1:6da924f: /*
20:6da924f: 
1:bca8108:    Derby - Class org.apache.derbyTesting.functionTests.tests.lang.streamsTest
1:6da924f: 
1:6da924f:    Licensed to the Apache Software Foundation (ASF) under one or more
1:6da924f:    contributor license agreements.  See the NOTICE file distributed with
1:6da924f:    this work for additional information regarding copyright ownership.
1:6da924f:    The ASF licenses this file to You under the Apache License, Version 2.0
1:6da924f:    (the "License"); you may not use this file except in compliance with
1:6da924f:    the License.  You may obtain a copy of the License at
1:6da924f: 
1:6da924f:       http://www.apache.org/licenses/LICENSE-2.0
1:6da924f: 
1:6da924f:    Unless required by applicable law or agreed to in writing, software
1:6da924f:    distributed under the License is distributed on an "AS IS" BASIS,
1:6da924f:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:6da924f:    See the License for the specific language governing permissions and
1:6da924f:    limitations under the License.
1:6da924f: 
1:6da924f:  */
1:6da924f: 
1:6da924f: package org.apache.derbyTesting.functionTests.tests.lang;
1:6da924f: 
1:a609b81: import java.io.IOException;
1:6da924f: import java.sql.PreparedStatement;
1:6da924f: import java.sql.ResultSet;
1:6da924f: import java.sql.SQLException;
1:6da924f: import java.sql.Statement;
1:6da924f: import java.sql.Types;
1:6da924f: import junit.framework.Test;
1:6da924f: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:6da924f: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1:6da924f: import org.apache.derbyTesting.junit.DatabasePropertyTestSetup;
1:6da924f: 
1:6da924f: /**
1:6da924f:   This tests streams, and when we should not materialize it. Beetle entry 4896, 4955.
1:6da924f: 
1:6da924f:   Some of the code comes from conn/largeStreams.java.  But this program figures out whether
1:6da924f:   a stream is materialized or not in a different way.  Part of the reason is that this test
1:6da924f:   should be run nightly to catch regressions and shouldn't require too much disk space.  It
1:6da924f:   figures out whether a stream is materialized or not by comparing the stack levels of different
1:6da924f:   cases.  The stack level is when reading the last byte of the stream.  According to the current
1:6da924f:   code, the stack is about 10 levels deeper when reading the stream from store per page (not
1:6da924f:   materialized before hand), comparing to the case when materializing from sql language layer.
1:6da924f:   We don't expect this to change dramatically for some time.  And this can always be adjusted
1:6da924f:   when needed.
1:6da924f: 
1:6da924f:   For bug 5592 - match db's limits for long varchar which is 32700. In order to enforce that limit
1:6da924f:   we now materialize the stream to make sure we are not trying to overstuff data in long varchar.
1:6da924f:   Because of this, I had to make some changes into the stack level checking for long varchars.
1:6da924f:   
1:6da924f:   Converted to Junit based StreamsTest from the old streams.java test.
1:6da924f:  */
1:6da924f: 
1:6da924f: public class StreamsTest extends BaseJDBCTestCase {
1:6da924f:     
1:6da924f:     public StreamsTest(String name) {
1:6da924f:         super(name);
25:6da924f:      }
1:6da924f:     
1:6da924f:     /**
1:6da924f:      * Only runs embedded as it is checking stack depths
1:6da924f:      * of when certain operations happen to streams.
1:6da924f:      * Stack depths from the network server would be different
1:6da924f:      * and test is not designed work with a network client.
1:6da924f:      */
1:6da924f:     public static Test suite() {
1:6da924f:         
1:1ae02c9:         Test test = new BaseTestSuite(StreamsTest.class, "StreamsTest");
1:6da924f:         
1:6da924f:         test = DatabasePropertyTestSetup.singleProperty(test,
1:6da924f:                 "derby.storage.pageSize", "2048");
1:6da924f:         
1:6da924f:         return new CleanDatabaseTestSetup(test) {
1:6da924f:             
1:6da924f:             protected void decorateSQL(Statement s) throws SQLException
1:6da924f:             {
1:6da924f:                 s.executeUpdate(
1:6da924f:                         "create table t1 (id int, pid int, lvc long varchar, " +
1:6da924f:                         "lvb long varchar for bit data)");
1:6da924f:                 s.executeUpdate("create table t2 (id int, pid int, " +
1:6da924f:                         "lvc long varchar, lvb long varchar for bit data)");
1:6da924f:                 s.executeUpdate("create trigger tr21 after insert on t2 " +
1:6da924f:                         "for each statement values 1");
1:6da924f:                 s.executeUpdate("create table t3 (id int not null primary key, " +
1:6da924f:                         "pid int, lvc long varchar, lvb long varchar for bit data, " +
1:6da924f:                         "CONSTRAINT FK1 Foreign Key(pid) REFERENCES T3 (id))");
1:6da924f:                 s.executeUpdate("create table t4 (id int, longcol long varchar)");
1:6da924f:                 s.executeUpdate("create table t5 (id int, longcol long varchar)");                
1:6da924f:             }
1:6da924f:             
1:6da924f:         };
1:6da924f:         
1:6da924f:     }
1:6da924f: 
1:6da924f:     /**
1:6da924f:      * Unique values for primary keys.
1:6da924f:      */
1:6da924f:     private int pkCount;
1:6da924f:     
1:6da924f:     public void testStreams() throws Exception {
1:6da924f:         
1:6da924f:         getConnection().setAutoCommit(false);
1:6da924f:         
1:6da924f:         Statement s = createStatement();
1:6da924f:         
1:6da924f:         PreparedStatement ps = prepareStatement(
1:6da924f:                 "insert into  t1 values(?, ?, ?,?)");
1:6da924f:         int level1 = insertLongString(ps, 8, true);
1:6da924f:         // materialized insert: got reader stack level
1:6da924f:         ps.close();
1:6da924f:         
1:6da924f:         ps = prepareStatement("insert into  t2 values(?, ?, ?,?)");
1:6da924f:         int level2 = insertLongString(ps, 8, true);
1:6da924f:         // materialized insert (for trigger): got reader stack level
1:6da924f:         assertEquals("FAILED!! level difference not expected since streams are materialized.",
1:6da924f:                 level1, level2);
1:6da924f:         ps.close();
1:6da924f:         
1:6da924f:         ps = prepareStatement("insert into  t3 values(?, ?, ?,?)");
1:6da924f:         int level3 = insertLongString(ps, 8, true);
1:6da924f:         ps.close();
1:6da924f:         
1:6da924f:         // self ref foreign key insert(should not materialize):
1:6da924f:         // got reader stack level");
1:6da924f:         assertEquals("FAILED!! should not materialize in this case.",
1:6da924f:                 level3, level1);
1:6da924f:         
1:6da924f:         rollback();
1:6da924f:         
1:6da924f:         s.executeUpdate(
1:6da924f:                 "insert into t3 values (1,1,'a',null)," +
1:6da924f:                 "(2,2,'b',null), (3,3,'c',null)");
1:6da924f:         ps = prepareStatement("update t3 set id = ?, lvc = ? where pid = 2");
1:6da924f:         level1 = insertLongString(ps, 8, false);
1:6da924f:         ps.close();
1:6da924f:         // materialized for multiple row update: got reader stack level
1:6da924f:         
1:6da924f:         ps = prepareStatement("update t3 set id = ?, lvc = ? where pid = 2 " +
1:6da924f:                 "and id = 2");
1:6da924f:         level2 = insertLongString(ps, 8, false);
1:6da924f:         ps.close();
1:6da924f:         // single row update: got reader stack level
1:6da924f:         assertEquals("FAILED!! level difference not expected because streams are materialized with fix for bug 5592.",
1:6da924f:                 level1, level2);
1:6da924f:         
1:6da924f:         s.executeUpdate("insert into t4 values (1, 'ccccc')");
1:6da924f:         ps = prepareStatement("insert into t4 values(?, ?)");
1:6da924f:         insertLongString(ps, 6, false);
1:f148f1f:         s.executeUpdate("insert into t4 values (3, 'abbb')");
1:6da924f:         s.executeUpdate("insert into t4 values (4, 'bbbbbb')");
1:6da924f:         insertLongString(ps, 5, false);
1:6da924f:         ps.close();
1:6da924f:         ResultSet rs = s
1:6da924f:         .executeQuery("select id, cast(longcol as varchar(8192)) lcol from t4 order by lcol");
1:6da924f:         
1:f148f1f:         assertTrue(rs.next()); // 3, abbb
1:6da924f:         assertEquals(3, rs.getInt(1));
1:f148f1f:         assertEquals("abbb", rs.getString(2));
1:6da924f:         
1:6da924f:         assertTrue(rs.next()); // 4, bbbbbb
1:6da924f:         assertEquals(4, rs.getInt(1));
1:6da924f:         assertEquals("bbbbbb", rs.getString(2));
1:6da924f:         
1:6da924f:         assertTrue(rs.next()); // 2, bbbbbb... (length 5393)
1:6da924f:         assertEquals(2, rs.getInt(1));
1:6da924f:         String col2 = rs.getString(2);
1:6da924f:         assertNotNull(col2);
1:6da924f:         assertEquals(5393, col2.length());
1:6da924f:         for (int i = 0; i < col2.length(); i++)
1:6da924f:             assertEquals('b', col2.charAt(i));
1:6da924f:         
1:6da924f:         assertTrue(rs.next()); // 2, bbbbbb... (length 6417)
1:6da924f:         assertEquals(2, rs.getInt(1));
1:6da924f:         col2 = rs.getString(2);
1:6da924f:         assertNotNull(col2);
1:6da924f:         assertEquals(6417, col2.length());
1:6da924f:         for (int i = 0; i < col2.length(); i++)
1:6da924f:             assertEquals('b', col2.charAt(i));   
1:6da924f:         
1:6da924f:         assertTrue(rs.next()); // 1, 'ccccc'
1:6da924f:         assertEquals(1, rs.getInt(1));
1:6da924f:         assertEquals("ccccc", rs.getString(2));
1:6da924f:         
1:6da924f:         assertFalse(rs.next());
1:6da924f:         rs.close();
1:6da924f:         
1:6da924f:         s.executeUpdate("insert into t5 values (1, 'bbbbbb')");
1:6da924f:         ps = prepareStatement("insert into t5 values(?, ?)");
1:6da924f:         insertLongString(ps, 5, false);
1:6da924f:         insertLongString(ps, 7, false);
1:6da924f:         ps.close();
1:6da924f:         s.executeUpdate("insert into t5 values (3, 'aaaaabbbbbba')");
1:6da924f:         s.executeUpdate("insert into t5 values (4, 'bbbbbbbbb')");
1:6da924f:         rs = s
1:6da924f:         .executeQuery("select t4.id, t4.longcol, t5.id, cast(t5.longcol as varchar(8192)) lcol from t4, t5 where cast(t4.longcol as varchar(8192)) = cast(t5.longcol as varchar(8192)) order by lcol");
1:6da924f:         
1:6da924f:         assertTrue(rs.next());
1:6da924f:         assertEquals(4, rs.getInt(1));
1:6da924f:         assertEquals(6, rs.getString(2).length());
1:6da924f:         assertEquals(1, rs.getInt(3));
1:6da924f:         assertEquals(6, rs.getString(4).length());
1:6da924f:         
1:6da924f:         assertTrue(rs.next());
1:6da924f:         assertEquals(2, rs.getInt(1));
1:6da924f:         assertEquals(5393, rs.getString(2).length());
1:6da924f:         assertEquals(2, rs.getInt(3));
1:6da924f:         assertEquals(5393, rs.getString(4).length());
1:6da924f:         
1:6da924f:         assertFalse(rs.next());
1:6da924f:         rs.close();
1:6da924f:         
1:6da924f:         // Start testing long var binary
1:6da924f:         rollback();
1:6da924f:         
1:6da924f:         ps = prepareStatement("insert into  t1 values(?, ?, ?,?)");
1:6da924f:         level1 = insertLongBinary(ps, 8);
1:6da924f:         ps.close();
1:6da924f:         // non materialized insert: got reader stack level");
1:6da924f:         
1:6da924f:         ps = prepareStatement("insert into  t2 values(?, ?, ?,?)");
1:6da924f:         level2 = insertLongBinary(ps, 8);
1:6da924f:         ps.close();
1:6da924f:         // materialized insert (for trigger): got reader stack level");
1:6da924f:         assertTrue("FAILED, check stack level change.",
1:6da924f:                 level1 > level2 + 5);
1:6da924f:         
1:6da924f:         
1:6da924f:         ps = prepareStatement("insert into  t3 values(?, ?, ?,?)");
1:6da924f:         level3 = insertLongBinary(ps, 8);
1:6da924f:         ps.close();
1:6da924f:         // self ref foreign key insert(should not materialize):
1:6da924f:         // got reader stack level");
1:6da924f:         assertEquals("FAILED!! should not materialize stream in this case.",
1:6da924f:                 level3, level1);
1:6da924f: 
1:6da924f:         
1:6da924f:         s.close();
1:6da924f:         rollback();
1:6da924f:     }
1:6da924f:     
1:6da924f:     private int insertLongString(PreparedStatement ps, int kchars,
1:6da924f:             boolean isInsert) throws SQLException {
1:6da924f:         // don't end on a clean boundary
1:6da924f:         int chars = (kchars * 1024) + 273;
1:6da924f:                 
1:6da924f:         DummyReader dr = new DummyReader(chars);
1:6da924f:         if (isInsert) {
1:6da924f:             ps.setInt(1, pkCount);
1:6da924f:             ps.setInt(2, pkCount++);
1:6da924f:             ps.setCharacterStream(3, dr, chars);
1:6da924f:             ps.setNull(4, Types.VARBINARY);
1:6da924f:         } else {
1:6da924f:             ps.setInt(1, 2);
1:6da924f:             ps.setCharacterStream(2, dr, chars);
1:6da924f:         }
1:6da924f:         
1:6da924f:         ps.executeUpdate();
1:6da924f:         
1:6da924f:         return dr.readerStackLevel;
1:6da924f:         
1:6da924f:     }
1:6da924f:     
1:6da924f:     private  int insertLongBinary(PreparedStatement ps, int kbytes)
1:6da924f:     throws SQLException {
1:6da924f:         
1:6da924f:         // add a small number of bytes to ensure that we are not always ending
1:6da924f:         // on a clean Mb boundary
1:6da924f:         int bytes = (kbytes * 1024) + 273;
1:6da924f:         
1:6da924f:         ps.setInt(1, pkCount);
1:6da924f:         ps.setInt(2, pkCount++);
1:6da924f:         ps.setNull(3, Types.LONGVARCHAR);
1:6da924f:         DummyBinary db = new DummyBinary(bytes);
1:6da924f:         ps.setBinaryStream(4, db, bytes);
1:6da924f:         
1:6da924f:         ps.executeUpdate();
1:6da924f:         
1:6da924f:         return db.readerStackLevel;
1:6da924f:     }
1:6da924f: }
1:6da924f: 
1:6da924f: class DummyReader extends java.io.Reader {
1:6da924f:     
1:6da924f:     private int count;
1:6da924f:     
1:6da924f:     public int readerStackLevel;
1:6da924f:     
1:6da924f:     DummyReader(int length) {
1:6da924f:         this.count = length;
1:6da924f:     }
1:6da924f:     
2:6da924f:     private void whereAmI() {
1:edcdf1e:         StackTraceElement[] stelements = new Throwable().getStackTrace();
1:6da924f:         if (count == 0) {
1:1d7133e:             // see DERBY-2318 - some jvms report a line like:
1:1d7133e:             // at java.lang.Throwable<init>. Ignore all Throwable lines
1:1d7133e:             // for the count.
1:edcdf1e:             if (stelements.toString().indexOf(
1:1d7133e:                     "java.lang.Throwable".toLowerCase()) >=0)
1:1d7133e:             {
1:1d7133e:                 readerStackLevel = 
1:edcdf1e:                     stelements.length - 1;
1:6da924f:             }
1:1d7133e:             else
1:edcdf1e:                 readerStackLevel = stelements.length;
1:6da924f:         }
1:6da924f:     }
1:6da924f:     
1:a609b81:     public int read() throws IOException {
1:6da924f:         if (count == 0)
1:6da924f:             return -1;
1:6da924f:         
1:6da924f:         count--;
1:6da924f:         whereAmI();
1:6da924f:         
1:6da924f:         return 'b';
1:6da924f:     }
1:6da924f:     
1:6da924f:     public int read(char[] buf, int offset, int length) {
1:6da924f:         
1:6da924f:         if (count == 0)
1:6da924f:             return -1;
1:6da924f:         
1:6da924f:         if (length > count)
1:6da924f:             length = count;
1:6da924f:         
1:6da924f:         count -= length;
1:6da924f:         whereAmI();
1:6da924f:         
1:6da924f:         java.util.Arrays.fill(buf, offset, offset + length, 'b');
1:6da924f:         
1:6da924f:         return length;
1:6da924f:     }
1:6da924f:     
2:6da924f:     public void close() {
1:1ae02c9:     }
1:a609b81: }
1:6da924f: 
1:6da924f: class DummyBinary extends java.io.InputStream {
1:6da924f:     
1:6da924f:     public int readerStackLevel;
1:6da924f:     
1:6da924f:     int count;
1:6da924f:     
1:6da924f:     byte content = 42;
1:6da924f:     
1:6da924f:     DummyBinary(int length) {
1:6da924f:         this.count = length;
1:6da924f:     }
1:6da924f:     
1:a609b81:     private void whereAmI()  {
1:6da924f:         if (count == 0) {
1:1d7133e:             // see DERBY-2318 - some jvms report a line like:
1:1d7133e:             // at java.lang.Throwable<init>. Ignore all Throwable lines
1:1d7133e:             // for the count.
1:1d7133e:             if ((new Throwable().getStackTrace().toString()).indexOf(
1:1d7133e:                     "java.lang.Throwable".toLowerCase()) >=0)
1:1d7133e:             {
1:1d7133e:                 readerStackLevel = 
1:1d7133e:                     new Throwable().getStackTrace().length - 1;
1:1d7133e:             }
1:1d7133e:             else
1:1d7133e:                 readerStackLevel = new Throwable().getStackTrace().length;
1:1d7133e:         }
1:6da924f:     }
1:6da924f:     
2:6da924f:     public int read() {
1:6da924f:         if (count == 0)
1:6da924f:             return -1;
1:6da924f:         
1:6da924f:         count--;
1:6da924f:         whereAmI();
1:6da924f:         return content++;
1:6da924f:     }
1:6da924f:     
1:a609b81:     public int read(byte[] buf, int offset, int length)  {
1:6da924f:         
1:6da924f:         if (count == 0)
1:6da924f:             return -1;
1:6da924f:         
1:6da924f:         if (length > count)
1:6da924f:             length = count;
1:6da924f:         
1:6da924f:         count -= length;
1:6da924f:         whereAmI();
1:6da924f:         
1:6da924f:         for (int i = 0; i < length; i++)
1:6da924f:             buf[offset + i] = content++;
1:6da924f:         
1:6da924f:         return length;
1:6da924f:     }
1:6da924f:     
1:6da924f:     public void close() {
1:6da924f:     }
1:6da924f: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.BaseTestSuite;
/////////////////////////////////////////////////////////////////////////
1:         Test test = new BaseTestSuite(StreamsTest.class, "StreamsTest");
/////////////////////////////////////////////////////////////////////////
1: }
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:bca8108
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derbyTesting.functionTests.tests.lang.streamsTest
commit:1d7133e
/////////////////////////////////////////////////////////////////////////
1:             // see DERBY-2318 - some jvms report a line like:
1:             // at java.lang.Throwable<init>. Ignore all Throwable lines
1:             // for the count.
1:             if ((new Throwable().getStackTrace().toString()).indexOf(
1:                     "java.lang.Throwable".toLowerCase()) >=0)
1:             {
1:                 readerStackLevel = 
1:                     new Throwable().getStackTrace().length - 1;
1:             }
1:             else
1:                 readerStackLevel = new Throwable().getStackTrace().length;
/////////////////////////////////////////////////////////////////////////
1:             // see DERBY-2318 - some jvms report a line like:
1:             // at java.lang.Throwable<init>. Ignore all Throwable lines
1:             // for the count.
0:             if ((new Throwable().getStackTrace().toString()).indexOf(
1:                     "java.lang.Throwable".toLowerCase()) >=0)
1:             {
1:                 readerStackLevel = 
0:                     new Throwable().getStackTrace().length - 1;
1:             }
1:             else
0:                 readerStackLevel = new Throwable().getStackTrace().length;
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:edcdf1e
/////////////////////////////////////////////////////////////////////////
1:         StackTraceElement[] stelements = new Throwable().getStackTrace();
1:             if (stelements.toString().indexOf(
1:                     stelements.length - 1;
1:                 readerStackLevel = stelements.length;
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:f148f1f
/////////////////////////////////////////////////////////////////////////
1:         s.executeUpdate("insert into t4 values (3, 'abbb')");
1:         assertTrue(rs.next()); // 3, abbb
1:         assertEquals("abbb", rs.getString(2));
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:a609b81
/////////////////////////////////////////////////////////////////////////
0: import java.io.ByteArrayInputStream;
0: import java.io.ByteArrayOutputStream;
1: import java.io.IOException;
0: import java.io.InputStreamReader;
0: import java.io.LineNumberReader;
0: import java.io.OutputStream;
0: import java.io.PrintWriter;
/////////////////////////////////////////////////////////////////////////
0:             readerStackLevel = new Throwable().getStackTrace().length;
1:     public int read() throws IOException {
/////////////////////////////////////////////////////////////////////////
1:     private void whereAmI()  {
0:             readerStackLevel = new Throwable().getStackTrace().length;
/////////////////////////////////////////////////////////////////////////
1:     public int read(byte[] buf, int offset, int length)  {
/////////////////////////////////////////////////////////////////////////
1: }
commit:6da924f
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Derby - Class org.apache.derbyTesting.functionTests.tests.lang.streams
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.tests.lang;
1: 
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: import java.sql.Statement;
1: import java.sql.Types;
1: 
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: 
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1: import org.apache.derbyTesting.junit.DatabasePropertyTestSetup;
1: 
1: /**
1:   This tests streams, and when we should not materialize it. Beetle entry 4896, 4955.
1: 
1:   Some of the code comes from conn/largeStreams.java.  But this program figures out whether
1:   a stream is materialized or not in a different way.  Part of the reason is that this test
1:   should be run nightly to catch regressions and shouldn't require too much disk space.  It
1:   figures out whether a stream is materialized or not by comparing the stack levels of different
1:   cases.  The stack level is when reading the last byte of the stream.  According to the current
1:   code, the stack is about 10 levels deeper when reading the stream from store per page (not
1:   materialized before hand), comparing to the case when materializing from sql language layer.
1:   We don't expect this to change dramatically for some time.  And this can always be adjusted
1:   when needed.
1: 
1:   For bug 5592 - match db's limits for long varchar which is 32700. In order to enforce that limit
1:   we now materialize the stream to make sure we are not trying to overstuff data in long varchar.
1:   Because of this, I had to make some changes into the stack level checking for long varchars.
1:   
1:   Converted to Junit based StreamsTest from the old streams.java test.
1:  */
1: 
1: public class StreamsTest extends BaseJDBCTestCase {
1:     
1:     public StreamsTest(String name) {
1:         super(name);
1:      }
1:     
1:     /**
1:      * Only runs embedded as it is checking stack depths
1:      * of when certain operations happen to streams.
1:      * Stack depths from the network server would be different
1:      * and test is not designed work with a network client.
1:      */
1:     public static Test suite() {
1:         
0:         Test test = new TestSuite(StreamsTest.class, "StreamsTest");
1:         
1:         test = DatabasePropertyTestSetup.singleProperty(test,
1:                 "derby.storage.pageSize", "2048");
1:         
1:         return new CleanDatabaseTestSetup(test) {
1:             
1:             protected void decorateSQL(Statement s) throws SQLException
1:             {
1:                 s.executeUpdate(
1:                         "create table t1 (id int, pid int, lvc long varchar, " +
1:                         "lvb long varchar for bit data)");
1:                 s.executeUpdate("create table t2 (id int, pid int, " +
1:                         "lvc long varchar, lvb long varchar for bit data)");
1:                 s.executeUpdate("create trigger tr21 after insert on t2 " +
1:                         "for each statement values 1");
1:                 s.executeUpdate("create table t3 (id int not null primary key, " +
1:                         "pid int, lvc long varchar, lvb long varchar for bit data, " +
1:                         "CONSTRAINT FK1 Foreign Key(pid) REFERENCES T3 (id))");
1:                 s.executeUpdate("create table t4 (id int, longcol long varchar)");
1:                 s.executeUpdate("create table t5 (id int, longcol long varchar)");                
1:             }
1:             
1:         };
1:         
1:     }
1: 
1:     /**
1:      * Unique values for primary keys.
1:      */
1:     private int pkCount;
1:     
1:     public void testStreams() throws Exception {
1:         
1:         getConnection().setAutoCommit(false);
1:         
1:         Statement s = createStatement();
1:         
1:         PreparedStatement ps = prepareStatement(
1:                 "insert into  t1 values(?, ?, ?,?)");
1:         int level1 = insertLongString(ps, 8, true);
1:         // materialized insert: got reader stack level
1:         ps.close();
1:         
1:         ps = prepareStatement("insert into  t2 values(?, ?, ?,?)");
1:         int level2 = insertLongString(ps, 8, true);
1:         // materialized insert (for trigger): got reader stack level
1:         assertEquals("FAILED!! level difference not expected since streams are materialized.",
1:                 level1, level2);
1:         ps.close();
1:         
1:         ps = prepareStatement("insert into  t3 values(?, ?, ?,?)");
1:         int level3 = insertLongString(ps, 8, true);
1:         ps.close();
1:         
1:         // self ref foreign key insert(should not materialize):
1:         // got reader stack level");
1:         assertEquals("FAILED!! should not materialize in this case.",
1:                 level3, level1);
1:         
1:         rollback();
1:         
1:         s.executeUpdate(
1:                 "insert into t3 values (1,1,'a',null)," +
1:                 "(2,2,'b',null), (3,3,'c',null)");
1:         ps = prepareStatement("update t3 set id = ?, lvc = ? where pid = 2");
1:         level1 = insertLongString(ps, 8, false);
1:         ps.close();
1:         // materialized for multiple row update: got reader stack level
1:         
1:         ps = prepareStatement("update t3 set id = ?, lvc = ? where pid = 2 " +
1:                 "and id = 2");
1:         level2 = insertLongString(ps, 8, false);
1:         ps.close();
1:         // single row update: got reader stack level
1:         assertEquals("FAILED!! level difference not expected because streams are materialized with fix for bug 5592.",
1:                 level1, level2);
1:         
1:         s.executeUpdate("insert into t4 values (1, 'ccccc')");
1:         ps = prepareStatement("insert into t4 values(?, ?)");
1:         insertLongString(ps, 6, false);
0:         s.executeUpdate("insert into t4 values (3, 'aaaaabbbbbb')");
1:         s.executeUpdate("insert into t4 values (4, 'bbbbbb')");
1:         insertLongString(ps, 5, false);
1:         ps.close();
1:         ResultSet rs = s
1:         .executeQuery("select id, cast(longcol as varchar(8192)) lcol from t4 order by lcol");
1:         
0:         assertTrue(rs.next()); // 3, aaaaabbbbbb
1:         assertEquals(3, rs.getInt(1));
0:         assertEquals("aaaaabbbbbb", rs.getString(2));
1:         
1:         assertTrue(rs.next()); // 4, bbbbbb
1:         assertEquals(4, rs.getInt(1));
1:         assertEquals("bbbbbb", rs.getString(2));
1:         
1:         assertTrue(rs.next()); // 2, bbbbbb... (length 5393)
1:         assertEquals(2, rs.getInt(1));
1:         String col2 = rs.getString(2);
1:         assertNotNull(col2);
1:         assertEquals(5393, col2.length());
1:         for (int i = 0; i < col2.length(); i++)
1:             assertEquals('b', col2.charAt(i));
1:         
1:         assertTrue(rs.next()); // 2, bbbbbb... (length 6417)
1:         assertEquals(2, rs.getInt(1));
1:         col2 = rs.getString(2);
1:         assertNotNull(col2);
1:         assertEquals(6417, col2.length());
1:         for (int i = 0; i < col2.length(); i++)
1:             assertEquals('b', col2.charAt(i));   
1:         
1:         assertTrue(rs.next()); // 1, 'ccccc'
1:         assertEquals(1, rs.getInt(1));
1:         assertEquals("ccccc", rs.getString(2));
1:         
1:         assertFalse(rs.next());
1:         rs.close();
1:         
1:         s.executeUpdate("insert into t5 values (1, 'bbbbbb')");
1:         ps = prepareStatement("insert into t5 values(?, ?)");
1:         insertLongString(ps, 5, false);
1:         insertLongString(ps, 7, false);
1:         ps.close();
1:         s.executeUpdate("insert into t5 values (3, 'aaaaabbbbbba')");
1:         s.executeUpdate("insert into t5 values (4, 'bbbbbbbbb')");
1:         rs = s
1:         .executeQuery("select t4.id, t4.longcol, t5.id, cast(t5.longcol as varchar(8192)) lcol from t4, t5 where cast(t4.longcol as varchar(8192)) = cast(t5.longcol as varchar(8192)) order by lcol");
1:         
1:         assertTrue(rs.next());
1:         assertEquals(4, rs.getInt(1));
1:         assertEquals(6, rs.getString(2).length());
1:         assertEquals(1, rs.getInt(3));
1:         assertEquals(6, rs.getString(4).length());
1:         
1:         assertTrue(rs.next());
1:         assertEquals(2, rs.getInt(1));
1:         assertEquals(5393, rs.getString(2).length());
1:         assertEquals(2, rs.getInt(3));
1:         assertEquals(5393, rs.getString(4).length());
1:         
1:         assertFalse(rs.next());
1:         rs.close();
1:         
1:         // Start testing long var binary
1:         rollback();
1:         
1:         ps = prepareStatement("insert into  t1 values(?, ?, ?,?)");
1:         level1 = insertLongBinary(ps, 8);
1:         ps.close();
1:         // non materialized insert: got reader stack level");
1:         
1:         ps = prepareStatement("insert into  t2 values(?, ?, ?,?)");
1:         level2 = insertLongBinary(ps, 8);
1:         ps.close();
1:         // materialized insert (for trigger): got reader stack level");
1:         assertTrue("FAILED, check stack level change.",
1:                 level1 > level2 + 5);
1:         
1:         
1:         ps = prepareStatement("insert into  t3 values(?, ?, ?,?)");
1:         level3 = insertLongBinary(ps, 8);
1:         ps.close();
1:         // self ref foreign key insert(should not materialize):
1:         // got reader stack level");
1:         assertEquals("FAILED!! should not materialize stream in this case.",
1:                 level3, level1);
1: 
1:         
1:         s.close();
1:         rollback();
1:     }
1:     
1:     private int insertLongString(PreparedStatement ps, int kchars,
1:             boolean isInsert) throws SQLException {
1:         // don't end on a clean boundary
1:         int chars = (kchars * 1024) + 273;
1:                 
1:         DummyReader dr = new DummyReader(chars);
1:         if (isInsert) {
1:             ps.setInt(1, pkCount);
1:             ps.setInt(2, pkCount++);
1:             ps.setCharacterStream(3, dr, chars);
1:             ps.setNull(4, Types.VARBINARY);
1:         } else {
1:             ps.setInt(1, 2);
1:             ps.setCharacterStream(2, dr, chars);
1:         }
1:         
1:         ps.executeUpdate();
1:         
1:         return dr.readerStackLevel;
1:         
1:     }
1:     
1:     private  int insertLongBinary(PreparedStatement ps, int kbytes)
1:     throws SQLException {
1:         
1:         // add a small number of bytes to ensure that we are not always ending
1:         // on a clean Mb boundary
1:         int bytes = (kbytes * 1024) + 273;
1:         
1:         ps.setInt(1, pkCount);
1:         ps.setInt(2, pkCount++);
1:         ps.setNull(3, Types.LONGVARCHAR);
1:         DummyBinary db = new DummyBinary(bytes);
1:         ps.setBinaryStream(4, db, bytes);
1:         
1:         ps.executeUpdate();
1:         
1:         return db.readerStackLevel;
1:     }
1: }
1: 
1: class DummyReader extends java.io.Reader {
1:     
1:     private int count;
1:     
1:     public int readerStackLevel;
1:     
1:     DummyReader(int length) {
1:         this.count = length;
1:     }
1:     
1:     private void whereAmI() {
1:         if (count == 0) {
0:             readerStackLevel = -1;
0:             try {
0:                 throw new Throwable();
0:             } catch (Throwable e) {
0:                 try {
0:                     readerStackLevel = e.getStackTrace().length;
0:                     // System.out.println("================= stack array length
0:                     // is: " + readerStackLevel);
0:                     // e.printStackTrace();
0:                 } catch (NoSuchMethodError nme) {
0:                     DummyOutputStream dos = new DummyOutputStream();
0:                     DummyPrintStream dps = new DummyPrintStream(dos);
0:                     e.printStackTrace(dps);
0:                     dps.flush();
0:                     // System.out.println("================= print to dop level
0:                     // num is: " + dps.lines);
0:                     readerStackLevel = dps.lines;
0:                     // e.printStackTrace();
1:                 }
1:             }
1:         }
1:     }
1:     
1:     public int read() {
1:         if (count == 0)
1:             return -1;
1:         
1:         count--;
1:         whereAmI();
1:         
1:         return 'b';
1:     }
1:     
1:     public int read(char[] buf, int offset, int length) {
1:         
1:         if (count == 0)
1:             return -1;
1:         
1:         if (length > count)
1:             length = count;
1:         
1:         count -= length;
1:         whereAmI();
1:         
1:         java.util.Arrays.fill(buf, offset, offset + length, 'b');
1:         
1:         return length;
1:     }
1:     
1:     public void close() {
1:     }
1: }
1: 
1: class DummyBinary extends java.io.InputStream {
1:     
1:     public int readerStackLevel;
1:     
1:     int count;
1:     
1:     byte content = 42;
1:     
1:     DummyBinary(int length) {
1:         this.count = length;
1:     }
1:     
1:     private void whereAmI() {
1:         if (count == 0) {
0:             readerStackLevel = -1;
0:             try {
0:                 throw new Throwable();
0:             } catch (Throwable e) {
0:                 try {
0:                     readerStackLevel = e.getStackTrace().length;
0:                     //	System.out.println("================= stack array length is: " + readerStackLevel);
0:                     //	e.printStackTrace();
0:                 } catch (NoSuchMethodError nme) {
0:                     DummyOutputStream dos = new DummyOutputStream();
0:                     DummyPrintStream dps = new DummyPrintStream(dos);
0:                     e.printStackTrace(dps);
0:                     dps.flush();
0:                     //	System.out.println("================= print to dop level num is: " + dps.lines);
0:                     readerStackLevel = dps.lines;
0:                     //	e.printStackTrace();
1:                 }
1:             }
1:         }
1:     }
1:     
1:     public int read() {
1:         if (count == 0)
1:             return -1;
1:         
1:         count--;
1:         whereAmI();
1:         return content++;
1:     }
1:     
0:     public int read(byte[] buf, int offset, int length) {
1:         
1:         if (count == 0)
1:             return -1;
1:         
1:         if (length > count)
1:             length = count;
1:         
1:         count -= length;
1:         whereAmI();
1:         
1:         for (int i = 0; i < length; i++)
1:             buf[offset + i] = content++;
1:         
1:         return length;
1:     }
1:     
1:     public void close() {
1:     }
1: }
1: 
0: class DummyOutputStream extends java.io.OutputStream {
1:     public void close() {
1:     }
1:     
0:     public void flush() {
1:     }
1:     
0:     public void write(byte[] b) {
1:     }
1:     
0:     public void write(byte[] b, int off, int len) {
1:     }
1:     
0:     public void write(int b) {
1:     }
1: }
1: 
0: class DummyPrintStream extends java.io.PrintStream {
0:     int lines;
1:     
0:     public DummyPrintStream(DummyOutputStream dos) {
0:         super(dos);
1:     }
1:     
0:     public void println() {
0:         lines++;
1:     }
1:     
0:     public void println(String x) {
0:         lines++;
1:     }
1:     
0:     public void println(Object x) {
0:         lines++;
1:     }
1:     
0:     public void println(char[] x) {
0:         lines++;
1:     }
1:     
0:     public void println(double x) {
0:         lines++;
1:     }
1:     
0:     public void println(float x) {
0:         lines++;
1:     }
1:     
0:     public void println(long x) {
0:         lines++;
1:     }
1:     
0:     public void println(int x) {
0:         lines++;
1:     }
1:     
0:     public void println(char x) {
0:         lines++;
1:     }
1:     
0:     public void println(boolean x) {
0:         lines++;
1:     }
1: }
============================================================================