1:1d94b69: /**
1:1ae02c9:  *  Derby - Class org.apache.derbyTesting.functionTests.tests.lang.ScrollCursors1Test
1:1d94b69:  *  
1:1d94b69:  * Licensed to the Apache Software Foundation (ASF) under one
1:1d94b69:  * or more contributor license agreements.  See the NOTICE file
1:1d94b69:  * distributed with this work for additional information
1:1d94b69:  * regarding copyright ownership.  The ASF licenses this file
1:1d94b69:  * to you under the Apache License, Version 2.0 (the
1:1d94b69:  * "License"); you may not use this file except in compliance
1:1d94b69:  * with the License.  You may obtain a copy of the License at
1:1d94b69:  *
1:1d94b69:  *   http://www.apache.org/licenses/LICENSE-2.0
1:1d94b69:  *
1:1d94b69:  * Unless required by applicable law or agreed to in writing,
1:1d94b69:  * software distributed under the License is distributed on an
1:1d94b69:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:1d94b69:  * KIND, either express or implied.  See the License for the
1:1d94b69:  * specific language governing permissions and limitations
1:1d94b69:  * under the License.
1:1d94b69:  */
5:1d94b69: 
1:1d94b69: package org.apache.derbyTesting.functionTests.tests.lang;
1:1d94b69: 
1:1d94b69: import java.sql.CallableStatement;
1:1ae02c9: import java.sql.Connection;
1:1d94b69: import java.sql.PreparedStatement;
1:1d94b69: import java.sql.ResultSet;
1:1d94b69: import java.sql.SQLException;
1:1d94b69: import java.sql.Statement;
1:1d94b69: import junit.framework.Test;
1:1d94b69: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:1d94b69: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1:1d94b69: import org.apache.derbyTesting.junit.JDBC;
1:1d94b69: import org.apache.derbyTesting.junit.RuntimeStatisticsParser;
1:1d94b69: import org.apache.derbyTesting.junit.TestConfiguration;
1:1d94b69: 
1:40c2e1d: public class ScrollCursors1Test extends BaseJDBCTestCase {
1:1d94b69: 
1:40c2e1d:     public ScrollCursors1Test(String name) {
1:1d94b69:         super(name);
1:1d94b69: 
1:1d94b69:     }
1:1d94b69: 
1:1d94b69:     public void testForwardOnlyNegative() throws SQLException {
1:1d94b69:         Connection conn = getConnection();
1:1d94b69:         PreparedStatement ps_c1 = conn.prepareStatement("select i from t1");
1:1d94b69:         ResultSet rs = ps_c1.executeQuery();
1:1d94b69:         try {
1:1d94b69:             rs.getRow();
1:1d94b69:             // client and embedded differ on getRow().
1:1d94b69:             // spec says getRow is optional for forward only cursors.
1:1d94b69:             if (usingEmbedded())
1:1d94b69:                 fail("getRow succeeded on forward only cursor");
1:1d94b69:         } catch (SQLException se) {
1:1d94b69:             assertSQLState("XJ061",se);
1:1d94b69:             
1:1d94b69:         }
1:1d94b69:         try {
1:1d94b69:             rs.first();
1:1d94b69:             fail("first() not allowed on forward only result set");
1:1d94b69:         } catch(SQLException se) {
1:1d94b69:             if (usingEmbedded())
1:1d94b69:                 assertSQLState("XJ061",se);
1:1d94b69:             else
1:1d94b69:                 assertSQLState("XJ125",se);
1:1d94b69:         }
1:1d94b69:         try {
1:1d94b69:             rs.last();
1:1d94b69:             fail("last() not allowed on forward only result set");
1:1d94b69:         } catch(SQLException se) {
1:1d94b69:             if (usingEmbedded())
1:1d94b69:                 assertSQLState("XJ061",se);
1:1d94b69:             else
1:1d94b69:                 assertSQLState("XJ125",se);
1:1d94b69:         }
1:1d94b69:         try {
1:1d94b69:             rs.previous();
1:1d94b69:             fail("previous() not allowed on forward only result set");
1:1d94b69:         } catch(SQLException se) {
1:1d94b69:             if (usingEmbedded())
1:1d94b69:                 assertSQLState("XJ061",se);
1:1d94b69:             else
1:1d94b69:                 assertSQLState("XJ125",se);
1:1d94b69:         }
1:1d94b69:         try {
1:1d94b69:             rs.beforeFirst();
1:1d94b69:             fail("beforeFirst() not allowed on forward only result set");
1:1d94b69:         } catch(SQLException se) {
1:1d94b69:             if (usingEmbedded())
1:1d94b69:                 assertSQLState("XJ061",se);
1:1d94b69:             else
1:1d94b69:                 assertSQLState("XJ125",se);
1:1d94b69:         }
1:1d94b69:         try {
1:1d94b69:             rs.afterLast();
1:1d94b69:             fail("afterLast() not allowed on forward only result set");
1:1d94b69:         } catch(SQLException se) {
1:1d94b69:             if (usingEmbedded())
1:1d94b69:                 assertSQLState("XJ061",se);
1:1d94b69:             else
1:1d94b69:                 assertSQLState("XJ125",se);
1:1d94b69:         }
1:1d94b69:         try {
1:1d94b69:             rs.absolute(1);
1:1d94b69:             fail("absolute() not allowed on forward only result set");
1:1d94b69:         } catch(SQLException se) {
1:1d94b69:             if (usingEmbedded())
1:1d94b69:                 assertSQLState("XJ061",se);
1:1d94b69:             else
1:1d94b69:                 assertSQLState("XJ125",se);
1:1d94b69:         }
1:1d94b69:         try {
1:1d94b69:             rs.relative(1);
1:1d94b69:             fail("relative() not allowed on forward only result set");
1:1d94b69:         } catch(SQLException se) {
1:1d94b69:             if (usingEmbedded())
1:1d94b69:                 assertSQLState("XJ061",se);
1:1d94b69:             else
1:1d94b69:                 assertSQLState("XJ125",se);
1:1d94b69:         }
1:1d94b69:         rs.close();
1:1d94b69:         ps_c1.close();
1:1d94b69:     }
1:1d94b69: 
1:1d94b69:         public void testScrollInsensitive() throws SQLException {
1:1d94b69:             Connection conn = getConnection();
1:1d94b69:             conn.setAutoCommit(false);
1:1d94b69:             PreparedStatement ps_c1 = conn.prepareStatement("select * from t1",
1:1d94b69:                         ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY );
1:1d94b69:             ResultSet rs = ps_c1.executeQuery();
1:1d94b69:             rs.absolute(0);
1:1d94b69:             assertNoCurrentRow(rs);
1:1d94b69:             rs.close();
1:1d94b69:             
1:1d94b69:             rs = ps_c1.executeQuery();
1:1d94b69:             rs.relative(0);
1:1d94b69:             assertNoCurrentRow(rs);
1:1d94b69:             rs.close();
1:1d94b69:             rs = ps_c1.executeQuery();
1:1d94b69:             
1:1d94b69:             rs.relative(2);
1:1d94b69:             assertEquals("c",rs.getString(1).trim());
1:1d94b69:             assertEquals(3, rs.getInt(2));
1:1d94b69:             rs.close();
1:1d94b69:             rs = ps_c1.executeQuery();
1:1d94b69:             rs.first();
1:1d94b69:             assertEquals("b", rs.getString(1).trim());
1:1d94b69:             assertEquals(2, rs.getInt(2));
1:1d94b69:             assertEquals(1, rs.getRow());
1:1d94b69:             rs.next();
1:1d94b69:             assertEquals("c",rs.getString(1).trim());
1:1d94b69:             assertEquals(3, rs.getInt(2));
1:1d94b69:             assertEquals(2,rs.getRow());
1:1d94b69:             assertEquals(2,rs.getRow());
1:1d94b69:             rs.first();
1:1d94b69:             assertEquals("b", rs.getString(1).trim());
1:1d94b69:             assertEquals(2, rs.getInt(2));
1:1d94b69:             assertEquals(1, rs.getRow());
1:1d94b69:             
1:1d94b69:             rs.next();
1:1d94b69:             assertEquals("c",rs.getString(1).trim());
1:1d94b69:             assertEquals(3, rs.getInt(2));
1:1d94b69:             assertEquals(2,rs.getRow());
1:1d94b69:             
1:1d94b69:             rs.next();
1:1d94b69:             assertEquals("d",rs.getString(1).trim());
1:1d94b69:             assertEquals(4, rs.getInt(2));
1:1d94b69:             assertEquals(3,rs.getRow());
1:1d94b69:             
1:1d94b69:             rs.first();
1:1d94b69:             assertEquals("b", rs.getString(1).trim());
1:1d94b69:             assertEquals(2, rs.getInt(2));
1:1d94b69:             assertEquals(1, rs.getRow());
1:1d94b69:             
1:1d94b69:             rs.next();
1:1d94b69:             assertEquals("c",rs.getString(1).trim());
1:1d94b69:             assertEquals(3, rs.getInt(2));
1:1d94b69:             assertEquals(2,rs.getRow());
1:1d94b69:             
1:1d94b69:             rs.afterLast();
1:1d94b69:             assertNoCurrentRow(rs);
1:1d94b69:             
1:1d94b69:             assertEquals(0,rs.getRow());
1:1d94b69:             assertFalse(rs.next());
1:1d94b69:             assertNoCurrentRow(rs);
1:1d94b69:             
1:1d94b69:             assertEquals(0,rs.getRow());
1:1d94b69:             
1:1d94b69:             rs.previous();
1:1d94b69:             assertEquals("m",rs.getString(1).trim());
1:1d94b69:             assertEquals(13, rs.getInt(2));
1:1d94b69:             assertEquals(12, rs.getRow());
1:1d94b69:             rs.previous();
1:1d94b69:             assertEquals("l",rs.getString(1).trim());
1:1d94b69:             assertEquals(12, rs.getInt(2));
1:1d94b69:             assertEquals(11, rs.getRow());
1:1d94b69:             
1:1d94b69:             rs.last();
1:1d94b69:             assertEquals("m",rs.getString(1).trim());
1:1d94b69:             assertEquals(13, rs.getInt(2));
1:1d94b69:             assertEquals(12, rs.getRow());
1:1d94b69:             rs.beforeFirst();
1:1d94b69:             assertNoCurrentRow(rs);
1:1d94b69:             assertEquals(0,rs.getRow());
1:1d94b69:             rs.next();
1:1d94b69:             assertEquals("b", rs.getString(1).trim());
1:1d94b69:             assertEquals(2, rs.getInt(2));
1:1d94b69:             assertEquals(1, rs.getRow());
1:1d94b69:             
1:1d94b69:             rs.absolute(12);
1:1d94b69:             assertEquals("m",rs.getString(1).trim());
1:1d94b69:             assertEquals(13, rs.getInt(2));
1:1d94b69:             assertEquals(12, rs.getRow());
1:1d94b69:             
1:1d94b69:             rs.absolute(-11);
1:1d94b69:             assertEquals("c",rs.getString(1).trim());
1:1d94b69:             assertEquals(3, rs.getInt(2));
1:1d94b69:             assertEquals(2,rs.getRow());
1:1d94b69:             
1:1d94b69:             rs.absolute(13);
1:1d94b69:             assertNoCurrentRow(rs);
1:1d94b69:             assertEquals(0,rs.getRow());
1:1d94b69:             
1:1d94b69:             
1:1d94b69:             rs.absolute(-1);
1:1d94b69:             assertEquals("m",rs.getString(1).trim());
1:1d94b69:             assertEquals(13, rs.getInt(2));
1:1d94b69:             assertEquals(12, rs.getRow());
1:1d94b69:             rs.close();
1:1d94b69:    
1:1d94b69:             rs = ps_c1.executeQuery();
1:1d94b69:             // do last first
1:1d94b69:             rs.last();
1:1d94b69:             assertEquals("m",rs.getString(1).trim());
1:1d94b69:             assertEquals(13, rs.getInt(2));
1:1d94b69:             assertEquals(12, rs.getRow());
1:1d94b69:             
1:1d94b69:             assertFalse(rs.next());
1:1d94b69:             assertNoCurrentRow(rs);
1:1d94b69:            
1:1d94b69:             rs.last();
1:1d94b69:             assertEquals("m",rs.getString(1).trim());
1:1d94b69:             assertEquals(13, rs.getInt(2));
1:1d94b69:             assertEquals(12, rs.getRow());
1:1d94b69:             
1:1d94b69:             rs.previous();
1:1d94b69:             assertEquals("l",rs.getString(1).trim());
1:1d94b69:             assertEquals(12, rs.getInt(2));
1:1d94b69:             assertEquals(11, rs.getRow());
1:1d94b69:             
1:1d94b69:             rs.first();
1:1d94b69:             assertEquals("b", rs.getString(1).trim());
1:1d94b69:             assertEquals(2, rs.getInt(2));
1:1d94b69:             assertEquals(1, rs.getRow());
1:1d94b69: 
1:1d94b69:             rs.previous();
1:1d94b69:             assertNoCurrentRow(rs);
1:1d94b69:             rs.next();
1:1d94b69:             assertEquals("b", rs.getString(1).trim());
1:1d94b69:             assertEquals(2, rs.getInt(2));
1:1d94b69:             assertEquals(1, rs.getRow());
1:1d94b69:             rs.close();
1:1d94b69:             
1:1d94b69:             // afterLast first
1:1d94b69:             rs = ps_c1.executeQuery();
1:1d94b69:             rs.afterLast();
1:1d94b69:             assertNoCurrentRow(rs);
1:1d94b69:             rs.previous();
1:1d94b69:             
1:1d94b69:             assertEquals("m",rs.getString(1).trim());
1:1d94b69:             assertEquals(13, rs.getInt(2));
1:1d94b69:             assertEquals(12, rs.getRow());
1:1d94b69:             
1:1d94b69:             rs.previous();
1:1d94b69:             assertEquals("l",rs.getString(1).trim());
1:1d94b69:             assertEquals(12, rs.getInt(2));
1:1d94b69:             assertEquals(11, rs.getRow());
1:1d94b69:             
1:1d94b69:             rs.close();
1:1d94b69:             
1:1d94b69:             // go to next to last row and then do next
1:1d94b69:             ps_c1.close();
1:1d94b69:             ps_c1 = conn.prepareStatement("select * from t1 where i >=11",
1:1d94b69:                     ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
1:1d94b69:             rs = ps_c1.executeQuery();
1:1d94b69:             rs.next();
1:1d94b69:             assertEquals("k",rs.getString(1).trim());
1:1d94b69:             assertEquals(11, rs.getInt(2));
1:1d94b69:             assertEquals(1, rs.getRow());
1:1d94b69:             
1:1d94b69:             rs.next();
1:1d94b69:             assertEquals("l",rs.getString(1).trim());
1:1d94b69:             assertEquals(12, rs.getInt(2));
1:1d94b69:             assertEquals(2, rs.getRow());
1:1d94b69:             
1:1d94b69:             rs.last();
1:1d94b69:             assertEquals("m",rs.getString(1).trim());
1:1d94b69:             assertEquals(13, rs.getInt(2));
1:1d94b69:             assertEquals(3, rs.getRow());
1:1d94b69:             
1:1d94b69:             rs.previous();
1:1d94b69:             assertEquals("l",rs.getString(1).trim());
1:1d94b69:             assertEquals(12, rs.getInt(2));
1:1d94b69:             assertEquals(2, rs.getRow());
1:1d94b69:             
1:1d94b69:             rs.afterLast();
1:1d94b69:             assertNoCurrentRow(rs);
1:1d94b69:             
1:1d94b69:             rs.previous();
1:1d94b69:             assertEquals("m",rs.getString(1).trim());
1:1d94b69:             assertEquals(13, rs.getInt(2));
1:1d94b69:             assertEquals(3, rs.getRow());
1:1d94b69:             rs.close();
1:1d94b69:             // start at after ;ast/
1:1d94b69:             rs = ps_c1.executeQuery();
1:1d94b69:             rs.afterLast();
1:1d94b69:             assertNoCurrentRow(rs);
1:1d94b69:             
1:1d94b69:             rs.previous();
1:1d94b69:             assertEquals("m",rs.getString(1).trim());
1:1d94b69:             assertEquals(13, rs.getInt(2));
1:1d94b69:             assertEquals(3, rs.getRow());
1:1d94b69:             rs.close();
1:1d94b69:             ps_c1.close();
1:1d94b69:             // use absolute to get rows before scan would get to them.
1:1d94b69:            ps_c1 = conn.prepareStatement("select i from t1", ResultSet.TYPE_SCROLL_INSENSITIVE,
1:1d94b69:                    ResultSet.CONCUR_READ_ONLY);
1:1d94b69:            rs = ps_c1.executeQuery();
1:1d94b69:            rs.absolute(5);
1:1d94b69:            assertEquals(6, rs.getInt(1));
1:1d94b69:            assertEquals(5, rs.getRow());
1:1d94b69:            
1:1d94b69:            rs.absolute(-5);
1:1d94b69:            assertEquals(9,rs.getInt(1));
1:1d94b69:            assertEquals(8, rs.getRow());
1:1d94b69: 
1:1d94b69:            rs.absolute(5);
1:1d94b69:            assertEquals(6,rs.getInt(1));
1:1d94b69:            assertEquals(5, rs.getRow());
1:1d94b69:            rs.close();
1:1d94b69:            rs = ps_c1.executeQuery();
1:1d94b69:            rs.absolute(13);
1:1d94b69:            assertNoCurrentRow(rs);
1:1d94b69:            
1:1d94b69:            rs.previous();
1:1d94b69:            assertEquals(13, rs.getInt(1));
1:1d94b69:            assertEquals(12, rs.getRow());
1:1d94b69:            rs.close();
1:1d94b69:            rs = ps_c1.executeQuery();
1:1d94b69:            rs.absolute(-13);
1:1d94b69:            assertNoCurrentRow(rs);
1:1d94b69:            rs.next();
1:1d94b69:            assertEquals(2, rs.getInt(1));
1:1d94b69:            assertEquals(1,rs.getRow());
1:1d94b69:            rs.close();
1:1d94b69:            rs = ps_c1.executeQuery();
1:1d94b69:            rs.first();
1:1d94b69:            assertEquals(2,rs.getInt(1)); 
1:1d94b69:            assertEquals(1,rs.getRow());
1:1d94b69:            
1:1d94b69:            rs.relative(11);
1:1d94b69:            assertEquals(13, rs.getInt(1));
1:1d94b69:            assertEquals(12, rs.getRow());
1:1d94b69:            
1:1d94b69:            rs.relative(1);
1:1d94b69:            assertNoCurrentRow(rs);
1:1d94b69:            rs.last();
1:1d94b69:            assertEquals(13, rs.getInt(1));
1:1d94b69:            assertEquals(12,rs.getRow());
1:1d94b69:            
1:1d94b69:            rs.relative(-11);
1:1d94b69:            assertEquals(2,rs.getInt(1));
1:1d94b69:            assertEquals(1,rs.getRow());
1:1d94b69:            rs.close();
1:1d94b69:            ps_c1.close();
1:1d94b69:            conn.commit();
1:1d94b69:            // scroll sensitive cursor becomes scroll insensitive.
1:1d94b69:            ps_c1 = conn.prepareStatement("Select i from t1", ResultSet.TYPE_SCROLL_SENSITIVE,
1:1d94b69:                    ResultSet.CONCUR_READ_ONLY);    
1:1d94b69:            
1:1d94b69:            rs = ps_c1.executeQuery();
1:1d94b69:            rs.first();
1:1d94b69:            assertEquals(2,rs.getInt(1));
1:1d94b69:            rs.next();
1:1d94b69:            assertEquals(3,rs.getInt(1));
1:1d94b69:            Statement s = conn.createStatement();
1:1d94b69:            s.executeUpdate("update t1 set i = 666 where i = 2");
1:1d94b69:            rs.first();
1:1d94b69:            conn.rollback();
1:1d94b69:            rs.close();
1:1d94b69:            // verify that statement cache works correctly with scroll and forward only cursors.
1:1d94b69:            // with the same query text.
1:1d94b69:            ps_c1 = conn.prepareStatement("select i from t1", ResultSet.TYPE_SCROLL_INSENSITIVE,
1:1d94b69:                    ResultSet.CONCUR_READ_ONLY);
1:1d94b69:            rs = ps_c1.executeQuery();
1:1d94b69:            PreparedStatement ps_c2 = conn.prepareStatement("select i from t1");
1:1d94b69:            ResultSet rs2 = ps_c2.executeQuery();
1:1d94b69:            rs.first();
1:1d94b69:            assertEquals(2,rs.getInt(1));
1:1d94b69:            rs2.next();
1:1d94b69:            assertEquals(2,rs2.getInt(1));
1:1d94b69:            try {
1:1d94b69:                rs2.first();
1:1d94b69:                fail("first() not allowed on forward only result set");
1:1d94b69:            } catch(SQLException se) {
1:1d94b69:                if (usingEmbedded())
1:1d94b69:                    assertSQLState("XJ061",se);
1:1d94b69:                else
1:1d94b69:                    assertSQLState("XJ125",se);
1:1d94b69:            }
1:1d94b69:             rs.close();
1:1d94b69:             rs2.close();
1:1d94b69:             ps_c1.close();
1:1d94b69:             ps_c1.close();
1:1d94b69:             // first, last, etc on empty result set
1:1d94b69:             ps_c1 = conn.prepareStatement("select i from t1 where 1=0",
1:1d94b69:                     ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
1:1d94b69:             rs = ps_c1.executeQuery();
1:1d94b69:             rs.first();
1:1d94b69:             assertNoCurrentRow(rs);
1:1d94b69:             rs.previous();
1:1d94b69:             assertNoCurrentRow(rs);
1:1d94b69:             rs.next();
1:1d94b69:             assertNoCurrentRow(rs);
1:1d94b69:             rs.last();
1:1d94b69:             assertNoCurrentRow(rs);
1:1d94b69:             rs.previous();
1:1d94b69:             assertNoCurrentRow(rs);
1:1d94b69:             rs.absolute(1);
1:1d94b69:             assertNoCurrentRow(rs);
1:1d94b69:             rs.absolute(-1);
1:1d94b69:             assertNoCurrentRow(rs);
1:1d94b69:             assertEquals(0,rs.getRow());
1:1d94b69:             rs.close();
1:1d94b69:             rs = ps_c1.executeQuery();
1:1d94b69:             rs.afterLast();
1:1d94b69:             assertNoCurrentRow(rs);
1:1d94b69:             rs.previous();
1:1d94b69:             assertNoCurrentRow(rs);
1:1d94b69:             rs.beforeFirst();
1:1d94b69:             assertNoCurrentRow(rs);
1:1d94b69:             rs.next();
1:1d94b69:             assertNoCurrentRow(rs);
1:1d94b69:             rs.close();
1:1d94b69:             rs = ps_c1.executeQuery();
1:1d94b69:             rs.absolute(1);
1:1d94b69:             assertNoCurrentRow(rs);
1:1d94b69:             rs.absolute(-1);
1:1d94b69:             assertNoCurrentRow(rs);
1:1d94b69:             rs.close();
1:1d94b69:             rs = ps_c1.executeQuery();
1:1d94b69:             rs.absolute(-1);
1:1d94b69:             assertNoCurrentRow(rs);
1:1d94b69:             rs.absolute(1);
1:1d94b69:             assertNoCurrentRow(rs);
1:1d94b69:             rs.close();
1:1d94b69:             // with autocommit on
1:1d94b69:             conn.setAutoCommit(false);
1:1d94b69:             rs = ps_c1.executeQuery();
1:1d94b69:             rs = ps_c1.executeQuery();
1:1d94b69:             rs.first();
1:1d94b69:             assertNoCurrentRow(rs);
1:1d94b69:             rs.previous();
1:1d94b69:             assertNoCurrentRow(rs);
1:1d94b69:             rs.next();
1:1d94b69:             assertNoCurrentRow(rs);
1:1d94b69:             rs.last();
1:1d94b69:             assertNoCurrentRow(rs);
1:1d94b69:             rs.previous();
1:1d94b69:             assertNoCurrentRow(rs);
1:1d94b69:             rs.absolute(1);
1:1d94b69:             assertNoCurrentRow(rs);
1:1d94b69:             rs.absolute(-1);
1:1d94b69:             assertNoCurrentRow(rs);
1:1d94b69:             rs.next();
1:1d94b69:             assertNoCurrentRow(rs);
1:1d94b69:             rs.next();
1:1d94b69:             assertNoCurrentRow(rs);
1:1d94b69:             rs.close();
1:1d94b69:             ps_c1.close();
1:1d94b69:             
1:1d94b69:             // cursor on a sort
1:1d94b69:             ps_c1 = conn.prepareStatement("select * from t1 order by i desc",ResultSet.TYPE_SCROLL_INSENSITIVE,
1:1d94b69:                     ResultSet.CONCUR_READ_ONLY);
1:1d94b69:             rs = ps_c1.executeQuery();
1:1d94b69:             rs.last();
1:1d94b69:             assertEquals("b",rs.getString(1).trim());
1:1d94b69:             assertEquals(2,rs.getInt(2));
1:1d94b69:             rs.first();
1:1d94b69:             assertEquals("m",rs.getString(1).trim());
1:1d94b69:             assertEquals(13,rs.getInt(2));
1:1d94b69:             rs.relative(11);
1:1d94b69:             assertEquals("b",rs.getString(1).trim());
1:1d94b69:             assertEquals(2,rs.getInt(2));
1:1d94b69:             rs.previous();
1:1d94b69:             assertEquals("c",rs.getString(1).trim());
1:1d94b69:             assertEquals(3,rs.getInt(2));
1:1d94b69:             rs.close();
1:1d94b69:             ps_c1.close();
1:1d94b69:             ps_c1 = conn.prepareStatement("select * from t1",
1:1d94b69:                     ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
1:1d94b69:             CallableStatement cs = conn.prepareCall("call SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)");
1:1d94b69:             cs.execute();
1:1d94b69:             cs.close();
1:1d94b69:             rs = ps_c1.executeQuery();
1:1d94b69:             rs.last();
1:1d94b69:             assertEquals("m",rs.getString(1).trim());
1:1d94b69:             assertEquals(13,rs.getInt(2));
1:1d94b69:             rs.first();
1:1d94b69:             assertEquals("b",rs.getString(1).trim());
1:1d94b69:             assertEquals(2,rs.getInt(2));
1:1d94b69:             rs.next();
1:1d94b69:             assertEquals("c",rs.getString(1).trim());
1:1d94b69:             assertEquals(3,rs.getInt(2));
1:1d94b69:             rs.close();
1:1d94b69:             rs2 = s.executeQuery("values SYSCS_UTIL.SYSCS_GET_RUNTIMESTATISTICS()");
1:1d94b69:             rs2.next();
1:1d94b69:                     
1:1d94b69:             if (usingEmbedded())
1:1d94b69:             {
1:1d94b69:                 // not sure why I get a null rts with network server.
1:1d94b69:                 RuntimeStatisticsParser rts = new RuntimeStatisticsParser(rs2.getString(1));
1:1d94b69:                 rs2.close();
1:1d94b69:                 assertEquals(Connection.TRANSACTION_READ_COMMITTED, rts.getIsolationLevel());
1:1d94b69:                 assertTrue(rts.usedTableScan());
1:1d94b69:                 assertTrue(rts.isScrollInsensitive());
1:1d94b69:             }
1:1d94b69:          
1:1d94b69:             rs.close();  
1:1d94b69:             ps_c1.close();
1:1d94b69:         }
1:1d94b69: 
1:1d94b69:         public void testNoHoldScrollableResults() throws SQLException{
1:1d94b69:             Connection conn = getConnection();
1:1d94b69:             conn.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);
1:1d94b69:             // Beetle 4551 - insensitive cursor uses estimated row count which 
1:1d94b69:             // might be pessimistic and will get out of memory error
1:1d94b69:             Statement s = createStatement();
1:1d94b69:             s.executeUpdate("create table big(a int generated always as identity (start with 1, increment by 1))");
1:1d94b69:             
1:1d94b69:             for (int i = 0; i < 10; i++)
1:1d94b69:                 s.executeUpdate("insert into big values(default)");
1:1d94b69:             
1:1d94b69:          PreparedStatement ps_c1 = conn.prepareStatement("select * from big b1 left outer join  big b2 on b1.a = b2.a left outer join  big b3 on b2.a = b3.a left outer join big b4 on b3.a = b4.a left outer join (big b5 left outer join (big b6 left outer join (big b7 left outer join big b8 on b7.a = b8.a) on b6.a=b7.a) on b5.a = b6.a) on b4.a = b5.a");
1:1d94b69:          ResultSet rs = ps_c1.executeQuery();
1:1d94b69:          s.executeUpdate("drop table big");
1:1d94b69:         }
1:1d94b69:         
1:40c2e1d:         public void testSimpleScrollCursors() throws SQLException {
1:40c2e1d:             Connection conn = getConnection();
1:40c2e1d:             Statement s = conn.createStatement();
1:40c2e1d:             s.executeUpdate("create table t (a int)");
1:40c2e1d:             PreparedStatement ps = conn.prepareStatement("insert into t values (?)");
1:40c2e1d:             for (int i = 1; i <=5; i++)
1:40c2e1d:             {
1:40c2e1d:                 ps.setInt(1, i);
1:40c2e1d:                 ps.executeUpdate();
1:40c2e1d:             }
1:40c2e1d:             ps.close();
1:40c2e1d:             PreparedStatement ps_c1 = conn.prepareStatement("select * from t", ResultSet.TYPE_SCROLL_INSENSITIVE,
1:40c2e1d:                     ResultSet.CONCUR_READ_ONLY);
1:40c2e1d:             ResultSet rs = ps_c1.executeQuery();
1:40c2e1d:             rs.first();
1:40c2e1d:             assertEquals(1,rs.getInt(1));
1:40c2e1d:             rs.next();
1:40c2e1d:             assertEquals(2,rs.getInt(1));
1:40c2e1d:             rs.previous();
1:40c2e1d:             assertEquals(1,rs.getInt(1));
1:40c2e1d:             rs.last();
1:40c2e1d:             assertEquals(5,rs.getInt(1));
1:40c2e1d:             rs.absolute(2);
1:40c2e1d:             assertEquals(2, rs.getInt(1));
1:40c2e1d:             rs.relative(2);
1:40c2e1d:             assertEquals(4,rs.getInt(1));
1:40c2e1d:             rs.close();
1:40c2e1d:             // since JCC gets 64 results and then scrolls within them
1:40c2e1d:             // lets try each p ositioning command as the first command for the cursor.
1:40c2e1d:             rs = ps_c1.executeQuery();
1:40c2e1d:             rs.next();
1:40c2e1d:             assertEquals(1,rs.getInt(1));
1:40c2e1d:             rs.close();
1:40c2e1d:             rs = ps_c1.executeQuery();
1:40c2e1d:             rs.last();
1:40c2e1d:             assertEquals(5,rs.getInt(1));
1:40c2e1d:             rs.close();
1:40c2e1d:             rs = ps_c1.executeQuery();
1:40c2e1d:             rs.absolute(3);
1:40c2e1d:             assertEquals(3,rs.getInt(1));
1:40c2e1d:             rs.next();
1:40c2e1d:             assertEquals(4,rs.getInt(1));
1:40c2e1d:             rs.close();
1:40c2e1d:             ps_c1.close();
1:40c2e1d:             // lets try a table with more than 64 rows.
1:40c2e1d:             s.executeUpdate("create table tab1 (a int)");
1:40c2e1d:             PreparedStatement is = conn.prepareStatement("insert into tab1 values (?)");
1:40c2e1d:             for (int i = 1; i <= 70; i++) {
1:40c2e1d:                 is.setInt(1, i);
1:40c2e1d:                 is.executeUpdate();
1:40c2e1d:             }
1:40c2e1d:             ps_c1 = conn.prepareStatement("select * from tab1",ResultSet.TYPE_SCROLL_INSENSITIVE,
1:40c2e1d:                     ResultSet.CONCUR_READ_ONLY);
1:40c2e1d:             rs = ps_c1.executeQuery();
1:40c2e1d:             rs.first();
1:40c2e1d:             assertEquals(1,rs.getInt(1));
1:40c2e1d:             rs.last();
1:40c2e1d:             assertEquals(70,rs.getInt(1));
1:40c2e1d:             rs.absolute(65);
1:40c2e1d:             assertEquals(65,rs.getInt(1));
1:40c2e1d:             rs.absolute(-1);
1:40c2e1d:             assertEquals(70,rs.getInt(1));
1:40c2e1d:             rs.close();
1:40c2e1d:             ps_c1.close();
1:40c2e1d:             // try sensitive scroll cursors bug 4677
1:40c2e1d:             ps_c1 = conn.prepareStatement("select * from t1",ResultSet.TYPE_SCROLL_SENSITIVE,
1:40c2e1d:                         ResultSet.CONCUR_READ_ONLY);
1:40c2e1d:             rs = ps_c1.executeQuery();
1:40c2e1d:             rs.close();
1:40c2e1d:             ps_c1.close();
1:40c2e1d:             ps_c1 = conn.prepareStatement("select * from t1 for update",ResultSet.TYPE_SCROLL_SENSITIVE,
1:40c2e1d:                     ResultSet.CONCUR_UPDATABLE);
1:40c2e1d:             rs.close();
1:40c2e1d:             s.executeUpdate("drop table tab1");
1:40c2e1d:             // defect 5225, outer joins returning NULLS
1:40c2e1d:             s.executeUpdate("create table tab1(i1 bigint not null, c1 varchar(64) not null)");
1:40c2e1d:             s.executeUpdate("create table tab2 (i2 bigint not null, c2 varchar(64) not null)");
1:40c2e1d:             s.executeUpdate("insert into tab1 values (1, 'String 1')");
1:40c2e1d:             s.executeUpdate("insert into tab1 values (2, 'String 2')");
1:40c2e1d:             s.executeUpdate("insert into tab2 values (1, 'String 1')");
1:40c2e1d:             s.executeUpdate("insert into tab2 values (3, 'String 3')");
1:40c2e1d:             rs = s.executeQuery("select c1 from tab1 right outer join tab2 on (i1=i2)");
1:40c2e1d:             JDBC.assertFullResultSet(rs, new String[][] {{"String 1"},{null}});
1:40c2e1d:             rs = s.executeQuery("select c2 from tab1 right outer join tab2 on (i1=i2)");
1:40c2e1d:             JDBC.assertFullResultSet(rs, new String[][] {{"String 1"},{"String 3"}});
1:40c2e1d:             // left outer join
1:40c2e1d:             rs = s.executeQuery("select c1 from tab1 left outer join tab2 on (i1=i2)");
1:40c2e1d:             JDBC.assertFullResultSet(rs, new String[][] {{"String 1"},{"String 2"}});
1:40c2e1d:             rs = s.executeQuery("select c2 from tab1 left outer join tab2 on (i1=i2)");
1:40c2e1d:             JDBC.assertFullResultSet(rs, new String[][] {{"String 1"},{null}});
1:40c2e1d:             s.executeUpdate("drop table t");
1:40c2e1d:             s.executeUpdate("drop table tab1");
1:40c2e1d:             s.executeUpdate("drop table tab2");            
1:40c2e1d:         }
1:40c2e1d:         
1:1d94b69:         public void testScrollCursors3() throws SQLException {
1:1d94b69:             Connection conn = getConnection();
1:1d94b69:             Connection conn2 = openDefaultConnection();
1:1d94b69:             Statement s = conn.createStatement();
1:1d94b69:             s.executeUpdate("create table u1.t1(c1 int, c2 int)");
1:1d94b69:             s.executeUpdate("insert into u1.t1 values (1, 2), (3, 4), (5, 6), (7, 8), (9, 10)");
1:1d94b69:             PreparedStatement ps_c1 = conn.prepareStatement("select * from u1.t1", ResultSet.TYPE_SCROLL_INSENSITIVE,
1:1d94b69:                     ResultSet.CONCUR_READ_ONLY);
1:1d94b69:             ResultSet rs = ps_c1.executeQuery();
1:1d94b69:             
1:1d94b69:             // see what happens when other user when we close our cursor before
1:1d94b69:             // they are done.
1:1d94b69:             PreparedStatement ps_c2 = conn2.prepareStatement("select * from u1.t1", ResultSet.TYPE_SCROLL_INSENSITIVE,
1:1d94b69:                     ResultSet.CONCUR_READ_ONLY);
1:1d94b69:             ResultSet rs2 = ps_c2.executeQuery();
1:1d94b69:             rs.next();
1:1d94b69:             assertEquals(1, rs.getInt(1));
1:1d94b69:             assertEquals(2, rs.getInt(2));
1:1d94b69:             
1:1d94b69:             rs2.next();
1:1d94b69:             assertEquals(1, rs.getInt(1));
1:1d94b69:             assertEquals(2, rs.getInt(2));
1:1d94b69:             rs.last();
1:1d94b69:             assertEquals(9, rs.getInt(1));
1:1d94b69:             assertEquals(10, rs.getInt(2));
1:1d94b69:             rs2.last();
1:1d94b69:             assertEquals(9, rs.getInt(1));
1:1d94b69:             assertEquals(10, rs.getInt(2));
1:1d94b69:             rs.previous();
1:1d94b69:             assertEquals(7, rs.getInt(1));
1:1d94b69:             assertEquals(8, rs.getInt(2));
1:1d94b69:             rs2.close();
1:1d94b69:             rs.first();
1:1d94b69:             assertEquals(1, rs.getInt(1));
1:1d94b69:             assertEquals(2, rs.getInt(2));
1:1d94b69:             rs.close();
1:8a319fb:             s.executeUpdate("drop table u1.t1");
1:1d94b69:         }
1:1d94b69:         
1:1d94b69:         
1:1d94b69:         private void assertNoCurrentRow(ResultSet rs) throws SQLException {
1:1d94b69:             try {
1:1d94b69:                 rs.getString(1);
1:1d94b69:                 fail("getString not allowed after beforeFirst()");
1:1d94b69:             }catch (SQLException se ){
1:1d94b69:                 if (usingEmbedded())
1:1d94b69:                     assertSQLState("24000",se);
1:1d94b69:                 else
1:1d94b69:                     assertSQLState("XJ121",se);                
1:1d94b69:             }
1:1d94b69:             assertEquals(0,rs.getRow());
1:1d94b69:         }
1:1d94b69: 
1:1d94b69:         
1:1d94b69:         public static Test baseSuite(String name) {
1:1d94b69: 
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite(name);
1:40c2e1d:         suite.addTestSuite(ScrollCursors1Test.class);
1:1d94b69: 
1:1d94b69:         return new CleanDatabaseTestSetup(suite) {
1:1d94b69: 
1:1d94b69:             /**
1:1d94b69:              * Create and populate table
1:1d94b69:              * 
1:1d94b69:              * @see org.apache.derbyTesting.junit.CleanDatabaseTestSetup#decorateSQL(java.sql.Statement)
1:1d94b69:              */
1:1d94b69:             protected void decorateSQL(Statement s) throws SQLException {
1:1d94b69:                 s.executeUpdate("create table t1(c50 char(50), i int)");
1:1d94b69: 
1:1d94b69:                 s.executeUpdate(" create table t2(c50 char(50), i int)");
1:1d94b69: 
1:1d94b69:                 // populate tables
1:1d94b69: 
1:1d94b69:                 s.executeUpdate("insert into t1 values ('b', 2), ('c', 3), ('d', 4), "
1:1d94b69:                                 + "('e', 5),"
1:1d94b69:                                 + "                   ('f', 6), ('g', 7), ('h', 8), ('i', 9),"
1:1d94b69:                                 + "                   ('j', 10), ('k', 11), ('l', 12), ('m', 13)");
1:1d94b69: 
1:1d94b69:             }
1:1d94b69:         };
1:1d94b69:     }
1:1d94b69: 
1:1d94b69:     public static Test suite() {
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite("ScrollCursors1");
1:1d94b69:         suite.addTest(baseSuite("ScrollCursors1:embedded"));
1:1d94b69:         suite.addTest(TestConfiguration.clientServerDecorator(baseSuite("ScrollCursors1:client")));
1:1d94b69:         return suite;
1:1d94b69: 
1:1d94b69:     }
1:1d94b69: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1:  *  Derby - Class org.apache.derbyTesting.functionTests.tests.lang.ScrollCursors1Test
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Connection;
1: import org.apache.derbyTesting.junit.BaseTestSuite;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite(name);
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite("ScrollCursors1");
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:8a319fb
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             s.executeUpdate("drop table u1.t1");
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:c7f3642
/////////////////////////////////////////////////////////////////////////
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:40c2e1d
/////////////////////////////////////////////////////////////////////////
0:  *  Derby - Class org.apache.derbyTesting.functionTests.tests.lang.ScrollCursors1est
/////////////////////////////////////////////////////////////////////////
1: public class ScrollCursors1Test extends BaseJDBCTestCase {
1:     public ScrollCursors1Test(String name) {
/////////////////////////////////////////////////////////////////////////
1:         public void testSimpleScrollCursors() throws SQLException {
1:             Connection conn = getConnection();
1:             Statement s = conn.createStatement();
1:             s.executeUpdate("create table t (a int)");
1:             PreparedStatement ps = conn.prepareStatement("insert into t values (?)");
1:             for (int i = 1; i <=5; i++)
1:             {
1:                 ps.setInt(1, i);
1:                 ps.executeUpdate();
1:             }
1:             ps.close();
1:             PreparedStatement ps_c1 = conn.prepareStatement("select * from t", ResultSet.TYPE_SCROLL_INSENSITIVE,
1:                     ResultSet.CONCUR_READ_ONLY);
1:             ResultSet rs = ps_c1.executeQuery();
1:             rs.first();
1:             assertEquals(1,rs.getInt(1));
1:             rs.next();
1:             assertEquals(2,rs.getInt(1));
1:             rs.previous();
1:             assertEquals(1,rs.getInt(1));
1:             rs.last();
1:             assertEquals(5,rs.getInt(1));
1:             rs.absolute(2);
1:             assertEquals(2, rs.getInt(1));
1:             rs.relative(2);
1:             assertEquals(4,rs.getInt(1));
1:             rs.close();
1:             // since JCC gets 64 results and then scrolls within them
1:             // lets try each p ositioning command as the first command for the cursor.
1:             rs = ps_c1.executeQuery();
1:             rs.next();
1:             assertEquals(1,rs.getInt(1));
1:             rs.close();
1:             rs = ps_c1.executeQuery();
1:             rs.last();
1:             assertEquals(5,rs.getInt(1));
1:             rs.close();
1:             rs = ps_c1.executeQuery();
1:             rs.absolute(3);
1:             assertEquals(3,rs.getInt(1));
1:             rs.next();
1:             assertEquals(4,rs.getInt(1));
1:             rs.close();
1:             ps_c1.close();
1:             // lets try a table with more than 64 rows.
1:             s.executeUpdate("create table tab1 (a int)");
1:             PreparedStatement is = conn.prepareStatement("insert into tab1 values (?)");
1:             for (int i = 1; i <= 70; i++) {
1:                 is.setInt(1, i);
1:                 is.executeUpdate();
1:             }
1:             ps_c1 = conn.prepareStatement("select * from tab1",ResultSet.TYPE_SCROLL_INSENSITIVE,
1:                     ResultSet.CONCUR_READ_ONLY);
1:             rs = ps_c1.executeQuery();
1:             rs.first();
1:             assertEquals(1,rs.getInt(1));
1:             rs.last();
1:             assertEquals(70,rs.getInt(1));
1:             rs.absolute(65);
1:             assertEquals(65,rs.getInt(1));
1:             rs.absolute(-1);
1:             assertEquals(70,rs.getInt(1));
1:             rs.close();
1:             ps_c1.close();
1:             // try sensitive scroll cursors bug 4677
1:             ps_c1 = conn.prepareStatement("select * from t1",ResultSet.TYPE_SCROLL_SENSITIVE,
1:                         ResultSet.CONCUR_READ_ONLY);
1:             rs = ps_c1.executeQuery();
1:             rs.close();
1:             ps_c1.close();
1:             ps_c1 = conn.prepareStatement("select * from t1 for update",ResultSet.TYPE_SCROLL_SENSITIVE,
1:                     ResultSet.CONCUR_UPDATABLE);
1:             rs.close();
1:             s.executeUpdate("drop table tab1");
1:             // defect 5225, outer joins returning NULLS
1:             s.executeUpdate("create table tab1(i1 bigint not null, c1 varchar(64) not null)");
1:             s.executeUpdate("create table tab2 (i2 bigint not null, c2 varchar(64) not null)");
1:             s.executeUpdate("insert into tab1 values (1, 'String 1')");
1:             s.executeUpdate("insert into tab1 values (2, 'String 2')");
1:             s.executeUpdate("insert into tab2 values (1, 'String 1')");
1:             s.executeUpdate("insert into tab2 values (3, 'String 3')");
1:             rs = s.executeQuery("select c1 from tab1 right outer join tab2 on (i1=i2)");
1:             JDBC.assertFullResultSet(rs, new String[][] {{"String 1"},{null}});
1:             rs = s.executeQuery("select c2 from tab1 right outer join tab2 on (i1=i2)");
1:             JDBC.assertFullResultSet(rs, new String[][] {{"String 1"},{"String 3"}});
1:             // left outer join
1:             rs = s.executeQuery("select c1 from tab1 left outer join tab2 on (i1=i2)");
1:             JDBC.assertFullResultSet(rs, new String[][] {{"String 1"},{"String 2"}});
1:             rs = s.executeQuery("select c2 from tab1 left outer join tab2 on (i1=i2)");
1:             JDBC.assertFullResultSet(rs, new String[][] {{"String 1"},{null}});
1:             s.executeUpdate("drop table t");
1:             s.executeUpdate("drop table tab1");
1:             s.executeUpdate("drop table tab2");            
1:         }
1:         
/////////////////////////////////////////////////////////////////////////
1:         suite.addTestSuite(ScrollCursors1Test.class);
commit:1d94b69
/////////////////////////////////////////////////////////////////////////
1: /**
0:  *  Derby - Class org.apache.derbyTesting.functionTests.tests.lang.ScrollCursors1
1:  *  
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.tests.lang;
1: 
1: import java.sql.CallableStatement;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: import java.sql.Statement;
1: 
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: 
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1: import org.apache.derbyTesting.junit.JDBC;
1: import org.apache.derbyTesting.junit.RuntimeStatisticsParser;
1: import org.apache.derbyTesting.junit.TestConfiguration;
1: 
0: import java.sql.Connection;
1: 
0: public class ScrollCursors1 extends BaseJDBCTestCase {
1: 
0:     public ScrollCursors1(String name) {
1:         super(name);
1: 
1:     }
1: 
1:     public void testForwardOnlyNegative() throws SQLException {
1:         Connection conn = getConnection();
1:         PreparedStatement ps_c1 = conn.prepareStatement("select i from t1");
1:         ResultSet rs = ps_c1.executeQuery();
1:         try {
1:             rs.getRow();
1:             // client and embedded differ on getRow().
1:             // spec says getRow is optional for forward only cursors.
1:             if (usingEmbedded())
1:                 fail("getRow succeeded on forward only cursor");
1:         } catch (SQLException se) {
1:             assertSQLState("XJ061",se);
1:             
1:         }
1:         try {
1:             rs.first();
1:             fail("first() not allowed on forward only result set");
1:         } catch(SQLException se) {
1:             if (usingEmbedded())
1:                 assertSQLState("XJ061",se);
1:             else
1:                 assertSQLState("XJ125",se);
1:         }
1:         try {
1:             rs.last();
1:             fail("last() not allowed on forward only result set");
1:         } catch(SQLException se) {
1:             if (usingEmbedded())
1:                 assertSQLState("XJ061",se);
1:             else
1:                 assertSQLState("XJ125",se);
1:         }
1:         try {
1:             rs.previous();
1:             fail("previous() not allowed on forward only result set");
1:         } catch(SQLException se) {
1:             if (usingEmbedded())
1:                 assertSQLState("XJ061",se);
1:             else
1:                 assertSQLState("XJ125",se);
1:         }
1:         try {
1:             rs.beforeFirst();
1:             fail("beforeFirst() not allowed on forward only result set");
1:         } catch(SQLException se) {
1:             if (usingEmbedded())
1:                 assertSQLState("XJ061",se);
1:             else
1:                 assertSQLState("XJ125",se);
1:         }
1:         try {
1:             rs.afterLast();
1:             fail("afterLast() not allowed on forward only result set");
1:         } catch(SQLException se) {
1:             if (usingEmbedded())
1:                 assertSQLState("XJ061",se);
1:             else
1:                 assertSQLState("XJ125",se);
1:         }
1:         try {
1:             rs.absolute(1);
1:             fail("absolute() not allowed on forward only result set");
1:         } catch(SQLException se) {
1:             if (usingEmbedded())
1:                 assertSQLState("XJ061",se);
1:             else
1:                 assertSQLState("XJ125",se);
1:         }
1:         try {
1:             rs.relative(1);
1:             fail("relative() not allowed on forward only result set");
1:         } catch(SQLException se) {
1:             if (usingEmbedded())
1:                 assertSQLState("XJ061",se);
1:             else
1:                 assertSQLState("XJ125",se);
1:         }
1:         rs.close();
1:         ps_c1.close();
1:     }
1: 
1:         public void testScrollInsensitive() throws SQLException {
1:             Connection conn = getConnection();
1:             conn.setAutoCommit(false);
1:             PreparedStatement ps_c1 = conn.prepareStatement("select * from t1",
1:                         ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY );
1:             ResultSet rs = ps_c1.executeQuery();
1:             rs.absolute(0);
1:             assertNoCurrentRow(rs);
1:             rs.close();
1:             
1:             rs = ps_c1.executeQuery();
1:             rs.relative(0);
1:             assertNoCurrentRow(rs);
1:             rs.close();
1:             rs = ps_c1.executeQuery();
1:             
1:             rs.relative(2);
1:             assertEquals("c",rs.getString(1).trim());
1:             assertEquals(3, rs.getInt(2));
1:             rs.close();
1:             rs = ps_c1.executeQuery();
1:             rs.first();
1:             assertEquals("b", rs.getString(1).trim());
1:             assertEquals(2, rs.getInt(2));
1:             assertEquals(1, rs.getRow());
1:             rs.next();
1:             assertEquals("c",rs.getString(1).trim());
1:             assertEquals(3, rs.getInt(2));
1:             assertEquals(2,rs.getRow());
1:             assertEquals(2,rs.getRow());
1:             rs.first();
1:             assertEquals("b", rs.getString(1).trim());
1:             assertEquals(2, rs.getInt(2));
1:             assertEquals(1, rs.getRow());
1:             
1:             rs.next();
1:             assertEquals("c",rs.getString(1).trim());
1:             assertEquals(3, rs.getInt(2));
1:             assertEquals(2,rs.getRow());
1:             
1:             rs.next();
1:             assertEquals("d",rs.getString(1).trim());
1:             assertEquals(4, rs.getInt(2));
1:             assertEquals(3,rs.getRow());
1:             
1:             rs.first();
1:             assertEquals("b", rs.getString(1).trim());
1:             assertEquals(2, rs.getInt(2));
1:             assertEquals(1, rs.getRow());
1:             
1:             rs.next();
1:             assertEquals("c",rs.getString(1).trim());
1:             assertEquals(3, rs.getInt(2));
1:             assertEquals(2,rs.getRow());
1:             
1:             rs.afterLast();
1:             assertNoCurrentRow(rs);
1:             
1:             assertEquals(0,rs.getRow());
1:             assertFalse(rs.next());
1:             assertNoCurrentRow(rs);
1:             
1:             assertEquals(0,rs.getRow());
1:             
1:             rs.previous();
1:             assertEquals("m",rs.getString(1).trim());
1:             assertEquals(13, rs.getInt(2));
1:             assertEquals(12, rs.getRow());
1:             rs.previous();
1:             assertEquals("l",rs.getString(1).trim());
1:             assertEquals(12, rs.getInt(2));
1:             assertEquals(11, rs.getRow());
1:             
1:             rs.last();
1:             assertEquals("m",rs.getString(1).trim());
1:             assertEquals(13, rs.getInt(2));
1:             assertEquals(12, rs.getRow());
1:             rs.beforeFirst();
1:             assertNoCurrentRow(rs);
1:             assertEquals(0,rs.getRow());
1:             rs.next();
1:             assertEquals("b", rs.getString(1).trim());
1:             assertEquals(2, rs.getInt(2));
1:             assertEquals(1, rs.getRow());
1:             
1:             rs.absolute(12);
1:             assertEquals("m",rs.getString(1).trim());
1:             assertEquals(13, rs.getInt(2));
1:             assertEquals(12, rs.getRow());
1:             
1:             rs.absolute(-11);
1:             assertEquals("c",rs.getString(1).trim());
1:             assertEquals(3, rs.getInt(2));
1:             assertEquals(2,rs.getRow());
1:             
1:             rs.absolute(13);
1:             assertNoCurrentRow(rs);
1:             assertEquals(0,rs.getRow());
1:             
1:             
1:             rs.absolute(-1);
1:             assertEquals("m",rs.getString(1).trim());
1:             assertEquals(13, rs.getInt(2));
1:             assertEquals(12, rs.getRow());
1:             rs.close();
1:    
1:             rs = ps_c1.executeQuery();
1:             // do last first
1:             rs.last();
1:             assertEquals("m",rs.getString(1).trim());
1:             assertEquals(13, rs.getInt(2));
1:             assertEquals(12, rs.getRow());
1:             
1:             assertFalse(rs.next());
1:             assertNoCurrentRow(rs);
1:            
1:             rs.last();
1:             assertEquals("m",rs.getString(1).trim());
1:             assertEquals(13, rs.getInt(2));
1:             assertEquals(12, rs.getRow());
1:             
1:             rs.previous();
1:             assertEquals("l",rs.getString(1).trim());
1:             assertEquals(12, rs.getInt(2));
1:             assertEquals(11, rs.getRow());
1:             
1:             rs.first();
1:             assertEquals("b", rs.getString(1).trim());
1:             assertEquals(2, rs.getInt(2));
1:             assertEquals(1, rs.getRow());
1: 
1:             rs.previous();
1:             assertNoCurrentRow(rs);
1:             rs.next();
1:             assertEquals("b", rs.getString(1).trim());
1:             assertEquals(2, rs.getInt(2));
1:             assertEquals(1, rs.getRow());
1:             rs.close();
1:             
1:             // afterLast first
1:             rs = ps_c1.executeQuery();
1:             rs.afterLast();
1:             assertNoCurrentRow(rs);
1:             rs.previous();
1:             
1:             assertEquals("m",rs.getString(1).trim());
1:             assertEquals(13, rs.getInt(2));
1:             assertEquals(12, rs.getRow());
1:             
1:             rs.previous();
1:             assertEquals("l",rs.getString(1).trim());
1:             assertEquals(12, rs.getInt(2));
1:             assertEquals(11, rs.getRow());
1:             
1:             rs.close();
1:             
1:             // go to next to last row and then do next
1:             ps_c1.close();
1:             ps_c1 = conn.prepareStatement("select * from t1 where i >=11",
1:                     ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
1:             rs = ps_c1.executeQuery();
1:             rs.next();
1:             assertEquals("k",rs.getString(1).trim());
1:             assertEquals(11, rs.getInt(2));
1:             assertEquals(1, rs.getRow());
1:             
1:             rs.next();
1:             assertEquals("l",rs.getString(1).trim());
1:             assertEquals(12, rs.getInt(2));
1:             assertEquals(2, rs.getRow());
1:             
1:             rs.last();
1:             assertEquals("m",rs.getString(1).trim());
1:             assertEquals(13, rs.getInt(2));
1:             assertEquals(3, rs.getRow());
1:             
1:             rs.previous();
1:             assertEquals("l",rs.getString(1).trim());
1:             assertEquals(12, rs.getInt(2));
1:             assertEquals(2, rs.getRow());
1:             
1:             rs.afterLast();
1:             assertNoCurrentRow(rs);
1:             
1:             rs.previous();
1:             assertEquals("m",rs.getString(1).trim());
1:             assertEquals(13, rs.getInt(2));
1:             assertEquals(3, rs.getRow());
1:             rs.close();
1:             // start at after ;ast/
1:             rs = ps_c1.executeQuery();
1:             rs.afterLast();
1:             assertNoCurrentRow(rs);
1:             
1:             rs.previous();
1:             assertEquals("m",rs.getString(1).trim());
1:             assertEquals(13, rs.getInt(2));
1:             assertEquals(3, rs.getRow());
1:             rs.close();
1:             ps_c1.close();
1:             // use absolute to get rows before scan would get to them.
1:            ps_c1 = conn.prepareStatement("select i from t1", ResultSet.TYPE_SCROLL_INSENSITIVE,
1:                    ResultSet.CONCUR_READ_ONLY);
1:            rs = ps_c1.executeQuery();
1:            rs.absolute(5);
1:            assertEquals(6, rs.getInt(1));
1:            assertEquals(5, rs.getRow());
1:            
1:            rs.absolute(-5);
1:            assertEquals(9,rs.getInt(1));
1:            assertEquals(8, rs.getRow());
1: 
1:            rs.absolute(5);
1:            assertEquals(6,rs.getInt(1));
1:            assertEquals(5, rs.getRow());
1:            rs.close();
1:            rs = ps_c1.executeQuery();
1:            rs.absolute(13);
1:            assertNoCurrentRow(rs);
1:            
1:            rs.previous();
1:            assertEquals(13, rs.getInt(1));
1:            assertEquals(12, rs.getRow());
1:            rs.close();
1:            rs = ps_c1.executeQuery();
1:            rs.absolute(-13);
1:            assertNoCurrentRow(rs);
1:            rs.next();
1:            assertEquals(2, rs.getInt(1));
1:            assertEquals(1,rs.getRow());
1:            rs.close();
1:            rs = ps_c1.executeQuery();
1:            rs.first();
1:            assertEquals(2,rs.getInt(1)); 
1:            assertEquals(1,rs.getRow());
1:            
1:            rs.relative(11);
1:            assertEquals(13, rs.getInt(1));
1:            assertEquals(12, rs.getRow());
1:            
1:            rs.relative(1);
1:            assertNoCurrentRow(rs);
1:            rs.last();
1:            assertEquals(13, rs.getInt(1));
1:            assertEquals(12,rs.getRow());
1:            
1:            rs.relative(-11);
1:            assertEquals(2,rs.getInt(1));
1:            assertEquals(1,rs.getRow());
1:            rs.close();
1:            ps_c1.close();
1:            conn.commit();
1:            // scroll sensitive cursor becomes scroll insensitive.
1:            ps_c1 = conn.prepareStatement("Select i from t1", ResultSet.TYPE_SCROLL_SENSITIVE,
1:                    ResultSet.CONCUR_READ_ONLY);    
1:            
1:            rs = ps_c1.executeQuery();
1:            rs.first();
1:            assertEquals(2,rs.getInt(1));
1:            rs.next();
1:            assertEquals(3,rs.getInt(1));
1:            Statement s = conn.createStatement();
1:            s.executeUpdate("update t1 set i = 666 where i = 2");
1:            rs.first();
1:            conn.rollback();
1:            rs.close();
1:            // verify that statement cache works correctly with scroll and forward only cursors.
1:            // with the same query text.
1:            ps_c1 = conn.prepareStatement("select i from t1", ResultSet.TYPE_SCROLL_INSENSITIVE,
1:                    ResultSet.CONCUR_READ_ONLY);
1:            rs = ps_c1.executeQuery();
1:            PreparedStatement ps_c2 = conn.prepareStatement("select i from t1");
1:            ResultSet rs2 = ps_c2.executeQuery();
1:            rs.first();
1:            assertEquals(2,rs.getInt(1));
1:            rs2.next();
1:            assertEquals(2,rs2.getInt(1));
1:            try {
1:                rs2.first();
1:                fail("first() not allowed on forward only result set");
1:            } catch(SQLException se) {
1:                if (usingEmbedded())
1:                    assertSQLState("XJ061",se);
1:                else
1:                    assertSQLState("XJ125",se);
1:            }
1:             rs.close();
1:             rs2.close();
1:             ps_c1.close();
1:             ps_c1.close();
1:             // first, last, etc on empty result set
1:             ps_c1 = conn.prepareStatement("select i from t1 where 1=0",
1:                     ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
1:             rs = ps_c1.executeQuery();
1:             rs.first();
1:             assertNoCurrentRow(rs);
1:             rs.previous();
1:             assertNoCurrentRow(rs);
1:             rs.next();
1:             assertNoCurrentRow(rs);
1:             rs.last();
1:             assertNoCurrentRow(rs);
1:             rs.previous();
1:             assertNoCurrentRow(rs);
1:             rs.absolute(1);
1:             assertNoCurrentRow(rs);
1:             rs.absolute(-1);
1:             assertNoCurrentRow(rs);
1:             assertEquals(0,rs.getRow());
1:             rs.close();
1:             rs = ps_c1.executeQuery();
1:             rs.afterLast();
1:             assertNoCurrentRow(rs);
1:             rs.previous();
1:             assertNoCurrentRow(rs);
1:             rs.beforeFirst();
1:             assertNoCurrentRow(rs);
1:             rs.next();
1:             assertNoCurrentRow(rs);
1:             rs.close();
1:             rs = ps_c1.executeQuery();
1:             rs.absolute(1);
1:             assertNoCurrentRow(rs);
1:             rs.absolute(-1);
1:             assertNoCurrentRow(rs);
1:             rs.close();
1:             rs = ps_c1.executeQuery();
1:             rs.absolute(-1);
1:             assertNoCurrentRow(rs);
1:             rs.absolute(1);
1:             assertNoCurrentRow(rs);
1:             rs.close();
1:             // with autocommit on
1:             conn.setAutoCommit(false);
1:             rs = ps_c1.executeQuery();
1:             rs = ps_c1.executeQuery();
1:             rs.first();
1:             assertNoCurrentRow(rs);
1:             rs.previous();
1:             assertNoCurrentRow(rs);
1:             rs.next();
1:             assertNoCurrentRow(rs);
1:             rs.last();
1:             assertNoCurrentRow(rs);
1:             rs.previous();
1:             assertNoCurrentRow(rs);
1:             rs.absolute(1);
1:             assertNoCurrentRow(rs);
1:             rs.absolute(-1);
1:             assertNoCurrentRow(rs);
1:             rs.next();
1:             assertNoCurrentRow(rs);
1:             rs.next();
1:             assertNoCurrentRow(rs);
1:             rs.close();
1:             ps_c1.close();
1:             
1:             // cursor on a sort
1:             ps_c1 = conn.prepareStatement("select * from t1 order by i desc",ResultSet.TYPE_SCROLL_INSENSITIVE,
1:                     ResultSet.CONCUR_READ_ONLY);
1:             rs = ps_c1.executeQuery();
1:             rs.last();
1:             assertEquals("b",rs.getString(1).trim());
1:             assertEquals(2,rs.getInt(2));
1:             rs.first();
1:             assertEquals("m",rs.getString(1).trim());
1:             assertEquals(13,rs.getInt(2));
1:             rs.relative(11);
1:             assertEquals("b",rs.getString(1).trim());
1:             assertEquals(2,rs.getInt(2));
1:             rs.previous();
1:             assertEquals("c",rs.getString(1).trim());
1:             assertEquals(3,rs.getInt(2));
1:             rs.close();
1:             ps_c1.close();
1:             ps_c1 = conn.prepareStatement("select * from t1",
1:                     ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
1:             CallableStatement cs = conn.prepareCall("call SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)");
1:             cs.execute();
1:             cs.close();
1:             rs = ps_c1.executeQuery();
1:             rs.last();
1:             assertEquals("m",rs.getString(1).trim());
1:             assertEquals(13,rs.getInt(2));
1:             rs.first();
1:             assertEquals("b",rs.getString(1).trim());
1:             assertEquals(2,rs.getInt(2));
1:             rs.next();
1:             assertEquals("c",rs.getString(1).trim());
1:             assertEquals(3,rs.getInt(2));
1:             rs.close();
1:             rs2 = s.executeQuery("values SYSCS_UTIL.SYSCS_GET_RUNTIMESTATISTICS()");
1:             rs2.next();
1:                     
1:             if (usingEmbedded())
1:             {
1:                 // not sure why I get a null rts with network server.
1:                 RuntimeStatisticsParser rts = new RuntimeStatisticsParser(rs2.getString(1));
1:                 rs2.close();
1:                 assertEquals(Connection.TRANSACTION_READ_COMMITTED, rts.getIsolationLevel());
1:                 assertTrue(rts.usedTableScan());
1:                 assertTrue(rts.isScrollInsensitive());
1:             }
1:          
1:             rs.close();  
1:             ps_c1.close();
0:             s.executeUpdate("drop table t1");
0:             s.executeUpdate("drop table t2");                       
1:         }
1: 
1:         public void testNoHoldScrollableResults() throws SQLException{
1:             Connection conn = getConnection();
1:             conn.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);
1:             // Beetle 4551 - insensitive cursor uses estimated row count which 
1:             // might be pessimistic and will get out of memory error
1:             Statement s = createStatement();
1:             s.executeUpdate("create table big(a int generated always as identity (start with 1, increment by 1))");
1:             
1:             for (int i = 0; i < 10; i++)
1:                 s.executeUpdate("insert into big values(default)");
1:             
1:          PreparedStatement ps_c1 = conn.prepareStatement("select * from big b1 left outer join  big b2 on b1.a = b2.a left outer join  big b3 on b2.a = b3.a left outer join big b4 on b3.a = b4.a left outer join (big b5 left outer join (big b6 left outer join (big b7 left outer join big b8 on b7.a = b8.a) on b6.a=b7.a) on b5.a = b6.a) on b4.a = b5.a");
1:          ResultSet rs = ps_c1.executeQuery();
1:          s.executeUpdate("drop table big");
1:         }
1:         
1:         public void testScrollCursors3() throws SQLException {
1:             Connection conn = getConnection();
1:             Connection conn2 = openDefaultConnection();
1:             Statement s = conn.createStatement();
1:             s.executeUpdate("create table u1.t1(c1 int, c2 int)");
1:             s.executeUpdate("insert into u1.t1 values (1, 2), (3, 4), (5, 6), (7, 8), (9, 10)");
1:             PreparedStatement ps_c1 = conn.prepareStatement("select * from u1.t1", ResultSet.TYPE_SCROLL_INSENSITIVE,
1:                     ResultSet.CONCUR_READ_ONLY);
1:             ResultSet rs = ps_c1.executeQuery();
1:             
1:             // see what happens when other user when we close our cursor before
1:             // they are done.
1:             PreparedStatement ps_c2 = conn2.prepareStatement("select * from u1.t1", ResultSet.TYPE_SCROLL_INSENSITIVE,
1:                     ResultSet.CONCUR_READ_ONLY);
1:             ResultSet rs2 = ps_c2.executeQuery();
1:             rs.next();
1:             assertEquals(1, rs.getInt(1));
1:             assertEquals(2, rs.getInt(2));
1:             
1:             rs2.next();
1:             assertEquals(1, rs.getInt(1));
1:             assertEquals(2, rs.getInt(2));
1:             rs.last();
1:             assertEquals(9, rs.getInt(1));
1:             assertEquals(10, rs.getInt(2));
1:             rs2.last();
1:             assertEquals(9, rs.getInt(1));
1:             assertEquals(10, rs.getInt(2));
1:             rs.previous();
1:             assertEquals(7, rs.getInt(1));
1:             assertEquals(8, rs.getInt(2));
1:             rs2.close();
1:             rs.first();
1:             assertEquals(1, rs.getInt(1));
1:             assertEquals(2, rs.getInt(2));
1:             rs.close();
0:             s.executeUpdate("drop table t1");
1:         }
1:         
1:         
1:         private void assertNoCurrentRow(ResultSet rs) throws SQLException {
1:             try {
1:                 rs.getString(1);
1:                 fail("getString not allowed after beforeFirst()");
1:             }catch (SQLException se ){
1:                 if (usingEmbedded())
1:                     assertSQLState("24000",se);
1:                 else
1:                     assertSQLState("XJ121",se);                
1:             }
1:             assertEquals(0,rs.getRow());
1:         }
1: 
1:         
1:         public static Test baseSuite(String name) {
1: 
0:         TestSuite suite = new TestSuite(name);
0:         suite.addTestSuite(ScrollCursors1.class);
1: 
1:         return new CleanDatabaseTestSetup(suite) {
1: 
1:             /**
1:              * Create and populate table
1:              * 
1:              * @see org.apache.derbyTesting.junit.CleanDatabaseTestSetup#decorateSQL(java.sql.Statement)
1:              */
1:             protected void decorateSQL(Statement s) throws SQLException {
1:                 s.executeUpdate("create table t1(c50 char(50), i int)");
1: 
1:                 s.executeUpdate(" create table t2(c50 char(50), i int)");
1: 
1:                 // populate tables
1: 
1:                 s.executeUpdate("insert into t1 values ('b', 2), ('c', 3), ('d', 4), "
1:                                 + "('e', 5),"
1:                                 + "                   ('f', 6), ('g', 7), ('h', 8), ('i', 9),"
1:                                 + "                   ('j', 10), ('k', 11), ('l', 12), ('m', 13)");
1: 
1:                 
0:                 getConnection().setAutoCommit(false);
1:             }
1:         };
1:     }
1: 
1:     public static Test suite() {
0:         TestSuite suite = new TestSuite("ScrollCursors1");
1:         suite.addTest(baseSuite("ScrollCursors1:embedded"));
1:         suite.addTest(TestConfiguration.clientServerDecorator(baseSuite("ScrollCursors1:client")));
1:         return suite;
1: 
1:     }
1: }
============================================================================