1:eac0369: /*
9:eac0369: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.compile.NestedLoopJoinStrategy
1:345de35: 
1:2d37fd6:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2d37fd6:    contributor license agreements.  See the NOTICE file distributed with
1:2d37fd6:    this work for additional information regarding copyright ownership.
1:2d37fd6:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2d37fd6:    (the "License"); you may not use this file except in compliance with
1:2d37fd6:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:345de35: 
2:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.sql.compile;
1:eac0369: 
1:3bb140c: import org.apache.derby.iapi.error.StandardException;
1:3bb140c: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: import org.apache.derby.iapi.sql.compile.CostEstimate;
1:eac0369: import org.apache.derby.iapi.sql.compile.ExpressionClassBuilderInterface;
1:eac0369: import org.apache.derby.iapi.sql.compile.JoinStrategy;
1:eac0369: import org.apache.derby.iapi.sql.compile.Optimizable;
1:eac0369: import org.apache.derby.iapi.sql.compile.OptimizablePredicate;
1:3bb140c: import org.apache.derby.iapi.sql.compile.OptimizablePredicateList;
1:3bb140c: import org.apache.derby.iapi.sql.compile.Optimizer;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
1:3bb140c: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1:eac0369: import org.apache.derby.iapi.store.access.StoreCostController;
1:eac0369: import org.apache.derby.iapi.store.access.TransactionController;
1:eac0369: 
1:3bb140c: class NestedLoopJoinStrategy extends BaseJoinStrategy {
1:3bb140c:     NestedLoopJoinStrategy() {
1:af1c18c:         int i = 3;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
2:eac0369: 	/**
1:eac0369: 	 * @see JoinStrategy#feasible
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public boolean feasible(Optimizable innerTable,
1:eac0369: 							OptimizablePredicateList predList,
1:eac0369: 							Optimizer optimizer
1:eac0369: 							)
1:eac0369: 					throws StandardException 
1:eac0369: 	{
1:eac0369: 		/* Nested loop is feasible, except in the corner case
1:eac0369: 		 * where innerTable is a VTI that cannot be materialized
1:eac0369: 		 * (because it has a join column as a parameter) and
1:eac0369: 		 * it cannot be instantiated multiple times.
1:eac0369: 		 * RESOLVE - Actually, the above would work if all of 
1:eac0369: 		 * the tables outer to innerTable were 1 row tables, but
1:eac0369: 		 * we don't have that info yet, and it should probably
1:eac0369: 		 * be hidden in inner table somewhere.
1:eac0369: 		 * NOTE: A derived table that is correlated with an outer
1:eac0369: 		 * query block is not materializable, but it can be
1:eac0369: 		 * "instantiated" multiple times because that only has
1:eac0369: 		 * meaning for VTIs.
1:eac0369: 		 */
1:eac0369: 		if (innerTable.isMaterializable())
1:eac0369: 		{
1:eac0369: 			return true;
1:eac0369: 		}
1:eac0369: 		if (innerTable.supportsMultipleInstantiations())
1:eac0369: 		{
1:eac0369: 			return true;
1:eac0369: 		}
1:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see JoinStrategy#multiplyBaseCostByOuterRows */
1:eac0369: 	public boolean multiplyBaseCostByOuterRows() {
1:eac0369: 		return true;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see JoinStrategy#getBasePredicates
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public OptimizablePredicateList getBasePredicates(
1:eac0369: 									OptimizablePredicateList predList,
1:eac0369: 									OptimizablePredicateList basePredicates,
1:eac0369: 									Optimizable innerTable)
1:eac0369: 							throws StandardException {
1:eac0369: 		if (SanityManager.DEBUG) {
1:eac0369: 			SanityManager.ASSERT(basePredicates == null ||
1:eac0369: 								 basePredicates.size() == 0,
1:eac0369: 				"The base predicate list should be empty.");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (predList != null) {
1:eac0369: 			predList.transferAllPredicates(basePredicates);
1:eac0369: 			basePredicates.classify(innerTable,
1:eac0369: 				innerTable.getCurrentAccessPath().getConglomerateDescriptor());
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return basePredicates;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see JoinStrategy#nonBasePredicateSelectivity */
1:eac0369: 	public double nonBasePredicateSelectivity(
1:eac0369: 										Optimizable innerTable,
1:eac0369: 										OptimizablePredicateList predList) {
1:eac0369: 		/*
1:eac0369: 		** For nested loop, all predicates are base predicates, so there
1:eac0369: 		** is no extra selectivity.
1:eac0369: 		*/
1:eac0369: 		return 1.0;
1:eac0369: 	}
1:eac0369: 	
1:eac0369: 	/**
1:eac0369: 	 * @see JoinStrategy#putBasePredicates
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public void putBasePredicates(OptimizablePredicateList predList,
1:eac0369: 									OptimizablePredicateList basePredicates)
1:eac0369: 					throws StandardException {
1:eac0369: 		for (int i = basePredicates.size() - 1; i >= 0; i--) {
1:eac0369: 			OptimizablePredicate pred = basePredicates.getOptPredicate(i);
1:eac0369: 
1:eac0369: 			predList.addOptPredicate(pred);
1:eac0369: 			basePredicates.removeOptPredicate(i);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/* @see JoinStrategy#estimateCost */
1:eac0369: 	public void estimateCost(Optimizable innerTable,
1:eac0369: 							 OptimizablePredicateList predList,
1:eac0369: 							 ConglomerateDescriptor cd,
1:eac0369: 							 CostEstimate outerCost,
1:eac0369: 							 Optimizer optimizer,
1:eac0369: 							 CostEstimate costEstimate) {
1:eac0369: 		costEstimate.multiply(outerCost.rowCount(), costEstimate);
1:eac0369: 
1:9881ca4:         if ( innerTable.optimizerTracingIsOn() )
1:9881ca4:         { innerTable.getOptimizerTracer().traceCostOfNScans( innerTable.getTableNumber(), outerCost.rowCount(), costEstimate ); }
1:eac0369: 	}
1:eac0369: 
1:b223f72: 	/** @see JoinStrategy#maxCapacity */
1:b223f72: 	public int maxCapacity( int userSpecifiedCapacity,
1:b223f72:                             int maxMemoryPerTable,
1:b223f72:                             double perRowUsage) {
1:b223f72: 		return Integer.MAX_VALUE;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see JoinStrategy#getName */
1:eac0369: 	public String getName() {
1:eac0369: 		return "NESTEDLOOP";
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see JoinStrategy#scanCostType */
1:eac0369: 	public int scanCostType() {
1:eac0369: 		return StoreCostController.STORECOST_SCAN_NORMAL;
1:eac0369: 	}
1:eac0369: 
1:b6cc9d7: 	/** @see JoinStrategy#getOperatorSymbol */
1:b6cc9d7:     public  String  getOperatorSymbol() { return "*"; }
1:b6cc9d7: 
1:eac0369: 	/** @see JoinStrategy#resultSetMethodName */
1:af1c18c:     public String resultSetMethodName(
1:af1c18c:             boolean bulkFetch,
1:af1c18c:             boolean multiprobe,
1:af1c18c:             boolean validatingCheckConstraint) {
1:af1c18c: 
1:af1c18c:         if (validatingCheckConstraint) {
1:af1c18c:             return "getValidateCheckConstraintResultSet";
1:af1c18c:         } else if (bulkFetch) {
1:eac0369: 			return "getBulkTableScanResultSet";
1:af1c18c:         } else if (multiprobe) {
1:cbdc90c: 			return "getMultiProbeTableScanResultSet";
1:af1c18c:         } else {
1:eac0369: 			return "getTableScanResultSet";
1:af1c18c:         }
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see JoinStrategy#joinResultSetMethodName */
1:eac0369: 	public String joinResultSetMethodName() {
1:eac0369: 		return "getNestedLoopJoinResultSet";
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see JoinStrategy#halfOuterJoinResultSetMethodName */
1:eac0369: 	public String halfOuterJoinResultSetMethodName() {
1:eac0369: 		return "getNestedLoopLeftOuterJoinResultSet";
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see JoinStrategy#getScanArgs
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public int getScanArgs(
1:eac0369: 							TransactionController tc,
1:eac0369: 							MethodBuilder mb,
1:eac0369: 							Optimizable innerTable,
1:eac0369: 							OptimizablePredicateList storeRestrictionList,
1:eac0369: 							OptimizablePredicateList nonStoreRestrictionList,
1:eac0369: 							ExpressionClassBuilderInterface acbi,
1:eac0369: 							int bulkFetch,
1:959fef2: 							int resultRowTemplate,
1:eac0369: 							int colRefItem,
1:eac0369: 							int indexColItem,
1:eac0369: 							int lockMode,
1:eac0369: 							boolean tableLocked,
1:b223f72: 							int isolationLevel,
1:cbdc90c: 							int maxMemoryPerTable,
1:cbdc90c: 							boolean genInListVals
1:eac0369: 							)
1:eac0369: 						throws StandardException {
1:eac0369: 		ExpressionClassBuilder acb = (ExpressionClassBuilder) acbi;
1:eac0369: 		int numArgs;
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG) {
1:eac0369: 			if (nonStoreRestrictionList.size() != 0) {
1:eac0369: 				SanityManager.THROWASSERT(
1:eac0369: 					"nonStoreRestrictionList should be empty for " +
1:eac0369: 					"nested loop join strategy, but it contains " +
1:eac0369: 					nonStoreRestrictionList.size() +
1:eac0369: 					" elements");
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:cbdc90c: 		/* If we're going to generate a list of IN-values for index probing
1:cbdc90c: 		 * at execution time then we push TableScanResultSet arguments plus
1:cbdc90c: 		 * two additional arguments: 1) the list of IN-list values, and 2)
1:cbdc90c: 		 * a boolean indicating whether or not the IN-list values are already
1:cbdc90c: 		 * sorted.
1:cbdc90c: 		 */
1:cbdc90c: 		if (genInListVals)
1:cbdc90c: 		{
1:cbdc90c: 			numArgs = 26;
1:cbdc90c: 		}
1:cbdc90c: 		else if (bulkFetch > 1)
1:eac0369: 		{
1:ec6fcf1:             // Bulk-fetch uses TableScanResultSet arguments plus two
1:ec6fcf1:             // additional arguments: 1) bulk fetch size, and 2) whether the
1:ec6fcf1:             // table contains LOB columns (used at runtime to decide if
1:ec6fcf1:             // bulk fetch is safe DERBY-1511).
1:ec6fcf1:             numArgs = 26;
1:eac0369: 		}
2:eac0369: 		else
1:eac0369: 		{
1:9e6e461: 			numArgs = 24 ;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		fillInScanArgs1(tc, mb,
1:eac0369: 										innerTable,
1:eac0369: 										storeRestrictionList,
1:eac0369: 										acb,
1:959fef2: 										resultRowTemplate);
1:eac0369: 
1:cbdc90c: 		if (genInListVals)
1:cbdc90c: 			((PredicateList)storeRestrictionList).generateInListValues(acb, mb);
1:cbdc90c: 
1:cbdc90c: 		if (SanityManager.DEBUG)
1:cbdc90c: 		{
1:cbdc90c: 			/* If we're not generating IN-list values with which to probe
1:cbdc90c: 			 * the table then storeRestrictionList should not have any
1:cbdc90c: 			 * IN-list probing predicates.  Make sure that's the case.
1:cbdc90c: 			 */
1:cbdc90c: 			if (!genInListVals)
1:cbdc90c: 			{
1:cbdc90c: 				for (int i = storeRestrictionList.size() - 1; i >= 0; i--)
1:cbdc90c: 				{
1:3bb140c:                     Predicate pred =
1:3bb140c:                             (Predicate)storeRestrictionList.getOptPredicate(i);
1:9d82913: 					if (pred.isInListProbePredicate())
1:cbdc90c: 					{
1:cbdc90c: 						SanityManager.THROWASSERT("Found IN-list probing " +
1:cbdc90c: 							"predicate (" + pred.binaryRelOpColRefsToString() +
1:cbdc90c: 							") when no such predicates were expected.");
1:cbdc90c: 					}
1:cbdc90c: 				}
1:cbdc90c: 			}
1:cbdc90c: 		}
1:cbdc90c: 
1:eac0369: 		fillInScanArgs2(mb,
1:eac0369: 						innerTable,
1:eac0369: 						bulkFetch,
1:eac0369: 						colRefItem,
1:eac0369: 						indexColItem,
1:eac0369: 						lockMode,
1:eac0369: 						tableLocked,
1:eac0369: 						isolationLevel);
1:eac0369: 
1:eac0369: 		return numArgs;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see JoinStrategy#divideUpPredicateLists
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public void divideUpPredicateLists(
1:eac0369: 					Optimizable				 innerTable,
1:eac0369: 					OptimizablePredicateList originalRestrictionList,
1:eac0369: 					OptimizablePredicateList storeRestrictionList,
1:eac0369: 					OptimizablePredicateList nonStoreRestrictionList,
1:eac0369: 					OptimizablePredicateList requalificationRestrictionList,
1:eac0369: 					DataDictionary			 dd
1:eac0369: 					) throws StandardException
1:eac0369: 	{
1:eac0369: 		/*
1:eac0369: 		** All predicates are store predicates.  No requalification is
1:eac0369: 		** necessary for non-covering index scans.
1:eac0369: 		*/
1:eac0369: 		originalRestrictionList.setPredicatesAndProperties(storeRestrictionList);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see JoinStrategy#doesMaterialization
1:eac0369: 	 */
1:eac0369: 	public boolean doesMaterialization()
1:eac0369: 	{
1:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: 
1:3bb140c:     @Override
1:eac0369: 	public String toString() {
1:eac0369: 		return getName();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Can this join strategy be used on the
1:eac0369: 	 * outermost table of a join.
1:eac0369: 	 *
1:eac0369: 	 * @return Whether or not this join strategy
1:3bb140c:      * can be used on the outermost table of a join.
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	protected boolean validForOutermostTable()
1:eac0369: 	{
1:eac0369: 		return true;
1:eac0369: 	}
1:eac0369: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:af1c18c
/////////////////////////////////////////////////////////////////////////
1:         int i = 3;
/////////////////////////////////////////////////////////////////////////
1:     public String resultSetMethodName(
1:             boolean bulkFetch,
1:             boolean multiprobe,
1:             boolean validatingCheckConstraint) {
1: 
1:         if (validatingCheckConstraint) {
1:             return "getValidateCheckConstraintResultSet";
1:         } else if (bulkFetch) {
1:         } else if (multiprobe) {
1:         } else {
1:         }
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.services.compiler.MethodBuilder;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.sql.compile.OptimizablePredicateList;
1: import org.apache.derby.iapi.sql.compile.Optimizer;
1: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1: class NestedLoopJoinStrategy extends BaseJoinStrategy {
1:     NestedLoopJoinStrategy() {
/////////////////////////////////////////////////////////////////////////
1:                     Predicate pred =
1:                             (Predicate)storeRestrictionList.getOptPredicate(i);
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:      * can be used on the outermost table of a join.
1:     @Override
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:9881ca4
/////////////////////////////////////////////////////////////////////////
1:         if ( innerTable.optimizerTracingIsOn() )
1:         { innerTable.getOptimizerTracer().traceCostOfNScans( innerTable.getTableNumber(), outerCost.rowCount(), costEstimate ); }
commit:b6cc9d7
/////////////////////////////////////////////////////////////////////////
1: 	/** @see JoinStrategy#getOperatorSymbol */
1:     public  String  getOperatorSymbol() { return "*"; }
1: 
commit:9858a84
/////////////////////////////////////////////////////////////////////////
0:         if ( optimizer.tracingIsOn() )
0:         { optimizer.tracer().traceCostOfNScans( innerTable.getTableNumber(), outerCost.rowCount(), costEstimate ); }
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:959fef2
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 							int resultRowTemplate,
/////////////////////////////////////////////////////////////////////////
1: 										resultRowTemplate);
commit:ec6fcf1
/////////////////////////////////////////////////////////////////////////
1:             // Bulk-fetch uses TableScanResultSet arguments plus two
1:             // additional arguments: 1) bulk fetch size, and 2) whether the
1:             // table contains LOB columns (used at runtime to decide if
1:             // bulk fetch is safe DERBY-1511).
1:             numArgs = 26;
author:Army
-------------------------------------------------------------------------------
commit:9d82913
/////////////////////////////////////////////////////////////////////////
1: 					if (pred.isInListProbePredicate())
commit:cbdc90c
/////////////////////////////////////////////////////////////////////////
0: 	public String resultSetMethodName(boolean bulkFetch, boolean multiprobe) {
0: 		else if (multiprobe)
1: 			return "getMultiProbeTableScanResultSet";
/////////////////////////////////////////////////////////////////////////
1: 							int maxMemoryPerTable,
1: 							boolean genInListVals
/////////////////////////////////////////////////////////////////////////
1: 		/* If we're going to generate a list of IN-values for index probing
1: 		 * at execution time then we push TableScanResultSet arguments plus
1: 		 * two additional arguments: 1) the list of IN-list values, and 2)
1: 		 * a boolean indicating whether or not the IN-list values are already
1: 		 * sorted.
1: 		 */
1: 		if (genInListVals)
1: 		{
1: 			numArgs = 26;
1: 		}
1: 		else if (bulkFetch > 1)
/////////////////////////////////////////////////////////////////////////
1: 		if (genInListVals)
1: 			((PredicateList)storeRestrictionList).generateInListValues(acb, mb);
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			/* If we're not generating IN-list values with which to probe
1: 			 * the table then storeRestrictionList should not have any
1: 			 * IN-list probing predicates.  Make sure that's the case.
1: 			 */
1: 			if (!genInListVals)
1: 			{
0: 				Predicate pred = null;
1: 				for (int i = storeRestrictionList.size() - 1; i >= 0; i--)
1: 				{
0: 					pred = (Predicate)storeRestrictionList.getOptPredicate(i);
0: 					if (pred.getSourceInList() != null)
1: 					{
1: 						SanityManager.THROWASSERT("Found IN-list probing " +
1: 							"predicate (" + pred.binaryRelOpColRefsToString() +
1: 							") when no such predicates were expected.");
1: 					}
1: 				}
1: 			}
1: 		}
1: 
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:9e6e461
/////////////////////////////////////////////////////////////////////////
0: 			numArgs = 25;
1: 			numArgs = 24 ;
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.compile.NestedLoopJoinStrategy
1: 
0:    Copyright 1998, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:61070a6
/////////////////////////////////////////////////////////////////////////
0: public class NestedLoopJoinStrategy extends BaseJoinStrategy {
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.sql.compile;
1: 
1: import org.apache.derby.iapi.sql.compile.CostEstimate;
1: import org.apache.derby.iapi.sql.compile.ExpressionClassBuilderInterface;
1: import org.apache.derby.iapi.sql.compile.JoinStrategy;
1: import org.apache.derby.iapi.sql.compile.Optimizable;
0: import org.apache.derby.iapi.sql.compile.Optimizer;
0: import org.apache.derby.iapi.sql.compile.OptimizablePredicateList;
1: import org.apache.derby.iapi.sql.compile.OptimizablePredicate;
1: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
1: 
1: import org.apache.derby.iapi.store.access.StoreCostController;
1: import org.apache.derby.iapi.store.access.TransactionController;
1: 
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1: 
0: import org.apache.derby.impl.sql.compile.ExpressionClassBuilder;
1: 
0: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
0: public class NestedLoopJoinStrategy extends BaseJoinStrategy { 
1: 
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
0: 	public NestedLoopJoinStrategy() {
1: 	}
1: 
1: 
1: 	/**
1: 	 * @see JoinStrategy#feasible
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public boolean feasible(Optimizable innerTable,
1: 							OptimizablePredicateList predList,
1: 							Optimizer optimizer
1: 							)
1: 					throws StandardException 
1: 	{
1: 		/* Nested loop is feasible, except in the corner case
1: 		 * where innerTable is a VTI that cannot be materialized
1: 		 * (because it has a join column as a parameter) and
1: 		 * it cannot be instantiated multiple times.
1: 		 * RESOLVE - Actually, the above would work if all of 
1: 		 * the tables outer to innerTable were 1 row tables, but
1: 		 * we don't have that info yet, and it should probably
1: 		 * be hidden in inner table somewhere.
1: 		 * NOTE: A derived table that is correlated with an outer
1: 		 * query block is not materializable, but it can be
1: 		 * "instantiated" multiple times because that only has
1: 		 * meaning for VTIs.
1: 		 */
1: 		if (innerTable.isMaterializable())
1: 		{
1: 			return true;
1: 		}
1: 		if (innerTable.supportsMultipleInstantiations())
1: 		{
1: 			return true;
1: 		}
1: 		return false;
1: 	}
1: 
1: 	/** @see JoinStrategy#multiplyBaseCostByOuterRows */
1: 	public boolean multiplyBaseCostByOuterRows() {
1: 		return true;
1: 	}
1: 
1: 	/**
1: 	 * @see JoinStrategy#getBasePredicates
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public OptimizablePredicateList getBasePredicates(
1: 									OptimizablePredicateList predList,
1: 									OptimizablePredicateList basePredicates,
1: 									Optimizable innerTable)
1: 							throws StandardException {
1: 		if (SanityManager.DEBUG) {
1: 			SanityManager.ASSERT(basePredicates == null ||
1: 								 basePredicates.size() == 0,
1: 				"The base predicate list should be empty.");
1: 		}
1: 
1: 		if (predList != null) {
1: 			predList.transferAllPredicates(basePredicates);
1: 			basePredicates.classify(innerTable,
1: 				innerTable.getCurrentAccessPath().getConglomerateDescriptor());
1: 		}
1: 
1: 		return basePredicates;
1: 	}
1: 
1: 	/** @see JoinStrategy#nonBasePredicateSelectivity */
1: 	public double nonBasePredicateSelectivity(
1: 										Optimizable innerTable,
1: 										OptimizablePredicateList predList) {
1: 		/*
1: 		** For nested loop, all predicates are base predicates, so there
1: 		** is no extra selectivity.
1: 		*/
1: 		return 1.0;
1: 	}
1: 	
1: 	/**
1: 	 * @see JoinStrategy#putBasePredicates
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public void putBasePredicates(OptimizablePredicateList predList,
1: 									OptimizablePredicateList basePredicates)
1: 					throws StandardException {
1: 		for (int i = basePredicates.size() - 1; i >= 0; i--) {
1: 			OptimizablePredicate pred = basePredicates.getOptPredicate(i);
1: 
1: 			predList.addOptPredicate(pred);
1: 			basePredicates.removeOptPredicate(i);
1: 		}
1: 	}
1: 
1: 	/* @see JoinStrategy#estimateCost */
1: 	public void estimateCost(Optimizable innerTable,
1: 							 OptimizablePredicateList predList,
1: 							 ConglomerateDescriptor cd,
1: 							 CostEstimate outerCost,
1: 							 Optimizer optimizer,
1: 							 CostEstimate costEstimate) {
1: 		costEstimate.multiply(outerCost.rowCount(), costEstimate);
1: 
0: 		optimizer.trace(Optimizer.COST_OF_N_SCANS, innerTable.getTableNumber(), 0, outerCost.rowCount(),
0: 						costEstimate);
1: 	}
1: 
0: 	/** @see JoinStrategy#memoryUsage */
0: 	public double memoryUsage(double memoryPerRow, double rowCount) {
0: 		return 0.0;
1: 	}
1: 
1: 	/** @see JoinStrategy#getName */
1: 	public String getName() {
1: 		return "NESTEDLOOP";
1: 	}
1: 
1: 	/** @see JoinStrategy#scanCostType */
1: 	public int scanCostType() {
1: 		return StoreCostController.STORECOST_SCAN_NORMAL;
1: 	}
1: 
1: 	/** @see JoinStrategy#resultSetMethodName */
0: 	public String resultSetMethodName(boolean bulkFetch) {
0: 		if (bulkFetch)
1: 			return "getBulkTableScanResultSet";
1: 		else
1: 			return "getTableScanResultSet";
1: 	}
1: 
1: 	/** @see JoinStrategy#joinResultSetMethodName */
1: 	public String joinResultSetMethodName() {
1: 		return "getNestedLoopJoinResultSet";
1: 	}
1: 
1: 	/** @see JoinStrategy#halfOuterJoinResultSetMethodName */
1: 	public String halfOuterJoinResultSetMethodName() {
1: 		return "getNestedLoopLeftOuterJoinResultSet";
1: 	}
1: 
1: 	/**
1: 	 * @see JoinStrategy#getScanArgs
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public int getScanArgs(
1: 							TransactionController tc,
1: 							MethodBuilder mb,
1: 							Optimizable innerTable,
1: 							OptimizablePredicateList storeRestrictionList,
1: 							OptimizablePredicateList nonStoreRestrictionList,
1: 							ExpressionClassBuilderInterface acbi,
1: 							int bulkFetch,
0: 							MethodBuilder resultRowAllocator,
1: 							int colRefItem,
1: 							int indexColItem,
1: 							int lockMode,
1: 							boolean tableLocked,
0: 							int isolationLevel
1: 							)
1: 						throws StandardException {
1: 		ExpressionClassBuilder acb = (ExpressionClassBuilder) acbi;
1: 		int numArgs;
1: 
1: 		if (SanityManager.DEBUG) {
1: 			if (nonStoreRestrictionList.size() != 0) {
1: 				SanityManager.THROWASSERT(
1: 					"nonStoreRestrictionList should be empty for " +
1: 					"nested loop join strategy, but it contains " +
1: 					nonStoreRestrictionList.size() +
1: 					" elements");
1: 			}
1: 		}
1: 
0: 		if (bulkFetch > 1)
1: 		{
0: 			numArgs = 25;
1: 		}
1: 		else
1: 		{
0: 			numArgs = 24;
1: 		}
1: 
1: 		fillInScanArgs1(tc, mb,
1: 										innerTable,
1: 										storeRestrictionList,
1: 										acb,
0: 										resultRowAllocator);
1: 
1: 		fillInScanArgs2(mb,
1: 						innerTable,
1: 						bulkFetch,
1: 						colRefItem,
1: 						indexColItem,
1: 						lockMode,
1: 						tableLocked,
1: 						isolationLevel);
1: 
1: 		return numArgs;
1: 	}
1: 
1: 	/**
1: 	 * @see JoinStrategy#divideUpPredicateLists
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public void divideUpPredicateLists(
1: 					Optimizable				 innerTable,
1: 					OptimizablePredicateList originalRestrictionList,
1: 					OptimizablePredicateList storeRestrictionList,
1: 					OptimizablePredicateList nonStoreRestrictionList,
1: 					OptimizablePredicateList requalificationRestrictionList,
1: 					DataDictionary			 dd
1: 					) throws StandardException
1: 	{
1: 		/*
1: 		** All predicates are store predicates.  No requalification is
1: 		** necessary for non-covering index scans.
1: 		*/
1: 		originalRestrictionList.setPredicatesAndProperties(storeRestrictionList);
1: 	}
1: 
1: 	/**
1: 	 * @see JoinStrategy#doesMaterialization
1: 	 */
1: 	public boolean doesMaterialization()
1: 	{
1: 		return false;
1: 	}
1: 
1: 	public String toString() {
1: 		return getName();
1: 	}
1: 
1: 	/**
1: 	 * Can this join strategy be used on the
1: 	 * outermost table of a join.
1: 	 *
1: 	 * @return Whether or not this join strategy
0: 	 * can be used on the outermose table of a join.
1: 	 */
1: 	protected boolean validForOutermostTable()
1: 	{
1: 		return true;
1: 	}
1: }
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2d37fd6
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:c7248d5
/////////////////////////////////////////////////////////////////////////
0: 			numArgs = 26;
0: 			numArgs = 25;
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:b223f72
/////////////////////////////////////////////////////////////////////////
1: 	/** @see JoinStrategy#maxCapacity */
1: 	public int maxCapacity( int userSpecifiedCapacity,
1:                             int maxMemoryPerTable,
1:                             double perRowUsage) {
1: 		return Integer.MAX_VALUE;
/////////////////////////////////////////////////////////////////////////
1: 							int isolationLevel,
0:                             int maxMemoryPerTable
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.sql.compile;
0: 
0: import org.apache.derby.iapi.sql.compile.CostEstimate;
0: import org.apache.derby.iapi.sql.compile.ExpressionClassBuilderInterface;
0: import org.apache.derby.iapi.sql.compile.JoinStrategy;
0: import org.apache.derby.iapi.sql.compile.Optimizable;
0: import org.apache.derby.iapi.sql.compile.Optimizer;
0: import org.apache.derby.iapi.sql.compile.OptimizablePredicateList;
0: import org.apache.derby.iapi.sql.compile.OptimizablePredicate;
0: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
0: 
0: import org.apache.derby.iapi.store.access.StoreCostController;
0: import org.apache.derby.iapi.store.access.TransactionController;
0: 
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
0: 
0: import org.apache.derby.impl.sql.compile.ExpressionClassBuilder;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: public class NestedLoopJoinStrategy extends BaseJoinStrategy { 
0: 
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
0: 	public NestedLoopJoinStrategy() {
0: 	}
0: 
0: 
0: 	/**
0: 	 * @see JoinStrategy#feasible
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public boolean feasible(Optimizable innerTable,
0: 							OptimizablePredicateList predList,
0: 							Optimizer optimizer
0: 							)
0: 					throws StandardException 
0: 	{
0: 		/* Nested loop is feasible, except in the corner case
0: 		 * where innerTable is a VTI that cannot be materialized
0: 		 * (because it has a join column as a parameter) and
0: 		 * it cannot be instantiated multiple times.
0: 		 * RESOLVE - Actually, the above would work if all of 
0: 		 * the tables outer to innerTable were 1 row tables, but
0: 		 * we don't have that info yet, and it should probably
0: 		 * be hidden in inner table somewhere.
0: 		 * NOTE: A derived table that is correlated with an outer
0: 		 * query block is not materializable, but it can be
0: 		 * "instantiated" multiple times because that only has
0: 		 * meaning for VTIs.
0: 		 */
0: 		if (innerTable.isMaterializable())
0: 		{
0: 			return true;
0: 		}
0: 		if (innerTable.supportsMultipleInstantiations())
0: 		{
0: 			return true;
0: 		}
0: 		return false;
0: 	}
0: 
0: 	/** @see JoinStrategy#multiplyBaseCostByOuterRows */
0: 	public boolean multiplyBaseCostByOuterRows() {
0: 		return true;
0: 	}
0: 
0: 	/**
0: 	 * @see JoinStrategy#getBasePredicates
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public OptimizablePredicateList getBasePredicates(
0: 									OptimizablePredicateList predList,
0: 									OptimizablePredicateList basePredicates,
0: 									Optimizable innerTable)
0: 							throws StandardException {
0: 		if (SanityManager.DEBUG) {
0: 			SanityManager.ASSERT(basePredicates == null ||
0: 								 basePredicates.size() == 0,
0: 				"The base predicate list should be empty.");
0: 		}
0: 
0: 		if (predList != null) {
0: 			predList.transferAllPredicates(basePredicates);
0: 			basePredicates.classify(innerTable,
0: 				innerTable.getCurrentAccessPath().getConglomerateDescriptor());
0: 		}
0: 
0: 		return basePredicates;
0: 	}
0: 
0: 	/** @see JoinStrategy#nonBasePredicateSelectivity */
0: 	public double nonBasePredicateSelectivity(
0: 										Optimizable innerTable,
0: 										OptimizablePredicateList predList) {
0: 		/*
0: 		** For nested loop, all predicates are base predicates, so there
0: 		** is no extra selectivity.
0: 		*/
0: 		return 1.0;
0: 	}
0: 	
0: 	/**
0: 	 * @see JoinStrategy#putBasePredicates
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void putBasePredicates(OptimizablePredicateList predList,
0: 									OptimizablePredicateList basePredicates)
0: 					throws StandardException {
0: 		for (int i = basePredicates.size() - 1; i >= 0; i--) {
0: 			OptimizablePredicate pred = basePredicates.getOptPredicate(i);
0: 
0: 			predList.addOptPredicate(pred);
0: 			basePredicates.removeOptPredicate(i);
0: 		}
0: 	}
0: 
0: 	/* @see JoinStrategy#estimateCost */
0: 	public void estimateCost(Optimizable innerTable,
0: 							 OptimizablePredicateList predList,
0: 							 ConglomerateDescriptor cd,
0: 							 CostEstimate outerCost,
0: 							 Optimizer optimizer,
0: 							 CostEstimate costEstimate) {
0: 		costEstimate.multiply(outerCost.rowCount(), costEstimate);
0: 
0: 		optimizer.trace(Optimizer.COST_OF_N_SCANS, innerTable.getTableNumber(), 0, outerCost.rowCount(),
0: 						costEstimate);
0: 	}
0: 
0: 	/** @see JoinStrategy#memoryUsage */
0: 	public double memoryUsage(double memoryPerRow, double rowCount) {
0: 		return 0.0;
0: 	}
0: 
0: 	/** @see JoinStrategy#getName */
0: 	public String getName() {
0: 		return "NESTEDLOOP";
0: 	}
0: 
0: 	/** @see JoinStrategy#scanCostType */
0: 	public int scanCostType() {
0: 		return StoreCostController.STORECOST_SCAN_NORMAL;
0: 	}
0: 
0: 	/** @see JoinStrategy#resultSetMethodName */
0: 	public String resultSetMethodName(boolean bulkFetch) {
0: 		if (bulkFetch)
0: 			return "getBulkTableScanResultSet";
0: 		else
0: 			return "getTableScanResultSet";
0: 	}
0: 
0: 	/** @see JoinStrategy#joinResultSetMethodName */
0: 	public String joinResultSetMethodName() {
0: 		return "getNestedLoopJoinResultSet";
0: 	}
0: 
0: 	/** @see JoinStrategy#halfOuterJoinResultSetMethodName */
0: 	public String halfOuterJoinResultSetMethodName() {
0: 		return "getNestedLoopLeftOuterJoinResultSet";
0: 	}
0: 
0: 	/**
0: 	 * @see JoinStrategy#getScanArgs
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public int getScanArgs(
0: 							TransactionController tc,
0: 							MethodBuilder mb,
0: 							Optimizable innerTable,
0: 							OptimizablePredicateList storeRestrictionList,
0: 							OptimizablePredicateList nonStoreRestrictionList,
0: 							ExpressionClassBuilderInterface acbi,
0: 							int bulkFetch,
0: 							MethodBuilder resultRowAllocator,
0: 							int colRefItem,
0: 							int indexColItem,
0: 							int lockMode,
0: 							boolean tableLocked,
0: 							int isolationLevel
0: 							)
0: 						throws StandardException {
0: 		ExpressionClassBuilder acb = (ExpressionClassBuilder) acbi;
0: 		int numArgs;
0: 
0: 		if (SanityManager.DEBUG) {
0: 			if (nonStoreRestrictionList.size() != 0) {
0: 				SanityManager.THROWASSERT(
0: 					"nonStoreRestrictionList should be empty for " +
0: 					"nested loop join strategy, but it contains " +
0: 					nonStoreRestrictionList.size() +
0: 					" elements");
0: 			}
0: 		}
0: 
0: 		if (bulkFetch > 1)
0: 		{
0: 			numArgs = 25;
0: 		}
0: 		else
0: 		{
0: 			numArgs = 24;
0: 		}
0: 
0: 		fillInScanArgs1(tc, mb,
0: 										innerTable,
0: 										storeRestrictionList,
0: 										acb,
0: 										resultRowAllocator);
0: 
0: 		fillInScanArgs2(mb,
0: 						innerTable,
0: 						bulkFetch,
0: 						colRefItem,
0: 						indexColItem,
0: 						lockMode,
0: 						tableLocked,
0: 						isolationLevel);
0: 
0: 		return numArgs;
0: 	}
0: 
0: 	/**
0: 	 * @see JoinStrategy#divideUpPredicateLists
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void divideUpPredicateLists(
0: 					Optimizable				 innerTable,
0: 					OptimizablePredicateList originalRestrictionList,
0: 					OptimizablePredicateList storeRestrictionList,
0: 					OptimizablePredicateList nonStoreRestrictionList,
0: 					OptimizablePredicateList requalificationRestrictionList,
0: 					DataDictionary			 dd
0: 					) throws StandardException
0: 	{
0: 		/*
0: 		** All predicates are store predicates.  No requalification is
0: 		** necessary for non-covering index scans.
0: 		*/
0: 		originalRestrictionList.setPredicatesAndProperties(storeRestrictionList);
0: 	}
0: 
0: 	/**
0: 	 * @see JoinStrategy#doesMaterialization
0: 	 */
0: 	public boolean doesMaterialization()
0: 	{
0: 		return false;
0: 	}
0: 
0: 	public String toString() {
0: 		return getName();
0: 	}
0: 
0: 	/**
0: 	 * Can this join strategy be used on the
0: 	 * outermost table of a join.
0: 	 *
0: 	 * @return Whether or not this join strategy
0: 	 * can be used on the outermose table of a join.
0: 	 */
0: 	protected boolean validForOutermostTable()
0: 	{
0: 		return true;
0: 	}
0: }
============================================================================