1:33776ff: /*
38:33776ff: 
1:33776ff:    Derby - Class org.apache.derby.client.am.Agent
1:33776ff: 
1:59bf37d:    Licensed to the Apache Software Foundation (ASF) under one or more
1:59bf37d:    contributor license agreements.  See the NOTICE file distributed with
1:59bf37d:    this work for additional information regarding copyright ownership.
1:59bf37d:    The ASF licenses this file to You under the Apache License, Version 2.0
1:59bf37d:    (the "License"); you may not use this file except in compliance with
1:59bf37d:    the License.  You may obtain a copy of the License at
1:33776ff: 
1:33776ff:       http://www.apache.org/licenses/LICENSE-2.0
1:33776ff: 
1:33776ff:    Unless required by applicable law or agreed to in writing, software
1:33776ff:    distributed under the License is distributed on an "AS IS" BASIS,
1:33776ff:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:33776ff:    See the License for the specific language governing permissions and
1:33776ff:    limitations under the License.
1:33776ff: 
1:33776ff: */
1:33776ff: 
1:33776ff: package org.apache.derby.client.am;
1:33776ff: 
1:69e3d06: import java.io.PrintWriter;
1:69e3d06: import java.sql.BatchUpdateException;
1:69e3d06: import java.sql.Types;
1:b54918e: import org.apache.derby.jdbc.ClientDriver;
1:9f0c37a: import org.apache.derby.shared.common.reference.JDBC40Translation;
1:5d2e2bd: import org.apache.derby.shared.common.reference.SQLState;
1:5d2e2bd: 
1:70f7692: public abstract class Agent {
1:0326967:     SqlException accumulatedReadExceptions_ = null;
1:33776ff: 
1:70f7692:     private boolean enableBatchedExceptionTracking_;
1:70f7692:     private int batchedExceptionLabelIndex_;
1:70f7692:     private boolean[] batchedExceptionGenerated_;
1:33776ff: 
1:69e3d06:     ClientConnection connection_; // made friendly for lobs only, refactor !!
1:0326967: 
1:0326967:     SectionManager sectionManager_ = null;
1:33776ff: 
1:70f7692:     public LogWriter logWriter_ = null;
1:33776ff: 
1:70f7692:     final CrossConverters crossConverters_;
1:33776ff: 
1:70f7692:     // Exceptions that occur on dnc's implementation of SqlException.getMessage() via stored proc
1:70f7692:     // cannot be thrown on the getMessage() invocation because the signature of getMessage() does not
1:70f7692:     // allow for throwing an exception.
1:70f7692:     // Therefore, we must save the exception and throw it at our very first opportunity.
1:0326967:     private SqlException deferredException_;
1:70f7692: 
1:70f7692:     void checkForDeferredExceptions() throws SqlException {
1:70f7692:         if (deferredException_ != null) {
1:70f7692:             SqlException temp = deferredException_;
1:70f7692:             deferredException_ = null;
1:70f7692:             throw temp;
1:70f7692:         }
36:33776ff:     }
1:33776ff: 
1:9f0c37a:     /**
1:9f0c37a:      * Checks whether a data type is supported for
1:9f0c37a:      * <code>setObject(int, Object, int)</code> and
1:9f0c37a:      * <code>setObject(int, Object, int, int)</code>.
1:9f0c37a:      *
1:9f0c37a:      * @param dataType the data type to check
1:9f0c37a:      * @exception SqlException if the type is not supported
1:9f0c37a:      */
1:0326967:     void checkForSupportedDataType(int dataType) throws SqlException {
1:9f0c37a: 
1:9f0c37a:         // JDBC 4.0 javadoc for setObject() says:
1:9f0c37a:         //
1:9f0c37a:         // Throws: (...) SQLFeatureNotSupportedException - if
1:9f0c37a:         // targetSqlType is a ARRAY, BLOB, CLOB, DATALINK,
1:9f0c37a:         // JAVA_OBJECT, NCHAR, NCLOB, NVARCHAR, LONGNVARCHAR, REF,
1:9f0c37a:         // ROWID, SQLXML or STRUCT data type and the JDBC driver does
1:9f0c37a:         // not support this data type
1:9f0c37a:         //
1:9f0c37a:         // Of these types, we only support BLOB, CLOB and
1:9f0c37a:         // (sort of) JAVA_OBJECT.
1:9f0c37a: 
1:9f0c37a:         switch (dataType) {
1:69e3d06:         case Types.ARRAY:
1:69e3d06:         case Types.DATALINK:
1:69e3d06:         case Types.DISTINCT:
1:e33b8d8:         case Types.NCHAR:
1:e33b8d8:         case Types.NCLOB:
1:e33b8d8:         case Types.NVARCHAR:
1:e33b8d8:         case Types.LONGNVARCHAR:
1:69e3d06:         case Types.NULL:
1:69e3d06:         case Types.OTHER:
1:69e3d06:         case Types.REF:
1:9f0c37a:         case JDBC40Translation.REF_CURSOR:
1:e33b8d8:         case Types.ROWID:
1:e33b8d8:         case Types.SQLXML:
1:69e3d06:         case Types.STRUCT:
1:9f0c37a:             throw new SqlException
1:9f0c37a:                 (logWriter_,
1:9f0c37a:                  new ClientMessageId(SQLState.DATA_TYPE_NOT_SUPPORTED),
1:69e3d06:                  ClientTypes.getTypeString(dataType));
1:9f0c37a:         }
1:9f0c37a:     }
1:9f0c37a: 
1:0326967:     void accumulateDeferredException(SqlException e) {
1:70f7692:         if (deferredException_ == null) {
1:70f7692:             deferredException_ = e;
1:70f7692:         } else {
1:70f7692:             deferredException_.setNextException(e);
1:70f7692:         }
1:33776ff:     }
1:33776ff: 
1:69e3d06:     protected Agent(ClientConnection connection, LogWriter logWriter) {
1:70f7692:         connection_ = connection;
1:70f7692:         logWriter_ = logWriter;
1:70f7692:         crossConverters_ = new CrossConverters(this);
1:33776ff:     }
1:33776ff: 
1:0326967:     private void resetAgent(LogWriter logWriter) {
1:70f7692:         // sectionManager_ is set elsewhere
1:70f7692:         accumulatedReadExceptions_ = null;
1:70f7692:         enableBatchedExceptionTracking_ = false;
1:70f7692:         batchedExceptionLabelIndex_ = 0;
1:70f7692:         batchedExceptionGenerated_ = null;
1:70f7692:         logWriter_ = logWriter;
1:70f7692:         deferredException_ = null;
1:33776ff:     }
1:33776ff: 
1:0326967:     void resetAgent(
1:69e3d06:         ClientConnection connection,
1:69e3d06:         LogWriter logWriter,
1:69e3d06:         int loginTimeout,
1:69e3d06:         String server,
1:69e3d06:         int port) throws SqlException {
1:69e3d06: 
1:70f7692:         resetAgent(logWriter);
1:70f7692:         resetAgent_(logWriter, loginTimeout, server, port);
1:33776ff:     }
1:70f7692: 
1:70f7692:     abstract protected void resetAgent_(LogWriter logWriter, int loginTimeout, String server, int port) throws SqlException;
1:70f7692: 
1:70f7692:     //-------------------- entry points ------------------------------------------
1:70f7692: 
1:70f7692:     public final boolean loggingEnabled() {
1:9fd9272:         return logWriter_ != null;
1:33776ff:     }
1:70f7692: 
1:70f7692:     public final void setLogWriter(LogWriter logWriter) {
1:70f7692:         synchronized (connection_) {
1:70f7692:             if (logWriter_ != null) {
1:70f7692:                 logWriter_.close();
1:70f7692:             }
1:70f7692:             logWriter_ = logWriter;
1:70f7692:         }
1:33776ff:     }
1:70f7692: 
1:69e3d06:     public final PrintWriter getLogWriter() {
1:70f7692:         return (logWriter_ == null) ? null : logWriter_.printWriter_;
1:70f7692:     }
1:70f7692: 
1:70f7692:     //----------------------------------------------------------------------------
1:70f7692: 
1:70f7692: 
1:70f7692:     public final void accumulateReadException(SqlException e) {
1:70f7692:         if (enableBatchedExceptionTracking_) {
1:70f7692:             batchedExceptionGenerated_[batchedExceptionLabelIndex_] = true;
1:70f7692:             labelAsBatchedException(e, batchedExceptionLabelIndex_);
1:70f7692:         }
1:70f7692:         if (accumulatedReadExceptions_ == null) {
1:70f7692:             accumulatedReadExceptions_ = e;
1:70f7692:         } else {
1:70f7692:             accumulatedReadExceptions_.setNextException(e);
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:70f7692:     // Called only for disconnect event
1:0326967:     private void accumulateDisconnectException(DisconnectException e) {
1:70f7692:         if (enableBatchedExceptionTracking_) {
1:70f7692:             batchedExceptionGenerated_[batchedExceptionLabelIndex_] = true;
1:70f7692:             labelAsBatchedException(e, batchedExceptionLabelIndex_);
1:70f7692:         }
1:70f7692:         if (accumulatedReadExceptions_ != null) {
1:70f7692:             e.setNextException(accumulatedReadExceptions_);
1:70f7692:         }
1:70f7692: 
1:70f7692:         accumulatedReadExceptions_ = null;
1:70f7692:     }
1:70f7692: 
1:70f7692:     // For now, it looks like the only time we accumulate chain breaking exceptions
1:70f7692:     // is for disconnect exceptions.
1:70f7692:     public final void accumulateChainBreakingReadExceptionAndThrow(DisconnectException e) throws DisconnectException {
1:70f7692:         accumulateDisconnectException(e); // tacks disconnect exc to end of chain
1:70f7692:         markChainBreakingException_(); // sets a severity code in the NET agent
1:70f7692:         throw e; // disconnect will be caught in Reply classes, and front of original chain thrown
1:70f7692:     }
1:70f7692: 
1:70f7692:     abstract protected void markChainBreakingException_();
1:70f7692: 
1:70f7692:     abstract public void checkForChainBreakingException_() throws SqlException;
1:70f7692: 
1:70f7692:     private final void enableBatchedExceptionTracking(int batchSize) {
1:70f7692:         enableBatchedExceptionTracking_ = true;
1:70f7692:         batchedExceptionGenerated_ = new boolean[batchSize];
1:70f7692:         batchedExceptionLabelIndex_ = 0;
1:70f7692:     }
1:70f7692: 
1:70f7692:     final void disableBatchedExceptionTracking() {
1:70f7692:         enableBatchedExceptionTracking_ = false;
1:70f7692:     }
1:70f7692: 
1:70f7692:     public final void setBatchedExceptionLabelIndex(int index) {
1:70f7692:         batchedExceptionLabelIndex_ = index;
1:70f7692:     }
1:70f7692: 
1:70f7692:     private final SqlException labelAsBatchedException(SqlException e, int index) {
1:70f7692:         SqlException firstInChain = e;
1:70f7692:         while (e != null) {
1:70f7692:             e.setBatchPositionLabel(index);
1:70f7692:             e = (SqlException) e.getNextException();
1:70f7692:         }
1:70f7692:         return firstInChain;
1:70f7692:     }
1:70f7692: 
1:70f7692:     protected final void checkForExceptions() throws SqlException {
1:70f7692:         if (accumulatedReadExceptions_ != null) {
1:70f7692:             SqlException e = accumulatedReadExceptions_;
1:70f7692:             accumulatedReadExceptions_ = null;
1:70f7692:             throw e;
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:69e3d06:     public final void flow(ClientStatement statement) throws SqlException {
1:70f7692:         endWriteChain();
1:70f7692:         flush_();
1:70f7692:         beginReadChain(statement);
1:70f7692:     }
1:70f7692: 
1:0326967:     final void flowBatch(ClientStatement statement, int batchSize)
1:69e3d06:             throws SqlException {
1:70f7692:         endBatchedWriteChain();
1:70f7692:         flush_();
1:70f7692:         beginBatchedReadChain(statement, batchSize);
1:70f7692:     }
1:70f7692: 
1:70f7692:     public final void flowOutsideUOW() throws SqlException {
1:70f7692:         endWriteChain();
1:70f7692:         flush_();
1:70f7692:         beginReadChainOutsideUOW();
1:70f7692:     }
1:70f7692: 
1:70f7692:     // flush() means to send all chained requests.
1:70f7692:     abstract public void flush_() throws DisconnectException;
1:70f7692: 
1:70f7692:     // Close client resources associated with this agent, such as socket and streams for the net.
1:70f7692:     abstract public void close_() throws SqlException;
1:70f7692: 
1:70f7692:     public void close() throws SqlException {
1:70f7692:         close_();
1:70f7692:         if (logWriter_ != null) {
1:70f7692:             logWriter_.close();
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:0326967:     final void disconnectEvent() {
1:70f7692:         // closes client-side resources associated with database connection
1:70f7692:         try {
1:70f7692:             close();
1:70f7692:         } catch (SqlException doNothing) {
1:70f7692:         }
1:70f7692:         connection_.completeChainBreakingDisconnect();
1:70f7692:     }
1:b862050:     
1:b862050:     abstract public void beginWriteChainOutsideUOW() throws SqlException;
1:70f7692: 
1:69e3d06:     public void beginWriteChain(ClientStatement statement) throws SqlException {
1:70f7692:         connection_.writeTransactionStart(statement);
1:70f7692:     }
1:70f7692: 
1:0326967:     final void beginBatchedWriteChain(ClientStatement statement)
1:69e3d06:             throws SqlException {
1:70f7692:         beginWriteChain(statement);
1:70f7692:     }
1:70f7692: 
1:b862050:     abstract protected void endWriteChain();
1:70f7692: 
1:0326967:     private final void endBatchedWriteChain() {
1:b862050:         endWriteChain();
1:70f7692:     }
1:70f7692: 
1:69e3d06:     protected void beginReadChain(ClientStatement statement)
1:69e3d06:             throws SqlException {
1:70f7692:         connection_.readTransactionStart();
1:70f7692:     }
1:70f7692: 
1:0326967:     private void beginBatchedReadChain(
1:69e3d06:         ClientStatement statement,
1:69e3d06:         int batchSize)
1:69e3d06:             throws SqlException {
1:69e3d06: 
1:70f7692:         enableBatchedExceptionTracking(batchSize);
1:70f7692:         beginReadChain(statement);
1:70f7692:     }
1:70f7692: 
1:70f7692:     protected void beginReadChainOutsideUOW() throws SqlException {
1:70f7692:     }
1:70f7692: 
1:70f7692:     public void endReadChain() throws SqlException {
1:70f7692:         checkForExceptions();
1:70f7692:     }
1:70f7692: 
1:0326967:     final void endBatchedReadChain(long[] updateCounts,
1:0326967:                                    SqlException accumulatedExceptions)
1:0326967:             throws BatchUpdateException {
1:0326967: 
1:70f7692:         disableBatchedExceptionTracking();
1:70f7692:         for (int i = 0; i < batchedExceptionGenerated_.length; i++) {
1:70f7692:             if (batchedExceptionGenerated_[i]) {
1:70f7692:                 updateCounts[i] = -3;
1:70f7692:             }
1:70f7692:         }
1:70f7692:         if (accumulatedExceptions == null) {
1:70f7692:             try {
1:70f7692:                 endReadChain();
1:70f7692:             } catch (SqlException e) {
1:70f7692:                 accumulatedExceptions = e;
1:70f7692:             }
1:70f7692:         }
1:70f7692:         if (accumulatedExceptions != null) {
1:b54918e:             throw ClientDriver.getFactory().newBatchUpdateException(logWriter_,
1:e65b4db:                 new ClientMessageId(SQLState.BATCH_NON_ATOMIC_FAILURE),
1:465c7c7:                 null, updateCounts, accumulatedExceptions);
1:70f7692:         }
1:70f7692:     }
1:70f7692: }
1:70f7692: 
1:33776ff: 
============================================================================
author:Dyre Tjeldvoll
-------------------------------------------------------------------------------
commit:b862050
/////////////////////////////////////////////////////////////////////////
1:     
1:     abstract public void beginWriteChainOutsideUOW() throws SqlException;
/////////////////////////////////////////////////////////////////////////
1:     abstract protected void endWriteChain();
1:         endWriteChain();
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:6372907
/////////////////////////////////////////////////////////////////////////
commit:e33b8d8
/////////////////////////////////////////////////////////////////////////
1:         case Types.NCHAR:
1:         case Types.NCLOB:
1:         case Types.NVARCHAR:
1:         case Types.LONGNVARCHAR:
1:         case Types.ROWID:
1:         case Types.SQLXML:
commit:465c7c7
/////////////////////////////////////////////////////////////////////////
0:             throw new BatchUpdateException(logWriter_,
1:                 null, updateCounts, accumulatedExceptions);
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:0326967
/////////////////////////////////////////////////////////////////////////
1:     SqlException accumulatedReadExceptions_ = null;
1: 
1:     SectionManager sectionManager_ = null;
/////////////////////////////////////////////////////////////////////////
1:     private SqlException deferredException_;
/////////////////////////////////////////////////////////////////////////
1:     void checkForSupportedDataType(int dataType) throws SqlException {
/////////////////////////////////////////////////////////////////////////
1:     void accumulateDeferredException(SqlException e) {
/////////////////////////////////////////////////////////////////////////
1:     private void resetAgent(LogWriter logWriter) {
/////////////////////////////////////////////////////////////////////////
1:     void resetAgent(
/////////////////////////////////////////////////////////////////////////
1:     private void accumulateDisconnectException(DisconnectException e) {
/////////////////////////////////////////////////////////////////////////
1:     final void flowBatch(ClientStatement statement, int batchSize)
/////////////////////////////////////////////////////////////////////////
1:     final void disconnectEvent() {
/////////////////////////////////////////////////////////////////////////
1:     final void beginBatchedWriteChain(ClientStatement statement)
/////////////////////////////////////////////////////////////////////////
1:     private final void endBatchedWriteChain() {
/////////////////////////////////////////////////////////////////////////
1:     private void beginBatchedReadChain(
/////////////////////////////////////////////////////////////////////////
1:     final void endBatchedReadChain(long[] updateCounts,
1:                                    SqlException accumulatedExceptions)
1:             throws BatchUpdateException {
1: 
commit:69e3d06
/////////////////////////////////////////////////////////////////////////
1: import java.io.PrintWriter;
1: import java.sql.BatchUpdateException;
1: import java.sql.Types;
/////////////////////////////////////////////////////////////////////////
1:     ClientConnection connection_; // made friendly for lobs only, refactor !!
/////////////////////////////////////////////////////////////////////////
1:         case Types.ARRAY:
1:         case Types.DATALINK:
1:         case Types.DISTINCT:
1:         case Types.NULL:
1:         case Types.OTHER:
1:         case Types.REF:
1:         case Types.STRUCT:
1:                  ClientTypes.getTypeString(dataType));
/////////////////////////////////////////////////////////////////////////
1:     protected Agent(ClientConnection connection, LogWriter logWriter) {
/////////////////////////////////////////////////////////////////////////
0:     public void resetAgent(
1:         ClientConnection connection,
1:         LogWriter logWriter,
1:         int loginTimeout,
1:         String server,
1:         int port) throws SqlException {
1: 
/////////////////////////////////////////////////////////////////////////
1:     public final PrintWriter getLogWriter() {
0:     abstract public LogWriter newLogWriter_(
0:         PrintWriter printWriter, int traceLevel);
/////////////////////////////////////////////////////////////////////////
1:     public final void flow(ClientStatement statement) throws SqlException {
0:     public final void flowBatch(ClientStatement statement, int batchSize)
1:             throws SqlException {
/////////////////////////////////////////////////////////////////////////
1:     public void beginWriteChain(ClientStatement statement) throws SqlException {
0:     public final void beginBatchedWriteChain(ClientStatement statement)
1:             throws SqlException {
/////////////////////////////////////////////////////////////////////////
1:     protected void beginReadChain(ClientStatement statement)
1:             throws SqlException {
0:     protected final void beginBatchedReadChain(
1:         ClientStatement statement,
1:         int batchSize)
1:             throws SqlException {
1: 
/////////////////////////////////////////////////////////////////////////
0:         throws BatchUpdateException {
commit:9fd9272
/////////////////////////////////////////////////////////////////////////
1:         return logWriter_ != null;
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:01c7f83
/////////////////////////////////////////////////////////////////////////
0:         case java.sql.Types.DISTINCT:
0:         case java.sql.Types.NULL:
0:         case java.sql.Types.OTHER:
commit:9f0c37a
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.reference.JDBC40Translation;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Checks whether a data type is supported for
1:      * <code>setObject(int, Object, int)</code> and
1:      * <code>setObject(int, Object, int, int)</code>.
1:      *
1:      * @param dataType the data type to check
1:      * @exception SqlException if the type is not supported
1:      */
0:     public void checkForSupportedDataType(int dataType) throws SqlException {
1: 
1:         // JDBC 4.0 javadoc for setObject() says:
1:         //
1:         // Throws: (...) SQLFeatureNotSupportedException - if
1:         // targetSqlType is a ARRAY, BLOB, CLOB, DATALINK,
1:         // JAVA_OBJECT, NCHAR, NCLOB, NVARCHAR, LONGNVARCHAR, REF,
1:         // ROWID, SQLXML or STRUCT data type and the JDBC driver does
1:         // not support this data type
1:         //
1:         // Of these types, we only support BLOB, CLOB and
1:         // (sort of) JAVA_OBJECT.
1: 
1:         switch (dataType) {
0:         case java.sql.Types.ARRAY:
0:         case java.sql.Types.DATALINK:
0:         case JDBC40Translation.NCHAR:
0:         case JDBC40Translation.NCLOB:
0:         case JDBC40Translation.NVARCHAR:
0:         case JDBC40Translation.LONGNVARCHAR:
0:         case java.sql.Types.REF:
1:         case JDBC40Translation.REF_CURSOR:
0:         case JDBC40Translation.ROWID:
0:         case JDBC40Translation.SQLXML:
0:         case java.sql.Types.STRUCT:
1:             throw new SqlException
1:                 (logWriter_,
1:                  new ClientMessageId(SQLState.DATA_TYPE_NOT_SUPPORTED),
0:                  Types.getTypeString(dataType));
1:         }
1:     }
1: 
commit:b54918e
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.jdbc.ClientDriver;
/////////////////////////////////////////////////////////////////////////
0:     public final void endBatchedReadChain(long[] updateCounts, SqlException accumulatedExceptions)
0:         throws java.sql.BatchUpdateException {
/////////////////////////////////////////////////////////////////////////
1:             throw ClientDriver.getFactory().newBatchUpdateException(logWriter_,
commit:f26c60c
/////////////////////////////////////////////////////////////////////////
0:     public final void endBatchedReadChain(long[] updateCounts, SqlException accumulatedExceptions) throws BatchUpdateException {
/////////////////////////////////////////////////////////////////////////
0:             throw BatchUpdateException.newBatchUpdateException(logWriter_,
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:59bf37d
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:David Van Couvering
-------------------------------------------------------------------------------
commit:e65b4db
/////////////////////////////////////////////////////////////////////////
1:                 new ClientMessageId(SQLState.BATCH_NON_ATOMIC_FAILURE),
commit:5d2e2bd
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.reference.SQLState;
1: 
/////////////////////////////////////////////////////////////////////////
0:             BatchUpdateException bue = new BatchUpdateException(logWriter_,
0:                 new MessageId(SQLState.BATCH_NON_ATOMIC_FAILURE),
0:                 updateCounts);
commit:d506170
/////////////////////////////////////////////////////////////////////////
0:             bue.setNextException(accumulatedExceptions.getSQLException());
author:Jeremy Boynes
-------------------------------------------------------------------------------
commit:70f7692
/////////////////////////////////////////////////////////////////////////
1: public abstract class Agent {
0:     public SqlException accumulatedReadExceptions_ = null;
1:     private boolean enableBatchedExceptionTracking_;
1:     private int batchedExceptionLabelIndex_;
1:     private boolean[] batchedExceptionGenerated_;
0:     Connection connection_; // made friendly for lobs only, refactor !!
0:     public SectionManager sectionManager_ = null; // temporarily public, make friendly at least !!
1:     public LogWriter logWriter_ = null;
1:     final CrossConverters crossConverters_;
1:     // Exceptions that occur on dnc's implementation of SqlException.getMessage() via stored proc
1:     // cannot be thrown on the getMessage() invocation because the signature of getMessage() does not
1:     // allow for throwing an exception.
1:     // Therefore, we must save the exception and throw it at our very first opportunity.
0:     SqlException deferredException_;
1: 
1:     void checkForDeferredExceptions() throws SqlException {
1:         if (deferredException_ != null) {
1:             SqlException temp = deferredException_;
1:             deferredException_ = null;
1:             throw temp;
1:         }
0:     public void accumulateDeferredException(SqlException e) {
1:         if (deferredException_ == null) {
1:             deferredException_ = e;
1:         } else {
1:             deferredException_.setNextException(e);
1:         }
0:     protected Agent(Connection connection, LogWriter logWriter) {
1:         connection_ = connection;
1:         logWriter_ = logWriter;
1:         crossConverters_ = new CrossConverters(this);
0:     protected void resetAgent(LogWriter logWriter) {
1:         // sectionManager_ is set elsewhere
1:         accumulatedReadExceptions_ = null;
1:         enableBatchedExceptionTracking_ = false;
1:         batchedExceptionLabelIndex_ = 0;
1:         batchedExceptionGenerated_ = null;
1:         logWriter_ = logWriter;
1:         deferredException_ = null;
0:     public void resetAgent(Connection connection, LogWriter logWriter, int loginTimeout, String server, int port) throws SqlException {
1:         resetAgent(logWriter);
1:         resetAgent_(logWriter, loginTimeout, server, port);
1:     abstract protected void resetAgent_(LogWriter logWriter, int loginTimeout, String server, int port) throws SqlException;
1: 
1:     //-------------------- entry points ------------------------------------------
1: 
1:     public final boolean loggingEnabled() {
0:         return !org.apache.derby.client.am.Configuration.traceSuspended__ && logWriter_ != null;
1:     public final void setLogWriter(LogWriter logWriter) {
1:         synchronized (connection_) {
1:             if (logWriter_ != null) {
1:                 logWriter_.close();
1:             }
1:             logWriter_ = logWriter;
1:         }
1: 
0:     public final java.io.PrintWriter getLogWriter() {
1:         return (logWriter_ == null) ? null : logWriter_.printWriter_;
1: 
0:     abstract public LogWriter newLogWriter_(java.io.PrintWriter printWriter, int traceLevel);
1: 
1:     //----------------------------------------------------------------------------
1: 
1: 
1:     public final void accumulateReadException(SqlException e) {
1:         if (enableBatchedExceptionTracking_) {
1:             batchedExceptionGenerated_[batchedExceptionLabelIndex_] = true;
1:             labelAsBatchedException(e, batchedExceptionLabelIndex_);
1:         }
1:         if (accumulatedReadExceptions_ == null) {
1:             accumulatedReadExceptions_ = e;
1:         } else {
1:             accumulatedReadExceptions_.setNextException(e);
1:         }
1: 
1:     // Called only for disconnect event
0:     public final void accumulateDisconnectException(DisconnectException e) {
1:         if (enableBatchedExceptionTracking_) {
1:             batchedExceptionGenerated_[batchedExceptionLabelIndex_] = true;
1:             labelAsBatchedException(e, batchedExceptionLabelIndex_);
1:         }
1:         if (accumulatedReadExceptions_ != null) {
1:             e.setNextException(accumulatedReadExceptions_);
1:         }
1: 
1:         accumulatedReadExceptions_ = null;
1:     }
1: 
1:     // For now, it looks like the only time we accumulate chain breaking exceptions
1:     // is for disconnect exceptions.
1:     public final void accumulateChainBreakingReadExceptionAndThrow(DisconnectException e) throws DisconnectException {
1:         accumulateDisconnectException(e); // tacks disconnect exc to end of chain
1:         markChainBreakingException_(); // sets a severity code in the NET agent
1:         throw e; // disconnect will be caught in Reply classes, and front of original chain thrown
1:     }
1: 
1:     abstract protected void markChainBreakingException_();
1: 
1:     abstract public void checkForChainBreakingException_() throws SqlException;
1: 
1:     private final void enableBatchedExceptionTracking(int batchSize) {
1:         enableBatchedExceptionTracking_ = true;
1:         batchedExceptionGenerated_ = new boolean[batchSize];
1:         batchedExceptionLabelIndex_ = 0;
1:     }
1: 
1:     final void disableBatchedExceptionTracking() {
1:         enableBatchedExceptionTracking_ = false;
1:     }
1: 
1:     public final void setBatchedExceptionLabelIndex(int index) {
1:         batchedExceptionLabelIndex_ = index;
1:     }
1: 
1:     private final SqlException labelAsBatchedException(SqlException e, int index) {
1:         SqlException firstInChain = e;
1:         while (e != null) {
1:             e.setBatchPositionLabel(index);
1:             e = (SqlException) e.getNextException();
1:         }
1:         return firstInChain;
1:     }
1: 
1:     protected final void checkForExceptions() throws SqlException {
1:         if (accumulatedReadExceptions_ != null) {
1:             SqlException e = accumulatedReadExceptions_;
1:             accumulatedReadExceptions_ = null;
1:             throw e;
1:         }
1:     }
1: 
0:     // precondition: all batch execute reads have occurred
0:     final boolean batchUpdateExceptionGenerated() {
0:         return batchedExceptionGenerated_[batchedExceptionLabelIndex_];
1:     }
1: 
0:     public final void flow(Statement statement) throws SqlException {
1:         endWriteChain();
1:         flush_();
1:         beginReadChain(statement);
1:     }
1: 
0:     public final void flowBatch(Statement statement, int batchSize) throws SqlException {
1:         endBatchedWriteChain();
1:         flush_();
1:         beginBatchedReadChain(statement, batchSize);
1:     }
1: 
1:     public final void flowOutsideUOW() throws SqlException {
1:         endWriteChain();
1:         flush_();
1:         beginReadChainOutsideUOW();
1:     }
1: 
1:     // flush() means to send all chained requests.
1:     abstract public void flush_() throws DisconnectException;
1: 
1:     // Close client resources associated with this agent, such as socket and streams for the net.
1:     abstract public void close_() throws SqlException;
1: 
1:     public void close() throws SqlException {
1:         close_();
1:         if (logWriter_ != null) {
1:             logWriter_.close();
1:         }
1:     }
1: 
0:     public final void disconnectEvent() {
1:         // closes client-side resources associated with database connection
1:         try {
1:             close();
1:         } catch (SqlException doNothing) {
1:         }
1:         connection_.completeChainBreakingDisconnect();
1:     }
1: 
0:     public void beginWriteChainOutsideUOW() throws SqlException {
1:     }
1: 
0:     public void beginWriteChain(Statement statement) throws SqlException {
1:         connection_.writeTransactionStart(statement);
1:     }
1: 
0:     public final void beginBatchedWriteChain(Statement statement) throws SqlException {
1:         beginWriteChain(statement);
1:     }
1: 
0:     protected void endWriteChain() {
1:     }
1: 
0:     protected final void endBatchedWriteChain() {
1:     }
1: 
0:     protected void beginReadChain(Statement statement) throws SqlException {
1:         connection_.readTransactionStart();
1:     }
1: 
0:     protected final void beginBatchedReadChain(Statement statement, int batchSize) throws SqlException {
1:         enableBatchedExceptionTracking(batchSize);
1:         beginReadChain(statement);
1:     }
1: 
1:     protected void beginReadChainOutsideUOW() throws SqlException {
1:     }
1: 
1:     public void endReadChain() throws SqlException {
1:         checkForExceptions();
1:     }
1: 
0:     public final void endBatchedReadChain(int[] updateCounts, SqlException accumulatedExceptions) throws BatchUpdateException {
1:         disableBatchedExceptionTracking();
1:         for (int i = 0; i < batchedExceptionGenerated_.length; i++) {
1:             if (batchedExceptionGenerated_[i]) {
1:                 updateCounts[i] = -3;
1:             }
1:         }
1:         if (accumulatedExceptions == null) {
1:             try {
1:                 endReadChain();
1:             } catch (SqlException e) {
1:                 accumulatedExceptions = e;
1:             }
1:         }
1:         if (accumulatedExceptions != null) {
0:             BatchUpdateException bue =
0:                     new BatchUpdateException(logWriter_,
0:                             "Non-atomic batch failure.  The batch was submitted, but " +
0:                     "at least one exception occurred on an individual member of the batch. " +
0:                     "Use getNextException() to retrieve the exceptions for specific batched elements.",
0:                             updateCounts);
0:             bue.setNextException(accumulatedExceptions);
0:             throw bue;
1:         }
1:     }
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:33776ff
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derby.client.am.Agent
1: 
0:    Copyright (c) 2001, 2005 The Apache Software Foundation or its licensors, where applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1: */
1: 
1: package org.apache.derby.client.am;
1: 
0: public abstract class Agent
0: {
0:   public SqlException accumulatedReadExceptions_ = null;
1: 
0:   private boolean enableBatchedExceptionTracking_;
0:   private int batchedExceptionLabelIndex_;
0:   private boolean[] batchedExceptionGenerated_;
1: 
0:   Connection connection_; // made friendly for lobs only, refactor !!
0:   public SectionManager sectionManager_ = null; // temporarily public, make friendly at least !!
1: 
0:   public LogWriter logWriter_ = null;
1: 
0:   final CrossConverters crossConverters_;
1: 
0:   // Exceptions that occur on dnc's implementation of SqlException.getMessage() via stored proc
0:   // cannot be thrown on the getMessage() invocation because the signature of getMessage() does not
0:   // allow for throwing an exception.
0:   // Therefore, we must save the exception and throw it at our very first opportunity.
0:   SqlException deferredException_;
0:   void checkForDeferredExceptions() throws SqlException
0:   {
0:     if (deferredException_ != null) {
0:       SqlException temp = deferredException_;
0:       deferredException_ = null;
0:       throw temp;
1:     }
1:   }
0:   public void accumulateDeferredException (SqlException e)
0:   {
0:     if (deferredException_ == null)
0:       deferredException_ = e;
0:     else
0:       deferredException_.setNextException (e);
1:   }
1: 
0:   protected Agent (Connection connection, LogWriter logWriter)
0:   {
0:     connection_ = connection;
0:     logWriter_ = logWriter;
0:     crossConverters_ = new CrossConverters (this);
1:   }
1: 
0:   protected void resetAgent ( LogWriter logWriter)
0:   {
0:     // sectionManager_ is set elsewhere
0:     accumulatedReadExceptions_ = null;
0:     enableBatchedExceptionTracking_ = false;
0:     batchedExceptionLabelIndex_ = 0;
0:     batchedExceptionGenerated_ = null;
0:     logWriter_ = logWriter;
0:     deferredException_ = null;
1:   }
1: 
0:   public void resetAgent (Connection connection, LogWriter logWriter, int loginTimeout, String server,int port) throws SqlException
0:   {
0:   	resetAgent (logWriter);
0:   	resetAgent_ (logWriter, loginTimeout, server, port);
1:   }
1: 
0:   abstract protected void resetAgent_(LogWriter logWriter, int loginTimeout, String server,int port) throws SqlException;
1: 
0:   //-------------------- entry points ------------------------------------------
1: 
0:   public final boolean loggingEnabled () { return !org.apache.derby.client.am.Configuration.traceSuspended__ && logWriter_ != null; }
1: 
0:   public final void setLogWriter (LogWriter logWriter)
0:   {
0:     synchronized (connection_) {
0:       if (logWriter_ != null) logWriter_.close();
0:       logWriter_ = logWriter;
1:     }
1:   }
1: 
0:   public final java.io.PrintWriter getLogWriter ()
0:   { return (logWriter_ == null) ? null : logWriter_.printWriter_; }
1: 
0:   abstract public LogWriter newLogWriter_ (java.io.PrintWriter printWriter, int traceLevel);
1: 
0:   //----------------------------------------------------------------------------
1: 
1: 
0:   public final void accumulateReadException (SqlException e)
0:   {
0:     if (enableBatchedExceptionTracking_) {
0:       batchedExceptionGenerated_ [batchedExceptionLabelIndex_] = true;
0:       labelAsBatchedException (e, batchedExceptionLabelIndex_);
1:     }
0:     if (accumulatedReadExceptions_ == null)
0:       accumulatedReadExceptions_ = e;
0:     else
0:       accumulatedReadExceptions_.setNextException (e);
1:   }
1: 
0:   // Called only for disconnect event
0:   public final void accumulateDisconnectException (DisconnectException e)
0:   {
0:     if (enableBatchedExceptionTracking_) {
0:       batchedExceptionGenerated_ [batchedExceptionLabelIndex_] = true;
0:       labelAsBatchedException (e, batchedExceptionLabelIndex_);
1:     }
0:     if (accumulatedReadExceptions_ != null)
0:       e.setNextException (accumulatedReadExceptions_);
1: 
0:     accumulatedReadExceptions_ = null;
1:   }
1: 
0:   // For now, it looks like the only time we accumulate chain breaking exceptions
0:   // is for disconnect exceptions.
0:   public final void accumulateChainBreakingReadExceptionAndThrow (DisconnectException e) throws DisconnectException
0:   {
0:     accumulateDisconnectException (e); // tacks disconnect exc to end of chain
0:     markChainBreakingException_(); // sets a severity code in the NET agent
0:     throw e; // disconnect will be caught in Reply classes, and front of original chain thrown
1:   }
1: 
0:   abstract protected void markChainBreakingException_ (); 
0:   abstract public void checkForChainBreakingException_ () throws SqlException;
1: 
0:   private final void enableBatchedExceptionTracking (int batchSize)
0:   {
0:     enableBatchedExceptionTracking_ = true;
0:     batchedExceptionGenerated_ = new boolean[batchSize];
0:     batchedExceptionLabelIndex_ = 0;
1:   }
1: 
0:   final void disableBatchedExceptionTracking()
0:   {
0:     enableBatchedExceptionTracking_ = false;
1:   }
1: 
0:   public final void setBatchedExceptionLabelIndex (int index)
0:   {
0:     batchedExceptionLabelIndex_ = index;
1:   }
1: 
0:   private final SqlException labelAsBatchedException (SqlException e, int index)
0:   {
0:     SqlException firstInChain = e;
0:     while (e != null) {
0:       e.setBatchPositionLabel (index);
0:       e = (SqlException) e.getNextException();
1:     }
0:     return firstInChain;
1:   }
1: 
0:   protected final void checkForExceptions () throws SqlException
0:   {
0:     if (accumulatedReadExceptions_ != null) {
0:       SqlException e = accumulatedReadExceptions_;
0:       accumulatedReadExceptions_ = null;
0:       throw e;
1:     }
1:   }
1: 
0:   // precondition: all batch execute reads have occurred
0:   final boolean batchUpdateExceptionGenerated ()
0:   {
0:     return batchedExceptionGenerated_ [batchedExceptionLabelIndex_];
1:   }
1: 
0:   public final void flow (Statement statement) throws SqlException
0:   {
0:     endWriteChain();
0:     flush_();
0:     beginReadChain (statement);
1:   }
1: 
0:   public final void flowBatch (Statement statement, int batchSize) throws SqlException
0:   {
0:     endBatchedWriteChain();
0:     flush_();
0:     beginBatchedReadChain (statement, batchSize);
1:   }
1: 
0:   public final void flowOutsideUOW () throws SqlException
0:   {
0:     endWriteChain();
0:     flush_();
0:     beginReadChainOutsideUOW ();
1:   }
1: 
0:   // flush() means to send all chained requests.
0:   abstract public void flush_() throws DisconnectException;
1: 
0:   // Close client resources associated with this agent, such as socket and streams for the net.
0:   abstract public void close_ () throws SqlException;
1: 
0:   public void close () throws SqlException
0:   {
0:     close_();
0:     if (logWriter_ != null) logWriter_.close();
1:   }
1: 
0:   public final void disconnectEvent ()
0:   {
0:     // closes client-side resources associated with database connection
0:     try { close(); } catch (SqlException doNothing) {}
0:     connection_.completeChainBreakingDisconnect ();
1:   }
1: 
0:   public void beginWriteChainOutsideUOW () throws SqlException
0:   {
1:   }
1: 
0:   public void beginWriteChain (Statement statement) throws SqlException
0:   {
0:     connection_.writeTransactionStart(statement);
1:   }
1: 
0:   public final void beginBatchedWriteChain (Statement statement) throws SqlException
0:   {
0:     beginWriteChain (statement);
1:   }
1: 
0:   protected void endWriteChain ()
0:   {
1:   }
1: 
0:   protected final void endBatchedWriteChain ()
0:   {
1:   }
1: 
0:   protected void beginReadChain (Statement statement) throws SqlException
0:   {
0:     connection_.readTransactionStart();
1:   }
1: 
0:   protected final void beginBatchedReadChain (Statement statement, int batchSize) throws SqlException
0:   {
0:     enableBatchedExceptionTracking (batchSize);
0:     beginReadChain (statement);
1:   }
1: 
0:   protected void beginReadChainOutsideUOW () throws SqlException
0:   {
1:   }
1: 
0:   public void endReadChain () throws SqlException
0:   {
0:     checkForExceptions();
1:   }
1: 
0:   public final void endBatchedReadChain (int[] updateCounts, SqlException accumulatedExceptions) throws BatchUpdateException
0:   {
0:     disableBatchedExceptionTracking();
0:     for (int i=0; i < batchedExceptionGenerated_.length; i++) {
0:       if (batchedExceptionGenerated_[i])
0:         updateCounts[i] = -3;
1:     }
0:     if (accumulatedExceptions == null) {
0:       try {
0:         endReadChain();
1:       }
0:       catch (SqlException e) {
0:         accumulatedExceptions = e;
1:       }
1:     }
0:     if (accumulatedExceptions != null) {
0:       BatchUpdateException bue =
0:           new BatchUpdateException (logWriter_,
0:           "Non-atomic batch failure.  The batch was submitted, but " +
0:           "at least one exception occurred on an individual member of the batch. " +
0:           "Use getNextException() to retrieve the exceptions for specific batched elements.",
0:           updateCounts);
0:       bue.setNextException (accumulatedExceptions);
0:       throw bue;
1:     }
1:   }
1: }
1: 
1: 
============================================================================