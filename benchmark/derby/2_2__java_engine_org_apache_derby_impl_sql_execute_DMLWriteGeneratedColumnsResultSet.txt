1:a826375: /*
3:a826375: 
1:a826375:    Derby - Class org.apache.derby.impl.sql.execute.DMLWriteGeneratedColumnsResultSet
1:a826375: 
1:a826375:    Licensed to the Apache Software Foundation (ASF) under one or more
1:a826375:    contributor license agreements.  See the NOTICE file distributed with
1:a826375:    this work for additional information regarding copyright ownership.
1:a826375:    The ASF licenses this file to you under the Apache License, Version 2.0
1:a826375:    (the "License"); you may not use this file except in compliance with
1:a826375:    the License.  You may obtain a copy of the License at
1:a826375: 
1:a826375:       http://www.apache.org/licenses/LICENSE-2.0
1:a826375: 
1:a826375:    Unless required by applicable law or agreed to in writing, software
1:a826375:    distributed under the License is distributed on an "AS IS" BASIS,
1:a826375:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:a826375:    See the License for the specific language governing permissions and
1:a826375:    limitations under the License.
1:a826375: 
1:a826375:  */
1:a826375: 
1:a826375: package org.apache.derby.impl.sql.execute;
1:a826375: 
1:aa302c3: import java.util.Arrays;
1:a826375: import java.util.HashMap;
1:aa302c3: import java.util.Properties;
1:a826375: import org.apache.derby.iapi.error.StandardException;
1:aa302c3: import org.apache.derby.iapi.reference.SQLState;
1:a826375: import org.apache.derby.iapi.sql.Activation;
1:aa302c3: import org.apache.derby.iapi.sql.ResultDescription;
1:aa302c3: import org.apache.derby.iapi.sql.ResultSet;
1:aa302c3: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
1:aa302c3: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1:a826375: import org.apache.derby.iapi.sql.execute.ConstantAction;
1:aa302c3: import org.apache.derby.iapi.sql.execute.ExecRow;
1:a826375: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
1:a826375: import org.apache.derby.iapi.types.DataValueDescriptor;
1:a826375: import org.apache.derby.iapi.types.NumberDataValue;
1:a826375: import org.apache.derby.shared.common.sanity.SanityManager;
1:aa302c3: import org.apache.derby.catalog.UUID;
1:aa302c3: import org.apache.derby.iapi.sql.execute.RowChanger;
1:a826375: 
1:a826375: /*
1:a826375:  * This class includes code for auto generated columns that can be shared
1:a826375:  *  by insert and update statements in the execution phase.
1:a826375:  */
1:a826375: abstract public class DMLWriteGeneratedColumnsResultSet extends DMLWriteResultSet
1:a826375: {    
1:a826375: 	/**
1:a826375: 	 * keeps track of autoincrement values that are generated by 
1:a826375: 	 * getSetAutoincrementValues.
1:a826375: 	 */
1:a826375: 	protected DataValueDescriptor				aiCache[];
1:a826375: 	
1:a826375: 	protected String              identitySequenceUUIDString;
1:a826375: 
1:a826375: 	protected	NoPutResultSet			sourceResultSet;
1:a826375: 
1:aa302c3: 	//following is for jdbc3.0 feature auto generated keys resultset
1:aa302c3: 	protected  ResultSet			autoGeneratedKeysResultSet;
1:aa302c3: 	protected  TemporaryRowHolderImpl	autoGeneratedKeysRowsHolder;
1:aa302c3: 	protected  int[]                   autoGeneratedKeysColumnIndexes;
1:aa302c3: 	/**
1:aa302c3: 	 * If set to true, implies that Derby has generated autoincrement 
1:aa302c3: 	 * values for this (rep)resultset. During refresh for example, the 
1:aa302c3: 	 * autoincrement values are not generated but sent from the source 
1:aa302c3: 	 * to target or vice-versa.
1:aa302c3: 	 */
1:aa302c3: 	protected boolean autoincrementGenerated;
1:aa302c3: 	protected long	  identityVal;  //support of IDENTITY_LOCAL_VAL function
1:aa302c3: 	protected boolean setIdentity;
1:aa302c3: 
1:a826375: 	/**
1:a826375: 	 * Constructor
1:a826375: 	 *
1:a826375:  	 * @param activation		an activation
1:a826375: 	 *
1:a826375:  	 * @exception StandardException on error
1:a826375: 	 */
1:a826375: 	DMLWriteGeneratedColumnsResultSet(Activation activation)
1:a826375: 		throws StandardException
1:a826375: 	{
1:a826375: 		this(activation, activation.getConstantAction());
1:a826375: 	}
1:a826375: 
1:a826375: 	DMLWriteGeneratedColumnsResultSet(Activation activation, ConstantAction constantAction)
1:a826375: 		throws StandardException
1:a826375: 	{
1:a826375: 		super(activation, constantAction);
1:a826375: 	}
1:a826375: 	
1:a826375:     /**
1:a826375:      * getSetAutoincrementValue will get the autoincrement value of the 
1:a826375:      * columnPosition specified for the target table. If increment is 
1:a826375:      * non-zero we will also update the autoincrement value. 
1:a826375:      *
1:a826375:      * @param columnPosition	position of the column in the table (1-based)
1:a826375:      * @param increment			amount of increment. 
1:a826375:      *
1:a826375:      * @exception StandardException if anything goes wrong.
1:a826375:      */
1:a826375:     public NumberDataValue
1:a826375:     	getSetAutoincrementValue(int columnPosition, long increment)
1:a826375:     	throws StandardException {
1:a826375:         if (SanityManager.DEBUG) {
1:a826375:             // This method should be overriden by InsertResultSet and
1:a826375:             // UpdateResultSet, other shouldn't need it.
1:a826375:             SanityManager.NOTREACHED();
1:a826375:         }
1:a826375: 		return null; 
1:a826375:     }
1:a826375:     
1:a826375:     public void saveAIcacheInformation(String schemaName,
1:a826375:     		String tableName, String[] columnNames) 
1:a826375:     throws StandardException{
1:a826375:         if (aiCache != null)
1:a826375:         {
1:a826375:             HashMap<String,Long> aiHashtable = new HashMap<String,Long>();
1:a826375:             int numColumns = aiCache.length;
1:a826375:             // this insert updated ai values, store them in some persistent
1:a826375:             // place so that I can see these values.
1:a826375:             for (int i = 0; i < numColumns; i++)
1:a826375:             {
1:a826375:                 if (aiCache[i] == null)
1:a826375:                     continue;
1:a826375:                 aiHashtable.put(AutoincrementCounter.makeIdentity(
1:a826375:                         schemaName,
1:a826375:                         tableName,
1:a826375:                         columnNames[i]),
1:ce40a31:                         aiCache[i].getLong());
1:a826375:             }
1:a826375:             InternalTriggerExecutionContext itec =
1:a826375:                 (InternalTriggerExecutionContext)lcc.getTriggerExecutionContext();
1:a826375:             if (itec == null)
1:a826375:                 lcc.copyHashtableToAIHT(aiHashtable);
1:a826375:             else
1:a826375:                 itec.copyHashtableToAIHT(aiHashtable);
1:a826375:         }	
1:aa302c3: 
1:aa302c3:         /* autoGeneratedResultset for JDBC3. Nulled after statement execution 
1:aa302c3:         is over (ie after it is saved off in LocalSatement object) */
1:aa302c3:         if (activation.getAutoGeneratedKeysResultsetMode())
1:aa302c3:             autoGeneratedKeysResultSet = autoGeneratedKeysRowsHolder.getResultSet();
1:aa302c3:         else
1:aa302c3:             autoGeneratedKeysResultSet = null;
1:aa302c3:     }
1:aa302c3:     
1:aa302c3:     /*
1:aa302c3:     ** verify the auto-generated key columns list(ie there are no invalid
1:aa302c3:     ** column names or positions). This is done at execution time because
1:aa302c3:     ** for a precompiled insert statement, user can specify different column
1:aa302c3:     ** selections for auto-generated keys.
1:aa302c3:     */
1:aa302c3:     protected void verifyAutoGeneratedRScolumnsList(UUID targetUUID)
1:aa302c3:             throws StandardException{
1:aa302c3:         if(activation.getAutoGeneratedKeysResultsetMode())
1:aa302c3:         {
1:aa302c3:             int[]   agi = activation.getAutoGeneratedKeysColumnIndexes();
1:aa302c3:             if ( agi != null ) { 
1:aa302c3:                 verifyAutoGeneratedColumnsIndexes( agi, targetUUID ); 
1:aa302c3:             } else
1:aa302c3:             {
1:aa302c3:                 String[]    agc = activation.getAutoGeneratedKeysColumnNames();
1:aa302c3:                 if ( agc != null ) { 
1:aa302c3:                     verifyAutoGeneratedColumnsNames( agc, targetUUID ); 
1:aa302c3:                 }
1:aa302c3:             }
1:aa302c3:         }
1:aa302c3:     }
1:aa302c3: 
1:aa302c3:     /**
1:aa302c3:      * Verify that the auto-generated columns list (by position) has valid
1:aa302c3:      * column positions for the table.
1:aa302c3:      */
1:aa302c3:     private void verifyAutoGeneratedColumnsIndexes(
1:aa302c3:             int[] columnIndexes, UUID targetUUID)
1:aa302c3:         throws StandardException
1:aa302c3:     {
1:aa302c3:         int size = columnIndexes.length;
1:aa302c3:         TableDescriptor tabDesc = 
1:aa302c3:                 lcc.getDataDictionary().getTableDescriptor(targetUUID);
1:aa302c3: 
1:aa302c3:         // all 1-based column ids.
1:aa302c3:         for (int i = 0; i < size; i++)
1:aa302c3:         {
1:aa302c3:             ColumnDescriptor cd = tabDesc.getColumnDescriptor(columnIndexes[i]);
1:aa302c3:             if (!verifyAutoGenColumn(cd))
1:aa302c3:             {
1:aa302c3:                 throw StandardException.newException(
1:aa302c3:                     SQLState.LANG_INVALID_AUTOGEN_COLUMN_POSITION,
1:ce40a31:                     columnIndexes[i], tabDesc.getName());
1:aa302c3:             }
1:aa302c3:        }
1:aa302c3:     }
1:aa302c3: 
1:aa302c3:     /**
1:aa302c3:      * Verify that the auto-generated columns list (by name) has valid
1:aa302c3:      * column names for the table. If all the column names are valid,
1:aa302c3:      * convert column names array to corresponding column positions array
1:aa302c3:      * Save that column positions array in activation. We do this to 
1:aa302c3:      * simplify the rest of the logic(it only has to deal with column 
1:aa302c3:      * positions here after).
1:aa302c3:      *
1:aa302c3:      * @exception StandardException		Thrown on error if invalid column
1:aa302c3:      * name in the list.
1:aa302c3:      */
1:aa302c3:      private void verifyAutoGeneratedColumnsNames(String[] columnNames, UUID targetUUID)
1:aa302c3: 		throws StandardException
1:aa302c3:      {
1:aa302c3:         int size = columnNames.length;
1:aa302c3:         int columnPositions[] = new int[size];
1:aa302c3:         
1:aa302c3:         TableDescriptor tabDesc = 
1:aa302c3:             lcc.getDataDictionary().getTableDescriptor(targetUUID);
1:aa302c3:         ColumnDescriptor cd;
1:aa302c3: 
1:aa302c3:         for (int i = 0; i < size; i++)
1:aa302c3:         {
1:aa302c3:             if (columnNames[i] == null)
1:aa302c3:             {
1:aa302c3:                 throw StandardException.newException(
1:aa302c3:                     SQLState.LANG_INVALID_AUTOGEN_COLUMN_NAME,
1:aa302c3:                     columnNames[i], tabDesc.getName());
1:aa302c3:             }
1:aa302c3: 
1:aa302c3:             cd = tabDesc.getColumnDescriptor(columnNames[i]);
1:aa302c3:             if (!verifyAutoGenColumn(cd))
1:aa302c3:             {
1:aa302c3:                 throw StandardException.newException(
1:aa302c3:                     SQLState.LANG_INVALID_AUTOGEN_COLUMN_NAME,
1:aa302c3:                     columnNames[i], tabDesc.getName());
1:aa302c3:             }
1:aa302c3: 
1:aa302c3:             columnPositions[i] = cd.getPosition();
1:aa302c3:         }
1:aa302c3:         activation.setAutoGeneratedKeysResultsetInfo(columnPositions, null);
1:aa302c3: 	}
1:aa302c3: 
1:aa302c3: 	/**
1:aa302c3: 	 * Check that the received ColumnDescriptor corresponds to a column
1:aa302c3: 	 * for which it is possible to fetch auto-generated keys.
1:aa302c3: 	 */
1:aa302c3: 	private boolean verifyAutoGenColumn(ColumnDescriptor cd)
1:aa302c3: 	{
1:aa302c3: 		/* Derby currently gets generated keys by calling the
1:aa302c3: 		 * IDENTITY_VAL_LOCAL() function (see "getGeneratedKeys()"
1:aa302c3: 		 * as defined on EmbedStatement).  That function only
1:aa302c3: 		 * considers autoincrement columns.  So if the column
1:aa302c3: 		 * specified by the user is not autoincrement, we return
1:aa302c3: 		 * false.
1:aa302c3: 		 */
1:aa302c3: 		return ((cd != null) && cd.isAutoincrement());
1:aa302c3: 	}
1:aa302c3: 	
1:aa302c3:     protected void firstExecuteSpecialHandlingAutoGen(boolean firstExecute,
1:aa302c3:         RowChanger rowChanger, UUID targetUUID) 
1:aa302c3:             throws StandardException {
1:aa302c3:     if (firstExecute && activation.getAutoGeneratedKeysResultsetMode()) {
1:aa302c3:         ResultDescription rd;
1:aa302c3:         Properties properties = new Properties();
1:aa302c3:         autoGeneratedKeysColumnIndexes =
1:aa302c3:           	activation.getAutoGeneratedKeysColumnIndexes();
1:aa302c3: 
1:aa302c3:         // Get the properties on the old heap
1:aa302c3:         rowChanger.getHeapConglomerateController().getInternalTablePropertySet(properties);
1:aa302c3: 
1:aa302c3:         if (autoGeneratedKeysColumnIndexes != null) {
1:aa302c3:             // Use user-provided column positions array.
1:aa302c3:             autoGeneratedKeysColumnIndexes =
1:aa302c3:               	uniqueColumnPositionArray(autoGeneratedKeysColumnIndexes, targetUUID);
1:aa302c3:         } else {
1:aa302c3:             // Prepare array of auto-generated keys for the table since
1:aa302c3:             // user didn't provide any.
1:aa302c3:             autoGeneratedKeysColumnIndexes =
1:aa302c3:                 generatedColumnPositionsArray(targetUUID);
1:aa302c3:         }
1:aa302c3: 
1:aa302c3:         rd = lcc.getLanguageFactory().getResultDescription(
1:aa302c3:             resultDescription, autoGeneratedKeysColumnIndexes);
1:aa302c3:         autoGeneratedKeysRowsHolder =
1:aa302c3:             new TemporaryRowHolderImpl(activation, properties, rd);
1:aa302c3:         }
1:aa302c3:     }
1:aa302c3: 
1:aa302c3:     /**
1:aa302c3:      * If user didn't provide columns list for auto-generated columns, then only include
1:aa302c3:      * columns with auto-generated values in the resultset. Those columns would be ones
1:aa302c3:      * with default value defined.
1:aa302c3:      */
1:aa302c3:     private int[] generatedColumnPositionsArray(UUID targetUUID)
1:aa302c3:         throws StandardException
1:aa302c3:     {
1:aa302c3:         TableDescriptor tabDesb = lcc.getDataDictionary().getTableDescriptor(targetUUID);
1:aa302c3: 	    ColumnDescriptor cd;
1:aa302c3:         int size = tabDesb.getMaxColumnID();
1:aa302c3: 
1:aa302c3:         int[] generatedColumnPositionsArray = new int[size];
1:aa302c3:         Arrays.fill(generatedColumnPositionsArray, -1);
1:aa302c3:         int generatedColumnNumbers = 0;
1:aa302c3: 
1:aa302c3:         for (int i=0; i<size; i++) {
1:aa302c3:             cd = tabDesb.getColumnDescriptor(i+1);
1:aa302c3:             if (cd.isAutoincrement()) { //if the column has auto-increment value
1:aa302c3:                 generatedColumnNumbers++;
1:aa302c3:                 generatedColumnPositionsArray[i] = i+1;
1:aa302c3:             } else if (cd.getDefaultValue() != null || cd.getDefaultInfo() != null) {//default value
1:aa302c3:                 generatedColumnNumbers++;
1:aa302c3:                 generatedColumnPositionsArray[i] = i+1;
1:aa302c3:             }
1:aa302c3:         }
1:aa302c3:         int[] returnGeneratedColumnPositionsArray = new int[generatedColumnNumbers];
1:aa302c3: 
1:aa302c3:         for (int i=0, j=0; i<size; i++) {
1:aa302c3:             if (generatedColumnPositionsArray[i] != -1)
1:aa302c3:                 returnGeneratedColumnPositionsArray[j++] = generatedColumnPositionsArray[i];
1:aa302c3:         }
1:aa302c3: 
1:aa302c3:         return returnGeneratedColumnPositionsArray;
1:aa302c3:         }
1:aa302c3: 
1:aa302c3:     /**
1:aa302c3:      * Remove duplicate columns from the array. Then use this array to generate a sub-set
1:aa302c3:      * of insert resultset to be returned for JDBC3.0 getGeneratedKeys() call.
1:aa302c3:      */
1:aa302c3:     private int[] uniqueColumnPositionArray(int[] columnIndexes, UUID targetUUID)
1:aa302c3:         throws StandardException
1:aa302c3:     {
1:aa302c3:         int size = columnIndexes.length;
1:aa302c3:         TableDescriptor tabDesc = lcc.getDataDictionary().getTableDescriptor(targetUUID);
1:aa302c3: 
1:aa302c3:         //create an array of integer (the array size = number of columns in table)
1:aa302c3:         // valid column positions are 1...getMaxColumnID()
1:aa302c3:         int[] uniqueColumnIndexes = new int[tabDesc.getMaxColumnID()];
1:aa302c3: 
1:aa302c3:         int uniqueColumnNumbers = 0;
1:aa302c3: 
1:aa302c3:         //At the end of following loop, the uniqueColumnIndexes elements will not be 0 for user
1:aa302c3:         //selected auto-generated columns.
1:aa302c3:         for (int i=0; i<size; i++) {
1:aa302c3:             if (uniqueColumnIndexes[columnIndexes[i] - 1] == 0) {
1:aa302c3:                 uniqueColumnNumbers++;
1:aa302c3:                 uniqueColumnIndexes[columnIndexes[i] - 1] = columnIndexes[i];
1:aa302c3:             }
1:aa302c3:         }
1:aa302c3:         int[] returnUniqueColumnIndexes = new int[uniqueColumnNumbers];
1:aa302c3: 
1:aa302c3:         //return just the column positions which are not marked 0 in the uniqueColumnIndexes array
1:aa302c3:         for (int i=0, j=0; i<uniqueColumnIndexes.length; i++) {
1:aa302c3:             if (uniqueColumnIndexes[i] != 0)
1:aa302c3:                 returnUniqueColumnIndexes[j++] = uniqueColumnIndexes[i];
1:aa302c3:         }
1:aa302c3: 
1:aa302c3:         return returnUniqueColumnIndexes;
1:aa302c3:     }
1:aa302c3: 
1:aa302c3:     /**
1:aa302c3:      * Take the input row and return a new compact ExecRow
1:aa302c3:      * using the column positions provided in columnIndexes.
1:aa302c3:      * Copies references, no cloning.
1:aa302c3:      */
1:aa302c3:     protected ExecRow getCompactRow
1:aa302c3:     (
1:aa302c3:     	ExecRow 					inputRow, 
1:aa302c3:         int[] 						columnIndexes
1:aa302c3:     )
1:aa302c3:     throws StandardException
1:aa302c3:     {
1:aa302c3:         ExecRow outRow;
1:aa302c3:         int numInputCols = inputRow.nColumns();
1:aa302c3: 
1:aa302c3:         if (columnIndexes == null)
1:aa302c3:         {
1:aa302c3:             outRow = new ValueRow(numInputCols);
1:aa302c3:             Object[] src = inputRow.getRowArray();
1:aa302c3:             Object[] dst = outRow.getRowArray();
1:aa302c3:             System.arraycopy(src, 0, dst, 0, src.length);
1:aa302c3:             return outRow;
1:aa302c3:         }
1:aa302c3: 
1:aa302c3:         int numOutputCols = columnIndexes.length;
1:aa302c3: 
1:aa302c3:         outRow = new ValueRow(numOutputCols);
1:aa302c3:         for (int i = 0; i < numOutputCols; i++)
1:aa302c3:         {
1:aa302c3:             outRow.setColumn(i+1,
1:aa302c3:             	inputRow.getColumn(columnIndexes[i]));
1:aa302c3:         }
1:aa302c3: 
1:aa302c3:         return outRow;
1:aa302c3:     }
1:aa302c3: 
1:aa302c3:     @Override
1:aa302c3:     public ResultSet getAutoGeneratedKeysResultset()
1:aa302c3:     {
1:aa302c3:         return autoGeneratedKeysResultSet;
1:a826375:     }
1:a826375: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:ce40a31
/////////////////////////////////////////////////////////////////////////
1:                         aiCache[i].getLong());
/////////////////////////////////////////////////////////////////////////
1:                     columnIndexes[i], tabDesc.getName());
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:aa302c3
/////////////////////////////////////////////////////////////////////////
1: import java.util.Arrays;
1: import java.util.Properties;
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.sql.ResultDescription;
1: import org.apache.derby.iapi.sql.ResultSet;
1: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1: import org.apache.derby.iapi.sql.execute.ExecRow;
1: import org.apache.derby.catalog.UUID;
1: import org.apache.derby.iapi.sql.execute.RowChanger;
/////////////////////////////////////////////////////////////////////////
1: 	//following is for jdbc3.0 feature auto generated keys resultset
1: 	protected  ResultSet			autoGeneratedKeysResultSet;
1: 	protected  TemporaryRowHolderImpl	autoGeneratedKeysRowsHolder;
1: 	protected  int[]                   autoGeneratedKeysColumnIndexes;
1: 	/**
1: 	 * If set to true, implies that Derby has generated autoincrement 
1: 	 * values for this (rep)resultset. During refresh for example, the 
1: 	 * autoincrement values are not generated but sent from the source 
1: 	 * to target or vice-versa.
1: 	 */
1: 	protected boolean autoincrementGenerated;
1: 	protected long	  identityVal;  //support of IDENTITY_LOCAL_VAL function
1: 	protected boolean setIdentity;
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:         /* autoGeneratedResultset for JDBC3. Nulled after statement execution 
1:         is over (ie after it is saved off in LocalSatement object) */
1:         if (activation.getAutoGeneratedKeysResultsetMode())
1:             autoGeneratedKeysResultSet = autoGeneratedKeysRowsHolder.getResultSet();
1:         else
1:             autoGeneratedKeysResultSet = null;
1:     }
1:     
1:     /*
1:     ** verify the auto-generated key columns list(ie there are no invalid
1:     ** column names or positions). This is done at execution time because
1:     ** for a precompiled insert statement, user can specify different column
1:     ** selections for auto-generated keys.
1:     */
1:     protected void verifyAutoGeneratedRScolumnsList(UUID targetUUID)
1:             throws StandardException{
1:         if(activation.getAutoGeneratedKeysResultsetMode())
1:         {
1:             int[]   agi = activation.getAutoGeneratedKeysColumnIndexes();
1:             if ( agi != null ) { 
1:                 verifyAutoGeneratedColumnsIndexes( agi, targetUUID ); 
1:             } else
1:             {
1:                 String[]    agc = activation.getAutoGeneratedKeysColumnNames();
1:                 if ( agc != null ) { 
1:                     verifyAutoGeneratedColumnsNames( agc, targetUUID ); 
1:                 }
1:             }
1:         }
1:     }
1: 
1:     /**
1:      * Verify that the auto-generated columns list (by position) has valid
1:      * column positions for the table.
1:      */
1:     private void verifyAutoGeneratedColumnsIndexes(
1:             int[] columnIndexes, UUID targetUUID)
1:         throws StandardException
1:     {
1:         int size = columnIndexes.length;
1:         TableDescriptor tabDesc = 
1:                 lcc.getDataDictionary().getTableDescriptor(targetUUID);
1: 
1:         // all 1-based column ids.
1:         for (int i = 0; i < size; i++)
1:         {
1:             ColumnDescriptor cd = tabDesc.getColumnDescriptor(columnIndexes[i]);
1:             if (!verifyAutoGenColumn(cd))
1:             {
1:                 throw StandardException.newException(
1:                     SQLState.LANG_INVALID_AUTOGEN_COLUMN_POSITION,
0:                     new Integer(columnIndexes[i]), tabDesc.getName());
1:             }
1:        }
1:     }
1: 
1:     /**
1:      * Verify that the auto-generated columns list (by name) has valid
1:      * column names for the table. If all the column names are valid,
1:      * convert column names array to corresponding column positions array
1:      * Save that column positions array in activation. We do this to 
1:      * simplify the rest of the logic(it only has to deal with column 
1:      * positions here after).
1:      *
1:      * @exception StandardException		Thrown on error if invalid column
1:      * name in the list.
1:      */
1:      private void verifyAutoGeneratedColumnsNames(String[] columnNames, UUID targetUUID)
1: 		throws StandardException
1:      {
1:         int size = columnNames.length;
1:         int columnPositions[] = new int[size];
1:         
1:         TableDescriptor tabDesc = 
1:             lcc.getDataDictionary().getTableDescriptor(targetUUID);
1:         ColumnDescriptor cd;
1: 
1:         for (int i = 0; i < size; i++)
1:         {
1:             if (columnNames[i] == null)
1:             {
1:                 throw StandardException.newException(
1:                     SQLState.LANG_INVALID_AUTOGEN_COLUMN_NAME,
1:                     columnNames[i], tabDesc.getName());
1:             }
1: 
1:             cd = tabDesc.getColumnDescriptor(columnNames[i]);
1:             if (!verifyAutoGenColumn(cd))
1:             {
1:                 throw StandardException.newException(
1:                     SQLState.LANG_INVALID_AUTOGEN_COLUMN_NAME,
1:                     columnNames[i], tabDesc.getName());
1:             }
1: 
1:             columnPositions[i] = cd.getPosition();
1:         }
1:         activation.setAutoGeneratedKeysResultsetInfo(columnPositions, null);
1: 	}
1: 
1: 	/**
1: 	 * Check that the received ColumnDescriptor corresponds to a column
1: 	 * for which it is possible to fetch auto-generated keys.
1: 	 */
1: 	private boolean verifyAutoGenColumn(ColumnDescriptor cd)
1: 	{
1: 		/* Derby currently gets generated keys by calling the
1: 		 * IDENTITY_VAL_LOCAL() function (see "getGeneratedKeys()"
1: 		 * as defined on EmbedStatement).  That function only
1: 		 * considers autoincrement columns.  So if the column
1: 		 * specified by the user is not autoincrement, we return
1: 		 * false.
1: 		 */
1: 		return ((cd != null) && cd.isAutoincrement());
1: 	}
1: 	
1:     protected void firstExecuteSpecialHandlingAutoGen(boolean firstExecute,
1:         RowChanger rowChanger, UUID targetUUID) 
1:             throws StandardException {
1:     if (firstExecute && activation.getAutoGeneratedKeysResultsetMode()) {
1:         ResultDescription rd;
1:         Properties properties = new Properties();
1:         autoGeneratedKeysColumnIndexes =
1:           	activation.getAutoGeneratedKeysColumnIndexes();
1: 
1:         // Get the properties on the old heap
1:         rowChanger.getHeapConglomerateController().getInternalTablePropertySet(properties);
1: 
1:         if (autoGeneratedKeysColumnIndexes != null) {
1:             // Use user-provided column positions array.
1:             autoGeneratedKeysColumnIndexes =
1:               	uniqueColumnPositionArray(autoGeneratedKeysColumnIndexes, targetUUID);
1:         } else {
1:             // Prepare array of auto-generated keys for the table since
1:             // user didn't provide any.
1:             autoGeneratedKeysColumnIndexes =
1:                 generatedColumnPositionsArray(targetUUID);
1:         }
1: 
1:         rd = lcc.getLanguageFactory().getResultDescription(
1:             resultDescription, autoGeneratedKeysColumnIndexes);
1:         autoGeneratedKeysRowsHolder =
1:             new TemporaryRowHolderImpl(activation, properties, rd);
1:         }
1:     }
1: 
1:     /**
1:      * If user didn't provide columns list for auto-generated columns, then only include
1:      * columns with auto-generated values in the resultset. Those columns would be ones
1:      * with default value defined.
1:      */
1:     private int[] generatedColumnPositionsArray(UUID targetUUID)
1:         throws StandardException
1:     {
1:         TableDescriptor tabDesb = lcc.getDataDictionary().getTableDescriptor(targetUUID);
1: 	    ColumnDescriptor cd;
1:         int size = tabDesb.getMaxColumnID();
1: 
1:         int[] generatedColumnPositionsArray = new int[size];
1:         Arrays.fill(generatedColumnPositionsArray, -1);
1:         int generatedColumnNumbers = 0;
1: 
1:         for (int i=0; i<size; i++) {
1:             cd = tabDesb.getColumnDescriptor(i+1);
1:             if (cd.isAutoincrement()) { //if the column has auto-increment value
1:                 generatedColumnNumbers++;
1:                 generatedColumnPositionsArray[i] = i+1;
1:             } else if (cd.getDefaultValue() != null || cd.getDefaultInfo() != null) {//default value
1:                 generatedColumnNumbers++;
1:                 generatedColumnPositionsArray[i] = i+1;
1:             }
1:         }
1:         int[] returnGeneratedColumnPositionsArray = new int[generatedColumnNumbers];
1: 
1:         for (int i=0, j=0; i<size; i++) {
1:             if (generatedColumnPositionsArray[i] != -1)
1:                 returnGeneratedColumnPositionsArray[j++] = generatedColumnPositionsArray[i];
1:         }
1: 
1:         return returnGeneratedColumnPositionsArray;
1:         }
1: 
1:     /**
1:      * Remove duplicate columns from the array. Then use this array to generate a sub-set
1:      * of insert resultset to be returned for JDBC3.0 getGeneratedKeys() call.
1:      */
1:     private int[] uniqueColumnPositionArray(int[] columnIndexes, UUID targetUUID)
1:         throws StandardException
1:     {
1:         int size = columnIndexes.length;
1:         TableDescriptor tabDesc = lcc.getDataDictionary().getTableDescriptor(targetUUID);
1: 
1:         //create an array of integer (the array size = number of columns in table)
1:         // valid column positions are 1...getMaxColumnID()
1:         int[] uniqueColumnIndexes = new int[tabDesc.getMaxColumnID()];
1: 
1:         int uniqueColumnNumbers = 0;
1: 
1:         //At the end of following loop, the uniqueColumnIndexes elements will not be 0 for user
1:         //selected auto-generated columns.
1:         for (int i=0; i<size; i++) {
1:             if (uniqueColumnIndexes[columnIndexes[i] - 1] == 0) {
1:                 uniqueColumnNumbers++;
1:                 uniqueColumnIndexes[columnIndexes[i] - 1] = columnIndexes[i];
1:             }
1:         }
1:         int[] returnUniqueColumnIndexes = new int[uniqueColumnNumbers];
1: 
1:         //return just the column positions which are not marked 0 in the uniqueColumnIndexes array
1:         for (int i=0, j=0; i<uniqueColumnIndexes.length; i++) {
1:             if (uniqueColumnIndexes[i] != 0)
1:                 returnUniqueColumnIndexes[j++] = uniqueColumnIndexes[i];
1:         }
1: 
1:         return returnUniqueColumnIndexes;
1:     }
1: 
1:     /**
1:      * Take the input row and return a new compact ExecRow
1:      * using the column positions provided in columnIndexes.
1:      * Copies references, no cloning.
1:      */
1:     protected ExecRow getCompactRow
1:     (
1:     	ExecRow 					inputRow, 
1:         int[] 						columnIndexes
1:     )
1:     throws StandardException
1:     {
1:         ExecRow outRow;
1:         int numInputCols = inputRow.nColumns();
1: 
1:         if (columnIndexes == null)
1:         {
1:             outRow = new ValueRow(numInputCols);
1:             Object[] src = inputRow.getRowArray();
1:             Object[] dst = outRow.getRowArray();
1:             System.arraycopy(src, 0, dst, 0, src.length);
1:             return outRow;
1:         }
1: 
1:         int numOutputCols = columnIndexes.length;
1: 
1:         outRow = new ValueRow(numOutputCols);
1:         for (int i = 0; i < numOutputCols; i++)
1:         {
1:             outRow.setColumn(i+1,
1:             	inputRow.getColumn(columnIndexes[i]));
1:         }
1: 
1:         return outRow;
1:     }
1: 
1:     @Override
1:     public ResultSet getAutoGeneratedKeysResultset()
1:     {
1:         return autoGeneratedKeysResultSet;
commit:a826375
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derby.impl.sql.execute.DMLWriteGeneratedColumnsResultSet
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derby.impl.sql.execute;
1: 
1: import java.util.HashMap;
1: 
1: 
0: import org.apache.derby.catalog.UUID;
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.sql.Activation;
0: import org.apache.derby.iapi.sql.ResultColumnDescriptor;
1: import org.apache.derby.iapi.sql.execute.ConstantAction;
1: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
1: import org.apache.derby.iapi.types.DataValueDescriptor;
1: import org.apache.derby.iapi.types.NumberDataValue;
0: import org.apache.derby.iapi.types.RowLocation;
1: import org.apache.derby.shared.common.sanity.SanityManager;
1: 
1: /*
1:  * This class includes code for auto generated columns that can be shared
1:  *  by insert and update statements in the execution phase.
1:  */
1: abstract public class DMLWriteGeneratedColumnsResultSet extends DMLWriteResultSet
1: {    
1: 	/**
1: 	 * keeps track of autoincrement values that are generated by 
1: 	 * getSetAutoincrementValues.
1: 	 */
1: 	protected DataValueDescriptor				aiCache[];
1: 	
1: 	protected String              identitySequenceUUIDString;
1: 
1: 	protected	NoPutResultSet			sourceResultSet;
1: 
1: 	/**
1: 	 * Constructor
1: 	 *
1:  	 * @param activation		an activation
1: 	 *
1:  	 * @exception StandardException on error
1: 	 */
1: 	DMLWriteGeneratedColumnsResultSet(Activation activation)
1: 		throws StandardException
1: 	{
1: 		this(activation, activation.getConstantAction());
1: 	}
1: 
1: 	DMLWriteGeneratedColumnsResultSet(Activation activation, ConstantAction constantAction)
1: 		throws StandardException
1: 	{
1: 		super(activation, constantAction);
1: 	}
1: 	
1:     /**
1:      * getSetAutoincrementValue will get the autoincrement value of the 
1:      * columnPosition specified for the target table. If increment is 
1:      * non-zero we will also update the autoincrement value. 
1:      *
1:      * @param columnPosition	position of the column in the table (1-based)
1:      * @param increment			amount of increment. 
1:      *
1:      * @exception StandardException if anything goes wrong.
1:      */
1:     public NumberDataValue
1:     	getSetAutoincrementValue(int columnPosition, long increment)
1:     	throws StandardException {
1:         if (SanityManager.DEBUG) {
1:             // This method should be overriden by InsertResultSet and
1:             // UpdateResultSet, other shouldn't need it.
1:             SanityManager.NOTREACHED();
1:         }
1: 		return null; 
1:     }
1:     
1:     public void saveAIcacheInformation(String schemaName,
1:     		String tableName, String[] columnNames) 
1:     throws StandardException{
1:         if (aiCache != null)
1:         {
1:             HashMap<String,Long> aiHashtable = new HashMap<String,Long>();
1:             int numColumns = aiCache.length;
1:             // this insert updated ai values, store them in some persistent
1:             // place so that I can see these values.
1:             for (int i = 0; i < numColumns; i++)
1:             {
1:                 if (aiCache[i] == null)
1:                     continue;
1:                 aiHashtable.put(AutoincrementCounter.makeIdentity(
1:                         schemaName,
1:                         tableName,
1:                         columnNames[i]),
0:                         new Long(aiCache[i].getLong()));
1:             }
1:             InternalTriggerExecutionContext itec =
1:                 (InternalTriggerExecutionContext)lcc.getTriggerExecutionContext();
1:             if (itec == null)
1:                 lcc.copyHashtableToAIHT(aiHashtable);
1:             else
1:                 itec.copyHashtableToAIHT(aiHashtable);
1:         }	
1:     }
1: }
============================================================================