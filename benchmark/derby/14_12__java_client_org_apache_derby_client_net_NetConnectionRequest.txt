1:33776ff: /*
108:33776ff: 
1:33776ff:    Derby - Class org.apache.derby.client.net.NetConnectionRequest
1:33776ff: 
1:59bf37d:    Licensed to the Apache Software Foundation (ASF) under one or more
1:59bf37d:    contributor license agreements.  See the NOTICE file distributed with
1:59bf37d:    this work for additional information regarding copyright ownership.
1:59bf37d:    The ASF licenses this file to You under the Apache License, Version 2.0
1:59bf37d:    (the "License"); you may not use this file except in compliance with
1:59bf37d:    the License.  You may obtain a copy of the License at
1:33776ff: 
1:33776ff:       http://www.apache.org/licenses/LICENSE-2.0
1:33776ff: 
1:33776ff:    Unless required by applicable law or agreed to in writing, software
1:33776ff:    distributed under the License is distributed on an "AS IS" BASIS,
1:33776ff:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:33776ff:    See the License for the specific language governing permissions and
1:33776ff:    limitations under the License.
1:33776ff: 
1:33776ff: */
1:33776ff: 
1:33776ff: package org.apache.derby.client.net;
1:33776ff: 
1:33776ff: 
1:33776ff: import javax.transaction.xa.Xid;
1:33776ff: 
1:70f7692: import org.apache.derby.client.am.SqlException;
1:1b39163: import org.apache.derby.client.am.ClientMessageId;
1:1b39163: import org.apache.derby.shared.common.reference.SQLState;
1:33776ff: 
1:0326967: class NetConnectionRequest extends Request
1:0326967:     implements ConnectionRequestInterface {
1:0326967: 
1:1451af7:     NetConnectionRequest(NetAgent netAgent, int bufferSize) {
1:1451af7:         super(netAgent, bufferSize);
1:70f7692:     }
1:70f7692:     //----------------------------- entry points ---------------------------------
1:ffe112b: 
1:70f7692:     void writeExchangeServerAttributes(String externalName,
1:70f7692:                                        int targetAgent,
1:70f7692:                                        int targetSqlam,
1:70f7692:                                        int targetRdb,
1:70f7692:                                        int targetSecmgr,
1:70f7692:                                        int targetCmntcpip,
1:70f7692:                                        int targetCmnappc,
1:70f7692:                                        int targetXamgr,
1:70f7692:                                        int targetSyncptmgr,
1:b005ffa:                                        int targetRsyncmgr,
1:b005ffa:                                        int targetUnicodemgr) throws SqlException {
1:70f7692:         // send the exchange server attributes command to the server.
1:70f7692:         // no other commands will be chained to the excsat because
1:70f7692:         // the manager levels are needed before anything else is attempted.
1:70f7692:         buildEXCSAT(externalName,
1:70f7692:                 targetAgent,
1:70f7692:                 targetSqlam,
1:70f7692:                 targetRdb,
1:70f7692:                 targetSecmgr,
1:70f7692:                 targetCmntcpip,
1:70f7692:                 targetCmnappc,
1:70f7692:                 targetXamgr,
1:70f7692:                 targetSyncptmgr,
1:b005ffa:                 targetRsyncmgr,
1:b005ffa:                 targetUnicodemgr);
1:4e091b6: 
1:70f7692:     }
1:70f7692: 
1:70f7692:     void writeAccessSecurity(int securityMechanism,
1:70f7692:                              String databaseName,
1:70f7692:                              byte[] publicKey) throws SqlException {
1:70f7692:         buildACCSEC(securityMechanism, databaseName, publicKey);
1:70f7692:     }
1:70f7692: 
1:70f7692:     void writeSecurityCheck(int securityMechanism,
2:33776ff:                             String databaseName,
1:70f7692:                             String userid,
1:70f7692:                             String password,
1:70f7692:                             byte[] encryptedUserid,
1:70f7692:                             byte[] encryptedPassword) throws SqlException {
1:70f7692:         buildSECCHK(securityMechanism,
1:70f7692:                 databaseName,
1:70f7692:                 userid,
1:70f7692:                 password,
1:70f7692:                 encryptedUserid,
1:70f7692:                 encryptedPassword);
1:70f7692:     }
1:70f7692: 
1:70f7692:     void writeAccessDatabase(String rdbnam,
1:70f7692:                              boolean readOnly,
1:70f7692:                              byte[] correlationToken,
1:70f7692:                              byte[] productData,
1:70f7692:                              Typdef typdef) throws SqlException {
1:70f7692:         buildACCRDB(rdbnam,
1:70f7692:                 readOnly,
1:70f7692:                 correlationToken,
1:70f7692:                 productData,
1:70f7692:                 typdef);
1:70f7692:     }
1:33776ff: 
1:33776ff: 
1:70f7692:     public void writeCommitSubstitute(NetConnection connection) throws SqlException {
2:70f7692:         buildDummyEXCSAT();
1:70f7692:     }
1:33776ff: 
1:70f7692:     public void writeLocalCommit(NetConnection connection) throws SqlException {
1:70f7692:         buildRDBCMM();
1:70f7692:     }
1:70f7692: 
1:70f7692:     public void writeLocalRollback(NetConnection connection) throws SqlException {
1:70f7692:         buildRDBRLLBCK();
1:70f7692:     }
1:70f7692: 
1:70f7692:     public void writeLocalXAStart(NetConnection connection) throws SqlException {
1:70f7692:     }
1:70f7692: 
1:70f7692: 
1:70f7692:     //Build the SYNNCTL commit command
1:70f7692:     public void writeLocalXACommit(NetConnection conn) throws SqlException {
1:70f7692:     }
1:70f7692: 
1:70f7692:     //Build the SYNNCTL rollback command
1:70f7692:     public void writeLocalXARollback(NetConnection conn) throws SqlException {
1:70f7692:     }
1:70f7692: 
1:70f7692:     public void writeXaStartUnitOfWork(NetConnection conn) throws SqlException {
1:70f7692:     }
1:70f7692: 
1:70f7692:     public void writeXaEndUnitOfWork(NetConnection conn) throws SqlException {
1:70f7692:     }
1:70f7692: 
1:70f7692:     protected void writeXaPrepare(NetConnection conn) throws SqlException {
1:70f7692:     }
1:70f7692: 
1:70f7692:     protected void writeXaCommit(NetConnection conn, Xid xid) throws SqlException {
1:70f7692:     }
1:70f7692: 
1:70f7692:     protected void writeXaRollback(NetConnection conn, Xid xid) throws SqlException {
1:70f7692:     }
1:70f7692: 
1:70f7692:     protected void writeXaRecover(NetConnection conn, int flag) throws SqlException {
1:70f7692:     }
1:70f7692: 
1:70f7692:     protected void writeXaForget(NetConnection conn, Xid xid) throws SqlException {
1:70f7692:     }
1:70f7692: 
1:70f7692:     public void writeSYNCType(int codepoint, int syncType) {
1:70f7692:         writeScalar1Byte(codepoint, syncType);
1:70f7692:     }
1:70f7692: 
1:70f7692:     public void writeForget(int codepoint, int value) {
1:70f7692:     }
1:70f7692: 
1:70f7692:     public void writeReleaseConversation(int codepoint, int value) {
1:70f7692:     }
1:70f7692: 
1:70f7692:     void writeNullXID(int codepoint) {
1:70f7692:     }
1:70f7692: 
1:70f7692:     void writeXID(int codepoint, Xid xid) throws SqlException {
1:70f7692:     }
1:70f7692: 
1:70f7692:     void writeXAFlags(int codepoint, int xaFlags) {
1:70f7692:     }
1:70f7692: 
1:cccf5dd:     void writeXATimeout(int codepoint, long xaTimeout) {
1:cccf5dd:     }
1:cccf5dd: 
1:70f7692: 
1:70f7692:     //----------------------helper methods----------------------------------------
1:70f7692:     // These methods are "private protected", which is not a recognized java privilege,
1:70f7692:     // but means that these methods are private to this class and to subclasses,
1:70f7692:     // and should not be used as package-wide friendly methods.
1:70f7692: 
1:70f7692:     // RDB Commit Unit of Work (RDBCMM) Command commits all work performed
1:70f7692:     // for the current unit of work.
1:70f7692:     //
1:70f7692:     // The Relational Database Name (RDBNAM) is an optional parameter
1:70f7692:     // which will not be sent by this command to reduce size, building,
1:70f7692:     // and parsing.
1:b565f41:     private void buildRDBCMM() throws SqlException {
1:70f7692:         createCommand();
1:70f7692:         writeLengthCodePoint(0x04, CodePoint.RDBCMM);
1:70f7692:     }
1:70f7692: 
1:70f7692:     // RDB Rollback Unit of Work(RDBRLLBCK) Command rolls back
1:70f7692:     // all work performed for the current unit of work.
1:70f7692:     //
1:70f7692:     // The Relational Database Name (RDBNAM) is an optional parameter
1:70f7692:     // which will not be sent by this command to reduce size, building,
1:70f7692:     // and parsing.
1:0326967:     private void buildRDBRLLBCK() throws SqlException {
1:70f7692:         createCommand();
1:70f7692:         writeLengthCodePoint(0x04, CodePoint.RDBRLLBCK);
1:70f7692:     }
1:70f7692: 
1:70f7692:     // build the Exchange Server Attributes Command.
1:70f7692:     // This command sends the following information to the server.
1:70f7692:     // - this driver's server class name
1:70f7692:     // - this driver's level of each of the manager's it supports
1:70f7692:     // - this driver's product release level
1:70f7692:     // - this driver's external name
1:70f7692:     // - this driver's server name
1:0326967:     private void buildEXCSAT(String externalName,
1:70f7692:                      int targetAgent,
1:70f7692:                      int targetSqlam,
1:70f7692:                      int targetRdb,
1:70f7692:                      int targetSecmgr,
1:70f7692:                      int targetCmntcpip,
1:70f7692:                      int targetCmnappc,
1:70f7692:                      int targetXamgr,
1:70f7692:                      int targetSyncptmgr,
1:b005ffa:                      int targetRsyncmgr,
1:b005ffa:                      int targetUnicodemgr) throws SqlException {
1:70f7692:         createCommand();
1:70f7692: 
1:70f7692:         // begin excsat collection by placing the 4 byte llcp in the buffer.
1:70f7692:         // the length of this command will be computed later and "filled in"
1:70f7692:         // with the call to request.updateLengthBytes().
1:70f7692:         markLengthBytes(CodePoint.EXCSAT);
1:70f7692: 
1:70f7692:         // place the external name for the client into the buffer.
1:70f7692:         // the external name was previously calculated before the call to this method.
1:70f7692:         buildEXTNAM(externalName);
1:70f7692: 
1:70f7692:         // place the server name for the client into the buffer.
1:70f7692:         buildSRVNAM("Derby");
1:70f7692: 
1:70f7692:         // place the server release level for the client into the buffer.
1:70f7692:         // this is a hard coded value for the driver.
1:70f7692:         buildSRVRLSLV();
1:70f7692: 
1:70f7692:         // the managers supported by this driver and their levels will
1:70f7692:         // be sent to the server.  the variables which store these values
1:70f7692:         // were initialized during object constrcution to the highest values
1:70f7692:         // supported by the driver.
1:70f7692: 
1:70f7692:         // for the case of the manager levels object, there is no
1:70f7692:         // need to have the length of the ddm object dynamically calculated
1:70f7692:         // because this method knows exactly how many will be sent and can set
1:70f7692:         // this now.
1:70f7692:         // each manager level class and level are 4 bytes long and
1:70f7692:         // right now 5 are being sent for a total of 20 bytes or 0x14 bytes.
1:70f7692:         // writeScalarHeader will be called to insert the llcp.
1:70f7692:         buildMGRLVLLS(targetAgent,
1:70f7692:                 targetSqlam,
1:70f7692:                 targetRdb,
1:70f7692:                 targetSecmgr,
1:70f7692:                 targetXamgr,
1:70f7692:                 targetSyncptmgr,
1:b005ffa:                 targetRsyncmgr,
1:b005ffa:                 targetUnicodemgr);
1:70f7692: 
1:70f7692: 
1:70f7692:         // place the server class name into the buffer.
1:70f7692:         // this value is hard coded for the driver.
1:70f7692:         buildSRVCLSNM();
1:70f7692: 
1:70f7692:         // the excsat command is complete so the updateLengthBytes method
1:70f7692:         // is called to dynamically compute the length for this command and insert
1:70f7692:         // it into the buffer
1:4e091b6:         updateLengthBytes();
1:4e091b6:     }
1:4e091b6: 
1:0326967:     private void buildDummyEXCSAT() throws SqlException {
1:70f7692:         createCommand();
1:70f7692: 
1:70f7692:         // begin excsat collection by placing the 4 byte llcp in the buffer.
1:70f7692:         // the length of this command will be computed later and "filled in"
1:70f7692:         // with the call to request.updateLengthBytes().
1:70f7692:         markLengthBytes(CodePoint.EXCSAT);
1:70f7692: 
1:70f7692:         // the excsat command is complete so the updateLengthBytes method
1:70f7692:         // is called to dynamically compute the length for this command and insert
1:70f7692:         // it into the buffer
2:70f7692:         updateLengthBytes();
1:70f7692:     }
1:70f7692: 
1:0326967:     private void buildACCSEC(int secmec,
1:70f7692:                      String rdbnam,
1:70f7692:                      byte[] sectkn) throws SqlException {
1:70f7692:         createCommand();
1:70f7692: 
1:70f7692:         // place the llcp for the ACCSEC in the buffer.  save the length bytes for
1:70f7692:         // later update
1:70f7692:         markLengthBytes(CodePoint.ACCSEC);
1:70f7692: 
1:70f7692:         // the security mechanism is a required instance variable.  it will
1:70f7692:         // always be sent.
1:70f7692:         buildSECMEC(secmec);
1:70f7692: 
1:70f7692:         // the rdbnam will be built and sent.  different sqlam levels support
1:70f7692:         // different lengths.  at this point the length has been checked against
1:70f7692:         // the maximum allowable length.  so write the bytes and padd up to the
1:6384512:         // minimum length if needed.  We want to defer sending the rdbnam if an
1:6384512:         // EBCDIC conversion is not possible.
1:6384512:         buildRDBNAM(rdbnam,true);
1:70f7692: 
1:70f7692:         if (sectkn != null) {
1:70f7692:             buildSECTKN(sectkn);
1:70f7692:         }
1:70f7692: 
1:70f7692:         // the accsec command is complete so notify the the request object to
1:70f7692:         // update the ddm length and the dss header length.
1:70f7692:         updateLengthBytes();
1:70f7692:     }
1:70f7692: 
1:0326967:     private void buildSECCHK(int secmec,
1:70f7692:                      String rdbnam,
1:70f7692:                      String user,
1:70f7692:                      String password,
1:70f7692:                      byte[] sectkn,
1:70f7692:                      byte[] sectkn2) throws SqlException {
1:70f7692:         createCommand();
1:70f7692:         markLengthBytes(CodePoint.SECCHK);
1:70f7692: 
1:70f7692:         // always send the negotiated security mechanism for the connection.
1:70f7692:         buildSECMEC(secmec);
1:70f7692: 
1:70f7692:         // the rdbnam will be built and sent.  different sqlam levels support
1:70f7692:         // different lengths.  at this point the length has been checked against
1:70f7692:         // the maximum allowable length.  so write the bytes and padd up to the
2:70f7692:         // minimum length if needed.
1:6384512:         buildRDBNAM(rdbnam,false);
1:70f7692:         if (user != null) {
1:70f7692:             buildUSRID(user);
1:70f7692:         }
1:70f7692:         if (password != null) {
1:70f7692:             buildPASSWORD(password);
1:70f7692:         }
1:70f7692:         if (sectkn != null) {
1:70f7692:             buildSECTKN(sectkn);
1:70f7692:         }
1:70f7692:         if (sectkn2 != null) {
1:70f7692:             buildSECTKN(sectkn2);
1:70f7692:         }
1:70f7692:         updateLengthBytes();
1:70f7692: 
1:70f7692:     }
1:70f7692: 
1:70f7692:     // The Access RDB (ACCRDB) command makes a named relational database (RDB)
1:70f7692:     // available to a requester by creating an instance of an SQL application
1:70f7692:     // manager.  The access RDB command then binds the created instance to the target
1:70f7692:     // agent and to the RDB. The RDB remains available (accessed) until
1:70f7692:     // the communications conversation is terminate.
1:0326967:     private void buildACCRDB(String rdbnam,
1:70f7692:                      boolean readOnly,
1:70f7692:                      byte[] crrtkn,
1:70f7692:                      byte[] prddta,
1:70f7692:                      Typdef typdef) throws SqlException {
1:70f7692:         createCommand();
1:70f7692: 
1:70f7692:         markLengthBytes(CodePoint.ACCRDB);
1:70f7692: 
1:70f7692:         // the relational database name specifies the name of the rdb to
1:70f7692:         // be accessed.  this can be different sizes depending on the level of
1:70f7692:         // support.  the size will have ben previously checked so at this point just
1:70f7692:         // write the data and pad with the correct number of bytes as needed.
1:70f7692:         // this instance variable is always required.
1:b005ffa:         buildRDBNAM(rdbnam,true);
1:70f7692: 
1:70f7692:         // the rdb access manager class specifies an instance of the SQLAM
1:70f7692:         // that accesses the RDB.  the sqlam manager class codepoint
1:70f7692:         // is always used/required for this.  this instance variable
1:70f7692:         // is always required.
1:70f7692:         buildRDBACCCL();
1:70f7692: 
1:70f7692:         // product specific identifier specifies the product release level
1:70f7692:         // of this driver.  see the hard coded value in the NetConfiguration class.
1:70f7692:         // this instance variable is always required.
1:70f7692:         buildPRDID();
1:70f7692: 
1:70f7692:         // product specific data.  this is an optional parameter which carries
1:70f7692:         // product specific information.  although it is optional, it will be
1:70f7692:         // sent to the server.  use the first byte to determine the number
1:70f7692:         // of the prddta bytes to write to the buffer. note: this length
1:70f7692:         // doesn't include itself so increment by it by 1 to get the actual
1:70f7692:         // length of this data.
1:70f7692:         buildPRDDTA(prddta);
1:70f7692: 
1:70f7692: 
1:70f7692:         // the typdefnam parameter specifies the name of the data type to data representation
1:70f7692:         // mappings used when this driver sends command data objects.
1:70f7692:         buildTYPDEFNAM(typdef.getTypdefnam());
1:70f7692: 
1:70f7692:         if (crrtkn == null) {
1:70f7692:             netAgent_.netConnection_.constructCrrtkn();
1:70f7692:         }
1:70f7692: 
1:70f7692:         buildCRRTKN(netAgent_.netConnection_.crrtkn_);
1:70f7692: 
1:70f7692:         // This specifies the single-byte, double-byte
1:70f7692:         // and mixed-byte CCSIDs of the Scalar Data Arrays (SDAs) in the identified
1:70f7692:         // data type to the data representation mapping definitions.  This can
1:70f7692:         // contain 3 CCSIDs.  The driver will only send the ones which were set.
1:70f7692:         buildTYPDEFOVR(typdef.isCcsidSbcSet(),
1:70f7692:                 typdef.getCcsidSbc(),
1:70f7692:                 typdef.isCcsidDbcSet(),
1:70f7692:                 typdef.getCcsidDbc(),
1:70f7692:                 typdef.isCcsidMbcSet(),
1:70f7692:                 typdef.getCcsidMbc());
1:4e091b6: 
1:70f7692:         // RDB allow update is an optional parameter which indicates
1:70f7692:         // whether the RDB allows the requester to perform update operations
1:70f7692:         // in the RDB.  If update operations are not allowed, this connection
1:70f7692:         // is limited to read-only access of the RDB resources.
1:70f7692:         buildRDBALWUPD(readOnly);
1:70f7692: 
1:70f7692: 
1:70f7692: 
1:70f7692:         // the Statement Decimal Delimiter (STTDECDEL),
1:70f7692:         // Statement String Delimiter (STTSTRDEL),
1:70f7692:         // and Target Default Value Return (TRGDFTRT) are all optional
1:70f7692:         // instance variables which will not be sent to the server.
1:70f7692: 
1:70f7692:         // the command and the dss are complete so make the call to notify
1:70f7692:         // the request object.
1:70f7692:         updateLengthBytes();
1:70f7692:     }
1:70f7692: 
1:70f7692: 
1:70f7692:     void buildSYNCCTLMigrate() throws SqlException {
1:70f7692:     }
1:70f7692: 
1:70f7692:     void buildSYNCCTLCommit(int xaFlags, Xid xid) throws SqlException {
1:70f7692:     }
1:70f7692: 
1:70f7692:     void buildSYNCCTLRollback(int xaFlags) throws SqlException {
1:70f7692:     }
1:70f7692: 
1:70f7692: 
1:70f7692:     // The External Name is the name of the job, task, or process on a
1:70f7692:     // system for which a DDM server is active.
1:70f7692:     private void buildEXTNAM(String extnam) throws SqlException {
1:6391648:         int extnamTruncateLength = Math.min(extnam.length(),
1:70f7692:                 NetConfiguration.EXTNAM_MAXSIZE);
1:70f7692: 
1:5017a7d:         // Writing the truncated string as to preserve previous behavior
1:5017a7d:         writeScalarString(CodePoint.EXTNAM, extnam.substring(0, extnamTruncateLength), 0,
1:5017a7d:                 NetConfiguration.EXTNAM_MAXSIZE, SQLState.NET_EXTNAM_TOO_LONG);
1:70f7692:     }
1:70f7692: 
1:70f7692:     // Server Name is the name of the DDM server.
1:70f7692:     private void buildSRVNAM(String srvnam) throws SqlException {
1:6391648:         int srvnamTruncateLength = Math.min(srvnam.length(),
1:70f7692:                 NetConfiguration.SRVNAM_MAXSIZE);
1:5017a7d:         
1:5017a7d:         // Writing the truncated string as to preserve previous behavior
1:5017a7d:         writeScalarString(CodePoint.SRVNAM,srvnam.substring(0, srvnamTruncateLength),
1:5017a7d:                 0, NetConfiguration.SRVNAM_MAXSIZE,SQLState.NET_SRVNAM_TOO_LONG);
1:70f7692:     }
1:70f7692: 
1:70f7692:     // Server Product Release Level String specifies the product
1:70f7692:     // release level of a DDM server.
1:70f7692:     private void buildSRVRLSLV() throws SqlException {
1:70f7692:         // Hard-coded to ClientDNC 1.0 for dnc 1.0.
1:70f7692:         writeScalarString(CodePoint.SRVRLSLV, NetConfiguration.SRVRLSLV);
1:70f7692:     }
1:70f7692: 
1:70f7692:     private void buildSRVCLSNM() throws SqlException {
1:70f7692:         // Server class name is hard-coded to QDERBY/JVM for dnc.
1:70f7692:         writeScalarString(CodePoint.SRVCLSNM, NetConfiguration.SRVCLSNM_JVM);
1:70f7692:     }
1:70f7692: 
1:70f7692:     // Precondition: valid secmec is assumed.
1:70f7692:     private void buildSECMEC(int secmec) throws SqlException {
1:70f7692:         writeScalar2Bytes(CodePoint.SECMEC, secmec);
1:70f7692:     }
1:70f7692: 
1:6384512:     /**
1:6384512:      * 
1:6384512:      * Relational Database Name specifies the name of a relational database
1:6384512:      * of the server.
1:dbed020:      * if length of RDB name &lt;= 18 characters, there is not change to the format
1:6384512:      * of the RDB name.  The length of the RDBNAM remains fixed at 18 which includes
1:6384512:      * any right bland padding if necessary.
1:dbed020:      * if length of the RDB name is &gt; 18 characters, the length of the RDB name is
1:6384512:      * identical to the length of the RDB name.  No right blank padding is required.
1:6384512:      * @param rdbnam  name of the database.
1:6384512:      * @param dontSendOnConversionError omit sending the RDBNAM if there is an
1:6384512:      * exception converting to EBCDIC.  This will be used by ACCSEC to defer
1:6384512:      * sending the RDBNAM to SECCHK if it can't be converted.
1:6384512:      *
1:6384512:      */
1:6384512:     private void buildRDBNAM(String rdbnam, boolean dontSendOnConversionError) throws SqlException {
1:70f7692:         // since this gets built more than once on the connect flow,
1:70f7692:         // see if we can optimize
1:6384512:         if (dontSendOnConversionError) {
1:6384512:             try {
1:1451af7:                 netAgent_.getCurrentCcsidManager().convertFromJavaString(rdbnam, netAgent_);
1:6384512:             } catch (SqlException se)  {
1:6384512:                 netAgent_.exceptionConvertingRdbnam = se;
1:6384512:                 return;
1:6384512:             }
1:6384512:             
1:6384512:         }
1:70f7692:         
1:813aa38:         //DERBY-4805(Increase the length of the RDBNAM field in the 
1:813aa38:         // DRDA implementation)
1:813aa38:         //The new RDBNAM length in 10.11 is 1024bytes(it used to be 254 bytes).
1:813aa38:         //But if a 10.11 or higher client talks to a 10.10 or under server with
1:813aa38:         // a RDBNAM > 254 bytes, it will result in a protocol exception
1:813aa38:         // because those servers do not support RDBNAM greater than 254 bytes.
1:813aa38:         // This behavior will logged in the jira.
1:813aa38:         //One way to fix this would have been to check the server version
1:813aa38:         // before hand but we do not have that information when the client is
1:813aa38:         // first trying to establish connection to the server by sending the
1:813aa38:         // connect request along with the RDBNAM.
1:813aa38:         int maxRDBlength =
1:813aa38:                  NetConfiguration.RDBNAM_MAX_LEN;
1:ffe112b:         writeScalarString(CodePoint.RDBNAM, rdbnam,
1:ffe112b:                 NetConfiguration.PKG_IDENTIFIER_FIXED_LEN, //minimum RDBNAM length in bytes
1:813aa38:                 maxRDBlength,  
1:ffe112b:                 SQLState.NET_DBNAME_TOO_LONG);
1:ffe112b:                 
1:70f7692:     }
1:70f7692: 
1:70f7692:     private void buildSECTKN(byte[] sectkn) throws SqlException {
1:70f7692:         if (sectkn.length > NetConfiguration.SECTKN_MAXSIZE) {
1:1b39163:             throw new SqlException(netAgent_.logWriter_, 
1:1b39163:                 new ClientMessageId(SQLState.NET_SECTKN_TOO_LONG));
1:70f7692:         }
1:70f7692:         writeScalarBytes(CodePoint.SECTKN, sectkn);
1:70f7692:     }
1:70f7692: 
1:70f7692:     private void buildUSRID(String usrid) throws SqlException {
1:ffe112b:         
1:ffe112b:         writeScalarString(CodePoint.USRID, usrid,0,NetConfiguration.USRID_MAXSIZE,
1:ffe112b:                 SQLState.NET_USERID_TOO_LONG);
1:70f7692:     }
1:70f7692: 
1:70f7692:     private void buildPASSWORD(String password) throws SqlException {
1:70f7692:         int passwordLength = password.length();
1:ffe112b:         if ((passwordLength == 0) ) {
1:1b39163:             throw new SqlException(netAgent_.logWriter_, 
1:1b39163:                 new ClientMessageId(SQLState.NET_PASSWORD_TOO_LONG));
1:70f7692:         }
1:70f7692:         if (netAgent_.logWriter_ != null) {
1:70f7692:             // remember the position of password in order to
1:70f7692:             // mask it out in trace (see Request.sendBytes()).
1:70f7692:             passwordIncluded_ = true;
1:f6e1e6f:             passwordStart_ = buffer.position() + 4;
1:70f7692:         }
1:ffe112b:         writeScalarString(CodePoint.PASSWORD, password, 0, NetConfiguration.PASSWORD_MAXSIZE,
1:ffe112b:                 SQLState.NET_PASSWORD_TOO_LONG);
1:ffe112b:         if (netAgent_.logWriter_ != null) {
1:f6e1e6f:             passwordLength_ = buffer.position() - passwordStart_;
1:ffe112b:         }
1:70f7692:     }
1:70f7692: 
1:70f7692:     private void buildRDBACCCL() throws SqlException {
1:70f7692:         writeScalar2Bytes(CodePoint.RDBACCCL, CodePoint.SQLAM);
1:70f7692:     }
1:70f7692: 
1:70f7692: 
1:70f7692:     private void buildPRDID() throws SqlException {
1:70f7692:         writeScalarString(CodePoint.PRDID, NetConfiguration.PRDID);  // product id is hard-coded to DNC01000 for dnc 1.0.
1:70f7692:     }
1:70f7692: 
1:70f7692:     private void buildPRDDTA(byte[] prddta) throws SqlException {
1:70f7692:         int prddtaLength = (prddta[NetConfiguration.PRDDTA_LEN_BYTE] & 0xff) + 1;
1:70f7692:         writeScalarBytes(CodePoint.PRDDTA, prddta, 0, prddtaLength);
1:70f7692:     }
1:70f7692: 
1:70f7692:     private void buildTYPDEFNAM(String typdefnam) throws SqlException {
1:70f7692:         writeScalarString(CodePoint.TYPDEFNAM, typdefnam);
1:70f7692:     }
1:70f7692: 
1:0326967:     private void buildTYPDEFOVR(boolean sendCcsidSbc,
1:70f7692:                         int ccsidSbc,
1:70f7692:                         boolean sendCcsidDbc,
1:70f7692:                         int ccsidDbc,
1:70f7692:                         boolean sendCcsidMbc,
1:70f7692:                         int ccsidMbc) throws SqlException {
1:70f7692:         markLengthBytes(CodePoint.TYPDEFOVR);
1:70f7692:         // write the single-byte ccsid used by this driver.
1:70f7692:         if (sendCcsidSbc) {
1:70f7692:             writeScalar2Bytes(CodePoint.CCSIDSBC, ccsidSbc);
1:70f7692:         }
1:70f7692: 
1:70f7692:         // write the double-byte ccsid used by this driver.
1:70f7692:         if (sendCcsidDbc) {
1:70f7692:             writeScalar2Bytes(CodePoint.CCSIDDBC, ccsidDbc);
1:70f7692:         }
1:70f7692: 
1:70f7692:         // write the mixed-byte ccsid used by this driver
1:70f7692:         if (sendCcsidMbc) {
1:70f7692:             writeScalar2Bytes(CodePoint.CCSIDMBC, ccsidMbc);
1:70f7692:         }
1:70f7692: 
1:70f7692:         updateLengthBytes();
1:70f7692: 
1:70f7692:     }
1:70f7692: 
1:70f7692:     private void buildMGRLVLLS(int agent,
1:70f7692:                                int sqlam,
1:70f7692:                                int rdb,
1:70f7692:                                int secmgr,
1:70f7692:                                int xamgr,
1:70f7692:                                int syncptmgr,
1:b005ffa:                                int rsyncmgr,
1:b005ffa:                                int unicodemgr) throws SqlException {
1:70f7692:         markLengthBytes(CodePoint.MGRLVLLS);
1:70f7692: 
1:70f7692:         // place the managers and their levels in the buffer
1:70f7692:         writeCodePoint4Bytes(CodePoint.AGENT, agent);
1:70f7692:         writeCodePoint4Bytes(CodePoint.SQLAM, sqlam);
1:70f7692:         writeCodePoint4Bytes(CodePoint.RDB, rdb);
1:70f7692:         writeCodePoint4Bytes(CodePoint.SECMGR, secmgr);
1:b005ffa:         writeCodePoint4Bytes(CodePoint.UNICODEMGR, unicodemgr);
1:b005ffa:         
1:70f7692:         if (netAgent_.netConnection_.isXAConnection()) {
1:70f7692:             if (xamgr != NetConfiguration.MGRLVL_NA) {
1:70f7692:                 writeCodePoint4Bytes(CodePoint.XAMGR, xamgr);
1:70f7692:             }
1:70f7692:             if (syncptmgr != NetConfiguration.MGRLVL_NA) {
1:70f7692:                 writeCodePoint4Bytes(CodePoint.SYNCPTMGR, syncptmgr);
1:70f7692:             }
1:70f7692:             if (rsyncmgr != NetConfiguration.MGRLVL_NA) {
1:70f7692:                 writeCodePoint4Bytes(CodePoint.RSYNCMGR, rsyncmgr);
1:70f7692:             }
1:70f7692:         }
1:70f7692:         updateLengthBytes();
1:70f7692:     }
1:70f7692: 
1:70f7692:     private void buildCRRTKN(byte[] crrtkn) throws SqlException {
1:70f7692:         writeScalarBytes(CodePoint.CRRTKN, crrtkn);
1:70f7692:     }
1:70f7692: 
1:70f7692:     private void buildRDBALWUPD(boolean readOnly) throws SqlException {
1:70f7692:         if (readOnly) {
1:70f7692:             writeScalar1Byte(CodePoint.RDBALWUPD, CodePoint.FALSE);
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:70f7692: }
1:70f7692: 
1:70f7692: 
1:33776ff: 
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1:      * if length of RDB name &lt;= 18 characters, there is not change to the format
1:      * if length of the RDB name is &gt; 18 characters, the length of the RDB name is
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:813aa38
/////////////////////////////////////////////////////////////////////////
1:         //DERBY-4805(Increase the length of the RDBNAM field in the 
1:         // DRDA implementation)
1:         //The new RDBNAM length in 10.11 is 1024bytes(it used to be 254 bytes).
1:         //But if a 10.11 or higher client talks to a 10.10 or under server with
1:         // a RDBNAM > 254 bytes, it will result in a protocol exception
1:         // because those servers do not support RDBNAM greater than 254 bytes.
1:         // This behavior will logged in the jira.
1:         //One way to fix this would have been to check the server version
1:         // before hand but we do not have that information when the client is
1:         // first trying to establish connection to the server by sending the
1:         // connect request along with the RDBNAM.
1:         int maxRDBlength =
1:                  NetConfiguration.RDBNAM_MAX_LEN;
1:                 maxRDBlength,  
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:b565f41
/////////////////////////////////////////////////////////////////////////
1:     private void buildRDBCMM() throws SqlException {
commit:0326967
/////////////////////////////////////////////////////////////////////////
1: class NetConnectionRequest extends Request
1:     implements ConnectionRequestInterface {
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private void buildRDBRLLBCK() throws SqlException {
/////////////////////////////////////////////////////////////////////////
1:     private void buildEXCSAT(String externalName,
/////////////////////////////////////////////////////////////////////////
1:     private void buildDummyEXCSAT() throws SqlException {
/////////////////////////////////////////////////////////////////////////
1:     private void buildACCSEC(int secmec,
/////////////////////////////////////////////////////////////////////////
1:     private void buildSECCHK(int secmec,
/////////////////////////////////////////////////////////////////////////
1:     private void buildACCRDB(String rdbnam,
/////////////////////////////////////////////////////////////////////////
1:     private void buildTYPDEFOVR(boolean sendCcsidSbc,
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:f6e1e6f
/////////////////////////////////////////////////////////////////////////
1:             passwordStart_ = buffer.position() + 4;
1:             passwordLength_ = buffer.position() - passwordStart_;
commit:cccf5dd
/////////////////////////////////////////////////////////////////////////
1:     void writeXATimeout(int codepoint, long xaTimeout) {
1:     }
1: 
author:Tiago Aur¨¦lio Rodrigues Espinha
-------------------------------------------------------------------------------
commit:b005ffa
/////////////////////////////////////////////////////////////////////////
1:                                        int targetRsyncmgr,
1:                                        int targetUnicodemgr) throws SqlException {
/////////////////////////////////////////////////////////////////////////
1:                 targetRsyncmgr,
1:                 targetUnicodemgr);
/////////////////////////////////////////////////////////////////////////
1:                      int targetRsyncmgr,
1:                      int targetUnicodemgr) throws SqlException {
/////////////////////////////////////////////////////////////////////////
1:                 targetRsyncmgr,
1:                 targetUnicodemgr);
/////////////////////////////////////////////////////////////////////////
1:         buildRDBNAM(rdbnam,true);
/////////////////////////////////////////////////////////////////////////
1:                                int rsyncmgr,
1:                                int unicodemgr) throws SqlException {
/////////////////////////////////////////////////////////////////////////
1:         writeCodePoint4Bytes(CodePoint.UNICODEMGR, unicodemgr);
1:         
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:1451af7
/////////////////////////////////////////////////////////////////////////
1:     NetConnectionRequest(NetAgent netAgent, int bufferSize) {
1:         super(netAgent, bufferSize);
/////////////////////////////////////////////////////////////////////////
1:                 netAgent_.getCurrentCcsidManager().convertFromJavaString(rdbnam, netAgent_);
commit:5017a7d
/////////////////////////////////////////////////////////////////////////
1:         // Writing the truncated string as to preserve previous behavior
1:         writeScalarString(CodePoint.EXTNAM, extnam.substring(0, extnamTruncateLength), 0,
1:                 NetConfiguration.EXTNAM_MAXSIZE, SQLState.NET_EXTNAM_TOO_LONG);
1:         
1:         // Writing the truncated string as to preserve previous behavior
1:         writeScalarString(CodePoint.SRVNAM,srvnam.substring(0, srvnamTruncateLength),
1:                 0, NetConfiguration.SRVNAM_MAXSIZE,SQLState.NET_SRVNAM_TOO_LONG);
commit:ffe112b
/////////////////////////////////////////////////////////////////////////
1:         
1:         writeScalarString(CodePoint.RDBNAM, rdbnam,
1:                 NetConfiguration.PKG_IDENTIFIER_FIXED_LEN, //minimum RDBNAM length in bytes
0:                 NetConfiguration.PKG_IDENTIFIER_MAX_LEN,   //maximum RDBNAM length in bytes
1:                 SQLState.NET_DBNAME_TOO_LONG);
1:                 
/////////////////////////////////////////////////////////////////////////
1:         
1:         writeScalarString(CodePoint.USRID, usrid,0,NetConfiguration.USRID_MAXSIZE,
1:                 SQLState.NET_USERID_TOO_LONG);
1:         if ((passwordLength == 0) ) {
/////////////////////////////////////////////////////////////////////////
1:         writeScalarString(CodePoint.PASSWORD, password, 0, NetConfiguration.PASSWORD_MAXSIZE,
1:                 SQLState.NET_PASSWORD_TOO_LONG);
1:         if (netAgent_.logWriter_ != null) {
0:             passwordLength_ = offset_ - passwordStart_;
1:         }
commit:6384512
/////////////////////////////////////////////////////////////////////////
1:         // minimum length if needed.  We want to defer sending the rdbnam if an
1:         // EBCDIC conversion is not possible.
1:         buildRDBNAM(rdbnam,true);
/////////////////////////////////////////////////////////////////////////
1:         buildRDBNAM(rdbnam,false);
/////////////////////////////////////////////////////////////////////////
0:         buildRDBNAM(rdbnam,false);
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * 
1:      * Relational Database Name specifies the name of a relational database
1:      * of the server.
0:      * if length of RDB name <= 18 characters, there is not change to the format
1:      * of the RDB name.  The length of the RDBNAM remains fixed at 18 which includes
1:      * any right bland padding if necessary.
0:      * if length of the RDB name is > 18 characters, the length of the RDB name is
1:      * identical to the length of the RDB name.  No right blank padding is required.
1:      * @param rdbnam  name of the database.
1:      * @param dontSendOnConversionError omit sending the RDBNAM if there is an
1:      * exception converting to EBCDIC.  This will be used by ACCSEC to defer
1:      * sending the RDBNAM to SECCHK if it can't be converted.
1:      *
1:      */
1:     private void buildRDBNAM(String rdbnam, boolean dontSendOnConversionError) throws SqlException {
1:         if (dontSendOnConversionError) {
1:             try {
0:                 ccsidManager_.convertFromUCS2(rdbnam, netAgent_);
1:             } catch (SqlException se)  {
1:                 netAgent_.exceptionConvertingRdbnam = se;
1:                 return;
1:             }
1:             
1:         }
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:b9687fb
/////////////////////////////////////////////////////////////////////////
0:                 ccsidManager_.convertFromJavaString(rdbnam, netAgent_);
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6391648
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         int extnamTruncateLength = Math.min(extnam.length(),
/////////////////////////////////////////////////////////////////////////
1:         int srvnamTruncateLength = Math.min(srvnam.length(),
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:59bf37d
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Andreas Korneliussen
-------------------------------------------------------------------------------
commit:4d34a23
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Bernt Johnsen
-------------------------------------------------------------------------------
commit:4e091b6
/////////////////////////////////////////////////////////////////////////
0:         // This specifies the SQL Error Diagnostic Level
0:         buildDIAGLVL();
1: 
/////////////////////////////////////////////////////////////////////////
0:     private void buildDIAGLVL() throws SqlException {
0:         markLengthBytes(CodePoint.DIAGLVL);
1:         
0:         writeByte(CodePoint.DIAGLVL2);
1:         updateLengthBytes();
1:     }
1: 
author:David Van Couvering
-------------------------------------------------------------------------------
commit:1b39163
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.client.am.ClientMessageId;
1: import org.apache.derby.shared.common.reference.SQLState;
/////////////////////////////////////////////////////////////////////////
1:                 throw new SqlException(netAgent_.logWriter_, 
0:                     new ClientMessageId(SQLState.NET_DBNAME_TOO_LONG), rdbnam);
/////////////////////////////////////////////////////////////////////////
1:             throw new SqlException(netAgent_.logWriter_, 
1:                 new ClientMessageId(SQLState.NET_SECTKN_TOO_LONG));
/////////////////////////////////////////////////////////////////////////
0:             throw new SqlException(netAgent_.logWriter_, 
0:                 new ClientMessageId(SQLState.NET_USERID_TOO_LONG));
/////////////////////////////////////////////////////////////////////////
0:             throw new SqlException(netAgent_.logWriter_, 
1:                 new ClientMessageId(SQLState.NET_PASSWORD_TOO_LONG));
author:Jeremy Boynes
-------------------------------------------------------------------------------
commit:70f7692
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.client.am.SqlException;
0: import org.apache.derby.client.am.Utils;
0: public class NetConnectionRequest extends Request implements ConnectionRequestInterface {
0:     NetConnectionRequest(NetAgent netAgent, CcsidManager ccsidManager, int bufferSize) {
0:         super(netAgent, ccsidManager, bufferSize);
1:     }
1:     //----------------------------- entry points ---------------------------------
1:     void writeExchangeServerAttributes(String externalName,
1:                                        int targetAgent,
1:                                        int targetSqlam,
1:                                        int targetRdb,
1:                                        int targetSecmgr,
1:                                        int targetCmntcpip,
1:                                        int targetCmnappc,
1:                                        int targetXamgr,
1:                                        int targetSyncptmgr,
0:                                        int targetRsyncmgr) throws SqlException {
1:         // send the exchange server attributes command to the server.
1:         // no other commands will be chained to the excsat because
1:         // the manager levels are needed before anything else is attempted.
1:         buildEXCSAT(externalName,
1:                 targetAgent,
1:                 targetSqlam,
1:                 targetRdb,
1:                 targetSecmgr,
1:                 targetCmntcpip,
1:                 targetCmnappc,
1:                 targetXamgr,
1:                 targetSyncptmgr,
0:                 targetRsyncmgr);
1:     }
0:     void writeDummyExchangeServerAttributes() throws SqlException {
0:         // send the exchange server attributes command to the server,
0:         // without any parameters
1:         buildDummyEXCSAT();
1:     }
1: 
1:     void writeAccessSecurity(int securityMechanism,
1:                              String databaseName,
1:                              byte[] publicKey) throws SqlException {
1:         buildACCSEC(securityMechanism, databaseName, publicKey);
1:     }
1: 
1:     void writeSecurityCheck(int securityMechanism,
1:                             String userid,
1:                             String password,
1:                             byte[] encryptedUserid,
1:                             byte[] encryptedPassword) throws SqlException {
1:         buildSECCHK(securityMechanism,
1:                 databaseName,
1:                 userid,
1:                 password,
1:                 encryptedUserid,
1:                 encryptedPassword);
1: 
1:     void writeAccessDatabase(String rdbnam,
1:                              boolean readOnly,
1:                              byte[] correlationToken,
1:                              byte[] productData,
1:                              Typdef typdef) throws SqlException {
1:         buildACCRDB(rdbnam,
1:                 readOnly,
1:                 correlationToken,
1:                 productData,
1:                 typdef);
1:     public void writeCommitSubstitute(NetConnection connection) throws SqlException {
1:         buildDummyEXCSAT();
1:     public void writeLocalCommit(NetConnection connection) throws SqlException {
1:         buildRDBCMM();
1:     public void writeLocalRollback(NetConnection connection) throws SqlException {
1:         buildRDBRLLBCK();
1:     }
1:     public void writeLocalXAStart(NetConnection connection) throws SqlException {
1:     }
1: 
1: 
1:     //Build the SYNNCTL commit command
1:     public void writeLocalXACommit(NetConnection conn) throws SqlException {
1:     }
1: 
1:     //Build the SYNNCTL rollback command
1:     public void writeLocalXARollback(NetConnection conn) throws SqlException {
1:     }
1: 
1:     public void writeXaStartUnitOfWork(NetConnection conn) throws SqlException {
1:     }
1: 
1:     public void writeXaEndUnitOfWork(NetConnection conn) throws SqlException {
1:     }
1: 
1:     protected void writeXaPrepare(NetConnection conn) throws SqlException {
1:     }
1: 
1:     protected void writeXaCommit(NetConnection conn, Xid xid) throws SqlException {
1:     }
1: 
1:     protected void writeXaRollback(NetConnection conn, Xid xid) throws SqlException {
1:     }
1: 
1:     protected void writeXaRecover(NetConnection conn, int flag) throws SqlException {
1:     }
1: 
1:     protected void writeXaForget(NetConnection conn, Xid xid) throws SqlException {
1:     }
1: 
1:     public void writeSYNCType(int codepoint, int syncType) {
1:         writeScalar1Byte(codepoint, syncType);
1:     }
1: 
1:     public void writeForget(int codepoint, int value) {
1:     }
1: 
1:     public void writeReleaseConversation(int codepoint, int value) {
1:     }
1: 
1:     void writeNullXID(int codepoint) {
1:     }
1: 
1:     void writeXID(int codepoint, Xid xid) throws SqlException {
1:     }
1: 
1: 
1:     void writeXAFlags(int codepoint, int xaFlags) {
1:     }
1: 
1: 
1:     //----------------------helper methods----------------------------------------
1:     // These methods are "private protected", which is not a recognized java privilege,
1:     // but means that these methods are private to this class and to subclasses,
1:     // and should not be used as package-wide friendly methods.
1: 
1:     // RDB Commit Unit of Work (RDBCMM) Command commits all work performed
1:     // for the current unit of work.
1:     //
1:     // The Relational Database Name (RDBNAM) is an optional parameter
1:     // which will not be sent by this command to reduce size, building,
1:     // and parsing.
0:     void buildRDBCMM() throws SqlException {
1:         createCommand();
1:         writeLengthCodePoint(0x04, CodePoint.RDBCMM);
1:     }
1: 
1:     // RDB Rollback Unit of Work(RDBRLLBCK) Command rolls back
1:     // all work performed for the current unit of work.
1:     //
1:     // The Relational Database Name (RDBNAM) is an optional parameter
1:     // which will not be sent by this command to reduce size, building,
1:     // and parsing.
0:     void buildRDBRLLBCK() throws SqlException {
1:         createCommand();
1:         writeLengthCodePoint(0x04, CodePoint.RDBRLLBCK);
1:     }
1: 
1:     // build the Exchange Server Attributes Command.
1:     // This command sends the following information to the server.
1:     // - this driver's server class name
1:     // - this driver's level of each of the manager's it supports
1:     // - this driver's product release level
1:     // - this driver's external name
1:     // - this driver's server name
0:     void buildEXCSAT(String externalName,
1:                      int targetAgent,
1:                      int targetSqlam,
1:                      int targetRdb,
1:                      int targetSecmgr,
1:                      int targetCmntcpip,
1:                      int targetCmnappc,
1:                      int targetXamgr,
1:                      int targetSyncptmgr,
0:                      int targetRsyncmgr) throws SqlException {
1:         createCommand();
1: 
1:         // begin excsat collection by placing the 4 byte llcp in the buffer.
1:         // the length of this command will be computed later and "filled in"
1:         // with the call to request.updateLengthBytes().
1:         markLengthBytes(CodePoint.EXCSAT);
1: 
1:         // place the external name for the client into the buffer.
1:         // the external name was previously calculated before the call to this method.
1:         buildEXTNAM(externalName);
1: 
1:         // place the server name for the client into the buffer.
1:         buildSRVNAM("Derby");
1: 
1:         // place the server release level for the client into the buffer.
1:         // this is a hard coded value for the driver.
1:         buildSRVRLSLV();
1: 
1:         // the managers supported by this driver and their levels will
1:         // be sent to the server.  the variables which store these values
1:         // were initialized during object constrcution to the highest values
1:         // supported by the driver.
1: 
1:         // for the case of the manager levels object, there is no
1:         // need to have the length of the ddm object dynamically calculated
1:         // because this method knows exactly how many will be sent and can set
1:         // this now.
1:         // each manager level class and level are 4 bytes long and
1:         // right now 5 are being sent for a total of 20 bytes or 0x14 bytes.
1:         // writeScalarHeader will be called to insert the llcp.
1:         buildMGRLVLLS(targetAgent,
1:                 targetSqlam,
1:                 targetRdb,
1:                 targetSecmgr,
1:                 targetXamgr,
1:                 targetSyncptmgr,
0:                 targetRsyncmgr);
1: 
1: 
1:         // place the server class name into the buffer.
1:         // this value is hard coded for the driver.
1:         buildSRVCLSNM();
1: 
1:         // the excsat command is complete so the updateLengthBytes method
1:         // is called to dynamically compute the length for this command and insert
1:         // it into the buffer
1:         updateLengthBytes();
1:     }
1: 
0:     void buildDummyEXCSAT() throws SqlException {
1:         createCommand();
1: 
1:         // begin excsat collection by placing the 4 byte llcp in the buffer.
1:         // the length of this command will be computed later and "filled in"
1:         // with the call to request.updateLengthBytes().
1:         markLengthBytes(CodePoint.EXCSAT);
1: 
1:         // the excsat command is complete so the updateLengthBytes method
1:         // is called to dynamically compute the length for this command and insert
1:         // it into the buffer
1:         updateLengthBytes();
1:     }
1: 
0:     void buildACCSEC(int secmec,
1:                      String rdbnam,
1:                      byte[] sectkn) throws SqlException {
1:         createCommand();
1: 
1:         // place the llcp for the ACCSEC in the buffer.  save the length bytes for
1:         // later update
1:         markLengthBytes(CodePoint.ACCSEC);
1: 
1:         // the security mechanism is a required instance variable.  it will
1:         // always be sent.
1:         buildSECMEC(secmec);
1: 
1:         // the rdbnam will be built and sent.  different sqlam levels support
1:         // different lengths.  at this point the length has been checked against
1:         // the maximum allowable length.  so write the bytes and padd up to the
1:         // minimum length if needed.
0:         buildRDBNAM(rdbnam);
1: 
1:         if (sectkn != null) {
1:             buildSECTKN(sectkn);
1:         }
1: 
1:         // the accsec command is complete so notify the the request object to
1:         // update the ddm length and the dss header length.
1:         updateLengthBytes();
1:     }
1: 
0:     void buildSECCHK(int secmec,
1:                      String rdbnam,
1:                      String user,
1:                      String password,
1:                      byte[] sectkn,
1:                      byte[] sectkn2) throws SqlException {
1:         createCommand();
1:         markLengthBytes(CodePoint.SECCHK);
1: 
1:         // always send the negotiated security mechanism for the connection.
1:         buildSECMEC(secmec);
1: 
1:         // the rdbnam will be built and sent.  different sqlam levels support
1:         // different lengths.  at this point the length has been checked against
1:         // the maximum allowable length.  so write the bytes and padd up to the
1:         // minimum length if needed.
0:         buildRDBNAM(rdbnam);
1:         if (user != null) {
1:             buildUSRID(user);
1:         }
1:         if (password != null) {
1:             buildPASSWORD(password);
1:         }
1:         if (sectkn != null) {
1:             buildSECTKN(sectkn);
1:         }
1:         if (sectkn2 != null) {
1:             buildSECTKN(sectkn2);
1:         }
1:         updateLengthBytes();
1: 
1:     }
1: 
1:     // The Access RDB (ACCRDB) command makes a named relational database (RDB)
1:     // available to a requester by creating an instance of an SQL application
1:     // manager.  The access RDB command then binds the created instance to the target
1:     // agent and to the RDB. The RDB remains available (accessed) until
1:     // the communications conversation is terminate.
0:     void buildACCRDB(String rdbnam,
1:                      boolean readOnly,
1:                      byte[] crrtkn,
1:                      byte[] prddta,
1:                      Typdef typdef) throws SqlException {
1:         createCommand();
1: 
1:         markLengthBytes(CodePoint.ACCRDB);
1: 
1:         // the relational database name specifies the name of the rdb to
1:         // be accessed.  this can be different sizes depending on the level of
1:         // support.  the size will have ben previously checked so at this point just
1:         // write the data and pad with the correct number of bytes as needed.
1:         // this instance variable is always required.
0:         buildRDBNAM(rdbnam);
1: 
1:         // the rdb access manager class specifies an instance of the SQLAM
1:         // that accesses the RDB.  the sqlam manager class codepoint
1:         // is always used/required for this.  this instance variable
1:         // is always required.
1:         buildRDBACCCL();
1: 
1:         // product specific identifier specifies the product release level
1:         // of this driver.  see the hard coded value in the NetConfiguration class.
1:         // this instance variable is always required.
1:         buildPRDID();
1: 
1:         // product specific data.  this is an optional parameter which carries
1:         // product specific information.  although it is optional, it will be
1:         // sent to the server.  use the first byte to determine the number
1:         // of the prddta bytes to write to the buffer. note: this length
1:         // doesn't include itself so increment by it by 1 to get the actual
1:         // length of this data.
1:         buildPRDDTA(prddta);
1: 
1: 
1:         // the typdefnam parameter specifies the name of the data type to data representation
1:         // mappings used when this driver sends command data objects.
1:         buildTYPDEFNAM(typdef.getTypdefnam());
1: 
1:         if (crrtkn == null) {
1:             netAgent_.netConnection_.constructCrrtkn();
1:         }
1: 
1:         buildCRRTKN(netAgent_.netConnection_.crrtkn_);
1: 
1:         // This specifies the single-byte, double-byte
1:         // and mixed-byte CCSIDs of the Scalar Data Arrays (SDAs) in the identified
1:         // data type to the data representation mapping definitions.  This can
1:         // contain 3 CCSIDs.  The driver will only send the ones which were set.
1:         buildTYPDEFOVR(typdef.isCcsidSbcSet(),
1:                 typdef.getCcsidSbc(),
1:                 typdef.isCcsidDbcSet(),
1:                 typdef.getCcsidDbc(),
1:                 typdef.isCcsidMbcSet(),
1:                 typdef.getCcsidMbc());
1: 
1:         // RDB allow update is an optional parameter which indicates
1:         // whether the RDB allows the requester to perform update operations
1:         // in the RDB.  If update operations are not allowed, this connection
1:         // is limited to read-only access of the RDB resources.
1:         buildRDBALWUPD(readOnly);
1: 
1: 
1: 
1:         // the Statement Decimal Delimiter (STTDECDEL),
1:         // Statement String Delimiter (STTSTRDEL),
1:         // and Target Default Value Return (TRGDFTRT) are all optional
1:         // instance variables which will not be sent to the server.
1: 
1:         // the command and the dss are complete so make the call to notify
1:         // the request object.
1:         updateLengthBytes();
1:     }
1: 
1: 
1:     void buildSYNCCTLMigrate() throws SqlException {
1:     }
1: 
1:     void buildSYNCCTLCommit(int xaFlags, Xid xid) throws SqlException {
1:     }
1: 
1:     void buildSYNCCTLRollback(int xaFlags) throws SqlException {
1:     }
1: 
1: 
1:     // The External Name is the name of the job, task, or process on a
1:     // system for which a DDM server is active.
1:     private void buildEXTNAM(String extnam) throws SqlException {
0:         int extnamTruncateLength = Utils.min(extnam.length(),
1:                 NetConfiguration.EXTNAM_MAXSIZE);
1: 
0:         writeScalarString(CodePoint.EXTNAM,
0:                 extnam.substring(0, extnamTruncateLength));
1:     }
1: 
1:     // Server Name is the name of the DDM server.
1:     private void buildSRVNAM(String srvnam) throws SqlException {
0:         int srvnamTruncateLength = Utils.min(srvnam.length(),
1:                 NetConfiguration.SRVNAM_MAXSIZE);
0:         writeScalarString(CodePoint.SRVNAM,
0:                 srvnam.substring(0, srvnamTruncateLength));
1:     }
1: 
1:     // Server Product Release Level String specifies the product
1:     // release level of a DDM server.
1:     private void buildSRVRLSLV() throws SqlException {
1:         // Hard-coded to ClientDNC 1.0 for dnc 1.0.
1:         writeScalarString(CodePoint.SRVRLSLV, NetConfiguration.SRVRLSLV);
1:     }
1: 
1:     private void buildSRVCLSNM() throws SqlException {
1:         // Server class name is hard-coded to QDERBY/JVM for dnc.
1:         writeScalarString(CodePoint.SRVCLSNM, NetConfiguration.SRVCLSNM_JVM);
1:     }
1: 
1:     // Precondition: valid secmec is assumed.
1:     private void buildSECMEC(int secmec) throws SqlException {
1:         writeScalar2Bytes(CodePoint.SECMEC, secmec);
1:     }
1: 
0:     // Relational Database Name specifies the name of a relational database
0:     // of the server.
0:     // if length of RDB name <= 18 characters, there is not change to the format
0:     // of the RDB name.  The length of the RDBNAM remains fixed at 18 which includes
0:     // any right bland padding if necessary.
0:     // if length of the RDB name is > 18 characters, the length of the RDB name is
0:     // identical to the length of the RDB name.  No right blank padding is required.
0:     private void buildRDBNAM(String rdbnam) throws SqlException {
1:         // since this gets built more than once on the connect flow,
1:         // see if we can optimize
1: 
0:         int rdbnamLength = rdbnam.length();
0:         if (rdbnamLength <= NetConfiguration.PKG_IDENTIFIER_FIXED_LEN) {
0:             writeScalarPaddedString(CodePoint.RDBNAM,
0:                     rdbnam,
0:                     NetConfiguration.PKG_IDENTIFIER_FIXED_LEN);  // minimum length of RDBNAM
0:         } else {
0:             if (rdbnamLength <= NetConfiguration.PKG_IDENTIFIER_MAX_LEN) {
0:                 writeScalarString(CodePoint.RDBNAM, rdbnam);
0:             } else {
0:                 throw new SqlException(netAgent_.logWriter_, "Length of the Relational Database Name, " +
0:                         rdbnam +
0:                         ", exceeds maximum size allowed for PROTOCOL Connection.");// +
1:             }
0:             //"at SQLAM level " + netAgent_.targetSqlam_);
1:         }
1:     }
1: 
1:     private void buildSECTKN(byte[] sectkn) throws SqlException {
1:         if (sectkn.length > NetConfiguration.SECTKN_MAXSIZE) {
0:             throw new SqlException(netAgent_.logWriter_, "bug check: sectkn too long");
1:         }
1:         writeScalarBytes(CodePoint.SECTKN, sectkn);
1:     }
1: 
1:     private void buildUSRID(String usrid) throws SqlException {
0:         int usridLength = usrid.length();
0:         if ((usridLength == 0) || (usridLength > NetConfiguration.USRID_MAXSIZE)) {
0:             throw new SqlException(netAgent_.logWriter_, "userid length, " + usridLength + ", is not allowed.");
1:         }
1: 
0:         writeScalarString(CodePoint.USRID, usrid);
1:     }
1: 
1:     private void buildPASSWORD(String password) throws SqlException {
1:         int passwordLength = password.length();
0:         if ((passwordLength == 0) || (passwordLength > NetConfiguration.PASSWORD_MAXSIZE)) {
0:             throw new SqlException(netAgent_.logWriter_, "password length, " + passwordLength + ", is not allowed.");
1:         }
1:         if (netAgent_.logWriter_ != null) {
1:             // remember the position of password in order to
1:             // mask it out in trace (see Request.sendBytes()).
1:             passwordIncluded_ = true;
0:             passwordStart_ = offset_ + 4;
0:             passwordLength_ = passwordLength;
1:         }
0:         writeScalarString(CodePoint.PASSWORD, password);
1:     }
1: 
1:     private void buildRDBACCCL() throws SqlException {
1:         writeScalar2Bytes(CodePoint.RDBACCCL, CodePoint.SQLAM);
1:     }
1: 
1: 
1:     private void buildPRDID() throws SqlException {
1:         writeScalarString(CodePoint.PRDID, NetConfiguration.PRDID);  // product id is hard-coded to DNC01000 for dnc 1.0.
1:     }
1: 
1:     private void buildPRDDTA(byte[] prddta) throws SqlException {
1:         int prddtaLength = (prddta[NetConfiguration.PRDDTA_LEN_BYTE] & 0xff) + 1;
1:         writeScalarBytes(CodePoint.PRDDTA, prddta, 0, prddtaLength);
1:     }
1: 
1:     private void buildTYPDEFNAM(String typdefnam) throws SqlException {
1:         writeScalarString(CodePoint.TYPDEFNAM, typdefnam);
1:     }
1: 
0:     void buildTYPDEFOVR(boolean sendCcsidSbc,
1:                         int ccsidSbc,
1:                         boolean sendCcsidDbc,
1:                         int ccsidDbc,
1:                         boolean sendCcsidMbc,
1:                         int ccsidMbc) throws SqlException {
1:         markLengthBytes(CodePoint.TYPDEFOVR);
1:         // write the single-byte ccsid used by this driver.
1:         if (sendCcsidSbc) {
1:             writeScalar2Bytes(CodePoint.CCSIDSBC, ccsidSbc);
1:         }
1: 
1:         // write the double-byte ccsid used by this driver.
1:         if (sendCcsidDbc) {
1:             writeScalar2Bytes(CodePoint.CCSIDDBC, ccsidDbc);
1:         }
1: 
1:         // write the mixed-byte ccsid used by this driver
1:         if (sendCcsidMbc) {
1:             writeScalar2Bytes(CodePoint.CCSIDMBC, ccsidMbc);
1:         }
1: 
1:         updateLengthBytes();
1: 
1:     }
1: 
1:     private void buildMGRLVLLS(int agent,
1:                                int sqlam,
1:                                int rdb,
1:                                int secmgr,
1:                                int xamgr,
1:                                int syncptmgr,
0:                                int rsyncmgr) throws SqlException {
1:         markLengthBytes(CodePoint.MGRLVLLS);
1: 
1:         // place the managers and their levels in the buffer
1:         writeCodePoint4Bytes(CodePoint.AGENT, agent);
1:         writeCodePoint4Bytes(CodePoint.SQLAM, sqlam);
1:         writeCodePoint4Bytes(CodePoint.RDB, rdb);
1:         writeCodePoint4Bytes(CodePoint.SECMGR, secmgr);
1: 
1:         if (netAgent_.netConnection_.isXAConnection()) {
1:             if (xamgr != NetConfiguration.MGRLVL_NA) {
1:                 writeCodePoint4Bytes(CodePoint.XAMGR, xamgr);
1:             }
1:             if (syncptmgr != NetConfiguration.MGRLVL_NA) {
1:                 writeCodePoint4Bytes(CodePoint.SYNCPTMGR, syncptmgr);
1:             }
1:             if (rsyncmgr != NetConfiguration.MGRLVL_NA) {
1:                 writeCodePoint4Bytes(CodePoint.RSYNCMGR, rsyncmgr);
1:             }
1:         }
1:         updateLengthBytes();
1:     }
1: 
1:     private void buildCRRTKN(byte[] crrtkn) throws SqlException {
1:         writeScalarBytes(CodePoint.CRRTKN, crrtkn);
1:     }
1: 
1:     private void buildRDBALWUPD(boolean readOnly) throws SqlException {
1:         if (readOnly) {
1:             writeScalar1Byte(CodePoint.RDBALWUPD, CodePoint.FALSE);
1:         }
1:     }
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:33776ff
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derby.client.net.NetConnectionRequest
1: 
0:    Copyright (c) 2001, 2005 The Apache Software Foundation or its licensors, where applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1: */
1: 
1: package org.apache.derby.client.net;
1: 
1: 
0: import org.apache.derby.client.am.SqlException;
0: import org.apache.derby.client.am.Utils;
1: import javax.transaction.xa.Xid;
1: 
0: public class NetConnectionRequest extends Request implements ConnectionRequestInterface
0: {
0:   NetConnectionRequest (NetAgent netAgent, CcsidManager ccsidManager, int bufferSize)
0:   {
0:     super (netAgent, ccsidManager, bufferSize);
0:   }
0:   //----------------------------- entry points ---------------------------------
1: 
0:   void writeExchangeServerAttributes (String externalName,
0:                                       int targetAgent,
0:                                       int targetSqlam,
0:                                       int targetRdb,
0:                                       int targetSecmgr,
0:                                       int targetCmntcpip,
0:                                       int targetCmnappc,
0:                                       int targetXamgr,
0:                                       int targetSyncptmgr,
0:                                       int targetRsyncmgr) throws SqlException
0:   {
0:     // send the exchange server attributes command to the server.
0:     // no other commands will be chained to the excsat because
0:     // the manager levels are needed before anything else is attempted.
0:     buildEXCSAT (externalName,
0:                  targetAgent,
0:                  targetSqlam,
0:                  targetRdb,
0:                  targetSecmgr,
0:                  targetCmntcpip,
0:                  targetCmnappc,
0:                  targetXamgr,
0:                  targetSyncptmgr,
0:                  targetRsyncmgr);
1: 
0:   }
1: 
0:   void writeDummyExchangeServerAttributes () throws SqlException
0:   {
0:     // send the exchange server attributes command to the server,
0:     // without any parameters
0:     buildDummyEXCSAT ();
0:   }
1: 
0:   void writeAccessSecurity (int securityMechanism,
1:                             String databaseName,
0:                             byte[] publicKey) throws SqlException
0:   {
0:     buildACCSEC (securityMechanism, databaseName, publicKey);
0:   }
1: 
0:   void writeSecurityCheck (int securityMechanism,
1:                            String databaseName,
0:                            String userid,
0:                            String password,
0:                            byte[] encryptedUserid,
0:                            byte[] encryptedPassword) throws SqlException
1: 
1: 
0:   {
0:     buildSECCHK (securityMechanism,
0:                  databaseName,
0:                  userid,
0:                  password,
0:                  encryptedUserid,
0:                  encryptedPassword);
0:   }
1: 
0:   void writeAccessDatabase (String rdbnam,
0:                             boolean readOnly,
0:                             byte[] correlationToken,
0:                             byte[] productData,
0:                             Typdef typdef) throws SqlException
0:   {
0:     buildACCRDB (rdbnam,
0:                  readOnly,
0:                  correlationToken,
0:                  productData,
0:                  typdef);
0:   }
1: 
1: 
1: 
0:   public void writeCommitSubstitute (NetConnection connection) throws SqlException
0:   {
0:     buildDummyEXCSAT();
0:   }
1: 
0:   public void writeLocalCommit (NetConnection connection) throws SqlException
0:   {
0:     buildRDBCMM ();
0:   }
1: 
0:   public void writeLocalRollback (NetConnection connection) throws SqlException
0:   {
0:     buildRDBRLLBCK ();
0:   }
1: 
0:   public void writeLocalXAStart(NetConnection connection) throws SqlException
0:   {
0:   }
1: 
1: 
0:   //Build the SYNNCTL commit command
0:   public void writeLocalXACommit (NetConnection conn) throws SqlException
0:   {
0:   }
1: 
0:   //Build the SYNNCTL rollback command
0:   public void writeLocalXARollback (NetConnection conn) throws SqlException
0:   {
0:   }
1: 
0:   public void writeXaStartUnitOfWork(NetConnection conn) throws SqlException
0:       {
0:   }
1: 
0:   public void writeXaEndUnitOfWork(NetConnection conn) throws SqlException
0:       {
0:   }
1: 
0:  protected void writeXaPrepare(NetConnection conn) throws SqlException
0:   {
0:   }
1: 
0:  protected void writeXaCommit(NetConnection conn, Xid xid) throws SqlException
0:   {
0:  }
1: 
0:  protected void writeXaRollback(NetConnection conn, Xid xid) throws SqlException
0:  {
0:  }
1: 
0:  protected void writeXaRecover(NetConnection conn, int flag) throws SqlException
0:  {
0:  }
1: 
0:  protected void writeXaForget(NetConnection conn, Xid xid) throws SqlException
0:  {
0:  }
1: 
0:   public void writeSYNCType(int codepoint, int syncType)
0:   {
0:     writeScalar1Byte (codepoint, syncType);
0:   }
1: 
0:   public void writeForget(int codepoint, int value)
0:   {
0:   }
1: 
0:   public void writeReleaseConversation(int codepoint, int value)
0:   {
0:   }
1: 
0:   void writeNullXID(int codepoint)
0:   {
0:   }
1: 
0:   void writeXID(int codepoint, Xid xid) throws SqlException
0:   {
0:   }
1: 
1: 
0:   void writeXAFlags(int codepoint, int xaFlags)
0:   {
0:   }
1: 
1: 
0:   //----------------------helper methods----------------------------------------
0:   // These methods are "private protected", which is not a recognized java privilege,
0:   // but means that these methods are private to this class and to subclasses,
0:   // and should not be used as package-wide friendly methods.
1: 
0:   // RDB Commit Unit of Work (RDBCMM) Command commits all work performed
0:   // for the current unit of work.
0:   //
0:   // The Relational Database Name (RDBNAM) is an optional parameter
0:   // which will not be sent by this command to reduce size, building,
0:   // and parsing.
0:   void buildRDBCMM () throws SqlException
0:   {
0:     createCommand ();
0:     writeLengthCodePoint (0x04, CodePoint.RDBCMM);
0:   }
1: 
0:   // RDB Rollback Unit of Work(RDBRLLBCK) Command rolls back
0:   // all work performed for the current unit of work.
0:   //
0:   // The Relational Database Name (RDBNAM) is an optional parameter
0:   // which will not be sent by this command to reduce size, building,
0:   // and parsing.
0:   void buildRDBRLLBCK () throws SqlException
0:   {
0:     createCommand ();
0:     writeLengthCodePoint (0x04, CodePoint.RDBRLLBCK);
0:   }
1: 
0:   // build the Exchange Server Attributes Command.
0:   // This command sends the following information to the server.
0:   // - this driver's server class name
0:   // - this driver's level of each of the manager's it supports
0:   // - this driver's product release level
0:   // - this driver's external name
0:   // - this driver's server name
0:   void buildEXCSAT (String externalName,
0:                     int targetAgent,
0:                     int targetSqlam,
0:                     int targetRdb,
0:                     int targetSecmgr,
0:                     int targetCmntcpip,
0:                     int targetCmnappc,
0:                     int targetXamgr,
0:                     int targetSyncptmgr,
0:                     int targetRsyncmgr) throws SqlException
0:   {
0:     createCommand ();
1: 
0:     // begin excsat collection by placing the 4 byte llcp in the buffer.
0:     // the length of this command will be computed later and "filled in"
0:     // with the call to request.updateLengthBytes().
0:     markLengthBytes (CodePoint.EXCSAT);
1: 
0:     // place the external name for the client into the buffer.
0:     // the external name was previously calculated before the call to this method.
0:     buildEXTNAM (externalName); 
1: 
0:     // place the server name for the client into the buffer.
0:     buildSRVNAM ("Derby");
1: 
0:     // place the server release level for the client into the buffer.
0:     // this is a hard coded value for the driver.
0:     buildSRVRLSLV();
1: 
0:     // the managers supported by this driver and their levels will
0:     // be sent to the server.  the variables which store these values
0:     // were initialized during object constrcution to the highest values
0:     // supported by the driver.
1: 
0:     // for the case of the manager levels object, there is no
0:     // need to have the length of the ddm object dynamically calculated
0:     // because this method knows exactly how many will be sent and can set
0:     // this now.
0:     // each manager level class and level are 4 bytes long and
0:     // right now 5 are being sent for a total of 20 bytes or 0x14 bytes.
0:     // writeScalarHeader will be called to insert the llcp.
0:     buildMGRLVLLS (targetAgent,
0:                    targetSqlam,
0:                    targetRdb,
0:                    targetSecmgr,
0:                    targetXamgr,
0:                    targetSyncptmgr,
0:                    targetRsyncmgr);
1: 
1: 
0:     // place the server class name into the buffer.
0:     // this value is hard coded for the driver.
0:     buildSRVCLSNM();
1: 
0:     // the excsat command is complete so the updateLengthBytes method
0:     // is called to dynamically compute the length for this command and insert
0:     // it into the buffer
0:     updateLengthBytes();
0:   }
1: 
0:   void buildDummyEXCSAT () throws SqlException
0:   {
0:     createCommand ();
1: 
0:     // begin excsat collection by placing the 4 byte llcp in the buffer.
0:     // the length of this command will be computed later and "filled in"
0:     // with the call to request.updateLengthBytes().
0:     markLengthBytes (CodePoint.EXCSAT);
1: 
0:     // the excsat command is complete so the updateLengthBytes method
0:     // is called to dynamically compute the length for this command and insert
0:     // it into the buffer
0:     updateLengthBytes();
0:   }
1: 
0:   void buildACCSEC (int secmec,
0:                     String rdbnam,
0:                     byte[] sectkn) throws SqlException
0:   {
0:     createCommand ();
1: 
0:     // place the llcp for the ACCSEC in the buffer.  save the length bytes for
0:     // later update
0:     markLengthBytes (CodePoint.ACCSEC);
1: 
0:     // the security mechanism is a required instance variable.  it will
0:     // always be sent.
0:     buildSECMEC (secmec);
1: 
0:     // the rdbnam will be built and sent.  different sqlam levels support
0:     // different lengths.  at this point the length has been checked against
0:     // the maximum allowable length.  so write the bytes and padd up to the
0:     // minimum length if needed.
0:     buildRDBNAM (rdbnam);
1: 
0:     if (sectkn != null) buildSECTKN (sectkn);
1: 
0:     // the accsec command is complete so notify the the request object to
0:     // update the ddm length and the dss header length.
0:     updateLengthBytes();
0:   }
1: 
0:   void buildSECCHK (int secmec,
0:                     String rdbnam,
0:                     String user,
0:                     String password,
0:                     byte[] sectkn,
0:                     byte[] sectkn2) throws SqlException
0:   {
0:     createCommand ();
0:     markLengthBytes (CodePoint.SECCHK);
1: 
0:     // always send the negotiated security mechanism for the connection.
0:     buildSECMEC (secmec);
1: 
0:     // the rdbnam will be built and sent.  different sqlam levels support
0:     // different lengths.  at this point the length has been checked against
0:     // the maximum allowable length.  so write the bytes and padd up to the
0:     // minimum length if needed.
0:     buildRDBNAM (rdbnam);
0:     if (user != null ) buildUSRID (user);
0:     if (password != null ) buildPASSWORD (password);
0:     if (sectkn != null) buildSECTKN (sectkn);
0:     if (sectkn2 != null) buildSECTKN (sectkn2);
0:     updateLengthBytes();
1: 
0:   }
1: 
0:   // The Access RDB (ACCRDB) command makes a named relational database (RDB)
0:   // available to a requester by creating an instance of an SQL application
0:   // manager.  The access RDB command then binds the created instance to the target
0:   // agent and to the RDB. The RDB remains available (accessed) until
0:   // the communications conversation is terminate.
0:   void buildACCRDB (String rdbnam,
0:                     boolean readOnly,
0:                     byte[] crrtkn,
0:                     byte[] prddta,
0:                     Typdef typdef) throws SqlException
0:   {
0:     createCommand ();
1: 
0:     markLengthBytes (CodePoint.ACCRDB);
1: 
0:     // the relational database name specifies the name of the rdb to
0:     // be accessed.  this can be different sizes depending on the level of
0:     // support.  the size will have ben previously checked so at this point just
0:     // write the data and pad with the correct number of bytes as needed.
0:     // this instance variable is always required.
0:     buildRDBNAM (rdbnam);
1: 
0:     // the rdb access manager class specifies an instance of the SQLAM
0:     // that accesses the RDB.  the sqlam manager class codepoint
0:     // is always used/required for this.  this instance variable
0:     // is always required.
0:     buildRDBACCCL();
1: 
0:     // product specific identifier specifies the product release level
0:     // of this driver.  see the hard coded value in the NetConfiguration class.
0:     // this instance variable is always required.
0:     buildPRDID();
1: 
0:     // product specific data.  this is an optional parameter which carries
0:     // product specific information.  although it is optional, it will be
0:     // sent to the server.  use the first byte to determine the number
0:     // of the prddta bytes to write to the buffer. note: this length
0:     // doesn't include itself so increment by it by 1 to get the actual
0:     // length of this data.
0:     buildPRDDTA (prddta);
1: 
1: 
0:     // the typdefnam parameter specifies the name of the data type to data representation
0:     // mappings used when this driver sends command data objects.
0:     buildTYPDEFNAM (typdef.getTypdefnam());
1: 
0: 	if (crrtkn == null)
0:         netAgent_.netConnection_.constructCrrtkn();
1: 	
0: 	buildCRRTKN(netAgent_.netConnection_.crrtkn_);
1: 
0:     // This specifies the single-byte, double-byte
0:     // and mixed-byte CCSIDs of the Scalar Data Arrays (SDAs) in the identified
0:     // data type to the data representation mapping definitions.  This can
0:     // contain 3 CCSIDs.  The driver will only send the ones which were set.
0:     buildTYPDEFOVR (typdef.isCcsidSbcSet(),
0:                     typdef.getCcsidSbc(),
0:                     typdef.isCcsidDbcSet(),
0:                     typdef.getCcsidDbc(),
0:                     typdef.isCcsidMbcSet(),
0:                     typdef.getCcsidMbc());
1: 
0:     // RDB allow update is an optional parameter which indicates
0:     // whether the RDB allows the requester to perform update operations
0:     // in the RDB.  If update operations are not allowed, this connection
0:     // is limited to read-only access of the RDB resources.
0:     buildRDBALWUPD (readOnly);
1: 
1: 
1: 
0:     // the Statement Decimal Delimiter (STTDECDEL),
0:     // Statement String Delimiter (STTSTRDEL),
0:     // and Target Default Value Return (TRGDFTRT) are all optional
0:     // instance variables which will not be sent to the server.
1: 
0:     // the command and the dss are complete so make the call to notify
0:     // the request object.
0:     updateLengthBytes();
0:   }
1: 
1: 
0:   void buildSYNCCTLMigrate() throws SqlException
0:   {
0:   }
1: 
0:   void buildSYNCCTLCommit (int xaFlags, Xid xid) throws SqlException
0:   {
0:   }
1: 
0:   void buildSYNCCTLRollback (int xaFlags) throws SqlException
0:   {
0:   }
1: 
1: 
0:   // The External Name is the name of the job, task, or process on a
0:   // system for which a DDM server is active.
0:   private void buildEXTNAM (String extnam) throws SqlException
0:   {
0:     int extnamTruncateLength = Utils.min (extnam.length(),
0:                                           NetConfiguration.EXTNAM_MAXSIZE);
1: 
0:     writeScalarString (CodePoint.EXTNAM,
0:                        extnam.substring (0, extnamTruncateLength));
0:   }
1: 
0:   // Server Name is the name of the DDM server.
0:   private void buildSRVNAM (String srvnam) throws SqlException
0:   {
0:     int srvnamTruncateLength = Utils.min (srvnam.length(),
0:                                           NetConfiguration.SRVNAM_MAXSIZE);
0:     writeScalarString (CodePoint.SRVNAM,
0:                        srvnam.substring (0,srvnamTruncateLength));
0:   }
1: 
0:   // Server Product Release Level String specifies the product
0:   // release level of a DDM server.
0:   private void buildSRVRLSLV () throws SqlException
0:   {
0:     // Hard-coded to ClientDNC 1.0 for dnc 1.0.
0:     writeScalarString (CodePoint.SRVRLSLV, NetConfiguration.SRVRLSLV);
0:   }
1: 
0:   private void buildSRVCLSNM () throws SqlException
0:   {
0:     // Server class name is hard-coded to QDERBY/JVM for dnc.
0:     writeScalarString (CodePoint.SRVCLSNM, NetConfiguration.SRVCLSNM_JVM);
0:   }
1: 
0:   // Precondition: valid secmec is assumed.
0:   private void buildSECMEC (int secmec) throws SqlException
0:   {
0:     writeScalar2Bytes (CodePoint.SECMEC, secmec);
0:   }
1: 
0:   // Relational Database Name specifies the name of a relational database
0:   // of the server.
0:   // if length of RDB name <= 18 characters, there is not change to the format
0:   // of the RDB name.  The length of the RDBNAM remains fixed at 18 which includes
0:   // any right bland padding if necessary.
0:   // if length of the RDB name is > 18 characters, the length of the RDB name is
0:   // identical to the length of the RDB name.  No right blank padding is required.
0:   private void buildRDBNAM (String rdbnam) throws SqlException
0:   {
0:     // since this gets built more than once on the connect flow,
0:    // see if we can optimize
1: 
0:     int rdbnamLength = rdbnam.length();
0:     if (rdbnamLength <= NetConfiguration.PKG_IDENTIFIER_FIXED_LEN ) {
0:       writeScalarPaddedString (CodePoint.RDBNAM,
0:                                rdbnam,
0:                                NetConfiguration.PKG_IDENTIFIER_FIXED_LEN);  // minimum length of RDBNAM
0:     }
0:     else {
0:       if (rdbnamLength <= NetConfiguration.PKG_IDENTIFIER_MAX_LEN)
0:         writeScalarString (CodePoint.RDBNAM, rdbnam);
0:       else
0:         throw new SqlException (netAgent_.logWriter_, "Length of the Relational Database Name, " +
0:                                rdbnam +
0:                              ", exceeds maximum size allowed for PROTOCOL Connection.");// +
0:                              //"at SQLAM level " + netAgent_.targetSqlam_);
0:     }
0:   }
1: 
0:   private void buildSECTKN (byte[] sectkn) throws SqlException
0:   {
0:     if (sectkn.length > NetConfiguration.SECTKN_MAXSIZE)
0:       throw new SqlException (netAgent_.logWriter_, "bug check: sectkn too long");
0:     writeScalarBytes (CodePoint.SECTKN, sectkn);
0:   }
1: 
0:   private void buildUSRID (String usrid) throws SqlException
0:   {
0:     int usridLength = usrid.length();
0:     if ((usridLength == 0) || (usridLength > NetConfiguration.USRID_MAXSIZE))
0:       throw new SqlException (netAgent_.logWriter_, "userid length, " + usridLength + ", is not allowed.");
1: 
0:     writeScalarString (CodePoint.USRID, usrid);
0:   }
1: 
0:   private void buildPASSWORD (String password) throws SqlException
0:   {
0:     int passwordLength = password.length();
0:     if ((passwordLength == 0) || (passwordLength > NetConfiguration.PASSWORD_MAXSIZE))
0:       throw new SqlException (netAgent_.logWriter_, "password length, " + passwordLength + ", is not allowed.");
0:     if (netAgent_.logWriter_ != null) {
0:       // remember the position of password in order to
0:       // mask it out in trace (see Request.sendBytes()).
0:       passwordIncluded_ = true;
0:       passwordStart_ = offset_ + 4;
0:       passwordLength_ = passwordLength;
0:     }
0:     writeScalarString (CodePoint.PASSWORD, password);
0:   }
1: 
0:   private void buildRDBACCCL() throws SqlException
0:   {
0:     writeScalar2Bytes (CodePoint.RDBACCCL, CodePoint.SQLAM);
0:   }
1: 
1: 
0:   private void buildPRDID () throws SqlException
0:   {
0:     writeScalarString (CodePoint.PRDID, NetConfiguration.PRDID);  // product id is hard-coded to DNC01000 for dnc 1.0.
0:   }
1: 
0:   private void buildPRDDTA (byte[] prddta) throws SqlException
0:   {
0:     int prddtaLength = (prddta[NetConfiguration.PRDDTA_LEN_BYTE] & 0xff) + 1;
0:     writeScalarBytes (CodePoint.PRDDTA, prddta, 0, prddtaLength);
0:   }
1: 
0:   private void buildTYPDEFNAM (String typdefnam) throws SqlException
0:   {
0:     writeScalarString (CodePoint.TYPDEFNAM, typdefnam);
0:   }
1: 
0:   void buildTYPDEFOVR (boolean sendCcsidSbc,
0:                                int ccsidSbc,
0:                                boolean sendCcsidDbc,
0:                                int ccsidDbc,
0:                                boolean sendCcsidMbc,
0:                                int ccsidMbc
0:                                ) throws SqlException
0:   {
0:     markLengthBytes (CodePoint.TYPDEFOVR);
0:     // write the single-byte ccsid used by this driver.
0:     if (sendCcsidSbc) writeScalar2Bytes (CodePoint.CCSIDSBC, ccsidSbc);
1: 
0:     // write the double-byte ccsid used by this driver.
0:     if (sendCcsidDbc) writeScalar2Bytes (CodePoint.CCSIDDBC, ccsidDbc);
1: 
0:     // write the mixed-byte ccsid used by this driver
0:     if (sendCcsidMbc) writeScalar2Bytes (CodePoint.CCSIDMBC, ccsidMbc);
1: 
0:     updateLengthBytes();
1: 
0:   }
1: 
0:   private void buildMGRLVLLS (int agent,
0:                               int sqlam,
0:                               int rdb,
0:                               int secmgr,
0:                               int xamgr,
0:                               int syncptmgr,
0:                               int rsyncmgr) throws SqlException
1: 
0:   {
0:     markLengthBytes(CodePoint.MGRLVLLS);
1: 
0:     // place the managers and their levels in the buffer
0:     writeCodePoint4Bytes (CodePoint.AGENT, agent);
0:     writeCodePoint4Bytes (CodePoint.SQLAM, sqlam);
0:     writeCodePoint4Bytes (CodePoint.RDB, rdb);
0:     writeCodePoint4Bytes (CodePoint.SECMGR, secmgr);
1: 
0:     if (netAgent_.netConnection_.isXAConnection())
0:     {
0:       if (xamgr != NetConfiguration.MGRLVL_NA) writeCodePoint4Bytes (CodePoint.XAMGR, xamgr);
0:       if (syncptmgr != NetConfiguration.MGRLVL_NA) writeCodePoint4Bytes (CodePoint.SYNCPTMGR, syncptmgr);
0:       if (rsyncmgr != NetConfiguration.MGRLVL_NA) writeCodePoint4Bytes (CodePoint.RSYNCMGR, rsyncmgr);
0:     }
0:     updateLengthBytes();
0:   }
1: 
0:   private void buildCRRTKN (byte[] crrtkn) throws SqlException
0:   {
0:     writeScalarBytes (CodePoint.CRRTKN, crrtkn);
0:   }
1: 
0:   private void buildRDBALWUPD (boolean readOnly) throws SqlException
0:   {
0:     if (readOnly) writeScalar1Byte (CodePoint.RDBALWUPD, CodePoint.FALSE);
0:   }
1: 
0: }
1: 
1: 
1: 
============================================================================