1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.conn.GenericStatementContext
1:345de35: 
1:575d6a1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:575d6a1:    contributor license agreements.  See the NOTICE file distributed with
1:575d6a1:    this work for additional information regarding copyright ownership.
1:575d6a1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:575d6a1:    (the "License"); you may not use this file except in compliance with
1:575d6a1:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
7:eac0369: 
4:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.sql.conn;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.context.Context;
1:eac0369: 
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: 
1:3fcea8a: import org.apache.derby.iapi.services.monitor.Monitor;
1:3fcea8a: 
1:3fcea8a: import org.apache.derby.iapi.services.timer.TimerFactory;
1:3fcea8a: 
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1:eac0369: import org.apache.derby.iapi.sql.conn.StatementContext;
1:6950a39: import org.apache.derby.iapi.sql.conn.SQLSessionContext;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.sql.depend.Dependency;
1:eac0369: import org.apache.derby.iapi.sql.depend.DependencyManager;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
1:eac0369: 
1:6950a39: import org.apache.derby.iapi.sql.Activation;
1:eac0369: import org.apache.derby.iapi.sql.ResultSet;
1:eac0369: import org.apache.derby.iapi.sql.ParameterValueSet;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.context.ContextImpl;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.ExceptionSeverity;
1:eac0369: import org.apache.derby.iapi.reference.SQLState;
1:eac0369: import java.util.ArrayList;
1:eac0369: import java.util.Iterator;
1:3fcea8a: import java.util.TimerTask;
1:eac0369: 
1:3fcea8a: /**
1:eac0369:  * GenericStatementContext is pushed/popped around a statement prepare and execute
1:eac0369:  * so that any statement specific clean up can be performed.
1:98d82d9:  *
3:eac0369:  *
1:98d82d9:  */
1:eac0369: final class GenericStatementContext 
1:eac0369: 	extends ContextImpl implements StatementContext
1:eac0369: {
1:eac0369: 	private boolean		setSavePoint;
1:eac0369: 	private String		internalSavePointName;
1:eac0369: 	private ResultSet	topResultSet;
1:274c5ba: 	private ArrayList<Dependency>		dependencies;
1:eac0369: 	private NoPutResultSet[] subqueryTrackingArray;
1:eac0369: 	private NoPutResultSet[] materializedSubqueries;
1:eac0369: 	private	final LanguageConnectionContext lcc;
1:eac0369: 	private boolean		inUse = true;
1:3fcea8a: 
1:3fcea8a:     // This flag satisfies all the conditions
1:3fcea8a:     // for using volatile instead of synchronized.
1:3fcea8a:     // (Source: Doug Lea, Concurrent Programming in Java, Second Edition,
1:3fcea8a:     // section 2.2.7.4, page 97)
1:3fcea8a:     // true if statement has been cancelled
1:3fcea8a:     private volatile boolean cancellationFlag = false;
1:3fcea8a: 
1:3fcea8a:     // Reference to the TimerTask that will time out this statement.
1:3fcea8a:     // Needed for stopping the task when execution completes before timeout.
1:3fcea8a:     private CancelQueryTask cancelTask = null;
1:3fcea8a:         
1:eac0369:     private	boolean		parentInTrigger;	// whetherparent started with a trigger on stack
1:5087be8:     private	boolean		isForReadOnly = false;	
1:eac0369:     private	boolean		isAtomic;	
1:eac0369: 	private boolean		isSystemCode;
1:eac0369: 	private boolean		rollbackParentContext;
1:b4885a6:     private boolean     statementWasInvalidated;
1:eac0369:     private	String		stmtText;
1:eac0369:     private	ParameterValueSet			pvs;
1:eac0369: 
3:eac0369: 	/**
1:eac0369: 		Set to one of RoutineAliasInfo.{MODIFIES_SQL_DATA, READS_SQL_DATA, CONTAINS_SQL, NO_SQL}
1:eac0369: 	*/
1:eac0369: 	private short			sqlAllowed = -1;
1:98d82d9: 
1:6950a39: 	/**
1:6950a39: 	 * The activation associated with this context, or null
1:6950a39: 	 */
1:6950a39: 	private Activation activation;
1:6950a39: 
1:6950a39: 	/**
1:6950a39: 	 * The SQLSessionContext associated with a statement context.
1:6950a39: 	 */
1:6950a39: 	private SQLSessionContext sqlSessionContext;
1:6950a39: 
1:eac0369: 	/*
1:eac0369: 	   constructor
1:eac0369: 		@param tc transaction
1:eac0369: 	*/
1:95031f0: 	GenericStatementContext(LanguageConnectionContext lcc) 
1:eac0369: 	{
1:eac0369: 		super(lcc.getContextManager(), org.apache.derby.iapi.reference.ContextId.LANG_STATEMENT);
1:eac0369: 		this.lcc = lcc;
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT((lcc != null),
1:eac0369: 					"Failed to get language connection context");
3:eac0369: 		}
1:98d82d9: 
1:3c099fa:         internalSavePointName = lcc.getUniqueSavepointName();
1:98d82d9: 	}
1:eac0369: 
1:98d82d9:     /**
1:3fcea8a:      * This is a TimerTask that is responsible for timing out statements,
1:3fcea8a:      * typically when an application has called Statement.setQueryTimeout().
1:3fcea8a:      *
1:3fcea8a:      * When the application invokes execute() on a statement object, or
1:3fcea8a:      * fetches data on a ResultSet, a StatementContext object is allocated
1:3fcea8a:      * for the duration of the execution in the engine (until control is
1:3fcea8a:      * returned to the application).
1:3fcea8a:      *
1:3fcea8a:      * When the StatementContext object is assigned with setInUse(),
1:dbed020:      * a CancelQueryTask is scheduled if a timeout &gt; 0 has been set.
1:3fcea8a:      */
1:3fcea8a:     private static class CancelQueryTask
1:3fcea8a:         extends
1:3fcea8a:             TimerTask
1:3fcea8a:     {
1:3fcea8a:         /**
1:3fcea8a:          * Reference to the StatementContext for the executing statement
1:3fcea8a:          * which might time out.
1:3fcea8a:          */
1:3fcea8a:         private StatementContext statementContext;
1:3fcea8a: 
1:3fcea8a:         /**
1:3fcea8a:          * Initializes a new task for timing out a statement's execution.
1:3fcea8a:          * This does not schedule it for execution, the caller is
1:3fcea8a:          * responsible for calling Timer.schedule() with this object
1:3fcea8a:          * as parameter.
1:3fcea8a:          */
1:3fcea8a:         public CancelQueryTask(StatementContext ctx)
1:3fcea8a:         {
1:3fcea8a:             statementContext = ctx;
1:3fcea8a:         }
1:3fcea8a: 
1:3fcea8a:         /**
1:3fcea8a:          * Invoked by a Timer class to cancel an executing statement.
1:3fcea8a:          * This method just sets a volatile flag in the associated
1:3fcea8a:          * StatementContext object by calling StatementContext.cancel();
1:3fcea8a:          * it is the responsibility of the thread executing the statement
1:3fcea8a:          * to check this flag regularly.
1:3fcea8a:          */
1:3fcea8a:         public void run()
1:3fcea8a:         {
2:3fcea8a:             synchronized (this) {
1:3fcea8a:                 if (statementContext != null) {
1:3fcea8a:                     statementContext.cancel();
1:3fcea8a:                 }
1:3fcea8a:             }
1:3fcea8a:         }
1:3fcea8a: 
1:3fcea8a:         /**
1:3fcea8a:          * Stops this task and prevents it from cancelling a statement.
1:3fcea8a:          * Guarantees that after this method returns, the associated
1:3fcea8a:          * StatementContext object will not be tampered with by this task.
1:3fcea8a:          * Thus, the StatementContext object may safely be allocated to
1:3fcea8a:          * other executing statements.
1:3fcea8a:          */
1:3fcea8a:         public void forgetContext() {
1:1fac3e9:             synchronized (this) {
1:1fac3e9:                 statementContext = null;
1:3fcea8a:             }
1:13673bd:             getTimerFactory().cancel(this);
1:3fcea8a:         }
1:3fcea8a:     }
1:3fcea8a: 
1:13673bd:     private static TimerFactory getTimerFactory() {
1:56c1dc2:         return GenericLanguageConnectionFactory.getMonitor().getTimerFactory();
1:13673bd:     }
1:13673bd: 
1:eac0369: 	// StatementContext Interface
1:eac0369: 
1:eac0369: 	public void setInUse
1:eac0369: 	( 
1:eac0369: 		boolean parentInTrigger,
1:eac0369: 		boolean isAtomic, 
1:5087be8:                 boolean isForReadOnly,
1:eac0369: 		String stmtText,
1:3fcea8a: 		ParameterValueSet pvs,
1:3fcea8a:         long timeoutMillis
1:eac0369: 	) 
1:eac0369: 	{
1:eac0369: 		inUse = true;
1:eac0369: 
1:eac0369: 		this.parentInTrigger = parentInTrigger;
1:5087be8: 		this.isForReadOnly = isForReadOnly;
1:eac0369: 		this.isAtomic = isAtomic;
1:eac0369: 		this.stmtText = stmtText;
1:eac0369: 		this.pvs = pvs;
1:eac0369: 		rollbackParentContext = false;
1:3fcea8a:         if (timeoutMillis > 0) {
1:3fcea8a:             cancelTask = new CancelQueryTask(this);
1:13673bd:             getTimerFactory().schedule(cancelTask, timeoutMillis);
1:3fcea8a:         }
1:3fcea8a: 	}
1:eac0369: 
1:eac0369: 	public void clearInUse() {
1:eac0369: 		/* We must clear out the current top ResultSet to prepare for
1:eac0369: 		 * reusing a StatementContext.
1:eac0369: 		 */
1:eac0369: 		stuffTopResultSet( null, null );
1:eac0369: 		inUse = false;
1:eac0369: 
1:eac0369: 		parentInTrigger = false;
1:eac0369: 		isAtomic = false;
1:5087be8: 		isForReadOnly = false;
1:eac0369: 		this.stmtText = null;
1:eac0369: 		sqlAllowed = -1;
1:eac0369: 		isSystemCode = false;
1:eac0369: 		rollbackParentContext = false;
1:b4885a6:         statementWasInvalidated = false;
1:3fcea8a: 
1:3fcea8a:         if (cancelTask != null) {
1:3fcea8a:             cancelTask.forgetContext();
1:3fcea8a:             cancelTask = null;
1:3fcea8a:         }
1:3fcea8a:         cancellationFlag = false;
1:6950a39:         activation = null;
1:6950a39: 		sqlSessionContext = null;
1:6950a39:     }
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see StatementContext#setSavePoint
1:eac0369: 	 * @exception StandardException Thrown on error
1:eac0369: 	 */
1:eac0369: 	public void setSavePoint() throws StandardException {
1:eac0369: 		
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			if (SanityManager.DEBUG_ON("traceSavepoints"))
1:eac0369: 			{
1:eac0369: 				SanityManager.DEBUG_PRINT(
1:eac0369: 									"GenericStatementContext.setSavePoint()",
1:eac0369: 									internalSavePointName);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 			
1:eac0369: 		pleaseBeOnStack();
1:eac0369: 		
1:eac0369: 
1:95031f0: 		lcc.getTransactionExecute().setSavePoint(internalSavePointName, null);
1:eac0369: 		setSavePoint = true;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Resets the savepoint to the current spot if it is
1:eac0369: 	 * set, otherwise, noop.  Used when a commit is
1:eac0369: 	 * done on a nested connection.
1:eac0369: 	 *
1:eac0369: 	 * @see StatementContext#resetSavePoint
1:eac0369: 	 * @exception StandardException Thrown on error
1:eac0369: 	 */
1:eac0369: 	public void resetSavePoint() throws StandardException {
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			if (SanityManager.DEBUG_ON("traceSavepoints"))
1:eac0369: 			{
1:eac0369: 				SanityManager.DEBUG_PRINT(
1:eac0369: 					"GenericStatementContext.resetSavePoint()",
1:eac0369: 					internalSavePointName);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 			
1:eac0369: 		if (inUse && setSavePoint)
1:eac0369: 		{		
2:eac0369: 			// RESOLVE PLUGIN ???. For the plugin, there will be no transaction controller
1:95031f0: 			lcc.getTransactionExecute().setSavePoint(internalSavePointName, null);
1:eac0369: 			// stage buffer management
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see StatementContext#clearSavePoint
1:eac0369: 	 * @exception StandardException Thrown on error
1:eac0369: 	 */
1:eac0369: 	public void clearSavePoint() throws StandardException {
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			if (SanityManager.DEBUG_ON("traceSavepoints"))
1:eac0369: 			{
1:eac0369: 				SanityManager.DEBUG_PRINT("GenericStatementContext.clearSavePoint()",
1:eac0369: 										  internalSavePointName);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		pleaseBeOnStack();
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(setSavePoint, "setSavePoint is expected to be true");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// RESOLVE PLUGIN ???. For the plugin, there will be no transaction controller
1:95031f0: 		lcc.getTransactionExecute().releaseSavePoint(internalSavePointName, null);
1:eac0369: 		setSavePoint = false;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set the top ResultSet in the ResultSet tree for close down on
1:eac0369: 	 * an error.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException thrown on error.
1:eac0369: 	 */
1:eac0369: 	public void setTopResultSet(ResultSet topResultSet, 
1:eac0369: 							    NoPutResultSet[] subqueryTrackingArray)
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369: 		pleaseBeOnStack();
1:eac0369: 
1:eac0369: 		/* We have to handle both materialize and non-materialized subqueries.
1:eac0369: 		 * Materialized subqueries are attached before the top result set is 
1:eac0369: 		 * set.  If there are any, then we must copy them into the new
1:eac0369: 		 * subqueryTrackingArray.
1:eac0369: 		 */
1:eac0369: 		if (materializedSubqueries != null)
1:eac0369: 		{
1:eac0369: 			// Do the merging into the passed in array.
1:eac0369: 			if (subqueryTrackingArray != null)
1:eac0369: 			{
1:eac0369: 				if (SanityManager.DEBUG)
1:eac0369: 				{
1:eac0369: 					if (this.materializedSubqueries.length != subqueryTrackingArray.length)
1:eac0369: 					{
1:eac0369: 						SanityManager.THROWASSERT(
1:eac0369: 							"this.ms.length (" + this.materializedSubqueries.length +
1:eac0369: 							") expected to = sta.length(" + subqueryTrackingArray.length +
1:eac0369: 							")");
1:eac0369: 					}
1:eac0369: 				}
1:eac0369: 				for (int index = 0; index < subqueryTrackingArray.length; index++)
1:eac0369: 				{
1:05b022f:                     if (this.materializedSubqueries[index] != null)
1:eac0369: 					{
1:eac0369: 						subqueryTrackingArray[index] = this.materializedSubqueries[index];
1:eac0369: 					}
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 			else
1:eac0369: 			{
1:eac0369: 				subqueryTrackingArray = this.materializedSubqueries;
1:eac0369: 			}
1:eac0369: 			materializedSubqueries = null;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		stuffTopResultSet( topResultSet, subqueryTrackingArray );
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  *	Private minion of setTopResultSet() and clearInUse()
1:eac0369: 	  *
1:eac0369: 	  *	@param	topResultSet	make this the top result set
1:eac0369: 	  *	@param	subqueryTrackingArray	where to keep track of subqueries in this statement
1:eac0369: 	  */
1:eac0369: 	private	void	stuffTopResultSet(ResultSet topResultSet, 
1:eac0369: 									  NoPutResultSet[] subqueryTrackingArray)
1:eac0369: 	{
1:eac0369: 		this.topResultSet = topResultSet;
1:eac0369: 		this.subqueryTrackingArray = subqueryTrackingArray;
1:eac0369: 		dependencies = null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set the appropriate entry in the subquery tracking array for
1:eac0369: 	 * the specified subquery.
1:eac0369: 	 * Useful for closing down open subqueries on an exception.
1:eac0369: 	 *
1:eac0369: 	 * @param subqueryNumber	The subquery # for this subquery
1:eac0369: 	 * @param subqueryResultSet	The ResultSet at the top of the subquery
1:eac0369: 	 * @param numSubqueries		The total # of subqueries in the entire query
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException thrown on error.
1:eac0369: 	 */
1:eac0369: 	public void setSubqueryResultSet(int subqueryNumber,
1:eac0369: 									 NoPutResultSet subqueryResultSet,
1:eac0369: 									 int numSubqueries)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		pleaseBeOnStack();
1:eac0369: 		
1:eac0369: 		/* NOTE: In degenerate cases, it is possible that there is no top
1:eac0369: 		 * result set.  For example:
1:eac0369: 		 *		call (select 1 from systables).valueOf('111');
1:eac0369: 		 * In that case, we allocate our own subquery tracking array on
1:eac0369: 		 * each call. (Gross!)
1:eac0369: 		 * (Trust me, this is only done in degenerate cases.  The tests passed,
1:eac0369: 		 * except for the degenerate cases, before making this change, so we
1:eac0369: 		 * know that the top result set and array reuse is working for
1:eac0369: 		 * the non-degenerate cases.)
1:eac0369: 		 */
1:eac0369: 		if (subqueryTrackingArray == null)
1:eac0369: 		{
1:eac0369: 			if (topResultSet == null)
1:eac0369: 			{
1:eac0369: 				subqueryTrackingArray = new NoPutResultSet[numSubqueries];
1:eac0369: 				materializedSubqueries = new NoPutResultSet[numSubqueries];
1:eac0369: 			}
1:eac0369: 			else
1:eac0369: 			{
1:eac0369: 				subqueryTrackingArray = 
1:eac0369: 					topResultSet.getSubqueryTrackingArray(numSubqueries);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		subqueryTrackingArray[subqueryNumber] = subqueryResultSet;
1:eac0369: 		if (materializedSubqueries != null)
1:eac0369: 		{
1:eac0369: 			materializedSubqueries[subqueryNumber] = subqueryResultSet;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the subquery tracking array for this query.
1:eac0369: 	 * (Useful for runtime statistics.)
1:eac0369: 	 *
1:eac0369: 	 * @return NoPutResultSet[]	The	(sparse) array of tops of subquery ResultSet trees
1:eac0369: 	 * @exception StandardException thrown on error.
1:eac0369: 	 */
1:eac0369: 	public NoPutResultSet[] getSubqueryTrackingArray()
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		pleaseBeOnStack();
1:eac0369: 		
1:eac0369: 		return subqueryTrackingArray;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Track a Dependency within this StatementContext.
1:eac0369: 	 * (We need to clear any dependencies added within this
1:eac0369: 	 * context on an error.
1:eac0369: 	 *
1:eac0369: 	 * @param dy	The dependency to track.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException thrown on error.
1:eac0369: 	 */
1:eac0369: 	public void addDependency(Dependency dy)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		pleaseBeOnStack();
1:eac0369: 		
1:eac0369: 		if (dependencies == null)
1:eac0369: 		{
1:274c5ba: 			dependencies = new ArrayList<Dependency>();
1:eac0369: 		}
1:eac0369: 		dependencies.add(dy);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Returns whether we started from within the context of a trigger
1:eac0369: 	 * or not.
1:eac0369: 	 *
1:eac0369: 	 * @return	true if we are in a trigger context
1:eac0369: 	 */
1:eac0369: 	public	boolean	inTrigger()
1:eac0369: 	{
1:eac0369: 		return	parentInTrigger;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	//
1:eac0369: 	// Context interface
1:eac0369: 	//
1:eac0369: 	/**
1:eac0369: 	 * Close down the top ResultSet, if relevant, and rollback to the
1:eac0369: 	 * internal savepoint, if one was set.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException thrown on error. REVISIT: don't want
1:eac0369: 	 * cleanupOnError's to throw exceptions.
1:eac0369: 	 */
1:eac0369: 	public void cleanupOnError(Throwable error) throws StandardException
1:eac0369: 	{
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			if (SanityManager.DEBUG_ON("traceSavepoints"))
1:eac0369: 			{
1:eac0369: 				SanityManager.DEBUG_PRINT(
1:eac0369: 						"GenericStatementContext.cleanupOnError()",
1:eac0369: 						String.valueOf( hashCode() ) );
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:7f3bcb4: 		try {
1:eac0369: 		/*
1:eac0369: 		** If it isn't a StandardException, then assume
1:665a8b9: 		** session severity.  It is probably an unexpected
1:eac0369: 		** java error somewhere in the language.
1:665a8b9:         ** Store layer treats JVM error as session severity, 
1:665a8b9:         ** hence to be consistent and to avoid getting rawstore
1:665a8b9:         ** protocol violation errors, we treat java errors here
1:665a8b9:         ** to be of session severity.  
1:665a8b9:         */
1:b4885a6:         int severity = ExceptionSeverity.SESSION_SEVERITY;
1:b4885a6:         if (error instanceof StandardException) {
1:b4885a6:             StandardException se = (StandardException)error;
1:b4885a6:             // Update the severity.
1:b4885a6:             severity = se.getSeverity();
1:b4885a6:             // DERBY-4849: Remember that the plan was invalidated, such that
1:b4885a6:             // we can avoid performing certain actions more than once
1:b4885a6:             // (for correctness, not optimization).
1:b4885a6:             if (SQLState.LANG_STATEMENT_NEEDS_RECOMPILE.equals(
1:b4885a6:                     se.getMessageId())) {
1:b4885a6:                 statementWasInvalidated = true;
1:b4885a6:             }
1:b4885a6:         }
1:eac0369: 
1:eac0369: 
1:eac0369: 		/**
1:eac0369: 		 * Don't clean up this statement context if it's not in use.
1:eac0369: 		 * This can happen if you get an error while calling one of
1:eac0369: 		 * the JDBC getxxxx() methods on a ResultSet, since no statement
1:eac0369: 		 * context is pushed when those calls occur.
1:eac0369: 		 */
1:eac0369: 		if (! inUse)
1:eac0369: 		{
1:eac0369: 			return;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* Clean up the ResultSet, if one exists */
1:eac0369: 		if (topResultSet != null)
1:eac0369: 		{
1:eac0369: 			topResultSet.cleanUp();
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* Close down any open subqueries */
1:eac0369: 		if (subqueryTrackingArray != null)
1:eac0369: 		{
1:eac0369: 			for (int index = 0; index < subqueryTrackingArray.length; index++)
1:eac0369: 			{
1:eac0369: 				/* Remember, the array is sparse, so only check
1:eac0369: 				 * non-null entries.
1:eac0369: 				 */
1:eac0369: 				if (subqueryTrackingArray[index] != null)
1:eac0369: 				{
1:eac0369: 					subqueryTrackingArray[index].cleanUp();
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* Clean up any dependencies */
1:eac0369: 		if (dependencies != null)
1:eac0369: 		{
1:eac0369: 			DependencyManager dmgr = lcc.getDataDictionary().getDependencyManager();
1:eac0369: 
1:274c5ba: 			for (Iterator<Dependency> iterator = dependencies.iterator(); iterator.hasNext(); ) 
1:eac0369: 			{
1:274c5ba: 				Dependency dy = iterator.next();
1:eac0369: 				dmgr.clearInMemoryDependency(dy);
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			dependencies = null;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (severity <= ExceptionSeverity.STATEMENT_SEVERITY
1:eac0369: 			&& setSavePoint)
1:eac0369: 		{
1:eac0369: 			if (SanityManager.DEBUG)
1:eac0369: 			{
1:eac0369: 				if (SanityManager.DEBUG_ON("traceSavepoints"))
1:eac0369: 				{
1:eac0369: 					SanityManager.DEBUG_PRINT(
1:eac0369: 						"GenericStatementContext.cleanupOnError",
1:eac0369: 						"rolling back to: " + internalSavePointName);
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			lcc.internalRollbackToSavepoint( internalSavePointName, false, null);
1:eac0369: 
1:eac0369: 			clearSavePoint();
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (severity >= ExceptionSeverity.TRANSACTION_SEVERITY )
1:eac0369: 		{
1:eac0369: 			// transaction severity errors roll back the transaction.
1:eac0369: 
1:eac0369: 			/*
1:eac0369: 			** We call clearSavePoint() above only for statement errors.
1:eac0369: 			** We don't call clearSavePoint() for transaction errors because
1:eac0369: 			** the savepoint will be rolled back anyway.  So in this case,
1:eac0369: 			** we need to indicate that the savepoint is not set.
1:eac0369: 			*/
1:eac0369: 			setSavePoint = false;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* Pop the context */
1:eac0369: 		lcc.popStatementContext(this, error);
1:7f3bcb4: 		} catch(Exception ex) {
1:7f3bcb4: 			//DERBY-6722(GenericStatementContext.cleanupOnError()  
1:7f3bcb4: 			//needs protection from later errors during statement 
1:7f3bcb4: 			//cleanup
1:7f3bcb4: 			ex.initCause(error);
1:7f3bcb4: 			throw StandardException.unexpectedUserException(ex);
1:7f3bcb4: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see Context#isLastHandler
1:eac0369: 	 */
1:eac0369: 	public boolean isLastHandler(int severity)
1:eac0369: 	{
1:665a8b9:         // For JVM errors, severity gets mapped to 
1:665a8b9:         // ExceptionSeverity.NO_APPLICABLE_SEVERITY
1:665a8b9:         // in ContextManager.cleanupOnError. It is necessary to 
1:665a8b9:         // let outer contexts take corrective action for jvm errors, so 
1:665a8b9:         // return false as this will not be the last handler for such 
1:665a8b9:         // errors.
1:665a8b9: 		return inUse && !rollbackParentContext && 
1:665a8b9:             ( severity == ExceptionSeverity.STATEMENT_SEVERITY );
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  *	Reports whether this StatementContext is on the context stack.
1:eac0369: 	  *
1:eac0369: 	  *	@return	true if this StatementContext is on the context stack. false otherwise.
1:eac0369: 	  */
1:eac0369:     public	boolean	onStack() { return inUse; }
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Indicates whether the statement needs to be executed atomically
1:eac0369: 	 * or not, i.e., whether a commit/rollback is permitted by a
1:eac0369:  	 * connection nested in this statement.
1:eac0369: 	 *
1:eac0369: 	 * @return true if needs to be atomic
1:eac0369: 	 */
1:eac0369: 	public boolean isAtomic()
1:eac0369: 	{
1:eac0369: 		return isAtomic;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return the text of the current statement.
1:eac0369: 	 * Note that this may be null.  It is currently
1:eac0369: 	 * not set up correctly for ResultSets that aren't
1:eac0369: 	 * single row result sets (e.g SELECT), replication,
1:eac0369: 	 * and setXXXX/getXXXX jdbc methods.
1:eac0369: 	 *
1:eac0369: 	 * @return the statement text
1:eac0369: 	 */
1:eac0369: 	public String getStatementText()
1:eac0369: 	{
1:eac0369: 		return stmtText;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	//
1:eac0369: 	// class implementation
1:eac0369: 	//
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  *	Raise an exception if this Context is not in use, that is, on the
1:eac0369: 	  * Context Stack.
1:eac0369: 	  *
1:eac0369: 	  * @exception StandardException thrown on error.
1:eac0369: 	  */
1:eac0369: 	private	void	pleaseBeOnStack() throws StandardException
1:eac0369: 	{
1:eac0369: 		if ( !inUse ) { throw StandardException.newException(SQLState.LANG_DEAD_STATEMENT); }
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public boolean inUse()
1:eac0369: 	{
1:eac0369: 		return inUse;
1:eac0369: 	}
1:5087be8:     public boolean isForReadOnly()
1:5087be8:     {
1:5087be8: 	return isForReadOnly;
1:eac0369:     }
1:3fcea8a:         
1:3fcea8a:     /**
1:3fcea8a:      * Tests whether the statement which has allocated this StatementContext
1:3fcea8a:      * object has been cancelled. This method is typically called from the
1:3fcea8a:      * thread which is executing the statement, to test whether execution
1:3fcea8a:      * should continue or stop.
1:3fcea8a:      *
1:3fcea8a:      * @return whether the statement which has allocated this StatementContext
1:3fcea8a:      *  object has been cancelled.
1:3fcea8a:      */
1:3fcea8a:     public boolean isCancelled()
1:3fcea8a:     {
1:3fcea8a:         return cancellationFlag;
1:3fcea8a:     }
1:3fcea8a: 
1:3fcea8a:     /**
1:3fcea8a:      * Cancels the statement which has allocated this StatementContext object.
1:3fcea8a:      * This is done by setting a flag in the StatementContext object. For
1:3fcea8a:      * this to have any effect, it is the responsibility of the executing
1:3fcea8a:      * statement to check this flag regularly.
1:3fcea8a:      */
1:3fcea8a:     public void cancel()
1:3fcea8a:     {
1:3fcea8a:         cancellationFlag = true;
1:3fcea8a:     }
1:eac0369: 
1:eac0369: 	public void setSQLAllowed(short allow, boolean force) {
1:eac0369: 
1:eac0369: 		// cannot override a stricter setting.
1:eac0369: 		// -1 is no routine restriction in place
1:eac0369: 		// 0 is least restrictive
1:eac0369: 		// 4 is most
1:eac0369: 		if (force || (allow > sqlAllowed))
1:eac0369: 			sqlAllowed = allow;
1:eac0369: 
1:eac0369: 	}
1:eac0369: 	public short getSQLAllowed() {
1:eac0369: 		if (!inUse)
1:eac0369: 			return org.apache.derby.catalog.types.RoutineAliasInfo.NO_SQL;
1:eac0369: 
1:eac0369: 		return sqlAllowed;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Indicate that, in the event of a statement-level exception,
1:eac0369: 	 * this context is NOT the last one that needs to be rolled
1:eac0369: 	 * back--rather, it is nested within some other statement
1:eac0369: 	 * context, and that other context needs to be rolled back,
1:eac0369: 	 * too.
1:eac0369: 	*/
1:eac0369: 	public void setParentRollback() {
1:eac0369: 		rollbackParentContext = true;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Set to indicate statement is system code.
1:eac0369: 		For example a system procedure, view, function etc.
1:eac0369: 	*/
1:eac0369: 	public void setSystemCode() {
1:eac0369: 		isSystemCode = true;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Return true if this statement is system code.
1:eac0369: 	*/
1:eac0369: 	public boolean getSystemCode() {
1:eac0369: 		return isSystemCode;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public StringBuffer appendErrorInfo() {
1:eac0369: 
1:eac0369: 		StringBuffer sb = ((ContextImpl) lcc).appendErrorInfo();
1:eac0369: 		if (sb != null) {
1:eac0369: 
1:eac0369: 			sb.append("Failed Statement is: ");
1:eac0369: 
1:eac0369: 			sb.append(getStatementText());
1:eac0369: 
1:e243142: 			if ((pvs != null) && pvs.getParameterCount() > 0)
1:eac0369: 			{
1:eac0369: 				String pvsString = " with " + pvs.getParameterCount() +
1:eac0369: 						" parameters " + pvs.toString();
1:eac0369: 				sb.append(pvsString);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		return sb;
1:6950a39: 
1:eac0369: 	}
1:eac0369: 
1:6950a39: 	/**
1:6950a39: 	 * @see StatementContext#setActivation(Activation a)
1:6950a39: 	 */
1:6950a39: 	public void setActivation(Activation a) {
1:6950a39: 		activation = a;
1:6950a39: 	}
1:6950a39: 
1:6950a39: 	/**
1:6950a39: 	 * @see StatementContext#getActivation
1:6950a39: 	 */
1:6950a39: 	public Activation getActivation() {
1:6950a39: 		return activation;
1:6950a39: 	}
1:6950a39: 
1:6950a39: 	/**
1:6950a39: 	 * @see StatementContext#getSQLSessionContext
1:6950a39: 	 */
1:6950a39: 	public SQLSessionContext getSQLSessionContext() {
1:6950a39: 		return sqlSessionContext;
1:6950a39: 	}
1:6950a39: 
1:6950a39: 	/**
1:6950a39: 	 * @see StatementContext#setSQLSessionContext(SQLSessionContext ctx)
1:6950a39: 	 */
1:6950a39: 	public void setSQLSessionContext(SQLSessionContext ctx) {
1:6950a39: 		sqlSessionContext = ctx;
1:6950a39: 	}
1:b4885a6: 
1:b4885a6:     public boolean getStatementWasInvalidated() {
1:b4885a6:         return statementWasInvalidated;
1:b4885a6:     }
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1:      * a CancelQueryTask is scheduled if a timeout &gt; 0 has been set.
commit:56c1dc2
/////////////////////////////////////////////////////////////////////////
1:         return GenericLanguageConnectionFactory.getMonitor().getTimerFactory();
commit:274c5ba
/////////////////////////////////////////////////////////////////////////
1: 	private ArrayList<Dependency>		dependencies;
/////////////////////////////////////////////////////////////////////////
1: 			dependencies = new ArrayList<Dependency>();
/////////////////////////////////////////////////////////////////////////
1: 			for (Iterator<Dependency> iterator = dependencies.iterator(); iterator.hasNext(); ) 
1: 				Dependency dy = iterator.next();
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:7f3bcb4
/////////////////////////////////////////////////////////////////////////
1: 		try {
/////////////////////////////////////////////////////////////////////////
1: 		} catch(Exception ex) {
1: 			//DERBY-6722(GenericStatementContext.cleanupOnError()  
1: 			//needs protection from later errors during statement 
1: 			//cleanup
1: 			ex.initCause(error);
1: 			throw StandardException.unexpectedUserException(ex);
1: 		}
commit:1fac3e9
/////////////////////////////////////////////////////////////////////////
1:             synchronized (this) {
1:                 statementContext = null;
0:             cancel();
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:05b022f
/////////////////////////////////////////////////////////////////////////
1:                     if (this.materializedSubqueries[index] != null)
commit:13673bd
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             getTimerFactory().cancel(this);
1:     private static TimerFactory getTimerFactory() {
0:         return Monitor.getMonitor().getTimerFactory();
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:             getTimerFactory().schedule(cancelTask, timeoutMillis);
commit:3c099fa
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         internalSavePointName = lcc.getUniqueSavepointName();
commit:98d82d9
/////////////////////////////////////////////////////////////////////////
0:     // Counter used to create unique savepoint names.
0:     private static long nextNameId = Long.MIN_VALUE;
1: 
/////////////////////////////////////////////////////////////////////////
0:         internalSavePointName = createInternalSavepointName();
/////////////////////////////////////////////////////////////////////////
0:      * Generate a unique name for this savepoint.
0:      * This method should only be called from the constructor.
1:      *
0:      * @return the savepoint name.
1:      */
0:     private synchronized static String createInternalSavepointName() {
0:         return "ISSP" + nextNameId++;
1:     }
1: 
1:     /**
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:b4885a6
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private boolean     statementWasInvalidated;
/////////////////////////////////////////////////////////////////////////
1:         statementWasInvalidated = false;
/////////////////////////////////////////////////////////////////////////
1:         int severity = ExceptionSeverity.SESSION_SEVERITY;
1:         if (error instanceof StandardException) {
1:             StandardException se = (StandardException)error;
1:             // Update the severity.
1:             severity = se.getSeverity();
1:             // DERBY-4849: Remember that the plan was invalidated, such that
1:             // we can avoid performing certain actions more than once
1:             // (for correctness, not optimization).
1:             if (SQLState.LANG_STATEMENT_NEEDS_RECOMPILE.equals(
1:                     se.getMessageId())) {
1:                 statementWasInvalidated = true;
1:             }
1:         }
/////////////////////////////////////////////////////////////////////////
1: 
1:     public boolean getStatementWasInvalidated() {
1:         return statementWasInvalidated;
1:     }
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:6950a39
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.conn.SQLSessionContext;
1: import org.apache.derby.iapi.sql.Activation;
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * The activation associated with this context, or null
1: 	 */
1: 	private Activation activation;
1: 
1: 	/**
1: 	 * The SQLSessionContext associated with a statement context.
1: 	 */
1: 	private SQLSessionContext sqlSessionContext;
1: 
/////////////////////////////////////////////////////////////////////////
1:         activation = null;
1: 		sqlSessionContext = null;
1:     }
/////////////////////////////////////////////////////////////////////////
1: 
1: 	/**
1: 	 * @see StatementContext#setActivation(Activation a)
1: 	 */
1: 	public void setActivation(Activation a) {
1: 		activation = a;
1: 	}
1: 
1: 	/**
1: 	 * @see StatementContext#getActivation
1: 	 */
1: 	public Activation getActivation() {
1: 		return activation;
1: 	}
1: 
1: 	/**
1: 	 * @see StatementContext#getSQLSessionContext
1: 	 */
1: 	public SQLSessionContext getSQLSessionContext() {
1: 		return sqlSessionContext;
1: 	}
1: 
1: 	/**
1: 	 * @see StatementContext#setSQLSessionContext(SQLSessionContext ctx)
1: 	 */
1: 	public void setSQLSessionContext(SQLSessionContext ctx) {
1: 		sqlSessionContext = ctx;
1: 	}
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:e243142
/////////////////////////////////////////////////////////////////////////
1: 			if ((pvs != null) && pvs.getParameterCount() > 0)
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:95031f0
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	GenericStatementContext(LanguageConnectionContext lcc) 
/////////////////////////////////////////////////////////////////////////
1: 		lcc.getTransactionExecute().setSavePoint(internalSavePointName, null);
/////////////////////////////////////////////////////////////////////////
1: 			lcc.getTransactionExecute().setSavePoint(internalSavePointName, null);
/////////////////////////////////////////////////////////////////////////
1: 		lcc.getTransactionExecute().releaseSavePoint(internalSavePointName, null);
commit:665a8b9
/////////////////////////////////////////////////////////////////////////
1: 		** session severity.  It is probably an unexpected
1:         ** Store layer treats JVM error as session severity, 
1:         ** hence to be consistent and to avoid getting rawstore
1:         ** protocol violation errors, we treat java errors here
1:         ** to be of session severity.  
1:         */
0: 			ExceptionSeverity.SESSION_SEVERITY;
/////////////////////////////////////////////////////////////////////////
1:         // For JVM errors, severity gets mapped to 
1:         // ExceptionSeverity.NO_APPLICABLE_SEVERITY
1:         // in ContextManager.cleanupOnError. It is necessary to 
1:         // let outer contexts take corrective action for jvm errors, so 
1:         // return false as this will not be the last handler for such 
1:         // errors.
1: 		return inUse && !rollbackParentContext && 
1:             ( severity == ExceptionSeverity.STATEMENT_SEVERITY );
commit:3fcea8a
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.monitor.Monitor;
1: 
1: import org.apache.derby.iapi.services.timer.TimerFactory;
1: 
/////////////////////////////////////////////////////////////////////////
0: import java.util.Timer;
1: import java.util.TimerTask;
/////////////////////////////////////////////////////////////////////////
1: 
1:     // This flag satisfies all the conditions
1:     // for using volatile instead of synchronized.
1:     // (Source: Doug Lea, Concurrent Programming in Java, Second Edition,
1:     // section 2.2.7.4, page 97)
1:     // true if statement has been cancelled
1:     private volatile boolean cancellationFlag = false;
1: 
1:     // Reference to the TimerTask that will time out this statement.
1:     // Needed for stopping the task when execution completes before timeout.
1:     private CancelQueryTask cancelTask = null;
1:         
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * This is a TimerTask that is responsible for timing out statements,
1:      * typically when an application has called Statement.setQueryTimeout().
1:      *
1:      * When the application invokes execute() on a statement object, or
1:      * fetches data on a ResultSet, a StatementContext object is allocated
1:      * for the duration of the execution in the engine (until control is
1:      * returned to the application).
1:      *
1:      * When the StatementContext object is assigned with setInUse(),
0:      * a CancelQueryTask is scheduled if a timeout > 0 has been set.
1:      */
1:     private static class CancelQueryTask
1:         extends
1:             TimerTask
1:     {
1:         /**
1:          * Reference to the StatementContext for the executing statement
1:          * which might time out.
1:          */
1:         private StatementContext statementContext;
1: 
1:         /**
1:          * Initializes a new task for timing out a statement's execution.
1:          * This does not schedule it for execution, the caller is
1:          * responsible for calling Timer.schedule() with this object
1:          * as parameter.
1:          */
1:         public CancelQueryTask(StatementContext ctx)
1:         {
1:             statementContext = ctx;
1:         }
1: 
1:         /**
1:          * Invoked by a Timer class to cancel an executing statement.
1:          * This method just sets a volatile flag in the associated
1:          * StatementContext object by calling StatementContext.cancel();
1:          * it is the responsibility of the thread executing the statement
1:          * to check this flag regularly.
1:          */
1:         public void run()
1:         {
1:             synchronized (this) {
1:                 if (statementContext != null) {
1:                     statementContext.cancel();
1:                 }
1:             }
1:         }
1: 
1:         /**
1:          * Stops this task and prevents it from cancelling a statement.
1:          * Guarantees that after this method returns, the associated
1:          * StatementContext object will not be tampered with by this task.
1:          * Thus, the StatementContext object may safely be allocated to
1:          * other executing statements.
1:          */
1:         public void forgetContext() {
0:             boolean mayStillRun = !cancel();
0:             if (mayStillRun) {
1:                 synchronized (this) {
0:                     statementContext = null;
1:                 }
1:             }
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1: 		ParameterValueSet pvs,
1:         long timeoutMillis
/////////////////////////////////////////////////////////////////////////
1:         if (timeoutMillis > 0) {
0:             TimerFactory factory = Monitor.getMonitor().getTimerFactory();
0:             Timer timer = factory.getCancellationTimer();
1:             cancelTask = new CancelQueryTask(this);
0:             timer.schedule(cancelTask, timeoutMillis);
1:         }
/////////////////////////////////////////////////////////////////////////
1: 
1:         if (cancelTask != null) {
1:             cancelTask.forgetContext();
1:             cancelTask = null;
1:         }
1:         cancellationFlag = false;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         
1:     /**
1:      * Tests whether the statement which has allocated this StatementContext
1:      * object has been cancelled. This method is typically called from the
1:      * thread which is executing the statement, to test whether execution
1:      * should continue or stop.
1:      *
1:      * @return whether the statement which has allocated this StatementContext
1:      *  object has been cancelled.
1:      */
1:     public boolean isCancelled()
1:     {
1:         return cancellationFlag;
1:     }
1: 
1:     /**
1:      * Cancels the statement which has allocated this StatementContext object.
1:      * This is done by setting a flag in the StatementContext object. For
1:      * this to have any effect, it is the responsibility of the executing
1:      * statement to check this flag regularly.
1:      */
1:     public void cancel()
1:     {
1:         cancellationFlag = true;
1:     }
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.conn.GenericStatementContext
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:61070a6
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.conn
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.sql.conn;
1: 
1: import org.apache.derby.iapi.services.context.Context;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: 
1: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1: import org.apache.derby.iapi.sql.conn.StatementContext;
1: 
1: import org.apache.derby.iapi.sql.depend.Dependency;
1: import org.apache.derby.iapi.sql.depend.DependencyManager;
1: 
1: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
1: 
1: import org.apache.derby.iapi.sql.ResultSet;
1: import org.apache.derby.iapi.sql.ParameterValueSet;
1: 
0: import org.apache.derby.iapi.store.access.TransactionController;
1: 
1: import org.apache.derby.iapi.services.context.ContextImpl;
1: 
1: import org.apache.derby.iapi.error.ExceptionSeverity;
1: import org.apache.derby.iapi.reference.SQLState;
1: import java.util.ArrayList;
1: import java.util.Iterator;
0: import java.sql.SQLException;
1: 
1: /**
1:  * GenericStatementContext is pushed/popped around a statement prepare and execute
1:  * so that any statement specific clean up can be performed.
1:  *
0:  * @author jerry
1:  *
1:  */
1: final class GenericStatementContext 
1: 	extends ContextImpl implements StatementContext
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	private final TransactionController tc;
1: 
1: 	private boolean		setSavePoint;
1: 	private String		internalSavePointName;
1: 	private ResultSet	topResultSet;
0: 	private ArrayList		dependencies;
1: 	private NoPutResultSet[] subqueryTrackingArray;
1: 	private NoPutResultSet[] materializedSubqueries;
1: 	private	final LanguageConnectionContext lcc;
1: 	private boolean		inUse = true;
1:     private	boolean		parentInTrigger;	// whetherparent started with a trigger on stack
1:     private	boolean		isAtomic;	
1: 	private boolean		isSystemCode;
1: 	private boolean		rollbackParentContext;
1:     private	String		stmtText;
1:     private	ParameterValueSet			pvs;
1: 
1: 	/**
1: 		Set to one of RoutineAliasInfo.{MODIFIES_SQL_DATA, READS_SQL_DATA, CONTAINS_SQL, NO_SQL}
1: 	*/
1: 	private short			sqlAllowed = -1;
1: 
1: 	/*
1: 	   constructor
1: 		@param tc transaction
1: 	*/
0: 	GenericStatementContext(LanguageConnectionContext lcc, TransactionController tc) 
1: 	{
1: 		super(lcc.getContextManager(), org.apache.derby.iapi.reference.ContextId.LANG_STATEMENT);
1: 		this.lcc = lcc;
0: 		this.tc = tc;
1: 
0: 		internalSavePointName = "ISSP" + hashCode();
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT((lcc != null),
1: 					"Failed to get language connection context");
1: 		}
1: 
1: 	}
1: 
1: 	// StatementContext Interface
1: 
1: 	public void setInUse
1: 	( 
1: 		boolean parentInTrigger,
1: 		boolean isAtomic, 
1: 		String stmtText,
0: 		ParameterValueSet pvs
1: 	) 
1: 	{
1: 		inUse = true;
1: 
1: 		this.parentInTrigger = parentInTrigger;
1: 		this.isAtomic = isAtomic;
1: 		this.stmtText = stmtText;
1: 		this.pvs = pvs;
1: 		rollbackParentContext = false;
1: 	}
1: 
1: 	public void clearInUse() {
1: 		/* We must clear out the current top ResultSet to prepare for
1: 		 * reusing a StatementContext.
1: 		 */
1: 		stuffTopResultSet( null, null );
1: 		inUse = false;
1: 
1: 		parentInTrigger = false;
1: 		isAtomic = false;
1: 		this.stmtText = null;
1: 		sqlAllowed = -1;
1: 		isSystemCode = false;
1: 		rollbackParentContext = false;
1: 	}
1: 
1: 	/**
1: 	 * @see StatementContext#setSavePoint
1: 	 * @exception StandardException Thrown on error
1: 	 */
1: 	public void setSavePoint() throws StandardException {
1: 		
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			if (SanityManager.DEBUG_ON("traceSavepoints"))
1: 			{
1: 				SanityManager.DEBUG_PRINT(
1: 									"GenericStatementContext.setSavePoint()",
1: 									internalSavePointName);
1: 			}
1: 		}
1: 			
1: 		pleaseBeOnStack();
1: 		
1: 
1: 		// RESOLVE PLUGIN ???. For the plugin, there will be no transaction controller
0: 		if ( tc != null ) { tc.setSavePoint(internalSavePointName, null); }
1: 		setSavePoint = true;
1: 	}
1: 
1: 	/**
1: 	 * Resets the savepoint to the current spot if it is
1: 	 * set, otherwise, noop.  Used when a commit is
1: 	 * done on a nested connection.
1: 	 *
1: 	 * @see StatementContext#resetSavePoint
1: 	 * @exception StandardException Thrown on error
1: 	 */
1: 	public void resetSavePoint() throws StandardException {
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			if (SanityManager.DEBUG_ON("traceSavepoints"))
1: 			{
1: 				SanityManager.DEBUG_PRINT(
1: 					"GenericStatementContext.resetSavePoint()",
1: 					internalSavePointName);
1: 			}
1: 		}
1: 			
1: 		if (inUse && setSavePoint)
1: 		{		
1: 			// RESOLVE PLUGIN ???. For the plugin, there will be no transaction controller
0: 			if ( tc != null ) { tc.setSavePoint(internalSavePointName, null); }
1: 			// stage buffer management
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * @see StatementContext#clearSavePoint
1: 	 * @exception StandardException Thrown on error
1: 	 */
1: 	public void clearSavePoint() throws StandardException {
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			if (SanityManager.DEBUG_ON("traceSavepoints"))
1: 			{
1: 				SanityManager.DEBUG_PRINT("GenericStatementContext.clearSavePoint()",
1: 										  internalSavePointName);
1: 			}
1: 		}
1: 
1: 		pleaseBeOnStack();
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(setSavePoint, "setSavePoint is expected to be true");
1: 		}
1: 
1: 		// RESOLVE PLUGIN ???. For the plugin, there will be no transaction controller
0: 		if ( tc != null ) { tc.releaseSavePoint(internalSavePointName, null); }
1: 		setSavePoint = false;
1: 	}
1: 
1: 	/**
1: 	 * Set the top ResultSet in the ResultSet tree for close down on
1: 	 * an error.
1: 	 *
1: 	 * @exception StandardException thrown on error.
0: 	 * @return Nothing.
1: 	 */
1: 	public void setTopResultSet(ResultSet topResultSet, 
1: 							    NoPutResultSet[] subqueryTrackingArray)
1: 		 throws StandardException
1: 	{
1: 		pleaseBeOnStack();
1: 
1: 		/* We have to handle both materialize and non-materialized subqueries.
1: 		 * Materialized subqueries are attached before the top result set is 
1: 		 * set.  If there are any, then we must copy them into the new
1: 		 * subqueryTrackingArray.
1: 		 */
1: 		if (materializedSubqueries != null)
1: 		{
1: 			// Do the merging into the passed in array.
1: 			if (subqueryTrackingArray != null)
1: 			{
1: 				if (SanityManager.DEBUG)
1: 				{
1: 					if (this.materializedSubqueries.length != subqueryTrackingArray.length)
1: 					{
1: 						SanityManager.THROWASSERT(
1: 							"this.ms.length (" + this.materializedSubqueries.length +
1: 							") expected to = sta.length(" + subqueryTrackingArray.length +
1: 							")");
1: 					}
1: 				}
1: 				for (int index = 0; index < subqueryTrackingArray.length; index++)
1: 				{
0: 					if (this.subqueryTrackingArray[index] != null)
1: 					{
1: 						subqueryTrackingArray[index] = this.materializedSubqueries[index];
1: 					}
1: 				}
1: 			}
1: 			else
1: 			{
1: 				subqueryTrackingArray = this.materializedSubqueries;
1: 			}
1: 			materializedSubqueries = null;
1: 		}
1: 
1: 		stuffTopResultSet( topResultSet, subqueryTrackingArray );
1: 	}
1: 
1: 	/**
1: 	  *	Private minion of setTopResultSet() and clearInUse()
1: 	  *
1: 	  *	@param	topResultSet	make this the top result set
1: 	  *	@param	subqueryTrackingArray	where to keep track of subqueries in this statement
1: 	  *
0: 	  * @return Nothing.
1: 	  */
1: 	private	void	stuffTopResultSet(ResultSet topResultSet, 
1: 									  NoPutResultSet[] subqueryTrackingArray)
1: 	{
1: 		this.topResultSet = topResultSet;
1: 		this.subqueryTrackingArray = subqueryTrackingArray;
1: 		dependencies = null;
1: 	}
1: 
1: 
1: 	/**
1: 	 * Set the appropriate entry in the subquery tracking array for
1: 	 * the specified subquery.
1: 	 * Useful for closing down open subqueries on an exception.
1: 	 *
1: 	 * @param subqueryNumber	The subquery # for this subquery
1: 	 * @param subqueryResultSet	The ResultSet at the top of the subquery
1: 	 * @param numSubqueries		The total # of subqueries in the entire query
1: 	 *
1: 	 * @exception StandardException thrown on error.
0: 	 * @return Nothing.
1: 	 */
1: 	public void setSubqueryResultSet(int subqueryNumber,
1: 									 NoPutResultSet subqueryResultSet,
1: 									 int numSubqueries)
1: 		throws StandardException
1: 	{
1: 		pleaseBeOnStack();
1: 		
1: 		/* NOTE: In degenerate cases, it is possible that there is no top
1: 		 * result set.  For example:
1: 		 *		call (select 1 from systables).valueOf('111');
1: 		 * In that case, we allocate our own subquery tracking array on
1: 		 * each call. (Gross!)
1: 		 * (Trust me, this is only done in degenerate cases.  The tests passed,
1: 		 * except for the degenerate cases, before making this change, so we
1: 		 * know that the top result set and array reuse is working for
1: 		 * the non-degenerate cases.)
1: 		 */
1: 		if (subqueryTrackingArray == null)
1: 		{
1: 			if (topResultSet == null)
1: 			{
1: 				subqueryTrackingArray = new NoPutResultSet[numSubqueries];
1: 				materializedSubqueries = new NoPutResultSet[numSubqueries];
1: 			}
1: 			else
1: 			{
1: 				subqueryTrackingArray = 
1: 					topResultSet.getSubqueryTrackingArray(numSubqueries);
1: 			}
1: 		}
1: 		subqueryTrackingArray[subqueryNumber] = subqueryResultSet;
1: 		if (materializedSubqueries != null)
1: 		{
1: 			materializedSubqueries[subqueryNumber] = subqueryResultSet;
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Get the subquery tracking array for this query.
1: 	 * (Useful for runtime statistics.)
1: 	 *
1: 	 * @return NoPutResultSet[]	The	(sparse) array of tops of subquery ResultSet trees
1: 	 * @exception StandardException thrown on error.
1: 	 */
1: 	public NoPutResultSet[] getSubqueryTrackingArray()
1: 		throws StandardException
1: 	{
1: 		pleaseBeOnStack();
1: 		
1: 		return subqueryTrackingArray;
1: 	}
1: 
1: 	/**
1: 	 * Track a Dependency within this StatementContext.
1: 	 * (We need to clear any dependencies added within this
1: 	 * context on an error.
1: 	 *
1: 	 * @param dy	The dependency to track.
1: 	 *
0: 	 * @return Nothing.
1: 	 * @exception StandardException thrown on error.
1: 	 */
1: 	public void addDependency(Dependency dy)
1: 		throws StandardException
1: 	{
1: 		pleaseBeOnStack();
1: 		
1: 		if (dependencies == null)
1: 		{
0: 			dependencies = new ArrayList();
1: 		}
1: 		dependencies.add(dy);
1: 	}
1: 
1: 	/**
1: 	 * Returns whether we started from within the context of a trigger
1: 	 * or not.
1: 	 *
1: 	 * @return	true if we are in a trigger context
1: 	 */
1: 	public	boolean	inTrigger()
1: 	{
1: 		return	parentInTrigger;
1: 	}
1: 
1: 	//
1: 	// Context interface
1: 	//
1: 	/**
1: 	 * Close down the top ResultSet, if relevant, and rollback to the
1: 	 * internal savepoint, if one was set.
1: 	 *
1: 	 * @exception StandardException thrown on error. REVISIT: don't want
1: 	 * cleanupOnError's to throw exceptions.
1: 	 */
1: 	public void cleanupOnError(Throwable error) throws StandardException
1: 	{
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			if (SanityManager.DEBUG_ON("traceSavepoints"))
1: 			{
1: 				SanityManager.DEBUG_PRINT(
1: 						"GenericStatementContext.cleanupOnError()",
1: 						String.valueOf( hashCode() ) );
1: 			}
1: 		}
1: 
1: 		/*
1: 		** If it isn't a StandardException, then assume
0: 		** xact severity.  It is probably an unexpected
1: 		** java error somewhere in the language.
1: 		*/
0: 		int severity = (error instanceof StandardException) ?
0: 			((StandardException) error).getSeverity() :
0: 			ExceptionSeverity.STATEMENT_SEVERITY;
1: 
1: 
1: 		/**
1: 		 * Don't clean up this statement context if it's not in use.
1: 		 * This can happen if you get an error while calling one of
1: 		 * the JDBC getxxxx() methods on a ResultSet, since no statement
1: 		 * context is pushed when those calls occur.
1: 		 */
1: 		if (! inUse)
1: 		{
1: 			return;
1: 		}
1: 
1: 		/* Clean up the ResultSet, if one exists */
1: 		if (topResultSet != null)
1: 		{
1: 			topResultSet.cleanUp();
1: 		}
1: 
1: 		/* Close down any open subqueries */
1: 		if (subqueryTrackingArray != null)
1: 		{
1: 			for (int index = 0; index < subqueryTrackingArray.length; index++)
1: 			{
1: 				/* Remember, the array is sparse, so only check
1: 				 * non-null entries.
1: 				 */
1: 				if (subqueryTrackingArray[index] != null)
1: 				{
1: 					subqueryTrackingArray[index].cleanUp();
1: 				}
1: 			}
1: 		}
1: 
1: 		/* Clean up any dependencies */
1: 		if (dependencies != null)
1: 		{
1: 			DependencyManager dmgr = lcc.getDataDictionary().getDependencyManager();
1: 
0: 			for (Iterator iterator = dependencies.iterator(); iterator.hasNext(); ) 
1: 			{
0: 				Dependency dy = (Dependency) iterator.next();
1: 				dmgr.clearInMemoryDependency(dy);
1: 			}
1: 
1: 			dependencies = null;
1: 		}
1: 
1: 		if (severity <= ExceptionSeverity.STATEMENT_SEVERITY
1: 			&& setSavePoint)
1: 		{
1: 			if (SanityManager.DEBUG)
1: 			{
1: 				if (SanityManager.DEBUG_ON("traceSavepoints"))
1: 				{
1: 					SanityManager.DEBUG_PRINT(
1: 						"GenericStatementContext.cleanupOnError",
1: 						"rolling back to: " + internalSavePointName);
1: 				}
1: 			}
1: 
1: 			lcc.internalRollbackToSavepoint( internalSavePointName, false, null);
1: 
1: 			clearSavePoint();
1: 		}
1: 
1: 		if (severity >= ExceptionSeverity.TRANSACTION_SEVERITY )
1: 		{
1: 			// transaction severity errors roll back the transaction.
1: 
1: 			/*
1: 			** We call clearSavePoint() above only for statement errors.
1: 			** We don't call clearSavePoint() for transaction errors because
1: 			** the savepoint will be rolled back anyway.  So in this case,
1: 			** we need to indicate that the savepoint is not set.
1: 			*/
1: 			setSavePoint = false;
1: 		}
1: 
1: 		/* Pop the context */
1: 		lcc.popStatementContext(this, error);
1: 	}
1: 
1: 	/**
1: 	 * @see Context#isLastHandler
1: 	 */
1: 	public boolean isLastHandler(int severity)
1: 	{
0: 		return inUse && !rollbackParentContext && ((severity == ExceptionSeverity.STATEMENT_SEVERITY) ||
0: 						(severity == ExceptionSeverity.NO_APPLICABLE_SEVERITY));
1: 	}
1: 
1: 	/**
1: 	  *	Reports whether this StatementContext is on the context stack.
1: 	  *
1: 	  *	@return	true if this StatementContext is on the context stack. false otherwise.
1: 	  */
1:     public	boolean	onStack() { return inUse; }
1: 
1: 	/**
1: 	 * Indicates whether the statement needs to be executed atomically
1: 	 * or not, i.e., whether a commit/rollback is permitted by a
1:  	 * connection nested in this statement.
1: 	 *
1: 	 * @return true if needs to be atomic
1: 	 */
1: 	public boolean isAtomic()
1: 	{
1: 		return isAtomic;
1: 	}
1: 
1: 	/**
1: 	 * Return the text of the current statement.
1: 	 * Note that this may be null.  It is currently
1: 	 * not set up correctly for ResultSets that aren't
1: 	 * single row result sets (e.g SELECT), replication,
1: 	 * and setXXXX/getXXXX jdbc methods.
1: 	 *
1: 	 * @return the statement text
1: 	 */
1: 	public String getStatementText()
1: 	{
1: 		return stmtText;
1: 	}
1: 
1: 	//
1: 	// class implementation
1: 	//
1: 
1: 	/**
1: 	  *	Raise an exception if this Context is not in use, that is, on the
1: 	  * Context Stack.
1: 	  *
1: 	  * @exception StandardException thrown on error.
1: 	  */
1: 	private	void	pleaseBeOnStack() throws StandardException
1: 	{
1: 		if ( !inUse ) { throw StandardException.newException(SQLState.LANG_DEAD_STATEMENT); }
1: 	}
1: 
1: 	public boolean inUse()
1: 	{
1: 		return inUse;
1: 	}
1: 
1: 	public void setSQLAllowed(short allow, boolean force) {
1: 
1: 		// cannot override a stricter setting.
1: 		// -1 is no routine restriction in place
1: 		// 0 is least restrictive
1: 		// 4 is most
1: 		if (force || (allow > sqlAllowed))
1: 			sqlAllowed = allow;
1: 
1: 	}
1: 	public short getSQLAllowed() {
1: 		if (!inUse)
1: 			return org.apache.derby.catalog.types.RoutineAliasInfo.NO_SQL;
1: 
1: 		return sqlAllowed;
1: 	}
1: 
1: 	/**
1: 	 * Indicate that, in the event of a statement-level exception,
1: 	 * this context is NOT the last one that needs to be rolled
1: 	 * back--rather, it is nested within some other statement
1: 	 * context, and that other context needs to be rolled back,
1: 	 * too.
1: 	*/
1: 	public void setParentRollback() {
1: 		rollbackParentContext = true;
1: 	}
1: 
1: 	/**
1: 		Set to indicate statement is system code.
1: 		For example a system procedure, view, function etc.
1: 	*/
1: 	public void setSystemCode() {
1: 		isSystemCode = true;
1: 	}
1: 
1: 	/**
1: 		Return true if this statement is system code.
1: 	*/
1: 	public boolean getSystemCode() {
1: 		return isSystemCode;
1: 	}
1: 
1: 	public StringBuffer appendErrorInfo() {
1: 
1: 		StringBuffer sb = ((ContextImpl) lcc).appendErrorInfo();
1: 		if (sb != null) {
1: 
1: 			sb.append("Failed Statement is: ");
1: 
1: 			sb.append(getStatementText());
1: 
0: 			if (lcc.getLogStatementText() && (pvs != null) && pvs.getParameterCount() > 0)
1: 			{
1: 				String pvsString = " with " + pvs.getParameterCount() +
1: 						" parameters " + pvs.toString();
1: 				sb.append(pvsString);
1: 			}
1: 		}
1: 		return sb;
1: 
1: 	}
1: }
author:David Van Couvering
-------------------------------------------------------------------------------
commit:575d6a1
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Bernt Johnsen
-------------------------------------------------------------------------------
commit:5087be8
/////////////////////////////////////////////////////////////////////////
1:     private	boolean		isForReadOnly = false;	
/////////////////////////////////////////////////////////////////////////
1:                 boolean isForReadOnly,
/////////////////////////////////////////////////////////////////////////
1: 		this.isForReadOnly = isForReadOnly;
/////////////////////////////////////////////////////////////////////////
1: 		isForReadOnly = false;
/////////////////////////////////////////////////////////////////////////
1:     public boolean isForReadOnly()
1:     {
1: 	return isForReadOnly;
0:     }
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.conn
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.sql.conn;
0: 
0: import org.apache.derby.iapi.services.context.Context;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: import org.apache.derby.iapi.sql.conn.StatementContext;
0: 
0: import org.apache.derby.iapi.sql.depend.Dependency;
0: import org.apache.derby.iapi.sql.depend.DependencyManager;
0: 
0: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
0: 
0: import org.apache.derby.iapi.sql.ResultSet;
0: import org.apache.derby.iapi.sql.ParameterValueSet;
0: 
0: import org.apache.derby.iapi.store.access.TransactionController;
0: 
0: import org.apache.derby.iapi.services.context.ContextImpl;
0: 
0: import org.apache.derby.iapi.error.ExceptionSeverity;
0: import org.apache.derby.iapi.reference.SQLState;
0: import java.util.ArrayList;
0: import java.util.Iterator;
0: import java.sql.SQLException;
0: 
0: /**
0:  * GenericStatementContext is pushed/popped around a statement prepare and execute
0:  * so that any statement specific clean up can be performed.
0:  *
0:  * @author jerry
0:  *
0:  */
0: final class GenericStatementContext 
0: 	extends ContextImpl implements StatementContext
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	private final TransactionController tc;
0: 
0: 	private boolean		setSavePoint;
0: 	private String		internalSavePointName;
0: 	private ResultSet	topResultSet;
0: 	private ArrayList		dependencies;
0: 	private NoPutResultSet[] subqueryTrackingArray;
0: 	private NoPutResultSet[] materializedSubqueries;
0: 	private	final LanguageConnectionContext lcc;
0: 	private boolean		inUse = true;
0:     private	boolean		parentInTrigger;	// whetherparent started with a trigger on stack
0:     private	boolean		isAtomic;	
0: 	private boolean		isSystemCode;
0: 	private boolean		rollbackParentContext;
0:     private	String		stmtText;
0:     private	ParameterValueSet			pvs;
0: 
0: 	/**
0: 		Set to one of RoutineAliasInfo.{MODIFIES_SQL_DATA, READS_SQL_DATA, CONTAINS_SQL, NO_SQL}
0: 	*/
0: 	private short			sqlAllowed = -1;
0: 
0: 	/*
0: 	   constructor
0: 		@param tc transaction
0: 	*/
0: 	GenericStatementContext(LanguageConnectionContext lcc, TransactionController tc) 
0: 	{
0: 		super(lcc.getContextManager(), org.apache.derby.iapi.reference.ContextId.LANG_STATEMENT);
0: 		this.lcc = lcc;
0: 		this.tc = tc;
0: 
0: 		internalSavePointName = "ISSP" + hashCode();
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT((lcc != null),
0: 					"Failed to get language connection context");
0: 		}
0: 
0: 	}
0: 
0: 	// StatementContext Interface
0: 
0: 	public void setInUse
0: 	( 
0: 		boolean parentInTrigger,
0: 		boolean isAtomic, 
0: 		String stmtText,
0: 		ParameterValueSet pvs
0: 	) 
0: 	{
0: 		inUse = true;
0: 
0: 		this.parentInTrigger = parentInTrigger;
0: 		this.isAtomic = isAtomic;
0: 		this.stmtText = stmtText;
0: 		this.pvs = pvs;
0: 		rollbackParentContext = false;
0: 	}
0: 
0: 	public void clearInUse() {
0: 		/* We must clear out the current top ResultSet to prepare for
0: 		 * reusing a StatementContext.
0: 		 */
0: 		stuffTopResultSet( null, null );
0: 		inUse = false;
0: 
0: 		parentInTrigger = false;
0: 		isAtomic = false;
0: 		this.stmtText = null;
0: 		sqlAllowed = -1;
0: 		isSystemCode = false;
0: 		rollbackParentContext = false;
0: 	}
0: 
0: 	/**
0: 	 * @see StatementContext#setSavePoint
0: 	 * @exception StandardException Thrown on error
0: 	 */
0: 	public void setSavePoint() throws StandardException {
0: 		
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (SanityManager.DEBUG_ON("traceSavepoints"))
0: 			{
0: 				SanityManager.DEBUG_PRINT(
0: 									"GenericStatementContext.setSavePoint()",
0: 									internalSavePointName);
0: 			}
0: 		}
0: 			
0: 		pleaseBeOnStack();
0: 		
0: 
0: 		// RESOLVE PLUGIN ???. For the plugin, there will be no transaction controller
0: 		if ( tc != null ) { tc.setSavePoint(internalSavePointName, null); }
0: 		setSavePoint = true;
0: 	}
0: 
0: 	/**
0: 	 * Resets the savepoint to the current spot if it is
0: 	 * set, otherwise, noop.  Used when a commit is
0: 	 * done on a nested connection.
0: 	 *
0: 	 * @see StatementContext#resetSavePoint
0: 	 * @exception StandardException Thrown on error
0: 	 */
0: 	public void resetSavePoint() throws StandardException {
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (SanityManager.DEBUG_ON("traceSavepoints"))
0: 			{
0: 				SanityManager.DEBUG_PRINT(
0: 					"GenericStatementContext.resetSavePoint()",
0: 					internalSavePointName);
0: 			}
0: 		}
0: 			
0: 		if (inUse && setSavePoint)
0: 		{		
0: 			// RESOLVE PLUGIN ???. For the plugin, there will be no transaction controller
0: 			if ( tc != null ) { tc.setSavePoint(internalSavePointName, null); }
0: 			// stage buffer management
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * @see StatementContext#clearSavePoint
0: 	 * @exception StandardException Thrown on error
0: 	 */
0: 	public void clearSavePoint() throws StandardException {
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (SanityManager.DEBUG_ON("traceSavepoints"))
0: 			{
0: 				SanityManager.DEBUG_PRINT("GenericStatementContext.clearSavePoint()",
0: 										  internalSavePointName);
0: 			}
0: 		}
0: 
0: 		pleaseBeOnStack();
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(setSavePoint, "setSavePoint is expected to be true");
0: 		}
0: 
0: 		// RESOLVE PLUGIN ???. For the plugin, there will be no transaction controller
0: 		if ( tc != null ) { tc.releaseSavePoint(internalSavePointName, null); }
0: 		setSavePoint = false;
0: 	}
0: 
0: 	/**
0: 	 * Set the top ResultSet in the ResultSet tree for close down on
0: 	 * an error.
0: 	 *
0: 	 * @exception StandardException thrown on error.
0: 	 * @return Nothing.
0: 	 */
0: 	public void setTopResultSet(ResultSet topResultSet, 
0: 							    NoPutResultSet[] subqueryTrackingArray)
0: 		 throws StandardException
0: 	{
0: 		pleaseBeOnStack();
0: 
0: 		/* We have to handle both materialize and non-materialized subqueries.
0: 		 * Materialized subqueries are attached before the top result set is 
0: 		 * set.  If there are any, then we must copy them into the new
0: 		 * subqueryTrackingArray.
0: 		 */
0: 		if (materializedSubqueries != null)
0: 		{
0: 			// Do the merging into the passed in array.
0: 			if (subqueryTrackingArray != null)
0: 			{
0: 				if (SanityManager.DEBUG)
0: 				{
0: 					if (this.materializedSubqueries.length != subqueryTrackingArray.length)
0: 					{
0: 						SanityManager.THROWASSERT(
0: 							"this.ms.length (" + this.materializedSubqueries.length +
0: 							") expected to = sta.length(" + subqueryTrackingArray.length +
0: 							")");
0: 					}
0: 				}
0: 				for (int index = 0; index < subqueryTrackingArray.length; index++)
0: 				{
0: 					if (this.subqueryTrackingArray[index] != null)
0: 					{
0: 						subqueryTrackingArray[index] = this.materializedSubqueries[index];
0: 					}
0: 				}
0: 			}
0: 			else
0: 			{
0: 				subqueryTrackingArray = this.materializedSubqueries;
0: 			}
0: 			materializedSubqueries = null;
0: 		}
0: 
0: 		stuffTopResultSet( topResultSet, subqueryTrackingArray );
0: 	}
0: 
0: 	/**
0: 	  *	Private minion of setTopResultSet() and clearInUse()
0: 	  *
0: 	  *	@param	topResultSet	make this the top result set
0: 	  *	@param	subqueryTrackingArray	where to keep track of subqueries in this statement
0: 	  *
0: 	  * @return Nothing.
0: 	  */
0: 	private	void	stuffTopResultSet(ResultSet topResultSet, 
0: 									  NoPutResultSet[] subqueryTrackingArray)
0: 	{
0: 		this.topResultSet = topResultSet;
0: 		this.subqueryTrackingArray = subqueryTrackingArray;
0: 		dependencies = null;
0: 	}
0: 
0: 
0: 	/**
0: 	 * Set the appropriate entry in the subquery tracking array for
0: 	 * the specified subquery.
0: 	 * Useful for closing down open subqueries on an exception.
0: 	 *
0: 	 * @param subqueryNumber	The subquery # for this subquery
0: 	 * @param subqueryResultSet	The ResultSet at the top of the subquery
0: 	 * @param numSubqueries		The total # of subqueries in the entire query
0: 	 *
0: 	 * @exception StandardException thrown on error.
0: 	 * @return Nothing.
0: 	 */
0: 	public void setSubqueryResultSet(int subqueryNumber,
0: 									 NoPutResultSet subqueryResultSet,
0: 									 int numSubqueries)
0: 		throws StandardException
0: 	{
0: 		pleaseBeOnStack();
0: 		
0: 		/* NOTE: In degenerate cases, it is possible that there is no top
0: 		 * result set.  For example:
0: 		 *		call (select 1 from systables).valueOf('111');
0: 		 * In that case, we allocate our own subquery tracking array on
0: 		 * each call. (Gross!)
0: 		 * (Trust me, this is only done in degenerate cases.  The tests passed,
0: 		 * except for the degenerate cases, before making this change, so we
0: 		 * know that the top result set and array reuse is working for
0: 		 * the non-degenerate cases.)
0: 		 */
0: 		if (subqueryTrackingArray == null)
0: 		{
0: 			if (topResultSet == null)
0: 			{
0: 				subqueryTrackingArray = new NoPutResultSet[numSubqueries];
0: 				materializedSubqueries = new NoPutResultSet[numSubqueries];
0: 			}
0: 			else
0: 			{
0: 				subqueryTrackingArray = 
0: 					topResultSet.getSubqueryTrackingArray(numSubqueries);
0: 			}
0: 		}
0: 		subqueryTrackingArray[subqueryNumber] = subqueryResultSet;
0: 		if (materializedSubqueries != null)
0: 		{
0: 			materializedSubqueries[subqueryNumber] = subqueryResultSet;
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Get the subquery tracking array for this query.
0: 	 * (Useful for runtime statistics.)
0: 	 *
0: 	 * @return NoPutResultSet[]	The	(sparse) array of tops of subquery ResultSet trees
0: 	 * @exception StandardException thrown on error.
0: 	 */
0: 	public NoPutResultSet[] getSubqueryTrackingArray()
0: 		throws StandardException
0: 	{
0: 		pleaseBeOnStack();
0: 		
0: 		return subqueryTrackingArray;
0: 	}
0: 
0: 	/**
0: 	 * Track a Dependency within this StatementContext.
0: 	 * (We need to clear any dependencies added within this
0: 	 * context on an error.
0: 	 *
0: 	 * @param dy	The dependency to track.
0: 	 *
0: 	 * @return Nothing.
0: 	 * @exception StandardException thrown on error.
0: 	 */
0: 	public void addDependency(Dependency dy)
0: 		throws StandardException
0: 	{
0: 		pleaseBeOnStack();
0: 		
0: 		if (dependencies == null)
0: 		{
0: 			dependencies = new ArrayList();
0: 		}
0: 		dependencies.add(dy);
0: 	}
0: 
0: 	/**
0: 	 * Returns whether we started from within the context of a trigger
0: 	 * or not.
0: 	 *
0: 	 * @return	true if we are in a trigger context
0: 	 */
0: 	public	boolean	inTrigger()
0: 	{
0: 		return	parentInTrigger;
0: 	}
0: 
0: 	//
0: 	// Context interface
0: 	//
0: 	/**
0: 	 * Close down the top ResultSet, if relevant, and rollback to the
0: 	 * internal savepoint, if one was set.
0: 	 *
0: 	 * @exception StandardException thrown on error. REVISIT: don't want
0: 	 * cleanupOnError's to throw exceptions.
0: 	 */
0: 	public void cleanupOnError(Throwable error) throws StandardException
0: 	{
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (SanityManager.DEBUG_ON("traceSavepoints"))
0: 			{
0: 				SanityManager.DEBUG_PRINT(
0: 						"GenericStatementContext.cleanupOnError()",
0: 						String.valueOf( hashCode() ) );
0: 			}
0: 		}
0: 
0: 		/*
0: 		** If it isn't a StandardException, then assume
0: 		** xact severity.  It is probably an unexpected
0: 		** java error somewhere in the language.
0: 		*/
0: 		int severity = (error instanceof StandardException) ?
0: 			((StandardException) error).getSeverity() :
0: 			ExceptionSeverity.STATEMENT_SEVERITY;
0: 
0: 
0: 		/**
0: 		 * Don't clean up this statement context if it's not in use.
0: 		 * This can happen if you get an error while calling one of
0: 		 * the JDBC getxxxx() methods on a ResultSet, since no statement
0: 		 * context is pushed when those calls occur.
0: 		 */
0: 		if (! inUse)
0: 		{
0: 			return;
0: 		}
0: 
0: 		/* Clean up the ResultSet, if one exists */
0: 		if (topResultSet != null)
0: 		{
0: 			topResultSet.cleanUp();
0: 		}
0: 
0: 		/* Close down any open subqueries */
0: 		if (subqueryTrackingArray != null)
0: 		{
0: 			for (int index = 0; index < subqueryTrackingArray.length; index++)
0: 			{
0: 				/* Remember, the array is sparse, so only check
0: 				 * non-null entries.
0: 				 */
0: 				if (subqueryTrackingArray[index] != null)
0: 				{
0: 					subqueryTrackingArray[index].cleanUp();
0: 				}
0: 			}
0: 		}
0: 
0: 		/* Clean up any dependencies */
0: 		if (dependencies != null)
0: 		{
0: 			DependencyManager dmgr = lcc.getDataDictionary().getDependencyManager();
0: 
0: 			for (Iterator iterator = dependencies.iterator(); iterator.hasNext(); ) 
0: 			{
0: 				Dependency dy = (Dependency) iterator.next();
0: 				dmgr.clearInMemoryDependency(dy);
0: 			}
0: 
0: 			dependencies = null;
0: 		}
0: 
0: 		if (severity <= ExceptionSeverity.STATEMENT_SEVERITY
0: 			&& setSavePoint)
0: 		{
0: 			if (SanityManager.DEBUG)
0: 			{
0: 				if (SanityManager.DEBUG_ON("traceSavepoints"))
0: 				{
0: 					SanityManager.DEBUG_PRINT(
0: 						"GenericStatementContext.cleanupOnError",
0: 						"rolling back to: " + internalSavePointName);
0: 				}
0: 			}
0: 
0: 			lcc.internalRollbackToSavepoint( internalSavePointName, false, null);
0: 
0: 			clearSavePoint();
0: 		}
0: 
0: 		if (severity >= ExceptionSeverity.TRANSACTION_SEVERITY )
0: 		{
0: 			// transaction severity errors roll back the transaction.
0: 
0: 			/*
0: 			** We call clearSavePoint() above only for statement errors.
0: 			** We don't call clearSavePoint() for transaction errors because
0: 			** the savepoint will be rolled back anyway.  So in this case,
0: 			** we need to indicate that the savepoint is not set.
0: 			*/
0: 			setSavePoint = false;
0: 		}
0: 
0: 		/* Pop the context */
0: 		lcc.popStatementContext(this, error);
0: 	}
0: 
0: 	/**
0: 	 * @see Context#isLastHandler
0: 	 */
0: 	public boolean isLastHandler(int severity)
0: 	{
0: 		return inUse && !rollbackParentContext && ((severity == ExceptionSeverity.STATEMENT_SEVERITY) ||
0: 						(severity == ExceptionSeverity.NO_APPLICABLE_SEVERITY));
0: 	}
0: 
0: 	/**
0: 	  *	Reports whether this StatementContext is on the context stack.
0: 	  *
0: 	  *	@return	true if this StatementContext is on the context stack. false otherwise.
0: 	  */
0:     public	boolean	onStack() { return inUse; }
0: 
0: 	/**
0: 	 * Indicates whether the statement needs to be executed atomically
0: 	 * or not, i.e., whether a commit/rollback is permitted by a
0:  	 * connection nested in this statement.
0: 	 *
0: 	 * @return true if needs to be atomic
0: 	 */
0: 	public boolean isAtomic()
0: 	{
0: 		return isAtomic;
0: 	}
0: 
0: 	/**
0: 	 * Return the text of the current statement.
0: 	 * Note that this may be null.  It is currently
0: 	 * not set up correctly for ResultSets that aren't
0: 	 * single row result sets (e.g SELECT), replication,
0: 	 * and setXXXX/getXXXX jdbc methods.
0: 	 *
0: 	 * @return the statement text
0: 	 */
0: 	public String getStatementText()
0: 	{
0: 		return stmtText;
0: 	}
0: 
0: 	//
0: 	// class implementation
0: 	//
0: 
0: 	/**
0: 	  *	Raise an exception if this Context is not in use, that is, on the
0: 	  * Context Stack.
0: 	  *
0: 	  * @exception StandardException thrown on error.
0: 	  */
0: 	private	void	pleaseBeOnStack() throws StandardException
0: 	{
0: 		if ( !inUse ) { throw StandardException.newException(SQLState.LANG_DEAD_STATEMENT); }
0: 	}
0: 
0: 	public boolean inUse()
0: 	{
0: 		return inUse;
0: 	}
0: 
0: 	public void setSQLAllowed(short allow, boolean force) {
0: 
0: 		// cannot override a stricter setting.
0: 		// -1 is no routine restriction in place
0: 		// 0 is least restrictive
0: 		// 4 is most
0: 		if (force || (allow > sqlAllowed))
0: 			sqlAllowed = allow;
0: 
0: 	}
0: 	public short getSQLAllowed() {
0: 		if (!inUse)
0: 			return org.apache.derby.catalog.types.RoutineAliasInfo.NO_SQL;
0: 
0: 		return sqlAllowed;
0: 	}
0: 
0: 	/**
0: 	 * Indicate that, in the event of a statement-level exception,
0: 	 * this context is NOT the last one that needs to be rolled
0: 	 * back--rather, it is nested within some other statement
0: 	 * context, and that other context needs to be rolled back,
0: 	 * too.
0: 	*/
0: 	public void setParentRollback() {
0: 		rollbackParentContext = true;
0: 	}
0: 
0: 	/**
0: 		Set to indicate statement is system code.
0: 		For example a system procedure, view, function etc.
0: 	*/
0: 	public void setSystemCode() {
0: 		isSystemCode = true;
0: 	}
0: 
0: 	/**
0: 		Return true if this statement is system code.
0: 	*/
0: 	public boolean getSystemCode() {
0: 		return isSystemCode;
0: 	}
0: 
0: 	public StringBuffer appendErrorInfo() {
0: 
0: 		StringBuffer sb = ((ContextImpl) lcc).appendErrorInfo();
0: 		if (sb != null) {
0: 
0: 			sb.append("Failed Statement is: ");
0: 
0: 			sb.append(getStatementText());
0: 
0: 			if (lcc.getLogStatementText() && (pvs != null) && pvs.getParameterCount() > 0)
0: 			{
0: 				String pvsString = " with " + pvs.getParameterCount() +
0: 						" parameters " + pvs.toString();
0: 				sb.append(pvsString);
0: 			}
0: 		}
0: 		return sb;
0: 
0: 	}
0: }
============================================================================