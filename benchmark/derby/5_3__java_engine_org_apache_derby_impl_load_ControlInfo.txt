1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.load.ControlInfo
1:345de35: 
1:6d913c6:    Licensed to the Apache Software Foundation (ASF) under one or more
1:6d913c6:    contributor license agreements.  See the NOTICE file distributed with
1:6d913c6:    this work for additional information regarding copyright ownership.
1:6d913c6:    The ASF licenses this file to You under the Apache License, Version 2.0
1:6d913c6:    (the "License"); you may not use this file except in compliance with
1:6d913c6:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
3:eac0369: 
2:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.load;
1:eac0369: 
1:eac0369: import java.io.PrintStream;
1:eac0369: import java.io.InputStream;
1:eac0369: import java.io.InputStreamReader;
1:eac0369: import java.util.Date;
1:eac0369: import java.util.Properties;
1:eac0369: 
1:eac0369: //read the control file properties. If the passed parameter for control file
1:eac0369: //name is null, assigns default values to the properties. Also, if the control
1:eac0369: //file has message property in it, it sends the errors to that file by
1:eac0369: //redirecting system err to that message file
1:eac0369: class ControlInfo
1:eac0369: {
1:eac0369: 
1:eac0369:   static final String ESCAPE = "Escape";
1:eac0369:   static final String DEFAULT_ESCAPE = "\\";
1:eac0369:   static final String QUOTE = "Quote";
1:eac0369:   static final String DEFAULT_QUOTE = "'";
1:eac0369:   static final String COMMIT_COUNT = "CommitCount";
1:eac0369:   static final String DEFAULT_COMMIT_COUNT = "0";
1:eac0369:   static final String START_ROW = "StartRow";
1:eac0369:   static final String DEFAULT_START_ROW = "1";
1:eac0369:   static final String STOP_ROW = "StopRow";
1:eac0369:   static final String DEFAULT_STOP_ROW = "0";
1:eac0369: 
1:eac0369:   static final String FIELD_SEPARATOR = "FieldSeparator";
1:eac0369:   static final String DEFAULT_FIELD_SEPARATOR = ",";
1:eac0369:   static final String RECORD_SEPARATOR = "RecordSeparator";
1:eac0369:   static final String DEFAULT_RECORD_SEPARATOR = System.getProperty("line.separator");
1:eac0369:   static final String COLUMN_DEFINITION = "ColumnDefinition";
1:eac0369:   static final String DEFAULT_COLUMN_DEFINITION = "FALSE";
1:eac0369:   static final String NULL_STRING = "Null";
1:eac0369:   static final String DEFAULT_NULL_STRING = "NULL";
1:eac0369:   static final String FORMAT = "Format";
1:eac0369:   static final String DEFAULT_FORMAT = "ASCII_DELIMITED";
1:eac0369:   static final String DB2_DELIMITED_FORMAT = "DB2_DELIMITED";  //beetle 5007
1:eac0369:   static final String FIELD_START_DELIMITER = "FieldStartDelimiter";
1:eac0369:   static final String DEFAULT_FIELD_START_DELIMITER = "\"";
1:eac0369:   static final String FIELD_END_DELIMITER = "FieldEndDelimiter";
1:eac0369:   static final String DEFAULT_FIELD_END_DELIMITER = "\"";
1:eac0369:   static final String COLUMN_WIDTHS = "ColumnWidths";
1:eac0369:   static final String MESSAGE_FILE = "MessageFile";
1:eac0369:   static final String DEFAULT_VERSION = "1";
1:eac0369:   static final String VERSION = "Version";
1:eac0369:   static final String NEWLINE = "\n";
1:eac0369:   static final String COMMA = ",";
1:eac0369:   static final String SPACE = " ";
1:eac0369:   static final String TAB = "\t";
1:eac0369:   static final String CR = "\r";
1:eac0369:   static final String LF = "\n";
1:eac0369:   static final String CRLF = "\r\n";
1:eac0369:   static final String LFCR = "\n\r";
1:eac0369:   static final String FF = "\f";
1:eac0369:   static final String EMPTY_LINE = "\n\n";
1:eac0369:   static final String SEMICOLON = ";";
1:eac0369:   static final String DATA_CODESET = "DataCodeset";
1:eac0369:   static final String HAS_DELIMETER_AT_END = "HasDelimeterAtEnd";
1:eac0369: 
1:eac0369:   static final String INTERNAL_NONE = "None";
1:eac0369:   static final String INTERNAL_TRUE = "True";
1:eac0369:   static final String INTERNAL_FALSE = "False";
1:eac0369:   static final String INTERNAL_TAB = "Tab";
1:eac0369:   static final String INTERNAL_SPACE = "Space";
1:eac0369:   static final String INTERNAL_CR = "CR";
1:eac0369:   static final String INTERNAL_LF = "LF";
1:eac0369:   static final String INTERNAL_CRLF = "CR-LF";
1:eac0369:   static final String INTERNAL_LFCR = "LF-CR";
1:eac0369:   static final String INTERNAL_COMMA = "Comma";
1:eac0369:   static final String INTERNAL_SEMICOLON = "Semicolon";
1:eac0369:   static final String INTERNAL_NEWLINE = "New Line";
1:eac0369:   static final String INTERNAL_FF = "FF";
1:eac0369:   static final String INTERNAL_EMPTY_LINE = "Empty line";
1:eac0369: 
1:eac0369:   private Properties currentProperties;
1:eac0369: 
1:eac0369:   public ControlInfo() throws Exception  {
1:eac0369:     getCurrentProperties();
1:eac0369:     //the field and record separators can't be subset of each other
1:eac0369:     if (getFieldSeparator().indexOf(getRecordSeparator()) != -1) {
1:eac0369:        throw LoadError.fieldAndRecordSeparatorsSubset();
1:eac0369:     }
1:eac0369:   }
1:eac0369: 
1:eac0369:   //read the value of a given property
1:eac0369:   String getPropertyValue(String aKey) throws Exception {
1:eac0369:     return getCurrentProperties().getProperty(aKey);
1:eac0369:    }
1:eac0369: 
1:eac0369:   //following are the default values for few of the properties
1:eac0369:   private void loadDefaultValues() {
1:eac0369:     currentProperties = new Properties();
1:eac0369:     currentProperties.put(FIELD_SEPARATOR, DEFAULT_FIELD_SEPARATOR);
1:eac0369:     currentProperties.put(RECORD_SEPARATOR, DEFAULT_RECORD_SEPARATOR);
1:eac0369:     currentProperties.put(COLUMN_DEFINITION, DEFAULT_COLUMN_DEFINITION);
1:eac0369:     currentProperties.put(NULL_STRING, DEFAULT_NULL_STRING);
1:eac0369:     currentProperties.put(FORMAT, DEFAULT_FORMAT);
1:eac0369:     currentProperties.put(FIELD_START_DELIMITER, DEFAULT_FIELD_START_DELIMITER);
1:eac0369:     currentProperties.put(FIELD_END_DELIMITER, DEFAULT_FIELD_END_DELIMITER);
1:eac0369:     currentProperties.put(VERSION, DEFAULT_VERSION);
1:eac0369:     currentProperties.put(HAS_DELIMETER_AT_END, INTERNAL_FALSE);
1:eac0369:   }
1:eac0369: 
1:eac0369:   //get control file version.
1:eac0369:   String getCurrentVersion() throws Exception {
1:eac0369:     return(DEFAULT_VERSION);
1:eac0369:   }
1:eac0369: 
1:eac0369:   //2 possible formats: fixed and delimited. default is ASCII_DELIMITED
1:eac0369:   String getFormat() throws Exception {
1:eac0369:     return(getCurrentProperties().getProperty(FORMAT));
1:eac0369:   }
1:eac0369: 
1:eac0369:   //read the column widths property which is comma delimited.
1:eac0369:   //In case of fixed format, if column widths are missing, it will
1:eac0369:   //throw an exception
1:eac0369:   int[] getColumnWidths() {
1:eac0369:       return null;
1:eac0369:   }
1:eac0369: 
1:eac0369:   //default is DEFAULT_FIELD_SEPARATOR
1:eac0369:   String getFieldSeparator() throws Exception {
1:eac0369:     String fieldSeparator = getCurrentProperties().getProperty(FIELD_SEPARATOR);
1:eac0369:     fieldSeparator = mapFromUserFriendlyFieldDelimiters(fieldSeparator);
1:eac0369:     return fieldSeparator;
1:eac0369:   }
1:eac0369: 
1:eac0369:   String getFieldStartDelimiter() throws Exception {
1:eac0369:     return(getCurrentProperties().getProperty(FIELD_START_DELIMITER));
1:eac0369:   }
1:eac0369: 
1:eac0369:   String getFieldEndDelimiter() throws Exception {
1:eac0369:     return(getCurrentProperties().getProperty(FIELD_END_DELIMITER));
1:eac0369:   }
1:eac0369: 
1:eac0369:   String getRecordSeparator() throws Exception {
1:eac0369:     String recordSeparator = getCurrentProperties().getProperty(RECORD_SEPARATOR);
1:eac0369:     recordSeparator = mapFromUserFriendlyRecordDelimiters(recordSeparator);
1:eac0369:     return recordSeparator;
1:eac0369:   }
1:eac0369: 
1:eac0369:   //to be used to cover cases where column delimeters are placed at the end of
1:eac0369:   //each column resulting in an extra delimeter at the end of a row.
1:eac0369:   boolean getHasDelimiterAtEnd() throws Exception {
1:eac0369:     String hasDelimeterAtEnd = getCurrentProperties().getProperty(HAS_DELIMETER_AT_END);
1:eac0369:     return hasDelimeterAtEnd.equals(INTERNAL_TRUE);
1:eac0369:   }
1:eac0369:   String getHasDelimeterAtEndString() throws Exception {
1:eac0369:     String hasDelimeterAtEnd = getCurrentProperties().getProperty(HAS_DELIMETER_AT_END);
1:eac0369:     return hasDelimeterAtEnd;
1:eac0369:   }
1:eac0369:   //if at the time of export, the column has null into it, we will spit
1:eac0369:   //nullString in the output file.
1:eac0369:   //If at the time of import, we see nullString for a column, we will
1:eac0369:   //send null as part of resultSet interface
1:eac0369:   String getNullString() throws Exception {
1:eac0369:     return(getCurrentProperties().getProperty(NULL_STRING));
1:eac0369:   }
1:eac0369: 
1:eac0369:   //for fixed format, get column definitions
1:eac0369:   String getColumnDefinition() throws Exception {
1:eac0369:     return(getCurrentProperties().getProperty(COLUMN_DEFINITION));
1:eac0369:   }
1:eac0369: 
1:eac0369:   private String mapFromUserFriendlyFieldDelimiters(String aDelimiter) {
1:eac0369:     if (aDelimiter.toUpperCase(java.util.Locale.ENGLISH).equals(INTERNAL_TAB.toUpperCase(java.util.Locale.ENGLISH)))
1:eac0369:        return TAB;
1:eac0369:     if (aDelimiter.toUpperCase(java.util.Locale.ENGLISH).equals(INTERNAL_SPACE.toUpperCase(java.util.Locale.ENGLISH)))
1:eac0369:        return SPACE;
1:eac0369:     if (aDelimiter.toUpperCase(java.util.Locale.ENGLISH).equals(INTERNAL_CR.toUpperCase(java.util.Locale.ENGLISH)))
1:eac0369:        return CR;
1:eac0369:     if (aDelimiter.toUpperCase(java.util.Locale.ENGLISH).equals(INTERNAL_LF.toUpperCase(java.util.Locale.ENGLISH)))
1:eac0369:        return LF;
1:eac0369:     if (aDelimiter.toUpperCase(java.util.Locale.ENGLISH).equals(INTERNAL_CRLF.toUpperCase(java.util.Locale.ENGLISH)))
1:eac0369:        return CRLF;
1:eac0369:     if (aDelimiter.toUpperCase(java.util.Locale.ENGLISH).equals(INTERNAL_LFCR.toUpperCase(java.util.Locale.ENGLISH)))
1:eac0369:        return LFCR;
1:eac0369:     if (aDelimiter.toUpperCase(java.util.Locale.ENGLISH).equals(INTERNAL_COMMA.toUpperCase(java.util.Locale.ENGLISH)))
1:eac0369:        return COMMA;
1:eac0369:     if (aDelimiter.toUpperCase(java.util.Locale.ENGLISH).equals(INTERNAL_SEMICOLON.toUpperCase(java.util.Locale.ENGLISH)))
1:eac0369:        return SEMICOLON;
1:eac0369: 
1:eac0369:     aDelimiter = commonToFieldAndRecordDelimiters(aDelimiter, "\\n", '\n');
1:eac0369:     aDelimiter = commonToFieldAndRecordDelimiters(aDelimiter, "\\t", '\t');
1:eac0369:     aDelimiter = commonToFieldAndRecordDelimiters(aDelimiter, "\\r", '\r');
1:eac0369:     aDelimiter = commonToFieldAndRecordDelimiters(aDelimiter, "\\f", '\f');
1:eac0369:     return aDelimiter;
1:eac0369:   }
1:eac0369: 
1:eac0369:   //vjbms: when user types \n in vjbms, it comes as 2 characters \ and n
1:eac0369:   //and not just one character '\n' That's the reason for the following
1:eac0369:   //check. I look for "\n" and replace it with '\n'. Same thing for \t
1:eac0369:   // \r and \f
1:eac0369:   private String commonToFieldAndRecordDelimiters(String aDelimiter,
1:eac0369:   String specialChars, char replacementChar) {
1:eac0369:     String beforeSpecialChars;
1:eac0369:     String afterSpecialChars;
1:eac0369:     int specialCharsPosition;
1:eac0369:     while (aDelimiter.indexOf(specialChars) != -1) {
1:eac0369:       specialCharsPosition = aDelimiter.indexOf(specialChars);
1:eac0369:       beforeSpecialChars = aDelimiter.substring(0,specialCharsPosition);
1:eac0369:       afterSpecialChars = aDelimiter.substring(specialCharsPosition+2);
1:eac0369:       aDelimiter = beforeSpecialChars + replacementChar + afterSpecialChars;
1:eac0369:     }
1:eac0369:     return aDelimiter;
1:eac0369:   }
1:eac0369: 
1:eac0369:   private String mapFromUserFriendlyRecordDelimiters(String aDelimiter) {
1:eac0369:     if (aDelimiter.equals("\n"))
1:eac0369:        aDelimiter = INTERNAL_NEWLINE;
1:eac0369:     if (aDelimiter.toUpperCase(java.util.Locale.ENGLISH).equals(INTERNAL_NEWLINE.toUpperCase(java.util.Locale.ENGLISH)))
1:eac0369:        return NEWLINE;
1:eac0369:     if (aDelimiter.toUpperCase(java.util.Locale.ENGLISH).equals(INTERNAL_CR.toUpperCase(java.util.Locale.ENGLISH)))
1:eac0369:        return CR;
1:eac0369:     if (aDelimiter.toUpperCase(java.util.Locale.ENGLISH).equals(INTERNAL_LF.toUpperCase(java.util.Locale.ENGLISH)))
1:eac0369:        return LF;
1:eac0369:     if (aDelimiter.toUpperCase(java.util.Locale.ENGLISH).equals(INTERNAL_CRLF.toUpperCase(java.util.Locale.ENGLISH)))
1:eac0369:        return CRLF;
1:eac0369:     if (aDelimiter.toUpperCase(java.util.Locale.ENGLISH).equals(INTERNAL_LFCR.toUpperCase(java.util.Locale.ENGLISH)))
1:eac0369:        return LFCR;
1:eac0369:     if (aDelimiter.toUpperCase(java.util.Locale.ENGLISH).equals(INTERNAL_FF.toUpperCase(java.util.Locale.ENGLISH)))
1:eac0369:        return FF;
1:eac0369:     if (aDelimiter.toUpperCase(java.util.Locale.ENGLISH).equals(INTERNAL_EMPTY_LINE.toUpperCase(java.util.Locale.ENGLISH)))
1:eac0369:        return EMPTY_LINE;
1:eac0369: 
1:eac0369:     aDelimiter = commonToFieldAndRecordDelimiters(aDelimiter, "\\n", '\n');
1:eac0369:     aDelimiter = commonToFieldAndRecordDelimiters(aDelimiter, "\\t", '\t');
1:eac0369:     aDelimiter = commonToFieldAndRecordDelimiters(aDelimiter, "\\r", '\r');
1:eac0369:     aDelimiter = commonToFieldAndRecordDelimiters(aDelimiter, "\\f", '\f');
1:eac0369:     return aDelimiter;
1:eac0369:   }
1:eac0369: 
1:18c4da7:   /**
1:18c4da7:    * 
1:18c4da7:    * @return Code set, can return null for use the default code set.
1:18c4da7:    * @throws Exception
1:18c4da7:    */
1:eac0369:   String getDataCodeset() throws Exception {
1:eac0369:     return(getCurrentProperties().getProperty(DATA_CODESET));
1:eac0369:   }
1:eac0369: 
1:eac0369: 
1:eac0369:   /**read the control file properties into a local variable which is used later on
1:eac0369:   *In case there is no control file, read the default values for these properties
1:eac0369:  	* @exception	Exception if there is an error
1:eac0369: 	*/
1:eac0369:   Properties getCurrentProperties()  throws Exception{
1:eac0369:     if (currentProperties == null) {
1:eac0369:        loadDefaultValues();
1:eac0369:     }
1:eac0369:     return currentProperties;
1:eac0369:   }
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 	
1:eac0369: 	// Following set routines can be used to change the default properties
1:eac0369: 
1:eac0369: 	public void setColumnWidths(String columnWidths) throws Exception {
1:eac0369: 		if(columnWidths!=null)
1:eac0369: 			currentProperties.setProperty(COLUMN_WIDTHS, columnWidths);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	public void setFieldSeparator(String fieldSeperator) throws Exception {
1:eac0369: 		if(fieldSeperator!=null)
1:eac0369: 			currentProperties.setProperty(FIELD_SEPARATOR, fieldSeperator);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public void setFieldStartDelimiter(String fsdl) throws Exception {
1:eac0369: 		if(fsdl!=null)
1:eac0369: 			currentProperties.setProperty(FIELD_START_DELIMITER, fsdl);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public void setFieldEndDelimiter(String fedl) throws Exception {
1:eac0369: 		if(fedl!=null)
1:eac0369: 			currentProperties.setProperty(FIELD_END_DELIMITER, fedl);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public void  setRecordSeparator(String recordSeperator) throws Exception {
1:eac0369: 		if(recordSeperator!=null)
1:eac0369: 			currentProperties.setProperty(RECORD_SEPARATOR, recordSeperator);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public void setHasDelimiterAtEnd(String hasDelimeterAtEnd) throws Exception {
1:eac0369: 		if(hasDelimeterAtEnd!=null)
1:eac0369: 			currentProperties.setProperty(HAS_DELIMETER_AT_END, hasDelimeterAtEnd);
1:eac0369: 	}
1:eac0369:   
1:eac0369: 	public void setNullString(String nullString) throws Exception {
1:eac0369: 		if(nullString!=null)
1:eac0369: 			currentProperties.setProperty(NULL_STRING, nullString);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	//for fixed format, set column definitions
1:eac0369: 	public void setcolumnDefinition(String columnDefinition) throws Exception {
1:eac0369: 		if(columnDefinition!=null)
1:eac0369: 			currentProperties.setProperty(COLUMN_DEFINITION, columnDefinition);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	public void setDataCodeset(String codeset) throws Exception {
1:eac0369: 		if(codeset!=null)
1:eac0369: 			currentProperties.setProperty(DATA_CODESET, codeset);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	
1:eac0369: 	public void setCharacterDelimiter(String charDelimiter) throws Exception{
1:eac0369: 		if(charDelimiter !=null)
1:eac0369: 		{
1:eac0369: 			setFieldStartDelimiter(charDelimiter) ;
1:eac0369: 			setFieldEndDelimiter(charDelimiter);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	
1:eac0369: 	public void setControlProperties(String characterDelimiter ,
1:eac0369: 									 String columnDelimiter, 
1:eac0369: 									 String codeset) throws Exception
1:eac0369: 	{
1:eac0369: 		setCharacterDelimiter(characterDelimiter);
1:eac0369: 		setFieldSeparator(columnDelimiter);
1:eac0369: 		setDataCodeset(codeset);
1:eac0369: 		//check whether the delimiters are valid ones
1:eac0369: 		validateDelimiters();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	private void validateDelimiters() throws Exception
1:eac0369: 	{
1:eac0369: 
1:eac0369: 
1:eac0369: 		char colDel = (getFieldSeparator()).charAt(0);
1:eac0369: 		char charDel = (getFieldStartDelimiter()).charAt(0);
1:eac0369: 
1:eac0369: 		//The period was specified as a character string delimiter.
1:eac0369: 		if(charDel == '.')
1:eac0369: 		{
1:eac0369: 			throw LoadError.periodAsCharDelimiterNotAllowed();
1:eac0369: 		}
1:eac0369: 		
1:eac0369: 		
1:ea980d3:         // check for the invalid delimiters. A delimiter is not valid it 
1:ea980d3:         // is used more than once, i.e same character is used 
1:ea980d3:         // character data delimiter and also as a column delimiter. 
1:ea980d3:         // An hex decimal character (0-9, a-f ,A-F ) is not a 
1:ea980d3:         // valid delimiter, because binary data can be imported/exported 
1:ea980d3:         // as hex string.
1:ea980d3: 
1:eac0369: 		if(colDel == charDel || 
1:eac0369: 		   colDel == '.' ||
1:eac0369: 		   Character.isSpaceChar(colDel) ||  
1:ea980d3: 		   Character.isSpaceChar(charDel) ||
1:ea980d3:            Character.digit(colDel, 16) != -1 ||
1:ea980d3:            Character.digit(charDel, 16) != -1 )
1:eac0369: 		{
1:eac0369: 			throw LoadError.delimitersAreNotMutuallyExclusive();
1:eac0369: 		}
1:ea980d3:         
1:eac0369: 	}
1:eac0369: }
1:eac0369: 
============================================================================
author:Suresh Thalamati
-------------------------------------------------------------------------------
commit:ea980d3
/////////////////////////////////////////////////////////////////////////
1:         // check for the invalid delimiters. A delimiter is not valid it 
1:         // is used more than once, i.e same character is used 
1:         // character data delimiter and also as a column delimiter. 
1:         // An hex decimal character (0-9, a-f ,A-F ) is not a 
1:         // valid delimiter, because binary data can be imported/exported 
1:         // as hex string.
1: 
1: 		   Character.isSpaceChar(charDel) ||
1:            Character.digit(colDel, 16) != -1 ||
1:            Character.digit(charDel, 16) != -1 )
1:         
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:6d913c6
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:18c4da7
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:   /**
1:    * 
1:    * @return Code set, can return null for use the default code set.
1:    * @throws Exception
1:    */
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.load.ControlInfo
1: 
0:    Copyright 1998, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:1f9b9c4
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.load
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.load;
1: 
1: import java.io.PrintStream;
1: import java.io.InputStream;
1: import java.io.InputStreamReader;
1: import java.util.Date;
1: import java.util.Properties;
1: 
1: //read the control file properties. If the passed parameter for control file
1: //name is null, assigns default values to the properties. Also, if the control
1: //file has message property in it, it sends the errors to that file by
1: //redirecting system err to that message file
1: class ControlInfo
1: {
0: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
1: 
1:   static final String ESCAPE = "Escape";
1:   static final String DEFAULT_ESCAPE = "\\";
1:   static final String QUOTE = "Quote";
1:   static final String DEFAULT_QUOTE = "'";
1:   static final String COMMIT_COUNT = "CommitCount";
1:   static final String DEFAULT_COMMIT_COUNT = "0";
1:   static final String START_ROW = "StartRow";
1:   static final String DEFAULT_START_ROW = "1";
1:   static final String STOP_ROW = "StopRow";
1:   static final String DEFAULT_STOP_ROW = "0";
1: 
1:   static final String FIELD_SEPARATOR = "FieldSeparator";
1:   static final String DEFAULT_FIELD_SEPARATOR = ",";
1:   static final String RECORD_SEPARATOR = "RecordSeparator";
1:   static final String DEFAULT_RECORD_SEPARATOR = System.getProperty("line.separator");
1:   static final String COLUMN_DEFINITION = "ColumnDefinition";
1:   static final String DEFAULT_COLUMN_DEFINITION = "FALSE";
1:   static final String NULL_STRING = "Null";
1:   static final String DEFAULT_NULL_STRING = "NULL";
1:   static final String FORMAT = "Format";
1:   static final String DEFAULT_FORMAT = "ASCII_DELIMITED";
1:   static final String DB2_DELIMITED_FORMAT = "DB2_DELIMITED";  //beetle 5007
1:   static final String FIELD_START_DELIMITER = "FieldStartDelimiter";
1:   static final String DEFAULT_FIELD_START_DELIMITER = "\"";
1:   static final String FIELD_END_DELIMITER = "FieldEndDelimiter";
1:   static final String DEFAULT_FIELD_END_DELIMITER = "\"";
1:   static final String COLUMN_WIDTHS = "ColumnWidths";
1:   static final String MESSAGE_FILE = "MessageFile";
1:   static final String DEFAULT_VERSION = "1";
1:   static final String VERSION = "Version";
1:   static final String NEWLINE = "\n";
1:   static final String COMMA = ",";
1:   static final String SPACE = " ";
1:   static final String TAB = "\t";
1:   static final String CR = "\r";
1:   static final String LF = "\n";
1:   static final String CRLF = "\r\n";
1:   static final String LFCR = "\n\r";
1:   static final String FF = "\f";
1:   static final String EMPTY_LINE = "\n\n";
1:   static final String SEMICOLON = ";";
1:   static final String DATA_CODESET = "DataCodeset";
1:   static final String HAS_DELIMETER_AT_END = "HasDelimeterAtEnd";
1: 
1:   static final String INTERNAL_NONE = "None";
1:   static final String INTERNAL_TRUE = "True";
1:   static final String INTERNAL_FALSE = "False";
1:   static final String INTERNAL_TAB = "Tab";
1:   static final String INTERNAL_SPACE = "Space";
1:   static final String INTERNAL_CR = "CR";
1:   static final String INTERNAL_LF = "LF";
1:   static final String INTERNAL_CRLF = "CR-LF";
1:   static final String INTERNAL_LFCR = "LF-CR";
1:   static final String INTERNAL_COMMA = "Comma";
1:   static final String INTERNAL_SEMICOLON = "Semicolon";
1:   static final String INTERNAL_NEWLINE = "New Line";
1:   static final String INTERNAL_FF = "FF";
1:   static final String INTERNAL_EMPTY_LINE = "Empty line";
1: 
1:   private Properties currentProperties;
1: 
1:   public ControlInfo() throws Exception  {
1:     getCurrentProperties();
1:     //the field and record separators can't be subset of each other
1:     if (getFieldSeparator().indexOf(getRecordSeparator()) != -1) {
1:        throw LoadError.fieldAndRecordSeparatorsSubset();
1:     }
1:   }
1: 
1:   //read the value of a given property
1:   String getPropertyValue(String aKey) throws Exception {
1:     return getCurrentProperties().getProperty(aKey);
1:    }
1: 
1:   //following are the default values for few of the properties
1:   private void loadDefaultValues() {
1:     currentProperties = new Properties();
1:     currentProperties.put(FIELD_SEPARATOR, DEFAULT_FIELD_SEPARATOR);
1:     currentProperties.put(RECORD_SEPARATOR, DEFAULT_RECORD_SEPARATOR);
1:     currentProperties.put(COLUMN_DEFINITION, DEFAULT_COLUMN_DEFINITION);
1:     currentProperties.put(NULL_STRING, DEFAULT_NULL_STRING);
1:     currentProperties.put(FORMAT, DEFAULT_FORMAT);
1:     currentProperties.put(FIELD_START_DELIMITER, DEFAULT_FIELD_START_DELIMITER);
1:     currentProperties.put(FIELD_END_DELIMITER, DEFAULT_FIELD_END_DELIMITER);
1:     currentProperties.put(VERSION, DEFAULT_VERSION);
0:     // set the default code set to the platform default encoding value
0:     String default_data_codeset =
0:                           (new InputStreamReader(System.in)).getEncoding();
0:     currentProperties.put(DATA_CODESET, default_data_codeset);
1:     currentProperties.put(HAS_DELIMETER_AT_END, INTERNAL_FALSE);
1:   }
1: 
1:   //get control file version.
1:   String getCurrentVersion() throws Exception {
1:     return(DEFAULT_VERSION);
1:   }
1: 
1:   //2 possible formats: fixed and delimited. default is ASCII_DELIMITED
1:   String getFormat() throws Exception {
1:     return(getCurrentProperties().getProperty(FORMAT));
1:   }
1: 
1:   //read the column widths property which is comma delimited.
1:   //In case of fixed format, if column widths are missing, it will
1:   //throw an exception
1:   int[] getColumnWidths() {
1:       return null;
1:   }
1: 
1:   //default is DEFAULT_FIELD_SEPARATOR
1:   String getFieldSeparator() throws Exception {
1:     String fieldSeparator = getCurrentProperties().getProperty(FIELD_SEPARATOR);
1:     fieldSeparator = mapFromUserFriendlyFieldDelimiters(fieldSeparator);
1:     return fieldSeparator;
1:   }
1: 
1:   String getFieldStartDelimiter() throws Exception {
1:     return(getCurrentProperties().getProperty(FIELD_START_DELIMITER));
1:   }
1: 
1:   String getFieldEndDelimiter() throws Exception {
1:     return(getCurrentProperties().getProperty(FIELD_END_DELIMITER));
1:   }
1: 
1:   String getRecordSeparator() throws Exception {
1:     String recordSeparator = getCurrentProperties().getProperty(RECORD_SEPARATOR);
1:     recordSeparator = mapFromUserFriendlyRecordDelimiters(recordSeparator);
1:     return recordSeparator;
1:   }
1: 
1:   //to be used to cover cases where column delimeters are placed at the end of
1:   //each column resulting in an extra delimeter at the end of a row.
1:   boolean getHasDelimiterAtEnd() throws Exception {
1:     String hasDelimeterAtEnd = getCurrentProperties().getProperty(HAS_DELIMETER_AT_END);
1:     return hasDelimeterAtEnd.equals(INTERNAL_TRUE);
1:   }
1:   String getHasDelimeterAtEndString() throws Exception {
1:     String hasDelimeterAtEnd = getCurrentProperties().getProperty(HAS_DELIMETER_AT_END);
1:     return hasDelimeterAtEnd;
1:   }
1:   //if at the time of export, the column has null into it, we will spit
1:   //nullString in the output file.
1:   //If at the time of import, we see nullString for a column, we will
1:   //send null as part of resultSet interface
1:   String getNullString() throws Exception {
1:     return(getCurrentProperties().getProperty(NULL_STRING));
1:   }
1: 
1:   //for fixed format, get column definitions
1:   String getColumnDefinition() throws Exception {
1:     return(getCurrentProperties().getProperty(COLUMN_DEFINITION));
1:   }
1: 
1:   private String mapFromUserFriendlyFieldDelimiters(String aDelimiter) {
1:     if (aDelimiter.toUpperCase(java.util.Locale.ENGLISH).equals(INTERNAL_TAB.toUpperCase(java.util.Locale.ENGLISH)))
1:        return TAB;
1:     if (aDelimiter.toUpperCase(java.util.Locale.ENGLISH).equals(INTERNAL_SPACE.toUpperCase(java.util.Locale.ENGLISH)))
1:        return SPACE;
1:     if (aDelimiter.toUpperCase(java.util.Locale.ENGLISH).equals(INTERNAL_CR.toUpperCase(java.util.Locale.ENGLISH)))
1:        return CR;
1:     if (aDelimiter.toUpperCase(java.util.Locale.ENGLISH).equals(INTERNAL_LF.toUpperCase(java.util.Locale.ENGLISH)))
1:        return LF;
1:     if (aDelimiter.toUpperCase(java.util.Locale.ENGLISH).equals(INTERNAL_CRLF.toUpperCase(java.util.Locale.ENGLISH)))
1:        return CRLF;
1:     if (aDelimiter.toUpperCase(java.util.Locale.ENGLISH).equals(INTERNAL_LFCR.toUpperCase(java.util.Locale.ENGLISH)))
1:        return LFCR;
1:     if (aDelimiter.toUpperCase(java.util.Locale.ENGLISH).equals(INTERNAL_COMMA.toUpperCase(java.util.Locale.ENGLISH)))
1:        return COMMA;
1:     if (aDelimiter.toUpperCase(java.util.Locale.ENGLISH).equals(INTERNAL_SEMICOLON.toUpperCase(java.util.Locale.ENGLISH)))
1:        return SEMICOLON;
1: 
1:     aDelimiter = commonToFieldAndRecordDelimiters(aDelimiter, "\\n", '\n');
1:     aDelimiter = commonToFieldAndRecordDelimiters(aDelimiter, "\\t", '\t');
1:     aDelimiter = commonToFieldAndRecordDelimiters(aDelimiter, "\\r", '\r');
1:     aDelimiter = commonToFieldAndRecordDelimiters(aDelimiter, "\\f", '\f');
1:     return aDelimiter;
1:   }
1: 
1:   //vjbms: when user types \n in vjbms, it comes as 2 characters \ and n
1:   //and not just one character '\n' That's the reason for the following
1:   //check. I look for "\n" and replace it with '\n'. Same thing for \t
1:   // \r and \f
1:   private String commonToFieldAndRecordDelimiters(String aDelimiter,
1:   String specialChars, char replacementChar) {
1:     String beforeSpecialChars;
1:     String afterSpecialChars;
1:     int specialCharsPosition;
1:     while (aDelimiter.indexOf(specialChars) != -1) {
1:       specialCharsPosition = aDelimiter.indexOf(specialChars);
1:       beforeSpecialChars = aDelimiter.substring(0,specialCharsPosition);
1:       afterSpecialChars = aDelimiter.substring(specialCharsPosition+2);
1:       aDelimiter = beforeSpecialChars + replacementChar + afterSpecialChars;
1:     }
1:     return aDelimiter;
1:   }
1: 
1:   private String mapFromUserFriendlyRecordDelimiters(String aDelimiter) {
1:     if (aDelimiter.equals("\n"))
1:        aDelimiter = INTERNAL_NEWLINE;
1:     if (aDelimiter.toUpperCase(java.util.Locale.ENGLISH).equals(INTERNAL_NEWLINE.toUpperCase(java.util.Locale.ENGLISH)))
1:        return NEWLINE;
1:     if (aDelimiter.toUpperCase(java.util.Locale.ENGLISH).equals(INTERNAL_CR.toUpperCase(java.util.Locale.ENGLISH)))
1:        return CR;
1:     if (aDelimiter.toUpperCase(java.util.Locale.ENGLISH).equals(INTERNAL_LF.toUpperCase(java.util.Locale.ENGLISH)))
1:        return LF;
1:     if (aDelimiter.toUpperCase(java.util.Locale.ENGLISH).equals(INTERNAL_CRLF.toUpperCase(java.util.Locale.ENGLISH)))
1:        return CRLF;
1:     if (aDelimiter.toUpperCase(java.util.Locale.ENGLISH).equals(INTERNAL_LFCR.toUpperCase(java.util.Locale.ENGLISH)))
1:        return LFCR;
1:     if (aDelimiter.toUpperCase(java.util.Locale.ENGLISH).equals(INTERNAL_FF.toUpperCase(java.util.Locale.ENGLISH)))
1:        return FF;
1:     if (aDelimiter.toUpperCase(java.util.Locale.ENGLISH).equals(INTERNAL_EMPTY_LINE.toUpperCase(java.util.Locale.ENGLISH)))
1:        return EMPTY_LINE;
1: 
1:     aDelimiter = commonToFieldAndRecordDelimiters(aDelimiter, "\\n", '\n');
1:     aDelimiter = commonToFieldAndRecordDelimiters(aDelimiter, "\\t", '\t');
1:     aDelimiter = commonToFieldAndRecordDelimiters(aDelimiter, "\\r", '\r');
1:     aDelimiter = commonToFieldAndRecordDelimiters(aDelimiter, "\\f", '\f');
1:     return aDelimiter;
1:   }
1: 
1:   String getDataCodeset() throws Exception {
1:     return(getCurrentProperties().getProperty(DATA_CODESET));
1:   }
1: 
1: 
1:   /**read the control file properties into a local variable which is used later on
1:   *In case there is no control file, read the default values for these properties
1:  	* @exception	Exception if there is an error
1: 	*/
1:   Properties getCurrentProperties()  throws Exception{
1:     if (currentProperties == null) {
1:        loadDefaultValues();
1:     }
1:     return currentProperties;
1:   }
1: 
1: 
1: 
1: 	
1: 	// Following set routines can be used to change the default properties
1: 
1: 	public void setColumnWidths(String columnWidths) throws Exception {
1: 		if(columnWidths!=null)
1: 			currentProperties.setProperty(COLUMN_WIDTHS, columnWidths);
1: 	}
1: 
1: 
1: 	public void setFieldSeparator(String fieldSeperator) throws Exception {
1: 		if(fieldSeperator!=null)
1: 			currentProperties.setProperty(FIELD_SEPARATOR, fieldSeperator);
1: 	}
1: 
1: 	public void setFieldStartDelimiter(String fsdl) throws Exception {
1: 		if(fsdl!=null)
1: 			currentProperties.setProperty(FIELD_START_DELIMITER, fsdl);
1: 	}
1: 
1: 	public void setFieldEndDelimiter(String fedl) throws Exception {
1: 		if(fedl!=null)
1: 			currentProperties.setProperty(FIELD_END_DELIMITER, fedl);
1: 	}
1: 
1: 	public void  setRecordSeparator(String recordSeperator) throws Exception {
1: 		if(recordSeperator!=null)
1: 			currentProperties.setProperty(RECORD_SEPARATOR, recordSeperator);
1: 	}
1: 
1: 	public void setHasDelimiterAtEnd(String hasDelimeterAtEnd) throws Exception {
1: 		if(hasDelimeterAtEnd!=null)
1: 			currentProperties.setProperty(HAS_DELIMETER_AT_END, hasDelimeterAtEnd);
1: 	}
1:   
1: 	public void setNullString(String nullString) throws Exception {
1: 		if(nullString!=null)
1: 			currentProperties.setProperty(NULL_STRING, nullString);
1: 	}
1: 
1: 	//for fixed format, set column definitions
1: 	public void setcolumnDefinition(String columnDefinition) throws Exception {
1: 		if(columnDefinition!=null)
1: 			currentProperties.setProperty(COLUMN_DEFINITION, columnDefinition);
1: 	}
1: 
1: 
1: 	public void setDataCodeset(String codeset) throws Exception {
1: 		if(codeset!=null)
1: 			currentProperties.setProperty(DATA_CODESET, codeset);
1: 	}
1: 
1: 	
1: 	public void setCharacterDelimiter(String charDelimiter) throws Exception{
1: 		if(charDelimiter !=null)
1: 		{
1: 			setFieldStartDelimiter(charDelimiter) ;
1: 			setFieldEndDelimiter(charDelimiter);
1: 		}
1: 	}
1: 
1: 
1: 	
1: 	public void setControlProperties(String characterDelimiter ,
1: 									 String columnDelimiter, 
1: 									 String codeset) throws Exception
1: 	{
1: 		setCharacterDelimiter(characterDelimiter);
1: 		setFieldSeparator(columnDelimiter);
1: 		setDataCodeset(codeset);
1: 		//check whether the delimiters are valid ones
1: 		validateDelimiters();
1: 	}
1: 
1: 
1: 	private void validateDelimiters() throws Exception
1: 	{
1: 
1: 
1: 		char colDel = (getFieldSeparator()).charAt(0);
1: 		char charDel = (getFieldStartDelimiter()).charAt(0);
1: 
1: 		//The period was specified as a character string delimiter.
1: 		if(charDel == '.')
1: 		{
1: 			throw LoadError.periodAsCharDelimiterNotAllowed();
1: 		}
1: 		
1: 		
0: 		//A delimiter is not valid or is used more than once.
1: 		if(colDel == charDel || 
1: 		   colDel == '.' ||
1: 		   Character.isSpaceChar(colDel) ||  
0: 		   Character.isSpaceChar(charDel)
0: 		   )
1: 		{
1: 			throw LoadError.delimitersAreNotMutuallyExclusive();
1: 		}
1: 
1: 	}
1: }
1: 
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.load
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.load;
0: 
0: import java.io.PrintStream;
0: import java.io.InputStream;
0: import java.io.InputStreamReader;
0: import java.util.Date;
0: import java.util.Properties;
0: 
0: //read the control file properties. If the passed parameter for control file
0: //name is null, assigns default values to the properties. Also, if the control
0: //file has message property in it, it sends the errors to that file by
0: //redirecting system err to that message file
0: class ControlInfo
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
0: 
0:   static final String ESCAPE = "Escape";
0:   static final String DEFAULT_ESCAPE = "\\";
0:   static final String QUOTE = "Quote";
0:   static final String DEFAULT_QUOTE = "'";
0:   static final String COMMIT_COUNT = "CommitCount";
0:   static final String DEFAULT_COMMIT_COUNT = "0";
0:   static final String START_ROW = "StartRow";
0:   static final String DEFAULT_START_ROW = "1";
0:   static final String STOP_ROW = "StopRow";
0:   static final String DEFAULT_STOP_ROW = "0";
0: 
0:   static final String FIELD_SEPARATOR = "FieldSeparator";
0:   static final String DEFAULT_FIELD_SEPARATOR = ",";
0:   static final String RECORD_SEPARATOR = "RecordSeparator";
0:   static final String DEFAULT_RECORD_SEPARATOR = System.getProperty("line.separator");
0:   static final String COLUMN_DEFINITION = "ColumnDefinition";
0:   static final String DEFAULT_COLUMN_DEFINITION = "FALSE";
0:   static final String NULL_STRING = "Null";
0:   static final String DEFAULT_NULL_STRING = "NULL";
0:   static final String FORMAT = "Format";
0:   static final String DEFAULT_FORMAT = "ASCII_DELIMITED";
0:   static final String DB2_DELIMITED_FORMAT = "DB2_DELIMITED";  //beetle 5007
0:   static final String FIELD_START_DELIMITER = "FieldStartDelimiter";
0:   static final String DEFAULT_FIELD_START_DELIMITER = "\"";
0:   static final String FIELD_END_DELIMITER = "FieldEndDelimiter";
0:   static final String DEFAULT_FIELD_END_DELIMITER = "\"";
0:   static final String COLUMN_WIDTHS = "ColumnWidths";
0:   static final String MESSAGE_FILE = "MessageFile";
0:   static final String DEFAULT_VERSION = "1";
0:   static final String VERSION = "Version";
0:   static final String NEWLINE = "\n";
0:   static final String COMMA = ",";
0:   static final String SPACE = " ";
0:   static final String TAB = "\t";
0:   static final String CR = "\r";
0:   static final String LF = "\n";
0:   static final String CRLF = "\r\n";
0:   static final String LFCR = "\n\r";
0:   static final String FF = "\f";
0:   static final String EMPTY_LINE = "\n\n";
0:   static final String SEMICOLON = ";";
0:   static final String DATA_CODESET = "DataCodeset";
0:   static final String HAS_DELIMETER_AT_END = "HasDelimeterAtEnd";
0: 
0:   static final String INTERNAL_NONE = "None";
0:   static final String INTERNAL_TRUE = "True";
0:   static final String INTERNAL_FALSE = "False";
0:   static final String INTERNAL_TAB = "Tab";
0:   static final String INTERNAL_SPACE = "Space";
0:   static final String INTERNAL_CR = "CR";
0:   static final String INTERNAL_LF = "LF";
0:   static final String INTERNAL_CRLF = "CR-LF";
0:   static final String INTERNAL_LFCR = "LF-CR";
0:   static final String INTERNAL_COMMA = "Comma";
0:   static final String INTERNAL_SEMICOLON = "Semicolon";
0:   static final String INTERNAL_NEWLINE = "New Line";
0:   static final String INTERNAL_FF = "FF";
0:   static final String INTERNAL_EMPTY_LINE = "Empty line";
0: 
0:   private Properties currentProperties;
0: 
0:   public ControlInfo() throws Exception  {
0:     getCurrentProperties();
0:     //the field and record separators can't be subset of each other
0:     if (getFieldSeparator().indexOf(getRecordSeparator()) != -1) {
0:        throw LoadError.fieldAndRecordSeparatorsSubset();
0:     }
0:   }
0: 
0:   //read the value of a given property
0:   String getPropertyValue(String aKey) throws Exception {
0:     return getCurrentProperties().getProperty(aKey);
0:    }
0: 
0:   //following are the default values for few of the properties
0:   private void loadDefaultValues() {
0:     currentProperties = new Properties();
0:     currentProperties.put(FIELD_SEPARATOR, DEFAULT_FIELD_SEPARATOR);
0:     currentProperties.put(RECORD_SEPARATOR, DEFAULT_RECORD_SEPARATOR);
0:     currentProperties.put(COLUMN_DEFINITION, DEFAULT_COLUMN_DEFINITION);
0:     currentProperties.put(NULL_STRING, DEFAULT_NULL_STRING);
0:     currentProperties.put(FORMAT, DEFAULT_FORMAT);
0:     currentProperties.put(FIELD_START_DELIMITER, DEFAULT_FIELD_START_DELIMITER);
0:     currentProperties.put(FIELD_END_DELIMITER, DEFAULT_FIELD_END_DELIMITER);
0:     currentProperties.put(VERSION, DEFAULT_VERSION);
0:     // set the default code set to the platform default encoding value
0:     String default_data_codeset =
0:                           (new InputStreamReader(System.in)).getEncoding();
0:     currentProperties.put(DATA_CODESET, default_data_codeset);
0:     currentProperties.put(HAS_DELIMETER_AT_END, INTERNAL_FALSE);
0:   }
0: 
0:   //get control file version.
0:   String getCurrentVersion() throws Exception {
0:     return(DEFAULT_VERSION);
0:   }
0: 
0:   //2 possible formats: fixed and delimited. default is ASCII_DELIMITED
0:   String getFormat() throws Exception {
0:     return(getCurrentProperties().getProperty(FORMAT));
0:   }
0: 
0:   //read the column widths property which is comma delimited.
0:   //In case of fixed format, if column widths are missing, it will
0:   //throw an exception
0:   int[] getColumnWidths() {
0:       return null;
0:   }
0: 
0:   //default is DEFAULT_FIELD_SEPARATOR
0:   String getFieldSeparator() throws Exception {
0:     String fieldSeparator = getCurrentProperties().getProperty(FIELD_SEPARATOR);
0:     fieldSeparator = mapFromUserFriendlyFieldDelimiters(fieldSeparator);
0:     return fieldSeparator;
0:   }
0: 
0:   String getFieldStartDelimiter() throws Exception {
0:     return(getCurrentProperties().getProperty(FIELD_START_DELIMITER));
0:   }
0: 
0:   String getFieldEndDelimiter() throws Exception {
0:     return(getCurrentProperties().getProperty(FIELD_END_DELIMITER));
0:   }
0: 
0:   String getRecordSeparator() throws Exception {
0:     String recordSeparator = getCurrentProperties().getProperty(RECORD_SEPARATOR);
0:     recordSeparator = mapFromUserFriendlyRecordDelimiters(recordSeparator);
0:     return recordSeparator;
0:   }
0: 
0:   //to be used to cover cases where column delimeters are placed at the end of
0:   //each column resulting in an extra delimeter at the end of a row.
0:   boolean getHasDelimiterAtEnd() throws Exception {
0:     String hasDelimeterAtEnd = getCurrentProperties().getProperty(HAS_DELIMETER_AT_END);
0:     return hasDelimeterAtEnd.equals(INTERNAL_TRUE);
0:   }
0:   String getHasDelimeterAtEndString() throws Exception {
0:     String hasDelimeterAtEnd = getCurrentProperties().getProperty(HAS_DELIMETER_AT_END);
0:     return hasDelimeterAtEnd;
0:   }
0:   //if at the time of export, the column has null into it, we will spit
0:   //nullString in the output file.
0:   //If at the time of import, we see nullString for a column, we will
0:   //send null as part of resultSet interface
0:   String getNullString() throws Exception {
0:     return(getCurrentProperties().getProperty(NULL_STRING));
0:   }
0: 
0:   //for fixed format, get column definitions
0:   String getColumnDefinition() throws Exception {
0:     return(getCurrentProperties().getProperty(COLUMN_DEFINITION));
0:   }
0: 
0:   private String mapFromUserFriendlyFieldDelimiters(String aDelimiter) {
0:     if (aDelimiter.toUpperCase(java.util.Locale.ENGLISH).equals(INTERNAL_TAB.toUpperCase(java.util.Locale.ENGLISH)))
0:        return TAB;
0:     if (aDelimiter.toUpperCase(java.util.Locale.ENGLISH).equals(INTERNAL_SPACE.toUpperCase(java.util.Locale.ENGLISH)))
0:        return SPACE;
0:     if (aDelimiter.toUpperCase(java.util.Locale.ENGLISH).equals(INTERNAL_CR.toUpperCase(java.util.Locale.ENGLISH)))
0:        return CR;
0:     if (aDelimiter.toUpperCase(java.util.Locale.ENGLISH).equals(INTERNAL_LF.toUpperCase(java.util.Locale.ENGLISH)))
0:        return LF;
0:     if (aDelimiter.toUpperCase(java.util.Locale.ENGLISH).equals(INTERNAL_CRLF.toUpperCase(java.util.Locale.ENGLISH)))
0:        return CRLF;
0:     if (aDelimiter.toUpperCase(java.util.Locale.ENGLISH).equals(INTERNAL_LFCR.toUpperCase(java.util.Locale.ENGLISH)))
0:        return LFCR;
0:     if (aDelimiter.toUpperCase(java.util.Locale.ENGLISH).equals(INTERNAL_COMMA.toUpperCase(java.util.Locale.ENGLISH)))
0:        return COMMA;
0:     if (aDelimiter.toUpperCase(java.util.Locale.ENGLISH).equals(INTERNAL_SEMICOLON.toUpperCase(java.util.Locale.ENGLISH)))
0:        return SEMICOLON;
0: 
0:     aDelimiter = commonToFieldAndRecordDelimiters(aDelimiter, "\\n", '\n');
0:     aDelimiter = commonToFieldAndRecordDelimiters(aDelimiter, "\\t", '\t');
0:     aDelimiter = commonToFieldAndRecordDelimiters(aDelimiter, "\\r", '\r');
0:     aDelimiter = commonToFieldAndRecordDelimiters(aDelimiter, "\\f", '\f');
0:     return aDelimiter;
0:   }
0: 
0:   //vjbms: when user types \n in vjbms, it comes as 2 characters \ and n
0:   //and not just one character '\n' That's the reason for the following
0:   //check. I look for "\n" and replace it with '\n'. Same thing for \t
0:   // \r and \f
0:   private String commonToFieldAndRecordDelimiters(String aDelimiter,
0:   String specialChars, char replacementChar) {
0:     String beforeSpecialChars;
0:     String afterSpecialChars;
0:     int specialCharsPosition;
0:     while (aDelimiter.indexOf(specialChars) != -1) {
0:       specialCharsPosition = aDelimiter.indexOf(specialChars);
0:       beforeSpecialChars = aDelimiter.substring(0,specialCharsPosition);
0:       afterSpecialChars = aDelimiter.substring(specialCharsPosition+2);
0:       aDelimiter = beforeSpecialChars + replacementChar + afterSpecialChars;
0:     }
0:     return aDelimiter;
0:   }
0: 
0:   private String mapFromUserFriendlyRecordDelimiters(String aDelimiter) {
0:     if (aDelimiter.equals("\n"))
0:        aDelimiter = INTERNAL_NEWLINE;
0:     if (aDelimiter.toUpperCase(java.util.Locale.ENGLISH).equals(INTERNAL_NEWLINE.toUpperCase(java.util.Locale.ENGLISH)))
0:        return NEWLINE;
0:     if (aDelimiter.toUpperCase(java.util.Locale.ENGLISH).equals(INTERNAL_CR.toUpperCase(java.util.Locale.ENGLISH)))
0:        return CR;
0:     if (aDelimiter.toUpperCase(java.util.Locale.ENGLISH).equals(INTERNAL_LF.toUpperCase(java.util.Locale.ENGLISH)))
0:        return LF;
0:     if (aDelimiter.toUpperCase(java.util.Locale.ENGLISH).equals(INTERNAL_CRLF.toUpperCase(java.util.Locale.ENGLISH)))
0:        return CRLF;
0:     if (aDelimiter.toUpperCase(java.util.Locale.ENGLISH).equals(INTERNAL_LFCR.toUpperCase(java.util.Locale.ENGLISH)))
0:        return LFCR;
0:     if (aDelimiter.toUpperCase(java.util.Locale.ENGLISH).equals(INTERNAL_FF.toUpperCase(java.util.Locale.ENGLISH)))
0:        return FF;
0:     if (aDelimiter.toUpperCase(java.util.Locale.ENGLISH).equals(INTERNAL_EMPTY_LINE.toUpperCase(java.util.Locale.ENGLISH)))
0:        return EMPTY_LINE;
0: 
0:     aDelimiter = commonToFieldAndRecordDelimiters(aDelimiter, "\\n", '\n');
0:     aDelimiter = commonToFieldAndRecordDelimiters(aDelimiter, "\\t", '\t');
0:     aDelimiter = commonToFieldAndRecordDelimiters(aDelimiter, "\\r", '\r');
0:     aDelimiter = commonToFieldAndRecordDelimiters(aDelimiter, "\\f", '\f');
0:     return aDelimiter;
0:   }
0: 
0:   String getDataCodeset() throws Exception {
0:     return(getCurrentProperties().getProperty(DATA_CODESET));
0:   }
0: 
0: 
0:   /**read the control file properties into a local variable which is used later on
0:   *In case there is no control file, read the default values for these properties
0:  	* @exception	Exception if there is an error
0: 	*/
0:   Properties getCurrentProperties()  throws Exception{
0:     if (currentProperties == null) {
0:        loadDefaultValues();
0:     }
0:     return currentProperties;
0:   }
0: 
0: 
0: 
0: 	
0: 	// Following set routines can be used to change the default properties
0: 
0: 	public void setColumnWidths(String columnWidths) throws Exception {
0: 		if(columnWidths!=null)
0: 			currentProperties.setProperty(COLUMN_WIDTHS, columnWidths);
0: 	}
0: 
0: 
0: 	public void setFieldSeparator(String fieldSeperator) throws Exception {
0: 		if(fieldSeperator!=null)
0: 			currentProperties.setProperty(FIELD_SEPARATOR, fieldSeperator);
0: 	}
0: 
0: 	public void setFieldStartDelimiter(String fsdl) throws Exception {
0: 		if(fsdl!=null)
0: 			currentProperties.setProperty(FIELD_START_DELIMITER, fsdl);
0: 	}
0: 
0: 	public void setFieldEndDelimiter(String fedl) throws Exception {
0: 		if(fedl!=null)
0: 			currentProperties.setProperty(FIELD_END_DELIMITER, fedl);
0: 	}
0: 
0: 	public void  setRecordSeparator(String recordSeperator) throws Exception {
0: 		if(recordSeperator!=null)
0: 			currentProperties.setProperty(RECORD_SEPARATOR, recordSeperator);
0: 	}
0: 
0: 	public void setHasDelimiterAtEnd(String hasDelimeterAtEnd) throws Exception {
0: 		if(hasDelimeterAtEnd!=null)
0: 			currentProperties.setProperty(HAS_DELIMETER_AT_END, hasDelimeterAtEnd);
0: 	}
0:   
0: 	public void setNullString(String nullString) throws Exception {
0: 		if(nullString!=null)
0: 			currentProperties.setProperty(NULL_STRING, nullString);
0: 	}
0: 
0: 	//for fixed format, set column definitions
0: 	public void setcolumnDefinition(String columnDefinition) throws Exception {
0: 		if(columnDefinition!=null)
0: 			currentProperties.setProperty(COLUMN_DEFINITION, columnDefinition);
0: 	}
0: 
0: 
0: 	public void setDataCodeset(String codeset) throws Exception {
0: 		if(codeset!=null)
0: 			currentProperties.setProperty(DATA_CODESET, codeset);
0: 	}
0: 
0: 	
0: 	public void setCharacterDelimiter(String charDelimiter) throws Exception{
0: 		if(charDelimiter !=null)
0: 		{
0: 			setFieldStartDelimiter(charDelimiter) ;
0: 			setFieldEndDelimiter(charDelimiter);
0: 		}
0: 	}
0: 
0: 
0: 	
0: 	public void setControlProperties(String characterDelimiter ,
0: 									 String columnDelimiter, 
0: 									 String codeset) throws Exception
0: 	{
0: 		setCharacterDelimiter(characterDelimiter);
0: 		setFieldSeparator(columnDelimiter);
0: 		setDataCodeset(codeset);
0: 		//check whether the delimiters are valid ones
0: 		validateDelimiters();
0: 	}
0: 
0: 
0: 	private void validateDelimiters() throws Exception
0: 	{
0: 
0: 
0: 		char colDel = (getFieldSeparator()).charAt(0);
0: 		char charDel = (getFieldStartDelimiter()).charAt(0);
0: 
0: 		//The period was specified as a character string delimiter.
0: 		if(charDel == '.')
0: 		{
0: 			throw LoadError.periodAsCharDelimiterNotAllowed();
0: 		}
0: 		
0: 		
0: 		//A delimiter is not valid or is used more than once.
0: 		if(colDel == charDel || 
0: 		   colDel == '.' ||
0: 		   Character.isSpaceChar(colDel) ||  
0: 		   Character.isSpaceChar(charDel)
0: 		   )
0: 		{
0: 			throw LoadError.delimitersAreNotMutuallyExclusive();
0: 		}
0: 
0: 	}
0: }
0: 
============================================================================