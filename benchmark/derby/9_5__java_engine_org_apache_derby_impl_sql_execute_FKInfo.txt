1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.execute.FKInfo
1:345de35: 
1:f6123ee:    Licensed to the Apache Software Foundation (ASF) under one or more
1:f6123ee:    contributor license agreements.  See the NOTICE file distributed with
1:f6123ee:    this work for additional information regarding copyright ownership.
1:f6123ee:    The ASF licenses this file to you under the Apache License, Version 2.0
1:f6123ee:    (the "License"); you may not use this file except in compliance with
1:f6123ee:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
10:eac0369: 
2:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.sql.execute;
1:eac0369: 
1:eac0369: import java.io.IOException;
1:4cc0287: import java.io.ObjectInput;
1:4cc0287: import java.io.ObjectOutput;
1:4cc0287: import java.io.StreamCorruptedException;
1:eac0369: import java.util.Vector;
1:4cc0287: import org.apache.derby.catalog.UUID;
1:4cc0287: import org.apache.derby.iapi.error.StandardException;
1:4cc0287: import org.apache.derby.iapi.services.io.ArrayUtil;
1:4cc0287: import org.apache.derby.iapi.services.io.FormatIdUtil;
1:4cc0287: import org.apache.derby.iapi.services.io.Formatable;
1:4cc0287: import org.apache.derby.iapi.services.io.StoredFormatIds;
1:4cc0287: import org.apache.derby.iapi.services.monitor.Monitor;
1:4cc0287: import org.apache.derby.iapi.types.RowLocation;
1:4cc0287: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: 
2:eac0369: /**
1:eac0369:  * This is a simple class used to store the run time information
1:eac0369:  * about a foreign key.  Used by DML to figure out what to
1:eac0369:  * check.
1:eac0369:  *
1:eac0369:  */
1:eac0369: public class FKInfo implements Formatable 
1:eac0369: {
1:eac0369: 	/********************************************************
1:eac0369: 	**
1:eac0369: 	**	This class implements Formatable. That means that it
1:eac0369: 	**	can write itself to and from a formatted stream. If
1:eac0369: 	**	you add more fields to this class, make sure that you
1:eac0369: 	**	also write/read them with the writeExternal()/readExternal()
1:eac0369: 	**	methods.
1:eac0369: 	**
1:4cc0287:     **  If, between releases, you add more fields to this class,
1:eac0369: 	**	then you should bump the version number emitted by the getTypeFormatId()
1:eac0369: 	**	method.  OR, since this is something that is used
1:eac0369: 	**	in stored prepared statements, it is ok to change it
1:eac0369: 	**	if you make sure that stored prepared statements are
1:eac0369: 	**	invalidated across releases.
1:eac0369: 	**
1:eac0369: 	********************************************************/
1:eac0369: 
1:eac0369: 	public static final int FOREIGN_KEY = 1;
1:eac0369: 	public static final int REFERENCED_KEY = 2;
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** See the constructor for the meaning of these fields
1:eac0369: 	*/
1:4cc0287:     String              schemaName;
1:42544c4:     String              tableName;
1:42544c4:     int                 type;
1:4cc0287:     UUID                refUUID; // index index conglomerate uuid
1:42544c4:     long                refConglomNumber;
1:f6d02c9:     UUID                refConstraintID;
1:9179199:     boolean             refConstraintIsDeferrable;
1:42544c4:     int                 stmtType;
1:42544c4:     RowLocation         rowLocation;
1:4cc0287: 
1:4cc0287:     // These arrays all have the same cardinality, either 1 (foreign key), or
1:4cc0287:     // the number of FKs referencing this referenced key
1:4cc0287:     String[]            fkConstraintNames;
1:4cc0287:     private UUID[]      fkUUIDs; // the index conglomerate uuids
1:4cc0287:     long[]              fkConglomNumbers;
1:4cc0287:     UUID[]              fkIds; // the constraint uuids
1:4cc0287:     boolean[]           fkIsSelfReferencing;
1:4cc0287:     int[]               colArray;
1:42544c4:     int[]               raRules;
1:4cc0287:     boolean[]           deferrable;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Niladic constructor for Formattable
1:eac0369: 	 */
1:eac0369: 	public FKInfo() {}
1:eac0369: 
1:eac0369: 	/**
1:4cc0287:      * Constructor for FKInfo
1:eac0369: 	 *
1:eac0369: 	 * @param fkConstraintNames the foreign key constraint names
1:4cc0287:      * @param schemaName the name of the schema of the table being modified
1:eac0369: 	 * @param tableName	the name of the table being modified
1:6b50965: 	 * @param stmtType	the type of the statement: e.g. StatementType.INSERT
1:eac0369: 	 * @param type either FKInfo.REFERENCED_KEY or FKInfo.FOREIGN_KEY
1:9179199:      * @param refUUID UUID of the referenced constraint's supporting index
1:4cc0287:      * @param refConglomNumber conglomerate number of the referenced key
1:f6d02c9:      * @param refConstraintID UUID of the referenced constraint
1:9179199:      * @param refConstraintIsDeferrable {@code true} iff the referenced key
1:9179199:      *                                  constraint is deferrable
1:eac0369: 	 * @param fkUUIDs an array of fkUUIDs of backing indexes.  if
1:eac0369: 	 *			FOREIGN_KEY, then just one element, the backing
1:4cc0287:      *          index of the referenced keys.  if REFERENCED_KEY,
1:eac0369: 	 *			then all the foreign keys
1:eac0369: 	 * @param fkConglomNumbers array of conglomerate numbers, corresponds
1:eac0369: 	 *			to fkUUIDs
1:6b50965: 	 * @param fkIsSelfReferencing array of conglomerate booleans indicating
1:4cc0287:      *          whether the foreign key references a key in the same table
1:eac0369: 	 * @param colArray map of columns to the base row that DML
1:eac0369: 	 * 			is changing.  1 based.  Note that this maps the
1:eac0369: 	 *			constraint index to a row in the target table of
1:4cc0287:      *          the current DML operation.
1:eac0369: 	 * @param rowLocation a row location template for the target table
1:eac0369: 	 *			used to pass in a template row to tc.openScan()
1:4cc0287:      * @param raRules referential action rules
1:4cc0287:      * @param deferrable the corresponding constraint is deferrable
1:9179199:      * @param fkIds the foreign key constraints' uuids.
1:eac0369: 	 */
1:eac0369: 	public FKInfo(
1:eac0369: 					String[]			fkConstraintNames,
1:4cc0287:                     String              schemaName,
1:4cc0287:                     String              tableName,
1:eac0369: 					int					stmtType,
1:eac0369: 					int					type,
1:eac0369: 					UUID				refUUID,
1:eac0369: 					long				refConglomNumber,
1:f6d02c9:                     UUID                refConstraintID,
1:9179199:                     boolean             refConstraintIsDeferrable,
1:eac0369: 					UUID[]				fkUUIDs,
1:eac0369: 					long[]				fkConglomNumbers,
1:eac0369: 					boolean[]			fkIsSelfReferencing,
1:eac0369: 					int[]				colArray,
1:eac0369: 					RowLocation			rowLocation,
1:4cc0287:                     int[]               raRules,
1:4cc0287:                     boolean[]           deferrable,
1:4cc0287:                     UUID[]              fkIds
1:eac0369: 					)
1:eac0369: 	{
1:42544c4:         this.fkConstraintNames = ArrayUtil.copy(fkConstraintNames);
1:eac0369: 		this.tableName = tableName;
1:4cc0287:         this.schemaName = schemaName;
1:eac0369: 		this.stmtType = stmtType;
1:eac0369: 		this.type = type;
1:eac0369: 		this.refUUID = refUUID;
1:eac0369: 		this.refConglomNumber = refConglomNumber;
1:f6d02c9:         this.refConstraintID = refConstraintID;
1:9179199:         this.refConstraintIsDeferrable = refConstraintIsDeferrable;
1:3f7581c:         this.fkUUIDs = ArrayUtil.copy(fkUUIDs);
1:42544c4:         this.fkConglomNumbers = ArrayUtil.copy(fkConglomNumbers);
1:42544c4:         this.fkIsSelfReferencing = ArrayUtil.copy(fkIsSelfReferencing);
1:42544c4:         this.colArray = ArrayUtil.copy(colArray);
1:eac0369: 		this.rowLocation = rowLocation;
1:42544c4:         this.raRules = ArrayUtil.copy(raRules);
1:4cc0287:         this.deferrable = ArrayUtil.copy(deferrable);
1:4cc0287:         this.fkIds = ArrayUtil.copy(fkIds);
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			if (fkUUIDs.length != fkConglomNumbers.length)
1:eac0369: 			{
1:eac0369: 				SanityManager.THROWASSERT("number of ForeignKey UUIDS ("+fkUUIDs.length+
1:eac0369: 										") doesn't match the number of conglomerate numbers"+
1:eac0369: 										" ("+fkConglomNumbers.length+")");
1:eac0369: 			}
1:eac0369: 			if (type == FOREIGN_KEY)
1:eac0369: 			{
1:eac0369: 				SanityManager.ASSERT(fkUUIDs.length == 1, "unexpected number of fkUUIDs for a foreign key, should only have the uuid of the key it references");
1:eac0369: 			}
1:eac0369: 			else if (type == REFERENCED_KEY)
1:eac0369: 			{
1:eac0369: 				SanityManager.ASSERT(fkUUIDs.length >= 1, "too few fkUUIDs for a referenced key, expect at least one foreign key");
1:eac0369: 			}
1:eac0369: 			else
1:eac0369: 			{
1:eac0369: 				SanityManager.THROWASSERT("bad type: "+type);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Comb through the FKInfo structures and pick out the
1:eac0369: 	 * ones that have columns that intersect with the input
1:eac0369: 	 * columns.
1:eac0369: 	 *
1:eac0369:  	 * @param fkInfo	        array of fkinfos
1:eac0369: 	 * @param cols	            array of columns
1:4cc0287:      * @param addAllTypeIsFK    take all with type == FOREIGN_KEY
1:eac0369: 	 *
1:eac0369: 	 * @return array of relevant fkinfos
1:eac0369: 	 */
1:eac0369: 	public static FKInfo[] chooseRelevantFKInfos
1:eac0369: 	(	
1:eac0369: 		FKInfo[] 	fkInfo, 
1:eac0369: 		int[] 		cols,
1:eac0369: 		boolean		addAllTypeIsFK)
1:eac0369: 	{
1:eac0369: 		if (fkInfo == null)
1:eac0369: 		{
1:eac0369: 			return (FKInfo[])null;
1:eac0369: 		}
1:eac0369: 
1:71c8e86: 		Vector<FKInfo> newfksVector = new Vector<FKInfo>();
1:eac0369: 		FKInfo[] newfks = null;
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** For each FKInfo
1:eac0369: 		*/
1:eac0369: 		for (int i = 0; i < fkInfo.length; i++)
1:eac0369: 		{
1:eac0369: 			if (addAllTypeIsFK && 
1:eac0369: 				(fkInfo[i].type == FOREIGN_KEY))
1:eac0369: 			{
1:eac0369: 				newfksVector.addElement(fkInfo[i]);
1:eac0369: 				continue;
1:eac0369: 			}
1:eac0369: 				
1:eac0369: 			int fkcollen = fkInfo[i].colArray.length;
1:eac0369: 			for (int fkCols = 0; fkCols < fkcollen; fkCols++)
1:eac0369: 			{
1:eac0369: 				for (int chcol = 0; chcol < cols.length; chcol++)
1:eac0369: 				{
1:eac0369: 					/*
1:eac0369: 					** If any column intersects, the FKInfo is
1:eac0369: 					** relevant.
1:eac0369: 					*/
1:eac0369: 					if (fkInfo[i].colArray[fkCols] == cols[chcol])
1:eac0369: 					{
1:eac0369: 						newfksVector.addElement(fkInfo[i]);
1:eac0369: 						
1:eac0369: 						// go to the next fk
1:eac0369: 						fkCols = fkcollen;
1:eac0369: 						break;
1:eac0369: 					}
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		
1:eac0369: 		/*
1:eac0369: 		** Now convert the vector into an array.
1:eac0369: 		*/
1:eac0369: 		int size = newfksVector.size();
1:eac0369: 		if (size > 0)
1:eac0369: 		{
1:eac0369: 			newfks = new FKInfo[size];
1:eac0369: 			for (int i = 0; i < size; i++)
1:eac0369: 			{
1:801cf0d:                 newfks[i] = newfksVector.elementAt(i);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		return newfks;
1:eac0369: 	}
1:eac0369: 		
1:eac0369: 	//////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	// FORMATABLE
1:eac0369: 	//
1:eac0369: 	//////////////////////////////////////////////
1:eac0369: 	/**
1:eac0369: 	 * Write this object out
1:eac0369: 	 *
1:eac0369: 	 * @param out write bytes here
1:eac0369: 	 *
1:eac0369:  	 * @exception IOException thrown on error
1:eac0369: 	 */
1:eac0369: 	public void writeExternal(ObjectOutput out) throws IOException
1:eac0369: 	{
1:eac0369: 		/*
1:eac0369: 		** Row locations cannot be written unless they
1:eac0369: 		** have a valid value.  So we'll just write out
1:eac0369: 		** the format id, and create a new RowLocation
1:eac0369: 		** when we read it back in.
1:eac0369: 		*/
1:eac0369: 		FormatIdUtil.writeFormatIdInteger(out, rowLocation.getTypeFormatId());
1:eac0369: 
1:f65be8f:         out.writeObject(schemaName);
1:eac0369: 		out.writeObject(tableName);
1:eac0369: 		out.writeInt(type);
1:eac0369: 		out.writeInt(stmtType);
1:eac0369: 		out.writeObject(refUUID);
1:eac0369: 		out.writeLong(refConglomNumber);
1:f6d02c9:         out.writeObject(refConstraintID);
1:45da2f5:         out.writeBoolean(refConstraintIsDeferrable);
1:eac0369: 
1:eac0369: 		ArrayUtil.writeArray(out, fkConstraintNames);
1:eac0369: 		ArrayUtil.writeArray(out, fkUUIDs);
1:eac0369: 		ArrayUtil.writeLongArray(out, fkConglomNumbers);
1:eac0369: 		ArrayUtil.writeBooleanArray(out, fkIsSelfReferencing);
1:eac0369: 		ArrayUtil.writeIntArray(out, colArray);
1:eac0369: 		ArrayUtil.writeIntArray(out, raRules);
1:4cc0287:         ArrayUtil.writeBooleanArray(out, deferrable);
1:b08f421:         ArrayUtil.writeArray(out, fkIds);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Read this object from a stream of stored objects.
1:eac0369: 	 *
1:eac0369: 	 * @param in read this.
1:eac0369: 	 *
1:eac0369: 	 * @exception IOException					thrown on error
1:eac0369: 	 * @exception ClassNotFoundException		thrown on error
1:eac0369: 	 */
1:eac0369: 	public void readExternal(ObjectInput in)
1:eac0369: 		throws IOException, ClassNotFoundException
1:eac0369: 	{
1:eac0369: 		try
1:eac0369: 		{
1:eac0369: 			/*
1:eac0369: 			** Create a new RowLocation from the format id.
1:eac0369: 			*/
1:eac0369: 			int formatid = FormatIdUtil.readFormatIdInteger(in);
1:eac0369: 			rowLocation = (RowLocation)Monitor.newInstanceFromIdentifier(formatid);
1:eac0369: 			if (SanityManager.DEBUG)
1:eac0369: 			{
1:eac0369: 				SanityManager.ASSERT(rowLocation != null, "row location is null in readExternal");
1:eac0369: 			}
1:eac0369: 
1:f65be8f:             schemaName = (String) in.readObject();
1:eac0369: 			tableName = (String)in.readObject();
1:eac0369: 			type = in.readInt();
1:eac0369: 			stmtType = in.readInt();
1:eac0369: 			refUUID = (UUID)in.readObject();
1:eac0369: 			refConglomNumber = in.readLong();
1:f6d02c9:             refConstraintID = (UUID)in.readObject();
1:45da2f5:             refConstraintIsDeferrable = in.readBoolean();
1:eac0369: 
1:eac0369: 			fkConstraintNames = new String[ArrayUtil.readArrayLength(in)];
1:eac0369: 			ArrayUtil.readArrayItems(in, fkConstraintNames);
1:eac0369: 
1:eac0369: 			fkUUIDs = new UUID[ArrayUtil.readArrayLength(in)];
1:eac0369: 			ArrayUtil.readArrayItems(in, fkUUIDs);
1:eac0369: 
1:eac0369: 			fkConglomNumbers = ArrayUtil.readLongArray(in);
1:eac0369: 			fkIsSelfReferencing = ArrayUtil.readBooleanArray(in);
1:eac0369: 			colArray = ArrayUtil.readIntArray(in);
1:eac0369: 			raRules = ArrayUtil.readIntArray(in);
1:4cc0287:             deferrable = ArrayUtil.readBooleanArray(in);
1:b08f421:             fkIds = new UUID[ArrayUtil.readArrayLength(in)];
1:b08f421:             ArrayUtil.readArrayItems(in, fkIds);
1:eac0369: 		}
1:eac0369: 		catch (StandardException exception)
1:eac0369: 		{
1:eac0369: 			throw new StreamCorruptedException(exception.toString());
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 	
1:eac0369: 	/**
1:eac0369: 	 * Get the formatID which corresponds to this class.
1:eac0369: 	 *
1:eac0369: 	 *	@return	the formatID of this class
1:eac0369: 	 */
1:4cc0287:     public  int getTypeFormatId()   { return StoredFormatIds.FK_INFO_V01_ID; }
1:eac0369: 
1:eac0369: 	//////////////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	// Misc
1:eac0369: 	//
1:eac0369: 	//////////////////////////////////////////////////////////////
1:eac0369: 	public String toString()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:4cc0287:             StringBuilder str = new StringBuilder();
1:eac0369: 			str.append("\nTableName:\t\t\t");
1:eac0369: 			str.append(tableName);
1:eac0369: 
1:eac0369: 			str.append("\ntype:\t\t\t\t");
1:eac0369: 			str.append((type == FOREIGN_KEY) ? "FOREIGN_KEY" : "REFERENCED_KEY");
1:eac0369: 
1:45da2f5:             str.append("\nReferenced Key Index UUID:\t\t"+refUUID);
1:eac0369: 			str.append("\nReferenced Key ConglomNum:\t"+refConglomNumber);
1:45da2f5:             str.append("\nReferenced Key Constraint is deferrable:\t" +
1:45da2f5:                        refConstraintIsDeferrable);
1:eac0369: 
1:eac0369: 			str.append("\nForeign Key Names:\t\t(");
1:eac0369: 			for (int i = 0; i < fkUUIDs.length; i++)
1:eac0369: 			{
1:eac0369: 				if (i > 0)
1:eac0369: 					str.append(",");
1:eac0369: 			
1:eac0369: 				str.append(fkConstraintNames[i]);
1:eac0369: 			}
1:eac0369: 			str.append(")");
1:eac0369: 
1:eac0369: 			str.append("\nForeign Key UUIDS:\t\t(");
1:eac0369: 			for (int i = 0; i < fkUUIDs.length; i++)
1:eac0369: 			{
1:eac0369: 				if (i > 0)
1:eac0369: 					str.append(",");
1:eac0369: 			
1:eac0369: 				str.append(fkUUIDs[i]);
1:eac0369: 			}
1:eac0369: 			str.append(")");
1:eac0369: 
1:eac0369: 			str.append("\nForeign Key Conglom Nums:\t(");
1:eac0369: 			for (int i = 0; i < fkConglomNumbers.length; i++)
1:eac0369: 			{
1:eac0369: 				if (i > 0)
1:eac0369: 					str.append(",");
1:eac0369: 			
1:eac0369: 				str.append(fkConglomNumbers[i]);
1:eac0369: 			}
1:eac0369: 			str.append(")");
1:eac0369: 		
1:eac0369: 			str.append("\nForeign Key isSelfRef:\t\t(");
1:eac0369: 			for (int i = 0; i < fkIsSelfReferencing.length; i++)
1:eac0369: 			{
1:eac0369: 				if (i > 0)
1:eac0369: 					str.append(",");
1:eac0369: 			
1:eac0369: 				str.append(fkIsSelfReferencing[i]);
1:eac0369: 			}
1:eac0369: 			str.append(")");
1:eac0369: 		
1:eac0369: 			str.append("\ncolumn Array:\t\t\t(");
1:eac0369: 			for (int i = 0; i < colArray.length; i++)
1:eac0369: 			{
1:eac0369: 				if (i > 0)
1:eac0369: 					str.append(",");
1:eac0369: 			
1:eac0369: 				str.append(colArray[i]);
1:eac0369: 			}
1:eac0369: 			str.append(")\n");
1:45da2f5: 
1:4cc0287:             str.append("\nDeferrable array:\t\t\t(");
1:4cc0287:             for (int i = 0; i < deferrable.length; i++)
1:4cc0287:             {
1:4cc0287:                 if (i > 0)
1:4cc0287:                     str.append(",");
1:45da2f5: 
1:4cc0287:                 str.append(colArray[i]);
1:4cc0287:             }
1:4cc0287:             str.append(")\n");
1:4cc0287: 
1:4cc0287: 
1:eac0369: 
1:4cc0287:             return str.toString();
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return "";
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:f6d02c9
/////////////////////////////////////////////////////////////////////////
1:     UUID                refConstraintID;
/////////////////////////////////////////////////////////////////////////
1:      * @param refConstraintID UUID of the referenced constraint
/////////////////////////////////////////////////////////////////////////
1:                     UUID                refConstraintID,
/////////////////////////////////////////////////////////////////////////
1:         this.refConstraintID = refConstraintID;
/////////////////////////////////////////////////////////////////////////
1:         out.writeObject(refConstraintID);
/////////////////////////////////////////////////////////////////////////
1:             refConstraintID = (UUID)in.readObject();
commit:45da2f5
/////////////////////////////////////////////////////////////////////////
1:         out.writeBoolean(refConstraintIsDeferrable);
/////////////////////////////////////////////////////////////////////////
1:             refConstraintIsDeferrable = in.readBoolean();
/////////////////////////////////////////////////////////////////////////
1:             str.append("\nReferenced Key Index UUID:\t\t"+refUUID);
1:             str.append("\nReferenced Key Constraint is deferrable:\t" +
1:                        refConstraintIsDeferrable);
/////////////////////////////////////////////////////////////////////////
1: 
1: 
commit:9179199
/////////////////////////////////////////////////////////////////////////
1:     boolean             refConstraintIsDeferrable;
/////////////////////////////////////////////////////////////////////////
1:      * @param refUUID UUID of the referenced constraint's supporting index
1:      * @param refConstraintIsDeferrable {@code true} iff the referenced key
1:      *                                  constraint is deferrable
/////////////////////////////////////////////////////////////////////////
1:      * @param fkIds the foreign key constraints' uuids.
/////////////////////////////////////////////////////////////////////////
1:                     boolean             refConstraintIsDeferrable,
/////////////////////////////////////////////////////////////////////////
1:         this.refConstraintIsDeferrable = refConstraintIsDeferrable;
commit:4cc0287
/////////////////////////////////////////////////////////////////////////
1: import java.io.ObjectInput;
1: import java.io.ObjectOutput;
1: import java.io.StreamCorruptedException;
1: import org.apache.derby.catalog.UUID;
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.services.io.ArrayUtil;
1: import org.apache.derby.iapi.services.io.FormatIdUtil;
1: import org.apache.derby.iapi.services.io.Formatable;
1: import org.apache.derby.iapi.services.io.StoredFormatIds;
1: import org.apache.derby.iapi.services.monitor.Monitor;
1: import org.apache.derby.iapi.types.RowLocation;
1: import org.apache.derby.shared.common.sanity.SanityManager;
/////////////////////////////////////////////////////////////////////////
1:     **  If, between releases, you add more fields to this class,
/////////////////////////////////////////////////////////////////////////
1:     String              schemaName;
1:     UUID                refUUID; // index index conglomerate uuid
1: 
1:     // These arrays all have the same cardinality, either 1 (foreign key), or
1:     // the number of FKs referencing this referenced key
1:     String[]            fkConstraintNames;
1:     private UUID[]      fkUUIDs; // the index conglomerate uuids
1:     long[]              fkConglomNumbers;
1:     UUID[]              fkIds; // the constraint uuids
1:     boolean[]           fkIsSelfReferencing;
1:     int[]               colArray;
1:     boolean[]           deferrable;
/////////////////////////////////////////////////////////////////////////
1:      * Constructor for FKInfo
1:      * @param schemaName the name of the schema of the table being modified
1:      * @param refConglomNumber conglomerate number of the referenced key
1:      *          index of the referenced keys.  if REFERENCED_KEY,
1:      *          whether the foreign key references a key in the same table
1:      *          the current DML operation.
1:      * @param raRules referential action rules
1:      * @param deferrable the corresponding constraint is deferrable
1:                     String              schemaName,
1:                     String              tableName,
/////////////////////////////////////////////////////////////////////////
1:                     int[]               raRules,
1:                     boolean[]           deferrable,
1:                     UUID[]              fkIds
1:         this.schemaName = schemaName;
/////////////////////////////////////////////////////////////////////////
1:         this.deferrable = ArrayUtil.copy(deferrable);
1:         this.fkIds = ArrayUtil.copy(fkIds);
/////////////////////////////////////////////////////////////////////////
1:      * @param addAllTypeIsFK    take all with type == FOREIGN_KEY
/////////////////////////////////////////////////////////////////////////
1:         ArrayUtil.writeBooleanArray(out, deferrable);
/////////////////////////////////////////////////////////////////////////
1:             deferrable = ArrayUtil.readBooleanArray(in);
/////////////////////////////////////////////////////////////////////////
1:     public  int getTypeFormatId()   { return StoredFormatIds.FK_INFO_V01_ID; }
/////////////////////////////////////////////////////////////////////////
1:             StringBuilder str = new StringBuilder();
/////////////////////////////////////////////////////////////////////////
1:             str.append("\nDeferrable array:\t\t\t(");
1:             for (int i = 0; i < deferrable.length; i++)
1:             {
1:                 if (i > 0)
1:                     str.append(",");
1: 
1:                 str.append(colArray[i]);
1:             }
1:             str.append(")\n");
1: 
1:             return str.toString();
commit:801cf0d
/////////////////////////////////////////////////////////////////////////
1:                 newfks[i] = newfksVector.elementAt(i);
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:f65be8f
/////////////////////////////////////////////////////////////////////////
1:         out.writeObject(schemaName);
/////////////////////////////////////////////////////////////////////////
1:             schemaName = (String) in.readObject();
commit:b08f421
/////////////////////////////////////////////////////////////////////////
1:         ArrayUtil.writeArray(out, fkIds);
/////////////////////////////////////////////////////////////////////////
1:             fkIds = new UUID[ArrayUtil.readArrayLength(in)];
1:             ArrayUtil.readArrayItems(in, fkIds);
commit:3f7581c
/////////////////////////////////////////////////////////////////////////
1:         this.fkUUIDs = ArrayUtil.copy(fkUUIDs);
commit:42544c4
/////////////////////////////////////////////////////////////////////////
0:     String[]            fkConstraintNames;
1:     String              tableName;
1:     int                 type;
0:     UUID                refUUID;
1:     long                refConglomNumber;
0:     private UUID[]      fkUUIDs;
0:     long[]              fkConglomNumbers;
0:     boolean[]           fkIsSelfReferencing;
0:     int[]               colArray;
1:     int                 stmtType;
1:     RowLocation         rowLocation;
1:     int[]               raRules;
/////////////////////////////////////////////////////////////////////////
1:         this.fkConstraintNames = ArrayUtil.copy(fkConstraintNames);
0:         this.fkUUIDs = (UUID[]) ArrayUtil.copy(fkUUIDs);
1:         this.fkConglomNumbers = ArrayUtil.copy(fkConglomNumbers);
1:         this.fkIsSelfReferencing = ArrayUtil.copy(fkIsSelfReferencing);
1:         this.colArray = ArrayUtil.copy(colArray);
1:         this.raRules = ArrayUtil.copy(raRules);
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.shared.common.sanity.SanityManager;
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:71c8e86
/////////////////////////////////////////////////////////////////////////
1: 		Vector<FKInfo> newfksVector = new Vector<FKInfo>();
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:David Van Couvering
-------------------------------------------------------------------------------
commit:f6123ee
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
1: 	 * @param stmtType	the type of the statement: e.g. StatementType.INSERT
0: 	 * @param refConglomNumber congomerate number of the referenced key
1: 	 * @param fkIsSelfReferencing array of conglomerate booleans indicating
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.execute.FKInfo
1: 
0:    Copyright 1998, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:9e5097f
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.execute
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.sql.execute;
1: 
0: import org.apache.derby.catalog.UUID;
1: 
0: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.iapi.sql.dictionary.IndexRowGenerator;
1: 
0: import org.apache.derby.iapi.types.RowLocation;
1: 
0: import org.apache.derby.iapi.services.monitor.Monitor;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.services.io.StoredFormatIds;
0: import org.apache.derby.iapi.services.io.FormatIdUtil;
0: import org.apache.derby.iapi.services.io.ArrayUtil;
0: import org.apache.derby.iapi.services.io.Formatable;
1: 
0: import java.io.StreamCorruptedException;
0: import java.io.ObjectOutput;
0: import java.io.ObjectInput;
1: import java.io.IOException;
1: 
1: import java.util.Vector;
1: 
1: /**
1:  * This is a simple class used to store the run time information
1:  * about a foreign key.  Used by DML to figure out what to
1:  * check.
1:  *
0:  * @author jamie
1:  */
1: public class FKInfo implements Formatable 
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
1: 	/********************************************************
1: 	**
1: 	**	This class implements Formatable. That means that it
1: 	**	can write itself to and from a formatted stream. If
1: 	**	you add more fields to this class, make sure that you
1: 	**	also write/read them with the writeExternal()/readExternal()
1: 	**	methods.
1: 	**
0: 	**	If, inbetween releases, you add more fields to this class,
1: 	**	then you should bump the version number emitted by the getTypeFormatId()
1: 	**	method.  OR, since this is something that is used
1: 	**	in stored prepared statements, it is ok to change it
1: 	**	if you make sure that stored prepared statements are
1: 	**	invalidated across releases.
1: 	**
1: 	********************************************************/
1: 
1: 	public static final int FOREIGN_KEY = 1;
1: 	public static final int REFERENCED_KEY = 2;
1: 
1: 	/*
1: 	** See the constructor for the meaning of these fields
1: 	*/
0: 	public String				fkConstraintNames[];
0: 	public String				tableName;
0: 	public int					type;
0: 	public UUID					refUUID;
0: 	public long					refConglomNumber;
0: 	public UUID[]				fkUUIDs;
0: 	public long[]				fkConglomNumbers;
0: 	public boolean[]			fkIsSelfReferencing;
0: 	public int[]				colArray;
0: 	public int					stmtType;
0: 	public RowLocation			rowLocation;
0: 	public int[] 	            raRules;
1: 
1: 	/**
1: 	 * Niladic constructor for Formattable
1: 	 */
1: 	public FKInfo() {}
1: 
1: 	/**
0: 	 * Consructor for FKInfo
1: 	 *
1: 	 * @param fkConstraintNames the foreign key constraint names
1: 	 * @param tableName	the name of the table being modified
0: 	 * @param statementType	the type of the statement: e.g. StatementType.INSERT
1: 	 * @param type either FKInfo.REFERENCED_KEY or FKInfo.FOREIGN_KEY
0: 	 * @param refUUID UUID of the referenced constraint
0: 	 * @param refConglomMnubmer congomerate number of the referenced key
1: 	 * @param fkUUIDs an array of fkUUIDs of backing indexes.  if
1: 	 *			FOREIGN_KEY, then just one element, the backing
0: 	 *			index of the referrenced keys.  if REFERENCED_KEY,
1: 	 *			then all the foreign keys
1: 	 * @param fkConglomNumbers array of conglomerate numbers, corresponds
1: 	 *			to fkUUIDs
0: 	 * @param fkIsSelfRefernecing array of conglomerate booleans indicating
0: 	 *			whether the fk references a key in the same table
1: 	 * @param colArray map of columns to the base row that DML
1: 	 * 			is changing.  1 based.  Note that this maps the
1: 	 *			constraint index to a row in the target table of
0: 	 *			the current dml operation.
1: 	 * @param rowLocation a row location template for the target table
1: 	 *			used to pass in a template row to tc.openScan()
1: 	 */
1: 	public FKInfo(
1: 					String[]			fkConstraintNames,
0: 					String				tableName,
1: 					int					stmtType,
1: 					int					type,
1: 					UUID				refUUID,
1: 					long				refConglomNumber,
1: 					UUID[]				fkUUIDs,
1: 					long[]				fkConglomNumbers,
1: 					boolean[]			fkIsSelfReferencing,
1: 					int[]				colArray,
1: 					RowLocation			rowLocation,
0: 					int[]               raRules
1: 					)
1: 	{
0: 		this.fkConstraintNames = fkConstraintNames;
1: 		this.tableName = tableName;
1: 		this.stmtType = stmtType;
1: 		this.type = type;
1: 		this.refUUID = refUUID;
1: 		this.refConglomNumber = refConglomNumber;
0: 		this.fkUUIDs = fkUUIDs;
0: 		this.fkConglomNumbers = fkConglomNumbers;
0: 		this.fkIsSelfReferencing = fkIsSelfReferencing;
0: 		this.colArray = colArray;
1: 		this.rowLocation = rowLocation;
0: 		this.raRules = raRules;
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			if (fkUUIDs.length != fkConglomNumbers.length)
1: 			{
1: 				SanityManager.THROWASSERT("number of ForeignKey UUIDS ("+fkUUIDs.length+
1: 										") doesn't match the number of conglomerate numbers"+
1: 										" ("+fkConglomNumbers.length+")");
1: 			}
1: 			if (type == FOREIGN_KEY)
1: 			{
1: 				SanityManager.ASSERT(fkUUIDs.length == 1, "unexpected number of fkUUIDs for a foreign key, should only have the uuid of the key it references");
1: 			}
1: 			else if (type == REFERENCED_KEY)
1: 			{
1: 				SanityManager.ASSERT(fkUUIDs.length >= 1, "too few fkUUIDs for a referenced key, expect at least one foreign key");
1: 			}
1: 			else
1: 			{
1: 				SanityManager.THROWASSERT("bad type: "+type);
1: 			}
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Comb through the FKInfo structures and pick out the
1: 	 * ones that have columns that intersect with the input
1: 	 * columns.
1: 	 *
1:  	 * @param fkInfo	        array of fkinfos
1: 	 * @param cols	            array of columns
0: 	 * @param addAllTypeIsFK	take all with type == FORIEGN_KEY
1: 	 *
1: 	 * @return array of relevant fkinfos
1: 	 */
1: 	public static FKInfo[] chooseRelevantFKInfos
1: 	(	
1: 		FKInfo[] 	fkInfo, 
1: 		int[] 		cols,
1: 		boolean		addAllTypeIsFK)
1: 	{
1: 		if (fkInfo == null)
1: 		{
1: 			return (FKInfo[])null;
1: 		}
1: 
0: 		Vector newfksVector = new Vector();
1: 		FKInfo[] newfks = null;
1: 
1: 		/*
1: 		** For each FKInfo
1: 		*/
1: 		for (int i = 0; i < fkInfo.length; i++)
1: 		{
1: 			if (addAllTypeIsFK && 
1: 				(fkInfo[i].type == FOREIGN_KEY))
1: 			{
1: 				newfksVector.addElement(fkInfo[i]);
1: 				continue;
1: 			}
1: 				
1: 			int fkcollen = fkInfo[i].colArray.length;
1: 			for (int fkCols = 0; fkCols < fkcollen; fkCols++)
1: 			{
1: 				for (int chcol = 0; chcol < cols.length; chcol++)
1: 				{
1: 					/*
1: 					** If any column intersects, the FKInfo is
1: 					** relevant.
1: 					*/
1: 					if (fkInfo[i].colArray[fkCols] == cols[chcol])
1: 					{
1: 						newfksVector.addElement(fkInfo[i]);
1: 						
1: 						// go to the next fk
1: 						fkCols = fkcollen;
1: 						break;
1: 					}
1: 				}
1: 			}
1: 		}
1: 
1: 		
1: 		/*
1: 		** Now convert the vector into an array.
1: 		*/
1: 		int size = newfksVector.size();
1: 		if (size > 0)
1: 		{
1: 			newfks = new FKInfo[size];
1: 			for (int i = 0; i < size; i++)
1: 			{
0: 				newfks[i] = (FKInfo)newfksVector.elementAt(i);
1: 			}
1: 		}
1: 		return newfks;
1: 	}
1: 		
1: 	//////////////////////////////////////////////
1: 	//
1: 	// FORMATABLE
1: 	//
1: 	//////////////////////////////////////////////
1: 	/**
1: 	 * Write this object out
1: 	 *
1: 	 * @param out write bytes here
1: 	 *
1:  	 * @exception IOException thrown on error
1: 	 */
1: 	public void writeExternal(ObjectOutput out) throws IOException
1: 	{
1: 		/*
1: 		** Row locations cannot be written unless they
1: 		** have a valid value.  So we'll just write out
1: 		** the format id, and create a new RowLocation
1: 		** when we read it back in.
1: 		*/
1: 		FormatIdUtil.writeFormatIdInteger(out, rowLocation.getTypeFormatId());
1: 
1: 		out.writeObject(tableName);
1: 		out.writeInt(type);
1: 		out.writeInt(stmtType);
1: 		out.writeObject(refUUID);
1: 		out.writeLong(refConglomNumber);
1: 
1: 		ArrayUtil.writeArray(out, fkConstraintNames);
1: 		ArrayUtil.writeArray(out, fkUUIDs);
1: 		ArrayUtil.writeLongArray(out, fkConglomNumbers);
1: 		ArrayUtil.writeBooleanArray(out, fkIsSelfReferencing);
1: 		ArrayUtil.writeIntArray(out, colArray);
1: 		ArrayUtil.writeIntArray(out, raRules);
1: 		
1: 	}
1: 
1: 	/**
1: 	 * Read this object from a stream of stored objects.
1: 	 *
1: 	 * @param in read this.
1: 	 *
1: 	 * @exception IOException					thrown on error
1: 	 * @exception ClassNotFoundException		thrown on error
1: 	 */
1: 	public void readExternal(ObjectInput in)
1: 		throws IOException, ClassNotFoundException
1: 	{
1: 		try
1: 		{
1: 			/*
1: 			** Create a new RowLocation from the format id.
1: 			*/
1: 			int formatid = FormatIdUtil.readFormatIdInteger(in);
1: 			rowLocation = (RowLocation)Monitor.newInstanceFromIdentifier(formatid);
1: 			if (SanityManager.DEBUG)
1: 			{
1: 				SanityManager.ASSERT(rowLocation != null, "row location is null in readExternal");
1: 			}
1: 
1: 			tableName = (String)in.readObject();
1: 			type = in.readInt();
1: 			stmtType = in.readInt();
1: 			refUUID = (UUID)in.readObject();
1: 			refConglomNumber = in.readLong();
1: 
1: 			fkConstraintNames = new String[ArrayUtil.readArrayLength(in)];
1: 			ArrayUtil.readArrayItems(in, fkConstraintNames);
1: 
1: 			fkUUIDs = new UUID[ArrayUtil.readArrayLength(in)];
1: 			ArrayUtil.readArrayItems(in, fkUUIDs);
1: 
1: 			fkConglomNumbers = ArrayUtil.readLongArray(in);
1: 			fkIsSelfReferencing = ArrayUtil.readBooleanArray(in);
1: 			colArray = ArrayUtil.readIntArray(in);
1: 			raRules = ArrayUtil.readIntArray(in);
1: 		}
1: 		catch (StandardException exception)
1: 		{
1: 			throw new StreamCorruptedException(exception.toString());
1: 		}
1: 	}
1: 	
1: 	/**
1: 	 * Get the formatID which corresponds to this class.
1: 	 *
1: 	 *	@return	the formatID of this class
1: 	 */
0: 	public	int	getTypeFormatId()	{ return StoredFormatIds.FK_INFO_V01_ID; }
1: 
1: 	//////////////////////////////////////////////////////////////
1: 	//
1: 	// Misc
1: 	//
1: 	//////////////////////////////////////////////////////////////
1: 	public String toString()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			StringBuffer str = new StringBuffer();
1: 			str.append("\nTableName:\t\t\t");
1: 			str.append(tableName);
1: 
1: 			str.append("\ntype:\t\t\t\t");
1: 			str.append((type == FOREIGN_KEY) ? "FOREIGN_KEY" : "REFERENCED_KEY");
1: 
0: 			str.append("\nReferenced Key UUID:\t\t"+refUUID);
1: 			str.append("\nReferenced Key ConglomNum:\t"+refConglomNumber);
1: 
1: 			str.append("\nForeign Key Names:\t\t(");
1: 			for (int i = 0; i < fkUUIDs.length; i++)
1: 			{
1: 				if (i > 0)
1: 					str.append(",");
1: 			
1: 				str.append(fkConstraintNames[i]);
1: 			}
1: 			str.append(")");
1: 
1: 			str.append("\nForeign Key UUIDS:\t\t(");
1: 			for (int i = 0; i < fkUUIDs.length; i++)
1: 			{
1: 				if (i > 0)
1: 					str.append(",");
1: 			
1: 				str.append(fkUUIDs[i]);
1: 			}
1: 			str.append(")");
1: 
1: 			str.append("\nForeign Key Conglom Nums:\t(");
1: 			for (int i = 0; i < fkConglomNumbers.length; i++)
1: 			{
1: 				if (i > 0)
1: 					str.append(",");
1: 			
1: 				str.append(fkConglomNumbers[i]);
1: 			}
1: 			str.append(")");
1: 		
1: 			str.append("\nForeign Key isSelfRef:\t\t(");
1: 			for (int i = 0; i < fkIsSelfReferencing.length; i++)
1: 			{
1: 				if (i > 0)
1: 					str.append(",");
1: 			
1: 				str.append(fkIsSelfReferencing[i]);
1: 			}
1: 			str.append(")");
1: 		
1: 			str.append("\ncolumn Array:\t\t\t(");
1: 			for (int i = 0; i < colArray.length; i++)
1: 			{
1: 				if (i > 0)
1: 					str.append(",");
1: 			
1: 				str.append(colArray[i]);
1: 			}
1: 			str.append(")\n");
1: 
0: 			return str.toString();
1: 		}
1: 		else
1: 		{
1: 			return "";
1: 		}
1: 	}
1: }
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.execute
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.sql.execute;
0: 
0: import org.apache.derby.catalog.UUID;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.sql.dictionary.IndexRowGenerator;
0: 
0: import org.apache.derby.iapi.types.RowLocation;
0: 
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.services.io.StoredFormatIds;
0: import org.apache.derby.iapi.services.io.FormatIdUtil;
0: import org.apache.derby.iapi.services.io.ArrayUtil;
0: import org.apache.derby.iapi.services.io.Formatable;
0: 
0: import java.io.StreamCorruptedException;
0: import java.io.ObjectOutput;
0: import java.io.ObjectInput;
0: import java.io.IOException;
0: 
0: import java.util.Vector;
0: 
0: /**
0:  * This is a simple class used to store the run time information
0:  * about a foreign key.  Used by DML to figure out what to
0:  * check.
0:  *
0:  * @author jamie
0:  */
0: public class FKInfo implements Formatable 
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
0: 	/********************************************************
0: 	**
0: 	**	This class implements Formatable. That means that it
0: 	**	can write itself to and from a formatted stream. If
0: 	**	you add more fields to this class, make sure that you
0: 	**	also write/read them with the writeExternal()/readExternal()
0: 	**	methods.
0: 	**
0: 	**	If, inbetween releases, you add more fields to this class,
0: 	**	then you should bump the version number emitted by the getTypeFormatId()
0: 	**	method.  OR, since this is something that is used
0: 	**	in stored prepared statements, it is ok to change it
0: 	**	if you make sure that stored prepared statements are
0: 	**	invalidated across releases.
0: 	**
0: 	********************************************************/
0: 
0: 	public static final int FOREIGN_KEY = 1;
0: 	public static final int REFERENCED_KEY = 2;
0: 
0: 	/*
0: 	** See the constructor for the meaning of these fields
0: 	*/
0: 	public String				fkConstraintNames[];
0: 	public String				tableName;
0: 	public int					type;
0: 	public UUID					refUUID;
0: 	public long					refConglomNumber;
0: 	public UUID[]				fkUUIDs;
0: 	public long[]				fkConglomNumbers;
0: 	public boolean[]			fkIsSelfReferencing;
0: 	public int[]				colArray;
0: 	public int					stmtType;
0: 	public RowLocation			rowLocation;
0: 	public int[] 	            raRules;
0: 
0: 	/**
0: 	 * Niladic constructor for Formattable
0: 	 */
0: 	public FKInfo() {}
0: 
0: 	/**
0: 	 * Consructor for FKInfo
0: 	 *
0: 	 * @param fkConstraintNames the foreign key constraint names
0: 	 * @param tableName	the name of the table being modified
0: 	 * @param statementType	the type of the statement: e.g. StatementType.INSERT
0: 	 * @param type either FKInfo.REFERENCED_KEY or FKInfo.FOREIGN_KEY
0: 	 * @param refUUID UUID of the referenced constraint
0: 	 * @param refConglomMnubmer congomerate number of the referenced key
0: 	 * @param fkUUIDs an array of fkUUIDs of backing indexes.  if
0: 	 *			FOREIGN_KEY, then just one element, the backing
0: 	 *			index of the referrenced keys.  if REFERENCED_KEY,
0: 	 *			then all the foreign keys
0: 	 * @param fkConglomNumbers array of conglomerate numbers, corresponds
0: 	 *			to fkUUIDs
0: 	 * @param fkIsSelfRefernecing array of conglomerate booleans indicating
0: 	 *			whether the fk references a key in the same table
0: 	 * @param colArray map of columns to the base row that DML
0: 	 * 			is changing.  1 based.  Note that this maps the
0: 	 *			constraint index to a row in the target table of
0: 	 *			the current dml operation.
0: 	 * @param rowLocation a row location template for the target table
0: 	 *			used to pass in a template row to tc.openScan()
0: 	 */
0: 	public FKInfo(
0: 					String[]			fkConstraintNames,
0: 					String				tableName,
0: 					int					stmtType,
0: 					int					type,
0: 					UUID				refUUID,
0: 					long				refConglomNumber,
0: 					UUID[]				fkUUIDs,
0: 					long[]				fkConglomNumbers,
0: 					boolean[]			fkIsSelfReferencing,
0: 					int[]				colArray,
0: 					RowLocation			rowLocation,
0: 					int[]               raRules
0: 					)
0: 	{
0: 		this.fkConstraintNames = fkConstraintNames;
0: 		this.tableName = tableName;
0: 		this.stmtType = stmtType;
0: 		this.type = type;
0: 		this.refUUID = refUUID;
0: 		this.refConglomNumber = refConglomNumber;
0: 		this.fkUUIDs = fkUUIDs;
0: 		this.fkConglomNumbers = fkConglomNumbers;
0: 		this.fkIsSelfReferencing = fkIsSelfReferencing;
0: 		this.colArray = colArray;
0: 		this.rowLocation = rowLocation;
0: 		this.raRules = raRules;
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (fkUUIDs.length != fkConglomNumbers.length)
0: 			{
0: 				SanityManager.THROWASSERT("number of ForeignKey UUIDS ("+fkUUIDs.length+
0: 										") doesn't match the number of conglomerate numbers"+
0: 										" ("+fkConglomNumbers.length+")");
0: 			}
0: 			if (type == FOREIGN_KEY)
0: 			{
0: 				SanityManager.ASSERT(fkUUIDs.length == 1, "unexpected number of fkUUIDs for a foreign key, should only have the uuid of the key it references");
0: 			}
0: 			else if (type == REFERENCED_KEY)
0: 			{
0: 				SanityManager.ASSERT(fkUUIDs.length >= 1, "too few fkUUIDs for a referenced key, expect at least one foreign key");
0: 			}
0: 			else
0: 			{
0: 				SanityManager.THROWASSERT("bad type: "+type);
0: 			}
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Comb through the FKInfo structures and pick out the
0: 	 * ones that have columns that intersect with the input
0: 	 * columns.
0: 	 *
0:  	 * @param fkInfo	        array of fkinfos
0: 	 * @param cols	            array of columns
0: 	 * @param addAllTypeIsFK	take all with type == FORIEGN_KEY
0: 	 *
0: 	 * @return array of relevant fkinfos
0: 	 */
0: 	public static FKInfo[] chooseRelevantFKInfos
0: 	(	
0: 		FKInfo[] 	fkInfo, 
0: 		int[] 		cols,
0: 		boolean		addAllTypeIsFK)
0: 	{
0: 		if (fkInfo == null)
0: 		{
0: 			return (FKInfo[])null;
0: 		}
0: 
0: 		Vector newfksVector = new Vector();
0: 		FKInfo[] newfks = null;
0: 
0: 		/*
0: 		** For each FKInfo
0: 		*/
0: 		for (int i = 0; i < fkInfo.length; i++)
0: 		{
0: 			if (addAllTypeIsFK && 
0: 				(fkInfo[i].type == FOREIGN_KEY))
0: 			{
0: 				newfksVector.addElement(fkInfo[i]);
0: 				continue;
0: 			}
0: 				
0: 			int fkcollen = fkInfo[i].colArray.length;
0: 			for (int fkCols = 0; fkCols < fkcollen; fkCols++)
0: 			{
0: 				for (int chcol = 0; chcol < cols.length; chcol++)
0: 				{
0: 					/*
0: 					** If any column intersects, the FKInfo is
0: 					** relevant.
0: 					*/
0: 					if (fkInfo[i].colArray[fkCols] == cols[chcol])
0: 					{
0: 						newfksVector.addElement(fkInfo[i]);
0: 						
0: 						// go to the next fk
0: 						fkCols = fkcollen;
0: 						break;
0: 					}
0: 				}
0: 			}
0: 		}
0: 
0: 		
0: 		/*
0: 		** Now convert the vector into an array.
0: 		*/
0: 		int size = newfksVector.size();
0: 		if (size > 0)
0: 		{
0: 			newfks = new FKInfo[size];
0: 			for (int i = 0; i < size; i++)
0: 			{
0: 				newfks[i] = (FKInfo)newfksVector.elementAt(i);
0: 			}
0: 		}
0: 		return newfks;
0: 	}
0: 		
0: 	//////////////////////////////////////////////
0: 	//
0: 	// FORMATABLE
0: 	//
0: 	//////////////////////////////////////////////
0: 	/**
0: 	 * Write this object out
0: 	 *
0: 	 * @param out write bytes here
0: 	 *
0:  	 * @exception IOException thrown on error
0: 	 */
0: 	public void writeExternal(ObjectOutput out) throws IOException
0: 	{
0: 		/*
0: 		** Row locations cannot be written unless they
0: 		** have a valid value.  So we'll just write out
0: 		** the format id, and create a new RowLocation
0: 		** when we read it back in.
0: 		*/
0: 		FormatIdUtil.writeFormatIdInteger(out, rowLocation.getTypeFormatId());
0: 
0: 		out.writeObject(tableName);
0: 		out.writeInt(type);
0: 		out.writeInt(stmtType);
0: 		out.writeObject(refUUID);
0: 		out.writeLong(refConglomNumber);
0: 
0: 		ArrayUtil.writeArray(out, fkConstraintNames);
0: 		ArrayUtil.writeArray(out, fkUUIDs);
0: 		ArrayUtil.writeLongArray(out, fkConglomNumbers);
0: 		ArrayUtil.writeBooleanArray(out, fkIsSelfReferencing);
0: 		ArrayUtil.writeIntArray(out, colArray);
0: 		ArrayUtil.writeIntArray(out, raRules);
0: 		
0: 	}
0: 
0: 	/**
0: 	 * Read this object from a stream of stored objects.
0: 	 *
0: 	 * @param in read this.
0: 	 *
0: 	 * @exception IOException					thrown on error
0: 	 * @exception ClassNotFoundException		thrown on error
0: 	 */
0: 	public void readExternal(ObjectInput in)
0: 		throws IOException, ClassNotFoundException
0: 	{
0: 		try
0: 		{
0: 			/*
0: 			** Create a new RowLocation from the format id.
0: 			*/
0: 			int formatid = FormatIdUtil.readFormatIdInteger(in);
0: 			rowLocation = (RowLocation)Monitor.newInstanceFromIdentifier(formatid);
0: 			if (SanityManager.DEBUG)
0: 			{
0: 				SanityManager.ASSERT(rowLocation != null, "row location is null in readExternal");
0: 			}
0: 
0: 			tableName = (String)in.readObject();
0: 			type = in.readInt();
0: 			stmtType = in.readInt();
0: 			refUUID = (UUID)in.readObject();
0: 			refConglomNumber = in.readLong();
0: 
0: 			fkConstraintNames = new String[ArrayUtil.readArrayLength(in)];
0: 			ArrayUtil.readArrayItems(in, fkConstraintNames);
0: 
0: 			fkUUIDs = new UUID[ArrayUtil.readArrayLength(in)];
0: 			ArrayUtil.readArrayItems(in, fkUUIDs);
0: 
0: 			fkConglomNumbers = ArrayUtil.readLongArray(in);
0: 			fkIsSelfReferencing = ArrayUtil.readBooleanArray(in);
0: 			colArray = ArrayUtil.readIntArray(in);
0: 			raRules = ArrayUtil.readIntArray(in);
0: 		}
0: 		catch (StandardException exception)
0: 		{
0: 			throw new StreamCorruptedException(exception.toString());
0: 		}
0: 	}
0: 	
0: 	/**
0: 	 * Get the formatID which corresponds to this class.
0: 	 *
0: 	 *	@return	the formatID of this class
0: 	 */
0: 	public	int	getTypeFormatId()	{ return StoredFormatIds.FK_INFO_V01_ID; }
0: 
0: 	//////////////////////////////////////////////////////////////
0: 	//
0: 	// Misc
0: 	//
0: 	//////////////////////////////////////////////////////////////
0: 	public String toString()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			StringBuffer str = new StringBuffer();
0: 			str.append("\nTableName:\t\t\t");
0: 			str.append(tableName);
0: 
0: 			str.append("\ntype:\t\t\t\t");
0: 			str.append((type == FOREIGN_KEY) ? "FOREIGN_KEY" : "REFERENCED_KEY");
0: 
0: 			str.append("\nReferenced Key UUID:\t\t"+refUUID);
0: 			str.append("\nReferenced Key ConglomNum:\t"+refConglomNumber);
0: 
0: 			str.append("\nForeign Key Names:\t\t(");
0: 			for (int i = 0; i < fkUUIDs.length; i++)
0: 			{
0: 				if (i > 0)
0: 					str.append(",");
0: 			
0: 				str.append(fkConstraintNames[i]);
0: 			}
0: 			str.append(")");
0: 
0: 			str.append("\nForeign Key UUIDS:\t\t(");
0: 			for (int i = 0; i < fkUUIDs.length; i++)
0: 			{
0: 				if (i > 0)
0: 					str.append(",");
0: 			
0: 				str.append(fkUUIDs[i]);
0: 			}
0: 			str.append(")");
0: 
0: 			str.append("\nForeign Key Conglom Nums:\t(");
0: 			for (int i = 0; i < fkConglomNumbers.length; i++)
0: 			{
0: 				if (i > 0)
0: 					str.append(",");
0: 			
0: 				str.append(fkConglomNumbers[i]);
0: 			}
0: 			str.append(")");
0: 		
0: 			str.append("\nForeign Key isSelfRef:\t\t(");
0: 			for (int i = 0; i < fkIsSelfReferencing.length; i++)
0: 			{
0: 				if (i > 0)
0: 					str.append(",");
0: 			
0: 				str.append(fkIsSelfReferencing[i]);
0: 			}
0: 			str.append(")");
0: 		
0: 			str.append("\ncolumn Array:\t\t\t(");
0: 			for (int i = 0; i < colArray.length; i++)
0: 			{
0: 				if (i > 0)
0: 					str.append(",");
0: 			
0: 				str.append(colArray[i]);
0: 			}
0: 			str.append(")\n");
0: 
0: 			return str.toString();
0: 		}
0: 		else
0: 		{
0: 			return "";
0: 		}
0: 	}
0: }
============================================================================