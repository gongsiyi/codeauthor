1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.conn.GenericLanguageConnectionFactory
1:345de35: 
1:575d6a1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:575d6a1:    contributor license agreements.  See the NOTICE file distributed with
1:575d6a1:    this work for additional information regarding copyright ownership.
1:575d6a1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:575d6a1:    (the "License"); you may not use this file except in compliance with
1:575d6a1:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
17:eac0369: 
4:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.sql.conn;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.sql.conn.LanguageConnectionFactory;
1:eac0369: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1:eac0369: import org.apache.derby.iapi.sql.compile.CompilerContext;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.sql.LanguageFactory;
1:eac0369: import org.apache.derby.impl.sql.GenericStatement;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.uuid.UUIDFactory;
1:eac0369: import org.apache.derby.iapi.services.compiler.JavaFactory;
1:eac0369: import org.apache.derby.iapi.services.loader.ClassFactory;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.db.Database;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.access.TransactionController;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.sql.compile.TypeCompilerFactory;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.sql.compile.Parser;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.property.PropertyFactory;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.sql.Statement;
1:eac0369: import org.apache.derby.iapi.sql.compile.OptimizerFactory;
1:eac0369: import org.apache.derby.iapi.types.DataValueFactory;
1:eac0369: import org.apache.derby.iapi.sql.execute.ExecutionFactory;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
1:eac0369: 
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.monitor.Monitor;
1:eac0369: import org.apache.derby.iapi.services.monitor.ModuleControl;
1:56c1dc2: import org.apache.derby.iapi.services.monitor.ModuleFactory;
1:eac0369: import org.apache.derby.iapi.services.monitor.ModuleSupportable;
1:eac0369: import org.apache.derby.iapi.services.context.ContextManager;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.cache.CacheFactory;
1:eac0369: import org.apache.derby.iapi.services.cache.CacheManager;
1:eac0369: import org.apache.derby.iapi.services.cache.CacheableFactory;
1:eac0369: import org.apache.derby.iapi.services.cache.Cacheable;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.property.PropertyUtil;
1:eac0369: import org.apache.derby.iapi.services.property.PropertySetCallback;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.reference.SQLState;
1:eac0369: import org.apache.derby.iapi.reference.Property;
1:eac0369: import org.apache.derby.iapi.reference.EngineType;
1:eac0369: 
1:56c1dc2: import java.security.AccessController;
1:56c1dc2: import java.security.PrivilegedActionException;
1:56c1dc2: import java.security.PrivilegedAction;
1:56c1dc2: import java.security.PrivilegedExceptionAction;
1:eac0369: import java.util.Properties;
1:eac0369: import java.util.Dictionary;
1:eac0369: import java.io.Serializable;
1:eac0369: import org.apache.derby.iapi.util.IdUtil;
1:eac0369: import org.apache.derby.iapi.services.daemon.Serviceable;
1:6da88fc: import org.apache.derby.iapi.store.raw.data.DataFactory;
1:eac0369: import org.apache.derby.iapi.util.StringUtil;
1:eac0369: 
4:eac0369: /**
1:eac0369:  * LanguageConnectionFactory generates all of the items
1:eac0369:  * a language system needs that is specific to a particular
1:eac0369:  * connection. Alot of these are other factories.
2:eac0369:  *
1:eac0369:  */
1:eac0369: public class GenericLanguageConnectionFactory
1:eac0369: 	implements LanguageConnectionFactory, CacheableFactory, PropertySetCallback, ModuleControl, ModuleSupportable {
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 		fields
1:eac0369: 	 */
1:eac0369: 	private 	ExecutionFactory		ef;
1:eac0369: 	private 	OptimizerFactory		of;
1:eac0369: 	private		TypeCompilerFactory		tcf;
1:eac0369: 	private 	DataValueFactory		dvf;
1:eac0369: 	private 	UUIDFactory				uuidFactory;
1:eac0369: 	private 	JavaFactory				javaFactory;
1:eac0369: 	private 	ClassFactory			classFactory;
1:eac0369: 	private 	PropertyFactory			pf;
1:eac0369: 
1:eac0369: 	private		int						nextLCCInstanceNumber;
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	  for caching prepared statements 
1:eac0369: 	*/
1:eac0369: 	private int cacheSize = org.apache.derby.iapi.reference.Property.STATEMENT_CACHE_SIZE_DEFAULT;
1:eac0369: 	private CacheManager singleStatementCache;
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	   constructor
1:eac0369: 	*/
1:eac0369: 	public GenericLanguageConnectionFactory() {
6:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	   LanguageConnectionFactory interface
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 		these are the methods that do real work, not just look for factories
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Get a Statement for the connection
1:5087be8: 		@param compilationSchema schema
1:eac0369: 		@param statementText the text for the statement
1:5087be8: 		@param forReadOnly if concurrency is CONCUR_READ_ONLY
1:eac0369: 		@return	The Statement
1:eac0369: 	 */
1:5087be8:         public Statement getStatement(SchemaDescriptor compilationSchema, String statementText, boolean forReadOnly)
3:eac0369:         {
1:5087be8: 	    return new GenericStatement(compilationSchema, statementText, forReadOnly);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Get a LanguageConnectionContext. this holds things
1:eac0369: 		we want to remember about activity in the language system,
1:eac0369: 		where this factory holds things that are pretty stable,
1:eac0369: 		like other factories.
1:eac0369: 		<p>
1:eac0369: 		The returned LanguageConnectionContext is intended for use
1:eac0369: 		only by the connection that requested it.
1:eac0369: 
1:eac0369: 		@return a language connection context for the context stack.
1:eac0369: 		@exception StandardException the usual -- for the subclass
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	public LanguageConnectionContext newLanguageConnectionContext(
1:eac0369: 		ContextManager cm,
1:eac0369: 		TransactionController tc,
1:eac0369: 		LanguageFactory lf,
1:eac0369: 		Database db,
1:eac0369: 		String userName,
1:eac0369: 		String drdaID,
1:eac0369: 		String dbname) throws StandardException {
1:eac0369: 		
1:eac0369: 		return new GenericLanguageConnectionContext(cm,
1:eac0369: 													tc,
1:eac0369: 													lf,
1:eac0369: 													this,
1:eac0369: 													db,
1:eac0369: 													userName,
1:eac0369: 													getNextLCCInstanceNumber(),
1:eac0369: 													drdaID,
1:eac0369: 													dbname);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public Cacheable newCacheable(CacheManager cm) {
1:eac0369: 		return new CachedStatement();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 		these methods all look for factories that we booted.
1:eac0369: 	 */
1:eac0369: 	 
1:eac0369: 	 /**
1:eac0369: 		Get the UUIDFactory to use with this language connection
1:eac0369: 		REMIND: this is only used by the compiler; should there be
1:eac0369: 		a compiler module control class to boot compiler-only stuff?
1:eac0369: 	 */
1:eac0369: 	public UUIDFactory	getUUIDFactory()
1:eac0369: 	{
1:eac0369: 		return uuidFactory;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Get the ClassFactory to use with this language connection
1:eac0369: 	 */
1:eac0369: 	public ClassFactory	getClassFactory()
1:eac0369: 	{
1:eac0369: 		return classFactory;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Get the JavaFactory to use with this language connection
1:eac0369: 		REMIND: this is only used by the compiler; should there be
1:eac0369: 		a compiler module control class to boot compiler-only stuff?
1:eac0369: 	 */
1:eac0369: 	public JavaFactory	getJavaFactory()
1:eac0369: 	{
1:eac0369: 		return javaFactory;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Get the ExecutionFactory to use with this language connection
1:eac0369: 	 */
1:eac0369: 	public ExecutionFactory	getExecutionFactory() {
1:eac0369: 		return ef;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Get the PropertyFactory to use with this language connection
1:eac0369: 	 */
1:eac0369: 	public PropertyFactory	getPropertyFactory() 
1:eac0369: 	{
1:eac0369: 		return pf;
1:eac0369: 	}	
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Get the OptimizerFactory to use with this language connection
1:eac0369: 	 */
1:eac0369: 	public OptimizerFactory	getOptimizerFactory() {
1:eac0369: 		return of;
1:eac0369: 	}
1:eac0369: 	/**
1:eac0369: 		Get the TypeCompilerFactory to use with this language connection
1:eac0369: 	 */
1:eac0369: 	public TypeCompilerFactory getTypeCompilerFactory() {
1:eac0369: 		return tcf;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Get the DataValueFactory to use with this language connection
1:eac0369: 	 */
1:eac0369: 	public DataValueFactory		getDataValueFactory() {
1:eac0369: 		return dvf;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 		ModuleControl interface
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		this implementation will not support caching of statements.
1:eac0369: 	 */
1:eac0369: 	public boolean canSupport(Properties startParams) {
1:eac0369: 
1:b084bcd: 		return Monitor.isDesiredType( startParams,
1:b084bcd:                 EngineType.STANDALONE_DB | EngineType.STORELESS_ENGINE);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	private	int	statementCacheSize(Properties startParams)
1:eac0369: 	{
1:eac0369: 		String wantCacheProperty = null;
1:eac0369: 
1:eac0369: 		wantCacheProperty =
1:eac0369: 			PropertyUtil.getPropertyFromSet(startParams, org.apache.derby.iapi.reference.Property.STATEMENT_CACHE_SIZE);
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.DEBUG("StatementCacheInfo", "Cacheing implementation chosen if null or 0<"+wantCacheProperty);
1:eac0369: 
1:eac0369: 		if (wantCacheProperty != null) {
1:eac0369: 			try {
1:eac0369: 			    cacheSize = Integer.parseInt(wantCacheProperty);
1:eac0369: 			} catch (NumberFormatException nfe) {
1:eac0369: 				cacheSize = org.apache.derby.iapi.reference.Property.STATEMENT_CACHE_SIZE_DEFAULT; 
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return cacheSize;
1:eac0369: 	}
1:eac0369: 	
1:eac0369: 	/**
1:eac0369: 	 * Start-up method for this instance of the language connection factory.
1:eac0369: 	 * Note these are expected to be booted relative to a Database.
1:eac0369: 	 *
1:eac0369: 	 * @param startParams	The start-up parameters (ignored in this case)
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException	Thrown on failure to boot
1:eac0369: 	 */
1:eac0369: 	public void boot(boolean create, Properties startParams) 
1:eac0369: 		throws StandardException {
1:eac0369: 
1:cf391af: 		//The following call to Monitor to get DVF is going to get the already
1:cf391af: 		//booted DVF (DVF got booted by BasicDatabase's boot method. 
1:cf391af: 		//BasicDatabase also set the correct Locale in the DVF. There after,
1:cf391af: 		//DVF with correct Locale is available to rest of the Derby code.
1:56c1dc2: 		dvf = (DataValueFactory) bootServiceModule(create, this, org.apache.derby.iapi.reference.ClassName.DataValueFactory, startParams);
1:56c1dc2: 		javaFactory = (JavaFactory) startSystemModule(org.apache.derby.iapi.reference.Module.JavaFactory);
1:56c1dc2: 		uuidFactory = getMonitor().getUUIDFactory();
1:56c1dc2: 		classFactory = (ClassFactory) getServiceModule(this, org.apache.derby.iapi.reference.Module.ClassFactory);
1:eac0369: 		if (classFactory == null)
1:56c1dc2:  			classFactory = (ClassFactory) findSystemModule(org.apache.derby.iapi.reference.Module.ClassFactory);
1:eac0369: 
1:eac0369: 		//set the property validation module needed to do propertySetCallBack
1:eac0369: 		//register and property validation
1:eac0369: 		setValidation();
1:eac0369: 
1:56c1dc2: 		ef = (ExecutionFactory) bootServiceModule(create, this, ExecutionFactory.MODULE, startParams);
1:56c1dc2: 		of = (OptimizerFactory) bootServiceModule(create, this, OptimizerFactory.MODULE, startParams);
1:eac0369: 		tcf =
1:56c1dc2: 		   (TypeCompilerFactory) startSystemModule(TypeCompilerFactory.MODULE);
1:eac0369: 
1:eac0369: 		// If the system supports statement caching boot the CacheFactory module.
1:eac0369: 		int cacheSize = statementCacheSize(startParams);
1:eac0369: 		if (cacheSize > 0) {
1:56c1dc2: 			CacheFactory cacheFactory = (CacheFactory) startSystemModule(org.apache.derby.iapi.reference.Module.CacheFactory);
1:eac0369: 			singleStatementCache = cacheFactory.newCacheManager(this,
1:eac0369: 												"StatementCache",
1:eac0369: 												cacheSize/4,
1:eac0369: 												cacheSize);
1:6da88fc: 
1:6da88fc:             // Start a management bean for the statement cache to allow
1:6da88fc:             // monitoring through JMX, if it is available and enabled.
1:6da88fc:             DataFactory df = (DataFactory)
1:56c1dc2:                     findServiceModule(this, DataFactory.MODULE);
1:6da88fc:             singleStatementCache.registerMBean(df.getRootDirectory());
1:eac0369: 		}
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * returns the statement cache that this connection should use; currently
1:6da88fc:      * there is a statement cache per database.
1:eac0369: 	 */
1:eac0369: 	public CacheManager getStatementCache()
1:56c1dc2: 	{
1:eac0369: 		return singleStatementCache;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:6da88fc:      * Stop this module.
1:eac0369: 	 */
1:eac0369: 	public void stop() {
1:6da88fc:         if (singleStatementCache != null) {
1:6da88fc:             singleStatementCache.deregisterMBean();
1:6da88fc:         }
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Methods of PropertySetCallback
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	public void init(boolean dbOnly, Dictionary p) {
1:eac0369: 		// not called yet ...
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  @see PropertySetCallback#validate
1:eac0369: 	  @exception StandardException Thrown on error.
1:eac0369: 	*/
1:eac0369: 	public boolean validate(String key,
1:eac0369: 						 Serializable value,
1:eac0369: 						 Dictionary p)
1:eac0369: 		throws StandardException {
1:eac0369: 		if (value == null)
1:eac0369: 			return true;
1:eac0369: 		else if (key.equals(Property.DEFAULT_CONNECTION_MODE_PROPERTY))
1:eac0369: 		{
1:eac0369: 			String value_s = (String)value;
1:eac0369: 			if (value_s != null &&
1:eac0369: 				!StringUtil.SQLEqualsIgnoreCase(value_s, Property.NO_ACCESS) &&
1:eac0369: 				!StringUtil.SQLEqualsIgnoreCase(value_s, Property.READ_ONLY_ACCESS) &&
1:eac0369: 				!StringUtil.SQLEqualsIgnoreCase(value_s, Property.FULL_ACCESS))
1:c45f5b1: 				throw StandardException.newException(SQLState.AUTH_INVALID_AUTHORIZATION_PROPERTY, key, value_s);
1:eac0369: 
1:eac0369: 			return true;
1:eac0369: 		}
1:eac0369: 		else if (key.equals(Property.READ_ONLY_ACCESS_USERS_PROPERTY) ||
1:eac0369: 				 key.equals(Property.FULL_ACCESS_USERS_PROPERTY))
1:eac0369: 		{
1:eac0369: 			String value_s = (String)value;
1:eac0369: 
1:eac0369: 			/** Parse the new userIdList to verify its syntax. */
1:eac0369: 			String[] newList_a;
1:eac0369: 			try {newList_a = IdUtil.parseIdList(value_s);}
1:eac0369: 			catch (StandardException se) {
1:75fb1cf:                 throw StandardException.newException(SQLState.AUTH_INVALID_AUTHORIZATION_PROPERTY, se, key,value_s);
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			/** Check the new list userIdList for duplicates. */
1:eac0369: 			String dups = IdUtil.dups(newList_a);
1:eac0369: 			if (dups != null) throw StandardException.newException(SQLState.AUTH_DUPLICATE_USERS, key,dups);
1:eac0369: 
1:eac0369: 			/** Check for users with both read and full access permission. */
1:eac0369: 			String[] otherList_a;
1:eac0369: 			String otherList;
1:eac0369: 			if (key.equals(Property.READ_ONLY_ACCESS_USERS_PROPERTY))
1:eac0369: 				otherList = (String)p.get(Property.FULL_ACCESS_USERS_PROPERTY);
1:eac0369: 			else
1:eac0369: 				otherList = (String)p.get(Property.READ_ONLY_ACCESS_USERS_PROPERTY);
1:eac0369: 			otherList_a = IdUtil.parseIdList(otherList);
1:eac0369: 			String both = IdUtil.intersect(newList_a,otherList_a);
1:eac0369: 			if (both != null) throw StandardException.newException(SQLState.AUTH_USER_IN_READ_AND_WRITE_LISTS, both);
1:eac0369: 			
1:eac0369: 			return true;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: 	/** @see PropertySetCallback#apply */
1:eac0369: 	public Serviceable apply(String key,
1:eac0369: 							 Serializable value,
1:eac0369: 							 Dictionary p)
1:eac0369: 	{
1:eac0369: 			 return null;
1:eac0369: 	}
1:eac0369: 	/** @see PropertySetCallback#map */
1:eac0369: 	public Serializable map(String key, Serializable value, Dictionary p)
1:eac0369: 	{
1:eac0369: 		return null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	protected void setValidation() throws StandardException {
1:56c1dc2: 		pf = (PropertyFactory) findServiceModule(this,
1:eac0369: 			org.apache.derby.iapi.reference.Module.PropertyFactory);
1:eac0369: 		pf.addPropertySetNotification(this);
1:eac0369: 	}
1:eac0369: 
1:eac0369:     public Parser newParser(CompilerContext cc)
1:eac0369:     {
1:eac0369:         return new org.apache.derby.impl.sql.compile.ParserImpl(cc);
1:eac0369:     }
1:eac0369: 
1:eac0369: 	// Class methods
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the instance # for the next LCC.
1:eac0369: 	 * (Useful for logStatementText=true output.
1:eac0369: 	 *
1:eac0369: 	 * @return instance # of next LCC.
1:eac0369: 	 */
1:eac0369: 	protected synchronized int getNextLCCInstanceNumber()
1:eac0369: 	{
1:eac0369: 		return nextLCCInstanceNumber++;
1:eac0369: 	}
1:56c1dc2:     
1:56c1dc2:     /**
1:56c1dc2:      * Privileged Monitor lookup. Must be package private so that user code
1:56c1dc2:      * can't call this entry point.
1:56c1dc2:      */
1:56c1dc2:     static  ModuleFactory  getMonitor()
1:56c1dc2:     {
1:56c1dc2:         return AccessController.doPrivileged
1:56c1dc2:             (
1:56c1dc2:              new PrivilegedAction<ModuleFactory>()
1:56c1dc2:              {
1:56c1dc2:                  public ModuleFactory run()
1:56c1dc2:                  {
1:56c1dc2:                      return Monitor.getMonitor();
1:56c1dc2:                  }
1:56c1dc2:              }
1:56c1dc2:              );
1:56c1dc2:     }
1:56c1dc2: 
1:56c1dc2:     
1:56c1dc2:     /**
1:56c1dc2:      * Privileged startup. Must be private so that user code
1:56c1dc2:      * can't call this entry point.
1:56c1dc2:      */
1:56c1dc2:     private  static  Object  startSystemModule( final String factoryInterface )
1:56c1dc2:         throws StandardException
1:56c1dc2:     {
1:56c1dc2:         try {
1:56c1dc2:             return AccessController.doPrivileged
1:56c1dc2:                 (
1:56c1dc2:                  new PrivilegedExceptionAction<Object>()
1:56c1dc2:                  {
1:56c1dc2:                      public Object run()
1:56c1dc2:                          throws StandardException
1:56c1dc2:                      {
1:56c1dc2:                          return Monitor.startSystemModule( factoryInterface );
1:56c1dc2:                      }
1:56c1dc2:                  }
1:56c1dc2:                  );
1:56c1dc2:         } catch (PrivilegedActionException pae)
1:56c1dc2:         {
1:56c1dc2:             throw StandardException.plainWrapException( pae );
1:56c1dc2:         }
1:56c1dc2:     }
1:56c1dc2: 
1:56c1dc2:     
1:56c1dc2:     /**
1:56c1dc2:      * Privileged lookup. Must be private so that user code
1:56c1dc2:      * can't call this entry point.
1:56c1dc2:      */
1:56c1dc2:     private  static  Object  findSystemModule( final String factoryInterface )
1:56c1dc2:         throws StandardException
1:56c1dc2:     {
1:56c1dc2:         try {
1:56c1dc2:             return AccessController.doPrivileged
1:56c1dc2:                 (
1:56c1dc2:                  new PrivilegedExceptionAction<Object>()
1:56c1dc2:                  {
1:56c1dc2:                      public Object run()
1:56c1dc2:                          throws StandardException
1:56c1dc2:                      {
1:56c1dc2:                          return Monitor.findSystemModule( factoryInterface );
1:56c1dc2:                      }
1:56c1dc2:                  }
1:56c1dc2:                  );
1:56c1dc2:         } catch (PrivilegedActionException pae)
1:56c1dc2:         {
1:56c1dc2:             throw StandardException.plainWrapException( pae );
1:56c1dc2:         }
1:56c1dc2:     }
1:56c1dc2: 
1:56c1dc2:     
1:56c1dc2:     /**
1:56c1dc2:      * Privileged startup. Must be private so that user code
1:56c1dc2:      * can't call this entry point.
1:56c1dc2:      */
1:56c1dc2:     private  static  Object bootServiceModule
1:56c1dc2:         (
1:56c1dc2:          final boolean create, final Object serviceModule,
1:56c1dc2:          final String factoryInterface, final Properties properties
1:56c1dc2:          )
1:56c1dc2:         throws StandardException
1:56c1dc2:     {
1:56c1dc2:         try {
1:56c1dc2:             return AccessController.doPrivileged
1:56c1dc2:                 (
1:56c1dc2:                  new PrivilegedExceptionAction<Object>()
1:56c1dc2:                  {
1:56c1dc2:                      public Object run()
1:56c1dc2:                          throws StandardException
1:56c1dc2:                      {
1:56c1dc2:                          return Monitor.bootServiceModule( create, serviceModule, factoryInterface, properties );
1:56c1dc2:                      }
1:56c1dc2:                  }
1:56c1dc2:                  );
1:56c1dc2:         } catch (PrivilegedActionException pae)
1:56c1dc2:         {
1:56c1dc2:             throw StandardException.plainWrapException( pae );
1:56c1dc2:         }
1:56c1dc2:     }
1:56c1dc2: 
1:56c1dc2:     /**
1:56c1dc2:      * Privileged startup. Must be private so that user code
1:56c1dc2:      * can't call this entry point.
1:56c1dc2:      */
1:56c1dc2:     private  static  Object findServiceModule( final Object serviceModule, final String factoryInterface)
1:56c1dc2:         throws StandardException
1:56c1dc2:     {
1:56c1dc2:         try {
1:56c1dc2:             return AccessController.doPrivileged
1:56c1dc2:                 (
1:56c1dc2:                  new PrivilegedExceptionAction<Object>()
1:56c1dc2:                  {
1:56c1dc2:                      public Object run()
1:56c1dc2:                          throws StandardException
1:eac0369:                      {
1:56c1dc2:                          return Monitor.findServiceModule( serviceModule, factoryInterface );
1:56c1dc2:                      }
1:56c1dc2:                  }
1:56c1dc2:                  );
1:56c1dc2:         } catch (PrivilegedActionException pae)
1:56c1dc2:         {
1:56c1dc2:             throw StandardException.plainWrapException( pae );
1:56c1dc2:         }
1:56c1dc2:     }
1:56c1dc2: 
1:56c1dc2:     /**
1:56c1dc2:      * Privileged module lookup. Must be private so that user code
1:56c1dc2:      * can't call this entry point.
1:56c1dc2:      */
1:56c1dc2:     private static  Object getServiceModule( final Object serviceModule, final String factoryInterface )
1:56c1dc2:     {
1:56c1dc2:         return AccessController.doPrivileged
1:56c1dc2:             (
1:56c1dc2:              new PrivilegedAction<Object>()
1:56c1dc2:              {
1:56c1dc2:                  public Object run()
1:56c1dc2:                  {
1:56c1dc2:                      return Monitor.getServiceModule( serviceModule, factoryInterface );
1:56c1dc2:                  }
1:56c1dc2:              }
1:56c1dc2:              );
1:56c1dc2:     }
1:56c1dc2: 
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:56c1dc2
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.monitor.ModuleFactory;
/////////////////////////////////////////////////////////////////////////
1: import java.security.AccessController;
1: import java.security.PrivilegedActionException;
1: import java.security.PrivilegedAction;
1: import java.security.PrivilegedExceptionAction;
/////////////////////////////////////////////////////////////////////////
1: 		dvf = (DataValueFactory) bootServiceModule(create, this, org.apache.derby.iapi.reference.ClassName.DataValueFactory, startParams);
1: 		javaFactory = (JavaFactory) startSystemModule(org.apache.derby.iapi.reference.Module.JavaFactory);
1: 		uuidFactory = getMonitor().getUUIDFactory();
1: 		classFactory = (ClassFactory) getServiceModule(this, org.apache.derby.iapi.reference.Module.ClassFactory);
1:  			classFactory = (ClassFactory) findSystemModule(org.apache.derby.iapi.reference.Module.ClassFactory);
1: 		ef = (ExecutionFactory) bootServiceModule(create, this, ExecutionFactory.MODULE, startParams);
1: 		of = (OptimizerFactory) bootServiceModule(create, this, OptimizerFactory.MODULE, startParams);
1: 		   (TypeCompilerFactory) startSystemModule(TypeCompilerFactory.MODULE);
1: 			CacheFactory cacheFactory = (CacheFactory) startSystemModule(org.apache.derby.iapi.reference.Module.CacheFactory);
/////////////////////////////////////////////////////////////////////////
1:                     findServiceModule(this, DataFactory.MODULE);
/////////////////////////////////////////////////////////////////////////
1: 		pf = (PropertyFactory) findServiceModule(this,
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Privileged Monitor lookup. Must be package private so that user code
1:      * can't call this entry point.
1:      */
1:     static  ModuleFactory  getMonitor()
1:     {
1:         return AccessController.doPrivileged
1:             (
1:              new PrivilegedAction<ModuleFactory>()
1:              {
1:                  public ModuleFactory run()
1:                  {
1:                      return Monitor.getMonitor();
1:                  }
1:              }
1:              );
1:     }
1: 
1:     
1:     /**
1:      * Privileged startup. Must be private so that user code
1:      * can't call this entry point.
1:      */
1:     private  static  Object  startSystemModule( final String factoryInterface )
1:         throws StandardException
1:     {
1:         try {
1:             return AccessController.doPrivileged
1:                 (
1:                  new PrivilegedExceptionAction<Object>()
1:                  {
1:                      public Object run()
1:                          throws StandardException
1:                      {
1:                          return Monitor.startSystemModule( factoryInterface );
1:                      }
1:                  }
1:                  );
1:         } catch (PrivilegedActionException pae)
1:         {
1:             throw StandardException.plainWrapException( pae );
1:         }
1:     }
1: 
1:     
1:     /**
1:      * Privileged lookup. Must be private so that user code
1:      * can't call this entry point.
1:      */
1:     private  static  Object  findSystemModule( final String factoryInterface )
1:         throws StandardException
1:     {
1:         try {
1:             return AccessController.doPrivileged
1:                 (
1:                  new PrivilegedExceptionAction<Object>()
1:                  {
1:                      public Object run()
1:                          throws StandardException
1:                      {
1:                          return Monitor.findSystemModule( factoryInterface );
1:                      }
1:                  }
1:                  );
1:         } catch (PrivilegedActionException pae)
1:         {
1:             throw StandardException.plainWrapException( pae );
1:         }
1:     }
1: 
1:     
1:     /**
1:      * Privileged startup. Must be private so that user code
1:      * can't call this entry point.
1:      */
1:     private  static  Object bootServiceModule
1:         (
1:          final boolean create, final Object serviceModule,
1:          final String factoryInterface, final Properties properties
1:          )
1:         throws StandardException
1:     {
1:         try {
1:             return AccessController.doPrivileged
1:                 (
1:                  new PrivilegedExceptionAction<Object>()
1:                  {
1:                      public Object run()
1:                          throws StandardException
1:                      {
1:                          return Monitor.bootServiceModule( create, serviceModule, factoryInterface, properties );
1:                      }
1:                  }
1:                  );
1:         } catch (PrivilegedActionException pae)
1:         {
1:             throw StandardException.plainWrapException( pae );
1:         }
1:     }
1: 
1:     /**
1:      * Privileged startup. Must be private so that user code
1:      * can't call this entry point.
1:      */
1:     private  static  Object findServiceModule( final Object serviceModule, final String factoryInterface)
1:         throws StandardException
1:     {
1:         try {
1:             return AccessController.doPrivileged
1:                 (
1:                  new PrivilegedExceptionAction<Object>()
1:                  {
1:                      public Object run()
1:                          throws StandardException
1:                      {
1:                          return Monitor.findServiceModule( serviceModule, factoryInterface );
1:                      }
1:                  }
1:                  );
1:         } catch (PrivilegedActionException pae)
1:         {
1:             throw StandardException.plainWrapException( pae );
1:         }
1:     }
1: 
1:     /**
1:      * Privileged module lookup. Must be private so that user code
1:      * can't call this entry point.
1:      */
1:     private static  Object getServiceModule( final Object serviceModule, final String factoryInterface )
1:     {
1:         return AccessController.doPrivileged
1:             (
1:              new PrivilegedAction<Object>()
1:              {
1:                  public Object run()
1:                  {
1:                      return Monitor.getServiceModule( serviceModule, factoryInterface );
1:                  }
1:              }
1:              );
1:     }
1: 
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:6da88fc
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.store.raw.data.DataFactory;
/////////////////////////////////////////////////////////////////////////
1: 
1:             // Start a management bean for the statement cache to allow
1:             // monitoring through JMX, if it is available and enabled.
1:             DataFactory df = (DataFactory)
0:                     Monitor.findServiceModule(this, DataFactory.MODULE);
1:             singleStatementCache.registerMBean(df.getRootDirectory());
1:      * there is a statement cache per database.
1:      * Stop this module.
1:         if (singleStatementCache != null) {
1:             singleStatementCache.deregisterMBean();
1:         }
commit:c5c4f19
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:cf391af
/////////////////////////////////////////////////////////////////////////
1: 		//The following call to Monitor to get DVF is going to get the already
1: 		//booted DVF (DVF got booted by BasicDatabase's boot method. 
1: 		//BasicDatabase also set the correct Locale in the DVF. There after,
1: 		//DVF with correct Locale is available to rest of the Derby code.
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:b084bcd
/////////////////////////////////////////////////////////////////////////
1: 		return Monitor.isDesiredType( startParams,
1:                 EngineType.STANDALONE_DB | EngineType.STORELESS_ENGINE);
commit:2bb479f
/////////////////////////////////////////////////////////////////////////
commit:4841b0e
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 		db.getDataDictionary().pushDataDictionaryContext(cm);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:1985a18
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:b7df3e8
/////////////////////////////////////////////////////////////////////////
0: 		dd.pushDataDictionaryContext(cm);
commit:ded6889
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 		dvf = (DataValueFactory) Monitor.bootServiceModule(create, this, org.apache.derby.iapi.reference.ClassName.DataValueFactory, startParams);
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.conn.GenericLanguageConnectionFactory
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:61070a6
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.conn
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.sql.conn;
1: 
0: import org.apache.derby.iapi.reference.JDBC20Translation;
0: import org.apache.derby.iapi.reference.JDBC30Translation;
1: 
1: import org.apache.derby.iapi.sql.conn.LanguageConnectionFactory;
1: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1: import org.apache.derby.iapi.sql.compile.CompilerContext;
1: 
1: import org.apache.derby.iapi.sql.LanguageFactory;
1: import org.apache.derby.impl.sql.GenericStatement;
1: 
0: import org.apache.derby.impl.sql.conn.CachedStatement;
1: 
1: import org.apache.derby.iapi.services.uuid.UUIDFactory;
1: import org.apache.derby.iapi.services.compiler.JavaFactory;
1: import org.apache.derby.iapi.services.loader.ClassFactory;
1: 
1: import org.apache.derby.iapi.db.Database;
1: 
1: import org.apache.derby.iapi.store.access.TransactionController;
1: 
1: import org.apache.derby.iapi.sql.compile.TypeCompilerFactory;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.iapi.sql.compile.NodeFactory;
1: import org.apache.derby.iapi.sql.compile.Parser;
1: 
0: import org.apache.derby.iapi.sql.Activation;
1: 
0: import org.apache.derby.iapi.store.access.AccessFactory;
1: import org.apache.derby.iapi.services.property.PropertyFactory;
1: 
1: import org.apache.derby.iapi.sql.Statement;
1: import org.apache.derby.iapi.sql.compile.OptimizerFactory;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1: import org.apache.derby.iapi.types.DataValueFactory;
1: import org.apache.derby.iapi.sql.execute.ExecutionFactory;
1: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: import org.apache.derby.iapi.services.monitor.Monitor;
1: import org.apache.derby.iapi.services.monitor.ModuleControl;
1: import org.apache.derby.iapi.services.monitor.ModuleSupportable;
0: import org.apache.derby.iapi.services.monitor.ModuleFactory;
1: import org.apache.derby.iapi.services.context.ContextManager;
1: 
1: import org.apache.derby.iapi.services.cache.CacheFactory;
1: import org.apache.derby.iapi.services.cache.CacheManager;
1: import org.apache.derby.iapi.services.cache.CacheableFactory;
1: import org.apache.derby.iapi.services.cache.Cacheable;
1: 
1: import org.apache.derby.iapi.services.property.PropertyUtil;
1: import org.apache.derby.iapi.services.property.PropertySetCallback;
1: 
0: import org.apache.derby.iapi.types.DataValueFactoryImpl;
1: 
0: import org.apache.derby.iapi.services.i18n.LocaleFinder;
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.reference.Property;
1: import org.apache.derby.iapi.reference.EngineType;
1: 
1: import java.util.Properties;
0: import java.util.Locale;
1: import java.util.Dictionary;
1: import java.io.Serializable;
1: import org.apache.derby.iapi.util.IdUtil;
1: import org.apache.derby.iapi.services.daemon.Serviceable;
1: import org.apache.derby.iapi.util.StringUtil;
1: 
1: /**
1:  * LanguageConnectionFactory generates all of the items
1:  * a language system needs that is specific to a particular
1:  * connection. Alot of these are other factories.
1:  *
0:  * @author ames
1:  */
1: public class GenericLanguageConnectionFactory
1: 	implements LanguageConnectionFactory, CacheableFactory, PropertySetCallback, ModuleControl, ModuleSupportable {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 
1: 	/*
1: 		fields
1: 	 */
0: 	protected 	DataDictionary	dd;
1: 	private 	ExecutionFactory		ef;
1: 	private 	OptimizerFactory		of;
1: 	private		TypeCompilerFactory		tcf;
1: 	private 	DataValueFactory		dvf;
1: 	private 	UUIDFactory				uuidFactory;
1: 	private 	JavaFactory				javaFactory;
1: 	private 	ClassFactory			classFactory;
0: 	private 	NodeFactory				nodeFactory;
0: 	private 	AccessFactory			af;
1: 	private 	PropertyFactory			pf;
1: 
1: 	private		int						nextLCCInstanceNumber;
1: 
1: 	/*
1: 	  for caching prepared statements 
1: 	*/
1: 	private int cacheSize = org.apache.derby.iapi.reference.Property.STATEMENT_CACHE_SIZE_DEFAULT;
1: 	private CacheManager singleStatementCache;
1: 
1: 	/*
1: 	   constructor
1: 	*/
1: 	public GenericLanguageConnectionFactory() {
1: 	}
1: 
1: 	/*
1: 	   LanguageConnectionFactory interface
1: 	*/
1: 
1: 	/*
1: 		these are the methods that do real work, not just look for factories
1: 	 */
1: 
1: 	/**
1: 		Get a Statement for the connection
1: 		
1: 		@param statementText the text for the statement
1: 		@return	The Statement
1: 	 */
0: 	public Statement getStatement(SchemaDescriptor compilationSchema, String statementText)
1: 	{
0: 		return new GenericStatement(compilationSchema, statementText);
1: 	}
1: 
1: 	/**
1: 		Get a LanguageConnectionContext. this holds things
1: 		we want to remember about activity in the language system,
1: 		where this factory holds things that are pretty stable,
1: 		like other factories.
1: 		<p>
1: 		The returned LanguageConnectionContext is intended for use
1: 		only by the connection that requested it.
1: 
1: 		@return a language connection context for the context stack.
1: 		@exception StandardException the usual -- for the subclass
1: 	 */
1: 
1: 	public LanguageConnectionContext newLanguageConnectionContext(
1: 		ContextManager cm,
1: 		TransactionController tc,
1: 		LanguageFactory lf,
1: 		Database db,
1: 		String userName,
1: 		String drdaID,
1: 		String dbname) throws StandardException {
1: 		
0: 		pushDataDictionaryContext(cm);
1: 
1: 		return new GenericLanguageConnectionContext(cm,
1: 													tc,
1: 													lf,
1: 													this,
1: 													db,
1: 													userName,
1: 													getNextLCCInstanceNumber(),
1: 													drdaID,
1: 													dbname);
1: 	}
1: 
1: 	public Cacheable newCacheable(CacheManager cm) {
1: 		return new CachedStatement();
1: 	}
1: 
1: 	/*
1: 		these methods all look for factories that we booted.
1: 	 */
1: 	 
1: 	 /**
1: 		Get the UUIDFactory to use with this language connection
1: 		REMIND: this is only used by the compiler; should there be
1: 		a compiler module control class to boot compiler-only stuff?
1: 	 */
1: 	public UUIDFactory	getUUIDFactory()
1: 	{
1: 		return uuidFactory;
1: 	}
1: 
1: 	/**
1: 		Get the ClassFactory to use with this language connection
1: 	 */
1: 	public ClassFactory	getClassFactory()
1: 	{
1: 		return classFactory;
1: 	}
1: 
1: 	/**
1: 		Get the JavaFactory to use with this language connection
1: 		REMIND: this is only used by the compiler; should there be
1: 		a compiler module control class to boot compiler-only stuff?
1: 	 */
1: 	public JavaFactory	getJavaFactory()
1: 	{
1: 		return javaFactory;
1: 	}
1: 
1: 	/**
0: 		Get the NodeFactory to use with this language connection
0: 		REMIND: is this only used by the compiler?
1: 	 */
0: 	public NodeFactory	getNodeFactory()
1: 	{
0: 		return nodeFactory;
1: 	}
1: 
1: 	/**
1: 		Get the ExecutionFactory to use with this language connection
1: 	 */
1: 	public ExecutionFactory	getExecutionFactory() {
1: 		return ef;
1: 	}
1: 
1: 	/**
0: 		Get the AccessFactory to use with this language connection
1: 	 */
0: 	public AccessFactory	getAccessFactory() 
1: 	{
0: 		return af;
1: 	}	
1: 
1: 	/**
1: 		Get the PropertyFactory to use with this language connection
1: 	 */
1: 	public PropertyFactory	getPropertyFactory() 
1: 	{
1: 		return pf;
1: 	}	
1: 
1: 	/**
1: 		Get the OptimizerFactory to use with this language connection
1: 	 */
1: 	public OptimizerFactory	getOptimizerFactory() {
1: 		return of;
1: 	}
1: 	/**
1: 		Get the TypeCompilerFactory to use with this language connection
1: 	 */
1: 	public TypeCompilerFactory getTypeCompilerFactory() {
1: 		return tcf;
1: 	}
1: 
1: 	/**
1: 		Get the DataValueFactory to use with this language connection
1: 	 */
1: 	public DataValueFactory		getDataValueFactory() {
1: 		return dvf;
1: 	}
1: 
0: 	protected void pushDataDictionaryContext(ContextManager cm) {
0: 		// we make sure there is a data dictionary context in place.
0: 		dd.pushDataDictionaryContext(cm, false);
1: 	}
1: 
1: 	/*
1: 		ModuleControl interface
1: 	 */
1: 
1: 	/**
1: 		this implementation will not support caching of statements.
1: 	 */
1: 	public boolean canSupport(Properties startParams) {
1: 
0: 		return Monitor.isDesiredType( startParams, EngineType.STANDALONE_DB);
1: 	}
1: 
1: 	private	int	statementCacheSize(Properties startParams)
1: 	{
1: 		String wantCacheProperty = null;
1: 
1: 		wantCacheProperty =
1: 			PropertyUtil.getPropertyFromSet(startParams, org.apache.derby.iapi.reference.Property.STATEMENT_CACHE_SIZE);
1: 
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.DEBUG("StatementCacheInfo", "Cacheing implementation chosen if null or 0<"+wantCacheProperty);
1: 
1: 		if (wantCacheProperty != null) {
1: 			try {
1: 			    cacheSize = Integer.parseInt(wantCacheProperty);
1: 			} catch (NumberFormatException nfe) {
1: 				cacheSize = org.apache.derby.iapi.reference.Property.STATEMENT_CACHE_SIZE_DEFAULT; 
1: 			}
1: 		}
1: 
1: 		return cacheSize;
1: 	}
1: 	
1: 	/**
1: 	 * Start-up method for this instance of the language connection factory.
1: 	 * Note these are expected to be booted relative to a Database.
1: 	 *
1: 	 * @param startParams	The start-up parameters (ignored in this case)
1: 	 *
1: 	 * @exception StandardException	Thrown on failure to boot
1: 	 */
1: 	public void boot(boolean create, Properties startParams) 
1: 		throws StandardException {
1: 
0: 		// Get the Database from the context manager and pass it to the
0: 		// DataValueFactory. The DVF expects a LocaleFinder, which Database
0: 		// implements.
0: 		//
0: 		// RESOLVE: Unfortunately, the Database is in the process of booting,
0: 		// so the Monitor can't find it. So, we just pass in null, and let
0: 		// the DVF get the Database on first access. No amount of shuffling
0: 		// of boot order can solve this problem, because the Database is
0: 		// the top-level module for almost everything. So, the Monitor needs
0: 		// to be fixed so it can find modules that are not done booting yet.
0: 		dvf = new DataValueFactoryImpl((LocaleFinder) null);
1: 
0: 		javaFactory = (JavaFactory) Monitor.startSystemModule(org.apache.derby.iapi.reference.Module.JavaFactory);
0: 		uuidFactory = Monitor.getMonitor().getUUIDFactory();
0: 		classFactory = (ClassFactory) Monitor.getServiceModule(this, org.apache.derby.iapi.reference.Module.ClassFactory);
1: 		if (classFactory == null)
0:  			classFactory = (ClassFactory) Monitor.findSystemModule(org.apache.derby.iapi.reference.Module.ClassFactory);
1: 
0: 		bootDataDictionary(create, startParams);
1: 
1: 		//set the property validation module needed to do propertySetCallBack
1: 		//register and property validation
1: 		setValidation();
1: 
0: 		setStore();
1: 
0: 		ef = (ExecutionFactory) Monitor.bootServiceModule(create, this, ExecutionFactory.MODULE, startParams);
0: 		of = (OptimizerFactory) Monitor.bootServiceModule(create, this, OptimizerFactory.MODULE, startParams);
1: 		tcf =
0: 		   (TypeCompilerFactory) Monitor.startSystemModule(TypeCompilerFactory.MODULE);
0: 		nodeFactory = (NodeFactory) Monitor.bootServiceModule(create, this, NodeFactory.MODULE, startParams);
1: 
1: 		// If the system supports statement caching boot the CacheFactory module.
1: 		int cacheSize = statementCacheSize(startParams);
1: 		if (cacheSize > 0) {
0: 			CacheFactory cacheFactory = (CacheFactory) Monitor.startSystemModule(org.apache.derby.iapi.reference.Module.CacheFactory);
1: 			singleStatementCache = cacheFactory.newCacheManager(this,
1: 												"StatementCache",
1: 												cacheSize/4,
1: 												cacheSize);
1: 		}
1: 
1: 	}
1: 
0: 	protected void bootDataDictionary(boolean create, Properties startParams) throws StandardException {
0: 		dd = (DataDictionary) Monitor.bootServiceModule(create, this, DataDictionary.MODULE, startParams);
1: 	}
1: 
1: 	/**
1: 	 * returns the statement cache that this connection should use; currently
0: 	 * there is a statement cache per connection.
1: 	 */
1: 	
1: 
1: 	public CacheManager getStatementCache()
1: 	{
1: 		return singleStatementCache;
1: 	}
1: 
1: 	/**
0: 	 * Stop this module.  In this case, nothing needs to be done.
1: 	 *
0: 	 * @return	Nothing
1: 	 */
1: 	public void stop() {
1: 	}
1: 
1: 	/*
1: 	** Methods of PropertySetCallback
1: 	*/
1: 
1: 	public void init(boolean dbOnly, Dictionary p) {
1: 		// not called yet ...
1: 	}
1: 
1: 	/**
1: 	  @see PropertySetCallback#validate
1: 	  @exception StandardException Thrown on error.
1: 	*/
1: 	public boolean validate(String key,
1: 						 Serializable value,
1: 						 Dictionary p)
1: 		throws StandardException {
1: 		if (value == null)
1: 			return true;
1: 		else if (key.equals(Property.DEFAULT_CONNECTION_MODE_PROPERTY))
1: 		{
1: 			String value_s = (String)value;
1: 			if (value_s != null &&
1: 				!StringUtil.SQLEqualsIgnoreCase(value_s, Property.NO_ACCESS) &&
1: 				!StringUtil.SQLEqualsIgnoreCase(value_s, Property.READ_ONLY_ACCESS) &&
1: 				!StringUtil.SQLEqualsIgnoreCase(value_s, Property.FULL_ACCESS))
0: 				throw StandardException.newException(SQLState.AUTH_INVALID_AUTHORIZATION_PROPERTY					, key,value_s);
1: 
1: 			return true;
1: 		}
1: 		else if (key.equals(Property.READ_ONLY_ACCESS_USERS_PROPERTY) ||
1: 				 key.equals(Property.FULL_ACCESS_USERS_PROPERTY))
1: 		{
1: 			String value_s = (String)value;
1: 
1: 			/** Parse the new userIdList to verify its syntax. */
1: 			String[] newList_a;
1: 			try {newList_a = IdUtil.parseIdList(value_s);}
1: 			catch (StandardException se) {
0: 				throw StandardException.newException(SQLState.AUTH_INVALID_AUTHORIZATION_PROPERTY, key,value_s,se);
1: 			}
1: 
1: 			/** Check the new list userIdList for duplicates. */
1: 			String dups = IdUtil.dups(newList_a);
1: 			if (dups != null) throw StandardException.newException(SQLState.AUTH_DUPLICATE_USERS, key,dups);
1: 
1: 			/** Check for users with both read and full access permission. */
1: 			String[] otherList_a;
1: 			String otherList;
1: 			if (key.equals(Property.READ_ONLY_ACCESS_USERS_PROPERTY))
1: 				otherList = (String)p.get(Property.FULL_ACCESS_USERS_PROPERTY);
1: 			else
1: 				otherList = (String)p.get(Property.READ_ONLY_ACCESS_USERS_PROPERTY);
1: 			otherList_a = IdUtil.parseIdList(otherList);
1: 			String both = IdUtil.intersect(newList_a,otherList_a);
1: 			if (both != null) throw StandardException.newException(SQLState.AUTH_USER_IN_READ_AND_WRITE_LISTS, both);
1: 			
1: 			return true;
1: 		}
1: 
1: 		return false;
1: 	}
1: 	/** @see PropertySetCallback#apply */
1: 	public Serviceable apply(String key,
1: 							 Serializable value,
1: 							 Dictionary p)
1: 	{
1: 			 return null;
1: 	}
1: 	/** @see PropertySetCallback#map */
1: 	public Serializable map(String key, Serializable value, Dictionary p)
1: 	{
1: 		return null;
1: 	}
1: 
1: 	protected void setValidation() throws StandardException {
0: 		pf = (PropertyFactory) Monitor.findServiceModule(this,
1: 			org.apache.derby.iapi.reference.Module.PropertyFactory);
1: 		pf.addPropertySetNotification(this);
1: 	}
1: 
0: 	protected void setStore() throws StandardException {
0: 		af = (AccessFactory) Monitor.findServiceModule(this,AccessFactory.MODULE);
1: 	}
1: 
1:     public Parser newParser(CompilerContext cc)
1:     {
1:         return new org.apache.derby.impl.sql.compile.ParserImpl(cc);
1:     }
1: 
1: 	// Class methods
1: 
1: 	/**
1: 	 * Get the instance # for the next LCC.
1: 	 * (Useful for logStatementText=true output.
1: 	 *
1: 	 * @return instance # of next LCC.
1: 	 */
1: 	protected synchronized int getNextLCCInstanceNumber()
1: 	{
1: 		return nextLCCInstanceNumber++;
1: 	}
1: }
author:David Van Couvering
-------------------------------------------------------------------------------
commit:575d6a1
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
commit:75fb1cf
/////////////////////////////////////////////////////////////////////////
1:                 throw StandardException.newException(SQLState.AUTH_INVALID_AUTHORIZATION_PROPERTY, se, key,value_s);
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:5ec8510
/////////////////////////////////////////////////////////////////////////
0: 				!StringUtil.SQLEqualsIgnoreCase(value_s, Property.FULL_ACCESS))
commit:c45f5b1
/////////////////////////////////////////////////////////////////////////
0: 				!StringUtil.SQLEqualsIgnoreCase(value_s, Property.FULL_ACCESS) &&
0: 				!StringUtil.SQLEqualsIgnoreCase(value_s, Property.SQL_STANDARD_ACCESS))
1: 				throw StandardException.newException(SQLState.AUTH_INVALID_AUTHORIZATION_PROPERTY, key, value_s);
author:Bernt Johnsen
-------------------------------------------------------------------------------
commit:5087be8
/////////////////////////////////////////////////////////////////////////
1: 		@param compilationSchema schema
1: 		@param forReadOnly if concurrency is CONCUR_READ_ONLY
1:         public Statement getStatement(SchemaDescriptor compilationSchema, String statementText, boolean forReadOnly)
0:         {
1: 	    return new GenericStatement(compilationSchema, statementText, forReadOnly);
0: 
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.conn
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.sql.conn;
0: 
0: import org.apache.derby.iapi.reference.JDBC20Translation;
0: import org.apache.derby.iapi.reference.JDBC30Translation;
0: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionFactory;
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: import org.apache.derby.iapi.sql.compile.CompilerContext;
0: 
0: import org.apache.derby.iapi.sql.LanguageFactory;
0: import org.apache.derby.impl.sql.GenericStatement;
0: 
0: import org.apache.derby.impl.sql.conn.CachedStatement;
0: 
0: import org.apache.derby.iapi.services.uuid.UUIDFactory;
0: import org.apache.derby.iapi.services.compiler.JavaFactory;
0: import org.apache.derby.iapi.services.loader.ClassFactory;
0: 
0: import org.apache.derby.iapi.db.Database;
0: 
0: import org.apache.derby.iapi.store.access.TransactionController;
0: 
0: import org.apache.derby.iapi.sql.compile.TypeCompilerFactory;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.sql.compile.NodeFactory;
0: import org.apache.derby.iapi.sql.compile.Parser;
0: 
0: import org.apache.derby.iapi.sql.Activation;
0: 
0: import org.apache.derby.iapi.store.access.AccessFactory;
0: import org.apache.derby.iapi.services.property.PropertyFactory;
0: 
0: import org.apache.derby.iapi.sql.Statement;
0: import org.apache.derby.iapi.sql.compile.OptimizerFactory;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.types.DataValueFactory;
0: import org.apache.derby.iapi.sql.execute.ExecutionFactory;
0: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: import org.apache.derby.iapi.services.monitor.ModuleControl;
0: import org.apache.derby.iapi.services.monitor.ModuleSupportable;
0: import org.apache.derby.iapi.services.monitor.ModuleFactory;
0: import org.apache.derby.iapi.services.context.ContextManager;
0: 
0: import org.apache.derby.iapi.services.cache.CacheFactory;
0: import org.apache.derby.iapi.services.cache.CacheManager;
0: import org.apache.derby.iapi.services.cache.CacheableFactory;
0: import org.apache.derby.iapi.services.cache.Cacheable;
0: 
0: import org.apache.derby.iapi.services.property.PropertyUtil;
0: import org.apache.derby.iapi.services.property.PropertySetCallback;
0: 
0: import org.apache.derby.iapi.types.DataValueFactoryImpl;
0: 
0: import org.apache.derby.iapi.services.i18n.LocaleFinder;
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.reference.Property;
0: import org.apache.derby.iapi.reference.EngineType;
0: 
0: import java.util.Properties;
0: import java.util.Locale;
0: import java.util.Dictionary;
0: import java.io.Serializable;
0: import org.apache.derby.iapi.util.IdUtil;
0: import org.apache.derby.iapi.services.daemon.Serviceable;
0: import org.apache.derby.iapi.util.StringUtil;
0: 
0: /**
0:  * LanguageConnectionFactory generates all of the items
0:  * a language system needs that is specific to a particular
0:  * connection. Alot of these are other factories.
0:  *
0:  * @author ames
0:  */
0: public class GenericLanguageConnectionFactory
0: 	implements LanguageConnectionFactory, CacheableFactory, PropertySetCallback, ModuleControl, ModuleSupportable {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 
0: 	/*
0: 		fields
0: 	 */
0: 	protected 	DataDictionary	dd;
0: 	private 	ExecutionFactory		ef;
0: 	private 	OptimizerFactory		of;
0: 	private		TypeCompilerFactory		tcf;
0: 	private 	DataValueFactory		dvf;
0: 	private 	UUIDFactory				uuidFactory;
0: 	private 	JavaFactory				javaFactory;
0: 	private 	ClassFactory			classFactory;
0: 	private 	NodeFactory				nodeFactory;
0: 	private 	AccessFactory			af;
0: 	private 	PropertyFactory			pf;
0: 
0: 	private		int						nextLCCInstanceNumber;
0: 
0: 	/*
0: 	  for caching prepared statements 
0: 	*/
0: 	private int cacheSize = org.apache.derby.iapi.reference.Property.STATEMENT_CACHE_SIZE_DEFAULT;
0: 	private CacheManager singleStatementCache;
0: 
0: 	/*
0: 	   constructor
0: 	*/
0: 	public GenericLanguageConnectionFactory() {
0: 	}
0: 
0: 	/*
0: 	   LanguageConnectionFactory interface
0: 	*/
0: 
0: 	/*
0: 		these are the methods that do real work, not just look for factories
0: 	 */
0: 
0: 	/**
0: 		Get a Statement for the connection
0: 		
0: 		@param statementText the text for the statement
0: 		@return	The Statement
0: 	 */
0: 	public Statement getStatement(SchemaDescriptor compilationSchema, String statementText)
0: 	{
0: 		return new GenericStatement(compilationSchema, statementText);
0: 	}
0: 
0: 	/**
0: 		Get a LanguageConnectionContext. this holds things
0: 		we want to remember about activity in the language system,
0: 		where this factory holds things that are pretty stable,
0: 		like other factories.
0: 		<p>
0: 		The returned LanguageConnectionContext is intended for use
0: 		only by the connection that requested it.
0: 
0: 		@return a language connection context for the context stack.
0: 		@exception StandardException the usual -- for the subclass
0: 	 */
0: 
0: 	public LanguageConnectionContext newLanguageConnectionContext(
0: 		ContextManager cm,
0: 		TransactionController tc,
0: 		LanguageFactory lf,
0: 		Database db,
0: 		String userName,
0: 		String drdaID,
0: 		String dbname) throws StandardException {
0: 		
0: 		pushDataDictionaryContext(cm);
0: 
0: 		return new GenericLanguageConnectionContext(cm,
0: 													tc,
0: 													lf,
0: 													this,
0: 													db,
0: 													userName,
0: 													getNextLCCInstanceNumber(),
0: 													drdaID,
0: 													dbname);
0: 	}
0: 
0: 	public Cacheable newCacheable(CacheManager cm) {
0: 		return new CachedStatement();
0: 	}
0: 
0: 	/*
0: 		these methods all look for factories that we booted.
0: 	 */
0: 	 
0: 	 /**
0: 		Get the UUIDFactory to use with this language connection
0: 		REMIND: this is only used by the compiler; should there be
0: 		a compiler module control class to boot compiler-only stuff?
0: 	 */
0: 	public UUIDFactory	getUUIDFactory()
0: 	{
0: 		return uuidFactory;
0: 	}
0: 
0: 	/**
0: 		Get the ClassFactory to use with this language connection
0: 	 */
0: 	public ClassFactory	getClassFactory()
0: 	{
0: 		return classFactory;
0: 	}
0: 
0: 	/**
0: 		Get the JavaFactory to use with this language connection
0: 		REMIND: this is only used by the compiler; should there be
0: 		a compiler module control class to boot compiler-only stuff?
0: 	 */
0: 	public JavaFactory	getJavaFactory()
0: 	{
0: 		return javaFactory;
0: 	}
0: 
0: 	/**
0: 		Get the NodeFactory to use with this language connection
0: 		REMIND: is this only used by the compiler?
0: 	 */
0: 	public NodeFactory	getNodeFactory()
0: 	{
0: 		return nodeFactory;
0: 	}
0: 
0: 	/**
0: 		Get the ExecutionFactory to use with this language connection
0: 	 */
0: 	public ExecutionFactory	getExecutionFactory() {
0: 		return ef;
0: 	}
0: 
0: 	/**
0: 		Get the AccessFactory to use with this language connection
0: 	 */
0: 	public AccessFactory	getAccessFactory() 
0: 	{
0: 		return af;
0: 	}	
0: 
0: 	/**
0: 		Get the PropertyFactory to use with this language connection
0: 	 */
0: 	public PropertyFactory	getPropertyFactory() 
0: 	{
0: 		return pf;
0: 	}	
0: 
0: 	/**
0: 		Get the OptimizerFactory to use with this language connection
0: 	 */
0: 	public OptimizerFactory	getOptimizerFactory() {
0: 		return of;
0: 	}
0: 	/**
0: 		Get the TypeCompilerFactory to use with this language connection
0: 	 */
0: 	public TypeCompilerFactory getTypeCompilerFactory() {
0: 		return tcf;
0: 	}
0: 
0: 	/**
0: 		Get the DataValueFactory to use with this language connection
0: 	 */
0: 	public DataValueFactory		getDataValueFactory() {
0: 		return dvf;
0: 	}
0: 
0: 	protected void pushDataDictionaryContext(ContextManager cm) {
0: 		// we make sure there is a data dictionary context in place.
0: 		dd.pushDataDictionaryContext(cm, false);
0: 	}
0: 
0: 	/*
0: 		ModuleControl interface
0: 	 */
0: 
0: 	/**
0: 		this implementation will not support caching of statements.
0: 	 */
0: 	public boolean canSupport(Properties startParams) {
0: 
0: 		return Monitor.isDesiredType( startParams, EngineType.STANDALONE_DB);
0: 	}
0: 
0: 	private	int	statementCacheSize(Properties startParams)
0: 	{
0: 		String wantCacheProperty = null;
0: 
0: 		wantCacheProperty =
0: 			PropertyUtil.getPropertyFromSet(startParams, org.apache.derby.iapi.reference.Property.STATEMENT_CACHE_SIZE);
0: 
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.DEBUG("StatementCacheInfo", "Cacheing implementation chosen if null or 0<"+wantCacheProperty);
0: 
0: 		if (wantCacheProperty != null) {
0: 			try {
0: 			    cacheSize = Integer.parseInt(wantCacheProperty);
0: 			} catch (NumberFormatException nfe) {
0: 				cacheSize = org.apache.derby.iapi.reference.Property.STATEMENT_CACHE_SIZE_DEFAULT; 
0: 			}
0: 		}
0: 
0: 		return cacheSize;
0: 	}
0: 	
0: 	/**
0: 	 * Start-up method for this instance of the language connection factory.
0: 	 * Note these are expected to be booted relative to a Database.
0: 	 *
0: 	 * @param startParams	The start-up parameters (ignored in this case)
0: 	 *
0: 	 * @exception StandardException	Thrown on failure to boot
0: 	 */
0: 	public void boot(boolean create, Properties startParams) 
0: 		throws StandardException {
0: 
0: 		// Get the Database from the context manager and pass it to the
0: 		// DataValueFactory. The DVF expects a LocaleFinder, which Database
0: 		// implements.
0: 		//
0: 		// RESOLVE: Unfortunately, the Database is in the process of booting,
0: 		// so the Monitor can't find it. So, we just pass in null, and let
0: 		// the DVF get the Database on first access. No amount of shuffling
0: 		// of boot order can solve this problem, because the Database is
0: 		// the top-level module for almost everything. So, the Monitor needs
0: 		// to be fixed so it can find modules that are not done booting yet.
0: 		dvf = new DataValueFactoryImpl((LocaleFinder) null);
0: 
0: 		javaFactory = (JavaFactory) Monitor.startSystemModule(org.apache.derby.iapi.reference.Module.JavaFactory);
0: 		uuidFactory = Monitor.getMonitor().getUUIDFactory();
0: 		classFactory = (ClassFactory) Monitor.getServiceModule(this, org.apache.derby.iapi.reference.Module.ClassFactory);
0: 		if (classFactory == null)
0:  			classFactory = (ClassFactory) Monitor.findSystemModule(org.apache.derby.iapi.reference.Module.ClassFactory);
0: 
0: 		bootDataDictionary(create, startParams);
0: 
0: 		//set the property validation module needed to do propertySetCallBack
0: 		//register and property validation
0: 		setValidation();
0: 
0: 		setStore();
0: 
0: 		ef = (ExecutionFactory) Monitor.bootServiceModule(create, this, ExecutionFactory.MODULE, startParams);
0: 		of = (OptimizerFactory) Monitor.bootServiceModule(create, this, OptimizerFactory.MODULE, startParams);
0: 		tcf =
0: 		   (TypeCompilerFactory) Monitor.startSystemModule(TypeCompilerFactory.MODULE);
0: 		nodeFactory = (NodeFactory) Monitor.bootServiceModule(create, this, NodeFactory.MODULE, startParams);
0: 
0: 		// If the system supports statement caching boot the CacheFactory module.
0: 		int cacheSize = statementCacheSize(startParams);
0: 		if (cacheSize > 0) {
0: 			CacheFactory cacheFactory = (CacheFactory) Monitor.startSystemModule(org.apache.derby.iapi.reference.Module.CacheFactory);
0: 			singleStatementCache = cacheFactory.newCacheManager(this,
0: 												"StatementCache",
0: 												cacheSize/4,
0: 												cacheSize);
0: 		}
0: 
0: 	}
0: 
0: 	protected void bootDataDictionary(boolean create, Properties startParams) throws StandardException {
0: 		dd = (DataDictionary) Monitor.bootServiceModule(create, this, DataDictionary.MODULE, startParams);
0: 	}
0: 
0: 	/**
0: 	 * returns the statement cache that this connection should use; currently
0: 	 * there is a statement cache per connection.
0: 	 */
0: 	
0: 
0: 	public CacheManager getStatementCache()
0: 	{
0: 		return singleStatementCache;
0: 	}
0: 
0: 	/**
0: 	 * Stop this module.  In this case, nothing needs to be done.
0: 	 *
0: 	 * @return	Nothing
0: 	 */
0: 	public void stop() {
0: 	}
0: 
0: 	/*
0: 	** Methods of PropertySetCallback
0: 	*/
0: 
0: 	public void init(boolean dbOnly, Dictionary p) {
0: 		// not called yet ...
0: 	}
0: 
0: 	/**
0: 	  @see PropertySetCallback#validate
0: 	  @exception StandardException Thrown on error.
0: 	*/
0: 	public boolean validate(String key,
0: 						 Serializable value,
0: 						 Dictionary p)
0: 		throws StandardException {
0: 		if (value == null)
0: 			return true;
0: 		else if (key.equals(Property.DEFAULT_CONNECTION_MODE_PROPERTY))
0: 		{
0: 			String value_s = (String)value;
0: 			if (value_s != null &&
0: 				!StringUtil.SQLEqualsIgnoreCase(value_s, Property.NO_ACCESS) &&
0: 				!StringUtil.SQLEqualsIgnoreCase(value_s, Property.READ_ONLY_ACCESS) &&
0: 				!StringUtil.SQLEqualsIgnoreCase(value_s, Property.FULL_ACCESS))
0: 				throw StandardException.newException(SQLState.AUTH_INVALID_AUTHORIZATION_PROPERTY					, key,value_s);
0: 
0: 			return true;
0: 		}
0: 		else if (key.equals(Property.READ_ONLY_ACCESS_USERS_PROPERTY) ||
0: 				 key.equals(Property.FULL_ACCESS_USERS_PROPERTY))
0: 		{
0: 			String value_s = (String)value;
0: 
0: 			/** Parse the new userIdList to verify its syntax. */
0: 			String[] newList_a;
0: 			try {newList_a = IdUtil.parseIdList(value_s);}
0: 			catch (StandardException se) {
0: 				throw StandardException.newException(SQLState.AUTH_INVALID_AUTHORIZATION_PROPERTY, key,value_s,se);
0: 			}
0: 
0: 			/** Check the new list userIdList for duplicates. */
0: 			String dups = IdUtil.dups(newList_a);
0: 			if (dups != null) throw StandardException.newException(SQLState.AUTH_DUPLICATE_USERS, key,dups);
0: 
0: 			/** Check for users with both read and full access permission. */
0: 			String[] otherList_a;
0: 			String otherList;
0: 			if (key.equals(Property.READ_ONLY_ACCESS_USERS_PROPERTY))
0: 				otherList = (String)p.get(Property.FULL_ACCESS_USERS_PROPERTY);
0: 			else
0: 				otherList = (String)p.get(Property.READ_ONLY_ACCESS_USERS_PROPERTY);
0: 			otherList_a = IdUtil.parseIdList(otherList);
0: 			String both = IdUtil.intersect(newList_a,otherList_a);
0: 			if (both != null) throw StandardException.newException(SQLState.AUTH_USER_IN_READ_AND_WRITE_LISTS, both);
0: 			
0: 			return true;
0: 		}
0: 
0: 		return false;
0: 	}
0: 	/** @see PropertySetCallback#apply */
0: 	public Serviceable apply(String key,
0: 							 Serializable value,
0: 							 Dictionary p)
0: 	{
0: 			 return null;
0: 	}
0: 	/** @see PropertySetCallback#map */
0: 	public Serializable map(String key, Serializable value, Dictionary p)
0: 	{
0: 		return null;
0: 	}
0: 
0: 	protected void setValidation() throws StandardException {
0: 		pf = (PropertyFactory) Monitor.findServiceModule(this,
0: 			org.apache.derby.iapi.reference.Module.PropertyFactory);
0: 		pf.addPropertySetNotification(this);
0: 	}
0: 
0: 	protected void setStore() throws StandardException {
0: 		af = (AccessFactory) Monitor.findServiceModule(this,AccessFactory.MODULE);
0: 	}
0: 
0:     public Parser newParser(CompilerContext cc)
0:     {
0:         return new org.apache.derby.impl.sql.compile.ParserImpl(cc);
0:     }
0: 
0: 	// Class methods
0: 
0: 	/**
0: 	 * Get the instance # for the next LCC.
0: 	 * (Useful for logStatementText=true output.
0: 	 *
0: 	 * @return instance # of next LCC.
0: 	 */
0: 	protected synchronized int getNextLCCInstanceNumber()
0: 	{
0: 		return nextLCCInstanceNumber++;
0: 	}
0: }
============================================================================