1:db2c1c2: /*
6:db2c1c2: 
1:db2c1c2:    Derby - Class org.apache.derbyTesting.functionTests.tests.tools.ImportExportTest
1:db2c1c2: 
1:db2c1c2:    Licensed to the Apache Software Foundation (ASF) under one or more
1:db2c1c2:    contributor license agreements.  See the NOTICE file distributed with
1:db2c1c2:    this work for additional information regarding copyright ownership.
1:db2c1c2:    The ASF licenses this file to You under the Apache License, Version 2.0
1:db2c1c2:    (the "License"); you may not use this file except in compliance with
1:db2c1c2:    the License.  You may obtain a copy of the License at
1:db2c1c2: 
1:db2c1c2:       http://www.apache.org/licenses/LICENSE-2.0
1:db2c1c2: 
1:db2c1c2:    Unless required by applicable law or agreed to in writing, software
1:db2c1c2:    distributed under the License is distributed on an "AS IS" BASIS,
1:db2c1c2:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:db2c1c2:    See the License for the specific language governing permissions and
1:db2c1c2:    limitations under the License.
1:db2c1c2: 
1:3103790:  */
1:db2c1c2: 
1:db2c1c2: package org.apache.derbyTesting.functionTests.tests.tools;
1:db2c1c2: 
1:db2c1c2: import java.sql.PreparedStatement;
1:db2c1c2: import java.sql.ResultSet;
1:db2c1c2: import java.sql.SQLException;
1:1ae02c9: import java.sql.Statement;
1:1ae02c9: import junit.framework.Test;
1:db2c1c2: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:db2c1c2: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1:db2c1c2: import org.apache.derbyTesting.junit.JDBC;
1:db2c1c2: import org.apache.derbyTesting.junit.SupportFilesSetup;
1:db2c1c2: import org.apache.derbyTesting.junit.TestConfiguration;
1:db2c1c2: 
1:db2c1c2: /**
1:db2c1c2:  * Test import and export procedures 
2:db2c1c2:  */
1:db2c1c2: public class ImportExportTest extends BaseJDBCTestCase {
1:db2c1c2: 
1:db2c1c2: 	public ImportExportTest(String name) {
1:db2c1c2: 		super(name);
1:2732872: 	}
1:2732872: 	
1:db2c1c2: 	public static Test suite() {
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite("ImportExportTest");
1:db2c1c2: 
1:99b7123:         // disabled on weme6.1 due at the moment due 
1:99b7123:         // to problems with security exceptions.
1:99b7123:         if (JDBC.vmSupportsJSR169())
1:99b7123:         {
1:1ae02c9:             return new BaseTestSuite();
1:99b7123:         }
1:db2c1c2:         suite.addTest(baseSuite("ImportExportTest:embedded"));
1:db2c1c2: 
1:db2c1c2:         suite.addTest(
1:db2c1c2:                 TestConfiguration.clientServerDecorator(
1:db2c1c2:                         baseSuite("ImportExportTest:client")));    
1:db2c1c2:         return suite;
2:db2c1c2: 	}
1:db2c1c2: 	
1:db2c1c2: 	public static Test baseSuite(String name) {
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite(ImportExportTest.class, name);
1:40a4584: 		Test test = new SupportFilesSetup(suite, new String[] {"functionTests/testData/ImportExport/TwoLineBadEOF.dat"} );
1:db2c1c2: 		return new CleanDatabaseTestSetup(test) {
1:db2c1c2:             protected void decorateSQL(Statement s) throws SQLException {
1:db2c1c2: 
1:2732872:                 s.execute( "create type Price external name 'org.apache.derbyTesting.functionTests.tests.lang.Price' language java" );
1:2732872:                 s.execute( "create type hashmap external name 'java.util.HashMap' language java" );
1:2732872: 
1:2732872:                 s.execute( "create function makePrice( ) returns price " +
1:2732872:                            "language java parameter style java no sql " +
1:2732872:                            "external name 'org.apache.derbyTesting.functionTests.tests.lang.Price.makePrice'" );
1:2732872: 
1:2732872:                 s.execute( "create function makeHashMap( ) returns hashmap " +
1:2732872:                            "language java parameter style java no sql " +
1:2732872:                            "external name 'org.apache.derbyTesting.functionTests.tests.lang.UDTTest.makeHashMap'" );
1:2732872: 
1:db2c1c2:                 s.execute("CREATE TABLE T1 (COLUMN1 VARCHAR(5) , COLUMN2 VARCHAR(8) , " +
1:db2c1c2: 						   "COLUMN3 SMALLINT , COLUMN4 CHAR(11) , COLUMN5 DATE , COLUMN6 DECIMAL(5,1) , " +
1:db2c1c2: 						   "COLUMN7 DOUBLE PRECISION , COLUMN8 INT , COLUMN9 BIGINT , COLUMN10 NUMERIC , " +
1:db2c1c2: 						   "COLUMN11 REAL , COLUMN12 SMALLINT , COLUMN13 TIME , COLUMN14 TIMESTAMP , "+
1:2732872: 						   "COLUMN15 SMALLINT , COLUMN16 VARCHAR(1), COLUMN17 PRICE)");
1:db2c1c2:                 s.execute("CREATE TABLE T2 (COLUMN1 VARCHAR(5) , COLUMN2 VARCHAR(8) , " +
1:db2c1c2: 						   "COLUMN3 SMALLINT, COLUMN4 CHAR(11) , COLUMN5 DATE , COLUMN6 DECIMAL(5,1) , " +
1:db2c1c2: 						   "COLUMN7 DOUBLE PRECISION , COLUMN8 INT , COLUMN9 BIGINT , COLUMN10 NUMERIC , " +
1:db2c1c2: 						   "COLUMN11 REAL , COLUMN12 SMALLINT , COLUMN13 TIME , COLUMN14 TIMESTAMP , "+
1:2732872: 						   "COLUMN15 SMALLINT , COLUMN16 VARCHAR(1), COLUMN17 PRICE)");
1:40a4584:                 s.execute("create table T4 (   Account int,    Name   char(30), Jobdesc char(40), " +
1:40a4584:                            "Company varchar(35), Address1 varchar(40), Address2 varchar(40), " +
1:40a4584:                            "City    varchar(20), State   char(5), Zip char(10), Country char(10), " +
1:40a4584:                            "Phone1  char(20), Phone2  char(20), email   char(30), web     char(30), " +
1:40a4584:                            "Fname   char(30), Lname   char(30), Comment char(30), AccDate char(30), " +
1:40a4584:                            "Payment decimal(8,2), Balance decimal(8,2))");
1:2732872: 
1:2732872:                 s.execute( "create table t5( a int, b price )" );
1:2732872:                 s.execute( "create table t6( a int, b hashmap )" );
1:40a4584:                 }
1:db2c1c2:         };
1:db2c1c2: 	}
1:b26ddb0: 
1:b26ddb0:     /**
1:b26ddb0:      * Set up the test environment.
1:b26ddb0:      */
1:b26ddb0:     protected void setUp() throws Exception {
1:b26ddb0:         resetTables();
1:b26ddb0:     }
1:db2c1c2: 	
1:db2c1c2: 	public void testImportFromNonExistantFile() {
1:db2c1c2: 		try {
1:ccc1b8d:             doImport("Z", null, "T1", null, null, null, 0);
1:94d395e:             fail();
1:db2c1c2: 		} catch (SQLException e) {
1:de3b108: 			assertSQLState("XIE04", e);
1:db2c1c2: 		}
1:db2c1c2: 	}
1:ccc1b8d: 	
1:db2c1c2: 	public void testNullDataFile() {
1:db2c1c2: 		try {
1:ccc1b8d:             doImport(null, null, "T1", null, null, null, 0);
1:94d395e:             fail();
1:db2c1c2: 		} catch (SQLException e) {
1:de3b108: 			assertSQLState("XIE05", e);
1:db2c1c2: 		}
1:db2c1c2: 	}
1:db2c1c2: 	
1:db2c1c2: 	public void testEmptyTable() throws SQLException {
1:ccc1b8d:         doImportAndExport(null, "T1", null, null, null);
1:db2c1c2: 	}
1:db2c1c2: 
1:db2c1c2: 	public void testEmptyTableWithDelimitedFormat() throws SQLException {
1:ccc1b8d:         doImportAndExport(null, "T1", null, null, "8859_1");
1:db2c1c2: 	}
1:db2c1c2: 
1:db2c1c2: 	public void testEmptyTableWithFieldCharDelimiters() throws SQLException {
1:ccc1b8d:         doImportAndExport(null, "T1", "\t", "|", "8859_1");
1:db2c1c2: 	}
1:db2c1c2: 	
1:db2c1c2: 	public void testWithDefaultOptions() throws Exception {
1:ccc1b8d:         doImportAndExport(null, "T1", null, null, null);
1:db2c1c2: 	}
1:db2c1c2: 	
1:db2c1c2: 	public void testWithCodeset() throws Exception {
1:ccc1b8d:         doImportAndExport(null, "T1", null, null, "8859_1");
1:db2c1c2: 	}
1:db2c1c2: 
1:db2c1c2: 	public void testDelimiterAndCodeset() throws Exception {
1:ccc1b8d:         doImportAndExport(null, "T1", "\t", "|", "8859_1");
1:db2c1c2: 	}
1:db2c1c2: 	
1:db2c1c2: 	public void testSpecialDelimitersAndCodeset() throws Exception {
1:ccc1b8d:         doImportAndExport(null, "T1", "%", "&", "Cp1252");
1:db2c1c2: 	}
1:db2c1c2: 
1:db2c1c2: 	public void testSpecialDelimitersAndUTF16() throws Exception {
1:ccc1b8d:         doImportAndExport(null, "T1", "%", "&", "UTF-16");
1:db2c1c2: 	}
1:db2c1c2: 	
1:052d757: 	public void testInvalidEncoding() throws Exception {
1:db2c1c2: 		try {
1:ccc1b8d:             doImportAndExport(null, "T1", "^", "#", "INAVALID ENCODING");
1:94d395e:             fail();
1:db2c1c2: 		} catch (SQLException e) {
1:db2c1c2: 			assertSQLState("XIE0I", e);
1:db2c1c2: 		}
1:db2c1c2: 	}
1:db2c1c2: 	
1:db2c1c2: 	public void testEarlyEndOfFile() throws Exception {
1:db2c1c2: 		try {
1:ccc1b8d:             doImportFromFile("extin/TwoLineBadEOF.dat", null, "T4",
1:ccc1b8d:                              null, null, "US-ASCII", 0);
1:94d395e:             fail();
1:db2c1c2: 		} catch (SQLException e) {
1:de3b108: 			assertSQLState("XIE0E", e);
1:db2c1c2: 		}
1:db2c1c2: 	}
1:ccc1b8d: 
1:ccc1b8d:     /**
1:161e9cc:      * Test that import to a table in the default schema works if a table
1:161e9cc:      * with the same name exists in a different schema (DERBY-3296).
1:161e9cc:      */
1:161e9cc:     public void testImportWithSameNameInDifferentSchema() throws Exception {
1:161e9cc:         doExport(null, "T1", null, null, null);
1:161e9cc:         Statement s = createStatement();
1:161e9cc:         s.executeUpdate("create table otherschema.t2(x int)");
1:161e9cc:         // toSchema must be null to trigger the bug. The bug is not exposed if
1:161e9cc:         // the schema is explicit.
1:161e9cc:         doImport("T1", null, "T2", null, null, null, 0);
1:161e9cc:         // Check that the rows were imported to the correct table (APP.T2)
1:161e9cc:         JDBC.assertSingleValueResultSet(
1:161e9cc:                 s.executeQuery("select count(*) from app.t2"), "4");
1:161e9cc:         setAutoCommit(false); // requirement for dropSchema()
1:161e9cc:         JDBC.dropSchema(getConnection().getMetaData(), "OTHERSCHEMA");
1:161e9cc:     }
1:161e9cc: 
1:161e9cc:     /**
1:ccc1b8d:      * Test that quotes in the arguments to the export and import procedures
1:ccc1b8d:      * are handled properly (DERBY-4042).
1:ccc1b8d:      */
1:ccc1b8d:     public void testQuotesInArguments() throws Exception {
1:ccc1b8d:         // Create schema names and table names containing both single quotes
1:ccc1b8d:         // and double quotes to expose bugs both for internally generated
1:ccc1b8d:         // string literals (enclosed in single quotes) and SQL identifiers
1:4e83499:         // (enclosed in double quotes). Both single and double quotes used
1:4e83499:         // to cause problems.
1:ccc1b8d:         final String schema = "s'\"";
1:ccc1b8d:         final String table = "t'\"";
1:ccc1b8d:         final String escapedName = JDBC.escape(schema, table);
1:ccc1b8d: 
1:ccc1b8d:         Statement s = createStatement();
1:ccc1b8d:         s.execute("create table " + escapedName +
1:ccc1b8d:                   " as select * from T1 with no data");
1:ccc1b8d:         s.execute("insert into " + escapedName + " select * from t1");
1:ccc1b8d: 
1:4e83499:         // Quotes in the delimiters didn't use to be a problem, but test
1:4e83499:         // it anyway
1:4e83499:         final String colDel = "'";
1:4e83499:         final String charDel = "\"";
1:4e83499:         final String encoding = "US-ASCII";
1:4e83499: 
1:4e83499:         // Single quotes in file name used to cause syntax errors
1:4e83499:         final String fileName = SupportFilesSetup.
1:4e83499:                 getReadWrite("please don't fail.dat").getPath();
1:4e83499: 
1:4e83499:         // Export used to fail with a syntax error
1:4e83499:         doExportToFile(fileName, schema, table, colDel, charDel, encoding);
1:4e83499: 
1:4e83499:         // Empty the table so that we can see that it was imported later
1:4e83499:         int rowsInTable = s.executeUpdate("delete from " + escapedName);
1:4e83499: 
1:4e83499:         // Import used to fail with a syntax error
1:4e83499:         doImportFromFile(fileName, schema, table, colDel, charDel, encoding, 0);
1:4e83499: 
1:4e83499:         // Verify that the table was imported
1:4e83499:         JDBC.assertSingleValueResultSet(
1:4e83499:                 s.executeQuery("select count(*) from " + escapedName),
1:4e83499:                 Integer.toString(rowsInTable));
1:ccc1b8d:     }
1:ccc1b8d: 
1:2732872:     /**
1:9e89a51:      * Test that we can successfully export from and import to tables that
1:9e89a51:      * have columns with special characters in their names (single and double
1:9e89a51:      * quotes, spaces, mixed case). Regression test case for DERBY-4828.
1:9e89a51:      */
1:9e89a51:     public void testQuotesInColumnNames() throws Exception {
1:9e89a51:         Statement s = createStatement();
1:9e89a51: 
1:9e89a51:         // Create a source table with column names that contain special
1:9e89a51:         // characters.
1:9e89a51:         s.execute("create table table_with_funny_cols_src ("
1:9e89a51:                 // simple column name
1:9e89a51:                 + "x int, "
1:9e89a51:                 // column name with single and double quotes, mixed case
1:9e89a51:                 // and spaces
1:9e89a51:                 + "\"Let's try this! \"\" :)\" int)");
1:9e89a51:         s.execute("insert into table_with_funny_cols_src values (1,2), (3,4)");
1:9e89a51: 
1:9e89a51:         // Export the table to a file.
1:9e89a51:         doExport(null, "TABLE_WITH_FUNNY_COLS_SRC", null, null, null);
1:9e89a51: 
1:9e89a51:         // Create an empty destination table with the same schema as the
1:9e89a51:         // source table.
1:9e89a51:         s.execute("create table table_with_funny_cols_dest as "
1:9e89a51:                 + "select * from table_with_funny_cols_src with no data");
1:9e89a51: 
1:9e89a51:         // Import into the destination table.
1:9e89a51:         doImport("TABLE_WITH_FUNNY_COLS_SRC",
1:9e89a51:                  null, "TABLE_WITH_FUNNY_COLS_DEST",
1:9e89a51:                  null, null, null, 0);
1:9e89a51: 
1:9e89a51:         // Verify that the rows were successfully imported.
1:9e89a51:         JDBC.assertFullResultSet(
1:9e89a51:                 s.executeQuery(
1:9e89a51:                     "select * from table_with_funny_cols_dest order by x"),
1:9e89a51:                 new String[][] { {"1", "2"}, {"3", "4"} });
1:9e89a51:     }
1:9e89a51: 
1:9e89a51:     /**
1:2732872:      * Test that you can't import the wrong type of object into a UDT column.
1:2732872:      */
1:2732872:     public void testCastingProblem() throws Exception
1:2732872:     {
1:2732872:         final String fileName = SupportFilesSetup.
1:2732872:                 getReadWrite("castCheck.dat").getPath();
1:2732872: 
1:2732872:         // export table which has a HashMap column
1:2732872:         doExportToFile( fileName, null, "T6", null, null, null );
1:2732872: 
1:2732872:         // try to import the HashMap into a Price column
1:2732872:         try {
1:2732872:             doImportFromFile( fileName, null, "T5", null, null, null, 0 );
1:2732872:             fail();
1:2732872: 		} catch (SQLException e) {
1:2732872: 			assertSQLState("XJ001", e);
1:2732872: 		}
1:db2c1c2:     }
1:2732872: 
1:ccc1b8d:     private void doImport(String fromTable, String toSchema, String toTable,
1:db2c1c2: 			 String colDel, String charDel , 
1:db2c1c2: 			 String codeset, int replace) throws SQLException 
1:db2c1c2:     {
1:4e83499:         String fileName = (fromTable == null) ?
1:4e83499:             null : SupportFilesSetup.getReadWrite(fromTable + ".dat").getPath();
1:4e83499:         doImportFromFile(fileName, toSchema, toTable,
1:4e83499:                 colDel, charDel, codeset, replace);
1:db2c1c2:     }
1:db2c1c2: 	
1:ccc1b8d:     private void doImportFromFile(
1:ccc1b8d:              String fileName, String toSchema, String toTable,
1:db2c1c2: 			 String colDel, String charDel , 
1:4e83499: 			 String codeset, int replace) throws SQLException
1:db2c1c2:     {
2:db2c1c2: 		String impsql = "call SYSCS_UTIL.SYSCS_IMPORT_TABLE (? , ? , ? , ?, ? , ?, ?)";
1:ccc1b8d:         PreparedStatement ps = prepareStatement(impsql);
1:ccc1b8d:         ps.setString(1, toSchema);
2:db2c1c2: 		ps.setString(2, toTable);
1:db2c1c2: 		ps.setString(3, fileName);
2:db2c1c2: 		ps.setString(4 , colDel);
2:db2c1c2: 		ps.setString(5 , charDel);
2:db2c1c2: 		ps.setString(6 , codeset);
2:db2c1c2: 		ps.setInt(7, replace);
2:db2c1c2: 		ps.execute();
2:db2c1c2: 		ps.close();
1:db2c1c2: 
1:db2c1c2:     }
1:db2c1c2: 
1:ccc1b8d: 	private void doImportAndExport(
1:ccc1b8d:               String fromSchema, String fromTable, String colDel,
2:db2c1c2: 			  String charDel, 
2:db2c1c2: 			  String codeset) throws SQLException 
1:db2c1c2:     {
1:ccc1b8d:         doExport(fromSchema, fromTable, colDel, charDel, codeset);
1:ccc1b8d:         doImportAndVerify(fromSchema, fromTable, colDel, charDel, codeset, 0);
1:db2c1c2:         // also test with replace
1:ccc1b8d:         doImportAndVerify(fromSchema, fromTable, colDel, charDel, codeset, 1);
1:db2c1c2:     }
1:db2c1c2: 	
1:ccc1b8d:     private void doExport(String fromSchema, String fromTable, String colDel,
1:4e83499: 			 String charDel,
1:4e83499: 			 String codeset) throws SQLException
1:db2c1c2: 	{
1:4e83499:         String fileName = (fromTable == null) ?
1:4e83499:             null : SupportFilesSetup.getReadWrite(fromTable + ".dat").getPath();
1:4e83499:         doExportToFile(
1:4e83499:                 fileName, fromSchema, fromTable, colDel, charDel, codeset);
1:4e83499:     }
1:4e83499: 
1:4e83499:     private void doExportToFile(
1:4e83499:             String fileName, String fromSchema, String fromTable,
1:4e83499:             String colDel, String charDel, String codeset) throws SQLException
1:4e83499:     {
1:927ad05: 		 //DERBY-2925: need to delete existing files first.
1:4e83499:          if (fileName != null) {
1:4e83499:              SupportFilesSetup.deleteFile(fileName);
1:4e83499:          }
1:db2c1c2: 		 String expsql = "call SYSCS_UTIL.SYSCS_EXPORT_TABLE (? , ? , ? , ?, ? , ?)";
1:ccc1b8d:          PreparedStatement ps = prepareStatement(expsql);
1:ccc1b8d:          ps.setString(1, fromSchema);
1:db2c1c2: 		 ps.setString(2, fromTable);
1:4e83499:          ps.setString(3, fileName);
1:db2c1c2: 		 ps.setString(4 , colDel);
1:db2c1c2: 		 ps.setString(5 , charDel);
1:db2c1c2: 		 ps.setString(6 , codeset);
1:db2c1c2: 		 ps.execute();
1:db2c1c2: 		 ps.close();
1:db2c1c2:     }
1:db2c1c2: 	
1:db2c1c2: 	/**
1:db2c1c2: 	 * doImportAndVerify checks that data which has been imported and
1:db2c1c2: 	 * then exported is identical. It imports the requested data, 
1:db2c1c2: 	 * which has been exported from T1. Row counts are compared, and
1:db2c1c2: 	 * then the data in T2 is again exported. A bytewise comparison 
1:db2c1c2: 	 * of the two files is then made to verify that the data has been
1:db2c1c2: 	 * gone through the import/export process intact.
1:db2c1c2: 	 */
1:ccc1b8d: 	private void doImportAndVerify(
1:ccc1b8d:               String fromSchema, String fromTable, String colDel,
1:db2c1c2: 			  String charDel , String codeset, 
1:db2c1c2: 			  int replace) throws SQLException 
1:db2c1c2:     {
1:db2c1c2: 
1:ccc1b8d:         doImport(fromTable, null, "T2", colDel, charDel, codeset, replace);
1:db2c1c2: 
1:ccc1b8d:         Statement stmt = createStatement();
1:ccc1b8d:         ResultSet rs = stmt.executeQuery("SELECT COUNT(*) FROM " +
1:ccc1b8d:                 ((fromSchema == null) ?
1:ccc1b8d:                     JDBC.escape(fromTable) :
1:ccc1b8d:                     JDBC.escape(fromSchema, fromTable)));
1:db2c1c2: 		rs.next();
1:db2c1c2: 		int numberOfRowsInT1 = rs.getInt(1);
1:db2c1c2: 		rs.close();
1:db2c1c2: 		rs = stmt.executeQuery("SELECT COUNT(*) FROM t2");
1:db2c1c2: 		rs.next();
1:db2c1c2: 		int numberOfRowsInT2 = rs.getInt(1);
1:db2c1c2: 		rs.close();
1:db2c1c2: 		stmt.close();
1:db2c1c2: 		assertEquals(numberOfRowsInT1, numberOfRowsInT2);
1:db2c1c2: 
1:ccc1b8d: 		doExport(null, "T2" , colDel , charDel , codeset);
1:db2c1c2: 
1:db2c1c2:         //check whether the  exported files from T1 and T2  are same now.
1:db2c1c2: 		assertEquals(SupportFilesSetup.getReadWrite(fromTable + ".dat"),
1:db2c1c2: 				     SupportFilesSetup.getReadWrite("T2.dat"));
1:db2c1c2:     }
1:db2c1c2: 	
1:db2c1c2: 	/**
1:b26ddb0: 	 * Called from {@link #setUp()}.
1:db2c1c2: 	 * Ensures that the import and export operate on a consistent
1:db2c1c2: 	 * set of data.
1:db2c1c2: 	 */
1:db2c1c2: 	private void resetTables() throws Exception {
1:db2c1c2: 		runSQLCommands("delete from t1");
1:db2c1c2: 		runSQLCommands("delete from t2");
1:2732872: 		runSQLCommands("delete from t5");
1:2732872: 		runSQLCommands("delete from t6");
1:db2c1c2: 		runSQLCommands("INSERT INTO T1 VALUES (null,'aa',1,'a',DATE('1998-06-30'),"+
1:2732872: 		               "1,1,1,1,1,1,1,TIME('12:00:00'),TIMESTAMP('1998-06-30 12:00:00.0'),1,'a', makePrice() )");
1:db2c1c2:         runSQLCommands("INSERT INTO T1 VALUES (null,'bb',1,'b',DATE('1998-06-30'),"+
1:2732872: 					   "2,2,2,2,2,2,2,TIME('12:00:00'),TIMESTAMP('1998-06-30 12:00:00.0'),2,'b', makePrice() )");
1:db2c1c2:         runSQLCommands("INSERT INTO T1 VALUES (null,'cc',1,'c',DATE('1998-06-30'),"+
1:2732872: 					   "3,3,3,3,3,3,3,TIME('12:00:00'),TIMESTAMP('1998-06-30 12:00:00.0'),3,'c', makePrice())");
1:db2c1c2:         runSQLCommands("INSERT INTO T1 VALUES (null,'dd',1,'d',DATE('1998-06-30'),"+
1:2732872: 					   "4,4,4,4,4,4,4,TIME('12:00:00'),TIMESTAMP('1998-06-30 12:00:00.0'),4,'d', makePrice())");
1:2732872:         runSQLCommands( "insert into t6 values( 1, makeHashMap() )" );
1:db2c1c2: 	}
1:db2c1c2: 
1:db2c1c2: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Statement;
1: import junit.framework.Test;
1: import org.apache.derbyTesting.junit.BaseTestSuite;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite("ImportExportTest");
1:             return new BaseTestSuite();
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite(ImportExportTest.class, name);
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:b26ddb0
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Set up the test environment.
1:      */
1:     protected void setUp() throws Exception {
1:         resetTables();
1:     }
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	 * Called from {@link #setUp()}.
commit:9e89a51
/////////////////////////////////////////////////////////////////////////
1:      * Test that we can successfully export from and import to tables that
1:      * have columns with special characters in their names (single and double
1:      * quotes, spaces, mixed case). Regression test case for DERBY-4828.
1:      */
1:     public void testQuotesInColumnNames() throws Exception {
1:         Statement s = createStatement();
1: 
1:         // Create a source table with column names that contain special
1:         // characters.
1:         s.execute("create table table_with_funny_cols_src ("
1:                 // simple column name
1:                 + "x int, "
1:                 // column name with single and double quotes, mixed case
1:                 // and spaces
1:                 + "\"Let's try this! \"\" :)\" int)");
1:         s.execute("insert into table_with_funny_cols_src values (1,2), (3,4)");
1: 
1:         // Export the table to a file.
1:         doExport(null, "TABLE_WITH_FUNNY_COLS_SRC", null, null, null);
1: 
1:         // Create an empty destination table with the same schema as the
1:         // source table.
1:         s.execute("create table table_with_funny_cols_dest as "
1:                 + "select * from table_with_funny_cols_src with no data");
1: 
1:         // Import into the destination table.
1:         doImport("TABLE_WITH_FUNNY_COLS_SRC",
1:                  null, "TABLE_WITH_FUNNY_COLS_DEST",
1:                  null, null, null, 0);
1: 
1:         // Verify that the rows were successfully imported.
1:         JDBC.assertFullResultSet(
1:                 s.executeQuery(
1:                     "select * from table_with_funny_cols_dest order by x"),
1:                 new String[][] { {"1", "2"}, {"3", "4"} });
1:     }
1: 
1:     /**
commit:161e9cc
/////////////////////////////////////////////////////////////////////////
1:      * Test that import to a table in the default schema works if a table
1:      * with the same name exists in a different schema (DERBY-3296).
1:      */
1:     public void testImportWithSameNameInDifferentSchema() throws Exception {
0:         resetTables();
1:         doExport(null, "T1", null, null, null);
1:         Statement s = createStatement();
1:         s.executeUpdate("create table otherschema.t2(x int)");
1:         // toSchema must be null to trigger the bug. The bug is not exposed if
1:         // the schema is explicit.
1:         doImport("T1", null, "T2", null, null, null, 0);
1:         // Check that the rows were imported to the correct table (APP.T2)
1:         JDBC.assertSingleValueResultSet(
1:                 s.executeQuery("select count(*) from app.t2"), "4");
1:         setAutoCommit(false); // requirement for dropSchema()
1:         JDBC.dropSchema(getConnection().getMetaData(), "OTHERSCHEMA");
1:     }
1: 
1:     /**
commit:4e83499
/////////////////////////////////////////////////////////////////////////
1:         // (enclosed in double quotes). Both single and double quotes used
1:         // to cause problems.
/////////////////////////////////////////////////////////////////////////
1:         // Quotes in the delimiters didn't use to be a problem, but test
1:         // it anyway
1:         final String colDel = "'";
1:         final String charDel = "\"";
1:         final String encoding = "US-ASCII";
1: 
1:         // Single quotes in file name used to cause syntax errors
1:         final String fileName = SupportFilesSetup.
1:                 getReadWrite("please don't fail.dat").getPath();
1: 
1:         // Export used to fail with a syntax error
1:         doExportToFile(fileName, schema, table, colDel, charDel, encoding);
1: 
1:         // Empty the table so that we can see that it was imported later
1:         int rowsInTable = s.executeUpdate("delete from " + escapedName);
1: 
1:         // Import used to fail with a syntax error
1:         doImportFromFile(fileName, schema, table, colDel, charDel, encoding, 0);
1: 
1:         // Verify that the table was imported
1:         JDBC.assertSingleValueResultSet(
1:                 s.executeQuery("select count(*) from " + escapedName),
1:                 Integer.toString(rowsInTable));
0:         JDBC.assertEmpty(s.executeQuery(
0:                 "select * from " + escapedName +
0:                 " except all select * from T1"));
1:         String fileName = (fromTable == null) ?
1:             null : SupportFilesSetup.getReadWrite(fromTable + ".dat").getPath();
1:         doImportFromFile(fileName, toSchema, toTable,
1:                 colDel, charDel, codeset, replace);
1: 			 String codeset, int replace) throws SQLException
/////////////////////////////////////////////////////////////////////////
1: 			 String charDel,
1: 			 String codeset) throws SQLException
1:         String fileName = (fromTable == null) ?
1:             null : SupportFilesSetup.getReadWrite(fromTable + ".dat").getPath();
1:         doExportToFile(
1:                 fileName, fromSchema, fromTable, colDel, charDel, codeset);
1:     }
1: 
1:     private void doExportToFile(
1:             String fileName, String fromSchema, String fromTable,
1:             String colDel, String charDel, String codeset) throws SQLException
1:     {
1:          if (fileName != null) {
1:              SupportFilesSetup.deleteFile(fileName);
1:          }
1:          ps.setString(3, fileName);
commit:ccc1b8d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             doImport("Z", null, "T1", null, null, null, 0);
/////////////////////////////////////////////////////////////////////////
1:             doImport(null, null, "T1", null, null, null, 0);
/////////////////////////////////////////////////////////////////////////
1:         doImportAndExport(null, "T1", null, null, null);
1:         doImportAndExport(null, "T1", null, null, "8859_1");
1:         doImportAndExport(null, "T1", "\t", "|", "8859_1");
1:         doImportAndExport(null, "T1", null, null, null);
1:         doImportAndExport(null, "T1", null, null, "8859_1");
1:         doImportAndExport(null, "T1", "\t", "|", "8859_1");
1:         doImportAndExport(null, "T1", "%", "&", "Cp1252");
1:         doImportAndExport(null, "T1", "%", "&", "UTF-16");
1:             doImportAndExport(null, "T1", "^", "#", "INAVALID ENCODING");
/////////////////////////////////////////////////////////////////////////
1:             doImportFromFile("extin/TwoLineBadEOF.dat", null, "T4",
1:                              null, null, "US-ASCII", 0);
1: 
1:     /**
1:      * Test that quotes in the arguments to the export and import procedures
1:      * are handled properly (DERBY-4042).
1:      */
1:     public void testQuotesInArguments() throws Exception {
0:         resetTables();
1: 
1:         // Create schema names and table names containing both single quotes
1:         // and double quotes to expose bugs both for internally generated
1:         // string literals (enclosed in single quotes) and SQL identifiers
0:         // (enclosed in double quotes). This will also indirectly test that
0:         // the export/import system procedures handle those characters in
0:         // file names (which they didn't do very well before the fix for
0:         // DERBY-4042), as doExport() and doImportAndVerify() use a file name
0:         // derived from the table name.
1:         final String schema = "s'\"";
1:         final String table = "t'\"";
1:         final String escapedName = JDBC.escape(schema, table);
1: 
1:         Statement s = createStatement();
1:         s.execute("create table " + escapedName +
1:                   " as select * from T1 with no data");
1:         s.execute("insert into " + escapedName + " select * from t1");
1: 
0:         doImportAndExport(schema, table, "'", "\"", "US-ASCII");
1:     }
1: 
1:     private void doImport(String fromTable, String toSchema, String toTable,
1:         PreparedStatement ps = prepareStatement(impsql);
1:         ps.setString(1, toSchema);
/////////////////////////////////////////////////////////////////////////
1:     private void doImportFromFile(
1:              String fileName, String toSchema, String toTable,
0:         PreparedStatement ps = prepareStatement(impsql);
0:         ps.setString(1, toSchema);
/////////////////////////////////////////////////////////////////////////
1: 	private void doImportAndExport(
1:               String fromSchema, String fromTable, String colDel,
1:         doExport(fromSchema, fromTable, colDel, charDel, codeset);
1:         doImportAndVerify(fromSchema, fromTable, colDel, charDel, codeset, 0);
1:         doImportAndVerify(fromSchema, fromTable, colDel, charDel, codeset, 1);
1:     private void doExport(String fromSchema, String fromTable, String colDel,
1:          PreparedStatement ps = prepareStatement(expsql);
1:          ps.setString(1, fromSchema);
/////////////////////////////////////////////////////////////////////////
1: 	private void doImportAndVerify(
1:               String fromSchema, String fromTable, String colDel,
1:         doImport(fromTable, null, "T2", colDel, charDel, codeset, replace);
1:         Statement stmt = createStatement();
1:         ResultSet rs = stmt.executeQuery("SELECT COUNT(*) FROM " +
1:                 ((fromSchema == null) ?
1:                     JDBC.escape(fromTable) :
1:                     JDBC.escape(fromSchema, fromTable)));
/////////////////////////////////////////////////////////////////////////
1: 		doExport(null, "T2" , colDel , charDel , codeset);
commit:94d395e
/////////////////////////////////////////////////////////////////////////
1:             fail();
/////////////////////////////////////////////////////////////////////////
1:             fail();
/////////////////////////////////////////////////////////////////////////
1:             fail();
/////////////////////////////////////////////////////////////////////////
1:             fail();
commit:de3b108
/////////////////////////////////////////////////////////////////////////
1: 			assertSQLState("XIE04", e);
/////////////////////////////////////////////////////////////////////////
1: 			assertSQLState("XIE05", e);
/////////////////////////////////////////////////////////////////////////
1: 			assertSQLState("XIE0E", e);
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:2732872
/////////////////////////////////////////////////////////////////////////
1:                 s.execute( "create type Price external name 'org.apache.derbyTesting.functionTests.tests.lang.Price' language java" );
1:                 s.execute( "create type hashmap external name 'java.util.HashMap' language java" );
1: 
1:                 s.execute( "create function makePrice( ) returns price " +
1:                            "language java parameter style java no sql " +
1:                            "external name 'org.apache.derbyTesting.functionTests.tests.lang.Price.makePrice'" );
1: 
1:                 s.execute( "create function makeHashMap( ) returns hashmap " +
1:                            "language java parameter style java no sql " +
1:                            "external name 'org.apache.derbyTesting.functionTests.tests.lang.UDTTest.makeHashMap'" );
1: 
1: 						   "COLUMN15 SMALLINT , COLUMN16 VARCHAR(1), COLUMN17 PRICE)");
1: 						   "COLUMN15 SMALLINT , COLUMN16 VARCHAR(1), COLUMN17 PRICE)");
1: 
1:                 s.execute( "create table t5( a int, b price )" );
1:                 s.execute( "create table t6( a int, b hashmap )" );
/////////////////////////////////////////////////////////////////////////
1:     }
1: 
1:     /**
1:      * Test that you can't import the wrong type of object into a UDT column.
1:      */
1:     public void testCastingProblem() throws Exception
1:     {
0:         resetTables();
1: 
1:         final String fileName = SupportFilesSetup.
1:                 getReadWrite("castCheck.dat").getPath();
1: 
1:         // export table which has a HashMap column
1:         doExportToFile( fileName, null, "T6", null, null, null );
1: 
1:         // try to import the HashMap into a Price column
1:         try {
1:             doImportFromFile( fileName, null, "T5", null, null, null, 0 );
1:             fail();
1: 		} catch (SQLException e) {
1: 			assertSQLState("XJ001", e);
1: 		}
/////////////////////////////////////////////////////////////////////////
1: 		runSQLCommands("delete from t5");
1: 		runSQLCommands("delete from t6");
1: 		               "1,1,1,1,1,1,1,TIME('12:00:00'),TIMESTAMP('1998-06-30 12:00:00.0'),1,'a', makePrice() )");
1: 					   "2,2,2,2,2,2,2,TIME('12:00:00'),TIMESTAMP('1998-06-30 12:00:00.0'),2,'b', makePrice() )");
1: 					   "3,3,3,3,3,3,3,TIME('12:00:00'),TIMESTAMP('1998-06-30 12:00:00.0'),3,'c', makePrice())");
1: 					   "4,4,4,4,4,4,4,TIME('12:00:00'),TIMESTAMP('1998-06-30 12:00:00.0'),4,'d', makePrice())");
1:         runSQLCommands( "insert into t6 values( 1, makeHashMap() )" );
commit:ca42bbe
/////////////////////////////////////////////////////////////////////////
0: 			assertSQLState(JDBC.vmSupportsJDBC4() ? "XIE0R" : "XIE0E", e);
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:40a4584
/////////////////////////////////////////////////////////////////////////
1: 		Test test = new SupportFilesSetup(suite, new String[] {"functionTests/testData/ImportExport/TwoLineBadEOF.dat"} );
/////////////////////////////////////////////////////////////////////////
1:                 s.execute("create table T4 (   Account int,    Name   char(30), Jobdesc char(40), " +
1:                            "Company varchar(35), Address1 varchar(40), Address2 varchar(40), " +
1:                            "City    varchar(20), State   char(5), Zip char(10), Country char(10), " +
1:                            "Phone1  char(20), Phone2  char(20), email   char(30), web     char(30), " +
1:                            "Fname   char(30), Lname   char(30), Comment char(30), AccDate char(30), " +
1:                            "Payment decimal(8,2), Balance decimal(8,2))");
1:                 }
/////////////////////////////////////////////////////////////////////////
0: 			doImportFromFile(c, "extin/TwoLineBadEOF.dat" , "T4" , null , null , "US-ASCII", 0);
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:c3ff1bd
/////////////////////////////////////////////////////////////////////////
0: 			doImportFromFile(c, "extin/EndOfFile.txt" , "T4" , null , null , "US-ASCII", 0);
commit:927ad05
/////////////////////////////////////////////////////////////////////////
1: 		 //DERBY-2925: need to delete existing files first.
0:         	 SupportFilesSetup.deleteFile("extinout/" + fromTable + ".dat");
author:Suresh Thalamati
-------------------------------------------------------------------------------
commit:052d757
/////////////////////////////////////////////////////////////////////////
1: 	public void testInvalidEncoding() throws Exception {
commit:3103790
/////////////////////////////////////////////////////////////////////////
0:     /* This test is disabled temporarily due to bug : DERBY-2456 .
0:      * Remove the prefix "derby2456"  when the bug is fixed.
1:      */
0: 	public void derby2456testInvalidEncoding() throws Exception {
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:99b7123
/////////////////////////////////////////////////////////////////////////
1:         // disabled on weme6.1 due at the moment due 
1:         // to problems with security exceptions.
1:         if (JDBC.vmSupportsJSR169())
1:         {
0:         	return new TestSuite();
1:         }
commit:db2c1c2
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derbyTesting.functionTests.tests.tools.ImportExportTest
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.tests.tools;
1: 
0: import java.io.File;
0: import java.sql.Connection;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
0: import java.sql.Statement;
1: import java.sql.SQLException;
1: 
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1: import org.apache.derbyTesting.junit.JDBC;
1: import org.apache.derbyTesting.junit.SupportFilesSetup;
1: import org.apache.derbyTesting.junit.TestConfiguration;
0: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: 
1: /**
1:  * Test import and export procedures 
1:  */
1: public class ImportExportTest extends BaseJDBCTestCase {
1: 
1: 	public ImportExportTest(String name) {
1: 		super(name);
1: 	}
1: 	
1: 	public static Test suite() {
0:         TestSuite suite = new TestSuite("ImportExportTest");
1: 
0:         //if (JDBC.vmSupportsJSR169())
0:         //{
0:         //	return new TestSuite();
0:         //}
1:         suite.addTest(baseSuite("ImportExportTest:embedded"));
1: 
1:         suite.addTest(
1:                 TestConfiguration.clientServerDecorator(
1:                         baseSuite("ImportExportTest:client")));    
1:         return suite;
1: 	}
1: 	
1: 	public static Test baseSuite(String name) {
0: 		TestSuite suite = new TestSuite(ImportExportTest.class, name);
0: 		Test test = new SupportFilesSetup(suite, new String[] {"functionTests/testData/ImportExport/EndOfFile.txt"} );
1: 		return new CleanDatabaseTestSetup(test) {
1:             protected void decorateSQL(Statement s) throws SQLException {
1: 
1:                 s.execute("CREATE TABLE T1 (COLUMN1 VARCHAR(5) , COLUMN2 VARCHAR(8) , " +
1: 						   "COLUMN3 SMALLINT , COLUMN4 CHAR(11) , COLUMN5 DATE , COLUMN6 DECIMAL(5,1) , " +
1: 						   "COLUMN7 DOUBLE PRECISION , COLUMN8 INT , COLUMN9 BIGINT , COLUMN10 NUMERIC , " +
1: 						   "COLUMN11 REAL , COLUMN12 SMALLINT , COLUMN13 TIME , COLUMN14 TIMESTAMP , "+
0: 						   "COLUMN15 SMALLINT , COLUMN16 VARCHAR(1))");
1:                 s.execute("CREATE TABLE T2 (COLUMN1 VARCHAR(5) , COLUMN2 VARCHAR(8) , " +
1: 						   "COLUMN3 SMALLINT, COLUMN4 CHAR(11) , COLUMN5 DATE , COLUMN6 DECIMAL(5,1) , " +
1: 						   "COLUMN7 DOUBLE PRECISION , COLUMN8 INT , COLUMN9 BIGINT , COLUMN10 NUMERIC , " +
1: 						   "COLUMN11 REAL , COLUMN12 SMALLINT , COLUMN13 TIME , COLUMN14 TIMESTAMP , "+
0: 						   "COLUMN15 SMALLINT , COLUMN16 VARCHAR(1))");
0:                 s.execute("create table T4 (   Account int,    Fname   char(30),"+
0:                         "Lname   char(30), Company varchar(35), Address varchar(40), City    varchar(20),"+
0:  					   "State   char(5), Zip     char(10), Payment decimal(8,2), Balance decimal(8,2))");
1:                 
1:             }
1:         };
1: 	}
1: 	
1: 	public void testImportFromNonExistantFile() {
1: 		try {
0: 			Connection c = getConnection();
0: 			doImport(c, "Z" , "T1" , null , null , null, 0);
1: 		} catch (SQLException e) {
0:             // DERBY-1440: JDBC 4 client driver doesn't include nested exception SQLStates
0: 			assertSQLState(JDBC.vmSupportsJDBC4() ? "38000" : "XIE04", e);
1: 		}
1: 	}
1: 	
1: 	public void testNullDataFile() {
1: 		try {
0: 			Connection c = getConnection();
0: 			doImport(c, null, "T1" , null , null, null, 0);
1: 		} catch (SQLException e) {
0:             // DERBY-1440: JDBC 4 client driver doesn't include nested exception SQLStates
0: 			assertSQLState(JDBC.vmSupportsJDBC4() ? "38000" : "XIE05", e);
1: 		}
1: 	}
1: 	
1: 	public void testEmptyTable() throws SQLException {
0: 		Connection c = getConnection();
0: 		doImportAndExport(c, "T1", null, null , null);
1: 	}
1: 
1: 	public void testEmptyTableWithDelimitedFormat() throws SQLException {
0: 		Connection c = getConnection();
0: 		doImportAndExport(c, "T1", null, null , "8859_1");
1: 	}
1: 
1: 	public void testEmptyTableWithFieldCharDelimiters() throws SQLException {
0: 		Connection c = getConnection();
0: 		doImportAndExport(c, "T1", "\t", "|" , "8859_1");
1: 	}
1: 	
1: 	public void testWithDefaultOptions() throws Exception {
0: 		Connection c = getConnection();
0: 		resetTables();
0: 		doImportAndExport(c, "T1", null, null, null);
1: 	}
1: 	
1: 	public void testWithCodeset() throws Exception {
0: 		Connection c = getConnection();
0: 		resetTables();
0: 		doImportAndExport(c, "T1", null, null , "8859_1");
1: 	}
1: 
1: 	public void testDelimiterAndCodeset() throws Exception {
0: 		Connection c = getConnection();
0: 		resetTables();
0: 		doImportAndExport(c, "T1", "\t", "|", "8859_1");
1: 	}
1: 	
1: 	public void testSpecialDelimitersAndCodeset() throws Exception {
0: 		Connection c = getConnection();
0: 		resetTables();
0: 		doImportAndExport(c, "T1", "%", "&", "Cp1252");
1: 	}
1: 
1: 	public void testSpecialDelimitersAndUTF16() throws Exception {
0: 		Connection c = getConnection();
0: 		resetTables();
0: 		doImportAndExport(c, "T1", "%", "&", "UTF-16");
1: 	}
1: 	
0: 	public void testInvalidEncoding() throws Exception {
0: 		Connection c = getConnection();
0: 		resetTables();
1: 		try {
0: 		    doImportAndExport(c, "T1", "^", "#", "INAVALID ENCODING");
1: 		} catch (SQLException e) {
1: 			assertSQLState("XIE0I", e);
1: 		}
1: 	}
1: 	
1: 	public void testEarlyEndOfFile() throws Exception {
0: 		Connection c = getConnection();
1: 		try {
0: 			doImportFromFile(c, "extin/EndOfFile.txt" , "T4" , null , null , null, 0);
1: 		} catch (SQLException e) {
0: 			// DERBY-1440: JDBC 4 client driver doesn't include nested exception SQLStates
0: 			assertSQLState(JDBC.vmSupportsJDBC4() ? "38000" : "XIE0E", e);
1: 		}
1: 	}
1: 	
0: 	private void doImport(Connection c, String fromTable, String toTable, 
1: 			 String colDel, String charDel , 
1: 			 String codeset, int replace) throws SQLException 
1:     {
1: 		String impsql = "call SYSCS_UTIL.SYSCS_IMPORT_TABLE (? , ? , ? , ?, ? , ?, ?)";
0: 		PreparedStatement ps = c.prepareStatement(impsql);
0: 		ps.setString(1 , "APP");
1: 		ps.setString(2, toTable);
0: 		ps.setString(3, (fromTable==null ?  fromTable : "extinout/" + fromTable + ".dat" ));
1: 		ps.setString(4 , colDel);
1: 		ps.setString(5 , charDel);
1: 		ps.setString(6 , codeset);
1: 		ps.setInt(7, replace);
1: 		ps.execute();
1: 		ps.close();
1:     }
1: 	
0: 	private void doImportFromFile(Connection c, String fileName, String toTable, 
1: 			 String colDel, String charDel , 
0: 			 String codeset, int replace) throws Exception 
1:     {
1: 		String impsql = "call SYSCS_UTIL.SYSCS_IMPORT_TABLE (? , ? , ? , ?, ? , ?, ?)";
0: 		PreparedStatement ps = c.prepareStatement(impsql);
0: 		ps.setString(1 , "APP");
1: 		ps.setString(2, toTable);
1: 		ps.setString(3, fileName);
1: 		ps.setString(4 , colDel);
1: 		ps.setString(5 , charDel);
1: 		ps.setString(6 , codeset);
1: 		ps.setInt(7, replace);
1: 		ps.execute();
1: 		ps.close();
1: 
1:     }
1: 
0: 	private void doImportAndExport(Connection c, String fromTable, String colDel , 
1: 			  String charDel, 
1: 			  String codeset) throws SQLException 
1:     {
0: 		doExport(c, fromTable , colDel , charDel , codeset);
0: 		doImportAndVerify(c, fromTable, colDel , charDel, codeset,  0);
1:         // also test with replace
0: 		doImportAndVerify(c, fromTable, colDel , charDel, codeset,  1);
1:     }
1: 	
0: 	private void doExport(Connection c, String fromTable, String colDel , 
1: 			 String charDel, 
1: 			 String codeset) throws SQLException 
1: 	{
1: 		 String expsql = "call SYSCS_UTIL.SYSCS_EXPORT_TABLE (? , ? , ? , ?, ? , ?)";
0: 		 PreparedStatement ps = c.prepareStatement(expsql);
0: 		 ps.setString(1 , "APP");
1: 		 ps.setString(2, fromTable);
0: 		 ps.setString(3, (fromTable==null ?  fromTable : "extinout/" + fromTable + ".dat" ));
1: 		 ps.setString(4 , colDel);
1: 		 ps.setString(5 , charDel);
1: 		 ps.setString(6 , codeset);
1: 		 ps.execute();
1: 		 ps.close();
1:     }
1: 	
1: 	/**
1: 	 * doImportAndVerify checks that data which has been imported and
1: 	 * then exported is identical. It imports the requested data, 
1: 	 * which has been exported from T1. Row counts are compared, and
1: 	 * then the data in T2 is again exported. A bytewise comparison 
1: 	 * of the two files is then made to verify that the data has been
1: 	 * gone through the import/export process intact.
1: 	 */
0: 	private void doImportAndVerify(Connection c, String fromTable,  String colDel, 
1: 			  String charDel , String codeset, 
1: 			  int replace) throws SQLException 
1:     {
1: 
0: 		doImport(c, fromTable , "T2" , colDel , charDel , codeset , replace);
1: 
0: 		Statement stmt = c.createStatement();
0: 		ResultSet rs = stmt.executeQuery("SELECT COUNT(*) FROM " + fromTable);
1: 		rs.next();
1: 		int numberOfRowsInT1 = rs.getInt(1);
1: 		rs.close();
1: 		rs = stmt.executeQuery("SELECT COUNT(*) FROM t2");
1: 		rs.next();
1: 		int numberOfRowsInT2 = rs.getInt(1);
1: 		rs.close();
1: 		stmt.close();
1: 		assertEquals(numberOfRowsInT1, numberOfRowsInT2);
1: 
0: 		doExport(c, "T2" , colDel , charDel , codeset);
1: 
1:         //check whether the  exported files from T1 and T2  are same now.
1: 		assertEquals(SupportFilesSetup.getReadWrite(fromTable + ".dat"),
1: 				     SupportFilesSetup.getReadWrite("T2.dat"));
1:     }
1: 	
1: 	/**
0: 	 * Called from each fixture that verifies data in the table.
1: 	 * Ensures that the import and export operate on a consistent
1: 	 * set of data.
1: 	 */
1: 	private void resetTables() throws Exception {
1: 		runSQLCommands("delete from t1");
1: 		runSQLCommands("delete from t2");
1: 		runSQLCommands("INSERT INTO T1 VALUES (null,'aa',1,'a',DATE('1998-06-30'),"+
0: 		               "1,1,1,1,1,1,1,TIME('12:00:00'),TIMESTAMP('1998-06-30 12:00:00.0'),1,'a')");
1:         runSQLCommands("INSERT INTO T1 VALUES (null,'bb',1,'b',DATE('1998-06-30'),"+
0: 					   "2,2,2,2,2,2,2,TIME('12:00:00'),TIMESTAMP('1998-06-30 12:00:00.0'),2,'b')");
1:         runSQLCommands("INSERT INTO T1 VALUES (null,'cc',1,'c',DATE('1998-06-30'),"+
0: 					   "3,3,3,3,3,3,3,TIME('12:00:00'),TIMESTAMP('1998-06-30 12:00:00.0'),3,'c')");
1:         runSQLCommands("INSERT INTO T1 VALUES (null,'dd',1,'d',DATE('1998-06-30'),"+
0: 					   "4,4,4,4,4,4,4,TIME('12:00:00'),TIMESTAMP('1998-06-30 12:00:00.0'),4,'d')");
1: 	}
1: 
1: }
============================================================================