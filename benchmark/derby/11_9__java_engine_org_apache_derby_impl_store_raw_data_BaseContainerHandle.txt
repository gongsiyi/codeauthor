1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.store.raw.data.BaseContainerHandle
1:345de35: 
1:270a34d:    Licensed to the Apache Software Foundation (ASF) under one or more
1:270a34d:    contributor license agreements.  See the NOTICE file distributed with
1:270a34d:    this work for additional information regarding copyright ownership.
1:270a34d:    The ASF licenses this file to you under the Apache License, Version 2.0
1:270a34d:    (the "License"); you may not use this file except in compliance with
1:270a34d:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
9:eac0369: 
5:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.store.raw.data;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.reference.SQLState;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.locks.Lockable;
1:eac0369: import org.apache.derby.iapi.services.locks.VirtualLockTable;
1:a12152a: import org.apache.derby.iapi.services.monitor.DerbyObservable;
1:a12152a: import org.apache.derby.iapi.services.monitor.DerbyObserver;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: import org.apache.derby.iapi.store.access.SpaceInfo;
1:eac0369: import org.apache.derby.iapi.store.raw.ContainerHandle;
1:eac0369: import org.apache.derby.iapi.store.raw.ContainerLock;
1:eac0369: import org.apache.derby.iapi.store.raw.LockingPolicy;
1:eac0369: import org.apache.derby.iapi.store.raw.Page;
1:eac0369: import org.apache.derby.iapi.store.raw.PageKey;
1:eac0369: import org.apache.derby.iapi.store.raw.PageTimeStamp;
1:eac0369: import org.apache.derby.iapi.store.raw.RecordHandle;
1:eac0369: import org.apache.derby.iapi.store.raw.ContainerKey;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.raw.data.RawContainerHandle;
1:eac0369: import org.apache.derby.iapi.store.raw.xact.RawTransaction;
1:eac0369: import org.apache.derby.iapi.store.raw.log.LogInstant;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.util.ByteArray;
1:eac0369: import org.apache.derby.catalog.UUID;
1:eac0369: 
1:eac0369: import java.util.Hashtable;
1:eac0369: import java.util.Properties;
1:eac0369: 
4:eac0369: /**
1:eac0369: 	A handle to an open container, implememts RawContainerHandle.
1:eac0369: 	<P>
1:a12152a: 	This class is a DerbyObserver to observe RawTransactions
1:a12152a: 	and is also a DerbyObservable to
1:eac0369: 	handle the list of pages accessed thorough this handle.
1:eac0369: 	<BR>
1:eac0369: 	This class implements Lockable (defined to be ContainerHandle) and is
1:eac0369: 	the object used to logically lock the container.
1:eac0369: 
1:eac0369: 	<BR> MT - Mutable - Immutable identity - Thread Aware
1:eac0369: */
1:eac0369: 
1:a12152a: public class BaseContainerHandle extends DerbyObservable 
1:a12152a:     implements RawContainerHandle, DerbyObserver 
3:eac0369: {
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Fields
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Container identifier
1:eac0369: 		<BR> MT - Immutable
1:eac0369: 	*/
1:3fb9515: 	private /*final*/ ContainerKey		identity;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Is this ContainerHandle active.
1:eac0369: 
1:eac0369: 		<BR> MT - Mutable : scoped
1:eac0369: 	*/
1:3fb9515: 	private boolean				        active;	
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		The actual container we are accessing. Only valid when active is true.
1:eac0369: 
1:eac0369: 		<BR> MT - Mutable : scoped
1:eac0369: 	*/
1:3fb9515: 	protected BaseContainer		        container;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		the locking policy we opened the container with. 
1:eac0369:         Only valid when active is true.
1:eac0369: 
1:eac0369: 		<BR> MT - Mutable : scoped
1:eac0369: 	*/
1:eac0369: 
1:3fb9515: 	private	LockingPolicy		        locking;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		our transaction. Only valid when active is true.
1:eac0369: 
1:eac0369: 		<BR> MT - Mutable : scoped
1:eac0369: 	*/
1:3fb9515: 	private	RawTransaction		        xact;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		are we going to update?
1:eac0369: 
1:eac0369: 		<BR> MT - Immutable after container handle becomes active
1:eac0369: 	*/
1:3fb9515: 	private	boolean		                forUpdate;
1:eac0369: 
1:eac0369: 
1:3fb9515:     /**
1:3fb9515:      * mode the conainter was opened in.
1:3fb9515:      **/
1:3fb9515: 	private int                         mode;
1:3fb9515: 
1:3fb9515: 
1:3fb9515: 	private PageActions		            actionsSet;
1:3fb9515: 	private AllocationActions           allocActionsSet;
1:eac0369: 
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Constructor
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Create an object that is only used for locking the container.
1:eac0369: 	*/
1:eac0369: 	public BaseContainerHandle(UUID rawStoreId, RawTransaction xact,
1:eac0369: 		ContainerKey identity, LockingPolicy locking, int mode) 
1:eac0369:     {
1:eac0369: 		this.identity = identity;
1:eac0369: 		this.xact = xact;
1:eac0369: 		this.locking = locking;
1:eac0369: 		this.mode = mode;
1:eac0369: 		this.forUpdate = (mode & MODE_FORUPDATE) == MODE_FORUPDATE;
3:eac0369: 	}
1:ae71c74: 
1:ae71c74: 	/**
1:eac0369: 		Create a container handle that is used to actually access the container.
1:25f99f5: 	*/
1:eac0369: 	public BaseContainerHandle(
1:eac0369:     UUID                rawStoreId, 
1:eac0369:     RawTransaction      xact,
1:eac0369:     PageActions         actionsSet, 
1:eac0369:     AllocationActions   allocActionsSet, 
1:eac0369:     LockingPolicy       locking,
1:eac0369: 	BaseContainer       container, 
1:eac0369:     int                 mode)
1:eac0369: 	{
1:eac0369: 		this(rawStoreId, xact, 
1:eac0369:                 (ContainerKey) container.getIdentity(), locking, mode);
1:ae71c74: 
1:eac0369: 
1:eac0369: 		this.actionsSet      = actionsSet;
1:eac0369: 		this.allocActionsSet = allocActionsSet;
1:eac0369: 		this.container       = container;
1:eac0369: 
1:eac0369: 		// we are inactive until useContainer is called.
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Methods from ContainerHandle
1:d376440: 	*/
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Add a page to the container
1:eac0369: 		The page returned will be observing me.
1:eac0369: 
1:eac0369: 		@see BaseContainer#addPage
1:eac0369: 		@see ContainerHandle#addPage
1:94f158a: 		@exception StandardException Standard Derby error policy
1:eac0369: 	*/
1:eac0369: 	public Page addPage() throws StandardException 
1:eac0369:     {
1:eac0369: 		checkUpdateOpen();
1:eac0369: 
1:eac0369: 		Page page = container.addPage(this, false /* not an overflow page */);
1:eac0369: 			
1:eac0369: 		return page;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:bbc927c: 		Release free space to the OS.
1:bbc927c: 		<P>
1:bbc927c:         As is possible release any free space to the operating system.  This
1:bbc927c:         will usually mean releasing any free pages located at the end of the
1:bbc927c:         file using the java truncate() interface.
1:bbc927c: 
1:94f158a: 		@exception StandardException	Standard Derby error policy
1:bbc927c: 	*/
1:bbc927c: 	public void compressContainer() throws StandardException 
1:bbc927c:     {
1:bbc927c: 		checkUpdateOpen();
1:bbc927c: 
1:bbc927c: 		container.compressContainer(this);
1:bbc927c: 	}
1:bbc927c: 
1:bbc927c: 	/**
1:d376440: 	 * Get the reusable recordId sequence number.
1:d376440: 	 * @return version sequence number
1:ae71c74: 	 * @exception StandardException	Standard Derby error policy
1:d376440: 	 * @see ContainerHandle#getReusableRecordIdSequenceNumber
1:ae71c74: 	 */
1:d376440: 	public long getReusableRecordIdSequenceNumber() throws StandardException
1:ae71c74: 	{
1:d376440: 		checkOpen();
1:d376440: 		
1:d376440: 		return container.getReusableRecordIdSequenceNumber();
1:d376440: 	}
1:d376440: 
1:d376440: 	/**
1:eac0369: 		Add a page to the container, if flag == ContainerHandle.ADD_PAGE_BULK,
1:eac0369: 		tell the container about it.
1:eac0369: 
1:eac0369: 		The page returned will be observing me.
1:eac0369: 
1:eac0369: 		@see BaseContainer#addPage
1:eac0369: 		@see ContainerHandle#addPage
1:94f158a: 		@exception StandardException Standard Derby error policy
1:eac0369: 	*/
1:eac0369: 	public Page addPage(int flag) throws StandardException {
1:eac0369: 
1:eac0369: 		if ((flag & ContainerHandle.ADD_PAGE_BULK) != 0 && active && forUpdate)
1:d376440: 		{
1:eac0369: 			// start preallocating immediatelly, don't wait for the
1:eac0369: 			// preallocation threshold to be crossed.  Don't go wild and
1:eac0369: 			// preallocate a bunch of pages either, use preAllocate for that. 
1:eac0369: 			container.clearPreallocThreshold();
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return addPage();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Preallocate numPage if possible.
1:eac0369: 	*/
1:eac0369: 	public void preAllocate(int numPage)
1:eac0369: 	{
1:eac0369: 		if (numPage > 0 && active && forUpdate)
1:eac0369: 			container.prepareForBulkLoad(this, numPage);
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Request the system properties associated with a container. 
1:eac0369:      * <p>
1:eac0369:      * Request the value of properties that are associated with a container.  
1:eac0369:      * The following properties can be requested:
1:eac0369:      *     derby.storage.pageSize 
1:eac0369:      *     derby.storage.pageReservedSpace
1:eac0369:      *     derby.storage.minimumRecordSize
1:eac0369:      * <p>
1:eac0369:      * To get the value of a particular property add it to the property list,
1:eac0369:      * and on return the value of the property will be set to it's current 
1:eac0369:      * value.  For example:
1:eac0369:      *
1:eac0369:      * get_prop(BaseContainerHandle ch)
1:eac0369:      * {
1:eac0369:      *     Properties prop = new Properties();
1:eac0369:      *     prop.put("derby.storage.pageSize", "");
1:eac0369:      *     ch.getContainerProperties(prop);
1:eac0369:      *
1:eac0369:      *     System.out.println(
1:eac0369:      *         "conatainer's page size = " + 
1:eac0369:      *         prop.getProperty("derby.storage.pageSize");
1:eac0369:      * }
1:eac0369:      *
1:eac0369:      * @param prop   Property list to fill in.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     public void getContainerProperties(Properties prop)
1:eac0369: 		throws StandardException
1:eac0369:     {
1:eac0369: 		checkOpen();
1:eac0369: 
1:eac0369:         container.getContainerProperties(prop);
1:eac0369: 
1:eac0369:         return;
1:eac0369:     }
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Remove a page from the container.  
1:eac0369: 
1:eac0369: 		@see ContainerHandle#removePage
1:94f158a: 		@exception StandardException Standard Derby error policy
1:eac0369: 	*/
1:eac0369: 	public void removePage(Page page) throws StandardException
1:eac0369: 	{
1:eac0369: 		if (!active)
1:eac0369: 		{
1:eac0369: 			if (page != null)
1:eac0369: 				page.unlatch();
1:eac0369: 			throw StandardException.newException(
1:eac0369:                     SQLState.DATA_CONTAINER_CLOSED);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (!forUpdate)
1:eac0369: 		{
1:eac0369: 			if (page != null)
1:eac0369: 				page.unlatch();
1:eac0369: 			throw StandardException.newException(
1:eac0369:                     SQLState.DATA_CONTAINER_READ_ONLY);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		container.removePage(this, (BasePage)page);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public Page getPage(long pageNumber) throws StandardException 
1:eac0369:     {
1:eac0369: 
1:eac0369: 		checkOpen();
1:eac0369: 
1:eac0369: 		return container.getPage(this, pageNumber, true);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	public Page getAllocPage(long pageNumber) throws StandardException 
1:eac0369:     {
1:eac0369: 		checkOpen();
1:eac0369: 
1:eac0369: 		return container.getAllocPage(this, pageNumber, true);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public Page getUserPageNoWait(long pageNumber) 
1:eac0369:         throws StandardException 
1:eac0369:     {
1:eac0369: 		checkOpen();
1:eac0369: 
1:eac0369: 		return container.getHeadPage(this, pageNumber, false);
1:eac0369: 	}
1:eac0369: 	public Page getUserPageWait(long pageNumber) 
1:eac0369:         throws StandardException 
1:eac0369:     {
1:eac0369: 		checkOpen();
1:eac0369: 
1:eac0369: 		return container.getHeadPage(this, pageNumber, true);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public Page getPageNoWait(long pageNumber) 
1:eac0369:         throws StandardException 
1:eac0369:     {
1:eac0369: 		checkOpen();
1:eac0369: 
1:eac0369: 		return container.getPage(this, pageNumber, false);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public Page getFirstPage() throws StandardException 
1:eac0369:     {
1:eac0369: 		checkOpen();
1:eac0369: 
1:eac0369: 		return container.getFirstPage(this);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public Page getNextPage(long pageNumber) throws StandardException 
1:eac0369:     {
1:eac0369: 		checkOpen();
1:eac0369: 
1:eac0369: 		return container.getNextPage(this, pageNumber);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public Page getPageForInsert(int flag) 
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369: 		checkUpdateOpen();
1:eac0369: 
1:eac0369: 		return container.getPageForInsert(this, flag);
1:eac0369: 	}
1:eac0369: 
1:bbc927c: 	public Page getPageForCompress(int flag, long pageno) 
1:bbc927c: 		 throws StandardException
1:bbc927c: 	{
1:bbc927c: 		checkUpdateOpen();
1:bbc927c: 
1:bbc927c: 		return container.getPageForCompress(this, flag, pageno);
1:bbc927c: 	}
1:bbc927c: 
1:eac0369: 	/**
1:eac0369: 		@see ContainerHandle#isReadOnly()
1:eac0369: 	*/
1:eac0369:     public final boolean isReadOnly()
1:eac0369:     {
1:eac0369:         return(!forUpdate);
1:eac0369:     }
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		@see ContainerHandle#close
1:eac0369: 	*/
1:eac0369: 
1:3fb9515: 	public synchronized void close() 
1:eac0369:     {
1:3fb9515:         // Close may be called by multiple threads concurrently, for
1:3fb9515:         // instance it can be called automatically after an abort and
1:3fb9515:         // explicitly by a client.  Depending on timing of machine
1:3fb9515:         // these calls may happen concurrently.  Thus close needs to
1:3fb9515:         // be synchronized.  
1:3fb9515:         //
1:3fb9515:         // Another example is that we may hand out an indirect reference
1:3fb9515:         // to clients outside of JDBC through an OverFlowInputStream.  
1:3fb9515:         // Derby code cannot control when clients may close those 
1:3fb9515:         // streams with respect to implicit closes by abort.
1:eac0369: 
1:eac0369:         if (xact == null) 
1:eac0369:         {
1:eac0369:             return;
1:eac0369:         }
1:eac0369: 
1:3fb9515:         // notify our observers (Pages) that we are closing ...
1:3fb9515:         informObservers();
1:eac0369: 
1:3fb9515:         active = false;
1:eac0369: 
1:3fb9515:         getLockingPolicy().unlockContainer(xact, this);
1:eac0369: 
1:3fb9515:         // let go of the container
1:3fb9515:         if (container != null) 
1:eac0369:         {
1:3fb9515:             container.letGo(this);
1:3fb9515:             container = null;
1:3fb9515:         }
1:eac0369: 
1:3fb9515:         // and remove ourseleves from this transaction
1:eac0369:         xact.deleteObserver(this);
1:eac0369: 
1:3fb9515:         xact = null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/* cost estimation */
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		@see ContainerHandle#getEstimatedRowCount
1:94f158a: 		@exception StandardException Standard Derby error policy
1:eac0369: 	 */
1:eac0369: 	public long getEstimatedRowCount(int flag) throws StandardException
1:eac0369: 	{
1:eac0369: 		checkOpen();
1:eac0369: 
1:eac0369: 		return container.getEstimatedRowCount(flag);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		@see ContainerHandle#setEstimatedRowCount
1:94f158a: 		@exception StandardException Standard Derby error policy
1:eac0369: 	 */
1:eac0369: 	public void setEstimatedRowCount(long count, int flag) 
1:eac0369:         throws StandardException
1:eac0369: 	{
1:eac0369: 		checkOpen();
1:eac0369: 
1:eac0369: 		container.setEstimatedRowCount(count, flag);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		@see ContainerHandle#getEstimatedPageCount
1:94f158a: 		@exception StandardException Standard Derby error policy
1:eac0369: 	 */
1:eac0369: 	public long getEstimatedPageCount(int flag) 
1:eac0369:         throws StandardException
1:eac0369: 	{
1:eac0369: 		checkOpen();
1:eac0369: 
1:eac0369: 		return container.getEstimatedPageCount(this, flag);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		@see ContainerHandle#flushContainer
1:94f158a: 		@exception StandardException Standard Derby error policy
1:eac0369: 	 */
1:eac0369: 	public void flushContainer() 
1:eac0369:         throws StandardException
1:eac0369: 	{
1:eac0369: 		checkUpdateOpen();
1:eac0369: 
1:eac0369: 		// raw store may override unlog mode when log is Archived.
1:eac0369: 		// if ((mode & MODE_CREATE_UNLOGGED) == 0)
1:eac0369: 		//	throw StandardException.newException(
1:eac0369:         //	    SQLState.DATA_NOT_CREATE_UNLOGGED, identity);
1:eac0369: 
1:eac0369: 		container.flushAll();
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		@see ContainerHandle#compactRecord
1:94f158a: 		@exception StandardException Standard Derby error policy
1:eac0369: 	 */
1:eac0369: 	public void compactRecord(RecordHandle record) 
1:eac0369:         throws StandardException
1:eac0369: 	{
1:eac0369: 		if (!forUpdate)
1:eac0369:         {
1:eac0369: 			throw StandardException.newException(
1:eac0369:                     SQLState.DATA_CONTAINER_READ_ONLY);
1:eac0369:         }
1:eac0369: 
1:eac0369: 		PageKey pkey = (PageKey)record.getPageId();
1:eac0369: 		BasePage headPage = (BasePage)getPage(pkey.getPageNumber());
1:eac0369: 
1:eac0369: 		if (headPage != null)
1:eac0369: 		{
1:eac0369: 			// The page could have been null if it was deallocated after the
1:eac0369: 			// row lock is gotten.  We are doing all of these post commit so
1:eac0369: 			// the record may not even be there and we got a lock for nothing.
1:eac0369: 			try
1:eac0369: 			{
1:eac0369: 				headPage.compactRecord(record);
1:eac0369: 			}
1:eac0369: 			finally
1:eac0369: 			{
1:eac0369: 				headPage.unlatch();
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Methods of RawContainerHandle - methods are called underneath the log
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Get the container status.  
1:eac0369: 
1:94f158a: 		@exception StandardException Standard Derby error policy		
1:eac0369: 		@see RawContainerHandle#getContainerStatus
1:eac0369: 	*/
1:eac0369: 	public int getContainerStatus() throws StandardException
1:eac0369: 	{
1:eac0369: 		checkOpen();
1:eac0369: 
1:eac0369: 		return container.getContainerStatus();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		remove the container
1:eac0369: 
1:94f158a: 		@exception StandardException Standard Derby error policy		
1:eac0369: 		@see RawContainerHandle#removeContainer
1:eac0369: 	*/
1:eac0369: 	public void removeContainer(LogInstant instant) throws StandardException
1:eac0369: 	{
1:eac0369: 		checkUpdateOpen();
1:eac0369: 
1:eac0369: 		// This call can only be issued by within rawStore.
1:eac0369: 		// while the container is dropped, no client of raw store
1:eac0369: 		// should be able to access the container (it is 
1:eac0369: 		// exclusively locked).  
1:eac0369: 		// Then as postcommit processing, 
1:eac0369: 		// the container iw 
1:eac0369: 
1:eac0369: 		container.removeContainer(instant, true);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		@see ContainerHandle#getId
1:eac0369: 	 */
1:eac0369: 	public ContainerKey getId()
1:eac0369: 	{
1:eac0369: 		return identity;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		@see ContainerHandle#getUniqueId
1:eac0369: 	 */
1:eac0369: 	public Object getUniqueId()
1:eac0369: 	{
1:eac0369:         return(this);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:94f158a: 		@exception StandardException  Standard Derby exception policy
1:eac0369: 		@see RawContainerHandle#dropContainer
1:eac0369: 	*/
1:eac0369: 	public void dropContainer(LogInstant instant, boolean drop) 
1:eac0369:         throws StandardException
1:eac0369: 	{
1:eac0369: 		checkUpdateOpen();
1:eac0369: 
1:eac0369: 		container.dropContainer(instant, drop);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:94f158a: 		@exception StandardException  Standard Derby exception policy
1:eac0369: 		@see RawContainerHandle#getContainerVersion
1:eac0369: 	*/
1:eac0369: 	public long getContainerVersion() 
1:eac0369:         throws StandardException
1:eac0369: 	{
1:eac0369: 		checkOpen();
1:eac0369: 
1:eac0369: 		return container.getContainerVersion();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Get this page with no check - any page type or status is fine.
1:eac0369: 		Caller must be prepared to handle freed, deallocated,or alloc page
1:eac0369: 		Called by recovery ONLY.
1:eac0369: 
1:94f158a: 		@exception StandardException Derby Standard error policy
1:eac0369: 	*/
1:eac0369: 	public Page getAnyPage(long pageNumber) throws StandardException
1:eac0369: 	{
1:eac0369: 		checkOpen();
1:eac0369: 
1:eac0369: 		return container.getAnyPage(this, pageNumber, true /* wait */);
1:eac0369: 	}
1:eac0369: 
1:f57b07d:     /**
1:f57b07d:      * ReCreate a page for rollforward recovery.  
1:f57b07d:      * <p>
1:f57b07d:      * During redo recovery it is possible for the system to try to redo
1:f57b07d:      * the creation of a page (ie. going from non-existence to version 0).
1:f57b07d:      * It first trys to read the page from disk, but a few different types
1:f57b07d:      * of errors can occur:
1:f57b07d:      *     o the page does not exist at all on disk, this can happen during
1:f57b07d:      *       rollforward recovery applied to a backup where the file was
1:f57b07d:      *       copied and the page was added to the file during the time frame
1:f57b07d:      *       of the backup but after the physical file was copied.
1:f57b07d:      *     o space in the file exists, but it was never initalized.  This
1:f57b07d:      *       can happen if you happen to crash at just the right moment during
1:f57b07d:      *       the allocation process.  Also
1:f57b07d:      *       on some OS's it is possible to read from a part of the file that
1:f57b07d:      *       was not ever written - resulting in garbage from the store's 
1:f57b07d:      *       point of view (often the result is all 0's).  
1:f57b07d:      *
1:f57b07d:      * All these errors are easy to recover from as the system can easily 
1:f57b07d:      * create a version 0 from scratch and write it to disk.
1:f57b07d:      *
1:f57b07d:      * Because the system does not sync allocation of data pages, it is also
1:f57b07d:      * possible at this point that whlie writing the version 0 to disk to 
1:f57b07d:      * create it we may encounter an out of disk space error (caught in this
1:f57b07d:      * routine as a StandardException from the create() call.  We can't 
1:f57b07d:      * recovery from this without help from outside, so the caught exception
1:f57b07d:      * is nested and a new exception thrown which the recovery system will
1:f57b07d:      * output to the user asking them to check their disk for space/errors.
1:f57b07d:      *
1:f57b07d: 	 * @exception  StandardException  Standard exception policy.
1:f57b07d:      **/
1:f57b07d: 	public Page reCreatePageForRedoRecovery(
1:eac0369:     int     pageFormat,
1:eac0369:     long    pageNumber, 
1:eac0369:     long    pageOffset)
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369: 		checkUpdateOpen();
1:eac0369: 
1:f57b07d: 		return container.reCreatePageForRedoRecovery(
1:eac0369: 					this, pageFormat, pageNumber, pageOffset);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Log all information necessary to recreate the container during a load
1:eac0369: 		tran.
1:eac0369: 
1:94f158a: 		@exception StandardException Standard Derby error policy
1:eac0369: 	 */
1:eac0369: 	public ByteArray logCreateContainerInfo() 
1:eac0369:         throws StandardException
1:eac0369: 	{
1:eac0369: 		checkUpdateOpen();
1:eac0369: 
1:eac0369: 		return container.logCreateContainerInfo();
1:eac0369: 	}
1:eac0369: 	
1:eac0369: 	/**
1:eac0369: 		Return a record handle that is initialized to the given page number and
1:eac0369:         record id.
1:eac0369: 
1:94f158a: 		@exception StandardException Standard Derby exception policy.
1:eac0369: 
1:eac0369: 		@param pageNumber   the page number of the RecordHandle.
1:eac0369: 		@param recordId     the record id of the RecordHandle.
1:eac0369: 
1:eac0369: 		@see RecordHandle
1:eac0369: 	*/
1:eac0369: 	public RecordHandle makeRecordHandle(long pageNumber, int recordId)
1:eac0369: 		 throws	StandardException
1:eac0369:     {
1:eac0369:         return new RecordId(identity, pageNumber, recordId);
1:eac0369:     }
1:eac0369: 
1:eac0369: 
1:eac0369: 	/*
1:a12152a: 	**	Methods of DerbyObserver
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Called when the transaction is about to complete.
1:eac0369: 
1:d21039a: 		@see DerbyObserver#update
1:eac0369: 	*/
1:a12152a: 	public void update(DerbyObservable obj, Object arg) 
1:eac0369:     {
3:eac0369: 		if (SanityManager.DEBUG) 
1:eac0369:         {
1:eac0369: 			if (arg == null)
1:eac0369: 				SanityManager.THROWASSERT("still on observr list " + this);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// already been removed from the list
1:eac0369: 		if (xact == null) 
1:eac0369:         {
1:eac0369: 			return;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG) 
1:eac0369:         {
1:eac0369: 			// just check reference equality
1:eac0369: 
1:eac0369: 			if (obj != xact)
1:eac0369:             {
1:eac0369: 				SanityManager.THROWASSERT(
1:eac0369:                     "Observable passed to update is incorrect expected " + 
1:eac0369:                     xact + " got " + obj);
1:eac0369:             }
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// close on a commit, abort or drop of this container.
1:eac0369: 		if (arg.equals(RawTransaction.COMMIT) || 
1:eac0369:             arg.equals(RawTransaction.ABORT)  || 
1:eac0369:             arg.equals(identity)) 
1:eac0369:         {
1:eac0369: 			// close the container		
1:eac0369: 			close();
1:eac0369: 			return;
1:eac0369: 
1:eac0369: 		}
1:eac0369: 		
1:eac0369: 		if (arg.equals(RawTransaction.SAVEPOINT_ROLLBACK)) 
1:eac0369:         {
1:eac0369: 
1:eac0369: 			// unlatch any pages but remain open
2:eac0369: 			informObservers();
1:eac0369: 
1:eac0369: 			// remain open
1:eac0369: 			return;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// Transaction is notifying us that our container
1:eac0369: 		// has undergone some lock escalation. We re-get
1:eac0369: 		// our table lock which will promote us 
1:eac0369: 		// if possible
1:eac0369: 		
1:eac0369: 		if (arg.equals(RawTransaction.LOCK_ESCALATE)) 
1:eac0369:         {
1:eac0369: 
1:eac0369: 			// only attempt escalation on RowLocking modes.
1:eac0369: 			if (getLockingPolicy().getMode() != LockingPolicy.MODE_RECORD)
1:eac0369: 				return;
1:eac0369: 
1:eac0369: 			try 
1:eac0369:             {
1:eac0369: 				getLockingPolicy().lockContainer(
1:eac0369:                     getTransaction(), this, false, forUpdate);
1:eac0369: 			} 
1:eac0369:             catch (StandardException se) 
1:eac0369:             {
1:eac0369: 				xact.setObserverException(se);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Implementation specific methods, these are public so that they can be 
1:eac0369:     ** called in other packages that are specific implementations of Data, ie.
1:eac0369: 	** a directory at the level
1:eac0369: 	**
1:eac0369: 	** com.ibm.db2j.impl.Database.Storage.RawStore.Data.*
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	public PageActions getActionSet() 
1:eac0369:     {
1:eac0369: 		return actionsSet;
1:eac0369: 	}
1:eac0369: 	
1:eac0369: 	public AllocationActions getAllocationActionSet() 
1:eac0369:     {
1:eac0369: 		return allocActionsSet;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Attach me to a container. If this method returns false then
1:eac0369: 		I cannot be used anymore, and any reference to me must be discarded.
1:eac0369: 
1:eac0369: 		@param droppedOK if true, use this container even if it is dropped,
1:eac0369: 		otherwise, return false if container is dropped.  
1:eac0369: 
1:eac0369: 		@param waitForLock if true, wait on lock, otherwise, get lock no wait.
1:eac0369: 
1:94f158a: 		@exception StandardException Standard Derby error policy
1:eac0369: 	*/
1:eac0369: 	public boolean useContainer(
1:eac0369:     boolean droppedOK, 
1:eac0369:     boolean waitForLock) 
1:eac0369:         throws StandardException 
1:eac0369:     {
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG) 
1:eac0369:         {
2:eac0369: 			SanityManager.ASSERT(!active);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		boolean gotLock = 
1:eac0369: 			getLockingPolicy().lockContainer(
1:eac0369:                 getTransaction(), this, waitForLock, forUpdate);
1:eac0369: 
1:eac0369: 		if (gotLock == false)
1:eac0369: 		{
1:eac0369: 			// this is a lockingPolicy error, if waitForLock should either 
1:eac0369: 			// return true or throw a deadlock exception
1:eac0369: 			if (SanityManager.DEBUG)
1:eac0369: 				SanityManager.ASSERT(waitForLock == false, 
1:eac0369: 					"lockContainer wait returns false");
1:eac0369: 
2:eac0369: 			container = null;
1:eac0369: 
1:eac0369:             throw StandardException.newException(SQLState.LOCK_TIMEOUT);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if ((mode & ContainerHandle.MODE_OPEN_FOR_LOCK_ONLY) == 0) 
1:eac0369:         {
1:eac0369: 
1:eac0369: 			if (SanityManager.DEBUG) 
1:eac0369:             {
1:eac0369: 				SanityManager.ASSERT(container != null);
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			if (!container.use(this, forUpdate, droppedOK)) 
1:eac0369:             {
1:eac0369: 
1:eac0369:                 // If we got a lock, but for some reason we can't open the
1:eac0369:                 // table (like it doesn't exist), then call unlockContainer().
1:eac0369:                 // In the normal case it would be called when the container
1:eac0369:                 // handle was closed, but in this case the user is never going
1:eac0369:                 // to get an "open" container handle back.  We can't call 
1:eac0369:                 // close() here as we haven't done all the "open" stuff.
2:eac0369:                 getLockingPolicy().unlockContainer(xact, this);
1:eac0369: 
1:eac0369: 				container = null;
1:eac0369: 
1:eac0369: 				return false;
1:eac0369: 			}
1:eac0369: 			active = true;
1:eac0369: 		} 
1:eac0369:         else 
1:eac0369:         {
1:eac0369: 			// lock only, we only observe the transaction if
1:eac0369: 			// we are performing row level locking.
1:eac0369: 			if (getLockingPolicy().getMode() != LockingPolicy.MODE_RECORD)
1:eac0369: 				return true;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// watch transaction so we will close handle just before xact completes.
1:eac0369: 		xact.addObserver(this);
1:eac0369: 
1:eac0369: 
1:eac0369: 		// Add special objects implementing certain behaviour at commit/rollback
1:eac0369: 
1:eac0369: 		if ((mode & (ContainerHandle.MODE_READONLY | 
1:eac0369:                      ContainerHandle.MODE_NO_ACTIONS_ON_COMMIT)) == 0) 
1:eac0369:         {
1:eac0369: 			if ((mode & MODE_TRUNCATE_ON_COMMIT) == MODE_TRUNCATE_ON_COMMIT) 
1:eac0369:             {
1:eac0369: 				xact.addObserver(
1:eac0369:                     new TruncateOnCommit(identity, true /* always */));
1:eac0369: 			} 
1:eac0369:             else if ((mode & MODE_TRUNCATE_ON_ROLLBACK) == 
1:eac0369:                                         MODE_TRUNCATE_ON_ROLLBACK) 
1:eac0369:             {
1:eac0369: 				xact.addObserver(
1:eac0369:                     new TruncateOnCommit(identity, false /* rollbacks only */));
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			if ((mode & MODE_DROP_ON_COMMIT) == MODE_DROP_ON_COMMIT) 
1:eac0369:             {
1:eac0369: 				xact.addObserver(new DropOnCommit(identity));				
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			if ((mode & MODE_FLUSH_ON_COMMIT) == MODE_FLUSH_ON_COMMIT) 
1:eac0369:             {
1:eac0369: 				xact.addObserver(new SyncOnCommit(identity));
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return true;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Return the RawTransaction I was opened in.
1:eac0369: 	*/
1:eac0369: 	public final RawTransaction getTransaction() 
1:eac0369:     {
1:eac0369: 		return xact;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Return my locking policy, may be different from the Transaction's
1:eac0369: 		default locking policy.
1:eac0369: 	*/
1:eac0369: 	public final LockingPolicy getLockingPolicy() 
1:eac0369:     {
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG) 
1:eac0369:         {
1:eac0369: 			SanityManager.ASSERT(locking != null);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return locking;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public final void setLockingPolicy(LockingPolicy newLockingPolicy) 
1:eac0369:     {
1:eac0369: 		locking = newLockingPolicy;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Was I opened for updates?
1:20bc69f:         <p>
1:eac0369: 
1:eac0369: 		<BR> MT - thread safe
1:eac0369: 	*/
1:eac0369: 	public final boolean updateOK() 
1:eac0369:     {
1:eac0369: 		return forUpdate;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Get the mode I was opened with.
1:eac0369: 	*/
1:eac0369: 	public int getMode() 
1:eac0369:     {
1:eac0369: 		return mode;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	   The container is about to be modified.
1:eac0369: 	   Loggable actions use this to make sure the container gets cleaned if a
1:eac0369: 	   checkpoint is taken after any log record is sent to the log stream but
1:eac0369: 	   before the container is actually dirtied.
1:eac0369: 
1:94f158a: 		@exception StandardException Standard Derby error policy
1:eac0369: 	 */
1:eac0369: 	public void preDirty(boolean preDirtyOn) throws StandardException 
1:eac0369:     {
1:eac0369: 
1:eac0369: 		checkUpdateOpen();
1:eac0369: 
1:eac0369: 		container.preDirty(preDirtyOn);
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		@see ContainerHandle#isTemporaryContainer
1:94f158a: 		@exception StandardException Standard Derby error policy
1:eac0369: 	 */
1:eac0369: 	public boolean isTemporaryContainer() throws StandardException 
1:eac0369:     {
1:eac0369: 
1:eac0369: 		checkOpen();
1:eac0369: 
1:eac0369: 		return (identity != null && 
1:eac0369: 				identity.getSegmentId() == ContainerHandle.TEMPORARY_SEGMENT);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Implementation specific methods for myself and my sub-classes
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	protected void checkOpen() throws StandardException 
1:eac0369:     {
1:eac0369: 		if (!active)
1:eac0369: 			throw StandardException.newException(
1:eac0369:                     SQLState.DATA_CONTAINER_CLOSED);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369:     private void checkUpdateOpen() throws StandardException 
1:eac0369:     {
1:eac0369: 
1:eac0369: 		if (!active)
1:eac0369:         {
1:eac0369: 			throw StandardException.newException(
1:eac0369:                     SQLState.DATA_CONTAINER_CLOSED);
1:eac0369:         }
1:eac0369: 
1:eac0369: 		if (!forUpdate)
1:eac0369:         {
1:eac0369: 			throw StandardException.newException(
1:eac0369:                     SQLState.DATA_CONTAINER_READ_ONLY);
1:eac0369:         }
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	protected void informObservers() 
1:eac0369:     {
1:eac0369: 
1:eac0369: 		// notify our observers (Pages) that we are closing, 
1:eac0369:         // or undergoing some state change ...
1:eac0369: 
1:eac0369: 		if (countObservers() != 0) 
1:eac0369:         {
1:eac0369: 			setChanged();
1:eac0369: 			notifyObservers();
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369:     /**
1:eac0369:     Get information about space used by the container.
1:eac0369:     **/
1:eac0369:     public SpaceInfo getSpaceInfo()
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         return container.getSpaceInfo(this);
1:eac0369:     }
1:25f99f5: 
1:eac0369: 
1:25f99f5: 	/**
1:bf643fd:      * Backup the container to the specified path.
1:be3e2aa:      * @param backupContainerPath  location of the backup container.
1:bf643fd: 	 *  @exception StandardException	Standard Derby error policy
1:bf643fd:      */
1:25f99f5: 	public void backupContainer(String backupContainerPath) throws StandardException 
1:25f99f5:     {
1:25f99f5: 		checkOpen();
1:25f99f5: 		container.backupContainer(this, backupContainerPath);
1:25f99f5: 	}
1:25f99f5: 
1:ae71c74: 
1:eac0369: 
1:89a6625:     /** {@inheritDoc} */
1:89a6625:     public void encryptOrDecryptContainer(String newFilePath, boolean doEncrypt)
1:89a6625:             throws StandardException {
1:ae71c74:         checkOpen();
1:89a6625:         container.encryptOrDecryptContainer(this, newFilePath, doEncrypt);
1:ae71c74:     }
1:eac0369: 
1:eac0369:     
1:eac0369:     public String toString()
1:eac0369:     {
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:4a4b0a8:             String str = "BaseContainerHandle:(" + identity.toString() + ")";
1:eac0369:             return(str);
1:eac0369:         }
1:eac0369:         else
1:eac0369:         {
1:eac0369:             return(super.toString());
1:eac0369:         }
1:eac0369:     }
1:eac0369: 
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:d21039a
/////////////////////////////////////////////////////////////////////////
1: 		@see DerbyObserver#update
commit:a12152a
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.monitor.DerbyObservable;
1: import org.apache.derby.iapi.services.monitor.DerbyObserver;
/////////////////////////////////////////////////////////////////////////
1: 	This class is a DerbyObserver to observe RawTransactions
1: 	and is also a DerbyObservable to
/////////////////////////////////////////////////////////////////////////
1: public class BaseContainerHandle extends DerbyObservable 
1:     implements RawContainerHandle, DerbyObserver 
/////////////////////////////////////////////////////////////////////////
1: 	**	Methods of DerbyObserver
/////////////////////////////////////////////////////////////////////////
1: 	public void update(DerbyObservable obj, Object arg) 
commit:270a34d
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:89a6625
/////////////////////////////////////////////////////////////////////////
1:     /** {@inheritDoc} */
1:     public void encryptOrDecryptContainer(String newFilePath, boolean doEncrypt)
1:             throws StandardException {
1:         container.encryptOrDecryptContainer(this, newFilePath, doEncrypt);
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:4a4b0a8
/////////////////////////////////////////////////////////////////////////
1:             String str = "BaseContainerHandle:(" + identity.toString() + ")";
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:3fb9515
/////////////////////////////////////////////////////////////////////////
1: 	private /*final*/ ContainerKey		identity;
1: 	private boolean				        active;	
1: 	protected BaseContainer		        container;
/////////////////////////////////////////////////////////////////////////
1: 	private	LockingPolicy		        locking;
1: 	private	RawTransaction		        xact;
1: 	private	boolean		                forUpdate;
1:     /**
1:      * mode the conainter was opened in.
1:      **/
1: 	private int                         mode;
1: 
1: 
1: 	private PageActions		            actionsSet;
1: 	private AllocationActions           allocActionsSet;
/////////////////////////////////////////////////////////////////////////
1: 	public synchronized void close() 
1:         // Close may be called by multiple threads concurrently, for
1:         // instance it can be called automatically after an abort and
1:         // explicitly by a client.  Depending on timing of machine
1:         // these calls may happen concurrently.  Thus close needs to
1:         // be synchronized.  
1:         //
1:         // Another example is that we may hand out an indirect reference
1:         // to clients outside of JDBC through an OverFlowInputStream.  
1:         // Derby code cannot control when clients may close those 
1:         // streams with respect to implicit closes by abort.
1:         // notify our observers (Pages) that we are closing ...
1:         informObservers();
1:         active = false;
1:         getLockingPolicy().unlockContainer(xact, this);
1:         // let go of the container
1:         if (container != null) 
1:             container.letGo(this);
1:             container = null;
1:         }
1:         // and remove ourseleves from this transaction
1:         xact = null;
commit:f57b07d
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * ReCreate a page for rollforward recovery.  
1:      * <p>
1:      * During redo recovery it is possible for the system to try to redo
1:      * the creation of a page (ie. going from non-existence to version 0).
1:      * It first trys to read the page from disk, but a few different types
1:      * of errors can occur:
1:      *     o the page does not exist at all on disk, this can happen during
1:      *       rollforward recovery applied to a backup where the file was
1:      *       copied and the page was added to the file during the time frame
1:      *       of the backup but after the physical file was copied.
1:      *     o space in the file exists, but it was never initalized.  This
1:      *       can happen if you happen to crash at just the right moment during
1:      *       the allocation process.  Also
1:      *       on some OS's it is possible to read from a part of the file that
1:      *       was not ever written - resulting in garbage from the store's 
1:      *       point of view (often the result is all 0's).  
1:      *
1:      * All these errors are easy to recover from as the system can easily 
1:      * create a version 0 from scratch and write it to disk.
1:      *
1:      * Because the system does not sync allocation of data pages, it is also
1:      * possible at this point that whlie writing the version 0 to disk to 
1:      * create it we may encounter an out of disk space error (caught in this
1:      * routine as a StandardException from the create() call.  We can't 
1:      * recovery from this without help from outside, so the caught exception
1:      * is nested and a new exception thrown which the recovery system will
1:      * output to the user asking them to check their disk for space/errors.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1: 	public Page reCreatePageForRedoRecovery(
/////////////////////////////////////////////////////////////////////////
1: 		return container.reCreatePageForRedoRecovery(
commit:be3e2aa
/////////////////////////////////////////////////////////////////////////
1:      * @param backupContainerPath  location of the backup container.
commit:bf643fd
/////////////////////////////////////////////////////////////////////////
1:      * Backup the container to the specified path.
0:      * @param backupConatainerPath  location of the backup container.
1: 	 *  @exception StandardException	Standard Derby error policy
1:      */
commit:25f99f5
/////////////////////////////////////////////////////////////////////////
1: 
1: 	/**
0: 	   Backup the container to the specified path.
0: 	   @exception StandardException	Standard Cloudscape error policy
1: 	*/
1: 	public void backupContainer(String backupContainerPath) throws StandardException 
1:     {
1: 		checkOpen();
1: 		container.backupContainer(this, backupContainerPath);
1: 	}
1: 
commit:20bc69f
/////////////////////////////////////////////////////////////////////////
1:         <p>
commit:bbc927c
/////////////////////////////////////////////////////////////////////////
1: 		Release free space to the OS.
1: 		<P>
1:         As is possible release any free space to the operating system.  This
1:         will usually mean releasing any free pages located at the end of the
1:         file using the java truncate() interface.
1: 
0: 		@exception StandardException	Standard Cloudscape error policy
1: 	*/
1: 	public void compressContainer() throws StandardException 
1:     {
1: 		checkUpdateOpen();
1: 
1: 		container.compressContainer(this);
1: 	}
1: 
1: 	/**
/////////////////////////////////////////////////////////////////////////
1: 	public Page getPageForCompress(int flag, long pageno) 
1: 		 throws StandardException
1: 	{
1: 		checkUpdateOpen();
1: 
1: 		return container.getPageForCompress(this, flag, pageno);
1: 	}
1: 
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:94f158a
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException Standard Derby error policy
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException	Standard Derby error policy
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException Standard Derby error policy
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException Standard Derby error policy
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException Standard Derby error policy
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException Standard Derby error policy
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException Standard Derby error policy
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException Standard Derby error policy
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException Standard Derby error policy
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException Standard Derby error policy		
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException Standard Derby error policy		
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException  Standard Derby exception policy
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException  Standard Derby exception policy
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException Derby Standard error policy
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException Standard Derby error policy
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException Standard Derby exception policy.
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException Standard Derby error policy
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException Standard Derby error policy
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException Standard Derby error policy
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:ae71c74
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:     /**
0:      * Create encrypted version of the  container with the 
0:      * user specified encryption properties.        
0:      * @param newFilePath file to store the new encrypted version of the container
1:      * @exception StandardException	Standard Derby error policy
1:      */
0:     public void encryptContainer(String newFilePath) throws StandardException 
1:     {
1:         checkOpen();
0:         container.encryptContainer(this, newFilePath);
1:     }
1: 
commit:b44abbf
/////////////////////////////////////////////////////////////////////////
author:David Van Couvering
-------------------------------------------------------------------------------
commit:d376440
/////////////////////////////////////////////////////////////////////////
1: 	 * Get the reusable recordId sequence number.
1: 	 * @return version sequence number
0: 	 * @exception StandardException	Standard Derby error policy
1: 	 * @see ContainerHandle#getReusableRecordIdSequenceNumber
1: 	 */
1: 	public long getReusableRecordIdSequenceNumber() throws StandardException
1: 	{
1: 		checkOpen();
1: 		
1: 		return container.getReusableRecordIdSequenceNumber();
1: 	}
1: 
1: 	/**
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.store.raw.data.BaseContainerHandle
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:c6ad534
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.raw.data
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.store.raw.data;
1: 
1: import org.apache.derby.iapi.reference.SQLState;
1: 
1: import org.apache.derby.iapi.services.locks.Lockable;
1: import org.apache.derby.iapi.services.locks.VirtualLockTable;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.store.access.SpaceInfo;
1: import org.apache.derby.iapi.store.raw.ContainerHandle;
1: import org.apache.derby.iapi.store.raw.ContainerLock;
1: import org.apache.derby.iapi.store.raw.LockingPolicy;
1: import org.apache.derby.iapi.store.raw.Page;
1: import org.apache.derby.iapi.store.raw.PageKey;
1: import org.apache.derby.iapi.store.raw.PageTimeStamp;
1: import org.apache.derby.iapi.store.raw.RecordHandle;
1: import org.apache.derby.iapi.store.raw.ContainerKey;
1: 
1: import org.apache.derby.iapi.store.raw.data.RawContainerHandle;
1: import org.apache.derby.iapi.store.raw.xact.RawTransaction;
1: import org.apache.derby.iapi.store.raw.log.LogInstant;
1: 
1: import org.apache.derby.iapi.util.ByteArray;
1: import org.apache.derby.catalog.UUID;
1: 
1: import java.util.Hashtable;
0: import java.util.Observable;
0: import java.util.Observer;
1: import java.util.Properties;
1: 
1: /**
1: 	A handle to an open container, implememts RawContainerHandle.
1: 	<P>
0: 	This class is an Observer to observe RawTransactions
0: 	and is also a Observable to
1: 	handle the list of pages accessed thorough this handle.
1: 	<BR>
1: 	This class implements Lockable (defined to be ContainerHandle) and is
1: 	the object used to logically lock the container.
1: 
1: 	<BR> MT - Mutable - Immutable identity - Thread Aware
1: */
1: 
0: public class BaseContainerHandle extends Observable 
0:     implements RawContainerHandle, Observer 
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
1:  
0:     private static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 
1: 	/*
1: 	** Fields
1: 	*/
1: 
1: 	/**
1: 		Container identifier
1: 		<BR> MT - Immutable
1: 	*/
0: 	protected /*final*/ ContainerKey		identity;
1: 
1: 	/**
1: 		Is this ContainerHandle active.
1: 
1: 		<BR> MT - Mutable : scoped
1: 	*/
0: 	protected boolean				active;	
1: 
1: 	/**
1: 		The actual container we are accessing. Only valid when active is true.
1: 
1: 		<BR> MT - Mutable : scoped
1: 	*/
0: 	protected BaseContainer		container;
1: 
1: 	/**
1: 		the locking policy we opened the container with. 
1:         Only valid when active is true.
1: 
1: 		<BR> MT - Mutable : scoped
1: 	*/
1: 
0: 	private	LockingPolicy		locking;
1: 
1: 	/**
1: 		our transaction. Only valid when active is true.
1: 
1: 		<BR> MT - Mutable : scoped
1: 	*/
0: 	protected	RawTransaction		xact;
1: 
1: 	/**
1: 		are we going to update?
1: 
1: 		<BR> MT - Immutable after container handle becomes active
1: 	*/
0: 	private	boolean		forUpdate;
1: 
0: 	protected int mode;	// mode the container was opened in
1: 
1: 
0: 	protected PageActions		actionsSet;
0: 	protected AllocationActions allocActionsSet;
1: 
1: 
1: 	/*
1: 	** Constructor
1: 	*/
1: 
1: 	/**
1: 		Create an object that is only used for locking the container.
1: 	*/
1: 	public BaseContainerHandle(UUID rawStoreId, RawTransaction xact,
1: 		ContainerKey identity, LockingPolicy locking, int mode) 
1:     {
1: 		this.identity = identity;
1: 		this.xact = xact;
1: 		this.locking = locking;
1: 		this.mode = mode;
1: 		this.forUpdate = (mode & MODE_FORUPDATE) == MODE_FORUPDATE;
1: 	}
1: 
1: 	/**
1: 		Create a container handle that is used to actually access the container.
1: 	*/
1: 	public BaseContainerHandle(
1:     UUID                rawStoreId, 
1:     RawTransaction      xact,
1:     PageActions         actionsSet, 
1:     AllocationActions   allocActionsSet, 
1:     LockingPolicy       locking,
1: 	BaseContainer       container, 
1:     int                 mode)
1: 	{
1: 		this(rawStoreId, xact, 
1:                 (ContainerKey) container.getIdentity(), locking, mode);
1: 
1: 
1: 		this.actionsSet      = actionsSet;
1: 		this.allocActionsSet = allocActionsSet;
1: 		this.container       = container;
1: 
1: 		// we are inactive until useContainer is called.
1: 	}
1: 
1: 	/*
1: 	** Methods from ContainerHandle
1: 	*/
1: 
1: 	/**
1: 		Add a page to the container
1: 		The page returned will be observing me.
1: 
1: 		@see BaseContainer#addPage
1: 		@see ContainerHandle#addPage
0: 		@exception StandardException Standard Cloudscape error policy
1: 	*/
1: 	public Page addPage() throws StandardException 
1:     {
1: 		checkUpdateOpen();
1: 
1: 		Page page = container.addPage(this, false /* not an overflow page */);
1: 			
1: 		return page;
1: 	}
1: 
1: 	/**
1: 		Add a page to the container, if flag == ContainerHandle.ADD_PAGE_BULK,
1: 		tell the container about it.
1: 
1: 		The page returned will be observing me.
1: 
1: 		@see BaseContainer#addPage
1: 		@see ContainerHandle#addPage
0: 		@exception StandardException Standard Cloudscape error policy
1: 	*/
1: 	public Page addPage(int flag) throws StandardException {
1: 
1: 		if ((flag & ContainerHandle.ADD_PAGE_BULK) != 0 && active && forUpdate)
1: 		{
1: 			// start preallocating immediatelly, don't wait for the
1: 			// preallocation threshold to be crossed.  Don't go wild and
1: 			// preallocate a bunch of pages either, use preAllocate for that. 
1: 			container.clearPreallocThreshold();
1: 		}
1: 
1: 		return addPage();
1: 	}
1: 
1: 	/**
1: 		Preallocate numPage if possible.
1: 	*/
1: 	public void preAllocate(int numPage)
1: 	{
1: 		if (numPage > 0 && active && forUpdate)
1: 			container.prepareForBulkLoad(this, numPage);
1: 	}
1: 
1:     /**
1:      * Request the system properties associated with a container. 
1:      * <p>
1:      * Request the value of properties that are associated with a container.  
1:      * The following properties can be requested:
1:      *     derby.storage.pageSize 
1:      *     derby.storage.pageReservedSpace
1:      *     derby.storage.minimumRecordSize
1:      * <p>
1:      * To get the value of a particular property add it to the property list,
1:      * and on return the value of the property will be set to it's current 
1:      * value.  For example:
1:      *
1:      * get_prop(BaseContainerHandle ch)
1:      * {
1:      *     Properties prop = new Properties();
1:      *     prop.put("derby.storage.pageSize", "");
1:      *     ch.getContainerProperties(prop);
1:      *
1:      *     System.out.println(
1:      *         "conatainer's page size = " + 
1:      *         prop.getProperty("derby.storage.pageSize");
1:      * }
1:      *
1:      * @param prop   Property list to fill in.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     public void getContainerProperties(Properties prop)
1: 		throws StandardException
1:     {
1: 		checkOpen();
1: 
1:         container.getContainerProperties(prop);
1: 
1:         return;
1:     }
1: 
1: 	/**
1: 		Remove a page from the container.  
1: 
1: 		@see ContainerHandle#removePage
0: 		@exception StandardException Standard Cloudscape error policy
1: 	*/
1: 	public void removePage(Page page) throws StandardException
1: 	{
1: 		if (!active)
1: 		{
1: 			if (page != null)
1: 				page.unlatch();
1: 			throw StandardException.newException(
1:                     SQLState.DATA_CONTAINER_CLOSED);
1: 		}
1: 
1: 		if (!forUpdate)
1: 		{
1: 			if (page != null)
1: 				page.unlatch();
1: 			throw StandardException.newException(
1:                     SQLState.DATA_CONTAINER_READ_ONLY);
1: 		}
1: 
1: 		container.removePage(this, (BasePage)page);
1: 	}
1: 
1: 	public Page getPage(long pageNumber) throws StandardException 
1:     {
1: 
1: 		checkOpen();
1: 
1: 		return container.getPage(this, pageNumber, true);
1: 	}
1: 
1: 
1: 	public Page getAllocPage(long pageNumber) throws StandardException 
1:     {
1: 		checkOpen();
1: 
1: 		return container.getAllocPage(this, pageNumber, true);
1: 	}
1: 
1: 	public Page getUserPageNoWait(long pageNumber) 
1:         throws StandardException 
1:     {
1: 		checkOpen();
1: 
1: 		return container.getHeadPage(this, pageNumber, false);
1: 	}
1: 	public Page getUserPageWait(long pageNumber) 
1:         throws StandardException 
1:     {
1: 		checkOpen();
1: 
1: 		return container.getHeadPage(this, pageNumber, true);
1: 	}
1: 
1: 	public Page getPageNoWait(long pageNumber) 
1:         throws StandardException 
1:     {
1: 		checkOpen();
1: 
1: 		return container.getPage(this, pageNumber, false);
1: 	}
1: 
1: 	public Page getFirstPage() throws StandardException 
1:     {
1: 		checkOpen();
1: 
1: 		return container.getFirstPage(this);
1: 	}
1: 
1: 	public Page getNextPage(long pageNumber) throws StandardException 
1:     {
1: 		checkOpen();
1: 
1: 		return container.getNextPage(this, pageNumber);
1: 	}
1: 
1: 	public Page getPageForInsert(int flag) 
1: 		 throws StandardException
1: 	{
1: 		checkUpdateOpen();
1: 
1: 		return container.getPageForInsert(this, flag);
1: 	}
1: 
1: 	/**
1: 		@see ContainerHandle#isReadOnly()
1: 	*/
1:     public final boolean isReadOnly()
1:     {
1:         return(!forUpdate);
1:     }
1: 
1: 	/**
1: 		@see ContainerHandle#close
1: 	*/
1: 
0: 	public void close() 
1:     {
1: 
1:         if (xact == null) 
1:         {
0:             // Probably be closed explicitly by a client, after closing 
0:             // automatically after an abort.
1:             
1:             if (SanityManager.DEBUG)
1:                 SanityManager.ASSERT(!active);
1: 
1:             return;
1:         }
1: 
0: 		// notify our observers (Pages) that we are closing ...
1: 		informObservers();
1: 
0: 		active = false;
1: 
1: 		getLockingPolicy().unlockContainer(xact, this);
1: 
0: 		// let go of the container
0: 		if (container != null) 
1:         {
0: 			container.letGo(this);
1: 			container = null;
1: 		}
1: 
0: 		// and remove ourseleves from this transaction
1:         xact.deleteObserver(this);
1: 
0: 		xact = null;
1: 		
1: 	}
1: 
1: 	/* cost estimation */
1: 
1: 	/**
1: 		@see ContainerHandle#getEstimatedRowCount
0: 		@exception StandardException Standard Cloudscape error policy
1: 	 */
1: 	public long getEstimatedRowCount(int flag) throws StandardException
1: 	{
1: 		checkOpen();
1: 
1: 		return container.getEstimatedRowCount(flag);
1: 	}
1: 
1: 	/**
1: 		@see ContainerHandle#setEstimatedRowCount
0: 		@exception StandardException Standard Cloudscape error policy
1: 	 */
1: 	public void setEstimatedRowCount(long count, int flag) 
1:         throws StandardException
1: 	{
1: 		checkOpen();
1: 
1: 		container.setEstimatedRowCount(count, flag);
1: 	}
1: 
1: 	/**
1: 		@see ContainerHandle#getEstimatedPageCount
0: 		@exception StandardException Standard Cloudscape error policy
1: 	 */
1: 	public long getEstimatedPageCount(int flag) 
1:         throws StandardException
1: 	{
1: 		checkOpen();
1: 
1: 		return container.getEstimatedPageCount(this, flag);
1: 	}
1: 
1: 	/**
1: 		@see ContainerHandle#flushContainer
0: 		@exception StandardException Standard Cloudscape error policy
1: 	 */
1: 	public void flushContainer() 
1:         throws StandardException
1: 	{
1: 		checkUpdateOpen();
1: 
1: 		// raw store may override unlog mode when log is Archived.
1: 		// if ((mode & MODE_CREATE_UNLOGGED) == 0)
1: 		//	throw StandardException.newException(
1:         //	    SQLState.DATA_NOT_CREATE_UNLOGGED, identity);
1: 
1: 		container.flushAll();
1: 
1: 	}
1: 
1: 	/**
1: 		@see ContainerHandle#compactRecord
0: 		@exception StandardException Standard Cloudscape error policy
1: 	 */
1: 	public void compactRecord(RecordHandle record) 
1:         throws StandardException
1: 	{
1: 		if (!forUpdate)
1:         {
1: 			throw StandardException.newException(
1:                     SQLState.DATA_CONTAINER_READ_ONLY);
1:         }
1: 
1: 		PageKey pkey = (PageKey)record.getPageId();
1: 		BasePage headPage = (BasePage)getPage(pkey.getPageNumber());
1: 
1: 		if (headPage != null)
1: 		{
1: 			// The page could have been null if it was deallocated after the
1: 			// row lock is gotten.  We are doing all of these post commit so
1: 			// the record may not even be there and we got a lock for nothing.
1: 			try
1: 			{
1: 				headPage.compactRecord(record);
1: 			}
1: 			finally
1: 			{
1: 				headPage.unlatch();
1: 			}
1: 		}
1: 	}
1: 
1: 
1: 	/*
1: 	** Methods of RawContainerHandle - methods are called underneath the log
1: 	*/
1: 
1: 	/**
1: 		Get the container status.  
1: 
0: 		@exception StandardException Standard Cloudscape error policy		
1: 		@see RawContainerHandle#getContainerStatus
1: 	*/
1: 	public int getContainerStatus() throws StandardException
1: 	{
1: 		checkOpen();
1: 
1: 		return container.getContainerStatus();
1: 	}
1: 
1: 	/**
1: 		remove the container
1: 
0: 		@exception StandardException Standard Cloudscape error policy		
1: 		@see RawContainerHandle#removeContainer
1: 	*/
1: 	public void removeContainer(LogInstant instant) throws StandardException
1: 	{
1: 		checkUpdateOpen();
1: 
1: 		// This call can only be issued by within rawStore.
1: 		// while the container is dropped, no client of raw store
1: 		// should be able to access the container (it is 
1: 		// exclusively locked).  
1: 		// Then as postcommit processing, 
1: 		// the container iw 
1: 
1: 		container.removeContainer(instant, true);
1: 	}
1: 
1: 	/**
1: 		@see ContainerHandle#getId
1: 	 */
1: 	public ContainerKey getId()
1: 	{
1: 		return identity;
1: 	}
1: 
1: 	/**
1: 		@see ContainerHandle#getUniqueId
1: 	 */
1: 	public Object getUniqueId()
1: 	{
1:         return(this);
1: 	}
1: 
1: 
1: 	/**
0: 		@exception StandardException  Standard cloudscape exception policy
1: 		@see RawContainerHandle#dropContainer
1: 	*/
1: 	public void dropContainer(LogInstant instant, boolean drop) 
1:         throws StandardException
1: 	{
1: 		checkUpdateOpen();
1: 
1: 		container.dropContainer(instant, drop);
1: 	}
1: 
1: 	/**
0: 		@exception StandardException  Standard cloudscape exception policy
1: 		@see RawContainerHandle#getContainerVersion
1: 	*/
1: 	public long getContainerVersion() 
1:         throws StandardException
1: 	{
1: 		checkOpen();
1: 
1: 		return container.getContainerVersion();
1: 	}
1: 
1: 
1: 	/**
1: 		Get this page with no check - any page type or status is fine.
1: 		Caller must be prepared to handle freed, deallocated,or alloc page
1: 		Called by recovery ONLY.
1: 
0: 		@exception StandardException Cloudscape Standard error policy
1: 	*/
1: 	public Page getAnyPage(long pageNumber) throws StandardException
1: 	{
1: 		checkOpen();
1: 
1: 		return container.getAnyPage(this, pageNumber, true /* wait */);
1: 	}
1: 
1: 	/**
0: 		Re-create this page for load tran.  Called by recovery redo ONLY
0: 		@exception StandardException Cloudscape Standard error policy
1: 	 */
0: 	public Page reCreatePageForLoadTran(
1:     int     pageFormat,
1:     long    pageNumber, 
1:     long    pageOffset)
1: 		 throws StandardException
1: 	{
1: 		checkUpdateOpen();
1: 
0: 		return container.reCreatePageForLoadTran(
1: 					this, pageFormat, pageNumber, pageOffset);
1: 	}
1: 
1: 	/**
1: 		Log all information necessary to recreate the container during a load
1: 		tran.
1: 
0: 		@exception StandardException Standard Cloudscape error policy
1: 	 */
1: 	public ByteArray logCreateContainerInfo() 
1:         throws StandardException
1: 	{
1: 		checkUpdateOpen();
1: 
1: 		return container.logCreateContainerInfo();
1: 	}
1: 	
1: 	/**
1: 		Return a record handle that is initialized to the given page number and
1:         record id.
1: 
0: 		@exception StandardException Standard cloudscape exception policy.
1: 
1: 		@param pageNumber   the page number of the RecordHandle.
1: 		@param recordId     the record id of the RecordHandle.
1: 
1: 		@see RecordHandle
1: 	*/
1: 	public RecordHandle makeRecordHandle(long pageNumber, int recordId)
1: 		 throws	StandardException
1:     {
1:         return new RecordId(identity, pageNumber, recordId);
1:     }
1: 
1: 
1: 	/*
0: 	**	Methods of Observer
1: 	*/
1: 
1: 	/**
1: 		Called when the transaction is about to complete.
1: 
0: 		@see Observer#update
1: 	*/
0: 	public void update(Observable obj, Object arg) 
1:     {
1: 		if (SanityManager.DEBUG) 
1:         {
1: 			if (arg == null)
1: 				SanityManager.THROWASSERT("still on observr list " + this);
1: 		}
1: 
1: 		// already been removed from the list
1: 		if (xact == null) 
1:         {
1: 			return;
1: 		}
1: 
1: 		if (SanityManager.DEBUG) 
1:         {
1: 			// just check reference equality
1: 
1: 			if (obj != xact)
1:             {
1: 				SanityManager.THROWASSERT(
1:                     "Observable passed to update is incorrect expected " + 
1:                     xact + " got " + obj);
1:             }
1: 		}
1: 
1: 		// close on a commit, abort or drop of this container.
1: 		if (arg.equals(RawTransaction.COMMIT) || 
1:             arg.equals(RawTransaction.ABORT)  || 
1:             arg.equals(identity)) 
1:         {
1: 			// close the container		
1: 			close();
1: 			return;
1: 
1: 		}
1: 		
1: 		if (arg.equals(RawTransaction.SAVEPOINT_ROLLBACK)) 
1:         {
1: 
1: 			// unlatch any pages but remain open
1: 			informObservers();
1: 
1: 			// remain open
1: 			return;
1: 		}
1: 
1: 		// Transaction is notifying us that our container
1: 		// has undergone some lock escalation. We re-get
1: 		// our table lock which will promote us 
1: 		// if possible
1: 		
1: 		if (arg.equals(RawTransaction.LOCK_ESCALATE)) 
1:         {
1: 
1: 			// only attempt escalation on RowLocking modes.
1: 			if (getLockingPolicy().getMode() != LockingPolicy.MODE_RECORD)
1: 				return;
1: 
1: 			try 
1:             {
1: 				getLockingPolicy().lockContainer(
1:                     getTransaction(), this, false, forUpdate);
1: 			} 
1:             catch (StandardException se) 
1:             {
1: 				xact.setObserverException(se);
1: 			}
1: 		}
1: 	}
1: 
1: 	/*
1: 	** Implementation specific methods, these are public so that they can be 
1:     ** called in other packages that are specific implementations of Data, ie.
1: 	** a directory at the level
1: 	**
1: 	** com.ibm.db2j.impl.Database.Storage.RawStore.Data.*
1: 	*/
1: 
1: 	public PageActions getActionSet() 
1:     {
1: 		return actionsSet;
1: 	}
1: 	
1: 	public AllocationActions getAllocationActionSet() 
1:     {
1: 		return allocActionsSet;
1: 	}
1: 
1: 	/**
1: 		Attach me to a container. If this method returns false then
1: 		I cannot be used anymore, and any reference to me must be discarded.
1: 
1: 		@param droppedOK if true, use this container even if it is dropped,
1: 		otherwise, return false if container is dropped.  
1: 
1: 		@param waitForLock if true, wait on lock, otherwise, get lock no wait.
1: 
0: 		@exception StandardException Standard Cloudscape error policy
1: 	*/
1: 	public boolean useContainer(
1:     boolean droppedOK, 
1:     boolean waitForLock) 
1:         throws StandardException 
1:     {
1: 
1: 		if (SanityManager.DEBUG) 
1:         {
1: 			SanityManager.ASSERT(!active);
1: 		}
1: 
1: 		boolean gotLock = 
1: 			getLockingPolicy().lockContainer(
1:                 getTransaction(), this, waitForLock, forUpdate);
1: 
1: 		if (gotLock == false)
1: 		{
1: 			// this is a lockingPolicy error, if waitForLock should either 
1: 			// return true or throw a deadlock exception
1: 			if (SanityManager.DEBUG)
1: 				SanityManager.ASSERT(waitForLock == false, 
1: 					"lockContainer wait returns false");
1: 
1: 			container = null;
1: 
1:             throw StandardException.newException(SQLState.LOCK_TIMEOUT);
1: 		}
1: 
1: 		if ((mode & ContainerHandle.MODE_OPEN_FOR_LOCK_ONLY) == 0) 
1:         {
1: 
1: 			if (SanityManager.DEBUG) 
1:             {
1: 				SanityManager.ASSERT(container != null);
1: 			}
1: 
1: 			if (!container.use(this, forUpdate, droppedOK)) 
1:             {
1: 
1:                 // If we got a lock, but for some reason we can't open the
1:                 // table (like it doesn't exist), then call unlockContainer().
1:                 // In the normal case it would be called when the container
1:                 // handle was closed, but in this case the user is never going
1:                 // to get an "open" container handle back.  We can't call 
1:                 // close() here as we haven't done all the "open" stuff.
1:                 getLockingPolicy().unlockContainer(xact, this);
1: 
1: 				container = null;
1: 
1: 				return false;
1: 			}
1: 			active = true;
1: 		} 
1:         else 
1:         {
1: 			// lock only, we only observe the transaction if
1: 			// we are performing row level locking.
1: 			if (getLockingPolicy().getMode() != LockingPolicy.MODE_RECORD)
1: 				return true;
1: 		}
1: 
1: 		// watch transaction so we will close handle just before xact completes.
1: 		xact.addObserver(this);
1: 
1: 
1: 		// Add special objects implementing certain behaviour at commit/rollback
1: 
1: 		if ((mode & (ContainerHandle.MODE_READONLY | 
1:                      ContainerHandle.MODE_NO_ACTIONS_ON_COMMIT)) == 0) 
1:         {
1: 			if ((mode & MODE_TRUNCATE_ON_COMMIT) == MODE_TRUNCATE_ON_COMMIT) 
1:             {
1: 				xact.addObserver(
1:                     new TruncateOnCommit(identity, true /* always */));
1: 			} 
1:             else if ((mode & MODE_TRUNCATE_ON_ROLLBACK) == 
1:                                         MODE_TRUNCATE_ON_ROLLBACK) 
1:             {
1: 				xact.addObserver(
1:                     new TruncateOnCommit(identity, false /* rollbacks only */));
1: 			}
1: 
1: 			if ((mode & MODE_DROP_ON_COMMIT) == MODE_DROP_ON_COMMIT) 
1:             {
1: 				xact.addObserver(new DropOnCommit(identity));				
1: 			}
1: 
1: 			if ((mode & MODE_FLUSH_ON_COMMIT) == MODE_FLUSH_ON_COMMIT) 
1:             {
1: 				xact.addObserver(new SyncOnCommit(identity));
1: 			}
1: 		}
1: 
1: 		return true;
1: 	}
1: 
1: 	/**
1: 		Return the RawTransaction I was opened in.
1: 	*/
1: 	public final RawTransaction getTransaction() 
1:     {
1: 
1: 		if (SanityManager.DEBUG) 
1:         {
0: 			SanityManager.ASSERT(xact != null);
1: 		}
1: 
1: 		return xact;
1: 	}
1: 
1: 	/**
1: 		Return my locking policy, may be different from the Transaction's
1: 		default locking policy.
1: 	*/
1: 	public final LockingPolicy getLockingPolicy() 
1:     {
1: 
1: 		if (SanityManager.DEBUG) 
1:         {
1: 			SanityManager.ASSERT(locking != null);
1: 		}
1: 
1: 		return locking;
1: 	}
1: 
1: 	public final void setLockingPolicy(LockingPolicy newLockingPolicy) 
1:     {
1: 		locking = newLockingPolicy;
1: 	}
1: 
1: 	/**
1: 		Was I opened for updates?
1: 
1: 		<BR> MT - thread safe
1: 	*/
1: 	public final boolean updateOK() 
1:     {
1: 		return forUpdate;
1: 	}
1: 
1: 	/**
1: 		Get the mode I was opened with.
1: 	*/
1: 	public int getMode() 
1:     {
1: 		return mode;
1: 	}
1: 
1: 	/**
1: 	   The container is about to be modified.
1: 	   Loggable actions use this to make sure the container gets cleaned if a
1: 	   checkpoint is taken after any log record is sent to the log stream but
1: 	   before the container is actually dirtied.
1: 
0: 		@exception StandardException Standard Cloudscape error policy
1: 	 */
1: 	public void preDirty(boolean preDirtyOn) throws StandardException 
1:     {
1: 
1: 		checkUpdateOpen();
1: 
1: 		container.preDirty(preDirtyOn);
1: 
1: 	}
1: 
1: 	/**
1: 		@see ContainerHandle#isTemporaryContainer
0: 		@exception StandardException Standard Cloudscape error policy
1: 	 */
1: 	public boolean isTemporaryContainer() throws StandardException 
1:     {
1: 
1: 		checkOpen();
1: 
1: 		return (identity != null && 
1: 				identity.getSegmentId() == ContainerHandle.TEMPORARY_SEGMENT);
1: 	}
1: 
1: 	/*
1: 	** Implementation specific methods for myself and my sub-classes
1: 	*/
1: 
1: 	protected void checkOpen() throws StandardException 
1:     {
1: 		if (!active)
1: 			throw StandardException.newException(
1:                     SQLState.DATA_CONTAINER_CLOSED);
1: 	}
1: 
1: 
1:     private void checkUpdateOpen() throws StandardException 
1:     {
1: 
1: 		if (!active)
1:         {
1: 			throw StandardException.newException(
1:                     SQLState.DATA_CONTAINER_CLOSED);
1:         }
1: 
1: 		if (!forUpdate)
1:         {
1: 			throw StandardException.newException(
1:                     SQLState.DATA_CONTAINER_READ_ONLY);
1:         }
1: 	}
1: 
1: 	protected void informObservers() 
1:     {
1: 
1: 		// notify our observers (Pages) that we are closing, 
1:         // or undergoing some state change ...
1: 
1: 		if (countObservers() != 0) 
1:         {
1: 			setChanged();
1: 			notifyObservers();
1: 		}
1: 	}
1: 
1: 
1:     /**
1:     Get information about space used by the container.
1:     **/
1:     public SpaceInfo getSpaceInfo()
1:         throws StandardException
1:     {
1:         return container.getSpaceInfo(this);
1:     }
1: 
1:     
1:     public String toString()
1:     {
1:         if (SanityManager.DEBUG)
1:         {
0:             String str = new String();
0:             str += "BaseContainerHandle:(" + identity.toString() + ")";
1:             return(str);
1:         }
1:         else
1:         {
1:             return(super.toString());
1:         }
1:     }
1: 
1: }
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.raw.data
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.store.raw.data;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.iapi.services.locks.Lockable;
0: import org.apache.derby.iapi.services.locks.VirtualLockTable;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.store.access.SpaceInfo;
0: import org.apache.derby.iapi.store.raw.ContainerHandle;
0: import org.apache.derby.iapi.store.raw.ContainerLock;
0: import org.apache.derby.iapi.store.raw.LockingPolicy;
0: import org.apache.derby.iapi.store.raw.Page;
0: import org.apache.derby.iapi.store.raw.PageKey;
0: import org.apache.derby.iapi.store.raw.PageTimeStamp;
0: import org.apache.derby.iapi.store.raw.RecordHandle;
0: import org.apache.derby.iapi.store.raw.ContainerKey;
0: 
0: import org.apache.derby.iapi.store.raw.data.RawContainerHandle;
0: import org.apache.derby.iapi.store.raw.xact.RawTransaction;
0: import org.apache.derby.iapi.store.raw.log.LogInstant;
0: 
0: import org.apache.derby.iapi.util.ByteArray;
0: import org.apache.derby.catalog.UUID;
0: 
0: import java.util.Hashtable;
0: import java.util.Observable;
0: import java.util.Observer;
0: import java.util.Properties;
0: 
0: /**
0: 	A handle to an open container, implememts RawContainerHandle.
0: 	<P>
0: 	This class is an Observer to observe RawTransactions
0: 	and is also a Observable to
0: 	handle the list of pages accessed thorough this handle.
0: 	<BR>
0: 	This class implements Lockable (defined to be ContainerHandle) and is
0: 	the object used to logically lock the container.
0: 
0: 	<BR> MT - Mutable - Immutable identity - Thread Aware
0: */
0: 
0: public class BaseContainerHandle extends Observable 
0:     implements RawContainerHandle, Observer 
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0:  
0:     private static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 
0: 	/*
0: 	** Fields
0: 	*/
0: 
0: 	/**
0: 		Container identifier
0: 		<BR> MT - Immutable
0: 	*/
0: 	protected /*final*/ ContainerKey		identity;
0: 
0: 	/**
0: 		Is this ContainerHandle active.
0: 
0: 		<BR> MT - Mutable : scoped
0: 	*/
0: 	protected boolean				active;	
0: 
0: 	/**
0: 		The actual container we are accessing. Only valid when active is true.
0: 
0: 		<BR> MT - Mutable : scoped
0: 	*/
0: 	protected BaseContainer		container;
0: 
0: 	/**
0: 		the locking policy we opened the container with. 
0:         Only valid when active is true.
0: 
0: 		<BR> MT - Mutable : scoped
0: 	*/
0: 
0: 	private	LockingPolicy		locking;
0: 
0: 	/**
0: 		our transaction. Only valid when active is true.
0: 
0: 		<BR> MT - Mutable : scoped
0: 	*/
0: 	protected	RawTransaction		xact;
0: 
0: 	/**
0: 		are we going to update?
0: 
0: 		<BR> MT - Immutable after container handle becomes active
0: 	*/
0: 	private	boolean		forUpdate;
0: 
0: 	protected int mode;	// mode the container was opened in
0: 
0: 
0: 	protected PageActions		actionsSet;
0: 	protected AllocationActions allocActionsSet;
0: 
0: 
0: 	/*
0: 	** Constructor
0: 	*/
0: 
0: 	/**
0: 		Create an object that is only used for locking the container.
0: 	*/
0: 	public BaseContainerHandle(UUID rawStoreId, RawTransaction xact,
0: 		ContainerKey identity, LockingPolicy locking, int mode) 
0:     {
0: 		this.identity = identity;
0: 		this.xact = xact;
0: 		this.locking = locking;
0: 		this.mode = mode;
0: 		this.forUpdate = (mode & MODE_FORUPDATE) == MODE_FORUPDATE;
0: 	}
0: 
0: 	/**
0: 		Create a container handle that is used to actually access the container.
0: 	*/
0: 	public BaseContainerHandle(
0:     UUID                rawStoreId, 
0:     RawTransaction      xact,
0:     PageActions         actionsSet, 
0:     AllocationActions   allocActionsSet, 
0:     LockingPolicy       locking,
0: 	BaseContainer       container, 
0:     int                 mode)
0: 	{
0: 		this(rawStoreId, xact, 
0:                 (ContainerKey) container.getIdentity(), locking, mode);
0: 
0: 
0: 		this.actionsSet      = actionsSet;
0: 		this.allocActionsSet = allocActionsSet;
0: 		this.container       = container;
0: 
0: 		// we are inactive until useContainer is called.
0: 	}
0: 
0: 	/*
0: 	** Methods from ContainerHandle
0: 	*/
0: 
0: 	/**
0: 		Add a page to the container
0: 		The page returned will be observing me.
0: 
0: 		@see BaseContainer#addPage
0: 		@see ContainerHandle#addPage
0: 		@exception StandardException Standard Cloudscape error policy
0: 	*/
0: 	public Page addPage() throws StandardException 
0:     {
0: 		checkUpdateOpen();
0: 
0: 		Page page = container.addPage(this, false /* not an overflow page */);
0: 			
0: 		return page;
0: 	}
0: 
0: 	/**
0: 		Add a page to the container, if flag == ContainerHandle.ADD_PAGE_BULK,
0: 		tell the container about it.
0: 
0: 		The page returned will be observing me.
0: 
0: 		@see BaseContainer#addPage
0: 		@see ContainerHandle#addPage
0: 		@exception StandardException Standard Cloudscape error policy
0: 	*/
0: 	public Page addPage(int flag) throws StandardException {
0: 
0: 		if ((flag & ContainerHandle.ADD_PAGE_BULK) != 0 && active && forUpdate)
0: 		{
0: 			// start preallocating immediatelly, don't wait for the
0: 			// preallocation threshold to be crossed.  Don't go wild and
0: 			// preallocate a bunch of pages either, use preAllocate for that. 
0: 			container.clearPreallocThreshold();
0: 		}
0: 
0: 		return addPage();
0: 	}
0: 
0: 	/**
0: 		Preallocate numPage if possible.
0: 	*/
0: 	public void preAllocate(int numPage)
0: 	{
0: 		if (numPage > 0 && active && forUpdate)
0: 			container.prepareForBulkLoad(this, numPage);
0: 	}
0: 
0:     /**
0:      * Request the system properties associated with a container. 
0:      * <p>
0:      * Request the value of properties that are associated with a container.  
0:      * The following properties can be requested:
0:      *     derby.storage.pageSize 
0:      *     derby.storage.pageReservedSpace
0:      *     derby.storage.minimumRecordSize
0:      * <p>
0:      * To get the value of a particular property add it to the property list,
0:      * and on return the value of the property will be set to it's current 
0:      * value.  For example:
0:      *
0:      * get_prop(BaseContainerHandle ch)
0:      * {
0:      *     Properties prop = new Properties();
0:      *     prop.put("derby.storage.pageSize", "");
0:      *     ch.getContainerProperties(prop);
0:      *
0:      *     System.out.println(
0:      *         "conatainer's page size = " + 
0:      *         prop.getProperty("derby.storage.pageSize");
0:      * }
0:      *
0:      * @param prop   Property list to fill in.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     public void getContainerProperties(Properties prop)
0: 		throws StandardException
0:     {
0: 		checkOpen();
0: 
0:         container.getContainerProperties(prop);
0: 
0:         return;
0:     }
0: 
0: 	/**
0: 		Remove a page from the container.  
0: 
0: 		@see ContainerHandle#removePage
0: 		@exception StandardException Standard Cloudscape error policy
0: 	*/
0: 	public void removePage(Page page) throws StandardException
0: 	{
0: 		if (!active)
0: 		{
0: 			if (page != null)
0: 				page.unlatch();
0: 			throw StandardException.newException(
0:                     SQLState.DATA_CONTAINER_CLOSED);
0: 		}
0: 
0: 		if (!forUpdate)
0: 		{
0: 			if (page != null)
0: 				page.unlatch();
0: 			throw StandardException.newException(
0:                     SQLState.DATA_CONTAINER_READ_ONLY);
0: 		}
0: 
0: 		container.removePage(this, (BasePage)page);
0: 	}
0: 
0: 	public Page getPage(long pageNumber) throws StandardException 
0:     {
0: 
0: 		checkOpen();
0: 
0: 		return container.getPage(this, pageNumber, true);
0: 	}
0: 
0: 
0: 	public Page getAllocPage(long pageNumber) throws StandardException 
0:     {
0: 		checkOpen();
0: 
0: 		return container.getAllocPage(this, pageNumber, true);
0: 	}
0: 
0: 	public Page getUserPageNoWait(long pageNumber) 
0:         throws StandardException 
0:     {
0: 		checkOpen();
0: 
0: 		return container.getHeadPage(this, pageNumber, false);
0: 	}
0: 	public Page getUserPageWait(long pageNumber) 
0:         throws StandardException 
0:     {
0: 		checkOpen();
0: 
0: 		return container.getHeadPage(this, pageNumber, true);
0: 	}
0: 
0: 	public Page getPageNoWait(long pageNumber) 
0:         throws StandardException 
0:     {
0: 		checkOpen();
0: 
0: 		return container.getPage(this, pageNumber, false);
0: 	}
0: 
0: 	public Page getFirstPage() throws StandardException 
0:     {
0: 		checkOpen();
0: 
0: 		return container.getFirstPage(this);
0: 	}
0: 
0: 	public Page getNextPage(long pageNumber) throws StandardException 
0:     {
0: 		checkOpen();
0: 
0: 		return container.getNextPage(this, pageNumber);
0: 	}
0: 
0: 	public Page getPageForInsert(int flag) 
0: 		 throws StandardException
0: 	{
0: 		checkUpdateOpen();
0: 
0: 		return container.getPageForInsert(this, flag);
0: 	}
0: 
0: 	/**
0: 		@see ContainerHandle#isReadOnly()
0: 	*/
0:     public final boolean isReadOnly()
0:     {
0:         return(!forUpdate);
0:     }
0: 
0: 	/**
0: 		@see ContainerHandle#close
0: 	*/
0: 
0: 	public void close() 
0:     {
0: 
0:         if (xact == null) 
0:         {
0:             // Probably be closed explicitly by a client, after closing 
0:             // automatically after an abort.
0:             
0:             if (SanityManager.DEBUG)
0:                 SanityManager.ASSERT(!active);
0: 
0:             return;
0:         }
0: 
0: 		// notify our observers (Pages) that we are closing ...
0: 		informObservers();
0: 
0: 		active = false;
0: 
0: 		getLockingPolicy().unlockContainer(xact, this);
0: 
0: 		// let go of the container
0: 		if (container != null) 
0:         {
0: 			container.letGo(this);
0: 			container = null;
0: 		}
0: 
0: 		// and remove ourseleves from this transaction
0:         xact.deleteObserver(this);
0: 
0: 		xact = null;
0: 		
0: 	}
0: 
0: 	/* cost estimation */
0: 
0: 	/**
0: 		@see ContainerHandle#getEstimatedRowCount
0: 		@exception StandardException Standard Cloudscape error policy
0: 	 */
0: 	public long getEstimatedRowCount(int flag) throws StandardException
0: 	{
0: 		checkOpen();
0: 
0: 		return container.getEstimatedRowCount(flag);
0: 	}
0: 
0: 	/**
0: 		@see ContainerHandle#setEstimatedRowCount
0: 		@exception StandardException Standard Cloudscape error policy
0: 	 */
0: 	public void setEstimatedRowCount(long count, int flag) 
0:         throws StandardException
0: 	{
0: 		checkOpen();
0: 
0: 		container.setEstimatedRowCount(count, flag);
0: 	}
0: 
0: 	/**
0: 		@see ContainerHandle#getEstimatedPageCount
0: 		@exception StandardException Standard Cloudscape error policy
0: 	 */
0: 	public long getEstimatedPageCount(int flag) 
0:         throws StandardException
0: 	{
0: 		checkOpen();
0: 
0: 		return container.getEstimatedPageCount(this, flag);
0: 	}
0: 
0: 	/**
0: 		@see ContainerHandle#flushContainer
0: 		@exception StandardException Standard Cloudscape error policy
0: 	 */
0: 	public void flushContainer() 
0:         throws StandardException
0: 	{
0: 		checkUpdateOpen();
0: 
0: 		// raw store may override unlog mode when log is Archived.
0: 		// if ((mode & MODE_CREATE_UNLOGGED) == 0)
0: 		//	throw StandardException.newException(
0:         //	    SQLState.DATA_NOT_CREATE_UNLOGGED, identity);
0: 
0: 		container.flushAll();
0: 
0: 	}
0: 
0: 	/**
0: 		@see ContainerHandle#compactRecord
0: 		@exception StandardException Standard Cloudscape error policy
0: 	 */
0: 	public void compactRecord(RecordHandle record) 
0:         throws StandardException
0: 	{
0: 		if (!forUpdate)
0:         {
0: 			throw StandardException.newException(
0:                     SQLState.DATA_CONTAINER_READ_ONLY);
0:         }
0: 
0: 		PageKey pkey = (PageKey)record.getPageId();
0: 		BasePage headPage = (BasePage)getPage(pkey.getPageNumber());
0: 
0: 		if (headPage != null)
0: 		{
0: 			// The page could have been null if it was deallocated after the
0: 			// row lock is gotten.  We are doing all of these post commit so
0: 			// the record may not even be there and we got a lock for nothing.
0: 			try
0: 			{
0: 				headPage.compactRecord(record);
0: 			}
0: 			finally
0: 			{
0: 				headPage.unlatch();
0: 			}
0: 		}
0: 	}
0: 
0: 
0: 	/*
0: 	** Methods of RawContainerHandle - methods are called underneath the log
0: 	*/
0: 
0: 	/**
0: 		Get the container status.  
0: 
0: 		@exception StandardException Standard Cloudscape error policy		
0: 		@see RawContainerHandle#getContainerStatus
0: 	*/
0: 	public int getContainerStatus() throws StandardException
0: 	{
0: 		checkOpen();
0: 
0: 		return container.getContainerStatus();
0: 	}
0: 
0: 	/**
0: 		remove the container
0: 
0: 		@exception StandardException Standard Cloudscape error policy		
0: 		@see RawContainerHandle#removeContainer
0: 	*/
0: 	public void removeContainer(LogInstant instant) throws StandardException
0: 	{
0: 		checkUpdateOpen();
0: 
0: 		// This call can only be issued by within rawStore.
0: 		// while the container is dropped, no client of raw store
0: 		// should be able to access the container (it is 
0: 		// exclusively locked).  
0: 		// Then as postcommit processing, 
0: 		// the container iw 
0: 
0: 		container.removeContainer(instant, true);
0: 	}
0: 
0: 	/**
0: 		@see ContainerHandle#getId
0: 	 */
0: 	public ContainerKey getId()
0: 	{
0: 		return identity;
0: 	}
0: 
0: 	/**
0: 		@see ContainerHandle#getUniqueId
0: 	 */
0: 	public Object getUniqueId()
0: 	{
0:         return(this);
0: 	}
0: 
0: 
0: 	/**
0: 		@exception StandardException  Standard cloudscape exception policy
0: 		@see RawContainerHandle#dropContainer
0: 	*/
0: 	public void dropContainer(LogInstant instant, boolean drop) 
0:         throws StandardException
0: 	{
0: 		checkUpdateOpen();
0: 
0: 		container.dropContainer(instant, drop);
0: 	}
0: 
0: 	/**
0: 		@exception StandardException  Standard cloudscape exception policy
0: 		@see RawContainerHandle#getContainerVersion
0: 	*/
0: 	public long getContainerVersion() 
0:         throws StandardException
0: 	{
0: 		checkOpen();
0: 
0: 		return container.getContainerVersion();
0: 	}
0: 
0: 
0: 	/**
0: 		Get this page with no check - any page type or status is fine.
0: 		Caller must be prepared to handle freed, deallocated,or alloc page
0: 		Called by recovery ONLY.
0: 
0: 		@exception StandardException Cloudscape Standard error policy
0: 	*/
0: 	public Page getAnyPage(long pageNumber) throws StandardException
0: 	{
0: 		checkOpen();
0: 
0: 		return container.getAnyPage(this, pageNumber, true /* wait */);
0: 	}
0: 
0: 	/**
0: 		Re-create this page for load tran.  Called by recovery redo ONLY
0: 		@exception StandardException Cloudscape Standard error policy
0: 	 */
0: 	public Page reCreatePageForLoadTran(
0:     int     pageFormat,
0:     long    pageNumber, 
0:     long    pageOffset)
0: 		 throws StandardException
0: 	{
0: 		checkUpdateOpen();
0: 
0: 		return container.reCreatePageForLoadTran(
0: 					this, pageFormat, pageNumber, pageOffset);
0: 	}
0: 
0: 	/**
0: 		Log all information necessary to recreate the container during a load
0: 		tran.
0: 
0: 		@exception StandardException Standard Cloudscape error policy
0: 	 */
0: 	public ByteArray logCreateContainerInfo() 
0:         throws StandardException
0: 	{
0: 		checkUpdateOpen();
0: 
0: 		return container.logCreateContainerInfo();
0: 	}
0: 	
0: 	/**
0: 		Return a record handle that is initialized to the given page number and
0:         record id.
0: 
0: 		@exception StandardException Standard cloudscape exception policy.
0: 
0: 		@param pageNumber   the page number of the RecordHandle.
0: 		@param recordId     the record id of the RecordHandle.
0: 
0: 		@see RecordHandle
0: 	*/
0: 	public RecordHandle makeRecordHandle(long pageNumber, int recordId)
0: 		 throws	StandardException
0:     {
0:         return new RecordId(identity, pageNumber, recordId);
0:     }
0: 
0: 
0: 	/*
0: 	**	Methods of Observer
0: 	*/
0: 
0: 	/**
0: 		Called when the transaction is about to complete.
0: 
0: 		@see Observer#update
0: 	*/
0: 	public void update(Observable obj, Object arg) 
0:     {
0: 		if (SanityManager.DEBUG) 
0:         {
0: 			if (arg == null)
0: 				SanityManager.THROWASSERT("still on observr list " + this);
0: 		}
0: 
0: 		// already been removed from the list
0: 		if (xact == null) 
0:         {
0: 			return;
0: 		}
0: 
0: 		if (SanityManager.DEBUG) 
0:         {
0: 			// just check reference equality
0: 
0: 			if (obj != xact)
0:             {
0: 				SanityManager.THROWASSERT(
0:                     "Observable passed to update is incorrect expected " + 
0:                     xact + " got " + obj);
0:             }
0: 		}
0: 
0: 		// close on a commit, abort or drop of this container.
0: 		if (arg.equals(RawTransaction.COMMIT) || 
0:             arg.equals(RawTransaction.ABORT)  || 
0:             arg.equals(identity)) 
0:         {
0: 			// close the container		
0: 			close();
0: 			return;
0: 
0: 		}
0: 		
0: 		if (arg.equals(RawTransaction.SAVEPOINT_ROLLBACK)) 
0:         {
0: 
0: 			// unlatch any pages but remain open
0: 			informObservers();
0: 
0: 			// remain open
0: 			return;
0: 		}
0: 
0: 		// Transaction is notifying us that our container
0: 		// has undergone some lock escalation. We re-get
0: 		// our table lock which will promote us 
0: 		// if possible
0: 		
0: 		if (arg.equals(RawTransaction.LOCK_ESCALATE)) 
0:         {
0: 
0: 			// only attempt escalation on RowLocking modes.
0: 			if (getLockingPolicy().getMode() != LockingPolicy.MODE_RECORD)
0: 				return;
0: 
0: 			try 
0:             {
0: 				getLockingPolicy().lockContainer(
0:                     getTransaction(), this, false, forUpdate);
0: 			} 
0:             catch (StandardException se) 
0:             {
0: 				xact.setObserverException(se);
0: 			}
0: 		}
0: 	}
0: 
0: 	/*
0: 	** Implementation specific methods, these are public so that they can be 
0:     ** called in other packages that are specific implementations of Data, ie.
0: 	** a directory at the level
0: 	**
0: 	** com.ibm.db2j.impl.Database.Storage.RawStore.Data.*
0: 	*/
0: 
0: 	public PageActions getActionSet() 
0:     {
0: 		return actionsSet;
0: 	}
0: 	
0: 	public AllocationActions getAllocationActionSet() 
0:     {
0: 		return allocActionsSet;
0: 	}
0: 
0: 	/**
0: 		Attach me to a container. If this method returns false then
0: 		I cannot be used anymore, and any reference to me must be discarded.
0: 
0: 		@param droppedOK if true, use this container even if it is dropped,
0: 		otherwise, return false if container is dropped.  
0: 
0: 		@param waitForLock if true, wait on lock, otherwise, get lock no wait.
0: 
0: 		@exception StandardException Standard Cloudscape error policy
0: 	*/
0: 	public boolean useContainer(
0:     boolean droppedOK, 
0:     boolean waitForLock) 
0:         throws StandardException 
0:     {
0: 
0: 		if (SanityManager.DEBUG) 
0:         {
0: 			SanityManager.ASSERT(!active);
0: 		}
0: 
0: 		boolean gotLock = 
0: 			getLockingPolicy().lockContainer(
0:                 getTransaction(), this, waitForLock, forUpdate);
0: 
0: 		if (gotLock == false)
0: 		{
0: 			// this is a lockingPolicy error, if waitForLock should either 
0: 			// return true or throw a deadlock exception
0: 			if (SanityManager.DEBUG)
0: 				SanityManager.ASSERT(waitForLock == false, 
0: 					"lockContainer wait returns false");
0: 
0: 			container = null;
0: 
0:             throw StandardException.newException(SQLState.LOCK_TIMEOUT);
0: 		}
0: 
0: 		if ((mode & ContainerHandle.MODE_OPEN_FOR_LOCK_ONLY) == 0) 
0:         {
0: 
0: 			if (SanityManager.DEBUG) 
0:             {
0: 				SanityManager.ASSERT(container != null);
0: 			}
0: 
0: 			if (!container.use(this, forUpdate, droppedOK)) 
0:             {
0: 
0:                 // If we got a lock, but for some reason we can't open the
0:                 // table (like it doesn't exist), then call unlockContainer().
0:                 // In the normal case it would be called when the container
0:                 // handle was closed, but in this case the user is never going
0:                 // to get an "open" container handle back.  We can't call 
0:                 // close() here as we haven't done all the "open" stuff.
0:                 getLockingPolicy().unlockContainer(xact, this);
0: 
0: 				container = null;
0: 
0: 				return false;
0: 			}
0: 			active = true;
0: 		} 
0:         else 
0:         {
0: 			// lock only, we only observe the transaction if
0: 			// we are performing row level locking.
0: 			if (getLockingPolicy().getMode() != LockingPolicy.MODE_RECORD)
0: 				return true;
0: 		}
0: 
0: 		// watch transaction so we will close handle just before xact completes.
0: 		xact.addObserver(this);
0: 
0: 
0: 		// Add special objects implementing certain behaviour at commit/rollback
0: 
0: 		if ((mode & (ContainerHandle.MODE_READONLY | 
0:                      ContainerHandle.MODE_NO_ACTIONS_ON_COMMIT)) == 0) 
0:         {
0: 			if ((mode & MODE_TRUNCATE_ON_COMMIT) == MODE_TRUNCATE_ON_COMMIT) 
0:             {
0: 				xact.addObserver(
0:                     new TruncateOnCommit(identity, true /* always */));
0: 			} 
0:             else if ((mode & MODE_TRUNCATE_ON_ROLLBACK) == 
0:                                         MODE_TRUNCATE_ON_ROLLBACK) 
0:             {
0: 				xact.addObserver(
0:                     new TruncateOnCommit(identity, false /* rollbacks only */));
0: 			}
0: 
0: 			if ((mode & MODE_DROP_ON_COMMIT) == MODE_DROP_ON_COMMIT) 
0:             {
0: 				xact.addObserver(new DropOnCommit(identity));				
0: 			}
0: 
0: 			if ((mode & MODE_FLUSH_ON_COMMIT) == MODE_FLUSH_ON_COMMIT) 
0:             {
0: 				xact.addObserver(new SyncOnCommit(identity));
0: 			}
0: 		}
0: 
0: 		return true;
0: 	}
0: 
0: 	/**
0: 		Return the RawTransaction I was opened in.
0: 	*/
0: 	public final RawTransaction getTransaction() 
0:     {
0: 
0: 		if (SanityManager.DEBUG) 
0:         {
0: 			SanityManager.ASSERT(xact != null);
0: 		}
0: 
0: 		return xact;
0: 	}
0: 
0: 	/**
0: 		Return my locking policy, may be different from the Transaction's
0: 		default locking policy.
0: 	*/
0: 	public final LockingPolicy getLockingPolicy() 
0:     {
0: 
0: 		if (SanityManager.DEBUG) 
0:         {
0: 			SanityManager.ASSERT(locking != null);
0: 		}
0: 
0: 		return locking;
0: 	}
0: 
0: 	public final void setLockingPolicy(LockingPolicy newLockingPolicy) 
0:     {
0: 		locking = newLockingPolicy;
0: 	}
0: 
0: 	/**
0: 		Was I opened for updates?
0: 
0: 		<BR> MT - thread safe
0: 	*/
0: 	public final boolean updateOK() 
0:     {
0: 		return forUpdate;
0: 	}
0: 
0: 	/**
0: 		Get the mode I was opened with.
0: 	*/
0: 	public int getMode() 
0:     {
0: 		return mode;
0: 	}
0: 
0: 	/**
0: 	   The container is about to be modified.
0: 	   Loggable actions use this to make sure the container gets cleaned if a
0: 	   checkpoint is taken after any log record is sent to the log stream but
0: 	   before the container is actually dirtied.
0: 
0: 		@exception StandardException Standard Cloudscape error policy
0: 	 */
0: 	public void preDirty(boolean preDirtyOn) throws StandardException 
0:     {
0: 
0: 		checkUpdateOpen();
0: 
0: 		container.preDirty(preDirtyOn);
0: 
0: 	}
0: 
0: 	/**
0: 		@see ContainerHandle#isTemporaryContainer
0: 		@exception StandardException Standard Cloudscape error policy
0: 	 */
0: 	public boolean isTemporaryContainer() throws StandardException 
0:     {
0: 
0: 		checkOpen();
0: 
0: 		return (identity != null && 
0: 				identity.getSegmentId() == ContainerHandle.TEMPORARY_SEGMENT);
0: 	}
0: 
0: 	/*
0: 	** Implementation specific methods for myself and my sub-classes
0: 	*/
0: 
0: 	protected void checkOpen() throws StandardException 
0:     {
0: 		if (!active)
0: 			throw StandardException.newException(
0:                     SQLState.DATA_CONTAINER_CLOSED);
0: 	}
0: 
0: 
0:     private void checkUpdateOpen() throws StandardException 
0:     {
0: 
0: 		if (!active)
0:         {
0: 			throw StandardException.newException(
0:                     SQLState.DATA_CONTAINER_CLOSED);
0:         }
0: 
0: 		if (!forUpdate)
0:         {
0: 			throw StandardException.newException(
0:                     SQLState.DATA_CONTAINER_READ_ONLY);
0:         }
0: 	}
0: 
0: 	protected void informObservers() 
0:     {
0: 
0: 		// notify our observers (Pages) that we are closing, 
0:         // or undergoing some state change ...
0: 
0: 		if (countObservers() != 0) 
0:         {
0: 			setChanged();
0: 			notifyObservers();
0: 		}
0: 	}
0: 
0: 
0:     /**
0:     Get information about space used by the container.
0:     **/
0:     public SpaceInfo getSpaceInfo()
0:         throws StandardException
0:     {
0:         return container.getSpaceInfo(this);
0:     }
0: 
0:     
0:     public String toString()
0:     {
0:         if (SanityManager.DEBUG)
0:         {
0:             String str = new String();
0:             str += "BaseContainerHandle:(" + identity.toString() + ")";
0:             return(str);
0:         }
0:         else
0:         {
0:             return(super.toString());
0:         }
0:     }
0: 
0: }
============================================================================