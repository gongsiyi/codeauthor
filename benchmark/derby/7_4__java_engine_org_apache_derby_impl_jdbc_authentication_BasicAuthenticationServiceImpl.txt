2:eac0369: /*
1:1ede0a8: 
1:345de35:    Derby - Class org.apache.derby.impl.jdbc.authentication.BasicAuthenticationServiceImpl
1:345de35: 
1:88a3cb9:    Licensed to the Apache Software Foundation (ASF) under one or more
1:88a3cb9:    contributor license agreements.  See the NOTICE file distributed with
1:88a3cb9:    this work for additional information regarding copyright ownership.
1:88a3cb9:    The ASF licenses this file to you under the Apache License, Version 2.0
1:88a3cb9:    (the "License"); you may not use this file except in compliance with
1:88a3cb9:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:345de35: 
3:eac0369:  */
7:eac0369: 
1:eac0369: package org.apache.derby.impl.jdbc.authentication;
1:eac0369: 
1:a84fc26: import org.apache.derby.iapi.sql.dictionary.PasswordHasher;
1:7233e33: import org.apache.derby.iapi.reference.Attribute;
1:3b82686: import org.apache.derby.iapi.reference.SQLState;
1:eac0369: import org.apache.derby.authentication.UserAuthenticator;
1:eac0369: import org.apache.derby.iapi.services.property.PropertyUtil;
1:eac0369: import org.apache.derby.iapi.services.monitor.Monitor;
1:dcd69d3: import org.apache.derby.iapi.store.access.TransactionController;
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: import org.apache.derby.iapi.util.StringUtil;
1:60edeb0: import org.apache.derby.impl.jdbc.Util;
1:eac0369: 
1:eac0369: import java.util.Properties;
1:eac0369: // security imports - for SHA-1 digest
1:eac0369: import java.security.MessageDigest;
1:eac0369: import java.security.NoSuchAlgorithmException;
1:60edeb0: import java.sql.SQLException;
1:eac0369: 
2:eac0369: /**
1:94f158a:  * This authentication service is the basic Derby user authentication
1:eac0369:  * level support.
1:eac0369:  *
1:eac0369:  * It is activated upon setting derby.authentication.provider database
1:eac0369:  * or system property to 'BUILTIN'.
1:eac0369:  * <p>
1:dbed020:  * It instantiates and calls the basic User authentication scheme at runtime.
1:eac0369:  * <p>
1:eac0369:  * In 2.0, users can now be defined as database properties.
1:eac0369:  * If derby.database.propertiesOnly is set to true, then in this
1:eac0369:  * case, only users defined as database properties for the current database
1:eac0369:  * will be considered.
1:eac0369:  *
1:eac0369:  */
1:eac0369: public final class BasicAuthenticationServiceImpl
1:eac0369: 	extends AuthenticationServiceBase implements UserAuthenticator {
1:eac0369: 
1:eac0369: 	//
1:eac0369: 	// ModuleControl implementation (overriden)
1:eac0369: 	//
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 *  Check if we should activate this authentication service.
1:eac0369: 	 */
1:eac0369: 	public boolean canSupport(Properties properties) {
1:eac0369: 
1:eac0369: 		if (!requireAuthentication(properties))
3:eac0369: 			return false;
1:eac0369: 
1:eac0369: 		//
1:eac0369: 		// We check 2 System/Database properties:
1:eac0369: 		//
1:eac0369: 		//
1:eac0369: 		// - if derby.authentication.provider is set to 'BUILTIN'.
1:eac0369: 		//
1:eac0369: 		// and in that case we are the authentication service that should
1:eac0369: 		// be run.
1:eac0369: 		//
1:eac0369: 
1:eac0369: 		String authenticationProvider = PropertyUtil.getPropertyFromSet(
1:eac0369: 					properties,
1:eac0369: 					org.apache.derby.iapi.reference.Property.AUTHENTICATION_PROVIDER_PARAMETER);
1:eac0369: 
1:eac0369: 		if ( (authenticationProvider != null) &&
1:eac0369: 			 (authenticationProvider.length() != 0) &&
1:eac0369: 			 (!(StringUtil.SQLEqualsIgnoreCase(authenticationProvider,
1:eac0369: 				  org.apache.derby.iapi.reference.Property.AUTHENTICATION_PROVIDER_BUILTIN))))
1:eac0369: 			return false;
1:eac0369: 		else
1:eac0369: 			return true;	// Yep, we're on!
3:eac0369: 	}
1:60edeb0: 
1:60edeb0: 	/**
1:eac0369: 	 * @see org.apache.derby.iapi.services.monitor.ModuleControl#boot
1:eac0369: 	 * @exception StandardException upon failure to load/boot the expected
1:eac0369: 	 * authentication service.
1:eac0369: 	 */
1:eac0369: 	public void boot(boolean create, Properties properties)
1:eac0369: 	  throws StandardException {
1:eac0369: 
1:eac0369: 		// We need authentication
1:eac0369: 		// setAuthentication(true);
1:eac0369: 
1:eac0369: 		// we call the super in case there is anything to get initialized.
1:eac0369: 		super.boot(create, properties);
1:eac0369: 
1:eac0369: 		// Initialize the MessageDigest class engine here
1:eac0369: 		// (we don't need to do that ideally, but there is some
1:eac0369: 		// overhead the first time it is instantiated.
1:eac0369: 		// SHA-1 is expected in jdk 1.1x and jdk1.2
1:eac0369: 		// This is a standard name: check,
1:eac0369: 		// http://java.sun.com/products/jdk/1.{1,2}
1:eac0369: 		//					/docs/guide/security/CryptoSpec.html#AppA 
1:eac0369: 		try {
1:eac0369: 			MessageDigest digestAlgorithm = MessageDigest.getInstance("SHA-1");
1:eac0369: 			digestAlgorithm.reset();
1:eac0369: 
1:eac0369: 		} catch (NoSuchAlgorithmException nsae) {
1:eac0369: 			throw Monitor.exceptionStartingModule(nsae);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// Set ourselves as being ready and loading the proper
1:eac0369: 		// authentication scheme for this service
1:eac0369: 		//
1:eac0369: 		this.setAuthenticationService(this);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** UserAuthenticator methods.
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Authenticate the passed-in user's credentials.
1:eac0369: 	 *
1:eac0369: 	 * @param userName		The user's name used to connect to JBMS system
1:eac0369: 	 * @param userPassword	The user's password used to connect to JBMS system
1:eac0369: 	 * @param databaseName	The database which the user wants to connect to.
1:eac0369: 	 * @param info			Additional jdbc connection info.
1:eac0369: 	 */
1:eac0369: 	public boolean	authenticateUser(String userName,
1:eac0369: 								 String userPassword,
1:eac0369: 								 String databaseName,
1:eac0369: 								 Properties info
1:eac0369: 									)
1:60edeb0:             throws SQLException
1:eac0369: 	{
1:7233e33:         // Client security mechanism if any specified
1:7233e33:         // Note: Right now it is only used to handle clients authenticating
1:7233e33:         // via DRDA SECMEC_USRSSBPWD mechanism
1:7233e33:         String clientSecurityMechanism = null;
1:7233e33:         // Client security mechanism (if any) short representation
1:7233e33:         // Default value is none.
1:7233e33:         int secMec = 0;
1:7233e33: 
1:eac0369: 		// let's check if the user has been defined as a valid user of the
1:eac0369: 		// JBMS system.
1:eac0369: 		// We expect to find and match a System property corresponding to the
1:eac0369: 		// credentials passed-in.
1:eac0369: 		//
1:eac0369: 		if (userName == null)
1:eac0369: 			// We don't tolerate 'guest' user for now.
1:eac0369: 			return false;
1:eac0369: 
1:7233e33: 		String definedUserPassword = null, passedUserPassword = null;
1:7233e33: 
1:7233e33:         // If a security mechanism is specified as part of the connection
1:7233e33:         // properties, it indicates that we've to account as far as how the
1:7233e33:         // password is presented to us - in the case of SECMEC_USRSSBPWD
1:7233e33:         // (only expected one at the moment), the password is a substitute
1:7233e33:         // one which has already been hashed differently than what we store
1:7233e33:         // at the database level (for instance) - this will influence how we
1:7233e33:         // assess the substitute password to be legitimate for Derby's
1:7233e33:         // BUILTIN authentication scheme/provider.
1:7233e33:         if ((clientSecurityMechanism =
1:cb29d72:                 info.getProperty(Attribute.DRDA_SECMEC)) != null)
1:7233e33:         {
1:7233e33:             secMec = Integer.parseInt(clientSecurityMechanism);
1:7233e33:         }
1:7233e33: 
1:eac0369: 		//
1:eac0369: 		// Check if user has been defined at the database or/and
1:eac0369: 		// system level. The user (administrator) can configure it the
1:eac0369: 		// way he/she wants (as well as forcing users properties to
1:eac0369: 		// be retrieved at the datbase level only).
1:eac0369: 		//
1:7233e33:         String userNameProperty =
1:7233e33:           org.apache.derby.iapi.reference.Property.USER_PROPERTY_PREFIX.concat(
1:7233e33:                         userName);
1:eac0369: 
1:eac0369: 		// check if user defined at the database level
1:eac0369: 		definedUserPassword = getDatabaseProperty(userNameProperty);
1:eac0369: 
1:7233e33:         if (definedUserPassword != null)
1:7233e33:         {
1:7233e33:             if (secMec != SECMEC_USRSSBPWD)
1:7233e33:             {
1:5d3b815:                 // hash passed-in password
1:60edeb0:                 try {
1:5d3b815:                     passedUserPassword = hashPasswordUsingStoredAlgorithm(
1:60edeb0:                             userName, userPassword, definedUserPassword);
1:60edeb0:                 } catch (StandardException se) {
1:60edeb0:                     // The UserAuthenticator interface does not allow us to
1:60edeb0:                     // throw a StandardException, so convert to SQLException.
1:60edeb0:                     throw Util.generateCsSQLException(se);
1:7233e33:                 }
1:60edeb0:             }
1:7233e33:             else
1:7233e33:             {
1:7233e33:                 // Dealing with a client SECMEC - password checking is
1:7233e33:                 // slightly different and we need to generate a
1:7233e33:                 // password substitute to compare with the substitute
1:7233e33:                 // generated one from the client.
1:7233e33:                 definedUserPassword = substitutePassword(userName,
1:7233e33:                                                          definedUserPassword,
1:7233e33:                                                          info, true);
1:7233e33:                 // As SecMec is SECMEC_USRSSBPWD, expected passed-in password
1:7233e33:                 // to be HexString'ified already
1:7233e33:                 passedUserPassword = userPassword;
1:7233e33:             }
1:7233e33:         }
1:7233e33:         else
1:7233e33:         {
1:dcd69d3:             // DERBY-5539: Generate a hashed token even if the user is not
1:dcd69d3:             // defined at the database level (that is, the user is defined at
1:dcd69d3:             // the system level or does not exist at all). If we don't do that,
1:dcd69d3:             // authentication failures would take less time for non-existing
1:dcd69d3:             // users than they would for existing users, since generating the
1:dcd69d3:             // hashed token is a relatively expensive operation. Attackers
1:dcd69d3:             // could use this to determine if a user exists. By generating the
1:dcd69d3:             // hashed token also for non-existing users, authentication
1:dcd69d3:             // failures will take the same time for existing and non-existing
1:dcd69d3:             // users, and it will be more difficult for attackers to tell the
1:dcd69d3:             // difference.
1:dcd69d3:             try {
1:dcd69d3:                 Properties props = getDatabaseProperties();
1:dcd69d3:                 if (props != null) {
1:5d3b815:                     hashUsingDefaultAlgorithm(
1:dcd69d3:                             userName, userPassword, props);
1:dcd69d3:                 }
1:dcd69d3:             } catch (StandardException se) {
1:dcd69d3:                 throw Util.generateCsSQLException(se);
1:dcd69d3:             }
1:dcd69d3: 
1:7233e33:             // check if user defined at the system level
1:7233e33:             definedUserPassword = getSystemProperty(userNameProperty);
1:7233e33:             passedUserPassword = userPassword;
1:eac0369: 
1:7233e33:             if ((definedUserPassword != null) &&
1:7233e33:                 (secMec == SECMEC_USRSSBPWD))
1:7233e33:             {
1:7233e33:                 // Dealing with a client SECMEC - see above comments
1:7233e33:                 definedUserPassword = substitutePassword(userName,
1:7233e33:                                                          definedUserPassword,
1:7233e33:                                                          info, false);
1:7233e33:             }
1:7233e33:         }
1:eac0369: 
1:3b82686:         // Check if the passwords match.
1:eac0369: 		// NOTE: We do not look at the passed-in database name value as
1:eac0369: 		// we rely on the authorization service that was put in
1:eac0369: 		// in 2.0 . (if a database name was passed-in)
1:3b82686:         boolean passwordsMatch =
1:3b82686:                 (definedUserPassword != null) &&
1:3b82686:                 definedUserPassword.equals(passedUserPassword);
1:eac0369: 
1:3b82686:         // Provide extra information on mismatch if strong password
1:3b82686:         // substitution is used, since the problem may be that the stored
1:3b82686:         // password was stored using the configurable hash authentication
1:3b82686:         // scheme which is incompatible with strong password substitution.
1:3b82686:         if (!passwordsMatch && secMec == SECMEC_USRSSBPWD) {
1:3b82686:             throw Util.generateCsSQLException(
1:3b82686:                     SQLState.NET_CONNECT_SECMEC_INCOMPATIBLE_SCHEME);
1:3b82686:         }
1:3b82686: 
1:3b82686:         return passwordsMatch;
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:5d3b815:      * Hash a password using the same algorithm as we used to generate the
1:60edeb0:      * stored password token.
1:60edeb0:      *
1:5d3b815:      * @param user the user whose password to hash
1:60edeb0:      * @param password the plaintext password
1:60edeb0:      * @param storedPassword the password token that's stored in the database
1:60edeb0:      * @return a digest of the password created the same way as the stored
1:60edeb0:      *         password
1:5d3b815:      * @throws StandardException if the password cannot be hashed with the
1:60edeb0:      *         requested algorithm
1:60edeb0:      */
1:5d3b815:     private String hashPasswordUsingStoredAlgorithm(
1:60edeb0:                 String user, String password, String storedPassword)
1:60edeb0:             throws StandardException
1:60edeb0:     {
1:a84fc26:         if (storedPassword.startsWith( PasswordHasher.ID_PATTERN_SHA1_SCHEME )) {
1:5d3b815:             return hashPasswordSHA1Scheme(password);
1:a84fc26:         }
1:a84fc26:         else
1:a84fc26:         {
1:a84fc26:             PasswordHasher  hasher = new PasswordHasher( storedPassword );
1:eac0369: 
1:a84fc26:             return hasher.hashAndEncode( user, password );
1:60edeb0:         }
1:60edeb0:     }
1:60edeb0: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1:  * It instantiates and calls the basic User authentication scheme at runtime.
commit:a84fc26
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.dictionary.PasswordHasher;
/////////////////////////////////////////////////////////////////////////
1:         if (storedPassword.startsWith( PasswordHasher.ID_PATTERN_SHA1_SCHEME )) {
1:         }
1:         else
1:         {
1:             PasswordHasher  hasher = new PasswordHasher( storedPassword );
1:             return hasher.hashAndEncode( user, password );
commit:7233e33
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.reference.Attribute;
/////////////////////////////////////////////////////////////////////////
1:         // Client security mechanism if any specified
1:         // Note: Right now it is only used to handle clients authenticating
1:         // via DRDA SECMEC_USRSSBPWD mechanism
1:         String clientSecurityMechanism = null;
1:         // Client security mechanism (if any) short representation
1:         // Default value is none.
1:         int secMec = 0;
1: 
/////////////////////////////////////////////////////////////////////////
1: 		String definedUserPassword = null, passedUserPassword = null;
1: 
1:         // If a security mechanism is specified as part of the connection
1:         // properties, it indicates that we've to account as far as how the
1:         // password is presented to us - in the case of SECMEC_USRSSBPWD
1:         // (only expected one at the moment), the password is a substitute
1:         // one which has already been hashed differently than what we store
1:         // at the database level (for instance) - this will influence how we
1:         // assess the substitute password to be legitimate for Derby's
1:         // BUILTIN authentication scheme/provider.
1:         if ((clientSecurityMechanism =
0:                 info.getProperty(Attribute.CLIENT_SECURITY_MECHANISM)) != null)
1:         {
1:             secMec = Integer.parseInt(clientSecurityMechanism);
1:         }
1: 
1:         String userNameProperty =
1:           org.apache.derby.iapi.reference.Property.USER_PROPERTY_PREFIX.concat(
1:                         userName);
1:         if (definedUserPassword != null)
1:         {
1:             if (secMec != SECMEC_USRSSBPWD)
1:             {
0:                 // encrypt passed-in password
0:                 passedUserPassword = encryptPassword(userPassword);
1:             }
1:             else
1:             {
1:                 // Dealing with a client SECMEC - password checking is
1:                 // slightly different and we need to generate a
1:                 // password substitute to compare with the substitute
1:                 // generated one from the client.
1:                 definedUserPassword = substitutePassword(userName,
1:                                                          definedUserPassword,
1:                                                          info, true);
1:                 // As SecMec is SECMEC_USRSSBPWD, expected passed-in password
1:                 // to be HexString'ified already
1:                 passedUserPassword = userPassword;
1:             }
1:         }
1:         else
1:         {
1:             // check if user defined at the system level
1:             definedUserPassword = getSystemProperty(userNameProperty);
1:             passedUserPassword = userPassword;
1:             if ((definedUserPassword != null) &&
1:                 (secMec == SECMEC_USRSSBPWD))
1:             {
1:                 // Dealing with a client SECMEC - see above comments
1:                 definedUserPassword = substitutePassword(userName,
1:                                                          definedUserPassword,
1:                                                          info, false);
1:             }
1:         }
/////////////////////////////////////////////////////////////////////////
commit:88a3cb9
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:5d3b815
/////////////////////////////////////////////////////////////////////////
1:                 // hash passed-in password
1:                     passedUserPassword = hashPasswordUsingStoredAlgorithm(
/////////////////////////////////////////////////////////////////////////
1:                     hashUsingDefaultAlgorithm(
/////////////////////////////////////////////////////////////////////////
1:      * Hash a password using the same algorithm as we used to generate the
1:      * @param user the user whose password to hash
1:      * @throws StandardException if the password cannot be hashed with the
1:     private String hashPasswordUsingStoredAlgorithm(
1:             return hashPasswordSHA1Scheme(password);
commit:dcd69d3
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.store.access.TransactionController;
/////////////////////////////////////////////////////////////////////////
1:             // DERBY-5539: Generate a hashed token even if the user is not
1:             // defined at the database level (that is, the user is defined at
1:             // the system level or does not exist at all). If we don't do that,
1:             // authentication failures would take less time for non-existing
1:             // users than they would for existing users, since generating the
1:             // hashed token is a relatively expensive operation. Attackers
1:             // could use this to determine if a user exists. By generating the
1:             // hashed token also for non-existing users, authentication
1:             // failures will take the same time for existing and non-existing
1:             // users, and it will be more difficult for attackers to tell the
1:             // difference.
1:             try {
1:                 Properties props = getDatabaseProperties();
1:                 if (props != null) {
0:                     encryptUsingDefaultAlgorithm(
1:                             userName, userPassword, props);
1:                 }
1:             } catch (StandardException se) {
1:                 throw Util.generateCsSQLException(se);
1:             }
1: 
commit:1ede0a8
/////////////////////////////////////////////////////////////////////////
0:             return encryptPasswordConfigurableScheme(
0:                     user, password, algorithm, null, 1);
0:         } else if (storedPassword.startsWith(
0:                         ID_PATTERN_CONFIGURABLE_STRETCHED_SCHEME)) {
0:             int saltPos = storedPassword.indexOf(SEPARATOR_CHAR) + 1;
0:             int iterPos = storedPassword.indexOf(SEPARATOR_CHAR, saltPos) + 1;
0:             int algoPos = storedPassword.indexOf(SEPARATOR_CHAR, iterPos) + 1;
1: 
0:             byte[] salt = StringUtil.fromHexString(
0:                     storedPassword, saltPos, iterPos - saltPos - 1);
0:             int iterations = Integer.parseInt(
0:                     storedPassword.substring(iterPos, algoPos - 1));
0:             String algorithm = storedPassword.substring(algoPos);
0:             return encryptPasswordConfigurableScheme(
0:                     user, password, algorithm, salt, iterations);
commit:3b82686
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.reference.SQLState;
/////////////////////////////////////////////////////////////////////////
1:         // Check if the passwords match.
1:         boolean passwordsMatch =
1:                 (definedUserPassword != null) &&
1:                 definedUserPassword.equals(passedUserPassword);
1:         // Provide extra information on mismatch if strong password
1:         // substitution is used, since the problem may be that the stored
1:         // password was stored using the configurable hash authentication
1:         // scheme which is incompatible with strong password substitution.
1:         if (!passwordsMatch && secMec == SECMEC_USRSSBPWD) {
1:             throw Util.generateCsSQLException(
1:                     SQLState.NET_CONNECT_SECMEC_INCOMPATIBLE_SCHEME);
1:         }
1: 
1:         return passwordsMatch;
commit:60edeb0
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.impl.jdbc.Util;
1: import java.sql.SQLException;
/////////////////////////////////////////////////////////////////////////
1:             throws SQLException
/////////////////////////////////////////////////////////////////////////
1:                 try {
0:                     passedUserPassword = encryptPasswordUsingStoredAlgorithm(
1:                             userName, userPassword, definedUserPassword);
1:                 } catch (StandardException se) {
1:                     // The UserAuthenticator interface does not allow us to
1:                     // throw a StandardException, so convert to SQLException.
1:                     throw Util.generateCsSQLException(se);
1:                 }
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
0:      * Encrypt a password using the same algorithm as we used to generate the
1:      * stored password token.
1:      *
0:      * @param user the user whose password to encrypt
1:      * @param password the plaintext password
1:      * @param storedPassword the password token that's stored in the database
1:      * @return a digest of the password created the same way as the stored
1:      *         password
0:      * @throws StandardException if the password cannot be encrypted with the
1:      *         requested algorithm
1:      */
0:     private String encryptPasswordUsingStoredAlgorithm(
1:                 String user, String password, String storedPassword)
1:             throws StandardException
1:     {
0:         if (storedPassword.startsWith(ID_PATTERN_SHA1_SCHEME)) {
0:             return encryptPasswordSHA1Scheme(password);
0:         } else if (storedPassword.startsWith(
0:                         ID_PATTERN_CONFIGURABLE_HASH_SCHEME)) {
0:             String algorithm = storedPassword.substring(
0:                     storedPassword.indexOf(SEPARATOR_CHAR) + 1);
0:             return encryptPasswordConfigurableScheme(user, password, algorithm);
0:         } else {
0:             if (SanityManager.DEBUG) {
0:                 SanityManager.THROWASSERT(
0:                         "Unknown authentication scheme for token " +
0:                         storedPassword);
1:             }
0:             return null;
1:         }
1:     }
commit:cb29d72
/////////////////////////////////////////////////////////////////////////
1:                 info.getProperty(Attribute.DRDA_SECMEC)) != null)
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:94f158a
/////////////////////////////////////////////////////////////////////////
1:  * This authentication service is the basic Derby user authentication
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.jdbc.authentication.BasicAuthenticationServiceImpl
1: 
0:    Copyright 1998, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:1f9b9c4
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.jdbc.authentication
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.jdbc.authentication;
1: 
0: import org.apache.derby.iapi.reference.MessageId;
1: import org.apache.derby.authentication.UserAuthenticator;
1: import org.apache.derby.iapi.services.property.PropertyUtil;
0: import org.apache.derby.iapi.services.daemon.Serviceable;
0: import org.apache.derby.iapi.services.monitor.ModuleFactory;
1: import org.apache.derby.iapi.services.monitor.Monitor;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.services.i18n.MessageService;
0: import org.apache.derby.iapi.store.access.TransactionController;
0: import org.apache.derby.iapi.jdbc.AuthenticationService;
1: import org.apache.derby.iapi.util.StringUtil;
1: 
1: import java.util.Properties;
1: // security imports - for SHA-1 digest
1: import java.security.MessageDigest;
1: import java.security.NoSuchAlgorithmException;
0: import java.io.Serializable;
0: import java.util.Dictionary;
1: 
1: /**
0:  * This authentication service is the basic Cloudscape User authentication
1:  * level support.
1:  *
1:  * It is activated upon setting derby.authentication.provider database
1:  * or system property to 'BUILTIN'.
1:  * <p>
0:  * It instantiates & calls the basic User authentication scheme at runtime.
1:  * <p>
1:  * In 2.0, users can now be defined as database properties.
1:  * If derby.database.propertiesOnly is set to true, then in this
1:  * case, only users defined as database properties for the current database
1:  * will be considered.
1:  *
0:  * @author Francois
1:  */
1: public final class BasicAuthenticationServiceImpl
1: 	extends AuthenticationServiceBase implements UserAuthenticator {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
1: 
1: 	//
1: 	// ModuleControl implementation (overriden)
1: 	//
1: 
1: 	/**
1: 	 *  Check if we should activate this authentication service.
1: 	 */
1: 	public boolean canSupport(Properties properties) {
1: 
1: 		if (!requireAuthentication(properties))
1: 			return false;
1: 
1: 		//
1: 		// We check 2 System/Database properties:
1: 		//
1: 		//
1: 		// - if derby.authentication.provider is set to 'BUILTIN'.
1: 		//
1: 		// and in that case we are the authentication service that should
1: 		// be run.
1: 		//
1: 
1: 		String authenticationProvider = PropertyUtil.getPropertyFromSet(
1: 					properties,
1: 					org.apache.derby.iapi.reference.Property.AUTHENTICATION_PROVIDER_PARAMETER);
1: 
1: 		if ( (authenticationProvider != null) &&
1: 			 (authenticationProvider.length() != 0) &&
1: 			 (!(StringUtil.SQLEqualsIgnoreCase(authenticationProvider,
1: 				  org.apache.derby.iapi.reference.Property.AUTHENTICATION_PROVIDER_BUILTIN))))
1: 			return false;
1: 		else
1: 			return true;	// Yep, we're on!
1: 	}
1: 
1: 	/**
1: 	 * @see org.apache.derby.iapi.services.monitor.ModuleControl#boot
1: 	 * @exception StandardException upon failure to load/boot the expected
1: 	 * authentication service.
1: 	 */
1: 	public void boot(boolean create, Properties properties)
1: 	  throws StandardException {
1: 
1: 		// We need authentication
1: 		// setAuthentication(true);
1: 
1: 		// we call the super in case there is anything to get initialized.
1: 		super.boot(create, properties);
1: 
1: 		// Initialize the MessageDigest class engine here
1: 		// (we don't need to do that ideally, but there is some
1: 		// overhead the first time it is instantiated.
1: 		// SHA-1 is expected in jdk 1.1x and jdk1.2
1: 		// This is a standard name: check,
1: 		// http://java.sun.com/products/jdk/1.{1,2}
1: 		//					/docs/guide/security/CryptoSpec.html#AppA 
1: 		try {
1: 			MessageDigest digestAlgorithm = MessageDigest.getInstance("SHA-1");
1: 			digestAlgorithm.reset();
1: 
1: 		} catch (NoSuchAlgorithmException nsae) {
1: 			throw Monitor.exceptionStartingModule(nsae);
1: 		}
1: 
1: 		// Set ourselves as being ready and loading the proper
1: 		// authentication scheme for this service
1: 		//
1: 		this.setAuthenticationService(this);
1: 	}
1: 
1: 	/*
1: 	** UserAuthenticator methods.
1: 	*/
1: 
1: 	/**
1: 	 * Authenticate the passed-in user's credentials.
1: 	 *
1: 	 * @param userName		The user's name used to connect to JBMS system
1: 	 * @param userPassword	The user's password used to connect to JBMS system
1: 	 * @param databaseName	The database which the user wants to connect to.
1: 	 * @param info			Additional jdbc connection info.
1: 	 */
1: 	public boolean	authenticateUser(String userName,
1: 								 String userPassword,
1: 								 String databaseName,
1: 								 Properties info
1: 									)
1: 	{
1: 		// let's check if the user has been defined as a valid user of the
1: 		// JBMS system.
1: 		// We expect to find and match a System property corresponding to the
1: 		// credentials passed-in.
1: 		//
1: 		if (userName == null)
1: 			// We don't tolerate 'guest' user for now.
1: 			return false;
1: 
1: 		//
1: 		// Check if user has been defined at the database or/and
1: 		// system level. The user (administrator) can configure it the
1: 		// way he/she wants (as well as forcing users properties to
1: 		// be retrieved at the datbase level only).
1: 		//
0: 		String definedUserPassword = null, passedUserPassword = null;
1: 
0: 		String userNameProperty = org.apache.derby.iapi.reference.Property.USER_PROPERTY_PREFIX.concat(userName);
1: 
1: 		// check if user defined at the database level
1: 		definedUserPassword = getDatabaseProperty(userNameProperty);
1: 
0: 		if (definedUserPassword != null) {
0: 			// encrypt passed-in password
0: 			passedUserPassword = encryptPassword(userPassword);
1: 
0: 		} else {
1: 
0: 			// check if user defined at the system level
0: 			definedUserPassword = getSystemProperty(userNameProperty);
0: 			passedUserPassword = userPassword;
1: 		}
1: 
0: 		if (definedUserPassword == null)
0: 			// no such user found
1: 			return false;
1: 
0: 		// check if the passwords match
0: 		if (!definedUserPassword.equals(passedUserPassword))
1: 			return false;
1: 
1: 		// NOTE: We do not look at the passed-in database name value as
1: 		// we rely on the authorization service that was put in
1: 		// in 2.0 . (if a database name was passed-in)
1: 
0: 		// We do have a valid user
0: 		return true;
1: 	}
1: 
1: 	/*
0: 	** Encryption related methods.
1: 	*/
1: }
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.jdbc.authentication
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.jdbc.authentication;
0: 
0: import org.apache.derby.iapi.reference.MessageId;
0: import org.apache.derby.authentication.UserAuthenticator;
0: import org.apache.derby.iapi.services.property.PropertyUtil;
0: import org.apache.derby.iapi.services.daemon.Serviceable;
0: import org.apache.derby.iapi.services.monitor.ModuleFactory;
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.services.i18n.MessageService;
0: import org.apache.derby.iapi.store.access.TransactionController;
0: import org.apache.derby.iapi.jdbc.AuthenticationService;
0: import org.apache.derby.iapi.util.StringUtil;
0: 
0: import java.util.Properties;
0: // security imports - for SHA-1 digest
0: import java.security.MessageDigest;
0: import java.security.NoSuchAlgorithmException;
0: import java.io.Serializable;
0: import java.util.Dictionary;
0: 
0: /**
0:  * This authentication service is the basic Cloudscape User authentication
0:  * level support.
0:  *
0:  * It is activated upon setting derby.authentication.provider database
0:  * or system property to 'BUILTIN'.
0:  * <p>
0:  * It instantiates & calls the basic User authentication scheme at runtime.
0:  * <p>
0:  * In 2.0, users can now be defined as database properties.
0:  * If derby.database.propertiesOnly is set to true, then in this
0:  * case, only users defined as database properties for the current database
0:  * will be considered.
0:  *
0:  * @author Francois
0:  */
0: public final class BasicAuthenticationServiceImpl
0: 	extends AuthenticationServiceBase implements UserAuthenticator {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
0: 
0: 	//
0: 	// ModuleControl implementation (overriden)
0: 	//
0: 
0: 	/**
0: 	 *  Check if we should activate this authentication service.
0: 	 */
0: 	public boolean canSupport(Properties properties) {
0: 
0: 		if (!requireAuthentication(properties))
0: 			return false;
0: 
0: 		//
0: 		// We check 2 System/Database properties:
0: 		//
0: 		//
0: 		// - if derby.authentication.provider is set to 'BUILTIN'.
0: 		//
0: 		// and in that case we are the authentication service that should
0: 		// be run.
0: 		//
0: 
0: 		String authenticationProvider = PropertyUtil.getPropertyFromSet(
0: 					properties,
0: 					org.apache.derby.iapi.reference.Property.AUTHENTICATION_PROVIDER_PARAMETER);
0: 
0: 		if ( (authenticationProvider != null) &&
0: 			 (authenticationProvider.length() != 0) &&
0: 			 (!(StringUtil.SQLEqualsIgnoreCase(authenticationProvider,
0: 				  org.apache.derby.iapi.reference.Property.AUTHENTICATION_PROVIDER_BUILTIN))))
0: 			return false;
0: 		else
0: 			return true;	// Yep, we're on!
0: 	}
0: 
0: 	/**
0: 	 * @see org.apache.derby.iapi.services.monitor.ModuleControl#boot
0: 	 * @exception StandardException upon failure to load/boot the expected
0: 	 * authentication service.
0: 	 */
0: 	public void boot(boolean create, Properties properties)
0: 	  throws StandardException {
0: 
0: 		// We need authentication
0: 		// setAuthentication(true);
0: 
0: 		// we call the super in case there is anything to get initialized.
0: 		super.boot(create, properties);
0: 
0: 		// Initialize the MessageDigest class engine here
0: 		// (we don't need to do that ideally, but there is some
0: 		// overhead the first time it is instantiated.
0: 		// SHA-1 is expected in jdk 1.1x and jdk1.2
0: 		// This is a standard name: check,
0: 		// http://java.sun.com/products/jdk/1.{1,2}
0: 		//					/docs/guide/security/CryptoSpec.html#AppA 
0: 		try {
0: 			MessageDigest digestAlgorithm = MessageDigest.getInstance("SHA-1");
0: 			digestAlgorithm.reset();
0: 
0: 		} catch (NoSuchAlgorithmException nsae) {
0: 			throw Monitor.exceptionStartingModule(nsae);
0: 		}
0: 
0: 		// Set ourselves as being ready and loading the proper
0: 		// authentication scheme for this service
0: 		//
0: 		this.setAuthenticationService(this);
0: 	}
0: 
0: 	/*
0: 	** UserAuthenticator methods.
0: 	*/
0: 
0: 	/**
0: 	 * Authenticate the passed-in user's credentials.
0: 	 *
0: 	 * @param userName		The user's name used to connect to JBMS system
0: 	 * @param userPassword	The user's password used to connect to JBMS system
0: 	 * @param databaseName	The database which the user wants to connect to.
0: 	 * @param info			Additional jdbc connection info.
0: 	 */
0: 	public boolean	authenticateUser(String userName,
0: 								 String userPassword,
0: 								 String databaseName,
0: 								 Properties info
0: 									)
0: 	{
0: 		// let's check if the user has been defined as a valid user of the
0: 		// JBMS system.
0: 		// We expect to find and match a System property corresponding to the
0: 		// credentials passed-in.
0: 		//
0: 		if (userName == null)
0: 			// We don't tolerate 'guest' user for now.
0: 			return false;
0: 
0: 		//
0: 		// Check if user has been defined at the database or/and
0: 		// system level. The user (administrator) can configure it the
0: 		// way he/she wants (as well as forcing users properties to
0: 		// be retrieved at the datbase level only).
0: 		//
0: 		String definedUserPassword = null, passedUserPassword = null;
0: 
0: 		String userNameProperty = org.apache.derby.iapi.reference.Property.USER_PROPERTY_PREFIX.concat(userName);
0: 
0: 		// check if user defined at the database level
0: 		definedUserPassword = getDatabaseProperty(userNameProperty);
0: 
0: 		if (definedUserPassword != null) {
0: 			// encrypt passed-in password
0: 			passedUserPassword = encryptPassword(userPassword);
0: 
0: 		} else {
0: 
0: 			// check if user defined at the system level
0: 			definedUserPassword = getSystemProperty(userNameProperty);
0: 			passedUserPassword = userPassword;
0: 		}
0: 
0: 		if (definedUserPassword == null)
0: 			// no such user found
0: 			return false;
0: 
0: 		// check if the passwords match
0: 		if (!definedUserPassword.equals(passedUserPassword))
0: 			return false;
0: 
0: 		// NOTE: We do not look at the passed-in database name value as
0: 		// we rely on the authorization service that was put in
0: 		// in 2.0 . (if a database name was passed-in)
0: 
0: 		// We do have a valid user
0: 		return true;
0: 	}
0: 
0: 	/*
0: 	** Encryption related methods.
0: 	*/
0: }
============================================================================