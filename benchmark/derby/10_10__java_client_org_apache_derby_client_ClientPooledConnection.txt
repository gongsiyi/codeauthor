1:407e52d: /*
1:dadd05a: 
1:33776ff:    Derby - Class org.apache.derby.client.ClientPooledConnection
1:cbd0ff1: 
1:59bf37d:    Licensed to the Apache Software Foundation (ASF) under one or more
1:59bf37d:    contributor license agreements.  See the NOTICE file distributed with
1:59bf37d:    this work for additional information regarding copyright ownership.
1:59bf37d:    The ASF licenses this file to You under the Apache License, Version 2.0
1:59bf37d:    (the "License"); you may not use this file except in compliance with
1:59bf37d:    the License.  You may obtain a copy of the License at
28:33776ff: 
1:33776ff:       http://www.apache.org/licenses/LICENSE-2.0
1:33776ff: 
1:33776ff:    Unless required by applicable law or agreed to in writing, software
1:33776ff:    distributed under the License is distributed on an "AS IS" BASIS,
1:33776ff:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:33776ff:    See the License for the specific language governing permissions and
1:33776ff:    limitations under the License.
1:33776ff: 
1:b6594e1: */
1:33776ff: package org.apache.derby.client;
1:d506170: 
1:69e3d06: import java.sql.Connection;
1:69e3d06: import java.sql.PreparedStatement;
1:d506170: import java.sql.SQLException;
1:45a24ec: import java.util.ArrayList;
1:45a24ec: import java.util.Iterator;
1:9a0cdf1: import java.util.concurrent.CopyOnWriteArrayList;
1:4772c7e: import javax.sql.ConnectionEvent;
1:4772c7e: import javax.sql.ConnectionEventListener;
1:69e3d06: import javax.sql.PooledConnection;
1:9a0cdf1: import javax.sql.StatementEvent;
1:9a0cdf1: import javax.sql.StatementEventListener;
1:e65b4db: import org.apache.derby.client.am.ClientMessageId;
1:69e3d06: import org.apache.derby.client.am.ClientConnection;
1:b13b17c: import org.apache.derby.client.am.LogWriter;
1:b13b17c: import org.apache.derby.client.am.LogicalConnection;
1:33776ff: import org.apache.derby.client.am.SqlException;
1:9892638: import org.apache.derby.client.am.stmtcache.JDBCStatementCache;
1:4772c7e: import org.apache.derby.client.net.NetXAConnection;
1:4772c7e: import org.apache.derby.iapi.error.ExceptionSeverity;
1:7863d83: import org.apache.derby.jdbc.BasicClientDataSource40;
1:4772c7e: import org.apache.derby.jdbc.ClientDriver;
1:d506170: import org.apache.derby.shared.common.reference.SQLState;
1:33776ff: 
1:9892638: /**
1:b6594e1:  * A physical connection to a data source, to be used for creating logical
1:b6594e1:  * connections to the same data source.
1:b6594e1:  */
1:69e3d06: public class ClientPooledConnection implements PooledConnection {
1:b6594e1: 
1:b6594e1:     /** Tells if this pooled connection is newly created. */
1:70f7692:     private boolean newPC_ = true;
1:70f7692: 
1:45a24ec:     //@GuardedBy("this")
1:af3cf0c:     /** List of {@code ConnectionEventListener}s. Never {@code null}. */
1:4772c7e:     private ArrayList<ConnectionEventListener> listeners_ =
1:4772c7e:             new ArrayList<ConnectionEventListener>();
1:af3cf0c: 
1:af3cf0c:     /**
1:af3cf0c:      * The number of iterators going through the list of connection event
1:af3cf0c:      * listeners at the current time. Only one thread may be iterating over the
1:af3cf0c:      * list at any time (because of synchronization), but a single thread may
1:af3cf0c:      * have multiple iterators if for instance an event listener performs
1:af3cf0c:      * database calls that trigger a new event.
1:af3cf0c:      */
1:af3cf0c:     private int eventIterators;
1:af3cf0c: 
1:69e3d06:     ClientConnection physicalConnection_ = null;
1:b13b17c:     NetXAConnection netXAPhysicalConnection_ = null;
1:33776ff: 
1:b6594e1:     /**
1:9892638:      * The statement cache for the underlying physical connection.
1:9892638:      * <p>
1:9892638:      * This will be {@code null} if statement caching is disabled (default).
1:9892638:      */
1:9892638:     private final JDBCStatementCache statementCache;
1:9892638: 
1:b6594e1:     /** The logical connection using the physical connection. */
1:b6594e1:     //@GuardedBy("this")
1:b13b17c:     private LogicalConnection logicalConnection_ = null;
1:33776ff: 
1:b13b17c:     protected LogWriter logWriter_ = null;
1:33776ff: 
1:ee33904:     /** Resource manager identifier. */
1:70f7692:     protected int rmId_ = 0;
1:70f7692: 
1:b6594e1:     /**
1:9a0cdf1:      * List of statement event listeners. The list is copied on each write,
1:9a0cdf1:      * ensuring that it can be safely iterated over even if other threads or
1:9a0cdf1:      * the listeners fired in the same thread add or remove listeners.
1:9a0cdf1:      */
1:9a0cdf1:     private final CopyOnWriteArrayList<StatementEventListener>
1:9a0cdf1:             statementEventListeners =
1:9a0cdf1:                     new CopyOnWriteArrayList<StatementEventListener>();
1:9a0cdf1: 
1:9a0cdf1:     /**
1:b6594e1:      * Constructor for non-XA pooled connections.
1:b6594e1:      * <p>
1:b6594e1:      * Using standard Java APIs, a CPDS is passed in. Arguments for
1:b6594e1:      * user/password overrides anything on the data source.
1:b6594e1:      * 
1:b6594e1:      * @param ds data source creating this pooled connection
1:b6594e1:      * @param logWriter destination for log messages
1:b6594e1:      * @param user user name
1:b6594e1:      * @param password user password
1:b6594e1:      * @throws SQLException if creating the pooled connection fails due problems
1:b6594e1:      *      in the database, or problems communicating with the database
1:b6594e1:      */
1:7863d83:     public ClientPooledConnection(BasicClientDataSource40 ds,
1:b13b17c:                                   LogWriter logWriter,
2:70f7692:                                   String user,
1:d506170:                                   String password) throws SQLException {
1:9892638:         logWriter_ = logWriter;
1:9892638: 
1:9892638:         if (ds.maxStatementsToPool() <= 0) {
1:9892638:             this.statementCache = null;
1:9892638:         } else {
1:f3f832c:             this.statementCache =
1:f3f832c:                     new JDBCStatementCache(ds.maxStatementsToPool());
1:9892638:         }
1:1d49f56: 
1:9892638:         try {
1:407e52d:             //pass the client pooled connection instance to this
1:407e52d:             //instance of the NetConnection object 
1:407e52d:             //this object is then used to pass the close and the error events 
1:407e52d:             //that occur in the PreparedStatement object back to the 
1:407e52d:             //PooledConnection which will then raise the events
1:407e52d:             //on the listeners
1:407e52d:             
1:b565f41:             physicalConnection_ =
1:cbd0ff1:             ClientDriver.getFactory().newNetConnection(
1:6372907:                     logWriter_,
1:d506170:                     user,
1:d506170:                     password,
1:d506170:                     ds,
1:d506170:                     -1,
1:407e52d:                     false,
1:b13b17c:                     ClientPooledConnection.this);
1:9892638:         } catch (SqlException se) {
1:d506170:             throw se.getSQLException();
1:d506170:         }
8:70f7692:     }
1:9892638: 
1:b6594e1:     /**
1:b6594e1:      * Constructor for XA pooled connections only.
1:b6594e1:      * <p>
1:b6594e1:      * Using standard Java APIs, a CPDS is passed in. Arguments for
1:b6594e1:      * user/password overrides anything on the data source.
1:b6594e1:      * 
1:b6594e1:      * @param ds data source creating this pooled connection
1:b6594e1:      * @param logWriter destination for log messages
1:b6594e1:      * @param user user name
1:b6594e1:      * @param password user password
1:b6594e1:      * @param rmId resource manager id
1:b6594e1:      * @throws SQLException if creating the pooled connection fails due problems
1:b6594e1:      *      in the database, or problems communicating with the database
1:b6594e1:      */
1:7863d83:     public ClientPooledConnection(BasicClientDataSource40 ds,
1:b13b17c:                                   LogWriter logWriter,
1:dadd05a:                                   String user,
1:dadd05a:                                   String password,
1:d506170:                                   int rmId) throws SQLException {
1:9892638:         logWriter_ = logWriter;
1:9892638:         rmId_ = rmId;
1:9892638: 
1:9892638:         if (ds.maxStatementsToPool() <= 0) {
1:9892638:             this.statementCache = null;
1:9892638:         } else {
1:9892638:             // NOTE: Disable statement pooling for XA for now.
2:9892638:             this.statementCache = null;
1:9892638:             //        new JDBCStatementCache(ds.maxStatementsToPool());
1:9892638:         }
1:9892638: 
1:cbd0ff1:         try {
1:ee33904:             netXAPhysicalConnection_ = new NetXAConnection(
1:6372907:                     logWriter,
1:d506170:                     user,
1:d506170:                     password,
1:ee33904:                     ds,
1:ee33904:                     rmId,
1:ee33904:                     true,
1:ee33904:                     this);
1:cbd0ff1:         } catch ( SqlException se ) {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:9892638:         physicalConnection_ = netXAPhysicalConnection_.getNetConnection();
1:9892638:     }
1:9892638: 
1:9892638:     /**
1:9892638:      * Tells is statement pooling is enabled or not.
1:9892638:      *
1:9892638:      * @return {@code true} if enabled, {@code false} if disabled.
1:9892638:      */
1:9892638:     public boolean isStatementPoolingEnabled() {
1:9892638:         return this.statementCache != null;
1:70f7692:     }
1:cbd0ff1: 
1:b13b17c:     protected void finalize() throws Throwable {
4:70f7692:         if (logWriter_ != null) {
1:70f7692:             logWriter_.traceEntry(this, "finalize");
1:d506170:         }
1:b13b17c: 
1:b13b17c:         try {
1:b13b17c:             close();
1:b13b17c:         } finally {
1:b13b17c:             // Any exception ignored if thrown from finalizer anyway, so no
1:b13b17c:             // need to catch it.
1:b13b17c:             super.finalize();
1:b13b17c:         }
1:d506170:     }
1:cbd0ff1: 
1:b6594e1:     /**
1:b6594e1:      * Closes the physical connection to the data source and frees all
1:ee33904:      * associated resources.
1:b6594e1:      * 
1:b6594e1:      * @throws SQLException if closing the connection causes an error. Note that
1:b6594e1:      *      this connection can still be considered closed even if an error
1:b6594e1:      *      occurs.
1:b6594e1:      */
1:d506170:     public synchronized void close() throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             if (logWriter_ != null) {
1:d506170:                 logWriter_.traceEntry(this, "close");
1:d506170:             }
1:d506170: 
1:d506170:             if (logicalConnection_ != null) {
1:d506170:                 logicalConnection_.nullPhysicalConnection();
1:ee33904:                 logicalConnection_ = null;
1:407e52d:             }
1:407e52d: 
1:d506170:             if (physicalConnection_ == null) {
1:cb47a36:                 return;
1:d506170:             }
1:407e52d: 
1:70f7692:             // Even if the physcial connection is marked closed (in the pool),
1:70f7692:             // this will close its underlying resources.
1:70f7692:             physicalConnection_.closeResources();
1:d506170:         }
1:d506170:         finally 
1:d506170:         {
1:70f7692:             physicalConnection_ = null;
1:d506170:         }
1:d506170:     }
1:407e52d: 
1:407e52d:     /**
1:b6594e1:      * Creates a logical connection.
1:b6594e1:      * <p>
1:b6594e1:      * This is the standard API for getting a logical connection handle for a
1:b6594e1:      * pooled connection. No "resettable" properties are passed, so user,
1:b6594e1:      * password, and all other properties may not change.
1:407e52d:      * 
1:b6594e1:      * @throws SQLException if creating a new logical connection fails
1:407e52d:      */
1:69e3d06:     public synchronized Connection getConnection() throws SQLException {
2:d506170:         try
3:d506170:         {
1:d506170:             if (logWriter_ != null) {
1:d506170:                 logWriter_.traceEntry(this, "getConnection");
1:494a328:             }           
1:d506170:             createLogicalConnection();
1:407e52d: 
1:407e52d:             
1:d506170:             if (!newPC_) {
1:6eb29f6:                 // DERBY-1144 changed the last parameter of this method to true
1:6eb29f6:                 // to reset the connection state to the default on 
1:6eb29f6:                 // PooledConnection.getConnection() otherwise the 
1:6eb29f6:                 // isolation level and holdability was not correct and out of sync with the server.
1:bbc2fd8:                 physicalConnection_.reset(logWriter_);
1:d506170:             }
1:d506170:             else {
1:d506170:                 physicalConnection_.lightReset();    //poolfix
1:d506170:             }
1:d506170:             newPC_ = false;
1:dadd05a: 
1:d506170:             if (logWriter_ != null) {
1:d506170:                 logWriter_.traceExit(this, "getConnection", logicalConnection_);
1:d506170:             }
1:d506170:             return logicalConnection_;
1:d506170:         }
1:cbd0ff1:         catch (SqlException se)
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:d506170:         }
1:d506170:     }
1:70f7692: 
1:407e52d:     /**
1:b6594e1:      * Creates a new logical connection by performing all the required steps to
1:b6594e1:      * be able to reuse the physical connection.
1:b6594e1:      * <p>
1:407e52d:      * 
1:b6594e1:      * @throws SqlException if there is no physical connection, or if any error
1:b6594e1:      *      occurs when recycling the physical connection or closing/craeting
1:b6594e1:      *      the logical connection
1:407e52d:      */
1:b6594e1:     //@GuardedBy("this")
1:70f7692:     private void createLogicalConnection() throws SqlException {
2:70f7692:         if (physicalConnection_ == null) {
1:d506170:             throw new SqlException(logWriter_,
1:e65b4db:                 new ClientMessageId(SQLState.NOGETCONN_ON_CLOSED_POOLED_CONNECTION));
1:d506170:         }
1:494a328:         
1:494a328:         // Roll back any pending transactions.  Otherwise we get an exception
1:494a328:         // when we try to close the connection (even for re-use), with an error
1:494a328:         // saying we can't close the connection with active transactions
1:494a328:         // (this fixes DERBY-1004)
1:494a328:         try {
1:494a328:             if ( physicalConnection_.transactionInProgress() ) {
1:494a328:                 physicalConnection_.rollback();
1:494a328:             }
1:494a328:         } catch ( SQLException sqle ) {
1:494a328:             throw new SqlException(sqle);
1:494a328:         }
1:494a328:         
1:b6594e1:         // Not the usual case, but if we have an existing logical connection,
1:b6594e1:         // then we must close it by spec. We close the logical connection
1:b6594e1:         // without notifying the pool manager that this pooled connection is
1:b6594e1:         // availabe for reuse.
2:70f7692:         if (logicalConnection_ != null) {
1:70f7692:             logicalConnection_.closeWithoutRecyclingToPool();
1:70f7692:         }
1:9892638:         if (this.statementCache == null) {
1:9892638:             logicalConnection_ = ClientDriver.getFactory().newLogicalConnection(
1:b64ccfc:                                                         physicalConnection_,
1:407e52d:                                                         this);
1:9892638:         } else {
1:9892638:             logicalConnection_ = ClientDriver.getFactory().
1:9892638:                     newCachingLogicalConnection(
1:9892638:                             physicalConnection_, this, statementCache);
1:9892638:         }
1:70f7692:     }
1:70f7692: 
1:45a24ec:     public synchronized void addConnectionEventListener(
1:45a24ec:                                             ConnectionEventListener listener) {
1:70f7692:         if (logWriter_ != null) {
1:70f7692:             logWriter_.traceEntry(this, "addConnectionEventListener", listener);
1:70f7692:         }
1:2e2d2ee: 
1:2e2d2ee:         if (listener == null) {
1:2e2d2ee:             // Ignore the listener if it is null. Otherwise, an exception is
1:2e2d2ee:             // thrown when a connection event occurs (DERBY-3307).
1:2e2d2ee:             return;
1:2e2d2ee:         }
1:2e2d2ee: 
1:af3cf0c:         if (eventIterators > 0) {
1:af3cf0c:             // DERBY-3401: Someone is iterating over the ArrayList, and since
1:af3cf0c:             // we were able to synchronize on this, that someone is us. Clone
1:af3cf0c:             // the list of listeners in order to prevent invalidation of the
1:af3cf0c:             // iterator.
1:4772c7e:             listeners_ = new ArrayList<ConnectionEventListener>(listeners_);
1:af3cf0c:         }
1:45a24ec:         listeners_.add(listener);
1:70f7692:     }
1:70f7692: 
1:45a24ec:     public synchronized void removeConnectionEventListener(
1:45a24ec:                                             ConnectionEventListener listener) {
1:70f7692:         if (logWriter_ != null) {
1:70f7692:             logWriter_.traceEntry(this, "removeConnectionEventListener", listener);
1:af3cf0c:         }
1:af3cf0c:         if (eventIterators > 0) {
1:af3cf0c:             // DERBY-3401: Someone is iterating over the ArrayList, and since
1:af3cf0c:             // we were able to synchronize on this, that someone is us. Clone
1:af3cf0c:             // the list of listeners in order to prevent invalidation of the
1:af3cf0c:             // iterator.
1:4772c7e:             listeners_ = new ArrayList<ConnectionEventListener>(listeners_);
1:70f7692:         }
1:45a24ec:         listeners_.remove(listener);
1:70f7692:     }
1:70f7692: 
1:b6594e1:     /**
1:b6594e1:      * Inform listeners that the logical connection has been closed and that the
1:b6594e1:      * physical connection is ready for reuse.
1:b6594e1:      * <p>
1:b6594e1:      * Not public, but needs to be visible to am.LogicalConnection
1:b6594e1:      */
1:45a24ec:     public synchronized void recycleConnection() {
1:70f7692:         if (physicalConnection_.agent_.loggingEnabled()) {
1:70f7692:             physicalConnection_.agent_.logWriter_.traceEntry(this, "recycleConnection");
1:70f7692:         }
1:70f7692: 
1:5d59e9d:         // Null out the reference to the logical connection that is currently
1:5d59e9d:         // being closed.
1:5d59e9d:         this.logicalConnection_ = null;
1:5d59e9d: 
1:af3cf0c:         fireConnectionEventListeners(null);
1:70f7692:     }
1:70f7692: 
1:b6594e1:     /**
1:b6594e1:      * Inform listeners that an error has occured on the connection, if the
1:b6594e1:      * error severity is high enough.
1:b6594e1:      * <p>
1:b6594e1:      * Not public, but needs to be visible to am.LogicalConnection
1:407e52d:      * 
1:b6594e1:      * @param exception the exception that occurred on the connection
1:b6594e1:      */
1:4397a19:     public void informListeners(SqlException exception) {
1:6eb29f6:         // only report fatal error  
1:6eb29f6:         if (exception.getErrorCode() < ExceptionSeverity.SESSION_SEVERITY)
1:6eb29f6:             return;
1:cb47a36: 
1:45a24ec:         synchronized (this) {
1:af3cf0c:             fireConnectionEventListeners(exception);
1:af3cf0c:         }
1:af3cf0c:     }
1:af3cf0c: 
1:af3cf0c:     /**
1:af3cf0c:      * Fire all the {@code ConnectionEventListener}s registered. Callers must
1:af3cf0c:      * synchronize on {@code this} to prevent others from modifying the list of
1:af3cf0c:      * listeners.
1:af3cf0c:      *
1:af3cf0c:      * @param exception the exception that caused the event, or {@code null} if
1:af3cf0c:      * it is a close event
1:af3cf0c:      */
1:af3cf0c:     private void fireConnectionEventListeners(SqlException exception) {
1:af3cf0c:         if (!listeners_.isEmpty()) {
1:af3cf0c:             final ConnectionEvent event = (exception == null) ?
1:af3cf0c:                 new ConnectionEvent(this) :
1:af3cf0c:                 new ConnectionEvent(this, exception.getSQLException());
1:af3cf0c:             eventIterators++;
1:af3cf0c:             try {
1:af3cf0c:                 for (Iterator it = listeners_.iterator(); it.hasNext(); ) {
1:af3cf0c:                     final ConnectionEventListener listener =
1:af3cf0c:                         (ConnectionEventListener) it.next();
1:af3cf0c:                     if (exception == null) {
1:af3cf0c:                         listener.connectionClosed(event);
1:af3cf0c:                     } else {
1:af3cf0c:                         listener.connectionErrorOccurred(event);
1:af3cf0c:                     }
1:af3cf0c:                 }
1:af3cf0c:             } finally {
1:af3cf0c:                 eventIterators--;
1:45a24ec:             }
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:b6594e1:     /**
1:5d59e9d:      * Used by {@code LogicalConnection.close} in some circumstances when
1:5d59e9d:      * it disassociates itself from the pooled connection.
1:b6594e1:      */
1:70f7692:     public synchronized void nullLogicalConnection() {
1:d506170:         logicalConnection_ = null;
1:dadd05a:     }
1:9a0cdf1: 
1:9a0cdf1:     // JDBC 4.0 methods
1:9a0cdf1: 
1:b6594e1:     /**
1:9a0cdf1:      * Registers a StatementEventListener with this PooledConnection object.
1:9a0cdf1:      * Components that wish to be informed of events associated with the
1:9a0cdf1:      * PreparedStatement object created by this PooledConnection like the close
1:9a0cdf1:      * or error occurred event can register a StatementEventListener with this
1:9a0cdf1:      * PooledConnection object.
1:407e52d:      *
1:9a0cdf1:      * @param listener A component that implements the StatementEventListener
1:9a0cdf1:      * interface and wants to be notified of Statement closed or or Statement
1:9a0cdf1:      * error occurred events
1:9a0cdf1:      */
1:9a0cdf1:     public void addStatementEventListener(StatementEventListener listener) {
1:9a0cdf1:         if (logWriter_ != null) {
1:9a0cdf1:             logWriter_.traceEntry(this, "addStatementEventListener", listener);
1:9a0cdf1:         }
1:9a0cdf1:         if (listener != null) {
1:9a0cdf1:             statementEventListeners.add(listener);
1:9a0cdf1:         }
1:9a0cdf1:     }
1:9a0cdf1: 
1:9a0cdf1:     /**
1:9a0cdf1:      * Removes the specified previously registered listener object from the list
1:9a0cdf1:      * of components that would be informed of events with a PreparedStatement
1:9a0cdf1:      * object.
1:9a0cdf1:      *
1:9a0cdf1:      * @param listener The previously registered event listener that needs to be
1:9a0cdf1:      * removed from the list of components
1:9a0cdf1:      */
1:9a0cdf1:     public void removeStatementEventListener(StatementEventListener listener) {
1:9a0cdf1:         if (logWriter_ != null) {
1:9a0cdf1:             logWriter_.traceEntry(
1:9a0cdf1:                     this, "removeConnectionEventListener", listener);
1:9a0cdf1:         }
1:9a0cdf1:         statementEventListeners.remove(listener);
1:9a0cdf1:     }
1:9a0cdf1: 
1:9a0cdf1:     /**
1:9a0cdf1:      * Raise the statementClosed event for all the listeners when the
1:9a0cdf1:      * corresponding events occurs.
1:b6594e1:      *
2:407e52d:      * @param statement The PreparedStatement that was closed
1:407e52d:      */
1:69e3d06:     public void onStatementClose(PreparedStatement statement) {
1:9a0cdf1:         if (!statementEventListeners.isEmpty()) {
1:9a0cdf1:             StatementEvent event = new StatementEvent(this, statement);
1:9a0cdf1:             for (StatementEventListener l : statementEventListeners) {
1:9a0cdf1:                 l.statementClosed(event);
1:9a0cdf1:             }
1:9a0cdf1:         }
1:407e52d:     }
1:9a0cdf1: 
1:b6594e1:     /**
1:9a0cdf1:      * Raise the statementErrorOccurred event for all the listeners when the
1:9a0cdf1:      * corresponding events occurs.
1:b6594e1:      *
1:9a0cdf1:      * @param statement The PreparedStatement on which error occurred
1:9a0cdf1:      * @param sqle The SQLException associated with the error that caused the
1:9a0cdf1:      * invalidation of the PreparedStatements
1:b6594e1:      */
1:69e3d06:     public void onStatementErrorOccurred(PreparedStatement statement,
1:9a0cdf1:             SQLException sqle) {
1:9a0cdf1:         if (!statementEventListeners.isEmpty()) {
1:9a0cdf1:             StatementEvent event = new StatementEvent(this, statement, sqle);
1:9a0cdf1:             for (StatementEventListener l : statementEventListeners) {
1:9a0cdf1:                 l.statementErrorOccurred(event);
1:9a0cdf1:             }
1:9a0cdf1:         }
1:70f7692:     }
1:70f7692: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:7863d83
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.jdbc.BasicClientDataSource40;
/////////////////////////////////////////////////////////////////////////
1:     public ClientPooledConnection(BasicClientDataSource40 ds,
/////////////////////////////////////////////////////////////////////////
1:     public ClientPooledConnection(BasicClientDataSource40 ds,
commit:b565f41
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             physicalConnection_ =
/////////////////////////////////////////////////////////////////////////
commit:69e3d06
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Connection;
1: import java.sql.PreparedStatement;
1: import javax.sql.PooledConnection;
1: import org.apache.derby.client.am.ClientConnection;
/////////////////////////////////////////////////////////////////////////
1: public class ClientPooledConnection implements PooledConnection {
/////////////////////////////////////////////////////////////////////////
1:     ClientConnection physicalConnection_ = null;
0:     NetConnection netPhysicalConnection_ = null;
/////////////////////////////////////////////////////////////////////////
1:     public synchronized Connection getConnection() throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:     public void onStatementClose(PreparedStatement statement) {
/////////////////////////////////////////////////////////////////////////
1:     public void onStatementErrorOccurred(PreparedStatement statement,
commit:b13b17c
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.client.am.Connection;
1: import org.apache.derby.client.am.LogWriter;
1: import org.apache.derby.client.am.LogicalConnection;
0: import org.apache.derby.client.net.NetConnection;
/////////////////////////////////////////////////////////////////////////
0:     Connection physicalConnection_ = null;
0:     private NetConnection netPhysicalConnection_ = null;
1:     NetXAConnection netXAPhysicalConnection_ = null;
/////////////////////////////////////////////////////////////////////////
1:     private LogicalConnection logicalConnection_ = null;
1:     protected LogWriter logWriter_ = null;
/////////////////////////////////////////////////////////////////////////
1:                                   LogWriter logWriter,
/////////////////////////////////////////////////////////////////////////
0:             netPhysicalConnection_ = (NetConnection)
/////////////////////////////////////////////////////////////////////////
1:                     ClientPooledConnection.this);
/////////////////////////////////////////////////////////////////////////
1:                                   LogWriter logWriter,
/////////////////////////////////////////////////////////////////////////
1:     protected void finalize() throws Throwable {
1: 
1:         try {
1:             close();
1:         } finally {
1:             // Any exception ignored if thrown from finalizer anyway, so no
1:             // need to catch it.
1:             super.finalize();
1:         }
/////////////////////////////////////////////////////////////////////////
0:     public void onStatementClose(java.sql.PreparedStatement statement) {
/////////////////////////////////////////////////////////////////////////
0:     public void onStatementErrorOccurred(java.sql.PreparedStatement statement,
commit:ee33904
/////////////////////////////////////////////////////////////////////////
0:     private org.apache.derby.client.net.NetConnection
0:             netPhysicalConnection_ = null;
/////////////////////////////////////////////////////////////////////////
0:     private org.apache.derby.client.am.LogicalConnection
1:         logicalConnection_ = null;
1:     /** Resource manager identifier. */
/////////////////////////////////////////////////////////////////////////
1:             netXAPhysicalConnection_ = new NetXAConnection(
0:                     (NetLogWriter)logWriter,
1:                     ds,
1:                     rmId,
1:                     true,
1:                     this);
/////////////////////////////////////////////////////////////////////////
1:      * associated resources.
/////////////////////////////////////////////////////////////////////////
commit:8269b78
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.jdbc.ClientBaseDataSourceRoot;
/////////////////////////////////////////////////////////////////////////
0:     public ClientPooledConnection(ClientBaseDataSourceRoot ds,
/////////////////////////////////////////////////////////////////////////
0:     public ClientPooledConnection(ClientBaseDataSourceRoot ds,
/////////////////////////////////////////////////////////////////////////
0:     protected NetXAConnection getNetXAConnection (ClientBaseDataSourceRoot ds,
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:6372907
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                     logWriter_,
/////////////////////////////////////////////////////////////////////////
1:                     logWriter,
commit:9a0cdf1
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.CopyOnWriteArrayList;
1: import javax.sql.StatementEvent;
1: import javax.sql.StatementEventListener;
/////////////////////////////////////////////////////////////////////////
1:      * List of statement event listeners. The list is copied on each write,
1:      * ensuring that it can be safely iterated over even if other threads or
1:      * the listeners fired in the same thread add or remove listeners.
1:      */
1:     private final CopyOnWriteArrayList<StatementEventListener>
1:             statementEventListeners =
1:                     new CopyOnWriteArrayList<StatementEventListener>();
1: 
1:     /**
/////////////////////////////////////////////////////////////////////////
1: 
1:     // JDBC 4.0 methods
1: 
1:      * Registers a StatementEventListener with this PooledConnection object.
1:      * Components that wish to be informed of events associated with the
1:      * PreparedStatement object created by this PooledConnection like the close
1:      * or error occurred event can register a StatementEventListener with this
1:      * PooledConnection object.
1:      * @param listener A component that implements the StatementEventListener
1:      * interface and wants to be notified of Statement closed or or Statement
1:      * error occurred events
1:      */
1:     public void addStatementEventListener(StatementEventListener listener) {
1:         if (logWriter_ != null) {
1:             logWriter_.traceEntry(this, "addStatementEventListener", listener);
1:         }
1:         if (listener != null) {
1:             statementEventListeners.add(listener);
1:         }
1:     }
1: 
1:     /**
1:      * Removes the specified previously registered listener object from the list
1:      * of components that would be informed of events with a PreparedStatement
1:      * object.
1:      *
1:      * @param listener The previously registered event listener that needs to be
1:      * removed from the list of components
1:      */
1:     public void removeStatementEventListener(StatementEventListener listener) {
1:         if (logWriter_ != null) {
1:             logWriter_.traceEntry(
1:                     this, "removeConnectionEventListener", listener);
1:         }
1:         statementEventListeners.remove(listener);
1:     }
1: 
1:     /**
1:      * Raise the statementClosed event for all the listeners when the
1:      * corresponding events occurs.
1:         if (!statementEventListeners.isEmpty()) {
1:             StatementEvent event = new StatementEvent(this, statement);
1:             for (StatementEventListener l : statementEventListeners) {
1:                 l.statementClosed(event);
1:             }
1:         }
1: 
1:      * Raise the statementErrorOccurred event for all the listeners when the
1:      * corresponding events occurs.
1:      * @param statement The PreparedStatement on which error occurred
1:      * @param sqle The SQLException associated with the error that caused the
1:      * invalidation of the PreparedStatements
1:             SQLException sqle) {
1:         if (!statementEventListeners.isEmpty()) {
1:             StatementEvent event = new StatementEvent(this, statement, sqle);
1:             for (StatementEventListener l : statementEventListeners) {
1:                 l.statementErrorOccurred(event);
1:             }
1:         }
commit:4772c7e
/////////////////////////////////////////////////////////////////////////
1: import javax.sql.ConnectionEvent;
1: import javax.sql.ConnectionEventListener;
1: import org.apache.derby.client.net.NetXAConnection;
1: import org.apache.derby.iapi.error.ExceptionSeverity;
0: import org.apache.derby.jdbc.ClientBaseDataSource;
1: import org.apache.derby.jdbc.ClientDriver;
/////////////////////////////////////////////////////////////////////////
1:     private ArrayList<ConnectionEventListener> listeners_ =
1:             new ArrayList<ConnectionEventListener>();
/////////////////////////////////////////////////////////////////////////
1:             listeners_ = new ArrayList<ConnectionEventListener>(listeners_);
/////////////////////////////////////////////////////////////////////////
1:             listeners_ = new ArrayList<ConnectionEventListener>(listeners_);
commit:2e2d2ee
/////////////////////////////////////////////////////////////////////////
1: 
1:         if (listener == null) {
1:             // Ignore the listener if it is null. Otherwise, an exception is
1:             // thrown when a connection event occurs (DERBY-3307).
1:             return;
1:         }
1: 
commit:af3cf0c
/////////////////////////////////////////////////////////////////////////
1:     /** List of {@code ConnectionEventListener}s. Never {@code null}. */
0:     private ArrayList listeners_ = new ArrayList();
1: 
1:     /**
1:      * The number of iterators going through the list of connection event
1:      * listeners at the current time. Only one thread may be iterating over the
1:      * list at any time (because of synchronization), but a single thread may
1:      * have multiple iterators if for instance an event listener performs
1:      * database calls that trigger a new event.
1:      */
1:     private int eventIterators;
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         if (eventIterators > 0) {
1:             // DERBY-3401: Someone is iterating over the ArrayList, and since
1:             // we were able to synchronize on this, that someone is us. Clone
1:             // the list of listeners in order to prevent invalidation of the
1:             // iterator.
0:             listeners_ = (ArrayList) listeners_.clone();
1:         }
/////////////////////////////////////////////////////////////////////////
1:         if (eventIterators > 0) {
1:             // DERBY-3401: Someone is iterating over the ArrayList, and since
1:             // we were able to synchronize on this, that someone is us. Clone
1:             // the list of listeners in order to prevent invalidation of the
1:             // iterator.
0:             listeners_ = (ArrayList) listeners_.clone();
1:         }
/////////////////////////////////////////////////////////////////////////
1:         fireConnectionEventListeners(null);
/////////////////////////////////////////////////////////////////////////
1:             fireConnectionEventListeners(exception);
1:         }
1:     }
1: 
1:     /**
1:      * Fire all the {@code ConnectionEventListener}s registered. Callers must
1:      * synchronize on {@code this} to prevent others from modifying the list of
1:      * listeners.
1:      *
1:      * @param exception the exception that caused the event, or {@code null} if
1:      * it is a close event
1:      */
1:     private void fireConnectionEventListeners(SqlException exception) {
1:         if (!listeners_.isEmpty()) {
1:             final ConnectionEvent event = (exception == null) ?
1:                 new ConnectionEvent(this) :
1:                 new ConnectionEvent(this, exception.getSQLException());
1:             eventIterators++;
1:             try {
1:                 for (Iterator it = listeners_.iterator(); it.hasNext(); ) {
1:                     final ConnectionEventListener listener =
1:                         (ConnectionEventListener) it.next();
1:                     if (exception == null) {
1:                         listener.connectionClosed(event);
1:                     } else {
1:                         listener.connectionErrorOccurred(event);
1:                     }
1:                 }
1:             } finally {
1:                 eventIterators--;
commit:407e52d
/////////////////////////////////////////////////////////////////////////
0: import java.sql.PreparedStatement;
/////////////////////////////////////////////////////////////////////////
1:             //pass the client pooled connection instance to this
1:             //instance of the NetConnection object 
1:             //this object is then used to pass the close and the error events 
1:             //that occur in the PreparedStatement object back to the 
1:             //PooledConnection which will then raise the events
1:             //on the listeners
1:             
/////////////////////////////////////////////////////////////////////////
1:                     false,
1:                     this);
/////////////////////////////////////////////////////////////////////////
0:     /*-----------------------------------------------------------------*/
1:     /*
0:      * These methods are needed to provide StatementEvent support for 
0:      * derby. 
0:      * They are actually implemented in EmbedPooledConnection40 but have
0:      * a dummy implementation here
1:      */
1:     
1:     /**
1:      *
0:      * The onStatementClose contains the logic for raising the Statement Closed
0:      * events. This method has a dummy implementation here to avoid error when
0:      * this class is compiled with jdk1.4. The class the actual implementation 
0:      * in ClientPooledConnection40.
1:      *
1:      * @param statement The PreparedStatement that was closed
1:      *
1:      */
0:     public void onStatementClose(PreparedStatement statement) {
1:         
1:     }
1:     
1:     /**
0:      * The method contains the logic for raising the Statement error occurred
0:      * events. This method has a dummy implementation here to avoid error when
0:      * this class is compiled with jdk1.4. The class the actual implementation 
0:      * in ClientPooledConnection40.
1:      *
1:      * @param statement The PreparedStatement that was closed
0:      * @param sqle      The SQLException associated with the error that caused
0:      *                  the invalidation of this PreparedStatement
1:      */
0:     public void onStatementErrorOccurred(PreparedStatement statement,
0:                     SQLException sqle) {
1:         
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
0:                     true,
0:                     this);
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:6eb29f6
/////////////////////////////////////////////////////////////////////////
1:                 // DERBY-1144 changed the last parameter of this method to true
1:                 // to reset the connection state to the default on 
1:                 // PooledConnection.getConnection() otherwise the 
1:                 // isolation level and holdability was not correct and out of sync with the server.
/////////////////////////////////////////////////////////////////////////
1:         // only report fatal error  
1:         if (exception.getErrorCode() < ExceptionSeverity.SESSION_SEVERITY)
1:             return;
commit:1d49f56
/////////////////////////////////////////////////////////////////////////
1:             
0:             	// DERBY-1144 changed the last parameter of this method to true
0:             	// to reset the connection state to the default on 
0:             	// PooledConnection.getConnection() otherwise the 
0:             	// isolation level and holdability was not correct and out of sync with the server.
0:                 physicalConnection_.reset(logWriter_, user_, password_, ds_, true);
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:bbc2fd8
/////////////////////////////////////////////////////////////////////////
1:                 physicalConnection_.reset(logWriter_);
commit:ea141d7
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                 physicalConnection_.reset(logWriter_, true);
commit:080c38f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                 physicalConnection_.reset(logWriter_, ds_, true);
commit:5d59e9d
/////////////////////////////////////////////////////////////////////////
1:         // Null out the reference to the logical connection that is currently
1:         // being closed.
1:         this.logicalConnection_ = null;
1: 
/////////////////////////////////////////////////////////////////////////
1:      * Used by {@code LogicalConnection.close} in some circumstances when
1:      * it disassociates itself from the pooled connection.
commit:1c72cdc
/////////////////////////////////////////////////////////////////////////
commit:f3f832c
/////////////////////////////////////////////////////////////////////////
1:             this.statementCache =
1:                     new JDBCStatementCache(ds.maxStatementsToPool());
commit:9892638
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.client.am.stmtcache.JDBCStatementCache;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * The statement cache for the underlying physical connection.
1:      * <p>
1:      * This will be {@code null} if statement caching is disabled (default).
1:      */
1:     private final JDBCStatementCache statementCache;
1: 
/////////////////////////////////////////////////////////////////////////
1:         logWriter_ = logWriter;
0:         ds_ = ds;
0:         user_ = user;
0:         password_ = password;
0:         listeners_ = new ArrayList();
1: 
1:         if (ds.maxStatementsToPool() <= 0) {
1:             this.statementCache = null;
1:         } else {
0:             // Disabled for now.
1:             this.statementCache = null;
1:             //        new JDBCStatementCache(ds.maxStatementsToPool());
1:         }
1: 
1:         try {
/////////////////////////////////////////////////////////////////////////
1:         } catch (SqlException se) {
0:         physicalConnection_ = netPhysicalConnection_;
/////////////////////////////////////////////////////////////////////////
1:         logWriter_ = logWriter;
0:         ds_ = ds;
0:         user_ = user;
0:         password_ = password;
1:         rmId_ = rmId;
0:         listeners_ = new ArrayList();
1: 
1:         if (ds.maxStatementsToPool() <= 0) {
1:             this.statementCache = null;
1:         } else {
1:             // NOTE: Disable statement pooling for XA for now.
1:             this.statementCache = null;
0:             //        new JDBCStatementCache(ds.maxStatementsToPool());
1:         }
1: 
1:         physicalConnection_ = netXAPhysicalConnection_.getNetConnection();
1:     }
1: 
1:     /**
1:      * Tells is statement pooling is enabled or not.
1:      *
1:      * @return {@code true} if enabled, {@code false} if disabled.
1:      */
1:     public boolean isStatementPoolingEnabled() {
1:         return this.statementCache != null;
/////////////////////////////////////////////////////////////////////////
1:         if (this.statementCache == null) {
1:             logicalConnection_ = ClientDriver.getFactory().newLogicalConnection(
1:         } else {
1:             logicalConnection_ = ClientDriver.getFactory().
1:                     newCachingLogicalConnection(
1:                             physicalConnection_, this, statementCache);
1:         }
commit:4397a19
/////////////////////////////////////////////////////////////////////////
1:     public void informListeners(SqlException exception) {
commit:45a24ec
/////////////////////////////////////////////////////////////////////////
0: import javax.sql.ConnectionEvent;
0: import javax.sql.ConnectionEventListener;
1: import java.util.ArrayList;
1: import java.util.Iterator;
/////////////////////////////////////////////////////////////////////////
1:     //@GuardedBy("this")
0:     private ArrayList listeners_ = null;
/////////////////////////////////////////////////////////////////////////
0:             listeners_ = new ArrayList();
/////////////////////////////////////////////////////////////////////////
0:             listeners_ = new ArrayList();
/////////////////////////////////////////////////////////////////////////
1:     public synchronized void addConnectionEventListener(
1:                                             ConnectionEventListener listener) {
1:         listeners_.add(listener);
1:     public synchronized void removeConnectionEventListener(
1:                                             ConnectionEventListener listener) {
1:         listeners_.remove(listener);
/////////////////////////////////////////////////////////////////////////
1:     public synchronized void recycleConnection() {
0:         for (Iterator e = listeners_.iterator(); e.hasNext();) {
0:             ConnectionEventListener listener =
0:                     (ConnectionEventListener)e.next();
0:             ConnectionEvent event = new ConnectionEvent(this);
/////////////////////////////////////////////////////////////////////////
1:         synchronized (this) {
0:             for (Iterator e = listeners_.iterator(); e.hasNext();) {
0:                 ConnectionEventListener listener =
0:                         (ConnectionEventListener)e.next();
0:                 SQLException sqle = exception.getSQLException();
0:                 ConnectionEvent event = new ConnectionEvent(this, sqle);
0:                 listener.connectionErrorOccurred(event);
1:             }
commit:b6594e1
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * A physical connection to a data source, to be used for creating logical
1:  * connections to the same data source.
1:  */
1: 
1:     /** Tells if this pooled connection is newly created. */
/////////////////////////////////////////////////////////////////////////
1:     /** The logical connection using the physical connection. */
1:     //@GuardedBy("this")
0:     /** Resource manager identificator. */
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Constructor for non-XA pooled connections.
1:      * <p>
1:      * Using standard Java APIs, a CPDS is passed in. Arguments for
1:      * user/password overrides anything on the data source.
1:      * 
1:      * @param ds data source creating this pooled connection
1:      * @param logWriter destination for log messages
1:      * @param user user name
1:      * @param password user password
1:      * @throws SQLException if creating the pooled connection fails due problems
1:      *      in the database, or problems communicating with the database
1:      */
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Constructor for XA pooled connections only.
1:      * <p>
1:      * Using standard Java APIs, a CPDS is passed in. Arguments for
1:      * user/password overrides anything on the data source.
1:      * 
1:      * @param ds data source creating this pooled connection
1:      * @param logWriter destination for log messages
1:      * @param user user name
1:      * @param password user password
1:      * @param rmId resource manager id
1:      * @throws SQLException if creating the pooled connection fails due problems
1:      *      in the database, or problems communicating with the database
1:      */
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Closes the physical connection to the data source and frees all
0:      * assoicated resources.
1:      * 
1:      * @throws SQLException if closing the connection causes an error. Note that
1:      *      this connection can still be considered closed even if an error
1:      *      occurs.
1:      */
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Creates a logical connection.
1:      * <p>
1:      * This is the standard API for getting a logical connection handle for a
1:      * pooled connection. No "resettable" properties are passed, so user,
1:      * password, and all other properties may not change.
1:      * 
1:      * @throws SQLException if creating a new logical connection fails
1:      */
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Creates a new logical connection by performing all the required steps to
1:      * be able to reuse the physical connection.
1:      * <p>
1:      * 
1:      * @throws SqlException if there is no physical connection, or if any error
1:      *      occurs when recycling the physical connection or closing/craeting
1:      *      the logical connection
1:      */
1:     //@GuardedBy("this")
/////////////////////////////////////////////////////////////////////////
1:         // Not the usual case, but if we have an existing logical connection,
1:         // then we must close it by spec. We close the logical connection
1:         // without notifying the pool manager that this pooled connection is
1:         // availabe for reuse.
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Inform listeners that the logical connection has been closed and that the
1:      * physical connection is ready for reuse.
1:      * <p>
1:      * Not public, but needs to be visible to am.LogicalConnection
1:      */
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Inform listeners that an error has occured on the connection, if the
1:      * error severity is high enough.
1:      * <p>
1:      * Not public, but needs to be visible to am.LogicalConnection
0:      * 
1:      * @param exception the exception that occurred on the connection
1:      */
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * Used by <code>LogicalConnection.close</code> when it disassociates itself
0:      * from the pooled connection.
1:      */
commit:66149fa
/////////////////////////////////////////////////////////////////////////
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:cb47a36
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.error.ExceptionSeverity;
/////////////////////////////////////////////////////////////////////////
0: 		// only report fatal error  
0: 		if (exception.getErrorCode() < ExceptionSeverity.SESSION_SEVERITY)
1: 			return;
1: 
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:59bf37d
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:David Van Couvering
-------------------------------------------------------------------------------
commit:494a328
/////////////////////////////////////////////////////////////////////////
1:             }           
/////////////////////////////////////////////////////////////////////////
1:         
1:         // Roll back any pending transactions.  Otherwise we get an exception
1:         // when we try to close the connection (even for re-use), with an error
1:         // saying we can't close the connection with active transactions
1:         // (this fixes DERBY-1004)
1:         try {
1:             if ( physicalConnection_.transactionInProgress() ) {
1:                 physicalConnection_.rollback();
1:             }
1:         } catch ( SQLException sqle ) {
1:             throw new SqlException(sqle);
1:         }
1:         
commit:e65b4db
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.client.am.ClientMessageId;
/////////////////////////////////////////////////////////////////////////
1:                 new ClientMessageId(SQLState.NOGETCONN_ON_CLOSED_POOLED_CONNECTION));
commit:d506170
/////////////////////////////////////////////////////////////////////////
1: import java.sql.SQLException;
1: 
0: import org.apache.derby.client.am.MessageId;
1: import org.apache.derby.shared.common.reference.SQLState;
/////////////////////////////////////////////////////////////////////////
1:                                   String password) throws SQLException {
1:         try
1:         {
0:             logWriter_ = logWriter;
0:             ds_ = ds;
0:             user_ = user;
0:             password_ = password;
0:             listeners_ = new java.util.Vector();
0:             netPhysicalConnection_ = new org.apache.derby.client.net.NetConnection((NetLogWriter) logWriter_,
1:                     user,
1:                     password,
1:                     ds,
1:                     -1,
0:                     false);
0:             physicalConnection_ = netPhysicalConnection_;
1:         }
0:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
1:         }
/////////////////////////////////////////////////////////////////////////
1:                                   int rmId) throws SQLException {
1:         try
1:         {
0:             logWriter_ = logWriter;
0:             ds_ = ds;
0:             user_ = user;
0:             password_ = password;
0:             rmId_ = rmId;
0:             listeners_ = new java.util.Vector();
0:             netXAPhysicalConnection_ = new org.apache.derby.client.net.NetXAConnection((NetLogWriter) logWriter_,
1:                     user,
1:                     password,
0:                     ds,
0:                     rmId,
0:                     true);
0:             physicalConnection_ = netXAPhysicalConnection_;
1:         }
0:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
1:         }
0:                                   org.apache.derby.client.am.LogWriter logWriter) throws SQLException {
1:         try
1:         {
0:             logWriter_ = logWriter;
0:             ds_ = ds;
0:             listeners_ = new java.util.Vector();
0:             netPhysicalConnection_ = new org.apache.derby.client.net.NetConnection((NetLogWriter) logWriter_,
0:                     null,
0:                     null,
0:                     ds,
0:                     -1,
0:                     false);
0:             physicalConnection_ = netPhysicalConnection_;
1:         }
0:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
1:         }
/////////////////////////////////////////////////////////////////////////
1:     public synchronized void close() throws SQLException {
0:         try
0:         {
1:             if (logWriter_ != null) {
1:                 logWriter_.traceEntry(this, "close");
1:             }
1:             if (logicalConnection_ != null) {
1:                 logicalConnection_.nullPhysicalConnection();
1:                 logicalConnection_ = null;
1:             }
1:             if (physicalConnection_ == null) {
0:                 return;
1:             }
1: 
1:         }
1:         finally 
0:         {
0:     public synchronized java.sql.Connection getConnection() throws SQLException {
0:         try
0:         {
1:             if (logWriter_ != null) {
1:                 logWriter_.traceEntry(this, "getConnection");
1:             }
1:             createLogicalConnection();
1:             if (!newPC_) {
0:                 physicalConnection_.reset(logWriter_, user_, password_, ds_, false); // false means do not recompute
1:             }
0:             // properties from the dataSource
0:             // properties don't change
1:             else {
1:                 physicalConnection_.lightReset();    //poolfix
1:             }
1:             newPC_ = false;
1:             if (logWriter_ != null) {
1:                 logWriter_.traceExit(this, "getConnection", logicalConnection_);
1:             }
1:             return logicalConnection_;
0:         catch ( SqlException se )
0:         {
0:             throw se.getSQLException();
1:         }
1:             throw new SqlException(logWriter_,
0:                 new MessageId(SQLState.NOGETCONN_ON_CLOSED_POOLED_CONNECTION));
/////////////////////////////////////////////////////////////////////////
0:             java.sql.SQLException sqle = exception.getSQLException();
0:             javax.sql.ConnectionEvent event = new javax.sql.ConnectionEvent(this, sqle);
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:b64ccfc
/////////////////////////////////////////////////////////////////////////
0:         logicalConnection_ = ClientDriver.getFactory().newLogicalConnection(
1:                                                         physicalConnection_,
0:                                                         this);
commit:17d490d
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.jdbc.ClientBaseDataSource;
/////////////////////////////////////////////////////////////////////////
0:     private ClientBaseDataSource ds_;
0:     public ClientPooledConnection(ClientBaseDataSource ds,
/////////////////////////////////////////////////////////////////////////
0:     public ClientPooledConnection(ClientBaseDataSource ds,
/////////////////////////////////////////////////////////////////////////
0:     public ClientPooledConnection(ClientBaseDataSource ds,
/////////////////////////////////////////////////////////////////////////
0:     protected NetXAConnection getNetXAConnection (ClientBaseDataSource ds,
commit:dadd05a
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.client.net.NetXAConnection;
/////////////////////////////////////////////////////////////////////////
0:             netXAPhysicalConnection_ = getNetXAConnection(ds,
0:                     (NetLogWriter) logWriter_,
0:                     rmId);
0:             physicalConnection_ = netXAPhysicalConnection_.getNetConnection();
/////////////////////////////////////////////////////////////////////////
1:     
0:     /**
0:      * creates and returns NetXAConnection. 
0:      * Overwrite this method to create different version of NetXAConnection
0:      * @param ds 
0:      * @param logWriter 
0:      * @param user 
0:      * @param password 
0:      * @param rmId 
0:      * @return NetXAConnection
0:      */
0:     protected NetXAConnection getNetXAConnection (ClientDataSource ds,
0:                                   NetLogWriter logWriter,
1:                                   String user,
1:                                   String password,
0:                                   int rmId) throws SqlException {
0:           return new NetXAConnection(logWriter,
0:                     user,
0:                     password,
0:                     ds,
0:                     rmId,
0:                     true);
1:         
1:     }
commit:cbd0ff1
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.jdbc.ClientDataSource;
0: import org.apache.derby.jdbc.ClientDriver;
0: import org.apache.derby.client.am.ClientJDBCObjectFactory;
0: import org.apache.derby.client.am.MessageId;
/////////////////////////////////////////////////////////////////////////
1:             
0:             netPhysicalConnection_ = (org.apache.derby.client.net.NetConnection)
1:             ClientDriver.getFactory().newNetConnection(
0:                     (NetLogWriter) logWriter_,
1:         
0:         physicalConnection_ = netPhysicalConnection_;
/////////////////////////////////////////////////////////////////////////
1:         try {
/////////////////////////////////////////////////////////////////////////
1:         } catch ( SqlException se ) {
0:         logWriter_ = logWriter;
0:         ds_ = ds;
0:         listeners_ = new java.util.Vector();
0: 	try {
0:             netPhysicalConnection_ = (org.apache.derby.client.net.NetConnection)
0:             ClientDriver.getFactory().newNetConnection(
0:                     (NetLogWriter) logWriter_,
1: 
1:         catch (SqlException se)
/////////////////////////////////////////////////////////////////////////
0:         catch (SqlException se)
/////////////////////////////////////////////////////////////////////////
author:Jeremy Boynes
-------------------------------------------------------------------------------
commit:70f7692
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.client.net.NetLogWriter;
0: public class ClientPooledConnection implements javax.sql.PooledConnection {
1:     private boolean newPC_ = true;
0:     private java.util.Vector listeners_ = null;
0:     org.apache.derby.client.am.Connection physicalConnection_ = null;
0:     org.apache.derby.client.net.NetConnection netPhysicalConnection_ = null;
0:     org.apache.derby.client.net.NetXAConnection netXAPhysicalConnection_ = null;
0:     org.apache.derby.client.am.LogicalConnection logicalConnection_ = null;
0:     protected org.apache.derby.client.am.LogWriter logWriter_ = null;
1:     protected int rmId_ = 0;
0:     // Cached stuff from constructor
0:     private ClientDataSource ds_;
0:     private String user_;
0:     private String password_;
0:     // Constructor for Non-XA pooled connections.
0:     // Using standard Java APIs, a CPDS is passed in.
0:     // user/password overrides anything on the ds.
0:     public ClientPooledConnection(ClientDataSource ds,
0:                                   org.apache.derby.client.am.LogWriter logWriter,
1:                                   String user,
0:                                   String password) throws SqlException {
0:         logWriter_ = logWriter;
0:         ds_ = ds;
0:         user_ = user;
0:         password_ = password;
0:         listeners_ = new java.util.Vector();
0:         netPhysicalConnection_ = new org.apache.derby.client.net.NetConnection((NetLogWriter) logWriter_,
0:                 user,
0:                 password,
0:                 ds,
0:                 -1,
0:                 false);
0:         physicalConnection_ = netPhysicalConnection_;
0:     // Constructor for XA pooled connections only.
0:     // Using standard Java APIs, a CPDS is passed in.
0:     // user/password overrides anything on the ds.
0:     public ClientPooledConnection(ClientDataSource ds,
0:                                   org.apache.derby.client.am.LogWriter logWriter,
1:                                   String user,
0:                                   String password,
0:                                   int rmId) throws SqlException {
0:         logWriter_ = logWriter;
0:         ds_ = ds;
0:         user_ = user;
0:         password_ = password;
0:         rmId_ = rmId;
0:         listeners_ = new java.util.Vector();
0:         netXAPhysicalConnection_ = new org.apache.derby.client.net.NetXAConnection((NetLogWriter) logWriter_,
0:                 user,
0:                 password,
0:                 ds,
0:                 rmId,
0:                 true);
0:         physicalConnection_ = netXAPhysicalConnection_;
1: 
0:     public ClientPooledConnection(ClientDataSource ds,
0:                                   org.apache.derby.client.am.LogWriter logWriter) throws SqlException {
0:         logWriter_ = logWriter;
0:         ds_ = ds;
0:         listeners_ = new java.util.Vector();
0:         netPhysicalConnection_ = new org.apache.derby.client.net.NetConnection((NetLogWriter) logWriter_,
0:                 null,
0:                 null,
0:                 ds,
0:                 -1,
0:                 false);
0:         physicalConnection_ = netPhysicalConnection_;
0:     protected void finalize() throws java.lang.Throwable {
1:         if (logWriter_ != null) {
1:             logWriter_.traceEntry(this, "finalize");
1:         }
0:         close();
0:     public synchronized void close() throws SqlException {
1:         if (logWriter_ != null) {
0:             logWriter_.traceEntry(this, "close");
1:         }
1:         if (logicalConnection_ != null) {
0:             logicalConnection_.nullPhysicalConnection();
0:             logicalConnection_ = null;
1:         }
1:         if (physicalConnection_ == null) {
0:             return;
1:         }
0:         try {
1:             // Even if the physcial connection is marked closed (in the pool),
1:             // this will close its underlying resources.
1:             physicalConnection_.closeResources();
0:         } finally {
1:             physicalConnection_ = null;
1:         }
0:     // This is the standard API for getting a logical connection handle for a pooled connection.
0:     // No "resettable" properties are passed, so user, password, and all other properties may not change.
0:     public synchronized java.sql.Connection getConnection() throws SqlException {
1:         if (logWriter_ != null) {
0:             logWriter_.traceEntry(this, "getConnection");
1:         }
0:         createLogicalConnection();
1: 
0:         if (!newPC_) {
0:             physicalConnection_.reset(logWriter_, user_, password_, ds_, false); // false means do not recompute
1:         }
0:         // properties from the dataSource
0:         // properties don't change
0:         else {
0:             physicalConnection_.lightReset();    //poolfix
1:         }
0:         newPC_ = false;
1: 
1:         if (logWriter_ != null) {
0:             logWriter_.traceExit(this, "getConnection", logicalConnection_);
1:         }
0:         return logicalConnection_;
1:     private void createLogicalConnection() throws SqlException {
1:         if (physicalConnection_ == null) {
0:             throw new SqlException(logWriter_, "getConnection() is not valid on a closed PooledConnection.");
1:         }
0:         // Not the usual case, but if we have an existing logical connection, then we must close it by spec.
0:         // We close the logical connection without notifying the pool manager that this pooled connection is availabe for reuse.
1:         if (logicalConnection_ != null) {
1:             logicalConnection_.closeWithoutRecyclingToPool();
1:         }
0:         logicalConnection_ = new org.apache.derby.client.am.LogicalConnection(physicalConnection_, this);
1:     }
1: 
0:     public synchronized void addConnectionEventListener(javax.sql.ConnectionEventListener listener) {
1:         if (logWriter_ != null) {
1:             logWriter_.traceEntry(this, "addConnectionEventListener", listener);
1:         }
0:         listeners_.addElement(listener);
1:     }
1: 
0:     public synchronized void removeConnectionEventListener(javax.sql.ConnectionEventListener listener) {
1:         if (logWriter_ != null) {
1:             logWriter_.traceEntry(this, "removeConnectionEventListener", listener);
1:         }
0:         listeners_.removeElement(listener);
1:     }
1: 
0:     // Not public, but needs to be visible to am.LogicalConnection
0:     public void recycleConnection() {
1:         if (physicalConnection_.agent_.loggingEnabled()) {
1:             physicalConnection_.agent_.logWriter_.traceEntry(this, "recycleConnection");
1:         }
1: 
0:         for (java.util.Enumeration e = listeners_.elements(); e.hasMoreElements();) {
0:             javax.sql.ConnectionEventListener listener = (javax.sql.ConnectionEventListener) e.nextElement();
0:             javax.sql.ConnectionEvent event = new javax.sql.ConnectionEvent(this);
0:             listener.connectionClosed(event);
1:         }
1:     }
1: 
0:     // Not public, but needs to be visible to am.LogicalConnection
0:     public void trashConnection(SqlException exception) {
0:         for (java.util.Enumeration e = listeners_.elements(); e.hasMoreElements();) {
0:             javax.sql.ConnectionEventListener listener = (javax.sql.ConnectionEventListener) e.nextElement();
0:             javax.sql.ConnectionEvent event = new javax.sql.ConnectionEvent(this, exception);
0:             listener.connectionErrorOccurred(event);
1:         }
1:     }
1: 
0:     // Used by LogicalConnection close when it disassociates itself from the ClientPooledConnection
1:     public synchronized void nullLogicalConnection() {
0:         logicalConnection_ = null;
1:     }
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:33776ff
/////////////////////////////////////////////////////////////////////////
0: /*
1: 
1:    Derby - Class org.apache.derby.client.ClientPooledConnection
1: 
0:    Copyright (c) 2001, 2005 The Apache Software Foundation or its licensors, where applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
0: */
1: package org.apache.derby.client;
1: 
0: import org.apache.derby.client.net.NetLogWriter;
1: import org.apache.derby.client.am.SqlException;
0: import org.apache.derby.jdbc.ClientDataSource;
1: 
0: public class ClientPooledConnection implements javax.sql.PooledConnection
0: {
0:   private boolean newPC_ = true;
1: 
0:   private java.util.Vector listeners_ = null;
0:   org.apache.derby.client.am.Connection physicalConnection_ = null;
0:   org.apache.derby.client.net.NetConnection netPhysicalConnection_ = null;
0:   org.apache.derby.client.net.NetXAConnection netXAPhysicalConnection_ = null;
1: 
0:   org.apache.derby.client.am.LogicalConnection logicalConnection_ = null;
1: 
0:   protected org.apache.derby.client.am.LogWriter logWriter_ = null;
1: 
0:   protected int rmId_ = 0;
1: 
0:   // Cached stuff from constructor
0:   private ClientDataSource ds_;
0:   private String user_;
0:   private String password_;
1: 
0:   // Constructor for Non-XA pooled connections.
0:   // Using standard Java APIs, a CPDS is passed in.
0:   // user/password overrides anything on the ds.
0:   public ClientPooledConnection (ClientDataSource ds,
0:                               org.apache.derby.client.am.LogWriter logWriter,
0:                               String user,
0:                               String password) throws SqlException
0:   {
0:     logWriter_ = logWriter;
0:     ds_ = ds;
0:     user_ = user;
0:     password_ = password;
0:     listeners_ = new java.util.Vector();
1: 
0:     netPhysicalConnection_ =  new org.apache.derby.client.net.NetConnection ((NetLogWriter) logWriter_,
0:           user,
0:           password,
0:           ds,
0:           -1,
0:           false);
0:     physicalConnection_ = netPhysicalConnection_;
0:   }
1: 
0:   // Constructor for XA pooled connections only.
0:   // Using standard Java APIs, a CPDS is passed in.
0:   // user/password overrides anything on the ds.
0:   public ClientPooledConnection (ClientDataSource ds,
0:                               org.apache.derby.client.am.LogWriter logWriter,
0:                               String user,
0:                               String password,
0:                               int rmId) throws SqlException
0:   {
0:     logWriter_ = logWriter;
0:     ds_ = ds;
0:     user_ = user;
0:     password_ = password;
0:     rmId_ = rmId;
0:     listeners_ = new java.util.Vector();
0:     netXAPhysicalConnection_ = new org.apache.derby.client.net.NetXAConnection ((NetLogWriter) logWriter_,
0:             user,
0:             password,
0:             ds,
0:             rmId,
0:             true);
0:     physicalConnection_ = netXAPhysicalConnection_;
0:   }
1: 
0:   public ClientPooledConnection (ClientDataSource ds,
0:                               org.apache.derby.client.am.LogWriter logWriter
0:                               ) throws SqlException
0:   {
0:     logWriter_ = logWriter;
0:     ds_ = ds;
0:     listeners_ = new java.util.Vector();
0:     netPhysicalConnection_ =  new org.apache.derby.client.net.NetConnection ((NetLogWriter) logWriter_,
0:           null,
0:           null,
0:           ds,
0:           -1,
0:           false);
0:     physicalConnection_ = netPhysicalConnection_;
0:   }
1: 
0:   protected void finalize() throws java.lang.Throwable
0:   {
0:     if (logWriter_ != null) logWriter_.traceEntry (this, "finalize");
0:     close();
0:   }
1: 
0:   public synchronized void close() throws SqlException
0:   {
0:     if (logWriter_ != null) logWriter_.traceEntry (this, "close");
1: 
0:     if ( logicalConnection_ != null ) {
0:       logicalConnection_.nullPhysicalConnection();
0:       logicalConnection_ = null;
0:     }
1: 
0:     if (physicalConnection_ == null) return;
0:     try {
0:       // Even if the physcial connection is marked closed (in the pool),
0:       // this will close its underlying resources.
0:       physicalConnection_.closeResources();
0:     }
0:     finally {
0:       physicalConnection_ = null;
0:     }
0:   }
1: 
0:   // This is the standard API for getting a logical connection handle for a pooled connection.
0:   // No "resettable" properties are passed, so user, password, and all other properties may not change.
0:   public synchronized java.sql.Connection getConnection() throws SqlException
0:   {
0:     if (logWriter_ != null) logWriter_.traceEntry (this, "getConnection");
0:     createLogicalConnection ();
1: 
0: 	if (!newPC_)
0:       physicalConnection_.reset (logWriter_, user_, password_, ds_, false); // false means do not recompute
0:                                                                             // properties from the dataSource
0:     // properties don't change
0:    else {
0:      physicalConnection_.lightReset();    //poolfix
0:     }
0:     newPC_ = false;
1: 
0:     if (logWriter_ != null) logWriter_.traceExit (this, "getConnection", logicalConnection_);
0:     return logicalConnection_;
0:   }
1: 
0:   private void createLogicalConnection () throws SqlException
0:   {
0:     if (physicalConnection_ == null)
0:       throw new SqlException (logWriter_, "getConnection() is not valid on a closed PooledConnection.");
0:     // Not the usual case, but if we have an existing logical connection, then we must close it by spec.
0:     // We close the logical connection without notifying the pool manager that this pooled connection is availabe for reuse.
0:     if (logicalConnection_ != null) logicalConnection_.closeWithoutRecyclingToPool();
0:     logicalConnection_ = new org.apache.derby.client.am.LogicalConnection (physicalConnection_, this);
0:   }
1: 
0:   public synchronized void addConnectionEventListener (javax.sql.ConnectionEventListener listener)
0:   {
0:     if (logWriter_ != null) logWriter_.traceEntry (this, "addConnectionEventListener", listener);
0:     listeners_.addElement (listener);
0:   }
1: 
0:   public synchronized void removeConnectionEventListener (javax.sql.ConnectionEventListener listener )
0:   {
0:     if (logWriter_ != null) logWriter_.traceEntry (this, "removeConnectionEventListener", listener);
0:     listeners_.removeElement( listener );
0:   }
1: 
0:   // Not public, but needs to be visible to am.LogicalConnection
0:   public void recycleConnection ()
0:   {
0:     if (physicalConnection_.agent_.loggingEnabled())
0:       physicalConnection_.agent_.logWriter_.traceEntry (this, "recycleConnection");
1: 
0:     for (java.util.Enumeration e = listeners_.elements(); e.hasMoreElements(); ) {
0:       javax.sql.ConnectionEventListener listener = (javax.sql.ConnectionEventListener) e.nextElement();
0:       javax.sql.ConnectionEvent event = new javax.sql.ConnectionEvent (this);
0:       listener.connectionClosed (event);
0:     }
0:   }
1: 
0:   // Not public, but needs to be visible to am.LogicalConnection
0:   public void trashConnection (SqlException exception)
0:   {
0:     for (java.util.Enumeration e = listeners_.elements(); e.hasMoreElements(); ) {
0:       javax.sql.ConnectionEventListener listener = (javax.sql.ConnectionEventListener) e.nextElement();
0:       javax.sql.ConnectionEvent event = new javax.sql.ConnectionEvent (this, exception);
0:       listener.connectionErrorOccurred (event);
0:     }
0:   }
1: 
0:   // Used by LogicalConnection close when it disassociates itself from the ClientPooledConnection
0:   public synchronized void nullLogicalConnection ()
0:   {
0:     logicalConnection_ = null;
0:   }
0: }
1: 
1: 
1: 
============================================================================