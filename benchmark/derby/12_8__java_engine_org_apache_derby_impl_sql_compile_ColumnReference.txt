2:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.compile.ColumnReference
1:345de35: 
1:2d37fd6:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2d37fd6:    contributor license agreements.  See the NOTICE file distributed with
1:2d37fd6:    this work for additional information regarding copyright ownership.
1:2d37fd6:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2d37fd6:    (the "License"); you may not use this file except in compliance with
1:2d37fd6:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
26:eac0369: 
8:eac0369:  */
1:125f918: 
1:eac0369: package	org.apache.derby.impl.sql.compile;
1:eac0369: 
1:f33fbaf: import java.util.List;
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: import org.apache.derby.iapi.reference.SQLState;
1:eac0369: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1:3bb140c: import org.apache.derby.iapi.services.context.ContextManager;
1:69f8afa: import org.apache.derby.iapi.sql.compile.Visitor;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: import org.apache.derby.iapi.store.access.Qualifier;
1:3bb140c: import org.apache.derby.iapi.types.DataTypeDescriptor;
1:eac0369: import org.apache.derby.iapi.util.JBitSet;
1:eac0369: 
4:eac0369: /**
1:3bb140c:  * A ColumnReference represents a column in the query tree.  The parser
1:3bb140c:  * generates a ColumnReference for each column reference.  A column reference
1:3bb140c:  * could be a column in a base table, a column in a view (which could expand
1:3bb140c:  * into a complex expression), or a column in a subquery in the FROM clause.
13:eac0369:  *
1:eac0369:  */
1:eac0369: 
1:eac0369: public class ColumnReference extends ValueNode
18:eac0369: {
1:2f8e6fb:     // For associating columns with the SOURCE and TARGET tables of MERGE statements.
1:2f8e6fb:     public  static  final   int MERGE_UNKNOWN = 0;
1:2f8e6fb:     public  static  final   int MERGE_SOURCE = MERGE_UNKNOWN + 1;
1:2f8e6fb:     public  static  final   int MERGE_TARGET = MERGE_SOURCE + 1;
1:2f8e6fb:     
1:b0456a0: 	private String	_columnName;
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** This is the user-specified table name.  It will be null if the
1:eac0369: 	** user specifies a column without a table name.  Leave it null even
1:eac0369: 	** when the column is bound as it is only used in binding.
1:eac0369: 	*/
1:b0456a0: 	private TableName	_qualifiedTableName;
1:ee21e7c: 
1:ee21e7c:     /**
1:ee21e7c:      * The FromTable this column reference is bound to.
1:ee21e7c:      */
1:ee21e7c:     private int tableNumber;
1:ee21e7c: 
1:ee21e7c:     /**
1:ee21e7c:      * The column number in the underlying FromTable. But note {@code source}.
1:ee21e7c:      * @see #source
1:ee21e7c:      */
1:ee21e7c:     private int columnNumber;
1:ee21e7c: 
1:ee21e7c:     /**
1:ee21e7c:      * This is where the value for this column reference will be coming from.
1:ee21e7c:      * Note that for join nodes, {@code tableNumber}/{@code columnNumber} will
1:ee21e7c:      * point to the column in the left or right join participant {@code
1:ee21e7c:      * FromTable}, whereas {@code source} will be bound to the RC in the result
1:ee21e7c:      * column list of the join node. See also the comment at the end of
1:ee21e7c:      * JoinNode#getMatchingColumn.
1:ee21e7c:      * @see JoinNode#getMatchingColumn
1:ee21e7c:      * @see #columnNumber
1:ee21e7c:      * @see #tableNumber
1:ee21e7c:      */
1:ee21e7c:     private ResultColumn source;
1:eac0369: 
1:eac0369: 	/* For unRemapping */
1:b0456a0: 	private ResultColumn	_origSource;
1:5b2f5de: 	private String	origName;
1:b0456a0: 	private int				_origTableNumber = -1;
1:b0456a0: 	private int				_origColumnNumber = -1;
1:eac0369: 
1:125f918:     /* For remembering original (tn,cn) of this CR during join flattening. */
1:125f918:     private int tableNumberBeforeFlattening = -1;
1:125f918:     private int columnNumberBeforeFlattening = -1;
1:125f918: 
1:eac0369: 	/* Reuse generated code where possible */
1:eac0369: 	//Expression genResult;
1:eac0369: 
1:eac0369: 	private boolean		replacesAggregate;
1:7a9ce7e: 	private boolean		replacesWindowFunctionCall;
1:eac0369: 
1:eac0369: 	private int			nestingLevel = -1;
1:eac0369: 	private int			sourceLevel = -1;
1:eac0369: 
1:df88f63: 	/* Whether or not this column reference been scoped for the
1:df88f63: 	   sake of predicate pushdown.
1:df88f63: 	 */
1:df88f63: 	private boolean		scoped;
1:df88f63: 
1:df88f63: 	/* List of saved remap data if this ColumnReference is scoped
1:df88f63: 	   and has been remapped multiple times.
1:df88f63: 	 */
1:71c8e86: 	private java.util.ArrayList<RemapInfo> remaps;
1:df88f63: 
1:2f8e6fb:     /** Columns mentioned by MERGE statements need to be associated
1:2f8e6fb:      * the SOURCE or TARGET table */
1:2f8e6fb:     private int _mergeTableID = MERGE_UNKNOWN;
1:2f8e6fb: 
1:3e77b5a:     /**
1:3bb140c:      * Constructor.
1:eac0369: 	 * This one is called by the parser where we could
1:eac0369: 	 * be dealing with delimited identifiers.
1:eac0369: 	 *
1:eac0369: 	 * @param columnName	The name of the column being referenced
1:eac0369: 	 * @param tableName		The qualification for the column
1:eac0369: 	 * @param tokBeginOffset begin position of token for the column name 
1:eac0369: 	 *					identifier from parser.
1:eac0369: 	 * @param tokEndOffset	end position of token for the column name 
1:eac0369: 	 *					identifier from parser.
1:3bb140c:      * @param cm           The context manager
1:eac0369: 	 */
1:3bb140c:     ColumnReference(String         columnName,
1:3bb140c:                     TableName      tableName,
1:3bb140c:                     int            tokBeginOffset,
1:3bb140c:                     int            tokEndOffset,
1:3bb140c:                     ContextManager cm)  {
1:3bb140c:         super(cm);
1:b0456a0:         _columnName = columnName;
1:b0456a0:         _qualifiedTableName = tableName;
1:3bb140c:         this.setBeginOffset(tokBeginOffset);
1:3bb140c:         this.setEndOffset(tokEndOffset);
1:eac0369: 		tableNumber = -1;
1:df88f63: 		remaps = null;
12:eac0369: 	}
1:c723732: 
1:c723732: 	/**
1:3bb140c:      * Constructor.
1:c723732: 	 *
1:eac0369: 	 * @param columnName	The name of the column being referenced
1:eac0369: 	 * @param tableName		The qualification for the column
1:3bb140c:      * @param cm           The context manager
1:c723732: 	 */
1:3bb140c:     ColumnReference(String         columnName,
1:3bb140c:                     TableName      tableName,
1:3bb140c:                     ContextManager cm) {
1:3bb140c:         super(cm);
1:b0456a0:         _columnName = columnName;
1:b0456a0:         _qualifiedTableName = tableName;
1:eac0369: 		tableNumber = -1;
1:df88f63: 		remaps = null;
1:c723732: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
1:eac0369: 	 * for how this should be done for tree printing.
1:c723732: 	 *
1:eac0369: 	 * @return	This object as a String
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	public String toString()
1:c723732: 	{
5:eac0369: 		if (SanityManager.DEBUG)
1:01217c2: 		{
1:b0456a0: 			return "columnName: " + _columnName + "\n" +
1:eac0369: 				"tableNumber: " + tableNumber + "\n" +
1:eac0369: 				"columnNumber: " + columnNumber + "\n" +
1:eac0369: 				"replacesAggregate: " + replacesAggregate + "\n" +
1:7a9ce7e: 				"replacesWindowFunctionCall: " +
1:7a9ce7e: 				    replacesWindowFunctionCall + "\n" +
1:b0456a0: 				"tableName: " + ( ( _qualifiedTableName != null) ?
1:b0456a0: 								  _qualifiedTableName.toString() :
1:7a9ce7e: 								  "null") + "\n" +
1:eac0369: 				"nestingLevel: " + nestingLevel + "\n" +
1:eac0369: 				"sourceLevel: " + sourceLevel + "\n" +
1:eac0369: 				super.toString();
1:eac0369: 		}
3:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return "";
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
1:eac0369: 	 * how tree printing is supposed to work.
1:eac0369: 	 *
1:eac0369: 	 * @param depth		The depth of this node in the tree
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     void printSubNodes(int depth)
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			super.printSubNodes(depth);
1:eac0369: 
1:eac0369: 			if (source != null)
1:eac0369: 			{
1:eac0369: 				printLabel(depth, "source: ");
1:eac0369: 				source.treePrint(depth + 1);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return whether or not this CR is correlated.
1:eac0369: 	 *
1:eac0369: 	 * @return Whether or not this CR is correlated.
1:eac0369: 	 */
1:eac0369: 	boolean getCorrelated()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(nestingLevel != -1,
1:b0456a0: 				"nestingLevel on "+_columnName+" is not expected to be -1");
1:eac0369: 			SanityManager.ASSERT(sourceLevel != -1,
1:b0456a0: 				"sourceLevel on "+_columnName+" is not expected to be -1");
1:eac0369: 		}
1:eac0369: 		return sourceLevel != nestingLevel;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set the nesting level for this CR.  (The nesting level
1:eac0369: 	 * at which the CR appears.)
1:eac0369: 	 *
1:eac0369: 	 * @param nestingLevel	The Nesting level at which the CR appears.
1:eac0369: 	 */
1:eac0369: 	void setNestingLevel(int nestingLevel)
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(nestingLevel != -1,
1:eac0369: 				"nestingLevel is not expected to be -1");
1:eac0369: 		}
1:eac0369: 		this.nestingLevel = nestingLevel;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the nesting level for this CR.
1:eac0369: 	 *
1:eac0369: 	 * @return	The nesting level for this CR.
1:eac0369: 	 */
1:e9ec322: 	private int getNestingLevel()
1:eac0369: 	{
1:eac0369: 		return nestingLevel;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set the source level for this CR.  (The nesting level
1:eac0369: 	 * of the source of the CR.)
1:eac0369: 	 *
1:eac0369: 	 * @param sourceLevel	The Nesting level of the source of the CR.
1:eac0369: 	 */
1:eac0369: 	void setSourceLevel(int sourceLevel)
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(sourceLevel != -1,
1:eac0369: 				"sourceLevel is not expected to be -1");
1:eac0369: 		}
1:eac0369: 		this.sourceLevel = sourceLevel;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the source level for this CR.
1:eac0369: 	 *
1:eac0369: 	 * @return	The source level for this CR.
1:eac0369: 	 */
1:eac0369: 	int getSourceLevel()
1:eac0369: 	{
1:eac0369: 		return sourceLevel;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Mark this node as being generated to replace an aggregate.
1:eac0369: 	 * (Useful for replacing aggregates in the HAVING clause with 
1:eac0369: 	 * column references to the matching aggregate in the 
1:eac0369: 	 * user's SELECT.
1:eac0369: 	 */
1:3bb140c:     void markGeneratedToReplaceAggregate()
1:eac0369: 	{
1:eac0369: 		replacesAggregate = true;
1:eac0369: 	}
1:7a9ce7e: 
1:eac0369: 
1:7a9ce7e: 	/**
1:7a9ce7e: 	 * Mark this node as being generated to replace a window function call.
1:7a9ce7e: 	 */
1:3bb140c:     void markGeneratedToReplaceWindowFunctionCall()
1:7a9ce7e: 	{
1:7a9ce7e: 		replacesWindowFunctionCall = true;
1:7a9ce7e: 	}
1:7a9ce7e: 
1:eac0369: 	/**
1:eac0369: 	 * Determine whether or not this node was generated to
1:eac0369: 	 * replace an aggregate in the user's SELECT.
1:eac0369: 	 *
1:eac0369: 	 * @return boolean	Whether or not this node was generated to replace
1:eac0369: 	 *					an aggregate in the user's SELECT.
1:eac0369: 	 */
1:3bb140c:     boolean getGeneratedToReplaceAggregate()
1:eac0369: 	{
1:eac0369: 		return replacesAggregate;
1:eac0369: 	}
1:7a9ce7e: 
1:eac0369: 
1:7a9ce7e: 	/**
1:7a9ce7e: 	 * Determine whether or not this node was generated to
1:7a9ce7e: 	 * replace a window function call in the user's SELECT.
1:7a9ce7e: 	 *
1:7a9ce7e: 	 * @return boolean	Whether or not this node was generated to replace
1:7a9ce7e: 	 *					a window function call in the user's SELECT.
1:7a9ce7e: 	 */
1:3bb140c:     boolean getGeneratedToReplaceWindowFunctionCall()
1:7a9ce7e: 	{
1:7a9ce7e: 		return replacesWindowFunctionCall;
1:7a9ce7e: 	}
1:7a9ce7e: 
1:eac0369: 	/**
1:eac0369: 	 * Return a clone of this node.
1:eac0369: 	 *
1:eac0369: 	 * @return ValueNode	A clone of this node.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException			Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     ValueNode getClone()
2:eac0369: 		throws StandardException
1:eac0369: 	{
1:3bb140c:         ColumnReference newCR =
1:b0456a0:                 new ColumnReference(_columnName, _qualifiedTableName, getContextManager());
1:eac0369: 
1:eac0369: 		newCR.copyFields(this);
1:eac0369: 		return newCR;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Copy all of the "appropriate fields" for a shallow copy.
1:eac0369: 	 *
1:eac0369: 	 * @param oldCR		The ColumnReference to copy from.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException			Thrown on error
1:eac0369: 	 */
1:3bb140c:     void copyFields(ColumnReference oldCR)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		super.copyFields(oldCR);
1:eac0369: 
1:3e77b5a: 		setQualifiedTableName( oldCR.getQualifiedTableName() );
1:eac0369: 		tableNumber = oldCR.getTableNumber();
1:eac0369: 		columnNumber = oldCR.getColumnNumber();
1:eac0369: 		source = oldCR.getSource();
1:eac0369: 		nestingLevel = oldCR.getNestingLevel();
1:eac0369: 		sourceLevel = oldCR.getSourceLevel();
1:eac0369: 		replacesAggregate = oldCR.getGeneratedToReplaceAggregate();
1:7a9ce7e: 		replacesWindowFunctionCall =
1:7a9ce7e: 			oldCR.getGeneratedToReplaceWindowFunctionCall();
1:df88f63: 		scoped = oldCR.isScoped();
1:070d37e:         copyTagsFrom( oldCR );
1:2f8e6fb:         if ( oldCR._mergeTableID != MERGE_UNKNOWN )
1:2f8e6fb:         {
1:2f8e6fb:             setMergeTableID( oldCR.getMergeTableID() );
1:2f8e6fb:         }
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Bind this expression.  This means binding the sub-expressions,
1:eac0369: 	 * as well as figuring out what the return type is for this expression.
1:eac0369: 	 *
1:eac0369: 	 * NOTE: We must explicitly check for a null FromList here, column reference
1:eac0369: 	 * without a FROM list, as the grammar allows the following:
1:eac0369: 	 *			insert into t1 values(c1)
1:eac0369: 	 *
1:eac0369: 	 * @param fromList		The FROM list for the query this
1:eac0369: 	 *				expression is in, for binding columns.
1:eac0369: 	 * @param subqueryList		The subquery list being built as we find SubqueryNodes
1:09c2697:      * @param aggregates        The aggregate list being built as we find AggregateNodes
1:eac0369: 	 *
1:eac0369: 	 * @return	The new top of the expression tree.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:4fc5f9c:     ColumnReference bindExpression(FromList fromList,
1:3bb140c:                              SubqueryList subqueryList,
1:3bb140c:                              List<AggregateNode> aggregates)
1:3bb140c:             throws StandardException
1:eac0369: 	{
1:eac0369: 		ResultColumn matchingRC;
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(fromList != null, "fromList is expected to be non-null");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (fromList.size() == 0)
1:eac0369: 		{
1:b0456a0: 			throw StandardException.newException(SQLState.LANG_ILLEGAL_COLUMN_REFERENCE, _columnName);
1:eac0369: 		}
1:eac0369: 
1:2f8e6fb:         matchingRC = fromList.bindColumnReference(this);
1:eac0369: 
1:eac0369: 		/* Error if no match found in fromList */
1:eac0369: 		if (matchingRC == null)
1:eac0369: 		{
1:f1d4e9d: 			throw StandardException.newException(SQLState.LANG_COLUMN_NOT_FOUND, getSQLColumnName());
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return this;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:f1d4e9d: 	 * Get the column name for purposes of error
1:f1d4e9d: 	 * messages or debugging. This returns the column
1:f1d4e9d: 	 * name as used in the SQL statement. Thus if it was qualified
1:f1d4e9d: 	 * with a table, alias name that will be included.
1:eac0369: 	 *
1:f1d4e9d: 	 * @return	The  column name in the form [[schema.]table.]column
1:eac0369: 	 */
1:f1d4e9d: 
1:3bb140c:     String getSQLColumnName()
1:eac0369: 	{
1:b0456a0: 		if (_qualifiedTableName == null)
1:b0456a0:         {
1:b0456a0: 			return _columnName;
1:b0456a0:         }
1:eac0369: 		
1:b0456a0: 		return _qualifiedTableName.toString() + "." + _columnName;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the name of this column
1:eac0369: 	 *
1:eac0369: 	 * @return	The name of this column
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	public String getColumnName()
1:eac0369: 	{
1:b0456a0: 		return _columnName;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the table number for this ColumnReference.
1:eac0369: 	 *
1:eac0369: 	 * @return	int The table number for this ColumnReference
1:eac0369: 	 */
1:eac0369: 
1:3bb140c:     int getTableNumber()
1:eac0369: 	{
1:eac0369: 		return tableNumber;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set this ColumnReference to refer to the given table number.
1:eac0369: 	 *
1:6b50965: 	 * @param tableNumber	The table number this ColumnReference will refer to
1:eac0369: 	 */
1:eac0369: 
1:3bb140c:     void setTableNumber(int tableNumber)
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
2:eac0369: 			SanityManager.ASSERT(tableNumber != -1,
2:eac0369: 				"tableNumber not expected to be -1");
1:eac0369: 		}
1:eac0369: 		this.tableNumber = tableNumber;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the user-supplied table name of this column.  This will be null
1:eac0369: 	 * if the user did not supply a name (for example, select a from t).
1:b57ee34: 	 * The method will return B for this example, select b.a from t as b
1:b57ee34: 	 * The method will return T for this example, select t.a from t
1:eac0369: 	 *
1:eac0369: 	 * @return	The user-supplied name of this column.  Null if no user-
1:eac0369: 	 * 		supplied name.
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     String getTableName()
1:eac0369: 	{
1:b0456a0: 		return ( ( _qualifiedTableName != null) ? _qualifiedTableName.getTableName() : null );
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:b57ee34: 	 * Get the name of the underlying(base) table this column comes from, if any.
1:b57ee34: 	 * Following example queries will all return T
1:b57ee34: 	 * select a from t
1:b57ee34: 	 * select b.a from t as b
1:b57ee34: 	 * select t.a from t
1:eac0369: 	 *
1:b57ee34: 	 * @return	The name of the base table that this column comes from.
1:eac0369: 	 *			Null if not a ColumnReference.
1:eac0369: 	 */
1:eac0369: 
1:3bb140c:     String getSourceTableName()
1:eac0369: 	{
1:b57ee34: 		return ((source != null) ? source.getTableName() : null);
1:b57ee34: 	}
1:b57ee34: 
1:b57ee34: 	/**
1:b57ee34: 	 * Get the name of the schema for the Column's base table, if any.
1:b57ee34: 	 * Following example queries will all return APP (assuming user is in schema APP)
1:b57ee34: 	 * select t.a from t
1:b57ee34: 	 * select b.a from t as b
1:b57ee34: 	 * select app.t.a from t
1:b57ee34: 	 *
1:b57ee34: 	 * @return	The name of the schema for Column's base table. If the column
1:b57ee34: 	 *		is not in a schema (i.e. is a derived column), it returns NULL.
1:b57ee34: 	 */
1:3bb140c:     String getSourceSchemaName() throws StandardException
1:b57ee34: 	{
1:b57ee34: 		return ((source != null) ? source.getSchemaName() : null);
1:b57ee34: 	}
1:b57ee34: 
1:b57ee34: 	/**
1:b57ee34: 	 * Is the column wirtable by the cursor or not. (ie, is it in the list of FOR UPDATE columns list)
1:b57ee34: 	 *
1:b57ee34: 	 * @return TRUE, if the column is a base column of a table and is 
1:b57ee34: 	 * writable by cursor.
1:b57ee34: 	 */
1:3bb140c:     @Override
1:b57ee34: 	public boolean updatableByCursor()
1:b57ee34: 	{
1:b57ee34: 		return ((source != null) ? source.updatableByCursor() : false);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  Return the table name as the node it is.
1:eac0369: 	  @return the column's table name.
1:eac0369: 	 */
1:b0456a0: 	public TableName getQualifiedTableName()
1:eac0369: 	{
1:b0456a0: 		return _qualifiedTableName;
1:eac0369: 	}
1:eac0369: 
1:b0456a0:     void setQualifiedTableName(TableName tableName)
1:eac0369: 	{
1:b0456a0: 		_qualifiedTableName = tableName;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the column number for this ColumnReference.
1:eac0369: 	 *
1:eac0369: 	 * @return	int The column number for this ColumnReference
1:eac0369: 	 */
1:eac0369: 
1:3bb140c:     int getColumnNumber()
1:eac0369: 	{
1:eac0369: 		return columnNumber;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:6718a25: 	 * Set the column number for this ColumnReference.  This is
1:6718a25: 	 * used when scoping predicates for pushdown.
1:eac0369: 	 *
1:e98f05a: 	 * @param colNum The new column number.
1:eac0369: 	 */
1:eac0369: 
1:3bb140c:     void setColumnNumber(int colNum)
1:eac0369: 	{
1:6718a25: 		this.columnNumber = colNum;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the source this columnReference
1:eac0369: 	 *
1:eac0369: 	 * @return	The source of this columnReference
1:eac0369: 	 */
1:eac0369: 
1:3bb140c:     ResultColumn getSource()
1:eac0369: 	{
1:eac0369: 		return source;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set the source this columnReference
1:eac0369: 	 *
1:eac0369: 	 * @param source	The source of this columnReference
1:eac0369: 	 */
1:eac0369: 
1:3bb140c:     void setSource(ResultColumn source)
1:eac0369: 	{
1:eac0369: 		this.source = source;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Do the 1st step in putting an expression into conjunctive normal
1:eac0369: 	 * form.  This step ensures that the top level of the expression is
1:eac0369: 	 * a chain of AndNodes.
1:eac0369: 	 *
1:eac0369: 	 * @return		The modified expression
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     ValueNode putAndsOnTop()
1:eac0369: 					throws StandardException
1:eac0369: 	{
1:eac0369: 		BinaryComparisonOperatorNode		equalsNode;
1:eac0369: 		BooleanConstantNode	trueNode;
1:eac0369: 
1:3bb140c:         trueNode = new BooleanConstantNode(true, getContextManager());
1:3bb140c:         equalsNode = new BinaryRelationalOperatorNode(
1:2706d1f:                 BinaryRelationalOperatorNode.K_EQUALS,
1:2706d1f:                 this,
1:2706d1f:                 trueNode,
1:2706d1f:                 false,
1:2706d1f:                 getContextManager());
1:eac0369: 		/* Set type info for the operator node */
1:eac0369: 		equalsNode.bindComparisonOperator();
1:3bb140c: 
1:3bb140c:         AndNode andNode =
1:3bb140c:                 new AndNode(equalsNode, trueNode, getContextManager());
1:3bb140c:        andNode.postBindFixup();
1:eac0369: 		return andNode;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Categorize this predicate.  Initially, this means
1:eac0369: 	 * building a bit map of the referenced tables for each predicate.
1:eac0369: 	 * If the source of this ColumnReference (at the next underlying level) 
1:eac0369: 	 * is not a ColumnReference or a VirtualColumnNode then this predicate
1:eac0369: 	 * will not be pushed down.
1:eac0369: 	 *
1:eac0369: 	 * For example, in:
1:eac0369: 	 *		select * from (select 1 from s) a (x) where x = 1
1:eac0369: 	 * we will not push down x = 1.
1:eac0369: 	 * NOTE: It would be easy to handle the case of a constant, but if the
1:eac0369: 	 * inner SELECT returns an arbitrary expression, then we would have to copy
1:eac0369: 	 * that tree into the pushed predicate, and that tree could contain
1:eac0369: 	 * subqueries and method calls.
1:eac0369: 	 *
1:eac0369: 	 * Also, don't allow a predicate to be pushed down if it contains a
1:eac0369: 	 * ColumnReference that replaces an aggregate.  This can happen if
1:eac0369: 	 * the aggregate is in the HAVING clause.  In this case, we would be
1:eac0369: 	 * pushing the predicate into the SelectNode that evaluates the aggregate,
1:eac0369: 	 * which doesn't make sense, since the having clause is supposed to be
1:eac0369: 	 * applied to the result of the SelectNode.
1:7a9ce7e: 	 * This also goes for column references that replaces a window function.
1:7a9ce7e: 	 *
1:eac0369: 	 *
1:eac0369: 	 * RESOLVE - revisit this issue once we have views.
1:eac0369: 	 *
1:eac0369: 	 * @param referencedTabs	JBitSet with bit map of referenced FromTables
1:eac0369: 	 * @param simplePredsOnly	Whether or not to consider method
1:eac0369: 	 *							calls, field references and conditional nodes
1:eac0369: 	 *							when building bit map
1:eac0369: 	 *
1:eac0369: 	 * @return boolean		Whether or not source.expression is a ColumnReference
1:eac0369: 	 *						or a VirtualColumnNode or a ConstantNode.
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     boolean categorize(JBitSet referencedTabs, boolean simplePredsOnly)
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		SanityManager.ASSERT(tableNumber >= 0,
1:eac0369: 							 "tableNumber is expected to be non-negative");
1:eac0369: 		referencedTabs.set(tableNumber);
1:eac0369: 
1:eac0369: 		return ( ! replacesAggregate ) &&
1:7a9ce7e: 			   ( ! replacesWindowFunctionCall ) &&
1:eac0369: 			   ( (source.getExpression() instanceof ColumnReference) ||
1:eac0369: 			     (source.getExpression() instanceof VirtualColumnNode) ||
1:eac0369: 				 (source.getExpression() instanceof ConstantNode));
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Remap all of the ColumnReferences in this expression tree
1:eac0369: 	 * to point to the ResultColumn that is 1 level under their
1:eac0369: 	 * current source ResultColumn.
1:eac0369: 	 * This is useful for pushing down single table predicates.
1:eac0369: 	 *
1:eac0369: 	 * RESOLVE: Once we start pushing join clauses, we will need to walk the
1:eac0369: 	 * ResultColumn/VirtualColumnNode chain for them to remap the references.
1:eac0369: 	 */
1:3bb140c:     void remapColumnReferences()
1:eac0369: 	{
2:eac0369: 		ValueNode expression = source.getExpression();
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:b0456a0: 			// SanityManager.ASSERT(_origSource == null,
1:eac0369: 			// 		"Trying to remap ColumnReference twice without unremapping it.");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if ( ! ( (expression instanceof VirtualColumnNode) ||
1:eac0369: 				 (expression instanceof ColumnReference) )
2:eac0369: 			)
1:eac0369: 		{
1:eac0369: 			return;
1:eac0369: 		}
1:eac0369: 
1:df88f63: 		/* Scoped column references are a special case: they can be
1:df88f63: 		 * remapped several times (once for every ProjectRestrictNode
1:df88f63: 		 * through which the scoped ColumnReference is pushed before
1:df88f63: 		 * reaching its target result set) and will be un-remapped
1:df88f63: 		 * several times, as well (as the scoped predicate is "pulled"
1:df88f63: 		 * back up the query tree to it's original location).  So we
1:df88f63: 		 * have to keep track of the "orig" info for every remap
1:df88f63: 		 * operation, not just for the most recent one.
1:df88f63: 		 */
1:b0456a0: 		if (scoped && (_origSource != null))
1:df88f63: 		{
1:df88f63: 			if (remaps == null)
1:71c8e86: 				remaps = new java.util.ArrayList<RemapInfo>();
1:df88f63: 			remaps.add(new RemapInfo(
1:b0456a0: 				columnNumber, tableNumber, _columnName, source));
1:df88f63: 		}
1:df88f63: 		else
1:df88f63: 		{
1:b0456a0: 			_origSource = source;
1:b0456a0: 			origName = _columnName;
1:b0456a0: 			_origColumnNumber = columnNumber;
1:b0456a0: 			_origTableNumber = tableNumber;
1:df88f63: 		}
1:df88f63: 
2:eac0369: 		/* Find the matching ResultColumn */
1:eac0369: 		source = getSourceResultColumn();
1:b0456a0: 		_columnName = source.getName();
1:d7f41dd:         // Use the virtual column id if the ResultColumn's expression
1:d7f41dd:         // is a virtual column (DERBY-5933).
1:d7f41dd:         columnNumber = source.getExpression() instanceof VirtualColumnNode ?
1:d7f41dd:                 source.getVirtualColumnId() : source.getColumnPosition();
1:eac0369: 
1:eac0369: 		if (source.getExpression() instanceof ColumnReference)
1:eac0369: 		{
1:eac0369: 			ColumnReference cr = (ColumnReference) source.getExpression();
1:eac0369: 			tableNumber = cr.getTableNumber();
1:eac0369: 			if (SanityManager.DEBUG)
1:eac0369: 			{
1:eac0369: 				// if dummy cr generated to replace aggregate, it may not have table number
1:eac0369: 				// because underneath can be more than 1 table.
1:eac0369: 				if (tableNumber == -1 && ! cr.getGeneratedToReplaceAggregate())
1:eac0369: 				{
3:eac0369: 					SanityManager.THROWASSERT(
1:eac0369: 						"tableNumber not expected to be -1, origName = " + origName);
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:3bb140c:     void unRemapColumnReferences()
1:eac0369: 	{
1:b0456a0: 		if (_origSource == null)
1:b0456a0:         {
1:eac0369: 			return;
1:b0456a0:         }
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:b0456a0: 			// SanityManager.ASSERT(_origSource != null,
1:eac0369: 			// 	"Trying to unremap a ColumnReference that was not remapped.");
1:eac0369: 		}
1:eac0369: 
1:3bb140c:         if ((remaps == null) || (remaps.isEmpty()))
1:df88f63: 		{
1:b0456a0: 			source = _origSource;
1:b0456a0: 			_origSource = null;
1:b0456a0: 			_columnName = origName;
1:df88f63: 			origName = null;
1:b0456a0: 			tableNumber = _origTableNumber;
1:b0456a0: 			columnNumber = _origColumnNumber;
1:df88f63: 		}
1:df88f63: 		else
1:df88f63: 		{
1:df88f63: 			// This CR is multiply-remapped, so undo the most
1:df88f63: 			// recent (and only the most recent) remap operation.
1:71c8e86: 			RemapInfo rI = remaps.remove(remaps.size() - 1);
1:df88f63: 			source = rI.getSource();
1:b0456a0: 			_columnName = rI.getColumnName();
1:df88f63: 			tableNumber = rI.getTableNumber();
1:df88f63: 			columnNumber = rI.getColumnNumber();
1:3bb140c:             if (remaps.isEmpty())
1:df88f63: 				remaps = null;
1:df88f63: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:6718a25: 	 * Returns true if this ColumnReference has been remapped; false
1:6718a25: 	 * otherwise.
1:eac0369: 	 *
1:6718a25: 	 * @return Whether or not this ColumnReference has been remapped.
1:eac0369: 	 */
1:6718a25: 	protected boolean hasBeenRemapped()
1:eac0369: 	{
1:b0456a0: 		return (_origSource != null);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * Get the ResultColumn that the source points to.  This is useful for
1:eac0369: 	 * getting what the source will be after this ColumnReference is remapped.
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     ResultColumn getSourceResultColumn()
1:eac0369: 	{
1:e9ec322:         /* RESOLVE - If expression is a ColumnReference, then we are hitting
1:e9ec322:          * the top of a query block (derived table or view.)
1:e9ec322:          * In order to be able to push the expression down into the next
1:e9ec322:          * query block, it looks like we should reset the contents of the
1:e9ec322:          * current ColumnReference to be the same as expression.  (This probably
1:e9ec322:          * only means names and tableNumber.)  We would then "rebind" the top
1:e9ec322:          * level predicate somewhere up the call stack and see if we could push
1:e9ec322:          * the predicate through.
1:e9ec322:          */
1:e9ec322:         
1:e9ec322:         return source.getExpression().getSourceResultColumn();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Remap all ColumnReferences in this tree to be clones of the
1:eac0369: 	 * underlying expression.
1:eac0369: 	 *
1:eac0369: 	 * @return ValueNode			The remapped expression tree.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException			Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     ValueNode remapColumnReferencesToExpressions()
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		ResultColumn	rc;
1:eac0369: 		ResultColumn	sourceRC = source;
1:eac0369: 
1:eac0369: 		/* Nothing to do if we are not pointing to a redundant RC */
1:eac0369: 		if (! source.isRedundant())
1:eac0369: 		{
1:eac0369: 			return this;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* Find the last redundant RC in the chain.  We
1:eac0369: 		 * want to clone its expression.
1:eac0369: 		 */
1:eac0369: 		for (rc = source; rc != null && rc.isRedundant(); )
1:eac0369: 		{
1:eac0369: 			/* Find the matching ResultColumn */
1:e9ec322:             ResultColumn nextRC = rc.getExpression().getSourceResultColumn();
1:eac0369: 
1:eac0369: 			if (nextRC != null && nextRC.isRedundant())
1:eac0369: 			{
1:eac0369: 				sourceRC = nextRC;
1:eac0369: 			}
1:eac0369: 			rc = nextRC;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			if (sourceRC == null)
1:eac0369: 			{
1:eac0369: 				SanityManager.THROWASSERT(
1:eac0369: 					"sourceRC is expected to be non-null for " +
1:b0456a0: 					_columnName);
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			if ( ! sourceRC.isRedundant())
1:eac0369: 			{
1:eac0369: 				SanityManager.THROWASSERT(
1:eac0369: 					"sourceRC is expected to be redundant for " +
1:b0456a0: 					_columnName);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* If last expression is a VCN, then we can't clone it.
1:eac0369: 		 * Instead, we just reset our source to point to the
1:eac0369: 		 * source of the VCN, those chopping out the layers.
1:eac0369: 		 * Otherwise, we return a clone of the underlying expression.
1:eac0369: 		 */
1:eac0369: 		if (sourceRC.getExpression() instanceof VirtualColumnNode)
1:eac0369: 		{
1:eac0369: 			VirtualColumnNode vcn =
1:eac0369: 				(VirtualColumnNode) (sourceRC.getExpression());
1:eac0369: 			ResultSetNode rsn = vcn.getSourceResultSet();
1:eac0369: 			if (rsn instanceof FromTable)
1:eac0369: 			{
1:a3da76e: 				FromTable ft = (FromTable)rsn;
1:a3da76e: 
1:a3da76e: 				/* It's not enough to just set the table number.  Depending
1:a3da76e: 				 * on the original query specified and on whether or not
1:a3da76e: 				 * subquery flattening has occurred, it's possible that
1:a3da76e: 				 * the expression to which we're remapping has a different
1:a3da76e: 				 * RCL ordering than the one to which we were mapped before
1:a3da76e: 				 * we got here.  In that case we also need to update the
1:a3da76e: 				 * columnNumber to point to the correct column in "ft".
1:a3da76e: 				 * See DERBY-2526 for details.
1:125f918:                  * See DERBY-3023 and DERBY-4679 for further improvement
1:125f918:                  * details.
1:eac0369: 				 */
1:125f918: 
1:125f918:                 ResultColumnList rcl = ft.getResultColumns();
1:125f918: 
1:125f918:                 // Need to save original (tn,cn) in case we have several
1:125f918:                 // flattenings so we can relocate the correct column many
1:125f918:                 // times. After the first flattening, the (tn,cn) pair points
1:125f918:                 // to the top RCL which is going away..
1:125f918:                 if (tableNumberBeforeFlattening == -1) {
1:125f918:                     tableNumberBeforeFlattening = tableNumber;
1:125f918:                     columnNumberBeforeFlattening = columnNumber;
1:125f918:                 }
1:125f918: 
1:125f918:                 // Covers references to a table not being flattened out, e.g.
1:125f918:                 // inside a join tree, which can have many columns in the rcl
1:125f918:                 // with the same name, so looking up via column name can give
1:125f918:                 // the wrong column. DERBY-4679.
1:3bb140c:                 ResultColumn ftRC = rcl.getResultColumn(
1:125f918:                     tableNumberBeforeFlattening,
1:4ce669e:                     columnNumberBeforeFlattening,
1:b0456a0:                     _columnName);
1:125f918: 
1:125f918:                 if (ftRC == null) {
1:125f918:                     // The above lookup won't work for references to a base
1:125f918:                     // column, so fall back on column name, which is unique
1:125f918:                     // then.
1:b0456a0:                     ftRC = rcl.getResultColumn(_columnName);
1:125f918:                 }
1:125f918: 
1:125f918:                 if (SanityManager.DEBUG) {
1:125f918:                     SanityManager.ASSERT(
1:125f918:                         ftRC != null,
1:b0456a0:                         "Failed to find column '" + _columnName +
1:125f918:                         "' in the " + "RCL for '" + ft.getTableName() +
1:125f918:                         "'.");
1:125f918:                 }
1:125f918: 
1:125f918:                 tableNumber = ft.getTableNumber();
1:125f918: 
1:125f918: 				if (SanityManager.DEBUG) {
1:125f918: 					SanityManager.ASSERT(tableNumber != -1,
1:125f918: 						"tableNumber not expected to be -1");
1:a3da76e: 				}
1:a3da76e: 
1:2d2911e: 				/* Use the virtual column id if the ResultColumn's expression
1:2d2911e: 				 * is a virtual column (DERBY-3023).
1:2d2911e: 				 */
1:2d2911e: 				columnNumber =
1:2d2911e: 					(ftRC.getExpression() instanceof VirtualColumnNode)
1:2d2911e: 						? ftRC.getVirtualColumnId()
1:2d2911e: 						: ftRC.getColumnPosition();
1:eac0369: 			}
1:eac0369: 			else
1:a3da76e: 			{
1:a3da76e: 				if (SanityManager.DEBUG)
1:eac0369: 				{
1:eac0369: 					SanityManager.THROWASSERT("rsn expected to be a FromTable, but is a " + rsn.getClass().getName());
1:eac0369: 				}
1:eac0369: 			}
1:e9ec322: 			source = sourceRC.getExpression().getSourceResultColumn();
1:eac0369: 			return this;
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return sourceRC.getExpression().getClone();
1:eac0369: 		}
1:eac0369: 	}
1:a3da76e: 
1:eac0369: 	/** 
1:eac0369: 	 * Update the table map to reflect the source
1:eac0369: 	 * of this CR.
1:eac0369: 	 *
1:eac0369: 	 * @param refs	The table map.
1:a3da76e: 	 */
1:eac0369: 	void getTablesReferenced(JBitSet refs)
1:eac0369: 	{
1:eac0369: 		if (refs.size() < tableNumber)
1:eac0369: 			refs.grow(tableNumber);
1:eac0369: 
1:eac0369: 		if (tableNumber != -1)	// it may not be set if replacesAggregate is true
1:eac0369: 			refs.set(tableNumber);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return whether or not this expression tree is cloneable.
1:eac0369: 	 *
1:eac0369: 	 * @return boolean	Whether or not this expression tree is cloneable.
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     boolean isCloneable()
1:eac0369: 	{
1:eac0369: 		return true;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see ValueNode#constantExpression */
1:3bb140c:     @Override
1:3bb140c:     boolean constantExpression(PredicateList whereClause)
1:eac0369: 	{
1:eac0369: 		return whereClause.constantColumn(this);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * ColumnReference's are to the current row in the system.
1:eac0369: 	 * This lets us generate
1:eac0369: 	 * a faster get that simply returns the column from the
1:eac0369: 	 * current row, rather than getting the value out and
1:eac0369: 	 * returning that, only to have the caller (in the situations
1:eac0369: 	 * needed) stuffing it back into a new column holder object.
1:eac0369: 	 * We will assume the general generate() path is for getting
1:eac0369: 	 * the value out, and use generateColumn() when we want to
1:eac0369: 	 * keep the column wrapped.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:8fe3166:     void generateExpression(ExpressionClassBuilder acb, MethodBuilder mb)
1:eac0369: 									throws StandardException
1:eac0369: 	 {
1:eac0369: 		int sourceResultSetNumber = source.getResultSetNumber();
1:eac0369: 
1:eac0369: 		//PUSHCOMPILE
1:eac0369: 		/* Reuse generated code, where possible */
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** If the source is redundant, return the generation of its source.
1:eac0369: 		** Most redundant nodes will be flattened out by this point, but
1:eac0369: 		** in at least one case (elimination of redundant ProjectRestricts
1:eac0369: 		** during generation) we don't do this.
1:eac0369: 		*/
1:eac0369: 		if (source.isRedundant())
1:eac0369: 		{
1:eac0369: 			source.generateExpression(acb, mb);
1:eac0369: 			return;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			if (sourceResultSetNumber < 0)
1:eac0369: 			{
1:6718a25: 				SanityManager.THROWASSERT("sourceResultSetNumber expected to be >= 0 for " + getTableName() + "." + getColumnName());
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* The ColumnReference is from an immediately underlying ResultSet.
1:eac0369: 		 * The Row for that ResultSet is Activation.row[sourceResultSetNumber], 
1:eac0369: 		 * where sourceResultSetNumber is the resultSetNumber for that ResultSet.
1:eac0369: 		 *
1:eac0369: 		 * The generated java is the expression:
1:eac0369: 		 *	(<interface>) this.row[sourceResultSetNumber].getColumn(#columnId);
1:eac0369: 		 *
1:eac0369: 		 * where <interface> is the appropriate Datatype protocol interface
1:eac0369: 		 * for the type of the column.
1:eac0369: 		 */
1:eac0369: 	    acb.pushColumnReference(mb, sourceResultSetNumber, 
1:eac0369: 	    									source.getVirtualColumnId());
1:eac0369: 
1:eac0369: 		mb.cast(getTypeCompiler().interfaceName());
1:eac0369: 
1:eac0369: 		/* Remember generated code for possible resuse */
1:eac0369: 	 }
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the user-supplied schema name of this column.  This will be null
1:eac0369: 	 * if the user did not supply a name (for example, select t.a from t).
1:b57ee34: 	 * Another example for null return value (for example, select b.a from t as b).
1:b57ee34: 	 * But for following query select app.t.a from t, this will return APP
1:b57ee34: 	 * Code generation of aggregate functions relies on this method
1:eac0369: 	 *
1:eac0369: 	 * @return	The user-supplied schema name of this column.  Null if no user-
1:eac0369: 	 * 		supplied name.
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     String getSchemaName()
1:eac0369: 	{
1:b0456a0: 		return ( ( _qualifiedTableName != null) ? _qualifiedTableName.getSchemaName() : null );
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return the variant type for the underlying expression.
1:eac0369: 	 * The variant type can be:
1:eac0369: 	 *		VARIANT				- variant within a scan
1:eac0369: 	 *							  (method calls and non-static field access)
1:eac0369: 	 *		SCAN_INVARIANT		- invariant within a scan
1:eac0369: 	 *							  (column references from outer tables)
1:eac0369: 	 *		QUERY_INVARIANT		- invariant within the life of a query
1:eac0369: 	 *							  (constant expressions)
1:eac0369: 	 *
1:eac0369: 	 * @return	The variant type for the underlying expression.
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	protected int getOrderableVariantType()
1:eac0369: 	{
1:eac0369: 		// ColumnReferences are invariant for the life of the scan
1:eac0369: 		return Qualifier.SCAN_INVARIANT;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return whether or not the source of this ColumnReference is itself a ColumnReference.
1:eac0369: 	 *
1:eac0369: 	 * @return Whether or not the source of this ColumnReference is itself a ColumnReference.
1:eac0369: 	 */
1:eac0369: 	boolean pointsToColumnReference()
1:eac0369: 	{ 
1:eac0369: 		return (source.getExpression() instanceof ColumnReference);
1:eac0369: 	}
1:3527fd5: 
1:eac0369: 	/**
1:ed82406: 	 * The type of a ColumnReference is the type of its
1:ed82406:      * source unless the source is null then it is
1:ed82406:      * the type that has been set on this node.
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     DataTypeDescriptor getTypeServices()
1:ed82406: 	{        
1:ed82406:         if (source == null)
1:ed82406:             return super.getTypeServices();
1:ed82406:        
1:ed82406:         return source.getTypeServices();
1:ed82406:     }
1:eac0369: 
1:eac0369: 	/**
1:df88f63: 	 * Find the source result set for this ColumnReference and
1:df88f63: 	 * return it.  Also, when the source result set is found,
1:df88f63: 	 * return the position (within the source result set's RCL)
1:df88f63: 	 * of the column referenced by this ColumnReference.  The
1:df88f63: 	 * position is returned vai the colNum parameter.
1:eac0369: 	 *
1:df88f63: 	 * @param colNum Place to store the position of the column
1:df88f63: 	 *  to which this ColumnReference points (position is w.r.t
1:df88f63: 	 *  the source result set).
1:df88f63: 	 * @return The source result set for this ColumnReference;
1:df88f63: 	 *  null if there is no source result set.
1:eac0369: 	 */
1:df88f63: 	protected ResultSetNode getSourceResultSet(int [] colNum)
1:df88f63: 		throws StandardException
1:df88f63: 	{
1:df88f63: 		if (source == null)
1:eac0369: 		{
1:df88f63: 			/* this can happen if column reference is pointing to a column
1:df88f63: 			 * that is not from a base table.  For example, if we have a
1:df88f63: 			 * VALUES clause like
1:df88f63: 			 *
1:df88f63: 			 *    (values (1, 2), (3, 4)) V1 (i, j)
1:df88f63: 			 *
1:df88f63: 			 * and then a column reference to VI.i, the column reference
1:df88f63: 			 * won't have a source.
1:df88f63: 			 */
1:df88f63: 			return null;
1:eac0369: 		}
1:01217c2: 
1:df88f63: 		ResultColumn rc = getSource();
1:df88f63: 
1:df88f63: 		// Walk the ResultColumn->ColumnReference chain until we
1:df88f63: 		// find a ResultColumn whose expression is a VirtualColumnNode.
1:df88f63: 
1:3bb140c:         ValueNode rcExpr = rc.getExpression();
1:df88f63: 		colNum[0] = getColumnNumber();
1:df88f63: 
1:7e5c669: 		/* We have to make sure we enter this loop if rc is redundant,
1:7e5c669: 		 * so that we can navigate down to the actual source result
1:7e5c669: 		 * set (DERBY-1777). If rc *is* redundant, then rcExpr is not
1:7e5c669: 		 * guaranteed to be a ColumnReference, so we have to check
1:7e5c669: 		 * for that case inside the loop.
1:7e5c669: 		 */
1:7e5c669: 		while ((rcExpr != null) &&
1:7e5c669: 			(rc.isRedundant() || (rcExpr instanceof ColumnReference)))
1:df88f63: 		{
1:7e5c669: 			if (rcExpr instanceof ColumnReference)
1:7e5c669: 			{
1:7e5c669: 				colNum[0] = ((ColumnReference)rcExpr).getColumnNumber();
1:7e5c669: 				rc = ((ColumnReference)rcExpr).getSource();
1:7e5c669: 			}
1:df88f63: 
1:df88f63: 			/* If "rc" is redundant then that means it points to another
1:df88f63: 			 * ResultColumn that in turn points to the source expression.
1:df88f63: 			 * This can happen in cases where "rc" points to a subquery
1:df88f63: 			 * that has been flattened into the query above it (flattening
1:df88f63: 			 * of subqueries occurs during preprocessing).  In that case
1:df88f63: 			 * we want to skip over the redundant rc and find the
1:df88f63: 			 * ResultColumn that actually holds the source expression.
1:df88f63: 			 */
1:df88f63: 			while (rc.isRedundant())
1:df88f63: 			{
1:df88f63: 				rcExpr = rc.getExpression();
1:df88f63: 				if (rcExpr instanceof VirtualColumnNode)
1:e9ec322: 					rc = rcExpr.getSourceResultColumn();
1:df88f63: 				else if (rcExpr instanceof ColumnReference)
1:df88f63: 				{
2:df88f63: 					colNum[0] = ((ColumnReference)rcExpr).getColumnNumber();
2:df88f63: 					rc = ((ColumnReference)rcExpr).getSource();
1:df88f63: 				}
1:df88f63: 				else
1:df88f63: 				{
1:df88f63: 					/* If rc isn't pointing to a VirtualColumnNode nor
1:df88f63: 					 * to a ColumnReference, then it's not pointing to
1:df88f63: 					 * a result set.  It could, for example, be pointing
1:df88f63: 					 * to a constant node or to the result of an aggregate
1:df88f63: 					 * or function.  Break out of both loops and return
1:df88f63: 					 * null since there is no source result set.
1:df88f63: 					 */
1:df88f63: 					break;
1:df88f63: 				}
1:df88f63: 			}
1:df88f63: 			rcExpr = rc.getExpression();
1:eac0369: 		}
1:eac0369: 
1:df88f63: 		// If we found a VirtualColumnNode, return the VirtualColumnNode's
1:df88f63: 		// sourceResultSet.  The column within that sourceResultSet that
1:df88f63: 		// is referenced by this ColumnReference is also returned, via
1:df88f63: 		// the colNum parameter, and was set above.
1:df88f63: 		if ((rcExpr != null) && (rcExpr instanceof VirtualColumnNode))
1:df88f63: 			return ((VirtualColumnNode)rcExpr).getSourceResultSet();
1:eac0369: 
1:df88f63: 		// If we get here then the ColumnReference doesn't reference
1:df88f63: 		// a result set, so return null.
1:df88f63: 		colNum[0] = -1;
1:df88f63: 		return null;
1:df88f63: 	}
1:df88f63: 	
1:2706d1f:     boolean isEquivalent(ValueNode o) throws StandardException
1:df88f63: 	{
1:2706d1f:         if (! isSameNodeKind(o)) {
1:01217c2: 			return false;
1:01217c2: 		}
1:df88f63: 
1:01217c2: 		ColumnReference other = (ColumnReference)o;
1:01217c2: 		return (tableNumber == other.tableNumber 
1:b0456a0: 				&& _columnName.equals(other.getColumnName()));
1:01217c2: 	}
1:2706d1f: 
1:df88f63: 	/**
1:df88f63: 	 * Mark this column reference as "scoped", which means that it
1:df88f63: 	 * was created (as a clone of another ColumnReference) to serve
1:df88f63: 	 * as the left or right operand of a scoped predicate.
1:df88f63: 	 */
1:df88f63: 	protected void markAsScoped()
1:df88f63: 	{
1:df88f63: 		scoped = true;
1:df88f63: 	}
1:df88f63: 
1:df88f63: 	/**
1:df88f63: 	 * Return whether or not this ColumnReference is scoped.
1:df88f63: 	 */
1:df88f63: 	protected boolean isScoped()
1:df88f63: 	{
1:df88f63: 		return scoped;
1:df88f63: 	}
1:df88f63: 
1:2f8e6fb:     /** Associate this column with a SOURCE or TARGET table of a MERGE statement */
1:2f8e6fb:     void    setMergeTableID( int mergeTableID )
1:2f8e6fb:     {
1:2f8e6fb:         // Changing the association of a column means we are confused. Shouldn't happen.
1:b3f38f8:         if ( (_mergeTableID != MERGE_UNKNOWN) && (_mergeTableID != mergeTableID)  )
1:2f8e6fb:         {
1:2f8e6fb:             if (SanityManager.DEBUG)
1:2f8e6fb:             {
1:2f8e6fb:                 SanityManager.ASSERT
1:2f8e6fb:                     (
1:2f8e6fb:                      (_mergeTableID == mergeTableID),
1:b3f38f8:                      "MERGE statement can't re-associate column " + getSQLColumnName() +
1:b3f38f8:                      " from " + prettyPrintMergeTableID( _mergeTableID ) +
1:b3f38f8:                      " to " + prettyPrintMergeTableID( mergeTableID )
1:2f8e6fb:                      );
1:2f8e6fb:             }
1:2f8e6fb:         }
1:2f8e6fb: 
1:2f8e6fb:         _mergeTableID = mergeTableID;
1:2f8e6fb:     }
1:b3f38f8:     private String  prettyPrintMergeTableID( int mergeTableID )
1:b3f38f8:     {
1:b3f38f8:         switch ( mergeTableID )
1:b3f38f8:         {
1:b3f38f8:         case MERGE_SOURCE: return "SOURCE";
1:b3f38f8:         case MERGE_TARGET: return "TARGET";
1:b3f38f8:         default: return "UNKNOWN";
1:b3f38f8:         }
1:b3f38f8:     }
1:2f8e6fb: 
1:2f8e6fb:     /** Get the MERGE table (SOURCE or TARGET) associated with this column */
1:2f8e6fb:     int getMergeTableID()
1:2f8e6fb:     {
1:2f8e6fb:         return _mergeTableID;
1:2f8e6fb:     }
1:2f8e6fb: 
1:df88f63: 	/**
1:df88f63: 	 * Helper class to keep track of remap data when a ColumnReference
1:df88f63: 	 * is remapped multiple times.  This allows the CR to be UN-
1:df88f63: 	 * remapped multiple times, as well.
1:df88f63: 	 */
1:3bb140c:     private static class RemapInfo
1:2f8e6fb: 	{
1:df88f63: 		int colNum;
1:df88f63: 		int tableNum;
1:df88f63: 		String colName;
1:df88f63: 		ResultColumn source;
1:2f8e6fb: 
1:df88f63: 		RemapInfo(int cNum, int tNum, String cName, ResultColumn rc)
1:df88f63: 		{
1:df88f63: 			colNum = cNum;
1:df88f63: 			tableNum = tNum;
1:df88f63: 			colName = cName;
1:df88f63: 			source = rc;
1:2f8e6fb: 		}
1:df88f63: 
1:df88f63: 		int getColumnNumber() { return colNum; }
1:df88f63: 		int getTableNumber() { return tableNum; }
1:df88f63: 		String getColumnName() { return colName; }
1:df88f63: 		ResultColumn getSource() { return source; }
1:df88f63: 
1:df88f63: 		void setColNumber(int cNum) { colNum = cNum; }
1:df88f63: 		void setTableNumber(int tNum) { tableNum = tNum; }
1:df88f63: 		void setColName(String cName) { colName = cName; }
1:df88f63: 		void setSource(ResultColumn rc) { source = rc; }
1:df88f63: 	}
1:69f8afa: 
1:69f8afa:     @Override
1:69f8afa:     void acceptChildren(Visitor v) throws StandardException {
1:69f8afa:         super.acceptChildren(v);
1:69f8afa: 
1:b0456a0:         if (_qualifiedTableName != null) {
1:3e77b5a:             setQualifiedTableName( (TableName) _qualifiedTableName.accept(v) );
1:69f8afa:         }
1:69f8afa:     }
1:eac0369: }
============================================================================
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:4fc5f9c
/////////////////////////////////////////////////////////////////////////
1:     ColumnReference bindExpression(FromList fromList,
commit:69f8afa
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.compile.Visitor;
/////////////////////////////////////////////////////////////////////////
1: 
1:     @Override
1:     void acceptChildren(Visitor v) throws StandardException {
1:         super.acceptChildren(v);
1: 
0:         if (tableName != null) {
0:             tableName = (TableName) tableName.accept(v);
1:         }
1:     }
commit:8fe3166
/////////////////////////////////////////////////////////////////////////
1:     void generateExpression(ExpressionClassBuilder acb, MethodBuilder mb)
commit:09c2697
/////////////////////////////////////////////////////////////////////////
1:      * @param aggregates        The aggregate list being built as we find AggregateNodes
0:     ValueNode bindExpression(FromList fromList, SubqueryList subqueryList, List aggregates)
commit:f33fbaf
/////////////////////////////////////////////////////////////////////////
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 			List aggregateVector)
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:3e77b5a
/////////////////////////////////////////////////////////////////////////
1:     /**
/////////////////////////////////////////////////////////////////////////
1: 		setQualifiedTableName( oldCR.getQualifiedTableName() );
/////////////////////////////////////////////////////////////////////////
1:             setQualifiedTableName( (TableName) _qualifiedTableName.accept(v) );
commit:b3f38f8
/////////////////////////////////////////////////////////////////////////
1:         if ( (_mergeTableID != MERGE_UNKNOWN) && (_mergeTableID != mergeTableID)  )
1:                      "MERGE statement can't re-associate column " + getSQLColumnName() +
1:                      " from " + prettyPrintMergeTableID( _mergeTableID ) +
1:                      " to " + prettyPrintMergeTableID( mergeTableID )
1:     private String  prettyPrintMergeTableID( int mergeTableID )
1:     {
1:         switch ( mergeTableID )
1:         {
1:         case MERGE_SOURCE: return "SOURCE";
1:         case MERGE_TARGET: return "TARGET";
1:         default: return "UNKNOWN";
1:         }
1:     }
/////////////////////////////////////////////////////////////////////////
commit:2f8e6fb
/////////////////////////////////////////////////////////////////////////
1:     // For associating columns with the SOURCE and TARGET tables of MERGE statements.
1:     public  static  final   int MERGE_UNKNOWN = 0;
1:     public  static  final   int MERGE_SOURCE = MERGE_UNKNOWN + 1;
1:     public  static  final   int MERGE_TARGET = MERGE_SOURCE + 1;
1:     
/////////////////////////////////////////////////////////////////////////
1:     /** Columns mentioned by MERGE statements need to be associated
1:      * the SOURCE or TARGET table */
1:     private int _mergeTableID = MERGE_UNKNOWN;
1: 
/////////////////////////////////////////////////////////////////////////
1:         if ( oldCR._mergeTableID != MERGE_UNKNOWN )
1:         {
1:             setMergeTableID( oldCR.getMergeTableID() );
1:         }
/////////////////////////////////////////////////////////////////////////
1:         matchingRC = fromList.bindColumnReference(this);
/////////////////////////////////////////////////////////////////////////
1:     /** Associate this column with a SOURCE or TARGET table of a MERGE statement */
1:     void    setMergeTableID( int mergeTableID )
1:     {
1:         // Changing the association of a column means we are confused. Shouldn't happen.
0:         if ( _mergeTableID != MERGE_UNKNOWN )
1:         {
1:             if (SanityManager.DEBUG)
1:             {
1:                 SanityManager.ASSERT
1:                     (
1:                      (_mergeTableID == mergeTableID),
0:                      "MERGE statement can't re-associate column " + debugName()
1:                      );
1:             }
1:         }
1: 
1:         _mergeTableID = mergeTableID;
1:     }
1: 
1:     /** Get the MERGE table (SOURCE or TARGET) associated with this column */
1:     int getMergeTableID()
1:     {
1:         return _mergeTableID;
1:     }
1: 
0:     /** Get the name of this column (for debugging printout) */
0:     String  debugName()
1:     {
0:         if ( _qualifiedTableName == null ) { return _columnName; }
0:         else { return _qualifiedTableName + "." + _columnName; }
1:     }
1: 
commit:b0456a0
/////////////////////////////////////////////////////////////////////////
1: 	private String	_columnName;
1: 	private TableName	_qualifiedTableName;
/////////////////////////////////////////////////////////////////////////
1: 	private ResultColumn	_origSource;
1: 	private int				_origTableNumber = -1;
1: 	private int				_origColumnNumber = -1;
/////////////////////////////////////////////////////////////////////////
1:         _columnName = columnName;
1:         _qualifiedTableName = tableName;
/////////////////////////////////////////////////////////////////////////
1:         _columnName = columnName;
1:         _qualifiedTableName = tableName;
/////////////////////////////////////////////////////////////////////////
1: 			return "columnName: " + _columnName + "\n" +
1: 				"tableName: " + ( ( _qualifiedTableName != null) ?
1: 								  _qualifiedTableName.toString() :
/////////////////////////////////////////////////////////////////////////
1: 				"nestingLevel on "+_columnName+" is not expected to be -1");
1: 				"sourceLevel on "+_columnName+" is not expected to be -1");
/////////////////////////////////////////////////////////////////////////
1:                 new ColumnReference(_columnName, _qualifiedTableName, getContextManager());
/////////////////////////////////////////////////////////////////////////
0: 		_qualifiedTableName = oldCR.getQualifiedTableName();
/////////////////////////////////////////////////////////////////////////
1: 			throw StandardException.newException(SQLState.LANG_ILLEGAL_COLUMN_REFERENCE, _columnName);
/////////////////////////////////////////////////////////////////////////
1: 		if (_qualifiedTableName == null)
1:         {
1: 			return _columnName;
1:         }
1: 		return _qualifiedTableName.toString() + "." + _columnName;
/////////////////////////////////////////////////////////////////////////
1: 		return _columnName;
/////////////////////////////////////////////////////////////////////////
1: 		return ( ( _qualifiedTableName != null) ? _qualifiedTableName.getTableName() : null );
/////////////////////////////////////////////////////////////////////////
1: 	public TableName getQualifiedTableName()
1: 		return _qualifiedTableName;
1:     void setQualifiedTableName(TableName tableName)
1: 		_qualifiedTableName = tableName;
/////////////////////////////////////////////////////////////////////////
1: 			// SanityManager.ASSERT(_origSource == null,
/////////////////////////////////////////////////////////////////////////
1: 		if (scoped && (_origSource != null))
1: 				columnNumber, tableNumber, _columnName, source));
1: 			_origSource = source;
1: 			origName = _columnName;
1: 			_origColumnNumber = columnNumber;
1: 			_origTableNumber = tableNumber;
1: 		_columnName = source.getName();
/////////////////////////////////////////////////////////////////////////
1: 		if (_origSource == null)
1:         {
1:         }
1: 			// SanityManager.ASSERT(_origSource != null,
1: 			source = _origSource;
1: 			_origSource = null;
1: 			_columnName = origName;
1: 			tableNumber = _origTableNumber;
1: 			columnNumber = _origColumnNumber;
/////////////////////////////////////////////////////////////////////////
1: 			_columnName = rI.getColumnName();
/////////////////////////////////////////////////////////////////////////
1: 		return (_origSource != null);
/////////////////////////////////////////////////////////////////////////
1: 					_columnName);
1: 					_columnName);
/////////////////////////////////////////////////////////////////////////
1:                     _columnName);
1:                     ftRC = rcl.getResultColumn(_columnName);
1:                         "Failed to find column '" + _columnName +
/////////////////////////////////////////////////////////////////////////
1: 		return ( ( _qualifiedTableName != null) ? _qualifiedTableName.getSchemaName() : null );
/////////////////////////////////////////////////////////////////////////
1: 				&& _columnName.equals(other.getColumnName()));
/////////////////////////////////////////////////////////////////////////
1:         if (_qualifiedTableName != null) {
0:             _qualifiedTableName = (TableName) _qualifiedTableName.accept(v);
commit:070d37e
/////////////////////////////////////////////////////////////////////////
1:         copyTagsFrom( oldCR );
commit:71c8e86
/////////////////////////////////////////////////////////////////////////
1: 	private java.util.ArrayList<RemapInfo> remaps;
/////////////////////////////////////////////////////////////////////////
1: 				remaps = new java.util.ArrayList<RemapInfo>();
/////////////////////////////////////////////////////////////////////////
1: 			RemapInfo rI = remaps.remove(remaps.size() - 1);
commit:7e5c669
/////////////////////////////////////////////////////////////////////////
1: 		/* We have to make sure we enter this loop if rc is redundant,
1: 		 * so that we can navigate down to the actual source result
1: 		 * set (DERBY-1777). If rc *is* redundant, then rcExpr is not
1: 		 * guaranteed to be a ColumnReference, so we have to check
1: 		 * for that case inside the loop.
1: 		 */
1: 		while ((rcExpr != null) &&
1: 			(rc.isRedundant() || (rcExpr instanceof ColumnReference)))
1: 			if (rcExpr instanceof ColumnReference)
1: 			{
1: 				colNum[0] = ((ColumnReference)rcExpr).getColumnNumber();
1: 				rc = ((ColumnReference)rcExpr).getSource();
1: 			}
commit:df88f63
/////////////////////////////////////////////////////////////////////////
1: 	/* Whether or not this column reference been scoped for the
1: 	   sake of predicate pushdown.
1: 	 */
1: 	private boolean		scoped;
1: 
1: 	/* List of saved remap data if this ColumnReference is scoped
1: 	   and has been remapped multiple times.
1: 	 */
0: 	private java.util.ArrayList remaps;
1: 
/////////////////////////////////////////////////////////////////////////
1: 		remaps = null;
/////////////////////////////////////////////////////////////////////////
1: 		remaps = null;
/////////////////////////////////////////////////////////////////////////
1: 		scoped = oldCR.isScoped();
/////////////////////////////////////////////////////////////////////////
1: 		/* Scoped column references are a special case: they can be
1: 		 * remapped several times (once for every ProjectRestrictNode
1: 		 * through which the scoped ColumnReference is pushed before
1: 		 * reaching its target result set) and will be un-remapped
1: 		 * several times, as well (as the scoped predicate is "pulled"
1: 		 * back up the query tree to it's original location).  So we
1: 		 * have to keep track of the "orig" info for every remap
1: 		 * operation, not just for the most recent one.
1: 		 */
0: 		if (scoped && (origSource != null))
1: 		{
1: 			if (remaps == null)
0: 				remaps = new java.util.ArrayList();
1: 			remaps.add(new RemapInfo(
0: 				columnNumber, tableNumber, columnName, source));
1: 		}
1: 		else
1: 		{
0: 			origSource = source;
0: 			origName = columnName;
0: 			origColumnNumber = columnNumber;
0: 			origTableNumber = tableNumber;
1: 		}
1: 
/////////////////////////////////////////////////////////////////////////
0: 		if ((remaps == null) || (remaps.size() == 0))
1: 		{
0: 			source = origSource;
0: 			origSource = null;
0: 			columnName = origName;
1: 			origName = null;
0: 			tableNumber = origTableNumber;
0: 			columnNumber = origColumnNumber;
1: 		}
1: 		else
1: 		{
1: 			// This CR is multiply-remapped, so undo the most
1: 			// recent (and only the most recent) remap operation.
0: 			RemapInfo rI = (RemapInfo)remaps.remove(remaps.size() - 1);
1: 			source = rI.getSource();
0: 			columnName = rI.getColumnName();
1: 			tableNumber = rI.getTableNumber();
1: 			columnNumber = rI.getColumnNumber();
0: 			rI = null;
0: 			if (remaps.size() == 0)
1: 				remaps = null;
1: 		}
/////////////////////////////////////////////////////////////////////////
1: 	 * Find the source result set for this ColumnReference and
1: 	 * return it.  Also, when the source result set is found,
1: 	 * return the position (within the source result set's RCL)
1: 	 * of the column referenced by this ColumnReference.  The
1: 	 * position is returned vai the colNum parameter.
1: 	 * @param colNum Place to store the position of the column
1: 	 *  to which this ColumnReference points (position is w.r.t
1: 	 *  the source result set).
1: 	 * @return The source result set for this ColumnReference;
1: 	 *  null if there is no source result set.
1: 	protected ResultSetNode getSourceResultSet(int [] colNum)
1: 		throws StandardException
1: 		if (source == null)
1: 		{
1: 			/* this can happen if column reference is pointing to a column
1: 			 * that is not from a base table.  For example, if we have a
1: 			 * VALUES clause like
1: 			 *
1: 			 *    (values (1, 2), (3, 4)) V1 (i, j)
1: 			 *
1: 			 * and then a column reference to VI.i, the column reference
1: 			 * won't have a source.
1: 			 */
1: 			return null;
0: 		ValueNode rcExpr = null;
1: 		ResultColumn rc = getSource();
1: 
1: 		// Walk the ResultColumn->ColumnReference chain until we
1: 		// find a ResultColumn whose expression is a VirtualColumnNode.
1: 
1: 		rcExpr = rc.getExpression();
1: 		colNum[0] = getColumnNumber();
1: 
0: 		while ((rcExpr != null) && (rcExpr instanceof ColumnReference))
1: 		{
1: 			colNum[0] = ((ColumnReference)rcExpr).getColumnNumber();
1: 			rc = ((ColumnReference)rcExpr).getSource();
1: 
1: 			/* If "rc" is redundant then that means it points to another
1: 			 * ResultColumn that in turn points to the source expression.
1: 			 * This can happen in cases where "rc" points to a subquery
1: 			 * that has been flattened into the query above it (flattening
1: 			 * of subqueries occurs during preprocessing).  In that case
1: 			 * we want to skip over the redundant rc and find the
1: 			 * ResultColumn that actually holds the source expression.
1: 			 */
1: 			while (rc.isRedundant())
1: 			{
1: 				rcExpr = rc.getExpression();
1: 				if (rcExpr instanceof VirtualColumnNode)
0: 					rc = ((VirtualColumnNode)rcExpr).getSourceResultColumn();
1: 				else if (rcExpr instanceof ColumnReference)
1: 				{
1: 					colNum[0] = ((ColumnReference)rcExpr).getColumnNumber();
1: 					rc = ((ColumnReference)rcExpr).getSource();
1: 				}
1: 				else
1: 				{
1: 					/* If rc isn't pointing to a VirtualColumnNode nor
1: 					 * to a ColumnReference, then it's not pointing to
1: 					 * a result set.  It could, for example, be pointing
1: 					 * to a constant node or to the result of an aggregate
1: 					 * or function.  Break out of both loops and return
1: 					 * null since there is no source result set.
1: 					 */
0: 					rcExpr = null;
1: 					break;
1: 				}
1: 			}
1: 		// If we found a VirtualColumnNode, return the VirtualColumnNode's
1: 		// sourceResultSet.  The column within that sourceResultSet that
1: 		// is referenced by this ColumnReference is also returned, via
1: 		// the colNum parameter, and was set above.
1: 		if ((rcExpr != null) && (rcExpr instanceof VirtualColumnNode))
1: 			return ((VirtualColumnNode)rcExpr).getSourceResultSet();
1: 		// If we get here then the ColumnReference doesn't reference
1: 		// a result set, so return null.
1: 		colNum[0] = -1;
1: 		return null;
1: 	}
1: 
1: 	/**
1: 	 * Mark this column reference as "scoped", which means that it
1: 	 * was created (as a clone of another ColumnReference) to serve
1: 	 * as the left or right operand of a scoped predicate.
1: 	 */
1: 	protected void markAsScoped()
1: 	{
1: 		scoped = true;
1: 	}
1: 
1: 	/**
1: 	 * Return whether or not this ColumnReference is scoped.
1: 	 */
1: 	protected boolean isScoped()
1: 	{
1: 		return scoped;
1: 	}
1: 
1: 	/**
1: 	 * Helper class to keep track of remap data when a ColumnReference
1: 	 * is remapped multiple times.  This allows the CR to be UN-
1: 	 * remapped multiple times, as well.
1: 	 */
0: 	private class RemapInfo
1: 	{
1: 		int colNum;
1: 		int tableNum;
1: 		String colName;
1: 		ResultColumn source;
1: 
1: 		RemapInfo(int cNum, int tNum, String cName, ResultColumn rc)
1: 		{
1: 			colNum = cNum;
1: 			tableNum = tNum;
1: 			colName = cName;
1: 			source = rc;
1: 		}
1: 
1: 		int getColumnNumber() { return colNum; }
1: 		int getTableNumber() { return tableNum; }
1: 		String getColumnName() { return colName; }
1: 		ResultColumn getSource() { return source; }
1: 
1: 		void setColNumber(int cNum) { colNum = cNum; }
1: 		void setTableNumber(int tNum) { tableNum = tNum; }
1: 		void setColName(String cName) { colName = cName; }
1: 		void setSource(ResultColumn rc) { source = rc; }
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:2706d1f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 BinaryRelationalOperatorNode.K_EQUALS,
1:                 this,
1:                 trueNode,
1:                 false,
1:                 getContextManager());
/////////////////////////////////////////////////////////////////////////
1:     boolean isEquivalent(ValueNode o) throws StandardException
1:         if (! isSameNodeKind(o)) {
1: 
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.context.ContextManager;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
1: import org.apache.derby.iapi.types.DataTypeDescriptor;
1:  * A ColumnReference represents a column in the query tree.  The parser
1:  * generates a ColumnReference for each column reference.  A column reference
1:  * could be a column in a base table, a column in a view (which could expand
1:  * into a complex expression), or a column in a subquery in the FROM clause.
/////////////////////////////////////////////////////////////////////////
1:      * Constructor.
/////////////////////////////////////////////////////////////////////////
1:      * @param cm           The context manager
1:     ColumnReference(String         columnName,
1:                     TableName      tableName,
1:                     int            tokBeginOffset,
1:                     int            tokEndOffset,
1:                     ContextManager cm)  {
1:         super(cm);
0:         setNodeType(C_NodeTypes.COLUMN_REFERENCE);
0:         this.columnName = columnName;
0:         this.tableName = tableName;
1:         this.setBeginOffset(tokBeginOffset);
1:         this.setEndOffset(tokEndOffset);
1:      * Constructor.
1:      * @param cm           The context manager
1:     ColumnReference(String         columnName,
1:                     TableName      tableName,
1:                     ContextManager cm) {
1:         super(cm);
0:         setNodeType(C_NodeTypes.COLUMN_REFERENCE);
0:         this.columnName = columnName;
0:         this.tableName = tableName;
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     void printSubNodes(int depth)
/////////////////////////////////////////////////////////////////////////
1:     void markGeneratedToReplaceAggregate()
/////////////////////////////////////////////////////////////////////////
1:     void markGeneratedToReplaceWindowFunctionCall()
/////////////////////////////////////////////////////////////////////////
1:     boolean getGeneratedToReplaceAggregate()
/////////////////////////////////////////////////////////////////////////
1:     boolean getGeneratedToReplaceWindowFunctionCall()
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     ValueNode getClone()
1:         ColumnReference newCR =
0:                 new ColumnReference(columnName, tableName, getContextManager());
/////////////////////////////////////////////////////////////////////////
1:     void copyFields(ColumnReference oldCR)
/////////////////////////////////////////////////////////////////////////
1:     @Override
0:     ValueNode bindExpression(FromList fromList,
1:                              SubqueryList subqueryList,
1:                              List<AggregateNode> aggregates)
1:             throws StandardException
/////////////////////////////////////////////////////////////////////////
1:     String getSQLColumnName()
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     int getTableNumber()
/////////////////////////////////////////////////////////////////////////
1:     void setTableNumber(int tableNumber)
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     String getTableName()
/////////////////////////////////////////////////////////////////////////
1:     String getSourceTableName()
/////////////////////////////////////////////////////////////////////////
1:     String getSourceSchemaName() throws StandardException
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
0:     void setTableNameNode(TableName tableName)
/////////////////////////////////////////////////////////////////////////
1:     int getColumnNumber()
/////////////////////////////////////////////////////////////////////////
1:     void setColumnNumber(int colNum)
/////////////////////////////////////////////////////////////////////////
1:     ResultColumn getSource()
/////////////////////////////////////////////////////////////////////////
1:     void setSource(ResultColumn source)
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     ValueNode putAndsOnTop()
1:         trueNode = new BooleanConstantNode(true, getContextManager());
1:         equalsNode = new BinaryRelationalOperatorNode(
0:                                         false,
1: 
1:         AndNode andNode =
1:                 new AndNode(equalsNode, trueNode, getContextManager());
1:        andNode.postBindFixup();
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     boolean categorize(JBitSet referencedTabs, boolean simplePredsOnly)
/////////////////////////////////////////////////////////////////////////
1:     void remapColumnReferences()
/////////////////////////////////////////////////////////////////////////
1:     void unRemapColumnReferences()
/////////////////////////////////////////////////////////////////////////
1:         if ((remaps == null) || (remaps.isEmpty()))
/////////////////////////////////////////////////////////////////////////
1:             if (remaps.isEmpty())
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     ResultColumn getSourceResultColumn()
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     ValueNode remapColumnReferencesToExpressions()
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 ResultColumn ftRC = rcl.getResultColumn(
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     boolean isCloneable()
1:     @Override
1:     boolean constantExpression(PredicateList whereClause)
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     String getSchemaName()
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     DataTypeDescriptor getTypeServices()
/////////////////////////////////////////////////////////////////////////
1:         ValueNode rcExpr = rc.getExpression();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private static class RemapInfo
commit:d7f41dd
/////////////////////////////////////////////////////////////////////////
1:         // Use the virtual column id if the ResultColumn's expression
1:         // is a virtual column (DERBY-5933).
1:         columnNumber = source.getExpression() instanceof VirtualColumnNode ?
1:                 source.getVirtualColumnId() : source.getColumnPosition();
commit:ee21e7c
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * The FromTable this column reference is bound to.
1:      */
1:     private int tableNumber;
1: 
1:     /**
1:      * The column number in the underlying FromTable. But note {@code source}.
1:      * @see #source
1:      */
1:     private int columnNumber;
1: 
1:     /**
1:      * This is where the value for this column reference will be coming from.
1:      * Note that for join nodes, {@code tableNumber}/{@code columnNumber} will
1:      * point to the column in the left or right join participant {@code
1:      * FromTable}, whereas {@code source} will be bound to the RC in the result
1:      * column list of the join node. See also the comment at the end of
1:      * JoinNode#getMatchingColumn.
1:      * @see JoinNode#getMatchingColumn
1:      * @see #columnNumber
1:      * @see #tableNumber
1:      */
1:     private ResultColumn source;
/////////////////////////////////////////////////////////////////////////
commit:4ce669e
/////////////////////////////////////////////////////////////////////////
1:                     columnNumberBeforeFlattening,
0:                     columnName);
commit:125f918
/////////////////////////////////////////////////////////////////////////
1:     /* For remembering original (tn,cn) of this CR during join flattening. */
1:     private int tableNumberBeforeFlattening = -1;
1:     private int columnNumberBeforeFlattening = -1;
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                  * See DERBY-3023 and DERBY-4679 for further improvement
1:                  * details.
1:                 ResultColumnList rcl = ft.getResultColumns();
1: 
0:                 ResultColumn ftRC = null;
1: 
1: 
1:                 // Need to save original (tn,cn) in case we have several
1:                 // flattenings so we can relocate the correct column many
1:                 // times. After the first flattening, the (tn,cn) pair points
1:                 // to the top RCL which is going away..
1:                 if (tableNumberBeforeFlattening == -1) {
1:                     tableNumberBeforeFlattening = tableNumber;
1:                     columnNumberBeforeFlattening = columnNumber;
1:                 }
1: 
1:                 // Covers references to a table not being flattened out, e.g.
1:                 // inside a join tree, which can have many columns in the rcl
1:                 // with the same name, so looking up via column name can give
1:                 // the wrong column. DERBY-4679.
0:                 ftRC = rcl.getResultColumn(
1:                     tableNumberBeforeFlattening,
0:                     columnNumberBeforeFlattening);
1: 
1:                 if (ftRC == null) {
1:                     // The above lookup won't work for references to a base
1:                     // column, so fall back on column name, which is unique
1:                     // then.
0:                     ftRC = rcl.getResultColumn(columnName);
1:                 }
1: 
1:                 if (SanityManager.DEBUG) {
1:                     SanityManager.ASSERT(
1:                         ftRC != null,
0:                         "Failed to find column '" + columnName +
1:                         "' in the " + "RCL for '" + ft.getTableName() +
1:                         "'.");
1:                 }
1: 
1:                 tableNumber = ft.getTableNumber();
1: 
1: 				if (SanityManager.DEBUG) {
1: 					SanityManager.ASSERT(tableNumber != -1,
1: 						"tableNumber not expected to be -1");
commit:7a9ce7e
/////////////////////////////////////////////////////////////////////////
1: 	private boolean		replacesWindowFunctionCall;
/////////////////////////////////////////////////////////////////////////
1: 				"replacesWindowFunctionCall: " +
1: 				    replacesWindowFunctionCall + "\n" +
0: 				"tableName: " + ( ( tableName != null) ?
0: 								  tableName.toString() :
1: 								  "null") + "\n" +
/////////////////////////////////////////////////////////////////////////
1: 
1: 	/**
1: 	 * Mark this node as being generated to replace a window function call.
1: 	 */
0: 	public void markGeneratedToReplaceWindowFunctionCall()
1: 	{
1: 		replacesWindowFunctionCall = true;
1: 	}
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 	/**
1: 	 * Determine whether or not this node was generated to
1: 	 * replace a window function call in the user's SELECT.
1: 	 *
1: 	 * @return boolean	Whether or not this node was generated to replace
1: 	 *					a window function call in the user's SELECT.
1: 	 */
0: 	public boolean getGeneratedToReplaceWindowFunctionCall()
1: 	{
1: 		return replacesWindowFunctionCall;
1: 	}
1: 
/////////////////////////////////////////////////////////////////////////
1: 		replacesWindowFunctionCall =
1: 			oldCR.getGeneratedToReplaceWindowFunctionCall();
/////////////////////////////////////////////////////////////////////////
1: 	 * This also goes for column references that replaces a window function.
1: 	 *
/////////////////////////////////////////////////////////////////////////
1: 			   ( ! replacesWindowFunctionCall ) &&
commit:3527fd5
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:8c15184
/////////////////////////////////////////////////////////////////////////
0: 										Boolean.FALSE,
author:Army
-------------------------------------------------------------------------------
commit:411d1b7
/////////////////////////////////////////////////////////////////////////
commit:c723732
/////////////////////////////////////////////////////////////////////////
0: 			   ( ! source.isWindowFunction() ) && 
/////////////////////////////////////////////////////////////////////////
0: 	 * Return whether or not the source of this ColumnReference is a window 
0: 	 * function.
1: 	 * 
0: 	 * Note that we only care about the immediate source here.
0: 	 * This enables a push into a subquery that again has a windowfunction 
0: 	 * column in its subquery RCL.
1: 	 *
0: 	 * @return Whether or not the source of this ColumnReference 
0: 	 *         is a window function.
1: 	 */
0: 	boolean pointsToWindowFunction()
1: 	{ 
0: 		return (source.isWindowFunction());
1: 	}
1: 	
1: 	/**
commit:2d2911e
/////////////////////////////////////////////////////////////////////////
1: 				/* Use the virtual column id if the ResultColumn's expression
1: 				 * is a virtual column (DERBY-3023).
1: 				 */
1: 				columnNumber =
1: 					(ftRC.getExpression() instanceof VirtualColumnNode)
1: 						? ftRC.getVirtualColumnId()
1: 						: ftRC.getColumnPosition();
commit:a3da76e
/////////////////////////////////////////////////////////////////////////
1: 				FromTable ft = (FromTable)rsn;
0: 				tableNumber = ft.getTableNumber();
1: 
1: 				/* It's not enough to just set the table number.  Depending
1: 				 * on the original query specified and on whether or not
1: 				 * subquery flattening has occurred, it's possible that
1: 				 * the expression to which we're remapping has a different
1: 				 * RCL ordering than the one to which we were mapped before
1: 				 * we got here.  In that case we also need to update the
1: 				 * columnNumber to point to the correct column in "ft".
1: 				 * See DERBY-2526 for details.
1: 				 */
0: 				ResultColumn ftRC =
0: 					ft.getResultColumns().getResultColumn(columnName);
1: 
1: 				if (SanityManager.DEBUG)
1: 				{
0: 					SanityManager.ASSERT(ftRC != null,
0: 						"Failed to find column '" + columnName + "' in the " +
0: 						"RCL for '" + ft.getTableName() + "'.");
1: 				}
1: 
0: 				columnNumber = ftRC.getColumnPosition();
commit:d5ef906
/////////////////////////////////////////////////////////////////////////
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:ed82406
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	 * The type of a ColumnReference is the type of its
1:      * source unless the source is null then it is
1:      * the type that has been set on this node.
0: 	public DataTypeDescriptor getTypeServices()
1: 	{        
1:         if (source == null)
1:             return super.getTypeServices();
1:        
1:         return source.getTypeServices();
1:     }
commit:e9ec322
/////////////////////////////////////////////////////////////////////////
1: 	private int getNestingLevel()
/////////////////////////////////////////////////////////////////////////
1:         /* RESOLVE - If expression is a ColumnReference, then we are hitting
1:          * the top of a query block (derived table or view.)
1:          * In order to be able to push the expression down into the next
1:          * query block, it looks like we should reset the contents of the
1:          * current ColumnReference to be the same as expression.  (This probably
1:          * only means names and tableNumber.)  We would then "rebind" the top
1:          * level predicate somewhere up the call stack and see if we could push
1:          * the predicate through.
1:          */
1:         
1:         return source.getExpression().getSourceResultColumn();
/////////////////////////////////////////////////////////////////////////
1:             ResultColumn nextRC = rc.getExpression().getSourceResultColumn();
/////////////////////////////////////////////////////////////////////////
1: 			source = sourceRC.getExpression().getSourceResultColumn();
/////////////////////////////////////////////////////////////////////////
1: 					rc = rcExpr.getSourceResultColumn();
commit:01217c2
/////////////////////////////////////////////////////////////////////////
1: 	
0: 	protected boolean isEquivalent(ValueNode o) throws StandardException
1: 	{
0: 		if (!isSameNodeType(o)) {
1: 			return false;
1: 		}
1: 		ColumnReference other = (ColumnReference)o;
1: 		return (tableNumber == other.tableNumber 
0: 				&& columnName.equals(other.getColumnName()));
1: 	}
commit:5b2f5de
/////////////////////////////////////////////////////////////////////////
0: 	String	columnName;
0: 	TableName	tableName;
0: 	private int			tableNumber;	
0: 	private int			columnNumber;	
0: 	private ResultColumn	source;
1: 	private String	origName;
commit:7f1493a
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 		this.setBeginOffset(((Integer) tokBeginOffset).intValue());
0: 		this.setEndOffset(((Integer) tokEndOffset).intValue());
/////////////////////////////////////////////////////////////////////////
commit:b57ee34
/////////////////////////////////////////////////////////////////////////
1: 	 * The method will return B for this example, select b.a from t as b
1: 	 * The method will return T for this example, select t.a from t
/////////////////////////////////////////////////////////////////////////
1: 	 * Get the name of the underlying(base) table this column comes from, if any.
1: 	 * Following example queries will all return T
1: 	 * select a from t
1: 	 * select b.a from t as b
1: 	 * select t.a from t
1: 	 * @return	The name of the base table that this column comes from.
1: 		return ((source != null) ? source.getTableName() : null);
1: 	}
1: 
1: 	/**
1: 	 * Get the name of the schema for the Column's base table, if any.
1: 	 * Following example queries will all return APP (assuming user is in schema APP)
1: 	 * select t.a from t
1: 	 * select b.a from t as b
1: 	 * select app.t.a from t
1: 	 *
1: 	 * @return	The name of the schema for Column's base table. If the column
1: 	 *		is not in a schema (i.e. is a derived column), it returns NULL.
1: 	 */
0: 	public String getSourceSchemaName() throws StandardException
1: 	{
1: 		return ((source != null) ? source.getSchemaName() : null);
1: 	}
1: 
1: 	/**
1: 	 * Is the column wirtable by the cursor or not. (ie, is it in the list of FOR UPDATE columns list)
1: 	 *
1: 	 * @return TRUE, if the column is a base column of a table and is 
1: 	 * writable by cursor.
1: 	 */
1: 	public boolean updatableByCursor()
1: 	{
1: 		return ((source != null) ? source.updatableByCursor() : false);
/////////////////////////////////////////////////////////////////////////
1: 	 * Another example for null return value (for example, select b.a from t as b).
1: 	 * But for following query select app.t.a from t, this will return APP
1: 	 * Code generation of aggregate functions relies on this method
commit:f1d4e9d
/////////////////////////////////////////////////////////////////////////
1: 			throw StandardException.newException(SQLState.LANG_COLUMN_NOT_FOUND, getSQLColumnName());
/////////////////////////////////////////////////////////////////////////
1: 	 * Get the column name for purposes of error
1: 	 * messages or debugging. This returns the column
1: 	 * name as used in the SQL statement. Thus if it was qualified
1: 	 * with a table, alias name that will be included.
1: 	 * @return	The  column name in the form [[schema.]table.]column
0: 	public String getSQLColumnName()
0: 		if (tableName == null)
0: 			return columnName;
1: 		
0: 		return tableName.toString() + "." + columnName;
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.compile.ColumnReference
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:61070a6
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package	org.apache.derby.impl.sql.compile;
1: 
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
0: import org.apache.derby.iapi.sql.compile.NodeFactory;
1: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.reference.SQLState;
1: 
0: import org.apache.derby.impl.sql.compile.ExpressionClassBuilder;
1: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: import org.apache.derby.iapi.store.access.Qualifier;
1: 
1: import org.apache.derby.iapi.util.JBitSet;
1: 
0: import java.util.Vector;
1: 
1: /**
0:  * A ColumnReference represents a column in the query tree.  The parser generates a
0:  * ColumnReference for each column reference.  A column refercence could be a column in
0:  * a base table, a column in a view (which could expand into a complex
0:  * expression), or a column in a subquery in the FROM clause.
1:  *
0:  * @author Jerry Brenner
1:  */
1: 
1: public class ColumnReference extends ValueNode
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	public String	columnName;
1: 
1: 	/*
1: 	** This is the user-specified table name.  It will be null if the
1: 	** user specifies a column without a table name.  Leave it null even
1: 	** when the column is bound as it is only used in binding.
1: 	*/
0: 	public TableName	tableName;
0: 	/* The table this column reference is bound to */
0: 	public int			tableNumber;	
0: 	/* The column number in the underlying base table */
0: 	public int			columnNumber;	
0: 	/* This is where the value for this column reference will be coming from */
0: 	public ResultColumn	source;
1: 
1: 	/* For unRemapping */
0: 	ResultColumn	origSource;
0: 	public String	origName;
0: 	int				origTableNumber = -1;
0: 	int				origColumnNumber = -1;
1: 
1: 	/* Reuse generated code where possible */
1: 	//Expression genResult;
1: 
1: 	private boolean		replacesAggregate;
1: 
1: 	private int			nestingLevel = -1;
1: 	private int			sourceLevel = -1;
1: 
1: 	/*
0: 	** These fields are used to track the being and end
0: 	** offset of the token from which the column name came.
1: 	*/
0: 	private int		tokBeginOffset = -1;
0: 	private int		tokEndOffset = -1;
1: 
1: 	/**
0: 	 * Initializer.
1: 	 * This one is called by the parser where we could
1: 	 * be dealing with delimited identifiers.
1: 	 *
1: 	 * @param columnName	The name of the column being referenced
1: 	 * @param tableName		The qualification for the column
1: 	 * @param tokBeginOffset begin position of token for the column name 
1: 	 *					identifier from parser.
1: 	 * @param tokEndOffset	end position of token for the column name 
1: 	 *					identifier from parser.
1: 	 */
1: 
0: 	public void init(Object columnName, 
0: 					 Object tableName,
0: 			 		 Object	tokBeginOffset,
0: 					 Object	tokEndOffset
1: 					 )
1: 	{
0: 		this.columnName = (String) columnName;
0: 		this.tableName = (TableName) tableName;
0: 		this.tokBeginOffset = ((Integer) tokBeginOffset).intValue();
0: 		this.tokEndOffset = ((Integer) tokEndOffset).intValue();
1: 		tableNumber = -1;
1: 	}
1: 
1: 	/**
0: 	 * Initializer.
1: 	 *
1: 	 * @param columnName	The name of the column being referenced
1: 	 * @param tableName		The qualification for the column
1: 	 */
1: 
0: 	public void init(Object columnName, Object tableName)
1: 	{
0: 		this.columnName = (String) columnName;
0: 		this.tableName = (TableName) tableName;
1: 		tableNumber = -1;
1: 	}
1: 
1: 	/**
1: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
1: 	 * for how this should be done for tree printing.
1: 	 *
1: 	 * @return	This object as a String
1: 	 */
1: 
1: 	public String toString()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			return "columnName: " + columnName + "\n" +
1: 				"tableNumber: " + tableNumber + "\n" +
1: 				"columnNumber: " + columnNumber + "\n" +
1: 				"replacesAggregate: " + replacesAggregate + "\n" +
0: 				( ( tableName != null) ?
0: 						tableName.toString() :
0: 						"tableName: null\n") +
1: 				"nestingLevel: " + nestingLevel + "\n" +
1: 				"sourceLevel: " + sourceLevel + "\n" +
1: 				super.toString();
1: 		}
1: 		else
1: 		{
1: 			return "";
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
1: 	 * how tree printing is supposed to work.
1: 	 *
1: 	 * @param depth		The depth of this node in the tree
1: 	 *
0: 	 * @return	Nothing
1: 	 */
1: 
0: 	public void printSubNodes(int depth)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			super.printSubNodes(depth);
1: 
1: 			if (source != null)
1: 			{
1: 				printLabel(depth, "source: ");
1: 				source.treePrint(depth + 1);
1: 			}
1: 		}
1: 	}
1: 
1: 	/**
0: 	 * Get the begin offset of the parser token for the column name
0: 	 * Will only be set when the CR was generated by the
0: 	 * parser.
1: 	 *
0: 	 * @return the begin offset of the token.  -1 means unknown
1: 	 */
0: 	public int getTokenBeginOffset()
1: 	{
0: 		/* We should never get called if not initialized, as
0: 		 * begin/end offset has no meaning unless this CR was
0: 		 * created in the parser.
1: 		 */
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			if (tokBeginOffset == -1)
1: 			{
1: 				SanityManager.THROWASSERT(
0: 					"tokBeginOffset not expected to be -1");
1: 			}
1: 		}
0: 		return tokBeginOffset;
1: 	}
1: 
1: 	/**
0: 	 * Get the end offset of the parser token for the column name.
0: 	 * Will only be set when the CR was generated by the
0: 	 * parser.
1: 	 *
0: 	 * @return the end offset of the token.  -1 means unknown
1: 	 */
0: 	public int getTokenEndOffset()
1: 	{
0: 		/* We should never get called if not initialized, as
0: 		 * begin/end offset has no meaning unless this CR was
0: 		 * created in the parser.
1: 		 */
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			if (tokEndOffset == -1)
1: 			{
1: 				SanityManager.THROWASSERT(
0: 					"tokEndOffset not expected to be -1");
1: 			}
1: 		}
0: 		return tokEndOffset;
1: 	}
1: 
1: 	/**
1: 	 * Return whether or not this CR is correlated.
1: 	 *
1: 	 * @return Whether or not this CR is correlated.
1: 	 */
1: 	boolean getCorrelated()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(nestingLevel != -1,
0: 				"nestingLevel on "+columnName+" is not expected to be -1");
1: 			SanityManager.ASSERT(sourceLevel != -1,
0: 				"sourceLevel on "+columnName+" is not expected to be -1");
1: 		}
1: 		return sourceLevel != nestingLevel;
1: 	}
1: 
1: 	/**
1: 	 * Set the nesting level for this CR.  (The nesting level
1: 	 * at which the CR appears.)
1: 	 *
1: 	 * @param nestingLevel	The Nesting level at which the CR appears.
1: 	 *
0: 	 * @return Nothing.
1: 	 */
1: 	void setNestingLevel(int nestingLevel)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(nestingLevel != -1,
1: 				"nestingLevel is not expected to be -1");
1: 		}
1: 		this.nestingLevel = nestingLevel;
1: 	}
1: 
1: 	/**
1: 	 * Get the nesting level for this CR.
1: 	 *
1: 	 * @return	The nesting level for this CR.
1: 	 */
0: 	int getNestingLevel()
1: 	{
1: 		return nestingLevel;
1: 	}
1: 
1: 	/**
1: 	 * Set the source level for this CR.  (The nesting level
1: 	 * of the source of the CR.)
1: 	 *
1: 	 * @param sourceLevel	The Nesting level of the source of the CR.
1: 	 *
0: 	 * @return Nothing.
1: 	 */
1: 	void setSourceLevel(int sourceLevel)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(sourceLevel != -1,
1: 				"sourceLevel is not expected to be -1");
1: 		}
1: 		this.sourceLevel = sourceLevel;
1: 	}
1: 
1: 	/**
1: 	 * Get the source level for this CR.
1: 	 *
1: 	 * @return	The source level for this CR.
1: 	 */
1: 	int getSourceLevel()
1: 	{
1: 		return sourceLevel;
1: 	}
1: 
1: 	/**
1: 	 * Mark this node as being generated to replace an aggregate.
1: 	 * (Useful for replacing aggregates in the HAVING clause with 
1: 	 * column references to the matching aggregate in the 
1: 	 * user's SELECT.
1: 	 *
0: 	 * @return Nothing.
1: 	 */
0: 	public void markGeneratedToReplaceAggregate()
1: 	{
1: 		replacesAggregate = true;
1: 	}
1: 
1: 	/**
1: 	 * Determine whether or not this node was generated to
1: 	 * replace an aggregate in the user's SELECT.
1: 	 *
1: 	 * @return boolean	Whether or not this node was generated to replace
1: 	 *					an aggregate in the user's SELECT.
1: 	 */
0: 	public boolean getGeneratedToReplaceAggregate()
1: 	{
1: 		return replacesAggregate;
1: 	}
1: 
1: 	/**
1: 	 * Return a clone of this node.
1: 	 *
1: 	 * @return ValueNode	A clone of this node.
1: 	 *
1: 	 * @exception StandardException			Thrown on error
1: 	 */
0: 	public ValueNode getClone()
1: 		throws StandardException
1: 	{
0: 		ColumnReference newCR = (ColumnReference) getNodeFactory().getNode(
0: 									C_NodeTypes.COLUMN_REFERENCE,
0: 									columnName,
0: 									tableName,
0: 									getContextManager());
1: 
1: 		newCR.copyFields(this);
1: 		return newCR;
1: 	}
1: 
1: 	/**
1: 	 * Copy all of the "appropriate fields" for a shallow copy.
1: 	 *
1: 	 * @param oldCR		The ColumnReference to copy from.
1: 	 *
1: 	 * @exception StandardException			Thrown on error
1: 	 */
0: 	public void copyFields(ColumnReference oldCR)
1: 		throws StandardException
1: 	{
1: 		super.copyFields(oldCR);
1: 
0: 		tableName = oldCR.getTableNameNode();
1: 		tableNumber = oldCR.getTableNumber();
1: 		columnNumber = oldCR.getColumnNumber();
1: 		source = oldCR.getSource();
1: 		nestingLevel = oldCR.getNestingLevel();
1: 		sourceLevel = oldCR.getSourceLevel();
1: 		replacesAggregate = oldCR.getGeneratedToReplaceAggregate();
1: 	}
1: 
1: 	/**
1: 	 * Bind this expression.  This means binding the sub-expressions,
1: 	 * as well as figuring out what the return type is for this expression.
1: 	 *
1: 	 * NOTE: We must explicitly check for a null FromList here, column reference
1: 	 * without a FROM list, as the grammar allows the following:
1: 	 *			insert into t1 values(c1)
1: 	 *
1: 	 * @param fromList		The FROM list for the query this
1: 	 *				expression is in, for binding columns.
1: 	 * @param subqueryList		The subquery list being built as we find SubqueryNodes
0: 	 * @param aggregateVector	The aggregate vector being built as we find AggregateNodes
1: 	 *
1: 	 * @return	The new top of the expression tree.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public ValueNode bindExpression(FromList fromList, SubqueryList subqueryList,
0: 			Vector aggregateVector) 
1: 				throws StandardException
1: 	{
1: 
1: 		ResultColumn matchingRC;
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(fromList != null, "fromList is expected to be non-null");
1: 		}
1: 
1: 		if (fromList.size() == 0)
1: 		{
0: 			throw StandardException.newException(SQLState.LANG_ILLEGAL_COLUMN_REFERENCE, columnName);
1: 		}
1: 
0: 		matchingRC = fromList.bindColumnReference(this);
1: 
1: 		/* Error if no match found in fromList */
1: 		if (matchingRC == null)
1: 		{
0: 			throw StandardException.newException(SQLState.LANG_COLUMN_NOT_FOUND, getFullColumnName());
1: 		}
1: 
0: 		/* Set the columnNumber from the base table.
0:  		 * Useful for optimizer and generation.
1: 		 */
0: 		columnNumber = matchingRC.getColumnPosition();
1: 
1: 		return this;
1: 	}
1: 
1: 	/**
0: 	 * Get the full column name of this column for purposes of error
0: 	 * messages or debugging.  The full column name includes the table
0: 	 * name and schema name, if any.
1: 	 *
0: 	 * @return	The full column name in the form schema.table.column
1: 	 */
1: 
0: 	public String getFullColumnName()
1: 	{
0: 		String	fullColumnName = "";
1: 
0: 		if (tableName != null)
0: 			fullColumnName += tableName.getFullTableName() + ".";
0: 		fullColumnName += columnName;
1: 
0: 		return fullColumnName;
1: 	}
1: 
1: 	/**
1: 	 * Get the name of this column
1: 	 *
1: 	 * @return	The name of this column
1: 	 */
1: 
1: 	public String getColumnName()
1: 	{
0: 		return columnName;
1: 	}
1: 
1: 	/**
0: 	 * Set the name of this column
1: 	 *
0: 	 * @param columName	The name of this column
1: 	 *
0: 	 * @return None.
1: 	 */
1: 
0: 	public void setColumnName(String columnName)
1: 	{
0: 		this.columnName = columnName;
1: 	}
1: 
1: 	/**
1: 	 * Get the table number for this ColumnReference.
1: 	 *
1: 	 * @return	int The table number for this ColumnReference
1: 	 */
1: 
0: 	public int getTableNumber()
1: 	{
1: 		return tableNumber;
1: 	}
1: 
1: 	/**
1: 	 * Set this ColumnReference to refer to the given table number.
1: 	 *
0: 	 * @param table	The table number this ColumnReference will refer to
1: 	 *
0: 	 * @return	Nothing
1: 	 */
1: 
0: 	public void setTableNumber(int tableNumber)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(tableNumber != -1,
1: 				"tableNumber not expected to be -1");
1: 		}
1: 		this.tableNumber = tableNumber;
1: 	}
1: 
1: 	/**
1: 	 * Get the user-supplied table name of this column.  This will be null
1: 	 * if the user did not supply a name (for example, select a from t).
1: 	 *
1: 	 * @return	The user-supplied name of this column.  Null if no user-
1: 	 * 		supplied name.
1: 	 */
1: 
0: 	public String getTableName()
1: 	{
0: 		return ( ( tableName != null) ? tableName.getTableName() : null );
1: 	}
1: 
1: 	/**
0: 	 * Get the name of the table this column comes from.
1: 	 *
0: 	 * @return	The name of the table that this column comes from.  
1: 	 *			Null if not a ColumnReference.
1: 	 */
1: 
0: 	public String getSourceTableName()
1: 	{
0: 		return ( ( tableName != null) ? tableName.getTableName() : 
0: 					((source != null) ? source.getTableName() : null));
1: 	}
1: 
1: 	/**
1: 	  Return the table name as the node it is.
1: 	  @return the column's table name.
1: 	 */
0: 	public TableName getTableNameNode()
1: 	{
0: 		return tableName;
1: 	}
1: 
0: 	public void setTableNameNode(TableName tableName)
1: 	{
0: 		this.tableName = tableName;
1: 	}
1: 
1: 	/**
1: 	 * Get the column number for this ColumnReference.
1: 	 *
1: 	 * @return	int The column number for this ColumnReference
1: 	 */
1: 
0: 	public int getColumnNumber()
1: 	{
1: 		return columnNumber;
1: 	}
1: 
1: 	/**
1: 	 * Get the source this columnReference
1: 	 *
1: 	 * @return	The source of this columnReference
1: 	 */
1: 
0: 	public ResultColumn getSource()
1: 	{
1: 		return source;
1: 	}
1: 
1: 	/**
1: 	 * Set the source this columnReference
1: 	 *
1: 	 * @param source	The source of this columnReference
1: 	 *
0: 	 * @return None.
1: 	 */
1: 
0: 	public void setSource(ResultColumn source)
1: 	{
1: 		this.source = source;
1: 	}
1: 
1: 	/**
1: 	 * Do the 1st step in putting an expression into conjunctive normal
1: 	 * form.  This step ensures that the top level of the expression is
1: 	 * a chain of AndNodes.
1: 	 *
1: 	 * @return		The modified expression
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public ValueNode putAndsOnTop() 
1: 					throws StandardException
1: 	{
1: 		BinaryComparisonOperatorNode		equalsNode;
1: 		BooleanConstantNode	trueNode;
0: 		NodeFactory		nodeFactory = getNodeFactory();
0: 		ValueNode		andNode;
1: 
0:         trueNode = (BooleanConstantNode) nodeFactory.getNode(
0: 										C_NodeTypes.BOOLEAN_CONSTANT_NODE,
0: 										Boolean.TRUE,
0: 										getContextManager());
0: 		equalsNode = (BinaryComparisonOperatorNode) 
0: 						nodeFactory.getNode(
0: 										C_NodeTypes.BINARY_EQUALS_OPERATOR_NODE,
0: 										this,
0: 										trueNode,
0: 										getContextManager());
1: 		/* Set type info for the operator node */
1: 		equalsNode.bindComparisonOperator();
0: 		andNode = (ValueNode) nodeFactory.getNode(
0: 									C_NodeTypes.AND_NODE,
0: 									equalsNode,
0: 									trueNode,
0: 									getContextManager());
0: 		((AndNode) andNode).postBindFixup();
1: 		return andNode;
1: 	}
1: 
1: 	/**
1: 	 * Categorize this predicate.  Initially, this means
1: 	 * building a bit map of the referenced tables for each predicate.
1: 	 * If the source of this ColumnReference (at the next underlying level) 
1: 	 * is not a ColumnReference or a VirtualColumnNode then this predicate
1: 	 * will not be pushed down.
1: 	 *
1: 	 * For example, in:
1: 	 *		select * from (select 1 from s) a (x) where x = 1
1: 	 * we will not push down x = 1.
1: 	 * NOTE: It would be easy to handle the case of a constant, but if the
1: 	 * inner SELECT returns an arbitrary expression, then we would have to copy
1: 	 * that tree into the pushed predicate, and that tree could contain
1: 	 * subqueries and method calls.
1: 	 *
1: 	 * Also, don't allow a predicate to be pushed down if it contains a
1: 	 * ColumnReference that replaces an aggregate.  This can happen if
1: 	 * the aggregate is in the HAVING clause.  In this case, we would be
1: 	 * pushing the predicate into the SelectNode that evaluates the aggregate,
1: 	 * which doesn't make sense, since the having clause is supposed to be
1: 	 * applied to the result of the SelectNode.
1: 	 *
1: 	 * RESOLVE - revisit this issue once we have views.
1: 	 *
1: 	 * @param referencedTabs	JBitSet with bit map of referenced FromTables
1: 	 * @param simplePredsOnly	Whether or not to consider method
1: 	 *							calls, field references and conditional nodes
1: 	 *							when building bit map
1: 	 *
1: 	 * @return boolean		Whether or not source.expression is a ColumnReference
1: 	 *						or a VirtualColumnNode or a ConstantNode.
1: 	 */
0: 	public boolean categorize(JBitSet referencedTabs, boolean simplePredsOnly)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		SanityManager.ASSERT(tableNumber >= 0,
1: 							 "tableNumber is expected to be non-negative");
1: 		referencedTabs.set(tableNumber);
1: 
1: 		return ( ! replacesAggregate ) &&
1: 			   ( (source.getExpression() instanceof ColumnReference) ||
1: 			     (source.getExpression() instanceof VirtualColumnNode) ||
1: 				 (source.getExpression() instanceof ConstantNode));
1: 	}
1: 
1: 	/**
1: 	 * Remap all of the ColumnReferences in this expression tree
1: 	 * to point to the ResultColumn that is 1 level under their
1: 	 * current source ResultColumn.
1: 	 * This is useful for pushing down single table predicates.
1: 	 *
1: 	 * RESOLVE: Once we start pushing join clauses, we will need to walk the
1: 	 * ResultColumn/VirtualColumnNode chain for them to remap the references.
1: 	 *
0: 	 * @return None.
1: 	 */
0: 	public void remapColumnReferences()
1: 	{
1: 		ValueNode expression = source.getExpression();
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			// SanityManager.ASSERT(origSource == null,
1: 			// 		"Trying to remap ColumnReference twice without unremapping it.");
1: 		}
1: 
1: 		if ( ! ( (expression instanceof VirtualColumnNode) ||
1: 				 (expression instanceof ColumnReference) )
1: 			)
1: 		{
1: 			return;
1: 		}
1: 
1: 		/* Find the matching ResultColumn */
0: 		origSource = source;
1: 		source = getSourceResultColumn();
0: 		origName = columnName;
0: 		columnName = source.getName();
0: 		origColumnNumber = columnNumber;
0: 		columnNumber = source.getColumnPosition();
1: 
0: 		origTableNumber = tableNumber;
1: 		if (source.getExpression() instanceof ColumnReference)
1: 		{
1: 			ColumnReference cr = (ColumnReference) source.getExpression();
1: 			tableNumber = cr.getTableNumber();
1: 			if (SanityManager.DEBUG)
1: 			{
1: 				// if dummy cr generated to replace aggregate, it may not have table number
1: 				// because underneath can be more than 1 table.
1: 				if (tableNumber == -1 && ! cr.getGeneratedToReplaceAggregate())
1: 				{
1: 					SanityManager.THROWASSERT(
1: 						"tableNumber not expected to be -1, origName = " + origName);
1: 				}
1: 			}
1: 		}
1: 	}
1: 
0: 	public void unRemapColumnReferences()
1: 	{
0: 		if (origSource == null)
1: 			return;
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			// SanityManager.ASSERT(origSource != null,
1: 			// 	"Trying to unremap a ColumnReference that was not remapped.");
1: 		}
1: 
0: 		source = origSource;
0: 		origSource = null;
0: 		columnName = origName;
0: 		origName = null;
0: 		tableNumber = origTableNumber;
0: 		columnNumber = origColumnNumber;
1: 	}
1: 
1: 	/*
1: 	 * Get the ResultColumn that the source points to.  This is useful for
1: 	 * getting what the source will be after this ColumnReference is remapped.
1: 	 */
0: 	public ResultColumn getSourceResultColumn()
1: 	{
1: 		ValueNode expression = source.getExpression();
1: 
1: 		/* Find the matching ResultColumn */
0: 		if (expression instanceof VirtualColumnNode) 
1: 		{
0: 			return ((VirtualColumnNode) expression).getSourceResultColumn();
1: 		}
1: 		else
1: 		{
0: 			/* RESOLVE - If expression is a ColumnReference, then we are hitting
0: 			 * the top of a query block (derived table or view.)
0: 			 * In order to be able to push the expression down into the next
0: 			 * query block, it looks like we should reset the contents of the
0: 			 * current ColumnReference to be the same as expression.  (This probably
0: 			 * only means names and tableNumber.)  We would then "rebind" the top
0: 			 * level predicate somewhere up the call stack and see if we could push
0: 			 * the predicate through.
1: 			 */
0: 			return ((ColumnReference) expression).getSourceResultColumn();
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Remap all ColumnReferences in this tree to be clones of the
1: 	 * underlying expression.
1: 	 *
1: 	 * @return ValueNode			The remapped expression tree.
1: 	 *
1: 	 * @exception StandardException			Thrown on error
1: 	 */
0: 	public ValueNode remapColumnReferencesToExpressions()
1: 		throws StandardException
1: 	{
1: 		ResultColumn	rc;
1: 		ResultColumn	sourceRC = source;
1: 
1: 		/* Nothing to do if we are not pointing to a redundant RC */
1: 		if (! source.isRedundant())
1: 		{
1: 			return this;
1: 		}
1: 
1: 		/* Find the last redundant RC in the chain.  We
1: 		 * want to clone its expression.
1: 		 */
1: 		for (rc = source; rc != null && rc.isRedundant(); )
1: 		{
0: 			ResultColumn	nextRC = null;
0: 			ValueNode		expression = rc.getExpression();
1: 
1: 			/* Find the matching ResultColumn */
0: 			if (expression instanceof VirtualColumnNode) 
1: 			{
0: 				nextRC = ((VirtualColumnNode) expression).getSourceResultColumn();
1: 			}
0: 			else if (expression instanceof ColumnReference)
1: 			{
0: 				nextRC = ((ColumnReference) expression).getSourceResultColumn();
1: 			}
1: 			else
1: 			{
0: 				nextRC = null;
1: 			}
1: 
1: 			if (nextRC != null && nextRC.isRedundant())
1: 			{
1: 				sourceRC = nextRC;
1: 			}
1: 			rc = nextRC;
1: 		}
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			if (sourceRC == null)
1: 			{
1: 				SanityManager.THROWASSERT(
1: 					"sourceRC is expected to be non-null for " +
0: 					columnName);
1: 			}
1: 
1: 			if ( ! sourceRC.isRedundant())
1: 			{
1: 				SanityManager.THROWASSERT(
1: 					"sourceRC is expected to be redundant for " +
0: 					columnName);
1: 			}
1: 		}
1: 
1: 		/* If last expression is a VCN, then we can't clone it.
1: 		 * Instead, we just reset our source to point to the
1: 		 * source of the VCN, those chopping out the layers.
1: 		 * Otherwise, we return a clone of the underlying expression.
1: 		 */
1: 		if (sourceRC.getExpression() instanceof VirtualColumnNode)
1: 		{
1: 			VirtualColumnNode vcn =
1: 				(VirtualColumnNode) (sourceRC.getExpression());
1: 			ResultSetNode rsn = vcn.getSourceResultSet();
1: 			if (rsn instanceof FromTable)
1: 			{
0: 				tableNumber = ((FromTable) rsn).getTableNumber();
1: 				if (SanityManager.DEBUG)
1: 				{
1: 					SanityManager.ASSERT(tableNumber != -1,
1: 						"tableNumber not expected to be -1");
1: 				}
1: 			}
1: 			else
1: 			{
1: 				if (SanityManager.DEBUG)
1: 				{
1: 					SanityManager.THROWASSERT("rsn expected to be a FromTable, but is a " + rsn.getClass().getName());
1: 				}
1: 			}
0: 			source = ((VirtualColumnNode) sourceRC.getExpression()).
0: 										getSourceResultColumn();
1: 			return this;
1: 		}
1: 		else
1: 		{
1: 			return sourceRC.getExpression().getClone();
1: 		}
1: 	}
1: 
1: 	/** 
1: 	 * Update the table map to reflect the source
1: 	 * of this CR.
1: 	 *
1: 	 * @param refs	The table map.
1: 	 *
0: 	 * @return Nothing.
1: 	 */
1: 	void getTablesReferenced(JBitSet refs)
1: 	{
1: 		if (refs.size() < tableNumber)
1: 			refs.grow(tableNumber);
1: 
1: 		if (tableNumber != -1)	// it may not be set if replacesAggregate is true
1: 			refs.set(tableNumber);
1: 	}
1: 
1: 	/**
1: 	 * Return whether or not this expression tree is cloneable.
1: 	 *
1: 	 * @return boolean	Whether or not this expression tree is cloneable.
1: 	 */
0: 	public boolean isCloneable()
1: 	{
1: 		return true;
1: 	}
1: 
1: 	/** @see ValueNode#constantExpression */
0: 	public boolean constantExpression(PredicateList whereClause)
1: 	{
1: 		return whereClause.constantColumn(this);
1: 	}
1: 
1: 	/**
1: 	 * ColumnReference's are to the current row in the system.
1: 	 * This lets us generate
1: 	 * a faster get that simply returns the column from the
1: 	 * current row, rather than getting the value out and
1: 	 * returning that, only to have the caller (in the situations
1: 	 * needed) stuffing it back into a new column holder object.
1: 	 * We will assume the general generate() path is for getting
1: 	 * the value out, and use generateColumn() when we want to
1: 	 * keep the column wrapped.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	 public void generateExpression(ExpressionClassBuilder acb,
0: 											MethodBuilder mb)
1: 									throws StandardException
1: 	 {
1: 		int sourceResultSetNumber = source.getResultSetNumber();
1: 
1: 		//PUSHCOMPILE
1: 		/* Reuse generated code, where possible */
1: 
1: 		/*
1: 		** If the source is redundant, return the generation of its source.
1: 		** Most redundant nodes will be flattened out by this point, but
1: 		** in at least one case (elimination of redundant ProjectRestricts
1: 		** during generation) we don't do this.
1: 		*/
1: 		if (source.isRedundant())
1: 		{
1: 			source.generateExpression(acb, mb);
1: 			return;
1: 		}
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			if (sourceResultSetNumber < 0)
1: 			{
0: 				SanityManager.THROWASSERT("sourceResultSetNumber expected to be >= 0");
1: 			}
1: 		}
1: 
1: 		/* The ColumnReference is from an immediately underlying ResultSet.
1: 		 * The Row for that ResultSet is Activation.row[sourceResultSetNumber], 
1: 		 * where sourceResultSetNumber is the resultSetNumber for that ResultSet.
1: 		 *
1: 		 * The generated java is the expression:
1: 		 *	(<interface>) this.row[sourceResultSetNumber].getColumn(#columnId);
1: 		 *
1: 		 * where <interface> is the appropriate Datatype protocol interface
1: 		 * for the type of the column.
1: 		 */
1: 	    acb.pushColumnReference(mb, sourceResultSetNumber, 
1: 	    									source.getVirtualColumnId());
1: 
1: 		mb.cast(getTypeCompiler().interfaceName());
1: 
1: 		/* Remember generated code for possible resuse */
1: 	 }
1: 
1: 	/**
1: 	 * Get the user-supplied schema name of this column.  This will be null
1: 	 * if the user did not supply a name (for example, select t.a from t).
1: 	 *
1: 	 * @return	The user-supplied schema name of this column.  Null if no user-
1: 	 * 		supplied name.
1: 	 */
1: 
0: 	public String getSchemaName()
1: 	{
0: 		return ( ( tableName != null) ? tableName.getSchemaName() : null );
1: 	}
1: 
1: 	/**
1: 	 * Return the variant type for the underlying expression.
1: 	 * The variant type can be:
1: 	 *		VARIANT				- variant within a scan
1: 	 *							  (method calls and non-static field access)
1: 	 *		SCAN_INVARIANT		- invariant within a scan
1: 	 *							  (column references from outer tables)
1: 	 *		QUERY_INVARIANT		- invariant within the life of a query
1: 	 *							  (constant expressions)
1: 	 *
1: 	 * @return	The variant type for the underlying expression.
1: 	 */
1: 	protected int getOrderableVariantType()
1: 	{
1: 		// ColumnReferences are invariant for the life of the scan
1: 		return Qualifier.SCAN_INVARIANT;
1: 	}
1: 
1: 	/**
1: 	 * Return whether or not the source of this ColumnReference is itself a ColumnReference.
1: 	 *
1: 	 * @return Whether or not the source of this ColumnReference is itself a ColumnReference.
1: 	 */
1: 	boolean pointsToColumnReference()
1: 	{ 
1: 		return (source.getExpression() instanceof ColumnReference);
1: 	}
1: 
1: 	/**
0: 	 * Get the DataTypeServices from this Node.
1: 	 *
0: 	 * @return	The DataTypeServices from this Node.  This
0: 	 *		may be null if the node isn't bound yet.
1: 	 */
0: 	public DataTypeDescriptor getTypeServices()
1: 	{
0:         DataTypeDescriptor dtd = super.getTypeServices();
0:         if( dtd == null && source != null)
1:         {
0:             dtd = source.getTypeServices();
0:             if( dtd != null)
0:                 setType( dtd);
1:         }
0:         return dtd;
0:     } // end of getTypeServices
1: }
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2d37fd6
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 	 * @param columnName	The name of this column
/////////////////////////////////////////////////////////////////////////
1: 	 * @param tableNumber	The table number this ColumnReference will refer to
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:444aa52
/////////////////////////////////////////////////////////////////////////
0: 				"tableName: " + ( ( tableName != null) ? tableName.toString() : "null") + "\n" +
/////////////////////////////////////////////////////////////////////////
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:6eeba4f
/////////////////////////////////////////////////////////////////////////
0: 
0: 	/**
0: 	 * Determine whether or not this ColumnReference's source comes
0: 	 * from a FromBaseTable (as opposed to some other ResultSetNode).
0: 	 * We figure this out by walking the ResultColumn/VirtualColumnNode
0: 	 * chain until we get to last VirtualColumnNode in the chain
0: 	 * (if there is one), and then seeing what that VCN's source
0: 	 * result set is.  If there are no VCNs then we check to see
0: 	 * if the source is pointing to a BaseColumnNode.
0: 	 *
0: 	 * This is useful when scoping predicates for pushing; we
0: 	 * need to know if the predicate's column references are pointing
0: 	 * directly to base tables so that we can set the scoped references'
0: 	 * column numbers correctly.
0: 	 */
0: 	protected boolean pointsToBaseTable() throws StandardException
0: 	{
0: 		ResultColumn rc = getSource();
0: 
0: 		if (rc == null) {
0: 		// this can happen if column reference is pointing to a column
0: 		// that is not from a base table.  For example, if we have a
0: 		// VALUES clause like
0: 		//
0: 		//    (values (1, 2), (3, 4)) V1 (i, j)
0: 		//
0: 		// and then a column reference to VI.i, the column reference
0: 		// won't have a source.
0: 			return false;
0: 		}
0: 
0: 		// Walk the VirtualColumnNode->ResultColumn chain.
0: 		VirtualColumnNode vcn = null;
0: 		ValueNode rcExpr = rc.getExpression();
0: 		while (rcExpr instanceof VirtualColumnNode) {
0: 			vcn = (VirtualColumnNode)rcExpr;
0: 			rc = vcn.getSourceColumn();
0: 			rcExpr = rc.getExpression();
0: 		}
0: 
0: 		// If we've reached the bottom of the chain then see if
0: 		// the VCN is pointing to a FromBaseTable.
0: 		if (vcn != null)
0: 			return (vcn.getSourceResultSet() instanceof FromBaseTable);
0: 
0: 		// Else check our source's expression.
0: 		return (rc.getExpression() instanceof BaseColumnNode);
0: 	}
commit:e98f05a
/////////////////////////////////////////////////////////////////////////
1: 	 * @param colNum The new column number.
commit:6718a25
/////////////////////////////////////////////////////////////////////////
1: 	 * Set the column number for this ColumnReference.  This is
1: 	 * used when scoping predicates for pushdown.
0: 	 *
0: 	 * @param columnName	The new column number.
0: 	 */
0: 
0: 	public void setColumnNumber(int colNum)
0: 	{
1: 		this.columnNumber = colNum;
0: 	}
0: 
0: 	/**
/////////////////////////////////////////////////////////////////////////
0: 	/**
1: 	 * Returns true if this ColumnReference has been remapped; false
1: 	 * otherwise.
0: 	 *
1: 	 * @return Whether or not this ColumnReference has been remapped.
0: 	 */
1: 	protected boolean hasBeenRemapped()
0: 	{
0: 		return (origSource != null);
0: 	}
0: 
/////////////////////////////////////////////////////////////////////////
1: 				SanityManager.THROWASSERT("sourceResultSetNumber expected to be >= 0 for " + getTableName() + "." + getColumnName());
commit:d5bc20f
/////////////////////////////////////////////////////////////////////////
0: 	public DataTypeDescriptor getTypeServices() throws StandardException
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package	org.apache.derby.impl.sql.compile;
0: 
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
0: import org.apache.derby.iapi.sql.compile.NodeFactory;
0: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.impl.sql.compile.ExpressionClassBuilder;
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.store.access.Qualifier;
0: 
0: import org.apache.derby.iapi.util.JBitSet;
0: 
0: import java.util.Vector;
0: 
0: /**
0:  * A ColumnReference represents a column in the query tree.  The parser generates a
0:  * ColumnReference for each column reference.  A column refercence could be a column in
0:  * a base table, a column in a view (which could expand into a complex
0:  * expression), or a column in a subquery in the FROM clause.
0:  *
0:  * @author Jerry Brenner
0:  */
0: 
0: public class ColumnReference extends ValueNode
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	public String	columnName;
0: 
0: 	/*
0: 	** This is the user-specified table name.  It will be null if the
0: 	** user specifies a column without a table name.  Leave it null even
0: 	** when the column is bound as it is only used in binding.
0: 	*/
0: 	public TableName	tableName;
0: 	/* The table this column reference is bound to */
0: 	public int			tableNumber;	
0: 	/* The column number in the underlying base table */
0: 	public int			columnNumber;	
0: 	/* This is where the value for this column reference will be coming from */
0: 	public ResultColumn	source;
0: 
0: 	/* For unRemapping */
0: 	ResultColumn	origSource;
0: 	public String	origName;
0: 	int				origTableNumber = -1;
0: 	int				origColumnNumber = -1;
0: 
0: 	/* Reuse generated code where possible */
0: 	//Expression genResult;
0: 
0: 	private boolean		replacesAggregate;
0: 
0: 	private int			nestingLevel = -1;
0: 	private int			sourceLevel = -1;
0: 
0: 	/*
0: 	** These fields are used to track the being and end
0: 	** offset of the token from which the column name came.
0: 	*/
0: 	private int		tokBeginOffset = -1;
0: 	private int		tokEndOffset = -1;
0: 
0: 	/**
0: 	 * Initializer.
0: 	 * This one is called by the parser where we could
0: 	 * be dealing with delimited identifiers.
0: 	 *
0: 	 * @param columnName	The name of the column being referenced
0: 	 * @param tableName		The qualification for the column
0: 	 * @param tokBeginOffset begin position of token for the column name 
0: 	 *					identifier from parser.
0: 	 * @param tokEndOffset	end position of token for the column name 
0: 	 *					identifier from parser.
0: 	 */
0: 
0: 	public void init(Object columnName, 
0: 					 Object tableName,
0: 			 		 Object	tokBeginOffset,
0: 					 Object	tokEndOffset
0: 					 )
0: 	{
0: 		this.columnName = (String) columnName;
0: 		this.tableName = (TableName) tableName;
0: 		this.tokBeginOffset = ((Integer) tokBeginOffset).intValue();
0: 		this.tokEndOffset = ((Integer) tokEndOffset).intValue();
0: 		tableNumber = -1;
0: 	}
0: 
0: 	/**
0: 	 * Initializer.
0: 	 *
0: 	 * @param columnName	The name of the column being referenced
0: 	 * @param tableName		The qualification for the column
0: 	 */
0: 
0: 	public void init(Object columnName, Object tableName)
0: 	{
0: 		this.columnName = (String) columnName;
0: 		this.tableName = (TableName) tableName;
0: 		tableNumber = -1;
0: 	}
0: 
0: 	/**
0: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
0: 	 * for how this should be done for tree printing.
0: 	 *
0: 	 * @return	This object as a String
0: 	 */
0: 
0: 	public String toString()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			return "columnName: " + columnName + "\n" +
0: 				"tableNumber: " + tableNumber + "\n" +
0: 				"columnNumber: " + columnNumber + "\n" +
0: 				"replacesAggregate: " + replacesAggregate + "\n" +
0: 				( ( tableName != null) ?
0: 						tableName.toString() :
0: 						"tableName: null\n") +
0: 				"nestingLevel: " + nestingLevel + "\n" +
0: 				"sourceLevel: " + sourceLevel + "\n" +
0: 				super.toString();
0: 		}
0: 		else
0: 		{
0: 			return "";
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
0: 	 * how tree printing is supposed to work.
0: 	 *
0: 	 * @param depth		The depth of this node in the tree
0: 	 *
0: 	 * @return	Nothing
0: 	 */
0: 
0: 	public void printSubNodes(int depth)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			super.printSubNodes(depth);
0: 
0: 			if (source != null)
0: 			{
0: 				printLabel(depth, "source: ");
0: 				source.treePrint(depth + 1);
0: 			}
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Get the begin offset of the parser token for the column name
0: 	 * Will only be set when the CR was generated by the
0: 	 * parser.
0: 	 *
0: 	 * @return the begin offset of the token.  -1 means unknown
0: 	 */
0: 	public int getTokenBeginOffset()
0: 	{
0: 		/* We should never get called if not initialized, as
0: 		 * begin/end offset has no meaning unless this CR was
0: 		 * created in the parser.
0: 		 */
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (tokBeginOffset == -1)
0: 			{
0: 				SanityManager.THROWASSERT(
0: 					"tokBeginOffset not expected to be -1");
0: 			}
0: 		}
0: 		return tokBeginOffset;
0: 	}
0: 
0: 	/**
0: 	 * Get the end offset of the parser token for the column name.
0: 	 * Will only be set when the CR was generated by the
0: 	 * parser.
0: 	 *
0: 	 * @return the end offset of the token.  -1 means unknown
0: 	 */
0: 	public int getTokenEndOffset()
0: 	{
0: 		/* We should never get called if not initialized, as
0: 		 * begin/end offset has no meaning unless this CR was
0: 		 * created in the parser.
0: 		 */
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (tokEndOffset == -1)
0: 			{
0: 				SanityManager.THROWASSERT(
0: 					"tokEndOffset not expected to be -1");
0: 			}
0: 		}
0: 		return tokEndOffset;
0: 	}
0: 
0: 	/**
0: 	 * Return whether or not this CR is correlated.
0: 	 *
0: 	 * @return Whether or not this CR is correlated.
0: 	 */
0: 	boolean getCorrelated()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(nestingLevel != -1,
0: 				"nestingLevel on "+columnName+" is not expected to be -1");
0: 			SanityManager.ASSERT(sourceLevel != -1,
0: 				"sourceLevel on "+columnName+" is not expected to be -1");
0: 		}
0: 		return sourceLevel != nestingLevel;
0: 	}
0: 
0: 	/**
0: 	 * Set the nesting level for this CR.  (The nesting level
0: 	 * at which the CR appears.)
0: 	 *
0: 	 * @param nestingLevel	The Nesting level at which the CR appears.
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	void setNestingLevel(int nestingLevel)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(nestingLevel != -1,
0: 				"nestingLevel is not expected to be -1");
0: 		}
0: 		this.nestingLevel = nestingLevel;
0: 	}
0: 
0: 	/**
0: 	 * Get the nesting level for this CR.
0: 	 *
0: 	 * @return	The nesting level for this CR.
0: 	 */
0: 	int getNestingLevel()
0: 	{
0: 		return nestingLevel;
0: 	}
0: 
0: 	/**
0: 	 * Set the source level for this CR.  (The nesting level
0: 	 * of the source of the CR.)
0: 	 *
0: 	 * @param sourceLevel	The Nesting level of the source of the CR.
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	void setSourceLevel(int sourceLevel)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(sourceLevel != -1,
0: 				"sourceLevel is not expected to be -1");
0: 		}
0: 		this.sourceLevel = sourceLevel;
0: 	}
0: 
0: 	/**
0: 	 * Get the source level for this CR.
0: 	 *
0: 	 * @return	The source level for this CR.
0: 	 */
0: 	int getSourceLevel()
0: 	{
0: 		return sourceLevel;
0: 	}
0: 
0: 	/**
0: 	 * Mark this node as being generated to replace an aggregate.
0: 	 * (Useful for replacing aggregates in the HAVING clause with 
0: 	 * column references to the matching aggregate in the 
0: 	 * user's SELECT.
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	public void markGeneratedToReplaceAggregate()
0: 	{
0: 		replacesAggregate = true;
0: 	}
0: 
0: 	/**
0: 	 * Determine whether or not this node was generated to
0: 	 * replace an aggregate in the user's SELECT.
0: 	 *
0: 	 * @return boolean	Whether or not this node was generated to replace
0: 	 *					an aggregate in the user's SELECT.
0: 	 */
0: 	public boolean getGeneratedToReplaceAggregate()
0: 	{
0: 		return replacesAggregate;
0: 	}
0: 
0: 	/**
0: 	 * Return a clone of this node.
0: 	 *
0: 	 * @return ValueNode	A clone of this node.
0: 	 *
0: 	 * @exception StandardException			Thrown on error
0: 	 */
0: 	public ValueNode getClone()
0: 		throws StandardException
0: 	{
0: 		ColumnReference newCR = (ColumnReference) getNodeFactory().getNode(
0: 									C_NodeTypes.COLUMN_REFERENCE,
0: 									columnName,
0: 									tableName,
0: 									getContextManager());
0: 
0: 		newCR.copyFields(this);
0: 		return newCR;
0: 	}
0: 
0: 	/**
0: 	 * Copy all of the "appropriate fields" for a shallow copy.
0: 	 *
0: 	 * @param oldCR		The ColumnReference to copy from.
0: 	 *
0: 	 * @exception StandardException			Thrown on error
0: 	 */
0: 	public void copyFields(ColumnReference oldCR)
0: 		throws StandardException
0: 	{
0: 		super.copyFields(oldCR);
0: 
0: 		tableName = oldCR.getTableNameNode();
0: 		tableNumber = oldCR.getTableNumber();
0: 		columnNumber = oldCR.getColumnNumber();
0: 		source = oldCR.getSource();
0: 		nestingLevel = oldCR.getNestingLevel();
0: 		sourceLevel = oldCR.getSourceLevel();
0: 		replacesAggregate = oldCR.getGeneratedToReplaceAggregate();
0: 	}
0: 
0: 	/**
0: 	 * Bind this expression.  This means binding the sub-expressions,
0: 	 * as well as figuring out what the return type is for this expression.
0: 	 *
0: 	 * NOTE: We must explicitly check for a null FromList here, column reference
0: 	 * without a FROM list, as the grammar allows the following:
0: 	 *			insert into t1 values(c1)
0: 	 *
0: 	 * @param fromList		The FROM list for the query this
0: 	 *				expression is in, for binding columns.
0: 	 * @param subqueryList		The subquery list being built as we find SubqueryNodes
0: 	 * @param aggregateVector	The aggregate vector being built as we find AggregateNodes
0: 	 *
0: 	 * @return	The new top of the expression tree.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public ValueNode bindExpression(FromList fromList, SubqueryList subqueryList,
0: 			Vector aggregateVector) 
0: 				throws StandardException
0: 	{
0: 
0: 		ResultColumn matchingRC;
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(fromList != null, "fromList is expected to be non-null");
0: 		}
0: 
0: 		if (fromList.size() == 0)
0: 		{
0: 			throw StandardException.newException(SQLState.LANG_ILLEGAL_COLUMN_REFERENCE, columnName);
0: 		}
0: 
0: 		matchingRC = fromList.bindColumnReference(this);
0: 
0: 		/* Error if no match found in fromList */
0: 		if (matchingRC == null)
0: 		{
0: 			throw StandardException.newException(SQLState.LANG_COLUMN_NOT_FOUND, getFullColumnName());
0: 		}
0: 
0: 		/* Set the columnNumber from the base table.
0:  		 * Useful for optimizer and generation.
0: 		 */
0: 		columnNumber = matchingRC.getColumnPosition();
0: 
0: 		return this;
0: 	}
0: 
0: 	/**
0: 	 * Get the full column name of this column for purposes of error
0: 	 * messages or debugging.  The full column name includes the table
0: 	 * name and schema name, if any.
0: 	 *
0: 	 * @return	The full column name in the form schema.table.column
0: 	 */
0: 
0: 	public String getFullColumnName()
0: 	{
0: 		String	fullColumnName = "";
0: 
0: 		if (tableName != null)
0: 			fullColumnName += tableName.getFullTableName() + ".";
0: 		fullColumnName += columnName;
0: 
0: 		return fullColumnName;
0: 	}
0: 
0: 	/**
0: 	 * Get the name of this column
0: 	 *
0: 	 * @return	The name of this column
0: 	 */
0: 
0: 	public String getColumnName()
0: 	{
0: 		return columnName;
0: 	}
0: 
0: 	/**
0: 	 * Set the name of this column
0: 	 *
0: 	 * @param columName	The name of this column
0: 	 *
0: 	 * @return None.
0: 	 */
0: 
0: 	public void setColumnName(String columnName)
0: 	{
0: 		this.columnName = columnName;
0: 	}
0: 
0: 	/**
0: 	 * Get the table number for this ColumnReference.
0: 	 *
0: 	 * @return	int The table number for this ColumnReference
0: 	 */
0: 
0: 	public int getTableNumber()
0: 	{
0: 		return tableNumber;
0: 	}
0: 
0: 	/**
0: 	 * Set this ColumnReference to refer to the given table number.
0: 	 *
0: 	 * @param table	The table number this ColumnReference will refer to
0: 	 *
0: 	 * @return	Nothing
0: 	 */
0: 
0: 	public void setTableNumber(int tableNumber)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(tableNumber != -1,
0: 				"tableNumber not expected to be -1");
0: 		}
0: 		this.tableNumber = tableNumber;
0: 	}
0: 
0: 	/**
0: 	 * Get the user-supplied table name of this column.  This will be null
0: 	 * if the user did not supply a name (for example, select a from t).
0: 	 *
0: 	 * @return	The user-supplied name of this column.  Null if no user-
0: 	 * 		supplied name.
0: 	 */
0: 
0: 	public String getTableName()
0: 	{
0: 		return ( ( tableName != null) ? tableName.getTableName() : null );
0: 	}
0: 
0: 	/**
0: 	 * Get the name of the table this column comes from.
0: 	 *
0: 	 * @return	The name of the table that this column comes from.  
0: 	 *			Null if not a ColumnReference.
0: 	 */
0: 
0: 	public String getSourceTableName()
0: 	{
0: 		return ( ( tableName != null) ? tableName.getTableName() : 
0: 					((source != null) ? source.getTableName() : null));
0: 	}
0: 
0: 	/**
0: 	  Return the table name as the node it is.
0: 	  @return the column's table name.
0: 	 */
0: 	public TableName getTableNameNode()
0: 	{
0: 		return tableName;
0: 	}
0: 
0: 	public void setTableNameNode(TableName tableName)
0: 	{
0: 		this.tableName = tableName;
0: 	}
0: 
0: 	/**
0: 	 * Get the column number for this ColumnReference.
0: 	 *
0: 	 * @return	int The column number for this ColumnReference
0: 	 */
0: 
0: 	public int getColumnNumber()
0: 	{
0: 		return columnNumber;
0: 	}
0: 
0: 	/**
0: 	 * Get the source this columnReference
0: 	 *
0: 	 * @return	The source of this columnReference
0: 	 */
0: 
0: 	public ResultColumn getSource()
0: 	{
0: 		return source;
0: 	}
0: 
0: 	/**
0: 	 * Set the source this columnReference
0: 	 *
0: 	 * @param source	The source of this columnReference
0: 	 *
0: 	 * @return None.
0: 	 */
0: 
0: 	public void setSource(ResultColumn source)
0: 	{
0: 		this.source = source;
0: 	}
0: 
0: 	/**
0: 	 * Do the 1st step in putting an expression into conjunctive normal
0: 	 * form.  This step ensures that the top level of the expression is
0: 	 * a chain of AndNodes.
0: 	 *
0: 	 * @return		The modified expression
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public ValueNode putAndsOnTop() 
0: 					throws StandardException
0: 	{
0: 		BinaryComparisonOperatorNode		equalsNode;
0: 		BooleanConstantNode	trueNode;
0: 		NodeFactory		nodeFactory = getNodeFactory();
0: 		ValueNode		andNode;
0: 
0:         trueNode = (BooleanConstantNode) nodeFactory.getNode(
0: 										C_NodeTypes.BOOLEAN_CONSTANT_NODE,
0: 										Boolean.TRUE,
0: 										getContextManager());
0: 		equalsNode = (BinaryComparisonOperatorNode) 
0: 						nodeFactory.getNode(
0: 										C_NodeTypes.BINARY_EQUALS_OPERATOR_NODE,
0: 										this,
0: 										trueNode,
0: 										getContextManager());
0: 		/* Set type info for the operator node */
0: 		equalsNode.bindComparisonOperator();
0: 		andNode = (ValueNode) nodeFactory.getNode(
0: 									C_NodeTypes.AND_NODE,
0: 									equalsNode,
0: 									trueNode,
0: 									getContextManager());
0: 		((AndNode) andNode).postBindFixup();
0: 		return andNode;
0: 	}
0: 
0: 	/**
0: 	 * Categorize this predicate.  Initially, this means
0: 	 * building a bit map of the referenced tables for each predicate.
0: 	 * If the source of this ColumnReference (at the next underlying level) 
0: 	 * is not a ColumnReference or a VirtualColumnNode then this predicate
0: 	 * will not be pushed down.
0: 	 *
0: 	 * For example, in:
0: 	 *		select * from (select 1 from s) a (x) where x = 1
0: 	 * we will not push down x = 1.
0: 	 * NOTE: It would be easy to handle the case of a constant, but if the
0: 	 * inner SELECT returns an arbitrary expression, then we would have to copy
0: 	 * that tree into the pushed predicate, and that tree could contain
0: 	 * subqueries and method calls.
0: 	 *
0: 	 * Also, don't allow a predicate to be pushed down if it contains a
0: 	 * ColumnReference that replaces an aggregate.  This can happen if
0: 	 * the aggregate is in the HAVING clause.  In this case, we would be
0: 	 * pushing the predicate into the SelectNode that evaluates the aggregate,
0: 	 * which doesn't make sense, since the having clause is supposed to be
0: 	 * applied to the result of the SelectNode.
0: 	 *
0: 	 * RESOLVE - revisit this issue once we have views.
0: 	 *
0: 	 * @param referencedTabs	JBitSet with bit map of referenced FromTables
0: 	 * @param simplePredsOnly	Whether or not to consider method
0: 	 *							calls, field references and conditional nodes
0: 	 *							when building bit map
0: 	 *
0: 	 * @return boolean		Whether or not source.expression is a ColumnReference
0: 	 *						or a VirtualColumnNode or a ConstantNode.
0: 	 */
0: 	public boolean categorize(JBitSet referencedTabs, boolean simplePredsOnly)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		SanityManager.ASSERT(tableNumber >= 0,
0: 							 "tableNumber is expected to be non-negative");
0: 		referencedTabs.set(tableNumber);
0: 
0: 		return ( ! replacesAggregate ) &&
0: 			   ( (source.getExpression() instanceof ColumnReference) ||
0: 			     (source.getExpression() instanceof VirtualColumnNode) ||
0: 				 (source.getExpression() instanceof ConstantNode));
0: 	}
0: 
0: 	/**
0: 	 * Remap all of the ColumnReferences in this expression tree
0: 	 * to point to the ResultColumn that is 1 level under their
0: 	 * current source ResultColumn.
0: 	 * This is useful for pushing down single table predicates.
0: 	 *
0: 	 * RESOLVE: Once we start pushing join clauses, we will need to walk the
0: 	 * ResultColumn/VirtualColumnNode chain for them to remap the references.
0: 	 *
0: 	 * @return None.
0: 	 */
0: 	public void remapColumnReferences()
0: 	{
0: 		ValueNode expression = source.getExpression();
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			// SanityManager.ASSERT(origSource == null,
0: 			// 		"Trying to remap ColumnReference twice without unremapping it.");
0: 		}
0: 
0: 		if ( ! ( (expression instanceof VirtualColumnNode) ||
0: 				 (expression instanceof ColumnReference) )
0: 			)
0: 		{
0: 			return;
0: 		}
0: 
0: 		/* Find the matching ResultColumn */
0: 		origSource = source;
0: 		source = getSourceResultColumn();
0: 		origName = columnName;
0: 		columnName = source.getName();
0: 		origColumnNumber = columnNumber;
0: 		columnNumber = source.getColumnPosition();
0: 
0: 		origTableNumber = tableNumber;
0: 		if (source.getExpression() instanceof ColumnReference)
0: 		{
0: 			ColumnReference cr = (ColumnReference) source.getExpression();
0: 			tableNumber = cr.getTableNumber();
0: 			if (SanityManager.DEBUG)
0: 			{
0: 				// if dummy cr generated to replace aggregate, it may not have table number
0: 				// because underneath can be more than 1 table.
0: 				if (tableNumber == -1 && ! cr.getGeneratedToReplaceAggregate())
0: 				{
0: 					SanityManager.THROWASSERT(
0: 						"tableNumber not expected to be -1, origName = " + origName);
0: 				}
0: 			}
0: 		}
0: 	}
0: 
0: 	public void unRemapColumnReferences()
0: 	{
0: 		if (origSource == null)
0: 			return;
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			// SanityManager.ASSERT(origSource != null,
0: 			// 	"Trying to unremap a ColumnReference that was not remapped.");
0: 		}
0: 
0: 		source = origSource;
0: 		origSource = null;
0: 		columnName = origName;
0: 		origName = null;
0: 		tableNumber = origTableNumber;
0: 		columnNumber = origColumnNumber;
0: 	}
0: 
0: 	/*
0: 	 * Get the ResultColumn that the source points to.  This is useful for
0: 	 * getting what the source will be after this ColumnReference is remapped.
0: 	 */
0: 	public ResultColumn getSourceResultColumn()
0: 	{
0: 		ValueNode expression = source.getExpression();
0: 
0: 		/* Find the matching ResultColumn */
0: 		if (expression instanceof VirtualColumnNode) 
0: 		{
0: 			return ((VirtualColumnNode) expression).getSourceResultColumn();
0: 		}
0: 		else
0: 		{
0: 			/* RESOLVE - If expression is a ColumnReference, then we are hitting
0: 			 * the top of a query block (derived table or view.)
0: 			 * In order to be able to push the expression down into the next
0: 			 * query block, it looks like we should reset the contents of the
0: 			 * current ColumnReference to be the same as expression.  (This probably
0: 			 * only means names and tableNumber.)  We would then "rebind" the top
0: 			 * level predicate somewhere up the call stack and see if we could push
0: 			 * the predicate through.
0: 			 */
0: 			return ((ColumnReference) expression).getSourceResultColumn();
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Remap all ColumnReferences in this tree to be clones of the
0: 	 * underlying expression.
0: 	 *
0: 	 * @return ValueNode			The remapped expression tree.
0: 	 *
0: 	 * @exception StandardException			Thrown on error
0: 	 */
0: 	public ValueNode remapColumnReferencesToExpressions()
0: 		throws StandardException
0: 	{
0: 		ResultColumn	rc;
0: 		ResultColumn	sourceRC = source;
0: 
0: 		/* Nothing to do if we are not pointing to a redundant RC */
0: 		if (! source.isRedundant())
0: 		{
0: 			return this;
0: 		}
0: 
0: 		/* Find the last redundant RC in the chain.  We
0: 		 * want to clone its expression.
0: 		 */
0: 		for (rc = source; rc != null && rc.isRedundant(); )
0: 		{
0: 			ResultColumn	nextRC = null;
0: 			ValueNode		expression = rc.getExpression();
0: 
0: 			/* Find the matching ResultColumn */
0: 			if (expression instanceof VirtualColumnNode) 
0: 			{
0: 				nextRC = ((VirtualColumnNode) expression).getSourceResultColumn();
0: 			}
0: 			else if (expression instanceof ColumnReference)
0: 			{
0: 				nextRC = ((ColumnReference) expression).getSourceResultColumn();
0: 			}
0: 			else
0: 			{
0: 				nextRC = null;
0: 			}
0: 
0: 			if (nextRC != null && nextRC.isRedundant())
0: 			{
0: 				sourceRC = nextRC;
0: 			}
0: 			rc = nextRC;
0: 		}
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (sourceRC == null)
0: 			{
0: 				SanityManager.THROWASSERT(
0: 					"sourceRC is expected to be non-null for " +
0: 					columnName);
0: 			}
0: 
0: 			if ( ! sourceRC.isRedundant())
0: 			{
0: 				SanityManager.THROWASSERT(
0: 					"sourceRC is expected to be redundant for " +
0: 					columnName);
0: 			}
0: 		}
0: 
0: 		/* If last expression is a VCN, then we can't clone it.
0: 		 * Instead, we just reset our source to point to the
0: 		 * source of the VCN, those chopping out the layers.
0: 		 * Otherwise, we return a clone of the underlying expression.
0: 		 */
0: 		if (sourceRC.getExpression() instanceof VirtualColumnNode)
0: 		{
0: 			VirtualColumnNode vcn =
0: 				(VirtualColumnNode) (sourceRC.getExpression());
0: 			ResultSetNode rsn = vcn.getSourceResultSet();
0: 			if (rsn instanceof FromTable)
0: 			{
0: 				tableNumber = ((FromTable) rsn).getTableNumber();
0: 				if (SanityManager.DEBUG)
0: 				{
0: 					SanityManager.ASSERT(tableNumber != -1,
0: 						"tableNumber not expected to be -1");
0: 				}
0: 			}
0: 			else
0: 			{
0: 				if (SanityManager.DEBUG)
0: 				{
0: 					SanityManager.THROWASSERT("rsn expected to be a FromTable, but is a " + rsn.getClass().getName());
0: 				}
0: 			}
0: 			source = ((VirtualColumnNode) sourceRC.getExpression()).
0: 										getSourceResultColumn();
0: 			return this;
0: 		}
0: 		else
0: 		{
0: 			return sourceRC.getExpression().getClone();
0: 		}
0: 	}
0: 
0: 	/** 
0: 	 * Update the table map to reflect the source
0: 	 * of this CR.
0: 	 *
0: 	 * @param refs	The table map.
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	void getTablesReferenced(JBitSet refs)
0: 	{
0: 		if (refs.size() < tableNumber)
0: 			refs.grow(tableNumber);
0: 
0: 		if (tableNumber != -1)	// it may not be set if replacesAggregate is true
0: 			refs.set(tableNumber);
0: 	}
0: 
0: 	/**
0: 	 * Return whether or not this expression tree is cloneable.
0: 	 *
0: 	 * @return boolean	Whether or not this expression tree is cloneable.
0: 	 */
0: 	public boolean isCloneable()
0: 	{
0: 		return true;
0: 	}
0: 
0: 	/** @see ValueNode#constantExpression */
0: 	public boolean constantExpression(PredicateList whereClause)
0: 	{
0: 		return whereClause.constantColumn(this);
0: 	}
0: 
0: 	/**
0: 	 * ColumnReference's are to the current row in the system.
0: 	 * This lets us generate
0: 	 * a faster get that simply returns the column from the
0: 	 * current row, rather than getting the value out and
0: 	 * returning that, only to have the caller (in the situations
0: 	 * needed) stuffing it back into a new column holder object.
0: 	 * We will assume the general generate() path is for getting
0: 	 * the value out, and use generateColumn() when we want to
0: 	 * keep the column wrapped.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	 public void generateExpression(ExpressionClassBuilder acb,
0: 											MethodBuilder mb)
0: 									throws StandardException
0: 	 {
0: 		int sourceResultSetNumber = source.getResultSetNumber();
0: 
0: 		//PUSHCOMPILE
0: 		/* Reuse generated code, where possible */
0: 
0: 		/*
0: 		** If the source is redundant, return the generation of its source.
0: 		** Most redundant nodes will be flattened out by this point, but
0: 		** in at least one case (elimination of redundant ProjectRestricts
0: 		** during generation) we don't do this.
0: 		*/
0: 		if (source.isRedundant())
0: 		{
0: 			source.generateExpression(acb, mb);
0: 			return;
0: 		}
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (sourceResultSetNumber < 0)
0: 			{
0: 				SanityManager.THROWASSERT("sourceResultSetNumber expected to be >= 0");
0: 			}
0: 		}
0: 
0: 		/* The ColumnReference is from an immediately underlying ResultSet.
0: 		 * The Row for that ResultSet is Activation.row[sourceResultSetNumber], 
0: 		 * where sourceResultSetNumber is the resultSetNumber for that ResultSet.
0: 		 *
0: 		 * The generated java is the expression:
0: 		 *	(<interface>) this.row[sourceResultSetNumber].getColumn(#columnId);
0: 		 *
0: 		 * where <interface> is the appropriate Datatype protocol interface
0: 		 * for the type of the column.
0: 		 */
0: 	    acb.pushColumnReference(mb, sourceResultSetNumber, 
0: 	    									source.getVirtualColumnId());
0: 
0: 		mb.cast(getTypeCompiler().interfaceName());
0: 
0: 		/* Remember generated code for possible resuse */
0: 	 }
0: 
0: 	/**
0: 	 * Get the user-supplied schema name of this column.  This will be null
0: 	 * if the user did not supply a name (for example, select t.a from t).
0: 	 *
0: 	 * @return	The user-supplied schema name of this column.  Null if no user-
0: 	 * 		supplied name.
0: 	 */
0: 
0: 	public String getSchemaName()
0: 	{
0: 		return ( ( tableName != null) ? tableName.getSchemaName() : null );
0: 	}
0: 
0: 	/**
0: 	 * Return the variant type for the underlying expression.
0: 	 * The variant type can be:
0: 	 *		VARIANT				- variant within a scan
0: 	 *							  (method calls and non-static field access)
0: 	 *		SCAN_INVARIANT		- invariant within a scan
0: 	 *							  (column references from outer tables)
0: 	 *		QUERY_INVARIANT		- invariant within the life of a query
0: 	 *							  (constant expressions)
0: 	 *
0: 	 * @return	The variant type for the underlying expression.
0: 	 */
0: 	protected int getOrderableVariantType()
0: 	{
0: 		// ColumnReferences are invariant for the life of the scan
0: 		return Qualifier.SCAN_INVARIANT;
0: 	}
0: 
0: 	/**
0: 	 * Return whether or not the source of this ColumnReference is itself a ColumnReference.
0: 	 *
0: 	 * @return Whether or not the source of this ColumnReference is itself a ColumnReference.
0: 	 */
0: 	boolean pointsToColumnReference()
0: 	{ 
0: 		return (source.getExpression() instanceof ColumnReference);
0: 	}
0: 
0: 	/**
0: 	 * Get the DataTypeServices from this Node.
0: 	 *
0: 	 * @return	The DataTypeServices from this Node.  This
0: 	 *		may be null if the node isn't bound yet.
0: 	 */
0: 	public DataTypeDescriptor getTypeServices()
0: 	{
0:         DataTypeDescriptor dtd = super.getTypeServices();
0:         if( dtd == null && source != null)
0:         {
0:             dtd = source.getTypeServices();
0:             if( dtd != null)
0:                 setType( dtd);
0:         }
0:         return dtd;
0:     } // end of getTypeServices
0: }
============================================================================