1:80570d6: /*
1:80570d6:  *
1:80570d6:  * Derby - Class org.apache.derbyTesting.system.oe.client.Submitter
1:80570d6:  *
1:80570d6:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:80570d6:  * contributor license agreements.  See the NOTICE file distributed with
1:80570d6:  * this work for additional information regarding copyright ownership.
1:80570d6:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:80570d6:  * (the "License"); you may not use this file except in compliance with
1:80570d6:  * the License.  You may obtain a copy of the License at
1:80570d6:  *
1:80570d6:  *    http://www.apache.org/licenses/LICENSE-2.0
1:80570d6:  *
1:80570d6:  * Unless required by applicable law or agreed to in writing, 
1:80570d6:  * software distributed under the License is distributed on an 
1:80570d6:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, 
1:80570d6:  * either express or implied. See the License for the specific 
1:80570d6:  * language governing permissions and limitations under the License.
1:80570d6:  */
1:80570d6: package org.apache.derbyTesting.system.oe.client;
2:80570d6: 
1:80570d6: import java.io.PrintStream;
1:80570d6: import java.math.BigDecimal;
1:4469400: import java.math.RoundingMode;
1:76c452e: import java.sql.Connection;
1:76c452e: import java.sql.ResultSet;
1:76c452e: import java.sql.SQLException;
1:31ad846: import java.util.Arrays;
1:80570d6: 
1:80570d6: import org.apache.derbyTesting.system.oe.util.OERandom;
1:80570d6: 
1:80570d6: /**
1:80570d6:  * Class that submits Order Entry transactions
1:80570d6:  * to a database through an instance of an Operations class.
1:80570d6:  * This class is responsible for the mix of transactions
1:80570d6:  * and the generation of the random input values.
1:80570d6:  * 
1:80570d6:  * Sub-classes can override the mix.
1:80570d6:  */
1:80570d6: public class Submitter {
1:80570d6:     
1:80570d6:     /**
1:80570d6:      * Offset of Stock Level transaction in returned
1:80570d6:      * arrays with run information.
1:80570d6:      */
1:80570d6:     public static final int STOCK_LEVEL = 0;
1:80570d6:     /**
1:80570d6:      * Offset of Order Status by Name transaction in returned
1:80570d6:      * arrays with run information.
1:80570d6:      */    
1:80570d6:     public static final int ORDER_STATUS_BY_NAME = 1;
1:80570d6:     /**
1:80570d6:      * Offset of Order Status by Id transaction in returned
1:80570d6:      * arrays with run information.
1:80570d6:      */
1:80570d6:     public static final int ORDER_STATUS_BY_ID = 2;
1:80570d6:     
1:80570d6:      /**
1:80570d6:       * Offset of Payment by Name transaction in returned
1:80570d6:       * arrays with run information.
1:80570d6:       */
1:80570d6:     public static final int PAYMENT_BY_NAME = 3;
1:80570d6:     
1:80570d6:     /**
1:80570d6:      * Offset of Payement by ID transaction in returned
1:80570d6:      * arrays with run information.
1:80570d6:      */
1:80570d6:     public static final int PAYMENT_BY_ID = 4;
1:80570d6:     
1:80570d6:     /**
1:80570d6:      * Offset of Delivery transaction in returned
1:80570d6:      * arrays with run information.
1:80570d6:      */
1:80570d6:     public static final int DELIVERY_SCHEDULE = 5;
1:80570d6:     
1:80570d6:     /**
1:80570d6:      * Offset of New Order transaction in returned
1:80570d6:      * arrays with run information.
1:80570d6:      */
1:80570d6:     public static final int NEW_ORDER = 6;
1:80570d6:     
1:80570d6:     /**
1:80570d6:      * Offset of New Order transaction that rolled back in returned
1:80570d6:      * arrays with run information.
1:80570d6:      */
1:80570d6:     public static final int NEW_ORDER_ROLLBACK = 7;
1:80570d6:     
1:80570d6:     /**
1:80570d6:      * Display to write the output to.
1:80570d6:      */
1:80570d6:     private final Display display;
1:80570d6:     
1:80570d6:     /**
1:80570d6:      * How the business transactions are implemented.
1:80570d6:      */
1:80570d6:     private final Operations ops;
1:80570d6:     
1:80570d6:     /**
1:80570d6:      * My own random number generator.
1:80570d6:      */
1:80570d6:     private final OERandom rand;
1:80570d6:     
1:80570d6:     /**
1:80570d6:      * Scale of the database.
1:80570d6:      */
1:80570d6:     private final short maxW;
1:80570d6:     
1:80570d6:     /**
1:80570d6:      * Record of how many transactions are implemented.
1:80570d6:      */
1:80570d6:     private final int[] transactionCount;
1:76c452e:     
1:76c452e:     /**
1:76c452e:      * Generate a new random number generator
1:76c452e:      * that follows the rules according to 2.1.6.1
1:76c452e:      * @param conn
1:183bfa5:      * @return rand number generator
1:76c452e:      * @throws SQLException
1:76c452e:      */
1:76c452e:     public static OERandom getRuntimeRandom(Connection conn)
1:76c452e:         throws SQLException
1:76c452e:     {
1:76c452e:         OERandom rand = new OERandom(-1);
1:76c452e:         
1:76c452e:         ResultSet rs = conn.createStatement().executeQuery(
1:76c452e:                 "SELECT CLOAD FROM C");
1:76c452e:         rs.next();
1:76c452e:         int cload = rs.getInt(1);
1:76c452e:         rs.close();
1:76c452e:         
1:76c452e:         for (;;)
1:76c452e:         {
1:76c452e:             int c = rand.randomInt(0, 255);
1:76c452e:             int delta = Math.abs(cload - c);
1:76c452e:             if (delta == 96 || delta == 112)
1:76c452e:                 continue;
1:76c452e:             if (delta < 65 || delta > 119)
1:76c452e:                 continue;
1:76c452e:             
1:76c452e:             rand = new OERandom(c);
1:76c452e:             break;
1:76c452e:         }
1:76c452e:         
1:76c452e:         return rand;
1:76c452e:     }
1:1b6c3f0:     
1:1b6c3f0:     /**
1:1b6c3f0:      * Return a Submitter than only executes stock level transactions.
1:1b6c3f0:      */
1:1b6c3f0:     public static Submitter stockLevelOnly(Display display,
1:1b6c3f0:     		Operations ops, OERandom rand,
1:1b6c3f0:             short maxW)
1:1b6c3f0:     {
1:1b6c3f0:     	return new Submitter(display, ops, rand, maxW)
1:1b6c3f0: 		{
1:1b6c3f0: 			protected int mixType(final int chooseType)
1:1b6c3f0: 			{
1:1b6c3f0: 				return Submitter.STOCK_LEVEL;
1:1b6c3f0: 			}
1:1b6c3f0: 		};  	
1:1b6c3f0:     }
1:1b6c3f0:     /**
1:1b6c3f0:      * Return a Submitter than only executes order
1:1b6c3f0:      * status by identifier transactions.
1:1b6c3f0:      */
1:1b6c3f0:     public static Submitter orderStatusByIdOnly(Display display,
1:1b6c3f0:     		Operations ops, OERandom rand,
1:1b6c3f0:             short maxW)
1:1b6c3f0:     {
1:1b6c3f0:     	return new Submitter(display, ops, rand, maxW)
1:1b6c3f0: 		{
1:1b6c3f0: 			protected int mixType(final int chooseType)
1:1b6c3f0: 			{
1:1b6c3f0: 				return Submitter.ORDER_STATUS_BY_ID;
1:1b6c3f0: 			}
1:1b6c3f0: 		};  	
1:1b6c3f0:     }
1:1b6c3f0:     /**
1:1b6c3f0:      * Return a Submitter than only executes order
1:1b6c3f0:      * status by name transactions.
1:1b6c3f0:      */
1:1b6c3f0:     public static Submitter orderStatusByNameOnly(Display display,
1:1b6c3f0:     		Operations ops, OERandom rand,
1:1b6c3f0:             short maxW)
1:1b6c3f0:     {
1:1b6c3f0:     	return new Submitter(display, ops, rand, maxW)
1:1b6c3f0: 		{
1:1b6c3f0: 			protected int mixType(final int chooseType)
1:1b6c3f0: 			{
1:1b6c3f0: 				return Submitter.ORDER_STATUS_BY_NAME;
1:1b6c3f0: 			}
1:1b6c3f0: 		};  	
1:1b6c3f0:     }    
1:1b6c3f0:     /**
1:1b6c3f0:      * Return a Submitter than only executes payment
1:1b6c3f0:      * by identifier transactions.
1:1b6c3f0:      */
1:1b6c3f0:     public static Submitter paymentByIdOnly(Display display,
1:1b6c3f0:     		Operations ops, OERandom rand,
1:1b6c3f0:             short maxW)
1:1b6c3f0:     {
1:1b6c3f0:     	return new Submitter(display, ops, rand, maxW)
1:1b6c3f0: 		{
1:1b6c3f0: 			protected int mixType(final int chooseType)
1:1b6c3f0: 			{
1:1b6c3f0: 				return Submitter.PAYMENT_BY_ID;
1:1b6c3f0: 			}
1:1b6c3f0: 		};  	
1:1b6c3f0:     }
1:1b6c3f0:     /**
1:1b6c3f0:      * Return a Submitter than only executes payment
1:1b6c3f0:      * by name transactions.
1:1b6c3f0:      */
1:1b6c3f0:     public static Submitter paymentByNameOnly(Display display,
1:1b6c3f0:     		Operations ops, OERandom rand,
1:1b6c3f0:             short maxW)
1:1b6c3f0:     {
1:1b6c3f0:     	return new Submitter(display, ops, rand, maxW)
1:1b6c3f0: 		{
1:1b6c3f0: 			protected int mixType(final int chooseType)
1:1b6c3f0: 			{
1:1b6c3f0: 				return Submitter.PAYMENT_BY_NAME;
1:1b6c3f0: 			}
1:1b6c3f0: 		};  	
1:1b6c3f0:     }    
1:1b6c3f0:     /**
1:1b6c3f0:      * Return a Submitter than only executes new order
1:1b6c3f0:      * transactions with no rollback
1:1b6c3f0:      */
1:1b6c3f0:     public static Submitter newOrderOnly(Display display,
1:1b6c3f0:     		Operations ops, OERandom rand,
1:1b6c3f0:             short maxW)
1:1b6c3f0:     {
1:1b6c3f0:     	return new Submitter(display, ops, rand, maxW)
1:1b6c3f0: 		{
1:1b6c3f0: 			protected int mixType(final int chooseType)
1:1b6c3f0: 			{
1:1b6c3f0: 				return Submitter.NEW_ORDER;
1:1b6c3f0: 			}
1:1b6c3f0: 		};  	
1:1b6c3f0:     }        
1:1b6c3f0:     
1:1b6c3f0:     /**
1:1b6c3f0:      * Create a submitter that has a fixed mix of transactions
1:1b6c3f0:      * at input time.
1:1b6c3f0:      * 
1:1b6c3f0:      * @see Submitter#mixType(int)
1:1b6c3f0:      */
1:80570d6:     public Submitter(Display display, Operations ops, OERandom rand,
1:80570d6:             short maxW)
1:80570d6:     {
1:80570d6:         this.display = display;
1:80570d6:         this.ops = ops;
1:80570d6:         this.rand = rand;
1:80570d6:         this.maxW = maxW;
1:80570d6:         
1:80570d6:         transactionCount = new int[NEW_ORDER_ROLLBACK+1];
1:80570d6:     }
1:80570d6:     
1:80570d6:     /**
1:31ad846:      * Reset the transaction counts to zero.
1:31ad846:      */
1:31ad846:     public void clearTransactionCount()
1:31ad846:     {
1:31ad846:         Arrays.fill(transactionCount, 0);
1:31ad846:     }
1:31ad846:     
1:31ad846:     /**
1:76c452e:      * Run a fixed number of transactions returning the
1:76c452e:      * time in milli-seconds required to execute all of them.
1:76c452e:      * @param displayData Passed onto Display calls
1:76c452e:      * @param count Number of transactions to run
1:76c452e:      * @return Elapsed time in ms to run count transactions
1:76c452e:      * @throws Exception
1:76c452e:      */
1:76c452e:     public long runTransactions(final Object displayData, final int count)
1:76c452e:     throws Exception
1:76c452e:     {
1:76c452e:         long startms = System.currentTimeMillis();
1:76c452e:         for (int i = 0; i < count; i++)
1:76c452e:             runTransaction(displayData);
1:76c452e:         long endms = System.currentTimeMillis();
1:76c452e:         
1:76c452e:         return endms - startms;
1:76c452e:     }
1:76c452e:     
1:76c452e:     /**
1:80570d6:      * Run an order entry transaction picking the specific
1:80570d6:      * transaction at random with a hard-coded mix.
1:80570d6:      * @param displayData Passed onto Display calls
1:80570d6:      * @throws Exception Error executing the transaction
1:80570d6:      */
1:76c452e:     public void runTransaction(final Object displayData) throws Exception
1:80570d6:     {       
1:80570d6:         int chooseType = rand.randomInt(1, 100);
1:80570d6:         
1:80570d6:         int type = mixType(chooseType);
1:80570d6:         
1:80570d6:         switch (type)
1:80570d6:         {
1:80570d6:         case Submitter.DELIVERY_SCHEDULE:
1:80570d6:             runScheduleDelivery(displayData);
1:80570d6:             break;
1:80570d6:         case Submitter.NEW_ORDER:
1:80570d6:             runNewOrder(displayData, false);
1:80570d6:             break;
1:80570d6:         case Submitter.NEW_ORDER_ROLLBACK:
1:80570d6:             runNewOrder(displayData, true);
1:80570d6:             break;
1:80570d6:         case Submitter.ORDER_STATUS_BY_ID:
1:80570d6:             runOrderStatus(displayData, false);
1:80570d6:             break;
1:80570d6:         case Submitter.ORDER_STATUS_BY_NAME:
1:80570d6:             runOrderStatus(displayData, true);
1:80570d6:             break;
1:80570d6:         case Submitter.PAYMENT_BY_ID:
1:80570d6:             runPayment(displayData, false);
1:80570d6:             break;
1:80570d6:         case Submitter.PAYMENT_BY_NAME:
1:80570d6:             runPayment(displayData, true);
1:80570d6:             break;
1:80570d6:         case Submitter.STOCK_LEVEL:
1:80570d6:             runStockLevel(displayData);
1:80570d6:             break;
1:80570d6:         }
1:80570d6:         
1:80570d6:         transactionCount[type]++;
1:80570d6:     }
1:80570d6:     
1:80570d6:     /**
1:80570d6:      * Return one of transaction constants to run that transaction.
1:80570d6:      * This mix in not correct for TPC-C specification.
1:80570d6:      * With the official spec the final mix of transactions
1:80570d6:      * must match a certain profile. With this setup the
1:80570d6:      * mix is fixed upon input following the TPC-C final ratios.
1:80570d6:      * This will give approximately correct results, but the final
1:80570d6:      * mix will not be in line with TPC-C rules. This is because
1:80570d6:      * different transactions have different execution times.
1:80570d6:      * @param chooseType Random number between 1 and 100 inclusive.
1:80570d6:      * @return A transaction constant from this class.
1:80570d6:      */
1:76c452e:     protected int mixType(final int chooseType)
1:80570d6:     {
1:80570d6:         if (chooseType <= 43)
1:80570d6:         {
1:80570d6:             boolean byName = rand.randomInt(1, 100) <= 60;
1:80570d6:             return byName ?
1:80570d6:                 Submitter.PAYMENT_BY_NAME : Submitter.PAYMENT_BY_ID;       
1:80570d6:         }
1:80570d6:         else if (chooseType <= (43 + 4))
1:80570d6:         {
1:80570d6:             boolean byName = rand.randomInt(1, 100) <= 60;
1:80570d6:             return byName ?
1:80570d6:                 Submitter.ORDER_STATUS_BY_NAME : Submitter.ORDER_STATUS_BY_ID;
1:80570d6:         }
1:80570d6:         else if (chooseType <= (43 + 4 + 4))
1:80570d6:             return Submitter.DELIVERY_SCHEDULE;
1:80570d6:         else if (chooseType <= (43 + 4 + 4 + 4))
1:80570d6:             return Submitter.STOCK_LEVEL;
1:80570d6:         else
1:80570d6:         {
1:80570d6:             // 1% rollback
1:80570d6:             boolean rollback = rand.randomInt(1, 100) == 1;
1:80570d6:             return rollback ?
1:80570d6:                Submitter.NEW_ORDER_ROLLBACK : Submitter.NEW_ORDER;
1:80570d6:         }
1:80570d6:     }
1:80570d6:     
1:1b6c3f0:     protected void runNewOrder(Object displayData, boolean forRollback)
1:1b6c3f0:         throws Exception
1:1b6c3f0:    {
1:1b6c3f0:     	short homeWarehouse = warehouse();
1:1b6c3f0:     	
1:1b6c3f0:     	final int orderItemCount = rand.randomInt(5, 15);
1:1b6c3f0:     	
1:1b6c3f0:     	int[] items = new int[orderItemCount];
1:1b6c3f0:     	short[] quantities = new short[orderItemCount];
1:1b6c3f0:     	short[] supplyW = new short[orderItemCount];
1:1b6c3f0:     	
1:1b6c3f0:     	for (int i = 0; i < orderItemCount; i++)
1:1b6c3f0:     	{
1:1b6c3f0:     		// Section 2.4.1.5
1:1b6c3f0:     		
1:1b6c3f0:     		// 1)
1:1b6c3f0:     		items[i] = rand.NURand8191();
1:1b6c3f0:     		
1:1b6c3f0:     		// 2)
1:1b6c3f0:     		if (maxW == 1 || rand.randomInt(1, 100) > 1)
1:1b6c3f0:     		{
1:1b6c3f0:     			supplyW[i] = homeWarehouse;
1:1b6c3f0:     		}
1:1b6c3f0:     		else
1:1b6c3f0:     		{
1:1b6c3f0:     			short sw = warehouse();
1:1b6c3f0:     			while (sw == homeWarehouse)
1:1b6c3f0:     				sw = warehouse();
1:1b6c3f0:     			supplyW[i] = sw;
1:1b6c3f0:     		}
1:1b6c3f0:     		supplyW[i] = rand.randomInt(1, 100) > 1 ?
1:1b6c3f0:     				homeWarehouse : warehouse();
1:1b6c3f0:     		
1:1b6c3f0:     		// 3) 
1:1b6c3f0:     		quantities[i] = (short) rand.randomInt(1, 10);
1:1b6c3f0:     	}
1:1b6c3f0:     	
1:1b6c3f0:     	// Section 2.4.1.4
1:1b6c3f0:     	if (forRollback)
1:1b6c3f0:     	{
1:479ef91:     		items[orderItemCount - 1] = 2334432;
1:1b6c3f0:     	}
1:1b6c3f0:     	
1:1b6c3f0:         ops.newOrder(display, displayData,
1:1b6c3f0:         		homeWarehouse, rand.district(),
1:1b6c3f0:         		rand.NURand1023(),
1:1b6c3f0:         		items, quantities, supplyW);
1:1b6c3f0:         		
1:80570d6:     }
1:80570d6: 
1:80570d6:     protected void runScheduleDelivery(Object displayData) {
2:80570d6:         // TODO Auto-generated method stub
1:80570d6:     }
1:80570d6: 
1:80570d6:     /**
1:80570d6:      * Run a payment transaction with random input values.
1:80570d6:      */
1:80570d6:     protected void runPayment(Object displayData,
1:80570d6:             boolean byName) throws Exception {
1:80570d6:         
1:80570d6:         if (byName)
1:80570d6:         {
1:80570d6:             ops.payment(display, displayData,
1:80570d6:                     warehouse(), rand.district(),
1:80570d6:                     warehouse(), rand.district(),
1:80570d6:                     rand.randomCLast(), rand.payment().toString());
1:80570d6:         }
1:80570d6:         else
1:80570d6:         {
1:80570d6:             ops.payment(display, displayData,
1:80570d6:                 warehouse(), rand.district(),
1:80570d6:                 warehouse(), rand.district(),
1:80570d6:                 rand.NURand1023(), rand.payment().toString());
1:80570d6:         }
1:80570d6:      }
1:80570d6: 
1:80570d6:     /**
1:80570d6:      * Return a random warehouse
1:d5376da:      * @return a random warehouse
1:80570d6:      */
1:80570d6:     private final short warehouse() {
1:1b6c3f0:     	if (maxW == 1)
1:1b6c3f0:     		return 1;
1:80570d6:         return (short) rand.randomInt(1, maxW);
1:80570d6:     }
1:80570d6: 
1:80570d6:     /**
1:80570d6:      * Run a stock level transaction with random input values.
1:80570d6:      */
1:80570d6:     protected void runStockLevel(Object displayData) throws Exception
1:80570d6:     {
1:80570d6:         ops.stockLevel(display, displayData,
1:80570d6:                 warehouse(), rand.district(), rand.threshold());
1:80570d6:     }
1:80570d6:     
1:80570d6:     /**
1:80570d6:      * Run an order status transaction with random input values.
1:80570d6:      */
1:80570d6:     protected void runOrderStatus(Object displayData, boolean byName) throws Exception {
1:80570d6: 
1:80570d6:         if (byName)
1:80570d6:         {
1:80570d6:             ops.orderStatus(display, displayData,
1:80570d6:                     warehouse(), rand.district(), rand.randomCLast());
1:80570d6:         }
1:80570d6:         else
1:80570d6:         {
1:80570d6:             ops.orderStatus(display, displayData,
1:80570d6:                 warehouse(), rand.district(), rand.NURand1023());
1:80570d6:         }
1:80570d6: 
1:80570d6:     }
1:80570d6:     
1:80570d6:     /**
1:80570d6:      * Print a simple report of the activity.
1:80570d6:      * @param out
1:80570d6:      */
1:80570d6:     public void printReport(PrintStream out) {
1:80570d6:              
1:80570d6:         int total = 0;
1:80570d6:         for (int i = 0; i < transactionCount.length; i++)
1:80570d6:             total += transactionCount[i];
1:80570d6:         
1:80570d6:         out.println("Total Transactions: " + total);
1:80570d6:         
1:80570d6:         int noTotal = transactionCount[NEW_ORDER] +
1:80570d6:             transactionCount[NEW_ORDER_ROLLBACK];       
1:80570d6:         int pyCount = transactionCount[PAYMENT_BY_NAME] +
1:80570d6:             transactionCount[PAYMENT_BY_ID];
1:80570d6:         int osCount = transactionCount[ORDER_STATUS_BY_NAME] +
1:80570d6:             transactionCount[ORDER_STATUS_BY_ID];
1:80570d6: 
1:31ad846:         if (noTotal != 0)
1:31ad846:             out.println(transactionCount("New Order         ", noTotal, total));
1:80570d6:         
1:31ad846:         if (pyCount != 0) {
1:31ad846:             out.println(transactionCount("Payment           ",  pyCount, total));
1:31ad846:             out.println(transactionCount("    By Name       ",  transactionCount[PAYMENT_BY_NAME], total));
1:31ad846:             out.println(transactionCount("    By Identifier ",  transactionCount[PAYMENT_BY_ID], total));
1:31ad846:         }
1:31ad846:         
1:31ad846:         if (osCount != 0) {
1:31ad846:             out.println(transactionCount("Order Status      ",  osCount, total));
1:31ad846:             out.println(transactionCount("    By Name       ",  transactionCount[ORDER_STATUS_BY_NAME], total));
1:31ad846:             out.println(transactionCount("    By Identifier ",  transactionCount[ORDER_STATUS_BY_ID], total));
1:31ad846:         }
1:31ad846:         
1:31ad846:         if (transactionCount[STOCK_LEVEL] != 0)
1:31ad846:             out.println(transactionCount("Stock Level       ", 
1:80570d6:                 transactionCount[STOCK_LEVEL], total));
1:31ad846:         
1:31ad846:         if (transactionCount[DELIVERY_SCHEDULE] != 0)
1:31ad846:             out.println(transactionCount("Schedule Delivery ", 
1:80570d6:                 transactionCount[DELIVERY_SCHEDULE], total));
1:80570d6:     }
1:80570d6:     
1:80570d6:     private String transactionCount(String name, int count, int total) 
1:80570d6:     {
1:80570d6:         return name + " : " + percent(count, total) +
1:80570d6:            "(" + count + ")" ;
1:80570d6:         
1:80570d6:     }
1:80570d6:     
1:80570d6:     private String percent(int count, int total)
1:80570d6:     {
1:54b4e5f:         BigDecimal c = BigDecimal.valueOf((long) count * 100L);
1:54b4e5f:         BigDecimal t = BigDecimal.valueOf((long) total);
1:80570d6:         
1:4469400:         BigDecimal p = c.divide(t, 2, RoundingMode.DOWN);
1:80570d6:         
1:80570d6:         return p.toString().concat("%");
1:80570d6:     }
1:80570d6: 
1:80570d6:     /**
1:80570d6:      * Get the executed transaction counts.
1:80570d6:      * 
1:d5376da:      * @return transactionCount
1:80570d6:      */
1:80570d6:     public int[] getTransactionCount() {
1:80570d6:         return transactionCount;
1:80570d6:     }   
1:80570d6: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:4469400
/////////////////////////////////////////////////////////////////////////
1: import java.math.RoundingMode;
/////////////////////////////////////////////////////////////////////////
1:         BigDecimal p = c.divide(t, 2, RoundingMode.DOWN);
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:54b4e5f
/////////////////////////////////////////////////////////////////////////
1:         BigDecimal c = BigDecimal.valueOf((long) count * 100L);
1:         BigDecimal t = BigDecimal.valueOf((long) total);
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:479ef91
/////////////////////////////////////////////////////////////////////////
1:     		items[orderItemCount - 1] = 2334432;
commit:31ad846
/////////////////////////////////////////////////////////////////////////
1: import java.util.Arrays;
/////////////////////////////////////////////////////////////////////////
1:      * Reset the transaction counts to zero.
1:      */
1:     public void clearTransactionCount()
1:     {
1:         Arrays.fill(transactionCount, 0);
1:     }
1:     
1:     /**
/////////////////////////////////////////////////////////////////////////
1:         if (noTotal != 0)
1:             out.println(transactionCount("New Order         ", noTotal, total));
1:         if (pyCount != 0) {
1:             out.println(transactionCount("Payment           ",  pyCount, total));
1:             out.println(transactionCount("    By Name       ",  transactionCount[PAYMENT_BY_NAME], total));
1:             out.println(transactionCount("    By Identifier ",  transactionCount[PAYMENT_BY_ID], total));
1:         }
1:         
1:         if (osCount != 0) {
1:             out.println(transactionCount("Order Status      ",  osCount, total));
1:             out.println(transactionCount("    By Name       ",  transactionCount[ORDER_STATUS_BY_NAME], total));
1:             out.println(transactionCount("    By Identifier ",  transactionCount[ORDER_STATUS_BY_ID], total));
1:         }
1:         
1:         if (transactionCount[STOCK_LEVEL] != 0)
1:             out.println(transactionCount("Stock Level       ", 
1:         
1:         if (transactionCount[DELIVERY_SCHEDULE] != 0)
1:             out.println(transactionCount("Schedule Delivery ", 
commit:183bfa5
/////////////////////////////////////////////////////////////////////////
1:      * @return rand number generator
commit:1b6c3f0
/////////////////////////////////////////////////////////////////////////
0:      * @return
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Return a Submitter than only executes stock level transactions.
1:      */
1:     public static Submitter stockLevelOnly(Display display,
1:     		Operations ops, OERandom rand,
1:             short maxW)
1:     {
1:     	return new Submitter(display, ops, rand, maxW)
1: 		{
1: 			protected int mixType(final int chooseType)
1: 			{
1: 				return Submitter.STOCK_LEVEL;
1: 			}
1: 		};  	
1:     }
1:     /**
1:      * Return a Submitter than only executes order
1:      * status by identifier transactions.
1:      */
1:     public static Submitter orderStatusByIdOnly(Display display,
1:     		Operations ops, OERandom rand,
1:             short maxW)
1:     {
1:     	return new Submitter(display, ops, rand, maxW)
1: 		{
1: 			protected int mixType(final int chooseType)
1: 			{
1: 				return Submitter.ORDER_STATUS_BY_ID;
1: 			}
1: 		};  	
1:     }
1:     /**
1:      * Return a Submitter than only executes order
1:      * status by name transactions.
1:      */
1:     public static Submitter orderStatusByNameOnly(Display display,
1:     		Operations ops, OERandom rand,
1:             short maxW)
1:     {
1:     	return new Submitter(display, ops, rand, maxW)
1: 		{
1: 			protected int mixType(final int chooseType)
1: 			{
1: 				return Submitter.ORDER_STATUS_BY_NAME;
1: 			}
1: 		};  	
1:     }    
1:     /**
1:      * Return a Submitter than only executes payment
1:      * by identifier transactions.
1:      */
1:     public static Submitter paymentByIdOnly(Display display,
1:     		Operations ops, OERandom rand,
1:             short maxW)
1:     {
1:     	return new Submitter(display, ops, rand, maxW)
1: 		{
1: 			protected int mixType(final int chooseType)
1: 			{
1: 				return Submitter.PAYMENT_BY_ID;
1: 			}
1: 		};  	
1:     }
1:     /**
1:      * Return a Submitter than only executes payment
1:      * by name transactions.
1:      */
1:     public static Submitter paymentByNameOnly(Display display,
1:     		Operations ops, OERandom rand,
1:             short maxW)
1:     {
1:     	return new Submitter(display, ops, rand, maxW)
1: 		{
1: 			protected int mixType(final int chooseType)
1: 			{
1: 				return Submitter.PAYMENT_BY_NAME;
1: 			}
1: 		};  	
1:     }    
1:     /**
1:      * Return a Submitter than only executes new order
1:      * transactions with no rollback
1:      */
1:     public static Submitter newOrderOnly(Display display,
1:     		Operations ops, OERandom rand,
1:             short maxW)
1:     {
1:     	return new Submitter(display, ops, rand, maxW)
1: 		{
1: 			protected int mixType(final int chooseType)
1: 			{
1: 				return Submitter.NEW_ORDER;
1: 			}
1: 		};  	
1:     }        
1:     
1:     /**
1:      * Create a submitter that has a fixed mix of transactions
1:      * at input time.
1:      * 
1:      * @see Submitter#mixType(int)
1:      */
/////////////////////////////////////////////////////////////////////////
1:     protected void runNewOrder(Object displayData, boolean forRollback)
1:         throws Exception
1:    {
1:     	short homeWarehouse = warehouse();
1:     	
1:     	final int orderItemCount = rand.randomInt(5, 15);
1:     	
1:     	int[] items = new int[orderItemCount];
1:     	short[] quantities = new short[orderItemCount];
1:     	short[] supplyW = new short[orderItemCount];
1:     	
1:     	for (int i = 0; i < orderItemCount; i++)
1:     	{
1:     		// Section 2.4.1.5
1:     		
1:     		// 1)
1:     		items[i] = rand.NURand8191();
1:     		
1:     		// 2)
1:     		if (maxW == 1 || rand.randomInt(1, 100) > 1)
1:     		{
1:     			supplyW[i] = homeWarehouse;
1:     		}
1:     		else
1:     		{
1:     			short sw = warehouse();
1:     			while (sw == homeWarehouse)
1:     				sw = warehouse();
1:     			supplyW[i] = sw;
1:     		}
1:     		supplyW[i] = rand.randomInt(1, 100) > 1 ?
1:     				homeWarehouse : warehouse();
1:     		
1:     		// 3) 
1:     		quantities[i] = (short) rand.randomInt(1, 10);
1:     	}
1:     	
1:     	// Section 2.4.1.4
1:     	if (forRollback)
1:     	{
0:     		items[orderItemCount] = 2334432;
1:     	}
1:     	
1:         ops.newOrder(display, displayData,
1:         		homeWarehouse, rand.district(),
1:         		rand.NURand1023(),
1:         		items, quantities, supplyW);
1:         		
/////////////////////////////////////////////////////////////////////////
1:     	if (maxW == 1)
1:     		return 1;
/////////////////////////////////////////////////////////////////////////
0:         out.println(transactionCount("    By Name       ",  transactionCount[PAYMENT_BY_NAME], total));
0:         out.println(transactionCount("    By Identifier ",  transactionCount[PAYMENT_BY_ID], total));
commit:76c452e
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Connection;
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Generate a new random number generator
1:      * that follows the rules according to 2.1.6.1
1:      * @param conn
0:      * @return
1:      * @throws SQLException
1:      */
1:     public static OERandom getRuntimeRandom(Connection conn)
1:         throws SQLException
1:     {
1:         OERandom rand = new OERandom(-1);
1:         
1:         ResultSet rs = conn.createStatement().executeQuery(
1:                 "SELECT CLOAD FROM C");
1:         rs.next();
1:         int cload = rs.getInt(1);
1:         rs.close();
1:         
1:         for (;;)
1:         {
1:             int c = rand.randomInt(0, 255);
1:             int delta = Math.abs(cload - c);
1:             if (delta == 96 || delta == 112)
1:                 continue;
1:             if (delta < 65 || delta > 119)
1:                 continue;
1:             
1:             rand = new OERandom(c);
1:             break;
1:         }
1:         
1:         return rand;
1:     }
/////////////////////////////////////////////////////////////////////////
1:      * Run a fixed number of transactions returning the
1:      * time in milli-seconds required to execute all of them.
1:      * @param displayData Passed onto Display calls
1:      * @param count Number of transactions to run
1:      * @return Elapsed time in ms to run count transactions
1:      * @throws Exception
1:      */
1:     public long runTransactions(final Object displayData, final int count)
1:     throws Exception
1:     {
1:         long startms = System.currentTimeMillis();
1:         for (int i = 0; i < count; i++)
1:             runTransaction(displayData);
1:         long endms = System.currentTimeMillis();
1:         
1:         return endms - startms;
1:     }
1:     
1:     /**
1:     public void runTransaction(final Object displayData) throws Exception
/////////////////////////////////////////////////////////////////////////
1:     protected int mixType(final int chooseType)
commit:80570d6
/////////////////////////////////////////////////////////////////////////
1: /*
1:  *
1:  * Derby - Class org.apache.derbyTesting.system.oe.client.Submitter
1:  *
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *    http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, 
1:  * software distributed under the License is distributed on an 
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, 
1:  * either express or implied. See the License for the specific 
1:  * language governing permissions and limitations under the License.
1:  */
1: package org.apache.derbyTesting.system.oe.client;
1: 
1: import java.io.PrintStream;
1: import java.math.BigDecimal;
1: 
1: import org.apache.derbyTesting.system.oe.util.OERandom;
1: 
1: /**
1:  * Class that submits Order Entry transactions
1:  * to a database through an instance of an Operations class.
1:  * This class is responsible for the mix of transactions
1:  * and the generation of the random input values.
1:  * 
1:  * Sub-classes can override the mix.
1:  */
1: public class Submitter {
1:     
1:     /**
1:      * Offset of Stock Level transaction in returned
1:      * arrays with run information.
1:      */
1:     public static final int STOCK_LEVEL = 0;
1:     /**
1:      * Offset of Order Status by Name transaction in returned
1:      * arrays with run information.
1:      */    
1:     public static final int ORDER_STATUS_BY_NAME = 1;
1:     /**
1:      * Offset of Order Status by Id transaction in returned
1:      * arrays with run information.
1:      */
1:     public static final int ORDER_STATUS_BY_ID = 2;
1:     
1:      /**
1:       * Offset of Payment by Name transaction in returned
1:       * arrays with run information.
1:       */
1:     public static final int PAYMENT_BY_NAME = 3;
1:     
1:     /**
1:      * Offset of Payement by ID transaction in returned
1:      * arrays with run information.
1:      */
1:     public static final int PAYMENT_BY_ID = 4;
1:     
1:     /**
1:      * Offset of Delivery transaction in returned
1:      * arrays with run information.
1:      */
1:     public static final int DELIVERY_SCHEDULE = 5;
1:     
1:     /**
1:      * Offset of New Order transaction in returned
1:      * arrays with run information.
1:      */
1:     public static final int NEW_ORDER = 6;
1:     
1:     /**
1:      * Offset of New Order transaction that rolled back in returned
1:      * arrays with run information.
1:      */
1:     public static final int NEW_ORDER_ROLLBACK = 7;
1:     
1:     /**
1:      * Display to write the output to.
1:      */
1:     private final Display display;
1:     
1:     /**
1:      * How the business transactions are implemented.
1:      */
1:     private final Operations ops;
1:     
1:     /**
1:      * My own random number generator.
1:      */
1:     private final OERandom rand;
1:     
1:     /**
1:      * Scale of the database.
1:      */
1:     private final short maxW;
1:     
1:     /**
1:      * Record of how many transactions are implemented.
1:      */
1:     private final int[] transactionCount;
1: 
1:     public Submitter(Display display, Operations ops, OERandom rand,
1:             short maxW)
0:         throws Exception
1:     {
1:         this.display = display;
1:         this.ops = ops;
1:         this.rand = rand;
1:         this.maxW = maxW;
1:         
1:         transactionCount = new int[NEW_ORDER_ROLLBACK+1];
1:     }
1:     
1:     /**
1:      * Run an order entry transaction picking the specific
1:      * transaction at random with a hard-coded mix.
1:      * @param displayData Passed onto Display calls
1:      * @throws Exception Error executing the transaction
1:      */
0:     public void runTransaction(Object displayData) throws Exception
1:     {       
1:         int chooseType = rand.randomInt(1, 100);
1:         
1:         int type = mixType(chooseType);
1:         
1:         switch (type)
1:         {
1:         case Submitter.DELIVERY_SCHEDULE:
1:             runScheduleDelivery(displayData);
1:             break;
1:         case Submitter.NEW_ORDER:
1:             runNewOrder(displayData, false);
1:             break;
1:         case Submitter.NEW_ORDER_ROLLBACK:
1:             runNewOrder(displayData, true);
1:             break;
1:         case Submitter.ORDER_STATUS_BY_ID:
1:             runOrderStatus(displayData, false);
1:             break;
1:         case Submitter.ORDER_STATUS_BY_NAME:
1:             runOrderStatus(displayData, true);
1:             break;
1:         case Submitter.PAYMENT_BY_ID:
1:             runPayment(displayData, false);
1:             break;
1:         case Submitter.PAYMENT_BY_NAME:
1:             runPayment(displayData, true);
1:             break;
1:         case Submitter.STOCK_LEVEL:
1:             runStockLevel(displayData);
1:             break;
1:         }
1:         
1:         transactionCount[type]++;
1:     }
1:     
1:     /**
1:      * Return one of transaction constants to run that transaction.
1:      * This mix in not correct for TPC-C specification.
1:      * With the official spec the final mix of transactions
1:      * must match a certain profile. With this setup the
1:      * mix is fixed upon input following the TPC-C final ratios.
1:      * This will give approximately correct results, but the final
1:      * mix will not be in line with TPC-C rules. This is because
1:      * different transactions have different execution times.
1:      * @param chooseType Random number between 1 and 100 inclusive.
1:      * @return A transaction constant from this class.
1:      */
0:     protected int mixType(int chooseType)
1:     {
1:         if (chooseType <= 43)
1:         {
1:             boolean byName = rand.randomInt(1, 100) <= 60;
1:             return byName ?
1:                 Submitter.PAYMENT_BY_NAME : Submitter.PAYMENT_BY_ID;       
1:         }
1:         else if (chooseType <= (43 + 4))
1:         {
1:             boolean byName = rand.randomInt(1, 100) <= 60;
1:             return byName ?
1:                 Submitter.ORDER_STATUS_BY_NAME : Submitter.ORDER_STATUS_BY_ID;
1:         }
1:         else if (chooseType <= (43 + 4 + 4))
1:             return Submitter.DELIVERY_SCHEDULE;
1:         else if (chooseType <= (43 + 4 + 4 + 4))
1:             return Submitter.STOCK_LEVEL;
1:         else
1:         {
1:             // 1% rollback
1:             boolean rollback = rand.randomInt(1, 100) == 1;
1:             return rollback ?
1:                Submitter.NEW_ORDER_ROLLBACK : Submitter.NEW_ORDER;
1:         }
1:     }
1:     
0:     protected void runNewOrder(Object displayData, boolean forRollback) {
1:         // TODO Auto-generated method stub
1:     }
1: 
1:     protected void runScheduleDelivery(Object displayData) {
1:         // TODO Auto-generated method stub
1:     }
1: 
1:     /**
1:      * Run a payment transaction with random input values.
1:      */
1:     protected void runPayment(Object displayData,
1:             boolean byName) throws Exception {
1:         
1:         if (byName)
1:         {
1:             ops.payment(display, displayData,
1:                     warehouse(), rand.district(),
1:                     warehouse(), rand.district(),
1:                     rand.randomCLast(), rand.payment().toString());
1:         }
1:         else
1:         {
1:             ops.payment(display, displayData,
1:                 warehouse(), rand.district(),
1:                 warehouse(), rand.district(),
1:                 rand.NURand1023(), rand.payment().toString());
1:         }
1:      }
1: 
1:     /**
1:      * Return a random warehouse
0:      * @return
1:      */
1:     private final short warehouse() {
1:         return (short) rand.randomInt(1, maxW);
1:     }
1: 
1:     /**
1:      * Run a stock level transaction with random input values.
1:      */
1:     protected void runStockLevel(Object displayData) throws Exception
1:     {
1:         ops.stockLevel(display, displayData,
1:                 warehouse(), rand.district(), rand.threshold());
1:     }
1:     
1:     /**
1:      * Run an order status transaction with random input values.
1:      */
1:     protected void runOrderStatus(Object displayData, boolean byName) throws Exception {
1: 
1:         if (byName)
1:         {
1:             ops.orderStatus(display, displayData,
1:                     warehouse(), rand.district(), rand.randomCLast());
1:         }
1:         else
1:         {
1:             ops.orderStatus(display, displayData,
1:                 warehouse(), rand.district(), rand.NURand1023());
1:         }
1: 
1:     }
1:     
1:     /**
1:      * Print a simple report of the activity.
1:      * @param out
1:      */
1:     public void printReport(PrintStream out) {
1:              
1:         int total = 0;
1:         for (int i = 0; i < transactionCount.length; i++)
1:             total += transactionCount[i];
1:         
1:         out.println("Total Transactions: " + total);
1:         
1:         int noTotal = transactionCount[NEW_ORDER] +
1:             transactionCount[NEW_ORDER_ROLLBACK];       
1:         int pyCount = transactionCount[PAYMENT_BY_NAME] +
1:             transactionCount[PAYMENT_BY_ID];
1:         int osCount = transactionCount[ORDER_STATUS_BY_NAME] +
1:             transactionCount[ORDER_STATUS_BY_ID];
1: 
0:         out.println(transactionCount("New Order         ", noTotal, total));        
0:         out.println(transactionCount("Payment           ",  pyCount, total));
0:         out.println(transactionCount("Order Status      ",  osCount, total));
0:         out.println(transactionCount("    By Name       ",  transactionCount[ORDER_STATUS_BY_NAME], total));
0:         out.println(transactionCount("    By Identifier ",  transactionCount[ORDER_STATUS_BY_ID], total));
1:         
0:         out.println(transactionCount("Stock Level       ", 
1:                 transactionCount[STOCK_LEVEL], total));
0:         out.println(transactionCount("Schedule Delivery ", 
1:                 transactionCount[DELIVERY_SCHEDULE], total));
1:     }
1:     
1:     private String transactionCount(String name, int count, int total) 
1:     {
1:         return name + " : " + percent(count, total) +
1:            "(" + count + ")" ;
1:         
1:     }
1:     
1:     private String percent(int count, int total)
1:     {
0:         BigDecimal c = new BigDecimal((long) count * 100L);
0:         BigDecimal t = new BigDecimal((long) total);
1:         
0:         BigDecimal p = c.divide(t, 2, BigDecimal.ROUND_DOWN);
1:         
1:         return p.toString().concat("%");
1:     }
1: 
1:     /**
1:      * Get the executed transaction counts.
1:      * 
0:      * @return
1:      */
1:     public int[] getTransactionCount() {
1:         return transactionCount;
1:     }   
1: }
commit:454ea63
/////////////////////////////////////////////////////////////////////////
0: /*
0:  *
0:  * Derby - Class org.apache.derbyTesting.system.oe.client.Submitter
0:  *
0:  * Licensed to the Apache Software Foundation (ASF) under one or more
0:  * contributor license agreements.  See the NOTICE file distributed with
0:  * this work for additional information regarding copyright ownership.
0:  * The ASF licenses this file to You under the Apache License, Version 2.0
0:  * (the "License"); you may not use this file except in compliance with
0:  * the License.  You may obtain a copy of the License at
0:  *
0:  *    http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  * Unless required by applicable law or agreed to in writing, 
0:  * software distributed under the License is distributed on an 
0:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, 
0:  * either express or implied. See the License for the specific 
0:  * language governing permissions and limitations under the License.
0:  */
0: package org.apache.derbyTesting.system.oe.client;
0: 
0: import java.io.PrintStream;
0: import java.math.BigDecimal;
0: 
0: import org.apache.derbyTesting.system.oe.util.OERandom;
0: 
0: /**
0:  * Class that submits Order Entry transactions
0:  * to a database through an instance of an Operations class.
0:  * This class is responsible for the mix of transactions
0:  * and the generation of the random input values.
0:  * 
0:  * Sub-classes can override the mix.
0:  */
0: public class Submitter {
0:     
0:     /**
0:      * Offset of Stock Level transaction in returned
0:      * arrays with run information.
0:      */
0:     public static final int STOCK_LEVEL = 0;
0:     /**
0:      * Offset of Order Status by Name transaction in returned
0:      * arrays with run information.
0:      */    
0:     public static final int ORDER_STATUS_BY_NAME = 1;
0:     /**
0:      * Offset of Order Status by Id transaction in returned
0:      * arrays with run information.
0:      */
0:     public static final int ORDER_STATUS_BY_ID = 2;
0:     
0:      /**
0:       * Offset of Payment by Name transaction in returned
0:       * arrays with run information.
0:       */
0:     public static final int PAYMENT_BY_NAME = 3;
0:     
0:     /**
0:      * Offset of Payement by ID transaction in returned
0:      * arrays with run information.
0:      */
0:     public static final int PAYMENT_BY_ID = 4;
0:     
0:     /**
0:      * Offset of Delivery transaction in returned
0:      * arrays with run information.
0:      */
0:     public static final int DELIVERY_SCHEDULE = 5;
0:     
0:     /**
0:      * Offset of New Order transaction in returned
0:      * arrays with run information.
0:      */
0:     public static final int NEW_ORDER = 6;
0:     
0:     /**
0:      * Offset of New Order transaction that rolled back in returned
0:      * arrays with run information.
0:      */
0:     public static final int NEW_ORDER_ROLLBACK = 7;
0:     
0:     /**
0:      * Display to write the output to.
0:      */
0:     private final Display display;
0:     
0:     /**
0:      * How the business transactions are implemented.
0:      */
0:     private final Operations ops;
0:     
0:     /**
0:      * My own random number generator.
0:      */
0:     private final OERandom rand;
0:     
0:     /**
0:      * Scale of the database.
0:      */
0:     private final short maxW;
0:     
0:     /**
0:      * Record of how many transactions are implemented.
0:      */
0:     private final int[] transactionCount;
0: 
0:     public Submitter(Display display, Operations ops, OERandom rand,
0:             short maxW)
0:         throws Exception
0:     {
0:         this.display = display;
0:         this.ops = ops;
0:         this.rand = rand;
0:         this.maxW = maxW;
0:         
0:         transactionCount = new int[NEW_ORDER_ROLLBACK+1];
0:     }
0:     
0:     /**
0:      * Run an order entry transaction picking the specific
0:      * transaction at random with a hard-coded mix.
0:      * @param displayData Passed onto Display calls
0:      * @throws Exception Error executing the transaction
0:      */
0:     public void runTransaction(Object displayData) throws Exception
0:     {       
0:         int chooseType = rand.randomInt(1, 100);
0:         
0:         int type = mixType(chooseType);
0:         
0:         switch (type)
0:         {
0:         case Submitter.DELIVERY_SCHEDULE:
0:             runScheduleDelivery(displayData);
0:             break;
0:         case Submitter.NEW_ORDER:
0:             runNewOrder(displayData, false);
0:             break;
0:         case Submitter.NEW_ORDER_ROLLBACK:
0:             runNewOrder(displayData, true);
0:             break;
0:         case Submitter.ORDER_STATUS_BY_ID:
0:             runOrderStatus(displayData, false);
0:             break;
0:         case Submitter.ORDER_STATUS_BY_NAME:
0:             runOrderStatus(displayData, true);
0:             break;
0:         case Submitter.PAYMENT_BY_ID:
0:             runPayment(displayData, false);
0:             break;
0:         case Submitter.PAYMENT_BY_NAME:
0:             runPayment(displayData, true);
0:             break;
0:         case Submitter.STOCK_LEVEL:
0:             runStockLevel(displayData);
0:             break;
0:         }
0:         
0:         transactionCount[type]++;
0:     }
0:     
0:     /**
0:      * Return one of transaction constants to run that transaction.
0:      * This mix in not correct for TPC-C specification.
0:      * With the official spec the final mix of transactions
0:      * must match a certain profile. With this setup the
0:      * mix is fixed upon input following the TPC-C final ratios.
0:      * This will give approximately correct results, but the final
0:      * mix will not be in line with TPC-C rules. This is because
0:      * different transactions have different execution times.
0:      * @param chooseType Random number between 1 and 100 inclusive.
0:      * @return A transaction constant from this class.
0:      */
0:     protected int mixType(int chooseType)
0:     {
0:         if (chooseType <= 43)
0:         {
0:             boolean byName = rand.randomInt(1, 100) <= 60;
0:             return byName ?
0:                 Submitter.PAYMENT_BY_NAME : Submitter.PAYMENT_BY_ID;       
0:         }
0:         else if (chooseType <= (43 + 4))
0:         {
0:             boolean byName = rand.randomInt(1, 100) <= 60;
0:             return byName ?
0:                 Submitter.ORDER_STATUS_BY_NAME : Submitter.ORDER_STATUS_BY_ID;
0:         }
0:         else if (chooseType <= (43 + 4 + 4))
0:             return Submitter.DELIVERY_SCHEDULE;
0:         else if (chooseType <= (43 + 4 + 4 + 4))
0:             return Submitter.STOCK_LEVEL;
0:         else
0:         {
0:             // 1% rollback
0:             boolean rollback = rand.randomInt(1, 100) == 1;
0:             return rollback ?
0:                Submitter.NEW_ORDER_ROLLBACK : Submitter.NEW_ORDER;
0:         }
0:     }
0:     
0:     protected void runNewOrder(Object displayData, boolean forRollback) {
0:         // TODO Auto-generated method stub
0:     }
0: 
0:     protected void runScheduleDelivery(Object displayData) {
0:         // TODO Auto-generated method stub
0:     }
0: 
0:     /**
0:      * Run a payment transaction with random input values.
0:      */
0:     protected void runPayment(Object displayData,
0:             boolean byName) throws Exception {
0:         
0:         if (byName)
0:         {
0:             ops.payment(display, displayData,
0:                     warehouse(), rand.district(),
0:                     warehouse(), rand.district(),
0:                     rand.randomCLast(), rand.payment().toString());
0:         }
0:         else
0:         {
0:             ops.payment(display, displayData,
0:                 warehouse(), rand.district(),
0:                 warehouse(), rand.district(),
0:                 rand.NURand1023(), rand.payment().toString());
0:         }
0:      }
0: 
0:     /**
0:      * Return a random warehouse
0:      * @return
0:      */
0:     private final short warehouse() {
0:         return (short) rand.randomInt(1, maxW);
0:     }
0: 
0:     /**
0:      * Run a stock level transaction with random input values.
0:      */
0:     protected void runStockLevel(Object displayData) throws Exception
0:     {
0:         ops.stockLevel(display, displayData,
0:                 warehouse(), rand.district(), rand.threshold());
0:     }
0:     
0:     /**
0:      * Run an order status transaction with random input values.
0:      */
0:     protected void runOrderStatus(Object displayData, boolean byName) throws Exception {
0: 
0:         if (byName)
0:         {
0:             ops.orderStatus(display, displayData,
0:                     warehouse(), rand.district(), rand.randomCLast());
0:         }
0:         else
0:         {
0:             ops.orderStatus(display, displayData,
0:                 warehouse(), rand.district(), rand.NURand1023());
0:         }
0: 
0:     }
0:     
0:     /**
0:      * Print a simple report of the activity.
0:      * @param out
0:      */
0:     public void printReport(PrintStream out) {
0:              
0:         int total = 0;
0:         for (int i = 0; i < transactionCount.length; i++)
0:             total += transactionCount[i];
0:         
0:         out.println("Total Transactions: " + total);
0:         
0:         int noTotal = transactionCount[NEW_ORDER] +
0:             transactionCount[NEW_ORDER_ROLLBACK];       
0:         int pyCount = transactionCount[PAYMENT_BY_NAME] +
0:             transactionCount[PAYMENT_BY_ID];
0:         int osCount = transactionCount[ORDER_STATUS_BY_NAME] +
0:             transactionCount[ORDER_STATUS_BY_ID];
0: 
0:         out.println(transactionCount("New Order         ", noTotal, total));        
0:         out.println(transactionCount("Payment           ",  pyCount, total));
0:         out.println(transactionCount("Order Status      ",  osCount, total));
0:         out.println(transactionCount("    By Name       ",  transactionCount[ORDER_STATUS_BY_NAME], total));
0:         out.println(transactionCount("    By Identifier ",  transactionCount[ORDER_STATUS_BY_ID], total));
0:         
0:         out.println(transactionCount("Stock Level       ", 
0:                 transactionCount[STOCK_LEVEL], total));
0:         out.println(transactionCount("Schedule Delivery ", 
0:                 transactionCount[DELIVERY_SCHEDULE], total));
0:     }
0:     
0:     private String transactionCount(String name, int count, int total) 
0:     {
0:         return name + " : " + percent(count, total) +
0:            "(" + count + ")" ;
0:         
0:     }
0:     
0:     private String percent(int count, int total)
0:     {
0:         BigDecimal c = new BigDecimal((long) count * 100L);
0:         BigDecimal t = new BigDecimal((long) total);
0:         
0:         BigDecimal p = c.divide(t, 2, BigDecimal.ROUND_DOWN);
0:         
0:         return p.toString().concat("%");
0:     }
0: 
0:     /**
0:      * Get the executed transaction counts.
0:      * 
0:      * @return
0:      */
0:     public int[] getTransactionCount() {
0:         return transactionCount;
0:     }   
0: }
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:c36dd38
/////////////////////////////////////////////////////////////////////////
0:      * @return random number generator
commit:d5376da
/////////////////////////////////////////////////////////////////////////
1:      * @return a random warehouse
/////////////////////////////////////////////////////////////////////////
1:      * @return transactionCount
============================================================================