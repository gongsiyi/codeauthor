1:fe77ca5: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.compile.StaticMethodCallNode
1:232d09a: 
1:2d37fd6:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2d37fd6:    contributor license agreements.  See the NOTICE file distributed with
1:2d37fd6:    this work for additional information regarding copyright ownership.
1:2d37fd6:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2d37fd6:    (the "License"); you may not use this file except in compliance with
1:2d37fd6:    the License.  You may obtain a copy of the License at
1:14d5f00: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:345de35: 
2:fe77ca5:  */
1:345de35: 
1:fe77ca5: package	org.apache.derby.impl.sql.compile;
114:fe77ca5: 
1:e1f49ca: import java.lang.reflect.Method;
1:fe77ca5: import java.lang.reflect.Modifier;
1:e33b8d8: import java.sql.ParameterMetaData;
1:f33fbaf: import java.util.List;
1:3bb140c: import org.apache.derby.catalog.AliasInfo;
1:3bb140c: import org.apache.derby.catalog.TypeDescriptor;
1:3bb140c: import org.apache.derby.catalog.types.RoutineAliasInfo;
1:3bb140c: import org.apache.derby.iapi.error.StandardException;
1:3bb140c: import org.apache.derby.iapi.reference.ClassName;
1:3bb140c: import org.apache.derby.iapi.reference.SQLState;
1:3bb140c: import org.apache.derby.iapi.services.classfile.VMOpcode;
1:3bb140c: import org.apache.derby.iapi.services.compiler.LocalField;
1:3bb140c: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1:2cf546d: import org.apache.derby.iapi.services.context.ContextManager;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:3bb140c: import org.apache.derby.iapi.sql.compile.CompilerContext;
1:69f8afa: import org.apache.derby.iapi.sql.compile.Visitor;
1:3bb140c: import org.apache.derby.iapi.sql.conn.Authorizer;
1:0c5bc3a: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1:3bb140c: import org.apache.derby.iapi.sql.dictionary.AliasDescriptor;
1:3bb140c: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
1:3bb140c: import org.apache.derby.iapi.types.DataTypeDescriptor;
1:3bb140c: import org.apache.derby.iapi.types.JSQLType;
1:3bb140c: import org.apache.derby.iapi.types.StringDataValue;
1:3bb140c: import org.apache.derby.iapi.types.TypeId;
1:3bb140c: import org.apache.derby.iapi.util.JBitSet;
1:fe77ca5: 
1:065a81f: /**
1:fe77ca5:  * A StaticMethodCallNode represents a static method call from a Class
1:fe77ca5:  * (as opposed to from an Object).
1:fe77ca5: 
1:fe77ca5:    For a procedure the call requires that the arguments be ? parameters.
1:fe77ca5:    The parameter is *logically* passed into the method call a number of different ways.
1:fe77ca5: 
1:fe77ca5:    <P>
1:fe77ca5:    For a application call like CALL MYPROC(?) the logically Java method call is
1:fe77ca5:    (in psuedo Java/SQL code) (examples with CHAR(10) parameter)
1:fe77ca5:    <BR>
1:fe77ca5:    Fixed length IN parameters - com.acme.MyProcedureMethod(?)
1:fe77ca5:    <BR>
1:fe77ca5:    Variable length IN parameters - com.acme.MyProcedureMethod(CAST (? AS CHAR(10))
1:fe77ca5:    <BR>
1:fe77ca5:    Fixed length INOUT parameter -
1:fe77ca5: 		String[] holder = new String[] {?}; com.acme.MyProcedureMethod(holder); ? = holder[0]
1:fe77ca5:    <BR>
1:fe77ca5:    Variable length INOUT parameter -
1:fe77ca5: 		String[] holder = new String[] {CAST (? AS CHAR(10)}; com.acme.MyProcedureMethod(holder); ? = CAST (holder[0] AS CHAR(10))
1:fe77ca5: 
1:fe77ca5:    <BR>
1:fe77ca5:    Fixed length OUT parameter -
1:fe77ca5: 		String[] holder = new String[1]; com.acme.MyProcedureMethod(holder); ? = holder[0]
1:fe77ca5: 
1:fe77ca5:    <BR>
1:fe77ca5:    Variable length INOUT parameter -
1:fe77ca5: 		String[] holder = new String[1]; com.acme.MyProcedureMethod(holder); ? = CAST (holder[0] AS CHAR(10))
1:fe77ca5: 
1:fe77ca5: 
1:fe77ca5:     <P>
1:fe77ca5: 	For static method calls there is no pre-definition of an IN or INOUT parameter, so a call to CallableStatement.registerOutParameter()
1:fe77ca5: 	makes the parameter an INOUT parameter, provided:
1:fe77ca5: 		- the parameter is passed directly to the method call (no casts or expressions).
1:fe77ca5: 		- the method's parameter type is a Java array type.
1:fe77ca5: 
1:3bb140c:     Since this is a dynamic decision we compile in code to take both paths,
1:3bb140c:     based upon a boolean is INOUT which is derived from the
1:3bb140c:     ParameterValueSet. Code is logically (only single parameter String[] shown
1:3bb140c:     here). Note, no casts can exist here.
1:fe77ca5: 
1:fe77ca5: 	boolean isINOUT = getParameterValueSet().getParameterMode(0) == PARAMETER_IN_OUT;
1:fe77ca5: 	if (isINOUT) {
1:fe77ca5: 		String[] holder = new String[] {?}; com.acme.MyProcedureMethod(holder); ? = holder[0]
1:fe77ca5: 	   
1:fe77ca5: 	} else {
1:fe77ca5: 		com.acme.MyProcedureMethod(?)
1:14d5f00: 	}
1:fe77ca5: 
2:fe77ca5:  *
1:2cf546d:  */
1:3bb140c: class StaticMethodCallNode extends MethodCallNode
1:e604a71: {
1:fe77ca5: 	private TableName procedureName;
1:69f8afa: 
1:fe77ca5: 	private LocalField[] outParamArrays;
1:fe77ca5: 	private int[]		 applicationParameterNumbers; 
1:fe77ca5: 
1:fe77ca5: 	private boolean		isSystemCode;
1:065a81f: 
1:2cf546d:     /**
1:065a81f:      * This flag is true while bindExpression() is executing. It is used to
1:065a81f:      * avoid infinite recursion when bindExpression() is reentered.
1:065a81f:      */
1:065a81f:     private boolean isInsideBind;
1:fe77ca5: 
1:c8603c4:     /**
1:7d3ddb1:      * Generated boolean field to hold the indicator
1:7d3ddb1:      * for if any of the parameters to a
1:7d3ddb1:      * RETURNS NULL ON NULL INPUT function are NULL.
1:7d3ddb1:      * Only set if this node is calling such a function.
1:7d3ddb1:      * Set at generation time.
1:7d3ddb1:      */
1:fe77ca5: 	private LocalField	returnsNullOnNullState;
1:fe77ca5: 
1:9f60172:     /**
1:9f60172:      * Authorization id of user owning schema in which routine is defined.
1:9f60172:      */
1:9f60172:     private String routineDefiner = null;
1:fe77ca5: 
1:fe77ca5: 	AliasDescriptor	ad;
1:fe77ca5: 
1:c8603c4:     private AggregateNode   resolvedAggregate;
1:c8603c4: 
1:63e0910:     private boolean appearsInGroupBy = false;
1:63e0910: 
1:fe77ca5: 
1:7d3ddb1: 	/**
1:3bb140c:      * Constructor for a NonStaticMethodCallNode
1:c8603c4: 	 *
1:fe77ca5: 	 * @param methodName		The name of the method to call
1:3bb140c:      * @param javaClassName     The name of the java class that the static
1:3bb140c:      *                          method belongs to.
1:3bb140c:      * @param cm                The context manager
1:fe77ca5: 	 */
1:3bb140c:     StaticMethodCallNode(
1:3bb140c:             String methodName,
1:3bb140c:             String javaClassName,
1:3bb140c:             ContextManager cm) {
1:3bb140c:         super(methodName, cm);
1:3bb140c:         this.javaClassName = javaClassName;
1:3bb140c:     }
1:fe77ca5: 
1:3bb140c:     /**
1:3bb140c:      * Constructor for a StaticMethodCallNode
1:3bb140c:      *
1:3bb140c:      * @param methodName        The name of the method to call
1:3bb140c:      * @param javaClassName     The name of the java class that the static
1:3bb140c:      *                          method belongs to.
1:3bb140c:      * @param cm                The context manager
1:3bb140c:      */
1:3bb140c:     StaticMethodCallNode(
1:3bb140c:             TableName methodName,
1:3bb140c:             String javaClassName,
1:3bb140c:             ContextManager cm) {
1:3bb140c:         super(methodName.getTableName(), cm);
1:3bb140c:         procedureName = methodName;
1:3bb140c:         this.javaClassName = javaClassName;
1:3bb140c:     }
1:fe77ca5: 
2:fe77ca5:     /**
1:c8603c4:      * Get the aggregate, if any, which this method call resolves to.
1:c8603c4:      */
1:c8603c4:     public  AggregateNode   getResolvedAggregate() { return resolvedAggregate; }
1:63e0910: 
1:63e0910:     /** Flag that this function invocation appears in a GROUP BY clause */
1:63e0910:     public  void    setAppearsInGroupBy() { appearsInGroupBy = true; }
1:c8603c4:     
1:29007f0:     @Override
1:29007f0:     TableName getFullName()
1:29007f0: 	{
1:29007f0: 		return  procedureName;
1:29007f0: 	}
1:29007f0: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Bind this expression.  This means binding the sub-expressions,
1:fe77ca5: 	 * as well as figuring out what the return type is for this expression.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @param fromList		The FROM list for the query this
1:09c2697:      *                      expression is in, for binding columns.
1:09c2697:      * @param subqueryList  The subquery list being built as we find SubqueryNodes
1:09c2697:      * @param aggregates    The aggregate list being built as we find AggregateNodes
1:fe77ca5: 	 *
1:fe77ca5: 	 * @return	this or an AggregateNode
1:fe77ca5: 	 *
1:fe77ca5: 	 * @exception StandardException		Thrown on error
1:fe77ca5: 	 */
1:09c2697:     JavaValueNode bindExpression(
1:71c8e86:         FromList fromList, SubqueryList subqueryList, List<AggregateNode> aggregates)
1:2cf546d: 			throws StandardException
1:2cf546d: 	{
1:fe77ca5: 		// for a function we can get called recursively
1:065a81f:         if (isInsideBind) {
1:065a81f:             return this;
1:065a81f:         }
1:fe77ca5: 
1:065a81f:         isInsideBind = true;
1:065a81f:         try {
1:065a81f:             return bindExpressionMinion(fromList, subqueryList, aggregates);
1:065a81f:         } finally {
1:065a81f:             isInsideBind = false;
1:065a81f:         }
1:065a81f:     }
1:fe77ca5: 
1:065a81f:     private JavaValueNode bindExpressionMinion(
1:065a81f:             FromList fromList,
1:065a81f:             SubqueryList subqueryList,
1:065a81f:             List<AggregateNode> aggregates)
1:065a81f:         throws StandardException
1:c8603c4:     {
1:09c2697:         bindParameters(fromList, subqueryList, aggregates);
1:fe77ca5: 
1:fe77ca5: 		
1:fe77ca5: 		/* If javaClassName is null then we assume that the current methodName
1:fe77ca5: 		 * is an alias and we must go to sysmethods to
1:fe77ca5: 		 * get the real method and java class names for this alias.
1:fe77ca5: 		 */
1:fe77ca5: 		if (javaClassName == null)
1:065a81f: 		{
1:fe77ca5: 			CompilerContext cc = getCompilerContext();
1:fe77ca5: 
1:fe77ca5: 			// look for a routine
1:fe77ca5: 
1:e604a71: 			String schemaName = procedureName.getSchemaName();
1:e604a71: 								
1:e604a71: 			boolean noSchema = schemaName == null;
1:14d5f00: 
1:e604a71: 			SchemaDescriptor sd = getSchemaDescriptor(schemaName, schemaName != null);
1:e604a71: 
1:e604a71:             // The field methodName is used by resolveRoutine and
1:e604a71:             // is set to the name of the routine (procedureName.getTableName()).
1:2782d72:             resolveRoutine( fromList, subqueryList, aggregates, sd, noSchema );
1:95a483d: 
1:c8603c4:             if ( (ad != null) && (ad.getAliasType() == AliasInfo.ALIAS_TYPE_AGGREGATE_AS_CHAR) )
1:c8603c4:             {
1:3bb140c:                 resolvedAggregate = new AggregateNode(
1:c8603c4:                      ((SQLToJavaValueNode) methodParms[ 0 ]).getSQLValueNode(),
1:c8603c4:                      new UserAggregateDefinition( ad ), 
1:0cefeda:                      procedureName,
1:3bb140c:                      false,
1:c8603c4:                      ad.getJavaClassName(),
2:232d09a:                      getContextManager()
1:2cf546d:                      );
1:c8603c4: 
1:070d37e:                 // Propagate tags used to flag nodes which need privilege checks. See DERBY-6429.
1:070d37e:                 resolvedAggregate.copyTagsFrom( this );
1:070d37e: 
1:63e0910:                 // The parser may have noticed that this aggregate is invoked in a
1:63e0910:                 // GROUP BY clause. That is not allowed.
1:63e0910:                 if ( appearsInGroupBy )
1:63e0910:                 {
1:63e0910:                     throw StandardException.newException(SQLState.LANG_AGGREGATE_IN_GROUPBY_LIST);
1:63e0910:                 }
1:63e0910:                 
1:c8603c4:                 return this;
1:c8603c4:             }
1:c8603c4: 
1:946f53d:             SchemaDescriptor savedSd = sd;
1:946f53d: 
1:946f53d:             if (ad == null && noSchema && !forCallStatement)
1:946f53d:             {
1:946f53d:                 // Resolve to a built-in SYSFUN function but only
1:946f53d:                 // if this is a function call and the call
1:946f53d:                 // was not qualified. E.g. COS(angle). The
1:946f53d:                 // SYSFUN functions are not in SYSALIASES but
1:946f53d:                 // an in-memory table, set up in DataDictioanryImpl.
1:946f53d:                 sd = getSchemaDescriptor("SYSFUN", true);
1:946f53d: 
1:2782d72:                 resolveRoutine(fromList, subqueryList, aggregates, sd, noSchema);
1:946f53d:             }
1:946f53d: 
1:946f53d:             if (ad == null) {
1:946f53d:                 // DERBY-2927. Check if a procedure is being used as a
1:946f53d:                 // function, or vice versa.
1:946f53d:                 sd = savedSd;
1:946f53d: 
1:946f53d:                 if (!forCallStatement) {
1:946f53d:                     // Procedure as function. We have JDBC escape syntax which
1:946f53d:                     // may entice users to try that:
1:946f53d:                     //      "{? = CALL <proc>}"
1:946f53d:                     //
1:946f53d:                     // but we don't currently support it (it's not std SQL
1:946f53d:                     // either). By resolving it as a procedure we can give a
1:946f53d:                     // better error message.
1:946f53d:                     //
1:946f53d:                     // Note that with the above escape syntax one *can* CALL a
1:946f53d:                     // function, though:
1:946f53d:                     //      "{? = CALL <func>}"
1:946f53d:                     //
1:946f53d:                     // but such cases have already been resolved above.
1:946f53d: 
1:946f53d:                     forCallStatement = true; // temporarily: resolve
1:946f53d:                                              // as procedure
1:2782d72:                     resolveRoutine(fromList, subqueryList, aggregates, sd, noSchema);
1:946f53d:                     forCallStatement = false; // restore it
1:946f53d: 
1:946f53d:                     if (ad != null) {
1:946f53d:                         throw StandardException.newException
1:946f53d:                             (SQLState.LANG_PROC_USED_AS_FUNCTION,
1:946f53d:                              procedureName);
1:946f53d:                     }
1:946f53d:                 } else {
1:946f53d:                     // Maybe a function is being CALLed ?
1:946f53d:                     forCallStatement = false; // temporarily: resolve
1:946f53d:                                               // as function
1:2782d72:                     resolveRoutine(fromList, subqueryList, aggregates, sd, noSchema);
1:946f53d:                     forCallStatement = true; // restore it
1:946f53d: 
1:946f53d:                     if (ad != null) {
1:946f53d:                         throw StandardException.newException
1:946f53d:                             (SQLState.LANG_FUNCTION_USED_AS_PROC,
1:946f53d:                              procedureName);
1:946f53d:                     }
1:946f53d:                 }
1:946f53d:             }
1:946f53d: 
1:e604a71: 			/* Throw exception if no routine found */
1:fe77ca5: 			if (ad == null)
1:14d5f00: 			{
1:e604a71: 				throw StandardException.newException(
1:e604a71:                         SQLState.LANG_NO_SUCH_METHOD_ALIAS, procedureName);
1:14d5f00: 			}
1:9d9f6dd: 
1:9d9f6dd:             if (noSchema) {
1:9d9f6dd:                 // If no schema was specified, register where we found the
1:9d9f6dd:                 // routine.
1:9d9f6dd:                 procedureName.setSchemaName(sd.getSchemaName());
1:9d9f6dd:             }
1:9d9f6dd: 
1:95a483d:             if ( !routineInfo.isDeterministic() )
1:95a483d:             {
1:95a483d:                 checkReliability( getMethodName(), CompilerContext.NON_DETERMINISTIC_ILLEGAL );
1:95a483d:             }
1:5a0cfa2:             if ( permitsSQL( routineInfo ) )
1:5a0cfa2:             {
1:5a0cfa2:                 checkReliability( getMethodName(), CompilerContext.SQL_IN_ROUTINES_ILLEGAL );
1:5a0cfa2:             }
1:95a483d: 			
1:e604a71: 
1:14d5f00: 
1:fe77ca5: 			/* Query is dependent on the AliasDescriptor */
1:fe77ca5: 			cc.createDependency(ad);
1:14d5f00: 
1:14d5f00: 
1:fe77ca5: 			methodName = ad.getAliasInfo().getMethodName();
1:fe77ca5: 			javaClassName = ad.getJavaClassName();
1:e604a71:             
1:e604a71:             // DERBY-2330 Do not allow a routine to resolve to
1:e604a71:             // a Java method that is part of the Derby runtime code base.
1:e604a71:             // This is a security measure to stop user-defined routines
1:e604a71:             // bypassing security by making calls directly to Derby's
1:e604a71:             // internal methods. E.g. open a table's conglomerate
1:e604a71:             // directly and read the file, bypassing any authorization.
1:e604a71:             // This is a simpler mechanism than analyzing all of
1:e604a71:             // Derby's public static methods and ensuring they have
1:e604a71:             // no Security holes.
1:ea335da:             //
1:ea335da:             // A special exception is made for the optional tools methods.
1:ea335da:             if (
1:ea335da:                 javaClassName.startsWith( "org.apache.derby." ) &&
1:e081c85:                 !javaClassName.startsWith( "org.apache.derby.impl.tools.optional." ) &&
1:fbf176c:                 !javaClassName.startsWith( "org.apache.derby.optional.lucene." ) &&
1:2c38f3c:                 !javaClassName.startsWith( "org.apache.derby.optional.json." ) &&
1:515a63e:                 !javaClassName.startsWith( "org.apache.derby.optional.api." ) &&
1:28c4dc4:                 !javaClassName.startsWith( "org.apache.derby.optional.dump." ) &&
1:e081c85:                 !javaClassName.startsWith( "org.apache.derby.vti." )
1:ea335da:                 )
1:e604a71:             {
1:e604a71:                 if (!sd.isSystemSchema())
1:e604a71:                     throw StandardException.newException(
1:e604a71:                         SQLState.LANG_TYPE_DOESNT_EXIST2, (Throwable) null,
1:e604a71:                         javaClassName);
1:e604a71:             }
1:14d5f00: 		}
1:14d5f00: 
1:2e1b5e8: 		verifyClassExist(javaClassName);
1:fe77ca5: 
1:fe77ca5: 		/* Resolve the method call */
1:232d09a: 		resolveMethodCall( javaClassName, true );
1:fe77ca5: 
1:fe77ca5: 
1:2d2e717: 		if (isPrivilegeCollectionRequired())
1:2d2e717: 			getCompilerContext().addRequiredRoutinePriv(ad);
1:fe77ca5: 
1:fe77ca5: 		// If this is a function call with a variable length
1:fe77ca5: 		// return type, then we need to push a CAST node.
1:fe77ca5: 		if (routineInfo != null)
1:14d5f00: 		{
1:3905037: 			if (methodParms != null) 
1:3905037: 				optimizeDomainValueConversion();
1:3905037: 			
1:fe77ca5: 			TypeDescriptor returnType = routineInfo.getReturnType();
1:d6c2047: 
1:d6c2047:             // create type dependency if return type is an ANSI UDT
1:d6c2047:             if ( returnType != null ) { createTypeDependency( DataTypeDescriptor.getType( returnType ) ); }
1:d6c2047: 
1:d039ced: 			if ( returnType != null && !returnType.isRowMultiSet() && !returnType.isUserDefinedType() )
1:14d5f00: 			{
1:fe77ca5: 				TypeId returnTypeId = TypeId.getBuiltInTypeId(returnType.getJDBCTypeId());
1:fe77ca5: 
1:fe77ca5: 				if (returnTypeId.variableLength()) {
1:fe77ca5: 					// Cast the return using a cast node, but have to go
1:fe77ca5: 					// into the SQL domain, and back to the Java domain.
1:fe77ca5: 
1:fe77ca5: 					DataTypeDescriptor returnValueDtd = new DataTypeDescriptor(
1:fe77ca5: 								returnTypeId,
1:fe77ca5: 								returnType.getPrecision(),
1:fe77ca5: 								returnType.getScale(),
1:fe77ca5: 								returnType.isNullable(),
1:fe77ca5: 								returnType.getMaximumWidth()
1:c8603c4: 							);
1:9ed7c4d: 							
1:9ed7c4d: 
1:3bb140c:                     ValueNode returnValueToSQL =
1:3bb140c:                             new JavaToSQLValueNode(this, getContextManager());
1:fe77ca5: 
1:3bb140c:                     ValueNode returnValueCastNode = new CastNode(
1:fe77ca5: 									returnValueToSQL, 
1:fe77ca5: 									returnValueDtd,
3:14d5f00: 									getContextManager());
1:9ed7c4d:                     
1:72abc72:                     // DERBY-2972  Match the collation of the RoutineAliasInfo
1:9ed7c4d:                     returnValueCastNode.setCollationInfo(
1:9ed7c4d:                             returnType.getCollationType(),
1:9ed7c4d:                             StringDataValue.COLLATION_DERIVATION_IMPLICIT);
1:fe77ca5: 
1:3bb140c:                     JavaValueNode returnValueToJava = new SQLToJavaValueNode(
1:3bb140c:                             returnValueCastNode, getContextManager());
1:72abc72: 					returnValueToJava.setCollationType(returnType.getCollationType());
1:09c2697:                     return returnValueToJava.bindExpression(fromList, subqueryList, aggregates);
1:14d5f00: 				}
1:fe77ca5: 
43:fe77ca5: 			}
1:fe77ca5: 		}
1:fe77ca5: 
2:fe77ca5: 		return this;
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:5a0cfa2: 	 * Returns true if the routine permits SQL.
1:5a0cfa2: 	 */
1:5a0cfa2:     private boolean permitsSQL( RoutineAliasInfo rai )
1:5a0cfa2:     {
1:5a0cfa2:         short       sqlAllowed = rai.getSQLAllowed();
1:5a0cfa2: 
1:5a0cfa2:         switch( sqlAllowed )
1:5a0cfa2:         {
1:5a0cfa2:         case RoutineAliasInfo.MODIFIES_SQL_DATA:
1:5a0cfa2:         case RoutineAliasInfo.READS_SQL_DATA:
1:5a0cfa2:         case RoutineAliasInfo.CONTAINS_SQL:
1:5a0cfa2:             return true;
1:5a0cfa2: 
1:5a0cfa2:         default:    return false;
1:5a0cfa2:         }
1:5a0cfa2:     }
1:5a0cfa2:     
1:5a0cfa2: 	/**
1:3905037: 	 * If this SQL function has parameters which are SQLToJavaValueNode over
1:3905037: 	 * JavaToSQLValueNode and the java value node underneath is a SQL function
1:3905037: 	 * defined with CALLED ON NULL INPUT, then we can get rid of the wrapper
1:3905037: 	 * nodes over the java value node for such parameters. This is because
1:3905037: 	 * SQL functions defined with CALLED ON NULL INPUT need access to only
1:3905037: 	 * java domain values.
1:3905037: 	 * This can't be done for parameters which are wrappers over SQL function
1:3905037: 	 * defined with RETURN NULL ON NULL INPUT because such functions need
1:3905037: 	 * access to both sql domain value and java domain value. - Derby479
1:ec60795:      * This optimization is not available if the outer function is
1:ec60795: 	 * RETURN NULL ON NULL INPUT. That is because the SQLToJavaNode is
1:ec60795: 	 * responsible for compiling the byte code which skips the method call if
1:ec60795:      * the parameter is null--if we remove the SQLToJavaNode, then we don't
1:ec60795:      * compile that check and we get bug DERBY-1030.
1:3905037: 	 */
1:3905037: 	private void optimizeDomainValueConversion() throws StandardException {
1:ec60795: 
1:ec60795:         //
1:ec60795:         // This optimization is not possible if we are compiling a call to
1:ec60795:         // a NULL ON NULL INPUT method. See DERBY-1030 and the header
1:ec60795:         // comment above.
1:ec60795:         //
1:ec60795:         if ( !routineInfo.calledOnNullInput() ) { return; }
1:ec60795:         
1:3905037: 		int		count = methodParms.length;
1:3905037: 		for (int parm = 0; parm < count; parm++)
1:3905037: 		{
1:aec2537:             //
1:aec2537:             // We also skip the optimization if the argument must be cast to a primitive. In this case we need
1:aec2537:             // a runtime check to make sure that the argument is not null. See DERBY-4459.
1:aec2537:             //
1:aec2537:             if ( (methodParms != null) && methodParms[ parm ].mustCastToPrimitive() ) { continue; }
1:aec2537:             
1:3905037: 			if (methodParms[parm] instanceof SQLToJavaValueNode &&
1:3905037: 				((SQLToJavaValueNode)methodParms[parm]).getSQLValueNode() instanceof
1:3905037: 				JavaToSQLValueNode)
1:3905037: 			{
1:3905037: 				//If we are here, then it means that the parameter is
1:3905037: 				//SQLToJavaValueNode on top of JavaToSQLValueNode
1:3905037: 				JavaValueNode paramIsJavaValueNode =
1:3905037: 					((JavaToSQLValueNode)((SQLToJavaValueNode)methodParms[parm]).getSQLValueNode()).getJavaValueNode();
1:3905037: 				if (paramIsJavaValueNode instanceof StaticMethodCallNode)
1:3905037: 				{
1:3905037: 					//If we are here, then it means that the parameter has
1:3905037: 					//a MethodCallNode underneath it.
1:3905037: 					StaticMethodCallNode paramIsMethodCallNode = (StaticMethodCallNode)paramIsJavaValueNode;
1:3905037: 					//If the MethodCallNode parameter is defined as
1:3905037: 					//CALLED ON NULL INPUT, then we can remove the wrappers
1:3905037: 					//for the param and just set the parameter to the
1:3905037: 					//java value node.
1:3905037: 					if (paramIsMethodCallNode.routineInfo != null &&
1:3905037: 							paramIsMethodCallNode.routineInfo.calledOnNullInput())
1:3905037: 						methodParms[parm] =
1:3905037: 							((JavaToSQLValueNode)((SQLToJavaValueNode)methodParms[parm]).getSQLValueNode()).getJavaValueNode();
1:3905037: 				}
1:3905037: 			}
1:3905037: 		}
1:3905037: 	}
1:3905037: 
1:3905037: 	/**
1:14d5f00: 	 * Resolve a routine. Obtain a list of routines from the data dictionary
1:14d5f00: 	 * of the correct type (functions or procedures) and name.
1:14d5f00: 	 * Pick the best routine from the list. Currently only a single routine
1:14d5f00: 	 * with a given type and name is allowed, thus if changes are made to
1:14d5f00: 	 * support overloaded routines, careful code inspection and testing will
1:14d5f00: 	 * be required.
1:14d5f00: 	 */
1:f33fbaf:     private void resolveRoutine(FromList fromList, SubqueryList subqueryList,
1:2782d72:                                 List<AggregateNode> aggregates, SchemaDescriptor sd,
1:2782d72:                                 boolean noSchema)
1:f33fbaf:             throws StandardException {
1:14d5f00: 		if (sd.getUUID() != null) {
1:14d5f00: 
1:3bb140c:         List<AliasDescriptor> list = getDataDictionary().getRoutineList(
1:3bb140c:             sd.getUUID().toString(),
1:3bb140c:             methodName,
1:3bb140c:             forCallStatement ?
1:3bb140c:                 AliasInfo.ALIAS_NAME_SPACE_PROCEDURE_AS_CHAR :
1:3bb140c:                 AliasInfo.ALIAS_NAME_SPACE_FUNCTION_AS_CHAR);
1:14d5f00: 
1:14d5f00: 		for (int i = list.size() - 1; i >= 0; i--) {
1:14d5f00: 
1:3bb140c:             AliasDescriptor proc = list.get(i);
1:14d5f00: 
1:615cb37: 			RoutineAliasInfo rai = (RoutineAliasInfo) proc.getAliasInfo();
1:615cb37: 			int parameterCount = rai.getParameterCount();
1:615cb37:             boolean hasVarargs = rai.hasVarargs();
1:14d5f00: 
1:232d09a:             if ( hasVarargs )
1:232d09a:             {
1:232d09a:                 // a varargs method can be called with no values supplied
1:232d09a:                 // for the trailing varargs argument
1:232d09a:                 if ( methodParms.length < (parameterCount - 1) ) { continue; }
1:232d09a:             }
1:232d09a: 			else if (parameterCount != methodParms.length)
1:232d09a:             { continue; }
1:14d5f00: 
1:14d5f00: 			// pre-form the method signature. If it is a dynamic result set procedure
1:14d5f00: 			// then we need to add in the ResultSet array
1:14d5f00: 
1:615cb37: 			TypeDescriptor[] parameterTypes = rai.getParameterTypes();
1:14d5f00: 
1:14d5f00: 			int sigParameterCount = parameterCount;
1:615cb37: 			if (rai.getMaxDynamicResultSets() > 0)
1:232d09a:             { sigParameterCount++; }
1:14d5f00: 
1:14d5f00: 			signature = new JSQLType[sigParameterCount];
1:14d5f00: 			for (int p = 0; p < parameterCount; p++) {
1:14d5f00: 
1:14d5f00: 				// find the declared type.
1:14d5f00: 
1:14d5f00: 				TypeDescriptor td = parameterTypes[p];
1:14d5f00: 
1:d039ced: 				TypeId typeId = TypeId.getTypeId(td);
1:14d5f00: 
1:14d5f00: 				TypeId parameterTypeId = typeId;
1:14d5f00: 
1:14d5f00: 
1:14d5f00: 				// if it's an OUT or INOUT parameter we need an array.
1:615cb37: 				int parameterMode = rai.getParameterModes()[ getRoutineArgIdx( rai, p ) ];
1:14d5f00: 
1:e33b8d8:                 if (parameterMode != (ParameterMetaData.parameterModeIn)) {
1:14d5f00: 
1:14d5f00: 					String arrayType;
1:14d5f00: 					switch (typeId.getJDBCTypeId()) {
1:4bad559: 						case java.sql.Types.BOOLEAN:
1:14d5f00: 						case java.sql.Types.SMALLINT:
1:14d5f00: 						case java.sql.Types.INTEGER:
1:14d5f00: 						case java.sql.Types.BIGINT:
1:14d5f00: 						case java.sql.Types.REAL:
1:14d5f00: 						case java.sql.Types.DOUBLE:
1:14d5f00: 							arrayType = getTypeCompiler(typeId).getCorrespondingPrimitiveTypeName().concat("[]");
1:14d5f00: 							break;
1:14d5f00: 						default:
1:14d5f00: 							arrayType = typeId.getCorrespondingJavaTypeName().concat("[]");
1:c8603c4: 							break;
1:c8603c4: 					}
1:c8603c4: 
1:bbd82de: 					typeId = TypeId.getUserDefinedTypeId(arrayType);
1:c8603c4: 				}
1:c8603c4: 
1:14d5f00: 				// this is the type descriptor of the require method parameter
1:14d5f00: 				DataTypeDescriptor methoddtd = new DataTypeDescriptor(
2:14d5f00: 						typeId,
1:14d5f00: 						td.getPrecision(),
1:14d5f00: 						td.getScale(),
1:14d5f00: 						td.isNullable(),
1:14d5f00: 						td.getMaximumWidth()
1:2cf546d: 					);
1:c8603c4: 
1:14d5f00: 				signature[p] = new JSQLType(methoddtd);
1:c8603c4: 
1:14d5f00: 				// this is the SQL type of the procedure parameter.
1:14d5f00: 				DataTypeDescriptor paramdtd = new DataTypeDescriptor(
1:14d5f00: 					parameterTypeId,
1:14d5f00: 					td.getPrecision(),
1:14d5f00: 					td.getScale(),
1:14d5f00: 					td.isNullable(),
1:14d5f00: 					td.getMaximumWidth()
4:14d5f00: 				);
1:14d5f00: 
1:232d09a:                 //
1:232d09a:                 // Now coerce the actual method parameter to the declared type
1:232d09a:                 // of this routine arg.
1:232d09a:                 //
1:14d5f00: 
1:232d09a:                 // if this is the last argument of a varargs routine...
1:232d09a:                 if ( hasVarargs && (p == parameterCount-1) )
1:232d09a:                 {
1:232d09a:                     //
1:232d09a:                     // The invocation of a varargs routine may have more actual parameters
1:232d09a:                     // than the number of declared routine arguments. All of the trailing
1:232d09a:                     // parameters must be coercible to the type of the last declared argument.
1:232d09a:                     // Furthermore, it may turn out that there isn't a parameter corresponding to the last
1:232d09a:                     // declared argument of the varargs routine.
1:232d09a:                     //
1:232d09a:                     for ( int idx = p; idx < methodParms.length; idx++ )
1:232d09a:                     {
1:232d09a:                         coerceMethodParameter
1:232d09a:                             (
1:09c2697:                              fromList, subqueryList, aggregates,
1:615cb37:                              rai,
1:ba70926:                              methodParms.length,
1:232d09a:                              paramdtd, parameterTypeId, parameterMode,
1:232d09a:                              idx
1:232d09a:                              );
1:232d09a:                     }
1:232d09a:                 }
1:232d09a:                 else    // NOT the last argument of a varargs routine
1:232d09a:                 {
1:232d09a:                     coerceMethodParameter
2:232d09a:                         (
1:09c2697:                          fromList, subqueryList, aggregates,
1:615cb37:                          rai,
1:ba70926:                          methodParms.length,
1:232d09a:                          paramdtd, parameterTypeId, parameterMode,
1:232d09a:                          p
1:232d09a:                          );
1:232d09a:                 }
1:c8603c4: 			}
1:14d5f00: 
1:14d5f00: 			if (sigParameterCount != parameterCount) {
1:14d5f00: 
1:14d5f00: 				DataTypeDescriptor dtd = new DataTypeDescriptor(
1:bbd82de: 						TypeId.getUserDefinedTypeId("java.sql.ResultSet[]"),
1:14d5f00: 						0,
1:14d5f00: 						0,
1:14d5f00: 						false,
1:14d5f00: 						-1
1:232d09a: 					);
1:14d5f00: 
1:14d5f00: 				signature[parameterCount] = new JSQLType(dtd);
1:14d5f00: 
1:c8603c4: 			}
1:14d5f00: 
1:615cb37: 			this.routineInfo = rai;
1:14d5f00: 			ad = proc;
1:14d5f00: 
1:14d5f00: 			// If a procedure is in the system schema and defined as executing
1:232d09a: 			// SQL, note that we are in system code.
1:232d09a: 			if (
1:232d09a:                 sd.isSystemSchema() &&
1:232d09a:                 (routineInfo.getReturnType() == null) &&
1:232d09a:                 routineInfo.getSQLAllowed() != RoutineAliasInfo.NO_SQL
1:232d09a:                 )
1:232d09a:             { isSystemCode = true; }
1:14d5f00: 
1:9f60172:             routineDefiner = sd.getAuthorizationId();
1:9f60172: 
1:14d5f00: 			break;
1:14d5f00: 		}
1:14d5f00:         }
1:14d5f00: 
1:d389f7d:         if ( (ad == null) && (methodParms.length == 1) )
1:c8603c4:         {
1:2782d72:             ad = AggregateNode.resolveAggregate
1:2782d72:                 ( getDataDictionary(), sd, methodName, noSchema );
1:14d5f00:         }
1:14d5f00: 	}
1:14d5f00: 
1:c8603c4:     /**
1:232d09a:      * <p>
1:232d09a:      * Coerce an actual method parameter to the declared type of the corresponding
1:232d09a:      * routine argument.
1:232d09a:      * </p>
1:232d09a:      */
1:232d09a:     private void    coerceMethodParameter
1:232d09a:         (
1:232d09a:          FromList fromList,
1:232d09a:          SubqueryList subqueryList,
1:71c8e86:          List<AggregateNode> aggregates,
1:615cb37:          RoutineAliasInfo rai,
1:232d09a:          int    parameterCount, // number of declared routine args
1:232d09a:          DataTypeDescriptor paramdtd,   // declared type of routine arg
1:232d09a:          TypeId parameterTypeId,    // declared type id of routine arg
1:232d09a:          int    parameterMode,
1:232d09a:          int    p   // index of actual method parameter in array of parameters
1:232d09a:          )
1:232d09a:         throws StandardException
1:232d09a:     {
1:232d09a:         // check parameter is a ? node for INOUT and OUT parameters.
1:232d09a: 
1:232d09a:         ValueNode sqlParamNode = null;
1:232d09a: 
1:232d09a:         if (methodParms[p] instanceof SQLToJavaValueNode)
1:232d09a:         {
1:232d09a:             SQLToJavaValueNode sql2j = (SQLToJavaValueNode) methodParms[p];
1:232d09a:             sqlParamNode = sql2j.getSQLValueNode();
1:232d09a:         }
1:232d09a: 
1:232d09a:         boolean isParameterMarker = true;
1:232d09a:         if ((sqlParamNode == null) || !sqlParamNode.requiresTypeFromContext())
1:232d09a:         {
1:e33b8d8:             if (parameterMode != (ParameterMetaData.parameterModeIn))
1:232d09a:             {
1:232d09a:                 throw StandardException.newException
1:232d09a:                     (
1:232d09a:                      SQLState.LANG_DB2_PARAMETER_NEEDS_MARKER,
1:232d09a:                      RoutineAliasInfo.parameterMode(parameterMode),
1:615cb37:                      rai.getParameterNames()[p]
1:232d09a:                      );
1:232d09a:             }
1:232d09a:             isParameterMarker = false;
1:232d09a:         }
1:232d09a:         else
1:232d09a:         {
1:232d09a:             if (applicationParameterNumbers == null)
1:232d09a:             { applicationParameterNumbers = new int[parameterCount]; }
1:232d09a:             if (sqlParamNode instanceof UnaryOperatorNode)
1:232d09a:             {
1:232d09a:                 ParameterNode pn = ((UnaryOperatorNode)sqlParamNode).getParameterOperand();
1:232d09a:                 applicationParameterNumbers[p] = pn.getParameterNumber();
1:232d09a:             } else
1:232d09a:             { applicationParameterNumbers[p] = ((ParameterNode) sqlParamNode).getParameterNumber(); }
1:232d09a:         }
1:232d09a: 
1:232d09a:         boolean needCast = false;
1:232d09a:         if (!isParameterMarker)
1:232d09a:         {
1:232d09a:             // can only be an IN parameter.
1:232d09a:             // check that the value can be assigned to the
1:232d09a:             // type of the procedure parameter.
1:232d09a:             if (sqlParamNode instanceof UntypedNullConstantNode)
1:232d09a:             {
1:232d09a:                 sqlParamNode.setType(paramdtd);
1:232d09a:             }
1:232d09a:             else
1:232d09a:             {
1:232d09a:                 DataTypeDescriptor dts;
1:232d09a:                 TypeId argumentTypeId;
1:232d09a:                 
1:232d09a:                 if (sqlParamNode != null)
1:232d09a:                 {
1:232d09a:                     // a node from the SQL world
1:232d09a:                     argumentTypeId = sqlParamNode.getTypeId();
1:232d09a:                     dts = sqlParamNode.getTypeServices();
1:232d09a:                 }
1:232d09a:                 else
1:232d09a:                 {
1:232d09a:                     // a node from the Java world
1:232d09a:                     dts = DataTypeDescriptor.getSQLDataTypeDescriptor(methodParms[p].getJavaTypeName());
1:232d09a:                     if (dts == null)
1:232d09a:                     {
1:232d09a:                         throw StandardException.newException
1:232d09a:                             (
1:232d09a:                              SQLState.LANG_NO_CORRESPONDING_S_Q_L_TYPE, 
1:232d09a:                              methodParms[p].getJavaTypeName()
1:232d09a:                              );
1:232d09a:                     }
1:232d09a: 
1:232d09a:                     argumentTypeId = dts.getTypeId();
1:232d09a:                 }
1:232d09a: 
1:232d09a:                 if (! getTypeCompiler(parameterTypeId).storable(argumentTypeId, getClassFactory()))
1:232d09a:                 {
1:232d09a:                     throw StandardException.newException
1:232d09a:                         (
1:232d09a:                          SQLState.LANG_NOT_STORABLE, 
1:232d09a:                          parameterTypeId.getSQLTypeName(),
1:232d09a:                          argumentTypeId.getSQLTypeName()
1:232d09a:                          );
1:232d09a:                 }
1:232d09a: 
1:232d09a:                 // if it's not an exact length match then some cast will be needed.
1:232d09a:                 if (!paramdtd.isExactTypeAndLengthMatch(dts))   { needCast = true; }
1:232d09a:             }
1:232d09a:         }
1:232d09a:         else
1:232d09a:         {
1:232d09a:             // any variable length type will need a cast from the
1:232d09a:             // Java world (the ? parameter) to the SQL type. This
1:232d09a:             // ensures values like CHAR(10) are passed into the procedure
1:232d09a:             // correctly as 10 characters long.
1:232d09a:             if (parameterTypeId.variableLength())
1:232d09a:             {
1:e33b8d8:                 if (parameterMode != (ParameterMetaData.parameterModeOut))
1:232d09a:                 { needCast = true; }
1:232d09a:             }
1:232d09a:         }
1:232d09a: 
1:232d09a:         if (needCast)
1:232d09a:         {
1:232d09a:             // push a cast node to ensure the
1:232d09a:             // correct type is passed to the method
1:232d09a:             // this gets tacky because before we knew
1:232d09a:             // it was a procedure call we ensured all the
1:232d09a:             // parameter are JavaNodeTypes. Now we need to
1:232d09a:             // push them back to the SQL domain, cast them
1:232d09a:             // and then push them back to the Java domain.
1:232d09a:             
1:232d09a:             if (sqlParamNode == null)
1:232d09a:             {
1:3bb140c:                 sqlParamNode =
1:3bb140c:                     new JavaToSQLValueNode(methodParms[p], getContextManager());
1:232d09a:             }
1:232d09a: 
1:232d09a:             ValueNode castNode = makeCast
1:232d09a:                 (
1:232d09a:                  sqlParamNode,
1:232d09a:                  paramdtd,
1:232d09a:                  getContextManager()
1:232d09a:                  );
1:232d09a: 
1:3bb140c:             methodParms[p] =
1:3bb140c:                     new SQLToJavaValueNode(castNode, getContextManager());
1:232d09a: 
1:09c2697:             methodParms[p] = methodParms[p].bindExpression(
1:09c2697:                     fromList, subqueryList, aggregates);
1:232d09a:         }
1:232d09a: 
1:232d09a:         // only force the type for a ? so that the correct type shows up
1:232d09a:         // in parameter meta data
1:232d09a:         if (isParameterMarker)  { sqlParamNode.setType(paramdtd); }
1:232d09a:     }
1:232d09a: 
1:232d09a:     /**
1:2cf546d:      * Wrap a parameter in a CAST node.
1:c8603c4:      */
1:3bb140c:     public static ValueNode makeCast (ValueNode parameterNode,
1:3bb140c:                                       DataTypeDescriptor targetType,
1:3bb140c:                                       ContextManager cm)
1:c8603c4:         throws StandardException
1:c8603c4:     {
1:3bb140c:         ValueNode castNode = new CastNode(parameterNode, targetType, cm);
1:2cf546d: 
1:2cf546d:         // Argument type has the same semantics as assignment:
1:2cf546d:         // Section 9.2 (Store assignment). There, General Rule 
1:2cf546d:         // 2.b.v.2 says that the database should raise an exception
1:2cf546d:         // if truncation occurs when stuffing a string value into a
1:2cf546d:         // VARCHAR, so make sure CAST doesn't issue warning only.
1:2cf546d:         ((CastNode)castNode).setAssignmentSemantics();
1:2cf546d: 
1:2cf546d:         return castNode;
1:2cf546d:     }
1:2cf546d: 
1:14d5f00: 	/**
1:6950a39: 	 * Add code to set up the SQL session context for a stored
1:6950a39: 	 * procedure or function which needs a nested SQL session
1:6950a39: 	 * context (only needed for those which can contain SQL).
1:6950a39: 	 *
1:0c5bc3a:      * The generated code calls pushNestedSessionContext.
1:0c5bc3a:      * @see LanguageConnectionContext#pushNestedSessionContext
1:6950a39: 	 *
1:6950a39: 	 * @param acb activation class builder
1:6950a39: 	 * @param mb  method builder
1:6950a39: 	 */
1:0c5bc3a:     private void generatePushNestedSessionContext(
1:9f60172:         ActivationClassBuilder acb,
1:9f60172:         MethodBuilder mb,
1:9f60172:         boolean hadDefinersRights,
1:9f60172:         String definer) throws StandardException {
1:6950a39: 
1:6950a39: 		// Generates the following Java code:
1:6950a39: 		// ((Activation)this).getLanguageConnectionContext().
1:0c5bc3a:         //       pushNestedSessionContext((Activation)this);
1:6950a39: 
1:6950a39: 		acb.pushThisAsActivation(mb);
1:6950a39: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, null,
1:6950a39: 					  "getLanguageConnectionContext",
1:6950a39: 					  ClassName.LanguageConnectionContext, 0);
1:6950a39: 		acb.pushThisAsActivation(mb);
1:9f60172:         mb.push(hadDefinersRights);
1:9f60172:         mb.push(definer);
1:6950a39: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, null,
1:0c5bc3a:                       "pushNestedSessionContext",
1:9f60172:                       "void", 3);
1:6950a39: 	}
1:6950a39: 
1:6950a39: 
1:6950a39: 	/**
1:fe77ca5: 		Push extra code to generate the casts within the
1:fe77ca5: 		arrays for the parameters passed as arrays.
1:fe77ca5: 	*/
1:3bb140c:     @Override
1:9f2ed7d:     void generateOneParameter(ExpressionClassBuilder acb,
1:fe77ca5: 											MethodBuilder mb,
1:fe77ca5: 											int parameterNumber )
2:fe77ca5: 			throws StandardException
1:14d5f00: 	{
1:fe77ca5: 		int parameterMode;
1:14d5f00: 
1:fe77ca5: 		SQLToJavaValueNode sql2j = null;
1:fe77ca5: 		if (methodParms[parameterNumber] instanceof SQLToJavaValueNode)
1:fe77ca5: 			sql2j = (SQLToJavaValueNode) methodParms[parameterNumber];
1:14d5f00: 		
2:fe77ca5: 		if (routineInfo != null) {
1:232d09a: 			parameterMode = routineInfo.getParameterModes()[ getRoutineArgIdx( parameterNumber ) ];
1:fe77ca5: 		} else {
1:fe77ca5: 			// for a static method call the parameter always starts out as a in parameter, but
1:fe77ca5: 			// may be registered as an IN OUT parameter. For a static method argument to be
1:fe77ca5: 			// a dynmaically registered out parameter it must be a simple ? parameter
1:14d5f00: 
1:e33b8d8:             parameterMode = (ParameterMetaData.parameterModeIn);
1:14d5f00: 
1:fe77ca5: 			if (sql2j != null) {
1:d5bc20f: 				if (sql2j.getSQLValueNode().requiresTypeFromContext()) {
1:d5bc20f: 	  				ParameterNode pn;
1:d5bc20f: 		  			if (sql2j.getSQLValueNode() instanceof UnaryOperatorNode) 
1:d5bc20f: 		  				pn = ((UnaryOperatorNode)sql2j.getSQLValueNode()).getParameterOperand();
3:14d5f00: 		  			else
1:d5bc20f: 		  				pn = (ParameterNode) (sql2j.getSQLValueNode());
1:14d5f00: 
1:fe77ca5: 					// applicationParameterNumbers is only set up for a procedure.
1:d5bc20f: 					int applicationParameterNumber = pn.getParameterNumber();
1:14d5f00: 
1:ba70926: 					String parameterType = methodParameterTypes[ getRoutineArgIdx( parameterNumber ) ];
1:14d5f00: 
1:fe77ca5: 					if (parameterType.endsWith("[]")) {
1:14d5f00: 
1:c6892a1: 						// constructor  - setting up correct parameter type info
1:fe77ca5: 						MethodBuilder constructor = acb.getConstructor();
1:fe77ca5: 						acb.pushThisAsActivation(constructor);
1:fe77ca5: 						constructor.callMethod(VMOpcode.INVOKEINTERFACE, null,
1:fe77ca5: 											"getParameterValueSet", ClassName.ParameterValueSet, 0);
1:14d5f00: 
1:fe77ca5: 						constructor.push(applicationParameterNumber);
1:e33b8d8:                         constructor.push(ParameterMetaData.parameterModeUnknown);
1:fe77ca5: 						constructor.callMethod(VMOpcode.INVOKEINTERFACE, null,
1:fe77ca5: 											"setParameterMode", "void", 2);
1:fe77ca5: 						constructor.endStatement();
1:14d5f00: 					}
1:14d5f00: 				}
1:14d5f00: 			} 
1:14d5f00: 		}
1:14d5f00: 
1:fe77ca5: 		switch (parameterMode) {
1:e33b8d8:         case (ParameterMetaData.parameterModeIn):
1:e33b8d8:         case (ParameterMetaData.parameterModeInOut):
1:e33b8d8:         case (ParameterMetaData.parameterModeUnknown):
1:fe77ca5: 			if (sql2j != null)
1:fe77ca5: 				sql2j.returnsNullOnNullState = returnsNullOnNullState;
1:fe77ca5: 			super.generateOneParameter(acb, mb, parameterNumber);
1:14d5f00: 			break;
1:14d5f00: 
1:e33b8d8:         case (ParameterMetaData.parameterModeOut):
1:fe77ca5: 			// For an OUT parameter we require nothing to be pushed into the
1:fe77ca5: 			// method call from the parameter node.
5:fe77ca5: 			break;
1:14d5f00: 		}
1:14d5f00: 
1:fe77ca5: 		switch (parameterMode) {
1:e33b8d8:         case (ParameterMetaData.parameterModeIn):
1:e33b8d8:         case (ParameterMetaData.parameterModeUnknown):
1:fe77ca5: 			break;
1:14d5f00: 
1:e33b8d8:         case (ParameterMetaData.parameterModeInOut):
1:e33b8d8:         case (ParameterMetaData.parameterModeOut):
1:14d5f00: 		{
1:fe77ca5: 			// Create the array used to pass into the method. We create a
1:fe77ca5: 			// new array for each call as there is a small chance the
1:fe77ca5: 			// application could retain a reference to it and corrupt
1:fe77ca5: 			// future calls with the same CallableStatement object.
1:14d5f00: 
1:ba70926: 			String methodParameterType = methodParameterTypes[ getRoutineArgIdx( parameterNumber ) ];
1:fe77ca5: 			String arrayType = methodParameterType.substring(0, methodParameterType.length() - 2);
1:ba70926: 
1:ba70926:             // if a varargs arg, then strip off the extra array dimension added by varargs
1:ba70926:             if ( isVararg( parameterNumber ) )
1:ba70926:             {
1:ba70926:                 methodParameterType = stripOneArrayLevel( methodParameterType );
1:ba70926:                 arrayType = stripOneArrayLevel( arrayType );
1:ba70926:             }
1:ba70926:             
1:fe77ca5: 			LocalField lf = acb.newFieldDeclaration(Modifier.PRIVATE, methodParameterType);
1:14d5f00: 
1:fe77ca5: 			if (outParamArrays == null)
1:ba70926:             { outParamArrays = new LocalField[methodParms.length]; }
1:14d5f00: 
1:fe77ca5: 			outParamArrays[parameterNumber] = lf;
1:14d5f00: 
1:fe77ca5: 			mb.pushNewArray(arrayType, 1);
1:fe77ca5: 			mb.putField(lf);
1:14d5f00: 
1:fe77ca5: 			// set the IN part of the parameter into the INOUT parameter.
1:e33b8d8:             if (parameterMode != (ParameterMetaData.parameterModeOut)) {
1:fe77ca5: 				mb.swap();
1:fe77ca5: 				mb.setArrayElement(0);
1:fe77ca5: 				mb.getField(lf);
1:14d5f00: 			}
1:fe77ca5: 			break;
1:14d5f00: 			}
1:14d5f00: 		}
1:14d5f00: 
1:14d5f00: 	}
1:14d5f00: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Categorize this predicate.  Initially, this means
1:fe77ca5: 	 * building a bit map of the referenced tables for each predicate.
1:fe77ca5: 	 * If the source of this ColumnReference (at the next underlying level) 
1:fe77ca5: 	 * is not a ColumnReference or a VirtualColumnNode then this predicate
1:fe77ca5: 	 * will not be pushed down.
1:fe77ca5: 	 *
1:fe77ca5: 	 * For example, in:
1:fe77ca5: 	 *		select * from (select 1 from s) a (x) where x = 1
1:fe77ca5: 	 * we will not push down x = 1.
1:fe77ca5: 	 * NOTE: It would be easy to handle the case of a constant, but if the
1:fe77ca5: 	 * inner SELECT returns an arbitrary expression, then we would have to copy
1:fe77ca5: 	 * that tree into the pushed predicate, and that tree could contain
1:fe77ca5: 	 * subqueries and method calls.
1:fe77ca5: 	 * RESOLVE - revisit this issue once we have views.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @param referencedTabs	JBitSet with bit map of referenced FromTables
1:fe77ca5: 	 * @param simplePredsOnly	Whether or not to consider method
1:fe77ca5: 	 *							calls, field references and conditional nodes
1:fe77ca5: 	 *							when building bit map
1:fe77ca5: 	 *
1:fe77ca5: 	 * @return boolean		Whether or not source.expression is a ColumnReference
1:fe77ca5: 	 *						or a VirtualColumnNode.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @exception StandardException		Thrown on error
1:fe77ca5: 	 */
1:3bb140c:     @Override
1:9f2ed7d:     boolean categorize(JBitSet referencedTabs, boolean simplePredsOnly)
1:fe77ca5: 		throws StandardException
1:14d5f00: 	{
1:fe77ca5: 		/* We stop here when only considering simple predicates
1:fe77ca5: 		 *  as we don't consider method calls when looking
1:fe77ca5: 		 * for null invariant predicates.
1:fe77ca5: 		 */
1:fe77ca5: 		if (simplePredsOnly)
1:14d5f00: 		{
1:fe77ca5: 			return false;
1:14d5f00: 		}
1:14d5f00: 
1:fe77ca5: 		boolean pushable = true;
1:fe77ca5: 
1:fe77ca5: 		pushable = pushable && super.categorize(referencedTabs, simplePredsOnly);
1:fe77ca5: 
1:fe77ca5: 		return pushable;
1:14d5f00: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
1:fe77ca5: 	 * for how this should be done for tree printing.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @return	This object as a String
1:fe77ca5: 	 */
1:3bb140c:     @Override
1:fe77ca5: 	public String toString()
1:14d5f00: 	{
1:fe77ca5: 		if (SanityManager.DEBUG)
1:14d5f00: 		{
1:fe77ca5: 			return "javaClassName: " +
1:fe77ca5: 				(javaClassName != null ? javaClassName : "null") + "\n" +
1:fe77ca5: 				super.toString();
1:14d5f00: 		}
1:14d5f00: 		else
1:14d5f00: 		{
1:fe77ca5: 			return "";
1:14d5f00: 		}
1:14d5f00: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Do code generation for this method call
1:fe77ca5: 	 *
1:fe77ca5: 	 * @param acb	The ExpressionClassBuilder for the class we're generating
1:fe77ca5: 	 * @param mb	The method the expression will go into
1:fe77ca5: 	 *
1:fe77ca5: 	 *
1:fe77ca5: 	 * @exception StandardException		Thrown on error
1:fe77ca5: 	 */
1:9f2ed7d:     void generateExpression(ExpressionClassBuilder acb, MethodBuilder mb)
1:fe77ca5: 									throws StandardException
1:14d5f00: 	{
1:fe77ca5: 		if (routineInfo != null) {
1:fe77ca5: 
1:fe77ca5: 			if (!routineInfo.calledOnNullInput() && routineInfo.getParameterCount() != 0)
1:fe77ca5: 				returnsNullOnNullState = acb.newFieldDeclaration(Modifier.PRIVATE, "boolean");
1:fe77ca5: 
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 		// reset the parameters are null indicator.
1:fe77ca5: 		if (returnsNullOnNullState != null) {
1:fe77ca5: 			mb.push(false);
1:afa871e: 			mb.setField(returnsNullOnNullState);
1:fe77ca5: 
1:fe77ca5: 			// for the call to the generated method below.
1:fe77ca5: 			mb.pushThis();
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 		int nargs = generateParameters(acb, mb);
1:fe77ca5: 
1:fe77ca5: 		LocalField functionEntrySQLAllowed = null;
1:fe77ca5: 
1:fe77ca5: 		if (routineInfo != null) {
1:fe77ca5: 
1:fe77ca5: 			short sqlAllowed = routineInfo.getSQLAllowed();
1:fe77ca5: 
1:fe77ca5: 			// Before we set up our authorization level, add a check to see if this
1:fe77ca5: 			// method can be called. If the routine is NO SQL or CONTAINS SQL 
1:fe77ca5: 			// then there is no need for a check. As follows:
1:fe77ca5: 			//
1:fe77ca5: 			// Current Level = NO_SQL - CALL will be rejected when getting CALL result set
1:fe77ca5: 			// Current Level = anything else - calls to procedures defined as NO_SQL and CONTAINS SQL both allowed.
1:fe77ca5: 
1:fe77ca5: 
1:fe77ca5: 			if (sqlAllowed != RoutineAliasInfo.NO_SQL)
1:14d5f00: 			{
1:fe77ca5: 				
1:fe77ca5: 				int sqlOperation;
1:fe77ca5: 				
1:fe77ca5: 				if (sqlAllowed == RoutineAliasInfo.READS_SQL_DATA)
1:fe77ca5: 					sqlOperation = Authorizer.SQL_SELECT_OP;
1:fe77ca5: 				else if (sqlAllowed == RoutineAliasInfo.MODIFIES_SQL_DATA)
1:fe77ca5: 					sqlOperation = Authorizer.SQL_WRITE_OP;
1:14d5f00: 				else
1:fe77ca5: 					sqlOperation = Authorizer.SQL_ARBITARY_OP;
1:fe77ca5: 				
1:fe77ca5: 				generateAuthorizeCheck((ActivationClassBuilder) acb, mb, sqlOperation);
1:fe77ca5: 			}
1:fe77ca5: 
1:fe77ca5: 			int statmentContextReferences = isSystemCode ? 2 : 1;
1:fe77ca5: 			
1:fe77ca5: 			boolean isFunction = routineInfo.getReturnType() != null;
1:fe77ca5: 
1:fe77ca5: 			if (isFunction)
1:fe77ca5: 				statmentContextReferences++;
1:fe77ca5: 
1:fe77ca5: 
1:fe77ca5: 			if (statmentContextReferences != 0) {
1:fe77ca5: 				acb.pushThisAsActivation(mb);
1:fe77ca5: 				mb.callMethod(VMOpcode.INVOKEINTERFACE, null,
1:fe77ca5: 									"getLanguageConnectionContext", ClassName.LanguageConnectionContext, 0);
1:fe77ca5: 				mb.callMethod(VMOpcode.INVOKEINTERFACE, null,
1:fe77ca5: 									"getStatementContext", "org.apache.derby.iapi.sql.conn.StatementContext", 0);
1:fe77ca5: 
1:fe77ca5: 				for (int scc = 1; scc < statmentContextReferences; scc++)
1:fe77ca5: 					mb.dup();
1:fe77ca5: 			}
1:fe77ca5: 
1:fe77ca5: 			/**
1:fe77ca5: 				Set the statement context to reflect we are running
1:fe77ca5: 				System procedures, so that we can execute non-standard SQL.
1:fe77ca5: 			*/
1:fe77ca5: 			if (isSystemCode) {
1:fe77ca5: 				mb.callMethod(VMOpcode.INVOKEINTERFACE, null,
1:fe77ca5: 									"setSystemCode", "void", 0);
1:fe77ca5: 			}
1:fe77ca5: 
1:6950a39: 			// If no SQL, there is no need to setup a nested session
1:6950a39: 			// context.
1:6950a39: 			if (sqlAllowed != RoutineAliasInfo.NO_SQL) {
1:0c5bc3a:                 generatePushNestedSessionContext(
1:9f60172:                     (ActivationClassBuilder) acb,
1:9f60172:                     mb,
1:9f60172:                     routineInfo.hasDefinersRights(),
1:9f60172:                     routineDefiner);
1:6950a39: 			}
1:6950a39: 
1:fe77ca5: 			// for a function we need to fetch the current SQL control
1:fe77ca5: 			// so that we can reset it once the function is complete.
1:fe77ca5: 			// 
1:fe77ca5: 			if (isFunction)
27:fe77ca5: 			{
1:fe77ca5: 				functionEntrySQLAllowed = acb.newFieldDeclaration(Modifier.PRIVATE, "short");
1:fe77ca5: 				mb.callMethod(VMOpcode.INVOKEINTERFACE, null,
1:fe77ca5: 									"getSQLAllowed", "short", 0);
1:afa871e: 				mb.setField(functionEntrySQLAllowed);
1:fe77ca5: 
1:fe77ca5: 			}
1:fe77ca5: 			
1:fe77ca5: 			
1:fe77ca5: 			// Set up the statement context to reflect the
1:fe77ca5: 			// restricted SQL execution allowed by this routine.
1:fe77ca5: 
1:fe77ca5: 			mb.push(sqlAllowed);
1:fe77ca5: 			mb.push(false);
1:fe77ca5: 			mb.callMethod(VMOpcode.INVOKEINTERFACE, null,
1:fe77ca5: 								"setSQLAllowed", "void", 2);
1:fe77ca5: 
1:fe77ca5: 		}
1:fe77ca5: 
1:232d09a: 		// add in the ResultSet arrays. note that varargs and dynamic ResultSets
1:232d09a:         // both make claims on the trailing arguments of the method invocation.
1:232d09a:         // a routine may make use of both varargs and dynamic ResultSets.
1:232d09a: 		if ( routineInfo != null && !hasVarargs() )
1:232d09a:         {
1:68573fc: 			int compiledResultSets = methodParameterTypes.length - methodParms.length;
1:fe77ca5: 
1:fe77ca5: 			if (compiledResultSets != 0) {
1:fe77ca5: 
1:fe77ca5: 				// Add a method that indicates the maxium number of dynamic result sets.
1:fe77ca5: 				int maxDynamicResults = routineInfo.getMaxDynamicResultSets();
1:fe77ca5: 				if (maxDynamicResults > 0) {
1:fe77ca5: 					MethodBuilder gdr = acb.getClassBuilder().newMethodBuilder(Modifier.PUBLIC, "int", "getMaxDynamicResults");
1:fe77ca5: 					gdr.push(maxDynamicResults);
1:fe77ca5: 					gdr.methodReturn();
1:fe77ca5: 					gdr.complete();
1:fe77ca5: 				}
1:7b398e9: 
1:fe77ca5: 				// add a method to return all the dynamic result sets (unordered)
1:fe77ca5: 				MethodBuilder gdr = acb.getClassBuilder().newMethodBuilder(Modifier.PUBLIC, "java.sql.ResultSet[][]", "getDynamicResults");
1:fe77ca5: 
1:fe77ca5: 				MethodBuilder cons = acb.getConstructor();
1:fe77ca5: 				// if (procDef.getParameterStyle() == RoutineAliasInfo.PS_JAVA)
1:fe77ca5: 				{
1:fe77ca5: 					// PARAMETER STYLE JAVA
1:fe77ca5: 
1:fe77ca5: 					LocalField procedureResultSetsHolder = acb.newFieldDeclaration(Modifier.PRIVATE, "java.sql.ResultSet[][]");
1:fe77ca5: 
1:fe77ca5: 					// getDynamicResults body
1:fe77ca5: 					gdr.getField(procedureResultSetsHolder);
1:fe77ca5: 
1:fe77ca5: 					// create the holder of all the ResultSet arrays, new java.sql.ResultSet[][compiledResultSets]
1:fe77ca5: 					cons.pushNewArray("java.sql.ResultSet[]", compiledResultSets);
1:afa871e: 					cons.setField(procedureResultSetsHolder);
1:fe77ca5: 
1:fe77ca5: 
1:fe77ca5: 					// arguments for the dynamic result sets
1:fe77ca5: 					for (int i = 0; i < compiledResultSets; i++) {
1:fe77ca5: 
1:fe77ca5: 						mb.pushNewArray("java.sql.ResultSet", 1);
1:fe77ca5: 						mb.dup();
1:fe77ca5: 
1:fe77ca5: 						mb.getField(procedureResultSetsHolder);
1:fe77ca5: 						mb.swap();
1:fe77ca5: 
1:fe77ca5: 						mb.setArrayElement(i);
1:fe77ca5: 					}
1:fe77ca5: 				} 
1:fe77ca5: 
1:fe77ca5: 				// complete the method that returns the ResultSet[][] to the 
1:fe77ca5: 				gdr.methodReturn();
1:fe77ca5: 				gdr.complete();
1:68573fc: 
1:fe77ca5: 				nargs += compiledResultSets;
1:fe77ca5: 			}
1:fe77ca5: 
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 		String javaReturnType = getJavaTypeName();
1:fe77ca5: 
1:fe77ca5: 		MethodBuilder mbnc = null;
1:fe77ca5: 		MethodBuilder mbcm = mb;
1:68573fc: 
1:fe77ca5: 
1:fe77ca5: 		// If any of the parameters are null then
1:fe77ca5: 		// do not call the method, just return null.
1:fe77ca5: 		if (returnsNullOnNullState != null)
1:fe77ca5: 		{
1:fe77ca5: 			mbnc = acb.newGeneratedFun(javaReturnType, Modifier.PRIVATE, methodParameterTypes);
1:fe77ca5: 
1:fe77ca5: 			// add the throws clause for the public static method we are going to call.
1:fe77ca5: 			Class[] throwsSet = ((java.lang.reflect.Method) method).getExceptionTypes();
1:fe77ca5: 			for (int te = 0; te < throwsSet.length; te++)
1:fe77ca5: 			{
1:fe77ca5: 				mbnc.addThrownException(throwsSet[te].getName());
1:fe77ca5: 			}
1:fe77ca5: 
1:fe77ca5: 			mbnc.getField(returnsNullOnNullState);
1:fe77ca5: 			mbnc.conditionalIf();
1:fe77ca5: 
1:fe77ca5: 			// set up for a null!!
1:fe77ca5: 			// for objects is easy.
1:fe77ca5: 			mbnc.pushNull(javaReturnType);
1:fe77ca5: 
1:fe77ca5: 			mbnc.startElseCode();	
1:fe77ca5: 
2:fe77ca5: 			if (!actualMethodReturnType.equals(javaReturnType))
1:fe77ca5: 				mbnc.pushNewStart(javaReturnType);
1:fe77ca5: 
1:fe77ca5: 			// fetch all the arguments
1:fe77ca5: 			for (int pa = 0; pa < nargs; pa++)
1:fe77ca5: 			{
1:fe77ca5: 				mbnc.getParameter(pa);
1:fe77ca5: 			}
1:fe77ca5: 
1:fe77ca5: 			mbcm = mbnc;
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 		mbcm.callMethod(VMOpcode.INVOKESTATIC, method.getDeclaringClass().getName(), methodName,
1:fe77ca5: 					actualMethodReturnType, nargs);
1:fe77ca5: 
1:fe77ca5: 
1:fe77ca5: 		if (returnsNullOnNullState != null)
1:fe77ca5: 		{
1:0a6ce0b: 			// DERBY-3360. In the case of function returning
1:0a6ce0b: 			// a SMALLINT if we specify RETURN NULL ON NULL INPUT
1:0a6ce0b: 			// the javaReturnType will be java.lang.Integer. In
1:0a6ce0b: 			// order to initialize the integer properly, we need
1:0a6ce0b: 			// to upcast the short.  This is a special case for
1:0a6ce0b: 			// SMALLINT functions only as other types are 
1:0a6ce0b: 			// compatible with their function return types.
1:0a6ce0b: 			if (!actualMethodReturnType.equals(javaReturnType)) {
1:0a6ce0b: 				if (actualMethodReturnType.equals("short") &&
1:0a6ce0b: 						javaReturnType.equals("java.lang.Integer"))
1:0a6ce0b: 					mbnc.upCast("int");
1:0a6ce0b: 			
1:fe77ca5: 				mbnc.pushNewComplete(1);
1:0a6ce0b: 			}
1:fe77ca5: 			mbnc.completeConditional();
1:fe77ca5: 
1:fe77ca5: 			mbnc.methodReturn();
1:fe77ca5: 			mbnc.complete();
1:fe77ca5: 
1:fe77ca5: 			// now call the wrapper method
1:fe77ca5: 			mb.callMethod(VMOpcode.INVOKEVIRTUAL, acb.getClassBuilder().getFullName(), mbnc.getName(),
1:fe77ca5: 					javaReturnType, nargs);
1:fe77ca5: 			mbnc = null;
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 
1:fe77ca5: 		if (routineInfo != null) {
1:fe77ca5: 
1:fe77ca5: 			// reset the SQL allowed setting that we set upon
1:fe77ca5: 			// entry to the method.
1:fe77ca5: 			if (functionEntrySQLAllowed != null) {
1:fe77ca5: 				acb.pushThisAsActivation(mb);
1:fe77ca5: 				mb.callMethod(VMOpcode.INVOKEINTERFACE, null,
1:fe77ca5: 									"getLanguageConnectionContext", ClassName.LanguageConnectionContext, 0);
1:fe77ca5: 				mb.callMethod(VMOpcode.INVOKEINTERFACE, null,
1:fe77ca5: 									"getStatementContext", "org.apache.derby.iapi.sql.conn.StatementContext", 0);
1:fe77ca5: 				mb.getField(functionEntrySQLAllowed);
1:fe77ca5: 				mb.push(true); // override as we are ending the control set by this function all.
1:fe77ca5: 				mb.callMethod(VMOpcode.INVOKEINTERFACE, null,
1:fe77ca5: 									"setSQLAllowed", "void", 2);
1:fe77ca5: 
1:fe77ca5: 			}
1:fe77ca5: 
1:fe77ca5: 			if (outParamArrays != null) {
1:fe77ca5: 
1:fe77ca5: 				MethodBuilder constructor = acb.getConstructor();
1:fe77ca5: 
1:c6892a1: 				// constructor  - setting up correct parameter type info
1:fe77ca5: 				acb.pushThisAsActivation(constructor);
1:fe77ca5: 				constructor.callMethod(VMOpcode.INVOKEINTERFACE, null,
1:fe77ca5: 									"getParameterValueSet", ClassName.ParameterValueSet, 0);
1:fe77ca5: 
1:fe77ca5: 				// execute  - passing out parameters back.
1:fe77ca5: 				acb.pushThisAsActivation(mb);
1:fe77ca5: 				mb.callMethod(VMOpcode.INVOKEINTERFACE, null,
1:fe77ca5: 									"getParameterValueSet", ClassName.ParameterValueSet, 0);
1:fe77ca5: 
1:fe77ca5: 				int[] parameterModes = routineInfo.getParameterModes();
1:fe77ca5: 				for (int i = 0; i < outParamArrays.length; i++) {
1:fe77ca5: 
1:ba70926: 					int parameterMode = parameterModes[ getRoutineArgIdx( i ) ];
1:ba70926:                     
1:e33b8d8:                     if (parameterMode != (ParameterMetaData.parameterModeIn)) {
1:fe77ca5: 
1:fe77ca5: 						// must be a parameter if it is INOUT or OUT.
1:fe77ca5: 						ValueNode sqlParamNode = ((SQLToJavaValueNode) methodParms[i]).getSQLValueNode();
1:fe77ca5: 
1:fe77ca5: 
1:fe77ca5: 						int applicationParameterNumber = applicationParameterNumbers[i];
1:fe77ca5: 
1:fe77ca5: 						// Set the correct parameter nodes in the ParameterValueSet at constructor time.
1:fe77ca5: 						constructor.dup();
1:fe77ca5: 						constructor.push(applicationParameterNumber);
1:fe77ca5: 						constructor.push(parameterMode);
1:fe77ca5: 						constructor.callMethod(VMOpcode.INVOKEINTERFACE, null,
1:fe77ca5: 										"setParameterMode", "void", 2);
1:fe77ca5: 
1:fe77ca5: 						// Pass the value of the outparameters back to the calling code
1:fe77ca5: 						LocalField lf = outParamArrays[i];
1:fe77ca5: 
1:fe77ca5: 						mb.dup(); 
1:fe77ca5: 						mb.push(applicationParameterNumber);
1:fe77ca5: 						mb.callMethod(VMOpcode.INVOKEINTERFACE, null,
1:fe77ca5: 									"getParameter", ClassName.DataValueDescriptor, 1);
1:fe77ca5: 
1:fe77ca5: 						// see if we need to set the desired length/scale/precision of the type
1:fe77ca5: 						DataTypeDescriptor paramdtd = sqlParamNode.getTypeServices();
1:fe77ca5: 
1:fe77ca5: 						boolean isNumericType = paramdtd.getTypeId().isNumericTypeId();
1:33bfdc0: 						boolean isAnsiUDT = paramdtd.getTypeId().getBaseTypeId().isAnsiUDT();
1:fe77ca5: 
1:d7f7457: 						// is the underlying type for the OUT/INOUT parameter primitive.
1:ba70926:                         // if this is a varargs arg then we have to strip off another array level
1:e1f49ca:                         Class<?> cellType = ((Method) method).
1:e1f49ca:                                 getParameterTypes()[ getRoutineArgIdx( i ) ].
1:ba70926:                                 getComponentType();
1:e1f49ca: 
1:e1f49ca:                         if ( isVararg( i ) ) {
1:e1f49ca:                             cellType = cellType.getComponentType();
1:e1f49ca:                         }
1:ba70926: 						boolean isPrimitive = cellType.isPrimitive();
1:fe77ca5: 
1:d7f7457: 						if (isNumericType) {
1:d7f7457: 							// need to up-cast as the setValue(Number) method only exists on NumberDataValue
1:d7f7457: 
1:d7f7457: 							if (!isPrimitive)
1:d7f7457: 								mb.cast(ClassName.NumberDataValue);
1:fe77ca5: 						}
1:fe77ca5: 						else if (paramdtd.getTypeId().isBooleanTypeId())
1:fe77ca5: 						{
1:d7f7457: 							// need to cast as the setValue(Boolean) method only exists on BooleanDataValue
1:d7f7457: 							if (!isPrimitive)
1:fe77ca5: 								mb.cast(ClassName.BooleanDataValue);
1:fe77ca5: 						}
1:fe77ca5: 
1:fe77ca5: 						if (paramdtd.getTypeId().variableLength()) {
1:fe77ca5: 							// need another DVD reference for the set width below.
1:fe77ca5: 							mb.dup();
1:fe77ca5: 						}
1:fe77ca5: 
1:fe77ca5: 
1:fe77ca5: 						mb.getField(lf); // pvs, dvd, array
1:fe77ca5: 						mb.getArrayElement(0); // pvs, dvd, value
1:d7f7457: 
1:d7f7457: 						// The value needs to be set thorugh the setValue(Number) method.
1:d7f7457: 						if (isNumericType && !isPrimitive)
1:d7f7457: 						{
1:d7f7457: 							mb.upCast("java.lang.Number");
1:d7f7457: 						}
1:d7f7457: 
1:33bfdc0: 						// The value needs to be set thorugh the setValue(Object) method.
1:33bfdc0: 						if (isAnsiUDT)
1:33bfdc0: 						{
1:33bfdc0: 							mb.upCast("java.lang.Object");
1:33bfdc0: 						}
1:33bfdc0: 
1:fe77ca5: 						mb.callMethod(VMOpcode.INVOKEINTERFACE, null, "setValue", "void", 1);
1:fe77ca5: 
1:fe77ca5: 						if (paramdtd.getTypeId().variableLength()) {
1:fe77ca5: 							mb.push(isNumericType ? paramdtd.getPrecision() : paramdtd.getMaximumWidth());
1:fe77ca5: 							mb.push(paramdtd.getScale());
1:fe77ca5: 							mb.push(isNumericType);
1:806114c: 							mb.callMethod(VMOpcode.INVOKEINTERFACE, ClassName.VariableSizeDataValue, "setWidth", "void", 3);
1:806114c: 							// mb.endStatement();
1:fe77ca5: 						}
1:fe77ca5: 					}
1:fe77ca5: 				}
1:fe77ca5: 				constructor.endStatement();
4:fe77ca5: 				mb.endStatement();
1:fe77ca5: 			}
1:fe77ca5: 
1:fe77ca5: 		}
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:d78ad2e: 	 * Set default privilege of EXECUTE for this node. 
1:fe77ca5: 	 */
1:d78ad2e: 	int getPrivType()
1:fe77ca5: 	{
1:d78ad2e: 		return Authorizer.EXECUTE_PRIV;
1:fe77ca5: 	}
1:7b398e9: 
1:69f8afa:     @Override
1:69f8afa:     void acceptChildren(Visitor v) throws StandardException {
1:69f8afa:         super.acceptChildren(v);
1:69f8afa: 
1:69f8afa:         if (procedureName != null) {
1:69f8afa:             procedureName = (TableName) procedureName.accept(v);
1:69f8afa:         }
1:69f8afa:     }
1:fe77ca5: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:28c4dc4
/////////////////////////////////////////////////////////////////////////
1:                 !javaClassName.startsWith( "org.apache.derby.optional.dump." ) &&
commit:2782d72
/////////////////////////////////////////////////////////////////////////
1:             resolveRoutine( fromList, subqueryList, aggregates, sd, noSchema );
/////////////////////////////////////////////////////////////////////////
1:                 resolveRoutine(fromList, subqueryList, aggregates, sd, noSchema);
/////////////////////////////////////////////////////////////////////////
1:                     resolveRoutine(fromList, subqueryList, aggregates, sd, noSchema);
/////////////////////////////////////////////////////////////////////////
1:                     resolveRoutine(fromList, subqueryList, aggregates, sd, noSchema);
/////////////////////////////////////////////////////////////////////////
1:                                 List<AggregateNode> aggregates, SchemaDescriptor sd,
1:                                 boolean noSchema)
/////////////////////////////////////////////////////////////////////////
1:             ad = AggregateNode.resolveAggregate
1:                 ( getDataDictionary(), sd, methodName, noSchema );
commit:2c38f3c
/////////////////////////////////////////////////////////////////////////
1:                 !javaClassName.startsWith( "org.apache.derby.optional.json." ) &&
commit:515a63e
/////////////////////////////////////////////////////////////////////////
1:                 !javaClassName.startsWith( "org.apache.derby.optional.api." ) &&
commit:fbf176c
/////////////////////////////////////////////////////////////////////////
1:                 !javaClassName.startsWith( "org.apache.derby.optional.lucene." ) &&
commit:d847ced
/////////////////////////////////////////////////////////////////////////
0:                 !javaClassName.startsWith( "org.apache.derby.impl.optional.lucene." ) &&
commit:29007f0
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     TableName getFullName()
1: 	{
1: 		return  procedureName;
1: 	}
1: 
commit:070d37e
/////////////////////////////////////////////////////////////////////////
1:                 // Propagate tags used to flag nodes which need privilege checks. See DERBY-6429.
1:                 resolvedAggregate.copyTagsFrom( this );
1: 
commit:71c8e86
/////////////////////////////////////////////////////////////////////////
1:         FromList fromList, SubqueryList subqueryList, List<AggregateNode> aggregates)
/////////////////////////////////////////////////////////////////////////
0:                                 List<AggregateNode> aggregates, SchemaDescriptor sd)
/////////////////////////////////////////////////////////////////////////
1:          List<AggregateNode> aggregates,
commit:615cb37
/////////////////////////////////////////////////////////////////////////
1: 			RoutineAliasInfo rai = (RoutineAliasInfo) proc.getAliasInfo();
1: 			int parameterCount = rai.getParameterCount();
1:             boolean hasVarargs = rai.hasVarargs();
/////////////////////////////////////////////////////////////////////////
1: 			TypeDescriptor[] parameterTypes = rai.getParameterTypes();
1: 			if (rai.getMaxDynamicResultSets() > 0)
/////////////////////////////////////////////////////////////////////////
1: 				int parameterMode = rai.getParameterModes()[ getRoutineArgIdx( rai, p ) ];
/////////////////////////////////////////////////////////////////////////
1:                              rai,
/////////////////////////////////////////////////////////////////////////
1:                          rai,
/////////////////////////////////////////////////////////////////////////
1: 			this.routineInfo = rai;
/////////////////////////////////////////////////////////////////////////
0:          Vector aggregateVector,
1:          RoutineAliasInfo rai,
/////////////////////////////////////////////////////////////////////////
1:                      rai.getParameterNames()[p]
commit:e081c85
/////////////////////////////////////////////////////////////////////////
1:                 !javaClassName.startsWith( "org.apache.derby.impl.tools.optional." ) &&
1:                 !javaClassName.startsWith( "org.apache.derby.vti." )
commit:ea335da
/////////////////////////////////////////////////////////////////////////
1:             //
1:             // A special exception is made for the optional tools methods.
1:             if (
1:                 javaClassName.startsWith( "org.apache.derby." ) &&
0:                 !javaClassName.startsWith( "org.apache.derby.impl.tools.optional." )
1:                 )
commit:ba70926
/////////////////////////////////////////////////////////////////////////
0: 				int parameterMode = routineInfo.getParameterModes()[ getRoutineArgIdx( routineInfo, p ) ];
/////////////////////////////////////////////////////////////////////////
1:                              methodParms.length,
/////////////////////////////////////////////////////////////////////////
1:                          methodParms.length,
/////////////////////////////////////////////////////////////////////////
1: 					String parameterType = methodParameterTypes[ getRoutineArgIdx( parameterNumber ) ];
/////////////////////////////////////////////////////////////////////////
1: 			String methodParameterType = methodParameterTypes[ getRoutineArgIdx( parameterNumber ) ];
1: 
1:             // if a varargs arg, then strip off the extra array dimension added by varargs
1:             if ( isVararg( parameterNumber ) )
1:             {
1:                 methodParameterType = stripOneArrayLevel( methodParameterType );
1:                 arrayType = stripOneArrayLevel( arrayType );
1:             }
1:             
1:             { outParamArrays = new LocalField[methodParms.length]; }
/////////////////////////////////////////////////////////////////////////
1: 					int parameterMode = parameterModes[ getRoutineArgIdx( i ) ];
1:                     
/////////////////////////////////////////////////////////////////////////
1:                         // if this is a varargs arg then we have to strip off another array level
0:                         Class   cellType = ((java.lang.reflect.Method) method).getParameterTypes()[ getRoutineArgIdx( i ) ].
1:                             getComponentType();
0:                         if ( isVararg( i ) ) { cellType = cellType.getComponentType(); }
1: 						boolean isPrimitive = cellType.isPrimitive();
commit:232d09a
/////////////////////////////////////////////////////////////////////////
1: 		resolveMethodCall( javaClassName, true );
/////////////////////////////////////////////////////////////////////////
0:             boolean hasVarargs = routineInfo.hasVarargs();
1: 
1:             if ( hasVarargs )
1:             {
1:                 // a varargs method can be called with no values supplied
1:                 // for the trailing varargs argument
1:                 if ( methodParms.length < (parameterCount - 1) ) { continue; }
1:             }
1: 			else if (parameterCount != methodParms.length)
1:             { continue; }
/////////////////////////////////////////////////////////////////////////
1:             { sigParameterCount++; }
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 //
1:                 // Now coerce the actual method parameter to the declared type
1:                 // of this routine arg.
1:                 //
1:                 // if this is the last argument of a varargs routine...
1:                 if ( hasVarargs && (p == parameterCount-1) )
1:                 {
1:                     //
1:                     // The invocation of a varargs routine may have more actual parameters
1:                     // than the number of declared routine arguments. All of the trailing
1:                     // parameters must be coercible to the type of the last declared argument.
1:                     // Furthermore, it may turn out that there isn't a parameter corresponding to the last
1:                     // declared argument of the varargs routine.
1:                     //
1:                     for ( int idx = p; idx < methodParms.length; idx++ )
1:                     {
1:                         coerceMethodParameter
1:                             (
0:                              fromList, subqueryList, aggregateVector,
0:                              parameterCount,
1:                              paramdtd, parameterTypeId, parameterMode,
1:                              idx
1:                              );
1:                     }
1:                 }
1:                 else    // NOT the last argument of a varargs routine
1:                 {
1:                     coerceMethodParameter
0:                          fromList, subqueryList, aggregateVector,
0:                          parameterCount,
1:                          paramdtd, parameterTypeId, parameterMode,
1:                          p
1:                 }
/////////////////////////////////////////////////////////////////////////
1: 			// SQL, note that we are in system code.
1: 			if (
1:                 sd.isSystemSchema() &&
1:                 (routineInfo.getReturnType() == null) &&
1:                 routineInfo.getSQLAllowed() != RoutineAliasInfo.NO_SQL
1:                 )
1:             { isSystemCode = true; }
/////////////////////////////////////////////////////////////////////////
1:      * <p>
1:      * Coerce an actual method parameter to the declared type of the corresponding
1:      * routine argument.
1:      * </p>
1:      */
1:     private void    coerceMethodParameter
1:         (
1:          FromList fromList,
1:          SubqueryList subqueryList,
0:          Vector aggregateVector, 
1:          int    parameterCount, // number of declared routine args
1:          DataTypeDescriptor paramdtd,   // declared type of routine arg
1:          TypeId parameterTypeId,    // declared type id of routine arg
1:          int    parameterMode,
1:          int    p   // index of actual method parameter in array of parameters
1:          )
1:         throws StandardException
1:     {
1:         // check parameter is a ? node for INOUT and OUT parameters.
1: 
1:         ValueNode sqlParamNode = null;
1: 
1:         if (methodParms[p] instanceof SQLToJavaValueNode)
1:         {
1:             SQLToJavaValueNode sql2j = (SQLToJavaValueNode) methodParms[p];
1:             sqlParamNode = sql2j.getSQLValueNode();
1:         }
1: 
1:         boolean isParameterMarker = true;
1:         if ((sqlParamNode == null) || !sqlParamNode.requiresTypeFromContext())
1:         {
0:             if (parameterMode != JDBC30Translation.PARAMETER_MODE_IN)
1:             {
1:                 throw StandardException.newException
1:                     (
1:                      SQLState.LANG_DB2_PARAMETER_NEEDS_MARKER,
1:                      RoutineAliasInfo.parameterMode(parameterMode),
0:                      routineInfo.getParameterNames()[p]
1:                      );
1:             }
1:             isParameterMarker = false;
1:         }
1:         else
1:         {
1:             if (applicationParameterNumbers == null)
1:             { applicationParameterNumbers = new int[parameterCount]; }
1:             if (sqlParamNode instanceof UnaryOperatorNode)
1:             {
1:                 ParameterNode pn = ((UnaryOperatorNode)sqlParamNode).getParameterOperand();
1:                 applicationParameterNumbers[p] = pn.getParameterNumber();
1:             } else
1:             { applicationParameterNumbers[p] = ((ParameterNode) sqlParamNode).getParameterNumber(); }
1:         }
1: 
1:         boolean needCast = false;
1:         if (!isParameterMarker)
1:         {
1:             // can only be an IN parameter.
1:             // check that the value can be assigned to the
1:             // type of the procedure parameter.
1:             if (sqlParamNode instanceof UntypedNullConstantNode)
1:             {
1:                 sqlParamNode.setType(paramdtd);
1:             }
1:             else
1:             {
1:                 DataTypeDescriptor dts;
1:                 TypeId argumentTypeId;
1:                 
1:                 if (sqlParamNode != null)
1:                 {
1:                     // a node from the SQL world
1:                     argumentTypeId = sqlParamNode.getTypeId();
1:                     dts = sqlParamNode.getTypeServices();
1:                 }
1:                 else
1:                 {
1:                     // a node from the Java world
1:                     dts = DataTypeDescriptor.getSQLDataTypeDescriptor(methodParms[p].getJavaTypeName());
1:                     if (dts == null)
1:                     {
1:                         throw StandardException.newException
1:                             (
1:                              SQLState.LANG_NO_CORRESPONDING_S_Q_L_TYPE, 
1:                              methodParms[p].getJavaTypeName()
1:                              );
1:                     }
1: 
1:                     argumentTypeId = dts.getTypeId();
1:                 }
1: 
1:                 if (! getTypeCompiler(parameterTypeId).storable(argumentTypeId, getClassFactory()))
1:                 {
1:                     throw StandardException.newException
1:                         (
1:                          SQLState.LANG_NOT_STORABLE, 
1:                          parameterTypeId.getSQLTypeName(),
1:                          argumentTypeId.getSQLTypeName()
1:                          );
1:                 }
1: 
1:                 // if it's not an exact length match then some cast will be needed.
1:                 if (!paramdtd.isExactTypeAndLengthMatch(dts))   { needCast = true; }
1:             }
1:         }
1:         else
1:         {
1:             // any variable length type will need a cast from the
1:             // Java world (the ? parameter) to the SQL type. This
1:             // ensures values like CHAR(10) are passed into the procedure
1:             // correctly as 10 characters long.
1:             if (parameterTypeId.variableLength())
1:             {
0:                 if (parameterMode != JDBC30Translation.PARAMETER_MODE_OUT)
1:                 { needCast = true; }
1:             }
1:         }
1: 
1:         if (needCast)
1:         {
1:             // push a cast node to ensure the
1:             // correct type is passed to the method
1:             // this gets tacky because before we knew
1:             // it was a procedure call we ensured all the
1:             // parameter are JavaNodeTypes. Now we need to
1:             // push them back to the SQL domain, cast them
1:             // and then push them back to the Java domain.
1:             
1:             if (sqlParamNode == null)
1:             {
0:                 sqlParamNode = (ValueNode) getNodeFactory().getNode
1:                     (
0:                      C_NodeTypes.JAVA_TO_SQL_VALUE_NODE,
0:                      methodParms[p], 
1:                      getContextManager()
1:                      );
1:             }
1: 
1:             ValueNode castNode = makeCast
1:                 (
1:                  sqlParamNode,
1:                  paramdtd,
0:                  getNodeFactory(),
1:                  getContextManager()
1:                  );
1: 
0:             methodParms[p] = (JavaValueNode) getNodeFactory().getNode
1:                 (
0:                  C_NodeTypes.SQL_TO_JAVA_VALUE_NODE,
0:                  castNode, 
1:                  getContextManager()
1:                  );
1: 
0:             methodParms[p] = methodParms[p].bindExpression(fromList, subqueryList, aggregateVector);
1:         }
1: 
1:         // only force the type for a ? so that the correct type shows up
1:         // in parameter meta data
1:         if (isParameterMarker)  { sqlParamNode.setType(paramdtd); }
1:     }
1: 
1:     /**
/////////////////////////////////////////////////////////////////////////
1: 			parameterMode = routineInfo.getParameterModes()[ getRoutineArgIdx( parameterNumber ) ];
/////////////////////////////////////////////////////////////////////////
1: 		// add in the ResultSet arrays. note that varargs and dynamic ResultSets
1:         // both make claims on the trailing arguments of the method invocation.
1:         // a routine may make use of both varargs and dynamic ResultSets.
1: 		if ( routineInfo != null && !hasVarargs() )
1:         {
commit:63e0910
/////////////////////////////////////////////////////////////////////////
1:     private boolean appearsInGroupBy = false;
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     /** Flag that this function invocation appears in a GROUP BY clause */
1:     public  void    setAppearsInGroupBy() { appearsInGroupBy = true; }
/////////////////////////////////////////////////////////////////////////
1:                 // The parser may have noticed that this aggregate is invoked in a
1:                 // GROUP BY clause. That is not allowed.
1:                 if ( appearsInGroupBy )
1:                 {
1:                     throw StandardException.newException(SQLState.LANG_AGGREGATE_IN_GROUPBY_LIST);
1:                 }
1:                 
commit:2cf546d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.context.ContextManager;
0: import org.apache.derby.iapi.sql.compile.NodeFactory;
/////////////////////////////////////////////////////////////////////////
0: 					ValueNode castNode = makeCast
0:                         (
0:                          sqlParamNode,
0:                          paramdtd,
0:                          getNodeFactory(),
0:                          getContextManager()
1:                          );
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Wrap a parameter in a CAST node.
1:      */
0:     public  static  ValueNode   makeCast
0:         ( ValueNode parameterNode, DataTypeDescriptor targetType, NodeFactory nodeFactory, ContextManager cm )
1:         throws StandardException
1:     {
0:         ValueNode castNode = (ValueNode) nodeFactory.getNode
0:             (
0:              C_NodeTypes.CAST_NODE,
0:              parameterNode, 
0:              targetType,
0:              cm
1:              );
1: 
1:         // Argument type has the same semantics as assignment:
1:         // Section 9.2 (Store assignment). There, General Rule 
1:         // 2.b.v.2 says that the database should raise an exception
1:         // if truncation occurs when stuffing a string value into a
1:         // VARCHAR, so make sure CAST doesn't issue warning only.
1:         ((CastNode)castNode).setAssignmentSemantics();
1: 
1:         return castNode;
1:     }
1: 
commit:d389f7d
/////////////////////////////////////////////////////////////////////////
0: 			resolveRoutine( fromList, subqueryList, aggregateVector, sd );
/////////////////////////////////////////////////////////////////////////
1:         if ( (ad == null) && (methodParms.length == 1) )
0:             ad = AggregateNode.resolveAggregate( getDataDictionary(), sd, methodName );
commit:c8603c4
/////////////////////////////////////////////////////////////////////////
1:     private AggregateNode   resolvedAggregate;
1: 
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Get the aggregate, if any, which this method call resolves to.
1:      */
1:     public  AggregateNode   getResolvedAggregate() { return resolvedAggregate; }
1:     
/////////////////////////////////////////////////////////////////////////
1:             if ( (ad != null) && (ad.getAliasType() == AliasInfo.ALIAS_TYPE_AGGREGATE_AS_CHAR) )
1:             {
0:                 resolvedAggregate = (AggregateNode) getNodeFactory().getNode
0:                     (
0:                      C_NodeTypes.AGGREGATE_NODE,
1:                      ((SQLToJavaValueNode) methodParms[ 0 ]).getSQLValueNode(),
1:                      new UserAggregateDefinition( ad ), 
0:                      Boolean.FALSE,
1:                      ad.getJavaClassName(),
0:                      getContextManager()
1:                      );
1: 
1:                 return this;
1:             }
1: 
/////////////////////////////////////////////////////////////////////////
1:         }
1: 
0:         if ( ad == null )
1:         {
0:             resolveAggregate( fromList, subqueryList, aggregateVector, sd );
1:         }
0: 	 * Resolve a user-defined aggregate.
1:      *
0: 	 * @param fromList
0: 	 * @param subqueryList
0: 	 * @param aggregateVector
0: 	 * @param sd
0: 	 * @throws StandardException
1: 	 */
0: 	private void resolveAggregate
0:         (FromList fromList, SubqueryList subqueryList, Vector aggregateVector, SchemaDescriptor sd)
1:         throws StandardException
1:     {
0:         // aggregates have only 1 argument
0:         if ( methodParms.length != 1 ) { return; }
1:         
0: 		java.util.List list = getDataDictionary().getRoutineList
0:             ( sd.getUUID().toString(), methodName, AliasInfo.ALIAS_NAME_SPACE_AGGREGATE_AS_CHAR );
1: 
0:         for ( int i = 0; i < list.size(); i++ )
1:         {
0:             ad = (AliasDescriptor) list.get( i );
1:             break;
1:         }
1:     }
1:     
1: 	/**
commit:aec2537
/////////////////////////////////////////////////////////////////////////
1:             //
1:             // We also skip the optimization if the argument must be cast to a primitive. In this case we need
1:             // a runtime check to make sure that the argument is not null. See DERBY-4459.
1:             //
1:             if ( (methodParms != null) && methodParms[ parm ].mustCastToPrimitive() ) { continue; }
1:             
commit:4bad559
/////////////////////////////////////////////////////////////////////////
1: 						case java.sql.Types.BOOLEAN:
commit:33bfdc0
/////////////////////////////////////////////////////////////////////////
1: 						boolean isAnsiUDT = paramdtd.getTypeId().getBaseTypeId().isAnsiUDT();
/////////////////////////////////////////////////////////////////////////
1: 						// The value needs to be set thorugh the setValue(Object) method.
1: 						if (isAnsiUDT)
1: 						{
1: 							mb.upCast("java.lang.Object");
1: 						}
1: 
commit:d6c2047
/////////////////////////////////////////////////////////////////////////
1: 
1:             // create type dependency if return type is an ANSI UDT
1:             if ( returnType != null ) { createTypeDependency( DataTypeDescriptor.getType( returnType ) ); }
1: 
commit:ec60795
/////////////////////////////////////////////////////////////////////////
1:      * This optimization is not available if the outer function is
1: 	 * RETURN NULL ON NULL INPUT. That is because the SQLToJavaNode is
1: 	 * responsible for compiling the byte code which skips the method call if
1:      * the parameter is null--if we remove the SQLToJavaNode, then we don't
1:      * compile that check and we get bug DERBY-1030.
1: 
1:         //
1:         // This optimization is not possible if we are compiling a call to
1:         // a NULL ON NULL INPUT method. See DERBY-1030 and the header
1:         // comment above.
1:         //
1:         if ( !routineInfo.calledOnNullInput() ) { return; }
1:         
commit:d039ced
/////////////////////////////////////////////////////////////////////////
1: 			if ( returnType != null && !returnType.isRowMultiSet() && !returnType.isUserDefinedType() )
/////////////////////////////////////////////////////////////////////////
1: 				TypeId typeId = TypeId.getTypeId(td);
commit:5a0cfa2
/////////////////////////////////////////////////////////////////////////
1:             if ( permitsSQL( routineInfo ) )
1:             {
1:                 checkReliability( getMethodName(), CompilerContext.SQL_IN_ROUTINES_ILLEGAL );
1:             }
/////////////////////////////////////////////////////////////////////////
1: 	 * Returns true if the routine permits SQL.
1: 	 */
1:     private boolean permitsSQL( RoutineAliasInfo rai )
1:     {
1:         short       sqlAllowed = rai.getSQLAllowed();
1: 
1:         switch( sqlAllowed )
1:         {
1:         case RoutineAliasInfo.MODIFIES_SQL_DATA:
1:         case RoutineAliasInfo.READS_SQL_DATA:
1:         case RoutineAliasInfo.CONTAINS_SQL:
1:             return true;
1: 
1:         default:    return false;
1:         }
1:     }
1:     
1: 	/**
commit:95a483d
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             if ( !routineInfo.isDeterministic() )
1:             {
1:                 checkReliability( getMethodName(), CompilerContext.NON_DETERMINISTIC_ILLEGAL );
1:             }
1: 			
commit:68573fc
/////////////////////////////////////////////////////////////////////////
1: 			int compiledResultSets = methodParameterTypes.length - methodParms.length;
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
commit:7b398e9
/////////////////////////////////////////////////////////////////////////
0: 			int compiledResultSets = getCompiledResultSetCount();
/////////////////////////////////////////////////////////////////////////
1:                 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
commit:4aef9b0
/////////////////////////////////////////////////////////////////////////
0: 			if (returnType != null && !returnType.isRowMultiSet())
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:0cefeda
/////////////////////////////////////////////////////////////////////////
1:                      procedureName,
commit:065a81f
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * This flag is true while bindExpression() is executing. It is used to
1:      * avoid infinite recursion when bindExpression() is reentered.
1:      */
1:     private boolean isInsideBind;
/////////////////////////////////////////////////////////////////////////
1:         if (isInsideBind) {
1:             return this;
1:         }
1:         isInsideBind = true;
1:         try {
1:             return bindExpressionMinion(fromList, subqueryList, aggregates);
1:         } finally {
1:             isInsideBind = false;
1:         }
1:     }
1:     private JavaValueNode bindExpressionMinion(
1:             FromList fromList,
1:             SubqueryList subqueryList,
1:             List<AggregateNode> aggregates)
1:         throws StandardException
1:     {
/////////////////////////////////////////////////////////////////////////
commit:9d9f6dd
/////////////////////////////////////////////////////////////////////////
1: 
1:             if (noSchema) {
1:                 // If no schema was specified, register where we found the
1:                 // routine.
1:                 procedureName.setSchemaName(sd.getSchemaName());
1:             }
1: 
commit:69f8afa
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.compile.Visitor;
/////////////////////////////////////////////////////////////////////////
1: 
1:     @Override
1:     void acceptChildren(Visitor v) throws StandardException {
1:         super.acceptChildren(v);
1: 
1:         if (procedureName != null) {
1:             procedureName = (TableName) procedureName.accept(v);
1:         }
1:     }
commit:e33b8d8
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import java.sql.ParameterMetaData;
/////////////////////////////////////////////////////////////////////////
1:                 if (parameterMode != (ParameterMetaData.parameterModeIn)) {
/////////////////////////////////////////////////////////////////////////
1:             if (parameterMode != (ParameterMetaData.parameterModeIn))
/////////////////////////////////////////////////////////////////////////
1:                 if (parameterMode != (ParameterMetaData.parameterModeOut))
/////////////////////////////////////////////////////////////////////////
1:             parameterMode = (ParameterMetaData.parameterModeIn);
/////////////////////////////////////////////////////////////////////////
1:                         constructor.push(ParameterMetaData.parameterModeUnknown);
/////////////////////////////////////////////////////////////////////////
1:         case (ParameterMetaData.parameterModeIn):
1:         case (ParameterMetaData.parameterModeInOut):
1:         case (ParameterMetaData.parameterModeUnknown):
1:         case (ParameterMetaData.parameterModeOut):
1:         case (ParameterMetaData.parameterModeIn):
1:         case (ParameterMetaData.parameterModeUnknown):
1:         case (ParameterMetaData.parameterModeInOut):
1:         case (ParameterMetaData.parameterModeOut):
/////////////////////////////////////////////////////////////////////////
1:             if (parameterMode != (ParameterMetaData.parameterModeOut)) {
/////////////////////////////////////////////////////////////////////////
1:                     if (parameterMode != (ParameterMetaData.parameterModeIn)) {
commit:9f2ed7d
/////////////////////////////////////////////////////////////////////////
1:     void generateOneParameter(ExpressionClassBuilder acb,
/////////////////////////////////////////////////////////////////////////
1:     boolean categorize(JBitSet referencedTabs, boolean simplePredsOnly)
/////////////////////////////////////////////////////////////////////////
1:     void generateExpression(ExpressionClassBuilder acb, MethodBuilder mb)
commit:09c2697
/////////////////////////////////////////////////////////////////////////
1:      *                      expression is in, for binding columns.
1:      * @param subqueryList  The subquery list being built as we find SubqueryNodes
1:      * @param aggregates    The aggregate list being built as we find AggregateNodes
1:     JavaValueNode bindExpression(
0:         FromList fromList, SubqueryList subqueryList, List aggregates)
/////////////////////////////////////////////////////////////////////////
1:         bindParameters(fromList, subqueryList, aggregates);
/////////////////////////////////////////////////////////////////////////
0:             resolveRoutine( fromList, subqueryList, aggregates, sd );
/////////////////////////////////////////////////////////////////////////
0:                 resolveRoutine(fromList, subqueryList, aggregates, sd);
/////////////////////////////////////////////////////////////////////////
0:                     resolveRoutine(fromList, subqueryList, aggregates, sd);
/////////////////////////////////////////////////////////////////////////
0:                     resolveRoutine(fromList, subqueryList, aggregates, sd);
/////////////////////////////////////////////////////////////////////////
1:                     return returnValueToJava.bindExpression(fromList, subqueryList, aggregates);
/////////////////////////////////////////////////////////////////////////
0:                                 List aggregates, SchemaDescriptor sd)
/////////////////////////////////////////////////////////////////////////
1:                              fromList, subqueryList, aggregates,
/////////////////////////////////////////////////////////////////////////
1:                          fromList, subqueryList, aggregates,
/////////////////////////////////////////////////////////////////////////
0:          List aggregates,
/////////////////////////////////////////////////////////////////////////
1:             methodParms[p] = methodParms[p].bindExpression(
1:                     fromList, subqueryList, aggregates);
commit:f33fbaf
/////////////////////////////////////////////////////////////////////////
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
0: 		List aggregateVector)
/////////////////////////////////////////////////////////////////////////
1:     private void resolveRoutine(FromList fromList, SubqueryList subqueryList,
0:                                 List aggregateVector, SchemaDescriptor sd)
1:             throws StandardException {
/////////////////////////////////////////////////////////////////////////
0:          List aggregateVector,
commit:bbd82de
/////////////////////////////////////////////////////////////////////////
1: 					typeId = TypeId.getUserDefinedTypeId(arrayType);
/////////////////////////////////////////////////////////////////////////
1: 						TypeId.getUserDefinedTypeId("java.sql.ResultSet[]"),
commit:c6892a1
/////////////////////////////////////////////////////////////////////////
1: 						// constructor  - setting up correct parameter type info
/////////////////////////////////////////////////////////////////////////
1: 				// constructor  - setting up correct parameter type info
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:0c5bc3a
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
/////////////////////////////////////////////////////////////////////////
1:      * The generated code calls pushNestedSessionContext.
1:      * @see LanguageConnectionContext#pushNestedSessionContext
1:     private void generatePushNestedSessionContext(
/////////////////////////////////////////////////////////////////////////
1:         //       pushNestedSessionContext((Activation)this);
/////////////////////////////////////////////////////////////////////////
1:                       "pushNestedSessionContext",
/////////////////////////////////////////////////////////////////////////
1:                 generatePushNestedSessionContext(
commit:2706d1f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:e1f49ca
/////////////////////////////////////////////////////////////////////////
1: import java.lang.reflect.Method;
/////////////////////////////////////////////////////////////////////////
1:                         Class<?> cellType = ((Method) method).
1:                                 getParameterTypes()[ getRoutineArgIdx( i ) ].
0:                                 getComponentType();
1: 
1:                         if ( isVararg( i ) ) {
1:                             cellType = cellType.getComponentType();
1:                         }
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.catalog.AliasInfo;
1: import org.apache.derby.catalog.TypeDescriptor;
1: import org.apache.derby.catalog.types.RoutineAliasInfo;
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.reference.ClassName;
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.services.classfile.VMOpcode;
1: import org.apache.derby.iapi.services.compiler.LocalField;
1: import org.apache.derby.iapi.services.compiler.MethodBuilder;
0: import org.apache.derby.iapi.services.context.ContextManager;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
1: import org.apache.derby.iapi.sql.compile.CompilerContext;
1: import org.apache.derby.iapi.sql.conn.Authorizer;
1: import org.apache.derby.iapi.sql.dictionary.AliasDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
1: import org.apache.derby.iapi.types.DataTypeDescriptor;
1: import org.apache.derby.iapi.types.JSQLType;
1: import org.apache.derby.iapi.types.StringDataValue;
1: import org.apache.derby.iapi.types.TypeId;
1: import org.apache.derby.iapi.util.JBitSet;
/////////////////////////////////////////////////////////////////////////
1:     Since this is a dynamic decision we compile in code to take both paths,
1:     based upon a boolean is INOUT which is derived from the
1:     ParameterValueSet. Code is logically (only single parameter String[] shown
1:     here). Note, no casts can exist here.
/////////////////////////////////////////////////////////////////////////
1: class StaticMethodCallNode extends MethodCallNode
/////////////////////////////////////////////////////////////////////////
1:      * Constructor for a NonStaticMethodCallNode
1:      * @param javaClassName     The name of the java class that the static
1:      *                          method belongs to.
1:      * @param cm                The context manager
1:     StaticMethodCallNode(
1:             String methodName,
1:             String javaClassName,
1:             ContextManager cm) {
1:         super(methodName, cm);
0:         setNodeType(C_NodeTypes.STATIC_METHOD_CALL_NODE);
1:         this.javaClassName = javaClassName;
1:     }
1:     /**
1:      * Constructor for a StaticMethodCallNode
1:      *
1:      * @param methodName        The name of the method to call
1:      * @param javaClassName     The name of the java class that the static
1:      *                          method belongs to.
1:      * @param cm                The context manager
1:      */
1:     StaticMethodCallNode(
1:             TableName methodName,
1:             String javaClassName,
1:             ContextManager cm) {
1:         super(methodName.getTableName(), cm);
1:         procedureName = methodName;
0:         setNodeType(C_NodeTypes.STATIC_METHOD_CALL_NODE);
1:         this.javaClassName = javaClassName;
1:     }
/////////////////////////////////////////////////////////////////////////
1:                 resolvedAggregate = new AggregateNode(
1:                      false,
/////////////////////////////////////////////////////////////////////////
1:                     ValueNode returnValueToSQL =
1:                             new JavaToSQLValueNode(this, getContextManager());
1:                     ValueNode returnValueCastNode = new CastNode(
/////////////////////////////////////////////////////////////////////////
1:                     JavaValueNode returnValueToJava = new SQLToJavaValueNode(
1:                             returnValueCastNode, getContextManager());
/////////////////////////////////////////////////////////////////////////
1:         List<AliasDescriptor> list = getDataDictionary().getRoutineList(
1:             sd.getUUID().toString(),
1:             methodName,
1:             forCallStatement ?
1:                 AliasInfo.ALIAS_NAME_SPACE_PROCEDURE_AS_CHAR :
1:                 AliasInfo.ALIAS_NAME_SPACE_FUNCTION_AS_CHAR);
1:             AliasDescriptor proc = list.get(i);
/////////////////////////////////////////////////////////////////////////
1:                 sqlParamNode =
1:                     new JavaToSQLValueNode(methodParms[p], getContextManager());
1:             methodParms[p] =
1:                     new SQLToJavaValueNode(castNode, getContextManager());
/////////////////////////////////////////////////////////////////////////
1:     public static ValueNode makeCast (ValueNode parameterNode,
1:                                       DataTypeDescriptor targetType,
1:                                       ContextManager cm)
1:         ValueNode castNode = new CastNode(parameterNode, targetType, cm);
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
commit:946f53d
/////////////////////////////////////////////////////////////////////////
1:             SchemaDescriptor savedSd = sd;
1: 
1:             if (ad == null && noSchema && !forCallStatement)
1:             {
1:                 // Resolve to a built-in SYSFUN function but only
1:                 // if this is a function call and the call
1:                 // was not qualified. E.g. COS(angle). The
1:                 // SYSFUN functions are not in SYSALIASES but
1:                 // an in-memory table, set up in DataDictioanryImpl.
1:                 sd = getSchemaDescriptor("SYSFUN", true);
1: 
0:                 resolveRoutine(fromList, subqueryList, aggregateVector, sd);
1:             }
1: 
1:             if (ad == null) {
1:                 // DERBY-2927. Check if a procedure is being used as a
1:                 // function, or vice versa.
1:                 sd = savedSd;
1: 
1:                 if (!forCallStatement) {
1:                     // Procedure as function. We have JDBC escape syntax which
1:                     // may entice users to try that:
1:                     //      "{? = CALL <proc>}"
1:                     //
1:                     // but we don't currently support it (it's not std SQL
1:                     // either). By resolving it as a procedure we can give a
1:                     // better error message.
1:                     //
1:                     // Note that with the above escape syntax one *can* CALL a
1:                     // function, though:
1:                     //      "{? = CALL <func>}"
1:                     //
1:                     // but such cases have already been resolved above.
1: 
1:                     forCallStatement = true; // temporarily: resolve
1:                                              // as procedure
0:                     resolveRoutine(fromList, subqueryList, aggregateVector, sd);
1:                     forCallStatement = false; // restore it
1: 
1:                     if (ad != null) {
1:                         throw StandardException.newException
1:                             (SQLState.LANG_PROC_USED_AS_FUNCTION,
1:                              procedureName);
1:                     }
1:                 } else {
1:                     // Maybe a function is being CALLed ?
1:                     forCallStatement = false; // temporarily: resolve
1:                                               // as function
0:                     resolveRoutine(fromList, subqueryList, aggregateVector, sd);
1:                     forCallStatement = true; // restore it
1: 
1:                     if (ad != null) {
1:                         throw StandardException.newException
1:                             (SQLState.LANG_FUNCTION_USED_AS_PROC,
1:                              procedureName);
1:                     }
1:                 }
1:             }
1: 
commit:eff9169
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                     // Argument type has the same semantics as assignment:
0:                     // Section 9.2 (Store assignment). There, General Rule 
0:                     // 2.b.v.2 says that the database should raise an exception
0:                     // if truncation occurs when stuffing a string value into a
0:                     // VARCHAR, so make sure CAST doesn't issue warning only.
0:                     ((CastNode)castNode).setAssignmentSemantics();
commit:9f60172
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Authorization id of user owning schema in which routine is defined.
1:      */
1:     private String routineDefiner = null;
/////////////////////////////////////////////////////////////////////////
1:             routineDefiner = sd.getAuthorizationId();
1: 
/////////////////////////////////////////////////////////////////////////
0:     private void generateSetupNestedSessionContext(
1:         ActivationClassBuilder acb,
1:         MethodBuilder mb,
1:         boolean hadDefinersRights,
1:         String definer) throws StandardException {
/////////////////////////////////////////////////////////////////////////
1:         mb.push(hadDefinersRights);
1:         mb.push(definer);
1:                       "void", 3);
/////////////////////////////////////////////////////////////////////////
0:                 generateSetupNestedSessionContext(
1:                     (ActivationClassBuilder) acb,
1:                     mb,
1:                     routineInfo.hasDefinersRights(),
1:                     routineDefiner);
commit:6950a39
/////////////////////////////////////////////////////////////////////////
1: 	 * Add code to set up the SQL session context for a stored
1: 	 * procedure or function which needs a nested SQL session
1: 	 * context (only needed for those which can contain SQL).
1: 	 *
0: 	 * The generated code calls setupNestedSessionContext.
0: 	 * @see org.apache.derby.iapi.sql.conn.LanguageConnectionContext#setupNestedSessionContext
1: 	 *
1: 	 * @param acb activation class builder
1: 	 * @param mb  method builder
1: 	 */
0: 	private void generateSetupNestedSessionContext(ActivationClassBuilder acb,
0: 												   MethodBuilder mb) {
1: 
1: 		// Generates the following Java code:
1: 		// ((Activation)this).getLanguageConnectionContext().
0: 		//       setupNestedSessionContext((Activation)this);
1: 
1: 		acb.pushThisAsActivation(mb);
1: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, null,
1: 					  "getLanguageConnectionContext",
1: 					  ClassName.LanguageConnectionContext, 0);
1: 		acb.pushThisAsActivation(mb);
1: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, null,
0: 					  "setupNestedSessionContext",
0: 					  "void", 1);
1: 	}
1: 
1: 
1: 	/**
/////////////////////////////////////////////////////////////////////////
1: 			// If no SQL, there is no need to setup a nested session
1: 			// context.
1: 			if (sqlAllowed != RoutineAliasInfo.NO_SQL) {
0: 				generateSetupNestedSessionContext((ActivationClassBuilder) acb,
0: 												  mb);
1: 			}
1: 
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:0a6ce0b
/////////////////////////////////////////////////////////////////////////
1: 			// DERBY-3360. In the case of function returning
1: 			// a SMALLINT if we specify RETURN NULL ON NULL INPUT
1: 			// the javaReturnType will be java.lang.Integer. In
1: 			// order to initialize the integer properly, we need
1: 			// to upcast the short.  This is a special case for
1: 			// SMALLINT functions only as other types are 
1: 			// compatible with their function return types.
1: 			if (!actualMethodReturnType.equals(javaReturnType)) {
1: 				if (actualMethodReturnType.equals("short") &&
1: 						javaReturnType.equals("java.lang.Integer"))
1: 					mbnc.upCast("int");
1: 			
1: 			}
commit:72abc72
/////////////////////////////////////////////////////////////////////////
1: 					// DERBY-2972  Match the collation of the RoutineAliasInfo		
0: 					returnValueDtd.setCollationType(returnType.getCollationType());
0:                                         returnValueDtd.setCollationDerivation(StringDataValue.COLLATION_DERIVATION_IMPLICIT);
/////////////////////////////////////////////////////////////////////////
1: 					returnValueToJava.setCollationType(returnType.getCollationType());
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:9ed7c4d
/////////////////////////////////////////////////////////////////////////
1: 							
1: 
/////////////////////////////////////////////////////////////////////////
1:                     
0:                     // DERBY-2972  Match the collation of the RoutineAliasInfo
1:                     returnValueCastNode.setCollationInfo(
1:                             returnType.getCollationType(),
1:                             StringDataValue.COLLATION_DERIVATION_IMPLICIT);
commit:e604a71
/////////////////////////////////////////////////////////////////////////
1: 			String schemaName = procedureName.getSchemaName();
1: 								
1: 			boolean noSchema = schemaName == null;
1: 			SchemaDescriptor sd = getSchemaDescriptor(schemaName, schemaName != null);
1:             // The field methodName is used by resolveRoutine and
1:             // is set to the name of the routine (procedureName.getTableName()).
0: 			resolveRoutine(fromList, subqueryList, aggregateVector, sd);
1: 			
0: 			if (ad == null && noSchema && !forCallStatement)
1: 			{
0: 				// Resolve to a built-in SYSFUN function but only
0: 				// if this is a function call and the call
0: 				// was not qualified. E.g. COS(angle). The
0: 				// SYSFUN functions are not in SYSALIASES but
0: 				// an in-memory table, set up in DataDictioanryImpl.
0: 				sd = getSchemaDescriptor("SYSFUN", true);
0: 				resolveRoutine(fromList, subqueryList, aggregateVector, sd);
1: 	
1: 			/* Throw exception if no routine found */
1: 				throw StandardException.newException(
1:                         SQLState.LANG_NO_SUCH_METHOD_ALIAS, procedureName);
/////////////////////////////////////////////////////////////////////////
1:             
1:             // DERBY-2330 Do not allow a routine to resolve to
1:             // a Java method that is part of the Derby runtime code base.
1:             // This is a security measure to stop user-defined routines
1:             // bypassing security by making calls directly to Derby's
1:             // internal methods. E.g. open a table's conglomerate
1:             // directly and read the file, bypassing any authorization.
1:             // This is a simpler mechanism than analyzing all of
1:             // Derby's public static methods and ensuring they have
1:             // no Security holes.
0:             if (javaClassName.startsWith("org.apache.derby."))
1:             {
1:                 if (!sd.isSystemSchema())
1:                     throw StandardException.newException(
1:                         SQLState.LANG_TYPE_DOESNT_EXIST2, (Throwable) null,
1:                         javaClassName);
1:             }
commit:2e1b5e8
/////////////////////////////////////////////////////////////////////////
1: 		verifyClassExist(javaClassName);
commit:7d3ddb1
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Generated boolean field to hold the indicator
1:      * for if any of the parameters to a
1:      * RETURNS NULL ON NULL INPUT function are NULL.
1:      * Only set if this node is calling such a function.
1:      * Set at generation time.
1:      */
commit:2d2e717
/////////////////////////////////////////////////////////////////////////
1: 		if (isPrivilegeCollectionRequired())
1: 			getCompilerContext().addRequiredRoutinePriv(ad);
commit:3905037
/////////////////////////////////////////////////////////////////////////
1: 			if (methodParms != null) 
1: 				optimizeDomainValueConversion();
1: 			
/////////////////////////////////////////////////////////////////////////
1: 	 * If this SQL function has parameters which are SQLToJavaValueNode over
1: 	 * JavaToSQLValueNode and the java value node underneath is a SQL function
1: 	 * defined with CALLED ON NULL INPUT, then we can get rid of the wrapper
1: 	 * nodes over the java value node for such parameters. This is because
1: 	 * SQL functions defined with CALLED ON NULL INPUT need access to only
1: 	 * java domain values.
1: 	 * This can't be done for parameters which are wrappers over SQL function
1: 	 * defined with RETURN NULL ON NULL INPUT because such functions need
1: 	 * access to both sql domain value and java domain value. - Derby479
1: 	 */
1: 	private void optimizeDomainValueConversion() throws StandardException {
1: 		int		count = methodParms.length;
1: 		for (int parm = 0; parm < count; parm++)
1: 		{
1: 			if (methodParms[parm] instanceof SQLToJavaValueNode &&
1: 				((SQLToJavaValueNode)methodParms[parm]).getSQLValueNode() instanceof
1: 				JavaToSQLValueNode)
1: 			{
1: 				//If we are here, then it means that the parameter is
1: 				//SQLToJavaValueNode on top of JavaToSQLValueNode
1: 				JavaValueNode paramIsJavaValueNode =
1: 					((JavaToSQLValueNode)((SQLToJavaValueNode)methodParms[parm]).getSQLValueNode()).getJavaValueNode();
1: 				if (paramIsJavaValueNode instanceof StaticMethodCallNode)
1: 				{
1: 					//If we are here, then it means that the parameter has
1: 					//a MethodCallNode underneath it.
1: 					StaticMethodCallNode paramIsMethodCallNode = (StaticMethodCallNode)paramIsJavaValueNode;
1: 					//If the MethodCallNode parameter is defined as
1: 					//CALLED ON NULL INPUT, then we can remove the wrappers
1: 					//for the param and just set the parameter to the
1: 					//java value node.
1: 					if (paramIsMethodCallNode.routineInfo != null &&
1: 							paramIsMethodCallNode.routineInfo.calledOnNullInput())
1: 						methodParms[parm] =
1: 							((JavaToSQLValueNode)((SQLToJavaValueNode)methodParms[parm]).getSQLValueNode()).getJavaValueNode();
1: 				}
1: 			}
1: 		}
1: 	}
1: 
1: 	/**
commit:806114c
/////////////////////////////////////////////////////////////////////////
1: 							mb.callMethod(VMOpcode.INVOKEINTERFACE, ClassName.VariableSizeDataValue, "setWidth", "void", 3);
1: 							// mb.endStatement();
commit:14d5f00
/////////////////////////////////////////////////////////////////////////
1: 									
0: 				boolean noSchema = schemaName == null;
0: 				resolveRoutine(fromList, subqueryList, aggregateVector, sd);
1: 				
0: 				if (ad == null && noSchema && !forCallStatement)
1: 				{
0: 					// Resolve to a built-in SYSFUN function but only
0: 					// if this is a function call and the call
0: 					// was not qualified. E.g. COS(angle). The
0: 					// SYSFUN functions are not in SYSALIASES but
0: 					// an in-memory table, set up in DataDictioanryImpl.
0: 					sd = getSchemaDescriptor("SYSFUN", true);
1: 					
0: 					resolveRoutine(fromList, subqueryList, aggregateVector, sd);
/////////////////////////////////////////////////////////////////////////
1: 	 * Resolve a routine. Obtain a list of routines from the data dictionary
1: 	 * of the correct type (functions or procedures) and name.
1: 	 * Pick the best routine from the list. Currently only a single routine
1: 	 * with a given type and name is allowed, thus if changes are made to
1: 	 * support overloaded routines, careful code inspection and testing will
1: 	 * be required.
0: 	 * @param fromList
0: 	 * @param subqueryList
0: 	 * @param aggregateVector
0: 	 * @param sd
0: 	 * @throws StandardException
1: 	 */
0: 	private void resolveRoutine(FromList fromList, SubqueryList subqueryList, Vector aggregateVector, SchemaDescriptor sd) throws StandardException {
1: 		if (sd.getUUID() != null) {
1: 
0: 		java.util.List list = getDataDictionary().getRoutineList(
0: 			sd.getUUID().toString(), methodName,
0: 			forCallStatement ? AliasInfo.ALIAS_NAME_SPACE_PROCEDURE_AS_CHAR : AliasInfo.ALIAS_NAME_SPACE_FUNCTION_AS_CHAR
1: 			);
1: 
1: 		for (int i = list.size() - 1; i >= 0; i--) {
1: 
0: 			AliasDescriptor proc = (AliasDescriptor) list.get(i);
1: 
0: 			RoutineAliasInfo routineInfo = (RoutineAliasInfo) proc.getAliasInfo();
0: 			int parameterCount = routineInfo.getParameterCount();
0: 			if (parameterCount != methodParms.length)
0: 				continue;
1: 
1: 			// pre-form the method signature. If it is a dynamic result set procedure
1: 			// then we need to add in the ResultSet array
1: 
0: 			TypeDescriptor[] parameterTypes = routineInfo.getParameterTypes();
1: 
1: 			int sigParameterCount = parameterCount;
0: 			if (routineInfo.getMaxDynamicResultSets() > 0)
0: 				sigParameterCount++;
1: 
1: 			signature = new JSQLType[sigParameterCount];
1: 			for (int p = 0; p < parameterCount; p++) {
1: 
1: 				// find the declared type.
1: 
1: 				TypeDescriptor td = parameterTypes[p];
1: 
0: 				TypeId typeId = TypeId.getBuiltInTypeId(td.getJDBCTypeId());
1: 
1: 				TypeId parameterTypeId = typeId;
1: 
1: 
1: 				// if it's an OUT or INOUT parameter we need an array.
0: 				int parameterMode = routineInfo.getParameterModes()[p];
1: 
0: 				if (parameterMode != JDBC30Translation.PARAMETER_MODE_IN) {
1: 
1: 					String arrayType;
1: 					switch (typeId.getJDBCTypeId()) {
1: 						case java.sql.Types.SMALLINT:
1: 						case java.sql.Types.INTEGER:
1: 						case java.sql.Types.BIGINT:
1: 						case java.sql.Types.REAL:
1: 						case java.sql.Types.DOUBLE:
1: 							arrayType = getTypeCompiler(typeId).getCorrespondingPrimitiveTypeName().concat("[]");
1: 							break;
1: 						default:
1: 							arrayType = typeId.getCorrespondingJavaTypeName().concat("[]");
1: 							break;
1: 					}
1: 
0: 					typeId = TypeId.getUserDefinedTypeId(arrayType, false);
1: 				}
1: 
1: 				// this is the type descriptor of the require method parameter
1: 				DataTypeDescriptor methoddtd = new DataTypeDescriptor(
1: 						typeId,
1: 						td.getPrecision(),
1: 						td.getScale(),
1: 						td.isNullable(),
1: 						td.getMaximumWidth()
1: 					);
1: 
1: 				signature[p] = new JSQLType(methoddtd);
1: 
0: 				// check parameter is a ? node for INOUT and OUT parameters.
1: 
0: 				ValueNode sqlParamNode = null;
1: 
0: 				if (methodParms[p] instanceof SQLToJavaValueNode) {
0: 					SQLToJavaValueNode sql2j = (SQLToJavaValueNode) methodParms[p];
0: 					sqlParamNode = sql2j.getSQLValueNode();
1: 				}
1: 				else
1: 				{
1: 				}
1: 
0: 				boolean isParameterMarker = true;
0: 				if ((sqlParamNode == null) || !sqlParamNode.isParameterNode())
1: 				{
0: 					if (parameterMode != JDBC30Translation.PARAMETER_MODE_IN) {
1: 					 
0: 						throw StandardException.newException(SQLState.LANG_DB2_PARAMETER_NEEDS_MARKER,
0: 							RoutineAliasInfo.parameterMode(parameterMode),
0: 							routineInfo.getParameterNames()[p]);
1: 					}
0: 					isParameterMarker = false;
1: 				}
1: 				else
1: 				{
0: 					if (applicationParameterNumbers == null)
0: 						applicationParameterNumbers = new int[parameterCount];
0: 					applicationParameterNumbers[p] = ((ParameterNode) sqlParamNode).getParameterNumber();
1: 				}
1: 
1: 				// this is the SQL type of the procedure parameter.
1: 				DataTypeDescriptor paramdtd = new DataTypeDescriptor(
1: 					parameterTypeId,
1: 					td.getPrecision(),
1: 					td.getScale(),
1: 					td.isNullable(),
1: 					td.getMaximumWidth()
1: 				);
1: 
0: 				boolean needCast = false;
0: 				if (!isParameterMarker)
1: 				{
1: 
0: 					// can only be an IN parameter.
0: 					// check that the value can be assigned to the
0: 					// type of the procedure parameter.
0: 					if (sqlParamNode instanceof UntypedNullConstantNode)
1: 					{
0: 						sqlParamNode.setDescriptor(paramdtd);
1: 					}
1: 					else
1: 					{
1: 
1: 
0: 						DataTypeDescriptor dts;
0: 						TypeId argumentTypeId;
1: 
0: 						if (sqlParamNode != null)
1: 						{
0: 							// a node from the SQL world
0: 							argumentTypeId = sqlParamNode.getTypeId();
0: 							dts = sqlParamNode.getTypeServices();
1: 						}
1: 						else
1: 						{
0: 							// a node from the Java world
0: 							dts = DataTypeDescriptor.getSQLDataTypeDescriptor(methodParms[p].getJavaTypeName());
0: 							if (dts == null)
1: 							{
0: 								throw StandardException.newException(SQLState.LANG_NO_CORRESPONDING_S_Q_L_TYPE, 
0: 									methodParms[p].getJavaTypeName());
1: 							}
1: 
0: 							argumentTypeId = dts.getTypeId();
1: 						}
1: 
0: 						if (! getTypeCompiler(parameterTypeId).storable(argumentTypeId, getClassFactory()))
0: 								throw StandardException.newException(SQLState.LANG_NOT_STORABLE, 
0: 									parameterTypeId.getSQLTypeName(),
0: 									argumentTypeId.getSQLTypeName() );
1: 
0: 						// if it's not an exact length match then some cast will be needed.
0: 						if (!paramdtd.isExactTypeAndLengthMatch(dts))
0: 							needCast = true;
1: 					}
1: 				}
1: 				else
1: 				{
0: 					// any variable length type will need a cast from the
0: 					// Java world (the ? parameter) to the SQL type. This
0: 					// ensures values like CHAR(10) are passed into the procedure
0: 					// correctly as 10 characters long.
0: 					if (parameterTypeId.variableLength()) {
1: 
0: 						if (parameterMode != JDBC30Translation.PARAMETER_MODE_OUT)
0: 							needCast = true;
1: 					}
1: 				}
1: 				
1: 
0: 				if (needCast)
1: 				{
0: 					// push a cast node to ensure the
0: 					// correct type is passed to the method
0: 					// this gets tacky because before we knew
0: 					// it was a procedure call we ensured all the
0: 					// parameter are JavaNodeTypes. Now we need to
0: 					// push them back to the SQL domain, cast them
0: 					// and then push them back to the Java domain.
1: 
0: 					if (sqlParamNode == null) {
1: 
0: 						sqlParamNode = (ValueNode) getNodeFactory().getNode(
0: 							C_NodeTypes.JAVA_TO_SQL_VALUE_NODE,
0: 							methodParms[p], 
1: 							getContextManager());
1: 					}
1: 
0: 					ValueNode castNode = (ValueNode) getNodeFactory().getNode(
0: 						C_NodeTypes.CAST_NODE,
0: 						sqlParamNode, 
0: 						paramdtd,
1: 						getContextManager());
1: 
1: 
0: 					methodParms[p] = (JavaValueNode) getNodeFactory().getNode(
0: 							C_NodeTypes.SQL_TO_JAVA_VALUE_NODE,
0: 							castNode, 
1: 							getContextManager());
1: 
0: 					methodParms[p] = methodParms[p].bindExpression(fromList, subqueryList, aggregateVector);
1: 				}
1: 
0: 				// only force the type for a ? so that the correct type shows up
0: 				// in parameter meta data
0: 				if (isParameterMarker)
0: 					sqlParamNode.setDescriptor(paramdtd);
1: 			}
1: 
1: 			if (sigParameterCount != parameterCount) {
1: 
0: 				TypeId typeId = TypeId.getUserDefinedTypeId("java.sql.ResultSet[]", false);
1: 
1: 				DataTypeDescriptor dtd = new DataTypeDescriptor(
1: 						typeId,
1: 						0,
1: 						0,
1: 						false,
1: 						-1
1: 					);
1: 
1: 				signature[parameterCount] = new JSQLType(dtd);
1: 
1: 			}
1: 
0: 			this.routineInfo = routineInfo;
1: 			ad = proc;
1: 
1: 			// If a procedure is in the system schema and defined as executing
0: 			// SQL do we set we are in system code.
0: 			if (sd.isSystemSchema() && (routineInfo.getReturnType() == null) && routineInfo.getSQLAllowed() != RoutineAliasInfo.NO_SQL)
0: 				isSystemCode = true;
1: 
1: 			break;
1: 		}
1: }
1: 	}
1: 
1: 	/**
commit:afa871e
/////////////////////////////////////////////////////////////////////////
1: 			mb.setField(returnsNullOnNullState);
/////////////////////////////////////////////////////////////////////////
1: 				mb.setField(functionEntrySQLAllowed);
/////////////////////////////////////////////////////////////////////////
1: 					cons.setField(procedureResultSetsHolder);
commit:d7f7457
/////////////////////////////////////////////////////////////////////////
1: 						// is the underlying type for the OUT/INOUT parameter primitive.
0: 						boolean isPrimitive = ((java.lang.reflect.Method) method).getParameterTypes()[i].getComponentType().isPrimitive();
1: 						if (isNumericType) {
1: 							// need to up-cast as the setValue(Number) method only exists on NumberDataValue
1: 
1: 							if (!isPrimitive)
1: 								mb.cast(ClassName.NumberDataValue);
1: 							// need to cast as the setValue(Boolean) method only exists on BooleanDataValue
1: 							if (!isPrimitive)
/////////////////////////////////////////////////////////////////////////
1: 
1: 						// The value needs to be set thorugh the setValue(Number) method.
1: 						if (isNumericType && !isPrimitive)
1: 						{
1: 							mb.upCast("java.lang.Number");
1: 						}
1: 
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.compile.StaticMethodCallNode
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:61070a6
/////////////////////////////////////////////////////////////////////////
commit:fe77ca5
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package	org.apache.derby.impl.sql.compile;
1: 
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
0: import org.apache.derby.iapi.sql.compile.CompilerContext;
0: import org.apache.derby.iapi.sql.compile.TypeCompiler;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
0: import org.apache.derby.iapi.types.JSQLType;
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: import org.apache.derby.iapi.types.TypeId;
1: 
0: import org.apache.derby.iapi.sql.dictionary.AliasDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
1: 
0: import org.apache.derby.iapi.reference.ClassName;
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.reference.JDBC30Translation;
0: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.impl.sql.compile.ExpressionClassBuilder;
0: import org.apache.derby.iapi.services.loader.ClassInspector;
0: import org.apache.derby.iapi.services.compiler.LocalField;
1: 
0: import org.apache.derby.iapi.util.JBitSet;
0: import org.apache.derby.iapi.services.classfile.VMOpcode;
1: 
0: import org.apache.derby.iapi.sql.conn.Authorizer;
1: 
0: import org.apache.derby.catalog.AliasInfo;
0: import org.apache.derby.catalog.TypeDescriptor;
0: import org.apache.derby.catalog.types.RoutineAliasInfo;
0: import org.apache.derby.impl.sql.compile.ActivationClassBuilder;
1: 
0: import org.apache.derby.catalog.UUID;
1: 
0: import java.util.Vector;
1: import java.lang.reflect.Modifier;
1: 
1: /**
1:  * A StaticMethodCallNode represents a static method call from a Class
1:  * (as opposed to from an Object).
1: 
1:    For a procedure the call requires that the arguments be ? parameters.
1:    The parameter is *logically* passed into the method call a number of different ways.
1: 
1:    <P>
1:    For a application call like CALL MYPROC(?) the logically Java method call is
1:    (in psuedo Java/SQL code) (examples with CHAR(10) parameter)
1:    <BR>
1:    Fixed length IN parameters - com.acme.MyProcedureMethod(?)
1:    <BR>
1:    Variable length IN parameters - com.acme.MyProcedureMethod(CAST (? AS CHAR(10))
1:    <BR>
1:    Fixed length INOUT parameter -
1: 		String[] holder = new String[] {?}; com.acme.MyProcedureMethod(holder); ? = holder[0]
1:    <BR>
1:    Variable length INOUT parameter -
1: 		String[] holder = new String[] {CAST (? AS CHAR(10)}; com.acme.MyProcedureMethod(holder); ? = CAST (holder[0] AS CHAR(10))
1: 
1:    <BR>
1:    Fixed length OUT parameter -
1: 		String[] holder = new String[1]; com.acme.MyProcedureMethod(holder); ? = holder[0]
1: 
1:    <BR>
1:    Variable length INOUT parameter -
1: 		String[] holder = new String[1]; com.acme.MyProcedureMethod(holder); ? = CAST (holder[0] AS CHAR(10))
1: 
1: 
1:     <P>
1: 	For static method calls there is no pre-definition of an IN or INOUT parameter, so a call to CallableStatement.registerOutParameter()
1: 	makes the parameter an INOUT parameter, provided:
1: 		- the parameter is passed directly to the method call (no casts or expressions).
1: 		- the method's parameter type is a Java array type.
1: 
0:     Since this is a dynmaic decision we compile in code to take both paths, based upon a boolean isINOUT which is dervied from the
0: 	ParameterValueSet. Code is logically (only single parameter String[] shown here). Note, no casts can exist here.
1: 
1: 	boolean isINOUT = getParameterValueSet().getParameterMode(0) == PARAMETER_IN_OUT;
1: 	if (isINOUT) {
1: 		String[] holder = new String[] {?}; com.acme.MyProcedureMethod(holder); ? = holder[0]
1: 	   
1: 	} else {
1: 		com.acme.MyProcedureMethod(?)
1: 	}
1: 
1:  *
0:  * @author Jerry Brenner
1:  */
0: public class StaticMethodCallNode extends MethodCallNode
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 	private TableName procedureName;
1: 
1: 	private LocalField[] outParamArrays;
1: 	private int[]		 applicationParameterNumbers; 
1: 
1: 	private boolean		isSystemCode;
0: 	private boolean		alreadyBound;
1: 
1: 	private LocalField	returnsNullOnNullState;
1: 
1: 
1: 	AliasDescriptor	ad;
1: 
1: 
1: 	/**
0: 	 * Intializer for a NonStaticMethodCallNode
1: 	 *
1: 	 * @param methodName		The name of the method to call
0: 	 * @param javaClassName		The name of the java class that the static method belongs to.
1: 	 */
0: 	public void init(Object methodName, Object javaClassName)
1: 	{
0: 		if (methodName instanceof String)
0: 			init(methodName);
0: 		else {
0: 			procedureName = (TableName) methodName;
0: 			init(procedureName.getTableName());
1: 		}
1: 
0: 		this.javaClassName = (String) javaClassName;
1: 	}
1: 
1: 	/**
1: 	 * Bind this expression.  This means binding the sub-expressions,
1: 	 * as well as figuring out what the return type is for this expression.
1: 	 *
1: 	 * @param fromList		The FROM list for the query this
0: 	 *				expression is in, for binding columns.
0: 	 * @param subqueryList		The subquery list being built as we find SubqueryNodes
0: 	 * @param aggregateVector	The aggregate vector being built as we find AggregateNodes
1: 	 *
1: 	 * @return	this or an AggregateNode
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public JavaValueNode bindExpression(
0: 		FromList fromList, SubqueryList subqueryList,
0: 		Vector	aggregateVector) 
1: 			throws StandardException
1: 	{
1: 		// for a function we can get called recursively
0: 		if (alreadyBound)
1: 			return this;
1: 
1: 
0: 		bindParameters(fromList, subqueryList, aggregateVector);
1: 
1: 		
1: 		/* If javaClassName is null then we assume that the current methodName
1: 		 * is an alias and we must go to sysmethods to
1: 		 * get the real method and java class names for this alias.
1: 		 */
1: 		if (javaClassName == null)
1: 		{
1: 			CompilerContext cc = getCompilerContext();
1: 
1: 			// look for a routine
0: 			if (ad == null) {
1: 
0: 				String schemaName = procedureName != null ?
0: 									procedureName.getSchemaName() : null;
1: 
0: 				SchemaDescriptor sd = getSchemaDescriptor(schemaName, schemaName != null);
1: 
1: 
0: 				if (sd.getUUID() != null) {
1: 
0: 				java.util.List list = getDataDictionary().getRoutineList(
0: 					sd.getUUID().toString(), methodName,
0: 					forCallStatement ? AliasInfo.ALIAS_NAME_SPACE_PROCEDURE_AS_CHAR : AliasInfo.ALIAS_NAME_SPACE_FUNCTION_AS_CHAR
0: 					);
1: 
0: 				for (int i = list.size() - 1; i >= 0; i--) {
1: 
0: 					AliasDescriptor proc = (AliasDescriptor) list.get(i);
1: 
0: 					RoutineAliasInfo routineInfo = (RoutineAliasInfo) proc.getAliasInfo();
0: 					int parameterCount = routineInfo.getParameterCount();
0: 					if (parameterCount != methodParms.length)
0: 						continue;
1: 
0: 					// pre-form the method signature. If it is a dynamic result set procedure
0: 					// then we need to add in the ResultSet array
1: 
0: 					TypeDescriptor[] parameterTypes = routineInfo.getParameterTypes();
1: 
0: 					int sigParameterCount = parameterCount;
0: 					if (routineInfo.getMaxDynamicResultSets() > 0)
0: 						sigParameterCount++;
1: 
0: 					signature = new JSQLType[sigParameterCount];
0: 					for (int p = 0; p < parameterCount; p++) {
1: 
0: 						// find the declared type.
1: 
0: 						TypeDescriptor td = parameterTypes[p];
1: 
0: 						TypeId typeId = TypeId.getBuiltInTypeId(td.getJDBCTypeId());
1: 
0: 						TypeId parameterTypeId = typeId;
1: 
1: 
0: 						// if it's an OUT or INOUT parameter we need an array.
0: 						int parameterMode = routineInfo.getParameterModes()[p];
1: 
0: 						if (parameterMode != JDBC30Translation.PARAMETER_MODE_IN) {
1: 
0: 							String arrayType;
0: 							switch (typeId.getJDBCTypeId()) {
0: 								case java.sql.Types.SMALLINT:
0: 								case java.sql.Types.INTEGER:
0: 								case java.sql.Types.BIGINT:
0: 								case java.sql.Types.REAL:
0: 								case java.sql.Types.DOUBLE:
0: 									arrayType = getTypeCompiler(typeId).getCorrespondingPrimitiveTypeName().concat("[]");
1: 									break;
0: 								default:
0: 									arrayType = typeId.getCorrespondingJavaTypeName().concat("[]");
1: 									break;
1: 							}
1: 
0: 							typeId = TypeId.getUserDefinedTypeId(arrayType, false);
1: 						}
1: 
0: 						// this is the type descriptor of the require method parameter
0: 						DataTypeDescriptor methoddtd = new DataTypeDescriptor(
0: 								typeId,
0: 								td.getPrecision(),
0: 								td.getScale(),
0: 								td.isNullable(),
0: 								td.getMaximumWidth()
0: 							);
1: 
0: 						signature[p] = new JSQLType(methoddtd);
1: 
0: 						// check parameter is a ? node for INOUT and OUT parameters.
1: 
0: 						ValueNode sqlParamNode = null;
1: 
0: 						if (methodParms[p] instanceof SQLToJavaValueNode) {
0: 							SQLToJavaValueNode sql2j = (SQLToJavaValueNode) methodParms[p];
0: 							sqlParamNode = sql2j.getSQLValueNode();
1: 						}
0: 						else
1: 						{
1: 						}
1: 
0: 						boolean isParameterMarker = true;
0: 						if ((sqlParamNode == null) || !sqlParamNode.isParameterNode())
1: 						{
0: 							if (parameterMode != JDBC30Translation.PARAMETER_MODE_IN) {
1: 							 
0: 								throw StandardException.newException(SQLState.LANG_DB2_PARAMETER_NEEDS_MARKER,
0: 									RoutineAliasInfo.parameterMode(parameterMode),
0: 									routineInfo.getParameterNames()[p]);
1: 							}
0: 							isParameterMarker = false;
1: 						}
0: 						else
1: 						{
0: 							if (applicationParameterNumbers == null)
0: 								applicationParameterNumbers = new int[parameterCount];
0: 							applicationParameterNumbers[p] = ((ParameterNode) sqlParamNode).getParameterNumber();
1: 						}
1: 
0: 						// this is the SQL type of the procedure parameter.
0: 						DataTypeDescriptor paramdtd = new DataTypeDescriptor(
0: 							parameterTypeId,
0: 							td.getPrecision(),
0: 							td.getScale(),
0: 							td.isNullable(),
0: 							td.getMaximumWidth()
0: 						);
1: 
0: 						boolean needCast = false;
0: 						if (!isParameterMarker)
1: 						{
1: 
0: 							// can only be an IN parameter.
0: 							// check that the value can be assigned to the
0: 							// type of the procedure parameter.
0: 							if (sqlParamNode instanceof UntypedNullConstantNode)
1: 							{
0: 								sqlParamNode.setDescriptor(paramdtd);
1: 							}
0: 							else
1: 							{
1: 
1: 
0: 								DataTypeDescriptor dts;
0: 								TypeId argumentTypeId;
1: 
0: 								if (sqlParamNode != null)
1: 								{
0: 									// a node from the SQL world
0: 									argumentTypeId = sqlParamNode.getTypeId();
0: 									dts = sqlParamNode.getTypeServices();
1: 								}
0: 								else
1: 								{
0: 									// a node from the Java world
0: 									dts = DataTypeDescriptor.getSQLDataTypeDescriptor(methodParms[p].getJavaTypeName());
0: 									if (dts == null)
1: 									{
0: 										throw StandardException.newException(SQLState.LANG_NO_CORRESPONDING_S_Q_L_TYPE, 
0: 											methodParms[p].getJavaTypeName());
1: 									}
1: 
0: 									argumentTypeId = dts.getTypeId();
1: 								}
1: 
0: 								if (! getTypeCompiler(parameterTypeId).storable(argumentTypeId, getClassFactory()))
0: 										throw StandardException.newException(SQLState.LANG_NOT_STORABLE, 
0: 											parameterTypeId.getSQLTypeName(),
0: 											argumentTypeId.getSQLTypeName() );
1: 
0: 								// if it's not an exact length match then some cast will be needed.
0: 								if (!paramdtd.isExactTypeAndLengthMatch(dts))
0: 									needCast = true;
1: 							}
1: 						}
0: 						else
1: 						{
0: 							// any variable length type will need a cast from the
0: 							// Java world (the ? parameter) to the SQL type. This
0: 							// ensures values like CHAR(10) are passed into the procedure
0: 							// correctly as 10 characters long.
0: 							if (parameterTypeId.variableLength()) {
1: 
0: 								if (parameterMode != JDBC30Translation.PARAMETER_MODE_OUT)
0: 									needCast = true;
1: 							}
1: 						}
1: 						
1: 
0: 						if (needCast)
1: 						{
0: 							// push a cast node to ensure the
0: 							// correct type is passed to the method
0: 							// this gets tacky because before we knew
0: 							// it was a procedure call we ensured all the
0: 							// parameter are JavaNodeTypes. Now we need to
0: 							// push them back to the SQL domain, cast them
0: 							// and then push them back to the Java domain.
1: 
0: 							if (sqlParamNode == null) {
1: 
0: 								sqlParamNode = (ValueNode) getNodeFactory().getNode(
0: 									C_NodeTypes.JAVA_TO_SQL_VALUE_NODE,
0: 									methodParms[p], 
0: 									getContextManager());
1: 							}
1: 
0: 							ValueNode castNode = (ValueNode) getNodeFactory().getNode(
0: 								C_NodeTypes.CAST_NODE,
0: 								sqlParamNode, 
0: 								paramdtd,
0: 								getContextManager());
1: 
1: 
0: 							methodParms[p] = (JavaValueNode) getNodeFactory().getNode(
0: 									C_NodeTypes.SQL_TO_JAVA_VALUE_NODE,
0: 									castNode, 
0: 									getContextManager());
1: 
0: 							methodParms[p] = methodParms[p].bindExpression(fromList, subqueryList, aggregateVector);
1: 						}
1: 
0: 						// only force the type for a ? so that the correct type shows up
0: 						// in parameter meta data
0: 						if (isParameterMarker)
0: 							sqlParamNode.setDescriptor(paramdtd);
1: 					}
1: 
0: 					if (sigParameterCount != parameterCount) {
1: 
0: 						TypeId typeId = TypeId.getUserDefinedTypeId("java.sql.ResultSet[]", false);
1: 
0: 						DataTypeDescriptor dtd = new DataTypeDescriptor(
0: 								typeId,
0: 								0,
0: 								0,
0: 								false,
0: 								-1
0: 							);
1: 
0: 						signature[parameterCount] = new JSQLType(dtd);
1: 
1: 					}
1: 
0: 					this.routineInfo = routineInfo;
0: 					ad = proc;
1: 
0: 					// If a procedure is in the system schema and defined as executing
0: 					// SQL do we set we are in system code.
0: 					if (sd.isSystemSchema() && (routineInfo.getReturnType() == null) && routineInfo.getSQLAllowed() != RoutineAliasInfo.NO_SQL)
0: 						isSystemCode = true;
1: 
1: 					break;
1: 				}
1: 			}
1: 	
1: 			}
1: 
0: 			/* Throw exception if no alias found */
1: 			if (ad == null)
1: 			{
0: 				Object errName;
0: 				if (procedureName == null)
0: 					errName = methodName;
0: 				else
0: 					errName = procedureName;
1: 
0: 				throw StandardException.newException(SQLState.LANG_NO_SUCH_METHOD_ALIAS, errName);
1: 			}
1: 	
1: 
1: 
1: 			/* Query is dependent on the AliasDescriptor */
1: 			cc.createDependency(ad);
1: 
1: 
1: 			methodName = ad.getAliasInfo().getMethodName();
1: 			javaClassName = ad.getJavaClassName();
1: 		}
1: 
1: 
0: 		javaClassName = verifyClassExist(javaClassName, true);
1: 
1: 		/* Resolve the method call */
0: 		resolveMethodCall(javaClassName, true);
1: 
1: 
0: 		alreadyBound = true;
1: 
1: 		// If this is a function call with a variable length
1: 		// return type, then we need to push a CAST node.
1: 		if (routineInfo != null)
1: 		{
1: 			TypeDescriptor returnType = routineInfo.getReturnType();
0: 			if (returnType != null)
1: 			{
1: 				TypeId returnTypeId = TypeId.getBuiltInTypeId(returnType.getJDBCTypeId());
1: 
1: 				if (returnTypeId.variableLength()) {
1: 					// Cast the return using a cast node, but have to go
1: 					// into the SQL domain, and back to the Java domain.
1: 
1: 					DataTypeDescriptor returnValueDtd = new DataTypeDescriptor(
1: 								returnTypeId,
1: 								returnType.getPrecision(),
1: 								returnType.getScale(),
1: 								returnType.isNullable(),
1: 								returnType.getMaximumWidth()
0: 							);
1: 
1: 
0: 					ValueNode returnValueToSQL = (ValueNode) getNodeFactory().getNode(
0: 								C_NodeTypes.JAVA_TO_SQL_VALUE_NODE,
0: 								this, 
0: 								getContextManager());
1: 
0: 					ValueNode returnValueCastNode = (ValueNode) getNodeFactory().getNode(
0: 									C_NodeTypes.CAST_NODE,
1: 									returnValueToSQL, 
1: 									returnValueDtd,
0: 									getContextManager());
1: 
1: 
0: 					JavaValueNode returnValueToJava = (JavaValueNode) getNodeFactory().getNode(
0: 										C_NodeTypes.SQL_TO_JAVA_VALUE_NODE,
0: 										returnValueCastNode, 
0: 										getContextManager());
1: 
0: 					return returnValueToJava.bindExpression(fromList, subqueryList, aggregateVector);
1: 				}
1: 
1: 			}
1: 		}
1: 
1: 		return this;
1: 	}
1: 
1: 	/**
1: 		Push extra code to generate the casts within the
1: 		arrays for the parameters passed as arrays.
1: 	*/
0: 	public	void generateOneParameter(ExpressionClassBuilder acb,
1: 											MethodBuilder mb,
1: 											int parameterNumber )
1: 			throws StandardException
1: 	{
1: 		int parameterMode;
1: 
1: 
1: 		SQLToJavaValueNode sql2j = null;
1: 		if (methodParms[parameterNumber] instanceof SQLToJavaValueNode)
1: 			sql2j = (SQLToJavaValueNode) methodParms[parameterNumber];
1: 		
1: 		if (routineInfo != null) {
0: 			parameterMode = routineInfo.getParameterModes()[parameterNumber];
1: 		} else {
1: 			// for a static method call the parameter always starts out as a in parameter, but
1: 			// may be registered as an IN OUT parameter. For a static method argument to be
1: 			// a dynmaically registered out parameter it must be a simple ? parameter
1: 
0: 			parameterMode = JDBC30Translation.PARAMETER_MODE_IN;
1: 
1: 			if (sql2j != null) {
0: 				if (sql2j.getSQLValueNode().isParameterNode()) {
1: 
1: 					// applicationParameterNumbers is only set up for a procedure.
0: 					int applicationParameterNumber = ((ParameterNode) (sql2j.getSQLValueNode())).getParameterNumber();
1: 
0: 					String parameterType = methodParameterTypes[parameterNumber];
1: 
1: 					if (parameterType.endsWith("[]")) {
1: 
0: 						// constructor  - setting up correct paramter type info
1: 						MethodBuilder constructor = acb.getConstructor();
1: 						acb.pushThisAsActivation(constructor);
1: 						constructor.callMethod(VMOpcode.INVOKEINTERFACE, null,
1: 											"getParameterValueSet", ClassName.ParameterValueSet, 0);
1: 
1: 						constructor.push(applicationParameterNumber);
0: 						constructor.push(JDBC30Translation.PARAMETER_MODE_UNKNOWN);
1: 						constructor.callMethod(VMOpcode.INVOKEINTERFACE, null,
1: 											"setParameterMode", "void", 2);
1: 						constructor.endStatement();
1: 					}
1: 				}
1: 			} 
1: 		}
1: 
1: 		switch (parameterMode) {
0: 		case JDBC30Translation.PARAMETER_MODE_IN:
0: 		case JDBC30Translation.PARAMETER_MODE_IN_OUT:
0: 		case JDBC30Translation.PARAMETER_MODE_UNKNOWN:
1: 			if (sql2j != null)
1: 				sql2j.returnsNullOnNullState = returnsNullOnNullState;
1: 			super.generateOneParameter(acb, mb, parameterNumber);
1: 			break;
1: 
0: 		case JDBC30Translation.PARAMETER_MODE_OUT:
1: 			// For an OUT parameter we require nothing to be pushed into the
1: 			// method call from the parameter node.
1: 			break;
1: 		}
1: 
1: 		switch (parameterMode) {
0: 		case JDBC30Translation.PARAMETER_MODE_IN:
0: 		case JDBC30Translation.PARAMETER_MODE_UNKNOWN:
1: 			break;
1: 
0: 		case JDBC30Translation.PARAMETER_MODE_IN_OUT:
0: 		case JDBC30Translation.PARAMETER_MODE_OUT:
1: 		{
1: 			// Create the array used to pass into the method. We create a
1: 			// new array for each call as there is a small chance the
1: 			// application could retain a reference to it and corrupt
1: 			// future calls with the same CallableStatement object.
1: 
0: 			String methodParameterType = methodParameterTypes[parameterNumber];
1: 			String arrayType = methodParameterType.substring(0, methodParameterType.length() - 2);
1: 			LocalField lf = acb.newFieldDeclaration(Modifier.PRIVATE, methodParameterType);
1: 
1: 			if (outParamArrays == null)
0: 				outParamArrays = new LocalField[methodParms.length];
1: 
1: 			outParamArrays[parameterNumber] = lf;
1: 
1: 			mb.pushNewArray(arrayType, 1);
1: 			mb.putField(lf);
1: 
1: 			// set the IN part of the parameter into the INOUT parameter.
0: 			if (parameterMode != JDBC30Translation.PARAMETER_MODE_OUT) {
1: 				mb.swap();
1: 				mb.setArrayElement(0);
1: 				mb.getField(lf);
1: 			}
1: 			break;
1: 			}
1: 		}
1: 
1: 	}
1: 
1: 	/**
1: 	 * Categorize this predicate.  Initially, this means
1: 	 * building a bit map of the referenced tables for each predicate.
1: 	 * If the source of this ColumnReference (at the next underlying level) 
1: 	 * is not a ColumnReference or a VirtualColumnNode then this predicate
1: 	 * will not be pushed down.
1: 	 *
1: 	 * For example, in:
1: 	 *		select * from (select 1 from s) a (x) where x = 1
1: 	 * we will not push down x = 1.
1: 	 * NOTE: It would be easy to handle the case of a constant, but if the
1: 	 * inner SELECT returns an arbitrary expression, then we would have to copy
1: 	 * that tree into the pushed predicate, and that tree could contain
1: 	 * subqueries and method calls.
1: 	 * RESOLVE - revisit this issue once we have views.
1: 	 *
1: 	 * @param referencedTabs	JBitSet with bit map of referenced FromTables
1: 	 * @param simplePredsOnly	Whether or not to consider method
1: 	 *							calls, field references and conditional nodes
1: 	 *							when building bit map
1: 	 *
1: 	 * @return boolean		Whether or not source.expression is a ColumnReference
1: 	 *						or a VirtualColumnNode.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public boolean categorize(JBitSet referencedTabs, boolean simplePredsOnly)
1: 		throws StandardException
1: 	{
1: 		/* We stop here when only considering simple predicates
1: 		 *  as we don't consider method calls when looking
1: 		 * for null invariant predicates.
1: 		 */
1: 		if (simplePredsOnly)
1: 		{
1: 			return false;
1: 		}
1: 
1: 		boolean pushable = true;
1: 
1: 		pushable = pushable && super.categorize(referencedTabs, simplePredsOnly);
1: 
1: 		return pushable;
1: 	}
1: 
1: 	/**
1: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
1: 	 * for how this should be done for tree printing.
1: 	 *
1: 	 * @return	This object as a String
1: 	 */
1: 
1: 	public String toString()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			return "javaClassName: " +
1: 				(javaClassName != null ? javaClassName : "null") + "\n" +
1: 				super.toString();
1: 		}
0: 		else
1: 		{
1: 			return "";
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Do code generation for this method call
1: 	 *
1: 	 * @param acb	The ExpressionClassBuilder for the class we're generating
1: 	 * @param mb	The method the expression will go into
1: 	 *
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public void generateExpression(ExpressionClassBuilder acb,
0: 											MethodBuilder mb)
1: 									throws StandardException
1: 	{
1: 		if (routineInfo != null) {
1: 
1: 			if (!routineInfo.calledOnNullInput() && routineInfo.getParameterCount() != 0)
1: 				returnsNullOnNullState = acb.newFieldDeclaration(Modifier.PRIVATE, "boolean");
1: 
1: 		}
1: 
1: 		// reset the parameters are null indicator.
1: 		if (returnsNullOnNullState != null) {
1: 			mb.push(false);
0: 			mb.putField(returnsNullOnNullState);
1: 			mb.endStatement();
1: 
1: 			// for the call to the generated method below.
1: 			mb.pushThis();
1: 		}
1: 
1: 		int nargs = generateParameters(acb, mb);
1: 
1: 		LocalField functionEntrySQLAllowed = null;
1: 
1: 		if (routineInfo != null) {
1: 
1: 			short sqlAllowed = routineInfo.getSQLAllowed();
1: 
1: 			// Before we set up our authorization level, add a check to see if this
1: 			// method can be called. If the routine is NO SQL or CONTAINS SQL 
1: 			// then there is no need for a check. As follows:
1: 			//
1: 			// Current Level = NO_SQL - CALL will be rejected when getting CALL result set
1: 			// Current Level = anything else - calls to procedures defined as NO_SQL and CONTAINS SQL both allowed.
1: 
1: 
1: 			if (sqlAllowed != RoutineAliasInfo.NO_SQL)
1: 			{
1: 				
1: 				int sqlOperation;
1: 				
1: 				if (sqlAllowed == RoutineAliasInfo.READS_SQL_DATA)
1: 					sqlOperation = Authorizer.SQL_SELECT_OP;
1: 				else if (sqlAllowed == RoutineAliasInfo.MODIFIES_SQL_DATA)
1: 					sqlOperation = Authorizer.SQL_WRITE_OP;
0: 				else
1: 					sqlOperation = Authorizer.SQL_ARBITARY_OP;
1: 				
1: 				generateAuthorizeCheck((ActivationClassBuilder) acb, mb, sqlOperation);
1: 			}
1: 
1: 			int statmentContextReferences = isSystemCode ? 2 : 1;
1: 			
1: 			boolean isFunction = routineInfo.getReturnType() != null;
1: 
1: 			if (isFunction)
1: 				statmentContextReferences++;
1: 
1: 
1: 			if (statmentContextReferences != 0) {
1: 				acb.pushThisAsActivation(mb);
1: 				mb.callMethod(VMOpcode.INVOKEINTERFACE, null,
1: 									"getLanguageConnectionContext", ClassName.LanguageConnectionContext, 0);
1: 				mb.callMethod(VMOpcode.INVOKEINTERFACE, null,
1: 									"getStatementContext", "org.apache.derby.iapi.sql.conn.StatementContext", 0);
1: 
1: 				for (int scc = 1; scc < statmentContextReferences; scc++)
1: 					mb.dup();
1: 			}
1: 
1: 			/**
1: 				Set the statement context to reflect we are running
1: 				System procedures, so that we can execute non-standard SQL.
1: 			*/
1: 			if (isSystemCode) {
1: 				mb.callMethod(VMOpcode.INVOKEINTERFACE, null,
1: 									"setSystemCode", "void", 0);
1: 			}
1: 
1: 			// for a function we need to fetch the current SQL control
1: 			// so that we can reset it once the function is complete.
1: 			// 
1: 			if (isFunction)
1: 			{
1: 				functionEntrySQLAllowed = acb.newFieldDeclaration(Modifier.PRIVATE, "short");
1: 				mb.callMethod(VMOpcode.INVOKEINTERFACE, null,
1: 									"getSQLAllowed", "short", 0);
0: 				mb.putField(functionEntrySQLAllowed);
1: 				mb.endStatement();
1: 
1: 			}
1: 			
1: 			
1: 			// Set up the statement context to reflect the
1: 			// restricted SQL execution allowed by this routine.
1: 
1: 			mb.push(sqlAllowed);
1: 			mb.push(false);
1: 			mb.callMethod(VMOpcode.INVOKEINTERFACE, null,
1: 								"setSQLAllowed", "void", 2);
1: 
1: 		}
1: 
0: 		// add in the ResultSet arrays.
1: 		if (routineInfo != null) {
1: 
0: 			int compiledResultSets = methodParameterTypes.length - methodParms.length;
1: 
1: 			if (compiledResultSets != 0) {
1: 
1: 				// Add a method that indicates the maxium number of dynamic result sets.
1: 				int maxDynamicResults = routineInfo.getMaxDynamicResultSets();
1: 				if (maxDynamicResults > 0) {
1: 					MethodBuilder gdr = acb.getClassBuilder().newMethodBuilder(Modifier.PUBLIC, "int", "getMaxDynamicResults");
1: 					gdr.push(maxDynamicResults);
1: 					gdr.methodReturn();
1: 					gdr.complete();
1: 				}
1: 
1: 				// add a method to return all the dynamic result sets (unordered)
1: 				MethodBuilder gdr = acb.getClassBuilder().newMethodBuilder(Modifier.PUBLIC, "java.sql.ResultSet[][]", "getDynamicResults");
1: 
1: 				MethodBuilder cons = acb.getConstructor();
1: 				// if (procDef.getParameterStyle() == RoutineAliasInfo.PS_JAVA)
1: 				{
1: 					// PARAMETER STYLE JAVA
1: 
1: 					LocalField procedureResultSetsHolder = acb.newFieldDeclaration(Modifier.PRIVATE, "java.sql.ResultSet[][]");
1: 
1: 					// getDynamicResults body
1: 					gdr.getField(procedureResultSetsHolder);
1: 
1: 					// create the holder of all the ResultSet arrays, new java.sql.ResultSet[][compiledResultSets]
1: 					cons.pushNewArray("java.sql.ResultSet[]", compiledResultSets);
0: 					cons.putField(procedureResultSetsHolder);
0: 					cons.endStatement();
1: 
1: 
1: 					// arguments for the dynamic result sets
1: 					for (int i = 0; i < compiledResultSets; i++) {
1: 
1: 						mb.pushNewArray("java.sql.ResultSet", 1);
1: 						mb.dup();
1: 
1: 						mb.getField(procedureResultSetsHolder);
1: 						mb.swap();
1: 
1: 						mb.setArrayElement(i);
1: 					}
1: 				} 
1: 
1: 				// complete the method that returns the ResultSet[][] to the 
1: 				gdr.methodReturn();
1: 				gdr.complete();
1: 
1: 				nargs += compiledResultSets;
1: 			}
1: 
1: 		}
1: 
1: 		String javaReturnType = getJavaTypeName();
1: 
1: 		MethodBuilder mbnc = null;
1: 		MethodBuilder mbcm = mb;
1: 
1: 
1: 		// If any of the parameters are null then
1: 		// do not call the method, just return null.
1: 		if (returnsNullOnNullState != null)
1: 		{
1: 			mbnc = acb.newGeneratedFun(javaReturnType, Modifier.PRIVATE, methodParameterTypes);
1: 
1: 			// add the throws clause for the public static method we are going to call.
1: 			Class[] throwsSet = ((java.lang.reflect.Method) method).getExceptionTypes();
1: 			for (int te = 0; te < throwsSet.length; te++)
1: 			{
1: 				mbnc.addThrownException(throwsSet[te].getName());
1: 			}
1: 
1: 			mbnc.getField(returnsNullOnNullState);
1: 			mbnc.conditionalIf();
1: 
1: 			// set up for a null!!
1: 			// for objects is easy.
1: 			mbnc.pushNull(javaReturnType);
1: 
1: 			mbnc.startElseCode();	
1: 
1: 			if (!actualMethodReturnType.equals(javaReturnType))
1: 				mbnc.pushNewStart(javaReturnType);
1: 
1: 			// fetch all the arguments
1: 			for (int pa = 0; pa < nargs; pa++)
1: 			{
1: 				mbnc.getParameter(pa);
1: 			}
1: 
1: 			mbcm = mbnc;
1: 		}
1: 
1: 		mbcm.callMethod(VMOpcode.INVOKESTATIC, method.getDeclaringClass().getName(), methodName,
1: 					actualMethodReturnType, nargs);
1: 
1: 
1: 		if (returnsNullOnNullState != null)
1: 		{
1: 			if (!actualMethodReturnType.equals(javaReturnType))
1: 				mbnc.pushNewComplete(1);
1: 
1: 			mbnc.completeConditional();
1: 
1: 			mbnc.methodReturn();
1: 			mbnc.complete();
1: 
1: 			// now call the wrapper method
1: 			mb.callMethod(VMOpcode.INVOKEVIRTUAL, acb.getClassBuilder().getFullName(), mbnc.getName(),
1: 					javaReturnType, nargs);
1: 			mbnc = null;
1: 		}
1: 
1: 
1: 		if (routineInfo != null) {
1: 
1: 			// reset the SQL allowed setting that we set upon
1: 			// entry to the method.
1: 			if (functionEntrySQLAllowed != null) {
1: 				acb.pushThisAsActivation(mb);
1: 				mb.callMethod(VMOpcode.INVOKEINTERFACE, null,
1: 									"getLanguageConnectionContext", ClassName.LanguageConnectionContext, 0);
1: 				mb.callMethod(VMOpcode.INVOKEINTERFACE, null,
1: 									"getStatementContext", "org.apache.derby.iapi.sql.conn.StatementContext", 0);
1: 				mb.getField(functionEntrySQLAllowed);
1: 				mb.push(true); // override as we are ending the control set by this function all.
1: 				mb.callMethod(VMOpcode.INVOKEINTERFACE, null,
1: 									"setSQLAllowed", "void", 2);
1: 
1: 			}
1: 
1: 			if (outParamArrays != null) {
1: 
1: 				MethodBuilder constructor = acb.getConstructor();
1: 
0: 				// constructor  - setting up correct paramter type info
1: 				acb.pushThisAsActivation(constructor);
1: 				constructor.callMethod(VMOpcode.INVOKEINTERFACE, null,
1: 									"getParameterValueSet", ClassName.ParameterValueSet, 0);
1: 
1: 				// execute  - passing out parameters back.
1: 				acb.pushThisAsActivation(mb);
1: 				mb.callMethod(VMOpcode.INVOKEINTERFACE, null,
1: 									"getParameterValueSet", ClassName.ParameterValueSet, 0);
1: 
1: 				int[] parameterModes = routineInfo.getParameterModes();
1: 				for (int i = 0; i < outParamArrays.length; i++) {
1: 
0: 					int parameterMode = parameterModes[i];
0: 					if (parameterMode != JDBC30Translation.PARAMETER_MODE_IN) {
1: 
1: 						// must be a parameter if it is INOUT or OUT.
1: 						ValueNode sqlParamNode = ((SQLToJavaValueNode) methodParms[i]).getSQLValueNode();
1: 
1: 
1: 						int applicationParameterNumber = applicationParameterNumbers[i];
1: 
1: 						// Set the correct parameter nodes in the ParameterValueSet at constructor time.
1: 						constructor.dup();
1: 						constructor.push(applicationParameterNumber);
1: 						constructor.push(parameterMode);
1: 						constructor.callMethod(VMOpcode.INVOKEINTERFACE, null,
1: 										"setParameterMode", "void", 2);
1: 
1: 						// Pass the value of the outparameters back to the calling code
1: 						LocalField lf = outParamArrays[i];
1: 
1: 						mb.dup(); 
1: 						mb.push(applicationParameterNumber);
1: 						mb.callMethod(VMOpcode.INVOKEINTERFACE, null,
1: 									"getParameter", ClassName.DataValueDescriptor, 1);
1: 
1: 						// see if we need to set the desired length/scale/precision of the type
1: 						DataTypeDescriptor paramdtd = sqlParamNode.getTypeServices();
1: 
1: 						boolean isNumericType = paramdtd.getTypeId().isNumericTypeId();
1: 
0: 						if (isNumericType) {
0: 							if (!paramdtd.getTypeId().isDecimalTypeId()) {
1: 
0: 								if (!((java.lang.reflect.Method) method).getParameterTypes()[i].getComponentType().isPrimitive())
0: 									mb.cast(ClassName.NumberDataValue);
1: 							}
1: 						}
1: 						else if (paramdtd.getTypeId().isBooleanTypeId())
1: 						{
0: 							if (!((java.lang.reflect.Method) method).getParameterTypes()[i].getComponentType().isPrimitive())
1: 								mb.cast(ClassName.BooleanDataValue);
1: 						}
1: 
1: 
1: 
1: 						if (paramdtd.getTypeId().variableLength()) {
1: 							// need another DVD reference for the set width below.
1: 							mb.dup();
1: 						}
1: 
1: 
1: 						mb.getField(lf); // pvs, dvd, array
1: 						mb.getArrayElement(0); // pvs, dvd, value
1: 						mb.callMethod(VMOpcode.INVOKEINTERFACE, null, "setValue", "void", 1);
1: 
1: 						if (paramdtd.getTypeId().variableLength()) {
1: 							mb.push(isNumericType ? paramdtd.getPrecision() : paramdtd.getMaximumWidth());
1: 							mb.push(paramdtd.getScale());
1: 							mb.push(isNumericType);
0: 							mb.callMethod(VMOpcode.INVOKEINTERFACE, ClassName.VariableSizeDataValue, "setWidth", ClassName.DataValueDescriptor, 3);
1: 							mb.endStatement();
1: 						}
1: 					}
1: 				}
1: 				constructor.endStatement();
1: 				mb.endStatement();
1: 			}
1: 
1: 		}
1: 	}
1: }
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:aaa6325
/////////////////////////////////////////////////////////////////////////
commit:7c5fbc4
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.types.StringDataValue;
/////////////////////////////////////////////////////////////////////////
0: 					//collation of ? operand should be same as the current schema
0: 					pn.getTypeServices().setCollationDerivation(
0: 							StringDataValue.COLLATION_DERIVATION_IMPLICIT);
0: 					pn.getTypeServices().setCollationType(
0: 							getLanguageConnectionContext().getDefaultSchema()
0: 									.getCollationType());
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2d37fd6
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:d78ad2e
/////////////////////////////////////////////////////////////////////////
0: 		getCompilerContext().addRequiredRoutinePriv(ad);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 
0: 	/**
1: 	 * Set default privilege of EXECUTE for this node. 
0: 	 */
1: 	int getPrivType()
0: 	{
1: 		return Authorizer.EXECUTE_PRIV;
0: 	}
commit:c45f5b1
/////////////////////////////////////////////////////////////////////////
0: 		getCompilerContext().addRequiredRoutinePriv(ad);
commit:d5bc20f
/////////////////////////////////////////////////////////////////////////
0: 				if ((sqlParamNode == null) || !sqlParamNode.requiresTypeFromContext())
/////////////////////////////////////////////////////////////////////////
0: 		  			if (sqlParamNode instanceof UnaryOperatorNode) {
0: 		  				ParameterNode pn = ((UnaryOperatorNode)sqlParamNode).getParameterOperand();
0: 		  				applicationParameterNumbers[p] = pn.getParameterNumber();
0: 		  			} else
0: 						applicationParameterNumbers[p] = ((ParameterNode) sqlParamNode).getParameterNumber();
/////////////////////////////////////////////////////////////////////////
0: 						sqlParamNode.setType(paramdtd);
/////////////////////////////////////////////////////////////////////////
0: 					sqlParamNode.setType(paramdtd);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 				if (sql2j.getSQLValueNode().requiresTypeFromContext()) {
1: 	  				ParameterNode pn;
1: 		  			if (sql2j.getSQLValueNode() instanceof UnaryOperatorNode) 
1: 		  				pn = ((UnaryOperatorNode)sql2j.getSQLValueNode()).getParameterOperand();
0: 		  			else
1: 		  				pn = (ParameterNode) (sql2j.getSQLValueNode());
1: 					int applicationParameterNumber = pn.getParameterNumber();
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package	org.apache.derby.impl.sql.compile;
0: 
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.sql.compile.CompilerContext;
0: import org.apache.derby.iapi.sql.compile.TypeCompiler;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
0: import org.apache.derby.iapi.types.JSQLType;
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: import org.apache.derby.iapi.types.TypeId;
0: 
0: import org.apache.derby.iapi.sql.dictionary.AliasDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
0: 
0: import org.apache.derby.iapi.reference.ClassName;
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.reference.JDBC30Translation;
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.impl.sql.compile.ExpressionClassBuilder;
0: import org.apache.derby.iapi.services.loader.ClassInspector;
0: import org.apache.derby.iapi.services.compiler.LocalField;
0: 
0: import org.apache.derby.iapi.util.JBitSet;
0: import org.apache.derby.iapi.services.classfile.VMOpcode;
0: 
0: import org.apache.derby.iapi.sql.conn.Authorizer;
0: 
0: import org.apache.derby.catalog.AliasInfo;
0: import org.apache.derby.catalog.TypeDescriptor;
0: import org.apache.derby.catalog.types.RoutineAliasInfo;
0: import org.apache.derby.impl.sql.compile.ActivationClassBuilder;
0: 
0: import org.apache.derby.catalog.UUID;
0: 
0: import java.util.Vector;
0: import java.lang.reflect.Modifier;
0: 
0: /**
0:  * A StaticMethodCallNode represents a static method call from a Class
0:  * (as opposed to from an Object).
0: 
0:    For a procedure the call requires that the arguments be ? parameters.
0:    The parameter is *logically* passed into the method call a number of different ways.
0: 
0:    <P>
0:    For a application call like CALL MYPROC(?) the logically Java method call is
0:    (in psuedo Java/SQL code) (examples with CHAR(10) parameter)
0:    <BR>
0:    Fixed length IN parameters - com.acme.MyProcedureMethod(?)
0:    <BR>
0:    Variable length IN parameters - com.acme.MyProcedureMethod(CAST (? AS CHAR(10))
0:    <BR>
0:    Fixed length INOUT parameter -
0: 		String[] holder = new String[] {?}; com.acme.MyProcedureMethod(holder); ? = holder[0]
0:    <BR>
0:    Variable length INOUT parameter -
0: 		String[] holder = new String[] {CAST (? AS CHAR(10)}; com.acme.MyProcedureMethod(holder); ? = CAST (holder[0] AS CHAR(10))
0: 
0:    <BR>
0:    Fixed length OUT parameter -
0: 		String[] holder = new String[1]; com.acme.MyProcedureMethod(holder); ? = holder[0]
0: 
0:    <BR>
0:    Variable length INOUT parameter -
0: 		String[] holder = new String[1]; com.acme.MyProcedureMethod(holder); ? = CAST (holder[0] AS CHAR(10))
0: 
0: 
0:     <P>
0: 	For static method calls there is no pre-definition of an IN or INOUT parameter, so a call to CallableStatement.registerOutParameter()
0: 	makes the parameter an INOUT parameter, provided:
0: 		- the parameter is passed directly to the method call (no casts or expressions).
0: 		- the method's parameter type is a Java array type.
0: 
0:     Since this is a dynmaic decision we compile in code to take both paths, based upon a boolean isINOUT which is dervied from the
0: 	ParameterValueSet. Code is logically (only single parameter String[] shown here). Note, no casts can exist here.
0: 
0: 	boolean isINOUT = getParameterValueSet().getParameterMode(0) == PARAMETER_IN_OUT;
0: 	if (isINOUT) {
0: 		String[] holder = new String[] {?}; com.acme.MyProcedureMethod(holder); ? = holder[0]
0: 	   
0: 	} else {
0: 		com.acme.MyProcedureMethod(?)
0: 	}
0: 
0:  *
0:  * @author Jerry Brenner
0:  */
0: public class StaticMethodCallNode extends MethodCallNode
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	private TableName procedureName;
0: 
0: 	private LocalField[] outParamArrays;
0: 	private int[]		 applicationParameterNumbers; 
0: 
0: 	private boolean		isSystemCode;
0: 	private boolean		alreadyBound;
0: 
0: 	private LocalField	returnsNullOnNullState;
0: 
0: 
0: 	AliasDescriptor	ad;
0: 
0: 
0: 	/**
0: 	 * Intializer for a NonStaticMethodCallNode
0: 	 *
0: 	 * @param methodName		The name of the method to call
0: 	 * @param javaClassName		The name of the java class that the static method belongs to.
0: 	 */
0: 	public void init(Object methodName, Object javaClassName)
0: 	{
0: 		if (methodName instanceof String)
0: 			init(methodName);
0: 		else {
0: 			procedureName = (TableName) methodName;
0: 			init(procedureName.getTableName());
0: 		}
0: 
0: 		this.javaClassName = (String) javaClassName;
0: 	}
0: 
0: 	/**
0: 	 * Bind this expression.  This means binding the sub-expressions,
0: 	 * as well as figuring out what the return type is for this expression.
0: 	 *
0: 	 * @param fromList		The FROM list for the query this
0: 	 *				expression is in, for binding columns.
0: 	 * @param subqueryList		The subquery list being built as we find SubqueryNodes
0: 	 * @param aggregateVector	The aggregate vector being built as we find AggregateNodes
0: 	 *
0: 	 * @return	this or an AggregateNode
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public JavaValueNode bindExpression(
0: 		FromList fromList, SubqueryList subqueryList,
0: 		Vector	aggregateVector) 
0: 			throws StandardException
0: 	{
0: 		// for a function we can get called recursively
0: 		if (alreadyBound)
0: 			return this;
0: 
0: 
0: 		bindParameters(fromList, subqueryList, aggregateVector);
0: 
0: 		
0: 		/* If javaClassName is null then we assume that the current methodName
0: 		 * is an alias and we must go to sysmethods to
0: 		 * get the real method and java class names for this alias.
0: 		 */
0: 		if (javaClassName == null)
0: 		{
0: 			CompilerContext cc = getCompilerContext();
0: 
0: 			// look for a routine
0: 			if (ad == null) {
0: 
0: 				String schemaName = procedureName != null ?
0: 									procedureName.getSchemaName() : null;
0: 
0: 				SchemaDescriptor sd = getSchemaDescriptor(schemaName, schemaName != null);
0: 
0: 
0: 				if (sd.getUUID() != null) {
0: 
0: 				java.util.List list = getDataDictionary().getRoutineList(
0: 					sd.getUUID().toString(), methodName,
0: 					forCallStatement ? AliasInfo.ALIAS_NAME_SPACE_PROCEDURE_AS_CHAR : AliasInfo.ALIAS_NAME_SPACE_FUNCTION_AS_CHAR
0: 					);
0: 
0: 				for (int i = list.size() - 1; i >= 0; i--) {
0: 
0: 					AliasDescriptor proc = (AliasDescriptor) list.get(i);
0: 
0: 					RoutineAliasInfo routineInfo = (RoutineAliasInfo) proc.getAliasInfo();
0: 					int parameterCount = routineInfo.getParameterCount();
0: 					if (parameterCount != methodParms.length)
0: 						continue;
0: 
0: 					// pre-form the method signature. If it is a dynamic result set procedure
0: 					// then we need to add in the ResultSet array
0: 
0: 					TypeDescriptor[] parameterTypes = routineInfo.getParameterTypes();
0: 
0: 					int sigParameterCount = parameterCount;
0: 					if (routineInfo.getMaxDynamicResultSets() > 0)
0: 						sigParameterCount++;
0: 
0: 					signature = new JSQLType[sigParameterCount];
0: 					for (int p = 0; p < parameterCount; p++) {
0: 
0: 						// find the declared type.
0: 
0: 						TypeDescriptor td = parameterTypes[p];
0: 
0: 						TypeId typeId = TypeId.getBuiltInTypeId(td.getJDBCTypeId());
0: 
0: 						TypeId parameterTypeId = typeId;
0: 
0: 
0: 						// if it's an OUT or INOUT parameter we need an array.
0: 						int parameterMode = routineInfo.getParameterModes()[p];
0: 
0: 						if (parameterMode != JDBC30Translation.PARAMETER_MODE_IN) {
0: 
0: 							String arrayType;
0: 							switch (typeId.getJDBCTypeId()) {
0: 								case java.sql.Types.SMALLINT:
0: 								case java.sql.Types.INTEGER:
0: 								case java.sql.Types.BIGINT:
0: 								case java.sql.Types.REAL:
0: 								case java.sql.Types.DOUBLE:
0: 									arrayType = getTypeCompiler(typeId).getCorrespondingPrimitiveTypeName().concat("[]");
0: 									break;
0: 								default:
0: 									arrayType = typeId.getCorrespondingJavaTypeName().concat("[]");
0: 									break;
0: 							}
0: 
0: 							typeId = TypeId.getUserDefinedTypeId(arrayType, false);
0: 						}
0: 
0: 						// this is the type descriptor of the require method parameter
0: 						DataTypeDescriptor methoddtd = new DataTypeDescriptor(
0: 								typeId,
0: 								td.getPrecision(),
0: 								td.getScale(),
0: 								td.isNullable(),
0: 								td.getMaximumWidth()
0: 							);
0: 
0: 						signature[p] = new JSQLType(methoddtd);
0: 
0: 						// check parameter is a ? node for INOUT and OUT parameters.
0: 
0: 						ValueNode sqlParamNode = null;
0: 
0: 						if (methodParms[p] instanceof SQLToJavaValueNode) {
0: 							SQLToJavaValueNode sql2j = (SQLToJavaValueNode) methodParms[p];
0: 							sqlParamNode = sql2j.getSQLValueNode();
0: 						}
0: 						else
0: 						{
0: 						}
0: 
0: 						boolean isParameterMarker = true;
0: 						if ((sqlParamNode == null) || !sqlParamNode.isParameterNode())
0: 						{
0: 							if (parameterMode != JDBC30Translation.PARAMETER_MODE_IN) {
0: 							 
0: 								throw StandardException.newException(SQLState.LANG_DB2_PARAMETER_NEEDS_MARKER,
0: 									RoutineAliasInfo.parameterMode(parameterMode),
0: 									routineInfo.getParameterNames()[p]);
0: 							}
0: 							isParameterMarker = false;
0: 						}
0: 						else
0: 						{
0: 							if (applicationParameterNumbers == null)
0: 								applicationParameterNumbers = new int[parameterCount];
0: 							applicationParameterNumbers[p] = ((ParameterNode) sqlParamNode).getParameterNumber();
0: 						}
0: 
0: 						// this is the SQL type of the procedure parameter.
0: 						DataTypeDescriptor paramdtd = new DataTypeDescriptor(
0: 							parameterTypeId,
0: 							td.getPrecision(),
0: 							td.getScale(),
0: 							td.isNullable(),
0: 							td.getMaximumWidth()
0: 						);
0: 
0: 						boolean needCast = false;
0: 						if (!isParameterMarker)
0: 						{
0: 
0: 							// can only be an IN parameter.
0: 							// check that the value can be assigned to the
0: 							// type of the procedure parameter.
0: 							if (sqlParamNode instanceof UntypedNullConstantNode)
0: 							{
0: 								sqlParamNode.setDescriptor(paramdtd);
0: 							}
0: 							else
0: 							{
0: 
0: 
0: 								DataTypeDescriptor dts;
0: 								TypeId argumentTypeId;
0: 
0: 								if (sqlParamNode != null)
0: 								{
0: 									// a node from the SQL world
0: 									argumentTypeId = sqlParamNode.getTypeId();
0: 									dts = sqlParamNode.getTypeServices();
0: 								}
0: 								else
0: 								{
0: 									// a node from the Java world
0: 									dts = DataTypeDescriptor.getSQLDataTypeDescriptor(methodParms[p].getJavaTypeName());
0: 									if (dts == null)
0: 									{
0: 										throw StandardException.newException(SQLState.LANG_NO_CORRESPONDING_S_Q_L_TYPE, 
0: 											methodParms[p].getJavaTypeName());
0: 									}
0: 
0: 									argumentTypeId = dts.getTypeId();
0: 								}
0: 
0: 								if (! getTypeCompiler(parameterTypeId).storable(argumentTypeId, getClassFactory()))
0: 										throw StandardException.newException(SQLState.LANG_NOT_STORABLE, 
0: 											parameterTypeId.getSQLTypeName(),
0: 											argumentTypeId.getSQLTypeName() );
0: 
0: 								// if it's not an exact length match then some cast will be needed.
0: 								if (!paramdtd.isExactTypeAndLengthMatch(dts))
0: 									needCast = true;
0: 							}
0: 						}
0: 						else
0: 						{
0: 							// any variable length type will need a cast from the
0: 							// Java world (the ? parameter) to the SQL type. This
0: 							// ensures values like CHAR(10) are passed into the procedure
0: 							// correctly as 10 characters long.
0: 							if (parameterTypeId.variableLength()) {
0: 
0: 								if (parameterMode != JDBC30Translation.PARAMETER_MODE_OUT)
0: 									needCast = true;
0: 							}
0: 						}
0: 						
0: 
0: 						if (needCast)
0: 						{
0: 							// push a cast node to ensure the
0: 							// correct type is passed to the method
0: 							// this gets tacky because before we knew
0: 							// it was a procedure call we ensured all the
0: 							// parameter are JavaNodeTypes. Now we need to
0: 							// push them back to the SQL domain, cast them
0: 							// and then push them back to the Java domain.
0: 
0: 							if (sqlParamNode == null) {
0: 
0: 								sqlParamNode = (ValueNode) getNodeFactory().getNode(
0: 									C_NodeTypes.JAVA_TO_SQL_VALUE_NODE,
0: 									methodParms[p], 
0: 									getContextManager());
0: 							}
0: 
0: 							ValueNode castNode = (ValueNode) getNodeFactory().getNode(
0: 								C_NodeTypes.CAST_NODE,
0: 								sqlParamNode, 
0: 								paramdtd,
0: 								getContextManager());
0: 
0: 
0: 							methodParms[p] = (JavaValueNode) getNodeFactory().getNode(
0: 									C_NodeTypes.SQL_TO_JAVA_VALUE_NODE,
0: 									castNode, 
0: 									getContextManager());
0: 
0: 							methodParms[p] = methodParms[p].bindExpression(fromList, subqueryList, aggregateVector);
0: 						}
0: 
0: 						// only force the type for a ? so that the correct type shows up
0: 						// in parameter meta data
0: 						if (isParameterMarker)
0: 							sqlParamNode.setDescriptor(paramdtd);
0: 					}
0: 
0: 					if (sigParameterCount != parameterCount) {
0: 
0: 						TypeId typeId = TypeId.getUserDefinedTypeId("java.sql.ResultSet[]", false);
0: 
0: 						DataTypeDescriptor dtd = new DataTypeDescriptor(
0: 								typeId,
0: 								0,
0: 								0,
0: 								false,
0: 								-1
0: 							);
0: 
0: 						signature[parameterCount] = new JSQLType(dtd);
0: 
0: 					}
0: 
0: 					this.routineInfo = routineInfo;
0: 					ad = proc;
0: 
0: 					// If a procedure is in the system schema and defined as executing
0: 					// SQL do we set we are in system code.
0: 					if (sd.isSystemSchema() && (routineInfo.getReturnType() == null) && routineInfo.getSQLAllowed() != RoutineAliasInfo.NO_SQL)
0: 						isSystemCode = true;
0: 
0: 					break;
0: 				}
0: 			}
0: 	
0: 			}
0: 
0: 			/* Throw exception if no alias found */
0: 			if (ad == null)
0: 			{
0: 				Object errName;
0: 				if (procedureName == null)
0: 					errName = methodName;
0: 				else
0: 					errName = procedureName;
0: 
0: 				throw StandardException.newException(SQLState.LANG_NO_SUCH_METHOD_ALIAS, errName);
0: 			}
0: 	
0: 
0: 
0: 			/* Query is dependent on the AliasDescriptor */
0: 			cc.createDependency(ad);
0: 
0: 
0: 			methodName = ad.getAliasInfo().getMethodName();
0: 			javaClassName = ad.getJavaClassName();
0: 		}
0: 
0: 
0: 		javaClassName = verifyClassExist(javaClassName, true);
0: 
0: 		/* Resolve the method call */
0: 		resolveMethodCall(javaClassName, true);
0: 
0: 
0: 		alreadyBound = true;
0: 
0: 		// If this is a function call with a variable length
0: 		// return type, then we need to push a CAST node.
0: 		if (routineInfo != null)
0: 		{
0: 			TypeDescriptor returnType = routineInfo.getReturnType();
0: 			if (returnType != null)
0: 			{
0: 				TypeId returnTypeId = TypeId.getBuiltInTypeId(returnType.getJDBCTypeId());
0: 
0: 				if (returnTypeId.variableLength()) {
0: 					// Cast the return using a cast node, but have to go
0: 					// into the SQL domain, and back to the Java domain.
0: 
0: 					DataTypeDescriptor returnValueDtd = new DataTypeDescriptor(
0: 								returnTypeId,
0: 								returnType.getPrecision(),
0: 								returnType.getScale(),
0: 								returnType.isNullable(),
0: 								returnType.getMaximumWidth()
0: 							);
0: 
0: 
0: 					ValueNode returnValueToSQL = (ValueNode) getNodeFactory().getNode(
0: 								C_NodeTypes.JAVA_TO_SQL_VALUE_NODE,
0: 								this, 
0: 								getContextManager());
0: 
0: 					ValueNode returnValueCastNode = (ValueNode) getNodeFactory().getNode(
0: 									C_NodeTypes.CAST_NODE,
0: 									returnValueToSQL, 
0: 									returnValueDtd,
0: 									getContextManager());
0: 
0: 
0: 					JavaValueNode returnValueToJava = (JavaValueNode) getNodeFactory().getNode(
0: 										C_NodeTypes.SQL_TO_JAVA_VALUE_NODE,
0: 										returnValueCastNode, 
0: 										getContextManager());
0: 
0: 					return returnValueToJava.bindExpression(fromList, subqueryList, aggregateVector);
0: 				}
0: 
0: 			}
0: 		}
0: 
0: 		return this;
0: 	}
0: 
0: 	/**
0: 		Push extra code to generate the casts within the
0: 		arrays for the parameters passed as arrays.
0: 	*/
0: 	public	void generateOneParameter(ExpressionClassBuilder acb,
0: 											MethodBuilder mb,
0: 											int parameterNumber )
0: 			throws StandardException
0: 	{
0: 		int parameterMode;
0: 
0: 
0: 		SQLToJavaValueNode sql2j = null;
0: 		if (methodParms[parameterNumber] instanceof SQLToJavaValueNode)
0: 			sql2j = (SQLToJavaValueNode) methodParms[parameterNumber];
0: 		
0: 		if (routineInfo != null) {
0: 			parameterMode = routineInfo.getParameterModes()[parameterNumber];
0: 		} else {
0: 			// for a static method call the parameter always starts out as a in parameter, but
0: 			// may be registered as an IN OUT parameter. For a static method argument to be
0: 			// a dynmaically registered out parameter it must be a simple ? parameter
0: 
0: 			parameterMode = JDBC30Translation.PARAMETER_MODE_IN;
0: 
0: 			if (sql2j != null) {
0: 				if (sql2j.getSQLValueNode().isParameterNode()) {
0: 
0: 					// applicationParameterNumbers is only set up for a procedure.
0: 					int applicationParameterNumber = ((ParameterNode) (sql2j.getSQLValueNode())).getParameterNumber();
0: 
0: 					String parameterType = methodParameterTypes[parameterNumber];
0: 
0: 					if (parameterType.endsWith("[]")) {
0: 
0: 						// constructor  - setting up correct paramter type info
0: 						MethodBuilder constructor = acb.getConstructor();
0: 						acb.pushThisAsActivation(constructor);
0: 						constructor.callMethod(VMOpcode.INVOKEINTERFACE, null,
0: 											"getParameterValueSet", ClassName.ParameterValueSet, 0);
0: 
0: 						constructor.push(applicationParameterNumber);
0: 						constructor.push(JDBC30Translation.PARAMETER_MODE_UNKNOWN);
0: 						constructor.callMethod(VMOpcode.INVOKEINTERFACE, null,
0: 											"setParameterMode", "void", 2);
0: 						constructor.endStatement();
0: 					}
0: 				}
0: 			} 
0: 		}
0: 
0: 		switch (parameterMode) {
0: 		case JDBC30Translation.PARAMETER_MODE_IN:
0: 		case JDBC30Translation.PARAMETER_MODE_IN_OUT:
0: 		case JDBC30Translation.PARAMETER_MODE_UNKNOWN:
0: 			if (sql2j != null)
0: 				sql2j.returnsNullOnNullState = returnsNullOnNullState;
0: 			super.generateOneParameter(acb, mb, parameterNumber);
0: 			break;
0: 
0: 		case JDBC30Translation.PARAMETER_MODE_OUT:
0: 			// For an OUT parameter we require nothing to be pushed into the
0: 			// method call from the parameter node.
0: 			break;
0: 		}
0: 
0: 		switch (parameterMode) {
0: 		case JDBC30Translation.PARAMETER_MODE_IN:
0: 		case JDBC30Translation.PARAMETER_MODE_UNKNOWN:
0: 			break;
0: 
0: 		case JDBC30Translation.PARAMETER_MODE_IN_OUT:
0: 		case JDBC30Translation.PARAMETER_MODE_OUT:
0: 		{
0: 			// Create the array used to pass into the method. We create a
0: 			// new array for each call as there is a small chance the
0: 			// application could retain a reference to it and corrupt
0: 			// future calls with the same CallableStatement object.
0: 
0: 			String methodParameterType = methodParameterTypes[parameterNumber];
0: 			String arrayType = methodParameterType.substring(0, methodParameterType.length() - 2);
0: 			LocalField lf = acb.newFieldDeclaration(Modifier.PRIVATE, methodParameterType);
0: 
0: 			if (outParamArrays == null)
0: 				outParamArrays = new LocalField[methodParms.length];
0: 
0: 			outParamArrays[parameterNumber] = lf;
0: 
0: 			mb.pushNewArray(arrayType, 1);
0: 			mb.putField(lf);
0: 
0: 			// set the IN part of the parameter into the INOUT parameter.
0: 			if (parameterMode != JDBC30Translation.PARAMETER_MODE_OUT) {
0: 				mb.swap();
0: 				mb.setArrayElement(0);
0: 				mb.getField(lf);
0: 			}
0: 			break;
0: 			}
0: 		}
0: 
0: 	}
0: 
0: 	/**
0: 	 * Categorize this predicate.  Initially, this means
0: 	 * building a bit map of the referenced tables for each predicate.
0: 	 * If the source of this ColumnReference (at the next underlying level) 
0: 	 * is not a ColumnReference or a VirtualColumnNode then this predicate
0: 	 * will not be pushed down.
0: 	 *
0: 	 * For example, in:
0: 	 *		select * from (select 1 from s) a (x) where x = 1
0: 	 * we will not push down x = 1.
0: 	 * NOTE: It would be easy to handle the case of a constant, but if the
0: 	 * inner SELECT returns an arbitrary expression, then we would have to copy
0: 	 * that tree into the pushed predicate, and that tree could contain
0: 	 * subqueries and method calls.
0: 	 * RESOLVE - revisit this issue once we have views.
0: 	 *
0: 	 * @param referencedTabs	JBitSet with bit map of referenced FromTables
0: 	 * @param simplePredsOnly	Whether or not to consider method
0: 	 *							calls, field references and conditional nodes
0: 	 *							when building bit map
0: 	 *
0: 	 * @return boolean		Whether or not source.expression is a ColumnReference
0: 	 *						or a VirtualColumnNode.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public boolean categorize(JBitSet referencedTabs, boolean simplePredsOnly)
0: 		throws StandardException
0: 	{
0: 		/* We stop here when only considering simple predicates
0: 		 *  as we don't consider method calls when looking
0: 		 * for null invariant predicates.
0: 		 */
0: 		if (simplePredsOnly)
0: 		{
0: 			return false;
0: 		}
0: 
0: 		boolean pushable = true;
0: 
0: 		pushable = pushable && super.categorize(referencedTabs, simplePredsOnly);
0: 
0: 		return pushable;
0: 	}
0: 
0: 	/**
0: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
0: 	 * for how this should be done for tree printing.
0: 	 *
0: 	 * @return	This object as a String
0: 	 */
0: 
0: 	public String toString()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			return "javaClassName: " +
0: 				(javaClassName != null ? javaClassName : "null") + "\n" +
0: 				super.toString();
0: 		}
0: 		else
0: 		{
0: 			return "";
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Do code generation for this method call
0: 	 *
0: 	 * @param acb	The ExpressionClassBuilder for the class we're generating
0: 	 * @param mb	The method the expression will go into
0: 	 *
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public void generateExpression(ExpressionClassBuilder acb,
0: 											MethodBuilder mb)
0: 									throws StandardException
0: 	{
0: 		if (routineInfo != null) {
0: 
0: 			if (!routineInfo.calledOnNullInput() && routineInfo.getParameterCount() != 0)
0: 				returnsNullOnNullState = acb.newFieldDeclaration(Modifier.PRIVATE, "boolean");
0: 
0: 		}
0: 
0: 		// reset the parameters are null indicator.
0: 		if (returnsNullOnNullState != null) {
0: 			mb.push(false);
0: 			mb.putField(returnsNullOnNullState);
0: 			mb.endStatement();
0: 
0: 			// for the call to the generated method below.
0: 			mb.pushThis();
0: 		}
0: 
0: 		int nargs = generateParameters(acb, mb);
0: 
0: 		LocalField functionEntrySQLAllowed = null;
0: 
0: 		if (routineInfo != null) {
0: 
0: 			short sqlAllowed = routineInfo.getSQLAllowed();
0: 
0: 			// Before we set up our authorization level, add a check to see if this
0: 			// method can be called. If the routine is NO SQL or CONTAINS SQL 
0: 			// then there is no need for a check. As follows:
0: 			//
0: 			// Current Level = NO_SQL - CALL will be rejected when getting CALL result set
0: 			// Current Level = anything else - calls to procedures defined as NO_SQL and CONTAINS SQL both allowed.
0: 
0: 
0: 			if (sqlAllowed != RoutineAliasInfo.NO_SQL)
0: 			{
0: 				
0: 				int sqlOperation;
0: 				
0: 				if (sqlAllowed == RoutineAliasInfo.READS_SQL_DATA)
0: 					sqlOperation = Authorizer.SQL_SELECT_OP;
0: 				else if (sqlAllowed == RoutineAliasInfo.MODIFIES_SQL_DATA)
0: 					sqlOperation = Authorizer.SQL_WRITE_OP;
0: 				else
0: 					sqlOperation = Authorizer.SQL_ARBITARY_OP;
0: 				
0: 				generateAuthorizeCheck((ActivationClassBuilder) acb, mb, sqlOperation);
0: 			}
0: 
0: 			int statmentContextReferences = isSystemCode ? 2 : 1;
0: 			
0: 			boolean isFunction = routineInfo.getReturnType() != null;
0: 
0: 			if (isFunction)
0: 				statmentContextReferences++;
0: 
0: 
0: 			if (statmentContextReferences != 0) {
0: 				acb.pushThisAsActivation(mb);
0: 				mb.callMethod(VMOpcode.INVOKEINTERFACE, null,
0: 									"getLanguageConnectionContext", ClassName.LanguageConnectionContext, 0);
0: 				mb.callMethod(VMOpcode.INVOKEINTERFACE, null,
0: 									"getStatementContext", "org.apache.derby.iapi.sql.conn.StatementContext", 0);
0: 
0: 				for (int scc = 1; scc < statmentContextReferences; scc++)
0: 					mb.dup();
0: 			}
0: 
0: 			/**
0: 				Set the statement context to reflect we are running
0: 				System procedures, so that we can execute non-standard SQL.
0: 			*/
0: 			if (isSystemCode) {
0: 				mb.callMethod(VMOpcode.INVOKEINTERFACE, null,
0: 									"setSystemCode", "void", 0);
0: 			}
0: 
0: 			// for a function we need to fetch the current SQL control
0: 			// so that we can reset it once the function is complete.
0: 			// 
0: 			if (isFunction)
0: 			{
0: 				functionEntrySQLAllowed = acb.newFieldDeclaration(Modifier.PRIVATE, "short");
0: 				mb.callMethod(VMOpcode.INVOKEINTERFACE, null,
0: 									"getSQLAllowed", "short", 0);
0: 				mb.putField(functionEntrySQLAllowed);
0: 				mb.endStatement();
0: 
0: 			}
0: 			
0: 			
0: 			// Set up the statement context to reflect the
0: 			// restricted SQL execution allowed by this routine.
0: 
0: 			mb.push(sqlAllowed);
0: 			mb.push(false);
0: 			mb.callMethod(VMOpcode.INVOKEINTERFACE, null,
0: 								"setSQLAllowed", "void", 2);
0: 
0: 		}
0: 
0: 		// add in the ResultSet arrays.
0: 		if (routineInfo != null) {
0: 
0: 			int compiledResultSets = methodParameterTypes.length - methodParms.length;
0: 
0: 			if (compiledResultSets != 0) {
0: 
0: 				// Add a method that indicates the maxium number of dynamic result sets.
0: 				int maxDynamicResults = routineInfo.getMaxDynamicResultSets();
0: 				if (maxDynamicResults > 0) {
0: 					MethodBuilder gdr = acb.getClassBuilder().newMethodBuilder(Modifier.PUBLIC, "int", "getMaxDynamicResults");
0: 					gdr.push(maxDynamicResults);
0: 					gdr.methodReturn();
0: 					gdr.complete();
0: 				}
0: 
0: 				// add a method to return all the dynamic result sets (unordered)
0: 				MethodBuilder gdr = acb.getClassBuilder().newMethodBuilder(Modifier.PUBLIC, "java.sql.ResultSet[][]", "getDynamicResults");
0: 
0: 				MethodBuilder cons = acb.getConstructor();
0: 				// if (procDef.getParameterStyle() == RoutineAliasInfo.PS_JAVA)
0: 				{
0: 					// PARAMETER STYLE JAVA
0: 
0: 					LocalField procedureResultSetsHolder = acb.newFieldDeclaration(Modifier.PRIVATE, "java.sql.ResultSet[][]");
0: 
0: 					// getDynamicResults body
0: 					gdr.getField(procedureResultSetsHolder);
0: 
0: 					// create the holder of all the ResultSet arrays, new java.sql.ResultSet[][compiledResultSets]
0: 					cons.pushNewArray("java.sql.ResultSet[]", compiledResultSets);
0: 					cons.putField(procedureResultSetsHolder);
0: 					cons.endStatement();
0: 
0: 
0: 					// arguments for the dynamic result sets
0: 					for (int i = 0; i < compiledResultSets; i++) {
0: 
0: 						mb.pushNewArray("java.sql.ResultSet", 1);
0: 						mb.dup();
0: 
0: 						mb.getField(procedureResultSetsHolder);
0: 						mb.swap();
0: 
0: 						mb.setArrayElement(i);
0: 					}
0: 				} 
0: 
0: 				// complete the method that returns the ResultSet[][] to the 
0: 				gdr.methodReturn();
0: 				gdr.complete();
0: 
0: 				nargs += compiledResultSets;
0: 			}
0: 
0: 		}
0: 
0: 		String javaReturnType = getJavaTypeName();
0: 
0: 		MethodBuilder mbnc = null;
0: 		MethodBuilder mbcm = mb;
0: 
0: 
0: 		// If any of the parameters are null then
0: 		// do not call the method, just return null.
0: 		if (returnsNullOnNullState != null)
0: 		{
0: 			mbnc = acb.newGeneratedFun(javaReturnType, Modifier.PRIVATE, methodParameterTypes);
0: 
0: 			// add the throws clause for the public static method we are going to call.
0: 			Class[] throwsSet = ((java.lang.reflect.Method) method).getExceptionTypes();
0: 			for (int te = 0; te < throwsSet.length; te++)
0: 			{
0: 				mbnc.addThrownException(throwsSet[te].getName());
0: 			}
0: 
0: 			mbnc.getField(returnsNullOnNullState);
0: 			mbnc.conditionalIf();
0: 
0: 			// set up for a null!!
0: 			// for objects is easy.
0: 			mbnc.pushNull(javaReturnType);
0: 
0: 			mbnc.startElseCode();	
0: 
0: 			if (!actualMethodReturnType.equals(javaReturnType))
0: 				mbnc.pushNewStart(javaReturnType);
0: 
0: 			// fetch all the arguments
0: 			for (int pa = 0; pa < nargs; pa++)
0: 			{
0: 				mbnc.getParameter(pa);
0: 			}
0: 
0: 			mbcm = mbnc;
0: 		}
0: 
0: 		mbcm.callMethod(VMOpcode.INVOKESTATIC, method.getDeclaringClass().getName(), methodName,
0: 					actualMethodReturnType, nargs);
0: 
0: 
0: 		if (returnsNullOnNullState != null)
0: 		{
0: 			if (!actualMethodReturnType.equals(javaReturnType))
0: 				mbnc.pushNewComplete(1);
0: 
0: 			mbnc.completeConditional();
0: 
0: 			mbnc.methodReturn();
0: 			mbnc.complete();
0: 
0: 			// now call the wrapper method
0: 			mb.callMethod(VMOpcode.INVOKEVIRTUAL, acb.getClassBuilder().getFullName(), mbnc.getName(),
0: 					javaReturnType, nargs);
0: 			mbnc = null;
0: 		}
0: 
0: 
0: 		if (routineInfo != null) {
0: 
0: 			// reset the SQL allowed setting that we set upon
0: 			// entry to the method.
0: 			if (functionEntrySQLAllowed != null) {
0: 				acb.pushThisAsActivation(mb);
0: 				mb.callMethod(VMOpcode.INVOKEINTERFACE, null,
0: 									"getLanguageConnectionContext", ClassName.LanguageConnectionContext, 0);
0: 				mb.callMethod(VMOpcode.INVOKEINTERFACE, null,
0: 									"getStatementContext", "org.apache.derby.iapi.sql.conn.StatementContext", 0);
0: 				mb.getField(functionEntrySQLAllowed);
0: 				mb.push(true); // override as we are ending the control set by this function all.
0: 				mb.callMethod(VMOpcode.INVOKEINTERFACE, null,
0: 									"setSQLAllowed", "void", 2);
0: 
0: 			}
0: 
0: 			if (outParamArrays != null) {
0: 
0: 				MethodBuilder constructor = acb.getConstructor();
0: 
0: 				// constructor  - setting up correct paramter type info
0: 				acb.pushThisAsActivation(constructor);
0: 				constructor.callMethod(VMOpcode.INVOKEINTERFACE, null,
0: 									"getParameterValueSet", ClassName.ParameterValueSet, 0);
0: 
0: 				// execute  - passing out parameters back.
0: 				acb.pushThisAsActivation(mb);
0: 				mb.callMethod(VMOpcode.INVOKEINTERFACE, null,
0: 									"getParameterValueSet", ClassName.ParameterValueSet, 0);
0: 
0: 				int[] parameterModes = routineInfo.getParameterModes();
0: 				for (int i = 0; i < outParamArrays.length; i++) {
0: 
0: 					int parameterMode = parameterModes[i];
0: 					if (parameterMode != JDBC30Translation.PARAMETER_MODE_IN) {
0: 
0: 						// must be a parameter if it is INOUT or OUT.
0: 						ValueNode sqlParamNode = ((SQLToJavaValueNode) methodParms[i]).getSQLValueNode();
0: 
0: 
0: 						int applicationParameterNumber = applicationParameterNumbers[i];
0: 
0: 						// Set the correct parameter nodes in the ParameterValueSet at constructor time.
0: 						constructor.dup();
0: 						constructor.push(applicationParameterNumber);
0: 						constructor.push(parameterMode);
0: 						constructor.callMethod(VMOpcode.INVOKEINTERFACE, null,
0: 										"setParameterMode", "void", 2);
0: 
0: 						// Pass the value of the outparameters back to the calling code
0: 						LocalField lf = outParamArrays[i];
0: 
0: 						mb.dup(); 
0: 						mb.push(applicationParameterNumber);
0: 						mb.callMethod(VMOpcode.INVOKEINTERFACE, null,
0: 									"getParameter", ClassName.DataValueDescriptor, 1);
0: 
0: 						// see if we need to set the desired length/scale/precision of the type
0: 						DataTypeDescriptor paramdtd = sqlParamNode.getTypeServices();
0: 
0: 						boolean isNumericType = paramdtd.getTypeId().isNumericTypeId();
0: 
0: 						if (isNumericType) {
0: 							if (!paramdtd.getTypeId().isDecimalTypeId()) {
0: 
0: 								if (!((java.lang.reflect.Method) method).getParameterTypes()[i].getComponentType().isPrimitive())
0: 									mb.cast(ClassName.NumberDataValue);
0: 							}
0: 						}
0: 						else if (paramdtd.getTypeId().isBooleanTypeId())
0: 						{
0: 							if (!((java.lang.reflect.Method) method).getParameterTypes()[i].getComponentType().isPrimitive())
0: 								mb.cast(ClassName.BooleanDataValue);
0: 						}
0: 
0: 
0: 
0: 						if (paramdtd.getTypeId().variableLength()) {
0: 							// need another DVD reference for the set width below.
0: 							mb.dup();
0: 						}
0: 
0: 
0: 						mb.getField(lf); // pvs, dvd, array
0: 						mb.getArrayElement(0); // pvs, dvd, value
0: 						mb.callMethod(VMOpcode.INVOKEINTERFACE, null, "setValue", "void", 1);
0: 
0: 						if (paramdtd.getTypeId().variableLength()) {
0: 							mb.push(isNumericType ? paramdtd.getPrecision() : paramdtd.getMaximumWidth());
0: 							mb.push(paramdtd.getScale());
0: 							mb.push(isNumericType);
0: 							mb.callMethod(VMOpcode.INVOKEINTERFACE, ClassName.VariableSizeDataValue, "setWidth", ClassName.DataValueDescriptor, 3);
0: 							mb.endStatement();
0: 						}
0: 					}
0: 				}
0: 				constructor.endStatement();
0: 				mb.endStatement();
0: 			}
0: 
0: 		}
0: 	}
0: }
============================================================================