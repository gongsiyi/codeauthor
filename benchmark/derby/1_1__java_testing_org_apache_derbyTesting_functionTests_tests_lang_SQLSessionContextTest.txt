1:6950a39: /*
1:6950a39: 
1:6950a39:    Derby - Class org.apache.derbyTesting.functionTests.tests.lang.SQLSessionContextTest
1:6950a39: 
1:6950a39:    Licensed to the Apache Software Foundation (ASF) under one or more
1:6950a39:    contributor license agreements.  See the NOTICE file distributed with
1:6950a39:    this work for additional information regarding copyright ownership.
1:6950a39:    The ASF licenses this file to you under the Apache License, Version 2.0
1:6950a39:    (the "License"); you may not use this file except in compliance with
1:6950a39:    the License.  You may obtain a copy of the License at
1:6950a39: 
1:6950a39:      http://www.apache.org/licenses/LICENSE-2.0
1:6950a39: 
1:6950a39:    Unless required by applicable law or agreed to in writing, software
1:6950a39:    distributed under the License is distributed on an "AS IS" BASIS,
1:6950a39:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:6950a39:    See the License for the specific language governing permissions and
1:6950a39:    limitations under the License.
1:6950a39: 
1:6950a39:  */
1:6950a39: 
1:6950a39: package org.apache.derbyTesting.functionTests.tests.lang;
1:6950a39: 
1:6950a39: import java.sql.Connection;
1:1ae02c9: import java.sql.DriverManager;
1:6950a39: import java.sql.PreparedStatement;
1:6950a39: import java.sql.ResultSet;
1:1ae02c9: import java.sql.SQLException;
1:1ae02c9: import java.sql.Statement;
1:6950a39: import junit.framework.Test;
1:6950a39: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:6950a39: import org.apache.derbyTesting.junit.DatabasePropertyTestSetup;
1:6950a39: import org.apache.derbyTesting.junit.JDBC;
1:1ae02c9: import org.apache.derbyTesting.junit.TestConfiguration;
1:6950a39: 
1:6950a39: /**
1:6950a39:  * SQLSessionContextTest tests the SQL session context stacking,
1:6950a39:  * cf. SQL 4.37.3. The testing of one of the SQL session state
1:6950a39:  * variable, the current role, relies on sqlAuthorization being set,
1:6950a39:  * so use sqlAuthorization=true.
1:6950a39:  *
1:6950a39:  * State variables tested:
1:6950a39:  *   current role            (SET ROLE <role>, CURRENT_ROLE)
1:6950a39:  *   current default schema  (SET SCHEMA <schema>, CURRENT SCHEMA)
1:6950a39:  *
1:6950a39:  * SET SCHEMA and SET ROLE are SQL SESSION statements and are not
1:6950a39:  * transaction-initiating, cf. SQL section 4.33.
1:6950a39:  *
1:6950a39:  * The tests are run in the cross product:
1:6950a39:  *
1:6950a39:  *    {client/server, embedded} x
1:6950a39:  *    {data base owner}
1:6950a39:  *
1:9f60172:  * See also RoutinesDefinersRightsTest, which tests the current user part of
1:9f60172:  * the SQLSessionContext.
1:6950a39:  */
1:6950a39: public class SQLSessionContextTest extends BaseJDBCTestCase
1:6950a39: {
1:6950a39:     /* internal state */
1:6950a39:     private Connection _conn;
1:6950a39:     private Statement _stm;
1:6950a39: 
1:6950a39:     private final static String pwSuffix = "pwSuffix";
1:6950a39: 
1:6950a39:     /**
1:6950a39:      * SQL states used by test
1:6950a39:      */
1:6950a39:     private final static String userException = "38000";
1:6950a39: 
1:6950a39:     /**
1:6950a39:      * The TestConfiguration.sqlAuthorizationDecorator decorator presumes
1:6950a39:      * TEST_DBO as dbo, so add it to set of valid users. It uses a fresh db
1:6950a39:      * 'dbsqlauth', not 'wombat'.
1:6950a39:      */
1:6950a39:     private final static String[] users = {"TEST_DBO"};
1:6950a39: 
1:6950a39:     /**
1:6950a39:      * SQL keywords for session context state variables
1:6950a39:      */
1:6950a39:     private final static String[] variableKeywords =
1:6950a39:         new String[]{"role", "schema"};
1:6950a39: 
1:6950a39:     /**
1:6950a39:      * SQL prefix used to retrieve current value of a session context
1:6950a39:      * state variable. Cf. variableKeywords.
1:6950a39:      */
1:6950a39:     private final static String[] currentPrefix =
1:6950a39:         new String[]{"current_", "current "};
1:6950a39: 
1:6950a39:     /**
1:6950a39:      * Create a new instance of SQLSessionContextTest.
1:6950a39:      *
1:6950a39:      * @param name Fixture name
1:6950a39:      */
1:6950a39: 
1:6950a39:     public SQLSessionContextTest(String name)
1:6950a39:     {
1:6950a39:         super(name);
1:6950a39:     }
1:6950a39: 
1:6950a39: 
1:6950a39:     /**
1:6950a39:      * Construct top level suite in this JUnit test
1:6950a39:      *
1:6950a39:      * @return A suite containing embedded and client suites.
1:6950a39:      *         Client/server suite commented out to speed up this test as
1:6950a39:      *         it does not add much value given the nature of the changes
1:6950a39:      *         (SQL language only).
1:6950a39:      */
1:6950a39:     public static Test suite()
1:6950a39:     {
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite("SQLSessionContextTest");
1:6950a39: 
1:6950a39:         /* Positive tests */
1:6950a39:         if (!JDBC.vmSupportsJSR169()) {
1:6950a39:             // JSR169 cannot run with tests with stored procedures
1:6950a39:             // that do database access - for they require a
1:6950a39:             // DriverManager connection to jdbc:default:connection;
1:6950a39:             // DriverManager is not supported with JSR169.
1:6950a39:             suite.addTest(
1:6950a39:                 positiveSuite("suite: positive, embedded"));
1:6950a39: 
1:6950a39:             suite.addTest(
1:6950a39:                 TestConfiguration.clientServerDecorator(
1:6950a39:                     positiveSuite("suite: positive, client")));
1:6950a39:         }
1:6950a39: 
1:6950a39:         return suite;
1:6950a39:     }
1:6950a39: 
1:6950a39:     /**
1:6950a39:      * Construct suite of positive tests
1:6950a39:      *
1:6950a39:      * @param framework Derby framework indication
1:6950a39:      *
1:6950a39:      * @return A suite containing the positive test cases incarnated only
1:6950a39:      * for security level sqlAuthorization.
1:6950a39:      */
1:6950a39:     private static Test positiveSuite(String framework)
1:6950a39:     {
1:6950a39:         /* Tests running with sql authorization set.
1:6950a39:          * First decorate with users, then with authentication +
1:6950a39:          * sqlAuthorization.
1:6950a39:          */
1:6950a39: 
1:6950a39:         // add decorator for different users authenticated
1:1ae02c9:         BaseTestSuite usersSuite =
1:1ae02c9:             new BaseTestSuite("suite: positiveSuite");
1:6950a39: 
1:6950a39:         // First decorate with users, then with authorization
1:6950a39:         // decorator
1:6950a39:         for (int userNo = 0; userNo < users.length; userNo++) {
1:6950a39:             usersSuite.addTest
1:6950a39:                 (TestConfiguration.changeUserDecorator
1:6950a39:                  (new SQLSessionContextTest("testPositive"),
1:6950a39:                   users[userNo],
1:6950a39:                   users[userNo].concat(pwSuffix)));
1:6950a39:         }
1:6950a39: 
1:6950a39:         return TestConfiguration.sqlAuthorizationDecorator(
1:6950a39:             DatabasePropertyTestSetup.builtinAuthentication(
1:6950a39:                 usersSuite, users, pwSuffix));
1:6950a39:     }
1:6950a39: 
1:6950a39:     /**
1:6950a39:      * Positive tests for SQL session state.
1:6950a39:      *
1:6950a39:      * @throws SQLException
1:6950a39:      */
1:6950a39:     public void testPositive() throws SQLException
1:6950a39:     {
1:6950a39:         PreparedStatement[]ps = new PreparedStatement[]{null, null};
1:6950a39: 
1:6950a39:         for (int i= 0; i < variableKeywords.length; i++) {
1:6950a39:             String curr = currentPrefix[i] + variableKeywords[i];
1:6950a39:             ps[i] = _conn.prepareStatement("values " + curr);
1:6950a39:         }
1:6950a39: 
1:6950a39:         println("testPositive user="+getTestConfiguration().getUserName());
1:6950a39: 
1:6950a39:         /*
1:6950a39:          * SET SESSION STATE variables
1:6950a39:          */
1:6950a39:         _stm.executeUpdate("set role outermost");
1:6950a39:         _stm.executeUpdate("set schema outermost");
1:6950a39: 
1:6950a39:         /**
1:6950a39:          * The SQL standard requires we have an SQL session context
1:6950a39:          * see section 4.27.3, which is stacked. The stack is pushed
1:6950a39:          * at entry to a stored procedure or function.  The current
1:6950a39:          * SQL session state is popped at end of stored procedure.  We
1:6950a39:          * test two levels deep.
1:6950a39:          */
1:6950a39:         _stm.execute("call test_dbo.p2()");
1:6950a39: 
1:6950a39:         // Dynamic result set: At what time should CURRENT_<state> be
1:6950a39:         // evaluated?  Logically at the inside (inside the nested
1:6950a39:         // SQL session context), so it should be "LEVEL2" also when
1:6950a39:         // accessed on outside (outer SQL session context) I
1:6950a39:         // think. Anyway, that's what's implemented: the
1:6950a39:         // activation of the call is still live and holds (the
1:6950a39:         // final state of) the nested SQL session context
1:6950a39:         // even when the procedure call has
1:6950a39:         // returned.
1:6950a39:         ResultSet prs = _stm.getResultSet(); // role
1:6950a39:         assertCurrent("role", prs, "LEVEL2");
1:6950a39: 
1:6950a39:         _stm.getMoreResults(Statement.CLOSE_CURRENT_RESULT);
1:6950a39:         prs = _stm.getResultSet();
1:6950a39:         assertCurrent("schema", prs, "LEVEL2");
1:6950a39:         prs.close();
1:6950a39: 
1:6950a39:         // check that state didn't get impacted by change inside p2
1:6950a39:         //
1:6950a39:         for (int i= 0; i < variableKeywords.length; i++) {
1:6950a39:             ResultSet rs = ps[i].executeQuery();
1:6950a39:             assertCurrent(variableKeywords[i], rs, "OUTERMOST");
1:6950a39:             rs.close();
1:6950a39:         }
1:6950a39: 
1:6950a39:         ResultSet rs = _stm.executeQuery("values test_dbo.f2()");
1:6950a39: 
1:6950a39: 
1:6950a39:         // Gotcha: we need to fetch first row for embedded driver
1:6950a39:         // to actually call f2. The client driver prefetches, so
1:6950a39:         // call to f2 will get performed even without the next():
1:6950a39:         rs.next();
1:6950a39:         rs.close();
1:6950a39: 
1:6950a39:         // check that state didn't get impacted by change inside f2
1:6950a39:         //
1:6950a39:         for (int i= 0; i < variableKeywords.length; i++) {
1:6950a39:             rs = ps[i].executeQuery();
1:6950a39:             assertCurrent(variableKeywords[i], rs, "OUTERMOST");
1:6950a39:             rs.close();
1:6950a39:         }
1:6950a39: 
1:6950a39:         // check that f2 doesn't impact f22
1:6950a39:         rs = _stm.executeQuery("values test_dbo.f2() + test_dbo.f22()");
1:6950a39:         rs.next();
1:6950a39:         rs.close();
1:6950a39: 
1:6950a39:         // check that pushed SQL session context was popped also
1:6950a39:         // when the callee gets an exception
1:6950a39:         try {
1:6950a39:             rs = _stm.executeQuery("values test_dbo.f3()");
1:6950a39:             rs.next();
1:6950a39:         } catch (SQLException e) {
1:6950a39:             assertSQLState(userException, e);
1:6950a39:         }
1:6950a39: 
1:6950a39:         for (int i= 0; i < 1; i++) {
1:6950a39:             rs = ps[i].executeQuery();
1:6950a39:             assertCurrent(variableKeywords[i], rs, "OUTERMOST");
1:6950a39:             rs.close();
1:6950a39:         }
1:6950a39: 
1:6950a39:         // Test that when a nested routine drops a role/schema the
1:6950a39:         // caller's stacked value is correctly reset. See also javadoc
1:6950a39:         // for dropper.
1:6950a39:         _stm.execute("call test_dbo.dropper()");
1:6950a39: 
1:34b59c6:         String[] expected = new String[]{null, "TEST_DBO"};
1:6950a39:         for (int i= 0; i < 1; i++) {
1:6950a39:             rs = ps[i].executeQuery();
1:6950a39:             assertCurrent(variableKeywords[i], rs, expected[i]);
1:6950a39:             rs.close();
1:6950a39:         }
1:6950a39: 
1:6950a39:         for (int i= 0; i < variableKeywords.length; i++) {
1:6950a39:             ps[i].close();
1:6950a39:         }
1:e3883f5: 
1:e3883f5:         // DERBY-3897: See
1:e3883f5:         //
1:e3883f5:         // RolesConferredPrivilegesTest#testDefaultCurrentRole and
1:e3883f5:         // RolesConferredPrivilegesTest#testCurrentRoleInWeirdContexts
1:e3883f5:         //
1:e3883f5:         // which are also relevant tests for SQLSessionContext.
1:6950a39:     }
1:6950a39: 
1:6950a39: 
1:6950a39:     protected void setUp() throws Exception
1:6950a39:     {
1:6950a39:         super.setUp();
1:6950a39: 
1:6950a39:         _stm = createStatement();
1:6950a39:         _conn = getConnection();
1:6950a39: 
1:6950a39:         _stm.executeUpdate("create role outermost");
1:6950a39:         _stm.executeUpdate("create role level2");
1:6950a39:         _stm.executeUpdate("create role innermost");
1:6950a39:         _stm.executeUpdate("create schema outermost");
1:6950a39:         _stm.executeUpdate("create schema level2");
1:6950a39:         _stm.executeUpdate("create schema innermost");
1:6950a39: 
1:6950a39:         _stm.executeUpdate(
1:6950a39:             "create procedure p2()" +
1:6950a39:             "  dynamic result sets 2 language java parameter style java"+
1:6950a39:             "  external name 'org.apache.derbyTesting." +
1:6950a39:             "functionTests.tests.lang.SQLSessionContextTest.p2'" +
1:6950a39:             "  modifies sql data");
1:6950a39:         _stm.executeUpdate(
1:6950a39:             "create function f2()" +
1:6950a39:             "  returns int language java parameter style java" +
1:6950a39:             "  external name 'org.apache.derbyTesting." +
1:6950a39:             "functionTests.tests.lang.SQLSessionContextTest.f2'" +
1:6950a39:             "  reads sql data");
1:6950a39:         _stm.executeUpdate(
1:6950a39:             "create function f22()" +
1:6950a39:             "  returns int language java parameter style java" +
1:6950a39:             "  external name 'org.apache.derbyTesting." +
1:6950a39:             "functionTests.tests.lang.SQLSessionContextTest.f22'" +
1:6950a39:             "  reads sql data");
1:6950a39:         _stm.executeUpdate(
1:6950a39:             "create function f3()" +
1:6950a39:             "  returns int language java parameter style java" +
1:6950a39:             "  external name 'org.apache.derbyTesting." +
1:6950a39:             "functionTests.tests.lang.SQLSessionContextTest.f3'" +
1:6950a39:             "  reads sql data");
1:6950a39:         _stm.executeUpdate(
1:6950a39:             "create procedure calledNestedFromP2(state VARCHAR(255))" +
1:6950a39:             "  language java parameter style java" +
1:6950a39:             "  external name 'org.apache.derbyTesting." +
1:6950a39:             "functionTests.tests.lang.SQLSessionContextTest.calledNestedFromP2'"
1:6950a39:             +
1:6950a39:             "  modifies sql data");
1:6950a39:         _stm.executeUpdate(
1:6950a39:             "create procedure dropper()" +
1:6950a39:             "  language java parameter style java" +
1:6950a39:             "  external name 'org.apache.derbyTesting." +
1:6950a39:             "functionTests.tests.lang.SQLSessionContextTest.dropper'" +
1:6950a39:             "  modifies sql data");
1:6950a39:     }
1:6950a39: 
1:6950a39: 
1:6950a39:     protected void tearDown() throws Exception
1:6950a39:     {
1:6950a39:         try {
1:6950a39:             _stm.executeUpdate("set schema test_dbo");
1:6950a39:             // "OUTERMOST" role/schema is dropped as part of the test,
1:6950a39:             // cf. stored procedure 'dropper'.
1:6950a39:             _stm.executeUpdate("drop role level2");
1:6950a39:             _stm.executeUpdate("drop role innermost");
1:6950a39:             _stm.executeUpdate("drop schema level2 restrict");
1:6950a39:             _stm.executeUpdate("drop schema innermost restrict");
1:6950a39:             _stm.executeUpdate("drop procedure p2");
1:6950a39:             _stm.executeUpdate("drop function f2");
1:6950a39:             _stm.executeUpdate("drop function f22");
1:6950a39:             _stm.executeUpdate("drop function f3");
1:6950a39:             _stm.executeUpdate("drop procedure calledNestedFromP2");
1:6950a39:             _stm.executeUpdate("drop procedure dropper");
1:6950a39:         }
1:6950a39:         finally {
1:6950a39:             if (_stm != null) {
1:6950a39:                 _stm = null;
1:6950a39:             }
1:6950a39: 
1:6950a39:             if (_conn != null) {
1:6950a39:                 _conn = null;
1:6950a39:             }
1:6950a39: 
1:6950a39:             super.tearDown();
1:6950a39:         }
1:6950a39: 
1:6950a39:     }
1:6950a39: 
1:6950a39: 
1:44ea4f0:     private static void assertCurrent(String sessionVar,
1:6950a39:                                       ResultSet rs,
1:6950a39:                                       String expected)
1:6950a39:             throws SQLException
1:6950a39:     {
1:6950a39:         assertTrue("result set empty", rs.next());
1:6950a39:         String actualCurrent = rs.getString(1);
1:6950a39: 
1:44ea4f0:         if (sessionVar.equals("role") && expected != null) {
1:44ea4f0:             // returned current_role is a delimited identifer, which is SQL
1:44ea4f0:             // standard compliant. current_schema returns case normal form,
1:44ea4f0:             // which is not.
1:44ea4f0:             expected = "\"" + expected + "\"";
1:44ea4f0:         }
1:44ea4f0: 
1:34b59c6:         if (expected != null) {
1:44ea4f0:             assertTrue(sessionVar + ": current is " + actualCurrent +
1:6950a39:                        ", expected " + expected,
1:34b59c6:                        expected.equals(actualCurrent));
1:34b59c6:         } else {
1:44ea4f0:             assertTrue(sessionVar + ": current is " + actualCurrent +
1:34b59c6:                        ", expected null",
1:34b59c6:                        actualCurrent == null);
1:34b59c6:         }
1:34b59c6: 
1:34b59c6: 
1:6950a39: 
1:6950a39:         // cardinality should be 1
1:6950a39:         assertFalse("result set not empty", rs.next());
1:6950a39:     }
1:6950a39: 
1:6950a39: 
1:6950a39:     /**
1:6950a39:      * Utility procedure used to test that current session state is
1:6950a39:      * stacked correctly in a nested SQL session context.
1:6950a39:      */
1:6950a39:     public static void p2(ResultSet[] rs1, ResultSet[] rs2)
1:6950a39:             throws Throwable
1:6950a39:     {
1:6950a39:         Connection conn1 = null;
1:6950a39:         Connection conn2 = null;
1:6950a39: 
1:6950a39:         try {
1:6950a39:             conn1 = DriverManager.getConnection("jdbc:default:connection");
1:6950a39: 
1:6950a39:             for (int i= 0; i < variableKeywords.length; i++) {
1:6950a39: 
1:6950a39:                 String curr = currentPrefix[i] + variableKeywords[i];
1:6950a39: 
1:6950a39:                 PreparedStatement ps =
1:6950a39:                     conn1.prepareStatement("values " + curr);
1:6950a39: 
1:6950a39:                 // check that we inherit context correctly
1:6950a39:                 // current role, cf. SQL 4.34.1.1 and 4.27.3
1:6950a39:                 // current default schema, cf. SQL 4.37.3 and 4.37.5
1:6950a39:                 ResultSet rs = ps.executeQuery();
1:6950a39:                 assertCurrent(variableKeywords[i], rs, "OUTERMOST");
1:6950a39:                 rs.close();
1:6950a39: 
1:6950a39:                 // set the state to "LEVEL2"
1:6950a39:                 Statement stm = conn1.createStatement();
1:6950a39:                 stm.executeUpdate("set " + variableKeywords[i] + " level2");
1:6950a39:                 rs = ps.executeQuery();
1:6950a39: 
1:6950a39:                 // check that state got set
1:6950a39:                 assertCurrent(variableKeywords[i], rs, "LEVEL2");
1:6950a39: 
1:6950a39:                 // another nesting level to test session context stack
1:6950a39:                 // even more
1:6950a39:                 conn1.commit(); // need to be idle
1:6950a39:                 stm.executeUpdate("call test_dbo.calledNestedFromP2('"
1:6950a39:                                   + variableKeywords[i] + "')");
1:6950a39: 
1:6950a39:                 rs = ps.executeQuery();
1:6950a39: 
1:6950a39:                 // check that state didn't get impacted by change inside
1:6950a39:                 // calledNestedFromP2 to 'INNERMOST':
1:6950a39:                 assertCurrent(variableKeywords[i], rs, "LEVEL2");
1:6950a39:                 rs.close();
1:6950a39: 
1:6950a39:                 // Test that the state is shared by another nested
1:6950a39:                 // connection also.
1:6950a39:                 conn2 = DriverManager.getConnection("jdbc:default:connection");
1:6950a39:                 PreparedStatement ps2 =
1:6950a39:                     conn2.prepareStatement("values " + curr);
1:6950a39:                 rs = ps2.executeQuery();
1:6950a39:                 assertCurrent(variableKeywords[i], rs, "LEVEL2");
1:6950a39:                 rs.close();
1:6950a39:                 ps2.close();
1:6950a39:             }
1:6950a39: 
1:6950a39:             for (int i= 0; i < variableKeywords.length; i++) {
1:6950a39:                 // Pass out CURRENT <state> in a dynamic result set.
1:6950a39:                 String curr = currentPrefix[i] + variableKeywords[i];
1:6950a39:                 PreparedStatement ps =
1:6950a39:                     conn1.prepareStatement("values " + curr);
1:6950a39:                 ResultSet rs = ps.executeQuery();
1:6950a39: 
1:6950a39:                 if (variableKeywords[i].equals("role")) {
1:6950a39:                     rs1[0] = rs;
1:6950a39:                 } else {
1:6950a39:                     rs2[0] = rs;
1:6950a39:                 }
1:6950a39:             }
1:6950a39:         } catch (Throwable e) {
1:6950a39:             // Print here if debug, since on outside we only see 38000
1:6950a39:             // (user error)
1:6950a39:             println("err: " + e);
1:6950a39: 
1:6950a39:             throw e;
1:6950a39: 
1:6950a39:         } finally {
1:6950a39: 
1:6950a39:             if (conn1 != null) {
1:6950a39:                 try {
1:6950a39:                     conn1.close();
1:6950a39:                 } catch (Exception e) {
1:6950a39:                 }
1:6950a39:             }
1:6950a39: 
1:6950a39:             if (conn2 != null) {
1:6950a39:                 try {
1:6950a39:                     conn2.close();
1:6950a39:                 } catch (Exception e) {
1:6950a39:                 }
1:6950a39:             }
1:6950a39:         }
1:6950a39: 
1:6950a39:     }
1:6950a39: 
1:6950a39:     /**
1:6950a39:      * Called from p2 so we get to test with a call stack 3 levels
1:6950a39:      * deep.
1:6950a39:      */
1:6950a39:     public static void calledNestedFromP2(String stateString)
1:6950a39:             throws SQLException
1:6950a39:     {
1:6950a39:         Connection conn1 = null;
1:6950a39:         Connection conn2 = null;
1:6950a39: 
1:6950a39:         try {
1:6950a39:             conn1 = DriverManager.getConnection("jdbc:default:connection");
1:6950a39: 
1:6950a39:             // CURRENT_ROLE  vs CURRENT SCHEMA syntax:
1:6950a39:             String curr = stateString.equals("role")
1:6950a39:                 ? "current_role"
1:6950a39:                 : "current schema";
1:6950a39: 
1:6950a39:             PreparedStatement ps =
1:6950a39:                 conn1.prepareStatement("values " + curr);
1:6950a39: 
1:6950a39:             // check that we inherit state correctly
1:6950a39:             ResultSet rs = ps.executeQuery();
1:6950a39:             assertCurrent(stateString, rs, "LEVEL2");
1:6950a39:             rs.close();
1:6950a39: 
1:6950a39:             // set the state to "INNERMOST"
1:6950a39:             Statement stm = conn1.createStatement();
1:6950a39:             stm.executeUpdate("set " + stateString + " innermost");
1:6950a39:             rs = ps.executeQuery();
1:6950a39: 
1:6950a39:             // check that state got set
1:6950a39:             assertCurrent(stateString, rs, "INNERMOST");
1:6950a39:             rs.close();
1:6950a39:             ps.close();
1:6950a39: 
1:6950a39:             // Test that the session context is shared by another
1:6950a39:             // nested connection also.
1:6950a39:             conn2 = DriverManager.getConnection("jdbc:default:connection");
1:6950a39:             ps = conn2.prepareStatement("values " + curr);
1:6950a39:             rs = ps.executeQuery();
1:6950a39:             assertCurrent(stateString, rs, "INNERMOST");
1:6950a39:             rs.close();
1:6950a39:             ps.close();
1:6950a39: 
1:6950a39:         } finally {
1:6950a39:             if (conn1 != null) {
1:6950a39:                 try {
1:6950a39:                     conn1.close();
1:6950a39:                 } catch (Exception e) {
1:6950a39:                 }
1:6950a39:             }
1:6950a39:             if (conn2 != null) {
1:6950a39:                 try {
1:6950a39:                     conn2.close();
1:6950a39:                 } catch (Exception e) {
1:6950a39:                 }
1:6950a39:             }
1:6950a39:         }
1:6950a39:     }
1:6950a39: 
1:6950a39: 
1:6950a39:     /**
1:6950a39:      * Utility function used to test that state variables are stacked
1:6950a39:      * correctly in a nested SQL session context.
1:6950a39:      */
1:6950a39:     public static int f2() throws SQLException
1:6950a39:     {
1:6950a39:         Connection conn1 = null;
1:6950a39:         Connection conn2 = null;
1:6950a39: 
1:6950a39:         try {
1:6950a39:             conn1 = DriverManager.getConnection("jdbc:default:connection");
1:6950a39: 
1:6950a39:             for (int i= 0; i < variableKeywords.length; i++) {
1:6950a39:                 String curr = currentPrefix[i] + variableKeywords[i];
1:6950a39: 
1:6950a39:                 PreparedStatement ps =
1:6950a39:                     conn1.prepareStatement("values " + curr);
1:6950a39: 
1:6950a39:                 // check that we inherit context correctly
1:6950a39:                 ResultSet rs = ps.executeQuery();
1:6950a39:                 assertCurrent(variableKeywords[i], rs, "OUTERMOST");
1:6950a39:                 rs.close();
1:6950a39: 
1:6950a39:                 // set the state to "LEVEL2"
1:6950a39:                 Statement stm = conn1.createStatement();
1:6950a39:                 stm.executeUpdate("set " + variableKeywords[i] + " level2");
1:6950a39:                 rs = ps.executeQuery();
1:6950a39: 
1:6950a39:                 // check that state got set
1:6950a39:                 assertCurrent(variableKeywords[i], rs, "LEVEL2");
1:6950a39: 
1:6950a39:                 ps.close();
1:6950a39: 
1:6950a39:                 // Test that the state is shared by another nested
1:6950a39:                 // connection also.
1:6950a39:                 conn2 = DriverManager.getConnection("jdbc:default:connection");
1:6950a39:                 ps = conn2.prepareStatement("values " + curr);
1:6950a39:                 rs = ps.executeQuery();
1:6950a39:                 assertCurrent(variableKeywords[i], rs, "LEVEL2");
1:6950a39:                 rs.close();
1:6950a39:                 ps.close();
1:6950a39:             }
1:6950a39: 
1:6950a39:         } finally {
1:6950a39: 
1:6950a39:             if (conn1 != null) {
1:6950a39:                 try {
1:6950a39:                     conn1.close();
1:6950a39:                 } catch (Exception e) {
1:6950a39:                 }
1:6950a39:             }
1:6950a39:             if (conn2 != null) {
1:6950a39:                 try {
1:6950a39:                     conn2.close();
1:6950a39:                 } catch (Exception e) {
1:6950a39:                 }
1:6950a39:             }
1:6950a39:         }
1:6950a39: 
1:6950a39:         return 1;
1:6950a39:     }
1:6950a39: 
1:6950a39: 
1:6950a39:     /**
1:6950a39:      * Used to test that a parallel (subsequent) function call in the
1:6950a39:      * same statement (called after f2 which changes state) is not
1:6950a39:      * affected by the preceding function (f2) call's changes.
1:6950a39:      *
1:6950a39:      */
1:6950a39:     public static int f22() throws SQLException
1:6950a39:     {
1:6950a39:         Connection conn1 = null;
1:6950a39: 
1:6950a39:         try {
1:6950a39:             conn1 = DriverManager.getConnection("jdbc:default:connection");
1:6950a39: 
1:6950a39:             for (int i= 0; i < variableKeywords.length; i++) {
1:6950a39:                 String curr = currentPrefix[i] + variableKeywords[i];
1:6950a39: 
1:6950a39:                 PreparedStatement ps =
1:6950a39:                     conn1.prepareStatement("values " + curr);
1:6950a39: 
1:6950a39:                 // check that we inherit context correctly
1:6950a39:                 ResultSet rs = ps.executeQuery();
1:6950a39:                 assertCurrent(variableKeywords[i], rs, "OUTERMOST");
1:6950a39:                 rs.close();
1:6950a39:                 ps.close();
1:6950a39:             }
1:6950a39: 
1:6950a39:         } finally {
1:6950a39: 
1:6950a39:             if (conn1 != null) {
1:6950a39:                 try {
1:6950a39:                     conn1.close();
1:6950a39:                 } catch (Exception e) {
1:6950a39:                 }
1:6950a39:             }
1:6950a39:         }
1:6950a39: 
1:6950a39:         return 1;
1:6950a39:     }
1:6950a39: 
1:6950a39: 
1:6950a39:     /**
1:6950a39:      * Utility function used to test that current state is stacked
1:6950a39:      * correctly in a nested SQL session context.  This particular
1:6950a39:      * function will throw and exception. This is used to test that
1:6950a39:      * the cleaning up pops the SQL session stack also.
1:6950a39:      */
1:6950a39:     public static int f3() throws SQLException
1:6950a39:     {
1:6950a39:         Connection conn1 = null;
1:6950a39: 
1:6950a39:         try {
1:6950a39:             conn1 = DriverManager.getConnection("jdbc:default:connection");
1:6950a39:             // set the state to something else
1:6950a39:             Statement stm = conn1.createStatement();
1:6950a39:             stm.executeUpdate("set role level2");
1:6950a39:             stm.executeUpdate("set schema level2");
1:6950a39: 
1:6950a39:             PreparedStatement ps =
1:6950a39:                 conn1.prepareStatement("values 42");
1:6950a39:             ResultSet rs = ps.executeQuery();
1:6950a39:             rs.next();
1:6950a39:             // force an exception, rs. is empty, next should throw now
1:6950a39:             rs.next();
1:6950a39:             String s = rs.getString(1);
1:6950a39:         } finally {
1:6950a39:             if (conn1 != null) {
1:6950a39:                 try {
1:6950a39:                     conn1.close();
1:6950a39:                 } catch (Exception e) {
1:6950a39:                 }
1:6950a39:             }
1:6950a39:         }
1:6950a39:         return 1;
1:6950a39:     }
1:6950a39: 
1:6950a39: 
1:6950a39:     /**
1:6950a39:      * Test that when a nested routine drops a role/schema, the
1:6950a39:      * current value is correctly reset. For roles, the current role
1:6950a39:      * is unchanged, since it is lazily checked (and potentially reset
1:6950a39:      * to NONE if it no longer exists or it is no longer granted to
1:34b59c6:      * session user) only when it is attempted used for anything. For
1:34b59c6:      * schema, the current schema should revert back to the session's
1:34b59c6:      * default schema. This holds for all frames on the session
1:34b59c6:      * context stack (see also caller's check).
1:6950a39:      */
1:6950a39:     public static void dropper() throws SQLException
1:6950a39:     {
1:6950a39:         Connection conn1 = null;
1:6950a39: 
1:6950a39:         try {
1:6950a39:             conn1 = DriverManager.getConnection("jdbc:default:connection");
1:6950a39: 
1:6950a39:             // Drop current contexts
1:6950a39:             Statement stm = conn1.createStatement();
1:6950a39:             stm.executeUpdate("drop role outermost");
1:6950a39:             stm.executeUpdate("drop schema outermost restrict");
1:6950a39:             stm.close();
1:6950a39: 
1:34b59c6:             String[] expected = new String[]{null, "TEST_DBO"};
1:6950a39: 
1:6950a39:             // check that we revert correctly
1:6950a39:             for (int i= 0; i < variableKeywords.length; i++) {
1:6950a39:                 String curr = currentPrefix[i] + variableKeywords[i];
1:6950a39: 
1:6950a39:                 PreparedStatement ps =
1:6950a39:                     conn1.prepareStatement("values " + curr);
1:6950a39: 
1:6950a39:                 ResultSet rs = ps.executeQuery();
1:6950a39:                 assertCurrent(variableKeywords[i], rs, expected[i]);
1:6950a39:                 rs.close();
1:6950a39:                 ps.close();
1:6950a39:             }
1:6950a39:         } finally {
1:6950a39:             if (conn1 != null) {
1:6950a39:                 try {
1:6950a39:                     conn1.close();
1:6950a39:                 } catch (Exception e) {
1:6950a39:                 }
1:6950a39:             }
1:6950a39:         }
1:6950a39:     }
1:6950a39: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import java.sql.DriverManager;
1: import java.sql.SQLException;
1: import java.sql.Statement;
1: import org.apache.derbyTesting.junit.BaseTestSuite;
1: import org.apache.derbyTesting.junit.TestConfiguration;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite("SQLSessionContextTest");
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite usersSuite =
1:             new BaseTestSuite("suite: positiveSuite");
commit:9f60172
/////////////////////////////////////////////////////////////////////////
1:  * See also RoutinesDefinersRightsTest, which tests the current user part of
1:  * the SQLSessionContext.
commit:e3883f5
/////////////////////////////////////////////////////////////////////////
1: 
1:         // DERBY-3897: See
1:         //
1:         // RolesConferredPrivilegesTest#testDefaultCurrentRole and
1:         // RolesConferredPrivilegesTest#testCurrentRoleInWeirdContexts
1:         //
1:         // which are also relevant tests for SQLSessionContext.
commit:44ea4f0
/////////////////////////////////////////////////////////////////////////
1:     private static void assertCurrent(String sessionVar,
/////////////////////////////////////////////////////////////////////////
1:         if (sessionVar.equals("role") && expected != null) {
1:             // returned current_role is a delimited identifer, which is SQL
1:             // standard compliant. current_schema returns case normal form,
1:             // which is not.
1:             expected = "\"" + expected + "\"";
1:         }
1: 
1:             assertTrue(sessionVar + ": current is " + actualCurrent +
1:             assertTrue(sessionVar + ": current is " + actualCurrent +
commit:34b59c6
/////////////////////////////////////////////////////////////////////////
1:         String[] expected = new String[]{null, "TEST_DBO"};
/////////////////////////////////////////////////////////////////////////
1:         if (expected != null) {
0:             assertTrue(comment + "current is " + actualCurrent +
1:                        expected.equals(actualCurrent));
1:         } else {
0:             assertTrue(comment + "current is " + actualCurrent +
1:                        ", expected null",
1:                        actualCurrent == null);
1:         }
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:      * session user) only when it is attempted used for anything. For
1:      * schema, the current schema should revert back to the session's
1:      * default schema. This holds for all frames on the session
1:      * context stack (see also caller's check).
/////////////////////////////////////////////////////////////////////////
1:             String[] expected = new String[]{null, "TEST_DBO"};
commit:6950a39
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derbyTesting.functionTests.tests.lang.SQLSessionContextTest
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:      http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.tests.lang;
1: 
0: import java.sql.SQLException;
0: import java.sql.SQLWarning;
1: import java.sql.Connection;
0: import java.sql.Statement;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
0: import java.sql.DriverManager;
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.DatabasePropertyTestSetup;
0: import org.apache.derbyTesting.junit.TestConfiguration;
1: import org.apache.derbyTesting.junit.JDBC;
1: 
1: /**
1:  * SQLSessionContextTest tests the SQL session context stacking,
1:  * cf. SQL 4.37.3. The testing of one of the SQL session state
1:  * variable, the current role, relies on sqlAuthorization being set,
1:  * so use sqlAuthorization=true.
1:  *
1:  * State variables tested:
1:  *   current role            (SET ROLE <role>, CURRENT_ROLE)
1:  *   current default schema  (SET SCHEMA <schema>, CURRENT SCHEMA)
1:  *
1:  * SET SCHEMA and SET ROLE are SQL SESSION statements and are not
1:  * transaction-initiating, cf. SQL section 4.33.
1:  *
1:  * The tests are run in the cross product:
1:  *
1:  *    {client/server, embedded} x
1:  *    {data base owner}
1:  *
1:  */
1: public class SQLSessionContextTest extends BaseJDBCTestCase
1: {
1:     /* internal state */
1:     private Connection _conn;
1:     private Statement _stm;
1: 
1:     private final static String pwSuffix = "pwSuffix";
1: 
1:     /**
1:      * SQL states used by test
1:      */
1:     private final static String userException = "38000";
1: 
1:     /**
1:      * The TestConfiguration.sqlAuthorizationDecorator decorator presumes
1:      * TEST_DBO as dbo, so add it to set of valid users. It uses a fresh db
1:      * 'dbsqlauth', not 'wombat'.
1:      */
1:     private final static String[] users = {"TEST_DBO"};
1: 
1:     /**
1:      * SQL keywords for session context state variables
1:      */
1:     private final static String[] variableKeywords =
1:         new String[]{"role", "schema"};
1: 
1:     /**
1:      * SQL prefix used to retrieve current value of a session context
1:      * state variable. Cf. variableKeywords.
1:      */
1:     private final static String[] currentPrefix =
1:         new String[]{"current_", "current "};
1: 
1:     /**
1:      * Create a new instance of SQLSessionContextTest.
1:      *
1:      * @param name Fixture name
1:      */
1: 
1:     public SQLSessionContextTest(String name)
1:     {
1:         super(name);
1:     }
1: 
1: 
1:     /**
1:      * Construct top level suite in this JUnit test
1:      *
1:      * @return A suite containing embedded and client suites.
1:      *         Client/server suite commented out to speed up this test as
1:      *         it does not add much value given the nature of the changes
1:      *         (SQL language only).
1:      */
1:     public static Test suite()
1:     {
0:         TestSuite suite = new TestSuite("SQLSessionContextTest");
1: 
1:         /* Positive tests */
1:         if (!JDBC.vmSupportsJSR169()) {
1:             // JSR169 cannot run with tests with stored procedures
1:             // that do database access - for they require a
1:             // DriverManager connection to jdbc:default:connection;
1:             // DriverManager is not supported with JSR169.
1:             suite.addTest(
1:                 positiveSuite("suite: positive, embedded"));
1: 
1:             suite.addTest(
1:                 TestConfiguration.clientServerDecorator(
1:                     positiveSuite("suite: positive, client")));
1:         }
1: 
1:         return suite;
1:     }
1: 
1:     /**
1:      * Construct suite of positive tests
1:      *
1:      * @param framework Derby framework indication
1:      *
1:      * @return A suite containing the positive test cases incarnated only
1:      * for security level sqlAuthorization.
1:      */
1:     private static Test positiveSuite(String framework)
1:     {
1:         /* Tests running with sql authorization set.
1:          * First decorate with users, then with authentication +
1:          * sqlAuthorization.
1:          */
1: 
1:         // add decorator for different users authenticated
0:         TestSuite usersSuite =
0:             new TestSuite("suite: positiveSuite");
1: 
1:         // First decorate with users, then with authorization
1:         // decorator
1:         for (int userNo = 0; userNo < users.length; userNo++) {
1:             usersSuite.addTest
1:                 (TestConfiguration.changeUserDecorator
1:                  (new SQLSessionContextTest("testPositive"),
1:                   users[userNo],
1:                   users[userNo].concat(pwSuffix)));
1:         }
1: 
1:         return TestConfiguration.sqlAuthorizationDecorator(
1:             DatabasePropertyTestSetup.builtinAuthentication(
1:                 usersSuite, users, pwSuffix));
1:     }
1: 
1:     /**
1:      * Positive tests for SQL session state.
1:      *
1:      * @throws SQLException
1:      */
1:     public void testPositive() throws SQLException
1:     {
1:         PreparedStatement[]ps = new PreparedStatement[]{null, null};
1: 
1:         for (int i= 0; i < variableKeywords.length; i++) {
1:             String curr = currentPrefix[i] + variableKeywords[i];
1:             ps[i] = _conn.prepareStatement("values " + curr);
1:         }
1: 
1:         println("testPositive user="+getTestConfiguration().getUserName());
1: 
1:         /*
1:          * SET SESSION STATE variables
1:          */
1:         _stm.executeUpdate("set role outermost");
1:         _stm.executeUpdate("set schema outermost");
1: 
1:         /**
1:          * The SQL standard requires we have an SQL session context
1:          * see section 4.27.3, which is stacked. The stack is pushed
1:          * at entry to a stored procedure or function.  The current
1:          * SQL session state is popped at end of stored procedure.  We
1:          * test two levels deep.
1:          */
1:         _stm.execute("call test_dbo.p2()");
1: 
1:         // Dynamic result set: At what time should CURRENT_<state> be
1:         // evaluated?  Logically at the inside (inside the nested
1:         // SQL session context), so it should be "LEVEL2" also when
1:         // accessed on outside (outer SQL session context) I
1:         // think. Anyway, that's what's implemented: the
1:         // activation of the call is still live and holds (the
1:         // final state of) the nested SQL session context
1:         // even when the procedure call has
1:         // returned.
1:         ResultSet prs = _stm.getResultSet(); // role
1:         assertCurrent("role", prs, "LEVEL2");
1: 
1:         _stm.getMoreResults(Statement.CLOSE_CURRENT_RESULT);
1:         prs = _stm.getResultSet();
1:         assertCurrent("schema", prs, "LEVEL2");
1:         prs.close();
1: 
1:         // check that state didn't get impacted by change inside p2
1:         //
1:         for (int i= 0; i < variableKeywords.length; i++) {
1:             ResultSet rs = ps[i].executeQuery();
1:             assertCurrent(variableKeywords[i], rs, "OUTERMOST");
1:             rs.close();
1:         }
1: 
1:         ResultSet rs = _stm.executeQuery("values test_dbo.f2()");
1: 
1: 
1:         // Gotcha: we need to fetch first row for embedded driver
1:         // to actually call f2. The client driver prefetches, so
1:         // call to f2 will get performed even without the next():
1:         rs.next();
1:         rs.close();
1: 
1:         // check that state didn't get impacted by change inside f2
1:         //
1:         for (int i= 0; i < variableKeywords.length; i++) {
1:             rs = ps[i].executeQuery();
1:             assertCurrent(variableKeywords[i], rs, "OUTERMOST");
1:             rs.close();
1:         }
1: 
1:         // check that f2 doesn't impact f22
1:         rs = _stm.executeQuery("values test_dbo.f2() + test_dbo.f22()");
1:         rs.next();
1:         rs.close();
1: 
1:         // check that pushed SQL session context was popped also
1:         // when the callee gets an exception
1:         try {
1:             rs = _stm.executeQuery("values test_dbo.f3()");
1:             rs.next();
1:         } catch (SQLException e) {
1:             assertSQLState(userException, e);
1:         }
1: 
1:         for (int i= 0; i < 1; i++) {
1:             rs = ps[i].executeQuery();
1:             assertCurrent(variableKeywords[i], rs, "OUTERMOST");
1:             rs.close();
1:         }
1: 
1:         // Test that when a nested routine drops a role/schema the
1:         // caller's stacked value is correctly reset. See also javadoc
1:         // for dropper.
1:         _stm.execute("call test_dbo.dropper()");
1: 
0:         String[] expected = new String[]{"OUTERMOST", "TEST_DBO"};
1:         for (int i= 0; i < 1; i++) {
1:             rs = ps[i].executeQuery();
1:             assertCurrent(variableKeywords[i], rs, expected[i]);
1:             rs.close();
1:         }
1: 
1:         for (int i= 0; i < variableKeywords.length; i++) {
1:             ps[i].close();
1:         }
1:     }
1: 
1: 
1:     protected void setUp() throws Exception
1:     {
1:         super.setUp();
1: 
1:         _stm = createStatement();
1:         _conn = getConnection();
1: 
1:         _stm.executeUpdate("create role outermost");
1:         _stm.executeUpdate("create role level2");
1:         _stm.executeUpdate("create role innermost");
1:         _stm.executeUpdate("create schema outermost");
1:         _stm.executeUpdate("create schema level2");
1:         _stm.executeUpdate("create schema innermost");
1: 
1:         _stm.executeUpdate(
1:             "create procedure p2()" +
1:             "  dynamic result sets 2 language java parameter style java"+
1:             "  external name 'org.apache.derbyTesting." +
1:             "functionTests.tests.lang.SQLSessionContextTest.p2'" +
1:             "  modifies sql data");
1:         _stm.executeUpdate(
1:             "create function f2()" +
1:             "  returns int language java parameter style java" +
1:             "  external name 'org.apache.derbyTesting." +
1:             "functionTests.tests.lang.SQLSessionContextTest.f2'" +
1:             "  reads sql data");
1:         _stm.executeUpdate(
1:             "create function f22()" +
1:             "  returns int language java parameter style java" +
1:             "  external name 'org.apache.derbyTesting." +
1:             "functionTests.tests.lang.SQLSessionContextTest.f22'" +
1:             "  reads sql data");
1:         _stm.executeUpdate(
1:             "create function f3()" +
1:             "  returns int language java parameter style java" +
1:             "  external name 'org.apache.derbyTesting." +
1:             "functionTests.tests.lang.SQLSessionContextTest.f3'" +
1:             "  reads sql data");
1:         _stm.executeUpdate(
1:             "create procedure calledNestedFromP2(state VARCHAR(255))" +
1:             "  language java parameter style java" +
1:             "  external name 'org.apache.derbyTesting." +
1:             "functionTests.tests.lang.SQLSessionContextTest.calledNestedFromP2'"
1:             +
1:             "  modifies sql data");
1:         _stm.executeUpdate(
1:             "create procedure dropper()" +
1:             "  language java parameter style java" +
1:             "  external name 'org.apache.derbyTesting." +
1:             "functionTests.tests.lang.SQLSessionContextTest.dropper'" +
1:             "  modifies sql data");
1:     }
1: 
1: 
1:     protected void tearDown() throws Exception
1:     {
1:         try {
1:             _stm.executeUpdate("set schema test_dbo");
1:             // "OUTERMOST" role/schema is dropped as part of the test,
1:             // cf. stored procedure 'dropper'.
1:             _stm.executeUpdate("drop role level2");
1:             _stm.executeUpdate("drop role innermost");
1:             _stm.executeUpdate("drop schema level2 restrict");
1:             _stm.executeUpdate("drop schema innermost restrict");
1:             _stm.executeUpdate("drop procedure p2");
1:             _stm.executeUpdate("drop function f2");
1:             _stm.executeUpdate("drop function f22");
1:             _stm.executeUpdate("drop function f3");
1:             _stm.executeUpdate("drop procedure calledNestedFromP2");
1:             _stm.executeUpdate("drop procedure dropper");
1:         }
1:         finally {
1:             if (_stm != null) {
1:                 _stm = null;
1:             }
1: 
1:             if (_conn != null) {
1:                 _conn = null;
1:             }
1: 
1:             super.tearDown();
1:         }
1: 
1:     }
1: 
1: 
0:     private static void assertCurrent(String comment,
1:                                       ResultSet rs,
1:                                       String expected)
1:             throws SQLException
1:     {
1:         assertTrue("result set empty", rs.next());
1:         String actualCurrent = rs.getString(1);
1: 
0:         assertTrue(comment + "current is " + actualCurrent +
1:                        ", expected " + expected,
0:                    expected.equals(actualCurrent));
1: 
1:         // cardinality should be 1
1:         assertFalse("result set not empty", rs.next());
1:     }
1: 
1: 
1:     /**
1:      * Utility procedure used to test that current session state is
1:      * stacked correctly in a nested SQL session context.
1:      */
1:     public static void p2(ResultSet[] rs1, ResultSet[] rs2)
1:             throws Throwable
1:     {
1:         Connection conn1 = null;
1:         Connection conn2 = null;
1: 
1:         try {
1:             conn1 = DriverManager.getConnection("jdbc:default:connection");
1: 
1:             for (int i= 0; i < variableKeywords.length; i++) {
1: 
1:                 String curr = currentPrefix[i] + variableKeywords[i];
1: 
1:                 PreparedStatement ps =
1:                     conn1.prepareStatement("values " + curr);
1: 
1:                 // check that we inherit context correctly
1:                 // current role, cf. SQL 4.34.1.1 and 4.27.3
1:                 // current default schema, cf. SQL 4.37.3 and 4.37.5
1:                 ResultSet rs = ps.executeQuery();
1:                 assertCurrent(variableKeywords[i], rs, "OUTERMOST");
1:                 rs.close();
1: 
1:                 // set the state to "LEVEL2"
1:                 Statement stm = conn1.createStatement();
1:                 stm.executeUpdate("set " + variableKeywords[i] + " level2");
1:                 rs = ps.executeQuery();
1: 
1:                 // check that state got set
1:                 assertCurrent(variableKeywords[i], rs, "LEVEL2");
1: 
1:                 // another nesting level to test session context stack
1:                 // even more
1:                 conn1.commit(); // need to be idle
1:                 stm.executeUpdate("call test_dbo.calledNestedFromP2('"
1:                                   + variableKeywords[i] + "')");
1: 
1:                 rs = ps.executeQuery();
1: 
1:                 // check that state didn't get impacted by change inside
1:                 // calledNestedFromP2 to 'INNERMOST':
1:                 assertCurrent(variableKeywords[i], rs, "LEVEL2");
1:                 rs.close();
1: 
1:                 // Test that the state is shared by another nested
1:                 // connection also.
1:                 conn2 = DriverManager.getConnection("jdbc:default:connection");
1:                 PreparedStatement ps2 =
1:                     conn2.prepareStatement("values " + curr);
1:                 rs = ps2.executeQuery();
1:                 assertCurrent(variableKeywords[i], rs, "LEVEL2");
1:                 rs.close();
1:                 ps2.close();
1:             }
1: 
1:             for (int i= 0; i < variableKeywords.length; i++) {
1:                 // Pass out CURRENT <state> in a dynamic result set.
1:                 String curr = currentPrefix[i] + variableKeywords[i];
1:                 PreparedStatement ps =
1:                     conn1.prepareStatement("values " + curr);
1:                 ResultSet rs = ps.executeQuery();
1: 
1:                 if (variableKeywords[i].equals("role")) {
1:                     rs1[0] = rs;
1:                 } else {
1:                     rs2[0] = rs;
1:                 }
1:             }
1:         } catch (Throwable e) {
1:             // Print here if debug, since on outside we only see 38000
1:             // (user error)
1:             println("err: " + e);
1: 
1:             throw e;
1: 
1:         } finally {
1: 
1:             if (conn1 != null) {
1:                 try {
1:                     conn1.close();
1:                 } catch (Exception e) {
1:                 }
1:             }
1: 
1:             if (conn2 != null) {
1:                 try {
1:                     conn2.close();
1:                 } catch (Exception e) {
1:                 }
1:             }
1:         }
1: 
1:     }
1: 
1:     /**
1:      * Called from p2 so we get to test with a call stack 3 levels
1:      * deep.
1:      */
1:     public static void calledNestedFromP2(String stateString)
1:             throws SQLException
1:     {
1:         Connection conn1 = null;
1:         Connection conn2 = null;
1: 
1:         try {
1:             conn1 = DriverManager.getConnection("jdbc:default:connection");
1: 
1:             // CURRENT_ROLE  vs CURRENT SCHEMA syntax:
1:             String curr = stateString.equals("role")
1:                 ? "current_role"
1:                 : "current schema";
1: 
1:             PreparedStatement ps =
1:                 conn1.prepareStatement("values " + curr);
1: 
1:             // check that we inherit state correctly
1:             ResultSet rs = ps.executeQuery();
1:             assertCurrent(stateString, rs, "LEVEL2");
1:             rs.close();
1: 
1:             // set the state to "INNERMOST"
1:             Statement stm = conn1.createStatement();
1:             stm.executeUpdate("set " + stateString + " innermost");
1:             rs = ps.executeQuery();
1: 
1:             // check that state got set
1:             assertCurrent(stateString, rs, "INNERMOST");
1:             rs.close();
1:             ps.close();
1: 
1:             // Test that the session context is shared by another
1:             // nested connection also.
1:             conn2 = DriverManager.getConnection("jdbc:default:connection");
1:             ps = conn2.prepareStatement("values " + curr);
1:             rs = ps.executeQuery();
1:             assertCurrent(stateString, rs, "INNERMOST");
1:             rs.close();
1:             ps.close();
1: 
1:         } finally {
1:             if (conn1 != null) {
1:                 try {
1:                     conn1.close();
1:                 } catch (Exception e) {
1:                 }
1:             }
1:             if (conn2 != null) {
1:                 try {
1:                     conn2.close();
1:                 } catch (Exception e) {
1:                 }
1:             }
1:         }
1:     }
1: 
1: 
1:     /**
1:      * Utility function used to test that state variables are stacked
1:      * correctly in a nested SQL session context.
1:      */
1:     public static int f2() throws SQLException
1:     {
1:         Connection conn1 = null;
1:         Connection conn2 = null;
1: 
1:         try {
1:             conn1 = DriverManager.getConnection("jdbc:default:connection");
1: 
1:             for (int i= 0; i < variableKeywords.length; i++) {
1:                 String curr = currentPrefix[i] + variableKeywords[i];
1: 
1:                 PreparedStatement ps =
1:                     conn1.prepareStatement("values " + curr);
1: 
1:                 // check that we inherit context correctly
1:                 ResultSet rs = ps.executeQuery();
1:                 assertCurrent(variableKeywords[i], rs, "OUTERMOST");
1:                 rs.close();
1: 
1:                 // set the state to "LEVEL2"
1:                 Statement stm = conn1.createStatement();
1:                 stm.executeUpdate("set " + variableKeywords[i] + " level2");
1:                 rs = ps.executeQuery();
1: 
1:                 // check that state got set
1:                 assertCurrent(variableKeywords[i], rs, "LEVEL2");
1: 
1:                 ps.close();
1: 
1:                 // Test that the state is shared by another nested
1:                 // connection also.
1:                 conn2 = DriverManager.getConnection("jdbc:default:connection");
1:                 ps = conn2.prepareStatement("values " + curr);
1:                 rs = ps.executeQuery();
1:                 assertCurrent(variableKeywords[i], rs, "LEVEL2");
1:                 rs.close();
1:                 ps.close();
1:             }
1: 
1:         } finally {
1: 
1:             if (conn1 != null) {
1:                 try {
1:                     conn1.close();
1:                 } catch (Exception e) {
1:                 }
1:             }
1:             if (conn2 != null) {
1:                 try {
1:                     conn2.close();
1:                 } catch (Exception e) {
1:                 }
1:             }
1:         }
1: 
1:         return 1;
1:     }
1: 
1: 
1:     /**
1:      * Used to test that a parallel (subsequent) function call in the
1:      * same statement (called after f2 which changes state) is not
1:      * affected by the preceding function (f2) call's changes.
1:      *
1:      */
1:     public static int f22() throws SQLException
1:     {
1:         Connection conn1 = null;
1: 
1:         try {
1:             conn1 = DriverManager.getConnection("jdbc:default:connection");
1: 
1:             for (int i= 0; i < variableKeywords.length; i++) {
1:                 String curr = currentPrefix[i] + variableKeywords[i];
1: 
1:                 PreparedStatement ps =
1:                     conn1.prepareStatement("values " + curr);
1: 
1:                 // check that we inherit context correctly
1:                 ResultSet rs = ps.executeQuery();
1:                 assertCurrent(variableKeywords[i], rs, "OUTERMOST");
1:                 rs.close();
1:                 ps.close();
1:             }
1: 
1:         } finally {
1: 
1:             if (conn1 != null) {
1:                 try {
1:                     conn1.close();
1:                 } catch (Exception e) {
1:                 }
1:             }
1:         }
1: 
1:         return 1;
1:     }
1: 
1: 
1:     /**
1:      * Utility function used to test that current state is stacked
1:      * correctly in a nested SQL session context.  This particular
1:      * function will throw and exception. This is used to test that
1:      * the cleaning up pops the SQL session stack also.
1:      */
1:     public static int f3() throws SQLException
1:     {
1:         Connection conn1 = null;
1: 
1:         try {
1:             conn1 = DriverManager.getConnection("jdbc:default:connection");
1:             // set the state to something else
1:             Statement stm = conn1.createStatement();
1:             stm.executeUpdate("set role level2");
1:             stm.executeUpdate("set schema level2");
1: 
1:             PreparedStatement ps =
1:                 conn1.prepareStatement("values 42");
1:             ResultSet rs = ps.executeQuery();
1:             rs.next();
1:             // force an exception, rs. is empty, next should throw now
1:             rs.next();
1:             String s = rs.getString(1);
1:         } finally {
1:             if (conn1 != null) {
1:                 try {
1:                     conn1.close();
1:                 } catch (Exception e) {
1:                 }
1:             }
1:         }
1:         return 1;
1:     }
1: 
1: 
1:     /**
1:      * Test that when a nested routine drops a role/schema, the
1:      * current value is correctly reset. For roles, the current role
1:      * is unchanged, since it is lazily checked (and potentially reset
1:      * to NONE if it no longer exists or it is no longer granted to
0:      * session user) only when it is attempted used for anything
0:      * except retrieving its current value. For schema, the current
0:      * schema should revert back to the session's default schema. This
0:      * holds for all frames on the session context stack (see also
0:      * caller's check).
1:      */
1:     public static void dropper() throws SQLException
1:     {
1:         Connection conn1 = null;
1: 
1:         try {
1:             conn1 = DriverManager.getConnection("jdbc:default:connection");
1: 
1:             // Drop current contexts
1:             Statement stm = conn1.createStatement();
1:             stm.executeUpdate("drop role outermost");
1:             stm.executeUpdate("drop schema outermost restrict");
1:             stm.close();
1: 
0:             String[] expected = new String[]{"OUTERMOST", "TEST_DBO"};
1: 
1:             // check that we revert correctly
1:             for (int i= 0; i < variableKeywords.length; i++) {
1:                 String curr = currentPrefix[i] + variableKeywords[i];
1: 
1:                 PreparedStatement ps =
1:                     conn1.prepareStatement("values " + curr);
1: 
1:                 ResultSet rs = ps.executeQuery();
1:                 assertCurrent(variableKeywords[i], rs, expected[i]);
1:                 rs.close();
1:                 ps.close();
1:             }
1:         } finally {
1:             if (conn1 != null) {
1:                 try {
1:                     conn1.close();
1:                 } catch (Exception e) {
1:                 }
1:             }
1:         }
1:     }
1: }
============================================================================