1:782dbe1: /*
1:782dbe1: 
1:782dbe1:    Derby - Class org.apache.derby.impl.sql.execute.xplain.XPLAINSystemTableVisitor
1:782dbe1: 
1:782dbe1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:782dbe1:    contributor license agreements.  See the NOTICE file distributed with
1:782dbe1:    this work for additional information regarding copyright ownership.
1:782dbe1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:782dbe1:    (the "License"); you may not use this file except in compliance with
1:782dbe1:    the License.  You may obtain a copy of the License at
1:782dbe1: 
1:782dbe1:       http://www.apache.org/licenses/LICENSE-2.0
1:782dbe1: 
1:782dbe1:    Unless required by applicable law or agreed to in writing, software
1:782dbe1:    distributed under the License is distributed on an "AS IS" BASIS,
1:782dbe1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:782dbe1:    See the License for the specific language governing permissions and
1:782dbe1:    limitations under the License.
1:782dbe1: 
1:782dbe1:  */
1:782dbe1: 
1:48a9884: package org.apache.derby.impl.sql.execute.xplain;
1:48a9884: 
1:48a9884: import java.sql.Connection;
1:48a9884: import java.sql.PreparedStatement;
1:48a9884: import java.sql.SQLException;
1:48a9884: import java.sql.Timestamp;
1:48a9884: import java.util.ArrayList;
1:48a9884: import java.util.Iterator;
1:48a9884: import java.util.List;
1:48a9884: import java.util.Stack;
1:48a9884: 
1:48a9884: import org.apache.derby.catalog.UUID;
1:48a9884: import org.apache.derby.iapi.jdbc.ConnectionContext;
1:48a9884: import org.apache.derby.iapi.error.StandardException;
1:48a9884: import org.apache.derby.iapi.services.info.JVMInfo;
1:48a9884: import org.apache.derby.iapi.sql.Activation;
1:48a9884: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1:48a9884: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1:48a9884: import org.apache.derby.impl.sql.catalog.XPLAINResultSetDescriptor;
1:48a9884: import org.apache.derby.impl.sql.catalog.XPLAINResultSetTimingsDescriptor;
1:48a9884: import org.apache.derby.impl.sql.catalog.XPLAINScanPropsDescriptor;
1:48a9884: import org.apache.derby.impl.sql.catalog.XPLAINSortPropsDescriptor;
1:48a9884: import org.apache.derby.impl.sql.catalog.XPLAINStatementDescriptor;
1:48a9884: import org.apache.derby.impl.sql.catalog.XPLAINStatementTimingsDescriptor;
1:48a9884: import org.apache.derby.iapi.sql.execute.RunTimeStatistics;
1:48a9884: import org.apache.derby.iapi.sql.execute.xplain.XPLAINVisitor;
1:5825332: import org.apache.derby.iapi.sql.execute.ResultSetStatistics;
1:48a9884: 
1:48a9884: /**
1:48a9884:  * This is the Visitor, which explains the information and stores the statistics in 
1:48a9884:  * the system catalogs. It traverses the result set statistics tree and extracts the
1:48a9884:  * information.  
1:48a9884:  *
1:48a9884:  */
1:48a9884: public class XPLAINSystemTableVisitor implements XPLAINVisitor {
1:48a9884:     
1:48a9884:     private boolean no_call_stmts = true;
1:48a9884:     
1:48a9884:     
1:48a9884:     // ---------------------------------------------------------
1:48a9884:     // member variables
1:48a9884:     // ---------------------------------------------------------
1:48a9884:     
1:48a9884:     // the needed system objects for writing to the dictionary
1:48a9884:     private LanguageConnectionContext lcc;
1:48a9884:     private DataDictionary dd;
1:48a9884:     
1:48a9884:     // the stmt activation object
1:48a9884:     private Activation activation;
1:48a9884: 
1:48a9884:     // a flag which is used to reflect if the statistics timings is on
1:48a9884:     private boolean considerTimingInformation = false;
1:48a9884:     
1:48a9884:     // the different tuple descriptors describing the query characteristics
1:48a9884:     // regarding the stmt
1:48a9884:     private XPLAINStatementDescriptor stmt;
1:48a9884:     private XPLAINStatementTimingsDescriptor stmtTimings = null;
1:48a9884:     private UUID stmtUUID; // the UUID to save for the resultsets
1:48a9884:     
1:48a9884:     // now the lists of descriptors regarding the resultsets
1:9d5bd0e:     private List<XPLAINResultSetDescriptor> rsets; // for the resultset descriptors
1:9d5bd0e:     private List<Object> rsetsTimings; // for the resultset timings descriptors
1:9d5bd0e:     private List<XPLAINSortPropsDescriptor> sortrsets; // for the sort props descriptors
1:9d5bd0e:     private List<XPLAINScanPropsDescriptor> scanrsets; // fot the scan props descriptors
1:48a9884:     
1:48a9884:     // the number of children of the current explained node
1:48a9884:     private int noChildren;
1:48a9884:     
1:48a9884:     // this stack keeps track of the result set UUIDs, which get popped by the
1:48a9884:     // children of the current explained node
1:9d5bd0e:     private Stack<UUID> UUIDStack;
1:48a9884:     
1:48a9884:     // ---------------------------------------------------------
1:48a9884:     // Constructor
1:48a9884:     // ---------------------------------------------------------
1:48a9884:     
1:48a9884:     public XPLAINSystemTableVisitor(){
1:48a9884:         // System.out.println("System Table Visitor created...");
1:48a9884:         // initialize lists
1:9d5bd0e:         rsets        = new ArrayList<XPLAINResultSetDescriptor>();
1:9d5bd0e:         rsetsTimings = new ArrayList<Object>();
1:9d5bd0e:         sortrsets    = new ArrayList<XPLAINSortPropsDescriptor>();
1:9d5bd0e:         scanrsets    = new ArrayList<XPLAINScanPropsDescriptor>();
1:48a9884:         
1:48a9884:         // init UUIDStack
1:9d5bd0e:         UUIDStack    = new Stack<UUID>();
1:48a9884:         
1:48a9884:     }
1:48a9884: 
1:48a9884:     
1:48a9884:     /** helper method, which pushes the UUID,
1:48a9884:      *  "number of Children" times onto the UUIDStack.
1:48a9884:      * @param uuid the UUID to push
1:48a9884:      */
1:48a9884:     private void pushUUIDnoChildren(UUID uuid){
1:48a9884:         for (int i=0;i<noChildren;i++){
1:48a9884:             UUIDStack.push(uuid);
1:48a9884:         }
1:48a9884:     }
1:48a9884:     
1:48a9884:     // ---------------------------------------------------------
1:48a9884:     // XPLAINVisitor Implementation
1:48a9884:     // ---------------------------------------------------------
1:48a9884:     
1:48a9884:     /**
1:48a9884:      * this method only stores the current number of children of the current explained node.
1:48a9884:      * The child nodes then can re-use this information.
1:48a9884:      */
1:48a9884:     public void setNumberOfChildren(int noChildren) {
1:48a9884:         this.noChildren = noChildren;
1:48a9884:     }
1:48a9884:     
1:48a9884:     /** 
1:48a9884:       * Visit this node, calling back to it to get details.
1:48a9884:       *
1:48a9884:       * This method visits the RS Statisitcs node, calling back to the
1:48a9884:       * node to get detailed descriptor information about it.
1:48a9884:       */
1:48a9884:     public void visit(ResultSetStatistics statistics)
1:48a9884:     {
1:48a9884:         UUID timingID = null;
1:48a9884:         
1:48a9884:         if(considerTimingInformation){
1:48a9884:             timingID = dd.getUUIDFactory().createUUID();
1:9d5bd0e:             rsetsTimings.add(
1:48a9884:                     statistics.getResultSetTimingsDescriptor(timingID));
1:48a9884:         }
1:48a9884:         
1:48a9884:         UUID sortID = dd.getUUIDFactory().createUUID();
1:9d5bd0e:         XPLAINSortPropsDescriptor sortRSDescriptor = (XPLAINSortPropsDescriptor) statistics.getSortPropsDescriptor(sortID);
1:48a9884:         if (sortRSDescriptor != null)
1:48a9884:             sortrsets.add(sortRSDescriptor);
1:48a9884:         else
1:48a9884:             sortID = null;
1:48a9884:         
1:48a9884:         UUID scanID = dd.getUUIDFactory().createUUID();
1:9d5bd0e:         XPLAINScanPropsDescriptor scanRSDescriptor = (XPLAINScanPropsDescriptor)statistics.getScanPropsDescriptor(scanID);
1:48a9884:         if (scanRSDescriptor != null)
1:48a9884:             scanrsets.add(scanRSDescriptor);
1:48a9884:         else
1:48a9884:             scanID = null;
1:48a9884: 
1:48a9884:         UUID rsID = dd.getUUIDFactory().createUUID();
1:9d5bd0e:         rsets.add( (XPLAINResultSetDescriptor) statistics.getResultSetDescriptor(rsID,
1:9d5bd0e:              UUIDStack.empty()?  (UUID)null: UUIDStack.pop(),
1:48a9884:            scanID, sortID, stmtUUID, timingID));
1:48a9884:         
1:48a9884:         pushUUIDnoChildren(rsID);
1:48a9884:     }
1:48a9884:     
1:48a9884:     /**
1:48a9884:      * This method resets the visitor. Gets called right before explanation
1:48a9884:      * to make sure all needed objects exist and are up to date and the lists are cleared
1:48a9884:      */
1:48a9884:     public void reset() {
1:48a9884:         lcc = activation.getLanguageConnectionContext();
1:48a9884:         dd  = lcc.getDataDictionary();
1:48a9884:     }
1:48a9884:     
1:48a9884:     /** the interface method, which gets called by the Top-ResultSet, which starts
1:48a9884:      *  the tree traversal. 
1:48a9884:      */
1:48a9884:     public void doXPLAIN(RunTimeStatistics rss, Activation activation)
1:48a9884:         throws StandardException
1:48a9884:     {
1:48a9884:          // save this activation
1:48a9884:          this.activation = activation;
1:48a9884:          
1:48a9884:          // reset this visitor
1:48a9884:          reset();
1:48a9884:          
1:48a9884:          // get the timings settings
1:48a9884:          considerTimingInformation = lcc.getStatisticsTiming();
1:48a9884:          
1:48a9884:          // placeholder for the stmt timings UUID 
1:48a9884:          UUID stmtTimingsUUID = null;
1:48a9884:          
1:48a9884:          //1. create new stmt timings descriptor 
1:48a9884:          if (considerTimingInformation){
1:48a9884:              stmtTimingsUUID = dd.getUUIDFactory().createUUID();
1:48a9884:              Timestamp endExeTS   = rss.getEndExecutionTimestamp();
1:48a9884:              Timestamp beginExeTS = rss.getBeginExecutionTimestamp();
1:48a9884:              long exeTime;
1:48a9884:              if (endExeTS!=null && beginExeTS!=null){
1:48a9884:                  exeTime = endExeTS.getTime() - beginExeTS.getTime();
1:48a9884:              } else {
1:48a9884:                  exeTime = 0;
1:48a9884:              }
1:48a9884:              
1:48a9884:              stmtTimings = new XPLAINStatementTimingsDescriptor(
1:48a9884:                  stmtTimingsUUID,                    // the Timing UUID
1:ce40a31:                  rss.getParseTimeInMillis(),         // the Parse Time
1:ce40a31:                  rss.getBindTimeInMillis(),          // the Bind Time
1:ce40a31:                  rss.getOptimizeTimeInMillis(),      // the Optimize Time
1:ce40a31:                  rss.getGenerateTimeInMillis(),      // the Generate Time
1:ce40a31:                  rss.getCompileTimeInMillis(),       // the Compile Time
1:ce40a31:                  exeTime,                            // the Execute Time, TODO resolve why getExecutionTime() returns 0
1:48a9884:                  rss.getBeginCompilationTimestamp(), // the Begin Compilation TS
1:48a9884:                  rss.getEndCompilationTimestamp(),   // the End   Compilation TS
1:48a9884:                  rss.getBeginExecutionTimestamp(),   // the Begin Execution   TS
1:48a9884:                  rss.getEndExecutionTimestamp()      // the End   Execution   TS
1:48a9884:              );
1:48a9884:          }
1:48a9884:          
1:48a9884:          // 2. create new Statement Descriptor 
1:48a9884: 
1:48a9884:          // create new UUID
1:48a9884:          stmtUUID = dd.getUUIDFactory().createUUID();
1:48a9884:          // extract stmt type
1:48a9884:          String type = XPLAINUtil.getStatementType(rss.getStatementText());
1:48a9884:          
1:48a9884:          // don`t explain CALL Statements, quick implementation
1:48a9884:          // TODO improve usability to switch between call stmt explanation on or off
1:48a9884:          if (type.equalsIgnoreCase("C") && no_call_stmts) return;
1:48a9884:          
1:48a9884:          // get transaction ID
1:48a9884:          String xaID = lcc.getTransactionExecute().getTransactionIdString();
1:48a9884:          // get session ID
1:48a9884:          String sessionID = Integer.toString(lcc.getInstanceNumber());
1:48a9884:          // get the JVM ID
1:48a9884:          String jvmID = Integer.toString(JVMInfo.JDK_ID); 
1:48a9884:          // get the OS ID 
1:48a9884:          String osID  = System.getProperty("os.name"); 
1:48a9884:          // the current system time
1:48a9884:          long current = System.currentTimeMillis();
1:48a9884:          // the xplain type
1:48a9884:          String XPLAINtype = lcc.getXplainOnlyMode() ?
1:48a9884:              XPLAINUtil.XPLAIN_ONLY : XPLAINUtil.XPLAIN_FULL;
1:48a9884:          // the xplain time
1:48a9884:          Timestamp time = new Timestamp(current);
1:48a9884:          // the thread id
1:48a9884:          String threadID = Thread.currentThread().toString();
1:48a9884:          
1:48a9884:          stmt = new XPLAINStatementDescriptor(
1:48a9884:             stmtUUID,               // unique statement UUID
1:48a9884:             rss.getStatementName(), // the statement name
1:48a9884:             type,                   // the statement type
1:48a9884:             rss.getStatementText(), // the statement text
1:48a9884:             jvmID,                  // the JVM ID
1:48a9884:             osID,                   // the OS ID
1:48a9884:             XPLAINtype,             // the EXPLAIN tpye
1:48a9884:             time,                   // the EXPLAIN Timestamp
1:48a9884:             threadID,               // the Thread ID
1:48a9884:             xaID,                   // the transaction ID
1:48a9884:             sessionID,              // the Session ID
1:48a9884:             lcc.getDbname(),        // the Database name
1:48a9884:             lcc.getDrdaID(),        // the DRDA ID
1:48a9884:             stmtTimingsUUID         // Timing ID, if available
1:48a9884:             );
1:48a9884:          
1:48a9884:         try {
1:48a9884:          // add it to system catalog
1:48a9884:          addStmtDescriptorsToSystemCatalog();                 
1:48a9884:          
1:48a9884:          // get TopRSS and start the traversal of the RSS-tree
1:48a9884:          rss.acceptFromTopResultSet(this);
1:48a9884:          
1:48a9884:          // add the filled lists to the dictionary
1:48a9884:          addArraysToSystemCatalogs();
1:48a9884:         }
1:48a9884:         catch (SQLException e)
1:48a9884:         {
1:48a9884:             throw StandardException.plainWrapException(e);
1:48a9884:         }
1:48a9884:          
1:48a9884:          // clean up to free kept resources
1:48a9884:          clean();
1:48a9884:     }
1:48a9884: 
1:48a9884:     // ---------------------------------------------------------
1:48a9884:     // helper methods
1:48a9884:     // ---------------------------------------------------------
1:48a9884:     
1:48a9884:     /**
1:48a9884:      * This method cleans up things after explanation. It frees kept 
1:48a9884:      * resources and still holded references.
1:48a9884:      */
1:48a9884:     private void clean(){
1:48a9884:         
1:48a9884:         
1:48a9884:         // forget about all the system objects
1:48a9884:         activation = null;
1:48a9884:         lcc = null;
1:48a9884:         dd = null;
1:48a9884:         
1:48a9884:         // forget about the stmt descriptors and the Stmt UUID
1:48a9884:         stmtUUID = null;
1:48a9884:         stmt = null;
1:48a9884:         stmtTimings = null;
1:48a9884:         
1:48a9884:         // reset the descriptor lists to keep memory low
1:48a9884:         rsets.clear();
1:48a9884:         rsetsTimings.clear();
1:48a9884:         sortrsets.clear();
1:48a9884:         scanrsets.clear();
1:48a9884:         
1:48a9884:         // clear stack, although it must be already empty...
1:48a9884:         UUIDStack.clear();
1:48a9884:     }
1:48a9884:     
1:48a9884:     /**
1:48a9884:       * Open a nested Connection with which to execute INSERT statements.
1:48a9884:       */
1:48a9884:     private Connection getDefaultConn()throws SQLException
1:48a9884:     {
1:48a9884:         ConnectionContext cc = (ConnectionContext)
1:48a9884:             lcc.getContextManager().getContext(ConnectionContext.CONTEXT_ID);
1:48a9884:         return cc.getNestedConnection(true);
1:48a9884:     }
1:48a9884:     /**
1:48a9884:      * This method writes only the stmt and its timing descriptor
1:48a9884:      * to the dataDictionary
1:48a9884:      *
1:48a9884:      */
1:48a9884:     private void addStmtDescriptorsToSystemCatalog()
1:48a9884:         throws StandardException, SQLException
1:48a9884:     {
1:48a9884:         boolean statsSave = lcc.getRunTimeStatisticsMode();
1:48a9884:         lcc.setRunTimeStatisticsMode(false);
1:48a9884:         Connection conn = getDefaultConn();
1:48a9884:         PreparedStatement ps = conn.prepareStatement(
1:48a9884:             (String)lcc.getXplainStatement("SYSXPLAIN_STATEMENTS"));
1:48a9884:         stmt.setStatementParameters(ps);
1:48a9884:         ps.executeUpdate();
1:48a9884:         ps.close();
1:48a9884:             
1:48a9884:         if(considerTimingInformation)
1:48a9884:         {
1:48a9884:             ps = conn.prepareStatement(
1:48a9884:                 (String)lcc.getXplainStatement("SYSXPLAIN_STATEMENT_TIMINGS"));
1:48a9884:             stmtTimings.setStatementParameters(ps);
1:48a9884:             ps.executeUpdate();
1:48a9884:             ps.close();
1:48a9884:         }
1:48a9884:         conn.close();
1:48a9884:         lcc.setRunTimeStatisticsMode(statsSave);
1:48a9884:     }
1:48a9884:     
1:48a9884:     /**
1:48a9884:      * This method writes the created descriptor arrays 
1:48a9884:      * to the cooresponding system catalogs.
1:48a9884:      */
1:48a9884:     private void addArraysToSystemCatalogs()
1:48a9884:         throws StandardException, SQLException
1:48a9884:     {
1:48a9884:         boolean statsSave = lcc.getRunTimeStatisticsMode();
1:48a9884:         lcc.setRunTimeStatisticsMode(false);
1:48a9884:         Connection conn = getDefaultConn();
1:48a9884: 
1:48a9884:         PreparedStatement ps = conn.prepareStatement(
1:48a9884:             (String)lcc.getXplainStatement("SYSXPLAIN_RESULTSETS"));
1:9d5bd0e:         Iterator<XPLAINResultSetDescriptor> rsetsiter = rsets.iterator();
1:9d5bd0e:         while (rsetsiter.hasNext())
1:48a9884:         {
1:48a9884:             XPLAINResultSetDescriptor rset =
1:9d5bd0e:                 rsetsiter.next();
1:48a9884:             rset.setStatementParameters(ps);
1:48a9884:             ps.executeUpdate();
1:48a9884:         }
1:48a9884:         ps.close();
1:48a9884: 
1:48a9884:         // add the resultset timings descriptors, if timing is on
1:48a9884:         if(considerTimingInformation)
1:48a9884:         {
1:48a9884:             ps = conn.prepareStatement(
1:48a9884:                 (String)lcc.getXplainStatement("SYSXPLAIN_RESULTSET_TIMINGS"));
1:9d5bd0e:             Iterator<Object> timingsiter = rsetsTimings.iterator();
1:9d5bd0e:             while (timingsiter.hasNext())
1:48a9884:             {
1:48a9884:                 XPLAINResultSetTimingsDescriptor rsetT =
1:9d5bd0e:                     (XPLAINResultSetTimingsDescriptor)timingsiter.next();
1:48a9884:                 rsetT.setStatementParameters(ps);
1:48a9884:                 ps.executeUpdate();
1:48a9884:             }
1:48a9884:             ps.close();
1:48a9884:         }
1:48a9884:         ps = conn.prepareStatement(
1:48a9884:             (String)lcc.getXplainStatement("SYSXPLAIN_SCAN_PROPS"));
1:9d5bd0e:         Iterator<XPLAINScanPropsDescriptor> scaniter = scanrsets.iterator();
1:9d5bd0e:         while (scaniter.hasNext())
1:48a9884:         {
1:48a9884:             XPLAINScanPropsDescriptor scanProps =
1:9d5bd0e:                 scaniter.next();
1:48a9884:             scanProps.setStatementParameters(ps);
1:48a9884:             ps.executeUpdate();
1:48a9884:         }
1:48a9884:         ps.close();
1:48a9884: 
1:48a9884:         ps = conn.prepareStatement(
1:48a9884:             (String)lcc.getXplainStatement("SYSXPLAIN_SORT_PROPS"));
1:9d5bd0e:         Iterator<XPLAINSortPropsDescriptor> sortiter = sortrsets.iterator();
1:9d5bd0e:         while (sortiter.hasNext())
1:48a9884:         {
1:48a9884:             XPLAINSortPropsDescriptor sortProps =
1:9d5bd0e:                 sortiter.next();
1:48a9884:             sortProps.setStatementParameters(ps);
1:48a9884:             ps.executeUpdate();
1:48a9884:         }
1:48a9884:         ps.close();
1:48a9884: 
1:48a9884:         conn.close();
1:48a9884:         lcc.setRunTimeStatisticsMode(statsSave);
1:48a9884:     }
1:48a9884: 
1:48a9884: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:ce40a31
/////////////////////////////////////////////////////////////////////////
1:                  rss.getParseTimeInMillis(),         // the Parse Time
1:                  rss.getBindTimeInMillis(),          // the Bind Time
1:                  rss.getOptimizeTimeInMillis(),      // the Optimize Time
1:                  rss.getGenerateTimeInMillis(),      // the Generate Time
1:                  rss.getCompileTimeInMillis(),       // the Compile Time
1:                  exeTime,                            // the Execute Time, TODO resolve why getExecutionTime() returns 0
commit:9d5bd0e
/////////////////////////////////////////////////////////////////////////
1:     private List<XPLAINResultSetDescriptor> rsets; // for the resultset descriptors
1:     private List<Object> rsetsTimings; // for the resultset timings descriptors
1:     private List<XPLAINSortPropsDescriptor> sortrsets; // for the sort props descriptors
1:     private List<XPLAINScanPropsDescriptor> scanrsets; // fot the scan props descriptors
1:     private Stack<UUID> UUIDStack;
/////////////////////////////////////////////////////////////////////////
1:         rsets        = new ArrayList<XPLAINResultSetDescriptor>();
1:         rsetsTimings = new ArrayList<Object>();
1:         sortrsets    = new ArrayList<XPLAINSortPropsDescriptor>();
1:         scanrsets    = new ArrayList<XPLAINScanPropsDescriptor>();
1:         UUIDStack    = new Stack<UUID>();
/////////////////////////////////////////////////////////////////////////
1:             rsetsTimings.add(
1:         XPLAINSortPropsDescriptor sortRSDescriptor = (XPLAINSortPropsDescriptor) statistics.getSortPropsDescriptor(sortID);
1:         XPLAINScanPropsDescriptor scanRSDescriptor = (XPLAINScanPropsDescriptor)statistics.getScanPropsDescriptor(scanID);
1:         rsets.add( (XPLAINResultSetDescriptor) statistics.getResultSetDescriptor(rsID,
1:              UUIDStack.empty()?  (UUID)null: UUIDStack.pop(),
/////////////////////////////////////////////////////////////////////////
1:         Iterator<XPLAINResultSetDescriptor> rsetsiter = rsets.iterator();
1:         while (rsetsiter.hasNext())
1:                 rsetsiter.next();
/////////////////////////////////////////////////////////////////////////
1:             Iterator<Object> timingsiter = rsetsTimings.iterator();
1:             while (timingsiter.hasNext())
1:                     (XPLAINResultSetTimingsDescriptor)timingsiter.next();
/////////////////////////////////////////////////////////////////////////
1:         Iterator<XPLAINScanPropsDescriptor> scaniter = scanrsets.iterator();
1:         while (scaniter.hasNext())
1:                 scaniter.next();
/////////////////////////////////////////////////////////////////////////
1:         Iterator<XPLAINSortPropsDescriptor> sortiter = sortrsets.iterator();
1:         while (sortiter.hasNext())
1:                 sortiter.next();
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:5825332
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.execute.ResultSetStatistics;
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:f1c8383
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:782dbe1
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derby.impl.sql.execute.xplain.XPLAINSystemTableVisitor
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:48a9884
/////////////////////////////////////////////////////////////////////////
1: package org.apache.derby.impl.sql.execute.xplain;
1: 
1: import java.sql.Connection;
1: import java.sql.PreparedStatement;
1: import java.sql.SQLException;
1: import java.sql.Timestamp;
1: import java.util.ArrayList;
1: import java.util.Iterator;
1: import java.util.List;
0: import java.util.Properties;
1: import java.util.Stack;
1: 
1: import org.apache.derby.catalog.UUID;
0: import org.apache.derby.jdbc.InternalDriver;
0: import org.apache.derby.impl.jdbc.Util;
1: import org.apache.derby.iapi.jdbc.ConnectionContext;
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.services.info.JVMInfo;
0: import org.apache.derby.iapi.services.io.FormatableProperties;
1: import org.apache.derby.iapi.sql.Activation;
1: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: import org.apache.derby.iapi.sql.dictionary.DataDescriptorGenerator;
1: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.TupleDescriptor;
1: import org.apache.derby.impl.sql.catalog.XPLAINResultSetDescriptor;
1: import org.apache.derby.impl.sql.catalog.XPLAINResultSetTimingsDescriptor;
1: import org.apache.derby.impl.sql.catalog.XPLAINScanPropsDescriptor;
1: import org.apache.derby.impl.sql.catalog.XPLAINSortPropsDescriptor;
1: import org.apache.derby.impl.sql.catalog.XPLAINStatementDescriptor;
1: import org.apache.derby.impl.sql.catalog.XPLAINStatementTimingsDescriptor;
1: import org.apache.derby.iapi.sql.execute.RunTimeStatistics;
1: import org.apache.derby.iapi.sql.execute.xplain.XPLAINVisitor;
0: import org.apache.derby.iapi.store.access.TransactionController;
0: import org.apache.derby.impl.sql.compile.IntersectOrExceptNode;
0: import org.apache.derby.impl.sql.execute.rts.RealAnyResultSetStatistics;
0: import org.apache.derby.impl.sql.execute.rts.RealDeleteCascadeResultSetStatistics;
0: import org.apache.derby.impl.sql.execute.rts.RealDeleteResultSetStatistics;
0: import org.apache.derby.impl.sql.execute.rts.RealDeleteVTIResultSetStatistics;
0: import org.apache.derby.impl.sql.execute.rts.RealDistinctScalarAggregateStatistics;
0: import org.apache.derby.impl.sql.execute.rts.RealDistinctScanStatistics;
0: import org.apache.derby.impl.sql.execute.rts.RealGroupedAggregateStatistics;
0: import org.apache.derby.impl.sql.execute.rts.RealHashJoinStatistics;
0: import org.apache.derby.impl.sql.execute.rts.RealHashLeftOuterJoinStatistics;
0: import org.apache.derby.impl.sql.execute.rts.RealHashScanStatistics;
0: import org.apache.derby.impl.sql.execute.rts.RealHashTableStatistics;
0: import org.apache.derby.impl.sql.execute.rts.RealIndexRowToBaseRowStatistics;
0: import org.apache.derby.impl.sql.execute.rts.RealInsertResultSetStatistics;
0: import org.apache.derby.impl.sql.execute.rts.RealInsertVTIResultSetStatistics;
0: import org.apache.derby.impl.sql.execute.rts.RealLastIndexKeyScanStatistics;
0: import org.apache.derby.impl.sql.execute.rts.RealMaterializedResultSetStatistics;
0: import org.apache.derby.impl.sql.execute.rts.RealNestedLoopJoinStatistics;
0: import org.apache.derby.impl.sql.execute.rts.RealNestedLoopLeftOuterJoinStatistics;
0: import org.apache.derby.impl.sql.execute.rts.RealNormalizeResultSetStatistics;
0: import org.apache.derby.impl.sql.execute.rts.RealOnceResultSetStatistics;
0: import org.apache.derby.impl.sql.execute.rts.RealProjectRestrictStatistics;
0: import org.apache.derby.impl.sql.execute.rts.RealRowResultSetStatistics;
0: import org.apache.derby.impl.sql.execute.rts.RealScalarAggregateStatistics;
0: import org.apache.derby.impl.sql.execute.rts.RealScrollInsensitiveResultSetStatistics;
0: import org.apache.derby.impl.sql.execute.rts.RealSetOpResultSetStatistics;
0: import org.apache.derby.impl.sql.execute.rts.RealSortStatistics;
0: import org.apache.derby.impl.sql.execute.rts.RealTableScanStatistics;
0: import org.apache.derby.impl.sql.execute.rts.RealUnionResultSetStatistics;
0: import org.apache.derby.impl.sql.execute.rts.RealUpdateResultSetStatistics;
0: import org.apache.derby.impl.sql.execute.rts.RealVTIStatistics;
0: import org.apache.derby.impl.sql.execute.rts.ResultSetStatistics;
1: 
1: /**
1:  * This is the Visitor, which explains the information and stores the statistics in 
1:  * the system catalogs. It traverses the result set statistics tree and extracts the
1:  * information.  
1:  *
1:  */
1: public class XPLAINSystemTableVisitor implements XPLAINVisitor {
1:     
1:     private boolean no_call_stmts = true;
1:     
1:     
1:     // ---------------------------------------------------------
1:     // member variables
1:     // ---------------------------------------------------------
1:     
1:     // the needed system objects for writing to the dictionary
1:     private LanguageConnectionContext lcc;
1:     private DataDictionary dd;
0:     private TransactionController tc;
0:     private DataDescriptorGenerator ddg;
1:     
1:     // the stmt activation object
1:     private Activation activation;
1: 
1:     // a flag which is used to reflect if the statistics timings is on
1:     private boolean considerTimingInformation = false;
1:     
1:     // the different tuple descriptors describing the query characteristics
1:     // regarding the stmt
1:     private XPLAINStatementDescriptor stmt;
1:     private XPLAINStatementTimingsDescriptor stmtTimings = null;
1:     private UUID stmtUUID; // the UUID to save for the resultsets
1:     
1:     // now the lists of descriptors regarding the resultsets
0:     private List rsets; // for the resultset descriptors
0:     private List rsetsTimings; // for the resultset timings descriptors
0:     private List sortrsets; // for the sort props descriptors
0:     private List scanrsets; // fot the scan props descriptors
1:     
1:     // the number of children of the current explained node
1:     private int noChildren;
1:     
1:     // this stack keeps track of the result set UUIDs, which get popped by the
1:     // children of the current explained node
0:     private Stack UUIDStack;
1:     
1:     // ---------------------------------------------------------
1:     // Constructor
1:     // ---------------------------------------------------------
1:     
1:     public XPLAINSystemTableVisitor(){
1:         // System.out.println("System Table Visitor created...");
1:         // initialize lists
0:         rsets        = new ArrayList();
0:         rsetsTimings = new ArrayList();
0:         sortrsets    = new ArrayList();
0:         scanrsets    = new ArrayList();
1:         
1:         // init UUIDStack
0:         UUIDStack    = new Stack();
1:         
1:     }
1: 
1:     
1:     /** helper method, which pushes the UUID,
1:      *  "number of Children" times onto the UUIDStack.
1:      * @param uuid the UUID to push
1:      */
1:     private void pushUUIDnoChildren(UUID uuid){
1:         for (int i=0;i<noChildren;i++){
1:             UUIDStack.push(uuid);
1:         }
1:     }
1:     
1:     // ---------------------------------------------------------
1:     // XPLAINVisitor Implementation
1:     // ---------------------------------------------------------
1:     
1:     /**
1:      * this method only stores the current number of children of the current explained node.
1:      * The child nodes then can re-use this information.
1:      */
1:     public void setNumberOfChildren(int noChildren) {
1:         this.noChildren = noChildren;
1:     }
1:     
1:     /** 
1:       * Visit this node, calling back to it to get details.
1:       *
1:       * This method visits the RS Statisitcs node, calling back to the
1:       * node to get detailed descriptor information about it.
1:       */
1:     public void visit(ResultSetStatistics statistics)
1:     {
1:         UUID timingID = null;
1:         
1:         if(considerTimingInformation){
1:             timingID = dd.getUUIDFactory().createUUID();
0:             rsetsTimings.add( 
1:                     statistics.getResultSetTimingsDescriptor(timingID));
1:         }
1:         
1:         UUID sortID = dd.getUUIDFactory().createUUID();
0:         Object sortRSDescriptor = statistics.getSortPropsDescriptor(sortID);
1:         if (sortRSDescriptor != null)
1:             sortrsets.add(sortRSDescriptor);
1:         else
1:             sortID = null;
1:         
1:         UUID scanID = dd.getUUIDFactory().createUUID();
0:         Object scanRSDescriptor = statistics.getScanPropsDescriptor(scanID);
1:         if (scanRSDescriptor != null)
1:             scanrsets.add(scanRSDescriptor);
1:         else
1:             scanID = null;
1: 
1:         UUID rsID = dd.getUUIDFactory().createUUID();
0:         rsets.add(statistics.getResultSetDescriptor(rsID,
0:            UUIDStack.empty()?  null: (UUID)UUIDStack.pop(),
1:            scanID, sortID, stmtUUID, timingID));
1:         
1:         pushUUIDnoChildren(rsID);
1:     }
1:     
1:     /**
1:      * This method resets the visitor. Gets called right before explanation
1:      * to make sure all needed objects exist and are up to date and the lists are cleared
1:      */
1:     public void reset() {
1:         lcc = activation.getLanguageConnectionContext();
1:         dd  = lcc.getDataDictionary();
0:         tc  = lcc.getTransactionExecute();
0:         ddg = dd.getDataDescriptorGenerator(); 
1:     }
1:     
1:     /** the interface method, which gets called by the Top-ResultSet, which starts
1:      *  the tree traversal. 
1:      */
1:     public void doXPLAIN(RunTimeStatistics rss, Activation activation)
1:         throws StandardException
1:     {
1:          // save this activation
1:          this.activation = activation;
1:          
1:          // reset this visitor
1:          reset();
1:          
1:          // get the timings settings
1:          considerTimingInformation = lcc.getStatisticsTiming();
1:          
1:          // placeholder for the stmt timings UUID 
1:          UUID stmtTimingsUUID = null;
1:          
1:          //1. create new stmt timings descriptor 
1:          if (considerTimingInformation){
1:              stmtTimingsUUID = dd.getUUIDFactory().createUUID();
1:              Timestamp endExeTS   = rss.getEndExecutionTimestamp();
1:              Timestamp beginExeTS = rss.getBeginExecutionTimestamp();
1:              long exeTime;
1:              if (endExeTS!=null && beginExeTS!=null){
1:                  exeTime = endExeTS.getTime() - beginExeTS.getTime();
1:              } else {
1:                  exeTime = 0;
1:              }
1:              
1:              stmtTimings = new XPLAINStatementTimingsDescriptor(
1:                  stmtTimingsUUID,                    // the Timing UUID
0:                  new Long(rss.getParseTimeInMillis()),         // the Parse Time
0:                  new Long(rss.getBindTimeInMillis()),          // the Bind Time
0:                  new Long(rss.getOptimizeTimeInMillis()),      // the Optimize Time
0:                  new Long(rss.getGenerateTimeInMillis()),      // the Generate Time
0:                  new Long(rss.getCompileTimeInMillis()),       // the Compile Time
0:                  new Long(exeTime),                            // the Execute Time, TODO resolve why getExecutionTime() returns 0
1:                  rss.getBeginCompilationTimestamp(), // the Begin Compilation TS
1:                  rss.getEndCompilationTimestamp(),   // the End   Compilation TS
1:                  rss.getBeginExecutionTimestamp(),   // the Begin Execution   TS
1:                  rss.getEndExecutionTimestamp()      // the End   Execution   TS
1:              );
1:          }
1:          
1:          // 2. create new Statement Descriptor 
1: 
1:          // create new UUID
1:          stmtUUID = dd.getUUIDFactory().createUUID();
1:          // extract stmt type
1:          String type = XPLAINUtil.getStatementType(rss.getStatementText());
1:          
1:          // don`t explain CALL Statements, quick implementation
1:          // TODO improve usability to switch between call stmt explanation on or off
1:          if (type.equalsIgnoreCase("C") && no_call_stmts) return;
1:          
1:          // get transaction ID
1:          String xaID = lcc.getTransactionExecute().getTransactionIdString();
1:          // get session ID
1:          String sessionID = Integer.toString(lcc.getInstanceNumber());
1:          // get the JVM ID
1:          String jvmID = Integer.toString(JVMInfo.JDK_ID); 
1:          // get the OS ID 
1:          String osID  = System.getProperty("os.name"); 
1:          // the current system time
1:          long current = System.currentTimeMillis();
1:          // the xplain type
1:          String XPLAINtype = lcc.getXplainOnlyMode() ?
1:              XPLAINUtil.XPLAIN_ONLY : XPLAINUtil.XPLAIN_FULL;
1:          // the xplain time
1:          Timestamp time = new Timestamp(current);
1:          // the thread id
1:          String threadID = Thread.currentThread().toString();
1:          
1:          stmt = new XPLAINStatementDescriptor(
1:             stmtUUID,               // unique statement UUID
1:             rss.getStatementName(), // the statement name
1:             type,                   // the statement type
1:             rss.getStatementText(), // the statement text
1:             jvmID,                  // the JVM ID
1:             osID,                   // the OS ID
1:             XPLAINtype,             // the EXPLAIN tpye
1:             time,                   // the EXPLAIN Timestamp
1:             threadID,               // the Thread ID
1:             xaID,                   // the transaction ID
1:             sessionID,              // the Session ID
1:             lcc.getDbname(),        // the Database name
1:             lcc.getDrdaID(),        // the DRDA ID
1:             stmtTimingsUUID         // Timing ID, if available
1:             );
1:          
1:         try {
1:          // add it to system catalog
1:          addStmtDescriptorsToSystemCatalog();                 
1:          
1:          // get TopRSS and start the traversal of the RSS-tree
1:          rss.acceptFromTopResultSet(this);
1:          
1:          // add the filled lists to the dictionary
1:          addArraysToSystemCatalogs();
1:         }
1:         catch (SQLException e)
1:         {
0:             e.printStackTrace();
1:             throw StandardException.plainWrapException(e);
1:         }
1:          
1:          // clean up to free kept resources
1:          clean();
1:     }
1: 
1:     // ---------------------------------------------------------
1:     // helper methods
1:     // ---------------------------------------------------------
1:     
1:     /**
1:      * This method cleans up things after explanation. It frees kept 
1:      * resources and still holded references.
1:      */
1:     private void clean(){
1:         
1:         
1:         // forget about all the system objects
1:         activation = null;
1:         lcc = null;
1:         dd = null;
0:         tc = null;
1:         
1:         // forget about the stmt descriptors and the Stmt UUID
1:         stmtUUID = null;
1:         stmt = null;
1:         stmtTimings = null;
1:         
1:         // reset the descriptor lists to keep memory low
1:         rsets.clear();
1:         rsetsTimings.clear();
1:         sortrsets.clear();
1:         scanrsets.clear();
1:         
1:         // clear stack, although it must be already empty...
1:         UUIDStack.clear();
1:     }
1:     
1:     /**
1:       * Open a nested Connection with which to execute INSERT statements.
1:       */
1:     private Connection getDefaultConn()throws SQLException
1:     {
1:         ConnectionContext cc = (ConnectionContext)
1:             lcc.getContextManager().getContext(ConnectionContext.CONTEXT_ID);
1:         return cc.getNestedConnection(true);
1:     }
1:     /**
1:      * This method writes only the stmt and its timing descriptor
1:      * to the dataDictionary
1:      *
1:      */
1:     private void addStmtDescriptorsToSystemCatalog()
1:         throws StandardException, SQLException
1:     {
1:         boolean statsSave = lcc.getRunTimeStatisticsMode();
1:         lcc.setRunTimeStatisticsMode(false);
1:         Connection conn = getDefaultConn();
1:         PreparedStatement ps = conn.prepareStatement(
1:             (String)lcc.getXplainStatement("SYSXPLAIN_STATEMENTS"));
1:         stmt.setStatementParameters(ps);
1:         ps.executeUpdate();
1:         ps.close();
1:             
1:         if(considerTimingInformation)
1:         {
1:             ps = conn.prepareStatement(
1:                 (String)lcc.getXplainStatement("SYSXPLAIN_STATEMENT_TIMINGS"));
1:             stmtTimings.setStatementParameters(ps);
1:             ps.executeUpdate();
1:             ps.close();
1:         }
1:         conn.close();
1:         lcc.setRunTimeStatisticsMode(statsSave);
1:     }
1:     
1:     /**
1:      * This method writes the created descriptor arrays 
1:      * to the cooresponding system catalogs.
1:      */
1:     private void addArraysToSystemCatalogs()
1:         throws StandardException, SQLException
1:     {
0:         Iterator iter;
1:         boolean statsSave = lcc.getRunTimeStatisticsMode();
1:         lcc.setRunTimeStatisticsMode(false);
1:         Connection conn = getDefaultConn();
1: 
1:         PreparedStatement ps = conn.prepareStatement(
1:             (String)lcc.getXplainStatement("SYSXPLAIN_RESULTSETS"));
0:         iter = rsets.iterator();
0:         while (iter.hasNext())
1:         {
1:             XPLAINResultSetDescriptor rset =
0:                 (XPLAINResultSetDescriptor)iter.next();
1:             rset.setStatementParameters(ps);
1:             ps.executeUpdate();
1:         }
1:         ps.close();
1: 
1:         // add the resultset timings descriptors, if timing is on
1:         if(considerTimingInformation)
1:         {
1:             ps = conn.prepareStatement(
1:                 (String)lcc.getXplainStatement("SYSXPLAIN_RESULTSET_TIMINGS"));
0:             iter = rsetsTimings.iterator();
0:             while (iter.hasNext())
1:             {
1:                 XPLAINResultSetTimingsDescriptor rsetT =
0:                     (XPLAINResultSetTimingsDescriptor)iter.next();
1:                 rsetT.setStatementParameters(ps);
1:                 ps.executeUpdate();
1:             }
1:             ps.close();
1:         }
1:         ps = conn.prepareStatement(
1:             (String)lcc.getXplainStatement("SYSXPLAIN_SCAN_PROPS"));
0:         iter = scanrsets.iterator();
0:         while (iter.hasNext())
1:         {
1:             XPLAINScanPropsDescriptor scanProps =
0:                 (XPLAINScanPropsDescriptor)iter.next();
1:             scanProps.setStatementParameters(ps);
1:             ps.executeUpdate();
1:         }
1:         ps.close();
1: 
1:         ps = conn.prepareStatement(
1:             (String)lcc.getXplainStatement("SYSXPLAIN_SORT_PROPS"));
0:         iter = sortrsets.iterator();
0:         while (iter.hasNext())
1:         {
1:             XPLAINSortPropsDescriptor sortProps =
0:                 (XPLAINSortPropsDescriptor)iter.next();
1:             sortProps.setStatementParameters(ps);
1:             ps.executeUpdate();
1:         }
1:         ps.close();
1: 
1:         conn.close();
1:         lcc.setRunTimeStatisticsMode(statsSave);
1:     }
1: 
1: }
============================================================================