1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.compile.TypeCompilerFactoryImpl
1:345de35: 
1:2d37fd6:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2d37fd6:    contributor license agreements.  See the NOTICE file distributed with
1:2d37fd6:    this work for additional information regarding copyright ownership.
1:2d37fd6:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2d37fd6:    (the "License"); you may not use this file except in compliance with
1:2d37fd6:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
5:eac0369: 
2:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.sql.compile;
1:eac0369: 
1:eac0369: import java.sql.Types;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:3bb140c: import org.apache.derby.iapi.sql.compile.TypeCompiler;
1:3bb140c: import org.apache.derby.iapi.sql.compile.TypeCompilerFactory;
1:3bb140c: import org.apache.derby.iapi.types.TypeId;
1:eac0369: 
1:eac0369: public class TypeCompilerFactoryImpl implements TypeCompilerFactory
8:eac0369: {
1:eac0369:         private static final String PACKAGE_NAME =
1:eac0369:                         "org.apache.derby.impl.sql.compile.";
1:eac0369: 
1:eac0369:         // These are all the TypeCompilers that are stateless, so we can
1:eac0369:         // use a single instance of each. Initialize all to null, and fault
1:eac0369:         // them in.
1:eac0369:         static TypeCompiler bitTypeCompiler;
1:eac0369:         static TypeCompiler booleanTypeCompiler;
1:eac0369:         static TypeCompiler charTypeCompiler;
1:eac0369:         static TypeCompiler decimalTypeCompiler ;
1:eac0369:         static TypeCompiler doubleTypeCompiler ;
1:eac0369:         static TypeCompiler intTypeCompiler ;
1:eac0369:         static TypeCompiler longintTypeCompiler ;
1:eac0369:         static TypeCompiler longvarbitTypeCompiler ;
1:eac0369:         static TypeCompiler longvarcharTypeCompiler ;
1:eac0369:         static TypeCompiler realTypeCompiler ;
1:eac0369:         static TypeCompiler smallintTypeCompiler ;
1:eac0369:         static TypeCompiler tinyintTypeCompiler ;
1:eac0369:         static TypeCompiler dateTypeCompiler ;
1:eac0369:         static TypeCompiler timeTypeCompiler ;
1:eac0369:         static TypeCompiler timestampTypeCompiler ;
1:eac0369:         static TypeCompiler varbitTypeCompiler ;
1:eac0369:         static TypeCompiler varcharTypeCompiler ;
1:eac0369:         static TypeCompiler refTypeCompiler ;
1:eac0369:         static TypeCompiler blobTypeCompiler ;
1:eac0369:         static TypeCompiler clobTypeCompiler ;
1:099e28f:         static TypeCompiler xmlTypeCompiler ;
1:eac0369: 
2:eac0369:         /**
1:eac0369:          * Get a TypeCompiler corresponding to the given TypeId
1:eac0369:          *
1:eac0369:          * @param typeId        The TypeId to get a TypeCompiler for
1:eac0369:          *
1:eac0369:          * @return      The corresponding TypeCompiler
1:eac0369:          */
1:eac0369: 
1:eac0369:         public TypeCompiler getTypeCompiler(TypeId typeId)
1:92268ac:         {
1:eac0369:                 return staticGetTypeCompiler(typeId);
9:eac0369:         }
1:eac0369: 
1:eac0369:         static TypeCompiler staticGetTypeCompiler(TypeId typeId)
1:eac0369:         {
1:eac0369:                 String sqlTypeName;
1:92268ac: 
1:eac0369:                 switch (typeId.getJDBCTypeId())
1:eac0369:                 {
1:eac0369:                   case Types.BINARY:
1:eac0369:                         return bitTypeCompiler =
1:eac0369:                                         getAnInstance(PACKAGE_NAME + "BitTypeCompiler",
1:eac0369:                                                                         bitTypeCompiler,
5:eac0369:                                                                         typeId);
1:eac0369: 
1:eac0369:                   case Types.BIT:
1:1a4ea31:                   case Types.BOOLEAN:
1:eac0369:                         return booleanTypeCompiler =
1:eac0369:                                         getAnInstance(PACKAGE_NAME + "BooleanTypeCompiler",
1:eac0369:                                                                 booleanTypeCompiler,
1:eac0369:                                                                 typeId);
1:eac0369: 
1:eac0369:                   case Types.CHAR:
1:eac0369:                           sqlTypeName = typeId.getSQLTypeName();
1:eac0369:                           return charTypeCompiler =
1:92268ac:                               getAnInstance(PACKAGE_NAME + "CharTypeCompiler",
1:eac0369:                                                       charTypeCompiler,
1:92268ac:                                                       typeId);
1:eac0369: 
1:eac0369:                   case Types.NUMERIC:
1:eac0369:                   case Types.DECIMAL:
1:eac0369:                         return decimalTypeCompiler =
1:eac0369:                                 getAnInstance(PACKAGE_NAME + "NumericTypeCompiler",
1:eac0369:                                                                 decimalTypeCompiler,
1:eac0369:                                                                 typeId);
1:eac0369: 
1:eac0369:                   case Types.DOUBLE:
1:eac0369:                         return doubleTypeCompiler =
1:eac0369:                                 getAnInstance(PACKAGE_NAME + "NumericTypeCompiler",
1:eac0369:                                                                 doubleTypeCompiler,
1:eac0369:                                                                 typeId);
1:eac0369: 
1:eac0369:                   case Types.INTEGER:
1:eac0369:                         return intTypeCompiler =
1:eac0369:                                 getAnInstance(PACKAGE_NAME + "NumericTypeCompiler",
1:eac0369:                                                                 intTypeCompiler,
1:eac0369:                                                                 typeId);
1:eac0369: 
1:eac0369:                   case Types.BIGINT:
1:eac0369:                         return longintTypeCompiler =
1:eac0369:                                 getAnInstance(PACKAGE_NAME + "NumericTypeCompiler",
1:eac0369:                                                                 longintTypeCompiler,
1:eac0369:                                                                 typeId);
1:eac0369: 
1:1a4ea31:                   case Types.BLOB:
1:eac0369:                         return blobTypeCompiler =
1:eac0369:                                 getAnInstance(PACKAGE_NAME + "LOBTypeCompiler",
1:eac0369:                                                           blobTypeCompiler,
1:eac0369:                                                           typeId);
1:eac0369: 
1:eac0369:                   case Types.LONGVARBINARY:
1:eac0369:                         return longvarbitTypeCompiler =
1:eac0369:                                 getAnInstance(PACKAGE_NAME + "BitTypeCompiler",
1:eac0369:                                                           longvarbitTypeCompiler,
1:eac0369:                                                           typeId);
1:eac0369: 
1:1a4ea31:                   case Types.CLOB:
1:eac0369:                       sqlTypeName = typeId.getSQLTypeName();
1:eac0369:                       return clobTypeCompiler =
2:eac0369:                           getAnInstance(PACKAGE_NAME + "CLOBTypeCompiler",
1:eac0369:                                         clobTypeCompiler,
1:eac0369:                                         typeId);
1:eac0369:                   case Types.LONGVARCHAR:
1:eac0369:                           sqlTypeName = typeId.getSQLTypeName();
1:eac0369:                           return longvarcharTypeCompiler =
5:eac0369:                               getAnInstance(PACKAGE_NAME + "CharTypeCompiler",
1:eac0369:                                                       longvarcharTypeCompiler,
1:eac0369:                                                       typeId);
1:eac0369: 
1:eac0369:                   case Types.REAL:
1:eac0369:                         return realTypeCompiler =
1:eac0369:                                 getAnInstance(PACKAGE_NAME + "NumericTypeCompiler",
1:eac0369:                                                                 realTypeCompiler,
1:eac0369:                                                                 typeId);
1:eac0369: 
1:eac0369:                   case Types.SMALLINT:
1:eac0369:                         return smallintTypeCompiler =
1:eac0369:                                 getAnInstance(PACKAGE_NAME + "NumericTypeCompiler",
1:eac0369:                                                                 smallintTypeCompiler,
1:eac0369:                                                                 typeId);
1:eac0369: 
1:eac0369:                   case Types.TINYINT:
1:eac0369:                     return tinyintTypeCompiler =
1:eac0369:                                 getAnInstance(PACKAGE_NAME + "NumericTypeCompiler",
1:eac0369:                                                                 tinyintTypeCompiler,
1:eac0369:                                                                 typeId);
1:eac0369: 
1:eac0369:                   case Types.DATE:
1:eac0369:                         return dateTypeCompiler =
1:eac0369:                                         getAnInstance(PACKAGE_NAME + "DateTypeCompiler",
1:eac0369:                                                                         dateTypeCompiler,
1:eac0369:                                                                         typeId);
1:eac0369: 
1:eac0369:                   case Types.TIME:
1:eac0369:                         return timeTypeCompiler =
1:eac0369:                                         getAnInstance(PACKAGE_NAME + "TimeTypeCompiler",
1:eac0369:                                                                         timeTypeCompiler,
1:eac0369:                                                                         typeId);
1:eac0369:                   case Types.TIMESTAMP:
1:eac0369:                         return timestampTypeCompiler =
1:eac0369:                                         getAnInstance(PACKAGE_NAME + "TimestampTypeCompiler",
1:eac0369:                                                                         timestampTypeCompiler,
1:eac0369:                                                                         typeId);
1:eac0369:                   case Types.VARBINARY:
1:eac0369:                         return varbitTypeCompiler =
1:eac0369:                                 getAnInstance(PACKAGE_NAME + "BitTypeCompiler",
1:eac0369:                                                                 varbitTypeCompiler,
1:eac0369:                                                                 typeId);
1:eac0369: 
1:eac0369:                   case Types.VARCHAR:
1:eac0369:                           sqlTypeName = typeId.getSQLTypeName();
1:eac0369:                           return varcharTypeCompiler =
1:eac0369:                               getAnInstance(PACKAGE_NAME + "CharTypeCompiler",
1:eac0369:                                                       varcharTypeCompiler,
1:eac0369:                                                       typeId);
1:eac0369: 
1:1a4ea31:                   case Types.JAVA_OBJECT:
1:eac0369:                   case Types.OTHER:
1:eac0369:                         if (typeId.isRefTypeId())
1:eac0369:                         {
1:eac0369:                                 return refTypeCompiler = getAnInstance(
1:eac0369:                                                                                         PACKAGE_NAME + "RefTypeCompiler",
1:eac0369:                                                                                         refTypeCompiler,
1:eac0369:                                                                                         typeId);
1:92268ac:                         }
4:eac0369:                         else
1:eac0369:                         {
1:eac0369:                                 // Cannot re-use instances of user-defined type compilers,
1:eac0369:                                 // because they contain the class name
1:eac0369:                                 BaseTypeCompiler btc = new UserDefinedTypeCompiler();
1:eac0369:                                 btc.setTypeId(typeId);
1:eac0369:                                 return btc;
1:eac0369:                         }
1:eac0369: 
1:e33b8d8:                   case Types.SQLXML:
1:099e28f:                         return xmlTypeCompiler =
1:099e28f:                                 getAnInstance(PACKAGE_NAME + "XMLTypeCompiler",
1:099e28f:                                                                 xmlTypeCompiler,
1:eac0369:                                                                 typeId);
1:eac0369: 
1:eac0369:                 }
1:eac0369: 
1:eac0369:                 if (SanityManager.DEBUG)
1:eac0369:                 {
1:eac0369:                         SanityManager.THROWASSERT("Unexpected JDBC type id " +
1:eac0369:                                                                                 typeId.getJDBCTypeId() +
1:eac0369:                                                                                 " for typeId of class " +
1:eac0369:                                                                                 typeId.getClass().getName());
1:eac0369:                 }
1:eac0369: 
1:eac0369:                 return null;
1:eac0369:         }
1:eac0369: 
1:eac0369:         /**
1:eac0369:          * Check whether the given TypeCompiler has been allocated yet.
1:eac0369:          * If so, just return it, otherwise allocate a new instance
1:eac0369:          * given its class.
1:eac0369:          */
1:eac0369:         private static TypeCompiler getAnInstance(String className,
1:eac0369:                                                                 TypeCompiler anInstance,
1:eac0369:                                                                 TypeId typeId)
1:eac0369:         {
1:eac0369:                 if (anInstance == null)
1:eac0369:                 {
1:eac0369:                         Exception exc = null;
1:e1f49ca:                         Class<?> typeCompilerClass = null;
1:eac0369: 
1:eac0369:                         try
1:eac0369:                         {
1:eac0369:                                 typeCompilerClass = Class.forName(className);
1:4469400:                                 anInstance  = (TypeCompiler)
1:4469400:                                     typeCompilerClass.getConstructor().newInstance();
1:eac0369:                                 ((BaseTypeCompiler) anInstance).setTypeId(typeId);
1:eac0369:                         }
1:eac0369:                         catch (ClassNotFoundException cnfe)
1:eac0369:                         {
1:eac0369:                                 exc = cnfe;
1:eac0369:                         }
1:eac0369:                         catch (IllegalAccessException iae)
1:eac0369:                         {
1:eac0369:                                 exc = iae;
1:eac0369:                         }
1:eac0369:                         catch (InstantiationException ie)
1:eac0369:                         {
1:eac0369:                                 exc = ie;
1:eac0369:                         }
1:4469400:                         catch (NoSuchMethodException nsme)
1:4469400:                         {
1:4469400:                                 exc = nsme;
1:4469400:                         }
1:4469400:                         catch (java.lang.reflect.InvocationTargetException ite)
1:4469400:                         {
1:4469400:                                 exc = ite;
1:4469400:                         }
1:eac0369: 
1:eac0369:                         if (SanityManager.DEBUG)
1:eac0369:                         {
1:eac0369:                                 if (exc != null)
1:eac0369:                                 {
1:eac0369:                                         SanityManager.THROWASSERT(
1:eac0369:                                                 "Exception " +
1:eac0369:                                                 exc +
1:eac0369:                                                 " while trying to get new instance of a " +
1:eac0369:                                                 typeCompilerClass.getName());
1:eac0369:                                 }
1:eac0369:                         }
1:eac0369:                 }
1:eac0369: 
1:eac0369:                 return anInstance;
1:eac0369:         }
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:4469400
/////////////////////////////////////////////////////////////////////////
1:                                 anInstance  = (TypeCompiler)
1:                                     typeCompilerClass.getConstructor().newInstance();
/////////////////////////////////////////////////////////////////////////
1:                         catch (NoSuchMethodException nsme)
1:                         {
1:                                 exc = nsme;
1:                         }
1:                         catch (java.lang.reflect.InvocationTargetException ite)
1:                         {
1:                                 exc = ite;
1:                         }
commit:9495437
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:92268ac
/////////////////////////////////////////////////////////////////////////
0:         static TypeCompiler passwordTypeCompiler;
/////////////////////////////////////////////////////////////////////////
0:                 if ( typeId.isPasswordTypeId() )
1:                 {
0:                     return passwordTypeCompiler =
1:                         getAnInstance(PACKAGE_NAME + "CharTypeCompiler",
0:                                       passwordTypeCompiler,
1:                                       typeId);
1:                 }
1: 
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:e1f49ca
/////////////////////////////////////////////////////////////////////////
1:                         Class<?> typeCompilerClass = null;
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.sql.compile.TypeCompiler;
1: import org.apache.derby.iapi.sql.compile.TypeCompilerFactory;
1: import org.apache.derby.iapi.types.TypeId;
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:e33b8d8
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                   case Types.SQLXML:
commit:402f3c2
/////////////////////////////////////////////////////////////////////////
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:1a4ea31
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                   case Types.BOOLEAN:
/////////////////////////////////////////////////////////////////////////
1:                   case Types.BLOB:
/////////////////////////////////////////////////////////////////////////
1:                   case Types.CLOB:
/////////////////////////////////////////////////////////////////////////
1:                   case Types.JAVA_OBJECT:
commit:01b5961
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.reference.JDBC40Translation;
/////////////////////////////////////////////////////////////////////////
0:                   case JDBC40Translation.SQLXML:
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.compile.TypeCompilerFactoryImpl
1: 
0:    Copyright 1999, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:61070a6
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1999, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.sql.compile;
1: 
0: import org.apache.derby.iapi.sql.compile.TypeCompilerFactory;
0: import org.apache.derby.iapi.sql.compile.TypeCompiler;
0: import org.apache.derby.iapi.types.TypeId;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
0: import org.apache.derby.iapi.reference.JDBC20Translation;
0: import org.apache.derby.iapi.reference.JDBC30Translation;
1: 
0: import java.util.Properties;
1: 
1: import java.sql.Types;
1: 
1: public class TypeCompilerFactoryImpl implements TypeCompilerFactory
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1999_2004;
1:         private static final String PACKAGE_NAME =
1:                         "org.apache.derby.impl.sql.compile.";
1: 
1:         // These are all the TypeCompilers that are stateless, so we can
1:         // use a single instance of each. Initialize all to null, and fault
1:         // them in.
1:         static TypeCompiler bitTypeCompiler;
1:         static TypeCompiler booleanTypeCompiler;
1:         static TypeCompiler charTypeCompiler;
1:         static TypeCompiler decimalTypeCompiler ;
1:         static TypeCompiler doubleTypeCompiler ;
1:         static TypeCompiler intTypeCompiler ;
1:         static TypeCompiler longintTypeCompiler ;
1:         static TypeCompiler longvarbitTypeCompiler ;
1:         static TypeCompiler longvarcharTypeCompiler ;
0:         static TypeCompiler nationalCharTypeCompiler ;
0:         static TypeCompiler nationalLongvarcharTypeCompiler ;
0:         static TypeCompiler nationalVarcharTypeCompiler ;
1:         static TypeCompiler realTypeCompiler ;
1:         static TypeCompiler smallintTypeCompiler ;
1:         static TypeCompiler tinyintTypeCompiler ;
1:         static TypeCompiler dateTypeCompiler ;
1:         static TypeCompiler timeTypeCompiler ;
1:         static TypeCompiler timestampTypeCompiler ;
1:         static TypeCompiler varbitTypeCompiler ;
1:         static TypeCompiler varcharTypeCompiler ;
1:         static TypeCompiler refTypeCompiler ;
1:         static TypeCompiler blobTypeCompiler ;
1:         static TypeCompiler clobTypeCompiler ;
0:         static TypeCompiler nclobTypeCompiler ;
1: 
1:         /**
1:          * Get a TypeCompiler corresponding to the given TypeId
1:          *
1:          * @param typeId        The TypeId to get a TypeCompiler for
1:          *
1:          * @return      The corresponding TypeCompiler
1:          */
1: 
1:         public TypeCompiler getTypeCompiler(TypeId typeId)
1:         {
1:                 return staticGetTypeCompiler(typeId);
1:         }
1: 
1:         static TypeCompiler staticGetTypeCompiler(TypeId typeId)
1:         {
1:                 String sqlTypeName;
1: 
1:                 switch (typeId.getJDBCTypeId())
1:                 {
1:                   case Types.BINARY:
1:                         return bitTypeCompiler =
1:                                         getAnInstance(PACKAGE_NAME + "BitTypeCompiler",
1:                                                                         bitTypeCompiler,
1:                                                                         typeId);
1: 
1:                   case Types.BIT:
0:                   case JDBC30Translation.SQL_TYPES_BOOLEAN:
1:                         return booleanTypeCompiler =
1:                                         getAnInstance(PACKAGE_NAME + "BooleanTypeCompiler",
1:                                                                 booleanTypeCompiler,
1:                                                                 typeId);
1: 
1:                   case Types.CHAR:
1:                           sqlTypeName = typeId.getSQLTypeName();
0:                           if (sqlTypeName.equals(TypeId.CHAR_NAME))
1:                           {
1:                                 return charTypeCompiler =
1:                                         getAnInstance(PACKAGE_NAME + "CharTypeCompiler",
1:                                                                 charTypeCompiler,
1:                                                                 typeId);
1:                           }
1:                           else
1:                           {
0:                                 return nationalCharTypeCompiler =
1:                                         getAnInstance(PACKAGE_NAME + "CharTypeCompiler",
0:                                                                 nationalCharTypeCompiler,
1:                                                                 typeId);
1:                           }
1: 
1:                   case Types.NUMERIC:
1:                   case Types.DECIMAL:
1:                         return decimalTypeCompiler =
1:                                 getAnInstance(PACKAGE_NAME + "NumericTypeCompiler",
1:                                                                 decimalTypeCompiler,
1:                                                                 typeId);
1: 
1:                   case Types.DOUBLE:
1:                         return doubleTypeCompiler =
1:                                 getAnInstance(PACKAGE_NAME + "NumericTypeCompiler",
1:                                                                 doubleTypeCompiler,
1:                                                                 typeId);
1: 
1:                   case Types.INTEGER:
1:                         return intTypeCompiler =
1:                                 getAnInstance(PACKAGE_NAME + "NumericTypeCompiler",
1:                                                                 intTypeCompiler,
1:                                                                 typeId);
1: 
1:                   case Types.BIGINT:
1:                         return longintTypeCompiler =
1:                                 getAnInstance(PACKAGE_NAME + "NumericTypeCompiler",
1:                                                                 longintTypeCompiler,
1:                                                                 typeId);
1: 
0:                   case JDBC20Translation.SQL_TYPES_BLOB:
1:                         return blobTypeCompiler =
1:                                 getAnInstance(PACKAGE_NAME + "LOBTypeCompiler",
1:                                                           blobTypeCompiler,
1:                                                           typeId);
1: 
1:                   case Types.LONGVARBINARY:
1:                         return longvarbitTypeCompiler =
1:                                 getAnInstance(PACKAGE_NAME + "BitTypeCompiler",
1:                                                           longvarbitTypeCompiler,
1:                                                           typeId);
1: 
0:                   case JDBC20Translation.SQL_TYPES_CLOB:
1:                       sqlTypeName = typeId.getSQLTypeName();
0:                       if (sqlTypeName.equals(TypeId.CLOB_NAME)) {
1:                           return clobTypeCompiler =
1:                               getAnInstance(PACKAGE_NAME + "CLOBTypeCompiler",
1:                                             clobTypeCompiler,
1:                                             typeId);
0:                       } else {
0:                           return nclobTypeCompiler =
1:                               getAnInstance(PACKAGE_NAME + "CLOBTypeCompiler",
0:                                             nclobTypeCompiler,
1:                                             typeId);
1:                       }
1:                   case Types.LONGVARCHAR:
1:                           sqlTypeName = typeId.getSQLTypeName();
0:                           if (sqlTypeName.equals(TypeId.LONGVARCHAR_NAME))
1:                           {
1:                                 return longvarcharTypeCompiler =
1:                                         getAnInstance(PACKAGE_NAME + "CharTypeCompiler",
1:                                                                 longvarcharTypeCompiler,
1:                                                                 typeId);
1:                           }
1:                           else
1:                           {
0:                                 return nationalLongvarcharTypeCompiler =
1:                                         getAnInstance(PACKAGE_NAME + "CharTypeCompiler",
0:                                                                 nationalLongvarcharTypeCompiler,
1:                                                                 typeId);
1:                           }
1: 
1:                   case Types.REAL:
1:                         return realTypeCompiler =
1:                                 getAnInstance(PACKAGE_NAME + "NumericTypeCompiler",
1:                                                                 realTypeCompiler,
1:                                                                 typeId);
1: 
1:                   case Types.SMALLINT:
1:                         return smallintTypeCompiler =
1:                                 getAnInstance(PACKAGE_NAME + "NumericTypeCompiler",
1:                                                                 smallintTypeCompiler,
1:                                                                 typeId);
1: 
1:                   case Types.TINYINT:
1:                     return tinyintTypeCompiler =
1:                                 getAnInstance(PACKAGE_NAME + "NumericTypeCompiler",
1:                                                                 tinyintTypeCompiler,
1:                                                                 typeId);
1: 
1:                   case Types.DATE:
1:                         return dateTypeCompiler =
1:                                         getAnInstance(PACKAGE_NAME + "DateTypeCompiler",
1:                                                                         dateTypeCompiler,
1:                                                                         typeId);
1: 
1:                   case Types.TIME:
1:                         return timeTypeCompiler =
1:                                         getAnInstance(PACKAGE_NAME + "TimeTypeCompiler",
1:                                                                         timeTypeCompiler,
1:                                                                         typeId);
1:                   case Types.TIMESTAMP:
1:                         return timestampTypeCompiler =
1:                                         getAnInstance(PACKAGE_NAME + "TimestampTypeCompiler",
1:                                                                         timestampTypeCompiler,
1:                                                                         typeId);
1:                   case Types.VARBINARY:
1:                         return varbitTypeCompiler =
1:                                 getAnInstance(PACKAGE_NAME + "BitTypeCompiler",
1:                                                                 varbitTypeCompiler,
1:                                                                 typeId);
1: 
1:                   case Types.VARCHAR:
1:                           sqlTypeName = typeId.getSQLTypeName();
0:                           if (sqlTypeName.equals(TypeId.VARCHAR_NAME))
1:                           {
1:                                 return varcharTypeCompiler =
1:                                         getAnInstance(PACKAGE_NAME + "CharTypeCompiler",
1:                                                                 varcharTypeCompiler,
1:                                                                 typeId);
1:                           }
1:                           else
1:                           {
0:                                 return nationalVarcharTypeCompiler =
1:                                         getAnInstance(PACKAGE_NAME + "CharTypeCompiler",
0:                                                                 nationalVarcharTypeCompiler,
1:                                                                 typeId);
1:                           }
1: 
0:                   case org.apache.derby.iapi.reference.JDBC20Translation.SQL_TYPES_JAVA_OBJECT:
1:                   case Types.OTHER:
1:                         if (typeId.isRefTypeId())
1:                         {
1:                                 return refTypeCompiler = getAnInstance(
1:                                                                                         PACKAGE_NAME + "RefTypeCompiler",
1:                                                                                         refTypeCompiler,
1:                                                                                         typeId);
1:                         }
1:                         else
1:                         {
1:                                 // Cannot re-use instances of user-defined type compilers,
1:                                 // because they contain the class name
1:                                 BaseTypeCompiler btc = new UserDefinedTypeCompiler();
1:                                 btc.setTypeId(typeId);
1:                                 return btc;
1:                         }
1:                 }
1: 
1:                 if (SanityManager.DEBUG)
1:                 {
1:                         SanityManager.THROWASSERT("Unexpected JDBC type id " +
1:                                                                                 typeId.getJDBCTypeId() +
1:                                                                                 " for typeId of class " +
1:                                                                                 typeId.getClass().getName());
1:                 }
1: 
1:                 return null;
1:         }
1: 
1:         /**
1:          * Check whether the given TypeCompiler has been allocated yet.
1:          * If so, just return it, otherwise allocate a new instance
1:          * given its class.
1:          */
1:         private static TypeCompiler getAnInstance(String className,
1:                                                                 TypeCompiler anInstance,
1:                                                                 TypeId typeId)
1:         {
1:                 if (anInstance == null)
1:                 {
1:                         Exception exc = null;
0:                         Class typeCompilerClass = null;
1: 
1:                         try
1:                         {
1:                                 typeCompilerClass = Class.forName(className);
0:                                 anInstance  = (TypeCompiler) typeCompilerClass.newInstance();
1:                                 ((BaseTypeCompiler) anInstance).setTypeId(typeId);
1:                         }
1:                         catch (ClassNotFoundException cnfe)
1:                         {
1:                                 exc = cnfe;
1:                         }
1:                         catch (IllegalAccessException iae)
1:                         {
1:                                 exc = iae;
1:                         }
1:                         catch (InstantiationException ie)
1:                         {
1:                                 exc = ie;
1:                         }
1: 
1:                         if (SanityManager.DEBUG)
1:                         {
1:                                 if (exc != null)
1:                                 {
1:                                         SanityManager.THROWASSERT(
1:                                                 "Exception " +
1:                                                 exc +
1:                                                 " while trying to get new instance of a " +
1:                                                 typeCompilerClass.getName());
1:                                 }
1:                         }
1:                 }
1: 
1:                 return anInstance;
1:         }
1: }
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:111785f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                           return charTypeCompiler =
0:                               getAnInstance(PACKAGE_NAME + "CharTypeCompiler",
0:                                                       charTypeCompiler,
0:                                                       typeId);
/////////////////////////////////////////////////////////////////////////
0:                       return clobTypeCompiler =
0:                           getAnInstance(PACKAGE_NAME + "CLOBTypeCompiler",
0:                                         clobTypeCompiler,
0:                                         typeId);
0:                           return longvarcharTypeCompiler =
0:                               getAnInstance(PACKAGE_NAME + "CharTypeCompiler",
0:                                                       longvarcharTypeCompiler,
0:                                                       typeId);
/////////////////////////////////////////////////////////////////////////
0:                           return varcharTypeCompiler =
0:                               getAnInstance(PACKAGE_NAME + "CharTypeCompiler",
0:                                                       varcharTypeCompiler,
0:                                                       typeId);
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2d37fd6
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:099e28f
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.services.io.StoredFormatIds;
/////////////////////////////////////////////////////////////////////////
1:         static TypeCompiler xmlTypeCompiler ;
/////////////////////////////////////////////////////////////////////////
0: 
0:                   case StoredFormatIds.XML_TYPE_ID:
1:                         return xmlTypeCompiler =
1:                                 getAnInstance(PACKAGE_NAME + "XMLTypeCompiler",
1:                                                                 xmlTypeCompiler,
0:                                                                 typeId);
0: 
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1999, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.sql.compile;
0: 
0: import org.apache.derby.iapi.sql.compile.TypeCompilerFactory;
0: import org.apache.derby.iapi.sql.compile.TypeCompiler;
0: import org.apache.derby.iapi.types.TypeId;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.reference.JDBC20Translation;
0: import org.apache.derby.iapi.reference.JDBC30Translation;
0: 
0: import java.util.Properties;
0: 
0: import java.sql.Types;
0: 
0: public class TypeCompilerFactoryImpl implements TypeCompilerFactory
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1999_2004;
0:         private static final String PACKAGE_NAME =
0:                         "org.apache.derby.impl.sql.compile.";
0: 
0:         // These are all the TypeCompilers that are stateless, so we can
0:         // use a single instance of each. Initialize all to null, and fault
0:         // them in.
0:         static TypeCompiler bitTypeCompiler;
0:         static TypeCompiler booleanTypeCompiler;
0:         static TypeCompiler charTypeCompiler;
0:         static TypeCompiler decimalTypeCompiler ;
0:         static TypeCompiler doubleTypeCompiler ;
0:         static TypeCompiler intTypeCompiler ;
0:         static TypeCompiler longintTypeCompiler ;
0:         static TypeCompiler longvarbitTypeCompiler ;
0:         static TypeCompiler longvarcharTypeCompiler ;
0:         static TypeCompiler nationalCharTypeCompiler ;
0:         static TypeCompiler nationalLongvarcharTypeCompiler ;
0:         static TypeCompiler nationalVarcharTypeCompiler ;
0:         static TypeCompiler realTypeCompiler ;
0:         static TypeCompiler smallintTypeCompiler ;
0:         static TypeCompiler tinyintTypeCompiler ;
0:         static TypeCompiler dateTypeCompiler ;
0:         static TypeCompiler timeTypeCompiler ;
0:         static TypeCompiler timestampTypeCompiler ;
0:         static TypeCompiler varbitTypeCompiler ;
0:         static TypeCompiler varcharTypeCompiler ;
0:         static TypeCompiler refTypeCompiler ;
0:         static TypeCompiler blobTypeCompiler ;
0:         static TypeCompiler clobTypeCompiler ;
0:         static TypeCompiler nclobTypeCompiler ;
0: 
0:         /**
0:          * Get a TypeCompiler corresponding to the given TypeId
0:          *
0:          * @param typeId        The TypeId to get a TypeCompiler for
0:          *
0:          * @return      The corresponding TypeCompiler
0:          */
0: 
0:         public TypeCompiler getTypeCompiler(TypeId typeId)
0:         {
0:                 return staticGetTypeCompiler(typeId);
0:         }
0: 
0:         static TypeCompiler staticGetTypeCompiler(TypeId typeId)
0:         {
0:                 String sqlTypeName;
0: 
0:                 switch (typeId.getJDBCTypeId())
0:                 {
0:                   case Types.BINARY:
0:                         return bitTypeCompiler =
0:                                         getAnInstance(PACKAGE_NAME + "BitTypeCompiler",
0:                                                                         bitTypeCompiler,
0:                                                                         typeId);
0: 
0:                   case Types.BIT:
0:                   case JDBC30Translation.SQL_TYPES_BOOLEAN:
0:                         return booleanTypeCompiler =
0:                                         getAnInstance(PACKAGE_NAME + "BooleanTypeCompiler",
0:                                                                 booleanTypeCompiler,
0:                                                                 typeId);
0: 
0:                   case Types.CHAR:
0:                           sqlTypeName = typeId.getSQLTypeName();
0:                           if (sqlTypeName.equals(TypeId.CHAR_NAME))
0:                           {
0:                                 return charTypeCompiler =
0:                                         getAnInstance(PACKAGE_NAME + "CharTypeCompiler",
0:                                                                 charTypeCompiler,
0:                                                                 typeId);
0:                           }
0:                           else
0:                           {
0:                                 return nationalCharTypeCompiler =
0:                                         getAnInstance(PACKAGE_NAME + "CharTypeCompiler",
0:                                                                 nationalCharTypeCompiler,
0:                                                                 typeId);
0:                           }
0: 
0:                   case Types.NUMERIC:
0:                   case Types.DECIMAL:
0:                         return decimalTypeCompiler =
0:                                 getAnInstance(PACKAGE_NAME + "NumericTypeCompiler",
0:                                                                 decimalTypeCompiler,
0:                                                                 typeId);
0: 
0:                   case Types.DOUBLE:
0:                         return doubleTypeCompiler =
0:                                 getAnInstance(PACKAGE_NAME + "NumericTypeCompiler",
0:                                                                 doubleTypeCompiler,
0:                                                                 typeId);
0: 
0:                   case Types.INTEGER:
0:                         return intTypeCompiler =
0:                                 getAnInstance(PACKAGE_NAME + "NumericTypeCompiler",
0:                                                                 intTypeCompiler,
0:                                                                 typeId);
0: 
0:                   case Types.BIGINT:
0:                         return longintTypeCompiler =
0:                                 getAnInstance(PACKAGE_NAME + "NumericTypeCompiler",
0:                                                                 longintTypeCompiler,
0:                                                                 typeId);
0: 
0:                   case JDBC20Translation.SQL_TYPES_BLOB:
0:                         return blobTypeCompiler =
0:                                 getAnInstance(PACKAGE_NAME + "LOBTypeCompiler",
0:                                                           blobTypeCompiler,
0:                                                           typeId);
0: 
0:                   case Types.LONGVARBINARY:
0:                         return longvarbitTypeCompiler =
0:                                 getAnInstance(PACKAGE_NAME + "BitTypeCompiler",
0:                                                           longvarbitTypeCompiler,
0:                                                           typeId);
0: 
0:                   case JDBC20Translation.SQL_TYPES_CLOB:
0:                       sqlTypeName = typeId.getSQLTypeName();
0:                       if (sqlTypeName.equals(TypeId.CLOB_NAME)) {
0:                           return clobTypeCompiler =
0:                               getAnInstance(PACKAGE_NAME + "CLOBTypeCompiler",
0:                                             clobTypeCompiler,
0:                                             typeId);
0:                       } else {
0:                           return nclobTypeCompiler =
0:                               getAnInstance(PACKAGE_NAME + "CLOBTypeCompiler",
0:                                             nclobTypeCompiler,
0:                                             typeId);
0:                       }
0:                   case Types.LONGVARCHAR:
0:                           sqlTypeName = typeId.getSQLTypeName();
0:                           if (sqlTypeName.equals(TypeId.LONGVARCHAR_NAME))
0:                           {
0:                                 return longvarcharTypeCompiler =
0:                                         getAnInstance(PACKAGE_NAME + "CharTypeCompiler",
0:                                                                 longvarcharTypeCompiler,
0:                                                                 typeId);
0:                           }
0:                           else
0:                           {
0:                                 return nationalLongvarcharTypeCompiler =
0:                                         getAnInstance(PACKAGE_NAME + "CharTypeCompiler",
0:                                                                 nationalLongvarcharTypeCompiler,
0:                                                                 typeId);
0:                           }
0: 
0:                   case Types.REAL:
0:                         return realTypeCompiler =
0:                                 getAnInstance(PACKAGE_NAME + "NumericTypeCompiler",
0:                                                                 realTypeCompiler,
0:                                                                 typeId);
0: 
0:                   case Types.SMALLINT:
0:                         return smallintTypeCompiler =
0:                                 getAnInstance(PACKAGE_NAME + "NumericTypeCompiler",
0:                                                                 smallintTypeCompiler,
0:                                                                 typeId);
0: 
0:                   case Types.TINYINT:
0:                     return tinyintTypeCompiler =
0:                                 getAnInstance(PACKAGE_NAME + "NumericTypeCompiler",
0:                                                                 tinyintTypeCompiler,
0:                                                                 typeId);
0: 
0:                   case Types.DATE:
0:                         return dateTypeCompiler =
0:                                         getAnInstance(PACKAGE_NAME + "DateTypeCompiler",
0:                                                                         dateTypeCompiler,
0:                                                                         typeId);
0: 
0:                   case Types.TIME:
0:                         return timeTypeCompiler =
0:                                         getAnInstance(PACKAGE_NAME + "TimeTypeCompiler",
0:                                                                         timeTypeCompiler,
0:                                                                         typeId);
0:                   case Types.TIMESTAMP:
0:                         return timestampTypeCompiler =
0:                                         getAnInstance(PACKAGE_NAME + "TimestampTypeCompiler",
0:                                                                         timestampTypeCompiler,
0:                                                                         typeId);
0:                   case Types.VARBINARY:
0:                         return varbitTypeCompiler =
0:                                 getAnInstance(PACKAGE_NAME + "BitTypeCompiler",
0:                                                                 varbitTypeCompiler,
0:                                                                 typeId);
0: 
0:                   case Types.VARCHAR:
0:                           sqlTypeName = typeId.getSQLTypeName();
0:                           if (sqlTypeName.equals(TypeId.VARCHAR_NAME))
0:                           {
0:                                 return varcharTypeCompiler =
0:                                         getAnInstance(PACKAGE_NAME + "CharTypeCompiler",
0:                                                                 varcharTypeCompiler,
0:                                                                 typeId);
0:                           }
0:                           else
0:                           {
0:                                 return nationalVarcharTypeCompiler =
0:                                         getAnInstance(PACKAGE_NAME + "CharTypeCompiler",
0:                                                                 nationalVarcharTypeCompiler,
0:                                                                 typeId);
0:                           }
0: 
0:                   case org.apache.derby.iapi.reference.JDBC20Translation.SQL_TYPES_JAVA_OBJECT:
0:                   case Types.OTHER:
0:                         if (typeId.isRefTypeId())
0:                         {
0:                                 return refTypeCompiler = getAnInstance(
0:                                                                                         PACKAGE_NAME + "RefTypeCompiler",
0:                                                                                         refTypeCompiler,
0:                                                                                         typeId);
0:                         }
0:                         else
0:                         {
0:                                 // Cannot re-use instances of user-defined type compilers,
0:                                 // because they contain the class name
0:                                 BaseTypeCompiler btc = new UserDefinedTypeCompiler();
0:                                 btc.setTypeId(typeId);
0:                                 return btc;
0:                         }
0:                 }
0: 
0:                 if (SanityManager.DEBUG)
0:                 {
0:                         SanityManager.THROWASSERT("Unexpected JDBC type id " +
0:                                                                                 typeId.getJDBCTypeId() +
0:                                                                                 " for typeId of class " +
0:                                                                                 typeId.getClass().getName());
0:                 }
0: 
0:                 return null;
0:         }
0: 
0:         /**
0:          * Check whether the given TypeCompiler has been allocated yet.
0:          * If so, just return it, otherwise allocate a new instance
0:          * given its class.
0:          */
0:         private static TypeCompiler getAnInstance(String className,
0:                                                                 TypeCompiler anInstance,
0:                                                                 TypeId typeId)
0:         {
0:                 if (anInstance == null)
0:                 {
0:                         Exception exc = null;
0:                         Class typeCompilerClass = null;
0: 
0:                         try
0:                         {
0:                                 typeCompilerClass = Class.forName(className);
0:                                 anInstance  = (TypeCompiler) typeCompilerClass.newInstance();
0:                                 ((BaseTypeCompiler) anInstance).setTypeId(typeId);
0:                         }
0:                         catch (ClassNotFoundException cnfe)
0:                         {
0:                                 exc = cnfe;
0:                         }
0:                         catch (IllegalAccessException iae)
0:                         {
0:                                 exc = iae;
0:                         }
0:                         catch (InstantiationException ie)
0:                         {
0:                                 exc = ie;
0:                         }
0: 
0:                         if (SanityManager.DEBUG)
0:                         {
0:                                 if (exc != null)
0:                                 {
0:                                         SanityManager.THROWASSERT(
0:                                                 "Exception " +
0:                                                 exc +
0:                                                 " while trying to get new instance of a " +
0:                                                 typeCompilerClass.getName());
0:                                 }
0:                         }
0:                 }
0: 
0:                 return anInstance;
0:         }
0: }
============================================================================