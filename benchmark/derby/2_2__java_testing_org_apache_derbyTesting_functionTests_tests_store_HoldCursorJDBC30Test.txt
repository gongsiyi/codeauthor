1:e734b17: /*
1:e734b17:  * 
1:e734b17:  * Derby - Class org.apache.derbyTesting.functionTests.tests.store.HoldCursorJDBC30Test
1:e734b17:  * 
1:e734b17:  * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
1:e734b17:  * agreements. See the NOTICE file distributed with this work for additional information
1:e734b17:  * regarding copyright ownership. The ASF licenses this file to You under the Apache
1:e734b17:  * License, Version 2.0 (the "License"); you may not use this file except in compliance
1:e734b17:  * with the License. You may obtain a copy of the License at
1:e734b17:  * 
1:e734b17:  * http://www.apache.org/licenses/LICENSE-2.0
1:e734b17:  * 
1:e734b17:  * Unless required by applicable law or agreed to in writing, software distributed under
1:e734b17:  * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:e734b17:  * KIND, either express or implied. See the License for the specific language governing
1:e734b17:  * permissions and limitations under the License.
1:e734b17:  * 
1:e734b17:  */
3:e734b17: 
1:e734b17: package org.apache.derbyTesting.functionTests.tests.store;
1:e734b17: 
1:e734b17: import java.sql.PreparedStatement;
1:e734b17: import java.sql.ResultSet;
1:e734b17: import java.sql.SQLException;
1:e734b17: import java.sql.Statement;
1:1ae02c9: import junit.framework.Test;
1:e734b17: import org.apache.derbyTesting.functionTests.util.Formatters;
1:e734b17: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:e734b17: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1:e734b17: import org.apache.derbyTesting.junit.JDBC;
1:e734b17: import org.apache.derbyTesting.junit.TestConfiguration;
1:e734b17: 
1:e734b17: public final class HoldCursorJDBC30Test extends BaseJDBCTestCase {
1:e734b17: 
1:e734b17:     /**
1:e734b17:      * Public constructor required for running test as standalone JUnit.
1:e734b17:      */
1:e734b17:     public HoldCursorJDBC30Test(String name) {
1:e734b17:         super(name);
2:e734b17:     }
1:e734b17: 
1:e734b17:     /**
1:e734b17:      * This will allow us to decorate the test for each driver separately
1:e734b17:      */
1:e734b17:     private static Test decorateTest(Test test) {
1:e734b17:         return new CleanDatabaseTestSetup(test){
1:e734b17:             protected void decorateSQL(Statement s)
1:e734b17:             throws SQLException {
1:e734b17:                 /* getConnection().setAutoCommit(false); */
1:e734b17: 
1:e734b17:                 /* testBasicHeapScanZeroRows */
1:e734b17:                 s.execute("create table foo1 (a int, data int)");
1:e734b17: 
1:e734b17:                 /* testBasicHeapScanMultiRows */
1:e734b17:                 s.execute("create table foo2 (a int, data int)");
1:e734b17: 
1:e734b17:                 /* testBasicBtreeScanForZeroRowsUpdateNonkeyfield */
1:e734b17:                 s.execute("create table foo3 (a int, data int)");
1:e734b17:                 s.execute("create index foox_3 on foo3 (a)");
1:e734b17: 
1:e734b17:                 /* testBasicBtreeScanTestsForMultipleRowsOrUpdateNonkeyField */
1:e734b17:                 s.execute("create table foo4 (a int, data int)");
1:e734b17: 
1:e734b17:                 /* testBasicBtreeScanForZeroRowsReadOnlyNoGroupFetch */
1:e734b17:                 s.execute("create table foo5 (a int, data int)");
1:e734b17:                 s.execute("create index foox_5 on foo5 (a)");
1:e734b17: 
1:e734b17:                 /* testBasicBtreeScanTestsForMultipleRowsOrReadOnly */
1:e734b17:                 s.execute("create table foo6 (a int, data int)");
1:e734b17: 
1:e734b17:                 /* testOrder */
1:e734b17:                 s.execute("create table foo7 (a int, data int)");
1:e734b17:                 s.execute("create index foox_7 on foo7 (a)");
1:e734b17: 
1:e734b17:                 /* testDistinctScalarAggregateResultSet */
1:e734b17:                 s.execute("create table t1_8 (c1 int, c2 int)");
1:e734b17: 
1:e734b17:                 /* testDistinctScalarAggregateResultSetGrouped */
1:e734b17:                 s.execute("create table t1_9 (c1 int, c2 int)");
1:e734b17: 
1:e734b17:                 /* testPositionPurgedRow */
1:e734b17:                 s.execute("create table t1_10 (c1 int, c2 int)");
1:e734b17:                 s.execute("create index tx_10 on t1_10 (c1)");
1:e734b17: 
1:e734b17:                 /* testPositionPurgedPage - Index created on test here */
1:e734b17:                 s.execute("create table t1_11 (c1 varchar(1000), c2 int)");
1:e734b17: 
1:e734b17:                 /* testBeetle4902 */
1:e734b17:                 s.execute("create table t1_12 (t1_i1 int, t1_i2 int)");
1:e734b17:                 s.execute("create table t2_12 (t2_i1 int, t2_i2 int)");
1:e734b17:                 s.execute("create index t1_idx_12 on t1_12 (t1_i1)");
1:e734b17:                 s.execute("create index t2_idx_12 on t2_12 (t2_i1)");
1:e734b17: 
1:e734b17:                 /* testBeetle4902WithBulkFetchDefaultSet */
1:e734b17:                 s.execute("create table t1_13 (t1_i1 int, t1_i2 int)");
1:e734b17:                 s.execute("create table t2_13 (t2_i1 int, t2_i2 int)");
1:e734b17:                 s.execute("create index t1_idx_13 on t1_13 (t1_i1)");
1:e734b17:                 s.execute("create index t2_idx_13 on t2_13 (t2_i1)");
1:e734b17:             }
1:e734b17:         };
1:e734b17:     }
1:e734b17: 
1:e734b17:     public static Test suite() {
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite("HoldCursorJDBC30Test");
1:e734b17:         suite.addTest(decorateTest(TestConfiguration.embeddedSuite(HoldCursorJDBC30Test.class)));
1:e734b17:         suite.addTest(decorateTest(TestConfiguration.clientServerSuite(HoldCursorJDBC30Test.class)));
1:e734b17:         
1:e734b17:         return suite;
1:e734b17:     }
1:e734b17:        
1:e734b17:     /**
1:e734b17:      * Disabling auto-commit for all tests
1:e734b17:      * @throws java.sql.SQLException
1:e734b17:      */
1:e734b17:     protected void setUp() throws SQLException {
1:e734b17:         setAutoCommit(false);
1:e734b17:         createStatement().execute("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:e734b17:                              "'derby.language.bulkFetchDefault', '1')");
1:e734b17:     }
1:e734b17: 
1:e734b17:     /**
1:e734b17:      * The following tests that no matter where commit comes in the state of
1:e734b17:      * the scan that the scan will continue after the commit.  Tests various
1:e734b17:      * states of scan like: before first next, after first next, before close,
1:e734b17:      * after close.
1:e734b17:      */
1:e734b17:     public void testBasicHeapScanZeroRows() throws SQLException{ 
1:e734b17:         Statement stUtil = createStatement();
1:e734b17:                 
1:e734b17:         Statement st = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
1:e734b17:                                        ResultSet.CONCUR_READ_ONLY,
1:e734b17:                                        ResultSet.HOLD_CURSORS_OVER_COMMIT);
1:e734b17: 
1:e734b17:         ResultSet test1 = st.executeQuery("select * from foo1");
1:e734b17:         test1.close();
1:e734b17:         commit();
1:e734b17:         try {
1:e734b17:             test1.next();
1:e734b17:             fail("Should be unable to establish cursor!");
1:e734b17:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:e734b17:        
1:e734b17:         test1 = st.executeQuery("select * from foo1 for update");
1:e734b17:         commit();
1:e734b17:         test1.close();
1:e734b17:         try {
1:e734b17:             test1.next();
1:e734b17:             fail("Should be unable to establish cursor!");
1:e734b17:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:e734b17:          
1:e734b17:         test1 = st.executeQuery("select * from foo1 for update");
1:e734b17:         commit();
1:e734b17:         assertFalse(test1.next());
1:e734b17:         test1.close();
1:e734b17:         try {
1:e734b17:             test1.next();
1:e734b17:             fail("Should be unable to establish cursor!");
1:e734b17:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:e734b17:         
1:e734b17:         test1 = st.executeQuery("select * from foo1 for update");
1:e734b17:         assertFalse(test1.next());
1:e734b17:         commit();     
1:e734b17:         assertFalse(test1.next());
1:e734b17:         test1.close();
1:e734b17:         try {
1:e734b17:             test1.next();
1:e734b17:             fail("Should be unable to establish cursor!");
1:e734b17:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:e734b17:         
1:e734b17:         test1 = st.executeQuery("select * from foo1 for update");
1:e734b17:         assertFalse(test1.next());
1:e734b17:         commit();
1:e734b17:         assertFalse(test1.next());
1:e734b17:         commit();
1:e734b17:         test1.close();
1:e734b17:         try {
1:e734b17:             test1.next();
1:e734b17:             fail("Should be unable to establish cursor!");
1:e734b17:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:e734b17:         
1:e734b17:         test1 = st.executeQuery("select * from foo1 for update");
1:e734b17:         assertFalse(test1.next());
1:e734b17:         commit();
1:e734b17:         assertFalse(test1.next());
1:e734b17:         commit();
1:e734b17:         assertFalse(test1.next());
1:e734b17:         assertFalse(test1.next());
1:e734b17:         assertFalse(test1.next());
1:e734b17:         commit();
1:e734b17:         test1.close();
1:e734b17:         try {
1:e734b17:             test1.next();
1:e734b17:             fail("Should be unable to establish cursor!");
1:e734b17:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:e734b17:         
1:e734b17:         test1 = st.executeQuery("select * from foo1 for update");
1:e734b17:         assertFalse(test1.next());
1:e734b17:         commit();
1:e734b17:         assertFalse(test1.next());
1:e734b17:         commit();
1:e734b17:         assertFalse(test1.next());
1:e734b17:         assertFalse(test1.next());
1:e734b17:         assertFalse(test1.next());
1:e734b17:         assertFalse(test1.next());
1:e734b17:         commit();
1:e734b17:         test1.close();
1:e734b17:         try {
1:e734b17:             test1.next();
1:e734b17:             fail("Should be unable to establish cursor!");
1:e734b17:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:e734b17:         
1:e734b17:         test1 = st.executeQuery("select * from foo1");
1:e734b17:         assertFalse(test1.next());
1:e734b17:         commit();
1:e734b17:         assertFalse(test1.next());
1:e734b17:         commit();
1:e734b17:         assertFalse(test1.next());
1:e734b17:         assertFalse(test1.next());
1:e734b17:         assertFalse(test1.next());
1:e734b17:         assertFalse(test1.next());
1:e734b17:         test1.close();
1:e734b17:         commit();
1:e734b17:         try {
1:e734b17:             test1.next();
1:e734b17:             fail("Should be unable to establish cursor!");
1:e734b17:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:e734b17:         
1:e734b17:         commit();
1:e734b17:         
1:e734b17:         st.close();
1:e734b17:         stUtil.close();
1:1ae02c9:     }
1:e734b17:     
1:e734b17:     /**
1:e734b17:      * The following tests that no matter where commit comes in the state of 
1:e734b17:      * the scan that the scan will continue after the commit. 
1:e734b17:      * Tests various states of scan like: before first next, 
1:e734b17:      * after first next, before close,after close.
1:e734b17:      */
1:e734b17:     public void testBasicHeapScanMultiRows() throws SQLException{ 
1:e734b17:         Statement stUtil = createStatement();
1:e734b17: 
1:e734b17:         stUtil.addBatch("insert into foo2 values (1, 10)");
1:e734b17:         stUtil.addBatch("insert into foo2 values (1, 20)");
1:e734b17:         stUtil.addBatch("insert into foo2 values (1, 30)");
1:e734b17:         stUtil.addBatch("insert into foo2 values (1, 40)");
1:e734b17:         stUtil.addBatch("insert into foo2 values (1, 50)");
1:e734b17:         stUtil.executeBatch();
1:e734b17: 
1:e734b17:         Statement st = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
1:e734b17:                                        ResultSet.CONCUR_READ_ONLY,
1:e734b17:                                        ResultSet.HOLD_CURSORS_OVER_COMMIT);
1:e734b17:         
1:e734b17:         /*the following for update cursors will all use group fetch = 1,
1:e734b17:          thus each next passes straight through to store. */
1:e734b17:         ResultSet test1 = st.executeQuery("select * from foo2 for update");
1:e734b17:         test1.close();
1:e734b17:         commit();
1:e734b17:         try {
1:e734b17:             test1.next();
1:e734b17:             fail("Should be unable to establish cursor!");
1:e734b17:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:e734b17:         
1:e734b17:         test1 = st.executeQuery("select * from foo2 for update");
1:e734b17:         commit();
1:e734b17:         test1.close();
1:e734b17:         try {
1:e734b17:             test1.next();
1:e734b17:             fail("Should be unable to establish cursor!");
1:e734b17:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:e734b17:          
1:e734b17:         test1 = st.executeQuery("select * from foo2 for update");
1:e734b17:         commit();
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(10,test1.getInt("data"));
1:e734b17:         test1.close();
1:e734b17:         try {
1:e734b17:             test1.next();
1:e734b17:             fail("Should be unable to establish cursor!");
1:e734b17:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:e734b17:         
1:e734b17:         test1 = st.executeQuery("select * from foo2 for update");
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(10,test1.getInt("data"));
1:e734b17:         commit();
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(20,test1.getInt("data"));
1:e734b17:         test1.close();
1:e734b17:         try {
1:e734b17:             test1.next();
1:e734b17:             fail("Should be unable to establish cursor!");
1:e734b17:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:e734b17:         
1:e734b17:         test1 = st.executeQuery("select * from foo2 for update");
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(10,test1.getInt("data"));
1:e734b17:         commit();
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(20,test1.getInt("data"));
1:e734b17:         commit();
1:e734b17:         test1.close();
1:e734b17:         try {
1:e734b17:             test1.next();
1:e734b17:             fail("Should be unable to establish cursor!");
1:e734b17:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:e734b17:         
1:e734b17:         test1 = st.executeQuery("select * from foo2 for update");
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(10,test1.getInt("data"));
1:e734b17:         commit();
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(20,test1.getInt("data"));
1:e734b17:         commit();
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(30,test1.getInt("data"));
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(40,test1.getInt("data"));
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(50,test1.getInt("data"));
1:e734b17:         commit();
1:e734b17:         test1.close();
1:e734b17:         try {
1:e734b17:             test1.next();
1:e734b17:             fail("Should be unable to establish cursor!");
1:e734b17:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:e734b17:         
1:e734b17:         test1 = st.executeQuery("select * from foo2 for update");
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(10,test1.getInt("data"));
1:e734b17:         commit();
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(20,test1.getInt("data"));
1:e734b17:         commit();
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(30,test1.getInt("data"));
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(40,test1.getInt("data"));
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(50,test1.getInt("data"));
1:e734b17:         /* beyond the total num. */
1:e734b17:         assertFalse(test1.next());
1:e734b17:         commit();
1:e734b17:         test1.close();
1:e734b17:         try {
1:e734b17:             test1.next();
1:e734b17:             fail("Should be unable to establish cursor!");
1:e734b17:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:e734b17:         
1:e734b17: 
1:e734b17:         test1 = st.executeQuery("select * from foo2 for update");
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(10,test1.getInt("data"));
1:e734b17:         commit();
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(20,test1.getInt("data"));
1:e734b17:         commit();
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(30,test1.getInt("data"));
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(40,test1.getInt("data"));
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(50,test1.getInt("data"));
1:e734b17:         assertFalse(test1.next());
1:e734b17:         test1.close();
1:e734b17:         commit();
1:e734b17:         try {
1:e734b17:             test1.next();
1:e734b17:             fail("Should be unable to establish cursor!");
1:e734b17:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:e734b17:         
1:e734b17:         commit();
1:e734b17:         
1:e734b17:         st.close();
1:e734b17:         stUtil.close();
1:e734b17:     }   
1:e734b17:     
1:e734b17:     /**
1:e734b17:      *  basic btree scan tests (zero rows/update nonkey field)
1:e734b17:      *  The following tests that no matter where commit comes in the state of
1:e734b17:      *  the scan that the scan will continue after the commit.  Tests various
1:e734b17:      *  states of scan like: before first next, after first next, before close,
1:e734b17:      *  after close.
1:e734b17:      */
1:e734b17:     public void testBasicBtreeScanForZeroRowsUpdateNonkeyfield() throws SQLException{ 
1:e734b17:         Statement stUtil = createStatement();
1:e734b17: 
1:e734b17:         Statement st = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
1:e734b17:                                        ResultSet.CONCUR_READ_ONLY,
1:e734b17:                                        ResultSet.HOLD_CURSORS_OVER_COMMIT);
1:e734b17:         
1:e734b17:         /* the following for update cursors will all use group fetch = 1,
1:e734b17:            thus each next passes straight through to store. */
1:e734b17:         ResultSet test1 = st.executeQuery("select * from foo3 for update of data");
1:e734b17:         test1.close();
1:e734b17:         commit();
1:e734b17:         try {
1:e734b17:             test1.next();
1:e734b17:             fail("Should be unable to establish cursor!");
1:e734b17:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:e734b17:         
1:e734b17:         test1 = st.executeQuery("select * from foo3 for update of data");
1:e734b17:         commit();
1:e734b17:         test1.close();
1:e734b17:         try {
1:e734b17:             test1.next();
1:e734b17:             fail("Should be unable to establish cursor!");
1:e734b17:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:e734b17:          
1:e734b17:         test1 = st.executeQuery("select * from foo3 for update of data");
1:e734b17:         commit();
1:e734b17:         assertFalse(test1.next());
1:e734b17:         test1.close();
1:e734b17:         try {
1:e734b17:             test1.next();
1:e734b17:             fail("Should be Should be unable to establish cursor!");
1:e734b17:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:e734b17:         
1:e734b17:         test1 = st.executeQuery("select * from foo3 for update of data");
1:e734b17:         assertFalse(test1.next());
1:e734b17:         commit();     
1:e734b17:         assertFalse(test1.next());
1:e734b17:         test1.close();
1:e734b17:         try {
1:e734b17:             test1.next();
1:e734b17:             fail("Should be Should be unable to establish cursor!");
1:e734b17:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:e734b17:         
1:e734b17:         test1 = st.executeQuery("select * from foo3 for update of data");
1:e734b17:         assertFalse(test1.next());
1:e734b17:         commit();
1:e734b17:         assertFalse(test1.next());
1:e734b17:         commit();
1:e734b17:         test1.close();
1:e734b17:         try {
1:e734b17:             test1.next();
1:e734b17:             fail("Should be Should be unable to establish cursor!");
1:e734b17:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:e734b17:         
1:e734b17:         test1 = st.executeQuery("select * from foo3 for update of data");
1:e734b17:         assertFalse(test1.next());
1:e734b17:         commit();
1:e734b17:         assertFalse(test1.next());
1:e734b17:         commit();
1:e734b17:         assertFalse(test1.next());
1:e734b17:         assertFalse(test1.next());
1:e734b17:         assertFalse(test1.next());
1:e734b17:         commit();
1:e734b17:         test1.close();
1:e734b17:         try {
1:e734b17:             test1.next();
1:e734b17:             fail("Should be Should be unable to establish cursor!");
1:e734b17:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:e734b17:         
1:e734b17:         test1 = st.executeQuery("select * from foo3 for update of data");
1:e734b17:         assertFalse(test1.next());
1:e734b17:         commit();
1:e734b17:         assertFalse(test1.next());
1:e734b17:         commit();
1:e734b17:         assertFalse(test1.next());
1:e734b17:         assertFalse(test1.next());
1:e734b17:         assertFalse(test1.next());
1:e734b17:         assertFalse(test1.next());
1:e734b17:         commit();
1:e734b17:         test1.close();
1:e734b17:         try {
1:e734b17:             test1.next();
1:e734b17:             fail("Should be Should be unable to establish cursor!");
1:e734b17:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:e734b17:         
1:e734b17:         test1 = st.executeQuery("select * from foo3 for update of data");
1:e734b17:         assertFalse(test1.next());
1:e734b17:         commit();
1:e734b17:         assertFalse(test1.next());
1:e734b17:         commit();
1:e734b17:         assertFalse(test1.next());
1:e734b17:         assertFalse(test1.next());
1:e734b17:         assertFalse(test1.next());
1:e734b17:         assertFalse(test1.next());
1:e734b17:         test1.close();
1:e734b17:         commit();
1:e734b17:         try {
1:e734b17:             test1.next();
1:e734b17:             fail("Should be unable to establish cursor!");
1:e734b17:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:e734b17:         
1:e734b17:         commit();
1:e734b17: 	
1:e734b17:         st.close();
1:e734b17:         stUtil.close();
1:e734b17:     }
1:e734b17:     
1:e734b17:     /**
1:e734b17:      * The following tests that no matter where commit comes in the state of
1:e734b17:      * the scan that the scan will continue after the commit.  Tests various
1:e734b17:      * states of scan like: before first next, after first next, before close,
1:e734b17:      * after close.
1:e734b17:      * @throws SQLException 
1:e734b17:      */
1:e734b17:     public void testBasicBtreeScanTestsForMultipleRowsOrUpdateNonkeyField()
1:e734b17:     throws SQLException{ 
1:e734b17:         Statement stUtil = createStatement();
1:e734b17: 
1:e734b17:         stUtil.addBatch("insert into foo4 values (1, 10)");
1:e734b17:         stUtil.addBatch("insert into foo4 values (1, 20)");
1:e734b17:         stUtil.addBatch("insert into foo4 values (1, 30)");
1:e734b17:         stUtil.addBatch("insert into foo4 values (1, 40)");
1:e734b17:         stUtil.addBatch("insert into foo4 values (1, 50)");
1:e734b17:         stUtil.executeBatch();
1:e734b17: 
1:e734b17:         /* the following for update of data cursors
1:e734b17:            will all use group fetch = 1, thus each
1:e734b17:            next passes straight through to store */
1:e734b17:         Statement st = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
1:e734b17:                                        ResultSet.CONCUR_READ_ONLY,
1:e734b17:                                        ResultSet.HOLD_CURSORS_OVER_COMMIT);
1:e734b17: 
1:e734b17:         /* the following for update cursors will all use group fetch = 1,
1:e734b17:            thus each next passes straight through to store. */
1:e734b17:         ResultSet test1 = st.executeQuery("select * from foo4 for update of data");
1:e734b17:         test1.close();
1:e734b17:         commit();
1:e734b17:         try {
1:e734b17:             test1.next();
1:e734b17:             fail("Should be unable to establish cursor!");
1:e734b17:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:e734b17:         
1:e734b17:         test1 = st.executeQuery("select * from foo4 for update of data");
1:e734b17:         commit();
1:e734b17:         test1.close();
1:e734b17:         try {
1:e734b17:             test1.next();
1:e734b17:             fail("Should be unable to establish cursor!");
1:e734b17:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:e734b17:          
1:e734b17:         test1 = st.executeQuery("select * from foo4 for update of data");
1:e734b17:         commit();
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(10,test1.getInt("data"));
1:e734b17:         test1.close();
1:e734b17:         try {
1:e734b17:             test1.next();
1:e734b17:             fail("Should be unable to establish cursor!");
1:e734b17:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:e734b17:         
1:e734b17:         test1 = st.executeQuery("select * from foo4 for update of data");
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(10,test1.getInt("data"));
1:e734b17:         commit();
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(20,test1.getInt("data"));
1:e734b17:         test1.close();
1:e734b17:         try {
1:e734b17:             test1.next();
1:e734b17:             fail("Should be unable to establish cursor!");
1:e734b17:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:e734b17:         
1:e734b17:         test1 = st.executeQuery("select * from foo4 for update of data");
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(10,test1.getInt("data"));
1:e734b17:         commit();
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(20,test1.getInt("data"));
1:e734b17:         commit();
1:e734b17:         test1.close();
1:e734b17:         try {
1:e734b17:             test1.next();
1:e734b17:             fail("Should be unable to establish cursor!");
1:e734b17:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:e734b17:         
1:e734b17:         test1 = st.executeQuery("select * from foo4 for update of data");
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(10,test1.getInt("data"));
1:e734b17:         commit();
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(20,test1.getInt("data"));
1:e734b17:         commit();
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(30,test1.getInt("data"));
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(40,test1.getInt("data"));
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(50,test1.getInt("data"));
1:e734b17:         commit();
1:e734b17:         test1.close();
1:e734b17:         try {
1:e734b17:             test1.next();
1:e734b17:             fail("Should be unable to establish cursor!");
1:e734b17:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:e734b17:         
1:e734b17:         test1 = st.executeQuery("select * from foo4 for update of data");
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(10,test1.getInt("data"));
1:e734b17:         commit();
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(20,test1.getInt("data"));
1:e734b17:         commit();
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(30,test1.getInt("data"));
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(40,test1.getInt("data"));
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(50,test1.getInt("data"));
1:e734b17:         /* beyond the total num. */
1:e734b17:         assertFalse(test1.next());
1:e734b17:         commit();
1:e734b17:         test1.close();
1:e734b17:         try {
1:e734b17:             test1.next();
1:e734b17:             fail("Should be unable to establish cursor!");
1:e734b17:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:e734b17: 
1:e734b17:         test1 = st.executeQuery("select * from foo4 for update of data");
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(10,test1.getInt("data"));
1:e734b17:         commit();
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(20,test1.getInt("data"));
1:e734b17:         commit();
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(30,test1.getInt("data"));
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(40,test1.getInt("data"));
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(50,test1.getInt("data"));
1:e734b17:         assertFalse(test1.next());
1:e734b17:         test1.close();
1:e734b17:         commit();
1:e734b17:         try {
1:e734b17:             test1.next();
1:e734b17:             fail("Should be unable to establish cursor!");
1:e734b17:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:e734b17:         
1:e734b17:         /* test negative case of trying non next operations after commit */
1:e734b17:         test1 = st.executeQuery("select * from foo4 for update of data");
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(10,test1.getInt("data"));
1:e734b17:         commit();
1:e734b17:         try {
1:e734b17:             test1.deleteRow();
1:e734b17:             fail("Should be unable to delete row!");
1:e734b17:         } catch (SQLException e) { assertSQLState("XJ083", e); }
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(20,test1.getInt("data"));
1:e734b17:         commit();
1:e734b17:         try {
1:e734b17:             test1.updateInt("data", -3000);
1:e734b17:             fail("Should be unable to update row!");
1:e734b17:         } catch (SQLException e) { assertSQLState("XJ083", e); }
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(30,test1.getInt("data"));
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(40,test1.getInt("data"));
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(50,test1.getInt("data"));
1:e734b17:         assertFalse(test1.next());
1:e734b17:         test1.close();
1:e734b17:         commit();
1:e734b17:         try {
1:e734b17:             test1.next();
1:e734b17:             fail("Should be unable to establish cursor!");
1:e734b17:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:e734b17: 
1:e734b17:         /* This is a workaround for DERBY-4184 */
1:e734b17:         st = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
1:e734b17:                              ResultSet.CONCUR_UPDATABLE,
1:e734b17:                              ResultSet.HOLD_CURSORS_OVER_COMMIT);
1:e734b17:         /* test positive case of trying delete/update after commit and next. */
1:e734b17: 
1:e734b17:         /* ATTENTION! Add the following ' for update of data' to the query
1:e734b17:          * once DERBY-4198 is fixed! */
1:e734b17:         test1 = st.executeQuery("select * from foo4");
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(10,test1.getInt("data"));
1:e734b17:         commit();
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(20,test1.getInt("data"));
1:e734b17:         test1.deleteRow();
1:e734b17:         commit();
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(30,test1.getInt("data"));
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(40,test1.getInt("data"));
1:e734b17:         test1.updateInt("data", -3000);
1:e734b17:         test1.updateRow();
1:e734b17:         
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(50,test1.getInt("data"));
1:e734b17:         assertFalse(test1.next());
1:e734b17:         test1.close();
1:e734b17:         commit();
1:e734b17:         try {
1:e734b17:             test1.next();
1:e734b17:             fail("Should be unable to establish cursor!");
1:e734b17:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:e734b17:         
1:e734b17:         /* make sure above deletes/updates worked. */
1:e734b17:         test1 = st.executeQuery("select * from foo4 for update of data");
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(10,test1.getInt("data"));
1:e734b17:         commit();
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(30,test1.getInt("data"));
1:e734b17:         commit();
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(-3000,test1.getInt("data"));
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(50,test1.getInt("data"));
1:e734b17:         assertFalse(test1.next());
1:e734b17:         assertFalse(test1.next());
1:e734b17:         test1.close();
1:e734b17:         commit();
1:e734b17:         try {
1:e734b17:             test1.next();
1:e734b17:             fail("Should be unable to establish cursor!");
1:e734b17:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:e734b17:         
1:e734b17:         commit();
1:e734b17:         
1:e734b17:         st.close();	
1:e734b17:         stUtil.close();
1:e734b17:     }    
1:e734b17:     
1:e734b17:     /**
1:e734b17:      * The following tests that no matter where commit comes in the state of
1:e734b17:      * the scan that the scan will continue after the commit.  Tests various
1:e734b17:      * states of scan like: before first next, after first next, before close,
1:e734b17:      * after close.
1:e734b17:      */
1:e734b17:     public void testBasicBtreeScanForZeroRowsReadOnlyNoGroupFetch()
1:e734b17:     throws SQLException{ 
1:e734b17:         Statement stUtil = createStatement();
1:e734b17: 
1:e734b17:         /* the following for read cursors will all use group fetch = 1,
1:e734b17:            thus each next passes straight through to store.
1:e734b17:            This select should only use the
1:e734b17:            index with no interaction with the base table. */
1:e734b17:         Statement st = createStatement(ResultSet.TYPE_FORWARD_ONLY,
1:e734b17:                                        ResultSet.CONCUR_READ_ONLY,
1:e734b17:                                        ResultSet.HOLD_CURSORS_OVER_COMMIT);
1:e734b17: 
1:e734b17:         /* the following for update cursors will all use group fetch = 1,
1:e734b17:            thus each next passes straight through to store. */
1:e734b17:         ResultSet test1 = st.executeQuery("select * from foo5");
1:e734b17:         test1.close();
1:e734b17:         commit();
1:e734b17:         try {
1:e734b17:             test1.next();
1:e734b17:             fail("Should be unable to establish cursor!");
1:e734b17:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:e734b17:         
1:e734b17:         test1 = st.executeQuery("select * from foo5");
1:e734b17:         commit();
1:e734b17:         test1.close();
1:e734b17:         try {
1:e734b17:             test1.next();
1:e734b17:             fail("Should be unable to establish cursor!");
1:e734b17:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:e734b17:          
1:e734b17:         test1 = st.executeQuery("select * from foo5");
1:e734b17:         commit();
1:e734b17:         assertFalse(test1.next());
1:e734b17:         test1.close();
1:e734b17:         try {
1:e734b17:             test1.next();
1:e734b17:             fail("Should be unable to establish cursor!");
1:e734b17:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:e734b17:         
1:e734b17:         test1 = st.executeQuery("select * from foo5");
1:e734b17:         assertFalse(test1.next());
1:e734b17:         commit();     
1:e734b17:         assertFalse(test1.next());
1:e734b17:         test1.close();
1:e734b17:         try {
1:e734b17:             test1.next();
1:e734b17:             fail("Should be unable to establish cursor!");
1:e734b17:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:e734b17:         
1:e734b17:         test1 = st.executeQuery("select * from foo5");
1:e734b17:         assertFalse(test1.next());
1:e734b17:         commit();
1:e734b17:         assertFalse(test1.next());
1:e734b17:         commit();
1:e734b17:         test1.close();
1:e734b17:         try {
1:e734b17:             test1.next();
1:e734b17:             fail("Should be unable to establish cursor!");
1:e734b17:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:e734b17:         
1:e734b17:         test1 = st.executeQuery("select * from foo5");
1:e734b17:         assertFalse(test1.next());
1:e734b17:         commit();
1:e734b17:         assertFalse(test1.next());
1:e734b17:         commit();
1:e734b17:         assertFalse(test1.next());
1:e734b17:         assertFalse(test1.next());
1:e734b17:         assertFalse(test1.next());
1:e734b17:         commit();
1:e734b17:         test1.close();
1:e734b17:         try {
1:e734b17:             test1.next();
1:e734b17:             fail("Should be unable to establish cursor!");
1:e734b17:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:e734b17:         
1:e734b17:         test1 = st.executeQuery("select * from foo5");
1:e734b17:         assertFalse(test1.next());
1:e734b17:         commit();
1:e734b17:         assertFalse(test1.next());
1:e734b17:         commit();
1:e734b17:         assertFalse(test1.next());
1:e734b17:         assertFalse(test1.next());
1:e734b17:         assertFalse(test1.next());
1:e734b17:         assertFalse(test1.next());
1:e734b17:         commit();
1:e734b17:         test1.close();
1:e734b17:         try {
1:e734b17:             test1.next();
1:e734b17:             fail("Should be Should be unable to establish cursor!");
1:e734b17:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:e734b17:         
1:e734b17:         test1 = st.executeQuery("select * from foo5");
1:e734b17:         assertFalse(test1.next());
1:e734b17:         commit();
1:e734b17:         assertFalse(test1.next());
1:e734b17:         commit();
1:e734b17:         assertFalse(test1.next());
1:e734b17:         assertFalse(test1.next());
1:e734b17:         assertFalse(test1.next());
1:e734b17:         assertFalse(test1.next());
1:e734b17:         test1.close();
1:e734b17:         commit();
1:e734b17:         try {
1:e734b17:             test1.next();
1:e734b17:             fail("Should be unable to establish cursor!");
1:e734b17:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:e734b17:         
1:e734b17:         commit();
1:e734b17: 	
1:e734b17:         st.close();
1:e734b17:         stUtil.close();
1:e734b17:     }
1:e734b17:     
1:e734b17:     /**
1:e734b17:      * basic btree scan tests (multiple rows/read only/no group fetch)
1:e734b17:      * The following tests that no matter where commit comes in the state of
1:e734b17:      * the scan that the scan will continue after the commit.  Tests various
1:e734b17:      * states of scan like: before first next, after first next, before close,
1:e734b17:      * after close.
1:e734b17:      */
1:e734b17:     public void testBasicBtreeScanTestsForMultipleRowsOrReadOnly()
1:e734b17:     throws SQLException{ 
1:e734b17:         Statement stUtil = createStatement();
1:e734b17: 
1:e734b17:         stUtil.addBatch("insert into foo6 values (1, 10)");
1:e734b17:         stUtil.addBatch("insert into foo6 values (1, 20)");
1:e734b17:         stUtil.addBatch("insert into foo6 values (1, 30)");
1:e734b17:         stUtil.addBatch("insert into foo6 values (1, 40)");
1:e734b17:         stUtil.addBatch("insert into foo6 values (1, 50)");
1:e734b17:         stUtil.executeBatch();
1:e734b17: 
1:e734b17:         /* the following for read cursors will all use group fetch = 1,
1:e734b17:            thus each next passes straight through to store.
1:e734b17:            This select should only use the
1:e734b17:            index with no interaction with the base table */
1:e734b17:         Statement st = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
1:e734b17:                                        ResultSet.CONCUR_READ_ONLY,
1:e734b17:                                        ResultSet.HOLD_CURSORS_OVER_COMMIT);
1:e734b17: 
1:e734b17:         /* the following for update cursors will all use group fetch = 1,
1:e734b17:            thus each next passes straight through to store. */
1:e734b17:         ResultSet test1 = st.executeQuery("select * from foo6");
1:e734b17:         test1.close();
1:e734b17:         commit();
1:e734b17:         try {
1:e734b17:             test1.next();
1:e734b17:             fail("Should be unable to establish cursor!");
1:e734b17:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:e734b17:         
1:e734b17:         test1 = st.executeQuery("select * from foo6");
1:e734b17:         commit();
1:e734b17:         test1.close();
1:e734b17:         try {
1:e734b17:             test1.next();
1:e734b17:             fail("Should be unable to establish cursor!");
1:e734b17:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:e734b17:          
1:e734b17:         test1 = st.executeQuery("select * from foo6");
1:e734b17:         commit();
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(10,test1.getInt("data"));
1:e734b17:         test1.close();
1:e734b17:         try {
1:e734b17:             test1.next();
1:e734b17:             fail("Should be unable to establish cursor!");
1:e734b17:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:e734b17:         
1:e734b17:         test1 = st.executeQuery("select * from foo6");
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(10,test1.getInt("data"));
1:e734b17:         commit();
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(20,test1.getInt("data"));
1:e734b17:         test1.close();
1:e734b17:         try {
1:e734b17:             test1.next();
1:e734b17:             fail("Should be unable to establish cursor!");
1:e734b17:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:e734b17:         
1:e734b17:         test1 = st.executeQuery("select * from foo6");
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(10,test1.getInt("data"));
1:e734b17:         commit();
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(20,test1.getInt("data"));
1:e734b17:         commit();
1:e734b17:         test1.close();
1:e734b17:         try {
1:e734b17:             test1.next();
1:e734b17:             fail("Should be unable to establish cursor!");
1:e734b17:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:e734b17:         
1:e734b17:         test1 = st.executeQuery("select * from foo6");
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(10,test1.getInt("data"));
1:e734b17:         commit();
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(20,test1.getInt("data"));
1:e734b17:         commit();
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(30,test1.getInt("data"));
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(40,test1.getInt("data"));
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(50,test1.getInt("data"));
1:e734b17:         commit();
1:e734b17:         test1.close();
1:e734b17:         try {
1:e734b17:             test1.next();
1:e734b17:             fail("Should be unable to establish cursor!");
1:e734b17:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:e734b17:         
1:e734b17:         test1 = st.executeQuery("select * from foo6");
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(10,test1.getInt("data"));
1:e734b17:         commit();
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(20,test1.getInt("data"));
1:e734b17:         commit();
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(30,test1.getInt("data"));
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(40,test1.getInt("data"));
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(50,test1.getInt("data"));
1:e734b17:         /* beyond the total num. */
1:e734b17:         assertFalse(test1.next());
1:e734b17:         commit();
1:e734b17:         test1.close();
1:e734b17:         try {
1:e734b17:             test1.next();
1:e734b17:             fail("Should be unable to establish cursor!");
1:e734b17:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:e734b17: 
1:e734b17:         test1 = st.executeQuery("select * from foo6");
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(10,test1.getInt("data"));
1:e734b17:         commit();
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(20,test1.getInt("data"));
1:e734b17:         commit();
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(30,test1.getInt("data"));
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(40,test1.getInt("data"));
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(50,test1.getInt("data"));
1:e734b17:         assertFalse(test1.next());
1:e734b17:         test1.close();
1:e734b17:         commit();
1:e734b17:         try {
1:e734b17:             test1.next();
1:e734b17:             fail("Should be unable to establish cursor!");
1:e734b17:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:e734b17:         
1:e734b17:         commit();
1:e734b17:         
1:e734b17:         st.close();	
1:e734b17:         stUtil.close();
1:e734b17:     }
1:e734b17:     
1:e734b17:     /**
1:e734b17:      * basic tests for cursors with order by 
1:e734b17:      * The following tests that no matter where commit comes in the state of
1:e734b17:      * the scan that the scan will continue after the commit.  Tests various
1:e734b17:      * states of scan like: before first next, after first next, before close,
1:e734b17:      * after close.
1:e734b17:      */
1:e734b17:     public void testOrder() throws SQLException{ 
1:e734b17:         Statement stUtil = createStatement();
1:e734b17: 
1:e734b17:         /* the following for read cursors will all use group fetch = 1,
1:e734b17:            thus each next passes straight through to store.
1:e734b17:            This select should only use the
1:e734b17:            index with no interaction with the base table. */
1:e734b17:         Statement st = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
1:e734b17:                                        ResultSet.CONCUR_READ_ONLY,
1:e734b17:                                        ResultSet.HOLD_CURSORS_OVER_COMMIT);
1:e734b17:         
1:e734b17:         /* the following for update cursors will all use group fetch = 1,
1:e734b17:            thus each next passes straight through to store. */
1:e734b17:         ResultSet test1 = st.executeQuery("select a,data from foo7 order by data desc");
1:e734b17:         test1.close();
1:e734b17:         commit();
1:e734b17:         try {
1:e734b17:             test1.next();
1:e734b17:             fail("Should be unable to establish cursor!");
1:e734b17:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:e734b17:         
1:e734b17:         test1 = st.executeQuery("select a,data from foo7 order by data desc");
1:e734b17:         commit();
1:e734b17:         test1.close();
1:e734b17:         try {
1:e734b17:             test1.next();
1:e734b17:             fail("Should be unable to establish cursor!");
1:e734b17:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:e734b17:          
1:e734b17:         test1 = st.executeQuery("select a,data from foo7 order by data desc");
1:e734b17:         commit();
1:e734b17:         assertFalse(test1.next());
1:e734b17:         test1.close();
1:e734b17:         try {
1:e734b17:             test1.next();
1:e734b17:             fail("Should be Should be unable to establish cursor!");
1:e734b17:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:e734b17:         
1:e734b17:         test1 = st.executeQuery("select a,data from foo7 order by data desc");
1:e734b17:         assertFalse(test1.next());
1:e734b17:         commit();     
1:e734b17:         assertFalse(test1.next());
1:e734b17:         test1.close();
1:e734b17:         try {
1:e734b17:             test1.next();
1:e734b17:             fail("Should be Should be unable to establish cursor!");
1:e734b17:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:e734b17:         
1:e734b17:         test1 = st.executeQuery("select a,data from foo7 order by data desc");
1:e734b17:         assertFalse(test1.next());
1:e734b17:         commit();
1:e734b17:         assertFalse(test1.next());
1:e734b17:         commit();
1:e734b17:         test1.close();
1:e734b17:         try {
1:e734b17:             test1.next();
1:e734b17:             fail("Should be Should be unable to establish cursor!");
1:e734b17:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:e734b17:         
1:e734b17:         test1 = st.executeQuery("select a,data from foo7 order by data desc");
1:e734b17:         assertFalse(test1.next());
1:e734b17:         commit();
1:e734b17:         assertFalse(test1.next());
1:e734b17:         commit();
1:e734b17:         assertFalse(test1.next());
1:e734b17:         assertFalse(test1.next());
1:e734b17:         assertFalse(test1.next());
1:e734b17:         commit();
1:e734b17:         test1.close();
1:e734b17:         try {
1:e734b17:             test1.next();
1:e734b17:             fail("Should be Should be unable to establish cursor!");
1:e734b17:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:e734b17:         
1:e734b17:         test1 = st.executeQuery("select a,data from foo7 order by data desc");
1:e734b17:         assertFalse(test1.next());
1:e734b17:         commit();
1:e734b17:         assertFalse(test1.next());
1:e734b17:         commit();
1:e734b17:         assertFalse(test1.next());
1:e734b17:         assertFalse(test1.next());
1:e734b17:         assertFalse(test1.next());
1:e734b17:         assertFalse(test1.next());
1:e734b17:         commit();
1:e734b17:         test1.close();
1:e734b17:         try {
1:e734b17:             test1.next();
1:e734b17:             fail("Should be Should be unable to establish cursor!");
1:e734b17:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:e734b17:         
1:e734b17:         test1 = st.executeQuery("select a,data from foo7 order by data desc");
1:e734b17:         assertFalse(test1.next());
1:e734b17:         commit();
1:e734b17:         assertFalse(test1.next());
1:e734b17:         commit();
1:e734b17:         assertFalse(test1.next());
1:e734b17:         assertFalse(test1.next());
1:e734b17:         assertFalse(test1.next());
1:e734b17:         assertFalse(test1.next());
1:e734b17:         test1.close();
1:e734b17:         commit();
1:e734b17:         try {
1:e734b17:             test1.next();
1:e734b17:             fail("Should be unable to establish cursor!");
1:e734b17:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:e734b17:         
1:e734b17:         commit();
1:e734b17:         
1:e734b17:         stUtil.addBatch("insert into foo7 values (1, 10)");
1:e734b17:         stUtil.addBatch("insert into foo7 values (1, 20)");
1:e734b17:         stUtil.addBatch("insert into foo7 values (1, 30)");
1:e734b17:         stUtil.addBatch("insert into foo7 values (1, 40)");
1:e734b17:         stUtil.addBatch("insert into foo7 values (1, 50)");
1:e734b17:         stUtil.executeBatch();
1:e734b17: 
1:e734b17:         test1 = st.executeQuery("select a,data from foo7 order by data desc");
1:e734b17:         test1.close();
1:e734b17:         commit();
1:e734b17:         try {
1:e734b17:             test1.next();
1:e734b17:             fail("Should be unable to establish cursor!");
1:e734b17:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:e734b17:         
1:e734b17:         test1 = st.executeQuery("select a,data from foo7 order by data desc");
1:e734b17:         commit();
1:e734b17:         test1.close();
1:e734b17:         try {
1:e734b17:             test1.next();
1:e734b17:             fail("Should be unable to establish cursor!");
1:e734b17:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:e734b17:          
1:e734b17:         test1 = st.executeQuery("select a,data from foo7 order by data desc");
1:e734b17:         commit();
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(50,test1.getInt("data"));
1:e734b17:         test1.close();
1:e734b17:         try {
1:e734b17:             test1.next();
1:e734b17:             fail("Should be unable to establish cursor!");
1:e734b17:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:e734b17:         
1:e734b17:         test1 = st.executeQuery("select a,data from foo7 order by data desc");
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(50,test1.getInt("data"));
1:e734b17:         commit();
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(40,test1.getInt("data"));
1:e734b17:         test1.close();
1:e734b17:         try {
1:e734b17:             test1.next();
1:e734b17:             fail("Should be unable to establish cursor!");
1:e734b17:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:e734b17:         
1:e734b17:         test1 = st.executeQuery("select a,data from foo7 order by data desc");
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(50,test1.getInt("data"));
1:e734b17:         commit();
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(40,test1.getInt("data"));
1:e734b17:         commit();
1:e734b17:         test1.close();
1:e734b17:         try {
1:e734b17:             test1.next();
1:e734b17:             fail("Should be unable to establish cursor!");
1:e734b17:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:e734b17:         
1:e734b17:         test1 = st.executeQuery("select a,data from foo7 order by data desc");
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(50,test1.getInt("data"));
1:e734b17:         commit();
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(40,test1.getInt("data"));
1:e734b17:         commit();
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(30,test1.getInt("data"));
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(20,test1.getInt("data"));
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(10,test1.getInt("data"));
1:e734b17:         commit();
1:e734b17:         test1.close();
1:e734b17:         try {
1:e734b17:             test1.next();
1:e734b17:             fail("Should be unable to establish cursor!");
1:e734b17:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:e734b17:         
1:e734b17:         test1 = st.executeQuery("select a,data from foo7 order by data desc");
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(50,test1.getInt("data"));
1:e734b17:         commit();
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(40,test1.getInt("data"));
1:e734b17:         commit();
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(30,test1.getInt("data"));
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(20,test1.getInt("data"));
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(10,test1.getInt("data"));
1:e734b17:         /* beyond the total num. */
1:e734b17:         assertFalse(test1.next());
1:e734b17:         commit();
1:e734b17:         test1.close();
1:e734b17:         try {
1:e734b17:             test1.next();
1:e734b17:             fail("Should be unable to establish cursor!");
1:e734b17:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:e734b17: 
1:e734b17:         test1 = st.executeQuery("select a,data from foo7 order by data desc");
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(50,test1.getInt("data"));
1:e734b17:         commit();
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(40,test1.getInt("data"));
1:e734b17:         commit();
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(30,test1.getInt("data"));
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(20,test1.getInt("data"));
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("a"));
1:e734b17:         assertEquals(10,test1.getInt("data"));
1:e734b17:         assertFalse(test1.next());
1:e734b17:         test1.close();
1:e734b17:         commit();
1:e734b17:         try {
1:e734b17:             test1.next();
1:e734b17:             fail("Should be unable to establish cursor!");
1:e734b17:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:e734b17:         
1:e734b17:         commit();
1:e734b17:     
1:e734b17:         st.close();
1:e734b17:         stUtil.close();
1:e734b17:     }
1:e734b17:     
1:e734b17:     /**
1:e734b17:      *  test of hold cursor code in DistinctScalarAggregateResultSet.java
1:e734b17:      *  Directed test of hold cursor as applies to sort scans opened by
1:e734b17:      *  DistinctScalarAggregateResultSet.java.
1:e734b17:      */
1:e734b17:     public void testDistinctScalarAggregateResultSet() throws SQLException{ 
1:e734b17:         Statement stUtil = createStatement();
1:e734b17: 
1:e734b17:         stUtil.executeUpdate("insert into t1_8 values (null, null), (1,1), " +
1:e734b17:                              "(null, null), (2,1), (3,1), (10,10)");
1:e734b17:         JDBC.assertFullResultSet(stUtil.executeQuery("select * from t1_8"),
1:e734b17:             new String[][]{
1:e734b17:                     {null, null}, {"1", "1"}, {null, null},
1:e734b17:                     {"2", "1"}, {"3", "1"}, {"10", "10"},
1:e734b17:         });
1:e734b17: 
1:e734b17:         JDBC.assertFullResultSet(
1:e734b17:             stUtil.executeQuery("select sum(distinct c1) from t1_8"),
1:e734b17:             new String[][]{{"16"},}
1:e734b17:         );
1:e734b17: 
1:e734b17:         Statement st = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
1:e734b17:                                        ResultSet.CONCUR_READ_ONLY,
1:e734b17:                                        ResultSet.HOLD_CURSORS_OVER_COMMIT);
1:e734b17: 
1:e734b17:         ResultSet test1 = st.executeQuery("select sum(distinct c1) from t1_8");
1:e734b17:         commit();
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(16,test1.getInt(1));
1:e734b17:         test1.close();
1:e734b17: 
1:e734b17:         test1 = st.executeQuery("select sum(distinct c1) from t1_8");
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(16,test1.getInt(1));
1:e734b17:         commit();
1:e734b17:         assertFalse(test1.next());
1:e734b17:         commit();
1:e734b17:         test1.close();
1:e734b17: 
1:e734b17:         commit();
1:e734b17: 
1:e734b17:         st.close();
1:e734b17:         stUtil.close();
1:e734b17:     }  
1:e734b17:     
1:e734b17:     /**
1:e734b17:      * test of hold cursor code in GroupedAggregateResultSet.java
1:e734b17:      * Directed test of hold cursor as applies to sort scans opened by
1:e734b17:      * GroupedAggregateResultSet.java.
1:e734b17:      */
1:e734b17:     public void testDistinctScalarAggregateResultSetGrouped()
1:e734b17:     throws SQLException{ 
1:e734b17:         Statement stUtil = createStatement();
1:e734b17: 
1:e734b17:         stUtil.executeUpdate("insert into t1_9 values (null, null), (1,1), " +
1:e734b17:                 "(null, null), (2,1), (3,1), (10,10)");
1:e734b17:         JDBC.assertFullResultSet(stUtil.executeQuery("select * from t1_9"),
1:e734b17:             new String[][]{
1:e734b17:                     {null, null}, {"1", "1"}, {null, null},
1:e734b17:                     {"2", "1"}, {"3", "1"}, {"10", "10"},
1:e734b17:         });
1:e734b17: 
1:e734b17:         JDBC.assertFullResultSet(
1:e734b17:             stUtil.executeQuery(
1:e734b17:                 "select sum(distinct c1) from t1_9 group by c2"),
1:e734b17:             new String[][]{
1:e734b17:                     {"6"},
1:e734b17:                     {"10"},
1:e734b17:                     {null},
1:e734b17:                 }
1:e734b17:         );
1:e734b17:         commit();
1:e734b17: 
1:e734b17:         Statement st = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
1:e734b17:                                        ResultSet.CONCUR_READ_ONLY,
1:e734b17:                                        ResultSet.HOLD_CURSORS_OVER_COMMIT);
1:e734b17: 
1:e734b17:         ResultSet test1 = st.executeQuery("select sum(distinct c1) from t1_9 group by c2");
1:e734b17:         commit();
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(6,test1.getInt(1));
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(10,test1.getInt(1));
1:e734b17:         commit();
1:e734b17:         assertTrue(test1.next());
1:e734b17:         test1.getInt(1);
1:e734b17:         assertTrue(test1.wasNull());
1:e734b17:         test1.close();
1:e734b17: 
1:e734b17:         test1 = st.executeQuery("select sum(distinct c1) from t1_9 group by c2");
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(6,test1.getInt(1));
1:e734b17:         commit();
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(10,test1.getInt(1));
1:e734b17:         commit();
1:e734b17:         assertTrue(test1.next());
1:e734b17:         test1.getInt(1);
1:e734b17:         assertTrue(test1.wasNull());
1:e734b17:         test1.close();
1:e734b17: 
1:e734b17:         commit();
1:e734b17: 
1:e734b17:         st.close();
1:e734b17:         stUtil.close();
1:e734b17:     }  
1:e734b17:     
1:e734b17:     /**
1:e734b17:      * test scan positioned on a row which has been purged.
1:e734b17:      */
1:e734b17:     public void testPositionPurgedRow() throws SQLException{
1:e734b17:         Statement stUtil = createStatement();
1:e734b17: 
1:e734b17:         stUtil.executeUpdate("insert into t1_10 values (1, 1), (2, 2), " +
1:e734b17:                              "(3, 3), (4, 4), (5, 5), (6, 6)");
1:e734b17: 
1:e734b17:         Statement st = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
1:e734b17:                                        ResultSet.CONCUR_UPDATABLE,
1:e734b17:                                        ResultSet.HOLD_CURSORS_OVER_COMMIT);
1:e734b17: 
1:e734b17:         ResultSet test1 = st.executeQuery("select c1 from t1_10");
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(1, test1.getInt("c1"));
1:e734b17:         commit();
1:e734b17: 
1:e734b17:         /* at this point the btree scan is positioned by "key" on (1,1).
1:e734b17:            Make sure deleting this key doesn't cause any problems. */
1:e734b17:         assertUpdateCount(stUtil, 2, "delete from t1_10 where c1 = 1 or c1 = 2");
1:e734b17: 
1:e734b17:         /* This IF works around a difference in behaviours between the client
1:e734b17:          * and the embedded drivers. Check DERBY-3839 for comments on this. */
1:e734b17:         if (usingEmbedded()){
1:e734b17:             assertTrue(test1.next());
1:e734b17:             assertEquals(3, test1.getInt("c1"));
1:e734b17: 
1:e734b17:             /* -- at this point the btree scan is positioned on (3, 3),
1:e734b17:                let's see what happens if we delete (3,3) and look at current scan. */
1:e734b17:             assertUpdateCount(stUtil, 1, "delete from t1_10 where c1 = 3");
1:e734b17: 
1:e734b17:             /* position on (4,4) */
1:e734b17:             assertTrue(test1.next());
1:e734b17:             assertEquals(4, test1.getInt("c1"));
1:e734b17: 
1:e734b17:             commit();
1:e734b17: 
1:e734b17:             /* delete all the rows and hopefully get all rows to be purged
1:e734b17:                by the time the scan does the next. */
1:e734b17:             assertUpdateCount(stUtil, 3, "delete from t1_10");
1:e734b17:             commit();
1:e734b17: 
1:e734b17:             assertFalse(test1.next());
1:e734b17:         } else { /* Client has a different behaviour. Maybe a bug! */
1:e734b17:             assertTrue(test1.next());
1:e734b17:             assertEquals(2, test1.getInt("c1"));
1:e734b17: 
1:e734b17:             /* -- at this point the btree scan is positioned on (3, 3),
1:e734b17:                let's see what happens if we delete (3,3) and look at current scan. */
1:e734b17:             assertUpdateCount(stUtil, 1, "delete from t1_10 where c1 = 3");
1:e734b17: 
1:e734b17:             /* position on (4,4) */
1:e734b17:             assertTrue(test1.next());
1:e734b17:             assertEquals(3, test1.getInt("c1"));
1:e734b17: 
1:e734b17:             commit();
1:e734b17: 
1:e734b17:             /* delete all the rows and hopefully get all rows to be purged
1:e734b17:                by the time the scan does the next. */
1:e734b17:             assertUpdateCount(stUtil, 3, "delete from t1_10");
1:e734b17:             commit();
1:e734b17: 
1:e734b17:             /* The records are all still there, even though the above assert
1:e734b17:              * passed with the correct update count */
1:e734b17:             assertTrue(test1.next());
1:e734b17:             assertEquals(4, test1.getInt("c1"));
1:e734b17:             assertTrue(test1.next());
1:e734b17:             assertEquals(5, test1.getInt("c1"));
1:e734b17:             assertTrue(test1.next());
1:e734b17:             assertEquals(6, test1.getInt("c1"));
1:e734b17: 
1:e734b17:             assertFalse(test1.next());
1:e734b17:         }
1:e734b17:         
1:e734b17:         test1.close();
1:e734b17:         stUtil.close();
1:e734b17:     }
1:e734b17:     
1:e734b17:     /**
1:e734b17:      * test scan positioned on a page which has been purged (should really
1:e734b17:      * not be any different than a row being purged).
1:e734b17:      */
1:e734b17:     public void testPositionPurgedPage() throws SQLException{ 
1:e734b17:         /**
1:e734b17:          * rows[0] = 1 with 1000 padding
1:e734b17:          * rows[1] = 2 with 1000 padding
1:e734b17:          * ...
1:e734b17:          */
1:e734b17:         String[] rows = new String[7];
1:e734b17:         for(int i = 1; i <= rows.length; i++){
1:e734b17:             rows[i - 1] = Formatters.padString("" + i, 1000);
1:e734b17:         }
1:e734b17: 
1:e734b17:         Statement stUtil = createStatement();
1:e734b17: 
1:e734b17:         stUtil.executeUpdate("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:e734b17:             "'derby.storage.pageSize', '4096')");
1:e734b17:         stUtil.executeUpdate("create index tx_11 on t1_11 (c1)");
1:e734b17:         stUtil.executeUpdate("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:e734b17:             "'derby.storage.pageSize', Null)");
1:e734b17: 
1:e734b17:         PreparedStatement ps = prepareStatement(
1:e734b17:             "insert into t1_11 values(?,1), (?,2), (?,3), " +
1:e734b17:             "(?,4), (?,5), (?,6), (?,7)");
1:e734b17:         for(int i = 0; i < rows.length; i++){
1:e734b17:             ps.setString(i + 1, rows[i]);
1:e734b17:         }
1:e734b17:         ps.executeUpdate();
1:e734b17:         ps.close();
1:e734b17: 
1:e734b17:         Statement st = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
1:e734b17:                                        ResultSet.CONCUR_READ_ONLY,
1:e734b17:                                        ResultSet.HOLD_CURSORS_OVER_COMMIT);
1:e734b17: 
1:e734b17:         ResultSet test1 = st.executeQuery("select c1 from t1_11");
1:e734b17:         assertTrue(test1.next());
1:e734b17:         assertEquals(rows[0], test1.getString("c1"));
1:e734b17:         commit();
1:e734b17: 
1:e734b17:         /* at this point the btree scan is positioned by "key" on (1,1).
1:e734b17:            Make sure deleting this key doesn't cause any problems. */
1:e734b17:         ps = prepareStatement("delete from t1_11 where c1 = ? or c1 = ?");
1:e734b17:         ps.setString(1, rows[0]);
1:e734b17:         ps.setString(2, rows[1]);
1:e734b17:         assertUpdateCount(ps, 2);
1:e734b17:         ps.close();
1:e734b17: 
1:e734b17:         /* This IF works around a difference in behaviours between the client
1:e734b17:          * and the embedded drivers. Check DERBY-3839 for comments on this. */
1:e734b17:         if (usingEmbedded()) {
1:e734b17:             assertTrue(test1.next());
1:e734b17:             assertEquals(rows[2], test1.getString("c1"));
1:e734b17: 
1:e734b17:             /* -- at this point the btree scan is positioned on (3, 3),
1:e734b17:                let's see what happens if we delete (3,3) and look at current scan. */
1:e734b17:             ps = prepareStatement("delete from t1_11 where c1 = ?");
1:e734b17:             ps.setString(1, rows[2]);
1:e734b17:             assertUpdateCount(ps, 1);
1:e734b17:             ps.close();
1:e734b17: 
1:e734b17:             /* position on (4,4) */
1:e734b17:             assertTrue(test1.next());
1:e734b17:             assertEquals(rows[3], test1.getString("c1"));
1:e734b17: 
1:e734b17:             commit();
1:e734b17: 
1:e734b17:             /* delete all the rows and hopefully get all rows to be purged
1:e734b17:                by the time the scan does the next. */
1:e734b17:             assertUpdateCount(stUtil, 4, "delete from t1_11");
1:e734b17:             commit();
1:e734b17: 
1:e734b17:             assertFalse(test1.next());
1:e734b17:         } else {
1:e734b17:             assertTrue(test1.next());
1:e734b17:             assertEquals(rows[1], test1.getString("c1"));
1:e734b17: 
1:e734b17:             /* -- at this point the btree scan is positioned on (3, 3),
1:e734b17:                let's see what happens if we delete (3,3) and look at current scan. */
1:e734b17:             ps = prepareStatement("delete from t1_11 where c1 = ?");
1:e734b17:             ps.setString(1, rows[2]);
1:e734b17:             assertUpdateCount(ps, 1);
1:e734b17:             ps.close();
1:e734b17: 
1:e734b17:             /* position on (4,4) */
1:e734b17:             assertTrue(test1.next());
1:e734b17:             assertEquals(rows[2], test1.getString("c1"));
1:e734b17: 
1:e734b17:             commit();
1:e734b17: 
1:e734b17:             /* delete all the rows and hopefully get all rows to be purged
1:e734b17:                by the time the scan does the next. */
1:e734b17:             assertUpdateCount(stUtil, 4, "delete from t1_11");
1:e734b17:             commit();
1:e734b17: 
1:e734b17:             /**
1:e734b17:              * The records are all still there, even though the above assert
1:e734b17:              * passed with the correct update count.
1:e734b17:              */
1:e734b17:             assertTrue(test1.next());
1:e734b17:             assertEquals(rows[3], test1.getString("c1"));
1:e734b17:             assertTrue(test1.next());
1:e734b17:             assertEquals(rows[4], test1.getString("c1"));
1:e734b17:             assertTrue(test1.next());
1:e734b17:             assertEquals(rows[5], test1.getString("c1"));
1:e734b17:             assertTrue(test1.next());
1:e734b17:             assertEquals(rows[6], test1.getString("c1"));
1:e734b17: 
1:e734b17:             assertFalse(test1.next());
1:e734b17:         }
1:e734b17: 
1:e734b17:         test1.close();
1:e734b17:         st.close();
1:e734b17:         stUtil.close();
1:e734b17:     }
1:e734b17:     
1:e734b17:     /**
1:e734b17:      * test query plans which use reopenScan() on a btree to 
1:e734b17:      * do the inner table processing of a join.  Prior to the fix a null
1:e734b17:      * pointer exception would be thrown after the commit, as the code
1:e734b17:      * did not handle keeping the resultset used for the inner table
1:e734b17:      * open across commits in this case.
1:e734b17:      */
1:e734b17:     public void testBeetle4902() throws SQLException{ 
1:e734b17:         Statement stUtil = createStatement();
1:e734b17: 
1:e734b17:         stUtil.addBatch("insert into t1_12 values (1, 10), (2, 20), " +
1:e734b17:                         "(3, 30), (4, 40), (5, 50)");
1:e734b17:         stUtil.addBatch("insert into t2_12 values (1, 10), (2, 20), " +
1:e734b17:                         "(4, 40), (5, 50)");
1:e734b17:         stUtil.executeBatch();
1:e734b17:         commit();
1:e734b17: 
1:e734b17:         /* force nestedLoop to make sure reopenScan() is used on inner table. */
1:e734b17:         Statement st = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
1:e734b17:                                        ResultSet.CONCUR_READ_ONLY,
1:e734b17:                                        ResultSet.HOLD_CURSORS_OVER_COMMIT);
1:e734b17:         
1:e734b17:         ResultSet test11 = st.executeQuery("select * from t1_12, t2_12 where t1_12.t1_i1 = t2_12.t2_i1");
1:e734b17: 
1:e734b17:         commit();
1:e734b17:         assertTrue(test11.next());
1:e734b17:         assertEquals(1, test11.getInt("t1_i1"));
1:e734b17:         assertEquals(10, test11.getInt("t1_i2"));
1:e734b17:         assertEquals(1, test11.getInt("t2_i1"));
1:e734b17:         assertEquals(10, test11.getInt("t2_i2"));
1:e734b17:         commit();
1:e734b17:         assertTrue(test11.next());
1:e734b17:         assertEquals(2, test11.getInt("t1_i1"));
1:e734b17:         assertEquals(20, test11.getInt("t1_i2"));
1:e734b17:         assertEquals(2, test11.getInt("t2_i1"));
1:e734b17:         assertEquals(20, test11.getInt("t2_i2"));
1:e734b17:         commit();
1:e734b17:         assertTrue(test11.next());
1:e734b17:         assertEquals(4, test11.getInt("t1_i1"));
1:e734b17:         assertEquals(40, test11.getInt("t1_i2"));
1:e734b17:         assertEquals(4, test11.getInt("t2_i1"));
1:e734b17:         assertEquals(40, test11.getInt("t2_i2"));
1:e734b17:         assertTrue(test11.next());
1:e734b17:         assertEquals(5, test11.getInt("t1_i1"));
1:e734b17:         assertEquals(50, test11.getInt("t1_i2"));
1:e734b17:         assertEquals(5, test11.getInt("t2_i1"));
1:e734b17:         assertEquals(50, test11.getInt("t2_i2"));
1:e734b17:         commit();
1:e734b17:         commit();
1:e734b17:         assertFalse(test11.next());
1:e734b17:         commit();
1:e734b17: 
1:e734b17:         test11.close();
1:e734b17: 
1:e734b17:         st.close();
1:e734b17:         stUtil.close();
1:e734b17:     }
1:e734b17:     
1:e734b17: 
1:e734b17:     /**
1:e734b17:      * test query plans which use reopenScan() on a btree to 
1:e734b17:      * do the inner table processing of a join.  Prior to the fix a null
1:e734b17:      * pointer exception would be thrown after the commit, as the code
1:e734b17:      * did not handle keeping the resultset used for the inner table
1:e734b17:      * open across commits in this case.
1:e734b17:      */
1:e734b17:     public void testBeetle4902WithBulkFetchDefaultSet() throws SQLException{
1:e734b17:         Statement stUtil = createStatement();
1:e734b17: 
1:e734b17:         stUtil.addBatch("insert into t1_13 values (1, 10), (2, 20), " +
1:e734b17:                         "(3, 30), (4, 40), (5, 50)");
1:e734b17:         stUtil.addBatch("insert into t2_13 values (1, 10), (2, 20), " +
1:e734b17:                         "(4, 40), (5, 50)");
1:e734b17:         stUtil.executeBatch();
1:e734b17:         commit();
1:e734b17: 
1:e734b17:         /* force nestedLoop to make sure reopenScan() is used on inner table. */
1:e734b17:         Statement st = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
1:e734b17:                                        ResultSet.CONCUR_READ_ONLY,
1:e734b17:                                        ResultSet.HOLD_CURSORS_OVER_COMMIT);
1:e734b17:         ResultSet test12 = st.executeQuery("select * from t1_13, t2_13 where t1_13.t1_i1 = t2_13.t2_i1");
1:e734b17:         stUtil.executeUpdate("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:e734b17:                              "'derby.language.bulkFetchDefault', '16')");
1:e734b17: 
1:e734b17:         commit();
1:e734b17: 
1:e734b17:         assertTrue(test12.next());
1:e734b17:         assertEquals(1, test12.getInt("t1_i1"));
1:e734b17:         assertEquals(10, test12.getInt("t1_i2"));
1:e734b17:         assertEquals(1, test12.getInt("t2_i1"));
1:e734b17:         assertEquals(10, test12.getInt("t2_i2"));
1:e734b17:         commit();
1:e734b17:         assertTrue(test12.next());
1:e734b17:         assertEquals(2, test12.getInt("t1_i1"));
1:e734b17:         assertEquals(20, test12.getInt("t1_i2"));
1:e734b17:         assertEquals(2, test12.getInt("t2_i1"));
1:e734b17:         assertEquals(20, test12.getInt("t2_i2"));
1:e734b17:         commit();
1:e734b17:         assertTrue(test12.next());
1:e734b17:         assertEquals(4, test12.getInt("t1_i1"));
1:e734b17:         assertEquals(40, test12.getInt("t1_i2"));
1:e734b17:         assertEquals(4, test12.getInt("t2_i1"));
1:e734b17:         assertEquals(40, test12.getInt("t2_i2"));
1:e734b17:         assertTrue(test12.next());
1:e734b17:         assertEquals(5, test12.getInt("t1_i1"));
1:e734b17:         assertEquals(50, test12.getInt("t1_i2"));
1:e734b17:         assertEquals(5, test12.getInt("t2_i1"));
1:e734b17:         assertEquals(50, test12.getInt("t2_i2"));
1:e734b17:         commit();
1:e734b17:         commit();
1:e734b17:         assertFalse(test12.next());
1:e734b17:         commit();
1:e734b17: 
1:e734b17:         test12.close();
1:e734b17: 
1:e734b17:         st.close();
1:e734b17:         stUtil.close();
1:e734b17:     }
1:e734b17: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import junit.framework.Test;
1: import org.apache.derbyTesting.junit.BaseTestSuite;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite("HoldCursorJDBC30Test");
/////////////////////////////////////////////////////////////////////////
1: }
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:e734b17
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * 
1:  * Derby - Class org.apache.derbyTesting.functionTests.tests.store.HoldCursorJDBC30Test
1:  * 
1:  * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
1:  * agreements. See the NOTICE file distributed with this work for additional information
1:  * regarding copyright ownership. The ASF licenses this file to You under the Apache
1:  * License, Version 2.0 (the "License"); you may not use this file except in compliance
1:  * with the License. You may obtain a copy of the License at
1:  * 
1:  * http://www.apache.org/licenses/LICENSE-2.0
1:  * 
1:  * Unless required by applicable law or agreed to in writing, software distributed under
1:  * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied. See the License for the specific language governing
1:  * permissions and limitations under the License.
1:  * 
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.tests.store;
1: 
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: import java.sql.Statement;
1: 
1: import org.apache.derbyTesting.functionTests.util.Formatters;
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1: import org.apache.derbyTesting.junit.JDBC;
1: import org.apache.derbyTesting.junit.TestConfiguration;
1: 
0: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: 
1: public final class HoldCursorJDBC30Test extends BaseJDBCTestCase {
1: 
1:     /**
1:      * Public constructor required for running test as standalone JUnit.
1:      */
1:     public HoldCursorJDBC30Test(String name) {
1:         super(name);
1:     }
1: 
1:     /**
1:      * This will allow us to decorate the test for each driver separately
1:      */
1:     private static Test decorateTest(Test test) {
1:         return new CleanDatabaseTestSetup(test){
1:             protected void decorateSQL(Statement s)
1:             throws SQLException {
1:                 /* getConnection().setAutoCommit(false); */
1: 
1:                 /* testBasicHeapScanZeroRows */
1:                 s.execute("create table foo1 (a int, data int)");
1: 
1:                 /* testBasicHeapScanMultiRows */
1:                 s.execute("create table foo2 (a int, data int)");
1: 
1:                 /* testBasicBtreeScanForZeroRowsUpdateNonkeyfield */
1:                 s.execute("create table foo3 (a int, data int)");
1:                 s.execute("create index foox_3 on foo3 (a)");
1: 
1:                 /* testBasicBtreeScanTestsForMultipleRowsOrUpdateNonkeyField */
1:                 s.execute("create table foo4 (a int, data int)");
1: 
1:                 /* testBasicBtreeScanForZeroRowsReadOnlyNoGroupFetch */
1:                 s.execute("create table foo5 (a int, data int)");
1:                 s.execute("create index foox_5 on foo5 (a)");
1: 
1:                 /* testBasicBtreeScanTestsForMultipleRowsOrReadOnly */
1:                 s.execute("create table foo6 (a int, data int)");
1: 
1:                 /* testOrder */
1:                 s.execute("create table foo7 (a int, data int)");
1:                 s.execute("create index foox_7 on foo7 (a)");
1: 
1:                 /* testDistinctScalarAggregateResultSet */
1:                 s.execute("create table t1_8 (c1 int, c2 int)");
1: 
1:                 /* testDistinctScalarAggregateResultSetGrouped */
1:                 s.execute("create table t1_9 (c1 int, c2 int)");
1: 
1:                 /* testPositionPurgedRow */
1:                 s.execute("create table t1_10 (c1 int, c2 int)");
1:                 s.execute("create index tx_10 on t1_10 (c1)");
1: 
1:                 /* testPositionPurgedPage - Index created on test here */
1:                 s.execute("create table t1_11 (c1 varchar(1000), c2 int)");
1: 
1:                 /* testBeetle4902 */
1:                 s.execute("create table t1_12 (t1_i1 int, t1_i2 int)");
1:                 s.execute("create table t2_12 (t2_i1 int, t2_i2 int)");
1:                 s.execute("create index t1_idx_12 on t1_12 (t1_i1)");
1:                 s.execute("create index t2_idx_12 on t2_12 (t2_i1)");
1: 
1:                 /* testBeetle4902WithBulkFetchDefaultSet */
1:                 s.execute("create table t1_13 (t1_i1 int, t1_i2 int)");
1:                 s.execute("create table t2_13 (t2_i1 int, t2_i2 int)");
1:                 s.execute("create index t1_idx_13 on t1_13 (t1_i1)");
1:                 s.execute("create index t2_idx_13 on t2_13 (t2_i1)");
1:             }
1:         };
1:     }
1: 
1:     public static Test suite() {
0:         TestSuite suite = new TestSuite("HoldCursorJDBC30Test");
1:         suite.addTest(decorateTest(TestConfiguration.embeddedSuite(HoldCursorJDBC30Test.class)));
1:         suite.addTest(decorateTest(TestConfiguration.clientServerSuite(HoldCursorJDBC30Test.class)));
1:         
1:         return suite;
1:     }
1:        
1:     /**
1:      * Disabling auto-commit for all tests
1:      * @throws java.sql.SQLException
1:      */
1:     protected void setUp() throws SQLException {
1:         setAutoCommit(false);
1:         createStatement().execute("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:                              "'derby.language.bulkFetchDefault', '1')");
1:     }
1: 
1:     /**
1:      * The following tests that no matter where commit comes in the state of
1:      * the scan that the scan will continue after the commit.  Tests various
1:      * states of scan like: before first next, after first next, before close,
1:      * after close.
1:      */
1:     public void testBasicHeapScanZeroRows() throws SQLException{ 
1:         Statement stUtil = createStatement();
1:                 
1:         Statement st = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
1:                                        ResultSet.CONCUR_READ_ONLY,
1:                                        ResultSet.HOLD_CURSORS_OVER_COMMIT);
1: 
1:         ResultSet test1 = st.executeQuery("select * from foo1");
1:         test1.close();
1:         commit();
1:         try {
1:             test1.next();
1:             fail("Should be unable to establish cursor!");
1:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:        
1:         test1 = st.executeQuery("select * from foo1 for update");
1:         commit();
1:         test1.close();
1:         try {
1:             test1.next();
1:             fail("Should be unable to establish cursor!");
1:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:          
1:         test1 = st.executeQuery("select * from foo1 for update");
1:         commit();
1:         assertFalse(test1.next());
1:         test1.close();
1:         try {
1:             test1.next();
1:             fail("Should be unable to establish cursor!");
1:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:         
1:         test1 = st.executeQuery("select * from foo1 for update");
1:         assertFalse(test1.next());
1:         commit();     
1:         assertFalse(test1.next());
1:         test1.close();
1:         try {
1:             test1.next();
1:             fail("Should be unable to establish cursor!");
1:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:         
1:         test1 = st.executeQuery("select * from foo1 for update");
1:         assertFalse(test1.next());
1:         commit();
1:         assertFalse(test1.next());
1:         commit();
1:         test1.close();
1:         try {
1:             test1.next();
1:             fail("Should be unable to establish cursor!");
1:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:         
1:         test1 = st.executeQuery("select * from foo1 for update");
1:         assertFalse(test1.next());
1:         commit();
1:         assertFalse(test1.next());
1:         commit();
1:         assertFalse(test1.next());
1:         assertFalse(test1.next());
1:         assertFalse(test1.next());
1:         commit();
1:         test1.close();
1:         try {
1:             test1.next();
1:             fail("Should be unable to establish cursor!");
1:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:         
1:         test1 = st.executeQuery("select * from foo1 for update");
1:         assertFalse(test1.next());
1:         commit();
1:         assertFalse(test1.next());
1:         commit();
1:         assertFalse(test1.next());
1:         assertFalse(test1.next());
1:         assertFalse(test1.next());
1:         assertFalse(test1.next());
1:         commit();
1:         test1.close();
1:         try {
1:             test1.next();
1:             fail("Should be unable to establish cursor!");
1:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:         
1:         test1 = st.executeQuery("select * from foo1");
1:         assertFalse(test1.next());
1:         commit();
1:         assertFalse(test1.next());
1:         commit();
1:         assertFalse(test1.next());
1:         assertFalse(test1.next());
1:         assertFalse(test1.next());
1:         assertFalse(test1.next());
1:         test1.close();
1:         commit();
1:         try {
1:             test1.next();
1:             fail("Should be unable to establish cursor!");
1:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:         
1:         commit();
1:         
1:         st.close();
1:         stUtil.close();
1:     }
1:     
1:     /**
1:      * The following tests that no matter where commit comes in the state of 
1:      * the scan that the scan will continue after the commit. 
1:      * Tests various states of scan like: before first next, 
1:      * after first next, before close,after close.
1:      */
1:     public void testBasicHeapScanMultiRows() throws SQLException{ 
1:         Statement stUtil = createStatement();
1: 
1:         stUtil.addBatch("insert into foo2 values (1, 10)");
1:         stUtil.addBatch("insert into foo2 values (1, 20)");
1:         stUtil.addBatch("insert into foo2 values (1, 30)");
1:         stUtil.addBatch("insert into foo2 values (1, 40)");
1:         stUtil.addBatch("insert into foo2 values (1, 50)");
1:         stUtil.executeBatch();
1: 
1:         Statement st = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
1:                                        ResultSet.CONCUR_READ_ONLY,
1:                                        ResultSet.HOLD_CURSORS_OVER_COMMIT);
1:         
1:         /*the following for update cursors will all use group fetch = 1,
1:          thus each next passes straight through to store. */
1:         ResultSet test1 = st.executeQuery("select * from foo2 for update");
1:         test1.close();
1:         commit();
1:         try {
1:             test1.next();
1:             fail("Should be unable to establish cursor!");
1:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:         
1:         test1 = st.executeQuery("select * from foo2 for update");
1:         commit();
1:         test1.close();
1:         try {
1:             test1.next();
1:             fail("Should be unable to establish cursor!");
1:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:          
1:         test1 = st.executeQuery("select * from foo2 for update");
1:         commit();
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(10,test1.getInt("data"));
1:         test1.close();
1:         try {
1:             test1.next();
1:             fail("Should be unable to establish cursor!");
1:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:         
1:         test1 = st.executeQuery("select * from foo2 for update");
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(10,test1.getInt("data"));
1:         commit();
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(20,test1.getInt("data"));
1:         test1.close();
1:         try {
1:             test1.next();
1:             fail("Should be unable to establish cursor!");
1:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:         
1:         test1 = st.executeQuery("select * from foo2 for update");
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(10,test1.getInt("data"));
1:         commit();
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(20,test1.getInt("data"));
1:         commit();
1:         test1.close();
1:         try {
1:             test1.next();
1:             fail("Should be unable to establish cursor!");
1:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:         
1:         test1 = st.executeQuery("select * from foo2 for update");
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(10,test1.getInt("data"));
1:         commit();
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(20,test1.getInt("data"));
1:         commit();
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(30,test1.getInt("data"));
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(40,test1.getInt("data"));
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(50,test1.getInt("data"));
1:         commit();
1:         test1.close();
1:         try {
1:             test1.next();
1:             fail("Should be unable to establish cursor!");
1:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:         
1:         test1 = st.executeQuery("select * from foo2 for update");
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(10,test1.getInt("data"));
1:         commit();
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(20,test1.getInt("data"));
1:         commit();
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(30,test1.getInt("data"));
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(40,test1.getInt("data"));
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(50,test1.getInt("data"));
1:         /* beyond the total num. */
1:         assertFalse(test1.next());
1:         commit();
1:         test1.close();
1:         try {
1:             test1.next();
1:             fail("Should be unable to establish cursor!");
1:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:         
1: 
1:         test1 = st.executeQuery("select * from foo2 for update");
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(10,test1.getInt("data"));
1:         commit();
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(20,test1.getInt("data"));
1:         commit();
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(30,test1.getInt("data"));
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(40,test1.getInt("data"));
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(50,test1.getInt("data"));
1:         assertFalse(test1.next());
1:         test1.close();
1:         commit();
1:         try {
1:             test1.next();
1:             fail("Should be unable to establish cursor!");
1:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:         
1:         commit();
1:         
1:         st.close();
1:         stUtil.close();
1:     }   
1:     
1:     /**
1:      *  basic btree scan tests (zero rows/update nonkey field)
1:      *  The following tests that no matter where commit comes in the state of
1:      *  the scan that the scan will continue after the commit.  Tests various
1:      *  states of scan like: before first next, after first next, before close,
1:      *  after close.
1:      */
1:     public void testBasicBtreeScanForZeroRowsUpdateNonkeyfield() throws SQLException{ 
1:         Statement stUtil = createStatement();
1: 
1:         Statement st = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
1:                                        ResultSet.CONCUR_READ_ONLY,
1:                                        ResultSet.HOLD_CURSORS_OVER_COMMIT);
1:         
1:         /* the following for update cursors will all use group fetch = 1,
1:            thus each next passes straight through to store. */
1:         ResultSet test1 = st.executeQuery("select * from foo3 for update of data");
1:         test1.close();
1:         commit();
1:         try {
1:             test1.next();
1:             fail("Should be unable to establish cursor!");
1:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:         
1:         test1 = st.executeQuery("select * from foo3 for update of data");
1:         commit();
1:         test1.close();
1:         try {
1:             test1.next();
1:             fail("Should be unable to establish cursor!");
1:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:          
1:         test1 = st.executeQuery("select * from foo3 for update of data");
1:         commit();
1:         assertFalse(test1.next());
1:         test1.close();
1:         try {
1:             test1.next();
1:             fail("Should be Should be unable to establish cursor!");
1:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:         
1:         test1 = st.executeQuery("select * from foo3 for update of data");
1:         assertFalse(test1.next());
1:         commit();     
1:         assertFalse(test1.next());
1:         test1.close();
1:         try {
1:             test1.next();
1:             fail("Should be Should be unable to establish cursor!");
1:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:         
1:         test1 = st.executeQuery("select * from foo3 for update of data");
1:         assertFalse(test1.next());
1:         commit();
1:         assertFalse(test1.next());
1:         commit();
1:         test1.close();
1:         try {
1:             test1.next();
1:             fail("Should be Should be unable to establish cursor!");
1:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:         
1:         test1 = st.executeQuery("select * from foo3 for update of data");
1:         assertFalse(test1.next());
1:         commit();
1:         assertFalse(test1.next());
1:         commit();
1:         assertFalse(test1.next());
1:         assertFalse(test1.next());
1:         assertFalse(test1.next());
1:         commit();
1:         test1.close();
1:         try {
1:             test1.next();
1:             fail("Should be Should be unable to establish cursor!");
1:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:         
1:         test1 = st.executeQuery("select * from foo3 for update of data");
1:         assertFalse(test1.next());
1:         commit();
1:         assertFalse(test1.next());
1:         commit();
1:         assertFalse(test1.next());
1:         assertFalse(test1.next());
1:         assertFalse(test1.next());
1:         assertFalse(test1.next());
1:         commit();
1:         test1.close();
1:         try {
1:             test1.next();
1:             fail("Should be Should be unable to establish cursor!");
1:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:         
1:         test1 = st.executeQuery("select * from foo3 for update of data");
1:         assertFalse(test1.next());
1:         commit();
1:         assertFalse(test1.next());
1:         commit();
1:         assertFalse(test1.next());
1:         assertFalse(test1.next());
1:         assertFalse(test1.next());
1:         assertFalse(test1.next());
1:         test1.close();
1:         commit();
1:         try {
1:             test1.next();
1:             fail("Should be unable to establish cursor!");
1:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:         
1:         commit();
1: 	
1:         st.close();
1:         stUtil.close();
1:     }
1:     
1:     /**
1:      * The following tests that no matter where commit comes in the state of
1:      * the scan that the scan will continue after the commit.  Tests various
1:      * states of scan like: before first next, after first next, before close,
1:      * after close.
1:      * @throws SQLException 
1:      */
1:     public void testBasicBtreeScanTestsForMultipleRowsOrUpdateNonkeyField()
1:     throws SQLException{ 
1:         Statement stUtil = createStatement();
1: 
1:         stUtil.addBatch("insert into foo4 values (1, 10)");
1:         stUtil.addBatch("insert into foo4 values (1, 20)");
1:         stUtil.addBatch("insert into foo4 values (1, 30)");
1:         stUtil.addBatch("insert into foo4 values (1, 40)");
1:         stUtil.addBatch("insert into foo4 values (1, 50)");
1:         stUtil.executeBatch();
1: 
1:         /* the following for update of data cursors
1:            will all use group fetch = 1, thus each
1:            next passes straight through to store */
1:         Statement st = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
1:                                        ResultSet.CONCUR_READ_ONLY,
1:                                        ResultSet.HOLD_CURSORS_OVER_COMMIT);
1: 
1:         /* the following for update cursors will all use group fetch = 1,
1:            thus each next passes straight through to store. */
1:         ResultSet test1 = st.executeQuery("select * from foo4 for update of data");
1:         test1.close();
1:         commit();
1:         try {
1:             test1.next();
1:             fail("Should be unable to establish cursor!");
1:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:         
1:         test1 = st.executeQuery("select * from foo4 for update of data");
1:         commit();
1:         test1.close();
1:         try {
1:             test1.next();
1:             fail("Should be unable to establish cursor!");
1:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:          
1:         test1 = st.executeQuery("select * from foo4 for update of data");
1:         commit();
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(10,test1.getInt("data"));
1:         test1.close();
1:         try {
1:             test1.next();
1:             fail("Should be unable to establish cursor!");
1:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:         
1:         test1 = st.executeQuery("select * from foo4 for update of data");
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(10,test1.getInt("data"));
1:         commit();
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(20,test1.getInt("data"));
1:         test1.close();
1:         try {
1:             test1.next();
1:             fail("Should be unable to establish cursor!");
1:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:         
1:         test1 = st.executeQuery("select * from foo4 for update of data");
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(10,test1.getInt("data"));
1:         commit();
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(20,test1.getInt("data"));
1:         commit();
1:         test1.close();
1:         try {
1:             test1.next();
1:             fail("Should be unable to establish cursor!");
1:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:         
1:         test1 = st.executeQuery("select * from foo4 for update of data");
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(10,test1.getInt("data"));
1:         commit();
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(20,test1.getInt("data"));
1:         commit();
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(30,test1.getInt("data"));
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(40,test1.getInt("data"));
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(50,test1.getInt("data"));
1:         commit();
1:         test1.close();
1:         try {
1:             test1.next();
1:             fail("Should be unable to establish cursor!");
1:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:         
1:         test1 = st.executeQuery("select * from foo4 for update of data");
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(10,test1.getInt("data"));
1:         commit();
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(20,test1.getInt("data"));
1:         commit();
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(30,test1.getInt("data"));
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(40,test1.getInt("data"));
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(50,test1.getInt("data"));
1:         /* beyond the total num. */
1:         assertFalse(test1.next());
1:         commit();
1:         test1.close();
1:         try {
1:             test1.next();
1:             fail("Should be unable to establish cursor!");
1:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1: 
1:         test1 = st.executeQuery("select * from foo4 for update of data");
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(10,test1.getInt("data"));
1:         commit();
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(20,test1.getInt("data"));
1:         commit();
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(30,test1.getInt("data"));
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(40,test1.getInt("data"));
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(50,test1.getInt("data"));
1:         assertFalse(test1.next());
1:         test1.close();
1:         commit();
1:         try {
1:             test1.next();
1:             fail("Should be unable to establish cursor!");
1:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:         
1:         /* test negative case of trying non next operations after commit */
1:         test1 = st.executeQuery("select * from foo4 for update of data");
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(10,test1.getInt("data"));
1:         commit();
1:         try {
1:             test1.deleteRow();
1:             fail("Should be unable to delete row!");
1:         } catch (SQLException e) { assertSQLState("XJ083", e); }
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(20,test1.getInt("data"));
1:         commit();
1:         try {
1:             test1.updateInt("data", -3000);
1:             fail("Should be unable to update row!");
1:         } catch (SQLException e) { assertSQLState("XJ083", e); }
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(30,test1.getInt("data"));
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(40,test1.getInt("data"));
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(50,test1.getInt("data"));
1:         assertFalse(test1.next());
1:         test1.close();
1:         commit();
1:         try {
1:             test1.next();
1:             fail("Should be unable to establish cursor!");
1:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1: 
1:         /* This is a workaround for DERBY-4184 */
1:         st = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
1:                              ResultSet.CONCUR_UPDATABLE,
1:                              ResultSet.HOLD_CURSORS_OVER_COMMIT);
1:         /* test positive case of trying delete/update after commit and next. */
1: 
1:         /* ATTENTION! Add the following ' for update of data' to the query
1:          * once DERBY-4198 is fixed! */
1:         test1 = st.executeQuery("select * from foo4");
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(10,test1.getInt("data"));
1:         commit();
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(20,test1.getInt("data"));
1:         test1.deleteRow();
1:         commit();
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(30,test1.getInt("data"));
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(40,test1.getInt("data"));
1:         test1.updateInt("data", -3000);
1:         test1.updateRow();
1:         
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(50,test1.getInt("data"));
1:         assertFalse(test1.next());
1:         test1.close();
1:         commit();
1:         try {
1:             test1.next();
1:             fail("Should be unable to establish cursor!");
1:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:         
1:         /* make sure above deletes/updates worked. */
1:         test1 = st.executeQuery("select * from foo4 for update of data");
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(10,test1.getInt("data"));
1:         commit();
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(30,test1.getInt("data"));
1:         commit();
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(-3000,test1.getInt("data"));
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(50,test1.getInt("data"));
1:         assertFalse(test1.next());
1:         assertFalse(test1.next());
1:         test1.close();
1:         commit();
1:         try {
1:             test1.next();
1:             fail("Should be unable to establish cursor!");
1:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:         
1:         commit();
1:         
1:         st.close();	
1:         stUtil.close();
1:     }    
1:     
1:     /**
1:      * The following tests that no matter where commit comes in the state of
1:      * the scan that the scan will continue after the commit.  Tests various
1:      * states of scan like: before first next, after first next, before close,
1:      * after close.
1:      */
1:     public void testBasicBtreeScanForZeroRowsReadOnlyNoGroupFetch()
1:     throws SQLException{ 
1:         Statement stUtil = createStatement();
1: 
1:         /* the following for read cursors will all use group fetch = 1,
1:            thus each next passes straight through to store.
1:            This select should only use the
1:            index with no interaction with the base table. */
1:         Statement st = createStatement(ResultSet.TYPE_FORWARD_ONLY,
1:                                        ResultSet.CONCUR_READ_ONLY,
1:                                        ResultSet.HOLD_CURSORS_OVER_COMMIT);
1: 
1:         /* the following for update cursors will all use group fetch = 1,
1:            thus each next passes straight through to store. */
1:         ResultSet test1 = st.executeQuery("select * from foo5");
1:         test1.close();
1:         commit();
1:         try {
1:             test1.next();
1:             fail("Should be unable to establish cursor!");
1:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:         
1:         test1 = st.executeQuery("select * from foo5");
1:         commit();
1:         test1.close();
1:         try {
1:             test1.next();
1:             fail("Should be unable to establish cursor!");
1:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:          
1:         test1 = st.executeQuery("select * from foo5");
1:         commit();
1:         assertFalse(test1.next());
1:         test1.close();
1:         try {
1:             test1.next();
1:             fail("Should be unable to establish cursor!");
1:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:         
1:         test1 = st.executeQuery("select * from foo5");
1:         assertFalse(test1.next());
1:         commit();     
1:         assertFalse(test1.next());
1:         test1.close();
1:         try {
1:             test1.next();
1:             fail("Should be unable to establish cursor!");
1:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:         
1:         test1 = st.executeQuery("select * from foo5");
1:         assertFalse(test1.next());
1:         commit();
1:         assertFalse(test1.next());
1:         commit();
1:         test1.close();
1:         try {
1:             test1.next();
1:             fail("Should be unable to establish cursor!");
1:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:         
1:         test1 = st.executeQuery("select * from foo5");
1:         assertFalse(test1.next());
1:         commit();
1:         assertFalse(test1.next());
1:         commit();
1:         assertFalse(test1.next());
1:         assertFalse(test1.next());
1:         assertFalse(test1.next());
1:         commit();
1:         test1.close();
1:         try {
1:             test1.next();
1:             fail("Should be unable to establish cursor!");
1:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:         
1:         test1 = st.executeQuery("select * from foo5");
1:         assertFalse(test1.next());
1:         commit();
1:         assertFalse(test1.next());
1:         commit();
1:         assertFalse(test1.next());
1:         assertFalse(test1.next());
1:         assertFalse(test1.next());
1:         assertFalse(test1.next());
1:         commit();
1:         test1.close();
1:         try {
1:             test1.next();
1:             fail("Should be Should be unable to establish cursor!");
1:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:         
1:         test1 = st.executeQuery("select * from foo5");
1:         assertFalse(test1.next());
1:         commit();
1:         assertFalse(test1.next());
1:         commit();
1:         assertFalse(test1.next());
1:         assertFalse(test1.next());
1:         assertFalse(test1.next());
1:         assertFalse(test1.next());
1:         test1.close();
1:         commit();
1:         try {
1:             test1.next();
1:             fail("Should be unable to establish cursor!");
1:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:         
1:         commit();
1: 	
1:         st.close();
1:         stUtil.close();
1:     }
1:     
1:     /**
1:      * basic btree scan tests (multiple rows/read only/no group fetch)
1:      * The following tests that no matter where commit comes in the state of
1:      * the scan that the scan will continue after the commit.  Tests various
1:      * states of scan like: before first next, after first next, before close,
1:      * after close.
1:      */
1:     public void testBasicBtreeScanTestsForMultipleRowsOrReadOnly()
1:     throws SQLException{ 
1:         Statement stUtil = createStatement();
1: 
1:         stUtil.addBatch("insert into foo6 values (1, 10)");
1:         stUtil.addBatch("insert into foo6 values (1, 20)");
1:         stUtil.addBatch("insert into foo6 values (1, 30)");
1:         stUtil.addBatch("insert into foo6 values (1, 40)");
1:         stUtil.addBatch("insert into foo6 values (1, 50)");
1:         stUtil.executeBatch();
1: 
1:         /* the following for read cursors will all use group fetch = 1,
1:            thus each next passes straight through to store.
1:            This select should only use the
1:            index with no interaction with the base table */
1:         Statement st = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
1:                                        ResultSet.CONCUR_READ_ONLY,
1:                                        ResultSet.HOLD_CURSORS_OVER_COMMIT);
1: 
1:         /* the following for update cursors will all use group fetch = 1,
1:            thus each next passes straight through to store. */
1:         ResultSet test1 = st.executeQuery("select * from foo6");
1:         test1.close();
1:         commit();
1:         try {
1:             test1.next();
1:             fail("Should be unable to establish cursor!");
1:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:         
1:         test1 = st.executeQuery("select * from foo6");
1:         commit();
1:         test1.close();
1:         try {
1:             test1.next();
1:             fail("Should be unable to establish cursor!");
1:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:          
1:         test1 = st.executeQuery("select * from foo6");
1:         commit();
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(10,test1.getInt("data"));
1:         test1.close();
1:         try {
1:             test1.next();
1:             fail("Should be unable to establish cursor!");
1:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:         
1:         test1 = st.executeQuery("select * from foo6");
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(10,test1.getInt("data"));
1:         commit();
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(20,test1.getInt("data"));
1:         test1.close();
1:         try {
1:             test1.next();
1:             fail("Should be unable to establish cursor!");
1:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:         
1:         test1 = st.executeQuery("select * from foo6");
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(10,test1.getInt("data"));
1:         commit();
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(20,test1.getInt("data"));
1:         commit();
1:         test1.close();
1:         try {
1:             test1.next();
1:             fail("Should be unable to establish cursor!");
1:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:         
1:         test1 = st.executeQuery("select * from foo6");
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(10,test1.getInt("data"));
1:         commit();
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(20,test1.getInt("data"));
1:         commit();
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(30,test1.getInt("data"));
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(40,test1.getInt("data"));
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(50,test1.getInt("data"));
1:         commit();
1:         test1.close();
1:         try {
1:             test1.next();
1:             fail("Should be unable to establish cursor!");
1:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:         
1:         test1 = st.executeQuery("select * from foo6");
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(10,test1.getInt("data"));
1:         commit();
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(20,test1.getInt("data"));
1:         commit();
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(30,test1.getInt("data"));
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(40,test1.getInt("data"));
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(50,test1.getInt("data"));
1:         /* beyond the total num. */
1:         assertFalse(test1.next());
1:         commit();
1:         test1.close();
1:         try {
1:             test1.next();
1:             fail("Should be unable to establish cursor!");
1:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1: 
1:         test1 = st.executeQuery("select * from foo6");
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(10,test1.getInt("data"));
1:         commit();
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(20,test1.getInt("data"));
1:         commit();
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(30,test1.getInt("data"));
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(40,test1.getInt("data"));
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(50,test1.getInt("data"));
1:         assertFalse(test1.next());
1:         test1.close();
1:         commit();
1:         try {
1:             test1.next();
1:             fail("Should be unable to establish cursor!");
1:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:         
1:         commit();
1:         
1:         st.close();	
1:         stUtil.close();
1:     }
1:     
1:     /**
1:      * basic tests for cursors with order by 
1:      * The following tests that no matter where commit comes in the state of
1:      * the scan that the scan will continue after the commit.  Tests various
1:      * states of scan like: before first next, after first next, before close,
1:      * after close.
1:      */
1:     public void testOrder() throws SQLException{ 
1:         Statement stUtil = createStatement();
1: 
1:         /* the following for read cursors will all use group fetch = 1,
1:            thus each next passes straight through to store.
1:            This select should only use the
1:            index with no interaction with the base table. */
1:         Statement st = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
1:                                        ResultSet.CONCUR_READ_ONLY,
1:                                        ResultSet.HOLD_CURSORS_OVER_COMMIT);
1:         
1:         /* the following for update cursors will all use group fetch = 1,
1:            thus each next passes straight through to store. */
1:         ResultSet test1 = st.executeQuery("select a,data from foo7 order by data desc");
1:         test1.close();
1:         commit();
1:         try {
1:             test1.next();
1:             fail("Should be unable to establish cursor!");
1:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:         
1:         test1 = st.executeQuery("select a,data from foo7 order by data desc");
1:         commit();
1:         test1.close();
1:         try {
1:             test1.next();
1:             fail("Should be unable to establish cursor!");
1:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:          
1:         test1 = st.executeQuery("select a,data from foo7 order by data desc");
1:         commit();
1:         assertFalse(test1.next());
1:         test1.close();
1:         try {
1:             test1.next();
1:             fail("Should be Should be unable to establish cursor!");
1:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:         
1:         test1 = st.executeQuery("select a,data from foo7 order by data desc");
1:         assertFalse(test1.next());
1:         commit();     
1:         assertFalse(test1.next());
1:         test1.close();
1:         try {
1:             test1.next();
1:             fail("Should be Should be unable to establish cursor!");
1:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:         
1:         test1 = st.executeQuery("select a,data from foo7 order by data desc");
1:         assertFalse(test1.next());
1:         commit();
1:         assertFalse(test1.next());
1:         commit();
1:         test1.close();
1:         try {
1:             test1.next();
1:             fail("Should be Should be unable to establish cursor!");
1:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:         
1:         test1 = st.executeQuery("select a,data from foo7 order by data desc");
1:         assertFalse(test1.next());
1:         commit();
1:         assertFalse(test1.next());
1:         commit();
1:         assertFalse(test1.next());
1:         assertFalse(test1.next());
1:         assertFalse(test1.next());
1:         commit();
1:         test1.close();
1:         try {
1:             test1.next();
1:             fail("Should be Should be unable to establish cursor!");
1:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:         
1:         test1 = st.executeQuery("select a,data from foo7 order by data desc");
1:         assertFalse(test1.next());
1:         commit();
1:         assertFalse(test1.next());
1:         commit();
1:         assertFalse(test1.next());
1:         assertFalse(test1.next());
1:         assertFalse(test1.next());
1:         assertFalse(test1.next());
1:         commit();
1:         test1.close();
1:         try {
1:             test1.next();
1:             fail("Should be Should be unable to establish cursor!");
1:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:         
1:         test1 = st.executeQuery("select a,data from foo7 order by data desc");
1:         assertFalse(test1.next());
1:         commit();
1:         assertFalse(test1.next());
1:         commit();
1:         assertFalse(test1.next());
1:         assertFalse(test1.next());
1:         assertFalse(test1.next());
1:         assertFalse(test1.next());
1:         test1.close();
1:         commit();
1:         try {
1:             test1.next();
1:             fail("Should be unable to establish cursor!");
1:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:         
1:         commit();
1:         
1:         stUtil.addBatch("insert into foo7 values (1, 10)");
1:         stUtil.addBatch("insert into foo7 values (1, 20)");
1:         stUtil.addBatch("insert into foo7 values (1, 30)");
1:         stUtil.addBatch("insert into foo7 values (1, 40)");
1:         stUtil.addBatch("insert into foo7 values (1, 50)");
1:         stUtil.executeBatch();
1: 
1:         test1 = st.executeQuery("select a,data from foo7 order by data desc");
1:         test1.close();
1:         commit();
1:         try {
1:             test1.next();
1:             fail("Should be unable to establish cursor!");
1:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:         
1:         test1 = st.executeQuery("select a,data from foo7 order by data desc");
1:         commit();
1:         test1.close();
1:         try {
1:             test1.next();
1:             fail("Should be unable to establish cursor!");
1:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:          
1:         test1 = st.executeQuery("select a,data from foo7 order by data desc");
1:         commit();
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(50,test1.getInt("data"));
1:         test1.close();
1:         try {
1:             test1.next();
1:             fail("Should be unable to establish cursor!");
1:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:         
1:         test1 = st.executeQuery("select a,data from foo7 order by data desc");
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(50,test1.getInt("data"));
1:         commit();
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(40,test1.getInt("data"));
1:         test1.close();
1:         try {
1:             test1.next();
1:             fail("Should be unable to establish cursor!");
1:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:         
1:         test1 = st.executeQuery("select a,data from foo7 order by data desc");
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(50,test1.getInt("data"));
1:         commit();
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(40,test1.getInt("data"));
1:         commit();
1:         test1.close();
1:         try {
1:             test1.next();
1:             fail("Should be unable to establish cursor!");
1:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:         
1:         test1 = st.executeQuery("select a,data from foo7 order by data desc");
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(50,test1.getInt("data"));
1:         commit();
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(40,test1.getInt("data"));
1:         commit();
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(30,test1.getInt("data"));
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(20,test1.getInt("data"));
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(10,test1.getInt("data"));
1:         commit();
1:         test1.close();
1:         try {
1:             test1.next();
1:             fail("Should be unable to establish cursor!");
1:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:         
1:         test1 = st.executeQuery("select a,data from foo7 order by data desc");
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(50,test1.getInt("data"));
1:         commit();
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(40,test1.getInt("data"));
1:         commit();
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(30,test1.getInt("data"));
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(20,test1.getInt("data"));
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(10,test1.getInt("data"));
1:         /* beyond the total num. */
1:         assertFalse(test1.next());
1:         commit();
1:         test1.close();
1:         try {
1:             test1.next();
1:             fail("Should be unable to establish cursor!");
1:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1: 
1:         test1 = st.executeQuery("select a,data from foo7 order by data desc");
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(50,test1.getInt("data"));
1:         commit();
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(40,test1.getInt("data"));
1:         commit();
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(30,test1.getInt("data"));
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(20,test1.getInt("data"));
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("a"));
1:         assertEquals(10,test1.getInt("data"));
1:         assertFalse(test1.next());
1:         test1.close();
1:         commit();
1:         try {
1:             test1.next();
1:             fail("Should be unable to establish cursor!");
1:         } catch (SQLException e) { assertSQLState("XCL16", e); }
1:         
1:         commit();
1:     
1:         st.close();
1:         stUtil.close();
1:     }
1:     
1:     /**
1:      *  test of hold cursor code in DistinctScalarAggregateResultSet.java
1:      *  Directed test of hold cursor as applies to sort scans opened by
1:      *  DistinctScalarAggregateResultSet.java.
1:      */
1:     public void testDistinctScalarAggregateResultSet() throws SQLException{ 
1:         Statement stUtil = createStatement();
1: 
1:         stUtil.executeUpdate("insert into t1_8 values (null, null), (1,1), " +
1:                              "(null, null), (2,1), (3,1), (10,10)");
1:         JDBC.assertFullResultSet(stUtil.executeQuery("select * from t1_8"),
1:             new String[][]{
1:                     {null, null}, {"1", "1"}, {null, null},
1:                     {"2", "1"}, {"3", "1"}, {"10", "10"},
1:         });
1: 
1:         JDBC.assertFullResultSet(
1:             stUtil.executeQuery("select sum(distinct c1) from t1_8"),
1:             new String[][]{{"16"},}
1:         );
1: 
1:         Statement st = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
1:                                        ResultSet.CONCUR_READ_ONLY,
1:                                        ResultSet.HOLD_CURSORS_OVER_COMMIT);
1: 
1:         ResultSet test1 = st.executeQuery("select sum(distinct c1) from t1_8");
1:         commit();
1:         assertTrue(test1.next());
1:         assertEquals(16,test1.getInt(1));
1:         test1.close();
1: 
1:         test1 = st.executeQuery("select sum(distinct c1) from t1_8");
1:         assertTrue(test1.next());
1:         assertEquals(16,test1.getInt(1));
1:         commit();
1:         assertFalse(test1.next());
1:         commit();
1:         test1.close();
1: 
1:         commit();
1: 
1:         st.close();
1:         stUtil.close();
1:     }  
1:     
1:     /**
1:      * test of hold cursor code in GroupedAggregateResultSet.java
1:      * Directed test of hold cursor as applies to sort scans opened by
1:      * GroupedAggregateResultSet.java.
1:      */
1:     public void testDistinctScalarAggregateResultSetGrouped()
1:     throws SQLException{ 
1:         Statement stUtil = createStatement();
1: 
1:         stUtil.executeUpdate("insert into t1_9 values (null, null), (1,1), " +
1:                 "(null, null), (2,1), (3,1), (10,10)");
1:         JDBC.assertFullResultSet(stUtil.executeQuery("select * from t1_9"),
1:             new String[][]{
1:                     {null, null}, {"1", "1"}, {null, null},
1:                     {"2", "1"}, {"3", "1"}, {"10", "10"},
1:         });
1: 
1:         JDBC.assertFullResultSet(
1:             stUtil.executeQuery(
1:                 "select sum(distinct c1) from t1_9 group by c2"),
1:             new String[][]{
1:                     {"6"},
1:                     {"10"},
1:                     {null},
1:                 }
1:         );
1:         commit();
1: 
1:         Statement st = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
1:                                        ResultSet.CONCUR_READ_ONLY,
1:                                        ResultSet.HOLD_CURSORS_OVER_COMMIT);
1: 
1:         ResultSet test1 = st.executeQuery("select sum(distinct c1) from t1_9 group by c2");
1:         commit();
1:         assertTrue(test1.next());
1:         assertEquals(6,test1.getInt(1));
1:         assertTrue(test1.next());
1:         assertEquals(10,test1.getInt(1));
1:         commit();
1:         assertTrue(test1.next());
1:         test1.getInt(1);
1:         assertTrue(test1.wasNull());
1:         test1.close();
1: 
1:         test1 = st.executeQuery("select sum(distinct c1) from t1_9 group by c2");
1:         assertTrue(test1.next());
1:         assertEquals(6,test1.getInt(1));
1:         commit();
1:         assertTrue(test1.next());
1:         assertEquals(10,test1.getInt(1));
1:         commit();
1:         assertTrue(test1.next());
1:         test1.getInt(1);
1:         assertTrue(test1.wasNull());
1:         test1.close();
1: 
1:         commit();
1: 
1:         st.close();
1:         stUtil.close();
1:     }  
1:     
1:     /**
1:      * test scan positioned on a row which has been purged.
1:      */
1:     public void testPositionPurgedRow() throws SQLException{
1:         Statement stUtil = createStatement();
1: 
1:         stUtil.executeUpdate("insert into t1_10 values (1, 1), (2, 2), " +
1:                              "(3, 3), (4, 4), (5, 5), (6, 6)");
1: 
1:         Statement st = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
1:                                        ResultSet.CONCUR_UPDATABLE,
1:                                        ResultSet.HOLD_CURSORS_OVER_COMMIT);
1: 
1:         ResultSet test1 = st.executeQuery("select c1 from t1_10");
1:         assertTrue(test1.next());
1:         assertEquals(1, test1.getInt("c1"));
1:         commit();
1: 
1:         /* at this point the btree scan is positioned by "key" on (1,1).
1:            Make sure deleting this key doesn't cause any problems. */
1:         assertUpdateCount(stUtil, 2, "delete from t1_10 where c1 = 1 or c1 = 2");
1: 
1:         /* This IF works around a difference in behaviours between the client
1:          * and the embedded drivers. Check DERBY-3839 for comments on this. */
1:         if (usingEmbedded()){
1:             assertTrue(test1.next());
1:             assertEquals(3, test1.getInt("c1"));
1: 
1:             /* -- at this point the btree scan is positioned on (3, 3),
1:                let's see what happens if we delete (3,3) and look at current scan. */
1:             assertUpdateCount(stUtil, 1, "delete from t1_10 where c1 = 3");
1: 
1:             /* position on (4,4) */
1:             assertTrue(test1.next());
1:             assertEquals(4, test1.getInt("c1"));
1: 
1:             commit();
1: 
1:             /* delete all the rows and hopefully get all rows to be purged
1:                by the time the scan does the next. */
1:             assertUpdateCount(stUtil, 3, "delete from t1_10");
1:             commit();
1: 
1:             assertFalse(test1.next());
1:         } else { /* Client has a different behaviour. Maybe a bug! */
1:             assertTrue(test1.next());
1:             assertEquals(2, test1.getInt("c1"));
1: 
1:             /* -- at this point the btree scan is positioned on (3, 3),
1:                let's see what happens if we delete (3,3) and look at current scan. */
1:             assertUpdateCount(stUtil, 1, "delete from t1_10 where c1 = 3");
1: 
1:             /* position on (4,4) */
1:             assertTrue(test1.next());
1:             assertEquals(3, test1.getInt("c1"));
1: 
1:             commit();
1: 
1:             /* delete all the rows and hopefully get all rows to be purged
1:                by the time the scan does the next. */
1:             assertUpdateCount(stUtil, 3, "delete from t1_10");
1:             commit();
1: 
1:             /* The records are all still there, even though the above assert
1:              * passed with the correct update count */
1:             assertTrue(test1.next());
1:             assertEquals(4, test1.getInt("c1"));
1:             assertTrue(test1.next());
1:             assertEquals(5, test1.getInt("c1"));
1:             assertTrue(test1.next());
1:             assertEquals(6, test1.getInt("c1"));
1: 
1:             assertFalse(test1.next());
1:         }
1:         
1:         test1.close();
1:         stUtil.close();
1:     }
1:     
1:     /**
1:      * test scan positioned on a page which has been purged (should really
1:      * not be any different than a row being purged).
1:      */
1:     public void testPositionPurgedPage() throws SQLException{ 
1:         /**
1:          * rows[0] = 1 with 1000 padding
1:          * rows[1] = 2 with 1000 padding
1:          * ...
1:          */
1:         String[] rows = new String[7];
1:         for(int i = 1; i <= rows.length; i++){
1:             rows[i - 1] = Formatters.padString("" + i, 1000);
1:         }
1: 
1:         Statement stUtil = createStatement();
1: 
1:         stUtil.executeUpdate("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:             "'derby.storage.pageSize', '4096')");
1:         stUtil.executeUpdate("create index tx_11 on t1_11 (c1)");
1:         stUtil.executeUpdate("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:             "'derby.storage.pageSize', Null)");
1: 
1:         PreparedStatement ps = prepareStatement(
1:             "insert into t1_11 values(?,1), (?,2), (?,3), " +
1:             "(?,4), (?,5), (?,6), (?,7)");
1:         for(int i = 0; i < rows.length; i++){
1:             ps.setString(i + 1, rows[i]);
1:         }
1:         ps.executeUpdate();
1:         ps.close();
1: 
1:         Statement st = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
1:                                        ResultSet.CONCUR_READ_ONLY,
1:                                        ResultSet.HOLD_CURSORS_OVER_COMMIT);
1: 
1:         ResultSet test1 = st.executeQuery("select c1 from t1_11");
1:         assertTrue(test1.next());
1:         assertEquals(rows[0], test1.getString("c1"));
1:         commit();
1: 
1:         /* at this point the btree scan is positioned by "key" on (1,1).
1:            Make sure deleting this key doesn't cause any problems. */
1:         ps = prepareStatement("delete from t1_11 where c1 = ? or c1 = ?");
1:         ps.setString(1, rows[0]);
1:         ps.setString(2, rows[1]);
1:         assertUpdateCount(ps, 2);
1:         ps.close();
1: 
1:         /* This IF works around a difference in behaviours between the client
1:          * and the embedded drivers. Check DERBY-3839 for comments on this. */
1:         if (usingEmbedded()) {
1:             assertTrue(test1.next());
1:             assertEquals(rows[2], test1.getString("c1"));
1: 
1:             /* -- at this point the btree scan is positioned on (3, 3),
1:                let's see what happens if we delete (3,3) and look at current scan. */
1:             ps = prepareStatement("delete from t1_11 where c1 = ?");
1:             ps.setString(1, rows[2]);
1:             assertUpdateCount(ps, 1);
1:             ps.close();
1: 
1:             /* position on (4,4) */
1:             assertTrue(test1.next());
1:             assertEquals(rows[3], test1.getString("c1"));
1: 
1:             commit();
1: 
1:             /* delete all the rows and hopefully get all rows to be purged
1:                by the time the scan does the next. */
1:             assertUpdateCount(stUtil, 4, "delete from t1_11");
1:             commit();
1: 
1:             assertFalse(test1.next());
1:         } else {
1:             assertTrue(test1.next());
1:             assertEquals(rows[1], test1.getString("c1"));
1: 
1:             /* -- at this point the btree scan is positioned on (3, 3),
1:                let's see what happens if we delete (3,3) and look at current scan. */
1:             ps = prepareStatement("delete from t1_11 where c1 = ?");
1:             ps.setString(1, rows[2]);
1:             assertUpdateCount(ps, 1);
1:             ps.close();
1: 
1:             /* position on (4,4) */
1:             assertTrue(test1.next());
1:             assertEquals(rows[2], test1.getString("c1"));
1: 
1:             commit();
1: 
1:             /* delete all the rows and hopefully get all rows to be purged
1:                by the time the scan does the next. */
1:             assertUpdateCount(stUtil, 4, "delete from t1_11");
1:             commit();
1: 
1:             /**
1:              * The records are all still there, even though the above assert
1:              * passed with the correct update count.
1:              */
1:             assertTrue(test1.next());
1:             assertEquals(rows[3], test1.getString("c1"));
1:             assertTrue(test1.next());
1:             assertEquals(rows[4], test1.getString("c1"));
1:             assertTrue(test1.next());
1:             assertEquals(rows[5], test1.getString("c1"));
1:             assertTrue(test1.next());
1:             assertEquals(rows[6], test1.getString("c1"));
1: 
1:             assertFalse(test1.next());
1:         }
1: 
1:         test1.close();
1:         st.close();
1:         stUtil.close();
1:     }
1:     
1:     /**
1:      * test query plans which use reopenScan() on a btree to 
1:      * do the inner table processing of a join.  Prior to the fix a null
1:      * pointer exception would be thrown after the commit, as the code
1:      * did not handle keeping the resultset used for the inner table
1:      * open across commits in this case.
1:      */
1:     public void testBeetle4902() throws SQLException{ 
1:         Statement stUtil = createStatement();
1: 
1:         stUtil.addBatch("insert into t1_12 values (1, 10), (2, 20), " +
1:                         "(3, 30), (4, 40), (5, 50)");
1:         stUtil.addBatch("insert into t2_12 values (1, 10), (2, 20), " +
1:                         "(4, 40), (5, 50)");
1:         stUtil.executeBatch();
1:         commit();
1: 
1:         /* force nestedLoop to make sure reopenScan() is used on inner table. */
1:         Statement st = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
1:                                        ResultSet.CONCUR_READ_ONLY,
1:                                        ResultSet.HOLD_CURSORS_OVER_COMMIT);
1:         
1:         ResultSet test11 = st.executeQuery("select * from t1_12, t2_12 where t1_12.t1_i1 = t2_12.t2_i1");
1: 
1:         commit();
1:         assertTrue(test11.next());
1:         assertEquals(1, test11.getInt("t1_i1"));
1:         assertEquals(10, test11.getInt("t1_i2"));
1:         assertEquals(1, test11.getInt("t2_i1"));
1:         assertEquals(10, test11.getInt("t2_i2"));
1:         commit();
1:         assertTrue(test11.next());
1:         assertEquals(2, test11.getInt("t1_i1"));
1:         assertEquals(20, test11.getInt("t1_i2"));
1:         assertEquals(2, test11.getInt("t2_i1"));
1:         assertEquals(20, test11.getInt("t2_i2"));
1:         commit();
1:         assertTrue(test11.next());
1:         assertEquals(4, test11.getInt("t1_i1"));
1:         assertEquals(40, test11.getInt("t1_i2"));
1:         assertEquals(4, test11.getInt("t2_i1"));
1:         assertEquals(40, test11.getInt("t2_i2"));
1:         assertTrue(test11.next());
1:         assertEquals(5, test11.getInt("t1_i1"));
1:         assertEquals(50, test11.getInt("t1_i2"));
1:         assertEquals(5, test11.getInt("t2_i1"));
1:         assertEquals(50, test11.getInt("t2_i2"));
1:         commit();
1:         commit();
1:         assertFalse(test11.next());
1:         commit();
1: 
1:         test11.close();
1: 
1:         st.close();
1:         stUtil.close();
1:     }
1:     
1: 
1:     /**
1:      * test query plans which use reopenScan() on a btree to 
1:      * do the inner table processing of a join.  Prior to the fix a null
1:      * pointer exception would be thrown after the commit, as the code
1:      * did not handle keeping the resultset used for the inner table
1:      * open across commits in this case.
1:      */
1:     public void testBeetle4902WithBulkFetchDefaultSet() throws SQLException{
1:         Statement stUtil = createStatement();
1: 
1:         stUtil.addBatch("insert into t1_13 values (1, 10), (2, 20), " +
1:                         "(3, 30), (4, 40), (5, 50)");
1:         stUtil.addBatch("insert into t2_13 values (1, 10), (2, 20), " +
1:                         "(4, 40), (5, 50)");
1:         stUtil.executeBatch();
1:         commit();
1: 
1:         /* force nestedLoop to make sure reopenScan() is used on inner table. */
1:         Statement st = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
1:                                        ResultSet.CONCUR_READ_ONLY,
1:                                        ResultSet.HOLD_CURSORS_OVER_COMMIT);
1:         ResultSet test12 = st.executeQuery("select * from t1_13, t2_13 where t1_13.t1_i1 = t2_13.t2_i1");
1:         stUtil.executeUpdate("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:                              "'derby.language.bulkFetchDefault', '16')");
1: 
1:         commit();
1: 
1:         assertTrue(test12.next());
1:         assertEquals(1, test12.getInt("t1_i1"));
1:         assertEquals(10, test12.getInt("t1_i2"));
1:         assertEquals(1, test12.getInt("t2_i1"));
1:         assertEquals(10, test12.getInt("t2_i2"));
1:         commit();
1:         assertTrue(test12.next());
1:         assertEquals(2, test12.getInt("t1_i1"));
1:         assertEquals(20, test12.getInt("t1_i2"));
1:         assertEquals(2, test12.getInt("t2_i1"));
1:         assertEquals(20, test12.getInt("t2_i2"));
1:         commit();
1:         assertTrue(test12.next());
1:         assertEquals(4, test12.getInt("t1_i1"));
1:         assertEquals(40, test12.getInt("t1_i2"));
1:         assertEquals(4, test12.getInt("t2_i1"));
1:         assertEquals(40, test12.getInt("t2_i2"));
1:         assertTrue(test12.next());
1:         assertEquals(5, test12.getInt("t1_i1"));
1:         assertEquals(50, test12.getInt("t1_i2"));
1:         assertEquals(5, test12.getInt("t2_i1"));
1:         assertEquals(50, test12.getInt("t2_i2"));
1:         commit();
1:         commit();
1:         assertFalse(test12.next());
1:         commit();
1: 
1:         test12.close();
1: 
1:         st.close();
1:         stUtil.close();
1:     }
1: }
============================================================================