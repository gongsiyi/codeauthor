1:eac0369: /*
1:e2f08d2: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.compile.UnaryArithmeticOperatorNode
1:345de35: 
1:2d37fd6:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2d37fd6:    contributor license agreements.  See the NOTICE file distributed with
1:2d37fd6:    this work for additional information regarding copyright ownership.
1:2d37fd6:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2d37fd6:    (the "License"); you may not use this file except in compliance with
1:2d37fd6:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:345de35: 
3:eac0369:  */
14:eac0369: 
1:eac0369: package	org.apache.derby.impl.sql.compile;
1:eac0369: 
1:eac0369: import java.sql.Types;
1:f33fbaf: import java.util.List;
1:3bb140c: import org.apache.derby.iapi.error.StandardException;
1:3bb140c: import org.apache.derby.iapi.reference.SQLState;
1:3bb140c: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1:3bb140c: import org.apache.derby.iapi.services.context.ContextManager;
1:3bb140c: import org.apache.derby.iapi.types.DataTypeDescriptor;
1:3bb140c: import org.apache.derby.iapi.types.TypeId;
1:3bb140c: 
1:e2f08d2: /**
1:eac0369:  * This node represents a unary arithmetic operator
4:eac0369:  *
1:eac0369:  */
1:3bb140c: 
1:3bb140c: class UnaryArithmeticOperatorNode extends UnaryOperatorNode
5:eac0369: {
1:eac0369: 	private final static String[] UNARY_OPERATORS = {"+","-","SQRT", "ABS/ABSVAL"};
1:eac0369: 	private final static String[] UNARY_METHODS = {"plus","minus","sqrt", "absolute"};
1:3bb140c: 
1:2706d1f:     // Allowed kinds
1:2706d1f:     final static int K_PLUS = 0;
1:2706d1f:     final static int K_MINUS = 1;
1:2706d1f:     final static int K_SQRT = 2;
1:2706d1f:     final static int K_ABS = 3;
1:3bb140c:     
3:eac0369:     /**
1:2706d1f:      * This class is used to hold logically different objects for
1:2706d1f:      * space efficiency. {@code kind} represents the logical object
1:2706d1f:      * type. See also {@link ValueNode#isSameNodeKind}.
1:2706d1f:      */
1:2706d1f:     final int kind;
1:2706d1f: 
1:2706d1f:     /**
1:3bb140c:      * @param operand The operand of the node
1:2706d1f:      * @param kind unary operator identity
1:3bb140c:      * @param cm context manager
1:3bb140c:      * @throws StandardException
1:3bb140c:      */
1:3bb140c:     UnaryArithmeticOperatorNode(
1:3bb140c:             ValueNode operand,
1:2706d1f:             int kind,
1:3bb140c:             ContextManager cm) throws StandardException {
1:3bb140c:         super(operand,
1:2706d1f:               UNARY_OPERATORS[kind],
1:2706d1f:               UNARY_METHODS[kind],
1:3bb140c:               cm);
1:2706d1f:         this.kind = kind;
1:3bb140c:     }
1:2706d1f: 
1:3bb140c:     /**
1:e2f08d2:      * Unary + and - require their type to be set if
1:e2f08d2:      * they wrap another node (e.g. a parameter) that
1:e2f08d2:      * requires type from its context.
1:e2f08d2:      * @see ValueNode#requiresTypeFromContext
1:e2f08d2:      */
1:3bb140c:     @Override
1:e2f08d2:     public boolean requiresTypeFromContext()
1:e2f08d2:     {
1:2706d1f:         if (kind == K_PLUS ||
1:2706d1f:             kind == K_MINUS) {
1:e2f08d2:             return operand.requiresTypeFromContext(); 
1:3bb140c:         }
1:e2f08d2:         return false;
1:3bb140c:     }
1:ac12b1f:     
1:ac12b1f:     /**
1:ac12b1f:      * A +? or a -? is considered a parameter.
1:ac12b1f:      */
1:3bb140c:     @Override
1:ac12b1f:     public boolean isParameterNode()
1:ac12b1f:     {
1:2706d1f:         if (kind == K_PLUS ||
1:2706d1f:             kind == K_MINUS) {
1:23c83d2:             return operand.isParameterNode(); 
1:3bb140c:         }
1:23c83d2:         return false;
1:3bb140c:     }
1:eac0369: 
1:eac0369: 	/**
1:e2f08d2:      * For SQRT and ABS the parameter becomes a DOUBLE.
1:e2f08d2:      * For unary + and - no change is made to the
1:e2f08d2:      * underlying node. Once this node's type is set
1:e2f08d2:      * using setType, then the underlying node will have
1:e2f08d2:      * its type set.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown if ?  parameter doesn't
1:eac0369: 	 *									have a type bound to it yet.
1:eac0369: 	 *									? parameter where it isn't allowed.
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	void bindParameter() throws StandardException
1:eac0369: 	{
1:2706d1f:        if (kind == K_SQRT ||
1:2706d1f:             kind == K_ABS)
1:eac0369: 		{
1:d5bc20f: 			operand.setType(
1:eac0369: 				new DataTypeDescriptor(TypeId.getBuiltInTypeId(Types.DOUBLE), true));
1:e2f08d2:             return;
1:ac12b1f: 		}
1:e2f08d2:         
1:d5bc20f: 		//Derby-582 add support for dynamic parameter for unary plus and minus
1:2706d1f:        if (kind == K_MINUS ||
1:2706d1f:             kind == K_PLUS)
1:d5bc20f: 			return;
1:e2f08d2:         
1:e2f08d2:         // Not expected to get here since only the above types are supported
1:e2f08d2:         // but the super-class method will throw an exception
1:e2f08d2:         super.bindParameter();
1:e2f08d2:         
1:e2f08d2: 	}
1:e2f08d2:     
1:eac0369: 	/**
1:eac0369: 	 * Bind this operator
1:eac0369: 	 *
1:eac0369: 	 * @param fromList			The query's FROM list
1:eac0369: 	 * @param subqueryList		The subquery list being built as we find SubqueryNodes
1:09c2697:      * @param aggregates        The aggregate list being built as we find AggregateNodes
1:eac0369: 	 *
1:eac0369: 	 * @return	The new top of the expression tree.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:09c2697:     ValueNode bindExpression(
1:71c8e86:         FromList fromList, SubqueryList subqueryList, List<AggregateNode> aggregates)
1:eac0369: 			throws StandardException
1:eac0369: 	{
1:d5bc20f: 		//Return with no binding, if the type of unary minus/plus parameter is not set yet.
1:3bb140c:        if (operand.requiresTypeFromContext() &&
1:2706d1f:                 ((kind == K_PLUS ||
1:2706d1f:                   kind == K_MINUS))
1:d5bc20f: 				&& operand.getTypeServices() == null)
1:d5bc20f: 				return this;
1:eac0369: 
1:09c2697:         bindOperand(fromList, subqueryList, aggregates);
1:eac0369: 
1:2706d1f:        if (kind == K_SQRT ||
1:2706d1f:             kind == K_ABS)
1:eac0369: 		{
1:eac0369: 			bindSQRTABS();
7:eac0369: 		}
1:2706d1f:        else if (kind == K_PLUS ||
1:2706d1f:                  kind == K_MINUS)
1:eac0369: 		{
1:e2f08d2:             checkOperandIsNumeric(operand.getTypeId());
1:eac0369: 		}
1:eac0369: 		/*
1:eac0369: 		** The result type of a +, -, SQRT, ABS is the same as its operand.
1:eac0369: 		*/
1:d5bc20f: 		super.setType(operand.getTypeServices());
1:eac0369: 		return this;
1:eac0369: 	}
1:e2f08d2:     
1:e2f08d2:     /**
1:e2f08d2:      * Only called for Unary +/-.
1:e2f08d2:      *
1:e2f08d2:      */
1:e2f08d2: 	private void checkOperandIsNumeric(TypeId operandType) throws StandardException
1:e2f08d2: 	{
1:e2f08d2: 	    if (!operandType.isNumericTypeId())
1:e2f08d2: 	    {
1:e2f08d2: 	        throw StandardException.newException(
1:e2f08d2:                     SQLState.LANG_UNARY_ARITHMETIC_BAD_TYPE, 
1:2706d1f:                    (kind == K_PLUS) ? "+" : "-",
1:e2f08d2: 	                        operandType.getSQLTypeName());
1:e2f08d2: 	    }
1:e2f08d2: 	    
1:e2f08d2: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Do code generation for this unary plus operator
1:eac0369: 	 *
1:eac0369: 	 * @param acb	The ExpressionClassBuilder for the class we're generating
1:eac0369: 	 * @param mb	The method the expression will go into
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:8fe3166:     void generateExpression(ExpressionClassBuilder acb, MethodBuilder mb)
1:eac0369: 									throws StandardException
1:eac0369: 	{
1:eac0369: 		/* Unary + doesn't do anything.  Just return the operand */
1:2706d1f:        if (kind == K_PLUS)
1:eac0369: 			operand.generateExpression(acb, mb);
1:eac0369: 		else
1:eac0369: 			super.generateExpression(acb, mb);
1:eac0369: 	}
1:eac0369: 	/**
1:eac0369: 	 * Bind SQRT or ABS
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	private void bindSQRTABS()
1:eac0369: 			throws StandardException
1:eac0369: 	{
1:eac0369: 		TypeId	operandType;
1:eac0369: 		int 	jdbcType;
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** Check the type of the operand 
1:eac0369: 		*/
1:eac0369: 		operandType = operand.getTypeId();
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 	 	 * If the operand is not a build-in type, generate a bound conversion
1:eac0369: 		 * tree to build-in types.
1:eac0369: 		 */
1:08d6ce2: 		if (operandType.userType() )
1:eac0369: 		{
1:eac0369: 			operand = operand.genSQLJavaSQLTree();
1:eac0369: 		}
1:eac0369: 		/* DB2 doesn't cast string types to numeric types for numeric functions  */
1:eac0369: 
1:eac0369: 		jdbcType = operandType.getJDBCTypeId();
1:eac0369: 
1:eac0369: 		/* Both SQRT and ABS are only allowed on numeric types */
1:eac0369: 		if (!operandType.isNumericTypeId())
1:eac0369: 			throw StandardException.newException(
1:eac0369: 						SQLState.LANG_UNARY_FUNCTION_BAD_TYPE, 
1:eac0369: 						getOperatorString(), operandType.getSQLTypeName());
1:eac0369: 
1:eac0369: 		/* For SQRT, if operand is not a DOUBLE, convert it to DOUBLE */
1:2706d1f:        if (kind == K_SQRT &&
1:3bb140c:             jdbcType != Types.DOUBLE)
1:eac0369: 		{
1:3bb140c:             operand = new CastNode(
1:eac0369: 					operand,
1:eac0369: 					new DataTypeDescriptor(TypeId.getBuiltInTypeId(Types.DOUBLE), true),
1:eac0369: 					getContextManager());
1:eac0369: 			((CastNode) operand).bindCastNodeOnly();
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:e2f08d2: 	/** We are overwriting this method here because for -?/+?, we now know
1:d5bc20f: 	the type of these dynamic parameters and hence we can do the parameter
1:d5bc20f: 	binding. The setType method will call the binding code after setting
1:d5bc20f: 	the type of the parameter*/
1:3bb140c:     @Override
1:3bb140c:     void setType(DataTypeDescriptor descriptor) throws StandardException
1:eac0369: 	{
1:e2f08d2:         if (operand.requiresTypeFromContext() && operand.getTypeServices() == null)
1:e2f08d2:         {
1:e2f08d2:             checkOperandIsNumeric(descriptor.getTypeId());
1:e2f08d2: 		    operand.setType(descriptor);
1:e2f08d2:         }
1:d5bc20f: 		super.setType(descriptor);
1:eac0369: 	}
1:2706d1f: 
1:2706d1f:     @Override
1:2706d1f:     boolean isSameNodeKind(ValueNode o) {
1:2706d1f:         return super.isSameNodeKind(o) &&
1:2706d1f:                 ((UnaryArithmeticOperatorNode)o).kind == kind;
1:2706d1f:     }
1:eac0369: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:2706d1f
/////////////////////////////////////////////////////////////////////////
1:     // Allowed kinds
1:     final static int K_PLUS = 0;
1:     final static int K_MINUS = 1;
1:     final static int K_SQRT = 2;
1:     final static int K_ABS = 3;
1:      * This class is used to hold logically different objects for
1:      * space efficiency. {@code kind} represents the logical object
1:      * type. See also {@link ValueNode#isSameNodeKind}.
1:      */
1:     final int kind;
1: 
1:     /**
1:      * @param kind unary operator identity
1:             int kind,
1:               UNARY_OPERATORS[kind],
1:               UNARY_METHODS[kind],
1:         this.kind = kind;
1: 
/////////////////////////////////////////////////////////////////////////
1:         if (kind == K_PLUS ||
1:             kind == K_MINUS) {
/////////////////////////////////////////////////////////////////////////
1:         if (kind == K_PLUS ||
1:             kind == K_MINUS) {
/////////////////////////////////////////////////////////////////////////
1:        if (kind == K_SQRT ||
1:             kind == K_ABS)
/////////////////////////////////////////////////////////////////////////
1:        if (kind == K_MINUS ||
1:             kind == K_PLUS)
/////////////////////////////////////////////////////////////////////////
1:                 ((kind == K_PLUS ||
1:                   kind == K_MINUS))
1:        if (kind == K_SQRT ||
1:             kind == K_ABS)
1:        else if (kind == K_PLUS ||
1:                  kind == K_MINUS)
/////////////////////////////////////////////////////////////////////////
1:                    (kind == K_PLUS) ? "+" : "-",
/////////////////////////////////////////////////////////////////////////
1:        if (kind == K_PLUS)
/////////////////////////////////////////////////////////////////////////
1:        if (kind == K_SQRT &&
/////////////////////////////////////////////////////////////////////////
1: 
1:     @Override
1:     boolean isSameNodeKind(ValueNode o) {
1:         return super.isSameNodeKind(o) &&
1:                 ((UnaryArithmeticOperatorNode)o).kind == kind;
1:     }
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1: import org.apache.derby.iapi.services.context.ContextManager;
1: import org.apache.derby.iapi.types.DataTypeDescriptor;
1: import org.apache.derby.iapi.types.TypeId;
1: class UnaryArithmeticOperatorNode extends UnaryOperatorNode
0:    private final OperatorType operatorType;
1: 
0:     public enum OperatorType {PLUS(0), MINUS(1), SQRT(2), ABS(3);
1: 
0:         private int representation;
1: 
0:         private OperatorType(int repr) {
0:             this.representation = repr;
1:         }
1: 
0:         public int getVal() { return representation; }
1:     }
1:      * @param operand The operand of the node
0:      * @param type unary operator identity
1:      * @param cm context manager
1:      * @throws StandardException
1:      */
1:     UnaryArithmeticOperatorNode(
1:             ValueNode operand,
0:             OperatorType type,
1:             ContextManager cm) throws StandardException {
1:         super(operand,
0:               UNARY_OPERATORS[type.getVal()],
0:               UNARY_METHODS[type.getVal()],
1:               cm);
0:         this.operatorType = type;
1:     }
1:     /**
1:     @Override
0:         if (operatorType == OperatorType.PLUS ||
0:             operatorType == OperatorType.MINUS) {
1:         }
1:     @Override
0:         if (operatorType == OperatorType.PLUS ||
0:             operatorType == OperatorType.MINUS) {
1:         }
/////////////////////////////////////////////////////////////////////////
1:     @Override
0:        if (operatorType == OperatorType.SQRT ||
0:             operatorType == OperatorType.ABS)
/////////////////////////////////////////////////////////////////////////
0:        if (operatorType == OperatorType.MINUS ||
0:             operatorType == OperatorType.PLUS)
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:        if (operand.requiresTypeFromContext() &&
0:                 ((operatorType == OperatorType.PLUS ||
0:                   operatorType == OperatorType.MINUS))
0:        if (operatorType == OperatorType.SQRT ||
0:             operatorType == OperatorType.ABS)
0:        else if (operatorType == OperatorType.PLUS ||
0:                  operatorType == OperatorType.MINUS)
/////////////////////////////////////////////////////////////////////////
0:                    (operatorType == OperatorType.PLUS) ? "+" : "-",
/////////////////////////////////////////////////////////////////////////
1:     @Override
0:        if (operatorType == OperatorType.PLUS)
/////////////////////////////////////////////////////////////////////////
0:        if (operatorType == OperatorType.SQRT &&
1:             jdbcType != Types.DOUBLE)
1:             operand = new CastNode(
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     void setType(DataTypeDescriptor descriptor) throws StandardException
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:71c8e86
/////////////////////////////////////////////////////////////////////////
1:         FromList fromList, SubqueryList subqueryList, List<AggregateNode> aggregates)
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:8fe3166
/////////////////////////////////////////////////////////////////////////
1:     void generateExpression(ExpressionClassBuilder acb, MethodBuilder mb)
commit:09c2697
/////////////////////////////////////////////////////////////////////////
1:      * @param aggregates        The aggregate list being built as we find AggregateNodes
1:     ValueNode bindExpression(
0:         FromList fromList, SubqueryList subqueryList, List aggregates)
/////////////////////////////////////////////////////////////////////////
1:         bindOperand(fromList, subqueryList, aggregates);
commit:f33fbaf
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
0: 		List aggregateVector)
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:23c83d2
/////////////////////////////////////////////////////////////////////////
0:         if (operatorType == UNARY_PLUS || operatorType == UNARY_MINUS)
1:             return operand.isParameterNode(); 
1:         return false;
commit:ac12b1f
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * A +? or a -? is considered a parameter.
1:      */
1:     public boolean isParameterNode()
1:     {
0:         return requiresTypeFromContext();
1:     }
commit:e2f08d2
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Unary + and - require their type to be set if
1:      * they wrap another node (e.g. a parameter) that
1:      * requires type from its context.
1:      * @see ValueNode#requiresTypeFromContext
1:      */
1:     public boolean requiresTypeFromContext()
1:     {
0:         if (operatorType == UNARY_PLUS || operatorType == UNARY_MINUS)
1:             return operand.requiresTypeFromContext(); 
1:         return false;
1:     }
1:      * For SQRT and ABS the parameter becomes a DOUBLE.
1:      * For unary + and - no change is made to the
1:      * underlying node. Once this node's type is set
1:      * using setType, then the underlying node will have
1:      * its type set.
/////////////////////////////////////////////////////////////////////////
1:             return;
1:         
0: 		if (operatorType == UNARY_MINUS || operatorType == UNARY_PLUS) 
1:         
1:         // Not expected to get here since only the above types are supported
1:         // but the super-class method will throw an exception
1:         super.bindParameter();
1:         
1:     
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             checkOperandIsNumeric(operand.getTypeId());
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Only called for Unary +/-.
1:      *
1:      */
1: 	private void checkOperandIsNumeric(TypeId operandType) throws StandardException
1: 	{
1: 	    if (!operandType.isNumericTypeId())
1: 	    {
1: 	        throw StandardException.newException(
1:                     SQLState.LANG_UNARY_ARITHMETIC_BAD_TYPE, 
0: 	                (operatorType == UNARY_PLUS) ? "+" : "-", 
1: 	                        operandType.getSQLTypeName());
1: 	    }
1: 	    
1: 	}
/////////////////////////////////////////////////////////////////////////
1: 	/** We are overwriting this method here because for -?/+?, we now know
1:         if (operand.requiresTypeFromContext() && operand.getTypeServices() == null)
1:         {
1:             checkOperandIsNumeric(descriptor.getTypeId());
1: 		    operand.setType(descriptor);
1:         }
commit:3233189
/////////////////////////////////////////////////////////////////////////
0: 		bindOperand(fromList, subqueryList,
commit:08d6ce2
/////////////////////////////////////////////////////////////////////////
1: 		if (operandType.userType() )
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.compile.UnaryArithmeticOperatorNode
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:61070a6
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package	org.apache.derby.impl.sql.compile;
1: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1: 
0: import org.apache.derby.iapi.types.TypeId;
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
0: import org.apache.derby.impl.sql.compile.ExpressionClassBuilder;
1: 
1: import java.sql.Types;
0: import java.util.Vector;
1: 
1: /**
1:  * This node represents a unary arithmetic operator
1:  *
0:  * @author Manish Khettry
1:  */
1: 
0: public class UnaryArithmeticOperatorNode extends UnaryOperatorNode
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	private final static int UNARY_PLUS	= 0;
0: 	private final static int UNARY_MINUS	= 1;
0: 	private final static int SQRT = 2;
0: 	private final static int ABSOLUTE = 3;
1: 	private final static String[] UNARY_OPERATORS = {"+","-","SQRT", "ABS/ABSVAL"};
1: 	private final static String[] UNARY_METHODS = {"plus","minus","sqrt", "absolute"};
1: 
0: 	private int operatorType;
1: 
1: 
1: 	/**
0: 	 * Initializer for a UnaryArithmeticOperatorNode
1: 	 *
0: 	 * @param operand		The operand of the node
1: 	 */
0: 	public void init(Object operand)
1: 	{
0: 		switch(getNodeType())
1: 		{
0: 			case C_NodeTypes.UNARY_PLUS_OPERATOR_NODE:
0: 				operatorType = UNARY_PLUS;
0: 				break;
0: 			case C_NodeTypes.UNARY_MINUS_OPERATOR_NODE:
0: 				operatorType = UNARY_MINUS;
0: 				break;
0: 			case C_NodeTypes.SQRT_OPERATOR_NODE:
0: 				operatorType = SQRT;
0: 				break;
0: 			case C_NodeTypes.ABSOLUTE_OPERATOR_NODE:
0: 				operatorType = ABSOLUTE;
0: 				break;
0: 			default:
0: 				if (SanityManager.DEBUG)
1: 				{
0: 					SanityManager.THROWASSERT("init for UnaryArithmeticOperator called with wrong nodeType = " + getNodeType());
1: 				}
0: 			    break;
1: 		}
0: 		init(operand, UNARY_OPERATORS[this.operatorType], 
0: 				UNARY_METHODS[this.operatorType]);
1: 	}
1: 
1: 	/**
0: 	 * By default unary operators don't accept ? parameters as operands.
0: 	 * This can be over-ridden for particular unary operators.
1: 	 *
0: 	 *	We throw an exception if the parameter doesn't have a datatype
0: 	 *	assigned to it yet.
1: 	 *
0: 	 * @return	Nothing
1: 	 *
1: 	 * @exception StandardException		Thrown if ?  parameter doesn't
1: 	 *									have a type bound to it yet.
1: 	 *									? parameter where it isn't allowed.
1: 	 */
1: 
1: 	void bindParameter() throws StandardException
1: 	{
0: 		if (operatorType == SQRT || operatorType == ABSOLUTE)
1: 		{
0: 			((ParameterNode) operand).setDescriptor(
1: 				new DataTypeDescriptor(TypeId.getBuiltInTypeId(Types.DOUBLE), true));
1: 		}
0: 		else if (operand.getTypeServices() == null)
1: 		{
0: 			throw StandardException.newException(SQLState.LANG_UNARY_OPERAND_PARM, operator);
1: 		}
1: 	}
1: 	/**
1: 	 * Bind this operator
1: 	 *
1: 	 * @param fromList			The query's FROM list
1: 	 * @param subqueryList		The subquery list being built as we find SubqueryNodes
0: 	 * @param aggregateVector	The aggregate vector being built as we find AggregateNodes
1: 	 *
1: 	 * @return	The new top of the expression tree.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public ValueNode bindExpression(
0: 		FromList	fromList, SubqueryList subqueryList,
0: 		Vector	aggregateVector)
1: 			throws StandardException
1: 	{
0: 		super.bindExpression(fromList, subqueryList,
0: 				aggregateVector);
1: 
0: 		if (operatorType == SQRT || operatorType == ABSOLUTE)
1: 		{
1: 			bindSQRTABS();
1: 		}
0: 		else if (operatorType == UNARY_PLUS || operatorType == UNARY_MINUS)
1: 		{
0: 			TypeId operandType = operand.getTypeId();
1: 
0: 			if ( ! operandType.isNumericTypeId())
1: 			{
1: 			
0: 				throw StandardException.newException(SQLState.LANG_UNARY_ARITHMETIC_BAD_TYPE, 
0: 					(operatorType == UNARY_PLUS) ? "+" : "-", 
0: 					operandType.getSQLTypeName());
1: 			}
1: 		}
1: 		/*
1: 		** The result type of a +, -, SQRT, ABS is the same as its operand.
1: 		*/
0: 		setType(operand.getTypeServices());
1: 		return this;
1: 	}
1: 
1: 	/**
1: 	 * Do code generation for this unary plus operator
1: 	 *
1: 	 * @param acb	The ExpressionClassBuilder for the class we're generating
1: 	 * @param mb	The method the expression will go into
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public void generateExpression(ExpressionClassBuilder acb,
0: 											MethodBuilder mb)
1: 									throws StandardException
1: 	{
1: 		/* Unary + doesn't do anything.  Just return the operand */
0: 		if (operatorType == UNARY_PLUS)
1: 			operand.generateExpression(acb, mb);
1: 		else
1: 			super.generateExpression(acb, mb);
1: 	}
1: 	/**
1: 	 * Bind SQRT or ABS
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	private void bindSQRTABS()
1: 			throws StandardException
1: 	{
1: 		TypeId	operandType;
1: 		int 	jdbcType;
1: 
1: 		/*
1: 		** Check the type of the operand 
1: 		*/
1: 		operandType = operand.getTypeId();
1: 
1: 		/*
1: 	 	 * If the operand is not a build-in type, generate a bound conversion
1: 		 * tree to build-in types.
1: 		 */
0: 		if( ! operandType.systemBuiltIn() )
1: 		{
1: 			operand = operand.genSQLJavaSQLTree();
1: 		}
1: 		/* DB2 doesn't cast string types to numeric types for numeric functions  */
1: 
1: 		jdbcType = operandType.getJDBCTypeId();
1: 
1: 		/* Both SQRT and ABS are only allowed on numeric types */
1: 		if (!operandType.isNumericTypeId())
1: 			throw StandardException.newException(
1: 						SQLState.LANG_UNARY_FUNCTION_BAD_TYPE, 
1: 						getOperatorString(), operandType.getSQLTypeName());
1: 
1: 		/* For SQRT, if operand is not a DOUBLE, convert it to DOUBLE */
0: 		if (operatorType == SQRT && jdbcType != Types.DOUBLE)
1: 		{
0: 			operand = (ValueNode) getNodeFactory().getNode(
0: 					C_NodeTypes.CAST_NODE,
1: 					operand,
1: 					new DataTypeDescriptor(TypeId.getBuiltInTypeId(Types.DOUBLE), true),
1: 					getContextManager());
1: 			((CastNode) operand).bindCastNodeOnly();
1: 		}
1: 	}
1: }
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:c7f7349
/////////////////////////////////////////////////////////////////////////
commit:f63b7da
/////////////////////////////////////////////////////////////////////////
0: 		//collation of ? operand should be same as the compilation schema
0: 		operand.setCollationUsingCompilationSchema(
commit:7c5fbc4
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.types.StringDataValue;
/////////////////////////////////////////////////////////////////////////
0: 		//collation of ? operand should be same as the current schema
0: 		operand.getTypeServices().setCollationDerivation(
0: 				StringDataValue.COLLATION_DERIVATION_IMPLICIT);
0: 		operand.getTypeServices().setCollationType(
0: 				getLanguageConnectionContext().getDefaultSchema()
0: 						.getCollationType());
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2d37fd6
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:d5bc20f
/////////////////////////////////////////////////////////////////////////
0: 	//when the bindExpression method is called during the normal binding phase,
0: 	//unary minus and unary plus dynamic parameters are not ready for
0: 	//binding because the type of these dynamic parameters is not yet set.
0: 	//For eg, consider sql select * from t1 where c1 = -?
0: 	//bindExpression on -? gets called from BinaryComparisonOperatorNode's
0: 	//bindExpression but the parameter type has not been set yet for -?
0: 	//Later on, in BinaryComparisonOperatorNode's bindExpression, the type
0: 	//of the -? gets set to the type of c1 by the setType call. 
0: 	//Now, at this point, we are ready to finish binding phase for -? 
0: 	//(This class's setType method calls the bindExpression to finish binding)
0: 	//In order to accomplish binding later on, we need to save the following 
0: 	//3 objects during first call to bindExpression and then later this 
0: 	//gets used in setType method when it calls the bindExpression method.
0: 	FromList localCopyFromList;
0: 	SubqueryList localCopySubqueryList;
0: 	Vector localAggregateVector;
0:   
/////////////////////////////////////////////////////////////////////////
1: 			operand.setType(
1: 		//Derby-582 add support for dynamic parameter for unary plus and minus
0: 		else if (operatorType == UNARY_MINUS || operatorType == UNARY_PLUS) 
1: 			return;
/////////////////////////////////////////////////////////////////////////
0: 		localCopyFromList = fromList;
0: 		localCopySubqueryList = subqueryList;
0: 		localAggregateVector = aggregateVector;
1: 		//Return with no binding, if the type of unary minus/plus parameter is not set yet.
0: 		if (operand.requiresTypeFromContext() && ((operatorType == UNARY_PLUS || operatorType == UNARY_MINUS))
1: 				&& operand.getTypeServices() == null)
1: 				return this;
0: 
/////////////////////////////////////////////////////////////////////////
1: 		super.setType(operand.getTypeServices());
/////////////////////////////////////////////////////////////////////////
0: 
0: 	/** @see ValueNode#setType */
0: 	/* We are overwriting this method here because for -?/+?, we now know
1: 	the type of these dynamic parameters and hence we can do the parameter
1: 	binding. The setType method will call the binding code after setting
1: 	the type of the parameter*/
0: 	public void setType(DataTypeDescriptor descriptor) throws StandardException
0: 	{
0: 		operand.setType(descriptor);
1: 		super.setType(descriptor);
0: 		//Derby-582 add support for dynamic parameters for unary plus and minus
0: 		//Now that we know the type of this parameter node, we can do the
0: 		//binding.
0: 		bindExpression(localCopyFromList, localCopySubqueryList, localAggregateVector);
0: 	}
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package	org.apache.derby.impl.sql.compile;
0: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: 
0: import org.apache.derby.iapi.types.TypeId;
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
0: import org.apache.derby.impl.sql.compile.ExpressionClassBuilder;
0: 
0: import java.sql.Types;
0: import java.util.Vector;
0: 
0: /**
0:  * This node represents a unary arithmetic operator
0:  *
0:  * @author Manish Khettry
0:  */
0: 
0: public class UnaryArithmeticOperatorNode extends UnaryOperatorNode
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	private final static int UNARY_PLUS	= 0;
0: 	private final static int UNARY_MINUS	= 1;
0: 	private final static int SQRT = 2;
0: 	private final static int ABSOLUTE = 3;
0: 	private final static String[] UNARY_OPERATORS = {"+","-","SQRT", "ABS/ABSVAL"};
0: 	private final static String[] UNARY_METHODS = {"plus","minus","sqrt", "absolute"};
0: 
0: 	private int operatorType;
0: 
0: 
0: 	/**
0: 	 * Initializer for a UnaryArithmeticOperatorNode
0: 	 *
0: 	 * @param operand		The operand of the node
0: 	 */
0: 	public void init(Object operand)
0: 	{
0: 		switch(getNodeType())
0: 		{
0: 			case C_NodeTypes.UNARY_PLUS_OPERATOR_NODE:
0: 				operatorType = UNARY_PLUS;
0: 				break;
0: 			case C_NodeTypes.UNARY_MINUS_OPERATOR_NODE:
0: 				operatorType = UNARY_MINUS;
0: 				break;
0: 			case C_NodeTypes.SQRT_OPERATOR_NODE:
0: 				operatorType = SQRT;
0: 				break;
0: 			case C_NodeTypes.ABSOLUTE_OPERATOR_NODE:
0: 				operatorType = ABSOLUTE;
0: 				break;
0: 			default:
0: 				if (SanityManager.DEBUG)
0: 				{
0: 					SanityManager.THROWASSERT("init for UnaryArithmeticOperator called with wrong nodeType = " + getNodeType());
0: 				}
0: 			    break;
0: 		}
0: 		init(operand, UNARY_OPERATORS[this.operatorType], 
0: 				UNARY_METHODS[this.operatorType]);
0: 	}
0: 
0: 	/**
0: 	 * By default unary operators don't accept ? parameters as operands.
0: 	 * This can be over-ridden for particular unary operators.
0: 	 *
0: 	 *	We throw an exception if the parameter doesn't have a datatype
0: 	 *	assigned to it yet.
0: 	 *
0: 	 * @return	Nothing
0: 	 *
0: 	 * @exception StandardException		Thrown if ?  parameter doesn't
0: 	 *									have a type bound to it yet.
0: 	 *									? parameter where it isn't allowed.
0: 	 */
0: 
0: 	void bindParameter() throws StandardException
0: 	{
0: 		if (operatorType == SQRT || operatorType == ABSOLUTE)
0: 		{
0: 			((ParameterNode) operand).setDescriptor(
0: 				new DataTypeDescriptor(TypeId.getBuiltInTypeId(Types.DOUBLE), true));
0: 		}
0: 		else if (operand.getTypeServices() == null)
0: 		{
0: 			throw StandardException.newException(SQLState.LANG_UNARY_OPERAND_PARM, operator);
0: 		}
0: 	}
0: 	/**
0: 	 * Bind this operator
0: 	 *
0: 	 * @param fromList			The query's FROM list
0: 	 * @param subqueryList		The subquery list being built as we find SubqueryNodes
0: 	 * @param aggregateVector	The aggregate vector being built as we find AggregateNodes
0: 	 *
0: 	 * @return	The new top of the expression tree.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public ValueNode bindExpression(
0: 		FromList	fromList, SubqueryList subqueryList,
0: 		Vector	aggregateVector)
0: 			throws StandardException
0: 	{
0: 		super.bindExpression(fromList, subqueryList,
0: 				aggregateVector);
0: 
0: 		if (operatorType == SQRT || operatorType == ABSOLUTE)
0: 		{
0: 			bindSQRTABS();
0: 		}
0: 		else if (operatorType == UNARY_PLUS || operatorType == UNARY_MINUS)
0: 		{
0: 			TypeId operandType = operand.getTypeId();
0: 
0: 			if ( ! operandType.isNumericTypeId())
0: 			{
0: 			
0: 				throw StandardException.newException(SQLState.LANG_UNARY_ARITHMETIC_BAD_TYPE, 
0: 					(operatorType == UNARY_PLUS) ? "+" : "-", 
0: 					operandType.getSQLTypeName());
0: 			}
0: 		}
0: 		/*
0: 		** The result type of a +, -, SQRT, ABS is the same as its operand.
0: 		*/
0: 		setType(operand.getTypeServices());
0: 		return this;
0: 	}
0: 
0: 	/**
0: 	 * Do code generation for this unary plus operator
0: 	 *
0: 	 * @param acb	The ExpressionClassBuilder for the class we're generating
0: 	 * @param mb	The method the expression will go into
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public void generateExpression(ExpressionClassBuilder acb,
0: 											MethodBuilder mb)
0: 									throws StandardException
0: 	{
0: 		/* Unary + doesn't do anything.  Just return the operand */
0: 		if (operatorType == UNARY_PLUS)
0: 			operand.generateExpression(acb, mb);
0: 		else
0: 			super.generateExpression(acb, mb);
0: 	}
0: 	/**
0: 	 * Bind SQRT or ABS
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	private void bindSQRTABS()
0: 			throws StandardException
0: 	{
0: 		TypeId	operandType;
0: 		int 	jdbcType;
0: 
0: 		/*
0: 		** Check the type of the operand 
0: 		*/
0: 		operandType = operand.getTypeId();
0: 
0: 		/*
0: 	 	 * If the operand is not a build-in type, generate a bound conversion
0: 		 * tree to build-in types.
0: 		 */
0: 		if( ! operandType.systemBuiltIn() )
0: 		{
0: 			operand = operand.genSQLJavaSQLTree();
0: 		}
0: 		/* DB2 doesn't cast string types to numeric types for numeric functions  */
0: 
0: 		jdbcType = operandType.getJDBCTypeId();
0: 
0: 		/* Both SQRT and ABS are only allowed on numeric types */
0: 		if (!operandType.isNumericTypeId())
0: 			throw StandardException.newException(
0: 						SQLState.LANG_UNARY_FUNCTION_BAD_TYPE, 
0: 						getOperatorString(), operandType.getSQLTypeName());
0: 
0: 		/* For SQRT, if operand is not a DOUBLE, convert it to DOUBLE */
0: 		if (operatorType == SQRT && jdbcType != Types.DOUBLE)
0: 		{
0: 			operand = (ValueNode) getNodeFactory().getNode(
0: 					C_NodeTypes.CAST_NODE,
0: 					operand,
0: 					new DataTypeDescriptor(TypeId.getBuiltInTypeId(Types.DOUBLE), true),
0: 					getContextManager());
0: 			((CastNode) operand).bindCastNodeOnly();
0: 		}
0: 	}
0: }
============================================================================