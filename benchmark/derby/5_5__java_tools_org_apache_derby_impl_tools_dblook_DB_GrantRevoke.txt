1:2efac28: /*
3:2efac28: 
1:ebad814:    Derby - Class org.apache.derby.impl.tools.dblook.DB_GrantRevoke
1:2efac28: 
1:20cdca3:    Licensed to the Apache Software Foundation (ASF) under one or more
1:20cdca3:    contributor license agreements.  See the NOTICE file distributed with
1:20cdca3:    this work for additional information regarding copyright ownership.
1:20cdca3:    The ASF licenses this file to you under the Apache License, Version 2.0
1:20cdca3:    (the "License"); you may not use this file except in compliance with
1:20cdca3:    the License.  You may obtain a copy of the License at
1:2efac28: 
1:2efac28:       http://www.apache.org/licenses/LICENSE-2.0
1:2efac28: 
1:2efac28:    Unless required by applicable law or agreed to in writing, software
1:2efac28:    distributed under the License is distributed on an "AS IS" BASIS,
1:2efac28:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:2efac28:    See the License for the specific language governing permissions and
1:2efac28:    limitations under the License.
1:2efac28: 
1:2efac28:  */
1:2efac28: 
1:2efac28: package org.apache.derby.impl.tools.dblook;
1:2efac28: 
1:2efac28: import java.sql.Connection;
1:d1a8391: import java.sql.PreparedStatement;
1:2efac28: import java.sql.Statement;
1:2efac28: import java.sql.ResultSet;
1:2efac28: import java.sql.SQLException;
1:2efac28: 
1:2efac28: import java.util.StringTokenizer;
1:2efac28: 
1:2efac28: import org.apache.derby.tools.dblook;
1:2efac28: 
1:2efac28: public class DB_GrantRevoke {
1:2efac28: 
1:2efac28: 	/** ************************************************
1:dbed020: 	 * Generate Grant and Revoke statements if sqlAuthorization is on
1:2efac28: 	 * 
1:2efac28: 	 * @param conn Connection to use
1:c6892a1: 	 * @param at10_6 True if the database level is 10.6 or higher
1:2efac28: 	 */
1:9ce7492: 	public static void doAuthorizations(Connection conn, boolean at10_6)
1:2efac28: 		throws SQLException {
1:2efac28: 
1:2efac28: 		// First generate table privilege statements
1:2efac28: 		Statement stmt = conn.createStatement();
1:9ce7492:         ResultSet rs;
1:9ce7492: 
1:9ce7492:         if ( at10_6 )
1:9ce7492:         {
1:9ce7492:             // Generate udt privilege statements
1:9ce7492:             rs = stmt.executeQuery("SELECT P.GRANTEE, S.SCHEMANAME, A.ALIAS, P.PERMISSION, P.OBJECTTYPE FROM " +
1:9ce7492:                                    "SYS.SYSPERMS P, SYS.SYSALIASES A, SYS.SYSSCHEMAS S WHERE A.SCHEMAID = " +
1:9ce7492:                                    "S.SCHEMAID AND P.OBJECTID = A.ALIASID AND A.ALIASTYPE='A'");
1:9ce7492:             generateUDTPrivs(rs);
1:9ce7492:             
1:9ce7492:             // Generate sequence privilege statements
1:9ce7492:             rs = stmt.executeQuery("SELECT P.GRANTEE, S.SCHEMANAME, SEQ.SEQUENCENAME, P.PERMISSION, P.OBJECTTYPE FROM " +
1:9ce7492:                                    "SYS.SYSPERMS P, SYS.SYSSEQUENCES SEQ, SYS.SYSSCHEMAS S WHERE SEQ.SCHEMAID = " +
1:9ce7492:                                    "S.SCHEMAID AND P.OBJECTID = SEQ.SEQUENCEID");
1:9ce7492:             generateSequencePrivs(rs);
1:f3c6217:             
1:f3c6217:             // Generate aggregate privilege statements
1:f3c6217:             rs = stmt.executeQuery("SELECT P.GRANTEE, S.SCHEMANAME, A.ALIAS, P.PERMISSION, P.OBJECTTYPE FROM " +
1:f3c6217:                                    "SYS.SYSPERMS P, SYS.SYSALIASES A, SYS.SYSSCHEMAS S WHERE A.SCHEMAID = " +
1:f3c6217:                                    "S.SCHEMAID AND P.OBJECTID = A.ALIASID AND A.ALIASTYPE='G'");
1:f3c6217:             generateAggregatePrivs(rs);
1:9ce7492:         }
1:9ce7492: 
1:9ce7492:         rs = stmt.executeQuery("SELECT GRANTEE, SCHEMANAME, TABLENAME, SELECTPRIV, " +
1:2efac28: 			"DELETEPRIV, INSERTPRIV, UPDATEPRIV, REFERENCESPRIV, TRIGGERPRIV FROM " +
1:2efac28: 			"SYS.SYSTABLEPERMS P, SYS.SYSTABLES T, SYS.SYSSCHEMAS S WHERE T.SCHEMAID = " +
1:2efac28: 			"S.SCHEMAID AND T.TABLEID = P.TABLEID");
1:2efac28: 		generateTablePrivs(rs);
1:2efac28: 
1:2efac28: 		// Generate column privilege statements
1:2efac28: 		rs = stmt.executeQuery("SELECT GRANTEE, SCHEMANAME, TABLENAME, TYPE, COLUMNS FROM " +
1:2efac28: 			"SYS.SYSCOLPERMS P, SYS.SYSTABLES T, SYS.SYSSCHEMAS S WHERE T.SCHEMAID = " +
1:2efac28: 			"S.SCHEMAID AND T.TABLEID = P.TABLEID");
1:2efac28: 		generateColumnPrivs(rs, conn);
1:ef1ecee: 
1:2efac28: 		// Generate routine privilege statements
1:2efac28: 		rs = stmt.executeQuery("SELECT GRANTEE, SCHEMANAME, ALIAS, ALIASTYPE FROM " +
1:2efac28: 			"SYS.SYSROUTINEPERMS P, SYS.SYSALIASES A, SYS.SYSSCHEMAS S WHERE A.SCHEMAID = " +
1:2efac28: 			"S.SCHEMAID AND P.ALIASID = A.ALIASID");
1:2efac28: 		generateRoutinePrivs(rs);
1:2efac28: 
1:2efac28: 		rs.close();
1:2efac28: 		stmt.close();
1:2efac28: 		return;
1:2efac28: 
1:2efac28: 	}
1:2efac28: 
1:2efac28: 	/** ************************************************
1:2efac28: 	 * Generate table privilege statements
1:2efac28: 	 * 
1:2efac28: 	 * @param rs Result set holding required information
1:2efac28: 	 ****/
1:2efac28: 	private static void generateTablePrivs(ResultSet rs)
1:2efac28: 		throws SQLException
1:2efac28: 	{
1:2efac28: 		boolean firstTime = true;
1:2efac28: 		while (rs.next()) {
1:2efac28: 
1:2efac28: 			if (firstTime) {
1:2efac28: 				Logs.reportString("----------------------------------------------");
1:2efac28: 				Logs.reportMessage( "DBLOOK_TablePrivHeader");
1:2efac28: 				Logs.reportString("----------------------------------------------\n");
1:2efac28: 			}
1:2efac28: 
1:ebad814: 			String authName = dblook.addQuotes
1:ebad814: 				(dblook.expandDoubleQuotes(rs.getString(1)));
1:ebad814: 			String schemaName = dblook.addQuotes
1:ebad814: 				(dblook.expandDoubleQuotes(rs.getString(2)));
1:ebad814: 			String tableName = dblook.addQuotes
1:ebad814: 				(dblook.expandDoubleQuotes(rs.getString(3)));
1:2efac28: 			String fullName = schemaName + "." + tableName;
1:2efac28: 
2:2efac28: 			if (dblook.isIgnorableSchema(schemaName))
1:2efac28: 				continue;
1:2efac28: 
1:2efac28: 			Logs.writeToNewDDL(tablePrivStatement(rs, fullName, authName));
1:2efac28: 			Logs.writeStmtEndToNewDDL();
1:2efac28: 			Logs.writeNewlineToNewDDL();
1:2efac28: 			firstTime = false;
1:2efac28: 		}
1:2efac28: 	}
1:2efac28: 
1:2efac28: 	private static String separatorStr(boolean addSeparator)
1:2efac28: 	{
1:2efac28: 		return (addSeparator) ? ", " : "";
1:2efac28: 	}
1:2efac28: 	
1:2efac28: 	/** **************************************************
1:2efac28: 	 * Generate table privilege statement for the current row
1:2efac28: 	 *
1:2efac28: 	 * @param rs 		ResultSet holding tableperm information
1:2efac28: 	 * @param fullName	Table's qualified name
1:2efac28: 	 * @param authName	Authorization id for grant statement
1:2efac28: 	 */
1:2efac28: 	private static String tablePrivStatement(ResultSet rs, String fullName, String authName)
1:2efac28: 		throws SQLException
1:2efac28: 	{
1:2efac28: 		boolean addSeparator = false;
1:2efac28: 		StringBuffer grantStmt = new StringBuffer("GRANT ");
1:2efac28: 
1:2efac28: 		if (rs.getString(4).toUpperCase().equals("Y")) 
1:2efac28: 		{
1:2efac28: 			grantStmt.append("SELECT");
1:2efac28: 			addSeparator = true;
1:2efac28: 		}
1:2efac28: 
1:2efac28: 		if (rs.getString(5).toUpperCase().equals("Y"))
1:2efac28: 		{
1:2efac28: 			grantStmt.append(separatorStr(addSeparator)+ "DELETE");
1:2efac28: 			addSeparator = true;
1:2efac28: 		}
1:2efac28: 
1:2efac28: 		if (rs.getString(6).toUpperCase().equals("Y"))
1:2efac28: 		{
1:2efac28: 			grantStmt.append(separatorStr(addSeparator)+ "INSERT");
1:2efac28: 			addSeparator = true;
1:2efac28: 		}
1:2efac28: 
1:2efac28: 		if (rs.getString(7).toUpperCase().equals("Y"))
1:2efac28: 		{
1:2efac28: 			grantStmt.append(separatorStr(addSeparator)+ "UPDATE");
1:2efac28: 			addSeparator = true;
1:2efac28: 		}
1:2efac28: 
1:2efac28: 		if (rs.getString(8).toUpperCase().equals("Y"))
1:2efac28: 		{
1:2efac28: 			grantStmt.append(separatorStr(addSeparator)+ "REFERENCES");
1:2efac28: 			addSeparator = true;
1:2efac28: 		}
1:2efac28: 
1:2efac28: 		if (rs.getString(9).toUpperCase().equals("Y"))
1:2efac28: 		{
1:2efac28: 			grantStmt.append(separatorStr(addSeparator)+ "TRIGGER");
1:2efac28: 			addSeparator = true;
1:2efac28: 		}
1:2efac28: 
1:2efac28: 		grantStmt.append(" ON " + fullName + " TO " + authName);
1:2efac28: 
1:2efac28: 		return grantStmt.toString();
1:2efac28: 	}
1:2efac28: 
1:f3c6217: 	/** ************************************************
1:2efac28: 	 * Generate column privilege statements
1:2efac28: 	 * 
1:2efac28: 	 * @param rs	ResultSet holding column privilege information
1:2efac28: 	 * @param conn	Connection to use. Used to get another ResultSet
1:2efac28: 	 ****/
1:2efac28: 
1:2efac28: 	private static void generateColumnPrivs(ResultSet rs, Connection conn)
1:2efac28: 		throws SQLException
1:2efac28: 	{
1:d1a8391:         // Statement that gets the names of the columns in a given table.
1:d1a8391:         PreparedStatement columnStmt = conn.prepareStatement(
1:d1a8391:             "SELECT COLUMNNUMBER, COLUMNNAME " +
1:d1a8391:             "FROM SYS.SYSCOLUMNS C, SYS.SYSTABLES T, SYS.SYSSCHEMAS S " +
1:d1a8391:             "WHERE T.TABLEID = C.REFERENCEID and S.SCHEMAID = T.SCHEMAID " +
1:d1a8391:             "AND S.SCHEMANAME = ? AND T.TABLENAME = ? " +
1:d1a8391:             "ORDER BY COLUMNNUMBER");
1:d1a8391: 
1:2efac28: 		boolean firstTime = true;
1:2efac28: 		while (rs.next()) {
1:2efac28: 			if (firstTime) {
1:2efac28: 				Logs.reportString("----------------------------------------------");
1:2efac28: 				Logs.reportMessage( "DBLOOK_ColumnPrivHeader");
1:2efac28: 				Logs.reportString("----------------------------------------------\n");
1:2efac28: 			}
1:2efac28: 
1:d1a8391:             // Auth name will added directly to the generated DDL, so we need
1:d1a8391:             // to quote it.
1:ebad814: 			String authName = dblook.addQuotes
1:ebad814: 				(dblook.expandDoubleQuotes(rs.getString(1)));
1:2efac28: 
1:d1a8391:             // Schema name and table name are parameters to a prepared
1:d1a8391:             // statement, so quoting is not needed.
1:d1a8391:             String schemaName = rs.getString(2);
1:d1a8391:             String tableName = rs.getString(3);
1:d1a8391: 
1:d1a8391:             // isIgnorableSchema, on the other hand, expects the schema name
1:d1a8391:             // to be quoted.
1:d1a8391:             String schemaNameQuoted =
1:d1a8391:                     dblook.addQuotes(dblook.expandDoubleQuotes(schemaName));
1:d1a8391:             if (dblook.isIgnorableSchema(schemaNameQuoted)) {
1:2efac28: 				continue;
1:d1a8391:             }
1:2efac28: 
1:2efac28: 			// Create another resultSet to get column names
1:d1a8391:             columnStmt.setString(1, schemaName);
1:d1a8391:             columnStmt.setString(2, tableName);
1:d1a8391:             ResultSet rsCols = columnStmt.executeQuery();
1:2efac28: 
1:d1a8391:             // The full name will be added directly to the generated GRANT
1:d1a8391:             // statement, so it needs to be quoted.
1:d1a8391:             String fullName = schemaNameQuoted + "." +
1:d1a8391:                     dblook.addQuotes(dblook.expandDoubleQuotes(tableName));
1:2efac28: 
1:2efac28: 			Logs.writeToNewDDL(columnPrivStatement(rs, fullName, authName, rsCols));
1:2efac28: 			Logs.writeStmtEndToNewDDL();
1:2efac28: 			Logs.writeNewlineToNewDDL();
1:2efac28: 			firstTime = false;
1:d1a8391: 
1:d1a8391:             rsCols.close();
1:2efac28: 		}
1:d1a8391: 
1:d1a8391:         columnStmt.close();
1:2efac28: 	}
1:2efac28: 
1:2efac28: 	private static String privTypeToString(String privType)
1:2efac28: 	{
1:2efac28: 		if (privType.equals("S"))
1:2efac28: 			return "SELECT";
1:2efac28: 		else if (privType.equals("R"))
1:2efac28: 			return "REFERENCES";
1:2efac28: 		else if (privType.equals("U"))
1:2efac28: 			return "UPDATE";
1:2efac28: 
1:2efac28: 		// Should throw an exception?
1:2efac28: 		return "";
1:2efac28: 	}
1:2efac28: 
1:9ce7492: 	/** ************************************************
1:2efac28: 	 * Generate one column grant statement
1:2efac28: 	 * 
1:2efac28: 	 * @param columns	List of columns to grant required privs
1:2efac28: 	 * @param rsCols	ResultSet for mapping column numbers to names
1:2efac28: 	 ****/
1:2efac28: 
1:2efac28: 	private static String mapColumnsToNames(String columns, ResultSet rsCols)
1:2efac28: 		throws SQLException
1:2efac28: 	{
1:2efac28: 		StringBuffer colNames = new StringBuffer();
1:2efac28: 		rsCols.next();
1:2efac28: 		int curColumn = 1;
1:2efac28: 		boolean addSeparator = false;
1:2efac28: 
1:2efac28: 		// Strip out outer {} in addition to spaces and comma
1:2efac28: 		StringTokenizer st = new StringTokenizer(columns, " ,{}");
1:2efac28: 		while (st.hasMoreTokens())
1:2efac28: 		{
1:2efac28: 			int colNum = Integer.parseInt(st.nextToken());
1:2efac28: 			while (colNum+1 > curColumn)
1:2efac28: 			{
1:2efac28: 				rsCols.next();
1:2efac28: 				curColumn = rsCols.getInt(1);
1:2efac28: 			}
1:2efac28: 			colNames.append(separatorStr(addSeparator));
1:2efac28: 			addSeparator = true;
1:d1a8391: 
1:d1a8391:             String colName = dblook.addQuotes(
1:d1a8391:                     dblook.expandDoubleQuotes(rsCols.getString(2)));
1:d1a8391:             colNames.append(colName);
1:2efac28: 		}
1:2efac28: 
1:2efac28: 		return colNames.toString();
1:2efac28: 	}
1:2efac28: 
1:2efac28: 	/** ************************************************
1:2efac28: 	 * 
1:2efac28: 	 * @param rs		ResultSet with info for this GRANT statement
1:2efac28: 	 * @param fullName	Full qualified name of the table
1:f2e6696: 	 * @param authName	Authorization name for this GRANT
1:2efac28: 	 * @param rsCols	ResultSet for mapping column numbers to names
1:2efac28: 	 ****/
1:2efac28: 
1:2efac28: 	private static String columnPrivStatement(ResultSet rs, String fullName,
1:2efac28: 			String authName, ResultSet rsCols) throws SQLException
1:2efac28: 	{
1:2efac28: 		StringBuffer grantStmt = new StringBuffer("GRANT ");
1:2efac28: 
1:2efac28: 		String privType = rs.getString(4).toUpperCase();
1:2efac28: 		String columns = rs.getString(5);
1:2efac28: 		grantStmt.append(privTypeToString(privType));
1:2efac28: 		grantStmt.append("(");
1:2efac28: 		grantStmt.append(mapColumnsToNames(columns, rsCols));
1:d1a8391:         grantStmt.append(") ON ");
1:d1a8391:         grantStmt.append(fullName);
1:2efac28: 		grantStmt.append(" TO ");
1:2efac28: 		grantStmt.append(authName);
1:2efac28: 
1:2efac28: 		return grantStmt.toString();
1:2efac28: 	}
1:2efac28: 
1:2efac28: 	/** ************************************************
1:ef1ecee: 	 * Generate udt privilege statements
1:ef1ecee: 	 *
1:ef1ecee: 	 * @param rs ResultSet holding required information
1:ef1ecee: 	 ****/
1:ef1ecee: 	public static void generateUDTPrivs(ResultSet rs) throws SQLException
1:ef1ecee: 	{
1:ef1ecee: 		boolean firstTime = true;
1:ef1ecee: 		while (rs.next()) {
1:ef1ecee: 			String authName = dblook.addQuotes
1:ef1ecee: 				(dblook.expandDoubleQuotes(rs.getString(1)));
1:ef1ecee: 			String schemaName = dblook.addQuotes
1:ef1ecee: 				(dblook.expandDoubleQuotes(rs.getString(2)));
1:ef1ecee: 			String aliasName = dblook.addQuotes
1:ef1ecee: 				(dblook.expandDoubleQuotes(rs.getString(3)));
1:ef1ecee: 			String fullName = schemaName + "." + aliasName;
1:ef1ecee: 			String permission = rs.getString(4);
1:ef1ecee: 			String objectType = rs.getString(5);
1:ef1ecee: 
1:ef1ecee: 			if (dblook.isIgnorableSchema(schemaName))
1:ef1ecee: 				continue;
1:ef1ecee: 
1:ef1ecee: 			if (firstTime) {
1:ef1ecee: 				Logs.reportString("----------------------------------------------");
1:ef1ecee: 				Logs.reportMessage("DBLOOK_UDTPrivHeader");
1:ef1ecee: 				Logs.reportString("----------------------------------------------\n");
1:ef1ecee: 			}
1:ef1ecee: 
1:ef1ecee: 			Logs.writeToNewDDL(genericPrivStatement(fullName, authName, permission, objectType ));
1:ef1ecee: 			Logs.writeStmtEndToNewDDL();
1:ef1ecee: 			Logs.writeNewlineToNewDDL();
1:ef1ecee: 			firstTime = false;
1:ef1ecee: 		}
1:ef1ecee: 	}
1:2efac28: 	/** ************************************************
1:9ce7492: 	 * Generate sequence privilege statements
1:9ce7492: 	 *
1:9ce7492: 	 * @param rs ResultSet holding required information
1:9ce7492: 	 ****/
1:9ce7492: 	public static void generateSequencePrivs(ResultSet rs) throws SQLException
1:9ce7492: 	{
1:9ce7492: 		boolean firstTime = true;
1:9ce7492: 		while (rs.next()) {
1:9ce7492: 			String authName = dblook.addQuotes
1:9ce7492: 				(dblook.expandDoubleQuotes(rs.getString(1)));
1:9ce7492: 			String schemaName = dblook.addQuotes
1:9ce7492: 				(dblook.expandDoubleQuotes(rs.getString(2)));
1:9ce7492: 			String sequenceName = dblook.addQuotes
1:9ce7492: 				(dblook.expandDoubleQuotes(rs.getString(3)));
1:9ce7492: 			String fullName = schemaName + "." + sequenceName;
1:9ce7492: 			String permission = rs.getString(4);
1:9ce7492: 			String objectType = rs.getString(5);
1:9ce7492: 
1:9ce7492: 			if (dblook.isIgnorableSchema(schemaName))
1:9ce7492: 				continue;
1:9ce7492: 
1:9ce7492: 			if (firstTime) {
1:9ce7492: 				Logs.reportString("----------------------------------------------");
1:9ce7492: 				Logs.reportMessage("DBLOOK_SequencePrivHeader");
1:9ce7492: 				Logs.reportString("----------------------------------------------\n");
1:9ce7492: 			}
1:9ce7492: 
1:9ce7492: 			Logs.writeToNewDDL(genericPrivStatement(fullName, authName, permission, objectType ));
1:9ce7492: 			Logs.writeStmtEndToNewDDL();
1:9ce7492: 			Logs.writeNewlineToNewDDL();
1:9ce7492: 			firstTime = false;
1:9ce7492: 		}
1:9ce7492: 	}
1:2efac28: 	/** ************************************************
1:f3c6217: 	 * Generate aggregate privilege statements
1:f3c6217: 	 *
1:f3c6217: 	 * @param rs ResultSet holding required information
1:f3c6217: 	 ****/
1:f3c6217: 	public static void generateAggregatePrivs(ResultSet rs) throws SQLException
1:f3c6217: 	{
1:f3c6217: 		boolean firstTime = true;
1:f3c6217: 		while (rs.next()) {
1:f3c6217: 			String authName = dblook.addQuotes
1:f3c6217: 				(dblook.expandDoubleQuotes(rs.getString(1)));
1:f3c6217: 			String schemaName = dblook.addQuotes
1:f3c6217: 				(dblook.expandDoubleQuotes(rs.getString(2)));
1:f3c6217: 			String aliasName = dblook.addQuotes
1:f3c6217: 				(dblook.expandDoubleQuotes(rs.getString(3)));
1:f3c6217: 			String fullName = schemaName + "." + aliasName;
1:f3c6217: 			String permission = rs.getString(4);
1:f3c6217: 			String objectType = rs.getString(5);
1:f3c6217: 
1:f3c6217: 			if (dblook.isIgnorableSchema(schemaName))
1:f3c6217: 				continue;
1:f3c6217: 
1:f3c6217: 			if (firstTime) {
1:f3c6217: 				Logs.reportString("----------------------------------------------");
1:f3c6217: 				Logs.reportMessage("DBLOOK_AggregatePrivHeader");
1:f3c6217: 				Logs.reportString("----------------------------------------------\n");
1:f3c6217: 			}
1:f3c6217: 
1:f3c6217: 			Logs.writeToNewDDL(genericPrivStatement(fullName, authName, permission, objectType ));
1:f3c6217: 			Logs.writeStmtEndToNewDDL();
1:f3c6217: 			Logs.writeNewlineToNewDDL();
1:f3c6217: 			firstTime = false;
1:f3c6217: 		}
1:f3c6217: 	}
1:ef1ecee: 	private static String genericPrivStatement(String fullName, String authName, String permission, String objectType )
1:ef1ecee: 		throws SQLException
1:ef1ecee: 	{
1:ef1ecee: 		boolean addSeparator = false;
1:ef1ecee: 		StringBuffer grantStmt = new StringBuffer("GRANT " + permission + " ON " + objectType + " " );
1:ef1ecee: 
1:ef1ecee: 		grantStmt.append(fullName);
1:ef1ecee: 		grantStmt.append(" TO ");
1:ef1ecee: 		grantStmt.append(authName);
1:ef1ecee: 
1:ef1ecee: 		return grantStmt.toString();
1:ef1ecee: 	}
1:ef1ecee: 
1:ef1ecee: 	/** ************************************************
1:2efac28: 	 * Generate routine privilege statements
1:2efac28: 	 *
1:2efac28: 	 * @param rs ResultSet holding required information
1:2efac28: 	 ****/
1:2efac28: 	public static void generateRoutinePrivs(ResultSet rs) throws SQLException
1:2efac28: 	{
1:2efac28: 		boolean firstTime = true;
1:2efac28: 		while (rs.next()) {
1:ebad814: 			String authName = dblook.addQuotes
1:ebad814: 				(dblook.expandDoubleQuotes(rs.getString(1)));
1:ebad814: 			String schemaName = dblook.addQuotes
1:ebad814: 				(dblook.expandDoubleQuotes(rs.getString(2)));
1:ebad814: 			String aliasName = dblook.addQuotes
1:ebad814: 				(dblook.expandDoubleQuotes(rs.getString(3)));
1:2efac28: 			String fullName = schemaName + "." + aliasName;
1:2efac28: 			String aliasType = rs.getString(4);
1:2efac28: 
1:2efac28: 			if (dblook.isIgnorableSchema(schemaName))
1:2efac28: 				continue;
1:2efac28: 
1:2efac28: 			// Ignore SYSCS_UTIL privileges as all new databases automatically get them
1:2efac28: 			if (schemaName.equals("\"SYSCS_UTIL\""))
1:2efac28: 				continue;
1:2efac28: 
1:2efac28: 			if (firstTime) {
1:2efac28: 				Logs.reportString("----------------------------------------------");
1:2efac28: 				Logs.reportMessage("DBLOOK_RoutinePrivHeader");
1:2efac28: 				Logs.reportString("----------------------------------------------\n");
1:2efac28: 			}
1:2efac28: 
1:2efac28: 			Logs.writeToNewDDL(routinePrivStatement(fullName, authName, aliasType));
1:2efac28: 			Logs.writeStmtEndToNewDDL();
1:2efac28: 			Logs.writeNewlineToNewDDL();
1:2efac28: 			firstTime = false;
1:2efac28: 		}
1:2efac28: 	}
1:2efac28: 
1:2efac28: 	private static String routinePrivStatement(String fullName, String authName, String aliasType)
1:2efac28: 		throws SQLException
1:2efac28: 	{
1:2efac28: 		boolean addSeparator = false;
1:2efac28: 		StringBuffer grantStmt = new StringBuffer("GRANT EXECUTE ON ");
1:2efac28: 
1:2efac28: 		grantStmt.append((aliasType.equals("P")) ? "PROCEDURE " : "FUNCTION ");
1:2efac28: 		grantStmt.append(fullName);
1:2efac28: 		grantStmt.append(" TO ");
1:2efac28: 		grantStmt.append(authName);
1:2efac28: 
1:2efac28: 		return grantStmt.toString();
1:2efac28: 	}
1:2efac28: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1: 	 * Generate Grant and Revoke statements if sqlAuthorization is on
commit:f3c6217
/////////////////////////////////////////////////////////////////////////
1:             
1:             // Generate aggregate privilege statements
1:             rs = stmt.executeQuery("SELECT P.GRANTEE, S.SCHEMANAME, A.ALIAS, P.PERMISSION, P.OBJECTTYPE FROM " +
1:                                    "SYS.SYSPERMS P, SYS.SYSALIASES A, SYS.SYSSCHEMAS S WHERE A.SCHEMAID = " +
1:                                    "S.SCHEMAID AND P.OBJECTID = A.ALIASID AND A.ALIASTYPE='G'");
1:             generateAggregatePrivs(rs);
/////////////////////////////////////////////////////////////////////////
1: 	/** ************************************************
1: 	 * Generate aggregate privilege statements
1: 	 *
1: 	 * @param rs ResultSet holding required information
1: 	 ****/
1: 	public static void generateAggregatePrivs(ResultSet rs) throws SQLException
1: 	{
1: 		boolean firstTime = true;
1: 		while (rs.next()) {
1: 			String authName = dblook.addQuotes
1: 				(dblook.expandDoubleQuotes(rs.getString(1)));
1: 			String schemaName = dblook.addQuotes
1: 				(dblook.expandDoubleQuotes(rs.getString(2)));
1: 			String aliasName = dblook.addQuotes
1: 				(dblook.expandDoubleQuotes(rs.getString(3)));
1: 			String fullName = schemaName + "." + aliasName;
1: 			String permission = rs.getString(4);
1: 			String objectType = rs.getString(5);
1: 
1: 			if (dblook.isIgnorableSchema(schemaName))
1: 				continue;
1: 
1: 			if (firstTime) {
1: 				Logs.reportString("----------------------------------------------");
1: 				Logs.reportMessage("DBLOOK_AggregatePrivHeader");
1: 				Logs.reportString("----------------------------------------------\n");
1: 			}
1: 
1: 			Logs.writeToNewDDL(genericPrivStatement(fullName, authName, permission, objectType ));
1: 			Logs.writeStmtEndToNewDDL();
1: 			Logs.writeNewlineToNewDDL();
1: 			firstTime = false;
1: 		}
1: 	}
commit:9ce7492
/////////////////////////////////////////////////////////////////////////
0: 	 * @param at10_6 True if the databse level is 10.6 or higher
1: 	public static void doAuthorizations(Connection conn, boolean at10_6)
1:         ResultSet rs;
1: 
1:         if ( at10_6 )
1:         {
1:             // Generate udt privilege statements
1:             rs = stmt.executeQuery("SELECT P.GRANTEE, S.SCHEMANAME, A.ALIAS, P.PERMISSION, P.OBJECTTYPE FROM " +
1:                                    "SYS.SYSPERMS P, SYS.SYSALIASES A, SYS.SYSSCHEMAS S WHERE A.SCHEMAID = " +
1:                                    "S.SCHEMAID AND P.OBJECTID = A.ALIASID AND A.ALIASTYPE='A'");
1:             generateUDTPrivs(rs);
1:             
1:             // Generate sequence privilege statements
1:             rs = stmt.executeQuery("SELECT P.GRANTEE, S.SCHEMANAME, SEQ.SEQUENCENAME, P.PERMISSION, P.OBJECTTYPE FROM " +
1:                                    "SYS.SYSPERMS P, SYS.SYSSEQUENCES SEQ, SYS.SYSSCHEMAS S WHERE SEQ.SCHEMAID = " +
1:                                    "S.SCHEMAID AND P.OBJECTID = SEQ.SEQUENCEID");
1:             generateSequencePrivs(rs);
1:         }
1: 
1:         rs = stmt.executeQuery("SELECT GRANTEE, SCHEMANAME, TABLENAME, SELECTPRIV, " +
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	/** ************************************************
1: 	 * Generate sequence privilege statements
1: 	 *
1: 	 * @param rs ResultSet holding required information
1: 	 ****/
1: 	public static void generateSequencePrivs(ResultSet rs) throws SQLException
1: 	{
1: 		boolean firstTime = true;
1: 		while (rs.next()) {
1: 			String authName = dblook.addQuotes
1: 				(dblook.expandDoubleQuotes(rs.getString(1)));
1: 			String schemaName = dblook.addQuotes
1: 				(dblook.expandDoubleQuotes(rs.getString(2)));
1: 			String sequenceName = dblook.addQuotes
1: 				(dblook.expandDoubleQuotes(rs.getString(3)));
1: 			String fullName = schemaName + "." + sequenceName;
1: 			String permission = rs.getString(4);
1: 			String objectType = rs.getString(5);
1: 
1: 			if (dblook.isIgnorableSchema(schemaName))
1: 				continue;
1: 
1: 			if (firstTime) {
1: 				Logs.reportString("----------------------------------------------");
1: 				Logs.reportMessage("DBLOOK_SequencePrivHeader");
1: 				Logs.reportString("----------------------------------------------\n");
1: 			}
1: 
1: 			Logs.writeToNewDDL(genericPrivStatement(fullName, authName, permission, objectType ));
1: 			Logs.writeStmtEndToNewDDL();
1: 			Logs.writeNewlineToNewDDL();
1: 			firstTime = false;
1: 		}
1: 	}
commit:ef1ecee
/////////////////////////////////////////////////////////////////////////
0: 		// Generate udt privilege statements
0: 		rs = stmt.executeQuery("SELECT P.GRANTEE, S.SCHEMANAME, A.ALIAS, P.PERMISSION, P.OBJECTTYPE FROM " +
0: 			"SYS.SYSPERMS P, SYS.SYSALIASES A, SYS.SYSSCHEMAS S WHERE A.SCHEMAID = " +
0: 			"S.SCHEMAID AND P.OBJECTID = A.ALIASID AND A.ALIASTYPE='A'");
0: 		generateUDTPrivs(rs);
1: 
/////////////////////////////////////////////////////////////////////////
1: 	 * Generate udt privilege statements
1: 	 *
1: 	 * @param rs ResultSet holding required information
1: 	 ****/
1: 	public static void generateUDTPrivs(ResultSet rs) throws SQLException
1: 	{
1: 		boolean firstTime = true;
1: 		while (rs.next()) {
1: 			String authName = dblook.addQuotes
1: 				(dblook.expandDoubleQuotes(rs.getString(1)));
1: 			String schemaName = dblook.addQuotes
1: 				(dblook.expandDoubleQuotes(rs.getString(2)));
1: 			String aliasName = dblook.addQuotes
1: 				(dblook.expandDoubleQuotes(rs.getString(3)));
1: 			String fullName = schemaName + "." + aliasName;
1: 			String permission = rs.getString(4);
1: 			String objectType = rs.getString(5);
1: 
1: 			if (dblook.isIgnorableSchema(schemaName))
1: 				continue;
1: 
1: 			if (firstTime) {
1: 				Logs.reportString("----------------------------------------------");
1: 				Logs.reportMessage("DBLOOK_UDTPrivHeader");
1: 				Logs.reportString("----------------------------------------------\n");
1: 			}
1: 
1: 			Logs.writeToNewDDL(genericPrivStatement(fullName, authName, permission, objectType ));
1: 			Logs.writeStmtEndToNewDDL();
1: 			Logs.writeNewlineToNewDDL();
1: 			firstTime = false;
1: 		}
1: 	}
1: 	private static String genericPrivStatement(String fullName, String authName, String permission, String objectType )
1: 		throws SQLException
1: 	{
1: 		boolean addSeparator = false;
1: 		StringBuffer grantStmt = new StringBuffer("GRANT " + permission + " ON " + objectType + " " );
1: 
1: 		grantStmt.append(fullName);
1: 		grantStmt.append(" TO ");
1: 		grantStmt.append(authName);
1: 
1: 		return grantStmt.toString();
1: 	}
1: 
1: 	/** ************************************************
commit:f2e6696
/////////////////////////////////////////////////////////////////////////
1: 	 * @param authName	Authorization name for this GRANT
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:c6892a1
/////////////////////////////////////////////////////////////////////////
1: 	 * @param at10_6 True if the database level is 10.6 or higher
commit:d1a8391
/////////////////////////////////////////////////////////////////////////
1: import java.sql.PreparedStatement;
/////////////////////////////////////////////////////////////////////////
1:         // Statement that gets the names of the columns in a given table.
1:         PreparedStatement columnStmt = conn.prepareStatement(
1:             "SELECT COLUMNNUMBER, COLUMNNAME " +
1:             "FROM SYS.SYSCOLUMNS C, SYS.SYSTABLES T, SYS.SYSSCHEMAS S " +
1:             "WHERE T.TABLEID = C.REFERENCEID and S.SCHEMAID = T.SCHEMAID " +
1:             "AND S.SCHEMANAME = ? AND T.TABLENAME = ? " +
1:             "ORDER BY COLUMNNUMBER");
1: 
/////////////////////////////////////////////////////////////////////////
1:             // Auth name will added directly to the generated DDL, so we need
1:             // to quote it.
1:             // Schema name and table name are parameters to a prepared
1:             // statement, so quoting is not needed.
1:             String schemaName = rs.getString(2);
1:             String tableName = rs.getString(3);
1: 
1:             // isIgnorableSchema, on the other hand, expects the schema name
1:             // to be quoted.
1:             String schemaNameQuoted =
1:                     dblook.addQuotes(dblook.expandDoubleQuotes(schemaName));
1:             if (dblook.isIgnorableSchema(schemaNameQuoted)) {
1:             }
1:             columnStmt.setString(1, schemaName);
1:             columnStmt.setString(2, tableName);
1:             ResultSet rsCols = columnStmt.executeQuery();
1:             // The full name will be added directly to the generated GRANT
1:             // statement, so it needs to be quoted.
1:             String fullName = schemaNameQuoted + "." +
1:                     dblook.addQuotes(dblook.expandDoubleQuotes(tableName));
1: 
1:             rsCols.close();
1: 
1:         columnStmt.close();
/////////////////////////////////////////////////////////////////////////
1: 
1:             String colName = dblook.addQuotes(
1:                     dblook.expandDoubleQuotes(rsCols.getString(2)));
1:             colNames.append(colName);
/////////////////////////////////////////////////////////////////////////
1:         grantStmt.append(") ON ");
1:         grantStmt.append(fullName);
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:ebad814
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.tools.dblook.DB_GrantRevoke
/////////////////////////////////////////////////////////////////////////
1: 			String authName = dblook.addQuotes
1: 				(dblook.expandDoubleQuotes(rs.getString(1)));
1: 			String schemaName = dblook.addQuotes
1: 				(dblook.expandDoubleQuotes(rs.getString(2)));
1: 			String tableName = dblook.addQuotes
1: 				(dblook.expandDoubleQuotes(rs.getString(3)));
/////////////////////////////////////////////////////////////////////////
1: 			String authName = dblook.addQuotes
1: 				(dblook.expandDoubleQuotes(rs.getString(1)));
/////////////////////////////////////////////////////////////////////////
1: 			String authName = dblook.addQuotes
1: 				(dblook.expandDoubleQuotes(rs.getString(1)));
1: 			String schemaName = dblook.addQuotes
1: 				(dblook.expandDoubleQuotes(rs.getString(2)));
1: 			String aliasName = dblook.addQuotes
1: 				(dblook.expandDoubleQuotes(rs.getString(3)));
author:David Van Couvering
-------------------------------------------------------------------------------
commit:20cdca3
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:2efac28
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Derby - Class org.apache.derby.impl.tools.dblook.DB_Alias
1: 
0:    Copyright 2006 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derby.impl.tools.dblook;
1: 
1: import java.sql.Connection;
1: import java.sql.Statement;
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: 
1: import java.util.StringTokenizer;
1: 
1: import org.apache.derby.tools.dblook;
1: 
1: public class DB_GrantRevoke {
1: 
1: 	/** ************************************************
0: 	 * Generate Grant & Revoke statements if sqlAuthorization is on
1: 	 * 
1: 	 * @param conn Connection to use
1: 	 */
0: 	public static void doAuthorizations(Connection conn)
1: 		throws SQLException {
1: 
1: 		// First generate table privilege statements
1: 		Statement stmt = conn.createStatement();
0: 		ResultSet rs = stmt.executeQuery("SELECT GRANTEE, SCHEMANAME, TABLENAME, SELECTPRIV, " +
1: 			"DELETEPRIV, INSERTPRIV, UPDATEPRIV, REFERENCESPRIV, TRIGGERPRIV FROM " +
1: 			"SYS.SYSTABLEPERMS P, SYS.SYSTABLES T, SYS.SYSSCHEMAS S WHERE T.SCHEMAID = " +
1: 			"S.SCHEMAID AND T.TABLEID = P.TABLEID");
1: 		generateTablePrivs(rs);
1: 
1: 		// Generate column privilege statements
1: 		rs = stmt.executeQuery("SELECT GRANTEE, SCHEMANAME, TABLENAME, TYPE, COLUMNS FROM " +
1: 			"SYS.SYSCOLPERMS P, SYS.SYSTABLES T, SYS.SYSSCHEMAS S WHERE T.SCHEMAID = " +
1: 			"S.SCHEMAID AND T.TABLEID = P.TABLEID");
1: 		generateColumnPrivs(rs, conn);
1: 
1: 		// Generate routine privilege statements
1: 		rs = stmt.executeQuery("SELECT GRANTEE, SCHEMANAME, ALIAS, ALIASTYPE FROM " +
1: 			"SYS.SYSROUTINEPERMS P, SYS.SYSALIASES A, SYS.SYSSCHEMAS S WHERE A.SCHEMAID = " +
1: 			"S.SCHEMAID AND P.ALIASID = A.ALIASID");
1: 		generateRoutinePrivs(rs);
1: 
1: 		rs.close();
1: 		stmt.close();
1: 		return;
1: 
1: 	}
1: 
1: 	/** ************************************************
1: 	 * Generate table privilege statements
1: 	 * 
1: 	 * @param rs Result set holding required information
1: 	 ****/
1: 	private static void generateTablePrivs(ResultSet rs)
1: 		throws SQLException
1: 	{
1: 		boolean firstTime = true;
1: 		while (rs.next()) {
1: 
1: 			if (firstTime) {
1: 				Logs.reportString("----------------------------------------------");
1: 				Logs.reportMessage( "DBLOOK_TablePrivHeader");
1: 				Logs.reportString("----------------------------------------------\n");
1: 			}
1: 
0: 			String authName = rs.getString(1);
0: 			String schemaName = dblook.addQuotes(dblook.expandDoubleQuotes(rs.getString(2)));
0: 			String tableName = dblook.addQuotes(dblook.expandDoubleQuotes(rs.getString(3)));
1: 			String fullName = schemaName + "." + tableName;
1: 
1: 			if (dblook.isIgnorableSchema(schemaName))
1: 				continue;
1: 
1: 			Logs.writeToNewDDL(tablePrivStatement(rs, fullName, authName));
1: 			Logs.writeStmtEndToNewDDL();
1: 			Logs.writeNewlineToNewDDL();
1: 			firstTime = false;
1: 		}
1: 	}
1: 
1: 	private static String separatorStr(boolean addSeparator)
1: 	{
1: 		return (addSeparator) ? ", " : "";
1: 	}
1: 	
1: 	/** **************************************************
1: 	 * Generate table privilege statement for the current row
1: 	 *
1: 	 * @param rs 		ResultSet holding tableperm information
1: 	 * @param fullName	Table's qualified name
1: 	 * @param authName	Authorization id for grant statement
1: 	 */
1: 	private static String tablePrivStatement(ResultSet rs, String fullName, String authName)
1: 		throws SQLException
1: 	{
1: 		boolean addSeparator = false;
1: 		StringBuffer grantStmt = new StringBuffer("GRANT ");
1: 
1: 		if (rs.getString(4).toUpperCase().equals("Y")) 
1: 		{
1: 			grantStmt.append("SELECT");
1: 			addSeparator = true;
1: 		}
1: 
1: 		if (rs.getString(5).toUpperCase().equals("Y"))
1: 		{
1: 			grantStmt.append(separatorStr(addSeparator)+ "DELETE");
1: 			addSeparator = true;
1: 		}
1: 
1: 		if (rs.getString(6).toUpperCase().equals("Y"))
1: 		{
1: 			grantStmt.append(separatorStr(addSeparator)+ "INSERT");
1: 			addSeparator = true;
1: 		}
1: 
1: 		if (rs.getString(7).toUpperCase().equals("Y"))
1: 		{
1: 			grantStmt.append(separatorStr(addSeparator)+ "UPDATE");
1: 			addSeparator = true;
1: 		}
1: 
1: 		if (rs.getString(8).toUpperCase().equals("Y"))
1: 		{
1: 			grantStmt.append(separatorStr(addSeparator)+ "REFERENCES");
1: 			addSeparator = true;
1: 		}
1: 
1: 		if (rs.getString(9).toUpperCase().equals("Y"))
1: 		{
1: 			grantStmt.append(separatorStr(addSeparator)+ "TRIGGER");
1: 			addSeparator = true;
1: 		}
1: 
1: 		grantStmt.append(" ON " + fullName + " TO " + authName);
1: 
1: 		return grantStmt.toString();
1: 	}
1: 
1: 	/** ************************************************
1: 	 * Generate column privilege statements
1: 	 * 
1: 	 * @param rs	ResultSet holding column privilege information
1: 	 * @param conn	Connection to use. Used to get another ResultSet
1: 	 ****/
1: 
1: 	private static void generateColumnPrivs(ResultSet rs, Connection conn)
1: 		throws SQLException
1: 	{
1: 		boolean firstTime = true;
1: 		while (rs.next()) {
1: 			if (firstTime) {
1: 				Logs.reportString("----------------------------------------------");
1: 				Logs.reportMessage( "DBLOOK_ColumnPrivHeader");
1: 				Logs.reportString("----------------------------------------------\n");
1: 			}
1: 
0: 			String authName = rs.getString(1);
0: 			String schemaName = dblook.expandDoubleQuotes(rs.getString(2));
0: 			String tableName = dblook.expandDoubleQuotes(rs.getString(3));
1: 
1: 			if (dblook.isIgnorableSchema(schemaName))
1: 				continue;
1: 
1: 			// Create another resultSet to get column names
0: 			Statement stmtCols = conn.createStatement();
0: 			String queryCols = "SELECT COLUMNNUMBER, COLUMNNAME " +
0: 				"FROM SYS.SYSCOLUMNS C, SYS.SYSTABLES T, SYS.SYSSCHEMAS S " +
0: 				"WHERE T.TABLEID = C.REFERENCEID and S.SCHEMAID = T.SCHEMAID "+
0: 				"and T.TABLENAME = '"+tableName+"' AND SCHEMANAME = '"+schemaName +
0: 				"' ORDER BY COLUMNNUMBER";
1: 
0: 			ResultSet rsCols= stmtCols.executeQuery(queryCols);
0: 			String fullName = dblook.addQuotes(schemaName) + "." + dblook.addQuotes(tableName);
1: 
1: 			Logs.writeToNewDDL(columnPrivStatement(rs, fullName, authName, rsCols));
1: 			Logs.writeStmtEndToNewDDL();
1: 			Logs.writeNewlineToNewDDL();
1: 			firstTime = false;
1: 		}
1: 	}
1: 
1: 	private static String privTypeToString(String privType)
1: 	{
1: 		if (privType.equals("S"))
1: 			return "SELECT";
1: 		else if (privType.equals("R"))
1: 			return "REFERENCES";
1: 		else if (privType.equals("U"))
1: 			return "UPDATE";
1: 
1: 		// Should throw an exception?
1: 		return "";
1: 	}
1: 
1: 	/** ************************************************
1: 	 * Generate one column grant statement
1: 	 * 
1: 	 * @param columns	List of columns to grant required privs
1: 	 * @param rsCols	ResultSet for mapping column numbers to names
1: 	 ****/
1: 
1: 	private static String mapColumnsToNames(String columns, ResultSet rsCols)
1: 		throws SQLException
1: 	{
1: 		StringBuffer colNames = new StringBuffer();
1: 		rsCols.next();
1: 		int curColumn = 1;
1: 		boolean addSeparator = false;
1: 
1: 		// Strip out outer {} in addition to spaces and comma
1: 		StringTokenizer st = new StringTokenizer(columns, " ,{}");
1: 		while (st.hasMoreTokens())
1: 		{
1: 			int colNum = Integer.parseInt(st.nextToken());
1: 			while (colNum+1 > curColumn)
1: 			{
1: 				rsCols.next();
1: 				curColumn = rsCols.getInt(1);
1: 			}
1: 			colNames.append(separatorStr(addSeparator));
0: 			colNames.append(rsCols.getString(2));
1: 			addSeparator = true;
1: 		}
1: 
1: 		return colNames.toString();
1: 	}
1: 
1: 	/** ************************************************
1: 	 * 
1: 	 * @param rs		ResultSet with info for this GRANT statement
1: 	 * @param fullName	Full qualified name of the table
0: 	 * @param rs		authorization name for this GRANT
1: 	 * @param rsCols	ResultSet for mapping column numbers to names
1: 	 ****/
1: 
1: 	private static String columnPrivStatement(ResultSet rs, String fullName,
1: 			String authName, ResultSet rsCols) throws SQLException
1: 	{
1: 		StringBuffer grantStmt = new StringBuffer("GRANT ");
1: 
1: 		String privType = rs.getString(4).toUpperCase();
1: 		String columns = rs.getString(5);
1: 		grantStmt.append(privTypeToString(privType));
1: 		grantStmt.append("(");
1: 		grantStmt.append(mapColumnsToNames(columns, rsCols));
0: 		grantStmt.append(")");
1: 		grantStmt.append(" TO ");
1: 		grantStmt.append(authName);
1: 
1: 		return grantStmt.toString();
1: 	}
1: 
1: 	/** ************************************************
1: 	 * Generate routine privilege statements
1: 	 *
1: 	 * @param rs ResultSet holding required information
1: 	 ****/
1: 	public static void generateRoutinePrivs(ResultSet rs) throws SQLException
1: 	{
1: 		boolean firstTime = true;
1: 		while (rs.next()) {
0: 			String authName = rs.getString(1);
0: 			String schemaName = dblook.addQuotes(dblook.expandDoubleQuotes(rs.getString(2)));
0: 			String aliasName = dblook.addQuotes(dblook.expandDoubleQuotes(rs.getString(3)));
1: 			String fullName = schemaName + "." + aliasName;
1: 			String aliasType = rs.getString(4);
1: 
1: 			if (dblook.isIgnorableSchema(schemaName))
1: 				continue;
1: 
1: 			// Ignore SYSCS_UTIL privileges as all new databases automatically get them
1: 			if (schemaName.equals("\"SYSCS_UTIL\""))
1: 				continue;
1: 
1: 			if (firstTime) {
1: 				Logs.reportString("----------------------------------------------");
1: 				Logs.reportMessage("DBLOOK_RoutinePrivHeader");
1: 				Logs.reportString("----------------------------------------------\n");
1: 			}
1: 
1: 			Logs.writeToNewDDL(routinePrivStatement(fullName, authName, aliasType));
1: 			Logs.writeStmtEndToNewDDL();
1: 			Logs.writeNewlineToNewDDL();
1: 			firstTime = false;
1: 		}
1: 	}
1: 
1: 	private static String routinePrivStatement(String fullName, String authName, String aliasType)
1: 		throws SQLException
1: 	{
1: 		boolean addSeparator = false;
1: 		StringBuffer grantStmt = new StringBuffer("GRANT EXECUTE ON ");
1: 
1: 		grantStmt.append((aliasType.equals("P")) ? "PROCEDURE " : "FUNCTION ");
1: 		grantStmt.append(fullName);
1: 		grantStmt.append(" TO ");
1: 		grantStmt.append(authName);
1: 
1: 		return grantStmt.toString();
1: 	}
1: }
============================================================================