1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.diag.StatementDuration
1:345de35: 
1:2f36947:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2f36947:    contributor license agreements.  See the NOTICE file distributed with
1:2f36947:    this work for additional information regarding copyright ownership.
1:2f36947:    The ASF licenses this file to You under the Apache License, Version 2.0
1:2f36947:    (the "License"); you may not use this file except in compliance with
1:2f36947:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
5:eac0369: 
2:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.diag;
1:eac0369: 
1:eac0369: import java.io.BufferedReader;
1:eac0369: import java.io.FileNotFoundException;
1:eac0369: import java.io.InputStream;
1:eac0369: import java.io.InputStreamReader;
1:eac0369: import java.io.FileInputStream;
1:431cefd: import java.security.PrivilegedAction;
1:431cefd: import java.security.AccessController;
1:70ff9b0: import java.text.SimpleDateFormat;
1:eac0369: import java.util.Hashtable;
1:eac0369: import java.sql.ResultSetMetaData;
1:eac0369: import java.sql.SQLException;
1:eac0369: import java.sql.Timestamp;
1:eac0369: import java.sql.Types;
1:38586ad: import java.util.Locale;
1:eac0369: import org.apache.derby.vti.VTITemplate;
1:431cefd: import org.apache.derby.iapi.error.StandardException;
1:eac0369: import org.apache.derby.iapi.sql.ResultColumnDescriptor;
1:eac0369: import org.apache.derby.impl.jdbc.EmbedResultSetMetaData;
1:b1f84c1: import org.apache.derby.iapi.reference.Limits;
1:431cefd: import org.apache.derby.iapi.reference.Property;
1:eac0369: import org.apache.derby.iapi.util.StringUtil;
1:eac0369: 
2:eac0369: /**
1:eac0369: 	
1:eac0369: 
1:eac0369: 	StatementDuration is a virtual table which
1:eac0369: 	can be used to analyze the execution duration of the statements
1:eac0369: 	of "interest" in db2j.<!-- -->log or a specified file when
1:eac0369: 	db2j.<!-- -->language.<!-- -->logStatementText=true.
1:eac0369: 	
1:eac0369: 
1:eac0369: 	<P>A limitation is that, for each transaction ID,
1:eac0369: 	a row will not be returned for the last	statement with that
1:eac0369: 	transaction id.  (Transaction IDs change within a connection after
1:eac0369: 	a commit or rollback, if the transaction that just ended modified data.)
1:eac0369: 
1:eac0369:     <P>The execution duration is the time between the beginning of
1:eac0369: 	execution of two successive statements.  There are a number of reasons
1:eac0369: 	why this time may not be accurate.  The duration could include time
1:eac0369: 	spent in the application waiting for user input, doing other work, etc.
1:eac0369: 	It may also only include a portion of the actual execution time, if
1:eac0369: 	the application executes a new statement before draining the previous
1:eac0369: 	open ResultSet.  StatementDuration can be used to get a rough sense of
1:eac0369: 	where the bottlenecks in an application's JDBC code are.
1:eac0369: 
1:eac0369: 	<P>The StatementDuration virtual table has the following columns:
1:eac0369: 	<UL><LI>TS varchar(26) - not nullable.  The timestamp of the statement.</LI>
1:eac0369: 	<LI>THREADID varchar(80) - not nullable.  The thread name.</LI>
1:eac0369: 	<LI>XID varchar(15) - not nullable.  The transaction ID.</LI>
1:eac0369: 	<LI>LOGTEXT long varchar - nullable.  Text of the statement or commit or rollback.</LI>
1:eac0369: 	<LI>DURATION varchar(10) - not nullable.  Duration, in milliseconds, of the statement.</LI>
1:eac0369: 	</UL>
1:eac0369: 
1:eac0369:  */
1:eac0369: public class StatementDuration extends VTITemplate
1:eac0369: {
1:eac0369: 	/*
1:eac0369: 	** private 
1:eac0369: 	*/
1:eac0369: 	private boolean gotFile;
1:eac0369: 	private InputStreamReader inputFileStreamReader;
1:eac0369: 	private InputStream inputStream;
1:eac0369: 	private BufferedReader bufferedReader;
1:eac0369: 	private String inputFileName;
1:0758fb6: 	private Hashtable<String,String[]> hashTable;
1:eac0369: 
1:eac0369: 	// Variables for current row
1:eac0369: 	private String line;
1:70ff9b0: 	private int endTimestampIndex;
1:eac0369: 	private int threadIndex;
1:eac0369: 	private int xidIndex;
1:eac0369: 	private int lccidIndex;
1:eac0369: 	private String[] currentRow;
1:eac0369: 
1:70ff9b0: 	private static final String END_TIMESTAMP = " Thread";
1:eac0369: 	private static final String BEGIN_THREAD_STRING = "[";
1:eac0369: 	private static final String END_THREAD_STRING = "]";
1:eac0369: 	private static final String BEGIN_XID_STRING = "= ";
1:eac0369: 	private static final String END_XID_STRING = ")";
1:eac0369: 	private static final String BEGIN_EXECUTING_STRING = "Executing prepared";
1:eac0369: 	private static final String END_EXECUTING_STRING = " :End prepared";
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		StatementDuration() accesses the error log in
1:eac0369: 		derby.system.home, if set, otherwise it looks in the current directory.
1:eac0369: 		StatementDuration('filename') will access the specified
1:eac0369: 		file name.
1:eac0369: 	 */
1:431cefd: 	public StatementDuration()  throws StandardException
1:eac0369: 	{
1:431cefd:         DiagUtil.checkAccess();
1:431cefd: 
1:0758fb6:         final String home = AccessController.doPrivileged
1:431cefd:             (
1:0758fb6:              new PrivilegedAction<String>()
1:431cefd:              {
1:0758fb6:                  public String run()
1:431cefd:                  {
1:431cefd:                      return System.getProperty( Property.SYSTEM_HOME_PROPERTY );
1:431cefd:                  }
1:431cefd:              }
1:431cefd:              );
1:eac0369: 
1:eac0369: 		inputFileName = "derby.log";
1:eac0369: 
1:eac0369: 		if (home != null)
1:eac0369: 		{
1:eac0369: 			inputFileName = home + "/" + inputFileName;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:431cefd: 	public StatementDuration(String inputFileName)  throws StandardException
1:eac0369: 	{
1:431cefd:         DiagUtil.checkAccess();
1:431cefd: 
1:eac0369: 		this.inputFileName = inputFileName;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		@see java.sql.ResultSet#getMetaData
1:eac0369: 	 */
1:eac0369: 	public ResultSetMetaData getMetaData()
1:eac0369: 	{
1:eac0369: 		return metadata;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		@see java.sql.ResultSet#next
1:eac0369: 		@exception SQLException If database access error occurs.
1:eac0369: 	 */
1:eac0369: 	public boolean next() throws SQLException
1:eac0369: 	{
1:eac0369: 		if (! gotFile)
1:eac0369: 		{
1:eac0369: 			gotFile = true;
1:eac0369: 		    try 
1:eac0369: 			{
1:eac0369: 		        inputFileStreamReader = new InputStreamReader(new FileInputStream(inputFileName));
1:eac0369: 				bufferedReader = new BufferedReader(inputFileStreamReader, 32*1024);
1:eac0369: 			} 
1:eac0369: 			catch (FileNotFoundException ex) 
1:eac0369: 			{
1:eac0369: 				throw new SQLException(ex.getMessage());
1:eac0369: 			}
1:eac0369: 
1:0758fb6: 			hashTable = new Hashtable<String,String[]>();
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		while (true)
1:eac0369: 		{
1:eac0369: 			try
1:eac0369: 			{
1:eac0369: 				line = bufferedReader.readLine();
1:eac0369: 			}
1:eac0369: 			catch (java.io.IOException ioe)
1:eac0369: 			{
1:eac0369: 				throw new SQLException(ioe.getMessage());
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			if (line == null)
1:eac0369: 			{
1:eac0369: 				return false;
1:eac0369: 			}
1:eac0369: 
1:70ff9b0:             endTimestampIndex = line.indexOf( END_TIMESTAMP );
1:eac0369: 			threadIndex = line.indexOf(BEGIN_THREAD_STRING);
1:eac0369: 			xidIndex = line.indexOf(BEGIN_XID_STRING);
1:eac0369: 			lccidIndex = line.indexOf(BEGIN_XID_STRING, xidIndex + 1);
1:eac0369: 
1:70ff9b0: 			if (endTimestampIndex != -1 && threadIndex != -1 && xidIndex != -1)
1:eac0369: 			{
1:eac0369: 				/* Build a row */
1:eac0369: 				String[] newRow = new String[6];
1:eac0369: 				for (int index = 1;
1:eac0369: 					 index <= 5;
1:eac0369: 					 index++)
1:eac0369: 				{
1:eac0369: 					newRow[index - 1] = setupColumn(index);
1:eac0369: 				}
1:eac0369: 
1:eac0369: 				/* NOTE: We need to use the LCCID as the key
1:eac0369: 				 */
1:0758fb6: 				String[] previousRow = hashTable.put(newRow[3],
1:eac0369: 												   newRow);
1:eac0369: 				if (previousRow == null)
1:eac0369: 				{
1:eac0369: 					continue;
1:eac0369: 				}
1:eac0369: 
1:0758fb6: 				currentRow = previousRow;
1:eac0369: 				
1:eac0369: 				/* Figure out the duration. */
1:70ff9b0: 				Timestamp endTs = stringToTimestamp( newRow[0] );
1:eac0369: 				long end = endTs.getTime() + endTs.getNanos() / 1000000;
1:70ff9b0: 				Timestamp startTs = stringToTimestamp( currentRow[0] );
1:eac0369: 				long start = startTs.getTime() + startTs.getNanos() / 1000000;
1:eac0369: 				currentRow[5] = Long.toString(end - start);
1:eac0369: 
1:eac0369: 				return true;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:70ff9b0:     // Turn a string into a Timestamp
1:70ff9b0:     private Timestamp   stringToTimestamp( String raw ) throws SQLException
1:70ff9b0:     {
1:70ff9b0:         //
1:70ff9b0:         // We have to handle two timestamp formats.
1:70ff9b0:         //
1:70ff9b0:         // 1) Logged timestamps look like this before 10.7 and the fix introduced by DERBY-4752:
1:70ff9b0:         //
1:70ff9b0:         //     2006-12-15 16:14:58.280 GMT
1:70ff9b0:         //
1:70ff9b0:         // 2) From 10.7 onward, logged timestamps look like this:
1:70ff9b0:         //
1:70ff9b0:         //     Fri Aug 26 09:28:00 PDT 2011
1:70ff9b0:         //
1:70ff9b0:         String  trimmed = raw.trim();
1:70ff9b0: 
1:70ff9b0:         // if we're dealing with a pre-10.7 timestamp
1:70ff9b0:         if ( !Character.isDigit( trimmed.charAt( trimmed.length() -1 ) ) )
1:70ff9b0:         {
1:70ff9b0:             // strip off the trailing timezone, which Timestamp does not expect
1:70ff9b0: 
1:70ff9b0:             trimmed = trimmed.substring( 0, trimmed.length() - 4 );
1:70ff9b0:             
1:70ff9b0:             return Timestamp.valueOf( trimmed );
1:70ff9b0:         }
1:70ff9b0:         else
1:70ff9b0:         {
1:70ff9b0:             //
1:38586ad:             // From 10.7 onward, the logged timestamp was formatted by
1:38586ad:             // Date.toString(), which is always formatted using the pattern
1:38586ad:             // specified below, and always in US locale.
1:70ff9b0:             //
1:38586ad:             SimpleDateFormat sdf =
1:38586ad:                 new SimpleDateFormat("EEE MMM dd HH:mm:ss zzz yyyy", Locale.US);
1:70ff9b0: 
1:70ff9b0:             try {
1:70ff9b0:                 return new Timestamp( sdf.parse( trimmed ).getTime() );
1:70ff9b0:             }
1:70ff9b0:             catch (Exception e)
1:70ff9b0:             {
1:70ff9b0:                 throw new SQLException( e.getMessage() );
1:70ff9b0:             }
1:70ff9b0:         }
1:70ff9b0:     }
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		@see java.sql.ResultSet#close
1:eac0369: 	 */
1:eac0369: 	public void close()
1:eac0369: 	{
1:eac0369: 		if (bufferedReader != null)
1:eac0369: 		{
1:eac0369: 			try
1:eac0369: 			{
1:eac0369: 				bufferedReader.close();
1:eac0369: 				inputFileStreamReader.close();
1:eac0369: 			}
1:eac0369: 			catch (java.io.IOException ioe)
1:eac0369: 			{
1:eac0369: 				// eat exceptions during close;
1:eac0369: 			}
1:eac0369: 			finally
1:eac0369: 			{
1:eac0369: 				bufferedReader = null;
1:eac0369: 				inputFileStreamReader = null;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		All columns in StatementDuration VTI have String data types.
1:eac0369: 		@see java.sql.ResultSet#getString
1:eac0369: 		@exception SQLException If database access error occurs.
1:eac0369: 	 */
1:eac0369: 	public String getString(int columnNumber)
1:eac0369: 		throws SQLException
1:eac0369: 	{
1:eac0369: 		return currentRow[columnNumber - 1];
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	private String setupColumn(int columnNumber)
1:eac0369: 		throws SQLException
1:eac0369: 	{
1:eac0369: 		switch (columnNumber)
1:eac0369: 		{
1:eac0369: 			case 1:
1:70ff9b0: 				return line.substring(0, endTimestampIndex);
1:eac0369: 
1:eac0369: 			case 2:
1:eac0369: 				return line.substring(threadIndex + 1, line.indexOf(END_THREAD_STRING));
1:eac0369: 
1:eac0369: 			case 3:
1:eac0369: 				return line.substring(xidIndex + 2, line.indexOf(END_XID_STRING, xidIndex));
1:eac0369: 
1:eac0369: 			case 4:
1:eac0369: 				return line.substring(lccidIndex + 2, line.indexOf(END_XID_STRING, lccidIndex));
1:eac0369: 
1:eac0369: 			case 5:
1:eac0369: 				/* Executing prepared statement is a special case as
1:eac0369: 				 * it could span multiple lines
1:eac0369: 				 */
1:a9c3863: 				StringBuffer output = new StringBuffer(64);
1:eac0369: 				if (line.indexOf(BEGIN_EXECUTING_STRING) == -1)
1:eac0369: 				{
1:a9c3863: 					output.append(line.substring(line.indexOf(END_XID_STRING, lccidIndex) + 3));
1:eac0369: 				}
1:eac0369: 				else
1:eac0369: 				{
1:eac0369: 
1:eac0369: 				/* We need to build string until we find the end of the text */
1:eac0369: 				int endIndex = line.indexOf(END_EXECUTING_STRING, lccidIndex);
1:eac0369: 				if (endIndex == -1)
1:eac0369: 				{
1:a9c3863: 					output.append(line.substring(line.indexOf(END_XID_STRING, lccidIndex) + 3));
1:eac0369: 				}
1:eac0369: 				else
1:eac0369: 				{
1:a9c3863: 					output.append(line.substring(line.indexOf(END_XID_STRING, lccidIndex) + 3,
1:a9c3863: 											endIndex));
1:eac0369: 				}
1:eac0369: 
1:eac0369: 				while (endIndex == -1)
1:eac0369: 				{
1:eac0369: 					try
1:eac0369: 					{
1:eac0369: 						line = bufferedReader.readLine();
1:eac0369: 					}
1:eac0369: 					catch (java.io.IOException ioe)
1:eac0369: 					{
1:eac0369: 						throw new SQLException("Error reading file " + ioe);
1:eac0369: 					}
1:eac0369: 					endIndex = line.indexOf(END_EXECUTING_STRING);
1:eac0369: 					if (endIndex == -1)
1:eac0369: 					{
1:a9c3863: 						output.append(line);
1:eac0369: 					}
1:eac0369: 					else
1:eac0369: 					{
1:a9c3863: 						output.append(line.substring(0, endIndex));
1:eac0369: 					}
1:eac0369: 				}
1:eac0369: 				}
1:eac0369: 
1:a9c3863: 				return StringUtil.truncate(output.toString(), Limits.DB2_VARCHAR_MAXWIDTH);
1:eac0369: 
1:eac0369: 			default:
1:eac0369: 				return null;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		@see java.sql.ResultSet#wasNull
1:eac0369: 	 */
1:eac0369: 	public boolean wasNull()
1:eac0369: 	{
1:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Metadata
1:eac0369: 	*/
1:eac0369: 	private static final ResultColumnDescriptor[] columnInfo = {
1:eac0369: 
1:70ff9b0: 		EmbedResultSetMetaData.getResultColumnDescriptor("TS",        Types.VARCHAR, false, 29),
1:eac0369: 		EmbedResultSetMetaData.getResultColumnDescriptor("THREADID",  Types.VARCHAR, false, 80),
1:eac0369: 		EmbedResultSetMetaData.getResultColumnDescriptor("XID",       Types.VARCHAR, false, 15),
1:eac0369: 		EmbedResultSetMetaData.getResultColumnDescriptor("LCCID",     Types.VARCHAR, false, 10),
1:b1f84c1: 		EmbedResultSetMetaData.getResultColumnDescriptor("LOGTEXT",   Types.VARCHAR, true, Limits.DB2_VARCHAR_MAXWIDTH),
1:eac0369: 		EmbedResultSetMetaData.getResultColumnDescriptor("DURATION",  Types.VARCHAR, false, 10),
1:eac0369: 	};
1:eac0369: 	
1:8514aa2:     private static final ResultSetMetaData metadata =
1:8514aa2:         new EmbedResultSetMetaData(columnInfo);
1:eac0369: }
1:eac0369: 
============================================================================
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:8514aa2
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private static final ResultSetMetaData metadata =
1:         new EmbedResultSetMetaData(columnInfo);
commit:38586ad
/////////////////////////////////////////////////////////////////////////
1: import java.util.Locale;
/////////////////////////////////////////////////////////////////////////
1:             // From 10.7 onward, the logged timestamp was formatted by
1:             // Date.toString(), which is always formatted using the pattern
1:             // specified below, and always in US locale.
1:             SimpleDateFormat sdf =
1:                 new SimpleDateFormat("EEE MMM dd HH:mm:ss zzz yyyy", Locale.US);
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:5570eb0
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.impl.jdbc.EmbedResultSetMetaData40;
/////////////////////////////////////////////////////////////////////////
0: 	private static final ResultSetMetaData metadata = new EmbedResultSetMetaData40(columnInfo);
commit:0758fb6
/////////////////////////////////////////////////////////////////////////
1: 	private Hashtable<String,String[]> hashTable;
/////////////////////////////////////////////////////////////////////////
1:         final String home = AccessController.doPrivileged
1:              new PrivilegedAction<String>()
1:                  public String run()
/////////////////////////////////////////////////////////////////////////
1: 			hashTable = new Hashtable<String,String[]>();
/////////////////////////////////////////////////////////////////////////
1: 				String[] previousRow = hashTable.put(newRow[3],
1: 				currentRow = previousRow;
commit:431cefd
/////////////////////////////////////////////////////////////////////////
1: import java.security.PrivilegedAction;
1: import java.security.AccessController;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.reference.Property;
/////////////////////////////////////////////////////////////////////////
1: 	public StatementDuration()  throws StandardException
1:         DiagUtil.checkAccess();
1: 
0:         final String home = (String)AccessController.doPrivileged
1:             (
0:              new PrivilegedAction()
1:              {
0:                  public Object run()
1:                  {
1:                      return System.getProperty( Property.SYSTEM_HOME_PROPERTY );
1:                  }
1:              }
1:              );
/////////////////////////////////////////////////////////////////////////
1: 	public StatementDuration(String inputFileName)  throws StandardException
1:         DiagUtil.checkAccess();
1: 
commit:70ff9b0
/////////////////////////////////////////////////////////////////////////
1: import java.text.SimpleDateFormat;
/////////////////////////////////////////////////////////////////////////
1: 	private int endTimestampIndex;
1: 	private static final String END_TIMESTAMP = " Thread";
/////////////////////////////////////////////////////////////////////////
1:             endTimestampIndex = line.indexOf( END_TIMESTAMP );
1: 			if (endTimestampIndex != -1 && threadIndex != -1 && xidIndex != -1)
/////////////////////////////////////////////////////////////////////////
1: 				Timestamp endTs = stringToTimestamp( newRow[0] );
1: 				Timestamp startTs = stringToTimestamp( currentRow[0] );
/////////////////////////////////////////////////////////////////////////
1:     // Turn a string into a Timestamp
1:     private Timestamp   stringToTimestamp( String raw ) throws SQLException
1:     {
1:         //
1:         // We have to handle two timestamp formats.
1:         //
1:         // 1) Logged timestamps look like this before 10.7 and the fix introduced by DERBY-4752:
1:         //
1:         //     2006-12-15 16:14:58.280 GMT
1:         //
1:         // 2) From 10.7 onward, logged timestamps look like this:
1:         //
1:         //     Fri Aug 26 09:28:00 PDT 2011
1:         //
1:         String  trimmed = raw.trim();
1: 
1:         // if we're dealing with a pre-10.7 timestamp
1:         if ( !Character.isDigit( trimmed.charAt( trimmed.length() -1 ) ) )
1:         {
1:             // strip off the trailing timezone, which Timestamp does not expect
1: 
1:             trimmed = trimmed.substring( 0, trimmed.length() - 4 );
1:             
1:             return Timestamp.valueOf( trimmed );
1:         }
1:         else
1:         {
1:             //
0:             // From 10.7 onward, the logged timestamp was formatted by Date.toString().
1:             //
0:             SimpleDateFormat    sdf = new SimpleDateFormat( "EEE MMM dd HH:mm:ss zzz yyyy" );
1: 
1:             try {
1:                 return new Timestamp( sdf.parse( trimmed ).getTime() );
1:             }
1:             catch (Exception e)
1:             {
1:                 throw new SQLException( e.getMessage() );
1:             }
1:         }
1:     }
/////////////////////////////////////////////////////////////////////////
1: 				return line.substring(0, endTimestampIndex);
/////////////////////////////////////////////////////////////////////////
1: 		EmbedResultSetMetaData.getResultColumnDescriptor("TS",        Types.VARCHAR, false, 29),
author:Lily Wei
-------------------------------------------------------------------------------
commit:a9c3863
/////////////////////////////////////////////////////////////////////////
1: 				StringBuffer output = new StringBuffer(64);
1: 					output.append(line.substring(line.indexOf(END_XID_STRING, lccidIndex) + 3));
/////////////////////////////////////////////////////////////////////////
1: 					output.append(line.substring(line.indexOf(END_XID_STRING, lccidIndex) + 3));
1: 					output.append(line.substring(line.indexOf(END_XID_STRING, lccidIndex) + 3,
1: 											endIndex));
/////////////////////////////////////////////////////////////////////////
1: 						output.append(line);
1: 						output.append(line.substring(0, endIndex));
1: 				return StringUtil.truncate(output.toString(), Limits.DB2_VARCHAR_MAXWIDTH);
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:2f36947
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:b1f84c1
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.reference.Limits;
/////////////////////////////////////////////////////////////////////////
0: 				output = StringUtil.truncate(output, Limits.DB2_VARCHAR_MAXWIDTH);
/////////////////////////////////////////////////////////////////////////
1: 		EmbedResultSetMetaData.getResultColumnDescriptor("LOGTEXT",   Types.VARCHAR, true, Limits.DB2_VARCHAR_MAXWIDTH),
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.diag.StatementDuration
1: 
0:    Copyright 2000, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:4dede3b
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.diag
0:    (C) Copyright IBM Corp. 2000, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.diag;
1: 
1: import java.io.BufferedReader;
1: import java.io.FileNotFoundException;
1: import java.io.InputStream;
1: import java.io.InputStreamReader;
1: import java.io.FileInputStream;
1: 
1: import java.util.Hashtable;
0: import java.util.Enumeration;
0: import java.util.Properties;
1: import java.sql.ResultSetMetaData;
1: import java.sql.SQLException;
1: import java.sql.Timestamp;
1: import java.sql.Types;
1: import org.apache.derby.vti.VTITemplate;
1: import org.apache.derby.iapi.sql.ResultColumnDescriptor;
1: import org.apache.derby.impl.jdbc.EmbedResultSetMetaData;
0: import org.apache.derby.iapi.reference.DB2Limit;
1: import org.apache.derby.iapi.util.StringUtil;
1: 
1: /**
1: 	
1: 
1: 	StatementDuration is a virtual table which
1: 	can be used to analyze the execution duration of the statements
1: 	of "interest" in db2j.<!-- -->log or a specified file when
1: 	db2j.<!-- -->language.<!-- -->logStatementText=true.
1: 	
1: 
1: 	<P>A limitation is that, for each transaction ID,
1: 	a row will not be returned for the last	statement with that
1: 	transaction id.  (Transaction IDs change within a connection after
1: 	a commit or rollback, if the transaction that just ended modified data.)
1: 
1:     <P>The execution duration is the time between the beginning of
1: 	execution of two successive statements.  There are a number of reasons
1: 	why this time may not be accurate.  The duration could include time
1: 	spent in the application waiting for user input, doing other work, etc.
1: 	It may also only include a portion of the actual execution time, if
1: 	the application executes a new statement before draining the previous
1: 	open ResultSet.  StatementDuration can be used to get a rough sense of
1: 	where the bottlenecks in an application's JDBC code are.
1: 
1: 	<P>The StatementDuration virtual table has the following columns:
1: 	<UL><LI>TS varchar(26) - not nullable.  The timestamp of the statement.</LI>
1: 	<LI>THREADID varchar(80) - not nullable.  The thread name.</LI>
1: 	<LI>XID varchar(15) - not nullable.  The transaction ID.</LI>
1: 	<LI>LOGTEXT long varchar - nullable.  Text of the statement or commit or rollback.</LI>
1: 	<LI>DURATION varchar(10) - not nullable.  Duration, in milliseconds, of the statement.</LI>
1: 	</UL>
1: 
1:  */
1: public class StatementDuration extends VTITemplate
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2000_2004;
1: 	/*
1: 	** private 
1: 	*/
1: 	private boolean gotFile;
1: 	private InputStreamReader inputFileStreamReader;
1: 	private InputStream inputStream;
1: 	private BufferedReader bufferedReader;
1: 	private String inputFileName;
0: 	private Hashtable hashTable;
1: 
1: 	// Variables for current row
1: 	private String line;
0: 	private int gmtIndex;
1: 	private int threadIndex;
1: 	private int xidIndex;
1: 	private int lccidIndex;
1: 	private String[] currentRow;
1: 
0: 	private static final String GMT_STRING = " GMT";
1: 	private static final String BEGIN_THREAD_STRING = "[";
1: 	private static final String END_THREAD_STRING = "]";
1: 	private static final String BEGIN_XID_STRING = "= ";
1: 	private static final String END_XID_STRING = ")";
1: 	private static final String BEGIN_EXECUTING_STRING = "Executing prepared";
1: 	private static final String END_EXECUTING_STRING = " :End prepared";
1: 
1: 
1: 	/**
1: 		StatementDuration() accesses the error log in
1: 		derby.system.home, if set, otherwise it looks in the current directory.
1: 		StatementDuration('filename') will access the specified
1: 		file name.
1: 	 */
0: 	public StatementDuration()
1: 	{
0: 		String home = System.getProperty("derby.system.home");
1: 
1: 		inputFileName = "derby.log";
1: 
1: 		if (home != null)
1: 		{
1: 			inputFileName = home + "/" + inputFileName;
1: 		}
1: 	}
1: 
0: 	public StatementDuration(String inputFileName)
1: 	{
1: 		this.inputFileName = inputFileName;
1: 	}
1: 
1: 	/**
1: 		@see java.sql.ResultSet#getMetaData
1: 	 */
1: 	public ResultSetMetaData getMetaData()
1: 	{
1: 		return metadata;
1: 	}
1: 
1: 	/**
1: 		@see java.sql.ResultSet#next
1: 		@exception SQLException If database access error occurs.
1: 	 */
1: 	public boolean next() throws SQLException
1: 	{
1: 		if (! gotFile)
1: 		{
1: 			gotFile = true;
1: 		    try 
1: 			{
1: 		        inputFileStreamReader = new InputStreamReader(new FileInputStream(inputFileName));
1: 				bufferedReader = new BufferedReader(inputFileStreamReader, 32*1024);
1: 			} 
1: 			catch (FileNotFoundException ex) 
1: 			{
1: 				throw new SQLException(ex.getMessage());
1: 			}
1: 
0: 			hashTable = new Hashtable();
1: 		}
1: 
1: 		while (true)
1: 		{
1: 			try
1: 			{
1: 				line = bufferedReader.readLine();
1: 			}
1: 			catch (java.io.IOException ioe)
1: 			{
1: 				throw new SQLException(ioe.getMessage());
1: 			}
1: 
1: 			if (line == null)
1: 			{
1: 				return false;
1: 			}
1: 
0: 			gmtIndex = line.indexOf(GMT_STRING);
1: 			threadIndex = line.indexOf(BEGIN_THREAD_STRING);
1: 			xidIndex = line.indexOf(BEGIN_XID_STRING);
1: 			lccidIndex = line.indexOf(BEGIN_XID_STRING, xidIndex + 1);
1: 
0: 			if (gmtIndex != -1 && threadIndex != -1)
1: 			{
1: 				/* Build a row */
1: 				String[] newRow = new String[6];
1: 				for (int index = 1;
1: 					 index <= 5;
1: 					 index++)
1: 				{
1: 					newRow[index - 1] = setupColumn(index);
1: 				}
1: 
1: 				/* NOTE: We need to use the LCCID as the key
1: 				 */
0: 				Object previousRow = hashTable.put(newRow[3],
1: 												   newRow);
1: 				if (previousRow == null)
1: 				{
1: 					continue;
1: 				}
1: 
0: 				currentRow = (String[]) previousRow;
1: 				
1: 				/* Figure out the duration. */
0: 				Timestamp endTs = Timestamp.valueOf(newRow[0]);
1: 				long end = endTs.getTime() + endTs.getNanos() / 1000000;
0: 				Timestamp startTs = Timestamp.valueOf(currentRow[0]);
1: 				long start = startTs.getTime() + startTs.getNanos() / 1000000;
1: 				currentRow[5] = Long.toString(end - start);
1: 
1: 				return true;
1: 			}
1: 		}
1: 	}
1: 
1: 	/**
1: 		@see java.sql.ResultSet#close
1: 	 */
1: 	public void close()
1: 	{
1: 		if (bufferedReader != null)
1: 		{
1: 			try
1: 			{
1: 				bufferedReader.close();
1: 				inputFileStreamReader.close();
1: 			}
1: 			catch (java.io.IOException ioe)
1: 			{
1: 				// eat exceptions during close;
1: 			}
1: 			finally
1: 			{
1: 				bufferedReader = null;
1: 				inputFileStreamReader = null;
1: 			}
1: 		}
1: 	}
1: 
1: 	/**
1: 		All columns in StatementDuration VTI have String data types.
1: 		@see java.sql.ResultSet#getString
1: 		@exception SQLException If database access error occurs.
1: 	 */
1: 	public String getString(int columnNumber)
1: 		throws SQLException
1: 	{
1: 		return currentRow[columnNumber - 1];
1: 	}
1: 
1: 	private String setupColumn(int columnNumber)
1: 		throws SQLException
1: 	{
1: 		switch (columnNumber)
1: 		{
1: 			case 1:
0: 				return line.substring(0, gmtIndex);
1: 
1: 			case 2:
1: 				return line.substring(threadIndex + 1, line.indexOf(END_THREAD_STRING));
1: 
1: 			case 3:
1: 				return line.substring(xidIndex + 2, line.indexOf(END_XID_STRING, xidIndex));
1: 
1: 			case 4:
1: 				return line.substring(lccidIndex + 2, line.indexOf(END_XID_STRING, lccidIndex));
1: 
1: 			case 5:
1: 				/* Executing prepared statement is a special case as
1: 				 * it could span multiple lines
1: 				 */
0: 				String output;
1: 				if (line.indexOf(BEGIN_EXECUTING_STRING) == -1)
1: 				{
0: 					output = line.substring(line.indexOf(END_XID_STRING, lccidIndex) + 3);
1: 				}
1: 				else
1: 				{
1: 
1: 				/* We need to build string until we find the end of the text */
1: 				int endIndex = line.indexOf(END_EXECUTING_STRING, lccidIndex);
1: 				if (endIndex == -1)
1: 				{
0: 					output = line.substring(line.indexOf(END_XID_STRING, lccidIndex) + 3);
1: 				}
1: 				else
1: 				{
0: 					output = line.substring(line.indexOf(END_XID_STRING, lccidIndex) + 3,
0: 											endIndex);
1: 				}
1: 
1: 				while (endIndex == -1)
1: 				{
1: 					try
1: 					{
1: 						line = bufferedReader.readLine();
1: 					}
1: 					catch (java.io.IOException ioe)
1: 					{
1: 						throw new SQLException("Error reading file " + ioe);
1: 					}
1: 					endIndex = line.indexOf(END_EXECUTING_STRING);
1: 					if (endIndex == -1)
1: 					{
0: 						output = output + line;
1: 					}
1: 					else
1: 					{
0: 						output = output + line.substring(0, endIndex);
1: 					}
1: 				}
1: 				}
1: 
0: 				output = StringUtil.truncate(output, DB2Limit.DB2_VARCHAR_MAXWIDTH);
1: 
1: 
0: 				return output;
1: 
1: 			default:
1: 				return null;
1: 		}
1: 	}
1: 
1: 
1: 	/**
1: 		@see java.sql.ResultSet#wasNull
1: 	 */
1: 	public boolean wasNull()
1: 	{
1: 		return false;
1: 	}
1: 
1: 	/*
1: 	** Metadata
1: 	*/
1: 	private static final ResultColumnDescriptor[] columnInfo = {
1: 
0: 		EmbedResultSetMetaData.getResultColumnDescriptor("TS",        Types.VARCHAR, false, 26),
1: 		EmbedResultSetMetaData.getResultColumnDescriptor("THREADID",  Types.VARCHAR, false, 80),
1: 		EmbedResultSetMetaData.getResultColumnDescriptor("XID",       Types.VARCHAR, false, 15),
1: 		EmbedResultSetMetaData.getResultColumnDescriptor("LCCID",     Types.VARCHAR, false, 10),
0: 		EmbedResultSetMetaData.getResultColumnDescriptor("LOGTEXT",   Types.VARCHAR, true, DB2Limit.DB2_VARCHAR_MAXWIDTH),
1: 		EmbedResultSetMetaData.getResultColumnDescriptor("DURATION",  Types.VARCHAR, false, 10),
1: 	};
1: 	
0: 	private static final ResultSetMetaData metadata = new EmbedResultSetMetaData(columnInfo);
1: }
1: 
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.diag
0:    (C) Copyright IBM Corp. 2000, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.diag;
0: 
0: import java.io.BufferedReader;
0: import java.io.FileNotFoundException;
0: import java.io.InputStream;
0: import java.io.InputStreamReader;
0: import java.io.FileInputStream;
0: 
0: import java.util.Hashtable;
0: import java.util.Enumeration;
0: import java.util.Properties;
0: import java.sql.ResultSetMetaData;
0: import java.sql.SQLException;
0: import java.sql.Timestamp;
0: import java.sql.Types;
0: import org.apache.derby.vti.VTITemplate;
0: import org.apache.derby.iapi.sql.ResultColumnDescriptor;
0: import org.apache.derby.impl.jdbc.EmbedResultSetMetaData;
0: import org.apache.derby.iapi.reference.DB2Limit;
0: import org.apache.derby.iapi.util.StringUtil;
0: 
0: /**
0: 	
0: 
0: 	StatementDuration is a virtual table which
0: 	can be used to analyze the execution duration of the statements
0: 	of "interest" in db2j.<!-- -->log or a specified file when
0: 	db2j.<!-- -->language.<!-- -->logStatementText=true.
0: 	
0: 
0: 	<P>A limitation is that, for each transaction ID,
0: 	a row will not be returned for the last	statement with that
0: 	transaction id.  (Transaction IDs change within a connection after
0: 	a commit or rollback, if the transaction that just ended modified data.)
0: 
0:     <P>The execution duration is the time between the beginning of
0: 	execution of two successive statements.  There are a number of reasons
0: 	why this time may not be accurate.  The duration could include time
0: 	spent in the application waiting for user input, doing other work, etc.
0: 	It may also only include a portion of the actual execution time, if
0: 	the application executes a new statement before draining the previous
0: 	open ResultSet.  StatementDuration can be used to get a rough sense of
0: 	where the bottlenecks in an application's JDBC code are.
0: 
0: 	<P>The StatementDuration virtual table has the following columns:
0: 	<UL><LI>TS varchar(26) - not nullable.  The timestamp of the statement.</LI>
0: 	<LI>THREADID varchar(80) - not nullable.  The thread name.</LI>
0: 	<LI>XID varchar(15) - not nullable.  The transaction ID.</LI>
0: 	<LI>LOGTEXT long varchar - nullable.  Text of the statement or commit or rollback.</LI>
0: 	<LI>DURATION varchar(10) - not nullable.  Duration, in milliseconds, of the statement.</LI>
0: 	</UL>
0: 
0:  */
0: public class StatementDuration extends VTITemplate
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2000_2004;
0: 	/*
0: 	** private 
0: 	*/
0: 	private boolean gotFile;
0: 	private InputStreamReader inputFileStreamReader;
0: 	private InputStream inputStream;
0: 	private BufferedReader bufferedReader;
0: 	private String inputFileName;
0: 	private Hashtable hashTable;
0: 
0: 	// Variables for current row
0: 	private String line;
0: 	private int gmtIndex;
0: 	private int threadIndex;
0: 	private int xidIndex;
0: 	private int lccidIndex;
0: 	private String[] currentRow;
0: 
0: 	private static final String GMT_STRING = " GMT";
0: 	private static final String BEGIN_THREAD_STRING = "[";
0: 	private static final String END_THREAD_STRING = "]";
0: 	private static final String BEGIN_XID_STRING = "= ";
0: 	private static final String END_XID_STRING = ")";
0: 	private static final String BEGIN_EXECUTING_STRING = "Executing prepared";
0: 	private static final String END_EXECUTING_STRING = " :End prepared";
0: 
0: 
0: 	/**
0: 		StatementDuration() accesses the error log in
0: 		derby.system.home, if set, otherwise it looks in the current directory.
0: 		StatementDuration('filename') will access the specified
0: 		file name.
0: 	 */
0: 	public StatementDuration()
0: 	{
0: 		String home = System.getProperty("derby.system.home");
0: 
0: 		inputFileName = "derby.log";
0: 
0: 		if (home != null)
0: 		{
0: 			inputFileName = home + "/" + inputFileName;
0: 		}
0: 	}
0: 
0: 	public StatementDuration(String inputFileName)
0: 	{
0: 		this.inputFileName = inputFileName;
0: 	}
0: 
0: 	/**
0: 		@see java.sql.ResultSet#getMetaData
0: 	 */
0: 	public ResultSetMetaData getMetaData()
0: 	{
0: 		return metadata;
0: 	}
0: 
0: 	/**
0: 		@see java.sql.ResultSet#next
0: 		@exception SQLException If database access error occurs.
0: 	 */
0: 	public boolean next() throws SQLException
0: 	{
0: 		if (! gotFile)
0: 		{
0: 			gotFile = true;
0: 		    try 
0: 			{
0: 		        inputFileStreamReader = new InputStreamReader(new FileInputStream(inputFileName));
0: 				bufferedReader = new BufferedReader(inputFileStreamReader, 32*1024);
0: 			} 
0: 			catch (FileNotFoundException ex) 
0: 			{
0: 				throw new SQLException(ex.getMessage());
0: 			}
0: 
0: 			hashTable = new Hashtable();
0: 		}
0: 
0: 		while (true)
0: 		{
0: 			try
0: 			{
0: 				line = bufferedReader.readLine();
0: 			}
0: 			catch (java.io.IOException ioe)
0: 			{
0: 				throw new SQLException(ioe.getMessage());
0: 			}
0: 
0: 			if (line == null)
0: 			{
0: 				return false;
0: 			}
0: 
0: 			gmtIndex = line.indexOf(GMT_STRING);
0: 			threadIndex = line.indexOf(BEGIN_THREAD_STRING);
0: 			xidIndex = line.indexOf(BEGIN_XID_STRING);
0: 			lccidIndex = line.indexOf(BEGIN_XID_STRING, xidIndex + 1);
0: 
0: 			if (gmtIndex != -1 && threadIndex != -1)
0: 			{
0: 				/* Build a row */
0: 				String[] newRow = new String[6];
0: 				for (int index = 1;
0: 					 index <= 5;
0: 					 index++)
0: 				{
0: 					newRow[index - 1] = setupColumn(index);
0: 				}
0: 
0: 				/* NOTE: We need to use the LCCID as the key
0: 				 */
0: 				Object previousRow = hashTable.put(newRow[3],
0: 												   newRow);
0: 				if (previousRow == null)
0: 				{
0: 					continue;
0: 				}
0: 
0: 				currentRow = (String[]) previousRow;
0: 				
0: 				/* Figure out the duration. */
0: 				Timestamp endTs = Timestamp.valueOf(newRow[0]);
0: 				long end = endTs.getTime() + endTs.getNanos() / 1000000;
0: 				Timestamp startTs = Timestamp.valueOf(currentRow[0]);
0: 				long start = startTs.getTime() + startTs.getNanos() / 1000000;
0: 				currentRow[5] = Long.toString(end - start);
0: 
0: 				return true;
0: 			}
0: 		}
0: 	}
0: 
0: 	/**
0: 		@see java.sql.ResultSet#close
0: 	 */
0: 	public void close()
0: 	{
0: 		if (bufferedReader != null)
0: 		{
0: 			try
0: 			{
0: 				bufferedReader.close();
0: 				inputFileStreamReader.close();
0: 			}
0: 			catch (java.io.IOException ioe)
0: 			{
0: 				// eat exceptions during close;
0: 			}
0: 			finally
0: 			{
0: 				bufferedReader = null;
0: 				inputFileStreamReader = null;
0: 			}
0: 		}
0: 	}
0: 
0: 	/**
0: 		All columns in StatementDuration VTI have String data types.
0: 		@see java.sql.ResultSet#getString
0: 		@exception SQLException If database access error occurs.
0: 	 */
0: 	public String getString(int columnNumber)
0: 		throws SQLException
0: 	{
0: 		return currentRow[columnNumber - 1];
0: 	}
0: 
0: 	private String setupColumn(int columnNumber)
0: 		throws SQLException
0: 	{
0: 		switch (columnNumber)
0: 		{
0: 			case 1:
0: 				return line.substring(0, gmtIndex);
0: 
0: 			case 2:
0: 				return line.substring(threadIndex + 1, line.indexOf(END_THREAD_STRING));
0: 
0: 			case 3:
0: 				return line.substring(xidIndex + 2, line.indexOf(END_XID_STRING, xidIndex));
0: 
0: 			case 4:
0: 				return line.substring(lccidIndex + 2, line.indexOf(END_XID_STRING, lccidIndex));
0: 
0: 			case 5:
0: 				/* Executing prepared statement is a special case as
0: 				 * it could span multiple lines
0: 				 */
0: 				String output;
0: 				if (line.indexOf(BEGIN_EXECUTING_STRING) == -1)
0: 				{
0: 					output = line.substring(line.indexOf(END_XID_STRING, lccidIndex) + 3);
0: 				}
0: 				else
0: 				{
0: 
0: 				/* We need to build string until we find the end of the text */
0: 				int endIndex = line.indexOf(END_EXECUTING_STRING, lccidIndex);
0: 				if (endIndex == -1)
0: 				{
0: 					output = line.substring(line.indexOf(END_XID_STRING, lccidIndex) + 3);
0: 				}
0: 				else
0: 				{
0: 					output = line.substring(line.indexOf(END_XID_STRING, lccidIndex) + 3,
0: 											endIndex);
0: 				}
0: 
0: 				while (endIndex == -1)
0: 				{
0: 					try
0: 					{
0: 						line = bufferedReader.readLine();
0: 					}
0: 					catch (java.io.IOException ioe)
0: 					{
0: 						throw new SQLException("Error reading file " + ioe);
0: 					}
0: 					endIndex = line.indexOf(END_EXECUTING_STRING);
0: 					if (endIndex == -1)
0: 					{
0: 						output = output + line;
0: 					}
0: 					else
0: 					{
0: 						output = output + line.substring(0, endIndex);
0: 					}
0: 				}
0: 				}
0: 
0: 				output = StringUtil.truncate(output, DB2Limit.DB2_VARCHAR_MAXWIDTH);
0: 
0: 
0: 				return output;
0: 
0: 			default:
0: 				return null;
0: 		}
0: 	}
0: 
0: 
0: 	/**
0: 		@see java.sql.ResultSet#wasNull
0: 	 */
0: 	public boolean wasNull()
0: 	{
0: 		return false;
0: 	}
0: 
0: 	/*
0: 	** Metadata
0: 	*/
0: 	private static final ResultColumnDescriptor[] columnInfo = {
0: 
0: 		EmbedResultSetMetaData.getResultColumnDescriptor("TS",        Types.VARCHAR, false, 26),
0: 		EmbedResultSetMetaData.getResultColumnDescriptor("THREADID",  Types.VARCHAR, false, 80),
0: 		EmbedResultSetMetaData.getResultColumnDescriptor("XID",       Types.VARCHAR, false, 15),
0: 		EmbedResultSetMetaData.getResultColumnDescriptor("LCCID",     Types.VARCHAR, false, 10),
0: 		EmbedResultSetMetaData.getResultColumnDescriptor("LOGTEXT",   Types.VARCHAR, true, DB2Limit.DB2_VARCHAR_MAXWIDTH),
0: 		EmbedResultSetMetaData.getResultColumnDescriptor("DURATION",  Types.VARCHAR, false, 10),
0: 	};
0: 	
0: 	private static final ResultSetMetaData metadata = new EmbedResultSetMetaData(columnInfo);
0: }
0: 
============================================================================