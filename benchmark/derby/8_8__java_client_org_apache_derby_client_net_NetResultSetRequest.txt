1:33776ff: /*
45:33776ff: 
1:33776ff:    Derby - Class org.apache.derby.client.net.NetResultSetRequest
1:33776ff: 
1:59bf37d:    Licensed to the Apache Software Foundation (ASF) under one or more
1:59bf37d:    contributor license agreements.  See the NOTICE file distributed with
1:59bf37d:    this work for additional information regarding copyright ownership.
1:59bf37d:    The ASF licenses this file to You under the Apache License, Version 2.0
1:59bf37d:    (the "License"); you may not use this file except in compliance with
1:59bf37d:    the License.  You may obtain a copy of the License at
1:33776ff: 
1:33776ff:       http://www.apache.org/licenses/LICENSE-2.0
1:33776ff: 
1:33776ff:    Unless required by applicable law or agreed to in writing, software
1:33776ff:    distributed under the License is distributed on an "AS IS" BASIS,
1:33776ff:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:33776ff:    See the License for the specific language governing permissions and
1:33776ff:    limitations under the License.
1:33776ff: 
1:33776ff: */
1:33776ff: 
1:33776ff: package org.apache.derby.client.net;
1:33776ff: 
1:69e3d06: import java.sql.ResultSet;
1:70f7692: import org.apache.derby.client.am.ColumnMetaData;
1:69e3d06: import org.apache.derby.client.am.ClientResultSet;
1:33776ff: import org.apache.derby.client.am.Section;
1:33776ff: import org.apache.derby.client.am.SqlException;
1:f271471: import org.apache.derby.client.am.ClientMessageId;
1:f271471: 
1:f271471: import org.apache.derby.shared.common.reference.SQLState;
1:33776ff: 
1:0326967: class NetResultSetRequest extends NetStatementRequest
1:70f7692:         implements ResultSetRequestInterface {
1:0326967: 
1:0326967:     NetResultSetRequest(NetAgent netAgent, int bufferSize) {
1:1451af7:         super(netAgent, bufferSize);
19:33776ff:     }
1:33776ff: 
1:70f7692:     //----------------------------- entry points ---------------------------------
1:70f7692:     public void writeFetch(NetResultSet resultSet,
1:70f7692:                            Section section,
1:70f7692:                            int fetchSize) throws SqlException {
1:70f7692:         // - for forward-only cursors we do not send qryrowset on OPNQRY, fetchSize is ignored.
1:70f7692:         //   but qryrowset is sent on EXCSQLSTT for a stored procedure call.
1:70f7692:         boolean sendQryrowset =
1:95049cf:                 ((NetStatement) resultSet.statement_.getMaterialStatement()).qryrowsetSentOnOpnqry_;
1:33776ff: 
1:70f7692:         boolean sendRtnextdta = false;
1:69e3d06: 
1:69e3d06:         if (sendQryrowset && resultSet.resultSetType_ ==
1:69e3d06:                 ResultSet.TYPE_FORWARD_ONLY &&
1:69e3d06:             ((NetCursor) resultSet.cursor_).hasLobs_) {
1:69e3d06: 
1:70f7692:             fetchSize = 1;
1:70f7692:             resultSet.fetchSize_ = 1;
1:70f7692:             sendRtnextdta = true;
1:70f7692:             ((NetCursor) resultSet.cursor_).rtnextrow_ = false;
1:70f7692:         }
1:70f7692:         // if one of the result sets returned from a stored procedure is scrollable,
1:70f7692:         // then we set netStatement_.qryrowsetSentOnOpnqry_ to true even though we didn't really
1:70f7692:         // send a qryrowset on excsqlstt for sqlam >= 7.  this is ok for scrollable cursors,
1:70f7692:         // but will cause a problem for forward-only cursors.  Because if fetchSize was never
1:70f7692:         // set, we will send qryrowset(0), which will cause a syntaxrm.
1:70f7692:         else if (resultSet.fetchSize_ == 0) {
1:70f7692:             sendQryrowset = false;
1:70f7692:         }
1:33776ff: 
1:70f7692:         buildCNTQRY(section,
1:70f7692:                 sendQryrowset,
1:70f7692:                 resultSet.queryInstanceIdentifier_,
1:70f7692:                 fetchSize,
1:70f7692:                 sendRtnextdta);
1:33776ff: 
1:70f7692:         buildOUTOVR(resultSet,
1:70f7692:                 resultSet.resultSetMetaData_,
1:70f7692:                 resultSet.firstOutovrBuilt_,
1:70f7692:                 ((NetCursor) resultSet.cursor_).hasLobs_);
1:70f7692:     }
1:33776ff: 
1:70f7692:     public void writeScrollableFetch(NetResultSet resultSet,
5:33776ff:                                      Section section,
1:70f7692:                                      int fetchSize,
2:33776ff:                                      int orientation,
1:70f7692:                                      long rowToFetch,
1:70f7692:                                      boolean resetQueryBlocks) throws SqlException {
1:70f7692:         int protocolOrientation = computePROTOCOLOrientation(orientation);
1:33776ff: 
1:70f7692:         // - for sensitive-static cursors:
1:70f7692:         //     * qryrowset must be sent on opnqry to indicate to the server that the cursor is
1:70f7692:         //       going to be used in a scrollable fashion.  (sqlam<7)
1:70f7692:         //     * if qryrowset is sent on opnqry, then it must be sent on all subsequent cntqry's
1:70f7692:         // - for sensitive-dynamic non-rowset cursors: (we should never be in this case)
1:70f7692:         //     * qryrowset is NOT ALLOWED on cntqry's
1:70f7692:         // - for rowset cursors:
1:70f7692:         //     * qryrowset is optional.  it is ignored on opnqry.  if not sent on cntqry,
1:70f7692:         //       then the fetch is going fetch next row as opposed to fetch next rowset.
1:70f7692:         boolean sendQryrowset =
1:69e3d06:             resultSet.isRowsetCursor_ ||
1:69e3d06:             (((NetStatement)resultSet.statement_.getMaterialStatement()).
1:69e3d06:                  qryrowsetSentOnOpnqry_ &&
1:69e3d06:              (resultSet.sensitivity_ ==
1:69e3d06:               ClientResultSet.sensitivity_sensitive_static__ ||
1:69e3d06:               ((NetCursor)resultSet.cursor_).blocking_));
1:33776ff: 
1:70f7692:         buildScrollCNTQRY(protocolOrientation,
1:70f7692:                 rowToFetch,
1:70f7692:                 section,
1:70f7692:                 sendQryrowset,
1:70f7692:                 resultSet.queryInstanceIdentifier_,
1:70f7692:                 fetchSize,
1:70f7692:                 resetQueryBlocks);
1:70f7692: 
1:70f7692:         buildOUTOVR(resultSet,
1:70f7692:                 resultSet.resultSetMetaData_,
1:70f7692:                 resultSet.firstOutovrBuilt_,
1:70f7692:                 ((NetCursor) resultSet.cursor_).hasLobs_);
1:33776ff:     }
1:70f7692: 
1:70f7692:     public void writePositioningFetch(NetResultSet resultSet,
1:70f7692:                                       Section section,
1:70f7692:                                       int orientation,
1:70f7692:                                       long rowToFetch) throws SqlException {
1:70f7692:         int protocolOrientation = computePROTOCOLOrientation(orientation);
1:70f7692: 
1:70f7692:         // do not send qryrowste if the cursor is a non-rowset, sensitive dynamic cursor
1:70f7692:         boolean sendQryrowset =
1:70f7692:                 resultSet.isRowsetCursor_ ||
1:95049cf:                 (((NetStatement) resultSet.statement_.getMaterialStatement()).qryrowsetSentOnOpnqry_ &&
1:70f7692:                 resultSet.sensitivity_ != resultSet.sensitivity_sensitive_dynamic__);
1:70f7692: 
1:70f7692:         buildPositioningCNTQRY(protocolOrientation,
1:70f7692:                 rowToFetch,
1:70f7692:                 section,
1:70f7692:                 sendQryrowset,
1:70f7692:                 resultSet.queryInstanceIdentifier_,
1:70f7692:                 resultSet.fetchSize_);
1:70f7692: 
1:70f7692:         buildOUTOVR(resultSet,
1:70f7692:                 resultSet.resultSetMetaData_,
1:70f7692:                 resultSet.firstOutovrBuilt_,
1:70f7692:                 ((NetCursor) resultSet.cursor_).hasLobs_);
1:70f7692:     }
1:33776ff: 
1:70f7692:     public void writeCursorClose(NetResultSet resultSet,
1:70f7692:                                  Section section) throws SqlException {
1:70f7692:         buildCLSQRY(section,
1:70f7692:                 resultSet.queryInstanceIdentifier_);
1:70f7692:     }
1:70f7692: 
1:70f7692:     //----------------------helper methods----------------------------------------
1:70f7692:     // These methods are "private protected", which is not a recognized java privilege,
1:70f7692:     // but means that these methods are private to this class and to subclasses,
1:70f7692:     // and should not be used as package-wide friendly methods.
1:70f7692: 
1:70f7692:     private void buildCLSQRY(Section section,
1:70f7692:                              long queryInstanceIdentifier)
1:70f7692:             throws SqlException {
1:70f7692:         createCommand();
1:70f7692:         markLengthBytes(CodePoint.CLSQRY);
1:70f7692:         buildPKGNAMCSN(section);
1:70f7692:         buildQRYINSID(queryInstanceIdentifier);
1:70f7692:         updateLengthBytes();
1:70f7692:     }
1:70f7692: 
1:70f7692:     private void buildCNTQRY(Section section,
1:70f7692:                              boolean sendQryrowset,
1:70f7692:                              long queryInstanceIdentifier,
1:70f7692:                              int qryrowsetSize,
1:70f7692:                              boolean sendRtnextdta) throws SqlException {
1:70f7692:         buildCoreCNTQRY(section,
1:70f7692:                 sendQryrowset,
1:70f7692:                 queryInstanceIdentifier,
1:70f7692:                 qryrowsetSize);
1:70f7692: 
1:70f7692:         // We will always let RTNEXTDTA default to RTNEXTROW.  The only time we need to send
1:70f7692:         // RTNEXTDTA RTNEXTALL is for a stored procedure returned forward-only ResultSet
1:70f7692:         // that has LOB columns.  Since there are LOBs in the
1:70f7692:         // ResultSet, no QRYDTA is returned on execute.  On the CNTQRY's, we will
1:70f7692:         // send qryrowset(1) and rtnextall.
1:70f7692:         if (sendRtnextdta) {
1:70f7692:             buildRTNEXTDTA(CodePoint.RTNEXTALL);
1:70f7692:         }
1:70f7692: 
1:70f7692: 
1:70f7692:         updateLengthBytes();
1:70f7692:     }
1:70f7692: 
1:70f7692:     // buildCoreCntqry builds the common parameters
1:70f7692:     private void buildCoreCNTQRY(Section section,
1:70f7692:                                  boolean sendQryrowset,
1:70f7692:                                  long queryInstanceIdentifier,
1:70f7692:                                  int qryrowsetSize)
1:70f7692:             throws SqlException {
1:70f7692:         createCommand();
1:70f7692:         markLengthBytes(CodePoint.CNTQRY);
1:70f7692: 
1:70f7692:         buildPKGNAMCSN(section); // 1. packageNameAndConsistencyToken
1:70f7692:         buildQRYBLKSZ(); // 2. qryblksz
1:70f7692: 
1:70f7692:         // maxblkext (-1) tells the server that the client is capable of receiving any number of query blocks
1:70f7692:         if (sendQryrowset) {
1:70f7692:             buildMAXBLKEXT(-1); // 3. maxblkext
1:70f7692:         }
1:70f7692: 
1:70f7692:         // 4. qryinsid
1:70f7692:         buildQRYINSID(queryInstanceIdentifier);
1:70f7692: 
1:70f7692:         if (sendQryrowset) {
1:70f7692:             buildQRYROWSET(qryrowsetSize);  // 5. qryrowset
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:70f7692:     // Send CNTQRY to get a new rowset from the target server.
1:70f7692:     private void buildScrollCNTQRY(int scrollOrientation,
1:70f7692:                                    long rowNumber,
1:70f7692:                                    Section section,
1:70f7692:                                    boolean sendQryrowset,
1:70f7692:                                    long queryInstanceIdentifier,
1:70f7692:                                    int qryrowsetSize,
1:70f7692:                                    boolean resetQueryBlocks)
1:70f7692:             throws SqlException {
1:70f7692:         buildCoreCNTQRY(section,
1:70f7692:                 sendQryrowset,
1:70f7692:                 queryInstanceIdentifier,
1:70f7692:                 qryrowsetSize);
1:70f7692: 
1:70f7692:         buildQRYSCRORN(scrollOrientation); // qryscrorn
1:70f7692: 
1:70f7692:         if (scrollOrientation == CodePoint.QRYSCRABS || scrollOrientation == CodePoint.QRYSCRREL) {
1:70f7692:             buildQRYROWNBR(rowNumber);
1:70f7692:         }
1:70f7692: 
1:70f7692:         if (resetQueryBlocks) {
1:70f7692:             buildQRYBLKRST(0xF1);  // do reset the rowset
1:70f7692:         } else {
1:70f7692:             buildQRYBLKRST(0xF0);  // do not reset the rowset
1:70f7692:         }
1:70f7692: 
1:70f7692:         buildQRYRTNDTA(0xF1);    // do return data
1:70f7692: 
1:70f7692:         updateLengthBytes();
1:70f7692:     }
1:70f7692: 
1:70f7692:     // Send CTNQRY to reposition the cursor on the target server.
1:70f7692:     private void buildPositioningCNTQRY(int scrollOrientation,
1:70f7692:                                         long rowNumber,
1:70f7692:                                         Section section,
1:70f7692:                                         boolean sendQryrowset,
1:70f7692:                                         long queryInstanceIdentifier,
1:70f7692:                                         int qryrowsetSize)
1:70f7692:             throws SqlException {
1:70f7692:         createCommand();
1:70f7692:         markLengthBytes(CodePoint.CNTQRY);
1:70f7692: 
1:70f7692:         buildPKGNAMCSN(section); // 1. pkgnamcsn
1:70f7692:         buildQRYBLKSZ(); // 2. qryblksz
1:70f7692: 
1:70f7692:         buildQRYINSID(queryInstanceIdentifier); // 3. qryinsid
1:70f7692: 
1:70f7692:         if (sendQryrowset) {
1:70f7692:             buildQRYROWSET(qryrowsetSize);   // 4. qryrowset
1:70f7692:         }
1:70f7692: 
1:70f7692:         buildQRYSCRORN(scrollOrientation); // 5. qryscrorn
1:70f7692: 
1:70f7692:         if (scrollOrientation == CodePoint.QRYSCRABS || scrollOrientation == CodePoint.QRYSCRREL) {
1:70f7692:             buildQRYROWNBR(rowNumber); // 6. qryrownbr
1:70f7692:         }
1:70f7692: 
1:70f7692:         buildQRYBLKRST(0xF1); // 7. do reset the rowset
1:70f7692:         buildQRYRTNDTA(0xF0); // 8. do not return data
1:70f7692: 
1:70f7692: 
1:70f7692:         updateLengthBytes(); // for cntqry
1:70f7692:     }
1:70f7692: 
1:ad7199e:     private void buildOUTOVR(NetResultSet resultSet,
1:70f7692:                              ColumnMetaData resultSetMetaData,
1:70f7692:                              boolean firstOutovrBuilt,
1:70f7692:                              boolean hasLobs) throws SqlException {
1:5b7bb25:         if (hasLobs) {
1:ad7199e:             if (!firstOutovrBuilt) {
1:ad7199e:                 buildOUTOVR(resultSet, resultSetMetaData);
1:ad7199e:                 resultSet.firstOutovrBuilt_ = true;
1:ad7199e:             }
1:ad7199e:         }
1:70f7692:     }
1:70f7692: 
1:70f7692:     private void buildRTNEXTDTA(int rtnextdta) throws SqlException {
1:70f7692:         writeScalar1Byte(CodePoint.RTNEXTDTA, rtnextdta);
1:70f7692:     }
1:70f7692: 
1:70f7692:     private void buildQRYSCRORN(int scrollOrientation) throws SqlException {
1:70f7692:         writeScalar1Byte(CodePoint.QRYSCRORN, scrollOrientation);
1:70f7692:     }
1:70f7692: 
1:70f7692:     private void buildQRYBLKRST(int qryblkrst) throws SqlException {
1:70f7692:         writeScalar1Byte(CodePoint.QRYBLKRST, qryblkrst);
1:70f7692:     }
1:70f7692: 
1:70f7692:     private void buildQRYROWNBR(long rowNumber) throws SqlException {
1:70f7692:         writeScalar8Bytes(CodePoint.QRYROWNBR, rowNumber);
1:70f7692:     }
1:70f7692: 
1:70f7692:     private void buildQRYRTNDTA(int qryrtndta) throws SqlException {
1:70f7692:         writeScalar1Byte(CodePoint.QRYRTNDTA, qryrtndta);
1:70f7692:     }
1:70f7692: 
1:70f7692:     //----------------------non-parsing computational helper methods--------------
1:70f7692:     // These methods are "private protected", which is not a recognized java privilege,
1:70f7692:     // but means that these methods are private to this class and to subclasses,
1:70f7692:     // and should not be used as package-wide friendly methods.
1:70f7692: 
1:70f7692:     // Called by NetResultSetRequest.writeScrollableFetch()
1:70f7692:     private int computePROTOCOLOrientation(int orientation) throws SqlException {
1:70f7692:         switch (orientation) {
1:69e3d06:         case ClientResultSet.scrollOrientation_absolute__:
1:70f7692:             return CodePoint.QRYSCRABS;
1:70f7692: 
1:69e3d06:         case ClientResultSet.scrollOrientation_after__:
1:70f7692:             return CodePoint.QRYSCRAFT;
1:70f7692: 
1:69e3d06:         case ClientResultSet.scrollOrientation_before__:
1:70f7692:             return CodePoint.QRYSCRBEF;
1:70f7692: 
1:69e3d06:         case ClientResultSet.scrollOrientation_relative__:
1:70f7692:             return CodePoint.QRYSCRREL;
1:70f7692: 
1:70f7692:         default:
1:f271471:             throw new SqlException(netAgent_.logWriter_, 
1:f271471:                 new ClientMessageId(SQLState.NET_INVALID_SCROLL_ORIENTATION));
1:70f7692:         }
1:70f7692:     }
1:33776ff: 
1:33776ff: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:0326967
/////////////////////////////////////////////////////////////////////////
1: class NetResultSetRequest extends NetStatementRequest
1: 
1:     NetResultSetRequest(NetAgent netAgent, int bufferSize) {
commit:69e3d06
/////////////////////////////////////////////////////////////////////////
1: import java.sql.ResultSet;
1: import org.apache.derby.client.am.ClientResultSet;
/////////////////////////////////////////////////////////////////////////
1: 
1:         if (sendQryrowset && resultSet.resultSetType_ ==
1:                 ResultSet.TYPE_FORWARD_ONLY &&
1:             ((NetCursor) resultSet.cursor_).hasLobs_) {
1: 
/////////////////////////////////////////////////////////////////////////
1:             resultSet.isRowsetCursor_ ||
1:             (((NetStatement)resultSet.statement_.getMaterialStatement()).
1:                  qryrowsetSentOnOpnqry_ &&
1:              (resultSet.sensitivity_ ==
1:               ClientResultSet.sensitivity_sensitive_static__ ||
1:               ((NetCursor)resultSet.cursor_).blocking_));
/////////////////////////////////////////////////////////////////////////
1:         case ClientResultSet.scrollOrientation_absolute__:
1:         case ClientResultSet.scrollOrientation_after__:
1:         case ClientResultSet.scrollOrientation_before__:
1:         case ClientResultSet.scrollOrientation_relative__:
commit:95049cf
/////////////////////////////////////////////////////////////////////////
1:                 ((NetStatement) resultSet.statement_.getMaterialStatement()).qryrowsetSentOnOpnqry_;
/////////////////////////////////////////////////////////////////////////
1:                 (((NetStatement) resultSet.statement_.getMaterialStatement()).qryrowsetSentOnOpnqry_ &&
/////////////////////////////////////////////////////////////////////////
0:                 (((NetStatement) resultSet.statement_.getMaterialStatement()).qryrowsetSentOnOpnqry_ &&
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:1451af7
/////////////////////////////////////////////////////////////////////////
0:     public NetResultSetRequest(NetAgent netAgent, int bufferSize) {
1:         super(netAgent, bufferSize);
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:5b7bb25
/////////////////////////////////////////////////////////////////////////
1:         if (hasLobs) {
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:ad7199e
/////////////////////////////////////////////////////////////////////////
1:     private void buildOUTOVR(NetResultSet resultSet,
0:         if (false && hasLobs) {  // Disable use of locators for now
1:             if (!firstOutovrBuilt) {
1:                 buildOUTOVR(resultSet, resultSetMetaData);
1:                 resultSet.firstOutovrBuilt_ = true;
1:             }
1:         }
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:59bf37d
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:David Van Couvering
-------------------------------------------------------------------------------
commit:f271471
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.client.am.ClientMessageId;
1: 
1: import org.apache.derby.shared.common.reference.SQLState;
/////////////////////////////////////////////////////////////////////////
1:             throw new SqlException(netAgent_.logWriter_, 
1:                 new ClientMessageId(SQLState.NET_INVALID_SCROLL_ORIENTATION));
author:Jeremy Boynes
-------------------------------------------------------------------------------
commit:70f7692
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.client.am.ColumnMetaData;
0: import org.apache.derby.client.am.ResultSet;
1:         implements ResultSetRequestInterface {
0:     public NetResultSetRequest(NetAgent netAgent, CcsidManager ccsidManager, int bufferSize) {
0:         super(netAgent, ccsidManager, bufferSize);
1:     //----------------------------- entry points ---------------------------------
1:     public void writeFetch(NetResultSet resultSet,
1:                            Section section,
1:                            int fetchSize) throws SqlException {
1:         // - for forward-only cursors we do not send qryrowset on OPNQRY, fetchSize is ignored.
1:         //   but qryrowset is sent on EXCSQLSTT for a stored procedure call.
1:         boolean sendQryrowset =
0:                 ((NetStatement) resultSet.statement_.materialStatement_).qryrowsetSentOnOpnqry_;
1:         boolean sendRtnextdta = false;
0:         if (sendQryrowset && resultSet.resultSetType_ == java.sql.ResultSet.TYPE_FORWARD_ONLY &&
0:                 ((NetCursor) resultSet.cursor_).hasLobs_) {
1:             fetchSize = 1;
1:             resultSet.fetchSize_ = 1;
1:             sendRtnextdta = true;
1:             ((NetCursor) resultSet.cursor_).rtnextrow_ = false;
1:         }
1:         // if one of the result sets returned from a stored procedure is scrollable,
1:         // then we set netStatement_.qryrowsetSentOnOpnqry_ to true even though we didn't really
1:         // send a qryrowset on excsqlstt for sqlam >= 7.  this is ok for scrollable cursors,
1:         // but will cause a problem for forward-only cursors.  Because if fetchSize was never
1:         // set, we will send qryrowset(0), which will cause a syntaxrm.
1:         else if (resultSet.fetchSize_ == 0) {
1:             sendQryrowset = false;
1:         }
1:         buildCNTQRY(section,
1:                 sendQryrowset,
1:                 resultSet.queryInstanceIdentifier_,
1:                 fetchSize,
1:                 sendRtnextdta);
1:         buildOUTOVR(resultSet,
1:                 resultSet.resultSetMetaData_,
1:                 resultSet.firstOutovrBuilt_,
1:                 ((NetCursor) resultSet.cursor_).hasLobs_);
1:     }
1:     public void writeScrollableFetch(NetResultSet resultSet,
1:                                      int fetchSize,
1:                                      long rowToFetch,
1:                                      boolean resetQueryBlocks) throws SqlException {
1:         int protocolOrientation = computePROTOCOLOrientation(orientation);
1:         // - for sensitive-static cursors:
1:         //     * qryrowset must be sent on opnqry to indicate to the server that the cursor is
1:         //       going to be used in a scrollable fashion.  (sqlam<7)
1:         //     * if qryrowset is sent on opnqry, then it must be sent on all subsequent cntqry's
1:         // - for sensitive-dynamic non-rowset cursors: (we should never be in this case)
1:         //     * qryrowset is NOT ALLOWED on cntqry's
1:         // - for rowset cursors:
1:         //     * qryrowset is optional.  it is ignored on opnqry.  if not sent on cntqry,
1:         //       then the fetch is going fetch next row as opposed to fetch next rowset.
1:         boolean sendQryrowset =
0:                 (resultSet.isRowsetCursor_ ||
0:                 (((NetStatement) resultSet.statement_.materialStatement_).qryrowsetSentOnOpnqry_ &&
0:                 (resultSet.sensitivity_ == ResultSet.sensitivity_sensitive_static__ ||
0:                 ((NetCursor) resultSet.cursor_).blocking_)));
1:         buildScrollCNTQRY(protocolOrientation,
1:                 rowToFetch,
1:                 section,
1:                 sendQryrowset,
1:                 resultSet.queryInstanceIdentifier_,
1:                 fetchSize,
1:                 resetQueryBlocks);
1:         buildOUTOVR(resultSet,
1:                 resultSet.resultSetMetaData_,
1:                 resultSet.firstOutovrBuilt_,
1:                 ((NetCursor) resultSet.cursor_).hasLobs_);
1: 
1:     public void writePositioningFetch(NetResultSet resultSet,
1:                                       Section section,
1:                                       int orientation,
1:                                       long rowToFetch) throws SqlException {
1:         int protocolOrientation = computePROTOCOLOrientation(orientation);
1: 
1:         // do not send qryrowste if the cursor is a non-rowset, sensitive dynamic cursor
1:         boolean sendQryrowset =
1:                 resultSet.isRowsetCursor_ ||
0:                 (((NetStatement) resultSet.statement_.materialStatement_).qryrowsetSentOnOpnqry_ &&
1:                 resultSet.sensitivity_ != resultSet.sensitivity_sensitive_dynamic__);
1: 
1:         buildPositioningCNTQRY(protocolOrientation,
1:                 rowToFetch,
1:                 section,
1:                 sendQryrowset,
1:                 resultSet.queryInstanceIdentifier_,
1:                 resultSet.fetchSize_);
1: 
1:         buildOUTOVR(resultSet,
1:                 resultSet.resultSetMetaData_,
1:                 resultSet.firstOutovrBuilt_,
1:                 ((NetCursor) resultSet.cursor_).hasLobs_);
1:     }
1: 
1:     public void writeCursorClose(NetResultSet resultSet,
1:                                  Section section) throws SqlException {
1:         buildCLSQRY(section,
1:                 resultSet.queryInstanceIdentifier_);
1:     }
1: 
1:     //----------------------helper methods----------------------------------------
1:     // These methods are "private protected", which is not a recognized java privilege,
1:     // but means that these methods are private to this class and to subclasses,
1:     // and should not be used as package-wide friendly methods.
1: 
1:     private void buildCLSQRY(Section section,
1:                              long queryInstanceIdentifier)
1:             throws SqlException {
1:         createCommand();
1:         markLengthBytes(CodePoint.CLSQRY);
1:         buildPKGNAMCSN(section);
1:         buildQRYINSID(queryInstanceIdentifier);
1:         updateLengthBytes();
1:     }
1: 
1:     private void buildCNTQRY(Section section,
1:                              boolean sendQryrowset,
1:                              long queryInstanceIdentifier,
1:                              int qryrowsetSize,
1:                              boolean sendRtnextdta) throws SqlException {
1:         buildCoreCNTQRY(section,
1:                 sendQryrowset,
1:                 queryInstanceIdentifier,
1:                 qryrowsetSize);
1: 
1:         // We will always let RTNEXTDTA default to RTNEXTROW.  The only time we need to send
1:         // RTNEXTDTA RTNEXTALL is for a stored procedure returned forward-only ResultSet
1:         // that has LOB columns.  Since there are LOBs in the
1:         // ResultSet, no QRYDTA is returned on execute.  On the CNTQRY's, we will
1:         // send qryrowset(1) and rtnextall.
1:         if (sendRtnextdta) {
1:             buildRTNEXTDTA(CodePoint.RTNEXTALL);
1:         }
1: 
1: 
1:         updateLengthBytes();
1:     }
1: 
1:     // buildCoreCntqry builds the common parameters
1:     private void buildCoreCNTQRY(Section section,
1:                                  boolean sendQryrowset,
1:                                  long queryInstanceIdentifier,
1:                                  int qryrowsetSize)
1:             throws SqlException {
1:         createCommand();
1:         markLengthBytes(CodePoint.CNTQRY);
1: 
1:         buildPKGNAMCSN(section); // 1. packageNameAndConsistencyToken
1:         buildQRYBLKSZ(); // 2. qryblksz
1: 
1:         // maxblkext (-1) tells the server that the client is capable of receiving any number of query blocks
1:         if (sendQryrowset) {
1:             buildMAXBLKEXT(-1); // 3. maxblkext
1:         }
1: 
1:         // 4. qryinsid
1:         buildQRYINSID(queryInstanceIdentifier);
1: 
1:         if (sendQryrowset) {
1:             buildQRYROWSET(qryrowsetSize);  // 5. qryrowset
1:         }
1:     }
1: 
1:     // Send CNTQRY to get a new rowset from the target server.
1:     private void buildScrollCNTQRY(int scrollOrientation,
1:                                    long rowNumber,
1:                                    Section section,
1:                                    boolean sendQryrowset,
1:                                    long queryInstanceIdentifier,
1:                                    int qryrowsetSize,
1:                                    boolean resetQueryBlocks)
1:             throws SqlException {
1:         buildCoreCNTQRY(section,
1:                 sendQryrowset,
1:                 queryInstanceIdentifier,
1:                 qryrowsetSize);
1: 
1:         buildQRYSCRORN(scrollOrientation); // qryscrorn
1: 
1:         if (scrollOrientation == CodePoint.QRYSCRABS || scrollOrientation == CodePoint.QRYSCRREL) {
1:             buildQRYROWNBR(rowNumber);
1:         }
1: 
1:         if (resetQueryBlocks) {
1:             buildQRYBLKRST(0xF1);  // do reset the rowset
1:         } else {
1:             buildQRYBLKRST(0xF0);  // do not reset the rowset
1:         }
1: 
1:         buildQRYRTNDTA(0xF1);    // do return data
1: 
1:         updateLengthBytes();
1:     }
1: 
1:     // Send CTNQRY to reposition the cursor on the target server.
1:     private void buildPositioningCNTQRY(int scrollOrientation,
1:                                         long rowNumber,
1:                                         Section section,
1:                                         boolean sendQryrowset,
1:                                         long queryInstanceIdentifier,
1:                                         int qryrowsetSize)
1:             throws SqlException {
1:         createCommand();
1:         markLengthBytes(CodePoint.CNTQRY);
1: 
1:         buildPKGNAMCSN(section); // 1. pkgnamcsn
1:         buildQRYBLKSZ(); // 2. qryblksz
1: 
1:         buildQRYINSID(queryInstanceIdentifier); // 3. qryinsid
1: 
1:         if (sendQryrowset) {
1:             buildQRYROWSET(qryrowsetSize);   // 4. qryrowset
1:         }
1: 
1:         buildQRYSCRORN(scrollOrientation); // 5. qryscrorn
1: 
1:         if (scrollOrientation == CodePoint.QRYSCRABS || scrollOrientation == CodePoint.QRYSCRREL) {
1:             buildQRYROWNBR(rowNumber); // 6. qryrownbr
1:         }
1: 
1:         buildQRYBLKRST(0xF1); // 7. do reset the rowset
1:         buildQRYRTNDTA(0xF0); // 8. do not return data
1: 
1: 
1:         updateLengthBytes(); // for cntqry
1:     }
1: 
0:     private void buildOUTOVR(ResultSet resultSet,
1:                              ColumnMetaData resultSetMetaData,
1:                              boolean firstOutovrBuilt,
1:                              boolean hasLobs) throws SqlException {
0:         return;
1:     }
1: 
1:     private void buildRTNEXTDTA(int rtnextdta) throws SqlException {
1:         writeScalar1Byte(CodePoint.RTNEXTDTA, rtnextdta);
1:     }
1: 
1:     private void buildQRYSCRORN(int scrollOrientation) throws SqlException {
1:         writeScalar1Byte(CodePoint.QRYSCRORN, scrollOrientation);
1:     }
1: 
1:     private void buildQRYBLKRST(int qryblkrst) throws SqlException {
1:         writeScalar1Byte(CodePoint.QRYBLKRST, qryblkrst);
1:     }
1: 
1:     private void buildQRYROWNBR(long rowNumber) throws SqlException {
1:         writeScalar8Bytes(CodePoint.QRYROWNBR, rowNumber);
1:     }
1: 
1:     private void buildQRYRTNDTA(int qryrtndta) throws SqlException {
1:         writeScalar1Byte(CodePoint.QRYRTNDTA, qryrtndta);
1:     }
1: 
1:     //----------------------non-parsing computational helper methods--------------
1:     // These methods are "private protected", which is not a recognized java privilege,
1:     // but means that these methods are private to this class and to subclasses,
1:     // and should not be used as package-wide friendly methods.
1: 
1:     // Called by NetResultSetRequest.writeScrollableFetch()
1:     private int computePROTOCOLOrientation(int orientation) throws SqlException {
1:         switch (orientation) {
0:         case ResultSet.scrollOrientation_absolute__:
1:             return CodePoint.QRYSCRABS;
1: 
0:         case ResultSet.scrollOrientation_after__:
1:             return CodePoint.QRYSCRAFT;
1: 
0:         case ResultSet.scrollOrientation_before__:
1:             return CodePoint.QRYSCRBEF;
1: 
0:         case ResultSet.scrollOrientation_relative__:
1:             return CodePoint.QRYSCRREL;
1: 
1:         default:
0:             throw new SqlException(netAgent_.logWriter_, "Bug check: invalid scroll orientation");
1:         }
1:     }
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:33776ff
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derby.client.net.NetResultSetRequest
1: 
0:    Copyright (c) 2001, 2005 The Apache Software Foundation or its licensors, where applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1: */
1: 
1: package org.apache.derby.client.net;
1: 
1: import org.apache.derby.client.am.Section;
1: import org.apache.derby.client.am.SqlException;
0: import org.apache.derby.client.am.ResultSet;
0: import org.apache.derby.client.am.ColumnMetaData;
1: 
0: public class NetResultSetRequest extends NetStatementRequest
0:                                 implements ResultSetRequestInterface
0: {
0:   public NetResultSetRequest (NetAgent netAgent, CcsidManager ccsidManager, int bufferSize)
0:   {
0:     super (netAgent, ccsidManager, bufferSize);
1:   }
1: 
0:   //----------------------------- entry points ---------------------------------
0:   public void writeFetch (NetResultSet resultSet,
1:                           Section section,
0:                           int fetchSize) throws SqlException
0:   {
0:     // - for forward-only cursors we do not send qryrowset on OPNQRY, fetchSize is ignored.
0:     //   but qryrowset is sent on EXCSQLSTT for a stored procedure call.
0:     boolean sendQryrowset =
0:          ((NetStatement) resultSet.statement_.materialStatement_).qryrowsetSentOnOpnqry_;
1: 
0:     boolean sendRtnextdta = false;
0:     if (sendQryrowset && resultSet.resultSetType_ == java.sql.ResultSet.TYPE_FORWARD_ONLY &&
0:         ((NetCursor) resultSet.cursor_).hasLobs_) {
0:       fetchSize = 1;
0:       resultSet.fetchSize_ = 1;
0:       sendRtnextdta = true;
0:       ((NetCursor) resultSet.cursor_).rtnextrow_ = false;
1:     }
0:     // if one of the result sets returned from a stored procedure is scrollable,
0:     // then we set netStatement_.qryrowsetSentOnOpnqry_ to true even though we didn't really
0:     // send a qryrowset on excsqlstt for sqlam >= 7.  this is ok for scrollable cursors,
0:     // but will cause a problem for forward-only cursors.  Because if fetchSize was never
0:     // set, we will send qryrowset(0), which will cause a syntaxrm.
0:     else if (resultSet.fetchSize_ == 0) {
0:       sendQryrowset = false;
1:     }
1: 
0:     buildCNTQRY (section,
0:                  sendQryrowset,
0:                  resultSet.queryInstanceIdentifier_,
0:                  fetchSize,
0:                  sendRtnextdta);
1: 
0:     buildOUTOVR (resultSet,
0:                  resultSet.resultSetMetaData_,
0:                  resultSet.firstOutovrBuilt_,
0:                  ((NetCursor) resultSet.cursor_).hasLobs_);
1:   }
1: 
0:   public void writeScrollableFetch (NetResultSet resultSet,
1:                                     Section section,
0:                                     int fetchSize,
1:                                     int orientation,
0:                                     long rowToFetch,
0:                                     boolean resetQueryBlocks) throws SqlException
0:   {
0:     int protocolOrientation = computePROTOCOLOrientation (orientation);
1: 
0:     // - for sensitive-static cursors:
0:     //     * qryrowset must be sent on opnqry to indicate to the server that the cursor is
0:     //       going to be used in a scrollable fashion.  (sqlam<7)
0:     //     * if qryrowset is sent on opnqry, then it must be sent on all subsequent cntqry's
0:     // - for sensitive-dynamic non-rowset cursors: (we should never be in this case)
0:     //     * qryrowset is NOT ALLOWED on cntqry's
0:     // - for rowset cursors:
0:     //     * qryrowset is optional.  it is ignored on opnqry.  if not sent on cntqry,
0:     //       then the fetch is going fetch next row as opposed to fetch next rowset.
0:     boolean sendQryrowset =
0:         (resultSet.isRowsetCursor_ ||
0:          (((NetStatement) resultSet.statement_.materialStatement_).qryrowsetSentOnOpnqry_ &&
0:           (resultSet.sensitivity_ == ResultSet.sensitivity_sensitive_static__ ||
0:           ((NetCursor)resultSet.cursor_).blocking_)));
1: 
0:     buildScrollCNTQRY (protocolOrientation,
0:                        rowToFetch,
0:                        section,
0:                        sendQryrowset,
0:                        resultSet.queryInstanceIdentifier_,
0:                        fetchSize,
0:                        resetQueryBlocks);
1: 
0:     buildOUTOVR (resultSet,
0:                  resultSet.resultSetMetaData_,
0:                  resultSet.firstOutovrBuilt_,
0:                  ((NetCursor) resultSet.cursor_).hasLobs_);
1:   }
1: 
0:   public void writePositioningFetch (NetResultSet resultSet,
1:                                      Section section,
1:                                      int orientation,
0:                                      long rowToFetch) throws SqlException
0:   {
0:     int protocolOrientation = computePROTOCOLOrientation (orientation);
1: 
0:     // do not send qryrowste if the cursor is a non-rowset, sensitive dynamic cursor
0:     boolean sendQryrowset =
0:         resultSet.isRowsetCursor_ ||
0:         (((NetStatement) resultSet.statement_.materialStatement_).qryrowsetSentOnOpnqry_ &&
0:          resultSet.sensitivity_ != resultSet.sensitivity_sensitive_dynamic__);
1: 
0:     buildPositioningCNTQRY (protocolOrientation,
0:                             rowToFetch,
0:                             section,
0:                             sendQryrowset,
0:                             resultSet.queryInstanceIdentifier_,
0:                             resultSet.fetchSize_);
1: 
0:     buildOUTOVR (resultSet,
0:                  resultSet.resultSetMetaData_,
0:                  resultSet.firstOutovrBuilt_,
0:                  ((NetCursor) resultSet.cursor_).hasLobs_);
1:   }
1: 
0:   public void writeCursorClose (NetResultSet resultSet,
0:                                 Section section) throws SqlException
0:   {
0:     buildCLSQRY (section,
0:                  resultSet.queryInstanceIdentifier_);
1:   }
1: 
0:   //----------------------helper methods----------------------------------------
0:   // These methods are "private protected", which is not a recognized java privilege,
0:   // but means that these methods are private to this class and to subclasses,
0:   // and should not be used as package-wide friendly methods.
1: 
0:   private void buildCLSQRY (Section section,
0:                             long queryInstanceIdentifier)
0: 			    throws SqlException
0:   {
0:     createCommand ();
0:     markLengthBytes (CodePoint.CLSQRY);
0:     buildPKGNAMCSN (section);
0:     buildQRYINSID (queryInstanceIdentifier);
0:     updateLengthBytes();
1:   }
1: 
0:   private void buildCNTQRY (Section section,
0:                             boolean sendQryrowset,
0:                             long queryInstanceIdentifier,
0:                             int qryrowsetSize,
0:                             boolean sendRtnextdta) throws SqlException
0:   {
0:     buildCoreCNTQRY (section,
0:                      sendQryrowset,
0:                      queryInstanceIdentifier,
0:                      qryrowsetSize);
1: 
0:     // We will always let RTNEXTDTA default to RTNEXTROW.  The only time we need to send
0:     // RTNEXTDTA RTNEXTALL is for a stored procedure returned forward-only ResultSet
0:     // that has LOB columns.  Since there are LOBs in the
0:     // ResultSet, no QRYDTA is returned on execute.  On the CNTQRY's, we will
0:     // send qryrowset(1) and rtnextall.
0:     if (sendRtnextdta) buildRTNEXTDTA (CodePoint.RTNEXTALL);
1: 
1: 
0:     updateLengthBytes();
1:   }
1: 
0:   // buildCoreCntqry builds the common parameters
0:   private void buildCoreCNTQRY (Section section,
0:                                 boolean sendQryrowset,
0:                                 long queryInstanceIdentifier,
0:                                 int qryrowsetSize)
0: 				 throws SqlException
0:   {
0:     createCommand ();
0:     markLengthBytes (CodePoint.CNTQRY);
1: 
0:     buildPKGNAMCSN (section); // 1. packageNameAndConsistencyToken
0:     buildQRYBLKSZ (); // 2. qryblksz
1: 
0:     // maxblkext (-1) tells the server that the client is capable of receiving any number of query blocks
0:     if (sendQryrowset)
0:       buildMAXBLKEXT (-1); // 3. maxblkext
1: 
0:     // 4. qryinsid
0: 	buildQRYINSID (queryInstanceIdentifier);
1: 
0:     if (sendQryrowset) buildQRYROWSET (qryrowsetSize);  // 5. qryrowset
1:   }
1: 
0:   // Send CNTQRY to get a new rowset from the target server.
0:   private void buildScrollCNTQRY (int scrollOrientation,
0:                                   long rowNumber,
1:                                   Section section,
0:                                   boolean sendQryrowset,
0:                                   long queryInstanceIdentifier,
0:                                   int qryrowsetSize,
0: 				  boolean resetQueryBlocks)
0: 				    throws SqlException
0:   {
0:     buildCoreCNTQRY (section,
0:                      sendQryrowset,
0:                      queryInstanceIdentifier,
0:                      qryrowsetSize);
1: 
0:     buildQRYSCRORN (scrollOrientation); // qryscrorn
1: 
0:     if (scrollOrientation == CodePoint.QRYSCRABS || scrollOrientation == CodePoint.QRYSCRREL)
0:       buildQRYROWNBR (rowNumber);
1: 
0:     if (resetQueryBlocks)
0:       buildQRYBLKRST (0xF1);  // do reset the rowset
0:     else
0:       buildQRYBLKRST (0xF0);  // do not reset the rowset
1: 
0:     buildQRYRTNDTA (0xF1);    // do return data
1: 
0:     updateLengthBytes();
1:   }
1: 
0:   // Send CTNQRY to reposition the cursor on the target server.
0:   private void buildPositioningCNTQRY (int scrollOrientation,
0:                                        long rowNumber,
1:                                        Section section,
0:                                        boolean sendQryrowset,
0:                                        long queryInstanceIdentifier,
0:                                        int qryrowsetSize)
0:                                         throws SqlException
0:   {
0:     createCommand ();
0:     markLengthBytes (CodePoint.CNTQRY);
1: 
0:     buildPKGNAMCSN (section); // 1. pkgnamcsn
0:     buildQRYBLKSZ (); // 2. qryblksz
1: 
0:     buildQRYINSID (queryInstanceIdentifier); // 3. qryinsid
1: 
0:     if (sendQryrowset)
0:       buildQRYROWSET (qryrowsetSize);   // 4. qryrowset
1: 
0:     buildQRYSCRORN (scrollOrientation); // 5. qryscrorn
1: 
0:     if (scrollOrientation == CodePoint.QRYSCRABS || scrollOrientation == CodePoint.QRYSCRREL)
0:     buildQRYROWNBR (rowNumber); // 6. qryrownbr
1: 
0:     buildQRYBLKRST (0xF1); // 7. do reset the rowset
0:     buildQRYRTNDTA (0xF0); // 8. do not return data
1: 
1: 
0:     updateLengthBytes(); // for cntqry
1:   }
1: 
0:   private void buildOUTOVR (ResultSet resultSet,
0:                             ColumnMetaData resultSetMetaData,
0:                             boolean firstOutovrBuilt,
0:                             boolean hasLobs) throws SqlException
0:   {
0:     return;
1:   }
1: 
0:   private void buildRTNEXTDTA (int rtnextdta) throws SqlException
0:   {
0:     writeScalar1Byte (CodePoint.RTNEXTDTA, rtnextdta);
1:   }
1: 
0:   private void buildQRYSCRORN (int scrollOrientation) throws SqlException
0:   {
0:     writeScalar1Byte (CodePoint.QRYSCRORN, scrollOrientation);
1:   }
1: 
0:   private void buildQRYBLKRST (int qryblkrst) throws SqlException
0:   {
0:     writeScalar1Byte (CodePoint.QRYBLKRST, qryblkrst);
1:   }
1: 
0:   private void buildQRYROWNBR (long rowNumber) throws SqlException
0:   {
0:     writeScalar8Bytes (CodePoint.QRYROWNBR, rowNumber);
1:   }
1: 
0:   private void buildQRYRTNDTA (int qryrtndta) throws SqlException
0:   {
0:     writeScalar1Byte (CodePoint.QRYRTNDTA, qryrtndta);
1:   }
1: 
0:   //----------------------non-parsing computational helper methods--------------
0:   // These methods are "private protected", which is not a recognized java privilege,
0:   // but means that these methods are private to this class and to subclasses,
0:   // and should not be used as package-wide friendly methods.
1: 
0:   // Called by NetResultSetRequest.writeScrollableFetch()
0:   private int computePROTOCOLOrientation (int orientation) throws SqlException
0:   {
0:     switch (orientation) {
0:     case ResultSet.scrollOrientation_absolute__ :
0:       return CodePoint.QRYSCRABS;
1: 
0:     case ResultSet.scrollOrientation_after__ :
0:       return CodePoint.QRYSCRAFT;
1: 
0:     case ResultSet.scrollOrientation_before__ :
0:       return CodePoint.QRYSCRBEF;
1: 
0:     case ResultSet.scrollOrientation_relative__ :
0:       return CodePoint.QRYSCRREL;
1: 
0:     default:
0:       throw new SqlException (netAgent_.logWriter_, "Bug check: invalid scroll orientation");
1:     }
1:   }
1: 
1: }
============================================================================