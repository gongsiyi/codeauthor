1:8f23d8f: /*
2:8f23d8f: 
1:8f23d8f:    Derby - Class org.apache.derbyTesting.functionTests.tests.lang.RestrictedTableVTI
1:8f23d8f: 
1:8f23d8f:    Licensed to the Apache Software Foundation (ASF) under one or more
1:8f23d8f:    contributor license agreements.  See the NOTICE file distributed with
1:8f23d8f:    this work for additional information regarding copyright ownership.
1:8f23d8f:    The ASF licenses this file to you under the Apache License, Version 2.0
1:8f23d8f:    (the "License"); you may not use this file except in compliance with
1:8f23d8f:    the License.  You may obtain a copy of the License at
1:8f23d8f: 
1:8f23d8f:      http://www.apache.org/licenses/LICENSE-2.0
1:8f23d8f: 
1:8f23d8f:    Unless required by applicable law or agreed to in writing, software
1:8f23d8f:    distributed under the License is distributed on an "AS IS" BASIS,
1:8f23d8f:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:8f23d8f:    See the License for the specific language governing permissions and
1:8f23d8f:    limitations under the License.
1:8f23d8f: 
1:8f23d8f:  */
1:8f23d8f: 
1:8f23d8f: package org.apache.derbyTesting.functionTests.tests.lang;
1:8f23d8f: 
1:8f23d8f: import java.io.InputStream;
1:8f23d8f: import java.io.Reader;
1:8f23d8f: import java.math.BigDecimal;
1:8f23d8f: import java.sql.Blob;
1:8f23d8f: import java.sql.Clob;
1:8f23d8f: import java.sql.Connection;
1:8f23d8f: import java.sql.Date;
1:8f23d8f: import java.sql.DriverManager;
1:8f23d8f: import java.sql.PreparedStatement;
1:8f23d8f: import java.sql.ResultSet;
1:8f23d8f: import java.sql.ResultSetMetaData;
1:8f23d8f: import java.sql.SQLException;
1:8f23d8f: import java.sql.Time;
1:8f23d8f: import java.sql.Timestamp;
1:8f23d8f: import java.util.Calendar;
1:8f23d8f: 
1:8f23d8f: import org.apache.derby.vti.VTITemplate;
1:8f23d8f: import org.apache.derby.vti.RestrictedVTI;
1:8f23d8f: import org.apache.derby.vti.Restriction;
1:8f23d8f: 
1:8f23d8f: /**
1:8f23d8f:  * <p>
1:8f23d8f:  * This class contains a table function which can be used to read data
1:8f23d8f:  * from a Derby table.
1:8f23d8f:  * </p>
1:8f23d8f:  */
1:8f23d8f: public	class   RestrictedTableVTI extends VTITemplate implements  RestrictedVTI
1:8f23d8f: {
1:8f23d8f:     ////////////////////////////////////////////////////////////////////////
1:8f23d8f:     //
1:8f23d8f:     //	CONSTANTS
1:8f23d8f:     //
1:8f23d8f:     ////////////////////////////////////////////////////////////////////////
1:8f23d8f: 
1:8f23d8f:     ////////////////////////////////////////////////////////////////////////
1:8f23d8f:     //
1:8f23d8f:     //	STATE
1:8f23d8f:     //
1:8f23d8f:     ////////////////////////////////////////////////////////////////////////
1:8f23d8f: 
1:8f23d8f:     private String  _schemaName;
1:8f23d8f:     private String  _tableName;
1:8f23d8f:     private Connection _connection;
1:8f23d8f: 
1:8f23d8f:     private String[]    _columnNames;
1:8f23d8f:     private Restriction _restriction;
1:8f23d8f: 
1:8f23d8f:     // this maps table function columns (0-based) to table column numbers (1-based) in
1:8f23d8f:     // the actual query
1:8f23d8f:     private int[]               _columnNumberMap;
1:8f23d8f:     private PreparedStatement   _preparedStatement;
1:8f23d8f:     private ResultSet           _resultSet;
1:8f23d8f: 
1:8f23d8f:     private static  String  _lastQuery;
1:8f23d8f: 
1:8f23d8f:     ////////////////////////////////////////////////////////////////////////
1:8f23d8f:     //
1:8f23d8f:     //	CONSTRUCTOR
1:8f23d8f:     //
1:8f23d8f:     ////////////////////////////////////////////////////////////////////////
1:8f23d8f: 
1:8f23d8f:     protected  RestrictedTableVTI
1:8f23d8f:         (
1:8f23d8f:          String schemaName,
1:8f23d8f:          String tableName
1:8f23d8f:          )
1:8f23d8f:         throws Exception
1:8f23d8f:     {
1:8f23d8f:         _schemaName = schemaName;
1:8f23d8f:         _tableName = tableName;
1:8f23d8f:         _connection = getDerbyConnection();
1:8f23d8f:     }
1:8f23d8f: 
1:8f23d8f:     ////////////////////////////////////////////////////////////////////////
1:8f23d8f:     //
1:8f23d8f:     //	TABLE FUNCTIONS
1:8f23d8f:     //
1:8f23d8f:     ////////////////////////////////////////////////////////////////////////
1:8f23d8f: 
1:8f23d8f:     /**
1:8f23d8f:      * <p>
1:8f23d8f:      * Table function to read a table in Derby.
1:8f23d8f:      * </p>
1:8f23d8f:      */
1:8f23d8f:     public  static  RestrictedTableVTI readTable
1:8f23d8f:         (
1:8f23d8f:          String schemaName,
1:8f23d8f:          String tableName
1:8f23d8f:          )
1:8f23d8f:         throws Exception
1:8f23d8f:     {
1:8f23d8f:         return new RestrictedTableVTI( schemaName, tableName );
1:8f23d8f:     }
1:8f23d8f: 
1:8f23d8f:     /**
1:8f23d8f:      * <p>
1:8f23d8f:      * Scalar function to retrieve the last query generated by this machinery.
1:8f23d8f:      * </p>
1:8f23d8f:      */
1:8f23d8f:     public  static  String  getLastQuery() { return _lastQuery; }
1:8f23d8f:     
1:8f23d8f: 
1:8f23d8f:     ////////////////////////////////////////////////////////////////////////
1:8f23d8f:     //
1:8f23d8f:     //	ResultSet BEHAVIOR
1:8f23d8f:     //
1:8f23d8f:     ////////////////////////////////////////////////////////////////////////
1:8f23d8f: 
1:8f23d8f:     public  void    close() throws SQLException
1:8f23d8f:     {
1:8f23d8f:         if ( !isClosed() )
1:8f23d8f:         {
1:8f23d8f:             _schemaName = null;
1:8f23d8f:             _tableName = null;
1:8f23d8f:             _connection = null;
1:8f23d8f:             _columnNames = null;
1:8f23d8f:             _restriction = null;
1:8f23d8f:             _columnNumberMap = null;
1:8f23d8f: 
1:8f23d8f:             if ( _resultSet != null ) { _resultSet.close(); }
1:8f23d8f:             if ( _preparedStatement != null ) { _preparedStatement.close(); }
1:8f23d8f: 
1:8f23d8f:             _resultSet = null;
1:8f23d8f:             _preparedStatement = null;
1:8f23d8f:         }
1:8f23d8f:     }
1:8f23d8f: 
1:8f23d8f:     public  boolean next()  throws SQLException
1:8f23d8f:     {
1:8f23d8f:         if ( !isClosed() && (_resultSet == null) )
1:8f23d8f:         {
1:8f23d8f:             _preparedStatement = prepareStatement( _connection, makeQuery() );
1:8f23d8f:             _resultSet = _preparedStatement.executeQuery();
1:8f23d8f:         }
1:8f23d8f: 
1:8f23d8f:         return _resultSet.next();
1:8f23d8f:     }
1:8f23d8f: 
1:8f23d8f:     public boolean isClosed() { return (_connection == null); }
1:8f23d8f: 
1:8f23d8f:     public  boolean wasNull()   throws SQLException
1:8f23d8f:     { return _resultSet.wasNull(); }
1:8f23d8f: 
1:8f23d8f:     public  ResultSetMetaData   getMetaData()   throws SQLException
1:8f23d8f:     { return _resultSet.getMetaData(); }
1:8f23d8f: 
1:8f23d8f:     public  InputStream 	getAsciiStream(int i) throws SQLException
1:8f23d8f:     { return _resultSet.getAsciiStream( mapColumnNumber( i ) ); }
1:8f23d8f:     
1:8f23d8f:     public  BigDecimal 	getBigDecimal(int i) throws SQLException
1:8f23d8f:     { return _resultSet.getBigDecimal( mapColumnNumber( i ) ); }
1:2510115: 
1:2510115:     @Deprecated
1:8f23d8f:     public  BigDecimal 	getBigDecimal(int i, int scale) throws SQLException
1:8f23d8f:     { return _resultSet.getBigDecimal( mapColumnNumber( i ), scale ); }
1:8f23d8f:     
1:8f23d8f:     public  InputStream 	getBinaryStream(int i)  throws SQLException
1:8f23d8f:     { return _resultSet.getBinaryStream( mapColumnNumber( i ) ); }
1:8f23d8f:     
1:8f23d8f:     public  Blob 	getBlob(int i)  throws SQLException
1:8f23d8f:     { return _resultSet.getBlob( mapColumnNumber( i ) ); }
1:8f23d8f:     
1:8f23d8f:     public  boolean 	getBoolean(int i) throws SQLException
1:8f23d8f:     { return _resultSet.getBoolean( mapColumnNumber( i ) ); }
1:8f23d8f:     
1:8f23d8f:     public  byte 	getByte(int i)    throws SQLException
1:8f23d8f:     { return _resultSet.getByte( mapColumnNumber( i ) ); }
1:8f23d8f:     
1:8f23d8f:     public  byte[] 	getBytes(int i) throws SQLException
1:8f23d8f:     { return _resultSet.getBytes( mapColumnNumber( i ) ); }
1:8f23d8f:     
1:8f23d8f:     public  Reader 	getCharacterStream(int i) throws SQLException
1:8f23d8f:     { return _resultSet.getCharacterStream( mapColumnNumber( i ) ); }
1:8f23d8f: 
1:8f23d8f:     public  Clob 	getClob(int i)  throws SQLException
1:8f23d8f:     { return _resultSet.getClob( mapColumnNumber( i ) ); }
1:8f23d8f: 
1:8f23d8f:     public  Date 	getDate(int i)  throws SQLException
1:8f23d8f:     { return _resultSet.getDate( mapColumnNumber( i ) ); }
1:8f23d8f: 
1:8f23d8f:     public  Date 	getDate(int i, Calendar cal)    throws SQLException
1:8f23d8f:     { return _resultSet.getDate( mapColumnNumber( i ), cal ); }
1:8f23d8f: 
1:8f23d8f:     public  double 	getDouble(int i)    throws SQLException
1:8f23d8f:     { return _resultSet.getDouble( mapColumnNumber( i ) ); }
1:8f23d8f: 
1:8f23d8f:     public  float 	getFloat(int i) throws SQLException
1:8f23d8f:     { return _resultSet.getFloat( mapColumnNumber( i ) ); }
1:8f23d8f: 
1:8f23d8f:     public  int 	getInt(int i)   throws SQLException
1:8f23d8f:     { return _resultSet.getInt( mapColumnNumber( i ) ); }
1:8f23d8f: 
1:8f23d8f:     public  long 	getLong(int i)  throws SQLException
1:8f23d8f:     { return _resultSet.getLong( mapColumnNumber( i ) ); }
1:8f23d8f: 
1:8f23d8f:     public  Object 	getObject(int i)    throws SQLException
1:8f23d8f:     { return _resultSet.getObject( mapColumnNumber( i ) ); }
1:8f23d8f: 
1:8f23d8f:     public  short 	getShort(int i) throws SQLException
1:8f23d8f:     { return _resultSet.getShort( mapColumnNumber( i ) ); }
1:8f23d8f: 
1:8f23d8f:     public  String 	getString(int i)    throws SQLException
1:8f23d8f:     { return _resultSet.getString( mapColumnNumber( i ) ); }
1:8f23d8f: 
1:8f23d8f:     public  Time 	getTime(int i)  throws SQLException
1:8f23d8f:     { return _resultSet.getTime( mapColumnNumber( i ) ); }
1:8f23d8f: 
1:8f23d8f:     public  Time 	getTime(int i, Calendar cal)    throws SQLException
1:8f23d8f:     { return _resultSet.getTime( mapColumnNumber( i ), cal ); }
1:8f23d8f: 
1:8f23d8f:     public  Timestamp 	getTimestamp(int i) throws SQLException
1:8f23d8f:     { return _resultSet.getTimestamp( mapColumnNumber( i ) ); }
1:8f23d8f: 
1:8f23d8f:     public  Timestamp 	getTimestamp(int i, Calendar cal)   throws SQLException
1:8f23d8f:     { return _resultSet.getTimestamp( mapColumnNumber( i ), cal ); }
1:8f23d8f: 
1:8f23d8f:     ////////////////////////////////////////////////////////////////////////
1:8f23d8f:     //
1:8f23d8f:     //	RestrictedVTI BEHAVIOR
1:8f23d8f:     //
1:8f23d8f:     ////////////////////////////////////////////////////////////////////////
1:8f23d8f: 
1:8f23d8f:     public  void    initScan
1:8f23d8f:         ( String[] columnNames, Restriction restriction )
1:8f23d8f:         throws SQLException
1:8f23d8f:     {
1:8f23d8f:         _columnNames = columnNames;
1:8f23d8f:         _restriction = restriction;
1:8f23d8f: 
1:8f23d8f:         int columnCount = _columnNames.length;
1:8f23d8f: 
1:8f23d8f:         _columnNumberMap = new int[ columnCount ];
1:8f23d8f:         int foreignColumnID = 1;
1:8f23d8f:         for ( int i = 0; i < columnCount; i++ )
1:8f23d8f:         {
1:8f23d8f:             if ( columnNames[ i ] != null ) { _columnNumberMap[ i ] = foreignColumnID++; }
1:8f23d8f:         }
1:8f23d8f:     }
1:8f23d8f: 
1:8f23d8f:     ////////////////////////////////////////////////////////////////////////
1:8f23d8f:     //
1:8f23d8f:     //	Connection MANAGEMENT
1:8f23d8f:     //
1:8f23d8f:     ////////////////////////////////////////////////////////////////////////
1:8f23d8f: 
1:8f23d8f:     private static  Connection  getDerbyConnection() throws SQLException
1:8f23d8f:     {
1:8f23d8f:         return DriverManager.getConnection( "jdbc:default:connection" );
1:8f23d8f:     }
1:8f23d8f: 
1:8f23d8f: 
1:8f23d8f: 
1:8f23d8f:     ////////////////////////////////////////////////////////////////////////
1:8f23d8f:     //
1:8f23d8f:     //	QUERY FACTORY
1:8f23d8f:     //
1:8f23d8f:     ////////////////////////////////////////////////////////////////////////
1:8f23d8f: 
1:8f23d8f:     /**
1:8f23d8f:      * <p>
1:8f23d8f:      * Build the query which will be sent to the nested connection.
1:8f23d8f:      * </p>
1:8f23d8f:      */
1:8f23d8f:     private String  makeQuery()
1:8f23d8f:     {
1:8f23d8f:         StringBuffer   buffer = new StringBuffer();
1:8f23d8f: 
1:8f23d8f:         buffer.append( "select " );
1:8f23d8f: 
1:8f23d8f:         int possibleCount = _columnNames.length;
1:8f23d8f:         int actualCount = 0;
1:8f23d8f:         for ( int i = 0; i < possibleCount; i++ )
1:8f23d8f:         {
1:8f23d8f:             String  rawName = _columnNames[ i ];
1:8f23d8f:             if ( rawName == null ) { continue; }
1:8f23d8f: 
1:8f23d8f:             if ( actualCount > 0 ) { buffer.append( ", " ); }
1:8f23d8f:             actualCount++;
1:8f23d8f:             
1:8f23d8f:             buffer.append( doubleQuote( rawName ) );
1:8f23d8f:         }
1:8f23d8f: 
1:8f23d8f:         buffer.append( "\nfrom " );
1:8f23d8f:         buffer.append( doubleQuote( _schemaName ) );
1:8f23d8f:         buffer.append( '.' );
1:8f23d8f:         buffer.append( doubleQuote( _tableName ) );
1:8f23d8f: 
1:8f23d8f:         if ( _restriction != null )
1:8f23d8f:         {
1:8f23d8f:             String  clause = _restriction.toSQL();
1:8f23d8f: 
1:8f23d8f:             if (clause != null)
1:8f23d8f:             {
1:8f23d8f:                 clause = clause.trim();
1:8f23d8f:                 if ( clause.length() != 0 )
1:8f23d8f:                 {
1:8f23d8f:                     buffer.append( "\nwhere " + clause );
1:8f23d8f:                 }
1:8f23d8f:             }
1:8f23d8f:         }
1:8f23d8f: 
1:8f23d8f:         _lastQuery = buffer.toString();
1:8f23d8f: 
1:8f23d8f:         return _lastQuery;
1:8f23d8f:     }
1:8f23d8f: 
1:8f23d8f:     private static  String  doubleQuote( String text )  { return '"' + text + '"'; }
1:8f23d8f:     private static  String  singleQuote( String text )  { return '\'' + text + '\''; }
1:8f23d8f: 
1:8f23d8f:     private static  PreparedStatement   prepareStatement
1:8f23d8f:         ( Connection conn, String text )
1:8f23d8f:         throws SQLException
1:8f23d8f:     {
1:8f23d8f:         return conn.prepareStatement( text );
1:8f23d8f:     }
1:8f23d8f: 
1:8f23d8f:     ////////////////////////////////////////////////////////////////////////
1:8f23d8f:     //
1:8f23d8f:     //	UTILITY METHODS
1:8f23d8f:     //
1:8f23d8f:     ////////////////////////////////////////////////////////////////////////
1:8f23d8f: 
1:8f23d8f:     /**
1:8f23d8f:      * <p>
1:8f23d8f:      * Map a 1-based Derby column number to a 1-based column number in the
1:8f23d8f:      * query.
1:8f23d8f:      * </p>
1:8f23d8f:      */
1:8f23d8f:     private int mapColumnNumber( int derbyNumber )
1:8f23d8f:     {
1:8f23d8f:         return _columnNumberMap[ derbyNumber - 1 ];
1:8f23d8f:     }
1:8f23d8f: }
1:8f23d8f: 
============================================================================
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:2510115
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1:     @Deprecated
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:8f23d8f
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derbyTesting.functionTests.tests.lang.RestrictedTableVTI
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:      http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.tests.lang;
1: 
1: import java.io.InputStream;
1: import java.io.Reader;
1: import java.math.BigDecimal;
1: import java.sql.Blob;
1: import java.sql.Clob;
1: import java.sql.Connection;
1: import java.sql.Date;
0: import java.sql.DatabaseMetaData;
1: import java.sql.DriverManager;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.ResultSetMetaData;
1: import java.sql.SQLException;
1: import java.sql.Time;
1: import java.sql.Timestamp;
0: import java.sql.Types;
1: import java.util.Calendar;
0: import java.util.HashMap;
0: import java.util.Map;
1: 
1: import org.apache.derby.vti.VTITemplate;
1: import org.apache.derby.vti.RestrictedVTI;
1: import org.apache.derby.vti.Restriction;
1: 
1: /**
1:  * <p>
1:  * This class contains a table function which can be used to read data
1:  * from a Derby table.
1:  * </p>
1:  */
1: public	class   RestrictedTableVTI extends VTITemplate implements  RestrictedVTI
1: {
1:     ////////////////////////////////////////////////////////////////////////
1:     //
1:     //	CONSTANTS
1:     //
1:     ////////////////////////////////////////////////////////////////////////
1: 
1:     ////////////////////////////////////////////////////////////////////////
1:     //
1:     //	STATE
1:     //
1:     ////////////////////////////////////////////////////////////////////////
1: 
1:     private String  _schemaName;
1:     private String  _tableName;
1:     private Connection _connection;
1: 
1:     private String[]    _columnNames;
1:     private Restriction _restriction;
1: 
1:     // this maps table function columns (0-based) to table column numbers (1-based) in
1:     // the actual query
1:     private int[]               _columnNumberMap;
1:     private PreparedStatement   _preparedStatement;
1:     private ResultSet           _resultSet;
1: 
1:     private static  String  _lastQuery;
1: 
1:     ////////////////////////////////////////////////////////////////////////
1:     //
1:     //	CONSTRUCTOR
1:     //
1:     ////////////////////////////////////////////////////////////////////////
1: 
1:     protected  RestrictedTableVTI
1:         (
1:          String schemaName,
1:          String tableName
1:          )
1:         throws Exception
1:     {
1:         _schemaName = schemaName;
1:         _tableName = tableName;
1:         _connection = getDerbyConnection();
1:     }
1: 
1:     ////////////////////////////////////////////////////////////////////////
1:     //
1:     //	TABLE FUNCTIONS
1:     //
1:     ////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * <p>
1:      * Table function to read a table in Derby.
1:      * </p>
1:      */
1:     public  static  RestrictedTableVTI readTable
1:         (
1:          String schemaName,
1:          String tableName
1:          )
1:         throws Exception
1:     {
1:         return new RestrictedTableVTI( schemaName, tableName );
1:     }
1: 
1:     /**
1:      * <p>
1:      * Scalar function to retrieve the last query generated by this machinery.
1:      * </p>
1:      */
1:     public  static  String  getLastQuery() { return _lastQuery; }
1:     
1: 
1:     ////////////////////////////////////////////////////////////////////////
1:     //
1:     //	ResultSet BEHAVIOR
1:     //
1:     ////////////////////////////////////////////////////////////////////////
1: 
1:     public  void    close() throws SQLException
1:     {
1:         if ( !isClosed() )
1:         {
1:             _schemaName = null;
1:             _tableName = null;
1:             _connection = null;
1:             _columnNames = null;
1:             _restriction = null;
1:             _columnNumberMap = null;
1: 
1:             if ( _resultSet != null ) { _resultSet.close(); }
1:             if ( _preparedStatement != null ) { _preparedStatement.close(); }
1: 
1:             _resultSet = null;
1:             _preparedStatement = null;
1:         }
1:     }
1: 
1:     public  boolean next()  throws SQLException
1:     {
1:         if ( !isClosed() && (_resultSet == null) )
1:         {
1:             _preparedStatement = prepareStatement( _connection, makeQuery() );
1:             _resultSet = _preparedStatement.executeQuery();
1:         }
1: 
1:         return _resultSet.next();
1:     }
1: 
1:     public boolean isClosed() { return (_connection == null); }
1: 
1:     public  boolean wasNull()   throws SQLException
1:     { return _resultSet.wasNull(); }
1: 
1:     public  ResultSetMetaData   getMetaData()   throws SQLException
1:     { return _resultSet.getMetaData(); }
1: 
1:     public  InputStream 	getAsciiStream(int i) throws SQLException
1:     { return _resultSet.getAsciiStream( mapColumnNumber( i ) ); }
1:     
1:     public  BigDecimal 	getBigDecimal(int i) throws SQLException
1:     { return _resultSet.getBigDecimal( mapColumnNumber( i ) ); }
1:     
1:     public  BigDecimal 	getBigDecimal(int i, int scale) throws SQLException
1:     { return _resultSet.getBigDecimal( mapColumnNumber( i ), scale ); }
1:     
1:     public  InputStream 	getBinaryStream(int i)  throws SQLException
1:     { return _resultSet.getBinaryStream( mapColumnNumber( i ) ); }
1:     
1:     public  Blob 	getBlob(int i)  throws SQLException
1:     { return _resultSet.getBlob( mapColumnNumber( i ) ); }
1:     
1:     public  boolean 	getBoolean(int i) throws SQLException
1:     { return _resultSet.getBoolean( mapColumnNumber( i ) ); }
1:     
1:     public  byte 	getByte(int i)    throws SQLException
1:     { return _resultSet.getByte( mapColumnNumber( i ) ); }
1:     
1:     public  byte[] 	getBytes(int i) throws SQLException
1:     { return _resultSet.getBytes( mapColumnNumber( i ) ); }
1:     
1:     public  Reader 	getCharacterStream(int i) throws SQLException
1:     { return _resultSet.getCharacterStream( mapColumnNumber( i ) ); }
1: 
1:     public  Clob 	getClob(int i)  throws SQLException
1:     { return _resultSet.getClob( mapColumnNumber( i ) ); }
1: 
1:     public  Date 	getDate(int i)  throws SQLException
1:     { return _resultSet.getDate( mapColumnNumber( i ) ); }
1: 
1:     public  Date 	getDate(int i, Calendar cal)    throws SQLException
1:     { return _resultSet.getDate( mapColumnNumber( i ), cal ); }
1: 
1:     public  double 	getDouble(int i)    throws SQLException
1:     { return _resultSet.getDouble( mapColumnNumber( i ) ); }
1: 
1:     public  float 	getFloat(int i) throws SQLException
1:     { return _resultSet.getFloat( mapColumnNumber( i ) ); }
1: 
1:     public  int 	getInt(int i)   throws SQLException
1:     { return _resultSet.getInt( mapColumnNumber( i ) ); }
1: 
1:     public  long 	getLong(int i)  throws SQLException
1:     { return _resultSet.getLong( mapColumnNumber( i ) ); }
1: 
1:     public  Object 	getObject(int i)    throws SQLException
1:     { return _resultSet.getObject( mapColumnNumber( i ) ); }
1: 
1:     public  short 	getShort(int i) throws SQLException
1:     { return _resultSet.getShort( mapColumnNumber( i ) ); }
1: 
1:     public  String 	getString(int i)    throws SQLException
1:     { return _resultSet.getString( mapColumnNumber( i ) ); }
1: 
1:     public  Time 	getTime(int i)  throws SQLException
1:     { return _resultSet.getTime( mapColumnNumber( i ) ); }
1: 
1:     public  Time 	getTime(int i, Calendar cal)    throws SQLException
1:     { return _resultSet.getTime( mapColumnNumber( i ), cal ); }
1: 
1:     public  Timestamp 	getTimestamp(int i) throws SQLException
1:     { return _resultSet.getTimestamp( mapColumnNumber( i ) ); }
1: 
1:     public  Timestamp 	getTimestamp(int i, Calendar cal)   throws SQLException
1:     { return _resultSet.getTimestamp( mapColumnNumber( i ), cal ); }
1: 
1:     ////////////////////////////////////////////////////////////////////////
1:     //
1:     //	RestrictedVTI BEHAVIOR
1:     //
1:     ////////////////////////////////////////////////////////////////////////
1: 
1:     public  void    initScan
1:         ( String[] columnNames, Restriction restriction )
1:         throws SQLException
1:     {
1:         _columnNames = columnNames;
1:         _restriction = restriction;
1: 
1:         int columnCount = _columnNames.length;
1: 
1:         _columnNumberMap = new int[ columnCount ];
1:         int foreignColumnID = 1;
1:         for ( int i = 0; i < columnCount; i++ )
1:         {
1:             if ( columnNames[ i ] != null ) { _columnNumberMap[ i ] = foreignColumnID++; }
1:         }
1:     }
1: 
1:     ////////////////////////////////////////////////////////////////////////
1:     //
1:     //	Connection MANAGEMENT
1:     //
1:     ////////////////////////////////////////////////////////////////////////
1: 
1:     private static  Connection  getDerbyConnection() throws SQLException
1:     {
1:         return DriverManager.getConnection( "jdbc:default:connection" );
1:     }
1: 
1: 
1: 
1:     ////////////////////////////////////////////////////////////////////////
1:     //
1:     //	QUERY FACTORY
1:     //
1:     ////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * <p>
1:      * Build the query which will be sent to the nested connection.
1:      * </p>
1:      */
1:     private String  makeQuery()
1:     {
1:         StringBuffer   buffer = new StringBuffer();
1: 
1:         buffer.append( "select " );
1: 
1:         int possibleCount = _columnNames.length;
1:         int actualCount = 0;
1:         for ( int i = 0; i < possibleCount; i++ )
1:         {
1:             String  rawName = _columnNames[ i ];
1:             if ( rawName == null ) { continue; }
1: 
1:             if ( actualCount > 0 ) { buffer.append( ", " ); }
1:             actualCount++;
1:             
1:             buffer.append( doubleQuote( rawName ) );
1:         }
1: 
1:         buffer.append( "\nfrom " );
1:         buffer.append( doubleQuote( _schemaName ) );
1:         buffer.append( '.' );
1:         buffer.append( doubleQuote( _tableName ) );
1: 
1:         if ( _restriction != null )
1:         {
1:             String  clause = _restriction.toSQL();
1: 
1:             if (clause != null)
1:             {
1:                 clause = clause.trim();
1:                 if ( clause.length() != 0 )
1:                 {
1:                     buffer.append( "\nwhere " + clause );
1:                 }
1:             }
1:         }
1: 
1:         _lastQuery = buffer.toString();
1: 
1:         return _lastQuery;
1:     }
1: 
1:     private static  String  doubleQuote( String text )  { return '"' + text + '"'; }
1:     private static  String  singleQuote( String text )  { return '\'' + text + '\''; }
1: 
1:     private static  PreparedStatement   prepareStatement
1:         ( Connection conn, String text )
1:         throws SQLException
1:     {
1:         return conn.prepareStatement( text );
1:     }
1: 
1:     ////////////////////////////////////////////////////////////////////////
1:     //
1:     //	UTILITY METHODS
1:     //
1:     ////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * <p>
1:      * Map a 1-based Derby column number to a 1-based column number in the
1:      * query.
1:      * </p>
1:      */
1:     private int mapColumnNumber( int derbyNumber )
1:     {
1:         return _columnNumberMap[ derbyNumber - 1 ];
1:     }
1: }
1: 
============================================================================