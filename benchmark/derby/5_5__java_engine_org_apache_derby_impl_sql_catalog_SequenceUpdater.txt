1:139ca85: /*
24:139ca85: 
1:139ca85:    Derby - Class org.apache.derby.impl.sql.catalog.SequenceUpdater
1:139ca85: 
1:139ca85:    Licensed to the Apache Software Foundation (ASF) under one or more
1:139ca85:    contributor license agreements.  See the NOTICE file distributed with
1:139ca85:    this work for additional information regarding copyright ownership.
1:139ca85:    The ASF licenses this file to you under the Apache License, Version 2.0
1:139ca85:    (the "License"); you may not use this file except in compliance with
1:139ca85:    the License.  You may obtain a copy of the License at
1:139ca85: 
1:139ca85:       http://www.apache.org/licenses/LICENSE-2.0
1:139ca85: 
1:139ca85:    Unless required by applicable law or agreed to in writing, software
1:139ca85:    distributed under the License is distributed on an "AS IS" BASIS,
1:139ca85:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:139ca85:    See the License for the specific language governing permissions and
1:139ca85:    limitations under the License.
1:139ca85: 
3:139ca85:  */
1:139ca85: package org.apache.derby.impl.sql.catalog;
1:139ca85: 
1:a0dbbd7: import java.security.AccessController;
1:a0dbbd7: import java.security.PrivilegedAction;
1:7953b49: import java.util.HashMap;
1:7953b49: 
1:311ee54: import org.apache.derby.catalog.SequencePreallocator;
1:4c5c16b: import org.apache.derby.iapi.db.Database;
1:139ca85: import org.apache.derby.iapi.error.StandardException;
1:311ee54: import org.apache.derby.iapi.reference.Property;
1:139ca85: import org.apache.derby.iapi.reference.SQLState;
1:139ca85: import org.apache.derby.iapi.services.cache.Cacheable;
1:139ca85: import org.apache.derby.iapi.services.cache.CacheManager;
1:139ca85: import org.apache.derby.iapi.services.context.ContextManager;
1:a0dbbd7: import org.apache.derby.iapi.services.context.Context;
1:139ca85: import org.apache.derby.iapi.services.context.ContextService;
1:c8986df: import org.apache.derby.iapi.services.i18n.MessageService;
1:c8986df: import org.apache.derby.iapi.services.monitor.Monitor;
1:311ee54: import org.apache.derby.iapi.services.property.PropertyUtil;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:139ca85: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1:a180287: import org.apache.derby.iapi.sql.dictionary.BulkInsertCounter;
1:8612b0b: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
1:139ca85: import org.apache.derby.iapi.sql.dictionary.SequenceDescriptor;
1:c8986df: import org.apache.derby.iapi.store.access.AccessFactory;
1:139ca85: import org.apache.derby.iapi.store.access.TransactionController;
1:139ca85: import org.apache.derby.iapi.types.NumberDataValue;
1:139ca85: import org.apache.derby.iapi.types.RowLocation;
1:139ca85: 
3:139ca85: /**
3:139ca85:  * <p>
1:139ca85:  * An object cached in the data dictionary which manages new values
1:139ca85:  * for sequences. Note that this class must be public and
1:139ca85:  * have a 0-arg constructor in order to satisfy the Cacheable contract.
3:139ca85:  * </p>
3:139ca85:  *
1:139ca85:  * <p>
1:139ca85:  * This is the abstract superclass of specific implementations for specific
1:139ca85:  * sequences. For instance, one subclass handles the ANSI/ISO sequences
1:139ca85:  * stored in SYSSEQUENCES. Another subclass could handle the sequences
1:139ca85:  * stored in Derby's identity columns.
1:139ca85:  * </p>
1:139ca85:  *
1:139ca85:  * <p>
1:139ca85:  * This class does a couple tricky things:
1:139ca85:  * </p>
1:139ca85:  *
2:139ca85:  * <ul>
1:139ca85:  * <li>It pre-allocates a range of values from a sequence so that we don't have to change
1:139ca85:  *  the on-disk value every time we get the next value for a sequence.</li>
1:8e352d6:  * <li>When updating the on-disk value, we use a subtransaction of the user's
1:8e352d6:  * execution transaction. If the
1:8e352d6:  * special transaction cannot do its work immediately, without waiting for a lock, then
1:8e352d6:  * a TOO MUCH CONTENTION error is raised. It is believed that this can only happen
1:8e352d6:  * if someone holds locks on SYSSEQUENCES, either via sequence DDL or a scan
1:8e352d6:  * of the catalog. The TOO MUCH CONTENTION error tells
1:8e352d6:  * the user to not scan SYSSEQUENCES directly, but to instead use the
1:8e352d6:  * SYSCS_UTIL.SYSCS_PEEK_AT_SEQUENCE() if the user needs the current value of the
1:8e352d6:  * sequence generator.</li>
2:139ca85:  * </ul>
1:139ca85:  *
1:139ca85:  * <p>
1:139ca85:  * Here is the algorithm pursued when the caller asks for the next number in a sequence:
1:139ca85:  * </p>
1:139ca85:  *
1:139ca85:  *
1:139ca85:  * <ul>
1:139ca85:  * <li>We try to get the next number from a cache of pre-allocated numbers. The endpoint
1:139ca85:  * (last number in the pre-allocated range) was previously recorded in the catalog row which
1:139ca85:  * describes this sequence. If we are successful in getting the next number, we
1:139ca85:  * return it and all is well.</li>
1:8e352d6:  * <li>Otherwise, we must allocate a new range by updating the catalog row. We should not
1:8e352d6:  * be in contention with another connection because the update method is synchronized.</li>
1:139ca85:  * </ul>
1:139ca85:  *
1:139ca85:  */
1:139ca85: public abstract class SequenceUpdater implements Cacheable
1:39c6ffc: {
1:139ca85:     ///////////////////////////////////////////////////////////////////////////////////
1:68c72e7:     //
1:139ca85:     // CONSTANTS
1:68c72e7:     //
1:139ca85:     ///////////////////////////////////////////////////////////////////////////////////
1:729be57: 
1:139ca85:     ///////////////////////////////////////////////////////////////////////////////////
1:729be57:     //
1:139ca85:     // CONSTANT STATE
11:139ca85:     //
1:139ca85:     ///////////////////////////////////////////////////////////////////////////////////
1:729be57: 
1:139ca85:     // DataDictionary where this generator is cached.
1:139ca85:     protected DataDictionaryImpl _dd;
1:39c6ffc: 
1:7953b49:     //
1:7953b49:     // The following state needs to be reset whenever this Cachable is re-used.
1:7953b49:     //
1:7953b49:     
1:7953b49:     /** This is the key used to lookup this generator in the cache. */
1:139ca85:     protected String _uuidString;
1:139ca85: 
1:7953b49:     /** This is the object which allocates ranges of sequence values */
1:139ca85:     protected SequenceGenerator _sequenceGenerator;
1:39c6ffc: 
1:139ca85:     ///////////////////////////////////////////////////////////////////////////////////
1:139ca85:     //
1:139ca85:     // CONSTRUCTOR
1:139ca85:     //
1:139ca85:     ///////////////////////////////////////////////////////////////////////////////////
1:139ca85: 
1:139ca85:     /** No-arg constructor to satisfy the Cacheable contract */
1:39c6ffc:     public SequenceUpdater()
1:729be57:     {
1:39c6ffc:     }
1:68c72e7: 
1:139ca85:     /** Normal constructor */
1:139ca85:     public SequenceUpdater( DataDictionaryImpl dd )
1:68c72e7:     {
1:39c6ffc:         this();
1:68c72e7:         
1:139ca85:         _dd = dd;
1:68c72e7:     }
1:39c6ffc:     
1:139ca85:     ///////////////////////////////////////////////////////////////////////////////////
1:139ca85:     //
1:68c72e7:     // ABSTRACT OR OVERRIDABLE BEHAVIOR TO BE IMPLEMENTED BY CHILDREN
1:139ca85:     //
1:139ca85:     ///////////////////////////////////////////////////////////////////////////////////
1:39c6ffc: 
1:a180287:     /**
1:a180287:      * <p>
1:139ca85:      * Initialize the sequence generator. Work is done inside a read-only subtransaction of
1:139ca85:      * the session's execution transaction.
1:729be57:      * </p>
1:68c72e7:      */
1:139ca85:      abstract protected SequenceGenerator createSequenceGenerator( TransactionController readOnlyTC )
1:139ca85:          throws StandardException;
1:39c6ffc: 
1:68c72e7:     /**
1:139ca85:      * <p>
1:8e352d6:      * Update the sequence value on disk. This method does its work in a subtransaction of
1:8e352d6:      * the user's execution transaction.
1:139ca85:      * </p>
1:139ca85:      *
1:139ca85:      * @param tc The transaction to use
1:139ca85:      * @param oldValue Expected value on disk for this sequence
1:139ca85:      * @param newValue The value to poke into the system table backing this sequence
1:139ca85:      * @param wait Whether to wait for a lock
1:139ca85:      *
1:139ca85: 	 * 
1:139ca85: 	 * @return Returns true if the value was successfully updated, false if we lost a race with another session.
1:139ca85:      *
1:139ca85:      * @throws StandardException May throw an exception if a lock can't be obtained.
1:729be57:      */
1:139ca85:     abstract protected boolean updateCurrentValueOnDisk( TransactionController tc, Long oldValue, Long newValue, boolean wait ) throws StandardException;
1:139ca85:     
1:68c72e7:     /**
1:68c72e7:      * <p>
1:68c72e7:      * Create an exception to state that there is too much contention on the generator.
1:68c72e7:      * For backward compatibility reasons, different messages are needed by sequences
1:68c72e7:      * and identities. See DERBY-5426.
1:68c72e7:      * </p>
1:68c72e7:      */
1:8612b0b:     private   StandardException   tooMuchContentionException()
1:68c72e7:     {
1:8612b0b:         // If the sequence lives in the SYS schema, then it is used to back an identity column.
1:8612b0b:         if ( SchemaDescriptor.STD_SYSTEM_SCHEMA_NAME.equals( _sequenceGenerator.getSchemaName() ) )
1:8612b0b:         {
1:8612b0b:             return StandardException.newException( SQLState.LOCK_TIMEOUT );
1:8612b0b:         }
1:8612b0b:         else
1:8612b0b:         {
1:8612b0b:             return StandardException.newException
1:8612b0b:                 ( SQLState.LANG_TOO_MUCH_CONTENTION_ON_SEQUENCE, _sequenceGenerator.getName() );
1:8612b0b:         }
1:68c72e7:     }
1:68c72e7:     
1:139ca85:     ///////////////////////////////////////////////////////////////////////////////////
1:139ca85:     //
1:139ca85:     // Cacheable BEHAVIOR
1:139ca85:     //
1:139ca85:     ///////////////////////////////////////////////////////////////////////////////////
1:139ca85: 
1:139ca85: 	public void clean(boolean forRemove) throws StandardException
1:39c6ffc: 	{
1:139ca85:         //
1:139ca85:         // Flush current value to disk. This prevents us from leaking values when DDL
1:139ca85:         // is performed. The metadata caches are invalidated and cleared when DDL is performed.
1:c8986df:         // We flush the current value to disk on database shutdown also.
1:7953b49:         // The call to updateCurrentValueOnDisk can fail if someone is holding a lock
1:7953b49:         // on the SYS.SYSSEQUENCES row. This can happen if the user disregards our
1:7953b49:         // advice and scans that catalog. This can also happen if the transaction which
1:7953b49:         // creates the sequences is open for a long time and some later sequence creation
1:7953b49:         // causes us to evict the old, uncommitted sequence generator from the cache.
1:139ca85:         //
1:7953b49:         boolean gapClosed = false;
1:c8986df: 
1:7953b49:         try {
1:7953b49:             if ( _sequenceGenerator == null ) { gapClosed = true; }
1:7953b49:             else
1:7953b49:             {
1:7953b49:                 gapClosed = updateCurrentValueOnDisk( null, peekAtCurrentValue() );
1:7953b49:             }
1:7953b49:         }
1:7953b49:         catch (StandardException se)
1:7953b49:         {
1:7953b49:             // The too much contention exception is redundant because the problem is logged
1:7953b49:             // by the message below
1:7953b49:             if ( !SQLState.LANG_TOO_MUCH_CONTENTION_ON_SEQUENCE.equals( se.getMessageId() ) )
1:7953b49:             {
1:7953b49:                 throw se;
1:7953b49:             }
1:7953b49:         }
1:7953b49:         finally
1:7953b49:         {
1:c8986df:             // log an error message if we failed to flush the preallocated values.
1:c8986df:             if ( !gapClosed )
1:c8986df:             {
1:c8986df:                 String  errorMessage = MessageService.getTextMessage
1:c8986df:                     (
1:c8986df:                      SQLState.LANG_CANT_FLUSH_PREALLOCATOR,
1:c8986df:                      _sequenceGenerator.getSchemaName(),
1:c8986df:                      _sequenceGenerator.getName()
1:c8986df:                      );
1:c8986df: 
1:c8986df:                 Monitor.getStream().println( errorMessage );
1:c8986df:             }
1:39c6ffc: 
1:7953b49:             _uuidString = null;
1:7953b49:             _sequenceGenerator = null;
1:7953b49:         }
1:39c6ffc: 	}
1:139ca85:     
1:139ca85: 	public boolean isDirty() { return false; }
1:139ca85:     public Object getIdentity() { return _uuidString; }
1:139ca85: 
1:139ca85: 	public void clearIdentity()
1:39c6ffc:     {
1:139ca85:         try
1:39c6ffc:         {
1:139ca85:             clean( false );
1:139ca85:         } catch (StandardException se)
8:139ca85:         {
1:4c5c16b:             //Doing check for lcc and db to be certain
1:4c5c16b:             LanguageConnectionContext lcc = getLCC();
1:9da08da:             if (lcc != null)
1:139ca85:             {
1:9da08da:                 Database db = lcc.getDatabase();
1:9da08da:                 boolean isactive = (db != null ? db.isActive() : false);
1:9da08da:                 lcc.getContextManager().cleanupOnError(se, isactive);
1:39c6ffc:             }
7:139ca85:         }
1:139ca85:     }
1:139ca85: 
1:139ca85: 	public Cacheable createIdentity( Object key, Object createParameter ) throws StandardException
1:139ca85: 	{
1:139ca85:         Cacheable cacheable = this;
1:139ca85: 
1:139ca85:         //
1:139ca85:         // The createParameter arg is unused.
1:139ca85:         //
1:139ca85:         return cacheable.setIdentity( key );
1:139ca85: 	}
1:139ca85: 
1:139ca85: 	/**
1:139ca85: 	 * @see Cacheable#setIdentity
1:139ca85: 	 *
1:139ca85: 	 * @exception StandardException		Thrown on error
1:139ca85: 	 */
1:139ca85: 	public Cacheable setIdentity(Object key) throws StandardException
1:139ca85: 	{
1:139ca85: 		if (SanityManager.DEBUG)
1:139ca85: 		{
1:139ca85: 			if (!(key instanceof String))
1:139ca85: 			{
1:139ca85: 				SanityManager.THROWASSERT( "Key for a SequenceUpdater is a " + key.getClass().getName() );
1:139ca85: 			}
1:139ca85: 
1:139ca85:             if ( (_uuidString != null) || (_sequenceGenerator != null) )
1:139ca85: 			{
1:139ca85: 				SanityManager.THROWASSERT( "Identity being changed on a live cacheable. Old uuidString = " + _uuidString );
1:139ca85: 			}
1:139ca85: 		}
1:139ca85: 
1:139ca85: 		_uuidString = (String) key;
1:139ca85: 
1:139ca85:         if ( _sequenceGenerator == null )
1:139ca85:         {
1:139ca85:             TransactionController executionTC = getLCC().getTransactionExecute();
1:139ca85:             
1:139ca85:             //
1:139ca85:             // We lookup information in a read-only subtransaction in order to minimize
1:139ca85:             // contention. Since this is a read-only subtransaction, there should be
1:139ca85:             // no conflict with the parent transaction.
1:139ca85:             //
1:ceaf7df:             TransactionController subTransaction = 
1:ceaf7df:                 executionTC.startNestedUserTransaction( true, true );
1:139ca85: 
3:139ca85:             try {
1:139ca85:                 _sequenceGenerator = createSequenceGenerator( subTransaction );
1:139ca85:             }
1:139ca85:             finally
1:139ca85:             {
1:132af01:                 // if we failed to get a generator, we have no identity. see DERBY-5389.
1:132af01:                 if ( _sequenceGenerator == null ) { _uuidString = null; }
1:132af01:             
1:139ca85:                 subTransaction.commit();
1:139ca85:                 subTransaction.destroy();
1:139ca85:             }
1:139ca85:         }
1:139ca85: 
1:139ca85: 		if ( _sequenceGenerator != null ) { return this; }
1:139ca85: 		else { return null; }
1:139ca85: 	}
1:139ca85: 
1:139ca85:     ///////////////////////////////////////////////////////////////////////////////////
1:139ca85:     //
1:139ca85:     // PUBLIC BEHAVIOR
1:139ca85:     //
1:139ca85:     ///////////////////////////////////////////////////////////////////////////////////
1:139ca85: 
1:139ca85:     /**
1:139ca85:      * <p>
1:a180287:      * Reset the sequence generator to a new start value. This is used by the special
1:a180287:      * bulk-insert optimization in InsertResultSet.
1:a180287:      * </p>
1:a180287:      */
1:a180287:     public synchronized void reset( Long newValue )
1:a180287:         throws StandardException
1:a180287:     {
1:a180287:         // first try to reset on disk
1:a180287:         updateCurrentValueOnDisk( null, newValue );
1:a180287: 
1:a180287:         // now reset the sequence generator
1:a180287:         _sequenceGenerator = _sequenceGenerator.clone( newValue );
1:a180287:     }
1:a180287:     
1:a180287:     /**
1:a180287:      * <p>
1:a180287:      * Get the SequenceUpdater used for the bulk-insert optimization in InsertResultSet.
1:a180287:      * </p>
1:a180287:      *
1:a180287:      * @param restart   True if the counter should be re-initialized to its start position.
1:a180287:      */
1:a180287:     public synchronized BulkInsertUpdater   getBulkInsertUpdater( boolean restart )
1:a180287:         throws StandardException
1:a180287:     {
1:a180287:         return new BulkInsertUpdater( this, restart );
1:a180287:     }
1:a180287:     
1:a180287:     /**
1:a180287:      * <p>
1:139ca85:      * Get the next sequence number managed by this generator and advance the number. Could raise an
1:139ca85:      * exception if the legal range is exhausted and wrap-around is not allowed.
1:8e352d6:      * Only one thread at a time is allowed through here. We do not want a race between the
1:8e352d6:      * two calls to the sequence generator: getCurrentValueAndAdvance() and allocateNewRange().
1:139ca85:      * </p>
1:139ca85:      *
1:139ca85:      * @param returnValue This value is stuffed with the new sequence number.
1:139ca85:      */
1:8e352d6:     public synchronized void getCurrentValueAndAdvance
1:139ca85:         ( NumberDataValue returnValue ) throws StandardException
1:139ca85:     {
1:139ca85:         //
1:8e352d6:         // We may have to try to get a value from the Sequence Generator twice.
1:8e352d6:         // The first attempt may fail because we need to pre-allocate a new chunk
1:8e352d6:         // of values.
1:139ca85:         //
1:8e352d6:         for ( int i = 0; i < 2; i++ )
1:139ca85:         {
1:8e352d6:             //
1:8e352d6:             // We try to get a sequence number. The SequenceGenerator method is synchronized
1:8e352d6:             // so only one writer should be in there at a time. Lock contention is possible if
1:8e352d6:             // someone has selected from SYSSEQUENCES contrary to our advice. In that case,
1:8e352d6:             // we raise a TOO MUCH CONTENTION exception.
1:8e352d6:             //
1:139ca85:             long[] cvaa = _sequenceGenerator.getCurrentValueAndAdvance();
1:68c72e7:             
1:139ca85:             int status = (int) cvaa[ SequenceGenerator.CVAA_STATUS ];
1:139ca85:             long currentValue = cvaa[ SequenceGenerator.CVAA_CURRENT_VALUE ];
1:139ca85:             long lastAllocatedValue = cvaa[ SequenceGenerator.CVAA_LAST_ALLOCATED_VALUE ];
1:139ca85:             long numberOfValuesAllocated = cvaa[ SequenceGenerator.CVAA_NUMBER_OF_VALUES_ALLOCATED ];
1:139ca85:             
1:139ca85:             switch ( status )
1:139ca85:             {
1:139ca85:             case SequenceGenerator.RET_OK:
1:139ca85:                 returnValue.setValue( currentValue );
1:139ca85:                 return;
1:139ca85:                 
1:139ca85:             case SequenceGenerator.RET_MARK_EXHAUSTED:
1:ce40a31:                 updateCurrentValueOnDisk( currentValue, null );
1:139ca85:                 returnValue.setValue( currentValue );
1:139ca85:                 return;
1:139ca85:                 
1:139ca85:             case SequenceGenerator.RET_ALLOCATE_NEW_VALUES:
1:139ca85:                 
1:ce40a31:                 if ( updateCurrentValueOnDisk( currentValue, lastAllocatedValue ) )
1:139ca85:                 {
1:139ca85:                     _sequenceGenerator.allocateNewRange( currentValue, numberOfValuesAllocated );
1:139ca85:                 }
1:39c6ffc:                 break;
1:8e352d6:             
1:139ca85:             default:
1:139ca85:                 throw unimplementedFeature();
1:8e352d6:             }
1:39c6ffc:         }
1:139ca85: 
1:8e352d6:         //
1:8e352d6:         // If we get here, then we failed to allocate a new sequence number range.
1:8e352d6:         //
1:8e352d6:         throw tooMuchContentionException();
1:139ca85:     }
1:139ca85: 
1:139ca85:     /**
1:139ca85:      * <p>
1:139ca85:      * Get the current value of the sequence generator without advancing it.
1:139ca85:      * May return null if the generator is exhausted.
1:139ca85:      * </p>
1:139ca85:      */
1:8e352d6:     public Long peekAtCurrentValue() throws StandardException
1:139ca85:     {
1:139ca85:         return _sequenceGenerator.peekAtCurrentValue();
1:139ca85:     }
1:139ca85: 
1:139ca85:     ///////////////////////////////////////////////////////////////////////////////////
1:139ca85:     //
1:139ca85:     // DISK WRITING MINIONS
1:139ca85:     //
1:139ca85:     ///////////////////////////////////////////////////////////////////////////////////
1:139ca85: 
1:139ca85:     /**
1:139ca85:      * <p>
1:8e352d6:      * Update the value on disk. Does its work in a subtransaction of the user's
1:8e352d6:      * execution transaction. If that fails, raises a TOO MUCH CONTENTION exception.
1:139ca85:      * </p>
1:139ca85: 	 * 
1:139ca85: 	 * @return Returns true if the value was successfully updated, false if we lost a race with another session.
1:139ca85:      *
1:139ca85:      */
1:8e352d6:     public synchronized boolean updateCurrentValueOnDisk( Long oldValue, Long newValue ) throws StandardException
1:139ca85:     {
1:c8986df:         LanguageConnectionContext   lcc = getLCC();
1:c8986df: 
1:c8986df:         //
1:c8986df:         // Not having an LCC should mean that we are in the middle of engine
1:c8986df:         // shutdown. We get here only to flush the current value to disk so that
1:c8986df:         // we don't leak unused sequence numbers. See DERBY-5398.
1:c8986df:         //
1:c8986df:         if ( lcc == null )
1:c8986df:         {
1:c8986df:             if (SanityManager.DEBUG)
1:c8986df:             {
1:c8986df: 				SanityManager.ASSERT( oldValue == null, "We should be flushing unused sequence values here." );
1:c8986df: 			}
1:c8986df:             
1:a0dbbd7:             ContextService csf = getContextService();
1:c8986df:             ContextManager cm = csf.getCurrentContextManager();
1:c8986df:             AccessFactory af = _dd.af;
1:c8986df:             TransactionController   dummyTransaction = af.getTransaction( cm );
1:c8986df: 
1:c8986df:             boolean retval = updateCurrentValueOnDisk( dummyTransaction, oldValue, newValue, false );
1:c8986df:             dummyTransaction.commit();
1:c8986df:             dummyTransaction.destroy();
1:c8986df: 
1:c8986df:             return retval;
1:c8986df: 		}
1:c8986df: 
1:c8986df:         TransactionController executionTransaction = lcc.getTransactionExecute();
1:ceaf7df:         TransactionController nestedTransaction = 
1:ceaf7df:             executionTransaction.startNestedUserTransaction( false, true );
1:139ca85: 
1:139ca85:         if ( nestedTransaction != null )
1:8e352d6:         {
1:7953b49:             boolean retval = false;
1:9819cf8:             boolean escalateToParentTransaction = false;
1:7953b49:             
1:8e352d6:             try
1:139ca85:             {
1:7953b49:                 retval = updateCurrentValueOnDisk( nestedTransaction, oldValue, newValue, false );
1:139ca85:             }
1:139ca85:             catch (StandardException se)
1:139ca85:             {
1:9819cf8:                 if ( !se.isLockTimeout() )
1:9819cf8:                 {
1:9819cf8:                     if ( se.isSelfDeadlock() )
1:9819cf8:                     {
1:9819cf8:                         // We're blocked by a lock held by our parent transaction.
1:9819cf8:                         // Escalate into the parent transaction now. See DERBY-6554.
1:9819cf8:                         escalateToParentTransaction = true;
1:9819cf8:                     }
1:9819cf8:                     else
1:9819cf8:                     {
1:9819cf8:                         Monitor.logThrowable( se );
1:9819cf8:                         throw se;
1:9819cf8:                     }
1:9819cf8:                 }
1:139ca85:             }
1:139ca85:             finally
1:139ca85:             {
1:5705f5b:                 // DERBY-5494, if this commit does not flush log then an
1:5705f5b:                 // unorderly shutdown could lose the update.  Do not use
1:5705f5b:                 // commitNoSync(), and store needs to flush user nested update
1:5705f5b:                 // transaction commits by default.
1:139ca85:                 nestedTransaction.commit();
1:139ca85:                 nestedTransaction.destroy();
1:7953b49: 
1:9819cf8:                 if ( escalateToParentTransaction )
1:9819cf8:                 {
1:9819cf8:                     retval = updateCurrentValueOnDisk( executionTransaction, oldValue, newValue, false );
1:9819cf8:                 }
1:9819cf8: 
1:7953b49:                 return retval;
1:139ca85:             }
1:139ca85:         }
1:39c6ffc:         
1:139ca85:         // If we get here, we failed to do the work in the nested transaction.
1:8e352d6:         // We might be self-deadlocking if the user has selected from SYSSEQUENCES
1:8e352d6:         // contrary to our advice.
1:8e352d6: 
1:8e352d6:         throw tooMuchContentionException();
1:139ca85:     }
1:39c6ffc: 
1:139ca85:     ///////////////////////////////////////////////////////////////////////////////////
1:139ca85:     //
1:139ca85:     // UTILITY MINIONS
1:139ca85:     //
1:139ca85:     ///////////////////////////////////////////////////////////////////////////////////
1:139ca85: 
1:311ee54:     /** Make a new range allocator (called when the generator is instantiated) */
1:311ee54:     protected SequencePreallocator  makePreallocator( TransactionController tc )
1:311ee54:         throws StandardException
1:311ee54:     {
1:311ee54:         String  propertyName = Property.LANG_SEQUENCE_PREALLOCATOR;
1:311ee54:         String  className = PropertyUtil.getServiceProperty( tc, propertyName );
1:311ee54: 
1:311ee54:         if ( className == null ) { return new SequenceRange(); }
1:311ee54: 
1:311ee54:         try {
1:365a750:             // If the property value was a number rather than a class name, then
1:365a750:             // use that as the default size for preallocated ranges.
1:365a750:             if ( isNumber( className ) )
1:365a750:             {
1:365a750:                 return new SequenceRange( Integer.parseInt( className ) );
1:365a750:             }
1:365a750: 
1:59f29e4:             Class<?> klass = Class.forName(className);
1:59f29e4:             if (!SequencePreallocator.class.isAssignableFrom(klass)) {
1:59f29e4:                 throw StandardException.newException(
1:59f29e4:                     SQLState.LANG_NOT_A_SEQUENCE_PREALLOCATOR, propertyName);
1:311ee54:             }
1:139ca85: 
1:4469400:             return (SequencePreallocator) klass.getConstructor().newInstance();
1:139ca85:         }
1:311ee54:         catch (ClassNotFoundException e) { throw missingAllocator( propertyName, className, e ); }
1:311ee54:         catch (ClassCastException e) { throw missingAllocator( propertyName, className, e ); }
1:311ee54:         catch (InstantiationException e) { throw missingAllocator( propertyName, className, e ); }
1:311ee54:         catch (IllegalAccessException e) { throw missingAllocator( propertyName, className, e ); }
1:365a750:         catch (NumberFormatException e) { throw missingAllocator( propertyName, className, e ); }
1:4469400:         catch (NoSuchMethodException e) { throw missingAllocator( propertyName, className, e ); }
1:4469400:         catch (java.lang.reflect.InvocationTargetException e) { throw missingAllocator( propertyName, className, e ); }
1:311ee54:     }
1:311ee54:     private StandardException   missingAllocator( String propertyName, String className, Exception e )
1:311ee54:     {
1:311ee54:         return StandardException.newException( SQLState.LANG_UNKNOWN_SEQUENCE_PREALLOCATOR, e, propertyName, className );
1:311ee54:     }
1:365a750:     private boolean isNumber( String text )
1:365a750:     {
1:365a750:         int length = text.length();
1:365a750: 
1:365a750:         for ( int i = 0; i < length; i++ )
1:365a750:         {
1:365a750:             if ( !Character.isDigit( text.charAt( i ) ) ) { return false; }
1:365a750:         }
1:365a750: 
1:365a750:         return true;
1:365a750:     }
1:311ee54:     
1:139ca85: 	private static LanguageConnectionContext getLCC()
1:139ca85:     {
1:139ca85: 		return (LanguageConnectionContext) 
1:a0dbbd7: 					getContextOrNull(LanguageConnectionContext.CONTEXT_ID);
1:139ca85: 	}
1:139ca85: 
1:139ca85:     /** Report an unimplemented feature */
1:139ca85:     private StandardException unimplementedFeature()
1:139ca85:     {
1:139ca85:         return StandardException.newException( SQLState.BTREE_UNIMPLEMENTED_FEATURE );
1:139ca85:     }
1:139ca85: 
1:a0dbbd7:     /**
1:a0dbbd7:      * Privileged lookup of the ContextService. Must be private so that user code
1:a0dbbd7:      * can't call this entry point.
1:a0dbbd7:      */
1:a0dbbd7:     private  static  ContextService    getContextService()
1:a0dbbd7:     {
1:a0dbbd7:         if ( System.getSecurityManager() == null )
1:a0dbbd7:         {
1:a0dbbd7:             return ContextService.getFactory();
1:a0dbbd7:         }
1:a0dbbd7:         else
1:a0dbbd7:         {
1:a0dbbd7:             return AccessController.doPrivileged
1:a0dbbd7:                 (
1:a0dbbd7:                  new PrivilegedAction<ContextService>()
1:a0dbbd7:                  {
1:a0dbbd7:                      public ContextService run()
1:a0dbbd7:                      {
1:a0dbbd7:                          return ContextService.getFactory();
1:a0dbbd7:                      }
1:a0dbbd7:                  }
1:a0dbbd7:                  );
1:a0dbbd7:         }
1:a0dbbd7:     }
1:a0dbbd7: 
1:a0dbbd7:     
1:a0dbbd7:     /**
1:a0dbbd7:      * Privileged lookup of a Context. Must be private so that user code
1:a0dbbd7:      * can't call this entry point.
1:a0dbbd7:      */
1:a0dbbd7:     private  static  Context    getContextOrNull( final String contextID )
1:a0dbbd7:     {
1:a0dbbd7:         if ( System.getSecurityManager() == null )
1:a0dbbd7:         {
1:a0dbbd7:             return ContextService.getContextOrNull( contextID );
1:a0dbbd7:         }
1:a0dbbd7:         else
1:a0dbbd7:         {
1:a0dbbd7:             return AccessController.doPrivileged
1:a0dbbd7:                 (
1:a0dbbd7:                  new PrivilegedAction<Context>()
1:a0dbbd7:                  {
1:a0dbbd7:                      public Context run()
1:a0dbbd7:                      {
1:a0dbbd7:                          return ContextService.getContextOrNull( contextID );
1:a0dbbd7:                      }
1:a0dbbd7:                  }
1:a0dbbd7:                  );
1:a0dbbd7:         }
1:a0dbbd7:     }
1:a0dbbd7: 
1:139ca85:     ///////////////////////////////////////////////////////////////////////////////////
1:139ca85:     //
1:bb4cfe9:     // INNER CLASSES
1:139ca85:     //
1:139ca85:     ///////////////////////////////////////////////////////////////////////////////////
1:139ca85: 
1:139ca85:     /**
1:139ca85:      * <p>
1:729be57:      * Specific implementation of SequenceUpdater for the sequences managed by
1:139ca85:      * SYSSEQUENCES.
1:139ca85:      * </p>
1:139ca85:      */
1:139ca85:     public static final class SyssequenceUpdater extends SequenceUpdater
1:139ca85:     {
1:729be57:         private RowLocation _sequenceRowLocation;
1:139ca85: 
1:139ca85:         public SyssequenceUpdater() { super(); }
1:139ca85:         public SyssequenceUpdater( DataDictionaryImpl dd ) { super( dd ); }
1:139ca85:     
1:139ca85:         //
1:729be57:         // SequenceUpdater BEHAVIOR
1:729be57:         //
1:729be57: 
1:729be57:         protected SequenceGenerator createSequenceGenerator( TransactionController readOnlyTC )
1:729be57:             throws StandardException
1:729be57:         {
1:729be57:             RowLocation[] rowLocation = new RowLocation[ 1 ];
1:729be57:             SequenceDescriptor[] sequenceDescriptor = new SequenceDescriptor[ 1 ];
1:729be57:             
1:139ca85:             _dd.computeSequenceRowLocation( readOnlyTC, _uuidString, rowLocation, sequenceDescriptor );
1:729be57:             
1:729be57:             _sequenceRowLocation = rowLocation[ 0 ];
1:729be57:             
1:729be57:             SequenceDescriptor isd = sequenceDescriptor[ 0 ];
1:729be57:             
1:729be57:             return new SequenceGenerator
1:729be57:                 (
1:729be57:                  isd.getCurrentValue(),
1:729be57:                  isd.canCycle(),
1:729be57:                  isd.getIncrement(),
1:729be57:                  isd.getMaximumValue(),
1:729be57:                  isd.getMinimumValue(),
1:729be57:                  isd.getStartValue(),
1:311ee54:                  isd.getSchemaDescriptor().getSchemaName(),
1:311ee54:                  isd.getSequenceName(),
1:311ee54:                  makePreallocator( readOnlyTC )
1:729be57:                  );
1:729be57:         }
1:729be57: 
1:729be57:         protected boolean updateCurrentValueOnDisk( TransactionController tc, Long oldValue, Long newValue, boolean wait ) throws StandardException
1:729be57:         {
1:139ca85:             return _dd.updateCurrentSequenceValue( tc, _sequenceRowLocation, wait, oldValue, newValue );
1:729be57:         }
1:729be57:     }
1:729be57: 
1:729be57:     /**
1:729be57:      * <p>
1:a180287:      * Implementation of SequenceUpdater for use with the bulk-insert optimization
1:a180287:      * used by InsertResultSet. This BulkInsertUpdater doesn't really write to disk. It is assumed
1:a180287:      * that the BulkInsertUpdater will only be used by the bulk-insert code, where the
1:a180287:      * user has exclusive write-access on the table whose identity column is backed by
1:a180287:      * the original SequenceUpdater. At the end of bulk-insert, the current value of the
1:a180287:      * BulkInsertUpdater is written to disk by other code.
1:a180287:      * </p>
1:a180287:      */
1:a180287:     public static final class BulkInsertUpdater extends SequenceUpdater implements BulkInsertCounter
1:a180287:     {
1:a180287:         public BulkInsertUpdater() { super(); }
1:a180287:         public BulkInsertUpdater( SequenceUpdater originalUpdater, boolean restart )
1:a180287:         {
1:a180287:             _sequenceGenerator = originalUpdater._sequenceGenerator.clone( restart );
1:a180287:         }
1:a180287:     
1:a180287:         //
1:a180287:         // SequenceUpdater BEHAVIOR
1:a180287:         //
1:a180287: 
1:a180287:         protected SequenceGenerator createSequenceGenerator( TransactionController readOnlyTC )
1:a180287:             throws StandardException
1:a180287:         {
1:a180287:             return _sequenceGenerator;
1:a180287:         }
1:a180287: 
1:a180287:         protected boolean updateCurrentValueOnDisk( TransactionController tc, Long oldValue, Long newValue, boolean wait )
1:a180287:             throws StandardException
1:a180287:         {
1:a180287:             // always succeeds
1:a180287:             return true;
1:a180287:         }
1:a180287:     }
1:a180287: 
1:139ca85: }
1:139ca85: 
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:4469400
/////////////////////////////////////////////////////////////////////////
1:             return (SequencePreallocator) klass.getConstructor().newInstance();
1:         catch (NoSuchMethodException e) { throw missingAllocator( propertyName, className, e ); }
1:         catch (java.lang.reflect.InvocationTargetException e) { throw missingAllocator( propertyName, className, e ); }
commit:ce40a31
/////////////////////////////////////////////////////////////////////////
1:                 updateCurrentValueOnDisk( currentValue, null );
1:                 if ( updateCurrentValueOnDisk( currentValue, lastAllocatedValue ) )
commit:a0dbbd7
/////////////////////////////////////////////////////////////////////////
1: import java.security.AccessController;
1: import java.security.PrivilegedAction;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.context.Context;
/////////////////////////////////////////////////////////////////////////
1:             ContextService csf = getContextService();
/////////////////////////////////////////////////////////////////////////
1: 					getContextOrNull(LanguageConnectionContext.CONTEXT_ID);
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Privileged lookup of the ContextService. Must be private so that user code
1:      * can't call this entry point.
1:      */
1:     private  static  ContextService    getContextService()
1:     {
1:         if ( System.getSecurityManager() == null )
1:         {
1:             return ContextService.getFactory();
1:         }
1:         else
1:         {
1:             return AccessController.doPrivileged
1:                 (
1:                  new PrivilegedAction<ContextService>()
1:                  {
1:                      public ContextService run()
1:                      {
1:                          return ContextService.getFactory();
1:                      }
1:                  }
1:                  );
1:         }
1:     }
1: 
1:     
1:     /**
1:      * Privileged lookup of a Context. Must be private so that user code
1:      * can't call this entry point.
1:      */
1:     private  static  Context    getContextOrNull( final String contextID )
1:     {
1:         if ( System.getSecurityManager() == null )
1:         {
1:             return ContextService.getContextOrNull( contextID );
1:         }
1:         else
1:         {
1:             return AccessController.doPrivileged
1:                 (
1:                  new PrivilegedAction<Context>()
1:                  {
1:                      public Context run()
1:                      {
1:                          return ContextService.getContextOrNull( contextID );
1:                      }
1:                  }
1:                  );
1:         }
1:     }
1: 
commit:8612b0b
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
/////////////////////////////////////////////////////////////////////////
1:     private   StandardException   tooMuchContentionException()
1:         // If the sequence lives in the SYS schema, then it is used to back an identity column.
1:         if ( SchemaDescriptor.STD_SYSTEM_SCHEMA_NAME.equals( _sequenceGenerator.getSchemaName() ) )
1:         {
1:             return StandardException.newException( SQLState.LOCK_TIMEOUT );
1:         }
1:         else
1:         {
1:             return StandardException.newException
1:                 ( SQLState.LANG_TOO_MUCH_CONTENTION_ON_SEQUENCE, _sequenceGenerator.getName() );
1:         }
commit:a180287
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.dictionary.BulkInsertCounter;
/////////////////////////////////////////////////////////////////////////
1:      * Reset the sequence generator to a new start value. This is used by the special
1:      * bulk-insert optimization in InsertResultSet.
1:      * </p>
1:      */
1:     public synchronized void reset( Long newValue )
1:         throws StandardException
1:     {
1:         // first try to reset on disk
1:         updateCurrentValueOnDisk( null, newValue );
1: 
1:         // now reset the sequence generator
1:         _sequenceGenerator = _sequenceGenerator.clone( newValue );
1:     }
1:     
1:     /**
1:      * <p>
1:      * Get the SequenceUpdater used for the bulk-insert optimization in InsertResultSet.
1:      * </p>
1:      *
1:      * @param restart   True if the counter should be re-initialized to its start position.
1:      */
1:     public synchronized BulkInsertUpdater   getBulkInsertUpdater( boolean restart )
1:         throws StandardException
1:     {
1:         return new BulkInsertUpdater( this, restart );
1:     }
1:     
1:     /**
1:      * <p>
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * <p>
1:      * Implementation of SequenceUpdater for use with the bulk-insert optimization
1:      * used by InsertResultSet. This BulkInsertUpdater doesn't really write to disk. It is assumed
1:      * that the BulkInsertUpdater will only be used by the bulk-insert code, where the
1:      * user has exclusive write-access on the table whose identity column is backed by
1:      * the original SequenceUpdater. At the end of bulk-insert, the current value of the
1:      * BulkInsertUpdater is written to disk by other code.
1:      * </p>
1:      */
1:     public static final class BulkInsertUpdater extends SequenceUpdater implements BulkInsertCounter
1:     {
1:         public BulkInsertUpdater() { super(); }
1:         public BulkInsertUpdater( SequenceUpdater originalUpdater, boolean restart )
1:         {
1:             _sequenceGenerator = originalUpdater._sequenceGenerator.clone( restart );
1:         }
1:     
1:         //
1:         // SequenceUpdater BEHAVIOR
1:         //
1: 
1:         protected SequenceGenerator createSequenceGenerator( TransactionController readOnlyTC )
1:             throws StandardException
1:         {
1:             return _sequenceGenerator;
1:         }
1: 
1:         protected boolean updateCurrentValueOnDisk( TransactionController tc, Long oldValue, Long newValue, boolean wait )
1:             throws StandardException
1:         {
1:             // always succeeds
1:             return true;
1:         }
1:     }
1: 
commit:9819cf8
/////////////////////////////////////////////////////////////////////////
1:             boolean escalateToParentTransaction = false;
/////////////////////////////////////////////////////////////////////////
1:                 if ( !se.isLockTimeout() )
1:                 {
1:                     if ( se.isSelfDeadlock() )
1:                     {
1:                         // We're blocked by a lock held by our parent transaction.
1:                         // Escalate into the parent transaction now. See DERBY-6554.
1:                         escalateToParentTransaction = true;
1:                     }
1:                     else
1:                     {
1:                         Monitor.logThrowable( se );
1:                         throw se;
1:                     }
1:                 }
/////////////////////////////////////////////////////////////////////////
1:                 if ( escalateToParentTransaction )
1:                 {
1:                     retval = updateCurrentValueOnDisk( executionTransaction, oldValue, newValue, false );
1:                 }
1: 
commit:7953b49
/////////////////////////////////////////////////////////////////////////
1: import java.util.HashMap;
1: 
/////////////////////////////////////////////////////////////////////////
1:     //
1:     // The following state needs to be reset whenever this Cachable is re-used.
1:     //
1:     
1:     /** This is the key used to lookup this generator in the cache. */
1:     /** This is the object which allocates ranges of sequence values */
/////////////////////////////////////////////////////////////////////////
1:         // The call to updateCurrentValueOnDisk can fail if someone is holding a lock
1:         // on the SYS.SYSSEQUENCES row. This can happen if the user disregards our
1:         // advice and scans that catalog. This can also happen if the transaction which
1:         // creates the sequences is open for a long time and some later sequence creation
1:         // causes us to evict the old, uncommitted sequence generator from the cache.
1:         boolean gapClosed = false;
1:         try {
1:             if ( _sequenceGenerator == null ) { gapClosed = true; }
1:             else
1:             {
1:                 gapClosed = updateCurrentValueOnDisk( null, peekAtCurrentValue() );
1:             }
1:         }
1:         catch (StandardException se)
1:         {
1:             // The too much contention exception is redundant because the problem is logged
1:             // by the message below
1:             if ( !SQLState.LANG_TOO_MUCH_CONTENTION_ON_SEQUENCE.equals( se.getMessageId() ) )
1:             {
1:                 throw se;
1:             }
1:         }
1:         finally
1:         {
/////////////////////////////////////////////////////////////////////////
1:             _uuidString = null;
1:             _sequenceGenerator = null;
1:         }
/////////////////////////////////////////////////////////////////////////
1:             boolean retval = false;
1:             
1:                 retval = updateCurrentValueOnDisk( nestedTransaction, oldValue, newValue, false );
/////////////////////////////////////////////////////////////////////////
1: 
1:                 return retval;
commit:8e352d6
/////////////////////////////////////////////////////////////////////////
1:  * <li>When updating the on-disk value, we use a subtransaction of the user's
1:  * execution transaction. If the
1:  * special transaction cannot do its work immediately, without waiting for a lock, then
1:  * a TOO MUCH CONTENTION error is raised. It is believed that this can only happen
1:  * if someone holds locks on SYSSEQUENCES, either via sequence DDL or a scan
1:  * of the catalog. The TOO MUCH CONTENTION error tells
1:  * the user to not scan SYSSEQUENCES directly, but to instead use the
1:  * SYSCS_UTIL.SYSCS_PEEK_AT_SEQUENCE() if the user needs the current value of the
1:  * sequence generator.</li>
/////////////////////////////////////////////////////////////////////////
1:  * <li>Otherwise, we must allocate a new range by updating the catalog row. We should not
1:  * be in contention with another connection because the update method is synchronized.</li>
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:      * Update the sequence value on disk. This method does its work in a subtransaction of
1:      * the user's execution transaction.
/////////////////////////////////////////////////////////////////////////
1:      * Only one thread at a time is allowed through here. We do not want a race between the
1:      * two calls to the sequence generator: getCurrentValueAndAdvance() and allocateNewRange().
1:     public synchronized void getCurrentValueAndAdvance
1:         // We may have to try to get a value from the Sequence Generator twice.
1:         // The first attempt may fail because we need to pre-allocate a new chunk
1:         // of values.
1:         for ( int i = 0; i < 2; i++ )
1:             //
1:             // We try to get a sequence number. The SequenceGenerator method is synchronized
1:             // so only one writer should be in there at a time. Lock contention is possible if
1:             // someone has selected from SYSSEQUENCES contrary to our advice. In that case,
1:             // we raise a TOO MUCH CONTENTION exception.
1:             //
/////////////////////////////////////////////////////////////////////////
1:             
1:         }
1:         //
1:         // If we get here, then we failed to allocate a new sequence number range.
1:         //
1:         throw tooMuchContentionException();
/////////////////////////////////////////////////////////////////////////
1:     public Long peekAtCurrentValue() throws StandardException
/////////////////////////////////////////////////////////////////////////
1:      * Update the value on disk. Does its work in a subtransaction of the user's
1:      * execution transaction. If that fails, raises a TOO MUCH CONTENTION exception.
1:     public synchronized boolean updateCurrentValueOnDisk( Long oldValue, Long newValue ) throws StandardException
/////////////////////////////////////////////////////////////////////////
0:         TransactionController nestedTransaction = executionTransaction.startNestedUserTransaction( false );
1:             try
1:             {
/////////////////////////////////////////////////////////////////////////
1:         // We might be self-deadlocking if the user has selected from SYSSEQUENCES
1:         // contrary to our advice.
1: 
1:         throw tooMuchContentionException();
/////////////////////////////////////////////////////////////////////////
commit:bb4cfe9
/////////////////////////////////////////////////////////////////////////
1:     // INNER CLASSES
commit:68c72e7
/////////////////////////////////////////////////////////////////////////
1:     // ABSTRACT OR OVERRIDABLE BEHAVIOR TO BE IMPLEMENTED BY CHILDREN
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * <p>
1:      * Create an exception to state that there is too much contention on the generator.
1:      * For backward compatibility reasons, different messages are needed by sequences
1:      * and identities. See DERBY-5426.
1:      * </p>
1:      */
0:     protected   StandardException   tooMuchContentionException()
1:     {
0:         return StandardException.newException
0:             ( SQLState.LANG_TOO_MUCH_CONTENTION_ON_SEQUENCE, _sequenceGenerator.getName() );
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
1: 
0:         // We try to get a sequence number. We try until we've exceeded the lock timeout
0:         // in case we find ourselves in a race with another session which is draining numbers from
/////////////////////////////////////////////////////////////////////////
1:                 //
0:                 // If we get here, then we exhausted our retry attempts. This might be a sign
0:                 // that we need to increase the number of sequence numbers which we
0:                 // allocate. There's an opportunity for Derby to tune itself here.
1:                 //
0:                 throw tooMuchContentionException();
/////////////////////////////////////////////////////////////////////////
1: 
1:         /**
0:          * Wrap the "too much contention" exception in a "lock timeout" exception in
0:          * order to preserve the old error behavior of identity columns. See DERBY-5426.
1:          */
0:         protected   StandardException   tooMuchContentionException()
1:         {
0:             StandardException   tooMuchContention = super.tooMuchContentionException();
1: 
0:             return StandardException.newException( SQLState.LOCK_TIMEOUT, tooMuchContention );
1:         }
commit:132af01
/////////////////////////////////////////////////////////////////////////
1:                 // if we failed to get a generator, we have no identity. see DERBY-5389.
1:                 if ( _sequenceGenerator == null ) { _uuidString = null; }
1:             
commit:c8986df
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.i18n.MessageService;
1: import org.apache.derby.iapi.services.monitor.Monitor;
1: import org.apache.derby.iapi.store.access.AccessFactory;
/////////////////////////////////////////////////////////////////////////
1:         // We flush the current value to disk on database shutdown also.
0:             boolean gapClosed = updateCurrentValueOnDisk( null, peekAtCurrentValue() );
1: 
1:             // log an error message if we failed to flush the preallocated values.
1:             if ( !gapClosed )
1:             {
1:                 String  errorMessage = MessageService.getTextMessage
1:                     (
1:                      SQLState.LANG_CANT_FLUSH_PREALLOCATOR,
1:                      _sequenceGenerator.getSchemaName(),
1:                      _sequenceGenerator.getName()
1:                      );
1: 
1:                 Monitor.getStream().println( errorMessage );
1:             }
/////////////////////////////////////////////////////////////////////////
1:         LanguageConnectionContext   lcc = getLCC();
1: 
1:         //
1:         // Not having an LCC should mean that we are in the middle of engine
1:         // shutdown. We get here only to flush the current value to disk so that
1:         // we don't leak unused sequence numbers. See DERBY-5398.
1:         //
1:         if ( lcc == null )
1:         {
1:             if (SanityManager.DEBUG)
1:             {
1: 				SanityManager.ASSERT( oldValue == null, "We should be flushing unused sequence values here." );
1: 			}
1:             
0:             ContextService csf = ContextService.getFactory();
1:             ContextManager cm = csf.getCurrentContextManager();
1:             AccessFactory af = _dd.af;
1:             TransactionController   dummyTransaction = af.getTransaction( cm );
1: 
1:             boolean retval = updateCurrentValueOnDisk( dummyTransaction, oldValue, newValue, false );
1:             dummyTransaction.commit();
1:             dummyTransaction.destroy();
1: 
1:             return retval;
1: 		}
1: 
1:         TransactionController executionTransaction = lcc.getTransactionExecute();
commit:365a750
/////////////////////////////////////////////////////////////////////////
1:             // If the property value was a number rather than a class name, then
1:             // use that as the default size for preallocated ranges.
1:             if ( isNumber( className ) )
1:             {
1:                 return new SequenceRange( Integer.parseInt( className ) );
1:             }
1:             
1:         catch (NumberFormatException e) { throw missingAllocator( propertyName, className, e ); }
1:     private boolean isNumber( String text )
1:     {
1:         int length = text.length();
1: 
1:         for ( int i = 0; i < length; i++ )
1:         {
1:             if ( !Character.isDigit( text.charAt( i ) ) ) { return false; }
1:         }
1: 
1:         return true;
1:     }
commit:311ee54
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.catalog.SequencePreallocator;
1: import org.apache.derby.iapi.reference.Property;
1: import org.apache.derby.iapi.services.property.PropertyUtil;
/////////////////////////////////////////////////////////////////////////
1:     /** Make a new range allocator (called when the generator is instantiated) */
1:     protected SequencePreallocator  makePreallocator( TransactionController tc )
1:         throws StandardException
1:     {
1:         String  propertyName = Property.LANG_SEQUENCE_PREALLOCATOR;
1:         String  className = PropertyUtil.getServiceProperty( tc, propertyName );
1: 
1:         if ( className == null ) { return new SequenceRange(); }
1: 
1:         try {
0:             return (SequencePreallocator) Class.forName( className ).newInstance();
1:         }
1:         catch (ClassNotFoundException e) { throw missingAllocator( propertyName, className, e ); }
1:         catch (ClassCastException e) { throw missingAllocator( propertyName, className, e ); }
1:         catch (InstantiationException e) { throw missingAllocator( propertyName, className, e ); }
1:         catch (IllegalAccessException e) { throw missingAllocator( propertyName, className, e ); }
1:     }
1:     private StandardException   missingAllocator( String propertyName, String className, Exception e )
1:     {
1:         return StandardException.newException( SQLState.LANG_UNKNOWN_SEQUENCE_PREALLOCATOR, e, propertyName, className );
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
1:                  isd.getSchemaDescriptor().getSchemaName(),
1:                  isd.getSequenceName(),
1:                  makePreallocator( readOnlyTC )
/////////////////////////////////////////////////////////////////////////
0:                  isd.getSchemaDescriptor().getSchemaName(),
0:                  isd.getSequenceName(),
0:                  makePreallocator( readOnlyTC )
commit:729be57
/////////////////////////////////////////////////////////////////////////
0:     // NESTED CLASSES
0:      * SYSCOLUMNS.
1:      * </p>
1:      */
0:     public static final class SyscolumnsUpdater extends SequenceUpdater
1:     {
1:         private RowLocation _sequenceRowLocation;
1: 
0:         public SyscolumnsUpdater() { super(); }
0:         public SyscolumnsUpdater( DataDictionaryImpl dd ) { super( dd ); }
1:     
1:         //
1:         // SequenceUpdater BEHAVIOR
1:         //
1: 
1:         protected SequenceGenerator createSequenceGenerator( TransactionController readOnlyTC )
1:             throws StandardException
1:         {
1:             RowLocation[] rowLocation = new RowLocation[ 1 ];
1:             SequenceDescriptor[] sequenceDescriptor = new SequenceDescriptor[ 1 ];
1:             
0:             _dd.computeIdentityRowLocation( readOnlyTC, _uuidString, rowLocation, sequenceDescriptor );
1:             
1:             _sequenceRowLocation = rowLocation[ 0 ];
1:             
1:             SequenceDescriptor isd = sequenceDescriptor[ 0 ];
1:             
1:             return new SequenceGenerator
1:                 (
1:                  isd.getCurrentValue(),
1:                  isd.canCycle(),
1:                  isd.getIncrement(),
1:                  isd.getMaximumValue(),
1:                  isd.getMinimumValue(),
1:                  isd.getStartValue(),
0:                  isd.getSequenceName()
1:                  );
1:         }
1: 
1:         protected boolean updateCurrentValueOnDisk( TransactionController tc, Long oldValue, Long newValue, boolean wait ) throws StandardException
1:         {
0:             return _dd.updateCurrentIdentityValue( tc, _sequenceRowLocation, wait, oldValue, newValue );
1:         }
1:     }
1: 
1:     /**
1:      * <p>
1:      * Specific implementation of SequenceUpdater for the sequences managed by
commit:39c6ffc
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     // This is the object which allocates ranges of sequence values
0:     // This is the lock timeout in milliseconds; a negative number means no timeout
0:     private long _lockTimeoutInMillis;
1: 
/////////////////////////////////////////////////////////////////////////
1:     public SequenceUpdater()
1:     {
0:         _lockTimeoutInMillis = getLockTimeout();
1:     }
1:         this();
1:         
/////////////////////////////////////////////////////////////////////////
0:         Long startTime = null;
1:         
0:         while ( true )
/////////////////////////////////////////////////////////////////////////
0:             if ( startTime == null )
1:             {
0:                 // get the system time only if we have to
0:                 startTime = new Long( System.currentTimeMillis() );
0:                 continue;
1:             }
1:             
0:             if (
0:                 (_lockTimeoutInMillis >= 0L) &&
0:                 ( (System.currentTimeMillis() - startTime.longValue()) > _lockTimeoutInMillis )
0:                 )
1:             {
1:                 break;
1:             }
/////////////////////////////////////////////////////////////////////////
1:         
/////////////////////////////////////////////////////////////////////////
1:         
1:         
/////////////////////////////////////////////////////////////////////////
0:     /** Get the time we wait for a lock, in milliseconds--overridden by unit tests */
0:     protected int getLockTimeout()
1:     {
0:         return getLCC().getTransactionExecute().getAccessManager().getLockFactory().getWaitTimeout();
1:     }
1:     
commit:139ca85
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derby.impl.sql.catalog.SequenceUpdater
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: package org.apache.derby.impl.sql.catalog;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.services.cache.Cacheable;
1: import org.apache.derby.iapi.services.cache.CacheManager;
1: import org.apache.derby.iapi.services.context.ContextManager;
1: import org.apache.derby.iapi.services.context.ContextService;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1: import org.apache.derby.iapi.sql.dictionary.SequenceDescriptor;
1: import org.apache.derby.iapi.store.access.TransactionController;
1: import org.apache.derby.iapi.types.NumberDataValue;
1: import org.apache.derby.iapi.types.RowLocation;
1: 
1: /**
1:  * <p>
1:  * An object cached in the data dictionary which manages new values
1:  * for sequences. Note that this class must be public and
1:  * have a 0-arg constructor in order to satisfy the Cacheable contract.
1:  * </p>
1:  *
1:  * <p>
1:  * This is the abstract superclass of specific implementations for specific
1:  * sequences. For instance, one subclass handles the ANSI/ISO sequences
1:  * stored in SYSSEQUENCES. Another subclass could handle the sequences
1:  * stored in Derby's identity columns.
1:  * </p>
1:  *
1:  * <p>
1:  * This class does a couple tricky things:
1:  * </p>
1:  *
1:  * <ul>
1:  * <li>It pre-allocates a range of values from a sequence so that we don't have to change
1:  *  the on-disk value every time we get the next value for a sequence.</li>
0:  * <li>When updating the on-disk value, we first try to do the writing in
0:  *  a nested subtransaction. This is so that we can immediately release the write-lock afterwards.
0:  *  If that fails, we then try to do the writing in the user's execution transaction.</li>
1:  * </ul>
1:  *
1:  * <p>
1:  * Here is the algorithm pursued when the caller asks for the next number in a sequence:
1:  * </p>
1:  *
1:  *
1:  * <ul>
1:  * <li>We try to get the next number from a cache of pre-allocated numbers. The endpoint
1:  * (last number in the pre-allocated range) was previously recorded in the catalog row which
1:  * describes this sequence. If we are successful in getting the next number, we
1:  * return it and all is well.</li>
0:  * <li>Otherwise, we must allocate a new range by updating the catalog row. At this
0:  * point we may find ourselves racing another session, which also needs the next number
0:  * in the sequence.</li>
0:  * <li>When we try to update the catalog row, we check to see whether the current value
0:  * there is what we expect it to be. If it is, then all is well: we update the catalog row
0:  * then return to the first step to try to get the next number from the new cache of
0:  * pre-allocated numbers.</li>
0:  * <li>If, however, the value in the catalog row is not what we expect, then another
0:  * session has won the race to update the catalog. We accept this fact gracefully and
0:  * do not touch the catalog. Instead, we return to the first step and try to get the
0:  * next number from the new cache of numbers which the other session has just
0:  * pre-allocated.</li>
0:  * <li>We only allow ourselves to retry this loop a small number of times. If we still
0:  * can't get the next number in the sequence, we raise an exception complaining that
0:  * there is too much contention on the generator.</li>
1:  * </ul>
1:  *
1:  * <p>
0:  * If applications start seeing exceptions complaining that there is too much contention
0:  * on a sequence generator, then we should improve this algorithm. Here are some options
0:  * based on the idea that contention should go down if we increase the number of
0:  * pre-allocated numbers:
1:  * </p>
1:  *
1:  * <ul>
0:  * <li>We can let the user change the size of the pre-allocated range.</li>
0:  * <li>Derby can increase the size of the pre-allocated range when Derby detects
0:  * too much contention.</li>
1:  * </ul>
1:  *
1:  */
1: public abstract class SequenceUpdater implements Cacheable
1: {
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // CONSTANTS
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     //
0:     // This is the number of times we attempt to get a sequence number in case we
0:     // find ourselves in a race against another session which is draining numbers
0:     // from the same sequence generator.
1:     //
0:     private static final int RETRY_COUNT = 3;
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // CONSTANT STATE
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     // DataDictionary where this generator is cached.
1:     protected DataDictionaryImpl _dd;
1: 
0:     // This is the key used to lookup this generator in the cache.
1:     protected String _uuidString;
1: 
0:     // This is the object which allocates ranges of sequence values */
1:     protected SequenceGenerator _sequenceGenerator;
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // CONSTRUCTOR
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     /** No-arg constructor to satisfy the Cacheable contract */
0:     public SequenceUpdater() {}
1: 
1:     /** Normal constructor */
1:     public SequenceUpdater( DataDictionaryImpl dd )
1:     {
1:         _dd = dd;
1:     }
1:     
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
0:     // ABSTRACT BEHAVIOR TO BE IMPLEMENTED BY CHILDREN
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * <p>
1:      * Initialize the sequence generator. Work is done inside a read-only subtransaction of
1:      * the session's execution transaction.
1:      * </p>
1:      */
1:      abstract protected SequenceGenerator createSequenceGenerator( TransactionController readOnlyTC )
1:          throws StandardException;
1: 
1:     /**
1:      * <p>
0:      * Update the sequence value on disk. This method is first called with a read/write subtransaction
0:      * of the session's execution transaction. If work can't be done there immediately, this method
0:      * is called with the session's execution transaction.
1:      * </p>
1:      *
1:      * @param tc The transaction to use
1:      * @param oldValue Expected value on disk for this sequence
1:      * @param newValue The value to poke into the system table backing this sequence
1:      * @param wait Whether to wait for a lock
1:      *
1: 	 * 
1: 	 * @return Returns true if the value was successfully updated, false if we lost a race with another session.
1:      *
1:      * @throws StandardException May throw an exception if a lock can't be obtained.
1:      */
1:     abstract protected boolean updateCurrentValueOnDisk( TransactionController tc, Long oldValue, Long newValue, boolean wait ) throws StandardException;
1:     
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // Cacheable BEHAVIOR
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1: 	public void clean(boolean forRemove) throws StandardException
1: 	{
1:         //
1:         // Flush current value to disk. This prevents us from leaking values when DDL
1:         // is performed. The metadata caches are invalidated and cleared when DDL is performed.
1:         //
0:         if ( _sequenceGenerator != null )
1:         {
0:             updateCurrentValueOnDisk( null, peekAtCurrentValue() );
1:         }
1: 
0:         _uuidString = null;
0:         _sequenceGenerator = null;
1: 	}
1:     
1: 	public boolean isDirty() { return false; }
1:     public Object getIdentity() { return _uuidString; }
1: 
1: 	public void clearIdentity()
1:     {
1:         try
1:         {
1:             clean( false );
1:         } catch (StandardException se)
1:         {
0:             getLCC().getContextManager().cleanupOnError( se );
1:         }
1:     }
1: 
1: 	public Cacheable createIdentity( Object key, Object createParameter ) throws StandardException
1: 	{
1:         Cacheable cacheable = this;
1: 
1:         //
1:         // The createParameter arg is unused.
1:         //
1:         return cacheable.setIdentity( key );
1: 	}
1: 
1: 	/**
1: 	 * @see Cacheable#setIdentity
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public Cacheable setIdentity(Object key) throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			if (!(key instanceof String))
1: 			{
1: 				SanityManager.THROWASSERT( "Key for a SequenceUpdater is a " + key.getClass().getName() );
1: 			}
1: 
1:             if ( (_uuidString != null) || (_sequenceGenerator != null) )
1: 			{
1: 				SanityManager.THROWASSERT( "Identity being changed on a live cacheable. Old uuidString = " + _uuidString );
1: 			}
1: 		}
1: 
1: 		_uuidString = (String) key;
1: 
1:         if ( _sequenceGenerator == null )
1:         {
1:             TransactionController executionTC = getLCC().getTransactionExecute();
1:             
1:             //
1:             // We lookup information in a read-only subtransaction in order to minimize
1:             // contention. Since this is a read-only subtransaction, there should be
1:             // no conflict with the parent transaction.
1:             //
0:             TransactionController subTransaction = executionTC.startNestedUserTransaction( true );
1:             try {
1:                 _sequenceGenerator = createSequenceGenerator( subTransaction );
1:             }
1:             finally
1:             {
1:                 subTransaction.commit();
1:                 subTransaction.destroy();
1:             }
1:         }
1: 
1: 		if ( _sequenceGenerator != null ) { return this; }
1: 		else { return null; }
1: 	}
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // PUBLIC BEHAVIOR
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * <p>
1:      * Get the next sequence number managed by this generator and advance the number. Could raise an
1:      * exception if the legal range is exhausted and wrap-around is not allowed.
0:      * Only one thread at a time is allowed through here. That synchronization is performed by
0:      * the sequence generator itself.
1:      * </p>
1:      *
1:      * @param returnValue This value is stuffed with the new sequence number.
1:      */
0:     public void getCurrentValueAndAdvance
1:         ( NumberDataValue returnValue ) throws StandardException
1:     {
1:         //
0:         // We try to get a sequence number. We try a couple times in case we find
0:         // ourselves in a race with another session which is draining numbers from
0:         // the same sequence generator.
1:         //
0:         for ( int i = 0; i < RETRY_COUNT; i++ )
1:         {
1:             long[] cvaa = _sequenceGenerator.getCurrentValueAndAdvance();
1:             
1:             int status = (int) cvaa[ SequenceGenerator.CVAA_STATUS ];
1:             long currentValue = cvaa[ SequenceGenerator.CVAA_CURRENT_VALUE ];
1:             long lastAllocatedValue = cvaa[ SequenceGenerator.CVAA_LAST_ALLOCATED_VALUE ];
1:             long numberOfValuesAllocated = cvaa[ SequenceGenerator.CVAA_NUMBER_OF_VALUES_ALLOCATED ];
1:             
1:             switch ( status )
1:             {
1:             case SequenceGenerator.RET_OK:
1:                 returnValue.setValue( currentValue );
1:                 return;
1:                 
1:             case SequenceGenerator.RET_MARK_EXHAUSTED:
0:                 updateCurrentValueOnDisk( new Long( currentValue ), null );
1:                 returnValue.setValue( currentValue );
1:                 return;
1:                 
1:             case SequenceGenerator.RET_ALLOCATE_NEW_VALUES:
1:                 
0:                 if ( updateCurrentValueOnDisk( new Long( currentValue ), new Long( lastAllocatedValue ) ) )
1:                 {
1:                     _sequenceGenerator.allocateNewRange( currentValue, numberOfValuesAllocated );
1:                 }
0:                 break;
1:                 
1:             default:
1:                 throw unimplementedFeature();
1:             }
1: 
1:             //
0:             // If we get here, then we failed to get a sequence number. Along the way,
0:             // we or another session may have allocated more sequence numbers on disk. We go back
0:             // in to try to grab one of those numbers.
1:             //
1: 
1:             
0:         } // end of retry loop
1: 
1:         //
0:         // If we get here, then we exhausted our retry attempts. This might be a sign
0:         // that we need to increase the number of sequence numbers which we
0:         // allocate. There's an opportunity for Derby to tune itself here.
1:         //
0:         throw StandardException.newException
0:             ( SQLState.LANG_TOO_MUCH_CONTENTION_ON_SEQUENCE, _sequenceGenerator.getName() );
1:     }
1: 
1:     /**
1:      * <p>
1:      * Get the current value of the sequence generator without advancing it.
1:      * May return null if the generator is exhausted.
1:      * </p>
1:      */
0:     private Long peekAtCurrentValue() throws StandardException
1:     {
1:         return _sequenceGenerator.peekAtCurrentValue();
1:     }
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // DISK WRITING MINIONS
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * <p>
0:      * Update the value on disk. First tries to update the value in a
0:      * subtransaction. If that fails, falls back on the execution transaction.
0:      * This is a callback method invoked by the sequence generator.
1:      * </p>
1: 	 * 
1: 	 * @return Returns true if the value was successfully updated, false if we lost a race with another session.
1:      *
1:      */
0:     public boolean updateCurrentValueOnDisk( Long oldValue, Long newValue ) throws StandardException
1:     {
0:         TransactionController executionTransaction = getLCC().getTransactionExecute();
0:         TransactionController nestedTransaction = null;
1: 
0:         // Try to get a nested transaction.
1:         try {
0:             nestedTransaction = executionTransaction.startNestedUserTransaction( false );
0:         } catch (StandardException se) {}
1: 
0:         // First try to do the work in the nested transaction. Fail if we can't
0:         // get a lock immediately.
1:         if ( nestedTransaction != null )
1:         {
1:             try {
0:                 return updateCurrentValueOnDisk( nestedTransaction, oldValue, newValue, false );
1:             }
1:             catch (StandardException se)
1:             {
0:                 if ( !se.getMessageId().equals( SQLState.LOCK_TIMEOUT ) ) { throw se; }
1:             }
1:             finally
1:             {
1:                 nestedTransaction.commit();
1:                 nestedTransaction.destroy();
1:             }
1:         }
1: 
1:         // If we get here, we failed to do the work in the nested transaction.
0:         // Fall back on the execution transaction
0:         return updateCurrentValueOnDisk( executionTransaction, oldValue, newValue, true );
1:     }
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // UTILITY MINIONS
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1: 	private static LanguageConnectionContext getLCC()
1:     {
1: 		return (LanguageConnectionContext) 
0: 					ContextService.getContextOrNull(LanguageConnectionContext.CONTEXT_ID);
1: 	}
1: 
1:     /** Report an unimplemented feature */
1:     private StandardException unimplementedFeature()
1:     {
1:         return StandardException.newException( SQLState.BTREE_UNIMPLEMENTED_FEATURE );
1:     }
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
0:     // INNER CLASSES
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * <p>
0:      * Specific implementation of SequenceUpdater for the sequences managed by
1:      * SYSSEQUENCES.
1:      * </p>
1:      */
1:     public static final class SyssequenceUpdater extends SequenceUpdater
1:     {
0:         private RowLocation _sequenceRowLocation;
1: 
1:         public SyssequenceUpdater() { super(); }
1:         public SyssequenceUpdater( DataDictionaryImpl dd ) { super( dd ); }
1:     
1:         //
0:         // SequenceUpdater BEHAVIOR
1:         //
1: 
0:         protected SequenceGenerator createSequenceGenerator( TransactionController readOnlyTC )
0:             throws StandardException
1:         {
0:             RowLocation[] rowLocation = new RowLocation[ 1 ];
0:             SequenceDescriptor[] sequenceDescriptor = new SequenceDescriptor[ 1 ];
1:             
1:             _dd.computeSequenceRowLocation( readOnlyTC, _uuidString, rowLocation, sequenceDescriptor );
1:             
0:             _sequenceRowLocation = rowLocation[ 0 ];
1:             
0:             SequenceDescriptor isd = sequenceDescriptor[ 0 ];
1:             
0:             return new SequenceGenerator
0:                 (
0:                  isd.getCurrentValue(),
0:                  isd.canCycle(),
0:                  isd.getIncrement(),
0:                  isd.getMaximumValue(),
0:                  isd.getMinimumValue(),
0:                  isd.getStartValue(),
0:                  isd.getSequenceName()
0:                  );
1:         }
1: 
0:         protected boolean updateCurrentValueOnDisk( TransactionController tc, Long oldValue, Long newValue, boolean wait ) throws StandardException
1:         {
1:             return _dd.updateCurrentSequenceValue( tc, _sequenceRowLocation, wait, oldValue, newValue );
1:         }
1:     }
1: 
1: }
1: 
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:59f29e4
/////////////////////////////////////////////////////////////////////////
0: 
1:             Class<?> klass = Class.forName(className);
1:             if (!SequencePreallocator.class.isAssignableFrom(klass)) {
1:                 throw StandardException.newException(
1:                     SQLState.LANG_NOT_A_SEQUENCE_PREALLOCATOR, propertyName);
0:             }
0: 
0:             return (SequencePreallocator) klass.newInstance();
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:ceaf7df
/////////////////////////////////////////////////////////////////////////
1:             TransactionController subTransaction = 
1:                 executionTC.startNestedUserTransaction( true, true );
0: 
/////////////////////////////////////////////////////////////////////////
1:         TransactionController nestedTransaction = 
1:             executionTransaction.startNestedUserTransaction( false, true );
commit:5705f5b
/////////////////////////////////////////////////////////////////////////
1:                 // DERBY-5494, if this commit does not flush log then an
1:                 // unorderly shutdown could lose the update.  Do not use
1:                 // commitNoSync(), and store needs to flush user nested update
1:                 // transaction commits by default.
commit:c9ef166
/////////////////////////////////////////////////////////////////////////
0:                 if ( !se.isLockTimeout() ) { throw se; }
author:Lily Wei
-------------------------------------------------------------------------------
commit:9da08da
/////////////////////////////////////////////////////////////////////////
1:             if (lcc != null)
0:             {
1:                 Database db = lcc.getDatabase();
1:                 boolean isactive = (db != null ? db.isActive() : false);
1:                 lcc.getContextManager().cleanupOnError(se, isactive);
0:             }
commit:4c5c16b
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.db.Database;
/////////////////////////////////////////////////////////////////////////
1:             //Doing check for lcc and db to be certain
1:             LanguageConnectionContext lcc = getLCC();
0:             Database db = (lcc != null ? lcc.getDatabase() : null);
0:             boolean isactive = (db != null ? db.isActive() : false);
0:             lcc.getContextManager().cleanupOnError(se, isactive);
============================================================================