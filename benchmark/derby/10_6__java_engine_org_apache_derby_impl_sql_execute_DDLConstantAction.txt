1:eac0369: /*
3:2d2e717: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.execute.DDLConstantAction
1:c9ef166: 
1:f6123ee:    Licensed to the Apache Software Foundation (ASF) under one or more
1:f6123ee:    contributor license agreements.  See the NOTICE file distributed with
1:f6123ee:    this work for additional information regarding copyright ownership.
1:f6123ee:    The ASF licenses this file to you under the Apache License, Version 2.0
1:f6123ee:    (the "License"); you may not use this file except in compliance with
1:f6123ee:    the License.  You may obtain a copy of the License at
1:c9ef166: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:2d2e717: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:2d2e717: 
5:eac0369:  */
1:2d2e717: 
1:eac0369: package org.apache.derby.impl.sql.execute;
1:2d2e717: 
1:e126f58: import java.util.HashMap;
1:e126f58: import java.util.HashSet;
1:2d2e717: import java.util.List;
1:2d2e717: 
1:e126f58: import org.apache.derby.catalog.AliasInfo;
1:3c09be7: import org.apache.derby.catalog.DependableFinder;
1:1e2aae0: import org.apache.derby.catalog.UUID;
1:2209325: import org.apache.derby.catalog.TypeDescriptor;
1:aad6057: import org.apache.derby.catalog.types.AggregateAliasInfo;
1:2209325: import org.apache.derby.catalog.types.RoutineAliasInfo;
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:1e2aae0: import org.apache.derby.iapi.reference.SQLState;
1:3c09be7: import org.apache.derby.iapi.services.context.ContextManager;
1:1e2aae0: import org.apache.derby.iapi.sql.Activation;
1:2d2e717: import org.apache.derby.iapi.sql.conn.Authorizer;
1:eac0369: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1:1e2aae0: import org.apache.derby.iapi.sql.depend.DependencyManager;
1:1e2aae0: import org.apache.derby.iapi.sql.depend.Dependent;
1:3c09be7: import org.apache.derby.iapi.sql.depend.Provider;
1:8875d69: import org.apache.derby.iapi.sql.depend.ProviderInfo;
1:e126f58: import org.apache.derby.iapi.sql.dictionary.AliasDescriptor;
1:2d2e717: import org.apache.derby.iapi.sql.dictionary.ColPermsDescriptor;
1:3c09be7: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
1:e126f58: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptorList;
1:3c09be7: import org.apache.derby.iapi.sql.dictionary.DefaultDescriptor;
1:e126f58: import org.apache.derby.iapi.sql.dictionary.DependencyDescriptor;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1:3c09be7: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1:2d2e717: import org.apache.derby.iapi.sql.dictionary.PermissionsDescriptor;
1:eb38311: import org.apache.derby.iapi.sql.dictionary.RoleGrantDescriptor;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
1:2d2e717: import org.apache.derby.iapi.sql.dictionary.StatementColumnPermission;
1:2d2e717: import org.apache.derby.iapi.sql.dictionary.StatementPermission;
1:a4cbe6f: import org.apache.derby.iapi.sql.dictionary.StatementGenericPermission;
1:2d2e717: import org.apache.derby.iapi.sql.dictionary.StatementSchemaPermission;
1:eb38311: import org.apache.derby.iapi.sql.dictionary.StatementRolePermission;
1:eb38311: import org.apache.derby.iapi.sql.dictionary.StatementRoutinePermission;
1:2d2e717: import org.apache.derby.iapi.sql.dictionary.StatementTablePermission;
1:eb38311: import org.apache.derby.iapi.sql.dictionary.RoleClosureIterator;
1:eac0369: import org.apache.derby.iapi.sql.execute.ConstantAction;
1:eac0369: import org.apache.derby.iapi.store.access.ConglomerateController;
1:eac0369: import org.apache.derby.iapi.store.access.TransactionController;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:e126f58: import org.apache.derby.iapi.types.DataTypeDescriptor;
1:2d2e717: 
1:2d2e717: /**
1:eac0369:  * Abstract class that has actions that are across
1:eac0369:  * all DDL actions.
5:eac0369:  *
1:eac0369:  */
1:e4fa8cb: abstract class DDLConstantAction implements ConstantAction
3:eac0369: {
4:eac0369: 	/**
1:eac0369: 	 * Get the schema descriptor for the schemaid.
1:eac0369: 	 *
1:eac0369: 	 * @param dd the data dictionary
1:eac0369: 	 * @param schemaId the schema id
1:eac0369: 	 * @param statementType string describing type of statement for error
1:eac0369: 	 *	reporting.  e.g. "ALTER STATEMENT"
1:eac0369: 	 *
1:eac0369: 	 * @return the schema descriptor
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException if schema is system schema
1:eac0369: 	 */
1:eac0369: 	static SchemaDescriptor getAndCheckSchemaDescriptor(
1:eac0369: 						DataDictionary		dd,
1:eac0369: 						UUID				schemaId,
1:eac0369: 						String				statementType)
2:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		SchemaDescriptor sd = dd.getSchemaDescriptor(schemaId, null);
1:eac0369: 		return sd;
9:2d2e717: 	}
1:8875d69: 
1:2209325: 	/**
1:eac0369: 	 * Get the schema descriptor in the creation of an object in
1:eac0369: 	   the passed in schema.
1:2d2e717: 	 *
1:eac0369: 	 * @param dd the data dictionary
1:4d8deb6: 	 * @param activation activation
1:4d8deb6: 	 * @param schemaName name of the schema
1:2d2e717: 	 *
1:eac0369: 	 * @return the schema descriptor
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException if the schema does not exist
1:e126f58: 	 */
1:eac0369: 	static SchemaDescriptor getSchemaDescriptorForCreate(
1:eac0369: 						DataDictionary		dd,
1:eac0369: 						Activation activation,
1:eac0369: 						String schemaName)
1:2d2e717: 		throws StandardException
1:3c09be7: 	{
1:4d8deb6: 		TransactionController tc = activation.
1:4d8deb6: 			getLanguageConnectionContext().getTransactionExecute();
1:8875d69: 
1:eac0369: 		SchemaDescriptor sd = dd.getSchemaDescriptor(schemaName, tc, false);
1:8875d69: 
1:eac0369: 		if (sd == null || sd.getUUID() == null) {
1:ddae94a: 			CreateSchemaConstantAction csca
1:ddae94a: 				= new CreateSchemaConstantAction(schemaName, (String) null);
1:4d8deb6: 
1:9e04f69: 			if (activation.getLanguageConnectionContext().
1:9e04f69: 					isInitialDefaultSchema(schemaName)) {
1:ddae94a: 				// DERBY-48: This operation creates the user's initial
1:ddae94a: 				// default schema and we don't want to hold a lock for
1:ddae94a: 				// SYSSCHEMAS for the duration of the user transaction
1:ddae94a: 				// since connection attempts may block, so we perform
1:ddae94a: 				// the creation in a nested transaction (if possible)
1:ddae94a: 				// so we can commit at once and release locks.
1:ddae94a: 				executeCAPreferSubTrans(csca, tc, activation);
1:9e04f69: 			} else {
1:ddae94a: 				// create the schema in the user transaction
2:9e04f69: 				try {
1:9e04f69: 					csca.executeConstantAction(activation);
2:9e04f69: 				} catch (StandardException se) {
1:9e04f69: 					if (se.getMessageId()
1:9e04f69: 							.equals(SQLState.LANG_OBJECT_ALREADY_EXISTS)) {
1:9e04f69: 						// Ignore "Schema already exists". Another thread has
1:9e04f69: 						// probably created it after we checked for it
1:9e04f69: 					} else {
2:9e04f69: 						throw se;
1:9e04f69: 					}
1:9e04f69: 				}
1:4d8deb6: 			}
1:4d8deb6: 
1:4d8deb6: 
1:eac0369: 			sd = dd.getSchemaDescriptor(schemaName, tc, true);
1:4d8deb6: 		}
1:3c09be7: 
1:eac0369: 		return sd;
1:2d2e717: 	}
1:c9ef166: 
1:c9ef166: 
1:ddae94a: 	private static void executeCAPreferSubTrans
1:ddae94a: 		(CreateSchemaConstantAction csca,
1:ddae94a: 		 TransactionController tc,
1:ddae94a: 		 Activation activation) throws StandardException {
1:ddae94a: 
1:801cf0d:         TransactionController useTc;
1:ddae94a: 		TransactionController nestedTc = null;
1:ddae94a: 
1:ddae94a: 		try {
1:ceaf7df: 			nestedTc = tc.startNestedUserTransaction(false, true);
1:ddae94a: 			useTc = nestedTc;
1:ddae94a: 		} catch (StandardException e) {
1:ddae94a: 			if (SanityManager.DEBUG) {
1:ddae94a: 				SanityManager.THROWASSERT(
1:ddae94a: 					"Unexpected: not able to start nested transaction " +
1:ddae94a: 					"to auto-create schema", e);
1:ddae94a: 			}
1:ddae94a: 			useTc = tc;
1:ddae94a: 		}
1:ddae94a: 
1:ddae94a: 		// Try max twice: if nested transaction times out, try
1:ddae94a: 		// again in the outer transaction because it may be a
1:ddae94a: 		// self-lock, that is, the outer transaction may hold some
1:ddae94a: 		// lock(s) that make the nested transaction attempt to set
1:ddae94a: 		// a write lock time out.  Trying it again in the outer
1:ddae94a: 		// transaction will then succeed. If the reason is some
1:ddae94a: 		// other transaction barring us, trying again in the outer
1:ddae94a: 		// transaction will possibly time out again.
1:ddae94a: 		//
1:ddae94a: 		// Also, if creating a nested transaction failed, only try
1:ddae94a: 		// once in the outer transaction.
1:ddae94a: 		while (true) {
1:ddae94a: 			try {
1:ddae94a: 				csca.executeConstantAction(activation, useTc);
1:ddae94a: 			} catch (StandardException se) {
1:9e04f69: 
1:c9ef166: 				if (se.isLockTimeout()) {
1:c9ef166:                     // We don't test for SQLState.DEADLOCK because if it is a
1:c9ef166:                     // deadlock, it may be better to expose it.  Just go ahead
1:c9ef166:                     // and throw it.
1:4d8deb6: 
1:c9ef166:                     if (!se.getMessageId().equals(SQLState.LOCK_TIMEOUT_LOG)) {
1:c9ef166:                         // In case of a LOCK_TIMEOUT_LOG also just throw it.
1:ddae94a:                         // LOCK_TIMEOUT_LOG happens when the app has set
1:ddae94a:                         // derby.locks.deadlockTrace=true, in which case we
1:c9ef166:                         // don't want to mask the timeout. 
1:9e04f69: 
1:ddae94a:                         if (useTc == nestedTc) {
1:ddae94a: 
1:ddae94a:                             // clean up after use of nested transaction,
1:ddae94a:                             // then try again in outer transaction
1:ddae94a:                             useTc = tc;
1:ddae94a:                             nestedTc.destroy();
1:ddae94a:                             continue;
1:ddae94a:                         }
1:9e04f69:                     }
1:9e04f69: 
1:ddae94a: 				} else if (se.getMessageId()
1:ddae94a: 							   .equals(SQLState.LANG_OBJECT_ALREADY_EXISTS)) {
1:ddae94a: 					// Ignore "Schema already exists". Another thread has
1:ddae94a: 					// probably created it after we checked for it
1:ddae94a: 					break;
1:ddae94a: 				}
1:ddae94a: 
1:ddae94a: 				// We got an non-expected exception, either in
1:ddae94a: 				// the nested transaction or in the outer
1:ddae94a: 				// transaction; we had better pass that on
1:ddae94a: 				if (useTc == nestedTc) {
1:ddae94a: 					nestedTc.destroy();
1:ddae94a: 				}
1:ddae94a: 
1:ddae94a: 				throw se;
1:ddae94a: 			}
1:ddae94a: 			break;
1:ddae94a: 		}
1:ddae94a: 
1:ddae94a: 		// We either succeeded or got LANG_OBJECT_ALREADY_EXISTS.
1:ddae94a: 		// Clean up if we did this in a nested transaction.
1:ddae94a: 		if (useTc == nestedTc) {
1:ddae94a: 			nestedTc.commit();
1:ddae94a: 			nestedTc.destroy();
1:ddae94a: 		}
1:ddae94a: 	}
1:ddae94a: 
1:ddae94a: 
1:e126f58: 	/**
1:eac0369: 	 * Lock the table in exclusive or share mode to prevent deadlocks.
1:eac0369: 	 *
1:eac0369: 	 * @param tc						The TransactionController
1:eac0369: 	 * @param heapConglomerateNumber	The conglomerate number for the heap.
1:eac0369: 	 * @param exclusiveMode				Whether or not to lock the table in exclusive mode.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException if schema is system schema
1:eac0369: 	 */
1:eac0369: 	final void lockTableForDDL(TransactionController tc,
1:eac0369: 						 long heapConglomerateNumber, boolean exclusiveMode)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		ConglomerateController cc;
1:9e04f69: 
1:eac0369: 		cc = tc.openConglomerate(
1:eac0369: 					heapConglomerateNumber,
1:eac0369:                     false,
1:eac0369: 					(exclusiveMode) ?
1:eac0369: 						(TransactionController.OPENMODE_FORUPDATE | 
1:eac0369: 							TransactionController.OPENMODE_FOR_LOCK_ONLY) :
1:eac0369: 						TransactionController.OPENMODE_FOR_LOCK_ONLY,
1:eac0369: 			        TransactionController.MODE_TABLE,
1:eac0369:                     TransactionController.ISOLATION_SERIALIZABLE);
1:eac0369: 		cc.close();
1:9e04f69: 	}
1:4d8deb6: 
1:eac0369: 	protected String constructToString(
1:eac0369: 						String				statementType,
1:eac0369: 						String              objectName)
1:eac0369: 	{
1:eac0369: 		// Do not put this under SanityManager.DEBUG - it is needed for
1:eac0369: 		// error reporting.
1:4d8deb6: 
1:eac0369: 		return statementType + objectName;
1:9e04f69: 	}
1:4d8deb6: 	
1:4d8deb6: 	
1:3c09be7: 	/**
1:2d2e717: 	 *	This method saves dependencies of constraints on privileges in the  
1:2d2e717: 	 *  dependency system. It gets called by CreateConstraintConstantAction.
1:2d2e717: 	 *  Views and triggers and constraints run with definer's privileges. If 
1:2d2e717: 	 *  one of the required privileges is revoked from the definer, the 
1:2d2e717: 	 *  dependent view/trigger/constraint on that privilege will be dropped 
1:2d2e717: 	 *  automatically. In order to implement this behavior, we need to save 
1:2d2e717: 	 *  view/trigger/constraint dependencies on required privileges in the 
1:2d2e717: 	 *  dependency system. Following method accomplishes that part of the 
1:2d2e717: 	 *  equation for constraints only. The dependency collection for 
1:2d2e717: 	 *  constraints is not same as for views and triggers and hence 
1:2d2e717: 	 *  constraints are handled by this special method.
1:8875d69: 	 *
1:2d2e717: 	 * 	Views and triggers can depend on many different kind of privileges
1:8875d69: 	 *  where as constraints only depend on REFERENCES privilege on a table
1:8875d69: 	 *  (FOREIGN KEY constraints) or EXECUTE privileges on one or more
1:8875d69: 	 *  functions (CHECK constraints).
1:8875d69: 	 *
1:2d2e717: 	 *  Another difference is only one view or trigger can be defined by a
1:2d2e717: 	 *  sql statement and hence all the dependencies collected for the sql
1:2d2e717: 	 *  statement apply to the view or trigger in question. As for constraints,
1:2d2e717: 	 *  one sql statement can defined multiple constraints and hence the 
1:2d2e717: 	 *  all the privileges required by the statement are not necessarily
1:2d2e717: 	 *  required by all the constraints defined by that sql statement. We need
1:2d2e717: 	 *  to identify right privileges for right constraints for a given sql
1:2d2e717: 	 *  statement. Because of these differences between constraints and views
1:2d2e717: 	 *  (and triggers), there are 2 different methods in this class to save
1:eb38311: 	 *  their privileges in the dependency system.
1:eb38311: 	 *
1:eb38311: 	 *  For each required privilege, we now register a dependency on a role if
1:eb38311: 	 *  that role was required to find an applicable privilege.
1:eb38311: 	 *   
1:2d2e717: 	 *  @param activation The execution environment for this constant action.
1:2d2e717: 	 *  @param dependent Make this object depend on required privileges
1:2d2e717: 	 *  @param refTableUUID Make sure we are looking for REFERENCES privilege 
1:2d2e717: 	 * 		for right table
1:8875d69: 	 *  @param providers set of providers for this constraint
1:2d2e717: 	 * @exception StandardException		Thrown on failure
1:2d2e717: 	 */
1:2d2e717: 	protected void storeConstraintDependenciesOnPrivileges(
1:8875d69: 		Activation activation,
1:8875d69: 		Dependent dependent,
1:8875d69: 		UUID refTableUUID,
1:8875d69: 		ProviderInfo[] providers)
1:8875d69: 			throws StandardException
1:2d2e717: 	{
1:2d2e717: 		LanguageConnectionContext lcc = activation.getLanguageConnectionContext();
1:2d2e717: 		DataDictionary dd = lcc.getDataDictionary();
1:2d2e717: 		DependencyManager dm = dd.getDependencyManager();
1:9f60172:         String currentUser = lcc.getCurrentUserId(activation);
1:eb38311: 		SettableBoolean roleDepAdded = new SettableBoolean();
1:eb38311: 
1:439d1e8: 		//If the Database Owner is creating this constraint, then no need to 
1:439d1e8: 		//collect any privilege dependencies because the Database Owner can   
1:439d1e8: 		//access any objects without any restrictions
1:9f60172:         if (! currentUser.equals( dd.getAuthorizationDatabaseOwner()) )
1:2d2e717: 		{
1:2d2e717: 			PermissionsDescriptor permDesc;
1:eb38311: 			// Now, it is time to add into dependency system the FOREIGN
1:eb38311: 			// constraint's dependency on REFERENCES privilege, or, if it is a
1:a4cbe6f: 			// CHECK constraint, any EXECUTE or USAGE privileges. If the REFERENCES is
1:eb38311: 			// revoked from the constraint owner, the constraint will get
1:eb38311: 			// dropped automatically.
1:801cf0d:             List<StatementPermission> requiredPermissionsList =
1:801cf0d:                 activation.getPreparedStatement().getRequiredPermissionsList();
1:eb38311: 
2:2d2e717: 			if (requiredPermissionsList != null && ! requiredPermissionsList.isEmpty())
1:2d2e717: 			{
1:801cf0d:                 for (StatementPermission statPerm : requiredPermissionsList)
1:2d2e717: 				{
1:2d2e717: 					//First check if we are dealing with a Table or 
1:2d2e717: 					//Column level privilege. All the other privileges
1:2d2e717: 					//are not required for a foreign key constraint.
1:2d2e717: 					if (statPerm instanceof StatementTablePermission)
1:2d2e717: 					{//It is a table/column level privilege
1:2d2e717: 						StatementTablePermission statementTablePermission = 
1:2d2e717: 							(StatementTablePermission) statPerm;
1:2d2e717: 						//Check if we are dealing with REFERENCES privilege.
1:2d2e717: 						//If not, move on to the next privilege in the
1:2d2e717: 						//required privileges list
1:2d2e717: 						if (statementTablePermission.getPrivType() != Authorizer.REFERENCES_PRIV)
1:9e04f69: 							continue;
1:2d2e717: 						//Next check is this REFERENCES privilege is 
1:2d2e717: 						//on the same table as referenced by the foreign
1:2d2e717: 						//key constraint? If not, move on to the next
1:2d2e717: 						//privilege in the required privileges list
1:2d2e717: 						if (!statementTablePermission.getTableUUID().equals(refTableUUID))
1:4d8deb6: 							continue;
1:eb38311: 					} else if (statPerm instanceof StatementSchemaPermission
1:a4cbe6f: 						    || statPerm instanceof StatementRolePermission
1:a4cbe6f:                                || statPerm instanceof StatementGenericPermission ) {
1:c9ef166: 						continue;
1:8875d69: 					} else {
1:8875d69: 						if (SanityManager.DEBUG) {
1:8875d69: 							SanityManager.ASSERT(
1:8875d69: 								statPerm instanceof StatementRoutinePermission,
1:8875d69: 								"only StatementRoutinePermission expected");
1:8875d69: 						}
1:8875d69: 
1:8875d69: 						// skip if this permission concerns a function not
1:8875d69: 						// referenced by this constraint
1:8875d69: 						StatementRoutinePermission rp =
1:8875d69: 							(StatementRoutinePermission)statPerm;
1:8875d69: 						if (!inProviderSet(providers, rp.getRoutineUUID())) {
1:8875d69: 							continue;
1:8875d69: 						}
1:9e04f69: 					}
1:8875d69: 
1:8875d69: 
1:a4cbe6f: 					// We know that we are working with a REFERENCES, EXECUTE, or USAGE
1:8875d69: 					// privilege. Find all the PermissionDescriptors for this
1:8875d69: 					// privilege and make constraint depend on it through
1:8875d69: 					// dependency manager.  The REFERENCES privilege could be
1:8875d69: 					// defined at the table level or it could be defined at
1:8875d69: 					// individual column levels. In addition, individual column
1:8875d69: 					// REFERENCES privilege could be available at the user
1:a4cbe6f: 					// level, PUBLIC or role level.  EXECUTE and USAGE privileges could be
1:eb38311: 					// available at the user level, PUBLIC or role level.
1:9f60172:                     permDesc = statPerm.getPermissionDescriptor(
1:9f60172:                         currentUser, dd);
1:9f60172: 
1:2d2e717: 					if (permDesc == null) 
1:2d2e717: 					{
1:eb38311: 						// No privilege exists for given user. The privilege
1:eb38311: 						// has to exist at at PUBLIC level....
1:eb38311: 
2:2d2e717: 						permDesc = statPerm.getPermissionDescriptor(Authorizer.PUBLIC_AUTHORIZATION_ID, dd);
1:eb38311: 						// .... or at the role level. Additionally, for column
1:eb38311: 						// level privileges, even if *some* were available at
1:eb38311: 						// the PUBLIC level others may be still be missing,
1:eb38311: 						// hence the call in the test below to
1:eb38311: 						// allColumnsCoveredByUserOrPUBLIC.
1:eb38311: 						boolean roleUsed = false;
1:eb38311: 
1:eb38311: 						if (permDesc == null ||
1:eb38311: 							((permDesc instanceof ColPermsDescriptor) &&
1:9f60172:                                  ! ((StatementColumnPermission)statPerm).
1:9f60172:                                    allColumnsCoveredByUserOrPUBLIC(
1:9f60172:                                        currentUser, dd))) {
1:eb38311: 							roleUsed = true;
1:eb38311: 							permDesc = findRoleUsage(activation, statPerm);
1:eb38311: 						}
1:eb38311: 
1:eb38311: 						// If the user accessing the object is the owner of
1:eb38311: 						// that object, then no privilege tracking is needed
1:eb38311: 						// for the owner.
1:9f60172:                         if (! permDesc.checkOwner(currentUser) ) {
1:9f60172: 
1:9f60172:                             dm.addDependency(dependent, permDesc,
1:eb38311: 											 lcc.getContextManager());
1:eb38311: 
1:eb38311: 							if (roleUsed) {
1:eb38311: 								// We had to rely on role, so track that
1:eb38311: 								// dependency, too.
1:eb38311: 								trackRoleDependency
1:eb38311: 									(activation, dependent, roleDepAdded);
1:eb38311: 							}
1:eb38311: 						}
1:eb38311: 					} else
1:2d2e717: 						//if the object on which permission is required is owned by the
1:2d2e717: 						//same user as the current user, then no need to keep that
1:2d2e717: 						//object's privilege dependency in the dependency system
1:9f60172:                     if (! permDesc.checkOwner(currentUser))
1:2d2e717: 					{
4:2d2e717: 						dm.addDependency(dependent, permDesc, lcc.getContextManager());
1:2d2e717: 						if (permDesc instanceof ColPermsDescriptor)
1:2d2e717: 						{
1:eb38311: 							// The if statement above means we found a
1:eb38311: 							// REFERENCES privilege at column level for the
1:eb38311: 							// given authorizer. If this privilege doesn't
1:eb38311: 							// cover all the column , then there has to exisit
1:eb38311: 							// REFERENCES for the remaining columns at PUBLIC
1:eb38311: 							// level or at role level.  Get that permission
1:eb38311: 							// descriptor and save it in dependency system
1:eb38311: 							StatementColumnPermission
1:eb38311: 								statementColumnPermission = (
1:eb38311: 									StatementColumnPermission)statPerm;
1:eb38311: 							permDesc = statementColumnPermission.
1:9f60172:                                 getPUBLIClevelColPermsDescriptor(
1:9f60172:                                     currentUser, dd);
1:2d2e717: 							//Following if checks if some column level privileges
1:2d2e717: 							//exist only at public level. If so, then the public
1:2d2e717: 							//level column privilege dependency is added
1:2d2e717: 							//into the dependency system
1:eb38311: 							if (permDesc != null &&
1:eb38311: 									permDesc.getObjectID() != null) {
1:eb38311: 								// User did not have all required column
1:eb38311: 								// permissions and at least one column is
1:eb38311: 								// covered by PUBLIC.
1:eb38311: 								dm.addDependency(dependent, permDesc,
1:eb38311: 												 lcc.getContextManager());
1:eb38311: 							}
1:eb38311: 							// Possibly, the current role has also been relied
1:eb38311: 							// upon.
1:eb38311: 							if (!statementColumnPermission.
1:9f60172:                                     allColumnsCoveredByUserOrPUBLIC(
1:9f60172:                                         currentUser, dd)) {
1:eb38311: 								// Role has been relied upon, so register a
1:eb38311: 								// dependency.
1:eb38311: 								trackRoleDependency
1:eb38311: 									(activation, dependent, roleDepAdded);
1:eb38311: 							}
1:9e04f69: 						}
1:1a63d73: 					}
1:8875d69: 
1:eb38311: 					if (!(statPerm instanceof StatementRoutinePermission)) {
1:8875d69: 						//We have found the REFERENCES privilege for all the
1:8875d69: 						//columns in foreign key constraint and we don't
1:8875d69: 						//need to go through the rest of the privileges
1:8875d69: 						//for this sql statement.
1:8875d69: 						break;
1:eb38311: 					} else {
1:eb38311: 						// For EXECUTE privilege there may be several functions
1:eb38311: 						// referenced in the constraint, so continue looking.
1:eb38311: 					}
1:8875d69: 				}
1:4d8deb6: 			}
1:4d8deb6: 		}
1:eb38311: 		
1:4d8deb6: 	}	
1:eb38311: 
1:eb38311: 
1:eb38311: 	/**
1:eb38311: 	 * We have determined that the statement permission described by statPerm
1:eb38311: 	 * is not granted to the current user nor to PUBLIC, so it must be granted
1:eb38311: 	 * to the current role or one of the roles inherited by the current
1:eb38311: 	 * role. Find the relevant permission descriptor and return it.
1:eb38311: 	 *
1:eb38311: 	 * @return the permission descriptor that yielded the privilege
1:eb38311: 	 */
1:eb38311: 	private static PermissionsDescriptor findRoleUsage
1:eb38311: 		(Activation activation,
1:eb38311: 		 StatementPermission statPerm) throws StandardException {
1:eb38311: 
1:eb38311: 		LanguageConnectionContext lcc =
1:eb38311: 			activation.getLanguageConnectionContext();
1:eb38311: 		DataDictionary dd = lcc.getDataDictionary();
1:eb38311: 		String role = lcc.getCurrentRoleId(activation);
1:eb38311: 		PermissionsDescriptor permDesc = null;
1:eb38311: 
1:eb38311: 		if (SanityManager.DEBUG) {
1:eb38311: 			SanityManager.ASSERT(
1:eb38311: 				role != null,
1:eb38311: 				"Unexpected: current role is not set");
1:eb38311: 		}
1:eb38311: 
1:eb38311: 		// If not found in current role, get transitive
1:eb38311: 		// closure of roles granted to current role and
1:eb38311: 		// iterate over it to see if permission has
1:eb38311: 		// been granted to any of the roles the current
1:eb38311: 		// role inherits.
1:eb38311: 		RoleClosureIterator rci =
1:eb38311: 			dd.createRoleClosureIterator
1:eb38311: 			(activation.getTransactionController(),
1:eb38311: 			 role, true /* inverse relation*/);
1:eb38311: 
1:eb38311: 		String graphGrant;
1:eb38311: 		while (permDesc == null &&
1:eb38311: 			   (graphGrant = rci.next()) != null) {
1:eb38311: 			permDesc =
1:eb38311: 				statPerm.getPermissionDescriptor
1:eb38311: 				(graphGrant, dd);
1:eb38311: 		}
1:eb38311: 
1:eb38311: 		if (SanityManager.DEBUG) {
1:eb38311: 			SanityManager.ASSERT(
1:eb38311: 				permDesc != null,
1:eb38311: 				"Unexpected: Permission needs to be found via role");
1:eb38311: 		}
1:eb38311: 
1:eb38311: 		return permDesc;
1:eb38311: 	}
1:eb38311: 
1:eb38311: 
1:eb38311: 	/**
1:eb38311: 	 * The statement permission needed for dependent has been found to rely on
1:eb38311: 	 * the current role. If not already done, register the dependency so that
1:eb38311: 	 * if the current role (or any of the roles it inherits) is revoked (or
1:eb38311: 	 * dropped), we can invalidate dependent.
1:eb38311: 	 *
1:eb38311: 	 * @param activation the current activation
1:eb38311: 	 * @param dependent the view, constraint or trigger that is dependent on the
1:eb38311: 	 *        current role for some privilege.
1:801cf0d:      * @param roleDepAdded keeps track of whether a dependency on the
1:801cf0d:      *        current role has already been registered.
1:eb38311: 	 */
1:eb38311: 	private static void trackRoleDependency(Activation activation,
1:eb38311: 											Dependent dependent,
1:eb38311: 											SettableBoolean roleDepAdded)
1:eb38311: 			throws StandardException {
1:eb38311: 
1:eb38311: 		// We only register the dependency once, lest
1:eb38311: 		// we get duplicates in SYSDEPENDS (duplicates
1:eb38311: 		// are not healthy..invalidating more than once
1:eb38311: 		// fails for triggers at least).
1:eb38311: 		if (!roleDepAdded.get()) {
1:eb38311: 			LanguageConnectionContext lcc =
1:eb38311: 				activation.getLanguageConnectionContext();
1:eb38311: 			DataDictionary dd = lcc.getDataDictionary();
1:eb38311: 			DependencyManager dm = dd.getDependencyManager();
1:eb38311: 
1:eb38311: 			String role =
1:eb38311: 				lcc.getCurrentRoleId(activation);
1:eb38311: 			RoleGrantDescriptor rgd =
1:eb38311: 				dd.getRoleDefinitionDescriptor(role);
1:eb38311: 
1:eb38311: 			dm.addDependency
1:eb38311: 				(dependent, rgd,
1:eb38311: 				 lcc.getContextManager());
1:eb38311: 			roleDepAdded.set(true);
1:eb38311: 		}
1:eb38311: 	}
1:eb38311: 
1:2d2e717: 	/**
1:2d2e717: 	 *	This method saves dependencies of views and triggers on privileges in  
1:2d2e717: 	 *  the dependency system. It gets called by CreateViewConstantAction
1:2d2e717: 	 *  and CreateTriggerConstantAction. Views and triggers and constraints
1:2d2e717: 	 *  run with definer's privileges. If one of the required privileges is
1:2d2e717: 	 *  revoked from the definer, the dependent view/trigger/constraint on
1:2d2e717: 	 *  that privilege will be dropped automatically. In order to implement 
1:2d2e717: 	 *  this behavior, we need to save view/trigger/constraint dependencies 
1:2d2e717: 	 *  on required privileges in the dependency system. Following method 
1:2d2e717: 	 *  accomplishes that part of the equation for views and triggers. The
1:2d2e717: 	 *  dependency collection for constraints is not same as for views and
1:2d2e717: 	 *  triggers and hence constraints are not covered by this method.
1:2d2e717: 	 *  Views and triggers can depend on many different kind of privileges
2:2d2e717: 	 *  where as constraints only depend on REFERENCES privilege on a table.
1:2d2e717: 	 *  Another difference is only one view or trigger can be defined by a
1:2d2e717: 	 *  sql statement and hence all the dependencies collected for the sql
1:2d2e717: 	 *  statement apply to the view or trigger in question. As for constraints,
1:2d2e717: 	 *  one sql statement can defined multiple constraints and hence the 
1:2d2e717: 	 *  all the privileges required by the statement are not necessarily
1:2d2e717: 	 *  required by all the constraints defined by that sql statement. We need
1:2d2e717: 	 *  to identify right privileges for right constraints for a given sql
1:2d2e717: 	 *  statement. Because of these differences between constraints and views
1:2d2e717: 	 *  (and triggers), there are 2 different methods in this class to save
2:2d2e717: 	 *  their privileges in the dependency system.
1:2d2e717: 	 *
1:eb38311: 	 *  For each required privilege, we now register of a dependency on a role
1:eb38311: 	 *  if that role was required to find an applicable privilege.
1:2d2e717: 	 *
1:2d2e717: 	 *  @param activation The execution environment for this constant action.
1:2d2e717: 	 *  @param dependent Make this object depend on required privileges
1:eac0369: 	 *
1:2d2e717: 	 * @exception StandardException		Thrown on failure
1:2d2e717: 	 */
1:2d2e717: 	protected void storeViewTriggerDependenciesOnPrivileges(
1:2d2e717: 			Activation activation, Dependent dependent)
1:2d2e717: 	throws StandardException
1:2d2e717: 	{
1:2d2e717: 		LanguageConnectionContext lcc = activation.getLanguageConnectionContext();
1:2d2e717: 		DataDictionary dd = lcc.getDataDictionary();
1:2d2e717: 		DependencyManager dm = dd.getDependencyManager();
1:eb38311: 		String dbo = dd.getAuthorizationDatabaseOwner();
1:9f60172:         String currentUser = lcc.getCurrentUserId(activation);
1:eb38311: 		SettableBoolean roleDepAdded = new SettableBoolean();
1:eb38311: 
1:eb38311: 		// If the Database Owner is creating this view/trigger, then no need to
1:eb38311: 		// collect any privilege dependencies because the Database Owner can
1:eb38311: 		// access any objects without any restrictions.
1:9f60172:         if (! currentUser.equals(dbo))
1:2d2e717: 		{
1:2d2e717: 			PermissionsDescriptor permDesc;
1:801cf0d:             List<StatementPermission> requiredPermissionsList =
1:801cf0d:                 activation.getPreparedStatement().getRequiredPermissionsList();
1:801cf0d: 
1:801cf0d:             if (requiredPermissionsList != null &&
1:801cf0d:                 ! requiredPermissionsList.isEmpty())
1:2d2e717: 			{
1:801cf0d:                 for (StatementPermission statPerm : requiredPermissionsList)
1:2d2e717: 				{
1:2d2e717: 					//The schema ownership permission just needs to be checked 
1:2d2e717: 					//at object creation time, to see if the object creator has 
1:2d2e717: 					//permissions to create the object in the specified schema. 
1:2d2e717: 					//But we don't need to add schema permission to list of 
1:2d2e717: 					//permissions that the object is dependent on once it is 
1:2d2e717: 					//created.
1:eb38311: 					//Also, StatementRolePermission should not occur here.
1:eb38311: 					if (statPerm instanceof StatementSchemaPermission ||
1:eb38311: 						statPerm instanceof StatementRolePermission) {
1:eb38311: 
1:eb38311: 						if (SanityManager.DEBUG) {
1:eb38311: 							if (statPerm instanceof StatementRolePermission) {
1:eb38311: 								SanityManager.THROWASSERT(
1:eb38311: 									"Unexpected StatementRolePermission");
1:eb38311: 							}
1:eb38311: 						}
1:eb38311: 
4:2d2e717: 						continue;
1:eb38311: 					}
1:eb38311: 
1:2d2e717: 					//See if we can find the required privilege for given authorizer?
1:9f60172:                     permDesc = statPerm.
1:9f60172:                         getPermissionDescriptor(currentUser, dd);
1:2d2e717: 					if (permDesc == null)//privilege not found for given authorizer 
1:2d2e717: 					{
1:2d2e717: 						//The if condition above means that required privilege does 
1:2d2e717: 						//not exist at the user level. The privilege has to exist at 
1:eb38311: 						//PUBLIC level... ,
1:eb38311: 						permDesc = statPerm.getPermissionDescriptor(
1:eb38311: 							Authorizer.PUBLIC_AUTHORIZATION_ID, dd);
1:eb38311: 
1:eb38311: 						boolean roleUsed = false;
1:eb38311: 
1:eb38311: 						// .. or at role level
1:eb38311: 						if (permDesc == null ||
1:eb38311: 								((permDesc instanceof ColPermsDescriptor) &&
1:9f60172:                                  ! ((StatementColumnPermission)statPerm).
1:9f60172:                                      allColumnsCoveredByUserOrPUBLIC(
1:9f60172:                                          currentUser, dd)) ) {
1:eb38311: 							roleUsed = true;
1:eb38311: 							permDesc = findRoleUsage(activation, statPerm);
1:eb38311: 						}
1:eb38311: 
1:2d2e717: 						//If the user accessing the object is the owner of that 
1:2d2e717: 						//object, then no privilege tracking is needed for the
1:2d2e717: 						//owner.
1:9f60172:                         if (! permDesc.checkOwner(currentUser) ) {
1:9f60172: 
1:2d2e717: 							dm.addDependency(dependent, permDesc, lcc.getContextManager());
1:eb38311: 
1:eb38311: 							// We had to rely on role, so track that
1:eb38311: 							// dependency, too.
1:eb38311: 							if (roleUsed) {
1:eb38311: 								trackRoleDependency
1:eb38311: 									(activation, dependent, roleDepAdded);
1:eb38311: 							}
1:eb38311: 						}
1:2d2e717: 						continue;
1:4d8deb6: 					}
1:2d2e717: 					//if the object on which permission is required is owned by the
1:2d2e717: 					//same user as the current user, then no need to keep that
1:2d2e717: 					//object's privilege dependency in the dependency system
1:9f60172:                     if (! permDesc.checkOwner(currentUser) )
1:2d2e717: 					{
1:2d2e717: 						dm.addDependency(dependent, permDesc, lcc.getContextManager());	           							
1:2d2e717: 						if (permDesc instanceof ColPermsDescriptor)
1:2d2e717: 						{
1:2d2e717: 							//For a given table, the table owner can give privileges
1:2d2e717: 							//on some columns at individual user level and privileges
1:2d2e717: 							//on some columns at PUBLIC level. Hence, when looking for
1:2d2e717: 							//column level privileges, we need to look both at user
1:2d2e717: 							//level as well as PUBLIC level(only if user level column
1:2d2e717: 							//privileges do not cover all the columns accessed by this
1:2d2e717: 							//object). We have finished adding dependency for user level 
1:2d2e717: 							//columns, now we are checking if some required column 
1:2d2e717: 							//level privileges are at PUBLIC level.
1:2d2e717: 							//A specific eg of a view
1:2d2e717: 							//user1
1:2d2e717: 							//create table t11(c11 int, c12 int);
1:2d2e717: 							//grant select(c11) on t1 to user2;
1:2d2e717: 							//grant select(c12) on t1 to PUBLIC;
1:2d2e717: 							//user2
1:2d2e717: 							//create view v1 as select c11 from user1.t11 where c12=2;
1:2d2e717: 							//For the view above, there are 2 column level privilege 
1:2d2e717: 							//depencies, one for column c11 which exists directly
1:2d2e717: 							//for user2 and one for column c12 which exists at PUBLIC level.
2:2d2e717: 							StatementColumnPermission statementColumnPermission = (StatementColumnPermission) statPerm;
1:9f60172:                             permDesc = statementColumnPermission.
1:9f60172:                                 getPUBLIClevelColPermsDescriptor(
1:9f60172:                                     currentUser, dd);
1:2d2e717: 							//Following if checks if some column level privileges
1:2d2e717: 							//exist only at public level. If so, then the public
1:eb38311: 							//level column privilege, if any, dependency of
1:eb38311: 							//view is added into dependency system.
1:eb38311: 
1:eb38311: 							if (permDesc != null &&
1:eb38311: 									permDesc.getObjectID() != null) {
1:eb38311: 								// User did not have all required column
1:eb38311: 								// permissions and at least one column is
1:eb38311: 								// covered by PUBLIC.
1:eb38311: 								dm.addDependency(dependent, permDesc,
1:eb38311: 												 lcc.getContextManager());
1:eb38311: 							} // else nothing found for PUBLIC..
1:eb38311: 
1:eb38311: 							// Has the the current role has also been relied
1:eb38311: 							// upon?
1:eb38311: 							if (!statementColumnPermission.
1:9f60172:                                     allColumnsCoveredByUserOrPUBLIC(
1:9f60172:                                         currentUser, dd)) {
1:eb38311: 								trackRoleDependency
1:eb38311: 									(activation, dependent, roleDepAdded);
1:eb38311: 							}
1:4d8deb6: 						}
1:4d8deb6: 					}
1:c9ef166: 				}
1:c9ef166: 			}
1:2d2e717: 		}
1:2d2e717: 	}
1:4d8deb6: 
1:8875d69: 	private boolean inProviderSet(ProviderInfo[] providers, UUID routineId) {
1:8875d69: 		if (providers == null) {
1:8875d69: 			return false;
1:8875d69: 		}
1:eb38311: 
1:8875d69: 		for (int i = 0; i < providers.length; i++) {
1:8875d69: 			if (providers[i].getObjectId().equals(routineId)) {
1:8875d69: 				return true;
1:8875d69: 			}
1:8875d69: 		}
1:8875d69: 		return false;
1:8875d69: 	}
1:3c09be7: 
1:eb38311:     /**
1:3c09be7:      * Add dependencies of a column on providers. These can arise if a generated column depends
1:3c09be7:      * on a user created function.
1:3c09be7:      */
1:3c09be7:     protected   void    addColumnDependencies
1:e126f58:         (
1:e126f58:          LanguageConnectionContext  lcc,
1:e126f58:          DataDictionary     dd,
1:e126f58:          TableDescriptor    td,
1:3c09be7:          ColumnInfo         ci
1:3c09be7:          )
1:3c09be7:         throws StandardException
1:e126f58:     {
1:3c09be7:         ProviderInfo[]  providers = ci.providers;
1:e126f58: 
1:3c09be7:         if ( providers != null )
1:3c09be7:         {
1:e126f58:             DependencyManager   dm = dd.getDependencyManager();
1:e126f58:             ContextManager      cm = lcc.getContextManager();
1:3c09be7:             int                         providerCount = providers.length;
1:3c09be7:             ColumnDescriptor    cd = td.getColumnDescriptor( ci.name );
1:3c09be7:             DefaultDescriptor   defDesc = cd.getDefaultDescriptor( dd );
1:e126f58: 
1:3c09be7:             for ( int px = 0; px < providerCount; px++ )
1:3c09be7:             {
1:3c09be7:                 ProviderInfo            pi = providers[ px ];
1:3c09be7:                 DependableFinder    finder = pi.getDependableFinder();
1:3c09be7:                 UUID                        providerID = pi.getObjectId();
1:3c09be7:                 Provider                    provider = (Provider) finder.getDependable( dd, providerID );
1:3c09be7: 
1:3c09be7:                 dm.addDependency( defDesc, provider, cm );
1:3c09be7:             }   // end loop through providers
1:3c09be7:         }
1:3c09be7:     }
1:3c09be7: 
1:eac0369:     /**
1:e126f58:      * Adjust dependencies of a table on ANSI UDTs. We only add one dependency
1:e126f58:      * between a table and a UDT. If the table already depends on the UDT, we don't add
1:e126f58:      * a redundant dependency.
1:eac0369:      */
1:e126f58:     protected   void    adjustUDTDependencies
1:3c09be7:         (
1:3c09be7:          LanguageConnectionContext  lcc,
1:b8c6110:          DataDictionary             dd,
1:b8c6110:          TableDescriptor            td,
1:b8c6110:          ColumnInfo[]               columnInfos,
1:b8c6110:          boolean                    dropWholeTable
1:e126f58:          )
1:e126f58:         throws StandardException
1:e126f58:     {
1:b8c6110:         if ( (!dropWholeTable) && (columnInfos == null) ) { return; }
1:e126f58: 
1:e126f58: 		TransactionController tc = lcc.getTransactionExecute();
1:801cf0d: 
1:b8c6110:         int changedColumnCount = columnInfos == null ? 0 : columnInfos.length;
1:71c8e86:         HashMap<String,AliasDescriptor> addUdtMap = new HashMap<String,AliasDescriptor>();
1:71c8e86:         HashMap<String,AliasDescriptor> dropUdtMap = new HashMap<String,AliasDescriptor>();
1:71c8e86:         HashSet<String> addColumnNames = new HashSet<String>();
1:71c8e86:         HashSet<String> dropColumnNames = new HashSet<String>();
1:e126f58: 
1:e126f58:         // first find all of the new ansi udts which the table must depend on
1:e126f58:         // and the old ones which are candidates for removal
1:e126f58:         for ( int i = 0; i < changedColumnCount; i++ )
1:e126f58:         {
1:e126f58:             ColumnInfo ci = columnInfos[ i ];
1:e126f58: 
1:e126f58:             // skip this column if it is not a UDT
1:e126f58:             AliasDescriptor ad = dd.getAliasDescriptorForUDT( tc, columnInfos[ i ].dataType );
1:e126f58:             if ( ad == null ) { continue; }
1:e126f58: 
1:e126f58:             String key = ad.getObjectID().toString();
1:e126f58: 
1:e126f58:             if ( ci.action == ColumnInfo.CREATE )
1:e126f58:             {
1:e126f58:                 addColumnNames.add( ci.name);
1:e126f58: 
1:e126f58:                 // no need to add the descriptor if it is already on the list
1:e126f58:                 if ( addUdtMap.get( key ) != null ) { continue; }
1:e126f58: 
1:e126f58:                 addUdtMap.put( key, ad );
1:e126f58:             }
1:e126f58:             else if ( ci.action == ColumnInfo.DROP )
1:e126f58:             {
1:e126f58:                 dropColumnNames.add( ci.name );
1:e126f58:                 dropUdtMap.put( key, ad );
1:e126f58:             }
1:e126f58:         }
1:e126f58: 
1:b8c6110:         // nothing to do if there are no changed columns of udt type
1:b8c6110:         // and this is not a DROP TABLE command
1:801cf0d:         if ( !dropWholeTable && addUdtMap.isEmpty() && dropUdtMap.isEmpty() ) {
1:801cf0d:             return;
1:801cf0d:         }
1:e126f58: 
1:9e04f69:         //
1:e126f58:         // Now prune from the add list all udt descriptors for which we already have dependencies.
1:e126f58:         // These are the udts for old columns. This supports the ALTER TABLE ADD COLUMN
1:e126f58:         // case.
1:4d8deb6:         //
1:e126f58:         // Also prune from the drop list add udt descriptors which will still be
1:e126f58:         // referenced by the remaining columns.
3:e126f58:         //
1:e126f58:         ColumnDescriptorList cdl = td.getColumnDescriptorList();
1:e126f58:         int totalColumnCount = cdl.size();
1:e126f58: 
1:e126f58:         for ( int i = 0; i < totalColumnCount; i++ )
1:e126f58:         {
1:e126f58:             ColumnDescriptor cd = cdl.elementAt( i );
1:e126f58: 
1:e126f58:             // skip columns that are being added and dropped. we only want the untouched columns
1:e126f58:             if (
1:e126f58:                 addColumnNames.contains( cd.getColumnName() ) ||
1:e126f58:                 dropColumnNames.contains( cd.getColumnName() )
1:e126f58:                 ) { continue; }
1:e126f58: 
1:e126f58:             // nothing to do if the old column isn't a UDT
1:e126f58:             AliasDescriptor ad = dd.getAliasDescriptorForUDT( tc, cd.getType() );
1:e126f58:             if ( ad == null ) { continue; }
1:e126f58: 
1:e126f58:             String key = ad.getObjectID().toString();
1:e126f58: 
1:b8c6110:             // ha, it is a UDT.
1:b8c6110:             if ( dropWholeTable ) { dropUdtMap.put( key, ad ); }
1:b8c6110:             else
1:b8c6110:             {
1:b8c6110:                 if ( addUdtMap.get( key ) != null ) { addUdtMap.remove( key ); }
1:b8c6110:                 if ( dropUdtMap.get( key ) != null ) { dropUdtMap.remove( key ); }
1:b8c6110:             }
1:e126f58:         }
1:e126f58: 
1:2209325:         adjustUDTDependencies( lcc, dd, td, addUdtMap, dropUdtMap );
1:2209325:     }
1:2209325:     /**
1:2209325:      * Add and drop dependencies of an object on UDTs.
1:2209325:      *
1:2209325:      * @param lcc Interpreter's state variable for this session.
1:2209325:      * @param dd Metadata
1:2209325:      * @param dependent Object which depends on UDT
1:2209325:      * @param addUdtMap Map of UDTs for which dependencies should be added
1:2209325:      * @param dropUdtMap Map of UDT for which dependencies should be dropped
1:2209325:      */
1:2209325:     private   void    adjustUDTDependencies
1:2209325:         (
1:2209325:          LanguageConnectionContext  lcc,
1:2209325:          DataDictionary             dd,
1:2209325:          Dependent                  dependent,
1:801cf0d:          HashMap<String, AliasDescriptor> addUdtMap,
1:801cf0d:          HashMap<String, AliasDescriptor> dropUdtMap
1:2209325:          )
1:2209325:         throws StandardException
1:2209325:     {
1:e126f58:         // again, nothing to do if there are no columns of udt type
1:801cf0d:         if ( (addUdtMap.isEmpty()) && (dropUdtMap.isEmpty()) ) {
1:801cf0d:             return;
1:801cf0d:         }
1:e126f58: 
1:2209325: 		TransactionController tc = lcc.getTransactionExecute();
1:2209325:         DependencyManager     dm = dd.getDependencyManager();
1:2209325:         ContextManager        cm = lcc.getContextManager();
1:e126f58: 
1:e126f58:         // add new dependencies
1:801cf0d:         for (AliasDescriptor ad : addUdtMap.values())
1:e126f58:         {
1:2209325:             dm.addDependency( dependent, ad, cm );
1:e126f58:         }
1:e126f58: 
1:e126f58:         // drop dependencies that are orphaned
1:801cf0d:         for (AliasDescriptor ad : dropUdtMap.values()) {
1:801cf0d:             DependencyDescriptor dep = new DependencyDescriptor(dependent, ad);
1:801cf0d:             dd.dropStoredDependency( dep, tc );
1:e126f58:         }
1:e126f58:     }
1:e126f58: 
1:eac0369:     /**
1:2209325:      * Add and drop dependencies of a routine on UDTs.
1:2209325:      *
1:2209325:      * @param lcc Interpreter's state variable for this session.
1:2209325:      * @param dd Metadata
1:2209325:      * @param ad Alias descriptor for the routine
1:2209325:      * @param adding True if we are adding dependencies, false if we're dropping them
1:2209325:      */
1:2209325:     protected   void    adjustUDTDependencies
1:2209325:         (
1:2209325:          LanguageConnectionContext  lcc,
1:2209325:          DataDictionary             dd,
1:2209325:          AliasDescriptor            ad,
1:2209325:          boolean                    adding
1:2209325:          )
1:2209325:         throws StandardException
1:2209325:     {
1:aad6057:         RoutineAliasInfo      routineInfo = null;
1:aad6057:         AggregateAliasInfo  aggInfo = null;
1:aad6057:         
1:2209325:         // nothing to do if this is not a routine
1:2209325:         switch ( ad.getAliasType() )
1:2209325:         {
1:aad6057: 		case AliasInfo.ALIAS_TYPE_AGGREGATE_AS_CHAR:
1:aad6057:             aggInfo = (AggregateAliasInfo) ad.getAliasInfo();
1:9e04f69:             break;
1:aad6057: 
1:2209325: 		case AliasInfo.ALIAS_TYPE_PROCEDURE_AS_CHAR:
1:2209325: 		case AliasInfo.ALIAS_TYPE_FUNCTION_AS_CHAR:
1:aad6057:             routineInfo = (RoutineAliasInfo) ad.getAliasInfo();
1:9e04f69:             break;
1:2209325: 
1:2209325:         default: return;
1:2209325:         }
1:2209325:         
1:2209325: 		TransactionController tc = lcc.getTransactionExecute();
1:2209325: 
1:801cf0d:         HashMap<String,AliasDescriptor> addUdtMap =
1:801cf0d:                 new HashMap<String,AliasDescriptor>();
1:801cf0d: 
1:801cf0d:         HashMap<String,AliasDescriptor> dropUdtMap =
1:801cf0d:                 new HashMap<String,AliasDescriptor>();
1:801cf0d: 
1:801cf0d:         HashMap<String,AliasDescriptor> udtMap =
1:801cf0d:                 adding ? addUdtMap : dropUdtMap;
1:801cf0d: 
1:aad6057:         TypeDescriptor        rawReturnType = aggInfo != null ?
1:aad6057:             aggInfo.getReturnType() : routineInfo.getReturnType();
1:e126f58: 
1:2209325:         if ( rawReturnType != null )
1:2209325:         {
1:2209325:             AliasDescriptor       returnTypeAD = dd.getAliasDescriptorForUDT
1:2209325:                 ( tc, DataTypeDescriptor.getType( rawReturnType ) );
1:2209325: 
1:2209325:             if ( returnTypeAD != null ) { udtMap.put( returnTypeAD.getObjectID().toString(), returnTypeAD ); }
1:2209325:         }
1:2209325: 
1:b4af7da:         // table functions can have udt columns. track those dependencies.
1:b4af7da:         if ( (rawReturnType != null) && rawReturnType.isRowMultiSet() )
1:b4af7da:         {
1:b4af7da:             TypeDescriptor[] columnTypes = rawReturnType.getRowTypes();
1:b4af7da:             int columnCount = columnTypes.length;
1:b4af7da: 
1:b4af7da:             for ( int i = 0; i < columnCount; i++ )
1:b4af7da:             {
1:b4af7da:                 AliasDescriptor       columnTypeAD = dd.getAliasDescriptorForUDT
1:b4af7da:                     ( tc, DataTypeDescriptor.getType( columnTypes[ i ] ) );
1:b4af7da: 
1:b4af7da:                 if ( columnTypeAD != null ) { udtMap.put( columnTypeAD.getObjectID().toString(), columnTypeAD ); }
1:b4af7da:             }
1:b4af7da:         }
1:b4af7da: 
1:aad6057:         TypeDescriptor[]      paramTypes = aggInfo != null ?
1:aad6057:             new TypeDescriptor[] { aggInfo.getForType() } : routineInfo.getParameterTypes();
1:2209325:         if ( paramTypes != null )
1:2209325:         {
1:2209325:             int paramCount = paramTypes.length;
1:2209325:             for ( int i = 0; i < paramCount; i++ )
1:2209325:             {
1:2209325:                 AliasDescriptor       paramType = dd.getAliasDescriptorForUDT
1:2209325:                     ( tc, DataTypeDescriptor.getType( paramTypes[ i ] ) );
1:2209325: 
1:2209325:                 if ( paramType != null ) { udtMap.put( paramType.getObjectID().toString(), paramType ); }
1:2209325:             }
1:2209325:         }
1:2209325: 
1:2209325:         adjustUDTDependencies( lcc, dd, ad, addUdtMap, dropUdtMap );
1:2209325:     }
1:e126f58:     
1:eac0369: 	/**
1:eb38311: 	 * Mutable Boolean wrapper, initially false
1:eb38311: 	 */
1:801cf0d:     private static class SettableBoolean {
1:eb38311: 		boolean value;
1:eb38311: 
1:eb38311: 		SettableBoolean() {
1:eb38311: 			value = false;
1:eb38311: 		}
1:eb38311: 
1:eb38311: 		void set(boolean b) {
1:eb38311: 			value = b;
1:eb38311: 		}
1:eb38311: 
1:eb38311: 		boolean get() {
1:eb38311: 			return value;
1:eb38311: 		}
1:eb38311: 	}
1:2d2e717: }
1:e126f58: 
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:801cf0d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         TransactionController useTc;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             List<StatementPermission> requiredPermissionsList =
1:                 activation.getPreparedStatement().getRequiredPermissionsList();
1:                 for (StatementPermission statPerm : requiredPermissionsList)
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:      * @param roleDepAdded keeps track of whether a dependency on the
1:      *        current role has already been registered.
/////////////////////////////////////////////////////////////////////////
1:             List<StatementPermission> requiredPermissionsList =
1:                 activation.getPreparedStatement().getRequiredPermissionsList();
1: 
1:             if (requiredPermissionsList != null &&
1:                 ! requiredPermissionsList.isEmpty())
1:                 for (StatementPermission statPerm : requiredPermissionsList)
/////////////////////////////////////////////////////////////////////////
1:         if ( !dropWholeTable && addUdtMap.isEmpty() && dropUdtMap.isEmpty() ) {
1:             return;
1:         }
/////////////////////////////////////////////////////////////////////////
1:          HashMap<String, AliasDescriptor> addUdtMap,
1:          HashMap<String, AliasDescriptor> dropUdtMap
1:         if ( (addUdtMap.isEmpty()) && (dropUdtMap.isEmpty()) ) {
1:             return;
1:         }
1:         for (AliasDescriptor ad : addUdtMap.values())
1:         for (AliasDescriptor ad : dropUdtMap.values()) {
1:             DependencyDescriptor dep = new DependencyDescriptor(dependent, ad);
1:             dd.dropStoredDependency( dep, tc );
/////////////////////////////////////////////////////////////////////////
1: 
1:         HashMap<String,AliasDescriptor> addUdtMap =
1:                 new HashMap<String,AliasDescriptor>();
1: 
1:         HashMap<String,AliasDescriptor> dropUdtMap =
1:                 new HashMap<String,AliasDescriptor>();
1: 
1:         HashMap<String,AliasDescriptor> udtMap =
1:                 adding ? addUdtMap : dropUdtMap;
1: 
/////////////////////////////////////////////////////////////////////////
1:     private static class SettableBoolean {
commit:9f60172
/////////////////////////////////////////////////////////////////////////
1:         String currentUser = lcc.getCurrentUserId(activation);
1:         if (! currentUser.equals( dd.getAuthorizationDatabaseOwner()) )
/////////////////////////////////////////////////////////////////////////
1:                     permDesc = statPerm.getPermissionDescriptor(
1:                         currentUser, dd);
1: 
/////////////////////////////////////////////////////////////////////////
1:                                  ! ((StatementColumnPermission)statPerm).
1:                                    allColumnsCoveredByUserOrPUBLIC(
1:                                        currentUser, dd))) {
/////////////////////////////////////////////////////////////////////////
1:                         if (! permDesc.checkOwner(currentUser) ) {
1: 
1:                             dm.addDependency(dependent, permDesc,
/////////////////////////////////////////////////////////////////////////
1:                     if (! permDesc.checkOwner(currentUser))
/////////////////////////////////////////////////////////////////////////
1:                                 getPUBLIClevelColPermsDescriptor(
1:                                     currentUser, dd);
/////////////////////////////////////////////////////////////////////////
1:                                     allColumnsCoveredByUserOrPUBLIC(
1:                                         currentUser, dd)) {
/////////////////////////////////////////////////////////////////////////
1:         String currentUser = lcc.getCurrentUserId(activation);
/////////////////////////////////////////////////////////////////////////
0:             dd.getRoleGrantDescriptor(role, currentUser, dbo);
/////////////////////////////////////////////////////////////////////////
0:         String currentUser = lcc.getCurrentUserId(activation);
1:         if (! currentUser.equals(dbo))
/////////////////////////////////////////////////////////////////////////
1:                     permDesc = statPerm.
1:                         getPermissionDescriptor(currentUser, dd);
/////////////////////////////////////////////////////////////////////////
1:                                  ! ((StatementColumnPermission)statPerm).
1:                                      allColumnsCoveredByUserOrPUBLIC(
1:                                          currentUser, dd)) ) {
/////////////////////////////////////////////////////////////////////////
1:                         if (! permDesc.checkOwner(currentUser) ) {
1: 
/////////////////////////////////////////////////////////////////////////
1:                     if (! permDesc.checkOwner(currentUser) )
/////////////////////////////////////////////////////////////////////////
1:                             permDesc = statementColumnPermission.
1:                                 getPUBLIClevelColPermsDescriptor(
1:                                     currentUser, dd);
/////////////////////////////////////////////////////////////////////////
1:                                     allColumnsCoveredByUserOrPUBLIC(
1:                                         currentUser, dd)) {
commit:eb38311
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.dictionary.RoleGrantDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.StatementRolePermission;
1: import org.apache.derby.iapi.sql.dictionary.StatementRoutinePermission;
1: import org.apache.derby.iapi.sql.dictionary.RoleClosureIterator;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
/////////////////////////////////////////////////////////////////////////
1: 	 *
1: 	 *  For each required privilege, we now register a dependency on a role if
1: 	 *  that role was required to find an applicable privilege.
/////////////////////////////////////////////////////////////////////////
1: 		String dbo = dd.getAuthorizationDatabaseOwner();
0: 		String authId = lcc.getAuthorizationId();
1: 		SettableBoolean roleDepAdded = new SettableBoolean();
1: 
1: 			// Now, it is time to add into dependency system the FOREIGN
1: 			// constraint's dependency on REFERENCES privilege, or, if it is a
0: 			// CHECK constraint, any EXECUTE privileges. If the REFERENCES is
1: 			// revoked from the constraint owner, the constraint will get
1: 			// dropped automatically.
/////////////////////////////////////////////////////////////////////////
1: 					} else if (statPerm instanceof StatementSchemaPermission
0: 						    || statPerm instanceof StatementRolePermission) {
/////////////////////////////////////////////////////////////////////////
1: 					// available at the user level, PUBLIC or role level.
1: 						// No privilege exists for given user. The privilege
1: 						// has to exist at at PUBLIC level....
1: 
1: 						// .... or at the role level. Additionally, for column
1: 						// level privileges, even if *some* were available at
1: 						// the PUBLIC level others may be still be missing,
1: 						// hence the call in the test below to
1: 						// allColumnsCoveredByUserOrPUBLIC.
1: 						boolean roleUsed = false;
1: 
1: 						if (permDesc == null ||
1: 							((permDesc instanceof ColPermsDescriptor) &&
0: 									 !(((StatementColumnPermission)statPerm).
0: 										   allColumnsCoveredByUserOrPUBLIC
0: 										   (lcc.getAuthorizationId(), dd)))) {
1: 							roleUsed = true;
1: 							permDesc = findRoleUsage(activation, statPerm);
1: 						}
1: 
1: 						// If the user accessing the object is the owner of
1: 						// that object, then no privilege tracking is needed
1: 						// for the owner.
0: 						if (!(permDesc.checkOwner(lcc.getAuthorizationId()))) {
1: 							dm.addDependency(dependent, permDesc,
1: 											 lcc.getContextManager());
1: 
1: 							if (roleUsed) {
1: 								// We had to rely on role, so track that
1: 								// dependency, too.
1: 								trackRoleDependency
1: 									(activation, dependent, roleDepAdded);
1: 							}
1: 						}
1: 					} else
/////////////////////////////////////////////////////////////////////////
1: 							// The if statement above means we found a
1: 							// REFERENCES privilege at column level for the
1: 							// given authorizer. If this privilege doesn't
1: 							// cover all the column , then there has to exisit
1: 							// REFERENCES for the remaining columns at PUBLIC
1: 							// level or at role level.  Get that permission
1: 							// descriptor and save it in dependency system
1: 							StatementColumnPermission
1: 								statementColumnPermission = (
1: 									StatementColumnPermission)statPerm;
1: 							permDesc = statementColumnPermission.
0: 								getPUBLIClevelColPermsDescriptor
0: 								   (lcc.getAuthorizationId(), dd);
1: 							if (permDesc != null &&
1: 									permDesc.getObjectID() != null) {
1: 								// User did not have all required column
1: 								// permissions and at least one column is
1: 								// covered by PUBLIC.
1: 								dm.addDependency(dependent, permDesc,
1: 												 lcc.getContextManager());
1: 							}
1: 							// Possibly, the current role has also been relied
1: 							// upon.
1: 							if (!statementColumnPermission.
0: 									allColumnsCoveredByUserOrPUBLIC
0: 									    (lcc.getAuthorizationId(), dd)) {
1: 								// Role has been relied upon, so register a
1: 								// dependency.
1: 								trackRoleDependency
1: 									(activation, dependent, roleDepAdded);
1: 							}
1: 					if (!(statPerm instanceof StatementRoutinePermission)) {
1: 					} else {
1: 						// For EXECUTE privilege there may be several functions
1: 						// referenced in the constraint, so continue looking.
1: 
1: 
1: 	/**
1: 	 * We have determined that the statement permission described by statPerm
1: 	 * is not granted to the current user nor to PUBLIC, so it must be granted
1: 	 * to the current role or one of the roles inherited by the current
1: 	 * role. Find the relevant permission descriptor and return it.
1: 	 *
1: 	 * @return the permission descriptor that yielded the privilege
1: 	 */
1: 	private static PermissionsDescriptor findRoleUsage
1: 		(Activation activation,
1: 		 StatementPermission statPerm) throws StandardException {
1: 
1: 		LanguageConnectionContext lcc =
1: 			activation.getLanguageConnectionContext();
1: 		DataDictionary dd = lcc.getDataDictionary();
0: 		RoleGrantDescriptor rootGrant = null;
1: 		String role = lcc.getCurrentRoleId(activation);
0: 		String dbo = dd.getAuthorizationDatabaseOwner();
0: 		String authId = lcc.getAuthorizationId();
1: 		PermissionsDescriptor permDesc = null;
1: 
1: 		if (SanityManager.DEBUG) {
1: 			SanityManager.ASSERT(
1: 				role != null,
1: 				"Unexpected: current role is not set");
1: 		}
1: 
0: 		// determine how we got to be able use this role
0: 		rootGrant =
0: 			dd.getRoleGrantDescriptor(role, authId, dbo);
1: 
0: 		if (rootGrant == null) {
0: 			rootGrant = dd.getRoleGrantDescriptor(
0: 				role,
0: 				Authorizer.PUBLIC_AUTHORIZATION_ID,
0: 				dbo);
1: 		}
1: 
1: 		// If not found in current role, get transitive
1: 		// closure of roles granted to current role and
1: 		// iterate over it to see if permission has
1: 		// been granted to any of the roles the current
1: 		// role inherits.
1: 		RoleClosureIterator rci =
1: 			dd.createRoleClosureIterator
1: 			(activation.getTransactionController(),
1: 			 role, true /* inverse relation*/);
1: 
1: 		String graphGrant;
1: 		while (permDesc == null &&
1: 			   (graphGrant = rci.next()) != null) {
1: 			permDesc =
1: 				statPerm.getPermissionDescriptor
1: 				(graphGrant, dd);
1: 		}
1: 
1: 		if (SanityManager.DEBUG) {
1: 			SanityManager.ASSERT(
1: 				permDesc != null,
1: 				"Unexpected: Permission needs to be found via role");
1: 		}
1: 
1: 		return permDesc;
1: 	}
1: 
1: 
1: 	/**
1: 	 * The statement permission needed for dependent has been found to rely on
1: 	 * the current role. If not already done, register the dependency so that
1: 	 * if the current role (or any of the roles it inherits) is revoked (or
1: 	 * dropped), we can invalidate dependent.
1: 	 *
1: 	 * @param activation the current activation
1: 	 * @param dependent the view, constraint or trigger that is dependent on the
1: 	 *        current role for some privilege.
0: 	 * @param roleDepAdded keeps track of whether a dependeny on the
0: 	 *        current role has aleady been registered.
1: 	 */
1: 	private static void trackRoleDependency(Activation activation,
1: 											Dependent dependent,
1: 											SettableBoolean roleDepAdded)
1: 			throws StandardException {
1: 
1: 		// We only register the dependency once, lest
1: 		// we get duplicates in SYSDEPENDS (duplicates
1: 		// are not healthy..invalidating more than once
1: 		// fails for triggers at least).
1: 		if (!roleDepAdded.get()) {
1: 			LanguageConnectionContext lcc =
1: 				activation.getLanguageConnectionContext();
1: 			DataDictionary dd = lcc.getDataDictionary();
1: 			DependencyManager dm = dd.getDependencyManager();
1: 
1: 			String role =
1: 				lcc.getCurrentRoleId(activation);
1: 			RoleGrantDescriptor rgd =
1: 				dd.getRoleDefinitionDescriptor(role);
1: 
1: 			dm.addDependency
1: 				(dependent, rgd,
1: 				 lcc.getContextManager());
1: 			roleDepAdded.set(true);
1: 		}
1: 	}
1: 
/////////////////////////////////////////////////////////////////////////
1: 	 *  their privileges in the dependency system.
1: 	 *
1: 	 *  For each required privilege, we now register of a dependency on a role
1: 	 *  if that role was required to find an applicable privilege.
/////////////////////////////////////////////////////////////////////////
0: 		String dbo = dd.getAuthorizationDatabaseOwner();
0: 		String authId = lcc.getAuthorizationId();
1: 		SettableBoolean roleDepAdded = new SettableBoolean();
1: 
1: 		// If the Database Owner is creating this view/trigger, then no need to
1: 		// collect any privilege dependencies because the Database Owner can
1: 		// access any objects without any restrictions.
0: 		if (!authId.equals(dbo))
/////////////////////////////////////////////////////////////////////////
1: 					//Also, StatementRolePermission should not occur here.
1: 					if (statPerm instanceof StatementSchemaPermission ||
1: 						statPerm instanceof StatementRolePermission) {
1: 
1: 						if (SanityManager.DEBUG) {
1: 							if (statPerm instanceof StatementRolePermission) {
1: 								SanityManager.THROWASSERT(
1: 									"Unexpected StatementRolePermission");
1: 							}
1: 						}
1: 
1: 					}
1: 
1: 						//PUBLIC level... ,
1: 						permDesc = statPerm.getPermissionDescriptor(
1: 							Authorizer.PUBLIC_AUTHORIZATION_ID, dd);
1: 
1: 						boolean roleUsed = false;
1: 
1: 						// .. or at role level
1: 						if (permDesc == null ||
1: 								((permDesc instanceof ColPermsDescriptor) &&
0: 									 !(((StatementColumnPermission)statPerm).
0: 									 allColumnsCoveredByUserOrPUBLIC
0: 										   (lcc.getAuthorizationId(), dd)))) {
1: 							roleUsed = true;
1: 							permDesc = findRoleUsage(activation, statPerm);
1: 						}
1: 
0: 						if (!(permDesc.checkOwner(lcc.getAuthorizationId()))) {
1: 
1: 							// We had to rely on role, so track that
1: 							// dependency, too.
1: 							if (roleUsed) {
1: 								trackRoleDependency
1: 									(activation, dependent, roleDepAdded);
1: 							}
1: 						}
/////////////////////////////////////////////////////////////////////////
1: 							//level column privilege, if any, dependency of
1: 							//view is added into dependency system.
1: 
1: 							if (permDesc != null &&
1: 									permDesc.getObjectID() != null) {
1: 								// User did not have all required column
1: 								// permissions and at least one column is
1: 								// covered by PUBLIC.
0: 								dm.addDependency(dependent, permDesc,
1: 												 lcc.getContextManager());
1: 							} // else nothing found for PUBLIC..
1: 
1: 							// Has the the current role has also been relied
1: 							// upon?
1: 							if (!statementColumnPermission.
0: 									allColumnsCoveredByUserOrPUBLIC
0: 									    (lcc.getAuthorizationId(), dd)) {
1: 								trackRoleDependency
1: 									(activation, dependent, roleDepAdded);
1: 							}
/////////////////////////////////////////////////////////////////////////
1: 
1: 	/**
1: 	 * Mutable Boolean wrapper, initially false
1: 	 */
0: 	private class SettableBoolean {
1: 		boolean value;
1: 
1: 		SettableBoolean() {
1: 			value = false;
1: 		}
1: 
1: 		void set(boolean b) {
1: 			value = b;
1: 		}
1: 
1: 		boolean get() {
1: 			return value;
1: 		}
1: 	}
commit:8875d69
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.depend.ProviderInfo;
/////////////////////////////////////////////////////////////////////////
1: 	 *
1: 	 *  where as constraints only depend on REFERENCES privilege on a table
1: 	 *  (FOREIGN KEY constraints) or EXECUTE privileges on one or more
1: 	 *  functions (CHECK constraints).
1: 	 *
/////////////////////////////////////////////////////////////////////////
1: 	 *  @param providers set of providers for this constraint
1: 		Activation activation,
1: 		Dependent dependent,
1: 		UUID refTableUUID,
1: 		ProviderInfo[] providers)
1: 			throws StandardException
/////////////////////////////////////////////////////////////////////////
0: 			// Now, it is time to add into dependency system, constraint's
0: 			// dependency on REFERENCES or, if it is a CHECK constraint, any
0: 			// EXECUTE privileges. If the REFERENCES is revoked from the
0: 			// constraint owner, the constraint will get dropped automatically.
1: 
/////////////////////////////////////////////////////////////////////////
1: 					} else {
1: 						if (SanityManager.DEBUG) {
1: 							SanityManager.ASSERT(
1: 								statPerm instanceof StatementRoutinePermission,
1: 								"only StatementRoutinePermission expected");
1: 						}
1: 
1: 						// skip if this permission concerns a function not
1: 						// referenced by this constraint
1: 						StatementRoutinePermission rp =
1: 							(StatementRoutinePermission)statPerm;
1: 						if (!inProviderSet(providers, rp.getRoutineUUID())) {
1: 							continue;
1: 						}
1: 
1: 
0: 					// We know that we are working with a REFERENCES or EXECUTE
1: 					// privilege. Find all the PermissionDescriptors for this
1: 					// privilege and make constraint depend on it through
1: 					// dependency manager.  The REFERENCES privilege could be
1: 					// defined at the table level or it could be defined at
1: 					// individual column levels. In addition, individual column
1: 					// REFERENCES privilege could be available at the user
0: 					// level, PUBLIC or role level.  EXECUTE privilege could be
0: 					// available at the user or PUBLIC level.
/////////////////////////////////////////////////////////////////////////
1: 
0: 					if (statPerm instanceof StatementTablePermission) {
1: 						//We have found the REFERENCES privilege for all the
1: 						//columns in foreign key constraint and we don't
1: 						//need to go through the rest of the privileges
1: 						//for this sql statement.
1: 						break;
1: 					}
/////////////////////////////////////////////////////////////////////////
1: 
1: 	private boolean inProviderSet(ProviderInfo[] providers, UUID routineId) {
1: 		if (providers == null) {
1: 			return false;
1: 		}
1: 
1: 		for (int i = 0; i < providers.length; i++) {
1: 			if (providers[i].getObjectId().equals(routineId)) {
1: 				return true;
1: 			}
1: 		}
1: 		return false;
1: 	}
commit:ddae94a
/////////////////////////////////////////////////////////////////////////
1: 			CreateSchemaConstantAction csca
1: 				= new CreateSchemaConstantAction(schemaName, (String) null);
1: 				// DERBY-48: This operation creates the user's initial
1: 				// default schema and we don't want to hold a lock for
1: 				// SYSSCHEMAS for the duration of the user transaction
1: 				// since connection attempts may block, so we perform
1: 				// the creation in a nested transaction (if possible)
1: 				// so we can commit at once and release locks.
1: 				executeCAPreferSubTrans(csca, tc, activation);
1: 				// create the schema in the user transaction
/////////////////////////////////////////////////////////////////////////
1: 	private static void executeCAPreferSubTrans
1: 		(CreateSchemaConstantAction csca,
1: 		 TransactionController tc,
1: 		 Activation activation) throws StandardException {
1: 
0: 		TransactionController useTc    = null;
1: 		TransactionController nestedTc = null;
1: 
1: 		try {
0: 			nestedTc = tc.startNestedUserTransaction(false);
1: 			useTc = nestedTc;
1: 		} catch (StandardException e) {
1: 			if (SanityManager.DEBUG) {
1: 				SanityManager.THROWASSERT(
1: 					"Unexpected: not able to start nested transaction " +
1: 					"to auto-create schema", e);
1: 			}
1: 			useTc = tc;
1: 		}
1: 
1: 		// Try max twice: if nested transaction times out, try
1: 		// again in the outer transaction because it may be a
1: 		// self-lock, that is, the outer transaction may hold some
1: 		// lock(s) that make the nested transaction attempt to set
1: 		// a write lock time out.  Trying it again in the outer
1: 		// transaction will then succeed. If the reason is some
1: 		// other transaction barring us, trying again in the outer
1: 		// transaction will possibly time out again.
1: 		//
1: 		// Also, if creating a nested transaction failed, only try
1: 		// once in the outer transaction.
1: 		while (true) {
1: 			try {
1: 				csca.executeConstantAction(activation, useTc);
1: 			} catch (StandardException se) {
0: 				if (se.getMessageId().equals(SQLState.LOCK_TIMEOUT)) {
0: 					// We don't test for SQLState.DEADLOCK or
0: 					// .LOCK_TIMEOUT_LOG here because a) if it is a
0: 					// deadlock, it may be better to expose it, and b)
1: 					// LOCK_TIMEOUT_LOG happens when the app has set
1: 					// derby.locks.deadlockTrace=true, in which case we
0: 					// don't want to mask the timeout.  So in both the
0: 					// latter cases we just throw.
1: 					if (useTc == nestedTc) {
1: 
1: 						// clean up after use of nested transaction,
1: 						// then try again in outer transaction
1: 						useTc = tc;
1: 						nestedTc.destroy();
1: 						continue;
1: 					}
1: 				} else if (se.getMessageId()
1: 							   .equals(SQLState.LANG_OBJECT_ALREADY_EXISTS)) {
1: 					// Ignore "Schema already exists". Another thread has
1: 					// probably created it after we checked for it
1: 					break;
1: 				}
1: 
1: 				// We got an non-expected exception, either in
1: 				// the nested transaction or in the outer
1: 				// transaction; we had better pass that on
1: 				if (useTc == nestedTc) {
1: 					nestedTc.destroy();
1: 				}
1: 
1: 				throw se;
1: 			}
1: 			break;
1: 		}
1: 
1: 		// We either succeeded or got LANG_OBJECT_ALREADY_EXISTS.
1: 		// Clean up if we did this in a nested transaction.
1: 		if (useTc == nestedTc) {
1: 			nestedTc.commit();
1: 			nestedTc.destroy();
1: 		}
1: 	}
1: 
1: 
commit:9e04f69
/////////////////////////////////////////////////////////////////////////
1: 			if (activation.getLanguageConnectionContext().
1: 					isInitialDefaultSchema(schemaName)) {
0: 				// DERBY-48: This operation creates the user's initial default
0: 				// schema and we don't want to hold a lock for SYSSCHEMAS for
0: 				// the duration of the user transaction, so we perform the
0: 				// creation in a nested transaction if possible.
0: 				TransactionController useTc    = null;
0: 				TransactionController nestedTc = null;
0: 					nestedTc = tc.startNestedUserTransaction(false);
0: 					useTc = nestedTc;
0: 				} catch (StandardException e) {
0: 					if (SanityManager.DEBUG) {
0: 						SanityManager.THROWASSERT(
0: 							"Unexpected: not able to start nested transaction " +
0: 							"to auto-create schema", e);
1: 					}
0: 					useTc = tc;
1: 				}
0: 				// Try max twice: if nested transaction times out, try
0: 				// again in the outer transaction because it may be a
0: 				// self-lock, that is, the outer transaction may hold some
0: 				// lock(s) that make the nested transaction attempt to set
0: 				// a write lock time out.  Trying it again in the outer
0: 				// transaction will then succeed. If the reason is some
0: 				// other transaction barring us, trying again in the outer
0: 				// transaction will possibly time out again.
1: 				//
0: 				// Also, if creating a nested transaction failed, only try
0: 				// once in the outer transaction.
0: 				while (true) {
1: 					try {
0: 						csca.executeConstantAction(activation, useTc);
1: 					} catch (StandardException se) {
0: 						if (se.getMessageId().equals(SQLState.LOCK_TIMEOUT)) {
0: 							// We don't test for SQLState.DEADLOCK or
0: 							// .LOCK_TIMEOUT_LOG here because a) if it is a
0: 							// deadlock, it may be better to expose it, and b)
0: 							// LOCK_TIMEOUT_LOG happens when the app has set
0: 							// derby.locks.deadlockTrace=true, in which case we
0: 							// don't want to mask the timeout.  So in both the
0: 							// latter cases we just throw.
0: 							if (useTc == nestedTc) {
1: 
0: 								// clean up after use of nested transaction,
0: 								// then try again in outer transaction
0: 								useTc = tc;
0: 								nestedTc.destroy();
1: 								continue;
1: 							}
0: 						} else if (se.getMessageId()
1: 									   .equals(SQLState.LANG_OBJECT_ALREADY_EXISTS)) {
1: 							// Ignore "Schema already exists". Another thread has
1: 							// probably created it after we checked for it
1: 							break;
1: 
0: 						// We got an non-expected exception, either in
0: 						// the nested transaction or in the outer
0: 						// transaction; we had better pass that on
0: 						if (useTc == nestedTc) {
0: 							nestedTc.destroy();
1: 						}
1: 
1: 						throw se;
1: 					}
1: 					break;
1: 				}
1: 
0: 				// We either succeeded or got LANG_OBJECT_ALREADY_EXISTS.
0: 				// Clean up if we did this in a nested transaction.
0: 				if (useTc == nestedTc) {
0: 					nestedTc.commit();
0: 					nestedTc.destroy();
1: 				}
1: 			} else {
0: 				// create the schema in the user transaction always
1: 				try {
1: 					csca.executeConstantAction(activation);
1: 				} catch (StandardException se) {
1: 					if (se.getMessageId()
1: 					} else {
1: 						throw se;
commit:12988c7
/////////////////////////////////////////////////////////////////////////
0: 						if (permDesc != null &&
0: 							!(permDesc.checkOwner(lcc.getAuthorizationId())))
/////////////////////////////////////////////////////////////////////////
0: 						if (permDesc != null &&
0: 							!(permDesc.checkOwner(lcc.getAuthorizationId())))
commit:1a63d73
/////////////////////////////////////////////////////////////////////////
0: 					} else if (statPerm instanceof StatementSchemaPermission) { 
1: 					}
commit:4d8deb6
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.reference.Property;
0: import org.apache.derby.iapi.services.property.PropertyUtil;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
/////////////////////////////////////////////////////////////////////////
1: 	 * @param activation activation
1: 	 * @param schemaName name of the schema
/////////////////////////////////////////////////////////////////////////
1: 		TransactionController tc = activation.
1: 			getLanguageConnectionContext().getTransactionExecute();
1: 
0:             CreateSchemaConstantAction csca
0: 			// DERBY-48: This operation creates a schema and we don't
0: 			// want to hold a lock for SYSSCHEMAS for the duration of
0: 			// the user transaction, so we perform the creation in a
0: 			// nested transaction if possible.
0: 			TransactionController useTc    = null;
0: 			TransactionController nestedTc = null;
1: 
0: 			try {
0: 				nestedTc = tc.startNestedUserTransaction(false);
0: 				useTc = nestedTc;
0: 			} catch (StandardException e) {
0: 				if (SanityManager.DEBUG) {
0: 					SanityManager.THROWASSERT(
0: 						"Unexpected: not able to start nested transaction " +
0: 						"to auto-create schema", e);
1: 				}
0: 				useTc = tc;
1: 			}
1: 
0: 			// Try max twice: if nested transaction times out, try
0: 			// again in the outer transaction because it may be a
0: 			// self-lock, that is, the outer transaction may hold some
0: 			// lock(s) that make the nested transaction attempt to set
0: 			// a write lock time out.  Trying it again in the outer
0: 			// transaction will then succeed. If the reason is some
0: 			// other transaction barring us, trying again in the outer
0: 			// transaction will possibly time out again.
1: 			//
0: 			// Also, if creating a nested transaction failed, only try
0: 			// once in the outer transaction.
0: 			while (true) {
0: 				try {
0: 					csca.executeConstantAction(activation, useTc);
0: 				} catch (StandardException se) {
0: 					if (se.getMessageId().equals(SQLState.LOCK_TIMEOUT)) {
0: 						// We don't test for SQLState.DEADLOCK or
0: 						// .LOCK_TIMEOUT_LOG here because a) if it is a
0: 						// deadlock, it may be better to expose it, and b)
0: 						// LOCK_TIMEOUT_LOG happens when the app has set
0: 						// derby.locks.deadlockTrace=true, in which case we
0: 						// don't want to mask the timeout.  So in both the
0: 						// latter cases we just throw.
0: 						if (useTc == nestedTc) {
1: 
0: 							// clean up after use of nested transaction,
0: 							// then try again in outer transaction
0: 							useTc = tc;
0: 							nestedTc.destroy();
1: 							continue;
1: 						}
0: 					} else if (se.getMessageId()
0: 							.equals(SQLState.LANG_OBJECT_ALREADY_EXISTS)) {
0: 						// Ignore "Schema already exists". Another thread has
0: 						// probably created it after we checked for it
0: 						break;
1: 					}
1: 
0: 					// We got an non-expected exception, either in
0: 					// the nested transaction or in the outer
0: 					// transaction; we had better pass that on
0: 					if (useTc == nestedTc) {
0: 						nestedTc.destroy();
1: 					}
1: 
0: 					throw se;
1: 				}
0: 				break;
1: 			}
1: 
0: 			// We either succeeded or got LANG_OBJECT_ALREADY_EXISTS.
0: 			// Clean up if we did this in a nested transaction.
0: 			if (useTc == nestedTc) {
0: 				nestedTc.commit();
0: 				nestedTc.destroy();
1: 			}
1: 
1: 
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:71c8e86
/////////////////////////////////////////////////////////////////////////
1:         HashMap<String,AliasDescriptor> addUdtMap = new HashMap<String,AliasDescriptor>();
1:         HashMap<String,AliasDescriptor> dropUdtMap = new HashMap<String,AliasDescriptor>();
1:         HashSet<String> addColumnNames = new HashSet<String>();
1:         HashSet<String> dropColumnNames = new HashSet<String>();
/////////////////////////////////////////////////////////////////////////
0:         HashMap<String,AliasDescriptor>               addUdtMap = new HashMap<String,AliasDescriptor>();
0:         HashMap<String,AliasDescriptor>               dropUdtMap = new HashMap<String,AliasDescriptor>();
0:         HashMap<String,AliasDescriptor>               udtMap = adding ? addUdtMap : dropUdtMap;
commit:aad6057
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.catalog.types.AggregateAliasInfo;
/////////////////////////////////////////////////////////////////////////
1:         RoutineAliasInfo      routineInfo = null;
1:         AggregateAliasInfo  aggInfo = null;
1:         
1: 		case AliasInfo.ALIAS_TYPE_AGGREGATE_AS_CHAR:
1:             aggInfo = (AggregateAliasInfo) ad.getAliasInfo();
0:             break;
1: 
1:             routineInfo = (RoutineAliasInfo) ad.getAliasInfo();
1:         TypeDescriptor        rawReturnType = aggInfo != null ?
1:             aggInfo.getReturnType() : routineInfo.getReturnType();
/////////////////////////////////////////////////////////////////////////
1:         TypeDescriptor[]      paramTypes = aggInfo != null ?
1:             new TypeDescriptor[] { aggInfo.getForType() } : routineInfo.getParameterTypes();
commit:b4af7da
/////////////////////////////////////////////////////////////////////////
1:         // table functions can have udt columns. track those dependencies.
1:         if ( (rawReturnType != null) && rawReturnType.isRowMultiSet() )
1:         {
1:             TypeDescriptor[] columnTypes = rawReturnType.getRowTypes();
1:             int columnCount = columnTypes.length;
1: 
1:             for ( int i = 0; i < columnCount; i++ )
1:             {
1:                 AliasDescriptor       columnTypeAD = dd.getAliasDescriptorForUDT
1:                     ( tc, DataTypeDescriptor.getType( columnTypes[ i ] ) );
1: 
1:                 if ( columnTypeAD != null ) { udtMap.put( columnTypeAD.getObjectID().toString(), columnTypeAD ); }
1:             }
1:         }
1: 
commit:a4cbe6f
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.dictionary.StatementGenericPermission;
/////////////////////////////////////////////////////////////////////////
1: 			// CHECK constraint, any EXECUTE or USAGE privileges. If the REFERENCES is
/////////////////////////////////////////////////////////////////////////
1: 						    || statPerm instanceof StatementRolePermission
1:                                || statPerm instanceof StatementGenericPermission ) {
/////////////////////////////////////////////////////////////////////////
1: 					// We know that we are working with a REFERENCES, EXECUTE, or USAGE
1: 					// level, PUBLIC or role level.  EXECUTE and USAGE privileges could be
commit:2209325
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.catalog.TypeDescriptor;
1: import org.apache.derby.catalog.types.RoutineAliasInfo;
/////////////////////////////////////////////////////////////////////////
1:         adjustUDTDependencies( lcc, dd, td, addUdtMap, dropUdtMap );
1:     }
1:     /**
1:      * Add and drop dependencies of an object on UDTs.
1:      *
1:      * @param lcc Interpreter's state variable for this session.
1:      * @param dd Metadata
1:      * @param dependent Object which depends on UDT
1:      * @param addUdtMap Map of UDTs for which dependencies should be added
1:      * @param dropUdtMap Map of UDT for which dependencies should be dropped
1:      */
1:     private   void    adjustUDTDependencies
1:         (
1:          LanguageConnectionContext  lcc,
1:          DataDictionary             dd,
1:          Dependent                  dependent,
0:          HashMap                    addUdtMap,
0:          HashMap                    dropUdtMap
1:          )
1:         throws StandardException
1:     {
1: 		TransactionController tc = lcc.getTransactionExecute();
1:         DependencyManager     dm = dd.getDependencyManager();
1:         ContextManager        cm = lcc.getContextManager();
/////////////////////////////////////////////////////////////////////////
1:             dm.addDependency( dependent, ad, cm );
/////////////////////////////////////////////////////////////////////////
0:             DependencyDescriptor dependency = new DependencyDescriptor( dependent, ad );
1:     /**
1:      * Add and drop dependencies of a routine on UDTs.
1:      *
1:      * @param lcc Interpreter's state variable for this session.
1:      * @param dd Metadata
1:      * @param ad Alias descriptor for the routine
1:      * @param adding True if we are adding dependencies, false if we're dropping them
1:      */
1:     protected   void    adjustUDTDependencies
1:         (
1:          LanguageConnectionContext  lcc,
1:          DataDictionary             dd,
1:          AliasDescriptor            ad,
1:          boolean                    adding
1:          )
1:         throws StandardException
1:     {
1:         // nothing to do if this is not a routine
1:         switch ( ad.getAliasType() )
1:         {
1: 		case AliasInfo.ALIAS_TYPE_PROCEDURE_AS_CHAR:
1: 		case AliasInfo.ALIAS_TYPE_FUNCTION_AS_CHAR:
0:             break;
1: 
1:         default: return;
1:         }
1:         
1: 		TransactionController tc = lcc.getTransactionExecute();
0:         RoutineAliasInfo      aliasInfo = (RoutineAliasInfo) ad.getAliasInfo();
0:         HashMap               addUdtMap = new HashMap();
0:         HashMap               dropUdtMap = new HashMap();
0:         HashMap               udtMap = adding ? addUdtMap : dropUdtMap;
0:         TypeDescriptor        rawReturnType = aliasInfo.getReturnType();
1: 
1:         if ( rawReturnType != null )
1:         {
1:             AliasDescriptor       returnTypeAD = dd.getAliasDescriptorForUDT
1:                 ( tc, DataTypeDescriptor.getType( rawReturnType ) );
1: 
1:             if ( returnTypeAD != null ) { udtMap.put( returnTypeAD.getObjectID().toString(), returnTypeAD ); }
1:         }
1: 
0:         TypeDescriptor[]      paramTypes = aliasInfo.getParameterTypes();
1:         if ( paramTypes != null )
1:         {
1:             int paramCount = paramTypes.length;
1:             for ( int i = 0; i < paramCount; i++ )
1:             {
1:                 AliasDescriptor       paramType = dd.getAliasDescriptorForUDT
1:                     ( tc, DataTypeDescriptor.getType( paramTypes[ i ] ) );
1: 
1:                 if ( paramType != null ) { udtMap.put( paramType.getObjectID().toString(), paramType ); }
1:             }
1:         }
1: 
1:         adjustUDTDependencies( lcc, dd, ad, addUdtMap, dropUdtMap );
1:     }
commit:b8c6110
/////////////////////////////////////////////////////////////////////////
1:          DataDictionary             dd,
1:          TableDescriptor            td,
1:          ColumnInfo[]               columnInfos,
1:          boolean                    dropWholeTable
1:         if ( (!dropWholeTable) && (columnInfos == null) ) { return; }
1:         int changedColumnCount = columnInfos == null ? 0 : columnInfos.length;
/////////////////////////////////////////////////////////////////////////
1:         // nothing to do if there are no changed columns of udt type
1:         // and this is not a DROP TABLE command
0:         if ( (!dropWholeTable) && (addUdtMap.size() == 0) && (dropUdtMap.size() == 0) ) { return; }
/////////////////////////////////////////////////////////////////////////
1:             // ha, it is a UDT.
1:             if ( dropWholeTable ) { dropUdtMap.put( key, ad ); }
1:             else
1:             {
1:                 if ( addUdtMap.get( key ) != null ) { addUdtMap.remove( key ); }
1:                 if ( dropUdtMap.get( key ) != null ) { dropUdtMap.remove( key ); }
1:             }
commit:e126f58
/////////////////////////////////////////////////////////////////////////
1: import java.util.HashMap;
1: import java.util.HashSet;
1: import org.apache.derby.catalog.AliasInfo;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.dictionary.AliasDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptorList;
1: import org.apache.derby.iapi.sql.dictionary.DependencyDescriptor;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.types.DataTypeDescriptor;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Adjust dependencies of a table on ANSI UDTs. We only add one dependency
1:      * between a table and a UDT. If the table already depends on the UDT, we don't add
1:      * a redundant dependency.
1:      */
1:     protected   void    adjustUDTDependencies
1:         (
1:          LanguageConnectionContext  lcc,
1:          DataDictionary     dd,
1:          TableDescriptor    td,
0:          ColumnInfo[]        columnInfos
1:          )
1:         throws StandardException
1:     {
0:         if ( columnInfos == null ) { return; }
1: 
1: 		TransactionController tc = lcc.getTransactionExecute();
1: 
0:         int changedColumnCount = columnInfos.length;
0:         HashMap addUdtMap = new HashMap();
0:         HashMap dropUdtMap = new HashMap();
0:         HashSet addColumnNames = new HashSet();
0:         HashSet dropColumnNames = new HashSet();
1: 
1:         // first find all of the new ansi udts which the table must depend on
1:         // and the old ones which are candidates for removal
1:         for ( int i = 0; i < changedColumnCount; i++ )
1:         {
1:             ColumnInfo ci = columnInfos[ i ];
1: 
1:             // skip this column if it is not a UDT
1:             AliasDescriptor ad = dd.getAliasDescriptorForUDT( tc, columnInfos[ i ].dataType );
1:             if ( ad == null ) { continue; }
1: 
1:             String key = ad.getObjectID().toString();
1: 
1:             if ( ci.action == ColumnInfo.CREATE )
1:             {
1:                 addColumnNames.add( ci.name);
1: 
1:                 // no need to add the descriptor if it is already on the list
1:                 if ( addUdtMap.get( key ) != null ) { continue; }
1: 
1:                 addUdtMap.put( key, ad );
1:             }
1:             else if ( ci.action == ColumnInfo.DROP )
1:             {
1:                 dropColumnNames.add( ci.name );
1:                 dropUdtMap.put( key, ad );
1:             }
1:         }
1: 
0:         // nothing to do if there are no columns of udt type
0:         if ( (addUdtMap.size() == 0) && (dropUdtMap.size() == 0) ) { return; }
1: 
1:         //
1:         // Now prune from the add list all udt descriptors for which we already have dependencies.
1:         // These are the udts for old columns. This supports the ALTER TABLE ADD COLUMN
1:         // case.
1:         //
1:         // Also prune from the drop list add udt descriptors which will still be
1:         // referenced by the remaining columns.
1:         //
1:         ColumnDescriptorList cdl = td.getColumnDescriptorList();
1:         int totalColumnCount = cdl.size();
1: 
1:         for ( int i = 0; i < totalColumnCount; i++ )
1:         {
1:             ColumnDescriptor cd = cdl.elementAt( i );
1: 
1:             // skip columns that are being added and dropped. we only want the untouched columns
1:             if (
1:                 addColumnNames.contains( cd.getColumnName() ) ||
1:                 dropColumnNames.contains( cd.getColumnName() )
1:                 ) { continue; }
1: 
1:             // nothing to do if the old column isn't a UDT
1:             AliasDescriptor ad = dd.getAliasDescriptorForUDT( tc, cd.getType() );
1:             if ( ad == null ) { continue; }
1: 
1:             String key = ad.getObjectID().toString();
1: 
0:             // ha, it is a UDT. remove the UDT from the list of dependencies to
0:             // add and drop
0:             if ( addUdtMap.get( key ) != null ) { addUdtMap.remove( key ); }
0:             if ( dropUdtMap.get( key ) != null ) { dropUdtMap.remove( key ); }
1:         }
1: 
1:         // again, nothing to do if there are no columns of udt type
0:         if ( (addUdtMap.size() == 0) && (dropUdtMap.size() == 0) ) { return; }
1: 
1:         DependencyManager   dm = dd.getDependencyManager();
1:         ContextManager      cm = lcc.getContextManager();
1: 
1:         // add new dependencies
0:         Iterator            addIterator = addUdtMap.values().iterator();
0:         while( addIterator.hasNext() )
1:         {
0:             AliasDescriptor ad = (AliasDescriptor) addIterator.next();
1: 
0:             dm.addDependency( td, ad, cm );
1:         }
1: 
1:         // drop dependencies that are orphaned
0:         Iterator            dropIterator = dropUdtMap.values().iterator();
0:         while( dropIterator.hasNext() )
1:         {
0:             AliasDescriptor ad = (AliasDescriptor) dropIterator.next();
1: 
0:             DependencyDescriptor dependency = new DependencyDescriptor( td, ad );
1: 
0:             dd.dropStoredDependency( dependency, tc );
1:         }
1:     }
1: 
1:     
commit:3c09be7
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.catalog.DependableFinder;
1: import org.apache.derby.iapi.services.context.ContextManager;
1: import org.apache.derby.iapi.sql.depend.Provider;
1: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.DefaultDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Add dependencies of a column on providers. These can arise if a generated column depends
1:      * on a user created function.
1:      */
1:     protected   void    addColumnDependencies
1:         (
1:          LanguageConnectionContext  lcc,
0:          DataDictionary     dd,
0:          TableDescriptor    td,
1:          ColumnInfo         ci
1:          )
1:         throws StandardException
1:     {
1:         ProviderInfo[]  providers = ci.providers;
1: 
1:         if ( providers != null )
1:         {
0:             DependencyManager   dm = dd.getDependencyManager();
0:             ContextManager      cm = lcc.getContextManager();
1:             int                         providerCount = providers.length;
1:             ColumnDescriptor    cd = td.getColumnDescriptor( ci.name );
1:             DefaultDescriptor   defDesc = cd.getDefaultDescriptor( dd );
1: 
1:             for ( int px = 0; px < providerCount; px++ )
1:             {
1:                 ProviderInfo            pi = providers[ px ];
1:                 DependableFinder    finder = pi.getDependableFinder();
1:                 UUID                        providerID = pi.getObjectId();
1:                 Provider                    provider = (Provider) finder.getDependable( dd, providerID );
1: 
1:                 dm.addDependency( defDesc, provider, cm );
1:             }   // end loop through providers
1:         }
1:     }
1: 
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:ceaf7df
/////////////////////////////////////////////////////////////////////////
1: 			nestedTc = tc.startNestedUserTransaction(false, true);
commit:c9ef166
/////////////////////////////////////////////////////////////////////////
1: 				if (se.isLockTimeout()) {
1:                     // We don't test for SQLState.DEADLOCK because if it is a
1:                     // deadlock, it may be better to expose it.  Just go ahead
1:                     // and throw it.
1: 
1:                     if (!se.getMessageId().equals(SQLState.LOCK_TIMEOUT_LOG)) {
1:                         // In case of a LOCK_TIMEOUT_LOG also just throw it.
0:                         // LOCK_TIMEOUT_LOG happens when the app has set
0:                         // derby.locks.deadlockTrace=true, in which case we
1:                         // don't want to mask the timeout. 
1: 
0:                         if (useTc == nestedTc) {
1: 
0:                             // clean up after use of nested transaction,
0:                             // then try again in outer transaction
0:                             useTc = tc;
0:                             nestedTc.destroy();
1:                             continue;
1:                         }
1:                     }
1: 
commit:439d1e8
/////////////////////////////////////////////////////////////////////////
1: 		//If the Database Owner is creating this constraint, then no need to 
1: 		//collect any privilege dependencies because the Database Owner can   
1: 		//access any objects without any restrictions
0: 		if (!(lcc.getAuthorizationId().equals(dd.getAuthorizationDatabaseOwner())))
/////////////////////////////////////////////////////////////////////////
0: 		//If the Database Owner is creating this view/triiger, then no need to  
0: 		//collect any privilege dependencies because the Database Owner can  
0: 		//access any objects without any restrictions
0: 		if (!(lcc.getAuthorizationId().equals(dd.getAuthorizationDatabaseOwner())))
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:e4fa8cb
/////////////////////////////////////////////////////////////////////////
1: abstract class DDLConstantAction implements ConstantAction
commit:1e2aae0
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.catalog.UUID;
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.sql.Activation;
1: import org.apache.derby.iapi.sql.depend.DependencyManager;
1: import org.apache.derby.iapi.sql.depend.Dependent;
commit:9cd47dc
/////////////////////////////////////////////////////////////////////////
commit:2d2e717
/////////////////////////////////////////////////////////////////////////
0: import java.util.Iterator;
1: import java.util.List;
1: 
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.conn.Authorizer;
1: import org.apache.derby.iapi.sql.dictionary.ColPermsDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.PermissionsDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.ReferencedKeyConstraintDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.StatementColumnPermission;
1: import org.apache.derby.iapi.sql.dictionary.StatementPermission;
0: import org.apache.derby.iapi.sql.dictionary.StatementRoutinePermission;
1: import org.apache.derby.iapi.sql.dictionary.StatementSchemaPermission;
1: import org.apache.derby.iapi.sql.dictionary.StatementTablePermission;
/////////////////////////////////////////////////////////////////////////
1: 	
1: 	
1: 	/**
1: 	 *	This method saves dependencies of constraints on privileges in the  
1: 	 *  dependency system. It gets called by CreateConstraintConstantAction.
1: 	 *  Views and triggers and constraints run with definer's privileges. If 
1: 	 *  one of the required privileges is revoked from the definer, the 
1: 	 *  dependent view/trigger/constraint on that privilege will be dropped 
1: 	 *  automatically. In order to implement this behavior, we need to save 
1: 	 *  view/trigger/constraint dependencies on required privileges in the 
1: 	 *  dependency system. Following method accomplishes that part of the 
1: 	 *  equation for constraints only. The dependency collection for 
1: 	 *  constraints is not same as for views and triggers and hence 
1: 	 *  constraints are handled by this special method.
1: 	 * 	Views and triggers can depend on many different kind of privileges
1: 	 *  where as constraints only depend on REFERENCES privilege on a table.
1: 	 *  Another difference is only one view or trigger can be defined by a
1: 	 *  sql statement and hence all the dependencies collected for the sql
1: 	 *  statement apply to the view or trigger in question. As for constraints,
1: 	 *  one sql statement can defined multiple constraints and hence the 
1: 	 *  all the privileges required by the statement are not necessarily
1: 	 *  required by all the constraints defined by that sql statement. We need
1: 	 *  to identify right privileges for right constraints for a given sql
1: 	 *  statement. Because of these differences between constraints and views
1: 	 *  (and triggers), there are 2 different methods in this class to save
1: 	 *  their privileges in the dependency system.
1: 	 *   
1: 	 *  @param activation The execution environment for this constant action.
1: 	 *  @param dependent Make this object depend on required privileges
1: 	 *  @param refTableUUID Make sure we are looking for REFERENCES privilege 
1: 	 * 		for right table
1: 	 *
1: 	 * @exception StandardException		Thrown on failure
1: 	 */
1: 	protected void storeConstraintDependenciesOnPrivileges(
0: 			Activation activation, Dependent dependent, UUID refTableUUID)
1: 	throws StandardException
1: 	{
1: 		LanguageConnectionContext lcc = activation.getLanguageConnectionContext();
1: 		DataDictionary dd = lcc.getDataDictionary();
1: 		DependencyManager dm = dd.getDependencyManager();
1: 		
0: 		//If a dba is creating this constraint, then no need to collect any 
0: 		//privilege dependencies because a dba can access any objects without 
0: 		//any restrictions
0: 		if (!(lcc.getAuthorizationId().equals(dd.getAuthorizationDBA())))
1: 		{
1: 			PermissionsDescriptor permDesc;
0: 			//Now, it is time to add into dependency system, constraint's 
0: 			//dependency on REFERENCES privilege. If the REFERENCES privilege is 
0: 			//revoked from the constraint owner, the constraint will get 
0: 			//dropped automatically.
0: 			List requiredPermissionsList = activation.getPreparedStatement().getRequiredPermissionsList();
1: 			if (requiredPermissionsList != null && ! requiredPermissionsList.isEmpty())
1: 			{
0: 				for(Iterator iter = requiredPermissionsList.iterator();iter.hasNext();)
1: 				{
0: 					StatementPermission statPerm = (StatementPermission) iter.next();
1: 					//First check if we are dealing with a Table or 
1: 					//Column level privilege. All the other privileges
1: 					//are not required for a foreign key constraint.
1: 					if (statPerm instanceof StatementTablePermission)
1: 					{//It is a table/column level privilege
1: 						StatementTablePermission statementTablePermission = 
1: 							(StatementTablePermission) statPerm;
1: 						//Check if we are dealing with REFERENCES privilege.
1: 						//If not, move on to the next privilege in the
1: 						//required privileges list
1: 						if (statementTablePermission.getPrivType() != Authorizer.REFERENCES_PRIV)
1: 							continue;
1: 						//Next check is this REFERENCES privilege is 
1: 						//on the same table as referenced by the foreign
1: 						//key constraint? If not, move on to the next
1: 						//privilege in the required privileges list
1: 						if (!statementTablePermission.getTableUUID().equals(refTableUUID))
1: 							continue;
0: 					} else if (statPerm instanceof StatementSchemaPermission 
0: 							|| statPerm instanceof StatementRoutinePermission)
1: 						continue;
1: 
0: 					//We know that we are working with a REFERENCES 
0: 					//privilege. Find all the PermissionDescriptors for
0: 					//this privilege and make constraint depend on it
0: 					//through dependency manager.
0: 					//The REFERENCES privilege could be defined at the
0: 					//table level or it could be defined at individual
0: 					//column levels. In addition, individual column
0: 					//REFERENCES privilege could be available at the
0: 					//user level or PUBLIC level.
0: 					permDesc = statPerm.getPermissionDescriptor(lcc.getAuthorizationId(), dd);				
1: 					if (permDesc == null) 
1: 					{
0: 						//No REFERENCES privilege exists for given 
0: 						//authorizer at table or column level.
0: 						//REFERENCES privilege has to exist at at PUBLIC level
1: 						permDesc = statPerm.getPermissionDescriptor(Authorizer.PUBLIC_AUTHORIZATION_ID, dd);
0: 						if (!(permDesc.checkOwner(lcc.getAuthorizationId())))
1: 							dm.addDependency(dependent, permDesc, lcc.getContextManager());
0: 					} else 
1: 						//if the object on which permission is required is owned by the
1: 						//same user as the current user, then no need to keep that
1: 						//object's privilege dependency in the dependency system
0: 					if (!(permDesc.checkOwner(lcc.getAuthorizationId())))
1: 					{
1: 						dm.addDependency(dependent, permDesc, lcc.getContextManager());
1: 						if (permDesc instanceof ColPermsDescriptor)
1: 						{
0: 							//The if statement above means we found a
0: 							//REFERENCES privilege at column level for
0: 							//the given authorizer. If this privilege
0: 							//doesn't cover all the column , then there 
0: 							//has to exisit REFERENCES for the remaining
0: 							//columns at PUBLIC level. Get that permission
0: 							//descriptor and save it in dependency system
1: 							StatementColumnPermission statementColumnPermission = (StatementColumnPermission) statPerm;
0: 							permDesc = statementColumnPermission.getPUBLIClevelColPermsDescriptor(lcc.getAuthorizationId(), dd);
1: 							//Following if checks if some column level privileges
1: 							//exist only at public level. If so, then the public
1: 							//level column privilege dependency is added
1: 							//into the dependency system
0: 							if (permDesc != null)
1: 								dm.addDependency(dependent, permDesc, lcc.getContextManager());	           																
1: 						}
1: 					}
0: 					//We have found the REFERENCES privilege for all the
0: 					//columns in foreign key constraint and we don't 
0: 					//need to go through the rest of the privileges
0: 					//for this sql statement.
0: 					break;																										
1: 				}
1: 			}
1: 		}
1: 		
1: 	}	
1: 	
1: 	/**
1: 	 *	This method saves dependencies of views and triggers on privileges in  
1: 	 *  the dependency system. It gets called by CreateViewConstantAction
1: 	 *  and CreateTriggerConstantAction. Views and triggers and constraints
1: 	 *  run with definer's privileges. If one of the required privileges is
1: 	 *  revoked from the definer, the dependent view/trigger/constraint on
1: 	 *  that privilege will be dropped automatically. In order to implement 
1: 	 *  this behavior, we need to save view/trigger/constraint dependencies 
1: 	 *  on required privileges in the dependency system. Following method 
1: 	 *  accomplishes that part of the equation for views and triggers. The
1: 	 *  dependency collection for constraints is not same as for views and
1: 	 *  triggers and hence constraints are not covered by this method.
1: 	 *  Views and triggers can depend on many different kind of privileges
1: 	 *  where as constraints only depend on REFERENCES privilege on a table.
1: 	 *  Another difference is only one view or trigger can be defined by a
1: 	 *  sql statement and hence all the dependencies collected for the sql
1: 	 *  statement apply to the view or trigger in question. As for constraints,
1: 	 *  one sql statement can defined multiple constraints and hence the 
1: 	 *  all the privileges required by the statement are not necessarily
1: 	 *  required by all the constraints defined by that sql statement. We need
1: 	 *  to identify right privileges for right constraints for a given sql
1: 	 *  statement. Because of these differences between constraints and views
1: 	 *  (and triggers), there are 2 different methods in this class to save
1: 	 *  their privileges in the dependency system.  
1: 	 *
1: 	 *  @param activation The execution environment for this constant action.
1: 	 *  @param dependent Make this object depend on required privileges
1: 	 *
1: 	 * @exception StandardException		Thrown on failure
1: 	 */
1: 	protected void storeViewTriggerDependenciesOnPrivileges(
1: 			Activation activation, Dependent dependent)
1: 	throws StandardException
1: 	{
1: 		LanguageConnectionContext lcc = activation.getLanguageConnectionContext();
1: 		DataDictionary dd = lcc.getDataDictionary();
1: 		DependencyManager dm = dd.getDependencyManager();
1: 		
0: 		//If a dba is creating this view/triiger, then no need to collect any 
0: 		//privilege dependencies because a dba can access any objects without 
0: 		//any restrictions
0: 		if (!(lcc.getAuthorizationId().equals(dd.getAuthorizationDBA())))
1: 		{
1: 			PermissionsDescriptor permDesc;
0: 			List requiredPermissionsList = activation.getPreparedStatement().getRequiredPermissionsList();
1: 			if (requiredPermissionsList != null && ! requiredPermissionsList.isEmpty())
1: 			{
0: 				for(Iterator iter = requiredPermissionsList.iterator();iter.hasNext();)
1: 				{
0: 					StatementPermission statPerm = (StatementPermission) iter.next();
1: 					//The schema ownership permission just needs to be checked 
1: 					//at object creation time, to see if the object creator has 
1: 					//permissions to create the object in the specified schema. 
1: 					//But we don't need to add schema permission to list of 
1: 					//permissions that the object is dependent on once it is 
1: 					//created.
0: 					if (statPerm instanceof StatementSchemaPermission)
1: 						continue;
1: 					//See if we can find the required privilege for given authorizer?
0: 					permDesc = statPerm.getPermissionDescriptor(lcc.getAuthorizationId(), dd);				
1: 					if (permDesc == null)//privilege not found for given authorizer 
1: 					{
1: 						//The if condition above means that required privilege does 
1: 						//not exist at the user level. The privilege has to exist at 
0: 						//PUBLIC level.
1: 						permDesc = statPerm.getPermissionDescriptor(Authorizer.PUBLIC_AUTHORIZATION_ID, dd);
1: 						//If the user accessing the object is the owner of that 
1: 						//object, then no privilege tracking is needed for the
1: 						//owner.
0: 						if (!(permDesc.checkOwner(lcc.getAuthorizationId())))
1: 							dm.addDependency(dependent, permDesc, lcc.getContextManager());
1: 						continue;
1: 					}
1: 					//if the object on which permission is required is owned by the
1: 					//same user as the current user, then no need to keep that
1: 					//object's privilege dependency in the dependency system
0: 					if (!(permDesc.checkOwner(lcc.getAuthorizationId())))
1: 					{
1: 						dm.addDependency(dependent, permDesc, lcc.getContextManager());	           							
1: 						if (permDesc instanceof ColPermsDescriptor)
1: 						{
1: 							//For a given table, the table owner can give privileges
1: 							//on some columns at individual user level and privileges
1: 							//on some columns at PUBLIC level. Hence, when looking for
1: 							//column level privileges, we need to look both at user
1: 							//level as well as PUBLIC level(only if user level column
1: 							//privileges do not cover all the columns accessed by this
1: 							//object). We have finished adding dependency for user level 
1: 							//columns, now we are checking if some required column 
1: 							//level privileges are at PUBLIC level.
1: 							//A specific eg of a view
1: 							//user1
1: 							//create table t11(c11 int, c12 int);
1: 							//grant select(c11) on t1 to user2;
1: 							//grant select(c12) on t1 to PUBLIC;
1: 							//user2
1: 							//create view v1 as select c11 from user1.t11 where c12=2;
1: 							//For the view above, there are 2 column level privilege 
1: 							//depencies, one for column c11 which exists directly
1: 							//for user2 and one for column c12 which exists at PUBLIC level.
1: 							StatementColumnPermission statementColumnPermission = (StatementColumnPermission) statPerm;
0: 							permDesc = statementColumnPermission.getPUBLIClevelColPermsDescriptor(lcc.getAuthorizationId(), dd);
1: 							//Following if checks if some column level privileges
1: 							//exist only at public level. If so, then the public
0: 							//level column privilege dependency of view is added
0: 							//into dependency system.
0: 							if (permDesc != null)
1: 								dm.addDependency(dependent, permDesc, lcc.getContextManager());	           							
1: 						}
1: 					}
1: 				}
1: 			}
1: 			
1: 		}
1: 	}
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.execute.DDLConstantAction
0: 
0:    Copyright 1998, 2004 The Apache Software Foundation or its licensors, as applicable.
0: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
0: 
1:       http://www.apache.org/licenses/LICENSE-2.0
0: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:9e5097f
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.execute
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
1:  */
0: 
1: package org.apache.derby.impl.sql.execute;
0: 
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.services.io.FormatIdUtil;
0: import org.apache.derby.iapi.services.io.Formatable;
0: import org.apache.derby.iapi.services.io.StoredFormatIds;
0: 
1: import org.apache.derby.iapi.error.StandardException;
0: 
1: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: 
0: import org.apache.derby.iapi.sql.dictionary.DataDescriptorGenerator;
1: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionaryContext;
1: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
0: 
0: import org.apache.derby.iapi.sql.depend.Dependency;
0: import org.apache.derby.iapi.sql.depend.Dependent;
0: import org.apache.derby.iapi.sql.depend.DependencyManager;
0: 
0: import org.apache.derby.iapi.sql.Activation;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: 
1: import org.apache.derby.iapi.sql.execute.ConstantAction;
0: 
1: import org.apache.derby.iapi.store.access.ConglomerateController;
1: import org.apache.derby.iapi.store.access.TransactionController;
0: 
0: import org.apache.derby.catalog.UUID;
0: 
1: /**
1:  * Abstract class that has actions that are across
1:  * all DDL actions.
1:  *
0:  * @author jamie
1:  */
0: public abstract class DDLConstantAction extends GenericConstantAction
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
0: 	//TransactionController 		tc;
0: 	//protected LanguageConnectionContext 	lcc;
0: 	//DataDescriptorGenerator 	ddg;
0: 	//DataDictionary 				dd;
0: 	//DependencyManager			dm;
0: 
1: 	/**
0: 	 * Set up the "environment variables" for this
0: 	 * constant action.
1: 	 */
0: 	//protected void setEnvironmentVariables(Activation activation)
0: 	//{
0: 		/* find the language context.
0: 		 * NOTE: The activation could be null if
0: 		 * we are creating the SPSs for the metadata
0: 		 * queries in the background, so we get
0: 		 * the lcc from the ContextService.
1: 		 */
0: 		//lcc = (activation == null) ?
0: 		//		(LanguageConnectionContext)
0: 		//			ContextService.getContext(LanguageConnectionContext.CONTEXT_ID):
0: 		//		activation.getLanguageConnectionContext();
0: 
0: 
0:         // Get the current transaction controller
0:         //tc = lcc.getTransactionExecute();
0: 
0: 		//dd = lcc.getDataDictionary();
0: 		//dm = dd.getDependencyManager();
0: 		//ddg = dd.getDataDescriptorGenerator();
0: //	}
0: 
1: 	/**
1: 	 * Get the schema descriptor for the schemaid.
1: 	 *
1: 	 * @param dd the data dictionary
1: 	 * @param schemaId the schema id
1: 	 * @param statementType string describing type of statement for error
1: 	 *	reporting.  e.g. "ALTER STATEMENT"
1: 	 *
1: 	 * @return the schema descriptor
1: 	 *
1: 	 * @exception StandardException if schema is system schema
1: 	 */
1: 	static SchemaDescriptor getAndCheckSchemaDescriptor(
1: 						DataDictionary		dd,
1: 						UUID				schemaId,
1: 						String				statementType)
1: 		throws StandardException
1: 	{
1: 		SchemaDescriptor sd = dd.getSchemaDescriptor(schemaId, null);
1: 		return sd;
0: 	}
0: 
1: 	/**
1: 	 * Get the schema descriptor in the creation of an object in
1: 	   the passed in schema.
1: 	 *
1: 	 * @param dd the data dictionary
0: 	   @param activation activation
0: 	   @param schemaName name of the schema
1: 	 *
1: 	 * @return the schema descriptor
1: 	 *
1: 	 * @exception StandardException if the schema does not exist
1: 	 */
1: 	static SchemaDescriptor getSchemaDescriptorForCreate(
1: 						DataDictionary		dd,
1: 						Activation activation,
1: 						String schemaName)
1: 		throws StandardException
1: 	{
0: 		TransactionController tc = activation.getLanguageConnectionContext().getTransactionExecute();
1: 		SchemaDescriptor sd = dd.getSchemaDescriptor(schemaName, tc, false);
0: 
1: 		if (sd == null || sd.getUUID() == null) {
0: 			ConstantAction csca = new CreateSchemaConstantAction(schemaName, (String) null);
0: 			csca.executeConstantAction(activation);
0: 
1: 			sd = dd.getSchemaDescriptor(schemaName, tc, true);
0: 		}
0: 
1: 		return sd;
0: 	}
0: 
1: 	/**
1: 	 * Lock the table in exclusive or share mode to prevent deadlocks.
1: 	 *
1: 	 * @param tc						The TransactionController
1: 	 * @param heapConglomerateNumber	The conglomerate number for the heap.
1: 	 * @param exclusiveMode				Whether or not to lock the table in exclusive mode.
1: 	 *
0: 	 * @return Nothing.
1: 	 *
1: 	 * @exception StandardException if schema is system schema
1: 	 */
1: 	final void lockTableForDDL(TransactionController tc,
1: 						 long heapConglomerateNumber, boolean exclusiveMode)
1: 		throws StandardException
1: 	{
1: 		ConglomerateController cc;
0: 
1: 		cc = tc.openConglomerate(
1: 					heapConglomerateNumber,
1:                     false,
1: 					(exclusiveMode) ?
1: 						(TransactionController.OPENMODE_FORUPDATE | 
1: 							TransactionController.OPENMODE_FOR_LOCK_ONLY) :
1: 						TransactionController.OPENMODE_FOR_LOCK_ONLY,
1: 			        TransactionController.MODE_TABLE,
1:                     TransactionController.ISOLATION_SERIALIZABLE);
1: 		cc.close();
0: 	}
0: 
1: 	/**
0: 	 * Does this constant action modify the passed in table
0: 	 * uuid?  By modify we mean add or drop things tied to
0: 	 * this table (e.g. index, trigger, constraint).  Things
0: 	 * like views or spses that reference this table don't
0: 	 * count.
1: 	 *
0: 	 * @param tableId the table id
1:  	 *
0: 	 * @exception StandardException on error
1: 	 */
0: 	public boolean modifiesTableId(UUID tableId) throws StandardException
1: 	{
0: 		// by default, assume we don't modify it
0: 		return false;
0: 	}
0: 
0: 
1: 	protected String constructToString(
1: 						String				statementType,
1: 						String              objectName)
1: 	{
1: 		// Do not put this under SanityManager.DEBUG - it is needed for
1: 		// error reporting.
0: 
1: 		return statementType + objectName;
0: 	}
0: }
0: 
author:David Van Couvering
-------------------------------------------------------------------------------
commit:f6123ee
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:0e6f38b
/////////////////////////////////////////////////////////////////////////
0:             ConstantAction csca 
0:                 = new CreateSchemaConstantAction(schemaName, (String) null);
0:             try {
0:                 csca.executeConstantAction(activation);
0:             } catch (StandardException se) {
0:                 if (se.getMessageId()
0:                     .equals(SQLState.LANG_OBJECT_ALREADY_EXISTS)) {
0:                     // Ignore "Schema already exists". Another thread has 
0:                     // probably created it after we checked for it
0:                 } else {
0:                     throw se;
0:                 }
0:             }
0:             
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.execute
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.sql.execute;
0: 
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.services.io.FormatIdUtil;
0: import org.apache.derby.iapi.services.io.Formatable;
0: import org.apache.derby.iapi.services.io.StoredFormatIds;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: 
0: import org.apache.derby.iapi.sql.dictionary.DataDescriptorGenerator;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionaryContext;
0: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
0: 
0: import org.apache.derby.iapi.sql.depend.Dependency;
0: import org.apache.derby.iapi.sql.depend.Dependent;
0: import org.apache.derby.iapi.sql.depend.DependencyManager;
0: 
0: import org.apache.derby.iapi.sql.Activation;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.iapi.sql.execute.ConstantAction;
0: 
0: import org.apache.derby.iapi.store.access.ConglomerateController;
0: import org.apache.derby.iapi.store.access.TransactionController;
0: 
0: import org.apache.derby.catalog.UUID;
0: 
0: /**
0:  * Abstract class that has actions that are across
0:  * all DDL actions.
0:  *
0:  * @author jamie
0:  */
0: public abstract class DDLConstantAction extends GenericConstantAction
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
0: 	//TransactionController 		tc;
0: 	//protected LanguageConnectionContext 	lcc;
0: 	//DataDescriptorGenerator 	ddg;
0: 	//DataDictionary 				dd;
0: 	//DependencyManager			dm;
0: 
0: 	/**
0: 	 * Set up the "environment variables" for this
0: 	 * constant action.
0: 	 */
0: 	//protected void setEnvironmentVariables(Activation activation)
0: 	//{
0: 		/* find the language context.
0: 		 * NOTE: The activation could be null if
0: 		 * we are creating the SPSs for the metadata
0: 		 * queries in the background, so we get
0: 		 * the lcc from the ContextService.
0: 		 */
0: 		//lcc = (activation == null) ?
0: 		//		(LanguageConnectionContext)
0: 		//			ContextService.getContext(LanguageConnectionContext.CONTEXT_ID):
0: 		//		activation.getLanguageConnectionContext();
0: 
0: 
0:         // Get the current transaction controller
0:         //tc = lcc.getTransactionExecute();
0: 
0: 		//dd = lcc.getDataDictionary();
0: 		//dm = dd.getDependencyManager();
0: 		//ddg = dd.getDataDescriptorGenerator();
0: //	}
0: 
0: 	/**
0: 	 * Get the schema descriptor for the schemaid.
0: 	 *
0: 	 * @param dd the data dictionary
0: 	 * @param schemaId the schema id
0: 	 * @param statementType string describing type of statement for error
0: 	 *	reporting.  e.g. "ALTER STATEMENT"
0: 	 *
0: 	 * @return the schema descriptor
0: 	 *
0: 	 * @exception StandardException if schema is system schema
0: 	 */
0: 	static SchemaDescriptor getAndCheckSchemaDescriptor(
0: 						DataDictionary		dd,
0: 						UUID				schemaId,
0: 						String				statementType)
0: 		throws StandardException
0: 	{
0: 		SchemaDescriptor sd = dd.getSchemaDescriptor(schemaId, null);
0: 		return sd;
0: 	}
0: 
0: 	/**
0: 	 * Get the schema descriptor in the creation of an object in
0: 	   the passed in schema.
0: 	 *
0: 	 * @param dd the data dictionary
0: 	   @param activation activation
0: 	   @param schemaName name of the schema
0: 	 *
0: 	 * @return the schema descriptor
0: 	 *
0: 	 * @exception StandardException if the schema does not exist
0: 	 */
0: 	static SchemaDescriptor getSchemaDescriptorForCreate(
0: 						DataDictionary		dd,
0: 						Activation activation,
0: 						String schemaName)
0: 		throws StandardException
0: 	{
0: 		TransactionController tc = activation.getLanguageConnectionContext().getTransactionExecute();
0: 		SchemaDescriptor sd = dd.getSchemaDescriptor(schemaName, tc, false);
0: 
0: 		if (sd == null || sd.getUUID() == null) {
0: 			ConstantAction csca = new CreateSchemaConstantAction(schemaName, (String) null);
0: 			csca.executeConstantAction(activation);
0: 
0: 			sd = dd.getSchemaDescriptor(schemaName, tc, true);
0: 		}
0: 
0: 		return sd;
0: 	}
0: 
0: 	/**
0: 	 * Lock the table in exclusive or share mode to prevent deadlocks.
0: 	 *
0: 	 * @param tc						The TransactionController
0: 	 * @param heapConglomerateNumber	The conglomerate number for the heap.
0: 	 * @param exclusiveMode				Whether or not to lock the table in exclusive mode.
0: 	 *
0: 	 * @return Nothing.
0: 	 *
0: 	 * @exception StandardException if schema is system schema
0: 	 */
0: 	final void lockTableForDDL(TransactionController tc,
0: 						 long heapConglomerateNumber, boolean exclusiveMode)
0: 		throws StandardException
0: 	{
0: 		ConglomerateController cc;
0: 
0: 		cc = tc.openConglomerate(
0: 					heapConglomerateNumber,
0:                     false,
0: 					(exclusiveMode) ?
0: 						(TransactionController.OPENMODE_FORUPDATE | 
0: 							TransactionController.OPENMODE_FOR_LOCK_ONLY) :
0: 						TransactionController.OPENMODE_FOR_LOCK_ONLY,
0: 			        TransactionController.MODE_TABLE,
0:                     TransactionController.ISOLATION_SERIALIZABLE);
0: 		cc.close();
0: 	}
0: 
0: 	/**
0: 	 * Does this constant action modify the passed in table
0: 	 * uuid?  By modify we mean add or drop things tied to
0: 	 * this table (e.g. index, trigger, constraint).  Things
0: 	 * like views or spses that reference this table don't
0: 	 * count.
0: 	 *
0: 	 * @param tableId the table id
0:  	 *
0: 	 * @exception StandardException on error
0: 	 */
0: 	public boolean modifiesTableId(UUID tableId) throws StandardException
0: 	{
0: 		// by default, assume we don't modify it
0: 		return false;
0: 	}
0: 
0: 
0: 	protected String constructToString(
0: 						String				statementType,
0: 						String              objectName)
0: 	{
0: 		// Do not put this under SanityManager.DEBUG - it is needed for
0: 		// error reporting.
0: 
0: 		return statementType + objectName;
0: 	}
0: }
0: 
============================================================================