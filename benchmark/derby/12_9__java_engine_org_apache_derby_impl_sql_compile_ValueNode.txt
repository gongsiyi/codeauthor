2:eac0369: /*
1:d861c23: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.compile.ValueNode
1:345de35: 
1:2d37fd6:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2d37fd6:    contributor license agreements.  See the NOTICE file distributed with
1:2d37fd6:    this work for additional information regarding copyright ownership.
1:2d37fd6:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2d37fd6:    (the "License"); you may not use this file except in compliance with
1:2d37fd6:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:345de35: 
12:eac0369:  */
34:eac0369: 
1:eac0369: package	org.apache.derby.impl.sql.compile;
1:eac0369: 
1:f33fbaf: import java.util.List;
1:ef158f2: import org.apache.derby.iapi.error.StandardException;
1:ef158f2: import org.apache.derby.iapi.reference.SQLState;
1:ef158f2: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1:3bb140c: import org.apache.derby.iapi.services.context.ContextManager;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:ef158f2: import org.apache.derby.iapi.sql.compile.Optimizable;
1:ef158f2: import org.apache.derby.iapi.sql.compile.TypeCompiler;
1:ef158f2: import org.apache.derby.iapi.store.access.Qualifier;
1:ef158f2: import org.apache.derby.iapi.types.DataTypeDescriptor;
1:ef158f2: import org.apache.derby.iapi.types.DataValueFactory;
1:9ed7c4d: import org.apache.derby.iapi.types.StringDataValue;
1:ef158f2: import org.apache.derby.iapi.types.TypeId;
1:ef158f2: import org.apache.derby.iapi.util.JBitSet;
1:ef158f2: 
10:eac0369: /**
1:eac0369:  * A ValueNode is an abstract class for all nodes that can represent data
1:eac0369:  * values, that is, constants, columns, and expressions.
27:eac0369:  *
1:eac0369:  */
1:eac0369: 
1:eac0369: public abstract class ValueNode extends QueryTreeNode
15:eac0369: {
1:ef158f2:     /**
1:ef158f2:      * The data type for this node.
1:ef158f2:      */
1:ed82406: 	private DataTypeDescriptor	dataTypeServices;
1:d6c2047: 
1:eac0369: 	// Whether or not additional predicates have been created from this one.
1:eac0369: 	boolean	transformed;
1:ef158f2: 
1:eac0369: 	/*
1:eac0369: 	** Constructor for untyped ValueNodes, for example, untyped NULLs
1:eac0369: 	** and parameter nodes.
1:eac0369: 	**
1:eac0369: 	** Binding will replace all untyped ValueNodes with typed ValueNodes
1:eac0369: 	** when it figures out what their types should be.
1:eac0369: 	*/
1:3bb140c:     ValueNode(ContextManager cm) {
1:3bb140c:         super(cm);
15:eac0369: 	}
1:f63b7da:     
1:f63b7da:     /**
1:ef158f2:      * Set this node's type from type components.
1:ef158f2:      */
1:ef158f2:     final void setType(TypeId typeId,
1:ef158f2:             boolean isNullable,
1:ef158f2:             int maximumWidth)
1:ef158f2:        throws StandardException
1:ef158f2:        
1:ef158f2:        {
1:3bb140c:         setType(new DataTypeDescriptor(typeId, isNullable, maximumWidth));
1:ef158f2:        }
1:ef158f2: 
1:ef158f2:     /**
1:ef158f2:      * Set this node's type from type components.
1:ef158f2:      */
1:ef158f2:     final void setType(TypeId typeId,
1:ef158f2:             int precision, int scale,
1:ef158f2:             boolean isNullable,
1:ef158f2:             int maximumWidth)
1:ef158f2:        throws StandardException
1:ef158f2:     {
2:ef158f2:         setType(
2:ef158f2:                 new DataTypeDescriptor(
1:3bb140c:                             typeId,
1:ef158f2:                             precision,
1:ef158f2:                             scale,
2:ef158f2:                             isNullable,
2:ef158f2:                             maximumWidth
2:ef158f2:                         )
1:ef158f2:                     );   
1:ef158f2:     }
1:ef158f2: 
1:ef158f2: 	/**
1:eac0369: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
1:eac0369: 	 * for how this should be done for tree printing.
1:eac0369: 	 *
1:eac0369: 	 * @return	This object as a String
1:eac0369: 	 */
1:eac0369: 
1:3bb140c:     @Override
1:eac0369: 	public String toString()
1:eac0369: 	{
2:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			return "dataTypeServices: " +
1:eac0369: 				( ( dataTypeServices != null) ?
1:eac0369: 						dataTypeServices.toString() : "null" ) + "\n" +
1:eac0369: 				super.toString();
1:eac0369: 		}
3:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return "";
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the DataTypeServices from this ValueNode.
1:eac0369: 	 *
1:eac0369: 	 * @return	The DataTypeServices from this ValueNode.  This
1:eac0369: 	 *		may be null if the node isn't bound yet.
1:eac0369: 	 */
1:3bb140c:     DataTypeDescriptor getTypeServices()
1:eac0369: 	{
1:eac0369: 		return dataTypeServices;
1:eac0369: 	}
1:ed82406:     
1:ed82406:     /**
1:ed82406:      * Set the nullability of this value.
1:ed82406:      * @throws StandardException 
1:ed82406:      */
1:ed82406:     public void setNullability(boolean nullability) throws StandardException
1:ed82406:     {
1:ed82406:         setType(getTypeServices().getNullabilityType(nullability));
1:ed82406:     }
1:b25481f:     
1:b25481f:     /**
1:b25481f:      * Set the collation type and derivation of this node based upon
1:b25481f:      * the collation information in the passed in type. Note that the
1:b25481f:      * base type of this node is not changed (e.g. INTEGER), only its
1:b25481f:      * collation settings. This may result in a different object being
1:b25481f:      * returned from getTypeServices().
1:b25481f:      * 
1:b25481f:      * @param collationInfoType Type to take collation type and derivation from.
1:b25481f:      * @throws StandardException Error setting type.
1:b25481f:      */
1:b25481f:     public void setCollationInfo(DataTypeDescriptor collationInfoType)
1:b25481f:     throws StandardException
1:b25481f:     {
1:b25481f:         setCollationInfo(collationInfoType.getCollationType(),
1:b25481f:                 collationInfoType.getCollationDerivation());
1:b25481f:     }
1:b25481f: 
1:b25481f:     /**
1:b25481f:      * Set the collation type and derivation of this node based upon
1:b25481f:      * the collation information passed in.
1:b25481f:      * This may result in a different object being
1:b25481f:      * returned from getTypeServices().
1:b25481f:      * 
1:b25481f:      * @param collationType Collation type
1:b25481f:      * @param collationDerivation Collation derivation
1:b25481f:      * @throws StandardException Error setting type
1:b25481f:      */
1:b25481f:     public void setCollationInfo(int collationType, int collationDerivation)
1:b25481f:         throws StandardException
1:b25481f:     {
1:b25481f:         setType(getTypeServices().getCollatedType(
1:b25481f:                 collationType, collationDerivation));
1:b25481f:     }
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the TypeId from this ValueNode.
1:eac0369: 	 *
1:eac0369: 	 * @return	The TypeId from this ValueNode.  This
1:eac0369: 	 *		may be null if the node isn't bound yet.
1:eac0369: 	 */
1:3bb140c:     TypeId getTypeId() throws StandardException
1:eac0369: 	{
1:ef158f2:         DataTypeDescriptor dtd = getTypeServices();
1:ef158f2:         if (dtd != null)
1:ef158f2:             return dtd.getTypeId();
1:ef158f2: 		return null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Return the DataValueFactory
1:eac0369: 	*/
1:eac0369: 	protected final DataValueFactory getDataValueFactory() {
1:eac0369: 		return getLanguageConnectionContext().getDataValueFactory();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:ef158f2: 	 * Get the TypeCompiler from this ValueNode, based on its TypeId
1:ef158f2:      * using getTypeId().
1:eac0369: 	 *
1:eac0369: 	 * @return	This ValueNode's TypeCompiler
1:eac0369: 	 *
1:eac0369: 	 */
1:3bb140c:     final TypeCompiler getTypeCompiler() throws StandardException
1:eac0369: 	{
1:ef158f2: 		return getTypeCompiler(getTypeId());
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set the DataTypeServices for this ValueNode.  This method is
1:eac0369: 	 * overridden in ParameterNode.
1:eac0369: 	 *
1:eac0369: 	 * @param dataTypeServices	The DataTypeServices to set in this
1:eac0369: 	 *				ValueNode
1:eac0369: 	 */
1:eac0369: 
1:3bb140c:     void setType(DataTypeDescriptor dataTypeServices) throws StandardException
1:eac0369: 	{
1:2732872:         // bind the type in case it is a user defined type. this will create a dependency on the udt.
1:2732872:         if ( dataTypeServices != null )
1:2732872:         {
1:2732872:             dataTypeServices = bindUserType( dataTypeServices );
1:2732872:         }
1:eac0369: 
1:2732872: 		this.dataTypeServices = dataTypeServices;
1:2732872:         
1:d6c2047:         // create a dependency on this type if it is an ANSI UDT
1:d6c2047:         if ( dataTypeServices != null ) { createTypeDependency( dataTypeServices ); }
1:eac0369: 	}
1:eac0369: 	
1:eac0369: 	/**
1:9ed7c4d: 	 * Set the collation based upon the current schema with derivation
1:9ed7c4d: 	 * type implicit.
1:9ed7c4d: 	 * 
1:9ed7c4d: 	 * @throws StandardException
1:9ed7c4d: 	 */
1:9ed7c4d: 	protected final void setCollationUsingCompilationSchema()
1:9ed7c4d: 	throws StandardException {
1:9ed7c4d: 		setCollationUsingCompilationSchema(
1:9ed7c4d: 				StringDataValue.COLLATION_DERIVATION_IMPLICIT);
1:9ed7c4d: 	}	
1:9ed7c4d: 	
1:9ed7c4d: 	/**
1:f63b7da: 	 * There are many subclasses of ValueNode where we want the 
1:f63b7da: 	 * DataTypeDescriptor of the node to have the same collation type as the 
1:f63b7da: 	 * compilation schema's collation type. For that purpose, this method in 
1:f63b7da: 	 * the baseclass here can be utilized by the subclasses. In addition, the
1:f63b7da: 	 * subclasses can pass the collationDerivation that they expect the
1:f63b7da: 	 * DataTypeDescriptor to have.
1:f63b7da: 	 * 
1:f63b7da: 	 * @param collationDerivation This can be 
1:f63b7da: 	 * StringDataValue#COLLATION_DERIVATION_IMPLICIT
1:f63b7da: 	 * StringDataValue#COLLATION_DERIVATION_NONE
1:f63b7da: 	 * StringDataValue#COLLATION_DERIVATION_EXPLICIT
1:f63b7da: 	 * 
1:f63b7da: 	 * @throws StandardException
1:f63b7da: 	 */
1:9ed7c4d: 	protected final void setCollationUsingCompilationSchema(int collationDerivation)
1:f63b7da: 	throws StandardException {
1:b25481f:         setCollationInfo(
1:b25481f:                 getSchemaDescriptor(null, false).getCollationType(),
1:b25481f:                 collationDerivation);
1:f63b7da: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the source for this ValueNode.
1:eac0369: 	 *
1:e9ec322: 	 * @return	The source of this ValueNode, null if this node
1:e9ec322:      * is not sourced by a column.
1:eac0369: 	 */
1:eac0369: 
1:3bb140c:     ResultColumn getSourceResultColumn()
1:eac0369: 	{
1:eac0369: 		return null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Mark this predicate has having been transformed (other predicates
1:eac0369: 	 * were generated from it).  This will help us with ensure that the
1:eac0369: 	 * predicate does not get calculated into the selectivity multiple
1:eac0369: 	 * times.
1:eac0369: 	 */
1:eac0369: 	void setTransformed()
1:eac0369: 	{
1:eac0369: 		transformed = true;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** 
1:eac0369: 	 * Return whether or not this predicate has been transformed.
1:eac0369: 	 *
1:eac0369: 	 * @return Whether or not this predicate has been transformed.
1:eac0369: 	 */
1:eac0369: 	boolean getTransformed()
1:eac0369: 	{
1:eac0369: 		return transformed;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	
1:09c2697:     ValueNode bindExpression(
1:71c8e86:             FromList fromList, SubqueryList subqueryList, List<AggregateNode> aggregates)
6:eac0369: 		throws StandardException
1:eac0369: 	{
1:09c2697:         return bindExpression(fromList, subqueryList, aggregates, false);
1:eac0369: 	}
1:eac0369: 	
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Bind this expression.  This is a place-holder method - it should never
1:eac0369: 	 * be called.
1:eac0369: 	 *
1:eac0369: 	 * @param fromList			The FROM list to use for binding
1:eac0369: 	 * @param subqueryList		The SubqueryList we are building as we hit
1:eac0369: 	 *							SubqueryNodes.
1:09c2697:      * @param aggregates        The aggregate list being built as we find AggregateNodes
1:eac0369: 	 *
1:eac0369: 	 * @return	The new top of the expression tree.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException	Thrown on error
1:eac0369: 	 */
1:eac0369: 
1:3bb140c:     ValueNode bindExpression(FromList fromList,
1:3bb140c:                              SubqueryList subqueryList,
1:3bb140c:                              List<AggregateNode> aggregates,
1:3bb140c:                              boolean forQueryRewrite) throws StandardException
1:eac0369: 	{
1:eac0369: 		/* There are a bizillion classes which extend ValueNode.  Here is info
1:eac0369: 		 * on some of the classes that bindExpression() should not be called on
1:eac0369: 		 * and why:
1:eac0369: 		 *	o  BaseColumnNodes should only appear under the ResultColumnList
1:eac0369: 		 *     in the FromBaseTable.  They are created/bound when binding the
1:eac0369: 		 *     FromBaseTable.
1:eac0369: 		 */
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
2:eac0369: 			SanityManager.ASSERT(false, 
1:eac0369: 						"bindExpression() not expected to be called on a " + 
1:eac0369: 						this.getClass().toString());
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return this;
1:eac0369: 	}
1:eac0369: 
1:568cbf1: 	/**
1:dbed020: 	 * Generate a SQL-&gt;Java-&gt;SQL conversion tree above the current node
1:eac0369: 	 * and bind the new nodes individually.
1:eac0369: 	 * This is useful when doing comparisons, built-in functions, etc. on
1:eac0369: 	 * java types which have a direct mapping to system built-in types.
1:eac0369: 	 *
1:eac0369: 	 * @return ValueNode	The new tree.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException	Thrown on error
1:eac0369: 	 */
1:3bb140c:     ValueNode genSQLJavaSQLTree()
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:ef158f2: 			SanityManager.ASSERT(getTypeId() != null,
1:eac0369: 				"genSQLJavaSQLTree() only expected to be called on a bound node");
1:ef158f2: 			SanityManager.ASSERT(getTypeId().userType(),
1:eac0369: 				"genSQLJavaSQLTree() only expected to be called on user types");
1:eac0369: 		}
1:eac0369: 
1:3bb140c:         final ContextManager cm = getContextManager();
1:3bb140c:         JavaValueNode stjvn = new SQLToJavaValueNode(this, cm);
1:eac0369: 
1:3bb140c:         ValueNode jtsvn = new JavaToSQLValueNode(stjvn, cm);
1:eac0369: 
1:d861c23:         DataTypeDescriptor  resultType;
1:d861c23:         if ( (getTypeServices() != null) && getTypeId().userType() ) { resultType = getTypeServices(); }
1:d861c23:         else { resultType = DataTypeDescriptor.getSQLDataTypeDescriptor(stjvn.getJavaTypeName()); }
1:d861c23: 
1:d861c23: 		jtsvn.setType( resultType );
1:d861c23: 
1:eac0369: 		return jtsvn;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Preprocess an expression tree.  We do a number of transformations
1:eac0369: 	 * here (including subqueries, IN lists, LIKE and BETWEEN) plus
1:eac0369: 	 * subquery flattening.
1:eac0369: 	 * NOTE: This is done before the outer ResultSetNode is preprocessed.
1:eac0369: 	 *
1:eac0369: 	 * @param	numTables			Number of tables in the DML Statement
1:eac0369: 	 * @param	outerFromList		FromList from outer query block
1:eac0369: 	 * @param	outerSubqueryList	SubqueryList from outer query block
1:eac0369: 	 * @param	outerPredicateList	PredicateList from outer query block
1:eac0369: 	 *
1:eac0369: 	 * @return		The modified expression
1:eac0369: 	 *
4:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     ValueNode preprocess(int numTables,
1:eac0369: 								FromList outerFromList,
1:eac0369: 								SubqueryList outerSubqueryList,
1:eac0369: 								PredicateList outerPredicateList) 
1:eac0369: 					throws StandardException
1:eac0369: 	{
1:eac0369: 		return this;
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:568cbf1:      * If this node is known to always evaluate to the same value, return a
1:568cbf1:      * node that represents that known value as a constant. Typically used to
1:568cbf1:      * transform operators with constant operands into constants.
1:568cbf1:      *
1:568cbf1:      * @return a constant representing the value to which this node is
1:568cbf1:      * guaranteed to evaluate, or {@code this} if the value is not known
1:568cbf1:      * @throws StandardException if an error occurs during evaluation
1:568cbf1:      * @see ConstantExpressionVisitor
1:568cbf1:      */
1:568cbf1:     ValueNode evaluateConstantExpressions() throws StandardException {
1:568cbf1:         // We normally don't know what the node evaluates to up front, so
1:568cbf1:         // don't do anything in the default implementation.
1:568cbf1:         return this;
1:568cbf1:     }
1:568cbf1: 
1:eac0369: 	/**
1:eac0369: 	 * Eliminate NotNodes in the current query block.  We traverse the tree, 
1:eac0369: 	 * inverting ANDs and ORs and eliminating NOTs as we go.  We stop at 
1:eac0369: 	 * ComparisonOperators and boolean expressions.  We invert 
1:eac0369: 	 * ComparisonOperators and replace boolean expressions with 
1:eac0369: 	 * boolean expression = false.
1:eac0369: 	 * NOTE: Since we do not recurse under ComparisonOperators, there
1:eac0369: 	 * still could be NotNodes left in the tree.
1:eac0369: 	 *
1:eac0369: 	 * @param	underNotNode		Whether or not we are under a NotNode.
1:eac0369: 	 *							
1:eac0369: 	 *
1:eac0369: 	 * @return		The modified expression
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	ValueNode eliminateNots(boolean underNotNode) 
1:eac0369: 					throws StandardException
1:eac0369: 	{
1:eac0369: 		if (! underNotNode)
1:eac0369: 		{
1:eac0369: 			return this;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* bind() has ensured that this node's type is SQLBoolean */
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		SanityManager.ASSERT(
1:ef158f2: 				getTypeId().isBooleanTypeId(),
1:eac0369: 					"Node's type (" +
1:ef158f2: 					getTypeId().getSQLTypeName() +
1:eac0369: 					") is expected to be boolean");
1:eac0369: 
1:eac0369: 		/* Return ValueNode = false */
1:eac0369: 		return genEqualsFalseTree();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Transform this into this = false.  Useful for NOT elimination.
1:eac0369: 	 *
1:eac0369: 	 *
1:eac0369: 	 * @return		The modified expression
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     ValueNode genEqualsFalseTree()
1:eac0369: 			throws StandardException
1:eac0369: 	{
1:eac0369: 		BinaryRelationalOperatorNode equalsNode;
1:eac0369: 		BooleanConstantNode		 falseNode;
1:eac0369: 		boolean 				nullableResult;
1:eac0369: 
1:3bb140c:         falseNode = new BooleanConstantNode(false, getContextManager());
1:3bb140c:         equalsNode = new BinaryRelationalOperatorNode(
1:2706d1f:                 BinaryRelationalOperatorNode.K_EQUALS,
1:2706d1f:                 this,
1:2706d1f:                 falseNode,
1:2706d1f:                 false,
1:2706d1f:                 getContextManager());
1:ef158f2: 		nullableResult = getTypeServices().isNullable();
1:eac0369: 		equalsNode.setType(new DataTypeDescriptor(
1:eac0369: 									TypeId.BOOLEAN_ID,
1:eac0369: 									nullableResult)
1:ef158f2: 						  );
1:eac0369: 		return equalsNode;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:09c30dd:      * Transform this into this IS NULL or IS NOT NULL.
1:eac0369: 	 *
1:09c30dd:      * @param notNull if true, transform this into IS NOT NULL;
1:09c30dd:      *                otherwise, transform this into IS NULL
1:eac0369: 	 * @return		The modified expression
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:09c30dd:     ValueNode genIsNullTree(boolean notNull)
1:eac0369: 			throws StandardException
1:eac0369: 	{
1:eac0369: 		IsNullNode isNullNode;
1:eac0369: 
1:09c30dd:         isNullNode = new IsNullNode(this, notNull, getContextManager());
1:eac0369: 		isNullNode.setType(new DataTypeDescriptor(
1:eac0369: 									TypeId.BOOLEAN_ID,
1:eac0369: 									false)
4:eac0369: 						  );
1:eac0369: 		return isNullNode;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Verify that eliminateNots() did its job correctly.  Verify that
1:eac0369: 	 * there are no NotNodes above the top level comparison operators
1:eac0369: 	 * and boolean expressions.
1:eac0369: 	 *
1:eac0369: 	 * @return		Boolean which reflects validity of the tree.
1:eac0369: 	 */
1:eac0369: 	boolean verifyEliminateNots()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.ASSERT)
1:eac0369: 		{
1:eac0369: 			return (! (this instanceof NotNode));
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return true;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Do the 1st step in putting an expression into conjunctive normal
1:eac0369: 	 * form.  This step ensures that the top level of the expression is
1:eac0369: 	 * a chain of AndNodes.
1:eac0369: 	 *
1:eac0369: 	 * @return		The modified expression
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     ValueNode putAndsOnTop()
1:eac0369: 					throws StandardException
1:eac0369: 	{
1:3bb140c:         BooleanConstantNode trueNode =
1:3bb140c:                 new BooleanConstantNode(true, getContextManager());
1:3bb140c:         AndNode andNode = new AndNode(this, trueNode, getContextManager());
1:eac0369: 		andNode.postBindFixup();
1:eac0369: 		return andNode;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Verify that putAndsOnTop() did its job correctly.  Verify that the top level 
1:eac0369: 	 * of the expression is a chain of AndNodes.
1:eac0369: 	 *
1:eac0369: 	 * @return		Boolean which reflects validity of the tree.
1:eac0369: 	 */
1:3bb140c:     boolean verifyPutAndsOnTop()
1:eac0369: 	{
1:eac0369: 		return true;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Finish putting an expression into conjunctive normal
1:eac0369: 	 * form.  An expression tree in conjunctive normal form meets
1:eac0369: 	 * the following criteria:
1:eac0369: 	 *		o  If the expression tree is not null,
1:eac0369: 	 *		   the top level will be a chain of AndNodes terminating
1:eac0369: 	 *		   in a true BooleanConstantNode.
1:eac0369: 	 *		o  The left child of an AndNode will never be an AndNode.
1:eac0369: 	 *		o  Any right-linked chain that includes an AndNode will
1:eac0369: 	 *		   be entirely composed of AndNodes terminated by a true BooleanConstantNode.
1:eac0369: 	 *		o  The left child of an OrNode will never be an OrNode.
1:eac0369: 	 *		o  Any right-linked chain that includes an OrNode will
1:eac0369: 	 *		   be entirely composed of OrNodes terminated by a false BooleanConstantNode.
1:eac0369: 	 *		o  ValueNodes other than AndNodes and OrNodes are considered
1:eac0369: 	 *		   leaf nodes for purposes of expression normalization.
1:eac0369: 	 *		   In other words, we won't do any normalization under
1:eac0369: 	 *		   those nodes.
1:eac0369: 	 *
1:eac0369: 	 * In addition, we track whether or not we are under a top level AndNode.  
1:eac0369: 	 * SubqueryNodes need to know this for subquery flattening.
1:eac0369: 	 *
1:eac0369: 	 * @param	underTopAndNode		Whether or not we are under a top level AndNode.
1:eac0369: 	 *							
1:eac0369: 	 *
1:eac0369: 	 * @return		The modified expression
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     ValueNode changeToCNF(boolean underTopAndNode)
1:eac0369: 					throws StandardException
1:eac0369: 	{
1:eac0369: 		return this;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Verify that changeToCNF() did its job correctly.  Verify that:
1:eac0369: 	 *		o  AndNode  - rightOperand is not instanceof OrNode
1:eac0369: 	 *				      leftOperand is not instanceof AndNode
1:eac0369: 	 *		o  OrNode	- rightOperand is not instanceof AndNode
1:eac0369: 	 *					  leftOperand is not instanceof OrNode
1:eac0369: 	 *
1:eac0369: 	 * @return		Boolean which reflects validity of the tree.
1:eac0369: 	 */
1:3bb140c:     boolean verifyChangeToCNF()
1:eac0369: 	{
1:eac0369: 		return true;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Categorize this predicate.  Initially, this means
1:eac0369: 	 * building a bit map of the referenced tables for each predicate.
1:eac0369: 	 * If the source of this ColumnReference (at the next underlying level) 
1:eac0369: 	 * is not a ColumnReference or a VirtualColumnNode then this predicate
1:eac0369: 	 * will not be pushed down.
1:eac0369: 	 *
1:eac0369: 	 * For example, in:
1:eac0369: 	 *		select * from (select 1 from s) a (x) where x = 1
1:eac0369: 	 * we will not push down x = 1.
1:eac0369: 	 * NOTE: It would be easy to handle the case of a constant, but if the
1:eac0369: 	 * inner SELECT returns an arbitrary expression, then we would have to copy
1:eac0369: 	 * that tree into the pushed predicate, and that tree could contain
1:eac0369: 	 * subqueries and method calls.
1:eac0369: 	 * RESOLVE - revisit this issue once we have views.
1:eac0369: 	 *
1:eac0369: 	 * @param referencedTabs	JBitSet with bit map of referenced FromTables
1:eac0369: 	 * @param simplePredsOnly	Whether or not to consider method
1:eac0369: 	 *							calls, field references and conditional nodes
1:eac0369: 	 *							when building bit map
1:eac0369: 	 *
1:eac0369: 	 * @return boolean		Whether or not source.expression is a ColumnReference
1:eac0369: 	 *						or a VirtualColumnNode.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException			Thrown on error
1:eac0369: 	 */
1:3bb140c:     boolean categorize(JBitSet referencedTabs, boolean simplePredsOnly)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		return true;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:b57ee34: 	 * This returns the user-supplied schema name of the column.
1:b57ee34: 	 * At this class level, it simply returns null. But, the subclasses
1:b57ee34: 	 * of ValueNode will overwrite this method to return the
1:b57ee34: 	 * user-supplied schema name.
1:b57ee34: 	 * 
1:eac0369: 	 * When the value node is in a result column of a select list,
1:eac0369: 	 * the user can request metadata information. The result column
1:eac0369: 	 * won't have a column descriptor, so we return some default
1:eac0369: 	 * information through the expression. This lets expressions that
1:eac0369: 	 * are simply columns return all of the info, and others use
1:eac0369: 	 * this supertype's default values.
1:b57ee34: 	 *
2:eac0369: 	 * @return the default schema name for an expression -- null
1:eac0369: 	 */
1:3bb140c:     String getSchemaName() throws StandardException
1:eac0369: 	{
1:eac0369: 		return null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:b57ee34: 	 * This returns the user-supplied table name of the column.
1:b57ee34: 	 * At this class level, it simply returns null. But, the subclasses
1:b57ee34: 	 * of ValueNode will overwrite this method to return the
1:b57ee34: 	 * user-supplied table name.
1:b57ee34: 	 *
1:b57ee34: 	 * When the value node is in a result column of a select list,
1:b57ee34: 	 * the user can request metadata information. The result column
1:b57ee34: 	 * won't have a column descriptor, so we return some default
1:b57ee34: 	 * information through the expression. This lets expressions that
1:b57ee34: 	 * are simply columns return all of the info, and others use
1:b57ee34: 	 * this supertype's default values.
1:eac0369: 	 *
1:b57ee34: 	 * @return the default table name for an expression -- null
1:eac0369: 	 */
1:3bb140c:     String getTableName()
1:eac0369: 	{
1:eac0369: 		return null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:b57ee34: 	 * @return the default updatability for an expression - false
1:b57ee34: 	 */
1:b57ee34: 	public boolean updatableByCursor()
1:b57ee34: 	{
1:b57ee34: 		return false;
1:01217c2: 	}
1:01217c2: 
1:01217c2: 	/**
1:eac0369: 	 * This is null so that the caller will substitute in the resultset generated
1:eac0369: 	 * name as needed.
1:01217c2: 	 *
1:eac0369: 	 * @return the default column name for an expression -- null.
1:01217c2: 	 */
1:3bb140c:     String getColumnName()
1:01217c2: 	{
1:eac0369: 		return null;
1:b57ee34: 	}
1:b57ee34: 
1:01217c2: 	/**
1:eac0369: 	 * Get a bit map of table references in this expression
1:01217c2: 	 *
1:eac0369: 	 * @return	A bit map of table numbers referred to in this expression
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException			Thrown on error
1:eac0369: 	 */
1:eac0369: 	JBitSet getTablesReferenced()
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		ReferencedTablesVisitor rtv = new ReferencedTablesVisitor(new JBitSet(0));
1:eac0369: 		accept(rtv);
1:eac0369: 		return rtv.getTableMap();
1:eac0369: 	}
1:eac0369: 
1:b57ee34: 	/**
1:eac0369: 	 * Return whether or not this expression tree is cloneable.
1:eac0369: 	 *
1:eac0369: 	 * @return boolean	Whether or not this expression tree is cloneable.
1:eac0369: 	 */
1:3bb140c:     boolean isCloneable()
1:eac0369: 	{
1:01217c2: 		return false;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return a clone of this node.
1:eac0369: 	 *
1:eac0369: 	 * @return ValueNode	A clone of this node.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException			Thrown on error
1:eac0369: 	 */
1:3bb140c:     ValueNode getClone() throws StandardException
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(false,
1:eac0369: 				"getClone() not expected to be called for " +
1:eac0369: 				getClass().getName());
1:eac0369: 		}
1:eac0369: 		return null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Copy all of the "appropriate fields" for a shallow copy.
1:eac0369: 	 *
1:eac0369: 	 * @param oldVN		The ValueNode to copy from.
1:eac0369: 	 *
1:eac0369: 	 */
1:3bb140c:     void copyFields(ValueNode oldVN) throws StandardException
1:eac0369: 	{
1:eac0369: 		dataTypeServices = oldVN.getTypeServices();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Remap all ColumnReferences in this tree to be clones of the
1:eac0369: 	 * underlying expression.
1:eac0369: 	 *
1:eac0369: 	 * @return ValueNode			The remapped expression tree.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException			Thrown on error
1:eac0369: 	 */
1:3bb140c:     ValueNode remapColumnReferencesToExpressions() throws StandardException
1:eac0369: 	{
1:eac0369: 		return this;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return whether or not this expression tree represents a constant expression.
1:eac0369: 	 *
1:eac0369: 	 * @return	Whether or not this expression tree represents a constant expression.
1:eac0369: 	 */
1:3bb140c:     boolean isConstantExpression()
1:eac0369: 	{
1:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return whether or not this expression tree represents a constant value.
1:eac0369: 	 * In this case, "constant" means that it will always evaluate to the
1:eac0369: 	 * same thing, even if it includes columns.  A column is constant if it
1:eac0369: 	 * is compared to a constant expression.
1:eac0369: 	 *
1:eac0369: 	 * @return	True means this expression tree represents a constant value.
1:eac0369: 	 */
1:3bb140c:     boolean constantExpression(PredicateList whereClause)
1:eac0369: 	{
1:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return the variant type for the underlying expression.
1:eac0369: 	 * The variant type can be:
1:eac0369: 	 *		VARIANT				- variant within a scan
1:eac0369: 	 *							  (method calls and non-static field access)
1:eac0369: 	 *		SCAN_INVARIANT		- invariant within a scan
1:eac0369: 	 *							  (column references from outer tables)
1:eac0369: 	 *		QUERY_INVARIANT		- invariant within the life of a query
1:eac0369: 	 *							  (constant expressions)
1:eac0369: 	 *
1:eac0369: 	 * @return	The variant type for the underlying expression.
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	protected int getOrderableVariantType() throws StandardException
1:eac0369: 	{
1:eac0369: 		// The default is VARIANT
1:eac0369: 		return Qualifier.VARIANT;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  * Bind time logic. Raises an error if this ValueNode does not resolve to
1:eac0369: 	  *	a boolean value. This method is called by WHERE clauses.
1:eac0369: 	  *
1:eac0369: 	  *	@return	bound coercion of this node to a builtin type as necessary
1:eac0369: 	  *
1:eac0369: 	  * @exception StandardException		Thrown on error
1:eac0369: 	  */
1:eac0369: 	public	ValueNode	checkIsBoolean()
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		ValueNode	whereClause = this;
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** Is the datatype of the WHERE clause BOOLEAN?
1:eac0369: 		**
1:eac0369: 		** NOTE: This test is not necessary in SQL92 entry level, because
1:eac0369: 		** it is syntactically impossible to have a non-Boolean WHERE clause
1:eac0369: 		** in that level of the standard.  But we intend to extend the
1:eac0369: 		** language to allow Boolean user functions in the WHERE clause,
1:eac0369: 		** so we need to test for the error condition.
1:eac0369: 		*/
1:eac0369: 		TypeId whereTypeId = whereClause.getTypeId();
1:eac0369: 
1:eac0369: 		/* If the where clause is not a built-in type, then generate a bound 
1:eac0369: 		 * conversion tree to a built-in type.
1:eac0369: 		 */
1:08d6ce2: 		if (whereTypeId.userType())
1:eac0369: 		{
1:eac0369: 			whereClause = whereClause.genSQLJavaSQLTree();
1:eac0369: 			whereTypeId = whereClause.getTypeId();
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (! whereTypeId.equals(TypeId.BOOLEAN_ID))
1:eac0369: 		{
1:eac0369: 			throw StandardException.newException(SQLState.LANG_NON_BOOLEAN_WHERE_CLAUSE, 
1:eac0369: 				whereTypeId.getSQLTypeName()
1:eac0369: 				);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return	whereClause;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return an Object representing the bind time value of this
1:eac0369: 	 * expression tree.  If the expression tree does not evaluate to
1:eac0369: 	 * a constant at bind time then we return null.
1:eac0369: 	 * This is useful for bind time resolution of VTIs.
1:eac0369: 	 * RESOLVE: What do we do for primitives?
1:eac0369: 	 *
1:eac0369: 	 * @return	An Object representing the bind time value of this expression tree.
1:eac0369: 	 *			(null if not a bind time constant.)
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	Object getConstantValueAsObject()
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		return null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/////////////////////////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	//	The ValueNode defers its generate() work to a method that works on
1:eac0369: 	//	ExpressionClassBuilders rather than ActivationClassBuilders. This
1:eac0369: 	//	is so that expression generation can be shared by the Core compiler
1:eac0369: 	//	AND the Replication Filter compiler.
1:eac0369: 	//
1:eac0369: 	/////////////////////////////////////////////////////////////////////////
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Do the code generation for this node.  Call the more general
1:eac0369: 	 * routine that generates expressions.
1:eac0369: 	 *
1:eac0369: 	 * @param acb	The ActivationClassBuilder for the class being built
2:eac0369: 	 * @param mb	The method the expression will go into
1:eac0369: 	 *
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:8fe3166:     final void generate(ActivationClassBuilder acb, MethodBuilder mb)
1:eac0369: 								throws StandardException
1:eac0369: 	{
1:eac0369: 		generateExpression( acb, mb );
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * The default selectivity for value nodes is 50%.  This is overridden
1:eac0369: 	 * in specific cases, such as the RelationalOperators.
1:eac0369: 	 */
1:eac0369: 	public double selectivity(Optimizable optTable)
1:eac0369: 	throws StandardException
1:eac0369: 	{
1:eac0369: 		// Return 1 if additional predicates have been generated from this one.
1:eac0369: 		if (transformed)
1:eac0369: 		{
1:eac0369: 			return 1.0;
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return 0.5d;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Update the array of columns in = conditions with expressions without
1:eac0369: 	 * column references from the same table.  This is useful when doing
1:eac0369: 	 * subquery flattening on the basis of an equality condition.
1:eac0369: 	 * eqOuterCols or tableColMap may be null if the calling routine
1:eac0369: 	 * doesn't need the information provided
1:eac0369: 	 *
1:eac0369: 	 * @param tableNumber	The tableNumber of the table from which
1:eac0369: 	 *						the columns of interest come from.
1:eac0369: 	 * @param eqOuterCols	Array of booleans for noting which columns
1:eac0369: 	 *						are in = predicates without columns from the
1:eac0369: 	 *						subquery block. May be null.
1:eac0369: 	 * @param tableNumbers	Array of table numbers in this query block.
1:eac0369: 	 * @param tableColMap	Array of bits for noting which columns
1:eac0369: 	 *						are in = predicates for each table in the
1:eac0369: 	 *						query block. May be null.
1:eac0369: 	 * @param resultColTable True if tableNumber is the table containing result
1:eac0369: 	 * 						columns
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException			Thrown on error
1:eac0369: 	 * 
1:eac0369: 	 */
1:eac0369: 	void checkTopPredicatesForEqualsConditions(
1:eac0369: 				int tableNumber, boolean[] eqOuterCols, int[] tableNumbers, 
1:eac0369: 				JBitSet[] tableColMap, boolean resultColTable)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		for (ValueNode whereWalker = this; whereWalker instanceof AndNode; 
1:eac0369: 			 whereWalker = ((AndNode) whereWalker).getRightOperand())
1:eac0369: 		{
1:eac0369: 			// See if this is a candidate =
1:eac0369: 			AndNode and = (AndNode) whereWalker;
1:eac0369: 
1:eac0369: 			if (!and.getLeftOperand().isRelationalOperator() ||
1:eac0369: 				!(((RelationalOperator)(and.getLeftOperand())).getOperator() == RelationalOperator.EQUALS_RELOP))
1:eac0369: 			{
1:eac0369: 				continue;
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			BinaryRelationalOperatorNode beon =
1:eac0369: 					(BinaryRelationalOperatorNode) and.getLeftOperand();
1:eac0369: 			ValueNode left = beon.getLeftOperand();
1:eac0369: 			ValueNode right = beon.getRightOperand();
1:eac0369: 			int resultTable = 0;
1:eac0369: 			if (resultColTable)
1:eac0369: 			{
1:eac0369: 				for ( ; resultTable < tableNumbers.length; resultTable++)
1:eac0369: 				{
1:eac0369: 					if (tableNumbers[resultTable] == tableNumber)
1:eac0369: 						break;
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 			else
1:eac0369: 				resultTable = -1;
1:eac0369: 
1:eac0369: 			/* Is this = of the right form? */
1:eac0369: 			if ((left instanceof ColumnReference) &&
1:eac0369: 				((ColumnReference) left).getTableNumber() == tableNumber)
1:eac0369: 			{
1:eac0369: 				updateMaps(tableColMap, eqOuterCols, tableNumbers, tableNumber,
1:eac0369: 					resultTable, right, left);
1:eac0369: 			}
1:eac0369: 			else if ((right instanceof ColumnReference) &&
1:eac0369: 					 ((ColumnReference) right).getTableNumber() == tableNumber)
1:eac0369: 			{
1:eac0369: 				updateMaps(tableColMap, eqOuterCols, tableNumbers, tableNumber,
1:eac0369: 					resultTable, left, right);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Does this represent a true constant.
1:eac0369: 	 *
1:eac0369: 	 * @return Whether or not this node represents a true constant.
1:eac0369: 	 */
1:eac0369: 	boolean isBooleanTrue()
1:eac0369: 	{
1:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Does this represent a false constant.
1:eac0369: 	 *
1:eac0369: 	 * @return Whether or not this node represents a false constant.
1:eac0369: 	 */
1:eac0369: 	boolean isBooleanFalse()
1:eac0369: 	{
1:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Generate code for this calculation.  This is a place-holder method -
1:eac0369: 	 * it should not be called.
1:eac0369: 	 *
1:6b50965: 	 * @param acb	The ExpressionClassBuilder for the class being built
1:eac0369: 	 * @param mb	The method the expression will go into
1:eac0369: 	 *
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 
1:8fe3166:     void generateExpression(ExpressionClassBuilder acb, MethodBuilder mb)
1:eac0369: 						throws StandardException
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		SanityManager.ASSERT(false, "Code generation for this type of ValueNode is unimplemented");
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set the correct bits in tableColMap and set the boolean value in eqOuterCols 
1:eac0369: 	 * given two arguments to an = predicate
1:eac0369: 	 * tableColMap[t] - bit is set if the column is in an = predicate with a column 
1:eac0369: 	 *					in table t, or a bit is set if the column is in an 
1:eac0369: 	 *					= predicate with a constant,parameter or correlation variable 
1:eac0369: 	 *				    (for all table t, if this tableColMap is not for the
1:eac0369:   	 *					table with the result columns)
1:eac0369: 	 * eqOuterCols[c] - is true if the column is in an = predicate with a constant,
1:eac0369: 	 *					parameter or correlation variable
1:eac0369: 	 * 
1:eac0369: 	 *
1:eac0369: 	 * @param tableColMap	Array of bitmaps for noting which columns are in = 
1:eac0369: 	 *						predicates with columns from each table
1:eac0369: 	 * @param eqOuterCols	Array of booleans for noting which columns
1:eac0369: 	 *						are in = predicates without columns from the
1:eac0369: 	 *						subquery block.
1:eac0369: 	 * @param tableNumber	table number for which we are setting up the Maps
1:eac0369: 	 * @param resultTable	-1 if this table is not the result table; otherwise
1:eac0369: 	 *						the index into tableNumbers for the result table
1:eac0369: 	 * @param arg1			one side of the = predicate
1:eac0369: 	 * @param arg2			other side of the = predicate
1:eac0369: 	 *
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	private void updateMaps(JBitSet[] tableColMap, boolean[] eqOuterCols,
1:eac0369: 		int[] tableNumbers,  int tableNumber, int resultTable,
1:eac0369: 		ValueNode arg1, ValueNode arg2)
1:eac0369: 			throws StandardException
1:eac0369: 	{
1:eac0369: 		/* arg2 is a column from our table.  This
1:eac0369: 		 * is a good = for both All tables and Outer arrays
1:eac0369: 		 * if the right side is a constant or a parameter
1:eac0369: 		 * or a column from an outer table.
1:eac0369: 		 * It is a good = for only the All array if
1:eac0369: 		 * the right side is a column from this query block.
1:eac0369: 		 */
1:d5bc20f: 		if ((arg1 instanceof ConstantNode) || (arg1.requiresTypeFromContext()))
1:eac0369: 		{
1:eac0369: 			setValueCols(tableColMap, eqOuterCols,
1:eac0369: 				((ColumnReference) arg2).getColumnNumber(), resultTable);
1:eac0369: 		}
1:eac0369: 		else if((arg1 instanceof ColumnReference &&
1:eac0369: 					((ColumnReference) arg1).getTableNumber() != tableNumber))
1:eac0369: 		{
1:eac0369: 			/* See if other columns is a correlation column */
1:eac0369: 			int otherTN = ((ColumnReference) arg1).getTableNumber();
1:eac0369: 			int index = 0;
1:eac0369: 			int colNumber =	((ColumnReference) arg2).getColumnNumber();
1:eac0369: 
1:eac0369: 			for ( ; index < tableNumbers.length; index++)
1:eac0369: 			{
1:eac0369: 				if (otherTN == tableNumbers[index])
1:eac0369: 				{
1:eac0369: 					break;
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 			/* Correlation column, so we can treat it as a constant */
1:eac0369: 			if (index == tableNumbers.length)
1:eac0369: 			{
1:eac0369: 				setValueCols(tableColMap, eqOuterCols, colNumber, resultTable);
1:eac0369: 			}
1:eac0369: 			else if (tableColMap != null)
1:eac0369: 			{
1:eac0369: 				tableColMap[index].set(colNumber);
1:eac0369: 			}
1:eac0369: 
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			/* See if other side contains a column reference from the same table */
1:eac0369: 			JBitSet referencedTables = arg1.getTablesReferenced();
1:eac0369: 			/* See if other columns are all correlation columns */
1:eac0369: 			int index = 0;
1:eac0369: 			int colNumber =	((ColumnReference) arg2).getColumnNumber();
1:eac0369: 			for ( ; index < tableNumbers.length; index++)
1:eac0369: 			{
1:eac0369: 				if (referencedTables.get(tableNumbers[index]))
1:eac0369: 				{
1:eac0369: 					break;
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 			/* Correlation column, so we can treat it as a constant */
1:eac0369: 			if (index == tableNumbers.length)
1:eac0369: 			{
1:eac0369: 				setValueCols(tableColMap, eqOuterCols, colNumber, resultTable);
1:eac0369: 			}
1:eac0369: 			else if (tableColMap != null && !referencedTables.get(tableNumber))
1:eac0369: 			{
1:eac0369: 				tableColMap[index].set(colNumber);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 	/**
1:eac0369: 	 * Set eqOuterCols and the column in all the tables for constants,
1:eac0369: 	 * parmeters and correlation columns
1:eac0369: 	 * The column in the tableColMap is set only for the current table
1:eac0369: 	 * if the table is the result column table.  For other tables in the
1:eac0369: 	 * query we set the column for all the tables since the constant will
1:eac0369: 	 * reduced the number of columns required in a unique multicolumn index for
1:eac0369: 	 * distinctness.
1:eac0369: 	 * For example, given an unique index on t1(a,b), setting b=1 means that
1:eac0369: 	 * t1(a) is unique since there can be no duplicates for a where b=1 without
1:eac0369: 	 * destroying the uniqueness of t1(a,b).  However, for the result columns
1:eac0369: 	 * setting b=1, does not mean that a select list of t1.a is distinct if
1:eac0369: 	 * t1.a is the only column used in joining with another table
1:eac0369: 	 * e.g. select t1.a from t1, t2 where t1.a = t2.a and t1.b = 1;
1:eac0369: 	 * 
1:eac0369: 	 * 	t1			t2			result
1:eac0369: 	 *	a	b		a			a
1:eac0369: 	 *  1	1		1			1
1:eac0369: 	 *  1 	2		2			1
1:eac0369: 	 *	2	1
1:eac0369: 	 * 
1:eac0369: 	 *
1:eac0369: 	 * @param tableColMap	Array of bitmaps for noting which columns are in = 
1:eac0369: 	 *						predicates with columns from each table
1:eac0369: 	 * @param eqOuterCols	Array of booleans for noting which columns
1:eac0369: 	 *						are in = predicates without columns from the
1:eac0369: 	 *						subquery block.
1:eac0369: 	 * @param colReference	The column to set
1:eac0369: 	 * @param resultTable	If -1 set all the bit for all the tables for that
1:eac0369: 	 *						column; otherwise set the bit for the specified table
1:eac0369: 	 *
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 	private void setValueCols(JBitSet[] tableColMap, boolean[] eqOuterCols, 
1:eac0369: 		int colReference, int resultTable)
1:eac0369: 	{
1:eac0369: 		if (eqOuterCols != null)
1:eac0369: 			eqOuterCols[colReference] = true;
1:eac0369: 
1:eac0369: 		if (tableColMap != null)
1:eac0369: 		{
1:eac0369: 			if (resultTable == -1)
1:eac0369: 			{
1:eac0369: 				for (int i = 0; i < tableColMap.length; i++)
1:eac0369: 					tableColMap[i].set(colReference);
1:eac0369: 			}
1:eac0369: 			else
1:eac0369: 				tableColMap[resultTable].set(colReference);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Returns true if this ValueNode is a relational operator. Relational
1:dbed020: 	 * Operators are &lt;, &lt;=, =, &gt;, &gt;=, &lt;&gt; as well as IS NULL and IS NOT
1:eac0369: 	 * NULL. This is the preferred way of figuring out if a ValueNode is
1:eac0369: 	 * relational or not. 
1:eac0369: 	 * @see RelationalOperator
1:eac0369: 	 * @see BinaryRelationalOperatorNode
1:eac0369: 	 * @see IsNullNode
1:eac0369: 	*/
1:3bb140c:     boolean isRelationalOperator()
1:eac0369: 	{
1:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: 	
1:eac0369: 	/**
1:eac0369: 	 * Returns true if this value node is a <em>equals</em> operator. 
1:eac0369: 	 *
1:eac0369: 	 * @see ValueNode#isRelationalOperator
1:eac0369: 	 */
1:3bb140c:     boolean isBinaryEqualsOperatorNode()
1:eac0369: 	{
1:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:9d82913: 	 * Returns true if this value node is an operator created
1:9d82913: 	 * for optimized performance of an IN list.
1:eac0369: 	 *
1:9d82913: 	 * Or more specifically, returns true if this value node is
1:9d82913: 	 * an equals operator of the form "col = ?" that we generated
1:9d82913: 	 * during preprocessing to allow index multi-probing.
1:eac0369: 	 */
1:3bb140c:     boolean isInListProbeNode()
1:eac0369: 	{
1:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** Return true if the predicate represents an optimizable equality node.
1:eac0369: 	 * an expression is considered to be an optimizable equality node if all the
1:eac0369: 	 * following conditions are met:
1:eac0369: 	 * <ol>
1:eac0369: 	 * <li> the operator is an <em>=</em> or <em>IS NULL</em> operator </li>
1:eac0369: 	 * <li> one of the operands is a column specified by optTable/columnNumber</li>
1:eac0369: 	 * <li> Both operands are not the same column; i.e tab.col = tab.col </li>
1:eac0369: 	 * <li> There are no implicit varchar comparisons of the operands; i.e
1:eac0369: 	 * either both operands are string like (varchar, char, longvarchar) or
1:eac0369: 	 * neither operand is string like </li>
1:eac0369: 	 * </ol>
1:eac0369: 	 * 
1:eac0369: 	 * @param optTable	the table being optimized. Column reference must be from
1:eac0369: 	 * this table.
1:eac0369: 	 * @param columnNumber the column number. One of the operands of this
1:eac0369: 	 * predicate must be the column number specified by optTable/columnNumber
1:eac0369: 	 * @param isNullOkay if set to true we also consider IS NULL predicates;
1:eac0369: 	 * otherwise consider only = predicates.
1:eac0369: 	 */
1:3bb140c:     boolean optimizableEqualityNode(Optimizable optTable,
1:eac0369: 										   int columnNumber, 
1:eac0369: 										   boolean isNullOkay)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:d5bc20f: 	 * Returns TRUE if the type of this node will be determined from the
1:e2f08d2: 	 * context in which it is getting used. If true is returned then
1:e2f08d2:      * after bindExpression() is called on the node, its type
1:e2f08d2:      * must be set (from the relevant context) using setType().
1:eac0369: 	 *
1:d5bc20f: 	 * @return Whether this node's type will be determined from the context
1:eac0369: 	 */
1:3bb140c:     boolean requiresTypeFromContext()
1:eac0369: 	{
1:9d82913: 		return false;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Returns TRUE if this is a parameter node. We do lots of special things
1:eac0369: 	 * with Parameter Nodes.
1:eac0369: 	 *
1:eac0369: 	 */
1:3bb140c:     boolean isParameterNode()
1:eac0369: 	{
1:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: 	
1:eac0369: 	/**
1:01217c2: 	 * Tests if this node is equivalent to the specified ValueNode. Two 
1:01217c2: 	 * ValueNodes are considered equivalent if they will evaluate to the same
1:01217c2: 	 * value during query execution. 
1:1d4b49f: 	 * <p> 
1:1d4b49f: 	 * This method provides basic expression matching facility for the derived 
1:1d4b49f: 	 * class of ValueNode and it is used by the language layer to compare the 
1:1d4b49f: 	 * node structural form of the two expressions for equivalence at bind 
1:1d4b49f: 	 * phase.  
1:1d4b49f: 	 *  <p>
1:1d4b49f: 	 * Note that it is not comparing the actual row values at runtime to produce 
1:1d4b49f: 	 * a result; hence, when comparing SQL NULLs, they are considered to be 
1:1d4b49f: 	 * equivalent and not unknown.  
1:1d4b49f: 	 *  <p>
1:1d4b49f: 	 * One usage case of this method in this context is to compare the select 
1:1d4b49f: 	 * column expression against the group by expression to check if they are 
1:1d4b49f: 	 * equivalent.  e.g.:
1:1d4b49f: 	 *  <p>
1:1d4b49f: 	 * SELECT c1+c2 FROM t1 GROUP BY c1+c2   
1:1d4b49f: 	 *  <p>
1:1d4b49f: 	 * In general, node equivalence is determined by the derived class of 
1:1d4b49f: 	 * ValueNode.  But they generally abide to the rules below:
1:1d4b49f: 	 *  <ul>
1:1d4b49f: 	 * <li>The two ValueNodes must be of the same node type to be considered 
1:1d4b49f: 	 *   equivalent.  e.g.:  CastNode vs. CastNode - equivalent (if their args 
1:1d4b49f: 	 *   also match), ColumnReference vs CastNode - not equivalent.
1:1d4b49f: 	 *   
1:1d4b49f: 	 * <li>If node P contains other ValueNode(s) and so on, those node(s) must 
1:1d4b49f: 	 *   also be of the same node type to be considered equivalent.
1:1d4b49f: 	 *   
1:1d4b49f: 	 * <li>If node P takes a parameter list, then the number of arguments and its 
1:1d4b49f: 	 *   arguments for the two nodes must also match to be considered 
1:1d4b49f: 	 *   equivalent.  e.g.:  CAST(c1 as INTEGER) vs CAST(c1 as SMALLINT), they 
1:1d4b49f: 	 *   are not equivalent.
1:1d4b49f: 	 *   
1:1d4b49f: 	 * <li>When comparing SQL NULLs in this context, they are considered to be 
1:1d4b49f: 	 *   equivalent.
1:01217c2: 	 * 
1:1d4b49f: 	 * <li>If this does not apply or it is determined that the two nodes are not 
1:1d4b49f: 	 *   equivalent then the derived class of this method should return false; 
1:1d4b49f: 	 *   otherwise, return true.
1:1d4b49f: 	 * </ul>   
1:1d4b49f: 	 *   
1:01217c2: 	 * @param other the node to compare this ValueNode against.
1:01217c2: 	 * @return <code>true</code> if the two nodes are equivalent, 
1:01217c2: 	 * <code>false</code> otherwise.
1:01217c2: 	 * 
1:01217c2: 	 * @throws StandardException 
1:01217c2: 	 */
1:3bb140c:     abstract boolean isEquivalent(ValueNode other)
1:01217c2: 		throws StandardException;
1:01217c2: 
1:2706d1f:     /**
1:2706d1f:      * Some node classes represent several logical node types (to reduce
1:2706d1f:      * footprint), which we call <em>kinds</em>.
1:eb88678:      * This means that implementations of {@link #isEquivalent}
1:2706d1f:      * cannot always just use {@code instanceof} to check if the other node
1:2706d1f:      * represents the same kind. Hence this method needs to be
1:7b87db0:      * overridden by all node classes that represent several kinds.
1:7b87db0:      * This default implementation does not look at kinds.
1:19aa0ac:      * It is only called from implementations of {@code isEquivalent}.
1:2706d1f:      *
1:2706d1f:      * @param other The other value node whose kind we want to compare with.
1:2706d1f:      * @return {@code true} if {@code this} and {@code o} represent the same
1:2706d1f:      *         logical node type, i.e. kind.
1:2706d1f:      */
1:2706d1f:     boolean isSameNodeKind(ValueNode other) {
1:2706d1f:         // Default implementation does not look at kinds.
1:2706d1f:         return other != null && other.getClass().equals(this.getClass());
1:2706d1f:     }
1:01217c2: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1: 	 * Generate a SQL-&gt;Java-&gt;SQL conversion tree above the current node
/////////////////////////////////////////////////////////////////////////
1: 	 * Operators are &lt;, &lt;=, =, &gt;, &gt;=, &lt;&gt; as well as IS NULL and IS NOT
commit:71c8e86
/////////////////////////////////////////////////////////////////////////
1:             FromList fromList, SubqueryList subqueryList, List<AggregateNode> aggregates)
commit:d861c23
/////////////////////////////////////////////////////////////////////////
1: 
1:         DataTypeDescriptor  resultType;
1:         if ( (getTypeServices() != null) && getTypeId().userType() ) { resultType = getTypeServices(); }
1:         else { resultType = DataTypeDescriptor.getSQLDataTypeDescriptor(stjvn.getJavaTypeName()); }
1: 
1: 		jtsvn.setType( resultType );
1: 
commit:2732872
/////////////////////////////////////////////////////////////////////////
1:         // bind the type in case it is a user defined type. this will create a dependency on the udt.
1:         if ( dataTypeServices != null )
1:         {
1:             dataTypeServices = bindUserType( dataTypeServices );
1:         }
1: 		this.dataTypeServices = dataTypeServices;
1:         
commit:d6c2047
/////////////////////////////////////////////////////////////////////////
1: 
1:         // create a dependency on this type if it is an ANSI UDT
1:         if ( dataTypeServices != null ) { createTypeDependency( dataTypeServices ); }
commit:95a483d
/////////////////////////////////////////////////////////////////////////
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:09c30dd
/////////////////////////////////////////////////////////////////////////
1:      * Transform this into this IS NULL or IS NOT NULL.
1:      * @param notNull if true, transform this into IS NOT NULL;
1:      *                otherwise, transform this into IS NULL
1:     ValueNode genIsNullTree(boolean notNull)
1:         isNullNode = new IsNullNode(this, notNull, getContextManager());
commit:8fe3166
/////////////////////////////////////////////////////////////////////////
1:     final void generate(ActivationClassBuilder acb, MethodBuilder mb)
/////////////////////////////////////////////////////////////////////////
1:     void generateExpression(ExpressionClassBuilder acb, MethodBuilder mb)
commit:09c2697
/////////////////////////////////////////////////////////////////////////
1:     ValueNode bindExpression(
0:             FromList fromList, SubqueryList subqueryList, List aggregates)
1:         return bindExpression(fromList, subqueryList, aggregates, false);
/////////////////////////////////////////////////////////////////////////
1:      * @param aggregates        The aggregate list being built as we find AggregateNodes
0:     ValueNode bindExpression(
0:             FromList fromList, SubqueryList subqueryList, List aggregates, boolean forQueryRewrite)
commit:f33fbaf
/////////////////////////////////////////////////////////////////////////
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
0:             FromList fromList, SubqueryList subqueryList, List aggregateVector)
/////////////////////////////////////////////////////////////////////////
0: 			List aggregateVector, boolean forQueryRewrite)
commit:e6a9998
/////////////////////////////////////////////////////////////////////////
0:         QueryTreeNode trueNode = (QueryTreeNode) nodeFactory.getNode(
commit:568cbf1
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * If this node is known to always evaluate to the same value, return a
1:      * node that represents that known value as a constant. Typically used to
1:      * transform operators with constant operands into constants.
1:      *
1:      * @return a constant representing the value to which this node is
1:      * guaranteed to evaluate, or {@code this} if the value is not known
1:      * @throws StandardException if an error occurs during evaluation
1:      * @see ConstantExpressionVisitor
1:      */
1:     ValueNode evaluateConstantExpressions() throws StandardException {
1:         // We normally don't know what the node evaluates to up front, so
1:         // don't do anything in the default implementation.
1:         return this;
1:     }
1: 
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
commit:1d4b49f
/////////////////////////////////////////////////////////////////////////
1: 	 * <p> 
1: 	 * This method provides basic expression matching facility for the derived 
1: 	 * class of ValueNode and it is used by the language layer to compare the 
1: 	 * node structural form of the two expressions for equivalence at bind 
1: 	 * phase.  
1: 	 *  <p>
1: 	 * Note that it is not comparing the actual row values at runtime to produce 
1: 	 * a result; hence, when comparing SQL NULLs, they are considered to be 
1: 	 * equivalent and not unknown.  
1: 	 *  <p>
1: 	 * One usage case of this method in this context is to compare the select 
1: 	 * column expression against the group by expression to check if they are 
1: 	 * equivalent.  e.g.:
1: 	 *  <p>
1: 	 * SELECT c1+c2 FROM t1 GROUP BY c1+c2   
1: 	 *  <p>
1: 	 * In general, node equivalence is determined by the derived class of 
1: 	 * ValueNode.  But they generally abide to the rules below:
1: 	 *  <ul>
1: 	 * <li>The two ValueNodes must be of the same node type to be considered 
1: 	 *   equivalent.  e.g.:  CastNode vs. CastNode - equivalent (if their args 
1: 	 *   also match), ColumnReference vs CastNode - not equivalent.
1: 	 *   
1: 	 * <li>If node P contains other ValueNode(s) and so on, those node(s) must 
1: 	 *   also be of the same node type to be considered equivalent.
1: 	 *   
1: 	 * <li>If node P takes a parameter list, then the number of arguments and its 
1: 	 *   arguments for the two nodes must also match to be considered 
1: 	 *   equivalent.  e.g.:  CAST(c1 as INTEGER) vs CAST(c1 as SMALLINT), they 
1: 	 *   are not equivalent.
1: 	 *   
1: 	 * <li>When comparing SQL NULLs in this context, they are considered to be 
1: 	 *   equivalent.
1: 	 * <li>If this does not apply or it is determined that the two nodes are not 
1: 	 *   equivalent then the derived class of this method should return false; 
1: 	 *   otherwise, return true.
1: 	 * </ul>   
1: 	 *   
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:7b87db0
/////////////////////////////////////////////////////////////////////////
1:      * overridden by all node classes that represent several kinds.
1:      * This default implementation does not look at kinds.
commit:19aa0ac
/////////////////////////////////////////////////////////////////////////
1:      * It is only called from implementations of {@code isEquivalent}.
commit:eb88678
/////////////////////////////////////////////////////////////////////////
1:      * This means that implementations of {@link #isEquivalent}
0:      * It is only called from implementations of {@code #isEquivalent}.
commit:2706d1f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 BinaryRelationalOperatorNode.K_EQUALS,
1:                 this,
1:                 falseNode,
1:                 false,
1:                 getContextManager());
/////////////////////////////////////////////////////////////////////////
0:        isNullNode = new IsNullNode(this, false, getContextManager());
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Some node classes represent several logical node types (to reduce
1:      * footprint), which we call <em>kinds</em>.
0:      * This means that implementations of {@link #isEquivalent()}
1:      * cannot always just use {@code instanceof} to check if the other node
1:      * represents the same kind. Hence this method needs to be
0:      * implemented by all node classes that represent several kinds.
0:      * It is only called from implementations of {@code isEquivalent}.
1:      *
1:      * @param other The other value node whose kind we want to compare with.
1:      * @return {@code true} if {@code this} and {@code o} represent the same
1:      *         logical node type, i.e. kind.
1:      */
1:     boolean isSameNodeKind(ValueNode other) {
1:         // Default implementation does not look at kinds.
1:         return other != null && other.getClass().equals(this.getClass());
1:     }
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.context.ContextManager;
/////////////////////////////////////////////////////////////////////////
1:     ValueNode(ContextManager cm) {
1:         super(cm);
/////////////////////////////////////////////////////////////////////////
1:         setType(new DataTypeDescriptor(typeId, isNullable, maximumWidth));
/////////////////////////////////////////////////////////////////////////
1:                             typeId,
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     DataTypeDescriptor getTypeServices()
/////////////////////////////////////////////////////////////////////////
1:     TypeId getTypeId() throws StandardException
/////////////////////////////////////////////////////////////////////////
1:     final TypeCompiler getTypeCompiler() throws StandardException
/////////////////////////////////////////////////////////////////////////
1:     void setType(DataTypeDescriptor dataTypeServices) throws StandardException
/////////////////////////////////////////////////////////////////////////
1:     ResultColumn getSourceResultColumn()
/////////////////////////////////////////////////////////////////////////
1:     ValueNode bindExpression(FromList fromList,
1:                              SubqueryList subqueryList,
1:                              List<AggregateNode> aggregates,
1:                              boolean forQueryRewrite) throws StandardException
/////////////////////////////////////////////////////////////////////////
1:     ValueNode genSQLJavaSQLTree()
/////////////////////////////////////////////////////////////////////////
1:         final ContextManager cm = getContextManager();
1:         JavaValueNode stjvn = new SQLToJavaValueNode(this, cm);
1:         ValueNode jtsvn = new JavaToSQLValueNode(stjvn, cm);
/////////////////////////////////////////////////////////////////////////
1:     ValueNode preprocess(int numTables,
/////////////////////////////////////////////////////////////////////////
1:     ValueNode genEqualsFalseTree()
1:         falseNode = new BooleanConstantNode(false, getContextManager());
1:         equalsNode = new BinaryRelationalOperatorNode(
0:                                 false,
/////////////////////////////////////////////////////////////////////////
0:     ValueNode genIsNullTree()
0:        isNullNode = new IsNullNode(
0:                 this, IsNullNode.Sign.IS_NULL, getContextManager());
/////////////////////////////////////////////////////////////////////////
1:     ValueNode putAndsOnTop()
1:         BooleanConstantNode trueNode =
1:                 new BooleanConstantNode(true, getContextManager());
1:         AndNode andNode = new AndNode(this, trueNode, getContextManager());
/////////////////////////////////////////////////////////////////////////
1:     boolean verifyPutAndsOnTop()
/////////////////////////////////////////////////////////////////////////
1:     ValueNode changeToCNF(boolean underTopAndNode)
/////////////////////////////////////////////////////////////////////////
1:     boolean verifyChangeToCNF()
/////////////////////////////////////////////////////////////////////////
1:     boolean categorize(JBitSet referencedTabs, boolean simplePredsOnly)
/////////////////////////////////////////////////////////////////////////
1:     String getSchemaName() throws StandardException
/////////////////////////////////////////////////////////////////////////
1:     String getTableName()
/////////////////////////////////////////////////////////////////////////
1:     String getColumnName()
/////////////////////////////////////////////////////////////////////////
1:     boolean isCloneable()
/////////////////////////////////////////////////////////////////////////
1:     ValueNode getClone() throws StandardException
/////////////////////////////////////////////////////////////////////////
1:     void copyFields(ValueNode oldVN) throws StandardException
/////////////////////////////////////////////////////////////////////////
1:     ValueNode remapColumnReferencesToExpressions() throws StandardException
/////////////////////////////////////////////////////////////////////////
1:     boolean isConstantExpression()
/////////////////////////////////////////////////////////////////////////
1:     boolean constantExpression(PredicateList whereClause)
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     boolean isRelationalOperator()
/////////////////////////////////////////////////////////////////////////
1:     boolean isBinaryEqualsOperatorNode()
/////////////////////////////////////////////////////////////////////////
1:     boolean isInListProbeNode()
/////////////////////////////////////////////////////////////////////////
1:     boolean optimizableEqualityNode(Optimizable optTable,
/////////////////////////////////////////////////////////////////////////
1:     boolean requiresTypeFromContext()
/////////////////////////////////////////////////////////////////////////
1:     boolean isParameterNode()
/////////////////////////////////////////////////////////////////////////
1:     abstract boolean isEquivalent(ValueNode other)
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:8c15184
/////////////////////////////////////////////////////////////////////////
0: 								Boolean.FALSE,
commit:f63b7da
/////////////////////////////////////////////////////////////////////////
1: 	
1: 	/**
1: 	 * There are many subclasses of ValueNode where we want the 
1: 	 * DataTypeDescriptor of the node to have the same collation type as the 
1: 	 * compilation schema's collation type. For that purpose, this method in 
1: 	 * the baseclass here can be utilized by the subclasses. In addition, the
1: 	 * subclasses can pass the collationDerivation that they expect the
1: 	 * DataTypeDescriptor to have.
1: 	 * 
1: 	 * @param collationDerivation This can be 
1: 	 * StringDataValue#COLLATION_DERIVATION_IMPLICIT
1: 	 * StringDataValue#COLLATION_DERIVATION_NONE
1: 	 * StringDataValue#COLLATION_DERIVATION_EXPLICIT
1: 	 * 
1: 	 * @throws StandardException
1: 	 */
0: 	protected void setCollationUsingCompilationSchema(int collationDerivation)
1: 	throws StandardException {
0: 		dataTypeServices.setCollationType(
0: 	    	     getSchemaDescriptor(null).getCollationType());
0: 		dataTypeServices.setCollationDerivation(collationDerivation);
1: 	}
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:9ed7c4d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.types.StringDataValue;
/////////////////////////////////////////////////////////////////////////
1: 	 * Set the collation based upon the current schema with derivation
1: 	 * type implicit.
1: 	 * 
1: 	 * @throws StandardException
1: 	 */
1: 	protected final void setCollationUsingCompilationSchema()
1: 	throws StandardException {
1: 		setCollationUsingCompilationSchema(
1: 				StringDataValue.COLLATION_DERIVATION_IMPLICIT);
1: 	}	
1: 	
1: 	/**
/////////////////////////////////////////////////////////////////////////
1: 	protected final void setCollationUsingCompilationSchema(int collationDerivation)
commit:b25481f
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Set the collation type and derivation of this node based upon
1:      * the collation information in the passed in type. Note that the
1:      * base type of this node is not changed (e.g. INTEGER), only its
1:      * collation settings. This may result in a different object being
1:      * returned from getTypeServices().
1:      * 
1:      * @param collationInfoType Type to take collation type and derivation from.
1:      * @throws StandardException Error setting type.
1:      */
1:     public void setCollationInfo(DataTypeDescriptor collationInfoType)
1:     throws StandardException
1:     {
1:         setCollationInfo(collationInfoType.getCollationType(),
1:                 collationInfoType.getCollationDerivation());
1:     }
1: 
1:     /**
1:      * Set the collation type and derivation of this node based upon
1:      * the collation information passed in.
1:      * This may result in a different object being
1:      * returned from getTypeServices().
1:      * 
1:      * @param collationType Collation type
1:      * @param collationDerivation Collation derivation
1:      * @throws StandardException Error setting type
1:      */
1:     public void setCollationInfo(int collationType, int collationDerivation)
1:         throws StandardException
1:     {
1:         setType(getTypeServices().getCollatedType(
1:                 collationType, collationDerivation));
1:     }
/////////////////////////////////////////////////////////////////////////
1:         setCollationInfo(
1:                 getSchemaDescriptor(null, false).getCollationType(),
1:                 collationDerivation);
commit:ed82406
/////////////////////////////////////////////////////////////////////////
1: 	private DataTypeDescriptor	dataTypeServices;
/////////////////////////////////////////////////////////////////////////
0: 	public DataTypeDescriptor getTypeServices()
1:     
1:     /**
1:      * Set the nullability of this value.
1:      * @throws StandardException 
1:      */
1:     public void setNullability(boolean nullability) throws StandardException
1:     {
1:         setType(getTypeServices().getNullabilityType(nullability));
1:     }
/////////////////////////////////////////////////////////////////////////
commit:e2f08d2
/////////////////////////////////////////////////////////////////////////
1: 	 * context in which it is getting used. If true is returned then
1:      * after bindExpression() is called on the node, its type
1:      * must be set (from the relevant context) using setType().
commit:ef158f2
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.services.compiler.MethodBuilder;
0: import org.apache.derby.iapi.services.i18n.MessageService;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
0: import org.apache.derby.iapi.sql.compile.CompilerContext;
0: import org.apache.derby.iapi.sql.compile.NodeFactory;
1: import org.apache.derby.iapi.sql.compile.Optimizable;
1: import org.apache.derby.iapi.sql.compile.TypeCompiler;
1: import org.apache.derby.iapi.store.access.Qualifier;
1: import org.apache.derby.iapi.types.DataTypeDescriptor;
1: import org.apache.derby.iapi.types.DataValueFactory;
1: import org.apache.derby.iapi.types.TypeId;
1: import org.apache.derby.iapi.util.JBitSet;
1: 
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * The data type for this node.
1:      */
1:    
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Set this node's type from type components.
1:      */
1:     final void setType(TypeId typeId,
1:             boolean isNullable,
1:             int maximumWidth)
1:        throws StandardException
1:        
1:        {
1:         setType(
1:                 new DataTypeDescriptor(
0:                             (TypeId) typeId,
1:                             isNullable,
1:                             maximumWidth
1:                         )
1:                     );           
1:        }
1: 
1:     /**
1:      * Set this node's type from type components.
1:      */
1:     final void setType(TypeId typeId,
1:             int precision, int scale,
1:             boolean isNullable,
1:             int maximumWidth)
1:        throws StandardException
1:     {
1:         setType(
1:                 new DataTypeDescriptor(
0:                             (TypeId) typeId,
1:                             precision,
1:                             scale,
1:                             isNullable,
1:                             maximumWidth
1:                         )
1:                     );   
1:     }
/////////////////////////////////////////////////////////////////////////
1:         DataTypeDescriptor dtd = getTypeServices();
1:         if (dtd != null)
1:             return dtd.getTypeId();
1: 		return null;
/////////////////////////////////////////////////////////////////////////
1: 	 * Get the TypeCompiler from this ValueNode, based on its TypeId
1:      * using getTypeId().
0: 	public final TypeCompiler getTypeCompiler() throws StandardException
1: 		return getTypeCompiler(getTypeId());
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         getTypeServices().setCollationType(
0:         getTypeServices().setCollationDerivation(collationDerivation);
/////////////////////////////////////////////////////////////////////////
1: 			SanityManager.ASSERT(getTypeId() != null,
1: 			SanityManager.ASSERT(getTypeId().userType(),
/////////////////////////////////////////////////////////////////////////
1: 				getTypeId().isBooleanTypeId(),
1: 					getTypeId().getSQLTypeName() +
/////////////////////////////////////////////////////////////////////////
1: 		nullableResult = getTypeServices().isNullable();
/////////////////////////////////////////////////////////////////////////
commit:e9ec322
/////////////////////////////////////////////////////////////////////////
1: 	 * @return	The source of this ValueNode, null if this node
1:      * is not sourced by a column.
commit:065d697
/////////////////////////////////////////////////////////////////////////
0: 	    	     getSchemaDescriptor(null, false).getCollationType());
commit:01217c2
/////////////////////////////////////////////////////////////////////////
1: 	
1: 	/**
1: 	 * Tests if this node is equivalent to the specified ValueNode. Two 
1: 	 * ValueNodes are considered equivalent if they will evaluate to the same
1: 	 * value during query execution. 
1: 	 * 
1: 	 * @param other the node to compare this ValueNode against.
1: 	 * @return <code>true</code> if the two nodes are equivalent, 
1: 	 * <code>false</code> otherwise.
1: 	 * 
1: 	 * @throws StandardException 
1: 	 */
0: 	protected abstract boolean isEquivalent(ValueNode other)
1: 		throws StandardException;
1: 	/**
0: 	 * Tests if this node is of the same type as the specified node as
0: 	 * reported by {@link QueryTreeNode#getNodeType()}.
1: 	 * 
0: 	 * @param other the node to compare this value node against. 
1: 	 * 
0: 	 * @return <code>true</code> if the two nodes are of the same type.  
1: 	 */
0: 	protected final boolean isSameNodeType(ValueNode other)
1: 	{
0: 		if (other != null) {
0: 			return other.getNodeType() == getNodeType();
1: 		}
1: 		return false;
1: 	}
1: 	
commit:08d6ce2
/////////////////////////////////////////////////////////////////////////
1: 		if (whereTypeId.userType())
commit:b57ee34
/////////////////////////////////////////////////////////////////////////
1: 	 * This returns the user-supplied schema name of the column.
1: 	 * At this class level, it simply returns null. But, the subclasses
1: 	 * of ValueNode will overwrite this method to return the
1: 	 * user-supplied schema name.
1: 	 * 
/////////////////////////////////////////////////////////////////////////
0: 	public String getSchemaName() throws StandardException
1: 	 * This returns the user-supplied table name of the column.
1: 	 * At this class level, it simply returns null. But, the subclasses
1: 	 * of ValueNode will overwrite this method to return the
1: 	 * user-supplied table name.
1: 	 *
1: 	 * When the value node is in a result column of a select list,
1: 	 * the user can request metadata information. The result column
1: 	 * won't have a column descriptor, so we return some default
1: 	 * information through the expression. This lets expressions that
1: 	 * are simply columns return all of the info, and others use
1: 	 * this supertype's default values.
1: 	 *
1: 	 * @return the default table name for an expression -- null
/////////////////////////////////////////////////////////////////////////
1: 	 * @return the default updatability for an expression - false
1: 	 */
1: 	public boolean updatableByCursor()
1: 	{
1: 		return false;
1: 	}
1: 
1: 	/**
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.compile.ValueNode
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:61070a6
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package	org.apache.derby.impl.sql.compile;
1: 
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: import org.apache.derby.iapi.types.TypeId;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.iapi.sql.compile.TypeCompiler;
0: import org.apache.derby.iapi.types.DataValueFactory;
1: 
0: import org.apache.derby.iapi.types.SQLChar;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
0: import org.apache.derby.iapi.sql.compile.CompilerContext;
0: import org.apache.derby.iapi.sql.compile.Optimizable;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
0: import org.apache.derby.iapi.sql.compile.NodeFactory;
1: 
0: import org.apache.derby.iapi.reference.SQLState;
1: 
0: import org.apache.derby.iapi.store.access.Qualifier;
1: 
0: import org.apache.derby.impl.sql.compile.ActivationClassBuilder;
0: import org.apache.derby.impl.sql.compile.ExpressionClassBuilder;
1: 
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1: 
0: import org.apache.derby.iapi.util.JBitSet;
0: import org.apache.derby.iapi.services.i18n.MessageService;
1: 
0: import java.lang.reflect.Modifier;
1: 
0: import java.sql.Date;
0: import java.sql.Time;
0: import java.sql.Timestamp;
1: 
0: import java.util.Vector;
1: 
1: /**
1:  * A ValueNode is an abstract class for all nodes that can represent data
1:  * values, that is, constants, columns, and expressions.
1:  *
0:  * @author Jeff Lichtman
1:  */
1: 
1: public abstract class ValueNode extends QueryTreeNode
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	public static final int IN_UNKNOWN_CLAUSE = 0;
0: 	public static final int IN_SELECT_LIST = 1;
0: 	public static final int IN_WHERE_CLAUSE = 2;
0: 	public static final int IN_HAVING_CLAUSE = 3;
1: 
0: 	protected DataTypeDescriptor	dataTypeServices;
0: 	private TypeId typeId;	   
0: 	private TypeCompiler typeCompiler;
0: 	protected int				clause = IN_UNKNOWN_CLAUSE;
1: 
1: 	// Whether or not additional predicates have been created from this one.
1: 	boolean	transformed;
1: 
1: 	/*
1: 	** Constructor for untyped ValueNodes, for example, untyped NULLs
1: 	** and parameter nodes.
1: 	**
1: 	** Binding will replace all untyped ValueNodes with typed ValueNodes
1: 	** when it figures out what their types should be.
1: 	*/
0: 	public ValueNode()
1: 	{
1: 	}
1: 
1: 	/**
0: 	 * Initializer for numeric types.
1: 	 * 
1: 	 *
0: 	 * @param typeId	The TypeID of this new node
0: 	 * @param precision	The precision of this new node
0: 	 * @param scale		The scale of this new node
0: 	 * @param isNullable	The nullability of this new node
0: 	 * @param maximumWidth	The maximum width of this new node
1: 	 *
0: 	 * @return	Nothing
1: 	 *
0: 	 * @exception StandardException
1: 	 */
1: 
0: 	public void init(
0: 			Object typeId,
0: 			Object precision,
0: 			Object scale,
0: 			Object isNullable,
0: 			Object maximumWidth)
1: 		throws StandardException
1: 	{
0: 		setType(
0: 			new DataTypeDescriptor(
0: 						(TypeId) typeId,
0: 						((Integer) precision).intValue(),
0: 						((Integer) scale).intValue(),
0: 						((Boolean) isNullable).booleanValue(),
0: 						((Integer) maximumWidth).intValue()
0: 					)
1: 				);
1: 	}
1: 
1: 	/**
0: 	 * Initializer for non-numeric types.
1: 	 * 
1: 	 *
0: 	 * @param tcf		The factory to get the
0: 	 *					DataTypeServicesFactory from
0: 	 * @param typeId	The TypeID of this new node
0: 	 * @param isNullable	The nullability of this new node
0: 	 * @param maximumWidth	The maximum width of this new node
1: 	 *
0: 	 * @exception StandardException
1: 	 */
1: 
0: 	ValueNode(
0: 			Object tcf,
0: 			Object typeId,
0: 			Object isNullable,
0: 			Object maximumWidth)
1: 		throws StandardException
1: 	{
0: 		setType(new DataTypeDescriptor(
0: 						(TypeId) typeId,
0: 						((Boolean) isNullable).booleanValue(),
0: 						((Integer) maximumWidth).intValue()
0: 						)
1: 				);
1: 	}
1: 
1: 			
1: 	/**
1: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
1: 	 * for how this should be done for tree printing.
1: 	 *
1: 	 * @return	This object as a String
1: 	 */
1: 
1: 	public String toString()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			return "dataTypeServices: " +
1: 				( ( dataTypeServices != null) ?
1: 						dataTypeServices.toString() : "null" ) + "\n" +
0: 				"clause: " + clause + "\n" +
1: 				super.toString();
1: 		}
1: 		else
1: 		{
1: 			return "";
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Get the DataTypeServices from this ValueNode.
1: 	 *
1: 	 * @return	The DataTypeServices from this ValueNode.  This
1: 	 *		may be null if the node isn't bound yet.
1: 	 */
0: 	public DataTypeDescriptor getTypeServices()
1: 	{
1: 		return dataTypeServices;
1: 	}
1: 
1: 	/**
1: 	 * Get the TypeId from this ValueNode.
1: 	 *
1: 	 * @return	The TypeId from this ValueNode.  This
1: 	 *		may be null if the node isn't bound yet.
1: 	 */
0: 	public TypeId getTypeId()
1: 	{
0: 		return typeId;
1: 	}
1: 
1: 
1: 	/**
1: 		Return the DataValueFactory
1: 	*/
1: 	protected final DataValueFactory getDataValueFactory() {
1: 		return getLanguageConnectionContext().getDataValueFactory();
1: 	}
1: 
1: 	/**
0: 	 * Get the TypeCompiler from this ValueNode, based on its TypeId.
1: 	 *
1: 	 * @return	This ValueNode's TypeCompiler
1: 	 *
1: 	 */
0: 	public TypeCompiler getTypeCompiler()
1: 	{
0: 		if (typeCompiler == null)
1: 		{
1: 			/*
0: 			** getTypeId() is overriddend by parameter node so
0: 			** don't get smart and remove the extra method call.
1: 			*/
0: 			typeCompiler = getTypeCompiler(getTypeId());
1: 		}
1: 
0: 		return typeCompiler;
1: 	}
1: 
1: 	/**
0: 	 * Set the DataTypeServices in this ValueNode.
1: 	 *
1: 	 * @param dataTypeServices	The DataTypeServices to set in this
1: 	 *				ValueNode
1: 	 *
0: 	 * @return	Nothing
1: 	 */
1: 
0: 	public void setType(DataTypeDescriptor dataTypeServices)
1: 	{
0: 		this.dataTypeServices = dataTypeServices;
1: 
0: 		/* Get this now so we only have to cast it once */
0: 		if (dataTypeServices == null)
0: 			typeId = null;
1: 		else
0: 			typeId = dataTypeServices.getTypeId();
1: 
0: 		// Clear the typeCompiler, just in case type has changed
0: 		typeCompiler = null;
1: 	}
1: 
1: 	/**
1: 	 * Set the DataTypeServices for this ValueNode.  This method is
1: 	 * overridden in ParameterNode.
1: 	 *
0: 	 * @param descriptor	The DataTypeServices to set for this ValueNode
1: 	 *
0: 	 * @return	Nothing
1: 	 *
1: 	 */
1: 
0: 	public void setDescriptor(DataTypeDescriptor descriptor)
1: 	{
0: 		setType(descriptor);
1: 	}
1: 
1: 	/**
1: 	 * Get the source for this ValueNode.
1: 	 *
0: 	 * @return	The source of this ValueNode.
1: 	 */
1: 
0: 	public ResultColumn getSourceResultColumn()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		SanityManager.ASSERT(false,
0: 			"getSourceResultColumn() not expected to be called for this node - " +
0: 			getClass().toString());
1: 		return null;
1: 	}
1: 
1: 	/**
0: 	 * Get the clause that this node appears in.
1: 	 *
0: 	 * @return int	The clause that this node appears in.
1: 	 */
0: 	public int getClause()
1: 	{
0: 		return clause;
1: 	}
1: 
1: 	/**
0: 	 * Set the clause that this node appears in.
1: 	 *
0: 	 * @param clause	The clause that this node appears in.
1: 	 *
0: 	 * @return Nothing.
1: 	 */
0: 	public void setClause(int clause)
1: 	{
0: 		this.clause = clause;
1: 	}
1: 
1: 	/**
1: 	 * Mark this predicate has having been transformed (other predicates
1: 	 * were generated from it).  This will help us with ensure that the
1: 	 * predicate does not get calculated into the selectivity multiple
1: 	 * times.
1: 	 *
0: 	 * @return Nothing.
1: 	 */
1: 	void setTransformed()
1: 	{
1: 		transformed = true;
1: 	}
1: 
1: 	/** 
1: 	 * Return whether or not this predicate has been transformed.
1: 	 *
1: 	 * @return Whether or not this predicate has been transformed.
1: 	 */
1: 	boolean getTransformed()
1: 	{
1: 		return transformed;
1: 	}
1: 
1: 	
0: 	public ValueNode bindExpression(
0: 									FromList fromList, SubqueryList subqueryList,
0: 									Vector	aggregateVector)
1: 		throws StandardException
1: 	{
0: 		return bindExpression(fromList, subqueryList, aggregateVector,false);
1: 	}
1: 	
1: 
1: 	/**
1: 	 * Bind this expression.  This is a place-holder method - it should never
1: 	 * be called.
1: 	 *
1: 	 * @param fromList			The FROM list to use for binding
1: 	 * @param subqueryList		The SubqueryList we are building as we hit
1: 	 *							SubqueryNodes.
0: 	 * @param aggregateVector	The aggregate vector being built as we find AggregateNodes
1: 	 *
1: 	 * @return	The new top of the expression tree.
1: 	 *
1: 	 * @exception StandardException	Thrown on error
1: 	 */
1: 
0: 	public ValueNode bindExpression(
0: 			FromList fromList, SubqueryList subqueryList,
0: 			Vector aggregateVector, boolean forQueryRewrite) 
1: 				throws StandardException
1: 	{
1: 		/* There are a bizillion classes which extend ValueNode.  Here is info
1: 		 * on some of the classes that bindExpression() should not be called on
1: 		 * and why:
1: 		 *	o  BaseColumnNodes should only appear under the ResultColumnList
1: 		 *     in the FromBaseTable.  They are created/bound when binding the
1: 		 *     FromBaseTable.
1: 		 */
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(false, 
1: 						"bindExpression() not expected to be called on a " + 
1: 						this.getClass().toString());
1: 		}
1: 
1: 		return this;
1: 	}
1: 
1: 	/**
0: 	 * Generate a SQL->Java->SQL conversion tree above the current node
1: 	 * and bind the new nodes individually.
1: 	 * This is useful when doing comparisons, built-in functions, etc. on
1: 	 * java types which have a direct mapping to system built-in types.
1: 	 *
1: 	 * @return ValueNode	The new tree.
1: 	 *
1: 	 * @exception StandardException	Thrown on error
1: 	 */
0: 	public ValueNode genSQLJavaSQLTree()
1: 		throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			SanityManager.ASSERT(typeId != null,
1: 				"genSQLJavaSQLTree() only expected to be called on a bound node");
0: 			SanityManager.ASSERT(typeId.userType(),
1: 				"genSQLJavaSQLTree() only expected to be called on user types");
1: 		}
1: 
0: 		JavaValueNode stjvn = (JavaValueNode) getNodeFactory().getNode(
0: 									C_NodeTypes.SQL_TO_JAVA_VALUE_NODE,
0: 									this,
0: 									getContextManager());
1: 
0: 		ValueNode jtsvn = (ValueNode) getNodeFactory().getNode(
0: 									C_NodeTypes.JAVA_TO_SQL_VALUE_NODE,
0: 									stjvn,
0: 									getContextManager());
0: 		jtsvn.setType(DataTypeDescriptor.getSQLDataTypeDescriptor(stjvn.getJavaTypeName()));
1: 		return jtsvn;
1: 	}
1: 
1: 	/**
1: 	 * Preprocess an expression tree.  We do a number of transformations
1: 	 * here (including subqueries, IN lists, LIKE and BETWEEN) plus
1: 	 * subquery flattening.
1: 	 * NOTE: This is done before the outer ResultSetNode is preprocessed.
1: 	 *
1: 	 * @param	numTables			Number of tables in the DML Statement
1: 	 * @param	outerFromList		FromList from outer query block
1: 	 * @param	outerSubqueryList	SubqueryList from outer query block
1: 	 * @param	outerPredicateList	PredicateList from outer query block
1: 	 *
1: 	 * @return		The modified expression
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public ValueNode preprocess(int numTables,
1: 								FromList outerFromList,
1: 								SubqueryList outerSubqueryList,
1: 								PredicateList outerPredicateList) 
1: 					throws StandardException
1: 	{
1: 		return this;
1: 	}
1: 
1: 	/**
1: 	 * Eliminate NotNodes in the current query block.  We traverse the tree, 
1: 	 * inverting ANDs and ORs and eliminating NOTs as we go.  We stop at 
1: 	 * ComparisonOperators and boolean expressions.  We invert 
1: 	 * ComparisonOperators and replace boolean expressions with 
1: 	 * boolean expression = false.
1: 	 * NOTE: Since we do not recurse under ComparisonOperators, there
1: 	 * still could be NotNodes left in the tree.
1: 	 *
1: 	 * @param	underNotNode		Whether or not we are under a NotNode.
1: 	 *							
1: 	 *
1: 	 * @return		The modified expression
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	ValueNode eliminateNots(boolean underNotNode) 
1: 					throws StandardException
1: 	{
1: 		if (! underNotNode)
1: 		{
1: 			return this;
1: 		}
1: 
1: 		/* bind() has ensured that this node's type is SQLBoolean */
1: 		if (SanityManager.DEBUG)
1: 		SanityManager.ASSERT(
0: 				dataTypeServices.getTypeId().equals(
0: 												TypeId.BOOLEAN_ID),
1: 					"Node's type (" +
0: 					dataTypeServices.getTypeId().getSQLTypeName() +
1: 					") is expected to be boolean");
1: 
1: 		/* Return ValueNode = false */
1: 		return genEqualsFalseTree();
1: 	}
1: 
1: 	/**
1: 	 * Transform this into this = false.  Useful for NOT elimination.
1: 	 *
1: 	 *
1: 	 * @return		The modified expression
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public ValueNode genEqualsFalseTree()
1: 			throws StandardException
1: 	{
1: 		BinaryRelationalOperatorNode equalsNode;
1: 		BooleanConstantNode		 falseNode;
1: 		boolean 				nullableResult;
0: 		NodeFactory				nodeFactory = getNodeFactory();
1: 
0: 		falseNode = (BooleanConstantNode) nodeFactory.getNode(
0: 									C_NodeTypes.BOOLEAN_CONSTANT_NODE,
0: 									Boolean.FALSE,
0: 									getContextManager());
0: 		equalsNode = (BinaryRelationalOperatorNode)
0: 							nodeFactory.getNode(
0: 								C_NodeTypes.BINARY_EQUALS_OPERATOR_NODE,
0: 								this,
0: 								falseNode,
0: 								getContextManager());
0: 		nullableResult = dataTypeServices.isNullable();
1: 		equalsNode.setType(new DataTypeDescriptor(
1: 									TypeId.BOOLEAN_ID,
1: 									nullableResult)
1: 						  );
1: 		return equalsNode;
1: 	}
1: 
1: 	/**
0: 	 * Transform this into this is null.  Useful for NOT elimination.
1: 	 *
1: 	 * @return		The modified expression
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public ValueNode genIsNullTree()
1: 			throws StandardException
1: 	{
1: 		IsNullNode isNullNode;
1: 
0: 		isNullNode = (IsNullNode)
0: 							getNodeFactory().getNode(
0: 													C_NodeTypes.IS_NULL_NODE,
0: 													this,
0: 													getContextManager());
1: 		isNullNode.setType(new DataTypeDescriptor(
1: 									TypeId.BOOLEAN_ID,
1: 									false)
1: 						  );
1: 		return isNullNode;
1: 	}
1: 
1: 	/**
1: 	 * Verify that eliminateNots() did its job correctly.  Verify that
1: 	 * there are no NotNodes above the top level comparison operators
1: 	 * and boolean expressions.
1: 	 *
1: 	 * @return		Boolean which reflects validity of the tree.
1: 	 */
1: 	boolean verifyEliminateNots()
1: 	{
1: 		if (SanityManager.ASSERT)
1: 		{
1: 			return (! (this instanceof NotNode));
1: 		}
1: 		else
1: 		{
1: 			return true;
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Do the 1st step in putting an expression into conjunctive normal
1: 	 * form.  This step ensures that the top level of the expression is
1: 	 * a chain of AndNodes.
1: 	 *
1: 	 * @return		The modified expression
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public ValueNode putAndsOnTop() 
1: 					throws StandardException
1: 	{
0: 		NodeFactory		nodeFactory = getNodeFactory();
1: 
0:         QueryTreeNode trueNode = nodeFactory.getNode(
0: 										C_NodeTypes.BOOLEAN_CONSTANT_NODE,
0: 										Boolean.TRUE,
0: 										getContextManager());
0: 		AndNode andNode = (AndNode) nodeFactory.getNode(
0: 										C_NodeTypes.AND_NODE,
0: 										this,
0: 										trueNode,
0: 										getContextManager());
1: 		andNode.postBindFixup();
1: 		return andNode;
1: 	}
1: 
1: 	/**
1: 	 * Verify that putAndsOnTop() did its job correctly.  Verify that the top level 
1: 	 * of the expression is a chain of AndNodes.
1: 	 *
1: 	 * @return		Boolean which reflects validity of the tree.
1: 	 */
0: 	public boolean verifyPutAndsOnTop()
1: 	{
1: 		return true;
1: 	}
1: 
1: 	/**
1: 	 * Finish putting an expression into conjunctive normal
1: 	 * form.  An expression tree in conjunctive normal form meets
1: 	 * the following criteria:
1: 	 *		o  If the expression tree is not null,
1: 	 *		   the top level will be a chain of AndNodes terminating
1: 	 *		   in a true BooleanConstantNode.
1: 	 *		o  The left child of an AndNode will never be an AndNode.
1: 	 *		o  Any right-linked chain that includes an AndNode will
1: 	 *		   be entirely composed of AndNodes terminated by a true BooleanConstantNode.
1: 	 *		o  The left child of an OrNode will never be an OrNode.
1: 	 *		o  Any right-linked chain that includes an OrNode will
1: 	 *		   be entirely composed of OrNodes terminated by a false BooleanConstantNode.
1: 	 *		o  ValueNodes other than AndNodes and OrNodes are considered
1: 	 *		   leaf nodes for purposes of expression normalization.
1: 	 *		   In other words, we won't do any normalization under
1: 	 *		   those nodes.
1: 	 *
1: 	 * In addition, we track whether or not we are under a top level AndNode.  
1: 	 * SubqueryNodes need to know this for subquery flattening.
1: 	 *
1: 	 * @param	underTopAndNode		Whether or not we are under a top level AndNode.
1: 	 *							
1: 	 *
1: 	 * @return		The modified expression
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public ValueNode changeToCNF(boolean underTopAndNode) 
1: 					throws StandardException
1: 	{
1: 		return this;
1: 	}
1: 
1: 	/**
1: 	 * Verify that changeToCNF() did its job correctly.  Verify that:
1: 	 *		o  AndNode  - rightOperand is not instanceof OrNode
1: 	 *				      leftOperand is not instanceof AndNode
1: 	 *		o  OrNode	- rightOperand is not instanceof AndNode
1: 	 *					  leftOperand is not instanceof OrNode
1: 	 *
1: 	 * @return		Boolean which reflects validity of the tree.
1: 	 */
0: 	public boolean verifyChangeToCNF()
1: 	{
1: 		return true;
1: 	}
1: 
1: 	/**
1: 	 * Categorize this predicate.  Initially, this means
1: 	 * building a bit map of the referenced tables for each predicate.
1: 	 * If the source of this ColumnReference (at the next underlying level) 
1: 	 * is not a ColumnReference or a VirtualColumnNode then this predicate
1: 	 * will not be pushed down.
1: 	 *
1: 	 * For example, in:
1: 	 *		select * from (select 1 from s) a (x) where x = 1
1: 	 * we will not push down x = 1.
1: 	 * NOTE: It would be easy to handle the case of a constant, but if the
1: 	 * inner SELECT returns an arbitrary expression, then we would have to copy
1: 	 * that tree into the pushed predicate, and that tree could contain
1: 	 * subqueries and method calls.
1: 	 * RESOLVE - revisit this issue once we have views.
1: 	 *
1: 	 * @param referencedTabs	JBitSet with bit map of referenced FromTables
1: 	 * @param simplePredsOnly	Whether or not to consider method
1: 	 *							calls, field references and conditional nodes
1: 	 *							when building bit map
1: 	 *
1: 	 * @return boolean		Whether or not source.expression is a ColumnReference
1: 	 *						or a VirtualColumnNode.
1: 	 *
1: 	 * @exception StandardException			Thrown on error
1: 	 */
0: 	public boolean categorize(JBitSet referencedTabs, boolean simplePredsOnly)
1: 		throws StandardException
1: 	{
1: 		return true;
1: 	}
1: 
1: 	/**
1: 	 * When the value node is in a result column of a select list,
1: 	 * the user can request metadata information. The result column
1: 	 * won't have a column descriptor, so we return some default
1: 	 * information through the expression. This lets expressions that
1: 	 * are simply columns return all of the info, and others use
1: 	 * this supertype's default values.
1: 	 *
1: 	 * @return the default schema name for an expression -- null
1: 	 */
0: 	public String getSchemaName()
1: 	{
1: 		return null;
1: 	}
1: 
1: 	/**
1: 	 * @return the default schema name for an expression -- null
1: 	 */
0: 	public String getTableName()
1: 	{
1: 		return null;
1: 	}
1: 
1: 	/**
1: 	 * This is null so that the caller will substitute in the resultset generated
1: 	 * name as needed.
1: 	 *
1: 	 * @return the default column name for an expression -- null.
1: 	 */
0: 	public String getColumnName()
1: 	{
1: 		return null;
1: 	}
1: 
1: 	/**
1: 	 * Get a bit map of table references in this expression
1: 	 *
1: 	 * @return	A bit map of table numbers referred to in this expression
1: 	 *
1: 	 * @exception StandardException			Thrown on error
1: 	 */
1: 	JBitSet getTablesReferenced()
1: 		throws StandardException
1: 	{
1: 		ReferencedTablesVisitor rtv = new ReferencedTablesVisitor(new JBitSet(0));
1: 		accept(rtv);
1: 		return rtv.getTableMap();
1: 	}
1: 
1: 	/**
1: 	 * Return whether or not this expression tree is cloneable.
1: 	 *
1: 	 * @return boolean	Whether or not this expression tree is cloneable.
1: 	 */
0: 	public boolean isCloneable()
1: 	{
1: 		return false;
1: 	}
1: 
1: 	/**
1: 	 * Return a clone of this node.
1: 	 *
1: 	 * @return ValueNode	A clone of this node.
1: 	 *
1: 	 * @exception StandardException			Thrown on error
1: 	 */
0: 	public ValueNode getClone() throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(false,
1: 				"getClone() not expected to be called for " +
1: 				getClass().getName());
1: 		}
1: 		return null;
1: 	}
1: 
1: 	/**
1: 	 * Copy all of the "appropriate fields" for a shallow copy.
1: 	 *
1: 	 * @param oldVN		The ValueNode to copy from.
1: 	 *
1: 	 */
0: 	public void copyFields(ValueNode oldVN)
1: 	{
1: 		dataTypeServices = oldVN.getTypeServices();
0: 		typeId = oldVN.getTypeId();
1: 	}
1: 
1: 	/**
1: 	 * Remap all ColumnReferences in this tree to be clones of the
1: 	 * underlying expression.
1: 	 *
1: 	 * @return ValueNode			The remapped expression tree.
1: 	 *
1: 	 * @exception StandardException			Thrown on error
1: 	 */
0: 	public ValueNode remapColumnReferencesToExpressions() throws StandardException
1: 	{
1: 		return this;
1: 	}
1: 
1: 	/**
1: 	 * Return whether or not this expression tree represents a constant expression.
1: 	 *
1: 	 * @return	Whether or not this expression tree represents a constant expression.
1: 	 */
0: 	public boolean isConstantExpression()
1: 	{
1: 		return false;
1: 	}
1: 
1: 	/**
1: 	 * Return whether or not this expression tree represents a constant value.
1: 	 * In this case, "constant" means that it will always evaluate to the
1: 	 * same thing, even if it includes columns.  A column is constant if it
1: 	 * is compared to a constant expression.
1: 	 *
1: 	 * @return	True means this expression tree represents a constant value.
1: 	 */
0: 	public boolean constantExpression(PredicateList whereClause)
1: 	{
1: 		return false;
1: 	}
1: 
1: 	/**
0: 	  * Bind time logic. Raises an error if this ValueNode, once compiled, returns
0: 	  * unstable results AND if we're in a context where unstable results are
0: 	  * forbidden.
1: 	  *
0: 	  * Called by children who may NOT appear in the WHERE subclauses of ADD TABLE clauses.
1: 	  *
0: 	  *	@param	fragmentType	Type of fragment as a String, for inclusion in error messages.
0: 	  *	@param	fragmentBitMask	Type of fragment as a bitmask of possible fragment types
1: 	  *
1: 	  * @exception StandardException		Thrown on error
1: 	  */
0: 	public	void	checkReliability( String fragmentType, int fragmentBitMask )
1: 		throws StandardException
1: 	{
0: 		// if we're in a context that forbids unreliable fragments, raise an error
0: 		if ( ( getCompilerContext().getReliability() & fragmentBitMask ) != 0 )
1: 		{
0:             throwReliabilityException( fragmentType );
1: 		}
1: 	}
1: 
1: 	/**
0: 	  * Bind time logic. Raises an error if this ValueNode, once compiled, returns
0: 	  * unstable results AND if we're in a context where unstable results are
0: 	  * forbidden.
1: 	  *
0: 	  * Called by children who may NOT appear in the WHERE subclauses of ADD TABLE clauses.
1: 	  *
0: 	  *	@param	fragmentBitMask	Type of fragment as a bitmask of possible fragment types
0: 	  *	@param	fragmentType	Type of fragment as a String, to be fetch for the error message.
1: 	  *
1: 	  * @exception StandardException		Thrown on error
1: 	  */
0: 	public	void	checkReliability( int fragmentBitMask, String fragmentType )
1: 		throws StandardException
1: 	{
0: 		// if we're in a context that forbids unreliable fragments, raise an error
0: 		if ( ( getCompilerContext().getReliability() & fragmentBitMask ) != 0 )
1: 		{
0:             String fragmentTypeTxt = MessageService.getTextMessage( fragmentType );
0:             throwReliabilityException( fragmentTypeTxt );
1: 		}
1: 	}
1: 
1:     /**
0:      * Common code for the 2 checkReliability functions.  Always throws StandardException.
1:      *
0:      * @param fragmentType Type of fragment as a string, for inclusion in error messages.
0:      * @exception StandardException        Throws an error, always.
1:      */
0:     private void throwReliabilityException( String fragmentType ) throws StandardException
1:     {
0:         String sqlState;
0: 		/* Error string somewhat dependent on operation due to different
0: 		 * nodes being allowed for different operations.
1: 		 */
0: 		if (getCompilerContext().getReliability() == CompilerContext.DEFAULT_RESTRICTION)
1: 		{
0:             sqlState = SQLState.LANG_INVALID_DEFAULT_DEFINITION;
1: 		}
1: 		else
1: 		{
0:             sqlState = SQLState.LANG_UNRELIABLE_QUERY_FRAGMENT;
1: 		}
0: 		throw StandardException.newException(sqlState, fragmentType);
1:     }
1: 
1: 	/**
1: 	 * Return the variant type for the underlying expression.
1: 	 * The variant type can be:
1: 	 *		VARIANT				- variant within a scan
1: 	 *							  (method calls and non-static field access)
1: 	 *		SCAN_INVARIANT		- invariant within a scan
1: 	 *							  (column references from outer tables)
1: 	 *		QUERY_INVARIANT		- invariant within the life of a query
1: 	 *							  (constant expressions)
1: 	 *
1: 	 * @return	The variant type for the underlying expression.
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	protected int getOrderableVariantType() throws StandardException
1: 	{
1: 		// The default is VARIANT
1: 		return Qualifier.VARIANT;
1: 	}
1: 
1: 
1: 	/**
1: 	  * Bind time logic. Raises an error if this ValueNode does not resolve to
1: 	  *	a boolean value. This method is called by WHERE clauses.
1: 	  *
1: 	  *	@return	bound coercion of this node to a builtin type as necessary
1: 	  *
1: 	  * @exception StandardException		Thrown on error
1: 	  */
1: 	public	ValueNode	checkIsBoolean()
1: 		throws StandardException
1: 	{
1: 		ValueNode	whereClause = this;
1: 
1: 		/*
1: 		** Is the datatype of the WHERE clause BOOLEAN?
1: 		**
1: 		** NOTE: This test is not necessary in SQL92 entry level, because
1: 		** it is syntactically impossible to have a non-Boolean WHERE clause
1: 		** in that level of the standard.  But we intend to extend the
1: 		** language to allow Boolean user functions in the WHERE clause,
1: 		** so we need to test for the error condition.
1: 		*/
1: 		TypeId whereTypeId = whereClause.getTypeId();
1: 
1: 		/* If the where clause is not a built-in type, then generate a bound 
1: 		 * conversion tree to a built-in type.
1: 		 */
0: 		if (! whereTypeId.systemBuiltIn())
1: 		{
1: 			whereClause = whereClause.genSQLJavaSQLTree();
1: 			whereTypeId = whereClause.getTypeId();
1: 		}
1: 
1: 		if (! whereTypeId.equals(TypeId.BOOLEAN_ID))
1: 		{
1: 			throw StandardException.newException(SQLState.LANG_NON_BOOLEAN_WHERE_CLAUSE, 
1: 				whereTypeId.getSQLTypeName()
1: 				);
1: 		}
1: 
1: 		return	whereClause;
1: 	}
1: 
1: 	/**
1: 	 * Return an Object representing the bind time value of this
1: 	 * expression tree.  If the expression tree does not evaluate to
1: 	 * a constant at bind time then we return null.
1: 	 * This is useful for bind time resolution of VTIs.
1: 	 * RESOLVE: What do we do for primitives?
1: 	 *
1: 	 * @return	An Object representing the bind time value of this expression tree.
1: 	 *			(null if not a bind time constant.)
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	Object getConstantValueAsObject()
1: 		throws StandardException
1: 	{
1: 		return null;
1: 	}
1: 
1: 	/////////////////////////////////////////////////////////////////////////
1: 	//
1: 	//	The ValueNode defers its generate() work to a method that works on
1: 	//	ExpressionClassBuilders rather than ActivationClassBuilders. This
1: 	//	is so that expression generation can be shared by the Core compiler
1: 	//	AND the Replication Filter compiler.
1: 	//
1: 	/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 	/**
1: 	 * Do the code generation for this node.  Call the more general
1: 	 * routine that generates expressions.
1: 	 *
1: 	 * @param acb	The ActivationClassBuilder for the class being built
1: 	 * @param mb	The method the expression will go into
1: 	 *
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	protected final	void generate(ActivationClassBuilder acb,
0: 										MethodBuilder mb)
1: 								throws StandardException
1: 	{
1: 		generateExpression( acb, mb );
1: 	}
1: 
1: 	/**
0: 	 * The only reason this routine exists is so that I don't have to change
0: 	 * the protection on generateExpression() and rototill all of QueryTree.
1: 	 *
0: 	 * @param ecb	The ExpressionClassBuilder for the class being built
1: 	 * @param mb	The method the expression will go into
1: 	 *
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public	void generateFilter(ExpressionClassBuilder ecb,
0: 										MethodBuilder mb)
1: 		throws StandardException
1: 	{
0: 		generateExpression( ecb, mb );
1: 	}
1: 	
1: 
1: 	/**
1: 	 * The default selectivity for value nodes is 50%.  This is overridden
1: 	 * in specific cases, such as the RelationalOperators.
1: 	 */
1: 	public double selectivity(Optimizable optTable)
1: 	{
1: 		// Return 1 if additional predicates have been generated from this one.
1: 		if (transformed)
1: 		{
1: 			return 1.0;
1: 		}
1: 		else
1: 		{
1: 			return 0.5d;
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Update the array of columns in = conditions with expressions without
1: 	 * column references from the same table.  This is useful when doing
1: 	 * subquery flattening on the basis of an equality condition.
1: 	 * eqOuterCols or tableColMap may be null if the calling routine
1: 	 * doesn't need the information provided
1: 	 *
1: 	 * @param tableNumber	The tableNumber of the table from which
1: 	 *						the columns of interest come from.
1: 	 * @param eqOuterCols	Array of booleans for noting which columns
1: 	 *						are in = predicates without columns from the
1: 	 *						subquery block. May be null.
1: 	 * @param tableNumbers	Array of table numbers in this query block.
1: 	 * @param tableColMap	Array of bits for noting which columns
1: 	 *						are in = predicates for each table in the
1: 	 *						query block. May be null.
1: 	 * @param resultColTable True if tableNumber is the table containing result
1: 	 * 						columns
1: 	 *
0: 	 * @return Nothing.
1: 	 *
1: 	 * @exception StandardException			Thrown on error
1: 	 * 
1: 	 */
1: 	void checkTopPredicatesForEqualsConditions(
1: 				int tableNumber, boolean[] eqOuterCols, int[] tableNumbers, 
1: 				JBitSet[] tableColMap, boolean resultColTable)
1: 		throws StandardException
1: 	{
1: 		for (ValueNode whereWalker = this; whereWalker instanceof AndNode; 
1: 			 whereWalker = ((AndNode) whereWalker).getRightOperand())
1: 		{
1: 			// See if this is a candidate =
1: 			AndNode and = (AndNode) whereWalker;
1: 
1: 			if (!and.getLeftOperand().isRelationalOperator() ||
1: 				!(((RelationalOperator)(and.getLeftOperand())).getOperator() == RelationalOperator.EQUALS_RELOP))
1: 			{
1: 				continue;
1: 			}
1: 
1: 			BinaryRelationalOperatorNode beon =
1: 					(BinaryRelationalOperatorNode) and.getLeftOperand();
1: 			ValueNode left = beon.getLeftOperand();
1: 			ValueNode right = beon.getRightOperand();
1: 			int resultTable = 0;
1: 			if (resultColTable)
1: 			{
1: 				for ( ; resultTable < tableNumbers.length; resultTable++)
1: 				{
1: 					if (tableNumbers[resultTable] == tableNumber)
1: 						break;
1: 				}
1: 			}
1: 			else
1: 				resultTable = -1;
1: 
1: 			/* Is this = of the right form? */
1: 			if ((left instanceof ColumnReference) &&
1: 				((ColumnReference) left).getTableNumber() == tableNumber)
1: 			{
1: 				updateMaps(tableColMap, eqOuterCols, tableNumbers, tableNumber,
1: 					resultTable, right, left);
1: 			}
1: 			else if ((right instanceof ColumnReference) &&
1: 					 ((ColumnReference) right).getTableNumber() == tableNumber)
1: 			{
1: 				updateMaps(tableColMap, eqOuterCols, tableNumbers, tableNumber,
1: 					resultTable, left, right);
1: 			}
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Does this represent a true constant.
1: 	 *
1: 	 * @return Whether or not this node represents a true constant.
1: 	 */
1: 	boolean isBooleanTrue()
1: 	{
1: 		return false;
1: 	}
1: 
1: 	/**
1: 	 * Does this represent a false constant.
1: 	 *
1: 	 * @return Whether or not this node represents a false constant.
1: 	 */
1: 	boolean isBooleanFalse()
1: 	{
1: 		return false;
1: 	}
1: 
1: 	/**
1: 	 * Generate code for this calculation.  This is a place-holder method -
1: 	 * it should not be called.
1: 	 *
0: 	 * @param ecb	The ExpressionClassBuilder for the class being built
1: 	 * @param mb	The method the expression will go into
1: 	 *
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public void generateExpression(ExpressionClassBuilder acb,
0: 											MethodBuilder mb)
1: 						throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		SanityManager.ASSERT(false, "Code generation for this type of ValueNode is unimplemented");
1: 	}
1: 
1: 	/**
1: 	 * Set the correct bits in tableColMap and set the boolean value in eqOuterCols 
1: 	 * given two arguments to an = predicate
1: 	 * tableColMap[t] - bit is set if the column is in an = predicate with a column 
1: 	 *					in table t, or a bit is set if the column is in an 
1: 	 *					= predicate with a constant,parameter or correlation variable 
1: 	 *				    (for all table t, if this tableColMap is not for the
1:   	 *					table with the result columns)
1: 	 * eqOuterCols[c] - is true if the column is in an = predicate with a constant,
1: 	 *					parameter or correlation variable
1: 	 * 
1: 	 *
1: 	 * @param tableColMap	Array of bitmaps for noting which columns are in = 
1: 	 *						predicates with columns from each table
1: 	 * @param eqOuterCols	Array of booleans for noting which columns
1: 	 *						are in = predicates without columns from the
1: 	 *						subquery block.
1: 	 * @param tableNumber	table number for which we are setting up the Maps
1: 	 * @param resultTable	-1 if this table is not the result table; otherwise
1: 	 *						the index into tableNumbers for the result table
1: 	 * @param arg1			one side of the = predicate
1: 	 * @param arg2			other side of the = predicate
1: 	 *
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	private void updateMaps(JBitSet[] tableColMap, boolean[] eqOuterCols,
1: 		int[] tableNumbers,  int tableNumber, int resultTable,
1: 		ValueNode arg1, ValueNode arg2)
1: 			throws StandardException
1: 	{
1: 		/* arg2 is a column from our table.  This
1: 		 * is a good = for both All tables and Outer arrays
1: 		 * if the right side is a constant or a parameter
1: 		 * or a column from an outer table.
1: 		 * It is a good = for only the All array if
1: 		 * the right side is a column from this query block.
1: 		 */
0: 		if ((arg1 instanceof ConstantNode) || (arg1.isParameterNode()))
1: 		{
1: 			setValueCols(tableColMap, eqOuterCols,
1: 				((ColumnReference) arg2).getColumnNumber(), resultTable);
1: 		}
1: 		else if((arg1 instanceof ColumnReference &&
1: 					((ColumnReference) arg1).getTableNumber() != tableNumber))
1: 		{
1: 			/* See if other columns is a correlation column */
1: 			int otherTN = ((ColumnReference) arg1).getTableNumber();
1: 			int index = 0;
1: 			int colNumber =	((ColumnReference) arg2).getColumnNumber();
1: 
1: 			for ( ; index < tableNumbers.length; index++)
1: 			{
1: 				if (otherTN == tableNumbers[index])
1: 				{
1: 					break;
1: 				}
1: 			}
1: 			/* Correlation column, so we can treat it as a constant */
1: 			if (index == tableNumbers.length)
1: 			{
1: 				setValueCols(tableColMap, eqOuterCols, colNumber, resultTable);
1: 			}
1: 			else if (tableColMap != null)
1: 			{
1: 				tableColMap[index].set(colNumber);
1: 			}
1: 
1: 		}
1: 		else
1: 		{
1: 			/* See if other side contains a column reference from the same table */
1: 			JBitSet referencedTables = arg1.getTablesReferenced();
1: 			/* See if other columns are all correlation columns */
1: 			int index = 0;
1: 			int colNumber =	((ColumnReference) arg2).getColumnNumber();
1: 			for ( ; index < tableNumbers.length; index++)
1: 			{
1: 				if (referencedTables.get(tableNumbers[index]))
1: 				{
1: 					break;
1: 				}
1: 			}
1: 			/* Correlation column, so we can treat it as a constant */
1: 			if (index == tableNumbers.length)
1: 			{
1: 				setValueCols(tableColMap, eqOuterCols, colNumber, resultTable);
1: 			}
1: 			else if (tableColMap != null && !referencedTables.get(tableNumber))
1: 			{
1: 				tableColMap[index].set(colNumber);
1: 			}
1: 		}
1: 	}
1: 	/**
1: 	 * Set eqOuterCols and the column in all the tables for constants,
1: 	 * parmeters and correlation columns
1: 	 * The column in the tableColMap is set only for the current table
1: 	 * if the table is the result column table.  For other tables in the
1: 	 * query we set the column for all the tables since the constant will
1: 	 * reduced the number of columns required in a unique multicolumn index for
1: 	 * distinctness.
1: 	 * For example, given an unique index on t1(a,b), setting b=1 means that
1: 	 * t1(a) is unique since there can be no duplicates for a where b=1 without
1: 	 * destroying the uniqueness of t1(a,b).  However, for the result columns
1: 	 * setting b=1, does not mean that a select list of t1.a is distinct if
1: 	 * t1.a is the only column used in joining with another table
1: 	 * e.g. select t1.a from t1, t2 where t1.a = t2.a and t1.b = 1;
1: 	 * 
1: 	 * 	t1			t2			result
1: 	 *	a	b		a			a
1: 	 *  1	1		1			1
1: 	 *  1 	2		2			1
1: 	 *	2	1
1: 	 * 
1: 	 *
1: 	 * @param tableColMap	Array of bitmaps for noting which columns are in = 
1: 	 *						predicates with columns from each table
1: 	 * @param eqOuterCols	Array of booleans for noting which columns
1: 	 *						are in = predicates without columns from the
1: 	 *						subquery block.
1: 	 * @param colReference	The column to set
1: 	 * @param resultTable	If -1 set all the bit for all the tables for that
1: 	 *						column; otherwise set the bit for the specified table
1: 	 *
1: 	 *
1: 	 */
1: 	private void setValueCols(JBitSet[] tableColMap, boolean[] eqOuterCols, 
1: 		int colReference, int resultTable)
1: 	{
1: 		if (eqOuterCols != null)
1: 			eqOuterCols[colReference] = true;
1: 
1: 		if (tableColMap != null)
1: 		{
1: 			if (resultTable == -1)
1: 			{
1: 				for (int i = 0; i < tableColMap.length; i++)
1: 					tableColMap[i].set(colReference);
1: 			}
1: 			else
1: 				tableColMap[resultTable].set(colReference);
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Returns true if this ValueNode is a relational operator. Relational
0: 	 * Operators are <, <=, =, >, >=, <> as well as IS NULL and IS NOT
1: 	 * NULL. This is the preferred way of figuring out if a ValueNode is
1: 	 * relational or not. 
1: 	 * @see RelationalOperator
1: 	 * @see BinaryRelationalOperatorNode
1: 	 * @see IsNullNode
1: 	*/
0: 	public boolean isRelationalOperator()
1: 	{
1: 		return false;
1: 	}
1: 	
1: 	/**
1: 	 * Returns true if this value node is a <em>equals</em> operator. 
1: 	 *
1: 	 * @see ValueNode#isRelationalOperator
1: 	 */
0: 	public boolean isBinaryEqualsOperatorNode()
1: 	{
1: 		return false;
1: 	}
1: 
1: 	/** Return true if the predicate represents an optimizable equality node.
1: 	 * an expression is considered to be an optimizable equality node if all the
1: 	 * following conditions are met:
1: 	 * <ol>
1: 	 * <li> the operator is an <em>=</em> or <em>IS NULL</em> operator </li>
1: 	 * <li> one of the operands is a column specified by optTable/columnNumber</li>
1: 	 * <li> Both operands are not the same column; i.e tab.col = tab.col </li>
1: 	 * <li> There are no implicit varchar comparisons of the operands; i.e
1: 	 * either both operands are string like (varchar, char, longvarchar) or
1: 	 * neither operand is string like </li>
1: 	 * </ol>
1: 	 * 
1: 	 * @param optTable	the table being optimized. Column reference must be from
1: 	 * this table.
1: 	 * @param columnNumber the column number. One of the operands of this
1: 	 * predicate must be the column number specified by optTable/columnNumber
1: 	 * @param isNullOkay if set to true we also consider IS NULL predicates;
1: 	 * otherwise consider only = predicates.
1: 	 */
0: 	public boolean optimizableEqualityNode(Optimizable optTable, 
1: 										   int columnNumber, 
1: 										   boolean isNullOkay)
1: 		throws StandardException
1: 	{
1: 		return false;
1: 	}
1: 
1: 	/**
1: 	 * Returns TRUE if this is a parameter node. We do lots of special things
1: 	 * with Parameter Nodes.
1: 	 *
1: 	 */
0: 	public boolean isParameterNode()
1: 	{
1: 		return false;
1: 	}
1: 
1: }
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:b3bf9ca
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:Army
-------------------------------------------------------------------------------
commit:9d82913
/////////////////////////////////////////////////////////////////////////
0: 	/**
1: 	 * Returns true if this value node is an operator created
1: 	 * for optimized performance of an IN list.
0: 	 *
1: 	 * Or more specifically, returns true if this value node is
1: 	 * an equals operator of the form "col = ?" that we generated
1: 	 * during preprocessing to allow index multi-probing.
0: 	 */
0: 	public boolean isInListProbeNode()
0: 	{
1: 		return false;
0: 	}
0: 
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2d37fd6
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	 * @param acb	The ExpressionClassBuilder for the class being built
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:d5bc20f
/////////////////////////////////////////////////////////////////////////
0: 	public DataTypeDescriptor getTypeServices() throws StandardException
/////////////////////////////////////////////////////////////////////////
0: 	public TypeId getTypeId() throws StandardException
/////////////////////////////////////////////////////////////////////////
0: 	public TypeCompiler getTypeCompiler() throws StandardException
/////////////////////////////////////////////////////////////////////////
0: 	 * Set the DataTypeServices for this ValueNode.  This method is
0: 	 * overridden in ParameterNode.
/////////////////////////////////////////////////////////////////////////
0: 	public void setType(DataTypeDescriptor dataTypeServices) throws StandardException
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 	public void copyFields(ValueNode oldVN) throws StandardException
/////////////////////////////////////////////////////////////////////////
0: 	throws StandardException
/////////////////////////////////////////////////////////////////////////
1: 		if ((arg1 instanceof ConstantNode) || (arg1.requiresTypeFromContext()))
/////////////////////////////////////////////////////////////////////////
1: 	 * Returns TRUE if the type of this node will be determined from the
0: 	 * context in which it is getting used.
0: 	 *
1: 	 * @return Whether this node's type will be determined from the context
0: 	 */
0: 	public boolean requiresTypeFromContext()
0: 	{
0: 		return false;
0: 	}
0: 
0: 	/**
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package	org.apache.derby.impl.sql.compile;
0: 
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: import org.apache.derby.iapi.types.TypeId;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.sql.compile.TypeCompiler;
0: import org.apache.derby.iapi.types.DataValueFactory;
0: 
0: import org.apache.derby.iapi.types.SQLChar;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.sql.compile.CompilerContext;
0: import org.apache.derby.iapi.sql.compile.Optimizable;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
0: import org.apache.derby.iapi.sql.compile.NodeFactory;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.iapi.store.access.Qualifier;
0: 
0: import org.apache.derby.impl.sql.compile.ActivationClassBuilder;
0: import org.apache.derby.impl.sql.compile.ExpressionClassBuilder;
0: 
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
0: 
0: import org.apache.derby.iapi.util.JBitSet;
0: import org.apache.derby.iapi.services.i18n.MessageService;
0: 
0: import java.lang.reflect.Modifier;
0: 
0: import java.sql.Date;
0: import java.sql.Time;
0: import java.sql.Timestamp;
0: 
0: import java.util.Vector;
0: 
0: /**
0:  * A ValueNode is an abstract class for all nodes that can represent data
0:  * values, that is, constants, columns, and expressions.
0:  *
0:  * @author Jeff Lichtman
0:  */
0: 
0: public abstract class ValueNode extends QueryTreeNode
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	public static final int IN_UNKNOWN_CLAUSE = 0;
0: 	public static final int IN_SELECT_LIST = 1;
0: 	public static final int IN_WHERE_CLAUSE = 2;
0: 	public static final int IN_HAVING_CLAUSE = 3;
0: 
0: 	protected DataTypeDescriptor	dataTypeServices;
0: 	private TypeId typeId;	   
0: 	private TypeCompiler typeCompiler;
0: 	protected int				clause = IN_UNKNOWN_CLAUSE;
0: 
0: 	// Whether or not additional predicates have been created from this one.
0: 	boolean	transformed;
0: 
0: 	/*
0: 	** Constructor for untyped ValueNodes, for example, untyped NULLs
0: 	** and parameter nodes.
0: 	**
0: 	** Binding will replace all untyped ValueNodes with typed ValueNodes
0: 	** when it figures out what their types should be.
0: 	*/
0: 	public ValueNode()
0: 	{
0: 	}
0: 
0: 	/**
0: 	 * Initializer for numeric types.
0: 	 * 
0: 	 *
0: 	 * @param typeId	The TypeID of this new node
0: 	 * @param precision	The precision of this new node
0: 	 * @param scale		The scale of this new node
0: 	 * @param isNullable	The nullability of this new node
0: 	 * @param maximumWidth	The maximum width of this new node
0: 	 *
0: 	 * @return	Nothing
0: 	 *
0: 	 * @exception StandardException
0: 	 */
0: 
0: 	public void init(
0: 			Object typeId,
0: 			Object precision,
0: 			Object scale,
0: 			Object isNullable,
0: 			Object maximumWidth)
0: 		throws StandardException
0: 	{
0: 		setType(
0: 			new DataTypeDescriptor(
0: 						(TypeId) typeId,
0: 						((Integer) precision).intValue(),
0: 						((Integer) scale).intValue(),
0: 						((Boolean) isNullable).booleanValue(),
0: 						((Integer) maximumWidth).intValue()
0: 					)
0: 				);
0: 	}
0: 
0: 	/**
0: 	 * Initializer for non-numeric types.
0: 	 * 
0: 	 *
0: 	 * @param tcf		The factory to get the
0: 	 *					DataTypeServicesFactory from
0: 	 * @param typeId	The TypeID of this new node
0: 	 * @param isNullable	The nullability of this new node
0: 	 * @param maximumWidth	The maximum width of this new node
0: 	 *
0: 	 * @exception StandardException
0: 	 */
0: 
0: 	ValueNode(
0: 			Object tcf,
0: 			Object typeId,
0: 			Object isNullable,
0: 			Object maximumWidth)
0: 		throws StandardException
0: 	{
0: 		setType(new DataTypeDescriptor(
0: 						(TypeId) typeId,
0: 						((Boolean) isNullable).booleanValue(),
0: 						((Integer) maximumWidth).intValue()
0: 						)
0: 				);
0: 	}
0: 
0: 			
0: 	/**
0: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
0: 	 * for how this should be done for tree printing.
0: 	 *
0: 	 * @return	This object as a String
0: 	 */
0: 
0: 	public String toString()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			return "dataTypeServices: " +
0: 				( ( dataTypeServices != null) ?
0: 						dataTypeServices.toString() : "null" ) + "\n" +
0: 				"clause: " + clause + "\n" +
0: 				super.toString();
0: 		}
0: 		else
0: 		{
0: 			return "";
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Get the DataTypeServices from this ValueNode.
0: 	 *
0: 	 * @return	The DataTypeServices from this ValueNode.  This
0: 	 *		may be null if the node isn't bound yet.
0: 	 */
0: 	public DataTypeDescriptor getTypeServices()
0: 	{
0: 		return dataTypeServices;
0: 	}
0: 
0: 	/**
0: 	 * Get the TypeId from this ValueNode.
0: 	 *
0: 	 * @return	The TypeId from this ValueNode.  This
0: 	 *		may be null if the node isn't bound yet.
0: 	 */
0: 	public TypeId getTypeId()
0: 	{
0: 		return typeId;
0: 	}
0: 
0: 
0: 	/**
0: 		Return the DataValueFactory
0: 	*/
0: 	protected final DataValueFactory getDataValueFactory() {
0: 		return getLanguageConnectionContext().getDataValueFactory();
0: 	}
0: 
0: 	/**
0: 	 * Get the TypeCompiler from this ValueNode, based on its TypeId.
0: 	 *
0: 	 * @return	This ValueNode's TypeCompiler
0: 	 *
0: 	 */
0: 	public TypeCompiler getTypeCompiler()
0: 	{
0: 		if (typeCompiler == null)
0: 		{
0: 			/*
0: 			** getTypeId() is overriddend by parameter node so
0: 			** don't get smart and remove the extra method call.
0: 			*/
0: 			typeCompiler = getTypeCompiler(getTypeId());
0: 		}
0: 
0: 		return typeCompiler;
0: 	}
0: 
0: 	/**
0: 	 * Set the DataTypeServices in this ValueNode.
0: 	 *
0: 	 * @param dataTypeServices	The DataTypeServices to set in this
0: 	 *				ValueNode
0: 	 *
0: 	 * @return	Nothing
0: 	 */
0: 
0: 	public void setType(DataTypeDescriptor dataTypeServices)
0: 	{
0: 		this.dataTypeServices = dataTypeServices;
0: 
0: 		/* Get this now so we only have to cast it once */
0: 		if (dataTypeServices == null)
0: 			typeId = null;
0: 		else
0: 			typeId = dataTypeServices.getTypeId();
0: 
0: 		// Clear the typeCompiler, just in case type has changed
0: 		typeCompiler = null;
0: 	}
0: 
0: 	/**
0: 	 * Set the DataTypeServices for this ValueNode.  This method is
0: 	 * overridden in ParameterNode.
0: 	 *
0: 	 * @param descriptor	The DataTypeServices to set for this ValueNode
0: 	 *
0: 	 * @return	Nothing
0: 	 *
0: 	 */
0: 
0: 	public void setDescriptor(DataTypeDescriptor descriptor)
0: 	{
0: 		setType(descriptor);
0: 	}
0: 
0: 	/**
0: 	 * Get the source for this ValueNode.
0: 	 *
0: 	 * @return	The source of this ValueNode.
0: 	 */
0: 
0: 	public ResultColumn getSourceResultColumn()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		SanityManager.ASSERT(false,
0: 			"getSourceResultColumn() not expected to be called for this node - " +
0: 			getClass().toString());
0: 		return null;
0: 	}
0: 
0: 	/**
0: 	 * Get the clause that this node appears in.
0: 	 *
0: 	 * @return int	The clause that this node appears in.
0: 	 */
0: 	public int getClause()
0: 	{
0: 		return clause;
0: 	}
0: 
0: 	/**
0: 	 * Set the clause that this node appears in.
0: 	 *
0: 	 * @param clause	The clause that this node appears in.
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	public void setClause(int clause)
0: 	{
0: 		this.clause = clause;
0: 	}
0: 
0: 	/**
0: 	 * Mark this predicate has having been transformed (other predicates
0: 	 * were generated from it).  This will help us with ensure that the
0: 	 * predicate does not get calculated into the selectivity multiple
0: 	 * times.
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	void setTransformed()
0: 	{
0: 		transformed = true;
0: 	}
0: 
0: 	/** 
0: 	 * Return whether or not this predicate has been transformed.
0: 	 *
0: 	 * @return Whether or not this predicate has been transformed.
0: 	 */
0: 	boolean getTransformed()
0: 	{
0: 		return transformed;
0: 	}
0: 
0: 	
0: 	public ValueNode bindExpression(
0: 									FromList fromList, SubqueryList subqueryList,
0: 									Vector	aggregateVector)
0: 		throws StandardException
0: 	{
0: 		return bindExpression(fromList, subqueryList, aggregateVector,false);
0: 	}
0: 	
0: 
0: 	/**
0: 	 * Bind this expression.  This is a place-holder method - it should never
0: 	 * be called.
0: 	 *
0: 	 * @param fromList			The FROM list to use for binding
0: 	 * @param subqueryList		The SubqueryList we are building as we hit
0: 	 *							SubqueryNodes.
0: 	 * @param aggregateVector	The aggregate vector being built as we find AggregateNodes
0: 	 *
0: 	 * @return	The new top of the expression tree.
0: 	 *
0: 	 * @exception StandardException	Thrown on error
0: 	 */
0: 
0: 	public ValueNode bindExpression(
0: 			FromList fromList, SubqueryList subqueryList,
0: 			Vector aggregateVector, boolean forQueryRewrite) 
0: 				throws StandardException
0: 	{
0: 		/* There are a bizillion classes which extend ValueNode.  Here is info
0: 		 * on some of the classes that bindExpression() should not be called on
0: 		 * and why:
0: 		 *	o  BaseColumnNodes should only appear under the ResultColumnList
0: 		 *     in the FromBaseTable.  They are created/bound when binding the
0: 		 *     FromBaseTable.
0: 		 */
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(false, 
0: 						"bindExpression() not expected to be called on a " + 
0: 						this.getClass().toString());
0: 		}
0: 
0: 		return this;
0: 	}
0: 
0: 	/**
0: 	 * Generate a SQL->Java->SQL conversion tree above the current node
0: 	 * and bind the new nodes individually.
0: 	 * This is useful when doing comparisons, built-in functions, etc. on
0: 	 * java types which have a direct mapping to system built-in types.
0: 	 *
0: 	 * @return ValueNode	The new tree.
0: 	 *
0: 	 * @exception StandardException	Thrown on error
0: 	 */
0: 	public ValueNode genSQLJavaSQLTree()
0: 		throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(typeId != null,
0: 				"genSQLJavaSQLTree() only expected to be called on a bound node");
0: 			SanityManager.ASSERT(typeId.userType(),
0: 				"genSQLJavaSQLTree() only expected to be called on user types");
0: 		}
0: 
0: 		JavaValueNode stjvn = (JavaValueNode) getNodeFactory().getNode(
0: 									C_NodeTypes.SQL_TO_JAVA_VALUE_NODE,
0: 									this,
0: 									getContextManager());
0: 
0: 		ValueNode jtsvn = (ValueNode) getNodeFactory().getNode(
0: 									C_NodeTypes.JAVA_TO_SQL_VALUE_NODE,
0: 									stjvn,
0: 									getContextManager());
0: 		jtsvn.setType(DataTypeDescriptor.getSQLDataTypeDescriptor(stjvn.getJavaTypeName()));
0: 		return jtsvn;
0: 	}
0: 
0: 	/**
0: 	 * Preprocess an expression tree.  We do a number of transformations
0: 	 * here (including subqueries, IN lists, LIKE and BETWEEN) plus
0: 	 * subquery flattening.
0: 	 * NOTE: This is done before the outer ResultSetNode is preprocessed.
0: 	 *
0: 	 * @param	numTables			Number of tables in the DML Statement
0: 	 * @param	outerFromList		FromList from outer query block
0: 	 * @param	outerSubqueryList	SubqueryList from outer query block
0: 	 * @param	outerPredicateList	PredicateList from outer query block
0: 	 *
0: 	 * @return		The modified expression
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public ValueNode preprocess(int numTables,
0: 								FromList outerFromList,
0: 								SubqueryList outerSubqueryList,
0: 								PredicateList outerPredicateList) 
0: 					throws StandardException
0: 	{
0: 		return this;
0: 	}
0: 
0: 	/**
0: 	 * Eliminate NotNodes in the current query block.  We traverse the tree, 
0: 	 * inverting ANDs and ORs and eliminating NOTs as we go.  We stop at 
0: 	 * ComparisonOperators and boolean expressions.  We invert 
0: 	 * ComparisonOperators and replace boolean expressions with 
0: 	 * boolean expression = false.
0: 	 * NOTE: Since we do not recurse under ComparisonOperators, there
0: 	 * still could be NotNodes left in the tree.
0: 	 *
0: 	 * @param	underNotNode		Whether or not we are under a NotNode.
0: 	 *							
0: 	 *
0: 	 * @return		The modified expression
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	ValueNode eliminateNots(boolean underNotNode) 
0: 					throws StandardException
0: 	{
0: 		if (! underNotNode)
0: 		{
0: 			return this;
0: 		}
0: 
0: 		/* bind() has ensured that this node's type is SQLBoolean */
0: 		if (SanityManager.DEBUG)
0: 		SanityManager.ASSERT(
0: 				dataTypeServices.getTypeId().equals(
0: 												TypeId.BOOLEAN_ID),
0: 					"Node's type (" +
0: 					dataTypeServices.getTypeId().getSQLTypeName() +
0: 					") is expected to be boolean");
0: 
0: 		/* Return ValueNode = false */
0: 		return genEqualsFalseTree();
0: 	}
0: 
0: 	/**
0: 	 * Transform this into this = false.  Useful for NOT elimination.
0: 	 *
0: 	 *
0: 	 * @return		The modified expression
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public ValueNode genEqualsFalseTree()
0: 			throws StandardException
0: 	{
0: 		BinaryRelationalOperatorNode equalsNode;
0: 		BooleanConstantNode		 falseNode;
0: 		boolean 				nullableResult;
0: 		NodeFactory				nodeFactory = getNodeFactory();
0: 
0: 		falseNode = (BooleanConstantNode) nodeFactory.getNode(
0: 									C_NodeTypes.BOOLEAN_CONSTANT_NODE,
0: 									Boolean.FALSE,
0: 									getContextManager());
0: 		equalsNode = (BinaryRelationalOperatorNode)
0: 							nodeFactory.getNode(
0: 								C_NodeTypes.BINARY_EQUALS_OPERATOR_NODE,
0: 								this,
0: 								falseNode,
0: 								getContextManager());
0: 		nullableResult = dataTypeServices.isNullable();
0: 		equalsNode.setType(new DataTypeDescriptor(
0: 									TypeId.BOOLEAN_ID,
0: 									nullableResult)
0: 						  );
0: 		return equalsNode;
0: 	}
0: 
0: 	/**
0: 	 * Transform this into this is null.  Useful for NOT elimination.
0: 	 *
0: 	 * @return		The modified expression
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public ValueNode genIsNullTree()
0: 			throws StandardException
0: 	{
0: 		IsNullNode isNullNode;
0: 
0: 		isNullNode = (IsNullNode)
0: 							getNodeFactory().getNode(
0: 													C_NodeTypes.IS_NULL_NODE,
0: 													this,
0: 													getContextManager());
0: 		isNullNode.setType(new DataTypeDescriptor(
0: 									TypeId.BOOLEAN_ID,
0: 									false)
0: 						  );
0: 		return isNullNode;
0: 	}
0: 
0: 	/**
0: 	 * Verify that eliminateNots() did its job correctly.  Verify that
0: 	 * there are no NotNodes above the top level comparison operators
0: 	 * and boolean expressions.
0: 	 *
0: 	 * @return		Boolean which reflects validity of the tree.
0: 	 */
0: 	boolean verifyEliminateNots()
0: 	{
0: 		if (SanityManager.ASSERT)
0: 		{
0: 			return (! (this instanceof NotNode));
0: 		}
0: 		else
0: 		{
0: 			return true;
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Do the 1st step in putting an expression into conjunctive normal
0: 	 * form.  This step ensures that the top level of the expression is
0: 	 * a chain of AndNodes.
0: 	 *
0: 	 * @return		The modified expression
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public ValueNode putAndsOnTop() 
0: 					throws StandardException
0: 	{
0: 		NodeFactory		nodeFactory = getNodeFactory();
0: 
0:         QueryTreeNode trueNode = nodeFactory.getNode(
0: 										C_NodeTypes.BOOLEAN_CONSTANT_NODE,
0: 										Boolean.TRUE,
0: 										getContextManager());
0: 		AndNode andNode = (AndNode) nodeFactory.getNode(
0: 										C_NodeTypes.AND_NODE,
0: 										this,
0: 										trueNode,
0: 										getContextManager());
0: 		andNode.postBindFixup();
0: 		return andNode;
0: 	}
0: 
0: 	/**
0: 	 * Verify that putAndsOnTop() did its job correctly.  Verify that the top level 
0: 	 * of the expression is a chain of AndNodes.
0: 	 *
0: 	 * @return		Boolean which reflects validity of the tree.
0: 	 */
0: 	public boolean verifyPutAndsOnTop()
0: 	{
0: 		return true;
0: 	}
0: 
0: 	/**
0: 	 * Finish putting an expression into conjunctive normal
0: 	 * form.  An expression tree in conjunctive normal form meets
0: 	 * the following criteria:
0: 	 *		o  If the expression tree is not null,
0: 	 *		   the top level will be a chain of AndNodes terminating
0: 	 *		   in a true BooleanConstantNode.
0: 	 *		o  The left child of an AndNode will never be an AndNode.
0: 	 *		o  Any right-linked chain that includes an AndNode will
0: 	 *		   be entirely composed of AndNodes terminated by a true BooleanConstantNode.
0: 	 *		o  The left child of an OrNode will never be an OrNode.
0: 	 *		o  Any right-linked chain that includes an OrNode will
0: 	 *		   be entirely composed of OrNodes terminated by a false BooleanConstantNode.
0: 	 *		o  ValueNodes other than AndNodes and OrNodes are considered
0: 	 *		   leaf nodes for purposes of expression normalization.
0: 	 *		   In other words, we won't do any normalization under
0: 	 *		   those nodes.
0: 	 *
0: 	 * In addition, we track whether or not we are under a top level AndNode.  
0: 	 * SubqueryNodes need to know this for subquery flattening.
0: 	 *
0: 	 * @param	underTopAndNode		Whether or not we are under a top level AndNode.
0: 	 *							
0: 	 *
0: 	 * @return		The modified expression
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public ValueNode changeToCNF(boolean underTopAndNode) 
0: 					throws StandardException
0: 	{
0: 		return this;
0: 	}
0: 
0: 	/**
0: 	 * Verify that changeToCNF() did its job correctly.  Verify that:
0: 	 *		o  AndNode  - rightOperand is not instanceof OrNode
0: 	 *				      leftOperand is not instanceof AndNode
0: 	 *		o  OrNode	- rightOperand is not instanceof AndNode
0: 	 *					  leftOperand is not instanceof OrNode
0: 	 *
0: 	 * @return		Boolean which reflects validity of the tree.
0: 	 */
0: 	public boolean verifyChangeToCNF()
0: 	{
0: 		return true;
0: 	}
0: 
0: 	/**
0: 	 * Categorize this predicate.  Initially, this means
0: 	 * building a bit map of the referenced tables for each predicate.
0: 	 * If the source of this ColumnReference (at the next underlying level) 
0: 	 * is not a ColumnReference or a VirtualColumnNode then this predicate
0: 	 * will not be pushed down.
0: 	 *
0: 	 * For example, in:
0: 	 *		select * from (select 1 from s) a (x) where x = 1
0: 	 * we will not push down x = 1.
0: 	 * NOTE: It would be easy to handle the case of a constant, but if the
0: 	 * inner SELECT returns an arbitrary expression, then we would have to copy
0: 	 * that tree into the pushed predicate, and that tree could contain
0: 	 * subqueries and method calls.
0: 	 * RESOLVE - revisit this issue once we have views.
0: 	 *
0: 	 * @param referencedTabs	JBitSet with bit map of referenced FromTables
0: 	 * @param simplePredsOnly	Whether or not to consider method
0: 	 *							calls, field references and conditional nodes
0: 	 *							when building bit map
0: 	 *
0: 	 * @return boolean		Whether or not source.expression is a ColumnReference
0: 	 *						or a VirtualColumnNode.
0: 	 *
0: 	 * @exception StandardException			Thrown on error
0: 	 */
0: 	public boolean categorize(JBitSet referencedTabs, boolean simplePredsOnly)
0: 		throws StandardException
0: 	{
0: 		return true;
0: 	}
0: 
0: 	/**
0: 	 * When the value node is in a result column of a select list,
0: 	 * the user can request metadata information. The result column
0: 	 * won't have a column descriptor, so we return some default
0: 	 * information through the expression. This lets expressions that
0: 	 * are simply columns return all of the info, and others use
0: 	 * this supertype's default values.
0: 	 *
0: 	 * @return the default schema name for an expression -- null
0: 	 */
0: 	public String getSchemaName()
0: 	{
0: 		return null;
0: 	}
0: 
0: 	/**
0: 	 * @return the default schema name for an expression -- null
0: 	 */
0: 	public String getTableName()
0: 	{
0: 		return null;
0: 	}
0: 
0: 	/**
0: 	 * This is null so that the caller will substitute in the resultset generated
0: 	 * name as needed.
0: 	 *
0: 	 * @return the default column name for an expression -- null.
0: 	 */
0: 	public String getColumnName()
0: 	{
0: 		return null;
0: 	}
0: 
0: 	/**
0: 	 * Get a bit map of table references in this expression
0: 	 *
0: 	 * @return	A bit map of table numbers referred to in this expression
0: 	 *
0: 	 * @exception StandardException			Thrown on error
0: 	 */
0: 	JBitSet getTablesReferenced()
0: 		throws StandardException
0: 	{
0: 		ReferencedTablesVisitor rtv = new ReferencedTablesVisitor(new JBitSet(0));
0: 		accept(rtv);
0: 		return rtv.getTableMap();
0: 	}
0: 
0: 	/**
0: 	 * Return whether or not this expression tree is cloneable.
0: 	 *
0: 	 * @return boolean	Whether or not this expression tree is cloneable.
0: 	 */
0: 	public boolean isCloneable()
0: 	{
0: 		return false;
0: 	}
0: 
0: 	/**
0: 	 * Return a clone of this node.
0: 	 *
0: 	 * @return ValueNode	A clone of this node.
0: 	 *
0: 	 * @exception StandardException			Thrown on error
0: 	 */
0: 	public ValueNode getClone() throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(false,
0: 				"getClone() not expected to be called for " +
0: 				getClass().getName());
0: 		}
0: 		return null;
0: 	}
0: 
0: 	/**
0: 	 * Copy all of the "appropriate fields" for a shallow copy.
0: 	 *
0: 	 * @param oldVN		The ValueNode to copy from.
0: 	 *
0: 	 */
0: 	public void copyFields(ValueNode oldVN)
0: 	{
0: 		dataTypeServices = oldVN.getTypeServices();
0: 		typeId = oldVN.getTypeId();
0: 	}
0: 
0: 	/**
0: 	 * Remap all ColumnReferences in this tree to be clones of the
0: 	 * underlying expression.
0: 	 *
0: 	 * @return ValueNode			The remapped expression tree.
0: 	 *
0: 	 * @exception StandardException			Thrown on error
0: 	 */
0: 	public ValueNode remapColumnReferencesToExpressions() throws StandardException
0: 	{
0: 		return this;
0: 	}
0: 
0: 	/**
0: 	 * Return whether or not this expression tree represents a constant expression.
0: 	 *
0: 	 * @return	Whether or not this expression tree represents a constant expression.
0: 	 */
0: 	public boolean isConstantExpression()
0: 	{
0: 		return false;
0: 	}
0: 
0: 	/**
0: 	 * Return whether or not this expression tree represents a constant value.
0: 	 * In this case, "constant" means that it will always evaluate to the
0: 	 * same thing, even if it includes columns.  A column is constant if it
0: 	 * is compared to a constant expression.
0: 	 *
0: 	 * @return	True means this expression tree represents a constant value.
0: 	 */
0: 	public boolean constantExpression(PredicateList whereClause)
0: 	{
0: 		return false;
0: 	}
0: 
0: 	/**
0: 	  * Bind time logic. Raises an error if this ValueNode, once compiled, returns
0: 	  * unstable results AND if we're in a context where unstable results are
0: 	  * forbidden.
0: 	  *
0: 	  * Called by children who may NOT appear in the WHERE subclauses of ADD TABLE clauses.
0: 	  *
0: 	  *	@param	fragmentType	Type of fragment as a String, for inclusion in error messages.
0: 	  *	@param	fragmentBitMask	Type of fragment as a bitmask of possible fragment types
0: 	  *
0: 	  * @exception StandardException		Thrown on error
0: 	  */
0: 	public	void	checkReliability( String fragmentType, int fragmentBitMask )
0: 		throws StandardException
0: 	{
0: 		// if we're in a context that forbids unreliable fragments, raise an error
0: 		if ( ( getCompilerContext().getReliability() & fragmentBitMask ) != 0 )
0: 		{
0:             throwReliabilityException( fragmentType );
0: 		}
0: 	}
0: 
0: 	/**
0: 	  * Bind time logic. Raises an error if this ValueNode, once compiled, returns
0: 	  * unstable results AND if we're in a context where unstable results are
0: 	  * forbidden.
0: 	  *
0: 	  * Called by children who may NOT appear in the WHERE subclauses of ADD TABLE clauses.
0: 	  *
0: 	  *	@param	fragmentBitMask	Type of fragment as a bitmask of possible fragment types
0: 	  *	@param	fragmentType	Type of fragment as a String, to be fetch for the error message.
0: 	  *
0: 	  * @exception StandardException		Thrown on error
0: 	  */
0: 	public	void	checkReliability( int fragmentBitMask, String fragmentType )
0: 		throws StandardException
0: 	{
0: 		// if we're in a context that forbids unreliable fragments, raise an error
0: 		if ( ( getCompilerContext().getReliability() & fragmentBitMask ) != 0 )
0: 		{
0:             String fragmentTypeTxt = MessageService.getTextMessage( fragmentType );
0:             throwReliabilityException( fragmentTypeTxt );
0: 		}
0: 	}
0: 
0:     /**
0:      * Common code for the 2 checkReliability functions.  Always throws StandardException.
0:      *
0:      * @param fragmentType Type of fragment as a string, for inclusion in error messages.
0:      * @exception StandardException        Throws an error, always.
0:      */
0:     private void throwReliabilityException( String fragmentType ) throws StandardException
0:     {
0:         String sqlState;
0: 		/* Error string somewhat dependent on operation due to different
0: 		 * nodes being allowed for different operations.
0: 		 */
0: 		if (getCompilerContext().getReliability() == CompilerContext.DEFAULT_RESTRICTION)
0: 		{
0:             sqlState = SQLState.LANG_INVALID_DEFAULT_DEFINITION;
0: 		}
0: 		else
0: 		{
0:             sqlState = SQLState.LANG_UNRELIABLE_QUERY_FRAGMENT;
0: 		}
0: 		throw StandardException.newException(sqlState, fragmentType);
0:     }
0: 
0: 	/**
0: 	 * Return the variant type for the underlying expression.
0: 	 * The variant type can be:
0: 	 *		VARIANT				- variant within a scan
0: 	 *							  (method calls and non-static field access)
0: 	 *		SCAN_INVARIANT		- invariant within a scan
0: 	 *							  (column references from outer tables)
0: 	 *		QUERY_INVARIANT		- invariant within the life of a query
0: 	 *							  (constant expressions)
0: 	 *
0: 	 * @return	The variant type for the underlying expression.
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	protected int getOrderableVariantType() throws StandardException
0: 	{
0: 		// The default is VARIANT
0: 		return Qualifier.VARIANT;
0: 	}
0: 
0: 
0: 	/**
0: 	  * Bind time logic. Raises an error if this ValueNode does not resolve to
0: 	  *	a boolean value. This method is called by WHERE clauses.
0: 	  *
0: 	  *	@return	bound coercion of this node to a builtin type as necessary
0: 	  *
0: 	  * @exception StandardException		Thrown on error
0: 	  */
0: 	public	ValueNode	checkIsBoolean()
0: 		throws StandardException
0: 	{
0: 		ValueNode	whereClause = this;
0: 
0: 		/*
0: 		** Is the datatype of the WHERE clause BOOLEAN?
0: 		**
0: 		** NOTE: This test is not necessary in SQL92 entry level, because
0: 		** it is syntactically impossible to have a non-Boolean WHERE clause
0: 		** in that level of the standard.  But we intend to extend the
0: 		** language to allow Boolean user functions in the WHERE clause,
0: 		** so we need to test for the error condition.
0: 		*/
0: 		TypeId whereTypeId = whereClause.getTypeId();
0: 
0: 		/* If the where clause is not a built-in type, then generate a bound 
0: 		 * conversion tree to a built-in type.
0: 		 */
0: 		if (! whereTypeId.systemBuiltIn())
0: 		{
0: 			whereClause = whereClause.genSQLJavaSQLTree();
0: 			whereTypeId = whereClause.getTypeId();
0: 		}
0: 
0: 		if (! whereTypeId.equals(TypeId.BOOLEAN_ID))
0: 		{
0: 			throw StandardException.newException(SQLState.LANG_NON_BOOLEAN_WHERE_CLAUSE, 
0: 				whereTypeId.getSQLTypeName()
0: 				);
0: 		}
0: 
0: 		return	whereClause;
0: 	}
0: 
0: 	/**
0: 	 * Return an Object representing the bind time value of this
0: 	 * expression tree.  If the expression tree does not evaluate to
0: 	 * a constant at bind time then we return null.
0: 	 * This is useful for bind time resolution of VTIs.
0: 	 * RESOLVE: What do we do for primitives?
0: 	 *
0: 	 * @return	An Object representing the bind time value of this expression tree.
0: 	 *			(null if not a bind time constant.)
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	Object getConstantValueAsObject()
0: 		throws StandardException
0: 	{
0: 		return null;
0: 	}
0: 
0: 	/////////////////////////////////////////////////////////////////////////
0: 	//
0: 	//	The ValueNode defers its generate() work to a method that works on
0: 	//	ExpressionClassBuilders rather than ActivationClassBuilders. This
0: 	//	is so that expression generation can be shared by the Core compiler
0: 	//	AND the Replication Filter compiler.
0: 	//
0: 	/////////////////////////////////////////////////////////////////////////
0: 
0: 
0: 	/**
0: 	 * Do the code generation for this node.  Call the more general
0: 	 * routine that generates expressions.
0: 	 *
0: 	 * @param acb	The ActivationClassBuilder for the class being built
0: 	 * @param mb	The method the expression will go into
0: 	 *
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	protected final	void generate(ActivationClassBuilder acb,
0: 										MethodBuilder mb)
0: 								throws StandardException
0: 	{
0: 		generateExpression( acb, mb );
0: 	}
0: 
0: 	/**
0: 	 * The only reason this routine exists is so that I don't have to change
0: 	 * the protection on generateExpression() and rototill all of QueryTree.
0: 	 *
0: 	 * @param ecb	The ExpressionClassBuilder for the class being built
0: 	 * @param mb	The method the expression will go into
0: 	 *
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public	void generateFilter(ExpressionClassBuilder ecb,
0: 										MethodBuilder mb)
0: 		throws StandardException
0: 	{
0: 		generateExpression( ecb, mb );
0: 	}
0: 	
0: 
0: 	/**
0: 	 * The default selectivity for value nodes is 50%.  This is overridden
0: 	 * in specific cases, such as the RelationalOperators.
0: 	 */
0: 	public double selectivity(Optimizable optTable)
0: 	{
0: 		// Return 1 if additional predicates have been generated from this one.
0: 		if (transformed)
0: 		{
0: 			return 1.0;
0: 		}
0: 		else
0: 		{
0: 			return 0.5d;
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Update the array of columns in = conditions with expressions without
0: 	 * column references from the same table.  This is useful when doing
0: 	 * subquery flattening on the basis of an equality condition.
0: 	 * eqOuterCols or tableColMap may be null if the calling routine
0: 	 * doesn't need the information provided
0: 	 *
0: 	 * @param tableNumber	The tableNumber of the table from which
0: 	 *						the columns of interest come from.
0: 	 * @param eqOuterCols	Array of booleans for noting which columns
0: 	 *						are in = predicates without columns from the
0: 	 *						subquery block. May be null.
0: 	 * @param tableNumbers	Array of table numbers in this query block.
0: 	 * @param tableColMap	Array of bits for noting which columns
0: 	 *						are in = predicates for each table in the
0: 	 *						query block. May be null.
0: 	 * @param resultColTable True if tableNumber is the table containing result
0: 	 * 						columns
0: 	 *
0: 	 * @return Nothing.
0: 	 *
0: 	 * @exception StandardException			Thrown on error
0: 	 * 
0: 	 */
0: 	void checkTopPredicatesForEqualsConditions(
0: 				int tableNumber, boolean[] eqOuterCols, int[] tableNumbers, 
0: 				JBitSet[] tableColMap, boolean resultColTable)
0: 		throws StandardException
0: 	{
0: 		for (ValueNode whereWalker = this; whereWalker instanceof AndNode; 
0: 			 whereWalker = ((AndNode) whereWalker).getRightOperand())
0: 		{
0: 			// See if this is a candidate =
0: 			AndNode and = (AndNode) whereWalker;
0: 
0: 			if (!and.getLeftOperand().isRelationalOperator() ||
0: 				!(((RelationalOperator)(and.getLeftOperand())).getOperator() == RelationalOperator.EQUALS_RELOP))
0: 			{
0: 				continue;
0: 			}
0: 
0: 			BinaryRelationalOperatorNode beon =
0: 					(BinaryRelationalOperatorNode) and.getLeftOperand();
0: 			ValueNode left = beon.getLeftOperand();
0: 			ValueNode right = beon.getRightOperand();
0: 			int resultTable = 0;
0: 			if (resultColTable)
0: 			{
0: 				for ( ; resultTable < tableNumbers.length; resultTable++)
0: 				{
0: 					if (tableNumbers[resultTable] == tableNumber)
0: 						break;
0: 				}
0: 			}
0: 			else
0: 				resultTable = -1;
0: 
0: 			/* Is this = of the right form? */
0: 			if ((left instanceof ColumnReference) &&
0: 				((ColumnReference) left).getTableNumber() == tableNumber)
0: 			{
0: 				updateMaps(tableColMap, eqOuterCols, tableNumbers, tableNumber,
0: 					resultTable, right, left);
0: 			}
0: 			else if ((right instanceof ColumnReference) &&
0: 					 ((ColumnReference) right).getTableNumber() == tableNumber)
0: 			{
0: 				updateMaps(tableColMap, eqOuterCols, tableNumbers, tableNumber,
0: 					resultTable, left, right);
0: 			}
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Does this represent a true constant.
0: 	 *
0: 	 * @return Whether or not this node represents a true constant.
0: 	 */
0: 	boolean isBooleanTrue()
0: 	{
0: 		return false;
0: 	}
0: 
0: 	/**
0: 	 * Does this represent a false constant.
0: 	 *
0: 	 * @return Whether or not this node represents a false constant.
0: 	 */
0: 	boolean isBooleanFalse()
0: 	{
0: 		return false;
0: 	}
0: 
0: 	/**
0: 	 * Generate code for this calculation.  This is a place-holder method -
0: 	 * it should not be called.
0: 	 *
0: 	 * @param ecb	The ExpressionClassBuilder for the class being built
0: 	 * @param mb	The method the expression will go into
0: 	 *
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public void generateExpression(ExpressionClassBuilder acb,
0: 											MethodBuilder mb)
0: 						throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		SanityManager.ASSERT(false, "Code generation for this type of ValueNode is unimplemented");
0: 	}
0: 
0: 	/**
0: 	 * Set the correct bits in tableColMap and set the boolean value in eqOuterCols 
0: 	 * given two arguments to an = predicate
0: 	 * tableColMap[t] - bit is set if the column is in an = predicate with a column 
0: 	 *					in table t, or a bit is set if the column is in an 
0: 	 *					= predicate with a constant,parameter or correlation variable 
0: 	 *				    (for all table t, if this tableColMap is not for the
0:   	 *					table with the result columns)
0: 	 * eqOuterCols[c] - is true if the column is in an = predicate with a constant,
0: 	 *					parameter or correlation variable
0: 	 * 
0: 	 *
0: 	 * @param tableColMap	Array of bitmaps for noting which columns are in = 
0: 	 *						predicates with columns from each table
0: 	 * @param eqOuterCols	Array of booleans for noting which columns
0: 	 *						are in = predicates without columns from the
0: 	 *						subquery block.
0: 	 * @param tableNumber	table number for which we are setting up the Maps
0: 	 * @param resultTable	-1 if this table is not the result table; otherwise
0: 	 *						the index into tableNumbers for the result table
0: 	 * @param arg1			one side of the = predicate
0: 	 * @param arg2			other side of the = predicate
0: 	 *
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	private void updateMaps(JBitSet[] tableColMap, boolean[] eqOuterCols,
0: 		int[] tableNumbers,  int tableNumber, int resultTable,
0: 		ValueNode arg1, ValueNode arg2)
0: 			throws StandardException
0: 	{
0: 		/* arg2 is a column from our table.  This
0: 		 * is a good = for both All tables and Outer arrays
0: 		 * if the right side is a constant or a parameter
0: 		 * or a column from an outer table.
0: 		 * It is a good = for only the All array if
0: 		 * the right side is a column from this query block.
0: 		 */
0: 		if ((arg1 instanceof ConstantNode) || (arg1.isParameterNode()))
0: 		{
0: 			setValueCols(tableColMap, eqOuterCols,
0: 				((ColumnReference) arg2).getColumnNumber(), resultTable);
0: 		}
0: 		else if((arg1 instanceof ColumnReference &&
0: 					((ColumnReference) arg1).getTableNumber() != tableNumber))
0: 		{
0: 			/* See if other columns is a correlation column */
0: 			int otherTN = ((ColumnReference) arg1).getTableNumber();
0: 			int index = 0;
0: 			int colNumber =	((ColumnReference) arg2).getColumnNumber();
0: 
0: 			for ( ; index < tableNumbers.length; index++)
0: 			{
0: 				if (otherTN == tableNumbers[index])
0: 				{
0: 					break;
0: 				}
0: 			}
0: 			/* Correlation column, so we can treat it as a constant */
0: 			if (index == tableNumbers.length)
0: 			{
0: 				setValueCols(tableColMap, eqOuterCols, colNumber, resultTable);
0: 			}
0: 			else if (tableColMap != null)
0: 			{
0: 				tableColMap[index].set(colNumber);
0: 			}
0: 
0: 		}
0: 		else
0: 		{
0: 			/* See if other side contains a column reference from the same table */
0: 			JBitSet referencedTables = arg1.getTablesReferenced();
0: 			/* See if other columns are all correlation columns */
0: 			int index = 0;
0: 			int colNumber =	((ColumnReference) arg2).getColumnNumber();
0: 			for ( ; index < tableNumbers.length; index++)
0: 			{
0: 				if (referencedTables.get(tableNumbers[index]))
0: 				{
0: 					break;
0: 				}
0: 			}
0: 			/* Correlation column, so we can treat it as a constant */
0: 			if (index == tableNumbers.length)
0: 			{
0: 				setValueCols(tableColMap, eqOuterCols, colNumber, resultTable);
0: 			}
0: 			else if (tableColMap != null && !referencedTables.get(tableNumber))
0: 			{
0: 				tableColMap[index].set(colNumber);
0: 			}
0: 		}
0: 	}
0: 	/**
0: 	 * Set eqOuterCols and the column in all the tables for constants,
0: 	 * parmeters and correlation columns
0: 	 * The column in the tableColMap is set only for the current table
0: 	 * if the table is the result column table.  For other tables in the
0: 	 * query we set the column for all the tables since the constant will
0: 	 * reduced the number of columns required in a unique multicolumn index for
0: 	 * distinctness.
0: 	 * For example, given an unique index on t1(a,b), setting b=1 means that
0: 	 * t1(a) is unique since there can be no duplicates for a where b=1 without
0: 	 * destroying the uniqueness of t1(a,b).  However, for the result columns
0: 	 * setting b=1, does not mean that a select list of t1.a is distinct if
0: 	 * t1.a is the only column used in joining with another table
0: 	 * e.g. select t1.a from t1, t2 where t1.a = t2.a and t1.b = 1;
0: 	 * 
0: 	 * 	t1			t2			result
0: 	 *	a	b		a			a
0: 	 *  1	1		1			1
0: 	 *  1 	2		2			1
0: 	 *	2	1
0: 	 * 
0: 	 *
0: 	 * @param tableColMap	Array of bitmaps for noting which columns are in = 
0: 	 *						predicates with columns from each table
0: 	 * @param eqOuterCols	Array of booleans for noting which columns
0: 	 *						are in = predicates without columns from the
0: 	 *						subquery block.
0: 	 * @param colReference	The column to set
0: 	 * @param resultTable	If -1 set all the bit for all the tables for that
0: 	 *						column; otherwise set the bit for the specified table
0: 	 *
0: 	 *
0: 	 */
0: 	private void setValueCols(JBitSet[] tableColMap, boolean[] eqOuterCols, 
0: 		int colReference, int resultTable)
0: 	{
0: 		if (eqOuterCols != null)
0: 			eqOuterCols[colReference] = true;
0: 
0: 		if (tableColMap != null)
0: 		{
0: 			if (resultTable == -1)
0: 			{
0: 				for (int i = 0; i < tableColMap.length; i++)
0: 					tableColMap[i].set(colReference);
0: 			}
0: 			else
0: 				tableColMap[resultTable].set(colReference);
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Returns true if this ValueNode is a relational operator. Relational
0: 	 * Operators are <, <=, =, >, >=, <> as well as IS NULL and IS NOT
0: 	 * NULL. This is the preferred way of figuring out if a ValueNode is
0: 	 * relational or not. 
0: 	 * @see RelationalOperator
0: 	 * @see BinaryRelationalOperatorNode
0: 	 * @see IsNullNode
0: 	*/
0: 	public boolean isRelationalOperator()
0: 	{
0: 		return false;
0: 	}
0: 	
0: 	/**
0: 	 * Returns true if this value node is a <em>equals</em> operator. 
0: 	 *
0: 	 * @see ValueNode#isRelationalOperator
0: 	 */
0: 	public boolean isBinaryEqualsOperatorNode()
0: 	{
0: 		return false;
0: 	}
0: 
0: 	/** Return true if the predicate represents an optimizable equality node.
0: 	 * an expression is considered to be an optimizable equality node if all the
0: 	 * following conditions are met:
0: 	 * <ol>
0: 	 * <li> the operator is an <em>=</em> or <em>IS NULL</em> operator </li>
0: 	 * <li> one of the operands is a column specified by optTable/columnNumber</li>
0: 	 * <li> Both operands are not the same column; i.e tab.col = tab.col </li>
0: 	 * <li> There are no implicit varchar comparisons of the operands; i.e
0: 	 * either both operands are string like (varchar, char, longvarchar) or
0: 	 * neither operand is string like </li>
0: 	 * </ol>
0: 	 * 
0: 	 * @param optTable	the table being optimized. Column reference must be from
0: 	 * this table.
0: 	 * @param columnNumber the column number. One of the operands of this
0: 	 * predicate must be the column number specified by optTable/columnNumber
0: 	 * @param isNullOkay if set to true we also consider IS NULL predicates;
0: 	 * otherwise consider only = predicates.
0: 	 */
0: 	public boolean optimizableEqualityNode(Optimizable optTable, 
0: 										   int columnNumber, 
0: 										   boolean isNullOkay)
0: 		throws StandardException
0: 	{
0: 		return false;
0: 	}
0: 
0: 	/**
0: 	 * Returns TRUE if this is a parameter node. We do lots of special things
0: 	 * with Parameter Nodes.
0: 	 *
0: 	 */
0: 	public boolean isParameterNode()
0: 	{
0: 		return false;
0: 	}
0: 
0: }
============================================================================