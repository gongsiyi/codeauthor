1:334e9a3: 
1:77323ec: /*
8:77323ec:  
1:1bac3f3:    Derby - Class org.apache.derby.impl.store.replication.net.ReplicationMessageReceive
1:77323ec:  
1:77323ec:    Licensed to the Apache Software Foundation (ASF) under one or more
1:77323ec:    contributor license agreements.  See the NOTICE file distributed with
1:77323ec:    this work for additional information regarding copyright ownership.
1:77323ec:    The ASF licenses this file to you under the Apache License, Version 2.0
1:77323ec:    (the "License"); you may not use this file except in compliance with
1:77323ec:    the License.  You may obtain a copy of the License at
1:77323ec:  
1:77323ec:       http://www.apache.org/licenses/LICENSE-2.0
1:77323ec:  
1:77323ec:    Unless required by applicable law or agreed to in writing, software
1:77323ec:    distributed under the License is distributed on an "AS IS" BASIS,
1:77323ec:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:77323ec:    See the License for the specific language governing permissions and
1:77323ec:    limitations under the License.
1:77323ec:  
3:77323ec:  */
1:77323ec: 
1:1bac3f3: package org.apache.derby.impl.store.replication.net;
1:77323ec: 
1:77323ec: import java.io.IOException;
1:77323ec: import java.net.ServerSocket;
1:77323ec: import java.net.Socket;
1:77323ec: import java.security.AccessController;
1:77323ec: import java.security.PrivilegedActionException;
1:77323ec: import java.security.PrivilegedExceptionAction;
1:77323ec: import javax.net.ServerSocketFactory;
1:77323ec: import org.apache.derby.iapi.error.StandardException;
1:334e9a3: import org.apache.derby.iapi.reference.MessageId;
1:77323ec: import org.apache.derby.iapi.reference.SQLState;
1:334e9a3: import org.apache.derby.iapi.services.monitor.Monitor;
1:29fd25c: import org.apache.derby.impl.store.raw.log.LogCounter;
1:5d97422: import org.apache.derby.iapi.util.InterruptStatus;
1:77323ec: 
3:77323ec: /**
1:77323ec:  * This class is the Receiver (viz. Socket server or listener) part of the
1:77323ec:  * network communication. It receives the message from the master and
1:77323ec:  * performs appropriate action depending on the type of the message.
1:77323ec:  */
1:77323ec: public class ReplicationMessageReceive {
1:77323ec:     /**
1:77323ec:      * Contains the address (hostname and port number) of the slave
1:77323ec:      * to replicate to.
1:77323ec:      */
1:77323ec:     private final SlaveAddress slaveAddress;
1:77323ec:     
1:77323ec:     /**
1:c458b05:      * Contains the <code>ServerSocket</code> used to listen for
1:c458b05:      * connections from the replication master. */
1:c458b05:     private ServerSocket serverSocket;
1:c458b05: 
1:c458b05:     /**
1:77323ec:      * Contains the methods used to read and write to the Object streams
1:77323ec:      * obtained from a <code>Socket</code> connection.
1:77323ec:      */
1:77323ec:     private SocketConnection socketConn;
1:77323ec:     
1:c283bcd:     /* -- Ping-thread related fields start -- */
1:c283bcd: 
1:c283bcd:     /** The maximum number of millis to wait before giving up waiting for
1:c283bcd:      * a ping response*/
1:c283bcd:     private static final int DEFAULT_PING_TIMEOUT = 5000; // 5 seconds
1:c283bcd: 
1:c283bcd:     /** Thread used to send ping messages to master to check if the connection
1:c283bcd:      * is working. The ping message must be sent from a separate thread
1:c283bcd:      * because failed message shipping over TCP does not timeout for two
1:c283bcd:      * minutes (not configurable). */
1:c283bcd:     private Thread pingThread = null;
1:c283bcd: 
1:c283bcd:     /** Used to terminate the ping thread. */
1:c283bcd:     private boolean killPingThread = false;
1:c283bcd: 
1:c283bcd:     /** Whether or not the connection with the master is confirmed to be
1:c283bcd:      * working. Set to false by isConnectedToMaster, set to true when
1:c283bcd:      * a pong (i.e., a response to a ping) is received. Field protected by
1:c283bcd:      * receivePongSemephore */
1:c283bcd:     private boolean connectionConfirmed = false;
1:c283bcd: 
1:c283bcd:     /** Used for synchronization of the ping thread */
1:c283bcd:     private final Object sendPingSemaphore = new Object();
1:c283bcd: 
1:5d97422:     /**
1:5d97422:      * Whether or not the ping thread has been notified to check connection.
1:5d97422:      * Protected by sendPingSemaphore.
1:5d97422:      */
1:5d97422:     private boolean doSendPing = false;
1:5d97422: 
1:c283bcd:     /** Used for synchronization when waiting for a ping reply message */
1:c283bcd:     private final Object receivePongSemaphore = new Object();
1:c283bcd: 
1:c283bcd:     /* -- Ping-thread related fields stop -- */
1:c283bcd: 
1:77323ec:     /**
1:77323ec:      * Constructor initializes the slave address used in replication. Accepts
1:77323ec:      * the host name and port number that constitute the slave address as
1:77323ec:      * parameters.
4:77323ec:      *
1:f2ec1d8:      * @param slaveAddress the address (host name and port number) of the slave
1:f2ec1d8:      *                     to connect to.
1:f2ec1d8:      * @param dbname the name of the database.
1:77323ec:      */
1:f2ec1d8:     public ReplicationMessageReceive(SlaveAddress slaveAddress, 
1:f2ec1d8:                                      String dbname) {
1:f2ec1d8:         this.slaveAddress = slaveAddress;
1:f2ec1d8:         Monitor.logTextMessage(MessageId.REPLICATION_SLAVE_NETWORK_LISTEN,
1:f2ec1d8:                                dbname, 
1:f2ec1d8:                                slaveAddress.getHostAddress().getHostName(),
1:f2ec1d8:                                String.valueOf(slaveAddress.getPortNumber()));
9:77323ec:     }
1:c085d07:     
1:c085d07:     /**
1:77323ec:      * Used to create the server socket, listen on the socket
1:77323ec:      * for connections from the master and verify compatibility
1:77323ec:      * with the database version of the master.
1:334e9a3:      *
1:e071963:      * @param timeout The amount of time, in milliseconds, this method
1:e071963:      * will wait for a connection to be established. If no connection
1:e071963:      * has been established before the timeout, a
1:8e4af95:      * IOException is raised with cause
1:e071963:      * java.net.SocketTimeoutException
1:29fd25c:      * @param synchOnInstant the slave log instant, used to check that
1:29fd25c:      * the master and slave log files are in synch. If no chunks of log
1:29fd25c:      * records have been received from the master yet, this is the
1:29fd25c:      * end position in the current log file. If a chunk of log has been
1:29fd25c:      * received, this is the instant of the log record received last.
1:29fd25c:      * Note that there is a difference!
1:29fd25c:      * @param dbname the name of the replicated database
1:8e4af95:      *
1:334e9a3:      *
1:e071963:      *
1:77323ec:      * @throws IOException if an exception occurs while trying to create the
1:8e4af95:      *                     <code>SocketConnection</code> class or while
1:8e4af95:      *                     trying to open a connection.
1:77323ec:      *
1:77323ec:      * @throws ClassNotFoundException Class of a serialized object cannot
1:77323ec:      *                                be found.
1:77323ec:      * @throws StandardException if an incompatible database version is found.
1:77323ec:      *
1:334e9a3:      */
1:29fd25c:     public void initConnection(int timeout, long synchOnInstant, String dbname)
1:29fd25c:         throws
1:77323ec:         IOException,
1:77323ec:         StandardException,
1:77323ec:         ClassNotFoundException {
1:334e9a3:         
1:c458b05:         // Create the ServerSocket object if this is the first
1:c458b05:         // initConnection attempt. Otherwise, we reuse the existing
1:c458b05:         // server socket
1:c458b05:         if (serverSocket == null) {
1:c458b05:             serverSocket = createServerSocket();
1:334e9a3:         }
1:e071963:         serverSocket.setSoTimeout(timeout);
1:8e4af95:         Socket client = null;
1:8e4af95:         try {
1:8e4af95:             //Start listening on the socket and accepting the connection
1:8e4af95:             client =
1:7e7a589:                 AccessController.doPrivileged(new PrivilegedExceptionAction<Socket>() {
1:7e7a589:                     public Socket run() throws IOException {
1:8e4af95:                         return serverSocket.accept();
1:8e4af95:                     }
1:8e4af95:                 });
1:8e4af95:         } catch(PrivilegedActionException pea) {
1:8e4af95:             throw (IOException) pea.getException();
1:8e4af95:         }
1:8e4af95: 
1:77323ec:         //create the SocketConnection object using the client connection.
1:77323ec:         socketConn = new SocketConnection(client);
1:77323ec:         
1:29fd25c:         // exchange initiator messages to check that master and slave are at 
1:29fd25c:         // the same version...
1:29fd25c:         parseAndAckVersion(readMessage(), dbname);
1:29fd25c:         // ...and have equal log files
1:29fd25c:         parseAndAckInstant(readMessage(), synchOnInstant, dbname);
1:c283bcd: 
1:c283bcd:         killPingThread = false;
1:c283bcd:         pingThread = new SlavePingThread(dbname);
1:c283bcd:         pingThread.setDaemon(true);
1:c283bcd:         pingThread.start();
1:c283bcd: 
1:c458b05:     }
1:77323ec:     
1:334e9a3:     /**
1:77323ec:      * Used to create a <code>ServerSocket</code> for listening to connections
1:77323ec:      * from the master.
1:77323ec:      *
1:77323ec:      * @return an instance of the <code>ServerSocket</code> class.
1:77323ec:      *
1:8e4af95:      * @throws IOException if an exception occurs while trying
2:77323ec:      *                                   to open a connection.
1:334e9a3:      */
1:8e4af95:     private ServerSocket createServerSocket() throws IOException {
1:77323ec:         //create a ServerSocket at the specified host name and the
1:77323ec:         //port number.
1:8e4af95:         ServerSocket ss = null;
1:8e4af95:         try { 
1:7e7a589:             ss = AccessController.doPrivileged
1:7e7a589:             (new PrivilegedExceptionAction<ServerSocket>() {
1:7e7a589:                 public ServerSocket run() throws IOException  {
1:8e4af95:                     ServerSocketFactory sf = ServerSocketFactory.getDefault();
1:8e4af95:                     return sf.createServerSocket(slaveAddress.getPortNumber(),
1:8e4af95:                             0, slaveAddress.getHostAddress());
1:8e4af95:                 }
1:8e4af95:             });
1:8e4af95:             return ss;
1:8e4af95:         } catch(PrivilegedActionException pea) {
1:8e4af95:             throw (IOException) pea.getException();
1:8e4af95:         }
1:77323ec:     }
1:77323ec:     
1:77323ec:     /**
1:b9c57d5:      * Used to close the <code>ServerSocket</code> and the resources
1:b9c57d5:      * associated with it.
1:b9c57d5:      *
1:b9c57d5:      * @throws IOException If an exception occurs while trying to
1:b9c57d5:      *                     close the socket or the associated resources.
1:b9c57d5:      */
1:b9c57d5:     public void tearDown() throws IOException {
1:c283bcd:         synchronized (sendPingSemaphore) {
1:c283bcd:             killPingThread = true;
1:c283bcd:             sendPingSemaphore.notify();
1:c283bcd:         }
1:c283bcd: 
1:42526fd:         // socketConn.tearDown() may fail if the master has crashed. We still
1:42526fd:         // want to close the server socket if an exception is thrown, so that
1:42526fd:         // we don't prevent starting a new slave listening to the same port.
1:42526fd:         // Therefore, use try/finally. DERBY-3878
1:42526fd:         try {
1:42526fd:             if (socketConn != null) {
1:42526fd:                 socketConn.tearDown();
1:42526fd:             }
1:42526fd:         } finally {
1:42526fd:             if (serverSocket != null) {
1:42526fd:                 serverSocket.close();
1:42526fd:             }
1:b9c57d5:         }
1:b9c57d5:     }
1:b9c57d5:     
1:b9c57d5:     /**
1:77323ec:      * Used to parse the initiator message from the master and check if the
1:77323ec:      * slave is compatible with the master by comparing the UID of the 
1:77323ec:      * <code>ReplicationMessage</code> class of the master, that is wrapped
1:77323ec:      * in the initiator message, with the UID of the same class in the slave.
1:77323ec:      *
1:77323ec:      * @param initiatorMessage the object containing the UID.
1:29fd25c:      * @param dbname the name of the replicated database
1:77323ec:      *
1:77323ec:      * @throws IOException If an exception occurs while sending the
1:77323ec:      *                     acknowledgment.
1:77323ec:      *
1:77323ec:      * @throws StandardException If the UID's do not match.
1:77323ec:      */
1:29fd25c:     private void parseAndAckVersion(ReplicationMessage initiatorMessage, 
1:29fd25c:                                     String dbname)
1:77323ec:         throws IOException, StandardException {
1:77323ec:         //Holds the replication message that will be sent
1:77323ec:         //to the master.
1:77323ec:         ReplicationMessage ack = null;
1:29fd25c: 
1:29fd25c:         //Check if this message is an initiate version message, if not
1:29fd25c:         //throw an exception
1:29fd25c:         if (initiatorMessage.getType() != 
1:29fd25c:                 ReplicationMessage.TYPE_INITIATE_VERSION) {
1:29fd25c:             // The message format was not recognized. Notify master and throw
1:29fd25c:             // an exception
1:29fd25c:             String expectedMsgId = String.
1:29fd25c:                 valueOf(ReplicationMessage.TYPE_INITIATE_VERSION);
1:29fd25c:             String receivedMsgId = String.valueOf(initiatorMessage.getType());
1:29fd25c:             handleUnexpectedMessage(dbname, expectedMsgId, receivedMsgId);
1:29fd25c:         }
1:29fd25c: 
1:77323ec:         //Get the UID of the master
1:77323ec:         long masterVersion = ((Long)initiatorMessage.getMessage()).longValue();
1:77323ec:         //If the UID's are equal send the acknowledgment message
1:77323ec:         if (masterVersion == ReplicationMessage.serialVersionUID) {
1:77323ec:             ack = new ReplicationMessage
1:77323ec:                 (ReplicationMessage.TYPE_ACK, "UID OK");
1:c085d07:             sendMessage(ack);
1:334e9a3:         } else {
1:29fd25c:             //If the UID's are not equal send an error message. The
1:29fd25c:             //object of a TYPE_ERROR message must be a String[]
1:77323ec:             ack = new ReplicationMessage
1:77323ec:                 (ReplicationMessage.TYPE_ERROR,
1:29fd25c:                  new String[]{SQLState.
1:29fd25c:                               REPLICATION_MASTER_SLAVE_VERSION_MISMATCH});
1:c085d07:             sendMessage(ack);
1:29fd25c: 
1:77323ec:             //The UID's do not match.
1:e071963:             throw StandardException.newException
1:77323ec:                 (SQLState.REPLICATION_MASTER_SLAVE_VERSION_MISMATCH);
1:334e9a3:         }
1:b9c57d5:     }
1:29fd25c: 
1:29fd25c:     /**
1:29fd25c:      * Used to parse the log instant initiator message from the master and 
1:29fd25c:      * check that the master and slave log files are in synch.
1:29fd25c:      *
1:29fd25c:      * @param initiatorMessage the object containing the UID.
1:29fd25c:      * @param synchOnInstant the slave log instant, used to check that
1:29fd25c:      * the master and slave log files are in synch. If no chunks of log
1:29fd25c:      * records have been received from the master yet, this is the
1:29fd25c:      * end position in the current log file. If a chunk of log has been
1:29fd25c:      * received, this is the instant of the log record received last.
1:29fd25c:      * Note that there is a difference!
1:29fd25c:      * @param dbname the name of the replicated database
1:29fd25c:      *
1:29fd25c:      * @throws IOException If an exception occurs while sending the
1:29fd25c:      *                     acknowledgment.
1:29fd25c:      *
1:29fd25c:      * @throws StandardException If the log files are not in synch
1:29fd25c:      */
1:29fd25c:     private void parseAndAckInstant(ReplicationMessage initiatorMessage,
1:29fd25c:                                     long synchOnInstant, String dbname)
1:29fd25c:         throws IOException, StandardException {
1:29fd25c:         ReplicationMessage ack = null;
1:29fd25c: 
1:29fd25c:         //Check if this message is a log synch message, if not throw
1:29fd25c:         //an exception
1:29fd25c:         if (initiatorMessage.getType() !=
1:29fd25c:             ReplicationMessage.TYPE_INITIATE_INSTANT) {
1:29fd25c:             // The message format was not recognized. Notify master and throw 
1:29fd25c:             // an exception
1:29fd25c:             String expectedMsgId = String.
1:29fd25c:                 valueOf(ReplicationMessage.TYPE_INITIATE_INSTANT);
1:29fd25c:             String receivedMsgId = String.valueOf(initiatorMessage.getType());
1:29fd25c:             handleUnexpectedMessage(dbname, expectedMsgId, receivedMsgId);
1:29fd25c:         }
1:29fd25c: 
1:29fd25c:         // Get the log instant of the master
1:29fd25c:         long masterInstant = ((Long)initiatorMessage.getMessage()).longValue();
1:29fd25c: 
1:29fd25c:         if (masterInstant == synchOnInstant) {
1:29fd25c:             // Notify the master that the logs are in synch
1:29fd25c:             ack = new ReplicationMessage
1:29fd25c:                 (ReplicationMessage.TYPE_ACK, "Instant OK");
1:c085d07:             sendMessage(ack);
1:29fd25c:         } else {
1:29fd25c:             // Notify master that the logs are out of synch
1:29fd25c:             // See ReplicationMessage#TYPE_ERROR
1:29fd25c:             String[] exception = new String[6];
1:29fd25c:             exception[0] = dbname;
1:29fd25c:             exception[1] = String.valueOf(LogCounter.
1:29fd25c:                                           getLogFileNumber(masterInstant));
1:29fd25c:             exception[2] = String.valueOf(LogCounter.
1:29fd25c:                                           getLogFilePosition(masterInstant));
1:29fd25c:             exception[3] = String.valueOf(LogCounter.
1:29fd25c:                                           getLogFileNumber(synchOnInstant));
1:29fd25c:             exception[4] = String.valueOf(LogCounter.
1:29fd25c:                                           getLogFilePosition(synchOnInstant));
1:29fd25c:             exception[5] = SQLState.REPLICATION_LOG_OUT_OF_SYNCH;
1:29fd25c:             ack = new ReplicationMessage(ReplicationMessage.TYPE_ERROR, 
1:29fd25c:                                          exception);
1:c085d07:             sendMessage(ack);
1:29fd25c: 
1:29fd25c:             throw StandardException.
1:29fd25c:                 newException(SQLState.REPLICATION_LOG_OUT_OF_SYNCH, exception);
1:29fd25c:         }
1:29fd25c:     }
1:77323ec:     
1:77323ec:     /**
1:29fd25c:      * Notify other replication peer that the message type was unexpected and 
1:29fd25c:      * throw a StandardException
1:29fd25c:      *
1:29fd25c:      * @param dbname the name of the replicated database
1:29fd25c:      * @param expextedMsgId the expected message type
1:29fd25c:      * @param receivedMsgId the received message type
1:29fd25c:      *
1:29fd25c:      * @throws StandardException exception describing that an unexpected
1:29fd25c:      * message was received is always thrown 
1:29fd25c:      * @throws java.io.IOException thrown if an exception occurs while sending
1:29fd25c:      * the error message 
1:29fd25c:      */
1:29fd25c:     private void handleUnexpectedMessage(String dbname, 
1:29fd25c:                                          String expextedMsgId,
1:29fd25c:                                          String receivedMsgId)
1:29fd25c:         throws StandardException, IOException {
1:29fd25c:         String[] exception = new String[4];
1:29fd25c:         exception[0] = dbname;
1:29fd25c:         exception[1] = expextedMsgId;
1:29fd25c:         exception[2] = receivedMsgId;
1:29fd25c:         exception[3] = SQLState.REPLICATION_UNEXPECTED_MESSAGEID;
1:29fd25c: 
1:29fd25c:         ReplicationMessage ack = 
1:29fd25c:             new ReplicationMessage(ReplicationMessage.TYPE_ERROR, exception);
1:29fd25c: 
1:c085d07:         sendMessage(ack);
1:29fd25c: 
1:29fd25c:         throw StandardException.
1:29fd25c:             newException(SQLState.REPLICATION_UNEXPECTED_MESSAGEID, exception);
1:29fd25c: 
1:29fd25c:     }
1:29fd25c: 
1:29fd25c:     /**
1:77323ec:      * Used to send a replication message to the master.
1:77323ec:      *
1:77323ec:      * @param message a <code>ReplicationMessage</code> object that contains
1:77323ec:      *                the message to be transmitted.
1:77323ec:      *
1:c085d07:      * @throws IOException 1) if an exception occurs while transmitting
1:c085d07:      *                        the message,
1:c085d07:      *                     2) if the connection handle is invalid.
1:77323ec:      */
1:77323ec:     public void sendMessage(ReplicationMessage message) throws IOException {
1:c085d07:         checkSocketConnection();
1:77323ec:         socketConn.writeMessage(message);
1:e071963:     }
1:77323ec:     
1:77323ec:     /**
1:77323ec:      * Used to read a replication message sent by the master. This method
1:77323ec:      * would wait on the connection from the master until a message is received
1:c283bcd:      * or a connection failure occurs. Replication network layer specific
1:c283bcd:      * messages (i.e. ping/pong messages) are handled internally and are not
1:c283bcd:      * returned.
1:77323ec:      *
1:77323ec:      * @return a <code>ReplicationMessage</code> object that contains
1:77323ec:      *         the reply that is sent.
1:77323ec:      *
1:77323ec:      * @throws ClassNotFoundException Class of a serialized object cannot
1:77323ec:      *                                be found.
1:77323ec:      *
1:c085d07:      * @throws IOException 1) if an exception occurs while reading from the
1:c085d07:      *                        stream,
1:c085d07:      *                     2) if the connection handle is invalid.
1:77323ec:      */
1:77323ec:     public ReplicationMessage readMessage() throws
1:77323ec:         ClassNotFoundException, IOException {
1:c085d07:         checkSocketConnection();
1:c283bcd:         ReplicationMessage msg = (ReplicationMessage)socketConn.readMessage();
1:c283bcd: 
1:c283bcd:         if (msg.getType() == ReplicationMessage.TYPE_PONG) {
1:c283bcd:             // If a pong is received, connection is confirmed to be working.
1:c283bcd:             synchronized (receivePongSemaphore) {
1:c283bcd:                 connectionConfirmed = true;
1:c283bcd:                 receivePongSemaphore.notify();
1:c283bcd:             }
1:c283bcd:             // Pong messages are network layer specific. Do not return these
1:c283bcd:             return readMessage();
1:c283bcd:         } else {
1:c283bcd:             return msg;
1:c283bcd:         }
1:334e9a3:     }
1:334e9a3:         
1:334e9a3:     /**
1:c085d07:      * Verifies if the <code>SocketConnection</code> is valid.
1:c085d07:      *
1:c085d07:      * @throws IOException If the socket connection object is not
1:c085d07:      *                     valid (is null).
1:c085d07:      */
1:c085d07:     private void checkSocketConnection() throws IOException {
1:c085d07:         if (socketConn == null) {
1:c085d07:             throw new IOException
1:c085d07:                     (MessageId.REPLICATION_INVALID_CONNECTION_HANDLE);
1:c085d07:         }
1:c085d07:     }
1:c283bcd: 
1:c283bcd:     /**
1:c283bcd:      * Check if the repliation network is working. Tries to send a ping
1:c283bcd:      * message to the master and returns the network status based on the
1:c283bcd:      * success or failure of sending this message and receiving a pong reply.
1:c283bcd:      * MT: Currently, only one thread is allowed to check the network status at
1:c283bcd:      * any time to keep the code complexity down.
1:c283bcd:      * @return true if the pong message was received before timing out after
1:c283bcd:      * DEFAULT_PING_TIMEOUT millis, false otherwise
1:c283bcd:      * @see #DEFAULT_PING_TIMEOUT
1:c283bcd:      */
1:c283bcd:     public synchronized boolean isConnectedToMaster() {
1:c283bcd:         // synchronize on receivePongSemaphore so that this thread is
1:c283bcd:         // guaraneed to get to receivePongSemaphore.wait before the pong
1:c283bcd:         // message is processed in readMessage
1:5d97422: 
1:c283bcd:         synchronized (receivePongSemaphore) {
1:c283bcd:             connectionConfirmed = false;
1:5d97422: 
1:5d97422:             long startWaitingatTime;
1:5d97422:             long giveupWaitingAtTime;
1:5d97422:             long nextWait = DEFAULT_PING_TIMEOUT;
1:5d97422: 
1:c283bcd:             synchronized (sendPingSemaphore) {
1:c283bcd:                 // Make ping thread send a ping message to the master
1:5d97422:                 doSendPing = true;
1:c283bcd:                 sendPingSemaphore.notify();
1:5d97422: 
1:5d97422:                 // want result within DEFAULT_PING_TIMEOUT millis.
1:5d97422:                 startWaitingatTime = System.currentTimeMillis();
1:5d97422:                 giveupWaitingAtTime = startWaitingatTime + DEFAULT_PING_TIMEOUT;
1:c283bcd:             }
1:c283bcd: 
1:5d97422:             while (true) {
1:5d97422:                 try {
1:5d97422:                     // Wait for the pong response message
1:5d97422:                     receivePongSemaphore.wait(nextWait);
1:5d97422:                 } catch (InterruptedException ex) {
1:5d97422:                     InterruptStatus.setInterrupted();
1:5d97422:                 }
1:5d97422: 
1:5d97422:                 nextWait = giveupWaitingAtTime - System.currentTimeMillis();
1:5d97422: 
1:5d97422:                 if (!connectionConfirmed && nextWait > 0) {
1:5d97422:                     // we could have been interrupted or seen a spurious
1:5d97422:                     // wakeup, so wait a bit longer
1:5d97422:                     continue;
1:5d97422:                 }
1:5d97422:                 break;
1:c283bcd:             }
1:c283bcd:         }
1:c283bcd:         return connectionConfirmed;
1:c283bcd:     }
1:c283bcd: 
1:c283bcd:     /////////////////
1:c283bcd:     // Inner Class //
1:c283bcd:     /////////////////
1:c283bcd:     /**
1:c283bcd:      * Thread that sends ping messages to the master on request to check if the
1:c283bcd:      * replication network is working
1:c283bcd:      */
1:c283bcd:     private class SlavePingThread extends Thread {
1:c283bcd: 
1:c283bcd:         private final ReplicationMessage pingMsg =
1:c283bcd:             new ReplicationMessage(ReplicationMessage.TYPE_PING, null);
1:c283bcd: 
1:c283bcd:         SlavePingThread(String dbname) {
1:c283bcd:             super("derby.slave.ping-" + dbname);
1:c283bcd:         }
1:c283bcd: 
1:c283bcd:         public void run() {
2:c283bcd:             try {
1:c283bcd:                 while (!killPingThread) {
1:c283bcd:                     synchronized (sendPingSemaphore) {
1:5d97422:                         while (!doSendPing) {
1:5d97422:                             try {
1:5d97422:                                 sendPingSemaphore.wait();
1:5d97422:                             } catch (InterruptedException e) {
1:5d97422:                                 InterruptStatus.setInterrupted();
1:5d97422:                             }
1:5d97422:                         }
1:5d97422: 
1:5d97422:                         doSendPing = false;
1:c283bcd:                     }
1:5d97422: 
1:c283bcd:                     if (killPingThread) {
1:c283bcd:                         // The thread was notified to terminate
1:c283bcd:                         break;
1:c283bcd:                     }
1:c283bcd: 
1:c283bcd:                     sendMessage(pingMsg);
1:c283bcd:                 }
1:c283bcd:             } catch (IOException ioe) {
1:c283bcd:             // For both exceptions: Do nothing. isConnectedToMaster will return
1:c283bcd:             // 'false' and appropriate action will be taken.
1:c283bcd:             }
1:c283bcd:         }
1:c283bcd:     }
1:77323ec: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:7e7a589
/////////////////////////////////////////////////////////////////////////
1:                 AccessController.doPrivileged(new PrivilegedExceptionAction<Socket>() {
1:                     public Socket run() throws IOException {
/////////////////////////////////////////////////////////////////////////
1:             ss = AccessController.doPrivileged
1:             (new PrivilegedExceptionAction<ServerSocket>() {
1:                 public ServerSocket run() throws IOException  {
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:5d97422
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.util.InterruptStatus;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Whether or not the ping thread has been notified to check connection.
1:      * Protected by sendPingSemaphore.
1:      */
1:     private boolean doSendPing = false;
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:             long startWaitingatTime;
1:             long giveupWaitingAtTime;
1:             long nextWait = DEFAULT_PING_TIMEOUT;
1: 
1:                 doSendPing = true;
1: 
1:                 // want result within DEFAULT_PING_TIMEOUT millis.
1:                 startWaitingatTime = System.currentTimeMillis();
1:                 giveupWaitingAtTime = startWaitingatTime + DEFAULT_PING_TIMEOUT;
1:             while (true) {
1:                 try {
1:                     // Wait for the pong response message
1:                     receivePongSemaphore.wait(nextWait);
1:                 } catch (InterruptedException ex) {
1:                     InterruptStatus.setInterrupted();
1:                 }
1: 
1:                 nextWait = giveupWaitingAtTime - System.currentTimeMillis();
1: 
1:                 if (!connectionConfirmed && nextWait > 0) {
1:                     // we could have been interrupted or seen a spurious
1:                     // wakeup, so wait a bit longer
1:                     continue;
1:                 }
1:                 break;
/////////////////////////////////////////////////////////////////////////
1:                         while (!doSendPing) {
1:                             try {
1:                                 sendPingSemaphore.wait();
1:                             } catch (InterruptedException e) {
1:                                 InterruptStatus.setInterrupted();
1:                             }
1:                         }
1: 
1:                         doSendPing = false;
1: 
/////////////////////////////////////////////////////////////////////////
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:8e4af95
/////////////////////////////////////////////////////////////////////////
1:      * IOException is raised with cause
/////////////////////////////////////////////////////////////////////////
1:      *
1:      *                     <code>SocketConnection</code> class or while
1:      *                     trying to open a connection.
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         Socket client = null;
1:         try {
1:             //Start listening on the socket and accepting the connection
1:             client =
0:                 (Socket)
0:                 AccessController.doPrivileged(new PrivilegedExceptionAction() {
0:                     public Object run() throws IOException {
1:                         return serverSocket.accept();
1:                     }
1:                 });
1:         } catch(PrivilegedActionException pea) {
1:             throw (IOException) pea.getException();
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1:      * @throws IOException if an exception occurs while trying
1:     private ServerSocket createServerSocket() throws IOException {
1:         ServerSocket ss = null;
1:         try { 
0:             ss =   (ServerSocket) AccessController.doPrivileged
0:                 public Object run() throws IOException  {
1:                     ServerSocketFactory sf = ServerSocketFactory.getDefault();
1:                     return sf.createServerSocket(slaveAddress.getPortNumber(),
1:                             0, slaveAddress.getHostAddress());
1:                 }
1:             });
1:             return ss;
1:         } catch(PrivilegedActionException pea) {
1:             throw (IOException) pea.getException();
1:         }
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:42526fd
/////////////////////////////////////////////////////////////////////////
1:         // socketConn.tearDown() may fail if the master has crashed. We still
1:         // want to close the server socket if an exception is thrown, so that
1:         // we don't prevent starting a new slave listening to the same port.
1:         // Therefore, use try/finally. DERBY-3878
1:         try {
1:             if (socketConn != null) {
1:                 socketConn.tearDown();
1:             }
1:         } finally {
1:             if (serverSocket != null) {
1:                 serverSocket.close();
1:             }
author:Oystein Grovlen
-------------------------------------------------------------------------------
commit:f2ec1d8
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:      * @param slaveAddress the address (host name and port number) of the slave
1:      *                     to connect to.
1:      * @param dbname the name of the database.
1:     public ReplicationMessageReceive(SlaveAddress slaveAddress, 
1:                                      String dbname) {
1:         this.slaveAddress = slaveAddress;
1:         Monitor.logTextMessage(MessageId.REPLICATION_SLAVE_NETWORK_LISTEN,
1:                                dbname, 
1:                                slaveAddress.getHostAddress().getHostName(),
1:                                String.valueOf(slaveAddress.getPortNumber()));
/////////////////////////////////////////////////////////////////////////
commit:c283bcd
/////////////////////////////////////////////////////////////////////////
1:     /* -- Ping-thread related fields start -- */
1: 
1:     /** The maximum number of millis to wait before giving up waiting for
1:      * a ping response*/
1:     private static final int DEFAULT_PING_TIMEOUT = 5000; // 5 seconds
1: 
1:     /** Thread used to send ping messages to master to check if the connection
1:      * is working. The ping message must be sent from a separate thread
1:      * because failed message shipping over TCP does not timeout for two
1:      * minutes (not configurable). */
1:     private Thread pingThread = null;
1: 
1:     /** Used to terminate the ping thread. */
1:     private boolean killPingThread = false;
1: 
1:     /** Whether or not the connection with the master is confirmed to be
1:      * working. Set to false by isConnectedToMaster, set to true when
1:      * a pong (i.e., a response to a ping) is received. Field protected by
1:      * receivePongSemephore */
1:     private boolean connectionConfirmed = false;
1: 
1:     /** Used for synchronization of the ping thread */
1:     private final Object sendPingSemaphore = new Object();
1: 
1:     /** Used for synchronization when waiting for a ping reply message */
1:     private final Object receivePongSemaphore = new Object();
1: 
1:     /* -- Ping-thread related fields stop -- */
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:         killPingThread = false;
1:         pingThread = new SlavePingThread(dbname);
1:         pingThread.setDaemon(true);
1:         pingThread.start();
1: 
/////////////////////////////////////////////////////////////////////////
1:         synchronized (sendPingSemaphore) {
1:             killPingThread = true;
1:             sendPingSemaphore.notify();
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1:      * or a connection failure occurs. Replication network layer specific
1:      * messages (i.e. ping/pong messages) are handled internally and are not
1:      * returned.
/////////////////////////////////////////////////////////////////////////
1:         ReplicationMessage msg = (ReplicationMessage)socketConn.readMessage();
1: 
1:         if (msg.getType() == ReplicationMessage.TYPE_PONG) {
1:             // If a pong is received, connection is confirmed to be working.
1:             synchronized (receivePongSemaphore) {
1:                 connectionConfirmed = true;
1:                 receivePongSemaphore.notify();
1:             }
1:             // Pong messages are network layer specific. Do not return these
1:             return readMessage();
1:         } else {
1:             return msg;
1:         }
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Check if the repliation network is working. Tries to send a ping
1:      * message to the master and returns the network status based on the
1:      * success or failure of sending this message and receiving a pong reply.
1:      * MT: Currently, only one thread is allowed to check the network status at
1:      * any time to keep the code complexity down.
1:      * @return true if the pong message was received before timing out after
1:      * DEFAULT_PING_TIMEOUT millis, false otherwise
1:      * @see #DEFAULT_PING_TIMEOUT
1:      */
1:     public synchronized boolean isConnectedToMaster() {
1:         // synchronize on receivePongSemaphore so that this thread is
1:         // guaraneed to get to receivePongSemaphore.wait before the pong
1:         // message is processed in readMessage
1:         synchronized (receivePongSemaphore) {
1:             connectionConfirmed = false;
1:             synchronized (sendPingSemaphore) {
1:                 // Make ping thread send a ping message to the master
1:                 sendPingSemaphore.notify();
1:             }
1: 
1:             try {
0:                 // Wait for the pong response message
0:                 receivePongSemaphore.wait(DEFAULT_PING_TIMEOUT);
0:             } catch (InterruptedException ex) {
1:             }
1:         }
1:         return connectionConfirmed;
1:     }
1: 
1:     /////////////////
1:     // Inner Class //
1:     /////////////////
1:     /**
1:      * Thread that sends ping messages to the master on request to check if the
1:      * replication network is working
1:      */
1:     private class SlavePingThread extends Thread {
1: 
1:         private final ReplicationMessage pingMsg =
1:             new ReplicationMessage(ReplicationMessage.TYPE_PING, null);
1: 
1:         SlavePingThread(String dbname) {
1:             super("derby.slave.ping-" + dbname);
1:         }
1: 
1:         public void run() {
1:             try {
1:                 while (!killPingThread) {
1:                     synchronized (sendPingSemaphore) {
0:                         sendPingSemaphore.wait();
1:                     }
1:                     if (killPingThread) {
1:                         // The thread was notified to terminate
1:                         break;
1:                     }
1: 
1:                     sendMessage(pingMsg);
1:                 }
0:             } catch (InterruptedException ie) {
1:             } catch (IOException ioe) {
1:             // For both exceptions: Do nothing. isConnectedToMaster will return
1:             // 'false' and appropriate action will be taken.
1:             }
1:         }
1:     }
commit:1bac3f3
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.store.replication.net.ReplicationMessageReceive
/////////////////////////////////////////////////////////////////////////
1: package org.apache.derby.impl.store.replication.net;
commit:c085d07
/////////////////////////////////////////////////////////////////////////
1:             sendMessage(ack);
/////////////////////////////////////////////////////////////////////////
1:             sendMessage(ack);
/////////////////////////////////////////////////////////////////////////
1:             sendMessage(ack);
/////////////////////////////////////////////////////////////////////////
1:             sendMessage(ack);
/////////////////////////////////////////////////////////////////////////
1:         sendMessage(ack);
/////////////////////////////////////////////////////////////////////////
1:      * @throws IOException 1) if an exception occurs while transmitting
1:      *                        the message,
1:      *                     2) if the connection handle is invalid.
1:         checkSocketConnection();
/////////////////////////////////////////////////////////////////////////
1:      * @throws IOException 1) if an exception occurs while reading from the
1:      *                        stream,
1:      *                     2) if the connection handle is invalid.
1:         checkSocketConnection();
/////////////////////////////////////////////////////////////////////////
1:         
1:     /**
1:      * Verifies if the <code>SocketConnection</code> is valid.
1:      *
1:      * @throws IOException If the socket connection object is not
1:      *                     valid (is null).
1:      */
1:     private void checkSocketConnection() throws IOException {
1:         if (socketConn == null) {
1:             throw new IOException
1:                     (MessageId.REPLICATION_INVALID_CONNECTION_HANDLE);
1:         }
1:     }
commit:29fd25c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.impl.store.raw.log.LogCounter;
/////////////////////////////////////////////////////////////////////////
1:      * @param synchOnInstant the slave log instant, used to check that
1:      * the master and slave log files are in synch. If no chunks of log
1:      * records have been received from the master yet, this is the
1:      * end position in the current log file. If a chunk of log has been
1:      * received, this is the instant of the log record received last.
1:      * Note that there is a difference!
1:      * @param dbname the name of the replicated database
/////////////////////////////////////////////////////////////////////////
1:     public void initConnection(int timeout, long synchOnInstant, String dbname)
1:         throws
/////////////////////////////////////////////////////////////////////////
1:         // exchange initiator messages to check that master and slave are at 
1:         // the same version...
1:         parseAndAckVersion(readMessage(), dbname);
1:         // ...and have equal log files
1:         parseAndAckInstant(readMessage(), synchOnInstant, dbname);
/////////////////////////////////////////////////////////////////////////
1:      * @param dbname the name of the replicated database
1:     private void parseAndAckVersion(ReplicationMessage initiatorMessage, 
1:                                     String dbname)
1: 
1:         //Check if this message is an initiate version message, if not
1:         //throw an exception
1:         if (initiatorMessage.getType() != 
1:                 ReplicationMessage.TYPE_INITIATE_VERSION) {
1:             // The message format was not recognized. Notify master and throw
1:             // an exception
1:             String expectedMsgId = String.
1:                 valueOf(ReplicationMessage.TYPE_INITIATE_VERSION);
1:             String receivedMsgId = String.valueOf(initiatorMessage.getType());
1:             handleUnexpectedMessage(dbname, expectedMsgId, receivedMsgId);
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1:             //If the UID's are not equal send an error message. The
1:             //object of a TYPE_ERROR message must be a String[]
1:                  new String[]{SQLState.
1:                               REPLICATION_MASTER_SLAVE_VERSION_MISMATCH});
0:             socketConn.writeMessage(ack);
1: 
1: 
1:     /**
1:      * Used to parse the log instant initiator message from the master and 
1:      * check that the master and slave log files are in synch.
1:      *
1:      * @param initiatorMessage the object containing the UID.
1:      * @param synchOnInstant the slave log instant, used to check that
1:      * the master and slave log files are in synch. If no chunks of log
1:      * records have been received from the master yet, this is the
1:      * end position in the current log file. If a chunk of log has been
1:      * received, this is the instant of the log record received last.
1:      * Note that there is a difference!
1:      * @param dbname the name of the replicated database
1:      *
1:      * @throws IOException If an exception occurs while sending the
1:      *                     acknowledgment.
1:      *
1:      * @throws StandardException If the log files are not in synch
1:      */
1:     private void parseAndAckInstant(ReplicationMessage initiatorMessage,
1:                                     long synchOnInstant, String dbname)
1:         throws IOException, StandardException {
1:         ReplicationMessage ack = null;
1: 
1:         //Check if this message is a log synch message, if not throw
1:         //an exception
1:         if (initiatorMessage.getType() !=
1:             ReplicationMessage.TYPE_INITIATE_INSTANT) {
1:             // The message format was not recognized. Notify master and throw 
1:             // an exception
1:             String expectedMsgId = String.
1:                 valueOf(ReplicationMessage.TYPE_INITIATE_INSTANT);
1:             String receivedMsgId = String.valueOf(initiatorMessage.getType());
1:             handleUnexpectedMessage(dbname, expectedMsgId, receivedMsgId);
1:         }
1: 
1:         // Get the log instant of the master
1:         long masterInstant = ((Long)initiatorMessage.getMessage()).longValue();
1: 
1:         if (masterInstant == synchOnInstant) {
1:             // Notify the master that the logs are in synch
1:             ack = new ReplicationMessage
1:                 (ReplicationMessage.TYPE_ACK, "Instant OK");
0:             socketConn.writeMessage(ack);
1:         } else {
1:             // Notify master that the logs are out of synch
1:             // See ReplicationMessage#TYPE_ERROR
1:             String[] exception = new String[6];
1:             exception[0] = dbname;
1:             exception[1] = String.valueOf(LogCounter.
1:                                           getLogFileNumber(masterInstant));
1:             exception[2] = String.valueOf(LogCounter.
1:                                           getLogFilePosition(masterInstant));
1:             exception[3] = String.valueOf(LogCounter.
1:                                           getLogFileNumber(synchOnInstant));
1:             exception[4] = String.valueOf(LogCounter.
1:                                           getLogFilePosition(synchOnInstant));
1:             exception[5] = SQLState.REPLICATION_LOG_OUT_OF_SYNCH;
1:             ack = new ReplicationMessage(ReplicationMessage.TYPE_ERROR, 
1:                                          exception);
0:             socketConn.writeMessage(ack);
1: 
1:             throw StandardException.
1:                 newException(SQLState.REPLICATION_LOG_OUT_OF_SYNCH, exception);
1:         }
1:     }
1:      * Notify other replication peer that the message type was unexpected and 
1:      * throw a StandardException
1:      *
1:      * @param dbname the name of the replicated database
1:      * @param expextedMsgId the expected message type
1:      * @param receivedMsgId the received message type
1:      *
1:      * @throws StandardException exception describing that an unexpected
1:      * message was received is always thrown 
1:      * @throws java.io.IOException thrown if an exception occurs while sending
1:      * the error message 
1:      */
1:     private void handleUnexpectedMessage(String dbname, 
1:                                          String expextedMsgId,
1:                                          String receivedMsgId)
1:         throws StandardException, IOException {
1:         String[] exception = new String[4];
1:         exception[0] = dbname;
1:         exception[1] = expextedMsgId;
1:         exception[2] = receivedMsgId;
1:         exception[3] = SQLState.REPLICATION_UNEXPECTED_MESSAGEID;
1: 
1:         ReplicationMessage ack = 
1:             new ReplicationMessage(ReplicationMessage.TYPE_ERROR, exception);
1: 
0:         socketConn.writeMessage(ack);
1: 
1:         throw StandardException.
1:             newException(SQLState.REPLICATION_UNEXPECTED_MESSAGEID, exception);
1: 
1:     }
1: 
1:     /**
commit:334e9a3
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.reference.MessageId;
1: import org.apache.derby.iapi.services.monitor.Monitor;
/////////////////////////////////////////////////////////////////////////
0:      * @param dbname the name of the database
0:     public ReplicationMessageReceive(String hostName, int portNumber, 
0:                                      String dbname)
0:             Monitor.logTextMessage(MessageId.REPLICATION_SLAVE_NETWORK_LISTEN, 
0:                                    dbname, getHostName(), 
0:                                    String.valueOf(getPort()));
0:             // cannot use getPort because SlaveAddress creator threw
0:             // exception and has therefore not been initialized
0:             String port;
0:             if (portNumber > 0) {
0:                 port = String.valueOf(portNumber);
1:             } else {
0:                 port = String.valueOf(SlaveAddress.DEFAULT_PORT_NO);
1:             }
0:                 (SQLState.REPLICATION_CONNECTION_EXCEPTION, uhe, 
0:                  dbname, hostName, port);
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
0:      * Used to get the host name the slave listens for master
0:      * connections on
1:      *
0:      * @return the host name 
1:      */
0:     public String getHostName() {
0:         return slaveAddress.getHostAddress().getHostName();
1:      }
1: 
1:     /**
0:      * Used to get the port number the slave listens for master
0:      * connections on
1:      *
0:      * @return the port number
1:      */
0:     public int getPort() {
0:         return slaveAddress.getPortNumber();
1:      }
commit:b9c57d5
/////////////////////////////////////////////////////////////////////////
1:      * Used to close the <code>ServerSocket</code> and the resources
1:      * associated with it.
1:      *
1:      * @throws IOException If an exception occurs while trying to
1:      *                     close the socket or the associated resources.
1:      */
1:     public void tearDown() throws IOException {
0:         if (socketConn != null) {
0:             socketConn.tearDown();
1:         }
0:         if (serverSocket != null) {
0:             serverSocket.close();
1:         }
1:     }
1:     
1:     /**
commit:c458b05
/////////////////////////////////////////////////////////////////////////
1:      * Contains the <code>ServerSocket</code> used to listen for
1:      * connections from the replication master. */
1:     private ServerSocket serverSocket;
1: 
1:     /**
/////////////////////////////////////////////////////////////////////////
1:         // Create the ServerSocket object if this is the first
1:         // initConnection attempt. Otherwise, we reuse the existing
1:         // server socket
1:         if (serverSocket == null) {
1:             serverSocket = createServerSocket();
1:         }
commit:e071963
/////////////////////////////////////////////////////////////////////////
0:      * @throws StandardException If an exception occurs while trying to
0:      *                           resolve the host name.
0:         throws StandardException {
0:         try {
0:             slaveAddress = new SlaveAddress(hostName, portNumber);
0:         } catch (UnknownHostException uhe) {
1:             throw StandardException.newException
0:                 (SQLState.REPLICATION_CONNECTION_EXCEPTION, uhe);
1:         }
/////////////////////////////////////////////////////////////////////////
1:      * @param timeout The amount of time, in milliseconds, this method
1:      * will wait for a connection to be established. If no connection
1:      * has been established before the timeout, a
0:      * PrivilegedExceptionAction is raised with cause
1:      * java.net.SocketTimeoutException
1:      *
/////////////////////////////////////////////////////////////////////////
0:     public void initConnection(int timeout) throws
/////////////////////////////////////////////////////////////////////////
1:         serverSocket.setSoTimeout(timeout);
commit:77323ec
/////////////////////////////////////////////////////////////////////////
1: /*
1:  
0:    Derby - Class org.apache.derby.impl.services.replication.net.ReplicationMessageReceive
1:  
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1:  
1:       http://www.apache.org/licenses/LICENSE-2.0
1:  
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1:  
1:  */
1: 
0: package org.apache.derby.impl.services.replication.net;
1: 
1: import java.io.IOException;
1: import java.net.ServerSocket;
1: import java.net.Socket;
0: import java.net.UnknownHostException;
1: import java.security.AccessController;
1: import java.security.PrivilegedActionException;
1: import java.security.PrivilegedExceptionAction;
1: import javax.net.ServerSocketFactory;
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.reference.SQLState;
1: 
1: /**
1:  * This class is the Receiver (viz. Socket server or listener) part of the
1:  * network communication. It receives the message from the master and
1:  * performs appropriate action depending on the type of the message.
1:  */
1: public class ReplicationMessageReceive {
1:     /**
1:      * Contains the address (hostname and port number) of the slave
1:      * to replicate to.
1:      */
1:     private final SlaveAddress slaveAddress;
1:     
1:     /**
1:      * Contains the methods used to read and write to the Object streams
1:      * obtained from a <code>Socket</code> connection.
1:      */
1:     private SocketConnection socketConn;
1:     
1:     /**
1:      * Constructor initializes the slave address used in replication. Accepts
1:      * the host name and port number that constitute the slave address as
1:      * parameters.
1:      *
0:      * @param hostName a <code>String</code> that contains the host name of
0:      *                 the slave to replicate to.
0:      * @param portNumber an integer that contains the port number of the
0:      *                   slave to replicate to.
1:      *
0:      * @throws UnknownHostException If an exception occurs while trying to
0:      *                              resolve the host name.
1:      */
0:     public ReplicationMessageReceive(String hostName, int portNumber)
0:     throws UnknownHostException {
0:         slaveAddress = new SlaveAddress(hostName, portNumber);
1:     }
1:     
1:     /**
1:      * Used to create the server socket, listen on the socket
1:      * for connections from the master and verify compatibility
1:      * with the database version of the master.
1:      *
0:      * @throws PrivilegedActionException if an exception occurs while trying
1:      *                                   to open a connection.
1:      *
1:      * @throws IOException if an exception occurs while trying to create the
0:      *                     <code>SocketConnection</code> class.
1:      *
1:      * @throws ClassNotFoundException Class of a serialized object cannot
1:      *                                be found.
1:      * @throws StandardException if an incompatible database version is found.
1:      *
1:      */
0:     public void initConnection() throws
0:         PrivilegedActionException,
1:         IOException,
1:         StandardException,
1:         ClassNotFoundException {
1:         
0:         //Contains the <code>ServerSocket</code> used to listen for
0:         //connections from the replication master.
0:         final ServerSocket serverSocket = createServerSocket();
1:         
0:         //Start listening on the socket and accepting the connection
0:         Socket client =
0:             (Socket)
0:             AccessController.doPrivileged(new PrivilegedExceptionAction() {
0:             public Object run() throws IOException {
0:                 return serverSocket.accept();
1:             }
0:         });
1:         
1:         //create the SocketConnection object using the client connection.
1:         socketConn = new SocketConnection(client);
1:         
0:         //wait for the initiator message on the SocketConnection
0:         ReplicationMessage initMesg = readMessage();
1:         
0:         //Check if this message is an initiator message, if not
0:         //throw an exception
0:         if (initMesg.getType() != ReplicationMessage.TYPE_INITIATE) {
0:             //The message format was not recognized. Hence throw
0:             //an unexpected exception.
0:             throw StandardException.newException
0:                 (SQLState.REPLICATION_UNEXPECTED_EXCEPTION);
1:         }
1:         
0:         //parse the initiator message and perform appropriate action
0:         parseInitiatorMessage(initMesg);
1:     }
1:     
1:     /**
1:      * Used to create a <code>ServerSocket</code> for listening to connections
1:      * from the master.
1:      *
1:      * @return an instance of the <code>ServerSocket</code> class.
1:      *
0:      * @throws PrivilegedActionException if an exception occurs while trying
1:      *                                   to open a connection.
1:      */
0:     private ServerSocket createServerSocket() throws PrivilegedActionException {
1:         //create a ServerSocket at the specified host name and the
1:         //port number.
0:         return   (ServerSocket) AccessController.doPrivileged
0:             (new PrivilegedExceptionAction() {
0:             public Object run() throws IOException, StandardException {
0:                 ServerSocketFactory sf = ServerSocketFactory.getDefault();
0:                 return sf.createServerSocket(slaveAddress.getPortNumber(),
0:                     0, slaveAddress.getHostAddress());
1:             }
0:         });
1:     }
1:     
1:     /**
1:      * Used to parse the initiator message from the master and check if the
1:      * slave is compatible with the master by comparing the UID of the 
1:      * <code>ReplicationMessage</code> class of the master, that is wrapped
1:      * in the initiator message, with the UID of the same class in the slave.
1:      *
1:      * @param initiatorMessage the object containing the UID.
1:      *
1:      * @throws IOException If an exception occurs while sending the
1:      *                     acknowledgment.
1:      *
1:      * @throws StandardException If the UID's do not match.
1:      */
0:     private void parseInitiatorMessage(ReplicationMessage initiatorMessage)
1:         throws IOException, StandardException {
1:         //Holds the replication message that will be sent
1:         //to the master.
1:         ReplicationMessage ack = null;
1:         //Get the UID of the master
1:         long masterVersion = ((Long)initiatorMessage.getMessage()).longValue();
1:         //If the UID's are equal send the acknowledgment message
1:         if (masterVersion == ReplicationMessage.serialVersionUID) {
1:             ack = new ReplicationMessage
1:                 (ReplicationMessage.TYPE_ACK, "UID OK");
0:             socketConn.writeMessage(ack);
0:         } else {
0:             //If the UID's are not equal send an error message
1:             ack = new ReplicationMessage
1:                 (ReplicationMessage.TYPE_ERROR,
0:                 SQLState.REPLICATION_MASTER_SLAVE_VERSION_MISMATCH);
1:             
1:             //The UID's do not match.
0:             throw StandardException.newException
1:                 (SQLState.REPLICATION_MASTER_SLAVE_VERSION_MISMATCH);
1:         }
1:     }
1:     
1:     /**
1:      * Used to send a replication message to the master.
1:      *
1:      * @param message a <code>ReplicationMessage</code> object that contains
1:      *                the message to be transmitted.
1:      *
0:      * @throws IOException if an exception occurs while transmitting
0:      *                     the message.
1:      */
1:     public void sendMessage(ReplicationMessage message) throws IOException {
1:         socketConn.writeMessage(message);
1:     }
1:     
1:     /**
1:      * Used to read a replication message sent by the master. This method
1:      * would wait on the connection from the master until a message is received
0:      * or a connection failure occurs.
1:      *
1:      * @return a <code>ReplicationMessage</code> object that contains
1:      *         the reply that is sent.
1:      *
1:      * @throws ClassNotFoundException Class of a serialized object cannot
1:      *                                be found.
1:      *
0:      * @throws IOException if an exception occurs while reading from the
0:      *                     stream.
1:      */
1:     public ReplicationMessage readMessage() throws
1:         ClassNotFoundException, IOException {
0:         return (ReplicationMessage)socketConn.readMessage();
1:     }
1: }
============================================================================