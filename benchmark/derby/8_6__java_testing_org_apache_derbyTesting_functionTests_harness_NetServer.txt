1:67614ad: /*
1:67614ad: 
1:f68f62f:    Derby - Class org.apache.derbyTesting.functionTests.harness.NetServer
1:67614ad: 
1:15651f5:    Licensed to the Apache Software Foundation (ASF) under one or more
1:15651f5:    contributor license agreements.  See the NOTICE file distributed with
1:15651f5:    this work for additional information regarding copyright ownership.
1:15651f5:    The ASF licenses this file to You under the Apache License, Version 2.0
1:15651f5:    (the "License"); you may not use this file except in compliance with
1:15651f5:    the License.  You may obtain a copy of the License at
64:f68f62f: 
1:f68f62f:       http://www.apache.org/licenses/LICENSE-2.0
1:f68f62f: 
1:f68f62f:    Unless required by applicable law or agreed to in writing, software
1:f68f62f:    distributed under the License is distributed on an "AS IS" BASIS,
1:f68f62f:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:f68f62f:    See the License for the specific language governing permissions and
1:f68f62f:    limitations under the License.
1:f68f62f: 
2:67614ad:  */
1:67614ad: 
1:67614ad: package org.apache.derbyTesting.functionTests.harness;
1:67614ad: 
1:67614ad: import java.io.File;
1:67614ad: import java.io.FileOutputStream;
1:91eacad: import java.util.Locale;
1:67614ad: import java.util.Vector;
1:67614ad: import java.util.Hashtable;
1:67614ad: import java.lang.reflect.Method;
1:67614ad: import java.lang.reflect.Constructor;
1:67614ad: import java.net.Socket;
1:5ff5941: import org.apache.derbyTesting.functionTests.util.TestUtil;
1:67614ad: 
1:67614ad: public class NetServer
1:67614ad: {
1:67614ad: 
1:67614ad:     File homeDir; // The server directory (usually the test directory)
1:67614ad:     String jvmName = "jdk13";
1:67614ad:     String clPath;
1:67614ad:     String javaCmd;
1:67614ad:     String jvmflags;
1:67614ad:     String framework;
1:ebad814: 	String appsRequiredPassword;
1:b2686e6: 	int timeout=60;
1:5ff5941:     static String hostName;
1:67614ad:     
1:67614ad:     Object[] frameworkInfo;
1:67614ad:     int port;
1:67614ad:     Process pr;
1:67614ad:     BackgroundStreamSaver outSaver, errSaver;
1:67614ad:     FileOutputStream fosOut, fosErr;
1:91bb4f2: 	private boolean startServer;  // whether test will start it's own server
1:67614ad: 
1:67614ad: 	//  Variables for test connection
1:67614ad:     Object networkServer;   // Server needs to be created with reflection
1:67614ad: 	Method pingMethod;
1:67614ad: 
1:67614ad: 	private static String NETWORK_SERVER_CLASS_NAME="org.apache.derby.drda.NetworkServerControl";
1:67614ad:     
1:3f5c48a:     public static Hashtable<String, Object[]> m;
1:67614ad:     public static int PREFIX_POS = 0;
1:67614ad:     public static int SUFFIX_POS = 1;
1:67614ad:     public static int DRIVER_POS = 2;
1:67614ad:     public static int PORT_POS = 3;
1:67614ad:     public static int START_CMD_POS = 4;
1:67614ad:     public static int STOP_CMD1_POS = 5;
1:67614ad:     public static int STOP_CMD2_POS = 6;
1:67614ad: 
1:67614ad:     
1:67614ad:     static {
1:5ff5941:     	hostName=TestUtil.getHostName();
1:3f5c48a: 	m =  new Hashtable<String, Object[]>();
1:67614ad: 	// Hashtable is keyed on framework name and has 
1:67614ad: 	// an array of the framework prefix, suffix, driver, port  and 
1:67614ad: 	// String[] command arguments to start the server
1:67614ad: 	// String[] Command arguments to stop the server
1:5ff5941: 	String url = "jdbc:derby:net://" + hostName + ":1527/";
1:67614ad: 	m.put("DerbyNet", new Object[]
1:5ff5941: 	    {url,                 //prefix
1:67614ad: 	     "",                                            // suffix
1:67614ad: 	     "com.ibm.db2.jcc.DB2Driver",                   //driver
1:67614ad: 	     "1527",                                        // port
1:67614ad: 	     new String[] {NETWORK_SERVER_CLASS_NAME,  //start
1:67614ad: 			   "start"},                        
1:67614ad: 	     new String[] {NETWORK_SERVER_CLASS_NAME,  //shutdown
1:67614ad: 			   "shutdown"},
1:67614ad: 	     null});                                        //shutdown2
1:67614ad: 
1:5ff5941: 	url = "jdbc:derby://" + hostName + ":1527/";  
1:ebad814: 
1:0bbfdac: 	m.put("DerbyNetClient", new Object[]
1:5ff5941: 	    {url,                 //prefix
1:f68f62f: 	     "",                                            // suffix
1:0bbfdac: 	     "org.apache.derby.jdbc.ClientDriver",           //driver
1:f68f62f: 	     "1527",                                        // port
1:f68f62f: 	     new String[] {NETWORK_SERVER_CLASS_NAME,  //start
1:f68f62f: 			   "start"},                        
1:f68f62f: 	     new String[] {NETWORK_SERVER_CLASS_NAME,  //shutdown
1:f68f62f: 			   "shutdown"},
1:f68f62f: 	     null});                                        //shutdown2
1:67614ad: 
1:5ff5941: 	url = "jdbc:db2://" + hostName + ":50000/";
1:67614ad: 	m.put("DB2jcc", new Object[]
1:5ff5941: 	    {url,                //prefix
1:67614ad: 	     "",                                            //suffix
1:67614ad: 	     "com.ibm.db2.jcc.DB2Driver",                   //driver
1:67614ad: 	     "50000",                                       //port
1:67614ad: 	     null,                                          //start
1:67614ad: 	     null,                                          
1:67614ad: 	     null});
1:67614ad: 
1:67614ad: 	m.put("DB2app", new Object[]
1:67614ad: 	    {"jdbc:db2:",
1:67614ad: 	     "",
1:67614ad: 	     "COM.ibm.db2.jdbc.app.DB2Driver",
1:67614ad: 	     "0",
1:67614ad: 	     null,
1:67614ad: 	     null,
1:67614ad: 	     null});
1:67614ad:     }
1:67614ad: 
1:ebad814:     public NetServer(File homeDir, String jvmName, String clPath,
1:ebad814: 					 String javaCmd, String jvmflags, String framework,
1:ebad814: 					 boolean startServer, String appsRequiredPassword)
1:67614ad: 	throws Exception
1:67614ad:     {
1:67614ad: 	this.homeDir = homeDir;
1:67614ad:         this.jvmName = jvmName;
1:67614ad:         this.clPath = clPath;
1:67614ad:         this.javaCmd = javaCmd;
1:67614ad:         this.jvmflags = jvmflags;
1:67614ad: 	this.framework = framework;
1:b2686e6: 	
1:b2686e6:     if (jvmflags != null && jvmflags.length() > 0)
1:b2686e6:     {
1:b2686e6:         int start=jvmflags.indexOf("-Dtimeout");
1:b2686e6:         if (start >= 0) {
1:b2686e6:             String timeoutStr = jvmflags.substring(start);
1:b2686e6:             String[] tokens = timeoutStr.split(" ");
1:b2686e6:             timeoutStr = tokens[0];
1:b2686e6:             timeoutStr = timeoutStr.substring(10);
1:b2686e6:             timeout = Integer.parseInt(timeoutStr.trim());
1:b2686e6:         }
1:b2686e6:     }
1:ebad814: 
1:ebad814: 	    // if authentication is required to shutdown server we need password
1:ebad814: 	    // for user APP (the dbo).
1:ebad814:     	this.appsRequiredPassword = appsRequiredPassword;
1:67614ad: 	frameworkInfo =  (Object[]) m.get(framework);
1:67614ad: 	
1:67614ad: 	this.port = Integer.parseInt((String) frameworkInfo[PORT_POS]);
1:91bb4f2: 	this.startServer = startServer;
1:67614ad: 	// System.out.println("framework: " + this.framework + "port: " + this.port);
1:67614ad: 	
1:67614ad:     }
1:67614ad:     public void start() throws Exception
1:67614ad:     {
1:5ff5941:       if (! startServer)
29:f68f62f: 	  {
1:91bb4f2: 		System.out.println("startServer = false. Bypass server startup");
1:f68f62f: 		return;
30:f68f62f: 	  }
1:67614ad: 
1:67614ad: 	// Create the Server directory under the    server dir
1:67614ad: 	(new File(homeDir, framework + "Server")).mkdir();
1:67614ad: 	String[] startcmd = (String[]) frameworkInfo[START_CMD_POS];
1:67614ad: 	// if we are just connecting to DB2 we return
1:67614ad: 	if (startcmd == null) 
1:67614ad: 	    return;
1:67614ad: 	
1:67614ad:         // Build the command to run the WL server
1:67614ad: 	String homeDirName = homeDir.getCanonicalPath();
1:67614ad: 		jvm jvm = null; // to quiet the compiler
1:67614ad: 		jvm = jvm.getJvm(jvmName);
1:67614ad: 		if (jvmName.equals("jview"))
1:67614ad: 		    jvm.setJavaCmd("jview");
1:67614ad: 		else if (javaCmd != null)
1:67614ad: 		    jvm.setJavaCmd(javaCmd);
1:67614ad: 		
1:3f5c48a: 		Vector<String> jvmProps = new Vector<String>();
1:67614ad: 		if ( (clPath != null) && (clPath.length()>0) )
1:67614ad: 		    jvm.setClasspath(clPath);
1:67614ad: 
1:cce01c8:         if ( (jvmflags != null) && (jvmflags.length()>0) ) {
1:67614ad:             jvm.setFlags(jvmflags);
1:fe54944:             // Set no flags by default (DERBY-1614).
1:fe54944:             // The jvmflags property can be used to set any kind of JVM option.
1:67614ad:         }
1:67614ad: 
1:67614ad:         jvmProps.addElement("derby.system.home=" + homeDirName);
1:67614ad: 		jvm.setD(jvmProps);
1:67614ad: 		jvm.setSecurityProps();
1:67614ad:         // For some platforms (like Mac) the process exec command
1:67614ad:         // must be a string array; so we build this with a Vector
1:67614ad:         // first because some strings (paths) could have spaces
1:3f5c48a: 	Vector<String> vCmd = jvm.getCommandLine();
1:67614ad: 	for (int i = 0; i < startcmd.length; i++)
1:67614ad: 	    vCmd.addElement(startcmd[i]);
1:67614ad: 
1:67614ad: 	String serverCmd[] = new String[vCmd.size()];
1:67614ad: 	for (int i = 0; i < vCmd.size(); i++)
1:67614ad: 	{
1:67614ad: 	    serverCmd[i] = (String)vCmd.elementAt(i);
1:67614ad: 	    System.out.print(serverCmd[i] + " ");
1:67614ad: 	}
1:67614ad: 	System.out.println("");
1:67614ad:         // Start a process to run the Server
1:67614ad: 	pr = Runtime.getRuntime().exec(serverCmd);
1:67614ad: 	
1:67614ad:         // Write the out and err files to the server directory also
1:67614ad: 	File out = new File(homeDir, framework + ".out");
1:67614ad: 	fosOut = new FileOutputStream(out);
1:67614ad: 	outSaver = new BackgroundStreamSaver(pr.getInputStream(), fosOut);
1:67614ad: 	File err = new File(homeDir, framework + ".err");
1:67614ad: 	fosErr = new FileOutputStream(err);
1:67614ad: 	errSaver = new BackgroundStreamSaver(pr.getErrorStream(), fosErr);
1:67614ad: 	
1:67614ad: 	for (int i = 0 ; i <= 120 ; i++)
1:67614ad: 	{
1:67614ad: 	    // No need to wait for DB2
1:67614ad: 	    if (isDB2Connection(framework))
1:67614ad: 		break;
1:67614ad:      
1:67614ad: 	    try
1:67614ad: 	    {
1:67614ad:  			if (isNetworkServerConnection(framework))
1:67614ad: 			{
1:67614ad: 				// adding a testconnection check 
1:67614ad: 				// so that the test does not start before the server is up
1:67614ad:  				if (testNetworkServerConnection())
1:67614ad: 					break;
1:67614ad:  			}
1:67614ad:  			else	
1:67614ad:  			{
1:5ff5941:  				Socket s = new Socket(hostName, this.port);
1:67614ad:  				s.close();
1:67614ad: 				break;
1:67614ad:  			}
1:67614ad: 
1:67614ad: 		}
1:67614ad: 		catch (Exception e)
1:67614ad: 	    {
1:67614ad: 		// bail out if something has been written to stderr
1:67614ad: 		if (err.length() > 0) {
1:67614ad: 		    break;
1:67614ad: 		} else {
1:67614ad: 				// it's probably unnecessary to sleep, since the
1:67614ad: 				// connection request generally takes a long time when
1:67614ad: 				// the listener hasn't started yet, but what the heck ...
1:67614ad: 		    Thread.sleep(1000);
1:67614ad: 				// but here we iterate, and after 120 seconds, we stop
1:67614ad: 				// waiting to connect.
1:67614ad: 		} 
1:67614ad: 		
1:67614ad: 	    }
1:67614ad: 	}
1:67614ad:     }
1:67614ad:     
1:67614ad: 	public boolean  testNetworkServerConnection() throws Exception
1:67614ad: 	{ 	
1:91bb4f2: 		if (! startServer)
1:67614ad: 		{
1:91bb4f2: 			System.out.println("startServer = false. Bypass server check");
1:f68f62f: 			return true;
1:67614ad: 		}
1:67614ad: 		
1:67614ad: 		if (networkServer == null)
1:67614ad: 		{
1:3f5c48a: 			Class<?> serverClass = Class.forName(NETWORK_SERVER_CLASS_NAME);
1:3f5c48a: 			Constructor<?> serverConstructor = serverClass.getConstructor();
1:3f5c48a: 			networkServer = serverConstructor.newInstance();
1:3f5c48a: 			pingMethod = networkServer.getClass().getMethod("ping");
1:67614ad: 		}
1:3f5c48a: 		pingMethod.invoke(networkServer);
1:67614ad: 		return true;
1:f68f62f: 	}
1:67614ad: 
1:67614ad:     // stop the Server
1:67614ad: 	public void stop() throws Exception
1:67614ad:     {
1:91bb4f2: 	  if (! startServer)
1:f68f62f: 	  {
1:f68f62f: 		return;
1:f68f62f: 	  }
1:67614ad: 
1:91bb4f2: 	System.out.println("Attempt to shutdown framework: " 
1:91bb4f2: 						 + framework);
1:67614ad: 	jvm jvm = null; // to quiet the compiler
1:67614ad: 	jvm = jvm.getJvm(jvmName);
1:3f5c48a: 	Vector<String> jvmCmd = jvm.getCommandLine();
1:67614ad: 	
1:3f5c48a: 	Vector<String> connV = new Vector<String>();
1:67614ad: 	for (int i = 0; i < jvmCmd.size(); i++)
1:67614ad: 	{
1:3f5c48a: 	    connV.addElement(jvmCmd.elementAt(i));
1:67614ad:         }
1:67614ad: 	
1:67614ad: 	String[] stopcmd1 = (String[]) frameworkInfo[STOP_CMD1_POS];
1:67614ad: 		if (stopcmd1 == null)
1:67614ad: 		    return;
1:ebad814: 
1:ebad814: 		if (appsRequiredPassword != null) {
1:ebad814: 			String[] modifiedStopCmd = new String[stopcmd1.length + 4];
1:ebad814: 			System.arraycopy(stopcmd1, 0, modifiedStopCmd, 0, stopcmd1.length);
1:ebad814: 			modifiedStopCmd[stopcmd1.length]     = "-user";
1:ebad814: 			modifiedStopCmd[stopcmd1.length + 1] = "app";
1:ebad814: 			modifiedStopCmd[stopcmd1.length + 2] = "-password";
1:ebad814: 			modifiedStopCmd[stopcmd1.length + 3] = appsRequiredPassword;
1:ebad814: 			stopcmd1 = modifiedStopCmd;
1:ebad814: 		}
1:ebad814: 
1:ebad814: 
1:67614ad: 		for (int i = 0; i < stopcmd1.length; i++)
1:67614ad: 		    connV.addElement(stopcmd1[i]);
1:67614ad: 		
1:67614ad: 		String[] connCmd = new String[connV.size()];
1:67614ad: 		for (int i = 0; i < connV.size(); i++)
1:67614ad: 		{
1:67614ad: 		    connCmd[i] = (String)connV.elementAt(i);
1:67614ad: 		}		    
1:67614ad: 		
1:67614ad: 		
1:3f5c48a: 		Vector<String> stopV = new Vector<String>();
1:67614ad: 		for (int i = 0; i < jvmCmd.size(); i++)
1:67614ad: 		{
1:67614ad: 		    stopV.addElement((String)jvmCmd.elementAt(i));
1:67614ad: 		}
1:ebad814: 
1:67614ad: 		Process prconn = Runtime.getRuntime().exec(connCmd);
1:67614ad: 		// Give the server sixty seconds to shutdown.
1:67614ad: 		TimedProcess tp = new TimedProcess(prconn);
1:b2686e6: 		tp.waitFor(timeout);
1:67614ad: 		
1:67614ad: 		String[] stopcmd2 = (String[]) frameworkInfo[STOP_CMD2_POS];
1:67614ad: 		if (stopcmd2 != null)
1:67614ad: 		{
1:67614ad: 		    for (int i = 0; i < stopcmd2.length; i++)
1:67614ad: 			stopV.addElement(stopcmd2[i]);
1:67614ad: 		    
1:67614ad: 		    String[] stopCmd = new String[stopV.size()];
1:67614ad: 		    for (int i = 0; i < stopV.size(); i++)
1:67614ad: 		    {
1:67614ad: 			stopCmd[i] = (String)stopV.elementAt(i);
1:67614ad: 		    }
1:67614ad: 		    
1:67614ad: 		    Process prstop = Runtime.getRuntime().exec(stopCmd);
1:67614ad: 		    prstop.waitFor();
1:67614ad: 		}
1:67614ad: 
1:67614ad: 		// Try a TimedProcess as Phil did for the WLServer
1:67614ad: 		tp = new TimedProcess(pr);
1:67614ad: 		// In case the Server didn't shut down, force it to ...
1:b2686e6: 		tp.waitFor(timeout);
1:67614ad: 		
1:67614ad: 		// Finish and close the redirected out and err files
1:67614ad: 		outSaver.finish();
1:67614ad: 		errSaver.finish();
1:67614ad: 	}
1:67614ad:     
1:67614ad:     public void printFramworkInfo(String framework)
1:67614ad:     {
1:67614ad: 	System.out.println("PREFIX = " + frameworkInfo[PREFIX_POS]);
1:67614ad: 	System.out.println("SUFFIX = " + frameworkInfo[SUFFIX_POS]);
1:67614ad: 	System.out.println("DRIVER = " + frameworkInfo[DRIVER_POS]);
1:67614ad: 	System.out.println("PORT = " + frameworkInfo[PORT_POS]);
1:67614ad: 	
1:67614ad: 	for (int index = START_CMD_POS; index <= STOP_CMD2_POS; index++)
1:67614ad: 	{
1:67614ad: 	    String cmdString = "";
1:67614ad: 	    String[] cmdArray = (String[]) frameworkInfo[index] ;
1:67614ad: 	    for (int i = 0; i < cmdArray.length; i++)
1:67614ad: 	    {
1:67614ad: 		cmdString += " " + cmdArray[i];
1:67614ad: 	    }
1:67614ad: 	    if (index == START_CMD_POS)
1:67614ad: 		System.out.println("START_CMD =  " + cmdString);
1:67614ad: 	    else
1:67614ad: 		System.out.println("STOP_CMD = " + cmdString);
1:67614ad: 	    
1:67614ad: 	}
1:67614ad:     }
1:67614ad:     
1:67614ad:     // Get Framework Info
1:67614ad:     public static String getURLPrefix(String fm)
1:67614ad: 		{
1:67614ad: 		    Object[] info = (Object[]) m.get(fm);
1:67614ad: 		    return (String) info[PREFIX_POS];
1:67614ad: 		}
1:67614ad:     
1:67614ad:     public static String getURLSuffix(String fm)
1:67614ad:     {
1:67614ad: 	Object[] info = (Object[]) m.get(fm);
1:67614ad: 	return (String) info[SUFFIX_POS];
1:67614ad:     }
1:67614ad:     
1:67614ad:     public static String getDriverName(String fm)
1:67614ad:     {
1:67614ad: 	Object[] info =  (Object[]) m.get(fm);
1:67614ad: 	if (info != null)
1:67614ad: 	    return (String) info[DRIVER_POS];
1:67614ad: 	else 
1:67614ad: 	    return null;
1:67614ad:     }
1:67614ad:     
1:67614ad:     public static  boolean isDB2Connection(String fm)
1:67614ad:     {
1:91eacad: 	return (fm.toUpperCase(Locale.ENGLISH).equals("DB2APP") ||
1:91eacad: 		fm.toUpperCase(Locale.ENGLISH).equals("DB2JCC"));
1:67614ad: 
1:67614ad:     }
1:67614ad: 
1:67614ad: 	public static boolean isNetworkServerConnection(String fm)
1:67614ad: 	{
1:91eacad: 		return (fm.toUpperCase(Locale.ENGLISH).startsWith("DERBYNET"));
1:67614ad: 	}
1:67614ad: 
1:0bbfdac:     public static boolean isClientConnection(String fm)
1:f68f62f:     {
1:91eacad: 	return (fm.toUpperCase(Locale.ENGLISH).startsWith("DERBYNET") ||
1:91eacad: 		fm.toUpperCase(Locale.ENGLISH).equals("DB2JCC"));
1:f68f62f:     }
1:f68f62f: 
1:67614ad: 	public static boolean isJCCConnection(String fm)
1:67614ad: 	{
1:91eacad: 		return fm.toUpperCase(Locale.ENGLISH).equals("DB2JCC") || 
1:2801b13: 			fm.toUpperCase(Locale.ENGLISH).equals("DERBYNET");
1:67614ad: 	}
1:67614ad: 
2:67614ad:     /**
1:67614ad:      * @param fm framework name. database url from properties file
1:67614ad:      * @return  
1:67614ad:      * altered url (i.e. attributes stripped for DB2 and DerbyNet)
1:67614ad:      */
1:67614ad: 
1:67614ad:     public static String alterURL(String fm, String url)
1:67614ad:     {
1:67614ad: 	String urlPrefix = "jdbc:derby:";
1:67614ad: 	String newURLPrefix = getURLPrefix(fm);
1:67614ad: 	String newURLSuffix = getURLSuffix(fm);
1:67614ad: 	
1:67614ad: 	// If we don't have a URL prefix for this framework
1:67614ad: 	// just return
1:67614ad: 	if (newURLPrefix == null)
1:67614ad: 	    return url;
1:67614ad: 
1:67614ad: 	if (newURLSuffix == null)
1:67614ad: 	    newURLSuffix = "";
1:67614ad: 	
1:67614ad: 	if (url.equals(urlPrefix)) // Replace embedded
1:67614ad: 	    return newURLPrefix;
1:67614ad: 
1:67614ad: 	// If this is a DB2 connection we need to strip 
1:67614ad: 	// the connection attributes
1:67614ad: 	int attrOffset = url.indexOf(';');
1:67614ad: 	if (NetServer.isDB2Connection(fm)  &&
1:67614ad: 		attrOffset != -1)
1:67614ad: 	    url = url.substring(0,attrOffset);
1:67614ad: 	
1:67614ad: 	
1:67614ad: 	if (url.startsWith(urlPrefix))
1:67614ad: 	{
1:67614ad: 	    // replace jdbc:derby: with our url:
1:67614ad: 	    url = newURLPrefix +
1:67614ad: 		url.substring(urlPrefix.length()) +
1:67614ad: 		newURLSuffix;
1:67614ad: 	}
1:67614ad: 	else
1:67614ad: 	{
1:67614ad: 	    if (! (url.startsWith("jdbc:")))
1:67614ad: 	    {
1:67614ad: 		url = newURLPrefix + url + newURLSuffix;
1:67614ad: 	    }
1:67614ad: 	}
1:67614ad: 	return url;
1:67614ad:     }
1:67614ad:     
1:67614ad: 
1:67614ad: }
============================================================================
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:b2686e6
/////////////////////////////////////////////////////////////////////////
1: 	int timeout=60;
/////////////////////////////////////////////////////////////////////////
1: 	
1:     if (jvmflags != null && jvmflags.length() > 0)
1:     {
1:         int start=jvmflags.indexOf("-Dtimeout");
1:         if (start >= 0) {
1:             String timeoutStr = jvmflags.substring(start);
1:             String[] tokens = timeoutStr.split(" ");
1:             timeoutStr = tokens[0];
1:             timeoutStr = timeoutStr.substring(10);
1:             timeout = Integer.parseInt(timeoutStr.trim());
1:         }
1:     }
/////////////////////////////////////////////////////////////////////////
1: 		tp.waitFor(timeout);
/////////////////////////////////////////////////////////////////////////
1: 		tp.waitFor(timeout);
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:3f5c48a
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     public static Hashtable<String, Object[]> m;
/////////////////////////////////////////////////////////////////////////
1: 	m =  new Hashtable<String, Object[]>();
/////////////////////////////////////////////////////////////////////////
1: 		Vector<String> jvmProps = new Vector<String>();
/////////////////////////////////////////////////////////////////////////
1: 	Vector<String> vCmd = jvm.getCommandLine();
/////////////////////////////////////////////////////////////////////////
1: 			Class<?> serverClass = Class.forName(NETWORK_SERVER_CLASS_NAME);
1: 			Constructor<?> serverConstructor = serverClass.getConstructor();
1: 			networkServer = serverConstructor.newInstance();
1: 			pingMethod = networkServer.getClass().getMethod("ping");
1: 		pingMethod.invoke(networkServer);
/////////////////////////////////////////////////////////////////////////
1: 	Vector<String> jvmCmd = jvm.getCommandLine();
1: 	Vector<String> connV = new Vector<String>();
1: 	    connV.addElement(jvmCmd.elementAt(i));
/////////////////////////////////////////////////////////////////////////
1: 		Vector<String> stopV = new Vector<String>();
commit:a4aa5a7
/////////////////////////////////////////////////////////////////////////
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:2de67ca
/////////////////////////////////////////////////////////////////////////
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:ebad814
/////////////////////////////////////////////////////////////////////////
1: 	String appsRequiredPassword;
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:     public NetServer(File homeDir, String jvmName, String clPath,
1: 					 String javaCmd, String jvmflags, String framework,
1: 					 boolean startServer, String appsRequiredPassword)
/////////////////////////////////////////////////////////////////////////
1: 
1: 	    // if authentication is required to shutdown server we need password
1: 	    // for user APP (the dbo).
1:     	this.appsRequiredPassword = appsRequiredPassword;
/////////////////////////////////////////////////////////////////////////
1: 
1: 		if (appsRequiredPassword != null) {
1: 			String[] modifiedStopCmd = new String[stopcmd1.length + 4];
1: 			System.arraycopy(stopcmd1, 0, modifiedStopCmd, 0, stopcmd1.length);
1: 			modifiedStopCmd[stopcmd1.length]     = "-user";
1: 			modifiedStopCmd[stopcmd1.length + 1] = "app";
1: 			modifiedStopCmd[stopcmd1.length + 2] = "-password";
1: 			modifiedStopCmd[stopcmd1.length + 3] = appsRequiredPassword;
1: 			stopcmd1 = modifiedStopCmd;
1: 		}
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:15651f5
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:fe54944
/////////////////////////////////////////////////////////////////////////
1:             // Set no flags by default (DERBY-1614).
1:             // The jvmflags property can be used to set any kind of JVM option.
commit:c92a9b3
/////////////////////////////////////////////////////////////////////////
0:             if (setJvmFlags && ((jvmflags.indexOf("-ms") == -1) || (jvmflags.indexOf("-Xms") == -1)))
0:             if (setJvmFlags && ((jvmflags.indexOf("-mx") == -1) || (jvmflags.indexOf("-Xmx") == -1)))
commit:5ff5941
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.functionTests.util.TestUtil;
/////////////////////////////////////////////////////////////////////////
1:     static String hostName;
/////////////////////////////////////////////////////////////////////////
1:     	hostName=TestUtil.getHostName();
1: 	String url = "jdbc:derby:net://" + hostName + ":1527/";
1: 	    {url,                 //prefix
/////////////////////////////////////////////////////////////////////////
1: 	url = "jdbc:derby://" + hostName + ":1527/";  
1: 	    {url,                 //prefix
/////////////////////////////////////////////////////////////////////////
1: 	url = "jdbc:db2://" + hostName + ":50000/";
1: 	    {url,                //prefix
/////////////////////////////////////////////////////////////////////////
0:     public NetServer(File homeDir, String jvmName, String clPath, String 
0:    	     javaCmd, String jvmflags, String framework, boolean startServer)
/////////////////////////////////////////////////////////////////////////
1:       if (! startServer)
/////////////////////////////////////////////////////////////////////////
1:  				Socket s = new Socket(hostName, this.port);
commit:67614ad
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derbyTesting.functionTests.harness
0:    (C) Copyright IBM Corp. 2002, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.harness;
1: 
1: import java.io.File;
0: import java.io.FileInputStream;
1: import java.io.FileOutputStream;
0: import java.util.Properties;
1: import java.util.Vector;
1: import java.util.Hashtable;
1: import java.lang.reflect.Method;
1: import java.lang.reflect.Constructor;
0: import java.net.ConnectException;
1: import java.net.Socket;
1: 
1: public class NetServer
1: { 
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	private static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2002_2004;
1: 
1:     File homeDir; // The server directory (usually the test directory)
1:     String jvmName = "jdk13";
1:     String clPath;
1:     String javaCmd;
1:     String jvmflags;
1:     String framework;
1:     
1:     Object[] frameworkInfo;
1:     int port;
1:     Process pr;
1:     BackgroundStreamSaver outSaver, errSaver;
1:     FileOutputStream fosOut, fosErr;
0:     private String java;
1: 
1: 	//  Variables for test connection
1:     Object networkServer;   // Server needs to be created with reflection
1: 	Method pingMethod;
1: 
1: 	private static String NETWORK_SERVER_CLASS_NAME="org.apache.derby.drda.NetworkServerControl";
1:     
0:     public static Hashtable m;
1:     public static int PREFIX_POS = 0;
1:     public static int SUFFIX_POS = 1;
1:     public static int DRIVER_POS = 2;
1:     public static int PORT_POS = 3;
1:     public static int START_CMD_POS = 4;
1:     public static int STOP_CMD1_POS = 5;
1:     public static int STOP_CMD2_POS = 6;
1: 
1:     
1:     static {
0: 	m =  new Hashtable();
1: 	// Hashtable is keyed on framework name and has 
1: 	// an array of the framework prefix, suffix, driver, port  and 
1: 	// String[] command arguments to start the server
1: 	// String[] Command arguments to stop the server
1: 	m.put("DerbyNet", new Object[]
0: 	    {"jdbc:derby:net://localhost:1527/",                 //prefix
1: 	     "",                                            // suffix
1: 	     "com.ibm.db2.jcc.DB2Driver",                   //driver
1: 	     "1527",                                        // port
1: 	     new String[] {NETWORK_SERVER_CLASS_NAME,  //start
1: 			   "start"},                        
1: 	     new String[] {NETWORK_SERVER_CLASS_NAME,  //shutdown
1: 			   "shutdown"},
1: 	     null});                                        //shutdown2
1: 
1: 	m.put("DB2jcc", new Object[]
0: 	    {"jdbc:db2://localhost:50000/",                //prefix
1: 	     "",                                            //suffix
1: 	     "com.ibm.db2.jcc.DB2Driver",                   //driver
1: 	     "50000",                                       //port
1: 	     null,                                          //start
1: 	     null,                                          
1: 	     null});
1: 
1: 	m.put("DB2app", new Object[]
1: 	    {"jdbc:db2:",
1: 	     "",
1: 	     "COM.ibm.db2.jdbc.app.DB2Driver",
1: 	     "0",
1: 	     null,
1: 	     null,
1: 	     null});
1:     }
1: 
0:     public NetServer(File homeDir, String jvmName, String clPath, String
0: 		     javaCmd, String jvmflags, String framework) 
1: 	throws Exception
1:     {
1: 	this.homeDir = homeDir;
1:         this.jvmName = jvmName;
1:         this.clPath = clPath;
1:         this.javaCmd = javaCmd;
1:         this.jvmflags = jvmflags;
1: 	this.framework = framework;
1: 	frameworkInfo =  (Object[]) m.get(framework);
1: 	
1: 	this.port = Integer.parseInt((String) frameworkInfo[PORT_POS]);
1: 	
1: 	// System.out.println("framework: " + this.framework + "port: " + this.port);
1: 	
1:     }
1:     public void start() throws Exception
1:     {
1: 	// Create the Server directory under the    server dir
1: 	(new File(homeDir, framework + "Server")).mkdir();
1: 	String[] startcmd = (String[]) frameworkInfo[START_CMD_POS];
1: 	// if we are just connecting to DB2 we return
1: 	if (startcmd == null) 
1: 	    return;
1: 	
1:         // Build the command to run the WL server
1: 	String homeDirName = homeDir.getCanonicalPath();
1: 		jvm jvm = null; // to quiet the compiler
1: 		jvm = jvm.getJvm(jvmName);
1: 		if (jvmName.equals("jview"))
1: 		    jvm.setJavaCmd("jview");
1: 		else if (javaCmd != null)
1: 		    jvm.setJavaCmd(javaCmd);
1: 		
0: 		Vector jvmProps = new Vector();
1: 		if ( (clPath != null) && (clPath.length()>0) )
1: 		    jvm.setClasspath(clPath);
1: 
0:         if ( (jvmflags != null) && (jvmflags.length()>0) )
1:             jvm.setFlags(jvmflags);
1: 
1: 
0:         if (!jvmName.equals("jview"))
1:         {
0:             jvm.setMs(16*1024*1024); // -ms16m
0:             jvm.setMx(32*1024*1024); // -mx32m
0:             jvm.setNoasyncgc(true); // -noasyncgc
1:         }
1: 
1:         jvmProps.addElement("derby.system.home=" + homeDirName);
1: 		jvm.setD(jvmProps);
1: 		jvm.setSecurityProps();
1:         // For some platforms (like Mac) the process exec command
1:         // must be a string array; so we build this with a Vector
1:         // first because some strings (paths) could have spaces
0: 	Vector vCmd = jvm.getCommandLine();
1: 	for (int i = 0; i < startcmd.length; i++)
1: 	    vCmd.addElement(startcmd[i]);
1: 
1: 	String serverCmd[] = new String[vCmd.size()];
1: 	for (int i = 0; i < vCmd.size(); i++)
1: 	{
1: 	    serverCmd[i] = (String)vCmd.elementAt(i);
1: 	    System.out.print(serverCmd[i] + " ");
1: 	}
1: 	System.out.println("");
1:         // Start a process to run the Server
1: 	pr = Runtime.getRuntime().exec(serverCmd);
1: 	
1:         // Write the out and err files to the server directory also
1: 	File out = new File(homeDir, framework + ".out");
1: 	fosOut = new FileOutputStream(out);
1: 	outSaver = new BackgroundStreamSaver(pr.getInputStream(), fosOut);
1: 	File err = new File(homeDir, framework + ".err");
1: 	fosErr = new FileOutputStream(err);
1: 	errSaver = new BackgroundStreamSaver(pr.getErrorStream(), fosErr);
1: 	
1: 	for (int i = 0 ; i <= 120 ; i++)
1: 	{
1: 	    // No need to wait for DB2
1: 	    if (isDB2Connection(framework))
1: 		break;
1:      
1: 	    try
1: 	    {
1:  			if (isNetworkServerConnection(framework))
1: 			{
1: 				// adding a testconnection check 
1: 				// so that the test does not start before the server is up
1:  				if (testNetworkServerConnection())
1: 					break;
1:  			}
1:  			else	
1:  			{
0:  				Socket s = new Socket("localhost", this.port);
1:  				s.close();
1: 				break;
1:  			}
1: 
1: 		}
1: 		catch (Exception e)
1: 	    {
1: 		// bail out if something has been written to stderr
1: 		if (err.length() > 0) {
1: 		    break;
1: 		} else {
1: 				// it's probably unnecessary to sleep, since the
1: 				// connection request generally takes a long time when
1: 				// the listener hasn't started yet, but what the heck ...
1: 		    Thread.sleep(1000);
1: 				// but here we iterate, and after 120 seconds, we stop
1: 				// waiting to connect.
1: 		} 
1: 		
1: 	    }
1: 	}
1:     }
1:     
1: 	public boolean  testNetworkServerConnection() throws Exception
1: 	{ 	
0: 	    Object[] testConnectionArg  = null;
1: 		if (networkServer == null)
1: 		{
0: 			Constructor serverConstructor;
0: 			Class serverClass = Class.forName(NETWORK_SERVER_CLASS_NAME);
0: 			serverConstructor = serverClass.getDeclaredConstructor(null);
0: 			networkServer = serverConstructor.newInstance(null);
0: 			pingMethod = networkServer.getClass().getMethod("ping",
0: 															 null);
1: 		}
0: 		pingMethod.invoke(networkServer,null);
1: 		return true;
1: 	}
1: 
1:     // stop the Server
1: 	public void stop() throws Exception
1:     {
1: 	jvm jvm = null; // to quiet the compiler
1: 	jvm = jvm.getJvm(jvmName);
0: 	Vector jvmCmd = jvm.getCommandLine();
1: 	
0: 	Vector connV = new Vector();
1: 	for (int i = 0; i < jvmCmd.size(); i++)
1: 	{
0: 	    connV.addElement((String)jvmCmd.elementAt(i));
1:         }
1: 	
1: 	String[] stopcmd1 = (String[]) frameworkInfo[STOP_CMD1_POS];
1: 		if (stopcmd1 == null)
1: 		    return;
1: 		
1: 		for (int i = 0; i < stopcmd1.length; i++)
1: 		    connV.addElement(stopcmd1[i]);
1: 		
1: 		String[] connCmd = new String[connV.size()];
1: 		for (int i = 0; i < connV.size(); i++)
1: 		{
1: 		    connCmd[i] = (String)connV.elementAt(i);
1: 		}		    
1: 		
1: 		
0: 		Vector stopV = new Vector();
1: 		for (int i = 0; i < jvmCmd.size(); i++)
1: 		{
1: 		    stopV.addElement((String)jvmCmd.elementAt(i));
1: 		}
1: 		Process prconn = Runtime.getRuntime().exec(connCmd);
1: 		// Give the server sixty seconds to shutdown.
1: 		TimedProcess tp = new TimedProcess(prconn);
0: 		tp.waitFor(60);
1: 		
1: 		String[] stopcmd2 = (String[]) frameworkInfo[STOP_CMD2_POS];
1: 		if (stopcmd2 != null)
1: 		{
1: 		    for (int i = 0; i < stopcmd2.length; i++)
1: 			stopV.addElement(stopcmd2[i]);
1: 		    
1: 		    String[] stopCmd = new String[stopV.size()];
1: 		    for (int i = 0; i < stopV.size(); i++)
1: 		    {
1: 			stopCmd[i] = (String)stopV.elementAt(i);
1: 		    }
1: 		    
1: 		    Process prstop = Runtime.getRuntime().exec(stopCmd);
1: 		    prstop.waitFor();
1: 		}
1: 
1: 		// Try a TimedProcess as Phil did for the WLServer
1: 		tp = new TimedProcess(pr);
1: 		// In case the Server didn't shut down, force it to ...
0: 		tp.waitFor(60);
1: 		
1: 		// Finish and close the redirected out and err files
1: 		outSaver.finish();
1: 		errSaver.finish();
1: 	}
1:     
1:     public void printFramworkInfo(String framework)
1:     {
1: 	System.out.println("PREFIX = " + frameworkInfo[PREFIX_POS]);
1: 	System.out.println("SUFFIX = " + frameworkInfo[SUFFIX_POS]);
1: 	System.out.println("DRIVER = " + frameworkInfo[DRIVER_POS]);
1: 	System.out.println("PORT = " + frameworkInfo[PORT_POS]);
1: 	
1: 	for (int index = START_CMD_POS; index <= STOP_CMD2_POS; index++)
1: 	{
1: 	    String cmdString = "";
1: 	    String[] cmdArray = (String[]) frameworkInfo[index] ;
1: 	    for (int i = 0; i < cmdArray.length; i++)
1: 	    {
1: 		cmdString += " " + cmdArray[i];
1: 	    }
1: 	    if (index == START_CMD_POS)
1: 		System.out.println("START_CMD =  " + cmdString);
1: 	    else
1: 		System.out.println("STOP_CMD = " + cmdString);
1: 	    
1: 	}
1:     }
1:     
1:     // Get Framework Info
1:     public static String getURLPrefix(String fm)
1: 		{
1: 		    Object[] info = (Object[]) m.get(fm);
1: 		    return (String) info[PREFIX_POS];
1: 		}
1:     
1:     public static String getURLSuffix(String fm)
1:     {
1: 	Object[] info = (Object[]) m.get(fm);
1: 	return (String) info[SUFFIX_POS];
1:     }
1:     
1:     public static String getDriverName(String fm)
1:     {
1: 	Object[] info =  (Object[]) m.get(fm);
1: 	if (info != null)
1: 	    return (String) info[DRIVER_POS];
1: 	else 
1: 	    return null;
1:     }
1:     
1:     public static  boolean isDB2Connection(String fm)
1:     {
0: 	return (fm.equals("DB2app") ||
0: 		fm.equals("DB2jcc"));
1: 
1:     }
1: 
1: 	public static boolean isNetworkServerConnection(String fm)
1: 	{
0: 		return (fm.equals("DerbyNet"));
1: 	}
1: 
1:     public static boolean isJCCConnection(String fm)
1:     {
0: 	return (fm.equals("DerbyNet") ||
0: 		fm.equals("DB2jcc"));
1:     }
1: 
1:     /**
1:      * @param fm framework name. database url from properties file
1:      * @return  
1:      * altered url (i.e. attributes stripped for DB2 and DerbyNet)
1:      */
1: 
1:     public static String alterURL(String fm, String url)
1:     {
1: 	String urlPrefix = "jdbc:derby:";
1: 	String newURLPrefix = getURLPrefix(fm);
1: 	String newURLSuffix = getURLSuffix(fm);
1: 	
1: 	// If we don't have a URL prefix for this framework
1: 	// just return
1: 	if (newURLPrefix == null)
1: 	    return url;
1: 
1: 	if (newURLSuffix == null)
1: 	    newURLSuffix = "";
1: 	
1: 	if (url.equals(urlPrefix)) // Replace embedded
1: 	    return newURLPrefix;
1: 
1: 	// If this is a DB2 connection we need to strip 
1: 	// the connection attributes
1: 	int attrOffset = url.indexOf(';');
1: 	if (NetServer.isDB2Connection(fm)  &&
1: 		attrOffset != -1)
1: 	    url = url.substring(0,attrOffset);
1: 	
1: 	
1: 	if (url.startsWith(urlPrefix))
1: 	{
1: 	    // replace jdbc:derby: with our url:
1: 	    url = newURLPrefix +
1: 		url.substring(urlPrefix.length()) +
1: 		newURLSuffix;
1: 	}
1: 	else
1: 	{
1: 	    if (! (url.startsWith("jdbc:")))
1: 	    {
1: 		url = newURLPrefix + url + newURLSuffix;
1: 	    }
1: 	}
1: 	return url;
1:     }
1:     
1: 
1: }
author:Andreas Korneliussen
-------------------------------------------------------------------------------
commit:e1a853e
/////////////////////////////////////////////////////////////////////////
0: 		jvmProps.addElement("user.language=en");
0: 		jvmProps.addElement("user.country=US");
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:5922ff5
/////////////////////////////////////////////////////////////////////////
0: 			serverConstructor = serverClass.getConstructor(null);
commit:f68f62f
/////////////////////////////////////////////////////////////////////////
0: /*
1: 
1:    Derby - Class org.apache.derbyTesting.functionTests.harness.NetServer
1: 
0:    Copyright 2002, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
0:  */
1: 
0: package org.apache.derbyTesting.functionTests.harness;
1: 
0: import java.io.File;
0: import java.io.FileInputStream;
0: import java.io.FileOutputStream;
0: import java.util.Properties;
0: import java.util.Vector;
0: import java.util.Hashtable;
0: import java.lang.reflect.Method;
0: import java.lang.reflect.Constructor;
0: import java.net.ConnectException;
0: import java.net.Socket;
1: 
0: public class NetServer
1: {
1: 
0:     File homeDir; // The server directory (usually the test directory)
0:     String jvmName = "jdk13";
0:     String clPath;
0:     String javaCmd;
0:     String jvmflags;
0:     String framework;
1:     
0:     Object[] frameworkInfo;
0:     int port;
0:     Process pr;
0:     BackgroundStreamSaver outSaver, errSaver;
0:     FileOutputStream fosOut, fosErr;
0:     private String java;
1: 
0: 	//  Variables for test connection
0:     Object networkServer;   // Server needs to be created with reflection
0: 	Method pingMethod;
1: 
0: 	private static String NETWORK_SERVER_CLASS_NAME="org.apache.derby.drda.NetworkServerControl";
1:     
0:     public static Hashtable m;
0:     public static int PREFIX_POS = 0;
0:     public static int SUFFIX_POS = 1;
0:     public static int DRIVER_POS = 2;
0:     public static int PORT_POS = 3;
0:     public static int START_CMD_POS = 4;
0:     public static int STOP_CMD1_POS = 5;
0:     public static int STOP_CMD2_POS = 6;
1: 
1:     
0:     static {
0: 	m =  new Hashtable();
0: 	// Hashtable is keyed on framework name and has 
0: 	// an array of the framework prefix, suffix, driver, port  and 
0: 	// String[] command arguments to start the server
0: 	// String[] Command arguments to stop the server
0: 	m.put("DerbyNet", new Object[]
0: 	    {"jdbc:derby:net://localhost:1527/",                 //prefix
1: 	     "",                                            // suffix
0: 	     "com.ibm.db2.jcc.DB2Driver",                   //driver
1: 	     "1527",                                        // port
1: 	     new String[] {NETWORK_SERVER_CLASS_NAME,  //start
1: 			   "start"},                        
1: 	     new String[] {NETWORK_SERVER_CLASS_NAME,  //shutdown
1: 			   "shutdown"},
1: 	     null});                                        //shutdown2
1: 
0: 	m.put("DB2jcc", new Object[]
0: 	    {"jdbc:db2://localhost:50000/",                //prefix
0: 	     "",                                            //suffix
0: 	     "com.ibm.db2.jcc.DB2Driver",                   //driver
0: 	     "50000",                                       //port
0: 	     null,                                          //start
0: 	     null,                                          
0: 	     null});
1: 
0: 	m.put("DB2app", new Object[]
0: 	    {"jdbc:db2:",
0: 	     "",
0: 	     "COM.ibm.db2.jdbc.app.DB2Driver",
0: 	     "0",
0: 	     null,
0: 	     null,
0: 	     null});
1:     }
1: 
0:     public NetServer(File homeDir, String jvmName, String clPath, String
0: 		     javaCmd, String jvmflags, String framework) 
0: 	throws Exception
1:     {
0: 	this.homeDir = homeDir;
0:         this.jvmName = jvmName;
0:         this.clPath = clPath;
0:         this.javaCmd = javaCmd;
0:         this.jvmflags = jvmflags;
0: 	this.framework = framework;
0: 	frameworkInfo =  (Object[]) m.get(framework);
1: 	
0: 	this.port = Integer.parseInt((String) frameworkInfo[PORT_POS]);
1: 	
0: 	// System.out.println("framework: " + this.framework + "port: " + this.port);
1: 	
1:     }
0:     public void start() throws Exception
1:     {
0: 	// Create the Server directory under the    server dir
0: 	(new File(homeDir, framework + "Server")).mkdir();
0: 	String[] startcmd = (String[]) frameworkInfo[START_CMD_POS];
0: 	// if we are just connecting to DB2 we return
0: 	if (startcmd == null) 
1: 	    return;
1: 	
0:         // Build the command to run the WL server
0: 	String homeDirName = homeDir.getCanonicalPath();
0: 		jvm jvm = null; // to quiet the compiler
0: 		jvm = jvm.getJvm(jvmName);
0: 		if (jvmName.equals("jview"))
0: 		    jvm.setJavaCmd("jview");
0: 		else if (javaCmd != null)
0: 		    jvm.setJavaCmd(javaCmd);
1: 		
0: 		Vector jvmProps = new Vector();
0: 		if ( (clPath != null) && (clPath.length()>0) )
0: 		    jvm.setClasspath(clPath);
1: 
0:         if ( (jvmflags != null) && (jvmflags.length()>0) )
0:             jvm.setFlags(jvmflags);
1: 
1: 
0:         if (!jvmName.equals("jview"))
1:         {
0:             jvm.setMs(16*1024*1024); // -ms16m
0:             jvm.setMx(32*1024*1024); // -mx32m
0:             jvm.setNoasyncgc(true); // -noasyncgc
1:         }
1: 
0:         jvmProps.addElement("derby.system.home=" + homeDirName);
0: 		jvm.setD(jvmProps);
0: 		jvm.setSecurityProps();
0:         // For some platforms (like Mac) the process exec command
0:         // must be a string array; so we build this with a Vector
0:         // first because some strings (paths) could have spaces
0: 	Vector vCmd = jvm.getCommandLine();
0: 	for (int i = 0; i < startcmd.length; i++)
0: 	    vCmd.addElement(startcmd[i]);
1: 
0: 	String serverCmd[] = new String[vCmd.size()];
0: 	for (int i = 0; i < vCmd.size(); i++)
1: 	{
0: 	    serverCmd[i] = (String)vCmd.elementAt(i);
0: 	    System.out.print(serverCmd[i] + " ");
1: 	}
0: 	System.out.println("");
0:         // Start a process to run the Server
0: 	pr = Runtime.getRuntime().exec(serverCmd);
1: 	
0:         // Write the out and err files to the server directory also
0: 	File out = new File(homeDir, framework + ".out");
0: 	fosOut = new FileOutputStream(out);
0: 	outSaver = new BackgroundStreamSaver(pr.getInputStream(), fosOut);
0: 	File err = new File(homeDir, framework + ".err");
0: 	fosErr = new FileOutputStream(err);
0: 	errSaver = new BackgroundStreamSaver(pr.getErrorStream(), fosErr);
1: 	
0: 	for (int i = 0 ; i <= 120 ; i++)
1: 	{
0: 	    // No need to wait for DB2
0: 	    if (isDB2Connection(framework))
0: 		break;
1:      
0: 	    try
1: 	    {
0:  			if (isNetworkServerConnection(framework))
1: 			{
0: 				// adding a testconnection check 
0: 				// so that the test does not start before the server is up
0:  				if (testNetworkServerConnection())
0: 					break;
1:  			}
0:  			else	
1:  			{
0:  				Socket s = new Socket("localhost", this.port);
0:  				s.close();
0: 				break;
1:  			}
1: 
1: 		}
0: 		catch (Exception e)
1: 	    {
0: 		// bail out if something has been written to stderr
0: 		if (err.length() > 0) {
0: 		    break;
0: 		} else {
0: 				// it's probably unnecessary to sleep, since the
0: 				// connection request generally takes a long time when
0: 				// the listener hasn't started yet, but what the heck ...
0: 		    Thread.sleep(1000);
0: 				// but here we iterate, and after 120 seconds, we stop
0: 				// waiting to connect.
1: 		} 
1: 		
1: 	    }
1: 	}
1:     }
1:     
0: 	public boolean  testNetworkServerConnection() throws Exception
1: 	{ 	
0: 	    Object[] testConnectionArg  = null;
0: 		if (networkServer == null)
1: 		{
0: 			Constructor serverConstructor;
0: 			Class serverClass = Class.forName(NETWORK_SERVER_CLASS_NAME);
0: 			serverConstructor = serverClass.getDeclaredConstructor(null);
0: 			networkServer = serverConstructor.newInstance(null);
0: 			pingMethod = networkServer.getClass().getMethod("ping",
0: 															 null);
1: 		}
0: 		pingMethod.invoke(networkServer,null);
1: 		return true;
1: 	}
1: 
0:     // stop the Server
0: 	public void stop() throws Exception
1:     {
0: 	jvm jvm = null; // to quiet the compiler
0: 	jvm = jvm.getJvm(jvmName);
0: 	Vector jvmCmd = jvm.getCommandLine();
1: 	
0: 	Vector connV = new Vector();
0: 	for (int i = 0; i < jvmCmd.size(); i++)
1: 	{
0: 	    connV.addElement((String)jvmCmd.elementAt(i));
1:         }
1: 	
0: 	String[] stopcmd1 = (String[]) frameworkInfo[STOP_CMD1_POS];
0: 		if (stopcmd1 == null)
1: 		    return;
1: 		
0: 		for (int i = 0; i < stopcmd1.length; i++)
0: 		    connV.addElement(stopcmd1[i]);
1: 		
0: 		String[] connCmd = new String[connV.size()];
0: 		for (int i = 0; i < connV.size(); i++)
1: 		{
0: 		    connCmd[i] = (String)connV.elementAt(i);
1: 		}		    
1: 		
1: 		
0: 		Vector stopV = new Vector();
0: 		for (int i = 0; i < jvmCmd.size(); i++)
1: 		{
0: 		    stopV.addElement((String)jvmCmd.elementAt(i));
1: 		}
0: 		Process prconn = Runtime.getRuntime().exec(connCmd);
0: 		// Give the server sixty seconds to shutdown.
0: 		TimedProcess tp = new TimedProcess(prconn);
0: 		tp.waitFor(60);
1: 		
0: 		String[] stopcmd2 = (String[]) frameworkInfo[STOP_CMD2_POS];
0: 		if (stopcmd2 != null)
1: 		{
0: 		    for (int i = 0; i < stopcmd2.length; i++)
0: 			stopV.addElement(stopcmd2[i]);
1: 		    
0: 		    String[] stopCmd = new String[stopV.size()];
0: 		    for (int i = 0; i < stopV.size(); i++)
1: 		    {
0: 			stopCmd[i] = (String)stopV.elementAt(i);
1: 		    }
1: 		    
0: 		    Process prstop = Runtime.getRuntime().exec(stopCmd);
0: 		    prstop.waitFor();
1: 		}
1: 
0: 		// Try a TimedProcess as Phil did for the WLServer
0: 		tp = new TimedProcess(pr);
0: 		// In case the Server didn't shut down, force it to ...
0: 		tp.waitFor(60);
1: 		
0: 		// Finish and close the redirected out and err files
0: 		outSaver.finish();
0: 		errSaver.finish();
1: 	}
1:     
0:     public void printFramworkInfo(String framework)
1:     {
0: 	System.out.println("PREFIX = " + frameworkInfo[PREFIX_POS]);
0: 	System.out.println("SUFFIX = " + frameworkInfo[SUFFIX_POS]);
0: 	System.out.println("DRIVER = " + frameworkInfo[DRIVER_POS]);
0: 	System.out.println("PORT = " + frameworkInfo[PORT_POS]);
1: 	
0: 	for (int index = START_CMD_POS; index <= STOP_CMD2_POS; index++)
1: 	{
0: 	    String cmdString = "";
0: 	    String[] cmdArray = (String[]) frameworkInfo[index] ;
0: 	    for (int i = 0; i < cmdArray.length; i++)
1: 	    {
0: 		cmdString += " " + cmdArray[i];
1: 	    }
0: 	    if (index == START_CMD_POS)
0: 		System.out.println("START_CMD =  " + cmdString);
0: 	    else
0: 		System.out.println("STOP_CMD = " + cmdString);
1: 	    
1: 	}
1:     }
1:     
0:     // Get Framework Info
0:     public static String getURLPrefix(String fm)
1: 		{
0: 		    Object[] info = (Object[]) m.get(fm);
0: 		    return (String) info[PREFIX_POS];
1: 		}
1:     
0:     public static String getURLSuffix(String fm)
1:     {
0: 	Object[] info = (Object[]) m.get(fm);
0: 	return (String) info[SUFFIX_POS];
1:     }
1:     
0:     public static String getDriverName(String fm)
1:     {
0: 	Object[] info =  (Object[]) m.get(fm);
0: 	if (info != null)
0: 	    return (String) info[DRIVER_POS];
0: 	else 
0: 	    return null;
1:     }
1:     
0:     public static  boolean isDB2Connection(String fm)
1:     {
0: 	return (fm.equals("DB2app") ||
0: 		fm.equals("DB2jcc"));
1: 
1:     }
1: 
0: 	public static boolean isNetworkServerConnection(String fm)
1: 	{
0: 		return (fm.equals("DerbyNet"));
1: 	}
1: 
0:     public static boolean isJCCConnection(String fm)
1:     {
0: 	return (fm.equals("DerbyNet") ||
0: 		fm.equals("DB2jcc"));
1:     }
1: 
0:     /**
0:      * @param fm framework name. database url from properties file
0:      * @return  
0:      * altered url (i.e. attributes stripped for DB2 and DerbyNet)
0:      */
1: 
0:     public static String alterURL(String fm, String url)
1:     {
0: 	String urlPrefix = "jdbc:derby:";
0: 	String newURLPrefix = getURLPrefix(fm);
0: 	String newURLSuffix = getURLSuffix(fm);
1: 	
0: 	// If we don't have a URL prefix for this framework
0: 	// just return
0: 	if (newURLPrefix == null)
0: 	    return url;
1: 
0: 	if (newURLSuffix == null)
0: 	    newURLSuffix = "";
1: 	
0: 	if (url.equals(urlPrefix)) // Replace embedded
0: 	    return newURLPrefix;
1: 
0: 	// If this is a DB2 connection we need to strip 
0: 	// the connection attributes
0: 	int attrOffset = url.indexOf(';');
0: 	if (NetServer.isDB2Connection(fm)  &&
0: 		attrOffset != -1)
0: 	    url = url.substring(0,attrOffset);
1: 	
1: 	
0: 	if (url.startsWith(urlPrefix))
1: 	{
0: 	    // replace jdbc:derby: with our url:
0: 	    url = newURLPrefix +
0: 		url.substring(urlPrefix.length()) +
0: 		newURLSuffix;
1: 	}
0: 	else
1: 	{
0: 	    if (! (url.startsWith("jdbc:")))
1: 	    {
0: 		url = newURLPrefix + url + newURLSuffix;
1: 	    }
1: 	}
0: 	return url;
1:     }
1:     
1: 
1: }
commit:c1c71ef
/////////////////////////////////////////////////////////////////////////
0:    Derby - Class org.apache.derbyTesting.functionTests.harness.NetServer
0: 
0:    Copyright 2002, 2004 The Apache Software Foundation or its licensors, as applicable.
0: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
0: 
0:       http://www.apache.org/licenses/LICENSE-2.0
0: 
0:    Unless required by applicable law or agreed to in writing, software
0:    distributed under the License is distributed on an "AS IS" BASIS,
0:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:    See the License for the specific language governing permissions and
0:    limitations under the License.
commit:cb1ca12
/////////////////////////////////////////////////////////////////////////
0: {
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:cce01c8
/////////////////////////////////////////////////////////////////////////
0:         boolean setJvmFlags = false;
1:         if ( (jvmflags != null) && (jvmflags.length()>0) ) {
0:             setJvmFlags = true;
0:         }
0:             if (setJvmFlags && (jvmflags.indexOf("-ms") == -1))
0:             // only setMs if no starting memory was given
0:                 jvm.setMs(16*1024*1024); // -ms16m
0:             if (setJvmFlags && (jvmflags.indexOf("-mx") == -1))
0:             // only setMx if no max memory was given
0:                 jvm.setMx(32*1024*1024); // -mx32m
commit:2801b13
/////////////////////////////////////////////////////////////////////////
1: 			fm.toUpperCase(Locale.ENGLISH).equals("DERBYNET");
commit:91eacad
/////////////////////////////////////////////////////////////////////////
1: import java.util.Locale;
/////////////////////////////////////////////////////////////////////////
1: 	return (fm.toUpperCase(Locale.ENGLISH).equals("DB2APP") ||
1: 		fm.toUpperCase(Locale.ENGLISH).equals("DB2JCC"));
1: 		return (fm.toUpperCase(Locale.ENGLISH).startsWith("DERBYNET"));
1: 	return (fm.toUpperCase(Locale.ENGLISH).startsWith("DERBYNET") ||
1: 		fm.toUpperCase(Locale.ENGLISH).equals("DB2JCC"));
0: 	public static boolean isJCCConnection(String fm)
0: 	{
1: 		return fm.toUpperCase(Locale.ENGLISH).equals("DB2JCC") || 
0: 			fm.equals("DERBYNET");
0: 	}
0: 
commit:91bb4f2
/////////////////////////////////////////////////////////////////////////
1: 	private boolean startServer;  // whether test will start it's own server
/////////////////////////////////////////////////////////////////////////
0: 		     javaCmd, String jvmflags, String framework, boolean startServer) 
/////////////////////////////////////////////////////////////////////////
1: 	this.startServer = startServer;
1: 	  if (! startServer)
0: 	  {
1: 		System.out.println("startServer = false. Bypass server startup");
0: 		return;
0: 	  }
0: 
/////////////////////////////////////////////////////////////////////////
1: 		if (! startServer)
0: 		{
1: 			System.out.println("startServer = false. Bypass server check");
0: 			return true;
0: 		}
0: 		
/////////////////////////////////////////////////////////////////////////
0: 	  if (! startServer)
0: 	  {
0: 		return;
0: 	  }
0: 
1: 	System.out.println("Attempt to shutdown framework: " 
1: 						 + framework);
commit:0bbfdac
/////////////////////////////////////////////////////////////////////////
1: 	m.put("DerbyNetClient", new Object[]
0: 	    {"jdbc:derby://localhost:1527/",                 //prefix
0: 	     "",                                            // suffix
1: 	     "org.apache.derby.jdbc.ClientDriver",           //driver
0: 	     "1527",                                        // port
0: 	     new String[] {NETWORK_SERVER_CLASS_NAME,  //start
0: 			   "start"},                        
0: 	     new String[] {NETWORK_SERVER_CLASS_NAME,  //shutdown
0: 			   "shutdown"},
0: 	     null});                                        //shutdown2
0: 
/////////////////////////////////////////////////////////////////////////
0: 		return (fm.startsWith("DerbyNet"));
1:     public static boolean isClientConnection(String fm)
0: 	return (fm.startsWith("DerbyNet") ||
============================================================================