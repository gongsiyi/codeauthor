1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.execute.RowChangerImpl
1:345de35: 
1:f6123ee:    Licensed to the Apache Software Foundation (ASF) under one or more
1:f6123ee:    contributor license agreements.  See the NOTICE file distributed with
1:f6123ee:    this work for additional information regarding copyright ownership.
1:f6123ee:    The ASF licenses this file to you under the Apache License, Version 2.0
1:f6123ee:    (the "License"); you may not use this file except in compliance with
1:f6123ee:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
4:eac0369: 
2:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.sql.execute;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.io.FormatableBitSet;
1:eac0369: 
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1:eac0369: import org.apache.derby.iapi.sql.conn.StatementContext;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.IndexRowGenerator;
1:eac0369: import org.apache.derby.iapi.sql.execute.ExecRow;
1:eac0369: import org.apache.derby.iapi.sql.execute.ExecutionContext;
1:eac0369: import org.apache.derby.iapi.sql.execute.RowChanger;
1:eac0369: import org.apache.derby.iapi.sql.execute.ExecutionFactory;
1:eac0369: import org.apache.derby.iapi.sql.execute.TemporaryRowHolder;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.sql.Activation;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.access.ConglomerateController;
1:eac0369: import org.apache.derby.iapi.store.access.DynamicCompiledOpenConglomInfo;
1:eac0369: import org.apache.derby.iapi.store.access.StaticCompiledOpenConglomInfo;
1:eac0369: import org.apache.derby.iapi.store.access.TransactionController;
1:38f02ec: import org.apache.derby.iapi.transaction.TransactionControl;
1:eac0369: import org.apache.derby.iapi.types.DataValueDescriptor;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.types.RowLocation;
1:eac0369: 
1:eac0369: import java.util.Vector;
1:eac0369: 
2:eac0369: /**
1:eac0369:   Perform row at a time DML operations of tables and maintain indexes.
1:eac0369:   */
1:6bc9897: class RowChangerImpl	implements	RowChanger
1:eac0369: {
1:eac0369: 	boolean isOpen = false;
1:eac0369: 
1:eac0369: 	//
1:eac0369: 	//Stuff provided to the constructor
1:eac0369: 	boolean[] fixOnUpdate = null;
1:eac0369: 	long heapConglom;
1:eac0369: 	DynamicCompiledOpenConglomInfo heapDCOCI;
1:eac0369: 	StaticCompiledOpenConglomInfo heapSCOCI;
1:eac0369: 	long[] indexCIDS = null;
1:eac0369: 	DynamicCompiledOpenConglomInfo[] indexDCOCIs;
1:eac0369: 	StaticCompiledOpenConglomInfo[] indexSCOCIs;
1:eac0369: 	IndexRowGenerator[] irgs = null;
1:48d2629: 	private final Activation		activation;
1:eac0369: 	TransactionController	tc;
1:eac0369: 	FormatableBitSet 	changedColumnBitSet;	
1:eac0369: 	FormatableBitSet 	baseRowReadList;	
1:6bc9897: 	private int[]		baseRowReadMap;	//index=heap column, value=input row column.
1:eac0369: 	int[]		changedColumnIds;
1:eac0369: 	TemporaryRowHolderImpl	rowHolder;
1:eac0369: 	
1:eac0369: 	// for error reporting.
1:eac0369: 	String[]	indexNames;
1:eac0369: 
1:eac0369: 	//
1:eac0369: 	//Stuff filled in by open
1:6bc9897: 	private ConglomerateController baseCC;
1:6bc9897: 	private RowLocation	baseRowLocation;
1:6bc9897: 	private IndexSetChanger isc;
1:eac0369: 
1:eac0369: 	// a row array with all non-updated columns compacted out
1:eac0369: 	private DataValueDescriptor[] sparseRowArray;
1:eac0369: 	private	int[] partialChangedColumnIds;
1:eac0369: 	
1:eac0369: 	/**
1:eac0369: 	  Create a new RowChanger for performing update and delete operations
1:eac0369: 	  based on partial before and after rows.
1:eac0369: 
1:eac0369: 	  @param heapConglom Conglomerate # for the heap
1:eac0369: 	  @param heapSCOCI	SCOCI for heap.
1:eac0369: 	  @param heapDCOCI	DCOCI for heap
1:eac0369: 	  @param irgs the IndexRowGenerators for the table's indexes. We use
1:eac0369: 	    positions in this array as local id's for indexes. To support updates,
1:eac0369: 	    only indexes that change need be included.
1:eac0369: 	  @param indexCIDS the conglomerateids for the table's idexes. 
1:eac0369: 	  	indexCIDS[ix] corresponds to the same index as irgs[ix].
1:eac0369: 	  @param indexSCOCIs the SCOCIs for the table's idexes. 
1:eac0369: 	  	indexSCOCIs[ix] corresponds to the same index as irgs[ix].
1:eac0369: 	  @param indexDCOCIs the DCOCIs for the table's idexes. 
1:eac0369: 	  	indexDCOCIs[ix] corresponds to the same index as irgs[ix].
1:eac0369: 	  @param numberOfColumns	Number of columns in partial write row.
1:eac0369: 	  @param changedColumnIdsInput array of 1 based ints indicating the columns
1:eac0369: 		to be updated.  Only used for updates
1:eac0369: 	  @param tc the transaction controller
1:eac0369: 	  @param baseRowReadList bit set of columns read from base row. 1 based.
1:dbed020: 	  @param baseRowReadMap BaseRowReadMap[heapColId]-&gt;ReadRowColumnId. (0 based)
1:eac0369: 	  @exception StandardException		Thrown on error
1:eac0369: 	  */
1:eac0369: 	public RowChangerImpl(
1:eac0369: 			   long heapConglom,
1:eac0369: 			   StaticCompiledOpenConglomInfo heapSCOCI,
1:eac0369: 			   DynamicCompiledOpenConglomInfo heapDCOCI,
1:eac0369: 			   IndexRowGenerator[] irgs,
1:eac0369: 			   long[] indexCIDS,
1:eac0369: 			   StaticCompiledOpenConglomInfo[] indexSCOCIs,
1:eac0369: 			   DynamicCompiledOpenConglomInfo[] indexDCOCIs,
1:eac0369: 			   int numberOfColumns,
1:eac0369: 			   int[] changedColumnIdsInput,
1:eac0369: 			   TransactionController tc,
1:eac0369: 			   FormatableBitSet	baseRowReadList,
1:eac0369: 			   int[] baseRowReadMap,
1:eac0369: 			   Activation activation)
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369: 		this.heapConglom = heapConglom;
1:eac0369: 		this.heapSCOCI = heapSCOCI;
1:eac0369: 		this.heapDCOCI = heapDCOCI;
1:eac0369: 		this.irgs = irgs;
1:eac0369: 		this.indexCIDS = indexCIDS;
1:eac0369: 		this.indexSCOCIs = indexSCOCIs;
1:eac0369: 		this.indexDCOCIs = indexDCOCIs;
1:eac0369: 		this.tc = tc;
1:eac0369: 		this.baseRowReadList = baseRowReadList;
1:eac0369: 		this.baseRowReadMap = baseRowReadMap;
1:eac0369: 		this.activation = activation;
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(indexCIDS != null, "indexCIDS is null");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** Construct the update column FormatableBitSet.
1:eac0369: 		** It is 0 based as opposed to the 1 based
1:eac0369: 		** changed column ids.
1:eac0369: 		*/
1:eac0369: 		if (changedColumnIdsInput != null)
1:eac0369: 		{
1:eac0369: 			/*
1:eac0369: 			** Sometimes replication does not have columns
1:eac0369: 			** in sorted order, and basically needs to
1:eac0369: 			** have the changed columns in non-sorted order.
1:eac0369: 			** So sort them first if needed.
1:eac0369: 			*/
1:eac0369: 			changedColumnIds = RowUtil.inAscendingOrder(changedColumnIdsInput) ?
1:eac0369: 								changedColumnIdsInput : sortArray(changedColumnIdsInput);
1:eac0369: 
1:eac0369: 			/*
1:eac0369: 			** Allocate the row array we are going to use during
1:eac0369: 			** update here, to avoid extra work.  setup
1:eac0369: 			** the FormatableBitSet of columns being updated.  See updateRow
1:eac0369: 			** for the use.
1:eac0369: 			**
1:eac0369: 			** changedColumnIds is guaranteed to be in order, so just take
1:eac0369: 			** the last column number in the array to be the highest
1:eac0369: 			** column number.
1:eac0369: 			*/
1:eac0369: 			sparseRowArray =
1:eac0369: 				new DataValueDescriptor[changedColumnIds[changedColumnIds.length - 1] + 1];
1:eac0369: 			changedColumnBitSet = new FormatableBitSet(numberOfColumns);
1:eac0369: 			for (int i = 0; i < changedColumnIds.length; i++)
1:eac0369: 			{
1:eac0369: 				// make sure changedColumnBitSet can accomodate bit 
1:eac0369: 				// changedColumnIds[i] - 1 
1:eac0369: 				changedColumnBitSet.grow(changedColumnIds[i]);
1:eac0369: 				changedColumnBitSet.set(changedColumnIds[i] - 1);
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			/*
1:eac0369: 			** If we have a read map and a write map, we
1:eac0369: 			** need to have a way to map the changed column
1:eac0369: 			** ids to be relative to the read map.
1:eac0369: 			*/
1:eac0369: 			if (baseRowReadList != null)
1:eac0369: 			{
1:eac0369: 				partialChangedColumnIds = new int[changedColumnIds.length];
1:eac0369: 				int partialColumnNumber = 1;
1:eac0369: 				int currentColumn = 0;
1:eac0369: 				for (int i = 0; i < changedColumnIds.length; i++)
1:eac0369: 				{
1:eac0369: 					for (; currentColumn < changedColumnIds[i]; currentColumn++)
1:eac0369: 					{
1:eac0369: 						if (baseRowReadList.get(currentColumn))
1:eac0369: 						{
1:eac0369: 							partialColumnNumber++;
1:eac0369: 						}
1:eac0369: 					}
1:eac0369: 					partialChangedColumnIds[i] = partialColumnNumber;
1:eac0369: 				}
1:eac0369: 			}	
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(indexCIDS != null, "indexCIDS is null");
1:eac0369: 		}
1:eac0369: 		
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set the row holder for this changer to use.
1:eac0369: 	 * If the row holder is set, it wont bother 
1:eac0369: 	 * saving copies of rows needed for deferred
1:eac0369: 	 * processing.  Also, it will never close the
1:eac0369: 	 * passed in rowHolder.
1:eac0369: 	 *
1:eac0369: 	 * @param rowHolder	the TemporaryRowHolder
1:eac0369: 	 */
1:eac0369: 	public void setRowHolder(TemporaryRowHolder rowHolder)
1:eac0369: 	{
1:eac0369: 		this.rowHolder = (TemporaryRowHolderImpl)rowHolder;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see RowChanger#setIndexNames
1:eac0369: 	 */
1:eac0369: 	public void setIndexNames(String[] indexNames)
1:eac0369: 	{
1:eac0369: 		this.indexNames = indexNames;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  Open this RowChanger.
1:eac0369: 
1:eac0369: 	  <P>Note to avoid the cost of fixing indexes that do not
1:eac0369: 	  change during update operations use openForUpdate().
1:eac0369: 	  @param lockMode	The lock mode to use
1:eac0369: 							(row or table, see TransactionController)
1:eac0369: 
1:eac0369: 	  @exception StandardException thrown on failure to convert
1:eac0369: 	  */
1:eac0369: 	public void open(int lockMode)
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:3d7a3d4: 		open(lockMode, true);
1:3d7a3d4: 	}
1:3d7a3d4: 
1:3d7a3d4: 	/**
1:3d7a3d4: 	 * @inheritDoc
1:3d7a3d4: 	 */
1:3d7a3d4: 	public void open(int lockMode, boolean wait)
1:3d7a3d4: 		 throws StandardException
1:3d7a3d4: 	{
1:eac0369: 		//
1:eac0369: 		//We open for update but say to fix every index on
1:eac0369: 		//updates.
1:eac0369: 		if (fixOnUpdate == null)
1:eac0369: 		{
1:eac0369: 			fixOnUpdate = new boolean[irgs.length];
1:eac0369: 			for (int ix = 0; ix < irgs.length; ix++)
1:eac0369: 				fixOnUpdate[ix] = true;
1:eac0369: 		}
1:3d7a3d4: 		openForUpdate(fixOnUpdate, lockMode, wait);
1:eac0369: 	}
1:3d7a3d4: 
1:eac0369: 	/**
1:eac0369: 	  Open this RowChanger to avoid fixing indexes that do not change
1:eac0369: 	  during update operations. 
1:eac0369: 
1:dbed020: 	  @param fixOnUpdate fixOnUpdat[ix] == true ==&gt; fix index 'ix' on
1:eac0369: 	  an update operation.
1:eac0369: 	  @param lockMode	The lock mode to use
1:eac0369: 							(row or table, see TransactionController)
1:eac0369: 	  @param wait		If true, then the caller wants to wait for locks. False will be
1:eac0369: 							when we using a nested user xaction - we want to timeout right away
1:eac0369: 							if the parent holds the lock.  (bug 4821)
1:eac0369: 
1:eac0369: 	  @exception StandardException thrown on failure to convert
1:eac0369: 	  */
1:eac0369: 	public void openForUpdate(
1:eac0369: 				  boolean[] fixOnUpdate, int lockMode, boolean wait
1:eac0369: 			  )
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369: 		LanguageConnectionContext lcc = null;
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		    SanityManager.ASSERT( ! isOpen, "RowChanger already open");
1:eac0369: 		
1:eac0369: 		if (activation != null)
1:eac0369: 		{
1:eac0369: 			lcc = activation.getLanguageConnectionContext();
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* Isolation level - translate from language to store */
1:eac0369: 		int isolationLevel;
1:eac0369: 		if (lcc == null)
1:eac0369: 		{
1:38f02ec: 			isolationLevel = TransactionControl.READ_COMMITTED_ISOLATION_LEVEL;
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			isolationLevel = lcc.getCurrentIsolationLevel();
1:eac0369: 		}
1:eac0369: 
1:eac0369: 
1:eac0369: 		switch (isolationLevel)
1:eac0369: 		{
1:eac0369: 			// Even though we preserve the isolation level at READ UNCOMMITTED,
1:94f158a: 			// Store will overwrite it to READ COMMITTED for update.
1:38f02ec: 			case TransactionControl.READ_UNCOMMITTED_ISOLATION_LEVEL:
1:eac0369: 				isolationLevel = 
1:eac0369:                     TransactionController.ISOLATION_READ_UNCOMMITTED;
1:eac0369: 				break;
1:eac0369: 
1:38f02ec: 			case TransactionControl.READ_COMMITTED_ISOLATION_LEVEL:
1:eac0369: 				isolationLevel = 
1:eac0369:                     TransactionController.ISOLATION_READ_COMMITTED;
1:eac0369: 				break;
1:eac0369: 
1:38f02ec: 			case TransactionControl.REPEATABLE_READ_ISOLATION_LEVEL:
1:eac0369: 				isolationLevel = 
1:eac0369:                     TransactionController.ISOLATION_REPEATABLE_READ;
1:eac0369: 				break;
1:eac0369: 
1:38f02ec: 			case TransactionControl.SERIALIZABLE_ISOLATION_LEVEL:
1:eac0369: 				isolationLevel = 
1:eac0369:                     TransactionController.ISOLATION_SERIALIZABLE;
1:eac0369: 				break;
1:eac0369: 
1:eac0369: 			default:
1:eac0369: 				if (SanityManager.DEBUG)
1:eac0369: 				{
1:eac0369: 					SanityManager.THROWASSERT(
1:eac0369: 						"Invalid isolation level - " + isolationLevel);
1:eac0369: 				}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		try {
1:eac0369: 
1:eac0369: 		/* We can get called by either an activation or 
1:eac0369: 		 * the DataDictionary.  The DD cannot use the
1:eac0369: 		 * CompiledInfo while the activation can.
1:eac0369: 		 */
1:eac0369: 		if (heapSCOCI != null)
1:eac0369: 		{
1:eac0369: 	        baseCC =
1:eac0369: 				tc.openCompiledConglomerate(
1:eac0369: 					false,
1:eac0369:                     (TransactionController.OPENMODE_FORUPDATE |
1:eac0369:                     ((wait) ? 0 : TransactionController.OPENMODE_LOCK_NOWAIT)),
1:eac0369: 					lockMode,
1:eac0369: 					isolationLevel,
1:eac0369: 					heapSCOCI,
1:eac0369: 					heapDCOCI);
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 	        baseCC =
1:eac0369: 				tc.openConglomerate(
1:eac0369: 					heapConglom,
1:eac0369: 					false,
1:eac0369:                     (TransactionController.OPENMODE_FORUPDATE |
1:eac0369:                     ((wait) ? 0 : TransactionController.OPENMODE_LOCK_NOWAIT)),
1:eac0369: 					lockMode,
1:eac0369: 					isolationLevel);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		} catch (StandardException se) {
1:eac0369: 			if (activation != null)
1:eac0369: 				activation.checkStatementValidity();
1:eac0369: 			throw se;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* Save the ConglomerateController off in the activation
1:eac0369: 		 * to eliminate the need to open it a 2nd time if we are doing
1:eac0369: 		 * and index to base row for the search as part of an update or
1:eac0369: 		 * delete below us.
1:eac0369: 		 * NOTE: activation can be null.  (We don't have it in
1:eac0369: 		 * the DataDictionary.)
1:eac0369: 		 */
1:eac0369: 		if (activation != null)
1:eac0369: 		{
1:eac0369: 			activation.checkStatementValidity();
1:eac0369: 			activation.setHeapConglomerateController(baseCC);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* Only worry about indexes if there are indexes to worry about */
1:eac0369: 		if (indexCIDS.length != 0)
1:eac0369: 		{
1:eac0369: 			/* IndexSetChanger re-used across executions. */
1:eac0369: 			if (isc == null)
1:eac0369: 			{
1:eac0369: 				isc = new IndexSetChanger(irgs,
1:eac0369: 										  indexCIDS,
1:eac0369: 										  indexSCOCIs,
1:eac0369: 										  indexDCOCIs,
1:eac0369: 										  indexNames,
1:eac0369: 										  baseCC,
1:eac0369: 										  tc,
1:eac0369: 										  lockMode,
1:eac0369: 										  baseRowReadList,
1:eac0369: 										  isolationLevel,
1:eac0369: 										  activation
1:eac0369: 										  );
1:eac0369: 				isc.setRowHolder(rowHolder);
1:eac0369: 			}
1:eac0369: 			else
1:eac0369: 			{
1:eac0369: 
1:eac0369: 				/* Propagate the heap's ConglomerateController to
1:eac0369: 				 * all of the underlying index changers.
1:eac0369: 				 */
1:eac0369: 				isc.setBaseCC(baseCC);
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			isc.open(fixOnUpdate);
1:eac0369: 
1:eac0369: 			if (baseRowLocation == null)
1:eac0369: 				baseRowLocation = baseCC.newRowLocationTemplate();
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		isOpen = true;
1:eac0369: 	}
1:eac0369: 	   
1:eac0369: 	/**
1:eac0369: 	  Insert a row into the table and perform associated index maintenance.
1:eac0369: 
1:eac0369: 	  @param baseRow the row.
1:eac0369: 	  @exception StandardException		Thrown on error
1:eac0369: 	  */
1:af1c18c:     public RowLocation insertRow(ExecRow baseRow, boolean getRL)
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT(! baseCC.isKeyed(),
1:eac0369: 								 "Keyed inserts not yet supported");
1:eac0369: 
1:eac0369: 		if (baseCC.isKeyed())
1:eac0369: 		{
1:eac0369: 			//kcc.insert(row.key(), row());
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:af1c18c:             if (isc != null || getRL)
1:eac0369: 			{
1:af1c18c:                 if (baseRowLocation == null) {
1:af1c18c:                     baseRowLocation = baseCC.newRowLocationTemplate();
1:af1c18c:                 }
1:eac0369: 				baseCC.insertAndFetchLocation(baseRow.getRowArray(), baseRowLocation);
1:af1c18c: 
1:af1c18c:                 if (isc != null) {
1:af1c18c:                     isc.insert(baseRow, baseRowLocation);
1:af1c18c:                 }
1:eac0369: 			}
1:eac0369: 			else
1:eac0369: 			{
1:0c5bc3a:                 baseCC.insert(baseRow.getRowArray());
1:eac0369: 			}
1:eac0369: 		}
1:af1c18c: 
1:af1c18c:         return getRL ? baseRowLocation : null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 		
1:eac0369: 	/**
1:eac0369: 	  Delete a row from the table and perform associated index maintenance.
1:eac0369: 
1:eac0369: 	  @param baseRow the row.
2:eac0369: 	  @param baseRowLocation the row's base conglomerate
2:eac0369: 	     location
1:eac0369: 	  @exception StandardException		Thrown on error
1:eac0369: 	  */
1:eac0369: 	public void deleteRow(ExecRow baseRow, RowLocation baseRowLocation)
1:eac0369: 		 throws StandardException
1:eac0369: 	{
2:eac0369: 		if (isc != null)
1:eac0369: 		{
1:eac0369: 			isc.delete(baseRow, baseRowLocation);
1:eac0369: 		}
1:eac0369: 		baseCC.delete(baseRowLocation);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  Update a row in the table and perform associated index maintenance.
1:eac0369: 
1:eac0369: 	  @param oldBaseRow the old image of the row.
1:eac0369: 	  @param newBaseRow the new image of the row.
1:eac0369: 	  @param baseRowLocation the row's base conglomerate
1:eac0369: 	     location
1:eac0369: 	  @exception StandardException		Thrown on error
1:eac0369: 	  */
1:eac0369: 	public void updateRow(ExecRow oldBaseRow,
1:eac0369: 						  ExecRow newBaseRow,
1:eac0369: 						  RowLocation baseRowLocation)
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369: 		if (isc != null)
1:eac0369: 		{
1:eac0369: 			isc.update(oldBaseRow, newBaseRow, baseRowLocation);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (changedColumnBitSet != null)
1:eac0369: 		{
1:eac0369: 			DataValueDescriptor[] baseRowArray = newBaseRow.getRowArray();
1:eac0369: 			int[] changedColumnArray = (partialChangedColumnIds == null) ?
1:eac0369: 					changedColumnIds : partialChangedColumnIds;
1:eac0369: 			int nextColumnToUpdate = -1;
1:eac0369: 			for (int i = 0; i < changedColumnArray.length; i++)
1:eac0369: 			{
1:eac0369: 				int copyFrom = changedColumnArray[i] - 1;
1:eac0369: 				nextColumnToUpdate =
1:eac0369: 							changedColumnBitSet.anySetBit(nextColumnToUpdate);
1:eac0369: 				if (SanityManager.DEBUG)
1:eac0369: 				{
1:eac0369: 					SanityManager.ASSERT(nextColumnToUpdate >= 0,
1:eac0369: 						"More columns in changedColumnArray than in changedColumnBitSet");
1:eac0369: 				}
1:eac0369: 				sparseRowArray[nextColumnToUpdate] = baseRowArray[copyFrom];
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			sparseRowArray = newBaseRow.getRowArray();
1:eac0369: 		}
1:eac0369: 		baseCC.replace(baseRowLocation, 
1:eac0369: 					sparseRowArray, 
1:eac0369: 					changedColumnBitSet);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  Finish processing the changes.  This means applying the deferred
1:eac0369: 	  inserts for updates to unique indexes.
1:eac0369: 
1:eac0369: 	  @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public void finish()
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		if (isc != null)
1:eac0369: 		{
1:eac0369: 			isc.finish();
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  Close this RowChanger.
1:eac0369: 
1:eac0369: 	  @exception StandardException		Thrown on error
1:eac0369: 	  */
1:eac0369: 	public void close()
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		//
1:eac0369: 		//NOTE: isc uses baseCC. Since we close baseCC we free isc for now.
1:eac0369: 		//We could consider making isc open its own baseCC or even leaving
1:eac0369: 		//baseCC open to promote re-use. We must keep in mind that baseCC
1:eac0369: 		//is associated with the opener's TransactionController.
1:eac0369: 		if (isc != null)
1:eac0369: 		{
1:eac0369: 			isc.close(); 
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (baseCC != null)
1:eac0369: 		{
1:eac0369: 			if (activation == null || activation.getForUpdateIndexScan() == null)
1:eac0369: 				baseCC.close();		//beetle 3865, don't close if borrowed to cursor
1:eac0369: 			baseCC = null;
1:eac0369: 		}
1:eac0369: 		
1:eac0369: 		isOpen = false;
1:eac0369: 
1:eac0369: 		// rowHolder is reused across executions and closed by caller
1:eac0369: 		// since caller creates it
1:eac0369: 
1:eac0369: 		if (activation != null)
1:eac0369: 		{
1:eac0369: 			activation.clearHeapConglomerateController();
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see RowChanger#getHeapConglomerateController */
1:eac0369: 	public ConglomerateController getHeapConglomerateController()
1:eac0369: 	{
1:eac0369: 		return baseCC;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	private int[] sortArray(int[] input)
1:eac0369: 	{
1:eac0369: 		/*
1:eac0369: 		** Sotring.sort() will change the underlying array, so we
1:eac0369: 		** 'clone' it first
1:eac0369: 		*/
1:eac0369: 		int[] output = new int[input.length];
1:eac0369: 		System.arraycopy(input, 0, output, 0, input.length);
1:eac0369: 		java.util.Arrays.sort(output);
1:eac0369: 		return output;
1:eac0369: 	}
1:7d0f620: 
1:7d0f620: 
1:7d0f620: 	public int findSelectedCol(int selectedCol) {
1:7d0f620: 		if (selectedCol == -1) {
1:7d0f620: 			// This is not a base column
1:7d0f620: 			return -1;
1:7d0f620: 		}
1:7d0f620: 
1:7d0f620: 		int[] changeColArray = (partialChangedColumnIds == null) ?
1:7d0f620: 			changedColumnIds : partialChangedColumnIds;
1:7d0f620: 
1:7d0f620: 		int nextColumnToUpdate = -1;
1:7d0f620: 		for (int i = 0; i < changeColArray.length; i++) {
1:7d0f620: 			nextColumnToUpdate =
1:7d0f620: 				changedColumnBitSet.anySetBit(nextColumnToUpdate);
1:7d0f620: 
1:7d0f620: 			if (selectedCol == nextColumnToUpdate + 1) { // bit set is 0 based
1:7d0f620: 				return changeColArray[i];
1:7d0f620: 			}
1:7d0f620: 		}
1:7d0f620: 
1:7d0f620: 		return -1;
1:7d0f620: 	}
1:7d0f620: 
1:7d0f620: 
1:7d0f620: 	public String toString() {
1:7d0f620: 		if (SanityManager.DEBUG) {
1:7d0f620: 			StringBuffer sb = new StringBuffer();
1:7d0f620: 			sb.append("changedColumnBitSet: " + changedColumnBitSet + "\n");
1:7d0f620: 
1:7d0f620: 			int[] changedColumnArray = (partialChangedColumnIds == null) ?
1:7d0f620: 				changedColumnIds : partialChangedColumnIds;
1:7d0f620: 
1:7d0f620: 			sb.append("changedColumnArray: [");
1:7d0f620: 			for (int i = 0; i < changedColumnArray.length; i++) {
1:7d0f620: 				sb.append(changedColumnArray[i]);
1:7d0f620: 
1:7d0f620: 				if (i < changedColumnArray.length-1) {
1:7d0f620: 					sb.append(",");
1:7d0f620: 				}
1:7d0f620: 			}
1:7d0f620: 			sb.append("]");
1:7d0f620: 
1:7d0f620: 			return sb.toString();
1:7d0f620: 		} else {
1:7d0f620: 			return super.toString();
1:7d0f620: 		}
1:7d0f620: 	}
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1: 	  @param baseRowReadMap BaseRowReadMap[heapColId]-&gt;ReadRowColumnId. (0 based)
/////////////////////////////////////////////////////////////////////////
1: 	  @param fixOnUpdate fixOnUpdat[ix] == true ==&gt; fix index 'ix' on
commit:38f02ec
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.transaction.TransactionControl;
/////////////////////////////////////////////////////////////////////////
1: 			isolationLevel = TransactionControl.READ_COMMITTED_ISOLATION_LEVEL;
/////////////////////////////////////////////////////////////////////////
1: 			case TransactionControl.READ_UNCOMMITTED_ISOLATION_LEVEL:
1: 			case TransactionControl.READ_COMMITTED_ISOLATION_LEVEL:
1: 			case TransactionControl.REPEATABLE_READ_ISOLATION_LEVEL:
1: 			case TransactionControl.SERIALIZABLE_ISOLATION_LEVEL:
commit:3d7a3d4
/////////////////////////////////////////////////////////////////////////
1: 		open(lockMode, true);
1: 	}
1: 
1: 	/**
1: 	 * @inheritDoc
1: 	 */
1: 	public void open(int lockMode, boolean wait)
1: 		 throws StandardException
1: 	{
/////////////////////////////////////////////////////////////////////////
1: 		openForUpdate(fixOnUpdate, lockMode, wait);
1: 
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:af1c18c
/////////////////////////////////////////////////////////////////////////
1:     public RowLocation insertRow(ExecRow baseRow, boolean getRL)
/////////////////////////////////////////////////////////////////////////
1:             if (isc != null || getRL)
1:                 if (baseRowLocation == null) {
1:                     baseRowLocation = baseCC.newRowLocationTemplate();
1:                 }
1: 
1:                 if (isc != null) {
1:                     isc.insert(baseRow, baseRowLocation);
1:                 }
1: 
1:         return getRL ? baseRowLocation : null;
commit:0c5bc3a
/////////////////////////////////////////////////////////////////////////
1:                 baseCC.insert(baseRow.getRowArray());
commit:7d0f620
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 	public int findSelectedCol(int selectedCol) {
1: 		if (selectedCol == -1) {
1: 			// This is not a base column
1: 			return -1;
1: 		}
1: 
1: 		int[] changeColArray = (partialChangedColumnIds == null) ?
1: 			changedColumnIds : partialChangedColumnIds;
1: 
1: 		int nextColumnToUpdate = -1;
1: 		for (int i = 0; i < changeColArray.length; i++) {
1: 			nextColumnToUpdate =
1: 				changedColumnBitSet.anySetBit(nextColumnToUpdate);
1: 
1: 			if (selectedCol == nextColumnToUpdate + 1) { // bit set is 0 based
1: 				return changeColArray[i];
1: 			}
1: 		}
1: 
1: 		return -1;
1: 	}
1: 
1: 
1: 	public String toString() {
1: 		if (SanityManager.DEBUG) {
1: 			StringBuffer sb = new StringBuffer();
1: 			sb.append("changedColumnBitSet: " + changedColumnBitSet + "\n");
1: 
1: 			int[] changedColumnArray = (partialChangedColumnIds == null) ?
1: 				changedColumnIds : partialChangedColumnIds;
1: 
1: 			sb.append("changedColumnArray: [");
1: 			for (int i = 0; i < changedColumnArray.length; i++) {
1: 				sb.append(changedColumnArray[i]);
1: 
1: 				if (i < changedColumnArray.length-1) {
1: 					sb.append(",");
1: 				}
1: 			}
1: 			sb.append("]");
1: 
1: 			return sb.toString();
1: 		} else {
1: 			return super.toString();
1: 		}
1: 	}
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:48d2629
/////////////////////////////////////////////////////////////////////////
1: 	private final Activation		activation;
commit:6bc9897
/////////////////////////////////////////////////////////////////////////
1: class RowChangerImpl	implements	RowChanger
/////////////////////////////////////////////////////////////////////////
1: 	private int[]		baseRowReadMap;	//index=heap column, value=input row column.
/////////////////////////////////////////////////////////////////////////
1: 	private ConglomerateController baseCC;
1: 	private RowLocation	baseRowLocation;
1: 	private IndexSetChanger isc;
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.execute.RowChangerImpl
1: 
0:    Copyright 1998, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:9e5097f
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.execute
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.sql.execute;
1: 
1: import org.apache.derby.iapi.services.io.FormatableBitSet;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: 
1: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1: import org.apache.derby.iapi.sql.conn.StatementContext;
1: import org.apache.derby.iapi.sql.dictionary.IndexRowGenerator;
1: import org.apache.derby.iapi.sql.execute.ExecRow;
1: import org.apache.derby.iapi.sql.execute.ExecutionContext;
1: import org.apache.derby.iapi.sql.execute.RowChanger;
1: import org.apache.derby.iapi.sql.execute.ExecutionFactory;
1: import org.apache.derby.iapi.sql.execute.TemporaryRowHolder;
1: 
1: import org.apache.derby.iapi.sql.Activation;
1: 
1: import org.apache.derby.iapi.store.access.ConglomerateController;
1: import org.apache.derby.iapi.store.access.DynamicCompiledOpenConglomInfo;
1: import org.apache.derby.iapi.store.access.StaticCompiledOpenConglomInfo;
1: import org.apache.derby.iapi.store.access.TransactionController;
1: 
1: import org.apache.derby.iapi.types.DataValueDescriptor;
1: 
1: import org.apache.derby.iapi.types.RowLocation;
1: 
1: import java.util.Vector;
1: 
1: /**
1:   Perform row at a time DML operations of tables and maintain indexes.
1:   */
0: public class RowChangerImpl	implements	RowChanger
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
1: 	boolean isOpen = false;
1: 
1: 	//
1: 	//Stuff provided to the constructor
1: 	boolean[] fixOnUpdate = null;
1: 	long heapConglom;
1: 	DynamicCompiledOpenConglomInfo heapDCOCI;
1: 	StaticCompiledOpenConglomInfo heapSCOCI;
1: 	long[] indexCIDS = null;
1: 	DynamicCompiledOpenConglomInfo[] indexDCOCIs;
1: 	StaticCompiledOpenConglomInfo[] indexSCOCIs;
1: 	IndexRowGenerator[] irgs = null;
0: 	Activation		activation;
1: 	TransactionController	tc;
1: 	FormatableBitSet 	changedColumnBitSet;	
1: 	FormatableBitSet 	baseRowReadList;	
0: 	protected int[]		baseRowReadMap;	//index=heap column, value=input row column.
1: 	int[]		changedColumnIds;
1: 	TemporaryRowHolderImpl	rowHolder;
1: 	
1: 	// for error reporting.
1: 	String[]	indexNames;
1: 
1: 	//
1: 	//Stuff filled in by open
0: 	protected ConglomerateController baseCC = null;
0: 	protected RowLocation	baseRowLocation = null;
0: 	IndexSetChanger isc;
1: 
1: 	// a row array with all non-updated columns compacted out
1: 	private DataValueDescriptor[] sparseRowArray;
1: 	private	int[] partialChangedColumnIds;
1: 	
1: 	/**
1: 	  Create a new RowChanger for performing update and delete operations
1: 	  based on partial before and after rows.
1: 
1: 	  @param heapConglom Conglomerate # for the heap
1: 	  @param heapSCOCI	SCOCI for heap.
1: 	  @param heapDCOCI	DCOCI for heap
1: 	  @param irgs the IndexRowGenerators for the table's indexes. We use
1: 	    positions in this array as local id's for indexes. To support updates,
1: 	    only indexes that change need be included.
1: 	  @param indexCIDS the conglomerateids for the table's idexes. 
1: 	  	indexCIDS[ix] corresponds to the same index as irgs[ix].
1: 	  @param indexSCOCIs the SCOCIs for the table's idexes. 
1: 	  	indexSCOCIs[ix] corresponds to the same index as irgs[ix].
1: 	  @param indexDCOCIs the DCOCIs for the table's idexes. 
1: 	  	indexDCOCIs[ix] corresponds to the same index as irgs[ix].
1: 	  @param numberOfColumns	Number of columns in partial write row.
1: 	  @param changedColumnIdsInput array of 1 based ints indicating the columns
1: 		to be updated.  Only used for updates
1: 	  @param tc the transaction controller
1: 	  @param baseRowReadList bit set of columns read from base row. 1 based.
0: 	  @param baseRowReadMap BaseRowReadMap[heapColId]->ReadRowColumnId. (0 based)
1: 	  @exception StandardException		Thrown on error
1: 	  */
1: 	public RowChangerImpl(
1: 			   long heapConglom,
1: 			   StaticCompiledOpenConglomInfo heapSCOCI,
1: 			   DynamicCompiledOpenConglomInfo heapDCOCI,
1: 			   IndexRowGenerator[] irgs,
1: 			   long[] indexCIDS,
1: 			   StaticCompiledOpenConglomInfo[] indexSCOCIs,
1: 			   DynamicCompiledOpenConglomInfo[] indexDCOCIs,
1: 			   int numberOfColumns,
1: 			   int[] changedColumnIdsInput,
1: 			   TransactionController tc,
1: 			   FormatableBitSet	baseRowReadList,
1: 			   int[] baseRowReadMap,
1: 			   Activation activation)
1: 		 throws StandardException
1: 	{
1: 		this.heapConglom = heapConglom;
1: 		this.heapSCOCI = heapSCOCI;
1: 		this.heapDCOCI = heapDCOCI;
1: 		this.irgs = irgs;
1: 		this.indexCIDS = indexCIDS;
1: 		this.indexSCOCIs = indexSCOCIs;
1: 		this.indexDCOCIs = indexDCOCIs;
1: 		this.tc = tc;
1: 		this.baseRowReadList = baseRowReadList;
1: 		this.baseRowReadMap = baseRowReadMap;
1: 		this.activation = activation;
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(indexCIDS != null, "indexCIDS is null");
1: 		}
1: 
1: 		/*
1: 		** Construct the update column FormatableBitSet.
1: 		** It is 0 based as opposed to the 1 based
1: 		** changed column ids.
1: 		*/
1: 		if (changedColumnIdsInput != null)
1: 		{
1: 			/*
1: 			** Sometimes replication does not have columns
1: 			** in sorted order, and basically needs to
1: 			** have the changed columns in non-sorted order.
1: 			** So sort them first if needed.
1: 			*/
1: 			changedColumnIds = RowUtil.inAscendingOrder(changedColumnIdsInput) ?
1: 								changedColumnIdsInput : sortArray(changedColumnIdsInput);
1: 
1: 			/*
1: 			** Allocate the row array we are going to use during
1: 			** update here, to avoid extra work.  setup
1: 			** the FormatableBitSet of columns being updated.  See updateRow
1: 			** for the use.
1: 			**
1: 			** changedColumnIds is guaranteed to be in order, so just take
1: 			** the last column number in the array to be the highest
1: 			** column number.
1: 			*/
1: 			sparseRowArray =
1: 				new DataValueDescriptor[changedColumnIds[changedColumnIds.length - 1] + 1];
1: 			changedColumnBitSet = new FormatableBitSet(numberOfColumns);
1: 			for (int i = 0; i < changedColumnIds.length; i++)
1: 			{
1: 				// make sure changedColumnBitSet can accomodate bit 
1: 				// changedColumnIds[i] - 1 
1: 				changedColumnBitSet.grow(changedColumnIds[i]);
1: 				changedColumnBitSet.set(changedColumnIds[i] - 1);
1: 			}
1: 
1: 			/*
1: 			** If we have a read map and a write map, we
1: 			** need to have a way to map the changed column
1: 			** ids to be relative to the read map.
1: 			*/
1: 			if (baseRowReadList != null)
1: 			{
1: 				partialChangedColumnIds = new int[changedColumnIds.length];
1: 				int partialColumnNumber = 1;
1: 				int currentColumn = 0;
1: 				for (int i = 0; i < changedColumnIds.length; i++)
1: 				{
1: 					for (; currentColumn < changedColumnIds[i]; currentColumn++)
1: 					{
1: 						if (baseRowReadList.get(currentColumn))
1: 						{
1: 							partialColumnNumber++;
1: 						}
1: 					}
1: 					partialChangedColumnIds[i] = partialColumnNumber;
1: 				}
1: 			}	
1: 		}
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(indexCIDS != null, "indexCIDS is null");
1: 		}
1: 		
1: 	}
1: 
1: 	/**
1: 	 * Set the row holder for this changer to use.
1: 	 * If the row holder is set, it wont bother 
1: 	 * saving copies of rows needed for deferred
1: 	 * processing.  Also, it will never close the
1: 	 * passed in rowHolder.
1: 	 *
1: 	 * @param rowHolder	the TemporaryRowHolder
1: 	 */
1: 	public void setRowHolder(TemporaryRowHolder rowHolder)
1: 	{
1: 		this.rowHolder = (TemporaryRowHolderImpl)rowHolder;
1: 	}
1: 
1: 	/**
1: 	 * @see RowChanger#setIndexNames
1: 	 */
1: 	public void setIndexNames(String[] indexNames)
1: 	{
1: 		this.indexNames = indexNames;
1: 	}
1: 
1: 	/**
1: 	  Open this RowChanger.
1: 
1: 	  <P>Note to avoid the cost of fixing indexes that do not
1: 	  change during update operations use openForUpdate().
1: 	  @param lockMode	The lock mode to use
1: 							(row or table, see TransactionController)
1: 
1: 	  @exception StandardException thrown on failure to convert
1: 	  */
1: 	public void open(int lockMode)
1: 		 throws StandardException
1: 	{
1: 		//
1: 		//We open for update but say to fix every index on
1: 		//updates.
1: 		if (fixOnUpdate == null)
1: 		{
1: 			fixOnUpdate = new boolean[irgs.length];
1: 			for (int ix = 0; ix < irgs.length; ix++)
1: 				fixOnUpdate[ix] = true;
1: 		}
0: 		openForUpdate(fixOnUpdate, lockMode, true);
1: 	}
1: 	
1: 	/**
1: 	  Open this RowChanger to avoid fixing indexes that do not change
1: 	  during update operations. 
1: 
0: 	  @param fixOnUpdate fixOnUpdat[ix] == true ==> fix index 'ix' on
1: 	  an update operation.
1: 	  @param lockMode	The lock mode to use
1: 							(row or table, see TransactionController)
1: 	  @param wait		If true, then the caller wants to wait for locks. False will be
1: 							when we using a nested user xaction - we want to timeout right away
1: 							if the parent holds the lock.  (bug 4821)
1: 
1: 	  @exception StandardException thrown on failure to convert
1: 	  */
1: 	public void openForUpdate(
1: 				  boolean[] fixOnUpdate, int lockMode, boolean wait
1: 			  )
1: 		 throws StandardException
1: 	{
1: 		LanguageConnectionContext lcc = null;
1: 
1: 		if (SanityManager.DEBUG)
1: 		    SanityManager.ASSERT( ! isOpen, "RowChanger already open");
1: 		
1: 		if (activation != null)
1: 		{
1: 			lcc = activation.getLanguageConnectionContext();
1: 		}
1: 
1: 		/* Isolation level - translate from language to store */
1: 		int isolationLevel;
1: 		if (lcc == null)
1: 		{
0: 			isolationLevel = ExecutionContext.READ_COMMITTED_ISOLATION_LEVEL;
1: 		}
1: 		else
1: 		{
1: 			isolationLevel = lcc.getCurrentIsolationLevel();
1: 		}
1: 
1: 
1: 		switch (isolationLevel)
1: 		{
1: 			// Even though we preserve the isolation level at READ UNCOMMITTED,
0: 			// Cloudscape Store will overwrite it to READ COMMITTED for update.
0: 			case ExecutionContext.READ_UNCOMMITTED_ISOLATION_LEVEL:
1: 				isolationLevel = 
1:                     TransactionController.ISOLATION_READ_UNCOMMITTED;
1: 				break;
1: 
0: 			case ExecutionContext.READ_COMMITTED_ISOLATION_LEVEL:
1: 				isolationLevel = 
1:                     TransactionController.ISOLATION_READ_COMMITTED;
1: 				break;
1: 
0: 			case ExecutionContext.REPEATABLE_READ_ISOLATION_LEVEL:
1: 				isolationLevel = 
1:                     TransactionController.ISOLATION_REPEATABLE_READ;
1: 				break;
1: 
0: 			case ExecutionContext.SERIALIZABLE_ISOLATION_LEVEL:
1: 				isolationLevel = 
1:                     TransactionController.ISOLATION_SERIALIZABLE;
1: 				break;
1: 
1: 			default:
1: 				if (SanityManager.DEBUG)
1: 				{
1: 					SanityManager.THROWASSERT(
1: 						"Invalid isolation level - " + isolationLevel);
1: 				}
1: 		}
1: 
1: 		try {
1: 
1: 		/* We can get called by either an activation or 
1: 		 * the DataDictionary.  The DD cannot use the
1: 		 * CompiledInfo while the activation can.
1: 		 */
1: 		if (heapSCOCI != null)
1: 		{
1: 	        baseCC =
1: 				tc.openCompiledConglomerate(
1: 					false,
1:                     (TransactionController.OPENMODE_FORUPDATE |
1:                     ((wait) ? 0 : TransactionController.OPENMODE_LOCK_NOWAIT)),
1: 					lockMode,
1: 					isolationLevel,
1: 					heapSCOCI,
1: 					heapDCOCI);
1: 		}
1: 		else
1: 		{
1: 	        baseCC =
1: 				tc.openConglomerate(
1: 					heapConglom,
1: 					false,
1:                     (TransactionController.OPENMODE_FORUPDATE |
1:                     ((wait) ? 0 : TransactionController.OPENMODE_LOCK_NOWAIT)),
1: 					lockMode,
1: 					isolationLevel);
1: 		}
1: 
1: 		} catch (StandardException se) {
1: 			if (activation != null)
1: 				activation.checkStatementValidity();
1: 			throw se;
1: 		}
1: 
1: 		/* Save the ConglomerateController off in the activation
1: 		 * to eliminate the need to open it a 2nd time if we are doing
1: 		 * and index to base row for the search as part of an update or
1: 		 * delete below us.
1: 		 * NOTE: activation can be null.  (We don't have it in
1: 		 * the DataDictionary.)
1: 		 */
1: 		if (activation != null)
1: 		{
1: 			activation.checkStatementValidity();
1: 			activation.setHeapConglomerateController(baseCC);
1: 		}
1: 
1: 		/* Only worry about indexes if there are indexes to worry about */
1: 		if (indexCIDS.length != 0)
1: 		{
1: 			/* IndexSetChanger re-used across executions. */
1: 			if (isc == null)
1: 			{
1: 				isc = new IndexSetChanger(irgs,
1: 										  indexCIDS,
1: 										  indexSCOCIs,
1: 										  indexDCOCIs,
1: 										  indexNames,
1: 										  baseCC,
1: 										  tc,
1: 										  lockMode,
1: 										  baseRowReadList,
1: 										  isolationLevel,
1: 										  activation
1: 										  );
1: 				isc.setRowHolder(rowHolder);
1: 			}
1: 			else
1: 			{
1: 
1: 				/* Propagate the heap's ConglomerateController to
1: 				 * all of the underlying index changers.
1: 				 */
1: 				isc.setBaseCC(baseCC);
1: 			}
1: 
1: 			isc.open(fixOnUpdate);
1: 
1: 			if (baseRowLocation == null)
1: 				baseRowLocation = baseCC.newRowLocationTemplate();
1: 		}
1: 
1: 		isOpen = true;
1: 	}
1: 	   
1: 	/**
1: 	  Insert a row into the table and perform associated index maintenance.
1: 
1: 	  @param baseRow the row.
1: 	  @param baseRowLocation the row's base conglomerate
1: 	     location
1: 	  @exception StandardException		Thrown on error
1: 	  */
0: 	public void insertRow(ExecRow baseRow)
1: 		 throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT(! baseCC.isKeyed(),
1: 								 "Keyed inserts not yet supported");
1: 
1: 		if (baseCC.isKeyed())
1: 		{
1: 			//kcc.insert(row.key(), row());
1: 		}
1: 		else
1: 		{
1: 			if (isc != null)
1: 			{
1: 				baseCC.insertAndFetchLocation(baseRow.getRowArray(), baseRowLocation);
0: 				isc.insert(baseRow, baseRowLocation);
1: 			}
1: 			else
1: 			{
0: 				baseCC.insert(baseRow.getRowArray());
1: 			}
1: 		}
1: 	}
1: 
1: 		
1: 	/**
1: 	  Delete a row from the table and perform associated index maintenance.
1: 
1: 	  @param baseRow the row.
1: 	  @param baseRowLocation the row's base conglomerate
1: 	     location
1: 	  @exception StandardException		Thrown on error
1: 	  */
1: 	public void deleteRow(ExecRow baseRow, RowLocation baseRowLocation)
1: 		 throws StandardException
1: 	{
1: 		if (isc != null)
1: 		{
1: 			isc.delete(baseRow, baseRowLocation);
1: 		}
1: 		baseCC.delete(baseRowLocation);
1: 	}
1: 
1: 	/**
1: 	  Update a row in the table and perform associated index maintenance.
1: 
0: 	  @param ef	ExecutionFactory to use for cloning
1: 	  @param oldBaseRow the old image of the row.
1: 	  @param newBaseRow the new image of the row.
1: 	  @param baseRowLocation the row's base conglomerate
1: 	     location
1: 	  @exception StandardException		Thrown on error
1: 	  */
1: 	public void updateRow(ExecRow oldBaseRow,
1: 						  ExecRow newBaseRow,
1: 						  RowLocation baseRowLocation)
1: 		 throws StandardException
1: 	{
1: 		if (isc != null)
1: 		{
1: 			isc.update(oldBaseRow, newBaseRow, baseRowLocation);
1: 		}
1: 
1: 		if (changedColumnBitSet != null)
1: 		{
1: 			DataValueDescriptor[] baseRowArray = newBaseRow.getRowArray();
1: 			int[] changedColumnArray = (partialChangedColumnIds == null) ?
1: 					changedColumnIds : partialChangedColumnIds;
1: 			int nextColumnToUpdate = -1;
1: 			for (int i = 0; i < changedColumnArray.length; i++)
1: 			{
1: 				int copyFrom = changedColumnArray[i] - 1;
1: 				nextColumnToUpdate =
1: 							changedColumnBitSet.anySetBit(nextColumnToUpdate);
1: 				if (SanityManager.DEBUG)
1: 				{
1: 					SanityManager.ASSERT(nextColumnToUpdate >= 0,
1: 						"More columns in changedColumnArray than in changedColumnBitSet");
1: 				}
1: 				sparseRowArray[nextColumnToUpdate] = baseRowArray[copyFrom];
1: 			}
1: 		}
1: 		else
1: 		{
1: 			sparseRowArray = newBaseRow.getRowArray();
1: 		}
1: 		baseCC.replace(baseRowLocation, 
1: 					sparseRowArray, 
1: 					changedColumnBitSet);
1: 	}
1: 
1: 	/**
1: 	  Finish processing the changes.  This means applying the deferred
1: 	  inserts for updates to unique indexes.
1: 
1: 	  @exception StandardException		Thrown on error
1: 	 */
1: 	public void finish()
1: 		throws StandardException
1: 	{
1: 		if (isc != null)
1: 		{
1: 			isc.finish();
1: 		}
1: 	}
1: 
1: 	/**
1: 	  Close this RowChanger.
1: 
1: 	  @exception StandardException		Thrown on error
1: 	  */
1: 	public void close()
1: 		throws StandardException
1: 	{
1: 		//
1: 		//NOTE: isc uses baseCC. Since we close baseCC we free isc for now.
1: 		//We could consider making isc open its own baseCC or even leaving
1: 		//baseCC open to promote re-use. We must keep in mind that baseCC
1: 		//is associated with the opener's TransactionController.
1: 		if (isc != null)
1: 		{
1: 			isc.close(); 
1: 		}
1: 
1: 		if (baseCC != null)
1: 		{
1: 			if (activation == null || activation.getForUpdateIndexScan() == null)
1: 				baseCC.close();		//beetle 3865, don't close if borrowed to cursor
1: 			baseCC = null;
1: 		}
1: 		
1: 		isOpen = false;
1: 
1: 		// rowHolder is reused across executions and closed by caller
1: 		// since caller creates it
1: 
1: 		if (activation != null)
1: 		{
1: 			activation.clearHeapConglomerateController();
1: 		}
1: 	}
1: 
1: 	/** @see RowChanger#getHeapConglomerateController */
1: 	public ConglomerateController getHeapConglomerateController()
1: 	{
1: 		return baseCC;
1: 	}
1: 
1: 	private int[] sortArray(int[] input)
1: 	{
1: 		/*
1: 		** Sotring.sort() will change the underlying array, so we
1: 		** 'clone' it first
1: 		*/
1: 		int[] output = new int[input.length];
1: 		System.arraycopy(input, 0, output, 0, input.length);
1: 		java.util.Arrays.sort(output);
1: 		return output;
1: 	}
1: }
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:94f158a
/////////////////////////////////////////////////////////////////////////
1: 			// Store will overwrite it to READ COMMITTED for update.
author:David Van Couvering
-------------------------------------------------------------------------------
commit:f6123ee
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.execute
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.sql.execute;
0: 
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: import org.apache.derby.iapi.sql.conn.StatementContext;
0: import org.apache.derby.iapi.sql.dictionary.IndexRowGenerator;
0: import org.apache.derby.iapi.sql.execute.ExecRow;
0: import org.apache.derby.iapi.sql.execute.ExecutionContext;
0: import org.apache.derby.iapi.sql.execute.RowChanger;
0: import org.apache.derby.iapi.sql.execute.ExecutionFactory;
0: import org.apache.derby.iapi.sql.execute.TemporaryRowHolder;
0: 
0: import org.apache.derby.iapi.sql.Activation;
0: 
0: import org.apache.derby.iapi.store.access.ConglomerateController;
0: import org.apache.derby.iapi.store.access.DynamicCompiledOpenConglomInfo;
0: import org.apache.derby.iapi.store.access.StaticCompiledOpenConglomInfo;
0: import org.apache.derby.iapi.store.access.TransactionController;
0: 
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: 
0: import org.apache.derby.iapi.types.RowLocation;
0: 
0: import java.util.Vector;
0: 
0: /**
0:   Perform row at a time DML operations of tables and maintain indexes.
0:   */
0: public class RowChangerImpl	implements	RowChanger
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
0: 	boolean isOpen = false;
0: 
0: 	//
0: 	//Stuff provided to the constructor
0: 	boolean[] fixOnUpdate = null;
0: 	long heapConglom;
0: 	DynamicCompiledOpenConglomInfo heapDCOCI;
0: 	StaticCompiledOpenConglomInfo heapSCOCI;
0: 	long[] indexCIDS = null;
0: 	DynamicCompiledOpenConglomInfo[] indexDCOCIs;
0: 	StaticCompiledOpenConglomInfo[] indexSCOCIs;
0: 	IndexRowGenerator[] irgs = null;
0: 	Activation		activation;
0: 	TransactionController	tc;
0: 	FormatableBitSet 	changedColumnBitSet;	
0: 	FormatableBitSet 	baseRowReadList;	
0: 	protected int[]		baseRowReadMap;	//index=heap column, value=input row column.
0: 	int[]		changedColumnIds;
0: 	TemporaryRowHolderImpl	rowHolder;
0: 	
0: 	// for error reporting.
0: 	String[]	indexNames;
0: 
0: 	//
0: 	//Stuff filled in by open
0: 	protected ConglomerateController baseCC = null;
0: 	protected RowLocation	baseRowLocation = null;
0: 	IndexSetChanger isc;
0: 
0: 	// a row array with all non-updated columns compacted out
0: 	private DataValueDescriptor[] sparseRowArray;
0: 	private	int[] partialChangedColumnIds;
0: 	
0: 	/**
0: 	  Create a new RowChanger for performing update and delete operations
0: 	  based on partial before and after rows.
0: 
0: 	  @param heapConglom Conglomerate # for the heap
0: 	  @param heapSCOCI	SCOCI for heap.
0: 	  @param heapDCOCI	DCOCI for heap
0: 	  @param irgs the IndexRowGenerators for the table's indexes. We use
0: 	    positions in this array as local id's for indexes. To support updates,
0: 	    only indexes that change need be included.
0: 	  @param indexCIDS the conglomerateids for the table's idexes. 
0: 	  	indexCIDS[ix] corresponds to the same index as irgs[ix].
0: 	  @param indexSCOCIs the SCOCIs for the table's idexes. 
0: 	  	indexSCOCIs[ix] corresponds to the same index as irgs[ix].
0: 	  @param indexDCOCIs the DCOCIs for the table's idexes. 
0: 	  	indexDCOCIs[ix] corresponds to the same index as irgs[ix].
0: 	  @param numberOfColumns	Number of columns in partial write row.
0: 	  @param changedColumnIdsInput array of 1 based ints indicating the columns
0: 		to be updated.  Only used for updates
0: 	  @param tc the transaction controller
0: 	  @param baseRowReadList bit set of columns read from base row. 1 based.
0: 	  @param baseRowReadMap BaseRowReadMap[heapColId]->ReadRowColumnId. (0 based)
0: 	  @exception StandardException		Thrown on error
0: 	  */
0: 	public RowChangerImpl(
0: 			   long heapConglom,
0: 			   StaticCompiledOpenConglomInfo heapSCOCI,
0: 			   DynamicCompiledOpenConglomInfo heapDCOCI,
0: 			   IndexRowGenerator[] irgs,
0: 			   long[] indexCIDS,
0: 			   StaticCompiledOpenConglomInfo[] indexSCOCIs,
0: 			   DynamicCompiledOpenConglomInfo[] indexDCOCIs,
0: 			   int numberOfColumns,
0: 			   int[] changedColumnIdsInput,
0: 			   TransactionController tc,
0: 			   FormatableBitSet	baseRowReadList,
0: 			   int[] baseRowReadMap,
0: 			   Activation activation)
0: 		 throws StandardException
0: 	{
0: 		this.heapConglom = heapConglom;
0: 		this.heapSCOCI = heapSCOCI;
0: 		this.heapDCOCI = heapDCOCI;
0: 		this.irgs = irgs;
0: 		this.indexCIDS = indexCIDS;
0: 		this.indexSCOCIs = indexSCOCIs;
0: 		this.indexDCOCIs = indexDCOCIs;
0: 		this.tc = tc;
0: 		this.baseRowReadList = baseRowReadList;
0: 		this.baseRowReadMap = baseRowReadMap;
0: 		this.activation = activation;
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(indexCIDS != null, "indexCIDS is null");
0: 		}
0: 
0: 		/*
0: 		** Construct the update column FormatableBitSet.
0: 		** It is 0 based as opposed to the 1 based
0: 		** changed column ids.
0: 		*/
0: 		if (changedColumnIdsInput != null)
0: 		{
0: 			/*
0: 			** Sometimes replication does not have columns
0: 			** in sorted order, and basically needs to
0: 			** have the changed columns in non-sorted order.
0: 			** So sort them first if needed.
0: 			*/
0: 			changedColumnIds = RowUtil.inAscendingOrder(changedColumnIdsInput) ?
0: 								changedColumnIdsInput : sortArray(changedColumnIdsInput);
0: 
0: 			/*
0: 			** Allocate the row array we are going to use during
0: 			** update here, to avoid extra work.  setup
0: 			** the FormatableBitSet of columns being updated.  See updateRow
0: 			** for the use.
0: 			**
0: 			** changedColumnIds is guaranteed to be in order, so just take
0: 			** the last column number in the array to be the highest
0: 			** column number.
0: 			*/
0: 			sparseRowArray =
0: 				new DataValueDescriptor[changedColumnIds[changedColumnIds.length - 1] + 1];
0: 			changedColumnBitSet = new FormatableBitSet(numberOfColumns);
0: 			for (int i = 0; i < changedColumnIds.length; i++)
0: 			{
0: 				// make sure changedColumnBitSet can accomodate bit 
0: 				// changedColumnIds[i] - 1 
0: 				changedColumnBitSet.grow(changedColumnIds[i]);
0: 				changedColumnBitSet.set(changedColumnIds[i] - 1);
0: 			}
0: 
0: 			/*
0: 			** If we have a read map and a write map, we
0: 			** need to have a way to map the changed column
0: 			** ids to be relative to the read map.
0: 			*/
0: 			if (baseRowReadList != null)
0: 			{
0: 				partialChangedColumnIds = new int[changedColumnIds.length];
0: 				int partialColumnNumber = 1;
0: 				int currentColumn = 0;
0: 				for (int i = 0; i < changedColumnIds.length; i++)
0: 				{
0: 					for (; currentColumn < changedColumnIds[i]; currentColumn++)
0: 					{
0: 						if (baseRowReadList.get(currentColumn))
0: 						{
0: 							partialColumnNumber++;
0: 						}
0: 					}
0: 					partialChangedColumnIds[i] = partialColumnNumber;
0: 				}
0: 			}	
0: 		}
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(indexCIDS != null, "indexCIDS is null");
0: 		}
0: 		
0: 	}
0: 
0: 	/**
0: 	 * Set the row holder for this changer to use.
0: 	 * If the row holder is set, it wont bother 
0: 	 * saving copies of rows needed for deferred
0: 	 * processing.  Also, it will never close the
0: 	 * passed in rowHolder.
0: 	 *
0: 	 * @param rowHolder	the TemporaryRowHolder
0: 	 */
0: 	public void setRowHolder(TemporaryRowHolder rowHolder)
0: 	{
0: 		this.rowHolder = (TemporaryRowHolderImpl)rowHolder;
0: 	}
0: 
0: 	/**
0: 	 * @see RowChanger#setIndexNames
0: 	 */
0: 	public void setIndexNames(String[] indexNames)
0: 	{
0: 		this.indexNames = indexNames;
0: 	}
0: 
0: 	/**
0: 	  Open this RowChanger.
0: 
0: 	  <P>Note to avoid the cost of fixing indexes that do not
0: 	  change during update operations use openForUpdate().
0: 	  @param lockMode	The lock mode to use
0: 							(row or table, see TransactionController)
0: 
0: 	  @exception StandardException thrown on failure to convert
0: 	  */
0: 	public void open(int lockMode)
0: 		 throws StandardException
0: 	{
0: 		//
0: 		//We open for update but say to fix every index on
0: 		//updates.
0: 		if (fixOnUpdate == null)
0: 		{
0: 			fixOnUpdate = new boolean[irgs.length];
0: 			for (int ix = 0; ix < irgs.length; ix++)
0: 				fixOnUpdate[ix] = true;
0: 		}
0: 		openForUpdate(fixOnUpdate, lockMode, true);
0: 	}
0: 	
0: 	/**
0: 	  Open this RowChanger to avoid fixing indexes that do not change
0: 	  during update operations. 
0: 
0: 	  @param fixOnUpdate fixOnUpdat[ix] == true ==> fix index 'ix' on
0: 	  an update operation.
0: 	  @param lockMode	The lock mode to use
0: 							(row or table, see TransactionController)
0: 	  @param wait		If true, then the caller wants to wait for locks. False will be
0: 							when we using a nested user xaction - we want to timeout right away
0: 							if the parent holds the lock.  (bug 4821)
0: 
0: 	  @exception StandardException thrown on failure to convert
0: 	  */
0: 	public void openForUpdate(
0: 				  boolean[] fixOnUpdate, int lockMode, boolean wait
0: 			  )
0: 		 throws StandardException
0: 	{
0: 		LanguageConnectionContext lcc = null;
0: 
0: 		if (SanityManager.DEBUG)
0: 		    SanityManager.ASSERT( ! isOpen, "RowChanger already open");
0: 		
0: 		if (activation != null)
0: 		{
0: 			lcc = activation.getLanguageConnectionContext();
0: 		}
0: 
0: 		/* Isolation level - translate from language to store */
0: 		int isolationLevel;
0: 		if (lcc == null)
0: 		{
0: 			isolationLevel = ExecutionContext.READ_COMMITTED_ISOLATION_LEVEL;
0: 		}
0: 		else
0: 		{
0: 			isolationLevel = lcc.getCurrentIsolationLevel();
0: 		}
0: 
0: 
0: 		switch (isolationLevel)
0: 		{
0: 			// Even though we preserve the isolation level at READ UNCOMMITTED,
0: 			// Cloudscape Store will overwrite it to READ COMMITTED for update.
0: 			case ExecutionContext.READ_UNCOMMITTED_ISOLATION_LEVEL:
0: 				isolationLevel = 
0:                     TransactionController.ISOLATION_READ_UNCOMMITTED;
0: 				break;
0: 
0: 			case ExecutionContext.READ_COMMITTED_ISOLATION_LEVEL:
0: 				isolationLevel = 
0:                     TransactionController.ISOLATION_READ_COMMITTED;
0: 				break;
0: 
0: 			case ExecutionContext.REPEATABLE_READ_ISOLATION_LEVEL:
0: 				isolationLevel = 
0:                     TransactionController.ISOLATION_REPEATABLE_READ;
0: 				break;
0: 
0: 			case ExecutionContext.SERIALIZABLE_ISOLATION_LEVEL:
0: 				isolationLevel = 
0:                     TransactionController.ISOLATION_SERIALIZABLE;
0: 				break;
0: 
0: 			default:
0: 				if (SanityManager.DEBUG)
0: 				{
0: 					SanityManager.THROWASSERT(
0: 						"Invalid isolation level - " + isolationLevel);
0: 				}
0: 		}
0: 
0: 		try {
0: 
0: 		/* We can get called by either an activation or 
0: 		 * the DataDictionary.  The DD cannot use the
0: 		 * CompiledInfo while the activation can.
0: 		 */
0: 		if (heapSCOCI != null)
0: 		{
0: 	        baseCC =
0: 				tc.openCompiledConglomerate(
0: 					false,
0:                     (TransactionController.OPENMODE_FORUPDATE |
0:                     ((wait) ? 0 : TransactionController.OPENMODE_LOCK_NOWAIT)),
0: 					lockMode,
0: 					isolationLevel,
0: 					heapSCOCI,
0: 					heapDCOCI);
0: 		}
0: 		else
0: 		{
0: 	        baseCC =
0: 				tc.openConglomerate(
0: 					heapConglom,
0: 					false,
0:                     (TransactionController.OPENMODE_FORUPDATE |
0:                     ((wait) ? 0 : TransactionController.OPENMODE_LOCK_NOWAIT)),
0: 					lockMode,
0: 					isolationLevel);
0: 		}
0: 
0: 		} catch (StandardException se) {
0: 			if (activation != null)
0: 				activation.checkStatementValidity();
0: 			throw se;
0: 		}
0: 
0: 		/* Save the ConglomerateController off in the activation
0: 		 * to eliminate the need to open it a 2nd time if we are doing
0: 		 * and index to base row for the search as part of an update or
0: 		 * delete below us.
0: 		 * NOTE: activation can be null.  (We don't have it in
0: 		 * the DataDictionary.)
0: 		 */
0: 		if (activation != null)
0: 		{
0: 			activation.checkStatementValidity();
0: 			activation.setHeapConglomerateController(baseCC);
0: 		}
0: 
0: 		/* Only worry about indexes if there are indexes to worry about */
0: 		if (indexCIDS.length != 0)
0: 		{
0: 			/* IndexSetChanger re-used across executions. */
0: 			if (isc == null)
0: 			{
0: 				isc = new IndexSetChanger(irgs,
0: 										  indexCIDS,
0: 										  indexSCOCIs,
0: 										  indexDCOCIs,
0: 										  indexNames,
0: 										  baseCC,
0: 										  tc,
0: 										  lockMode,
0: 										  baseRowReadList,
0: 										  isolationLevel,
0: 										  activation
0: 										  );
0: 				isc.setRowHolder(rowHolder);
0: 			}
0: 			else
0: 			{
0: 
0: 				/* Propagate the heap's ConglomerateController to
0: 				 * all of the underlying index changers.
0: 				 */
0: 				isc.setBaseCC(baseCC);
0: 			}
0: 
0: 			isc.open(fixOnUpdate);
0: 
0: 			if (baseRowLocation == null)
0: 				baseRowLocation = baseCC.newRowLocationTemplate();
0: 		}
0: 
0: 		isOpen = true;
0: 	}
0: 	   
0: 	/**
0: 	  Insert a row into the table and perform associated index maintenance.
0: 
0: 	  @param baseRow the row.
0: 	  @param baseRowLocation the row's base conglomerate
0: 	     location
0: 	  @exception StandardException		Thrown on error
0: 	  */
0: 	public void insertRow(ExecRow baseRow)
0: 		 throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(! baseCC.isKeyed(),
0: 								 "Keyed inserts not yet supported");
0: 
0: 		if (baseCC.isKeyed())
0: 		{
0: 			//kcc.insert(row.key(), row());
0: 		}
0: 		else
0: 		{
0: 			if (isc != null)
0: 			{
0: 				baseCC.insertAndFetchLocation(baseRow.getRowArray(), baseRowLocation);
0: 				isc.insert(baseRow, baseRowLocation);
0: 			}
0: 			else
0: 			{
0: 				baseCC.insert(baseRow.getRowArray());
0: 			}
0: 		}
0: 	}
0: 
0: 		
0: 	/**
0: 	  Delete a row from the table and perform associated index maintenance.
0: 
0: 	  @param baseRow the row.
0: 	  @param baseRowLocation the row's base conglomerate
0: 	     location
0: 	  @exception StandardException		Thrown on error
0: 	  */
0: 	public void deleteRow(ExecRow baseRow, RowLocation baseRowLocation)
0: 		 throws StandardException
0: 	{
0: 		if (isc != null)
0: 		{
0: 			isc.delete(baseRow, baseRowLocation);
0: 		}
0: 		baseCC.delete(baseRowLocation);
0: 	}
0: 
0: 	/**
0: 	  Update a row in the table and perform associated index maintenance.
0: 
0: 	  @param ef	ExecutionFactory to use for cloning
0: 	  @param oldBaseRow the old image of the row.
0: 	  @param newBaseRow the new image of the row.
0: 	  @param baseRowLocation the row's base conglomerate
0: 	     location
0: 	  @exception StandardException		Thrown on error
0: 	  */
0: 	public void updateRow(ExecRow oldBaseRow,
0: 						  ExecRow newBaseRow,
0: 						  RowLocation baseRowLocation)
0: 		 throws StandardException
0: 	{
0: 		if (isc != null)
0: 		{
0: 			isc.update(oldBaseRow, newBaseRow, baseRowLocation);
0: 		}
0: 
0: 		if (changedColumnBitSet != null)
0: 		{
0: 			DataValueDescriptor[] baseRowArray = newBaseRow.getRowArray();
0: 			int[] changedColumnArray = (partialChangedColumnIds == null) ?
0: 					changedColumnIds : partialChangedColumnIds;
0: 			int nextColumnToUpdate = -1;
0: 			for (int i = 0; i < changedColumnArray.length; i++)
0: 			{
0: 				int copyFrom = changedColumnArray[i] - 1;
0: 				nextColumnToUpdate =
0: 							changedColumnBitSet.anySetBit(nextColumnToUpdate);
0: 				if (SanityManager.DEBUG)
0: 				{
0: 					SanityManager.ASSERT(nextColumnToUpdate >= 0,
0: 						"More columns in changedColumnArray than in changedColumnBitSet");
0: 				}
0: 				sparseRowArray[nextColumnToUpdate] = baseRowArray[copyFrom];
0: 			}
0: 		}
0: 		else
0: 		{
0: 			sparseRowArray = newBaseRow.getRowArray();
0: 		}
0: 		baseCC.replace(baseRowLocation, 
0: 					sparseRowArray, 
0: 					changedColumnBitSet);
0: 	}
0: 
0: 	/**
0: 	  Finish processing the changes.  This means applying the deferred
0: 	  inserts for updates to unique indexes.
0: 
0: 	  @exception StandardException		Thrown on error
0: 	 */
0: 	public void finish()
0: 		throws StandardException
0: 	{
0: 		if (isc != null)
0: 		{
0: 			isc.finish();
0: 		}
0: 	}
0: 
0: 	/**
0: 	  Close this RowChanger.
0: 
0: 	  @exception StandardException		Thrown on error
0: 	  */
0: 	public void close()
0: 		throws StandardException
0: 	{
0: 		//
0: 		//NOTE: isc uses baseCC. Since we close baseCC we free isc for now.
0: 		//We could consider making isc open its own baseCC or even leaving
0: 		//baseCC open to promote re-use. We must keep in mind that baseCC
0: 		//is associated with the opener's TransactionController.
0: 		if (isc != null)
0: 		{
0: 			isc.close(); 
0: 		}
0: 
0: 		if (baseCC != null)
0: 		{
0: 			if (activation == null || activation.getForUpdateIndexScan() == null)
0: 				baseCC.close();		//beetle 3865, don't close if borrowed to cursor
0: 			baseCC = null;
0: 		}
0: 		
0: 		isOpen = false;
0: 
0: 		// rowHolder is reused across executions and closed by caller
0: 		// since caller creates it
0: 
0: 		if (activation != null)
0: 		{
0: 			activation.clearHeapConglomerateController();
0: 		}
0: 	}
0: 
0: 	/** @see RowChanger#getHeapConglomerateController */
0: 	public ConglomerateController getHeapConglomerateController()
0: 	{
0: 		return baseCC;
0: 	}
0: 
0: 	private int[] sortArray(int[] input)
0: 	{
0: 		/*
0: 		** Sotring.sort() will change the underlying array, so we
0: 		** 'clone' it first
0: 		*/
0: 		int[] output = new int[input.length];
0: 		System.arraycopy(input, 0, output, 0, input.length);
0: 		java.util.Arrays.sort(output);
0: 		return output;
0: 	}
0: }
============================================================================