1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.services.reflect.DatabaseClasses
1:345de35: 
1:93fea34:    Licensed to the Apache Software Foundation (ASF) under one or more
1:93fea34:    contributor license agreements.  See the NOTICE file distributed with
1:93fea34:    this work for additional information regarding copyright ownership.
1:93fea34:    The ASF licenses this file to you under the Apache License, Version 2.0
1:93fea34:    (the "License"); you may not use this file except in compliance with
1:93fea34:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
20:eac0369: 
2:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.services.reflect;
1:eac0369: 
1:eac0369: import java.io.File;
1:eac0369: import java.io.FileOutputStream;
1:eac0369: import java.io.IOException;
1:6790718: import java.io.ObjectStreamClass;
1:44454b6: import java.security.AccessController;
1:56c1dc2: import java.security.PrivilegedAction;
1:44454b6: import java.security.PrivilegedActionException;
1:44454b6: import java.security.PrivilegedExceptionAction;
1:6790718: import java.util.Properties;
1:6790718: import org.apache.derby.iapi.error.StandardException;
1:6790718: import org.apache.derby.iapi.reference.MessageId;
1:6790718: import org.apache.derby.iapi.reference.Property;
1:6790718: import org.apache.derby.iapi.reference.SQLState;
1:6790718: import org.apache.derby.iapi.services.i18n.MessageService;
1:6790718: import org.apache.derby.iapi.services.loader.ClassFactory;
1:6790718: import org.apache.derby.iapi.services.loader.ClassInspector;
1:6790718: import org.apache.derby.iapi.services.loader.GeneratedClass;
1:6790718: import org.apache.derby.iapi.services.monitor.ModuleControl;
1:56c1dc2: import org.apache.derby.iapi.services.monitor.ModuleFactory;
1:6790718: import org.apache.derby.iapi.services.monitor.Monitor;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:6790718: import org.apache.derby.iapi.services.stream.HeaderPrintWriter;
1:6790718: import org.apache.derby.iapi.util.ByteArray;
1:eac0369: 
2:eac0369: /**
1:eac0369: 
1:eac0369:     An abstract implementation of the ClassFactory. This package can
1:eac0369: 	be extended to fully implement a ClassFactory. Implementations can
1:eac0369: 	differ in two areas, how they load a class and how they invoke methods
1:eac0369: 	of the generated class.
1:eac0369: 
1:eac0369:     <P>
1:eac0369: 	This class manages a hash table of loaded generated classes and
1:eac0369: 	their GeneratedClass objects.  A loaded class may be referenced
1:eac0369: 	multiple times -- each class has a reference count associated
1:eac0369: 	with it.  When a load request arrives, if the class has already
1:eac0369: 	been loaded, its ref count is incremented.  For a remove request,
1:eac0369: 	the ref count is decremented unless it is the last reference,
1:eac0369: 	in which case the class is removed.  This is transparent to users.
1:eac0369: 
1:eac0369: 	@see org.apache.derby.iapi.services.loader.ClassFactory
1:eac0369: */
1:eac0369: 
1:2542f1d: abstract class DatabaseClasses
1:eac0369: 	implements ClassFactory, ModuleControl
1:eac0369: {
1:eac0369: 	/*
1:eac0369: 	** Fields
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	private	ClassInspector	classInspector;
1:eac0369: 
1:eac0369: 	private UpdateLoader		applicationLoader;
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Constructor
1:eac0369: 	*/
1:eac0369: 
1:2542f1d: 	DatabaseClasses() {
3:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Public methods of ModuleControl
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	public void boot(boolean create, Properties startParams)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 
1:c8603c4: 		classInspector = makeClassInspector( this );
1:eac0369: 
1:eac0369: 		//
1:eac0369: 		//The ClassFactory runs per service (database) mode (booted as a service module after AccessFactory).
1:eac0369: 		//If the code that booted
1:eac0369: 		//us needs a per-database classpath then they pass in the classpath using
1:eac0369: 		//the runtime property BOOT_DB_CLASSPATH in startParams
1:eac0369: 
1:eac0369: 
1:eac0369: 		String classpath = null;
1:eac0369: 		if (startParams != null) {
1:eac0369: 			classpath = startParams.getProperty(Property.BOOT_DB_CLASSPATH);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (classpath != null) {
1:eac0369: 			applicationLoader = new UpdateLoader(classpath, this, true,
1:eac0369:                                                  true);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 	public void stop() {
1:eac0369: 		if (applicationLoader != null)
1:eac0369: 			applicationLoader.close();
1:eac0369: 	}
1:eac0369: 
1:c8603c4:     /**
1:4e5e965:      * For creating the class inspector.
1:c8603c4:      */
1:c8603c4:     protected   ClassInspector  makeClassInspector( DatabaseClasses dc )
1:c8603c4:     {
1:c8603c4:         return new ClassInspector( dc );
1:c8603c4:     }
1:c8603c4: 
1:eac0369: 	/*
1:eac0369: 	**	Public methods of ClassFactory
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Here we load the newly added class now, rather than waiting for the
1:eac0369: 		findGeneratedClass(). Thus we are assuming that the class is going
1:eac0369: 		to be used sometime soon. Delaying the load would mean storing the class
1:eac0369: 		data in a file, this wastes cycles and compilcates the cleanup.
1:eac0369: 
1:eac0369: 		@see ClassFactory#loadGeneratedClass
1:eac0369: 
1:eac0369: 		@exception	StandardException Class format is bad.
1:eac0369: 	*/
1:eac0369: 	public final GeneratedClass loadGeneratedClass(String fullyQualifiedName, ByteArray classDump)
1:a9b4b8d: 		throws StandardException {
1:eac0369: 
1:eac0369: 
1:eac0369: 			try {
1:eac0369: 
1:eac0369: 
1:eac0369: 				return loadGeneratedClassFromData(fullyQualifiedName, classDump);
1:eac0369: 
1:eac0369: 			} catch (LinkageError le) {
1:eac0369: 
1:eac0369: 			    WriteClassFile(fullyQualifiedName, classDump, le);
1:eac0369: 
1:eac0369: 				throw StandardException.newException(SQLState.GENERATED_CLASS_LINKAGE_ERROR,
1:eac0369: 							le, fullyQualifiedName);
1:eac0369: 
1:eac0369:     		} catch (VirtualMachineError vme) { // these may be beyond saving, but fwiw
1:eac0369: 
1:eac0369: 			    WriteClassFile(fullyQualifiedName, classDump, vme);
1:eac0369: 
1:eac0369: 			    throw vme;
1:eac0369: 		    }
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369:     private static void WriteClassFile(String fullyQualifiedName, ByteArray bytecode, Throwable t) {
1:eac0369: 
1:eac0369: 		// get the un-qualified name and add the extension
1:eac0369:         int lastDot = fullyQualifiedName.lastIndexOf((int)'.');
1:eac0369:         String filename = fullyQualifiedName.substring(lastDot+1,fullyQualifiedName.length()).concat(".class");
1:eac0369: 
1:56c1dc2: 		Object env = getMonitor().getEnvironment();
1:eac0369: 		File dir = env instanceof File ? (File) env : null;
1:eac0369: 
1:8d4d087:         final File classFile = new File(dir, filename);
1:eac0369: 
1:eac0369: 		// find the error stream
1:eac0369: 		HeaderPrintWriter errorStream = Monitor.getStream();
1:eac0369: 
1:eac0369: 		try {
1:44454b6:             FileOutputStream fis;
1:44454b6:             try {
1:a15a470:                 fis = AccessController.doPrivileged(
1:a15a470:                         new PrivilegedExceptionAction<FileOutputStream>() {
1:a15a470:                             public FileOutputStream run() throws IOException {
1:44454b6:                                 return new FileOutputStream(classFile);
1:44454b6:                             }
1:44454b6:                         });
1:44454b6:             } catch (PrivilegedActionException pae) {
1:44454b6:                 throw (IOException) pae.getCause();
1:44454b6:             }
1:eac0369: 			fis.write(bytecode.getArray(),
1:eac0369: 				bytecode.getOffset(), bytecode.getLength());
1:eac0369: 			fis.flush();
1:eac0369: 			if (t!=null) {				
1:eac0369: 				errorStream.printlnWithHeader(MessageService.getTextMessage(MessageId.CM_WROTE_CLASS_FILE, fullyQualifiedName, classFile, t));
1:eac0369: 			}
1:eac0369: 			fis.close();
1:eac0369: 		} catch (IOException e) {
1:eac0369: 			if (SanityManager.DEBUG)
1:44454b6: 				SanityManager.THROWASSERT("Unable to write .class file", e);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public ClassInspector getClassInspector() {
1:eac0369: 		return classInspector;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	public final Class loadApplicationClass(String className)
1:eac0369: 		throws ClassNotFoundException {
1:4657698:         
1:4657698:         if (className.startsWith("org.apache.derby.")) {
1:4657698:             // Assume this is an engine class, if so
1:4657698:             // try to load from this class loader,
1:4657698:             // this ensures in strange class loader
1:4657698:             // environments we do not get ClassCastExceptions
1:4657698:             // when an engine class is loaded through a different
1:4657698:             // class loader to the rest of the engine.
1:4657698:             try {
1:4657698:                 return Class.forName(className);
1:4657698:             } catch (ClassNotFoundException cnfe)
1:4657698:             {
1:4657698:                 // fall through to the code below,
1:4657698:                 // could be client or tools class
1:4657698:                 // in a different loader.
1:4657698:             }
1:4657698:         }
1:4657698:  
1:2542f1d: 		Throwable loadError;
1:2542f1d: 		try {
1:eac0369: 			try {
1:2542f1d: 				return loadClassNotInDatabaseJar(className);
1:2542f1d: 			} catch (ClassNotFoundException cnfe) {
1:2542f1d: 				if (applicationLoader == null)
1:2542f1d: 					throw cnfe;
1:2542f1d: 				Class c = applicationLoader.loadClass(className, true);
1:2542f1d: 				if (c == null)
1:2542f1d: 					throw cnfe;
1:2542f1d: 				return c;
1:2542f1d: 			}
1:eac0369: 		}
1:2542f1d: 		catch (SecurityException se)
1:2542f1d: 		{
1:2542f1d: 			// Thrown if the class has been comprimised in some
1:2542f1d: 			// way, e.g. modified in a signed jar.
1:2542f1d: 			loadError = se;	
1:2542f1d: 		}
1:2542f1d: 		catch (LinkageError le)
1:2542f1d: 		{
1:2542f1d: 			// some error linking the jar, again could
1:2542f1d: 			// be malicious code inserted into a jar.
1:2542f1d: 			loadError = le;	
1:2542f1d: 		}
1:2542f1d: 		throw new ClassNotFoundException(className + " : " + loadError.getMessage());
1:eac0369: 	}
1:2542f1d: 	
1:2542f1d: 	abstract Class loadClassNotInDatabaseJar(String className)
1:2542f1d: 		throws ClassNotFoundException;
1:eac0369: 
1:eac0369: 	public final Class loadApplicationClass(ObjectStreamClass classDescriptor)
1:eac0369: 		throws ClassNotFoundException {
1:eac0369: 		return loadApplicationClass(classDescriptor.getName());
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public boolean isApplicationClass(Class theClass) {
1:eac0369: 
1:eac0369: 		return theClass.getClassLoader()
1:eac0369: 			instanceof JarLoader;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public void notifyModifyJar(boolean reload) throws StandardException  {
1:eac0369: 		if (applicationLoader != null) {
1:eac0369: 			applicationLoader.modifyJar(reload);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Notify the class manager that the classpath has been modified.
1:eac0369: 
1:eac0369: 		@exception StandardException thrown on error
1:eac0369: 	*/
1:eac0369: 	public void notifyModifyClasspath(String classpath) throws StandardException {
1:eac0369: 
1:eac0369: 		if (applicationLoader != null) {
1:eac0369: 			applicationLoader.modifyClasspath(classpath);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	public int getClassLoaderVersion() {
1:eac0369: 		if (applicationLoader != null) {
1:eac0369: 			return applicationLoader.getClassLoaderVersion();
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return -1;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Class specific methods
1:eac0369: 	*/
1:eac0369: 	
1:eac0369: 	/*
1:eac0369: 	** Keep track of loaded generated classes and their GeneratedClass objects.
1:eac0369: 	*/
1:eac0369: 
1:7a92d1f: 	abstract LoadedGeneratedClass loadGeneratedClassFromData(String fullyQualifiedName, ByteArray classDump); 
1:56c1dc2:     
1:56c1dc2:     /**
1:56c1dc2:      * Privileged Monitor lookup. Must be private so that user code
1:56c1dc2:      * can't call this entry point.
1:56c1dc2:      */
1:56c1dc2:     private  static  ModuleFactory  getMonitor()
1:56c1dc2:     {
1:56c1dc2:         return AccessController.doPrivileged
1:56c1dc2:             (
1:56c1dc2:              new PrivilegedAction<ModuleFactory>()
1:56c1dc2:              {
1:56c1dc2:                  public ModuleFactory run()
1:56c1dc2:                  {
1:56c1dc2:                      return Monitor.getMonitor();
1:56c1dc2:                  }
1:56c1dc2:              }
1:56c1dc2:              );
1:56c1dc2:     }
1:56c1dc2: 
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:56c1dc2
/////////////////////////////////////////////////////////////////////////
1: import java.security.PrivilegedAction;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.monitor.ModuleFactory;
/////////////////////////////////////////////////////////////////////////
1: 		Object env = getMonitor().getEnvironment();
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Privileged Monitor lookup. Must be private so that user code
1:      * can't call this entry point.
1:      */
1:     private  static  ModuleFactory  getMonitor()
1:     {
1:         return AccessController.doPrivileged
1:             (
1:              new PrivilegedAction<ModuleFactory>()
1:              {
1:                  public ModuleFactory run()
1:                  {
1:                      return Monitor.getMonitor();
1:                  }
1:              }
1:              );
1:     }
1: 
commit:a15a470
/////////////////////////////////////////////////////////////////////////
1:                 fis = AccessController.doPrivileged(
1:                         new PrivilegedExceptionAction<FileOutputStream>() {
1:                             public FileOutputStream run() throws IOException {
commit:c8603c4
/////////////////////////////////////////////////////////////////////////
1: 		classInspector = makeClassInspector( this );
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * For creating the class inspector. On Java 5 and higher, we have a more
0:      * capable class inspector.
1:      */
1:     protected   ClassInspector  makeClassInspector( DatabaseClasses dc )
1:     {
1:         return new ClassInspector( dc );
1:     }
1: 
commit:93fea34
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:8d4d087
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         final File classFile = new File(dir, filename);
commit:4e5e965
/////////////////////////////////////////////////////////////////////////
1:      * For creating the class inspector.
commit:6790718
/////////////////////////////////////////////////////////////////////////
1: import java.io.ObjectStreamClass;
1: import java.util.Properties;
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.reference.MessageId;
1: import org.apache.derby.iapi.reference.Property;
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.services.i18n.MessageService;
0: import org.apache.derby.iapi.services.io.FileUtil;
1: import org.apache.derby.iapi.services.loader.ClassFactory;
1: import org.apache.derby.iapi.services.loader.ClassInspector;
1: import org.apache.derby.iapi.services.loader.GeneratedClass;
1: import org.apache.derby.iapi.services.monitor.ModuleControl;
1: import org.apache.derby.iapi.services.monitor.Monitor;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.services.stream.HeaderPrintWriter;
1: import org.apache.derby.iapi.util.ByteArray;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:44454b6
/////////////////////////////////////////////////////////////////////////
1: import java.security.AccessController;
1: import java.security.PrivilegedActionException;
1: import java.security.PrivilegedExceptionAction;
/////////////////////////////////////////////////////////////////////////
0: 		final File classFile = FileUtil.newFile(dir,filename);
1:             FileOutputStream fis;
1:             try {
0:                 fis = (FileOutputStream) AccessController.doPrivileged(
0:                         new PrivilegedExceptionAction() {
0:                             public Object run() throws IOException {
1:                                 return new FileOutputStream(classFile);
1:                             }
1:                         });
1:             } catch (PrivilegedActionException pae) {
1:                 throw (IOException) pae.getCause();
1:             }
/////////////////////////////////////////////////////////////////////////
1: 				SanityManager.THROWASSERT("Unable to write .class file", e);
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:4657698
/////////////////////////////////////////////////////////////////////////
1:         
1:         if (className.startsWith("org.apache.derby.")) {
1:             // Assume this is an engine class, if so
1:             // try to load from this class loader,
1:             // this ensures in strange class loader
1:             // environments we do not get ClassCastExceptions
1:             // when an engine class is loaded through a different
1:             // class loader to the rest of the engine.
1:             try {
1:                 return Class.forName(className);
1:             } catch (ClassNotFoundException cnfe)
1:             {
1:                 // fall through to the code below,
1:                 // could be client or tools class
1:                 // in a different loader.
1:             }
1:         }
1:  
commit:2542f1d
/////////////////////////////////////////////////////////////////////////
1: abstract class DatabaseClasses
/////////////////////////////////////////////////////////////////////////
1: 	DatabaseClasses() {
/////////////////////////////////////////////////////////////////////////
1: 		Throwable loadError;
1: 			try {
1: 				return loadClassNotInDatabaseJar(className);
1: 			} catch (ClassNotFoundException cnfe) {
1: 				if (applicationLoader == null)
1: 					throw cnfe;
1: 				Class c = applicationLoader.loadClass(className, true);
1: 				if (c == null)
1: 					throw cnfe;
1: 				return c;
1: 			}
1: 		catch (SecurityException se)
1: 		{
1: 			// Thrown if the class has been comprimised in some
1: 			// way, e.g. modified in a signed jar.
1: 			loadError = se;	
1: 		}
1: 		catch (LinkageError le)
1: 		{
1: 			// some error linking the jar, again could
1: 			// be malicious code inserted into a jar.
1: 			loadError = le;	
1: 		}
1: 		throw new ClassNotFoundException(className + " : " + loadError.getMessage());
1: 	
1: 	abstract Class loadClassNotInDatabaseJar(String className)
1: 		throws ClassNotFoundException;
commit:7a92d1f
/////////////////////////////////////////////////////////////////////////
0: 	Class loadClassNotInDatabaseJar(String className) throws ClassNotFoundException {
/////////////////////////////////////////////////////////////////////////
1: 	abstract LoadedGeneratedClass loadGeneratedClassFromData(String fullyQualifiedName, ByteArray classDump); 
commit:a9b4b8d
/////////////////////////////////////////////////////////////////////////
0: 	public ByteArray buildSpecificFactory(String className, String factoryName)
1: 		throws StandardException {
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.services.reflect.DatabaseClasses
1: 
0:    Copyright 1998, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:1f9b9c4
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.services.reflect
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.services.reflect;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
0: import org.apache.derby.iapi.services.loader.ClassFactory;
0: import org.apache.derby.iapi.services.loader.GeneratedClass;
0: import org.apache.derby.iapi.services.loader.ClassInspector;
1: 
0: import org.apache.derby.iapi.services.monitor.ModuleControl;
0: import org.apache.derby.iapi.services.monitor.ModuleSupportable;
0: import org.apache.derby.iapi.services.monitor.Monitor;
1: 
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.services.property.PropertyUtil;
1: 
0: import org.apache.derby.iapi.services.stream.HeaderPrintWriter;
0: import org.apache.derby.iapi.services.monitor.Monitor;
1: 
0: import org.apache.derby.iapi.services.compiler.*;
0: import java.lang.reflect.Modifier;
0: import org.apache.derby.iapi.sql.compile.CodeGeneration;
1: 
0: import org.apache.derby.iapi.util.ByteArray;
0: import org.apache.derby.iapi.services.io.FileUtil;
0: import org.apache.derby.iapi.services.i18n.MessageService;
0: import org.apache.derby.iapi.reference.Property;
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.reference.MessageId;
0: import org.apache.derby.iapi.reference.ClassName;
1: 
0: import java.util.Properties;
0: import java.util.Hashtable;
1: 
0: import java.io.ObjectStreamClass;
1: import java.io.File;
1: import java.io.FileOutputStream;
1: import java.io.IOException;
0: import java.io.Serializable;
1: 
1: /**
1: 
1:     An abstract implementation of the ClassFactory. This package can
1: 	be extended to fully implement a ClassFactory. Implementations can
1: 	differ in two areas, how they load a class and how they invoke methods
1: 	of the generated class.
1: 
1:     <P>
1: 	This class manages a hash table of loaded generated classes and
1: 	their GeneratedClass objects.  A loaded class may be referenced
1: 	multiple times -- each class has a reference count associated
1: 	with it.  When a load request arrives, if the class has already
1: 	been loaded, its ref count is incremented.  For a remove request,
1: 	the ref count is decremented unless it is the last reference,
1: 	in which case the class is removed.  This is transparent to users.
1: 
1: 	@see org.apache.derby.iapi.services.loader.ClassFactory
1: */
1: 
0: public abstract class DatabaseClasses
1: 	implements ClassFactory, ModuleControl
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
1: 	/*
1: 	** Fields
1: 	*/
1: 
1: 	private	ClassInspector	classInspector;
0: 	private JavaFactory		javaFactory;
1: 
1: 	private UpdateLoader		applicationLoader;
1: 
1: 	/*
1: 	** Constructor
1: 	*/
1: 
0: 	public DatabaseClasses() {
1: 	}
1: 
1: 	/*
1: 	** Public methods of ModuleControl
1: 	*/
1: 
1: 	public void boot(boolean create, Properties startParams)
1: 		throws StandardException
1: 	{
1: 
0: 		classInspector = new ClassInspector(this);
1: 
1: 		//
1: 		//The ClassFactory runs per service (database) mode (booted as a service module after AccessFactory).
1: 		//If the code that booted
1: 		//us needs a per-database classpath then they pass in the classpath using
1: 		//the runtime property BOOT_DB_CLASSPATH in startParams
1: 
1: 
1: 		String classpath = null;
1: 		if (startParams != null) {
1: 			classpath = startParams.getProperty(Property.BOOT_DB_CLASSPATH);
1: 		}
1: 
1: 		if (classpath != null) {
1: 			applicationLoader = new UpdateLoader(classpath, this, true,
1:                                                  true);
1: 		}
1: 
0: 		javaFactory = (JavaFactory) org.apache.derby.iapi.services.monitor.Monitor.startSystemModule(org.apache.derby.iapi.reference.Module.JavaFactory);
1: 	}
1: 
1: 
1: 
1: 	public void stop() {
1: 		if (applicationLoader != null)
1: 			applicationLoader.close();
1: 	}
1: 
1: 	/*
1: 	**	Public methods of ClassFactory
1: 	*/
1: 
1: 	/**
1: 		Here we load the newly added class now, rather than waiting for the
1: 		findGeneratedClass(). Thus we are assuming that the class is going
1: 		to be used sometime soon. Delaying the load would mean storing the class
1: 		data in a file, this wastes cycles and compilcates the cleanup.
1: 
1: 		@see ClassFactory#loadGeneratedClass
1: 
1: 		@exception	StandardException Class format is bad.
1: 	*/
1: 	public final GeneratedClass loadGeneratedClass(String fullyQualifiedName, ByteArray classDump)
0: 		throws StandardException {
1: 
1: 
1: 			try {
1: 
1: 
1: 				return loadGeneratedClassFromData(fullyQualifiedName, classDump);
1: 
1: 			} catch (LinkageError le) {
1: 
1: 			    WriteClassFile(fullyQualifiedName, classDump, le);
1: 
1: 				throw StandardException.newException(SQLState.GENERATED_CLASS_LINKAGE_ERROR,
1: 							le, fullyQualifiedName);
1: 
1:     		} catch (VirtualMachineError vme) { // these may be beyond saving, but fwiw
1: 
1: 			    WriteClassFile(fullyQualifiedName, classDump, vme);
1: 
1: 			    throw vme;
1: 		    }
1: 
1: 	}
1: 
1:     private static void WriteClassFile(String fullyQualifiedName, ByteArray bytecode, Throwable t) {
1: 
1: 		// get the un-qualified name and add the extension
1:         int lastDot = fullyQualifiedName.lastIndexOf((int)'.');
1:         String filename = fullyQualifiedName.substring(lastDot+1,fullyQualifiedName.length()).concat(".class");
1: 
0: 		Object env = Monitor.getMonitor().getEnvironment();
1: 		File dir = env instanceof File ? (File) env : null;
1: 
0: 		File classFile = FileUtil.newFile(dir,filename);
1: 
1: 		// find the error stream
1: 		HeaderPrintWriter errorStream = Monitor.getStream();
1: 
1: 		try {
0: 			FileOutputStream fis = new FileOutputStream(classFile);
1: 			fis.write(bytecode.getArray(),
1: 				bytecode.getOffset(), bytecode.getLength());
1: 			fis.flush();
1: 			if (t!=null) {				
1: 				errorStream.printlnWithHeader(MessageService.getTextMessage(MessageId.CM_WROTE_CLASS_FILE, fullyQualifiedName, classFile, t));
1: 			}
1: 			fis.close();
1: 		} catch (IOException e) {
1: 			if (SanityManager.DEBUG)
0: 				SanityManager.THROWASSERT("Unable to write .class file");
1: 		}
1: 	}
1: 
1: 	public ClassInspector getClassInspector() {
1: 		return classInspector;
1: 	}
1: 
1: 
1: 	public final Class loadApplicationClass(String className)
1: 		throws ClassNotFoundException {
1: 
1: 		try {
0: 			return loadClassNotInDatabaseJar(className);
0: 		} catch (ClassNotFoundException cnfe) {
0: 			if (applicationLoader == null)
0: 				throw cnfe;
0: 			Class c = applicationLoader.loadClass(className, true);
0: 			if (c == null)
0: 				throw cnfe;
0: 			return c;
1: 		}
1: 	}
1: 
0: 	protected Class loadClassNotInDatabaseJar(String className) throws ClassNotFoundException {
0: 		return Class.forName(className);
1: 	}
1: 
1: 
1: 	public final Class loadApplicationClass(ObjectStreamClass classDescriptor)
1: 		throws ClassNotFoundException {
1: 		return loadApplicationClass(classDescriptor.getName());
1: 	}
1: 
1: 	public boolean isApplicationClass(Class theClass) {
1: 
1: 		return theClass.getClassLoader()
1: 			instanceof JarLoader;
1: 	}
1: 
1: 	public void notifyModifyJar(boolean reload) throws StandardException  {
1: 		if (applicationLoader != null) {
1: 			applicationLoader.modifyJar(reload);
1: 		}
1: 	}
1: 
1: 	/**
1: 		Notify the class manager that the classpath has been modified.
1: 
1: 		@exception StandardException thrown on error
1: 	*/
1: 	public void notifyModifyClasspath(String classpath) throws StandardException {
1: 
1: 		if (applicationLoader != null) {
1: 			applicationLoader.modifyClasspath(classpath);
1: 		}
1: 	}
1: 
1: 
1: 	public int getClassLoaderVersion() {
1: 		if (applicationLoader != null) {
1: 			return applicationLoader.getClassLoaderVersion();
1: 		}
1: 
1: 		return -1;
1: 	}
1: 
0: 	public ByteArray buildSpecificFactory(String className, String factoryName) {
1: 
0: 		ClassBuilder cb = javaFactory.newClassBuilder(this, CodeGeneration.GENERATED_PACKAGE_PREFIX,
0: 			Modifier.PUBLIC | Modifier.FINAL, factoryName, "org.apache.derby.impl.services.reflect.GCInstanceFactory");
1: 
0: 		MethodBuilder constructor = cb.newConstructorBuilder(Modifier.PUBLIC);
1: 
0: 		constructor.callSuper();
0: 		constructor.methodReturn();
0: 		constructor.complete();
0: 		constructor = null;
1: 
0: 		MethodBuilder noArg = cb.newMethodBuilder(Modifier.PUBLIC, ClassName.GeneratedByteCode, "getNewInstance");
0: 		noArg.pushNewStart(className);
0: 		noArg.pushNewComplete(0);
0: 		noArg.methodReturn();
0: 		noArg.complete();
0: 		noArg = null;
1: 
0: 		return cb.getClassBytecode();
1: 	}
1: 
1: 	/*
1: 	** Class specific methods
1: 	*/
1: 	
1: 	/*
1: 	** Keep track of loaded generated classes and their GeneratedClass objects.
1: 	*/
1: 
0: 	protected abstract LoadedGeneratedClass loadGeneratedClassFromData(String fullyQualifiedName, ByteArray classDump); 
1: }
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.services.reflect
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.services.reflect;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.services.loader.ClassFactory;
0: import org.apache.derby.iapi.services.loader.GeneratedClass;
0: import org.apache.derby.iapi.services.loader.ClassInspector;
0: 
0: import org.apache.derby.iapi.services.monitor.ModuleControl;
0: import org.apache.derby.iapi.services.monitor.ModuleSupportable;
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.services.property.PropertyUtil;
0: 
0: import org.apache.derby.iapi.services.stream.HeaderPrintWriter;
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: 
0: import org.apache.derby.iapi.services.compiler.*;
0: import java.lang.reflect.Modifier;
0: import org.apache.derby.iapi.sql.compile.CodeGeneration;
0: 
0: import org.apache.derby.iapi.util.ByteArray;
0: import org.apache.derby.iapi.services.io.FileUtil;
0: import org.apache.derby.iapi.services.i18n.MessageService;
0: import org.apache.derby.iapi.reference.Property;
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.reference.MessageId;
0: import org.apache.derby.iapi.reference.ClassName;
0: 
0: import java.util.Properties;
0: import java.util.Hashtable;
0: 
0: import java.io.ObjectStreamClass;
0: import java.io.File;
0: import java.io.FileOutputStream;
0: import java.io.IOException;
0: import java.io.Serializable;
0: 
0: /**
0: 
0:     An abstract implementation of the ClassFactory. This package can
0: 	be extended to fully implement a ClassFactory. Implementations can
0: 	differ in two areas, how they load a class and how they invoke methods
0: 	of the generated class.
0: 
0:     <P>
0: 	This class manages a hash table of loaded generated classes and
0: 	their GeneratedClass objects.  A loaded class may be referenced
0: 	multiple times -- each class has a reference count associated
0: 	with it.  When a load request arrives, if the class has already
0: 	been loaded, its ref count is incremented.  For a remove request,
0: 	the ref count is decremented unless it is the last reference,
0: 	in which case the class is removed.  This is transparent to users.
0: 
0: 	@see org.apache.derby.iapi.services.loader.ClassFactory
0: */
0: 
0: public abstract class DatabaseClasses
0: 	implements ClassFactory, ModuleControl
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
0: 	/*
0: 	** Fields
0: 	*/
0: 
0: 	private	ClassInspector	classInspector;
0: 	private JavaFactory		javaFactory;
0: 
0: 	private UpdateLoader		applicationLoader;
0: 
0: 	/*
0: 	** Constructor
0: 	*/
0: 
0: 	public DatabaseClasses() {
0: 	}
0: 
0: 	/*
0: 	** Public methods of ModuleControl
0: 	*/
0: 
0: 	public void boot(boolean create, Properties startParams)
0: 		throws StandardException
0: 	{
0: 
0: 		classInspector = new ClassInspector(this);
0: 
0: 		//
0: 		//The ClassFactory runs per service (database) mode (booted as a service module after AccessFactory).
0: 		//If the code that booted
0: 		//us needs a per-database classpath then they pass in the classpath using
0: 		//the runtime property BOOT_DB_CLASSPATH in startParams
0: 
0: 
0: 		String classpath = null;
0: 		if (startParams != null) {
0: 			classpath = startParams.getProperty(Property.BOOT_DB_CLASSPATH);
0: 		}
0: 
0: 		if (classpath != null) {
0: 			applicationLoader = new UpdateLoader(classpath, this, true,
0:                                                  true);
0: 		}
0: 
0: 		javaFactory = (JavaFactory) org.apache.derby.iapi.services.monitor.Monitor.startSystemModule(org.apache.derby.iapi.reference.Module.JavaFactory);
0: 	}
0: 
0: 
0: 
0: 	public void stop() {
0: 		if (applicationLoader != null)
0: 			applicationLoader.close();
0: 	}
0: 
0: 	/*
0: 	**	Public methods of ClassFactory
0: 	*/
0: 
0: 	/**
0: 		Here we load the newly added class now, rather than waiting for the
0: 		findGeneratedClass(). Thus we are assuming that the class is going
0: 		to be used sometime soon. Delaying the load would mean storing the class
0: 		data in a file, this wastes cycles and compilcates the cleanup.
0: 
0: 		@see ClassFactory#loadGeneratedClass
0: 
0: 		@exception	StandardException Class format is bad.
0: 	*/
0: 	public final GeneratedClass loadGeneratedClass(String fullyQualifiedName, ByteArray classDump)
0: 		throws StandardException {
0: 
0: 
0: 			try {
0: 
0: 
0: 				return loadGeneratedClassFromData(fullyQualifiedName, classDump);
0: 
0: 			} catch (LinkageError le) {
0: 
0: 			    WriteClassFile(fullyQualifiedName, classDump, le);
0: 
0: 				throw StandardException.newException(SQLState.GENERATED_CLASS_LINKAGE_ERROR,
0: 							le, fullyQualifiedName);
0: 
0:     		} catch (VirtualMachineError vme) { // these may be beyond saving, but fwiw
0: 
0: 			    WriteClassFile(fullyQualifiedName, classDump, vme);
0: 
0: 			    throw vme;
0: 		    }
0: 
0: 	}
0: 
0:     private static void WriteClassFile(String fullyQualifiedName, ByteArray bytecode, Throwable t) {
0: 
0: 		// get the un-qualified name and add the extension
0:         int lastDot = fullyQualifiedName.lastIndexOf((int)'.');
0:         String filename = fullyQualifiedName.substring(lastDot+1,fullyQualifiedName.length()).concat(".class");
0: 
0: 		Object env = Monitor.getMonitor().getEnvironment();
0: 		File dir = env instanceof File ? (File) env : null;
0: 
0: 		File classFile = FileUtil.newFile(dir,filename);
0: 
0: 		// find the error stream
0: 		HeaderPrintWriter errorStream = Monitor.getStream();
0: 
0: 		try {
0: 			FileOutputStream fis = new FileOutputStream(classFile);
0: 			fis.write(bytecode.getArray(),
0: 				bytecode.getOffset(), bytecode.getLength());
0: 			fis.flush();
0: 			if (t!=null) {				
0: 				errorStream.printlnWithHeader(MessageService.getTextMessage(MessageId.CM_WROTE_CLASS_FILE, fullyQualifiedName, classFile, t));
0: 			}
0: 			fis.close();
0: 		} catch (IOException e) {
0: 			if (SanityManager.DEBUG)
0: 				SanityManager.THROWASSERT("Unable to write .class file");
0: 		}
0: 	}
0: 
0: 	public ClassInspector getClassInspector() {
0: 		return classInspector;
0: 	}
0: 
0: 
0: 	public final Class loadApplicationClass(String className)
0: 		throws ClassNotFoundException {
0: 
0: 		try {
0: 			return loadClassNotInDatabaseJar(className);
0: 		} catch (ClassNotFoundException cnfe) {
0: 			if (applicationLoader == null)
0: 				throw cnfe;
0: 			Class c = applicationLoader.loadClass(className, true);
0: 			if (c == null)
0: 				throw cnfe;
0: 			return c;
0: 		}
0: 	}
0: 
0: 	protected Class loadClassNotInDatabaseJar(String className) throws ClassNotFoundException {
0: 		return Class.forName(className);
0: 	}
0: 
0: 
0: 	public final Class loadApplicationClass(ObjectStreamClass classDescriptor)
0: 		throws ClassNotFoundException {
0: 		return loadApplicationClass(classDescriptor.getName());
0: 	}
0: 
0: 	public boolean isApplicationClass(Class theClass) {
0: 
0: 		return theClass.getClassLoader()
0: 			instanceof JarLoader;
0: 	}
0: 
0: 	public void notifyModifyJar(boolean reload) throws StandardException  {
0: 		if (applicationLoader != null) {
0: 			applicationLoader.modifyJar(reload);
0: 		}
0: 	}
0: 
0: 	/**
0: 		Notify the class manager that the classpath has been modified.
0: 
0: 		@exception StandardException thrown on error
0: 	*/
0: 	public void notifyModifyClasspath(String classpath) throws StandardException {
0: 
0: 		if (applicationLoader != null) {
0: 			applicationLoader.modifyClasspath(classpath);
0: 		}
0: 	}
0: 
0: 
0: 	public int getClassLoaderVersion() {
0: 		if (applicationLoader != null) {
0: 			return applicationLoader.getClassLoaderVersion();
0: 		}
0: 
0: 		return -1;
0: 	}
0: 
0: 	public ByteArray buildSpecificFactory(String className, String factoryName) {
0: 
0: 		ClassBuilder cb = javaFactory.newClassBuilder(this, CodeGeneration.GENERATED_PACKAGE_PREFIX,
0: 			Modifier.PUBLIC | Modifier.FINAL, factoryName, "org.apache.derby.impl.services.reflect.GCInstanceFactory");
0: 
0: 		MethodBuilder constructor = cb.newConstructorBuilder(Modifier.PUBLIC);
0: 
0: 		constructor.callSuper();
0: 		constructor.methodReturn();
0: 		constructor.complete();
0: 		constructor = null;
0: 
0: 		MethodBuilder noArg = cb.newMethodBuilder(Modifier.PUBLIC, ClassName.GeneratedByteCode, "getNewInstance");
0: 		noArg.pushNewStart(className);
0: 		noArg.pushNewComplete(0);
0: 		noArg.methodReturn();
0: 		noArg.complete();
0: 		noArg = null;
0: 
0: 		return cb.getClassBytecode();
0: 	}
0: 
0: 	/*
0: 	** Class specific methods
0: 	*/
0: 	
0: 	/*
0: 	** Keep track of loaded generated classes and their GeneratedClass objects.
0: 	*/
0: 
0: 	protected abstract LoadedGeneratedClass loadGeneratedClassFromData(String fullyQualifiedName, ByteArray classDump); 
0: }
============================================================================