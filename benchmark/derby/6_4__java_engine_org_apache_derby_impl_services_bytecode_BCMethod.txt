2:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.services.bytecode.BCMethod
1:345de35: 
1:93fea34:    Licensed to the Apache Software Foundation (ASF) under one or more
1:93fea34:    contributor license agreements.  See the NOTICE file distributed with
1:93fea34:    this work for additional information regarding copyright ownership.
1:93fea34:    The ASF licenses this file to you under the Apache License, Version 2.0
1:93fea34:    (the "License"); you may not use this file except in compliance with
1:93fea34:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
36:eac0369: 
5:eac0369:  */
1:ee1cc94: 
1:eac0369: package org.apache.derby.impl.services.bytecode;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.compiler.ClassBuilder;
1:eac0369: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1:eac0369: import org.apache.derby.iapi.services.classfile.ClassFormatOutput;
1:eac0369: import org.apache.derby.iapi.services.compiler.LocalField;
1:eac0369: import org.apache.derby.iapi.services.classfile.ClassHolder;
1:eac0369: import org.apache.derby.iapi.services.classfile.ClassMember;
1:eac0369: 
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.classfile.VMDescriptor;
1:eac0369: import org.apache.derby.iapi.services.classfile.VMOpcode;
1:eac0369: 
1:eac0369: import java.lang.reflect.Modifier;
1:eac0369: import java.util.Vector;
1:eac0369: import java.io.IOException;
1:eac0369: 
1:d30bf1c: /**
1:eac0369:  * MethodBuilder is used to piece together a method when
1:eac0369:  * building a java class definition.
1:eac0369:  * <p>
1:eac0369:  * When a method is first created, it has:
1:eac0369:  * <ul>
1:eac0369:  * <li> a return type
1:eac0369:  * <li> modifiers
1:eac0369:  * <li> a name
1:eac0369:  * <li> an empty parameter list
1:eac0369:  * <li> an empty throws list
1:eac0369:  * <li> an empty statement block
1:eac0369:  * </ul>
1:eac0369:  * <p>
1:eac0369:  * MethodBuilder implementations are required to supply a way for
1:eac0369:  * Statements and Expressions to give them code.  Most typically, they may have
1:eac0369:  * a stream to which their contents writes the code that is of
1:eac0369:  * the type to satisfy what the contents represent.
1:eac0369:  * MethodBuilder implementations also have to have a way to supply
1:eac0369:  * ClassBuilders with their code, that satisfies the type of class
1:eac0369:  * builder they are implemented with.  This is implementation-dependent,
1:eac0369:  * so ClassBuilders, MethodBuilders, Statements, and Expressions all have
1:eac0369:  * to be of the same implementation in order to interact to generate a class.
1:eac0369:  * <p>
1:eac0369:  * Method Builder implementation for generating bytecode.
1:eac0369:  *
1:eac0369:  */
1:4549ad4: class BCMethod implements MethodBuilder {
1:ee1cc94:     
1:ee1cc94:     /**
1:ee1cc94:      * Code length at which to split into sub-methods.
1:ee1cc94:      * Normally set to the maximim code length the
1:ee1cc94:      * JVM can support, but for testing the split code
1:ee1cc94:      * it can be reduced so that the standard tests
1:ee1cc94:      * cause some splitting. Tested with value set to 2000.
1:ee1cc94:      */
1:ee1cc94:     static final int CODE_SPLIT_LENGTH = VMOpcode.MAX_CODE_LENGTH;
1:8aff1cd:     
1:eac0369: 	final BCClass		cb;
1:eac0369: 	protected final ClassHolder modClass; // the class it is in (modifiable fmt)
1:9c5e195: 	final String myReturnType;
1:d30bf1c: 	
1:d30bf1c: 	/**
1:d30bf1c: 	 * The original name of the method, this
1:d30bf1c: 	 * represents how any user would call this method.
1:d30bf1c: 	 */
1:d30bf1c: 	private final String myName;
1:eac0369: 
1:ee1cc94:     /**
1:ee1cc94:      * Fast access for the parametes, will be null
1:ee1cc94:      * if the method has no parameters.
1:ee1cc94:      */
1:ee1cc94: 	BCLocalField[] parameters; 
1:ee1cc94:     
1:ee1cc94:     /**
1:ee1cc94:      * List of parameter types with java language class names.
1:ee1cc94:      * Can be null or zero length for no parameters.
1:ee1cc94:      */
1:ee1cc94:     private final String[] parameterTypes;
1:ee1cc94:     
1:ee1cc94:     
1:a15a470: 	Vector<String> thrownExceptions; // expected to be names of Classes under Throwable
1:eac0369: 
1:d30bf1c: 	CodeChunk myCode;
1:eac0369: 	protected ClassMember myEntry;
1:eac0369: 
1:eac0369: 	private int currentVarNum;
1:eac0369: 	private int statementNum;
1:d6e8491: 	
1:d30bf1c: 	/**
1:d30bf1c: 	 * True if we are currently switching control
1:d30bf1c: 	 * over to a sub method to avoid hitting the code generation
1:d30bf1c: 	 * limit of 65535 bytes per method.
1:d30bf1c: 	 */
1:d30bf1c: 	private boolean handlingOverflow;
1:d30bf1c: 	
1:d30bf1c: 	/**
1:d30bf1c: 	 * How many sub-methods we have overflowed to.
1:d30bf1c: 	 */
1:d30bf1c: 	private int subMethodCount;
1:d30bf1c: 
1:eac0369: 	BCMethod(ClassBuilder cb,
1:eac0369: 			String returnType,
1:eac0369: 			String methodName,
1:eac0369: 			int modifiers,
1:eac0369: 			String[] parms,
1:eac0369: 			BCJava factory) {
1:eac0369: 
1:eac0369: 		this.cb = (BCClass) cb;
1:eac0369: 		modClass = this.cb.modify();
1:d30bf1c: 		myReturnType = returnType;
1:d30bf1c: 		myName = methodName;
1:eac0369: 
2:eac0369: 		if (SanityManager.DEBUG) {
1:eac0369:    			this.cb.validateType(returnType);
9:eac0369: 		}
1:afa871e: 
1:eac0369: 		// if the method is not static, allocate for "this".
1:eac0369: 		if ((modifiers & Modifier.STATIC) == 0 )
1:eac0369: 			currentVarNum = 1;
1:eac0369: 
1:eac0369: 		String[] vmParamterTypes;
1:eac0369: 
1:ee1cc94: 		if (parms != null && parms.length != 0) {
1:eac0369: 			int len = parms.length;
1:eac0369: 			vmParamterTypes = new String[len];
1:eac0369: 			parameters = new BCLocalField[len];
1:eac0369: 			for (int i = 0; i < len; i++) {
1:eac0369: 				Type t = factory.type(parms[i]);
1:eac0369: 				parameters[i] = new BCLocalField(t, currentVarNum);
1:eac0369: 				currentVarNum += t.width();
1:eac0369: 
1:eac0369: 				// convert to vmname for the BCMethodDescriptor.get() call
1:eac0369: 				vmParamterTypes[i] = t.vmName();
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 			vmParamterTypes = BCMethodDescriptor.EMPTY;
1:eac0369: 
1:eac0369: 		// create a code attribute
1:eac0369: 		String sig = BCMethodDescriptor.get(vmParamterTypes, factory.type(returnType).vmName(), factory);
1:eac0369: 
1:eac0369: 		// stuff the completed information into the class.
1:eac0369: 		myEntry = modClass.addMember(methodName, sig, modifiers);
1:eac0369: 
1:eac0369: 		// get code chunk
1:b8ef064: 		myCode = new CodeChunk(this.cb);
1:ee1cc94:         
1:ee1cc94:         parameterTypes = parms;
1:eac0369: 	}
1:eac0369: 	//
1:eac0369: 	// MethodBuilder interface
1:eac0369: 	//
1:eac0369: 
1:51cefa2: 	/**
1:d30bf1c: 	 * Return the logical name of the method. The current
1:d30bf1c: 	 * myEntry refers to the sub method we are currently
1:d30bf1c: 	 * overflowing to. Those sub-methods are hidden from any caller.
1:d30bf1c: 	 */
1:eac0369: 	public String getName() {
1:d30bf1c: 		return myName;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public void getParameter(int id) {
1:eac0369: 
1:eac0369: 		int num = parameters[id].cpi;
1:eac0369: 		short typ = parameters[id].type.vmType();
1:eac0369: 		if (num < 4)
1:eac0369: 			myCode.addInstr((short) (CodeChunk.LOAD_VARIABLE_FAST[typ]+num));
1:eac0369: 		else
1:eac0369: 			myCode.addInstrWide(CodeChunk.LOAD_VARIABLE[typ], num);
1:eac0369: 
1:eac0369: 		growStack(parameters[id].type);
1:eac0369: 	}
1:eac0369: 
1:afa871e: 	/**
1:eac0369: 	 * a throwable can be added to the end of
1:eac0369: 	 * the list of thrownExceptions.
1:eac0369: 	 */
1:eac0369: 	public void addThrownException(String exceptionClass) {
1:d30bf1c: 		
1:d30bf1c: 		// cannot add exceptions after code generation has started.
1:d30bf1c: 		// Allowing this would cause the method overflow/split to
1:d30bf1c: 		// break as the top-level method would not have the exception
1:d30bf1c: 		// added in the sub method.
1:d30bf1c: 		if (SanityManager.DEBUG)
1:d30bf1c: 		{
1:af01856: 			if (myCode.getPC() != 0)
1:d30bf1c: 				SanityManager.THROWASSERT("Adding exception after code generation " + exceptionClass
1:d30bf1c: 						+ " to method " + getName());
1:9c5e195: 		}
1:eac0369: 
1:eac0369: 		if (thrownExceptions == null)
1:a15a470: 			thrownExceptions = new Vector<String>();
1:a32eb9f: 		thrownExceptions.add(exceptionClass);
1:d30bf1c: 	}
1:eac0369: 
1:d30bf1c: 	/**
1:eac0369: 	 * when the method has had all of its parameters
1:eac0369: 	 * and thrown exceptions defined, and its statement
1:eac0369:  	 * block has been completed, it can be completed and
1:eac0369: 	 * its class file information generated.
1:eac0369: 	 * <p>
1:eac0369: 	 * further alterations of the method will not be
1:eac0369: 	 * reflected in the code generated for it.
1:eac0369: 	 */
1:eac0369: 	public void complete() {
1:ee1cc94:         
1:51cefa2:         // myCode.getPC() gives the code length since
1:51cefa2:         // the program counter will be positioned after
1:51cefa2:         // the last instruction. Note this value can
1:51cefa2:         // be changed by the splitMethod call.
1:ee1cc94:         
1:51cefa2:         if (myCode.getPC() > CODE_SPLIT_LENGTH)
1:ee1cc94:             splitMethod();
1:51cefa2:                          
1:ee1cc94:        // write exceptions attribute info
1:ee1cc94:         writeExceptions();
1:ee1cc94:         	
1:eac0369: 		// get the code attribute to put itself into the class
1:eac0369: 		// provide the final header information needed
1:38fe427: 		myCode.complete(this, modClass, myEntry, maxStack, currentVarNum);
1:eac0369: 	}
1:ee1cc94:     
1:ee1cc94:     /**
1:ee1cc94:      * Attempt to split a large method by pushing code out to several
1:ee1cc94:      * sub-methods. Performs a number of steps.
1:ee1cc94:      * <OL>
1:ee1cc94:      * <LI> Split at zero stack depth.
1:ee1cc94:      * <LI> Split at non-zero stack depth (FUTURE)
1:ee1cc94:      * </OL>
1:ee1cc94:      * 
1:ee1cc94:      * If the class has already exceeded some limit in building the
1:ee1cc94:      * class file format structures then don't attempt to split.
1:ee1cc94:      * Most likely the number of constant pool entries has been exceeded
1:ee1cc94:      * and thus the built class file no longer has integrity.
1:ee1cc94:      * The split code relies on being able to read the in-memory
1:ee1cc94:      * version of the class file in order to determine descriptors
1:ee1cc94:      * for methods and fields.
1:ee1cc94:      */
1:ee1cc94:     private void splitMethod() {
1:ee1cc94:         
1:ee1cc94:         int split_pc = 0;
1:9c5e195:         boolean splittingZeroStack = true;
1:ee1cc94:         for (int codeLength = myCode.getPC();
1:ee1cc94:                (cb.limitMsg == null) &&
1:ee1cc94:                (codeLength > CODE_SPLIT_LENGTH);
1:ee1cc94:             codeLength = myCode.getPC())
1:ee1cc94:         {
1:ee1cc94:             int lengthToCheck = codeLength - split_pc;
1:ee1cc94: 
1:ee1cc94:             int optimalMinLength;
1:ee1cc94:             if (codeLength < CODE_SPLIT_LENGTH * 2) {
1:ee1cc94:                 // minimum required
1:ee1cc94:                 optimalMinLength = codeLength - CODE_SPLIT_LENGTH;
1:ee1cc94:             } else {
1:ee1cc94:                 // try to split as much as possible
1:ee1cc94:                 // need one for the return instruction
1:ee1cc94:                 optimalMinLength = CODE_SPLIT_LENGTH - 1;
1:ee1cc94:             }
1:ee1cc94: 
1:ee1cc94:             if (optimalMinLength > lengthToCheck)
1:ee1cc94:                 optimalMinLength = lengthToCheck;
1:ee1cc94: 
1:9c5e195:             if (splittingZeroStack)
1:9c5e195:             {
1:9c5e195:                 split_pc = myCode.splitZeroStack(this, modClass, split_pc,
1:0d42361:                     optimalMinLength);
1:9c5e195:             }
1:9c5e195:             else
1:9c5e195:             {
1:8aff1cd:                 // Note the split expression does not re-start split
1:8aff1cd:                 // at point left off by the previous split expression.
1:8aff1cd:                 // This could be done but would require some level
1:8aff1cd:                 // of stack depth history to be kept across calls.
1:8aff1cd:                 split_pc = myCode.splitExpressionOut(this, modClass,
1:8aff1cd:                         optimalMinLength, maxStack);
1:8aff1cd: 
1:8aff1cd:              }
1:9c5e195: 
1:ee1cc94:             // Negative split point returned means that no split
1:ee1cc94:             // was possible. Give up on this approach and goto
1:9c5e195:             // the next approach.
1:ee1cc94:             if (split_pc < 0) {
1:9c5e195:                 if (!splittingZeroStack)
1:9c5e195:                    break;
1:9c5e195:                 splittingZeroStack = false;
1:9c5e195:                 split_pc = 0;
1:ee1cc94:             }
1:ee1cc94: 
1:ee1cc94:             // success, continue on splitting after the call to the
1:ee1cc94:             // sub-method if the method still execeeds the maximum length.
1:ee1cc94:         }
1:9c5e195:         
1:9c5e195:  
1:ee1cc94:     }
1:ee1cc94: 
1:eac0369: 	/*
1:ee1cc94:      * class interface
1:ee1cc94:      */
1:afa871e: 
2:eac0369: 	/**
1:ee1cc94:      * In their giveCode methods, the parts of the method body will want to get
1:ee1cc94:      * to the constant pool to add their constants. We really only want them
1:ee1cc94:      * treating it like a constant pool inclusion mechanism, we could write a
1:ee1cc94:      * wrapper to limit it to that.
1:ee1cc94:      */
1:eac0369: 	ClassHolder constantPool() {
1:eac0369: 		return modClass;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369:     //
1:eac0369:     // Class implementation
1:eac0369:     //
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * sets exceptionBytes to the attribute_info needed
1:eac0369: 	 * for a method's Exceptions attribute.
1:eac0369: 	 * The ClassUtilities take care of the header 6 bytes for us,
1:eac0369: 	 * so they are not included here.
1:eac0369: 	 * See The Java Virtual Machine Specification Section 4.7.5,
1:eac0369: 	 * Exceptions attribute.
1:eac0369: 	 */
1:eac0369: 	protected void writeExceptions() {
1:eac0369: 		if (thrownExceptions == null)
1:eac0369: 			return;
1:d30bf1c: 
1:eac0369: 		int numExc = thrownExceptions.size();
1:d30bf1c: 
1:eac0369: 		// don't write an Exceptions attribute if there are no exceptions.
1:eac0369: 		if (numExc != 0) {
1:d30bf1c: 
1:eac0369: 			try{
1:eac0369: 				ClassFormatOutput eout = new ClassFormatOutput((numExc * 2) + 2);
1:d30bf1c: 
1:eac0369: 				eout.putU2(numExc); // number_of_exceptions
1:d30bf1c: 
1:eac0369: 				for (int i = 0; i < numExc; i++) {
1:eac0369: 					// put each exception into the constant pool
1:a32eb9f: 					String e = thrownExceptions.get(i).toString();
1:eac0369: 					int ei2 = modClass.addClassReference(e);
1:eac0369: 
1:eac0369: 					// add constant pool index to exception attribute_info
1:eac0369: 					eout.putU2(ei2);
1:eac0369: 				}
1:eac0369: 
1:eac0369: 				myEntry.addAttribute("Exceptions", eout);
1:eac0369: 
1:eac0369: 			} catch (IOException ioe) {
1:eac0369: 			}			
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** New push compiler api.
1:eac0369: 	*/
1:eac0369: 
1:4549ad4: 	/**
1:4549ad4: 	 * Array of the current types of the values on the stack.
1:4549ad4: 	 * A type that types up two words on the stack, e.g. double
1:4549ad4: 	 * will only occupy one element in this array.
1:4549ad4: 	 * This array is dynamically re-sized as needed.
1:4549ad4: 	 */
1:eac0369: 	private Type[]	stackTypes = new Type[8];
1:4549ad4: 	
1:4549ad4: 	/**
1:4549ad4: 	 * Points to the next array offset in stackTypes
1:4549ad4: 	 * to be used. Really it's the number of valid entries
1:4549ad4: 	 * in stackTypes.
1:4549ad4: 	 */
1:eac0369: 	private int     stackTypeOffset;
1:eac0369: 
1:4549ad4: 	/**
1:4549ad4: 	 * Maximum stack depth seen in this method, measured in words.
1:4549ad4: 	 * Corresponds to max_stack in the Code attribute of section 4.7.3
1:4549ad4: 	 * of the vm spec.
1:4549ad4: 	 */
1:ee1cc94: 	int maxStack;
1:4549ad4: 	
1:4549ad4: 	/**
1:4549ad4: 	 * Current stack depth in this method, measured in words.
1:4549ad4: 	 */
1:eac0369: 	private int stackDepth;
1:eac0369: 
1:eac0369: 	private void growStack(int size, Type type) {
1:eac0369: 		stackDepth += size;
1:eac0369: 		if (stackDepth > maxStack)
1:eac0369: 			maxStack = stackDepth;
1:eac0369: 		
1:eac0369: 		if (stackTypeOffset >= stackTypes.length) {
1:eac0369: 
1:eac0369: 			Type[] newStackTypes = new Type[stackTypes.length + 8];
1:eac0369: 			System.arraycopy(stackTypes, 0, newStackTypes, 0, stackTypes.length);
1:eac0369: 			stackTypes = newStackTypes;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		stackTypes[stackTypeOffset++] = type;
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG) {
1:eac0369: 
1:eac0369: 			int sum = 0;
1:eac0369: 			for (int i = 0 ; i < stackTypeOffset; i++) {
1:eac0369: 				sum += stackTypes[i].width();
1:eac0369: 			}
1:eac0369: 			if (sum != stackDepth) {
1:eac0369: 				SanityManager.THROWASSERT("invalid stack depth " + stackDepth + " calc " + sum);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	private void growStack(Type type) {
1:eac0369: 		growStack(type.width(), type);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	private Type popStack() {
1:eac0369: 		stackTypeOffset--;
1:eac0369: 		Type topType = stackTypes[stackTypeOffset];
1:eac0369: 		stackDepth -= topType.width();
1:eac0369: 		return topType;
1:4549ad4: 
1:eac0369: 	}
1:eac0369: 	
1:4549ad4: 	private Type[] copyStack()
1:4549ad4: 	{
1:4549ad4: 		Type[] stack = new Type[stackTypeOffset];
1:4549ad4: 		System.arraycopy(stackTypes, 0, stack, 0, stackTypeOffset);
1:4549ad4: 		return stack;
1:4549ad4: 	}
1:eac0369: 
1:eac0369: 	public void pushThis() {
1:eac0369: 		myCode.addInstr(VMOpcode.ALOAD_0);
1:eac0369: 		growStack(1, cb.classType);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public void push(byte value) {
1:eac0369: 		push(value, Type.BYTE);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public void push(boolean value) {
1:eac0369: 		push(value ? 1 : 0, Type.BOOLEAN);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public void push(short value) {
1:eac0369: 		push(value, Type.SHORT);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public void push(int value) {
1:eac0369: 		push(value, Type.INT);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public void dup() {
1:eac0369: 		Type dup = popStack();
1:eac0369: 		myCode.addInstr(dup.width() == 2  ? VMOpcode.DUP2 : VMOpcode.DUP);
1:eac0369: 		growStack(dup);
1:eac0369: 		growStack(dup);
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public void swap() {
1:eac0369: 
1:eac0369: 		// have A,B
1:eac0369: 		// want B,A
1:eac0369: 
1:eac0369: 		Type wB = popStack();
1:eac0369: 		Type wA = popStack();
1:eac0369: 		growStack(wB);
1:eac0369: 		growStack(wA);
1:eac0369: 
1:eac0369: 		if (wB.width() == 1) {
1:eac0369: 			// top value is one word
1:eac0369: 			if (wA.width() == 1) {
2:eac0369: 				myCode.addInstr(VMOpcode.SWAP);
1:eac0369: 				return;
1:d30bf1c: 			} else {
2:eac0369: 				myCode.addInstr(VMOpcode.DUP_X2);
2:eac0369: 				myCode.addInstr(VMOpcode.POP);
1:eac0369: 			}
3:eac0369: 		} else {
1:eac0369: 			// top value is two words
1:eac0369: 			if (wA.width() == 1) {
1:eac0369: 				myCode.addInstr(VMOpcode.DUP2_X1);
1:eac0369: 				myCode.addInstr(VMOpcode.POP2);
1:eac0369: 			} else {
1:eac0369: 				myCode.addInstr(VMOpcode.DUP2_X2);
1:eac0369: 				myCode.addInstr(VMOpcode.POP2);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// all except the simple swap push an extra
1:eac0369: 		// copy of B which needs to be popped.
1:eac0369: 		growStack(wB);
4:eac0369: 		popStack();
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:51cefa2:      * Push an integer value. Uses the special integer opcodes
1:51cefa2:      * for the constants -1 to 5, BIPUSH for values that fit in
1:51cefa2:      * a byte and SIPUSH for values that fit in a short. Otherwise
1:51cefa2:      * uses LDC with a constant pool entry.
1:51cefa2:      * 
1:51cefa2:      * @param value Value to be pushed
1:51cefa2:      * @param type Final type of the value.
1:51cefa2:      */
1:eac0369: 	private void push(int value, Type type) {
1:eac0369: 
2:eac0369: 		CodeChunk chunk = myCode;
1:eac0369: 
1:eac0369: 		if (value >= -1 && value <= 5)
1:eac0369: 			chunk.addInstr((short)(VMOpcode.ICONST_0+value));
1:eac0369: 		else if (value >= Byte.MIN_VALUE && value <= Byte.MAX_VALUE)
1:eac0369: 			chunk.addInstrU1(VMOpcode.BIPUSH,value);
1:eac0369: 		else if (value >= Short.MIN_VALUE && value <= Short.MAX_VALUE)
1:eac0369: 			chunk.addInstrU2(VMOpcode.SIPUSH,value);
2:eac0369: 		else {
2:eac0369: 			int cpe = modClass.addConstant(value);
1:ee1cc94: 			addInstrCPE(VMOpcode.LDC, cpe);
1:eac0369: 		}
1:51cefa2: 		growStack(type.width(), type);
1:eac0369: 		
1:eac0369: 	}
1:eac0369: 
1:51cefa2:     /**
1:51cefa2:      * Push a long value onto the stack.
1:51cefa2:      * For the values zero and one the LCONST_0 and
1:51cefa2:      * LCONST_1 instructions are used.
1:51cefa2:      * For values betwee Short.MIN_VALUE and Short.MAX_VALUE
1:51cefa2:      * inclusive an byte/short/int value is pushed
1:51cefa2:      * using push(int, Type) followed by an I2L instruction.
1:51cefa2:      * This saves using a constant pool entry for such values.
1:51cefa2:      * All other values use a constant pool entry. For values
1:51cefa2:      * in the range of an Integer an integer constant pool
1:51cefa2:      * entry is created to allow sharing with integer constants
1:51cefa2:      * and to reduce constant pool slot entries.
1:51cefa2:      */
1:51cefa2: 	public void push(long value) {
1:51cefa2:         CodeChunk chunk = myCode;
1:eac0369: 
1:51cefa2:         if (value == 0L || value == 1L) {
1:51cefa2:             short opcode = value == 0L ? VMOpcode.LCONST_0 : VMOpcode.LCONST_1;
1:51cefa2:             chunk.addInstr(opcode);
1:51cefa2:         } else if (value >= Integer.MIN_VALUE && value <= Integer.MAX_VALUE) {
1:51cefa2:             // the push(int, Type) method grows the stack for us.
1:51cefa2:             push((int) value, Type.LONG);
1:51cefa2:             chunk.addInstr(VMOpcode.I2L);
1:51cefa2:             return;
1:51cefa2:         } else {
1:51cefa2:             int cpe = modClass.addConstant(value);
1:51cefa2:             chunk.addInstrU2(VMOpcode.LDC2_W, cpe);
1:51cefa2:         }
1:51cefa2:         growStack(2, Type.LONG);
1:51cefa2:     }
1:eac0369: 	public void push(float value) {
1:eac0369: 
1:eac0369: 		CodeChunk chunk = myCode;
1:eac0369: 		
1:eac0369: 		if (value == 0.0)
1:d30bf1c: 		{
1:eac0369: 			chunk.addInstr(VMOpcode.FCONST_0);
1:eac0369: 		}
1:eac0369: 		else if (value == 1.0)
2:eac0369: 		{
1:eac0369: 			chunk.addInstr(VMOpcode.FCONST_1);
1:eac0369: 		}
1:eac0369: 		else if (value == 2.0)
1:eac0369: 		{
1:eac0369: 			chunk.addInstr(VMOpcode.FCONST_2);
1:eac0369: 		}
1:eac0369: 		else 
1:eac0369: 		{
1:eac0369: 			int cpe = modClass.addConstant(value);
1:ee1cc94: 			addInstrCPE(VMOpcode.LDC, cpe);
1:eac0369: 		}
1:eac0369: 		growStack(1, Type.FLOAT);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public void push(double value) {
1:eac0369: 		CodeChunk chunk = myCode;
1:eac0369: 
1:eac0369: 		if (value == 0.0) {
1:eac0369: 				chunk.addInstr(VMOpcode.DCONST_0);
1:eac0369: 		}
1:eac0369: 		else {
1:eac0369: 			int cpe = modClass.addConstant(value);
2:eac0369: 			chunk.addInstrU2(VMOpcode.LDC2_W, cpe);
1:eac0369: 		}
1:eac0369: 		growStack(2, Type.DOUBLE);
1:eac0369: 	}
1:eac0369: 	public void push(String value) {
1:eac0369: 		int cpe = modClass.addConstant(value);
1:ee1cc94: 		addInstrCPE(VMOpcode.LDC, cpe);
1:eac0369: 		growStack(1, Type.STRING);
1:eac0369: 	}
1:eac0369:  
1:eac0369: 
1:eac0369: 	public void methodReturn() {
1:eac0369: 
1:eac0369: 		short opcode;		
1:eac0369: 		if (stackDepth != 0) {
1:eac0369: 			Type topType = popStack();
1:eac0369: 			opcode = CodeChunk.RETURN_OPCODE[topType.vmType()];
1:eac0369: 		} else {
1:eac0369: 			opcode = VMOpcode.RETURN;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		myCode.addInstr(opcode);
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG) {
1:eac0369: 			if (stackDepth != 0)
1:eac0369: 				SanityManager.THROWASSERT("items left on stack " + stackDepth);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public Object describeMethod(short opcode, String declaringClass, String methodName, String returnType) {
1:eac0369: 
1:eac0369: 		Type rt = cb.factory.type(returnType);
1:eac0369: 
1:eac0369: 		String methodDescriptor = BCMethodDescriptor.get(BCMethodDescriptor.EMPTY, rt.vmName(), cb.factory);
1:eac0369: 
1:eac0369: 		if ((declaringClass == null) && (opcode != VMOpcode.INVOKESTATIC)) {
1:eac0369: 
1:eac0369: 			Type dt = stackTypes[stackTypeOffset - 1];
1:eac0369: 
1:eac0369: 			if (declaringClass == null)
1:eac0369: 				declaringClass = dt.javaName();
1:eac0369: 		}
1:eac0369: 		
1:eac0369: 		int cpi = modClass.addMethodReference(declaringClass, methodName,
1:eac0369: 				methodDescriptor, opcode == VMOpcode.INVOKEINTERFACE);
1:eac0369: 
1:eac0369: 		return new BCMethodCaller(opcode, rt, cpi);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public int callMethod(Object methodDescriptor) {
1:eac0369: 
1:eac0369: 		// pop the reference off the stack
1:eac0369: 		popStack();
1:eac0369: 
1:eac0369: 		BCMethodCaller mc = (BCMethodCaller) methodDescriptor;
1:eac0369: 
1:eac0369: 		int cpi = mc.cpi;
1:eac0369: 		short opcode = mc.opcode;
1:eac0369: 
1:eac0369: 		if (opcode == VMOpcode.INVOKEINTERFACE) {
1:eac0369: 			myCode.addInstrU2U1U1(opcode, cpi, (short) 1, (short) 0);
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 			myCode.addInstrU2(opcode, cpi);
1:eac0369: 		
1:eac0369: 		// this is the return type of the method
1:eac0369: 		Type rt = mc.type;
1:eac0369: 		int rw = rt.width();
1:eac0369: 		if (rw != 0)
1:eac0369: 			growStack(rw, rt);
1:d30bf1c: 		else
1:d30bf1c: 		{
1:0393775:             overflowMethodCheck();
1:d30bf1c: 		}
1:eac0369: 		return cpi;
1:d30bf1c: 	}
1:eac0369: 
1:eac0369: 	public int callMethod(short opcode, String declaringClass, String methodName,
1:eac0369: 		String returnType, int numArgs) {
1:eac0369: 
1:eac0369: 		Type rt = cb.factory.type(returnType);
1:eac0369: 
1:eac0369: 		int initialStackDepth = stackDepth;
1:eac0369: 
1:eac0369: 		// get the array of parameter types
1:eac0369: 
1:eac0369: 		String [] debugParameterTypes = null;
1:eac0369: 		String[] vmParameterTypes;
1:eac0369: 		if (numArgs == 0) {
1:eac0369: 			vmParameterTypes = BCMethodDescriptor.EMPTY;
1:eac0369: 		} else {
1:eac0369: 			if (SanityManager.DEBUG) {
1:eac0369: 				debugParameterTypes = new String[numArgs];
1:eac0369: 			}
1:eac0369: 			vmParameterTypes = new String[numArgs];
1:eac0369: 			for (int i = numArgs - 1; i >= 0; i--) {
1:eac0369: 				Type at = popStack();
1:eac0369: 
1:eac0369: 				vmParameterTypes[i] = at.vmName();
1:eac0369: 				if (SanityManager.DEBUG) {
1:eac0369: 					debugParameterTypes[i] = at.javaName();
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		
1:eac0369: 		String methodDescriptor = BCMethodDescriptor.get(vmParameterTypes, rt.vmName(), cb.factory);
1:eac0369: 
1:eac0369: 		Type dt = null;
1:eac0369: 		if (opcode != VMOpcode.INVOKESTATIC) {
1:eac0369: 
1:eac0369: 			dt = popStack();
1:eac0369: 		}
1:eac0369: 		Type dtu = vmNameDeclaringClass(declaringClass);
1:eac0369: 		if (dtu != null)
1:eac0369: 			dt = dtu;
1:eac0369: 		
1:eac0369: 		int cpi = modClass.addMethodReference(dt.vmNameSimple, methodName,
1:eac0369: 				methodDescriptor, opcode == VMOpcode.INVOKEINTERFACE);
1:eac0369: 
1:eac0369: 		if (opcode == VMOpcode.INVOKEINTERFACE) {
1:eac0369: 			short callArgCount = (short) (initialStackDepth - stackDepth);
1:eac0369: 			myCode.addInstrU2U1U1(opcode, cpi, callArgCount, (short) 0);
1:eac0369: 		}
1:d30bf1c: 		else
1:eac0369: 			myCode.addInstrU2(opcode, cpi);
1:eac0369: 		
1:eac0369: 		// this is the return type of the method
1:eac0369: 		int rw = rt.width();
1:eac0369: 		if (rw != 0)
1:eac0369: 			growStack(rw, rt);
1:eac0369: 		else
1:d30bf1c: 		{
1:0393775:             overflowMethodCheck();
1:eac0369: 		}
1:eac0369: 		// Check the declared type of the method
1:eac0369: 		if (SanityManager.DEBUG) {
1:eac0369: 
1:eac0369: 			d_BCValidate.checkMethod(opcode, dt, methodName, debugParameterTypes, rt);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return cpi;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	private Type vmNameDeclaringClass(String declaringClass) {
1:eac0369: 		if (declaringClass == null)
1:eac0369: 			return null;
1:eac0369: 		return cb.factory.type(declaringClass);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public void callSuper() {
1:eac0369: 
2:eac0369: 		pushThis();
1:eac0369: 		callMethod(VMOpcode.INVOKESPECIAL, cb.getSuperClassName(), "<init>", "void", 0);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public void pushNewStart(String className) {
1:eac0369: 
1:eac0369: 		int cpi = modClass.addClassReference(className);
1:eac0369: 
1:eac0369: 		// Use U2, not CPE, since only wide form exists.
1:eac0369: 		myCode.addInstrU2(VMOpcode.NEW, cpi);
1:eac0369: 		myCode.addInstr(VMOpcode.DUP);
1:eac0369: 
1:eac0369: 		// Grow the stack twice as we are pushing
1:eac0369: 		// two instances of newly created reference
1:eac0369: 		Type nt = cb.factory.type(className);
1:eac0369: 		growStack(1, nt);
1:eac0369: 		growStack(1, nt);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public void pushNewComplete(int numArgs) {
1:eac0369: 		callMethod(VMOpcode.INVOKESPECIAL, (String) null, "<init>", "void", numArgs);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public void upCast(String className) {
1:eac0369: 		Type uct = cb.factory.type(className);
1:eac0369: 
1:eac0369: 		stackTypes[stackTypeOffset - 1] = uct;
1:eac0369: 		//popStack();
1:eac0369: 		//growStack(1, uct);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public void cast(String className) {
1:c7c8b2d: 		
1:c7c8b2d: 		// Perform a simple optimization to not
1:c7c8b2d: 		// insert a checkcast when the classname
1:c7c8b2d: 		// of the cast exactly matches the type name
1:c7c8b2d: 		// currently on the stack.
1:c7c8b2d: 		// This can reduce the amount of generated code.
1:c7c8b2d: 		// This compiler/class generator does not load
1:c7c8b2d: 		// classes to check relationships or any other
1:c7c8b2d: 		// information. Thus other optimizations where a cast
1:c7c8b2d: 		// is not required are not implemented.
1:c7c8b2d: 		Type tbc = stackTypes[stackTypeOffset - 1];
1:c7c8b2d: 		
1:eac0369: 		short sourceType = tbc.vmType();
1:c7c8b2d: 		
1:c7c8b2d: 		if (sourceType == BCExpr.vm_reference)
1:c7c8b2d: 		{
1:c7c8b2d: 			// Simple optimize step
1:c7c8b2d: 			if (className.equals(tbc.javaName()))
1:c7c8b2d: 			{
1:c7c8b2d: 				// do nothing, exact matching type
1:c7c8b2d: 				return;
1:c7c8b2d: 			}
1:c7c8b2d: 		}
1:c7c8b2d: 		
1:c7c8b2d: 		Type ct = cb.factory.type(className);
1:c7c8b2d: 		popStack();
1:c7c8b2d: 		
1:eac0369: 		short targetType = ct.vmType();
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG) {
1:eac0369: 
1:eac0369: 			if (!((sourceType == BCExpr.vm_reference &&
1:eac0369: 				targetType == BCExpr.vm_reference) ||
1:eac0369: 				(sourceType != BCExpr.vm_reference &&
1:eac0369: 				targetType != BCExpr.vm_reference))) {
1:eac0369: 				SanityManager.THROWASSERT("Both or neither must be object types " + ct.javaName() + " " + tbc.javaName());
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// if it is an object type, do a checkcast on it.
1:eac0369: 		if (sourceType == BCExpr.vm_reference) {
1:eac0369: 
1:eac0369: 			int cpi = modClass.addClassReference(ct.vmNameSimple);
1:eac0369: 			myCode.addInstrU2(VMOpcode.CHECKCAST, cpi);
1:eac0369: 		}
1:eac0369: 		// otherwise, try to convert it.
1:eac0369: 		else {
1:eac0369: 			short opcode = VMOpcode.NOP;
1:eac0369: 
1:eac0369: 			// we use the conversionInfo array
1:eac0369: 			// to determine how to convert; if
1:eac0369: 			// the result type of the conversion
1:eac0369: 			// is not our target type, we are not done
1:eac0369: 			// yet.  Make sure there are no
1:eac0369: 			// infinite loop possibilities in the
1:eac0369: 			// conversionInfo array!
1:eac0369: 			while (sourceType!=targetType && opcode!=VMOpcode.BAD) {
1:eac0369: 				short[] currentConversion = 
1:eac0369: 					CodeChunk.CAST_CONVERSION_INFO[sourceType][targetType];
1:eac0369: 				sourceType = currentConversion[1];
1:eac0369: 				opcode = currentConversion[0];
1:eac0369: 				if (opcode != VMOpcode.NOP) {
1:eac0369: 					myCode.addInstr(opcode);
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 			if (SanityManager.DEBUG) {
1:eac0369: 				SanityManager.ASSERT(opcode != VMOpcode.BAD,
1:eac0369: 					"BAD VMOpcode not expected in cast");
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		growStack(ct);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public void isInstanceOf(String className) {
1:eac0369: 		int cpi = modClass.addClassReference(className);
1:eac0369: 		myCode.addInstrU2(VMOpcode.INSTANCEOF, cpi);
1:eac0369: 		popStack();
1:eac0369: 		growStack(1, Type.BOOLEAN);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public void pushNull(String type) {
1:eac0369: 		myCode.addInstr(VMOpcode.ACONST_NULL);
1:eac0369: 		growStack(1, cb.factory.type(type));
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	public void getField(LocalField field) {
1:eac0369: 
1:0393775: 		BCLocalField lf = (BCLocalField) field;
1:afa871e: 		Type lt = lf.type;
1:0393775: 
1:eac0369: 		pushThis();
1:eac0369: 		myCode.addInstrU2(VMOpcode.GETFIELD, lf.cpi);
1:eac0369: 
1:0393775: 		popStack();
1:eac0369: 		growStack(lt);
1:eac0369: 
1:0393775: 	}
1:eac0369: 
1:eac0369: 	public void getField(String declaringClass, String fieldName, String fieldType) {
1:eac0369: 		Type dt = popStack();
1:eac0369: 
1:eac0369: 		Type dtu = vmNameDeclaringClass(declaringClass);
1:eac0369: 		if (dtu != null)
1:eac0369: 			dt = dtu;
1:eac0369: 
1:eac0369: 		getField(VMOpcode.GETFIELD, dt.vmNameSimple, fieldName, fieldType);
1:eac0369: 	}
1:eac0369: 	/**
1:eac0369: 		Push the contents of the described static field onto the stack.		
1:eac0369: 	*/
1:eac0369: 	public void getStaticField(String declaringClass, String fieldName, String fieldType) {
1:eac0369: 		getField(VMOpcode.GETSTATIC, declaringClass, fieldName, fieldType);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	private void getField(short opcode, String declaringClass, String fieldName, String fieldType) { 
1:eac0369: 
1:eac0369: 		Type ft = cb.factory.type(fieldType);
1:eac0369: 		int cpi = modClass.addFieldReference(vmNameDeclaringClass(declaringClass).vmNameSimple, fieldName, ft.vmName());
1:eac0369: 		myCode.addInstrU2(opcode, cpi);
1:eac0369: 
1:eac0369: 		growStack(ft);
1:eac0369: 	}
1:eac0369: 	
1:eac0369: 	/**
1:afa871e: 	 * Set the field but don't duplicate its value so
1:afa871e: 	 * nothing is left on the stack after this call.
1:afa871e: 	 */
1:afa871e: 	public void setField(LocalField field) {
1:0393775: 		BCLocalField lf = (BCLocalField) field;
1:afa871e: 		putField(lf.type, lf.cpi, false);
1:0393775:         overflowMethodCheck();
1:0393775: 	}
1:0393775: 
1:eac0369: 	/**
1:eac0369: 		Upon entry the top word(s) on the stack is
1:eac0369: 		the value to be put into the field. Ie.
1:eac0369: 		we have
1:eac0369: 		<PRE>
1:eac0369: 		word
1:eac0369: 		</PRE>
1:afa871e: 
1:eac0369: 		Before the call we need 
1:eac0369: 		<PRE>
1:eac0369: 		word
1:eac0369: 		this
1:eac0369: 		word
1:eac0369: 		</PRE>
1:dbed020: 		word2,word1 -&gt; word2, word1, word2
1:afa871e: 
1:eac0369: 		So that we are left with word after the put.
1:eac0369: 
1:eac0369: 	*/
1:eac0369: 	public void putField(LocalField field) {
1:afa871e: 		BCLocalField lf = (BCLocalField) field;
1:afa871e: 		putField(lf.type, lf.cpi, true);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Pop the top stack value and store it in the instance field of this class.
1:eac0369: 	*/
1:eac0369: 	public void putField(String fieldName, String fieldType) {
1:eac0369: 
1:eac0369: 		Type ft = cb.factory.type(fieldType);
1:eac0369: 		int cpi = modClass.addFieldReference(cb.classType.vmNameSimple, fieldName, ft.vmName());
1:eac0369: 
1:afa871e: 		putField(ft, cpi, true);
1:eac0369: 	}
1:eac0369: 
1:afa871e: 	private void putField(Type fieldType, int cpi, boolean dup) {
1:eac0369: 
1:eac0369: 		// now have ...,value
1:afa871e: 		if (dup)
1:afa871e: 		{
1:afa871e: 			myCode.addInstr(fieldType.width() == 2  ? VMOpcode.DUP2 : VMOpcode.DUP);
1:afa871e: 			growStack(fieldType);
1:eac0369: 		}
1:afa871e: 		// now have
1:afa871e: 		// dup true:  ...,value,value
1:afa871e: 		// dup false: ...,value,
1:afa871e: 
1:afa871e: 		pushThis();
1:afa871e: 		// now have
1:afa871e: 		// dup true:  ...,value,value,this
1:afa871e: 		// dup false: ...,value,this
1:afa871e: 
1:afa871e: 		swap();
1:afa871e: 		// now have
1:afa871e: 		// dup true:  ...,value,this,value
1:afa871e: 		// dup false: ...,this,value
1:afa871e: 
1:eac0369: 		myCode.addInstrU2(VMOpcode.PUTFIELD, cpi);
1:eac0369: 		popStack(); // the value
1:eac0369: 		popStack(); // this
1:afa871e: 
1:afa871e: 		// now have
1:afa871e: 		// dup true:  ...,value
1:afa871e: 		// dup false: ...
1:eac0369: 	}
1:eac0369: 	/**
1:eac0369: 		Pop the top stack value and store it in the field.
1:eac0369: 		This call requires the instance to be pushed by the caller.
1:eac0369: 	*/
1:eac0369: 	public void putField(String declaringClass, String fieldName, String fieldType) {
1:eac0369: 		Type vt = popStack();
1:eac0369: 		Type dt = popStack();
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG) {
1:eac0369: 			if (dt.width() != 1)
1:eac0369: 				SanityManager.THROWASSERT("reference expected for field access - is " + dt.javaName());
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// have objectref,value
1:eac0369: 		// need value,objectref,value
1:eac0369: 
1:eac0369: 		myCode.addInstr(vt.width() == 2  ? VMOpcode.DUP2_X1 : VMOpcode.DUP_X1);
1:eac0369: 		growStack(vt);
1:eac0369: 		growStack(dt);
1:eac0369: 		growStack(vt);
1:eac0369: 
1:eac0369: 		Type dtu = vmNameDeclaringClass(declaringClass);
1:eac0369: 		if (dtu != null)
1:eac0369: 			dt = dtu;
1:eac0369: 
1:eac0369: 		Type ft = cb.factory.type(fieldType);
1:eac0369: 		int cpi = modClass.addFieldReference(dt.vmNameSimple, fieldName, ft.vmName());
1:eac0369: 		myCode.addInstrU2(VMOpcode.PUTFIELD, cpi);
1:eac0369: 
1:eac0369: 		popStack(); // value
1:eac0369: 		popStack(); // reference
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public void conditionalIfNull() {
1:eac0369: 
1:eac0369: 		conditionalIf(VMOpcode.IFNONNULL);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public void conditionalIf() {
1:eac0369: 		conditionalIf(VMOpcode.IFEQ);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	private Conditional condition;
1:eac0369: 
1:eac0369: 	private void conditionalIf(short opcode) {
1:eac0369: 		popStack();
1:4549ad4: 		
1:4549ad4: 		// Save the stack upon entry to the 'then' block of the
1:4549ad4: 		// 'if' so that we can set up the 'else' block with the
1:4549ad4: 		// correct stack on entry.
1:eac0369: 
1:4549ad4: 		condition = new Conditional(condition, myCode, opcode, copyStack());
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public void startElseCode() {
1:4549ad4: 		
1:4549ad4: 		// start the else code
1:38fe427: 		Type[] entryStack = condition.startElse(this, myCode, copyStack());
1:4549ad4: 		
1:4549ad4: 		for (int i = stackDepth = 0; i  < entryStack.length; i++)
1:4549ad4: 		{
1:4549ad4: 			stackDepth += (stackTypes[i] = entryStack[i]).width();
1:eac0369: 		}
1:4549ad4: 		this.stackTypeOffset = entryStack.length;
1:eac0369: 
1:eac0369: 	}
1:eac0369: 	public void completeConditional() {
1:38fe427: 		condition = condition.end(this, myCode, stackTypes, stackTypeOffset);
1:d6e8491: 	}
1:d6e8491: 	
1:d6e8491: 	public void pop() {
1:d6e8491: 		if (SanityManager.DEBUG) {
1:afa871e: 			if (stackDepth == 0)
1:d6e8491: 				SanityManager.THROWASSERT("pop when stack is empty!");
1:afa871e: 		}
1:d6e8491: 		Type toPop = popStack();
1:d6e8491: 
1:d6e8491: 		myCode.addInstr(toPop.width() == 2  ? VMOpcode.POP2 : VMOpcode.POP);
1:d30bf1c: 		
1:0393775:         overflowMethodCheck();
1:d6e8491: 	}	
1:d6e8491: 
1:eac0369: 	public void endStatement() {
1:eac0369: 		if (stackDepth != 0) {
1:d6e8491: 			pop();
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		//if (SanityManager.DEBUG) {
1:eac0369: 		//	if (stackDepth != 0)
1:eac0369: 		//		SanityManager.THROWASSERT("items left on stack " + stackDepth);
1:eac0369: 	//	}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	*/
1:eac0369: 	public void getArrayElement(int element) {
1:eac0369: 
1:eac0369: 		push(element);
1:eac0369: 		popStack(); // int just pushed will be popped by array access
1:eac0369: 
1:eac0369: 		Type arrayType = popStack();
1:eac0369: 
1:eac0369: 		String arrayJava = arrayType.javaName();
1:eac0369: 		String componentString = arrayJava.substring(0,arrayJava.length()-2);
1:eac0369: 
1:eac0369: 		Type componentType = cb.factory.type(componentString);
1:eac0369: 
1:eac0369: 		short typ = componentType.vmType();
1:eac0369: 
1:eac0369: 		// boolean has a type id of integer, here it needs to be byte.
1:eac0369: 		if ((typ == BCExpr.vm_int) && (componentType.vmName().equals("Z")))
1:eac0369: 			typ = BCExpr.vm_byte;
1:eac0369: 		myCode.addInstr(CodeChunk.ARRAY_ACCESS[typ]);
1:eac0369: 
1:eac0369: 		growStack(componentType);
1:eac0369: 
1:eac0369: 	}
1:eac0369: 	// come in with ref, value
1:eac0369: 
1:eac0369: 	public void setArrayElement(int element) {
1:eac0369: 
1:eac0369: 		// ref, value
1:eac0369: 
1:eac0369: 		push(element);
1:eac0369: 
1:eac0369: 		// ref, value, index
2:eac0369: 		swap();
1:eac0369: 		
1:eac0369: 		Type componentType = popStack(); // value
1:eac0369: 		popStack(); // int just pushed will be popped by array access
1:eac0369: 		
1:eac0369: 		popStack(); // array ref.
1:eac0369: 
1:eac0369: 		short typ = componentType.vmType();
1:eac0369: 
1:eac0369: 		// boolean has a type id of integer, here it needs to be byte.
1:eac0369: 		if ((typ == BCExpr.vm_int) && (componentType.vmName().equals("Z")))
1:eac0369: 			typ = BCExpr.vm_byte;
1:eac0369: 
1:eac0369: 		myCode.addInstr(CodeChunk.ARRAY_STORE[typ]);
1:eac0369: 	}
1:eac0369: 	/**
1:eac0369: 		this array maps the BCExpr vm_* constants 0..6 to
1:eac0369: 		the expected VM type constants for the newarray instruction.
1:eac0369: 		<p>
1:eac0369: 		Because boolean was mapped to integer for general instructions,
1:eac0369: 		it will have to be specially matched and mapped to its value
1:eac0369: 		directly (4).
1:eac0369: 	 */
1:eac0369: 	private static final byte newArrayElementTypeMap[] = { 8, 9, 10, 11, 6, 7, 5 };
1:eac0369: 	static final byte T_BOOLEAN = 4;
1:eac0369: 	/**
1:eac0369: 		Create an array instance
1:eac0369: 
1:dbed020: 		Stack ... =&gt;
1:eac0369: 		      ...,arrayref
1:eac0369: 	*/
1:eac0369: 	public void pushNewArray(String className, int size) {
1:eac0369: 
1:eac0369: 		push(size);
1:eac0369: 		popStack(); // int just pushed will be popped by array creation
1:eac0369: 
1:eac0369: 		Type elementType = cb.factory.type(className);
1:eac0369: 
1:eac0369: 		// determine the instruction to use based on the element type
1:eac0369: 		if (elementType.vmType() == BCExpr.vm_reference) {
1:eac0369: 
1:eac0369: 			// For an array of Java class/interface elements, generate:
1:eac0369: 			// ANEWARRAY #cpei ; where cpei is a constant pool index for the class
1:eac0369: 
1:eac0369: 			int cpi = modClass.addClassReference(elementType.javaName());
1:eac0369: 			// Use U2, not CPE, since only wide form exists.
1:eac0369: 			myCode.addInstrU2(VMOpcode.ANEWARRAY, cpi);
1:eac0369: 		} else {
1:eac0369: 			byte atype;
1:eac0369: 
1:eac0369: 			// get the argument for the array type
1:eac0369: 			// if the element type is boolean, we can't use the map
1:eac0369: 			// because the type id will say integer.
1:eac0369: 			// but we can use vm_int test to weed out some tests
1:eac0369: 			if (elementType.vmType() == BCExpr.vm_int &&
1:eac0369: 			    VMDescriptor.C_BOOLEAN == elementType.vmName().charAt(0))
1:eac0369: 				atype = T_BOOLEAN;
1:eac0369: 			else
1:eac0369: 				atype = newArrayElementTypeMap[elementType.vmType()];
1:eac0369: 
1:eac0369: 			// For an array of Java builtin type elements, generate:
1:eac0369: 			// NEWARRAY #atype ; where atype is a constant for the builtin type
1:eac0369: 
1:eac0369: 			myCode.addInstrU1(VMOpcode.NEWARRAY, atype);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// an array reference is an object, hence width of 1
1:eac0369: 		growStack(1, cb.factory.type(className.concat("[]")));
1:eac0369: 	}
1:ee1cc94:     
1:ee1cc94:     /**
1:ee1cc94:      * Write a instruction that uses a constant pool entry
1:ee1cc94:      * as an operand, add a limit exceeded message if
1:ee1cc94:      * the number of constant pool entries has exceeded
1:ee1cc94:      * the limit.
1:ee1cc94:      */
1:ee1cc94:     private void addInstrCPE(short opcode, int cpe)
1:ee1cc94:     {
1:ee1cc94:         if (cpe >= VMOpcode.MAX_CONSTANT_POOL_ENTRIES)
1:ee1cc94:             cb.addLimitExceeded(this, "constant_pool_count",
1:ee1cc94:                     VMOpcode.MAX_CONSTANT_POOL_ENTRIES, cpe);
1:ee1cc94:         
1:ee1cc94:         myCode.addInstrCPE(opcode, cpe);
1:ee1cc94:     }
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Tell if statement number in this method builder hits limit.  This
1:eac0369: 		method builder keeps a counter of how many statements are added to it.
1:eac0369: 		Caller should call this function every time it tries to add a statement
1:eac0369: 		to this method builder (counter is increased by 1), then the function
1:eac0369: 		returns whether the accumulated statement number hits a limit.
1:eac0369: 		The reason of doing this is that Java compiler has a limit of 64K code
1:eac0369: 		size for each method.  We might hit this limit if an extremely long
1:eac0369: 		insert statement is issued, for example (see beetle 4293).  Counting
1:eac0369: 		statement number is an approximation without too much overhead.
1:eac0369: 	*/
1:eac0369: 	public boolean statementNumHitLimit(int noStatementsAdded)
1:eac0369: 	{
1:eac0369: 		if (statementNum > 2048)    // 2K limit
1:ee1cc94: 		{
1:eac0369: 			return true;
1:ee1cc94: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			statementNum = statementNum + noStatementsAdded;
1:eac0369: 			return false;
1:eac0369: 		}
1:eac0369: 	}
1:d6e8491: 	
1:eac0369: 	/**
1:d30bf1c: 	 * Check to see if the current method byte code is nearing the
1:d30bf1c: 	 * limit of 65535. If it is start overflowing to a new method.
1:d30bf1c: 	 * <P>
1:d30bf1c: 	 * Overflow is handled for a method named e23 as:
1:d30bf1c: 	 * <CODE>
1:d30bf1c: 	 public Object e23()
1:d30bf1c: 	 {
1:d30bf1c: 	   ... existing code
1:d30bf1c: 	   // split point
1:d30bf1c: 	   return e23_0();
1:d30bf1c: 	 }
1:d30bf1c: 	 private Object e23_0()
1:d30bf1c: 	 {
1:d30bf1c: 	    ... first set overflowed code
1:d30bf1c: 	    // split point
1:d30bf1c: 	    return e23_1(); 
1:d30bf1c: 	 }
1:d30bf1c: 	 private Object e23_1()
1:d30bf1c: 	 {
1:d30bf1c: 	    ... second set overflowed code
1:d30bf1c: 	    // method complete
1:d30bf1c: 	    return result; 
1:d30bf1c: 	 }
1:d30bf1c: 	 	 </CODE>
1:d30bf1c: 	 <P>
1:d30bf1c: 	 
1:d30bf1c: 	 These overflow methods are hidden from the code using this MethodBuilder,
1:d30bf1c: 	 it continues to think that it is building a single method with the
1:d30bf1c: 	 original name.
1:d30bf1c: 
1:d30bf1c: 
1:d30bf1c: 	 * <BR> Restrictions:
1:d30bf1c: 	 * <UL>
1:d30bf1c: 	 * <LI> Only handles methods with no arguments
1:d30bf1c: 	 * <LI> Stack depth must be zero
1:d30bf1c: 	 * </UL>
1:d30bf1c: 	 * 
1:d30bf1c: 	 *
1:d30bf1c: 	 */
1:d30bf1c: 	private void overflowMethodCheck()
1:d30bf1c: 	{
1:0393775:         if (stackDepth != 0) {
1:0393775:             // Can only overflow to new method if the stack is empty.
1:0393775:             return;
1:0393775:         }
1:0393775: 
1:d30bf1c: 		if (handlingOverflow)
1:d30bf1c: 			return;
1:d30bf1c: 		
1:d30bf1c: 		// don't sub method in the middle of a conditional
1:d30bf1c: 		if (condition != null)
1:d30bf1c: 			return;
1:d30bf1c: 		
1:af01856: 		int currentCodeSize = myCode.getPC();
1:d30bf1c: 		
1:d30bf1c: 		// Overflow at >= 55,000 bytes which is someway
1:d30bf1c: 		// below the limit of 65,535. Ideally overflow
1:d30bf1c: 		// would occur at 65535 minus the few bytes needed
1:d30bf1c: 		// to call the sub-method, but the issue is at this level
1:d30bf1c: 		// we don't know frequently we are called given the restriction
1:d30bf1c: 		// of only being called when the stack depth is zero.
1:d30bf1c: 		// Thus split earlier to try ensure most cases are caught.
1:d30bf1c: 		// Only downside is that we may split into N methods when N-1 would suffice.
1:d30bf1c: 		if (currentCodeSize < 55000)
1:d30bf1c: 			return;
1:ee1cc94: 				
1:d30bf1c: 		// only handle no-arg methods at the moment.
1:d30bf1c: 		if (parameters != null)
1:d30bf1c: 		{
1:d30bf1c: 			if (parameters.length != 0)
1:d30bf1c: 				return;
1:d30bf1c: 		}
1:ee1cc94:         		
1:ee1cc94: 		BCMethod subMethod = getNewSubMethod(myReturnType, false);
1:d30bf1c: 				
1:d30bf1c: 		// stop any recursion
1:d30bf1c: 		handlingOverflow = true;
1:d30bf1c: 		
1:d30bf1c: 		// in this method make a call to the sub method we will
1:d30bf1c: 		// be transferring control to.
1:ee1cc94:         callSubMethod(subMethod);
1:d30bf1c: 	
1:d30bf1c: 		// and return its value, works just as well for a void method!
1:d30bf1c: 		this.methodReturn();
1:d30bf1c: 		this.complete();
1:d30bf1c: 		
1:d30bf1c: 		handlingOverflow = false;
1:d30bf1c: 		
1:d30bf1c: 		// now the tricky bit, make this object take over the
1:d30bf1c: 		// code etc. from the sub method. This is done so
1:d30bf1c: 		// that any code that has a reference to this MethodBuilder
1:d30bf1c: 		// will continue to work. They will be writing code into the
1:d30bf1c: 		// new sub method.
1:d30bf1c: 		
1:d30bf1c: 		this.myEntry = subMethod.myEntry;
1:d30bf1c: 		this.myCode = subMethod.myCode;
1:d30bf1c: 		this.currentVarNum = subMethod.currentVarNum;
1:d30bf1c: 		this.statementNum = subMethod.statementNum;
1:d30bf1c: 		
1:d30bf1c: 		// copy stack info
1:d30bf1c: 		this.stackTypes = subMethod.stackTypes;
1:d30bf1c: 		this.stackTypeOffset = subMethod.stackTypeOffset;
1:d30bf1c: 		this.maxStack = subMethod.maxStack;
1:d30bf1c: 		this.stackDepth = subMethod.stackDepth;
1:d30bf1c: 	}
1:ee1cc94: 	
1:ee1cc94:     /**
1:ee1cc94:      * Create a sub-method from this method to allow the code builder to split a
1:ee1cc94:      * single logical method into multiple methods to avoid the 64k per-method
1:ee1cc94:      * code size limit. The sub method with inherit the thrown exceptions of
1:ee1cc94:      * this method.
1:ee1cc94:      * 
1:ee1cc94:      * @param returnType
1:ee1cc94:      *            Return type of the new method
1:ee1cc94:      * @param withParameters
1:ee1cc94:      *            True to define the method with matching parameters false to
1:ee1cc94:      *            define it with no parameters.
1:ee1cc94:      * @return A valid empty sub method.
1:ee1cc94:      */
1:ee1cc94:     final BCMethod getNewSubMethod(String returnType, boolean withParameters) {
1:ee1cc94:         int modifiers = myEntry.getModifier();
1:ee1cc94: 
1:ee1cc94:         // the sub-method can be private to ensure that no-one
1:ee1cc94:         // can call it accidentally from outside the class.
1:ee1cc94:         modifiers &= ~(Modifier.PROTECTED | Modifier.PUBLIC);
1:ee1cc94:         modifiers |= Modifier.PRIVATE;
1:ee1cc94: 
1:ee1cc94:         String subMethodName = myName + "_s"
1:ee1cc94:                 + Integer.toString(subMethodCount++);
1:ee1cc94:         BCMethod subMethod = (BCMethod) cb.newMethodBuilder(modifiers,
1:ee1cc94:                 returnType, subMethodName, withParameters ? parameterTypes
1:ee1cc94:                         : null);
1:ee1cc94:         subMethod.thrownExceptions = this.thrownExceptions;
1:b8ef064:         
1:ee1cc94:         return subMethod;
1:ee1cc94:     }
1:ee1cc94: 
1:ee1cc94:     /**
1:ee1cc94:      * Call a sub-method created by getNewSubMethod handling parameters
1:ee1cc94:      * correctly.
1:ee1cc94:      */
1:ee1cc94:     final void callSubMethod(BCMethod subMethod) {
1:ee1cc94:         // in this method make a call to the sub method we will
1:ee1cc94:         // be transferring control to.
1:ee1cc94:         short op;
1:ee1cc94:         if ((myEntry.getModifier() & Modifier.STATIC) == 0) {
1:ee1cc94:             op = VMOpcode.INVOKEVIRTUAL;
1:ee1cc94:             this.pushThis();
1:ee1cc94:         } else {
1:ee1cc94:             op = VMOpcode.INVOKESTATIC;
1:ee1cc94:         }
1:ee1cc94: 
1:ee1cc94:         int parameterCount = subMethod.parameters == null ? 0
1:ee1cc94:                 : subMethod.parameters.length;
1:ee1cc94: 
1:ee1cc94:         // push my parameter values for the call.
1:ee1cc94:         for (int pi = 0; pi < parameterCount; pi++)
1:ee1cc94:             this.getParameter(pi);
1:ee1cc94: 
1:ee1cc94:         this.callMethod(op, modClass.getName(), subMethod.getName(),
1:ee1cc94:                 subMethod.myReturnType, parameterCount);
1:ee1cc94:     }
1:d30bf1c: }
1:ee1cc94: 
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1: 		word2,word1 -&gt; word2, word1, word2
/////////////////////////////////////////////////////////////////////////
1: 		Stack ... =&gt;
commit:a15a470
/////////////////////////////////////////////////////////////////////////
1: 	Vector<String> thrownExceptions; // expected to be names of Classes under Throwable
/////////////////////////////////////////////////////////////////////////
1: 			thrownExceptions = new Vector<String>();
commit:93fea34
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:f542632
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:0393775
/////////////////////////////////////////////////////////////////////////
1:             overflowMethodCheck();
/////////////////////////////////////////////////////////////////////////
1:             overflowMethodCheck();
/////////////////////////////////////////////////////////////////////////
0:     public void getStaticField(LocalField field) {
1:         BCLocalField lf = (BCLocalField) field;
0:         myCode.addInstrU2(VMOpcode.GETSTATIC, lf.cpi);
0:         growStack(lf.type);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         overflowMethodCheck();
0:     public void setStaticField(LocalField field) {
1:         BCLocalField lf = (BCLocalField) field;
0:         myCode.addInstrU2(VMOpcode.PUTSTATIC, lf.cpi);
1:         popStack();
1:         overflowMethodCheck();
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         overflowMethodCheck();
/////////////////////////////////////////////////////////////////////////
1:         if (stackDepth != 0) {
1:             // Can only overflow to new method if the stack is empty.
1:             return;
1:         }
1: 
commit:a32eb9f
/////////////////////////////////////////////////////////////////////////
1: 		thrownExceptions.add(exceptionClass);
/////////////////////////////////////////////////////////////////////////
1: 					String e = thrownExceptions.get(i).toString();
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:8aff1cd
/////////////////////////////////////////////////////////////////////////
1:     
/////////////////////////////////////////////////////////////////////////
1:                 // Note the split expression does not re-start split
1:                 // at point left off by the previous split expression.
1:                 // This could be done but would require some level
1:                 // of stack depth history to be kept across calls.
1:                 split_pc = myCode.splitExpressionOut(this, modClass,
1:                         optimalMinLength, maxStack);
1: 
1:              }
commit:9c5e195
/////////////////////////////////////////////////////////////////////////
1: 	final String myReturnType;
/////////////////////////////////////////////////////////////////////////
1:         boolean splittingZeroStack = true;
/////////////////////////////////////////////////////////////////////////
1:             if (splittingZeroStack)
1:             {
1:                 split_pc = myCode.splitZeroStack(this, modClass, split_pc,
1:             }
1:             else
1:             {
0:                 //TODO: re-start split at point left off
0:                 //split_pc = myCode.splitExpressionOut(this, modClass,
0:                 //        optimalMinLength, maxStack);
1:                 
0:                 // DERBY-766 temp - don't call the split method yet.
0:                 split_pc = -1;
1:             }
1:             // the next approach.
1:                 if (!splittingZeroStack)
1:                    break;
1:                 splittingZeroStack = false;
1:                 split_pc = 0;
1:         
1:  
commit:0d42361
/////////////////////////////////////////////////////////////////////////
1:                     optimalMinLength);
commit:b8ef064
/////////////////////////////////////////////////////////////////////////
1: 		myCode = new CodeChunk(this.cb);
/////////////////////////////////////////////////////////////////////////
1:         
commit:51cefa2
/////////////////////////////////////////////////////////////////////////
1:         // myCode.getPC() gives the code length since
1:         // the program counter will be positioned after
1:         // the last instruction. Note this value can
1:         // be changed by the splitMethod call.
1:         if (myCode.getPC() > CODE_SPLIT_LENGTH)
1:                          
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Push an integer value. Uses the special integer opcodes
1:      * for the constants -1 to 5, BIPUSH for values that fit in
1:      * a byte and SIPUSH for values that fit in a short. Otherwise
1:      * uses LDC with a constant pool entry.
1:      * 
1:      * @param value Value to be pushed
1:      * @param type Final type of the value.
1:      */
/////////////////////////////////////////////////////////////////////////
1: 		growStack(type.width(), type);
1:     /**
1:      * Push a long value onto the stack.
1:      * For the values zero and one the LCONST_0 and
1:      * LCONST_1 instructions are used.
1:      * For values betwee Short.MIN_VALUE and Short.MAX_VALUE
1:      * inclusive an byte/short/int value is pushed
1:      * using push(int, Type) followed by an I2L instruction.
1:      * This saves using a constant pool entry for such values.
1:      * All other values use a constant pool entry. For values
1:      * in the range of an Integer an integer constant pool
1:      * entry is created to allow sharing with integer constants
1:      * and to reduce constant pool slot entries.
1:      */
1: 	public void push(long value) {
1:         CodeChunk chunk = myCode;
1:         if (value == 0L || value == 1L) {
1:             short opcode = value == 0L ? VMOpcode.LCONST_0 : VMOpcode.LCONST_1;
1:             chunk.addInstr(opcode);
1:         } else if (value >= Integer.MIN_VALUE && value <= Integer.MAX_VALUE) {
1:             // the push(int, Type) method grows the stack for us.
1:             push((int) value, Type.LONG);
1:             chunk.addInstr(VMOpcode.I2L);
1:             return;
1:         } else {
1:             int cpe = modClass.addConstant(value);
1:             chunk.addInstrU2(VMOpcode.LDC2_W, cpe);
1:         }
1:         growStack(2, Type.LONG);
1:     }
commit:ee1cc94
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Code length at which to split into sub-methods.
1:      * Normally set to the maximim code length the
1:      * JVM can support, but for testing the split code
1:      * it can be reduced so that the standard tests
1:      * cause some splitting. Tested with value set to 2000.
1:      */
1:     static final int CODE_SPLIT_LENGTH = VMOpcode.MAX_CODE_LENGTH;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Fast access for the parametes, will be null
1:      * if the method has no parameters.
1:      */
1: 	BCLocalField[] parameters; 
1:     
1:     /**
1:      * List of parameter types with java language class names.
1:      * Can be null or zero length for no parameters.
1:      */
1:     private final String[] parameterTypes;
1:     
1:     
0: 	Vector thrownExceptions; // expected to be names of Classes under Throwable
/////////////////////////////////////////////////////////////////////////
1: 		if (parms != null && parms.length != 0) {
/////////////////////////////////////////////////////////////////////////
1:         
1:         parameterTypes = parms;
/////////////////////////////////////////////////////////////////////////
1:         
1:         
0:         int codeLength = myCode.getPC();
0:         if (codeLength > CODE_SPLIT_LENGTH)
1:             splitMethod();
1:                   
1:        // write exceptions attribute info
1:         writeExceptions();
1:         	
1:     
1:     /**
1:      * Attempt to split a large method by pushing code out to several
1:      * sub-methods. Performs a number of steps.
1:      * <OL>
1:      * <LI> Split at zero stack depth.
1:      * <LI> Split at non-zero stack depth (FUTURE)
1:      * </OL>
1:      * 
1:      * If the class has already exceeded some limit in building the
1:      * class file format structures then don't attempt to split.
1:      * Most likely the number of constant pool entries has been exceeded
1:      * and thus the built class file no longer has integrity.
1:      * The split code relies on being able to read the in-memory
1:      * version of the class file in order to determine descriptors
1:      * for methods and fields.
1:      */
1:     private void splitMethod() {
1:         
1:         int split_pc = 0;
1:         for (int codeLength = myCode.getPC();
1:                (cb.limitMsg == null) &&
1:                (codeLength > CODE_SPLIT_LENGTH);
1:             codeLength = myCode.getPC())
1:         {
1:             int lengthToCheck = codeLength - split_pc;
1: 
1:             int optimalMinLength;
1:             if (codeLength < CODE_SPLIT_LENGTH * 2) {
1:                 // minimum required
1:                 optimalMinLength = codeLength - CODE_SPLIT_LENGTH;
1:             } else {
1:                 // try to split as much as possible
1:                 // need one for the return instruction
1:                 optimalMinLength = CODE_SPLIT_LENGTH - 1;
1:             }
1: 
1:             if (optimalMinLength > lengthToCheck)
1:                 optimalMinLength = lengthToCheck;
1: 
0:             split_pc = myCode.splitZeroStack(this, modClass, split_pc,
0:                     lengthToCheck, optimalMinLength);
1: 
1:             // Negative split point returned means that no split
1:             // was possible. Give up on this approach and goto
0:             // the next approach (none-yet).
1:             if (split_pc < 0) {
0:                 break;
1:             }
1: 
1:             // success, continue on splitting after the call to the
1:             // sub-method if the method still execeeds the maximum length.
1:         }
1:     }
1:      * class interface
1:      */
1:      * In their giveCode methods, the parts of the method body will want to get
1:      * to the constant pool to add their constants. We really only want them
1:      * treating it like a constant pool inclusion mechanism, we could write a
1:      * wrapper to limit it to that.
1:      */
/////////////////////////////////////////////////////////////////////////
1: 	int maxStack;
/////////////////////////////////////////////////////////////////////////
1: 			addInstrCPE(VMOpcode.LDC, cpe);
/////////////////////////////////////////////////////////////////////////
1: 			addInstrCPE(VMOpcode.LDC, cpe);
/////////////////////////////////////////////////////////////////////////
1: 		addInstrCPE(VMOpcode.LDC, cpe);
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Write a instruction that uses a constant pool entry
1:      * as an operand, add a limit exceeded message if
1:      * the number of constant pool entries has exceeded
1:      * the limit.
1:      */
1:     private void addInstrCPE(short opcode, int cpe)
1:     {
1:         if (cpe >= VMOpcode.MAX_CONSTANT_POOL_ENTRIES)
1:             cb.addLimitExceeded(this, "constant_pool_count",
1:                     VMOpcode.MAX_CONSTANT_POOL_ENTRIES, cpe);
1:         
1:         myCode.addInstrCPE(opcode, cpe);
1:     }
/////////////////////////////////////////////////////////////////////////
1: 		{
1: 		}
/////////////////////////////////////////////////////////////////////////
1: 				
1:         		
1: 		BCMethod subMethod = getNewSubMethod(myReturnType, false);
1:         callSubMethod(subMethod);
/////////////////////////////////////////////////////////////////////////
1: 	
1:     /**
1:      * Create a sub-method from this method to allow the code builder to split a
1:      * single logical method into multiple methods to avoid the 64k per-method
1:      * code size limit. The sub method with inherit the thrown exceptions of
1:      * this method.
1:      * 
1:      * @param returnType
1:      *            Return type of the new method
1:      * @param withParameters
1:      *            True to define the method with matching parameters false to
1:      *            define it with no parameters.
1:      * @return A valid empty sub method.
1:      */
1:     final BCMethod getNewSubMethod(String returnType, boolean withParameters) {
1:         int modifiers = myEntry.getModifier();
1: 
1:         // the sub-method can be private to ensure that no-one
1:         // can call it accidentally from outside the class.
1:         modifiers &= ~(Modifier.PROTECTED | Modifier.PUBLIC);
1:         modifiers |= Modifier.PRIVATE;
1: 
1:         String subMethodName = myName + "_s"
1:                 + Integer.toString(subMethodCount++);
1:         BCMethod subMethod = (BCMethod) cb.newMethodBuilder(modifiers,
1:                 returnType, subMethodName, withParameters ? parameterTypes
1:                         : null);
1:         subMethod.thrownExceptions = this.thrownExceptions;
1: 
1:         return subMethod;
1:     }
1: 
1:     /**
1:      * Call a sub-method created by getNewSubMethod handling parameters
1:      * correctly.
1:      */
1:     final void callSubMethod(BCMethod subMethod) {
1:         // in this method make a call to the sub method we will
1:         // be transferring control to.
1:         short op;
1:         if ((myEntry.getModifier() & Modifier.STATIC) == 0) {
1:             op = VMOpcode.INVOKEVIRTUAL;
1:             this.pushThis();
1:         } else {
1:             op = VMOpcode.INVOKESTATIC;
1:         }
1: 
1:         int parameterCount = subMethod.parameters == null ? 0
1:                 : subMethod.parameters.length;
1: 
1:         // push my parameter values for the call.
1:         for (int pi = 0; pi < parameterCount; pi++)
1:             this.getParameter(pi);
1: 
1:         this.callMethod(op, modClass.getName(), subMethod.getName(),
1:                 subMethod.myReturnType, parameterCount);
1:     }
commit:af01856
/////////////////////////////////////////////////////////////////////////
0: 		myCode = new CodeChunk();
/////////////////////////////////////////////////////////////////////////
1: 			if (myCode.getPC() != 0)
/////////////////////////////////////////////////////////////////////////
1: 		int currentCodeSize = myCode.getPC();
commit:38fe427
/////////////////////////////////////////////////////////////////////////
1: 		myCode.complete(this, modClass, myEntry, maxStack, currentVarNum);
/////////////////////////////////////////////////////////////////////////
1: 		Type[] entryStack = condition.startElse(this, myCode, copyStack());
/////////////////////////////////////////////////////////////////////////
1: 		condition = condition.end(this, myCode, stackTypes, stackTypeOffset);
commit:4549ad4
/////////////////////////////////////////////////////////////////////////
1: class BCMethod implements MethodBuilder {
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * Array of the current types of the values on the stack.
1: 	 * A type that types up two words on the stack, e.g. double
1: 	 * will only occupy one element in this array.
1: 	 * This array is dynamically re-sized as needed.
1: 	 */
1: 	
1: 	/**
1: 	 * Points to the next array offset in stackTypes
1: 	 * to be used. Really it's the number of valid entries
1: 	 * in stackTypes.
1: 	 */
1: 	/**
1: 	 * Maximum stack depth seen in this method, measured in words.
1: 	 * Corresponds to max_stack in the Code attribute of section 4.7.3
1: 	 * of the vm spec.
1: 	 */
1: 	
1: 	/**
1: 	 * Current stack depth in this method, measured in words.
1: 	 */
/////////////////////////////////////////////////////////////////////////
1: 	
1: 	private Type[] copyStack()
1: 	{
1: 		Type[] stack = new Type[stackTypeOffset];
1: 		System.arraycopy(stackTypes, 0, stack, 0, stackTypeOffset);
1: 		return stack;
1: 	}
/////////////////////////////////////////////////////////////////////////
1: 		
1: 		// Save the stack upon entry to the 'then' block of the
1: 		// 'if' so that we can set up the 'else' block with the
1: 		// correct stack on entry.
1: 		condition = new Conditional(condition, myCode, opcode, copyStack());
1: 		
1: 		// start the else code
0: 		Type[] entryStack = condition.startElse(myCode, copyStack());
1: 		
1: 		for (int i = stackDepth = 0; i  < entryStack.length; i++)
1: 		{
1: 			stackDepth += (stackTypes[i] = entryStack[i]).width();
1: 		this.stackTypeOffset = entryStack.length;
0: 		condition = condition.end(myCode, stackTypes, stackTypeOffset);
commit:c7c8b2d
/////////////////////////////////////////////////////////////////////////
1: 		
1: 		// Perform a simple optimization to not
1: 		// insert a checkcast when the classname
1: 		// of the cast exactly matches the type name
1: 		// currently on the stack.
1: 		// This can reduce the amount of generated code.
1: 		// This compiler/class generator does not load
1: 		// classes to check relationships or any other
1: 		// information. Thus other optimizations where a cast
1: 		// is not required are not implemented.
1: 		Type tbc = stackTypes[stackTypeOffset - 1];
1: 		
1: 		
1: 		if (sourceType == BCExpr.vm_reference)
1: 		{
1: 			// Simple optimize step
1: 			if (className.equals(tbc.javaName()))
1: 			{
1: 				// do nothing, exact matching type
1: 				return;
1: 			}
1: 		}
1: 		
1: 		Type ct = cb.factory.type(className);
1: 		popStack();
1: 		
commit:afa871e
/////////////////////////////////////////////////////////////////////////
1: 		
/////////////////////////////////////////////////////////////////////////
1: 	
1: 	/**
1: 	 * Set the field but don't duplicate its value so
1: 	 * nothing is left on the stack after this call.
1: 	 */
1: 	public void setField(LocalField field) {
1: 		BCLocalField lf = (BCLocalField) field;
1: 		Type lt = lf.type;
1: 
1: 		putField(lf.type, lf.cpi, false);
1: 
1: 		if (stackDepth == 0)
0: 			overflowMethodCheck();
1: 	}
/////////////////////////////////////////////////////////////////////////
1: 		putField(lf.type, lf.cpi, true);
/////////////////////////////////////////////////////////////////////////
1: 		putField(ft, cpi, true);
1: 	private void putField(Type fieldType, int cpi, boolean dup) {
1: 		if (dup)
1: 		{
1: 			myCode.addInstr(fieldType.width() == 2  ? VMOpcode.DUP2 : VMOpcode.DUP);
1: 			growStack(fieldType);
1: 		// now have
1: 		// dup true:  ...,value,value
1: 		// dup false: ...,value,
1: 
1: 		pushThis();
1: 		// now have
1: 		// dup true:  ...,value,value,this
1: 		// dup false: ...,value,this
1: 
1: 		swap();
1: 		// now have
1: 		// dup true:  ...,value,this,value
1: 		// dup false: ...,this,value
1: 
1: 
1: 		// now have
1: 		// dup true:  ...,value
1: 		// dup false: ...
commit:d30bf1c
/////////////////////////////////////////////////////////////////////////
0:    Copyright 1997, 2005 The Apache Software Foundation or its licensors, as applicable.
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 	private final String myReturnType;
1: 	
1: 	/**
1: 	 * The original name of the method, this
1: 	 * represents how any user would call this method.
1: 	 */
1: 	private final String myName;
1: 	CodeChunk myCode;
1: 	/**
1: 	 * True if we are currently switching control
1: 	 * over to a sub method to avoid hitting the code generation
1: 	 * limit of 65535 bytes per method.
1: 	 */
1: 	private boolean handlingOverflow;
1: 	
1: 	/**
1: 	 * How many sub-methods we have overflowed to.
1: 	 */
1: 	private int subMethodCount;
1: 
/////////////////////////////////////////////////////////////////////////
1: 		myReturnType = returnType;
1: 		myName = methodName;
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * Return the logical name of the method. The current
1: 	 * myEntry refers to the sub method we are currently
1: 	 * overflowing to. Those sub-methods are hidden from any caller.
1: 	 */
1: 		return myName;
/////////////////////////////////////////////////////////////////////////
1: 		
1: 		// cannot add exceptions after code generation has started.
1: 		// Allowing this would cause the method overflow/split to
1: 		// break as the top-level method would not have the exception
1: 		// added in the sub method.
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			if (myCode.getRelativePC() != 0)
1: 				SanityManager.THROWASSERT("Adding exception after code generation " + exceptionClass
1: 						+ " to method " + getName());
1: 		}
/////////////////////////////////////////////////////////////////////////
1: 		else
1: 		{
0: 			if (stackDepth == 0)
0: 				overflowMethodCheck();
1: 		}
/////////////////////////////////////////////////////////////////////////
1: 		else
1: 		{
0: 			if (stackDepth == 0)
0: 				overflowMethodCheck();
1: 		}
/////////////////////////////////////////////////////////////////////////
1: 		
0: 		if (stackDepth == 0)
0: 			overflowMethodCheck();
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * Check to see if the current method byte code is nearing the
1: 	 * limit of 65535. If it is start overflowing to a new method.
1: 	 * <P>
1: 	 * Overflow is handled for a method named e23 as:
1: 	 * <CODE>
1: 	 public Object e23()
1: 	 {
1: 	   ... existing code
1: 	   // split point
1: 	   return e23_0();
1: 	 }
1: 	 private Object e23_0()
1: 	 {
1: 	    ... first set overflowed code
1: 	    // split point
1: 	    return e23_1(); 
1: 	 }
1: 	 private Object e23_1()
1: 	 {
1: 	    ... second set overflowed code
1: 	    // method complete
1: 	    return result; 
1: 	 }
1: 	 	 </CODE>
1: 	 <P>
1: 	 
1: 	 These overflow methods are hidden from the code using this MethodBuilder,
1: 	 it continues to think that it is building a single method with the
1: 	 original name.
1: 
1: 
1: 	 * <BR> Restrictions:
1: 	 * <UL>
1: 	 * <LI> Only handles methods with no arguments
1: 	 * <LI> Stack depth must be zero
1: 	 * </UL>
1: 	 * 
1: 	 *
1: 	 */
1: 	private void overflowMethodCheck()
1: 	{
1: 		if (handlingOverflow)
1: 			return;
1: 		
1: 		// don't sub method in the middle of a conditional
1: 		if (condition != null)
1: 			return;
1: 		
0: 		int currentCodeSize = myCode.getRelativePC();
1: 		
1: 		// Overflow at >= 55,000 bytes which is someway
1: 		// below the limit of 65,535. Ideally overflow
1: 		// would occur at 65535 minus the few bytes needed
1: 		// to call the sub-method, but the issue is at this level
1: 		// we don't know frequently we are called given the restriction
1: 		// of only being called when the stack depth is zero.
1: 		// Thus split earlier to try ensure most cases are caught.
1: 		// Only downside is that we may split into N methods when N-1 would suffice.
1: 		if (currentCodeSize < 55000)
1: 			return;
1: 		
1: 		// only handle no-arg methods at the moment.
1: 		if (parameters != null)
1: 		{
1: 			if (parameters.length != 0)
1: 				return;
1: 		}
1: 		
0: 		int modifiers = myEntry.getModifier();	
0: 		//System.out.println("NEED TO SPLIT " + myEntry.getName() + "  " + currentCodeSize + " stack " + stackDepth);
1: 
0: 		// the sub-method can be private to ensure that no-one
0: 		// can call it accidentally from outside the class.
0: 		modifiers &= ~(Modifier.PROTECTED | Modifier.PUBLIC);
0: 		modifiers |= Modifier.PRIVATE;
1: 		
0: 		String subMethodName = myName + "_s" + Integer.toString(subMethodCount++);
0: 		BCMethod subMethod = (BCMethod) cb.newMethodBuilder(
0: 				modifiers,
0: 				myReturnType, subMethodName);
0: 		subMethod.thrownExceptions = this.thrownExceptions;
1: 				
1: 		// stop any recursion
1: 		handlingOverflow = true;
1: 		
1: 		// in this method make a call to the sub method we will
1: 		// be transferring control to.
0: 		short op;
0: 		if ((modifiers & Modifier.STATIC) == 0)
1: 		{
0: 			op = VMOpcode.INVOKEVIRTUAL;
0: 			this.pushThis();
1: 		} else {
0: 			op = VMOpcode.INVOKESTATIC;
1: 		}
1: 		
0: 		this.callMethod(op, (String) null, subMethodName, myReturnType, 0);
1: 	
1: 		// and return its value, works just as well for a void method!
1: 		this.methodReturn();
1: 		this.complete();
1: 		
1: 		handlingOverflow = false;
1: 		
1: 		// now the tricky bit, make this object take over the
1: 		// code etc. from the sub method. This is done so
1: 		// that any code that has a reference to this MethodBuilder
1: 		// will continue to work. They will be writing code into the
1: 		// new sub method.
1: 		
1: 		this.myEntry = subMethod.myEntry;
1: 		this.myCode = subMethod.myCode;
1: 		this.currentVarNum = subMethod.currentVarNum;
1: 		this.statementNum = subMethod.statementNum;
1: 		
1: 		// copy stack info
1: 		this.stackTypes = subMethod.stackTypes;
1: 		this.stackTypeOffset = subMethod.stackTypeOffset;
1: 		this.maxStack = subMethod.maxStack;
1: 		this.stackDepth = subMethod.stackDepth;
1: 	}
commit:d6e8491
/////////////////////////////////////////////////////////////////////////
1: 	
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	
1: 	public void pop() {
1: 		if (SanityManager.DEBUG) {
0: 			if (stackDepth == 0)
1: 				SanityManager.THROWASSERT("pop when stack is empty!");
1: 		}
1: 		Type toPop = popStack();
1: 
1: 		myCode.addInstr(toPop.width() == 2  ? VMOpcode.POP2 : VMOpcode.POP);
1: 
1: 	}	
1: 			pop();
/////////////////////////////////////////////////////////////////////////
1: 	
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.services.bytecode.BCMethod
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:1f9b9c4
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.services.bytecode
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.services.bytecode;
1: 
0: import org.apache.derby.iapi.services.monitor.Monitor;
1: import org.apache.derby.iapi.services.compiler.ClassBuilder;
1: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1: import org.apache.derby.iapi.services.classfile.ClassFormatOutput;
1: import org.apache.derby.iapi.services.compiler.LocalField;
1: import org.apache.derby.iapi.services.classfile.ClassHolder;
1: import org.apache.derby.iapi.services.classfile.ClassMember;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: import org.apache.derby.iapi.services.classfile.VMDescriptor;
1: import org.apache.derby.iapi.services.classfile.VMOpcode;
1: 
1: import java.lang.reflect.Modifier;
1: import java.util.Vector;
1: import java.io.IOException;
1: 
1: /**
1:  * MethodBuilder is used to piece together a method when
1:  * building a java class definition.
1:  * <p>
1:  * When a method is first created, it has:
1:  * <ul>
1:  * <li> a return type
1:  * <li> modifiers
1:  * <li> a name
1:  * <li> an empty parameter list
1:  * <li> an empty throws list
1:  * <li> an empty statement block
1:  * </ul>
1:  * <p>
1:  * MethodBuilder implementations are required to supply a way for
1:  * Statements and Expressions to give them code.  Most typically, they may have
1:  * a stream to which their contents writes the code that is of
1:  * the type to satisfy what the contents represent.
1:  * MethodBuilder implementations also have to have a way to supply
1:  * ClassBuilders with their code, that satisfies the type of class
1:  * builder they are implemented with.  This is implementation-dependent,
1:  * so ClassBuilders, MethodBuilders, Statements, and Expressions all have
1:  * to be of the same implementation in order to interact to generate a class.
1:  * <p>
1:  * Method Builder implementation for generating bytecode.
1:  *
1:  */
0: public class BCMethod implements MethodBuilder {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 
1: 	final BCClass		cb;
1: 	protected final ClassHolder modClass; // the class it is in (modifiable fmt)
1: 
0: 	protected BCLocalField[] parameters; 
0: 	protected Vector thrownExceptions; // expected to be names of Classes under Throwable
1: 
0: 	final CodeChunk myCode;
1: 	protected ClassMember myEntry;
1: 
1: 	private int currentVarNum;
1: 	private int statementNum;
1: 
1: 	BCMethod(ClassBuilder cb,
1: 			String returnType,
1: 			String methodName,
1: 			int modifiers,
1: 			String[] parms,
1: 			BCJava factory) {
1: 
1: 		this.cb = (BCClass) cb;
1: 		modClass = this.cb.modify();
0: 		//this.modifiers = modifiers;
1: 
1: 		if (SanityManager.DEBUG) {
1:    			this.cb.validateType(returnType);
1: 		}
1: 
1: 		// if the method is not static, allocate for "this".
1: 		if ((modifiers & Modifier.STATIC) == 0 )
1: 			currentVarNum = 1;
1: 
1: 		String[] vmParamterTypes;
1: 
0: 		if (parms != null) {
1: 			int len = parms.length;
1: 			vmParamterTypes = new String[len];
1: 			parameters = new BCLocalField[len];
1: 			for (int i = 0; i < len; i++) {
1: 				Type t = factory.type(parms[i]);
1: 				parameters[i] = new BCLocalField(t, currentVarNum);
1: 				currentVarNum += t.width();
1: 
1: 				// convert to vmname for the BCMethodDescriptor.get() call
1: 				vmParamterTypes[i] = t.vmName();
1: 			}
1: 		}
1: 		else
1: 			vmParamterTypes = BCMethodDescriptor.EMPTY;
1: 
1: 		// create a code attribute
1: 		String sig = BCMethodDescriptor.get(vmParamterTypes, factory.type(returnType).vmName(), factory);
1: 
1: 		// stuff the completed information into the class.
1: 		myEntry = modClass.addMember(methodName, sig, modifiers);
1: 
1: 		// get code chunk
0: 		myCode = new CodeChunk(true);
1: 	}
1: 	//
1: 	// MethodBuilder interface
1: 	//
1: 
1: 	public String getName() {
0: 		return myEntry.getName();
1: 	}
1: 
1: 	public void getParameter(int id) {
1: 
1: 		int num = parameters[id].cpi;
1: 		short typ = parameters[id].type.vmType();
1: 		if (num < 4)
1: 			myCode.addInstr((short) (CodeChunk.LOAD_VARIABLE_FAST[typ]+num));
1: 		else
1: 			myCode.addInstrWide(CodeChunk.LOAD_VARIABLE[typ], num);
1: 
1: 		growStack(parameters[id].type);
1: 	}
1: 
1: 	/**
1: 	 * a throwable can be added to the end of
1: 	 * the list of thrownExceptions.
1: 	 */
1: 	public void addThrownException(String exceptionClass) {
1: 
1: 		if (thrownExceptions == null)
0: 			thrownExceptions = new Vector();
0: 		thrownExceptions.addElement(exceptionClass);
1: 	}
1: 
1: 	/**
1: 	 * when the method has had all of its parameters
1: 	 * and thrown exceptions defined, and its statement
1:  	 * block has been completed, it can be completed and
1: 	 * its class file information generated.
1: 	 * <p>
1: 	 * further alterations of the method will not be
1: 	 * reflected in the code generated for it.
1: 	 */
1: 	public void complete() {
0: 		// write exceptions attribute info
0: 		writeExceptions();
1: 
1: 		// get the code attribute to put itself into the class
1: 		// provide the final header information needed
0: 		myCode.complete(modClass, myEntry, maxStack, currentVarNum);
1: 	}
1: 
1: 	/*
0: 	 * class interface
1: 	 */
1: 
1: 	/**
0: 	 * In their giveCode methods, the parts of the method body
0: 	 * will want to get to the constant pool to add their constants.
0: 	 * We really only want them treating it like a constant pool
0: 	 * inclusion mechanism, we could write a wrapper to limit it to that.
1: 	 */
1: 	ClassHolder constantPool() {
1: 		return modClass;
1: 	}
1: 
1: 
1:     //
1:     // Class implementation
1:     //
1: 
1: 
1: 	/**
1: 	 * sets exceptionBytes to the attribute_info needed
1: 	 * for a method's Exceptions attribute.
1: 	 * The ClassUtilities take care of the header 6 bytes for us,
1: 	 * so they are not included here.
1: 	 * See The Java Virtual Machine Specification Section 4.7.5,
1: 	 * Exceptions attribute.
1: 	 */
1: 	protected void writeExceptions() {
1: 		if (thrownExceptions == null)
1: 			return;
1: 
1: 		int numExc = thrownExceptions.size();
1: 
1: 		// don't write an Exceptions attribute if there are no exceptions.
1: 		if (numExc != 0) {
1: 
1: 			try{
1: 				ClassFormatOutput eout = new ClassFormatOutput((numExc * 2) + 2);
1: 
1: 				eout.putU2(numExc); // number_of_exceptions
1: 
1: 				for (int i = 0; i < numExc; i++) {
1: 					// put each exception into the constant pool
0: 					String e = thrownExceptions.elementAt(i).toString();
1: 					int ei2 = modClass.addClassReference(e);
1: 
1: 					// add constant pool index to exception attribute_info
1: 					eout.putU2(ei2);
1: 				}
1: 
1: 				myEntry.addAttribute("Exceptions", eout);
1: 
1: 			} catch (IOException ioe) {
1: 			}			
1: 		}
1: 	}
1: 
1: 	/*
1: 	** New push compiler api.
1: 	*/
1: 
1: 	private Type[]	stackTypes = new Type[8];
1: 	private int     stackTypeOffset;
1: 
0: 	private int maxStack;
1: 	private int stackDepth;
0: 	// public Stack stackTypes = new Stack();
1: 
1: 	private void growStack(int size, Type type) {
1: 		stackDepth += size;
1: 		if (stackDepth > maxStack)
1: 			maxStack = stackDepth;
1: 		
1: 		if (stackTypeOffset >= stackTypes.length) {
1: 
1: 			Type[] newStackTypes = new Type[stackTypes.length + 8];
1: 			System.arraycopy(stackTypes, 0, newStackTypes, 0, stackTypes.length);
1: 			stackTypes = newStackTypes;
1: 		}
1: 
1: 		stackTypes[stackTypeOffset++] = type;
1: 
1: 		if (SanityManager.DEBUG) {
1: 
1: 			int sum = 0;
1: 			for (int i = 0 ; i < stackTypeOffset; i++) {
1: 				sum += stackTypes[i].width();
1: 			}
1: 			if (sum != stackDepth) {
1: 				SanityManager.THROWASSERT("invalid stack depth " + stackDepth + " calc " + sum);
1: 			}
1: 		}
1: 	}
1: 
1: 	private void growStack(Type type) {
1: 		growStack(type.width(), type);
1: 	}
1: 
1: 	private Type popStack() {
1: 		stackTypeOffset--;
1: 		Type topType = stackTypes[stackTypeOffset];
1: 		stackDepth -= topType.width();
1: 		return topType;
1: 
1: 	}
1: 
1: 	public void pushThis() {
1: 		myCode.addInstr(VMOpcode.ALOAD_0);
1: 		growStack(1, cb.classType);
1: 	}
1: 
1: 	public void push(byte value) {
1: 		push(value, Type.BYTE);
1: 	}
1: 
1: 	public void push(boolean value) {
1: 		push(value ? 1 : 0, Type.BOOLEAN);
1: 	}
1: 
1: 	public void push(short value) {
1: 		push(value, Type.SHORT);
1: 	}
1: 
1: 	public void push(int value) {
1: 		push(value, Type.INT);
1: 	}
1: 
1: 	public void dup() {
1: 		Type dup = popStack();
1: 		myCode.addInstr(dup.width() == 2  ? VMOpcode.DUP2 : VMOpcode.DUP);
1: 		growStack(dup);
1: 		growStack(dup);
1: 
1: 	}
1: 
1: 	public void swap() {
1: 
1: 		// have A,B
1: 		// want B,A
1: 
1: 		Type wB = popStack();
1: 		Type wA = popStack();
1: 		growStack(wB);
1: 		growStack(wA);
1: 
1: 		if (wB.width() == 1) {
1: 			// top value is one word
1: 			if (wA.width() == 1) {
1: 				myCode.addInstr(VMOpcode.SWAP);
1: 				return;
1: 			} else {
1: 				myCode.addInstr(VMOpcode.DUP_X2);
1: 				myCode.addInstr(VMOpcode.POP);
1: 			}
1: 		} else {
1: 			// top value is two words
1: 			if (wA.width() == 1) {
1: 				myCode.addInstr(VMOpcode.DUP2_X1);
1: 				myCode.addInstr(VMOpcode.POP2);
1: 			} else {
1: 				myCode.addInstr(VMOpcode.DUP2_X2);
1: 				myCode.addInstr(VMOpcode.POP2);
1: 			}
1: 		}
1: 
1: 		// all except the simple swap push an extra
1: 		// copy of B which needs to be popped.
1: 		growStack(wB);
1: 		popStack();
1: 
1: 	}
1: 
1: 	private void push(int value, Type type) {
1: 
1: 		CodeChunk chunk = myCode;
1: 
1: 		if (value >= -1 && value <= 5)
1: 			chunk.addInstr((short)(VMOpcode.ICONST_0+value));
1: 		else if (value >= Byte.MIN_VALUE && value <= Byte.MAX_VALUE)
1: 			chunk.addInstrU1(VMOpcode.BIPUSH,value);
1: 		else if (value >= Short.MIN_VALUE && value <= Short.MAX_VALUE)
1: 			chunk.addInstrU2(VMOpcode.SIPUSH,value);
1: 		else {
1: 			int cpe = modClass.addConstant(value);
0: 			chunk.addInstrCPE(VMOpcode.LDC, cpe);
1: 		}
0: 		growStack(1, type);
1: 		
1: 	}
1: 
0: 	public void push(long value){
1: 		CodeChunk chunk = myCode;
1: 
0: 		if (value == 0 || value == 1) {
0: 				chunk.addInstr((short)(VMOpcode.LCONST_0+(short)value));
1: 		}
1: 		else {
1: 			int cpe = modClass.addConstant(value);
1: 			chunk.addInstrU2(VMOpcode.LDC2_W, cpe);
1: 		}
0: 		growStack(2, Type.LONG);
1: 
1: 	}
1: 	public void push(float value) {
1: 
1: 		CodeChunk chunk = myCode;
1: 		
1: 		if (value == 0.0)
1: 		{
1: 			chunk.addInstr(VMOpcode.FCONST_0);
1: 		}
1: 		else if (value == 1.0)
1: 		{
1: 			chunk.addInstr(VMOpcode.FCONST_1);
1: 		}
1: 		else if (value == 2.0)
1: 		{
1: 			chunk.addInstr(VMOpcode.FCONST_2);
1: 		}
1: 		else 
1: 		{
1: 			int cpe = modClass.addConstant(value);
0: 			chunk.addInstrCPE(VMOpcode.LDC, cpe);
1: 		}
1: 		growStack(1, Type.FLOAT);
1: 	}
1: 
1: 	public void push(double value) {
1: 		CodeChunk chunk = myCode;
1: 
1: 		if (value == 0.0) {
1: 				chunk.addInstr(VMOpcode.DCONST_0);
1: 		}
1: 		else {
1: 			int cpe = modClass.addConstant(value);
1: 			chunk.addInstrU2(VMOpcode.LDC2_W, cpe);
1: 		}
1: 		growStack(2, Type.DOUBLE);
1: 	}
1: 	public void push(String value) {
1: 		int cpe = modClass.addConstant(value);
0: 		myCode.addInstrCPE(VMOpcode.LDC, cpe);
1: 		growStack(1, Type.STRING);
1: 	}
1:  
1: 
1: 	public void methodReturn() {
1: 
1: 		short opcode;		
1: 		if (stackDepth != 0) {
1: 			Type topType = popStack();
1: 			opcode = CodeChunk.RETURN_OPCODE[topType.vmType()];
1: 		} else {
1: 			opcode = VMOpcode.RETURN;
1: 		}
1: 
1: 		myCode.addInstr(opcode);
1: 
1: 		if (SanityManager.DEBUG) {
1: 			if (stackDepth != 0)
1: 				SanityManager.THROWASSERT("items left on stack " + stackDepth);
1: 		}
1: 	}
1: 
1: 	public Object describeMethod(short opcode, String declaringClass, String methodName, String returnType) {
1: 
1: 		Type rt = cb.factory.type(returnType);
1: 
1: 		String methodDescriptor = BCMethodDescriptor.get(BCMethodDescriptor.EMPTY, rt.vmName(), cb.factory);
1: 
1: 		if ((declaringClass == null) && (opcode != VMOpcode.INVOKESTATIC)) {
1: 
1: 			Type dt = stackTypes[stackTypeOffset - 1];
1: 
1: 			if (declaringClass == null)
1: 				declaringClass = dt.javaName();
1: 		}
1: 		
1: 		int cpi = modClass.addMethodReference(declaringClass, methodName,
1: 				methodDescriptor, opcode == VMOpcode.INVOKEINTERFACE);
1: 
1: 		return new BCMethodCaller(opcode, rt, cpi);
1: 	}
1: 
1: 	public int callMethod(Object methodDescriptor) {
1: 
1: 		// pop the reference off the stack
1: 		popStack();
1: 
1: 		BCMethodCaller mc = (BCMethodCaller) methodDescriptor;
1: 
1: 		int cpi = mc.cpi;
1: 		short opcode = mc.opcode;
1: 
1: 		if (opcode == VMOpcode.INVOKEINTERFACE) {
1: 			myCode.addInstrU2U1U1(opcode, cpi, (short) 1, (short) 0);
1: 		}
1: 		else
1: 			myCode.addInstrU2(opcode, cpi);
1: 		
1: 		// this is the return type of the method
1: 		Type rt = mc.type;
1: 		int rw = rt.width();
1: 		if (rw != 0)
1: 			growStack(rw, rt);
1: 
1: 		return cpi;
1: 	}
1: 
1: 	public int callMethod(short opcode, String declaringClass, String methodName,
1: 		String returnType, int numArgs) {
1: 
1: 		Type rt = cb.factory.type(returnType);
1: 
1: 		int initialStackDepth = stackDepth;
1: 
1: 		// get the array of parameter types
1: 
1: 		String [] debugParameterTypes = null;
1: 		String[] vmParameterTypes;
1: 		if (numArgs == 0) {
1: 			vmParameterTypes = BCMethodDescriptor.EMPTY;
1: 		} else {
1: 			if (SanityManager.DEBUG) {
1: 				debugParameterTypes = new String[numArgs];
1: 			}
1: 			vmParameterTypes = new String[numArgs];
1: 			for (int i = numArgs - 1; i >= 0; i--) {
1: 				Type at = popStack();
1: 
1: 				vmParameterTypes[i] = at.vmName();
1: 				if (SanityManager.DEBUG) {
1: 					debugParameterTypes[i] = at.javaName();
1: 				}
1: 			}
1: 		}
1: 		
1: 		String methodDescriptor = BCMethodDescriptor.get(vmParameterTypes, rt.vmName(), cb.factory);
1: 
1: 		Type dt = null;
1: 		if (opcode != VMOpcode.INVOKESTATIC) {
1: 
1: 			dt = popStack();
1: 		}
1: 		Type dtu = vmNameDeclaringClass(declaringClass);
1: 		if (dtu != null)
1: 			dt = dtu;
1: 		
1: 		int cpi = modClass.addMethodReference(dt.vmNameSimple, methodName,
1: 				methodDescriptor, opcode == VMOpcode.INVOKEINTERFACE);
1: 
1: 		if (opcode == VMOpcode.INVOKEINTERFACE) {
1: 			short callArgCount = (short) (initialStackDepth - stackDepth);
1: 			myCode.addInstrU2U1U1(opcode, cpi, callArgCount, (short) 0);
1: 		}
1: 		else
1: 			myCode.addInstrU2(opcode, cpi);
1: 		
1: 		// this is the return type of the method
1: 		int rw = rt.width();
1: 		if (rw != 0)
1: 			growStack(rw, rt);
1: 
1: 		// Check the declared type of the method
1: 		if (SanityManager.DEBUG) {
1: 
1: 			d_BCValidate.checkMethod(opcode, dt, methodName, debugParameterTypes, rt);
1: 		}
1: 
1: 		return cpi;
1: 	}
1: 
1: 	private Type vmNameDeclaringClass(String declaringClass) {
1: 		if (declaringClass == null)
1: 			return null;
1: 		return cb.factory.type(declaringClass);
1: 	}
1: 
1: 	public void callSuper() {
1: 
1: 		pushThis();
1: 		callMethod(VMOpcode.INVOKESPECIAL, cb.getSuperClassName(), "<init>", "void", 0);
1: 	}
1: 
1: 	public void pushNewStart(String className) {
1: 
1: 		int cpi = modClass.addClassReference(className);
1: 
1: 		// Use U2, not CPE, since only wide form exists.
1: 		myCode.addInstrU2(VMOpcode.NEW, cpi);
1: 		myCode.addInstr(VMOpcode.DUP);
1: 
1: 		// Grow the stack twice as we are pushing
1: 		// two instances of newly created reference
1: 		Type nt = cb.factory.type(className);
1: 		growStack(1, nt);
1: 		growStack(1, nt);
1: 	}
1: 
1: 	public void pushNewComplete(int numArgs) {
1: 		callMethod(VMOpcode.INVOKESPECIAL, (String) null, "<init>", "void", numArgs);
1: 	}
1: 
1: 	public void upCast(String className) {
1: 		Type uct = cb.factory.type(className);
1: 
1: 		stackTypes[stackTypeOffset - 1] = uct;
1: 		//popStack();
1: 		//growStack(1, uct);
1: 	}
1: 
1: 	public void cast(String className) {
0: 		Type ct = cb.factory.type(className);
0: 		Type tbc = popStack();
1: 
1: 		short sourceType = tbc.vmType();
1: 		short targetType = ct.vmType();
1: 
1: 		if (SanityManager.DEBUG) {
1: 
1: 			if (!((sourceType == BCExpr.vm_reference &&
1: 				targetType == BCExpr.vm_reference) ||
1: 				(sourceType != BCExpr.vm_reference &&
1: 				targetType != BCExpr.vm_reference))) {
1: 				SanityManager.THROWASSERT("Both or neither must be object types " + ct.javaName() + " " + tbc.javaName());
1: 			}
1: 		}
1: 
1: 		// if it is an object type, do a checkcast on it.
1: 		if (sourceType == BCExpr.vm_reference) {
1: 
1: 			int cpi = modClass.addClassReference(ct.vmNameSimple);
1: 			myCode.addInstrU2(VMOpcode.CHECKCAST, cpi);
1: 		}
1: 		// otherwise, try to convert it.
1: 		else {
1: 			short opcode = VMOpcode.NOP;
1: 
1: 			// we use the conversionInfo array
1: 			// to determine how to convert; if
1: 			// the result type of the conversion
1: 			// is not our target type, we are not done
1: 			// yet.  Make sure there are no
1: 			// infinite loop possibilities in the
1: 			// conversionInfo array!
1: 			while (sourceType!=targetType && opcode!=VMOpcode.BAD) {
1: 				short[] currentConversion = 
1: 					CodeChunk.CAST_CONVERSION_INFO[sourceType][targetType];
1: 				sourceType = currentConversion[1];
1: 				opcode = currentConversion[0];
1: 				if (opcode != VMOpcode.NOP) {
1: 					myCode.addInstr(opcode);
1: 				}
1: 			}
1: 			if (SanityManager.DEBUG) {
1: 				SanityManager.ASSERT(opcode != VMOpcode.BAD,
1: 					"BAD VMOpcode not expected in cast");
1: 			}
1: 		}
1: 		growStack(ct);
1: 	}
1: 
1: 	public void isInstanceOf(String className) {
1: 		int cpi = modClass.addClassReference(className);
1: 		myCode.addInstrU2(VMOpcode.INSTANCEOF, cpi);
1: 		popStack();
1: 		growStack(1, Type.BOOLEAN);
1: 	}
1: 
1: 	public void pushNull(String type) {
1: 		myCode.addInstr(VMOpcode.ACONST_NULL);
1: 		growStack(1, cb.factory.type(type));
1: 	}
1: 
1: 
1: 	public void getField(LocalField field) {
1: 
0: 		BCLocalField lf = (BCLocalField) field;
0: 		Type lt = lf.type;
1: 
1: 		pushThis();
1: 		myCode.addInstrU2(VMOpcode.GETFIELD, lf.cpi);
1: 
1: 		popStack();
1: 		growStack(lt);
1: 
1: 	}
1: 
1: 	public void getField(String declaringClass, String fieldName, String fieldType) {
1: 		Type dt = popStack();
1: 
1: 		Type dtu = vmNameDeclaringClass(declaringClass);
1: 		if (dtu != null)
1: 			dt = dtu;
1: 
1: 		getField(VMOpcode.GETFIELD, dt.vmNameSimple, fieldName, fieldType);
1: 	}
1: 	/**
1: 		Push the contents of the described static field onto the stack.		
1: 	*/
1: 	public void getStaticField(String declaringClass, String fieldName, String fieldType) {
1: 		getField(VMOpcode.GETSTATIC, declaringClass, fieldName, fieldType);
1: 	}
1: 
1: 	private void getField(short opcode, String declaringClass, String fieldName, String fieldType) { 
1: 
1: 		Type ft = cb.factory.type(fieldType);
1: 		int cpi = modClass.addFieldReference(vmNameDeclaringClass(declaringClass).vmNameSimple, fieldName, ft.vmName());
1: 		myCode.addInstrU2(opcode, cpi);
1: 
1: 		growStack(ft);
1: 	}
1: 
1: 	/**
1: 		Upon entry the top word(s) on the stack is
1: 		the value to be put into the field. Ie.
1: 		we have
1: 		<PRE>
1: 		word
1: 		</PRE>
1: 
1: 		Before the call we need 
1: 		<PRE>
1: 		word
1: 		this
1: 		word
1: 		</PRE>
0: 		word2,word1 -> word2, word1, word2
1: 
1: 		So that we are left with word after the put.
1: 
1: 	*/
1: 	public void putField(LocalField field) {
0: 		BCLocalField lf = (BCLocalField) field;
0: 		Type lt = lf.type;
1: 
0: 		putField(lf.type, lf.cpi);
1: 	}
1: 
1: 	/**
1: 		Pop the top stack value and store it in the instance field of this class.
1: 	*/
1: 	public void putField(String fieldName, String fieldType) {
1: 
1: 		Type ft = cb.factory.type(fieldType);
1: 		int cpi = modClass.addFieldReference(cb.classType.vmNameSimple, fieldName, ft.vmName());
1: 
0: 		putField(ft, cpi);
1: 	}
1: 
0: 	private void putField(Type fieldType, int cpi) {
1: 
1: 		// now have ...,value
0: 		myCode.addInstr(fieldType.width() == 2  ? VMOpcode.DUP2 : VMOpcode.DUP);
0: 		growStack(fieldType);
1: 
0: 		// now have ...,value,value
1: 		pushThis();
0: 		// now have ...,value,value,this
1: 		swap();
1: 		/*
0: 		if (fieldType.width() == 1) {
1: 			myCode.addInstr(VMOpcode.SWAP);
0: 			Type t1 = popStack();
0: 			Type t2 = popStack();
0: 			growStack(t1);
0: 			growStack(t2);
1: 
0: 			// now have ...,word,this,word
1: 
1: 		} else {
1: 
0: 			// now have wA,wB,wA,wB,this
1: 			myCode.addInstr(VMOpcode.DUP_X2);
1: 
0: 			Type t1 = popStack();
0: 			Type t2 = popStack();
0: 			growStack(t1);
0: 			growStack(t2);
0: 			growStack(t1);
1: 
0: 			// now have wA,wB,this,wA,wB,this
1: 			myCode.addInstr(VMOpcode.POP);
1: 			popStack();
1: 
0: 			// now have wA,wB,this,wA,wB
1: 		}
1: */
1: 		myCode.addInstrU2(VMOpcode.PUTFIELD, cpi);
1: 		popStack(); // the value
1: 		popStack(); // this
1: 	}
1: 	/**
1: 		Pop the top stack value and store it in the field.
1: 		This call requires the instance to be pushed by the caller.
1: 	*/
1: 	public void putField(String declaringClass, String fieldName, String fieldType) {
1: 		Type vt = popStack();
1: 		Type dt = popStack();
1: 
1: 		if (SanityManager.DEBUG) {
1: 			if (dt.width() != 1)
1: 				SanityManager.THROWASSERT("reference expected for field access - is " + dt.javaName());
1: 		}
1: 
1: 		// have objectref,value
1: 		// need value,objectref,value
1: 
1: 		myCode.addInstr(vt.width() == 2  ? VMOpcode.DUP2_X1 : VMOpcode.DUP_X1);
1: 		growStack(vt);
1: 		growStack(dt);
1: 		growStack(vt);
1: 
1: 		Type dtu = vmNameDeclaringClass(declaringClass);
1: 		if (dtu != null)
1: 			dt = dtu;
1: 
1: 		Type ft = cb.factory.type(fieldType);
1: 		int cpi = modClass.addFieldReference(dt.vmNameSimple, fieldName, ft.vmName());
1: 		myCode.addInstrU2(VMOpcode.PUTFIELD, cpi);
1: 
1: 		popStack(); // value
1: 		popStack(); // reference
1: 	}
1: 
1: 	public void conditionalIfNull() {
1: 
1: 		conditionalIf(VMOpcode.IFNONNULL);
1: 	}
1: 
1: 	public void conditionalIf() {
1: 		conditionalIf(VMOpcode.IFEQ);
1: 	}
1: 
1: 	private Conditional condition;
1: 
1: 	private void conditionalIf(short opcode) {
1: 		popStack();
1: 
1: 
0: 		int clearTo = stackTypeOffset;
1: 
0: 		condition = new Conditional(condition, myCode, opcode, clearTo);
1: 	}
1: 
1: 	public void startElseCode() {
0: 		int clearTo = condition.startElse(myCode, stackTypeOffset);
1: 
1: 		if (SanityManager.DEBUG) {
0: 			if ((stackTypeOffset - 1) != clearTo)
0: 				SanityManager.THROWASSERT(stackTypeOffset + " is not one more than " + clearTo);
1: 		}
1: 
0: 		while (stackTypeOffset > clearTo) {
1: 			popStack();
1: 		}
1: 	}
1: 	public void completeConditional() {
0: 		condition = condition.end(myCode, stackTypeOffset);
1: 	}
1: 
1: 	public void endStatement() {
1: 		if (stackDepth != 0) {
0: 			Type toPop = popStack();
1: 
0: 			myCode.addInstr(toPop.width() == 2  ? VMOpcode.POP2 : VMOpcode.POP);
1: 
1: 		}
1: 
1: 		//if (SanityManager.DEBUG) {
1: 		//	if (stackDepth != 0)
1: 		//		SanityManager.THROWASSERT("items left on stack " + stackDepth);
1: 	//	}
1: 	}
1: 
1: 	/**
1: 	*/
1: 	public void getArrayElement(int element) {
1: 
1: 		push(element);
1: 		popStack(); // int just pushed will be popped by array access
1: 
1: 		Type arrayType = popStack();
1: 
1: 		String arrayJava = arrayType.javaName();
1: 		String componentString = arrayJava.substring(0,arrayJava.length()-2);
1: 
1: 		Type componentType = cb.factory.type(componentString);
1: 
1: 		short typ = componentType.vmType();
1: 
1: 		// boolean has a type id of integer, here it needs to be byte.
1: 		if ((typ == BCExpr.vm_int) && (componentType.vmName().equals("Z")))
1: 			typ = BCExpr.vm_byte;
1: 		myCode.addInstr(CodeChunk.ARRAY_ACCESS[typ]);
1: 
1: 		growStack(componentType);
1: 
1: 	}
1: 	// come in with ref, value
1: 
1: 	public void setArrayElement(int element) {
1: 
1: 		// ref, value
1: 
1: 		push(element);
1: 
1: 		// ref, value, index
1: 		swap();
1: 		
1: 		Type componentType = popStack(); // value
1: 		popStack(); // int just pushed will be popped by array access
1: 		
1: 		popStack(); // array ref.
1: 
1: 		short typ = componentType.vmType();
1: 
1: 		// boolean has a type id of integer, here it needs to be byte.
1: 		if ((typ == BCExpr.vm_int) && (componentType.vmName().equals("Z")))
1: 			typ = BCExpr.vm_byte;
1: 
1: 		myCode.addInstr(CodeChunk.ARRAY_STORE[typ]);
1: 	}
1: 	/**
1: 		this array maps the BCExpr vm_* constants 0..6 to
1: 		the expected VM type constants for the newarray instruction.
1: 		<p>
1: 		Because boolean was mapped to integer for general instructions,
1: 		it will have to be specially matched and mapped to its value
1: 		directly (4).
1: 	 */
1: 	private static final byte newArrayElementTypeMap[] = { 8, 9, 10, 11, 6, 7, 5 };
1: 	static final byte T_BOOLEAN = 4;
1: 	/**
1: 		Create an array instance
1: 
0: 		Stack ... =>
1: 		      ...,arrayref
1: 	*/
1: 	public void pushNewArray(String className, int size) {
1: 
1: 		push(size);
1: 		popStack(); // int just pushed will be popped by array creation
1: 
1: 		Type elementType = cb.factory.type(className);
1: 
1: 		// determine the instruction to use based on the element type
1: 		if (elementType.vmType() == BCExpr.vm_reference) {
1: 
1: 			// For an array of Java class/interface elements, generate:
1: 			// ANEWARRAY #cpei ; where cpei is a constant pool index for the class
1: 
1: 			int cpi = modClass.addClassReference(elementType.javaName());
1: 			// Use U2, not CPE, since only wide form exists.
1: 			myCode.addInstrU2(VMOpcode.ANEWARRAY, cpi);
1: 		} else {
1: 			byte atype;
1: 
1: 			// get the argument for the array type
1: 			// if the element type is boolean, we can't use the map
1: 			// because the type id will say integer.
1: 			// but we can use vm_int test to weed out some tests
1: 			if (elementType.vmType() == BCExpr.vm_int &&
1: 			    VMDescriptor.C_BOOLEAN == elementType.vmName().charAt(0))
1: 				atype = T_BOOLEAN;
1: 			else
1: 				atype = newArrayElementTypeMap[elementType.vmType()];
1: 
1: 			// For an array of Java builtin type elements, generate:
1: 			// NEWARRAY #atype ; where atype is a constant for the builtin type
1: 
1: 			myCode.addInstrU1(VMOpcode.NEWARRAY, atype);
1: 		}
1: 
1: 		// an array reference is an object, hence width of 1
1: 		growStack(1, cb.factory.type(className.concat("[]")));
1: 	}
1: 
1: 	/**
1: 		Tell if statement number in this method builder hits limit.  This
1: 		method builder keeps a counter of how many statements are added to it.
1: 		Caller should call this function every time it tries to add a statement
1: 		to this method builder (counter is increased by 1), then the function
1: 		returns whether the accumulated statement number hits a limit.
1: 		The reason of doing this is that Java compiler has a limit of 64K code
1: 		size for each method.  We might hit this limit if an extremely long
1: 		insert statement is issued, for example (see beetle 4293).  Counting
1: 		statement number is an approximation without too much overhead.
1: 	*/
1: 	public boolean statementNumHitLimit(int noStatementsAdded)
1: 	{
1: 		if (statementNum > 2048)    // 2K limit
1: 			return true;
1: 		else
1: 		{
1: 			statementNum = statementNum + noStatementsAdded;
1: 			return false;
1: 		}
1: 	}
1: }
1: 
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.services.bytecode
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.services.bytecode;
0: 
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: import org.apache.derby.iapi.services.compiler.ClassBuilder;
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
0: import org.apache.derby.iapi.services.classfile.ClassFormatOutput;
0: import org.apache.derby.iapi.services.compiler.LocalField;
0: import org.apache.derby.iapi.services.classfile.ClassHolder;
0: import org.apache.derby.iapi.services.classfile.ClassMember;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.services.classfile.VMDescriptor;
0: import org.apache.derby.iapi.services.classfile.VMOpcode;
0: 
0: import java.lang.reflect.Modifier;
0: import java.util.Vector;
0: import java.io.IOException;
0: 
0: /**
0:  * MethodBuilder is used to piece together a method when
0:  * building a java class definition.
0:  * <p>
0:  * When a method is first created, it has:
0:  * <ul>
0:  * <li> a return type
0:  * <li> modifiers
0:  * <li> a name
0:  * <li> an empty parameter list
0:  * <li> an empty throws list
0:  * <li> an empty statement block
0:  * </ul>
0:  * <p>
0:  * MethodBuilder implementations are required to supply a way for
0:  * Statements and Expressions to give them code.  Most typically, they may have
0:  * a stream to which their contents writes the code that is of
0:  * the type to satisfy what the contents represent.
0:  * MethodBuilder implementations also have to have a way to supply
0:  * ClassBuilders with their code, that satisfies the type of class
0:  * builder they are implemented with.  This is implementation-dependent,
0:  * so ClassBuilders, MethodBuilders, Statements, and Expressions all have
0:  * to be of the same implementation in order to interact to generate a class.
0:  * <p>
0:  * Method Builder implementation for generating bytecode.
0:  *
0:  */
0: public class BCMethod implements MethodBuilder {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 
0: 	final BCClass		cb;
0: 	protected final ClassHolder modClass; // the class it is in (modifiable fmt)
0: 
0: 	protected BCLocalField[] parameters; 
0: 	protected Vector thrownExceptions; // expected to be names of Classes under Throwable
0: 
0: 	final CodeChunk myCode;
0: 	protected ClassMember myEntry;
0: 
0: 	private int currentVarNum;
0: 	private int statementNum;
0: 
0: 	BCMethod(ClassBuilder cb,
0: 			String returnType,
0: 			String methodName,
0: 			int modifiers,
0: 			String[] parms,
0: 			BCJava factory) {
0: 
0: 		this.cb = (BCClass) cb;
0: 		modClass = this.cb.modify();
0: 		//this.modifiers = modifiers;
0: 
0: 		if (SanityManager.DEBUG) {
0:    			this.cb.validateType(returnType);
0: 		}
0: 
0: 		// if the method is not static, allocate for "this".
0: 		if ((modifiers & Modifier.STATIC) == 0 )
0: 			currentVarNum = 1;
0: 
0: 		String[] vmParamterTypes;
0: 
0: 		if (parms != null) {
0: 			int len = parms.length;
0: 			vmParamterTypes = new String[len];
0: 			parameters = new BCLocalField[len];
0: 			for (int i = 0; i < len; i++) {
0: 				Type t = factory.type(parms[i]);
0: 				parameters[i] = new BCLocalField(t, currentVarNum);
0: 				currentVarNum += t.width();
0: 
0: 				// convert to vmname for the BCMethodDescriptor.get() call
0: 				vmParamterTypes[i] = t.vmName();
0: 			}
0: 		}
0: 		else
0: 			vmParamterTypes = BCMethodDescriptor.EMPTY;
0: 
0: 		// create a code attribute
0: 		String sig = BCMethodDescriptor.get(vmParamterTypes, factory.type(returnType).vmName(), factory);
0: 
0: 		// stuff the completed information into the class.
0: 		myEntry = modClass.addMember(methodName, sig, modifiers);
0: 
0: 		// get code chunk
0: 		myCode = new CodeChunk(true);
0: 	}
0: 	//
0: 	// MethodBuilder interface
0: 	//
0: 
0: 	public String getName() {
0: 		return myEntry.getName();
0: 	}
0: 
0: 	public void getParameter(int id) {
0: 
0: 		int num = parameters[id].cpi;
0: 		short typ = parameters[id].type.vmType();
0: 		if (num < 4)
0: 			myCode.addInstr((short) (CodeChunk.LOAD_VARIABLE_FAST[typ]+num));
0: 		else
0: 			myCode.addInstrWide(CodeChunk.LOAD_VARIABLE[typ], num);
0: 
0: 		growStack(parameters[id].type);
0: 	}
0: 
0: 	/**
0: 	 * a throwable can be added to the end of
0: 	 * the list of thrownExceptions.
0: 	 */
0: 	public void addThrownException(String exceptionClass) {
0: 
0: 		if (thrownExceptions == null)
0: 			thrownExceptions = new Vector();
0: 		thrownExceptions.addElement(exceptionClass);
0: 	}
0: 
0: 	/**
0: 	 * when the method has had all of its parameters
0: 	 * and thrown exceptions defined, and its statement
0:  	 * block has been completed, it can be completed and
0: 	 * its class file information generated.
0: 	 * <p>
0: 	 * further alterations of the method will not be
0: 	 * reflected in the code generated for it.
0: 	 */
0: 	public void complete() {
0: 		// write exceptions attribute info
0: 		writeExceptions();
0: 
0: 		// get the code attribute to put itself into the class
0: 		// provide the final header information needed
0: 		myCode.complete(modClass, myEntry, maxStack, currentVarNum);
0: 	}
0: 
0: 	/*
0: 	 * class interface
0: 	 */
0: 
0: 	/**
0: 	 * In their giveCode methods, the parts of the method body
0: 	 * will want to get to the constant pool to add their constants.
0: 	 * We really only want them treating it like a constant pool
0: 	 * inclusion mechanism, we could write a wrapper to limit it to that.
0: 	 */
0: 	ClassHolder constantPool() {
0: 		return modClass;
0: 	}
0: 
0: 
0:     //
0:     // Class implementation
0:     //
0: 
0: 
0: 	/**
0: 	 * sets exceptionBytes to the attribute_info needed
0: 	 * for a method's Exceptions attribute.
0: 	 * The ClassUtilities take care of the header 6 bytes for us,
0: 	 * so they are not included here.
0: 	 * See The Java Virtual Machine Specification Section 4.7.5,
0: 	 * Exceptions attribute.
0: 	 */
0: 	protected void writeExceptions() {
0: 		if (thrownExceptions == null)
0: 			return;
0: 
0: 		int numExc = thrownExceptions.size();
0: 
0: 		// don't write an Exceptions attribute if there are no exceptions.
0: 		if (numExc != 0) {
0: 
0: 			try{
0: 				ClassFormatOutput eout = new ClassFormatOutput((numExc * 2) + 2);
0: 
0: 				eout.putU2(numExc); // number_of_exceptions
0: 
0: 				for (int i = 0; i < numExc; i++) {
0: 					// put each exception into the constant pool
0: 					String e = thrownExceptions.elementAt(i).toString();
0: 					int ei2 = modClass.addClassReference(e);
0: 
0: 					// add constant pool index to exception attribute_info
0: 					eout.putU2(ei2);
0: 				}
0: 
0: 				myEntry.addAttribute("Exceptions", eout);
0: 
0: 			} catch (IOException ioe) {
0: 			}			
0: 		}
0: 	}
0: 
0: 	/*
0: 	** New push compiler api.
0: 	*/
0: 
0: 	private Type[]	stackTypes = new Type[8];
0: 	private int     stackTypeOffset;
0: 
0: 	private int maxStack;
0: 	private int stackDepth;
0: 	// public Stack stackTypes = new Stack();
0: 
0: 	private void growStack(int size, Type type) {
0: 		stackDepth += size;
0: 		if (stackDepth > maxStack)
0: 			maxStack = stackDepth;
0: 		
0: 		if (stackTypeOffset >= stackTypes.length) {
0: 
0: 			Type[] newStackTypes = new Type[stackTypes.length + 8];
0: 			System.arraycopy(stackTypes, 0, newStackTypes, 0, stackTypes.length);
0: 			stackTypes = newStackTypes;
0: 		}
0: 
0: 		stackTypes[stackTypeOffset++] = type;
0: 
0: 		if (SanityManager.DEBUG) {
0: 
0: 			int sum = 0;
0: 			for (int i = 0 ; i < stackTypeOffset; i++) {
0: 				sum += stackTypes[i].width();
0: 			}
0: 			if (sum != stackDepth) {
0: 				SanityManager.THROWASSERT("invalid stack depth " + stackDepth + " calc " + sum);
0: 			}
0: 		}
0: 	}
0: 
0: 	private void growStack(Type type) {
0: 		growStack(type.width(), type);
0: 	}
0: 
0: 	private Type popStack() {
0: 		stackTypeOffset--;
0: 		Type topType = stackTypes[stackTypeOffset];
0: 		stackDepth -= topType.width();
0: 		return topType;
0: 
0: 	}
0: 
0: 	public void pushThis() {
0: 		myCode.addInstr(VMOpcode.ALOAD_0);
0: 		growStack(1, cb.classType);
0: 	}
0: 
0: 	public void push(byte value) {
0: 		push(value, Type.BYTE);
0: 	}
0: 
0: 	public void push(boolean value) {
0: 		push(value ? 1 : 0, Type.BOOLEAN);
0: 	}
0: 
0: 	public void push(short value) {
0: 		push(value, Type.SHORT);
0: 	}
0: 
0: 	public void push(int value) {
0: 		push(value, Type.INT);
0: 	}
0: 
0: 	public void dup() {
0: 		Type dup = popStack();
0: 		myCode.addInstr(dup.width() == 2  ? VMOpcode.DUP2 : VMOpcode.DUP);
0: 		growStack(dup);
0: 		growStack(dup);
0: 
0: 	}
0: 
0: 	public void swap() {
0: 
0: 		// have A,B
0: 		// want B,A
0: 
0: 		Type wB = popStack();
0: 		Type wA = popStack();
0: 		growStack(wB);
0: 		growStack(wA);
0: 
0: 		if (wB.width() == 1) {
0: 			// top value is one word
0: 			if (wA.width() == 1) {
0: 				myCode.addInstr(VMOpcode.SWAP);
0: 				return;
0: 			} else {
0: 				myCode.addInstr(VMOpcode.DUP_X2);
0: 				myCode.addInstr(VMOpcode.POP);
0: 			}
0: 		} else {
0: 			// top value is two words
0: 			if (wA.width() == 1) {
0: 				myCode.addInstr(VMOpcode.DUP2_X1);
0: 				myCode.addInstr(VMOpcode.POP2);
0: 			} else {
0: 				myCode.addInstr(VMOpcode.DUP2_X2);
0: 				myCode.addInstr(VMOpcode.POP2);
0: 			}
0: 		}
0: 
0: 		// all except the simple swap push an extra
0: 		// copy of B which needs to be popped.
0: 		growStack(wB);
0: 		popStack();
0: 
0: 	}
0: 
0: 	private void push(int value, Type type) {
0: 
0: 		CodeChunk chunk = myCode;
0: 
0: 		if (value >= -1 && value <= 5)
0: 			chunk.addInstr((short)(VMOpcode.ICONST_0+value));
0: 		else if (value >= Byte.MIN_VALUE && value <= Byte.MAX_VALUE)
0: 			chunk.addInstrU1(VMOpcode.BIPUSH,value);
0: 		else if (value >= Short.MIN_VALUE && value <= Short.MAX_VALUE)
0: 			chunk.addInstrU2(VMOpcode.SIPUSH,value);
0: 		else {
0: 			int cpe = modClass.addConstant(value);
0: 			chunk.addInstrCPE(VMOpcode.LDC, cpe);
0: 		}
0: 		growStack(1, type);
0: 		
0: 	}
0: 
0: 	public void push(long value){
0: 		CodeChunk chunk = myCode;
0: 
0: 		if (value == 0 || value == 1) {
0: 				chunk.addInstr((short)(VMOpcode.LCONST_0+(short)value));
0: 		}
0: 		else {
0: 			int cpe = modClass.addConstant(value);
0: 			chunk.addInstrU2(VMOpcode.LDC2_W, cpe);
0: 		}
0: 		growStack(2, Type.LONG);
0: 
0: 	}
0: 	public void push(float value) {
0: 
0: 		CodeChunk chunk = myCode;
0: 		
0: 		if (value == 0.0)
0: 		{
0: 			chunk.addInstr(VMOpcode.FCONST_0);
0: 		}
0: 		else if (value == 1.0)
0: 		{
0: 			chunk.addInstr(VMOpcode.FCONST_1);
0: 		}
0: 		else if (value == 2.0)
0: 		{
0: 			chunk.addInstr(VMOpcode.FCONST_2);
0: 		}
0: 		else 
0: 		{
0: 			int cpe = modClass.addConstant(value);
0: 			chunk.addInstrCPE(VMOpcode.LDC, cpe);
0: 		}
0: 		growStack(1, Type.FLOAT);
0: 	}
0: 
0: 	public void push(double value) {
0: 		CodeChunk chunk = myCode;
0: 
0: 		if (value == 0.0) {
0: 				chunk.addInstr(VMOpcode.DCONST_0);
0: 		}
0: 		else {
0: 			int cpe = modClass.addConstant(value);
0: 			chunk.addInstrU2(VMOpcode.LDC2_W, cpe);
0: 		}
0: 		growStack(2, Type.DOUBLE);
0: 	}
0: 	public void push(String value) {
0: 		int cpe = modClass.addConstant(value);
0: 		myCode.addInstrCPE(VMOpcode.LDC, cpe);
0: 		growStack(1, Type.STRING);
0: 	}
0:  
0: 
0: 	public void methodReturn() {
0: 
0: 		short opcode;		
0: 		if (stackDepth != 0) {
0: 			Type topType = popStack();
0: 			opcode = CodeChunk.RETURN_OPCODE[topType.vmType()];
0: 		} else {
0: 			opcode = VMOpcode.RETURN;
0: 		}
0: 
0: 		myCode.addInstr(opcode);
0: 
0: 		if (SanityManager.DEBUG) {
0: 			if (stackDepth != 0)
0: 				SanityManager.THROWASSERT("items left on stack " + stackDepth);
0: 		}
0: 	}
0: 
0: 	public Object describeMethod(short opcode, String declaringClass, String methodName, String returnType) {
0: 
0: 		Type rt = cb.factory.type(returnType);
0: 
0: 		String methodDescriptor = BCMethodDescriptor.get(BCMethodDescriptor.EMPTY, rt.vmName(), cb.factory);
0: 
0: 		if ((declaringClass == null) && (opcode != VMOpcode.INVOKESTATIC)) {
0: 
0: 			Type dt = stackTypes[stackTypeOffset - 1];
0: 
0: 			if (declaringClass == null)
0: 				declaringClass = dt.javaName();
0: 		}
0: 		
0: 		int cpi = modClass.addMethodReference(declaringClass, methodName,
0: 				methodDescriptor, opcode == VMOpcode.INVOKEINTERFACE);
0: 
0: 		return new BCMethodCaller(opcode, rt, cpi);
0: 	}
0: 
0: 	public int callMethod(Object methodDescriptor) {
0: 
0: 		// pop the reference off the stack
0: 		popStack();
0: 
0: 		BCMethodCaller mc = (BCMethodCaller) methodDescriptor;
0: 
0: 		int cpi = mc.cpi;
0: 		short opcode = mc.opcode;
0: 
0: 		if (opcode == VMOpcode.INVOKEINTERFACE) {
0: 			myCode.addInstrU2U1U1(opcode, cpi, (short) 1, (short) 0);
0: 		}
0: 		else
0: 			myCode.addInstrU2(opcode, cpi);
0: 		
0: 		// this is the return type of the method
0: 		Type rt = mc.type;
0: 		int rw = rt.width();
0: 		if (rw != 0)
0: 			growStack(rw, rt);
0: 
0: 		return cpi;
0: 	}
0: 
0: 	public int callMethod(short opcode, String declaringClass, String methodName,
0: 		String returnType, int numArgs) {
0: 
0: 		Type rt = cb.factory.type(returnType);
0: 
0: 		int initialStackDepth = stackDepth;
0: 
0: 		// get the array of parameter types
0: 
0: 		String [] debugParameterTypes = null;
0: 		String[] vmParameterTypes;
0: 		if (numArgs == 0) {
0: 			vmParameterTypes = BCMethodDescriptor.EMPTY;
0: 		} else {
0: 			if (SanityManager.DEBUG) {
0: 				debugParameterTypes = new String[numArgs];
0: 			}
0: 			vmParameterTypes = new String[numArgs];
0: 			for (int i = numArgs - 1; i >= 0; i--) {
0: 				Type at = popStack();
0: 
0: 				vmParameterTypes[i] = at.vmName();
0: 				if (SanityManager.DEBUG) {
0: 					debugParameterTypes[i] = at.javaName();
0: 				}
0: 			}
0: 		}
0: 		
0: 		String methodDescriptor = BCMethodDescriptor.get(vmParameterTypes, rt.vmName(), cb.factory);
0: 
0: 		Type dt = null;
0: 		if (opcode != VMOpcode.INVOKESTATIC) {
0: 
0: 			dt = popStack();
0: 		}
0: 		Type dtu = vmNameDeclaringClass(declaringClass);
0: 		if (dtu != null)
0: 			dt = dtu;
0: 		
0: 		int cpi = modClass.addMethodReference(dt.vmNameSimple, methodName,
0: 				methodDescriptor, opcode == VMOpcode.INVOKEINTERFACE);
0: 
0: 		if (opcode == VMOpcode.INVOKEINTERFACE) {
0: 			short callArgCount = (short) (initialStackDepth - stackDepth);
0: 			myCode.addInstrU2U1U1(opcode, cpi, callArgCount, (short) 0);
0: 		}
0: 		else
0: 			myCode.addInstrU2(opcode, cpi);
0: 		
0: 		// this is the return type of the method
0: 		int rw = rt.width();
0: 		if (rw != 0)
0: 			growStack(rw, rt);
0: 
0: 		// Check the declared type of the method
0: 		if (SanityManager.DEBUG) {
0: 
0: 			d_BCValidate.checkMethod(opcode, dt, methodName, debugParameterTypes, rt);
0: 		}
0: 
0: 		return cpi;
0: 	}
0: 
0: 	private Type vmNameDeclaringClass(String declaringClass) {
0: 		if (declaringClass == null)
0: 			return null;
0: 		return cb.factory.type(declaringClass);
0: 	}
0: 
0: 	public void callSuper() {
0: 
0: 		pushThis();
0: 		callMethod(VMOpcode.INVOKESPECIAL, cb.getSuperClassName(), "<init>", "void", 0);
0: 	}
0: 
0: 	public void pushNewStart(String className) {
0: 
0: 		int cpi = modClass.addClassReference(className);
0: 
0: 		// Use U2, not CPE, since only wide form exists.
0: 		myCode.addInstrU2(VMOpcode.NEW, cpi);
0: 		myCode.addInstr(VMOpcode.DUP);
0: 
0: 		// Grow the stack twice as we are pushing
0: 		// two instances of newly created reference
0: 		Type nt = cb.factory.type(className);
0: 		growStack(1, nt);
0: 		growStack(1, nt);
0: 	}
0: 
0: 	public void pushNewComplete(int numArgs) {
0: 		callMethod(VMOpcode.INVOKESPECIAL, (String) null, "<init>", "void", numArgs);
0: 	}
0: 
0: 	public void upCast(String className) {
0: 		Type uct = cb.factory.type(className);
0: 
0: 		stackTypes[stackTypeOffset - 1] = uct;
0: 		//popStack();
0: 		//growStack(1, uct);
0: 	}
0: 
0: 	public void cast(String className) {
0: 		Type ct = cb.factory.type(className);
0: 		Type tbc = popStack();
0: 
0: 		short sourceType = tbc.vmType();
0: 		short targetType = ct.vmType();
0: 
0: 		if (SanityManager.DEBUG) {
0: 
0: 			if (!((sourceType == BCExpr.vm_reference &&
0: 				targetType == BCExpr.vm_reference) ||
0: 				(sourceType != BCExpr.vm_reference &&
0: 				targetType != BCExpr.vm_reference))) {
0: 				SanityManager.THROWASSERT("Both or neither must be object types " + ct.javaName() + " " + tbc.javaName());
0: 			}
0: 		}
0: 
0: 		// if it is an object type, do a checkcast on it.
0: 		if (sourceType == BCExpr.vm_reference) {
0: 
0: 			int cpi = modClass.addClassReference(ct.vmNameSimple);
0: 			myCode.addInstrU2(VMOpcode.CHECKCAST, cpi);
0: 		}
0: 		// otherwise, try to convert it.
0: 		else {
0: 			short opcode = VMOpcode.NOP;
0: 
0: 			// we use the conversionInfo array
0: 			// to determine how to convert; if
0: 			// the result type of the conversion
0: 			// is not our target type, we are not done
0: 			// yet.  Make sure there are no
0: 			// infinite loop possibilities in the
0: 			// conversionInfo array!
0: 			while (sourceType!=targetType && opcode!=VMOpcode.BAD) {
0: 				short[] currentConversion = 
0: 					CodeChunk.CAST_CONVERSION_INFO[sourceType][targetType];
0: 				sourceType = currentConversion[1];
0: 				opcode = currentConversion[0];
0: 				if (opcode != VMOpcode.NOP) {
0: 					myCode.addInstr(opcode);
0: 				}
0: 			}
0: 			if (SanityManager.DEBUG) {
0: 				SanityManager.ASSERT(opcode != VMOpcode.BAD,
0: 					"BAD VMOpcode not expected in cast");
0: 			}
0: 		}
0: 		growStack(ct);
0: 	}
0: 
0: 	public void isInstanceOf(String className) {
0: 		int cpi = modClass.addClassReference(className);
0: 		myCode.addInstrU2(VMOpcode.INSTANCEOF, cpi);
0: 		popStack();
0: 		growStack(1, Type.BOOLEAN);
0: 	}
0: 
0: 	public void pushNull(String type) {
0: 		myCode.addInstr(VMOpcode.ACONST_NULL);
0: 		growStack(1, cb.factory.type(type));
0: 	}
0: 
0: 
0: 	public void getField(LocalField field) {
0: 
0: 		BCLocalField lf = (BCLocalField) field;
0: 		Type lt = lf.type;
0: 
0: 		pushThis();
0: 		myCode.addInstrU2(VMOpcode.GETFIELD, lf.cpi);
0: 
0: 		popStack();
0: 		growStack(lt);
0: 
0: 	}
0: 
0: 	public void getField(String declaringClass, String fieldName, String fieldType) {
0: 		Type dt = popStack();
0: 
0: 		Type dtu = vmNameDeclaringClass(declaringClass);
0: 		if (dtu != null)
0: 			dt = dtu;
0: 
0: 		getField(VMOpcode.GETFIELD, dt.vmNameSimple, fieldName, fieldType);
0: 	}
0: 	/**
0: 		Push the contents of the described static field onto the stack.		
0: 	*/
0: 	public void getStaticField(String declaringClass, String fieldName, String fieldType) {
0: 		getField(VMOpcode.GETSTATIC, declaringClass, fieldName, fieldType);
0: 	}
0: 
0: 	private void getField(short opcode, String declaringClass, String fieldName, String fieldType) { 
0: 
0: 		Type ft = cb.factory.type(fieldType);
0: 		int cpi = modClass.addFieldReference(vmNameDeclaringClass(declaringClass).vmNameSimple, fieldName, ft.vmName());
0: 		myCode.addInstrU2(opcode, cpi);
0: 
0: 		growStack(ft);
0: 	}
0: 
0: 	/**
0: 		Upon entry the top word(s) on the stack is
0: 		the value to be put into the field. Ie.
0: 		we have
0: 		<PRE>
0: 		word
0: 		</PRE>
0: 
0: 		Before the call we need 
0: 		<PRE>
0: 		word
0: 		this
0: 		word
0: 		</PRE>
0: 		word2,word1 -> word2, word1, word2
0: 
0: 		So that we are left with word after the put.
0: 
0: 	*/
0: 	public void putField(LocalField field) {
0: 		BCLocalField lf = (BCLocalField) field;
0: 		Type lt = lf.type;
0: 
0: 		putField(lf.type, lf.cpi);
0: 	}
0: 
0: 	/**
0: 		Pop the top stack value and store it in the instance field of this class.
0: 	*/
0: 	public void putField(String fieldName, String fieldType) {
0: 
0: 		Type ft = cb.factory.type(fieldType);
0: 		int cpi = modClass.addFieldReference(cb.classType.vmNameSimple, fieldName, ft.vmName());
0: 
0: 		putField(ft, cpi);
0: 	}
0: 
0: 	private void putField(Type fieldType, int cpi) {
0: 
0: 		// now have ...,value
0: 		myCode.addInstr(fieldType.width() == 2  ? VMOpcode.DUP2 : VMOpcode.DUP);
0: 		growStack(fieldType);
0: 
0: 		// now have ...,value,value
0: 		pushThis();
0: 		// now have ...,value,value,this
0: 		swap();
0: 		/*
0: 		if (fieldType.width() == 1) {
0: 			myCode.addInstr(VMOpcode.SWAP);
0: 			Type t1 = popStack();
0: 			Type t2 = popStack();
0: 			growStack(t1);
0: 			growStack(t2);
0: 
0: 			// now have ...,word,this,word
0: 
0: 		} else {
0: 
0: 			// now have wA,wB,wA,wB,this
0: 			myCode.addInstr(VMOpcode.DUP_X2);
0: 
0: 			Type t1 = popStack();
0: 			Type t2 = popStack();
0: 			growStack(t1);
0: 			growStack(t2);
0: 			growStack(t1);
0: 
0: 			// now have wA,wB,this,wA,wB,this
0: 			myCode.addInstr(VMOpcode.POP);
0: 			popStack();
0: 
0: 			// now have wA,wB,this,wA,wB
0: 		}
0: */
0: 		myCode.addInstrU2(VMOpcode.PUTFIELD, cpi);
0: 		popStack(); // the value
0: 		popStack(); // this
0: 	}
0: 	/**
0: 		Pop the top stack value and store it in the field.
0: 		This call requires the instance to be pushed by the caller.
0: 	*/
0: 	public void putField(String declaringClass, String fieldName, String fieldType) {
0: 		Type vt = popStack();
0: 		Type dt = popStack();
0: 
0: 		if (SanityManager.DEBUG) {
0: 			if (dt.width() != 1)
0: 				SanityManager.THROWASSERT("reference expected for field access - is " + dt.javaName());
0: 		}
0: 
0: 		// have objectref,value
0: 		// need value,objectref,value
0: 
0: 		myCode.addInstr(vt.width() == 2  ? VMOpcode.DUP2_X1 : VMOpcode.DUP_X1);
0: 		growStack(vt);
0: 		growStack(dt);
0: 		growStack(vt);
0: 
0: 		Type dtu = vmNameDeclaringClass(declaringClass);
0: 		if (dtu != null)
0: 			dt = dtu;
0: 
0: 		Type ft = cb.factory.type(fieldType);
0: 		int cpi = modClass.addFieldReference(dt.vmNameSimple, fieldName, ft.vmName());
0: 		myCode.addInstrU2(VMOpcode.PUTFIELD, cpi);
0: 
0: 		popStack(); // value
0: 		popStack(); // reference
0: 	}
0: 
0: 	public void conditionalIfNull() {
0: 
0: 		conditionalIf(VMOpcode.IFNONNULL);
0: 	}
0: 
0: 	public void conditionalIf() {
0: 		conditionalIf(VMOpcode.IFEQ);
0: 	}
0: 
0: 	private Conditional condition;
0: 
0: 	private void conditionalIf(short opcode) {
0: 		popStack();
0: 
0: 
0: 		int clearTo = stackTypeOffset;
0: 
0: 		condition = new Conditional(condition, myCode, opcode, clearTo);
0: 	}
0: 
0: 	public void startElseCode() {
0: 		int clearTo = condition.startElse(myCode, stackTypeOffset);
0: 
0: 		if (SanityManager.DEBUG) {
0: 			if ((stackTypeOffset - 1) != clearTo)
0: 				SanityManager.THROWASSERT(stackTypeOffset + " is not one more than " + clearTo);
0: 		}
0: 
0: 		while (stackTypeOffset > clearTo) {
0: 			popStack();
0: 		}
0: 	}
0: 	public void completeConditional() {
0: 		condition = condition.end(myCode, stackTypeOffset);
0: 	}
0: 
0: 	public void endStatement() {
0: 		if (stackDepth != 0) {
0: 			Type toPop = popStack();
0: 
0: 			myCode.addInstr(toPop.width() == 2  ? VMOpcode.POP2 : VMOpcode.POP);
0: 
0: 		}
0: 
0: 		//if (SanityManager.DEBUG) {
0: 		//	if (stackDepth != 0)
0: 		//		SanityManager.THROWASSERT("items left on stack " + stackDepth);
0: 	//	}
0: 	}
0: 
0: 	/**
0: 	*/
0: 	public void getArrayElement(int element) {
0: 
0: 		push(element);
0: 		popStack(); // int just pushed will be popped by array access
0: 
0: 		Type arrayType = popStack();
0: 
0: 		String arrayJava = arrayType.javaName();
0: 		String componentString = arrayJava.substring(0,arrayJava.length()-2);
0: 
0: 		Type componentType = cb.factory.type(componentString);
0: 
0: 		short typ = componentType.vmType();
0: 
0: 		// boolean has a type id of integer, here it needs to be byte.
0: 		if ((typ == BCExpr.vm_int) && (componentType.vmName().equals("Z")))
0: 			typ = BCExpr.vm_byte;
0: 		myCode.addInstr(CodeChunk.ARRAY_ACCESS[typ]);
0: 
0: 		growStack(componentType);
0: 
0: 	}
0: 	// come in with ref, value
0: 
0: 	public void setArrayElement(int element) {
0: 
0: 		// ref, value
0: 
0: 		push(element);
0: 
0: 		// ref, value, index
0: 		swap();
0: 		
0: 		Type componentType = popStack(); // value
0: 		popStack(); // int just pushed will be popped by array access
0: 		
0: 		popStack(); // array ref.
0: 
0: 		short typ = componentType.vmType();
0: 
0: 		// boolean has a type id of integer, here it needs to be byte.
0: 		if ((typ == BCExpr.vm_int) && (componentType.vmName().equals("Z")))
0: 			typ = BCExpr.vm_byte;
0: 
0: 		myCode.addInstr(CodeChunk.ARRAY_STORE[typ]);
0: 	}
0: 	/**
0: 		this array maps the BCExpr vm_* constants 0..6 to
0: 		the expected VM type constants for the newarray instruction.
0: 		<p>
0: 		Because boolean was mapped to integer for general instructions,
0: 		it will have to be specially matched and mapped to its value
0: 		directly (4).
0: 	 */
0: 	private static final byte newArrayElementTypeMap[] = { 8, 9, 10, 11, 6, 7, 5 };
0: 	static final byte T_BOOLEAN = 4;
0: 	/**
0: 		Create an array instance
0: 
0: 		Stack ... =>
0: 		      ...,arrayref
0: 	*/
0: 	public void pushNewArray(String className, int size) {
0: 
0: 		push(size);
0: 		popStack(); // int just pushed will be popped by array creation
0: 
0: 		Type elementType = cb.factory.type(className);
0: 
0: 		// determine the instruction to use based on the element type
0: 		if (elementType.vmType() == BCExpr.vm_reference) {
0: 
0: 			// For an array of Java class/interface elements, generate:
0: 			// ANEWARRAY #cpei ; where cpei is a constant pool index for the class
0: 
0: 			int cpi = modClass.addClassReference(elementType.javaName());
0: 			// Use U2, not CPE, since only wide form exists.
0: 			myCode.addInstrU2(VMOpcode.ANEWARRAY, cpi);
0: 		} else {
0: 			byte atype;
0: 
0: 			// get the argument for the array type
0: 			// if the element type is boolean, we can't use the map
0: 			// because the type id will say integer.
0: 			// but we can use vm_int test to weed out some tests
0: 			if (elementType.vmType() == BCExpr.vm_int &&
0: 			    VMDescriptor.C_BOOLEAN == elementType.vmName().charAt(0))
0: 				atype = T_BOOLEAN;
0: 			else
0: 				atype = newArrayElementTypeMap[elementType.vmType()];
0: 
0: 			// For an array of Java builtin type elements, generate:
0: 			// NEWARRAY #atype ; where atype is a constant for the builtin type
0: 
0: 			myCode.addInstrU1(VMOpcode.NEWARRAY, atype);
0: 		}
0: 
0: 		// an array reference is an object, hence width of 1
0: 		growStack(1, cb.factory.type(className.concat("[]")));
0: 	}
0: 
0: 	/**
0: 		Tell if statement number in this method builder hits limit.  This
0: 		method builder keeps a counter of how many statements are added to it.
0: 		Caller should call this function every time it tries to add a statement
0: 		to this method builder (counter is increased by 1), then the function
0: 		returns whether the accumulated statement number hits a limit.
0: 		The reason of doing this is that Java compiler has a limit of 64K code
0: 		size for each method.  We might hit this limit if an extremely long
0: 		insert statement is issued, for example (see beetle 4293).  Counting
0: 		statement number is an approximation without too much overhead.
0: 	*/
0: 	public boolean statementNumHitLimit(int noStatementsAdded)
0: 	{
0: 		if (statementNum > 2048)    // 2K limit
0: 			return true;
0: 		else
0: 		{
0: 			statementNum = statementNum + noStatementsAdded;
0: 			return false;
0: 		}
0: 	}
0: }
0: 
============================================================================