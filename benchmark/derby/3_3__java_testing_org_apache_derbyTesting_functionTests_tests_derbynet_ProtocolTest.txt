1:fdaf2b5: /*
10:fdaf2b5: 
1:fdaf2b5:    Derby - Class org.apache.derbyTesting.functionTests.tests.derbynet.ProtocolTest
1:fdaf2b5: 
1:fdaf2b5:    Licensed to the Apache Software Foundation (ASF) under one or more
1:fdaf2b5:    contributor license agreements.  See the NOTICE file distributed with
1:fdaf2b5:    this work for additional information regarding copyright ownership.
1:fdaf2b5:    The ASF licenses this file to You under the Apache License, Version 2.0
1:fdaf2b5:    (the "License"); you may not use this file except in compliance with
1:fdaf2b5:    the License.  You may obtain a copy of the License at
1:fdaf2b5: 
1:fdaf2b5:       http://www.apache.org/licenses/LICENSE-2.0
1:fdaf2b5: 
1:fdaf2b5:    Unless required by applicable law or agreed to in writing, software
1:fdaf2b5:    distributed under the License is distributed on an "AS IS" BASIS,
1:fdaf2b5:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:fdaf2b5:    See the License for the specific language governing permissions and
1:fdaf2b5:    limitations under the License.
1:fdaf2b5: 
1:fdaf2b5:  */
1:fdaf2b5: package org.apache.derbyTesting.functionTests.tests.derbynet;
1:fdaf2b5: 
1:fdaf2b5: import java.io.BufferedReader;
1:fdaf2b5: import java.io.File;
1:fdaf2b5: import java.io.IOException;
1:fdaf2b5: import java.io.InputStreamReader;
1:fdaf2b5: import java.io.Reader;
1:fdaf2b5: import java.io.StreamTokenizer;
1:fdaf2b5: import java.io.StringReader;
1:fdaf2b5: import java.io.UnsupportedEncodingException;
1:fdaf2b5: import java.net.Socket;
1:fdaf2b5: import java.net.URL;
1:fdaf2b5: import java.net.UnknownHostException;
1:fdaf2b5: import java.nio.charset.Charset;
1:fdaf2b5: import java.security.AccessController;
1:fdaf2b5: import java.security.PrivilegedActionException;
1:fdaf2b5: import java.sql.DriverManager;
1:fdaf2b5: import java.sql.SQLException;
1:fdaf2b5: import java.util.ArrayList;
1:1ae02c9: import java.util.Arrays;
1:fdaf2b5: import java.util.Locale;
1:fdaf2b5: import junit.framework.Test;
1:fdaf2b5: import org.apache.derby.impl.drda.ProtocolTestAdapter;
1:fdaf2b5: import org.apache.derbyTesting.functionTests.util.PrivilegedFileOpsForTests;
1:fdaf2b5: import org.apache.derbyTesting.functionTests.util.ProtocolTestGrammar;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:1ae02c9: import org.apache.derbyTesting.junit.SecurityManagerSetup;
1:1ae02c9: import org.apache.derbyTesting.junit.SupportFilesSetup;
1:1ae02c9: import org.apache.derbyTesting.junit.TestConfiguration;
1:fdaf2b5: 
1:fdaf2b5: /**
1:fdaf2b5:  * This class is used to test error conditions in the protocol.
1:fdaf2b5:  * <p>
1:fdaf2b5:  * The protocol to send to the Net server is contained in a file encoded
1:fdaf2b5:  * as calls to routines in {@code DDMReader} and {@code DDMWriter}.
1:fdaf2b5:  * Additional commands have been added for testing purposes.
1:fdaf2b5:  * To add tests, modify the file protocol.tests.
1:fdaf2b5:  * Tests can also be done as separate files and given as an argument to
1:fdaf2b5:  * this class.
1:fdaf2b5:  * <p>
1:fdaf2b5:  * This test was copied / converted from testProto.
1:fdaf2b5:  */
1:fdaf2b5: public class ProtocolTest
1:fdaf2b5:     extends BaseTestCase {
1:fdaf2b5: 
1:fdaf2b5:     private static final String PREFIX =
1:fdaf2b5:         "org/apache/derbyTesting/functionTests/tests/derbynet/";
1:fdaf2b5:     /** Newline character(s). */
1:fdaf2b5:     private static final String NL =
1:fdaf2b5:             BaseTestCase.getSystemProperty("line.separator");
1:fdaf2b5: 
1:fdaf2b5:     // Constants used to encode / represent multiple values for a command.
1:fdaf2b5:     private static final String MULTIVAL_START = "MULTIVALSTART";
1:fdaf2b5:     private static final String MULTIVAL_SEP = "SEP";
1:fdaf2b5:     private static final String MULTIVAL_END = "MULTIVALEND";
1:fdaf2b5: 
1:fdaf2b5:     // Replaces %UTF8TestString% in protocol.tests
1:fdaf2b5:     private static final String UTF8_TEST_MATCH = "%UTF8TestString%";
1:fdaf2b5:     private static final String UTF8_TEST_STRING =
1:fdaf2b5:             "\u4f60\u597d\u4e16\u754cABCDEFGHIJKLMNOPQ";
1:fdaf2b5: 
1:fdaf2b5: 
1:fdaf2b5:     /** Name of the file from which the test is obtained. */
1:fdaf2b5:     private final String filename;
1:fdaf2b5:     /** The start line of the test from the input file. */
1:fdaf2b5:     private final int startLine;
1:fdaf2b5:     /** Number of lines this test is composed of. */
1:fdaf2b5:     private final int lineCount;
1:fdaf2b5:     /**
1:fdaf2b5:      * The sequence of commands this test is composed of.
1:fdaf2b5:      * <p>
1:fdaf2b5:      * The sequence is expected to be line oriented, that is a one command and
1:fdaf2b5:      * optionally its arguments per line. The lines must be separated by a
1:fdaf2b5:      * newline token.
1:fdaf2b5:      */
1:fdaf2b5:     private String commandSequence;
1:fdaf2b5:     /**
1:fdaf2b5:      * The adapter that lives on the DRDA package, allowing us to call the
1:fdaf2b5:      * otherwise unavailable methods we need to call in package private
1:fdaf2b5:      * classes.
1:fdaf2b5:      */
1:fdaf2b5:     private ProtocolTestAdapter adapter;
1:fdaf2b5: 
1:fdaf2b5:     /**
1:fdaf2b5:      * Creates a new test case.
1:fdaf2b5:      *
1:fdaf2b5:      * @param file name of file containing the protocol tests (for verbosity)
1:fdaf2b5:      * @param cmds the sequence of commands (see {@link #commandSequence})
1:fdaf2b5:      * @param startLine starting line in the source file
1:fdaf2b5:      * @param lines number of lines from the source file
1:fdaf2b5:      */
1:fdaf2b5:     private ProtocolTest(String file, String cmds, int startLine, int lines) {
1:fdaf2b5:         super("testProtocolSequence");
1:fdaf2b5:         this.filename = file;
1:fdaf2b5:         this.commandSequence = cmds;
1:fdaf2b5:         this.startLine = startLine;
1:fdaf2b5:         this.lineCount = lines;
1:fdaf2b5:     }
1:fdaf2b5: 
1:fdaf2b5:     /**
1:fdaf2b5:      * Executes the test sequence.
1:fdaf2b5:      *
1:fdaf2b5:      * @throws IOException if accessing a file or the socket fails, or if
1:fdaf2b5:      *      Derby detects an unexpected protocol error
1:fdaf2b5:      * @throws UnknownHostException if the server host cannot be resolved
1:fdaf2b5:      */
1:fdaf2b5:     public void testProtocolSequence()
1:fdaf2b5:             throws IOException, UnknownHostException {
1:fdaf2b5:         // Update the name of the test.
1:fdaf2b5:         super.setName(
1:fdaf2b5:                 filename + "_" + startLine + "_" + (startLine + lineCount));
1:fdaf2b5:         println(getName() + " :: STARTED");
1:fdaf2b5:         // Validate the line count. Expects a newline also at end of last line.
1:fdaf2b5:         assertEquals("Actual line count does not match the specified count",
1:fdaf2b5:                 this.lineCount, this.commandSequence.length() -
1:fdaf2b5:                 this.commandSequence.replaceAll("\n", "").length() -1);
1:fdaf2b5: 
1:fdaf2b5:         adapter = new ProtocolTestAdapter(createSocket());
1:fdaf2b5:         Reader cmdStream = new StringReader(this.commandSequence);
1:fdaf2b5:         try {
1:fdaf2b5:             processCommands(cmdStream);
1:fdaf2b5:         } finally {
1:fdaf2b5:             try {
1:fdaf2b5:                 adapter.close();
1:fdaf2b5:             } catch (IOException ioe) {
1:fdaf2b5:                 // Don't act on the exception, but print its message.
1:fdaf2b5:                 alarm("adapter.close() failed: " + ioe.getMessage());
1:fdaf2b5:             }
1:fdaf2b5:         }
1:fdaf2b5:     }
1:fdaf2b5: 
1:eb14359:     /** Cleans up test resources. */
1:eb14359:     public void tearDown()
1:eb14359:             throws Exception {
1:eb14359:         commandSequence = null;
1:eb14359:         adapter.close();
1:eb14359:         adapter = null;
1:eb14359:         super.tearDown();
1:eb14359:     }
1:eb14359: 
1:fdaf2b5:     /**
1:fdaf2b5:      * Initializes a socket to the server.
1:fdaf2b5:      *
1:fdaf2b5:      * @return A socket connected to the server.
1:fdaf2b5:      * @throws IOException if reading/writing to the socket fails
1:fdaf2b5:      * @throws UnknownHostException if the server host cannot be resolved
1:fdaf2b5:      */
1:fdaf2b5:     private static Socket createSocket()
1:fdaf2b5:             throws IOException, UnknownHostException {
1:fdaf2b5:         Socket socket = null;
1:fdaf2b5:         final TestConfiguration cfg = TestConfiguration.getCurrent();
1:fdaf2b5:         try {
1:fdaf2b5:             socket = AccessController.doPrivileged (
1:fdaf2b5:                 new java.security.PrivilegedExceptionAction<Socket>() {
1:fdaf2b5:                     public Socket run()
1:fdaf2b5:                             throws IOException, UnknownHostException {
1:fdaf2b5:                         return new Socket(cfg.getHostName(), cfg.getPort());
1:fdaf2b5:                     }
1:fdaf2b5:                 }
1:fdaf2b5:             );
1:fdaf2b5:         } catch (PrivilegedActionException pae) {
1:fdaf2b5:             if (pae.getCause() instanceof IOException) {
1:fdaf2b5:                 throw (IOException)pae.getCause();
1:fdaf2b5:             } else if (pae.getCause() instanceof UnknownHostException) {
1:fdaf2b5:                 throw (UnknownHostException)pae.getCause();
1:fdaf2b5:             }
1:fdaf2b5:             fail("Unhandled exception", pae);
1:fdaf2b5:         }
1:fdaf2b5:         return socket;
1:fdaf2b5:     }
1:fdaf2b5: 
1:fdaf2b5:     /**
1:fdaf2b5:      * Executes the test commands in the specified file.
1:fdaf2b5:      *
1:fdaf2b5:      * @param fileName file containing the test
1:fdaf2b5:      * @throws IOException if accessing a file or the socket fails, or if
1:fdaf2b5:      *      Derby detects an unexpected protocol error
1:fdaf2b5:      */
1:fdaf2b5:     private void processFile(String fileName)
1:fdaf2b5:             throws IOException {
1:fdaf2b5:         File incFile = SupportFilesSetup.getReadOnly(fileName);
1:fdaf2b5:         assertTrue("Missing file: " + fileName,
1:fdaf2b5:                PrivilegedFileOpsForTests.exists(incFile));
1:fdaf2b5:         BufferedReader bIn = new BufferedReader(
1:fdaf2b5:                PrivilegedFileOpsForTests.getFileReader(incFile));
1:fdaf2b5:         try {
1:fdaf2b5:             processCommands(bIn);
1:fdaf2b5:         } finally {
1:fdaf2b5:             bIn.close();
1:fdaf2b5:         }
1:fdaf2b5:     }
1:fdaf2b5: 
1:fdaf2b5:     /**
1:fdaf2b5:      * Processes the test commands in the stream.
1:fdaf2b5:      *
1:fdaf2b5:      * @param cmdStream command stream (see {@link #commandSequence})
1:fdaf2b5:      * @throws IOException if accessing a file or the socket fails, or if
1:fdaf2b5:      *      Derby detects an unexpected protocol error
1:fdaf2b5:      */
1:fdaf2b5:     private void processCommands(Reader cmdStream)
1:fdaf2b5:             throws  IOException {
1:fdaf2b5:         StreamTokenizer tkn = new StreamTokenizer(cmdStream);
1:fdaf2b5:         boolean endSignalled = false;
1:fdaf2b5:         int val;
1:fdaf2b5:         while ( (val = tkn.nextToken()) != StreamTokenizer.TT_EOF) {
1:fdaf2b5:             assertFalse("End signalled, data to process left: " + tkn.sval,
1:fdaf2b5:                     endSignalled);
1:fdaf2b5:             switch(val) {
1:fdaf2b5:                 case StreamTokenizer.TT_NUMBER:
1:fdaf2b5:                     break;
1:fdaf2b5:                 case StreamTokenizer.TT_WORD:
1:fdaf2b5:                     endSignalled = processCommand(tkn);
1:fdaf2b5:                     break;
1:fdaf2b5:                 case StreamTokenizer.TT_EOL:
1:fdaf2b5:                     break;
1:fdaf2b5:             }
1:fdaf2b5:         }
1:fdaf2b5:     }
1:fdaf2b5: 
1:fdaf2b5:     /**
1:fdaf2b5:      * Process a command.
1:fdaf2b5:      */
1:fdaf2b5:     private boolean processCommand(StreamTokenizer tkn)
1:fdaf2b5:         throws IOException
1:fdaf2b5:     {
1:fdaf2b5:         ProtocolTestGrammar cmd = ProtocolTestGrammar.cmdFromString(
1:fdaf2b5:                                         tkn.sval.toLowerCase(Locale.ENGLISH));
1:fdaf2b5:         if (cmd == null) { // To avoid generating string for each command.
1:fdaf2b5:             fail("Unknown command '" + tkn.sval + "' in line " + ln(tkn));
1:fdaf2b5:         }
1:fdaf2b5:         int val;
1:fdaf2b5:         String str;
1:fdaf2b5: 
1:fdaf2b5:         switch (cmd)
1:fdaf2b5:         {
1:fdaf2b5:             case INCLUDE:
1:fdaf2b5:                 processFile(getString(tkn));
1:fdaf2b5:                 break;
1:fdaf2b5:             case CREATE_DSS_REQUEST:
1:fdaf2b5:                 adapter.wCreateDssRequest();
1:fdaf2b5:                 break;
1:fdaf2b5:             case CREATE_DSS_OBJECT:
1:fdaf2b5:                 adapter.wCreateDssObject();
1:fdaf2b5:                 break;
1:fdaf2b5:             case CREATE_DSS_REPLY:
1:fdaf2b5:                 adapter.wCreateDssReply();
1:fdaf2b5:                 break;
1:fdaf2b5:             case END_DSS:
1:fdaf2b5:                 tkn.nextToken();
1:fdaf2b5:                 tkn.pushBack();
1:fdaf2b5:                 if ((tkn.sval != null) && tkn.sval.startsWith("0x"))
1:fdaf2b5:                 // use specified chaining.
1:fdaf2b5:                     adapter.wEndDss((getBytes(tkn))[0]);
1:fdaf2b5:                 else
1:fdaf2b5:                 // use default chaining
1:fdaf2b5:                     adapter.wEndDss();
1:fdaf2b5:                 break;
1:fdaf2b5:             case END_DDM:
1:fdaf2b5:                 adapter.wEndDdm();
1:fdaf2b5:                 break;
1:fdaf2b5:             case END_DDM_AND_DSS:
1:fdaf2b5:                 adapter.wEndDdmAndDss();
1:fdaf2b5:                 break;
1:fdaf2b5:             case START_DDM:
1:fdaf2b5:                 adapter.wStartDdm(getCP(tkn));
1:fdaf2b5:                 break;
1:fdaf2b5:             case WRITE_SCALAR_STRING:
1:fdaf2b5:                 adapter.wWriteScalarString(getCP(tkn), getString(tkn));
1:fdaf2b5:                 break;
1:fdaf2b5:             case WRITE_SCALAR_2BYTES:
1:fdaf2b5:                 adapter.wWriteScalar2Bytes(getCP(tkn),getIntOrCP(tkn));
1:fdaf2b5:                 break;
1:fdaf2b5:             case WRITE_SCALAR_1BYTE:
1:fdaf2b5:                 adapter.wWriteScalar1Byte(getCP(tkn),getInt(tkn));
1:fdaf2b5:                 break;
1:fdaf2b5:             case WRITE_SCALAR_BYTES:
1:fdaf2b5:                 adapter.wWriteScalarBytes(getCP(tkn),getBytes(tkn));
1:fdaf2b5:                 break;
1:fdaf2b5:             case WRITE_SCALAR_PADDED_BYTES:
1:fdaf2b5:                 adapter.wWriteScalarPaddedBytes(getCP(tkn), getBytes(tkn),
1:fdaf2b5:                         getInt(tkn), ProtocolTestAdapter.SPACE);
1:fdaf2b5:                 break;
1:fdaf2b5:             case WRITE_BYTE:
1:fdaf2b5:                 adapter.wWriteByte(getInt(tkn));
1:fdaf2b5:                 break;
1:fdaf2b5:             case WRITE_BYTES:
1:fdaf2b5:                 adapter.wWriteBytes(getBytes(tkn));
1:fdaf2b5:                 break;
1:fdaf2b5:             case WRITE_SHORT:
1:fdaf2b5:                 adapter.wWriteShort(getInt(tkn));
1:fdaf2b5:                 break;
1:fdaf2b5:             case WRITE_INT:
1:fdaf2b5:                 adapter.wWriteInt(getInt(tkn));
1:fdaf2b5:                 break;
1:fdaf2b5:             case WRITE_CODEPOINT_4BYTES:
1:fdaf2b5:                 adapter.wWriteCodePoint4Bytes(getCP(tkn), getInt(tkn));
1:fdaf2b5:                 break;
1:fdaf2b5:             case WRITE_STRING:
1:fdaf2b5:                 str = getString(tkn);
1:fdaf2b5:                 adapter.wWriteBytes(getEBCDIC(str));
1:fdaf2b5:                 break;
1:fdaf2b5:             case WRITE_ENCODED_STRING:
1:fdaf2b5:                 writeEncodedString(getString(tkn), getString(tkn));
1:fdaf2b5:                 break;
1:fdaf2b5:             case WRITE_ENCODED_LDSTRING:
1:fdaf2b5:                 writeEncodedLDString(getString(tkn), getString(tkn), getInt(tkn));
1:fdaf2b5:                 break;
1:fdaf2b5:             case WRITE_PADDED_STRING:
1:fdaf2b5:                 str = getString(tkn);
1:fdaf2b5:                 adapter.wWriteBytes(getEBCDIC(str));
1:fdaf2b5:                 int reqLen = getInt(tkn);
1:fdaf2b5:                 int strLen = str.length();
1:fdaf2b5:                 if (strLen < reqLen)
1:fdaf2b5:                     adapter.wPadBytes(ProtocolTestAdapter.SPACE, reqLen-strLen);
1:fdaf2b5:                 break;
1:fdaf2b5:             case READ_REPLY_DSS:
1:fdaf2b5:                 adapter.rReadReplyDss();
1:fdaf2b5:                 break;
1:fdaf2b5:             case SKIP_DSS:
1:fdaf2b5:                 adapter.rSkipDss();
1:fdaf2b5:                 break;
1:fdaf2b5:             case SKIP_DDM:
1:fdaf2b5:                 adapter.rSkipDdm();
1:fdaf2b5:                 break;
1:fdaf2b5:             case MORE_DATA:
1:fdaf2b5:                 str = getString(tkn);
1:fdaf2b5:                 boolean expbool = Boolean.parseBoolean(str);
1:fdaf2b5:                 assertEquals("Too much/little data",
1:fdaf2b5:                         expbool, adapter.rMoreData());
1:fdaf2b5:                 break;
1:fdaf2b5:             case READ_LENGTH_AND_CODEPOINT:
1:fdaf2b5:                 readLengthAndCodePoint(tkn);
1:fdaf2b5:                 break;
1:fdaf2b5:             case READ_SCALAR_2BYTES:
1:fdaf2b5:                 readLengthAndCodePoint(tkn);
1:fdaf2b5:                 val = adapter.rReadNetworkShort();
1:fdaf2b5:                 checkIntOrCP(tkn, val);
1:fdaf2b5:                 break;
1:fdaf2b5:             case READ_SCALAR_1BYTE:
1:fdaf2b5:                 readLengthAndCodePoint(tkn);
1:fdaf2b5:                 val = adapter.rReadByte();
1:fdaf2b5:                 checkIntOrCP(tkn, val);
1:fdaf2b5:                 break;
1:fdaf2b5:             case READ_SECMEC_AND_SECCHKCD:
1:fdaf2b5:                 readSecMecAndSECCHKCD();
1:fdaf2b5:                 break;
1:fdaf2b5:             case READ_BYTES:
1:fdaf2b5:                 assertTrue("Mismatch between the byte arrays",
1:fdaf2b5:                         Arrays.equals(getBytes(tkn), adapter.rReadBytes()));
1:fdaf2b5:                 break;
1:fdaf2b5:             case READ_NETWORK_SHORT:
1:fdaf2b5:                 val = adapter.rReadNetworkShort();
1:fdaf2b5:                 checkIntOrCP(tkn, val);
1:fdaf2b5:                 break;
1:fdaf2b5:             case FLUSH:
1:fdaf2b5:                 adapter.wFlush();
1:fdaf2b5:                 break;
1:fdaf2b5:             case DISPLAY:
1:fdaf2b5:                 println(getString(tkn));
1:fdaf2b5:                 break;
1:fdaf2b5:             case CHECKERROR:
1:fdaf2b5:                 checkError(tkn);
1:fdaf2b5:                 break;
1:fdaf2b5:             case CHECK_SQLCARD:
1:fdaf2b5:                 checkSQLCARD(getInt(tkn), getString(tkn));
1:fdaf2b5:                 break;
1:fdaf2b5:             case END_TEST:
1:fdaf2b5:                 // Nothing to do for ending the test, as resources are closed
1:fdaf2b5:                 // elsewhere. Note that each test case will get it's own
1:fdaf2b5:                 //  connection and set of resources.
1:fdaf2b5:                 println(getName() + " :: FINISHED");
1:fdaf2b5:                 return true;
1:fdaf2b5:             case SKIP_BYTES:
1:fdaf2b5:                 adapter.rSkipBytes();
1:fdaf2b5:                 break;
1:fdaf2b5:             case SWITCH_TO_UTF8_CCSID_MANAGER:
1:fdaf2b5:                 adapter.setUtf8Ccsid();
1:fdaf2b5:                 break;
1:fdaf2b5:             case DELETE_DATABASE:
1:fdaf2b5:                 deleteDatabase(getString(tkn));
1:fdaf2b5:                 break;
1:fdaf2b5:             default:
1:fdaf2b5:                 fail("Command in line " + ln(tkn) + " not implemented: " +
1:fdaf2b5:                         cmd.toString());
1:fdaf2b5:         }
1:fdaf2b5:         return false;
1:fdaf2b5:     }
1:fdaf2b5: 
1:fdaf2b5:     /**
1:fdaf2b5:      * Read an int from the command file
1:fdaf2b5:      * Negative numbers are preceded by "-"
1:fdaf2b5:      */
1:fdaf2b5:     private int getInt(StreamTokenizer tkn) throws IOException
1:fdaf2b5:     {
1:fdaf2b5:         int mult = 1;
1:fdaf2b5:         int val = tkn.nextToken();
1:fdaf2b5:         if (tkn.sval != null && tkn.sval.equals("-"))
1:fdaf2b5:         {
1:fdaf2b5:             mult = -1;
1:fdaf2b5:             val = tkn.nextToken();
1:fdaf2b5:         }
1:fdaf2b5: 
1:fdaf2b5:         if (val != StreamTokenizer.TT_NUMBER)
1:fdaf2b5:         {
1:fdaf2b5:             assertNotNull("Invalid string on line " + ln(tkn), tkn.sval);
1:fdaf2b5:             String str = tkn.sval.toLowerCase(Locale.ENGLISH);
1:fdaf2b5:             if (!str.startsWith("0x")) {
1:fdaf2b5:                 fail("Expecting number, got " + tkn.sval + " on line " +
1:fdaf2b5:                         ln(tkn));
1:fdaf2b5:             } else {
1:fdaf2b5:                 return convertHex(str, ln(tkn));
1:fdaf2b5:             }
1:fdaf2b5:         }
1:39b3237:         return Double.valueOf(tkn.nval).intValue() * mult;
1:fdaf2b5:     }
1:fdaf2b5: 
1:fdaf2b5:     /**
1:fdaf2b5:      * Convert a token in hex format to int from the command file
1:fdaf2b5:      */
1:fdaf2b5:     private int convertHex(String str, int lineNumber) throws IOException
1:fdaf2b5:     {
1:fdaf2b5:         int retval = 0;
1:fdaf2b5:         int len = str.length();
1:fdaf2b5:         if ((len % 2) == 1 || len > 10)
1:fdaf2b5:         {
1:fdaf2b5:             fail("Invalid length for byte string, " + len +
1:fdaf2b5:                     " on line " + lineNumber);
1:fdaf2b5:         }
1:fdaf2b5:         for (int i = 2; i < len; i++)
1:fdaf2b5:         {
1:fdaf2b5:             retval = retval << 4;
1:fdaf2b5:             retval += Byte.valueOf(str.substring(i, i+1), 16).byteValue();
1:fdaf2b5:         }
1:fdaf2b5:         return retval;
1:fdaf2b5:     }
1:fdaf2b5: 
1:fdaf2b5:     /**
1:fdaf2b5:      * checks if value matches next int or cp.
1:fdaf2b5:      * Handles multiple legal values in protocol test file
1:fdaf2b5:      * FORMAT for Multiple Values
1:fdaf2b5:      * MULTIVALSTART 10 SEP 32 SEP 40 MULTIVALEND
1:fdaf2b5:      **/
1:fdaf2b5:     private boolean checkIntOrCP(StreamTokenizer tkn, int val)
1:fdaf2b5:             throws IOException {
1:fdaf2b5:         boolean rval = false;
1:fdaf2b5:         int tknType = tkn.nextToken();
1:fdaf2b5:         String reqVal = " ";
1:fdaf2b5: 
1:fdaf2b5:         if (tknType == StreamTokenizer.TT_WORD &&
1:fdaf2b5:                 tkn.sval.trim().equals(MULTIVAL_START)) {
1:fdaf2b5:             do {
1:fdaf2b5:                 int nextVal = getIntOrCP(tkn);
1:fdaf2b5:                 reqVal = reqVal + nextVal + " ";
1:fdaf2b5:                 rval = rval || (val == nextVal);
1:fdaf2b5:                 tkn.nextToken();
1:fdaf2b5:             }
1:fdaf2b5:             while(tkn.sval.trim().equals(MULTIVAL_SEP));
1:fdaf2b5: 
1:fdaf2b5:             if (! (tkn.sval.trim().equals(MULTIVAL_END)))
1:fdaf2b5:                 fail("Invalid test file format, requires " + MULTIVAL_END +
1:fdaf2b5:                      ", got: " + tkn.sval);
1:fdaf2b5:         }
1:fdaf2b5:         else
1:fdaf2b5:         {
1:fdaf2b5:             tkn.pushBack();
1:fdaf2b5:             int nextVal = getIntOrCP(tkn);
1:fdaf2b5:             reqVal = " " + nextVal;
1:fdaf2b5:             rval = (val == nextVal);
1:fdaf2b5:         }
1:fdaf2b5:         assertTrue("Expected '" + reqVal + "', got '" + val + "'", rval);
1:fdaf2b5: 
1:fdaf2b5:         return rval;
1:fdaf2b5:     }
1:fdaf2b5: 
1:fdaf2b5: 
1:fdaf2b5:     /**
1:fdaf2b5:      * Read an int or codepoint - codepoint is given as a string
1:fdaf2b5:      */
1:fdaf2b5:     private int getIntOrCP(StreamTokenizer tkn) throws IOException
1:fdaf2b5:     {
1:fdaf2b5:         int val = tkn.nextToken();
1:fdaf2b5:         if (val == StreamTokenizer.TT_NUMBER) {
1:fdaf2b5:             return Double.valueOf(tkn.nval).intValue();
1:fdaf2b5:         } else if (val == StreamTokenizer.TT_WORD) {
1:fdaf2b5:             return decodeCP(tkn.sval, ln(tkn));
1:fdaf2b5:         } else {
1:fdaf2b5:             fail("Expecting number, got '" + tkn.sval + "' on line " + ln(tkn));
1:fdaf2b5:         }
1:fdaf2b5:         return 0;
1:fdaf2b5:     }
1:fdaf2b5: 
1:fdaf2b5:     /**
1:fdaf2b5:      * Read an array of bytes from the command file
1:fdaf2b5:      * A byte string can start with 0x in which case the bytes are interpreted
1:fdaf2b5:      * in hex format or it can just be a string, in which case each char is
1:fdaf2b5:      * interpreted as  2 byte UNICODE
1:fdaf2b5:      *
1:fdaf2b5:      * @return byte array
1:fdaf2b5:      */
1:fdaf2b5:     private byte []  getBytes(StreamTokenizer tkn) throws IOException
1:fdaf2b5:     {
1:fdaf2b5:         byte[] retval;
1:fdaf2b5:         tkn.nextToken();
1:fdaf2b5:         assertNotNull("Missing input on line " + ln(tkn), tkn.sval);
1:fdaf2b5:         String str = tkn.sval.toLowerCase(Locale.ENGLISH);
1:fdaf2b5:         if (!str.startsWith("0x"))
1:fdaf2b5:         {
1:fdaf2b5:             //just convert the string to ebcdic byte array
1:fdaf2b5:             return getEBCDIC(str);
1:fdaf2b5:         }
1:fdaf2b5:         else
1:fdaf2b5:         {
1:fdaf2b5:             int len = str.length();
1:fdaf2b5:             if ((len % 2) == 1) {
1:fdaf2b5:                 fail("Invalid length for byte string, " + len +
1:fdaf2b5:                         " on line " + ln(tkn));
1:fdaf2b5:             }
1:fdaf2b5:             retval = new byte[(len-2)/2];
1:fdaf2b5:             int j = 0;
1:fdaf2b5:             for (int i = 2; i < len; i+=2, j++)
1:fdaf2b5:             {
1:fdaf2b5:                 retval[j] = (byte)(Byte.valueOf(str.substring(i, i+1), 16).byteValue() << 4);
1:fdaf2b5:                 retval[j] += Byte.valueOf(str.substring(i+1, i+2), 16).byteValue();
1:fdaf2b5:             }
1:fdaf2b5:         }
1:fdaf2b5:         return retval;
1:fdaf2b5:     }
1:fdaf2b5: 
1:fdaf2b5:     /**
1:fdaf2b5:      * Read a string from the command file
1:fdaf2b5:      *
1:fdaf2b5:      * @return string found in file
1:fdaf2b5:      * @exception     IOException     error reading file
1:fdaf2b5:      */
1:fdaf2b5:     private String getString(StreamTokenizer tkn) throws IOException
1:fdaf2b5:     {
1:fdaf2b5:         int val = tkn.nextToken();
1:fdaf2b5:         assertTrue("Expected string, got number '" + tkn.nval + "' on line " +
1:fdaf2b5:                 ln(tkn), val != StreamTokenizer.TT_NUMBER);
1:fdaf2b5: 
1:fdaf2b5:         /* Check whether '%UTF8TestString%' is in the string and replace
1:fdaf2b5:          * it with Chinese characters for the UTF8 protocol tests */
1:fdaf2b5:         if (tkn.sval.contains(UTF8_TEST_MATCH))
1:fdaf2b5:             return tkn.sval.replace(UTF8_TEST_MATCH, UTF8_TEST_STRING);
1:fdaf2b5: 
1:fdaf2b5:         return tkn.sval;
1:fdaf2b5:     }
1:fdaf2b5: 
1:fdaf2b5:     /**
1:fdaf2b5:      * Read the string version of a CodePoint
1:fdaf2b5:      *
1:fdaf2b5:      * @exception     IOException     error reading file
1:fdaf2b5:      */
1:fdaf2b5:     private int getCP(StreamTokenizer tkn)
1:fdaf2b5:             throws IOException {
1:fdaf2b5:         String strval = getString(tkn);
1:fdaf2b5:         return decodeCP(strval, ln(tkn));
1:fdaf2b5:     }
1:fdaf2b5: 
1:fdaf2b5:     /**
1:fdaf2b5:      * Translate a string codepoint such as ACCSEC to the equivalent int value
1:fdaf2b5:      *
1:fdaf2b5:      * @param strval    string codepoint
1:fdaf2b5:      * @return         integer value of codepoint
1:fdaf2b5:      */
1:fdaf2b5:     private int decodeCP(String strval, int lineNumber) {
1:fdaf2b5:         Integer cp = adapter.decodeCodePoint(strval);
1:fdaf2b5:         assertNotNull("Unknown codepoint '" + strval + "' in line " +
1:fdaf2b5:                 lineNumber, cp);
1:fdaf2b5:         return cp.intValue();
1:fdaf2b5:     }
1:fdaf2b5: 
1:fdaf2b5:     /**
1:fdaf2b5:      * Check error sent back to application requester
1:fdaf2b5:       *
1:fdaf2b5:      * @exception     IOException error reading file or protocol
1:fdaf2b5:      */
1:fdaf2b5:     private void checkError(StreamTokenizer tkn)
1:fdaf2b5:             throws IOException {
1:fdaf2b5:         int svrcod = 0;
1:fdaf2b5:         int invalidCodePoint = 0;
1:fdaf2b5:         int prccnvcd = 0;
1:fdaf2b5:         int synerrcd = 0;
1:fdaf2b5:         int codepoint;
1:fdaf2b5:         int reqVal;
1:fdaf2b5:         ArrayList<Integer> manager = new ArrayList<Integer>();
1:fdaf2b5:         ArrayList<Integer> managerLevel = new ArrayList<Integer>() ;
1:fdaf2b5:         adapter.rReadReplyDss();
1:fdaf2b5:         int error = adapter.rReadLengthAndCodePoint( false );
1:fdaf2b5:         int reqCP = getCP(tkn);
1:fdaf2b5:         assertCP(reqCP, error);
1:fdaf2b5:         while (adapter.rMoreDssData())
1:fdaf2b5:         {
1:fdaf2b5:             codepoint = adapter.rReadLengthAndCodePoint( false );
1:fdaf2b5:             switch (codepoint)
1:fdaf2b5:             {
1:fdaf2b5:                 case ProtocolTestAdapter.CP_SVRCOD:
1:fdaf2b5:                     svrcod = adapter.rReadNetworkShort();
1:fdaf2b5:                     break;
1:fdaf2b5:                 case ProtocolTestAdapter.CP_CODPNT:
1:fdaf2b5:                     invalidCodePoint = adapter.rReadNetworkShort();
1:fdaf2b5:                     break;
1:fdaf2b5:                 case ProtocolTestAdapter.CP_PRCCNVCD:
1:fdaf2b5:                     prccnvcd = adapter.rReadByte();
1:fdaf2b5:                     break;
1:fdaf2b5:                 case ProtocolTestAdapter.CP_SYNERRCD:
1:fdaf2b5:                     synerrcd = adapter.rReadByte();
1:fdaf2b5:                     break;
1:fdaf2b5:                 case ProtocolTestAdapter.CP_MGRLVLLS:
1:fdaf2b5:                     while (adapter.rMoreDdmData())
1:fdaf2b5:                     {
1:fdaf2b5:                         manager.add(Integer.valueOf(adapter.rReadNetworkShort()));
1:fdaf2b5:                         managerLevel.add(Integer.valueOf(adapter.rReadNetworkShort()));
1:fdaf2b5:                     }
1:fdaf2b5:                     break;
1:fdaf2b5:                 default:
1:fdaf2b5:                     //ignore codepoints we don't understand
1:fdaf2b5:                     adapter.rSkipBytes();
1:fdaf2b5:                     println("Skipped bytes for codepoint " + codepoint + " (" +
1:fdaf2b5:                             adapter.lookupCodePoint(codepoint) + ")");
1:fdaf2b5:             }
1:fdaf2b5:         }
1:fdaf2b5:         reqVal = getInt(tkn);
1:fdaf2b5:         assertEquals("Wrong svrcod (0x" + Integer.toHexString(reqVal) +
1:fdaf2b5:                 " != 0x" + Integer.toHexString(svrcod) + ")", reqVal, svrcod);
1:fdaf2b5:         if (error == ProtocolTestAdapter.CP_PRCCNVRM) {
1:fdaf2b5:             reqVal = getInt(tkn);
1:fdaf2b5:             assertEquals("Wrong prccnvcd (0x" + Integer.toHexString(reqVal) +
1:fdaf2b5:                 " != 0x" + Integer.toHexString(prccnvcd) + ")",
1:fdaf2b5:                 reqVal, prccnvcd);
1:fdaf2b5:         }
1:fdaf2b5:         if (error == ProtocolTestAdapter.CP_SYNTAXRM) {
1:fdaf2b5:             reqVal = getInt(tkn);
1:fdaf2b5:             assertEquals("Wrong synerrcd (0x" + Integer.toHexString(reqVal) +
1:fdaf2b5:                 " != 0x" + Integer.toHexString(synerrcd) + ")",
1:fdaf2b5:                 reqVal, synerrcd);
1:fdaf2b5:             reqVal = getIntOrCP(tkn);
1:fdaf2b5:             assertCP(reqVal, invalidCodePoint);
1:fdaf2b5:         }
1:fdaf2b5:         if (error == ProtocolTestAdapter.CP_MGRLVLRM)
1:fdaf2b5:         {
1:fdaf2b5:             int mgr, mgrLevel;
1:fdaf2b5:             for (int i = 0; i < manager.size(); i++)
1:fdaf2b5:             {
1:fdaf2b5:                 reqVal = getCP(tkn);
1:fdaf2b5:                 mgr = manager.get(i);
1:fdaf2b5:                 assertCP(reqVal, mgr);
1:fdaf2b5:                 mgrLevel = managerLevel.get(i);
1:fdaf2b5:                 reqVal = getInt(tkn);
1:fdaf2b5:                 assertEquals("Wrong manager level (0x" +
1:fdaf2b5:                         Integer.toHexString(reqVal) + " != 0x" +
1:fdaf2b5:                         Integer.toHexString(mgrLevel) + ")", reqVal, mgrLevel);
1:fdaf2b5:             }
1:fdaf2b5:         }
1:fdaf2b5:     }
1:fdaf2b5: 
1:fdaf2b5:     /**
1:fdaf2b5:      * Read length and codepoint and check against required values
1:fdaf2b5:       *
1:fdaf2b5:      * @exception     IOException error reading file or protocol
1:fdaf2b5:      */
1:fdaf2b5:     private void readLengthAndCodePoint(StreamTokenizer tkn)
1:fdaf2b5:             throws IOException {
1:fdaf2b5:         int codepoint = adapter.rReadLengthAndCodePoint( false );
1:fdaf2b5:         int reqCP = getCP(tkn);
1:fdaf2b5:         assertCP(reqCP, codepoint);
1:fdaf2b5:     }
1:fdaf2b5: 
1:fdaf2b5:     /**
1:fdaf2b5:      * Handle the case of testing the reading of SECMEC and SECCHKCD,
1:fdaf2b5:      * where on an invalid SECMEC value for ACCSEC, the server can send
1:fdaf2b5:      * valid supported SECMEC values. One of the valid supported value can be
1:fdaf2b5:      * EUSRIDPWD (secmec value of 9) depending on if the server JVM
1:fdaf2b5:      * can actually support it or not.
1:fdaf2b5:      * @exception   IOException error reading file or protocol
1:fdaf2b5:      */
1:fdaf2b5:     private void readSecMecAndSECCHKCD() throws IOException
1:fdaf2b5:     {
1:fdaf2b5:         int codepoint;
1:fdaf2b5:         boolean notDone = true;
1:fdaf2b5:         int val;
1:fdaf2b5:         do
1:fdaf2b5:         {
1:fdaf2b5:             codepoint = adapter.rReadLengthAndCodePoint( false );
1:fdaf2b5:             switch(codepoint)
1:fdaf2b5:             {
1:fdaf2b5:               case ProtocolTestAdapter.CP_SECMEC:
1:fdaf2b5:               {
1:fdaf2b5:                   val = adapter.rReadNetworkShort();
1:fdaf2b5:                   println("SECMEC=" + val);
1:fdaf2b5:               }
1:fdaf2b5:               break;
1:fdaf2b5:               case ProtocolTestAdapter.CP_SECCHKCD:
1:fdaf2b5:               {
1:fdaf2b5:                   val = adapter.rReadByte();
1:fdaf2b5:                   println("SECCHKCD=" + val);
1:fdaf2b5:                   notDone = false;
1:fdaf2b5:               }
1:fdaf2b5:               break;
1:fdaf2b5:               default:
1:fdaf2b5:                   notDone=false;
1:fdaf2b5:             }
1:fdaf2b5:         }while(notDone);
1:fdaf2b5:     }
1:fdaf2b5: 
1:fdaf2b5:     /**
1:fdaf2b5:      * Codepoint error
1:fdaf2b5:       *
1:fdaf2b5:      * @exception IOException error reading command file
1:fdaf2b5:      */
1:fdaf2b5:     private void assertCP(int reqCP, int cp) {
1:fdaf2b5:         String cpName = adapter.lookupCodePoint(cp);
1:fdaf2b5:         String reqCPName = adapter.lookupCodePoint(reqCP);
1:fdaf2b5:         assertEquals("Wrong codepoint (0x" + Integer.toHexString(reqCP) +
1:fdaf2b5:              "/" + reqCPName + " != 0x" + Integer.toHexString(cp) +
1:fdaf2b5:              "/" + cpName + ")", reqCP, cp);
1:fdaf2b5:     }
1:fdaf2b5: 
1:fdaf2b5:     /**
1:fdaf2b5:      * Translate a string to EBCDIC for use in the protocol
1:fdaf2b5:      *
1:fdaf2b5:      * @param str    string to transform
1:fdaf2b5:      * @return EBCDIC string
1:fdaf2b5:      */
1:fdaf2b5:     private byte[] getEBCDIC(String str)
1:fdaf2b5:     {
1:fdaf2b5:         return adapter.convertFromJavaString(str);
1:fdaf2b5:     }
1:fdaf2b5: 
1:fdaf2b5:     /**
1:fdaf2b5:      * Write an encoded string
1:fdaf2b5:      *
1:fdaf2b5:      * @param str    string to write
1:fdaf2b5:      * @param encoding    Java encoding to use
1:fdaf2b5:      * @exception IOException
1:fdaf2b5:      */
1:fdaf2b5:     private void writeEncodedString(String str, String encoding) {
1:fdaf2b5:         try {
1:fdaf2b5:             byte [] buf = str.getBytes(encoding);
1:fdaf2b5:             adapter.wWriteBytes(buf);
1:fdaf2b5:         } catch (UnsupportedEncodingException e) {
1:fdaf2b5:             fail("Unsupported encoding " + encoding, e);
1:fdaf2b5:         }
1:fdaf2b5:     }
1:fdaf2b5: 
1:fdaf2b5:     /**
1:fdaf2b5:      * Write length and encoded string
1:fdaf2b5:      *
1:fdaf2b5:      * @param str string to write
1:fdaf2b5:      * @param encoding    Java encoding to use
1:fdaf2b5:      * @param len            Size of length value (2 or 4 bytes)
1:fdaf2b5:      * @exception IOException
1:fdaf2b5:      */
1:fdaf2b5:     private void writeEncodedLDString(String str, String encoding, int len) {
1:fdaf2b5:         try {
1:fdaf2b5:             byte [] buf = str.getBytes(encoding);
1:fdaf2b5:             if (len == 2)
1:fdaf2b5:                 adapter.wWriteShort(buf.length);
1:fdaf2b5:             else
1:fdaf2b5:                 adapter.wWriteInt(buf.length);
1:fdaf2b5:             adapter.wWriteBytes(buf);
1:fdaf2b5:         } catch (UnsupportedEncodingException e) {
1:fdaf2b5:             fail("Unsupported encoding " + encoding, e);
1:fdaf2b5:         }
1:fdaf2b5:     }
1:fdaf2b5: 
1:fdaf2b5:     /**
1:fdaf2b5:      * Check the value of SQLCARD
1:fdaf2b5:      *
1:fdaf2b5:      * @param sqlCode    SQLCODE value
1:fdaf2b5:      * @param sqlState    SQLSTATE value
1:fdaf2b5:      * @exception IOException, DRDAProtocolException
1:fdaf2b5:      */
1:fdaf2b5:     private void checkSQLCARD(int sqlCode, String sqlState)
1:fdaf2b5:             throws IOException {
1:fdaf2b5:         adapter.rReadReplyDss();
1:fdaf2b5:         int codepoint = adapter.rReadLengthAndCodePoint( false );
1:fdaf2b5:         assertEquals("Expected SQLCARD (0x2408), got " +
1:fdaf2b5:                 Integer.toHexString(codepoint), ProtocolTestAdapter.CP_SQLCARD,
1:fdaf2b5:                 codepoint);
1:fdaf2b5:         adapter.rReadByte(); // Skip null indicator.
1:fdaf2b5:         //cheating here and using readNetworkInt since the byteorder is the same
1:fdaf2b5:         int code = adapter.rReadNetworkInt();
1:fdaf2b5:         assertEquals("Expected " + Integer.toHexString(sqlCode) + ", got " +
1:fdaf2b5:                 Integer.toHexString(code), sqlCode, code);
1:fdaf2b5:         String state = adapter.rReadString(5, "UTF-8");
1:fdaf2b5:         assertEquals("Wrong SQL state", sqlState, state);
1:fdaf2b5:         // skip the rest of the SQLCARD
1:fdaf2b5:         adapter.rSkipBytes();
1:fdaf2b5:     }
1:fdaf2b5: 
1:fdaf2b5:     /**
1:fdaf2b5:      * Calculates the current line number from the source file.
1:fdaf2b5:      * <p>
1:fdaf2b5:      * The intention is to be able to print which line number the test failed
1:fdaf2b5:      * on, so that the source of the error can be easily located.
1:fdaf2b5:      *
1:fdaf2b5:      * @param st processing stream tokenizer
1:fdaf2b5:      * @return The calculated current line number.
1:fdaf2b5:      */
1:fdaf2b5:     private int ln(StreamTokenizer st) {
1:fdaf2b5:         return (this.startLine + st.lineno() -1);
1:fdaf2b5:     }
1:fdaf2b5: 
1:fdaf2b5:     /**
1:fdaf2b5:      * Delete the database with the name 'name'
1:fdaf2b5:      * @param name Name of the database to delete
1:fdaf2b5:      */
1:fdaf2b5:     private void deleteDatabase(String name) {
1:fdaf2b5:         String shutdownUrl = "jdbc:derby:"+name+";shutdown=true";
1:fdaf2b5:         try {
1:fdaf2b5:             DriverManager.getConnection(shutdownUrl);
1:fdaf2b5:         } catch (SQLException sqle) {
1:fdaf2b5:             // ignore shutdown exception
1:fdaf2b5:             BaseJDBCTestCase.assertSQLState("08006", sqle);
1:fdaf2b5:         }
1:fdaf2b5:         removeDirectory(getSystemProperty("derby.system.home") +
1:fdaf2b5:                 File.separator + name);
1:fdaf2b5:     }
1:fdaf2b5: 
1:fdaf2b5:     /**
1:fdaf2b5:      * Creates a suite of tests dynamically from a file describing protocol
1:fdaf2b5:      * tests.
1:fdaf2b5:      *
1:fdaf2b5:      * @return A suite of tests.
1:fdaf2b5:      * @throws Exception if creating the suite fails for some reason
1:fdaf2b5:      */
1:fdaf2b5:     public static Test suite()
1:fdaf2b5:             throws Exception {
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite("Derby DRDA protocol tests");
1:fdaf2b5:         // Process the list of files and create test cases for the sub-tests.
1:fdaf2b5:         // NOTE: We cannot assume anything about the order in which the tests
1:fdaf2b5:         //      are executed.
1:fdaf2b5:         final String testFile = PREFIX + "protocol.tests";
1:fdaf2b5:         final URL testFileURL = BaseTestCase.getTestResource(testFile);
1:fdaf2b5:         BufferedReader bIn = new BufferedReader(
1:fdaf2b5:                 new InputStreamReader(
1:fdaf2b5:                     openTestResource(testFileURL),
1:fdaf2b5:                     Charset.forName("UTF-8")));
1:fdaf2b5: 
1:fdaf2b5:         // Split the tests into individual tests.
1:fdaf2b5:         final String END_TEST = ProtocolTestGrammar.END_TEST.toCmdString();
1:fdaf2b5:         int currentLine = 1;
1:fdaf2b5:         int startLine = 1; // First line is line number one.
1:fdaf2b5:         ArrayList<String> cmdLines = new ArrayList<String>();
1:fdaf2b5:         StringBuilder str = new StringBuilder();
1:fdaf2b5:         String line;
1:fdaf2b5:         // Iterate until the end of test token is reached.
1:fdaf2b5:         while ((line = bIn.readLine()) != null) {
1:fdaf2b5:             cmdLines.add(line);
1:fdaf2b5:             str.append(line).append(NL);
1:fdaf2b5:             if (line.toLowerCase(Locale.ENGLISH).startsWith(END_TEST)) {
1:fdaf2b5:                 // Create a new test case.
1:fdaf2b5:                 suite.addTest(new ProtocolTest(
1:fdaf2b5:                         "protocol.tests",
1:fdaf2b5:                         str.toString(),
1:fdaf2b5:                         startLine,
1:fdaf2b5:                         currentLine - startLine));
1:fdaf2b5:                 cmdLines.clear();
1:fdaf2b5:                 str.setLength(0);
1:fdaf2b5:                 startLine = currentLine +1;
1:fdaf2b5:             }
1:fdaf2b5:             currentLine++;
1:fdaf2b5:         }
1:fdaf2b5:         bIn.close();
1:fdaf2b5: 
1:fdaf2b5:         // Install a security policy and copy the required include files.
1:fdaf2b5:         final String resourcePath = "functionTests/tests/derbynet";
1:fdaf2b5:         return new SecurityManagerSetup(
1:fdaf2b5:                 TestConfiguration.clientServerDecorator(
1:fdaf2b5:                     new SupportFilesSetup(suite, new String[] {
1:fdaf2b5:                         resourcePath + "/connect.inc",
1:fdaf2b5:                         resourcePath + "/excsat_accsecrd1.inc",
1:fdaf2b5:                         resourcePath + "/excsat_accsecrd2.inc",
1:fdaf2b5:                         resourcePath + "/excsat_accsecrd_nordb.inc",
1:fdaf2b5:                         resourcePath + "/excsat_secchk_nordbonaccsec.inc",
1:fdaf2b5:                         resourcePath + "/excsat_secchk.inc",
1:fdaf2b5:                         resourcePath + "/values1.inc",
1:fdaf2b5:                         resourcePath + "/values64kblksz.inc",
1:fdaf2b5:                     })),
1:fdaf2b5:                 PREFIX + "ProtocolTest.policy",
1:fdaf2b5:                 true);
1:fdaf2b5:     }
1:fdaf2b5: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:39b3237
/////////////////////////////////////////////////////////////////////////
1:         return Double.valueOf(tkn.nval).intValue() * mult;
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import java.util.Arrays;
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.BaseTestCase;
1: import org.apache.derbyTesting.junit.BaseTestSuite;
1: import org.apache.derbyTesting.junit.SecurityManagerSetup;
1: import org.apache.derbyTesting.junit.SupportFilesSetup;
1: import org.apache.derbyTesting.junit.TestConfiguration;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite("Derby DRDA protocol tests");
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:eb14359
/////////////////////////////////////////////////////////////////////////
1:     /** Cleans up test resources. */
1:     public void tearDown()
1:             throws Exception {
1:         commandSequence = null;
1:         adapter.close();
1:         adapter = null;
1:         super.tearDown();
1:     }
1: 
commit:fdaf2b5
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derbyTesting.functionTests.tests.derbynet.ProtocolTest
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: package org.apache.derbyTesting.functionTests.tests.derbynet;
1: 
1: import java.io.BufferedReader;
1: import java.io.File;
1: import java.io.IOException;
1: import java.io.InputStreamReader;
1: import java.io.Reader;
1: import java.io.StreamTokenizer;
1: import java.io.StringReader;
1: import java.io.UnsupportedEncodingException;
1: 
1: import java.net.Socket;
1: import java.net.URL;
1: import java.net.UnknownHostException;
1: 
1: import java.nio.charset.Charset;
1: 
1: import java.security.AccessController;
1: import java.security.PrivilegedActionException;
1: 
1: import java.sql.DriverManager;
1: import java.sql.SQLException;
1: 
0: import java.util.Arrays;
1: import java.util.ArrayList;
1: import java.util.Locale;
1: 
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: 
1: import org.apache.derby.impl.drda.ProtocolTestAdapter;
1: 
1: import org.apache.derbyTesting.functionTests.util.PrivilegedFileOpsForTests;
1: import org.apache.derbyTesting.functionTests.util.ProtocolTestGrammar;
1: 
0: import org.apache.derbyTesting.junit.*;
1: 
1: /**
1:  * This class is used to test error conditions in the protocol.
1:  * <p>
1:  * The protocol to send to the Net server is contained in a file encoded
1:  * as calls to routines in {@code DDMReader} and {@code DDMWriter}.
1:  * Additional commands have been added for testing purposes.
1:  * To add tests, modify the file protocol.tests.
1:  * Tests can also be done as separate files and given as an argument to
1:  * this class.
1:  * <p>
1:  * This test was copied / converted from testProto.
1:  */
1: public class ProtocolTest
1:     extends BaseTestCase {
1: 
1:     private static final String PREFIX =
1:         "org/apache/derbyTesting/functionTests/tests/derbynet/";
1:     /** Newline character(s). */
1:     private static final String NL =
1:             BaseTestCase.getSystemProperty("line.separator");
1: 
1:     // Constants used to encode / represent multiple values for a command.
1:     private static final String MULTIVAL_START = "MULTIVALSTART";
1:     private static final String MULTIVAL_SEP = "SEP";
1:     private static final String MULTIVAL_END = "MULTIVALEND";
1: 
1:     // Replaces %UTF8TestString% in protocol.tests
1:     private static final String UTF8_TEST_MATCH = "%UTF8TestString%";
1:     private static final String UTF8_TEST_STRING =
1:             "\u4f60\u597d\u4e16\u754cABCDEFGHIJKLMNOPQ";
1: 
1: 
1:     /** Name of the file from which the test is obtained. */
1:     private final String filename;
1:     /** The start line of the test from the input file. */
1:     private final int startLine;
1:     /** Number of lines this test is composed of. */
1:     private final int lineCount;
1:     /**
1:      * The sequence of commands this test is composed of.
1:      * <p>
1:      * The sequence is expected to be line oriented, that is a one command and
1:      * optionally its arguments per line. The lines must be separated by a
1:      * newline token.
1:      */
1:     private String commandSequence;
1:     /**
1:      * The adapter that lives on the DRDA package, allowing us to call the
1:      * otherwise unavailable methods we need to call in package private
1:      * classes.
1:      */
1:     private ProtocolTestAdapter adapter;
1: 
1:     /**
1:      * Creates a new test case.
1:      *
1:      * @param file name of file containing the protocol tests (for verbosity)
1:      * @param cmds the sequence of commands (see {@link #commandSequence})
1:      * @param startLine starting line in the source file
1:      * @param lines number of lines from the source file
1:      */
1:     private ProtocolTest(String file, String cmds, int startLine, int lines) {
1:         super("testProtocolSequence");
1:         this.filename = file;
1:         this.commandSequence = cmds;
1:         this.startLine = startLine;
1:         this.lineCount = lines;
1:     }
1: 
1:     /**
1:      * Executes the test sequence.
1:      *
1:      * @throws IOException if accessing a file or the socket fails, or if
1:      *      Derby detects an unexpected protocol error
1:      * @throws UnknownHostException if the server host cannot be resolved
1:      */
1:     public void testProtocolSequence()
1:             throws IOException, UnknownHostException {
1:         // Update the name of the test.
1:         super.setName(
1:                 filename + "_" + startLine + "_" + (startLine + lineCount));
1:         println(getName() + " :: STARTED");
1:         // Validate the line count. Expects a newline also at end of last line.
1:         assertEquals("Actual line count does not match the specified count",
1:                 this.lineCount, this.commandSequence.length() -
1:                 this.commandSequence.replaceAll("\n", "").length() -1);
1: 
1:         adapter = new ProtocolTestAdapter(createSocket());
1:         Reader cmdStream = new StringReader(this.commandSequence);
1:         try {
1:             processCommands(cmdStream);
1:         } finally {
1:             try {
1:                 adapter.close();
1:             } catch (IOException ioe) {
1:                 // Don't act on the exception, but print its message.
1:                 alarm("adapter.close() failed: " + ioe.getMessage());
1:             }
1:         }
1:     }
1: 
1:     /**
1:      * Initializes a socket to the server.
1:      *
1:      * @return A socket connected to the server.
1:      * @throws IOException if reading/writing to the socket fails
1:      * @throws UnknownHostException if the server host cannot be resolved
1:      */
1:     private static Socket createSocket()
1:             throws IOException, UnknownHostException {
1:         Socket socket = null;
1:         final TestConfiguration cfg = TestConfiguration.getCurrent();
1:         try {
1:             socket = AccessController.doPrivileged (
1:                 new java.security.PrivilegedExceptionAction<Socket>() {
1:                     public Socket run()
1:                             throws IOException, UnknownHostException {
1:                         return new Socket(cfg.getHostName(), cfg.getPort());
1:                     }
1:                 }
1:             );
1:         } catch (PrivilegedActionException pae) {
1:             if (pae.getCause() instanceof IOException) {
1:                 throw (IOException)pae.getCause();
1:             } else if (pae.getCause() instanceof UnknownHostException) {
1:                 throw (UnknownHostException)pae.getCause();
1:             }
1:             fail("Unhandled exception", pae);
1:         }
1:         return socket;
1:     }
1: 
1:     /**
1:      * Executes the test commands in the specified file.
1:      *
1:      * @param fileName file containing the test
1:      * @throws IOException if accessing a file or the socket fails, or if
1:      *      Derby detects an unexpected protocol error
1:      */
1:     private void processFile(String fileName)
1:             throws IOException {
1:         File incFile = SupportFilesSetup.getReadOnly(fileName);
1:         assertTrue("Missing file: " + fileName,
1:                PrivilegedFileOpsForTests.exists(incFile));
1:         BufferedReader bIn = new BufferedReader(
1:                PrivilegedFileOpsForTests.getFileReader(incFile));
1:         try {
1:             processCommands(bIn);
1:         } finally {
1:             bIn.close();
1:         }
1:     }
1: 
1:     /**
1:      * Processes the test commands in the stream.
1:      *
1:      * @param cmdStream command stream (see {@link #commandSequence})
1:      * @throws IOException if accessing a file or the socket fails, or if
1:      *      Derby detects an unexpected protocol error
1:      */
1:     private void processCommands(Reader cmdStream)
1:             throws  IOException {
1:         StreamTokenizer tkn = new StreamTokenizer(cmdStream);
1:         boolean endSignalled = false;
1:         int val;
1:         while ( (val = tkn.nextToken()) != StreamTokenizer.TT_EOF) {
1:             assertFalse("End signalled, data to process left: " + tkn.sval,
1:                     endSignalled);
1:             switch(val) {
1:                 case StreamTokenizer.TT_NUMBER:
1:                     break;
1:                 case StreamTokenizer.TT_WORD:
1:                     endSignalled = processCommand(tkn);
1:                     break;
1:                 case StreamTokenizer.TT_EOL:
1:                     break;
1:             }
1:         }
1:     }
1: 
1:     /**
1:      * Process a command.
1:      */
1:     private boolean processCommand(StreamTokenizer tkn)
1:         throws IOException
1:     {
1:         ProtocolTestGrammar cmd = ProtocolTestGrammar.cmdFromString(
1:                                         tkn.sval.toLowerCase(Locale.ENGLISH));
1:         if (cmd == null) { // To avoid generating string for each command.
1:             fail("Unknown command '" + tkn.sval + "' in line " + ln(tkn));
1:         }
1:         int val;
1:         String str;
1: 
1:         switch (cmd)
1:         {
1:             case INCLUDE:
1:                 processFile(getString(tkn));
1:                 break;
1:             case CREATE_DSS_REQUEST:
1:                 adapter.wCreateDssRequest();
1:                 break;
1:             case CREATE_DSS_OBJECT:
1:                 adapter.wCreateDssObject();
1:                 break;
1:             case CREATE_DSS_REPLY:
1:                 adapter.wCreateDssReply();
1:                 break;
1:             case END_DSS:
1:                 tkn.nextToken();
1:                 tkn.pushBack();
1:                 if ((tkn.sval != null) && tkn.sval.startsWith("0x"))
1:                 // use specified chaining.
1:                     adapter.wEndDss((getBytes(tkn))[0]);
1:                 else
1:                 // use default chaining
1:                     adapter.wEndDss();
1:                 break;
1:             case END_DDM:
1:                 adapter.wEndDdm();
1:                 break;
1:             case END_DDM_AND_DSS:
1:                 adapter.wEndDdmAndDss();
1:                 break;
1:             case START_DDM:
1:                 adapter.wStartDdm(getCP(tkn));
1:                 break;
1:             case WRITE_SCALAR_STRING:
1:                 adapter.wWriteScalarString(getCP(tkn), getString(tkn));
1:                 break;
1:             case WRITE_SCALAR_2BYTES:
1:                 adapter.wWriteScalar2Bytes(getCP(tkn),getIntOrCP(tkn));
1:                 break;
1:             case WRITE_SCALAR_1BYTE:
1:                 adapter.wWriteScalar1Byte(getCP(tkn),getInt(tkn));
1:                 break;
1:             case WRITE_SCALAR_BYTES:
1:                 adapter.wWriteScalarBytes(getCP(tkn),getBytes(tkn));
1:                 break;
1:             case WRITE_SCALAR_PADDED_BYTES:
1:                 adapter.wWriteScalarPaddedBytes(getCP(tkn), getBytes(tkn),
1:                         getInt(tkn), ProtocolTestAdapter.SPACE);
1:                 break;
1:             case WRITE_BYTE:
1:                 adapter.wWriteByte(getInt(tkn));
1:                 break;
1:             case WRITE_BYTES:
1:                 adapter.wWriteBytes(getBytes(tkn));
1:                 break;
1:             case WRITE_SHORT:
1:                 adapter.wWriteShort(getInt(tkn));
1:                 break;
1:             case WRITE_INT:
1:                 adapter.wWriteInt(getInt(tkn));
1:                 break;
1:             case WRITE_CODEPOINT_4BYTES:
1:                 adapter.wWriteCodePoint4Bytes(getCP(tkn), getInt(tkn));
1:                 break;
1:             case WRITE_STRING:
1:                 str = getString(tkn);
1:                 adapter.wWriteBytes(getEBCDIC(str));
1:                 break;
1:             case WRITE_ENCODED_STRING:
1:                 writeEncodedString(getString(tkn), getString(tkn));
1:                 break;
1:             case WRITE_ENCODED_LDSTRING:
1:                 writeEncodedLDString(getString(tkn), getString(tkn), getInt(tkn));
1:                 break;
1:             case WRITE_PADDED_STRING:
1:                 str = getString(tkn);
1:                 adapter.wWriteBytes(getEBCDIC(str));
1:                 int reqLen = getInt(tkn);
1:                 int strLen = str.length();
1:                 if (strLen < reqLen)
1:                     adapter.wPadBytes(ProtocolTestAdapter.SPACE, reqLen-strLen);
1:                 break;
1:             case READ_REPLY_DSS:
1:                 adapter.rReadReplyDss();
1:                 break;
1:             case SKIP_DSS:
1:                 adapter.rSkipDss();
1:                 break;
1:             case SKIP_DDM:
1:                 adapter.rSkipDdm();
1:                 break;
1:             case MORE_DATA:
1:                 str = getString(tkn);
1:                 boolean expbool = Boolean.parseBoolean(str);
1:                 assertEquals("Too much/little data",
1:                         expbool, adapter.rMoreData());
1:                 break;
1:             case READ_LENGTH_AND_CODEPOINT:
1:                 readLengthAndCodePoint(tkn);
1:                 break;
1:             case READ_SCALAR_2BYTES:
1:                 readLengthAndCodePoint(tkn);
1:                 val = adapter.rReadNetworkShort();
1:                 checkIntOrCP(tkn, val);
1:                 break;
1:             case READ_SCALAR_1BYTE:
1:                 readLengthAndCodePoint(tkn);
1:                 val = adapter.rReadByte();
1:                 checkIntOrCP(tkn, val);
1:                 break;
1:             case READ_SECMEC_AND_SECCHKCD:
1:                 readSecMecAndSECCHKCD();
1:                 break;
1:             case READ_BYTES:
1:                 assertTrue("Mismatch between the byte arrays",
1:                         Arrays.equals(getBytes(tkn), adapter.rReadBytes()));
1:                 break;
1:             case READ_NETWORK_SHORT:
1:                 val = adapter.rReadNetworkShort();
1:                 checkIntOrCP(tkn, val);
1:                 break;
1:             case FLUSH:
1:                 adapter.wFlush();
1:                 break;
1:             case DISPLAY:
1:                 println(getString(tkn));
1:                 break;
1:             case CHECKERROR:
1:                 checkError(tkn);
1:                 break;
1:             case CHECK_SQLCARD:
1:                 checkSQLCARD(getInt(tkn), getString(tkn));
1:                 break;
1:             case END_TEST:
1:                 // Nothing to do for ending the test, as resources are closed
1:                 // elsewhere. Note that each test case will get it's own
1:                 //  connection and set of resources.
1:                 println(getName() + " :: FINISHED");
1:                 return true;
1:             case SKIP_BYTES:
1:                 adapter.rSkipBytes();
1:                 break;
1:             case SWITCH_TO_UTF8_CCSID_MANAGER:
1:                 adapter.setUtf8Ccsid();
1:                 break;
1:             case DELETE_DATABASE:
1:                 deleteDatabase(getString(tkn));
1:                 break;
1:             default:
1:                 fail("Command in line " + ln(tkn) + " not implemented: " +
1:                         cmd.toString());
1:         }
1:         return false;
1:     }
1: 
1:     /**
1:      * Read an int from the command file
1:      * Negative numbers are preceded by "-"
1:      */
1:     private int getInt(StreamTokenizer tkn) throws IOException
1:     {
1:         int mult = 1;
1:         int val = tkn.nextToken();
1:         if (tkn.sval != null && tkn.sval.equals("-"))
1:         {
1:             mult = -1;
1:             val = tkn.nextToken();
1:         }
1: 
1:         if (val != StreamTokenizer.TT_NUMBER)
1:         {
1:             assertNotNull("Invalid string on line " + ln(tkn), tkn.sval);
1:             String str = tkn.sval.toLowerCase(Locale.ENGLISH);
1:             if (!str.startsWith("0x")) {
1:                 fail("Expecting number, got " + tkn.sval + " on line " +
1:                         ln(tkn));
1:             } else {
1:                 return convertHex(str, ln(tkn));
1:             }
1:         }
0:         return (new Double(tkn.nval).intValue() * mult);
1:     }
1: 
1:     /**
1:      * Convert a token in hex format to int from the command file
1:      */
1:     private int convertHex(String str, int lineNumber) throws IOException
1:     {
1:         int retval = 0;
1:         int len = str.length();
1:         if ((len % 2) == 1 || len > 10)
1:         {
1:             fail("Invalid length for byte string, " + len +
1:                     " on line " + lineNumber);
1:         }
1:         for (int i = 2; i < len; i++)
1:         {
1:             retval = retval << 4;
1:             retval += Byte.valueOf(str.substring(i, i+1), 16).byteValue();
1:         }
1:         return retval;
1:     }
1: 
1:     /**
1:      * checks if value matches next int or cp.
1:      * Handles multiple legal values in protocol test file
1:      * FORMAT for Multiple Values
1:      * MULTIVALSTART 10 SEP 32 SEP 40 MULTIVALEND
1:      **/
1:     private boolean checkIntOrCP(StreamTokenizer tkn, int val)
1:             throws IOException {
1:         boolean rval = false;
1:         int tknType = tkn.nextToken();
1:         String reqVal = " ";
1: 
1:         if (tknType == StreamTokenizer.TT_WORD &&
1:                 tkn.sval.trim().equals(MULTIVAL_START)) {
1:             do {
1:                 int nextVal = getIntOrCP(tkn);
1:                 reqVal = reqVal + nextVal + " ";
1:                 rval = rval || (val == nextVal);
1:                 tkn.nextToken();
1:             }
1:             while(tkn.sval.trim().equals(MULTIVAL_SEP));
1: 
1:             if (! (tkn.sval.trim().equals(MULTIVAL_END)))
1:                 fail("Invalid test file format, requires " + MULTIVAL_END +
1:                      ", got: " + tkn.sval);
1:         }
1:         else
1:         {
1:             tkn.pushBack();
1:             int nextVal = getIntOrCP(tkn);
1:             reqVal = " " + nextVal;
1:             rval = (val == nextVal);
1:         }
1:         assertTrue("Expected '" + reqVal + "', got '" + val + "'", rval);
1: 
1:         return rval;
1:     }
1: 
1: 
1:     /**
1:      * Read an int or codepoint - codepoint is given as a string
1:      */
1:     private int getIntOrCP(StreamTokenizer tkn) throws IOException
1:     {
1:         int val = tkn.nextToken();
1:         if (val == StreamTokenizer.TT_NUMBER) {
1:             return Double.valueOf(tkn.nval).intValue();
1:         } else if (val == StreamTokenizer.TT_WORD) {
1:             return decodeCP(tkn.sval, ln(tkn));
1:         } else {
1:             fail("Expecting number, got '" + tkn.sval + "' on line " + ln(tkn));
1:         }
1:         return 0;
1:     }
1: 
1:     /**
1:      * Read an array of bytes from the command file
1:      * A byte string can start with 0x in which case the bytes are interpreted
1:      * in hex format or it can just be a string, in which case each char is
1:      * interpreted as  2 byte UNICODE
1:      *
1:      * @return byte array
1:      */
1:     private byte []  getBytes(StreamTokenizer tkn) throws IOException
1:     {
1:         byte[] retval;
1:         tkn.nextToken();
1:         assertNotNull("Missing input on line " + ln(tkn), tkn.sval);
1:         String str = tkn.sval.toLowerCase(Locale.ENGLISH);
1:         if (!str.startsWith("0x"))
1:         {
1:             //just convert the string to ebcdic byte array
1:             return getEBCDIC(str);
1:         }
1:         else
1:         {
1:             int len = str.length();
1:             if ((len % 2) == 1) {
1:                 fail("Invalid length for byte string, " + len +
1:                         " on line " + ln(tkn));
1:             }
1:             retval = new byte[(len-2)/2];
1:             int j = 0;
1:             for (int i = 2; i < len; i+=2, j++)
1:             {
1:                 retval[j] = (byte)(Byte.valueOf(str.substring(i, i+1), 16).byteValue() << 4);
1:                 retval[j] += Byte.valueOf(str.substring(i+1, i+2), 16).byteValue();
1:             }
1:         }
1:         return retval;
1:     }
1: 
1:     /**
1:      * Read a string from the command file
1:      *
1:      * @return string found in file
1:      * @exception     IOException     error reading file
1:      */
1:     private String getString(StreamTokenizer tkn) throws IOException
1:     {
1:         int val = tkn.nextToken();
1:         assertTrue("Expected string, got number '" + tkn.nval + "' on line " +
1:                 ln(tkn), val != StreamTokenizer.TT_NUMBER);
1: 
1:         /* Check whether '%UTF8TestString%' is in the string and replace
1:          * it with Chinese characters for the UTF8 protocol tests */
1:         if (tkn.sval.contains(UTF8_TEST_MATCH))
1:             return tkn.sval.replace(UTF8_TEST_MATCH, UTF8_TEST_STRING);
1: 
1:         return tkn.sval;
1:     }
1: 
1:     /**
1:      * Read the string version of a CodePoint
1:      *
1:      * @exception     IOException     error reading file
1:      */
1:     private int getCP(StreamTokenizer tkn)
1:             throws IOException {
1:         String strval = getString(tkn);
1:         return decodeCP(strval, ln(tkn));
1:     }
1: 
1:     /**
1:      * Translate a string codepoint such as ACCSEC to the equivalent int value
1:      *
1:      * @param strval    string codepoint
1:      * @return         integer value of codepoint
1:      */
1:     private int decodeCP(String strval, int lineNumber) {
1:         Integer cp = adapter.decodeCodePoint(strval);
1:         assertNotNull("Unknown codepoint '" + strval + "' in line " +
1:                 lineNumber, cp);
1:         return cp.intValue();
1:     }
1: 
1:     /**
1:      * Check error sent back to application requester
1:       *
1:      * @exception     IOException error reading file or protocol
1:      */
1:     private void checkError(StreamTokenizer tkn)
1:             throws IOException {
1:         int svrcod = 0;
1:         int invalidCodePoint = 0;
1:         int prccnvcd = 0;
1:         int synerrcd = 0;
1:         int codepoint;
1:         int reqVal;
1:         ArrayList<Integer> manager = new ArrayList<Integer>();
1:         ArrayList<Integer> managerLevel = new ArrayList<Integer>() ;
1:         adapter.rReadReplyDss();
1:         int error = adapter.rReadLengthAndCodePoint( false );
1:         int reqCP = getCP(tkn);
1:         assertCP(reqCP, error);
1:         while (adapter.rMoreDssData())
1:         {
1:             codepoint = adapter.rReadLengthAndCodePoint( false );
1:             switch (codepoint)
1:             {
1:                 case ProtocolTestAdapter.CP_SVRCOD:
1:                     svrcod = adapter.rReadNetworkShort();
1:                     break;
1:                 case ProtocolTestAdapter.CP_CODPNT:
1:                     invalidCodePoint = adapter.rReadNetworkShort();
1:                     break;
1:                 case ProtocolTestAdapter.CP_PRCCNVCD:
1:                     prccnvcd = adapter.rReadByte();
1:                     break;
1:                 case ProtocolTestAdapter.CP_SYNERRCD:
1:                     synerrcd = adapter.rReadByte();
1:                     break;
1:                 case ProtocolTestAdapter.CP_MGRLVLLS:
1:                     while (adapter.rMoreDdmData())
1:                     {
1:                         manager.add(Integer.valueOf(adapter.rReadNetworkShort()));
1:                         managerLevel.add(Integer.valueOf(adapter.rReadNetworkShort()));
1:                     }
1:                     break;
1:                 default:
1:                     //ignore codepoints we don't understand
1:                     adapter.rSkipBytes();
1:                     println("Skipped bytes for codepoint " + codepoint + " (" +
1:                             adapter.lookupCodePoint(codepoint) + ")");
1:             }
1:         }
1:         reqVal = getInt(tkn);
1:         assertEquals("Wrong svrcod (0x" + Integer.toHexString(reqVal) +
1:                 " != 0x" + Integer.toHexString(svrcod) + ")", reqVal, svrcod);
1:         if (error == ProtocolTestAdapter.CP_PRCCNVRM) {
1:             reqVal = getInt(tkn);
1:             assertEquals("Wrong prccnvcd (0x" + Integer.toHexString(reqVal) +
1:                 " != 0x" + Integer.toHexString(prccnvcd) + ")",
1:                 reqVal, prccnvcd);
1:         }
1:         if (error == ProtocolTestAdapter.CP_SYNTAXRM) {
1:             reqVal = getInt(tkn);
1:             assertEquals("Wrong synerrcd (0x" + Integer.toHexString(reqVal) +
1:                 " != 0x" + Integer.toHexString(synerrcd) + ")",
1:                 reqVal, synerrcd);
1:             reqVal = getIntOrCP(tkn);
1:             assertCP(reqVal, invalidCodePoint);
1:         }
1:         if (error == ProtocolTestAdapter.CP_MGRLVLRM)
1:         {
1:             int mgr, mgrLevel;
1:             for (int i = 0; i < manager.size(); i++)
1:             {
1:                 reqVal = getCP(tkn);
1:                 mgr = manager.get(i);
1:                 assertCP(reqVal, mgr);
1:                 mgrLevel = managerLevel.get(i);
1:                 reqVal = getInt(tkn);
1:                 assertEquals("Wrong manager level (0x" +
1:                         Integer.toHexString(reqVal) + " != 0x" +
1:                         Integer.toHexString(mgrLevel) + ")", reqVal, mgrLevel);
1:             }
1:         }
1:     }
1: 
1:     /**
1:      * Read length and codepoint and check against required values
1:       *
1:      * @exception     IOException error reading file or protocol
1:      */
1:     private void readLengthAndCodePoint(StreamTokenizer tkn)
1:             throws IOException {
1:         int codepoint = adapter.rReadLengthAndCodePoint( false );
1:         int reqCP = getCP(tkn);
1:         assertCP(reqCP, codepoint);
1:     }
1: 
1:     /**
1:      * Handle the case of testing the reading of SECMEC and SECCHKCD,
1:      * where on an invalid SECMEC value for ACCSEC, the server can send
1:      * valid supported SECMEC values. One of the valid supported value can be
1:      * EUSRIDPWD (secmec value of 9) depending on if the server JVM
1:      * can actually support it or not.
1:      * @exception   IOException error reading file or protocol
1:      */
1:     private void readSecMecAndSECCHKCD() throws IOException
1:     {
1:         int codepoint;
1:         boolean notDone = true;
1:         int val;
1:         do
1:         {
1:             codepoint = adapter.rReadLengthAndCodePoint( false );
1:             switch(codepoint)
1:             {
1:               case ProtocolTestAdapter.CP_SECMEC:
1:               {
1:                   val = adapter.rReadNetworkShort();
1:                   println("SECMEC=" + val);
1:               }
1:               break;
1:               case ProtocolTestAdapter.CP_SECCHKCD:
1:               {
1:                   val = adapter.rReadByte();
1:                   println("SECCHKCD=" + val);
1:                   notDone = false;
1:               }
1:               break;
1:               default:
1:                   notDone=false;
1:             }
1:         }while(notDone);
1:     }
1: 
1:     /**
1:      * Codepoint error
1:       *
1:      * @exception IOException error reading command file
1:      */
1:     private void assertCP(int reqCP, int cp) {
1:         String cpName = adapter.lookupCodePoint(cp);
1:         String reqCPName = adapter.lookupCodePoint(reqCP);
1:         assertEquals("Wrong codepoint (0x" + Integer.toHexString(reqCP) +
1:              "/" + reqCPName + " != 0x" + Integer.toHexString(cp) +
1:              "/" + cpName + ")", reqCP, cp);
1:     }
1: 
1:     /**
1:      * Translate a string to EBCDIC for use in the protocol
1:      *
1:      * @param str    string to transform
1:      * @return EBCDIC string
1:      */
1:     private byte[] getEBCDIC(String str)
1:     {
1:         return adapter.convertFromJavaString(str);
1:     }
1: 
1:     /**
1:      * Write an encoded string
1:      *
1:      * @param str    string to write
1:      * @param encoding    Java encoding to use
1:      * @exception IOException
1:      */
1:     private void writeEncodedString(String str, String encoding) {
1:         try {
1:             byte [] buf = str.getBytes(encoding);
1:             adapter.wWriteBytes(buf);
1:         } catch (UnsupportedEncodingException e) {
1:             fail("Unsupported encoding " + encoding, e);
1:         }
1:     }
1: 
1:     /**
1:      * Write length and encoded string
1:      *
1:      * @param str string to write
1:      * @param encoding    Java encoding to use
1:      * @param len            Size of length value (2 or 4 bytes)
1:      * @exception IOException
1:      */
1:     private void writeEncodedLDString(String str, String encoding, int len) {
1:         try {
1:             byte [] buf = str.getBytes(encoding);
1:             if (len == 2)
1:                 adapter.wWriteShort(buf.length);
1:             else
1:                 adapter.wWriteInt(buf.length);
1:             adapter.wWriteBytes(buf);
1:         } catch (UnsupportedEncodingException e) {
1:             fail("Unsupported encoding " + encoding, e);
1:         }
1:     }
1: 
1:     /**
1:      * Check the value of SQLCARD
1:      *
1:      * @param sqlCode    SQLCODE value
1:      * @param sqlState    SQLSTATE value
1:      * @exception IOException, DRDAProtocolException
1:      */
1:     private void checkSQLCARD(int sqlCode, String sqlState)
1:             throws IOException {
1:         adapter.rReadReplyDss();
1:         int codepoint = adapter.rReadLengthAndCodePoint( false );
1:         assertEquals("Expected SQLCARD (0x2408), got " +
1:                 Integer.toHexString(codepoint), ProtocolTestAdapter.CP_SQLCARD,
1:                 codepoint);
1:         adapter.rReadByte(); // Skip null indicator.
1:         //cheating here and using readNetworkInt since the byteorder is the same
1:         int code = adapter.rReadNetworkInt();
1:         assertEquals("Expected " + Integer.toHexString(sqlCode) + ", got " +
1:                 Integer.toHexString(code), sqlCode, code);
1:         String state = adapter.rReadString(5, "UTF-8");
1:         assertEquals("Wrong SQL state", sqlState, state);
1:         // skip the rest of the SQLCARD
1:         adapter.rSkipBytes();
1:     }
1: 
1:     /**
1:      * Calculates the current line number from the source file.
1:      * <p>
1:      * The intention is to be able to print which line number the test failed
1:      * on, so that the source of the error can be easily located.
1:      *
1:      * @param st processing stream tokenizer
1:      * @return The calculated current line number.
1:      */
1:     private int ln(StreamTokenizer st) {
1:         return (this.startLine + st.lineno() -1);
1:     }
1: 
1:     /**
1:      * Delete the database with the name 'name'
1:      * @param name Name of the database to delete
1:      */
1:     private void deleteDatabase(String name) {
1:         String shutdownUrl = "jdbc:derby:"+name+";shutdown=true";
1:         try {
1:             DriverManager.getConnection(shutdownUrl);
1:         } catch (SQLException sqle) {
1:             // ignore shutdown exception
1:             BaseJDBCTestCase.assertSQLState("08006", sqle);
1:         }
1:         removeDirectory(getSystemProperty("derby.system.home") +
1:                 File.separator + name);
1:     }
1: 
1:     /**
1:      * Creates a suite of tests dynamically from a file describing protocol
1:      * tests.
1:      *
1:      * @return A suite of tests.
1:      * @throws Exception if creating the suite fails for some reason
1:      */
1:     public static Test suite()
1:             throws Exception {
0:         TestSuite suite = new TestSuite("Derby DRDA protocol tests");
1:         // Process the list of files and create test cases for the sub-tests.
1:         // NOTE: We cannot assume anything about the order in which the tests
1:         //      are executed.
1:         final String testFile = PREFIX + "protocol.tests";
1:         final URL testFileURL = BaseTestCase.getTestResource(testFile);
1:         BufferedReader bIn = new BufferedReader(
1:                 new InputStreamReader(
1:                     openTestResource(testFileURL),
1:                     Charset.forName("UTF-8")));
1: 
1:         // Split the tests into individual tests.
1:         final String END_TEST = ProtocolTestGrammar.END_TEST.toCmdString();
1:         int currentLine = 1;
1:         int startLine = 1; // First line is line number one.
1:         ArrayList<String> cmdLines = new ArrayList<String>();
1:         StringBuilder str = new StringBuilder();
1:         String line;
1:         // Iterate until the end of test token is reached.
1:         while ((line = bIn.readLine()) != null) {
1:             cmdLines.add(line);
1:             str.append(line).append(NL);
1:             if (line.toLowerCase(Locale.ENGLISH).startsWith(END_TEST)) {
1:                 // Create a new test case.
1:                 suite.addTest(new ProtocolTest(
1:                         "protocol.tests",
1:                         str.toString(),
1:                         startLine,
1:                         currentLine - startLine));
1:                 cmdLines.clear();
1:                 str.setLength(0);
1:                 startLine = currentLine +1;
1:             }
1:             currentLine++;
1:         }
1:         bIn.close();
1: 
1:         // Install a security policy and copy the required include files.
1:         final String resourcePath = "functionTests/tests/derbynet";
1:         return new SecurityManagerSetup(
1:                 TestConfiguration.clientServerDecorator(
1:                     new SupportFilesSetup(suite, new String[] {
1:                         resourcePath + "/connect.inc",
1:                         resourcePath + "/excsat_accsecrd1.inc",
1:                         resourcePath + "/excsat_accsecrd2.inc",
1:                         resourcePath + "/excsat_accsecrd_nordb.inc",
1:                         resourcePath + "/excsat_secchk_nordbonaccsec.inc",
1:                         resourcePath + "/excsat_secchk.inc",
1:                         resourcePath + "/values1.inc",
1:                         resourcePath + "/values64kblksz.inc",
1:                     })),
1:                 PREFIX + "ProtocolTest.policy",
1:                 true);
1:     }
1: }
============================================================================