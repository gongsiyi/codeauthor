1:2bc809f: /*
1:2bc809f: 
1:2bc809f:    Derby - Class org.apache.derbyTesting.unitTests.store.T_RecoverBadLog
1:2bc809f: 
1:c38b841:    Licensed to the Apache Software Foundation (ASF) under one or more
1:c38b841:    contributor license agreements.  See the NOTICE file distributed with
1:c38b841:    this work for additional information regarding copyright ownership.
1:c38b841:    The ASF licenses this file to You under the Apache License, Version 2.0
1:c38b841:    (the "License"); you may not use this file except in compliance with
1:c38b841:    the License.  You may obtain a copy of the License at
1:2bc809f: 
1:2bc809f:       http://www.apache.org/licenses/LICENSE-2.0
1:2bc809f: 
1:2bc809f:    Unless required by applicable law or agreed to in writing, software
1:2bc809f:    distributed under the License is distributed on an "AS IS" BASIS,
1:2bc809f:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:2bc809f:    See the License for the specific language governing permissions and
1:2bc809f:    limitations under the License.
1:2bc809f: 
1:2bc809f:  */
1:2bc809f: 
1:2bc809f: package org.apache.derbyTesting.unitTests.store;
1:2bc809f: 
1:2bc809f: import org.apache.derbyTesting.unitTests.harness.T_Generic;
1:2bc809f: import org.apache.derbyTesting.unitTests.harness.T_Fail;
1:2bc809f: import org.apache.derbyTesting.unitTests.harness.UnitTest;
1:2bc809f: 
1:2bc809f: import org.apache.derby.impl.store.raw.log.*;
1:2bc809f: 
1:2bc809f: import org.apache.derby.iapi.services.context.ContextService;
1:2bc809f: import org.apache.derby.iapi.services.context.ContextManager;
1:2bc809f: import org.apache.derby.iapi.services.daemon.DaemonService;
1:2bc809f: import org.apache.derby.iapi.services.monitor.Monitor;
1:2bc809f: import org.apache.derby.iapi.services.locks.LockFactory;
1:2bc809f: import org.apache.derby.iapi.services.io.Storable;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:2bc809f: import org.apache.derby.iapi.reference.Property;
1:2bc809f: import org.apache.derby.iapi.reference.EngineType;
1:2bc809f: import org.apache.derby.iapi.services.property.PropertyUtil;
1:2bc809f: import org.apache.derby.iapi.services.io.FormatableBitSet;
1:aaea357: import org.apache.derby.io.StorageRandomAccessFile;
1:2bc809f: 
1:2bc809f: import org.apache.derby.iapi.error.StandardException;
1:2bc809f: 
1:2bc809f: import org.apache.derby.iapi.store.raw.*;
1:2bc809f: 
1:2bc809f: import org.apache.derby.iapi.store.access.conglomerate.LogicalUndo;
1:2bc809f: 
1:2bc809f: import org.apache.derby.iapi.store.access.Qualifier;
1:2bc809f: 
1:2bc809f: import java.io.IOException;
1:2bc809f: import java.io.RandomAccessFile;
1:2bc809f: import java.io.File;
1:a0dbbd7: import java.security.PrivilegedAction;
1:a0dbbd7: import java.security.AccessController;
1:56c1dc2: import java.security.PrivilegedActionException;
1:56c1dc2: import java.security.PrivilegedExceptionAction;
1:2bc809f: import java.util.Properties;
1:2bc809f: 
1:2bc809f: 
1:2bc809f: 
1:2bc809f: /**
1:2bc809f: 	A implementation unit test for recovering log that has been damanged but salvagable.
1:2bc809f: 
1:2bc809f:     To run, create a derby.properties file in a new directory with the
1:2bc809f: 	contents
1:2bc809f: 
1:2bc809f: 	derby.module.test.recoverBadLog=org.apache.derbyTesting.unitTests.store.T_RecoverBadLog
1:2bc809f: 
1:2bc809f:     Execute in order
1:2bc809f: 
1:aaea357: 	To Test Bad Log due to partial write that are identified by checking the
1:aaea357: 	length in the beginning and end of the log record. 
1:2bc809f: 
1:2bc809f: 	java -DTestBadLogSetup=true org.apache.derbyTesting.unitTests.harness.UnitTestMain
1:2bc809f: 	java -DTestBadLog1=true org.apache.derbyTesting.unitTests.harness.UnitTestMain
1:2bc809f: 	java -DTestBadLog2=true org.apache.derbyTesting.unitTests.harness.UnitTestMain
1:2bc809f: 	java -DTestBadLog3=true org.apache.derbyTesting.unitTests.harness.UnitTestMain
1:2bc809f: 	java -DTestBadLog4=true org.apache.derbyTesting.unitTests.harness.UnitTestMain
1:2bc809f: 	java -DTestBadLog5=true org.apache.derbyTesting.unitTests.harness.UnitTestMain
1:2bc809f: 	java -DTestBadLog6=true org.apache.derbyTesting.unitTests.harness.UnitTestMain
1:2bc809f: 	java -DTestBadLog7=true org.apache.derbyTesting.unitTests.harness.UnitTestMain
1:2bc809f: 	java -DTestBadLog1=true org.apache.derbyTesting.unitTests.harness.UnitTestMain
1:2bc809f: 
1:aaea357: 	To Test Bad Log due to an incomplete out of order write that is identified
1:aaea357: 	by the checksum logic (simulated by	explicitly corrupting a middle of a 
1:aaea357: 	log record at  the  end of log file after it is written).
1:2bc809f: 	
1:aaea357: 	java -DTestBadLogSetup=true -DTestBadChecksumLog=true org.apache.derbyTesting.unitTests.harness.UnitTestMain
1:aaea357: 	java -DTestBadLog1=true -DTestBadChecksumLog=true org.apache.derbyTesting.unitTests.harness.UnitTestMain
1:aaea357: 	java -DTestBadLog2=true -DTestBadChecksumLog=true org.apache.derbyTesting.unitTests.harness.UnitTestMain
1:aaea357: 	java -DTestBadLog3=true -DTestBadChecksumLog=true org.apache.derbyTesting.unitTests.harness.UnitTestMain
1:aaea357: 	java -DTestBadLog4=true -DTestBadChecksumLog=true org.apache.derbyTesting.unitTests.harness.UnitTestMain
1:aaea357: 	java -DTestBadLog5=true -DTestBadChecksumLog=true org.apache.derbyTesting.unitTests.harness.UnitTestMain
1:aaea357: 	java -DTestBadLog6=true -DTestBadChecksumLog=true org.apache.derbyTesting.unitTests.harness.UnitTestMain
1:aaea357: 	java -DTestBadLog7=true -DTestBadChecksumLog=true org.apache.derbyTesting.unitTests.harness.UnitTestMain
1:aaea357: 	java -DTestBadLog1=true -DTestBadChecksumLog=true org.apache.derbyTesting.unitTests.harness.UnitTestMain
1:2bc809f: 	
1:2bc809f: 	
1:2bc809f: */
342:aaea357: 
1:2bc809f: public class T_RecoverBadLog extends T_Generic {
1:2bc809f: 
1:aaea357: 	private  String testService = "BadLogTest";
1:2bc809f: 
1:2bc809f: 	static final String REC_001 = "McLaren";
1:2bc809f: 	static final String REC_002 = "Ferrari";
1:2bc809f: 	static final String REC_003 = "Benetton";
1:2bc809f: 	static final String REC_004 = "Prost";
1:2bc809f: 	static final String REC_005 = "Tyrell";
1:2bc809f: 	static final String REC_006 = "Derby, Natscape, Goatscape, the popular names";
1:2bc809f: 	static final String REC_UNDO = "Lotus";
1:2bc809f: 
1:2bc809f: 	static final String SP1 = "savepoint1";
1:2bc809f: 	static final String SP2 = "savepoint2";
1:2bc809f: 
1:2bc809f: 	private RandomAccessFile infofile = null;
1:2bc809f: 
1:2bc809f: 	private boolean setup;
1:2bc809f: 	private boolean test1;
1:2bc809f: 	private boolean test2;
1:2bc809f: 	private boolean test3;
1:2bc809f: 	private boolean test4;
1:2bc809f: 	private boolean test5;
1:2bc809f: 	private boolean test6;
1:2bc809f: 	private boolean test7;
1:aaea357: 	private boolean checksumTest; 
1:2bc809f: 	
1:aaea357: 	private  String infoPath = "extinout/T_RecoverBadLog.info";
1:2bc809f: 
1:2bc809f: 	private static final String TEST_BADLOG_SETUP = "TestBadLogSetup";
1:2bc809f: 	private static final String TEST_BADLOG1 = "TestBadLog1";
1:2bc809f: 	private static final String TEST_BADLOG2 = "TestBadLog2";
1:2bc809f: 	private static final String TEST_BADLOG3 = "TestBadLog3";
1:2bc809f: 	private static final String TEST_BADLOG4 = "TestBadLog4";
1:2bc809f: 	private static final String TEST_BADLOG5 = "TestBadLog5";
1:2bc809f: 	private static final String TEST_BADLOG6 = "TestBadLog6";
1:2bc809f: 	private static final String TEST_BADLOG7 = "TestBadLog7";
1:2bc809f: 
1:aaea357: 	private static final String TEST_BAD_CHECKSUM_LOG = "TestBadChecksumLog";
1:aaea357: 
1:2bc809f: 	private static final String TEST_BADLOG_INFO = "TestBadLogInfo";
1:aaea357: 	private static final String TEST_BADCHECKSUMLOG_INFO = "TestBadChecksumLogInfo";
1:2bc809f: 
1:2bc809f: 	RawStoreFactory	factory;
1:2bc809f: 	LockFactory  lf;
1:aaea357: 	LogToFile   logFactory;
1:2bc809f: 	ContextService contextService;
1:2bc809f: 	T_Util t_util;
1:2bc809f: 
1:2bc809f: 	public T_RecoverBadLog() {
1:2bc809f: 		super();
1:2bc809f: 	}
1:a0dbbd7: 
1:2bc809f: 	/*
1:2bc809f: 	** Methods required by T_Generic
1:2bc809f: 	*/
1:2bc809f: 
1:2bc809f: 	public String getModuleToTestProtocolName() {
1:2bc809f: 		return RawStoreFactory.MODULE;
1:2bc809f: 	}
1:2bc809f: 
1:a0dbbd7: 	/**
1:2bc809f: 	*/
1:2bc809f: 	private void getConfig()
1:2bc809f: 	{
1:2bc809f: 		String param;
1:2bc809f: 
1:2bc809f: 		param = PropertyUtil.getSystemProperty(TEST_BADLOG_SETUP);
1:2bc809f: 		setup = Boolean.valueOf(param).booleanValue();
1:2bc809f: 
1:2bc809f: 		param = PropertyUtil.getSystemProperty(TEST_BADLOG1);
1:2bc809f: 		test1 = Boolean.valueOf(param).booleanValue();
1:2bc809f: 
1:2bc809f: 		param = PropertyUtil.getSystemProperty(TEST_BADLOG2);
1:2bc809f: 		test2 = Boolean.valueOf(param).booleanValue();
1:2bc809f: 
1:2bc809f: 		param = PropertyUtil.getSystemProperty(TEST_BADLOG3);
1:2bc809f: 		test3 = Boolean.valueOf(param).booleanValue();
1:2bc809f: 		
1:2bc809f: 		
1:2bc809f: 		param = PropertyUtil.getSystemProperty(TEST_BADLOG4);
1:2bc809f: 		test4 = Boolean.valueOf(param).booleanValue();
1:2bc809f: 		
1:2bc809f: 		param = PropertyUtil.getSystemProperty(TEST_BADLOG5);
1:2bc809f: 		test5 = Boolean.valueOf(param).booleanValue();
1:2bc809f: 
1:2bc809f: 		param = PropertyUtil.getSystemProperty(TEST_BADLOG6);
1:2bc809f: 		test6 = Boolean.valueOf(param).booleanValue();
1:2bc809f: 
1:2bc809f: 		param = PropertyUtil.getSystemProperty(TEST_BADLOG7);
1:2bc809f: 		test7 = Boolean.valueOf(param).booleanValue();
1:2bc809f: 		
1:aaea357: 		param = PropertyUtil.getSystemProperty(TEST_BAD_CHECKSUM_LOG);
1:aaea357: 		checksumTest = Boolean.valueOf(param).booleanValue();
1:2bc809f: 		
1:aaea357: 		if(checksumTest)
1:a0dbbd7: 		{
1:aaea357: 			infoPath = "extinout/T_RecoverBadChecksumLog.info";
1:aaea357: 			testService = "BadChecksumLogTest";
1:a0dbbd7: 		}
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 
1:2bc809f: 	/**
1:2bc809f: 	    See T_Recovery for the general testing frame work
1:2bc809f: 
1:2bc809f: 		@exception T_Fail Unexpected behaviour from the API
1:2bc809f: 	 */
1:2bc809f: 	public void runTests() throws T_Fail {
1:2bc809f: 
1:2bc809f: 		getConfig();
1:2bc809f: 		int tests = 0;
1:2bc809f: 		if (setup) tests++;
1:2bc809f: 		if (test1) tests++;
1:2bc809f: 		if (test2) tests++;
1:2bc809f: 		if (test3) tests++;
1:2bc809f: 		if (test4) tests++;
1:2bc809f: 		if (test5) tests++;
1:2bc809f: 		if (test6) tests++;
1:2bc809f: 		if (test7) tests++;
1:2bc809f: 		
1:2bc809f: 		if (tests != 1)
1:2bc809f: 			throw T_Fail.testFailMsg("One & only one of the bad log recovery test should be run");
1:2bc809f: 
1:2bc809f: 		if (!SanityManager.DEBUG)
1:a0dbbd7: 		{
1:2bc809f: 			REPORT("recoverBadLog cannot be run on an insane server");
1:2bc809f: 			return;
1:2bc809f: 		}
1:2bc809f: 
1:2bc809f: 		try {
1:a0dbbd7: 			contextService = getContextService();
1:2bc809f: 
1:2bc809f: 			File ifile = new File(infoPath);
1:2bc809f: 
1:2bc809f: 			//
1:2bc809f: 			// no checkpoint log record in any of the log files - unless this value
1:2bc809f: 			// is reset. LogToFile.TEST_LOG_SWITCH_LOG
1:2bc809f: 			// this will cause recovery to switch log without checkpointing
1:2bc809f: 			//
1:2bc809f: 			SanityManager.DEBUG_SET(LogToFile.TEST_LOG_SWITCH_LOG);
1:2bc809f: 
1:2bc809f: 			// don't want background checkpoint process to be running
1:2bc809f: 			SanityManager.DEBUG_SET(DaemonService.DaemonOff);
1:2bc809f: 
1:2bc809f: 			// see if we are testing encryption
1:2bc809f: 			startParams = T_Util.setEncryptionParam(startParams);
1:2bc809f: 
1:2bc809f: 			if (setup)				// the first test cleans up and start from fresh
1:2bc809f: 			{
1:2bc809f: 				// remove the service directory to ensure a clean run
1:2bc809f: 				REPORT("_______________________________________________________");
1:2bc809f: 				REPORT("\n\t\tcleaning up database for recovering from bad logs");
1:2bc809f: 				REPORT("_______________________________________________________");
1:2bc809f: 
1:2bc809f: 				// don't automatic boot this service if it gets left around
1:2bc809f: 				if (startParams == null) 
1:2bc809f: 					startParams = new Properties();
1:2bc809f: 				
1:2bc809f: 				startParams.put(Property.NO_AUTO_BOOT, Boolean.TRUE.toString());
1:2bc809f: 				// remove the service directory to ensure a clean run
1:2bc809f: 				startParams.put(Property.DELETE_ON_CREATE, Boolean.TRUE.toString());
1:2bc809f: 
1:56c1dc2: 				factory = (RawStoreFactory) createPersistentService(getModuleToTestProtocolName(),
1:2bc809f: 															  testService,
1:2bc809f: 															  startParams);
1:2bc809f: 				// create a database with nothing
1:2bc809f: 
1:2bc809f: 				// delete the info file
1:2bc809f: 				if (ifile.exists())
1:2bc809f: 					ifile.delete();
1:2bc809f: 
1:2bc809f: 				return;				// don't run anything now
1:2bc809f: 
1:2bc809f: 			}
1:2bc809f: 			else					// not setup, recover it
1:2bc809f: 			{
1:2bc809f: 				REPORT("_______________________________________________________");
1:aaea357: 				
1:aaea357: 				String message = "\n\t\tRunning bad log test ";
1:aaea357: 				if (checksumTest)
1:aaea357: 					message = "\n\t\tRunning bad checksum log test ";
1:2bc809f: 				if (test1)
1:aaea357: 					REPORT(message + " 1");
1:2bc809f: 				if (test2)
1:aaea357: 					REPORT(message + " 2");
1:2bc809f: 				if (test3)
1:aaea357: 					REPORT(message + " 3");
1:2bc809f: 				if (test4)
1:aaea357: 					REPORT(message + " 4");
1:2bc809f: 				if (test5)
1:aaea357: 					REPORT(message + " 5");
1:2bc809f: 				if (test6)
1:aaea357: 					REPORT(message + " 6");
1:2bc809f: 				if (test7)
1:aaea357: 					REPORT(message + " 7");
1:2bc809f: 
1:2bc809f: 				REPORT("_______________________________________________________");
1:2bc809f: 
1:2bc809f: 				//if external input output files does not exist ,create one
1:2bc809f: 				File ifdir = new File("extinout");
1:2bc809f: 				if(!ifdir.exists())
1:2bc809f: 					ifdir.mkdirs();
1:2bc809f: 
1:2bc809f: 				try
1:2bc809f: 				{
1:2bc809f: 					// make sure it does exist
1:2bc809f: 					infofile = new RandomAccessFile(ifile, "rw");
1:2bc809f: 				}
1:2bc809f: 				catch (IOException ioe)
1:2bc809f: 				{
1:2bc809f: 					System.out.println("Cannot write to temporary file " +
1:2bc809f: 									   infoPath + 
1:2bc809f: 									   ".  Please make sure it is correct, if not, please set the property " +
1:2bc809f: 									   "TestBadLogInfo=<where temp files should go>");
1:2bc809f: 					
1:2bc809f: 					throw T_Fail.exceptionFail(ioe);
1:2bc809f: 				}
1:2bc809f: 
1:56c1dc2: 				if (!startPersistentService(testService, startParams))
1:2bc809f: 					throw T_Fail.testFailMsg("Monitor didn't know how to restart service: " + testService);
1:2bc809f: 
1:2bc809f: 				factory = (RawStoreFactory) Monitor.findService(getModuleToTestProtocolName(), testService);
1:56c1dc2: 				logFactory =(LogToFile) findServiceModule(factory, factory.getLogFactoryModule());
1:2bc809f: 				
1:2bc809f: 			}
1:2bc809f: 		} catch (StandardException mse) {
1:2bc809f: 			throw T_Fail.exceptionFail(mse);
1:2bc809f: 		}
1:2bc809f: 
1:2bc809f: 		if (factory == null) {
1:2bc809f: 			throw T_Fail.testFailMsg(getModuleToTestProtocolName() + " service not started.");
1:2bc809f: 		}
1:2bc809f: 			
1:2bc809f: 		lf = factory.getLockFactory();
1:2bc809f: 		if (lf == null) {
1:2bc809f: 			throw T_Fail.testFailMsg("LockFactory.MODULE not found");
1:2bc809f: 		}
1:2bc809f: 
1:2bc809f: 		// get a utility helper
1:2bc809f: 		t_util = new T_Util(factory, lf, contextService);
1:2bc809f: 
1:2bc809f: 		try {
1:2bc809f: 			
1:aaea357: 
1:2bc809f: 			// these tests can be run in any order
1:2bc809f: 			RTest1();
1:2bc809f: 			RTest2();
1:2bc809f: 			RTest3();
1:2bc809f: 			RTest4();
1:2bc809f: 			RTest5();
1:2bc809f: 			RTest6();
1:2bc809f: 			RTest7();
1:2bc809f: 
1:2bc809f: 			if (test1)
1:2bc809f: 				STest1();
1:2bc809f: 
1:2bc809f: 			if (test2)
1:2bc809f: 				STest2();
1:2bc809f: 				
1:2bc809f: 			if (test3)
1:2bc809f: 				STest3();
1:2bc809f: 						
1:2bc809f: 			if (test4)
1:2bc809f: 				STest4();
1:2bc809f: 
1:2bc809f: 			if(test5) 
1:2bc809f: 				STest5();
1:2bc809f: 
1:2bc809f: 			if(test6) 
1:2bc809f: 				STest6();
1:2bc809f: 
1:2bc809f: 			if(test7) 
1:2bc809f: 				STest7();
1:2bc809f: 
1:2bc809f: 			if (infofile != null)
1:2bc809f: 				infofile.close();
1:2bc809f: 
1:2bc809f: 		} catch (StandardException se) {
1:2bc809f: 
1:2bc809f: 			throw T_Fail.exceptionFail(se);
1:2bc809f: 		}
1:2bc809f: 		catch (IOException ioe)
1:2bc809f: 		{
1:2bc809f: 			throw T_Fail.exceptionFail(ioe);
1:2bc809f: 		}
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	private long find(long inkey)
1:2bc809f: 	{
1:2bc809f: 		if (infofile == null)
1:2bc809f: 			return -1;
1:2bc809f: 
1:2bc809f: 		try 
1:2bc809f: 		{
1:2bc809f: 			infofile.seek(0);
1:2bc809f: 			long key;
1:2bc809f: 
1:2bc809f: 			while(true)
1:2bc809f: 			{
1:2bc809f: 				key = infofile.readLong();
1:2bc809f: 				if (key == inkey)
1:2bc809f: 				{
1:2bc809f: 					long value = infofile.readLong();
1:2bc809f: 					// System.out.println("found " + key + " " + value);
1:2bc809f: 					return value;
1:2bc809f: 				}
1:2bc809f: 				infofile.readLong();
1:2bc809f: 			}
1:2bc809f: 		} 
1:2bc809f: 		catch (IOException ioe)
1:2bc809f: 		{
1:2bc809f: 			// System.out.println("key not found " + inkey);
1:2bc809f: 			return -1;
1:2bc809f: 		}
1:2bc809f: 
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	private long key(int test, int param)
1:2bc809f: 	{
1:2bc809f: 		long i = test;
1:2bc809f: 		return ((i << 32) + param);
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	private void register(long key, long value)
1:2bc809f: 		 throws T_Fail
1:2bc809f: 	{
1:2bc809f: 		// System.out.println("registering " + key + " " + value);
1:2bc809f: 		try 
1:2bc809f: 		{
1:2bc809f: 			// go to the end
1:2bc809f: 			infofile.seek(infofile.length());
1:2bc809f: 			infofile.writeLong(key);
1:2bc809f: 			infofile.writeLong(value);
1:2bc809f: 		}
1:2bc809f: 		catch (IOException ioe)
1:2bc809f: 		{
1:2bc809f: 			T_Fail.exceptionFail(ioe);
1:2bc809f: 		}
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 
1:2bc809f: 	/*
1:2bc809f: 	 * test1 manufactures a log with the following recoverable 'defects':
1:2bc809f: 	 *		- a log file that only have a single large 1/2 written log record
1:2bc809f: 	 */
1:2bc809f: 	protected void STest1() throws T_Fail, StandardException
1:2bc809f: 	{
1:2bc809f: 		Transaction t = t_util.t_startTransaction();
1:2bc809f: 
1:2bc809f: 		///////////////////////////////////////////
1:2bc809f: 		//// log switch without checkpoint here ///
1:2bc809f: 		///////////////////////////////////////////
1:2bc809f: 		factory.checkpoint();
1:2bc809f: 
1:2bc809f: 		try
1:2bc809f: 		{
1:2bc809f: 			long cid = t_util.t_addContainer(t, 0);
1:2bc809f: 			ContainerHandle c = t_util.t_openContainer(t, 0, cid, true);
1:2bc809f: 
1:2bc809f: 			Page page = t_util.t_getPage(c, ContainerHandle.FIRST_PAGE_NUMBER);
1:2bc809f: 
1:2bc809f: 			// make a really big record - fill 80% of the page
1:2bc809f: 			int numcol = (int)((RawStoreFactory.PAGE_SIZE_MINIMUM*8)/(10*20));
1:2bc809f: 
1:2bc809f: 			T_RawStoreRow bigrow = new T_RawStoreRow(numcol);
1:2bc809f: 			String string1 = "01234567890123456789"; // 20 char string
1:2bc809f: 			for (int i = 0; i < numcol; i++)
1:2bc809f: 				bigrow.setColumn(i, string1);
1:2bc809f: 
1:2bc809f: 			// if overhead is > 80%, then reduce the row size until it fits
1:2bc809f: 			RecordHandle rh = null;
1:2bc809f: 			while(numcol > 0)
1:2bc809f: 			{
1:2bc809f: 				try {
1:2bc809f: 					rh = t_util.t_insert(page, bigrow);
1:2bc809f: 					break;
1:2bc809f: 				} catch (StandardException se) {
1:2bc809f: 					bigrow.setColumn(--numcol, (String) null);
1:2bc809f: 				}
1:2bc809f: 			}
1:2bc809f: 			if (numcol == 0)
1:2bc809f: 				throw T_Fail.testFailMsg("cannot fit any column into the page");
1:2bc809f: 
1:2bc809f: 			
1:2bc809f: 
1:2bc809f: 			t_util.t_commit(t);
1:2bc809f: 
1:2bc809f: 			// make a big log record - update row
1:2bc809f: 			String string2 = "abcdefghijklmnopqrst"; // 20 char string
1:2bc809f: 			for (int i = 0; i < numcol; i++)
1:2bc809f: 				bigrow.setColumn(i, string2);
1:2bc809f: 
1:2bc809f: 			c = t_util.t_openContainer(t, 0, cid, true);
1:2bc809f: 			page = t_util.t_getPage(c, ContainerHandle.FIRST_PAGE_NUMBER);
1:2bc809f: 
1:2bc809f: 			Page p2 = t_util.t_addPage(c);		// do something so we get the beginXact log
1:2bc809f: 								// record out of the way
1:2bc809f: 			t_util.t_insert(p2, new T_RawStoreRow(REC_001));
1:2bc809f: 
1:2bc809f: 
1:2bc809f: 			///////////////////////////////////////////
1:2bc809f: 			//// log switch without checkpoint here ///
1:2bc809f: 			///////////////////////////////////////////
1:2bc809f: 			factory.checkpoint();
1:2bc809f: 
1:2bc809f: 			//////////////////////////////////////////////////////////
1:2bc809f: 			// writing approx 1/2 log record to the end of the log - 
1:2bc809f: 			// NO MORE LOG RECORD SHOULD BE WRITTEN,
1:2bc809f: 			//////////////////////////////////////////////////////////
1:aaea357: 			if(!checksumTest)
1:2bc809f: 			{
1:2bc809f: 				SanityManager.DEBUG_SET(LogToFile.TEST_LOG_INCOMPLETE_LOG_WRITE);
1:1093b6d: 				System.setProperty(LogToFile.TEST_LOG_PARTIAL_LOG_WRITE_NUM_BYTES, Integer.toString(numcol*20));
123:aaea357: 			}
1:2bc809f: 			
1:aaea357: 			logFactory.flushAll();
1:2bc809f: 
1:00d19b5: 			int slot = page.getSlotNumber(rh);
1:00d19b5: 			page.updateAtSlot(slot, bigrow.getRow(), null);
1:2bc809f: 
1:aaea357: 			if(checksumTest)
1:aaea357: 				simulateLogFileCorruption();
1:aaea357: 
1:2bc809f: 			////////////////////////////////////////////////////////
1:2bc809f: 
1:2bc809f: 			REPORT("badlog test1: cid = " + cid + " numcol " + numcol);
1:2bc809f: 
1:2bc809f: 			register(key(1,1), cid);
1:2bc809f: 			register(key(1,2), numcol);
1:2bc809f: 		}
1:2bc809f: 		finally
1:2bc809f: 		{
1:2bc809f: 			SanityManager.DEBUG_CLEAR(LogToFile.TEST_LOG_INCOMPLETE_LOG_WRITE);
1:2bc809f: 		}
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	/*
1:2bc809f: 	 * test recovery of test 1
1:2bc809f: 	 */
1:2bc809f: 	void RTest1() throws T_Fail, StandardException
1:2bc809f: 	{
1:2bc809f: 		long cid = find(key(1, 1));
1:2bc809f: 		if (cid < 0)
1:2bc809f: 		{
1:2bc809f: 			REPORT("bad log test1 not run");
1:2bc809f: 			return;
1:2bc809f: 		}
1:2bc809f: 		int numcol = (int)find(key(1,2));
1:2bc809f: 
1:2bc809f: 		Transaction t = t_util.t_startTransaction();
1:2bc809f: 		try
1:2bc809f: 		{
1:2bc809f: 			ContainerHandle c = t_util.t_openContainer(t, 0, cid, true);
1:2bc809f: 			Page page = t_util.t_getPage(c, ContainerHandle.FIRST_PAGE_NUMBER);
1:2bc809f: 
1:2bc809f: 			int optimisticNumcol = (int)((RawStoreFactory.PAGE_SIZE_MINIMUM*8)/(10*20));
1:2bc809f: 			T_RawStoreRow bigrow = new T_RawStoreRow(optimisticNumcol);
1:2bc809f: 			for (int i = 0; i < optimisticNumcol; i++)
1:2bc809f: 				bigrow.setColumn(i, (String) null);
1:2bc809f: 
1:2bc809f: 			page.fetchFromSlot(
1:2bc809f:                 (RecordHandle) null, 0, bigrow.getRow(), 
1:2bc809f:                 (FetchDescriptor) null,
1:2bc809f:                 false);
1:2bc809f: 
1:2bc809f: 			Storable column;
1:2bc809f: 			String string1 = "01234567890123456789"; // the original 20 char string
1:2bc809f: 
1:2bc809f: 			for (int i = 0; i < numcol; i++)
1:2bc809f: 			{
1:2bc809f: 				column = bigrow.getStorableColumn(i);
1:2bc809f: 				if (!(column.toString().equals(string1)))
1:2bc809f: 					throw T_Fail.testFailMsg("Column " + i + " value incorrect, got :" + column.toString());
1:2bc809f: 			}
1:2bc809f: 			for (int i = numcol; i < optimisticNumcol; i++)
1:2bc809f: 			{
1:2bc809f: 				column = bigrow.getStorableColumn(i);
1:2bc809f: 				if (!column.isNull())
1:2bc809f: 					throw T_Fail.testFailMsg("Column " + i + 
1:2bc809f: 											 " expect Null, got : " + column.toString());
1:2bc809f: 			}
1:2bc809f: 
1:2bc809f: 			REPORT("RTest1 passed");
1:2bc809f: 
1:2bc809f: 		}
1:2bc809f: 		finally
1:2bc809f: 		{
1:2bc809f: 			t_util.t_commit(t);
1:2bc809f: 			t.close();
1:2bc809f: 		}
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	/*
1:2bc809f: 	 * test2 manufactures a log with the following recoverable 'defects':
1:2bc809f: 	 *		- a log file that ends with a large 1/2 written log record
1:2bc809f: 	 */
1:2bc809f: 	protected void STest2() throws T_Fail, StandardException
1:2bc809f: 	{
1:2bc809f: 		Transaction t = t_util.t_startTransaction();
1:2bc809f: 
1:2bc809f: 		try
1:2bc809f: 		{
1:2bc809f: 			long cid = t_util.t_addContainer(t, 0);
1:2bc809f: 			ContainerHandle c = t_util.t_openContainer(t, 0, cid, true);
1:2bc809f: 
1:2bc809f: 			Page page = t_util.t_getPage(c, ContainerHandle.FIRST_PAGE_NUMBER);
1:2bc809f: 
1:2bc809f: 			// make a really big record - fill 80% of the page with 20 bytes row
1:2bc809f: 			int numcol = (int)((RawStoreFactory.PAGE_SIZE_MINIMUM*8)/(10*20));
1:2bc809f: 
1:2bc809f: 			T_RawStoreRow bigrow = new T_RawStoreRow(numcol);
1:2bc809f: 			String string1 = "01234567890123456789"; // 20 char string
1:2bc809f: 			for (int i = 0; i < numcol; i++)
1:2bc809f: 				bigrow.setColumn(i, string1);
1:2bc809f: 
1:2bc809f: 			// if overhead is > 80%, then reduce the row size until it fits
1:2bc809f: 			RecordHandle rh = null;
1:2bc809f: 			while(numcol > 0)
1:2bc809f: 			{
1:2bc809f: 				try {
1:2bc809f: 					rh = t_util.t_insert(page, bigrow);
1:2bc809f: 					break;
1:2bc809f: 				} catch (StandardException se) {
1:2bc809f: 					bigrow.setColumn(--numcol, (String) null);
1:2bc809f: 				}
1:2bc809f: 			}
1:2bc809f: 			if (numcol == 0)
1:2bc809f: 				throw T_Fail.testFailMsg("cannot fit any column into the page");
1:2bc809f: 
1:2bc809f: 			rh = t_util.t_insert(page, bigrow);
1:2bc809f: 
1:2bc809f: 			t_util.t_commit(t);
1:2bc809f: 
1:2bc809f: 			// make a big log record - update row
1:2bc809f: 			String string2 = "abcdefghijklmnopqrst"; // 20 char string
1:2bc809f: 			for (int i = 0; i < numcol; i++)
1:2bc809f: 				bigrow.setColumn(i, string2);
1:2bc809f: 
1:2bc809f: 			c = t_util.t_openContainer(t, 0, cid, true);
1:2bc809f: 			page = t_util.t_getPage(c, ContainerHandle.FIRST_PAGE_NUMBER);
1:2bc809f: 
1:2bc809f: 			//////////////////////////////////////////////////////////
1:2bc809f: 			// writing approx 1/2 log record to the end of the log - 
1:2bc809f: 			// NO MORE LOG RECORD SHOULD BE WRITTEN,
1:2bc809f: 			//////////////////////////////////////////////////////////
1:aaea357: 			if(!checksumTest)
110:aaea357: 			{
1:2bc809f: 				SanityManager.DEBUG_SET(LogToFile.TEST_LOG_INCOMPLETE_LOG_WRITE);
1:1093b6d: 				System.setProperty(LogToFile.TEST_LOG_PARTIAL_LOG_WRITE_NUM_BYTES,Integer.toString(numcol*20));
1:aaea357: 			}
1:2bc809f: 
1:aaea357: 			logFactory.flushAll();
1:00d19b5: 			int slot = page.getSlotNumber(rh);
1:00d19b5: 			page.updateAtSlot(slot, bigrow.getRow(), null);
1:2bc809f: 			
1:aaea357: 			if(checksumTest)
1:aaea357: 				simulateLogFileCorruption();
1:2bc809f: 
1:2bc809f: 			////////////////////////////////////////////////////////
1:aaea357: 
1:2bc809f: 			REPORT("badlog test2: cid = " + cid + " numcol " + numcol);
1:2bc809f: 
1:2bc809f: 			register(key(2,1), cid);
1:2bc809f: 			register(key(2,2), numcol);
1:2bc809f: 		}
1:2bc809f: 		finally
1:2bc809f: 		{
1:2bc809f: 			SanityManager.DEBUG_CLEAR(LogToFile.TEST_LOG_INCOMPLETE_LOG_WRITE);
1:2bc809f: 		}
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	/*
1:2bc809f: 	 * test recovery of test 2
1:2bc809f: 	 */
1:2bc809f: 	void RTest2() throws T_Fail, StandardException
1:2bc809f: 	{
1:2bc809f: 		long cid = find(key(2, 1));
1:2bc809f: 		if (cid < 0)
1:2bc809f: 		{
1:2bc809f: 			REPORT("bad log test2 not run");
1:2bc809f: 			return;
1:2bc809f: 		}
1:2bc809f: 		int numcol = (int)find(key(2,2));
1:2bc809f: 
1:2bc809f: 		Transaction t = t_util.t_startTransaction();
1:2bc809f: 		try
1:2bc809f: 		{
1:2bc809f: 			ContainerHandle c = t_util.t_openContainer(t, 0, cid, true);
1:2bc809f: 			Page page = t_util.t_getPage(c, ContainerHandle.FIRST_PAGE_NUMBER);
1:2bc809f: 
1:2bc809f: 			int optimisticNumcol = (int)((RawStoreFactory.PAGE_SIZE_MINIMUM*8)/(10*20));
1:2bc809f: 			T_RawStoreRow bigrow = new T_RawStoreRow(optimisticNumcol);
1:2bc809f: 			for (int i = 0; i < optimisticNumcol; i++)
1:2bc809f: 				bigrow.setColumn(i, (String) null);
1:2bc809f: 
1:2bc809f: 			page.fetchFromSlot(
1:2bc809f:                 (RecordHandle) null, 0, bigrow.getRow(), 
1:2bc809f:                 (FetchDescriptor) null,
1:2bc809f:                 false);
1:2bc809f: 			Storable column;
1:2bc809f: 			String string1 = "01234567890123456789"; // the original 20 char string
1:2bc809f: 
1:2bc809f: 			for (int i = 0; i < numcol; i++)
1:2bc809f: 			{
1:2bc809f: 				column = bigrow.getStorableColumn(i);
1:2bc809f: 				if (!(column.toString().equals(string1)))
1:2bc809f: 					throw T_Fail.testFailMsg("Column " + i + " value incorrect, got :" + column.toString());
1:2bc809f: 			}
1:2bc809f: 			for (int i = numcol; i < optimisticNumcol; i++)
1:2bc809f: 			{
1:2bc809f: 				column = bigrow.getStorableColumn(i);
1:2bc809f: 				if (!column.isNull())
1:2bc809f: 					throw T_Fail.testFailMsg("Column " + i + 
1:2bc809f: 											 " expect Null, got : " + column.toString());
1:2bc809f: 			}
1:2bc809f: 
1:2bc809f: 			REPORT("RTest2 passed");
1:2bc809f: 
1:2bc809f: 		}
1:2bc809f: 		finally
1:2bc809f: 		{
1:2bc809f: 			t_util.t_commit(t);
1:2bc809f: 			t.close();
1:2bc809f: 		}
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 
1:2bc809f: 
1:2bc809f: 	/*
1:2bc809f: 	 * test3 manufactures a log with the following recoverable 'defects':
1:2bc809f: 	 *    - a log with multiple files but no checkpoint log record
1:2bc809f: 	 *	  - a last log file with a paritally written log record at the end
1:2bc809f: 	 */
1:2bc809f: 	protected void STest3() throws T_Fail, StandardException
1:2bc809f: 	{
1:2bc809f: 		int numtrans = 7;
1:2bc809f: 		int numpages = 7;
1:2bc809f: 		int i,j;
1:2bc809f: 
1:2bc809f: 		// this is basically T_Recovery S203 with a couple of log switches
1:2bc809f: 		try
1:2bc809f: 		{
1:2bc809f: 			T_TWC[] t = new T_TWC[numtrans];
1:2bc809f: 			for (i = 0; i < numtrans; i++)
1:2bc809f: 				t[i] =  t_util.t_startTransactionWithContext();
1:2bc809f: 
1:2bc809f: 			long[] cid = new long[numtrans];
1:2bc809f: 			ContainerHandle[] c = new ContainerHandle[numtrans];
1:2bc809f: 
1:2bc809f: 			for (i = 0; i < numtrans; i++)
1:2bc809f: 			{
1:2bc809f: 				cid[i] = t_util.t_addContainer(t[i], 0);
1:2bc809f: 				t_util.t_commit(t[i]);
1:2bc809f: 				c[i] = t_util.t_openContainer(t[i], 0, cid[i], true);
1:2bc809f: 			}
1:2bc809f: 
1:2bc809f: 			Page page[][] = new Page[numtrans][numpages];
1:2bc809f: 			long pagenum[][] = new long[numtrans][numpages];
1:2bc809f: 
1:2bc809f: 			for (i = 0; i < numtrans; i++)
1:2bc809f: 			{
5:2bc809f: 				for (j = 0; j < numpages; j++)
1:2bc809f: 				{
1:2bc809f: 					t[i].switchTransactionContext();
1:2bc809f: 					page[i][j] = t_util.t_addPage(c[i]);
1:2bc809f: 					pagenum[i][j] = page[i][j].getPageNumber();
1:2bc809f: 					t[i].resetContext();
1:2bc809f: 				}
1:2bc809f: 			}
1:2bc809f: 
1:2bc809f: 			// set up numtrans (at least 5) transactions, each with one
1:2bc809f: 			// container and numpages pages.  Do the following test:
1:2bc809f: 			//
1:2bc809f: 			// 1) insert 1 row onto each page
1:2bc809f: 			// set savepoint SP1 on first transaction (t0)
1:2bc809f: 			//
1:2bc809f: 			// 2) update every rows
1:2bc809f: 			// set savepoint SP1 on all other transactions
1:2bc809f: 			//
1:2bc809f: 			// 3) update every rows
1:2bc809f: 			// set savepoint SP2 on all transactions
1:2bc809f: 			// 
1:2bc809f: 			// 4) update every rows
1:2bc809f: 			//
1:2bc809f: 			// 5) rollback t0 to SP1
1:2bc809f: 			//
1:2bc809f: 			// check that only page[0][x] have been rolled back
1:2bc809f: 			// past SP2
1:2bc809f: 			//
1:2bc809f: 			// 6) update every row
1:2bc809f: 			// 7) rollback SP2 on all transaction except the first
1:2bc809f: 			// 
1:2bc809f: 			// 8) update every rows
1:2bc809f: 			// 9) rollback t0 to SP1
1:2bc809f: 			//
1:2bc809f: 			// 10) leave transactions in the following state
1:2bc809f: 			// t0 - incomplete
1:2bc809f: 			// t1 - abort
1:2bc809f: 			// t2 - commit
1:2bc809f: 			// t3 - incomplete
1:2bc809f: 			// t4 - commit
1:2bc809f: 			// any other transactions - incomplete
1:2bc809f: 
1:2bc809f: 
1:2bc809f: 			//////////////////////// step 1 ////////////////////////
1:2bc809f: 			RecordHandle[][] rh = new RecordHandle[numtrans][numpages];
1:2bc809f: 			T_RawStoreRow row1 = new T_RawStoreRow(REC_001);
1:2bc809f: 			for (i = 0; i < numtrans; i++)
1:2bc809f: 				for (j = 0; j < numpages; j++)
1:2bc809f: 				{
1:2bc809f: 					t[i].switchTransactionContext();
1:2bc809f: 					rh[i][j] = t_util.t_insert(page[i][j], row1); 
1:2bc809f: 					t[i].resetContext();
1:2bc809f: 				}
1:2bc809f: 
1:2bc809f: 			t[0].setSavePoint(SP1, null);	// sp1
1:2bc809f: 
1:2bc809f: 			//////////////////////// step 2 ////////////////////////
1:2bc809f: 			T_RawStoreRow row2 = new T_RawStoreRow(REC_002);
1:2bc809f: 			for (i = 0; i < numtrans; i++)
1:2bc809f: 				for (j = 0; j < numpages; j++)
1:2bc809f: 				{
1:2bc809f: 					t[i].switchTransactionContext();
1:00d19b5: 					int slot = page[i][j].getSlotNumber(rh[i][j]);
1:00d19b5: 					page[i][j].updateAtSlot(slot, row2.getRow(), null);
1:2bc809f: 					t[i].resetContext();
1:2bc809f: 				}
1:2bc809f: 
1:2bc809f: 			for (i = 1; i < numtrans; i++) // sp1
1:2bc809f: 			{
1:2bc809f: 				t[i].setSavePoint(SP1, null);
1:2bc809f: 			}
1:2bc809f: 
1:2bc809f: 			///////////////////////////////////////////
1:2bc809f: 			//// log switch without checkpoint here ///
1:2bc809f: 			///////////////////////////////////////////
1:2bc809f: 			factory.checkpoint();
1:2bc809f: 
1:2bc809f: 
1:2bc809f: 			//////////////////////// step 3 ////////////////////////
1:2bc809f: 			T_RawStoreRow row3 = new T_RawStoreRow(REC_003);
1:2bc809f: 			for (i = 0; i < numtrans; i++)
1:00d19b5: 				for (j = 0; j < numpages; j++) {
1:00d19b5: 					int slot = page[i][j].getSlotNumber(rh[i][j]);
1:00d19b5: 					page[i][j].updateAtSlot(slot, row3.getRow(), null);
1:00d19b5: 				}
1:2bc809f: 
1:2bc809f: 			for (i = 0; i < numtrans; i++)
1:2bc809f: 				t[i].setSavePoint(SP2, null);	// sp2
1:2bc809f: 
1:2bc809f: 			//////////////////////// step 4 ////////////////////////
1:2bc809f: 			T_RawStoreRow row4 = new T_RawStoreRow(REC_004);
1:2bc809f: 			for (i = 0; i < numtrans; i++)
1:2bc809f: 			{
1:2bc809f: 				t[i].switchTransactionContext();
1:2bc809f: 
1:00d19b5: 				for (j = 0; j < numpages; j++) {
1:00d19b5: 					int slot = page[i][j].getSlotNumber(rh[i][j]);
1:00d19b5: 					page[i][j].updateAtSlot(slot, row4.getRow(), null);
1:00d19b5: 				}
1:2bc809f: 				t[i].resetContext();
1:2bc809f: 			}
1:2bc809f: 
1:2bc809f: 
1:2bc809f: 			//////////////////////// step 5 ////////////////////////
1:2bc809f: 			// unlatch relavante pages
1:2bc809f: 			t[0].switchTransactionContext();
1:2bc809f: 
1:2bc809f: 			for (j = 0; j < numpages; j++)
1:2bc809f: 				page[0][j].unlatch();
1:2bc809f: 
1:2bc809f: 			t[0].rollbackToSavePoint(SP1, null); // step 5
1:2bc809f: 
1:2bc809f: 			// relatch relavante pages
1:2bc809f: 			for (j = 0; j < numpages; j++)
1:2bc809f: 				page[0][j] = t_util.t_getPage(c[0], pagenum[0][j]);
1:2bc809f: 
1:2bc809f: 			t[0].resetContext();
1:2bc809f: 
1:2bc809f: 			///////////////////////////////////////////
1:2bc809f: 			//// log switch without checkpoint here ///
1:2bc809f: 			///////////////////////////////////////////
1:2bc809f: 			factory.checkpoint();
1:2bc809f: 
1:2bc809f: 
1:2bc809f: 			//////////////////////// check ////////////////////////
1:2bc809f: 			for (i = 1; i < numtrans; i++)
1:2bc809f: 			{
1:2bc809f: 				t[i].switchTransactionContext();
1:2bc809f: 				for (j = 0; j < numpages; j++)
1:2bc809f: 					t_util.t_checkFetch(page[i][j], rh[i][j], REC_004);
1:2bc809f: 				t[i].resetContext();
1:2bc809f: 			}
1:2bc809f: 
1:2bc809f: 			t[0].switchTransactionContext();
1:2bc809f: 			for (j = 0; j < numpages; j++)
1:2bc809f: 				t_util.t_checkFetch(page[0][j], rh[0][j], REC_001);
1:2bc809f: 			t[0].resetContext();
1:2bc809f: 
1:2bc809f: 			//////////////////////// step 6 ////////////////////////
1:2bc809f: 			T_RawStoreRow row5 = new T_RawStoreRow(REC_005);
1:2bc809f: 			for (i = 0; i < numtrans; i++)
1:2bc809f: 			{
1:2bc809f: 				t[i].switchTransactionContext();
1:00d19b5: 				for (j = 0; j < numpages; j++) {
1:00d19b5: 					int slot = page[i][j].getSlotNumber(rh[i][j]);
1:00d19b5: 					page[i][j].updateAtSlot(slot, row5.getRow(), null);
1:00d19b5: 				}
1:2bc809f: 				t[i].resetContext();
1:2bc809f: 			}
1:2bc809f: 
1:2bc809f: 			//////////////////////// step 7 ////////////////////////
1:2bc809f: 			for (i = 1; i < numtrans; i++)
1:2bc809f: 			{
1:2bc809f: 				t[i].switchTransactionContext();
1:2bc809f: 
1:2bc809f: 				for (j = 0; j < numpages; j++)
1:2bc809f: 					page[i][j].unlatch();
1:2bc809f: 
1:2bc809f: 				t[i].rollbackToSavePoint(SP2, null);
1:2bc809f: 
1:2bc809f: 				for (j = 0; j < numpages; j++)
1:2bc809f: 					page[i][j] = t_util.t_getPage(c[i],pagenum[i][j]);
1:2bc809f: 				t[i].resetContext();
1:2bc809f: 			}
1:2bc809f: 
1:2bc809f: 			//////////////////////// check ////////////////////////
1:2bc809f: 			for (i = 1; i < numtrans; i++)
1:2bc809f: 			{
1:2bc809f: 				t[i].switchTransactionContext();
1:2bc809f: 				for (j = 0; j < numpages; j++)
1:2bc809f: 					t_util.t_checkFetch(page[i][j], rh[i][j], REC_003);
1:2bc809f: 				t[i].resetContext();
1:2bc809f: 			}
1:2bc809f: 
1:2bc809f: 			t[0].switchTransactionContext();
1:2bc809f: 			for (j = 0; j < numpages; j++)
1:2bc809f: 				t_util.t_checkFetch(page[0][j], rh[0][j], REC_005);
1:2bc809f: 
1:2bc809f: 			t[0].resetContext();
1:2bc809f: 
1:2bc809f: 			///////////////////////////////////////////
1:2bc809f: 			//// log switch without checkpoint here ///
1:2bc809f: 			///////////////////////////////////////////
1:2bc809f: 			factory.checkpoint();
1:2bc809f: 
1:2bc809f: 
1:2bc809f: 			//////////////////////// step 8 ////////////////////////
1:2bc809f: 			T_RawStoreRow row6 = new T_RawStoreRow(REC_006);
1:2bc809f: 			for (i = 0; i < numtrans; i++)
1:2bc809f: 			{
1:2bc809f: 				t[i].switchTransactionContext();
1:00d19b5: 				for (j = 0; j < numpages; j++) {
1:00d19b5: 					int slot = page[i][j].getSlotNumber(rh[i][j]);
1:00d19b5: 					page[i][j].updateAtSlot(slot, row6.getRow(), null);
1:00d19b5: 				}
1:2bc809f: 				t[i].resetContext();
1:2bc809f: 			}
1:2bc809f: 
1:2bc809f: 			//////////////////////// step 9 ////////////////////////
1:2bc809f: 			// unlatch relavante pages
1:2bc809f: 			t[0].switchTransactionContext();
1:2bc809f: 			for (j = 0; j < numpages; j++)
1:2bc809f: 				page[0][j].unlatch();
1:2bc809f: 
1:2bc809f: 			t[0].rollbackToSavePoint(SP1, null); 
1:2bc809f: 
1:2bc809f: 			// relatch relevant pages
1:2bc809f: 			for (j = 0; j < numpages; j++)
1:2bc809f: 				page[0][j] = t_util.t_getPage(c[0], pagenum[0][j]);
1:2bc809f: 
1:2bc809f: 			t[0].resetContext();
1:2bc809f: 			//////////////////////// check ////////////////////////
1:2bc809f: 			for (i = 1; i < numtrans; i++)
1:2bc809f: 			{
1:2bc809f: 				t[i].switchTransactionContext();
1:2bc809f: 
1:2bc809f: 				for (j = 0; j < numpages; j++)
1:2bc809f: 				{
1:2bc809f: 					t_util.t_checkFetch(page[i][j], rh[i][j], REC_006);
1:2bc809f: 					t_util.t_checkRecordCount(page[i][j], 1, 1);
1:2bc809f: 				}
1:2bc809f: 				t[i].resetContext();
1:2bc809f: 			}
1:2bc809f: 
1:2bc809f: 			t[0].switchTransactionContext();
1:2bc809f: 			for (j = 0; j < numpages; j++)
1:2bc809f: 			{
1:2bc809f: 				t_util.t_checkFetch(page[0][j], rh[0][j], REC_001);
1:2bc809f: 				t_util.t_checkRecordCount(page[0][j], 1, 1);
1:2bc809f: 			}
1:2bc809f: 			t[0].resetContext();
1:2bc809f: 
1:2bc809f: 			//////////////////////// step 10 ////////////////////////
1:2bc809f: 			// unlatch all pages
1:2bc809f: 			for (i = 0; i < numtrans; i++)
1:2bc809f: 			{
1:2bc809f: 				t[i].switchTransactionContext();
1:2bc809f: 				for (j = 0; j < numpages; j++)
1:2bc809f: 					page[i][j].unlatch();
1:2bc809f: 				t[i].resetContext();
1:2bc809f: 			}
1:2bc809f: 
1:2bc809f: 			// t[0] incomplete
1:2bc809f: 			t_util.t_abort(t[1]);
1:2bc809f: 			t_util.t_commit(t[2]);
1:2bc809f: 			// t[3] incomplete
1:2bc809f: 			t_util.t_commit(t[4]);
1:2bc809f: 
1:2bc809f: 			// reopen containers 1, 2, and 4, where were closed when the
1:2bc809f: 			// transaction terminated.
1:2bc809f: 			c[1] = t_util.t_openContainer(t[1], 0, cid[1], false);
1:2bc809f: 			c[2] = t_util.t_openContainer(t[2], 0, cid[2], false);
1:2bc809f: 			c[4] = t_util.t_openContainer(t[4], 0, cid[4], false);
1:2bc809f: 
1:2bc809f: 			//////////////////////// check ////////////////////////
1:2bc809f: 			for (j = 0; j < numpages; j++)	
1:2bc809f: 			{
1:2bc809f: 				t[0].switchTransactionContext();
1:2bc809f: 				t_util.t_checkFetch(c[0], rh[0][j], REC_001);
1:2bc809f: 				t[0].resetContext();
1:2bc809f: 
1:2bc809f: 				// t[1] has been aborted
1:2bc809f: 				// rh[1][j] (REC_001) is deleted
1:2bc809f: 				t[1].switchTransactionContext();
1:2bc809f: 				page[1][j] = t_util.t_getPage(c[1], pagenum[1][j]);
1:2bc809f: 				t_util.t_checkRecordCount(page[1][j], 1, 0);
1:2bc809f: 				t_util.t_checkFetchBySlot(page[1][j], Page.FIRST_SLOT_NUMBER,
1:2bc809f: 								   REC_001, true, false);
1:2bc809f: 				page[1][j].unlatch();
1:2bc809f: 				t[1].resetContext();
1:2bc809f: 
1:2bc809f: 				t[2].switchTransactionContext();
1:2bc809f: 				t_util.t_checkFetch(c[2], rh[2][j], REC_006);
1:2bc809f: 				t[2].resetContext();
1:2bc809f: 
1:2bc809f: 				t[3].switchTransactionContext();
1:2bc809f: 				t_util.t_checkFetch(c[3], rh[3][j], REC_006);
1:2bc809f: 				t[3].resetContext();
1:2bc809f: 
1:2bc809f: 				t[4].switchTransactionContext();
1:2bc809f: 				t_util.t_checkFetch(c[4], rh[4][j], REC_006);
1:2bc809f: 				t[4].resetContext();
1:2bc809f: 			}
1:2bc809f: 
1:2bc809f: 
1:2bc809f: 			///////////////////////////////////////////////////////////
1:2bc809f: 			//// now write a 1/2 log record to the end of the log
1:2bc809f: 			//////////////////////////////////////////////////////////
1:2bc809f: 			t[3].switchTransactionContext();// this is going to be an
1:2bc809f: 											// incomplete transaction
1:2bc809f: 
1:2bc809f: 			// make a full page and then copy and purge it to another page
1:2bc809f: 			Page badPage1 = t_util.t_addPage(c[3]);
1:2bc809f: 			Page badPage2 = t_util.t_addPage(c[3]);
1:2bc809f: 			T_RawStoreRow row;
1:2bc809f: 			for (i = 0, row = new T_RawStoreRow("row at slot " + i);
1:2bc809f: 				 badPage1.spaceForInsert();
1:2bc809f: 				 i++, row = new T_RawStoreRow("row at slot " + i))
1:2bc809f: 			{
1:2bc809f: 				if (t_util.t_insertAtSlot(badPage1, i, row, Page.INSERT_UNDO_WITH_PURGE) == null)
1:2bc809f: 					break;
1:2bc809f: 			}
1:2bc809f: 
1:2bc809f: 			//////////////////////////////////////////////////////////
1:2bc809f: 			// writing 200 bytes of the log record to the end of the log - 
1:2bc809f: 			// NO MORE LOG RECORD SHOULD BE WRITTEN,
1:2bc809f: 			//////////////////////////////////////////////////////////
1:aaea357: 			if(!checksumTest)
1:aaea357: 			{
1:2bc809f: 				SanityManager.DEBUG_SET(LogToFile.TEST_LOG_INCOMPLETE_LOG_WRITE);
1:1093b6d: 				System.setProperty(LogToFile.TEST_LOG_PARTIAL_LOG_WRITE_NUM_BYTES, "200");
1:aaea357: 			}
1:aaea357: 			logFactory.flushAll();
1:2bc809f: 
1:2bc809f: 
1:2bc809f: 			// RESOLVE:
1:2bc809f: 			// copy and purge actually generates 2 log records, this is
1:2bc809f: 			// actually not a good operation to use for this test.  Just make
1:2bc809f: 			// sure the first log record is > 400 or else the log will be hosed
1:2bc809f: 			//
1:2bc809f: 			badPage1.copyAndPurge(badPage2, 0, i, 0);
1:2bc809f: 
1:2bc809f: 			t[3].resetContext();
1:2bc809f: 
1:aaea357: 			if(checksumTest)
1:aaea357: 				simulateLogFileCorruption();
1:aaea357: 
1:2bc809f: 			////////////////////////////////////////////////////////
1:aaea357: 
1:2bc809f: 			REPORT("badlog test3: numtrans " + numtrans + " numpages " + numpages);
1:2bc809f: 
1:2bc809f: 			for (i = 0; i < numtrans; i++)
1:2bc809f: 			{
1:2bc809f: 				register(key(3, i+10), cid[i]);
1:2bc809f: 
1:2bc809f: 				String str = "container " + i + ":" + find(key(3,i+10)) + " pages: ";
1:2bc809f: 
1:2bc809f: 				for (j = 0; j < numpages; j++)
1:2bc809f: 				{
1:2bc809f: 					str += pagenum[i][j] + " ";
1:2bc809f: 					register(key(3, (i+1)*1000+j), pagenum[i][j]);
1:2bc809f: 				}
1:2bc809f: 				REPORT("\t" + str);
1:2bc809f: 			}
1:2bc809f: 
1:2bc809f: 			register(key(3,1), numtrans); 
1:2bc809f: 			register(key(3,2), numpages);
1:2bc809f: 			register(key(3,3), badPage1.getPageNumber());
1:2bc809f: 			register(key(3,4), badPage2.getPageNumber());
1:2bc809f: 
1:2bc809f: 		}
1:2bc809f: 		finally
1:2bc809f: 		{
1:2bc809f: 			SanityManager.DEBUG_CLEAR(LogToFile.TEST_LOG_INCOMPLETE_LOG_WRITE);
1:2bc809f: 		}
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	/*
1:2bc809f: 	 * test recovery of test3
1:2bc809f: 	 */
1:2bc809f: 	void RTest3() throws T_Fail, StandardException
1:2bc809f: 	{
1:2bc809f: 		int numtrans = (int)find(key(3,1));
1:2bc809f: 		if (numtrans < 0)
1:2bc809f: 		{
1:2bc809f: 			REPORT("bad log test3 not run");
1:2bc809f: 			return;
1:2bc809f: 		}
1:2bc809f: 
1:2bc809f: 		int numpages = (int)find(key(3,2));
1:2bc809f: 		long badPagenum1 = find(key(3,3)); // these two pages are involved in
1:2bc809f: 										   // the 1/2 written log record, make
1:2bc809f: 										   // sure they are not corrupted
1:2bc809f: 		long badPagenum2 = find(key(3,4));
1:2bc809f: 
1:2bc809f: 		Transaction t = t_util.t_startTransaction();
1:2bc809f: 
1:2bc809f: 		long[] cid = new long[numtrans];
1:2bc809f: 		ContainerHandle[] c = new ContainerHandle[numtrans];
1:2bc809f: 
1:2bc809f: 		long[][] pagenum = new long[numtrans][numpages];
1:2bc809f: 		Page[][] page = new Page[numtrans][numpages];
1:2bc809f: 
1:2bc809f: 		int i,j;
1:2bc809f: 
1:2bc809f: 		for (i = 0; i < numtrans; i++)
1:2bc809f: 		{
1:2bc809f: 			cid[i] = find(key(3, i+10));
1:2bc809f: 
1:2bc809f: 			c[i] = t_util.t_openContainer(t, 0, cid[i], true);
1:2bc809f: 			
1:2bc809f: 			for (j = 0; j < numpages; j++)
1:2bc809f: 			{
1:2bc809f: 				pagenum[i][j] = find(key(3, (i+1)*1000+j));
1:2bc809f: 
1:2bc809f: 				page[i][j] = t_util.t_getPage(c[i], pagenum[i][j]);
1:2bc809f: 			}
1:2bc809f: 		}
1:2bc809f: 
1:2bc809f: 		// transactions were left in the following state
1:2bc809f: 		// t0 - incomplete (rolled back)
1:2bc809f: 		// t1 - abort
1:2bc809f: 		// t2 - commit
1:2bc809f: 		// t3 - incomplete (rolled back)
1:2bc809f: 		// t4 - commit
1:2bc809f: 		// any other transactions - incomplete
1:2bc809f: 		//
1:2bc809f: 		// all the rolled back transaction should have a deleted REC_001
1:2bc809f: 		// all the committed transactions should have a REC_006
1:2bc809f:                                                                            //
1:2bc809f: 		try 
1:2bc809f: 		{
1:2bc809f: 			for (j = 0; j < numpages; j++)
1:2bc809f: 			{
1:2bc809f: 				t_util.t_checkRecordCount(page[0][j], 1, 0);
1:2bc809f: 				t_util.t_checkFetchBySlot(page[0][j], Page.FIRST_SLOT_NUMBER,
1:2bc809f: 								   REC_001, true, true);
1:2bc809f: 
1:2bc809f: 				t_util.t_checkRecordCount(page[1][j], 1, 0);
1:2bc809f: 				t_util.t_checkFetchBySlot(page[1][j], Page.FIRST_SLOT_NUMBER,
1:2bc809f: 								   REC_001, true, true);
1:2bc809f: 
1:2bc809f: 				t_util.t_checkRecordCount(page[2][j], 1, 1);
1:2bc809f: 				t_util.t_checkFetchBySlot(page[2][j], Page.FIRST_SLOT_NUMBER,
1:2bc809f: 								   REC_006, false, true);
1:2bc809f: 
1:2bc809f: 				t_util.t_checkRecordCount(page[3][j], 1, 0);
1:2bc809f: 				t_util.t_checkFetchBySlot(page[3][j], Page.FIRST_SLOT_NUMBER,
1:2bc809f: 								   REC_001, true, true);
1:2bc809f: 
1:2bc809f: 				t_util.t_checkRecordCount(page[4][j], 1, 1);
1:2bc809f: 				t_util.t_checkFetchBySlot(page[4][j], Page.FIRST_SLOT_NUMBER,
1:2bc809f: 								   REC_006, false, true);
1:2bc809f: 			}
1:2bc809f: 
1:2bc809f: 			// now check the two bad pages - they are in c[3] and should be empty
1:2bc809f: 			Page badPage1 = t_util.t_getPage(c[3], badPagenum1);
1:2bc809f: 			Page badPage2 = t_util.t_getPage(c[3], badPagenum2);
1:2bc809f: 			t_util.t_checkRecordCount(badPage1, 0, 0);
1:2bc809f: 			t_util.t_checkRecordCount(badPage2, 0, 0);
1:2bc809f: 
1:2bc809f: 			REPORT("RTest3 passed: numtrans " + numtrans + " numpages " + numpages);
1:2bc809f: 
1:2bc809f: 			for (i = 0; i < numtrans; i++)
1:2bc809f: 			{
1:2bc809f: 				String str = "container " + i + ":" + cid[i] + " pages: ";
1:2bc809f: 				for (j = 0; j < numpages; j++)
1:2bc809f: 					str += pagenum[i][j] + " ";
1:2bc809f: 				REPORT("\t" + str);
1:2bc809f: 			}
1:2bc809f: 		}
1:2bc809f: 		finally
1:2bc809f: 		{
1:2bc809f: 			t_util.t_commit(t);
1:2bc809f: 			t.close();
1:2bc809f: 		}
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 		
1:2bc809f: 	/*
1:2bc809f: 	 * test4 manufactures a log with the following recoverable 'defects':
1:2bc809f: 	 * - a log file that only has the partial log instance(7 bytes instead of 8
1:2bc809f: 	 * bytes writtne) of a log record written 
1:2bc809f: 	 */
1:2bc809f: 	protected void STest4() throws T_Fail, StandardException
1:2bc809f: 	{
1:2bc809f: 		Transaction t = t_util.t_startTransaction();
1:2bc809f: 
1:2bc809f: 		try
1:2bc809f: 		{
1:2bc809f: 			long cid = t_util.t_addContainer(t, 0);
1:2bc809f: 			ContainerHandle c = t_util.t_openContainer(t, 0, cid, true);
1:2bc809f: 
1:2bc809f: 			Page page = t_util.t_getPage(c, ContainerHandle.FIRST_PAGE_NUMBER);
1:2bc809f: 
1:2bc809f: 			// make a really big record - fill 80% of the page
1:2bc809f: 			int numcol = (int)((RawStoreFactory.PAGE_SIZE_MINIMUM*8)/(10*20));
1:2bc809f: 
1:2bc809f: 			T_RawStoreRow bigrow = new T_RawStoreRow(numcol);
1:2bc809f: 			String string1 = "01234567890123456789"; // 20 char string
1:2bc809f: 			for (int i = 0; i < numcol; i++)
1:2bc809f: 				bigrow.setColumn(i, string1);
1:2bc809f: 
1:2bc809f: 			// if overhead is > 80%, then reduce the row size until it fits
1:2bc809f: 			RecordHandle rh = null;
1:2bc809f: 			while(numcol > 0)
1:2bc809f: 			{
1:2bc809f: 				try {
1:2bc809f: 					rh = t_util.t_insert(page, bigrow);
1:2bc809f: 					break;
1:2bc809f: 				} catch (StandardException se) {
1:2bc809f: 					bigrow.setColumn(--numcol, (String) null);
1:2bc809f: 				}
1:2bc809f: 			}
1:2bc809f: 			if (numcol == 0)
1:2bc809f: 				throw T_Fail.testFailMsg("cannot fit any column into the page");
1:2bc809f: 
1:2bc809f: 			
1:2bc809f: 
1:2bc809f: 			t_util.t_commit(t);
1:2bc809f: 
1:2bc809f: 			// make a big log record - update row
1:2bc809f: 			String string2 = "abcdefghijklmnopqrst"; // 20 char string
1:2bc809f: 			for (int i = 0; i < numcol; i++)
1:2bc809f: 				bigrow.setColumn(i, string2);
1:2bc809f: 
1:2bc809f: 			c = t_util.t_openContainer(t, 0, cid, true);
1:2bc809f: 			page = t_util.t_getPage(c, ContainerHandle.FIRST_PAGE_NUMBER);
1:2bc809f: 
1:2bc809f: 			Page p2 = t_util.t_addPage(c);		// do something so we get the beginXact log
1:2bc809f: 								// record out of the way
1:2bc809f: 			t_util.t_insert(p2, new T_RawStoreRow(REC_001));
1:2bc809f: 
1:2bc809f: 
1:2bc809f: 			//////////////////////////////////////////////////////////
1:2bc809f: 			// writing approx 1/2 of log record  instance to the end of the log - 
1:2bc809f: 			// NO MORE LOG RECORD SHOULD BE WRITTEN,
1:2bc809f: 			// Length  4 bytes + 7(8) bytes of log record instance
1:2bc809f: 			//////////////////////////////////////////////////////////
1:aaea357: 			if(!checksumTest)
1:aaea357: 			{
1:2bc809f: 				SanityManager.DEBUG_SET(LogToFile.TEST_LOG_INCOMPLETE_LOG_WRITE);
1:1093b6d: 				System.setProperty(LogToFile.TEST_LOG_PARTIAL_LOG_WRITE_NUM_BYTES, Integer.toString(11));
1:aaea357: 			}
1:2bc809f: 
1:aaea357: 			logFactory.flushAll();
1:00d19b5: 			int slot = page.getSlotNumber(rh);
1:00d19b5: 			page.updateAtSlot(slot, bigrow.getRow(), null);
1:2bc809f: 
1:aaea357: 			if(checksumTest)
1:aaea357: 				simulateLogFileCorruption();
1:2bc809f: 
1:2bc809f: 			////////////////////////////////////////////////////////
1:aaea357: 
1:2bc809f: 			REPORT("badlog test4: cid = " + cid + " numcol " + numcol);
1:2bc809f: 
1:2bc809f: 			register(key(4,1), cid);
1:2bc809f: 			register(key(4,2), numcol);
1:2bc809f: 		}
1:2bc809f: 		finally
1:2bc809f: 		{
1:2bc809f: 			SanityManager.DEBUG_CLEAR(LogToFile.TEST_LOG_INCOMPLETE_LOG_WRITE);
1:2bc809f: 		}
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	/*
1:2bc809f: 	 * test recovery of test 4
1:2bc809f: 	 */
1:2bc809f: 	void RTest4() throws T_Fail, StandardException
1:2bc809f: 	{
1:2bc809f: 		long cid = find(key(4, 1));
1:2bc809f: 		if (cid < 0)
1:2bc809f: 		{
1:2bc809f: 			REPORT("bad log test4 not run");
1:2bc809f: 			return;
1:2bc809f: 		}
1:2bc809f: 		int numcol = (int)find(key(4,2));
1:2bc809f: 
1:2bc809f: 		Transaction t = t_util.t_startTransaction();
1:2bc809f: 		try
1:2bc809f: 		{
1:2bc809f: 			ContainerHandle c = t_util.t_openContainer(t, 0, cid, true);
1:2bc809f: 			Page page = t_util.t_getPage(c, ContainerHandle.FIRST_PAGE_NUMBER);
1:2bc809f: 
1:2bc809f: 			int optimisticNumcol = (int)((RawStoreFactory.PAGE_SIZE_MINIMUM*8)/(10*20));
1:2bc809f: 			T_RawStoreRow bigrow = new T_RawStoreRow(optimisticNumcol);
1:2bc809f: 			for (int i = 0; i < optimisticNumcol; i++)
1:2bc809f: 				bigrow.setColumn(i, (String) null);
1:2bc809f: 
1:2bc809f: 			page.fetchFromSlot(
1:2bc809f:                 (RecordHandle) null, 0, bigrow.getRow(), 
1:2bc809f:                 (FetchDescriptor) null,
1:2bc809f:                 false);
1:2bc809f: 
1:2bc809f: 			Storable column;
1:2bc809f: 			String string1 = "01234567890123456789"; // the original 20 char string
1:2bc809f: 
1:2bc809f: 			for (int i = 0; i < numcol; i++)
1:2bc809f: 			{
1:2bc809f: 				column = bigrow.getStorableColumn(i);
1:2bc809f: 				if (!(column.toString().equals(string1)))
1:2bc809f: 					throw T_Fail.testFailMsg("Column " + i + " value incorrect, got :" + column.toString());
1:2bc809f: 			}
1:2bc809f: 			for (int i = numcol; i < optimisticNumcol; i++)
1:2bc809f: 			{
1:2bc809f: 				column = bigrow.getStorableColumn(i);
1:2bc809f: 				if (!column.isNull())
1:2bc809f: 					throw T_Fail.testFailMsg("Column " + i + 
1:2bc809f: 											 " expect Null, got : " + column.toString());
1:2bc809f: 			}
1:2bc809f: 
1:2bc809f: 			REPORT("RTest4 passed");
1:2bc809f: 
1:2bc809f: 		}
1:2bc809f: 		finally
1:2bc809f: 		{
1:2bc809f: 			t_util.t_commit(t);
1:2bc809f: 			t.close();
1:2bc809f: 		}
1:2bc809f: 	}
1:2bc809f: 	
1:2bc809f: 	/*
1:2bc809f: 	 * test5 manufactures a log with the following recoverable 'defects':
1:2bc809f: 	 * - a log file that only has the partial log record length (3 bytes instead of 4
1:2bc809f: 	 * bytes writtne) of a log record written in the beginning
1:2bc809f: 	 */
1:2bc809f: 	protected void STest5() throws T_Fail, StandardException
1:2bc809f: 	{
1:2bc809f: 		Transaction t = t_util.t_startTransaction();
1:2bc809f: 
1:2bc809f: 		try
1:2bc809f: 		{
1:2bc809f: 			long cid = t_util.t_addContainer(t, 0);
1:2bc809f: 			ContainerHandle c = t_util.t_openContainer(t, 0, cid, true);
1:2bc809f: 
1:2bc809f: 			Page page = t_util.t_getPage(c, ContainerHandle.FIRST_PAGE_NUMBER);
1:2bc809f: 
1:2bc809f: 			// make a really big record - fill 80% of the page
1:2bc809f: 			int numcol = (int)((RawStoreFactory.PAGE_SIZE_MINIMUM*8)/(10*20));
1:2bc809f: 
1:2bc809f: 			T_RawStoreRow bigrow = new T_RawStoreRow(numcol);
1:2bc809f: 			String string1 = "01234567890123456789"; // 20 char string
1:2bc809f: 			for (int i = 0; i < numcol; i++)
1:2bc809f: 				bigrow.setColumn(i, string1);
1:2bc809f: 
1:2bc809f: 			// if overhead is > 80%, then reduce the row size until it fits
1:2bc809f: 			RecordHandle rh = null;
1:2bc809f: 			while(numcol > 0)
1:2bc809f: 			{
1:2bc809f: 				try {
1:2bc809f: 					rh = t_util.t_insert(page, bigrow);
1:2bc809f: 					break;
1:2bc809f: 				} catch (StandardException se) {
1:2bc809f: 					bigrow.setColumn(--numcol, (String) null);
1:2bc809f: 				}
1:2bc809f: 			}
1:2bc809f: 			if (numcol == 0)
1:2bc809f: 				throw T_Fail.testFailMsg("cannot fit any column into the page");
1:2bc809f: 
1:2bc809f: 			
1:2bc809f: 
1:2bc809f: 			t_util.t_commit(t);
1:2bc809f: 
1:2bc809f: 			// make a big log record - update row
1:2bc809f: 			String string2 = "abcdefghijklmnopqrst"; // 20 char string
1:2bc809f: 			for (int i = 0; i < numcol; i++)
1:2bc809f: 				bigrow.setColumn(i, string2);
1:2bc809f: 
1:2bc809f: 			c = t_util.t_openContainer(t, 0, cid, true);
1:2bc809f: 			page = t_util.t_getPage(c, ContainerHandle.FIRST_PAGE_NUMBER);
1:2bc809f: 
1:2bc809f: 			Page p2 = t_util.t_addPage(c);		// do something so we get the beginXact log
1:2bc809f: 								// record out of the way
1:2bc809f: 			t_util.t_insert(p2, new T_RawStoreRow(REC_001));
1:2bc809f: 
1:2bc809f: 
1:2bc809f: 			//////////////////////////////////////////////////////////
1:2bc809f: 			// writing approx 3 bytes of log record to the end of the log - 
1:2bc809f: 			// NO MORE LOG RECORD SHOULD BE WRITTEN,
1:2bc809f: 			// Length  3 bytes (4) of log record length
1:2bc809f: 			//////////////////////////////////////////////////////////
1:aaea357: 			if(!checksumTest)
1:aaea357: 			{
1:2bc809f: 				SanityManager.DEBUG_SET(LogToFile.TEST_LOG_INCOMPLETE_LOG_WRITE);
1:1093b6d: 				System.setProperty(LogToFile.TEST_LOG_PARTIAL_LOG_WRITE_NUM_BYTES, Integer.toString(3));
1:aaea357: 			}
1:aaea357: 			logFactory.flushAll();
1:2bc809f: 
1:00d19b5: 			int slot = page.getSlotNumber(rh);
1:00d19b5: 			page.updateAtSlot(slot, bigrow.getRow(), null);
1:2bc809f: 
1:aaea357: 			if(checksumTest)
1:aaea357: 				simulateLogFileCorruption();
1:2bc809f: 
1:2bc809f: 			////////////////////////////////////////////////////////
1:2bc809f: 
1:2bc809f: 			REPORT("badlog test5: cid = " + cid + " numcol " + numcol);
1:2bc809f: 
1:2bc809f: 			register(key(5,1), cid);
1:2bc809f: 			register(key(5,2), numcol);
1:2bc809f: 		}
1:2bc809f: 		finally
1:2bc809f: 		{
1:2bc809f: 			SanityManager.DEBUG_CLEAR(LogToFile.TEST_LOG_INCOMPLETE_LOG_WRITE);
1:2bc809f: 		}
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	/*
1:2bc809f: 	 * test recovery of test 5
1:2bc809f: 	 */
1:2bc809f: 	void RTest5() throws T_Fail, StandardException
1:2bc809f: 	{
1:2bc809f: 		long cid = find(key(5, 1));
1:2bc809f: 		if (cid < 0)
1:2bc809f: 		{
1:2bc809f: 			REPORT("bad log test5 not run");
1:2bc809f: 			return;
1:2bc809f: 		}
1:2bc809f: 		int numcol = (int)find(key(5,2));
1:2bc809f: 
1:2bc809f: 		Transaction t = t_util.t_startTransaction();
1:2bc809f: 		try
1:2bc809f: 		{
1:2bc809f: 			ContainerHandle c = t_util.t_openContainer(t, 0, cid, true);
1:2bc809f: 			Page page = t_util.t_getPage(c, ContainerHandle.FIRST_PAGE_NUMBER);
1:2bc809f: 
1:2bc809f: 			int optimisticNumcol = (int)((RawStoreFactory.PAGE_SIZE_MINIMUM*8)/(10*20));
1:2bc809f: 			T_RawStoreRow bigrow = new T_RawStoreRow(optimisticNumcol);
1:2bc809f: 			for (int i = 0; i < optimisticNumcol; i++)
1:2bc809f: 				bigrow.setColumn(i, (String) null);
1:2bc809f: 
1:2bc809f: 			page.fetchFromSlot(
1:2bc809f:                 (RecordHandle) null, 0, bigrow.getRow(), 
1:2bc809f:                 (FetchDescriptor) null,
1:2bc809f:                 false);
1:2bc809f: 
1:2bc809f: 			Storable column;
1:2bc809f: 			String string1 = "01234567890123456789"; // the original 20 char string
1:2bc809f: 
1:2bc809f: 			for (int i = 0; i < numcol; i++)
1:2bc809f: 			{
1:2bc809f: 				column = bigrow.getStorableColumn(i);
1:2bc809f: 				if (!(column.toString().equals(string1)))
1:2bc809f: 					throw T_Fail.testFailMsg("Column " + i + " value incorrect, got :" + column.toString());
1:2bc809f: 			}
1:2bc809f: 			for (int i = numcol; i < optimisticNumcol; i++)
1:2bc809f: 			{
1:2bc809f: 				column = bigrow.getStorableColumn(i);
1:2bc809f: 				if (!column.isNull())
1:2bc809f: 					throw T_Fail.testFailMsg("Column " + i + 
1:2bc809f: 											 " expect Null, got : " + column.toString());
1:2bc809f: 			}
1:2bc809f: 
1:2bc809f: 			REPORT("RTest5 passed");
1:2bc809f: 
1:2bc809f: 		}
1:2bc809f: 		finally
1:2bc809f: 		{
1:2bc809f: 			t_util.t_commit(t);
1:2bc809f: 			t.close();
1:2bc809f: 		}
1:2bc809f: 	}
1:2bc809f: 		
1:2bc809f: 	/*
1:2bc809f: 	 * test6 manufactures a log with the following recoverable 'defects':
1:2bc809f: 	 * - a log file that only has the log record with partial data portion
1:2bc809f: 	 * written (approximately (1997/2 (data)+ 16(log records ov)))	 */
1:2bc809f: 	protected void STest6() throws T_Fail, StandardException
1:2bc809f: 	{
1:2bc809f: 		Transaction t = t_util.t_startTransaction();
1:2bc809f: 
1:2bc809f: 		try
1:2bc809f: 		{
1:2bc809f: 			long cid = t_util.t_addContainer(t, 0);
1:2bc809f: 			ContainerHandle c = t_util.t_openContainer(t, 0, cid, true);
1:2bc809f: 
1:2bc809f: 			Page page = t_util.t_getPage(c, ContainerHandle.FIRST_PAGE_NUMBER);
1:2bc809f: 
1:2bc809f: 			// make a really big record - fill 80% of the page
1:2bc809f: 			int numcol = (int)((RawStoreFactory.PAGE_SIZE_MINIMUM*8)/(10*20));
1:2bc809f: 
1:2bc809f: 			T_RawStoreRow bigrow = new T_RawStoreRow(numcol);
1:2bc809f: 			String string1 = "01234567890123456789"; // 20 char string
1:2bc809f: 			for (int i = 0; i < numcol; i++)
1:2bc809f: 				bigrow.setColumn(i, string1);
1:2bc809f: 
1:2bc809f: 			// if overhead is > 80%, then reduce the row size until it fits
1:2bc809f: 			RecordHandle rh = null;
1:2bc809f: 			while(numcol > 0)
1:2bc809f: 			{
1:2bc809f: 				try {
1:2bc809f: 					rh = t_util.t_insert(page, bigrow);
1:2bc809f: 					break;
1:2bc809f: 				} catch (StandardException se) {
1:2bc809f: 					bigrow.setColumn(--numcol, (String) null);
1:2bc809f: 				}
1:2bc809f: 			}
1:2bc809f: 			if (numcol == 0)
1:2bc809f: 				throw T_Fail.testFailMsg("cannot fit any column into the page");
1:2bc809f: 
1:2bc809f: 			
1:2bc809f: 
1:2bc809f: 			t_util.t_commit(t);
1:2bc809f: 
1:2bc809f: 			// make a big log record - update row
1:2bc809f: 			String string2 = "abcdefghijklmnopqrst"; // 20 char string
1:2bc809f: 			for (int i = 0; i < numcol; i++)
1:2bc809f: 				bigrow.setColumn(i, string2);
1:2bc809f: 
1:2bc809f: 			c = t_util.t_openContainer(t, 0, cid, true);
1:2bc809f: 			page = t_util.t_getPage(c, ContainerHandle.FIRST_PAGE_NUMBER);
1:2bc809f: 
1:2bc809f: 			Page p2 = t_util.t_addPage(c);		// do something so we get the beginXact log
1:2bc809f: 								// record out of the way
1:2bc809f: 			t_util.t_insert(p2, new T_RawStoreRow(REC_001));
1:2bc809f: 
1:2bc809f: 
1:2bc809f: 			//////////////////////////////////////////////////////////
1:2bc809f: 			// writing (1997/2 (data)+ 16(log records ov)) bytes of log record to the end of the log - 
1:2bc809f: 			// NO MORE LOG RECORD SHOULD BE WRITTEN,
1:2bc809f: 			//////////////////////////////////////////////////////////
1:aaea357: 			if(!checksumTest)
1:2bc809f: 			{
1:2bc809f: 				SanityManager.DEBUG_SET(LogToFile.TEST_LOG_INCOMPLETE_LOG_WRITE);
1:1093b6d: 				System.setProperty(LogToFile.TEST_LOG_PARTIAL_LOG_WRITE_NUM_BYTES, Integer.toString((1997/2) + 16));
1:aaea357: 			}
1:aaea357: 			logFactory.flushAll();
1:00d19b5: 			int slot = page.getSlotNumber(rh);
1:00d19b5: 			page.updateAtSlot(slot, bigrow.getRow(), null);
1:2bc809f: 
1:aaea357: 			if(checksumTest)
1:aaea357: 				simulateLogFileCorruption();
1:2bc809f: 
1:2bc809f: 			////////////////////////////////////////////////////////
1:2bc809f: 
1:2bc809f: 			REPORT("badlog test6: cid = " + cid + " numcol " + numcol);
1:2bc809f: 
1:2bc809f: 			register(key(6,1), cid);
1:2bc809f: 			register(key(6,2), numcol);
1:2bc809f: 		}
1:2bc809f: 		finally
1:2bc809f: 		{
1:2bc809f: 			SanityManager.DEBUG_CLEAR(LogToFile.TEST_LOG_INCOMPLETE_LOG_WRITE);
1:2bc809f: 		}
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	/*
1:2bc809f: 	 * test recovery of test 6
1:2bc809f: 	 */
1:2bc809f: 	void RTest6() throws T_Fail, StandardException
1:2bc809f: 	{
1:2bc809f: 		long cid = find(key(6, 1));
1:2bc809f: 		if (cid < 0)
1:2bc809f: 		{
1:2bc809f: 			REPORT("bad log test6 not run");
1:2bc809f: 			return;
1:2bc809f: 		}
1:2bc809f: 		int numcol = (int)find(key(6,2));
1:2bc809f: 
1:2bc809f: 		Transaction t = t_util.t_startTransaction();
1:2bc809f: 		try
1:2bc809f: 		{
1:2bc809f: 			ContainerHandle c = t_util.t_openContainer(t, 0, cid, true);
1:2bc809f: 			Page page = t_util.t_getPage(c, ContainerHandle.FIRST_PAGE_NUMBER);
1:2bc809f: 
1:2bc809f: 			int optimisticNumcol = (int)((RawStoreFactory.PAGE_SIZE_MINIMUM*8)/(10*20));
1:2bc809f: 			T_RawStoreRow bigrow = new T_RawStoreRow(optimisticNumcol);
1:2bc809f: 			for (int i = 0; i < optimisticNumcol; i++)
1:2bc809f: 				bigrow.setColumn(i, (String) null);
1:2bc809f: 
1:2bc809f: 			page.fetchFromSlot(
1:2bc809f:                 (RecordHandle) null, 0, bigrow.getRow(), 
1:2bc809f:                 (FetchDescriptor) null,
1:2bc809f:                 false);
1:2bc809f: 
1:2bc809f: 			Storable column;
1:2bc809f: 			String string1 = "01234567890123456789"; // the original 20 char string
1:2bc809f: 
1:2bc809f: 			for (int i = 0; i < numcol; i++)
1:2bc809f: 			{
1:2bc809f: 				column = bigrow.getStorableColumn(i);
1:2bc809f: 				if (!(column.toString().equals(string1)))
1:2bc809f: 					throw T_Fail.testFailMsg("Column " + i + " value incorrect, got :" + column.toString());
1:2bc809f: 			}
1:2bc809f: 			for (int i = numcol; i < optimisticNumcol; i++)
1:2bc809f: 			{
1:2bc809f: 				column = bigrow.getStorableColumn(i);
1:2bc809f: 				if (!column.isNull())
1:2bc809f: 					throw T_Fail.testFailMsg("Column " + i + 
1:2bc809f: 											 " expect Null, got : " + column.toString());
1:2bc809f: 			}
1:2bc809f: 
1:2bc809f: 			REPORT("RTest6 passed");
1:2bc809f: 
1:2bc809f: 		}
1:2bc809f: 		finally
1:2bc809f: 		{
1:2bc809f: 			t_util.t_commit(t);
1:2bc809f: 			t.close();
1:2bc809f: 		}
1:2bc809f: 	}
1:2bc809f: 	/*
1:2bc809f: 	 * test7 manufactures a log with the following recoverable 'defects':
1:2bc809f: 	 * - a log file that has the last log record with partial end length
1:2bc809f: 	 * written( 3 of 4 bytes). instead of (1997(data) + 16 (log records overhead)) write (1997 + 15) 
1:2bc809f: 	 */
1:2bc809f: 	protected void STest7() throws T_Fail, StandardException
1:2bc809f: 	{
1:2bc809f: 		Transaction t = t_util.t_startTransaction();
1:2bc809f: 
1:2bc809f: 		try
1:2bc809f: 		{
1:2bc809f: 			long cid = t_util.t_addContainer(t, 0);
1:2bc809f: 			ContainerHandle c = t_util.t_openContainer(t, 0, cid, true);
1:2bc809f: 
1:2bc809f: 			Page page = t_util.t_getPage(c, ContainerHandle.FIRST_PAGE_NUMBER);
1:2bc809f: 
1:2bc809f: 			// make a really big record - fill 80% of the page
1:2bc809f: 			int numcol = (int)((RawStoreFactory.PAGE_SIZE_MINIMUM*8)/(10*20));
1:2bc809f: 
1:2bc809f: 			T_RawStoreRow bigrow = new T_RawStoreRow(numcol);
1:2bc809f: 			String string1 = "01234567890123456789"; // 20 char string
1:2bc809f: 			for (int i = 0; i < numcol; i++)
1:2bc809f: 				bigrow.setColumn(i, string1);
1:2bc809f: 
1:2bc809f: 			// if overhead is > 80%, then reduce the row size until it fits
1:2bc809f: 			RecordHandle rh = null;
1:2bc809f: 			while(numcol > 0)
1:aaea357: 			{
1:2bc809f: 				try {
1:2bc809f: 					rh = t_util.t_insert(page, bigrow);
1:2bc809f: 					break;
1:2bc809f: 				} catch (StandardException se) {
1:2bc809f: 					bigrow.setColumn(--numcol, (String) null);
1:2bc809f: 				}
1:2bc809f: 			}
1:2bc809f: 			if (numcol == 0)
1:2bc809f: 				throw T_Fail.testFailMsg("cannot fit any column into the page");
1:2bc809f: 
1:2bc809f: 			
1:2bc809f: 
1:2bc809f: 			t_util.t_commit(t);
1:2bc809f: 
1:2bc809f: 			// make a big log record - update row
1:2bc809f: 			String string2 = "abcdefghijklmnopqrst"; // 20 char string
1:2bc809f: 			for (int i = 0; i < numcol; i++)
1:2bc809f: 				bigrow.setColumn(i, string2);
1:2bc809f: 
1:2bc809f: 			c = t_util.t_openContainer(t, 0, cid, true);
1:2bc809f: 			page = t_util.t_getPage(c, ContainerHandle.FIRST_PAGE_NUMBER);
1:2bc809f: 
1:2bc809f: 			Page p2 = t_util.t_addPage(c);		// do something so we get the beginXact log
1:2bc809f: 								// record out of the way
1:2bc809f: 			t_util.t_insert(p2, new T_RawStoreRow(REC_001));
1:2bc809f: 
1:aaea357: 
1:2bc809f: 			//////////////////////////////////////////////////////////
1:2bc809f: 			// writing only 3 bytes of end length of the log record to the end of the log - 
1:2bc809f: 			//i.e: instead of (1997(data) + 16 (log records overhead)) write (1997 + 15) 
1:2bc809f: 			// NO MORE LOG RECORD SHOULD BE WRITTEN,
1:2bc809f: 			//////////////////////////////////////////////////////////
1:aaea357: 			if(!checksumTest)
1:2bc809f: 			{
1:2bc809f: 				SanityManager.DEBUG_SET(LogToFile.TEST_LOG_INCOMPLETE_LOG_WRITE);
1:1093b6d: 				System.setProperty(LogToFile.TEST_LOG_PARTIAL_LOG_WRITE_NUM_BYTES, Integer.toString(1997+15));
1:2bc809f: 			}
1:aaea357: 			logFactory.flushAll();
1:00d19b5: 			int slot = page.getSlotNumber(rh);
1:00d19b5: 			page.updateAtSlot(slot, bigrow.getRow(), null);
1:2bc809f: 
1:aaea357: 			if(checksumTest)
1:aaea357: 				simulateLogFileCorruption();
1:2bc809f: 
1:2bc809f: 
1:2bc809f: 			////////////////////////////////////////////////////////
1:2bc809f: 
1:2bc809f: 			REPORT("badlog test7: cid = " + cid + " numcol " + numcol);
1:2bc809f: 
1:2bc809f: 			register(key(7,1), cid);
1:2bc809f: 			register(key(7,2), numcol);
1:2bc809f: 		}
1:2bc809f: 		finally
1:2bc809f: 		{
1:2bc809f: 			SanityManager.DEBUG_CLEAR(LogToFile.TEST_LOG_INCOMPLETE_LOG_WRITE);
1:2bc809f: 		}
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	/*
1:2bc809f: 	 * test recovery of test 7
1:2bc809f: 	 */
1:2bc809f: 	void RTest7() throws T_Fail, StandardException
1:2bc809f: 	{
1:2bc809f: 		long cid = find(key(6, 1));
1:2bc809f: 		if (cid < 0)
1:2bc809f: 		{
1:2bc809f: 			REPORT("bad log test7 not run");
1:2bc809f: 			return;
1:2bc809f: 		}
1:2bc809f: 		int numcol = (int)find(key(6,2));
1:2bc809f: 
1:2bc809f: 		Transaction t = t_util.t_startTransaction();
1:2bc809f: 		try
1:2bc809f: 		{
1:2bc809f: 			ContainerHandle c = t_util.t_openContainer(t, 0, cid, true);
1:2bc809f: 			Page page = t_util.t_getPage(c, ContainerHandle.FIRST_PAGE_NUMBER);
1:2bc809f: 
1:2bc809f: 			int optimisticNumcol = (int)((RawStoreFactory.PAGE_SIZE_MINIMUM*8)/(10*20));
1:2bc809f: 			T_RawStoreRow bigrow = new T_RawStoreRow(optimisticNumcol);
1:2bc809f: 			for (int i = 0; i < optimisticNumcol; i++)
1:2bc809f: 				bigrow.setColumn(i, (String) null);
1:2bc809f: 
1:2bc809f: 			page.fetchFromSlot(
1:2bc809f:                 (RecordHandle) null, 0, bigrow.getRow(), 
1:2bc809f:                 (FetchDescriptor) null,
1:2bc809f:                 false);
1:2bc809f: 
1:2bc809f: 			Storable column;
1:2bc809f: 			String string1 = "01234567890123456789"; // the original 20 char string
1:2bc809f: 
1:2bc809f: 			for (int i = 0; i < numcol; i++)
1:2bc809f: 			{
1:2bc809f: 				column = bigrow.getStorableColumn(i);
1:2bc809f: 				if (!(column.toString().equals(string1)))
1:2bc809f: 					throw T_Fail.testFailMsg("Column " + i + " value incorrect, got :" + column.toString());
1:2bc809f: 			}
1:2bc809f: 			for (int i = numcol; i < optimisticNumcol; i++)
1:aaea357: 			{
1:2bc809f: 				column = bigrow.getStorableColumn(i);
1:2bc809f: 				if (!column.isNull())
1:2bc809f: 					throw T_Fail.testFailMsg("Column " + i + 
1:2bc809f: 											 " expect Null, got : " + column.toString());
1:2bc809f: 			}
1:2bc809f: 
1:2bc809f: 			REPORT("RTest7 passed");
1:2bc809f: 
1:2bc809f: 		}
1:2bc809f: 		finally
1:2bc809f: 		{
1:2bc809f: 			t_util.t_commit(t);
1:2bc809f: 			t.close();
1:2bc809f: 		}
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 
1:aaea357: 
17:aaea357: 	/*
1:aaea357: 	 * simulate log corruption to test the checksuming of log records. 
19:aaea357: 	 */
1:aaea357: 	private void simulateLogFileCorruption() throws T_Fail, StandardException
1:aaea357: 	{
1:aaea357: 		long filenum;
1:aaea357: 		long filepos;
1:aaea357: 		long amountOfLogWritten;
1:aaea357: 		LogCounter logInstant = (LogCounter)logFactory.getFirstUnflushedInstant();
1:aaea357: 		filenum = logInstant.getLogFileNumber();
1:aaea357: 		filepos = logInstant.getLogFilePosition();
1:aaea357: 		logFactory.flushAll();
1:aaea357: 		logInstant = (LogCounter)logFactory.getFirstUnflushedInstant();
1:aaea357: 		filenum = logInstant.getLogFileNumber();
1:aaea357: 		amountOfLogWritten = logInstant.getLogFilePosition() - filepos;
1:aaea357: 
1:aaea357: 		// write some random  garbage into the log file , 
1:aaea357: 		// purpose of doing this is to test that recovery works correctly when 
1:aaea357: 		// log records in the end of a log file did not get wrtten completely
1:aaea357: 		// and in the correct order. 
1:aaea357: 
1:aaea357: 		try{
1:aaea357: 			StorageRandomAccessFile log = logFactory.getLogFileToSimulateCorruption(filenum) ;
1:aaea357: 		
1:aaea357: 			int noWrites = (int) amountOfLogWritten / 512;
1:aaea357: 			//mess up few bytes in every block of a 512 bytes.
1:aaea357: 			filepos += 512;
1:aaea357: 			java.util.Random r = new java.util.Random();
1:aaea357: 			for(int i = 0 ; i < noWrites ; i++)
1:aaea357: 			{
1:aaea357: 				REPORT("corruptig log file : filenum " + filenum + " fileposition " + filepos);
1:aaea357: 				log.seek(filepos);
1:aaea357: 				log.writeInt(r.nextInt());
1:aaea357: 				filepos +=512;
1:aaea357: 
1:aaea357: 			}
1:2d8c0d3:             log.sync();
1:aaea357: 			log.close();
1:aaea357: 		}catch(IOException ie)
1:aaea357: 		{
1:aaea357: 			throw T_Fail.exceptionFail(ie);
1:aaea357: 		}
1:aaea357: 		
1:aaea357: 	}
1:aaea357: 
1:aaea357:     
1:2bc809f:     /**
1:a0dbbd7:      * Privileged lookup of the ContextService. Must be private so that user code
1:a0dbbd7:      * can't call this entry point.
1:a0dbbd7:      */
1:a0dbbd7:     private  static  ContextService    getContextService()
1:a0dbbd7:     {
1:56c1dc2:         return AccessController.doPrivileged
1:56c1dc2:             (
1:56c1dc2:              new PrivilegedAction<ContextService>()
1:56c1dc2:              {
1:56c1dc2:                  public ContextService run()
1:56c1dc2:                  {
1:56c1dc2:                      return ContextService.getFactory();
1:56c1dc2:                  }
1:56c1dc2:              }
1:56c1dc2:              );
1:56c1dc2:     }
1:56c1dc2: 
1:56c1dc2:     /**
1:56c1dc2:      * Privileged startup. Must be private so that user code
1:56c1dc2:      * can't call this entry point.
1:56c1dc2:      */
1:56c1dc2:     private  static  Object findServiceModule( final Object serviceModule, final String factoryInterface)
1:56c1dc2:         throws StandardException
1:56c1dc2:     {
1:56c1dc2:         try {
1:a0dbbd7:             return AccessController.doPrivileged
1:a0dbbd7:                 (
1:56c1dc2:                  new PrivilegedExceptionAction<Object>()
1:a0dbbd7:                  {
1:56c1dc2:                      public Object run()
1:56c1dc2:                          throws StandardException
1:56c1dc2:                      {
1:56c1dc2:                          return Monitor.findServiceModule( serviceModule, factoryInterface );
1:a0dbbd7:                      }
1:a0dbbd7:                  }
1:a0dbbd7:                  );
1:56c1dc2:         } catch (PrivilegedActionException pae)
1:56c1dc2:         {
1:56c1dc2:             throw StandardException.plainWrapException( pae );
1:56c1dc2:         }
1:56c1dc2:     }
1:56c1dc2: 
1:56c1dc2:     /**
1:56c1dc2:      * Privileged startup. Must be private so that user code
1:56c1dc2:      * can't call this entry point.
1:56c1dc2:      */
1:56c1dc2:     private  static  boolean startPersistentService( final String serviceName, final Properties properties ) 
1:56c1dc2:         throws StandardException
1:56c1dc2:     {
1:56c1dc2:         try {
1:56c1dc2:             return AccessController.doPrivileged
1:56c1dc2:                 (
1:56c1dc2:                  new PrivilegedExceptionAction<Boolean>()
1:56c1dc2:                  {
1:56c1dc2:                      public Boolean run()
1:56c1dc2:                          throws StandardException
1:56c1dc2:                      {
1:56c1dc2:                          return Monitor.startPersistentService( serviceName, properties );
1:56c1dc2:                      }
1:56c1dc2:                  }
1:56c1dc2:                  );
1:56c1dc2:         } catch (PrivilegedActionException pae)
1:56c1dc2:         {
1:56c1dc2:             throw StandardException.plainWrapException( pae );
1:56c1dc2:         }
1:56c1dc2:     }
1:56c1dc2: 
1:56c1dc2:     /**
1:56c1dc2:      * Privileged startup. Must be private so that user code
1:56c1dc2:      * can't call this entry point.
1:56c1dc2:      */
1:56c1dc2:     private  static  Object createPersistentService( final String factoryInterface, final String serviceName, final Properties properties ) 
1:56c1dc2:         throws StandardException
1:56c1dc2:     {
1:56c1dc2:         try {
1:56c1dc2:             return AccessController.doPrivileged
1:56c1dc2:                 (
1:56c1dc2:                  new PrivilegedExceptionAction<Object>()
1:56c1dc2:                  {
1:56c1dc2:                      public Object run()
1:56c1dc2:                          throws StandardException
1:a0dbbd7:                      {
1:56c1dc2:                          return Monitor.createPersistentService( factoryInterface, serviceName, properties );
1:56c1dc2:                      }
1:56c1dc2:                  }
1:56c1dc2:                  );
1:56c1dc2:         } catch (PrivilegedActionException pae)
1:56c1dc2:         {
1:56c1dc2:             throw StandardException.plainWrapException( pae );
1:a0dbbd7:         }
1:a0dbbd7:     }
1:a0dbbd7: 
1:aaea357: }
1:aaea357: 
1:aaea357: 
1:aaea357: 
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:56c1dc2
/////////////////////////////////////////////////////////////////////////
1: import java.security.PrivilegedActionException;
1: import java.security.PrivilegedExceptionAction;
/////////////////////////////////////////////////////////////////////////
1: 				factory = (RawStoreFactory) createPersistentService(getModuleToTestProtocolName(),
/////////////////////////////////////////////////////////////////////////
1: 				if (!startPersistentService(testService, startParams))
1: 				logFactory =(LogToFile) findServiceModule(factory, factory.getLogFactoryModule());
/////////////////////////////////////////////////////////////////////////
1:         return AccessController.doPrivileged
1:             (
1:              new PrivilegedAction<ContextService>()
1:              {
1:                  public ContextService run()
1:                  {
1:                      return ContextService.getFactory();
1:                  }
1:              }
1:              );
1:     }
1: 
1:     /**
1:      * Privileged startup. Must be private so that user code
1:      * can't call this entry point.
1:      */
1:     private  static  Object findServiceModule( final Object serviceModule, final String factoryInterface)
1:         throws StandardException
1:     {
1:         try {
1:                  new PrivilegedExceptionAction<Object>()
1:                      public Object run()
1:                          throws StandardException
1:                          return Monitor.findServiceModule( serviceModule, factoryInterface );
1:         } catch (PrivilegedActionException pae)
1:         {
1:             throw StandardException.plainWrapException( pae );
1:         }
1:     }
1: 
1:     /**
1:      * Privileged startup. Must be private so that user code
1:      * can't call this entry point.
1:      */
1:     private  static  boolean startPersistentService( final String serviceName, final Properties properties ) 
1:         throws StandardException
1:     {
1:         try {
1:             return AccessController.doPrivileged
1:                 (
1:                  new PrivilegedExceptionAction<Boolean>()
1:                  {
1:                      public Boolean run()
1:                          throws StandardException
1:                      {
1:                          return Monitor.startPersistentService( serviceName, properties );
1:                      }
1:                  }
1:                  );
1:         } catch (PrivilegedActionException pae)
1:         {
1:             throw StandardException.plainWrapException( pae );
1:         }
1:     }
1: 
1:     /**
1:      * Privileged startup. Must be private so that user code
1:      * can't call this entry point.
1:      */
1:     private  static  Object createPersistentService( final String factoryInterface, final String serviceName, final Properties properties ) 
1:         throws StandardException
1:     {
1:         try {
1:             return AccessController.doPrivileged
1:                 (
1:                  new PrivilegedExceptionAction<Object>()
1:                  {
1:                      public Object run()
1:                          throws StandardException
1:                      {
1:                          return Monitor.createPersistentService( factoryInterface, serviceName, properties );
1:                      }
1:                  }
1:                  );
1:         } catch (PrivilegedActionException pae)
1:         {
1:             throw StandardException.plainWrapException( pae );
commit:a0dbbd7
/////////////////////////////////////////////////////////////////////////
1: import java.security.PrivilegedAction;
1: import java.security.AccessController;
/////////////////////////////////////////////////////////////////////////
1: 			contextService = getContextService();
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Privileged lookup of the ContextService. Must be private so that user code
1:      * can't call this entry point.
1:      */
1:     private  static  ContextService    getContextService()
1:     {
0:         if ( System.getSecurityManager() == null )
1:         {
0:             return ContextService.getFactory();
1:         }
0:         else
1:         {
1:             return AccessController.doPrivileged
1:                 (
0:                  new PrivilegedAction<ContextService>()
1:                  {
0:                      public ContextService run()
1:                      {
0:                          return ContextService.getFactory();
1:                      }
1:                  }
1:                  );
1:         }
1:     }
1: 
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:2d8c0d3
/////////////////////////////////////////////////////////////////////////
1:             log.sync();
commit:a552fe6
/////////////////////////////////////////////////////////////////////////
0: 			log.sync();
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:00d19b5
/////////////////////////////////////////////////////////////////////////
1: 			int slot = page.getSlotNumber(rh);
1: 			page.updateAtSlot(slot, bigrow.getRow(), null);
/////////////////////////////////////////////////////////////////////////
1: 			int slot = page.getSlotNumber(rh);
1: 			page.updateAtSlot(slot, bigrow.getRow(), null);
/////////////////////////////////////////////////////////////////////////
1: 					int slot = page[i][j].getSlotNumber(rh[i][j]);
1: 					page[i][j].updateAtSlot(slot, row2.getRow(), null);
/////////////////////////////////////////////////////////////////////////
1: 				for (j = 0; j < numpages; j++) {
1: 					int slot = page[i][j].getSlotNumber(rh[i][j]);
1: 					page[i][j].updateAtSlot(slot, row3.getRow(), null);
1: 				}
/////////////////////////////////////////////////////////////////////////
1: 				for (j = 0; j < numpages; j++) {
1: 					int slot = page[i][j].getSlotNumber(rh[i][j]);
1: 					page[i][j].updateAtSlot(slot, row4.getRow(), null);
1: 				}
/////////////////////////////////////////////////////////////////////////
1: 				for (j = 0; j < numpages; j++) {
1: 					int slot = page[i][j].getSlotNumber(rh[i][j]);
1: 					page[i][j].updateAtSlot(slot, row5.getRow(), null);
1: 				}
/////////////////////////////////////////////////////////////////////////
1: 				for (j = 0; j < numpages; j++) {
1: 					int slot = page[i][j].getSlotNumber(rh[i][j]);
1: 					page[i][j].updateAtSlot(slot, row6.getRow(), null);
1: 				}
/////////////////////////////////////////////////////////////////////////
1: 			int slot = page.getSlotNumber(rh);
1: 			page.updateAtSlot(slot, bigrow.getRow(), null);
/////////////////////////////////////////////////////////////////////////
1: 			int slot = page.getSlotNumber(rh);
1: 			page.updateAtSlot(slot, bigrow.getRow(), null);
/////////////////////////////////////////////////////////////////////////
1: 			int slot = page.getSlotNumber(rh);
1: 			page.updateAtSlot(slot, bigrow.getRow(), null);
/////////////////////////////////////////////////////////////////////////
1: 			int slot = page.getSlotNumber(rh);
1: 			page.updateAtSlot(slot, bigrow.getRow(), null);
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:c38b841
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:2bc809f
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derbyTesting.unitTests.store.T_RecoverBadLog
1: 
0:    Copyright 1997, 2005 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derbyTesting.unitTests.store;
1: 
1: import org.apache.derbyTesting.unitTests.harness.T_Generic;
1: import org.apache.derbyTesting.unitTests.harness.T_Fail;
1: import org.apache.derbyTesting.unitTests.harness.UnitTest;
1: 
1: import org.apache.derby.impl.store.raw.log.*;
1: 
1: import org.apache.derby.iapi.services.context.ContextService;
1: import org.apache.derby.iapi.services.context.ContextManager;
1: import org.apache.derby.iapi.services.daemon.DaemonService;
1: import org.apache.derby.iapi.services.monitor.Monitor;
1: 
1: import org.apache.derby.iapi.services.locks.LockFactory;
1: import org.apache.derby.iapi.services.io.Storable;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.reference.Property;
1: import org.apache.derby.iapi.reference.EngineType;
1: 
1: import org.apache.derby.iapi.services.property.PropertyUtil;
1: import org.apache.derby.iapi.services.io.FormatableBitSet;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: 
1: import org.apache.derby.iapi.store.raw.*;
1: 
1: import org.apache.derby.iapi.store.access.conglomerate.LogicalUndo;
1: 
1: import org.apache.derby.iapi.store.access.Qualifier;
1: 
1: import java.io.IOException;
1: import java.io.RandomAccessFile;
1: import java.io.File;
1: import java.util.Properties;
1: 
1: 
1: 
1: /**
1: 	A implementation unit test for recovering log that has been damanged but salvagable.
1: 
1:     To run, create a derby.properties file in a new directory with the
1: 	contents
1: 
1: 	derby.module.test.recoverBadLog=org.apache.derbyTesting.unitTests.store.T_RecoverBadLog
1: 
1:     Execute in order
1: 
1: 	java -DTestBadLogSetup=true org.apache.derbyTesting.unitTests.harness.UnitTestMain
1: 	java -DTestBadLog1=true org.apache.derbyTesting.unitTests.harness.UnitTestMain
1: 	java -DTestBadLog2=true org.apache.derbyTesting.unitTests.harness.UnitTestMain
1: 	java -DTestBadLog3=true org.apache.derbyTesting.unitTests.harness.UnitTestMain
1: 	java -DTestBadLog4=true org.apache.derbyTesting.unitTests.harness.UnitTestMain
1: 	java -DTestBadLog5=true org.apache.derbyTesting.unitTests.harness.UnitTestMain
1: 	java -DTestBadLog6=true org.apache.derbyTesting.unitTests.harness.UnitTestMain
1: 	java -DTestBadLog7=true org.apache.derbyTesting.unitTests.harness.UnitTestMain
1: 	java -DTestBadLog1=true org.apache.derbyTesting.unitTests.harness.UnitTestMain
1: 	
1: */
1: 
1: public class T_RecoverBadLog extends T_Generic {
1: 
0: 	private static final String testService = "BadLogTest";
1: 
1: 	static final String REC_001 = "McLaren";
1: 	static final String REC_002 = "Ferrari";
1: 	static final String REC_003 = "Benetton";
1: 	static final String REC_004 = "Prost";
1: 	static final String REC_005 = "Tyrell";
1: 	static final String REC_006 = "Derby, Natscape, Goatscape, the popular names";
1: 	static final String REC_UNDO = "Lotus";
1: 
1: 	static final String SP1 = "savepoint1";
1: 	static final String SP2 = "savepoint2";
1: 
1: 	private RandomAccessFile infofile = null;
1: 
1: 	private boolean setup;
1: 	private boolean test1;
1: 	private boolean test2;
1: 	private boolean test3;
1: 	private boolean test4;
1: 	private boolean test5;
1: 	private boolean test6;
1: 	private boolean test7;
1: 
0: 	private static final String infoPath = "extinout/T_RecoverBadLog.info";
1: 
1: 	private static final String TEST_BADLOG_SETUP = "TestBadLogSetup";
1: 	private static final String TEST_BADLOG1 = "TestBadLog1";
1: 	private static final String TEST_BADLOG2 = "TestBadLog2";
1: 	private static final String TEST_BADLOG3 = "TestBadLog3";
1: 	private static final String TEST_BADLOG4 = "TestBadLog4";
1: 	private static final String TEST_BADLOG5 = "TestBadLog5";
1: 	private static final String TEST_BADLOG6 = "TestBadLog6";
1: 	private static final String TEST_BADLOG7 = "TestBadLog7";
1: 
1: 	private static final String TEST_BADLOG_INFO = "TestBadLogInfo";
1: 
1: 	RawStoreFactory	factory;
1: 	LockFactory  lf;
1: 	ContextService contextService;
1: 	T_Util t_util;
1: 
1: 	public T_RecoverBadLog() {
1: 		super();
1: 	}
1: 
1: 	/*
1: 	** Methods required by T_Generic
1: 	*/
1: 
1: 	public String getModuleToTestProtocolName() {
1: 		return RawStoreFactory.MODULE;
1: 	}
1: 
1: 	/**
1: 	*/
1: 	private void getConfig()
1: 	{
1: 		String param;
1: 
1: 		param = PropertyUtil.getSystemProperty(TEST_BADLOG_SETUP);
1: 		setup = Boolean.valueOf(param).booleanValue();
1: 
1: 		param = PropertyUtil.getSystemProperty(TEST_BADLOG1);
1: 		test1 = Boolean.valueOf(param).booleanValue();
1: 
1: 		param = PropertyUtil.getSystemProperty(TEST_BADLOG2);
1: 		test2 = Boolean.valueOf(param).booleanValue();
1: 
1: 		param = PropertyUtil.getSystemProperty(TEST_BADLOG3);
1: 		test3 = Boolean.valueOf(param).booleanValue();
1: 		
1: 		
1: 		param = PropertyUtil.getSystemProperty(TEST_BADLOG4);
1: 		test4 = Boolean.valueOf(param).booleanValue();
1: 		
1: 		param = PropertyUtil.getSystemProperty(TEST_BADLOG5);
1: 		test5 = Boolean.valueOf(param).booleanValue();
1: 
1: 		param = PropertyUtil.getSystemProperty(TEST_BADLOG6);
1: 		test6 = Boolean.valueOf(param).booleanValue();
1: 
1: 		param = PropertyUtil.getSystemProperty(TEST_BADLOG7);
1: 		test7 = Boolean.valueOf(param).booleanValue();
1: 	}
1: 
1: 
1: 	/**
1: 	    See T_Recovery for the general testing frame work
1: 
1: 		@exception T_Fail Unexpected behaviour from the API
1: 	 */
1: 	public void runTests() throws T_Fail {
1: 
1: 		getConfig();
1: 		int tests = 0;
1: 		if (setup) tests++;
1: 		if (test1) tests++;
1: 		if (test2) tests++;
1: 		if (test3) tests++;
1: 		if (test4) tests++;
1: 		if (test5) tests++;
1: 		if (test6) tests++;
1: 		if (test7) tests++;
1: 
1: 		
1: 		if (tests != 1)
1: 			throw T_Fail.testFailMsg("One & only one of the bad log recovery test should be run");
1: 
1: 		if (!SanityManager.DEBUG)
1: 		{
1: 			REPORT("recoverBadLog cannot be run on an insane server");
1: 			return;
1: 		}
1: 
1: 		try {
0: 			contextService = ContextService.getFactory();
1: 
1: 			File ifile = new File(infoPath);
1: 
1: 			//
1: 			// no checkpoint log record in any of the log files - unless this value
1: 			// is reset. LogToFile.TEST_LOG_SWITCH_LOG
1: 			// this will cause recovery to switch log without checkpointing
1: 			//
1: 			SanityManager.DEBUG_SET(LogToFile.TEST_LOG_SWITCH_LOG);
1: 
1: 			// don't want background checkpoint process to be running
1: 			SanityManager.DEBUG_SET(DaemonService.DaemonOff);
1: 
1: 			// see if we are testing encryption
1: 			startParams = T_Util.setEncryptionParam(startParams);
1: 
1: 			if (setup)				// the first test cleans up and start from fresh
1: 			{
1: 				// remove the service directory to ensure a clean run
1: 				REPORT("_______________________________________________________");
1: 				REPORT("\n\t\tcleaning up database for recovering from bad logs");
1: 				REPORT("_______________________________________________________");
1: 
1: 				// don't automatic boot this service if it gets left around
1: 				if (startParams == null) 
1: 					startParams = new Properties();
1: 				
1: 				startParams.put(Property.NO_AUTO_BOOT, Boolean.TRUE.toString());
1: 				// remove the service directory to ensure a clean run
1: 				startParams.put(Property.DELETE_ON_CREATE, Boolean.TRUE.toString());
1: 
0: 				factory = (RawStoreFactory) Monitor.createPersistentService(getModuleToTestProtocolName(),
1: 															  testService,
1: 															  startParams);
1: 				// create a database with nothing
1: 
1: 				// delete the info file
1: 				if (ifile.exists())
1: 					ifile.delete();
1: 
1: 				return;				// don't run anything now
1: 
1: 			}
1: 			else					// not setup, recover it
1: 			{
1: 				REPORT("_______________________________________________________");
1: 				if (test1)
0: 					REPORT("\n\t\tRunning bad log test 1");
1: 				if (test2)
0: 					REPORT("\n\t\tRunning bad log test 2");
1: 				if (test3)
0: 					REPORT("\n\t\tRunning bad log test 3");
1: 				if (test4)
0: 					REPORT("\n\t\tRunning bad log test 4");
1: 				if (test5)
0: 					REPORT("\n\t\tRunning bad log test 5");
1: 				if (test6)
0: 					REPORT("\n\t\tRunning bad log test 6");
1: 				if (test7)
0: 					REPORT("\n\t\tRunning bad log test 7");
1: 				
1: 				REPORT("_______________________________________________________");
1: 
1: 				//if external input output files does not exist ,create one
1: 				File ifdir = new File("extinout");
1: 				if(!ifdir.exists())
1: 					ifdir.mkdirs();
1: 
1: 				try
1: 				{
1: 					// make sure it does exist
1: 					infofile = new RandomAccessFile(ifile, "rw");
1: 				}
1: 				catch (IOException ioe)
1: 				{
1: 					System.out.println("Cannot write to temporary file " +
1: 									   infoPath + 
1: 									   ".  Please make sure it is correct, if not, please set the property " +
1: 									   "TestBadLogInfo=<where temp files should go>");
1: 					
1: 					throw T_Fail.exceptionFail(ioe);
1: 				}
1: 
0: 				if (!Monitor.startPersistentService(testService, startParams))
1: 					throw T_Fail.testFailMsg("Monitor didn't know how to restart service: " + testService);
1: 
1: 				factory = (RawStoreFactory) Monitor.findService(getModuleToTestProtocolName(), testService);
1: 
1: 			}
1: 		} catch (StandardException mse) {
1: 			throw T_Fail.exceptionFail(mse);
1: 		}
1: 
1: 		if (factory == null) {
1: 			throw T_Fail.testFailMsg(getModuleToTestProtocolName() + " service not started.");
1: 		}
1: 			
1: 		lf = factory.getLockFactory();
1: 		if (lf == null) {
1: 			throw T_Fail.testFailMsg("LockFactory.MODULE not found");
1: 		}
1: 
1: 		// get a utility helper
1: 		t_util = new T_Util(factory, lf, contextService);
1: 
1: 		try {
1: 
1: 			// these tests can be run in any order
1: 			RTest1();
1: 			RTest2();
1: 			RTest3();
1: 			RTest4();
1: 			RTest5();
1: 			RTest6();
1: 			RTest7();
1: 
1: 			if (test1)
1: 				STest1();
1: 
1: 			if (test2)
1: 				STest2();
1: 				
1: 			if (test3)
1: 				STest3();
1: 						
1: 			if (test4)
1: 				STest4();
1: 
1: 			if(test5) 
1: 				STest5();
1: 
1: 			if(test6) 
1: 				STest6();
1: 
1: 			if(test7) 
1: 				STest7();
1: 
1: 			if (infofile != null)
1: 				infofile.close();
1: 
1: 		} catch (StandardException se) {
1: 
1: 			throw T_Fail.exceptionFail(se);
1: 		}
1: 		catch (IOException ioe)
1: 		{
1: 			throw T_Fail.exceptionFail(ioe);
1: 		}
1: 	}
1: 
1: 	private long find(long inkey)
1: 	{
1: 		if (infofile == null)
1: 			return -1;
1: 
1: 		try 
1: 		{
1: 			infofile.seek(0);
1: 			long key;
1: 
1: 			while(true)
1: 			{
1: 				key = infofile.readLong();
1: 				if (key == inkey)
1: 				{
1: 					long value = infofile.readLong();
1: 					// System.out.println("found " + key + " " + value);
1: 					return value;
1: 				}
1: 				infofile.readLong();
1: 			}
1: 		} 
1: 		catch (IOException ioe)
1: 		{
1: 			// System.out.println("key not found " + inkey);
1: 			return -1;
1: 		}
1: 
1: 	}
1: 
1: 	private long key(int test, int param)
1: 	{
1: 		long i = test;
1: 		return ((i << 32) + param);
1: 	}
1: 
1: 	private void register(long key, long value)
1: 		 throws T_Fail
1: 	{
1: 		// System.out.println("registering " + key + " " + value);
1: 		try 
1: 		{
1: 			// go to the end
1: 			infofile.seek(infofile.length());
1: 			infofile.writeLong(key);
1: 			infofile.writeLong(value);
1: 		}
1: 		catch (IOException ioe)
1: 		{
1: 			T_Fail.exceptionFail(ioe);
1: 		}
1: 	}
1: 
1: 
1: 	/*
1: 	 * test1 manufactures a log with the following recoverable 'defects':
1: 	 *		- a log file that only have a single large 1/2 written log record
1: 	 */
1: 	protected void STest1() throws T_Fail, StandardException
1: 	{
1: 		Transaction t = t_util.t_startTransaction();
1: 
1: 		///////////////////////////////////////////
1: 		//// log switch without checkpoint here ///
1: 		///////////////////////////////////////////
1: 		factory.checkpoint();
1: 
1: 		try
1: 		{
1: 			long cid = t_util.t_addContainer(t, 0);
1: 			ContainerHandle c = t_util.t_openContainer(t, 0, cid, true);
1: 
1: 			Page page = t_util.t_getPage(c, ContainerHandle.FIRST_PAGE_NUMBER);
1: 
1: 			// make a really big record - fill 80% of the page
1: 			int numcol = (int)((RawStoreFactory.PAGE_SIZE_MINIMUM*8)/(10*20));
1: 
1: 			T_RawStoreRow bigrow = new T_RawStoreRow(numcol);
1: 			String string1 = "01234567890123456789"; // 20 char string
1: 			for (int i = 0; i < numcol; i++)
1: 				bigrow.setColumn(i, string1);
1: 
1: 			// if overhead is > 80%, then reduce the row size until it fits
1: 			RecordHandle rh = null;
1: 			while(numcol > 0)
1: 			{
1: 				try {
1: 					rh = t_util.t_insert(page, bigrow);
1: 					break;
1: 				} catch (StandardException se) {
1: 					bigrow.setColumn(--numcol, (String) null);
1: 				}
1: 			}
1: 			if (numcol == 0)
1: 				throw T_Fail.testFailMsg("cannot fit any column into the page");
1: 
1: 			
1: 
1: 			t_util.t_commit(t);
1: 
1: 			// make a big log record - update row
1: 			String string2 = "abcdefghijklmnopqrst"; // 20 char string
1: 			for (int i = 0; i < numcol; i++)
1: 				bigrow.setColumn(i, string2);
1: 
1: 			c = t_util.t_openContainer(t, 0, cid, true);
1: 			page = t_util.t_getPage(c, ContainerHandle.FIRST_PAGE_NUMBER);
1: 
1: 			Page p2 = t_util.t_addPage(c);		// do something so we get the beginXact log
1: 								// record out of the way
1: 			t_util.t_insert(p2, new T_RawStoreRow(REC_001));
1: 
1: 
1: 			///////////////////////////////////////////
1: 			//// log switch without checkpoint here ///
1: 			///////////////////////////////////////////
1: 			factory.checkpoint();
1: 
1: 
1: 			//////////////////////////////////////////////////////////
1: 			// writing approx 1/2 log record to the end of the log - 
1: 			// NO MORE LOG RECORD SHOULD BE WRITTEN,
1: 			//////////////////////////////////////////////////////////
1: 			SanityManager.DEBUG_SET(LogToFile.TEST_LOG_INCOMPLETE_LOG_WRITE);
0: 			System.getProperties().put(LogToFile.TEST_LOG_PARTIAL_LOG_WRITE_NUM_BYTES, Integer.toString(numcol*20));
1: 
0: 			page.update(rh, bigrow.getRow(), (FormatableBitSet) null);
1: 
1: 			////////////////////////////////////////////////////////
1: 
1: 			REPORT("badlog test1: cid = " + cid + " numcol " + numcol);
1: 
1: 			register(key(1,1), cid);
1: 			register(key(1,2), numcol);
1: 		}
1: 		finally
1: 		{
1: 			SanityManager.DEBUG_CLEAR(LogToFile.TEST_LOG_INCOMPLETE_LOG_WRITE);
1: 		}
1: 	}
1: 
1: 	/*
1: 	 * test recovery of test 1
1: 	 */
1: 	void RTest1() throws T_Fail, StandardException
1: 	{
1: 		long cid = find(key(1, 1));
1: 		if (cid < 0)
1: 		{
1: 			REPORT("bad log test1 not run");
1: 			return;
1: 		}
1: 		int numcol = (int)find(key(1,2));
1: 
1: 		Transaction t = t_util.t_startTransaction();
1: 		try
1: 		{
1: 			ContainerHandle c = t_util.t_openContainer(t, 0, cid, true);
1: 			Page page = t_util.t_getPage(c, ContainerHandle.FIRST_PAGE_NUMBER);
1: 
1: 			int optimisticNumcol = (int)((RawStoreFactory.PAGE_SIZE_MINIMUM*8)/(10*20));
1: 			T_RawStoreRow bigrow = new T_RawStoreRow(optimisticNumcol);
1: 			for (int i = 0; i < optimisticNumcol; i++)
1: 				bigrow.setColumn(i, (String) null);
1: 
1: 			page.fetchFromSlot(
1:                 (RecordHandle) null, 0, bigrow.getRow(), 
1:                 (FetchDescriptor) null,
1:                 false);
1: 
1: 			Storable column;
1: 			String string1 = "01234567890123456789"; // the original 20 char string
1: 
1: 			for (int i = 0; i < numcol; i++)
1: 			{
1: 				column = bigrow.getStorableColumn(i);
1: 				if (!(column.toString().equals(string1)))
1: 					throw T_Fail.testFailMsg("Column " + i + " value incorrect, got :" + column.toString());
1: 			}
1: 			for (int i = numcol; i < optimisticNumcol; i++)
1: 			{
1: 				column = bigrow.getStorableColumn(i);
1: 				if (!column.isNull())
1: 					throw T_Fail.testFailMsg("Column " + i + 
1: 											 " expect Null, got : " + column.toString());
1: 			}
1: 
1: 			REPORT("RTest1 passed");
1: 
1: 		}
1: 		finally
1: 		{
1: 			t_util.t_commit(t);
1: 			t.close();
1: 		}
1: 	}
1: 
1: 	/*
1: 	 * test2 manufactures a log with the following recoverable 'defects':
1: 	 *		- a log file that ends with a large 1/2 written log record
1: 	 */
1: 	protected void STest2() throws T_Fail, StandardException
1: 	{
1: 		Transaction t = t_util.t_startTransaction();
1: 
1: 		try
1: 		{
1: 			long cid = t_util.t_addContainer(t, 0);
1: 			ContainerHandle c = t_util.t_openContainer(t, 0, cid, true);
1: 
1: 			Page page = t_util.t_getPage(c, ContainerHandle.FIRST_PAGE_NUMBER);
1: 
1: 			// make a really big record - fill 80% of the page with 20 bytes row
1: 			int numcol = (int)((RawStoreFactory.PAGE_SIZE_MINIMUM*8)/(10*20));
1: 
1: 			T_RawStoreRow bigrow = new T_RawStoreRow(numcol);
1: 			String string1 = "01234567890123456789"; // 20 char string
1: 			for (int i = 0; i < numcol; i++)
1: 				bigrow.setColumn(i, string1);
1: 
1: 			// if overhead is > 80%, then reduce the row size until it fits
1: 			RecordHandle rh = null;
1: 			while(numcol > 0)
1: 			{
1: 				try {
1: 					rh = t_util.t_insert(page, bigrow);
1: 					break;
1: 				} catch (StandardException se) {
1: 					bigrow.setColumn(--numcol, (String) null);
1: 				}
1: 			}
1: 			if (numcol == 0)
1: 				throw T_Fail.testFailMsg("cannot fit any column into the page");
1: 
1: 			rh = t_util.t_insert(page, bigrow);
1: 
1: 			t_util.t_commit(t);
1: 
1: 			// make a big log record - update row
1: 			String string2 = "abcdefghijklmnopqrst"; // 20 char string
1: 			for (int i = 0; i < numcol; i++)
1: 				bigrow.setColumn(i, string2);
1: 
1: 			c = t_util.t_openContainer(t, 0, cid, true);
1: 			page = t_util.t_getPage(c, ContainerHandle.FIRST_PAGE_NUMBER);
1: 
1: 			//////////////////////////////////////////////////////////
1: 			// writing approx 1/2 log record to the end of the log - 
1: 			// NO MORE LOG RECORD SHOULD BE WRITTEN,
1: 			//////////////////////////////////////////////////////////
1: 			SanityManager.DEBUG_SET(LogToFile.TEST_LOG_INCOMPLETE_LOG_WRITE);
0: 			System.getProperties().put(LogToFile.TEST_LOG_PARTIAL_LOG_WRITE_NUM_BYTES,Integer.toString(numcol*20));
1: 
0: 			page.update(rh, bigrow.getRow(), (FormatableBitSet) null);
1: 
1: 			////////////////////////////////////////////////////////
1: 
1: 			REPORT("badlog test2: cid = " + cid + " numcol " + numcol);
1: 
1: 			register(key(2,1), cid);
1: 			register(key(2,2), numcol);
1: 		}
1: 		finally
1: 		{
1: 			SanityManager.DEBUG_CLEAR(LogToFile.TEST_LOG_INCOMPLETE_LOG_WRITE);
1: 		}
1: 	}
1: 
1: 	/*
1: 	 * test recovery of test 2
1: 	 */
1: 	void RTest2() throws T_Fail, StandardException
1: 	{
1: 		long cid = find(key(2, 1));
1: 		if (cid < 0)
1: 		{
1: 			REPORT("bad log test2 not run");
1: 			return;
1: 		}
1: 		int numcol = (int)find(key(2,2));
1: 
1: 		Transaction t = t_util.t_startTransaction();
1: 		try
1: 		{
1: 			ContainerHandle c = t_util.t_openContainer(t, 0, cid, true);
1: 			Page page = t_util.t_getPage(c, ContainerHandle.FIRST_PAGE_NUMBER);
1: 
1: 			int optimisticNumcol = (int)((RawStoreFactory.PAGE_SIZE_MINIMUM*8)/(10*20));
1: 			T_RawStoreRow bigrow = new T_RawStoreRow(optimisticNumcol);
1: 			for (int i = 0; i < optimisticNumcol; i++)
1: 				bigrow.setColumn(i, (String) null);
1: 
1: 			page.fetchFromSlot(
1:                 (RecordHandle) null, 0, bigrow.getRow(), 
1:                 (FetchDescriptor) null,
1:                 false);
1: 			Storable column;
1: 			String string1 = "01234567890123456789"; // the original 20 char string
1: 
1: 			for (int i = 0; i < numcol; i++)
1: 			{
1: 				column = bigrow.getStorableColumn(i);
1: 				if (!(column.toString().equals(string1)))
1: 					throw T_Fail.testFailMsg("Column " + i + " value incorrect, got :" + column.toString());
1: 			}
1: 			for (int i = numcol; i < optimisticNumcol; i++)
1: 			{
1: 				column = bigrow.getStorableColumn(i);
1: 				if (!column.isNull())
1: 					throw T_Fail.testFailMsg("Column " + i + 
1: 											 " expect Null, got : " + column.toString());
1: 			}
1: 
1: 			REPORT("RTest2 passed");
1: 
1: 		}
1: 		finally
1: 		{
1: 			t_util.t_commit(t);
1: 			t.close();
1: 		}
1: 	}
1: 
1: 
1: 
1: 	/*
1: 	 * test3 manufactures a log with the following recoverable 'defects':
1: 	 *    - a log with multiple files but no checkpoint log record
1: 	 *	  - a last log file with a paritally written log record at the end
1: 	 */
1: 	protected void STest3() throws T_Fail, StandardException
1: 	{
1: 		int numtrans = 7;
1: 		int numpages = 7;
1: 		int i,j;
1: 
1: 		// this is basically T_Recovery S203 with a couple of log switches
1: 		try
1: 		{
1: 			T_TWC[] t = new T_TWC[numtrans];
1: 			for (i = 0; i < numtrans; i++)
1: 				t[i] =  t_util.t_startTransactionWithContext();
1: 
1: 			long[] cid = new long[numtrans];
1: 			ContainerHandle[] c = new ContainerHandle[numtrans];
1: 
1: 			for (i = 0; i < numtrans; i++)
1: 			{
1: 				cid[i] = t_util.t_addContainer(t[i], 0);
1: 				t_util.t_commit(t[i]);
1: 				c[i] = t_util.t_openContainer(t[i], 0, cid[i], true);
1: 			}
1: 
1: 			Page page[][] = new Page[numtrans][numpages];
1: 			long pagenum[][] = new long[numtrans][numpages];
1: 
1: 			for (i = 0; i < numtrans; i++)
1: 			{
1: 				for (j = 0; j < numpages; j++)
1: 				{
1: 					t[i].switchTransactionContext();
1: 					page[i][j] = t_util.t_addPage(c[i]);
1: 					pagenum[i][j] = page[i][j].getPageNumber();
1: 					t[i].resetContext();
1: 				}
1: 			}
1: 
1: 			// set up numtrans (at least 5) transactions, each with one
1: 			// container and numpages pages.  Do the following test:
1: 			//
1: 			// 1) insert 1 row onto each page
1: 			// set savepoint SP1 on first transaction (t0)
1: 			//
1: 			// 2) update every rows
1: 			// set savepoint SP1 on all other transactions
1: 			//
1: 			// 3) update every rows
1: 			// set savepoint SP2 on all transactions
1: 			// 
1: 			// 4) update every rows
1: 			//
1: 			// 5) rollback t0 to SP1
1: 			//
1: 			// check that only page[0][x] have been rolled back
1: 			// past SP2
1: 			//
1: 			// 6) update every row
1: 			// 7) rollback SP2 on all transaction except the first
1: 			// 
1: 			// 8) update every rows
1: 			// 9) rollback t0 to SP1
1: 			//
1: 			// 10) leave transactions in the following state
1: 			// t0 - incomplete
1: 			// t1 - abort
1: 			// t2 - commit
1: 			// t3 - incomplete
1: 			// t4 - commit
1: 			// any other transactions - incomplete
1: 
1: 
1: 			//////////////////////// step 1 ////////////////////////
1: 			RecordHandle[][] rh = new RecordHandle[numtrans][numpages];
1: 			T_RawStoreRow row1 = new T_RawStoreRow(REC_001);
1: 			for (i = 0; i < numtrans; i++)
1: 				for (j = 0; j < numpages; j++)
1: 				{
1: 					t[i].switchTransactionContext();
1: 					rh[i][j] = t_util.t_insert(page[i][j], row1); 
1: 					t[i].resetContext();
1: 				}
1: 
1: 			t[0].setSavePoint(SP1, null);	// sp1
1: 
1: 			//////////////////////// step 2 ////////////////////////
1: 			T_RawStoreRow row2 = new T_RawStoreRow(REC_002);
1: 			for (i = 0; i < numtrans; i++)
1: 				for (j = 0; j < numpages; j++)
1: 				{
1: 					t[i].switchTransactionContext();
0: 					page[i][j].update(rh[i][j], row2.getRow(), (FormatableBitSet) null);
1: 					t[i].resetContext();
1: 				}
1: 
1: 			for (i = 1; i < numtrans; i++) // sp1
1: 			{
1: 				t[i].setSavePoint(SP1, null);
1: 			}
1: 
1: 			///////////////////////////////////////////
1: 			//// log switch without checkpoint here ///
1: 			///////////////////////////////////////////
1: 			factory.checkpoint();
1: 
1: 
1: 			//////////////////////// step 3 ////////////////////////
1: 			T_RawStoreRow row3 = new T_RawStoreRow(REC_003);
1: 			for (i = 0; i < numtrans; i++)
1: 				for (j = 0; j < numpages; j++)
0: 					page[i][j].update(rh[i][j], row3.getRow(), (FormatableBitSet) null);
1: 
1: 			for (i = 0; i < numtrans; i++)
1: 				t[i].setSavePoint(SP2, null);	// sp2
1: 
1: 			//////////////////////// step 4 ////////////////////////
1: 			T_RawStoreRow row4 = new T_RawStoreRow(REC_004);
1: 			for (i = 0; i < numtrans; i++)
1: 			{
1: 				t[i].switchTransactionContext();
1: 
1: 				for (j = 0; j < numpages; j++)
0: 					page[i][j].update(rh[i][j], row4.getRow(), (FormatableBitSet) null);
1: 				t[i].resetContext();
1: 			}
1: 
1: 
1: 			//////////////////////// step 5 ////////////////////////
1: 			// unlatch relavante pages
1: 			t[0].switchTransactionContext();
1: 
1: 			for (j = 0; j < numpages; j++)
1: 				page[0][j].unlatch();
1: 
1: 			t[0].rollbackToSavePoint(SP1, null); // step 5
1: 
1: 			// relatch relavante pages
1: 			for (j = 0; j < numpages; j++)
1: 				page[0][j] = t_util.t_getPage(c[0], pagenum[0][j]);
1: 
1: 			t[0].resetContext();
1: 
1: 			///////////////////////////////////////////
1: 			//// log switch without checkpoint here ///
1: 			///////////////////////////////////////////
1: 			factory.checkpoint();
1: 
1: 
1: 			//////////////////////// check ////////////////////////
1: 			for (i = 1; i < numtrans; i++)
1: 			{
1: 				t[i].switchTransactionContext();
1: 				for (j = 0; j < numpages; j++)
1: 					t_util.t_checkFetch(page[i][j], rh[i][j], REC_004);
1: 				t[i].resetContext();
1: 			}
1: 
1: 			t[0].switchTransactionContext();
1: 			for (j = 0; j < numpages; j++)
1: 				t_util.t_checkFetch(page[0][j], rh[0][j], REC_001);
1: 			t[0].resetContext();
1: 
1: 			//////////////////////// step 6 ////////////////////////
1: 			T_RawStoreRow row5 = new T_RawStoreRow(REC_005);
1: 			for (i = 0; i < numtrans; i++)
1: 			{
1: 				t[i].switchTransactionContext();
1: 				for (j = 0; j < numpages; j++)
0: 					page[i][j].update(rh[i][j], row5.getRow(), (FormatableBitSet) null);
1: 				t[i].resetContext();
1: 			}
1: 
1: 			//////////////////////// step 7 ////////////////////////
1: 			for (i = 1; i < numtrans; i++)
1: 			{
1: 				t[i].switchTransactionContext();
1: 
1: 				for (j = 0; j < numpages; j++)
1: 					page[i][j].unlatch();
1: 
1: 				t[i].rollbackToSavePoint(SP2, null);
1: 
1: 				for (j = 0; j < numpages; j++)
1: 					page[i][j] = t_util.t_getPage(c[i],pagenum[i][j]);
1: 				t[i].resetContext();
1: 			}
1: 
1: 			//////////////////////// check ////////////////////////
1: 			for (i = 1; i < numtrans; i++)
1: 			{
1: 				t[i].switchTransactionContext();
1: 				for (j = 0; j < numpages; j++)
1: 					t_util.t_checkFetch(page[i][j], rh[i][j], REC_003);
1: 				t[i].resetContext();
1: 			}
1: 
1: 			t[0].switchTransactionContext();
1: 			for (j = 0; j < numpages; j++)
1: 				t_util.t_checkFetch(page[0][j], rh[0][j], REC_005);
1: 
1: 			t[0].resetContext();
1: 
1: 			///////////////////////////////////////////
1: 			//// log switch without checkpoint here ///
1: 			///////////////////////////////////////////
1: 			factory.checkpoint();
1: 
1: 
1: 			//////////////////////// step 8 ////////////////////////
1: 			T_RawStoreRow row6 = new T_RawStoreRow(REC_006);
1: 			for (i = 0; i < numtrans; i++)
1: 			{
1: 				t[i].switchTransactionContext();
1: 				for (j = 0; j < numpages; j++)
0: 					page[i][j].update(rh[i][j], row6.getRow(), (FormatableBitSet) null); // step 8
1: 				t[i].resetContext();
1: 			}
1: 
1: 			//////////////////////// step 9 ////////////////////////
1: 			// unlatch relavante pages
1: 			t[0].switchTransactionContext();
1: 			for (j = 0; j < numpages; j++)
1: 				page[0][j].unlatch();
1: 
1: 			t[0].rollbackToSavePoint(SP1, null); 
1: 
1: 			// relatch relevant pages
1: 			for (j = 0; j < numpages; j++)
1: 				page[0][j] = t_util.t_getPage(c[0], pagenum[0][j]);
1: 
1: 			t[0].resetContext();
1: 			//////////////////////// check ////////////////////////
1: 			for (i = 1; i < numtrans; i++)
1: 			{
1: 				t[i].switchTransactionContext();
1: 
1: 				for (j = 0; j < numpages; j++)
1: 				{
1: 					t_util.t_checkFetch(page[i][j], rh[i][j], REC_006);
1: 					t_util.t_checkRecordCount(page[i][j], 1, 1);
1: 				}
1: 				t[i].resetContext();
1: 			}
1: 
1: 			t[0].switchTransactionContext();
1: 			for (j = 0; j < numpages; j++)
1: 			{
1: 				t_util.t_checkFetch(page[0][j], rh[0][j], REC_001);
1: 				t_util.t_checkRecordCount(page[0][j], 1, 1);
1: 			}
1: 			t[0].resetContext();
1: 
1: 			//////////////////////// step 10 ////////////////////////
1: 			// unlatch all pages
1: 			for (i = 0; i < numtrans; i++)
1: 			{
1: 				t[i].switchTransactionContext();
1: 				for (j = 0; j < numpages; j++)
1: 					page[i][j].unlatch();
1: 				t[i].resetContext();
1: 			}
1: 
1: 			// t[0] incomplete
1: 			t_util.t_abort(t[1]);
1: 			t_util.t_commit(t[2]);
1: 			// t[3] incomplete
1: 			t_util.t_commit(t[4]);
1: 
1: 			// reopen containers 1, 2, and 4, where were closed when the
1: 			// transaction terminated.
1: 			c[1] = t_util.t_openContainer(t[1], 0, cid[1], false);
1: 			c[2] = t_util.t_openContainer(t[2], 0, cid[2], false);
1: 			c[4] = t_util.t_openContainer(t[4], 0, cid[4], false);
1: 
1: 			//////////////////////// check ////////////////////////
1: 			for (j = 0; j < numpages; j++)	
1: 			{
1: 				t[0].switchTransactionContext();
1: 				t_util.t_checkFetch(c[0], rh[0][j], REC_001);
1: 				t[0].resetContext();
1: 
1: 				// t[1] has been aborted
1: 				// rh[1][j] (REC_001) is deleted
1: 				t[1].switchTransactionContext();
1: 				page[1][j] = t_util.t_getPage(c[1], pagenum[1][j]);
1: 				t_util.t_checkRecordCount(page[1][j], 1, 0);
1: 				t_util.t_checkFetchBySlot(page[1][j], Page.FIRST_SLOT_NUMBER,
1: 								   REC_001, true, false);
1: 				page[1][j].unlatch();
1: 				t[1].resetContext();
1: 
1: 				t[2].switchTransactionContext();
1: 				t_util.t_checkFetch(c[2], rh[2][j], REC_006);
1: 				t[2].resetContext();
1: 
1: 				t[3].switchTransactionContext();
1: 				t_util.t_checkFetch(c[3], rh[3][j], REC_006);
1: 				t[3].resetContext();
1: 
1: 				t[4].switchTransactionContext();
1: 				t_util.t_checkFetch(c[4], rh[4][j], REC_006);
1: 				t[4].resetContext();
1: 			}
1: 
1: 
1: 			///////////////////////////////////////////////////////////
1: 			//// now write a 1/2 log record to the end of the log
1: 			//////////////////////////////////////////////////////////
1: 			t[3].switchTransactionContext();// this is going to be an
1: 											// incomplete transaction
1: 
1: 			// make a full page and then copy and purge it to another page
1: 			Page badPage1 = t_util.t_addPage(c[3]);
1: 			Page badPage2 = t_util.t_addPage(c[3]);
1: 			T_RawStoreRow row;
1: 			for (i = 0, row = new T_RawStoreRow("row at slot " + i);
1: 				 badPage1.spaceForInsert();
1: 				 i++, row = new T_RawStoreRow("row at slot " + i))
1: 			{
1: 				if (t_util.t_insertAtSlot(badPage1, i, row, Page.INSERT_UNDO_WITH_PURGE) == null)
1: 					break;
1: 			}
1: 
1: 			//////////////////////////////////////////////////////////
1: 			// writing 200 bytes of the log record to the end of the log - 
1: 			// NO MORE LOG RECORD SHOULD BE WRITTEN,
1: 			//////////////////////////////////////////////////////////
1: 
1: 			SanityManager.DEBUG_SET(LogToFile.TEST_LOG_INCOMPLETE_LOG_WRITE);
0: 			System.getProperties().put(LogToFile.TEST_LOG_PARTIAL_LOG_WRITE_NUM_BYTES, "200");
1: 
1: 			// RESOLVE:
1: 			// copy and purge actually generates 2 log records, this is
1: 			// actually not a good operation to use for this test.  Just make
1: 			// sure the first log record is > 400 or else the log will be hosed
1: 			//
1: 			badPage1.copyAndPurge(badPage2, 0, i, 0);
1: 
1: 			t[3].resetContext();
1: 			////////////////////////////////////////////////////////
1: 
1: 			REPORT("badlog test3: numtrans " + numtrans + " numpages " + numpages);
1: 
1: 			for (i = 0; i < numtrans; i++)
1: 			{
1: 				register(key(3, i+10), cid[i]);
1: 
1: 				String str = "container " + i + ":" + find(key(3,i+10)) + " pages: ";
1: 
1: 				for (j = 0; j < numpages; j++)
1: 				{
1: 					str += pagenum[i][j] + " ";
1: 					register(key(3, (i+1)*1000+j), pagenum[i][j]);
1: 				}
1: 				REPORT("\t" + str);
1: 			}
1: 
1: 			register(key(3,1), numtrans); 
1: 			register(key(3,2), numpages);
1: 			register(key(3,3), badPage1.getPageNumber());
1: 			register(key(3,4), badPage2.getPageNumber());
1: 
1: 		}
1: 		finally
1: 		{
1: 			SanityManager.DEBUG_CLEAR(LogToFile.TEST_LOG_INCOMPLETE_LOG_WRITE);
1: 		}
1: 	}
1: 
1: 	/*
1: 	 * test recovery of test3
1: 	 */
1: 	void RTest3() throws T_Fail, StandardException
1: 	{
1: 		int numtrans = (int)find(key(3,1));
1: 		if (numtrans < 0)
1: 		{
1: 			REPORT("bad log test3 not run");
1: 			return;
1: 		}
1: 
1: 		int numpages = (int)find(key(3,2));
1: 		long badPagenum1 = find(key(3,3)); // these two pages are involved in
1: 										   // the 1/2 written log record, make
1: 										   // sure they are not corrupted
1: 		long badPagenum2 = find(key(3,4));
1: 
1: 		Transaction t = t_util.t_startTransaction();
1: 
1: 		long[] cid = new long[numtrans];
1: 		ContainerHandle[] c = new ContainerHandle[numtrans];
1: 
1: 		long[][] pagenum = new long[numtrans][numpages];
1: 		Page[][] page = new Page[numtrans][numpages];
1: 
1: 		int i,j;
1: 
1: 		for (i = 0; i < numtrans; i++)
1: 		{
1: 			cid[i] = find(key(3, i+10));
1: 
1: 			c[i] = t_util.t_openContainer(t, 0, cid[i], true);
1: 			
1: 			for (j = 0; j < numpages; j++)
1: 			{
1: 				pagenum[i][j] = find(key(3, (i+1)*1000+j));
1: 
1: 				page[i][j] = t_util.t_getPage(c[i], pagenum[i][j]);
1: 			}
1: 		}
1: 
1: 		// transactions were left in the following state
1: 		// t0 - incomplete (rolled back)
1: 		// t1 - abort
1: 		// t2 - commit
1: 		// t3 - incomplete (rolled back)
1: 		// t4 - commit
1: 		// any other transactions - incomplete
1: 		//
1: 		// all the rolled back transaction should have a deleted REC_001
1: 		// all the committed transactions should have a REC_006
1:                                                                            //
1: 		try 
1: 		{
1: 			for (j = 0; j < numpages; j++)
1: 			{
1: 				t_util.t_checkRecordCount(page[0][j], 1, 0);
1: 				t_util.t_checkFetchBySlot(page[0][j], Page.FIRST_SLOT_NUMBER,
1: 								   REC_001, true, true);
1: 
1: 				t_util.t_checkRecordCount(page[1][j], 1, 0);
1: 				t_util.t_checkFetchBySlot(page[1][j], Page.FIRST_SLOT_NUMBER,
1: 								   REC_001, true, true);
1: 
1: 				t_util.t_checkRecordCount(page[2][j], 1, 1);
1: 				t_util.t_checkFetchBySlot(page[2][j], Page.FIRST_SLOT_NUMBER,
1: 								   REC_006, false, true);
1: 
1: 				t_util.t_checkRecordCount(page[3][j], 1, 0);
1: 				t_util.t_checkFetchBySlot(page[3][j], Page.FIRST_SLOT_NUMBER,
1: 								   REC_001, true, true);
1: 
1: 				t_util.t_checkRecordCount(page[4][j], 1, 1);
1: 				t_util.t_checkFetchBySlot(page[4][j], Page.FIRST_SLOT_NUMBER,
1: 								   REC_006, false, true);
1: 			}
1: 
1: 			// now check the two bad pages - they are in c[3] and should be empty
1: 			Page badPage1 = t_util.t_getPage(c[3], badPagenum1);
1: 			Page badPage2 = t_util.t_getPage(c[3], badPagenum2);
1: 			t_util.t_checkRecordCount(badPage1, 0, 0);
1: 			t_util.t_checkRecordCount(badPage2, 0, 0);
1: 
1: 			REPORT("RTest3 passed: numtrans " + numtrans + " numpages " + numpages);
1: 
1: 			for (i = 0; i < numtrans; i++)
1: 			{
1: 				String str = "container " + i + ":" + cid[i] + " pages: ";
1: 				for (j = 0; j < numpages; j++)
1: 					str += pagenum[i][j] + " ";
1: 				REPORT("\t" + str);
1: 			}
1: 		}
1: 		finally
1: 		{
1: 			t_util.t_commit(t);
1: 			t.close();
1: 		}
1: 	}
1: 
1: 		
1: 	/*
1: 	 * test4 manufactures a log with the following recoverable 'defects':
1: 	 * - a log file that only has the partial log instance(7 bytes instead of 8
1: 	 * bytes writtne) of a log record written 
1: 	 */
1: 	protected void STest4() throws T_Fail, StandardException
1: 	{
1: 		Transaction t = t_util.t_startTransaction();
1: 
1: 		try
1: 		{
1: 			long cid = t_util.t_addContainer(t, 0);
1: 			ContainerHandle c = t_util.t_openContainer(t, 0, cid, true);
1: 
1: 			Page page = t_util.t_getPage(c, ContainerHandle.FIRST_PAGE_NUMBER);
1: 
1: 			// make a really big record - fill 80% of the page
1: 			int numcol = (int)((RawStoreFactory.PAGE_SIZE_MINIMUM*8)/(10*20));
1: 
1: 			T_RawStoreRow bigrow = new T_RawStoreRow(numcol);
1: 			String string1 = "01234567890123456789"; // 20 char string
1: 			for (int i = 0; i < numcol; i++)
1: 				bigrow.setColumn(i, string1);
1: 
1: 			// if overhead is > 80%, then reduce the row size until it fits
1: 			RecordHandle rh = null;
1: 			while(numcol > 0)
1: 			{
1: 				try {
1: 					rh = t_util.t_insert(page, bigrow);
1: 					break;
1: 				} catch (StandardException se) {
1: 					bigrow.setColumn(--numcol, (String) null);
1: 				}
1: 			}
1: 			if (numcol == 0)
1: 				throw T_Fail.testFailMsg("cannot fit any column into the page");
1: 
1: 			
1: 
1: 			t_util.t_commit(t);
1: 
1: 			// make a big log record - update row
1: 			String string2 = "abcdefghijklmnopqrst"; // 20 char string
1: 			for (int i = 0; i < numcol; i++)
1: 				bigrow.setColumn(i, string2);
1: 
1: 			c = t_util.t_openContainer(t, 0, cid, true);
1: 			page = t_util.t_getPage(c, ContainerHandle.FIRST_PAGE_NUMBER);
1: 
1: 			Page p2 = t_util.t_addPage(c);		// do something so we get the beginXact log
1: 								// record out of the way
1: 			t_util.t_insert(p2, new T_RawStoreRow(REC_001));
1: 
1: 
1: 			//////////////////////////////////////////////////////////
1: 			// writing approx 1/2 of log record  instance to the end of the log - 
1: 			// NO MORE LOG RECORD SHOULD BE WRITTEN,
1: 			// Length  4 bytes + 7(8) bytes of log record instance
1: 			//////////////////////////////////////////////////////////
1: 			SanityManager.DEBUG_SET(LogToFile.TEST_LOG_INCOMPLETE_LOG_WRITE);
0: 			System.getProperties().put(LogToFile.TEST_LOG_PARTIAL_LOG_WRITE_NUM_BYTES, Integer.toString(11));
1: 
0: 			page.update(rh, bigrow.getRow(), (FormatableBitSet) null);
1: 
1: 			////////////////////////////////////////////////////////
1: 
1: 			REPORT("badlog test4: cid = " + cid + " numcol " + numcol);
1: 
1: 			register(key(4,1), cid);
1: 			register(key(4,2), numcol);
1: 		}
1: 		finally
1: 		{
1: 			SanityManager.DEBUG_CLEAR(LogToFile.TEST_LOG_INCOMPLETE_LOG_WRITE);
1: 		}
1: 	}
1: 
1: 	/*
1: 	 * test recovery of test 4
1: 	 */
1: 	void RTest4() throws T_Fail, StandardException
1: 	{
1: 		long cid = find(key(4, 1));
1: 		if (cid < 0)
1: 		{
1: 			REPORT("bad log test4 not run");
1: 			return;
1: 		}
1: 		int numcol = (int)find(key(4,2));
1: 
1: 		Transaction t = t_util.t_startTransaction();
1: 		try
1: 		{
1: 			ContainerHandle c = t_util.t_openContainer(t, 0, cid, true);
1: 			Page page = t_util.t_getPage(c, ContainerHandle.FIRST_PAGE_NUMBER);
1: 
1: 			int optimisticNumcol = (int)((RawStoreFactory.PAGE_SIZE_MINIMUM*8)/(10*20));
1: 			T_RawStoreRow bigrow = new T_RawStoreRow(optimisticNumcol);
1: 			for (int i = 0; i < optimisticNumcol; i++)
1: 				bigrow.setColumn(i, (String) null);
1: 
1: 			page.fetchFromSlot(
1:                 (RecordHandle) null, 0, bigrow.getRow(), 
1:                 (FetchDescriptor) null,
1:                 false);
1: 
1: 			Storable column;
1: 			String string1 = "01234567890123456789"; // the original 20 char string
1: 
1: 			for (int i = 0; i < numcol; i++)
1: 			{
1: 				column = bigrow.getStorableColumn(i);
1: 				if (!(column.toString().equals(string1)))
1: 					throw T_Fail.testFailMsg("Column " + i + " value incorrect, got :" + column.toString());
1: 			}
1: 			for (int i = numcol; i < optimisticNumcol; i++)
1: 			{
1: 				column = bigrow.getStorableColumn(i);
1: 				if (!column.isNull())
1: 					throw T_Fail.testFailMsg("Column " + i + 
1: 											 " expect Null, got : " + column.toString());
1: 			}
1: 
1: 			REPORT("RTest4 passed");
1: 
1: 		}
1: 		finally
1: 		{
1: 			t_util.t_commit(t);
1: 			t.close();
1: 		}
1: 	}
1: 	
1: 	/*
1: 	 * test5 manufactures a log with the following recoverable 'defects':
1: 	 * - a log file that only has the partial log record length (3 bytes instead of 4
1: 	 * bytes writtne) of a log record written in the beginning
1: 	 */
1: 	protected void STest5() throws T_Fail, StandardException
1: 	{
1: 		Transaction t = t_util.t_startTransaction();
1: 
1: 		try
1: 		{
1: 			long cid = t_util.t_addContainer(t, 0);
1: 			ContainerHandle c = t_util.t_openContainer(t, 0, cid, true);
1: 
1: 			Page page = t_util.t_getPage(c, ContainerHandle.FIRST_PAGE_NUMBER);
1: 
1: 			// make a really big record - fill 80% of the page
1: 			int numcol = (int)((RawStoreFactory.PAGE_SIZE_MINIMUM*8)/(10*20));
1: 
1: 			T_RawStoreRow bigrow = new T_RawStoreRow(numcol);
1: 			String string1 = "01234567890123456789"; // 20 char string
1: 			for (int i = 0; i < numcol; i++)
1: 				bigrow.setColumn(i, string1);
1: 
1: 			// if overhead is > 80%, then reduce the row size until it fits
1: 			RecordHandle rh = null;
1: 			while(numcol > 0)
1: 			{
1: 				try {
1: 					rh = t_util.t_insert(page, bigrow);
1: 					break;
1: 				} catch (StandardException se) {
1: 					bigrow.setColumn(--numcol, (String) null);
1: 				}
1: 			}
1: 			if (numcol == 0)
1: 				throw T_Fail.testFailMsg("cannot fit any column into the page");
1: 
1: 			
1: 
1: 			t_util.t_commit(t);
1: 
1: 			// make a big log record - update row
1: 			String string2 = "abcdefghijklmnopqrst"; // 20 char string
1: 			for (int i = 0; i < numcol; i++)
1: 				bigrow.setColumn(i, string2);
1: 
1: 			c = t_util.t_openContainer(t, 0, cid, true);
1: 			page = t_util.t_getPage(c, ContainerHandle.FIRST_PAGE_NUMBER);
1: 
1: 			Page p2 = t_util.t_addPage(c);		// do something so we get the beginXact log
1: 								// record out of the way
1: 			t_util.t_insert(p2, new T_RawStoreRow(REC_001));
1: 
1: 
1: 			//////////////////////////////////////////////////////////
1: 			// writing approx 3 bytes of log record to the end of the log - 
1: 			// NO MORE LOG RECORD SHOULD BE WRITTEN,
1: 			// Length  3 bytes (4) of log record length
1: 			//////////////////////////////////////////////////////////
1: 			SanityManager.DEBUG_SET(LogToFile.TEST_LOG_INCOMPLETE_LOG_WRITE);
0: 			System.getProperties().put(LogToFile.TEST_LOG_PARTIAL_LOG_WRITE_NUM_BYTES, Integer.toString(3));
1: 
0: 			page.update(rh, bigrow.getRow(), (FormatableBitSet) null);
1: 
1: 			////////////////////////////////////////////////////////
1: 
1: 			REPORT("badlog test5: cid = " + cid + " numcol " + numcol);
1: 
1: 			register(key(5,1), cid);
1: 			register(key(5,2), numcol);
1: 		}
1: 		finally
1: 		{
1: 			SanityManager.DEBUG_CLEAR(LogToFile.TEST_LOG_INCOMPLETE_LOG_WRITE);
1: 		}
1: 	}
1: 
1: 	/*
1: 	 * test recovery of test 5
1: 	 */
1: 	void RTest5() throws T_Fail, StandardException
1: 	{
1: 		long cid = find(key(5, 1));
1: 		if (cid < 0)
1: 		{
1: 			REPORT("bad log test5 not run");
1: 			return;
1: 		}
1: 		int numcol = (int)find(key(5,2));
1: 
1: 		Transaction t = t_util.t_startTransaction();
1: 		try
1: 		{
1: 			ContainerHandle c = t_util.t_openContainer(t, 0, cid, true);
1: 			Page page = t_util.t_getPage(c, ContainerHandle.FIRST_PAGE_NUMBER);
1: 
1: 			int optimisticNumcol = (int)((RawStoreFactory.PAGE_SIZE_MINIMUM*8)/(10*20));
1: 			T_RawStoreRow bigrow = new T_RawStoreRow(optimisticNumcol);
1: 			for (int i = 0; i < optimisticNumcol; i++)
1: 				bigrow.setColumn(i, (String) null);
1: 
1: 			page.fetchFromSlot(
1:                 (RecordHandle) null, 0, bigrow.getRow(), 
1:                 (FetchDescriptor) null,
1:                 false);
1: 
1: 			Storable column;
1: 			String string1 = "01234567890123456789"; // the original 20 char string
1: 
1: 			for (int i = 0; i < numcol; i++)
1: 			{
1: 				column = bigrow.getStorableColumn(i);
1: 				if (!(column.toString().equals(string1)))
1: 					throw T_Fail.testFailMsg("Column " + i + " value incorrect, got :" + column.toString());
1: 			}
1: 			for (int i = numcol; i < optimisticNumcol; i++)
1: 			{
1: 				column = bigrow.getStorableColumn(i);
1: 				if (!column.isNull())
1: 					throw T_Fail.testFailMsg("Column " + i + 
1: 											 " expect Null, got : " + column.toString());
1: 			}
1: 
1: 			REPORT("RTest5 passed");
1: 
1: 		}
1: 		finally
1: 		{
1: 			t_util.t_commit(t);
1: 			t.close();
1: 		}
1: 	}
1: 		
1: 	/*
1: 	 * test6 manufactures a log with the following recoverable 'defects':
1: 	 * - a log file that only has the log record with partial data portion
1: 	 * written (approximately (1997/2 (data)+ 16(log records ov)))	 */
1: 	protected void STest6() throws T_Fail, StandardException
1: 	{
1: 		Transaction t = t_util.t_startTransaction();
1: 
1: 		try
1: 		{
1: 			long cid = t_util.t_addContainer(t, 0);
1: 			ContainerHandle c = t_util.t_openContainer(t, 0, cid, true);
1: 
1: 			Page page = t_util.t_getPage(c, ContainerHandle.FIRST_PAGE_NUMBER);
1: 
1: 			// make a really big record - fill 80% of the page
1: 			int numcol = (int)((RawStoreFactory.PAGE_SIZE_MINIMUM*8)/(10*20));
1: 
1: 			T_RawStoreRow bigrow = new T_RawStoreRow(numcol);
1: 			String string1 = "01234567890123456789"; // 20 char string
1: 			for (int i = 0; i < numcol; i++)
1: 				bigrow.setColumn(i, string1);
1: 
1: 			// if overhead is > 80%, then reduce the row size until it fits
1: 			RecordHandle rh = null;
1: 			while(numcol > 0)
1: 			{
1: 				try {
1: 					rh = t_util.t_insert(page, bigrow);
1: 					break;
1: 				} catch (StandardException se) {
1: 					bigrow.setColumn(--numcol, (String) null);
1: 				}
1: 			}
1: 			if (numcol == 0)
1: 				throw T_Fail.testFailMsg("cannot fit any column into the page");
1: 
1: 			
1: 
1: 			t_util.t_commit(t);
1: 
1: 			// make a big log record - update row
1: 			String string2 = "abcdefghijklmnopqrst"; // 20 char string
1: 			for (int i = 0; i < numcol; i++)
1: 				bigrow.setColumn(i, string2);
1: 
1: 			c = t_util.t_openContainer(t, 0, cid, true);
1: 			page = t_util.t_getPage(c, ContainerHandle.FIRST_PAGE_NUMBER);
1: 
1: 			Page p2 = t_util.t_addPage(c);		// do something so we get the beginXact log
1: 								// record out of the way
1: 			t_util.t_insert(p2, new T_RawStoreRow(REC_001));
1: 
1: 
1: 			//////////////////////////////////////////////////////////
1: 			// writing (1997/2 (data)+ 16(log records ov)) bytes of log record to the end of the log - 
1: 			// NO MORE LOG RECORD SHOULD BE WRITTEN,
1: 			//////////////////////////////////////////////////////////
1: 			SanityManager.DEBUG_SET(LogToFile.TEST_LOG_INCOMPLETE_LOG_WRITE);
0: 			System.getProperties().put(LogToFile.TEST_LOG_PARTIAL_LOG_WRITE_NUM_BYTES, Integer.toString((1997/2) + 16));
1: 
0: 			page.update(rh, bigrow.getRow(), (FormatableBitSet) null);
1: 
1: 			////////////////////////////////////////////////////////
1: 
1: 			REPORT("badlog test6: cid = " + cid + " numcol " + numcol);
1: 
1: 			register(key(6,1), cid);
1: 			register(key(6,2), numcol);
1: 		}
1: 		finally
1: 		{
1: 			SanityManager.DEBUG_CLEAR(LogToFile.TEST_LOG_INCOMPLETE_LOG_WRITE);
1: 		}
1: 	}
1: 
1: 	/*
1: 	 * test recovery of test 6
1: 	 */
1: 	void RTest6() throws T_Fail, StandardException
1: 	{
1: 		long cid = find(key(6, 1));
1: 		if (cid < 0)
1: 		{
1: 			REPORT("bad log test6 not run");
1: 			return;
1: 		}
1: 		int numcol = (int)find(key(6,2));
1: 
1: 		Transaction t = t_util.t_startTransaction();
1: 		try
1: 		{
1: 			ContainerHandle c = t_util.t_openContainer(t, 0, cid, true);
1: 			Page page = t_util.t_getPage(c, ContainerHandle.FIRST_PAGE_NUMBER);
1: 
1: 			int optimisticNumcol = (int)((RawStoreFactory.PAGE_SIZE_MINIMUM*8)/(10*20));
1: 			T_RawStoreRow bigrow = new T_RawStoreRow(optimisticNumcol);
1: 			for (int i = 0; i < optimisticNumcol; i++)
1: 				bigrow.setColumn(i, (String) null);
1: 
1: 			page.fetchFromSlot(
1:                 (RecordHandle) null, 0, bigrow.getRow(), 
1:                 (FetchDescriptor) null,
1:                 false);
1: 
1: 			Storable column;
1: 			String string1 = "01234567890123456789"; // the original 20 char string
1: 
1: 			for (int i = 0; i < numcol; i++)
1: 			{
1: 				column = bigrow.getStorableColumn(i);
1: 				if (!(column.toString().equals(string1)))
1: 					throw T_Fail.testFailMsg("Column " + i + " value incorrect, got :" + column.toString());
1: 			}
1: 			for (int i = numcol; i < optimisticNumcol; i++)
1: 			{
1: 				column = bigrow.getStorableColumn(i);
1: 				if (!column.isNull())
1: 					throw T_Fail.testFailMsg("Column " + i + 
1: 											 " expect Null, got : " + column.toString());
1: 			}
1: 
1: 			REPORT("RTest6 passed");
1: 
1: 		}
1: 		finally
1: 		{
1: 			t_util.t_commit(t);
1: 			t.close();
1: 		}
1: 	}
1: 	/*
1: 	 * test7 manufactures a log with the following recoverable 'defects':
1: 	 * - a log file that has the last log record with partial end length
1: 	 * written( 3 of 4 bytes). instead of (1997(data) + 16 (log records overhead)) write (1997 + 15) 
1: 	 */
1: 	protected void STest7() throws T_Fail, StandardException
1: 	{
1: 		Transaction t = t_util.t_startTransaction();
1: 
1: 		try
1: 		{
1: 			long cid = t_util.t_addContainer(t, 0);
1: 			ContainerHandle c = t_util.t_openContainer(t, 0, cid, true);
1: 
1: 			Page page = t_util.t_getPage(c, ContainerHandle.FIRST_PAGE_NUMBER);
1: 
1: 			// make a really big record - fill 80% of the page
1: 			int numcol = (int)((RawStoreFactory.PAGE_SIZE_MINIMUM*8)/(10*20));
1: 
1: 			T_RawStoreRow bigrow = new T_RawStoreRow(numcol);
1: 			String string1 = "01234567890123456789"; // 20 char string
1: 			for (int i = 0; i < numcol; i++)
1: 				bigrow.setColumn(i, string1);
1: 
1: 			// if overhead is > 80%, then reduce the row size until it fits
1: 			RecordHandle rh = null;
1: 			while(numcol > 0)
1: 			{
1: 				try {
1: 					rh = t_util.t_insert(page, bigrow);
1: 					break;
1: 				} catch (StandardException se) {
1: 					bigrow.setColumn(--numcol, (String) null);
1: 				}
1: 			}
1: 			if (numcol == 0)
1: 				throw T_Fail.testFailMsg("cannot fit any column into the page");
1: 
1: 			
1: 
1: 			t_util.t_commit(t);
1: 
1: 			// make a big log record - update row
1: 			String string2 = "abcdefghijklmnopqrst"; // 20 char string
1: 			for (int i = 0; i < numcol; i++)
1: 				bigrow.setColumn(i, string2);
1: 
1: 			c = t_util.t_openContainer(t, 0, cid, true);
1: 			page = t_util.t_getPage(c, ContainerHandle.FIRST_PAGE_NUMBER);
1: 
1: 			Page p2 = t_util.t_addPage(c);		// do something so we get the beginXact log
1: 								// record out of the way
1: 			t_util.t_insert(p2, new T_RawStoreRow(REC_001));
1: 
1: 
1: 			//////////////////////////////////////////////////////////
1: 			// writing only 3 bytes of end length of the log record to the end of the log - 
1: 			//i.e: instead of (1997(data) + 16 (log records overhead)) write (1997 + 15) 
1: 			// NO MORE LOG RECORD SHOULD BE WRITTEN,
1: 			//////////////////////////////////////////////////////////
1: 			SanityManager.DEBUG_SET(LogToFile.TEST_LOG_INCOMPLETE_LOG_WRITE);
0: 			System.getProperties().put(LogToFile.TEST_LOG_PARTIAL_LOG_WRITE_NUM_BYTES, Integer.toString(1997+15));
1: 
0: 			page.update(rh, bigrow.getRow(), (FormatableBitSet) null);
1: 
1: 			////////////////////////////////////////////////////////
1: 
1: 			REPORT("badlog test7: cid = " + cid + " numcol " + numcol);
1: 
1: 			register(key(7,1), cid);
1: 			register(key(7,2), numcol);
1: 		}
1: 		finally
1: 		{
1: 			SanityManager.DEBUG_CLEAR(LogToFile.TEST_LOG_INCOMPLETE_LOG_WRITE);
1: 		}
1: 	}
1: 
1: 	/*
1: 	 * test recovery of test 7
1: 	 */
1: 	void RTest7() throws T_Fail, StandardException
1: 	{
1: 		long cid = find(key(6, 1));
1: 		if (cid < 0)
1: 		{
1: 			REPORT("bad log test7 not run");
1: 			return;
1: 		}
1: 		int numcol = (int)find(key(6,2));
1: 
1: 		Transaction t = t_util.t_startTransaction();
1: 		try
1: 		{
1: 			ContainerHandle c = t_util.t_openContainer(t, 0, cid, true);
1: 			Page page = t_util.t_getPage(c, ContainerHandle.FIRST_PAGE_NUMBER);
1: 
1: 			int optimisticNumcol = (int)((RawStoreFactory.PAGE_SIZE_MINIMUM*8)/(10*20));
1: 			T_RawStoreRow bigrow = new T_RawStoreRow(optimisticNumcol);
1: 			for (int i = 0; i < optimisticNumcol; i++)
1: 				bigrow.setColumn(i, (String) null);
1: 
1: 			page.fetchFromSlot(
1:                 (RecordHandle) null, 0, bigrow.getRow(), 
1:                 (FetchDescriptor) null,
1:                 false);
1: 
1: 			Storable column;
1: 			String string1 = "01234567890123456789"; // the original 20 char string
1: 
1: 			for (int i = 0; i < numcol; i++)
1: 			{
1: 				column = bigrow.getStorableColumn(i);
1: 				if (!(column.toString().equals(string1)))
1: 					throw T_Fail.testFailMsg("Column " + i + " value incorrect, got :" + column.toString());
1: 			}
1: 			for (int i = numcol; i < optimisticNumcol; i++)
1: 			{
1: 				column = bigrow.getStorableColumn(i);
1: 				if (!column.isNull())
1: 					throw T_Fail.testFailMsg("Column " + i + 
1: 											 " expect Null, got : " + column.toString());
1: 			}
1: 
1: 			REPORT("RTest7 passed");
1: 
1: 		}
1: 		finally
1: 		{
1: 			t_util.t_commit(t);
1: 			t.close();
1: 		}
1: 	}
1: }
1: 
1: 
1: 
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:1093b6d
/////////////////////////////////////////////////////////////////////////
1: 				System.setProperty(LogToFile.TEST_LOG_PARTIAL_LOG_WRITE_NUM_BYTES, Integer.toString(numcol*20));
/////////////////////////////////////////////////////////////////////////
1: 				System.setProperty(LogToFile.TEST_LOG_PARTIAL_LOG_WRITE_NUM_BYTES,Integer.toString(numcol*20));
/////////////////////////////////////////////////////////////////////////
1: 				System.setProperty(LogToFile.TEST_LOG_PARTIAL_LOG_WRITE_NUM_BYTES, "200");
/////////////////////////////////////////////////////////////////////////
1: 				System.setProperty(LogToFile.TEST_LOG_PARTIAL_LOG_WRITE_NUM_BYTES, Integer.toString(11));
/////////////////////////////////////////////////////////////////////////
1: 				System.setProperty(LogToFile.TEST_LOG_PARTIAL_LOG_WRITE_NUM_BYTES, Integer.toString(3));
/////////////////////////////////////////////////////////////////////////
1: 				System.setProperty(LogToFile.TEST_LOG_PARTIAL_LOG_WRITE_NUM_BYTES, Integer.toString((1997/2) + 16));
/////////////////////////////////////////////////////////////////////////
1: 				System.setProperty(LogToFile.TEST_LOG_PARTIAL_LOG_WRITE_NUM_BYTES, Integer.toString(1997+15));
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Derby - Class org.apache.derbyTesting.unitTests.store.T_RecoverBadLog
1: 
0:    Copyright 1997, 2005 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
0:       http://www.apache.org/licenses/LICENSE-2.0
1: 
0:    Unless required by applicable law or agreed to in writing, software
0:    distributed under the License is distributed on an "AS IS" BASIS,
0:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:    See the License for the specific language governing permissions and
0:    limitations under the License.
1: 
1:  */
1: 
0: package org.apache.derbyTesting.unitTests.store;
1: 
0: import org.apache.derbyTesting.unitTests.harness.T_Generic;
0: import org.apache.derbyTesting.unitTests.harness.T_Fail;
0: import org.apache.derbyTesting.unitTests.harness.UnitTest;
1: 
0: import org.apache.derby.impl.store.raw.log.*;
1: 
0: import org.apache.derby.iapi.services.context.ContextService;
0: import org.apache.derby.iapi.services.context.ContextManager;
0: import org.apache.derby.iapi.services.daemon.DaemonService;
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: import org.apache.derby.iapi.services.locks.LockFactory;
0: import org.apache.derby.iapi.services.io.Storable;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.reference.Property;
0: import org.apache.derby.iapi.reference.EngineType;
0: import org.apache.derby.iapi.services.property.PropertyUtil;
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
1: import org.apache.derby.io.StorageRandomAccessFile;
1: 
0: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.iapi.store.raw.*;
1: 
0: import org.apache.derby.iapi.store.access.conglomerate.LogicalUndo;
1: 
0: import org.apache.derby.iapi.store.access.Qualifier;
1: 
0: import java.io.IOException;
0: import java.io.RandomAccessFile;
0: import java.io.File;
0: import java.util.Properties;
1: 
1: 
1: 
0: /**
0: 	A implementation unit test for recovering log that has been damanged but salvagable.
1: 
0:     To run, create a derby.properties file in a new directory with the
0: 	contents
1: 
0: 	derby.module.test.recoverBadLog=org.apache.derbyTesting.unitTests.store.T_RecoverBadLog
1: 
0:     Execute in order
1: 
1: 	To Test Bad Log due to partial write that are identified by checking the
1: 	length in the beginning and end of the log record. 
1: 
0: 	java -DTestBadLogSetup=true org.apache.derbyTesting.unitTests.harness.UnitTestMain
0: 	java -DTestBadLog1=true org.apache.derbyTesting.unitTests.harness.UnitTestMain
0: 	java -DTestBadLog2=true org.apache.derbyTesting.unitTests.harness.UnitTestMain
0: 	java -DTestBadLog3=true org.apache.derbyTesting.unitTests.harness.UnitTestMain
0: 	java -DTestBadLog4=true org.apache.derbyTesting.unitTests.harness.UnitTestMain
0: 	java -DTestBadLog5=true org.apache.derbyTesting.unitTests.harness.UnitTestMain
0: 	java -DTestBadLog6=true org.apache.derbyTesting.unitTests.harness.UnitTestMain
0: 	java -DTestBadLog7=true org.apache.derbyTesting.unitTests.harness.UnitTestMain
0: 	java -DTestBadLog1=true org.apache.derbyTesting.unitTests.harness.UnitTestMain
1: 
1: 	To Test Bad Log due to an incomplete out of order write that is identified
1: 	by the checksum logic (simulated by	explicitly corrupting a middle of a 
1: 	log record at  the  end of log file after it is written).
1: 	
1: 	java -DTestBadLogSetup=true -DTestBadChecksumLog=true org.apache.derbyTesting.unitTests.harness.UnitTestMain
1: 	java -DTestBadLog1=true -DTestBadChecksumLog=true org.apache.derbyTesting.unitTests.harness.UnitTestMain
1: 	java -DTestBadLog2=true -DTestBadChecksumLog=true org.apache.derbyTesting.unitTests.harness.UnitTestMain
1: 	java -DTestBadLog3=true -DTestBadChecksumLog=true org.apache.derbyTesting.unitTests.harness.UnitTestMain
1: 	java -DTestBadLog4=true -DTestBadChecksumLog=true org.apache.derbyTesting.unitTests.harness.UnitTestMain
1: 	java -DTestBadLog5=true -DTestBadChecksumLog=true org.apache.derbyTesting.unitTests.harness.UnitTestMain
1: 	java -DTestBadLog6=true -DTestBadChecksumLog=true org.apache.derbyTesting.unitTests.harness.UnitTestMain
1: 	java -DTestBadLog7=true -DTestBadChecksumLog=true org.apache.derbyTesting.unitTests.harness.UnitTestMain
1: 	java -DTestBadLog1=true -DTestBadChecksumLog=true org.apache.derbyTesting.unitTests.harness.UnitTestMain
1: 	
1: 	
1: */
1: 
0: public class T_RecoverBadLog extends T_Generic {
1: 
1: 	private  String testService = "BadLogTest";
1: 
0: 	static final String REC_001 = "McLaren";
0: 	static final String REC_002 = "Ferrari";
0: 	static final String REC_003 = "Benetton";
0: 	static final String REC_004 = "Prost";
0: 	static final String REC_005 = "Tyrell";
0: 	static final String REC_006 = "Derby, Natscape, Goatscape, the popular names";
0: 	static final String REC_UNDO = "Lotus";
1: 
0: 	static final String SP1 = "savepoint1";
0: 	static final String SP2 = "savepoint2";
1: 
0: 	private RandomAccessFile infofile = null;
1: 
0: 	private boolean setup;
0: 	private boolean test1;
0: 	private boolean test2;
0: 	private boolean test3;
0: 	private boolean test4;
0: 	private boolean test5;
0: 	private boolean test6;
0: 	private boolean test7;
1: 	private boolean checksumTest; 
1: 	
1: 	private  String infoPath = "extinout/T_RecoverBadLog.info";
1: 
0: 	private static final String TEST_BADLOG_SETUP = "TestBadLogSetup";
0: 	private static final String TEST_BADLOG1 = "TestBadLog1";
0: 	private static final String TEST_BADLOG2 = "TestBadLog2";
0: 	private static final String TEST_BADLOG3 = "TestBadLog3";
0: 	private static final String TEST_BADLOG4 = "TestBadLog4";
0: 	private static final String TEST_BADLOG5 = "TestBadLog5";
0: 	private static final String TEST_BADLOG6 = "TestBadLog6";
0: 	private static final String TEST_BADLOG7 = "TestBadLog7";
1: 
1: 	private static final String TEST_BAD_CHECKSUM_LOG = "TestBadChecksumLog";
1: 
0: 	private static final String TEST_BADLOG_INFO = "TestBadLogInfo";
1: 	private static final String TEST_BADCHECKSUMLOG_INFO = "TestBadChecksumLogInfo";
1: 
0: 	RawStoreFactory	factory;
0: 	LockFactory  lf;
1: 	LogToFile   logFactory;
0: 	ContextService contextService;
0: 	T_Util t_util;
1: 
0: 	public T_RecoverBadLog() {
0: 		super();
1: 	}
1: 
1: 	/*
0: 	** Methods required by T_Generic
1: 	*/
1: 
0: 	public String getModuleToTestProtocolName() {
0: 		return RawStoreFactory.MODULE;
1: 	}
1: 
0: 	/**
1: 	*/
0: 	private void getConfig()
1: 	{
0: 		String param;
1: 
0: 		param = PropertyUtil.getSystemProperty(TEST_BADLOG_SETUP);
0: 		setup = Boolean.valueOf(param).booleanValue();
1: 
0: 		param = PropertyUtil.getSystemProperty(TEST_BADLOG1);
0: 		test1 = Boolean.valueOf(param).booleanValue();
1: 
0: 		param = PropertyUtil.getSystemProperty(TEST_BADLOG2);
0: 		test2 = Boolean.valueOf(param).booleanValue();
1: 
0: 		param = PropertyUtil.getSystemProperty(TEST_BADLOG3);
0: 		test3 = Boolean.valueOf(param).booleanValue();
1: 		
1: 		
0: 		param = PropertyUtil.getSystemProperty(TEST_BADLOG4);
0: 		test4 = Boolean.valueOf(param).booleanValue();
1: 		
0: 		param = PropertyUtil.getSystemProperty(TEST_BADLOG5);
0: 		test5 = Boolean.valueOf(param).booleanValue();
1: 
0: 		param = PropertyUtil.getSystemProperty(TEST_BADLOG6);
0: 		test6 = Boolean.valueOf(param).booleanValue();
1: 
0: 		param = PropertyUtil.getSystemProperty(TEST_BADLOG7);
0: 		test7 = Boolean.valueOf(param).booleanValue();
1: 		
1: 		param = PropertyUtil.getSystemProperty(TEST_BAD_CHECKSUM_LOG);
1: 		checksumTest = Boolean.valueOf(param).booleanValue();
1: 		
1: 		if(checksumTest)
1: 		{
1: 			infoPath = "extinout/T_RecoverBadChecksumLog.info";
1: 			testService = "BadChecksumLogTest";
1: 		}
1: 	}
1: 
1: 
0: 	/**
0: 	    See T_Recovery for the general testing frame work
1: 
0: 		@exception T_Fail Unexpected behaviour from the API
1: 	 */
0: 	public void runTests() throws T_Fail {
1: 
0: 		getConfig();
0: 		int tests = 0;
0: 		if (setup) tests++;
0: 		if (test1) tests++;
0: 		if (test2) tests++;
0: 		if (test3) tests++;
0: 		if (test4) tests++;
0: 		if (test5) tests++;
0: 		if (test6) tests++;
0: 		if (test7) tests++;
1: 		
0: 		if (tests != 1)
0: 			throw T_Fail.testFailMsg("One & only one of the bad log recovery test should be run");
1: 
0: 		if (!SanityManager.DEBUG)
1: 		{
0: 			REPORT("recoverBadLog cannot be run on an insane server");
0: 			return;
1: 		}
1: 
0: 		try {
0: 			contextService = ContextService.getFactory();
1: 
0: 			File ifile = new File(infoPath);
1: 
0: 			//
0: 			// no checkpoint log record in any of the log files - unless this value
0: 			// is reset. LogToFile.TEST_LOG_SWITCH_LOG
0: 			// this will cause recovery to switch log without checkpointing
0: 			//
0: 			SanityManager.DEBUG_SET(LogToFile.TEST_LOG_SWITCH_LOG);
1: 
0: 			// don't want background checkpoint process to be running
0: 			SanityManager.DEBUG_SET(DaemonService.DaemonOff);
1: 
0: 			// see if we are testing encryption
0: 			startParams = T_Util.setEncryptionParam(startParams);
1: 
0: 			if (setup)				// the first test cleans up and start from fresh
1: 			{
0: 				// remove the service directory to ensure a clean run
0: 				REPORT("_______________________________________________________");
0: 				REPORT("\n\t\tcleaning up database for recovering from bad logs");
0: 				REPORT("_______________________________________________________");
1: 
0: 				// don't automatic boot this service if it gets left around
0: 				if (startParams == null) 
0: 					startParams = new Properties();
1: 				
0: 				startParams.put(Property.NO_AUTO_BOOT, Boolean.TRUE.toString());
0: 				// remove the service directory to ensure a clean run
0: 				startParams.put(Property.DELETE_ON_CREATE, Boolean.TRUE.toString());
1: 
0: 				factory = (RawStoreFactory) Monitor.createPersistentService(getModuleToTestProtocolName(),
0: 															  testService,
0: 															  startParams);
0: 				// create a database with nothing
1: 
0: 				// delete the info file
0: 				if (ifile.exists())
0: 					ifile.delete();
1: 
0: 				return;				// don't run anything now
1: 
1: 			}
0: 			else					// not setup, recover it
1: 			{
0: 				REPORT("_______________________________________________________");
1: 				
1: 				String message = "\n\t\tRunning bad log test ";
1: 				if (checksumTest)
1: 					message = "\n\t\tRunning bad checksum log test ";
0: 				if (test1)
1: 					REPORT(message + " 1");
0: 				if (test2)
1: 					REPORT(message + " 2");
0: 				if (test3)
1: 					REPORT(message + " 3");
0: 				if (test4)
1: 					REPORT(message + " 4");
0: 				if (test5)
1: 					REPORT(message + " 5");
0: 				if (test6)
1: 					REPORT(message + " 6");
0: 				if (test7)
1: 					REPORT(message + " 7");
1: 
0: 				REPORT("_______________________________________________________");
1: 
0: 				//if external input output files does not exist ,create one
0: 				File ifdir = new File("extinout");
0: 				if(!ifdir.exists())
0: 					ifdir.mkdirs();
1: 
0: 				try
1: 				{
0: 					// make sure it does exist
0: 					infofile = new RandomAccessFile(ifile, "rw");
1: 				}
0: 				catch (IOException ioe)
1: 				{
0: 					System.out.println("Cannot write to temporary file " +
0: 									   infoPath + 
0: 									   ".  Please make sure it is correct, if not, please set the property " +
0: 									   "TestBadLogInfo=<where temp files should go>");
1: 					
0: 					throw T_Fail.exceptionFail(ioe);
1: 				}
1: 
0: 				if (!Monitor.startPersistentService(testService, startParams))
0: 					throw T_Fail.testFailMsg("Monitor didn't know how to restart service: " + testService);
1: 
0: 				factory = (RawStoreFactory) Monitor.findService(getModuleToTestProtocolName(), testService);
0: 				logFactory =(LogToFile) Monitor.findServiceModule(factory, factory.getLogFactoryModule());
1: 				
1: 			}
0: 		} catch (StandardException mse) {
0: 			throw T_Fail.exceptionFail(mse);
1: 		}
1: 
0: 		if (factory == null) {
0: 			throw T_Fail.testFailMsg(getModuleToTestProtocolName() + " service not started.");
1: 		}
1: 			
0: 		lf = factory.getLockFactory();
0: 		if (lf == null) {
0: 			throw T_Fail.testFailMsg("LockFactory.MODULE not found");
1: 		}
1: 
0: 		// get a utility helper
0: 		t_util = new T_Util(factory, lf, contextService);
1: 
0: 		try {
1: 			
1: 
0: 			// these tests can be run in any order
0: 			RTest1();
0: 			RTest2();
0: 			RTest3();
0: 			RTest4();
0: 			RTest5();
0: 			RTest6();
0: 			RTest7();
1: 
0: 			if (test1)
0: 				STest1();
1: 
0: 			if (test2)
0: 				STest2();
1: 				
0: 			if (test3)
0: 				STest3();
1: 						
0: 			if (test4)
0: 				STest4();
1: 
0: 			if(test5) 
0: 				STest5();
1: 
0: 			if(test6) 
0: 				STest6();
1: 
0: 			if(test7) 
0: 				STest7();
1: 
0: 			if (infofile != null)
0: 				infofile.close();
1: 
0: 		} catch (StandardException se) {
1: 
0: 			throw T_Fail.exceptionFail(se);
1: 		}
0: 		catch (IOException ioe)
1: 		{
0: 			throw T_Fail.exceptionFail(ioe);
1: 		}
1: 	}
1: 
0: 	private long find(long inkey)
1: 	{
0: 		if (infofile == null)
0: 			return -1;
1: 
0: 		try 
1: 		{
0: 			infofile.seek(0);
0: 			long key;
1: 
0: 			while(true)
1: 			{
0: 				key = infofile.readLong();
0: 				if (key == inkey)
1: 				{
0: 					long value = infofile.readLong();
0: 					// System.out.println("found " + key + " " + value);
0: 					return value;
1: 				}
0: 				infofile.readLong();
1: 			}
1: 		} 
0: 		catch (IOException ioe)
1: 		{
0: 			// System.out.println("key not found " + inkey);
0: 			return -1;
1: 		}
1: 
1: 	}
1: 
0: 	private long key(int test, int param)
1: 	{
0: 		long i = test;
0: 		return ((i << 32) + param);
1: 	}
1: 
0: 	private void register(long key, long value)
0: 		 throws T_Fail
1: 	{
0: 		// System.out.println("registering " + key + " " + value);
0: 		try 
1: 		{
0: 			// go to the end
0: 			infofile.seek(infofile.length());
0: 			infofile.writeLong(key);
0: 			infofile.writeLong(value);
1: 		}
0: 		catch (IOException ioe)
1: 		{
0: 			T_Fail.exceptionFail(ioe);
1: 		}
1: 	}
1: 
1: 
1: 	/*
0: 	 * test1 manufactures a log with the following recoverable 'defects':
0: 	 *		- a log file that only have a single large 1/2 written log record
1: 	 */
0: 	protected void STest1() throws T_Fail, StandardException
1: 	{
0: 		Transaction t = t_util.t_startTransaction();
1: 
0: 		///////////////////////////////////////////
0: 		//// log switch without checkpoint here ///
0: 		///////////////////////////////////////////
0: 		factory.checkpoint();
1: 
0: 		try
1: 		{
0: 			long cid = t_util.t_addContainer(t, 0);
0: 			ContainerHandle c = t_util.t_openContainer(t, 0, cid, true);
1: 
0: 			Page page = t_util.t_getPage(c, ContainerHandle.FIRST_PAGE_NUMBER);
1: 
0: 			// make a really big record - fill 80% of the page
0: 			int numcol = (int)((RawStoreFactory.PAGE_SIZE_MINIMUM*8)/(10*20));
1: 
0: 			T_RawStoreRow bigrow = new T_RawStoreRow(numcol);
0: 			String string1 = "01234567890123456789"; // 20 char string
0: 			for (int i = 0; i < numcol; i++)
0: 				bigrow.setColumn(i, string1);
1: 
0: 			// if overhead is > 80%, then reduce the row size until it fits
0: 			RecordHandle rh = null;
0: 			while(numcol > 0)
1: 			{
0: 				try {
0: 					rh = t_util.t_insert(page, bigrow);
0: 					break;
0: 				} catch (StandardException se) {
0: 					bigrow.setColumn(--numcol, (String) null);
1: 				}
1: 			}
0: 			if (numcol == 0)
0: 				throw T_Fail.testFailMsg("cannot fit any column into the page");
1: 
1: 			
1: 
0: 			t_util.t_commit(t);
1: 
0: 			// make a big log record - update row
0: 			String string2 = "abcdefghijklmnopqrst"; // 20 char string
0: 			for (int i = 0; i < numcol; i++)
0: 				bigrow.setColumn(i, string2);
1: 
0: 			c = t_util.t_openContainer(t, 0, cid, true);
0: 			page = t_util.t_getPage(c, ContainerHandle.FIRST_PAGE_NUMBER);
1: 
0: 			Page p2 = t_util.t_addPage(c);		// do something so we get the beginXact log
0: 								// record out of the way
0: 			t_util.t_insert(p2, new T_RawStoreRow(REC_001));
1: 
1: 
0: 			///////////////////////////////////////////
0: 			//// log switch without checkpoint here ///
0: 			///////////////////////////////////////////
0: 			factory.checkpoint();
1: 
0: 			//////////////////////////////////////////////////////////
0: 			// writing approx 1/2 log record to the end of the log - 
0: 			// NO MORE LOG RECORD SHOULD BE WRITTEN,
0: 			//////////////////////////////////////////////////////////
1: 			if(!checksumTest)
1: 			{
0: 				SanityManager.DEBUG_SET(LogToFile.TEST_LOG_INCOMPLETE_LOG_WRITE);
0: 				System.getProperties().put(LogToFile.TEST_LOG_PARTIAL_LOG_WRITE_NUM_BYTES, Integer.toString(numcol*20));
1: 			}
1: 			
1: 			logFactory.flushAll();
1: 
0: 			page.update(rh, bigrow.getRow(), (FormatableBitSet) null);
1: 
1: 			if(checksumTest)
1: 				simulateLogFileCorruption();
1: 
0: 			////////////////////////////////////////////////////////
1: 
0: 			REPORT("badlog test1: cid = " + cid + " numcol " + numcol);
1: 
0: 			register(key(1,1), cid);
0: 			register(key(1,2), numcol);
1: 		}
0: 		finally
1: 		{
0: 			SanityManager.DEBUG_CLEAR(LogToFile.TEST_LOG_INCOMPLETE_LOG_WRITE);
1: 		}
1: 	}
1: 
1: 	/*
0: 	 * test recovery of test 1
1: 	 */
0: 	void RTest1() throws T_Fail, StandardException
1: 	{
0: 		long cid = find(key(1, 1));
0: 		if (cid < 0)
1: 		{
0: 			REPORT("bad log test1 not run");
0: 			return;
1: 		}
0: 		int numcol = (int)find(key(1,2));
1: 
0: 		Transaction t = t_util.t_startTransaction();
0: 		try
1: 		{
0: 			ContainerHandle c = t_util.t_openContainer(t, 0, cid, true);
0: 			Page page = t_util.t_getPage(c, ContainerHandle.FIRST_PAGE_NUMBER);
1: 
0: 			int optimisticNumcol = (int)((RawStoreFactory.PAGE_SIZE_MINIMUM*8)/(10*20));
0: 			T_RawStoreRow bigrow = new T_RawStoreRow(optimisticNumcol);
0: 			for (int i = 0; i < optimisticNumcol; i++)
0: 				bigrow.setColumn(i, (String) null);
1: 
0: 			page.fetchFromSlot(
0:                 (RecordHandle) null, 0, bigrow.getRow(), 
0:                 (FetchDescriptor) null,
0:                 false);
1: 
0: 			Storable column;
0: 			String string1 = "01234567890123456789"; // the original 20 char string
1: 
0: 			for (int i = 0; i < numcol; i++)
1: 			{
0: 				column = bigrow.getStorableColumn(i);
0: 				if (!(column.toString().equals(string1)))
0: 					throw T_Fail.testFailMsg("Column " + i + " value incorrect, got :" + column.toString());
1: 			}
0: 			for (int i = numcol; i < optimisticNumcol; i++)
1: 			{
0: 				column = bigrow.getStorableColumn(i);
0: 				if (!column.isNull())
0: 					throw T_Fail.testFailMsg("Column " + i + 
0: 											 " expect Null, got : " + column.toString());
1: 			}
1: 
0: 			REPORT("RTest1 passed");
1: 
1: 		}
0: 		finally
1: 		{
0: 			t_util.t_commit(t);
0: 			t.close();
1: 		}
1: 	}
1: 
1: 	/*
0: 	 * test2 manufactures a log with the following recoverable 'defects':
0: 	 *		- a log file that ends with a large 1/2 written log record
1: 	 */
0: 	protected void STest2() throws T_Fail, StandardException
1: 	{
0: 		Transaction t = t_util.t_startTransaction();
1: 
0: 		try
1: 		{
0: 			long cid = t_util.t_addContainer(t, 0);
0: 			ContainerHandle c = t_util.t_openContainer(t, 0, cid, true);
1: 
0: 			Page page = t_util.t_getPage(c, ContainerHandle.FIRST_PAGE_NUMBER);
1: 
0: 			// make a really big record - fill 80% of the page with 20 bytes row
0: 			int numcol = (int)((RawStoreFactory.PAGE_SIZE_MINIMUM*8)/(10*20));
1: 
0: 			T_RawStoreRow bigrow = new T_RawStoreRow(numcol);
0: 			String string1 = "01234567890123456789"; // 20 char string
0: 			for (int i = 0; i < numcol; i++)
0: 				bigrow.setColumn(i, string1);
1: 
0: 			// if overhead is > 80%, then reduce the row size until it fits
0: 			RecordHandle rh = null;
0: 			while(numcol > 0)
1: 			{
0: 				try {
0: 					rh = t_util.t_insert(page, bigrow);
0: 					break;
0: 				} catch (StandardException se) {
0: 					bigrow.setColumn(--numcol, (String) null);
1: 				}
1: 			}
0: 			if (numcol == 0)
0: 				throw T_Fail.testFailMsg("cannot fit any column into the page");
1: 
0: 			rh = t_util.t_insert(page, bigrow);
1: 
0: 			t_util.t_commit(t);
1: 
0: 			// make a big log record - update row
0: 			String string2 = "abcdefghijklmnopqrst"; // 20 char string
0: 			for (int i = 0; i < numcol; i++)
0: 				bigrow.setColumn(i, string2);
1: 
0: 			c = t_util.t_openContainer(t, 0, cid, true);
0: 			page = t_util.t_getPage(c, ContainerHandle.FIRST_PAGE_NUMBER);
1: 
0: 			//////////////////////////////////////////////////////////
0: 			// writing approx 1/2 log record to the end of the log - 
0: 			// NO MORE LOG RECORD SHOULD BE WRITTEN,
0: 			//////////////////////////////////////////////////////////
1: 			if(!checksumTest)
1: 			{
0: 				SanityManager.DEBUG_SET(LogToFile.TEST_LOG_INCOMPLETE_LOG_WRITE);
0: 				System.getProperties().put(LogToFile.TEST_LOG_PARTIAL_LOG_WRITE_NUM_BYTES,Integer.toString(numcol*20));
1: 			}
1: 
1: 			logFactory.flushAll();
0: 			page.update(rh, bigrow.getRow(), (FormatableBitSet) null);
1: 			
1: 			if(checksumTest)
1: 				simulateLogFileCorruption();
1: 
0: 			////////////////////////////////////////////////////////
1: 
0: 			REPORT("badlog test2: cid = " + cid + " numcol " + numcol);
1: 
0: 			register(key(2,1), cid);
0: 			register(key(2,2), numcol);
1: 		}
0: 		finally
1: 		{
0: 			SanityManager.DEBUG_CLEAR(LogToFile.TEST_LOG_INCOMPLETE_LOG_WRITE);
1: 		}
1: 	}
1: 
1: 	/*
0: 	 * test recovery of test 2
1: 	 */
0: 	void RTest2() throws T_Fail, StandardException
1: 	{
0: 		long cid = find(key(2, 1));
0: 		if (cid < 0)
1: 		{
0: 			REPORT("bad log test2 not run");
0: 			return;
1: 		}
0: 		int numcol = (int)find(key(2,2));
1: 
0: 		Transaction t = t_util.t_startTransaction();
0: 		try
1: 		{
0: 			ContainerHandle c = t_util.t_openContainer(t, 0, cid, true);
0: 			Page page = t_util.t_getPage(c, ContainerHandle.FIRST_PAGE_NUMBER);
1: 
0: 			int optimisticNumcol = (int)((RawStoreFactory.PAGE_SIZE_MINIMUM*8)/(10*20));
0: 			T_RawStoreRow bigrow = new T_RawStoreRow(optimisticNumcol);
0: 			for (int i = 0; i < optimisticNumcol; i++)
0: 				bigrow.setColumn(i, (String) null);
1: 
0: 			page.fetchFromSlot(
0:                 (RecordHandle) null, 0, bigrow.getRow(), 
0:                 (FetchDescriptor) null,
0:                 false);
0: 			Storable column;
0: 			String string1 = "01234567890123456789"; // the original 20 char string
1: 
0: 			for (int i = 0; i < numcol; i++)
1: 			{
0: 				column = bigrow.getStorableColumn(i);
0: 				if (!(column.toString().equals(string1)))
0: 					throw T_Fail.testFailMsg("Column " + i + " value incorrect, got :" + column.toString());
1: 			}
0: 			for (int i = numcol; i < optimisticNumcol; i++)
1: 			{
0: 				column = bigrow.getStorableColumn(i);
0: 				if (!column.isNull())
0: 					throw T_Fail.testFailMsg("Column " + i + 
0: 											 " expect Null, got : " + column.toString());
1: 			}
1: 
0: 			REPORT("RTest2 passed");
1: 
1: 		}
0: 		finally
1: 		{
0: 			t_util.t_commit(t);
0: 			t.close();
1: 		}
1: 	}
1: 
1: 
1: 
1: 	/*
0: 	 * test3 manufactures a log with the following recoverable 'defects':
0: 	 *    - a log with multiple files but no checkpoint log record
0: 	 *	  - a last log file with a paritally written log record at the end
1: 	 */
0: 	protected void STest3() throws T_Fail, StandardException
1: 	{
0: 		int numtrans = 7;
0: 		int numpages = 7;
0: 		int i,j;
1: 
0: 		// this is basically T_Recovery S203 with a couple of log switches
0: 		try
1: 		{
0: 			T_TWC[] t = new T_TWC[numtrans];
0: 			for (i = 0; i < numtrans; i++)
0: 				t[i] =  t_util.t_startTransactionWithContext();
1: 
0: 			long[] cid = new long[numtrans];
0: 			ContainerHandle[] c = new ContainerHandle[numtrans];
1: 
0: 			for (i = 0; i < numtrans; i++)
1: 			{
0: 				cid[i] = t_util.t_addContainer(t[i], 0);
0: 				t_util.t_commit(t[i]);
0: 				c[i] = t_util.t_openContainer(t[i], 0, cid[i], true);
1: 			}
1: 
0: 			Page page[][] = new Page[numtrans][numpages];
0: 			long pagenum[][] = new long[numtrans][numpages];
1: 
0: 			for (i = 0; i < numtrans; i++)
1: 			{
0: 				for (j = 0; j < numpages; j++)
1: 				{
0: 					t[i].switchTransactionContext();
0: 					page[i][j] = t_util.t_addPage(c[i]);
0: 					pagenum[i][j] = page[i][j].getPageNumber();
0: 					t[i].resetContext();
1: 				}
1: 			}
1: 
0: 			// set up numtrans (at least 5) transactions, each with one
0: 			// container and numpages pages.  Do the following test:
0: 			//
0: 			// 1) insert 1 row onto each page
0: 			// set savepoint SP1 on first transaction (t0)
0: 			//
0: 			// 2) update every rows
0: 			// set savepoint SP1 on all other transactions
0: 			//
0: 			// 3) update every rows
0: 			// set savepoint SP2 on all transactions
0: 			// 
0: 			// 4) update every rows
0: 			//
0: 			// 5) rollback t0 to SP1
0: 			//
0: 			// check that only page[0][x] have been rolled back
0: 			// past SP2
0: 			//
0: 			// 6) update every row
0: 			// 7) rollback SP2 on all transaction except the first
0: 			// 
0: 			// 8) update every rows
0: 			// 9) rollback t0 to SP1
0: 			//
0: 			// 10) leave transactions in the following state
0: 			// t0 - incomplete
0: 			// t1 - abort
0: 			// t2 - commit
0: 			// t3 - incomplete
0: 			// t4 - commit
0: 			// any other transactions - incomplete
1: 
1: 
0: 			//////////////////////// step 1 ////////////////////////
0: 			RecordHandle[][] rh = new RecordHandle[numtrans][numpages];
0: 			T_RawStoreRow row1 = new T_RawStoreRow(REC_001);
0: 			for (i = 0; i < numtrans; i++)
0: 				for (j = 0; j < numpages; j++)
1: 				{
0: 					t[i].switchTransactionContext();
0: 					rh[i][j] = t_util.t_insert(page[i][j], row1); 
0: 					t[i].resetContext();
1: 				}
1: 
0: 			t[0].setSavePoint(SP1, null);	// sp1
1: 
0: 			//////////////////////// step 2 ////////////////////////
0: 			T_RawStoreRow row2 = new T_RawStoreRow(REC_002);
0: 			for (i = 0; i < numtrans; i++)
0: 				for (j = 0; j < numpages; j++)
1: 				{
0: 					t[i].switchTransactionContext();
0: 					page[i][j].update(rh[i][j], row2.getRow(), (FormatableBitSet) null);
0: 					t[i].resetContext();
1: 				}
1: 
0: 			for (i = 1; i < numtrans; i++) // sp1
1: 			{
0: 				t[i].setSavePoint(SP1, null);
1: 			}
1: 
0: 			///////////////////////////////////////////
0: 			//// log switch without checkpoint here ///
0: 			///////////////////////////////////////////
0: 			factory.checkpoint();
1: 
1: 
0: 			//////////////////////// step 3 ////////////////////////
0: 			T_RawStoreRow row3 = new T_RawStoreRow(REC_003);
0: 			for (i = 0; i < numtrans; i++)
0: 				for (j = 0; j < numpages; j++)
0: 					page[i][j].update(rh[i][j], row3.getRow(), (FormatableBitSet) null);
1: 
0: 			for (i = 0; i < numtrans; i++)
0: 				t[i].setSavePoint(SP2, null);	// sp2
1: 
0: 			//////////////////////// step 4 ////////////////////////
0: 			T_RawStoreRow row4 = new T_RawStoreRow(REC_004);
0: 			for (i = 0; i < numtrans; i++)
1: 			{
0: 				t[i].switchTransactionContext();
1: 
0: 				for (j = 0; j < numpages; j++)
0: 					page[i][j].update(rh[i][j], row4.getRow(), (FormatableBitSet) null);
0: 				t[i].resetContext();
1: 			}
1: 
1: 
0: 			//////////////////////// step 5 ////////////////////////
0: 			// unlatch relavante pages
0: 			t[0].switchTransactionContext();
1: 
0: 			for (j = 0; j < numpages; j++)
0: 				page[0][j].unlatch();
1: 
0: 			t[0].rollbackToSavePoint(SP1, null); // step 5
1: 
0: 			// relatch relavante pages
0: 			for (j = 0; j < numpages; j++)
0: 				page[0][j] = t_util.t_getPage(c[0], pagenum[0][j]);
1: 
0: 			t[0].resetContext();
1: 
0: 			///////////////////////////////////////////
0: 			//// log switch without checkpoint here ///
0: 			///////////////////////////////////////////
0: 			factory.checkpoint();
1: 
1: 
0: 			//////////////////////// check ////////////////////////
0: 			for (i = 1; i < numtrans; i++)
1: 			{
0: 				t[i].switchTransactionContext();
0: 				for (j = 0; j < numpages; j++)
0: 					t_util.t_checkFetch(page[i][j], rh[i][j], REC_004);
0: 				t[i].resetContext();
1: 			}
1: 
0: 			t[0].switchTransactionContext();
0: 			for (j = 0; j < numpages; j++)
0: 				t_util.t_checkFetch(page[0][j], rh[0][j], REC_001);
0: 			t[0].resetContext();
1: 
0: 			//////////////////////// step 6 ////////////////////////
0: 			T_RawStoreRow row5 = new T_RawStoreRow(REC_005);
0: 			for (i = 0; i < numtrans; i++)
1: 			{
0: 				t[i].switchTransactionContext();
0: 				for (j = 0; j < numpages; j++)
0: 					page[i][j].update(rh[i][j], row5.getRow(), (FormatableBitSet) null);
0: 				t[i].resetContext();
1: 			}
1: 
0: 			//////////////////////// step 7 ////////////////////////
0: 			for (i = 1; i < numtrans; i++)
1: 			{
0: 				t[i].switchTransactionContext();
1: 
0: 				for (j = 0; j < numpages; j++)
0: 					page[i][j].unlatch();
1: 
0: 				t[i].rollbackToSavePoint(SP2, null);
1: 
0: 				for (j = 0; j < numpages; j++)
0: 					page[i][j] = t_util.t_getPage(c[i],pagenum[i][j]);
0: 				t[i].resetContext();
1: 			}
1: 
0: 			//////////////////////// check ////////////////////////
0: 			for (i = 1; i < numtrans; i++)
1: 			{
0: 				t[i].switchTransactionContext();
0: 				for (j = 0; j < numpages; j++)
0: 					t_util.t_checkFetch(page[i][j], rh[i][j], REC_003);
0: 				t[i].resetContext();
1: 			}
1: 
0: 			t[0].switchTransactionContext();
0: 			for (j = 0; j < numpages; j++)
0: 				t_util.t_checkFetch(page[0][j], rh[0][j], REC_005);
1: 
0: 			t[0].resetContext();
1: 
0: 			///////////////////////////////////////////
0: 			//// log switch without checkpoint here ///
0: 			///////////////////////////////////////////
0: 			factory.checkpoint();
1: 
1: 
0: 			//////////////////////// step 8 ////////////////////////
0: 			T_RawStoreRow row6 = new T_RawStoreRow(REC_006);
0: 			for (i = 0; i < numtrans; i++)
1: 			{
0: 				t[i].switchTransactionContext();
0: 				for (j = 0; j < numpages; j++)
0: 					page[i][j].update(rh[i][j], row6.getRow(), (FormatableBitSet) null); // step 8
0: 				t[i].resetContext();
1: 			}
1: 
0: 			//////////////////////// step 9 ////////////////////////
0: 			// unlatch relavante pages
0: 			t[0].switchTransactionContext();
0: 			for (j = 0; j < numpages; j++)
0: 				page[0][j].unlatch();
1: 
0: 			t[0].rollbackToSavePoint(SP1, null); 
1: 
0: 			// relatch relevant pages
0: 			for (j = 0; j < numpages; j++)
0: 				page[0][j] = t_util.t_getPage(c[0], pagenum[0][j]);
1: 
0: 			t[0].resetContext();
0: 			//////////////////////// check ////////////////////////
0: 			for (i = 1; i < numtrans; i++)
1: 			{
0: 				t[i].switchTransactionContext();
1: 
0: 				for (j = 0; j < numpages; j++)
1: 				{
0: 					t_util.t_checkFetch(page[i][j], rh[i][j], REC_006);
0: 					t_util.t_checkRecordCount(page[i][j], 1, 1);
1: 				}
0: 				t[i].resetContext();
1: 			}
1: 
0: 			t[0].switchTransactionContext();
0: 			for (j = 0; j < numpages; j++)
1: 			{
0: 				t_util.t_checkFetch(page[0][j], rh[0][j], REC_001);
0: 				t_util.t_checkRecordCount(page[0][j], 1, 1);
1: 			}
0: 			t[0].resetContext();
1: 
0: 			//////////////////////// step 10 ////////////////////////
0: 			// unlatch all pages
0: 			for (i = 0; i < numtrans; i++)
1: 			{
0: 				t[i].switchTransactionContext();
0: 				for (j = 0; j < numpages; j++)
0: 					page[i][j].unlatch();
0: 				t[i].resetContext();
1: 			}
1: 
0: 			// t[0] incomplete
0: 			t_util.t_abort(t[1]);
0: 			t_util.t_commit(t[2]);
0: 			// t[3] incomplete
0: 			t_util.t_commit(t[4]);
1: 
0: 			// reopen containers 1, 2, and 4, where were closed when the
0: 			// transaction terminated.
0: 			c[1] = t_util.t_openContainer(t[1], 0, cid[1], false);
0: 			c[2] = t_util.t_openContainer(t[2], 0, cid[2], false);
0: 			c[4] = t_util.t_openContainer(t[4], 0, cid[4], false);
1: 
0: 			//////////////////////// check ////////////////////////
0: 			for (j = 0; j < numpages; j++)	
1: 			{
0: 				t[0].switchTransactionContext();
0: 				t_util.t_checkFetch(c[0], rh[0][j], REC_001);
0: 				t[0].resetContext();
1: 
0: 				// t[1] has been aborted
0: 				// rh[1][j] (REC_001) is deleted
0: 				t[1].switchTransactionContext();
0: 				page[1][j] = t_util.t_getPage(c[1], pagenum[1][j]);
0: 				t_util.t_checkRecordCount(page[1][j], 1, 0);
0: 				t_util.t_checkFetchBySlot(page[1][j], Page.FIRST_SLOT_NUMBER,
0: 								   REC_001, true, false);
0: 				page[1][j].unlatch();
0: 				t[1].resetContext();
1: 
0: 				t[2].switchTransactionContext();
0: 				t_util.t_checkFetch(c[2], rh[2][j], REC_006);
0: 				t[2].resetContext();
1: 
0: 				t[3].switchTransactionContext();
0: 				t_util.t_checkFetch(c[3], rh[3][j], REC_006);
0: 				t[3].resetContext();
1: 
0: 				t[4].switchTransactionContext();
0: 				t_util.t_checkFetch(c[4], rh[4][j], REC_006);
0: 				t[4].resetContext();
1: 			}
1: 
1: 
0: 			///////////////////////////////////////////////////////////
0: 			//// now write a 1/2 log record to the end of the log
0: 			//////////////////////////////////////////////////////////
0: 			t[3].switchTransactionContext();// this is going to be an
0: 											// incomplete transaction
1: 
0: 			// make a full page and then copy and purge it to another page
0: 			Page badPage1 = t_util.t_addPage(c[3]);
0: 			Page badPage2 = t_util.t_addPage(c[3]);
0: 			T_RawStoreRow row;
0: 			for (i = 0, row = new T_RawStoreRow("row at slot " + i);
0: 				 badPage1.spaceForInsert();
0: 				 i++, row = new T_RawStoreRow("row at slot " + i))
1: 			{
0: 				if (t_util.t_insertAtSlot(badPage1, i, row, Page.INSERT_UNDO_WITH_PURGE) == null)
0: 					break;
1: 			}
1: 
0: 			//////////////////////////////////////////////////////////
0: 			// writing 200 bytes of the log record to the end of the log - 
0: 			// NO MORE LOG RECORD SHOULD BE WRITTEN,
0: 			//////////////////////////////////////////////////////////
1: 			if(!checksumTest)
1: 			{
0: 				SanityManager.DEBUG_SET(LogToFile.TEST_LOG_INCOMPLETE_LOG_WRITE);
0: 				System.getProperties().put(LogToFile.TEST_LOG_PARTIAL_LOG_WRITE_NUM_BYTES, "200");
1: 			}
1: 			logFactory.flushAll();
1: 
1: 
0: 			// RESOLVE:
0: 			// copy and purge actually generates 2 log records, this is
0: 			// actually not a good operation to use for this test.  Just make
0: 			// sure the first log record is > 400 or else the log will be hosed
0: 			//
0: 			badPage1.copyAndPurge(badPage2, 0, i, 0);
1: 
0: 			t[3].resetContext();
1: 
1: 			if(checksumTest)
1: 				simulateLogFileCorruption();
1: 
0: 			////////////////////////////////////////////////////////
1: 
0: 			REPORT("badlog test3: numtrans " + numtrans + " numpages " + numpages);
1: 
0: 			for (i = 0; i < numtrans; i++)
1: 			{
0: 				register(key(3, i+10), cid[i]);
1: 
0: 				String str = "container " + i + ":" + find(key(3,i+10)) + " pages: ";
1: 
0: 				for (j = 0; j < numpages; j++)
1: 				{
0: 					str += pagenum[i][j] + " ";
0: 					register(key(3, (i+1)*1000+j), pagenum[i][j]);
1: 				}
0: 				REPORT("\t" + str);
1: 			}
1: 
0: 			register(key(3,1), numtrans); 
0: 			register(key(3,2), numpages);
0: 			register(key(3,3), badPage1.getPageNumber());
0: 			register(key(3,4), badPage2.getPageNumber());
1: 
1: 		}
0: 		finally
1: 		{
0: 			SanityManager.DEBUG_CLEAR(LogToFile.TEST_LOG_INCOMPLETE_LOG_WRITE);
1: 		}
1: 	}
1: 
1: 	/*
0: 	 * test recovery of test3
1: 	 */
0: 	void RTest3() throws T_Fail, StandardException
1: 	{
0: 		int numtrans = (int)find(key(3,1));
0: 		if (numtrans < 0)
1: 		{
0: 			REPORT("bad log test3 not run");
0: 			return;
1: 		}
1: 
0: 		int numpages = (int)find(key(3,2));
0: 		long badPagenum1 = find(key(3,3)); // these two pages are involved in
0: 										   // the 1/2 written log record, make
0: 										   // sure they are not corrupted
0: 		long badPagenum2 = find(key(3,4));
1: 
0: 		Transaction t = t_util.t_startTransaction();
1: 
0: 		long[] cid = new long[numtrans];
0: 		ContainerHandle[] c = new ContainerHandle[numtrans];
1: 
0: 		long[][] pagenum = new long[numtrans][numpages];
0: 		Page[][] page = new Page[numtrans][numpages];
1: 
0: 		int i,j;
1: 
0: 		for (i = 0; i < numtrans; i++)
1: 		{
0: 			cid[i] = find(key(3, i+10));
1: 
0: 			c[i] = t_util.t_openContainer(t, 0, cid[i], true);
1: 			
0: 			for (j = 0; j < numpages; j++)
1: 			{
0: 				pagenum[i][j] = find(key(3, (i+1)*1000+j));
1: 
0: 				page[i][j] = t_util.t_getPage(c[i], pagenum[i][j]);
1: 			}
1: 		}
1: 
0: 		// transactions were left in the following state
0: 		// t0 - incomplete (rolled back)
0: 		// t1 - abort
0: 		// t2 - commit
0: 		// t3 - incomplete (rolled back)
0: 		// t4 - commit
0: 		// any other transactions - incomplete
0: 		//
0: 		// all the rolled back transaction should have a deleted REC_001
0: 		// all the committed transactions should have a REC_006
0:                                                                            //
0: 		try 
1: 		{
0: 			for (j = 0; j < numpages; j++)
1: 			{
0: 				t_util.t_checkRecordCount(page[0][j], 1, 0);
0: 				t_util.t_checkFetchBySlot(page[0][j], Page.FIRST_SLOT_NUMBER,
0: 								   REC_001, true, true);
1: 
0: 				t_util.t_checkRecordCount(page[1][j], 1, 0);
0: 				t_util.t_checkFetchBySlot(page[1][j], Page.FIRST_SLOT_NUMBER,
0: 								   REC_001, true, true);
1: 
0: 				t_util.t_checkRecordCount(page[2][j], 1, 1);
0: 				t_util.t_checkFetchBySlot(page[2][j], Page.FIRST_SLOT_NUMBER,
0: 								   REC_006, false, true);
1: 
0: 				t_util.t_checkRecordCount(page[3][j], 1, 0);
0: 				t_util.t_checkFetchBySlot(page[3][j], Page.FIRST_SLOT_NUMBER,
0: 								   REC_001, true, true);
1: 
0: 				t_util.t_checkRecordCount(page[4][j], 1, 1);
0: 				t_util.t_checkFetchBySlot(page[4][j], Page.FIRST_SLOT_NUMBER,
0: 								   REC_006, false, true);
1: 			}
1: 
0: 			// now check the two bad pages - they are in c[3] and should be empty
0: 			Page badPage1 = t_util.t_getPage(c[3], badPagenum1);
0: 			Page badPage2 = t_util.t_getPage(c[3], badPagenum2);
0: 			t_util.t_checkRecordCount(badPage1, 0, 0);
0: 			t_util.t_checkRecordCount(badPage2, 0, 0);
1: 
0: 			REPORT("RTest3 passed: numtrans " + numtrans + " numpages " + numpages);
1: 
0: 			for (i = 0; i < numtrans; i++)
1: 			{
0: 				String str = "container " + i + ":" + cid[i] + " pages: ";
0: 				for (j = 0; j < numpages; j++)
0: 					str += pagenum[i][j] + " ";
0: 				REPORT("\t" + str);
1: 			}
1: 		}
0: 		finally
1: 		{
0: 			t_util.t_commit(t);
0: 			t.close();
1: 		}
1: 	}
1: 
1: 		
1: 	/*
0: 	 * test4 manufactures a log with the following recoverable 'defects':
0: 	 * - a log file that only has the partial log instance(7 bytes instead of 8
0: 	 * bytes writtne) of a log record written 
1: 	 */
0: 	protected void STest4() throws T_Fail, StandardException
1: 	{
0: 		Transaction t = t_util.t_startTransaction();
1: 
0: 		try
1: 		{
0: 			long cid = t_util.t_addContainer(t, 0);
0: 			ContainerHandle c = t_util.t_openContainer(t, 0, cid, true);
1: 
0: 			Page page = t_util.t_getPage(c, ContainerHandle.FIRST_PAGE_NUMBER);
1: 
0: 			// make a really big record - fill 80% of the page
0: 			int numcol = (int)((RawStoreFactory.PAGE_SIZE_MINIMUM*8)/(10*20));
1: 
0: 			T_RawStoreRow bigrow = new T_RawStoreRow(numcol);
0: 			String string1 = "01234567890123456789"; // 20 char string
0: 			for (int i = 0; i < numcol; i++)
0: 				bigrow.setColumn(i, string1);
1: 
0: 			// if overhead is > 80%, then reduce the row size until it fits
0: 			RecordHandle rh = null;
0: 			while(numcol > 0)
1: 			{
0: 				try {
0: 					rh = t_util.t_insert(page, bigrow);
0: 					break;
0: 				} catch (StandardException se) {
0: 					bigrow.setColumn(--numcol, (String) null);
1: 				}
1: 			}
0: 			if (numcol == 0)
0: 				throw T_Fail.testFailMsg("cannot fit any column into the page");
1: 
1: 			
1: 
0: 			t_util.t_commit(t);
1: 
0: 			// make a big log record - update row
0: 			String string2 = "abcdefghijklmnopqrst"; // 20 char string
0: 			for (int i = 0; i < numcol; i++)
0: 				bigrow.setColumn(i, string2);
1: 
0: 			c = t_util.t_openContainer(t, 0, cid, true);
0: 			page = t_util.t_getPage(c, ContainerHandle.FIRST_PAGE_NUMBER);
1: 
0: 			Page p2 = t_util.t_addPage(c);		// do something so we get the beginXact log
0: 								// record out of the way
0: 			t_util.t_insert(p2, new T_RawStoreRow(REC_001));
1: 
1: 
0: 			//////////////////////////////////////////////////////////
0: 			// writing approx 1/2 of log record  instance to the end of the log - 
0: 			// NO MORE LOG RECORD SHOULD BE WRITTEN,
0: 			// Length  4 bytes + 7(8) bytes of log record instance
0: 			//////////////////////////////////////////////////////////
1: 			if(!checksumTest)
1: 			{
0: 				SanityManager.DEBUG_SET(LogToFile.TEST_LOG_INCOMPLETE_LOG_WRITE);
0: 				System.getProperties().put(LogToFile.TEST_LOG_PARTIAL_LOG_WRITE_NUM_BYTES, Integer.toString(11));
1: 			}
1: 
1: 			logFactory.flushAll();
0: 			page.update(rh, bigrow.getRow(), (FormatableBitSet) null);
1: 
1: 			if(checksumTest)
1: 				simulateLogFileCorruption();
1: 
0: 			////////////////////////////////////////////////////////
1: 
0: 			REPORT("badlog test4: cid = " + cid + " numcol " + numcol);
1: 
0: 			register(key(4,1), cid);
0: 			register(key(4,2), numcol);
1: 		}
0: 		finally
1: 		{
0: 			SanityManager.DEBUG_CLEAR(LogToFile.TEST_LOG_INCOMPLETE_LOG_WRITE);
1: 		}
1: 	}
1: 
1: 	/*
0: 	 * test recovery of test 4
1: 	 */
0: 	void RTest4() throws T_Fail, StandardException
1: 	{
0: 		long cid = find(key(4, 1));
0: 		if (cid < 0)
1: 		{
0: 			REPORT("bad log test4 not run");
0: 			return;
1: 		}
0: 		int numcol = (int)find(key(4,2));
1: 
0: 		Transaction t = t_util.t_startTransaction();
0: 		try
1: 		{
0: 			ContainerHandle c = t_util.t_openContainer(t, 0, cid, true);
0: 			Page page = t_util.t_getPage(c, ContainerHandle.FIRST_PAGE_NUMBER);
1: 
0: 			int optimisticNumcol = (int)((RawStoreFactory.PAGE_SIZE_MINIMUM*8)/(10*20));
0: 			T_RawStoreRow bigrow = new T_RawStoreRow(optimisticNumcol);
0: 			for (int i = 0; i < optimisticNumcol; i++)
0: 				bigrow.setColumn(i, (String) null);
1: 
0: 			page.fetchFromSlot(
0:                 (RecordHandle) null, 0, bigrow.getRow(), 
0:                 (FetchDescriptor) null,
0:                 false);
1: 
0: 			Storable column;
0: 			String string1 = "01234567890123456789"; // the original 20 char string
1: 
0: 			for (int i = 0; i < numcol; i++)
1: 			{
0: 				column = bigrow.getStorableColumn(i);
0: 				if (!(column.toString().equals(string1)))
0: 					throw T_Fail.testFailMsg("Column " + i + " value incorrect, got :" + column.toString());
1: 			}
0: 			for (int i = numcol; i < optimisticNumcol; i++)
1: 			{
0: 				column = bigrow.getStorableColumn(i);
0: 				if (!column.isNull())
0: 					throw T_Fail.testFailMsg("Column " + i + 
0: 											 " expect Null, got : " + column.toString());
1: 			}
1: 
0: 			REPORT("RTest4 passed");
1: 
1: 		}
0: 		finally
1: 		{
0: 			t_util.t_commit(t);
0: 			t.close();
1: 		}
1: 	}
1: 	
1: 	/*
0: 	 * test5 manufactures a log with the following recoverable 'defects':
0: 	 * - a log file that only has the partial log record length (3 bytes instead of 4
0: 	 * bytes writtne) of a log record written in the beginning
1: 	 */
0: 	protected void STest5() throws T_Fail, StandardException
1: 	{
0: 		Transaction t = t_util.t_startTransaction();
1: 
0: 		try
1: 		{
0: 			long cid = t_util.t_addContainer(t, 0);
0: 			ContainerHandle c = t_util.t_openContainer(t, 0, cid, true);
1: 
0: 			Page page = t_util.t_getPage(c, ContainerHandle.FIRST_PAGE_NUMBER);
1: 
0: 			// make a really big record - fill 80% of the page
0: 			int numcol = (int)((RawStoreFactory.PAGE_SIZE_MINIMUM*8)/(10*20));
1: 
0: 			T_RawStoreRow bigrow = new T_RawStoreRow(numcol);
0: 			String string1 = "01234567890123456789"; // 20 char string
0: 			for (int i = 0; i < numcol; i++)
0: 				bigrow.setColumn(i, string1);
1: 
0: 			// if overhead is > 80%, then reduce the row size until it fits
0: 			RecordHandle rh = null;
0: 			while(numcol > 0)
1: 			{
0: 				try {
0: 					rh = t_util.t_insert(page, bigrow);
0: 					break;
0: 				} catch (StandardException se) {
0: 					bigrow.setColumn(--numcol, (String) null);
1: 				}
1: 			}
0: 			if (numcol == 0)
0: 				throw T_Fail.testFailMsg("cannot fit any column into the page");
1: 
1: 			
1: 
0: 			t_util.t_commit(t);
1: 
0: 			// make a big log record - update row
0: 			String string2 = "abcdefghijklmnopqrst"; // 20 char string
0: 			for (int i = 0; i < numcol; i++)
0: 				bigrow.setColumn(i, string2);
1: 
0: 			c = t_util.t_openContainer(t, 0, cid, true);
0: 			page = t_util.t_getPage(c, ContainerHandle.FIRST_PAGE_NUMBER);
1: 
0: 			Page p2 = t_util.t_addPage(c);		// do something so we get the beginXact log
0: 								// record out of the way
0: 			t_util.t_insert(p2, new T_RawStoreRow(REC_001));
1: 
1: 
0: 			//////////////////////////////////////////////////////////
0: 			// writing approx 3 bytes of log record to the end of the log - 
0: 			// NO MORE LOG RECORD SHOULD BE WRITTEN,
0: 			// Length  3 bytes (4) of log record length
0: 			//////////////////////////////////////////////////////////
1: 			if(!checksumTest)
1: 			{
0: 				SanityManager.DEBUG_SET(LogToFile.TEST_LOG_INCOMPLETE_LOG_WRITE);
0: 				System.getProperties().put(LogToFile.TEST_LOG_PARTIAL_LOG_WRITE_NUM_BYTES, Integer.toString(3));
1: 			}
1: 			logFactory.flushAll();
1: 
0: 			page.update(rh, bigrow.getRow(), (FormatableBitSet) null);
1: 
1: 			if(checksumTest)
1: 				simulateLogFileCorruption();
1: 
0: 			////////////////////////////////////////////////////////
1: 
0: 			REPORT("badlog test5: cid = " + cid + " numcol " + numcol);
1: 
0: 			register(key(5,1), cid);
0: 			register(key(5,2), numcol);
1: 		}
0: 		finally
1: 		{
0: 			SanityManager.DEBUG_CLEAR(LogToFile.TEST_LOG_INCOMPLETE_LOG_WRITE);
1: 		}
1: 	}
1: 
1: 	/*
0: 	 * test recovery of test 5
1: 	 */
0: 	void RTest5() throws T_Fail, StandardException
1: 	{
0: 		long cid = find(key(5, 1));
0: 		if (cid < 0)
1: 		{
0: 			REPORT("bad log test5 not run");
0: 			return;
1: 		}
0: 		int numcol = (int)find(key(5,2));
1: 
0: 		Transaction t = t_util.t_startTransaction();
0: 		try
1: 		{
0: 			ContainerHandle c = t_util.t_openContainer(t, 0, cid, true);
0: 			Page page = t_util.t_getPage(c, ContainerHandle.FIRST_PAGE_NUMBER);
1: 
0: 			int optimisticNumcol = (int)((RawStoreFactory.PAGE_SIZE_MINIMUM*8)/(10*20));
0: 			T_RawStoreRow bigrow = new T_RawStoreRow(optimisticNumcol);
0: 			for (int i = 0; i < optimisticNumcol; i++)
0: 				bigrow.setColumn(i, (String) null);
1: 
0: 			page.fetchFromSlot(
0:                 (RecordHandle) null, 0, bigrow.getRow(), 
0:                 (FetchDescriptor) null,
0:                 false);
1: 
0: 			Storable column;
0: 			String string1 = "01234567890123456789"; // the original 20 char string
1: 
0: 			for (int i = 0; i < numcol; i++)
1: 			{
0: 				column = bigrow.getStorableColumn(i);
0: 				if (!(column.toString().equals(string1)))
0: 					throw T_Fail.testFailMsg("Column " + i + " value incorrect, got :" + column.toString());
1: 			}
0: 			for (int i = numcol; i < optimisticNumcol; i++)
1: 			{
0: 				column = bigrow.getStorableColumn(i);
0: 				if (!column.isNull())
0: 					throw T_Fail.testFailMsg("Column " + i + 
0: 											 " expect Null, got : " + column.toString());
1: 			}
1: 
0: 			REPORT("RTest5 passed");
1: 
1: 		}
0: 		finally
1: 		{
0: 			t_util.t_commit(t);
0: 			t.close();
1: 		}
1: 	}
1: 		
1: 	/*
0: 	 * test6 manufactures a log with the following recoverable 'defects':
0: 	 * - a log file that only has the log record with partial data portion
0: 	 * written (approximately (1997/2 (data)+ 16(log records ov)))	 */
0: 	protected void STest6() throws T_Fail, StandardException
1: 	{
0: 		Transaction t = t_util.t_startTransaction();
1: 
0: 		try
1: 		{
0: 			long cid = t_util.t_addContainer(t, 0);
0: 			ContainerHandle c = t_util.t_openContainer(t, 0, cid, true);
1: 
0: 			Page page = t_util.t_getPage(c, ContainerHandle.FIRST_PAGE_NUMBER);
1: 
0: 			// make a really big record - fill 80% of the page
0: 			int numcol = (int)((RawStoreFactory.PAGE_SIZE_MINIMUM*8)/(10*20));
1: 
0: 			T_RawStoreRow bigrow = new T_RawStoreRow(numcol);
0: 			String string1 = "01234567890123456789"; // 20 char string
0: 			for (int i = 0; i < numcol; i++)
0: 				bigrow.setColumn(i, string1);
1: 
0: 			// if overhead is > 80%, then reduce the row size until it fits
0: 			RecordHandle rh = null;
0: 			while(numcol > 0)
1: 			{
0: 				try {
0: 					rh = t_util.t_insert(page, bigrow);
0: 					break;
0: 				} catch (StandardException se) {
0: 					bigrow.setColumn(--numcol, (String) null);
1: 				}
1: 			}
0: 			if (numcol == 0)
0: 				throw T_Fail.testFailMsg("cannot fit any column into the page");
1: 
1: 			
1: 
0: 			t_util.t_commit(t);
1: 
0: 			// make a big log record - update row
0: 			String string2 = "abcdefghijklmnopqrst"; // 20 char string
0: 			for (int i = 0; i < numcol; i++)
0: 				bigrow.setColumn(i, string2);
1: 
0: 			c = t_util.t_openContainer(t, 0, cid, true);
0: 			page = t_util.t_getPage(c, ContainerHandle.FIRST_PAGE_NUMBER);
1: 
0: 			Page p2 = t_util.t_addPage(c);		// do something so we get the beginXact log
0: 								// record out of the way
0: 			t_util.t_insert(p2, new T_RawStoreRow(REC_001));
1: 
1: 
0: 			//////////////////////////////////////////////////////////
0: 			// writing (1997/2 (data)+ 16(log records ov)) bytes of log record to the end of the log - 
0: 			// NO MORE LOG RECORD SHOULD BE WRITTEN,
0: 			//////////////////////////////////////////////////////////
1: 			if(!checksumTest)
1: 			{
0: 				SanityManager.DEBUG_SET(LogToFile.TEST_LOG_INCOMPLETE_LOG_WRITE);
0: 				System.getProperties().put(LogToFile.TEST_LOG_PARTIAL_LOG_WRITE_NUM_BYTES, Integer.toString((1997/2) + 16));
1: 			}
1: 			logFactory.flushAll();
0: 			page.update(rh, bigrow.getRow(), (FormatableBitSet) null);
1: 
1: 			if(checksumTest)
1: 				simulateLogFileCorruption();
1: 
0: 			////////////////////////////////////////////////////////
1: 
0: 			REPORT("badlog test6: cid = " + cid + " numcol " + numcol);
1: 
0: 			register(key(6,1), cid);
0: 			register(key(6,2), numcol);
1: 		}
0: 		finally
1: 		{
0: 			SanityManager.DEBUG_CLEAR(LogToFile.TEST_LOG_INCOMPLETE_LOG_WRITE);
1: 		}
1: 	}
1: 
1: 	/*
0: 	 * test recovery of test 6
1: 	 */
0: 	void RTest6() throws T_Fail, StandardException
1: 	{
0: 		long cid = find(key(6, 1));
0: 		if (cid < 0)
1: 		{
0: 			REPORT("bad log test6 not run");
0: 			return;
1: 		}
0: 		int numcol = (int)find(key(6,2));
1: 
0: 		Transaction t = t_util.t_startTransaction();
0: 		try
1: 		{
0: 			ContainerHandle c = t_util.t_openContainer(t, 0, cid, true);
0: 			Page page = t_util.t_getPage(c, ContainerHandle.FIRST_PAGE_NUMBER);
1: 
0: 			int optimisticNumcol = (int)((RawStoreFactory.PAGE_SIZE_MINIMUM*8)/(10*20));
0: 			T_RawStoreRow bigrow = new T_RawStoreRow(optimisticNumcol);
0: 			for (int i = 0; i < optimisticNumcol; i++)
0: 				bigrow.setColumn(i, (String) null);
1: 
0: 			page.fetchFromSlot(
0:                 (RecordHandle) null, 0, bigrow.getRow(), 
0:                 (FetchDescriptor) null,
0:                 false);
1: 
0: 			Storable column;
0: 			String string1 = "01234567890123456789"; // the original 20 char string
1: 
0: 			for (int i = 0; i < numcol; i++)
1: 			{
0: 				column = bigrow.getStorableColumn(i);
0: 				if (!(column.toString().equals(string1)))
0: 					throw T_Fail.testFailMsg("Column " + i + " value incorrect, got :" + column.toString());
1: 			}
0: 			for (int i = numcol; i < optimisticNumcol; i++)
1: 			{
0: 				column = bigrow.getStorableColumn(i);
0: 				if (!column.isNull())
0: 					throw T_Fail.testFailMsg("Column " + i + 
0: 											 " expect Null, got : " + column.toString());
1: 			}
1: 
0: 			REPORT("RTest6 passed");
1: 
1: 		}
0: 		finally
1: 		{
0: 			t_util.t_commit(t);
0: 			t.close();
1: 		}
1: 	}
1: 	/*
0: 	 * test7 manufactures a log with the following recoverable 'defects':
0: 	 * - a log file that has the last log record with partial end length
0: 	 * written( 3 of 4 bytes). instead of (1997(data) + 16 (log records overhead)) write (1997 + 15) 
1: 	 */
0: 	protected void STest7() throws T_Fail, StandardException
1: 	{
0: 		Transaction t = t_util.t_startTransaction();
1: 
0: 		try
1: 		{
0: 			long cid = t_util.t_addContainer(t, 0);
0: 			ContainerHandle c = t_util.t_openContainer(t, 0, cid, true);
1: 
0: 			Page page = t_util.t_getPage(c, ContainerHandle.FIRST_PAGE_NUMBER);
1: 
0: 			// make a really big record - fill 80% of the page
0: 			int numcol = (int)((RawStoreFactory.PAGE_SIZE_MINIMUM*8)/(10*20));
1: 
0: 			T_RawStoreRow bigrow = new T_RawStoreRow(numcol);
0: 			String string1 = "01234567890123456789"; // 20 char string
0: 			for (int i = 0; i < numcol; i++)
0: 				bigrow.setColumn(i, string1);
1: 
0: 			// if overhead is > 80%, then reduce the row size until it fits
0: 			RecordHandle rh = null;
0: 			while(numcol > 0)
1: 			{
0: 				try {
0: 					rh = t_util.t_insert(page, bigrow);
0: 					break;
0: 				} catch (StandardException se) {
0: 					bigrow.setColumn(--numcol, (String) null);
1: 				}
1: 			}
0: 			if (numcol == 0)
0: 				throw T_Fail.testFailMsg("cannot fit any column into the page");
1: 
1: 			
1: 
0: 			t_util.t_commit(t);
1: 
0: 			// make a big log record - update row
0: 			String string2 = "abcdefghijklmnopqrst"; // 20 char string
0: 			for (int i = 0; i < numcol; i++)
0: 				bigrow.setColumn(i, string2);
1: 
0: 			c = t_util.t_openContainer(t, 0, cid, true);
0: 			page = t_util.t_getPage(c, ContainerHandle.FIRST_PAGE_NUMBER);
1: 
0: 			Page p2 = t_util.t_addPage(c);		// do something so we get the beginXact log
0: 								// record out of the way
0: 			t_util.t_insert(p2, new T_RawStoreRow(REC_001));
1: 
1: 
0: 			//////////////////////////////////////////////////////////
0: 			// writing only 3 bytes of end length of the log record to the end of the log - 
0: 			//i.e: instead of (1997(data) + 16 (log records overhead)) write (1997 + 15) 
0: 			// NO MORE LOG RECORD SHOULD BE WRITTEN,
0: 			//////////////////////////////////////////////////////////
1: 			if(!checksumTest)
1: 			{
0: 				SanityManager.DEBUG_SET(LogToFile.TEST_LOG_INCOMPLETE_LOG_WRITE);
0: 				System.getProperties().put(LogToFile.TEST_LOG_PARTIAL_LOG_WRITE_NUM_BYTES, Integer.toString(1997+15));
1: 			}
1: 			logFactory.flushAll();
0: 			page.update(rh, bigrow.getRow(), (FormatableBitSet) null);
1: 
1: 			if(checksumTest)
1: 				simulateLogFileCorruption();
1: 
1: 
0: 			////////////////////////////////////////////////////////
1: 
0: 			REPORT("badlog test7: cid = " + cid + " numcol " + numcol);
1: 
0: 			register(key(7,1), cid);
0: 			register(key(7,2), numcol);
1: 		}
0: 		finally
1: 		{
0: 			SanityManager.DEBUG_CLEAR(LogToFile.TEST_LOG_INCOMPLETE_LOG_WRITE);
1: 		}
1: 	}
1: 
1: 	/*
0: 	 * test recovery of test 7
1: 	 */
0: 	void RTest7() throws T_Fail, StandardException
1: 	{
0: 		long cid = find(key(6, 1));
0: 		if (cid < 0)
1: 		{
0: 			REPORT("bad log test7 not run");
0: 			return;
1: 		}
0: 		int numcol = (int)find(key(6,2));
1: 
0: 		Transaction t = t_util.t_startTransaction();
0: 		try
1: 		{
0: 			ContainerHandle c = t_util.t_openContainer(t, 0, cid, true);
0: 			Page page = t_util.t_getPage(c, ContainerHandle.FIRST_PAGE_NUMBER);
1: 
0: 			int optimisticNumcol = (int)((RawStoreFactory.PAGE_SIZE_MINIMUM*8)/(10*20));
0: 			T_RawStoreRow bigrow = new T_RawStoreRow(optimisticNumcol);
0: 			for (int i = 0; i < optimisticNumcol; i++)
0: 				bigrow.setColumn(i, (String) null);
1: 
0: 			page.fetchFromSlot(
0:                 (RecordHandle) null, 0, bigrow.getRow(), 
0:                 (FetchDescriptor) null,
0:                 false);
1: 
0: 			Storable column;
0: 			String string1 = "01234567890123456789"; // the original 20 char string
1: 
0: 			for (int i = 0; i < numcol; i++)
1: 			{
0: 				column = bigrow.getStorableColumn(i);
0: 				if (!(column.toString().equals(string1)))
0: 					throw T_Fail.testFailMsg("Column " + i + " value incorrect, got :" + column.toString());
1: 			}
0: 			for (int i = numcol; i < optimisticNumcol; i++)
1: 			{
0: 				column = bigrow.getStorableColumn(i);
0: 				if (!column.isNull())
0: 					throw T_Fail.testFailMsg("Column " + i + 
0: 											 " expect Null, got : " + column.toString());
1: 			}
1: 
0: 			REPORT("RTest7 passed");
1: 
1: 		}
0: 		finally
1: 		{
0: 			t_util.t_commit(t);
0: 			t.close();
1: 		}
1: 	}
1: 
1: 
1: 
1: 	/*
1: 	 * simulate log corruption to test the checksuming of log records. 
1: 	 */
1: 	private void simulateLogFileCorruption() throws T_Fail, StandardException
1: 	{
1: 		long filenum;
1: 		long filepos;
1: 		long amountOfLogWritten;
1: 		LogCounter logInstant = (LogCounter)logFactory.getFirstUnflushedInstant();
1: 		filenum = logInstant.getLogFileNumber();
1: 		filepos = logInstant.getLogFilePosition();
1: 		logFactory.flushAll();
1: 		logInstant = (LogCounter)logFactory.getFirstUnflushedInstant();
1: 		filenum = logInstant.getLogFileNumber();
1: 		amountOfLogWritten = logInstant.getLogFilePosition() - filepos;
1: 
1: 		// write some random  garbage into the log file , 
1: 		// purpose of doing this is to test that recovery works correctly when 
1: 		// log records in the end of a log file did not get wrtten completely
1: 		// and in the correct order. 
1: 
1: 		try{
1: 			StorageRandomAccessFile log = logFactory.getLogFileToSimulateCorruption(filenum) ;
1: 		
1: 			int noWrites = (int) amountOfLogWritten / 512;
1: 			//mess up few bytes in every block of a 512 bytes.
1: 			filepos += 512;
1: 			java.util.Random r = new java.util.Random();
1: 			for(int i = 0 ; i < noWrites ; i++)
1: 			{
1: 				REPORT("corruptig log file : filenum " + filenum + " fileposition " + filepos);
1: 				log.seek(filepos);
1: 				log.writeInt(r.nextInt());
1: 				filepos +=512;
1: 
1: 			}
0: 			log.sync(false);
1: 			log.close();
1: 		}catch(IOException ie)
1: 		{
1: 			throw T_Fail.exceptionFail(ie);
1: 		}
1: 		
1: 	}
1: 
1: }
1: 
1: 
1: 
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:d609ee3
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Derby - Class org.apache.derbyTesting.unitTests.store.T_RecoverBadLog
0: 
0:    Copyright 1997, 2005 The Apache Software Foundation or its licensors, as applicable.
0: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
0: 
0:       http://www.apache.org/licenses/LICENSE-2.0
0: 
0:    Unless required by applicable law or agreed to in writing, software
0:    distributed under the License is distributed on an "AS IS" BASIS,
0:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:    See the License for the specific language governing permissions and
0:    limitations under the License.
0: 
0:  */
0: 
0: package org.apache.derbyTesting.unitTests.store;
0: 
0: import org.apache.derbyTesting.unitTests.harness.T_Generic;
0: import org.apache.derbyTesting.unitTests.harness.T_Fail;
0: import org.apache.derbyTesting.unitTests.harness.UnitTest;
0: 
0: import org.apache.derby.impl.store.raw.log.*;
0: 
0: import org.apache.derby.iapi.services.context.ContextService;
0: import org.apache.derby.iapi.services.context.ContextManager;
0: import org.apache.derby.iapi.services.daemon.DaemonService;
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: import org.apache.derby.iapi.services.locks.LockFactory;
0: import org.apache.derby.iapi.services.io.Storable;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.reference.Property;
0: import org.apache.derby.iapi.reference.EngineType;
0: import org.apache.derby.iapi.services.property.PropertyUtil;
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: import org.apache.derby.io.StorageRandomAccessFile;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.store.raw.*;
0: 
0: import org.apache.derby.iapi.store.access.conglomerate.LogicalUndo;
0: 
0: import org.apache.derby.iapi.store.access.Qualifier;
0: 
0: import java.io.IOException;
0: import java.io.RandomAccessFile;
0: import java.io.File;
0: import java.util.Properties;
0: 
0: 
0: 
0: /**
0: 	A implementation unit test for recovering log that has been damanged but salvagable.
0: 
0:     To run, create a derby.properties file in a new directory with the
0: 	contents
0: 
0: 	derby.module.test.recoverBadLog=org.apache.derbyTesting.unitTests.store.T_RecoverBadLog
0: 
0:     Execute in order
0: 
0: 	To Test Bad Log due to partial write that are identified by checking the
0: 	length in the beginning and end of the log record. 
0: 
0: 	java -DTestBadLogSetup=true org.apache.derbyTesting.unitTests.harness.UnitTestMain
0: 	java -DTestBadLog1=true org.apache.derbyTesting.unitTests.harness.UnitTestMain
0: 	java -DTestBadLog2=true org.apache.derbyTesting.unitTests.harness.UnitTestMain
0: 	java -DTestBadLog3=true org.apache.derbyTesting.unitTests.harness.UnitTestMain
0: 	java -DTestBadLog4=true org.apache.derbyTesting.unitTests.harness.UnitTestMain
0: 	java -DTestBadLog5=true org.apache.derbyTesting.unitTests.harness.UnitTestMain
0: 	java -DTestBadLog6=true org.apache.derbyTesting.unitTests.harness.UnitTestMain
0: 	java -DTestBadLog7=true org.apache.derbyTesting.unitTests.harness.UnitTestMain
0: 	java -DTestBadLog1=true org.apache.derbyTesting.unitTests.harness.UnitTestMain
0: 
0: 	To Test Bad Log due to an incomplete out of order write that is identified
0: 	by the checksum logic (simulated by	explicitly corrupting a middle of a 
0: 	log record at  the  end of log file after it is written).
0: 	
0: 	java -DTestBadLogSetup=true -DTestBadChecksumLog=true org.apache.derbyTesting.unitTests.harness.UnitTestMain
0: 	java -DTestBadLog1=true -DTestBadChecksumLog=true org.apache.derbyTesting.unitTests.harness.UnitTestMain
0: 	java -DTestBadLog2=true -DTestBadChecksumLog=true org.apache.derbyTesting.unitTests.harness.UnitTestMain
0: 	java -DTestBadLog3=true -DTestBadChecksumLog=true org.apache.derbyTesting.unitTests.harness.UnitTestMain
0: 	java -DTestBadLog4=true -DTestBadChecksumLog=true org.apache.derbyTesting.unitTests.harness.UnitTestMain
0: 	java -DTestBadLog5=true -DTestBadChecksumLog=true org.apache.derbyTesting.unitTests.harness.UnitTestMain
0: 	java -DTestBadLog6=true -DTestBadChecksumLog=true org.apache.derbyTesting.unitTests.harness.UnitTestMain
0: 	java -DTestBadLog7=true -DTestBadChecksumLog=true org.apache.derbyTesting.unitTests.harness.UnitTestMain
0: 	java -DTestBadLog1=true -DTestBadChecksumLog=true org.apache.derbyTesting.unitTests.harness.UnitTestMain
0: 	
0: 	
0: */
0: 
0: public class T_RecoverBadLog extends T_Generic {
0: 
0: 	private  String testService = "BadLogTest";
0: 
0: 	static final String REC_001 = "McLaren";
0: 	static final String REC_002 = "Ferrari";
0: 	static final String REC_003 = "Benetton";
0: 	static final String REC_004 = "Prost";
0: 	static final String REC_005 = "Tyrell";
0: 	static final String REC_006 = "Derby, Natscape, Goatscape, the popular names";
0: 	static final String REC_UNDO = "Lotus";
0: 
0: 	static final String SP1 = "savepoint1";
0: 	static final String SP2 = "savepoint2";
0: 
0: 	private RandomAccessFile infofile = null;
0: 
0: 	private boolean setup;
0: 	private boolean test1;
0: 	private boolean test2;
0: 	private boolean test3;
0: 	private boolean test4;
0: 	private boolean test5;
0: 	private boolean test6;
0: 	private boolean test7;
0: 	private boolean checksumTest; 
0: 	
0: 	private  String infoPath = "extinout/T_RecoverBadLog.info";
0: 
0: 	private static final String TEST_BADLOG_SETUP = "TestBadLogSetup";
0: 	private static final String TEST_BADLOG1 = "TestBadLog1";
0: 	private static final String TEST_BADLOG2 = "TestBadLog2";
0: 	private static final String TEST_BADLOG3 = "TestBadLog3";
0: 	private static final String TEST_BADLOG4 = "TestBadLog4";
0: 	private static final String TEST_BADLOG5 = "TestBadLog5";
0: 	private static final String TEST_BADLOG6 = "TestBadLog6";
0: 	private static final String TEST_BADLOG7 = "TestBadLog7";
0: 
0: 	private static final String TEST_BAD_CHECKSUM_LOG = "TestBadChecksumLog";
0: 
0: 	private static final String TEST_BADLOG_INFO = "TestBadLogInfo";
0: 	private static final String TEST_BADCHECKSUMLOG_INFO = "TestBadChecksumLogInfo";
0: 
0: 	RawStoreFactory	factory;
0: 	LockFactory  lf;
0: 	LogToFile   logFactory;
0: 	ContextService contextService;
0: 	T_Util t_util;
0: 
0: 	public T_RecoverBadLog() {
0: 		super();
0: 	}
0: 
0: 	/*
0: 	** Methods required by T_Generic
0: 	*/
0: 
0: 	public String getModuleToTestProtocolName() {
0: 		return RawStoreFactory.MODULE;
0: 	}
0: 
0: 	/**
0: 	*/
0: 	private void getConfig()
0: 	{
0: 		String param;
0: 
0: 		param = PropertyUtil.getSystemProperty(TEST_BADLOG_SETUP);
0: 		setup = Boolean.valueOf(param).booleanValue();
0: 
0: 		param = PropertyUtil.getSystemProperty(TEST_BADLOG1);
0: 		test1 = Boolean.valueOf(param).booleanValue();
0: 
0: 		param = PropertyUtil.getSystemProperty(TEST_BADLOG2);
0: 		test2 = Boolean.valueOf(param).booleanValue();
0: 
0: 		param = PropertyUtil.getSystemProperty(TEST_BADLOG3);
0: 		test3 = Boolean.valueOf(param).booleanValue();
0: 		
0: 		
0: 		param = PropertyUtil.getSystemProperty(TEST_BADLOG4);
0: 		test4 = Boolean.valueOf(param).booleanValue();
0: 		
0: 		param = PropertyUtil.getSystemProperty(TEST_BADLOG5);
0: 		test5 = Boolean.valueOf(param).booleanValue();
0: 
0: 		param = PropertyUtil.getSystemProperty(TEST_BADLOG6);
0: 		test6 = Boolean.valueOf(param).booleanValue();
0: 
0: 		param = PropertyUtil.getSystemProperty(TEST_BADLOG7);
0: 		test7 = Boolean.valueOf(param).booleanValue();
0: 		
0: 		param = PropertyUtil.getSystemProperty(TEST_BAD_CHECKSUM_LOG);
0: 		checksumTest = Boolean.valueOf(param).booleanValue();
0: 		
0: 		if(checksumTest)
0: 		{
0: 			infoPath = "extinout/T_RecoverBadChecksumLog.info";
0: 			testService = "BadChecksumLogTest";
0: 		}
0: 	}
0: 
0: 
0: 	/**
0: 	    See T_Recovery for the general testing frame work
0: 
0: 		@exception T_Fail Unexpected behaviour from the API
0: 	 */
0: 	public void runTests() throws T_Fail {
0: 
0: 		getConfig();
0: 		int tests = 0;
0: 		if (setup) tests++;
0: 		if (test1) tests++;
0: 		if (test2) tests++;
0: 		if (test3) tests++;
0: 		if (test4) tests++;
0: 		if (test5) tests++;
0: 		if (test6) tests++;
0: 		if (test7) tests++;
0: 		
0: 		if (tests != 1)
0: 			throw T_Fail.testFailMsg("One & only one of the bad log recovery test should be run");
0: 
0: 		if (!SanityManager.DEBUG)
0: 		{
0: 			REPORT("recoverBadLog cannot be run on an insane server");
0: 			return;
0: 		}
0: 
0: 		try {
0: 			contextService = ContextService.getFactory();
0: 
0: 			File ifile = new File(infoPath);
0: 
0: 			//
0: 			// no checkpoint log record in any of the log files - unless this value
0: 			// is reset. LogToFile.TEST_LOG_SWITCH_LOG
0: 			// this will cause recovery to switch log without checkpointing
0: 			//
0: 			SanityManager.DEBUG_SET(LogToFile.TEST_LOG_SWITCH_LOG);
0: 
0: 			// don't want background checkpoint process to be running
0: 			SanityManager.DEBUG_SET(DaemonService.DaemonOff);
0: 
0: 			// see if we are testing encryption
0: 			startParams = T_Util.setEncryptionParam(startParams);
0: 
0: 			if (setup)				// the first test cleans up and start from fresh
0: 			{
0: 				// remove the service directory to ensure a clean run
0: 				REPORT("_______________________________________________________");
0: 				REPORT("\n\t\tcleaning up database for recovering from bad logs");
0: 				REPORT("_______________________________________________________");
0: 
0: 				// don't automatic boot this service if it gets left around
0: 				if (startParams == null) 
0: 					startParams = new Properties();
0: 				
0: 				startParams.put(Property.NO_AUTO_BOOT, Boolean.TRUE.toString());
0: 				// remove the service directory to ensure a clean run
0: 				startParams.put(Property.DELETE_ON_CREATE, Boolean.TRUE.toString());
0: 
0: 				factory = (RawStoreFactory) Monitor.createPersistentService(getModuleToTestProtocolName(),
0: 															  testService,
0: 															  startParams);
0: 				// create a database with nothing
0: 
0: 				// delete the info file
0: 				if (ifile.exists())
0: 					ifile.delete();
0: 
0: 				return;				// don't run anything now
0: 
0: 			}
0: 			else					// not setup, recover it
0: 			{
0: 				REPORT("_______________________________________________________");
0: 				
0: 				String message = "\n\t\tRunning bad log test ";
0: 				if (checksumTest)
0: 					message = "\n\t\tRunning bad checksum log test ";
0: 				if (test1)
0: 					REPORT(message + " 1");
0: 				if (test2)
0: 					REPORT(message + " 2");
0: 				if (test3)
0: 					REPORT(message + " 3");
0: 				if (test4)
0: 					REPORT(message + " 4");
0: 				if (test5)
0: 					REPORT(message + " 5");
0: 				if (test6)
0: 					REPORT(message + " 6");
0: 				if (test7)
0: 					REPORT(message + " 7");
0: 
0: 				REPORT("_______________________________________________________");
0: 
0: 				//if external input output files does not exist ,create one
0: 				File ifdir = new File("extinout");
0: 				if(!ifdir.exists())
0: 					ifdir.mkdirs();
0: 
0: 				try
0: 				{
0: 					// make sure it does exist
0: 					infofile = new RandomAccessFile(ifile, "rw");
0: 				}
0: 				catch (IOException ioe)
0: 				{
0: 					System.out.println("Cannot write to temporary file " +
0: 									   infoPath + 
0: 									   ".  Please make sure it is correct, if not, please set the property " +
0: 									   "TestBadLogInfo=<where temp files should go>");
0: 					
0: 					throw T_Fail.exceptionFail(ioe);
0: 				}
0: 
0: 				if (!Monitor.startPersistentService(testService, startParams))
0: 					throw T_Fail.testFailMsg("Monitor didn't know how to restart service: " + testService);
0: 
0: 				factory = (RawStoreFactory) Monitor.findService(getModuleToTestProtocolName(), testService);
0: 				logFactory =(LogToFile) Monitor.findServiceModule(factory, factory.getLogFactoryModule());
0: 				
0: 			}
0: 		} catch (StandardException mse) {
0: 			throw T_Fail.exceptionFail(mse);
0: 		}
0: 
0: 		if (factory == null) {
0: 			throw T_Fail.testFailMsg(getModuleToTestProtocolName() + " service not started.");
0: 		}
0: 			
0: 		lf = factory.getLockFactory();
0: 		if (lf == null) {
0: 			throw T_Fail.testFailMsg("LockFactory.MODULE not found");
0: 		}
0: 
0: 		// get a utility helper
0: 		t_util = new T_Util(factory, lf, contextService);
0: 
0: 		try {
0: 			
0: 
0: 			// these tests can be run in any order
0: 			RTest1();
0: 			RTest2();
0: 			RTest3();
0: 			RTest4();
0: 			RTest5();
0: 			RTest6();
0: 			RTest7();
0: 
0: 			if (test1)
0: 				STest1();
0: 
0: 			if (test2)
0: 				STest2();
0: 				
0: 			if (test3)
0: 				STest3();
0: 						
0: 			if (test4)
0: 				STest4();
0: 
0: 			if(test5) 
0: 				STest5();
0: 
0: 			if(test6) 
0: 				STest6();
0: 
0: 			if(test7) 
0: 				STest7();
0: 
0: 			if (infofile != null)
0: 				infofile.close();
0: 
0: 		} catch (StandardException se) {
0: 
0: 			throw T_Fail.exceptionFail(se);
0: 		}
0: 		catch (IOException ioe)
0: 		{
0: 			throw T_Fail.exceptionFail(ioe);
0: 		}
0: 	}
0: 
0: 	private long find(long inkey)
0: 	{
0: 		if (infofile == null)
0: 			return -1;
0: 
0: 		try 
0: 		{
0: 			infofile.seek(0);
0: 			long key;
0: 
0: 			while(true)
0: 			{
0: 				key = infofile.readLong();
0: 				if (key == inkey)
0: 				{
0: 					long value = infofile.readLong();
0: 					// System.out.println("found " + key + " " + value);
0: 					return value;
0: 				}
0: 				infofile.readLong();
0: 			}
0: 		} 
0: 		catch (IOException ioe)
0: 		{
0: 			// System.out.println("key not found " + inkey);
0: 			return -1;
0: 		}
0: 
0: 	}
0: 
0: 	private long key(int test, int param)
0: 	{
0: 		long i = test;
0: 		return ((i << 32) + param);
0: 	}
0: 
0: 	private void register(long key, long value)
0: 		 throws T_Fail
0: 	{
0: 		// System.out.println("registering " + key + " " + value);
0: 		try 
0: 		{
0: 			// go to the end
0: 			infofile.seek(infofile.length());
0: 			infofile.writeLong(key);
0: 			infofile.writeLong(value);
0: 		}
0: 		catch (IOException ioe)
0: 		{
0: 			T_Fail.exceptionFail(ioe);
0: 		}
0: 	}
0: 
0: 
0: 	/*
0: 	 * test1 manufactures a log with the following recoverable 'defects':
0: 	 *		- a log file that only have a single large 1/2 written log record
0: 	 */
0: 	protected void STest1() throws T_Fail, StandardException
0: 	{
0: 		Transaction t = t_util.t_startTransaction();
0: 
0: 		///////////////////////////////////////////
0: 		//// log switch without checkpoint here ///
0: 		///////////////////////////////////////////
0: 		factory.checkpoint();
0: 
0: 		try
0: 		{
0: 			long cid = t_util.t_addContainer(t, 0);
0: 			ContainerHandle c = t_util.t_openContainer(t, 0, cid, true);
0: 
0: 			Page page = t_util.t_getPage(c, ContainerHandle.FIRST_PAGE_NUMBER);
0: 
0: 			// make a really big record - fill 80% of the page
0: 			int numcol = (int)((RawStoreFactory.PAGE_SIZE_MINIMUM*8)/(10*20));
0: 
0: 			T_RawStoreRow bigrow = new T_RawStoreRow(numcol);
0: 			String string1 = "01234567890123456789"; // 20 char string
0: 			for (int i = 0; i < numcol; i++)
0: 				bigrow.setColumn(i, string1);
0: 
0: 			// if overhead is > 80%, then reduce the row size until it fits
0: 			RecordHandle rh = null;
0: 			while(numcol > 0)
0: 			{
0: 				try {
0: 					rh = t_util.t_insert(page, bigrow);
0: 					break;
0: 				} catch (StandardException se) {
0: 					bigrow.setColumn(--numcol, (String) null);
0: 				}
0: 			}
0: 			if (numcol == 0)
0: 				throw T_Fail.testFailMsg("cannot fit any column into the page");
0: 
0: 			
0: 
0: 			t_util.t_commit(t);
0: 
0: 			// make a big log record - update row
0: 			String string2 = "abcdefghijklmnopqrst"; // 20 char string
0: 			for (int i = 0; i < numcol; i++)
0: 				bigrow.setColumn(i, string2);
0: 
0: 			c = t_util.t_openContainer(t, 0, cid, true);
0: 			page = t_util.t_getPage(c, ContainerHandle.FIRST_PAGE_NUMBER);
0: 
0: 			Page p2 = t_util.t_addPage(c);		// do something so we get the beginXact log
0: 								// record out of the way
0: 			t_util.t_insert(p2, new T_RawStoreRow(REC_001));
0: 
0: 
0: 			///////////////////////////////////////////
0: 			//// log switch without checkpoint here ///
0: 			///////////////////////////////////////////
0: 			factory.checkpoint();
0: 
0: 			//////////////////////////////////////////////////////////
0: 			// writing approx 1/2 log record to the end of the log - 
0: 			// NO MORE LOG RECORD SHOULD BE WRITTEN,
0: 			//////////////////////////////////////////////////////////
0: 			if(!checksumTest)
0: 			{
0: 				SanityManager.DEBUG_SET(LogToFile.TEST_LOG_INCOMPLETE_LOG_WRITE);
0: 				System.getProperties().put(LogToFile.TEST_LOG_PARTIAL_LOG_WRITE_NUM_BYTES, Integer.toString(numcol*20));
0: 			}
0: 			
0: 			logFactory.flushAll();
0: 
0: 			page.update(rh, bigrow.getRow(), (FormatableBitSet) null);
0: 
0: 			if(checksumTest)
0: 				simulateLogFileCorruption();
0: 
0: 			////////////////////////////////////////////////////////
0: 
0: 			REPORT("badlog test1: cid = " + cid + " numcol " + numcol);
0: 
0: 			register(key(1,1), cid);
0: 			register(key(1,2), numcol);
0: 		}
0: 		finally
0: 		{
0: 			SanityManager.DEBUG_CLEAR(LogToFile.TEST_LOG_INCOMPLETE_LOG_WRITE);
0: 		}
0: 	}
0: 
0: 	/*
0: 	 * test recovery of test 1
0: 	 */
0: 	void RTest1() throws T_Fail, StandardException
0: 	{
0: 		long cid = find(key(1, 1));
0: 		if (cid < 0)
0: 		{
0: 			REPORT("bad log test1 not run");
0: 			return;
0: 		}
0: 		int numcol = (int)find(key(1,2));
0: 
0: 		Transaction t = t_util.t_startTransaction();
0: 		try
0: 		{
0: 			ContainerHandle c = t_util.t_openContainer(t, 0, cid, true);
0: 			Page page = t_util.t_getPage(c, ContainerHandle.FIRST_PAGE_NUMBER);
0: 
0: 			int optimisticNumcol = (int)((RawStoreFactory.PAGE_SIZE_MINIMUM*8)/(10*20));
0: 			T_RawStoreRow bigrow = new T_RawStoreRow(optimisticNumcol);
0: 			for (int i = 0; i < optimisticNumcol; i++)
0: 				bigrow.setColumn(i, (String) null);
0: 
0: 			page.fetchFromSlot(
0:                 (RecordHandle) null, 0, bigrow.getRow(), 
0:                 (FetchDescriptor) null,
0:                 false);
0: 
0: 			Storable column;
0: 			String string1 = "01234567890123456789"; // the original 20 char string
0: 
0: 			for (int i = 0; i < numcol; i++)
0: 			{
0: 				column = bigrow.getStorableColumn(i);
0: 				if (!(column.toString().equals(string1)))
0: 					throw T_Fail.testFailMsg("Column " + i + " value incorrect, got :" + column.toString());
0: 			}
0: 			for (int i = numcol; i < optimisticNumcol; i++)
0: 			{
0: 				column = bigrow.getStorableColumn(i);
0: 				if (!column.isNull())
0: 					throw T_Fail.testFailMsg("Column " + i + 
0: 											 " expect Null, got : " + column.toString());
0: 			}
0: 
0: 			REPORT("RTest1 passed");
0: 
0: 		}
0: 		finally
0: 		{
0: 			t_util.t_commit(t);
0: 			t.close();
0: 		}
0: 	}
0: 
0: 	/*
0: 	 * test2 manufactures a log with the following recoverable 'defects':
0: 	 *		- a log file that ends with a large 1/2 written log record
0: 	 */
0: 	protected void STest2() throws T_Fail, StandardException
0: 	{
0: 		Transaction t = t_util.t_startTransaction();
0: 
0: 		try
0: 		{
0: 			long cid = t_util.t_addContainer(t, 0);
0: 			ContainerHandle c = t_util.t_openContainer(t, 0, cid, true);
0: 
0: 			Page page = t_util.t_getPage(c, ContainerHandle.FIRST_PAGE_NUMBER);
0: 
0: 			// make a really big record - fill 80% of the page with 20 bytes row
0: 			int numcol = (int)((RawStoreFactory.PAGE_SIZE_MINIMUM*8)/(10*20));
0: 
0: 			T_RawStoreRow bigrow = new T_RawStoreRow(numcol);
0: 			String string1 = "01234567890123456789"; // 20 char string
0: 			for (int i = 0; i < numcol; i++)
0: 				bigrow.setColumn(i, string1);
0: 
0: 			// if overhead is > 80%, then reduce the row size until it fits
0: 			RecordHandle rh = null;
0: 			while(numcol > 0)
0: 			{
0: 				try {
0: 					rh = t_util.t_insert(page, bigrow);
0: 					break;
0: 				} catch (StandardException se) {
0: 					bigrow.setColumn(--numcol, (String) null);
0: 				}
0: 			}
0: 			if (numcol == 0)
0: 				throw T_Fail.testFailMsg("cannot fit any column into the page");
0: 
0: 			rh = t_util.t_insert(page, bigrow);
0: 
0: 			t_util.t_commit(t);
0: 
0: 			// make a big log record - update row
0: 			String string2 = "abcdefghijklmnopqrst"; // 20 char string
0: 			for (int i = 0; i < numcol; i++)
0: 				bigrow.setColumn(i, string2);
0: 
0: 			c = t_util.t_openContainer(t, 0, cid, true);
0: 			page = t_util.t_getPage(c, ContainerHandle.FIRST_PAGE_NUMBER);
0: 
0: 			//////////////////////////////////////////////////////////
0: 			// writing approx 1/2 log record to the end of the log - 
0: 			// NO MORE LOG RECORD SHOULD BE WRITTEN,
0: 			//////////////////////////////////////////////////////////
0: 			if(!checksumTest)
0: 			{
0: 				SanityManager.DEBUG_SET(LogToFile.TEST_LOG_INCOMPLETE_LOG_WRITE);
0: 				System.getProperties().put(LogToFile.TEST_LOG_PARTIAL_LOG_WRITE_NUM_BYTES,Integer.toString(numcol*20));
0: 			}
0: 
0: 			logFactory.flushAll();
0: 			page.update(rh, bigrow.getRow(), (FormatableBitSet) null);
0: 			
0: 			if(checksumTest)
0: 				simulateLogFileCorruption();
0: 
0: 			////////////////////////////////////////////////////////
0: 
0: 			REPORT("badlog test2: cid = " + cid + " numcol " + numcol);
0: 
0: 			register(key(2,1), cid);
0: 			register(key(2,2), numcol);
0: 		}
0: 		finally
0: 		{
0: 			SanityManager.DEBUG_CLEAR(LogToFile.TEST_LOG_INCOMPLETE_LOG_WRITE);
0: 		}
0: 	}
0: 
0: 	/*
0: 	 * test recovery of test 2
0: 	 */
0: 	void RTest2() throws T_Fail, StandardException
0: 	{
0: 		long cid = find(key(2, 1));
0: 		if (cid < 0)
0: 		{
0: 			REPORT("bad log test2 not run");
0: 			return;
0: 		}
0: 		int numcol = (int)find(key(2,2));
0: 
0: 		Transaction t = t_util.t_startTransaction();
0: 		try
0: 		{
0: 			ContainerHandle c = t_util.t_openContainer(t, 0, cid, true);
0: 			Page page = t_util.t_getPage(c, ContainerHandle.FIRST_PAGE_NUMBER);
0: 
0: 			int optimisticNumcol = (int)((RawStoreFactory.PAGE_SIZE_MINIMUM*8)/(10*20));
0: 			T_RawStoreRow bigrow = new T_RawStoreRow(optimisticNumcol);
0: 			for (int i = 0; i < optimisticNumcol; i++)
0: 				bigrow.setColumn(i, (String) null);
0: 
0: 			page.fetchFromSlot(
0:                 (RecordHandle) null, 0, bigrow.getRow(), 
0:                 (FetchDescriptor) null,
0:                 false);
0: 			Storable column;
0: 			String string1 = "01234567890123456789"; // the original 20 char string
0: 
0: 			for (int i = 0; i < numcol; i++)
0: 			{
0: 				column = bigrow.getStorableColumn(i);
0: 				if (!(column.toString().equals(string1)))
0: 					throw T_Fail.testFailMsg("Column " + i + " value incorrect, got :" + column.toString());
0: 			}
0: 			for (int i = numcol; i < optimisticNumcol; i++)
0: 			{
0: 				column = bigrow.getStorableColumn(i);
0: 				if (!column.isNull())
0: 					throw T_Fail.testFailMsg("Column " + i + 
0: 											 " expect Null, got : " + column.toString());
0: 			}
0: 
0: 			REPORT("RTest2 passed");
0: 
0: 		}
0: 		finally
0: 		{
0: 			t_util.t_commit(t);
0: 			t.close();
0: 		}
0: 	}
0: 
0: 
0: 
0: 	/*
0: 	 * test3 manufactures a log with the following recoverable 'defects':
0: 	 *    - a log with multiple files but no checkpoint log record
0: 	 *	  - a last log file with a paritally written log record at the end
0: 	 */
0: 	protected void STest3() throws T_Fail, StandardException
0: 	{
0: 		int numtrans = 7;
0: 		int numpages = 7;
0: 		int i,j;
0: 
0: 		// this is basically T_Recovery S203 with a couple of log switches
0: 		try
0: 		{
0: 			T_TWC[] t = new T_TWC[numtrans];
0: 			for (i = 0; i < numtrans; i++)
0: 				t[i] =  t_util.t_startTransactionWithContext();
0: 
0: 			long[] cid = new long[numtrans];
0: 			ContainerHandle[] c = new ContainerHandle[numtrans];
0: 
0: 			for (i = 0; i < numtrans; i++)
0: 			{
0: 				cid[i] = t_util.t_addContainer(t[i], 0);
0: 				t_util.t_commit(t[i]);
0: 				c[i] = t_util.t_openContainer(t[i], 0, cid[i], true);
0: 			}
0: 
0: 			Page page[][] = new Page[numtrans][numpages];
0: 			long pagenum[][] = new long[numtrans][numpages];
0: 
0: 			for (i = 0; i < numtrans; i++)
0: 			{
0: 				for (j = 0; j < numpages; j++)
0: 				{
0: 					t[i].switchTransactionContext();
0: 					page[i][j] = t_util.t_addPage(c[i]);
0: 					pagenum[i][j] = page[i][j].getPageNumber();
0: 					t[i].resetContext();
0: 				}
0: 			}
0: 
0: 			// set up numtrans (at least 5) transactions, each with one
0: 			// container and numpages pages.  Do the following test:
0: 			//
0: 			// 1) insert 1 row onto each page
0: 			// set savepoint SP1 on first transaction (t0)
0: 			//
0: 			// 2) update every rows
0: 			// set savepoint SP1 on all other transactions
0: 			//
0: 			// 3) update every rows
0: 			// set savepoint SP2 on all transactions
0: 			// 
0: 			// 4) update every rows
0: 			//
0: 			// 5) rollback t0 to SP1
0: 			//
0: 			// check that only page[0][x] have been rolled back
0: 			// past SP2
0: 			//
0: 			// 6) update every row
0: 			// 7) rollback SP2 on all transaction except the first
0: 			// 
0: 			// 8) update every rows
0: 			// 9) rollback t0 to SP1
0: 			//
0: 			// 10) leave transactions in the following state
0: 			// t0 - incomplete
0: 			// t1 - abort
0: 			// t2 - commit
0: 			// t3 - incomplete
0: 			// t4 - commit
0: 			// any other transactions - incomplete
0: 
0: 
0: 			//////////////////////// step 1 ////////////////////////
0: 			RecordHandle[][] rh = new RecordHandle[numtrans][numpages];
0: 			T_RawStoreRow row1 = new T_RawStoreRow(REC_001);
0: 			for (i = 0; i < numtrans; i++)
0: 				for (j = 0; j < numpages; j++)
0: 				{
0: 					t[i].switchTransactionContext();
0: 					rh[i][j] = t_util.t_insert(page[i][j], row1); 
0: 					t[i].resetContext();
0: 				}
0: 
0: 			t[0].setSavePoint(SP1, null);	// sp1
0: 
0: 			//////////////////////// step 2 ////////////////////////
0: 			T_RawStoreRow row2 = new T_RawStoreRow(REC_002);
0: 			for (i = 0; i < numtrans; i++)
0: 				for (j = 0; j < numpages; j++)
0: 				{
0: 					t[i].switchTransactionContext();
0: 					page[i][j].update(rh[i][j], row2.getRow(), (FormatableBitSet) null);
0: 					t[i].resetContext();
0: 				}
0: 
0: 			for (i = 1; i < numtrans; i++) // sp1
0: 			{
0: 				t[i].setSavePoint(SP1, null);
0: 			}
0: 
0: 			///////////////////////////////////////////
0: 			//// log switch without checkpoint here ///
0: 			///////////////////////////////////////////
0: 			factory.checkpoint();
0: 
0: 
0: 			//////////////////////// step 3 ////////////////////////
0: 			T_RawStoreRow row3 = new T_RawStoreRow(REC_003);
0: 			for (i = 0; i < numtrans; i++)
0: 				for (j = 0; j < numpages; j++)
0: 					page[i][j].update(rh[i][j], row3.getRow(), (FormatableBitSet) null);
0: 
0: 			for (i = 0; i < numtrans; i++)
0: 				t[i].setSavePoint(SP2, null);	// sp2
0: 
0: 			//////////////////////// step 4 ////////////////////////
0: 			T_RawStoreRow row4 = new T_RawStoreRow(REC_004);
0: 			for (i = 0; i < numtrans; i++)
0: 			{
0: 				t[i].switchTransactionContext();
0: 
0: 				for (j = 0; j < numpages; j++)
0: 					page[i][j].update(rh[i][j], row4.getRow(), (FormatableBitSet) null);
0: 				t[i].resetContext();
0: 			}
0: 
0: 
0: 			//////////////////////// step 5 ////////////////////////
0: 			// unlatch relavante pages
0: 			t[0].switchTransactionContext();
0: 
0: 			for (j = 0; j < numpages; j++)
0: 				page[0][j].unlatch();
0: 
0: 			t[0].rollbackToSavePoint(SP1, null); // step 5
0: 
0: 			// relatch relavante pages
0: 			for (j = 0; j < numpages; j++)
0: 				page[0][j] = t_util.t_getPage(c[0], pagenum[0][j]);
0: 
0: 			t[0].resetContext();
0: 
0: 			///////////////////////////////////////////
0: 			//// log switch without checkpoint here ///
0: 			///////////////////////////////////////////
0: 			factory.checkpoint();
0: 
0: 
0: 			//////////////////////// check ////////////////////////
0: 			for (i = 1; i < numtrans; i++)
0: 			{
0: 				t[i].switchTransactionContext();
0: 				for (j = 0; j < numpages; j++)
0: 					t_util.t_checkFetch(page[i][j], rh[i][j], REC_004);
0: 				t[i].resetContext();
0: 			}
0: 
0: 			t[0].switchTransactionContext();
0: 			for (j = 0; j < numpages; j++)
0: 				t_util.t_checkFetch(page[0][j], rh[0][j], REC_001);
0: 			t[0].resetContext();
0: 
0: 			//////////////////////// step 6 ////////////////////////
0: 			T_RawStoreRow row5 = new T_RawStoreRow(REC_005);
0: 			for (i = 0; i < numtrans; i++)
0: 			{
0: 				t[i].switchTransactionContext();
0: 				for (j = 0; j < numpages; j++)
0: 					page[i][j].update(rh[i][j], row5.getRow(), (FormatableBitSet) null);
0: 				t[i].resetContext();
0: 			}
0: 
0: 			//////////////////////// step 7 ////////////////////////
0: 			for (i = 1; i < numtrans; i++)
0: 			{
0: 				t[i].switchTransactionContext();
0: 
0: 				for (j = 0; j < numpages; j++)
0: 					page[i][j].unlatch();
0: 
0: 				t[i].rollbackToSavePoint(SP2, null);
0: 
0: 				for (j = 0; j < numpages; j++)
0: 					page[i][j] = t_util.t_getPage(c[i],pagenum[i][j]);
0: 				t[i].resetContext();
0: 			}
0: 
0: 			//////////////////////// check ////////////////////////
0: 			for (i = 1; i < numtrans; i++)
0: 			{
0: 				t[i].switchTransactionContext();
0: 				for (j = 0; j < numpages; j++)
0: 					t_util.t_checkFetch(page[i][j], rh[i][j], REC_003);
0: 				t[i].resetContext();
0: 			}
0: 
0: 			t[0].switchTransactionContext();
0: 			for (j = 0; j < numpages; j++)
0: 				t_util.t_checkFetch(page[0][j], rh[0][j], REC_005);
0: 
0: 			t[0].resetContext();
0: 
0: 			///////////////////////////////////////////
0: 			//// log switch without checkpoint here ///
0: 			///////////////////////////////////////////
0: 			factory.checkpoint();
0: 
0: 
0: 			//////////////////////// step 8 ////////////////////////
0: 			T_RawStoreRow row6 = new T_RawStoreRow(REC_006);
0: 			for (i = 0; i < numtrans; i++)
0: 			{
0: 				t[i].switchTransactionContext();
0: 				for (j = 0; j < numpages; j++)
0: 					page[i][j].update(rh[i][j], row6.getRow(), (FormatableBitSet) null); // step 8
0: 				t[i].resetContext();
0: 			}
0: 
0: 			//////////////////////// step 9 ////////////////////////
0: 			// unlatch relavante pages
0: 			t[0].switchTransactionContext();
0: 			for (j = 0; j < numpages; j++)
0: 				page[0][j].unlatch();
0: 
0: 			t[0].rollbackToSavePoint(SP1, null); 
0: 
0: 			// relatch relevant pages
0: 			for (j = 0; j < numpages; j++)
0: 				page[0][j] = t_util.t_getPage(c[0], pagenum[0][j]);
0: 
0: 			t[0].resetContext();
0: 			//////////////////////// check ////////////////////////
0: 			for (i = 1; i < numtrans; i++)
0: 			{
0: 				t[i].switchTransactionContext();
0: 
0: 				for (j = 0; j < numpages; j++)
0: 				{
0: 					t_util.t_checkFetch(page[i][j], rh[i][j], REC_006);
0: 					t_util.t_checkRecordCount(page[i][j], 1, 1);
0: 				}
0: 				t[i].resetContext();
0: 			}
0: 
0: 			t[0].switchTransactionContext();
0: 			for (j = 0; j < numpages; j++)
0: 			{
0: 				t_util.t_checkFetch(page[0][j], rh[0][j], REC_001);
0: 				t_util.t_checkRecordCount(page[0][j], 1, 1);
0: 			}
0: 			t[0].resetContext();
0: 
0: 			//////////////////////// step 10 ////////////////////////
0: 			// unlatch all pages
0: 			for (i = 0; i < numtrans; i++)
0: 			{
0: 				t[i].switchTransactionContext();
0: 				for (j = 0; j < numpages; j++)
0: 					page[i][j].unlatch();
0: 				t[i].resetContext();
0: 			}
0: 
0: 			// t[0] incomplete
0: 			t_util.t_abort(t[1]);
0: 			t_util.t_commit(t[2]);
0: 			// t[3] incomplete
0: 			t_util.t_commit(t[4]);
0: 
0: 			// reopen containers 1, 2, and 4, where were closed when the
0: 			// transaction terminated.
0: 			c[1] = t_util.t_openContainer(t[1], 0, cid[1], false);
0: 			c[2] = t_util.t_openContainer(t[2], 0, cid[2], false);
0: 			c[4] = t_util.t_openContainer(t[4], 0, cid[4], false);
0: 
0: 			//////////////////////// check ////////////////////////
0: 			for (j = 0; j < numpages; j++)	
0: 			{
0: 				t[0].switchTransactionContext();
0: 				t_util.t_checkFetch(c[0], rh[0][j], REC_001);
0: 				t[0].resetContext();
0: 
0: 				// t[1] has been aborted
0: 				// rh[1][j] (REC_001) is deleted
0: 				t[1].switchTransactionContext();
0: 				page[1][j] = t_util.t_getPage(c[1], pagenum[1][j]);
0: 				t_util.t_checkRecordCount(page[1][j], 1, 0);
0: 				t_util.t_checkFetchBySlot(page[1][j], Page.FIRST_SLOT_NUMBER,
0: 								   REC_001, true, false);
0: 				page[1][j].unlatch();
0: 				t[1].resetContext();
0: 
0: 				t[2].switchTransactionContext();
0: 				t_util.t_checkFetch(c[2], rh[2][j], REC_006);
0: 				t[2].resetContext();
0: 
0: 				t[3].switchTransactionContext();
0: 				t_util.t_checkFetch(c[3], rh[3][j], REC_006);
0: 				t[3].resetContext();
0: 
0: 				t[4].switchTransactionContext();
0: 				t_util.t_checkFetch(c[4], rh[4][j], REC_006);
0: 				t[4].resetContext();
0: 			}
0: 
0: 
0: 			///////////////////////////////////////////////////////////
0: 			//// now write a 1/2 log record to the end of the log
0: 			//////////////////////////////////////////////////////////
0: 			t[3].switchTransactionContext();// this is going to be an
0: 											// incomplete transaction
0: 
0: 			// make a full page and then copy and purge it to another page
0: 			Page badPage1 = t_util.t_addPage(c[3]);
0: 			Page badPage2 = t_util.t_addPage(c[3]);
0: 			T_RawStoreRow row;
0: 			for (i = 0, row = new T_RawStoreRow("row at slot " + i);
0: 				 badPage1.spaceForInsert();
0: 				 i++, row = new T_RawStoreRow("row at slot " + i))
0: 			{
0: 				if (t_util.t_insertAtSlot(badPage1, i, row, Page.INSERT_UNDO_WITH_PURGE) == null)
0: 					break;
0: 			}
0: 
0: 			//////////////////////////////////////////////////////////
0: 			// writing 200 bytes of the log record to the end of the log - 
0: 			// NO MORE LOG RECORD SHOULD BE WRITTEN,
0: 			//////////////////////////////////////////////////////////
0: 			if(!checksumTest)
0: 			{
0: 				SanityManager.DEBUG_SET(LogToFile.TEST_LOG_INCOMPLETE_LOG_WRITE);
0: 				System.getProperties().put(LogToFile.TEST_LOG_PARTIAL_LOG_WRITE_NUM_BYTES, "200");
0: 			}
0: 			logFactory.flushAll();
0: 
0: 
0: 			// RESOLVE:
0: 			// copy and purge actually generates 2 log records, this is
0: 			// actually not a good operation to use for this test.  Just make
0: 			// sure the first log record is > 400 or else the log will be hosed
0: 			//
0: 			badPage1.copyAndPurge(badPage2, 0, i, 0);
0: 
0: 			t[3].resetContext();
0: 
0: 			if(checksumTest)
0: 				simulateLogFileCorruption();
0: 
0: 			////////////////////////////////////////////////////////
0: 
0: 			REPORT("badlog test3: numtrans " + numtrans + " numpages " + numpages);
0: 
0: 			for (i = 0; i < numtrans; i++)
0: 			{
0: 				register(key(3, i+10), cid[i]);
0: 
0: 				String str = "container " + i + ":" + find(key(3,i+10)) + " pages: ";
0: 
0: 				for (j = 0; j < numpages; j++)
0: 				{
0: 					str += pagenum[i][j] + " ";
0: 					register(key(3, (i+1)*1000+j), pagenum[i][j]);
0: 				}
0: 				REPORT("\t" + str);
0: 			}
0: 
0: 			register(key(3,1), numtrans); 
0: 			register(key(3,2), numpages);
0: 			register(key(3,3), badPage1.getPageNumber());
0: 			register(key(3,4), badPage2.getPageNumber());
0: 
0: 		}
0: 		finally
0: 		{
0: 			SanityManager.DEBUG_CLEAR(LogToFile.TEST_LOG_INCOMPLETE_LOG_WRITE);
0: 		}
0: 	}
0: 
0: 	/*
0: 	 * test recovery of test3
0: 	 */
0: 	void RTest3() throws T_Fail, StandardException
0: 	{
0: 		int numtrans = (int)find(key(3,1));
0: 		if (numtrans < 0)
0: 		{
0: 			REPORT("bad log test3 not run");
0: 			return;
0: 		}
0: 
0: 		int numpages = (int)find(key(3,2));
0: 		long badPagenum1 = find(key(3,3)); // these two pages are involved in
0: 										   // the 1/2 written log record, make
0: 										   // sure they are not corrupted
0: 		long badPagenum2 = find(key(3,4));
0: 
0: 		Transaction t = t_util.t_startTransaction();
0: 
0: 		long[] cid = new long[numtrans];
0: 		ContainerHandle[] c = new ContainerHandle[numtrans];
0: 
0: 		long[][] pagenum = new long[numtrans][numpages];
0: 		Page[][] page = new Page[numtrans][numpages];
0: 
0: 		int i,j;
0: 
0: 		for (i = 0; i < numtrans; i++)
0: 		{
0: 			cid[i] = find(key(3, i+10));
0: 
0: 			c[i] = t_util.t_openContainer(t, 0, cid[i], true);
0: 			
0: 			for (j = 0; j < numpages; j++)
0: 			{
0: 				pagenum[i][j] = find(key(3, (i+1)*1000+j));
0: 
0: 				page[i][j] = t_util.t_getPage(c[i], pagenum[i][j]);
0: 			}
0: 		}
0: 
0: 		// transactions were left in the following state
0: 		// t0 - incomplete (rolled back)
0: 		// t1 - abort
0: 		// t2 - commit
0: 		// t3 - incomplete (rolled back)
0: 		// t4 - commit
0: 		// any other transactions - incomplete
0: 		//
0: 		// all the rolled back transaction should have a deleted REC_001
0: 		// all the committed transactions should have a REC_006
0:                                                                            //
0: 		try 
0: 		{
0: 			for (j = 0; j < numpages; j++)
0: 			{
0: 				t_util.t_checkRecordCount(page[0][j], 1, 0);
0: 				t_util.t_checkFetchBySlot(page[0][j], Page.FIRST_SLOT_NUMBER,
0: 								   REC_001, true, true);
0: 
0: 				t_util.t_checkRecordCount(page[1][j], 1, 0);
0: 				t_util.t_checkFetchBySlot(page[1][j], Page.FIRST_SLOT_NUMBER,
0: 								   REC_001, true, true);
0: 
0: 				t_util.t_checkRecordCount(page[2][j], 1, 1);
0: 				t_util.t_checkFetchBySlot(page[2][j], Page.FIRST_SLOT_NUMBER,
0: 								   REC_006, false, true);
0: 
0: 				t_util.t_checkRecordCount(page[3][j], 1, 0);
0: 				t_util.t_checkFetchBySlot(page[3][j], Page.FIRST_SLOT_NUMBER,
0: 								   REC_001, true, true);
0: 
0: 				t_util.t_checkRecordCount(page[4][j], 1, 1);
0: 				t_util.t_checkFetchBySlot(page[4][j], Page.FIRST_SLOT_NUMBER,
0: 								   REC_006, false, true);
0: 			}
0: 
0: 			// now check the two bad pages - they are in c[3] and should be empty
0: 			Page badPage1 = t_util.t_getPage(c[3], badPagenum1);
0: 			Page badPage2 = t_util.t_getPage(c[3], badPagenum2);
0: 			t_util.t_checkRecordCount(badPage1, 0, 0);
0: 			t_util.t_checkRecordCount(badPage2, 0, 0);
0: 
0: 			REPORT("RTest3 passed: numtrans " + numtrans + " numpages " + numpages);
0: 
0: 			for (i = 0; i < numtrans; i++)
0: 			{
0: 				String str = "container " + i + ":" + cid[i] + " pages: ";
0: 				for (j = 0; j < numpages; j++)
0: 					str += pagenum[i][j] + " ";
0: 				REPORT("\t" + str);
0: 			}
0: 		}
0: 		finally
0: 		{
0: 			t_util.t_commit(t);
0: 			t.close();
0: 		}
0: 	}
0: 
0: 		
0: 	/*
0: 	 * test4 manufactures a log with the following recoverable 'defects':
0: 	 * - a log file that only has the partial log instance(7 bytes instead of 8
0: 	 * bytes writtne) of a log record written 
0: 	 */
0: 	protected void STest4() throws T_Fail, StandardException
0: 	{
0: 		Transaction t = t_util.t_startTransaction();
0: 
0: 		try
0: 		{
0: 			long cid = t_util.t_addContainer(t, 0);
0: 			ContainerHandle c = t_util.t_openContainer(t, 0, cid, true);
0: 
0: 			Page page = t_util.t_getPage(c, ContainerHandle.FIRST_PAGE_NUMBER);
0: 
0: 			// make a really big record - fill 80% of the page
0: 			int numcol = (int)((RawStoreFactory.PAGE_SIZE_MINIMUM*8)/(10*20));
0: 
0: 			T_RawStoreRow bigrow = new T_RawStoreRow(numcol);
0: 			String string1 = "01234567890123456789"; // 20 char string
0: 			for (int i = 0; i < numcol; i++)
0: 				bigrow.setColumn(i, string1);
0: 
0: 			// if overhead is > 80%, then reduce the row size until it fits
0: 			RecordHandle rh = null;
0: 			while(numcol > 0)
0: 			{
0: 				try {
0: 					rh = t_util.t_insert(page, bigrow);
0: 					break;
0: 				} catch (StandardException se) {
0: 					bigrow.setColumn(--numcol, (String) null);
0: 				}
0: 			}
0: 			if (numcol == 0)
0: 				throw T_Fail.testFailMsg("cannot fit any column into the page");
0: 
0: 			
0: 
0: 			t_util.t_commit(t);
0: 
0: 			// make a big log record - update row
0: 			String string2 = "abcdefghijklmnopqrst"; // 20 char string
0: 			for (int i = 0; i < numcol; i++)
0: 				bigrow.setColumn(i, string2);
0: 
0: 			c = t_util.t_openContainer(t, 0, cid, true);
0: 			page = t_util.t_getPage(c, ContainerHandle.FIRST_PAGE_NUMBER);
0: 
0: 			Page p2 = t_util.t_addPage(c);		// do something so we get the beginXact log
0: 								// record out of the way
0: 			t_util.t_insert(p2, new T_RawStoreRow(REC_001));
0: 
0: 
0: 			//////////////////////////////////////////////////////////
0: 			// writing approx 1/2 of log record  instance to the end of the log - 
0: 			// NO MORE LOG RECORD SHOULD BE WRITTEN,
0: 			// Length  4 bytes + 7(8) bytes of log record instance
0: 			//////////////////////////////////////////////////////////
0: 			if(!checksumTest)
0: 			{
0: 				SanityManager.DEBUG_SET(LogToFile.TEST_LOG_INCOMPLETE_LOG_WRITE);
0: 				System.getProperties().put(LogToFile.TEST_LOG_PARTIAL_LOG_WRITE_NUM_BYTES, Integer.toString(11));
0: 			}
0: 
0: 			logFactory.flushAll();
0: 			page.update(rh, bigrow.getRow(), (FormatableBitSet) null);
0: 
0: 			if(checksumTest)
0: 				simulateLogFileCorruption();
0: 
0: 			////////////////////////////////////////////////////////
0: 
0: 			REPORT("badlog test4: cid = " + cid + " numcol " + numcol);
0: 
0: 			register(key(4,1), cid);
0: 			register(key(4,2), numcol);
0: 		}
0: 		finally
0: 		{
0: 			SanityManager.DEBUG_CLEAR(LogToFile.TEST_LOG_INCOMPLETE_LOG_WRITE);
0: 		}
0: 	}
0: 
0: 	/*
0: 	 * test recovery of test 4
0: 	 */
0: 	void RTest4() throws T_Fail, StandardException
0: 	{
0: 		long cid = find(key(4, 1));
0: 		if (cid < 0)
0: 		{
0: 			REPORT("bad log test4 not run");
0: 			return;
0: 		}
0: 		int numcol = (int)find(key(4,2));
0: 
0: 		Transaction t = t_util.t_startTransaction();
0: 		try
0: 		{
0: 			ContainerHandle c = t_util.t_openContainer(t, 0, cid, true);
0: 			Page page = t_util.t_getPage(c, ContainerHandle.FIRST_PAGE_NUMBER);
0: 
0: 			int optimisticNumcol = (int)((RawStoreFactory.PAGE_SIZE_MINIMUM*8)/(10*20));
0: 			T_RawStoreRow bigrow = new T_RawStoreRow(optimisticNumcol);
0: 			for (int i = 0; i < optimisticNumcol; i++)
0: 				bigrow.setColumn(i, (String) null);
0: 
0: 			page.fetchFromSlot(
0:                 (RecordHandle) null, 0, bigrow.getRow(), 
0:                 (FetchDescriptor) null,
0:                 false);
0: 
0: 			Storable column;
0: 			String string1 = "01234567890123456789"; // the original 20 char string
0: 
0: 			for (int i = 0; i < numcol; i++)
0: 			{
0: 				column = bigrow.getStorableColumn(i);
0: 				if (!(column.toString().equals(string1)))
0: 					throw T_Fail.testFailMsg("Column " + i + " value incorrect, got :" + column.toString());
0: 			}
0: 			for (int i = numcol; i < optimisticNumcol; i++)
0: 			{
0: 				column = bigrow.getStorableColumn(i);
0: 				if (!column.isNull())
0: 					throw T_Fail.testFailMsg("Column " + i + 
0: 											 " expect Null, got : " + column.toString());
0: 			}
0: 
0: 			REPORT("RTest4 passed");
0: 
0: 		}
0: 		finally
0: 		{
0: 			t_util.t_commit(t);
0: 			t.close();
0: 		}
0: 	}
0: 	
0: 	/*
0: 	 * test5 manufactures a log with the following recoverable 'defects':
0: 	 * - a log file that only has the partial log record length (3 bytes instead of 4
0: 	 * bytes writtne) of a log record written in the beginning
0: 	 */
0: 	protected void STest5() throws T_Fail, StandardException
0: 	{
0: 		Transaction t = t_util.t_startTransaction();
0: 
0: 		try
0: 		{
0: 			long cid = t_util.t_addContainer(t, 0);
0: 			ContainerHandle c = t_util.t_openContainer(t, 0, cid, true);
0: 
0: 			Page page = t_util.t_getPage(c, ContainerHandle.FIRST_PAGE_NUMBER);
0: 
0: 			// make a really big record - fill 80% of the page
0: 			int numcol = (int)((RawStoreFactory.PAGE_SIZE_MINIMUM*8)/(10*20));
0: 
0: 			T_RawStoreRow bigrow = new T_RawStoreRow(numcol);
0: 			String string1 = "01234567890123456789"; // 20 char string
0: 			for (int i = 0; i < numcol; i++)
0: 				bigrow.setColumn(i, string1);
0: 
0: 			// if overhead is > 80%, then reduce the row size until it fits
0: 			RecordHandle rh = null;
0: 			while(numcol > 0)
0: 			{
0: 				try {
0: 					rh = t_util.t_insert(page, bigrow);
0: 					break;
0: 				} catch (StandardException se) {
0: 					bigrow.setColumn(--numcol, (String) null);
0: 				}
0: 			}
0: 			if (numcol == 0)
0: 				throw T_Fail.testFailMsg("cannot fit any column into the page");
0: 
0: 			
0: 
0: 			t_util.t_commit(t);
0: 
0: 			// make a big log record - update row
0: 			String string2 = "abcdefghijklmnopqrst"; // 20 char string
0: 			for (int i = 0; i < numcol; i++)
0: 				bigrow.setColumn(i, string2);
0: 
0: 			c = t_util.t_openContainer(t, 0, cid, true);
0: 			page = t_util.t_getPage(c, ContainerHandle.FIRST_PAGE_NUMBER);
0: 
0: 			Page p2 = t_util.t_addPage(c);		// do something so we get the beginXact log
0: 								// record out of the way
0: 			t_util.t_insert(p2, new T_RawStoreRow(REC_001));
0: 
0: 
0: 			//////////////////////////////////////////////////////////
0: 			// writing approx 3 bytes of log record to the end of the log - 
0: 			// NO MORE LOG RECORD SHOULD BE WRITTEN,
0: 			// Length  3 bytes (4) of log record length
0: 			//////////////////////////////////////////////////////////
0: 			if(!checksumTest)
0: 			{
0: 				SanityManager.DEBUG_SET(LogToFile.TEST_LOG_INCOMPLETE_LOG_WRITE);
0: 				System.getProperties().put(LogToFile.TEST_LOG_PARTIAL_LOG_WRITE_NUM_BYTES, Integer.toString(3));
0: 			}
0: 			logFactory.flushAll();
0: 
0: 			page.update(rh, bigrow.getRow(), (FormatableBitSet) null);
0: 
0: 			if(checksumTest)
0: 				simulateLogFileCorruption();
0: 
0: 			////////////////////////////////////////////////////////
0: 
0: 			REPORT("badlog test5: cid = " + cid + " numcol " + numcol);
0: 
0: 			register(key(5,1), cid);
0: 			register(key(5,2), numcol);
0: 		}
0: 		finally
0: 		{
0: 			SanityManager.DEBUG_CLEAR(LogToFile.TEST_LOG_INCOMPLETE_LOG_WRITE);
0: 		}
0: 	}
0: 
0: 	/*
0: 	 * test recovery of test 5
0: 	 */
0: 	void RTest5() throws T_Fail, StandardException
0: 	{
0: 		long cid = find(key(5, 1));
0: 		if (cid < 0)
0: 		{
0: 			REPORT("bad log test5 not run");
0: 			return;
0: 		}
0: 		int numcol = (int)find(key(5,2));
0: 
0: 		Transaction t = t_util.t_startTransaction();
0: 		try
0: 		{
0: 			ContainerHandle c = t_util.t_openContainer(t, 0, cid, true);
0: 			Page page = t_util.t_getPage(c, ContainerHandle.FIRST_PAGE_NUMBER);
0: 
0: 			int optimisticNumcol = (int)((RawStoreFactory.PAGE_SIZE_MINIMUM*8)/(10*20));
0: 			T_RawStoreRow bigrow = new T_RawStoreRow(optimisticNumcol);
0: 			for (int i = 0; i < optimisticNumcol; i++)
0: 				bigrow.setColumn(i, (String) null);
0: 
0: 			page.fetchFromSlot(
0:                 (RecordHandle) null, 0, bigrow.getRow(), 
0:                 (FetchDescriptor) null,
0:                 false);
0: 
0: 			Storable column;
0: 			String string1 = "01234567890123456789"; // the original 20 char string
0: 
0: 			for (int i = 0; i < numcol; i++)
0: 			{
0: 				column = bigrow.getStorableColumn(i);
0: 				if (!(column.toString().equals(string1)))
0: 					throw T_Fail.testFailMsg("Column " + i + " value incorrect, got :" + column.toString());
0: 			}
0: 			for (int i = numcol; i < optimisticNumcol; i++)
0: 			{
0: 				column = bigrow.getStorableColumn(i);
0: 				if (!column.isNull())
0: 					throw T_Fail.testFailMsg("Column " + i + 
0: 											 " expect Null, got : " + column.toString());
0: 			}
0: 
0: 			REPORT("RTest5 passed");
0: 
0: 		}
0: 		finally
0: 		{
0: 			t_util.t_commit(t);
0: 			t.close();
0: 		}
0: 	}
0: 		
0: 	/*
0: 	 * test6 manufactures a log with the following recoverable 'defects':
0: 	 * - a log file that only has the log record with partial data portion
0: 	 * written (approximately (1997/2 (data)+ 16(log records ov)))	 */
0: 	protected void STest6() throws T_Fail, StandardException
0: 	{
0: 		Transaction t = t_util.t_startTransaction();
0: 
0: 		try
0: 		{
0: 			long cid = t_util.t_addContainer(t, 0);
0: 			ContainerHandle c = t_util.t_openContainer(t, 0, cid, true);
0: 
0: 			Page page = t_util.t_getPage(c, ContainerHandle.FIRST_PAGE_NUMBER);
0: 
0: 			// make a really big record - fill 80% of the page
0: 			int numcol = (int)((RawStoreFactory.PAGE_SIZE_MINIMUM*8)/(10*20));
0: 
0: 			T_RawStoreRow bigrow = new T_RawStoreRow(numcol);
0: 			String string1 = "01234567890123456789"; // 20 char string
0: 			for (int i = 0; i < numcol; i++)
0: 				bigrow.setColumn(i, string1);
0: 
0: 			// if overhead is > 80%, then reduce the row size until it fits
0: 			RecordHandle rh = null;
0: 			while(numcol > 0)
0: 			{
0: 				try {
0: 					rh = t_util.t_insert(page, bigrow);
0: 					break;
0: 				} catch (StandardException se) {
0: 					bigrow.setColumn(--numcol, (String) null);
0: 				}
0: 			}
0: 			if (numcol == 0)
0: 				throw T_Fail.testFailMsg("cannot fit any column into the page");
0: 
0: 			
0: 
0: 			t_util.t_commit(t);
0: 
0: 			// make a big log record - update row
0: 			String string2 = "abcdefghijklmnopqrst"; // 20 char string
0: 			for (int i = 0; i < numcol; i++)
0: 				bigrow.setColumn(i, string2);
0: 
0: 			c = t_util.t_openContainer(t, 0, cid, true);
0: 			page = t_util.t_getPage(c, ContainerHandle.FIRST_PAGE_NUMBER);
0: 
0: 			Page p2 = t_util.t_addPage(c);		// do something so we get the beginXact log
0: 								// record out of the way
0: 			t_util.t_insert(p2, new T_RawStoreRow(REC_001));
0: 
0: 
0: 			//////////////////////////////////////////////////////////
0: 			// writing (1997/2 (data)+ 16(log records ov)) bytes of log record to the end of the log - 
0: 			// NO MORE LOG RECORD SHOULD BE WRITTEN,
0: 			//////////////////////////////////////////////////////////
0: 			if(!checksumTest)
0: 			{
0: 				SanityManager.DEBUG_SET(LogToFile.TEST_LOG_INCOMPLETE_LOG_WRITE);
0: 				System.getProperties().put(LogToFile.TEST_LOG_PARTIAL_LOG_WRITE_NUM_BYTES, Integer.toString((1997/2) + 16));
0: 			}
0: 			logFactory.flushAll();
0: 			page.update(rh, bigrow.getRow(), (FormatableBitSet) null);
0: 
0: 			if(checksumTest)
0: 				simulateLogFileCorruption();
0: 
0: 			////////////////////////////////////////////////////////
0: 
0: 			REPORT("badlog test6: cid = " + cid + " numcol " + numcol);
0: 
0: 			register(key(6,1), cid);
0: 			register(key(6,2), numcol);
0: 		}
0: 		finally
0: 		{
0: 			SanityManager.DEBUG_CLEAR(LogToFile.TEST_LOG_INCOMPLETE_LOG_WRITE);
0: 		}
0: 	}
0: 
0: 	/*
0: 	 * test recovery of test 6
0: 	 */
0: 	void RTest6() throws T_Fail, StandardException
0: 	{
0: 		long cid = find(key(6, 1));
0: 		if (cid < 0)
0: 		{
0: 			REPORT("bad log test6 not run");
0: 			return;
0: 		}
0: 		int numcol = (int)find(key(6,2));
0: 
0: 		Transaction t = t_util.t_startTransaction();
0: 		try
0: 		{
0: 			ContainerHandle c = t_util.t_openContainer(t, 0, cid, true);
0: 			Page page = t_util.t_getPage(c, ContainerHandle.FIRST_PAGE_NUMBER);
0: 
0: 			int optimisticNumcol = (int)((RawStoreFactory.PAGE_SIZE_MINIMUM*8)/(10*20));
0: 			T_RawStoreRow bigrow = new T_RawStoreRow(optimisticNumcol);
0: 			for (int i = 0; i < optimisticNumcol; i++)
0: 				bigrow.setColumn(i, (String) null);
0: 
0: 			page.fetchFromSlot(
0:                 (RecordHandle) null, 0, bigrow.getRow(), 
0:                 (FetchDescriptor) null,
0:                 false);
0: 
0: 			Storable column;
0: 			String string1 = "01234567890123456789"; // the original 20 char string
0: 
0: 			for (int i = 0; i < numcol; i++)
0: 			{
0: 				column = bigrow.getStorableColumn(i);
0: 				if (!(column.toString().equals(string1)))
0: 					throw T_Fail.testFailMsg("Column " + i + " value incorrect, got :" + column.toString());
0: 			}
0: 			for (int i = numcol; i < optimisticNumcol; i++)
0: 			{
0: 				column = bigrow.getStorableColumn(i);
0: 				if (!column.isNull())
0: 					throw T_Fail.testFailMsg("Column " + i + 
0: 											 " expect Null, got : " + column.toString());
0: 			}
0: 
0: 			REPORT("RTest6 passed");
0: 
0: 		}
0: 		finally
0: 		{
0: 			t_util.t_commit(t);
0: 			t.close();
0: 		}
0: 	}
0: 	/*
0: 	 * test7 manufactures a log with the following recoverable 'defects':
0: 	 * - a log file that has the last log record with partial end length
0: 	 * written( 3 of 4 bytes). instead of (1997(data) + 16 (log records overhead)) write (1997 + 15) 
0: 	 */
0: 	protected void STest7() throws T_Fail, StandardException
0: 	{
0: 		Transaction t = t_util.t_startTransaction();
0: 
0: 		try
0: 		{
0: 			long cid = t_util.t_addContainer(t, 0);
0: 			ContainerHandle c = t_util.t_openContainer(t, 0, cid, true);
0: 
0: 			Page page = t_util.t_getPage(c, ContainerHandle.FIRST_PAGE_NUMBER);
0: 
0: 			// make a really big record - fill 80% of the page
0: 			int numcol = (int)((RawStoreFactory.PAGE_SIZE_MINIMUM*8)/(10*20));
0: 
0: 			T_RawStoreRow bigrow = new T_RawStoreRow(numcol);
0: 			String string1 = "01234567890123456789"; // 20 char string
0: 			for (int i = 0; i < numcol; i++)
0: 				bigrow.setColumn(i, string1);
0: 
0: 			// if overhead is > 80%, then reduce the row size until it fits
0: 			RecordHandle rh = null;
0: 			while(numcol > 0)
0: 			{
0: 				try {
0: 					rh = t_util.t_insert(page, bigrow);
0: 					break;
0: 				} catch (StandardException se) {
0: 					bigrow.setColumn(--numcol, (String) null);
0: 				}
0: 			}
0: 			if (numcol == 0)
0: 				throw T_Fail.testFailMsg("cannot fit any column into the page");
0: 
0: 			
0: 
0: 			t_util.t_commit(t);
0: 
0: 			// make a big log record - update row
0: 			String string2 = "abcdefghijklmnopqrst"; // 20 char string
0: 			for (int i = 0; i < numcol; i++)
0: 				bigrow.setColumn(i, string2);
0: 
0: 			c = t_util.t_openContainer(t, 0, cid, true);
0: 			page = t_util.t_getPage(c, ContainerHandle.FIRST_PAGE_NUMBER);
0: 
0: 			Page p2 = t_util.t_addPage(c);		// do something so we get the beginXact log
0: 								// record out of the way
0: 			t_util.t_insert(p2, new T_RawStoreRow(REC_001));
0: 
0: 
0: 			//////////////////////////////////////////////////////////
0: 			// writing only 3 bytes of end length of the log record to the end of the log - 
0: 			//i.e: instead of (1997(data) + 16 (log records overhead)) write (1997 + 15) 
0: 			// NO MORE LOG RECORD SHOULD BE WRITTEN,
0: 			//////////////////////////////////////////////////////////
0: 			if(!checksumTest)
0: 			{
0: 				SanityManager.DEBUG_SET(LogToFile.TEST_LOG_INCOMPLETE_LOG_WRITE);
0: 				System.getProperties().put(LogToFile.TEST_LOG_PARTIAL_LOG_WRITE_NUM_BYTES, Integer.toString(1997+15));
0: 			}
0: 			logFactory.flushAll();
0: 			page.update(rh, bigrow.getRow(), (FormatableBitSet) null);
0: 
0: 			if(checksumTest)
0: 				simulateLogFileCorruption();
0: 
0: 
0: 			////////////////////////////////////////////////////////
0: 
0: 			REPORT("badlog test7: cid = " + cid + " numcol " + numcol);
0: 
0: 			register(key(7,1), cid);
0: 			register(key(7,2), numcol);
0: 		}
0: 		finally
0: 		{
0: 			SanityManager.DEBUG_CLEAR(LogToFile.TEST_LOG_INCOMPLETE_LOG_WRITE);
0: 		}
0: 	}
0: 
0: 	/*
0: 	 * test recovery of test 7
0: 	 */
0: 	void RTest7() throws T_Fail, StandardException
0: 	{
0: 		long cid = find(key(6, 1));
0: 		if (cid < 0)
0: 		{
0: 			REPORT("bad log test7 not run");
0: 			return;
0: 		}
0: 		int numcol = (int)find(key(6,2));
0: 
0: 		Transaction t = t_util.t_startTransaction();
0: 		try
0: 		{
0: 			ContainerHandle c = t_util.t_openContainer(t, 0, cid, true);
0: 			Page page = t_util.t_getPage(c, ContainerHandle.FIRST_PAGE_NUMBER);
0: 
0: 			int optimisticNumcol = (int)((RawStoreFactory.PAGE_SIZE_MINIMUM*8)/(10*20));
0: 			T_RawStoreRow bigrow = new T_RawStoreRow(optimisticNumcol);
0: 			for (int i = 0; i < optimisticNumcol; i++)
0: 				bigrow.setColumn(i, (String) null);
0: 
0: 			page.fetchFromSlot(
0:                 (RecordHandle) null, 0, bigrow.getRow(), 
0:                 (FetchDescriptor) null,
0:                 false);
0: 
0: 			Storable column;
0: 			String string1 = "01234567890123456789"; // the original 20 char string
0: 
0: 			for (int i = 0; i < numcol; i++)
0: 			{
0: 				column = bigrow.getStorableColumn(i);
0: 				if (!(column.toString().equals(string1)))
0: 					throw T_Fail.testFailMsg("Column " + i + " value incorrect, got :" + column.toString());
0: 			}
0: 			for (int i = numcol; i < optimisticNumcol; i++)
0: 			{
0: 				column = bigrow.getStorableColumn(i);
0: 				if (!column.isNull())
0: 					throw T_Fail.testFailMsg("Column " + i + 
0: 											 " expect Null, got : " + column.toString());
0: 			}
0: 
0: 			REPORT("RTest7 passed");
0: 
0: 		}
0: 		finally
0: 		{
0: 			t_util.t_commit(t);
0: 			t.close();
0: 		}
0: 	}
0: 
0: 
0: 
0: 	/*
0: 	 * simulate log corruption to test the checksuming of log records. 
0: 	 */
0: 	private void simulateLogFileCorruption() throws T_Fail, StandardException
0: 	{
0: 		long filenum;
0: 		long filepos;
0: 		long amountOfLogWritten;
0: 		LogCounter logInstant = (LogCounter)logFactory.getFirstUnflushedInstant();
0: 		filenum = logInstant.getLogFileNumber();
0: 		filepos = logInstant.getLogFilePosition();
0: 		logFactory.flushAll();
0: 		logInstant = (LogCounter)logFactory.getFirstUnflushedInstant();
0: 		filenum = logInstant.getLogFileNumber();
0: 		amountOfLogWritten = logInstant.getLogFilePosition() - filepos;
0: 
0: 		// write some random  garbage into the log file , 
0: 		// purpose of doing this is to test that recovery works correctly when 
0: 		// log records in the end of a log file did not get wrtten completely
0: 		// and in the correct order. 
0: 
0: 		try{
0: 			StorageRandomAccessFile log = logFactory.getLogFileToSimulateCorruption(filenum) ;
0: 		
0: 			int noWrites = (int) amountOfLogWritten / 512;
0: 			//mess up few bytes in every block of a 512 bytes.
0: 			filepos += 512;
0: 			java.util.Random r = new java.util.Random();
0: 			for(int i = 0 ; i < noWrites ; i++)
0: 			{
0: 				REPORT("corruptig log file : filenum " + filenum + " fileposition " + filepos);
0: 				log.seek(filepos);
0: 				log.writeInt(r.nextInt());
0: 				filepos +=512;
0: 
0: 			}
0: 			log.sync(false);
0: 			log.close();
0: 		}catch(IOException ie)
0: 		{
0: 			throw T_Fail.exceptionFail(ie);
0: 		}
0: 		
0: 	}
0: 
0: }
0: 
0: 
0: 
============================================================================