5:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.compile.ProjectRestrictNode
1:345de35: 
1:2d37fd6:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2d37fd6:    contributor license agreements.  See the NOTICE file distributed with
1:2d37fd6:    this work for additional information regarding copyright ownership.
1:2d37fd6:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2d37fd6:    (the "License"); you may not use this file except in compliance with
1:2d37fd6:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
25:eac0369: 
10:eac0369:  */
1:3527fd5: 
1:eac0369: package	org.apache.derby.impl.sql.compile;
1:c723732: 
1:3bb140c: import java.util.HashSet;
1:3bb140c: import java.util.Properties;
1:3bb140c: import java.util.Set;
1:f6d02c9: import org.apache.derby.catalog.UUID;
1:3bb140c: import org.apache.derby.catalog.types.ReferencedColumnsDescriptorImpl;
1:3bb140c: import org.apache.derby.iapi.error.StandardException;
1:3bb140c: import org.apache.derby.iapi.reference.ClassName;
1:3bb140c: import org.apache.derby.iapi.services.classfile.VMOpcode;
1:3bb140c: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1:eac0369: import org.apache.derby.iapi.services.context.ContextManager;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:3bb140c: import org.apache.derby.iapi.sql.compile.AccessPath;
1:3bb140c: import org.apache.derby.iapi.sql.compile.CostEstimate;
1:eac0369: import org.apache.derby.iapi.sql.compile.Optimizable;
1:eac0369: import org.apache.derby.iapi.sql.compile.OptimizablePredicate;
1:eac0369: import org.apache.derby.iapi.sql.compile.OptimizablePredicateList;
1:eac0369: import org.apache.derby.iapi.sql.compile.Optimizer;
1:eac0369: import org.apache.derby.iapi.sql.compile.RequiredRowOrdering;
1:eac0369: import org.apache.derby.iapi.sql.compile.RowOrdering;
1:3bb140c: import org.apache.derby.iapi.sql.compile.Visitor;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1:eac0369: import org.apache.derby.iapi.store.access.TransactionController;
1:eac0369: import org.apache.derby.iapi.util.JBitSet;
1:eac0369: 
2:eac0369: /**
1:eac0369:  * A ProjectRestrictNode represents a result set for any of the basic DML
1:eac0369:  * operations: SELECT, INSERT, UPDATE, and DELETE.  For INSERT with
1:eac0369:  * a VALUES clause, restriction will be null. For both INSERT and UPDATE,
1:eac0369:  * the resultColumns in the selectList will contain the names of the columns
1:eac0369:  * being inserted into or updated.
5:eac0369:  *
1:eac0369:  * NOTE: A ProjectRestrictNode extends FromTable since it can exist in a FromList.
1:eac0369:  *
1:c723732:  */
1:eac0369: 
1:3bb140c: class ProjectRestrictNode extends SingleChildResultSetNode
1:411d1b7: {
1:eac0369: 	/**
1:eac0369: 	 * The ValueNode for the restriction to be evaluated here.
1:c723732: 	 */
1:3bb140c:     ValueNode   restriction;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Constant expressions to be evaluated here.
1:eac0369: 	 */
1:eac0369: 	ValueNode	constantRestriction = null;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Restriction as a PredicateList
1:eac0369: 	 */
1:3bb140c:     PredicateList restrictionList;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * List of subqueries in projection
1:eac0369: 	 */
1:eac0369: 	SubqueryList projectSubquerys;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * List of subqueries in restriction
1:eac0369: 	 */
1:eac0369: 	SubqueryList restrictSubquerys;
1:eac0369: 
1:eac0369: 	private boolean accessPathModified;
1:eac0369: 
1:eac0369: 	/* Should we get the table number from this node,
1:eac0369: 	 * regardless of the class of our child.
1:eac0369: 	 */
1:eac0369: 	private boolean getTableNumberHere;
1:eac0369: 
1:af1c18c:     /**
1:af1c18c:      * Used with {@code validatingBaseTableCID} to validating deferred check
1:af1c18c:      * constraints.
1:af1c18c:      */
1:af1c18c:     private boolean validatingCheckConstraints = false;
1:f6d02c9:     private String validatingBaseTableUUIDString;
1:eac0369: 	/**
1:3bb140c:      * Constructor for a ProjectRestrictNode.
1:eac0369: 	 *
1:eac0369: 	 * @param childResult	The child ResultSetNode
1:eac0369: 	 * @param projection	The result column list for the projection
1:eac0369: 	 * @param restriction	An expression representing the restriction to be 
1:eac0369: 	 *					    evaluated here.
1:eac0369: 	 * @param restrictionList Restriction as a PredicateList
1:eac0369: 	 * @param projectSubquerys List of subqueries in the projection
1:eac0369: 	 * @param restrictSubquerys List of subqueries in the restriction
1:eac0369: 	 * @param tableProperties	Properties list associated with the table
1:3bb140c:      * @param cm            The context manager
1:eac0369: 	 */
1:eac0369: 
1:3bb140c:     ProjectRestrictNode(ResultSetNode    childResult,
1:3bb140c:                         ResultColumnList projection,
1:3bb140c:                         ValueNode        restriction,
1:3bb140c:                         PredicateList    restrictionList,
1:3bb140c:                         SubqueryList     projectSubquerys,
1:3bb140c:                         SubqueryList     restrictSubquerys,
1:3bb140c:                         Properties       tableProperties,
1:3bb140c:                         ContextManager   cm)
7:eac0369: 	{
1:3bb140c:         super(childResult, tableProperties, cm);
1:11f7ee3:         setResultColumns( projection );
1:3bb140c:         this.restriction = restriction;
1:3bb140c:         this.restrictionList = restrictionList;
1:3bb140c:         this.projectSubquerys = projectSubquerys;
1:3bb140c:         this.restrictSubquerys = restrictSubquerys;
1:eac0369: 
1:eac0369: 		/* A PRN will only hold the tableProperties for
1:eac0369: 		 * a result set tree if its child is not an
1:eac0369: 		 * optimizable.  Otherwise, the properties will
1:eac0369: 		 * be transferred down to the child.
1:eac0369: 		 */
1:eac0369: 		if (tableProperties != null &&
1:eac0369: 			 (childResult instanceof Optimizable))
1:eac0369: 		{
1:eac0369: 			((Optimizable) childResult).setProperties(getProperties());
1:eac0369: 			setProperties((Properties) null);
1:c723732: 		}
1:c723732: 	}
1:c723732: 
1:c723732: 	/*
1:eac0369: 	 *  Optimizable interface
1:eac0369: 	 */
1:eac0369: 
1:2060c4a: 	/**
1:eac0369: 		@see Optimizable#nextAccessPath
1:eac0369: 		@exception StandardException	Thrown on error
1:eac0369: 	 */
1:b4cda60:     @Override
1:eac0369: 	public boolean nextAccessPath(Optimizer optimizer,
1:eac0369: 									OptimizablePredicateList predList,
1:eac0369: 									RowOrdering rowOrdering)
1:eac0369: 			throws StandardException
1:eac0369: 	{
1:c723732: 		/*
1:eac0369: 		** If the child result set is an optimizable, let it choose its next
1:eac0369: 		** access path.  If it is not an optimizable, we have to tell the
1:eac0369: 		** caller that there is an access path the first time we are called
1:eac0369: 		** for this position in the join order, and that there are no more
1:eac0369: 		** access paths for subsequent calls for this position in the join
1:eac0369: 		** order.  The startOptimizing() method is called once on each
1:eac0369: 		** optimizable when it is put into a join position.
1:eac0369: 		*/
1:eac0369: 		if (childResult instanceof Optimizable)
1:eac0369: 		{
1:eac0369: 			return ((Optimizable) childResult).nextAccessPath(optimizer,
1:eac0369: 																restrictionList,
1:eac0369: 																rowOrdering);
7:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return super.nextAccessPath(optimizer, predList, rowOrdering);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see Optimizable#rememberAsBest 
1:eac0369: 		@exception StandardException	Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:62d4560: 	public void rememberAsBest(int planType, Optimizer optimizer)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:62d4560: 		super.rememberAsBest(planType, optimizer);
1:eac0369: 		if (childResult instanceof Optimizable)
1:62d4560: 			((Optimizable) childResult).rememberAsBest(planType, optimizer);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see Optimizable#startOptimizing */
1:3bb140c:     @Override
1:eac0369: 	public void startOptimizing(Optimizer optimizer, RowOrdering rowOrdering)
1:eac0369: 	{
1:eac0369: 		if (childResult instanceof Optimizable)
1:eac0369: 		{
1:eac0369: 			((Optimizable) childResult).startOptimizing(optimizer, rowOrdering);
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			super.startOptimizing(optimizer, rowOrdering);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see Optimizable#getTableNumber */
1:3bb140c:     @Override
1:eac0369: 	public int getTableNumber()
1:eac0369: 	{
1:eac0369: 		/* GROSS HACK - We need to get the tableNumber after
1:eac0369: 		 * calling modifyAccessPaths() on the child when doing
1:eac0369: 		 * a hash join on an arbitrary result set.  The problem
1:eac0369: 		 * is that the child will always be an optimizable at this
1:eac0369: 		 * point.  So, we 1st check to see if we should get it from
1:eac0369: 		 * this node.  (We set the boolean to true in the appropriate
1:eac0369: 		 * place in modifyAccessPaths().)
1:eac0369: 		 */
1:eac0369: 		if (getTableNumberHere)
1:eac0369: 		{
1:eac0369: 			return super.getTableNumber();
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (childResult instanceof Optimizable)
1:eac0369: 			return ((Optimizable) childResult).getTableNumber();
1:eac0369: 
1:eac0369: 		return super.getTableNumber();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see Optimizable#optimizeIt
1:eac0369: 	 *
2:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	public CostEstimate optimizeIt(
1:eac0369: 							Optimizer optimizer,
1:eac0369: 							OptimizablePredicateList predList,
1:eac0369: 							CostEstimate outerCost,
1:eac0369: 							RowOrdering rowOrdering)
1:eac0369: 			throws StandardException
1:eac0369: 	{
1:eac0369: 		/*
1:eac0369: 		** RESOLVE: Most types of Optimizables only implement estimateCost(),
1:eac0369: 		** and leave it up to optimizeIt() in FromTable to figure out the
1:eac0369: 		** total cost of the join.  A ProjectRestrict can have a non-Optimizable
1:eac0369: 		** child, though, in which case we want to tell the child the
1:eac0369: 		** number of outer rows - it could affect the join strategy
1:eac0369: 		** significantly.  So we implement optimizeIt() here, which overrides
1:eac0369: 		** the optimizeIt() in FromTable.  This assumes that the join strategy
1:eac0369: 		** for which this join node is the inner table is a nested loop join,
1:eac0369: 		** which will not be a valid assumption when we implement other
1:eac0369: 		** strategies like materialization (hash join can work only on
1:eac0369: 		** base tables).  The join strategy for a base table under a
1:eac0369: 		** ProjectRestrict is set in the base table itself.
1:eac0369: 		*/
1:11f7ee3: 
1:eac0369: 		CostEstimate childCost;
1:eac0369: 
1:11f7ee3: 		setCostEstimate( getCostEstimate( optimizer ) );
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** Don't re-optimize a child result set that has already been fully
1:eac0369: 		** optimized.  For example, if the child result set is a SelectNode,
1:eac0369: 		** it will be changed to a ProjectRestrictNode, which we don't want
1:eac0369: 		** to re-optimized.
1:eac0369: 		*/
1:eac0369: 		// NOTE: TO GET THE RIGHT COST, THE CHILD RESULT MAY HAVE TO BE
1:eac0369: 		// OPTIMIZED MORE THAN ONCE, BECAUSE THE NUMBER OF OUTER ROWS
1:eac0369: 		// MAY BE DIFFERENT EACH TIME.
1:eac0369: 		// if (childResultOptimized)
1:eac0369: 		// 	return costEstimate;
1:eac0369: 
1:e07631a: 		// It's possible that a call to optimize the left/right will cause
1:e07631a: 		// a new "truly the best" plan to be stored in the underlying base
1:e07631a: 		// tables.  If that happens and then we decide to skip that plan
1:e07631a: 		// (which we might do if the call to "considerCost()" below decides
1:e07631a: 		// the current path is infeasible or not the best) we need to be
1:e07631a: 		// able to revert back to the "truly the best" plans that we had
1:e07631a: 		// saved before we got here.  So with this next call we save the
1:e07631a: 		// current plans using "this" node as the key.  If needed, we'll
1:e07631a: 		// then make the call to revert the plans in OptimizerImpl's
1:e07631a: 		// getNextDecoratedPermutation() method.
1:acdff3c: 		updateBestPlanMap(ADD_PLAN, this);
1:eac0369: 
1:eac0369: 		/* If the childResult is instanceof Optimizable, then we optimizeIt.
1:eac0369: 		 * Otherwise, we are going into a new query block.  If the new query
1:eac0369: 		 * block has already had its access path modified, then there is
1:eac0369: 		 * nothing to do.  Otherwise, we must begin the optimization process
1:eac0369: 		 * anew on the new query block.
1:eac0369: 		 */
1:eac0369: 		if (childResult instanceof Optimizable)
1:eac0369: 		{
1:eac0369: 			childCost = ((Optimizable) childResult).optimizeIt(
1:eac0369: 															optimizer,
1:eac0369: 															restrictionList,
1:eac0369: 															outerCost,
1:eac0369: 															rowOrdering);
1:eac0369: 			/* Copy child cost to this node's cost */
1:11f7ee3: 			getCostEstimate().setCost(
1:eac0369: 							childCost.getEstimatedCost(),
1:eac0369: 							childCost.rowCount(),
1:eac0369: 							childCost.singleScanRowCount());
1:eac0369: 
1:eac0369: 
1:e540aee: 			// Note: we don't call "optimizer.considerCost()" here because
1:e540aee: 			// a) the child will make that call as part of its own
1:e540aee: 			// "optimizeIt()" work above, and b) the child might have
1:e540aee: 			// different criteria for "considering" (i.e. rejecting or
1:e540aee: 			// accepting) a plan's cost than this ProjectRestrictNode does--
1:e540aee: 			// and we don't want to override the child's decision.  So as
1:e540aee: 			// with most operations in this class, if the child is an
1:e540aee: 			// Optimizable, we just let it do its own work and make its
1:e540aee: 			// own decisions.
1:eac0369: 		}
1:eac0369: 		else if ( ! accessPathModified)
1:eac0369: 		{
1:eac0369: 			if (SanityManager.DEBUG)
1:eac0369: 			{
1:eac0369: 				if (! ((childResult instanceof SelectNode) ||
1:eac0369: 								 (childResult instanceof RowResultSetNode)))
1:eac0369: 				{
1:eac0369: 					SanityManager.THROWASSERT(
1:eac0369: 						"childResult is expected to be instanceof " +
1:eac0369: 						"SelectNode or RowResultSetNode - it is a " +
1:eac0369: 						childResult.getClass().getName());
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 			childResult = childResult.optimize(optimizer.getDataDictionary(), 
1:eac0369: 											   restrictionList,
1:eac0369: 											   outerCost.rowCount());
1:eac0369: 
1:eac0369: 			/* Copy child cost to this node's cost */
1:11f7ee3: 			childCost = childResult.getCostEstimate();
1:eac0369: 
1:11f7ee3: 			getCostEstimate().setCost(
1:eac0369: 							childCost.getEstimatedCost(),
1:eac0369: 							childCost.rowCount(),
1:eac0369: 							childCost.singleScanRowCount());
1:eac0369: 
1:0be2d6e: 			/* Note: Prior to the fix for DERBY-781 we had calls here
1:0be2d6e: 			 * to set the cost estimate for BestAccessPath and
1:0be2d6e: 			 * BestSortAvoidancePath to equal costEstimate.  That used
1:0be2d6e: 			 * to be okay because prior to DERBY-781 we would only
1:0be2d6e: 			 * get here once (per join order) for a given SelectNode/
1:0be2d6e: 			 * RowResultSetNode and thus we could safely say that the
1:0be2d6e: 			 * costEstimate from the most recent call to "optimize()"
1:0be2d6e: 			 * was the best one so far (because we knew that we would
1:0be2d6e: 			 * only call childResult.optimize() once).  Now that we
1:0be2d6e: 			 * support hash joins with subqueries, though, we can get
1:0be2d6e: 			 * here twice per join order: once when the optimizer is
1:0be2d6e: 			 * considering a nested loop join with this PRN, and once
1:0be2d6e: 			 * when it is considering a hash join.  This means we can't
1:0be2d6e: 			 * just arbitrarily use the cost estimate for the most recent
1:0be2d6e: 			 * "optimize()" as the best cost because that may not
1:0be2d6e: 			 * be accurate--it's possible that the above call to
1:0be2d6e: 			 * childResult.optimize() was for a hash join, but that
1:0be2d6e: 			 * we were here once before (namely for nested loop) and
1:0be2d6e: 			 * the cost of the nested loop is actually less than
1:0be2d6e: 			 * the cost of the hash join.  In that case it would
1:0be2d6e: 			 * be wrong to use costEstimate as the cost of the "best"
1:0be2d6e: 			 * paths because it (costEstimate) holds the cost of
1:0be2d6e: 			 * the hash join, not of the nested loop join.  So with
1:0be2d6e: 			 * DERBY-781 the following calls were removed:
1:0be2d6e: 			 *   getBestAccessPath().setCostEstimate(costEstimate);
1:0be2d6e: 			 *   getBestSortAvoidancePath().setCostEstimate(costEstimate);
1:0be2d6e: 			 * If costEstimate *does* actually hold the estimate for
1:0be2d6e: 			 * the best path so far, then we will set BestAccessPath
1:0be2d6e: 			 * and BestSortAvoidancePath as needed in the following
1:0be2d6e: 			 * call to "considerCost".
1:eac0369: 			 */
1:eac0369: 
1:eac0369: 			// childResultOptimized = true;
1:eac0369: 
1:eac0369: 			/* RESOLVE - ARBITRARYHASHJOIN - Passing restriction list here, as above, is correct.
1:eac0369: 			 * However,  passing predList makes the following work:
1:eac0369: 			 *	select * from t1, (select * from t2) c properties joinStrategy = hash where t1.c1 = c.c1;
1:eac0369: 			 * The following works with restrictionList:
1:eac0369: 			 *	select * from t1, (select c1 + 0 from t2) c(c1) properties joinStrategy = hash where t1.c1 = c.c1;
1:eac0369: 			 */
2:eac0369: 			optimizer.considerCost(this, restrictionList, getCostEstimate(), outerCost);
1:eac0369: 		}
1:eac0369: 
1:11f7ee3: 		return getCostEstimate();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see Optimizable#feasibleJoinStrategy
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	public boolean feasibleJoinStrategy(OptimizablePredicateList predList,
1:eac0369: 										Optimizer optimizer)
1:eac0369: 					throws StandardException
1:eac0369: 	{
1:eac0369: 		AccessPath ap;
1:eac0369: 
1:eac0369: 		/* The child being an Optimizable is a special case.  In that
1:eac0369: 		 * case, we want to get the current access path and join strategy
1:eac0369: 		 * from the child.  Otherwise, we want to get it from this node.
1:eac0369: 		 */
1:eac0369: 		if (childResult instanceof Optimizable)
1:eac0369: 		{
1:e07631a: 			// With DERBY-805 it's possible that, when considering a nested
1:e07631a: 			// loop join with this PRN, we pushed predicates down into the
1:e07631a: 			// child if the child is a UNION node.  At this point, though, we
1:e07631a: 			// may be considering doing a hash join with this PRN instead of a
1:e07631a: 			// nested loop join, and if that's the case we need to pull any
1:e07631a: 			// predicates back up so that they can be searched for equijoins
1:e07631a: 			// that will in turn make the hash join possible.  So that's what
1:e07631a: 			// the next call does.  Two things to note: 1) if no predicates
1:e07631a: 			// were pushed, this call is a no-op; and 2) if we get here when
1:e07631a: 			// considering a nested loop join, the predicates that we pull
1:e07631a: 			// here (if any) will be re-pushed for subsequent costing/ 
1:e07631a: 			// optimization as necessary (see OptimizerImpl.costPermutation(),
1:e07631a: 			// which will call this class's optimizeIt() method and that's
1:e07631a: 			// where the predicates are pushed down again).
1:e07631a: 			if (childResult instanceof UnionNode)
1:e07631a: 				((UnionNode)childResult).pullOptPredicates(restrictionList);
1:eac0369: 
1:e07631a: 			return ((Optimizable) childResult).
1:e07631a: 				feasibleJoinStrategy(restrictionList, optimizer);
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return super.feasibleJoinStrategy(restrictionList, optimizer);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see Optimizable#getCurrentAccessPath */
1:3bb140c:     @Override
1:eac0369: 	public AccessPath getCurrentAccessPath()
1:eac0369: 	{
1:eac0369: 		if (childResult instanceof Optimizable)
1:eac0369: 			return ((Optimizable) childResult).getCurrentAccessPath();
1:eac0369: 
1:eac0369: 		return super.getCurrentAccessPath();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see Optimizable#getBestAccessPath */
1:3bb140c:     @Override
1:eac0369: 	public AccessPath getBestAccessPath()
1:eac0369: 	{
1:eac0369: 		if (childResult instanceof Optimizable)
1:eac0369: 			return ((Optimizable) childResult).getBestAccessPath();
1:eac0369: 
1:eac0369: 		return super.getBestAccessPath();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see Optimizable#getBestSortAvoidancePath */
1:3bb140c:     @Override
1:eac0369: 	public AccessPath getBestSortAvoidancePath()
1:eac0369: 	{
1:eac0369: 		if (childResult instanceof Optimizable)
1:eac0369: 			return ((Optimizable) childResult).getBestSortAvoidancePath();
1:eac0369: 
1:eac0369: 		return super.getBestSortAvoidancePath();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see Optimizable#getTrulyTheBestAccessPath */
1:3bb140c:     @Override
1:eac0369: 	public AccessPath getTrulyTheBestAccessPath()
1:eac0369: 	{
1:eac0369: 		/* The childResult will always be an Optimizable
1:eac0369: 		 * during code generation.  If the childResult was
1:eac0369: 		 * not an Optimizable during optimization, then this node
1:eac0369: 		 * will have the truly the best access path, so we want to
1:eac0369: 		 * return it from this node, rather than traversing the tree.
1:eac0369: 		 * This can happen for non-flattenable derived tables.
1:eac0369: 		 * Anyway, we note this state when modifying the access paths.
1:eac0369: 		 */
1:eac0369: 		if (hasTrulyTheBestAccessPath)
1:eac0369: 		{
1:eac0369: 			return super.getTrulyTheBestAccessPath();
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (childResult instanceof Optimizable)
1:eac0369: 			return ((Optimizable) childResult).getTrulyTheBestAccessPath();
1:eac0369: 
1:eac0369: 		return super.getTrulyTheBestAccessPath();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see Optimizable#rememberSortAvoidancePath */
1:3bb140c:     @Override
1:eac0369: 	public void rememberSortAvoidancePath()
1:eac0369: 	{
1:eac0369: 		if (childResult instanceof Optimizable)
1:eac0369: 			((Optimizable) childResult).rememberSortAvoidancePath();
1:eac0369: 		else
1:eac0369: 			super.rememberSortAvoidancePath();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see Optimizable#considerSortAvoidancePath */
1:3bb140c:     @Override
1:eac0369: 	public boolean considerSortAvoidancePath()
1:eac0369: 	{
1:eac0369: 		if (childResult instanceof Optimizable)
1:eac0369: 			return ((Optimizable) childResult).considerSortAvoidancePath();
1:eac0369: 
1:eac0369: 		return super.considerSortAvoidancePath();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see Optimizable#pushOptPredicate
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 
1:3bb140c:     @Override
1:eac0369: 	public boolean pushOptPredicate(OptimizablePredicate optimizablePredicate)
1:eac0369: 			throws StandardException
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(optimizablePredicate instanceof Predicate,
1:eac0369: 				"optimizablePredicate expected to be instanceof Predicate");
1:eac0369: 			SanityManager.ASSERT(! optimizablePredicate.hasSubquery() &&
1:eac0369: 								 ! optimizablePredicate.hasMethodCall(),
1:eac0369: 				"optimizablePredicate either has a subquery or a method call");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* Add the matching predicate to the restrictionList */
1:eac0369: 		if (restrictionList == null)
1:eac0369: 		{
1:3bb140c:             restrictionList = new PredicateList(getContextManager());
1:eac0369: 		}
1:eac0369: 		restrictionList.addPredicate((Predicate) optimizablePredicate);
1:eac0369: 
1:eac0369: 		/* Remap all of the ColumnReferences to point to the
1:eac0369: 		 * source of the values.
1:eac0369: 		 */
1:df88f63: 		Predicate pred = (Predicate)optimizablePredicate;
1:df88f63: 
1:df88f63: 		/* If the predicate is scoped then the call to "remapScopedPred()"
1:df88f63: 		 * will do the necessary remapping for us and will return true;
1:df88f63: 		 * otherwise, we'll just do the normal remapping here.
1:df88f63: 		 */
1:df88f63: 		if (!pred.remapScopedPred())
1:df88f63: 		{
1:df88f63: 			RemapCRsVisitor rcrv = new RemapCRsVisitor(true);
1:df88f63: 			pred.getAndNode().accept(rcrv);
1:df88f63: 		}
1:eac0369: 
1:eac0369: 		return true;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see Optimizable#pullOptPredicates
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	public void pullOptPredicates(
1:eac0369: 								OptimizablePredicateList optimizablePredicates)
1:eac0369: 					throws StandardException
1:eac0369: 	{
1:7e23da1:         // DERBY-4001: Don't pull predicates if this node is part of a NOT
1:7e23da1:         // EXISTS join. For example, in the query below, if we allowed the
1:7e23da1:         // predicate 1<>1 (always false) to be pulled, no rows would be
1:7e23da1:         // returned, whereas it should return all the rows in table T.
1:7e23da1:         // SELECT * FROM T WHERE NOT EXISTS (SELECT * FROM T WHERE 1<>1)
1:7e23da1: 		if (restrictionList != null && !isNotExists())
1:eac0369: 		{
1:5872305: 			// Pull up any predicates that may have been pushed further
1:5872305: 			// down the tree during optimization.
1:5872305: 			if (childResult instanceof UnionNode)
1:5872305: 				((UnionNode)childResult).pullOptPredicates(restrictionList);
1:eac0369: 
1:eac0369: 			RemapCRsVisitor rcrv = new RemapCRsVisitor(false);
1:eac0369: 			for (int i = restrictionList.size() - 1; i >= 0; i--)
1:eac0369: 			{
1:eac0369: 				OptimizablePredicate optPred =
1:eac0369: 					restrictionList.getOptPredicate(i);
1:eac0369: 				((Predicate) optPred).getAndNode().accept(rcrv);
1:eac0369: 				optimizablePredicates.addOptPredicate(optPred);
1:eac0369: 				restrictionList.removeOptPredicate(i);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see Optimizable#modifyAccessPath
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	public Optimizable modifyAccessPath(JBitSet outerTables) 
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		boolean origChildOptimizable = true;
1:eac0369: 
1:eac0369: 		/* It is okay to optimize most nodes multiple times.  However,
1:eac0369: 		 * modifying the access path is something that should only be done
1:eac0369: 		 * once per node.  One reason for this is that the predicate list
1:eac0369: 		 * will be empty after the 1st call, and we assert that it should
1:eac0369: 		 * be non-empty.  Multiple calls to modify the access path can
1:eac0369: 		 * occur when there is a non-flattenable FromSubquery (or view).
1:eac0369: 		 */
1:eac0369: 		if (accessPathModified)
1:eac0369: 		{
1:eac0369: 			return this;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** Do nothing if the child result set is not optimizable, as there
1:eac0369: 		** can be nothing to modify.
1:eac0369: 		*/
1:e07631a: 		boolean alreadyPushed = false;
1:eac0369: 		if ( ! (childResult instanceof Optimizable))
1:eac0369: 		{
1:eac0369: 			// Remember that the original child was not Optimizable
1:eac0369: 			origChildOptimizable = false;
1:eac0369: 
1:df88f63: 			/* When we optimized the child we passed in our restriction list
1:df88f63: 			 * so that scoped predicates could be pushed further down the
1:df88f63: 			 * tree.  We need to do the same when modifying the access
1:df88f63: 			 * paths to ensure we generate the same plans the optimizer
1:df88f63: 			 * chose.
1:df88f63: 			 */
1:df88f63: 			childResult = childResult.modifyAccessPaths(restrictionList);
1:df88f63: 
1:eac0369: 			/* Mark this node as having the truly ... for
1:eac0369: 			 * the underlying tree.
1:eac0369: 			 */
1:eac0369: 			hasTrulyTheBestAccessPath = true;
1:eac0369: 
1:eac0369: 			/* Replace this PRN with a HRN if we are doing a hash join */
1:eac0369: 			if (trulyTheBestAccessPath.getJoinStrategy().isHashJoin())
1:eac0369: 			{
1:eac0369: 				if (SanityManager.DEBUG)
1:eac0369: 				{
1:eac0369: 					SanityManager.ASSERT(restrictionList != null,
1:eac0369: 						"restrictionList expected to be non-null");
1:eac0369: 					SanityManager.ASSERT(restrictionList.size() != 0,
1:eac0369: 							"restrictionList.size() expected to be non-zero");
1:eac0369: 				}
1:eac0369: 				/* We're doing a hash join on an arbitary result set.
1:eac0369: 				 * We need to get the table number from this node when
1:eac0369: 				 * dividing up the restriction list for a hash join.
1:eac0369: 				 * We need to explicitly remember this.
1:eac0369: 				 */
1:eac0369: 				getTableNumberHere = true;
1:eac0369: 			}
1:eac0369: 			else
1:eac0369: 			{
1:eac0369: 				/* We consider materialization into a temp table as a last step.
1:eac0369: 				 * Currently, we only materialize VTIs that are inner tables
1:eac0369: 				 * and can't be instantiated multiple times.  In the future we
1:eac0369: 				 * will consider materialization as a cost based option.
1:eac0369: 				 */
1:eac0369: 				return (Optimizable) considerMaterialization(outerTables);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* If the child is not a FromBaseTable, then we want to
1:eac0369: 		 * keep going down the tree.  (Nothing to do at this node.)
1:eac0369: 		 */
1:eac0369: 		else if (!(childResult instanceof FromBaseTable))
1:eac0369: 		{
1:eac0369: 			/* Make sure that we have a join strategy */
1:eac0369: 			if (trulyTheBestAccessPath.getJoinStrategy() == null)
1:eac0369: 			{
1:eac0369: 				trulyTheBestAccessPath = (AccessPathImpl) ((Optimizable) childResult).getTrulyTheBestAccessPath();
1:eac0369: 			}
1:eac0369: 
1:5872305: 			// If the childResult is a SetOperatorNode (esp. a UnionNode),
1:5872305: 			// then it's possible that predicates in our restrictionList are
1:5872305: 			// supposed to be pushed further down the tree (as of DERBY-805).
1:5872305: 			// We passed the restrictionList down when we optimized the child
1:5872305: 			// so that the relevant predicates could be pushed further as part
1:5872305: 			// of the optimization process; so now that we're finalizing the
1:5872305: 			// paths, we need to do the same thing: i.e. pass restrictionList
1:5872305: 			// down so that the predicates that need to be pushed further
1:5872305: 			// _can_ be pushed further.
1:5872305: 			if (childResult instanceof SetOperatorNode) {
1:5872305: 				childResult = (ResultSetNode)
1:5872305: 					((SetOperatorNode) childResult).modifyAccessPath(
1:5872305: 						outerTables, restrictionList);
1:eac0369: 
1:e07631a: 				// Take note of the fact that we already pushed predicates
1:e07631a: 				// as part of the modifyAccessPaths call.  This is necessary
1:e07631a: 				// because there may still be predicates in restrictionList
1:e07631a: 				// that we intentionally decided not to push (ex. if we're
1:e07631a: 				// going to do hash join then we chose to not push the join
1:e07631a: 				// predicates).  Whatever the reason for not pushing the
1:e07631a: 				// predicates, we have to make sure we don't inadvertenly
1:e07631a: 				// push them later (esp. as part of the "pushUsefulPredicates"
1:e07631a: 				// call below).
1:e07631a: 				alreadyPushed = true;
1:eac0369: 			}
1:5872305: 			else {
1:eac0369: 				childResult = 
1:5872305: 					(ResultSetNode) ((FromTable) childResult).
1:5872305: 						modifyAccessPath(outerTables);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:0be2d6e: 		// If we're doing a hash join with _this_ PRN (as opposed to
1:0be2d6e: 		// with this PRN's child) then we don't attempt to push
1:0be2d6e: 		// predicates down.  There are two reasons for this: 1)
1:0be2d6e: 		// we don't want to push the equijoin predicate that is
1:0be2d6e: 		// required for the hash join, and 2) if we're doing a
1:0be2d6e: 		// hash join then we're going to materialize this node,
1:0be2d6e: 		// but if we push predicates before materialization, we
1:0be2d6e: 		// can end up with incorrect results (esp. missing rows).
1:0be2d6e: 		// So don't push anything in this case.
1:0be2d6e: 		boolean hashJoinWithThisPRN = hasTrulyTheBestAccessPath &&
1:0be2d6e: 			(trulyTheBestAccessPath.getJoinStrategy() != null) &&
1:0be2d6e: 			trulyTheBestAccessPath.getJoinStrategy().isHashJoin();
1:eac0369: 
1:af1c18c:         if ((restrictionList != null) &&
1:af1c18c:             !alreadyPushed &&
1:af1c18c:             !hashJoinWithThisPRN &&
1:af1c18c:             !validatingCheckConstraints)
1:eac0369: 		{
1:eac0369: 			restrictionList.pushUsefulPredicates((Optimizable) childResult);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** The optimizer's decision on the access path for the child result
1:eac0369: 		** set may require the generation of extra result sets.  For
1:eac0369: 		** example, if it chooses an index, we need an IndexToBaseRowNode
1:eac0369: 		** above the FromBaseTable (and the FromBaseTable has to change
1:eac0369: 		** its column list to match that of the index.
1:eac0369: 		*/
1:eac0369: 		if (origChildOptimizable)
1:eac0369: 		{
1:eac0369: 			childResult = childResult.changeAccessPath();
1:eac0369: 		}
1:eac0369: 		accessPathModified = true;
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** Replace this PRN with a HTN if a hash join
1:eac0369: 		** is being done at this node.  (Hash join on a scan
1:eac0369: 		** is a special case and is handled at the FBT.)
1:eac0369: 		*/
1:eac0369: 		if (trulyTheBestAccessPath.getJoinStrategy() != null &&
1:eac0369: 			trulyTheBestAccessPath.getJoinStrategy().isHashJoin())
1:eac0369: 		{
1:eac0369: 			return replaceWithHashTableNode();
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* We consider materialization into a temp table as a last step.
1:eac0369: 		 * Currently, we only materialize VTIs that are inner tables
1:eac0369: 		 * and can't be instantiated multiple times.  In the future we
1:eac0369: 		 * will consider materialization as a cost based option.
1:eac0369: 		 */
1:eac0369: 		return (Optimizable) considerMaterialization(outerTables);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * This method creates a HashTableNode between the PRN and
1:eac0369: 	 * it's child when the optimizer chooses hash join on an
1:eac0369: 	 * arbitrary (non-FBT) result set tree.
1:eac0369: 	 * We divide up the restriction list into 3 parts and
1:eac0369: 	 * distribute those parts as described below.
1:eac0369: 	 * 
1:eac0369: 	 * @return The new (same) top of our result set tree.
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	private Optimizable replaceWithHashTableNode()
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:0be2d6e: 		// If this PRN has TTB access path for its child, store that access
1:0be2d6e: 		// path in the child here, so that we can find it later when it
1:0be2d6e: 		// comes time to generate qualifiers for the hash predicates (we
1:0be2d6e: 		// need the child's access path when generating qualifiers; if we
1:0be2d6e: 		// don't pass the path down here, the child won't be able to find
1:0be2d6e: 		// it).
1:0be2d6e: 		if (hasTrulyTheBestAccessPath)
1:eac0369: 		{
1:0be2d6e: 			((FromTable)childResult).trulyTheBestAccessPath =
1:0be2d6e: 				(AccessPathImpl)getTrulyTheBestAccessPath();
1:eac0369: 
1:0be2d6e: 			// If the child itself is another SingleChildResultSetNode
1:0be2d6e: 			// (which is also what a ProjectRestrictNode is), then tell
1:0be2d6e: 			// it that it is now holding TTB path for it's own child.  Again,
1:0be2d6e: 			// this info is needed so that child knows where to find the
1:0be2d6e: 			// access path at generation time.
1:0be2d6e: 			if (childResult instanceof SingleChildResultSetNode)
1:eac0369: 			{
1:0be2d6e: 				((SingleChildResultSetNode)childResult)
1:0be2d6e: 					.hasTrulyTheBestAccessPath = hasTrulyTheBestAccessPath;
1:eac0369: 
1:0be2d6e: 				// While we're at it, add the PRN's table number to the
1:0be2d6e: 				// child's referenced map so that we can find the equijoin
1:0be2d6e: 				// predicate.  We have to do this because the predicate
1:0be2d6e: 				// will be referencing the PRN's tableNumber, not the
1:0be2d6e: 				// child's--and since we use the child as the target
1:0be2d6e: 				// when searching for hash keys (as can be seen in
1:0be2d6e: 				// HashJoinStrategy.divideUpPredicateLists()), the child
1:0be2d6e: 				// should know what this PRN's table number is.  This
1:0be2d6e: 				// is somewhat bizarre since the child doesn't
1:0be2d6e: 				// actually "reference" this PRN, but since the child's
1:0be2d6e: 				// reference map is used when searching for the equijoin
1:0be2d6e: 				// predicate (see "buildTableNumList" in
1:0be2d6e: 				// BinaryRelationalOperatorNode), this is the simplest
1:0be2d6e: 				// way to pass this PRN's table number down.
1:0be2d6e: 				childResult.getReferencedTableMap().set(tableNumber);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* We want to divide the predicate list into 3 separate lists -
1:eac0369: 		 *	o predicates against the source of the hash table, which will
1:eac0369: 		 *	  be applied on the way into the hash table (searchRestrictionList)
1:eac0369: 		 *  o join clauses which are qualifiers and get applied to the
1:eac0369: 		 *	  rows in the hash table on a probe (joinRestrictionList)
1:eac0369: 		 *	o non-qualifiers involving both tables which will get
1:eac0369: 		 *	  applied after a row gets returned from the HTRS (nonQualifiers)
1:eac0369: 		 *
1:eac0369: 		 * We do some unnecessary work when doing this as we want to reuse
1:eac0369: 		 * as much existing code as possible.  The code that we are reusing
1:eac0369: 		 * was originally built for hash scans, hence the unnecessary
1:eac0369: 		 * requalification list.
1:eac0369: 		 */
1:eac0369: 		PredicateList searchRestrictionList =
1:3bb140c:                 new PredicateList(getContextManager());
1:eac0369: 		PredicateList joinQualifierList =
1:3bb140c:                 new PredicateList(getContextManager());
1:eac0369: 		PredicateList requalificationRestrictionList =
1:3bb140c:                 new PredicateList(getContextManager());
1:eac0369: 		trulyTheBestAccessPath.getJoinStrategy().divideUpPredicateLists(
1:3bb140c: 											this,
1:eac0369: 											restrictionList,
2:eac0369: 											searchRestrictionList,
2:eac0369: 											joinQualifierList,
1:eac0369: 											requalificationRestrictionList,
1:eac0369: 											getDataDictionary());
1:eac0369: 
1:eac0369: 		/* Break out the non-qualifiers from HTN's join qualifier list and make that
1:eac0369: 		 * the new restriction list for this PRN.
1:eac0369: 		 */
1:3bb140c:         restrictionList = new PredicateList(getContextManager());
1:eac0369:         /* For non-base table, we remove first 2 lists from requal list to avoid adding duplicates.
1:eac0369:          */
1:e1f49ca:         for (Predicate p : searchRestrictionList) {
1:e1f49ca:             requalificationRestrictionList.removeOptPredicate(p);
1:e1f49ca:         }
1:e1f49ca: 
1:e1f49ca:         for (Predicate p : joinQualifierList) {
1:e1f49ca:             requalificationRestrictionList.removeOptPredicate(p);
1:e1f49ca:         }
1:eac0369: 
1:eac0369: 		joinQualifierList.transferNonQualifiers(this, restrictionList); //purify joinQual list
1:eac0369: 		requalificationRestrictionList.copyPredicatesToOtherList(restrictionList); //any residual
1:eac0369: 
1:eac0369: 		ResultColumnList	htRCList;
1:eac0369: 
1:eac0369: 		/* We get a shallow copy of the child's ResultColumnList and its 
1:eac0369: 		 * ResultColumns.  (Copy maintains ResultColumn.expression for now.)
1:eac0369: 		 */
1:eac0369: 		htRCList = childResult.getResultColumns();
1:eac0369: 		childResult.setResultColumns(htRCList.copyListAndObjects());
1:eac0369: 
1:eac0369: 		/* Replace ResultColumn.expression with new VirtualColumnNodes
1:eac0369: 		 * in the HTN's ResultColumnList.  (VirtualColumnNodes include
1:eac0369: 		 * pointers to source ResultSetNode, this, and source ResultColumn.)
1:eac0369: 		 * NOTE: We don't want to mark the underlying RCs as referenced, otherwise
1:eac0369: 		 * we won't be able to project out any of them.
1:eac0369: 		 */
1:eac0369: 		htRCList.genVirtualColumnNodes(childResult, childResult.getResultColumns(), false);
1:eac0369: 
1:eac0369: 		/* The CRs for this side of the join in both the searchRestrictionList
1:eac0369: 		 * the joinQualifierList now point to the HTN's RCL.  We need them
1:eac0369: 		 * to point to the RCL in the child of the HTN.  (We skip doing this for
1:eac0369: 		 * the joinQualifierList as the code to generate the Qualifiers does not
1:eac0369: 		 * care.)
1:eac0369: 		 */
2:eac0369: 		RemapCRsVisitor rcrv = new RemapCRsVisitor(true);
1:eac0369: 		searchRestrictionList.accept(rcrv);
1:eac0369: 
1:eac0369: 		/* We can finally put the HTN between ourself and our old child. */
1:3bb140c:         childResult = new HashTableNode(childResult,
1:3bb140c:                                         tableProperties,
1:3bb140c:                                         htRCList,
1:3bb140c:                                         searchRestrictionList,
1:3bb140c:                                         joinQualifierList,
1:3bb140c:                                         trulyTheBestAccessPath,
1:3bb140c:                                         getCostEstimate(),
1:3bb140c:                                         projectSubquerys,
1:3bb140c:                                         restrictSubquerys,
1:3bb140c:                                         hashKeyColumns(),
1:3bb140c:                                         getContextManager());
1:eac0369: 		return this;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see Optimizable#verifyProperties 
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	public void verifyProperties(DataDictionary dDictionary)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		/* Table properties can be attached to this node if
1:eac0369: 		 * its child is not an optimizable, otherwise they
1:eac0369: 		 * are attached to its child.
1:eac0369: 		 */
1:eac0369: 
1:eac0369: 		if (childResult instanceof Optimizable)
1:eac0369: 		{
1:eac0369: 			((Optimizable) childResult).verifyProperties(dDictionary);
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			super.verifyProperties(dDictionary);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see Optimizable#legalJoinOrder
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	public boolean legalJoinOrder(JBitSet assignedTableMap)
1:eac0369: 	{
1:eac0369: 		if (childResult instanceof Optimizable)
1:eac0369: 		{
1:eac0369: 			return ((Optimizable) childResult).legalJoinOrder(assignedTableMap);
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return true;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see Optimizable#uniqueJoin
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	public double uniqueJoin(OptimizablePredicateList predList)
1:eac0369: 					throws StandardException
1:eac0369: 	{
1:eac0369: 		if (childResult instanceof Optimizable)
1:eac0369: 		{
1:eac0369: 			return ((Optimizable) childResult).uniqueJoin(predList);
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return super.uniqueJoin(predList);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return the restriction list from this node.
1:eac0369: 	 *
1:eac0369: 	 * @return	The restriction list from this node.
1:eac0369: 	 */
1:eac0369: 	PredicateList getRestrictionList()
1:eac0369: 	{
1:eac0369: 		return restrictionList;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** 
1:eac0369: 	 * Return the user specified join strategy, if any for this table.
1:eac0369: 	 *
1:eac0369: 	 * @return The user specified join strategy, if any for this table.
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	String getUserSpecifiedJoinStrategy()
1:eac0369: 	{
1:eac0369: 		if (childResult instanceof FromTable)
1:eac0369: 		{
1:eac0369: 			return ((FromTable) childResult).getUserSpecifiedJoinStrategy();
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return userSpecifiedJoinStrategy;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
1:eac0369: 	 * how tree printing is supposed to work.
1:eac0369: 	 *
1:eac0369: 	 * @param depth		The depth of this node in the tree
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     void printSubNodes(int depth)
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			super.printSubNodes(depth);
1:eac0369: 
1:eac0369: 			if (restriction != null)
1:eac0369: 			{
1:eac0369: 				printLabel(depth, "restriction: ");
1:eac0369: 				restriction.treePrint(depth + 1);
1:eac0369: 			}
1:eac0369: 
3:eac0369: 			if (restrictionList != null)
1:eac0369: 			{
1:eac0369: 				printLabel(depth, "restrictionList: ");
1:eac0369: 				restrictionList.treePrint(depth + 1);
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			if (projectSubquerys != null)
1:eac0369: 			{
1:eac0369: 				printLabel(depth, "projectSubquerys: ");
1:eac0369: 				projectSubquerys.treePrint(depth + 1);
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			if (restrictSubquerys != null)
1:eac0369: 			{
1:eac0369: 				printLabel(depth, "restrictSubquerys: ");
1:eac0369: 				restrictSubquerys.treePrint(depth + 1);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** 
1:eac0369: 	 * Put a ProjectRestrictNode on top of each FromTable in the FromList.
1:eac0369: 	 * ColumnReferences must continue to point to the same ResultColumn, so
1:eac0369: 	 * that ResultColumn must percolate up to the new PRN.  However,
1:eac0369: 	 * that ResultColumn will point to a new expression, a VirtualColumnNode, 
1:eac0369: 	 * which points to the FromTable and the ResultColumn that is the source for
1:eac0369: 	 * the ColumnReference.  
1:eac0369: 	 * (The new PRN will have the original of the ResultColumnList and
1:eac0369: 	 * the ResultColumns from that list.  The FromTable will get shallow copies
1:eac0369: 	 * of the ResultColumnList and its ResultColumns.  ResultColumn.expression
1:eac0369: 	 * will remain at the FromTable, with the PRN getting a new 
1:eac0369: 	 * VirtualColumnNode for each ResultColumn.expression.)
1:eac0369: 	 * We then project out the non-referenced columns.  If there are no referenced
1:eac0369: 	 * columns, then the PRN's ResultColumnList will consist of a single ResultColumn
1:eac0369: 	 * whose expression is 1.
1:eac0369: 	 *
1:eac0369: 	 * @param numTables			Number of tables in the DML Statement
1:eac0369: 	 * @param gbl				The group by list, if any
1:eac0369: 	 * @param fromList			The from list, if any
1:eac0369: 	 *
1:eac0369: 	 * @return The generated ProjectRestrictNode atop the original FromTable.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     ResultSetNode preprocess(int numTables,
1:eac0369: 									GroupByList gbl,
1:eac0369: 									FromList fromList) 
1:eac0369: 								throws StandardException
1:eac0369: 	{
1:eac0369: 		childResult = childResult.preprocess(numTables, gbl, fromList);
1:eac0369: 
1:eac0369: 		/* Build the referenced table map */
1:11f7ee3: 		setReferencedTableMap( (JBitSet) childResult.getReferencedTableMap().clone() );
1:eac0369: 
1:eac0369: 		return this;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Push expressions down to the first ResultSetNode which can do expression
1:eac0369: 	 * evaluation and has the same referenced table map.
1:eac0369: 	 * RESOLVE - This means only pushing down single table expressions to
1:eac0369: 	 * ProjectRestrictNodes today.  Once we have a better understanding of how
1:eac0369: 	 * the optimizer will work, we can push down join clauses.
1:eac0369: 	 *
1:eac0369: 	 * @param predicateList	The PredicateList.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     void pushExpressions(PredicateList predicateList)
1:eac0369: 					throws StandardException
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		SanityManager.ASSERT(predicateList != null,
1:eac0369: 							 "predicateList is expected to be non-null");
1:eac0369: 
1:eac0369: 		/* Push single table predicates down to the left of an outer
1:eac0369: 		 * join, if possible.  (We need to be able to walk an entire
1:eac0369: 		 * join tree.)
1:eac0369: 		 */
1:eac0369: 		if (childResult instanceof JoinNode)
1:eac0369: 		{
1:eac0369: 			((FromTable) childResult).pushExpressions(predicateList);
1:eac0369: 
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* Build a list of the single table predicates that we can push down */
1:3bb140c:         PredicateList pushPList =
1:11f7ee3:             predicateList.getPushablePredicates(getReferencedTableMap());
1:eac0369: 
1:eac0369: 		/* If this is a PRN above a SelectNode, probably due to a 
1:eac0369: 		 * view or derived table which couldn't be flattened, then see
1:eac0369: 		 * if we can push any of the predicates which just got pushed
1:eac0369: 		 * down to our level into the SelectNode.
1:3527fd5: 		 */
1:7a9ce7e: 		if (pushPList != null &&
1:7a9ce7e: 				(childResult instanceof SelectNode))
1:eac0369: 		{
1:d35198d:             SelectNode childSelect = (SelectNode)childResult;
1:7a9ce7e: 
1:d35198d:             // We can't push down if there is a window
1:d35198d:             // function because that would make ROW_NUMBER give wrong
1:d35198d:             // result:
1:d35198d:             // E.g.
1:d35198d:             //     SELECT * from (SELECT ROW_NUMBER() OVER (), j FROM T
1:d35198d:             //                    ORDER BY j) WHERE j=5
1:d35198d:             //
1:d35198d:             // Similarly, don't push if we have OFFSET and/or FETCH FROM.
1:d35198d:             //
1:b4cda60:             if (childSelect.hasWindows() ||
1:b4cda60:                 childSelect.hasOffsetFetchFirst()) {
1:d35198d:             } else {
1:d35198d:                 pushPList.pushExpressionsIntoSelect((SelectNode) childResult,
1:d35198d:                                                     false);
1:d35198d:             }
1:d35198d:         }
1:7a9ce7e: 
1:eac0369: 
1:c700973: 		/* DERBY-649: Push simple predicates into Unions. It would be up to UnionNode
1:c700973: 		 * to decide if these predicates can be pushed further into underlying SelectNodes
1:c700973: 		 * or UnionNodes.  Note, we also keep the predicateList at this
1:c700973: 		 * ProjectRestrictNode in case the predicates are not pushable or only
1:c700973: 		 * partially pushable.
1:eac0369: 		 *
1:c700973: 		 * It is possible to expand this optimization in UnionNode later.
1:c723732: 		 */
1:c700973: 		if (pushPList != null && (childResult instanceof UnionNode))
1:c700973: 			((UnionNode)childResult).pushExpressions(pushPList);
1:eac0369: 
1:eac0369: 		if (restrictionList == null)
1:eac0369: 		{
1:eac0369: 			restrictionList = pushPList;
1:7a9ce7e: 		}
1:eac0369: 		else if (pushPList != null && pushPList.size() != 0)
1:eac0369: 		{
1:eac0369: 			/* Concatenate the 2 PredicateLists */
1:eac0369: 			restrictionList.destructiveAppend(pushPList);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* RESOLVE - this looks like the place to try to try to push the 
1:eac0369: 		 * predicates through the ProjectRestrict.  Seems like we should
1:eac0369: 		 * "rebind" the column references and reset the referenced table maps
1:eac0369: 		 * in restrictionList and then call childResult.pushExpressions() on
1:eac0369: 		 * restrictionList.
1:eac0369: 		 */
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Add a new predicate to the list.  This is useful when doing subquery
1:eac0369: 	 * transformations, when we build a new predicate with the left side of
1:eac0369: 	 * the subquery operator and the subquery's result column.
1:eac0369: 	 *
1:eac0369: 	 * @param predicate		The predicate to add
1:eac0369: 	 *
1:eac0369: 	 * @return ResultSetNode	The new top of the tree.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     ResultSetNode addNewPredicate(Predicate predicate)
1:eac0369: 			throws StandardException
1:eac0369: 	{
1:eac0369: 		if (restrictionList == null)
1:eac0369: 		{
1:3bb140c:             restrictionList = new PredicateList(getContextManager());
1:eac0369: 		}
1:eac0369: 		restrictionList.addPredicate(predicate);
1:eac0369: 		return this;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Evaluate whether or not the subquery in a FromSubquery is flattenable.  
1:eac0369: 	 * Currently, a FSqry is flattenable if all of the following are true:
1:eac0369: 	 *		o  Subquery is a SelectNode. 
1:eac0369: 	 *		o  It contains no top level subqueries.  (RESOLVE - we can relax this)
1:eac0369: 	 *		o  It does not contain a group by or having clause
1:eac0369: 	 *		o  It does not contain aggregates.
1:eac0369: 	 *
1:eac0369: 	 * @param fromList	The outer from list
1:eac0369: 	 *
1:eac0369: 	 * @return boolean	Whether or not the FromSubquery is flattenable.
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     boolean flattenableInFromSubquery(FromList fromList)
1:eac0369: 	{
1:eac0369: 		/* Flattening currently involves merging predicates and FromLists.
1:eac0369: 		 * We don't have a FromList, so we can't flatten for now.
1:eac0369: 		 */
1:eac0369: 		/* RESOLVE - this will introduce yet another unnecessary PRN */
2:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Ensure that the top of the RSN tree has a PredicateList.
1:eac0369: 	 *
1:eac0369: 	 * @param numTables			The number of tables in the query.
1:eac0369: 	 * @return ResultSetNode	A RSN tree with a node which has a PredicateList on top.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     ResultSetNode ensurePredicateList(int numTables)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		return this;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Optimize this ProjectRestrictNode.  
1:eac0369: 	 *
1:eac0369: 	 * @param dataDictionary	The DataDictionary to use for optimization
1:6b50965: 	 * @param predicates		The PredicateList to optimize.  This should
1:eac0369: 	 *							be a join predicate.
1:eac0369: 	 * @param outerRows			The number of outer joining rows
1:eac0369: 	 *
1:eac0369: 	 * @return	ResultSetNode	The top of the optimized subtree
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     ResultSetNode optimize(DataDictionary dataDictionary,
1:eac0369: 								  PredicateList predicates,
1:eac0369: 								  double outerRows) 
1:eac0369: 					throws StandardException
1:eac0369: 	{
1:eac0369: 		/* We need to implement this method since a PRN can appear above a
1:eac0369: 		 * SelectNode in a query tree.
1:eac0369: 		 */
1:eac0369: 		childResult = childResult.optimize(dataDictionary,
1:eac0369: 											restrictionList,
1:eac0369: 											outerRows);
1:eac0369: 
1:eac0369: 		// RESOLVE: SHOULD FACTOR IN THE NON-OPTIMIZABLE PREDICATES THAT
1:eac0369: 		// WERE NOT PUSHED DOWN
1:11f7ee3:         setCostEstimate( getOptimizerFactory().getCostEstimate() );
1:eac0369: 
1:11f7ee3: 		getCostEstimate().setCost(childResult.getCostEstimate().getEstimatedCost(),
1:eac0369: 							childResult.getCostEstimate().rowCount(),
1:eac0369: 							childResult.getCostEstimate().singleScanRowCount());
1:eac0369: 
1:eac0369: 		return this;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the CostEstimate for this ProjectRestrictNode.
1:eac0369: 	 *
1:eac0369: 	 * @return	The CostEstimate for this ProjectRestrictNode, which is
1:eac0369: 	 * 			the cost estimate for the child node.
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     CostEstimate getCostEstimate()
1:eac0369: 	{
1:eac0369: 		/*
2:eac0369: 		** The cost estimate will be set here if either optimize() or
2:eac0369: 		** optimizeIt() was called on this node.  It's also possible
2:eac0369: 		** that optimization was done directly on the child node,
2:eac0369: 		** in which case the cost estimate will be null here.
1:eac0369: 		*/
1:11f7ee3: 		if (super.getCostEstimate() == null)
1:11f7ee3:         {
1:eac0369: 			return childResult.getCostEstimate();
1:11f7ee3:         }
1:eac0369: 		else
1:eac0369: 		{
1:11f7ee3: 			return super.getCostEstimate();
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the final CostEstimate for this ProjectRestrictNode.
1:eac0369: 	 *
1:eac0369: 	 * @return	The final CostEstimate for this ProjectRestrictNode, which is
1:eac0369: 	 * 			the final cost estimate for the child node.
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     CostEstimate getFinalCostEstimate()
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:11f7ee3: 		if (getCandidateFinalCostEstimate() != null)
1:11f7ee3:         {
1:11f7ee3:             // we already set it, so just return it.
1:11f7ee3: 			return getCandidateFinalCostEstimate();
1:11f7ee3:         }
1:eac0369: 
1:ab10884: 		// If the child result set is an Optimizable, then this node's
1:ab10884: 		// final cost is that of the child.  Otherwise, this node must
1:ab10884: 		// hold "trulyTheBestAccessPath" for it's child so we pull
1:ab10884: 		// the final cost from there.
1:ab10884: 		if (childResult instanceof Optimizable)
1:11f7ee3:         {
1:11f7ee3: 			setCandidateFinalCostEstimate( childResult.getFinalCostEstimate() );
1:11f7ee3:         }
1:eac0369: 		else
1:11f7ee3:         {
1:11f7ee3: 			setCandidateFinalCostEstimate( getTrulyTheBestAccessPath().getCostEstimate() );
1:11f7ee3:         }
1:eac0369: 
1:11f7ee3: 		return getCandidateFinalCostEstimate();
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * For joins, the tree will be (nodes are left out if the clauses
1:eac0369:      * are empty):
1:eac0369:      *
1:eac0369:      *      ProjectRestrictResultSet -- for the having and the select list
1:eac0369:      *      SortResultSet -- for the group by list
1:eac0369:      *      ProjectRestrictResultSet -- for the where and the select list (if no group or having)
1:eac0369:      *      the result set for the fromList
1:eac0369:      *
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369:      */
1:3bb140c:     @Override
1:8fe3166:     void generate(ActivationClassBuilder acb, MethodBuilder mb)
1:eac0369: 							throws StandardException
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:11f7ee3:             SanityManager.ASSERT(getResultColumns() != null, "Tree structure bad");
1:eac0369: 
1:7a9ce7e:         //
1:f6fa942:         // If we are projecting and restricting the stream from a table
1:f6fa942:         // function, then give the table function all of the information that
1:f6fa942:         // it needs in order to push the projection and qualifiers into
1:f6fa942:         // the table function. See DERBY-4357.
2:f6fa942:         //
1:f6fa942:         if ( childResult instanceof FromVTI )
1:f6fa942:         {
1:f6fa942:             ((FromVTI) childResult).computeProjectionAndRestriction( restrictionList );
1:f6fa942:         }
1:f6fa942: 
1:eac0369: 		generateMinion( acb, mb, false);
1:a2d0847: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * General logic shared by Core compilation.
1:eac0369: 	 *
1:6b50965: 	 * @param acb	The ExpressionClassBuilder for the class being built
1:eac0369: 	 * @param mb	The method the expression will go into
1:eac0369: 	 *
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 
1:3bb140c:     @Override
1:8fe3166:     void generateResultSet(ExpressionClassBuilder acb, MethodBuilder mb)
1:eac0369: 									throws StandardException
1:eac0369: 	{
1:eac0369: 		generateMinion( acb, mb, true);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Logic shared by generate() and generateResultSet().
1:eac0369: 	 *
1:6b50965: 	 * @param acb	The ExpressionClassBuilder for the class being built
1:eac0369: 	 * @param mb	The method the expression will go into
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	private void generateMinion(ExpressionClassBuilder acb,
1:eac0369: 									 MethodBuilder mb, boolean genChildResultSet)
1:eac0369: 									throws StandardException
1:a2d0847: 	{
1:eac0369: 		/* If this ProjectRestrict doesn't do anything, bypass its generation.
1:eac0369: 		 * (Remove any true and true predicates first, as they could be left
1:eac0369: 		 * by the like transformation.)
1:eac0369: 		 */
1:eac0369: 		if (restrictionList != null && restrictionList.size() > 0)
1:eac0369: 		{
1:eac0369: 			restrictionList.eliminateBooleanTrueAndBooleanTrue();
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (nopProjectRestrict())
1:eac0369: 		{
1:eac0369: 			generateNOPProjectRestrict();
1:eac0369: 			if (genChildResultSet)
1:eac0369: 				childResult.generateResultSet(acb, mb);
1:eac0369: 			else
1:eac0369: 				childResult.generate((ActivationClassBuilder)acb, mb);
1:11f7ee3: 			setCostEstimate( childResult.getFinalCostEstimate() );
1:eac0369: 			return;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// build up the tree.
1:eac0369: 
1:eac0369: 		/* Put the predicates back into the tree */
1:eac0369: 		if (restrictionList != null)
1:eac0369: 		{
1:eac0369: 			constantRestriction = restrictionList.restoreConstantPredicates();
1:eac0369: 			// Remove any redundant predicates before restoring
1:eac0369: 			restrictionList.removeRedundantPredicates();
1:eac0369: 			restriction = restrictionList.restorePredicates();
1:eac0369: 			/* Allow the restrictionList to get garbage collected now
1:eac0369: 			 * that we're done with it.
1:eac0369: 			 */
1:eac0369: 			restrictionList = null;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// for the restriction, we generate an exprFun
1:eac0369: 		// that evaluates the expression of the clause
1:eac0369: 		// against the current row of the child's result.
1:eac0369: 		// if the restriction is empty, simply pass null
1:eac0369: 		// to optimize for run time performance.
1:eac0369: 
1:eac0369:    		// generate the function and initializer:
1:eac0369:    		// Note: Boolean lets us return nulls (boolean would not)
1:eac0369:    		// private Boolean exprN()
1:eac0369:    		// {
1:eac0369:    		//   return <<restriction.generate(ps)>>;
1:eac0369:    		// }
1:eac0369:    		// static Method exprN = method pointer to exprN;
1:3527fd5: 
1:3527fd5: 
1:3527fd5: 
1:c723732: 
1:eac0369: 		// Map the result columns to the source columns
1:1d0c809: 
1:1d0c809:         ResultColumnList.ColumnMapping mappingArrays =
1:11f7ee3:             getResultColumns().mapSourceColumns();
1:1d0c809: 
1:1d0c809:         int[] mapArray = mappingArrays.mapArray;
1:1d0c809:         boolean[] cloneMap = mappingArrays.cloneMap;
1:1d0c809: 
1:eac0369: 		int mapArrayItem = acb.addItem(new ReferencedColumnsDescriptorImpl(mapArray));
1:1d0c809:         int cloneMapItem = acb.addItem(cloneMap);
1:eac0369: 
1:eac0369: 		/* Will this node do a projection? */
1:eac0369: 		boolean doesProjection = true;
1:eac0369: 
1:eac0369: 		/* Does a projection unless same # of columns in same order
1:eac0369: 		 * as child.
1:eac0369: 		 */
1:eac0369: 		if ( (! reflectionNeededForProjection()) && 
1:eac0369: 		    mapArray != null && 
1:eac0369: 			mapArray.length == childResult.getResultColumns().size())
1:eac0369: 		{
1:eac0369: 			/* mapArray entries are 1-based */
1:eac0369: 			int index = 0;
1:eac0369: 			for ( ; index < mapArray.length; index++)
1:eac0369: 			{
1:eac0369: 				if (mapArray[index] != index + 1)
1:eac0369: 				{
1:eac0369: 					break;
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 			if (index == mapArray.length)
1:eac0369: 			{
1:eac0369: 				doesProjection = false;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 		/* Generate the ProjectRestrictSet:
1:eac0369: 		 *	arg1: childExpress - Expression for childResultSet
1:eac0369: 		 *  arg2: Activation
1:eac0369: 		 *  arg3: restrictExpress - Expression for restriction
1:eac0369: 		 *  arg4: projectExpress - Expression for projection
1:eac0369: 		 *  arg5: resultSetNumber
1:eac0369: 		 *  arg6: constantExpress - Expression for constant restriction
1:eac0369: 		 *			(for example, where 1 = 2)
1:eac0369: 		 *  arg7: mapArrayItem - item # for mapping of source columns
1:1d0c809:          *  arg8: cloneMapItem - item # for mapping of columns that need cloning
1:1d0c809:          *  arg9: reuseResult - whether or not the result row can be reused
1:1d0c809:          *                      (ie, will it always be the same)
1:1d0c809:          *  arg10: doesProjection - does this node do a projection
1:1d0c809:          *  arg11: estimated row count
1:1d0c809:          *  arg12: estimated cost
1:1d0c809:          *  arg13: close method
1:1d0c809:          */
1:eac0369: 
1:eac0369: 		acb.pushGetResultSetFactoryExpression(mb);
1:eac0369: 		if (genChildResultSet)
1:eac0369: 			childResult.generateResultSet(acb, mb);
1:eac0369: 		else
1:eac0369: 			childResult.generate((ActivationClassBuilder)acb, mb);
1:eac0369: 
1:eac0369: 		/* Get the next ResultSet #, so that we can number this ResultSetNode, its
1:eac0369: 		 * ResultColumnList and ResultSet.
1:eac0369: 		 */
1:eac0369: 		assignResultSetNumber();
1:eac0369: 		
1:eac0369: 		/* Set the point of attachment in all subqueries attached
1:eac0369: 		 * to this node.
1:eac0369: 		 */
1:eac0369: 		if (projectSubquerys != null && projectSubquerys.size() > 0)
1:eac0369: 		{
1:11f7ee3: 			projectSubquerys.setPointOfAttachment(getResultSetNumber());
1:eac0369: 		}
1:eac0369: 		if (restrictSubquerys != null && restrictSubquerys.size() > 0)
1:eac0369: 		{
1:11f7ee3: 			restrictSubquerys.setPointOfAttachment(getResultSetNumber());
1:eac0369: 		}
1:eac0369: 
1:ab10884: 		// Load our final cost estimate.
1:11f7ee3: 		setCostEstimate( getFinalCostEstimate() );
1:eac0369: 
1:eac0369: 		// if there is no restriction, we just want to pass null.
1:eac0369: 		if (restriction == null)
1:eac0369: 		{
1:eac0369: 		   	mb.pushNull(ClassName.GeneratedMethod);
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			// this sets up the method and the static field.
1:eac0369: 			// generates:
1:eac0369: 			// 	Object userExprFun { }
1:eac0369: 			MethodBuilder userExprFun = acb.newUserExprFun();
1:eac0369: 
1:eac0369: 			// restriction knows it is returning its value;
1:eac0369: 
1:eac0369: 			/* generates:
1:eac0369: 			 *    return  <restriction.generate(acb)>;
1:eac0369: 			 * and adds it to userExprFun
1:eac0369: 			 * NOTE: The explicit cast to DataValueDescriptor is required
1:eac0369: 			 * since the restriction may simply be a boolean column or subquery
1:eac0369: 			 * which returns a boolean.  For example:
1:eac0369: 			 *		where booleanColumn
1:eac0369: 			 */
1:eac0369: 			restriction.generateExpression(acb, userExprFun);
1:eac0369: 			userExprFun.methodReturn();
1:eac0369: 
1:eac0369: 			// we are done modifying userExprFun, complete it.
1:eac0369: 			userExprFun.complete();
1:eac0369: 
1:eac0369: 	   		// restriction is used in the final result set as an access of the new static
1:eac0369:    			// field holding a reference to this new method.
1:eac0369: 			// generates:
1:eac0369: 			//	ActivationClass.userExprFun
1:eac0369: 			// which is the static field that "points" to the userExprFun
1:eac0369: 			// that evaluates the where clause.
1:eac0369:    			acb.pushMethodReference(mb, userExprFun);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* Determine whether or not reflection is needed for the projection.
1:eac0369: 		 * Reflection is not needed if all of the columns map directly to source
1:eac0369: 		 * columns.
1:eac0369: 		 */
1:eac0369: 		if (reflectionNeededForProjection())
1:eac0369: 		{
1:eac0369: 			// for the resultColumns, we generate a userExprFun
1:eac0369: 			// that creates a new row from expressions against
1:eac0369: 			// the current row of the child's result.
1:eac0369: 			// (Generate optimization: see if we can simply
1:eac0369: 			// return the current row -- we could, but don't, optimize
1:eac0369: 			// the function call out and have execution understand
1:eac0369: 			// that a null function pointer means take the current row
1:eac0369: 			// as-is, with the performance trade-off as discussed above.)
1:eac0369: 
1:eac0369: 			/* Generate the Row function for the projection */
1:11f7ee3: 			getResultColumns().generateCore(acb, mb, false);
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 		   	mb.pushNull(ClassName.GeneratedMethod);
1:eac0369: 		}
1:eac0369: 		
1:11f7ee3: 		mb.push(getResultSetNumber());
1:eac0369: 
1:eac0369: 		// if there is no constant restriction, we just want to pass null.
1:eac0369: 		if (constantRestriction == null)
1:eac0369: 		{
1:eac0369: 		   	mb.pushNull(ClassName.GeneratedMethod);
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			// this sets up the method and the static field.
1:eac0369: 			// generates:
1:eac0369: 			// 	userExprFun { }
1:eac0369: 			MethodBuilder userExprFun = acb.newUserExprFun();
1:eac0369: 
1:eac0369: 			// restriction knows it is returning its value;
1:eac0369: 
1:eac0369: 			/* generates:
1:eac0369: 			 *    return <restriction.generate(acb)>;
1:eac0369: 			 * and adds it to userExprFun
1:eac0369: 			 * NOTE: The explicit cast to DataValueDescriptor is required
1:eac0369: 			 * since the restriction may simply be a boolean column or subquery
1:eac0369: 			 * which returns a boolean.  For example:
1:eac0369: 			 *		where booleanColumn
1:eac0369: 			 */
1:eac0369: 			constantRestriction.generateExpression(acb, userExprFun);
1:eac0369: 
1:eac0369: 			userExprFun.methodReturn();
1:eac0369: 
1:eac0369: 			// we are done modifying userExprFun, complete it.
1:eac0369: 			userExprFun.complete();
1:eac0369: 
1:eac0369: 	   		// restriction is used in the final result set as an access
1:eac0369: 			// of the new static field holding a reference to this new method.
1:eac0369: 			// generates:
1:eac0369: 			//	ActivationClass.userExprFun
1:eac0369: 			// which is the static field that "points" to the userExprFun
1:eac0369: 			// that evaluates the where clause.
1:eac0369:    			acb.pushMethodReference(mb, userExprFun);
1:eac0369: 		}
1:eac0369: 		
1:eac0369: 		mb.push(mapArrayItem);
1:1d0c809:         mb.push(cloneMapItem);
1:11f7ee3: 		mb.push(getResultColumns().reusableResult());
1:eac0369: 		mb.push(doesProjection);
1:af1c18c:         mb.push(validatingCheckConstraints);
1:f6d02c9:         if ( validatingBaseTableUUIDString == null )
1:f6d02c9:         {
1:f6d02c9:             mb.push( UUID.NULL );
1:f6d02c9:         }
1:f6d02c9:         else
1:f6d02c9:         {
1:f6d02c9:             mb.push(validatingBaseTableUUIDString);
1:f6d02c9:         }
1:11f7ee3: 		mb.push(getCostEstimate().rowCount());
1:11f7ee3: 		mb.push(getCostEstimate().getEstimatedCost());
1:eac0369: 
1:eac0369: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, "getProjectRestrictResultSet",
1:af1c18c:                     ClassName.NoPutResultSet, 13);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Determine whether this ProjectRestrict does anything.  If it doesn't
1:eac0369: 	 * filter out any rows or columns, it's a No-Op.
1:eac0369: 	 *
1:eac0369: 	 * @return	true if this ProjectRestrict is a No-Op.
1:eac0369: 	 */
1:eac0369: 	boolean nopProjectRestrict()
1:eac0369: 	{
1:eac0369: 		/*
1:eac0369: 		** This ProjectRestrictNode is not a No-Op if it does any
1:eac0369: 		** restriction.
1:eac0369: 		*/
1:5825a32: 		if ( (restriction != null) || (constantRestriction != null) ||
1:eac0369: 			 (restrictionList != null && restrictionList.size() > 0) )
1:eac0369: 		{
1:eac0369: 			return false;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		ResultColumnList	childColumns = childResult.getResultColumns();
1:eac0369: 		ResultColumnList	PRNColumns = this.getResultColumns();
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** The two lists have the same numbers of elements.  Are the lists
1:eac0369: 		** identical?  In other words, is the expression in every ResultColumn
1:eac0369: 		** in the PRN's RCL a ColumnReference that points to the same-numbered
1:eac0369: 		** column?
1:eac0369: 		*/
1:eac0369: 		if (PRNColumns.nopProjection(childColumns))
1:eac0369: 			return true;
1:eac0369: 
1:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Bypass the generation of this No-Op ProjectRestrict, and just generate
1:eac0369: 	 * its child result set.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     void generateNOPProjectRestrict()
1:eac0369: 			throws StandardException
1:eac0369: 	{
1:eac0369: 		this.getResultColumns().setRedundant();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Consider materialization for this ResultSet tree if it is valid and cost effective
1:eac0369: 	 * (It is not valid if incorrect results would be returned.)
1:eac0369: 	 *
1:eac0369: 	 * @return Top of the new/same ResultSet tree.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     ResultSetNode considerMaterialization(JBitSet outerTables)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		childResult = childResult.considerMaterialization(outerTables);
1:eac0369: 		if (childResult.performMaterialization(outerTables))
1:eac0369: 		{
1:eac0369: 			MaterializeResultSetNode	mrsn;
1:eac0369: 			ResultColumnList			prRCList;
1:eac0369: 
1:eac0369: 			/* If the restriction contians a ColumnReference from another
1:eac0369: 			 * table then the MRSN must go above the childResult.  Otherwise we can put
1:eac0369: 			 * it above ourselves. (The later is optimal since projection and restriction 
1:eac0369: 			 * will only happen once.)
1:eac0369: 			 * Put MRSN above PRN if any of the following are true:
1:eac0369: 			 *	o  PRN doesn't have a restriction list
1:eac0369: 			 *	o  PRN's restriction list is empty 
1:eac0369: 			 *  o  Table's referenced in PRN's restriction list are a subset of
1:eac0369: 			 *	   table's referenced in PRN's childResult.  (NOTE: Rather than construct
1:eac0369: 			 *     a new, empty JBitSet before checking, we simply clone the childResult's
1:eac0369: 			 *	   referencedTableMap.  This is done for code simplicity and will not 
1:eac0369: 			 *	   affect the result.)
1:eac0369: 			 */
1:eac0369: 			ReferencedTablesVisitor rtv = new ReferencedTablesVisitor(
1:eac0369: 												(JBitSet) childResult.getReferencedTableMap().clone());
1:eac0369: 			boolean emptyRestrictionList = (restrictionList == null || restrictionList.size() == 0);
1:eac0369: 			if (! emptyRestrictionList)
1:eac0369: 			{
1:eac0369: 				restrictionList.accept(rtv);
1:eac0369: 			}
1:eac0369: 			if (emptyRestrictionList ||
1:eac0369: 				childResult.getReferencedTableMap().contains(rtv.getTableMap()))
1:eac0369: 			{
1:eac0369: 				/* We get a shallow copy of the ResultColumnList and its 
1:eac0369: 				 * ResultColumns.  (Copy maintains ResultColumn.expression for now.)
1:eac0369: 				 */
1:11f7ee3: 				prRCList = getResultColumns();
1:11f7ee3: 				setResultColumns(getResultColumns().copyListAndObjects());
1:eac0369: 
1:eac0369: 				/* Replace ResultColumn.expression with new VirtualColumnNodes
1:eac0369: 				 * in the NormalizeResultSetNode's ResultColumnList.  (VirtualColumnNodes include
1:eac0369: 				 * pointers to source ResultSetNode, this, and source ResultColumn.)
1:eac0369: 				 */
1:11f7ee3: 				prRCList.genVirtualColumnNodes(this, getResultColumns());
1:eac0369: 
2:eac0369: 				/* Finally, we create the new MaterializeResultSetNode */
1:3bb140c:                 mrsn = new MaterializeResultSetNode(
3:eac0369: 									this,
1:eac0369: 									prRCList,
2:eac0369: 									tableProperties,
8:eac0369: 									getContextManager());
1:eac0369: 				// Propagate the referenced table map if it's already been created
1:11f7ee3: 				if (getReferencedTableMap() != null)
1:eac0369: 				{
1:11f7ee3: 					mrsn.setReferencedTableMap((JBitSet) getReferencedTableMap().clone());
1:eac0369: 				}
1:eac0369: 				return mrsn;
1:eac0369: 			}
1:eac0369: 			else
1:eac0369: 			{
1:eac0369: 				/* We get a shallow copy of the ResultColumnList and its 
1:eac0369: 				 * ResultColumns.  (Copy maintains ResultColumn.expression for now.)
1:eac0369: 				 */
1:eac0369: 				prRCList = childResult.getResultColumns();
1:eac0369: 				childResult.setResultColumns(prRCList.copyListAndObjects());
1:eac0369: 
1:eac0369: 				/* Replace ResultColumn.expression with new VirtualColumnNodes
1:eac0369: 				 * in the MaterializeResultSetNode's ResultColumnList.  (VirtualColumnNodes include
1:eac0369: 				 * pointers to source ResultSetNode, this, and source ResultColumn.)
1:eac0369: 				 */
1:eac0369: 				prRCList.genVirtualColumnNodes(childResult, childResult.getResultColumns());
1:eac0369: 
1:eac0369: 				/* RESOLVE - we need to push single table predicates down so that
1:eac0369: 				 * they get applied while building the MaterializeResultSet.
1:eac0369: 				 */
1:eac0369: 
1:3bb140c:                 mrsn = new MaterializeResultSetNode(
2:eac0369: 									childResult,
1:eac0369: 									prRCList,
1:eac0369: 									tableProperties,
1:eac0369: 									getContextManager());
1:eac0369: 				// Propagate the referenced table map if it's already been created
1:eac0369: 				if (childResult.getReferencedTableMap() != null)
1:eac0369: 				{
1:eac0369: 					mrsn.setReferencedTableMap((JBitSet) childResult.getReferencedTableMap().clone());
1:eac0369: 				}
1:eac0369: 				childResult = mrsn;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return this;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** 
1:eac0369: 	 * Determine whether or not the specified name is an exposed name in
1:eac0369: 	 * the current query block.
1:eac0369: 	 *
1:eac0369: 	 * @param name	The specified name to search for as an exposed name.
1:eac0369: 	 * @param schemaName	Schema name, if non-null.
1:eac0369: 	 * @param exactMatch	Whether or not we need an exact match on specified schema and table
1:eac0369: 	 *						names or match on table id.
1:eac0369: 	 *
1:eac0369: 	 * @return The FromTable, if any, with the exposed name.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:8fe3166:     FromTable getFromTableByName(String name, String schemaName, boolean exactMatch)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		return childResult.getFromTableByName(name, schemaName, exactMatch);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the lock mode for the target of an update statement
1:eac0369: 	 * (a delete or update).  The update mode will always be row for
1:eac0369: 	 * CurrentOfNodes.  It will be table if there is no where clause.
1:eac0369: 	 *
1:eac0369: 	 * @return	The lock mode
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     int updateTargetLockMode()
1:eac0369: 	{
1:eac0369: 		if (restriction != null || constantRestriction != null)
1:eac0369: 		{
1:eac0369: 			return TransactionController.MODE_RECORD;
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return childResult.updateTargetLockMode();
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Is it possible to do a distinct scan on this ResultSet tree.
1:eac0369: 	 * (See SelectNode for the criteria.)
1:eac0369: 	 *
1:abbaf4e: 	 * @param distinctColumns the set of distinct columns
1:eac0369: 	 * @return Whether or not it is possible to do a distinct scan on this ResultSet tree.
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     boolean isPossibleDistinctScan(Set<BaseColumnNode> distinctColumns)
1:eac0369: 	{
1:eac0369: 		if (restriction != null || 
1:eac0369: 			(restrictionList != null && restrictionList.size() != 0))
1:eac0369: 		{
1:eac0369: 			return false;
1:eac0369: 		}
1:eac0369: 
1:71c8e86: 		HashSet<BaseColumnNode> columns = new HashSet<BaseColumnNode>();
1:e1f49ca: 
1:11f7ee3:         for (ResultColumn rc : getResultColumns()) {
1:abbaf4e: 			BaseColumnNode bc = rc.getBaseColumnNode();
1:abbaf4e: 			if (bc == null) return false;
1:abbaf4e: 			columns.add(bc);
1:eac0369: 		}
1:eac0369: 
1:abbaf4e: 		return columns.equals(distinctColumns) && childResult.isPossibleDistinctScan(distinctColumns);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Mark the underlying scan as a distinct scan.
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	void markForDistinctScan()
1:eac0369: 	{
1:eac0369: 		childResult.markForDistinctScan();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:dd2f5a8: 	 * Accept the visitor for all visitable children of this node.
1:eac0369: 	 * 
1:eac0369: 	 * @param v the visitor
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:dd2f5a8: 	void acceptChildren(Visitor v)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:dd2f5a8: 		super.acceptChildren(v);
1:eac0369: 
1:aebfb28: 		if (restriction != null)
1:eac0369: 		{
1:eac0369: 			restriction = (ValueNode)restriction.accept(v);
1:eac0369: 		}
1:eac0369: 
1:aebfb28: 		if (restrictionList != null)
1:eac0369: 		{
1:eac0369: 			restrictionList = (PredicateList)restrictionList.accept(v);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * set the Information gathered from the parent table that is 
1:28f9484:      * required to perform a referential action on dependent table.
1:eac0369: 	 */
1:3bb140c:     @Override
1:28f9484:     void setRefActionInfo(long fkIndexConglomId,
1:eac0369: 								 int[]fkColArray, 
1:eac0369: 								 String parentResultSetId,
1:eac0369: 								 boolean dependentScan)
1:eac0369: 	{
1:eac0369: 		childResult.setRefActionInfo(fkIndexConglomId,
1:eac0369: 								   fkColArray,
1:eac0369: 								   parentResultSetId,
1:eac0369: 								   dependentScan);
1:d5ef906: 	}
1:d5ef906: 
1:3bb140c:     void setRestriction(ValueNode restriction) {
1:d5ef906: 		this.restriction = restriction;
1:eac0369: 	}
1:eac0369: 
1:3bb140c:     @Override
1:b4cda60:     public void pushQueryExpressionSuffix() {
1:b4cda60:         childResult.pushQueryExpressionSuffix();
1:b4cda60:     }
1:b4cda60: 
1:b4cda60: 
1:eac0369: 	/**
1:2060c4a: 	 * Push the order by list down from InsertNode into its child result set so
1:2060c4a: 	 * that the optimizer has all of the information that it needs to consider
1:2060c4a: 	 * sort avoidance.
1:2060c4a: 	 *
1:2060c4a: 	 * @param orderByList	The order by list
1:2060c4a: 	 */
1:3bb140c:     @Override
1:2060c4a: 	void pushOrderByList(OrderByList orderByList)
1:2060c4a: 	{
1:2060c4a: 		childResult.pushOrderByList(orderByList);
1:2060c4a: 	}
1:2060c4a: 
1:108305b:     /**
1:108305b:      * Push down the offset and fetch first parameters, if any, to the
1:108305b:      * underlying child result set.
1:108305b:      *
1:108305b:      * @param offset    the OFFSET, if any
1:108305b:      * @param fetchFirst the OFFSET FIRST, if any
1:57c1b5c:      * @param hasJDBClimitClause true if the clauses were added by (and have the semantics of) a JDBC limit clause
1:108305b:      */
1:3bb140c:     @Override
1:57c1b5c:     void pushOffsetFetchFirst( ValueNode offset, ValueNode fetchFirst, boolean hasJDBClimitClause )
1:108305b:     {
1:57c1b5c:         childResult.pushOffsetFetchFirst( offset, fetchFirst, hasJDBClimitClause );
1:108305b:     }
1:af1c18c: 
1:f6d02c9:     void setValidatingCheckConstraints( String baseTableUUIDString ) {
1:af1c18c:         validatingCheckConstraints = true;
1:f6d02c9:         validatingBaseTableUUIDString = baseTableUUIDString;
1:af1c18c:     }
1:eac0369: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:f6d02c9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.catalog.UUID;
/////////////////////////////////////////////////////////////////////////
1:     private String validatingBaseTableUUIDString;
/////////////////////////////////////////////////////////////////////////
1:         if ( validatingBaseTableUUIDString == null )
1:         {
1:             mb.push( UUID.NULL );
1:         }
1:         else
1:         {
1:             mb.push(validatingBaseTableUUIDString);
1:         }
/////////////////////////////////////////////////////////////////////////
1:     void setValidatingCheckConstraints( String baseTableUUIDString ) {
1:         validatingBaseTableUUIDString = baseTableUUIDString;
commit:af1c18c
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Used with {@code validatingBaseTableCID} to validating deferred check
1:      * constraints.
1:      */
1:     private boolean validatingCheckConstraints = false;
0:     private long validatingBaseTableCID;
/////////////////////////////////////////////////////////////////////////
1:         if ((restrictionList != null) &&
1:             !alreadyPushed &&
1:             !hashJoinWithThisPRN &&
1:             !validatingCheckConstraints)
/////////////////////////////////////////////////////////////////////////
1:         mb.push(validatingCheckConstraints);
0:         mb.push(validatingBaseTableCID);
1:                     ClassName.NoPutResultSet, 13);
/////////////////////////////////////////////////////////////////////////
1: 
0:     void setValidatingCheckConstraints(long baseTableCID) {
1:         validatingCheckConstraints = true;
0:         validatingBaseTableCID = baseTableCID;
1:     }
commit:b4cda60
/////////////////////////////////////////////////////////////////////////
1:             if (childSelect.hasWindows() ||
1:                 childSelect.hasOffsetFetchFirst()) {
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     public void pushQueryExpressionSuffix() {
1:         childResult.pushQueryExpressionSuffix();
1:     }
1: 
1: 
commit:2706d1f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:e1f49ca
/////////////////////////////////////////////////////////////////////////
1:         for (Predicate p : searchRestrictionList) {
1:             requalificationRestrictionList.removeOptPredicate(p);
1:         }
1: 
1:         for (Predicate p : joinQualifierList) {
1:             requalificationRestrictionList.removeOptPredicate(p);
1:         }
/////////////////////////////////////////////////////////////////////////
1: 
0:         for (ResultColumn rc : resultColumns) {
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
1: import java.util.HashSet;
1: import java.util.Properties;
1: import java.util.Set;
1: import org.apache.derby.catalog.types.ReferencedColumnsDescriptorImpl;
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.reference.ClassName;
1: import org.apache.derby.iapi.services.classfile.VMOpcode;
1: import org.apache.derby.iapi.services.compiler.MethodBuilder;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.sql.compile.AccessPath;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
1: import org.apache.derby.iapi.sql.compile.CostEstimate;
1: import org.apache.derby.iapi.sql.compile.Visitor;
/////////////////////////////////////////////////////////////////////////
1: class ProjectRestrictNode extends SingleChildResultSetNode
1:     ValueNode   restriction;
/////////////////////////////////////////////////////////////////////////
1:     PredicateList restrictionList;
/////////////////////////////////////////////////////////////////////////
1:      * Constructor for a ProjectRestrictNode.
/////////////////////////////////////////////////////////////////////////
1:      * @param cm            The context manager
1:     ProjectRestrictNode(ResultSetNode    childResult,
1:                         ResultColumnList projection,
1:                         ValueNode        restriction,
1:                         PredicateList    restrictionList,
1:                         SubqueryList     projectSubquerys,
1:                         SubqueryList     restrictSubquerys,
1:                         Properties       tableProperties,
1:                         ContextManager   cm)
1:         super(childResult, tableProperties, cm);
0:         setNodeType(C_NodeTypes.PROJECT_RESTRICT_NODE);
0:         resultColumns = projection;
1:         this.restriction = restriction;
1:         this.restrictionList = restrictionList;
1:         this.projectSubquerys = projectSubquerys;
1:         this.restrictSubquerys = restrictSubquerys;
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:             restrictionList = new PredicateList(getContextManager());
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:                 new PredicateList(getContextManager());
1:                 new PredicateList(getContextManager());
1:                 new PredicateList(getContextManager());
/////////////////////////////////////////////////////////////////////////
1:         restrictionList = new PredicateList(getContextManager());
/////////////////////////////////////////////////////////////////////////
1:         childResult = new HashTableNode(childResult,
1:                                         tableProperties,
1:                                         htRCList,
1:                                         searchRestrictionList,
1:                                         joinQualifierList,
1:                                         trulyTheBestAccessPath,
1:                                         getCostEstimate(),
1:                                         projectSubquerys,
1:                                         restrictSubquerys,
1:                                         hashKeyColumns(),
1:                                         getContextManager());
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     void printSubNodes(int depth)
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     ResultSetNode preprocess(int numTables,
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     void pushExpressions(PredicateList predicateList)
/////////////////////////////////////////////////////////////////////////
1:         PredicateList pushPList =
0:                 predicateList.getPushablePredicates(referencedTableMap);
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     ResultSetNode addNewPredicate(Predicate predicate)
1:             restrictionList = new PredicateList(getContextManager());
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     boolean flattenableInFromSubquery(FromList fromList)
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     ResultSetNode ensurePredicateList(int numTables)
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     ResultSetNode optimize(DataDictionary dataDictionary,
/////////////////////////////////////////////////////////////////////////
0:         Optimizer opt = getOptimizer(
0:             new FromList(
0:                 getOptimizerFactory().doJoinOrderOptimization(),
1:                 this,
0:                 getContextManager()),
0:             predicates,
0:             dataDictionary,
0:             (RequiredRowOrdering) null);
0:         costEstimate = opt.newCostEstimate();
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     CostEstimate getCostEstimate()
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     CostEstimate getFinalCostEstimate()
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     void generateNOPProjectRestrict()
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     ResultSetNode considerMaterialization(JBitSet outerTables)
/////////////////////////////////////////////////////////////////////////
1:                 mrsn = new MaterializeResultSetNode(
/////////////////////////////////////////////////////////////////////////
1:                 mrsn = new MaterializeResultSetNode(
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     int updateTargetLockMode()
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     boolean isPossibleDistinctScan(Set<BaseColumnNode> distinctColumns)
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     void setRestriction(ValueNode restriction) {
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
commit:d35198d
/////////////////////////////////////////////////////////////////////////
1:             SelectNode childSelect = (SelectNode)childResult;
1:             // We can't push down if there is a window
1:             // function because that would make ROW_NUMBER give wrong
1:             // result:
1:             // E.g.
1:             //     SELECT * from (SELECT ROW_NUMBER() OVER (), j FROM T
1:             //                    ORDER BY j) WHERE j=5
1:             //
1:             // Similarly, don't push if we have OFFSET and/or FETCH FROM.
1:             //
0:             if ((childSelect.hasWindows() ||
0:                  childSelect.fetchFirst != null ||
0:                  childSelect.offset != null)){
1:             } else {
1:                 pushPList.pushExpressionsIntoSelect((SelectNode) childResult,
1:                                                     false);
1:             }
1:         }
commit:1d0c809
/////////////////////////////////////////////////////////////////////////
1: 
1:         ResultColumnList.ColumnMapping mappingArrays =
0:             resultColumns.mapSourceColumns();
1: 
1:         int[] mapArray = mappingArrays.mapArray;
1:         boolean[] cloneMap = mappingArrays.cloneMap;
1: 
1:         int cloneMapItem = acb.addItem(cloneMap);
/////////////////////////////////////////////////////////////////////////
1:          *  arg8: cloneMapItem - item # for mapping of columns that need cloning
1:          *  arg9: reuseResult - whether or not the result row can be reused
1:          *                      (ie, will it always be the same)
1:          *  arg10: doesProjection - does this node do a projection
1:          *  arg11: estimated row count
1:          *  arg12: estimated cost
1:          *  arg13: close method
1:          */
/////////////////////////////////////////////////////////////////////////
1:         mb.push(cloneMapItem);
0:                     ClassName.NoPutResultSet, 11);
commit:108305b
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Push down the offset and fetch first parameters, if any, to the
1:      * underlying child result set.
1:      *
1:      * @param offset    the OFFSET, if any
1:      * @param fetchFirst the OFFSET FIRST, if any
1:      */
0:     void pushOffsetFetchFirst(ValueNode offset, ValueNode fetchFirst)
1:     {
0:         childResult.pushOffsetFetchFirst(offset, fetchFirst);
1:     }
commit:2060c4a
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * Push the order by list down from InsertNode into its child result set so
1: 	 * that the optimizer has all of the information that it needs to consider
1: 	 * sort avoidance.
1: 	 *
1: 	 * @param orderByList	The order by list
1: 	 */
1: 	void pushOrderByList(OrderByList orderByList)
1: 	{
1: 		childResult.pushOrderByList(orderByList);
1: 	}
1: 
commit:7a9ce7e
/////////////////////////////////////////////////////////////////////////
1: 		if (pushPList != null &&
1: 				(childResult instanceof SelectNode))
0: 			SelectNode childSelect = (SelectNode)childResult;
1: 
0: 			if ( (childSelect.hasWindows()  &&
0: 				  childSelect.orderByList != null) ) {
0: 				// We can't push down if there is an ORDER BY and a window
0: 				// function because that would make ROW_NUMBER give wrong
0: 				// result:
0: 				// E.g.
0: 				//     SELECT * from (SELECT ROW_NUMBER() OVER (), j FROM T
0: 				//                    ORDER BY j) WHERE j=5
1: 				//
0: 			} else {
0: 				pushPList.pushExpressionsIntoSelect((SelectNode) childResult,
0: 													false);
1: 			}
1: 
commit:3527fd5
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		 */
0: 		if (pushPList != null && (childResult instanceof SelectNode))
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:11f7ee3
/////////////////////////////////////////////////////////////////////////
1:         setResultColumns( projection );
/////////////////////////////////////////////////////////////////////////
1: 		setCostEstimate( getCostEstimate( optimizer ) );
/////////////////////////////////////////////////////////////////////////
1: 			getCostEstimate().setCost(
/////////////////////////////////////////////////////////////////////////
1: 			childCost = childResult.getCostEstimate();
1: 			getCostEstimate().setCost(
/////////////////////////////////////////////////////////////////////////
1: 		return getCostEstimate();
/////////////////////////////////////////////////////////////////////////
1: 		setReferencedTableMap( (JBitSet) childResult.getReferencedTableMap().clone() );
/////////////////////////////////////////////////////////////////////////
1:             predicateList.getPushablePredicates(getReferencedTableMap());
/////////////////////////////////////////////////////////////////////////
1:         setCostEstimate( getOptimizerFactory().getCostEstimate() );
1: 		getCostEstimate().setCost(childResult.getCostEstimate().getEstimatedCost(),
/////////////////////////////////////////////////////////////////////////
1: 		if (super.getCostEstimate() == null)
1:         {
1:         }
1: 			return super.getCostEstimate();
/////////////////////////////////////////////////////////////////////////
1: 		if (getCandidateFinalCostEstimate() != null)
1:         {
1:             // we already set it, so just return it.
1: 			return getCandidateFinalCostEstimate();
1:         }
1:         {
1: 			setCandidateFinalCostEstimate( childResult.getFinalCostEstimate() );
1:         }
1:         {
1: 			setCandidateFinalCostEstimate( getTrulyTheBestAccessPath().getCostEstimate() );
1:         }
1: 		return getCandidateFinalCostEstimate();
/////////////////////////////////////////////////////////////////////////
1:             SanityManager.ASSERT(getResultColumns() != null, "Tree structure bad");
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 			setCostEstimate( childResult.getFinalCostEstimate() );
/////////////////////////////////////////////////////////////////////////
1:             getResultColumns().mapSourceColumns();
/////////////////////////////////////////////////////////////////////////
1: 			projectSubquerys.setPointOfAttachment(getResultSetNumber());
1: 			restrictSubquerys.setPointOfAttachment(getResultSetNumber());
1: 		setCostEstimate( getFinalCostEstimate() );
/////////////////////////////////////////////////////////////////////////
1: 			getResultColumns().generateCore(acb, mb, false);
1: 		mb.push(getResultSetNumber());
/////////////////////////////////////////////////////////////////////////
1: 		mb.push(getResultColumns().reusableResult());
1: 		mb.push(getCostEstimate().rowCount());
1: 		mb.push(getCostEstimate().getEstimatedCost());
/////////////////////////////////////////////////////////////////////////
1: 				prRCList = getResultColumns();
1: 				setResultColumns(getResultColumns().copyListAndObjects());
1: 				prRCList.genVirtualColumnNodes(this, getResultColumns());
/////////////////////////////////////////////////////////////////////////
1: 				if (getReferencedTableMap() != null)
1: 					mrsn.setReferencedTableMap((JBitSet) getReferencedTableMap().clone());
/////////////////////////////////////////////////////////////////////////
1:         for (ResultColumn rc : getResultColumns()) {
commit:6a270cb
/////////////////////////////////////////////////////////////////////////
0:         costEstimate = getOptimizerFactory().getCostEstimate();
commit:a56ecfa
/////////////////////////////////////////////////////////////////////////
0:             (RequiredRowOrdering) null,
0:             null );
commit:71c8e86
/////////////////////////////////////////////////////////////////////////
1: 		HashSet<BaseColumnNode> columns = new HashSet<BaseColumnNode>();
commit:57c1b5c
/////////////////////////////////////////////////////////////////////////
1:      * @param hasJDBClimitClause true if the clauses were added by (and have the semantics of) a JDBC limit clause
1:     void pushOffsetFetchFirst( ValueNode offset, ValueNode fetchFirst, boolean hasJDBClimitClause )
1:         childResult.pushOffsetFetchFirst( offset, fetchFirst, hasJDBClimitClause );
commit:f6fa942
/////////////////////////////////////////////////////////////////////////
1:         //
1:         // If we are projecting and restricting the stream from a table
1:         // function, then give the table function all of the information that
1:         // it needs in order to push the projection and qualifiers into
1:         // the table function. See DERBY-4357.
1:         //
1:         if ( childResult instanceof FromVTI )
1:         {
1:             ((FromVTI) childResult).computeProjectionAndRestriction( restrictionList );
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
commit:a2d0847
/////////////////////////////////////////////////////////////////////////
0:         //
0:         // If we are projecting and restricting the stream from a table
0:         // function, then give the table function all of the information that
0:         // it needs in order to push the projection and qualifiers into
0:         // the table function. See DERBY-4357.
0:         //
0:         if ( childResult instanceof FromVTI )
1:         {
0:             ((FromVTI) childResult).computeProjectionAndRestriction( resultColumns, restrictionList );
1:         }
commit:df88f63
/////////////////////////////////////////////////////////////////////////
1: 		Predicate pred = (Predicate)optimizablePredicate;
1: 
1: 		/* If the predicate is scoped then the call to "remapScopedPred()"
1: 		 * will do the necessary remapping for us and will return true;
1: 		 * otherwise, we'll just do the normal remapping here.
1: 		 */
1: 		if (!pred.remapScopedPred())
1: 		{
1: 			RemapCRsVisitor rcrv = new RemapCRsVisitor(true);
1: 			pred.getAndNode().accept(rcrv);
1: 		}
/////////////////////////////////////////////////////////////////////////
1: 			/* When we optimized the child we passed in our restriction list
1: 			 * so that scoped predicates could be pushed further down the
1: 			 * tree.  We need to do the same when modifying the access
1: 			 * paths to ensure we generate the same plans the optimizer
1: 			 * chose.
1: 			 */
1: 			childResult = childResult.modifyAccessPaths(restrictionList);
1: 
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:8fe3166
/////////////////////////////////////////////////////////////////////////
1:     void generate(ActivationClassBuilder acb, MethodBuilder mb)
/////////////////////////////////////////////////////////////////////////
1:     void generateResultSet(ExpressionClassBuilder acb, MethodBuilder mb)
/////////////////////////////////////////////////////////////////////////
1:     FromTable getFromTableByName(String name, String schemaName, boolean exactMatch)
commit:28f9484
/////////////////////////////////////////////////////////////////////////
1:      * required to perform a referential action on dependent table.
1:     void setRefActionInfo(long fkIndexConglomId,
commit:aebfb28
/////////////////////////////////////////////////////////////////////////
1: 		if (restriction != null)
1: 		if (restrictionList != null)
commit:dd2f5a8
/////////////////////////////////////////////////////////////////////////
1: 	 * Accept the visitor for all visitable children of this node.
1: 	void acceptChildren(Visitor v)
1: 		super.acceptChildren(v);
/////////////////////////////////////////////////////////////////////////
commit:5825a32
/////////////////////////////////////////////////////////////////////////
1: 		if ( (restriction != null) || (constantRestriction != null) ||
commit:7e23da1
/////////////////////////////////////////////////////////////////////////
1:         // DERBY-4001: Don't pull predicates if this node is part of a NOT
1:         // EXISTS join. For example, in the query below, if we allowed the
1:         // predicate 1<>1 (always false) to be pulled, no rows would be
1:         // returned, whereas it should return all the rows in table T.
1:         // SELECT * FROM T WHERE NOT EXISTS (SELECT * FROM T WHERE 1<>1)
1: 		if (restrictionList != null && !isNotExists())
author:Army
-------------------------------------------------------------------------------
commit:411d1b7
/////////////////////////////////////////////////////////////////////////
0: 			 * A DISTINCT query will place an additional DistinctNode on top of 
0: 			 * the window node:
0: 			 *    SELECT -> PRN -> PRN(noop) -> DN -> WN -> ...
0: 			 * The above two combinations are the only two possible from 
0: 			 * modifyAccessPaths() that require regeneration of the VCNs.
0: 				if (prn.childResult.getResultColumns()
0: 					.containsWindowFunctionResultColumn())
1: 				{
0: 					resultColumns.genVirtualColumnNodes(
0: 						prn.childResult, prn.childResult.getResultColumns());
commit:c723732
/////////////////////////////////////////////////////////////////////////
1: 			/*
0: 			 * If we have a subquery select with window function columns, we 
0: 			 * have the following simplified querytre before the above call:
0: 			 *    SELECT -> PRN -> SELECT
0: 			 * where middle PRN is what was originally a FromSubquery node.
0: 			 * With window functions we pull any WindowNodes into the tree, 
0: 			 * modify the lower selects RCL, and put a (noop) PRN on top in the 
0: 			 * above call. This results in:
0: 			 *    SELECT -> PRN -> PRN(noop) -> WN -> ...			 
0: 			 * Note that the RCL for the initial PRN and its child SELECT used 
0: 			 * to be the same object. After the above call, the initial PRNs RCL 
0: 			 * is incorrect, and we need to regenerate the VCNs. 
1: 			 */
0: 			if (childResult instanceof ProjectRestrictNode){
0: 				ProjectRestrictNode prn = (ProjectRestrictNode) childResult;
0: 				if (prn.childResult instanceof WindowNode){
1: 					/* 
0: 					 * We have a window function column in the RCL of our child 
0: 					 * PRN, and need to regenerate the VCNs.
1: 					 */					
0: 					resultColumns.genVirtualColumnNodes( prn.childResult, 
0: 														 prn.childResult.getResultColumns() );
1: 				}
1: 			}
1: 			
/////////////////////////////////////////////////////////////////////////
1: 		 */			
0: 		if (pushPList != null && 
0: 			childResult instanceof SelectNode &&
0: 			!resultColumns.containsWindowFunctionResultColumn() )
/////////////////////////////////////////////////////////////////////////
1: 	
/////////////////////////////////////////////////////////////////////////
1: 		
commit:d5ef906
/////////////////////////////////////////////////////////////////////////
0: 	public void setRestriction(ValueNode restriction) {
1: 		this.restriction = restriction;
1: 	}
1: 
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:9e6e461
/////////////////////////////////////////////////////////////////////////
0: 					ClassName.NoPutResultSet, 10);
commit:acdff3c
/////////////////////////////////////////////////////////////////////////
1: 		updateBestPlanMap(ADD_PLAN, this);
commit:6b26ee1
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 					ClassName.NoPutResultSet, 11);
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.compile.ProjectRestrictNode
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:61070a6
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package	org.apache.derby.impl.sql.compile;
1: 
1: import org.apache.derby.iapi.services.context.ContextManager;
1: 
1: import org.apache.derby.iapi.sql.compile.Optimizable;
1: import org.apache.derby.iapi.sql.compile.OptimizablePredicate;
1: import org.apache.derby.iapi.sql.compile.OptimizablePredicateList;
1: import org.apache.derby.iapi.sql.compile.Optimizer;
0: import org.apache.derby.iapi.sql.compile.CostEstimate;
0: import org.apache.derby.iapi.sql.compile.OptimizableList;
0: import org.apache.derby.iapi.sql.compile.Visitable;
0: import org.apache.derby.iapi.sql.compile.Visitor;
1: import org.apache.derby.iapi.sql.compile.RequiredRowOrdering;
1: import org.apache.derby.iapi.sql.compile.RowOrdering;
0: import org.apache.derby.iapi.sql.compile.AccessPath;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
1: 
1: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
1: 
0: import org.apache.derby.iapi.types.DataValueDescriptor;
1: 
0: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
1: 
0: import org.apache.derby.iapi.sql.Activation;
0: import org.apache.derby.iapi.sql.ResultSet;
1: 
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.reference.ClassName;
1: 
1: import org.apache.derby.iapi.store.access.TransactionController;
1: 
0: import org.apache.derby.impl.sql.compile.ExpressionClassBuilder;
0: import org.apache.derby.impl.sql.compile.ActivationClassBuilder;
1: 
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1: 
0: import org.apache.derby.iapi.services.loader.GeneratedMethod;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
0: import org.apache.derby.catalog.types.ReferencedColumnsDescriptorImpl;
1: import org.apache.derby.iapi.util.JBitSet;
0: import org.apache.derby.iapi.services.classfile.VMOpcode;
1: 
0: import java.util.Properties;
1: 
1: /**
1:  * A ProjectRestrictNode represents a result set for any of the basic DML
1:  * operations: SELECT, INSERT, UPDATE, and DELETE.  For INSERT with
1:  * a VALUES clause, restriction will be null. For both INSERT and UPDATE,
1:  * the resultColumns in the selectList will contain the names of the columns
1:  * being inserted into or updated.
1:  *
1:  * NOTE: A ProjectRestrictNode extends FromTable since it can exist in a FromList.
1:  *
0:  * @author Jeff Lichtman
1:  */
1: 
0: public class ProjectRestrictNode extends SingleChildResultSetNode
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 	/**
1: 	 * The ValueNode for the restriction to be evaluated here.
1: 	 */
0: 	public ValueNode	restriction;
1: 
1: 	/**
1: 	 * Constant expressions to be evaluated here.
1: 	 */
1: 	ValueNode	constantRestriction = null;
1: 
1: 	/**
1: 	 * Restriction as a PredicateList
1: 	 */
0: 	public PredicateList restrictionList;
1: 
1: 	/**
1: 	 * List of subqueries in projection
1: 	 */
1: 	SubqueryList projectSubquerys;
1: 
1: 	/**
1: 	 * List of subqueries in restriction
1: 	 */
1: 	SubqueryList restrictSubquerys;
1: 
1: 	private boolean accessPathModified;
1: 
0: 	private boolean accessPathConsidered;
1: 
0: 	private boolean childResultOptimized;
1: 
0: 	private boolean materialize;
1: 
1: 	/* Should we get the table number from this node,
1: 	 * regardless of the class of our child.
1: 	 */
1: 	private boolean getTableNumberHere;
1: 
1: 	/**
0: 	 * Initializer for a ProjectRestrictNode.
1: 	 *
1: 	 * @param childResult	The child ResultSetNode
1: 	 * @param projection	The result column list for the projection
1: 	 * @param restriction	An expression representing the restriction to be 
1: 	 *					    evaluated here.
1: 	 * @param restrictionList Restriction as a PredicateList
1: 	 * @param projectSubquerys List of subqueries in the projection
1: 	 * @param restrictSubquerys List of subqueries in the restriction
1: 	 * @param tableProperties	Properties list associated with the table
1: 	 */
1: 
0: 	public void init(
0: 							Object childResult,
0: 			 				Object projection,
0: 							Object restriction,
0: 							Object restrictionList,
0: 							Object projectSubquerys,
0: 							Object restrictSubquerys,
0: 							Object tableProperties)
1: 	{
0: 		super.init(childResult, tableProperties);
0: 		resultColumns = (ResultColumnList) projection;
0: 		this.restriction = (ValueNode) restriction;
0: 		this.restrictionList = (PredicateList) restrictionList;
0: 		this.projectSubquerys = (SubqueryList) projectSubquerys;
0: 		this.restrictSubquerys = (SubqueryList) restrictSubquerys;
1: 
1: 		/* A PRN will only hold the tableProperties for
1: 		 * a result set tree if its child is not an
1: 		 * optimizable.  Otherwise, the properties will
1: 		 * be transferred down to the child.
1: 		 */
1: 		if (tableProperties != null &&
1: 			 (childResult instanceof Optimizable))
1: 		{
1: 			((Optimizable) childResult).setProperties(getProperties());
1: 			setProperties((Properties) null);
1: 		}
1: 	}
1: 
1: 	/*
1: 	 *  Optimizable interface
1: 	 */
1: 
1: 	/**
1: 		@see Optimizable#nextAccessPath
1: 		@exception StandardException	Thrown on error
1: 	 */
1: 	public boolean nextAccessPath(Optimizer optimizer,
1: 									OptimizablePredicateList predList,
1: 									RowOrdering rowOrdering)
1: 			throws StandardException
1: 	{
1: 		/*
1: 		** If the child result set is an optimizable, let it choose its next
1: 		** access path.  If it is not an optimizable, we have to tell the
1: 		** caller that there is an access path the first time we are called
1: 		** for this position in the join order, and that there are no more
1: 		** access paths for subsequent calls for this position in the join
1: 		** order.  The startOptimizing() method is called once on each
1: 		** optimizable when it is put into a join position.
1: 		*/
1: 		if (childResult instanceof Optimizable)
1: 		{
1: 			return ((Optimizable) childResult).nextAccessPath(optimizer,
1: 																restrictionList,
1: 																rowOrdering);
1: 		}
1: 		else
1: 		{
1: 			return super.nextAccessPath(optimizer, predList, rowOrdering);
1: 		}
1: 	}
1: 
1: 	/** @see Optimizable#rememberAsBest 
1: 		@exception StandardException	Thrown on error
1: 	 */
0: 	public void rememberAsBest(int planType)
1: 		throws StandardException
1: 	{
0: 		super.rememberAsBest(planType);
1: 		if (childResult instanceof Optimizable)
0: 			((Optimizable) childResult).rememberAsBest(planType);
1: 	}
1: 
0: 	/* Don't print anything for a PRN, as their
0: 	 * child has the interesting info.
1: 	 */
0: 	void printRememberingBestAccessPath(int planType, AccessPath bestPath)
1: 	{
1: 	}
1: 
1: 	/** @see Optimizable#startOptimizing */
1: 	public void startOptimizing(Optimizer optimizer, RowOrdering rowOrdering)
1: 	{
1: 		if (childResult instanceof Optimizable)
1: 		{
1: 			((Optimizable) childResult).startOptimizing(optimizer, rowOrdering);
1: 		}
1: 		else
1: 		{
0: 			accessPathConsidered = false;
1: 
1: 			super.startOptimizing(optimizer, rowOrdering);
1: 		}
1: 	}
1: 
1: 	/** @see Optimizable#getTableNumber */
1: 	public int getTableNumber()
1: 	{
1: 		/* GROSS HACK - We need to get the tableNumber after
1: 		 * calling modifyAccessPaths() on the child when doing
1: 		 * a hash join on an arbitrary result set.  The problem
1: 		 * is that the child will always be an optimizable at this
1: 		 * point.  So, we 1st check to see if we should get it from
1: 		 * this node.  (We set the boolean to true in the appropriate
1: 		 * place in modifyAccessPaths().)
1: 		 */
1: 		if (getTableNumberHere)
1: 		{
1: 			return super.getTableNumber();
1: 		}
1: 
1: 		if (childResult instanceof Optimizable)
1: 			return ((Optimizable) childResult).getTableNumber();
1: 
1: 		return super.getTableNumber();
1: 	}
1: 
1: 	/**
1: 	 * @see Optimizable#optimizeIt
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public CostEstimate optimizeIt(
1: 							Optimizer optimizer,
1: 							OptimizablePredicateList predList,
1: 							CostEstimate outerCost,
1: 							RowOrdering rowOrdering)
1: 			throws StandardException
1: 	{
1: 		/*
1: 		** RESOLVE: Most types of Optimizables only implement estimateCost(),
1: 		** and leave it up to optimizeIt() in FromTable to figure out the
1: 		** total cost of the join.  A ProjectRestrict can have a non-Optimizable
1: 		** child, though, in which case we want to tell the child the
1: 		** number of outer rows - it could affect the join strategy
1: 		** significantly.  So we implement optimizeIt() here, which overrides
1: 		** the optimizeIt() in FromTable.  This assumes that the join strategy
1: 		** for which this join node is the inner table is a nested loop join,
1: 		** which will not be a valid assumption when we implement other
1: 		** strategies like materialization (hash join can work only on
1: 		** base tables).  The join strategy for a base table under a
1: 		** ProjectRestrict is set in the base table itself.
1: 		*/
1: 
1: 		CostEstimate childCost;
1: 
0: 		costEstimate = getCostEstimate(optimizer);
1: 
1: 		/*
1: 		** Don't re-optimize a child result set that has already been fully
1: 		** optimized.  For example, if the child result set is a SelectNode,
1: 		** it will be changed to a ProjectRestrictNode, which we don't want
1: 		** to re-optimized.
1: 		*/
1: 		// NOTE: TO GET THE RIGHT COST, THE CHILD RESULT MAY HAVE TO BE
1: 		// OPTIMIZED MORE THAN ONCE, BECAUSE THE NUMBER OF OUTER ROWS
1: 		// MAY BE DIFFERENT EACH TIME.
1: 		// if (childResultOptimized)
1: 		// 	return costEstimate;
1: 
1: 		/* If the childResult is instanceof Optimizable, then we optimizeIt.
1: 		 * Otherwise, we are going into a new query block.  If the new query
1: 		 * block has already had its access path modified, then there is
1: 		 * nothing to do.  Otherwise, we must begin the optimization process
1: 		 * anew on the new query block.
1: 		 */
1: 		if (childResult instanceof Optimizable)
1: 		{
1: 			childCost = ((Optimizable) childResult).optimizeIt(
1: 															optimizer,
1: 															restrictionList,
1: 															outerCost,
1: 															rowOrdering);
1: 			/* Copy child cost to this node's cost */
0: 			costEstimate.setCost(
1: 							childCost.getEstimatedCost(),
1: 							childCost.rowCount(),
1: 							childCost.singleScanRowCount());
1: 
1: 			optimizer.considerCost(this, restrictionList, getCostEstimate(), outerCost);
1: 		}
1: 		else if ( ! accessPathModified)
1: 		{
1: 			if (SanityManager.DEBUG)
1: 			{
1: 				if (! ((childResult instanceof SelectNode) ||
1: 								 (childResult instanceof RowResultSetNode)))
1: 				{
1: 					SanityManager.THROWASSERT(
1: 						"childResult is expected to be instanceof " +
1: 						"SelectNode or RowResultSetNode - it is a " +
1: 						childResult.getClass().getName());
1: 				}
1: 			}
1: 			childResult = childResult.optimize(optimizer.getDataDictionary(), 
1: 											   restrictionList,
1: 											   outerCost.rowCount());
1: 
1: 			/* Copy child cost to this node's cost */
0: 			childCost = childResult.costEstimate;
1: 
0: 			costEstimate.setCost(
1: 							childCost.getEstimatedCost(),
1: 							childCost.rowCount(),
1: 							childCost.singleScanRowCount());
1: 
0: 			getBestAccessPath().setCostEstimate(costEstimate);
1: 
1: 			/*
0: 			** The current access path may not be part of a sort avoidance
0: 			** path, but set the cost estimate there anyway, just in case
0: 			** it is.
1: 			*/
0: 			getBestSortAvoidancePath().setCostEstimate(costEstimate);
1: 
1: 			// childResultOptimized = true;
1: 
1: 			/* RESOLVE - ARBITRARYHASHJOIN - Passing restriction list here, as above, is correct.
1: 			 * However,  passing predList makes the following work:
1: 			 *	select * from t1, (select * from t2) c properties joinStrategy = hash where t1.c1 = c.c1;
1: 			 * The following works with restrictionList:
1: 			 *	select * from t1, (select c1 + 0 from t2) c(c1) properties joinStrategy = hash where t1.c1 = c.c1;
1: 			 */
1: 			optimizer.considerCost(this, restrictionList, getCostEstimate(), outerCost);
1: 		}
1: 
0: 		return costEstimate;
1: 	}
1: 
1: 	/**
1: 	 * @see Optimizable#feasibleJoinStrategy
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public boolean feasibleJoinStrategy(OptimizablePredicateList predList,
1: 										Optimizer optimizer)
1: 					throws StandardException
1: 	{
1: 		AccessPath ap;
1: 
1: 		/* The child being an Optimizable is a special case.  In that
1: 		 * case, we want to get the current access path and join strategy
1: 		 * from the child.  Otherwise, we want to get it from this node.
1: 		 */
1: 		if (childResult instanceof Optimizable)
1: 		{
0: 			return ((Optimizable) childResult).feasibleJoinStrategy(restrictionList, optimizer);
1: 		}
1: 		else
1: 		{
1: 			return super.feasibleJoinStrategy(restrictionList, optimizer);
1: 		}
1: 	}
1: 
1: 	/** @see Optimizable#getCurrentAccessPath */
1: 	public AccessPath getCurrentAccessPath()
1: 	{
1: 		if (childResult instanceof Optimizable)
1: 			return ((Optimizable) childResult).getCurrentAccessPath();
1: 
1: 		return super.getCurrentAccessPath();
1: 	}
1: 
1: 	/** @see Optimizable#getBestAccessPath */
1: 	public AccessPath getBestAccessPath()
1: 	{
1: 		if (childResult instanceof Optimizable)
1: 			return ((Optimizable) childResult).getBestAccessPath();
1: 
1: 		return super.getBestAccessPath();
1: 	}
1: 
1: 	/** @see Optimizable#getBestSortAvoidancePath */
1: 	public AccessPath getBestSortAvoidancePath()
1: 	{
1: 		if (childResult instanceof Optimizable)
1: 			return ((Optimizable) childResult).getBestSortAvoidancePath();
1: 
1: 		return super.getBestSortAvoidancePath();
1: 	}
1: 
1: 	/** @see Optimizable#getTrulyTheBestAccessPath */
1: 	public AccessPath getTrulyTheBestAccessPath()
1: 	{
1: 		/* The childResult will always be an Optimizable
1: 		 * during code generation.  If the childResult was
1: 		 * not an Optimizable during optimization, then this node
1: 		 * will have the truly the best access path, so we want to
1: 		 * return it from this node, rather than traversing the tree.
1: 		 * This can happen for non-flattenable derived tables.
1: 		 * Anyway, we note this state when modifying the access paths.
1: 		 */
1: 		if (hasTrulyTheBestAccessPath)
1: 		{
1: 			return super.getTrulyTheBestAccessPath();
1: 		}
1: 
1: 		if (childResult instanceof Optimizable)
1: 			return ((Optimizable) childResult).getTrulyTheBestAccessPath();
1: 
1: 		return super.getTrulyTheBestAccessPath();
1: 	}
1: 
1: 	/** @see Optimizable#rememberSortAvoidancePath */
1: 	public void rememberSortAvoidancePath()
1: 	{
1: 		if (childResult instanceof Optimizable)
1: 			((Optimizable) childResult).rememberSortAvoidancePath();
1: 		else
1: 			super.rememberSortAvoidancePath();
1: 	}
1: 
1: 	/** @see Optimizable#considerSortAvoidancePath */
1: 	public boolean considerSortAvoidancePath()
1: 	{
1: 		if (childResult instanceof Optimizable)
1: 			return ((Optimizable) childResult).considerSortAvoidancePath();
1: 
1: 		return super.considerSortAvoidancePath();
1: 	}
1: 
1: 	/**
1: 	 * @see Optimizable#pushOptPredicate
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
1: 	public boolean pushOptPredicate(OptimizablePredicate optimizablePredicate)
1: 			throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(optimizablePredicate instanceof Predicate,
1: 				"optimizablePredicate expected to be instanceof Predicate");
1: 			SanityManager.ASSERT(! optimizablePredicate.hasSubquery() &&
1: 								 ! optimizablePredicate.hasMethodCall(),
1: 				"optimizablePredicate either has a subquery or a method call");
1: 		}
1: 
1: 		/* Add the matching predicate to the restrictionList */
1: 		if (restrictionList == null)
1: 		{
0: 			restrictionList = (PredicateList) getNodeFactory().getNode(
0: 													C_NodeTypes.PREDICATE_LIST,
1: 													getContextManager());
1: 		}
1: 		restrictionList.addPredicate((Predicate) optimizablePredicate);
1: 
1: 		/* Remap all of the ColumnReferences to point to the
1: 		 * source of the values.
1: 		 */
1: 		RemapCRsVisitor rcrv = new RemapCRsVisitor(true);
0: 		((Predicate) optimizablePredicate).getAndNode().accept(rcrv);
1: 
1: 		return true;
1: 	}
1: 
1: 	/**
1: 	 * @see Optimizable#pullOptPredicates
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public void pullOptPredicates(
1: 								OptimizablePredicateList optimizablePredicates)
1: 					throws StandardException
1: 	{
1: 		if (restrictionList != null)
1: 		{
1: 			RemapCRsVisitor rcrv = new RemapCRsVisitor(false);
1: 			for (int i = restrictionList.size() - 1; i >= 0; i--)
1: 			{
1: 				OptimizablePredicate optPred =
1: 					restrictionList.getOptPredicate(i);
1: 				((Predicate) optPred).getAndNode().accept(rcrv);
1: 				optimizablePredicates.addOptPredicate(optPred);
1: 				restrictionList.removeOptPredicate(i);
1: 			}
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * @see Optimizable#modifyAccessPath
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public Optimizable modifyAccessPath(JBitSet outerTables) 
1: 		throws StandardException
1: 	{
1: 		boolean origChildOptimizable = true;
1: 
1: 		/* It is okay to optimize most nodes multiple times.  However,
1: 		 * modifying the access path is something that should only be done
1: 		 * once per node.  One reason for this is that the predicate list
1: 		 * will be empty after the 1st call, and we assert that it should
1: 		 * be non-empty.  Multiple calls to modify the access path can
1: 		 * occur when there is a non-flattenable FromSubquery (or view).
1: 		 */
1: 		if (accessPathModified)
1: 		{
1: 			return this;
1: 		}
1: 
1: 		/*
1: 		** Do nothing if the child result set is not optimizable, as there
1: 		** can be nothing to modify.
1: 		*/
1: 		if ( ! (childResult instanceof Optimizable))
1: 		{
1: 			// Remember that the original child was not Optimizable
1: 			origChildOptimizable = false;
1: 
0: 			childResult = childResult.modifyAccessPaths();
1: 			/* Mark this node as having the truly ... for
1: 			 * the underlying tree.
1: 			 */
1: 			hasTrulyTheBestAccessPath = true;
1: 
1: 			/* Replace this PRN with a HRN if we are doing a hash join */
1: 			if (trulyTheBestAccessPath.getJoinStrategy().isHashJoin())
1: 			{
1: 				if (SanityManager.DEBUG)
1: 				{
1: 					SanityManager.ASSERT(restrictionList != null,
1: 						"restrictionList expected to be non-null");
1: 					SanityManager.ASSERT(restrictionList.size() != 0,
1: 							"restrictionList.size() expected to be non-zero");
1: 				}
1: 				/* We're doing a hash join on an arbitary result set.
1: 				 * We need to get the table number from this node when
1: 				 * dividing up the restriction list for a hash join.
1: 				 * We need to explicitly remember this.
1: 				 */
1: 				getTableNumberHere = true;
1: 			}
1: 			else
1: 			{
1: 				/* We consider materialization into a temp table as a last step.
1: 				 * Currently, we only materialize VTIs that are inner tables
1: 				 * and can't be instantiated multiple times.  In the future we
1: 				 * will consider materialization as a cost based option.
1: 				 */
1: 				return (Optimizable) considerMaterialization(outerTables);
1: 			}
1: 		}
1: 
1: 		/* If the child is not a FromBaseTable, then we want to
1: 		 * keep going down the tree.  (Nothing to do at this node.)
1: 		 */
1: 		else if (!(childResult instanceof FromBaseTable))
1: 		{
1: 			/* Make sure that we have a join strategy */
1: 			if (trulyTheBestAccessPath.getJoinStrategy() == null)
1: 			{
1: 				trulyTheBestAccessPath = (AccessPathImpl) ((Optimizable) childResult).getTrulyTheBestAccessPath();
1: 			}
1: 			childResult = 
0: 				(ResultSetNode)
0: 					((FromTable) childResult).modifyAccessPath(outerTables);
1: 		}
1: 
1: 		if (restrictionList != null)
1: 		{
1: 			restrictionList.pushUsefulPredicates((Optimizable) childResult);
1: 		}
1: 
1: 		/*
1: 		** The optimizer's decision on the access path for the child result
1: 		** set may require the generation of extra result sets.  For
1: 		** example, if it chooses an index, we need an IndexToBaseRowNode
1: 		** above the FromBaseTable (and the FromBaseTable has to change
1: 		** its column list to match that of the index.
1: 		*/
1: 		if (origChildOptimizable)
1: 		{
1: 			childResult = childResult.changeAccessPath();
1: 		}
1: 		accessPathModified = true;
1: 
1: 		/*
1: 		** Replace this PRN with a HTN if a hash join
1: 		** is being done at this node.  (Hash join on a scan
1: 		** is a special case and is handled at the FBT.)
1: 		*/
1: 		if (trulyTheBestAccessPath.getJoinStrategy() != null &&
1: 			trulyTheBestAccessPath.getJoinStrategy().isHashJoin())
1: 		{
1: 			return replaceWithHashTableNode();
1: 		}
1: 
1: 		/* We consider materialization into a temp table as a last step.
1: 		 * Currently, we only materialize VTIs that are inner tables
1: 		 * and can't be instantiated multiple times.  In the future we
1: 		 * will consider materialization as a cost based option.
1: 		 */
1: 		return (Optimizable) considerMaterialization(outerTables);
1: 	}
1: 
1: 	/**
1: 	 * This method creates a HashTableNode between the PRN and
1: 	 * it's child when the optimizer chooses hash join on an
1: 	 * arbitrary (non-FBT) result set tree.
1: 	 * We divide up the restriction list into 3 parts and
1: 	 * distribute those parts as described below.
1: 	 * 
1: 	 * @return The new (same) top of our result set tree.
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	private Optimizable replaceWithHashTableNode()
1: 		throws StandardException
1: 	{
1: 		/* We want to divide the predicate list into 3 separate lists -
1: 		 *	o predicates against the source of the hash table, which will
1: 		 *	  be applied on the way into the hash table (searchRestrictionList)
1: 		 *  o join clauses which are qualifiers and get applied to the
1: 		 *	  rows in the hash table on a probe (joinRestrictionList)
1: 		 *	o non-qualifiers involving both tables which will get
1: 		 *	  applied after a row gets returned from the HTRS (nonQualifiers)
1: 		 *
1: 		 * We do some unnecessary work when doing this as we want to reuse
1: 		 * as much existing code as possible.  The code that we are reusing
1: 		 * was originally built for hash scans, hence the unnecessary
1: 		 * requalification list.
1: 		 */
1: 		PredicateList searchRestrictionList =
0: 								(PredicateList) getNodeFactory().getNode(
0: 													C_NodeTypes.PREDICATE_LIST,
1: 													getContextManager());
1: 		PredicateList joinQualifierList =
0: 								(PredicateList) getNodeFactory().getNode(
0: 													C_NodeTypes.PREDICATE_LIST,
1: 													getContextManager());
1: 		PredicateList requalificationRestrictionList =
0: 								(PredicateList) getNodeFactory().getNode(
0: 													C_NodeTypes.PREDICATE_LIST,
1: 													getContextManager());
1: 		trulyTheBestAccessPath.getJoinStrategy().divideUpPredicateLists(
1: 											this,
1: 											restrictionList,
1: 											searchRestrictionList,
1: 											joinQualifierList,
1: 											requalificationRestrictionList,
1: 											getDataDictionary());
1: 
1: 		/* Break out the non-qualifiers from HTN's join qualifier list and make that
1: 		 * the new restriction list for this PRN.
1: 		 */
0: 		restrictionList = (PredicateList) getNodeFactory().getNode(
0: 											C_NodeTypes.PREDICATE_LIST,
1: 											getContextManager());
1:         /* For non-base table, we remove first 2 lists from requal list to avoid adding duplicates.
1:          */
0: 		for (int i = 0; i < searchRestrictionList.size(); i++)
0: 			requalificationRestrictionList.removeOptPredicate((Predicate) searchRestrictionList.elementAt(i));
0: 		for (int i = 0; i < joinQualifierList.size(); i++)
0: 			requalificationRestrictionList.removeOptPredicate((Predicate) joinQualifierList.elementAt(i));
1: 
1: 		joinQualifierList.transferNonQualifiers(this, restrictionList); //purify joinQual list
1: 		requalificationRestrictionList.copyPredicatesToOtherList(restrictionList); //any residual
1: 
1: 		ResultColumnList	htRCList;
1: 
1: 		/* We get a shallow copy of the child's ResultColumnList and its 
1: 		 * ResultColumns.  (Copy maintains ResultColumn.expression for now.)
1: 		 */
1: 		htRCList = childResult.getResultColumns();
1: 		childResult.setResultColumns(htRCList.copyListAndObjects());
1: 
1: 		/* Replace ResultColumn.expression with new VirtualColumnNodes
1: 		 * in the HTN's ResultColumnList.  (VirtualColumnNodes include
1: 		 * pointers to source ResultSetNode, this, and source ResultColumn.)
1: 		 * NOTE: We don't want to mark the underlying RCs as referenced, otherwise
1: 		 * we won't be able to project out any of them.
1: 		 */
1: 		htRCList.genVirtualColumnNodes(childResult, childResult.getResultColumns(), false);
1: 
1: 		/* The CRs for this side of the join in both the searchRestrictionList
1: 		 * the joinQualifierList now point to the HTN's RCL.  We need them
1: 		 * to point to the RCL in the child of the HTN.  (We skip doing this for
1: 		 * the joinQualifierList as the code to generate the Qualifiers does not
1: 		 * care.)
1: 		 */
1: 		RemapCRsVisitor rcrv = new RemapCRsVisitor(true);
1: 		searchRestrictionList.accept(rcrv);
1: 
1: 		/* We can finally put the HTN between ourself and our old child. */
0: 		childResult = (ResultSetNode) getNodeFactory().getNode(
0: 											C_NodeTypes.HASH_TABLE_NODE,
1: 											childResult,
1: 											tableProperties, 
0: 											htRCList,
1: 											searchRestrictionList, 
1: 											joinQualifierList,
0: 											trulyTheBestAccessPath, 
0: 											getCostEstimate(),
0: 											projectSubquerys,
0: 											restrictSubquerys,
0: 											hashKeyColumns(),
1: 											getContextManager());
1: 		return this;
1: 	}
1: 
1: 	/** @see Optimizable#verifyProperties 
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public void verifyProperties(DataDictionary dDictionary)
1: 		throws StandardException
1: 	{
1: 		/* Table properties can be attached to this node if
1: 		 * its child is not an optimizable, otherwise they
1: 		 * are attached to its child.
1: 		 */
1: 
1: 		if (childResult instanceof Optimizable)
1: 		{
1: 			((Optimizable) childResult).verifyProperties(dDictionary);
1: 		}
1: 		else
1: 		{
1: 			super.verifyProperties(dDictionary);
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * @see Optimizable#legalJoinOrder
1: 	 */
1: 	public boolean legalJoinOrder(JBitSet assignedTableMap)
1: 	{
1: 		if (childResult instanceof Optimizable)
1: 		{
1: 			return ((Optimizable) childResult).legalJoinOrder(assignedTableMap);
1: 		}
1: 		else
1: 		{
1: 			return true;
1: 		}
1: 	}
1: 
0: 	/** @see Optimizable#isMaterializable 
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public boolean isMaterializable()
1: 		throws StandardException
1: 	{
0: 		/* RESOLVE - Disallow arbitrary hash joins on
0: 		 * SELECTS within a derived table for now.
0: 		 * Remove this method once that restriction is removed.
1: 		 */
0: 		if (! (childResult instanceof Optimizable))
1: 		{
1: 			return false;
1: 		}
1: 
0: 		return super.isMaterializable();
1: 	}
1: 
1: 	/**
1: 	 * @see Optimizable#uniqueJoin
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public double uniqueJoin(OptimizablePredicateList predList)
1: 					throws StandardException
1: 	{
1: 		if (childResult instanceof Optimizable)
1: 		{
1: 			return ((Optimizable) childResult).uniqueJoin(predList);
1: 		}
1: 		else
1: 		{
1: 			return super.uniqueJoin(predList);
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Return the restriction list from this node.
1: 	 *
1: 	 * @return	The restriction list from this node.
1: 	 */
1: 	PredicateList getRestrictionList()
1: 	{
1: 		return restrictionList;
1: 	}
1: 
1: 	/** 
1: 	 * Return the user specified join strategy, if any for this table.
1: 	 *
1: 	 * @return The user specified join strategy, if any for this table.
1: 	 */
1: 	String getUserSpecifiedJoinStrategy()
1: 	{
1: 		if (childResult instanceof FromTable)
1: 		{
1: 			return ((FromTable) childResult).getUserSpecifiedJoinStrategy();
1: 		}
1: 		else
1: 		{
1: 			return userSpecifiedJoinStrategy;
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
1: 	 * how tree printing is supposed to work.
1: 	 *
1: 	 * @param depth		The depth of this node in the tree
1: 	 *
0: 	 * @return	Nothing
1: 	 */
1: 
0: 	public void printSubNodes(int depth)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			super.printSubNodes(depth);
1: 
1: 			if (restriction != null)
1: 			{
1: 				printLabel(depth, "restriction: ");
1: 				restriction.treePrint(depth + 1);
1: 			}
1: 
1: 			if (restrictionList != null)
1: 			{
1: 				printLabel(depth, "restrictionList: ");
1: 				restrictionList.treePrint(depth + 1);
1: 			}
1: 
1: 			if (projectSubquerys != null)
1: 			{
1: 				printLabel(depth, "projectSubquerys: ");
1: 				projectSubquerys.treePrint(depth + 1);
1: 			}
1: 
1: 			if (restrictSubquerys != null)
1: 			{
1: 				printLabel(depth, "restrictSubquerys: ");
1: 				restrictSubquerys.treePrint(depth + 1);
1: 			}
1: 		}
1: 	}
1: 
1: 	/** 
1: 	 * Put a ProjectRestrictNode on top of each FromTable in the FromList.
1: 	 * ColumnReferences must continue to point to the same ResultColumn, so
1: 	 * that ResultColumn must percolate up to the new PRN.  However,
1: 	 * that ResultColumn will point to a new expression, a VirtualColumnNode, 
1: 	 * which points to the FromTable and the ResultColumn that is the source for
1: 	 * the ColumnReference.  
1: 	 * (The new PRN will have the original of the ResultColumnList and
1: 	 * the ResultColumns from that list.  The FromTable will get shallow copies
1: 	 * of the ResultColumnList and its ResultColumns.  ResultColumn.expression
1: 	 * will remain at the FromTable, with the PRN getting a new 
1: 	 * VirtualColumnNode for each ResultColumn.expression.)
1: 	 * We then project out the non-referenced columns.  If there are no referenced
1: 	 * columns, then the PRN's ResultColumnList will consist of a single ResultColumn
1: 	 * whose expression is 1.
1: 	 *
1: 	 * @param numTables			Number of tables in the DML Statement
1: 	 * @param gbl				The group by list, if any
1: 	 * @param fromList			The from list, if any
1: 	 *
1: 	 * @return The generated ProjectRestrictNode atop the original FromTable.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public ResultSetNode preprocess(int numTables,
1: 									GroupByList gbl,
1: 									FromList fromList) 
1: 								throws StandardException
1: 	{
1: 		childResult = childResult.preprocess(numTables, gbl, fromList);
1: 
1: 		/* Build the referenced table map */
0: 		referencedTableMap = (JBitSet) childResult.getReferencedTableMap().clone();
1: 
1: 		return this;
1: 	}
1: 
1: 	/**
1: 	 * Push expressions down to the first ResultSetNode which can do expression
1: 	 * evaluation and has the same referenced table map.
1: 	 * RESOLVE - This means only pushing down single table expressions to
1: 	 * ProjectRestrictNodes today.  Once we have a better understanding of how
1: 	 * the optimizer will work, we can push down join clauses.
1: 	 *
1: 	 * @param predicateList	The PredicateList.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public void pushExpressions(PredicateList predicateList)
1: 					throws StandardException
1: 	{
0: 		PredicateList	pushPList = null;
1: 
1: 		if (SanityManager.DEBUG)
1: 		SanityManager.ASSERT(predicateList != null,
1: 							 "predicateList is expected to be non-null");
1: 
1: 		/* Push single table predicates down to the left of an outer
1: 		 * join, if possible.  (We need to be able to walk an entire
1: 		 * join tree.)
1: 		 */
1: 		if (childResult instanceof JoinNode)
1: 		{
1: 			((FromTable) childResult).pushExpressions(predicateList);
1: 
1: 		}
1: 
1: 		/* Build a list of the single table predicates that we can push down */
0: 		pushPList = predicateList.getPushablePredicates(referencedTableMap);
1: 
1: 		/* If this is a PRN above a SelectNode, probably due to a 
1: 		 * view or derived table which couldn't be flattened, then see
1: 		 * if we can push any of the predicates which just got pushed
1: 		 * down to our level into the SelectNode.
1: 		 */
0: 		if (pushPList != null && (childResult instanceof SelectNode))
1: 		{
0: 			pushPList.pushExpressionsIntoSelect((SelectNode) childResult);
1: 		}
1: 
1: 		if (restrictionList == null)
1: 		{
1: 			restrictionList = pushPList;
1: 		}
1: 		else if (pushPList != null && pushPList.size() != 0)
1: 		{
1: 			/* Concatenate the 2 PredicateLists */
1: 			restrictionList.destructiveAppend(pushPList);
1: 		}
1: 
1: 		/* RESOLVE - this looks like the place to try to try to push the 
1: 		 * predicates through the ProjectRestrict.  Seems like we should
1: 		 * "rebind" the column references and reset the referenced table maps
1: 		 * in restrictionList and then call childResult.pushExpressions() on
1: 		 * restrictionList.
1: 		 */
1: 	}
1: 
1: 	/**
1: 	 * Add a new predicate to the list.  This is useful when doing subquery
1: 	 * transformations, when we build a new predicate with the left side of
1: 	 * the subquery operator and the subquery's result column.
1: 	 *
1: 	 * @param predicate		The predicate to add
1: 	 *
1: 	 * @return ResultSetNode	The new top of the tree.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public ResultSetNode addNewPredicate(Predicate predicate)
1: 			throws StandardException
1: 	{
1: 		if (restrictionList == null)
1: 		{
0: 			restrictionList = (PredicateList) getNodeFactory().getNode(
0: 													C_NodeTypes.PREDICATE_LIST,
1: 													getContextManager());
1: 		}
1: 		restrictionList.addPredicate(predicate);
1: 		return this;
1: 	}
1: 
1: 	/**
1: 	 * Evaluate whether or not the subquery in a FromSubquery is flattenable.  
1: 	 * Currently, a FSqry is flattenable if all of the following are true:
1: 	 *		o  Subquery is a SelectNode. 
1: 	 *		o  It contains no top level subqueries.  (RESOLVE - we can relax this)
1: 	 *		o  It does not contain a group by or having clause
1: 	 *		o  It does not contain aggregates.
1: 	 *
1: 	 * @param fromList	The outer from list
1: 	 *
1: 	 * @return boolean	Whether or not the FromSubquery is flattenable.
1: 	 */
0: 	public boolean flattenableInFromSubquery(FromList fromList)
1: 	{
1: 		/* Flattening currently involves merging predicates and FromLists.
1: 		 * We don't have a FromList, so we can't flatten for now.
1: 		 */
1: 		/* RESOLVE - this will introduce yet another unnecessary PRN */
1: 		return false;
1: 	}
1: 
1: 	/**
1: 	 * Ensure that the top of the RSN tree has a PredicateList.
1: 	 *
1: 	 * @param numTables			The number of tables in the query.
1: 	 * @return ResultSetNode	A RSN tree with a node which has a PredicateList on top.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public ResultSetNode ensurePredicateList(int numTables) 
1: 		throws StandardException
1: 	{
1: 		return this;
1: 	}
1: 
1: 	/**
1: 	 * Optimize this ProjectRestrictNode.  
1: 	 *
1: 	 * @param dataDictionary	The DataDictionary to use for optimization
0: 	 * @param predicateList		The PredicateList to optimize.  This should
1: 	 *							be a join predicate.
1: 	 * @param outerRows			The number of outer joining rows
1: 	 *
1: 	 * @return	ResultSetNode	The top of the optimized subtree
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public ResultSetNode optimize(DataDictionary dataDictionary,
1: 								  PredicateList predicates,
1: 								  double outerRows) 
1: 					throws StandardException
1: 	{
1: 		/* We need to implement this method since a PRN can appear above a
1: 		 * SelectNode in a query tree.
1: 		 */
1: 		childResult = childResult.optimize(dataDictionary,
1: 											restrictionList,
1: 											outerRows);
1: 
0: 		Optimizer optimizer = getOptimizer(
0: 								(FromList) getNodeFactory().getNode(
0: 									C_NodeTypes.FROM_LIST,
0: 									getNodeFactory().doJoinOrderOptimization(),
1: 									this,
0: 									getContextManager()),
0: 								predicates,
0: 								dataDictionary,
0: 								(RequiredRowOrdering) null);
1: 
1: 		// RESOLVE: SHOULD FACTOR IN THE NON-OPTIMIZABLE PREDICATES THAT
1: 		// WERE NOT PUSHED DOWN
0: 		costEstimate = optimizer.newCostEstimate();
1: 
0: 		costEstimate.setCost(childResult.getCostEstimate().getEstimatedCost(),
1: 							childResult.getCostEstimate().rowCount(),
1: 							childResult.getCostEstimate().singleScanRowCount());
1: 
1: 		return this;
1: 	}
1: 
1: 	/**
1: 	 * Get the CostEstimate for this ProjectRestrictNode.
1: 	 *
1: 	 * @return	The CostEstimate for this ProjectRestrictNode, which is
1: 	 * 			the cost estimate for the child node.
1: 	 */
0: 	public CostEstimate getCostEstimate()
1: 	{
1: 		/*
1: 		** The cost estimate will be set here if either optimize() or
1: 		** optimizeIt() was called on this node.  It's also possible
1: 		** that optimization was done directly on the child node,
1: 		** in which case the cost estimate will be null here.
1: 		*/
0: 		if (costEstimate == null)
1: 			return childResult.getCostEstimate();
1: 		else
1: 		{
0: 			return costEstimate;
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Get the final CostEstimate for this ProjectRestrictNode.
1: 	 *
1: 	 * @return	The final CostEstimate for this ProjectRestrictNode, which is
1: 	 * 			the final cost estimate for the child node.
1: 	 */
0: 	public CostEstimate getFinalCostEstimate()
1: 	{
1: 		/*
1: 		** The cost estimate will be set here if either optimize() or
1: 		** optimizeIt() was called on this node.  It's also possible
1: 		** that optimization was done directly on the child node,
1: 		** in which case the cost estimate will be null here.
1: 		*/
0: 		if (costEstimate == null)
0: 			return childResult.getFinalCostEstimate();
1: 		else
1: 		{
0: 			return costEstimate;
1: 		}
1: 	}
1: 
1:     /**
1:      * For joins, the tree will be (nodes are left out if the clauses
1:      * are empty):
1:      *
1:      *      ProjectRestrictResultSet -- for the having and the select list
1:      *      SortResultSet -- for the group by list
1:      *      ProjectRestrictResultSet -- for the where and the select list (if no group or having)
1:      *      the result set for the fromList
1:      *
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1:      */
0: 	public void generate(ActivationClassBuilder acb,
0: 								MethodBuilder mb)
1: 							throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG)
0:         SanityManager.ASSERT(resultColumns != null, "Tree structure bad");
1: 
1: 		generateMinion( acb, mb, false);
1: 	}
1: 
1: 	/**
1: 	 * General logic shared by Core compilation.
1: 	 *
0: 	 * @param ecb	The ExpressionClassBuilder for the class being built
1: 	 * @param mb	The method the expression will go into
1: 	 *
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public void generateResultSet(ExpressionClassBuilder acb,
0: 										   MethodBuilder mb)
1: 									throws StandardException
1: 	{
1: 		generateMinion( acb, mb, true);
1: 	}
1: 
1: 	/**
1: 	 * Logic shared by generate() and generateResultSet().
1: 	 *
0: 	 * @param ecb	The ExpressionClassBuilder for the class being built
1: 	 * @param mb	The method the expression will go into
1: 	 *
0: 	 * @return		The compiled Expression
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
1: 	private void generateMinion(ExpressionClassBuilder acb,
1: 									 MethodBuilder mb, boolean genChildResultSet)
1: 									throws StandardException
1: 	{
1: 
1: 		/* If this ProjectRestrict doesn't do anything, bypass its generation.
1: 		 * (Remove any true and true predicates first, as they could be left
1: 		 * by the like transformation.)
1: 		 */
1: 		if (restrictionList != null && restrictionList.size() > 0)
1: 		{
1: 			restrictionList.eliminateBooleanTrueAndBooleanTrue();
1: 		}
1: 
1: 		if (nopProjectRestrict())
1: 		{
1: 			generateNOPProjectRestrict();
1: 			if (genChildResultSet)
1: 				childResult.generateResultSet(acb, mb);
1: 			else
1: 				childResult.generate((ActivationClassBuilder)acb, mb);
0: 			costEstimate = childResult.getFinalCostEstimate();
1: 			return;
1: 		}
1: 
1: 		// build up the tree.
1: 
1: 		/* Put the predicates back into the tree */
1: 		if (restrictionList != null)
1: 		{
1: 			constantRestriction = restrictionList.restoreConstantPredicates();
1: 			// Remove any redundant predicates before restoring
1: 			restrictionList.removeRedundantPredicates();
1: 			restriction = restrictionList.restorePredicates();
1: 			/* Allow the restrictionList to get garbage collected now
1: 			 * that we're done with it.
1: 			 */
1: 			restrictionList = null;
1: 		}
1: 
1: 		// for the restriction, we generate an exprFun
1: 		// that evaluates the expression of the clause
1: 		// against the current row of the child's result.
1: 		// if the restriction is empty, simply pass null
1: 		// to optimize for run time performance.
1: 
1:    		// generate the function and initializer:
1:    		// Note: Boolean lets us return nulls (boolean would not)
1:    		// private Boolean exprN()
1:    		// {
1:    		//   return <<restriction.generate(ps)>>;
1:    		// }
1:    		// static Method exprN = method pointer to exprN;
1: 
1: 
1: 
1: 
1: 		// Map the result columns to the source columns
0: 		int[] mapArray = resultColumns.mapSourceColumns();
1: 		int mapArrayItem = acb.addItem(new ReferencedColumnsDescriptorImpl(mapArray));
1: 
1: 		/* Will this node do a projection? */
1: 		boolean doesProjection = true;
1: 
1: 		/* Does a projection unless same # of columns in same order
1: 		 * as child.
1: 		 */
1: 		if ( (! reflectionNeededForProjection()) && 
1: 		    mapArray != null && 
1: 			mapArray.length == childResult.getResultColumns().size())
1: 		{
1: 			/* mapArray entries are 1-based */
1: 			int index = 0;
1: 			for ( ; index < mapArray.length; index++)
1: 			{
1: 				if (mapArray[index] != index + 1)
1: 				{
1: 					break;
1: 				}
1: 			}
1: 			if (index == mapArray.length)
1: 			{
1: 				doesProjection = false;
1: 			}
1: 		}
1: 
1: 
1: 
1: 		/* Generate the ProjectRestrictSet:
1: 		 *	arg1: childExpress - Expression for childResultSet
1: 		 *  arg2: Activation
1: 		 *  arg3: restrictExpress - Expression for restriction
1: 		 *  arg4: projectExpress - Expression for projection
1: 		 *  arg5: resultSetNumber
1: 		 *  arg6: constantExpress - Expression for constant restriction
1: 		 *			(for example, where 1 = 2)
1: 		 *  arg7: mapArrayItem - item # for mapping of source columns
0: 		 *  arg8: reuseResult - whether or not the result row can be reused
0: 		 *						(ie, will it always be the same)
0: 		 *  arg9: doesProjection - does this node do a projection
0: 		 *  arg10: estimated row count
0: 		 *  arg11: estimated cost
0: 		 *  arg12: close method
1: 		 */
1: 
1: 		acb.pushGetResultSetFactoryExpression(mb);
1: 		if (genChildResultSet)
1: 			childResult.generateResultSet(acb, mb);
1: 		else
1: 			childResult.generate((ActivationClassBuilder)acb, mb);
1: 
1: 		/* Get the next ResultSet #, so that we can number this ResultSetNode, its
1: 		 * ResultColumnList and ResultSet.
1: 		 */
1: 		assignResultSetNumber();
1: 		
1: 		/* Set the point of attachment in all subqueries attached
1: 		 * to this node.
1: 		 */
1: 		if (projectSubquerys != null && projectSubquerys.size() > 0)
1: 		{
0: 			projectSubquerys.setPointOfAttachment(resultSetNumber);
1: 		}
1: 		if (restrictSubquerys != null && restrictSubquerys.size() > 0)
1: 		{
0: 			restrictSubquerys.setPointOfAttachment(resultSetNumber);
1: 		}
1: 
0: 		/* Drop our cost estimate if it is uninitialized. */
0: 		if (costEstimate != null && costEstimate.isUninitialized())
1: 		{
0: 			costEstimate = childResult.getFinalCostEstimate();
1: 		}
1: 
0: 		acb.pushThisAsActivation(mb);
1: 
1: 		// if there is no restriction, we just want to pass null.
1: 		if (restriction == null)
1: 		{
1: 		   	mb.pushNull(ClassName.GeneratedMethod);
1: 		}
1: 		else
1: 		{
1: 			// this sets up the method and the static field.
1: 			// generates:
1: 			// 	Object userExprFun { }
1: 			MethodBuilder userExprFun = acb.newUserExprFun();
1: 
1: 			// restriction knows it is returning its value;
1: 
1: 			/* generates:
1: 			 *    return  <restriction.generate(acb)>;
1: 			 * and adds it to userExprFun
1: 			 * NOTE: The explicit cast to DataValueDescriptor is required
1: 			 * since the restriction may simply be a boolean column or subquery
1: 			 * which returns a boolean.  For example:
1: 			 *		where booleanColumn
1: 			 */
1: 			restriction.generateExpression(acb, userExprFun);
1: 			userExprFun.methodReturn();
1: 
1: 			// we are done modifying userExprFun, complete it.
1: 			userExprFun.complete();
1: 
1: 	   		// restriction is used in the final result set as an access of the new static
1:    			// field holding a reference to this new method.
1: 			// generates:
1: 			//	ActivationClass.userExprFun
1: 			// which is the static field that "points" to the userExprFun
1: 			// that evaluates the where clause.
1:    			acb.pushMethodReference(mb, userExprFun);
1: 		}
1: 
1: 		/* Determine whether or not reflection is needed for the projection.
1: 		 * Reflection is not needed if all of the columns map directly to source
1: 		 * columns.
1: 		 */
1: 		if (reflectionNeededForProjection())
1: 		{
1: 			// for the resultColumns, we generate a userExprFun
1: 			// that creates a new row from expressions against
1: 			// the current row of the child's result.
1: 			// (Generate optimization: see if we can simply
1: 			// return the current row -- we could, but don't, optimize
1: 			// the function call out and have execution understand
1: 			// that a null function pointer means take the current row
1: 			// as-is, with the performance trade-off as discussed above.)
1: 
1: 			/* Generate the Row function for the projection */
0: 			resultColumns.generateCore(acb, mb, false);
1: 		}
1: 		else
1: 		{
1: 		   	mb.pushNull(ClassName.GeneratedMethod);
1: 		}
1: 		
0: 		mb.push(resultSetNumber);
1: 
1: 		// if there is no constant restriction, we just want to pass null.
1: 		if (constantRestriction == null)
1: 		{
1: 		   	mb.pushNull(ClassName.GeneratedMethod);
1: 		}
1: 		else
1: 		{
1: 			// this sets up the method and the static field.
1: 			// generates:
1: 			// 	userExprFun { }
1: 			MethodBuilder userExprFun = acb.newUserExprFun();
1: 
1: 			// restriction knows it is returning its value;
1: 
1: 			/* generates:
1: 			 *    return <restriction.generate(acb)>;
1: 			 * and adds it to userExprFun
1: 			 * NOTE: The explicit cast to DataValueDescriptor is required
1: 			 * since the restriction may simply be a boolean column or subquery
1: 			 * which returns a boolean.  For example:
1: 			 *		where booleanColumn
1: 			 */
1: 			constantRestriction.generateExpression(acb, userExprFun);
1: 
1: 			userExprFun.methodReturn();
1: 
1: 			// we are done modifying userExprFun, complete it.
1: 			userExprFun.complete();
1: 
1: 	   		// restriction is used in the final result set as an access
1: 			// of the new static field holding a reference to this new method.
1: 			// generates:
1: 			//	ActivationClass.userExprFun
1: 			// which is the static field that "points" to the userExprFun
1: 			// that evaluates the where clause.
1:    			acb.pushMethodReference(mb, userExprFun);
1: 		}
1: 		
1: 		mb.push(mapArrayItem);
0: 		mb.push(resultColumns.reusableResult());
1: 		mb.push(doesProjection);
0: 		mb.push(getFinalCostEstimate().rowCount());
0: 		mb.push(getFinalCostEstimate().getEstimatedCost());
0: 		closeMethodArgument(acb, mb);
1: 
1: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, "getProjectRestrictResultSet",
0: 					ClassName.NoPutResultSet, 12);
1: 	}
1: 
1: 	/**
1: 	 * Determine whether this ProjectRestrict does anything.  If it doesn't
1: 	 * filter out any rows or columns, it's a No-Op.
1: 	 *
1: 	 * @return	true if this ProjectRestrict is a No-Op.
1: 	 */
1: 	boolean nopProjectRestrict()
1: 	{
1: 		/*
1: 		** This ProjectRestrictNode is not a No-Op if it does any
1: 		** restriction.
1: 		*/
0: 		if ( (restriction != null) ||
1: 			 (restrictionList != null && restrictionList.size() > 0) )
1: 		{
1: 			return false;
1: 		}
1: 
1: 		ResultColumnList	childColumns = childResult.getResultColumns();
1: 		ResultColumnList	PRNColumns = this.getResultColumns();
1: 
1: 		/*
1: 		** The two lists have the same numbers of elements.  Are the lists
1: 		** identical?  In other words, is the expression in every ResultColumn
1: 		** in the PRN's RCL a ColumnReference that points to the same-numbered
1: 		** column?
1: 		*/
1: 		if (PRNColumns.nopProjection(childColumns))
1: 			return true;
1: 
1: 		return false;
1: 	}
1: 
1: 	/**
1: 	 * Bypass the generation of this No-Op ProjectRestrict, and just generate
1: 	 * its child result set.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public void generateNOPProjectRestrict()
1: 			throws StandardException
1: 	{
1: 		this.getResultColumns().setRedundant();
1: 	}
1: 
1: 	/**
1: 	 * Consider materialization for this ResultSet tree if it is valid and cost effective
1: 	 * (It is not valid if incorrect results would be returned.)
1: 	 *
1: 	 * @return Top of the new/same ResultSet tree.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public ResultSetNode considerMaterialization(JBitSet outerTables)
1: 		throws StandardException
1: 	{
1: 		childResult = childResult.considerMaterialization(outerTables);
1: 		if (childResult.performMaterialization(outerTables))
1: 		{
1: 			MaterializeResultSetNode	mrsn;
1: 			ResultColumnList			prRCList;
1: 
1: 			/* If the restriction contians a ColumnReference from another
1: 			 * table then the MRSN must go above the childResult.  Otherwise we can put
1: 			 * it above ourselves. (The later is optimal since projection and restriction 
1: 			 * will only happen once.)
1: 			 * Put MRSN above PRN if any of the following are true:
1: 			 *	o  PRN doesn't have a restriction list
1: 			 *	o  PRN's restriction list is empty 
1: 			 *  o  Table's referenced in PRN's restriction list are a subset of
1: 			 *	   table's referenced in PRN's childResult.  (NOTE: Rather than construct
1: 			 *     a new, empty JBitSet before checking, we simply clone the childResult's
1: 			 *	   referencedTableMap.  This is done for code simplicity and will not 
1: 			 *	   affect the result.)
1: 			 */
1: 			ReferencedTablesVisitor rtv = new ReferencedTablesVisitor(
1: 												(JBitSet) childResult.getReferencedTableMap().clone());
1: 			boolean emptyRestrictionList = (restrictionList == null || restrictionList.size() == 0);
1: 			if (! emptyRestrictionList)
1: 			{
1: 				restrictionList.accept(rtv);
1: 			}
1: 			if (emptyRestrictionList ||
1: 				childResult.getReferencedTableMap().contains(rtv.getTableMap()))
1: 			{
1: 				/* We get a shallow copy of the ResultColumnList and its 
1: 				 * ResultColumns.  (Copy maintains ResultColumn.expression for now.)
1: 				 */
0: 				prRCList = resultColumns;
0: 				setResultColumns(resultColumns.copyListAndObjects());
1: 
1: 				/* Replace ResultColumn.expression with new VirtualColumnNodes
1: 				 * in the NormalizeResultSetNode's ResultColumnList.  (VirtualColumnNodes include
1: 				 * pointers to source ResultSetNode, this, and source ResultColumn.)
1: 				 */
0: 				prRCList.genVirtualColumnNodes(this, resultColumns);
1: 
1: 				/* Finally, we create the new MaterializeResultSetNode */
0: 				mrsn = (MaterializeResultSetNode) getNodeFactory().getNode(
0: 									C_NodeTypes.MATERIALIZE_RESULT_SET_NODE,
1: 									this,
1: 									prRCList,
1: 									tableProperties,
1: 									getContextManager());
1: 				// Propagate the referenced table map if it's already been created
0: 				if (referencedTableMap != null)
1: 				{
0: 					mrsn.setReferencedTableMap((JBitSet) referencedTableMap.clone());
1: 				}
1: 				return mrsn;
1: 			}
1: 			else
1: 			{
1: 				/* We get a shallow copy of the ResultColumnList and its 
1: 				 * ResultColumns.  (Copy maintains ResultColumn.expression for now.)
1: 				 */
1: 				prRCList = childResult.getResultColumns();
1: 				childResult.setResultColumns(prRCList.copyListAndObjects());
1: 
1: 				/* Replace ResultColumn.expression with new VirtualColumnNodes
1: 				 * in the MaterializeResultSetNode's ResultColumnList.  (VirtualColumnNodes include
1: 				 * pointers to source ResultSetNode, this, and source ResultColumn.)
1: 				 */
1: 				prRCList.genVirtualColumnNodes(childResult, childResult.getResultColumns());
1: 
1: 				/* RESOLVE - we need to push single table predicates down so that
1: 				 * they get applied while building the MaterializeResultSet.
1: 				 */
1: 
1: 				/* Finally, we create the new MaterializeResultSetNode */
0: 				mrsn = (MaterializeResultSetNode) getNodeFactory().getNode(
0: 									C_NodeTypes.MATERIALIZE_RESULT_SET_NODE,
1: 									childResult,
1: 									prRCList,
1: 									tableProperties,
1: 									getContextManager());
1: 				// Propagate the referenced table map if it's already been created
1: 				if (childResult.getReferencedTableMap() != null)
1: 				{
1: 					mrsn.setReferencedTableMap((JBitSet) childResult.getReferencedTableMap().clone());
1: 				}
1: 				childResult = mrsn;
1: 			}
1: 		}
1: 
1: 		return this;
1: 	}
1: 
1: 	/** 
1: 	 * Determine whether or not the specified name is an exposed name in
1: 	 * the current query block.
1: 	 *
1: 	 * @param name	The specified name to search for as an exposed name.
1: 	 * @param schemaName	Schema name, if non-null.
1: 	 * @param exactMatch	Whether or not we need an exact match on specified schema and table
1: 	 *						names or match on table id.
1: 	 *
1: 	 * @return The FromTable, if any, with the exposed name.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	protected FromTable getFromTableByName(String name, String schemaName, boolean exactMatch)
1: 		throws StandardException
1: 	{
1: 		return childResult.getFromTableByName(name, schemaName, exactMatch);
1: 	}
1: 
1: 	/**
1: 	 * Get the lock mode for the target of an update statement
1: 	 * (a delete or update).  The update mode will always be row for
1: 	 * CurrentOfNodes.  It will be table if there is no where clause.
1: 	 *
1: 	 * @return	The lock mode
1: 	 */
0: 	public int updateTargetLockMode()
1: 	{
1: 		if (restriction != null || constantRestriction != null)
1: 		{
1: 			return TransactionController.MODE_RECORD;
1: 		}
1: 		else
1: 		{
1: 			return childResult.updateTargetLockMode();
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Is it possible to do a distinct scan on this ResultSet tree.
1: 	 * (See SelectNode for the criteria.)
1: 	 *
1: 	 * @return Whether or not it is possible to do a distinct scan on this ResultSet tree.
1: 	 */
0: 	boolean isPossibleDistinctScan()
1: 	{
1: 		if (restriction != null || 
1: 			(restrictionList != null && restrictionList.size() != 0))
1: 		{
1: 			return false;
1: 		}
0: 		return childResult.isPossibleDistinctScan();
1: 	}
1: 
1: 	/**
1: 	 * Mark the underlying scan as a distinct scan.
1: 	 *
0: 	 * @return Nothing.
1: 	 */
1: 	void markForDistinctScan()
1: 	{
1: 		childResult.markForDistinctScan();
1: 	}
1: 
1: 
1: 	/**
0: 	 * Accept a visitor, and call v.visit()
0: 	 * on child nodes as necessary.  
1: 	 * 
1: 	 * @param v the visitor
1: 	 *
1: 	 * @exception StandardException on error
1: 	 */
0: 	public Visitable accept(Visitor v) 
1: 		throws StandardException
1: 	{
0: 		if (v.skipChildren(this))
1: 		{
0: 			return v.visit(this);
1: 		}
1: 
0: 		Visitable returnNode = super.accept(v);
1: 
0: 		if (restriction != null && !v.stopTraversal())
1: 		{
1: 			restriction = (ValueNode)restriction.accept(v);
1: 		}
1: 
0: 		if (restrictionList != null && !v.stopTraversal())
1: 		{
1: 			restrictionList = (PredicateList)restrictionList.accept(v);
1: 		}
1: 
0: 		return returnNode;
1: 	}
1: 
1: 
1: 
1: 	/**
1: 	 * set the Information gathered from the parent table that is 
0: 	 * required to peform a referential action on dependent table.
1: 	 *
0: 	 * @return Nothing.
1: 	 */
0: 	public void setRefActionInfo(long fkIndexConglomId, 
1: 								 int[]fkColArray, 
1: 								 String parentResultSetId,
1: 								 boolean dependentScan)
1: 	{
1: 		childResult.setRefActionInfo(fkIndexConglomId,
1: 								   fkColArray,
1: 								   parentResultSetId,
1: 								   dependentScan);
1: 	}
1: 
1: }
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2d37fd6
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	 * @param predicates		The PredicateList to optimize.  This should
/////////////////////////////////////////////////////////////////////////
1: 	 * @param acb	The ExpressionClassBuilder for the class being built
/////////////////////////////////////////////////////////////////////////
1: 	 * @param acb	The ExpressionClassBuilder for the class being built
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:0be2d6e
/////////////////////////////////////////////////////////////////////////
1: 			/* Note: Prior to the fix for DERBY-781 we had calls here
1: 			 * to set the cost estimate for BestAccessPath and
1: 			 * BestSortAvoidancePath to equal costEstimate.  That used
1: 			 * to be okay because prior to DERBY-781 we would only
1: 			 * get here once (per join order) for a given SelectNode/
1: 			 * RowResultSetNode and thus we could safely say that the
1: 			 * costEstimate from the most recent call to "optimize()"
1: 			 * was the best one so far (because we knew that we would
1: 			 * only call childResult.optimize() once).  Now that we
1: 			 * support hash joins with subqueries, though, we can get
1: 			 * here twice per join order: once when the optimizer is
1: 			 * considering a nested loop join with this PRN, and once
1: 			 * when it is considering a hash join.  This means we can't
1: 			 * just arbitrarily use the cost estimate for the most recent
1: 			 * "optimize()" as the best cost because that may not
1: 			 * be accurate--it's possible that the above call to
1: 			 * childResult.optimize() was for a hash join, but that
1: 			 * we were here once before (namely for nested loop) and
1: 			 * the cost of the nested loop is actually less than
1: 			 * the cost of the hash join.  In that case it would
1: 			 * be wrong to use costEstimate as the cost of the "best"
1: 			 * paths because it (costEstimate) holds the cost of
1: 			 * the hash join, not of the nested loop join.  So with
1: 			 * DERBY-781 the following calls were removed:
1: 			 *   getBestAccessPath().setCostEstimate(costEstimate);
1: 			 *   getBestSortAvoidancePath().setCostEstimate(costEstimate);
1: 			 * If costEstimate *does* actually hold the estimate for
1: 			 * the best path so far, then we will set BestAccessPath
1: 			 * and BestSortAvoidancePath as needed in the following
1: 			 * call to "considerCost".
0: 			 */
/////////////////////////////////////////////////////////////////////////
1: 		// If we're doing a hash join with _this_ PRN (as opposed to
1: 		// with this PRN's child) then we don't attempt to push
1: 		// predicates down.  There are two reasons for this: 1)
1: 		// we don't want to push the equijoin predicate that is
1: 		// required for the hash join, and 2) if we're doing a
1: 		// hash join then we're going to materialize this node,
1: 		// but if we push predicates before materialization, we
1: 		// can end up with incorrect results (esp. missing rows).
1: 		// So don't push anything in this case.
1: 		boolean hashJoinWithThisPRN = hasTrulyTheBestAccessPath &&
1: 			(trulyTheBestAccessPath.getJoinStrategy() != null) &&
1: 			trulyTheBestAccessPath.getJoinStrategy().isHashJoin();
0: 		if ((restrictionList != null) && !alreadyPushed && !hashJoinWithThisPRN)
/////////////////////////////////////////////////////////////////////////
1: 		// If this PRN has TTB access path for its child, store that access
1: 		// path in the child here, so that we can find it later when it
1: 		// comes time to generate qualifiers for the hash predicates (we
1: 		// need the child's access path when generating qualifiers; if we
1: 		// don't pass the path down here, the child won't be able to find
1: 		// it).
1: 		if (hasTrulyTheBestAccessPath)
0: 		{
1: 			((FromTable)childResult).trulyTheBestAccessPath =
1: 				(AccessPathImpl)getTrulyTheBestAccessPath();
0: 
1: 			// If the child itself is another SingleChildResultSetNode
1: 			// (which is also what a ProjectRestrictNode is), then tell
1: 			// it that it is now holding TTB path for it's own child.  Again,
1: 			// this info is needed so that child knows where to find the
1: 			// access path at generation time.
1: 			if (childResult instanceof SingleChildResultSetNode)
0: 			{
1: 				((SingleChildResultSetNode)childResult)
1: 					.hasTrulyTheBestAccessPath = hasTrulyTheBestAccessPath;
0: 
1: 				// While we're at it, add the PRN's table number to the
1: 				// child's referenced map so that we can find the equijoin
1: 				// predicate.  We have to do this because the predicate
1: 				// will be referencing the PRN's tableNumber, not the
1: 				// child's--and since we use the child as the target
1: 				// when searching for hash keys (as can be seen in
1: 				// HashJoinStrategy.divideUpPredicateLists()), the child
1: 				// should know what this PRN's table number is.  This
1: 				// is somewhat bizarre since the child doesn't
1: 				// actually "reference" this PRN, but since the child's
1: 				// reference map is used when searching for the equijoin
1: 				// predicate (see "buildTableNumList" in
1: 				// BinaryRelationalOperatorNode), this is the simplest
1: 				// way to pass this PRN's table number down.
1: 				childResult.getReferencedTableMap().set(tableNumber);
0: 			}
0: 		}
0: 
/////////////////////////////////////////////////////////////////////////
commit:e540aee
/////////////////////////////////////////////////////////////////////////
0: 
1: 			// Note: we don't call "optimizer.considerCost()" here because
1: 			// a) the child will make that call as part of its own
1: 			// "optimizeIt()" work above, and b) the child might have
1: 			// different criteria for "considering" (i.e. rejecting or
1: 			// accepting) a plan's cost than this ProjectRestrictNode does--
1: 			// and we don't want to override the child's decision.  So as
1: 			// with most operations in this class, if the child is an
1: 			// Optimizable, we just let it do its own work and make its
1: 			// own decisions.
commit:e07631a
/////////////////////////////////////////////////////////////////////////
1: 		// It's possible that a call to optimize the left/right will cause
1: 		// a new "truly the best" plan to be stored in the underlying base
1: 		// tables.  If that happens and then we decide to skip that plan
1: 		// (which we might do if the call to "considerCost()" below decides
1: 		// the current path is infeasible or not the best) we need to be
1: 		// able to revert back to the "truly the best" plans that we had
1: 		// saved before we got here.  So with this next call we save the
1: 		// current plans using "this" node as the key.  If needed, we'll
1: 		// then make the call to revert the plans in OptimizerImpl's
1: 		// getNextDecoratedPermutation() method.
0: 		addOrLoadBestPlanMapping(true, this);
0: 
/////////////////////////////////////////////////////////////////////////
1: 			// With DERBY-805 it's possible that, when considering a nested
1: 			// loop join with this PRN, we pushed predicates down into the
1: 			// child if the child is a UNION node.  At this point, though, we
1: 			// may be considering doing a hash join with this PRN instead of a
1: 			// nested loop join, and if that's the case we need to pull any
1: 			// predicates back up so that they can be searched for equijoins
1: 			// that will in turn make the hash join possible.  So that's what
1: 			// the next call does.  Two things to note: 1) if no predicates
1: 			// were pushed, this call is a no-op; and 2) if we get here when
1: 			// considering a nested loop join, the predicates that we pull
1: 			// here (if any) will be re-pushed for subsequent costing/ 
1: 			// optimization as necessary (see OptimizerImpl.costPermutation(),
1: 			// which will call this class's optimizeIt() method and that's
1: 			// where the predicates are pushed down again).
1: 			if (childResult instanceof UnionNode)
1: 				((UnionNode)childResult).pullOptPredicates(restrictionList);
0: 
1: 			return ((Optimizable) childResult).
1: 				feasibleJoinStrategy(restrictionList, optimizer);
/////////////////////////////////////////////////////////////////////////
1: 		boolean alreadyPushed = false;
/////////////////////////////////////////////////////////////////////////
0: 
1: 				// Take note of the fact that we already pushed predicates
1: 				// as part of the modifyAccessPaths call.  This is necessary
1: 				// because there may still be predicates in restrictionList
1: 				// that we intentionally decided not to push (ex. if we're
1: 				// going to do hash join then we chose to not push the join
1: 				// predicates).  Whatever the reason for not pushing the
1: 				// predicates, we have to make sure we don't inadvertenly
1: 				// push them later (esp. as part of the "pushUsefulPredicates"
1: 				// call below).
1: 				alreadyPushed = true;
/////////////////////////////////////////////////////////////////////////
0: 
0: 		if ((restrictionList != null) && !alreadyPushed)
commit:5872305
/////////////////////////////////////////////////////////////////////////
1: 			// Pull up any predicates that may have been pushed further
1: 			// down the tree during optimization.
1: 			if (childResult instanceof UnionNode)
1: 				((UnionNode)childResult).pullOptPredicates(restrictionList);
0: 
/////////////////////////////////////////////////////////////////////////
0: 
1: 			// If the childResult is a SetOperatorNode (esp. a UnionNode),
1: 			// then it's possible that predicates in our restrictionList are
1: 			// supposed to be pushed further down the tree (as of DERBY-805).
1: 			// We passed the restrictionList down when we optimized the child
1: 			// so that the relevant predicates could be pushed further as part
1: 			// of the optimization process; so now that we're finalizing the
1: 			// paths, we need to do the same thing: i.e. pass restrictionList
1: 			// down so that the predicates that need to be pushed further
1: 			// _can_ be pushed further.
1: 			if (childResult instanceof SetOperatorNode) {
1: 				childResult = (ResultSetNode)
1: 					((SetOperatorNode) childResult).modifyAccessPath(
1: 						outerTables, restrictionList);
0: 			}
1: 			else {
0: 				childResult = 
1: 					(ResultSetNode) ((FromTable) childResult).
1: 						modifyAccessPath(outerTables);
0: 			}
commit:ab10884
/////////////////////////////////////////////////////////////////////////
0: 		throws StandardException
0: 		if (finalCostEstimate != null)
0: 		// we already set it, so just return it.
0: 			return finalCostEstimate;
0: 
1: 		// If the child result set is an Optimizable, then this node's
1: 		// final cost is that of the child.  Otherwise, this node must
1: 		// hold "trulyTheBestAccessPath" for it's child so we pull
1: 		// the final cost from there.
1: 		if (childResult instanceof Optimizable)
0: 			finalCostEstimate = childResult.getFinalCostEstimate();
0: 			finalCostEstimate = getTrulyTheBestAccessPath().getCostEstimate();
0: 
0: 		return finalCostEstimate;
/////////////////////////////////////////////////////////////////////////
1: 		// Load our final cost estimate.
0: 		costEstimate = getFinalCostEstimate();
/////////////////////////////////////////////////////////////////////////
0: 		mb.push(costEstimate.rowCount());
0: 		mb.push(costEstimate.getEstimatedCost());
commit:62d4560
/////////////////////////////////////////////////////////////////////////
1: 	public void rememberAsBest(int planType, Optimizer optimizer)
1: 		super.rememberAsBest(planType, optimizer);
1: 			((Optimizable) childResult).rememberAsBest(planType, optimizer);
commit:c700973
/////////////////////////////////////////////////////////////////////////
0: 			pushPList.pushExpressionsIntoSelect((SelectNode) childResult, false);
1: 		/* DERBY-649: Push simple predicates into Unions. It would be up to UnionNode
1: 		 * to decide if these predicates can be pushed further into underlying SelectNodes
1: 		 * or UnionNodes.  Note, we also keep the predicateList at this
1: 		 * ProjectRestrictNode in case the predicates are not pushable or only
1: 		 * partially pushable.
0: 		 *
1: 		 * It is possible to expand this optimization in UnionNode later.
0: 		 */
1: 		if (pushPList != null && (childResult instanceof UnionNode))
1: 			((UnionNode)childResult).pushExpressions(pushPList);
0: 
commit:abbaf4e
/////////////////////////////////////////////////////////////////////////
0: import java.util.HashSet;
0: import java.util.Set;
/////////////////////////////////////////////////////////////////////////
1: 	 * @param distinctColumns the set of distinct columns
0: 	boolean isPossibleDistinctScan(Set distinctColumns)
0: 
0: 		HashSet columns = new HashSet();
0: 		for (int i = 0; i < resultColumns.size(); i++) {
0: 			ResultColumn rc = (ResultColumn) resultColumns.elementAt(i);
1: 			BaseColumnNode bc = rc.getBaseColumnNode();
1: 			if (bc == null) return false;
1: 			columns.add(bc);
0: 		}
0: 
1: 		return columns.equals(distinctColumns) && childResult.isPossibleDistinctScan(distinctColumns);
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package	org.apache.derby.impl.sql.compile;
0: 
0: import org.apache.derby.iapi.services.context.ContextManager;
0: 
0: import org.apache.derby.iapi.sql.compile.Optimizable;
0: import org.apache.derby.iapi.sql.compile.OptimizablePredicate;
0: import org.apache.derby.iapi.sql.compile.OptimizablePredicateList;
0: import org.apache.derby.iapi.sql.compile.Optimizer;
0: import org.apache.derby.iapi.sql.compile.CostEstimate;
0: import org.apache.derby.iapi.sql.compile.OptimizableList;
0: import org.apache.derby.iapi.sql.compile.Visitable;
0: import org.apache.derby.iapi.sql.compile.Visitor;
0: import org.apache.derby.iapi.sql.compile.RequiredRowOrdering;
0: import org.apache.derby.iapi.sql.compile.RowOrdering;
0: import org.apache.derby.iapi.sql.compile.AccessPath;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
0: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
0: 
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: 
0: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
0: 
0: import org.apache.derby.iapi.sql.Activation;
0: import org.apache.derby.iapi.sql.ResultSet;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.reference.ClassName;
0: 
0: import org.apache.derby.iapi.store.access.TransactionController;
0: 
0: import org.apache.derby.impl.sql.compile.ExpressionClassBuilder;
0: import org.apache.derby.impl.sql.compile.ActivationClassBuilder;
0: 
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
0: 
0: import org.apache.derby.iapi.services.loader.GeneratedMethod;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.catalog.types.ReferencedColumnsDescriptorImpl;
0: import org.apache.derby.iapi.util.JBitSet;
0: import org.apache.derby.iapi.services.classfile.VMOpcode;
0: 
0: import java.util.Properties;
0: 
0: /**
0:  * A ProjectRestrictNode represents a result set for any of the basic DML
0:  * operations: SELECT, INSERT, UPDATE, and DELETE.  For INSERT with
0:  * a VALUES clause, restriction will be null. For both INSERT and UPDATE,
0:  * the resultColumns in the selectList will contain the names of the columns
0:  * being inserted into or updated.
0:  *
0:  * NOTE: A ProjectRestrictNode extends FromTable since it can exist in a FromList.
0:  *
0:  * @author Jeff Lichtman
0:  */
0: 
0: public class ProjectRestrictNode extends SingleChildResultSetNode
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	/**
0: 	 * The ValueNode for the restriction to be evaluated here.
0: 	 */
0: 	public ValueNode	restriction;
0: 
0: 	/**
0: 	 * Constant expressions to be evaluated here.
0: 	 */
0: 	ValueNode	constantRestriction = null;
0: 
0: 	/**
0: 	 * Restriction as a PredicateList
0: 	 */
0: 	public PredicateList restrictionList;
0: 
0: 	/**
0: 	 * List of subqueries in projection
0: 	 */
0: 	SubqueryList projectSubquerys;
0: 
0: 	/**
0: 	 * List of subqueries in restriction
0: 	 */
0: 	SubqueryList restrictSubquerys;
0: 
0: 	private boolean accessPathModified;
0: 
0: 	private boolean accessPathConsidered;
0: 
0: 	private boolean childResultOptimized;
0: 
0: 	private boolean materialize;
0: 
0: 	/* Should we get the table number from this node,
0: 	 * regardless of the class of our child.
0: 	 */
0: 	private boolean getTableNumberHere;
0: 
0: 	/**
0: 	 * Initializer for a ProjectRestrictNode.
0: 	 *
0: 	 * @param childResult	The child ResultSetNode
0: 	 * @param projection	The result column list for the projection
0: 	 * @param restriction	An expression representing the restriction to be 
0: 	 *					    evaluated here.
0: 	 * @param restrictionList Restriction as a PredicateList
0: 	 * @param projectSubquerys List of subqueries in the projection
0: 	 * @param restrictSubquerys List of subqueries in the restriction
0: 	 * @param tableProperties	Properties list associated with the table
0: 	 */
0: 
0: 	public void init(
0: 							Object childResult,
0: 			 				Object projection,
0: 							Object restriction,
0: 							Object restrictionList,
0: 							Object projectSubquerys,
0: 							Object restrictSubquerys,
0: 							Object tableProperties)
0: 	{
0: 		super.init(childResult, tableProperties);
0: 		resultColumns = (ResultColumnList) projection;
0: 		this.restriction = (ValueNode) restriction;
0: 		this.restrictionList = (PredicateList) restrictionList;
0: 		this.projectSubquerys = (SubqueryList) projectSubquerys;
0: 		this.restrictSubquerys = (SubqueryList) restrictSubquerys;
0: 
0: 		/* A PRN will only hold the tableProperties for
0: 		 * a result set tree if its child is not an
0: 		 * optimizable.  Otherwise, the properties will
0: 		 * be transferred down to the child.
0: 		 */
0: 		if (tableProperties != null &&
0: 			 (childResult instanceof Optimizable))
0: 		{
0: 			((Optimizable) childResult).setProperties(getProperties());
0: 			setProperties((Properties) null);
0: 		}
0: 	}
0: 
0: 	/*
0: 	 *  Optimizable interface
0: 	 */
0: 
0: 	/**
0: 		@see Optimizable#nextAccessPath
0: 		@exception StandardException	Thrown on error
0: 	 */
0: 	public boolean nextAccessPath(Optimizer optimizer,
0: 									OptimizablePredicateList predList,
0: 									RowOrdering rowOrdering)
0: 			throws StandardException
0: 	{
0: 		/*
0: 		** If the child result set is an optimizable, let it choose its next
0: 		** access path.  If it is not an optimizable, we have to tell the
0: 		** caller that there is an access path the first time we are called
0: 		** for this position in the join order, and that there are no more
0: 		** access paths for subsequent calls for this position in the join
0: 		** order.  The startOptimizing() method is called once on each
0: 		** optimizable when it is put into a join position.
0: 		*/
0: 		if (childResult instanceof Optimizable)
0: 		{
0: 			return ((Optimizable) childResult).nextAccessPath(optimizer,
0: 																restrictionList,
0: 																rowOrdering);
0: 		}
0: 		else
0: 		{
0: 			return super.nextAccessPath(optimizer, predList, rowOrdering);
0: 		}
0: 	}
0: 
0: 	/** @see Optimizable#rememberAsBest 
0: 		@exception StandardException	Thrown on error
0: 	 */
0: 	public void rememberAsBest(int planType)
0: 		throws StandardException
0: 	{
0: 		super.rememberAsBest(planType);
0: 		if (childResult instanceof Optimizable)
0: 			((Optimizable) childResult).rememberAsBest(planType);
0: 	}
0: 
0: 	/* Don't print anything for a PRN, as their
0: 	 * child has the interesting info.
0: 	 */
0: 	void printRememberingBestAccessPath(int planType, AccessPath bestPath)
0: 	{
0: 	}
0: 
0: 	/** @see Optimizable#startOptimizing */
0: 	public void startOptimizing(Optimizer optimizer, RowOrdering rowOrdering)
0: 	{
0: 		if (childResult instanceof Optimizable)
0: 		{
0: 			((Optimizable) childResult).startOptimizing(optimizer, rowOrdering);
0: 		}
0: 		else
0: 		{
0: 			accessPathConsidered = false;
0: 
0: 			super.startOptimizing(optimizer, rowOrdering);
0: 		}
0: 	}
0: 
0: 	/** @see Optimizable#getTableNumber */
0: 	public int getTableNumber()
0: 	{
0: 		/* GROSS HACK - We need to get the tableNumber after
0: 		 * calling modifyAccessPaths() on the child when doing
0: 		 * a hash join on an arbitrary result set.  The problem
0: 		 * is that the child will always be an optimizable at this
0: 		 * point.  So, we 1st check to see if we should get it from
0: 		 * this node.  (We set the boolean to true in the appropriate
0: 		 * place in modifyAccessPaths().)
0: 		 */
0: 		if (getTableNumberHere)
0: 		{
0: 			return super.getTableNumber();
0: 		}
0: 
0: 		if (childResult instanceof Optimizable)
0: 			return ((Optimizable) childResult).getTableNumber();
0: 
0: 		return super.getTableNumber();
0: 	}
0: 
0: 	/**
0: 	 * @see Optimizable#optimizeIt
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public CostEstimate optimizeIt(
0: 							Optimizer optimizer,
0: 							OptimizablePredicateList predList,
0: 							CostEstimate outerCost,
0: 							RowOrdering rowOrdering)
0: 			throws StandardException
0: 	{
0: 		/*
0: 		** RESOLVE: Most types of Optimizables only implement estimateCost(),
0: 		** and leave it up to optimizeIt() in FromTable to figure out the
0: 		** total cost of the join.  A ProjectRestrict can have a non-Optimizable
0: 		** child, though, in which case we want to tell the child the
0: 		** number of outer rows - it could affect the join strategy
0: 		** significantly.  So we implement optimizeIt() here, which overrides
0: 		** the optimizeIt() in FromTable.  This assumes that the join strategy
0: 		** for which this join node is the inner table is a nested loop join,
0: 		** which will not be a valid assumption when we implement other
0: 		** strategies like materialization (hash join can work only on
0: 		** base tables).  The join strategy for a base table under a
0: 		** ProjectRestrict is set in the base table itself.
0: 		*/
0: 
0: 		CostEstimate childCost;
0: 
0: 		costEstimate = getCostEstimate(optimizer);
0: 
0: 		/*
0: 		** Don't re-optimize a child result set that has already been fully
0: 		** optimized.  For example, if the child result set is a SelectNode,
0: 		** it will be changed to a ProjectRestrictNode, which we don't want
0: 		** to re-optimized.
0: 		*/
0: 		// NOTE: TO GET THE RIGHT COST, THE CHILD RESULT MAY HAVE TO BE
0: 		// OPTIMIZED MORE THAN ONCE, BECAUSE THE NUMBER OF OUTER ROWS
0: 		// MAY BE DIFFERENT EACH TIME.
0: 		// if (childResultOptimized)
0: 		// 	return costEstimate;
0: 
0: 		/* If the childResult is instanceof Optimizable, then we optimizeIt.
0: 		 * Otherwise, we are going into a new query block.  If the new query
0: 		 * block has already had its access path modified, then there is
0: 		 * nothing to do.  Otherwise, we must begin the optimization process
0: 		 * anew on the new query block.
0: 		 */
0: 		if (childResult instanceof Optimizable)
0: 		{
0: 			childCost = ((Optimizable) childResult).optimizeIt(
0: 															optimizer,
0: 															restrictionList,
0: 															outerCost,
0: 															rowOrdering);
0: 			/* Copy child cost to this node's cost */
0: 			costEstimate.setCost(
0: 							childCost.getEstimatedCost(),
0: 							childCost.rowCount(),
0: 							childCost.singleScanRowCount());
0: 
0: 			optimizer.considerCost(this, restrictionList, getCostEstimate(), outerCost);
0: 		}
0: 		else if ( ! accessPathModified)
0: 		{
0: 			if (SanityManager.DEBUG)
0: 			{
0: 				if (! ((childResult instanceof SelectNode) ||
0: 								 (childResult instanceof RowResultSetNode)))
0: 				{
0: 					SanityManager.THROWASSERT(
0: 						"childResult is expected to be instanceof " +
0: 						"SelectNode or RowResultSetNode - it is a " +
0: 						childResult.getClass().getName());
0: 				}
0: 			}
0: 			childResult = childResult.optimize(optimizer.getDataDictionary(), 
0: 											   restrictionList,
0: 											   outerCost.rowCount());
0: 
0: 			/* Copy child cost to this node's cost */
0: 			childCost = childResult.costEstimate;
0: 
0: 			costEstimate.setCost(
0: 							childCost.getEstimatedCost(),
0: 							childCost.rowCount(),
0: 							childCost.singleScanRowCount());
0: 
0: 			getBestAccessPath().setCostEstimate(costEstimate);
0: 
0: 			/*
0: 			** The current access path may not be part of a sort avoidance
0: 			** path, but set the cost estimate there anyway, just in case
0: 			** it is.
0: 			*/
0: 			getBestSortAvoidancePath().setCostEstimate(costEstimate);
0: 
0: 			// childResultOptimized = true;
0: 
0: 			/* RESOLVE - ARBITRARYHASHJOIN - Passing restriction list here, as above, is correct.
0: 			 * However,  passing predList makes the following work:
0: 			 *	select * from t1, (select * from t2) c properties joinStrategy = hash where t1.c1 = c.c1;
0: 			 * The following works with restrictionList:
0: 			 *	select * from t1, (select c1 + 0 from t2) c(c1) properties joinStrategy = hash where t1.c1 = c.c1;
0: 			 */
0: 			optimizer.considerCost(this, restrictionList, getCostEstimate(), outerCost);
0: 		}
0: 
0: 		return costEstimate;
0: 	}
0: 
0: 	/**
0: 	 * @see Optimizable#feasibleJoinStrategy
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public boolean feasibleJoinStrategy(OptimizablePredicateList predList,
0: 										Optimizer optimizer)
0: 					throws StandardException
0: 	{
0: 		AccessPath ap;
0: 
0: 		/* The child being an Optimizable is a special case.  In that
0: 		 * case, we want to get the current access path and join strategy
0: 		 * from the child.  Otherwise, we want to get it from this node.
0: 		 */
0: 		if (childResult instanceof Optimizable)
0: 		{
0: 			return ((Optimizable) childResult).feasibleJoinStrategy(restrictionList, optimizer);
0: 		}
0: 		else
0: 		{
0: 			return super.feasibleJoinStrategy(restrictionList, optimizer);
0: 		}
0: 	}
0: 
0: 	/** @see Optimizable#getCurrentAccessPath */
0: 	public AccessPath getCurrentAccessPath()
0: 	{
0: 		if (childResult instanceof Optimizable)
0: 			return ((Optimizable) childResult).getCurrentAccessPath();
0: 
0: 		return super.getCurrentAccessPath();
0: 	}
0: 
0: 	/** @see Optimizable#getBestAccessPath */
0: 	public AccessPath getBestAccessPath()
0: 	{
0: 		if (childResult instanceof Optimizable)
0: 			return ((Optimizable) childResult).getBestAccessPath();
0: 
0: 		return super.getBestAccessPath();
0: 	}
0: 
0: 	/** @see Optimizable#getBestSortAvoidancePath */
0: 	public AccessPath getBestSortAvoidancePath()
0: 	{
0: 		if (childResult instanceof Optimizable)
0: 			return ((Optimizable) childResult).getBestSortAvoidancePath();
0: 
0: 		return super.getBestSortAvoidancePath();
0: 	}
0: 
0: 	/** @see Optimizable#getTrulyTheBestAccessPath */
0: 	public AccessPath getTrulyTheBestAccessPath()
0: 	{
0: 		/* The childResult will always be an Optimizable
0: 		 * during code generation.  If the childResult was
0: 		 * not an Optimizable during optimization, then this node
0: 		 * will have the truly the best access path, so we want to
0: 		 * return it from this node, rather than traversing the tree.
0: 		 * This can happen for non-flattenable derived tables.
0: 		 * Anyway, we note this state when modifying the access paths.
0: 		 */
0: 		if (hasTrulyTheBestAccessPath)
0: 		{
0: 			return super.getTrulyTheBestAccessPath();
0: 		}
0: 
0: 		if (childResult instanceof Optimizable)
0: 			return ((Optimizable) childResult).getTrulyTheBestAccessPath();
0: 
0: 		return super.getTrulyTheBestAccessPath();
0: 	}
0: 
0: 	/** @see Optimizable#rememberSortAvoidancePath */
0: 	public void rememberSortAvoidancePath()
0: 	{
0: 		if (childResult instanceof Optimizable)
0: 			((Optimizable) childResult).rememberSortAvoidancePath();
0: 		else
0: 			super.rememberSortAvoidancePath();
0: 	}
0: 
0: 	/** @see Optimizable#considerSortAvoidancePath */
0: 	public boolean considerSortAvoidancePath()
0: 	{
0: 		if (childResult instanceof Optimizable)
0: 			return ((Optimizable) childResult).considerSortAvoidancePath();
0: 
0: 		return super.considerSortAvoidancePath();
0: 	}
0: 
0: 	/**
0: 	 * @see Optimizable#pushOptPredicate
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public boolean pushOptPredicate(OptimizablePredicate optimizablePredicate)
0: 			throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(optimizablePredicate instanceof Predicate,
0: 				"optimizablePredicate expected to be instanceof Predicate");
0: 			SanityManager.ASSERT(! optimizablePredicate.hasSubquery() &&
0: 								 ! optimizablePredicate.hasMethodCall(),
0: 				"optimizablePredicate either has a subquery or a method call");
0: 		}
0: 
0: 		/* Add the matching predicate to the restrictionList */
0: 		if (restrictionList == null)
0: 		{
0: 			restrictionList = (PredicateList) getNodeFactory().getNode(
0: 													C_NodeTypes.PREDICATE_LIST,
0: 													getContextManager());
0: 		}
0: 		restrictionList.addPredicate((Predicate) optimizablePredicate);
0: 
0: 		/* Remap all of the ColumnReferences to point to the
0: 		 * source of the values.
0: 		 */
0: 		RemapCRsVisitor rcrv = new RemapCRsVisitor(true);
0: 		((Predicate) optimizablePredicate).getAndNode().accept(rcrv);
0: 
0: 		return true;
0: 	}
0: 
0: 	/**
0: 	 * @see Optimizable#pullOptPredicates
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void pullOptPredicates(
0: 								OptimizablePredicateList optimizablePredicates)
0: 					throws StandardException
0: 	{
0: 		if (restrictionList != null)
0: 		{
0: 			RemapCRsVisitor rcrv = new RemapCRsVisitor(false);
0: 			for (int i = restrictionList.size() - 1; i >= 0; i--)
0: 			{
0: 				OptimizablePredicate optPred =
0: 					restrictionList.getOptPredicate(i);
0: 				((Predicate) optPred).getAndNode().accept(rcrv);
0: 				optimizablePredicates.addOptPredicate(optPred);
0: 				restrictionList.removeOptPredicate(i);
0: 			}
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * @see Optimizable#modifyAccessPath
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public Optimizable modifyAccessPath(JBitSet outerTables) 
0: 		throws StandardException
0: 	{
0: 		boolean origChildOptimizable = true;
0: 
0: 		/* It is okay to optimize most nodes multiple times.  However,
0: 		 * modifying the access path is something that should only be done
0: 		 * once per node.  One reason for this is that the predicate list
0: 		 * will be empty after the 1st call, and we assert that it should
0: 		 * be non-empty.  Multiple calls to modify the access path can
0: 		 * occur when there is a non-flattenable FromSubquery (or view).
0: 		 */
0: 		if (accessPathModified)
0: 		{
0: 			return this;
0: 		}
0: 
0: 		/*
0: 		** Do nothing if the child result set is not optimizable, as there
0: 		** can be nothing to modify.
0: 		*/
0: 		if ( ! (childResult instanceof Optimizable))
0: 		{
0: 			// Remember that the original child was not Optimizable
0: 			origChildOptimizable = false;
0: 
0: 			childResult = childResult.modifyAccessPaths();
0: 			/* Mark this node as having the truly ... for
0: 			 * the underlying tree.
0: 			 */
0: 			hasTrulyTheBestAccessPath = true;
0: 
0: 			/* Replace this PRN with a HRN if we are doing a hash join */
0: 			if (trulyTheBestAccessPath.getJoinStrategy().isHashJoin())
0: 			{
0: 				if (SanityManager.DEBUG)
0: 				{
0: 					SanityManager.ASSERT(restrictionList != null,
0: 						"restrictionList expected to be non-null");
0: 					SanityManager.ASSERT(restrictionList.size() != 0,
0: 							"restrictionList.size() expected to be non-zero");
0: 				}
0: 				/* We're doing a hash join on an arbitary result set.
0: 				 * We need to get the table number from this node when
0: 				 * dividing up the restriction list for a hash join.
0: 				 * We need to explicitly remember this.
0: 				 */
0: 				getTableNumberHere = true;
0: 			}
0: 			else
0: 			{
0: 				/* We consider materialization into a temp table as a last step.
0: 				 * Currently, we only materialize VTIs that are inner tables
0: 				 * and can't be instantiated multiple times.  In the future we
0: 				 * will consider materialization as a cost based option.
0: 				 */
0: 				return (Optimizable) considerMaterialization(outerTables);
0: 			}
0: 		}
0: 
0: 		/* If the child is not a FromBaseTable, then we want to
0: 		 * keep going down the tree.  (Nothing to do at this node.)
0: 		 */
0: 		else if (!(childResult instanceof FromBaseTable))
0: 		{
0: 			/* Make sure that we have a join strategy */
0: 			if (trulyTheBestAccessPath.getJoinStrategy() == null)
0: 			{
0: 				trulyTheBestAccessPath = (AccessPathImpl) ((Optimizable) childResult).getTrulyTheBestAccessPath();
0: 			}
0: 			childResult = 
0: 				(ResultSetNode)
0: 					((FromTable) childResult).modifyAccessPath(outerTables);
0: 		}
0: 
0: 		if (restrictionList != null)
0: 		{
0: 			restrictionList.pushUsefulPredicates((Optimizable) childResult);
0: 		}
0: 
0: 		/*
0: 		** The optimizer's decision on the access path for the child result
0: 		** set may require the generation of extra result sets.  For
0: 		** example, if it chooses an index, we need an IndexToBaseRowNode
0: 		** above the FromBaseTable (and the FromBaseTable has to change
0: 		** its column list to match that of the index.
0: 		*/
0: 		if (origChildOptimizable)
0: 		{
0: 			childResult = childResult.changeAccessPath();
0: 		}
0: 		accessPathModified = true;
0: 
0: 		/*
0: 		** Replace this PRN with a HTN if a hash join
0: 		** is being done at this node.  (Hash join on a scan
0: 		** is a special case and is handled at the FBT.)
0: 		*/
0: 		if (trulyTheBestAccessPath.getJoinStrategy() != null &&
0: 			trulyTheBestAccessPath.getJoinStrategy().isHashJoin())
0: 		{
0: 			return replaceWithHashTableNode();
0: 		}
0: 
0: 		/* We consider materialization into a temp table as a last step.
0: 		 * Currently, we only materialize VTIs that are inner tables
0: 		 * and can't be instantiated multiple times.  In the future we
0: 		 * will consider materialization as a cost based option.
0: 		 */
0: 		return (Optimizable) considerMaterialization(outerTables);
0: 	}
0: 
0: 	/**
0: 	 * This method creates a HashTableNode between the PRN and
0: 	 * it's child when the optimizer chooses hash join on an
0: 	 * arbitrary (non-FBT) result set tree.
0: 	 * We divide up the restriction list into 3 parts and
0: 	 * distribute those parts as described below.
0: 	 * 
0: 	 * @return The new (same) top of our result set tree.
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	private Optimizable replaceWithHashTableNode()
0: 		throws StandardException
0: 	{
0: 		/* We want to divide the predicate list into 3 separate lists -
0: 		 *	o predicates against the source of the hash table, which will
0: 		 *	  be applied on the way into the hash table (searchRestrictionList)
0: 		 *  o join clauses which are qualifiers and get applied to the
0: 		 *	  rows in the hash table on a probe (joinRestrictionList)
0: 		 *	o non-qualifiers involving both tables which will get
0: 		 *	  applied after a row gets returned from the HTRS (nonQualifiers)
0: 		 *
0: 		 * We do some unnecessary work when doing this as we want to reuse
0: 		 * as much existing code as possible.  The code that we are reusing
0: 		 * was originally built for hash scans, hence the unnecessary
0: 		 * requalification list.
0: 		 */
0: 		PredicateList searchRestrictionList =
0: 								(PredicateList) getNodeFactory().getNode(
0: 													C_NodeTypes.PREDICATE_LIST,
0: 													getContextManager());
0: 		PredicateList joinQualifierList =
0: 								(PredicateList) getNodeFactory().getNode(
0: 													C_NodeTypes.PREDICATE_LIST,
0: 													getContextManager());
0: 		PredicateList requalificationRestrictionList =
0: 								(PredicateList) getNodeFactory().getNode(
0: 													C_NodeTypes.PREDICATE_LIST,
0: 													getContextManager());
0: 		trulyTheBestAccessPath.getJoinStrategy().divideUpPredicateLists(
0: 											this,
0: 											restrictionList,
0: 											searchRestrictionList,
0: 											joinQualifierList,
0: 											requalificationRestrictionList,
0: 											getDataDictionary());
0: 
0: 		/* Break out the non-qualifiers from HTN's join qualifier list and make that
0: 		 * the new restriction list for this PRN.
0: 		 */
0: 		restrictionList = (PredicateList) getNodeFactory().getNode(
0: 											C_NodeTypes.PREDICATE_LIST,
0: 											getContextManager());
0:         /* For non-base table, we remove first 2 lists from requal list to avoid adding duplicates.
0:          */
0: 		for (int i = 0; i < searchRestrictionList.size(); i++)
0: 			requalificationRestrictionList.removeOptPredicate((Predicate) searchRestrictionList.elementAt(i));
0: 		for (int i = 0; i < joinQualifierList.size(); i++)
0: 			requalificationRestrictionList.removeOptPredicate((Predicate) joinQualifierList.elementAt(i));
0: 
0: 		joinQualifierList.transferNonQualifiers(this, restrictionList); //purify joinQual list
0: 		requalificationRestrictionList.copyPredicatesToOtherList(restrictionList); //any residual
0: 
0: 		ResultColumnList	htRCList;
0: 
0: 		/* We get a shallow copy of the child's ResultColumnList and its 
0: 		 * ResultColumns.  (Copy maintains ResultColumn.expression for now.)
0: 		 */
0: 		htRCList = childResult.getResultColumns();
0: 		childResult.setResultColumns(htRCList.copyListAndObjects());
0: 
0: 		/* Replace ResultColumn.expression with new VirtualColumnNodes
0: 		 * in the HTN's ResultColumnList.  (VirtualColumnNodes include
0: 		 * pointers to source ResultSetNode, this, and source ResultColumn.)
0: 		 * NOTE: We don't want to mark the underlying RCs as referenced, otherwise
0: 		 * we won't be able to project out any of them.
0: 		 */
0: 		htRCList.genVirtualColumnNodes(childResult, childResult.getResultColumns(), false);
0: 
0: 		/* The CRs for this side of the join in both the searchRestrictionList
0: 		 * the joinQualifierList now point to the HTN's RCL.  We need them
0: 		 * to point to the RCL in the child of the HTN.  (We skip doing this for
0: 		 * the joinQualifierList as the code to generate the Qualifiers does not
0: 		 * care.)
0: 		 */
0: 		RemapCRsVisitor rcrv = new RemapCRsVisitor(true);
0: 		searchRestrictionList.accept(rcrv);
0: 
0: 		/* We can finally put the HTN between ourself and our old child. */
0: 		childResult = (ResultSetNode) getNodeFactory().getNode(
0: 											C_NodeTypes.HASH_TABLE_NODE,
0: 											childResult,
0: 											tableProperties, 
0: 											htRCList,
0: 											searchRestrictionList, 
0: 											joinQualifierList,
0: 											trulyTheBestAccessPath, 
0: 											getCostEstimate(),
0: 											projectSubquerys,
0: 											restrictSubquerys,
0: 											hashKeyColumns(),
0: 											getContextManager());
0: 		return this;
0: 	}
0: 
0: 	/** @see Optimizable#verifyProperties 
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void verifyProperties(DataDictionary dDictionary)
0: 		throws StandardException
0: 	{
0: 		/* Table properties can be attached to this node if
0: 		 * its child is not an optimizable, otherwise they
0: 		 * are attached to its child.
0: 		 */
0: 
0: 		if (childResult instanceof Optimizable)
0: 		{
0: 			((Optimizable) childResult).verifyProperties(dDictionary);
0: 		}
0: 		else
0: 		{
0: 			super.verifyProperties(dDictionary);
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * @see Optimizable#legalJoinOrder
0: 	 */
0: 	public boolean legalJoinOrder(JBitSet assignedTableMap)
0: 	{
0: 		if (childResult instanceof Optimizable)
0: 		{
0: 			return ((Optimizable) childResult).legalJoinOrder(assignedTableMap);
0: 		}
0: 		else
0: 		{
0: 			return true;
0: 		}
0: 	}
0: 
0: 	/** @see Optimizable#isMaterializable 
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public boolean isMaterializable()
0: 		throws StandardException
0: 	{
0: 		/* RESOLVE - Disallow arbitrary hash joins on
0: 		 * SELECTS within a derived table for now.
0: 		 * Remove this method once that restriction is removed.
0: 		 */
0: 		if (! (childResult instanceof Optimizable))
0: 		{
0: 			return false;
0: 		}
0: 
0: 		return super.isMaterializable();
0: 	}
0: 
0: 	/**
0: 	 * @see Optimizable#uniqueJoin
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public double uniqueJoin(OptimizablePredicateList predList)
0: 					throws StandardException
0: 	{
0: 		if (childResult instanceof Optimizable)
0: 		{
0: 			return ((Optimizable) childResult).uniqueJoin(predList);
0: 		}
0: 		else
0: 		{
0: 			return super.uniqueJoin(predList);
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Return the restriction list from this node.
0: 	 *
0: 	 * @return	The restriction list from this node.
0: 	 */
0: 	PredicateList getRestrictionList()
0: 	{
0: 		return restrictionList;
0: 	}
0: 
0: 	/** 
0: 	 * Return the user specified join strategy, if any for this table.
0: 	 *
0: 	 * @return The user specified join strategy, if any for this table.
0: 	 */
0: 	String getUserSpecifiedJoinStrategy()
0: 	{
0: 		if (childResult instanceof FromTable)
0: 		{
0: 			return ((FromTable) childResult).getUserSpecifiedJoinStrategy();
0: 		}
0: 		else
0: 		{
0: 			return userSpecifiedJoinStrategy;
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
0: 	 * how tree printing is supposed to work.
0: 	 *
0: 	 * @param depth		The depth of this node in the tree
0: 	 *
0: 	 * @return	Nothing
0: 	 */
0: 
0: 	public void printSubNodes(int depth)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			super.printSubNodes(depth);
0: 
0: 			if (restriction != null)
0: 			{
0: 				printLabel(depth, "restriction: ");
0: 				restriction.treePrint(depth + 1);
0: 			}
0: 
0: 			if (restrictionList != null)
0: 			{
0: 				printLabel(depth, "restrictionList: ");
0: 				restrictionList.treePrint(depth + 1);
0: 			}
0: 
0: 			if (projectSubquerys != null)
0: 			{
0: 				printLabel(depth, "projectSubquerys: ");
0: 				projectSubquerys.treePrint(depth + 1);
0: 			}
0: 
0: 			if (restrictSubquerys != null)
0: 			{
0: 				printLabel(depth, "restrictSubquerys: ");
0: 				restrictSubquerys.treePrint(depth + 1);
0: 			}
0: 		}
0: 	}
0: 
0: 	/** 
0: 	 * Put a ProjectRestrictNode on top of each FromTable in the FromList.
0: 	 * ColumnReferences must continue to point to the same ResultColumn, so
0: 	 * that ResultColumn must percolate up to the new PRN.  However,
0: 	 * that ResultColumn will point to a new expression, a VirtualColumnNode, 
0: 	 * which points to the FromTable and the ResultColumn that is the source for
0: 	 * the ColumnReference.  
0: 	 * (The new PRN will have the original of the ResultColumnList and
0: 	 * the ResultColumns from that list.  The FromTable will get shallow copies
0: 	 * of the ResultColumnList and its ResultColumns.  ResultColumn.expression
0: 	 * will remain at the FromTable, with the PRN getting a new 
0: 	 * VirtualColumnNode for each ResultColumn.expression.)
0: 	 * We then project out the non-referenced columns.  If there are no referenced
0: 	 * columns, then the PRN's ResultColumnList will consist of a single ResultColumn
0: 	 * whose expression is 1.
0: 	 *
0: 	 * @param numTables			Number of tables in the DML Statement
0: 	 * @param gbl				The group by list, if any
0: 	 * @param fromList			The from list, if any
0: 	 *
0: 	 * @return The generated ProjectRestrictNode atop the original FromTable.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public ResultSetNode preprocess(int numTables,
0: 									GroupByList gbl,
0: 									FromList fromList) 
0: 								throws StandardException
0: 	{
0: 		childResult = childResult.preprocess(numTables, gbl, fromList);
0: 
0: 		/* Build the referenced table map */
0: 		referencedTableMap = (JBitSet) childResult.getReferencedTableMap().clone();
0: 
0: 		return this;
0: 	}
0: 
0: 	/**
0: 	 * Push expressions down to the first ResultSetNode which can do expression
0: 	 * evaluation and has the same referenced table map.
0: 	 * RESOLVE - This means only pushing down single table expressions to
0: 	 * ProjectRestrictNodes today.  Once we have a better understanding of how
0: 	 * the optimizer will work, we can push down join clauses.
0: 	 *
0: 	 * @param predicateList	The PredicateList.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void pushExpressions(PredicateList predicateList)
0: 					throws StandardException
0: 	{
0: 		PredicateList	pushPList = null;
0: 
0: 		if (SanityManager.DEBUG)
0: 		SanityManager.ASSERT(predicateList != null,
0: 							 "predicateList is expected to be non-null");
0: 
0: 		/* Push single table predicates down to the left of an outer
0: 		 * join, if possible.  (We need to be able to walk an entire
0: 		 * join tree.)
0: 		 */
0: 		if (childResult instanceof JoinNode)
0: 		{
0: 			((FromTable) childResult).pushExpressions(predicateList);
0: 
0: 		}
0: 
0: 		/* Build a list of the single table predicates that we can push down */
0: 		pushPList = predicateList.getPushablePredicates(referencedTableMap);
0: 
0: 		/* If this is a PRN above a SelectNode, probably due to a 
0: 		 * view or derived table which couldn't be flattened, then see
0: 		 * if we can push any of the predicates which just got pushed
0: 		 * down to our level into the SelectNode.
0: 		 */
0: 		if (pushPList != null && (childResult instanceof SelectNode))
0: 		{
0: 			pushPList.pushExpressionsIntoSelect((SelectNode) childResult);
0: 		}
0: 
0: 		if (restrictionList == null)
0: 		{
0: 			restrictionList = pushPList;
0: 		}
0: 		else if (pushPList != null && pushPList.size() != 0)
0: 		{
0: 			/* Concatenate the 2 PredicateLists */
0: 			restrictionList.destructiveAppend(pushPList);
0: 		}
0: 
0: 		/* RESOLVE - this looks like the place to try to try to push the 
0: 		 * predicates through the ProjectRestrict.  Seems like we should
0: 		 * "rebind" the column references and reset the referenced table maps
0: 		 * in restrictionList and then call childResult.pushExpressions() on
0: 		 * restrictionList.
0: 		 */
0: 	}
0: 
0: 	/**
0: 	 * Add a new predicate to the list.  This is useful when doing subquery
0: 	 * transformations, when we build a new predicate with the left side of
0: 	 * the subquery operator and the subquery's result column.
0: 	 *
0: 	 * @param predicate		The predicate to add
0: 	 *
0: 	 * @return ResultSetNode	The new top of the tree.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public ResultSetNode addNewPredicate(Predicate predicate)
0: 			throws StandardException
0: 	{
0: 		if (restrictionList == null)
0: 		{
0: 			restrictionList = (PredicateList) getNodeFactory().getNode(
0: 													C_NodeTypes.PREDICATE_LIST,
0: 													getContextManager());
0: 		}
0: 		restrictionList.addPredicate(predicate);
0: 		return this;
0: 	}
0: 
0: 	/**
0: 	 * Evaluate whether or not the subquery in a FromSubquery is flattenable.  
0: 	 * Currently, a FSqry is flattenable if all of the following are true:
0: 	 *		o  Subquery is a SelectNode. 
0: 	 *		o  It contains no top level subqueries.  (RESOLVE - we can relax this)
0: 	 *		o  It does not contain a group by or having clause
0: 	 *		o  It does not contain aggregates.
0: 	 *
0: 	 * @param fromList	The outer from list
0: 	 *
0: 	 * @return boolean	Whether or not the FromSubquery is flattenable.
0: 	 */
0: 	public boolean flattenableInFromSubquery(FromList fromList)
0: 	{
0: 		/* Flattening currently involves merging predicates and FromLists.
0: 		 * We don't have a FromList, so we can't flatten for now.
0: 		 */
0: 		/* RESOLVE - this will introduce yet another unnecessary PRN */
0: 		return false;
0: 	}
0: 
0: 	/**
0: 	 * Ensure that the top of the RSN tree has a PredicateList.
0: 	 *
0: 	 * @param numTables			The number of tables in the query.
0: 	 * @return ResultSetNode	A RSN tree with a node which has a PredicateList on top.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public ResultSetNode ensurePredicateList(int numTables) 
0: 		throws StandardException
0: 	{
0: 		return this;
0: 	}
0: 
0: 	/**
0: 	 * Optimize this ProjectRestrictNode.  
0: 	 *
0: 	 * @param dataDictionary	The DataDictionary to use for optimization
0: 	 * @param predicateList		The PredicateList to optimize.  This should
0: 	 *							be a join predicate.
0: 	 * @param outerRows			The number of outer joining rows
0: 	 *
0: 	 * @return	ResultSetNode	The top of the optimized subtree
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public ResultSetNode optimize(DataDictionary dataDictionary,
0: 								  PredicateList predicates,
0: 								  double outerRows) 
0: 					throws StandardException
0: 	{
0: 		/* We need to implement this method since a PRN can appear above a
0: 		 * SelectNode in a query tree.
0: 		 */
0: 		childResult = childResult.optimize(dataDictionary,
0: 											restrictionList,
0: 											outerRows);
0: 
0: 		Optimizer optimizer = getOptimizer(
0: 								(FromList) getNodeFactory().getNode(
0: 									C_NodeTypes.FROM_LIST,
0: 									getNodeFactory().doJoinOrderOptimization(),
0: 									this,
0: 									getContextManager()),
0: 								predicates,
0: 								dataDictionary,
0: 								(RequiredRowOrdering) null);
0: 
0: 		// RESOLVE: SHOULD FACTOR IN THE NON-OPTIMIZABLE PREDICATES THAT
0: 		// WERE NOT PUSHED DOWN
0: 		costEstimate = optimizer.newCostEstimate();
0: 
0: 		costEstimate.setCost(childResult.getCostEstimate().getEstimatedCost(),
0: 							childResult.getCostEstimate().rowCount(),
0: 							childResult.getCostEstimate().singleScanRowCount());
0: 
0: 		return this;
0: 	}
0: 
0: 	/**
0: 	 * Get the CostEstimate for this ProjectRestrictNode.
0: 	 *
0: 	 * @return	The CostEstimate for this ProjectRestrictNode, which is
0: 	 * 			the cost estimate for the child node.
0: 	 */
0: 	public CostEstimate getCostEstimate()
0: 	{
0: 		/*
0: 		** The cost estimate will be set here if either optimize() or
0: 		** optimizeIt() was called on this node.  It's also possible
0: 		** that optimization was done directly on the child node,
0: 		** in which case the cost estimate will be null here.
0: 		*/
0: 		if (costEstimate == null)
0: 			return childResult.getCostEstimate();
0: 		else
0: 		{
0: 			return costEstimate;
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Get the final CostEstimate for this ProjectRestrictNode.
0: 	 *
0: 	 * @return	The final CostEstimate for this ProjectRestrictNode, which is
0: 	 * 			the final cost estimate for the child node.
0: 	 */
0: 	public CostEstimate getFinalCostEstimate()
0: 	{
0: 		/*
0: 		** The cost estimate will be set here if either optimize() or
0: 		** optimizeIt() was called on this node.  It's also possible
0: 		** that optimization was done directly on the child node,
0: 		** in which case the cost estimate will be null here.
0: 		*/
0: 		if (costEstimate == null)
0: 			return childResult.getFinalCostEstimate();
0: 		else
0: 		{
0: 			return costEstimate;
0: 		}
0: 	}
0: 
0:     /**
0:      * For joins, the tree will be (nodes are left out if the clauses
0:      * are empty):
0:      *
0:      *      ProjectRestrictResultSet -- for the having and the select list
0:      *      SortResultSet -- for the group by list
0:      *      ProjectRestrictResultSet -- for the where and the select list (if no group or having)
0:      *      the result set for the fromList
0:      *
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0:      */
0: 	public void generate(ActivationClassBuilder acb,
0: 								MethodBuilder mb)
0: 							throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG)
0:         SanityManager.ASSERT(resultColumns != null, "Tree structure bad");
0: 
0: 		generateMinion( acb, mb, false);
0: 	}
0: 
0: 	/**
0: 	 * General logic shared by Core compilation.
0: 	 *
0: 	 * @param ecb	The ExpressionClassBuilder for the class being built
0: 	 * @param mb	The method the expression will go into
0: 	 *
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public void generateResultSet(ExpressionClassBuilder acb,
0: 										   MethodBuilder mb)
0: 									throws StandardException
0: 	{
0: 		generateMinion( acb, mb, true);
0: 	}
0: 
0: 	/**
0: 	 * Logic shared by generate() and generateResultSet().
0: 	 *
0: 	 * @param ecb	The ExpressionClassBuilder for the class being built
0: 	 * @param mb	The method the expression will go into
0: 	 *
0: 	 * @return		The compiled Expression
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	private void generateMinion(ExpressionClassBuilder acb,
0: 									 MethodBuilder mb, boolean genChildResultSet)
0: 									throws StandardException
0: 	{
0: 
0: 		/* If this ProjectRestrict doesn't do anything, bypass its generation.
0: 		 * (Remove any true and true predicates first, as they could be left
0: 		 * by the like transformation.)
0: 		 */
0: 		if (restrictionList != null && restrictionList.size() > 0)
0: 		{
0: 			restrictionList.eliminateBooleanTrueAndBooleanTrue();
0: 		}
0: 
0: 		if (nopProjectRestrict())
0: 		{
0: 			generateNOPProjectRestrict();
0: 			if (genChildResultSet)
0: 				childResult.generateResultSet(acb, mb);
0: 			else
0: 				childResult.generate((ActivationClassBuilder)acb, mb);
0: 			costEstimate = childResult.getFinalCostEstimate();
0: 			return;
0: 		}
0: 
0: 		// build up the tree.
0: 
0: 		/* Put the predicates back into the tree */
0: 		if (restrictionList != null)
0: 		{
0: 			constantRestriction = restrictionList.restoreConstantPredicates();
0: 			// Remove any redundant predicates before restoring
0: 			restrictionList.removeRedundantPredicates();
0: 			restriction = restrictionList.restorePredicates();
0: 			/* Allow the restrictionList to get garbage collected now
0: 			 * that we're done with it.
0: 			 */
0: 			restrictionList = null;
0: 		}
0: 
0: 		// for the restriction, we generate an exprFun
0: 		// that evaluates the expression of the clause
0: 		// against the current row of the child's result.
0: 		// if the restriction is empty, simply pass null
0: 		// to optimize for run time performance.
0: 
0:    		// generate the function and initializer:
0:    		// Note: Boolean lets us return nulls (boolean would not)
0:    		// private Boolean exprN()
0:    		// {
0:    		//   return <<restriction.generate(ps)>>;
0:    		// }
0:    		// static Method exprN = method pointer to exprN;
0: 
0: 
0: 
0: 
0: 		// Map the result columns to the source columns
0: 		int[] mapArray = resultColumns.mapSourceColumns();
0: 		int mapArrayItem = acb.addItem(new ReferencedColumnsDescriptorImpl(mapArray));
0: 
0: 		/* Will this node do a projection? */
0: 		boolean doesProjection = true;
0: 
0: 		/* Does a projection unless same # of columns in same order
0: 		 * as child.
0: 		 */
0: 		if ( (! reflectionNeededForProjection()) && 
0: 		    mapArray != null && 
0: 			mapArray.length == childResult.getResultColumns().size())
0: 		{
0: 			/* mapArray entries are 1-based */
0: 			int index = 0;
0: 			for ( ; index < mapArray.length; index++)
0: 			{
0: 				if (mapArray[index] != index + 1)
0: 				{
0: 					break;
0: 				}
0: 			}
0: 			if (index == mapArray.length)
0: 			{
0: 				doesProjection = false;
0: 			}
0: 		}
0: 
0: 
0: 
0: 		/* Generate the ProjectRestrictSet:
0: 		 *	arg1: childExpress - Expression for childResultSet
0: 		 *  arg2: Activation
0: 		 *  arg3: restrictExpress - Expression for restriction
0: 		 *  arg4: projectExpress - Expression for projection
0: 		 *  arg5: resultSetNumber
0: 		 *  arg6: constantExpress - Expression for constant restriction
0: 		 *			(for example, where 1 = 2)
0: 		 *  arg7: mapArrayItem - item # for mapping of source columns
0: 		 *  arg8: reuseResult - whether or not the result row can be reused
0: 		 *						(ie, will it always be the same)
0: 		 *  arg9: doesProjection - does this node do a projection
0: 		 *  arg10: estimated row count
0: 		 *  arg11: estimated cost
0: 		 *  arg12: close method
0: 		 */
0: 
0: 		acb.pushGetResultSetFactoryExpression(mb);
0: 		if (genChildResultSet)
0: 			childResult.generateResultSet(acb, mb);
0: 		else
0: 			childResult.generate((ActivationClassBuilder)acb, mb);
0: 
0: 		/* Get the next ResultSet #, so that we can number this ResultSetNode, its
0: 		 * ResultColumnList and ResultSet.
0: 		 */
0: 		assignResultSetNumber();
0: 		
0: 		/* Set the point of attachment in all subqueries attached
0: 		 * to this node.
0: 		 */
0: 		if (projectSubquerys != null && projectSubquerys.size() > 0)
0: 		{
0: 			projectSubquerys.setPointOfAttachment(resultSetNumber);
0: 		}
0: 		if (restrictSubquerys != null && restrictSubquerys.size() > 0)
0: 		{
0: 			restrictSubquerys.setPointOfAttachment(resultSetNumber);
0: 		}
0: 
0: 		/* Drop our cost estimate if it is uninitialized. */
0: 		if (costEstimate != null && costEstimate.isUninitialized())
0: 		{
0: 			costEstimate = childResult.getFinalCostEstimate();
0: 		}
0: 
0: 		acb.pushThisAsActivation(mb);
0: 
0: 		// if there is no restriction, we just want to pass null.
0: 		if (restriction == null)
0: 		{
0: 		   	mb.pushNull(ClassName.GeneratedMethod);
0: 		}
0: 		else
0: 		{
0: 			// this sets up the method and the static field.
0: 			// generates:
0: 			// 	Object userExprFun { }
0: 			MethodBuilder userExprFun = acb.newUserExprFun();
0: 
0: 			// restriction knows it is returning its value;
0: 
0: 			/* generates:
0: 			 *    return  <restriction.generate(acb)>;
0: 			 * and adds it to userExprFun
0: 			 * NOTE: The explicit cast to DataValueDescriptor is required
0: 			 * since the restriction may simply be a boolean column or subquery
0: 			 * which returns a boolean.  For example:
0: 			 *		where booleanColumn
0: 			 */
0: 			restriction.generateExpression(acb, userExprFun);
0: 			userExprFun.methodReturn();
0: 
0: 			// we are done modifying userExprFun, complete it.
0: 			userExprFun.complete();
0: 
0: 	   		// restriction is used in the final result set as an access of the new static
0:    			// field holding a reference to this new method.
0: 			// generates:
0: 			//	ActivationClass.userExprFun
0: 			// which is the static field that "points" to the userExprFun
0: 			// that evaluates the where clause.
0:    			acb.pushMethodReference(mb, userExprFun);
0: 		}
0: 
0: 		/* Determine whether or not reflection is needed for the projection.
0: 		 * Reflection is not needed if all of the columns map directly to source
0: 		 * columns.
0: 		 */
0: 		if (reflectionNeededForProjection())
0: 		{
0: 			// for the resultColumns, we generate a userExprFun
0: 			// that creates a new row from expressions against
0: 			// the current row of the child's result.
0: 			// (Generate optimization: see if we can simply
0: 			// return the current row -- we could, but don't, optimize
0: 			// the function call out and have execution understand
0: 			// that a null function pointer means take the current row
0: 			// as-is, with the performance trade-off as discussed above.)
0: 
0: 			/* Generate the Row function for the projection */
0: 			resultColumns.generateCore(acb, mb, false);
0: 		}
0: 		else
0: 		{
0: 		   	mb.pushNull(ClassName.GeneratedMethod);
0: 		}
0: 		
0: 		mb.push(resultSetNumber);
0: 
0: 		// if there is no constant restriction, we just want to pass null.
0: 		if (constantRestriction == null)
0: 		{
0: 		   	mb.pushNull(ClassName.GeneratedMethod);
0: 		}
0: 		else
0: 		{
0: 			// this sets up the method and the static field.
0: 			// generates:
0: 			// 	userExprFun { }
0: 			MethodBuilder userExprFun = acb.newUserExprFun();
0: 
0: 			// restriction knows it is returning its value;
0: 
0: 			/* generates:
0: 			 *    return <restriction.generate(acb)>;
0: 			 * and adds it to userExprFun
0: 			 * NOTE: The explicit cast to DataValueDescriptor is required
0: 			 * since the restriction may simply be a boolean column or subquery
0: 			 * which returns a boolean.  For example:
0: 			 *		where booleanColumn
0: 			 */
0: 			constantRestriction.generateExpression(acb, userExprFun);
0: 
0: 			userExprFun.methodReturn();
0: 
0: 			// we are done modifying userExprFun, complete it.
0: 			userExprFun.complete();
0: 
0: 	   		// restriction is used in the final result set as an access
0: 			// of the new static field holding a reference to this new method.
0: 			// generates:
0: 			//	ActivationClass.userExprFun
0: 			// which is the static field that "points" to the userExprFun
0: 			// that evaluates the where clause.
0:    			acb.pushMethodReference(mb, userExprFun);
0: 		}
0: 		
0: 		mb.push(mapArrayItem);
0: 		mb.push(resultColumns.reusableResult());
0: 		mb.push(doesProjection);
0: 		mb.push(getFinalCostEstimate().rowCount());
0: 		mb.push(getFinalCostEstimate().getEstimatedCost());
0: 		closeMethodArgument(acb, mb);
0: 
0: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, "getProjectRestrictResultSet",
0: 					ClassName.NoPutResultSet, 12);
0: 	}
0: 
0: 	/**
0: 	 * Determine whether this ProjectRestrict does anything.  If it doesn't
0: 	 * filter out any rows or columns, it's a No-Op.
0: 	 *
0: 	 * @return	true if this ProjectRestrict is a No-Op.
0: 	 */
0: 	boolean nopProjectRestrict()
0: 	{
0: 		/*
0: 		** This ProjectRestrictNode is not a No-Op if it does any
0: 		** restriction.
0: 		*/
0: 		if ( (restriction != null) ||
0: 			 (restrictionList != null && restrictionList.size() > 0) )
0: 		{
0: 			return false;
0: 		}
0: 
0: 		ResultColumnList	childColumns = childResult.getResultColumns();
0: 		ResultColumnList	PRNColumns = this.getResultColumns();
0: 
0: 		/*
0: 		** The two lists have the same numbers of elements.  Are the lists
0: 		** identical?  In other words, is the expression in every ResultColumn
0: 		** in the PRN's RCL a ColumnReference that points to the same-numbered
0: 		** column?
0: 		*/
0: 		if (PRNColumns.nopProjection(childColumns))
0: 			return true;
0: 
0: 		return false;
0: 	}
0: 
0: 	/**
0: 	 * Bypass the generation of this No-Op ProjectRestrict, and just generate
0: 	 * its child result set.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void generateNOPProjectRestrict()
0: 			throws StandardException
0: 	{
0: 		this.getResultColumns().setRedundant();
0: 	}
0: 
0: 	/**
0: 	 * Consider materialization for this ResultSet tree if it is valid and cost effective
0: 	 * (It is not valid if incorrect results would be returned.)
0: 	 *
0: 	 * @return Top of the new/same ResultSet tree.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public ResultSetNode considerMaterialization(JBitSet outerTables)
0: 		throws StandardException
0: 	{
0: 		childResult = childResult.considerMaterialization(outerTables);
0: 		if (childResult.performMaterialization(outerTables))
0: 		{
0: 			MaterializeResultSetNode	mrsn;
0: 			ResultColumnList			prRCList;
0: 
0: 			/* If the restriction contians a ColumnReference from another
0: 			 * table then the MRSN must go above the childResult.  Otherwise we can put
0: 			 * it above ourselves. (The later is optimal since projection and restriction 
0: 			 * will only happen once.)
0: 			 * Put MRSN above PRN if any of the following are true:
0: 			 *	o  PRN doesn't have a restriction list
0: 			 *	o  PRN's restriction list is empty 
0: 			 *  o  Table's referenced in PRN's restriction list are a subset of
0: 			 *	   table's referenced in PRN's childResult.  (NOTE: Rather than construct
0: 			 *     a new, empty JBitSet before checking, we simply clone the childResult's
0: 			 *	   referencedTableMap.  This is done for code simplicity and will not 
0: 			 *	   affect the result.)
0: 			 */
0: 			ReferencedTablesVisitor rtv = new ReferencedTablesVisitor(
0: 												(JBitSet) childResult.getReferencedTableMap().clone());
0: 			boolean emptyRestrictionList = (restrictionList == null || restrictionList.size() == 0);
0: 			if (! emptyRestrictionList)
0: 			{
0: 				restrictionList.accept(rtv);
0: 			}
0: 			if (emptyRestrictionList ||
0: 				childResult.getReferencedTableMap().contains(rtv.getTableMap()))
0: 			{
0: 				/* We get a shallow copy of the ResultColumnList and its 
0: 				 * ResultColumns.  (Copy maintains ResultColumn.expression for now.)
0: 				 */
0: 				prRCList = resultColumns;
0: 				setResultColumns(resultColumns.copyListAndObjects());
0: 
0: 				/* Replace ResultColumn.expression with new VirtualColumnNodes
0: 				 * in the NormalizeResultSetNode's ResultColumnList.  (VirtualColumnNodes include
0: 				 * pointers to source ResultSetNode, this, and source ResultColumn.)
0: 				 */
0: 				prRCList.genVirtualColumnNodes(this, resultColumns);
0: 
0: 				/* Finally, we create the new MaterializeResultSetNode */
0: 				mrsn = (MaterializeResultSetNode) getNodeFactory().getNode(
0: 									C_NodeTypes.MATERIALIZE_RESULT_SET_NODE,
0: 									this,
0: 									prRCList,
0: 									tableProperties,
0: 									getContextManager());
0: 				// Propagate the referenced table map if it's already been created
0: 				if (referencedTableMap != null)
0: 				{
0: 					mrsn.setReferencedTableMap((JBitSet) referencedTableMap.clone());
0: 				}
0: 				return mrsn;
0: 			}
0: 			else
0: 			{
0: 				/* We get a shallow copy of the ResultColumnList and its 
0: 				 * ResultColumns.  (Copy maintains ResultColumn.expression for now.)
0: 				 */
0: 				prRCList = childResult.getResultColumns();
0: 				childResult.setResultColumns(prRCList.copyListAndObjects());
0: 
0: 				/* Replace ResultColumn.expression with new VirtualColumnNodes
0: 				 * in the MaterializeResultSetNode's ResultColumnList.  (VirtualColumnNodes include
0: 				 * pointers to source ResultSetNode, this, and source ResultColumn.)
0: 				 */
0: 				prRCList.genVirtualColumnNodes(childResult, childResult.getResultColumns());
0: 
0: 				/* RESOLVE - we need to push single table predicates down so that
0: 				 * they get applied while building the MaterializeResultSet.
0: 				 */
0: 
0: 				/* Finally, we create the new MaterializeResultSetNode */
0: 				mrsn = (MaterializeResultSetNode) getNodeFactory().getNode(
0: 									C_NodeTypes.MATERIALIZE_RESULT_SET_NODE,
0: 									childResult,
0: 									prRCList,
0: 									tableProperties,
0: 									getContextManager());
0: 				// Propagate the referenced table map if it's already been created
0: 				if (childResult.getReferencedTableMap() != null)
0: 				{
0: 					mrsn.setReferencedTableMap((JBitSet) childResult.getReferencedTableMap().clone());
0: 				}
0: 				childResult = mrsn;
0: 			}
0: 		}
0: 
0: 		return this;
0: 	}
0: 
0: 	/** 
0: 	 * Determine whether or not the specified name is an exposed name in
0: 	 * the current query block.
0: 	 *
0: 	 * @param name	The specified name to search for as an exposed name.
0: 	 * @param schemaName	Schema name, if non-null.
0: 	 * @param exactMatch	Whether or not we need an exact match on specified schema and table
0: 	 *						names or match on table id.
0: 	 *
0: 	 * @return The FromTable, if any, with the exposed name.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	protected FromTable getFromTableByName(String name, String schemaName, boolean exactMatch)
0: 		throws StandardException
0: 	{
0: 		return childResult.getFromTableByName(name, schemaName, exactMatch);
0: 	}
0: 
0: 	/**
0: 	 * Get the lock mode for the target of an update statement
0: 	 * (a delete or update).  The update mode will always be row for
0: 	 * CurrentOfNodes.  It will be table if there is no where clause.
0: 	 *
0: 	 * @return	The lock mode
0: 	 */
0: 	public int updateTargetLockMode()
0: 	{
0: 		if (restriction != null || constantRestriction != null)
0: 		{
0: 			return TransactionController.MODE_RECORD;
0: 		}
0: 		else
0: 		{
0: 			return childResult.updateTargetLockMode();
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Is it possible to do a distinct scan on this ResultSet tree.
0: 	 * (See SelectNode for the criteria.)
0: 	 *
0: 	 * @return Whether or not it is possible to do a distinct scan on this ResultSet tree.
0: 	 */
0: 	boolean isPossibleDistinctScan()
0: 	{
0: 		if (restriction != null || 
0: 			(restrictionList != null && restrictionList.size() != 0))
0: 		{
0: 			return false;
0: 		}
0: 		return childResult.isPossibleDistinctScan();
0: 	}
0: 
0: 	/**
0: 	 * Mark the underlying scan as a distinct scan.
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	void markForDistinctScan()
0: 	{
0: 		childResult.markForDistinctScan();
0: 	}
0: 
0: 
0: 	/**
0: 	 * Accept a visitor, and call v.visit()
0: 	 * on child nodes as necessary.  
0: 	 * 
0: 	 * @param v the visitor
0: 	 *
0: 	 * @exception StandardException on error
0: 	 */
0: 	public Visitable accept(Visitor v) 
0: 		throws StandardException
0: 	{
0: 		if (v.skipChildren(this))
0: 		{
0: 			return v.visit(this);
0: 		}
0: 
0: 		Visitable returnNode = super.accept(v);
0: 
0: 		if (restriction != null && !v.stopTraversal())
0: 		{
0: 			restriction = (ValueNode)restriction.accept(v);
0: 		}
0: 
0: 		if (restrictionList != null && !v.stopTraversal())
0: 		{
0: 			restrictionList = (PredicateList)restrictionList.accept(v);
0: 		}
0: 
0: 		return returnNode;
0: 	}
0: 
0: 
0: 
0: 	/**
0: 	 * set the Information gathered from the parent table that is 
0: 	 * required to peform a referential action on dependent table.
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	public void setRefActionInfo(long fkIndexConglomId, 
0: 								 int[]fkColArray, 
0: 								 String parentResultSetId,
0: 								 boolean dependentScan)
0: 	{
0: 		childResult.setRefActionInfo(fkIndexConglomId,
0: 								   fkColArray,
0: 								   parentResultSetId,
0: 								   dependentScan);
0: 	}
0: 
0: }
============================================================================