1:eac0369: /*
1:d7258ed: 
1:d7258ed:    Derby - Class org.apache.derby.impl.drda.DDMReader
1:4abfe24: 
1:59e5225:    Licensed to the Apache Software Foundation (ASF) under one or more
1:59e5225:    contributor license agreements.  See the NOTICE file distributed with
1:59e5225:    this work for additional information regarding copyright ownership.
1:59e5225:    The ASF licenses this file to You under the Apache License, Version 2.0
1:59e5225:    (the "License"); you may not use this file except in compliance with
1:59e5225:    the License.  You may obtain a copy of the License at
1:4abfe24: 
1:d7258ed:       http://www.apache.org/licenses/LICENSE-2.0
1:d7258ed: 
1:d7258ed:    Unless required by applicable law or agreed to in writing, software
1:d7258ed:    distributed under the License is distributed on an "AS IS" BASIS,
1:d7258ed:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:d7258ed:    See the License for the specific language governing permissions and
1:d7258ed:    limitations under the License.
1:d7258ed: 
1:4abfe24:  */
1:d7258ed: 
1:eac0369: package org.apache.derby.impl.drda;
1:db4c995: 
1:db4c995: import java.io.ByteArrayInputStream;
1:db4c995: import java.io.ByteArrayOutputStream;
1:eac0369: import java.io.IOException;
1:eac0369: import java.io.InputStream;
1:eac0369: import java.math.BigDecimal;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
57:eac0369: 
1:fefd864: /**
1:4f996a4:     The DDMReader is used to read DRDA protocol.   DRDA Protocol is divided into
1:4f996a4:     three layers corresponding to the DDM three-tier architecture. For each layer,
1:4f996a4:     their is a DSS (Data Stream Structure) defined.
1:4f996a4:         Layer A     Communications management services
1:db9a013:         Layer B     Agent services
1:4f996a4:         Layer C     Data management services
1:4f996a4:     <P>
1:4f996a4:     At layer A are request, reply and data correlation, structure chaining,
1:4f996a4:     continuation or termination of chains when errors are detected, interleaving
1:4f996a4:     and multi-leaving request, reply, and data DSSs for multitasking environments.
1:4f996a4:     For TCP/IP, the format of the DDM envelope is
1:db9a013:         2 bytes     Length of the data
1:db9a013:         1 byte      'D0' - indicates DDM data
1:db9a013:         1 byte      DDM format byte(DSSFMT) - type of DSS(RQSDSS,RPYDSS), whether it is
1:4f996a4:                     chained, information about the next chained DSS
1:db9a013:         2 bytes     request correlation identifier
1:4f996a4:     <P>
1:4f996a4:     The correlation identifier ties together a request, the request data and the
1:4f996a4:     reply.  In a chained DSS, each request has a correlation identifier which
1:4f996a4:     is higher than the previous request (all correlation identifiers must
1:4f996a4:     be greater than 0).
1:4f996a4:     <P>
1:4f996a4:     At layer B are object mapping, object validation and command routing.
1:4f996a4:     Layer B objects with data 5 bytes less than 32K bytes consist of
1:db9a013:         2 bytes     Length
1:db9a013:         2 bytes     Type of the object (code point)
1:4f996a4:         Object data
1:4f996a4:     Object data is either SCALAR or COLLECTION data.  Scalar data consists of
1:4f996a4:     a string of bytes formatted as the class description of the object required.
1:4f996a4:     Collections consist of a set of objects in which the entries in the collection
1:4f996a4:     are nested within the length/ code point of the collection.
1:4f996a4:     <P>
1:dbed020:     Layer B objects with data &gt;=32763 bytes long format is 
1:db9a013:         2 bytes     Length - length of class, length, and extended total length fields
1:dbed020:                     (high order bit set, indicating &gt;=32763)
1:db9a013:         2 bytes     Type of the object (code point)
1:db9a013:         n bytes     Extended total length - length of the object
1:4f996a4:                     (n = Length - 4)
1:4f996a4:         Object data
1:4f996a4:     <P>
1:4f996a4:     At layer C are services each class of DDM object provides.
1:eac0369: 
1:4f996a4:             |-------------------------------------------|
1:db9a013:     Layer C | Specific  |   Specific    |   Specific    |
1:db9a013:             | Commands  |   Replies     | Scalars and   |
1:4f996a4:             | and their |  and their    | Collections   |
1:4f996a4:             |-------------------------------------------|----------------|
1:db9a013:     Layer B | Commands  |    Reply      | Scalars and   | Communications |
1:db9a013:             |           |   Messages    | Collections   |                |
1:4f996a4:             |-----------|---------------|---------------|----------------|
1:db9a013:     Layer A |  RQSDSS   |   RPYDSS      | OBJDSS        | CMNDSS         |
1:4f996a4:             |           |               |               | Mapped Data    |
1:4f996a4:             |-----------|---------------|---------------|----------------|
1:4f996a4:             |                DDM Data Stream Structures                  |
1:4f996a4:             |------------------------------------------------------------|
1:4f996a4:             
1:4f996a4:     DSS's may be chained so that more than one can be transmitted at a time
1:4f996a4:     to improve performance.
1:4f996a4:     For more details, see DRDA Volume 3 (Distributed Data Management(DDM)
1:4f996a4:         Architecture (DDS definition)
1:fefd864: */
1:eac0369: class DDMReader
1:4f996a4: {
1:4f996a4:     private final static int DEFAULT_BUFFER_SIZE = 32767;
1:4f996a4:     private final static int MAX_MARKS_NESTING = 10;
1:4f996a4:     private final static int NO_CODEPOINT = -1;
1:4f996a4:     private final static int EMPTY_STACK = -1;
1:4f996a4:     private final static boolean ADJUST_LENGTHS = true;
1:4f996a4:     private final static boolean NO_ADJUST_LENGTHS = false;
1:4f996a4:     private final static long MAX_EXTDTA_SIZE= Long.MAX_VALUE;
1:2e4a44e:     
1:fefd864: 
1:4f996a4:     // magnitude represented in an int array, used in BigDecimal conversion
1:eac0369:     private static final int[][] tenRadixMagnitude = {
1:eac0369:       { 0x3b9aca00 }, // 10^9
1:eac0369:       { 0x0de0b6b3, 0xa7640000 }, // 10^18
1:eac0369:       { 0x033b2e3c, 0x9fd0803c, 0xe8000000 }, // 10^27
1:eac0369:     };
1:eac0369: 
1:4f996a4:     private DRDAConnThread agent;
1:4f996a4:     private Utf8CcsidManager utf8CcsidManager;
1:4f996a4:     private EbcdicCcsidManager ebcdicCcsidManager;
1:4f996a4:     private CcsidManager ccsidManager;
1:eac0369: 
1:4f996a4:     // data buffer
1:4f996a4:     private byte[] buffer;
1:4f996a4:     private int pos;
1:4f996a4:     private int count;
1:eac0369: 
1:4f996a4:     // DDM object collection
1:4f996a4:     // top of stack
1:4f996a4:     private int topDdmCollectionStack;
1:4f996a4:     // length of each object in the stack
1:4f996a4:     private long[] ddmCollectionLenStack;
1:eac0369: 
1:4f996a4:     // DDM object length
1:4f996a4:     private long ddmScalarLen;
1:eac0369: 
1:4f996a4:     // DSS Length
1:4f996a4:     private int dssLength;
1:eac0369: 
1:4f996a4:     // DSS is larger than 32672 (continuation bit is set) so DSS is continued
1:4f996a4:     private boolean dssIsContinued;
1:eac0369: 
1:4f996a4:     private boolean terminateChainOnErr;
1:eac0369: 
1:4f996a4:     // next DSS in the chain has the same correlator
1:4f996a4:     private boolean dssIsChainedWithSameID;
1:eac0369: 
1:4f996a4:     // next DSS in the chain has a different correlator
1:4f996a4:     private boolean dssIsChainedWithDiffID;
1:4f996a4:     
1:4f996a4:     // correlation id for the current DSS
1:4f996a4:     private int dssCorrelationID;
1:eac0369: 
1:4f996a4:     // previous corelation id
1:4f996a4:     private int prevCorrelationID;
1:eac0369: 
1:4f996a4:     // current server codepoint
1:4f996a4:     private int svrcod;
1:eac0369: 
1:4f996a4:     // trace object of the associated session
1:4f996a4:     private DssTrace dssTrace;
1:eac0369: 
1:4f996a4:     // input stream
1:4f996a4:     private InputStream inputStream;
1:fefd864:     
1:fefd864:     // State whether doing layer B Streaming or not.
1:fefd864:     private boolean doingLayerBStreaming = false;;
1:1ab256e:     
1:1ab256e:     // For JMX statistics. Volatile to ensure we 
1:1ab256e:     // get one complete long, but we don't bother to synchronize, 
1:1ab256e:     // since this is just statistics.
1:1ab256e:     
1:1ab256e:     volatile long totalByteCount = 0;
1:eac0369: 
1:4f996a4:     // constructor
1:4f996a4:     DDMReader (DRDAConnThread agent, DssTrace dssTrace)
1:4f996a4:     {
1:4f996a4:         buffer = new byte[DEFAULT_BUFFER_SIZE];
1:4f996a4:         ddmCollectionLenStack = new long[MAX_MARKS_NESTING];
1:4f996a4:         initialize(agent, dssTrace);
1:4f996a4:     }
1:4f996a4:     /**
1:4f996a4:      * This constructor is used for testing the protocol
1:c3c7b7b:     * It is used by ProtocolTestAdapter to read the protocol returned by the
1:4f996a4:      * server 
1:4f996a4:      */
1:4f996a4:     DDMReader(InputStream inputStream)
1:4f996a4:     {
1:4f996a4:         buffer = new byte[DEFAULT_BUFFER_SIZE];
1:4f996a4:         ddmCollectionLenStack = new long[MAX_MARKS_NESTING];
1:4f996a4:         
1:4f996a4:         this.inputStream = inputStream;
1:4f996a4:         initialize(null, null);
1:4f996a4:     }
1:cdfb2d1: 
1:4f996a4:     /**
1:4f996a4:      * Initialize values for this session, the reader is reused so we need to
1:4f996a4:      * set null and 0 values
1:4f996a4:      */
1:4f996a4:     protected void initialize(DRDAConnThread agent, DssTrace dssTrace)
1:db9a013:     {
1:4f996a4:         this.agent = agent;
1:4f996a4:         this.utf8CcsidManager = new Utf8CcsidManager();
1:cdfb2d1:         this.ebcdicCcsidManager = new EbcdicCcsidManager();
1:cdfb2d1:         this.ccsidManager = ebcdicCcsidManager;
1:4f996a4:         if (agent != null)
1:4f996a4:         {
1:4f996a4:             inputStream = agent.getInputStream();
1:4f996a4:         }
1:4f996a4:         topDdmCollectionStack = EMPTY_STACK;
1:4f996a4:         svrcod = 0;
1:4f996a4:         pos = 0;
1:4f996a4:         count = 0;
1:4f996a4:         ddmScalarLen = 0;
1:4f996a4:         dssLength = 0;
1:4f996a4:         prevCorrelationID = DssConstants.CORRELATION_ID_UNKNOWN;
1:4f996a4:         dssCorrelationID = DssConstants.CORRELATION_ID_UNKNOWN;
1:4f996a4:         this.dssTrace = dssTrace;
1:826d7f1:         dssIsChainedWithDiffID = false;
1:826d7f1:         dssIsChainedWithSameID = false;
1:4f996a4:     }
1:fefd864: 
1:4f996a4:     // Switch the ccsidManager to the UTF-8 instance
1:cdfb2d1:     protected void setUtf8Ccsid() {
1:cdfb2d1:         ccsidManager = utf8CcsidManager;
1:4f996a4:     }
1:cdfb2d1:     
1:cdfb2d1:     // Switch the ccsidManager to the EBCDIC instance
1:cdfb2d1:     protected void setEbcdicCcsid() {
1:cdfb2d1:         ccsidManager = ebcdicCcsidManager;
1:4f996a4:     }
1:cdfb2d1:     
1:4f996a4:     protected boolean terminateChainOnErr()
1:4f996a4:     {
1:4f996a4:         return terminateChainOnErr;
1:4f996a4:     }
1:cdfb2d1: 
1:4f996a4:     /**
1:4f996a4:      * Next DSS has same correlator as current DSS
1:4f996a4:      *
1:4f996a4:      * @return true if next DSS has the same correlator as current DSS
1:4f996a4:      */
1:db9a013:     protected boolean isChainedWithSameID()
1:db9a013:     {
1:4f996a4:         return dssIsChainedWithSameID;
1:db9a013:     }
1:fefd864: 
1:4f996a4:     /**
1:4f996a4:      * Next DSS has different correlator than current DSS
1:4f996a4:      *
1:4f996a4:      * @return true if next DSS has a different correlator than current DSS
1:4f996a4:      */
1:db9a013:     protected boolean isChainedWithDiffID()
1:db9a013:     {
1:4f996a4:         return dssIsChainedWithDiffID;
1:db9a013:     }
1:fefd864: 
1:4f996a4:     /**
1:4f996a4:      * Length of current DDM object
1:4f996a4:      *
1:4f996a4:      * @return length of DDM object
1:4f996a4:      */
1:4f996a4:     protected long getDdmLength()
1:4f996a4:     {
1:4f996a4:         return ddmScalarLen;
1:4f996a4:     }
1:fefd864: 
1:4f996a4:     /**
1:4f996a4:      * Is there more in this DDM object
1:4f996a4:      *
1:dbed020:      * @return true if DDM length is &gt; 0
1:4f996a4:      */
1:4f996a4:     protected boolean moreDdmData()
1:4f996a4:     {
1:4f996a4:         return ddmScalarLen > 0;
1:4f996a4:     }
1:fefd864: 
1:4f996a4:     /**
1:4f996a4:      * Is there more in this DDS object
1:4f996a4:      *
1:dbed020:      * @return true if DDS length is &gt; 0
1:4f996a4:      */
1:4f996a4:     protected boolean moreDssData()
1:4f996a4:     {
1:4f996a4:         return dssLength > 0;
1:4f996a4:     }
1:4abfe24: 
1:4f996a4:     /** 
1:4f996a4:      * Is there more data in the buffer
1:4f996a4:      *
1:4f996a4:      * @return true if there is more data in the buffer
1:4f996a4:      */
1:4f996a4:     protected boolean moreData()
1:4f996a4:     {
1:4f996a4:         return (pos - count) > 0;
1:4f996a4:     }
1:4abfe24: 
1:4f996a4:     /**
1:4f996a4:      * Check for the command protocol
1:4f996a4:      *
1:4f996a4:      * @return true if this is a command; false otherwise
1:4f996a4:      *
1:a7adeeb:      * @exception DRDAProtocolException if a protocol error is detected
1:4f996a4:      */
1:4f996a4:     protected boolean isCmd() throws DRDAProtocolException, java.io.UnsupportedEncodingException
1:4f996a4:     {
1:4f996a4:         ensureALayerDataInBuffer(4);
1:4f996a4:         String val = new String(buffer, 0, 4, NetworkServerControlImpl.DEFAULT_ENCODING);
1:4f996a4:         return NetworkServerControlImpl.isCmd(val);
1:4f996a4:     }
1:4abfe24: 
1:4f996a4:     /**
1:4f996a4:      * Read DSS header
1:4f996a4:      * DSS Header format is 
1:db9a013:      *  2 bytes - length
1:db9a013:      *  1 byte  - 'D0'  - indicates DDM data
1:db9a013:      *  1 byte  - DSS format
1:db9a013:      *      |---|---------|----------|
1:db9a013:      *      | 0 |  flags  |  type    |
1:db9a013:      *      |---|---------|----------|
1:db9a013:      *      | 0 | 1  2  3 | 4 5 6 7  |
1:db9a013:      *      |---|---------|----------|
1:db9a013:      *      bit 0 - '0'
1:db9a013:      *      bit 1 - '0' - unchained, '1' - chained
1:db9a013:      *      bit 2 - '0' - do not continue on error, '1' - continue on error
1:db9a013:      *      bit 3 - '0' - next DSS has different correlator, '1' - next DSS has
1:db9a013:      *                      same correlator
1:db9a013:      *      type - 1 - Request DSS
1:db9a013:      *           - 2 - Reply DSS
1:db9a013:      *           - 3 - Object DSS
1:db9a013:      *           - 4 - Communications DSS
1:db9a013:      *           - 5 - Request DSS where no reply is expected
1:db9a013:      *  2 bytes - request correlation id
1:4f996a4:      *
1:a7adeeb:      * @exception DRDAProtocolException if a protocol error is detected
1:4f996a4:      */
1:4f996a4:     protected int readDssHeader () throws DRDAProtocolException
1:4f996a4:     {
1:4f996a4:         ensureALayerDataInBuffer (6);
1:4abfe24: 
1:4f996a4:         // read out the DSS length
1:4f996a4:         dssLength = ((buffer[pos] & 0xff) << 8) +
1:4f996a4:                     ((buffer[pos + 1] & 0xff) << 0);
1:4f996a4:         pos += 2;
1:4f996a4:         // check for the continuation bit and update length as needed.
1:4f996a4:         if ((dssLength & DssConstants.CONTINUATION_BIT) == 
1:4f996a4:                 DssConstants.CONTINUATION_BIT) 
1:4f996a4:         {
1:4f996a4:             dssLength = DssConstants.MAX_DSS_LENGTH;
1:4f996a4:             dssIsContinued = true;
1:4f996a4:         }
1:4f996a4:         else 
1:4f996a4:         {
1:4f996a4:             dssIsContinued = false;
1:4f996a4:         }
1:4abfe24: 
1:4f996a4:         if (dssLength < 6)
1:4f996a4:             agent.throwSyntaxrm(CodePoint.SYNERRCD_DSS_LESS_THAN_6,
1:4f996a4:                                DRDAProtocolException.NO_CODPNT_ARG);
1:4abfe24: 
1:4f996a4:         // If the GDS id is not valid, or
1:4f996a4:         // if the reply is not an RQSDSS nor
1:4f996a4:         // a OBJDSS, then throw an exception.
1:4abfe24: 
1:4f996a4:         if ((buffer[pos++] & 0xff) != DssConstants.DSS_ID)
1:4f996a4:             agent.throwSyntaxrm(CodePoint.SYNERRCD_CBYTE_NOT_D0,
1:4f996a4:                                DRDAProtocolException.NO_CODPNT_ARG);
1:4abfe24: 
1:4f996a4:         int gdsFormatter = buffer[pos++] & 0xff;
1:4f996a4:         
1:4f996a4:         if (((gdsFormatter & 0x0F) != DssConstants.DSSFMT_RQSDSS)
1:4f996a4:             &&((gdsFormatter & 0x0F) != DssConstants.DSSFMT_OBJDSS)) 
1:4f996a4:         {
1:4f996a4:             agent.throwSyntaxrm(CodePoint.SYNERRCD_FBYTE_NOT_SUPPORTED,
1:4f996a4:                                DRDAProtocolException.NO_CODPNT_ARG);
1:4f996a4:         }
1:a376274: 
1:4f996a4:         // Determine if the current DSS is chained with the
1:4f996a4:         // next DSS, with the same or different request ID.
1:4f996a4:         if ((gdsFormatter & DssConstants.DSSCHAIN) == DssConstants.DSSCHAIN) 
1:db9a013:         {   // on indicates structure chained to next structure
1:4f996a4:             if ((gdsFormatter & DssConstants.DSSCHAIN_SAME_ID) 
2:4f996a4:                     == DssConstants.DSSCHAIN_SAME_ID) 
1:4f996a4:             {
1:4f996a4:                 dssIsChainedWithSameID = true;
1:4f996a4:                 dssIsChainedWithDiffID = false;
1:4f996a4:             }
1:4f996a4:             else 
1:4f996a4:             {
1:4f996a4:                 dssIsChainedWithSameID = false;
1:4f996a4:                 dssIsChainedWithDiffID = true;
1:4f996a4:             }
1:4f996a4:             if ((gdsFormatter & DssConstants.DSSCHAIN_ERROR_CONTINUE) 
1:4f996a4:                 == DssConstants.DSSCHAIN_ERROR_CONTINUE)
1:4f996a4:                 terminateChainOnErr = false;
1:4f996a4:             else
1:4f996a4:                 terminateChainOnErr = true;
1:4f996a4:         }
1:4f996a4:         else 
1:4f996a4:         {
1:4f996a4:             // chaining bit not b'1', make sure DSSFMT same id not b'1'
1:4f996a4:             if ((gdsFormatter & DssConstants.DSSCHAIN_SAME_ID) 
1:db9a013:                     == DssConstants.DSSCHAIN_SAME_ID)
1:4f996a4:             {  // Next DSS can not have same correlator
1:4f996a4:                 agent.throwSyntaxrm(CodePoint.SYNERRCD_CHAIN_OFF_SAME_NEXT_CORRELATOR,
1:4f996a4:                                    DRDAProtocolException.NO_CODPNT_ARG);
1:4f996a4:             }
1:4f996a4:             // chaining bit not b'1', make sure no error continuation
1:4f996a4:             if ((gdsFormatter & DssConstants.DSSCHAIN_ERROR_CONTINUE) 
1:4f996a4:                 == DssConstants.DSSCHAIN_ERROR_CONTINUE) 
1:4f996a4:             { // must be 'do not continue on error'
1:4f996a4:                 agent.throwSyntaxrm(CodePoint.SYNERRCD_CHAIN_OFF_ERROR_CONTINUE,
1:4f996a4:                                    DRDAProtocolException.NO_CODPNT_ARG);
1:4f996a4:             }
1:eac0369: 
1:4f996a4:             dssIsChainedWithSameID = false;
1:4f996a4:             dssIsChainedWithDiffID = false;
1:4f996a4:         }
1:eac0369: 
1:4f996a4:         dssCorrelationID =
1:4f996a4:             ((buffer[pos] & 0xff) << 8) +
1:4f996a4:             ((buffer[pos + 1] & 0xff) << 0);
1:4f996a4:         pos += 2;
1:4f996a4:         if (SanityManager.DEBUG)
1:4f996a4:             trace("dssLength = " + dssLength + " correlationID = " + dssCorrelationID);
1:eac0369: 
1:4f996a4:         //check that correlationID is the same as previous
1:4f996a4:         if (prevCorrelationID != DssConstants.CORRELATION_ID_UNKNOWN && 
1:4f996a4:             dssCorrelationID != prevCorrelationID)
1:4f996a4:         {
1:4f996a4:             agent.throwSyntaxrm(CodePoint.SYNERRCD_CHAIN_OFF_ERROR_CONTINUE,
1:4f996a4:                                DRDAProtocolException.NO_CODPNT_ARG);
1:4f996a4:         }
1:4f996a4:         
1:4f996a4:         // set up previous correlation id to check that next DSS is correctly
1:4f996a4:         // formatted
1:4f996a4:         if (dssIsChainedWithSameID)
1:4f996a4:             prevCorrelationID = dssCorrelationID;
1:4f996a4:         else
1:4f996a4:             prevCorrelationID = DssConstants.CORRELATION_ID_UNKNOWN;
1:eac0369: 
1:4f996a4:         dssLength -= 6;
1:eac0369: 
1:4f996a4:         return dssCorrelationID;
1:4f996a4:     }
1:4f996a4:     /**
1:4f996a4:      * Read Reply DSS
1:4f996a4:      * This is used in testing the protocol.  We shouldn't see a reply
1:4f996a4:      * DSS when we are servicing DRDA commands
1:4f996a4:      *
1:a7adeeb:      * @exception DRDAProtocolException if a protocol error is detected
1:4f996a4:      */
1:4f996a4:     protected void readReplyDss() throws DRDAProtocolException
1:4f996a4:     {
1:4f996a4:         ensureALayerDataInBuffer (6);
1:eac0369: 
1:4f996a4:         // read out the DSS length
1:4f996a4:         dssLength = ((buffer[pos++] & 0xff) << 8) +
1:4f996a4:                     ((buffer[pos++] & 0xff) << 0);
1:eac0369: 
1:4f996a4:         // check for the continuation bit and update length as needed.
1:4f996a4:         if ((dssLength & DssConstants.CONTINUATION_BIT) == 
1:4f996a4:                 DssConstants.CONTINUATION_BIT) 
1:4f996a4:         {
1:4f996a4:             dssLength = DssConstants.MAX_DSS_LENGTH;
1:4f996a4:             dssIsContinued = true;
1:4f996a4:         }
1:4f996a4:         else 
1:4f996a4:         {
1:4f996a4:             dssIsContinued = false;
1:4f996a4:         }
1:eac0369: 
1:4f996a4:         if (dssLength < 6)
1:4f996a4:             agent.throwSyntaxrm(CodePoint.SYNERRCD_DSS_LESS_THAN_6,
1:4f996a4:                                DRDAProtocolException.NO_CODPNT_ARG);
1:eac0369: 
1:4f996a4:         // If the GDS id is not valid, throw exception
1:4f996a4: 
1:4f996a4:         if ((buffer[pos++] & 0xff) != DssConstants.DSS_ID)
1:4f996a4:             agent.throwSyntaxrm(CodePoint.SYNERRCD_CBYTE_NOT_D0,
1:4f996a4:                                DRDAProtocolException.NO_CODPNT_ARG);
1:eac0369: 
1:4f996a4:         int gdsFormatter = buffer[pos++] & 0xff;
1:eac0369:         
1:4f996a4:         // Determine if the current DSS is chained with the
1:4f996a4:         // next DSS, with the same or different request ID.
1:4f996a4:         if ((gdsFormatter & DssConstants.DSSCHAIN) == DssConstants.DSSCHAIN) 
1:db9a013:         {   // on indicates structure chained to next structure
1:4f996a4:             if ((gdsFormatter & DssConstants.DSSCHAIN_SAME_ID) 
1:4f996a4:                     == DssConstants.DSSCHAIN_SAME_ID) 
1:4f996a4:             {
1:4f996a4:                 dssIsChainedWithSameID = true;
1:4f996a4:                 dssIsChainedWithDiffID = false;
1:4f996a4:             }
1:4f996a4:             else 
1:4f996a4:             {
1:4f996a4:                 dssIsChainedWithSameID = false;
1:4f996a4:                 dssIsChainedWithDiffID = true;
1:4f996a4:             }
1:4f996a4:         }
1:4f996a4:         else 
1:4f996a4:         {
1:4f996a4:             dssIsChainedWithSameID = false;
1:4f996a4:             dssIsChainedWithDiffID = false;
1:4f996a4:         }
1:eac0369: 
1:4f996a4:         dssCorrelationID =
1:4f996a4:             ((buffer[pos++] & 0xff) << 8) +
1:4f996a4:             ((buffer[pos++] & 0xff) << 0);
1:eac0369: 
1:4f996a4:         if (SanityManager.DEBUG)                    
1:4f996a4:             trace("dssLength = " + dssLength + " correlationID = " + dssCorrelationID);
1:eac0369: 
1:4f996a4:         dssLength -= 6;
1:eac0369: 
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * Read the DDM Length and CodePoint
1:4f996a4:      *
1:fefd864:      * @param isLayerBStreamingPossible true only when layer B streaming is possible
1:4f996a4:      * @return - returns codepoint
1:4f996a4:      *
1:a7adeeb:      * @exception DRDAProtocolException if a protocol error is detected
1:4f996a4:      */
1:4f996a4:     protected int readLengthAndCodePoint( boolean isLayerBStreamingPossible ) 
1:ee2a860:         throws DRDAProtocolException
1:4f996a4:     {
1:4f996a4:         ensureBLayerDataInBuffer (4, NO_ADJUST_LENGTHS);
1:f582a77: 
1:4f996a4:         ddmScalarLen = readCodePoint();
1:4f996a4:         int codePoint = readCodePoint();
1:7062abe:         
1:4f996a4:         if (SanityManager.DEBUG)
1:4f996a4:             trace("length = "+ ddmScalarLen + " codepoint = " + java.lang.Integer.toHexString(codePoint));
1:4f996a4:         // SYNERRCD 0x0D - Object code point index not supported.
1:4f996a4:         // the object codepoint index will not be checked here since
1:4f996a4:         // the parse methods will catch any incorrect/unexpected codepoint values
1:4f996a4:         // and report them as unsupported objects or parameters.
1:4f996a4: 
1:4f996a4:         // Check if this DDM has extended length field
1:4f996a4:         if ((ddmScalarLen & DssConstants.CONTINUATION_BIT) == DssConstants.CONTINUATION_BIT) 
1:4f996a4:         {
1:4f996a4:             int numberOfExtendedLenBytes = ((int)ddmScalarLen - 
1:4f996a4:                     DssConstants.CONTINUATION_BIT) - 4;
1:4f996a4:             int adjustSize = 0;
1:4f996a4:             ensureBLayerDataInBuffer (numberOfExtendedLenBytes, NO_ADJUST_LENGTHS);
1:4f996a4:             switch (numberOfExtendedLenBytes) {
1:4f996a4:             case 8:
1:4f996a4:                  ddmScalarLen =
1:24d0b90:                     ((buffer[pos++] & 0xFFL) << 56) +
1:24d0b90:                     ((buffer[pos++] & 0xFFL) << 48) +
1:24d0b90:                     ((buffer[pos++] & 0xFFL) << 40) +
1:24d0b90:                     ((buffer[pos++] & 0xFFL) << 32) +
1:24d0b90:                     ((buffer[pos++] & 0xFFL) << 24) +
1:24d0b90:                     ((buffer[pos++] & 0xFFL) << 16) +
1:24d0b90:                     ((buffer[pos++] & 0xFFL) << 8) +
1:24d0b90:                     ((buffer[pos++] & 0xFFL) << 0);
1:4f996a4:                 adjustSize = 12;
1:4f996a4:                 break;
1:4f996a4:             case 6:
1:4f996a4:                 ddmScalarLen =
1:24d0b90:                     ((buffer[pos++] & 0xFFL) << 40) +
1:24d0b90:                     ((buffer[pos++] & 0xFFL) << 32) +
1:24d0b90:                     ((buffer[pos++] & 0xFFL) << 24) +
1:24d0b90:                     ((buffer[pos++] & 0xFFL) << 16) +
1:24d0b90:                     ((buffer[pos++] & 0xFFL) << 8) +
1:24d0b90:                     ((buffer[pos++] & 0xFFL) << 0);
1:4f996a4:                 adjustSize = 10;
1:4f996a4:                 break;
1:4f996a4:             case 4:
1:4f996a4:                 ddmScalarLen =
1:24d0b90:                     ((buffer[pos++] & 0xFFL) << 24) +
1:24d0b90:                     ((buffer[pos++] & 0xFFL) << 16) +
1:24d0b90:                     ((buffer[pos++] & 0xFFL) << 8) +
1:24d0b90:                     ((buffer[pos++] & 0xFFL) << 0);
1:4f996a4:                 adjustSize = 8;
1:4f996a4:                 break;
1:fefd864:                 
1:fefd864:             case 0:
1:fefd864:                 
1:fefd864:                 if( isLayerBStreamingPossible &&
1:fefd864:                     ( codePoint == CodePoint.EXTDTA || 
1:fefd864:                       codePoint == CodePoint.QRYDTA ) ){
1:fefd864:                     
1:fefd864:                     startLayerBStreaming();
1:fefd864:                     adjustSize = 4;
1:fefd864:                     
1:fefd864:                 }else {
1:fefd864:                     agent.throwSyntaxrm(CodePoint.SYNERRCD_INCORRECT_EXTENDED_LEN,
1:fefd864:                                         DRDAProtocolException.NO_CODPNT_ARG);
1:cdfb2d1:                 }
1:fefd864:                 
1:fefd864:                 break;
1:fefd864:                 
1:4f996a4:             default:
1:4f996a4:                 agent.throwSyntaxrm(CodePoint.SYNERRCD_INCORRECT_EXTENDED_LEN,
1:4f996a4:                                DRDAProtocolException.NO_CODPNT_ARG);
1:4f996a4:         }
1:a376274: 
1:db9a013:             // adjust the lengths here. this is a special case since the
1:4f996a4:             // extended length bytes do not include their own length.
1:4f996a4:             for (int i = 0; i <= topDdmCollectionStack; i++) {
1:4f996a4:                 ddmCollectionLenStack[i] -= adjustSize;
1:4f996a4:             }
1:4f996a4:             dssLength -= adjustSize;
1:4f996a4:         }
1:4f996a4:         else {
1:4f996a4:             if (ddmScalarLen < 4)
1:4f996a4:                 agent.throwSyntaxrm(CodePoint.SYNERRCD_OBJ_LEN_LESS_THAN_4,
1:4f996a4:                                    DRDAProtocolException.NO_CODPNT_ARG);
1:4f996a4:             adjustLengths (4);
1:4f996a4:         }
1:4f996a4:         return codePoint;
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * Read the CodePoint
1:4f996a4:      *
1:4f996a4:      * @return - returns codepoint
1:4f996a4:      */
1:4f996a4:     protected int readCodePoint()
1:4f996a4:     {
1:4f996a4:         return( ((buffer[pos++] & 0xff) << 8) +
1:4f996a4:           ((buffer[pos++] & 0xff) << 0));
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * Push DDM Length on to collection stack
1:4f996a4:      */
1:4f996a4:     protected void markCollection()
1:4f996a4:     {
1:4f996a4:         ddmCollectionLenStack[++topDdmCollectionStack] = ddmScalarLen;
1:4f996a4:         ddmScalarLen = 0;
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:db9a013:      *  Get the next CodePoint from a collection
1:db9a013:      *  @return NO_CODEPOINT if collection stack is empty or remaining length is
1:db9a013:      *      0; otherwise,  read length and code point
1:4f996a4:      *
1:a7adeeb:      * @exception DRDAProtocolException if a protocol error is detected
1:4f996a4:      */
1:4f996a4:     protected int getCodePoint() throws DRDAProtocolException
1:4f996a4:     {
1:4f996a4:         if (topDdmCollectionStack == EMPTY_STACK) 
1:4f996a4:         {
1:4f996a4:             return NO_CODEPOINT;
1:4f996a4:         }
1:4f996a4:         else 
1:4f996a4:         {
1:4f996a4:             // if the collecion is exhausted then return NO_CODEPOINT
1:4f996a4:             if (ddmCollectionLenStack[topDdmCollectionStack] == 0) 
1:4f996a4:                 {
1:4f996a4:                 // done with this collection so remove it's length from the stack
1:4f996a4:                 ddmCollectionLenStack[topDdmCollectionStack--] = 0;
1:4f996a4:                 return NO_CODEPOINT;
1:4f996a4:             }
1:4f996a4:             else {
1:4f996a4:                 return readLengthAndCodePoint( false );
1:4f996a4:             }
1:4f996a4:         }
1:4f996a4:     }
1:4f996a4:     /**
1:4f996a4:      * Get the next CodePoint from a collection and check that it matches the specified
1:db9a013:      *  CodePoint
1:db9a013:      * @param   codePointCheck  - codePoint to check against
1:db9a013:      * @return  codePoint
1:4f996a4:      *
1:a7adeeb:      * @exception DRDAProtocolException if a protocol error is detected
1:4f996a4:      */
1:4f996a4:     protected int getCodePoint(int codePointCheck) throws DRDAProtocolException
1:4f996a4:     {
1:4f996a4:         int codePoint = getCodePoint();
1:4f996a4:         if (codePoint != codePointCheck)
1:4f996a4:             agent.missingCodePoint(codePoint);
1:4f996a4:         return codePoint;
1:4f996a4:     }
1:4f996a4:     /**
1:4f996a4:      * The following routines read different types from the input stream
1:4f996a4:      * Data can be in network order or platform order depending on whether the
1:4f996a4:      * data is part of the protocol or data being received
1:4f996a4:      * The platform is determined by EXCSAT protocol
1:4f996a4:      */
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * Read byte value
1:db9a013:      * @return  value
1:4f996a4:      *
1:a7adeeb:      * @exception DRDAProtocolException if a protocol error is detected
1:4f996a4:      */
1:4f996a4:     protected byte readByte () throws DRDAProtocolException
1:4f996a4:     {
1:4f996a4:         ensureBLayerDataInBuffer (1, ADJUST_LENGTHS);
1:4f996a4:         return buffer[pos++];
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * Read byte value and mask out high order bytes before returning
1:4f996a4:      * @return value
1:4f996a4:      */
1:4f996a4:     protected int readUnsignedByte () throws DRDAProtocolException
1:4f996a4:     {
1:4f996a4:         ensureBLayerDataInBuffer (1, ADJUST_LENGTHS);
1:4f996a4:         return (int ) (buffer[pos++] & 0xff);
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * Read network short value
1:db9a013:      * @return  value
1:4f996a4:      *
1:a7adeeb:      * @exception DRDAProtocolException if a protocol error is detected
1:4f996a4:      */
1:4f996a4:     protected int readNetworkShort () throws DRDAProtocolException
1:4f996a4:     {
1:4f996a4:         ensureBLayerDataInBuffer (2, ADJUST_LENGTHS);
1:4f996a4:         return ((buffer[pos++] & 0xff) << 8) +
1:4f996a4:           ((buffer[pos++] & 0xff) << 0);
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * Read signed network short value
1:db9a013:      * @return  value
1:4f996a4:      *
1:a7adeeb:      * @exception DRDAProtocolException if a protocol error is detected
1:4f996a4:      */
1:4f996a4:     protected int readSignedNetworkShort () throws DRDAProtocolException
1:4f996a4:     {
1:4f996a4:         ensureBLayerDataInBuffer (2, ADJUST_LENGTHS);
1:4f996a4:         return (short)(((buffer[pos++] & 0xff) << 8) +
1:4f996a4:           ((buffer[pos++] & 0xff) << 0));
1:4f996a4:     }
1:4f996a4:     /**
1:4f996a4:      * Read platform short value
1:db9a013:      * @return  value
1:4f996a4:      *
1:a7adeeb:      * @exception DRDAProtocolException if a protocol error is detected
1:4f996a4:      */
1:4f996a4:     protected short readShort (int byteOrder) throws DRDAProtocolException
1:4f996a4:     {
1:4f996a4:         ensureBLayerDataInBuffer (2, ADJUST_LENGTHS);
1:4f996a4:         short s = SignedBinary.getShort (buffer, pos, byteOrder);
1:eac0369: 
1:4f996a4:         pos += 2;
1:eac0369: 
1:4f996a4:         return s;
1:4f996a4:     }
1:d79abcf: 
1:4f996a4:     /**
1:4f996a4:      * Read network int value
1:db9a013:      * @return  value
1:4f996a4:      *
1:a7adeeb:      * @exception DRDAProtocolException if a protocol error is detected
1:4f996a4:      */
1:4f996a4:     protected int readNetworkInt () throws DRDAProtocolException
1:4f996a4:     {
1:4f996a4:         ensureBLayerDataInBuffer (4, ADJUST_LENGTHS);
1:4f996a4:         return ((buffer[pos++] & 0xff) << 24) +
1:4f996a4:                ((buffer[pos++] & 0xff) << 16) +
1:4f996a4:                ((buffer[pos++] & 0xff) << 8) +
1:4f996a4:                ((buffer[pos++] & 0xff) << 0);
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * Read platform int value
1:db9a013:      * @return  value
1:4f996a4:      *
1:a7adeeb:      * @exception DRDAProtocolException if a protocol error is detected
1:4f996a4:      */
1:4f996a4:     protected int readInt (int byteOrder) throws DRDAProtocolException
1:4f996a4:     {
1:4f996a4:         ensureBLayerDataInBuffer (4, ADJUST_LENGTHS);
1:4f996a4:         int i = SignedBinary.getInt (buffer, pos, byteOrder);
1:eac0369: 
1:4f996a4:         pos += 4;
1:eac0369: 
1:4f996a4:         return i;
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * Read network long value
1:db9a013:      * @return  value
1:4f996a4:      *
1:a7adeeb:      * @exception DRDAProtocolException if a protocol error is detected
1:4f996a4:      */
1:4f996a4:     protected long readNetworkLong () throws DRDAProtocolException
1:4f996a4:     {
1:4f996a4:         ensureBLayerDataInBuffer (8, ADJUST_LENGTHS);
1:eac0369: 
1:4f996a4:         return ((buffer[pos++] & 0xffL) << 56) +
1:4f996a4:                ((buffer[pos++] & 0xffL) << 48) +
1:4f996a4:                ((buffer[pos++] & 0xffL) << 40) +
1:4f996a4:                ((buffer[pos++] & 0xffL) << 32) +
1:4f996a4:                ((buffer[pos++] & 0xffL) << 24) +
1:4f996a4:                ((buffer[pos++] & 0xffL) << 16) +
1:4f996a4:                ((buffer[pos++] & 0xffL) << 8) +
1:4f996a4:                ((buffer[pos++] & 0xffL) << 0);
1:4f996a4:     }
1:4f996a4: 
1:eac0369:     
1:4f996a4:     /**
1:4f996a4:      * Read network six byte value and put it in a long v
1:db9a013:      * @return  value
1:4f996a4:      *
1:a7adeeb:      * @exception DRDAProtocolException if a protocol error is detected
1:4f996a4:      */
1:4f996a4:     protected long readNetworkSixByteLong() throws DRDAProtocolException
1:4f996a4:     {
1:4f996a4:         ensureBLayerDataInBuffer (6, ADJUST_LENGTHS);
1:eac0369: 
1:4f996a4:         return (
1:4f996a4:                 ((buffer[pos++] & 0xffL) << 40) +
1:4f996a4:                ((buffer[pos++] & 0xffL) << 32) +
1:4f996a4:                ((buffer[pos++] & 0xffL) << 24) +
1:4f996a4:                ((buffer[pos++] & 0xffL) << 16) +
1:4f996a4:                ((buffer[pos++] & 0xffL) << 8) +
1:4f996a4:                ((buffer[pos++] & 0xffL) << 0));
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * Read platform long value
1:db9a013:      * @return  value
1:4f996a4:      *
1:a7adeeb:      * @exception DRDAProtocolException if a protocol error is detected
1:4f996a4:      */
1:4f996a4:     protected long readLong (int byteOrder) throws DRDAProtocolException
1:4f996a4:     {
1:4f996a4:         ensureBLayerDataInBuffer (8, ADJUST_LENGTHS);
1:4f996a4:         long l = SignedBinary.getLong (buffer, pos, byteOrder);
1:eac0369: 
1:4f996a4:         pos += 8;
1:eac0369: 
1:4f996a4:         return l;
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * Read platform float value
1:db9a013:      * @return  value
1:4f996a4:      *
1:a7adeeb:      * @exception DRDAProtocolException if a protocol error is detected
1:4f996a4:      */
1:4f996a4:     protected float readFloat(int byteOrder) throws DRDAProtocolException
1:4f996a4:     {
1:4f996a4:         return Float.intBitsToFloat(readInt(byteOrder));
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * Read platform double value
1:db9a013:      * @return  value
1:4f996a4:      *
1:a7adeeb:      * @exception DRDAProtocolException if a protocol error is detected
1:4f996a4:      */
1:4f996a4:     protected double readDouble(int byteOrder) throws DRDAProtocolException
1:4f996a4:     {
1:4f996a4:         return Double.longBitsToDouble(readLong(byteOrder));
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * Read a BigDecimal value
1:db9a013:      * @param   precision of the BigDecimal
1:db9a013:      * @param   scale of the BigDecimal
1:db9a013:      * @return  value
1:4f996a4:      *
1:a7adeeb:      * @exception DRDAProtocolException if a protocol error is detected
1:4f996a4:      */
1:4f996a4:     protected BigDecimal readBigDecimal(int precision, int scale) throws DRDAProtocolException
1:4f996a4:     {
1:eac0369:       // The byte-length of a packed decimal with precision p is always p/2 + 1
1:eac0369:       int length = precision / 2 + 1;
1:eac0369: 
1:4f996a4:       ensureBLayerDataInBuffer (length, ADJUST_LENGTHS);
1:eac0369: 
1:eac0369:       // check for sign.
1:eac0369:       int signum;
1:eac0369:       if ((buffer[pos+length-1] & 0x0F) == 0x0D)
1:eac0369:         signum = -1;
18:eac0369:       else
1:eac0369:         signum =  1;
1:eac0369: 
1:4020781:       if (precision <= 18) {
1:eac0369:         // can be handled by long without overflow.
1:eac0369:         long value = packedNybblesToLong(buffer, pos, 0, length*2-1);
1:4020781:         if (signum < 0) {
1:4020781:             value = -value;
1:4020781:         }
1:eac0369: 
1:4f996a4:         pos += length;
1:4020781:         return BigDecimal.valueOf(value, scale);
1:cdfb2d1:       }
1:eac0369:       else if (precision <= 27) {
1:eac0369:         // get the value of last 9 digits (5 bytes).
1:eac0369:         int lo = packedNybblesToInt(buffer, pos, (length-5)*2, 9);
1:eac0369:         // get the value of another 9 digits (5 bytes).
1:eac0369:         int me = packedNybblesToInt(buffer, pos, (length-10)*2+1, 9);
1:eac0369:         // get the value of the rest digits.
1:eac0369:         int hi = packedNybblesToInt(buffer, pos, 0, (length-10)*2+1);
1:eac0369: 
1:eac0369:         // compute the int array of magnitude.
1:eac0369:         int[] value = computeMagnitude(new int[] {hi, me, lo});
1:eac0369: 
3:eac0369:         // convert value to a byte array of magnitude.
1:eac0369:         byte[] magnitude = new byte[12];
1:eac0369:         magnitude[0]  = (byte)(value[0] >>> 24);
1:eac0369:         magnitude[1]  = (byte)(value[0] >>> 16);
1:eac0369:         magnitude[2]  = (byte)(value[0] >>> 8);
1:eac0369:         magnitude[3]  = (byte)(value[0]);
1:eac0369:         magnitude[4]  = (byte)(value[1] >>> 24);
1:eac0369:         magnitude[5]  = (byte)(value[1] >>> 16);
1:eac0369:         magnitude[6]  = (byte)(value[1] >>> 8);
1:eac0369:         magnitude[7]  = (byte)(value[1]);
1:eac0369:         magnitude[8]  = (byte)(value[2] >>> 24);
1:eac0369:         magnitude[9]  = (byte)(value[2] >>> 16);
1:eac0369:         magnitude[10] = (byte)(value[2] >>> 8);
1:eac0369:         magnitude[11] = (byte)(value[2]);
1:eac0369: 
1:4f996a4:         pos += length;
3:eac0369:         return new java.math.BigDecimal (new java.math.BigInteger(signum, magnitude), scale);
1:cdfb2d1:       }
1:eac0369:       else if (precision <= 31) {
1:eac0369:         // get the value of last 9 digits (5 bytes).
1:eac0369:         int lo   = packedNybblesToInt(buffer, pos, (length-5)*2, 9);
1:eac0369:         // get the value of another 9 digits (5 bytes).
1:eac0369:         int meLo = packedNybblesToInt(buffer, pos, (length-10)*2+1, 9);
1:eac0369:         // get the value of another 9 digits (5 bytes).
1:eac0369:         int meHi = packedNybblesToInt(buffer, pos, (length-14)*2, 9);
1:eac0369:         // get the value of the rest digits.
1:eac0369:         int hi   = packedNybblesToInt(buffer, pos, 0, (length-14)*2);
1:eac0369: 
1:eac0369:         // compute the int array of magnitude.
1:eac0369:         int[] value = computeMagnitude(new int[] {hi, meHi, meLo, lo});
1:eac0369: 
1:eac0369:         // convert value to a byte array of magnitude.
1:eac0369:         byte[] magnitude = new byte[16];
1:eac0369:         magnitude[0]  = (byte)(value[0] >>> 24);
1:eac0369:         magnitude[1]  = (byte)(value[0] >>> 16);
1:eac0369:         magnitude[2]  = (byte)(value[0] >>> 8);
1:eac0369:         magnitude[3]  = (byte)(value[0]);
1:eac0369:         magnitude[4]  = (byte)(value[1] >>> 24);
1:eac0369:         magnitude[5]  = (byte)(value[1] >>> 16);
1:eac0369:         magnitude[6]  = (byte)(value[1] >>> 8);
1:eac0369:         magnitude[7]  = (byte)(value[1]);
1:eac0369:         magnitude[8]  = (byte)(value[2] >>> 24);
1:eac0369:         magnitude[9]  = (byte)(value[2] >>> 16);
1:eac0369:         magnitude[10] = (byte)(value[2] >>> 8);
1:eac0369:         magnitude[11] = (byte)(value[2]);
1:eac0369:         magnitude[12] = (byte)(value[3] >>> 24);
1:eac0369:         magnitude[13] = (byte)(value[3] >>> 16);
1:eac0369:         magnitude[14] = (byte)(value[3] >>> 8);
1:eac0369:         magnitude[15] = (byte)(value[3]);
1:eac0369: 
1:4f996a4:         pos += length;
1:eac0369:         return new java.math.BigDecimal (new java.math.BigInteger(signum, magnitude), scale);
1:ee2a860:       }
5:eac0369:       else {
1:4f996a4:         pos += length;
1:eac0369:         // throw an exception here if nibbles is greater than 31
1:eac0369:         throw new java.lang.IllegalArgumentException("Decimal may only be up to 31 digits!");
1:fefd864:       }
1:fefd864:     }
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * Creates an InputStream which can stream EXTDTA objects.
1:4f996a4:      * The InputStream uses this DDMReader to read data from network. The 
1:4f996a4:      * DDMReader should not be used before all data in the stream has been read.
1:4f996a4:      * @param checkNullability used to check if the stream is null. If it is 
1:4f996a4:      * null, this method returns null
1:4f996a4:      * @return EXTDTAReaderInputStream object which can be passed to prepared
1:4f996a4:      *         statement as a binary stream.
1:4f996a4:      * @exception DRDAProtocolException standard DRDA protocol exception
1:4f996a4:      */
1:4f996a4:     EXTDTAReaderInputStream getEXTDTAReaderInputStream
1:4f996a4:         (final boolean checkNullability)
1:4f996a4:         throws DRDAProtocolException
1:4f996a4:     {
1:4f996a4:         if (checkNullability && isEXTDTANull()) {
1:4f996a4:             return null;
1:cf5cebf:         }
1:cf5cebf: 
1:cf5cebf:         // Check if we must read the status byte sent by the client.
1:cf5cebf:         boolean readEXTDTAStatusByte =
1:cf5cebf:                 agent.getSession().appRequester.supportsEXTDTAAbort();
1:fefd864:             
1:cf5cebf:         if (doingLayerBStreaming) {
1:cf5cebf:             return new LayerBStreamedEXTDTAReaderInputStream(
1:cf5cebf:                     this, readEXTDTAStatusByte);
1:fefd864:         } else {
1:cf5cebf:             return new StandardEXTDTAReaderInputStream(
1:cf5cebf:                     this, readEXTDTAStatusByte);
1:4f996a4:         }
1:fefd864: 
1:fefd864:     }
1:fefd864:     
1:d79abcf:     /**
1:4f996a4:      * This method is used by EXTDTAReaderInputStream to read the first chunk 
1:4f996a4:      * of data.
1:fefd864:      * This lengthless method must be called only when layer B streaming.
1:ee2a860:      *
1:4f996a4:      * @exception DRDAProtocolException standard DRDA protocol exception
1:4f996a4:      */
1:4f996a4:     ByteArrayInputStream readLOBInitStream() 
1:4f996a4:         throws DRDAProtocolException
1:4f996a4:     {
1:fefd864:         if ( SanityManager.DEBUG ) {
1:fefd864:             SanityManager.ASSERT( doingLayerBStreaming );
1:fefd864:         }
1:4f996a4:         
1:fefd864:         return readLOBInitStream( 0 );
1:4f996a4:         
1:4f996a4:     }
1:fefd864:     
1:fefd864: 
1:4f996a4:     /**
1:4f996a4:      * This method is used by EXTDTAReaderInputStream to read the first chunk 
1:4f996a4:      * of data.
1:4f996a4:      * @param desiredLength the desired length of chunk. This parameter is ignored when layerB Streaming is doing.
1:4f996a4:      * @exception DRDAProtocolException standard DRDA protocol exception
1:4f996a4:      */
1:4f996a4:     ByteArrayInputStream readLOBInitStream(final long desiredLength) 
1:4f996a4:         throws DRDAProtocolException
1:4f996a4:     {
1:4f996a4:         return readLOBChunk(false, desiredLength);
1:4f996a4:     }
1:4f996a4:     
1:fefd864:     
1:ee2a860:     /**
1:4f996a4:      * This method is used by EXTDTAReaderInputStream to read the next chunk 
1:4f996a4:      * of data.
1:ee2a860:      *
1:fefd864:      * Calling this method finishes layer B streaming 
1:fefd864:      * if continuation of DSS segment was finished.
1:fefd864:      * This lengthless method must be called only when layer B streaming.
1:fefd864:      *
1:4f996a4:      * @exception IOException IOException
1:4f996a4:      */
1:4f996a4:     ByteArrayInputStream readLOBContinuationStream ()
1:4f996a4:         throws IOException
1:db9a013:     {
1:fefd864:         if ( SanityManager.DEBUG ) {
1:fefd864:             SanityManager.ASSERT( doingLayerBStreaming );
1:fefd864:         }
1:fefd864:         return readLOBContinuationStream( 0 );
1:4f996a4:     }
1:fefd864:     
1:fefd864: 
1:4f996a4:     /**
1:4f996a4:      * This method is used by EXTDTAReaderInputStream to read the next chunk 
1:4f996a4:      * of data.
1:fefd864:      *
1:fefd864:      * Furthermore, when Layer B streaming is carried out,
1:fefd864:      * calling this method finishes layer B streaming 
1:fefd864:      * if continuation of DSS segment was finished.
1:fefd864:      *
1:4f996a4:      * @param desiredLength the desired length of chunk. This parameter is ignored when layerB Streaming is doing.
1:4f996a4:      * @exception IOException IOException
1:4f996a4:      */
1:4f996a4:     ByteArrayInputStream readLOBContinuationStream (final long desiredLength)
1:4f996a4:         throws IOException
1:db9a013:     {
1:4f996a4:         try {
1:4f996a4:             return readLOBChunk(true, desiredLength);
1:4f996a4:         } catch (DRDAProtocolException e) {
1:06797bd:             e.printStackTrace(agent.getServer().logWriter());
1:4f996a4:             throw new IOException(e.getMessage());
1:4f996a4:         }
1:4f996a4:     }
1:a376274: 
1:4f996a4:     /**
1:4f996a4:      * This method is used by EXTDTAReaderInputStream to read the next chunk 
1:4f996a4:      * of data.
1:fefd864:      *
1:fefd864:      * Furthermore, when Layer B streaming is carried out,
1:fefd864:      * calling this method may finish layer B streaming.
1:fefd864:      *
1:4f996a4:      * @param readHeader set to true if the dss continuation should be read
1:4f996a4:      * @param desiredLength the desired length of chunk. This parameter is ignored when layerB Streaming is doing.
1:4f996a4:      * @exception DRDAProtocolException standard DRDA protocol exception
1:4f996a4:      */
1:4f996a4:     private ByteArrayInputStream readLOBChunk
1:4f996a4:         (final boolean readHeader, final long desiredLength)
1:4f996a4:         throws DRDAProtocolException
1:db9a013:     {
1:db9a013:         if (readHeader) {
1:4f996a4:             readDSSContinuationHeader();
1:4f996a4:         }
1:4f996a4:         
1:fefd864:         int copySize = doingLayerBStreaming ? 
1:fefd864:             dssLength : 
1:fefd864:             (int) Math.min(dssLength, desiredLength);
1:4f996a4:         
1:4f996a4:         // read the segment
1:4f996a4:         ensureALayerDataInBuffer (copySize);
1:fefd864:         
1:fefd864:         if( ! doingLayerBStreaming ){
1:fefd864:             adjustLengths (copySize);
1:fefd864:             
1:fefd864:         }else{
1:fefd864:             dssLength -= copySize;
1:4f996a4:             
1:fc30c5f:         }
1:fefd864:         
1:4f996a4:         // Create ByteArrayInputStream on top of buffer. 
1:4f996a4:         // This will not make a copy of the buffer.
1:4f996a4:         ByteArrayInputStream bais = 
1:4f996a4:             new ByteArrayInputStream(buffer, pos, copySize);
1:4f996a4:         pos += copySize;
1:4f996a4:         
1:fefd864:         if( doingLayerBStreaming && 
1:fefd864:             ! dssIsContinued )
1:fefd864:             finishLayerBStreaming();
1:fefd864:         
1:4f996a4:         return bais;
1:4f996a4:     }
1:4abfe24: 
1:4f996a4:     byte[] getExtData (long desiredLength, boolean checkNullability) throws DRDAProtocolException
1:4f996a4:   {
1:fefd864: 
1:fefd864:       if ( SanityManager.DEBUG ) {
1:fefd864:             SanityManager.ASSERT( ! doingLayerBStreaming );
1:fefd864:         }
1:fefd864: 
1:eac0369:     boolean readHeader;
1:eac0369:     int copySize;
1:489a05c:     ByteArrayOutputStream baos;
1:eac0369:     boolean isLengthAndNullabilityUnknown = false;
1:4f996a4: 
1:4abfe24:     
1:4f996a4:     if (desiredLength != -1) {
1:eac0369:         // allocate a stream based on a known amount of data
1:489a05c:         baos = new ByteArrayOutputStream ((int) desiredLength);
1:4f996a4:     }
1:4f996a4:     else {
1:eac0369:         // allocate a stream to hold an unknown amount of data
1:489a05c:         baos = new ByteArrayOutputStream ();
1:eac0369:         //isLengthAndNullabilityUnknown = true;
1:4f996a4:         // If we aren't given a  length get the whole thing.
1:4f996a4:         desiredLength = MAX_EXTDTA_SIZE;
1:4f996a4:     }
1:4f996a4:     
1:4abfe24: 
1:eac0369:     // check for a null EXTDTA value, if it is nullable and if streaming
1:eac0369:     if (checkNullability)
1:eac0369:       if (isEXTDTANull())
1:a376274:         return null;
1:a376274: 
1:eac0369:     // set the amount to read for the first segment
1:4f996a4:     copySize = (int) Math.min(dssLength,desiredLength); //note: has already been adjusted for headers
1:a376274: 
1:a376274: 
1:eac0369:     //if (checkNullability)  // don't count the null byte we've already read
1:4f996a4:     //copySize--;
1:a376274: 
2:eac0369:     do {
1:eac0369:       // determine if a continuation header needs to be read after the data
2:eac0369:       if (dssIsContinued)
1:eac0369:         readHeader = true;
1:eac0369:       else
1:eac0369:         readHeader = false;
1:eac0369: 
1:a376274:       // read the segment
1:a376274:       ensureALayerDataInBuffer (copySize);
1:a376274:       adjustLengths (copySize);
1:eac0369:       baos.write (buffer, pos, copySize);
1:a376274:       pos += copySize;
1:4f996a4:       desiredLength -= copySize;
1:eac0369: 
1:eac0369:       // read the continuation header, if necessary
1:eac0369:       if (readHeader)
1:eac0369:         readDSSContinuationHeader ();
1:eac0369: 
1:4f996a4:       copySize = (int) Math.min(dssLength,desiredLength); //note: has already been adjusted for headers
1:eac0369: 
1:fefd864:     }
1:eac0369:     while (readHeader == true && desiredLength > 0);
1:eac0369: 
1:eac0369:     return baos.toByteArray();
1:fefd864:   }
1:eac0369: 
1:eac0369: 
1:eac0369:   // reads a DSS continuation header
1:eac0369:   // prereq: pos is positioned on the first byte of the two-byte header
1:eac0369:   // post:   dssIsContinued is set to true if the continuation bit is on, false otherwise
1:eac0369:   //         dssLength is set to DssConstants.MAXDSS_LEN - 2 (don't count the header for the next read)
1:eac0369:   // helper method for getEXTDTAData
1:4f996a4:     private void readDSSContinuationHeader () throws DRDAProtocolException
1:4f996a4:   {
1:eac0369:     ensureALayerDataInBuffer(2);
1:eac0369: 
1:eac0369:     dssLength =
1:eac0369:       ((buffer[pos++]&0xFF) << 8) +
1:eac0369:       ((buffer[pos++]&0xFF) << 0);
1:eac0369: 
1:eac0369:     if ((dssLength & 0x8000) == 0x8000) {
3:eac0369:       dssLength = DssConstants.MAX_DSS_LENGTH;
4:eac0369:       dssIsContinued = true;
1:fefd864:     }
1:eac0369:     else {
4:eac0369:       dssIsContinued = false;
1:fefd864:     }
1:eac0369:     // it is a syntax error if the dss continuation header length
1:eac0369:     // is less than or equal to two
1:eac0369:     if (dssLength <= 2) {
1:4f996a4:         agent.throwSyntaxrm(CodePoint.SYNERRCD_DSS_CONT_LESS_OR_EQUAL_2,
1:4f996a4:                                DRDAProtocolException.NO_CODPNT_ARG);
1:fefd864:     }
1:eac0369: 
1:eac0369:     dssLength -= 2;  // avoid consuming the DSS cont header
1:4abfe24:   }
1:eac0369: 
1:eac0369: // checks the null EXTDTA byte
1:eac0369:   // returns true if null, false otherwise
1:eac0369:   // helper method for getEXTDTAData
1:eac0369:   private boolean isEXTDTANull () throws DRDAProtocolException
1:4f996a4:   {
1:eac0369:     // make sure that the null byte is in the buffer
1:eac0369:     ensureALayerDataInBuffer (1);
1:eac0369:     adjustLengths (1);
1:eac0369: 
1:eac0369:     // examine the null byte
1:eac0369:     byte nullByte = buffer[pos++];
1:eac0369:     if (nullByte == (byte)0x00)
1:eac0369:       return false;
1:eac0369: 
1:eac0369:     return true;
1:4abfe24:   }
1:eac0369: 
1:eac0369: 
1:fefd864:    /**
1:eac0369:     * Convert a range of packed nybbles (up to 9 digits without overflow) to an int.
1:eac0369:     * Note that for performance purpose, it does not do array-out-of-bound checking.
1:db9a013:     * @param buffer         buffer to read from
1:db9a013:     * @param offset         offset in the buffer
1:4f996a4:     * @param startNybble        start nybble
1:4f996a4:     * @param numberOfNybbles    number of nybbles
1:db9a013:     * @return   an int value
1:d79abcf:     */
1:eac0369:     private int packedNybblesToInt (byte[] buffer,
1:eac0369:                                          int offset,
1:eac0369:                                          int startNybble,
1:eac0369:                                          int numberOfNybbles)
1:fc30c5f:     {
1:eac0369:       int value = 0;
1:eac0369: 
1:eac0369:       int i = startNybble / 2;
1:eac0369:       if ((startNybble % 2) != 0) {
1:eac0369:         // process low nybble of the first byte if necessary.
1:eac0369:         value += buffer[offset+i] & 0x0F;
1:eac0369:         i++;
1:4abfe24:       }
1:eac0369: 
1:eac0369:       int endNybble = startNybble + numberOfNybbles -1;
1:eac0369:       for (; i<(endNybble+1)/2; i++) {
1:eac0369:         value = value*10 + ((buffer[offset+i] & 0xF0) >>> 4); // high nybble.
1:eac0369:         value = value*10 +  (buffer[offset+i] & 0x0F);        // low nybble.
1:4abfe24:       }
1:eac0369: 
1:eac0369:       if ((endNybble % 2) == 0) {
1:eac0369:         // process high nybble of the last byte if necessary.
1:eac0369:         value = value*10 + ((buffer[offset+i] & 0xF0) >>> 4);
1:4abfe24:       }
1:eac0369: 
1:db9a013:       return value;
1:4f996a4:     }
1:eac0369: 
1:4abfe24:     /**
1:eac0369:      * Convert a range of packed nybbles (up to 18 digits without overflow) to a long.
1:eac0369:      * Note that for performance purpose, it does not do array-out-of-bound checking.
1:4f996a4:      * @param buffer        buffer to read from
1:4f996a4:      * @param offset        offset in the buffer
1:db9a013:      * @param startNybble       start nybble
1:db9a013:      * @param numberOfNybbles   number of nybbles
1:db9a013:      * @return  an long value
1:ee2a860:      */
1:eac0369:     private long packedNybblesToLong (byte[] buffer,
1:eac0369:                                            int offset,
1:eac0369:                                            int startNybble,
1:eac0369:                                            int numberOfNybbles)
1:fc30c5f:     {
1:eac0369:       long value = 0;
1:eac0369: 
1:eac0369:       int i = startNybble / 2;
1:eac0369:       if ((startNybble % 2) != 0) {
1:eac0369:         // process low nybble of the first byte if necessary.
1:eac0369:         value += buffer[offset+i] & 0x0F;
1:eac0369:         i++;
1:a376274:       }
1:eac0369: 
1:eac0369:       int endNybble = startNybble + numberOfNybbles -1;
1:eac0369:       for (; i<(endNybble+1)/2; i++) {
1:eac0369:         value = value*10 + ((buffer[offset+i] & 0xF0) >>> 4); // high nybble.
1:eac0369:         value = value*10 +  (buffer[offset+i] & 0x0F);        // low nybble.
1:a376274:       }
1:eac0369: 
1:eac0369:       if ((endNybble % 2) == 0) {
1:eac0369:         // process high nybble of the last byte if necessary.
1:eac0369:         value = value*10 + ((buffer[offset+i] & 0xF0) >>> 4);
1:a376274:       }
1:eac0369: 
1:4f996a4:       return value;
1:a376274:     }
1:eac0369: 
4:a376274:     /**
1:eac0369:      * Compute the int array of magnitude from input value segments.
1:db9a013:      * @param   input value segments
1:db9a013:      * @return  array of int magnitudes
1:fefd864:      */
1:eac0369:     private int[] computeMagnitude(int[] input)
1:ee2a860:     {
1:eac0369:         int length = input.length;
1:eac0369:         int[] mag = new int[length];
1:eac0369: 
1:eac0369:         mag[length-1] = input[length-1];
1:eac0369:         for (int i=0; i<length-1; i++) {
1:eac0369:           int carry = 0;
1:eac0369:           int j = tenRadixMagnitude[i].length-1;
1:eac0369:           int k = length-1;
1:eac0369:           for (; j>=0; j--, k--) {
1:eac0369:             long product = (input[length-2-i] & 0xFFFFFFFFL) * (tenRadixMagnitude[i][j] & 0xFFFFFFFFL)
1:eac0369:                          + (mag[k] & 0xFFFFFFFFL) // add previous value
1:eac0369:                          + (carry & 0xFFFFFFFFL); // add carry
1:eac0369:             carry  = (int) (product >>> 32);
1:eac0369:             mag[k] = (int) (product & 0xFFFFFFFFL);
1:a376274:           }
1:eac0369:           mag[k] = (int) carry;
1:a376274:         }
1:eac0369:         return mag;
1:a376274:     }
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * Read encrypted string
1:4f996a4:      * @param   decryptM  decryption manager
1:4f996a4:      * @param   securityMechanism security mechanism
1:4f996a4:      * @param   initVector   initialization vector for cipher
1:4f996a4:      * @param   sourcePublicKey  public key (as in Deffie-Hellman algorithm)
1:4f996a4:      *                           from source (encryptor)
1:4f996a4:      * @return  decrypted string
1:4f996a4:      *
1:a7adeeb:      * @exception DRDAProtocolException if a protocol error is detected
1:a7adeeb:      * @exception java.sql.SQLException wrapping any exception in decryption
1:4f996a4:      */
1:4f996a4:     protected String readEncryptedString (DecryptionManager decryptM, int securityMechanism,
1:4f996a4:                                          byte[] initVector, byte[] sourcePublicKey)
1:4f996a4:             throws DRDAProtocolException, java.sql.SQLException
1:4f996a4:     {
1:4f996a4:         byte[] cipherText = readBytes();
1:4f996a4:         byte[] plainText = null;
1:4f996a4:         plainText = decryptM.decryptData(cipherText, securityMechanism, initVector,
1:4f996a4:                                              sourcePublicKey);
1:4f996a4:         if (plainText == null)
1:4f996a4:             return null;
1:4f996a4:         else
1:4f996a4:             return ccsidManager.convertToJavaString(plainText);
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * Read string value
1:4f996a4:      * Strings in DRDA protocol are encoded in EBCDIC by default so we
1:4f996a4:      * need to convert to UCS2
1:4f996a4:      * @param length  - length of string to read
1:4f996a4:      * @return value
1:4f996a4:      *
1:a7adeeb:      * @exception DRDAProtocolException if a protocol error is detected
1:4f996a4:      */
1:4f996a4:     protected String readString (int length) throws DRDAProtocolException
1:4f996a4:     {
1:4f996a4:         ensureBLayerDataInBuffer (length, ADJUST_LENGTHS);
1:eac0369: 
1:4f996a4:         String result = ccsidManager.convertToJavaString(buffer, pos, length);
1:4f996a4:         pos += length;
1:4f996a4:         return result;
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * Read string value into a <code>DRDAString</code> object.
1:4f996a4:      *
1:4f996a4:      * @param dst  destination for the read string
1:4f996a4:      * @param size size (in bytes) of string to read
1:4f996a4:      * @param unpad if true, remove padding (trailing spaces)
1:4f996a4:      *
1:4f996a4:      * @exception DRDAProtocolException
1:4f996a4:      */
1:4f996a4:     protected void readString(DRDAString dst, int size, boolean unpad)
1:4f996a4:         throws DRDAProtocolException
1:4f996a4:     {
1:4f996a4:         ensureBLayerDataInBuffer(size, ADJUST_LENGTHS);
1:4f996a4:         int startPos = pos;
1:4f996a4:         pos += size;
1:4f996a4:         if (unpad) {
1:4f996a4:             while ((size > 0) &&
1:4f996a4:                    (buffer[startPos + size - 1] == ccsidManager.space)) {
1:4f996a4:                 --size;
1:4f996a4:             }
1:4f996a4:         }
1:4f996a4:         dst.setBytes(buffer, startPos, size);
1:4f996a4:     }
1:ee2a860: 
1:4f996a4:     /**
1:4f996a4:      * Read encoded string value
1:4f996a4:      * @param length  - length of string to read
1:4f996a4:      * @return value
1:4f996a4:      *
1:a7adeeb:      * @exception DRDAProtocolException if a protocol error is detected
1:4f996a4:      */
1:4f996a4:     protected String readString (int length, String encoding) 
1:4f996a4:         throws DRDAProtocolException
1:4f996a4:     {
1:4f996a4:         ensureBLayerDataInBuffer (length, ADJUST_LENGTHS);
1:4f996a4:         String s = null;
1:eac0369: 
1:4f996a4:         try {
1:4f996a4:           s = new String (buffer, pos, length, encoding);
1:4f996a4:         }
1:4f996a4:         catch (java.io.UnsupportedEncodingException e) {
1:4f996a4:             agent.agentError("UnsupportedEncodingException in readString, encoding = " 
1:4f996a4:                     + encoding);
1:06797bd:             e.printStackTrace(agent.getServer().logWriter());
1:4f996a4:         }
1:4f996a4:         
2:4f996a4:         pos += length;
1:4f996a4:         return s;
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * Read specified length of string value in DDM data with default encoding
1:4f996a4:      * @param length  - length of string to read
1:4f996a4:      * @return value
1:4f996a4:      *
1:a7adeeb:      * @exception DRDAProtocolException if a protocol error is detected
1:4f996a4:      */
1:4f996a4:     protected String readStringData(int length)
1:4f996a4:         throws DRDAProtocolException
1:4f996a4:     {
1:4f996a4:         return readString(length, NetworkServerControlImpl.DEFAULT_ENCODING);
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * Read length delimited string value in DDM data with default encoding
1:4f996a4:      * @return value
1:4f996a4:      *
1:a7adeeb:      * @exception DRDAProtocolException if a protocol error is detected
1:4f996a4:      */
1:4f996a4:     protected String readLDStringData(String encoding)
1:4f996a4:         throws DRDAProtocolException
1:4f996a4:     {
1:4f996a4:         int length = readNetworkShort();
1:4f996a4:         return readString(length, encoding);
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * Read string value
1:4f996a4:      *
1:a7adeeb:      * @exception DRDAProtocolException if a protocol error is detected
1:4f996a4:      */
1:4f996a4:     protected String readString () throws DRDAProtocolException
1:4f996a4:     {
1:4f996a4:         return readString((int)ddmScalarLen);
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * Read byte string value
1:4f996a4:      * @param length  - length of string to read
1:4f996a4:      * @return byte array
1:4f996a4:      *
1:a7adeeb:      * @exception DRDAProtocolException if a protocol error is detected
1:4f996a4:      */
1:4f996a4:     protected byte[] readBytes (int length) throws DRDAProtocolException
1:4f996a4:     {
1:4f996a4:         byte[] b;
1:eac0369: 
1:505bb8a:         if (length < DssConstants.MAX_DSS_LENGTH)
1:4f996a4:         {
1:4f996a4:             ensureBLayerDataInBuffer (length, ADJUST_LENGTHS);
1:4f996a4:             b = new byte[length];
1:4f996a4:             System.arraycopy(buffer,pos,b,0,length);
1:4f996a4:             pos +=length;
1:4f996a4:         }
1:4f996a4:         else
1:4f996a4:             b = getExtData(length,false);
1:4f996a4:         return b;
1:4f996a4:     }
1:4f996a4:     
1:4f996a4:     /**
1:4f996a4:      * Read byte string value
1:4f996a4:      * @return byte array
1:4f996a4:      *
1:a7adeeb:      * @exception DRDAProtocolException if a protocol error is detected
1:4f996a4:      */
1:4f996a4:     protected byte[] readBytes () throws DRDAProtocolException
1:4f996a4:     {
1:4f996a4:         return readBytes((int)ddmScalarLen);
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * Skip byte string value
1:4f996a4:      * @param length  - length of string to skip
1:4f996a4:      *
1:a7adeeb:      * @exception DRDAProtocolException if a protocol error is detected
1:4f996a4:      */
1:4f996a4:     protected void skipBytes (int length) throws DRDAProtocolException
1:4f996a4:     {
1:4f996a4:         ensureBLayerDataInBuffer (length, ADJUST_LENGTHS);
1:4f996a4:         pos += length;
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * Skip byte string value
1:4f996a4:      *
1:4f996a4:      * @exception DRDAProtocolException
1:4f996a4:      */
1:4f996a4:     protected void skipBytes () throws DRDAProtocolException
1:4f996a4:     {
1:4f996a4:         skipBytes((int)ddmScalarLen);
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * Skip remaining DSS
1:4f996a4:      *
1:4f996a4:      * @exception DRDAProtocolException
1:4f996a4:      */
1:4f996a4:     protected void skipDss() throws DRDAProtocolException
1:4f996a4:     {
1:4f996a4:         while (dssIsContinued)
1:4f996a4:         {
1:4f996a4:             skipBytes((int)dssLength);
1:4f996a4:             readDSSContinuationHeader();
1:4f996a4:         }
1:4f996a4:         skipBytes((int)dssLength);
1:4f996a4:         topDdmCollectionStack = EMPTY_STACK;
1:4f996a4:         ddmScalarLen = 0;
1:4f996a4:         dssLength = 0;
1:eac0369: 
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     protected void clearBuffer() throws DRDAProtocolException
1:4f996a4:     {
1:4f996a4:         skipBytes(java.lang.Math.min(dssLength, count - pos));
1:4f996a4:         dssIsChainedWithSameID = false;
1:4f996a4:         dssIsChainedWithDiffID = false;
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * Convert EBCDIC byte array to unicode string
1:4f996a4:      *
1:db9a013:      * @param   buf - byte array
1:4f996a4:      * @return string
1:4f996a4:      */
1:4f996a4:     protected String convertBytes(byte[] buf)
1:4f996a4:     {
1:4f996a4:         return ccsidManager.convertToJavaString (buf, 0, buf.length);
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     // Private methods
1:4f996a4:     /**
1:4f996a4:      * Adjust remaining length
1:4f996a4:      *
1:4f996a4:      * @param length - adjustment length
1:4f996a4:      */
1:4f996a4:     private void adjustLengths(int length)
1:4f996a4:     {
1:4f996a4:         ddmScalarLen -= length;
1:4f996a4:         for (int i = 0; i <= topDdmCollectionStack; i++) {
1:4f996a4:           ddmCollectionLenStack[i] -= length;
1:4f996a4:         }
1:4f996a4:         dssLength -= length;
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /********************************************************************/
1:4f996a4:     /*   NetworkServerControl  command protocol reading routines        
1:4f996a4:      */
1:4f996a4:     /********************************************************************/
1:4f996a4:     /**
1:4f996a4:      * Read string value
1:4f996a4:      * @param length  - length of string to read
1:4f996a4:      * @return value
1:4f996a4:      *
1:a7adeeb:      * @exception DRDAProtocolException if a protocol error is detected
1:4f996a4:      */
1:4f996a4:     protected String readCmdString (int length) throws DRDAProtocolException, java.io.UnsupportedEncodingException
1:4f996a4:     {
1:4f996a4:         if (length == 0)
1:4f996a4:             return null;
1:eac0369: 
1:4f996a4:         ensureBLayerDataInBuffer (length, ADJUST_LENGTHS);
1:4f996a4:         String result = new String (buffer, pos, length,
1:4f996a4:                                         NetworkServerControlImpl.DEFAULT_ENCODING);
1:4f996a4:         pos += length;
1:4f996a4:         return result;
1:4f996a4:     }
1:4f996a4:     /**
1:4f996a4:      * Read string value
1:4f996a4:      * @return value
1:4f996a4:      *
1:a7adeeb:      * @exception DRDAProtocolException if a protocol error is detected
1:4f996a4:      */
1:4f996a4:     protected String readCmdString () throws DRDAProtocolException, java.io.UnsupportedEncodingException
1:4f996a4:     {
1:4f996a4:         int length = readNetworkShort();
1:4f996a4:         return readCmdString(length);
1:4f996a4:         
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**************************************************************************/
1:4f996a4:     /*   Private methods
1:4f996a4:     /**************************************************************************/
1:4f996a4:     /**
1:4f996a4:      * Make sure a certain amount of Layer A data is in the buffer.
1:4f996a4:      * The data will be in the buffer after this method is called.
1:4f996a4:      *
1:4f996a4:      * @param desiredDataSize - amount of data we need
1:4f996a4:      *
1:db9a013:      * @exception   DRDAProtocolException
1:4f996a4:      */
1:4f996a4:     private void ensureALayerDataInBuffer (int desiredDataSize) 
1:4f996a4:         throws DRDAProtocolException
1:4f996a4:     {
1:4f996a4:         // calulate the the number of bytes in the buffer.
1:4f996a4:         int avail = count - pos;
1:eac0369: 
1:4f996a4:         // read more bytes off the network if the data is not in the buffer already.
1:4f996a4:         if (avail < desiredDataSize) 
1:4f996a4:         {
1:4f996a4:           fill (desiredDataSize - avail);
1:4f996a4:         }
1:4f996a4:     }
1:4f996a4:     /**
1:4f996a4:      * Make sure a certain amount of Layer B data is in the buffer.
1:4f996a4:      * The data will be in the buffer after this method is called.
1:4f996a4:      *
1:4f996a4:      * @param desiredDataSize - amount of data we need
1:db9a013:      * @param adjustLen - whether to adjust the remaining lengths
1:4f996a4:      *
1:a7adeeb:      * @exception DRDAProtocolException if a protocol error is detected
1:4f996a4:      */
1:4f996a4:     private void ensureBLayerDataInBuffer (int desiredDataSize, boolean adjustLen) 
1:4f996a4:         throws DRDAProtocolException
1:4f996a4:     {
1:f582a77:         if (dssIsContinued && (desiredDataSize > dssLength)) {
1:f582a77:             // The data that we want is split across multiple DSSs
1:f582a77:             int continueDssHeaderCount =
1:f582a77:                 (desiredDataSize - dssLength) / DssConstants.MAX_DSS_LENGTH + 1;
1:f582a77:             // Account for the extra header bytes (2 length bytes per DSS)
1:f582a77:             ensureALayerDataInBuffer(
1:f582a77:                     desiredDataSize + 2 * continueDssHeaderCount);
1:f582a77:             compressBLayerData(continueDssHeaderCount);
1:f582a77:         } else {
1:f582a77:             ensureALayerDataInBuffer(desiredDataSize);
1:f582a77:         }
1:f582a77: 
1:4f996a4:         if (adjustLen)
1:4f996a4:             adjustLengths(desiredDataSize);
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * Compress B Layer data if extended total length is used
1:4f996a4:      * by removing the continuation headers
1:4f996a4:      *
1:4f996a4:      * @param continueDssHeaderCount - amount of data we need
1:4f996a4:      *
1:db9a013:      * @exception   throws DRDAProtocolException
1:4f996a4:      */
1:4f996a4:     private void compressBLayerData (int continueDssHeaderCount) 
1:4f996a4:         throws DRDAProtocolException
1:4f996a4:     {
1:4f996a4: 
1:eac0369:         
1:4f996a4:         // jump to the last continuation header.
1:f582a77:         int tempPos = 0;
1:4f996a4:         for (int i = 0; i < continueDssHeaderCount; i++) 
1:4f996a4:         {
1:4f996a4:             // the first may be less than the size of a full DSS
1:4f996a4:             if (i == 0) 
1:4f996a4:             {
1:4f996a4:                 // only jump by the number of bytes remaining in the current DSS
1:f582a77:                 tempPos = pos + dssLength;
1:4f996a4:             }
1:4f996a4:             else 
1:4f996a4:             {
1:4f996a4:                 // all other jumps are for a full continued DSS
1:f582a77:                 tempPos += DssConstants.MAX_DSS_LENGTH;
1:4f996a4:             }
1:4f996a4:         }
1:eac0369: 
1:eac0369: 
1:4f996a4:         // for each of the DSS headers to remove,
1:4f996a4:         // read out the continuation header and increment the DSS length by the
1:db9a013:         // size of the continuation bytes,  then shift the continuation data as needed.
1:4f996a4:         int shiftSize = 0;
1:4f996a4:         int bytesToShift = 0;
1:4f996a4:         int continueHeaderLength = 0;
1:4f996a4:         int newdssLength = 0;
1:eac0369: 
1:eac0369: 
1:4f996a4:         for (int i = 0; i < continueDssHeaderCount; i++) 
1:4f996a4:         {
1:f582a77:             continueHeaderLength = ((buffer[tempPos] & 0xff) << 8) +
1:f582a77:                 ((buffer[tempPos + 1] & 0xff) << 0);
1:eac0369: 
1:4f996a4:             if (i == 0) 
1:4f996a4:             {
1:4f996a4:                 // if this is the last one (farthest down stream and first to strip out)
1:eac0369: 
1:4f996a4:                 if ((continueHeaderLength & DssConstants.CONTINUATION_BIT) 
1:4f996a4:                         == DssConstants.CONTINUATION_BIT)
1:4f996a4:                 {
1:4f996a4:                   // the last DSS header is again continued
1:4f996a4:                   continueHeaderLength = DssConstants.MAX_DSS_LENGTH;
1:4f996a4:                   dssIsContinued = true;
1:4f996a4:                 }
1:4f996a4:                 else 
1:4f996a4:                 {
1:4f996a4:                   // the last DSS header was not contiued so update continue state flag
1:4f996a4:                   dssIsContinued = false;
1:4f996a4:                 }
1:4f996a4:                 // the very first shift size is 2
1:4f996a4:                 shiftSize = 2;
1:4f996a4:             }
1:4f996a4:             else 
1:4f996a4:             {
1:4f996a4:                 // already removed the last header so make sure the chaining flag is on
1:4f996a4:                 if ((continueHeaderLength & DssConstants.CONTINUATION_BIT) == 
1:4f996a4:                         DssConstants.CONTINUATION_BIT)
1:4f996a4:                 {
1:4f996a4:                   continueHeaderLength = DssConstants.MAX_DSS_LENGTH;
1:4f996a4:                 }
1:4f996a4:                 else 
1:4f996a4:                 {
1:4f996a4:                   // this is a syntax error but not really certain which one.
1:4f996a4:                   // for now pick 0x02 which is DSS header Length does not 
1:4f996a4:                   // match the number
1:4f996a4:                     // of bytes of data found.
1:4f996a4:                     agent.throwSyntaxrm(CodePoint.SYNERRCD_DSS_LENGTH_BYTE_NUMBER_MISMATCH,
1:4f996a4:                                        DRDAProtocolException.NO_CODPNT_ARG);
1:4f996a4:                 }
1:4f996a4:                 // increase the shift size by 2
1:4f996a4:                 shiftSize += 2;
1:4f996a4:             }
1:7062abe: 
1:4f996a4:             // it is a syntax error if the DSS continuation is less 
1:4f996a4:             // than or equal to two
1:4f996a4:             if (continueHeaderLength <= 2) 
1:4f996a4:             {
1:4f996a4:                 agent.throwSyntaxrm(CodePoint.SYNERRCD_DSS_CONT_LESS_OR_EQUAL_2,
1:4f996a4:                                DRDAProtocolException.NO_CODPNT_ARG);
1:4f996a4:             }
1:eac0369: 
1:505bb8a:             newdssLength += (continueHeaderLength-2);
1:eac0369: 
1:4f996a4:             // calculate the number of bytes to shift
1:505bb8a:             if (i != (continueDssHeaderCount - 1))
1:4f996a4:                 bytesToShift = DssConstants.MAX_DSS_LENGTH;
1:4f996a4:             else
1:4f996a4:                 bytesToShift = dssLength;
1:eac0369: 
1:505bb8a:             tempPos -= (bytesToShift - 2);
1:505bb8a:             System.arraycopy(buffer, tempPos - shiftSize, buffer, tempPos,
1:505bb8a:                              bytesToShift);
1:4f996a4:         }
1:4f996a4:         // reposition the start of the data after the final DSS shift.
1:f582a77:         pos = tempPos;
1:505bb8a:         dssLength += newdssLength;
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * Methods to manage the data buffer.
1:4f996a4:      * Methods orginally from JCC
1:4f996a4:      * RESOLVE: need to check if this is the best performing way of doing this
1:4f996a4:      */
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * This is a helper method which shifts the buffered bytes from
1:4f996a4:      * wherever they are in the current buffer to the beginning of
1:4f996a4:      * different buffer (note these buffers could be the same).
1:4f996a4:      * State information is updated as needed after the shift.
1:4f996a4:      * @param destinationBuffer - buffer to shift data to
1:4f996a4:      */
1:4f996a4:     private void shiftBuffer (byte[] destinationBuffer)
1:4f996a4:     {
1:4f996a4:         // calculate the size of the data in the current buffer.
1:4f996a4:         int sz = count - pos;
1:4f996a4:         if (SanityManager.DEBUG) {
1:4f996a4:             if ((sz < 0 || pos < 0) )
1:4f996a4:             {
1:4f996a4:                 SanityManager.THROWASSERT(
1:4f996a4:                           "Unexpected data size or position. sz=" + sz + 
1:4f996a4:                           " count=" + count +" pos=" + pos);
1:4f996a4:             }
1:4f996a4:         }
1:4f996a4:         
1:4f996a4:         // copy this data to the new buffer startsing at position 0.
1:4f996a4:         System.arraycopy (buffer, pos, destinationBuffer, 0, sz);
1:eac0369: 
1:4f996a4:         // update the state information for data in the new buffer.
1:4f996a4:         pos = 0;
1:4f996a4:         count = sz;
1:eac0369: 
1:4f996a4:         // replace the old buffer with the new buffer.
1:4f996a4:         buffer = destinationBuffer;
1:4f996a4:     }
1:4f996a4:     /**
1:4f996a4:      * This method makes sure there is enough room in the buffer
1:4f996a4:      * for a certain number of bytes.  This method will allocate
1:4f996a4:      * a new buffer if needed and shift the bytes in the current buffer
1:4f996a4:      * to make ensure space is available for a fill.  Right now
1:4f996a4:      * this method will shift bytes as needed to make sure there is
1:4f996a4:      * as much room as possible in the buffer before trying to
1:4f996a4:      * do the read.  The idea is to try to have space to get as much data as possible
1:4f996a4:      * if we need to do a read on the socket's stream.
1:4f996a4:      *
1:4f996a4:      * @param desiredSpace - amount of data we need
1:4f996a4:      */
1:4f996a4:     private void ensureSpaceInBufferForFill (int desiredSpace)
1:4f996a4:     {
1:4f996a4:         // calculate the total unused space in the buffer.
1:4f996a4:         // this includes any space at the end of the buffer and any free
1:4f996a4:         // space at the beginning resulting from bytes already read.
1:4f996a4:         int currentAvailableSpace = (buffer.length - count) + pos;
1:eac0369: 
1:4f996a4:         // check to see if there is enough free space.
1:4f996a4:         if (currentAvailableSpace < desiredSpace) {
1:eac0369: 
1:4f996a4:             // there is not enough free space so we need more storage.
1:4f996a4:             // we are going to double the buffer unless that happens to still be 
1:4f996a4:             // too small. If more than double the buffer is needed, 
1:4f996a4:             // use the smallest amount over this as possible.
1:4f996a4:             int doubleBufferSize = (2 * buffer.length);
1:4f996a4:             int minumNewBufferSize = (desiredSpace - currentAvailableSpace) + 
1:4f996a4:                 buffer.length;
1:4f996a4:             int newsz = minumNewBufferSize <= doubleBufferSize ? 
1:4f996a4:                 doubleBufferSize : minumNewBufferSize;
1:eac0369: 
1:4f996a4:             byte[] newBuffer = new byte[newsz];
1:eac0369: 
1:4f996a4:             // shift everything from the old buffer to the new buffer
1:4f996a4:             shiftBuffer (newBuffer);
1:4f996a4:         }
1:4f996a4:         else {
1:eac0369: 
1:4f996a4:             // there is enough free space in the buffer but let's make sure
1:4f996a4:             // it is all at the end.
1:4f996a4:             // this is also important because if we are going to do a read, 
1:4f996a4:             // it would be nice
1:4f996a4:             // to get as much data as possible and making room at the end 
1:4f996a4:             // if the buffer helps to ensure this.
1:4f996a4:             if (pos != 0) {
1:4f996a4:                 shiftBuffer (buffer);
1:4f996a4:             }
1:4f996a4:         }
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * This method will attempt to read a minimum number of bytes
1:db9a013:      * from the underlying stream.  This method will keep trying to
1:4f996a4:      * read bytes until it has obtained at least the minimum number.
1:4f996a4:      * @param minimumBytesNeeded - minimum required bytes
1:4f996a4:      *
1:a7adeeb:      * @exception DRDAProtocolException if a protocol error is detected
1:4f996a4:      */
1:4f996a4:     private void fill (int minimumBytesNeeded) throws DRDAProtocolException
1:4f996a4:     {
1:4f996a4:         // make sure that there is enough space in the buffer to hold
1:4f996a4:         // the minimum number of bytes needed.
1:4f996a4:         ensureSpaceInBufferForFill (minimumBytesNeeded);
1:eac0369: 
1:4f996a4:         // read until the minimum number of bytes needed is now in the buffer.
1:4f996a4:         // hopefully the read method will return as many bytes as it can.
1:4f996a4:         int totalBytesRead = 0;
1:4f996a4:         int actualBytesRead = 0;
1:4f996a4:         do {
1:4f996a4:             try {
1:4f996a4:                 actualBytesRead = inputStream.read (
1:4f996a4:                   buffer, count, buffer.length - count);
1:4f996a4:             } catch (java.net.SocketTimeoutException ste) {
1:1f71856: 
1:1f71856:                 // Transport the timeout out through the layers. This
1:1f71856:                 // exception is caught in DRDAConnThread.run();
1:1f71856:                 throw new DRDASocketTimeoutException(agent);
1:1f71856: 
1:4f996a4:             } catch (java.io.IOException ioe) {
1:1f71856:                 agent.markCommunicationsFailure("DDMReader.fill()",
1:1f71856:                                                 "InputStream.read()", ioe.getMessage(), "*");
1:4f996a4:             } finally {
1:4f996a4:                 if ((dssTrace != null) && dssTrace.isComBufferTraceOn())
1:4f996a4:                   dssTrace.writeComBufferData (buffer,
1:4f996a4:                                                count,
1:4f996a4:                                                actualBytesRead,
1:4f996a4:                                                DssTrace.TYPE_TRACE_RECEIVE,
1:4f996a4:                                                "Request",
1:4f996a4:                                                "fill",
1:4f996a4:                                                5);
1:4f996a4:             }
1:4f996a4:             if (actualBytesRead != -1)
1:4f996a4:             {
1:4f996a4:                 count += actualBytesRead;
1:4f996a4:                 totalBytesRead += actualBytesRead;
1:4f996a4:             }
1:eac0369: 
1:4f996a4:         } while ((totalBytesRead < minimumBytesNeeded) && (actualBytesRead != -1));
1:1f71856: 
1:4f996a4:         if (actualBytesRead == -1) 
1:4f996a4:         {
1:4f996a4:             if (totalBytesRead < minimumBytesNeeded) 
1:4f996a4:             {
1:4f996a4:                 agent.markCommunicationsFailure ("DDMReader.fill()",
1:4f996a4:                   "InputStream.read()", "insufficient data", "*");
1:4f996a4:             }
1:4f996a4:         }
1:1ab256e:         totalByteCount += totalBytesRead;
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * Print a internal trace message
1:4f996a4:      */
1:4f996a4:     private void trace(String msg)
1:4f996a4:     {
1:4f996a4:         if (agent != null)
1:4f996a4:             agent.trace(msg);
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * Return chaining bit for current DSS.
1:4f996a4:      */
1:4f996a4:     protected byte getCurrChainState() {
1:d79abcf: 
1:4f996a4:         if (!dssIsChainedWithSameID && !dssIsChainedWithDiffID)
1:4f996a4:             return DssConstants.DSS_NOCHAIN;
1:d79abcf: 
1:4f996a4:         if (dssIsChainedWithSameID)
1:4f996a4:             return DssConstants.DSSCHAIN_SAME_ID;
1:d79abcf: 
1:4f996a4:         return DssConstants.DSSCHAIN;
1:d79abcf: 
1:4f996a4:     }
1:d79abcf:     
1:fefd864:     
1:fefd864:     private void startLayerBStreaming() {
1:fefd864:         doingLayerBStreaming = true;
1:fc30c5f:     }
1:fefd864:     
1:fefd864:     
1:fefd864:     private void finishLayerBStreaming() {
1:fefd864:         doingLayerBStreaming = false;
1:d79abcf:     }
1:fefd864:     
1:fefd864:     
1:fefd864:     boolean doingLayerBStreaming() {
1:fefd864:         return doingLayerBStreaming;
1:ee2a860:     }
1:fefd864:     
1:fefd864:     
1:ee2a860: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1:     Layer B objects with data &gt;=32763 bytes long format is 
1:                     (high order bit set, indicating &gt;=32763)
/////////////////////////////////////////////////////////////////////////
1:      * @return true if DDM length is &gt; 0
/////////////////////////////////////////////////////////////////////////
1:      * @return true if DDS length is &gt; 0
commit:06797bd
/////////////////////////////////////////////////////////////////////////
1:             e.printStackTrace(agent.getServer().logWriter());
/////////////////////////////////////////////////////////////////////////
1:             e.printStackTrace(agent.getServer().logWriter());
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
commit:505bb8a
/////////////////////////////////////////////////////////////////////////
1: 		if (length < DssConstants.MAX_DSS_LENGTH)
/////////////////////////////////////////////////////////////////////////
1: 			newdssLength += (continueHeaderLength-2);
1: 			if (i != (continueDssHeaderCount - 1))
1: 			tempPos -= (bytesToShift - 2);
1: 			System.arraycopy(buffer, tempPos - shiftSize, buffer, tempPos,
1: 							 bytesToShift);
1: 		dssLength += newdssLength;
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:db9a013
/////////////////////////////////////////////////////////////////////////
1:         Layer B     Agent services
1:         2 bytes     Length of the data
1:         1 byte      'D0' - indicates DDM data
1:         1 byte      DDM format byte(DSSFMT) - type of DSS(RQSDSS,RPYDSS), whether it is
1:         2 bytes     request correlation identifier
/////////////////////////////////////////////////////////////////////////
1:         2 bytes     Length
1:         2 bytes     Type of the object (code point)
/////////////////////////////////////////////////////////////////////////
1:         2 bytes     Length - length of class, length, and extended total length fields
1:         2 bytes     Type of the object (code point)
1:         n bytes     Extended total length - length of the object
1:     Layer C | Specific  |   Specific    |   Specific    |
1:             | Commands  |   Replies     | Scalars and   |
1:     Layer B | Commands  |    Reply      | Scalars and   | Communications |
1:             |           |   Messages    | Collections   |                |
1:     Layer A |  RQSDSS   |   RPYDSS      | OBJDSS        | CMNDSS         |
/////////////////////////////////////////////////////////////////////////
1:     {
/////////////////////////////////////////////////////////////////////////
1:     protected boolean isChainedWithSameID()
1:     {
1:     }
1:     protected boolean isChainedWithDiffID()
1:     {
1:     }
/////////////////////////////////////////////////////////////////////////
1:      *  2 bytes - length
1:      *  1 byte  - 'D0'  - indicates DDM data
1:      *  1 byte  - DSS format
1:      *      |---|---------|----------|
1:      *      | 0 |  flags  |  type    |
1:      *      |---|---------|----------|
1:      *      | 0 | 1  2  3 | 4 5 6 7  |
1:      *      |---|---------|----------|
1:      *      bit 0 - '0'
1:      *      bit 1 - '0' - unchained, '1' - chained
1:      *      bit 2 - '0' - do not continue on error, '1' - continue on error
1:      *      bit 3 - '0' - next DSS has different correlator, '1' - next DSS has
1:      *                      same correlator
1:      *      type - 1 - Request DSS
1:      *           - 2 - Reply DSS
1:      *           - 3 - Object DSS
1:      *           - 4 - Communications DSS
1:      *           - 5 - Request DSS where no reply is expected
1:      *  2 bytes - request correlation id
/////////////////////////////////////////////////////////////////////////
1:         {   // on indicates structure chained to next structure
/////////////////////////////////////////////////////////////////////////
1:                     == DssConstants.DSSCHAIN_SAME_ID)
/////////////////////////////////////////////////////////////////////////
1:         {   // on indicates structure chained to next structure
/////////////////////////////////////////////////////////////////////////
1:             // adjust the lengths here. this is a special case since the
/////////////////////////////////////////////////////////////////////////
1:      *  Get the next CodePoint from a collection
1:      *  @return NO_CODEPOINT if collection stack is empty or remaining length is
1:      *      0; otherwise,  read length and code point
/////////////////////////////////////////////////////////////////////////
1:      *  CodePoint
1:      * @param   codePointCheck  - codePoint to check against
1:      * @return  codePoint
/////////////////////////////////////////////////////////////////////////
1:      * @return  value
/////////////////////////////////////////////////////////////////////////
1:      * @return  value
/////////////////////////////////////////////////////////////////////////
1:      * @return  value
/////////////////////////////////////////////////////////////////////////
1:      * @return  value
/////////////////////////////////////////////////////////////////////////
1:      * @return  value
/////////////////////////////////////////////////////////////////////////
1:      * @return  value
/////////////////////////////////////////////////////////////////////////
1:      * @return  value
/////////////////////////////////////////////////////////////////////////
1:      * @return  value
/////////////////////////////////////////////////////////////////////////
1:      * @return  value
/////////////////////////////////////////////////////////////////////////
1:      * @return  value
/////////////////////////////////////////////////////////////////////////
1:      * @return  value
/////////////////////////////////////////////////////////////////////////
1:      * @param   precision of the BigDecimal
1:      * @param   scale of the BigDecimal
1:      * @return  value
/////////////////////////////////////////////////////////////////////////
1:     {
/////////////////////////////////////////////////////////////////////////
1:     {
/////////////////////////////////////////////////////////////////////////
1:     {
1:         if (readHeader) {
/////////////////////////////////////////////////////////////////////////
1:     * @param buffer         buffer to read from
1:     * @param offset         offset in the buffer
1:     * @return   an int value
/////////////////////////////////////////////////////////////////////////
1:      * @param startNybble       start nybble
1:      * @param numberOfNybbles   number of nybbles
1:      * @return  an long value
/////////////////////////////////////////////////////////////////////////
1:       return value;
1:      * @param   input value segments
1:      * @return  array of int magnitudes
/////////////////////////////////////////////////////////////////////////
1:      * @param   buf - byte array
/////////////////////////////////////////////////////////////////////////
1:      * @exception   DRDAProtocolException
/////////////////////////////////////////////////////////////////////////
1:      * @param adjustLen - whether to adjust the remaining lengths
/////////////////////////////////////////////////////////////////////////
1:      * @exception   throws DRDAProtocolException
/////////////////////////////////////////////////////////////////////////
1:         // size of the continuation bytes,  then shift the continuation data as needed.
/////////////////////////////////////////////////////////////////////////
1:      * from the underlying stream.  This method will keep trying to
commit:4020781
/////////////////////////////////////////////////////////////////////////
1:       if (precision <= 18) {
1:         if (signum < 0) {
1:             value = -value;
1:         }
1:         return BigDecimal.valueOf(value, scale);
commit:db4c995
/////////////////////////////////////////////////////////////////////////
1: 
1: import java.io.ByteArrayInputStream;
1: import java.io.ByteArrayOutputStream;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
commit:542c2b7
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:826d7f1
/////////////////////////////////////////////////////////////////////////
1: 		dssIsChainedWithDiffID = false;
1: 		dssIsChainedWithSameID = false;
commit:a7adeeb
/////////////////////////////////////////////////////////////////////////
1: 	 * @exception DRDAProtocolException if a protocol error is detected
/////////////////////////////////////////////////////////////////////////
1: 	 * @exception DRDAProtocolException if a protocol error is detected
/////////////////////////////////////////////////////////////////////////
1: 	 * @exception DRDAProtocolException if a protocol error is detected
/////////////////////////////////////////////////////////////////////////
1: 	 * @exception DRDAProtocolException if a protocol error is detected
/////////////////////////////////////////////////////////////////////////
1: 	 * @exception DRDAProtocolException if a protocol error is detected
/////////////////////////////////////////////////////////////////////////
1: 	 * @exception DRDAProtocolException if a protocol error is detected
/////////////////////////////////////////////////////////////////////////
1: 	 * @exception DRDAProtocolException if a protocol error is detected
/////////////////////////////////////////////////////////////////////////
1: 	 * @exception DRDAProtocolException if a protocol error is detected
/////////////////////////////////////////////////////////////////////////
1: 	 * @exception DRDAProtocolException if a protocol error is detected
/////////////////////////////////////////////////////////////////////////
1: 	 * @exception DRDAProtocolException if a protocol error is detected
/////////////////////////////////////////////////////////////////////////
1: 	 * @exception DRDAProtocolException if a protocol error is detected
/////////////////////////////////////////////////////////////////////////
1: 	 * @exception DRDAProtocolException if a protocol error is detected
/////////////////////////////////////////////////////////////////////////
1: 	 * @exception DRDAProtocolException if a protocol error is detected
/////////////////////////////////////////////////////////////////////////
1: 	 * @exception DRDAProtocolException if a protocol error is detected
/////////////////////////////////////////////////////////////////////////
1: 	 * @exception DRDAProtocolException if a protocol error is detected
/////////////////////////////////////////////////////////////////////////
1: 	 * @exception DRDAProtocolException if a protocol error is detected
/////////////////////////////////////////////////////////////////////////
1: 	 * @exception DRDAProtocolException if a protocol error is detected
/////////////////////////////////////////////////////////////////////////
1: 	 * @exception DRDAProtocolException if a protocol error is detected
/////////////////////////////////////////////////////////////////////////
1: 	 * @exception DRDAProtocolException if a protocol error is detected
/////////////////////////////////////////////////////////////////////////
1: 	 * @exception DRDAProtocolException if a protocol error is detected
1:      * @exception java.sql.SQLException wrapping any exception in decryption
/////////////////////////////////////////////////////////////////////////
1: 	 * @exception DRDAProtocolException if a protocol error is detected
/////////////////////////////////////////////////////////////////////////
1: 	 * @exception DRDAProtocolException if a protocol error is detected
/////////////////////////////////////////////////////////////////////////
1: 	 * @exception DRDAProtocolException if a protocol error is detected
/////////////////////////////////////////////////////////////////////////
1: 	 * @exception DRDAProtocolException if a protocol error is detected
/////////////////////////////////////////////////////////////////////////
1: 	 * @exception DRDAProtocolException if a protocol error is detected
/////////////////////////////////////////////////////////////////////////
1: 	 * @exception DRDAProtocolException if a protocol error is detected
/////////////////////////////////////////////////////////////////////////
1: 	 * @exception DRDAProtocolException if a protocol error is detected
/////////////////////////////////////////////////////////////////////////
1: 	 * @exception DRDAProtocolException if a protocol error is detected
/////////////////////////////////////////////////////////////////////////
1: 	 * @exception DRDAProtocolException if a protocol error is detected
/////////////////////////////////////////////////////////////////////////
1: 	 * @exception DRDAProtocolException if a protocol error is detected
/////////////////////////////////////////////////////////////////////////
1: 	 * @exception DRDAProtocolException if a protocol error is detected
/////////////////////////////////////////////////////////////////////////
0: 	 * @exception DRDAProtocolException if a protocol error is detected
/////////////////////////////////////////////////////////////////////////
0: 	 * @exception DRDAProtocolException if a protocol error is detected
commit:f582a77
/////////////////////////////////////////////////////////////////////////
1:         if (dssIsContinued && (desiredDataSize > dssLength)) {
1:             // The data that we want is split across multiple DSSs
1:             int continueDssHeaderCount =
1:                 (desiredDataSize - dssLength) / DssConstants.MAX_DSS_LENGTH + 1;
1:             // Account for the extra header bytes (2 length bytes per DSS)
1:             ensureALayerDataInBuffer(
1:                     desiredDataSize + 2 * continueDssHeaderCount);
1:             compressBLayerData(continueDssHeaderCount);
1:         } else {
1:             ensureALayerDataInBuffer(desiredDataSize);
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1: 		
1: 		int tempPos = 0;
1: 				tempPos = pos + dssLength;
1: 				tempPos += DssConstants.MAX_DSS_LENGTH;
/////////////////////////////////////////////////////////////////////////
1: 			continueHeaderLength = ((buffer[tempPos] & 0xff) << 8) +
1: 				((buffer[tempPos + 1] & 0xff) << 0);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 			tempPos -= (bytesToShift - 2);
0: 			System.arraycopy(buffer, tempPos - shiftSize, buffer, tempPos,
0: 							 bytesToShift);
1: 		pos = tempPos;
commit:7062abe
/////////////////////////////////////////////////////////////////////////
0:         // Offset from the start of the valid region of the byte buffer,
0:         // pointing to the start of the DSS we're looking at.
0:         int tempOffset = 0;
1: 
0: 				tempOffset = dssLength;
0: 				tempOffset += DssConstants.MAX_DSS_LENGTH;
/////////////////////////////////////////////////////////////////////////
0:             // Get the length of the DSS. Make sure that we have enough data
0:             // in the buffer to actually see the length (may not have enough
0:             // bytes if this is not the first DSS).
0:             ensureALayerDataInBuffer(tempOffset + 1);
0:             continueHeaderLength =
0:                     ((buffer[pos + tempOffset] & 0xff) << 8) +
0:                     (buffer[pos + tempOffset + 1] & 0xff);
/////////////////////////////////////////////////////////////////////////
1: 
0:                 // Make sure we have all of the last DSS in the buffer
0:                 // (DERBY-4088). Since we look at the last DSS first,
0:                 // we don't need to do this for the other DSSs, as they
0:                 // will also be fetched into the buffer when we fetch the
0:                 // last one.
0:                 ensureALayerDataInBuffer(tempOffset + continueHeaderLength);
/////////////////////////////////////////////////////////////////////////
0: 			tempOffset -= (bytesToShift - 2);
0: 			System.arraycopy(buffer, pos + tempOffset - shiftSize,
0:                              buffer, pos + tempOffset, bytesToShift);
0: 		pos += tempOffset;
commit:24d0b90
/////////////////////////////////////////////////////////////////////////
1: 					((buffer[pos++] & 0xFFL) << 56) +
1: 					((buffer[pos++] & 0xFFL) << 48) +
1: 					((buffer[pos++] & 0xFFL) << 40) +
1: 					((buffer[pos++] & 0xFFL) << 32) +
1: 					((buffer[pos++] & 0xFFL) << 24) +
1: 					((buffer[pos++] & 0xFFL) << 16) +
1: 					((buffer[pos++] & 0xFFL) << 8) +
1: 					((buffer[pos++] & 0xFFL) << 0);
1: 					((buffer[pos++] & 0xFFL) << 40) +
1: 					((buffer[pos++] & 0xFFL) << 32) +
1: 					((buffer[pos++] & 0xFFL) << 24) +
1: 					((buffer[pos++] & 0xFFL) << 16) +
1: 					((buffer[pos++] & 0xFFL) << 8) +
1: 					((buffer[pos++] & 0xFFL) << 0);
1: 					((buffer[pos++] & 0xFFL) << 24) +
1: 					((buffer[pos++] & 0xFFL) << 16) +
1: 					((buffer[pos++] & 0xFFL) << 8) +
1: 					((buffer[pos++] & 0xFFL) << 0);
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:4f996a4
/////////////////////////////////////////////////////////////////////////
1:     The DDMReader is used to read DRDA protocol.   DRDA Protocol is divided into
1:     three layers corresponding to the DDM three-tier architecture. For each layer,
1:     their is a DSS (Data Stream Structure) defined.
1:         Layer A     Communications management services
0:         Layer B        Agent services
1:         Layer C     Data management services
1:     <P>
1:     At layer A are request, reply and data correlation, structure chaining,
1:     continuation or termination of chains when errors are detected, interleaving
1:     and multi-leaving request, reply, and data DSSs for multitasking environments.
1:     For TCP/IP, the format of the DDM envelope is
0:         2 bytes        Length of the data
0:         1 byte        'D0' - indicates DDM data
0:         1 byte        DDM format byte(DSSFMT) - type of DSS(RQSDSS,RPYDSS), whether it is
1:                     chained, information about the next chained DSS
0:         2 bytes        request correlation identifier
1:     <P>
1:     The correlation identifier ties together a request, the request data and the
1:     reply.  In a chained DSS, each request has a correlation identifier which
1:     is higher than the previous request (all correlation identifiers must
1:     be greater than 0).
1:     <P>
1:     At layer B are object mapping, object validation and command routing.
1:     Layer B objects with data 5 bytes less than 32K bytes consist of
0:         2 bytes        Length
0:         2 bytes        Type of the object (code point)
1:         Object data
1:     Object data is either SCALAR or COLLECTION data.  Scalar data consists of
1:     a string of bytes formatted as the class description of the object required.
1:     Collections consist of a set of objects in which the entries in the collection
1:     are nested within the length/ code point of the collection.
1:     <P>
0:     Layer B objects with data >=32763 bytes long format is 
0:         2 bytes        Length - length of class, length, and extended total length fields
0:                     (high order bit set, indicating >=32763)
0:         2 bytes        Type of the object (code point)
0:         n bytes        Extended total length - length of the object
1:                     (n = Length - 4)
1:         Object data
1:     <P>
1:     At layer C are services each class of DDM object provides.
1:             |-------------------------------------------|
0:     Layer C | Specific    |    Specific    |    Specific    |
0:             | Commands    |    Replies        | Scalars and    |
1:             | and their |  and their    | Collections   |
1:             |-------------------------------------------|----------------|
0:     Layer B | Commands  |    Reply        | Scalars and   | Communications |
0:             |            |   Messages    | Collections    |                |
1:             |-----------|---------------|---------------|----------------|
0:     Layer A |  RQSDSS   |   RPYDSS        | OBJDSS        | CMNDSS         |
1:             |           |               |               | Mapped Data    |
1:             |-----------|---------------|---------------|----------------|
1:             |                DDM Data Stream Structures                  |
1:             |------------------------------------------------------------|
1:             
1:     DSS's may be chained so that more than one can be transmitted at a time
1:     to improve performance.
1:     For more details, see DRDA Volume 3 (Distributed Data Management(DDM)
1:         Architecture (DDS definition)
1:     private final static int DEFAULT_BUFFER_SIZE = 32767;
1:     private final static int MAX_MARKS_NESTING = 10;
1:     private final static int NO_CODEPOINT = -1;
1:     private final static int EMPTY_STACK = -1;
1:     private final static boolean ADJUST_LENGTHS = true;
1:     private final static boolean NO_ADJUST_LENGTHS = false;
1:     private final static long MAX_EXTDTA_SIZE= Long.MAX_VALUE;
1:     // magnitude represented in an int array, used in BigDecimal conversion
1:     private DRDAConnThread agent;
1:     private Utf8CcsidManager utf8CcsidManager;
1:     private EbcdicCcsidManager ebcdicCcsidManager;
1:     private CcsidManager ccsidManager;
1:     // data buffer
1:     private byte[] buffer;
1:     private int pos;
1:     private int count;
1:     // DDM object collection
1:     // top of stack
1:     private int topDdmCollectionStack;
1:     // length of each object in the stack
1:     private long[] ddmCollectionLenStack;
1:     // DDM object length
1:     private long ddmScalarLen;
1:     // DSS Length
1:     private int dssLength;
1:     // DSS is larger than 32672 (continuation bit is set) so DSS is continued
1:     private boolean dssIsContinued;
1:     private boolean terminateChainOnErr;
1:     // next DSS in the chain has the same correlator
1:     private boolean dssIsChainedWithSameID;
1:     // next DSS in the chain has a different correlator
1:     private boolean dssIsChainedWithDiffID;
1:     
1:     // correlation id for the current DSS
1:     private int dssCorrelationID;
1:     // previous corelation id
1:     private int prevCorrelationID;
1:     // current server codepoint
1:     private int svrcod;
1:     // trace object of the associated session
1:     private DssTrace dssTrace;
1:     // input stream
1:     private InputStream inputStream;
/////////////////////////////////////////////////////////////////////////
1:     // constructor
1:     DDMReader (DRDAConnThread agent, DssTrace dssTrace)
1:     {
1:         buffer = new byte[DEFAULT_BUFFER_SIZE];
1:         ddmCollectionLenStack = new long[MAX_MARKS_NESTING];
1:         initialize(agent, dssTrace);
1:     }
1:     /**
1:      * This constructor is used for testing the protocol
1:      * server 
1:      */
1:     DDMReader(InputStream inputStream)
1:     {
1:         buffer = new byte[DEFAULT_BUFFER_SIZE];
1:         ddmCollectionLenStack = new long[MAX_MARKS_NESTING];
1:         
1:         this.inputStream = inputStream;
1:         initialize(null, null);
1:     }
1:     /**
1:      * Initialize values for this session, the reader is reused so we need to
1:      * set null and 0 values
1:      */
1:     protected void initialize(DRDAConnThread agent, DssTrace dssTrace)
1:       {
1:         this.agent = agent;
1:         this.utf8CcsidManager = new Utf8CcsidManager();
1:         if (agent != null)
1:         {
1:             inputStream = agent.getInputStream();
1:         }
1:         topDdmCollectionStack = EMPTY_STACK;
1:         svrcod = 0;
1:         pos = 0;
1:         count = 0;
1:         ddmScalarLen = 0;
1:         dssLength = 0;
1:         prevCorrelationID = DssConstants.CORRELATION_ID_UNKNOWN;
1:         dssCorrelationID = DssConstants.CORRELATION_ID_UNKNOWN;
1:         this.dssTrace = dssTrace;
1:         dssIsChainedWithDiffID = false;
1:         dssIsChainedWithSameID = false;
1:     }
1:     // Switch the ccsidManager to the UTF-8 instance
/////////////////////////////////////////////////////////////////////////
1:     protected boolean terminateChainOnErr()
1:     {
1:         return terminateChainOnErr;
1:     }
1:     /**
1:      * Next DSS has same correlator as current DSS
1:      *
1:      * @return true if next DSS has the same correlator as current DSS
1:      */
0:       protected boolean isChainedWithSameID()
1:       {
1:         return dssIsChainedWithSameID;
1:       }
1:     /**
1:      * Next DSS has different correlator than current DSS
1:      *
1:      * @return true if next DSS has a different correlator than current DSS
1:      */
0:       protected boolean isChainedWithDiffID()
1:       {
1:         return dssIsChainedWithDiffID;
1:       }
1:     /**
1:      * Length of current DDM object
1:      *
1:      * @return length of DDM object
1:      */
1:     protected long getDdmLength()
1:     {
1:         return ddmScalarLen;
1:     }
1:     /**
1:      * Is there more in this DDM object
1:      *
0:      * @return true if DDM length is > 0
1:      */
1:     protected boolean moreDdmData()
1:     {
1:         return ddmScalarLen > 0;
1:     }
1:     /**
1:      * Is there more in this DDS object
1:      *
0:      * @return true if DDS length is > 0
1:      */
1:     protected boolean moreDssData()
1:     {
1:         return dssLength > 0;
1:     }
1:     /** 
1:      * Is there more data in the buffer
1:      *
1:      * @return true if there is more data in the buffer
1:      */
1:     protected boolean moreData()
1:     {
1:         return (pos - count) > 0;
1:     }
1:     /**
1:      * Check for the command protocol
1:      *
1:      * @return true if this is a command; false otherwise
1:      *
0:      * @exception DRDAProtocolException if a protocol error is detected
1:      */
1:     protected boolean isCmd() throws DRDAProtocolException, java.io.UnsupportedEncodingException
1:     {
1:         ensureALayerDataInBuffer(4);
1:         String val = new String(buffer, 0, 4, NetworkServerControlImpl.DEFAULT_ENCODING);
1:         return NetworkServerControlImpl.isCmd(val);
1:     }
1:     /**
1:      * Read DSS header
1:      * DSS Header format is 
0:      *     2 bytes    - length
0:      *    1 byte    - 'D0'    - indicates DDM data
0:      *     1 byte    - DSS format 
0:      *        |---|---------|----------|
0:      *        | 0    |  flags  |  type    |
0:      *        |---|---------|----------|
0:      *        | 0 | 1  2  3 | 4 5 6 7  |
0:      *        |---|---------|----------|
0:      *        bit 0 - '0'
0:      *        bit 1 - '0' - unchained, '1' - chained
0:      *        bit 2 - '0'    - do not continue on error, '1' - continue on error
0:      *        bit 3 - '0' - next DSS has different correlator, '1' - next DSS has
0:      *                        same correlator
0:      *        type - 1 - Request DSS
0:      *             - 2 - Reply DSS
0:      *             - 3 - Object DSS
0:      *             - 4 - Communications DSS
0:      *             - 5 - Request DSS where no reply is expected
0:      *    2 bytes - request correlation id
1:      *
0:      * @exception DRDAProtocolException if a protocol error is detected
1:      */
1:     protected int readDssHeader () throws DRDAProtocolException
1:     {
1:         ensureALayerDataInBuffer (6);
1:         // read out the DSS length
1:         dssLength = ((buffer[pos] & 0xff) << 8) +
1:                     ((buffer[pos + 1] & 0xff) << 0);
1:         pos += 2;
1:         // check for the continuation bit and update length as needed.
1:         if ((dssLength & DssConstants.CONTINUATION_BIT) == 
1:                 DssConstants.CONTINUATION_BIT) 
1:         {
1:             dssLength = DssConstants.MAX_DSS_LENGTH;
1:             dssIsContinued = true;
1:         }
1:         else 
1:         {
1:             dssIsContinued = false;
1:         }
1:         if (dssLength < 6)
1:             agent.throwSyntaxrm(CodePoint.SYNERRCD_DSS_LESS_THAN_6,
1:                                DRDAProtocolException.NO_CODPNT_ARG);
1:         // If the GDS id is not valid, or
1:         // if the reply is not an RQSDSS nor
1:         // a OBJDSS, then throw an exception.
1:         if ((buffer[pos++] & 0xff) != DssConstants.DSS_ID)
1:             agent.throwSyntaxrm(CodePoint.SYNERRCD_CBYTE_NOT_D0,
1:                                DRDAProtocolException.NO_CODPNT_ARG);
1:         int gdsFormatter = buffer[pos++] & 0xff;
1:         
1:         if (((gdsFormatter & 0x0F) != DssConstants.DSSFMT_RQSDSS)
1:             &&((gdsFormatter & 0x0F) != DssConstants.DSSFMT_OBJDSS)) 
1:         {
1:             agent.throwSyntaxrm(CodePoint.SYNERRCD_FBYTE_NOT_SUPPORTED,
1:                                DRDAProtocolException.NO_CODPNT_ARG);
1:         }
1:         // Determine if the current DSS is chained with the
1:         // next DSS, with the same or different request ID.
1:         if ((gdsFormatter & DssConstants.DSSCHAIN) == DssConstants.DSSCHAIN) 
0:         {    // on indicates structure chained to next structure
1:             if ((gdsFormatter & DssConstants.DSSCHAIN_SAME_ID) 
1:                     == DssConstants.DSSCHAIN_SAME_ID) 
1:             {
1:                 dssIsChainedWithSameID = true;
1:                 dssIsChainedWithDiffID = false;
1:             }
1:             else 
1:             {
1:                 dssIsChainedWithSameID = false;
1:                 dssIsChainedWithDiffID = true;
1:             }
1:             if ((gdsFormatter & DssConstants.DSSCHAIN_ERROR_CONTINUE) 
1:                 == DssConstants.DSSCHAIN_ERROR_CONTINUE)
1:                 terminateChainOnErr = false;
1:             else
1:                 terminateChainOnErr = true;
1:         }
1:         else 
1:         {
1:             // chaining bit not b'1', make sure DSSFMT same id not b'1'
1:             if ((gdsFormatter & DssConstants.DSSCHAIN_SAME_ID) 
1:                     == DssConstants.DSSCHAIN_SAME_ID)    
1:             {  // Next DSS can not have same correlator
1:                 agent.throwSyntaxrm(CodePoint.SYNERRCD_CHAIN_OFF_SAME_NEXT_CORRELATOR,
1:                                    DRDAProtocolException.NO_CODPNT_ARG);
1:             }
1:             // chaining bit not b'1', make sure no error continuation
1:             if ((gdsFormatter & DssConstants.DSSCHAIN_ERROR_CONTINUE) 
1:                 == DssConstants.DSSCHAIN_ERROR_CONTINUE) 
1:             { // must be 'do not continue on error'
1:                 agent.throwSyntaxrm(CodePoint.SYNERRCD_CHAIN_OFF_ERROR_CONTINUE,
1:                                    DRDAProtocolException.NO_CODPNT_ARG);
1:             }
1:             dssIsChainedWithSameID = false;
1:             dssIsChainedWithDiffID = false;
1:         }
1:         dssCorrelationID =
1:             ((buffer[pos] & 0xff) << 8) +
1:             ((buffer[pos + 1] & 0xff) << 0);
1:         pos += 2;
1:         if (SanityManager.DEBUG)
1:             trace("dssLength = " + dssLength + " correlationID = " + dssCorrelationID);
1:         //check that correlationID is the same as previous
1:         if (prevCorrelationID != DssConstants.CORRELATION_ID_UNKNOWN && 
1:             dssCorrelationID != prevCorrelationID)
1:         {
1:             agent.throwSyntaxrm(CodePoint.SYNERRCD_CHAIN_OFF_ERROR_CONTINUE,
1:                                DRDAProtocolException.NO_CODPNT_ARG);
1:         }
1:         
1:         // set up previous correlation id to check that next DSS is correctly
1:         // formatted
1:         if (dssIsChainedWithSameID)
1:             prevCorrelationID = dssCorrelationID;
1:         else
1:             prevCorrelationID = DssConstants.CORRELATION_ID_UNKNOWN;
1:         dssLength -= 6;
1:         return dssCorrelationID;
1:     }
1:     /**
1:      * Read Reply DSS
1:      * This is used in testing the protocol.  We shouldn't see a reply
1:      * DSS when we are servicing DRDA commands
1:      *
0:      * @exception DRDAProtocolException if a protocol error is detected
1:      */
1:     protected void readReplyDss() throws DRDAProtocolException
1:     {
1:         ensureALayerDataInBuffer (6);
1:         // read out the DSS length
1:         dssLength = ((buffer[pos++] & 0xff) << 8) +
1:                     ((buffer[pos++] & 0xff) << 0);
1:         // check for the continuation bit and update length as needed.
1:         if ((dssLength & DssConstants.CONTINUATION_BIT) == 
1:                 DssConstants.CONTINUATION_BIT) 
1:         {
1:             dssLength = DssConstants.MAX_DSS_LENGTH;
1:             dssIsContinued = true;
1:         }
1:         else 
1:         {
1:             dssIsContinued = false;
1:         }
1:         if (dssLength < 6)
1:             agent.throwSyntaxrm(CodePoint.SYNERRCD_DSS_LESS_THAN_6,
1:                                DRDAProtocolException.NO_CODPNT_ARG);
1:         // If the GDS id is not valid, throw exception
1:         if ((buffer[pos++] & 0xff) != DssConstants.DSS_ID)
1:             agent.throwSyntaxrm(CodePoint.SYNERRCD_CBYTE_NOT_D0,
1:                                DRDAProtocolException.NO_CODPNT_ARG);
1:         int gdsFormatter = buffer[pos++] & 0xff;
1:         
1:         // Determine if the current DSS is chained with the
1:         // next DSS, with the same or different request ID.
1:         if ((gdsFormatter & DssConstants.DSSCHAIN) == DssConstants.DSSCHAIN) 
0:         {    // on indicates structure chained to next structure
1:             if ((gdsFormatter & DssConstants.DSSCHAIN_SAME_ID) 
1:                     == DssConstants.DSSCHAIN_SAME_ID) 
1:             {
1:                 dssIsChainedWithSameID = true;
1:                 dssIsChainedWithDiffID = false;
1:             }
1:             else 
1:             {
1:                 dssIsChainedWithSameID = false;
1:                 dssIsChainedWithDiffID = true;
1:             }
1:         }
1:         else 
1:         {
1:             dssIsChainedWithSameID = false;
1:             dssIsChainedWithDiffID = false;
1:         }
1:         dssCorrelationID =
1:             ((buffer[pos++] & 0xff) << 8) +
1:             ((buffer[pos++] & 0xff) << 0);
1:         if (SanityManager.DEBUG)                    
1:             trace("dssLength = " + dssLength + " correlationID = " + dssCorrelationID);
1:         dssLength -= 6;
1:     }
1:     /**
1:      * Read the DDM Length and CodePoint
1:      *
1:      * @return - returns codepoint
1:      *
0:      * @exception DRDAProtocolException if a protocol error is detected
1:      */
1:     protected int readLengthAndCodePoint( boolean isLayerBStreamingPossible ) 
1:     {
1:         ensureBLayerDataInBuffer (4, NO_ADJUST_LENGTHS);
1:         ddmScalarLen = readCodePoint();
1:         int codePoint = readCodePoint();
1:         
1:         if (SanityManager.DEBUG)
1:             trace("length = "+ ddmScalarLen + " codepoint = " + java.lang.Integer.toHexString(codePoint));
1:         // SYNERRCD 0x0D - Object code point index not supported.
1:         // the object codepoint index will not be checked here since
1:         // the parse methods will catch any incorrect/unexpected codepoint values
1:         // and report them as unsupported objects or parameters.
1:         // Check if this DDM has extended length field
1:         if ((ddmScalarLen & DssConstants.CONTINUATION_BIT) == DssConstants.CONTINUATION_BIT) 
1:         {
1:             int numberOfExtendedLenBytes = ((int)ddmScalarLen - 
1:                     DssConstants.CONTINUATION_BIT) - 4;
1:             int adjustSize = 0;
1:             ensureBLayerDataInBuffer (numberOfExtendedLenBytes, NO_ADJUST_LENGTHS);
1:             switch (numberOfExtendedLenBytes) {
1:             case 8:
1:                  ddmScalarLen =
0:                     ((buffer[pos++] & 0xFFL) << 56) +
0:                     ((buffer[pos++] & 0xFFL) << 48) +
0:                     ((buffer[pos++] & 0xFFL) << 40) +
0:                     ((buffer[pos++] & 0xFFL) << 32) +
0:                     ((buffer[pos++] & 0xFFL) << 24) +
0:                     ((buffer[pos++] & 0xFFL) << 16) +
0:                     ((buffer[pos++] & 0xFFL) << 8) +
0:                     ((buffer[pos++] & 0xFFL) << 0);
1:                 adjustSize = 12;
1:                 break;
1:             case 6:
1:                 ddmScalarLen =
0:                     ((buffer[pos++] & 0xFFL) << 40) +
0:                     ((buffer[pos++] & 0xFFL) << 32) +
0:                     ((buffer[pos++] & 0xFFL) << 24) +
0:                     ((buffer[pos++] & 0xFFL) << 16) +
0:                     ((buffer[pos++] & 0xFFL) << 8) +
0:                     ((buffer[pos++] & 0xFFL) << 0);
1:                 adjustSize = 10;
1:                 break;
1:             case 4:
1:                 ddmScalarLen =
0:                     ((buffer[pos++] & 0xFFL) << 24) +
0:                     ((buffer[pos++] & 0xFFL) << 16) +
0:                     ((buffer[pos++] & 0xFFL) << 8) +
0:                     ((buffer[pos++] & 0xFFL) << 0);
1:                 adjustSize = 8;
1:                 break;
/////////////////////////////////////////////////////////////////////////
1:             default:
1:                 agent.throwSyntaxrm(CodePoint.SYNERRCD_INCORRECT_EXTENDED_LEN,
1:                                DRDAProtocolException.NO_CODPNT_ARG);
1:         }
0:             // adjust the lengths here.    this is a special case since the
1:             // extended length bytes do not include their own length.
1:             for (int i = 0; i <= topDdmCollectionStack; i++) {
1:                 ddmCollectionLenStack[i] -= adjustSize;
1:             }
1:             dssLength -= adjustSize;
1:         }
1:         else {
1:             if (ddmScalarLen < 4)
1:                 agent.throwSyntaxrm(CodePoint.SYNERRCD_OBJ_LEN_LESS_THAN_4,
1:                                    DRDAProtocolException.NO_CODPNT_ARG);
1:             adjustLengths (4);
1:         }
1:         return codePoint;
1:     }
1:     /**
1:      * Read the CodePoint
1:      *
1:      * @return - returns codepoint
1:      */
1:     protected int readCodePoint()
1:     {
1:         return( ((buffer[pos++] & 0xff) << 8) +
1:           ((buffer[pos++] & 0xff) << 0));
1:     }
1:     /**
1:      * Push DDM Length on to collection stack
1:      */
1:     protected void markCollection()
1:     {
1:         ddmCollectionLenStack[++topDdmCollectionStack] = ddmScalarLen;
1:         ddmScalarLen = 0;
1:     }
1:     /**
0:      *     Get the next CodePoint from a collection
0:      *     @return    NO_CODEPOINT if collection stack is empty or remaining length is
0:      *        0; otherwise,  read length and code point
1:      *
0:      * @exception DRDAProtocolException if a protocol error is detected
1:      */
1:     protected int getCodePoint() throws DRDAProtocolException
1:     {
1:         if (topDdmCollectionStack == EMPTY_STACK) 
1:         {
1:             return NO_CODEPOINT;
1:         }
1:         else 
1:         {
1:             // if the collecion is exhausted then return NO_CODEPOINT
1:             if (ddmCollectionLenStack[topDdmCollectionStack] == 0) 
1:                 // done with this collection so remove it's length from the stack
1:                 ddmCollectionLenStack[topDdmCollectionStack--] = 0;
1:                 return NO_CODEPOINT;
1:             }
1:             else {
1:                 return readLengthAndCodePoint( false );
1:             }
1:         }
1:     }
1:     /**
1:      * Get the next CodePoint from a collection and check that it matches the specified
0:      *     CodePoint
0:      * @param    codePointCheck    - codePoint to check against
0:      * @return    codePoint
1:      *
0:      * @exception DRDAProtocolException if a protocol error is detected
1:      */
1:     protected int getCodePoint(int codePointCheck) throws DRDAProtocolException
1:     {
1:         int codePoint = getCodePoint();
1:         if (codePoint != codePointCheck)
1:             agent.missingCodePoint(codePoint);
1:         return codePoint;
1:     }
1:     /**
1:      * The following routines read different types from the input stream
1:      * Data can be in network order or platform order depending on whether the
1:      * data is part of the protocol or data being received
1:      * The platform is determined by EXCSAT protocol
1:      */
1:     /**
1:      * Read byte value
0:      * @return    value
1:      *
0:      * @exception DRDAProtocolException if a protocol error is detected
1:      */
1:     protected byte readByte () throws DRDAProtocolException
1:     {
1:         ensureBLayerDataInBuffer (1, ADJUST_LENGTHS);
1:         return buffer[pos++];
1:     }
1:     /**
1:      * Read byte value and mask out high order bytes before returning
1:      * @return value
1:      */
1:     protected int readUnsignedByte () throws DRDAProtocolException
1:     {
1:         ensureBLayerDataInBuffer (1, ADJUST_LENGTHS);
1:         return (int ) (buffer[pos++] & 0xff);
1:     }
1:     /**
1:      * Read network short value
0:      * @return    value
1:      *
0:      * @exception DRDAProtocolException if a protocol error is detected
1:      */
1:     protected int readNetworkShort () throws DRDAProtocolException
1:     {
1:         ensureBLayerDataInBuffer (2, ADJUST_LENGTHS);
1:         return ((buffer[pos++] & 0xff) << 8) +
1:           ((buffer[pos++] & 0xff) << 0);
1:     }
1:     /**
1:      * Read signed network short value
0:      * @return    value
1:      *
0:      * @exception DRDAProtocolException if a protocol error is detected
1:      */
1:     protected int readSignedNetworkShort () throws DRDAProtocolException
1:     {
1:         ensureBLayerDataInBuffer (2, ADJUST_LENGTHS);
1:         return (short)(((buffer[pos++] & 0xff) << 8) +
1:           ((buffer[pos++] & 0xff) << 0));
1:     }
1:     /**
1:      * Read platform short value
0:      * @return    value
1:      *
0:      * @exception DRDAProtocolException if a protocol error is detected
1:      */
1:     protected short readShort (int byteOrder) throws DRDAProtocolException
1:     {
1:         ensureBLayerDataInBuffer (2, ADJUST_LENGTHS);
1:         short s = SignedBinary.getShort (buffer, pos, byteOrder);
1:         pos += 2;
1:         return s;
1:     }
1:     /**
1:      * Read network int value
0:      * @return    value
1:      *
0:      * @exception DRDAProtocolException if a protocol error is detected
1:      */
1:     protected int readNetworkInt () throws DRDAProtocolException
1:     {
1:         ensureBLayerDataInBuffer (4, ADJUST_LENGTHS);
1:         return ((buffer[pos++] & 0xff) << 24) +
1:                ((buffer[pos++] & 0xff) << 16) +
1:                ((buffer[pos++] & 0xff) << 8) +
1:                ((buffer[pos++] & 0xff) << 0);
1:     }
1:     /**
1:      * Read platform int value
0:      * @return    value
1:      *
0:      * @exception DRDAProtocolException if a protocol error is detected
1:      */
1:     protected int readInt (int byteOrder) throws DRDAProtocolException
1:     {
1:         ensureBLayerDataInBuffer (4, ADJUST_LENGTHS);
1:         int i = SignedBinary.getInt (buffer, pos, byteOrder);
1:         pos += 4;
1:         return i;
1:     }
1:     /**
1:      * Read network long value
0:      * @return    value
1:      *
0:      * @exception DRDAProtocolException if a protocol error is detected
1:      */
1:     protected long readNetworkLong () throws DRDAProtocolException
1:     {
1:         ensureBLayerDataInBuffer (8, ADJUST_LENGTHS);
1:         return ((buffer[pos++] & 0xffL) << 56) +
1:                ((buffer[pos++] & 0xffL) << 48) +
1:                ((buffer[pos++] & 0xffL) << 40) +
1:                ((buffer[pos++] & 0xffL) << 32) +
1:                ((buffer[pos++] & 0xffL) << 24) +
1:                ((buffer[pos++] & 0xffL) << 16) +
1:                ((buffer[pos++] & 0xffL) << 8) +
1:                ((buffer[pos++] & 0xffL) << 0);
1:     }
1:     
1:     /**
1:      * Read network six byte value and put it in a long v
0:      * @return    value
1:      *
0:      * @exception DRDAProtocolException if a protocol error is detected
1:      */
1:     protected long readNetworkSixByteLong() throws DRDAProtocolException
1:     {
1:         ensureBLayerDataInBuffer (6, ADJUST_LENGTHS);
1:         return (
1:                 ((buffer[pos++] & 0xffL) << 40) +
1:                ((buffer[pos++] & 0xffL) << 32) +
1:                ((buffer[pos++] & 0xffL) << 24) +
1:                ((buffer[pos++] & 0xffL) << 16) +
1:                ((buffer[pos++] & 0xffL) << 8) +
1:                ((buffer[pos++] & 0xffL) << 0));
1:     }
1:     /**
1:      * Read platform long value
0:      * @return    value
1:      *
0:      * @exception DRDAProtocolException if a protocol error is detected
1:      */
1:     protected long readLong (int byteOrder) throws DRDAProtocolException
1:     {
1:         ensureBLayerDataInBuffer (8, ADJUST_LENGTHS);
1:         long l = SignedBinary.getLong (buffer, pos, byteOrder);
1:         pos += 8;
1:         return l;
1:     }
1:     /**
1:      * Read platform float value
0:      * @return    value
1:      *
0:      * @exception DRDAProtocolException if a protocol error is detected
1:      */
1:     protected float readFloat(int byteOrder) throws DRDAProtocolException
1:     {
1:         return Float.intBitsToFloat(readInt(byteOrder));
1:     }
1:     /**
1:      * Read platform double value
0:      * @return    value
1:      *
0:      * @exception DRDAProtocolException if a protocol error is detected
1:      */
1:     protected double readDouble(int byteOrder) throws DRDAProtocolException
1:     {
1:         return Double.longBitsToDouble(readLong(byteOrder));
1:     }
1:     /**
1:      * Read a BigDecimal value
0:      * @param    precision of the BigDecimal
0:      * @param    scale of the BigDecimal
0:      * @return    value
1:      *
0:      * @exception DRDAProtocolException if a protocol error is detected
1:      */
1:     protected BigDecimal readBigDecimal(int precision, int scale) throws DRDAProtocolException
1:       ensureBLayerDataInBuffer (length, ADJUST_LENGTHS);
/////////////////////////////////////////////////////////////////////////
1:         pos += length;
/////////////////////////////////////////////////////////////////////////
1:         pos += length;
/////////////////////////////////////////////////////////////////////////
1:         pos += length;
/////////////////////////////////////////////////////////////////////////
1:         pos += length;
1:         pos += length;
1:     /**
1:      * Creates an InputStream which can stream EXTDTA objects.
1:      * The InputStream uses this DDMReader to read data from network. The 
1:      * DDMReader should not be used before all data in the stream has been read.
1:      * @param checkNullability used to check if the stream is null. If it is 
1:      * null, this method returns null
1:      * @return EXTDTAReaderInputStream object which can be passed to prepared
1:      *         statement as a binary stream.
1:      * @exception DRDAProtocolException standard DRDA protocol exception
1:      */
1:     EXTDTAReaderInputStream getEXTDTAReaderInputStream
1:         (final boolean checkNullability)
1:         throws DRDAProtocolException
1:     {
1:         if (checkNullability && isEXTDTANull()) {
1:             return null;
/////////////////////////////////////////////////////////////////////////
1:     }
1:      * This method is used by EXTDTAReaderInputStream to read the first chunk 
1:      * of data.
1:      * @exception DRDAProtocolException standard DRDA protocol exception
1:      */
1:     ByteArrayInputStream readLOBInitStream() 
1:         throws DRDAProtocolException
1:     {
1:         
1:     }
1:     
1:     /**
1:      * This method is used by EXTDTAReaderInputStream to read the first chunk 
1:      * of data.
1:      * @param desiredLength the desired length of chunk. This parameter is ignored when layerB Streaming is doing.
1:      * @exception DRDAProtocolException standard DRDA protocol exception
1:      */
1:     ByteArrayInputStream readLOBInitStream(final long desiredLength) 
1:         throws DRDAProtocolException
1:     {
1:         return readLOBChunk(false, desiredLength);
1:     }
1:     
1:      * This method is used by EXTDTAReaderInputStream to read the next chunk 
1:      * of data.
1:      * @exception IOException IOException
1:      */
1:     ByteArrayInputStream readLOBContinuationStream ()
1:         throws IOException
1:     {        
1:     }
1:     /**
1:      * This method is used by EXTDTAReaderInputStream to read the next chunk 
1:      * of data.
1:      * @param desiredLength the desired length of chunk. This parameter is ignored when layerB Streaming is doing.
1:      * @exception IOException IOException
1:      */
1:     ByteArrayInputStream readLOBContinuationStream (final long desiredLength)
1:         throws IOException
1:     {        
1:         try {
1:             return readLOBChunk(true, desiredLength);
1:         } catch (DRDAProtocolException e) {
0:             e.printStackTrace(agent.getServer().logWriter);
1:             throw new IOException(e.getMessage());
1:         }
1:     }
1:     /**
1:      * This method is used by EXTDTAReaderInputStream to read the next chunk 
1:      * of data.
1:      * @param readHeader set to true if the dss continuation should be read
1:      * @param desiredLength the desired length of chunk. This parameter is ignored when layerB Streaming is doing.
1:      * @exception DRDAProtocolException standard DRDA protocol exception
1:      */
1:     private ByteArrayInputStream readLOBChunk
1:         (final boolean readHeader, final long desiredLength)
1:         throws DRDAProtocolException
1:     {        
0:         if (readHeader) {            
1:             readDSSContinuationHeader();
1:         }
1:         
1:         
1:         // read the segment
1:         ensureALayerDataInBuffer (copySize);
/////////////////////////////////////////////////////////////////////////
1:         
1:         // Create ByteArrayInputStream on top of buffer. 
1:         // This will not make a copy of the buffer.
1:         ByteArrayInputStream bais = 
1:             new ByteArrayInputStream(buffer, pos, copySize);
1:         pos += copySize;
1:         
1:         return bais;
1:     }
1:     byte[] getExtData (long desiredLength, boolean checkNullability) throws DRDAProtocolException
/////////////////////////////////////////////////////////////////////////
1:     
1:     if (desiredLength != -1) {
1:     }
1:     else {
1:         // If we aren't given a  length get the whole thing.
1:         desiredLength = MAX_EXTDTA_SIZE;
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
1:     copySize = (int) Math.min(dssLength,desiredLength); //note: has already been adjusted for headers
1:     //copySize--;
/////////////////////////////////////////////////////////////////////////
1:       desiredLength -= copySize;
1:       copySize = (int) Math.min(dssLength,desiredLength); //note: has already been adjusted for headers
/////////////////////////////////////////////////////////////////////////
1:     private void readDSSContinuationHeader () throws DRDAProtocolException
/////////////////////////////////////////////////////////////////////////
1:         agent.throwSyntaxrm(CodePoint.SYNERRCD_DSS_CONT_LESS_OR_EQUAL_2,
1:                                DRDAProtocolException.NO_CODPNT_ARG);
/////////////////////////////////////////////////////////////////////////
0:     * @param buffer            buffer to read from
0:     * @param offset            offset in the buffer
1:     * @param startNybble        start nybble
1:     * @param numberOfNybbles    number of nybbles
0:     * @return    an int value
/////////////////////////////////////////////////////////////////////////
1:      * @param buffer        buffer to read from
1:      * @param offset        offset in the buffer
0:      * @param startNybble        start nybble
0:      * @param numberOfNybbles    number of nybbles
0:      * @return    an long value
/////////////////////////////////////////////////////////////////////////
1:        return value;
1:     }
0:      * @param    input value segments
0:      * @return    array of int magnitudes
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Read encrypted string
1:      * @param   decryptM  decryption manager
1:      * @param   securityMechanism security mechanism
1:      * @param   initVector   initialization vector for cipher
1:      * @param   sourcePublicKey  public key (as in Deffie-Hellman algorithm)
1:      *                           from source (encryptor)
1:      * @return  decrypted string
1:      *
0:      * @exception DRDAProtocolException if a protocol error is detected
1:      */
1:     protected String readEncryptedString (DecryptionManager decryptM, int securityMechanism,
1:                                          byte[] initVector, byte[] sourcePublicKey)
1:             throws DRDAProtocolException, java.sql.SQLException
1:     {
1:         byte[] cipherText = readBytes();
1:         byte[] plainText = null;
1:         plainText = decryptM.decryptData(cipherText, securityMechanism, initVector,
1:                                              sourcePublicKey);
1:         if (plainText == null)
1:             return null;
1:         else
1:             return ccsidManager.convertToJavaString(plainText);
1:     }
1:     /**
1:      * Read string value
1:      * Strings in DRDA protocol are encoded in EBCDIC by default so we
1:      * need to convert to UCS2
1:      * @param length  - length of string to read
1:      * @return value
1:      *
0:      * @exception DRDAProtocolException if a protocol error is detected
1:      */
1:     protected String readString (int length) throws DRDAProtocolException
1:     {
1:         ensureBLayerDataInBuffer (length, ADJUST_LENGTHS);
1:         String result = ccsidManager.convertToJavaString(buffer, pos, length);
1:         pos += length;
1:         return result;
1:     }
1:     /**
1:      * Read string value into a <code>DRDAString</code> object.
1:      *
1:      * @param dst  destination for the read string
1:      * @param size size (in bytes) of string to read
1:      * @param unpad if true, remove padding (trailing spaces)
1:      *
1:      * @exception DRDAProtocolException
1:      */
1:     protected void readString(DRDAString dst, int size, boolean unpad)
1:         throws DRDAProtocolException
1:     {
1:         ensureBLayerDataInBuffer(size, ADJUST_LENGTHS);
1:         int startPos = pos;
1:         pos += size;
1:         if (unpad) {
1:             while ((size > 0) &&
1:                    (buffer[startPos + size - 1] == ccsidManager.space)) {
1:                 --size;
1:             }
1:         }
1:         dst.setBytes(buffer, startPos, size);
1:     }
1:     /**
1:      * Read encoded string value
1:      * @param length  - length of string to read
1:      * @return value
1:      *
0:      * @exception DRDAProtocolException if a protocol error is detected
1:      */
1:     protected String readString (int length, String encoding) 
1:         throws DRDAProtocolException
1:     {
1:         ensureBLayerDataInBuffer (length, ADJUST_LENGTHS);
1:         String s = null;
1:         try {
1:           s = new String (buffer, pos, length, encoding);
1:         }
1:         catch (java.io.UnsupportedEncodingException e) {
1:             agent.agentError("UnsupportedEncodingException in readString, encoding = " 
1:                     + encoding);
0:             e.printStackTrace(agent.getServer().logWriter);
1:         }
1:         
1:         pos += length;
1:         return s;
1:     }
1:     /**
1:      * Read specified length of string value in DDM data with default encoding
1:      * @param length  - length of string to read
1:      * @return value
1:      *
0:      * @exception DRDAProtocolException if a protocol error is detected
1:      */
1:     protected String readStringData(int length)
1:         throws DRDAProtocolException
1:     {
1:         return readString(length, NetworkServerControlImpl.DEFAULT_ENCODING);
1:     }
1:     /**
1:      * Read length delimited string value in DDM data with default encoding
1:      * @return value
1:      *
0:      * @exception DRDAProtocolException if a protocol error is detected
1:      */
1:     protected String readLDStringData(String encoding)
1:         throws DRDAProtocolException
1:     {
1:         int length = readNetworkShort();
1:         return readString(length, encoding);
1:     }
1:     /**
1:      * Read string value
1:      *
0:      * @exception DRDAProtocolException if a protocol error is detected
1:      */
1:     protected String readString () throws DRDAProtocolException
1:     {
1:         return readString((int)ddmScalarLen);
1:     }
1:     /**
1:      * Read byte string value
1:      * @param length  - length of string to read
1:      * @return byte array
1:      *
0:      * @exception DRDAProtocolException if a protocol error is detected
1:      */
1:     protected byte[] readBytes (int length) throws DRDAProtocolException
1:     {
1:         byte[] b;
0:         if (length < DssConstants.MAX_DSS_LENGTH)
1:         {
1:             ensureBLayerDataInBuffer (length, ADJUST_LENGTHS);
1:             b = new byte[length];
1:             System.arraycopy(buffer,pos,b,0,length);
1:             pos +=length;
1:         }
1:         else
1:             b = getExtData(length,false);
1:         return b;
1:     }
1:     
1:     /**
1:      * Read byte string value
1:      * @return byte array
1:      *
0:      * @exception DRDAProtocolException if a protocol error is detected
1:      */
1:     protected byte[] readBytes () throws DRDAProtocolException
1:     {
1:         return readBytes((int)ddmScalarLen);
1:     }
1:     /**
1:      * Skip byte string value
1:      * @param length  - length of string to skip
1:      *
0:      * @exception DRDAProtocolException if a protocol error is detected
1:      */
1:     protected void skipBytes (int length) throws DRDAProtocolException
1:     {
1:         ensureBLayerDataInBuffer (length, ADJUST_LENGTHS);
1:         pos += length;
1:     }
1:     /**
1:      * Skip byte string value
1:      *
1:      * @exception DRDAProtocolException
1:      */
1:     protected void skipBytes () throws DRDAProtocolException
1:     {
1:         skipBytes((int)ddmScalarLen);
1:     }
1:     /**
1:      * Skip remaining DSS
1:      *
1:      * @exception DRDAProtocolException
1:      */
1:     protected void skipDss() throws DRDAProtocolException
1:     {
1:         while (dssIsContinued)
1:         {
1:             skipBytes((int)dssLength);
1:             readDSSContinuationHeader();
1:         }
1:         skipBytes((int)dssLength);
1:         topDdmCollectionStack = EMPTY_STACK;
1:         ddmScalarLen = 0;
1:         dssLength = 0;
1:     }
1:     protected void clearBuffer() throws DRDAProtocolException
1:     {
1:         skipBytes(java.lang.Math.min(dssLength, count - pos));
0:         dssIsChainedWithSameID = false;
0:         dssIsChainedWithDiffID = false;
1:     }
1:     /**
1:      * Convert EBCDIC byte array to unicode string
1:      *
0:      * @param     buf    - byte array
1:      * @return string
1:      */
1:     protected String convertBytes(byte[] buf)
1:     {
1:         return ccsidManager.convertToJavaString (buf, 0, buf.length);
1:     }
1:     // Private methods
1:     /**
1:      * Adjust remaining length
1:      *
1:      * @param length - adjustment length
1:      */
1:     private void adjustLengths(int length)
1:     {
1:         ddmScalarLen -= length;
1:         for (int i = 0; i <= topDdmCollectionStack; i++) {
1:           ddmCollectionLenStack[i] -= length;
1:         }
1:         dssLength -= length;
1:     }
1:     /********************************************************************/
1:     /*   NetworkServerControl  command protocol reading routines        
1:      */
1:     /********************************************************************/
1:     /**
1:      * Read string value
1:      * @param length  - length of string to read
1:      * @return value
1:      *
0:      * @exception DRDAProtocolException if a protocol error is detected
1:      */
1:     protected String readCmdString (int length) throws DRDAProtocolException, java.io.UnsupportedEncodingException
1:     {
1:         if (length == 0)
1:             return null;
1:         ensureBLayerDataInBuffer (length, ADJUST_LENGTHS);
1:         String result = new String (buffer, pos, length,
1:                                         NetworkServerControlImpl.DEFAULT_ENCODING);
1:         pos += length;
1:         return result;
1:     }
1:     /**
1:      * Read string value
1:      * @return value
1:      *
0:      * @exception DRDAProtocolException if a protocol error is detected
1:      */
1:     protected String readCmdString () throws DRDAProtocolException, java.io.UnsupportedEncodingException
1:     {
1:         int length = readNetworkShort();
1:         return readCmdString(length);
1:         
1:     }
1:     /**************************************************************************/
1:     /*   Private methods
1:     /**************************************************************************/
1:     /**
1:      * Make sure a certain amount of Layer A data is in the buffer.
1:      * The data will be in the buffer after this method is called.
1:      *
1:      * @param desiredDataSize - amount of data we need
1:      *
0:      * @exception    DRDAProtocolException
1:      */
1:     private void ensureALayerDataInBuffer (int desiredDataSize) 
1:         throws DRDAProtocolException
1:     {
1:         // calulate the the number of bytes in the buffer.
1:         int avail = count - pos;
1:         // read more bytes off the network if the data is not in the buffer already.
1:         if (avail < desiredDataSize) 
1:         {
1:           fill (desiredDataSize - avail);
1:         }
1:     }
1:     /**
1:      * Make sure a certain amount of Layer B data is in the buffer.
1:      * The data will be in the buffer after this method is called.
1:      *
1:      * @param desiredDataSize - amount of data we need
0:      * @param adjustLen    - whether to adjust the remaining lengths
1:      *
0:      * @exception DRDAProtocolException if a protocol error is detected
1:      */
1:     private void ensureBLayerDataInBuffer (int desiredDataSize, boolean adjustLen) 
1:         throws DRDAProtocolException
1:     {
/////////////////////////////////////////////////////////////////////////
1:         if (adjustLen)
1:             adjustLengths(desiredDataSize);
1:     }
1:     /**
1:      * Compress B Layer data if extended total length is used
1:      * by removing the continuation headers
1:      *
1:      * @param continueDssHeaderCount - amount of data we need
1:      *
0:      * @exception    throws DRDAProtocolException
1:      */
1:     private void compressBLayerData (int continueDssHeaderCount) 
1:         throws DRDAProtocolException
1:     {
1:         
1:         // jump to the last continuation header.
0:         int tempPos = 0;
1:         for (int i = 0; i < continueDssHeaderCount; i++) 
1:         {
1:             // the first may be less than the size of a full DSS
1:             if (i == 0) 
1:             {
1:                 // only jump by the number of bytes remaining in the current DSS
0:                 tempPos = pos + dssLength;
1:             }
1:             else 
1:             {
1:                 // all other jumps are for a full continued DSS
0:                 tempPos += DssConstants.MAX_DSS_LENGTH;
1:             }
1:         }
1:         // for each of the DSS headers to remove,
1:         // read out the continuation header and increment the DSS length by the
0:         // size of the continuation bytes,    then shift the continuation data as needed.
1:         int shiftSize = 0;
1:         int bytesToShift = 0;
1:         int continueHeaderLength = 0;
1:         int newdssLength = 0;
1:         for (int i = 0; i < continueDssHeaderCount; i++) 
1:         {
0:             continueHeaderLength = ((buffer[tempPos] & 0xff) << 8) +
0:                 ((buffer[tempPos + 1] & 0xff) << 0);
1:             if (i == 0) 
1:             {
1:                 // if this is the last one (farthest down stream and first to strip out)
1:                 if ((continueHeaderLength & DssConstants.CONTINUATION_BIT) 
1:                         == DssConstants.CONTINUATION_BIT)
1:                 {
1:                   // the last DSS header is again continued
1:                   continueHeaderLength = DssConstants.MAX_DSS_LENGTH;
1:                   dssIsContinued = true;
1:                 }
1:                 else 
1:                 {
1:                   // the last DSS header was not contiued so update continue state flag
1:                   dssIsContinued = false;
1:                 }
1:                 // the very first shift size is 2
1:                 shiftSize = 2;
1:             }
1:             else 
1:             {
1:                 // already removed the last header so make sure the chaining flag is on
1:                 if ((continueHeaderLength & DssConstants.CONTINUATION_BIT) == 
1:                         DssConstants.CONTINUATION_BIT)
1:                 {
1:                   continueHeaderLength = DssConstants.MAX_DSS_LENGTH;
1:                 }
1:                 else 
1:                 {
1:                   // this is a syntax error but not really certain which one.
1:                   // for now pick 0x02 which is DSS header Length does not 
1:                   // match the number
1:                     // of bytes of data found.
1:                     agent.throwSyntaxrm(CodePoint.SYNERRCD_DSS_LENGTH_BYTE_NUMBER_MISMATCH,
1:                                        DRDAProtocolException.NO_CODPNT_ARG);
1:                 }
1:                 // increase the shift size by 2
1:                 shiftSize += 2;
1:             }
1:             // it is a syntax error if the DSS continuation is less 
1:             // than or equal to two
1:             if (continueHeaderLength <= 2) 
1:             {
1:                 agent.throwSyntaxrm(CodePoint.SYNERRCD_DSS_CONT_LESS_OR_EQUAL_2,
1:                                DRDAProtocolException.NO_CODPNT_ARG);
1:             }
0:             newdssLength += (continueHeaderLength-2);
1:             // calculate the number of bytes to shift
0:             if (i != (continueDssHeaderCount - 1))
1:                 bytesToShift = DssConstants.MAX_DSS_LENGTH;
1:             else
1:                 bytesToShift = dssLength;
0:             tempPos -= (bytesToShift - 2);
0:             System.arraycopy(buffer, tempPos - shiftSize, buffer, tempPos,
0:                              bytesToShift);
1:         }
1:         // reposition the start of the data after the final DSS shift.
0:         pos = tempPos;
0:         dssLength += newdssLength;
1:     }
1:     /**
1:      * Methods to manage the data buffer.
1:      * Methods orginally from JCC
1:      * RESOLVE: need to check if this is the best performing way of doing this
1:      */
1:     /**
1:      * This is a helper method which shifts the buffered bytes from
1:      * wherever they are in the current buffer to the beginning of
1:      * different buffer (note these buffers could be the same).
1:      * State information is updated as needed after the shift.
1:      * @param destinationBuffer - buffer to shift data to
1:      */
1:     private void shiftBuffer (byte[] destinationBuffer)
1:     {
1:         // calculate the size of the data in the current buffer.
1:         int sz = count - pos;
1:         if (SanityManager.DEBUG) {
1:             if ((sz < 0 || pos < 0) )
1:             {
1:                 SanityManager.THROWASSERT(
1:                           "Unexpected data size or position. sz=" + sz + 
1:                           " count=" + count +" pos=" + pos);
1:             }
1:         }
1:         
1:         // copy this data to the new buffer startsing at position 0.
1:         System.arraycopy (buffer, pos, destinationBuffer, 0, sz);
1:         // update the state information for data in the new buffer.
1:         pos = 0;
1:         count = sz;
1:         // replace the old buffer with the new buffer.
1:         buffer = destinationBuffer;
1:     }
1:     /**
1:      * This method makes sure there is enough room in the buffer
1:      * for a certain number of bytes.  This method will allocate
1:      * a new buffer if needed and shift the bytes in the current buffer
1:      * to make ensure space is available for a fill.  Right now
1:      * this method will shift bytes as needed to make sure there is
1:      * as much room as possible in the buffer before trying to
1:      * do the read.  The idea is to try to have space to get as much data as possible
1:      * if we need to do a read on the socket's stream.
1:      *
1:      * @param desiredSpace - amount of data we need
1:      */
1:     private void ensureSpaceInBufferForFill (int desiredSpace)
1:     {
1:         // calculate the total unused space in the buffer.
1:         // this includes any space at the end of the buffer and any free
1:         // space at the beginning resulting from bytes already read.
1:         int currentAvailableSpace = (buffer.length - count) + pos;
1:         // check to see if there is enough free space.
1:         if (currentAvailableSpace < desiredSpace) {
1:             // there is not enough free space so we need more storage.
1:             // we are going to double the buffer unless that happens to still be 
1:             // too small. If more than double the buffer is needed, 
1:             // use the smallest amount over this as possible.
1:             int doubleBufferSize = (2 * buffer.length);
1:             int minumNewBufferSize = (desiredSpace - currentAvailableSpace) + 
1:                 buffer.length;
1:             int newsz = minumNewBufferSize <= doubleBufferSize ? 
1:                 doubleBufferSize : minumNewBufferSize;
1:             byte[] newBuffer = new byte[newsz];
1:             // shift everything from the old buffer to the new buffer
1:             shiftBuffer (newBuffer);
1:         }
1:         else {
1:             // there is enough free space in the buffer but let's make sure
1:             // it is all at the end.
1:             // this is also important because if we are going to do a read, 
1:             // it would be nice
1:             // to get as much data as possible and making room at the end 
1:             // if the buffer helps to ensure this.
1:             if (pos != 0) {
1:                 shiftBuffer (buffer);
1:             }
1:         }
1:     }
1:     /**
1:      * This method will attempt to read a minimum number of bytes
0:      * from the underlying stream.    This method will keep trying to
1:      * read bytes until it has obtained at least the minimum number.
1:      * @param minimumBytesNeeded - minimum required bytes
1:      *
0:      * @exception DRDAProtocolException if a protocol error is detected
1:      */
1:     private void fill (int minimumBytesNeeded) throws DRDAProtocolException
1:     {
1:         // make sure that there is enough space in the buffer to hold
1:         // the minimum number of bytes needed.
1:         ensureSpaceInBufferForFill (minimumBytesNeeded);
1:         // read until the minimum number of bytes needed is now in the buffer.
1:         // hopefully the read method will return as many bytes as it can.
1:         int totalBytesRead = 0;
1:         int actualBytesRead = 0;
1:         do {
1:             try {
1:                 actualBytesRead = inputStream.read (
1:                   buffer, count, buffer.length - count);
1:             } catch (java.net.SocketTimeoutException ste) {
1:             } catch (java.io.IOException ioe) {
1:             } finally {
1:                 if ((dssTrace != null) && dssTrace.isComBufferTraceOn())
1:                   dssTrace.writeComBufferData (buffer,
1:                                                count,
1:                                                actualBytesRead,
1:                                                DssTrace.TYPE_TRACE_RECEIVE,
1:                                                "Request",
1:                                                "fill",
1:                                                5);
1:             }
1:             if (actualBytesRead != -1)
1:             {
1:                 count += actualBytesRead;
1:                 totalBytesRead += actualBytesRead;
1:             }
1:         } while ((totalBytesRead < minimumBytesNeeded) && (actualBytesRead != -1));
1:         if (actualBytesRead == -1) 
1:         {
1:             if (totalBytesRead < minimumBytesNeeded) 
1:             {
1:                 agent.markCommunicationsFailure ("DDMReader.fill()",
1:                   "InputStream.read()", "insufficient data", "*");
1:             }
1:         }
1:     }
1:     /**
1:      * Print a internal trace message
1:      */
1:     private void trace(String msg)
1:     {
1:         if (agent != null)
1:             agent.trace(msg);
1:     }
1:     /**
1:      * Return chaining bit for current DSS.
1:      */
1:     protected byte getCurrChainState() {
1:         if (!dssIsChainedWithSameID && !dssIsChainedWithDiffID)
1:             return DssConstants.DSS_NOCHAIN;
1:         if (dssIsChainedWithSameID)
1:             return DssConstants.DSSCHAIN_SAME_ID;
1:         return DssConstants.DSSCHAIN;
1:     }
commit:cdfb2d1
/////////////////////////////////////////////////////////////////////////
0: 	private Utf8CcsidManager utf8CcsidManager;
0: 	private EbcdicCcsidManager ebcdicCcsidManager;
/////////////////////////////////////////////////////////////////////////
0: 	DDMReader(InputStream inputStream)
1: 		
/////////////////////////////////////////////////////////////////////////
0: 		this.utf8CcsidManager = new Utf8CcsidManager();
1:         this.ebcdicCcsidManager = new EbcdicCcsidManager();
1:         this.ccsidManager = ebcdicCcsidManager;
/////////////////////////////////////////////////////////////////////////
0: 	// Switch the ccsidManager to the UTF-8 instance
1:     protected void setUtf8Ccsid() {
1:         ccsidManager = utf8CcsidManager;
1:     }
1:     
1:     // Switch the ccsidManager to the EBCDIC instance
1:     protected void setEbcdicCcsid() {
1:         ccsidManager = ebcdicCcsidManager;
1:     }
1:     
0:     // Get the current ccsidManager
0:     protected CcsidManager getCurrentCcsidManager() {
0:         return ccsidManager;
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
0: 			return ccsidManager.convertToJavaString(plainText);
/////////////////////////////////////////////////////////////////////////
0: 		String result = ccsidManager.convertToJavaString(buffer, pos, length);
/////////////////////////////////////////////////////////////////////////
0: 		return ccsidManager.convertToJavaString (buf, 0, buf.length);
commit:fc30c5f
/////////////////////////////////////////////////////////////////////////
0: 		while (dssIsContinued)
1: 		{
0: 			skipBytes((int)dssLength);
0: 			readDSSContinuationHeader();
1: 		}
/////////////////////////////////////////////////////////////////////////
0: 		ensureALayerDataInBuffer (desiredDataSize);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 			if (actualBytesRead != -1)
1: 			{
0: 				count += actualBytesRead;
0: 				totalBytesRead += actualBytesRead;
1: 			}
commit:2e4a44e
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 		ddmScalarLen = readCodePoint();
0: 		int codePoint = readCodePoint();
1: 		
commit:cce01c8
/////////////////////////////////////////////////////////////////////////
0: 					((buffer[pos++] & 0xff) << 24) +
/////////////////////////////////////////////////////////////////////////
0: 					((buffer[pos++] & 0xff) << 24) +
/////////////////////////////////////////////////////////////////////////
0: 					((buffer[pos++] & 0xff) << 24) +
commit:9085abb
/////////////////////////////////////////////////////////////////////////
0: 		String val = new String(buffer, 0, 4, NetworkServerControlImpl.DEFAULT_ENCODING);
0: 		return NetworkServerControlImpl.isCmd(val);
/////////////////////////////////////////////////////////////////////////
0: 		return readString((int)ddmScalarLen, NetworkServerControlImpl.DEFAULT_ENCODING);
/////////////////////////////////////////////////////////////////////////
0: 		return readString(length, NetworkServerControlImpl.DEFAULT_ENCODING);
/////////////////////////////////////////////////////////////////////////
0: 										NetworkServerControlImpl.DEFAULT_ENCODING);
commit:119f972
/////////////////////////////////////////////////////////////////////////
0: 		return buffer[pos++];
commit:d79abcf
/////////////////////////////////////////////////////////////////////////
0:     	dssIsChainedWithSameID = false;
0:     	dssIsChainedWithDiffID = false;
/////////////////////////////////////////////////////////////////////////
1: 
1: 	/**
0: 	 * Return chaining bit for current DSS.
1: 	 */
0: 	protected byte getCurrChainState() {
1: 
0: 		if (!dssIsChainedWithSameID && !dssIsChainedWithDiffID)
0: 			return DssConstants.DSS_NOCHAIN;
1: 
0: 		if (dssIsChainedWithSameID)
0: 			return DssConstants.DSSCHAIN_SAME_ID;
1: 
0: 		return DssConstants.DSSCHAIN;
1: 
1: 	}
1: 
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:c3c7b7b
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     * It is used by ProtocolTestAdapter to read the protocol returned by the
/////////////////////////////////////////////////////////////////////////
commit:cf5cebf
/////////////////////////////////////////////////////////////////////////
1:         }
1: 
1:         // Check if we must read the status byte sent by the client.
1:         boolean readEXTDTAStatusByte =
1:                 agent.getSession().appRequester.supportsEXTDTAAbort();
1:         if (doingLayerBStreaming) {
1:             return new LayerBStreamedEXTDTAReaderInputStream(
1:                     this, readEXTDTAStatusByte);
1:             return new StandardEXTDTAReaderInputStream(
1:                     this, readEXTDTAStatusByte);
author:Camilla Haase
-------------------------------------------------------------------------------
commit:902725f
/////////////////////////////////////////////////////////////////////////
0: 	// DSS is larger than 32672 (continuation bit is set) so DSS is continued
author:Bernt Johnsen
-------------------------------------------------------------------------------
commit:1ab256e
/////////////////////////////////////////////////////////////////////////
1:     
1:     // For JMX statistics. Volatile to ensure we 
1:     // get one complete long, but we don't bother to synchronize, 
1:     // since this is just statistics.
1:     
1:     volatile long totalByteCount = 0;
/////////////////////////////////////////////////////////////////////////
1:         totalByteCount += totalBytesRead;
commit:1f71856
/////////////////////////////////////////////////////////////////////////
0: 			} catch (java.net.SocketTimeoutException ste) {
1: 
1:                 // Transport the timeout out through the layers. This
1:                 // exception is caught in DRDAConnThread.run();
1:                 throw new DRDASocketTimeoutException(agent);
1: 
0: 			} catch (java.io.IOException ioe) {
1:                 agent.markCommunicationsFailure("DDMReader.fill()",
1:                                                 "InputStream.read()", ioe.getMessage(), "*");
0: 			} finally {
/////////////////////////////////////////////////////////////////////////
0: 		} while ((totalBytesRead < minimumBytesNeeded) && (actualBytesRead != -1));
1: 
commit:ee2a860
/////////////////////////////////////////////////////////////////////////
0: 	 * Read string value into a <code>DRDAString</code> object.
1: 	 *
0: 	 * @param dst  destination for the read string
0: 	 * @param size size (in bytes) of string to read
0: 	 * @param unpad if true, remove padding (trailing spaces)
1: 	 *
0: 	 * @exception DRDAProtocolException
1: 	 */
0: 	protected void readString(DRDAString dst, int size, boolean unpad)
1: 		throws DRDAProtocolException
1: 	{
0: 		ensureBLayerDataInBuffer(size, ADJUST_LENGTHS);
0: 		int startPos = pos;
0: 		pos += size;
0: 		if (unpad) {
0: 			while ((size > 0) &&
0: 				   (buffer[startPos + size - 1] == ccsidManager.space)) {
0: 				--size;
1: 			}
1: 		}
0: 		dst.setBytes(buffer, startPos, size);
1: 	}
1: 
1: 	/**
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:0270d3d
/////////////////////////////////////////////////////////////////////////
commit:59e5225
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:f0b0870
/////////////////////////////////////////////////////////////////////////
0: 	* @param buffer			buffer to read from
0: 	* @param offset			offset in the buffer
0: 	* @param startNybble		start nybble
0: 	* @param numberOfNybbles	number of nybbles
/////////////////////////////////////////////////////////////////////////
0: 	 * @param buffer		buffer to read from
0: 	 * @param offset		offset in the buffer
0: 	 * @param startNybble		start nybble
0: 	 * @param numberOfNybbles	number of nybbles
/////////////////////////////////////////////////////////////////////////
0: 	 * @param   securityMechanism security mechanism
author:Tomohito Nakayama
-------------------------------------------------------------------------------
commit:fefd864
/////////////////////////////////////////////////////////////////////////
1:     
/////////////////////////////////////////////////////////////////////////
1:     
1:     // State whether doing layer B Streaming or not.
1:     private boolean doingLayerBStreaming = false;;
/////////////////////////////////////////////////////////////////////////
1:      * @param isLayerBStreamingPossible true only when layer B streaming is possible
0: 	protected int readLengthAndCodePoint( boolean isLayerBStreamingPossible ) 
0:         throws DRDAProtocolException
/////////////////////////////////////////////////////////////////////////
1:                 
1:             case 0:
1:                 
1:                 if( isLayerBStreamingPossible &&
1:                     ( codePoint == CodePoint.EXTDTA || 
1:                       codePoint == CodePoint.QRYDTA ) ){
1:                     
1:                     startLayerBStreaming();
1:                     adjustSize = 4;
1:                     
1:                 }else {
1:                     agent.throwSyntaxrm(CodePoint.SYNERRCD_INCORRECT_EXTENDED_LEN,
1:                                         DRDAProtocolException.NO_CODPNT_ARG);
1:                 }
1:                 
1:                 break;
1:                 
/////////////////////////////////////////////////////////////////////////
0:                 {
0: 				return readLengthAndCodePoint( false );
/////////////////////////////////////////////////////////////////////////
1:             
0: 		} else if ( doingLayerBStreaming ){
0: 			return new LayerBStreamedEXTDTAReaderInputStream(this);
1:         
1:         } else {
0:             return new StandardEXTDTAReaderInputStream(this);
1:             
1:         }
1: 
1:     
1:     /**
0: 	 * This method is used by EXTDTAReaderInputStream to read the first chunk 
0: 	 * of data.
1:      * This lengthless method must be called only when layer B streaming.
1:      *
0: 	 * @exception DRDAProtocolException standard DRDA protocol exception
1: 	 */
0: 	ByteArrayInputStream readLOBInitStream() 
0: 		throws DRDAProtocolException
0: 	{
1:         if ( SanityManager.DEBUG ) {
1:             SanityManager.ASSERT( doingLayerBStreaming );
1:         }
1: 		
1:         return readLOBInitStream( 0 );
1:         
1: 	}
1: 	
0: 	 * @param desiredLength the desired length of chunk. This parameter is ignored when layerB Streaming is doing.
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
0: 	 * This method is used by EXTDTAReaderInputStream to read the next chunk 
0: 	 * of data.
1:      *
1:      * Calling this method finishes layer B streaming 
1:      * if continuation of DSS segment was finished.
1:      * This lengthless method must be called only when layer B streaming.
1:      *
0: 	 * @param desiredLength the desired length of chunk. This parameter is ignored when layerB Streaming is doing.
0: 	 * @exception IOException IOException
1: 	 */
0: 	ByteArrayInputStream readLOBContinuationStream ()
0: 		throws IOException
0: 	{		
1:         if ( SanityManager.DEBUG ) {
1:             SanityManager.ASSERT( doingLayerBStreaming );
1:         }
1:         return readLOBContinuationStream( 0 );
1: 	}
1:     
1: 
1:      *
1:      * Furthermore, when Layer B streaming is carried out,
1:      * calling this method finishes layer B streaming 
1:      * if continuation of DSS segment was finished.
1:      *
0: 	 * @param desiredLength the desired length of chunk. This parameter is ignored when layerB Streaming is doing.
/////////////////////////////////////////////////////////////////////////
0:      *
1:      * Furthermore, when Layer B streaming is carried out,
1:      * calling this method may finish layer B streaming.
0:      *
0: 	 * @param desiredLength the desired length of chunk. This parameter is ignored when layerB Streaming is doing.
/////////////////////////////////////////////////////////////////////////
1: 		
1:         int copySize = doingLayerBStreaming ? 
1:             dssLength : 
1:             (int) Math.min(dssLength, desiredLength);
1:         
1:         if( ! doingLayerBStreaming ){
1:             adjustLengths (copySize);
1:             
1:         }else{
1:             dssLength -= copySize;
1:             
1:         }
/////////////////////////////////////////////////////////////////////////
1:         if( doingLayerBStreaming && 
1:             ! dssIsContinued )
1:             finishLayerBStreaming();
1:         
1: 
1:       if ( SanityManager.DEBUG ) {
1:             SanityManager.ASSERT( ! doingLayerBStreaming );
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1:     
1:     
1:     private void startLayerBStreaming() {
1:         doingLayerBStreaming = true;
1:     }
1:     
1:     
1:     private void finishLayerBStreaming() {
1:         doingLayerBStreaming = false;
1:     }
1:     
1:     
1:     boolean doingLayerBStreaming() {
1:         return doingLayerBStreaming;
1:     }
1:     
1:     
commit:489a05c
/////////////////////////////////////////////////////////////////////////
1:     ByteArrayOutputStream baos;
1:         baos = new ByteArrayOutputStream ((int) desiredLength);
1:         baos = new ByteArrayOutputStream ();
/////////////////////////////////////////////////////////////////////////
commit:4abfe24
/////////////////////////////////////////////////////////////////////////
0:     MemorySavedByteArrayOutputStream baos;
0:         baos = new MemorySavedByteArrayOutputStream ((int) desiredLength - 
0: 													 ( checkNullability ? 1:0 )
0: 													 );
0:         baos = new MemorySavedByteArrayOutputStream ();
/////////////////////////////////////////////////////////////////////////
1: 	
1: 
1: 	/**
0: 	 *
0: 	 * This class supress to allocate another memory when toByteArray() method was called.
0: 	 * In compensation for the saving memory, program using this class should not modify the return value of  toByteArray() method.
0: 	 *
1: 	 */
0: 	static class MemorySavedByteArrayOutputStream extends ByteArrayOutputStream {
1: 		
1: 		
0: 		MemorySavedByteArrayOutputStream(){
0: 			super();
1: 		}
1: 		
1: 		
0: 		MemorySavedByteArrayOutputStream(int size){
0: 			buf = new byte[size];
0: 			count = 0;
1: 		}
1: 		
1: 		
0: 		public byte[] toByteArray() {
1: 			
0: 			if(buf.length == count){
0: 				return buf;
1: 				
0: 			}else{
0: 				return super.toByteArray();
1: 
1: 			}
1: 		}
1: 		
1: 		
1: 	}
author:Andreas Korneliussen
-------------------------------------------------------------------------------
commit:a376274
/////////////////////////////////////////////////////////////////////////
0: import java.io.ByteArrayInputStream;
/////////////////////////////////////////////////////////////////////////
1: 	
1: 	/**
0: 	 * Creates an InputStream which can stream EXTDTA objects.
0: 	 * The InputStream uses this DDMReader to read data from network. The 
0: 	 * DDMReader should not be used before all data in the stream has been read.
0: 	 * @param checkNullability used to check if the stream is null. If it is 
0: 	 * null, this method returns null
0: 	 * @return EXTDTAReaderInputStream object which can be passed to prepared
0: 	 *         statement as a binary stream.
0: 	 * @exception DRDAProtocolException standard DRDA protocol exception
0: 	 */
0: 	EXTDTAReaderInputStream getEXTDTAReaderInputStream
0: 		(final boolean checkNullability)
0: 		throws DRDAProtocolException
0: 	{
0: 		if (checkNullability && isEXTDTANull()) {
1: 			return null;
0: 		} else {
0: 			return new EXTDTAReaderInputStream(this);
1: 		}
1: 	}
1: 
1: 	/**
0: 	 * This method is used by EXTDTAReaderInputStream to read the first chunk 
0: 	 * of data.
0: 	 * @param desiredLength the desired length of chunk
0: 	 * @exception DRDAProtocolException standard DRDA protocol exception
0: 	 */
0: 	ByteArrayInputStream readLOBInitStream(final long desiredLength) 
0: 		throws DRDAProtocolException
0: 	{
0: 		return readLOBChunk(false, desiredLength);
1: 	}
1: 	
1: 	/**
0: 	 * This method is used by EXTDTAReaderInputStream to read the next chunk 
0: 	 * of data.
0: 	 * @param desiredLength the desired length of chunk
0: 	 * @exception IOException IOException
0: 	 */
0: 	ByteArrayInputStream readLOBContinuationStream (final long desiredLength)
0: 		throws IOException
0: 	{		
0: 		try {
0: 			return readLOBChunk(true, desiredLength);
0: 		} catch (DRDAProtocolException e) {
0: 			e.printStackTrace(agent.getServer().logWriter);
0: 			throw new IOException(e.getMessage());
1: 		}
1: 	}
1: 
1: 	/**
0: 	 * This method is used by EXTDTAReaderInputStream to read the next chunk 
0: 	 * of data.
0: 	 * @param readHeader set to true if the dss continuation should be read
0: 	 * @param desiredLength the desired length of chunk
0: 	 * @exception DRDAProtocolException standard DRDA protocol exception
0: 	 */
0: 	private ByteArrayInputStream readLOBChunk
0: 		(final boolean readHeader, final long desiredLength)
0: 		throws DRDAProtocolException
0: 	{		
0: 		if (readHeader) {			
0: 			readDSSContinuationHeader();
1: 		}
0: 		int copySize = (int) Math.min(dssLength, desiredLength);
1: 		
1: 		// read the segment
1: 		ensureALayerDataInBuffer (copySize);
1: 		adjustLengths (copySize);
1: 		
0: 		// Create ByteArrayInputStream on top of buffer. 
0: 		// This will not make a copy of the buffer.
0: 		ByteArrayInputStream bais = 
0: 			new ByteArrayInputStream(buffer, pos, copySize);
1: 		pos += copySize;
1: 		
0: 		return bais;
1: 	}
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:7df5ffe
/////////////////////////////////////////////////////////////////////////
0: 	DDMReader (DRDAConnThread agent, DssTrace dssTrace)
/////////////////////////////////////////////////////////////////////////
0: 	DDMReader(CcsidManager ccsidManager, InputStream inputStream)
commit:d7258ed
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.drda.DDMReader
1: 
0:    Copyright 2001, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:141cd31
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.drda
0:    (C) Copyright IBM Corp. 2001, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
0:  */
1: 
1: package org.apache.derby.impl.drda;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import java.io.IOException;
1: import java.io.InputStream;
0: import java.io.ByteArrayOutputStream;
1: import java.math.BigDecimal;
1: 
0: /**
0: 	The DDMReader is used to read DRDA protocol.   DRDA Protocol is divided into
0: 	three layers corresponding to the DDM three-tier architecture. For each layer,
0: 	their is a DSS (Data Stream Structure) defined.
0: 		Layer A 	Communications management services
0: 		Layer B		Agent services
0: 		Layer C 	Data management services
0: 	<P>
0: 	At layer A are request, reply and data correlation, structure chaining,
0: 	continuation or termination of chains when errors are detected, interleaving
0: 	and multi-leaving request, reply, and data DSSs for multitasking environments.
0: 	For TCP/IP, the format of the DDM envelope is
0: 		2 bytes		Length of the data
0: 		1 byte		'D0' - indicates DDM data
0: 		1 byte		DDM format byte(DSSFMT) - type of DSS(RQSDSS,RPYDSS), whether it is
0: 					chained, information about the next chained DSS
0: 		2 bytes		request correlation identifier
0: 	<P>
0: 	The correlation identifier ties together a request, the request data and the
0: 	reply.  In a chained DSS, each request has a correlation identifier which
0: 	is higher than the previous request (all correlation identifiers must
0: 	be greater than 0).
0: 	<P>
0: 	At layer B are object mapping, object validation and command routing.
0: 	Layer B objects with data 5 bytes less than 32K bytes consist of
0: 		2 bytes		Length
0: 		2 bytes		Type of the object (code point)
0: 		Object data
0: 	Object data is either SCALAR or COLLECTION data.  Scalar data consists of
0: 	a string of bytes formatted as the class description of the object required.
0: 	Collections consist of a set of objects in which the entries in the collection
0: 	are nested within the length/ code point of the collection.
0: 	<P>
0: 	Layer B objects with data >=32763 bytes long format is 
0: 		2 bytes		Length - length of class, length, and extended total length fields
0: 					(high order bit set, indicating >=32763)
0: 		2 bytes		Type of the object (code point)
0: 		n bytes		Extended total length - length of the object
0: 					(n = Length - 4)
0: 		Object data
0: 	<P>
0: 	At layer C are services each class of DDM object provides.
1: 
0: 		    |-------------------------------------------|
0: 	Layer C | Specific	|	Specific	|	Specific	|
0: 		    | Commands	|	Replies		| Scalars and	|
0: 			| and their |  and their    | Collections   |
0: 			|-------------------------------------------|----------------|
0: 	Layer B | Commands  |    Reply		| Scalars and   | Communications |
0: 			|			|   Messages	| Collections	|                |
0: 			|-----------|---------------|---------------|----------------|
0: 	Layer A |  RQSDSS   |   RPYDSS		| OBJDSS		| CMNDSS         |
0: 			|           |               |               | Mapped Data    |
0: 			|-----------|---------------|---------------|----------------|
0: 			|                DDM Data Stream Structures                  |
0: 			|------------------------------------------------------------|
1: 			
0: 	DSS's may be chained so that more than one can be transmitted at a time
0: 	to improve performance.
0: 	For more details, see DRDA Volume 3 (Distributed Data Management(DDM)
0: 		Architecture (DDS definition)
0: */
1: class DDMReader
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
1: 
0: 	private static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2001_2004;
0: 	private final static int DEFAULT_BUFFER_SIZE = 32767;
0: 	private final static int MAX_MARKS_NESTING = 10;
0: 	private final static int NO_CODEPOINT = -1;
0: 	private final static int EMPTY_STACK = -1;
0: 	private final static boolean ADJUST_LENGTHS = true;
0: 	private final static boolean NO_ADJUST_LENGTHS = false;
0: 	private final static long MAX_EXTDTA_SIZE= Long.MAX_VALUE;
0: 	private static boolean internalTrace = true;
1: 
0: 	// magnitude represented in an int array, used in BigDecimal conversion
1:     private static final int[][] tenRadixMagnitude = {
1:       { 0x3b9aca00 }, // 10^9
1:       { 0x0de0b6b3, 0xa7640000 }, // 10^18
1:       { 0x033b2e3c, 0x9fd0803c, 0xe8000000 }, // 10^27
1:     };
1: 
0: 	private DRDAConnThread agent;
0: 	private CcsidManager ccsidManager;
1: 
0: 	// data buffer
0: 	private byte[] buffer;
0: 	private int pos;
0: 	private int count;
1: 
0: 	// DDM object collection
0: 	// top of stack
0: 	private int topDdmCollectionStack;
0: 	// length of each object in the stack
0: 	private long[] ddmCollectionLenStack;
1: 
0: 	// DDM object length
0: 	private long ddmScalarLen;
1: 
0: 	// DSS Length
0: 	private int dssLength;
1: 
0: 	// DSS is larger than 32762 (continuation bit is set) so DSS is continued
0: 	private boolean dssIsContinued;
1: 
0: 	private boolean terminateChainOnErr;
1: 
0: 	// next DSS in the chain has the same correlator
0: 	private boolean dssIsChainedWithSameID;
1: 
0: 	// next DSS in the chain has a different correlator
0: 	private boolean dssIsChainedWithDiffID;
1: 	
0: 	// correlation id for the current DSS
0: 	private int dssCorrelationID;
1: 
0: 	// previous corelation id
0: 	private int prevCorrelationID;
1: 
0: 	// current server codepoint
0: 	private int svrcod;
1: 
0: 	// trace object of the associated session
0: 	private DssTrace dssTrace;
1: 
0: 	// input stream
0: 	private InputStream inputStream;
1: 
0: 	// constructor
0: 	protected DDMReader (DRDAConnThread agent, DssTrace dssTrace)
0: 	{
0: 		buffer = new byte[DEFAULT_BUFFER_SIZE];
0: 		ddmCollectionLenStack = new long[MAX_MARKS_NESTING];
0: 		initialize(agent, dssTrace);
0: 	}
0: 	/**
0: 	 * This constructor is used for testing the protocol
0: 	 * It is used by TestProto to read the protocol returned by the
0: 	 * server 
0: 	 */
0: 	protected DDMReader(CcsidManager ccsidManager, InputStream inputStream)
0: 	{
0: 		buffer = new byte[DEFAULT_BUFFER_SIZE];
0: 		ddmCollectionLenStack = new long[MAX_MARKS_NESTING];
0: 		this.ccsidManager = ccsidManager;
0: 		this.inputStream = inputStream;
0: 		initialize(null, null);
0: 		// turn off tracing
0: 		internalTrace = false;
0: 	}
0: 	/**
0: 	 * This initializer is used for testing the protocol
0: 	 * It is used by TestProto for the reader it uses
0: 	 */
0: 	protected void initialize(InputStream inputStream)
0: 	{
0: 		this.inputStream = inputStream;
0: 		initialize(null, null);
0: 	}
1: 
0: 	/**
0: 	 * Initialize values for this session, the reader is reused so we need to
0: 	 * set null and 0 values
0: 	 */
0: 	protected void initialize(DRDAConnThread agent, DssTrace dssTrace)
0:   	{
0: 		this.agent = agent;
0: 		if (agent != null)
0: 		{
0: 			ccsidManager = agent.ccsidManager;
0: 			inputStream = agent.getInputStream();
0: 		}
0: 		topDdmCollectionStack = EMPTY_STACK;
0:     	svrcod = 0;
0: 		pos = 0;
0: 		count = 0;
0: 		ddmScalarLen = 0;
0: 		dssLength = 0;
0: 		prevCorrelationID = DssConstants.CORRELATION_ID_UNKNOWN;
0: 		dssCorrelationID = DssConstants.CORRELATION_ID_UNKNOWN;
0: 		this.dssTrace = dssTrace;
0: 	}
1: 
0: 	protected boolean terminateChainOnErr()
0: 	{
0: 		return terminateChainOnErr;
0: 	}
1: 
0: 	/**
0: 	 * Next DSS has same correlator as current DSS
0: 	 *
0: 	 * @return true if next DSS has the same correlator as current DSS
0: 	 */
0:   	protected boolean isChainedWithSameID()
0:   	{
0:     	return dssIsChainedWithSameID;
0:   	}
1: 
0: 	/**
0: 	 * Next DSS has different correlator than current DSS
0: 	 *
0: 	 * @return true if next DSS has a different correlator than current DSS
0: 	 */
0:   	protected boolean isChainedWithDiffID()
0:   	{
0:     	return dssIsChainedWithDiffID;
0:   	}
1: 
0: 	/**
0: 	 * Length of current DDM object
0: 	 *
0: 	 * @return length of DDM object
0: 	 */
0: 	protected long getDdmLength()
0: 	{
0: 		return ddmScalarLen;
0: 	}
1: 
0: 	/**
0: 	 * Is there more in this DDM object
0: 	 *
0: 	 * @return true if DDM length is > 0
0: 	 */
0: 	protected boolean moreDdmData()
0: 	{
0: 		return ddmScalarLen > 0;
0: 	}
1: 
0: 	/**
0: 	 * Is there more in this DDS object
0: 	 *
0: 	 * @return true if DDS length is > 0
0: 	 */
0: 	protected boolean moreDssData()
0: 	{
0: 		return dssLength > 0;
0: 	}
1: 
0: 	/** 
0: 	 * Is there more data in the buffer
0: 	 *
0: 	 * @return true if there is more data in the buffer
0: 	 */
0: 	protected boolean moreData()
0: 	{
0: 		return (pos - count) > 0;
0: 	}
1: 
0: 	/**
0: 	 * Check for the command protocol
0: 	 *
0: 	 * @return true if this is a command; false otherwise
0: 	 *
0: 	 * @exception DRDProtocolException
0: 	 */
0: 	protected boolean isCmd() throws DRDAProtocolException, java.io.UnsupportedEncodingException
0: 	{
0: 		ensureALayerDataInBuffer(4);
0: 		String val = new String(buffer, 0, 4, DB2jServerImpl.DEFAULT_ENCODING);
0: 		return DB2jServerImpl.isCmd(val);
0: 	}
1: 
0: 	/**
0: 	 * Return buffer 
0: 	 *
0: 	 *
0: 	 * @return buffer
0: 	 */
0: 	protected byte [] getBuffer()
0: 	{
0: 		return buffer;
0: 	}
1: 
0: 	/**
0: 	 * Read DSS header
0: 	 * DSS Header format is 
0: 	 * 	2 bytes	- length
0: 	 *	1 byte	- 'D0'	- indicates DDM data
0: 	 * 	1 byte	- DSS format 
0: 	 *		|---|---------|----------|
0: 	 *		| 0	|  flags  |  type    |
0: 	 *		|---|---------|----------|
0: 	 *		| 0 | 1  2  3 | 4 5 6 7  |
0: 	 *		|---|---------|----------|
0: 	 *		bit 0 - '0'
0: 	 *		bit 1 - '0' - unchained, '1' - chained
0: 	 *		bit 2 - '0'	- do not continue on error, '1' - continue on error
0: 	 *		bit 3 - '0' - next DSS has different correlator, '1' - next DSS has
0: 	 *						same correlator
0: 	 *		type - 1 - Request DSS
0: 	 *			 - 2 - Reply DSS
0: 	 *			 - 3 - Object DSS
0: 	 *			 - 4 - Communications DSS
0: 	 *			 - 5 - Request DSS where no reply is expected
0: 	 *	2 bytes - request correlation id
0: 	 *
0: 	 * @exception DRDProtocolException
0: 	 */
0: 	protected int readDssHeader () throws DRDAProtocolException
0: 	{
0: 		ensureALayerDataInBuffer (6);
1: 
0: 		// read out the DSS length
0: 		dssLength = ((buffer[pos] & 0xff) << 8) +
0: 					((buffer[pos + 1] & 0xff) << 0);
0: 		pos += 2;
0: 		// check for the continuation bit and update length as needed.
0: 		if ((dssLength & DssConstants.CONTINUATION_BIT) == 
0: 				DssConstants.CONTINUATION_BIT) 
0: 		{
1: 			dssLength = DssConstants.MAX_DSS_LENGTH;
1: 			dssIsContinued = true;
0: 		}
1: 		else 
0: 		{
1: 			dssIsContinued = false;
0: 		}
1: 
0: 		if (dssLength < 6)
0: 			agent.throwSyntaxrm(CodePoint.SYNERRCD_DSS_LESS_THAN_6,
0: 							   DRDAProtocolException.NO_CODPNT_ARG);
1: 
0: 		// If the GDS id is not valid, or
0: 		// if the reply is not an RQSDSS nor
0: 		// a OBJDSS, then throw an exception.
1: 
0: 		if ((buffer[pos++] & 0xff) != DssConstants.DSS_ID)
0: 			agent.throwSyntaxrm(CodePoint.SYNERRCD_CBYTE_NOT_D0,
0: 							   DRDAProtocolException.NO_CODPNT_ARG);
1: 
0: 		int gdsFormatter = buffer[pos++] & 0xff;
1: 		
0: 		if (((gdsFormatter & 0x0F) != DssConstants.DSSFMT_RQSDSS)
0: 			&&((gdsFormatter & 0x0F) != DssConstants.DSSFMT_OBJDSS)) 
0: 		{
0: 			agent.throwSyntaxrm(CodePoint.SYNERRCD_FBYTE_NOT_SUPPORTED,
0: 							   DRDAProtocolException.NO_CODPNT_ARG);
0: 		}
1: 
0: 		// Determine if the current DSS is chained with the
0: 		// next DSS, with the same or different request ID.
0: 		if ((gdsFormatter & DssConstants.DSSCHAIN) == DssConstants.DSSCHAIN) 
0: 		{	// on indicates structure chained to next structure
0: 			if ((gdsFormatter & DssConstants.DSSCHAIN_SAME_ID) 
0: 					== DssConstants.DSSCHAIN_SAME_ID) 
0: 			{
0: 				dssIsChainedWithSameID = true;
0: 				dssIsChainedWithDiffID = false;
0: 			}
1: 			else 
0: 			{
0: 				dssIsChainedWithSameID = false;
0: 				dssIsChainedWithDiffID = true;
0: 			}
0: 			if ((gdsFormatter & DssConstants.DSSCHAIN_ERROR_CONTINUE) 
0: 				== DssConstants.DSSCHAIN_ERROR_CONTINUE)
0: 				terminateChainOnErr = false;
1: 			else
0: 				terminateChainOnErr = true;
0: 		}
1: 		else 
0: 		{
0: 			// chaining bit not b'1', make sure DSSFMT same id not b'1'
0: 			if ((gdsFormatter & DssConstants.DSSCHAIN_SAME_ID) 
0: 					== DssConstants.DSSCHAIN_SAME_ID)	
0: 			{  // Next DSS can not have same correlator
0: 				agent.throwSyntaxrm(CodePoint.SYNERRCD_CHAIN_OFF_SAME_NEXT_CORRELATOR,
0: 								   DRDAProtocolException.NO_CODPNT_ARG);
0: 			}
0: 			// chaining bit not b'1', make sure no error continuation
0: 			if ((gdsFormatter & DssConstants.DSSCHAIN_ERROR_CONTINUE) 
0: 				== DssConstants.DSSCHAIN_ERROR_CONTINUE) 
0: 			{ // must be 'do not continue on error'
0: 				agent.throwSyntaxrm(CodePoint.SYNERRCD_CHAIN_OFF_ERROR_CONTINUE,
0: 								   DRDAProtocolException.NO_CODPNT_ARG);
0: 			}
1: 
0: 			dssIsChainedWithSameID = false;
0: 			dssIsChainedWithDiffID = false;
0: 		}
1: 
0: 		dssCorrelationID =
0: 			((buffer[pos] & 0xff) << 8) +
0: 			((buffer[pos + 1] & 0xff) << 0);
0: 		pos += 2;
0: 		if (SanityManager.DEBUG)
0: 			trace("dssLength = " + dssLength + " correlationID = " + dssCorrelationID);
1: 
0: 		//check that correlationID is the same as previous
0: 		if (prevCorrelationID != DssConstants.CORRELATION_ID_UNKNOWN && 
0: 			dssCorrelationID != prevCorrelationID)
0: 		{
0: 			agent.throwSyntaxrm(CodePoint.SYNERRCD_CHAIN_OFF_ERROR_CONTINUE,
0: 							   DRDAProtocolException.NO_CODPNT_ARG);
0: 		}
1: 		
0: 		// set up previous correlation id to check that next DSS is correctly
0: 		// formatted
0: 		if (dssIsChainedWithSameID)
0: 			prevCorrelationID = dssCorrelationID;
1: 		else
0: 			prevCorrelationID = DssConstants.CORRELATION_ID_UNKNOWN;
1: 
0: 		dssLength -= 6;
1: 
0: 		return dssCorrelationID;
0: 	}
0: 	/**
0: 	 * Read Reply DSS
0: 	 * This is used in testing the protocol.  We shouldn't see a reply
0: 	 * DSS when we are servicing DRDA commands
0: 	 *
0: 	 * @exception DRDProtocolException
0: 	 */
0: 	protected void readReplyDss() throws DRDAProtocolException
0: 	{
0: 		ensureALayerDataInBuffer (6);
1: 
0: 		// read out the DSS length
0: 		dssLength = ((buffer[pos++] & 0xff) << 8) +
0: 					((buffer[pos++] & 0xff) << 0);
1: 
0: 		// check for the continuation bit and update length as needed.
0: 		if ((dssLength & DssConstants.CONTINUATION_BIT) == 
0: 				DssConstants.CONTINUATION_BIT) 
0: 		{
1: 			dssLength = DssConstants.MAX_DSS_LENGTH;
1: 			dssIsContinued = true;
0: 		}
1: 		else 
0: 		{
1: 			dssIsContinued = false;
0: 		}
1: 
0: 		if (dssLength < 6)
0: 			agent.throwSyntaxrm(CodePoint.SYNERRCD_DSS_LESS_THAN_6,
0: 							   DRDAProtocolException.NO_CODPNT_ARG);
1: 
0: 		// If the GDS id is not valid, throw exception
1: 
0: 		if ((buffer[pos++] & 0xff) != DssConstants.DSS_ID)
0: 			agent.throwSyntaxrm(CodePoint.SYNERRCD_CBYTE_NOT_D0,
0: 							   DRDAProtocolException.NO_CODPNT_ARG);
1: 
0: 		int gdsFormatter = buffer[pos++] & 0xff;
1: 		
0: 		// Determine if the current DSS is chained with the
0: 		// next DSS, with the same or different request ID.
0: 		if ((gdsFormatter & DssConstants.DSSCHAIN) == DssConstants.DSSCHAIN) 
0: 		{	// on indicates structure chained to next structure
0: 			if ((gdsFormatter & DssConstants.DSSCHAIN_SAME_ID) 
0: 					== DssConstants.DSSCHAIN_SAME_ID) 
0: 			{
0: 				dssIsChainedWithSameID = true;
0: 				dssIsChainedWithDiffID = false;
0: 			}
1: 			else 
0: 			{
0: 				dssIsChainedWithSameID = false;
0: 				dssIsChainedWithDiffID = true;
0: 			}
0: 		}
1: 		else 
0: 		{
0: 			dssIsChainedWithSameID = false;
0: 			dssIsChainedWithDiffID = false;
0: 		}
1: 
0: 		dssCorrelationID =
0: 			((buffer[pos++] & 0xff) << 8) +
0: 			((buffer[pos++] & 0xff) << 0);
1: 
0: 		if (SanityManager.DEBUG)					
0: 			trace("dssLength = " + dssLength + " correlationID = " + dssCorrelationID);
1: 
0: 		dssLength -= 6;
1: 
0: 	}
1: 
0: 	/**
0: 	 * Read the DDM Length and CodePoint
0: 	 *
0: 	 * @return - returns codepoint
0: 	 *
0: 	 * @exception DRDProtocolException
0: 	 */
0: 	protected int readLengthAndCodePoint() throws DRDAProtocolException
0: 	{
0: 		ensureBLayerDataInBuffer (4, NO_ADJUST_LENGTHS);
1: 
0: 		ddmScalarLen =
0: 			((buffer[pos++] & 0xff) << 8) +
0: 			((buffer[pos++] & 0xff) << 0);
1: 
0: 		int codePoint =
0: 			((buffer[pos++] & 0xff) << 8) +
0: 			((buffer[pos++] & 0xff) << 0);
0: 		if (SanityManager.DEBUG)
0: 			trace("length = "+ ddmScalarLen + " codepoint = " + java.lang.Integer.toHexString(codePoint));
0: 		// SYNERRCD 0x0D - Object code point index not supported.
0: 		// the object codepoint index will not be checked here since
0: 		// the parse methods will catch any incorrect/unexpected codepoint values
0: 		// and report them as unsupported objects or parameters.
1: 
0: 		// Check if this DDM has extended length field
0: 		if ((ddmScalarLen & DssConstants.CONTINUATION_BIT) == DssConstants.CONTINUATION_BIT) 
0: 		{
0: 			int numberOfExtendedLenBytes = ((int)ddmScalarLen - 
0: 					DssConstants.CONTINUATION_BIT) - 4;
0: 			int adjustSize = 0;
0: 			ensureBLayerDataInBuffer (numberOfExtendedLenBytes, NO_ADJUST_LENGTHS);
0: 			switch (numberOfExtendedLenBytes) {
0: 			case 8:
0: 				 ddmScalarLen =
0: 					((buffer[pos++] & 0xff) << 64) +
0: 					((buffer[pos++] & 0xff) << 56) +
0: 					((buffer[pos++] & 0xff) << 48) +
0: 					((buffer[pos++] & 0xff) << 40) +
0: 					((buffer[pos++] & 0xff) << 32) +
0: 					((buffer[pos++] & 0xff) << 16) +
0: 					((buffer[pos++] & 0xff) << 8) +
0: 					((buffer[pos++] & 0xff) << 0);
0: 				adjustSize = 12;
0: 				break;
0: 			case 6:
0: 				ddmScalarLen =
0: 					((buffer[pos++] & 0xff) << 48) +
0: 					((buffer[pos++] & 0xff) << 40) +
0: 					((buffer[pos++] & 0xff) << 32) +
0: 					((buffer[pos++] & 0xff) << 16) +
0: 					((buffer[pos++] & 0xff) << 8) +
0: 					((buffer[pos++] & 0xff) << 0);
0: 				adjustSize = 10;
0: 				break;
0: 			case 4:
0: 				ddmScalarLen =
0: 					((buffer[pos++] & 0xff) << 32) +
0: 					((buffer[pos++] & 0xff) << 16) +
0: 					((buffer[pos++] & 0xff) << 8) +
0: 					((buffer[pos++] & 0xff) << 0);
0: 				adjustSize = 8;
0: 				break;
0: 			default:
0: 				agent.throwSyntaxrm(CodePoint.SYNERRCD_INCORRECT_EXTENDED_LEN,
0: 							   DRDAProtocolException.NO_CODPNT_ARG);
0: 		}
1: 
0: 			// adjust the lengths here.	this is a special case since the
0: 			// extended length bytes do not include their own length.
0: 			for (int i = 0; i <= topDdmCollectionStack; i++) {
0: 				ddmCollectionLenStack[i] -= adjustSize;
0: 			}
0: 			dssLength -= adjustSize;
0: 		}
1: 		else {
0: 			if (ddmScalarLen < 4)
0: 				agent.throwSyntaxrm(CodePoint.SYNERRCD_OBJ_LEN_LESS_THAN_4,
0: 								   DRDAProtocolException.NO_CODPNT_ARG);
0: 			adjustLengths (4);
0: 		}
0: 		return codePoint;
0: 	}
1: 
0: 	/**
0: 	 * Read the CodePoint
0: 	 *
0: 	 * @return - returns codepoint
0: 	 */
0: 	protected int readCodePoint()
0: 	{
0: 		return( ((buffer[pos++] & 0xff) << 8) +
0: 		  ((buffer[pos++] & 0xff) << 0));
0: 	}
1: 
0: 	/**
0: 	 * Push DDM Length on to collection stack
0: 	 */
0: 	protected void markCollection()
0: 	{
0: 		ddmCollectionLenStack[++topDdmCollectionStack] = ddmScalarLen;
0: 		ddmScalarLen = 0;
0: 	}
1: 
0: 	/**
0: 	 * 	Get the next CodePoint from a collection
0: 	 * 	@return	NO_CODEPOINT if collection stack is empty or remaining length is
0: 	 *		0; otherwise,  read length and code point
0: 	 *
0: 	 * @exception DRDProtocolException
0: 	 */
0: 	protected int getCodePoint() throws DRDAProtocolException
0: 	{
0: 		if (topDdmCollectionStack == EMPTY_STACK) 
0: 		{
0: 			return NO_CODEPOINT;
0: 		}
1: 		else 
0: 		{
0: 			// if the collecion is exhausted then return NO_CODEPOINT
0: 			if (ddmCollectionLenStack[topDdmCollectionStack] == 0) 
0: 			{
0: 				// done with this collection so remove it's length from the stack
0: 				ddmCollectionLenStack[topDdmCollectionStack--] = 0;
0: 				return NO_CODEPOINT;
0: 			}
1: 			else {
0: 				return readLengthAndCodePoint();
0: 			}
0: 		}
0: 	}
0: 	/**
0: 	 * Get the next CodePoint from a collection and check that it matches the specified
0: 	 * 	CodePoint
0: 	 * @param	codePointCheck	- codePoint to check against
0: 	 * @return	codePoint
0: 	 *
0: 	 * @exception DRDProtocolException
0: 	 */
0: 	protected int getCodePoint(int codePointCheck) throws DRDAProtocolException
0: 	{
0: 		int codePoint = getCodePoint();
0: 		if (codePoint != codePointCheck)
0: 			agent.missingCodePoint(codePoint);
0: 		return codePoint;
0: 	}
0: 	/**
0: 	 * The following routines read different types from the input stream
0: 	 * Data can be in network order or platform order depending on whether the
0: 	 * data is part of the protocol or data being received
0: 	 * The platform is determined by EXCSAT protocol
0: 	 */
1: 
0: 	/**
0: 	 * Read byte value
0: 	 * @return	value
0: 	 *
0: 	 * @exception DRDProtocolException
0: 	 */
0: 	protected byte readByte () throws DRDAProtocolException
0: 	{
0: 		ensureBLayerDataInBuffer (1, ADJUST_LENGTHS);
0: 		return (byte) (buffer[pos++] & 0xff);
0: 	}
1: 
0: 	/**
0: 	 * Read byte value and mask out high order bytes before returning
0: 	 * @return value
0: 	 */
0: 	protected int readUnsignedByte () throws DRDAProtocolException
0: 	{
0: 		ensureBLayerDataInBuffer (1, ADJUST_LENGTHS);
0: 		return (int ) (buffer[pos++] & 0xff);
0: 	}
1: 
0: 	/**
0: 	 * Read network short value
0: 	 * @return	value
0: 	 *
0: 	 * @exception DRDProtocolException
0: 	 */
0: 	protected int readNetworkShort () throws DRDAProtocolException
0: 	{
0: 		ensureBLayerDataInBuffer (2, ADJUST_LENGTHS);
0: 		return ((buffer[pos++] & 0xff) << 8) +
0: 		  ((buffer[pos++] & 0xff) << 0);
0: 	}
1: 
0: 	/**
0: 	 * Read signed network short value
0: 	 * @return	value
0: 	 *
0: 	 * @exception DRDProtocolException
0: 	 */
0: 	protected int readSignedNetworkShort () throws DRDAProtocolException
0: 	{
0: 		ensureBLayerDataInBuffer (2, ADJUST_LENGTHS);
0: 		return (short)(((buffer[pos++] & 0xff) << 8) +
0: 		  ((buffer[pos++] & 0xff) << 0));
0: 	}
0: 	/**
0: 	 * Read platform short value
0: 	 * @return	value
0: 	 *
0: 	 * @exception DRDProtocolException
0: 	 */
0: 	protected short readShort (int byteOrder) throws DRDAProtocolException
0: 	{
0: 		ensureBLayerDataInBuffer (2, ADJUST_LENGTHS);
0: 		short s = SignedBinary.getShort (buffer, pos, byteOrder);
1: 
0: 		pos += 2;
1: 
0: 		return s;
0: 	}
1: 
0: 	/**
0: 	 * Read network int value
0: 	 * @return	value
0: 	 *
0: 	 * @exception DRDProtocolException
0: 	 */
0: 	protected int readNetworkInt () throws DRDAProtocolException
0: 	{
0: 		ensureBLayerDataInBuffer (4, ADJUST_LENGTHS);
0: 		return ((buffer[pos++] & 0xff) << 24) +
0: 		       ((buffer[pos++] & 0xff) << 16) +
0: 		       ((buffer[pos++] & 0xff) << 8) +
0: 		       ((buffer[pos++] & 0xff) << 0);
0: 	}
1: 
0: 	/**
0: 	 * Read platform int value
0: 	 * @return	value
0: 	 *
0: 	 * @exception DRDProtocolException
0: 	 */
0: 	protected int readInt (int byteOrder) throws DRDAProtocolException
0: 	{
0: 		ensureBLayerDataInBuffer (4, ADJUST_LENGTHS);
0: 		int i = SignedBinary.getInt (buffer, pos, byteOrder);
1: 
0: 		pos += 4;
1: 
0: 		return i;
0: 	}
1: 
0: 	/**
0: 	 * Read network long value
0: 	 * @return	value
0: 	 *
0: 	 * @exception DRDProtocolException
0: 	 */
0: 	protected long readNetworkLong () throws DRDAProtocolException
0: 	{
0: 		ensureBLayerDataInBuffer (8, ADJUST_LENGTHS);
1: 
0: 		return ((buffer[pos++] & 0xffL) << 56) +
0: 		       ((buffer[pos++] & 0xffL) << 48) +
0: 		       ((buffer[pos++] & 0xffL) << 40) +
0: 		       ((buffer[pos++] & 0xffL) << 32) +
0: 		       ((buffer[pos++] & 0xffL) << 24) +
0: 		       ((buffer[pos++] & 0xffL) << 16) +
0: 		       ((buffer[pos++] & 0xffL) << 8) +
0: 		       ((buffer[pos++] & 0xffL) << 0);
0: 	}
1: 
1: 	
0: 	/**
0: 	 * Read network six byte value and put it in a long v
0: 	 * @return	value
0: 	 *
0: 	 * @exception DRDProtocolException
0: 	 */
0: 	protected long readNetworkSixByteLong() throws DRDAProtocolException
0: 	{
0: 		ensureBLayerDataInBuffer (6, ADJUST_LENGTHS);
1: 
0: 		return (
0: 				((buffer[pos++] & 0xffL) << 40) +
0: 		       ((buffer[pos++] & 0xffL) << 32) +
0: 		       ((buffer[pos++] & 0xffL) << 24) +
0: 		       ((buffer[pos++] & 0xffL) << 16) +
0: 		       ((buffer[pos++] & 0xffL) << 8) +
0: 		       ((buffer[pos++] & 0xffL) << 0));
0: 	}
1: 
0: 	/**
0: 	 * Read platform long value
0: 	 * @return	value
0: 	 *
0: 	 * @exception DRDProtocolException
0: 	 */
0: 	protected long readLong (int byteOrder) throws DRDAProtocolException
0: 	{
0: 		ensureBLayerDataInBuffer (8, ADJUST_LENGTHS);
0: 		long l = SignedBinary.getLong (buffer, pos, byteOrder);
1: 
0: 		pos += 8;
1: 
0: 		return l;
0: 	}
1: 
0: 	/**
0: 	 * Read platform float value
0: 	 * @return	value
0: 	 *
0: 	 * @exception DRDProtocolException
0: 	 */
0: 	protected float readFloat(int byteOrder) throws DRDAProtocolException
0: 	{
0: 		return Float.intBitsToFloat(readInt(byteOrder));
0: 	}
1: 
0: 	/**
0: 	 * Read platform double value
0: 	 * @return	value
0: 	 *
0: 	 * @exception DRDProtocolException
0: 	 */
0: 	protected double readDouble(int byteOrder) throws DRDAProtocolException
0: 	{
0: 		return Double.longBitsToDouble(readLong(byteOrder));
0: 	}
1: 
0: 	/**
0: 	 * Read a BigDecimal value
0: 	 * @param	precision of the BigDecimal
0: 	 * @param	scale of the BigDecimal
0: 	 * @return	value
0: 	 *
0: 	 * @exception DRDProtocolException
0: 	 */
0: 	protected BigDecimal readBigDecimal(int precision, int scale) throws DRDAProtocolException
0:     {
1:       // The byte-length of a packed decimal with precision p is always p/2 + 1
1:       int length = precision / 2 + 1;
1: 
0: 	  ensureBLayerDataInBuffer (length, ADJUST_LENGTHS);
1: 
1:       // check for sign.
1:       int signum;
1:       if ((buffer[pos+length-1] & 0x0F) == 0x0D)
1:         signum = -1;
1:       else
1:         signum =  1;
1: 
0:       if (precision <= 9) {
0:         // can be handled by int without overflow.
0:         int value = packedNybblesToInt(buffer, pos, 0, length*2-1);
1: 
1:         // convert value to a byte array of magnitude.
0:         byte[] magnitude = new byte[4];
0:         magnitude[0] = (byte)(value >>> 24);
0:         magnitude[1] = (byte)(value >>> 16);
0:         magnitude[2] = (byte)(value >>> 8);
0:         magnitude[3] = (byte)(value);
1: 
0: 		pos += length;
1:         return new java.math.BigDecimal (new java.math.BigInteger(signum, magnitude), scale);
0:       }
0:       else if (precision <= 18) {
1:         // can be handled by long without overflow.
1:         long value = packedNybblesToLong(buffer, pos, 0, length*2-1);
1: 
1:         // convert value to a byte array of magnitude.
0:         byte[] magnitude = new byte[8];
0:         magnitude[0] = (byte)(value >>> 56);
0:         magnitude[1] = (byte)(value >>> 48);
0:         magnitude[2] = (byte)(value >>> 40);
0:         magnitude[3] = (byte)(value >>> 32);
0:         magnitude[4] = (byte)(value >>> 24);
0:         magnitude[5] = (byte)(value >>> 16);
0:         magnitude[6] = (byte)(value >>>  8);
0:         magnitude[7] = (byte)(value);
1: 
0: 		pos += length;
1:         return new java.math.BigDecimal (new java.math.BigInteger(signum, magnitude), scale);
0:       }
1:       else if (precision <= 27) {
1:         // get the value of last 9 digits (5 bytes).
1:         int lo = packedNybblesToInt(buffer, pos, (length-5)*2, 9);
1:         // get the value of another 9 digits (5 bytes).
1:         int me = packedNybblesToInt(buffer, pos, (length-10)*2+1, 9);
1:         // get the value of the rest digits.
1:         int hi = packedNybblesToInt(buffer, pos, 0, (length-10)*2+1);
1: 
1:         // compute the int array of magnitude.
1:         int[] value = computeMagnitude(new int[] {hi, me, lo});
1: 
1:         // convert value to a byte array of magnitude.
1:         byte[] magnitude = new byte[12];
1:         magnitude[0]  = (byte)(value[0] >>> 24);
1:         magnitude[1]  = (byte)(value[0] >>> 16);
1:         magnitude[2]  = (byte)(value[0] >>> 8);
1:         magnitude[3]  = (byte)(value[0]);
1:         magnitude[4]  = (byte)(value[1] >>> 24);
1:         magnitude[5]  = (byte)(value[1] >>> 16);
1:         magnitude[6]  = (byte)(value[1] >>> 8);
1:         magnitude[7]  = (byte)(value[1]);
1:         magnitude[8]  = (byte)(value[2] >>> 24);
1:         magnitude[9]  = (byte)(value[2] >>> 16);
1:         magnitude[10] = (byte)(value[2] >>> 8);
1:         magnitude[11] = (byte)(value[2]);
1: 
0: 		pos += length;
1:         return new java.math.BigDecimal (new java.math.BigInteger(signum, magnitude), scale);
0:       }
1:       else if (precision <= 31) {
1:         // get the value of last 9 digits (5 bytes).
1:         int lo   = packedNybblesToInt(buffer, pos, (length-5)*2, 9);
1:         // get the value of another 9 digits (5 bytes).
1:         int meLo = packedNybblesToInt(buffer, pos, (length-10)*2+1, 9);
1:         // get the value of another 9 digits (5 bytes).
1:         int meHi = packedNybblesToInt(buffer, pos, (length-14)*2, 9);
1:         // get the value of the rest digits.
1:         int hi   = packedNybblesToInt(buffer, pos, 0, (length-14)*2);
1: 
1:         // compute the int array of magnitude.
1:         int[] value = computeMagnitude(new int[] {hi, meHi, meLo, lo});
1: 
1:         // convert value to a byte array of magnitude.
1:         byte[] magnitude = new byte[16];
1:         magnitude[0]  = (byte)(value[0] >>> 24);
1:         magnitude[1]  = (byte)(value[0] >>> 16);
1:         magnitude[2]  = (byte)(value[0] >>> 8);
1:         magnitude[3]  = (byte)(value[0]);
1:         magnitude[4]  = (byte)(value[1] >>> 24);
1:         magnitude[5]  = (byte)(value[1] >>> 16);
1:         magnitude[6]  = (byte)(value[1] >>> 8);
1:         magnitude[7]  = (byte)(value[1]);
1:         magnitude[8]  = (byte)(value[2] >>> 24);
1:         magnitude[9]  = (byte)(value[2] >>> 16);
1:         magnitude[10] = (byte)(value[2] >>> 8);
1:         magnitude[11] = (byte)(value[2]);
1:         magnitude[12] = (byte)(value[3] >>> 24);
1:         magnitude[13] = (byte)(value[3] >>> 16);
1:         magnitude[14] = (byte)(value[3] >>> 8);
1:         magnitude[15] = (byte)(value[3]);
1: 
0: 		pos += length;
1:         return new java.math.BigDecimal (new java.math.BigInteger(signum, magnitude), scale);
0:       }
1:       else {
0: 		pos += length;
1:         // throw an exception here if nibbles is greater than 31
1:         throw new java.lang.IllegalArgumentException("Decimal may only be up to 31 digits!");
0:       }
0:     }
1: 
1: 	
1: 
0: 	byte[] getExtData (boolean checkNullability) throws DRDAProtocolException
0: 	{
0: 		return  getExtData(ddmScalarLen, checkNullability);
0: 	}
1: 
1: 
0: 	byte[] getExtData (long desiredLength, boolean checkNullability) throws DRDAProtocolException
0:   {
1:     boolean readHeader;
1:     int copySize;
0:     ByteArrayOutputStream baos;
1:     boolean isLengthAndNullabilityUnknown = false;
1: 
1: 	
0: 	if (desiredLength != -1) {
1:         // allocate a stream based on a known amount of data
0:         baos = new ByteArrayOutputStream ((int) desiredLength);
0: 	}
1: 	else {
1:         // allocate a stream to hold an unknown amount of data
0:         baos = new ByteArrayOutputStream ();
1:         //isLengthAndNullabilityUnknown = true;
0: 		// If we aren't given a  length get the whole thing.
0: 		desiredLength = MAX_EXTDTA_SIZE;
0: 	}
1: 	
1: 
1:     // check for a null EXTDTA value, if it is nullable and if streaming
1:     if (checkNullability)
1:       if (isEXTDTANull())
0:         return null;
1: 
1:     // set the amount to read for the first segment
0: 	copySize = (int) Math.min(dssLength,desiredLength); //note: has already been adjusted for headers
1: 
1: 
1:     //if (checkNullability)  // don't count the null byte we've already read
0: 	//copySize--;
1: 
1:     do {
1:       // determine if a continuation header needs to be read after the data
1:       if (dssIsContinued)
1:         readHeader = true;
1:       else
1:         readHeader = false;
1: 
0:       // read the segment
0:       ensureALayerDataInBuffer (copySize);
0:       adjustLengths (copySize);
1:       baos.write (buffer, pos, copySize);
0:       pos += copySize;
0: 	  desiredLength -= copySize;
1: 
1:       // read the continuation header, if necessary
1:       if (readHeader)
1:         readDSSContinuationHeader ();
1: 
0: 	  copySize = (int) Math.min(dssLength,desiredLength); //note: has already been adjusted for headers
1: 
0:     }
1:     while (readHeader == true && desiredLength > 0);
1: 
1:     return baos.toByteArray();
0:   }
1: 
1: 
1:   // reads a DSS continuation header
1:   // prereq: pos is positioned on the first byte of the two-byte header
1:   // post:   dssIsContinued is set to true if the continuation bit is on, false otherwise
1:   //         dssLength is set to DssConstants.MAXDSS_LEN - 2 (don't count the header for the next read)
1:   // helper method for getEXTDTAData
0: 	private void readDSSContinuationHeader () throws DRDAProtocolException
0:   {
1:     ensureALayerDataInBuffer(2);
1: 
1:     dssLength =
1:       ((buffer[pos++]&0xFF) << 8) +
1:       ((buffer[pos++]&0xFF) << 0);
1: 
1:     if ((dssLength & 0x8000) == 0x8000) {
1:       dssLength = DssConstants.MAX_DSS_LENGTH;
1:       dssIsContinued = true;
0:     }
1:     else {
1:       dssIsContinued = false;
0:     }
1:     // it is a syntax error if the dss continuation header length
1:     // is less than or equal to two
1:     if (dssLength <= 2) {
0: 		agent.throwSyntaxrm(CodePoint.SYNERRCD_DSS_CONT_LESS_OR_EQUAL_2,
0: 							   DRDAProtocolException.NO_CODPNT_ARG);
0:     }
1: 
1:     dssLength -= 2;  // avoid consuming the DSS cont header
0:   }
1: 
1: // checks the null EXTDTA byte
1:   // returns true if null, false otherwise
1:   // helper method for getEXTDTAData
1:   private boolean isEXTDTANull () throws DRDAProtocolException
0:   {
1:     // make sure that the null byte is in the buffer
1:     ensureALayerDataInBuffer (1);
1:     adjustLengths (1);
1: 
1:     // examine the null byte
1:     byte nullByte = buffer[pos++];
1:     if (nullByte == (byte)0x00)
1:       return false;
1: 
1:     return true;
0:   }
1: 
1: 
0:    /**
1:     * Convert a range of packed nybbles (up to 9 digits without overflow) to an int.
1:     * Note that for performance purpose, it does not do array-out-of-bound checking.
0: 	* @param	buffer to read from
0: 	* @param	offset in the buffer
0: 	* @param	start nybble
0: 	* @param	number of nybbles
0: 	* @return	an int value
0:     */
1:     private int packedNybblesToInt (byte[] buffer,
1:                                          int offset,
1:                                          int startNybble,
1:                                          int numberOfNybbles)
0:     {
1:       int value = 0;
1: 
1:       int i = startNybble / 2;
1:       if ((startNybble % 2) != 0) {
1:         // process low nybble of the first byte if necessary.
1:         value += buffer[offset+i] & 0x0F;
1:         i++;
0:       }
1: 
1:       int endNybble = startNybble + numberOfNybbles -1;
1:       for (; i<(endNybble+1)/2; i++) {
1:         value = value*10 + ((buffer[offset+i] & 0xF0) >>> 4); // high nybble.
1:         value = value*10 +  (buffer[offset+i] & 0x0F);        // low nybble.
0:       }
1: 
1:       if ((endNybble % 2) == 0) {
1:         // process high nybble of the last byte if necessary.
1:         value = value*10 + ((buffer[offset+i] & 0xF0) >>> 4);
0:       }
1: 
0:       return value;
0:     }
1: 
0:     /**
1:      * Convert a range of packed nybbles (up to 18 digits without overflow) to a long.
1:      * Note that for performance purpose, it does not do array-out-of-bound checking.
0: 	 * @param	buffer to read from
0: 	 * @param	offset in the buffer
0: 	 * @param	start nybble
0: 	 * @param	number of nybbles
0: 	 * @return	an long value
0:      */
1:     private long packedNybblesToLong (byte[] buffer,
1:                                            int offset,
1:                                            int startNybble,
1:                                            int numberOfNybbles)
0:     {
1:       long value = 0;
1: 
1:       int i = startNybble / 2;
1:       if ((startNybble % 2) != 0) {
1:         // process low nybble of the first byte if necessary.
1:         value += buffer[offset+i] & 0x0F;
1:         i++;
0:       }
1: 
1:       int endNybble = startNybble + numberOfNybbles -1;
1:       for (; i<(endNybble+1)/2; i++) {
1:         value = value*10 + ((buffer[offset+i] & 0xF0) >>> 4); // high nybble.
1:         value = value*10 +  (buffer[offset+i] & 0x0F);        // low nybble.
0:       }
1: 
1:       if ((endNybble % 2) == 0) {
1:         // process high nybble of the last byte if necessary.
1:         value = value*10 + ((buffer[offset+i] & 0xF0) >>> 4);
0:       }
1: 
0:  	  return value;
0: 	}
1: 
0:     /**
1:      * Compute the int array of magnitude from input value segments.
0: 	 * @param	input value segments
0: 	 * @return	array of int magnitudes
0:      */
1:     private int[] computeMagnitude(int[] input)
0:     {
1:         int length = input.length;
1:         int[] mag = new int[length];
1: 
1:         mag[length-1] = input[length-1];
1:         for (int i=0; i<length-1; i++) {
1:           int carry = 0;
1:           int j = tenRadixMagnitude[i].length-1;
1:           int k = length-1;
1:           for (; j>=0; j--, k--) {
1:             long product = (input[length-2-i] & 0xFFFFFFFFL) * (tenRadixMagnitude[i][j] & 0xFFFFFFFFL)
1:                          + (mag[k] & 0xFFFFFFFFL) // add previous value
1:                          + (carry & 0xFFFFFFFFL); // add carry
1:             carry  = (int) (product >>> 32);
1:             mag[k] = (int) (product & 0xFFFFFFFFL);
0:           }
1:           mag[k] = (int) carry;
0:         }
1:         return mag;
0:     }
1: 
0: 	/**
0: 	 * Read boolean value
0: 	 * @return	value
0: 	 *
0: 	 * @exception DRDProtocolException
0: 	 */
0: 	protected boolean readBoolean () throws DRDAProtocolException
0: 	{
0: 		ensureBLayerDataInBuffer (1, ADJUST_LENGTHS);
0: 		return buffer[pos++] != 0;
0: 	}
1: 
0: 	/**
0: 	 * Read encrypted string
0: 	 * @param   decryptM  decryption manager
0: 	 * @param   security mechanism
0: 	 * @param   initVector   initialization vector for cipher
0: 	 * @param   sourcePublicKey  public key (as in Deffie-Hellman algorithm)
0: 	 *                           from source (encryptor)
0: 	 * @return  decrypted string
0: 	 *
0: 	 * @exception DRDProtocolException, SQLException(wrapping any exception in decryption)
0: 	 */
0: 	protected String readEncryptedString (DecryptionManager decryptM, int securityMechanism,
0: 										 byte[] initVector, byte[] sourcePublicKey)
0: 			throws DRDAProtocolException, java.sql.SQLException
0: 	{
0: 		byte[] cipherText = readBytes();
0: 		byte[] plainText = null;
0: 		plainText = decryptM.decryptData(cipherText, securityMechanism, initVector,
0: 											 sourcePublicKey);
0: 		if (plainText == null)
0: 			return null;
1: 		else
0: 			return ccsidManager.convertToUCS2(plainText);
0: 	}
1: 
0: 	/**
0: 	 * Read string value
0: 	 * Strings in DRDA protocol are encoded in EBCDIC by default so we
0: 	 * need to convert to UCS2
0: 	 * @param length  - length of string to read
0: 	 * @return value
0: 	 *
0: 	 * @exception DRDProtocolException
0: 	 */
0: 	protected String readString (int length) throws DRDAProtocolException
0: 	{
0: 		ensureBLayerDataInBuffer (length, ADJUST_LENGTHS);
1: 
0: 		String result = ccsidManager.convertToUCS2 (buffer, pos, length);
0: 		pos += length;
0: 		return result;
0: 	}
1: 
0: 	/**
0: 	 * Read encoded string value
0: 	 * @param length  - length of string to read
0: 	 * @return value
0: 	 *
0: 	 * @exception DRDProtocolException
0: 	 */
0: 	protected String readString (int length, String encoding) 
0: 		throws DRDAProtocolException
0: 	{
0: 		ensureBLayerDataInBuffer (length, ADJUST_LENGTHS);
0: 		String s = null;
1: 
0: 		try {
0: 		  s = new String (buffer, pos, length, encoding);
0: 		}
0: 		catch (java.io.UnsupportedEncodingException e) {
0: 			agent.agentError("UnsupportedEncodingException in readString, encoding = " 
0: 					+ encoding);
0: 			e.printStackTrace(agent.getServer().logWriter);
0: 		}
1: 		
0: 		pos += length;
0: 		return s;
0: 	}
1: 
0: 	/**
0: 	 * Read string value in DDM data with default encoding
0: 	 * @return value
0: 	 *
0: 	 * @exception DRDProtocolException
0: 	 */
0: 	protected String readStringData()
0: 		throws DRDAProtocolException
0: 	{
0: 		return readString((int)ddmScalarLen, DB2jServerImpl.DEFAULT_ENCODING);
0: 	}
1: 
0: 	/**
0: 	 * Read specified length of string value in DDM data with default encoding
0: 	 * @param length  - length of string to read
0: 	 * @return value
0: 	 *
0: 	 * @exception DRDProtocolException
0: 	 */
0: 	protected String readStringData(int length)
0: 		throws DRDAProtocolException
0: 	{
0: 		return readString(length, DB2jServerImpl.DEFAULT_ENCODING);
0: 	}
1: 
0: 	/**
0: 	 * Read length delimited string value in DDM data with default encoding
0: 	 * @return value
0: 	 *
0: 	 * @exception DRDProtocolException
0: 	 */
0: 	protected String readLDStringData(String encoding)
0: 		throws DRDAProtocolException
0: 	{
0: 		int length = readNetworkShort();
0: 		return readString(length, encoding);
0: 	}
1: 
0: 	/**
0: 	 * Read string value
0: 	 * @param length  - length of string to read
0: 	 * @return value
0: 	 *
0: 	 * @exception DRDProtocolException
0: 	 */
0: 	protected String readString () throws DRDAProtocolException
0: 	{
0: 		return readString((int)ddmScalarLen);
0: 	}
1: 
0: 	/**
0: 	 * Read byte string value
0: 	 * @param length  - length of string to read
0: 	 * @return byte array
0: 	 *
0: 	 * @exception DRDProtocolException
0: 	 */
0: 	protected byte[] readBytes (int length) throws DRDAProtocolException
0: 	{
0: 		byte[] b;
1: 
0: 		if (length < dssLength)
0: 		{
0: 			ensureBLayerDataInBuffer (length, ADJUST_LENGTHS);
0: 		    b = new byte[length];
0: 			System.arraycopy(buffer,pos,b,0,length);
0: 			pos +=length;
0: 		}
1: 		else
0: 			b = getExtData(length,false);
0: 		return b;
0: 	}
1: 	
0: 	/**
0: 	 * Read byte string value
0: 	 * @return byte array
0: 	 *
0: 	 * @exception DRDProtocolException
0: 	 */
0: 	protected byte[] readBytes () throws DRDAProtocolException
0: 	{
0: 		return readBytes((int)ddmScalarLen);
0: 	}
1: 
0: 	/**
0: 	 * Skip byte string value
0: 	 * @param length  - length of string to skip
0: 	 *
0: 	 * @exception DRDProtocolException
0: 	 */
0: 	protected void skipBytes (int length) throws DRDAProtocolException
0: 	{
0: 		ensureBLayerDataInBuffer (length, ADJUST_LENGTHS);
0: 		pos += length;
0: 	}
1: 
0: 	/**
0: 	 * Skip byte string value
0: 	 *
0: 	 * @exception DRDAProtocolException
0: 	 */
0: 	protected void skipBytes () throws DRDAProtocolException
0: 	{
0: 		skipBytes((int)ddmScalarLen);
0: 	}
1: 
0: 	/**
0: 	 * Skip remaining DSS
0: 	 *
0: 	 * @exception DRDAProtocolException
0: 	 */
0: 	protected void skipDss() throws DRDAProtocolException
0: 	{
0: 		skipBytes((int)dssLength);
0: 		topDdmCollectionStack = EMPTY_STACK;
0: 		ddmScalarLen = 0;
0: 		dssLength = 0;
1: 
0: 	}
1: 
0: 	protected void clearBuffer() throws DRDAProtocolException
0: 	{
0: 		skipBytes(java.lang.Math.min(dssLength, count - pos));
0: 	}
1: 
0: 	/**
0: 	 * Convert EBCDIC byte array to unicode string
0: 	 *
0: 	 * @param 	buf	- byte array
0: 	 * @return string
0: 	 */
0: 	protected String convertBytes(byte[] buf)
0: 	{
0: 		return ccsidManager.convertToUCS2 (buf, 0, buf.length);
0: 	}
1: 
0: 	// Private methods
0: 	/**
0: 	 * Adjust remaining length
0: 	 *
0: 	 * @param length - adjustment length
0: 	 */
0: 	private void adjustLengths(int length)
0: 	{
0: 		ddmScalarLen -= length;
0: 		for (int i = 0; i <= topDdmCollectionStack; i++) {
0: 		  ddmCollectionLenStack[i] -= length;
0: 		}
0: 		dssLength -= length;
0: 	}
1: 
0: 	/********************************************************************/
0: 	/*   NetworkServerControl  command protocol reading routines        
0: 	 */
0: 	/********************************************************************/
0: 	/**
0: 	 * Read string value
0: 	 * @param length  - length of string to read
0: 	 * @return value
0: 	 *
0: 	 * @exception DRDProtocolException
0: 	 */
0: 	protected String readCmdString (int length) throws DRDAProtocolException, java.io.UnsupportedEncodingException
0: 	{
0: 		if (length == 0)
0: 			return null;
1: 
0: 		ensureBLayerDataInBuffer (length, ADJUST_LENGTHS);
0: 		String result = new String (buffer, pos, length,
0: 										DB2jServerImpl.DEFAULT_ENCODING);
0: 		pos += length;
0: 		return result;
0: 	}
0: 	/**
0: 	 * Read string value
0: 	 * @return value
0: 	 *
0: 	 * @exception DRDProtocolException
0: 	 */
0: 	protected String readCmdString () throws DRDAProtocolException, java.io.UnsupportedEncodingException
0: 	{
0: 		int length = readNetworkShort();
0: 		return readCmdString(length);
1: 		
0: 	}
1: 
0: 	/**************************************************************************/
0: 	/*   Private methods
0: 	/**************************************************************************/
0: 	/**
0: 	 * Make sure a certain amount of Layer A data is in the buffer.
0: 	 * The data will be in the buffer after this method is called.
0: 	 *
0: 	 * @param desiredDataSize - amount of data we need
0: 	 *
0: 	 * @exception	DRDAProtocolException
0: 	 */
0: 	private void ensureALayerDataInBuffer (int desiredDataSize) 
0: 		throws DRDAProtocolException
0: 	{
0: 		// calulate the the number of bytes in the buffer.
0: 		int avail = count - pos;
1: 
0: 		// read more bytes off the network if the data is not in the buffer already.
0: 		if (avail < desiredDataSize) 
0: 		{
0: 		  fill (desiredDataSize - avail);
0: 		}
0: 	}
0: 	/**
0: 	 * Make sure a certain amount of Layer B data is in the buffer.
0: 	 * The data will be in the buffer after this method is called.
0: 	 *
0: 	 * @param desiredDataSize - amount of data we need
0: 	 * @param adjustLen	- whether to adjust the remaining lengths
0: 	 *
0: 	 * @exception DRDProtocolException
0: 	 */
0: 	private void ensureBLayerDataInBuffer (int desiredDataSize, boolean adjustLen) 
0: 		throws DRDAProtocolException
0: 	{
1: 		if (dssIsContinued) 
0: 		{
0: 			if (desiredDataSize > dssLength) 
0: 			{
0: 				int continueDssHeaderCount =
0: 					(((desiredDataSize - dssLength) / DssConstants.MAX_DSS_LENGTH) + 1);
0: 				compressBLayerData (continueDssHeaderCount);
0: 			}
0: 		}
1: 		else 
0: 		{
0: 			ensureALayerDataInBuffer (desiredDataSize);
0: 		}
0: 		if (adjustLen)
0: 			adjustLengths(desiredDataSize);
0: 	}
1: 
0: 	/**
0: 	 * Compress B Layer data if extended total length is used
0: 	 * by removing the continuation headers
0: 	 *
0: 	 * @param continueDssHeaderCount - amount of data we need
0: 	 *
0: 	 * @exception	throws DRDAProtocolException
0: 	 */
0: 	private void compressBLayerData (int continueDssHeaderCount) 
0: 		throws DRDAProtocolException
0: 	{
1: 
1: 		
0: 		// jump to the last continuation header.
0: 		int tempPos = 0;
0: 		for (int i = 0; i < continueDssHeaderCount; i++) 
0: 		{
0: 			// the first may be less than the size of a full DSS
0: 			if (i == 0) 
0: 			{
0: 				// only jump by the number of bytes remaining in the current DSS
0: 				tempPos = pos + dssLength;
0: 			}
1: 			else 
0: 			{
0: 				// all other jumps are for a full continued DSS
0: 				tempPos += DssConstants.MAX_DSS_LENGTH;
0: 			}
0: 		}
1: 
1: 
0: 		// for each of the DSS headers to remove,
0: 		// read out the continuation header and increment the DSS length by the
0: 		// size of the continuation bytes,	then shift the continuation data as needed.
0: 		int shiftSize = 0;
0: 		int bytesToShift = 0;
0: 		int continueHeaderLength = 0;
0: 		int newdssLength = 0;
1: 
1: 
0: 		for (int i = 0; i < continueDssHeaderCount; i++) 
0: 		{
0: 			continueHeaderLength = ((buffer[tempPos] & 0xff) << 8) +
0: 				((buffer[tempPos + 1] & 0xff) << 0);
1: 
0: 			if (i == 0) 
0: 			{
0: 				// if this is the last one (farthest down stream and first to strip out)
1: 
0: 				if ((continueHeaderLength & DssConstants.CONTINUATION_BIT) 
0: 						== DssConstants.CONTINUATION_BIT)
0: 				{
0: 				  // the last DSS header is again continued
0: 				  continueHeaderLength = DssConstants.MAX_DSS_LENGTH;
1: 				  dssIsContinued = true;
0: 				}
1: 				else 
0: 				{
0: 				  // the last DSS header was not contiued so update continue state flag
1: 				  dssIsContinued = false;
0: 				}
0: 				// the very first shift size is 2
0: 				shiftSize = 2;
0: 			}
1: 			else 
0: 			{
0: 				// already removed the last header so make sure the chaining flag is on
0: 				if ((continueHeaderLength & DssConstants.CONTINUATION_BIT) == 
0: 						DssConstants.CONTINUATION_BIT)
0: 				{
0: 				  continueHeaderLength = DssConstants.MAX_DSS_LENGTH;
0: 				}
1: 				else 
0: 				{
0: 				  // this is a syntax error but not really certain which one.
0: 				  // for now pick 0x02 which is DSS header Length does not 
0: 				  // match the number
0: 				    // of bytes of data found.
0: 					agent.throwSyntaxrm(CodePoint.SYNERRCD_DSS_LENGTH_BYTE_NUMBER_MISMATCH,
0: 									   DRDAProtocolException.NO_CODPNT_ARG);
0: 				}
0: 				// increase the shift size by 2
0: 				shiftSize += 2;
0: 			}
1: 
0: 			// it is a syntax error if the DSS continuation is less 
0: 			// than or equal to two
0: 			if (continueHeaderLength <= 2) 
0: 			{
0: 				agent.throwSyntaxrm(CodePoint.SYNERRCD_DSS_CONT_LESS_OR_EQUAL_2,
0: 							   DRDAProtocolException.NO_CODPNT_ARG);
0: 			}
1: 
0: 			newdssLength += continueHeaderLength;
1: 
0: 			// calculate the number of bytes to shift
0: 			if (i == (continueDssHeaderCount - 1))
0: 				bytesToShift = DssConstants.MAX_DSS_LENGTH;
1: 			else
0: 				bytesToShift = dssLength;
1: 
0: 			tempPos -= (shiftSize - 1);
0: 			System.arraycopy(buffer, tempPos, buffer, tempPos - bytesToShift +
0: 							 shiftSize , bytesToShift);
0: 			tempPos -= bytesToShift;
0: 			tempPos += (shiftSize + 1);
0: 		}
0: 		// reposition the start of the data after the final DSS shift.
0: 		pos = tempPos;
0: 	}
1: 
0: 	/**
0: 	 * Methods to manage the data buffer.
0: 	 * Methods orginally from JCC
0: 	 * RESOLVE: need to check if this is the best performing way of doing this
0: 	 */
1: 
0: 	/**
0: 	 * This is a helper method which shifts the buffered bytes from
0: 	 * wherever they are in the current buffer to the beginning of
0: 	 * different buffer (note these buffers could be the same).
0: 	 * State information is updated as needed after the shift.
0: 	 * @param destinationBuffer - buffer to shift data to
0: 	 */
0: 	private void shiftBuffer (byte[] destinationBuffer)
0: 	{
0: 		// calculate the size of the data in the current buffer.
0: 		int sz = count - pos;
0: 		if (SanityManager.DEBUG) {
0: 			if ((sz < 0 || pos < 0) )
0: 			{
0: 				SanityManager.THROWASSERT(
0: 					      "Unexpected data size or position. sz=" + sz + 
0: 						  " count=" + count +" pos=" + pos);
0: 			}
0: 		}
1: 		
0: 		// copy this data to the new buffer startsing at position 0.
0: 		System.arraycopy (buffer, pos, destinationBuffer, 0, sz);
1: 
0: 		// update the state information for data in the new buffer.
0: 		pos = 0;
0: 		count = sz;
1: 
0: 		// replace the old buffer with the new buffer.
0: 		buffer = destinationBuffer;
0: 	}
0: 	/**
0: 	 * This method makes sure there is enough room in the buffer
0: 	 * for a certain number of bytes.  This method will allocate
0: 	 * a new buffer if needed and shift the bytes in the current buffer
0: 	 * to make ensure space is available for a fill.  Right now
0: 	 * this method will shift bytes as needed to make sure there is
0: 	 * as much room as possible in the buffer before trying to
0: 	 * do the read.  The idea is to try to have space to get as much data as possible
0: 	 * if we need to do a read on the socket's stream.
0: 	 *
0: 	 * @param desiredSpace - amount of data we need
0: 	 */
0: 	private void ensureSpaceInBufferForFill (int desiredSpace)
0: 	{
0: 		// calculate the total unused space in the buffer.
0: 		// this includes any space at the end of the buffer and any free
0: 		// space at the beginning resulting from bytes already read.
0: 		int currentAvailableSpace = (buffer.length - count) + pos;
1: 
0: 		// check to see if there is enough free space.
0: 		if (currentAvailableSpace < desiredSpace) {
1: 
0: 			// there is not enough free space so we need more storage.
0: 			// we are going to double the buffer unless that happens to still be 
0: 			// too small. If more than double the buffer is needed, 
0: 			// use the smallest amount over this as possible.
0: 			int doubleBufferSize = (2 * buffer.length);
0: 			int minumNewBufferSize = (desiredSpace - currentAvailableSpace) + 
0: 				buffer.length;
0: 			int newsz = minumNewBufferSize <= doubleBufferSize ? 
0: 				doubleBufferSize : minumNewBufferSize;
1: 
0: 			byte[] newBuffer = new byte[newsz];
1: 
0: 			// shift everything from the old buffer to the new buffer
0: 			shiftBuffer (newBuffer);
0: 		}
1: 		else {
1: 
0: 			// there is enough free space in the buffer but let's make sure
0: 			// it is all at the end.
0: 			// this is also important because if we are going to do a read, 
0: 			// it would be nice
0: 			// to get as much data as possible and making room at the end 
0: 			// if the buffer helps to ensure this.
0: 			if (pos != 0) {
0: 				shiftBuffer (buffer);
0: 			}
0: 		}
0: 	}
1: 
0: 	/**
0: 	 * This method will attempt to read a minimum number of bytes
0: 	 * from the underlying stream.	This method will keep trying to
0: 	 * read bytes until it has obtained at least the minimum number.
0: 	 * @param minimumBytesNeeded - minimum required bytes
0: 	 *
0: 	 * @exception DRDProtocolException
0: 	 */
0: 	private void fill (int minimumBytesNeeded) throws DRDAProtocolException
0: 	{
0: 		// make sure that there is enough space in the buffer to hold
0: 		// the minimum number of bytes needed.
0: 		ensureSpaceInBufferForFill (minimumBytesNeeded);
1: 
0: 		// read until the minimum number of bytes needed is now in the buffer.
0: 		// hopefully the read method will return as many bytes as it can.
0: 		int totalBytesRead = 0;
0: 		int actualBytesRead = 0;
1: 		do {
0: 			try {
0: 				actualBytesRead = inputStream.read (
0: 				  buffer, count, buffer.length - count);
0: 			}
0: 			catch (java.io.IOException ioe) {
0: 				agent.markCommunicationsFailure ("DDMReader.fill()",
0: 				  "InputStream.read()", ioe.getMessage(), "*");
0: 			}
0: 			finally {
0: 				if ((dssTrace != null) && dssTrace.isComBufferTraceOn())
0: 				  dssTrace.writeComBufferData (buffer,
0: 				                               count,
0: 				                               actualBytesRead,
0: 				                               DssTrace.TYPE_TRACE_RECEIVE,
0: 				                               "Request",
0: 				                               "fill",
0: 				                               5);
0: 			}
0: 			count += actualBytesRead;
0: 			totalBytesRead += actualBytesRead;
1: 
0: 		}
0: 		while ((totalBytesRead < minimumBytesNeeded) && (actualBytesRead != -1));
0: 		if (actualBytesRead == -1) 
0: 		{
0: 			if (totalBytesRead < minimumBytesNeeded) 
0: 			{
0: 				agent.markCommunicationsFailure ("DDMReader.fill()",
0: 				  "InputStream.read()", "insufficient data", "*");
0: 			}
0: 		}
0: 	}
1: 
0: 	/**
0: 	 * Print a internal trace message
0: 	 */
0: 	private void trace(String msg)
0: 	{
0: 		if (agent != null)
0: 			agent.trace(msg);
0: 	}
1: 
0: 	protected String toDebugString(String indent)
0: 	{
0: 		String s = indent + "***** DDMReader toDebugString ******\n";
0: 		int buflen = 0;
0: 		if (buffer != null)
0: 			buflen = buffer.length;
0: 	   s += indent + "Reader buffer length = " + buffer.length + "\n";
0: 	   return s;
0: 	}
0: }
author:David Van Couvering
-------------------------------------------------------------------------------
commit:6b50965
/////////////////////////////////////////////////////////////////////////
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.drda
0:    (C) Copyright IBM Corp. 2001, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.drda;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import java.io.IOException;
0: import java.io.InputStream;
0: import java.io.ByteArrayOutputStream;
0: import java.math.BigDecimal;
0: 
0: /**
0: 	The DDMReader is used to read DRDA protocol.   DRDA Protocol is divided into
0: 	three layers corresponding to the DDM three-tier architecture. For each layer,
0: 	their is a DSS (Data Stream Structure) defined.
0: 		Layer A 	Communications management services
0: 		Layer B		Agent services
0: 		Layer C 	Data management services
0: 	<P>
0: 	At layer A are request, reply and data correlation, structure chaining,
0: 	continuation or termination of chains when errors are detected, interleaving
0: 	and multi-leaving request, reply, and data DSSs for multitasking environments.
0: 	For TCP/IP, the format of the DDM envelope is
0: 		2 bytes		Length of the data
0: 		1 byte		'D0' - indicates DDM data
0: 		1 byte		DDM format byte(DSSFMT) - type of DSS(RQSDSS,RPYDSS), whether it is
0: 					chained, information about the next chained DSS
0: 		2 bytes		request correlation identifier
0: 	<P>
0: 	The correlation identifier ties together a request, the request data and the
0: 	reply.  In a chained DSS, each request has a correlation identifier which
0: 	is higher than the previous request (all correlation identifiers must
0: 	be greater than 0).
0: 	<P>
0: 	At layer B are object mapping, object validation and command routing.
0: 	Layer B objects with data 5 bytes less than 32K bytes consist of
0: 		2 bytes		Length
0: 		2 bytes		Type of the object (code point)
0: 		Object data
0: 	Object data is either SCALAR or COLLECTION data.  Scalar data consists of
0: 	a string of bytes formatted as the class description of the object required.
0: 	Collections consist of a set of objects in which the entries in the collection
0: 	are nested within the length/ code point of the collection.
0: 	<P>
0: 	Layer B objects with data >=32763 bytes long format is 
0: 		2 bytes		Length - length of class, length, and extended total length fields
0: 					(high order bit set, indicating >=32763)
0: 		2 bytes		Type of the object (code point)
0: 		n bytes		Extended total length - length of the object
0: 					(n = Length - 4)
0: 		Object data
0: 	<P>
0: 	At layer C are services each class of DDM object provides.
0: 
0: 		    |-------------------------------------------|
0: 	Layer C | Specific	|	Specific	|	Specific	|
0: 		    | Commands	|	Replies		| Scalars and	|
0: 			| and their |  and their    | Collections   |
0: 			|-------------------------------------------|----------------|
0: 	Layer B | Commands  |    Reply		| Scalars and   | Communications |
0: 			|			|   Messages	| Collections	|                |
0: 			|-----------|---------------|---------------|----------------|
0: 	Layer A |  RQSDSS   |   RPYDSS		| OBJDSS		| CMNDSS         |
0: 			|           |               |               | Mapped Data    |
0: 			|-----------|---------------|---------------|----------------|
0: 			|                DDM Data Stream Structures                  |
0: 			|------------------------------------------------------------|
0: 			
0: 	DSS's may be chained so that more than one can be transmitted at a time
0: 	to improve performance.
0: 	For more details, see DRDA Volume 3 (Distributed Data Management(DDM)
0: 		Architecture (DDS definition)
0: */
0: class DDMReader
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 
0: 	private static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2001_2004;
0: 	private final static int DEFAULT_BUFFER_SIZE = 32767;
0: 	private final static int MAX_MARKS_NESTING = 10;
0: 	private final static int NO_CODEPOINT = -1;
0: 	private final static int EMPTY_STACK = -1;
0: 	private final static boolean ADJUST_LENGTHS = true;
0: 	private final static boolean NO_ADJUST_LENGTHS = false;
0: 	private final static long MAX_EXTDTA_SIZE= Long.MAX_VALUE;
0: 	private static boolean internalTrace = true;
0: 
0: 	// magnitude represented in an int array, used in BigDecimal conversion
0:     private static final int[][] tenRadixMagnitude = {
0:       { 0x3b9aca00 }, // 10^9
0:       { 0x0de0b6b3, 0xa7640000 }, // 10^18
0:       { 0x033b2e3c, 0x9fd0803c, 0xe8000000 }, // 10^27
0:     };
0: 
0: 	private DRDAConnThread agent;
0: 	private CcsidManager ccsidManager;
0: 
0: 	// data buffer
0: 	private byte[] buffer;
0: 	private int pos;
0: 	private int count;
0: 
0: 	// DDM object collection
0: 	// top of stack
0: 	private int topDdmCollectionStack;
0: 	// length of each object in the stack
0: 	private long[] ddmCollectionLenStack;
0: 
0: 	// DDM object length
0: 	private long ddmScalarLen;
0: 
0: 	// DSS Length
0: 	private int dssLength;
0: 
0: 	// DSS is larger than 32762 (continuation bit is set) so DSS is continued
0: 	private boolean dssIsContinued;
0: 
0: 	private boolean terminateChainOnErr;
0: 
0: 	// next DSS in the chain has the same correlator
0: 	private boolean dssIsChainedWithSameID;
0: 
0: 	// next DSS in the chain has a different correlator
0: 	private boolean dssIsChainedWithDiffID;
0: 	
0: 	// correlation id for the current DSS
0: 	private int dssCorrelationID;
0: 
0: 	// previous corelation id
0: 	private int prevCorrelationID;
0: 
0: 	// current server codepoint
0: 	private int svrcod;
0: 
0: 	// trace object of the associated session
0: 	private DssTrace dssTrace;
0: 
0: 	// input stream
0: 	private InputStream inputStream;
0: 
0: 	// constructor
0: 	protected DDMReader (DRDAConnThread agent, DssTrace dssTrace)
0: 	{
0: 		buffer = new byte[DEFAULT_BUFFER_SIZE];
0: 		ddmCollectionLenStack = new long[MAX_MARKS_NESTING];
0: 		initialize(agent, dssTrace);
0: 	}
0: 	/**
0: 	 * This constructor is used for testing the protocol
0: 	 * It is used by TestProto to read the protocol returned by the
0: 	 * server 
0: 	 */
0: 	protected DDMReader(CcsidManager ccsidManager, InputStream inputStream)
0: 	{
0: 		buffer = new byte[DEFAULT_BUFFER_SIZE];
0: 		ddmCollectionLenStack = new long[MAX_MARKS_NESTING];
0: 		this.ccsidManager = ccsidManager;
0: 		this.inputStream = inputStream;
0: 		initialize(null, null);
0: 		// turn off tracing
0: 		internalTrace = false;
0: 	}
0: 	/**
0: 	 * This initializer is used for testing the protocol
0: 	 * It is used by TestProto for the reader it uses
0: 	 */
0: 	protected void initialize(InputStream inputStream)
0: 	{
0: 		this.inputStream = inputStream;
0: 		initialize(null, null);
0: 	}
0: 
0: 	/**
0: 	 * Initialize values for this session, the reader is reused so we need to
0: 	 * set null and 0 values
0: 	 */
0: 	protected void initialize(DRDAConnThread agent, DssTrace dssTrace)
0:   	{
0: 		this.agent = agent;
0: 		if (agent != null)
0: 		{
0: 			ccsidManager = agent.ccsidManager;
0: 			inputStream = agent.getInputStream();
0: 		}
0: 		topDdmCollectionStack = EMPTY_STACK;
0:     	svrcod = 0;
0: 		pos = 0;
0: 		count = 0;
0: 		ddmScalarLen = 0;
0: 		dssLength = 0;
0: 		prevCorrelationID = DssConstants.CORRELATION_ID_UNKNOWN;
0: 		dssCorrelationID = DssConstants.CORRELATION_ID_UNKNOWN;
0: 		this.dssTrace = dssTrace;
0: 	}
0: 
0: 	protected boolean terminateChainOnErr()
0: 	{
0: 		return terminateChainOnErr;
0: 	}
0: 
0: 	/**
0: 	 * Next DSS has same correlator as current DSS
0: 	 *
0: 	 * @return true if next DSS has the same correlator as current DSS
0: 	 */
0:   	protected boolean isChainedWithSameID()
0:   	{
0:     	return dssIsChainedWithSameID;
0:   	}
0: 
0: 	/**
0: 	 * Next DSS has different correlator than current DSS
0: 	 *
0: 	 * @return true if next DSS has a different correlator than current DSS
0: 	 */
0:   	protected boolean isChainedWithDiffID()
0:   	{
0:     	return dssIsChainedWithDiffID;
0:   	}
0: 
0: 	/**
0: 	 * Length of current DDM object
0: 	 *
0: 	 * @return length of DDM object
0: 	 */
0: 	protected long getDdmLength()
0: 	{
0: 		return ddmScalarLen;
0: 	}
0: 
0: 	/**
0: 	 * Is there more in this DDM object
0: 	 *
0: 	 * @return true if DDM length is > 0
0: 	 */
0: 	protected boolean moreDdmData()
0: 	{
0: 		return ddmScalarLen > 0;
0: 	}
0: 
0: 	/**
0: 	 * Is there more in this DDS object
0: 	 *
0: 	 * @return true if DDS length is > 0
0: 	 */
0: 	protected boolean moreDssData()
0: 	{
0: 		return dssLength > 0;
0: 	}
0: 
0: 	/** 
0: 	 * Is there more data in the buffer
0: 	 *
0: 	 * @return true if there is more data in the buffer
0: 	 */
0: 	protected boolean moreData()
0: 	{
0: 		return (pos - count) > 0;
0: 	}
0: 
0: 	/**
0: 	 * Check for the command protocol
0: 	 *
0: 	 * @return true if this is a command; false otherwise
0: 	 *
0: 	 * @exception DRDProtocolException
0: 	 */
0: 	protected boolean isCmd() throws DRDAProtocolException, java.io.UnsupportedEncodingException
0: 	{
0: 		ensureALayerDataInBuffer(4);
0: 		String val = new String(buffer, 0, 4, DB2jServerImpl.DEFAULT_ENCODING);
0: 		return DB2jServerImpl.isCmd(val);
0: 	}
0: 
0: 	/**
0: 	 * Return buffer 
0: 	 *
0: 	 *
0: 	 * @return buffer
0: 	 */
0: 	protected byte [] getBuffer()
0: 	{
0: 		return buffer;
0: 	}
0: 
0: 	/**
0: 	 * Read DSS header
0: 	 * DSS Header format is 
0: 	 * 	2 bytes	- length
0: 	 *	1 byte	- 'D0'	- indicates DDM data
0: 	 * 	1 byte	- DSS format 
0: 	 *		|---|---------|----------|
0: 	 *		| 0	|  flags  |  type    |
0: 	 *		|---|---------|----------|
0: 	 *		| 0 | 1  2  3 | 4 5 6 7  |
0: 	 *		|---|---------|----------|
0: 	 *		bit 0 - '0'
0: 	 *		bit 1 - '0' - unchained, '1' - chained
0: 	 *		bit 2 - '0'	- do not continue on error, '1' - continue on error
0: 	 *		bit 3 - '0' - next DSS has different correlator, '1' - next DSS has
0: 	 *						same correlator
0: 	 *		type - 1 - Request DSS
0: 	 *			 - 2 - Reply DSS
0: 	 *			 - 3 - Object DSS
0: 	 *			 - 4 - Communications DSS
0: 	 *			 - 5 - Request DSS where no reply is expected
0: 	 *	2 bytes - request correlation id
0: 	 *
0: 	 * @exception DRDProtocolException
0: 	 */
0: 	protected int readDssHeader () throws DRDAProtocolException
0: 	{
0: 		ensureALayerDataInBuffer (6);
0: 
0: 		// read out the DSS length
0: 		dssLength = ((buffer[pos] & 0xff) << 8) +
0: 					((buffer[pos + 1] & 0xff) << 0);
0: 		pos += 2;
0: 		// check for the continuation bit and update length as needed.
0: 		if ((dssLength & DssConstants.CONTINUATION_BIT) == 
0: 				DssConstants.CONTINUATION_BIT) 
0: 		{
0: 			dssLength = DssConstants.MAX_DSS_LENGTH;
0: 			dssIsContinued = true;
0: 		}
0: 		else 
0: 		{
0: 			dssIsContinued = false;
0: 		}
0: 
0: 		if (dssLength < 6)
0: 			agent.throwSyntaxrm(CodePoint.SYNERRCD_DSS_LESS_THAN_6,
0: 							   DRDAProtocolException.NO_CODPNT_ARG);
0: 
0: 		// If the GDS id is not valid, or
0: 		// if the reply is not an RQSDSS nor
0: 		// a OBJDSS, then throw an exception.
0: 
0: 		if ((buffer[pos++] & 0xff) != DssConstants.DSS_ID)
0: 			agent.throwSyntaxrm(CodePoint.SYNERRCD_CBYTE_NOT_D0,
0: 							   DRDAProtocolException.NO_CODPNT_ARG);
0: 
0: 		int gdsFormatter = buffer[pos++] & 0xff;
0: 		
0: 		if (((gdsFormatter & 0x0F) != DssConstants.DSSFMT_RQSDSS)
0: 			&&((gdsFormatter & 0x0F) != DssConstants.DSSFMT_OBJDSS)) 
0: 		{
0: 			agent.throwSyntaxrm(CodePoint.SYNERRCD_FBYTE_NOT_SUPPORTED,
0: 							   DRDAProtocolException.NO_CODPNT_ARG);
0: 		}
0: 
0: 		// Determine if the current DSS is chained with the
0: 		// next DSS, with the same or different request ID.
0: 		if ((gdsFormatter & DssConstants.DSSCHAIN) == DssConstants.DSSCHAIN) 
0: 		{	// on indicates structure chained to next structure
0: 			if ((gdsFormatter & DssConstants.DSSCHAIN_SAME_ID) 
0: 					== DssConstants.DSSCHAIN_SAME_ID) 
0: 			{
0: 				dssIsChainedWithSameID = true;
0: 				dssIsChainedWithDiffID = false;
0: 			}
0: 			else 
0: 			{
0: 				dssIsChainedWithSameID = false;
0: 				dssIsChainedWithDiffID = true;
0: 			}
0: 			if ((gdsFormatter & DssConstants.DSSCHAIN_ERROR_CONTINUE) 
0: 				== DssConstants.DSSCHAIN_ERROR_CONTINUE)
0: 				terminateChainOnErr = false;
0: 			else
0: 				terminateChainOnErr = true;
0: 		}
0: 		else 
0: 		{
0: 			// chaining bit not b'1', make sure DSSFMT same id not b'1'
0: 			if ((gdsFormatter & DssConstants.DSSCHAIN_SAME_ID) 
0: 					== DssConstants.DSSCHAIN_SAME_ID)	
0: 			{  // Next DSS can not have same correlator
0: 				agent.throwSyntaxrm(CodePoint.SYNERRCD_CHAIN_OFF_SAME_NEXT_CORRELATOR,
0: 								   DRDAProtocolException.NO_CODPNT_ARG);
0: 			}
0: 			// chaining bit not b'1', make sure no error continuation
0: 			if ((gdsFormatter & DssConstants.DSSCHAIN_ERROR_CONTINUE) 
0: 				== DssConstants.DSSCHAIN_ERROR_CONTINUE) 
0: 			{ // must be 'do not continue on error'
0: 				agent.throwSyntaxrm(CodePoint.SYNERRCD_CHAIN_OFF_ERROR_CONTINUE,
0: 								   DRDAProtocolException.NO_CODPNT_ARG);
0: 			}
0: 
0: 			dssIsChainedWithSameID = false;
0: 			dssIsChainedWithDiffID = false;
0: 		}
0: 
0: 		dssCorrelationID =
0: 			((buffer[pos] & 0xff) << 8) +
0: 			((buffer[pos + 1] & 0xff) << 0);
0: 		pos += 2;
0: 		if (SanityManager.DEBUG)
0: 			trace("dssLength = " + dssLength + " correlationID = " + dssCorrelationID);
0: 
0: 		//check that correlationID is the same as previous
0: 		if (prevCorrelationID != DssConstants.CORRELATION_ID_UNKNOWN && 
0: 			dssCorrelationID != prevCorrelationID)
0: 		{
0: 			agent.throwSyntaxrm(CodePoint.SYNERRCD_CHAIN_OFF_ERROR_CONTINUE,
0: 							   DRDAProtocolException.NO_CODPNT_ARG);
0: 		}
0: 		
0: 		// set up previous correlation id to check that next DSS is correctly
0: 		// formatted
0: 		if (dssIsChainedWithSameID)
0: 			prevCorrelationID = dssCorrelationID;
0: 		else
0: 			prevCorrelationID = DssConstants.CORRELATION_ID_UNKNOWN;
0: 
0: 		dssLength -= 6;
0: 
0: 		return dssCorrelationID;
0: 	}
0: 	/**
0: 	 * Read Reply DSS
0: 	 * This is used in testing the protocol.  We shouldn't see a reply
0: 	 * DSS when we are servicing DRDA commands
0: 	 *
0: 	 * @exception DRDProtocolException
0: 	 */
0: 	protected void readReplyDss() throws DRDAProtocolException
0: 	{
0: 		ensureALayerDataInBuffer (6);
0: 
0: 		// read out the DSS length
0: 		dssLength = ((buffer[pos++] & 0xff) << 8) +
0: 					((buffer[pos++] & 0xff) << 0);
0: 
0: 		// check for the continuation bit and update length as needed.
0: 		if ((dssLength & DssConstants.CONTINUATION_BIT) == 
0: 				DssConstants.CONTINUATION_BIT) 
0: 		{
0: 			dssLength = DssConstants.MAX_DSS_LENGTH;
0: 			dssIsContinued = true;
0: 		}
0: 		else 
0: 		{
0: 			dssIsContinued = false;
0: 		}
0: 
0: 		if (dssLength < 6)
0: 			agent.throwSyntaxrm(CodePoint.SYNERRCD_DSS_LESS_THAN_6,
0: 							   DRDAProtocolException.NO_CODPNT_ARG);
0: 
0: 		// If the GDS id is not valid, throw exception
0: 
0: 		if ((buffer[pos++] & 0xff) != DssConstants.DSS_ID)
0: 			agent.throwSyntaxrm(CodePoint.SYNERRCD_CBYTE_NOT_D0,
0: 							   DRDAProtocolException.NO_CODPNT_ARG);
0: 
0: 		int gdsFormatter = buffer[pos++] & 0xff;
0: 		
0: 		// Determine if the current DSS is chained with the
0: 		// next DSS, with the same or different request ID.
0: 		if ((gdsFormatter & DssConstants.DSSCHAIN) == DssConstants.DSSCHAIN) 
0: 		{	// on indicates structure chained to next structure
0: 			if ((gdsFormatter & DssConstants.DSSCHAIN_SAME_ID) 
0: 					== DssConstants.DSSCHAIN_SAME_ID) 
0: 			{
0: 				dssIsChainedWithSameID = true;
0: 				dssIsChainedWithDiffID = false;
0: 			}
0: 			else 
0: 			{
0: 				dssIsChainedWithSameID = false;
0: 				dssIsChainedWithDiffID = true;
0: 			}
0: 		}
0: 		else 
0: 		{
0: 			dssIsChainedWithSameID = false;
0: 			dssIsChainedWithDiffID = false;
0: 		}
0: 
0: 		dssCorrelationID =
0: 			((buffer[pos++] & 0xff) << 8) +
0: 			((buffer[pos++] & 0xff) << 0);
0: 
0: 		if (SanityManager.DEBUG)					
0: 			trace("dssLength = " + dssLength + " correlationID = " + dssCorrelationID);
0: 
0: 		dssLength -= 6;
0: 
0: 	}
0: 
0: 	/**
0: 	 * Read the DDM Length and CodePoint
0: 	 *
0: 	 * @return - returns codepoint
0: 	 *
0: 	 * @exception DRDProtocolException
0: 	 */
0: 	protected int readLengthAndCodePoint() throws DRDAProtocolException
0: 	{
0: 		ensureBLayerDataInBuffer (4, NO_ADJUST_LENGTHS);
0: 
0: 		ddmScalarLen =
0: 			((buffer[pos++] & 0xff) << 8) +
0: 			((buffer[pos++] & 0xff) << 0);
0: 
0: 		int codePoint =
0: 			((buffer[pos++] & 0xff) << 8) +
0: 			((buffer[pos++] & 0xff) << 0);
0: 		if (SanityManager.DEBUG)
0: 			trace("length = "+ ddmScalarLen + " codepoint = " + java.lang.Integer.toHexString(codePoint));
0: 		// SYNERRCD 0x0D - Object code point index not supported.
0: 		// the object codepoint index will not be checked here since
0: 		// the parse methods will catch any incorrect/unexpected codepoint values
0: 		// and report them as unsupported objects or parameters.
0: 
0: 		// Check if this DDM has extended length field
0: 		if ((ddmScalarLen & DssConstants.CONTINUATION_BIT) == DssConstants.CONTINUATION_BIT) 
0: 		{
0: 			int numberOfExtendedLenBytes = ((int)ddmScalarLen - 
0: 					DssConstants.CONTINUATION_BIT) - 4;
0: 			int adjustSize = 0;
0: 			ensureBLayerDataInBuffer (numberOfExtendedLenBytes, NO_ADJUST_LENGTHS);
0: 			switch (numberOfExtendedLenBytes) {
0: 			case 8:
0: 				 ddmScalarLen =
0: 					((buffer[pos++] & 0xff) << 64) +
0: 					((buffer[pos++] & 0xff) << 56) +
0: 					((buffer[pos++] & 0xff) << 48) +
0: 					((buffer[pos++] & 0xff) << 40) +
0: 					((buffer[pos++] & 0xff) << 32) +
0: 					((buffer[pos++] & 0xff) << 16) +
0: 					((buffer[pos++] & 0xff) << 8) +
0: 					((buffer[pos++] & 0xff) << 0);
0: 				adjustSize = 12;
0: 				break;
0: 			case 6:
0: 				ddmScalarLen =
0: 					((buffer[pos++] & 0xff) << 48) +
0: 					((buffer[pos++] & 0xff) << 40) +
0: 					((buffer[pos++] & 0xff) << 32) +
0: 					((buffer[pos++] & 0xff) << 16) +
0: 					((buffer[pos++] & 0xff) << 8) +
0: 					((buffer[pos++] & 0xff) << 0);
0: 				adjustSize = 10;
0: 				break;
0: 			case 4:
0: 				ddmScalarLen =
0: 					((buffer[pos++] & 0xff) << 32) +
0: 					((buffer[pos++] & 0xff) << 16) +
0: 					((buffer[pos++] & 0xff) << 8) +
0: 					((buffer[pos++] & 0xff) << 0);
0: 				adjustSize = 8;
0: 				break;
0: 			default:
0: 				agent.throwSyntaxrm(CodePoint.SYNERRCD_INCORRECT_EXTENDED_LEN,
0: 							   DRDAProtocolException.NO_CODPNT_ARG);
0: 		}
0: 
0: 			// adjust the lengths here.	this is a special case since the
0: 			// extended length bytes do not include their own length.
0: 			for (int i = 0; i <= topDdmCollectionStack; i++) {
0: 				ddmCollectionLenStack[i] -= adjustSize;
0: 			}
0: 			dssLength -= adjustSize;
0: 		}
0: 		else {
0: 			if (ddmScalarLen < 4)
0: 				agent.throwSyntaxrm(CodePoint.SYNERRCD_OBJ_LEN_LESS_THAN_4,
0: 								   DRDAProtocolException.NO_CODPNT_ARG);
0: 			adjustLengths (4);
0: 		}
0: 		return codePoint;
0: 	}
0: 
0: 	/**
0: 	 * Read the CodePoint
0: 	 *
0: 	 * @return - returns codepoint
0: 	 */
0: 	protected int readCodePoint()
0: 	{
0: 		return( ((buffer[pos++] & 0xff) << 8) +
0: 		  ((buffer[pos++] & 0xff) << 0));
0: 	}
0: 
0: 	/**
0: 	 * Push DDM Length on to collection stack
0: 	 */
0: 	protected void markCollection()
0: 	{
0: 		ddmCollectionLenStack[++topDdmCollectionStack] = ddmScalarLen;
0: 		ddmScalarLen = 0;
0: 	}
0: 
0: 	/**
0: 	 * 	Get the next CodePoint from a collection
0: 	 * 	@return	NO_CODEPOINT if collection stack is empty or remaining length is
0: 	 *		0; otherwise,  read length and code point
0: 	 *
0: 	 * @exception DRDProtocolException
0: 	 */
0: 	protected int getCodePoint() throws DRDAProtocolException
0: 	{
0: 		if (topDdmCollectionStack == EMPTY_STACK) 
0: 		{
0: 			return NO_CODEPOINT;
0: 		}
0: 		else 
0: 		{
0: 			// if the collecion is exhausted then return NO_CODEPOINT
0: 			if (ddmCollectionLenStack[topDdmCollectionStack] == 0) 
0: 			{
0: 				// done with this collection so remove it's length from the stack
0: 				ddmCollectionLenStack[topDdmCollectionStack--] = 0;
0: 				return NO_CODEPOINT;
0: 			}
0: 			else {
0: 				return readLengthAndCodePoint();
0: 			}
0: 		}
0: 	}
0: 	/**
0: 	 * Get the next CodePoint from a collection and check that it matches the specified
0: 	 * 	CodePoint
0: 	 * @param	codePointCheck	- codePoint to check against
0: 	 * @return	codePoint
0: 	 *
0: 	 * @exception DRDProtocolException
0: 	 */
0: 	protected int getCodePoint(int codePointCheck) throws DRDAProtocolException
0: 	{
0: 		int codePoint = getCodePoint();
0: 		if (codePoint != codePointCheck)
0: 			agent.missingCodePoint(codePoint);
0: 		return codePoint;
0: 	}
0: 	/**
0: 	 * The following routines read different types from the input stream
0: 	 * Data can be in network order or platform order depending on whether the
0: 	 * data is part of the protocol or data being received
0: 	 * The platform is determined by EXCSAT protocol
0: 	 */
0: 
0: 	/**
0: 	 * Read byte value
0: 	 * @return	value
0: 	 *
0: 	 * @exception DRDProtocolException
0: 	 */
0: 	protected byte readByte () throws DRDAProtocolException
0: 	{
0: 		ensureBLayerDataInBuffer (1, ADJUST_LENGTHS);
0: 		return (byte) (buffer[pos++] & 0xff);
0: 	}
0: 
0: 	/**
0: 	 * Read byte value and mask out high order bytes before returning
0: 	 * @return value
0: 	 */
0: 	protected int readUnsignedByte () throws DRDAProtocolException
0: 	{
0: 		ensureBLayerDataInBuffer (1, ADJUST_LENGTHS);
0: 		return (int ) (buffer[pos++] & 0xff);
0: 	}
0: 
0: 	/**
0: 	 * Read network short value
0: 	 * @return	value
0: 	 *
0: 	 * @exception DRDProtocolException
0: 	 */
0: 	protected int readNetworkShort () throws DRDAProtocolException
0: 	{
0: 		ensureBLayerDataInBuffer (2, ADJUST_LENGTHS);
0: 		return ((buffer[pos++] & 0xff) << 8) +
0: 		  ((buffer[pos++] & 0xff) << 0);
0: 	}
0: 
0: 	/**
0: 	 * Read signed network short value
0: 	 * @return	value
0: 	 *
0: 	 * @exception DRDProtocolException
0: 	 */
0: 	protected int readSignedNetworkShort () throws DRDAProtocolException
0: 	{
0: 		ensureBLayerDataInBuffer (2, ADJUST_LENGTHS);
0: 		return (short)(((buffer[pos++] & 0xff) << 8) +
0: 		  ((buffer[pos++] & 0xff) << 0));
0: 	}
0: 	/**
0: 	 * Read platform short value
0: 	 * @return	value
0: 	 *
0: 	 * @exception DRDProtocolException
0: 	 */
0: 	protected short readShort (int byteOrder) throws DRDAProtocolException
0: 	{
0: 		ensureBLayerDataInBuffer (2, ADJUST_LENGTHS);
0: 		short s = SignedBinary.getShort (buffer, pos, byteOrder);
0: 
0: 		pos += 2;
0: 
0: 		return s;
0: 	}
0: 
0: 	/**
0: 	 * Read network int value
0: 	 * @return	value
0: 	 *
0: 	 * @exception DRDProtocolException
0: 	 */
0: 	protected int readNetworkInt () throws DRDAProtocolException
0: 	{
0: 		ensureBLayerDataInBuffer (4, ADJUST_LENGTHS);
0: 		return ((buffer[pos++] & 0xff) << 24) +
0: 		       ((buffer[pos++] & 0xff) << 16) +
0: 		       ((buffer[pos++] & 0xff) << 8) +
0: 		       ((buffer[pos++] & 0xff) << 0);
0: 	}
0: 
0: 	/**
0: 	 * Read platform int value
0: 	 * @return	value
0: 	 *
0: 	 * @exception DRDProtocolException
0: 	 */
0: 	protected int readInt (int byteOrder) throws DRDAProtocolException
0: 	{
0: 		ensureBLayerDataInBuffer (4, ADJUST_LENGTHS);
0: 		int i = SignedBinary.getInt (buffer, pos, byteOrder);
0: 
0: 		pos += 4;
0: 
0: 		return i;
0: 	}
0: 
0: 	/**
0: 	 * Read network long value
0: 	 * @return	value
0: 	 *
0: 	 * @exception DRDProtocolException
0: 	 */
0: 	protected long readNetworkLong () throws DRDAProtocolException
0: 	{
0: 		ensureBLayerDataInBuffer (8, ADJUST_LENGTHS);
0: 
0: 		return ((buffer[pos++] & 0xffL) << 56) +
0: 		       ((buffer[pos++] & 0xffL) << 48) +
0: 		       ((buffer[pos++] & 0xffL) << 40) +
0: 		       ((buffer[pos++] & 0xffL) << 32) +
0: 		       ((buffer[pos++] & 0xffL) << 24) +
0: 		       ((buffer[pos++] & 0xffL) << 16) +
0: 		       ((buffer[pos++] & 0xffL) << 8) +
0: 		       ((buffer[pos++] & 0xffL) << 0);
0: 	}
0: 
0: 	
0: 	/**
0: 	 * Read network six byte value and put it in a long v
0: 	 * @return	value
0: 	 *
0: 	 * @exception DRDProtocolException
0: 	 */
0: 	protected long readNetworkSixByteLong() throws DRDAProtocolException
0: 	{
0: 		ensureBLayerDataInBuffer (6, ADJUST_LENGTHS);
0: 
0: 		return (
0: 				((buffer[pos++] & 0xffL) << 40) +
0: 		       ((buffer[pos++] & 0xffL) << 32) +
0: 		       ((buffer[pos++] & 0xffL) << 24) +
0: 		       ((buffer[pos++] & 0xffL) << 16) +
0: 		       ((buffer[pos++] & 0xffL) << 8) +
0: 		       ((buffer[pos++] & 0xffL) << 0));
0: 	}
0: 
0: 	/**
0: 	 * Read platform long value
0: 	 * @return	value
0: 	 *
0: 	 * @exception DRDProtocolException
0: 	 */
0: 	protected long readLong (int byteOrder) throws DRDAProtocolException
0: 	{
0: 		ensureBLayerDataInBuffer (8, ADJUST_LENGTHS);
0: 		long l = SignedBinary.getLong (buffer, pos, byteOrder);
0: 
0: 		pos += 8;
0: 
0: 		return l;
0: 	}
0: 
0: 	/**
0: 	 * Read platform float value
0: 	 * @return	value
0: 	 *
0: 	 * @exception DRDProtocolException
0: 	 */
0: 	protected float readFloat(int byteOrder) throws DRDAProtocolException
0: 	{
0: 		return Float.intBitsToFloat(readInt(byteOrder));
0: 	}
0: 
0: 	/**
0: 	 * Read platform double value
0: 	 * @return	value
0: 	 *
0: 	 * @exception DRDProtocolException
0: 	 */
0: 	protected double readDouble(int byteOrder) throws DRDAProtocolException
0: 	{
0: 		return Double.longBitsToDouble(readLong(byteOrder));
0: 	}
0: 
0: 	/**
0: 	 * Read a BigDecimal value
0: 	 * @param	precision of the BigDecimal
0: 	 * @param	scale of the BigDecimal
0: 	 * @return	value
0: 	 *
0: 	 * @exception DRDProtocolException
0: 	 */
0: 	protected BigDecimal readBigDecimal(int precision, int scale) throws DRDAProtocolException
0:     {
0:       // The byte-length of a packed decimal with precision p is always p/2 + 1
0:       int length = precision / 2 + 1;
0: 
0: 	  ensureBLayerDataInBuffer (length, ADJUST_LENGTHS);
0: 
0:       // check for sign.
0:       int signum;
0:       if ((buffer[pos+length-1] & 0x0F) == 0x0D)
0:         signum = -1;
0:       else
0:         signum =  1;
0: 
0:       if (precision <= 9) {
0:         // can be handled by int without overflow.
0:         int value = packedNybblesToInt(buffer, pos, 0, length*2-1);
0: 
0:         // convert value to a byte array of magnitude.
0:         byte[] magnitude = new byte[4];
0:         magnitude[0] = (byte)(value >>> 24);
0:         magnitude[1] = (byte)(value >>> 16);
0:         magnitude[2] = (byte)(value >>> 8);
0:         magnitude[3] = (byte)(value);
0: 
0: 		pos += length;
0:         return new java.math.BigDecimal (new java.math.BigInteger(signum, magnitude), scale);
0:       }
0:       else if (precision <= 18) {
0:         // can be handled by long without overflow.
0:         long value = packedNybblesToLong(buffer, pos, 0, length*2-1);
0: 
0:         // convert value to a byte array of magnitude.
0:         byte[] magnitude = new byte[8];
0:         magnitude[0] = (byte)(value >>> 56);
0:         magnitude[1] = (byte)(value >>> 48);
0:         magnitude[2] = (byte)(value >>> 40);
0:         magnitude[3] = (byte)(value >>> 32);
0:         magnitude[4] = (byte)(value >>> 24);
0:         magnitude[5] = (byte)(value >>> 16);
0:         magnitude[6] = (byte)(value >>>  8);
0:         magnitude[7] = (byte)(value);
0: 
0: 		pos += length;
0:         return new java.math.BigDecimal (new java.math.BigInteger(signum, magnitude), scale);
0:       }
0:       else if (precision <= 27) {
0:         // get the value of last 9 digits (5 bytes).
0:         int lo = packedNybblesToInt(buffer, pos, (length-5)*2, 9);
0:         // get the value of another 9 digits (5 bytes).
0:         int me = packedNybblesToInt(buffer, pos, (length-10)*2+1, 9);
0:         // get the value of the rest digits.
0:         int hi = packedNybblesToInt(buffer, pos, 0, (length-10)*2+1);
0: 
0:         // compute the int array of magnitude.
0:         int[] value = computeMagnitude(new int[] {hi, me, lo});
0: 
0:         // convert value to a byte array of magnitude.
0:         byte[] magnitude = new byte[12];
0:         magnitude[0]  = (byte)(value[0] >>> 24);
0:         magnitude[1]  = (byte)(value[0] >>> 16);
0:         magnitude[2]  = (byte)(value[0] >>> 8);
0:         magnitude[3]  = (byte)(value[0]);
0:         magnitude[4]  = (byte)(value[1] >>> 24);
0:         magnitude[5]  = (byte)(value[1] >>> 16);
0:         magnitude[6]  = (byte)(value[1] >>> 8);
0:         magnitude[7]  = (byte)(value[1]);
0:         magnitude[8]  = (byte)(value[2] >>> 24);
0:         magnitude[9]  = (byte)(value[2] >>> 16);
0:         magnitude[10] = (byte)(value[2] >>> 8);
0:         magnitude[11] = (byte)(value[2]);
0: 
0: 		pos += length;
0:         return new java.math.BigDecimal (new java.math.BigInteger(signum, magnitude), scale);
0:       }
0:       else if (precision <= 31) {
0:         // get the value of last 9 digits (5 bytes).
0:         int lo   = packedNybblesToInt(buffer, pos, (length-5)*2, 9);
0:         // get the value of another 9 digits (5 bytes).
0:         int meLo = packedNybblesToInt(buffer, pos, (length-10)*2+1, 9);
0:         // get the value of another 9 digits (5 bytes).
0:         int meHi = packedNybblesToInt(buffer, pos, (length-14)*2, 9);
0:         // get the value of the rest digits.
0:         int hi   = packedNybblesToInt(buffer, pos, 0, (length-14)*2);
0: 
0:         // compute the int array of magnitude.
0:         int[] value = computeMagnitude(new int[] {hi, meHi, meLo, lo});
0: 
0:         // convert value to a byte array of magnitude.
0:         byte[] magnitude = new byte[16];
0:         magnitude[0]  = (byte)(value[0] >>> 24);
0:         magnitude[1]  = (byte)(value[0] >>> 16);
0:         magnitude[2]  = (byte)(value[0] >>> 8);
0:         magnitude[3]  = (byte)(value[0]);
0:         magnitude[4]  = (byte)(value[1] >>> 24);
0:         magnitude[5]  = (byte)(value[1] >>> 16);
0:         magnitude[6]  = (byte)(value[1] >>> 8);
0:         magnitude[7]  = (byte)(value[1]);
0:         magnitude[8]  = (byte)(value[2] >>> 24);
0:         magnitude[9]  = (byte)(value[2] >>> 16);
0:         magnitude[10] = (byte)(value[2] >>> 8);
0:         magnitude[11] = (byte)(value[2]);
0:         magnitude[12] = (byte)(value[3] >>> 24);
0:         magnitude[13] = (byte)(value[3] >>> 16);
0:         magnitude[14] = (byte)(value[3] >>> 8);
0:         magnitude[15] = (byte)(value[3]);
0: 
0: 		pos += length;
0:         return new java.math.BigDecimal (new java.math.BigInteger(signum, magnitude), scale);
0:       }
0:       else {
0: 		pos += length;
0:         // throw an exception here if nibbles is greater than 31
0:         throw new java.lang.IllegalArgumentException("Decimal may only be up to 31 digits!");
0:       }
0:     }
0: 
0: 	
0: 
0: 	byte[] getExtData (boolean checkNullability) throws DRDAProtocolException
0: 	{
0: 		return  getExtData(ddmScalarLen, checkNullability);
0: 	}
0: 
0: 
0: 	byte[] getExtData (long desiredLength, boolean checkNullability) throws DRDAProtocolException
0:   {
0:     boolean readHeader;
0:     int copySize;
0:     ByteArrayOutputStream baos;
0:     boolean isLengthAndNullabilityUnknown = false;
0: 
0: 	
0: 	if (desiredLength != -1) {
0:         // allocate a stream based on a known amount of data
0:         baos = new ByteArrayOutputStream ((int) desiredLength);
0: 	}
0: 	else {
0:         // allocate a stream to hold an unknown amount of data
0:         baos = new ByteArrayOutputStream ();
0:         //isLengthAndNullabilityUnknown = true;
0: 		// If we aren't given a  length get the whole thing.
0: 		desiredLength = MAX_EXTDTA_SIZE;
0: 	}
0: 	
0: 
0:     // check for a null EXTDTA value, if it is nullable and if streaming
0:     if (checkNullability)
0:       if (isEXTDTANull())
0:         return null;
0: 
0:     // set the amount to read for the first segment
0: 	copySize = (int) Math.min(dssLength,desiredLength); //note: has already been adjusted for headers
0: 
0: 
0:     //if (checkNullability)  // don't count the null byte we've already read
0: 	//copySize--;
0: 
0:     do {
0:       // determine if a continuation header needs to be read after the data
0:       if (dssIsContinued)
0:         readHeader = true;
0:       else
0:         readHeader = false;
0: 
0:       // read the segment
0:       ensureALayerDataInBuffer (copySize);
0:       adjustLengths (copySize);
0:       baos.write (buffer, pos, copySize);
0:       pos += copySize;
0: 	  desiredLength -= copySize;
0: 
0:       // read the continuation header, if necessary
0:       if (readHeader)
0:         readDSSContinuationHeader ();
0: 
0: 	  copySize = (int) Math.min(dssLength,desiredLength); //note: has already been adjusted for headers
0: 
0:     }
0:     while (readHeader == true && desiredLength > 0);
0: 
0:     return baos.toByteArray();
0:   }
0: 
0: 
0:   // reads a DSS continuation header
0:   // prereq: pos is positioned on the first byte of the two-byte header
0:   // post:   dssIsContinued is set to true if the continuation bit is on, false otherwise
0:   //         dssLength is set to DssConstants.MAXDSS_LEN - 2 (don't count the header for the next read)
0:   // helper method for getEXTDTAData
0: 	private void readDSSContinuationHeader () throws DRDAProtocolException
0:   {
0:     ensureALayerDataInBuffer(2);
0: 
0:     dssLength =
0:       ((buffer[pos++]&0xFF) << 8) +
0:       ((buffer[pos++]&0xFF) << 0);
0: 
0:     if ((dssLength & 0x8000) == 0x8000) {
0:       dssLength = DssConstants.MAX_DSS_LENGTH;
0:       dssIsContinued = true;
0:     }
0:     else {
0:       dssIsContinued = false;
0:     }
0:     // it is a syntax error if the dss continuation header length
0:     // is less than or equal to two
0:     if (dssLength <= 2) {
0: 		agent.throwSyntaxrm(CodePoint.SYNERRCD_DSS_CONT_LESS_OR_EQUAL_2,
0: 							   DRDAProtocolException.NO_CODPNT_ARG);
0:     }
0: 
0:     dssLength -= 2;  // avoid consuming the DSS cont header
0:   }
0: 
0: // checks the null EXTDTA byte
0:   // returns true if null, false otherwise
0:   // helper method for getEXTDTAData
0:   private boolean isEXTDTANull () throws DRDAProtocolException
0:   {
0:     // make sure that the null byte is in the buffer
0:     ensureALayerDataInBuffer (1);
0:     adjustLengths (1);
0: 
0:     // examine the null byte
0:     byte nullByte = buffer[pos++];
0:     if (nullByte == (byte)0x00)
0:       return false;
0: 
0:     return true;
0:   }
0: 
0: 
0:    /**
0:     * Convert a range of packed nybbles (up to 9 digits without overflow) to an int.
0:     * Note that for performance purpose, it does not do array-out-of-bound checking.
0: 	* @param	buffer to read from
0: 	* @param	offset in the buffer
0: 	* @param	start nybble
0: 	* @param	number of nybbles
0: 	* @return	an int value
0:     */
0:     private int packedNybblesToInt (byte[] buffer,
0:                                          int offset,
0:                                          int startNybble,
0:                                          int numberOfNybbles)
0:     {
0:       int value = 0;
0: 
0:       int i = startNybble / 2;
0:       if ((startNybble % 2) != 0) {
0:         // process low nybble of the first byte if necessary.
0:         value += buffer[offset+i] & 0x0F;
0:         i++;
0:       }
0: 
0:       int endNybble = startNybble + numberOfNybbles -1;
0:       for (; i<(endNybble+1)/2; i++) {
0:         value = value*10 + ((buffer[offset+i] & 0xF0) >>> 4); // high nybble.
0:         value = value*10 +  (buffer[offset+i] & 0x0F);        // low nybble.
0:       }
0: 
0:       if ((endNybble % 2) == 0) {
0:         // process high nybble of the last byte if necessary.
0:         value = value*10 + ((buffer[offset+i] & 0xF0) >>> 4);
0:       }
0: 
0:       return value;
0:     }
0: 
0:     /**
0:      * Convert a range of packed nybbles (up to 18 digits without overflow) to a long.
0:      * Note that for performance purpose, it does not do array-out-of-bound checking.
0: 	 * @param	buffer to read from
0: 	 * @param	offset in the buffer
0: 	 * @param	start nybble
0: 	 * @param	number of nybbles
0: 	 * @return	an long value
0:      */
0:     private long packedNybblesToLong (byte[] buffer,
0:                                            int offset,
0:                                            int startNybble,
0:                                            int numberOfNybbles)
0:     {
0:       long value = 0;
0: 
0:       int i = startNybble / 2;
0:       if ((startNybble % 2) != 0) {
0:         // process low nybble of the first byte if necessary.
0:         value += buffer[offset+i] & 0x0F;
0:         i++;
0:       }
0: 
0:       int endNybble = startNybble + numberOfNybbles -1;
0:       for (; i<(endNybble+1)/2; i++) {
0:         value = value*10 + ((buffer[offset+i] & 0xF0) >>> 4); // high nybble.
0:         value = value*10 +  (buffer[offset+i] & 0x0F);        // low nybble.
0:       }
0: 
0:       if ((endNybble % 2) == 0) {
0:         // process high nybble of the last byte if necessary.
0:         value = value*10 + ((buffer[offset+i] & 0xF0) >>> 4);
0:       }
0: 
0:  	  return value;
0: 	}
0: 
0:     /**
0:      * Compute the int array of magnitude from input value segments.
0: 	 * @param	input value segments
0: 	 * @return	array of int magnitudes
0:      */
0:     private int[] computeMagnitude(int[] input)
0:     {
0:         int length = input.length;
0:         int[] mag = new int[length];
0: 
0:         mag[length-1] = input[length-1];
0:         for (int i=0; i<length-1; i++) {
0:           int carry = 0;
0:           int j = tenRadixMagnitude[i].length-1;
0:           int k = length-1;
0:           for (; j>=0; j--, k--) {
0:             long product = (input[length-2-i] & 0xFFFFFFFFL) * (tenRadixMagnitude[i][j] & 0xFFFFFFFFL)
0:                          + (mag[k] & 0xFFFFFFFFL) // add previous value
0:                          + (carry & 0xFFFFFFFFL); // add carry
0:             carry  = (int) (product >>> 32);
0:             mag[k] = (int) (product & 0xFFFFFFFFL);
0:           }
0:           mag[k] = (int) carry;
0:         }
0:         return mag;
0:     }
0: 
0: 	/**
0: 	 * Read boolean value
0: 	 * @return	value
0: 	 *
0: 	 * @exception DRDProtocolException
0: 	 */
0: 	protected boolean readBoolean () throws DRDAProtocolException
0: 	{
0: 		ensureBLayerDataInBuffer (1, ADJUST_LENGTHS);
0: 		return buffer[pos++] != 0;
0: 	}
0: 
0: 	/**
0: 	 * Read encrypted string
0: 	 * @param   decryptM  decryption manager
0: 	 * @param   security mechanism
0: 	 * @param   initVector   initialization vector for cipher
0: 	 * @param   sourcePublicKey  public key (as in Deffie-Hellman algorithm)
0: 	 *                           from source (encryptor)
0: 	 * @return  decrypted string
0: 	 *
0: 	 * @exception DRDProtocolException, SQLException(wrapping any exception in decryption)
0: 	 */
0: 	protected String readEncryptedString (DecryptionManager decryptM, int securityMechanism,
0: 										 byte[] initVector, byte[] sourcePublicKey)
0: 			throws DRDAProtocolException, java.sql.SQLException
0: 	{
0: 		byte[] cipherText = readBytes();
0: 		byte[] plainText = null;
0: 		plainText = decryptM.decryptData(cipherText, securityMechanism, initVector,
0: 											 sourcePublicKey);
0: 		if (plainText == null)
0: 			return null;
0: 		else
0: 			return ccsidManager.convertToUCS2(plainText);
0: 	}
0: 
0: 	/**
0: 	 * Read string value
0: 	 * Strings in DRDA protocol are encoded in EBCDIC by default so we
0: 	 * need to convert to UCS2
0: 	 * @param length  - length of string to read
0: 	 * @return value
0: 	 *
0: 	 * @exception DRDProtocolException
0: 	 */
0: 	protected String readString (int length) throws DRDAProtocolException
0: 	{
0: 		ensureBLayerDataInBuffer (length, ADJUST_LENGTHS);
0: 
0: 		String result = ccsidManager.convertToUCS2 (buffer, pos, length);
0: 		pos += length;
0: 		return result;
0: 	}
0: 
0: 	/**
0: 	 * Read encoded string value
0: 	 * @param length  - length of string to read
0: 	 * @return value
0: 	 *
0: 	 * @exception DRDProtocolException
0: 	 */
0: 	protected String readString (int length, String encoding) 
0: 		throws DRDAProtocolException
0: 	{
0: 		ensureBLayerDataInBuffer (length, ADJUST_LENGTHS);
0: 		String s = null;
0: 
0: 		try {
0: 		  s = new String (buffer, pos, length, encoding);
0: 		}
0: 		catch (java.io.UnsupportedEncodingException e) {
0: 			agent.agentError("UnsupportedEncodingException in readString, encoding = " 
0: 					+ encoding);
0: 			e.printStackTrace(agent.getServer().logWriter);
0: 		}
0: 		
0: 		pos += length;
0: 		return s;
0: 	}
0: 
0: 	/**
0: 	 * Read string value in DDM data with default encoding
0: 	 * @return value
0: 	 *
0: 	 * @exception DRDProtocolException
0: 	 */
0: 	protected String readStringData()
0: 		throws DRDAProtocolException
0: 	{
0: 		return readString((int)ddmScalarLen, DB2jServerImpl.DEFAULT_ENCODING);
0: 	}
0: 
0: 	/**
0: 	 * Read specified length of string value in DDM data with default encoding
0: 	 * @param length  - length of string to read
0: 	 * @return value
0: 	 *
0: 	 * @exception DRDProtocolException
0: 	 */
0: 	protected String readStringData(int length)
0: 		throws DRDAProtocolException
0: 	{
0: 		return readString(length, DB2jServerImpl.DEFAULT_ENCODING);
0: 	}
0: 
0: 	/**
0: 	 * Read length delimited string value in DDM data with default encoding
0: 	 * @return value
0: 	 *
0: 	 * @exception DRDProtocolException
0: 	 */
0: 	protected String readLDStringData(String encoding)
0: 		throws DRDAProtocolException
0: 	{
0: 		int length = readNetworkShort();
0: 		return readString(length, encoding);
0: 	}
0: 
0: 	/**
0: 	 * Read string value
0: 	 * @param length  - length of string to read
0: 	 * @return value
0: 	 *
0: 	 * @exception DRDProtocolException
0: 	 */
0: 	protected String readString () throws DRDAProtocolException
0: 	{
0: 		return readString((int)ddmScalarLen);
0: 	}
0: 
0: 	/**
0: 	 * Read byte string value
0: 	 * @param length  - length of string to read
0: 	 * @return byte array
0: 	 *
0: 	 * @exception DRDProtocolException
0: 	 */
0: 	protected byte[] readBytes (int length) throws DRDAProtocolException
0: 	{
0: 		byte[] b;
0: 
0: 		if (length < dssLength)
0: 		{
0: 			ensureBLayerDataInBuffer (length, ADJUST_LENGTHS);
0: 		    b = new byte[length];
0: 			System.arraycopy(buffer,pos,b,0,length);
0: 			pos +=length;
0: 		}
0: 		else
0: 			b = getExtData(length,false);
0: 		return b;
0: 	}
0: 	
0: 	/**
0: 	 * Read byte string value
0: 	 * @return byte array
0: 	 *
0: 	 * @exception DRDProtocolException
0: 	 */
0: 	protected byte[] readBytes () throws DRDAProtocolException
0: 	{
0: 		return readBytes((int)ddmScalarLen);
0: 	}
0: 
0: 	/**
0: 	 * Skip byte string value
0: 	 * @param length  - length of string to skip
0: 	 *
0: 	 * @exception DRDProtocolException
0: 	 */
0: 	protected void skipBytes (int length) throws DRDAProtocolException
0: 	{
0: 		ensureBLayerDataInBuffer (length, ADJUST_LENGTHS);
0: 		pos += length;
0: 	}
0: 
0: 	/**
0: 	 * Skip byte string value
0: 	 *
0: 	 * @exception DRDAProtocolException
0: 	 */
0: 	protected void skipBytes () throws DRDAProtocolException
0: 	{
0: 		skipBytes((int)ddmScalarLen);
0: 	}
0: 
0: 	/**
0: 	 * Skip remaining DSS
0: 	 *
0: 	 * @exception DRDAProtocolException
0: 	 */
0: 	protected void skipDss() throws DRDAProtocolException
0: 	{
0: 		skipBytes((int)dssLength);
0: 		topDdmCollectionStack = EMPTY_STACK;
0: 		ddmScalarLen = 0;
0: 		dssLength = 0;
0: 
0: 	}
0: 
0: 	protected void clearBuffer() throws DRDAProtocolException
0: 	{
0: 		skipBytes(java.lang.Math.min(dssLength, count - pos));
0: 	}
0: 
0: 	/**
0: 	 * Convert EBCDIC byte array to unicode string
0: 	 *
0: 	 * @param 	buf	- byte array
0: 	 * @return string
0: 	 */
0: 	protected String convertBytes(byte[] buf)
0: 	{
0: 		return ccsidManager.convertToUCS2 (buf, 0, buf.length);
0: 	}
0: 
0: 	// Private methods
0: 	/**
0: 	 * Adjust remaining length
0: 	 *
0: 	 * @param length - adjustment length
0: 	 */
0: 	private void adjustLengths(int length)
0: 	{
0: 		ddmScalarLen -= length;
0: 		for (int i = 0; i <= topDdmCollectionStack; i++) {
0: 		  ddmCollectionLenStack[i] -= length;
0: 		}
0: 		dssLength -= length;
0: 	}
0: 
0: 	/********************************************************************/
0: 	/*   NetworkServerControl  command protocol reading routines        
0: 	 */
0: 	/********************************************************************/
0: 	/**
0: 	 * Read string value
0: 	 * @param length  - length of string to read
0: 	 * @return value
0: 	 *
0: 	 * @exception DRDProtocolException
0: 	 */
0: 	protected String readCmdString (int length) throws DRDAProtocolException, java.io.UnsupportedEncodingException
0: 	{
0: 		if (length == 0)
0: 			return null;
0: 
0: 		ensureBLayerDataInBuffer (length, ADJUST_LENGTHS);
0: 		String result = new String (buffer, pos, length,
0: 										DB2jServerImpl.DEFAULT_ENCODING);
0: 		pos += length;
0: 		return result;
0: 	}
0: 	/**
0: 	 * Read string value
0: 	 * @return value
0: 	 *
0: 	 * @exception DRDProtocolException
0: 	 */
0: 	protected String readCmdString () throws DRDAProtocolException, java.io.UnsupportedEncodingException
0: 	{
0: 		int length = readNetworkShort();
0: 		return readCmdString(length);
0: 		
0: 	}
0: 
0: 	/**************************************************************************/
0: 	/*   Private methods
0: 	/**************************************************************************/
0: 	/**
0: 	 * Make sure a certain amount of Layer A data is in the buffer.
0: 	 * The data will be in the buffer after this method is called.
0: 	 *
0: 	 * @param desiredDataSize - amount of data we need
0: 	 *
0: 	 * @exception	DRDAProtocolException
0: 	 */
0: 	private void ensureALayerDataInBuffer (int desiredDataSize) 
0: 		throws DRDAProtocolException
0: 	{
0: 		// calulate the the number of bytes in the buffer.
0: 		int avail = count - pos;
0: 
0: 		// read more bytes off the network if the data is not in the buffer already.
0: 		if (avail < desiredDataSize) 
0: 		{
0: 		  fill (desiredDataSize - avail);
0: 		}
0: 	}
0: 	/**
0: 	 * Make sure a certain amount of Layer B data is in the buffer.
0: 	 * The data will be in the buffer after this method is called.
0: 	 *
0: 	 * @param desiredDataSize - amount of data we need
0: 	 * @param adjustLen	- whether to adjust the remaining lengths
0: 	 *
0: 	 * @exception DRDProtocolException
0: 	 */
0: 	private void ensureBLayerDataInBuffer (int desiredDataSize, boolean adjustLen) 
0: 		throws DRDAProtocolException
0: 	{
0: 		if (dssIsContinued) 
0: 		{
0: 			if (desiredDataSize > dssLength) 
0: 			{
0: 				int continueDssHeaderCount =
0: 					(((desiredDataSize - dssLength) / DssConstants.MAX_DSS_LENGTH) + 1);
0: 				compressBLayerData (continueDssHeaderCount);
0: 			}
0: 		}
0: 		else 
0: 		{
0: 			ensureALayerDataInBuffer (desiredDataSize);
0: 		}
0: 		if (adjustLen)
0: 			adjustLengths(desiredDataSize);
0: 	}
0: 
0: 	/**
0: 	 * Compress B Layer data if extended total length is used
0: 	 * by removing the continuation headers
0: 	 *
0: 	 * @param continueDssHeaderCount - amount of data we need
0: 	 *
0: 	 * @exception	throws DRDAProtocolException
0: 	 */
0: 	private void compressBLayerData (int continueDssHeaderCount) 
0: 		throws DRDAProtocolException
0: 	{
0: 
0: 		
0: 		// jump to the last continuation header.
0: 		int tempPos = 0;
0: 		for (int i = 0; i < continueDssHeaderCount; i++) 
0: 		{
0: 			// the first may be less than the size of a full DSS
0: 			if (i == 0) 
0: 			{
0: 				// only jump by the number of bytes remaining in the current DSS
0: 				tempPos = pos + dssLength;
0: 			}
0: 			else 
0: 			{
0: 				// all other jumps are for a full continued DSS
0: 				tempPos += DssConstants.MAX_DSS_LENGTH;
0: 			}
0: 		}
0: 
0: 
0: 		// for each of the DSS headers to remove,
0: 		// read out the continuation header and increment the DSS length by the
0: 		// size of the continuation bytes,	then shift the continuation data as needed.
0: 		int shiftSize = 0;
0: 		int bytesToShift = 0;
0: 		int continueHeaderLength = 0;
0: 		int newdssLength = 0;
0: 
0: 
0: 		for (int i = 0; i < continueDssHeaderCount; i++) 
0: 		{
0: 			continueHeaderLength = ((buffer[tempPos] & 0xff) << 8) +
0: 				((buffer[tempPos + 1] & 0xff) << 0);
0: 
0: 			if (i == 0) 
0: 			{
0: 				// if this is the last one (farthest down stream and first to strip out)
0: 
0: 				if ((continueHeaderLength & DssConstants.CONTINUATION_BIT) 
0: 						== DssConstants.CONTINUATION_BIT)
0: 				{
0: 				  // the last DSS header is again continued
0: 				  continueHeaderLength = DssConstants.MAX_DSS_LENGTH;
0: 				  dssIsContinued = true;
0: 				}
0: 				else 
0: 				{
0: 				  // the last DSS header was not contiued so update continue state flag
0: 				  dssIsContinued = false;
0: 				}
0: 				// the very first shift size is 2
0: 				shiftSize = 2;
0: 			}
0: 			else 
0: 			{
0: 				// already removed the last header so make sure the chaining flag is on
0: 				if ((continueHeaderLength & DssConstants.CONTINUATION_BIT) == 
0: 						DssConstants.CONTINUATION_BIT)
0: 				{
0: 				  continueHeaderLength = DssConstants.MAX_DSS_LENGTH;
0: 				}
0: 				else 
0: 				{
0: 				  // this is a syntax error but not really certain which one.
0: 				  // for now pick 0x02 which is DSS header Length does not 
0: 				  // match the number
0: 				    // of bytes of data found.
0: 					agent.throwSyntaxrm(CodePoint.SYNERRCD_DSS_LENGTH_BYTE_NUMBER_MISMATCH,
0: 									   DRDAProtocolException.NO_CODPNT_ARG);
0: 				}
0: 				// increase the shift size by 2
0: 				shiftSize += 2;
0: 			}
0: 
0: 			// it is a syntax error if the DSS continuation is less 
0: 			// than or equal to two
0: 			if (continueHeaderLength <= 2) 
0: 			{
0: 				agent.throwSyntaxrm(CodePoint.SYNERRCD_DSS_CONT_LESS_OR_EQUAL_2,
0: 							   DRDAProtocolException.NO_CODPNT_ARG);
0: 			}
0: 
0: 			newdssLength += continueHeaderLength;
0: 
0: 			// calculate the number of bytes to shift
0: 			if (i == (continueDssHeaderCount - 1))
0: 				bytesToShift = DssConstants.MAX_DSS_LENGTH;
0: 			else
0: 				bytesToShift = dssLength;
0: 
0: 			tempPos -= (shiftSize - 1);
0: 			System.arraycopy(buffer, tempPos, buffer, tempPos - bytesToShift +
0: 							 shiftSize , bytesToShift);
0: 			tempPos -= bytesToShift;
0: 			tempPos += (shiftSize + 1);
0: 		}
0: 		// reposition the start of the data after the final DSS shift.
0: 		pos = tempPos;
0: 	}
0: 
0: 	/**
0: 	 * Methods to manage the data buffer.
0: 	 * Methods orginally from JCC
0: 	 * RESOLVE: need to check if this is the best performing way of doing this
0: 	 */
0: 
0: 	/**
0: 	 * This is a helper method which shifts the buffered bytes from
0: 	 * wherever they are in the current buffer to the beginning of
0: 	 * different buffer (note these buffers could be the same).
0: 	 * State information is updated as needed after the shift.
0: 	 * @param destinationBuffer - buffer to shift data to
0: 	 */
0: 	private void shiftBuffer (byte[] destinationBuffer)
0: 	{
0: 		// calculate the size of the data in the current buffer.
0: 		int sz = count - pos;
0: 		if (SanityManager.DEBUG) {
0: 			if ((sz < 0 || pos < 0) )
0: 			{
0: 				SanityManager.THROWASSERT(
0: 					      "Unexpected data size or position. sz=" + sz + 
0: 						  " count=" + count +" pos=" + pos);
0: 			}
0: 		}
0: 		
0: 		// copy this data to the new buffer startsing at position 0.
0: 		System.arraycopy (buffer, pos, destinationBuffer, 0, sz);
0: 
0: 		// update the state information for data in the new buffer.
0: 		pos = 0;
0: 		count = sz;
0: 
0: 		// replace the old buffer with the new buffer.
0: 		buffer = destinationBuffer;
0: 	}
0: 	/**
0: 	 * This method makes sure there is enough room in the buffer
0: 	 * for a certain number of bytes.  This method will allocate
0: 	 * a new buffer if needed and shift the bytes in the current buffer
0: 	 * to make ensure space is available for a fill.  Right now
0: 	 * this method will shift bytes as needed to make sure there is
0: 	 * as much room as possible in the buffer before trying to
0: 	 * do the read.  The idea is to try to have space to get as much data as possible
0: 	 * if we need to do a read on the socket's stream.
0: 	 *
0: 	 * @param desiredSpace - amount of data we need
0: 	 */
0: 	private void ensureSpaceInBufferForFill (int desiredSpace)
0: 	{
0: 		// calculate the total unused space in the buffer.
0: 		// this includes any space at the end of the buffer and any free
0: 		// space at the beginning resulting from bytes already read.
0: 		int currentAvailableSpace = (buffer.length - count) + pos;
0: 
0: 		// check to see if there is enough free space.
0: 		if (currentAvailableSpace < desiredSpace) {
0: 
0: 			// there is not enough free space so we need more storage.
0: 			// we are going to double the buffer unless that happens to still be 
0: 			// too small. If more than double the buffer is needed, 
0: 			// use the smallest amount over this as possible.
0: 			int doubleBufferSize = (2 * buffer.length);
0: 			int minumNewBufferSize = (desiredSpace - currentAvailableSpace) + 
0: 				buffer.length;
0: 			int newsz = minumNewBufferSize <= doubleBufferSize ? 
0: 				doubleBufferSize : minumNewBufferSize;
0: 
0: 			byte[] newBuffer = new byte[newsz];
0: 
0: 			// shift everything from the old buffer to the new buffer
0: 			shiftBuffer (newBuffer);
0: 		}
0: 		else {
0: 
0: 			// there is enough free space in the buffer but let's make sure
0: 			// it is all at the end.
0: 			// this is also important because if we are going to do a read, 
0: 			// it would be nice
0: 			// to get as much data as possible and making room at the end 
0: 			// if the buffer helps to ensure this.
0: 			if (pos != 0) {
0: 				shiftBuffer (buffer);
0: 			}
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * This method will attempt to read a minimum number of bytes
0: 	 * from the underlying stream.	This method will keep trying to
0: 	 * read bytes until it has obtained at least the minimum number.
0: 	 * @param minimumBytesNeeded - minimum required bytes
0: 	 *
0: 	 * @exception DRDProtocolException
0: 	 */
0: 	private void fill (int minimumBytesNeeded) throws DRDAProtocolException
0: 	{
0: 		// make sure that there is enough space in the buffer to hold
0: 		// the minimum number of bytes needed.
0: 		ensureSpaceInBufferForFill (minimumBytesNeeded);
0: 
0: 		// read until the minimum number of bytes needed is now in the buffer.
0: 		// hopefully the read method will return as many bytes as it can.
0: 		int totalBytesRead = 0;
0: 		int actualBytesRead = 0;
0: 		do {
0: 			try {
0: 				actualBytesRead = inputStream.read (
0: 				  buffer, count, buffer.length - count);
0: 			}
0: 			catch (java.io.IOException ioe) {
0: 				agent.markCommunicationsFailure ("DDMReader.fill()",
0: 				  "InputStream.read()", ioe.getMessage(), "*");
0: 			}
0: 			finally {
0: 				if ((dssTrace != null) && dssTrace.isComBufferTraceOn())
0: 				  dssTrace.writeComBufferData (buffer,
0: 				                               count,
0: 				                               actualBytesRead,
0: 				                               DssTrace.TYPE_TRACE_RECEIVE,
0: 				                               "Request",
0: 				                               "fill",
0: 				                               5);
0: 			}
0: 			count += actualBytesRead;
0: 			totalBytesRead += actualBytesRead;
0: 
0: 		}
0: 		while ((totalBytesRead < minimumBytesNeeded) && (actualBytesRead != -1));
0: 		if (actualBytesRead == -1) 
0: 		{
0: 			if (totalBytesRead < minimumBytesNeeded) 
0: 			{
0: 				agent.markCommunicationsFailure ("DDMReader.fill()",
0: 				  "InputStream.read()", "insufficient data", "*");
0: 			}
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Print a internal trace message
0: 	 */
0: 	private void trace(String msg)
0: 	{
0: 		if (agent != null)
0: 			agent.trace(msg);
0: 	}
0: 
0: 	protected String toDebugString(String indent)
0: 	{
0: 		String s = indent + "***** DDMReader toDebugString ******\n";
0: 		int buflen = 0;
0: 		if (buffer != null)
0: 			buflen = buffer.length;
0: 	   s += indent + "Reader buffer length = " + buffer.length + "\n";
0: 	   return s;
0: 	}
0: }
============================================================================