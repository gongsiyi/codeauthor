2:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.store.raw.xact.TransactionTable
1:345de35: 
1:270a34d:    Licensed to the Apache Software Foundation (ASF) under one or more
1:270a34d:    contributor license agreements.  See the NOTICE file distributed with
1:270a34d:    this work for additional information regarding copyright ownership.
1:270a34d:    The ASF licenses this file to you under the Apache License, Version 2.0
1:270a34d:    (the "License"); you may not use this file except in compliance with
1:270a34d:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
33:eac0369: 
7:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.store.raw.xact;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.context.ContextManager;
1:eac0369: 
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: import org.apache.derby.iapi.services.io.Formatable;
1:eac0369: import org.apache.derby.iapi.services.io.StoredFormatIds;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.access.TransactionInfo;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.raw.GlobalTransactionId;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.raw.log.LogInstant;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.raw.xact.RawTransaction;
1:eac0369: import org.apache.derby.iapi.store.raw.xact.TransactionId;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.io.CompressedNumber;
1:0fc1787: 
1:e21c3de: import java.util.ArrayList;
1:a809756: import java.util.concurrent.ConcurrentHashMap;
1:eac0369: 
1:eac0369: import java.io.ObjectOutput;
1:eac0369: import java.io.ObjectInput;
1:eac0369: import java.io.IOException;
1:eac0369: 
1:3c48dd9: /**
1:eac0369: 	The transaction table is used by the transaction factory to keep track of
1:eac0369: 	all transactions that are in the system.
1:eac0369: 
1:eac0369: 	<BR> The transction table serves the following purposes: <OL> 
1:eac0369: 
1:eac0369: 	<LI> checkpoint - when a checkpoint log record is written out, it writes
1:eac0369: 	out also all transactions that have updated the database.  RESOLVE: this is
1:eac0369: 	actually not used right now - rather, the transaction table is
1:eac0369: 	reconstructed during the redo phase by traversing from the undo LWM.  It is
1:eac0369: 	a goal to use this transaction table (and traversing from the redoLWM)
1:eac0369: 	instead of rebuilding it to speed up recovery.
1:eac0369: 
1:eac0369: 	<LI> Quiesce State - when a  system enters the quiesce state, it needs to account
1:eac0369: 	for all transactions in the system, even those which are just started and
1:eac0369: 	are in their IDLE state.
1:eac0369: 
1:eac0369: 	<LI> TransactionTable VTI - we need to get a snapshot of all transactions
1:eac0369: 	in the system for diagnostic purposes.
1:eac0369: 	</OL>
1:eac0369: 
1:eac0369: 	In order to speed up the time it takes to look up a transaction from the
1:eac0369: 	transaction table, each transaction must have a unique transaction Id.
1:eac0369: 	This means newly coined transaction must also have a transaction Id.
1:eac0369: 
1:eac0369: 	<P>During recovery, there is only one real xact object doing all the
1:eac0369: 	recovery work, but there could be many outstanding transactions that are
1:eac0369: 	gleamed from the log.  Each of these "recovery transactions" have its on
1:eac0369: 	entry into the transaction table but they all share the same Xact object.
1:eac0369: 
1:eac0369: 	<P>Multithreading considerations:<BR>
1:eac0369: 	TransactionTable must be MT-safe it is called upon by many threads
1:eac0369: 	simultaneously (except during recovery)
1:eac0369: 
1:a809756:     <P>Methods that are only called during
1:e21c3de:     recovery don't need to take MT considerations, and can safely use iterators
1:e21c3de:     with no additional synchronization.
1:eac0369: 
1:3c48dd9: */
1:eac0369: 
1:eac0369: public class TransactionTable implements Formatable
30:eac0369: {
1:eac0369: 	/*
1:eac0369: 	 * Fields
1:eac0369: 	 */
1:62721e6: 
1:a809756:     private final ConcurrentHashMap<TransactionId, TransactionTableEntry> trans;
1:eac0369: 
1:eac0369: 	private TransactionId largestUpdateXactId;
1:eac0369: 
7:eac0369: 	/**
1:eac0369: 		MT - not needed for constructor
1:eac0369: 	*/
1:eac0369: 	public TransactionTable()
1:62721e6: 	{
1:a809756:         trans = new ConcurrentHashMap<TransactionId, TransactionTableEntry>();
37:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*************************************************************
1:eac0369: 	 * generic methods called by all clients of transaction table
1:eac0369: 	 * Must be MT -safe
1:eac0369: 	 ************************************************************/
1:eac0369: 	private TransactionTableEntry findTransactionEntry(TransactionId id)
1:eac0369: 	{
1:eac0369: 
1:0fc1787: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT(
1:eac0369:                 id != null, "findTransacionEntry with null id");
1:0fc1787: 
1:eac0369: 		// Hashtable is synchronized
1:7e7a589: 		return trans.get(id);
1:eac0369: 	}
1:eac0369: 
1:3c48dd9:     /**
1:3c48dd9:      * Interface for visiting entries in the transaction table.
1:3c48dd9:      * @see #visitEntries(EntryVisitor)
1:3c48dd9:      */
1:3c48dd9:     static interface EntryVisitor {
1:3c48dd9:         /**
1:3c48dd9:          * Visit an entry. {@link #visitEntries(EntryVisitor)} will call this
1:e21c3de:          * method once for each entry in the transaction table, or until
1:e21c3de:          * {@code false} is returned by this method.
1:3c48dd9:          *
1:3c48dd9:          * @param entry the {@code TransactionTableEntry} being visited
1:e21c3de:          * @return {@code true} if the scan of the transaction table should
1:e21c3de:          * continue, or {@code false} if the visitor has completed its work
1:e21c3de:          * and no more entries need to be visited
1:e21c3de:          */
1:e21c3de:         boolean visit(TransactionTableEntry entry);
1:3c48dd9:     }
1:eac0369: 
1:e21c3de:     /**
1:3c48dd9:      * <p>
1:3c48dd9:      * Visit all the entries in the transaction table.
1:3c48dd9:      * </p>
1:3c48dd9:      *
1:3c48dd9:      * <p>
1:3c48dd9:      * MT - MT safe
1:3c48dd9:      * </p>
1:3c48dd9:      *
1:5b43e6f:      * <p>
1:5b43e6f:      * Entries that are added to or removed from the transaction table while
1:5b43e6f:      * it's being traversed, may or may not be visited. All the entries that
1:5b43e6f:      * are present in the map when this method is called, and have not been
1:5b43e6f:      * removed when the method returns, will have been visited exactly once
1:5b43e6f:      * (except if the {@code visit()} method returns false before all entries
1:5b43e6f:      * have been visited, in which case the traversal of the map will stop
1:5b43e6f:      * earlier).
1:5b43e6f:      * </p>
1:5b43e6f:      *
1:5b43e6f:      * <p>
1:5b43e6f:      * Note however that this method does not guarantee that a single
1:5b43e6f:      * {@code TransactionTableEntry} is not accessed concurrently by multiple
1:5b43e6f:      * threads. If the visitor accesses some of the entry's mutable state, the
1:5b43e6f:      * caller must ensure that appropriate synchronization protection is in
1:5b43e6f:      * place. For example, if accessing the update state of the entry, the
1:5b43e6f:      * caller must synchronize on "this" (the {@code TransactionTable}
1:5b43e6f:      * instance).
1:5b43e6f:      * </p>
1:5b43e6f:      *
1:3c48dd9:      * @param visitor the visitor to apply on each transaction table entry
1:3c48dd9:      */
1:3c48dd9:     void visitEntries(EntryVisitor visitor) {
1:a809756:         for (Object entry : trans.values()) {
1:a809756:             if (!visitor.visit((TransactionTableEntry) entry)) {
1:a809756:                 // The visitor returned false, meaning that it's done with
1:a809756:                 // all of its work and we can stop the scan.
1:a809756:                 break;
1:a809756:             }
1:a809756:         }
1:e21c3de:     }
1:eac0369: 
1:eac0369: 
1:eac0369: 	void add(Xact xact, boolean exclude)
1:eac0369: 	{
1:eac0369: 		TransactionId id = xact.getId();
1:eac0369: 
1:9b450ec:         TransactionTableEntry newEntry = new TransactionTableEntry(
1:9b450ec:                 xact, id, 0, exclude ? TransactionTableEntry.EXCLUDE : 0);
1:9b450ec: 
2:eac0369: 		synchronized(this)
1:eac0369: 		{
1:9b450ec:             Object oldEntry = trans.put(id, newEntry);
1:eac0369: 
1:9b450ec:             if (SanityManager.DEBUG)
1:9b450ec:             {
1:9b450ec:                 SanityManager.ASSERT(
1:9b450ec:                         oldEntry == null,
1:9b450ec:                         "Trying to add a transaction that's already " +
1:9b450ec:                         "in the transaction table");
1:eac0369: 
1:9b450ec:                 if (SanityManager.DEBUG_ON("TranTrace"))
1:eac0369:                 {
1:9b450ec:                     SanityManager.DEBUG(
1:9b450ec:                         "TranTrace", "adding transaction " + id);
1:9b450ec:                     SanityManager.showTrace(new Throwable("TranTrace"));
1:3c48dd9:                 }
1:3c48dd9:             }
1:3c48dd9: 		}
1:eac0369: 
1:e21c3de: 		if (SanityManager.DEBUG) {
1:eac0369: 
1:eac0369: 			if (SanityManager.DEBUG_ON("memoryLeakTrace")) {
1:eac0369: 
1:eac0369: 				if (trans.size() > 50)
1:eac0369: 					System.out.println("memoryLeakTrace:TransactionTable " + trans.size());
1:9b450ec: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:ee9c803: 	/**
1:eac0369: 		remove the transaction Id an return false iff the transaction is found
1:eac0369: 		in the table and it doesn't need exclusion during quiesce state
1:eac0369: 	 */
1:eac0369: 	boolean remove(TransactionId id)
1:eac0369: 	{
6:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT(
1:eac0369:                 id != null, 
1:eac0369:                 "cannot remove transaction from table with null id");
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369:         {
2:eac0369:             if (SanityManager.DEBUG_ON("TranTrace"))
1:eac0369:             {
2:eac0369:                 SanityManager.DEBUG(
1:eac0369:                     "TranTrace", "removing transaction " + id);
2:eac0369:                 SanityManager.showTrace(new Throwable("TranTrace"));
1:eac0369:             }
1:eac0369:         }
1:eac0369: 
1:eac0369: 		// Hashtable is synchronized
1:7e7a589: 		 TransactionTableEntry ent = trans.remove(id);
1:eac0369: 		 return (ent == null || ent.needExclusion());
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Change a transaction to update or add an update transaction to this table.
1:eac0369: 
1:eac0369: 		@param tid the transaction id
1:eac0369: 		@param tran the transaction to be added
1:eac0369: 		@param transactionStatus the transaction status that is stored in the
1:eac0369: 				BeginXact log record
1:eac0369: 	 */
1:eac0369: 	public void addUpdateTransaction(TransactionId tid, RawTransaction tran,
1:eac0369: 									 int transactionStatus)
1:eac0369: 	{
1:eac0369: 
1:eac0369: 		// we need to synchronize on the transaction table because we have to
1:eac0369: 		// prevent this state change from happening when the transaction table
1:eac0369: 		// itself is written out to the checkpoint.  This is the only
1:eac0369: 		// protection the TransactionTableEntry has to prevent fields in myxact
1:eac0369: 		// from changing underneath it while it is being written out.
1:eac0369: 		synchronized(this)
1:eac0369: 		{
1:eac0369: 			TransactionTableEntry ent = findTransactionEntry(tid);
1:eac0369: 
2:eac0369: 			if (ent != null)
1:eac0369: 			{
1:eac0369: 				// this happens during run time, when a transaction that is
1:eac0369: 				// already started changed status to an update transaction
1:eac0369: 
1:eac0369: 				ent.updateTransactionStatus((Xact)tran, transactionStatus,
1:eac0369: 											TransactionTableEntry.UPDATE) ;
1:eac0369: 			}
2:eac0369: 			else
1:eac0369: 			{
1:eac0369: 				// this happens during recovery, that's why we haven't seen
1:eac0369: 				// this transaction before - it is added in the doMe of the 
1:eac0369: 				// BeginXact log record.
1:eac0369: 				//
1:eac0369: 				// No matter what this transaction is, it won't need to be run
1:eac0369: 				// in quiesce state because we are in recovery.
1:eac0369: 				ent = new TransactionTableEntry((Xact)tran, tid, transactionStatus, 
1:eac0369: 												TransactionTableEntry.UPDATE | 
1:eac0369: 												TransactionTableEntry.EXCLUDE |
1:eac0369: 												TransactionTableEntry.RECOVERY);
1:eac0369: 				trans.put(tid, ent);
1:eac0369: 
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			if (XactId.compare(ent.getXid(), largestUpdateXactId) > 0)
1:eac0369: 				largestUpdateXactId = ent.getXid();
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	    Change update transaction to non-update
1:eac0369: 
1:eac0369: 		<P>MT - MT safe, since vector is MT-safe.
1:eac0369: 
1:eac0369: 		@param id the transaction Id
1:eac0369: 	  */
1:eac0369: 	void removeUpdateTransaction(TransactionId id)
1:eac0369: 	{
1:eac0369: 		// we need to synchronize on the transaction table because we have to
1:eac0369: 		// prevent this state change from happening when the transaction table
1:eac0369: 		// itself is written out to the checkpoint.  This is the only
1:eac0369: 		// protection the TransactionTableEntry has to prevent fields in myxact
1:eac0369: 		// from changing underneath it while it is being written out.
1:eac0369: 
1:eac0369: 		synchronized (this)
1:e21c3de: 		{
2:eac0369: 			TransactionTableEntry ent = findTransactionEntry(id);
1:e21c3de: 
1:eac0369: 			if (SanityManager.DEBUG)
1:eac0369: 			{
1:eac0369: 				SanityManager.ASSERT(ent != null, 
1:eac0369: 				 "removing update transaction that is not there");
1:e21c3de: 			}
1:eac0369: 
1:eac0369: 			ent.removeUpdateTransaction();
1:eac0369: 
1:eac0369: 			// If we are committing a recovery transaction, remove it from the
1:eac0369: 			// transaction table.  The xact object which is doing the work is
1:eac0369: 			// not going to be closed even though the transaction is done.
1:eac0369: 			if (ent.isRecovery())
1:eac0369: 				remove(id);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return;
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**************************************************************************
1:eac0369:      * Transaction table methods used by XA.
1:eac0369:      **************************************************************************
1:e21c3de:      */
1:eac0369: 
1:e21c3de: 	/**
1:eac0369: 	    Change transaction to prepared.
1:eac0369: 
2:eac0369: 		<P>MT - unsafe, caller is recovery, which is single threaded.
1:eac0369: 
1:eac0369: 		@param id the transaction Id
1:e21c3de: 	  */
1:eac0369: 	void prepareTransaction(TransactionId id)
1:eac0369: 	{
1:eac0369: 		// we need to synchronize on the transaction table because we have to
1:eac0369: 		// prevent this state change from happening when the transaction table
1:eac0369: 		// itself is written out to the checkpoint.  This is the only
1:eac0369: 		// protection the TransactionTableEntry has to prevent fields in myxact
1:eac0369: 		// from changing underneath it while it is being written out.
1:eac0369: 
1:eac0369:         TransactionTableEntry ent = findTransactionEntry(id);
1:eac0369: 
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:             SanityManager.ASSERT(
1:eac0369:                 ent != null, "preparing transaction that is not there");
1:eac0369:         }
1:eac0369: 
1:eac0369:         ent.prepareTransaction();
1:eac0369: 
1:eac0369: 		return;
1:eac0369: 	}
1:eac0369: 
1:e21c3de:     /**
1:eac0369:      * Find a transaction in the table by Global transaction id.
4:eac0369:      * <p>
1:62721e6:      * This routine use to be only called during offline recovery so performance
1:62721e6:      * was not critical.  Since that time more calls have been made, including
1:62721e6:      * one in startGlobalTransaction() so a linear search may no longer
1:62721e6:      * be appropriate.  See DERBY-828.
1:e21c3de:      *
2:eac0369: 	 * @return The ContextManager of the transaction being searched for.
5:eac0369:      *
2:eac0369:      * @param global_id The global transaction we are searching for.
2:eac0369:      **/
1:eac0369: 	public ContextManager findTransactionContextByGlobalId(
1:e21c3de:     final GlobalXactId global_id)
1:eac0369: 	{
1:a809756:         for (TransactionTableEntry entry : trans.values()) {
1:a809756:             GlobalTransactionId entry_gid = entry.getGid();
1:a809756:             if (entry_gid != null && entry_gid.equals(global_id)) {
1:a809756:                 return entry.getXact().getContextManager();
1:a809756:             }
1:62721e6:         }
1:e21c3de: 
1:a809756:         return null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/***********************************************************
1:eac0369: 	 * called when system is being quiesced, must be MT - safe
1:eac0369: 	 ***********************************************************/
1:e21c3de: 	/**
1:eac0369: 		Return true if there is no transaction actively updating the database.
1:eac0369: 		New transaction may be started or old transaction committed
1:eac0369: 		right afterward, the caller of this routine must have other ways to
1:eac0369: 		stop transactions from starting or ending.
1:eac0369: 
1:eac0369: 		<P>MT - safe
1:e21c3de: 	*/
1:eac0369: 	boolean hasActiveUpdateTransaction()
1:eac0369: 	{
1:eac0369: 		synchronized (this)
1:eac0369: 		{
1:a809756:             for (TransactionTableEntry entry : trans.values()) {
1:a809756:                 if (entry.isUpdate()) {
1:a809756:                     return true;
1:a809756:                 }
1:e21c3de:             }
1:e21c3de:         }
1:e21c3de: 
1:a809756:         return false;
1:e21c3de:     }
1:eac0369: 
1:eac0369: 	/************************************************************
1:eac0369: 	 * methods called only by checkpoint
1:eac0369: 	 ***********************************************************/
1:eac0369: 	/*
1:eac0369: 	 * Formatable methods
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Return my format identifier.
1:eac0369: 	*/
1:eac0369: 	public int getTypeFormatId() {
1:eac0369: 		return StoredFormatIds.RAW_STORE_TRANSACTION_TABLE;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  @exception IOException problem reading the transaction table
1:eac0369: 	*/
1:e21c3de: 	public void writeExternal(final ObjectOutput out) throws IOException
1:eac0369: 	{
1:eac0369: 		//don't let the transactions status change while writing out(beetle:5533)
1:e21c3de:         // We don't care if transactions are added or removed from the table
1:e21c3de:         // while we're writing it out, as long as the number of update
1:e21c3de:         // transactions is constant. Synchronizing on "this" prevents other
1:e21c3de:         // threads from adding or removing update transactions.
1:eac0369: 
1:eac0369: 		synchronized(this)
1:e21c3de:         {
1:a809756:             int count = 0;
1:a809756:             for (TransactionTableEntry entry : trans.values()) {
1:a809756:                 if (entry.isUpdate()) {
1:a809756:                     count++;
1:a809756:                 }
1:a809756:             }
1:eac0369: 
1:e21c3de:             CompressedNumber.writeInt(out, count);
1:e21c3de: 
1:e21c3de:             // now write them out
1:e21c3de:             if (count > 0)
1:e21c3de:             {
1:e21c3de:                 // Count the number of writes in debug builds.
1:a809756:                 int writeCount = 0;
1:e21c3de: 
1:a809756:                 for (TransactionTableEntry entry : trans.values()) {
1:a809756:                     if (entry.isUpdate()) {
1:a809756:                         // only write out update transactions
1:a809756:                         out.writeObject(entry);
1:a809756:                         if (SanityManager.DEBUG) {
1:a809756:                             writeCount++;
1:e21c3de:                         }
1:e21c3de:                     }
1:e21c3de:                 }
1:e21c3de: 
1:e21c3de:                 // Verify that we wrote the expected number of transactions.
1:e21c3de:                 if (SanityManager.DEBUG) {
1:a809756:                     SanityManager.ASSERT(count == writeCount);
1:e21c3de:                 }
1:e21c3de: 			}
1:e21c3de: 		}
1:e21c3de: 	}
1:e21c3de: 
1:eac0369: 	/************************************************************
1:eac0369: 	 * methods called only by recovery
1:eac0369: 	 ************************************************************/
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  @exception IOException problem reading the transaction table
1:eac0369: 	  @exception ClassNotFoundException problem reading the transaction table
1:eac0369: 	 */
1:eac0369: 	public void readExternal(ObjectInput in) 
1:eac0369: 		 throws IOException, ClassNotFoundException
1:eac0369: 	{
1:eac0369: 		// RESOLVE: this is only read in checkpoint record, but we have not
1:eac0369: 		// finish the work on using this transaction table to cut down on redo
1:eac0369: 		// so this transaction table is effectively and futilely thrown away!
1:eac0369: 
1:eac0369: 		int count = CompressedNumber.readInt(in);
1:eac0369: 		if (count == 0)
1:eac0369: 			return;
1:eac0369: 
1:eac0369: 		for (int i = 0; i < count; i++)
1:eac0369: 		{
1:6e66e70: 			TransactionTableEntry ent = 
1:eac0369: 				(TransactionTableEntry)in.readObject();
1:eac0369: 
1:eac0369: 			if (SanityManager.DEBUG)
1:eac0369: 				SanityManager.ASSERT(
1:eac0369:                     ent.getXid() != null,
1:eac0369:                     "read in transaction table entry with null id");
1:eac0369: 
1:eac0369: 			trans.put(ent.getXid(), ent);
1:eac0369: 
1:eac0369: 			if (ent.isUpdate() && 
1:eac0369:                 XactId.compare(ent.getXid(), largestUpdateXactId) > 0)
1:6e66e70:             {
1:eac0369: 				largestUpdateXactId = ent.getXid();
1:6e66e70:             }
1:eac0369: 		}
1:eac0369: 
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:7a4afea: 		Return the largest update transactionId I have seen so far.
1:eac0369: 
1:eac0369: 		<P>MT - unsafe, caller is recovery, which is single threaded.
1:eac0369: 	*/
1:eac0369: 	public TransactionId largestUpdateXactId()
1:eac0369: 	{
1:eac0369: 		return largestUpdateXactId;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:7a4afea: 		Is there an active internal transaction in the transaction table.
1:eac0369: 
1:eac0369: 		<P>MT - unsafe, caller is recovery, which is single threaded.
1:eac0369: 	*/
1:eac0369: 	public boolean hasRollbackFirstTransaction()
1:eac0369: 	{
1:a809756:         for (TransactionTableEntry ent : trans.values())
1:eac0369: 		{
2:eac0369: 			if (ent != null && ent.isRecovery() && 
1:eac0369: 				(ent.getTransactionStatus() & 
1:eac0369:                      Xact.RECOVERY_ROLLBACK_FIRST) != 0)
1:eac0369:             {
3:eac0369: 				return true;
1:eac0369:             }
1:eac0369: 		}
3:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:32635d2:        Is there a prepared transaction that are recovered 
1:32635d2:        durring the recovery in the transaction table.
1:eac0369: 
1:32635d2:        <P>MT - unsafe, caller is recovery, which is single threaded.
1:32635d2:     */
1:32635d2:     public boolean hasPreparedRecoveredXact()
1:32635d2:     {
1:32635d2:         return hasPreparedXact(true);
1:32635d2:     }
1:32635d2: 
1:eac0369: 
1:32635d2:     /**
1:32635d2:        Is there a prepared transaction in the transaction table.
1:32635d2:        <P>MT - unsafe, called during boot, which is single threaded.
1:32635d2:     */
1:32635d2:     public boolean hasPreparedXact()
1:32635d2:     {
1:32635d2:         return hasPreparedXact(false);
1:32635d2:     }
1:32635d2: 
1:32635d2:     /**
1:32635d2:      * Is there a prepared transaction in the transaction table.
1:32635d2:      * 
1:32635d2:      * <P>MT - unsafe, caller is recovery/at boot, which is single threaded.
1:32635d2:      *
1:32635d2:      * @param recovered  <code> true </code> to search  for transaction 
1:32635d2:      *                  that are in prepared during recovery.  
1:32635d2:      *                  recovered tranaction. 
1:dbed020:      *                  <code> false &gt; to search for just prepared 
1:32635d2:      *                  transactons. 
1:32635d2:      * @return         <code> true if there is a prepared transaction and
1:32635d2:      *                  recovered when <code> recovered </code> argument is 
1:32635d2:      *                  <code> true </code>
1:32635d2:      */
1:32635d2: 
1:32635d2:     private boolean hasPreparedXact(boolean recovered)
1:32635d2:     {
1:a809756:         for (TransactionTableEntry ent : trans.values())
1:32635d2:         {
1:32635d2:             if (ent != null && 
1:32635d2:                 (ent.getTransactionStatus() & Xact.END_PREPARED) != 0)
1:eac0369:             {
1:32635d2:                 if (recovered) {
1:32635d2:                     if(ent.isRecovery())
1:32635d2:                         return true;
1:e21c3de:                 } else {
1:32635d2:                     return true;
1:32635d2:                 }
1:32635d2:             }
1:32635d2:         }
1:32635d2:         return false;
1:eac0369:     }
1:32635d2: 
1:32635d2: 
1:32635d2: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Get the most recently added transaction that says it needs to be
1:eac0369: 		rolled back first (an InternalXact) from the transaction table and make
1:eac0369: 		the passed in transaction assume its identity. 
1:eac0369: 		<B> Should only be used in recovery undo !! </B>
1:eac0369: 		RESOLVE: (sku)I don't think even these internal transactions need to be
1:eac0369: 		rolled back in the reverse order, because they are physical in nature.
1:eac0369: 		But it won't hurt.
1:eac0369: 
1:eac0369: 		<P>MT - unsafe, caller is recovery, which is single threaded.
1:eac0369: 	*/
1:eac0369: 	public boolean getMostRecentRollbackFirstTransaction(RawTransaction tran)
1:eac0369: 	{
1:eac0369: 
2:eac0369: 		if (trans.isEmpty())
1:eac0369: 		{
1:eac0369: 			// set tranaction to idle
1:eac0369: 			return findAndAssumeTransaction((TransactionId)null, tran);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		TransactionId id = null;
1:a809756:         for (TransactionTableEntry ent : trans.values())
1:eac0369: 		{
1:eac0369: 			if (ent != null && ent.isUpdate() && ent.isRecovery() &&
1:eac0369: 				(ent.getTransactionStatus() & Xact.RECOVERY_ROLLBACK_FIRST) != 0)
1:eac0369: 			{
1:eac0369: 				// try to locate the most recent one
1:eac0369: 				if (id == null || XactId.compare(id, ent.getXid()) < 0)
1:eac0369: 					id = ent.getXid();
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (id == null)			// set transaction to idle
1:eac0369: 		{
1:eac0369: 			return findAndAssumeTransaction(id, tran);
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			// there is a rollback first transaction
1:eac0369: 			boolean found = 
1:eac0369:                 findAndAssumeTransaction(id, tran);
1:eac0369: 
1:eac0369: 			if (SanityManager.DEBUG)
1:eac0369:             {
1:eac0369:                 if (!found)
1:eac0369:                 {
2:eac0369:                     SanityManager.THROWASSERT(
1:eac0369:                         "cannot find transaction " + id + " in table");
1:eac0369:                 }
1:eac0369:             }
1:eac0369: 
1:eac0369: 			return true;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Get the most recently non-prepared added transaction from the 
1:eac0369:         transaction table and make the passed in transaction assume its 
1:eac0369:         identity.  Prepared transactions will not be undone.
1:eac0369: 
1:eac0369: 		RESOLVE: (sku) I don't think normal user transactions needs to be
1:eac0369: 		rolled back in order, but it won't hurt.
1:eac0369: 
1:eac0369: 		<B> Should only be used in recovery undo !! </B>
1:eac0369: 
1:eac0369: 		<P>MT - unsafe, caller is recovery, which is single threaded.
1:eac0369: 	*/
1:eac0369: 	public boolean getMostRecentTransactionForRollback(RawTransaction tran)
1:eac0369: 	{
1:eac0369:         TransactionId id = null;
1:eac0369: 
1:eac0369:         if (!trans.isEmpty())
1:eac0369: 		{
1:a809756:             for (TransactionTableEntry ent : trans.values())
1:eac0369: 			{
1:eac0369: 				if (ent != null         && 
1:eac0369:                     ent.isUpdate()      && 
1:eac0369:                     ent.isRecovery()    && 
1:eac0369:                     !ent.isPrepared())
1:eac0369: 				{
1:eac0369: 					// try to locate the most recent one
1:eac0369: 					if (id == null || XactId.compare(id, ent.getXid()) < 0)
1:eac0369: 						id = ent.getXid();
1:eac0369: 				}
1:eac0369: 
1:eac0369: 				if (SanityManager.DEBUG)
1:eac0369: 				{
1:eac0369: 					if (ent != null         && 
1:eac0369:                         ent.isUpdate()      && 
1:eac0369:                         ent.isRecovery()    &&
1:eac0369: 						(ent.getTransactionStatus() & 
1:eac0369:                          Xact.RECOVERY_ROLLBACK_FIRST) != 0)
1:eac0369:                     {
1:eac0369: 						SanityManager.THROWASSERT(
1:eac0369:                             "still rollback first xacts in the tran table!");
1:eac0369:                     }
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			if (SanityManager.DEBUG)
1:eac0369:             {
1:eac0369:                 // if all transactions are prepared then it is possible that
1:eac0369:                 // no transaction will be found, in that case id will be null.
1:eac0369:                 if (id != null)
1:eac0369:                 {
1:eac0369:                     SanityManager.ASSERT(findTransactionEntry(id) != null);
1:eac0369:                 }
1:eac0369:                 else
1:eac0369:                 {
1:eac0369:                     // all transactions in the table must be prepared.
1:a809756:                     for (TransactionTableEntry ent : trans.values())
1:eac0369:                     {
1:eac0369:                         SanityManager.ASSERT(ent.isPrepared());
1:eac0369:                     }
1:eac0369:                 }
1:eac0369:             }
1:eac0369: 		}
1:eac0369: 
1:eac0369:         return(findAndAssumeTransaction(id, tran));
1:eac0369: 	}	
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Get the most recently added transaction that says it is prepared during
1:eac0369:         recovery the transaction table and make the passed in transaction 
1:eac0369:         assume its identity. This routine turns off the isRecovery() state
1:eac0369: 		<B> Should only be used in recovery handle prepare after undo !! </B>
1:eac0369: 
1:eac0369: 		<P>MT - unsafe, caller is recovery, which is single threaded.
1:eac0369: 	*/
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Get the most recent recovered prepared transaction.
1:eac0369:      * <p>
1:eac0369:      * Get the most recently added transaction that says it is prepared during 
1:eac0369:      * recovery the transaction table and make the passed in transaction 
1:eac0369:      * assume its identity. 
1:eac0369:      * <p>
1:eac0369:      * This routine, unlike the redo and rollback getMostRecent*() routines
1:eac0369:      * expects a brand new transaction to be passed in.  If a candidate 
1:eac0369:      * transaction is found, then upon return the transaction table will 
1:eac0369:      * be altered such that the old entry no longer exists, and a new entry
1:eac0369:      * will exist pointing to the transaction passed in.  The new entry will
1:eac0369:      * look the same as if the prepared transaction had been created during
1:eac0369:      * runtime rather than recovery.
1:eac0369:      *
1:eac0369:      * <B> Should only be used in recovery handle prepare after undo !! </B>
1:eac0369:      *
1:eac0369:      * <P>MT - unsafe, caller is recovery, which is single threaded.
1:eac0369:      *
1:eac0369: 	 * @return true if a candidate transaction has been found.  false if no
1:eac0369:      *         prepared/recovery transactions found in the table.
1:eac0369:      *
1:eac0369:      * @param tran   Newly allocated transaction to add to link to a entry.
1:eac0369:      *
1:eac0369:      **/
1:eac0369: 	public boolean getMostRecentPreparedRecoveredXact(
1:eac0369:     RawTransaction tran)
1:eac0369: 	{
1:eac0369:         TransactionTableEntry   found_ent   = null;
1:eac0369: 
1:eac0369:         if (!trans.isEmpty())
1:eac0369: 		{
1:eac0369:             TransactionId           id          = null;
1:eac0369:             GlobalTransactionId     gid         = null;
1:eac0369: 
1:a809756:             for (TransactionTableEntry ent : trans.values())
1:eac0369: 			{
1:eac0369: 				if (ent != null         && 
1:eac0369:                     ent.isRecovery()    && 
1:eac0369:                     ent.isPrepared())
1:eac0369: 				{
1:eac0369: 					// try to locate the most recent one
1:eac0369: 					if (id == null || XactId.compare(id, ent.getXid()) < 0)
1:eac0369:                     {
1:eac0369:                         found_ent = ent;
1:eac0369: 						id        = ent.getXid();
1:eac0369: 						gid       = ent.getGid();
1:eac0369:                     }
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 
1:eac0369:             if (SanityManager.DEBUG)
1:eac0369:             {
1:eac0369:                 if (found_ent == null)
1:eac0369:                 {
1:eac0369:                     // if no entry's were found then the transaction table
1:eac0369:                     // should have the passed in idle tran, and the rest should
1:eac0369:                     // be non-recover, prepared global transactions.
1:a809756:                     for (TransactionTableEntry ent : trans.values())
1:eac0369:                     {
1:eac0369:                         if (XactId.compare(ent.getXid(), tran.getId()) != 0)
1:eac0369:                         {
1:eac0369:                             SanityManager.ASSERT(
1:eac0369:                                 !ent.isRecovery() && ent.isPrepared());
1:eac0369:                             SanityManager.ASSERT(ent.getGid() != null);
1:eac0369:                         }
1:eac0369:                     }
1:eac0369:                 }
1:eac0369:             }
1:eac0369: 
1:eac0369:             if (found_ent != null)
1:eac0369:             {
1:eac0369:                 // At this point there are 2 tt entries of interest:
1:eac0369:                 //     new_ent - the read only transaction entry that was 
1:eac0369:                 //               created when we allocated a new transaction.
1:eac0369:                 //               We will just throw this one away after 
1:eac0369:                 //               assuming the identity of the global xact.
1:eac0369:                 //     found_ent
1:eac0369:                 //             - the entry of the transaction that we are going
1:eac0369:                 //               to take over.
1:eac0369:                 TransactionTableEntry new_ent =
1:7e7a589:                     trans.remove(tran.getId());
1:eac0369: 
1:eac0369:                 // At this point only the found_ent should be in the table.
1:eac0369:                 if (SanityManager.DEBUG)
1:eac0369:                 {
1:eac0369: 	                SanityManager.ASSERT(findTransactionEntry(id) == found_ent);
1:eac0369:                 }
1:eac0369: 
1:eac0369:                 ((Xact) tran).assumeGlobalXactIdentity(found_ent);
1:eac0369: 
1:eac0369:                 // transform this recovery entry, into a runtime entry.
1:eac0369:                 found_ent.unsetRecoveryStatus();
1:eac0369:             }
1:eac0369: 		}
1:eac0369: 
1:eac0369:         return(found_ent != null);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Get the least recently added (oldest) transaction
1:eac0369: 		@return the RawTransaction's first log instant
1:eac0369: 
1:eac0369: 		<P>MT - safe, caller can be recovery or checkpoint
1:eac0369: 	*/
1:eac0369: 	public LogInstant getFirstLogInstant()
1:eac0369: 	{
1:eac0369: 		// assume for now that it is acceptable to return null if a transaction
1:eac0369: 		// starts right in the middle of this call.
1:eac0369: 
1:a809756:         LogInstant logInstant = null;
1:a809756:         for (TransactionTableEntry entry : trans.values()) {
1:a809756:             if (entry.isUpdate()) {
1:a809756:                 if (logInstant == null ||
1:a809756:                         entry.getFirstLog().lessThan(logInstant)) {
1:a809756:                     logInstant = entry.getFirstLog();
1:a809756:                 }
1:a809756:             }
1:eac0369:         }
1:eac0369: 
1:a809756:         return logInstant;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Find a transaction using the transaction id, and make the passed in
1:eac0369: 		transaction assume the identity and properties of that transaction.
1:eac0369: 
1:eac0369: 		<P>MT - unsafe, caller is recovery, which is single threaded.
1:eac0369: 
1:eac0369: 		@param id transaction Id
1:eac0369: 		@param tran the transaction that was made to assume the transactionID
1:c6892a1: 		and all other relevant information stored in the transaction table
1:eac0369: 		@return true if transaction can be found, false otherwise
1:eac0369: 	*/
1:eac0369: 	boolean findAndAssumeTransaction(
1:eac0369:     TransactionId       id, 
1:eac0369:     RawTransaction      tran)
1:eac0369: 	{
1:eac0369: 		// the only caller for this method right now is recovery.  
1:eac0369:         // No need to put in any concurrency control
1:eac0369: 		TransactionTableEntry ent = null;
1:eac0369: 
1:eac0369: 		if (id != null && !trans.isEmpty())
1:eac0369: 		{
1:eac0369: 			ent = findTransactionEntry(id);
1:eac0369: 
1:eac0369: 			if (SanityManager.DEBUG)
1:eac0369: 			{
1:eac0369: 				if (ent != null)
1:eac0369: 					SanityManager.ASSERT(ent.isRecovery(),
1:eac0369: 					"assuming the id of a non-recovery transaction");
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// if no transaction entry found, set transaction to idle
1:eac0369:         ((Xact)tran).assumeIdentity(ent);
1:eac0369: 
1:eac0369: 		return(ent != null);
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**********************************************************
1:eac0369: 	 * Transaction table vti and diagnostics
1:eac0369: 	 * MT - unsafe, caller is getting a snap shot which may be inconsistent 
1:eac0369: 	 *********************************************************/
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Get a printable version of the transaction table
1:eac0369: 	 */
1:eac0369: 	public TransactionInfo[] getTransactionInfo()
1:eac0369: 	{
1:eac0369: 		if (trans.isEmpty())
2:eac0369: 			return null;
1:eac0369: 
1:e21c3de:         if (SanityManager.DEBUG) {
1:e21c3de:             SanityManager.DEBUG("TranTrace", toString());
1:e21c3de:         }
1:eac0369: 
1:7e7a589:         final ArrayList<TransactionTableEntry> tinfo = new ArrayList<TransactionTableEntry>();
1:eac0369: 
1:e21c3de:         // Get clones of all the entries in the transaction table.
1:a809756:         for (TransactionTableEntry entry : trans.values()) {
1:a809756:             tinfo.add((TransactionTableEntry) entry.clone());
1:a809756:         }
1:eac0369: 
1:a809756:         return tinfo.toArray(new TransactionTableEntry[tinfo.size()]);
1:e21c3de: 	}
1:eac0369: 
1:eac0369: 	public String toString()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:e21c3de: 			final StringBuffer str = new StringBuffer(1000).
1:eac0369: 				append("\n**************************\n").
1:eac0369: 				append(super.toString()).
1:eac0369: 				append("\nTransaction Table: size = ").append(trans.size()).
1:eac0369: 				append(" largestUpdateXactId = ").append(largestUpdateXactId).
1:eac0369: 				append("\n");
1:eac0369: 
1:a809756:             boolean hasReadOnlyTransaction = false;
1:eac0369: 
1:a809756:             for (TransactionTableEntry entry : trans.values()) {
1:a809756:                 if (entry.isUpdate()) {
1:a809756:                     str.append(entry);
1:a809756:                 } else {
1:a809756:                     hasReadOnlyTransaction = true;
1:a809756:                 }
1:e21c3de:             }
1:eac0369: 
1:a809756:             if (hasReadOnlyTransaction)
1:eac0369: 			{
1:eac0369: 				str.append("\n READ ONLY TRANSACTIONS \n");
1:eac0369: 
1:a809756:                 for (TransactionTableEntry entry : trans.values()) {
1:a809756:                     if (!entry.isUpdate()) {
1:a809756:                         str.append(entry);
1:a809756:                     }
1:e21c3de:                 }
1:e21c3de: 			}
1:eac0369: 			str.append("---------------------------");
1:eac0369: 			return str.toString();
1:e21c3de: 		}
1:eac0369: 		else
1:eac0369: 			return null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: }
1:eac0369: 
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1:      *                  <code> false &gt; to search for just prepared 
commit:7e7a589
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.impl.store.raw.xact.TransactionTableEntry;
/////////////////////////////////////////////////////////////////////////
0: 	private final Map<TransactionId,TransactionTableEntry> trans;
/////////////////////////////////////////////////////////////////////////
1: 		return trans.get(id);
/////////////////////////////////////////////////////////////////////////
1: 		 TransactionTableEntry ent = trans.remove(id);
/////////////////////////////////////////////////////////////////////////
0: 		for (Iterator<TransactionTableEntry> it = trans.values().iterator(); it.hasNext(); )
0: 			TransactionTableEntry ent = it.next();
/////////////////////////////////////////////////////////////////////////
0:         for (Iterator<TransactionTableEntry> it = trans.values().iterator(); it.hasNext(); )
0:             TransactionTableEntry ent = it.next();
/////////////////////////////////////////////////////////////////////////
0: 		for (Iterator<TransactionTableEntry> it = trans.values().iterator(); it.hasNext(); )
0: 			TransactionTableEntry ent = it.next();
/////////////////////////////////////////////////////////////////////////
0: 			for (Iterator<TransactionTableEntry> it = trans.values().iterator(); it.hasNext() ; )
0: 				TransactionTableEntry ent = it.next();
/////////////////////////////////////////////////////////////////////////
0:                     for (Iterator<TransactionTableEntry> it = trans.values().iterator(); it.hasNext();)
0:                             it.next();
/////////////////////////////////////////////////////////////////////////
0: 			for (Iterator<TransactionTableEntry> it = trans.values().iterator(); it.hasNext(); )
0: 				ent = it.next();
/////////////////////////////////////////////////////////////////////////
0:                     for (Iterator<TransactionTableEntry> it = trans.values().iterator(); it.hasNext();)
0:                         ent = it.next();
/////////////////////////////////////////////////////////////////////////
1:                     trans.remove(tran.getId());
/////////////////////////////////////////////////////////////////////////
1:         final ArrayList<TransactionTableEntry> tinfo = new ArrayList<TransactionTableEntry>();
0:                 tinfo.add( (TransactionTableEntry) entry.clone());
commit:270a34d
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:a809756
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.ConcurrentHashMap;
/////////////////////////////////////////////////////////////////////////
1:     <P>Methods that are only called during
/////////////////////////////////////////////////////////////////////////
1:     private final ConcurrentHashMap<TransactionId, TransactionTableEntry> trans;
/////////////////////////////////////////////////////////////////////////
1:         trans = new ConcurrentHashMap<TransactionId, TransactionTableEntry>();
/////////////////////////////////////////////////////////////////////////
1:         for (Object entry : trans.values()) {
1:             if (!visitor.visit((TransactionTableEntry) entry)) {
1:                 // The visitor returned false, meaning that it's done with
1:                 // all of its work and we can stop the scan.
1:                 break;
1:             }
1:         }
/////////////////////////////////////////////////////////////////////////
1:         for (TransactionTableEntry entry : trans.values()) {
1:             GlobalTransactionId entry_gid = entry.getGid();
1:             if (entry_gid != null && entry_gid.equals(global_id)) {
1:                 return entry.getXact().getContextManager();
1:         }
1:         return null;
/////////////////////////////////////////////////////////////////////////
1:             for (TransactionTableEntry entry : trans.values()) {
1:                 if (entry.isUpdate()) {
1:                     return true;
1:                 }
1:         return false;
/////////////////////////////////////////////////////////////////////////
1:             int count = 0;
1:             for (TransactionTableEntry entry : trans.values()) {
1:                 if (entry.isUpdate()) {
1:                     count++;
1:                 }
1:             }
/////////////////////////////////////////////////////////////////////////
1:                 int writeCount = 0;
1:                 for (TransactionTableEntry entry : trans.values()) {
1:                     if (entry.isUpdate()) {
1:                         // only write out update transactions
1:                         out.writeObject(entry);
1:                         if (SanityManager.DEBUG) {
1:                             writeCount++;
1:                     SanityManager.ASSERT(count == writeCount);
/////////////////////////////////////////////////////////////////////////
1:         for (TransactionTableEntry ent : trans.values())
/////////////////////////////////////////////////////////////////////////
1:         for (TransactionTableEntry ent : trans.values())
/////////////////////////////////////////////////////////////////////////
1:         for (TransactionTableEntry ent : trans.values())
/////////////////////////////////////////////////////////////////////////
1:             for (TransactionTableEntry ent : trans.values())
/////////////////////////////////////////////////////////////////////////
1:                     for (TransactionTableEntry ent : trans.values())
/////////////////////////////////////////////////////////////////////////
1:             for (TransactionTableEntry ent : trans.values())
/////////////////////////////////////////////////////////////////////////
1:                     for (TransactionTableEntry ent : trans.values())
/////////////////////////////////////////////////////////////////////////
1:         LogInstant logInstant = null;
1:         for (TransactionTableEntry entry : trans.values()) {
1:             if (entry.isUpdate()) {
1:                 if (logInstant == null ||
1:                         entry.getFirstLog().lessThan(logInstant)) {
1:                     logInstant = entry.getFirstLog();
1:             }
1:         }
1:         return logInstant;
/////////////////////////////////////////////////////////////////////////
1:         for (TransactionTableEntry entry : trans.values()) {
1:             tinfo.add((TransactionTableEntry) entry.clone());
1:         }
1:         return tinfo.toArray(new TransactionTableEntry[tinfo.size()]);
/////////////////////////////////////////////////////////////////////////
1:             boolean hasReadOnlyTransaction = false;
1:             for (TransactionTableEntry entry : trans.values()) {
1:                 if (entry.isUpdate()) {
1:                     str.append(entry);
1:                 } else {
1:                     hasReadOnlyTransaction = true;
1:             }
1:             if (hasReadOnlyTransaction)
1:                 for (TransactionTableEntry entry : trans.values()) {
1:                     if (!entry.isUpdate()) {
1:                         str.append(entry);
1:                 }
commit:c6892a1
/////////////////////////////////////////////////////////////////////////
1: 		and all other relevant information stored in the transaction table
commit:5b43e6f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     private final TransactionMapFactory mapFactory;
/////////////////////////////////////////////////////////////////////////
0:         mapFactory = XactFactory.getMapFactory();
0:         trans = mapFactory.newMap();
/////////////////////////////////////////////////////////////////////////
1:      * <p>
1:      * Entries that are added to or removed from the transaction table while
1:      * it's being traversed, may or may not be visited. All the entries that
1:      * are present in the map when this method is called, and have not been
1:      * removed when the method returns, will have been visited exactly once
1:      * (except if the {@code visit()} method returns false before all entries
1:      * have been visited, in which case the traversal of the map will stop
1:      * earlier).
1:      * </p>
1:      *
1:      * <p>
1:      * Note however that this method does not guarantee that a single
1:      * {@code TransactionTableEntry} is not accessed concurrently by multiple
1:      * threads. If the visitor accesses some of the entry's mutable state, the
1:      * caller must ensure that appropriate synchronization protection is in
1:      * place. For example, if accessing the update state of the entry, the
1:      * caller must synchronize on "this" (the {@code TransactionTable}
1:      * instance).
1:      * </p>
1:      *
0:         mapFactory.visitEntries(trans, visitor);
commit:e21c3de
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayList;
/////////////////////////////////////////////////////////////////////////
0:     To allow thread-safe iteration over the values in the Hashtable, callers
0:     must synchronize on the Hashtable while iterating. The method {@link
0:     #visitEntries(EntryVisitor)} abstracts the synchronization and iteration
0:     so that the callers don't need to synchronize explicitly when they go
0:     through the contents of the table. Methods that are only called during
1:     recovery don't need to take MT considerations, and can safely use iterators
1:     with no additional synchronization.
/////////////////////////////////////////////////////////////////////////
1:          * method once for each entry in the transaction table, or until
1:          * {@code false} is returned by this method.
1:          * @return {@code true} if the scan of the transaction table should
1:          * continue, or {@code false} if the visitor has completed its work
1:          * and no more entries need to be visited
1:         boolean visit(TransactionTableEntry entry);
/////////////////////////////////////////////////////////////////////////
0:                 if (!visitor.visit((TransactionTableEntry) it.next())) {
0:                     // The visitor returned false, meaning that it's done with
0:                     // all of its work and we can stop the scan.
0:                     break;
1:                 }
/////////////////////////////////////////////////////////////////////////
1:     final GlobalXactId global_id)
0:         final ContextManager[] cm = new ContextManager[1];
0:         visitEntries(new EntryVisitor() {
0:             public boolean visit(TransactionTableEntry entry) {
0:                 GlobalTransactionId entry_gid = entry.getGid();
0:                 if (entry_gid != null && entry_gid.equals(global_id)) {
0:                     cm[0] = entry.getXact().getContextManager();
0:                 return cm[0] == null; // continue until context is found
0:         });
1: 
0:         return cm[0];
/////////////////////////////////////////////////////////////////////////
0:             UpdateTransactionCounter counter =
0:                     new UpdateTransactionCounter(true);
0:             visitEntries(counter);
0:             return counter.getCount() > 0;
1:     /**
0:      * Visitor class that counts update transactions. Note that update
0:      * transactions may be added or removed concurrently unless the caller
0:      * synchronizes on "this" (the {@code TransactionTable} instance) while
0:      * applying the visitor.
1:      */
0:     private static class UpdateTransactionCounter implements EntryVisitor
1:     {
0:         private final boolean stopOnFirst;
0:         private int count;
1:         /**
0:          * Create an instance of this visitor.
1:          *
0:          * @param stopOnFirst if {@code true}, stop the scan as soon as we
0:          * have found one update transaction (useful if all we care about is
0:          * whether or not the transaction table contains an update transaction);
0:          * otherwise, scan the entire transaction table
1:          */
0:         UpdateTransactionCounter(boolean stopOnFirst) {
0:             this.stopOnFirst = stopOnFirst;
1:         }
1: 
1:         /**
0:          * Check if the entry represents an update transaction, and update
0:          * the counter accordingly.
1:          */
0:         public boolean visit(TransactionTableEntry entry) {
0:             if (entry.isUpdate()) {
0:                 count++;
1:             }
0:             // Continue the scan if a full scan was requested, or if no update
0:             // transactions have been found yet.
0:             return !stopOnFirst || (count == 0);
1:         }
1: 
1:         /**
0:          * Get the number of update transactions seen by this visitor
0:          * @return number of update transactions
1:          */
0:         int getCount() {
0:             return count;
1:         }
1:     }
/////////////////////////////////////////////////////////////////////////
1: 	public void writeExternal(final ObjectOutput out) throws IOException
1:         // We don't care if transactions are added or removed from the table
1:         // while we're writing it out, as long as the number of update
1:         // transactions is constant. Synchronizing on "this" prevents other
1:         // threads from adding or removing update transactions.
1:         {
0:             UpdateTransactionCounter counter =
0:                     new UpdateTransactionCounter(false);
0:             visitEntries(counter);
0:             int count = counter.getCount();
1:             CompressedNumber.writeInt(out, count);
1:             // now write them out
1:             if (count > 0)
1:             {
1:                 // Count the number of writes in debug builds.
0:                 final int[] writeCount =
0:                         SanityManager.DEBUG ? new int[1] : null;
1: 
0:                 final IOException[] thrownException = new IOException[1];
1: 
0:                 visitEntries(new EntryVisitor() {
0:                     public boolean visit(TransactionTableEntry entry) {
0:                         try {
0:                             if (entry.isUpdate()) {
0:                                 // only write out update transactions
0:                                 out.writeObject(entry);
1:                                 if (SanityManager.DEBUG) {
0:                                     writeCount[0]++;
1:                                 }
1:                             }
0:                         } catch (IOException ioe) {
0:                             thrownException[0] = ioe;
0:                             return false; // stop on error
1:                         }
0:                         return true; // go through entire table
1:                     }
0:                 });
1: 
0:                 if (thrownException[0] != null) {
0:                     throw thrownException[0];
1:                 }
1: 
1:                 // Verify that we wrote the expected number of transactions.
1:                 if (SanityManager.DEBUG) {
0:                     SanityManager.ASSERT(count == writeCount[0]);
1:                 }
/////////////////////////////////////////////////////////////////////////
0:             final LogInstant[] logInstant = new LogInstant[1];
0:             visitEntries(new EntryVisitor() {
0:                 public boolean visit(TransactionTableEntry entry) {
0:                     if (entry.isUpdate()) {
0:                         if ((logInstant[0] == null) ||
0:                                 entry.getFirstLog().lessThan(logInstant[0])) {
0:                             logInstant[0] = entry.getFirstLog();
0:                     return true; // scan entire transaction table
0:             });
0:             return logInstant[0];
/////////////////////////////////////////////////////////////////////////
1:         if (SanityManager.DEBUG) {
1:             SanityManager.DEBUG("TranTrace", toString());
1:         }
0:         final ArrayList tinfo = new ArrayList();
1:         // Get clones of all the entries in the transaction table.
0:         visitEntries(new EntryVisitor() {
0:             public boolean visit(TransactionTableEntry entry) {
0:                 tinfo.add(entry.clone());
0:                 return true; // scan entire transaction table
1:             }
0:         });
0:         return (TransactionTableEntry[])
0:                 tinfo.toArray(new TransactionTableEntry[tinfo.size()]);
1: 			final StringBuffer str = new StringBuffer(1000).
0:             final boolean[] hasReadOnlyTransaction = new boolean[1];
0:             visitEntries(new EntryVisitor() {
0:                 public boolean visit(TransactionTableEntry entry) {
0:                     if (entry.isUpdate()) {
0:                         str.append(entry.toString());
1:                     } else {
0:                         hasReadOnlyTransaction[0] = true;
1:                     }
0:                     return true; // scan the entire transaction table
1:                 }
0:             });
0:             if (hasReadOnlyTransaction[0])
0:                 visitEntries(new EntryVisitor() {
0:                     public boolean visit(TransactionTableEntry entry) {
0:                         if (!entry.isUpdate()) {
0:                             str.append(entry.toString());
1:                         }
0:                         return true; // scan the entire transaction table
1:                     }
0:                 });
commit:3c48dd9
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Interface for visiting entries in the transaction table.
1:      * @see #visitEntries(EntryVisitor)
1:      */
1:     static interface EntryVisitor {
1:         /**
1:          * Visit an entry. {@link #visitEntries(EntryVisitor)} will call this
0:          * method once for each entry in the transaction table.
1:          *
1:          * @param entry the {@code TransactionTableEntry} being visited
1:          */
0:         void visit(TransactionTableEntry entry);
1:     }
1:     /**
1:      * <p>
1:      * Visit all the entries in the transaction table.
1:      * </p>
1:      *
1:      * <p>
1:      * MT - MT safe
1:      * </p>
1:      *
1:      * @param visitor the visitor to apply on each transaction table entry
1:      */
1:     void visitEntries(EntryVisitor visitor) {
0:         synchronized (trans) {
0:             for (Iterator it = trans.values().iterator(); it.hasNext(); ) {
0:                 visitor.visit((TransactionTableEntry) it.next());
1:             }
1:         }
1:     }
/////////////////////////////////////////////////////////////////////////
commit:6e66e70
/////////////////////////////////////////////////////////////////////////
0: 				if (count > 0)
0: 					for (Iterator it = trans.values().iterator(); it.hasNext();)
1: 						TransactionTableEntry ent =
0: 								(TransactionTableEntry) it.next();
0: 						if (ent != null && ent.isUpdate())
1: 						{
0: 							// only write out update transactions
0: 							out.writeObject(ent);
1: 						}
commit:0fc1787
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import java.util.Iterator;
0: import java.util.Map;
1: 
/////////////////////////////////////////////////////////////////////////
0: 	private final Map trans;
/////////////////////////////////////////////////////////////////////////
0: 	public Map getTableForXA()
/////////////////////////////////////////////////////////////////////////
0:             for (Iterator it = trans.values().iterator(); it.hasNext(); )
0:                 TransactionTableEntry entry = (TransactionTableEntry) it.next();
/////////////////////////////////////////////////////////////////////////
0: 			for (Iterator it = trans.values().iterator(); it.hasNext(); )
0: 				TransactionTableEntry ent = (TransactionTableEntry) it.next();
/////////////////////////////////////////////////////////////////////////
0: 				for (Iterator it = trans.values().iterator(); it.hasNext(); )
0: 					TransactionTableEntry ent =
0: 							(TransactionTableEntry) it.next();
/////////////////////////////////////////////////////////////////////////
0: 				for (Iterator it = trans.values().iterator(); it.hasNext(); )
0: 					TransactionTableEntry ent =
0: 							(TransactionTableEntry) it.next();
0: 					if (ent != null && ent.isUpdate())
0: 						// only writes out update transaction
0: 						out.writeObject(ent);
/////////////////////////////////////////////////////////////////////////
0: 		for (Iterator it = trans.values().iterator(); it.hasNext(); )
0: 			TransactionTableEntry ent = (TransactionTableEntry) it.next();
/////////////////////////////////////////////////////////////////////////
0:         for (Iterator it = trans.values().iterator(); it.hasNext(); )
0:             TransactionTableEntry ent = (TransactionTableEntry) it.next();
/////////////////////////////////////////////////////////////////////////
0: 		for (Iterator it = trans.values().iterator(); it.hasNext(); )
0: 			TransactionTableEntry ent = (TransactionTableEntry) it.next();
/////////////////////////////////////////////////////////////////////////
0: 			for (Iterator it = trans.values().iterator(); it.hasNext() ; )
0: 				TransactionTableEntry ent = (TransactionTableEntry) it.next();
/////////////////////////////////////////////////////////////////////////
0:                     for (Iterator it = trans.values().iterator(); it.hasNext();)
0:                             (TransactionTableEntry) it.next();
/////////////////////////////////////////////////////////////////////////
0: 			for (Iterator it = trans.values().iterator(); it.hasNext(); )
0: 				ent = (TransactionTableEntry) it.next();
/////////////////////////////////////////////////////////////////////////
0:                     for (Iterator it = trans.values().iterator(); it.hasNext();)
0:                         ent = (TransactionTableEntry) it.next();
/////////////////////////////////////////////////////////////////////////
0:                 for (Iterator it = trans.values().iterator(); it.hasNext(); )
0:                         (TransactionTableEntry) it.next();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 			if (SanityManager.DEBUG)
0: 				SanityManager.DEBUG("TranTrace", toString());
1: 
0: 			for (Iterator it = trans.values().iterator(); it.hasNext(); )
0: 				TransactionTableEntry ent = (TransactionTableEntry) it.next();
/////////////////////////////////////////////////////////////////////////
0: 			for (Iterator it = trans.values().iterator(); it.hasNext(); )
0: 				TransactionTableEntry ent = (TransactionTableEntry) it.next();
/////////////////////////////////////////////////////////////////////////
0: 				for (Iterator it = trans.values().iterator(); it.hasNext(); )
0: 						(TransactionTableEntry) it.next();
commit:9b450ec
/////////////////////////////////////////////////////////////////////////
1:         TransactionTableEntry newEntry = new TransactionTableEntry(
1:                 xact, id, 0, exclude ? TransactionTableEntry.EXCLUDE : 0);
1: 
1:             Object oldEntry = trans.put(id, newEntry);
1:             if (SanityManager.DEBUG)
1:             {
1:                 SanityManager.ASSERT(
1:                         oldEntry == null,
1:                         "Trying to add a transaction that's already " +
1:                         "in the transaction table");
1:                 if (SanityManager.DEBUG_ON("TranTrace"))
1:                     SanityManager.DEBUG(
1:                         "TranTrace", "adding transaction " + id);
1:                     SanityManager.showTrace(new Throwable("TranTrace"));
1:             }
commit:db756bb
/////////////////////////////////////////////////////////////////////////
0:         // Synchronize on trans to prevent problems that could occur if
0:         // elements are added to or removed from the Hashtable while we're
0:         // looping through the elements. Possible problems include:
0:         //   - ArrayIndexOutOfBoundsException if a transaction is added after
0:         //     the call to trans.size()
0:         //   - Assert failure, tx table has null entry (DERBY-3757)
0:         //   - NoSuchElementException (DERBY-3916)
0:         synchronized (trans)
commit:ee9c803
/////////////////////////////////////////////////////////////////////////
1: 	/**
author:Suresh Thalamati
-------------------------------------------------------------------------------
commit:32635d2
/////////////////////////////////////////////////////////////////////////
1:        Is there a prepared transaction that are recovered 
1:        durring the recovery in the transaction table.
1:        <P>MT - unsafe, caller is recovery, which is single threaded.
1:     */
1:     public boolean hasPreparedRecoveredXact()
1:     {
1:         return hasPreparedXact(true);
1:     }
1: 
1:     /**
1:        Is there a prepared transaction in the transaction table.
1:        <P>MT - unsafe, called during boot, which is single threaded.
1:     */
1:     public boolean hasPreparedXact()
1:     {
1:         return hasPreparedXact(false);
1:     }
1: 
1:     /**
1:      * Is there a prepared transaction in the transaction table.
1:      * 
1:      * <P>MT - unsafe, caller is recovery/at boot, which is single threaded.
1:      *
1:      * @param recovered  <code> true </code> to search  for transaction 
1:      *                  that are in prepared during recovery.  
1:      *                  recovered tranaction. 
0:      *                  <code> false > to search for just prepared 
1:      *                  transactons. 
1:      * @return         <code> true if there is a prepared transaction and
1:      *                  recovered when <code> recovered </code> argument is 
1:      *                  <code> true </code>
1:      */
1: 
1:     private boolean hasPreparedXact(boolean recovered)
1:     {
0:         for (Enumeration e = trans.elements(); e.hasMoreElements(); )
1:         {
0:             TransactionTableEntry ent = (TransactionTableEntry) e.nextElement();
1: 
1:             if (ent != null && 
1:                 (ent.getTransactionStatus() & Xact.END_PREPARED) != 0)
1:                 if (recovered) {
1:                     if(ent.isRecovery())
1:                         return true;
0:                 } else {
1:                     return true;
1:                 }
1:         }
1:         return false;
1:     }
1: 
1: 
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:62721e6
/////////////////////////////////////////////////////////////////////////
1:      * This routine use to be only called during offline recovery so performance
1:      * was not critical.  Since that time more calls have been made, including
1:      * one in startGlobalTransaction() so a linear search may no longer
1:      * be appropriate.  See DERBY-828.
/////////////////////////////////////////////////////////////////////////
0:                 if (entry != null)
0:                     GlobalTransactionId entry_gid = entry.getGid();
1: 
0:                     if (entry_gid != null && entry_gid.equals(global_id))
1:                     {
0:                         cm = entry.getXact().getContextManager();
0:                         break;
1:                     }
commit:7a4afea
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		Return the largest update transactionId I have seen so far.
/////////////////////////////////////////////////////////////////////////
1: 		Is there an active internal transaction in the transaction table.
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.store.raw.xact.TransactionTable
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:1f9b9c4
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.raw.xact
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.store.raw.xact;
1: 
1: import org.apache.derby.iapi.services.context.ContextManager;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.services.io.Formatable;
0: import org.apache.derby.iapi.services.io.FormatIdUtil;
1: import org.apache.derby.iapi.services.io.StoredFormatIds;
1: 
1: import org.apache.derby.iapi.store.access.TransactionInfo;
1: 
1: import org.apache.derby.iapi.store.raw.GlobalTransactionId;
1: 
1: import org.apache.derby.iapi.store.raw.log.LogInstant;
1: 
1: import org.apache.derby.iapi.store.raw.xact.RawTransaction;
1: import org.apache.derby.iapi.store.raw.xact.TransactionId;
1: 
0: import org.apache.derby.iapi.error.StandardException;
1: 
1: import org.apache.derby.iapi.services.io.CompressedNumber;
1: 
0: import java.util.Hashtable;
0: import java.util.Enumeration;
1: import java.io.ObjectOutput;
1: import java.io.ObjectInput;
1: import java.io.IOException;
1: 
1: /**
1: 	The transaction table is used by the transaction factory to keep track of
1: 	all transactions that are in the system.
1: 
1: 	<BR> The transction table serves the following purposes: <OL> 
1: 
1: 	<LI> checkpoint - when a checkpoint log record is written out, it writes
1: 	out also all transactions that have updated the database.  RESOLVE: this is
1: 	actually not used right now - rather, the transaction table is
1: 	reconstructed during the redo phase by traversing from the undo LWM.  It is
1: 	a goal to use this transaction table (and traversing from the redoLWM)
1: 	instead of rebuilding it to speed up recovery.
1: 
1: 	<LI> Quiesce State - when a  system enters the quiesce state, it needs to account
1: 	for all transactions in the system, even those which are just started and
1: 	are in their IDLE state.
1: 
1: 	<LI> TransactionTable VTI - we need to get a snapshot of all transactions
1: 	in the system for diagnostic purposes.
1: 	</OL>
1: 
1: 	In order to speed up the time it takes to look up a transaction from the
1: 	transaction table, each transaction must have a unique transaction Id.
1: 	This means newly coined transaction must also have a transaction Id.
1: 
1: 	<P>During recovery, there is only one real xact object doing all the
1: 	recovery work, but there could be many outstanding transactions that are
1: 	gleamed from the log.  Each of these "recovery transactions" have its on
1: 	entry into the transaction table but they all share the same Xact object.
1: 
1: 	<P>Multithreading considerations:<BR>
1: 	TransactionTable must be MT-safe it is called upon by many threads
1: 	simultaneously (except during recovery)
1: 
0: 	<P><B> This class depends on Hashtable synchronization!! </B>
1: 
1: */
1: 
1: public class TransactionTable implements Formatable
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 	/*
1: 	 * Fields
1: 	 */
1: 
0: 	private Hashtable trans;
1: 
1: 	private TransactionId largestUpdateXactId;
1: 
1: 	/**
1: 		MT - not needed for constructor
1: 	*/
1: 	public TransactionTable()
1: 	{
0: 		trans = new Hashtable(17);
1: 	}
1: 
1: 	/*************************************************************
1: 	 * generic methods called by all clients of transaction table
1: 	 * Must be MT -safe
1: 	 ************************************************************/
1: 	private TransactionTableEntry findTransactionEntry(TransactionId id)
1: 	{
1: 
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT(
1:                 id != null, "findTransacionEntry with null id");
1: 
1: 		// Hashtable is synchronized
0: 		return (TransactionTableEntry)trans.get(id);
1: 	}
1: 
1: 
1: 
1: 
1: 	void add(Xact xact, boolean exclude)
1: 	{
1: 		TransactionId id = xact.getId();
1: 
1: 		synchronized(this)
1: 		{
1: 			TransactionTableEntry ent = findTransactionEntry(id);
1: 
0: 			if (ent == null)
1: 			{
0: 				ent = new TransactionTableEntry
0: 					(xact, id, 0, 
0: 					 exclude ? TransactionTableEntry.EXCLUDE : 0);
1: 
0: 				trans.put(id, ent);
1: 
1: 				if (SanityManager.DEBUG)
1:                 {
1:                     if (SanityManager.DEBUG_ON("TranTrace"))
1:                     {
1:                         SanityManager.DEBUG(
0:                             "TranTrace", "adding transaction " + id);
1:                         SanityManager.showTrace(new Throwable("TranTrace"));
1:                     }
1:                 }
1: 			}
1: 
1: 			if (SanityManager.DEBUG)
1: 			{
0: 				if (exclude != ent.needExclusion())
1: 					SanityManager.THROWASSERT(
0: 					  "adding the same transaction with different exclusion: " +
0: 					  exclude + " " + ent.needExclusion());
1: 			}
1: 		}
1: 
0: 		if (SanityManager.DEBUG) {
1: 
1: 			if (SanityManager.DEBUG_ON("memoryLeakTrace")) {
1: 
1: 				if (trans.size() > 50)
1: 					System.out.println("memoryLeakTrace:TransactionTable " + trans.size());
1: 			}
1: 		}
1: 	}
1: 
1: 	/*
1: 		remove the transaction Id an return false iff the transaction is found
1: 		in the table and it doesn't need exclusion during quiesce state
1: 	 */
1: 	boolean remove(TransactionId id)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT(
1:                 id != null, 
1:                 "cannot remove transaction from table with null id");
1: 
1: 		if (SanityManager.DEBUG)
1:         {
1:             if (SanityManager.DEBUG_ON("TranTrace"))
1:             {
1:                 SanityManager.DEBUG(
1:                     "TranTrace", "removing transaction " + id);
1:                 SanityManager.showTrace(new Throwable("TranTrace"));
1:             }
1:         }
1: 
1: 		// Hashtable is synchronized
0: 		 TransactionTableEntry ent = (TransactionTableEntry)trans.remove(id);
1: 		 return (ent == null || ent.needExclusion());
1: 	}
1: 
1: 
1: 	/**
1: 		Change a transaction to update or add an update transaction to this table.
1: 
1: 		@param tid the transaction id
1: 		@param tran the transaction to be added
1: 		@param transactionStatus the transaction status that is stored in the
1: 				BeginXact log record
1: 	 */
1: 	public void addUpdateTransaction(TransactionId tid, RawTransaction tran,
1: 									 int transactionStatus)
1: 	{
1: 
1: 		// we need to synchronize on the transaction table because we have to
1: 		// prevent this state change from happening when the transaction table
1: 		// itself is written out to the checkpoint.  This is the only
1: 		// protection the TransactionTableEntry has to prevent fields in myxact
1: 		// from changing underneath it while it is being written out.
1: 		synchronized(this)
1: 		{
1: 			TransactionTableEntry ent = findTransactionEntry(tid);
1: 
1: 			if (ent != null)
1: 			{
1: 				// this happens during run time, when a transaction that is
1: 				// already started changed status to an update transaction
1: 
1: 				ent.updateTransactionStatus((Xact)tran, transactionStatus,
1: 											TransactionTableEntry.UPDATE) ;
1: 			}
1: 			else
1: 			{
1: 				// this happens during recovery, that's why we haven't seen
1: 				// this transaction before - it is added in the doMe of the 
1: 				// BeginXact log record.
1: 				//
1: 				// No matter what this transaction is, it won't need to be run
1: 				// in quiesce state because we are in recovery.
1: 				ent = new TransactionTableEntry((Xact)tran, tid, transactionStatus, 
1: 												TransactionTableEntry.UPDATE | 
1: 												TransactionTableEntry.EXCLUDE |
1: 												TransactionTableEntry.RECOVERY);
1: 				trans.put(tid, ent);
1: 
1: 			}
1: 
1: 			if (XactId.compare(ent.getXid(), largestUpdateXactId) > 0)
1: 				largestUpdateXactId = ent.getXid();
1: 		}
1: 	}
1: 
1: 	/**
1: 	    Change update transaction to non-update
1: 
1: 		<P>MT - MT safe, since vector is MT-safe.
1: 
1: 		@param id the transaction Id
1: 	  */
1: 	void removeUpdateTransaction(TransactionId id)
1: 	{
1: 		// we need to synchronize on the transaction table because we have to
1: 		// prevent this state change from happening when the transaction table
1: 		// itself is written out to the checkpoint.  This is the only
1: 		// protection the TransactionTableEntry has to prevent fields in myxact
1: 		// from changing underneath it while it is being written out.
1: 
1: 		synchronized (this)
1: 		{
1: 			TransactionTableEntry ent = findTransactionEntry(id);
1: 
1: 			if (SanityManager.DEBUG)
1: 			{
1: 				SanityManager.ASSERT(ent != null, 
1: 				 "removing update transaction that is not there");
1: 			}
1: 
1: 			ent.removeUpdateTransaction();
1: 
1: 			// If we are committing a recovery transaction, remove it from the
1: 			// transaction table.  The xact object which is doing the work is
1: 			// not going to be closed even though the transaction is done.
1: 			if (ent.isRecovery())
1: 				remove(id);
1: 		}
1: 
1: 		return;
1: 	}
1: 
1:     /**************************************************************************
1:      * Transaction table methods used by XA.
1:      **************************************************************************
1:      */
1: 
1:     /**
0:      * Return the hash table to the XA layer.
1:      * <p>
0:      * The XA code will do linear read-only operations on the hash table,
0:      * write operations are only done in this module.  It is a little ugly
0:      * to export the hash table, but I wanted to move the XA specific code
0:      * into the XA module, so that we could configure out the XA code if
0:      * necessary.
1:      * <p>
1:      *
0: 	 * Must be MT -safe, depends on sync hash table, and must get 
0:      *     synchronized(hash_table) for linear searches.
1:      *
1: 	 * @return The ContextManager of the transaction being searched for.
1:      *
1:      * @param global_id The global transaction we are searching for.
1:      **/
0: 	public Hashtable getTableForXA()
1: 	{
0:         return(trans);
1: 	}
1: 
1: 	/**
1: 	    Change transaction to prepared.
1: 
1: 		<P>MT - unsafe, caller is recovery, which is single threaded.
1: 
1: 		@param id the transaction Id
1: 	  */
1: 	void prepareTransaction(TransactionId id)
1: 	{
1: 		// we need to synchronize on the transaction table because we have to
1: 		// prevent this state change from happening when the transaction table
1: 		// itself is written out to the checkpoint.  This is the only
1: 		// protection the TransactionTableEntry has to prevent fields in myxact
1: 		// from changing underneath it while it is being written out.
1: 
1:         TransactionTableEntry ent = findTransactionEntry(id);
1: 
1:         if (SanityManager.DEBUG)
1:         {
1:             SanityManager.ASSERT(
1:                 ent != null, "preparing transaction that is not there");
1:         }
1: 
1:         ent.prepareTransaction();
1: 
1: 		return;
1: 	}
1: 
1:     /**
1:      * Find a transaction in the table by Global transaction id.
1:      * <p>
0:      * Only called by XactXAResourceManager.find() during offline recovery
0:      * of in-doubt transactions, we do not expect this to be called often 
0:      * so performance is not critical.  Just to linear search of id's. 
1:      * <p>
1:      *
1: 	 * @return The ContextManager of the transaction being searched for.
1:      *
1:      * @param global_id The global transaction we are searching for.
1:      **/
1: 	public ContextManager findTransactionContextByGlobalId(
0:     GlobalXactId global_id)
1: 	{
0:         ContextManager cm              = null;
1: 
0:         // Need to hold sync while linear searching the hash table.
0:         synchronized (trans)
1:         {
0:             for (Enumeration e = trans.elements(); e.hasMoreElements();) 
1:             {
0:                 TransactionTableEntry entry = 
0:                     (TransactionTableEntry) e.nextElement();
1: 
0:                 if (entry.getGid() != null && 
0: 					entry.getGid().equals(global_id))
1:                 {
0:                     cm = entry.getXact().getContextManager();
0:                     break;
1:                 }
1:             }
1:         }
1:               
0: 		return(cm);
1: 	}
1: 
1: 
1: 	/***********************************************************
1: 	 * called when system is being quiesced, must be MT - safe
1: 	 ***********************************************************/
1: 	/**
1: 		Return true if there is no transaction actively updating the database.
1: 		New transaction may be started or old transaction committed
1: 		right afterward, the caller of this routine must have other ways to
1: 		stop transactions from starting or ending.
1: 
1: 		<P>MT - safe
1: 	*/
1: 	boolean hasActiveUpdateTransaction()
1: 	{
1: 		synchronized (this)
1: 		{
0: 			for (Enumeration e = trans.elements(); e.hasMoreElements(); )
1: 			{
0: 				TransactionTableEntry ent = (TransactionTableEntry)e.nextElement();
0: 				if (ent != null && ent.isUpdate())
1: 					return true;
1: 			}
1: 		}
1: 		return false;
1: 	}
1: 
1: 
1: 
1: 	/************************************************************
1: 	 * methods called only by checkpoint
1: 	 ***********************************************************/
1: 	/*
1: 	 * Formatable methods
1: 	 */
1: 
1: 	/**
1: 		Return my format identifier.
1: 	*/
1: 	public int getTypeFormatId() {
1: 		return StoredFormatIds.RAW_STORE_TRANSACTION_TABLE;
1: 	}
1: 
1: 	/**
1: 	  @exception IOException problem reading the transaction table
1: 	*/
0: 	public void writeExternal(ObjectOutput out) throws IOException 
1: 	{
1: 		//don't let the transactions status change while writing out(beetle:5533)
0: 		//Note: syncing both on trans and this variable could be avoided if
0: 		//all the routines in this class are sycned on "this" and does not
0: 		//depend on hash table synchronization. But that will be overkill 
0: 		//because this routine gets called only on checkpoints and others
0: 		//are used more often.
1: 
1: 		synchronized(this)
1: 		{	
0: 			// don't touch the transaction table when I am being written out
0: 			synchronized(trans)
1: 			{
0: 				int count = 0;
0: 				int maxcount = trans.size();
1: 
0: 				// first count up the number of active update transactions 
0: 				for (Enumeration e = trans.elements();
0: 					 e.hasMoreElements(); )
1: 				{
0: 					TransactionTableEntry ent = (TransactionTableEntry)e.nextElement();
0: 					if (ent != null && ent.isUpdate())
0: 						count++;
1: 				}
1: 
0: 				CompressedNumber.writeInt(out, count);
1: 
0: 				// now write them out
0: 				if (count > 0)
1: 				{
0: 					for (Enumeration e = trans.elements();
0: 						 e.hasMoreElements() ; )
1: 					{
0: 						TransactionTableEntry ent = (TransactionTableEntry)e.nextElement();
0: 						if (ent != null && ent.isUpdate())
1: 						{
0: 							// only writes out update transaction
0: 							out.writeObject(ent);
1: 						}
1: 					}
1: 				}
1: 			}
1: 		}
1: 	}
1: 
1: 	/************************************************************
1: 	 * methods called only by recovery
1: 	 ************************************************************/
1: 
1: 
1: 	/**
1: 	  @exception IOException problem reading the transaction table
1: 	  @exception ClassNotFoundException problem reading the transaction table
1: 	 */
1: 	public void readExternal(ObjectInput in) 
1: 		 throws IOException, ClassNotFoundException
1: 	{
1: 		// RESOLVE: this is only read in checkpoint record, but we have not
1: 		// finish the work on using this transaction table to cut down on redo
1: 		// so this transaction table is effectively and futilely thrown away!
1: 
1: 		int count = CompressedNumber.readInt(in);
1: 		if (count == 0)
1: 			return;
1: 
1: 		for (int i = 0; i < count; i++)
1: 		{
0: 			TransactionTableEntry ent = 
1: 				(TransactionTableEntry)in.readObject();
1: 
1: 			if (SanityManager.DEBUG)
1: 				SanityManager.ASSERT(
1:                     ent.getXid() != null,
1:                     "read in transaction table entry with null id");
1: 
1: 			trans.put(ent.getXid(), ent);
1: 
1: 			if (ent.isUpdate() && 
1:                 XactId.compare(ent.getXid(), largestUpdateXactId) > 0)
1:             {
1: 				largestUpdateXactId = ent.getXid();
1:             }
1: 		}
1: 
1: 
1: 	}
1: 
1: 	/**
0: 		Return the largest update transactionId I have seen so far
1: 
1: 		<P>MT - unsafe, caller is recovery, which is single threaded.
1: 	*/
1: 	public TransactionId largestUpdateXactId()
1: 	{
1: 		return largestUpdateXactId;
1: 	}
1: 
1: 
1: 	/**
0: 		Is there an active internal transaction in the transaction table
1: 
1: 		<P>MT - unsafe, caller is recovery, which is single threaded.
1: 	*/
1: 	public boolean hasRollbackFirstTransaction()
1: 	{
0: 		for (Enumeration e = trans.elements();
0: 			 e.hasMoreElements() ; )
1: 		{
0: 			TransactionTableEntry ent = (TransactionTableEntry)e.nextElement();
1: 
1: 			if (ent != null && ent.isRecovery() && 
1: 				(ent.getTransactionStatus() & 
1:                      Xact.RECOVERY_ROLLBACK_FIRST) != 0)
1:             {
1: 				return true;
1:             }
1: 		}
1: 		return false;
1: 	}
1: 
1: 	/**
0: 		Is there a prepared transaction in the transaction table.
1: 
1: 		<P>MT - unsafe, caller is recovery, which is single threaded.
1: 	*/
0: 	public boolean hasPreparedRecoveredXact()
1: 	{
0: 		for (Enumeration e = trans.elements(); e.hasMoreElements(); )
1: 		{
0: 			TransactionTableEntry ent = (TransactionTableEntry) e.nextElement();
1: 
1: 			if (ent != null && ent.isRecovery() && 
0: 				(ent.getTransactionStatus() & Xact.END_PREPARED) != 0)
1:             {
1: 				return true;
1:             }
1: 		}
1: 		return false;
1: 	}
1: 
1: 
1: 	/**
1: 		Get the most recently added transaction that says it needs to be
1: 		rolled back first (an InternalXact) from the transaction table and make
1: 		the passed in transaction assume its identity. 
1: 		<B> Should only be used in recovery undo !! </B>
1: 		RESOLVE: (sku)I don't think even these internal transactions need to be
1: 		rolled back in the reverse order, because they are physical in nature.
1: 		But it won't hurt.
1: 
1: 		<P>MT - unsafe, caller is recovery, which is single threaded.
1: 	*/
1: 	public boolean getMostRecentRollbackFirstTransaction(RawTransaction tran)
1: 	{
1: 
1: 		if (trans.isEmpty())
1: 		{
1: 			// set tranaction to idle
1: 			return findAndAssumeTransaction((TransactionId)null, tran);
1: 		}
1: 
1: 		TransactionId id = null;
0: 		for (Enumeration e = trans.elements();
0: 			 e.hasMoreElements() ; )
1: 		{
0: 			TransactionTableEntry ent = (TransactionTableEntry)e.nextElement();
1: 
1: 			if (ent != null && ent.isUpdate() && ent.isRecovery() &&
1: 				(ent.getTransactionStatus() & Xact.RECOVERY_ROLLBACK_FIRST) != 0)
1: 			{
1: 				// try to locate the most recent one
1: 				if (id == null || XactId.compare(id, ent.getXid()) < 0)
1: 					id = ent.getXid();
1: 			}
1: 		}
1: 
1: 		if (id == null)			// set transaction to idle
1: 		{
1: 			return findAndAssumeTransaction(id, tran);
1: 		}
1: 		else
1: 		{
1: 			// there is a rollback first transaction
1: 			boolean found = 
1:                 findAndAssumeTransaction(id, tran);
1: 
1: 			if (SanityManager.DEBUG)
1:             {
1:                 if (!found)
1:                 {
1:                     SanityManager.THROWASSERT(
1:                         "cannot find transaction " + id + " in table");
1:                 }
1:             }
1: 
1: 			return true;
1: 		}
1: 	}
1: 
1: 	/**
1: 		Get the most recently non-prepared added transaction from the 
1:         transaction table and make the passed in transaction assume its 
1:         identity.  Prepared transactions will not be undone.
1: 
1: 		RESOLVE: (sku) I don't think normal user transactions needs to be
1: 		rolled back in order, but it won't hurt.
1: 
1: 		<B> Should only be used in recovery undo !! </B>
1: 
1: 		<P>MT - unsafe, caller is recovery, which is single threaded.
1: 	*/
1: 	public boolean getMostRecentTransactionForRollback(RawTransaction tran)
1: 	{
1:         TransactionId id = null;
1: 
1:         if (!trans.isEmpty())
1: 		{
0: 			for (Enumeration e = trans.elements();
0: 				 e.hasMoreElements() ; )
1: 			{
0: 				TransactionTableEntry ent =
0: 					 (TransactionTableEntry)e.nextElement();
1: 
1: 				if (ent != null         && 
1:                     ent.isUpdate()      && 
1:                     ent.isRecovery()    && 
1:                     !ent.isPrepared())
1: 				{
1: 					// try to locate the most recent one
1: 					if (id == null || XactId.compare(id, ent.getXid()) < 0)
1: 						id = ent.getXid();
1: 				}
1: 
1: 				if (SanityManager.DEBUG)
1: 				{
1: 					if (ent != null         && 
1:                         ent.isUpdate()      && 
1:                         ent.isRecovery()    &&
1: 						(ent.getTransactionStatus() & 
1:                          Xact.RECOVERY_ROLLBACK_FIRST) != 0)
1:                     {
1: 						SanityManager.THROWASSERT(
1:                             "still rollback first xacts in the tran table!");
1:                     }
1: 				}
1: 			}
1: 
1: 			if (SanityManager.DEBUG)
1:             {
1:                 // if all transactions are prepared then it is possible that
1:                 // no transaction will be found, in that case id will be null.
1:                 if (id != null)
1:                 {
1:                     SanityManager.ASSERT(findTransactionEntry(id) != null);
1:                 }
1:                 else
1:                 {
1:                     // all transactions in the table must be prepared.
0:                     for (Enumeration e = trans.elements(); e.hasMoreElements();)
1:                     {
0:                         TransactionTableEntry ent =
0:                             (TransactionTableEntry)e.nextElement();
1:                         SanityManager.ASSERT(ent.isPrepared());
1:                     }
1:                 }
1:             }
1: 		}
1: 
1:         return(findAndAssumeTransaction(id, tran));
1: 	}	
1: 
1: 	/**
1: 		Get the most recently added transaction that says it is prepared during
1:         recovery the transaction table and make the passed in transaction 
1:         assume its identity. This routine turns off the isRecovery() state
1: 		<B> Should only be used in recovery handle prepare after undo !! </B>
1: 
1: 		<P>MT - unsafe, caller is recovery, which is single threaded.
1: 	*/
1: 
1:     /**
1:      * Get the most recent recovered prepared transaction.
1:      * <p>
1:      * Get the most recently added transaction that says it is prepared during 
1:      * recovery the transaction table and make the passed in transaction 
1:      * assume its identity. 
1:      * <p>
1:      * This routine, unlike the redo and rollback getMostRecent*() routines
1:      * expects a brand new transaction to be passed in.  If a candidate 
1:      * transaction is found, then upon return the transaction table will 
1:      * be altered such that the old entry no longer exists, and a new entry
1:      * will exist pointing to the transaction passed in.  The new entry will
1:      * look the same as if the prepared transaction had been created during
1:      * runtime rather than recovery.
1:      *
1:      * <B> Should only be used in recovery handle prepare after undo !! </B>
1:      *
1:      * <P>MT - unsafe, caller is recovery, which is single threaded.
1:      *
1: 	 * @return true if a candidate transaction has been found.  false if no
1:      *         prepared/recovery transactions found in the table.
1:      *
1:      * @param tran   Newly allocated transaction to add to link to a entry.
1:      *
1:      **/
1: 	public boolean getMostRecentPreparedRecoveredXact(
1:     RawTransaction tran)
1: 	{
1:         TransactionTableEntry   found_ent   = null;
1: 
1:         if (!trans.isEmpty())
1: 		{
1:             TransactionId           id          = null;
1:             GlobalTransactionId     gid         = null;
0:             TransactionTableEntry   ent;
1: 
0: 			for (Enumeration e = trans.elements(); e.hasMoreElements(); )
1: 			{
0: 				ent = (TransactionTableEntry)e.nextElement();
1: 
1: 				if (ent != null         && 
1:                     ent.isRecovery()    && 
1:                     ent.isPrepared())
1: 				{
1: 					// try to locate the most recent one
1: 					if (id == null || XactId.compare(id, ent.getXid()) < 0)
1:                     {
1:                         found_ent = ent;
1: 						id        = ent.getXid();
1: 						gid       = ent.getGid();
1:                     }
1: 				}
1: 			}
1: 
1:             if (SanityManager.DEBUG)
1:             {
1:                 if (found_ent == null)
1:                 {
1:                     // if no entry's were found then the transaction table
1:                     // should have the passed in idle tran, and the rest should
1:                     // be non-recover, prepared global transactions.
0:                     for (Enumeration e = trans.elements(); e.hasMoreElements();)
1:                     {
0:                         ent = (TransactionTableEntry)e.nextElement();
1: 
1:                         if (XactId.compare(ent.getXid(), tran.getId()) != 0)
1:                         {
1:                             SanityManager.ASSERT(
1:                                 !ent.isRecovery() && ent.isPrepared());
1:                             SanityManager.ASSERT(ent.getGid() != null);
1:                         }
1:                     }
1:                 }
1:             }
1: 
1:             if (found_ent != null)
1:             {
1:                 // At this point there are 2 tt entries of interest:
1:                 //     new_ent - the read only transaction entry that was 
1:                 //               created when we allocated a new transaction.
1:                 //               We will just throw this one away after 
1:                 //               assuming the identity of the global xact.
1:                 //     found_ent
1:                 //             - the entry of the transaction that we are going
1:                 //               to take over.
1:                 TransactionTableEntry new_ent =
0:                     (TransactionTableEntry) trans.remove(tran.getId());
1: 
1:                 // At this point only the found_ent should be in the table.
1:                 if (SanityManager.DEBUG)
1:                 {
1: 	                SanityManager.ASSERT(findTransactionEntry(id) == found_ent);
1:                 }
1: 
1:                 ((Xact) tran).assumeGlobalXactIdentity(found_ent);
1: 
1:                 // transform this recovery entry, into a runtime entry.
1:                 found_ent.unsetRecoveryStatus();
1:             }
1: 		}
1: 
1:         return(found_ent != null);
1: 	}
1: 
1: 	/**
1: 		Get the least recently added (oldest) transaction
1: 		@return the RawTransaction's first log instant
1: 
1: 		<P>MT - safe, caller can be recovery or checkpoint
1: 	*/
1: 	public LogInstant getFirstLogInstant()
1: 	{
1: 		// assume for now that it is acceptable to return null if a transaction
1: 		// starts right in the middle of this call.
1: 
1: 		if (trans.isEmpty())
1:         {
1: 			return null;
1:         }
1: 		else
1: 		{
0: 			LogInstant logInstant = null;
1:             
0:             // bug 5632: need to sychronize so that another thread does not 
0:             // come in and disrupt the for loop, we got an exception on next,
0:             // likely because hash table changed by another thread after
0:             // hasMoreElements() called, but before nextElement().
1: 
0:             synchronized (trans)
1:             {
0:                 for (Enumeration e = trans.elements(); e.hasMoreElements(); )
1:                 {
0:                     TransactionTableEntry ent =
0:                         (TransactionTableEntry)e.nextElement();
1: 
0:                     if (ent != null && ent.isUpdate())
1:                     {
0:                         if (logInstant == null || 
0:                             ent.getFirstLog().lessThan(logInstant))
1:                         {
0:                             logInstant = ent.getFirstLog();
1:                         }
1:                     }
1:                 }
1:             }
1: 
0: 			return logInstant;
1: 		}
1: 	}
1: 
1: 	/**
1: 		Find a transaction using the transaction id, and make the passed in
1: 		transaction assume the identity and properties of that transaction.
1: 
1: 		<P>MT - unsafe, caller is recovery, which is single threaded.
1: 
1: 		@param id transaction Id
1: 		@param tran the transaction that was made to assume the transactionID
0: 		and all other relavent information stored in the transaction table
1: 		@return true if transaction can be found, false otherwise
1: 	*/
1: 	boolean findAndAssumeTransaction(
1:     TransactionId       id, 
1:     RawTransaction      tran)
1: 	{
1: 		// the only caller for this method right now is recovery.  
1:         // No need to put in any concurrency control
1: 		TransactionTableEntry ent = null;
1: 
1: 		if (id != null && !trans.isEmpty())
1: 		{
1: 			ent = findTransactionEntry(id);
1: 
1: 			if (SanityManager.DEBUG)
1: 			{
1: 				if (ent != null)
1: 					SanityManager.ASSERT(ent.isRecovery(),
1: 					"assuming the id of a non-recovery transaction");
1: 			}
1: 		}
1: 
1: 		// if no transaction entry found, set transaction to idle
1:         ((Xact)tran).assumeIdentity(ent);
1: 
1: 		return(ent != null);
1: 
1: 	}
1: 
1: 	/**********************************************************
1: 	 * Transaction table vti and diagnostics
1: 	 * MT - unsafe, caller is getting a snap shot which may be inconsistent 
1: 	 *********************************************************/
1: 
1: 	/**
1: 		Get a printable version of the transaction table
1: 	 */
1: 	public TransactionInfo[] getTransactionInfo()
1: 	{
1: 		if (trans.isEmpty())
1: 			return null;
1: 
0: 		// while taking a snap shot, no adding or removing of transaction
0: 		TransactionInfo[] tinfo;
1: 
1: 		if (SanityManager.DEBUG)
0: 			SanityManager.DEBUG("TranTrace", toString());
1: 
1: 		synchronized(this)
1: 		{
0: 			int ntran = trans.size();
0: 			tinfo = new TransactionTableEntry[ntran];
1: 
0: 			LogInstant logInstant = null;
0: 			int i = 0;
1: 
0: 			for (Enumeration e = trans.elements();
0: 				 e.hasMoreElements(); )
1: 			{
0: 				TransactionTableEntry ent =
0: 					(TransactionTableEntry)e.nextElement();
1: 
1: 				if (ent != null)
0: 					tinfo[i++] = (TransactionTableEntry)ent.clone();
1: 
1: 				if (SanityManager.DEBUG)
0: 					SanityManager.ASSERT(ent != null, "transaction table has null entry");
1: 			}
1: 		}
1: 
0: 		return tinfo;
1: 	}
1: 
1: 	public String toString()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			StringBuffer str = new StringBuffer(1000).
1: 				append("\n**************************\n").
1: 				append(super.toString()).
1: 				append("\nTransaction Table: size = ").append(trans.size()).
1: 				append(" largestUpdateXactId = ").append(largestUpdateXactId).
1: 				append("\n");
1: 
0: 			boolean hasReadOnlyTransaction = false;
1: 
0: 			for (Enumeration e = trans.elements();
0: 				 e.hasMoreElements(); )
1: 			{
0: 				TransactionTableEntry ent =
0: 					(TransactionTableEntry)e.nextElement(); 
1: 
0: 				if (ent != null && ent.isUpdate())
0: 					str.append(ent.toString());
1: 
0: 				if (ent != null && !ent.isUpdate())
0: 					hasReadOnlyTransaction = true;
1: 			}
1: 
0: 			if (hasReadOnlyTransaction)
1: 			{
1: 				str.append("\n READ ONLY TRANSACTIONS \n");
1: 
0: 				for (Enumeration e = trans.elements();
0: 					 e.hasMoreElements(); )
1: 				{
0: 					TransactionTableEntry ent =
0: 						(TransactionTableEntry)e.nextElement(); 
1: 
0: 					if (ent != null && !ent.isUpdate())
0: 						str.append(ent.toString());
1: 				}
1: 			}
1: 			str.append("---------------------------");
1: 			return str.toString();
1: 		}
1: 		else
1: 			return null;
1: 	}
1: 
1: 
1: }
1: 
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.raw.xact
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.store.raw.xact;
0: 
0: import org.apache.derby.iapi.services.context.ContextManager;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.services.io.Formatable;
0: import org.apache.derby.iapi.services.io.FormatIdUtil;
0: import org.apache.derby.iapi.services.io.StoredFormatIds;
0: 
0: import org.apache.derby.iapi.store.access.TransactionInfo;
0: 
0: import org.apache.derby.iapi.store.raw.GlobalTransactionId;
0: 
0: import org.apache.derby.iapi.store.raw.log.LogInstant;
0: 
0: import org.apache.derby.iapi.store.raw.xact.RawTransaction;
0: import org.apache.derby.iapi.store.raw.xact.TransactionId;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.services.io.CompressedNumber;
0: 
0: import java.util.Hashtable;
0: import java.util.Enumeration;
0: import java.io.ObjectOutput;
0: import java.io.ObjectInput;
0: import java.io.IOException;
0: 
0: /**
0: 	The transaction table is used by the transaction factory to keep track of
0: 	all transactions that are in the system.
0: 
0: 	<BR> The transction table serves the following purposes: <OL> 
0: 
0: 	<LI> checkpoint - when a checkpoint log record is written out, it writes
0: 	out also all transactions that have updated the database.  RESOLVE: this is
0: 	actually not used right now - rather, the transaction table is
0: 	reconstructed during the redo phase by traversing from the undo LWM.  It is
0: 	a goal to use this transaction table (and traversing from the redoLWM)
0: 	instead of rebuilding it to speed up recovery.
0: 
0: 	<LI> Quiesce State - when a  system enters the quiesce state, it needs to account
0: 	for all transactions in the system, even those which are just started and
0: 	are in their IDLE state.
0: 
0: 	<LI> TransactionTable VTI - we need to get a snapshot of all transactions
0: 	in the system for diagnostic purposes.
0: 	</OL>
0: 
0: 	In order to speed up the time it takes to look up a transaction from the
0: 	transaction table, each transaction must have a unique transaction Id.
0: 	This means newly coined transaction must also have a transaction Id.
0: 
0: 	<P>During recovery, there is only one real xact object doing all the
0: 	recovery work, but there could be many outstanding transactions that are
0: 	gleamed from the log.  Each of these "recovery transactions" have its on
0: 	entry into the transaction table but they all share the same Xact object.
0: 
0: 	<P>Multithreading considerations:<BR>
0: 	TransactionTable must be MT-safe it is called upon by many threads
0: 	simultaneously (except during recovery)
0: 
0: 	<P><B> This class depends on Hashtable synchronization!! </B>
0: 
0: */
0: 
0: public class TransactionTable implements Formatable
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	/*
0: 	 * Fields
0: 	 */
0: 
0: 	private Hashtable trans;
0: 
0: 	private TransactionId largestUpdateXactId;
0: 
0: 	/**
0: 		MT - not needed for constructor
0: 	*/
0: 	public TransactionTable()
0: 	{
0: 		trans = new Hashtable(17);
0: 	}
0: 
0: 	/*************************************************************
0: 	 * generic methods called by all clients of transaction table
0: 	 * Must be MT -safe
0: 	 ************************************************************/
0: 	private TransactionTableEntry findTransactionEntry(TransactionId id)
0: 	{
0: 
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(
0:                 id != null, "findTransacionEntry with null id");
0: 
0: 		// Hashtable is synchronized
0: 		return (TransactionTableEntry)trans.get(id);
0: 	}
0: 
0: 
0: 
0: 
0: 	void add(Xact xact, boolean exclude)
0: 	{
0: 		TransactionId id = xact.getId();
0: 
0: 		synchronized(this)
0: 		{
0: 			TransactionTableEntry ent = findTransactionEntry(id);
0: 
0: 			if (ent == null)
0: 			{
0: 				ent = new TransactionTableEntry
0: 					(xact, id, 0, 
0: 					 exclude ? TransactionTableEntry.EXCLUDE : 0);
0: 
0: 				trans.put(id, ent);
0: 
0: 				if (SanityManager.DEBUG)
0:                 {
0:                     if (SanityManager.DEBUG_ON("TranTrace"))
0:                     {
0:                         SanityManager.DEBUG(
0:                             "TranTrace", "adding transaction " + id);
0:                         SanityManager.showTrace(new Throwable("TranTrace"));
0:                     }
0:                 }
0: 			}
0: 
0: 			if (SanityManager.DEBUG)
0: 			{
0: 				if (exclude != ent.needExclusion())
0: 					SanityManager.THROWASSERT(
0: 					  "adding the same transaction with different exclusion: " +
0: 					  exclude + " " + ent.needExclusion());
0: 			}
0: 		}
0: 
0: 		if (SanityManager.DEBUG) {
0: 
0: 			if (SanityManager.DEBUG_ON("memoryLeakTrace")) {
0: 
0: 				if (trans.size() > 50)
0: 					System.out.println("memoryLeakTrace:TransactionTable " + trans.size());
0: 			}
0: 		}
0: 	}
0: 
0: 	/*
0: 		remove the transaction Id an return false iff the transaction is found
0: 		in the table and it doesn't need exclusion during quiesce state
0: 	 */
0: 	boolean remove(TransactionId id)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(
0:                 id != null, 
0:                 "cannot remove transaction from table with null id");
0: 
0: 		if (SanityManager.DEBUG)
0:         {
0:             if (SanityManager.DEBUG_ON("TranTrace"))
0:             {
0:                 SanityManager.DEBUG(
0:                     "TranTrace", "removing transaction " + id);
0:                 SanityManager.showTrace(new Throwable("TranTrace"));
0:             }
0:         }
0: 
0: 		// Hashtable is synchronized
0: 		 TransactionTableEntry ent = (TransactionTableEntry)trans.remove(id);
0: 		 return (ent == null || ent.needExclusion());
0: 	}
0: 
0: 
0: 	/**
0: 		Change a transaction to update or add an update transaction to this table.
0: 
0: 		@param tid the transaction id
0: 		@param tran the transaction to be added
0: 		@param transactionStatus the transaction status that is stored in the
0: 				BeginXact log record
0: 	 */
0: 	public void addUpdateTransaction(TransactionId tid, RawTransaction tran,
0: 									 int transactionStatus)
0: 	{
0: 
0: 		// we need to synchronize on the transaction table because we have to
0: 		// prevent this state change from happening when the transaction table
0: 		// itself is written out to the checkpoint.  This is the only
0: 		// protection the TransactionTableEntry has to prevent fields in myxact
0: 		// from changing underneath it while it is being written out.
0: 		synchronized(this)
0: 		{
0: 			TransactionTableEntry ent = findTransactionEntry(tid);
0: 
0: 			if (ent != null)
0: 			{
0: 				// this happens during run time, when a transaction that is
0: 				// already started changed status to an update transaction
0: 
0: 				ent.updateTransactionStatus((Xact)tran, transactionStatus,
0: 											TransactionTableEntry.UPDATE) ;
0: 			}
0: 			else
0: 			{
0: 				// this happens during recovery, that's why we haven't seen
0: 				// this transaction before - it is added in the doMe of the 
0: 				// BeginXact log record.
0: 				//
0: 				// No matter what this transaction is, it won't need to be run
0: 				// in quiesce state because we are in recovery.
0: 				ent = new TransactionTableEntry((Xact)tran, tid, transactionStatus, 
0: 												TransactionTableEntry.UPDATE | 
0: 												TransactionTableEntry.EXCLUDE |
0: 												TransactionTableEntry.RECOVERY);
0: 				trans.put(tid, ent);
0: 
0: 			}
0: 
0: 			if (XactId.compare(ent.getXid(), largestUpdateXactId) > 0)
0: 				largestUpdateXactId = ent.getXid();
0: 		}
0: 	}
0: 
0: 	/**
0: 	    Change update transaction to non-update
0: 
0: 		<P>MT - MT safe, since vector is MT-safe.
0: 
0: 		@param id the transaction Id
0: 	  */
0: 	void removeUpdateTransaction(TransactionId id)
0: 	{
0: 		// we need to synchronize on the transaction table because we have to
0: 		// prevent this state change from happening when the transaction table
0: 		// itself is written out to the checkpoint.  This is the only
0: 		// protection the TransactionTableEntry has to prevent fields in myxact
0: 		// from changing underneath it while it is being written out.
0: 
0: 		synchronized (this)
0: 		{
0: 			TransactionTableEntry ent = findTransactionEntry(id);
0: 
0: 			if (SanityManager.DEBUG)
0: 			{
0: 				SanityManager.ASSERT(ent != null, 
0: 				 "removing update transaction that is not there");
0: 			}
0: 
0: 			ent.removeUpdateTransaction();
0: 
0: 			// If we are committing a recovery transaction, remove it from the
0: 			// transaction table.  The xact object which is doing the work is
0: 			// not going to be closed even though the transaction is done.
0: 			if (ent.isRecovery())
0: 				remove(id);
0: 		}
0: 
0: 		return;
0: 	}
0: 
0:     /**************************************************************************
0:      * Transaction table methods used by XA.
0:      **************************************************************************
0:      */
0: 
0:     /**
0:      * Return the hash table to the XA layer.
0:      * <p>
0:      * The XA code will do linear read-only operations on the hash table,
0:      * write operations are only done in this module.  It is a little ugly
0:      * to export the hash table, but I wanted to move the XA specific code
0:      * into the XA module, so that we could configure out the XA code if
0:      * necessary.
0:      * <p>
0:      *
0: 	 * Must be MT -safe, depends on sync hash table, and must get 
0:      *     synchronized(hash_table) for linear searches.
0:      *
0: 	 * @return The ContextManager of the transaction being searched for.
0:      *
0:      * @param global_id The global transaction we are searching for.
0:      **/
0: 	public Hashtable getTableForXA()
0: 	{
0:         return(trans);
0: 	}
0: 
0: 	/**
0: 	    Change transaction to prepared.
0: 
0: 		<P>MT - unsafe, caller is recovery, which is single threaded.
0: 
0: 		@param id the transaction Id
0: 	  */
0: 	void prepareTransaction(TransactionId id)
0: 	{
0: 		// we need to synchronize on the transaction table because we have to
0: 		// prevent this state change from happening when the transaction table
0: 		// itself is written out to the checkpoint.  This is the only
0: 		// protection the TransactionTableEntry has to prevent fields in myxact
0: 		// from changing underneath it while it is being written out.
0: 
0:         TransactionTableEntry ent = findTransactionEntry(id);
0: 
0:         if (SanityManager.DEBUG)
0:         {
0:             SanityManager.ASSERT(
0:                 ent != null, "preparing transaction that is not there");
0:         }
0: 
0:         ent.prepareTransaction();
0: 
0: 		return;
0: 	}
0: 
0:     /**
0:      * Find a transaction in the table by Global transaction id.
0:      * <p>
0:      * Only called by XactXAResourceManager.find() during offline recovery
0:      * of in-doubt transactions, we do not expect this to be called often 
0:      * so performance is not critical.  Just to linear search of id's. 
0:      * <p>
0:      *
0: 	 * @return The ContextManager of the transaction being searched for.
0:      *
0:      * @param global_id The global transaction we are searching for.
0:      **/
0: 	public ContextManager findTransactionContextByGlobalId(
0:     GlobalXactId global_id)
0: 	{
0:         ContextManager cm              = null;
0: 
0:         // Need to hold sync while linear searching the hash table.
0:         synchronized (trans)
0:         {
0:             for (Enumeration e = trans.elements(); e.hasMoreElements();) 
0:             {
0:                 TransactionTableEntry entry = 
0:                     (TransactionTableEntry) e.nextElement();
0: 
0:                 if (entry.getGid() != null && 
0: 					entry.getGid().equals(global_id))
0:                 {
0:                     cm = entry.getXact().getContextManager();
0:                     break;
0:                 }
0:             }
0:         }
0:               
0: 		return(cm);
0: 	}
0: 
0: 
0: 	/***********************************************************
0: 	 * called when system is being quiesced, must be MT - safe
0: 	 ***********************************************************/
0: 	/**
0: 		Return true if there is no transaction actively updating the database.
0: 		New transaction may be started or old transaction committed
0: 		right afterward, the caller of this routine must have other ways to
0: 		stop transactions from starting or ending.
0: 
0: 		<P>MT - safe
0: 	*/
0: 	boolean hasActiveUpdateTransaction()
0: 	{
0: 		synchronized (this)
0: 		{
0: 			for (Enumeration e = trans.elements(); e.hasMoreElements(); )
0: 			{
0: 				TransactionTableEntry ent = (TransactionTableEntry)e.nextElement();
0: 				if (ent != null && ent.isUpdate())
0: 					return true;
0: 			}
0: 		}
0: 		return false;
0: 	}
0: 
0: 
0: 
0: 	/************************************************************
0: 	 * methods called only by checkpoint
0: 	 ***********************************************************/
0: 	/*
0: 	 * Formatable methods
0: 	 */
0: 
0: 	/**
0: 		Return my format identifier.
0: 	*/
0: 	public int getTypeFormatId() {
0: 		return StoredFormatIds.RAW_STORE_TRANSACTION_TABLE;
0: 	}
0: 
0: 	/**
0: 	  @exception IOException problem reading the transaction table
0: 	*/
0: 	public void writeExternal(ObjectOutput out) throws IOException 
0: 	{
0: 		//don't let the transactions status change while writing out(beetle:5533)
0: 		//Note: syncing both on trans and this variable could be avoided if
0: 		//all the routines in this class are sycned on "this" and does not
0: 		//depend on hash table synchronization. But that will be overkill 
0: 		//because this routine gets called only on checkpoints and others
0: 		//are used more often.
0: 
0: 		synchronized(this)
0: 		{	
0: 			// don't touch the transaction table when I am being written out
0: 			synchronized(trans)
0: 			{
0: 				int count = 0;
0: 				int maxcount = trans.size();
0: 
0: 				// first count up the number of active update transactions 
0: 				for (Enumeration e = trans.elements();
0: 					 e.hasMoreElements(); )
0: 				{
0: 					TransactionTableEntry ent = (TransactionTableEntry)e.nextElement();
0: 					if (ent != null && ent.isUpdate())
0: 						count++;
0: 				}
0: 
0: 				CompressedNumber.writeInt(out, count);
0: 
0: 				// now write them out
0: 				if (count > 0)
0: 				{
0: 					for (Enumeration e = trans.elements();
0: 						 e.hasMoreElements() ; )
0: 					{
0: 						TransactionTableEntry ent = (TransactionTableEntry)e.nextElement();
0: 						if (ent != null && ent.isUpdate())
0: 						{
0: 							// only writes out update transaction
0: 							out.writeObject(ent);
0: 						}
0: 					}
0: 				}
0: 			}
0: 		}
0: 	}
0: 
0: 	/************************************************************
0: 	 * methods called only by recovery
0: 	 ************************************************************/
0: 
0: 
0: 	/**
0: 	  @exception IOException problem reading the transaction table
0: 	  @exception ClassNotFoundException problem reading the transaction table
0: 	 */
0: 	public void readExternal(ObjectInput in) 
0: 		 throws IOException, ClassNotFoundException
0: 	{
0: 		// RESOLVE: this is only read in checkpoint record, but we have not
0: 		// finish the work on using this transaction table to cut down on redo
0: 		// so this transaction table is effectively and futilely thrown away!
0: 
0: 		int count = CompressedNumber.readInt(in);
0: 		if (count == 0)
0: 			return;
0: 
0: 		for (int i = 0; i < count; i++)
0: 		{
0: 			TransactionTableEntry ent = 
0: 				(TransactionTableEntry)in.readObject();
0: 
0: 			if (SanityManager.DEBUG)
0: 				SanityManager.ASSERT(
0:                     ent.getXid() != null,
0:                     "read in transaction table entry with null id");
0: 
0: 			trans.put(ent.getXid(), ent);
0: 
0: 			if (ent.isUpdate() && 
0:                 XactId.compare(ent.getXid(), largestUpdateXactId) > 0)
0:             {
0: 				largestUpdateXactId = ent.getXid();
0:             }
0: 		}
0: 
0: 
0: 	}
0: 
0: 	/**
0: 		Return the largest update transactionId I have seen so far
0: 
0: 		<P>MT - unsafe, caller is recovery, which is single threaded.
0: 	*/
0: 	public TransactionId largestUpdateXactId()
0: 	{
0: 		return largestUpdateXactId;
0: 	}
0: 
0: 
0: 	/**
0: 		Is there an active internal transaction in the transaction table
0: 
0: 		<P>MT - unsafe, caller is recovery, which is single threaded.
0: 	*/
0: 	public boolean hasRollbackFirstTransaction()
0: 	{
0: 		for (Enumeration e = trans.elements();
0: 			 e.hasMoreElements() ; )
0: 		{
0: 			TransactionTableEntry ent = (TransactionTableEntry)e.nextElement();
0: 
0: 			if (ent != null && ent.isRecovery() && 
0: 				(ent.getTransactionStatus() & 
0:                      Xact.RECOVERY_ROLLBACK_FIRST) != 0)
0:             {
0: 				return true;
0:             }
0: 		}
0: 		return false;
0: 	}
0: 
0: 	/**
0: 		Is there a prepared transaction in the transaction table.
0: 
0: 		<P>MT - unsafe, caller is recovery, which is single threaded.
0: 	*/
0: 	public boolean hasPreparedRecoveredXact()
0: 	{
0: 		for (Enumeration e = trans.elements(); e.hasMoreElements(); )
0: 		{
0: 			TransactionTableEntry ent = (TransactionTableEntry) e.nextElement();
0: 
0: 			if (ent != null && ent.isRecovery() && 
0: 				(ent.getTransactionStatus() & Xact.END_PREPARED) != 0)
0:             {
0: 				return true;
0:             }
0: 		}
0: 		return false;
0: 	}
0: 
0: 
0: 	/**
0: 		Get the most recently added transaction that says it needs to be
0: 		rolled back first (an InternalXact) from the transaction table and make
0: 		the passed in transaction assume its identity. 
0: 		<B> Should only be used in recovery undo !! </B>
0: 		RESOLVE: (sku)I don't think even these internal transactions need to be
0: 		rolled back in the reverse order, because they are physical in nature.
0: 		But it won't hurt.
0: 
0: 		<P>MT - unsafe, caller is recovery, which is single threaded.
0: 	*/
0: 	public boolean getMostRecentRollbackFirstTransaction(RawTransaction tran)
0: 	{
0: 
0: 		if (trans.isEmpty())
0: 		{
0: 			// set tranaction to idle
0: 			return findAndAssumeTransaction((TransactionId)null, tran);
0: 		}
0: 
0: 		TransactionId id = null;
0: 		for (Enumeration e = trans.elements();
0: 			 e.hasMoreElements() ; )
0: 		{
0: 			TransactionTableEntry ent = (TransactionTableEntry)e.nextElement();
0: 
0: 			if (ent != null && ent.isUpdate() && ent.isRecovery() &&
0: 				(ent.getTransactionStatus() & Xact.RECOVERY_ROLLBACK_FIRST) != 0)
0: 			{
0: 				// try to locate the most recent one
0: 				if (id == null || XactId.compare(id, ent.getXid()) < 0)
0: 					id = ent.getXid();
0: 			}
0: 		}
0: 
0: 		if (id == null)			// set transaction to idle
0: 		{
0: 			return findAndAssumeTransaction(id, tran);
0: 		}
0: 		else
0: 		{
0: 			// there is a rollback first transaction
0: 			boolean found = 
0:                 findAndAssumeTransaction(id, tran);
0: 
0: 			if (SanityManager.DEBUG)
0:             {
0:                 if (!found)
0:                 {
0:                     SanityManager.THROWASSERT(
0:                         "cannot find transaction " + id + " in table");
0:                 }
0:             }
0: 
0: 			return true;
0: 		}
0: 	}
0: 
0: 	/**
0: 		Get the most recently non-prepared added transaction from the 
0:         transaction table and make the passed in transaction assume its 
0:         identity.  Prepared transactions will not be undone.
0: 
0: 		RESOLVE: (sku) I don't think normal user transactions needs to be
0: 		rolled back in order, but it won't hurt.
0: 
0: 		<B> Should only be used in recovery undo !! </B>
0: 
0: 		<P>MT - unsafe, caller is recovery, which is single threaded.
0: 	*/
0: 	public boolean getMostRecentTransactionForRollback(RawTransaction tran)
0: 	{
0:         TransactionId id = null;
0: 
0:         if (!trans.isEmpty())
0: 		{
0: 			for (Enumeration e = trans.elements();
0: 				 e.hasMoreElements() ; )
0: 			{
0: 				TransactionTableEntry ent =
0: 					 (TransactionTableEntry)e.nextElement();
0: 
0: 				if (ent != null         && 
0:                     ent.isUpdate()      && 
0:                     ent.isRecovery()    && 
0:                     !ent.isPrepared())
0: 				{
0: 					// try to locate the most recent one
0: 					if (id == null || XactId.compare(id, ent.getXid()) < 0)
0: 						id = ent.getXid();
0: 				}
0: 
0: 				if (SanityManager.DEBUG)
0: 				{
0: 					if (ent != null         && 
0:                         ent.isUpdate()      && 
0:                         ent.isRecovery()    &&
0: 						(ent.getTransactionStatus() & 
0:                          Xact.RECOVERY_ROLLBACK_FIRST) != 0)
0:                     {
0: 						SanityManager.THROWASSERT(
0:                             "still rollback first xacts in the tran table!");
0:                     }
0: 				}
0: 			}
0: 
0: 			if (SanityManager.DEBUG)
0:             {
0:                 // if all transactions are prepared then it is possible that
0:                 // no transaction will be found, in that case id will be null.
0:                 if (id != null)
0:                 {
0:                     SanityManager.ASSERT(findTransactionEntry(id) != null);
0:                 }
0:                 else
0:                 {
0:                     // all transactions in the table must be prepared.
0:                     for (Enumeration e = trans.elements(); e.hasMoreElements();)
0:                     {
0:                         TransactionTableEntry ent =
0:                             (TransactionTableEntry)e.nextElement();
0:                         SanityManager.ASSERT(ent.isPrepared());
0:                     }
0:                 }
0:             }
0: 		}
0: 
0:         return(findAndAssumeTransaction(id, tran));
0: 	}	
0: 
0: 	/**
0: 		Get the most recently added transaction that says it is prepared during
0:         recovery the transaction table and make the passed in transaction 
0:         assume its identity. This routine turns off the isRecovery() state
0: 		<B> Should only be used in recovery handle prepare after undo !! </B>
0: 
0: 		<P>MT - unsafe, caller is recovery, which is single threaded.
0: 	*/
0: 
0:     /**
0:      * Get the most recent recovered prepared transaction.
0:      * <p>
0:      * Get the most recently added transaction that says it is prepared during 
0:      * recovery the transaction table and make the passed in transaction 
0:      * assume its identity. 
0:      * <p>
0:      * This routine, unlike the redo and rollback getMostRecent*() routines
0:      * expects a brand new transaction to be passed in.  If a candidate 
0:      * transaction is found, then upon return the transaction table will 
0:      * be altered such that the old entry no longer exists, and a new entry
0:      * will exist pointing to the transaction passed in.  The new entry will
0:      * look the same as if the prepared transaction had been created during
0:      * runtime rather than recovery.
0:      *
0:      * <B> Should only be used in recovery handle prepare after undo !! </B>
0:      *
0:      * <P>MT - unsafe, caller is recovery, which is single threaded.
0:      *
0: 	 * @return true if a candidate transaction has been found.  false if no
0:      *         prepared/recovery transactions found in the table.
0:      *
0:      * @param tran   Newly allocated transaction to add to link to a entry.
0:      *
0:      **/
0: 	public boolean getMostRecentPreparedRecoveredXact(
0:     RawTransaction tran)
0: 	{
0:         TransactionTableEntry   found_ent   = null;
0: 
0:         if (!trans.isEmpty())
0: 		{
0:             TransactionId           id          = null;
0:             GlobalTransactionId     gid         = null;
0:             TransactionTableEntry   ent;
0: 
0: 			for (Enumeration e = trans.elements(); e.hasMoreElements(); )
0: 			{
0: 				ent = (TransactionTableEntry)e.nextElement();
0: 
0: 				if (ent != null         && 
0:                     ent.isRecovery()    && 
0:                     ent.isPrepared())
0: 				{
0: 					// try to locate the most recent one
0: 					if (id == null || XactId.compare(id, ent.getXid()) < 0)
0:                     {
0:                         found_ent = ent;
0: 						id        = ent.getXid();
0: 						gid       = ent.getGid();
0:                     }
0: 				}
0: 			}
0: 
0:             if (SanityManager.DEBUG)
0:             {
0:                 if (found_ent == null)
0:                 {
0:                     // if no entry's were found then the transaction table
0:                     // should have the passed in idle tran, and the rest should
0:                     // be non-recover, prepared global transactions.
0:                     for (Enumeration e = trans.elements(); e.hasMoreElements();)
0:                     {
0:                         ent = (TransactionTableEntry)e.nextElement();
0: 
0:                         if (XactId.compare(ent.getXid(), tran.getId()) != 0)
0:                         {
0:                             SanityManager.ASSERT(
0:                                 !ent.isRecovery() && ent.isPrepared());
0:                             SanityManager.ASSERT(ent.getGid() != null);
0:                         }
0:                     }
0:                 }
0:             }
0: 
0:             if (found_ent != null)
0:             {
0:                 // At this point there are 2 tt entries of interest:
0:                 //     new_ent - the read only transaction entry that was 
0:                 //               created when we allocated a new transaction.
0:                 //               We will just throw this one away after 
0:                 //               assuming the identity of the global xact.
0:                 //     found_ent
0:                 //             - the entry of the transaction that we are going
0:                 //               to take over.
0:                 TransactionTableEntry new_ent =
0:                     (TransactionTableEntry) trans.remove(tran.getId());
0: 
0:                 // At this point only the found_ent should be in the table.
0:                 if (SanityManager.DEBUG)
0:                 {
0: 	                SanityManager.ASSERT(findTransactionEntry(id) == found_ent);
0:                 }
0: 
0:                 ((Xact) tran).assumeGlobalXactIdentity(found_ent);
0: 
0:                 // transform this recovery entry, into a runtime entry.
0:                 found_ent.unsetRecoveryStatus();
0:             }
0: 		}
0: 
0:         return(found_ent != null);
0: 	}
0: 
0: 	/**
0: 		Get the least recently added (oldest) transaction
0: 		@return the RawTransaction's first log instant
0: 
0: 		<P>MT - safe, caller can be recovery or checkpoint
0: 	*/
0: 	public LogInstant getFirstLogInstant()
0: 	{
0: 		// assume for now that it is acceptable to return null if a transaction
0: 		// starts right in the middle of this call.
0: 
0: 		if (trans.isEmpty())
0:         {
0: 			return null;
0:         }
0: 		else
0: 		{
0: 			LogInstant logInstant = null;
0:             
0:             // bug 5632: need to sychronize so that another thread does not 
0:             // come in and disrupt the for loop, we got an exception on next,
0:             // likely because hash table changed by another thread after
0:             // hasMoreElements() called, but before nextElement().
0: 
0:             synchronized (trans)
0:             {
0:                 for (Enumeration e = trans.elements(); e.hasMoreElements(); )
0:                 {
0:                     TransactionTableEntry ent =
0:                         (TransactionTableEntry)e.nextElement();
0: 
0:                     if (ent != null && ent.isUpdate())
0:                     {
0:                         if (logInstant == null || 
0:                             ent.getFirstLog().lessThan(logInstant))
0:                         {
0:                             logInstant = ent.getFirstLog();
0:                         }
0:                     }
0:                 }
0:             }
0: 
0: 			return logInstant;
0: 		}
0: 	}
0: 
0: 	/**
0: 		Find a transaction using the transaction id, and make the passed in
0: 		transaction assume the identity and properties of that transaction.
0: 
0: 		<P>MT - unsafe, caller is recovery, which is single threaded.
0: 
0: 		@param id transaction Id
0: 		@param tran the transaction that was made to assume the transactionID
0: 		and all other relavent information stored in the transaction table
0: 		@return true if transaction can be found, false otherwise
0: 	*/
0: 	boolean findAndAssumeTransaction(
0:     TransactionId       id, 
0:     RawTransaction      tran)
0: 	{
0: 		// the only caller for this method right now is recovery.  
0:         // No need to put in any concurrency control
0: 		TransactionTableEntry ent = null;
0: 
0: 		if (id != null && !trans.isEmpty())
0: 		{
0: 			ent = findTransactionEntry(id);
0: 
0: 			if (SanityManager.DEBUG)
0: 			{
0: 				if (ent != null)
0: 					SanityManager.ASSERT(ent.isRecovery(),
0: 					"assuming the id of a non-recovery transaction");
0: 			}
0: 		}
0: 
0: 		// if no transaction entry found, set transaction to idle
0:         ((Xact)tran).assumeIdentity(ent);
0: 
0: 		return(ent != null);
0: 
0: 	}
0: 
0: 	/**********************************************************
0: 	 * Transaction table vti and diagnostics
0: 	 * MT - unsafe, caller is getting a snap shot which may be inconsistent 
0: 	 *********************************************************/
0: 
0: 	/**
0: 		Get a printable version of the transaction table
0: 	 */
0: 	public TransactionInfo[] getTransactionInfo()
0: 	{
0: 		if (trans.isEmpty())
0: 			return null;
0: 
0: 		// while taking a snap shot, no adding or removing of transaction
0: 		TransactionInfo[] tinfo;
0: 
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.DEBUG("TranTrace", toString());
0: 
0: 		synchronized(this)
0: 		{
0: 			int ntran = trans.size();
0: 			tinfo = new TransactionTableEntry[ntran];
0: 
0: 			LogInstant logInstant = null;
0: 			int i = 0;
0: 
0: 			for (Enumeration e = trans.elements();
0: 				 e.hasMoreElements(); )
0: 			{
0: 				TransactionTableEntry ent =
0: 					(TransactionTableEntry)e.nextElement();
0: 
0: 				if (ent != null)
0: 					tinfo[i++] = (TransactionTableEntry)ent.clone();
0: 
0: 				if (SanityManager.DEBUG)
0: 					SanityManager.ASSERT(ent != null, "transaction table has null entry");
0: 			}
0: 		}
0: 
0: 		return tinfo;
0: 	}
0: 
0: 	public String toString()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			StringBuffer str = new StringBuffer(1000).
0: 				append("\n**************************\n").
0: 				append(super.toString()).
0: 				append("\nTransaction Table: size = ").append(trans.size()).
0: 				append(" largestUpdateXactId = ").append(largestUpdateXactId).
0: 				append("\n");
0: 
0: 			boolean hasReadOnlyTransaction = false;
0: 
0: 			for (Enumeration e = trans.elements();
0: 				 e.hasMoreElements(); )
0: 			{
0: 				TransactionTableEntry ent =
0: 					(TransactionTableEntry)e.nextElement(); 
0: 
0: 				if (ent != null && ent.isUpdate())
0: 					str.append(ent.toString());
0: 
0: 				if (ent != null && !ent.isUpdate())
0: 					hasReadOnlyTransaction = true;
0: 			}
0: 
0: 			if (hasReadOnlyTransaction)
0: 			{
0: 				str.append("\n READ ONLY TRANSACTIONS \n");
0: 
0: 				for (Enumeration e = trans.elements();
0: 					 e.hasMoreElements(); )
0: 				{
0: 					TransactionTableEntry ent =
0: 						(TransactionTableEntry)e.nextElement(); 
0: 
0: 					if (ent != null && !ent.isUpdate())
0: 						str.append(ent.toString());
0: 				}
0: 			}
0: 			str.append("---------------------------");
0: 			return str.toString();
0: 		}
0: 		else
0: 			return null;
0: 	}
0: 
0: 
0: }
0: 
============================================================================