1:33877ab: /*
1:a38484c: 
1:33877ab:    Derby - Class org.apache.derbyBuild.ReleaseNotesGenerator
1:0123797: 
1:33877ab:    Licensed to the Apache Software Foundation (ASF) under one or more
1:33877ab:    contributor license agreements.  See the NOTICE file distributed with
1:33877ab:    this work for additional information regarding copyright ownership.
1:33877ab:    The ASF licenses this file to You under the Apache License, Version 2.0
1:33877ab:    (the "License"); you may not use this file except in compliance with
1:33877ab:    the License.  You may obtain a copy of the License at
1:0123797: 
1:33877ab:       http://www.apache.org/licenses/LICENSE-2.0
1:a38484c: 
1:33877ab:    Unless required by applicable law or agreed to in writing, software
1:33877ab:    distributed under the License is distributed on an "AS IS" BASIS,
1:33877ab:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:33877ab:    See the License for the specific language governing permissions and
1:33877ab:    limitations under the License.
1:4c14d1b: 
44:33877ab:  */
1:4c14d1b: 
1:33877ab: package org.apache.derbyBuild;
1:2981b19: 
1:33877ab: import java.io.*;
1:d76e238: import java.util.*;
1:33877ab: import org.w3c.dom.*;
1:33877ab: import java.net.URL;
1:33877ab: import org.apache.tools.ant.BuildException;
1:2981b19: 
1:a38484c: /**
3:a38484c:  * <p>
1:33877ab:  * This tool generates Release Notes for a Derby release. See the USAGE
1:33877ab:  * constant for details on how to run this tool standalone. It is recommended
1:e1aa9c0:  * that you freshly regenerate your BUG_LIST just before you run this tool.
1:a38484c:  * </p>
1:a38484c:  *
1:a38484c:  * <p>
1:e1aa9c0:  * The tool is designed to be run from Derby's ant build scripts. The build
1:e1aa9c0:  * script will integrate the various steps of generating the release notes into
1:e1aa9c0:  * a single ant target. This includes generating the issue list by querying
1:e1aa9c0:  * the Apache JIRA instance. For this reason, the properties below must be
1:e1aa9c0:  * specified when invoking the ant target. You can specify them in
1:e1aa9c0:  * <tt>ant.properties</tt>, or on the command line.<br/>
1:e1aa9c0:  * To run under ant, do the following:
1:a38484c:  * </p>
1:a38484c:  *
1:33877ab:  * <ul>
1:e1aa9c0:  *      <li>Make sure the Maven 2 executable is in your path.</li>
1:e1aa9c0:  *      <li>Fill in information in <tt>releaseSummary.xml</tt>.<br/>
1:e1aa9c0:  *          See <tt>tools/release/templates/releaseSummaryTemplate.xml</tt>
1:e1aa9c0:  *          for details.</li>
1:e1aa9c0:  *      <li>Define <tt>jira.user</tt>.<br/>
1:e1aa9c0:  *          This variable is your JIRA user name.</li>
1:e1aa9c0:  *      <li>Define <tt>jira.password</tt>.<br/>
1:e1aa9c0:  *          This variable is your JIRA password.</li>
1:e1aa9c0:  *      <li>Define <tt>jira.filter.id</tt>.<br/>
1:e1aa9c0:  *          This variable holds the id for the manually created JIRA filter
1:e1aa9c0:  *          that will select the issues addressed by the release. The id
1:e1aa9c0:  *          consists of digits only.</li>
1:e1aa9c0:  *      <li>Define <tt>release.version</tt>.<br/>
1:e1aa9c0:  *          The version of the release, i.e. "10.7.1.0".</li>
1:e1aa9c0:  *      <li>Define <tt>relnotes.src.reports</tt>.<br/>
1:e1aa9c0:  *          This variable points at the directory which holds the list of JIRA
1:e1aa9c0:  *          issues addressed by the release. The file, called
1:e1aa9c0:  *          <tt>fixedBugsList.txt</tt>, will be generated when you invoke the
1:e1aa9c0:  *          ant target.</li>
1:e1aa9c0:  *      <li>cd into <tt>tools/release</tt> and run ant thusly:
1:e1aa9c0:  *          <tt>ant [properties] genrelnotes</tt></li>
1:33877ab:  * </ul>
1:e1aa9c0:  * Running the ant target successfully requires a working Internet connection
1:e1aa9c0:  * to the Apache JIRA instance, as well as a valid JIRA username/password and
1:e1aa9c0:  * the id of an existing JIRA filter.
1:a38484c:  * </p>
1:e1aa9c0:  * <p>For more information on this tool, please see the JIRAs which introduced it:
1:e1aa9c0:  * <ul> <li><a href="http://issues.apache.org/jira/browse/DERBY-4857">DERBY-4857</a></li>
1:e1aa9c0:  *      <li><a href="http://issues.apache.org/jira/browse/DERBY-2570">DERBY-2570</a></li>
1:e1aa9c0:  * </ul>
1:a38484c:  * </p>
1:286c99f:  */
1:d76e238: public class ReleaseNotesGenerator extends GeneratorBase {
9:33877ab:     /////////////////////////////////////////////////////////////////////////
34:33877ab:     //
1:33877ab:     //  CONSTANTS
1:33877ab:     //
1:33877ab:     /////////////////////////////////////////////////////////////////////////
1:2981b19: 
1:33877ab:     private static  final   String  USAGE =
1:33877ab:         "Usage:\n" +
2:33877ab:         "\n" +
1:e1aa9c0:         "  java org.apache.derbyBuild.ReleaseNotesGenerator SUMMARY BUG_LIST OUTPUT_PAMPHLET\n" +
1:33877ab:         "\n" +
1:33877ab:         "    where\n" +
1:33877ab:         "                  SUMMARY                    Summary, a filled-in copy of releaseSummaryTemplate.xml.\n" +
1:e1aa9c0:         "                  BUG_LIST                   A report of issues addressed by this release, generated by the Derby JIRA SOAP client.\n" +
1:33877ab:         "                  OUTPUT_PAMPHLET  The output file to generate, typically RELEASE-NOTES.html.\n" +
1:33877ab:         "\n" +
1:33877ab:         "The ReleaseNoteGenerator attempts to connect to issues.apache.org in\n" +
1:33877ab:         "order to read the detailed release notes that have been clipped to\n" +
1:33877ab:         "individual JIRAs. Before running this program, make sure that you can\n" +
1:33877ab:         "ping issues.apache.org.\n" +
1:a38484c:         "\n" +
1:e1aa9c0:         "The ReleaseNoteGenerator assumes that the JIRA report contains\n" +
1:e1aa9c0:         "key, title, fix versions and attachment id elements for each Derby\n" +
1:e1aa9c0:         "issue. For each issue in with an attachment id element the\n" +
1:e1aa9c0:         "ReleaseNotesGenerator grabs the (latest) releaseNote.html file.\n" +
1:33877ab:         "\n" +
1:33877ab:         "For this reason, it is recommended that you freshly generate BUG_LIST\n" +
1:e1aa9c0:         "just before you run this tool.\n"
1:33877ab:         ;
1:286c99f: 
1:286c99f: 
1:33877ab:     // major sections
1:33877ab:     private static  final   String  OVERVIEW_SECTION = "Overview";
1:33877ab:     private static  final   String  NEW_FEATURES_SECTION = "New Features";
1:33877ab:     private static  final   String  BUG_FIXES_SECTION = "Bug Fixes";
1:33877ab:     private static  final   String  ISSUES_SECTION = "Issues";
1:226c6e7:     private static  final   String  BUILD_ENVIRONMENT_SECTION = "Build Environment";
1:226c6e7:     private static  final   String  RELEASE_VERIFICATION_SECTION = "Verifying Releases";
1:286c99f: 
1:33877ab:     // headlines
1:33877ab:     private static  final   String  ANT_HEADLINE = "Ant";
1:33877ab:     private static  final   String  BRANCH_HEADLINE = "Branch";
1:33877ab:     private static  final   String  COMPILER_HEADLINE = "Compiler";
1:33877ab:     private static  final   String  JAVA6_HEADLINE = "Java 6";
1:33877ab:     private static  final   String  JDK14_HEADLINE = "JDK 1.4";
1:33877ab:     private static  final   String  MACHINE_HEADLINE = "Machine";
1:33877ab:     private static  final   String  OSGI_HEADLINE = "OSGi";
1:286c99f: 
1:33877ab:     // tags in summary xml
1:33877ab:     private static  final   String  SUM_ANT_VERSION = "antVersion";
1:33877ab:     private static  final   String  SUM_COMPILER = "compilers";
1:33877ab:     private static  final   String  SUM_JAVA6 = "java6";
1:33877ab:     private static  final   String  SUM_JDK14 = "jdk1.4";
1:33877ab:     private static  final   String  SUM_MACHINE = "machine";
1:33877ab:     private static  final   String  SUM_NEW_FEATURES = "newFeatures";
1:33877ab:     private static  final   String  SUM_OSGI = "osgi";
1:33877ab:     private static  final   String  SUM_OVERVIEW = "overview";
1:226c6e7:     private static  final   String  SUM_RELEASE_VERIFICATION = "releaseVerification";
1:286c99f: 
1:33877ab:     /////////////////////////////////////////////////////////////////////////
1:33877ab:     //
1:33877ab:     //  STATE
1:33877ab:     //
1:33877ab:     /////////////////////////////////////////////////////////////////////////
1:286c99f: 
1:d76e238:     private ReleaseNoteReader releaseNoteReader = new ReleaseNoteReader(docBldr);
1:33877ab:     // set on the command line or by ant
1:9c8b07b: 
1:38b9499:     private List<JiraIssue> missingReleaseNotes = new ArrayList<JiraIssue>();
1:286c99f: 
207:33877ab: 
1:d76e238:     public ReleaseNotesGenerator() throws Exception {
1:286c99f:     }
1:3a7cee2: 
1:4c14d1b:     /**
1:33877ab:      * Generate the release notes (for details on how to invoke this tool, see
1:33877ab:      * the header comment on this class).
1:d76e238:      * @param args command line arguments
2:d76e238:      * @throws Exception
1:4c14d1b:      */
1:d76e238:     public static void main(String[] args) throws Exception {
1:33877ab:         ReleaseNotesGenerator   me = new ReleaseNotesGenerator();
1:3a7cee2: 
1:33877ab:         me._invokedByAnt = false;
1:3a7cee2: 
1:d76e238:         if (me.parseArgs(args)) { me.execute(); }
1:d76e238:         else { me.println(USAGE); }
1:3a7cee2:     }
1:2981b19: 
1:33877ab:     /////////////////////////////////////////////////////////////////////////
1:33877ab:     //
1:33877ab:     //  ANT Task BEHAVIOR
1:33877ab:     //
1:33877ab:     /////////////////////////////////////////////////////////////////////////
1:2981b19: 
1:3a7cee2:     /**
1:33877ab:      * This is Ant's entry point into this task.
1:d76e238:      * @throws BuildException
1:4c14d1b:      */
1:d76e238:     public void execute() throws BuildException {
1:2981b19:         try {
1:d76e238:             beginOutput();
1:d76e238:             buildOverview();
1:d76e238:             buildNewFeatures();
1:e1aa9c0:             parseBugsList();
1:d76e238:             buildFixedBugsList();
1:d76e238:             buildReleaseNoteIssuesList();
1:d76e238:             buildEnvironment();
1:226c6e7:             buildReleaseVerification();
1:d76e238:             replaceVariables();
1:d76e238:             printOutput();
1:4c14d1b: 
1:d76e238:             printMissingReleaseNotes();
1:d76e238:             printErrors();
1:3a7cee2:         }
1:d76e238:         catch (Throwable t) {
1:33877ab:             t.printStackTrace();
1:2981b19: 
1:d76e238:             throw new BuildException("Error running ReleaseNotesGenerator: " +
1:d76e238:                     t.getMessage(), t);
1:3a7cee2:         }
1:2981b19:     }
1:2981b19: 
1:2981b19: 
1:33877ab:     /////////////////////////////////////////////////////////////////////////
1:33877ab:     //
1:33877ab:     //  MINIONS
1:33877ab:     //
1:33877ab:     /////////////////////////////////////////////////////////////////////////
1:286c99f: 
1:286c99f:     /**
1:d76e238:      * Start the RELEASE_NOTES html docment.
1:3a7cee2:      */
1:d76e238:     private void beginOutput() throws Exception {
1:1b5d924:         String titleText = "Release Notes for Apache Derby " + releaseID;
1:d76e238:         Element html = outputDoc.createElement(HTML);
1:d76e238:         Element title = createTextElement(outputDoc, "title", titleText);
1:d76e238:         Element body = outputDoc.createElement(BODY);
1:286c99f: 
1:4a57be6:         //
1:4a57be6:         // Set language attribute for accessibility reasons.
1:4a57be6:         // See http://www.w3.org/TR/WCAG10/#gl-abbreviated-and-foreign
1:4a57be6:         //
1:4a57be6:         html.setAttribute( "lang", "en" );
1:4a57be6: 
1:d76e238:         outputDoc.appendChild(html);
1:d76e238:         html.appendChild(title);
1:d76e238:         html.appendChild(body);
1:286c99f: 
1:d76e238:         Element bannerBlock = createHeader(body, BANNER_LEVEL, titleText);
1:d76e238:         buildDelta(bannerBlock);
1:286c99f: 
1:d76e238:         Element toc = createList(body);
1:286c99f: 
1:d76e238:         createSection(body, MAIN_SECTION_LEVEL, toc,
1:d76e238:                 OVERVIEW_SECTION, OVERVIEW_SECTION);
1:d76e238:         createSection(body, MAIN_SECTION_LEVEL, toc,
1:d76e238:                 NEW_FEATURES_SECTION, NEW_FEATURES_SECTION);
1:d76e238:         createSection(body, MAIN_SECTION_LEVEL, toc,
1:d76e238:                 BUG_FIXES_SECTION, BUG_FIXES_SECTION);
1:d76e238:         createSection(body, MAIN_SECTION_LEVEL, toc,
1:d76e238:                 ISSUES_SECTION, ISSUES_SECTION);
1:d76e238:         createSection(body, MAIN_SECTION_LEVEL, toc,
1:d76e238:                 BUILD_ENVIRONMENT_SECTION, BUILD_ENVIRONMENT_SECTION);
1:226c6e7:         createSection(body, MAIN_SECTION_LEVEL, toc,
1:226c6e7:                 RELEASE_VERIFICATION_SECTION, RELEASE_VERIFICATION_SECTION);
1:2981b19:     }
1:286c99f: 
1:286c99f: 
1:226c6e7:     //////////////////////////////////
1:226c6e7:     //
1:33877ab:     //  Overview SECTION
1:3a7cee2:     //
1:3a7cee2:     //////////////////////////////////
1:3a7cee2: 
1:3a7cee2:     /**
2:33877ab:      * Build the Overview section.
1:3a7cee2:      */
1:d76e238:     private void buildOverview() throws Exception {
1:33877ab:         // copy the details out of the summary file into the overview section
1:d76e238:         cloneChildren(summary.getElementByTagName(SUM_OVERVIEW),
1:d76e238:                 getSection(outputDoc, MAIN_SECTION_LEVEL, OVERVIEW_SECTION));
1:3a7cee2:     }
1:3a7cee2: 
1:3a7cee2:     //////////////////////////////////
1:3a7cee2:     //
1:33877ab:     //  New Features SECTION
1:33877ab:     //
9:33877ab:     //////////////////////////////////
1:286c99f: 
1:286c99f:     /**
1:33877ab:      * Build the New Features section.
1:286c99f:      */
1:d76e238:     private void buildNewFeatures() throws Exception {
1:33877ab:         // copy the details out of the summary file into the overview section
1:d76e238:         cloneChildren(summary.getElementByTagName(SUM_NEW_FEATURES),
1:d76e238:                 getSection(outputDoc, MAIN_SECTION_LEVEL,
1:d76e238:                 NEW_FEATURES_SECTION));
1:2981b19:     }
1:286c99f: 
1:33877ab:     //////////////////////////////////
1:33877ab:     //
1:33877ab:     //  Bug List SECTION
1:33877ab:     //
1:33877ab:     //////////////////////////////////
1:286c99f: 
1:e1aa9c0:     private void parseBugsList()
1:e1aa9c0:             throws Exception {
1:e1aa9c0:         bugList = JiraIssue.createJiraIssueList(bugListFileName);
1:e1aa9c0:         // Parse the file for the release version and the previous version to
1:e1aa9c0:         // carry out sanity checks.
1:e1aa9c0:         BufferedReader in = new BufferedReader(new InputStreamReader(
1:e1aa9c0:                 new FileInputStream(bugListFileName), "UTF-8"));
1:e1aa9c0:         String line;
1:e1aa9c0:         String prevVer = null;
1:e1aa9c0:         while ((line = in.readLine()) != null) {
1:e1aa9c0:             if (line.startsWith("// Previous release:")) {
1:e1aa9c0:                 prevVer = line.split(":")[1].trim();
1:e1aa9c0:                 break;
1:2981b19:             }
1:286c99f:         }
1:e1aa9c0:         in.close();
1:e1aa9c0:         if (prevVer == null) {
1:e1aa9c0:             System.out.println(
1:e1aa9c0:                     "WARNING: Skipped previous release version sanity check.");
1:e1aa9c0:         } else if (!prevVer.equals(previousReleaseID)) {
1:e1aa9c0:             throw new IllegalStateException("previous release version " +
1:e1aa9c0:                     "mismatch between releaseSummary.xml and bug list: " +
1:e1aa9c0:                     previousReleaseID + " != " + prevVer);
1:286c99f:         }
3:286c99f:     }
1:286c99f: 
1:286c99f:     /**
1:33877ab:      * Build the Bug List section.
1:d76e238:      * @param gs state
1:286c99f:      */
1:d76e238:     private void buildFixedBugsList()
2:a38484c:         throws Exception
1:9c8b07b:     {
1:d76e238:         Element bugListSection = getSection(outputDoc, MAIN_SECTION_LEVEL,
1:d76e238:                 BUG_FIXES_SECTION );
1:a38484c: 
1:d76e238:         String deltaStatement =
1:33877ab:             "The following issues are addressed by Derby release " + releaseID +
1:d76e238:             ". These issues are not addressed in the preceding " +
1:d76e238:             previousReleaseID + " release.";
1:a38484c: 
1:d76e238:         addParagraph(bugListSection, deltaStatement);
1:a38484c: 
1:d76e238:         Element table = createTable
1:d76e238:             (bugListSection, DEFAULT_TABLE_BORDER_WIDTH,
1:d76e238:             new String[] { ISSUE_ID_HEADLINE, DESCRIPTION_HEADLINE });
1:086e817:         // If we don't fix the width of the first column, the string
1:086e817:         // "DERBY-XXXX" is often broken up at the hyphen by some browsers.
1:086e817:         fixWidthOfFirstColumn(table);
1:9c8b07b: 
1:e1aa9c0:         for ( Iterator i=bugList.iterator(); i.hasNext(); ) {
1:d76e238:             JiraIssue issue = (JiraIssue) i.next();
1:8b2e4e7:             //println("Fixed: "+ issue.getKey());
1:d76e238:             Element row = insertRow(table);
1:d76e238:             Element linkColumn = insertColumn(row);
1:d76e238:             Element descriptionColumn = insertColumn(row);
1:d76e238:             Element hotlink = createLink(outputDoc, issue.getJiraAddress(),
1:9c8b07b:                     "DERBY-" + issue.getKey());
1:d76e238:             Text title = outputDoc.createTextNode(issue.getTitle());
1:a38484c: 
1:d76e238:             linkColumn.appendChild(hotlink);
1:d76e238:             descriptionColumn.appendChild(title);
1:a38484c:         }
1:a38484c:     }
1:a38484c: 
1:33877ab:     //////////////////////////////////
1:33877ab:     //
1:33877ab:     //  Issues SECTION
1:33877ab:     //
1:33877ab:     //////////////////////////////////
1:a38484c: 
1:a38484c:     /**
1:33877ab:      * Build the Issues section.
1:a38484c:      */
1:d76e238:     private void buildReleaseNoteIssuesList()
1:d76e238:         throws Exception {
1:d76e238:         Element issuesSection = getSection(outputDoc, MAIN_SECTION_LEVEL,
1:d76e238:                 ISSUES_SECTION);
1:d76e238:         String deltaStatement =
1:33877ab:             "Compared with the previous release (" + previousReleaseID +
1:d76e238:             "), Derby release " + releaseID + " introduces the following " +
1:d76e238:             "new features " +
1:33877ab:             "and incompatibilities. These merit your special attention.";
1:a38484c: 
1:d76e238:         addParagraph(issuesSection, deltaStatement);
1:d76e238:         Element toc = createList(issuesSection);
1:9c8b07b: 
1:e1aa9c0:         for (Iterator i=bugList.iterator(); i.hasNext(); ) {
1:d76e238:             JiraIssue issue = (JiraIssue) i.next();
1:d76e238:             if (issue.hasReleaseNote()) {
1:d76e238:                 Node summaryText = null;
1:d76e238:                 Element details = null;
1:a38484c:                 try {
1:d76e238:                     URL url = new URL(issue.getReleaseNoteAddress());
1:d76e238:                     InputStream is = url.openStream();
1:d76e238:                     Document releaseNote = releaseNoteReader.getReleaseNote(is);
1:d76e238:                     summaryText = releaseNoteReader.
1:d76e238:                             getReleaseNoteSummary(releaseNote);
1:d76e238:                     details = releaseNoteReader.
1:d76e238:                             getReleaseNoteDetails(releaseNote);
1:d76e238:                 } catch (Throwable t) {
1:d76e238:                     errors.add(formatError("Unable to read or parse " +
1:9c8b07b:                             "release note for DERBY-" +
1:d76e238:                             issue.getKey(), t));
1:d76e238:                     missingReleaseNotes.add(issue);
1:286c99f:                     continue;
1:a38484c:                 }
1:a38484c: 
1:9c8b07b:                 String key = "Note for DERBY-" + issue.getKey();
1:0bd3280:                 //println("Release note: "+issue.getKey()+" - "+issue.getTitle());
1:80e6765:                 Element paragraph = outputDoc.createElement(SPAN);
1:d76e238:                 paragraph.appendChild(outputDoc.createTextNode(key + ": "));
1:d76e238:                 cloneChildren(summaryText, paragraph);
1:d76e238:                 insertLine(issuesSection);
1:d76e238:                 Element issueSection = createSection(issuesSection,
1:d76e238:                         ISSUE_DETAIL_LEVEL, toc, key, paragraph);
1:d76e238:                 cloneChildren(details, issueSection);
1:e1aa9c0:             } else if (issue.hasMissingReleaseNote()) {
1:e1aa9c0:                 missingReleaseNotes.add(issue);
1:a38484c:             }
1:a38484c:         }
1:a38484c:     }
1:a38484c: 
1:33877ab:     //////////////////////////////////
1:33877ab:     //
1:33877ab:     //  Build Environment SECTION
1:33877ab:     //
1:33877ab:     //////////////////////////////////
1:a38484c: 
1:a38484c:     /**
1:33877ab:      * Build the section describing the build environment.
1:a38484c:      */
1:d76e238:     private void buildEnvironment()
1:d76e238:         throws Exception {
1:d76e238:         Element environmentSection = getSection(outputDoc, MAIN_SECTION_LEVEL,
1:d76e238:                 BUILD_ENVIRONMENT_SECTION );
1:a38484c: 
1:d76e238:         String desc = "Derby release " + releaseID +
1:d76e238:                 " was built using the following environment:";
1:a38484c: 
1:d76e238:         addParagraph(environmentSection, desc);
1:d76e238:         Element list = createList(environmentSection);
1:a38484c: 
1:d76e238:         addHeadlinedItem(list, BRANCH_HEADLINE,
1:d76e238:                 "Source code came from the " + branch + " branch.");
1:a38484c: 
1:d76e238:         addHeadlinedItem(list, MACHINE_HEADLINE,
1:d76e238:                 summary.getTextByTagName(SUM_MACHINE));
1:a38484c: 
1:d76e238:         addHeadlinedItem(list, ANT_HEADLINE,
1:d76e238:                 summary.getTextByTagName(SUM_ANT_VERSION));
1:a38484c: 
1:d76e238:         addHeadlinedItem(list, COMPILER_HEADLINE,
1:d76e238:                 summary.getTextByTagName(SUM_COMPILER));
1:a38484c:     }
1:a38484c: 
1:33877ab:     //////////////////////////////////
1:33877ab:     //
1:226c6e7:     //  Release Verification SECTION
1:226c6e7:     //
1:226c6e7:     //////////////////////////////////
1:226c6e7: 
1:226c6e7:     /**
1:226c6e7:      * Build the Release Verification section.
1:226c6e7:      */
1:226c6e7:     private void buildReleaseVerification() throws Exception {
1:226c6e7:         // copy the details out of the summary file into the release verification section
1:226c6e7:         cloneChildren(summary.getElementByTagName(SUM_RELEASE_VERIFICATION),
1:226c6e7:                 getSection(outputDoc, MAIN_SECTION_LEVEL, RELEASE_VERIFICATION_SECTION));
1:226c6e7:     }
1:226c6e7: 
1:4c14d1b: 
1:33877ab:     //////////////////////////////////
1:33877ab:     //
1:286c99f:     //  Print errors
1:33877ab:     //
1:33877ab:     //////////////////////////////////
1:4c14d1b: 
1:4c14d1b:     /**
1:286c99f:      * Print missing release notes
1:a38484c:      */
1:d76e238:     private void printMissingReleaseNotes() throws Exception {
1:d76e238:         if (missingReleaseNotes.isEmpty()) {
1:d76e238:             return;
1:4c14d1b:         }
1:d76e238:         println("The following JIRA issues still need release notes or the " +
1:d76e238:                 "release notes provided are unreadable:");
1:4c14d1b: 
1:d76e238:         for (Iterator i = missingReleaseNotes.iterator(); i.hasNext();) {
1:d76e238:             JiraIssue issue = (JiraIssue) i.next();
1:d76e238:             println("\t" + issue.getKey() + "\t" + issue.getTitle());
1:4c14d1b:         }
1:4c14d1b:     }
1:4c14d1b: 
1:3a7cee2: 
1:33877ab:     //////////////////////////////////
1:33877ab:     //
1:33877ab:     //  ARGUMENT MINIONS
1:33877ab:     //
1:33877ab:     //////////////////////////////////
1:3a7cee2: 
1:4c14d1b:     /**
1:33877ab:      * Returns true if arguments parse successfully, false otherwise.
1:4c14d1b:      */
1:33877ab:     private boolean    parseArgs( String[] args )
1:a38484c:         throws Exception
1:9c8b07b:     {
1:f5868b5:         if ( (args == null) || (args.length != 3) ) { return false; }
1:3a7cee2: 
1:33877ab:         int     idx = 0;
1:3a7cee2: 
1:33877ab:         setSummaryFileName( args[ idx++ ] );
1:33877ab:         setBugListFileName( args[ idx++ ] );
1:d76e238:         setOutputFileName( args[ idx++ ] );
1:3a7cee2: 
1:33877ab:         return true;
1:3a7cee2:     }
1:3a7cee2: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:c52bd60
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:64635d6
/////////////////////////////////////////////////////////////////////////
commit:4a57be6
/////////////////////////////////////////////////////////////////////////
1:         //
1:         // Set language attribute for accessibility reasons.
1:         // See http://www.w3.org/TR/WCAG10/#gl-abbreviated-and-foreign
1:         //
1:         html.setAttribute( "lang", "en" );
1: 
commit:1b5d924
/////////////////////////////////////////////////////////////////////////
1:         String titleText = "Release Notes for Apache Derby " + releaseID;
commit:226c6e7
/////////////////////////////////////////////////////////////////////////
1:     private static  final   String  BUILD_ENVIRONMENT_SECTION = "Build Environment";
1:     private static  final   String  RELEASE_VERIFICATION_SECTION = "Verifying Releases";
/////////////////////////////////////////////////////////////////////////
1:     private static  final   String  SUM_RELEASE_VERIFICATION = "releaseVerification";
/////////////////////////////////////////////////////////////////////////
1:             buildReleaseVerification();
/////////////////////////////////////////////////////////////////////////
1:         createSection(body, MAIN_SECTION_LEVEL, toc,
1:                 RELEASE_VERIFICATION_SECTION, RELEASE_VERIFICATION_SECTION);
/////////////////////////////////////////////////////////////////////////
1:     //////////////////////////////////
1:     //
1:     //  Release Verification SECTION
1:     //
1:     //////////////////////////////////
1: 
1:     /**
1:      * Build the Release Verification section.
1:      */
1:     private void buildReleaseVerification() throws Exception {
1:         // copy the details out of the summary file into the release verification section
1:         cloneChildren(summary.getElementByTagName(SUM_RELEASE_VERIFICATION),
1:                 getSection(outputDoc, MAIN_SECTION_LEVEL, RELEASE_VERIFICATION_SECTION));
1:     }
1: 
commit:9c8b07b
/////////////////////////////////////////////////////////////////////////
0:     private ReportParser reportParser = ReportParser.makeReportParser();
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         bugListDoc.reset();
1:         
0:         for ( Iterator i = JiraIssue.createJiraIssueList( bugListDoc, excludeReleaseIDList, reportParser ).iterator(); i.hasNext(); )
1:         {
1:                     "DERBY-" + issue.getKey());
/////////////////////////////////////////////////////////////////////////
0:         bugListDoc.reset();
1:         
0:         for ( Iterator i = JiraIssue.createJiraIssueList( bugListDoc, excludeReleaseIDList, reportParser ).iterator(); i.hasNext(); )
1:         {
/////////////////////////////////////////////////////////////////////////
1:                             "release note for DERBY-" +
1:                 String key = "Note for DERBY-" + issue.getKey();
/////////////////////////////////////////////////////////////////////////
commit:0bd3280
/////////////////////////////////////////////////////////////////////////
1:                 //println("Release note: "+issue.getKey()+" - "+issue.getTitle());
commit:8b2e4e7
/////////////////////////////////////////////////////////////////////////
1:             //println("Fixed: "+ issue.getKey());
commit:0123797
/////////////////////////////////////////////////////////////////////////
1: 
0:             // skip attachments that aren't release notes
0:             if ( !attachmentAddress.endsWith( RELEASE_NOTE_NAME ) ) { continue; }
1: 
commit:a38484c
/////////////////////////////////////////////////////////////////////////
1:  *
1:  * <p>
0:  * The format of the html reports changes over time. You may need to adjust this
0:  * tool for each release.
1:  * </p>
1:  *
/////////////////////////////////////////////////////////////////////////
0:         "key and title information for each Derby issue. For each\n" +
0:         "attachments clipped to that issue and grabs the latest reported\n" +
0:         "In order to parse the xml files, you may need to remove the\n" +
0:         "introductory DOCTYPE preamble because it refers to a DTD which does\n" +
0:         "not live in your local file system.\n" +
1:         "\n" +
/////////////////////////////////////////////////////////////////////////
0:     private static  final   String  JIRA_ITEM = "h3";
1: 
0:     // positioning strings inside a JIRA
0:     private static  final   String  ATTACHMENT_START = "/jira/secure/attachment/";
0:     private static  final   String  ATTACHMENT_VERSION_END = "/";
0:     private static  final   String  ATTACHMENT_END = "\"";
0:     private static  final   String  ATTACHMENT_PREFIX = "https://issues.apache.org";
/////////////////////////////////////////////////////////////////////////
0:              String title
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         // first get the issue
0:         InputStream issueStream = grabDocument( gs, issue.getJiraAddress() );
0:         if ( issueStream == null ) { return null; }
1:         
0:         String          issueDocument = readJira( issueStream );
0:         String          releaseNoteAddress = getReleaseNoteAddress( issueDocument );
0:         InputStream releaseNoteStream = grabDocument( gs, releaseNoteAddress );
0:         if ( releaseNoteStream == null ) { return null; }
0:         Document        releaseNoteDoc = gs.getReleaseNoteReader().getReleaseNote( releaseNoteStream );
0:         return releaseNoteDoc;
1:     }
1:     /**
1:      * <p>
0:      * We don't even bother trying to parse an individual jira since it is html
0:      * and not likely to be syntactically correct xml. We just siphon the jira
0:      * into a big string.
1:      * </p>
1:      */
0:     private String  readJira( InputStream is )
1:         throws Exception
0:     {
0:         InputStreamReader   isr = new InputStreamReader( is, "UTF-8" );
0:         LineNumberReader    lr = new LineNumberReader( isr );
0:         StringBuffer            buffer = new StringBuffer();
1: 
0:         while( true )
0:         {
0:             String  nextLine = lr.readLine();
1: 
0:             if ( nextLine == null ) { break; }
0:             else { buffer.append( nextLine ); }
1: 
0:         lr.close();
0:         isr.close();
0:         is.close();
1: 
0:         String  result = buffer.toString();
1: 
0:         return result;
1:     }
1:     
1:     /**
1:      * <p>
0:      * Loop through the attachment pointers in a JIRA, looking for the highest
0:      * numbered release note.
1:      * </p>
1:      */
0:     private String  getReleaseNoteAddress( String jira )
1:         throws Exception
0:     {
0:         long    highestReleaseNoteVersion = 0;
0:         String  releaseNoteAddress = null;
0:         int         idx = 0;
1: 
0:         while ( true )
0:         {
0:             int start = jira.indexOf( ATTACHMENT_START, idx );
0:             if ( start < 0 ) { break; }
0:             int end = jira.indexOf( ATTACHMENT_END, start );
0:             if ( end < 0 ) { break; }
1: 
0:             idx = end;
1: 
0:             String  attachmentAddress = jira.substring( start, end );
0:             int         versionNumberStart = ATTACHMENT_START.length();
0:             int         versionNumberEnd = attachmentAddress.indexOf( ATTACHMENT_VERSION_END, versionNumberStart );
0:             String  versionString = attachmentAddress.substring( versionNumberStart, versionNumberEnd );
0:             long    versionNumber = Long.parseLong( versionString);
1: 
0:             if ( versionNumber >= highestReleaseNoteVersion)
0:             {
0:                 highestReleaseNoteVersion = versionNumber;
0:                 releaseNoteAddress = ATTACHMENT_PREFIX + attachmentAddress;
1:             }
1:         }
1: 
0:         System.out.println( "Found release note address: " + releaseNoteAddress );
1: 
0:         return releaseNoteAddress;
1:     }
1:     
1:     /**
1:      * <p>
0:      * Grab a document off the web.
1:      * </p>
1:      */
0:     private InputStream   grabDocument( GeneratorState gs, String urlString )
1:         throws Exception
0:     {
0:         // first get the issue
0:         URL             url = null;
0:         InputStream is = null;
1:             
1:         try {
0:             url = new URL( urlString );
0:             is = url.openStream();
1: 
0:             return is;
1:         }
0:         catch (Throwable t)
0:         {
0:             processThrowable( t );
0:             return null;
1:         }
/////////////////////////////////////////////////////////////////////////
0:         // the text lives in an anchor
0:         Element anchorElement = getFirstChild( itemElement, ANCHOR );
0:         String  contents = squeezeText( anchorElement );
1: 
0:         String  key = parseKey( contents );
0:         String  title;
/////////////////////////////////////////////////////////////////////////
0:         title = contents.substring( contents.indexOf( ']' ) + 2, contents.length() );        
0:         return new JiraIssue( key, title );
0:      * Parse a string, looking for an id of the form "[DERBY-2598]". Extract the
0:      * bit between the brackets.
0:     private String parseKey( String raw )
0:         int  start = raw.indexOf( '[' );
0:         int  end = raw.indexOf( ']' );
0:         return raw.substring( start + 1, end );
1: 
commit:4c14d1b
/////////////////////////////////////////////////////////////////////////
0:         createSection( body, MAIN_SECTION_LEVEL, toc, OVERVIEW_SECTION, OVERVIEW_SECTION );
0:         createSection( body, MAIN_SECTION_LEVEL, toc, NEW_FEATURES_SECTION, NEW_FEATURES_SECTION );
0:         createSection( body, MAIN_SECTION_LEVEL, toc, BUG_FIXES_SECTION, BUG_FIXES_SECTION );
0:         createSection( body, MAIN_SECTION_LEVEL, toc, ISSUES_SECTION, ISSUES_SECTION );
0:         createSection( body, MAIN_SECTION_LEVEL, toc, BUILD_ENVIRONMENT_SECTION, BUILD_ENVIRONMENT_SECTION );
/////////////////////////////////////////////////////////////////////////
0:             Node     summaryText = null;
0:                 summaryText = releaseNoteReader.getReleaseNoteSummary( releaseNote );
0:                 summaryText = pamphlet.createTextNode( "Unreadable summary line" );
0:             Element         paragraph = pamphlet.createElement( PARAGRAPH );
1: 
0:             paragraph.appendChild(  pamphlet.createTextNode( key + ": ") );
0:             cloneChildren( summaryText, paragraph );
0:             Element     issueSection = createSection( issuesSection, ISSUE_DETAIL_LEVEL, toc, key, paragraph );
/////////////////////////////////////////////////////////////////////////
0:         Text                textNode = doc.createTextNode( tocEntry );
1: 
0:         return createSection( parent, sectionLevel, toc, sectionName, textNode );
1:     }
1:     
1:     /**
0:      * <p>
0:      * Create a section at the end of a parent element and link to it from a
0:      * table of contents.
0:      * </p>
1:      */
0:     private Element createSection( Element parent, int sectionLevel, Element toc, String sectionName, Node visibleText )
0:         throws Exception
0:     {
0:         Document        doc = parent.getOwnerDocument();
0:         Element             link = createLocalLink( doc, sectionName, visibleText );
/////////////////////////////////////////////////////////////////////////
0:         Text        textNode = doc.createTextNode( text );
1: 
0:         return createLocalLink( doc, anchor, textNode );
1:     }
1:     
1:     /**
0:      * <p>
0:      * Create a standard link to a local label.
0:      * </p>
1:      */
0:     private Element createLocalLink( Document doc, String anchor, Node visibleText )
0:         throws Exception
0:     {
0:         return createLink( doc, "#" + anchor, visibleText );
/////////////////////////////////////////////////////////////////////////
0:         return createLink( doc, label, textNode );
1:     }
1:     
1:     /**
0:      * <p>
0:      * Create a hotlink.
0:      * </p>
1:      */
0:     private Element createLink( Document doc, String label, Node visibleText )
0:         throws Exception
0:     {
0:         Element hotlink = doc.createElement( ANCHOR );
1: 
0:         hotlink.appendChild( visibleText );
/////////////////////////////////////////////////////////////////////////
0:     private void cloneChildren( Node source, Node target )
commit:3a7cee2
/////////////////////////////////////////////////////////////////////////
0:             replaceVariables( gs );
/////////////////////////////////////////////////////////////////////////
1:     //////////////////////////////////
1:     //
0:     //  REPLACE VARIABLES
1:     //
1:     //////////////////////////////////
1: 
1:     /**
0:      * <p>
0:      * Replace the known parameters with their corresponding text values.
0:      * </p>
1:      */
0:     private void replaceVariables( GeneratorState gs )
0:         throws Exception
0:     {
0:         Document    pamphlet = gs.getPamphlet();
1: 
0:         replaceTag( pamphlet, SUM_RELEASE_ID, getReleaseID( gs ) );
0:         replaceTag( pamphlet, SUM_PREVIOUS_RELEASE_ID, getPreviousReleaseID( gs ) );
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * <p>
0:      * Replace all instances of the tag with the indicated text.
0:      * </p>
1:      */
0:     private void replaceTag( Document doc, String tag, String replacementText )
0:         throws Exception
0:     {
0:         NodeList        sourceChildren = doc.getElementsByTagName( tag );
0:         int                 count = sourceChildren.getLength();
1: 
0:         for ( int i = 0; i < count; i++ )
0:         {
0:             Node    oldChild = sourceChildren.item( i );
0:             Node    newChild = doc.createTextNode( replacementText );
1: 
0:             if ( oldChild != null )
0:             {
0:                 Node    parent = oldChild.getParentNode();
1:             
0:                 if ( parent != null ) { parent.insertBefore( newChild, oldChild ); }
1:             }
1:         }
1: 
0:         for ( int i = count-1; i > -1; i-- )
0:         {
0:             Node    oldChild = sourceChildren.item( i );
1: 
0:             if ( oldChild != null )
0:             {
0:                 Node    parent = oldChild.getParentNode();
1:             
0:                 if ( parent != null ) { parent.removeChild( oldChild ); }
1:             }
1:         }
1:     }
1: 
commit:2981b19
/////////////////////////////////////////////////////////////////////////
0:         private ReleaseNoteReader   _releaseNoteReader;
/////////////////////////////////////////////////////////////////////////
1: 
0:             _releaseNoteReader = new ReleaseNoteReader( documentBuilder );
/////////////////////////////////////////////////////////////////////////
0:         public  ReleaseNoteReader   getReleaseNoteReader() { return _releaseNoteReader; }
/////////////////////////////////////////////////////////////////////////
0:         ReleaseNoteReader   releaseNoteReader = gs.getReleaseNoteReader();
/////////////////////////////////////////////////////////////////////////
0:             Document    releaseNote = null;
1: 
1:             try {
0:                 releaseNote = getReleaseNote( gs, issue );
1:             }
0:             catch (Throwable t)
0:             {
0:                 gs.addError( formatError( "Unable to read or parse release note for " + issue.getKey(), t ) );
1:             }
/////////////////////////////////////////////////////////////////////////
0:             String          summary = null;
1: 
0:             try {
0:                 summary = releaseNoteReader.getReleaseNoteSummary( releaseNote );
1:             }
0:             catch (Throwable t)
0:             {
0:                 gs.addError( formatError( "Badly formatted summary for " + issue.getKey(), t ) );
0:                 summary = "Unreadable summary line";
1:             }
1:             
/////////////////////////////////////////////////////////////////////////
0:                 Element     details = releaseNoteReader.getReleaseNoteDetails( releaseNote );
/////////////////////////////////////////////////////////////////////////
1:     
/////////////////////////////////////////////////////////////////////////
0:             URL             url = null;
0:             InputStream is = null;
1:             
0:                 url = new URL( issue.getReleaseNoteAddress() );
0:                 is = url.openStream();
0:                 processThrowable( t );
0:                 return null;
1: 
0:             Document        doc = gs.getReleaseNoteReader().getReleaseNote( is );
1: 
0:             return doc;
0:         else { return null; }
commit:286c99f
/////////////////////////////////////////////////////////////////////////
0:         private ArrayList       _errors;
/////////////////////////////////////////////////////////////////////////
0:             _errors = new ArrayList();
/////////////////////////////////////////////////////////////////////////
0:         public  void    addError( String message )
0:         {
0:             _errors.add( message );
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
0:         public  String[]     getErrors()
0:         {
0:             String[]        squeezed = new String[ _errors.size() ];
1: 
0:             _errors.toArray( squeezed );
1: 
0:             return squeezed;
1:         }
/////////////////////////////////////////////////////////////////////////
0:             printErrors( gs );
/////////////////////////////////////////////////////////////////////////
1:             
1: 
0:             // skip this note if we were unable to read it
0:             if ( releaseNote == null )
0:             {
0:                 gs.addMissingReleaseNote( issue );
1:                 continue;
1:             }
1:             
0:             String          summary = getReleaseNoteSummary( gs, issue, releaseNote );
0:             try {
/////////////////////////////////////////////////////////////////////////
0:             catch (Throwable t)
0:                 gs.addError( formatError( "Could not read required sections out of issue " + issue.getKey(), t ) );
/////////////////////////////////////////////////////////////////////////
1: 
0:                 gs.addError( formatError( "Unable to read or parse release note for " + issue.getKey(), e ) );
1: 
0:                 return null;
/////////////////////////////////////////////////////////////////////////
0:     private String   getReleaseNoteSummary( GeneratorState gs, JiraIssue issue, Document releaseNote )
/////////////////////////////////////////////////////////////////////////
0:                 gs.addError( formatError( "Badly formatted summary for " + issue.getKey(), t ) );
0:                 return "Unreadable summary line";
/////////////////////////////////////////////////////////////////////////
1:     //  Print errors
1:      * Print missing release notes
/////////////////////////////////////////////////////////////////////////
0:             println( "The following JIRA issues still need release notes or the release notes provided are unreadable:" );
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * <p>
0:      * Print errors.
0:      * </p>
1:      */
0:     private void printErrors( GeneratorState gs )
0:         throws Exception
0:     {
0:         String[]     errors = gs.getErrors();
0:         int                 count = errors.length;
1: 
0:         if ( count > 0 )
0:         {
0:             println( "The following other errors occurred:" );
1: 
0:             for ( int i = 0; i < count; i++ )
0:             {
0:                 String  error = errors[ i ];
1:                 
0:                 println( "\n" + error );
1:             }
1:         }
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * <p>
0:      * Format an error for later reporting.
0:      * </p>
1:      */
0:     private  String    formatError( String text, Throwable t )
0:     {
0:         text = text + ": " + t.toString() + "\n" + stringifyStackTrace( t );
1: 
0:         return text;
0:     }
1: 
1:     /**
0:      * <p>
0:      * Print a stack trace as a string.
0:      * </p>
1:      */
0:     private  String stringifyStackTrace( Throwable t )
0:     {
0:         StringWriter    sw = new StringWriter();
0:         PrintWriter     pw = new PrintWriter( sw, true );
1: 
0:         t.printStackTrace( pw );
0:         pw.flush();
0:         sw.flush();
1: 
0:         return sw.toString();        
0:     }
1: 
0:      ////////////////////////////////////////////////////////
commit:994a295
/////////////////////////////////////////////////////////////////////////
0:             String          summary = getReleaseNoteSummary( issue, releaseNote );
/////////////////////////////////////////////////////////////////////////
0:     private String   getReleaseNoteSummary( JiraIssue issue, Document releaseNote )
/////////////////////////////////////////////////////////////////////////
0:             try {
0:                 Element     root = releaseNote.getDocumentElement();
0:                 Element     summaryParagraph = getFirstChild( root, PARAGRAPH );
0:                 String          summaryText = squeezeText( summaryParagraph );
0:                 return summaryText;
0:             }
0:             catch (Throwable t)
0:             {
0:                 throw new BuildException
0:                     ( "Badly formatted summary for " + issue.getKey() + ": " + t.toString(), t );
0:             }
commit:33877ab
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derbyBuild.ReleaseNotesGenerator
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derbyBuild;
1: 
1: import java.io.*;
1: import java.net.URL;
0: import java.util.ArrayList;
0: import javax.xml.parsers.*;
0: import javax.xml.transform.*;
0: import javax.xml.transform.dom.*;
0: import javax.xml.transform.stream.*;
1: import org.w3c.dom.*;
1: 
1: import org.apache.tools.ant.BuildException;
0: import org.apache.tools.ant.Project;
0: import org.apache.tools.ant.Task;
0: import org.apache.tools.ant.taskdefs.Echo;
1: 
0: /**
0:  * <p>
1:  * This tool generates Release Notes for a Derby release. See the USAGE
1:  * constant for details on how to run this tool standalone. It is recommended
0:  * that you freshly regenerate your BUG_LIST and NOTES_LIST just before
0:  * you run this tool.
0:  * </p>
0:  *
0:  * <p>
0:  * The tool is designed to be run from Derby's ant build scripts. To run under
0:  * ant, do the following:
0:  * </p>
0:  *
1:  * <ul>
0:  * <li>Define the "relnotes.src.reports" variable in your ant.properties. This
0:  * variable points at the directory which holds your xml JIRA reports.</li>
0:  * <li>Put your xml JIRA reports in that directory. They should have the
0:  * following names:
0:  *  <ul>
0:  *  <li>fixedBugsList.xml - This is the list of issues addressed by the release.</li>
0:  *  <li>releaseNotesList.xml - This is the list of issues which have detailed
0:  *  release notes.</li>
0:  *  </ul>
0:  * </li>
0:  * <li>Then cd to tools/release and run ant thusly: "ant genrelnotes"</li>
1:  * </ul>
0:  *
0:  * <p>For more information on this tool, please see the JIRA which introduced it:
0:  * </p>
0:  *
0:  * <p>
0:  * <a href="http://issues.apache.org/jira/browse/DERBY-2570">DERBY-2570</a>
0:  * </p>
1:  */
0: public class ReleaseNotesGenerator extends Task
0: {
1:     /////////////////////////////////////////////////////////////////////////
1:     //
1:     //  CONSTANTS
1:     //
1:     /////////////////////////////////////////////////////////////////////////
1:     
1:     private static  final   String  USAGE =
1:         "Usage:\n" +
1:         "\n" +
0:         "  java org.apache.derbyBuild.ReleaseNotesGenerator SUMMARY BUG_LIST NOTES_LIST OUTPUT_PAMPHLET\n" +
1:         "\n" +
1:         "    where\n" +
1:         "                  SUMMARY                    Summary, a filled-in copy of releaseSummaryTemplate.xml.\n" +
0:         "                  BUG_LIST                     An xml JIRA report of issues addressed by this release.\n" +
0:         "                  NOTES_LIST                An xml JIRA report listing issues which have detailed releaseNotes.html attachments.\n" +
1:         "                  OUTPUT_PAMPHLET  The output file to generate, typically RELEASE-NOTES.html.\n" +
1:         "\n" +
1:         "The ReleaseNoteGenerator attempts to connect to issues.apache.org in\n" +
1:         "order to read the detailed release notes that have been clipped to\n" +
1:         "individual JIRAs. Before running this program, make sure that you can\n" +
1:         "ping issues.apache.org.\n" +
1:         "\n" +
0:         "The ReleaseNoteGenerator assumes that the two JIRA reports contain\n" +
0:         "key, title, and attachments elements for each Derby issue. For each\n" +
0:         "issue in NOTES_LIST, the ReleaseNotesGenerator looks through the\n" +
0:         "attachments block in that report and grabs the latest reported\n" +
0:         "releaseNote.html.\n" +
1:         "\n" +
1:         "For this reason, it is recommended that you freshly generate BUG_LIST\n" +
0:         "and NOTES_LIST just before you run this tool.\n"
1:         ;
1: 
0:     // header levels
0:     private static  final   int     BANNER_LEVEL = 1;
0:     private static  final   int     MAIN_SECTION_LEVEL = BANNER_LEVEL + 1;
0:     private static  final   int     ISSUE_DETAIL_LEVEL = MAIN_SECTION_LEVEL + 1;
1:     
1:     // major sections
1:     private static  final   String  OVERVIEW_SECTION = "Overview";
1:     private static  final   String  NEW_FEATURES_SECTION = "New Features";
1:     private static  final   String  BUG_FIXES_SECTION = "Bug Fixes";
1:     private static  final   String  ISSUES_SECTION = "Issues";
0:     private static  final   String  BUILD_ENVIRONMENT_SECTION = "Build Environment";
1: 
1:     // headlines
1:     private static  final   String  ANT_HEADLINE = "Ant";
1:     private static  final   String  BRANCH_HEADLINE = "Branch";
1:     private static  final   String  COMPILER_HEADLINE = "Compiler";
0:     private static  final   String  DESCRIPTION_HEADLINE = "Description";
0:     private static  final   String  ISSUE_ID_HEADLINE = "Issue Id";
1:     private static  final   String  JAVA6_HEADLINE = "Java 6";
1:     private static  final   String  JDK14_HEADLINE = "JDK 1.4";
0:     private static  final   String  JSR169_HEADLINE = "JSR 169";
1:     private static  final   String  MACHINE_HEADLINE = "Machine";
1:     private static  final   String  OSGI_HEADLINE = "OSGi";
1: 
0:     // formatting tags
0:     private static  final   String  ANCHOR = "a";
0:     private static  final   String  BODY = "body";
0:     private static  final   String  BOLD = "b";
0:     private static  final   String  BORDER = "border";
0:     private static  final   String  COLUMN = "td";
0:     private static  final   String  HORIZONTAL_LINE = "hr";
0:     private static  final   String  HTML = "html";
0:     private static  final   String  INDENT = "blockquote";
0:     private static  final   String  LIST = "ul";
0:     private static  final   String  LIST_ELEMENT = "li";
0:     private static  final   String  NAME = "name";
0:     private static  final   String  PARAGRAPH = "p";
0:     private static  final   String  ROW = "tr";
0:     private static  final   String  TABLE = "table";
1: 
1:     // tags in summary xml
1:     private static  final   String  SUM_ANT_VERSION = "antVersion";
0:     private static  final   String  SUM_BRANCH = "branch";
1:     private static  final   String  SUM_COMPILER = "compilers";
1:     private static  final   String  SUM_JAVA6 = "java6";
1:     private static  final   String  SUM_JDK14 = "jdk1.4";
0:     private static  final   String  SUM_JSR169 = "jsr169";
1:     private static  final   String  SUM_MACHINE = "machine";
1:     private static  final   String  SUM_NEW_FEATURES = "newFeatures";
1:     private static  final   String  SUM_OSGI = "osgi";
1:     private static  final   String  SUM_OVERVIEW = "overview";
0:     private static  final   String  SUM_PREVIOUS_RELEASE_ID = "previousReleaseID";
0:     private static  final   String  SUM_RELEASE_ID = "releaseID";
1: 
0:     // tags in JIRA reports
0:     private static  final   String  JIRA_ATTACHMENT = "attachment";
0:     private static  final   String  JIRA_ATTACHMENTS = "attachments";
0:     private static  final   String  JIRA_ID = "id";
0:     private static  final   String  JIRA_ITEM = "item";
0:     private static  final   String  JIRA_KEY = "key";
0:     private static  final   String  JIRA_NAME = "name";
0:     private static  final   String  JIRA_TITLE = "title";
1: 
0:     // managing releaseNote.html
0:     private static  final   String  RN_SUMMARY_OF_CHANGE = "Summary of Change";
1: 
0:     // other JIRA control
0:     private static  final   String  RELEASE_NOTE_NAME = "releaseNote.html";
0:     private static  final   String  RN_H4 = "h4";
1:     
0:     // other html control
0:     private static  final   int     DEFAULT_TABLE_BORDER_WIDTH = 2;
0:     private static  final   String  XML_DECLARATION = "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n";
1:     
1:     /////////////////////////////////////////////////////////////////////////
1:     //
1:     //  STATE
1:     //
1:     /////////////////////////////////////////////////////////////////////////
1: 
1:     // set on the command line or by ant
0:     private String  _summaryFileName;
0:     private String  _bugListFileName;
0:     private String  _releaseNotesListFileName;
0:     private String  _pamphletFileName;
1: 
0:     // computed at run time
0:     private String  _releaseID;
0:     private String  _previousReleaseID;
1: 
0:     // misc
0:     private boolean _invokedByAnt = true;
1:     
1:     /////////////////////////////////////////////////////////////////////////
1:     //
0:     //  INNER CLASSES
1:     //
1:     /////////////////////////////////////////////////////////////////////////
1: 
0:     /**
0:      * <p>
0:      * State used by the generator
0:      * </p>
1:      */
0:     public  static  class   GeneratorState
0:     {
0:         private DocumentBuilder _documentBuilder;
0:         private Document    _pamphlet;
0:         private Document    _summary;
0:         private Document    _bugList;
0:         private Document    _releaseNotesList;
1: 
0:         private ArrayList       _missingReleaseNotes;
1: 
0:         public  GeneratorState
0:             (
0:              DocumentBuilder    documentBuilder,
0:              Document   pamphlet,
0:              Document   summary,
0:              Document   bugList,
0:              Document   releaseNotesList
0:              )
0:         {
0:             _documentBuilder = documentBuilder;
0:             _pamphlet = pamphlet;
0:             _summary = summary;
0:             _bugList = bugList;
0:             _releaseNotesList = releaseNotesList;
1: 
0:             _missingReleaseNotes = new ArrayList();
0:         }
1: 
0:         public  void    addMissingReleaseNote( JiraIssue issue )
0:         {
0:             _missingReleaseNotes.add( issue );
0:         }
1: 
0:         public  DocumentBuilder getDocumentBuilder() { return _documentBuilder; }
0:         public  Document    getPamphlet() { return _pamphlet; }
0:         public  Document    getSummary() { return _summary; }
0:         public  Document    getBugList() { return _bugList; }
0:         public  Document    getReleaseNotesList() { return _releaseNotesList; }
1:         
0:         public  JiraIssue[]     getMissingReleaseNotes()
0:         {
0:             JiraIssue[]     missingNotes = new JiraIssue[ _missingReleaseNotes.size() ];
1: 
0:             _missingReleaseNotes.toArray( missingNotes );
1: 
0:             return missingNotes;
0:         }
0:     }
1: 
0:     /**
0:      * <p>
0:      * An issue from a JIRA report.
0:      * </p>
1:      */
0:     public  static  class   JiraIssue
0:     {
0:         public  static  final   long NO_RELEASE_NOTE = -1L;
1: 
0:         private String  _key;
0:         private String  _title;
0:         private long         _releaseNoteAttachmentID;
1: 
0:         public  JiraIssue
0:             (
0:              String key,
0:              String title,
0:              long       releaseNoteAttachmentID
0:              )
0:         {
0:             _key = key;
0:             _title = title;
0:             _releaseNoteAttachmentID = releaseNoteAttachmentID;
0:         }
1: 
0:         public  String  getKey() { return _key; }
0:         public  String  getTitle() { return _title; }
0:         public  long         getReleaseNoteAttachmentID() { return _releaseNoteAttachmentID; }
0:         public  boolean hasReleaseNote() { return (_releaseNoteAttachmentID > NO_RELEASE_NOTE); }
1:         
0:         public  String  getJiraAddress()
0:         {
0:             return "http://issues.apache.org/jira/browse/" + _key;
0:         }
1: 
0:         public  String  getReleaseNoteAddress()
0:         {
0:             return "http://issues.apache.org/jira/secure/attachment/" + _releaseNoteAttachmentID + "/releaseNote.html";
0:         }
0:     }
1:     
1:     /////////////////////////////////////////////////////////////////////////
1:     //
0:     //  CONSTRUCTORS
1:     //
1:     /////////////////////////////////////////////////////////////////////////
1: 
1:     /////////////////////////////////////////////////////////////////////////
1:     //
0:     //  ENTRY POINT
1:     //
1:     /////////////////////////////////////////////////////////////////////////
1: 
0:     /**
0:      * <p>
1:      * Generate the release notes (for details on how to invoke this tool, see
1:      * the header comment on this class).
0:      * </p>
1:      */
0:     public  static  void    main( String[] args )
0:         throws Exception
0:     {
1:         ReleaseNotesGenerator   me = new ReleaseNotesGenerator();
1: 
1:         me._invokedByAnt = false;
1:         
0:         if ( me.parseArgs( args ) ) { me.execute(); }
0:         else { me.printUsage(); }
0:     }
1:     
1:     /////////////////////////////////////////////////////////////////////////
1:     //
1:     //  ANT Task BEHAVIOR
1:     //
1:     /////////////////////////////////////////////////////////////////////////
1: 
0:     /** Ant accessor to set the name of the summary file prepared by the Release Manager */
0:     public   void    setSummaryFileName( String summaryFileName ) { _summaryFileName = summaryFileName; }     
1: 
0:     /** Ant accessor to set the name of the JIRA-generated list of bugs addressed by this release */
0:     public   void    setBugListFileName( String bugListFileName ) { _bugListFileName = bugListFileName; }     
1: 
0:     /** Ant accessor to set the name of the JIRA-generated list of bugs which have release notes */
0:     public   void    setReleaseNotesListFileName( String releaseNotesListFileName ) { _releaseNotesListFileName = releaseNotesListFileName; }     
1: 
0:     /** Ant accessor to set the name of the generated output file */
0:     public   void    setPamphletFileName( String pamphletFileName ) { _pamphletFileName = pamphletFileName; }     
1:         
0:     /**
0:      * <p>
1:      * This is Ant's entry point into this task.
0:      * </p>
1:      */
0:     public  void    execute()
0:         throws BuildException
0:     {
0:         try {
0:             GeneratorState                  gs = initialize();
1: 
0:             beginPamphlet( gs );
0:             buildOverview( gs );
0:             buildNewFeatures( gs );
0:             buildBugList( gs );
0:             buildIssuesList( gs );
0:             buildEnvironment( gs );
0:             endPamphlet( gs );
1:             
0:             printPamphlet( gs );
1: 
0:             printMissingReleaseNotes( gs );
0:         }
0:         catch ( Throwable t )
0:         {
1:             t.printStackTrace();
1:             
0:             throw new BuildException( "Error running ReleaseNotesGenerator: " + t.getMessage(), t );
0:         }
0:     }
1:     
1:     /////////////////////////////////////////////////////////////////////////
1:     //
0:     //  OTHER ACCESSORS
1:     //
1:     /////////////////////////////////////////////////////////////////////////
1: 
0:     /**
0:      * <p>
0:      * Get the release ID from the summary file.
0:      * </p>
1:      */
0:     private String getReleaseID( GeneratorState gs)
0:         throws Exception
0:     {
0:         if ( _releaseID == null )
0:         {
0:             Document    summary = gs.getSummary();
0:             Element     summaryRoot = summary.getDocumentElement();
1:             
0:             _releaseID = squeezeText( getFirstChild( summaryRoot, SUM_RELEASE_ID ) );
0:         }
1:         
0:         return _releaseID;
0:     }
1:     
0:     /**
0:      * <p>
0:      * Get the previous release ID from the summary file.
0:      * </p>
1:      */
0:     private String getPreviousReleaseID( GeneratorState gs)
0:         throws Exception
0:     {
0:         if ( _previousReleaseID == null )
0:         {
0:             Document    summary = gs.getSummary();
0:             Element     summaryRoot = summary.getDocumentElement();
1:             
0:             _previousReleaseID = squeezeText( getFirstChild( summaryRoot, SUM_PREVIOUS_RELEASE_ID ) );
0:         }
1:         
0:         return _previousReleaseID;
0:     }
1:     
1:     /////////////////////////////////////////////////////////////////////////
1:     //
1:     //  MINIONS
1:     //
1:     /////////////////////////////////////////////////////////////////////////
1: 
1:     //////////////////////////////////
1:     //
0:     //  Boilerplate
1:     //
1:     //////////////////////////////////
1: 
0:     /**
0:      * <p>
0:      * Start an html docment. Returns the body element.
0:      * </p>
1:      */
0:     private void beginPamphlet( GeneratorState gs )
0:         throws Exception
0:     {
0:         Document    pamphlet = gs.getPamphlet();
0:         String          releaseID = getReleaseID( gs );
0:         String          titleText = "Release Notes for Derby " + releaseID;
0:         Element     html = pamphlet.createElement( HTML );
0:         Element     title = createTextElement( pamphlet, "title", titleText );
0:         Element     body = pamphlet.createElement( BODY );
1: 
0:         pamphlet.appendChild( html );
0:         html.appendChild( title );
0:         html.appendChild( body );
1:         
0:         Element     bannerBlock = createHeader( body, BANNER_LEVEL, titleText );
0:         buildDelta( gs, bannerBlock );
1:         
0:         Element     toc = createList( body );
1: 
0:         createSection( body, MAIN_SECTION_LEVEL, toc, OVERVIEW_SECTION, null );
0:         createSection( body, MAIN_SECTION_LEVEL, toc, NEW_FEATURES_SECTION, null );
0:         createSection( body, MAIN_SECTION_LEVEL, toc, BUG_FIXES_SECTION, null );
0:         createSection( body, MAIN_SECTION_LEVEL, toc, ISSUES_SECTION, null );
0:         createSection( body, MAIN_SECTION_LEVEL, toc, BUILD_ENVIRONMENT_SECTION, null );
0:     }
1:     
0:     /**
0:      * <p>
0:      * Finish the html document.
0:      * </p>
1:      */
0:     private void    endPamphlet( GeneratorState gs )
0:         throws Exception
0:     {
0:     }
1:     
1:     //////////////////////////////////
1:     //
0:     //  Delta SECTION
1:     //
1:     //////////////////////////////////
1: 
0:     /**
0:      * <p>
0:      * Note that this release is a delta from the previous one.
0:      * </p>
1:      */
0:     private void buildDelta( GeneratorState gs, Element parent )
0:         throws Exception
0:     {
0:         String          releaseID = getReleaseID( gs );
0:         String          previousReleaseID = getPreviousReleaseID( gs );
0:         String          deltaStatement =
0:             "These notes describe the difference between Derby release " + releaseID +
0:             " and the preceding release " + previousReleaseID + ".";
1: 
0:         addParagraph( parent, deltaStatement );
0:     }
1:     
1:     //////////////////////////////////
1:     //
1:     //  Overview SECTION
1:     //
1:     //////////////////////////////////
1: 
0:     /**
0:      * <p>
1:      * Build the Overview section.
0:      * </p>
1:      */
0:     private void buildOverview( GeneratorState gs )
0:         throws Exception
0:     {
0:         Document    pamphlet = gs.getPamphlet();
0:         Element     overviewSection = getSection( pamphlet, MAIN_SECTION_LEVEL, OVERVIEW_SECTION );
0:         Document    summary = gs.getSummary();
0:         Element     summaryRoot = summary.getDocumentElement();
0:         Element     details = getFirstChild( summaryRoot, SUM_OVERVIEW );
1: 
1:         // copy the details out of the summary file into the overview section
0:         cloneChildren( details, overviewSection );
0:     }
1:     
1:     //////////////////////////////////
1:     //
1:     //  New Features SECTION
1:     //
1:     //////////////////////////////////
1: 
0:     /**
0:      * <p>
1:      * Build the New Features section.
0:      * </p>
1:      */
0:     private void buildNewFeatures( GeneratorState gs )
0:         throws Exception
0:     {
0:         Document    pamphlet = gs.getPamphlet();
0:         Element     newFeaturesSection = getSection( pamphlet, MAIN_SECTION_LEVEL, NEW_FEATURES_SECTION );
0:         Document    summary = gs.getSummary();
0:         Element     summaryRoot = summary.getDocumentElement();
0:         Element     details = getFirstChild( summaryRoot, SUM_NEW_FEATURES );
1: 
1:         // copy the details out of the summary file into the overview section
0:         cloneChildren( details, newFeaturesSection );
0:     }
1:     
1:     //////////////////////////////////
1:     //
1:     //  Bug List SECTION
1:     //
1:     //////////////////////////////////
1: 
0:     /**
0:      * <p>
1:      * Build the Bug List section.
0:      * </p>
1:      */
0:     private void buildBugList( GeneratorState gs )
0:         throws Exception
0:     {
0:         Document    pamphlet = gs.getPamphlet();
0:         Element     bugListSection = getSection( pamphlet, MAIN_SECTION_LEVEL, BUG_FIXES_SECTION );
0:         Document    bugList = gs.getBugList();
0:         JiraIssue[]    bugs = getJiraIssues( bugList );
0:         int                 count = bugs.length;
0:         String          releaseID = getReleaseID( gs );
0:         String          previousReleaseID = getPreviousReleaseID( gs );
0:         String          deltaStatement =
1:             "The following issues are addressed by Derby release " + releaseID +
0:             ". These issues are not addressed in the preceding " + previousReleaseID + " release.";
1: 
0:         addParagraph( bugListSection, deltaStatement );
1: 
0:         Element     table = createTable
0:             ( bugListSection, DEFAULT_TABLE_BORDER_WIDTH, new String[] { ISSUE_ID_HEADLINE, DESCRIPTION_HEADLINE } );
1: 
0:         for ( int i = 0; i < count; i++ )
0:         {
0:             JiraIssue   issue = bugs[ i ];
0:             Element     row = insertRow( table );
0:             Element     linkColumn = insertColumn( row );
0:             Element     descriptionColumn = insertColumn( row );
0:             Element     hotlink = createLink( pamphlet, issue.getJiraAddress(), issue.getKey() );
0:             Text            title = pamphlet.createTextNode( issue.getTitle() );
1: 
0:             linkColumn.appendChild( hotlink );
0:             descriptionColumn.appendChild( title );
0:         }
0:     }
1:     
1:     //////////////////////////////////
1:     //
1:     //  Issues SECTION
1:     //
1:     //////////////////////////////////
1: 
0:     /**
0:      * <p>
1:      * Build the Issues section.
0:      * </p>
1:      */
0:     private void buildIssuesList( GeneratorState gs )
0:         throws Exception
0:     {
0:         Document    pamphlet = gs.getPamphlet();
0:         Element     issuesSection = getSection( pamphlet, MAIN_SECTION_LEVEL, ISSUES_SECTION );
0:         Document    issuesList = gs.getReleaseNotesList();
0:         JiraIssue[]    bugs = getJiraIssues( issuesList );
0:         int                 count = bugs.length;
0:         String          releaseID = getReleaseID( gs );
0:         String          previousReleaseID = getPreviousReleaseID( gs );
0:         String          deltaStatement =
1:             "Compared with the previous release (" + previousReleaseID +
0:             "), Derby release " + releaseID + " introduces the following new features " +
1:             "and incompatibilities. These merit your special attention.";
1:         
0:         addParagraph( issuesSection, deltaStatement );
1: 
0:         Element     toc = createList( issuesSection );
1: 
0:         for ( int i = 0; i < count; i++ )
0:         {
0:             JiraIssue       issue = bugs[ i ];
0:             Document    releaseNote = getReleaseNote( gs, issue );
0:             String          key = "Note for " + issue.getKey();
0:             String          summary = getReleaseNoteSummary( releaseNote );
0:             String          tocEntry = key + ": " + summary;
1: 
0:             insertLine( issuesSection );
1:             
0:             Element     issueSection = createSection( issuesSection, ISSUE_DETAIL_LEVEL, toc, key, tocEntry );
1: 
0:             if ( releaseNote != null )
0:             {
0:                 Element     root = releaseNote.getDocumentElement();
0:                 Element     details = getFirstChild( root, BODY );
1: 
0:                 // copy the details out of the release note into this section of the
0:                 // pamphlet
0:                 cloneChildren( details, issueSection );
0:             }
0:             else
0:             {
0:                 gs.addMissingReleaseNote( issue );
0:             }
1: 
0:         }
0:     }
1:     
0:     /**
0:      * <p>
0:      * Get the release note for an issue.
0:      * </p>
1:      */
0:     private Document   getReleaseNote( GeneratorState gs, JiraIssue issue )
0:         throws Exception
0:     {
0:         if ( issue.hasReleaseNote() )
0:         {
0:             URL                                 url = new URL( issue.getReleaseNoteAddress() );
1: 
0:             try {
0:                 InputStream                     is = url.openStream();
0:                 Document        doc = gs.getDocumentBuilder().parse( is );
1: 
0:                 is.close();
1: 
0:                 return doc;
0:             }
0:             catch (Exception e)
0:             {
0:                 processThrowable( e );
1:                 
0:                 throw new BuildException
0:                     ( "Unable to read or parse release note for " + issue.getKey() + ": " + e.toString(), e );
0:             }
0:         }
0:         else { return null; }
0:     }
1: 
0:     /**
0:      * <p>
0:      * Get the summary for a release note
0:      * </p>
1:      */
0:     private String   getReleaseNoteSummary( Document releaseNote )
0:         throws Exception
0:     {
0:         if ( releaseNote != null )
0:         {
1:             //
0:             // The release note has the following structure:
1:             //
0:             // <h4>Summary of Change</h4>
0:             // <p>
0:             //  Summary text
0:             // </p>
1:             //
0:             Element     root = releaseNote.getDocumentElement();
0:             Element     summaryParagraph = getFirstChild( root, PARAGRAPH );
0:             String          summaryText = squeezeText( summaryParagraph );
1: 
0:             return summaryText;
0:         }
0:         else { return "???"; }
0:     }
1: 
1:     //////////////////////////////////
1:     //
1:     //  Build Environment SECTION
1:     //
1:     //////////////////////////////////
1: 
0:     /**
0:      * <p>
1:      * Build the section describing the build environment.
0:      * </p>
1:      */
0:     private void buildEnvironment( GeneratorState gs )
0:         throws Exception
0:     {
0:         Document    pamphlet = gs.getPamphlet();
0:         Element         environmentSection = getSection( pamphlet, MAIN_SECTION_LEVEL, BUILD_ENVIRONMENT_SECTION );
0:         Document    summary = gs.getSummary();
0:         Element     summaryRoot = summary.getDocumentElement();
0:         String          releaseID = getReleaseID( gs );
0:         String          desc = "Derby release " + releaseID + " was built using the following environment:";
1: 
0:         addParagraph( environmentSection, desc );
1: 
0:         Element     list = createList( environmentSection );
0:         String          branchName = squeezeText( getFirstChild( summaryRoot, SUM_BRANCH ) );
0:         String          branchText = "Source code came from the " + branchName + " branch.";
0:         addHeadlinedItem( list, BRANCH_HEADLINE, branchText );
1: 
0:         String          machine = squeezeText( getFirstChild( summaryRoot, SUM_MACHINE ) );
0:         addHeadlinedItem( list, MACHINE_HEADLINE, machine );
1: 
0:         String          antVersion = squeezeText( getFirstChild( summaryRoot, SUM_ANT_VERSION ) );
0:         addHeadlinedItem( list, ANT_HEADLINE, antVersion );
1: 
0:         String          jdk14Version = squeezeText( getFirstChild( summaryRoot, SUM_JDK14 ) );
0:         addHeadlinedItem( list, JDK14_HEADLINE, jdk14Version );
1: 
0:         String          java6Version = squeezeText( getFirstChild( summaryRoot, SUM_JAVA6 ) );
0:         addHeadlinedItem( list, JAVA6_HEADLINE, java6Version );
1: 
0:         String          osgiText = squeezeText( getFirstChild( summaryRoot, SUM_OSGI ) );
0:         addHeadlinedItem( list, OSGI_HEADLINE, osgiText );
1: 
0:         String          compilerText = squeezeText( getFirstChild( summaryRoot, SUM_COMPILER ) );
0:         addHeadlinedItem( list, COMPILER_HEADLINE, compilerText );
1: 
0:         String          jsr169Text = squeezeText( getFirstChild( summaryRoot, SUM_JSR169 ) );
0:         addHeadlinedItem( list, JSR169_HEADLINE, jsr169Text );
0:     }
1:     
1:    //////////////////////////////////
1:     //
0:     //  Print the generated document.
1:     //
1:     //////////////////////////////////
1: 
0:     /**
0:      * <p>
0:      * Print pamphlet to output file.
0:      * </p>
1:      */
0:     private void    printPamphlet( GeneratorState gs )
0:         throws Exception
0:     {
0:         Document    pamphlet = gs.getPamphlet();
0:         Source            source = new DOMSource( pamphlet );
0:         File                  outputFile = new File( _pamphletFileName );
0:         Result            result = new StreamResult( outputFile );
0:         Transformer   transformer = TransformerFactory.newInstance().newTransformer();
1:         
0:         transformer.transform( source, result );        
0:     }
1:     
1:     //////////////////////////////////
1:     //
0:     //  Print missing Release Notes
1:     //
1:     //////////////////////////////////
1: 
0:     /**
0:      * <p>
1:      * Build the Overview section.
0:      * </p>
1:      */
0:     private void printMissingReleaseNotes( GeneratorState gs )
0:         throws Exception
0:     {
0:         JiraIssue[]     missingReleaseNotes = gs.getMissingReleaseNotes();
0:         int                 count = missingReleaseNotes.length;
1: 
0:         if ( count > 0 )
0:         {
0:             println( "The following JIRA issues still need release notes:" );
1: 
0:             for ( int i = 0; i < count; i++ )
0:             {
0:                 JiraIssue   issue = missingReleaseNotes[ i ];
1:                 
0:                 println( "\t" + issue.getKey() + "\t" + issue.getTitle() );
0:             }
0:         }
0:     }
1:     
1:     //////////////////////////////////
1:     //
1:     //  ARGUMENT MINIONS
1:     //
1:     //////////////////////////////////
1: 
0:     /**
0:      * <p>
1:      * Returns true if arguments parse successfully, false otherwise.
0:      * </p>
1:      */
1:     private boolean    parseArgs( String[] args )
0:         throws Exception
0:     {
0:         if ( (args == null) || (args.length != 4) ) { return false; }
1: 
1:         int     idx = 0;
1: 
1:         setSummaryFileName( args[ idx++ ] );
1:         setBugListFileName( args[ idx++ ] );
0:         setReleaseNotesListFileName( args[ idx++ ] );
0:         setPamphletFileName( args[ idx++ ] );
1: 
1:         return true;
0:     }
1:     
0:     private void    printUsage()
0:     {
0:         println( USAGE );
0:     }
1: 
0:     /**
0:      * <p>
0:      * Make sure that the input files all exist. Returns a state variable for the generator.
0:      * </p>
1:      */
0:     private GeneratorState  initialize()
0:         throws Exception
0:     {
0:         DocumentBuilderFactory  factory = DocumentBuilderFactory.newInstance();
0:         DocumentBuilder              builder = factory.newDocumentBuilder();
0:         Document                          pamphlet = builder.newDocument();
0:         File                                    summaryFile = new File( _summaryFileName );
0:         File                                    bugListFile = new File( _bugListFileName );
0:         File                                    releaseNotesListFile = new File( _releaseNotesListFileName);
0:         Document                        summary = builder.parse( summaryFile );
0:         Document                        bugList = builder.parse( bugListFile );
0:         Document                        releaseNotesList = builder.parse( releaseNotesListFile );
1:         
0:         return new GeneratorState
0:             (
0:              builder,
0:              pamphlet,
0:              summary,
0:              bugList,
0:              releaseNotesList
0:              );
0:     }
1: 
0:     ////////////////////////////////////////////////////////
1:     //
0:     // HTML MINIONS
1:     //
0:     ////////////////////////////////////////////////////////
1: 
0:     /**
0:      * <p>
0:      * Create a section at the end of a parent element and link to it from a
0:      * table of contents.
0:      * </p>
1:      */
0:     private Element createSection( Element parent, int sectionLevel, Element toc, String sectionName, String tocEntry )
0:         throws Exception
0:     {
0:         Document        doc = parent.getOwnerDocument();
0:         Element             link = createLocalLink( doc, sectionName, tocEntry );
1: 
0:         addListItem( toc, link );
1: 
0:         return createHeader( parent, sectionLevel, sectionName );
0:     }
1:     
0:     /**
0:      * <p>
0:      * Create a header at the end of the parent node. Return the block created
0:      * to hold the text following this header.
0:      * </p>
1:      */
0:     private Element createHeader( Element parent, int headerLevel, String text )
0:         throws Exception
0:     {
0:         Document        doc = parent.getOwnerDocument();
0:         Text            textNode = doc.createTextNode( text );
0:         Element         header = doc.createElement( makeHeaderTag( headerLevel ) );
0:         Element         anchor = doc.createElement( ANCHOR );
0:         Element         block =doc.createElement( INDENT );
1: 
0:         parent.appendChild( header );
0:         anchor.setAttribute( NAME, text );
0:         header.appendChild( anchor );
0:         header.appendChild( textNode );
0:         parent.appendChild( block );
1:         
0:         return block;
0:     }
1:     
0:     /**
0:      * <p>
0:      * Create an html text element.
0:      * </p>
1:      */
0:     private Element createTextElement( Document doc, String tag, String text )
0:         throws Exception
0:     {
0:         Element     retval = doc.createElement( tag );
0:         Text            textNode = doc.createTextNode( text );
1: 
0:         retval.appendChild( textNode );
1:         
0:         return retval;
0:     }
1: 
0:     /**
0:      * <p>
0:      * Create a standard link to a local label.
0:      * </p>
1:      */
0:     private Element createLocalLink( Document doc, String anchor, String text )
0:         throws Exception
0:     {
0:         if ( text == null ) { text = anchor; }
1:         
0:         return createLink( doc, "#" + anchor, text );
0:     }
1:     
0:     /**
0:      * <p>
0:      * Create a hotlink.
0:      * </p>
1:      */
0:     private Element createLink( Document doc, String label, String text )
0:         throws Exception
0:     {
0:         Element hotlink = doc.createElement( ANCHOR );
0:         Text        textNode = doc.createTextNode( text );
1: 
0:         hotlink.setAttribute( "href", label );
0:         hotlink.appendChild( textNode );
1: 
0:         return hotlink;
0:     }
1:     
0:     /**
0:      * <p>
0:      * Insert a list at the end of the parent element.
0:      * </p>
1:      */
0:     private Element createList( Element parent )
0:         throws Exception
0:     {
0:         Document        doc = parent.getOwnerDocument();
0:         Element list = doc.createElement( LIST );
1: 
0:         parent.appendChild( list );
1: 
0:         return list;
0:     }
1:     
0:     /**
0:      * <p>
0:      * Add an item with a bold name to the end of a list.
0:      * </p>
1:      */
0:     private Element addHeadlinedItem( Element list, String headline, String text )
0:         throws Exception
0:     {
0:         Document        doc = list.getOwnerDocument();
0:         Element         itemElement = doc.createElement( LIST_ELEMENT );
0:         Element         boldText = boldText( doc, headline );
0:         Text            textNode = doc.createTextNode( " - " + text );
1: 
0:         list.appendChild( itemElement );
0:         itemElement.appendChild( boldText );
0:         itemElement.appendChild( textNode );
1: 
0:         return itemElement;
0:     }
1:     
0:     /**
0:      * <p>
0:      * Make some bold text.
0:      * </p>
1:      */
0:     private Element boldText( Document doc, String text)
0:         throws Exception
0:     {
0:         Element bold = createTextElement( doc, BOLD, text );
1: 
0:         return bold;
0:     }
1:     
0:     /**
0:      * <p>
0:      * Add an item to the end of a list.
0:      * </p>
1:      */
0:     private Element addListItem( Element list, Node item )
0:         throws Exception
0:     {
0:         Document        doc = list.getOwnerDocument();
0:         Element         itemElement = doc.createElement( LIST_ELEMENT );
1: 
0:         list.appendChild( itemElement );
0:         itemElement.appendChild( item );
1: 
0:         return itemElement;
0:     }
1:     
0:     /**
0:      * <p>
0:      * Retrieve the indented block inside a section
0:      * </p>
1:      */
0:     private Element getSection( Document doc, int sectionLevel, String sectionName )
0:         throws Exception
0:     {
0:         String          headerTag = makeHeaderTag( sectionLevel );
0:         Element     root = doc.getDocumentElement();
0:         NodeList    sectionList = root.getElementsByTagName( headerTag );
0:         int             count = sectionList.getLength();
1: 
0:         for ( int i = 0; i < count; i++ )
0:         {
0:             Element     section = (Element) sectionList.item( i );
0:             Element     sectionAnchor = getFirstChild( section, ANCHOR );
1: 
0:             if ( sectionName.equals( sectionAnchor.getAttribute( NAME ) ) )
0:             {
0:                 // the next item after the section header, is the indented block
1: 
0:                 return (Element) section.getNextSibling();
0:             }
0:         }
1: 
0:         return null;
0:     }
1: 
0:     /**
0:      * <p>
0:      * Make the tag for a header, given its level
0:      * </p>
1:      */
0:     private String makeHeaderTag( int headerLevel )
0:     {
0:         return "h" + Integer.toString( headerLevel );
0:     }
1:     
0:     /**
0:      * <p>
0:      * Add a paragraph to the end of a parent element.
0:      * </p>
1:      */
0:     private Element addParagraph( Element parent, String text )
0:         throws Exception
0:     {
0:         Document        doc = parent.getOwnerDocument();
0:         Text            textNode = doc.createTextNode( text );
0:         Element         paragraph = doc.createElement( PARAGRAPH );
1: 
0:         parent.appendChild( paragraph );
0:         paragraph.appendChild( textNode );
1:         
0:         return paragraph;
0:     }
1:     
0:     /**
0:      * <p>
0:      * Insert a table at the end of the parent element.
0:      * </p>
1:      */
0:     private Element createTable( Element parent, int borderWidth, String[] columnHeadings )
0:         throws Exception
0:     {
0:         Document        doc = parent.getOwnerDocument();
0:         Element         table = doc.createElement( TABLE );
0:         Element         headingRow = insertRow( table );
0:         int                     count = columnHeadings.length;
1: 
0:         parent.appendChild( table );
0:         table.setAttribute( BORDER, Integer.toString( borderWidth ) );
1: 
0:         for ( int i = 0; i < count; i++ )
0:         {
0:             Element     headingColumn = insertColumn( headingRow );
0:             Element     boldText = boldText( doc, columnHeadings[ i ] );
1: 
0:             headingColumn.appendChild( boldText );
0:         }
1: 
0:         return table;
0:     }
1:     
0:     /**
0:      * <p>
0:      * Insert a row at the end of a table
0:      * </p>
1:      */
0:     private Element insertRow( Element table )
0:         throws Exception
0:     {
0:         Document        doc = table.getOwnerDocument();
0:         Element         row = doc.createElement( ROW );
1: 
0:         table.appendChild( row );
1: 
0:         return row;
0:     }
1:     
0:     /**
0:      * <p>
0:      * Insert a column at the end of a row
0:      * </p>
1:      */
0:     private Element insertColumn( Element row )
0:         throws Exception
0:     {
0:         Document        doc = row.getOwnerDocument();
0:         Element         column = doc.createElement( COLUMN );
1: 
0:         row.appendChild( column );
1: 
0:         return column;
0:     }
1:     
0:     /**
0:      * <p>
0:      * Insert a horizontal line at the end of the parent element.
0:      * </p>
1:      */
0:     private Element insertLine( Element parent )
0:         throws Exception
0:     {
0:         Document        doc = parent.getOwnerDocument();
0:         Element         line = doc.createElement( HORIZONTAL_LINE );
1: 
0:         parent.appendChild( line );
1: 
0:         return line;
0:     }
1: 
0:     ////////////////////////////////////////////////////////
1:     //
0:     // XML MINIONS
1:     //
0:     ////////////////////////////////////////////////////////
1: 
0:     private Element getFirstChild( Element node, String childName )
0:         throws Exception
0:     {
0:         Element retval = getOptionalChild( node, childName );
1: 
0:         if ( retval == null )
0:         {
0:             throw new BuildException( "Could not find child element '" + childName + "' in parent element '" + node.getNodeName() + "'." );
0:         }
1: 
0:         return retval;
0:     }
1: 
0:     private Element getOptionalChild( Element node, String childName )
0:         throws Exception
0:     {
0:         return (Element) node.getElementsByTagName( childName ).item( 0 );
0:     }
1: 
0:     /**
0:      * <p>
0:      * Squeeze the text out of an Element.
0:      * </p>
1:      */
0:     private String squeezeText( Element node )
0:         throws Exception
0:     {
0:         Node        textChild = node.getFirstChild();
0:         String      text = textChild.getNodeValue();
1: 
0:         return text;
0:     }
1: 
0:     /**
0:      * <p>
0:      * Clone all of the children of a source node and add them as children
0:      * of a target node.
0:      * </p>
1:      */
0:     private void cloneChildren( Element source, Element target )
0:         throws Exception
0:     {
0:         Document    targetDoc = target.getOwnerDocument();
0:         NodeList        sourceChildren = source.getChildNodes();
0:         int                 count = sourceChildren.getLength();
1: 
0:         for ( int i = 0; i < count; i++ )
0:         {
0:             Node    sourceChild = sourceChildren.item( i );
0:             Node    targetChild = targetDoc.importNode( sourceChild, true );
1: 
0:             target.appendChild( targetChild );
0:         }
0:     }
1: 
0:     ////////////////////////////////////////////////////////
1:     //
0:     // JIRA MINIONS
1:     //
0:     ////////////////////////////////////////////////////////
1: 
0:     /**
0:      * <p>
0:      * Get an array of JiraIssues from a JIRA report.
0:      * </p>
1:      */
0:     private JiraIssue[]   getJiraIssues( Document report )
0:         throws Exception
0:     {
0:         Element         reportRoot = report.getDocumentElement();
0:         NodeList        itemList = reportRoot.getElementsByTagName( JIRA_ITEM );
0:         int                 count = itemList.getLength();
0:         JiraIssue[]     issues = new JiraIssue[ count ];
1: 
0:         for ( int i = 0; i < count; i++ ) { issues[ i ] = makeJiraIssue( (Element) itemList.item( i ) ); }
1: 
0:         return issues;
0:     }
1: 
0:     /**
0:      * <p>
0:      * Create a JiraIssue from an <item> element in a JIRA report.
0:      * </p>
1:      */
0:     private JiraIssue   makeJiraIssue( Element itemElement )
0:         throws Exception
0:     {
0:         String  key = squeezeText( getFirstChild( itemElement, JIRA_KEY ) );
0:         String  title = squeezeText( getFirstChild( itemElement, JIRA_TITLE ) );
0:         long         releaseNoteAttachmentID = getReleaseNoteAttachmentID( itemElement );
1: 
1:         //
0:         // A JIRA title has the following form:
1:         //
0:         //  "[DERBY-2598] new upgrade  test failures after change 528033"
1:         //
0:         // We strip off the leading JIRA id because that information already
0:         // lives in the key.
1:         //
0:         title = title.substring( title.indexOf( ']' ) + 2, title.length() );        
1: 
0:         return new JiraIssue( key, title, releaseNoteAttachmentID );
0:     }
1: 
0:     /**
0:      * <p>
0:      * Get the highest attachment id of all of the "releaseNote.html" documents
0:      * attached to this JIRA.
0:      * </p>
1:      */
0:     private long   getReleaseNoteAttachmentID( Element itemElement )
0:         throws Exception
0:     {
0:         long         releaseNoteAttachmentID = JiraIssue.NO_RELEASE_NOTE;
1: 
0:         Element     attachments = getOptionalChild( itemElement, JIRA_ATTACHMENTS );
1: 
0:         if ( attachments != null )
0:         {
0:             NodeList    attachmentsList = attachments.getElementsByTagName( JIRA_ATTACHMENT );
0:             int             count = attachmentsList.getLength();
1: 
0:             for ( int i = 0; i < count; i++ )
0:             {
0:                 Element     attachment = (Element) attachmentsList.item( i );
0:                 String          name = attachment.getAttribute( JIRA_NAME );
1: 
0:                 if ( RELEASE_NOTE_NAME.equals( name ) )
0:                 {
0:                     String      stringID = attachment.getAttribute( JIRA_ID );
0:                     int             id = Long.decode( stringID ).intValue();
1: 
0:                     if ( id > releaseNoteAttachmentID ) { releaseNoteAttachmentID = id; }
0:                 }
0:             }
1: 
0:         }
1: 
0:         return releaseNoteAttachmentID;
0:     }
1:     
0:     ////////////////////////////////////////////////////////
1:     //
0:     // EXCEPTION PROCESSING MINIONS
1:     //
0:     ////////////////////////////////////////////////////////
1: 
0:     /**
0:      * <p>
0:      * Special processing for special exceptions.
0:      * </p>
1:      */
0:     private  void    processThrowable( Throwable t )
0:     {
0:         if ( t instanceof java.net.UnknownHostException )
0:         {
0:             println( "Unknown host '" + t.getMessage() + "'. Can you ping this host from a shell window?" );
0:         }
0:     }
1: 
0:     ////////////////////////////////////////////////////////
1:     //
0:     // MISC MINIONS
1:     //
0:     ////////////////////////////////////////////////////////
1: 
0:     private  void    println( String text )
0:     {
0:         if ( _invokedByAnt )
0:         {
0:             log( text, Project.MSG_WARN );
0:         }
0:         else
0:         {
0:             System.out.println( text );
0:         }
0:     }
1:     
0: }
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:086e817
/////////////////////////////////////////////////////////////////////////
1:         // If we don't fix the width of the first column, the string
1:         // "DERBY-XXXX" is often broken up at the hyphen by some browsers.
1:         fixWidthOfFirstColumn(table);
commit:f5868b5
/////////////////////////////////////////////////////////////////////////
1:         if ( (args == null) || (args.length != 3) ) { return false; }
commit:e1aa9c0
/////////////////////////////////////////////////////////////////////////
1:  * that you freshly regenerate your BUG_LIST just before you run this tool.
1:  * The tool is designed to be run from Derby's ant build scripts. The build
1:  * script will integrate the various steps of generating the release notes into
1:  * a single ant target. This includes generating the issue list by querying
1:  * the Apache JIRA instance. For this reason, the properties below must be
1:  * specified when invoking the ant target. You can specify them in
1:  * <tt>ant.properties</tt>, or on the command line.<br/>
1:  * To run under ant, do the following:
1:  *      <li>Make sure the Maven 2 executable is in your path.</li>
1:  *      <li>Fill in information in <tt>releaseSummary.xml</tt>.<br/>
1:  *          See <tt>tools/release/templates/releaseSummaryTemplate.xml</tt>
1:  *          for details.</li>
1:  *      <li>Define <tt>jira.user</tt>.<br/>
1:  *          This variable is your JIRA user name.</li>
1:  *      <li>Define <tt>jira.password</tt>.<br/>
1:  *          This variable is your JIRA password.</li>
1:  *      <li>Define <tt>jira.filter.id</tt>.<br/>
1:  *          This variable holds the id for the manually created JIRA filter
1:  *          that will select the issues addressed by the release. The id
1:  *          consists of digits only.</li>
1:  *      <li>Define <tt>release.version</tt>.<br/>
1:  *          The version of the release, i.e. "10.7.1.0".</li>
1:  *      <li>Define <tt>relnotes.src.reports</tt>.<br/>
1:  *          This variable points at the directory which holds the list of JIRA
1:  *          issues addressed by the release. The file, called
1:  *          <tt>fixedBugsList.txt</tt>, will be generated when you invoke the
1:  *          ant target.</li>
1:  *      <li>cd into <tt>tools/release</tt> and run ant thusly:
1:  *          <tt>ant [properties] genrelnotes</tt></li>
1:  * Running the ant target successfully requires a working Internet connection
1:  * to the Apache JIRA instance, as well as a valid JIRA username/password and
1:  * the id of an existing JIRA filter.
1:  * <p>For more information on this tool, please see the JIRAs which introduced it:
1:  * <ul> <li><a href="http://issues.apache.org/jira/browse/DERBY-4857">DERBY-4857</a></li>
1:  *      <li><a href="http://issues.apache.org/jira/browse/DERBY-2570">DERBY-2570</a></li>
1:  * </ul>
/////////////////////////////////////////////////////////////////////////
1:         "  java org.apache.derbyBuild.ReleaseNotesGenerator SUMMARY BUG_LIST OUTPUT_PAMPHLET\n" +
1:         "                  BUG_LIST                   A report of issues addressed by this release, generated by the Derby JIRA SOAP client.\n" +
/////////////////////////////////////////////////////////////////////////
1:         "The ReleaseNoteGenerator assumes that the JIRA report contains\n" +
1:         "key, title, fix versions and attachment id elements for each Derby\n" +
1:         "issue. For each issue in with an attachment id element the\n" +
1:         "ReleaseNotesGenerator grabs the (latest) releaseNote.html file.\n" +
1:         "just before you run this tool.\n"
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             parseBugsList();
/////////////////////////////////////////////////////////////////////////
1:     private void parseBugsList()
1:             throws Exception {
1:         bugList = JiraIssue.createJiraIssueList(bugListFileName);
1:         // Parse the file for the release version and the previous version to
1:         // carry out sanity checks.
1:         BufferedReader in = new BufferedReader(new InputStreamReader(
1:                 new FileInputStream(bugListFileName), "UTF-8"));
1:         String line;
1:         String prevVer = null;
1:         while ((line = in.readLine()) != null) {
1:             if (line.startsWith("// Previous release:")) {
1:                 prevVer = line.split(":")[1].trim();
1:                 break;
0:             }
0:         }
1:         in.close();
1:         if (prevVer == null) {
1:             System.out.println(
1:                     "WARNING: Skipped previous release version sanity check.");
1:         } else if (!prevVer.equals(previousReleaseID)) {
1:             throw new IllegalStateException("previous release version " +
1:                     "mismatch between releaseSummary.xml and bug list: " +
1:                     previousReleaseID + " != " + prevVer);
0:         }
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
1:         for ( Iterator i=bugList.iterator(); i.hasNext(); ) {
/////////////////////////////////////////////////////////////////////////
1:         for (Iterator i=bugList.iterator(); i.hasNext(); ) {
/////////////////////////////////////////////////////////////////////////
1:             } else if (issue.hasMissingReleaseNote()) {
1:                 missingReleaseNotes.add(issue);
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:80e6765
/////////////////////////////////////////////////////////////////////////
1:                 Element paragraph = outputDoc.createElement(SPAN);
commit:38b9499
/////////////////////////////////////////////////////////////////////////
1:     private List<JiraIssue> missingReleaseNotes = new ArrayList<JiraIssue>();
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:d76e238
/////////////////////////////////////////////////////////////////////////
1: import java.util.*;
0: import java.net.URL;
/////////////////////////////////////////////////////////////////////////
0:  *  <li>fixedBugsList.xml - This is the list of issues addressed
0:  * by the release.</li>
/////////////////////////////////////////////////////////////////////////
1: public class ReleaseNotesGenerator extends GeneratorBase {
0: 
/////////////////////////////////////////////////////////////////////////
0:         "key, title, and attachments elements for each Derby issue. For each\n" +
0:         "attachments block in that report and grabs the latest reported\n" +
0: 
0:     private static  final   String  BUILD_ENVIRONMENT_SECTION =
0:             "Build Environment";
/////////////////////////////////////////////////////////////////////////
1:     private ReleaseNoteReader releaseNoteReader = new ReleaseNoteReader(docBldr);
0:     private String releaseNotesListFileName;
0:     private Document releaseNotesDoc;
0:     private ArrayList missingReleaseNotes = new ArrayList();
1:     public ReleaseNotesGenerator() throws Exception {
1:      * @param args command line arguments
1:      * @throws Exception
1:     public static void main(String[] args) throws Exception {
0: 
1:         if (me.parseArgs(args)) { me.execute(); }
1:         else { me.println(USAGE); }
0: 
0:      * Ant accessor to set the name of the JIRA-generated list of bugs which
0:      * have release notes
0:      * @param releaseNotesListFileName name of the xml file from the release
0:      * note Jira filter/query
1:      * @throws Exception
0:      */
0:     public void setReleaseNotesListFileName(String releaseNotesListFileName)
1:             throws Exception {
0:         this.releaseNotesListFileName = releaseNotesListFileName;
0:         releaseNotesDoc = docBldr.parse(new File(releaseNotesListFileName));
0:     }
0: 
0: 
0:     /**
1:      * @throws BuildException
1:     public void execute() throws BuildException {
1:             beginOutput();
1:             buildOverview();
1:             buildNewFeatures();
1:             buildFixedBugsList();
1:             buildReleaseNoteIssuesList();
1:             buildEnvironment();
1:             replaceVariables();
1:             printOutput();
1:             printMissingReleaseNotes();
1:             printErrors();
1:         catch (Throwable t) {
1:             throw new BuildException("Error running ReleaseNotesGenerator: " +
1:                     t.getMessage(), t);
0: 
0: 
1:      * Start the RELEASE_NOTES html docment.
1:     private void beginOutput() throws Exception {
0:         String titleText = "Release Notes for Derby " + releaseID;
1:         Element html = outputDoc.createElement(HTML);
1:         Element title = createTextElement(outputDoc, "title", titleText);
1:         Element body = outputDoc.createElement(BODY);
1:         outputDoc.appendChild(html);
1:         html.appendChild(title);
1:         html.appendChild(body);
1:         Element bannerBlock = createHeader(body, BANNER_LEVEL, titleText);
1:         buildDelta(bannerBlock);
0: 
1:         Element toc = createList(body);
0: 
1:         createSection(body, MAIN_SECTION_LEVEL, toc,
1:                 OVERVIEW_SECTION, OVERVIEW_SECTION);
1:         createSection(body, MAIN_SECTION_LEVEL, toc,
1:                 NEW_FEATURES_SECTION, NEW_FEATURES_SECTION);
1:         createSection(body, MAIN_SECTION_LEVEL, toc,
1:                 BUG_FIXES_SECTION, BUG_FIXES_SECTION);
1:         createSection(body, MAIN_SECTION_LEVEL, toc,
1:                 ISSUES_SECTION, ISSUES_SECTION);
1:         createSection(body, MAIN_SECTION_LEVEL, toc,
1:                 BUILD_ENVIRONMENT_SECTION, BUILD_ENVIRONMENT_SECTION);
/////////////////////////////////////////////////////////////////////////
1:     private void buildOverview() throws Exception {
1:         cloneChildren(summary.getElementByTagName(SUM_OVERVIEW),
1:                 getSection(outputDoc, MAIN_SECTION_LEVEL, OVERVIEW_SECTION));
0: 
/////////////////////////////////////////////////////////////////////////
1:     private void buildNewFeatures() throws Exception {
1:         cloneChildren(summary.getElementByTagName(SUM_NEW_FEATURES),
1:                 getSection(outputDoc, MAIN_SECTION_LEVEL,
1:                 NEW_FEATURES_SECTION));
0: 
/////////////////////////////////////////////////////////////////////////
1:      * @param gs state
1:     private void buildFixedBugsList()
1:         Element bugListSection = getSection(outputDoc, MAIN_SECTION_LEVEL,
1:                 BUG_FIXES_SECTION );
0: 
1:         String deltaStatement =
1:             ". These issues are not addressed in the preceding " +
1:             previousReleaseID + " release.";
1:         addParagraph(bugListSection, deltaStatement);
1:         Element table = createTable
1:             (bugListSection, DEFAULT_TABLE_BORDER_WIDTH,
1:             new String[] { ISSUE_ID_HEADLINE, DESCRIPTION_HEADLINE });
0:         for (Iterator i = JiraIssue.createJiraIssueList(bugListDoc,
0:                 excludeReleaseIDList).iterator(); i.hasNext();) {
1:             JiraIssue issue = (JiraIssue) i.next();
0:             println("Fixed: "+ issue.getKey());
1:             Element row = insertRow(table);
1:             Element linkColumn = insertColumn(row);
1:             Element descriptionColumn = insertColumn(row);
1:             Element hotlink = createLink(outputDoc, issue.getJiraAddress(),
0:                     issue.getKey());
1:             Text title = outputDoc.createTextNode(issue.getTitle());
1:             linkColumn.appendChild(hotlink);
1:             descriptionColumn.appendChild(title);
0: 
/////////////////////////////////////////////////////////////////////////
1:     private void buildReleaseNoteIssuesList()
1:         throws Exception {
1:         Element issuesSection = getSection(outputDoc, MAIN_SECTION_LEVEL,
1:                 ISSUES_SECTION);
1:         String deltaStatement =
1:             "), Derby release " + releaseID + " introduces the following " +
1:             "new features " +
1:         addParagraph(issuesSection, deltaStatement);
1:         Element toc = createList(issuesSection);
0:         for (Iterator i = JiraIssue.createJiraIssueList(releaseNotesDoc,
0:                 excludeReleaseIDList).iterator(); i.hasNext();) {
1:             JiraIssue issue = (JiraIssue) i.next();
1:             if (issue.hasReleaseNote()) {
1:                 Node summaryText = null;
1:                 Element details = null;
0:                 try {
1:                     URL url = new URL(issue.getReleaseNoteAddress());
1:                     InputStream is = url.openStream();
1:                     Document releaseNote = releaseNoteReader.getReleaseNote(is);
1:                     summaryText = releaseNoteReader.
1:                             getReleaseNoteSummary(releaseNote);
1:                     details = releaseNoteReader.
1:                             getReleaseNoteDetails(releaseNote);
1:                 } catch (Throwable t) {
1:                     errors.add(formatError("Unable to read or parse " +
0:                             "release note for " +
1:                             issue.getKey(), t));
1:                     missingReleaseNotes.add(issue);
0:                     continue;
0:                 }
0:                 String key = "Note for " + issue.getKey();
0:                 println("Release note: "+issue.getKey()+" - "+issue.getTitle());
0:                 Element paragraph = outputDoc.createElement(PARAGRAPH);
1:                 paragraph.appendChild(outputDoc.createTextNode(key + ": "));
1:                 cloneChildren(summaryText, paragraph);
1:                 insertLine(issuesSection);
1:                 Element issueSection = createSection(issuesSection,
1:                         ISSUE_DETAIL_LEVEL, toc, key, paragraph);
1:                 cloneChildren(details, issueSection);
/////////////////////////////////////////////////////////////////////////
1:     private void buildEnvironment()
0:         throws Exception {
1:         Element environmentSection = getSection(outputDoc, MAIN_SECTION_LEVEL,
1:                 BUILD_ENVIRONMENT_SECTION );
1:         String desc = "Derby release " + releaseID +
1:                 " was built using the following environment:";
1:         addParagraph(environmentSection, desc);
1:         Element list = createList(environmentSection);
1:         addHeadlinedItem(list, BRANCH_HEADLINE,
1:                 "Source code came from the " + branch + " branch.");
1:         addHeadlinedItem(list, MACHINE_HEADLINE,
1:                 summary.getTextByTagName(SUM_MACHINE));
1:         addHeadlinedItem(list, ANT_HEADLINE,
1:                 summary.getTextByTagName(SUM_ANT_VERSION));
0:         addHeadlinedItem(list, JDK14_HEADLINE,
0:                 summary.getTextByTagName(SUM_JDK14));
0:         addHeadlinedItem(list, JAVA6_HEADLINE,
0:                 summary.getTextByTagName(SUM_JAVA6));
1:         addHeadlinedItem(list, COMPILER_HEADLINE,
1:                 summary.getTextByTagName(SUM_COMPILER));
0:         addHeadlinedItem(list, JSR169_HEADLINE,
0:                 summary.getTextByTagName(SUM_JSR169));
/////////////////////////////////////////////////////////////////////////
1:     private void printMissingReleaseNotes() throws Exception {
1:         if (missingReleaseNotes.isEmpty()) {
1:             return;
0:         }
1:         println("The following JIRA issues still need release notes or the " +
1:                 "release notes provided are unreadable:");
1:         for (Iterator i = missingReleaseNotes.iterator(); i.hasNext();) {
1:             JiraIssue issue = (JiraIssue) i.next();
1:             println("\t" + issue.getKey() + "\t" + issue.getTitle());
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         setOutputFileName( args[ idx++ ] );
============================================================================