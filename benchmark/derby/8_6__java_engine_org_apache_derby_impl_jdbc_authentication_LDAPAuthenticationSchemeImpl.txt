1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.jdbc.authentication.LDAPAuthenticationSchemeImpl
1:345de35: 
1:88a3cb9:    Licensed to the Apache Software Foundation (ASF) under one or more
1:88a3cb9:    contributor license agreements.  See the NOTICE file distributed with
1:88a3cb9:    this work for additional information regarding copyright ownership.
1:88a3cb9:    The ASF licenses this file to you under the Apache License, Version 2.0
1:88a3cb9:    (the "License"); you may not use this file except in compliance with
1:88a3cb9:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
14:eac0369: 
3:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.jdbc.authentication;
1:eac0369: 
1:2544922: import java.io.FileOutputStream;
1:2544922: import java.io.IOException;
1:2544922: import java.security.AccessController;
1:2544922: import java.security.PrivilegedActionException;
1:2544922: import java.security.PrivilegedExceptionAction;
1:850aba4: import java.util.Properties;
1:850aba4: import javax.naming.*;
1:850aba4: import javax.naming.directory.*;
1:850aba4: import org.apache.derby.authentication.UserAuthenticator;
1:850aba4: import org.apache.derby.iapi.reference.MessageId;
1:850aba4: import org.apache.derby.iapi.services.monitor.Monitor;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:850aba4: import org.apache.derby.iapi.util.StringUtil;
1:eac0369: 
4:eac0369: /**
1:94f158a:  * This is the Derby LDAP authentication scheme implementation.
2:eac0369:  *
1:eac0369:  * JNDI system/environment properties can be set at the database
1:eac0369:  * level as database properties. They will be picked-up and set in
1:eac0369:  * the JNDI initial context if any are found.
1:eac0369:  *
1:eac0369:  * We do connect first to the LDAP server in order to retrieve the
1:eac0369:  * user's distinguished name (DN) and then we reconnect and try to
1:eac0369:  * authenticate with the user's DN and passed-in password.
1:eac0369:  *
1:eac0369:  * In 2.0 release, we first connect to do a search (user full DN lookup).
1:eac0369:  * This initial lookup can be done through anonymous bind or using special
1:eac0369:  * LDAP search credentials that the user may have configured on the
1:eac0369:  * LDAP settings for the database or the system.
1:eac0369:  * It is a typical operation with LDAP servers where sometimes it is
1:eac0369:  * hard to tell/guess in advance a users' full DN's.
1:eac0369:  *
1:eac0369:  * NOTE: In a future release, we will cache/maintain the user DN within
1:94f158a:  * the the Derby database or system to avoid the initial lookup.
1:eac0369:  * Also note that LDAP search/retrieval operations are usually very fast.
1:eac0369:  *
1:eac0369:  * The default LDAP url is ldap:/// (ldap://localhost:389/)
1:eac0369:  *
1:eac0369:  * @see org.apache.derby.authentication.UserAuthenticator 
1:eac0369:  *
1:eac0369:  */
1:eac0369: 
1:eac0369: public final class LDAPAuthenticationSchemeImpl
1:eac0369: extends JNDIAuthenticationSchemeBase
2:eac0369: {
1:eac0369: 	private static final String dfltLDAPURL = "ldap://";
1:eac0369: 
1:eac0369: 	private String searchBaseDN;
1:eac0369: 
1:eac0369: 	private String leftSearchFilter; // stick in uid in between
1:eac0369: 	private String rightSearchFilter;
1:eac0369: 	private boolean useUserPropertyAsDN;
1:eac0369: 
1:eac0369: 	// Search Auth DN & Password if anonymous search not allowed
1:eac0369: 	private String searchAuthDN;
1:eac0369: 	private String searchAuthPW;
1:eac0369: 	// we only want the user's full DN in return
1:eac0369: 	private static final String[] attrDN = {"dn"};								;
1:eac0369: 
1:eac0369: 	//
1:94f158a: 	// Derby LDAP Configuration properties
1:eac0369: 	//
1:eac0369: 	private static final String LDAP_SEARCH_BASE =
1:eac0369: 								"derby.authentication.ldap.searchBase";
1:eac0369: 	private static final String LDAP_SEARCH_FILTER =
1:eac0369: 								"derby.authentication.ldap.searchFilter";
1:eac0369: 	private static final String LDAP_SEARCH_AUTH_DN =
1:eac0369: 								"derby.authentication.ldap.searchAuthDN";
1:eac0369: 	private static final String LDAP_SEARCH_AUTH_PW =
1:eac0369: 								"derby.authentication.ldap.searchAuthPW";
1:eac0369: 	private static final String LDAP_LOCAL_USER_DN =
1:eac0369: 								"derby.user";
1:eac0369: 	private static final String LDAP_SEARCH_FILTER_USERNAME =
1:eac0369: 								"%USERNAME%";
1:eac0369: 
1:eac0369: 	public LDAPAuthenticationSchemeImpl(JNDIAuthenticationService as, Properties dbProperties) {
1:eac0369: 
1:eac0369: 		super(as, dbProperties);
10:eac0369: 	}
1:9c68d54: 
1:eac0369: 	/**
1:eac0369: 	 * Authenticate the passed-in user's credentials.
1:eac0369: 	 *
1:eac0369: 	 * We authenticate against a LDAP Server.
1:eac0369: 	 *
1:eac0369: 	 *
1:eac0369: 	 * @param userName		The user's name used to connect to JBMS system
1:eac0369: 	 * @param userPassword	The user's password used to connect to JBMS system
1:eac0369: 	 * @param databaseName	The database which the user wants to connect to.
1:eac0369: 	 * @param info			Additional jdbc connection info.
1:2544922: 	 */
1:eac0369: 	public boolean	authenticateUser(String userName,
1:eac0369: 								 String userPassword,
1:eac0369: 								 String databaseName,
1:eac0369: 								 Properties info
1:eac0369: 								)
1:eac0369: 								throws java.sql.SQLException
1:eac0369: 	{
1:eac0369: 		if ( ((userName == null) || (userName.length() == 0)) ||
1:eac0369: 			 ((userPassword == null) || (userPassword.length() == 0)) )
1:eac0369: 		{
1:eac0369: 			// We don't tolerate 'guest' user for now as well as
1:eac0369: 			// null password.
1:eac0369: 			// If a null password is passed upon authenticating a user
1:eac0369: 			// through LDAP, then the LDAP server might consider this as
1:eac0369: 			// anonymous bind and therefore no authentication will be done
1:eac0369: 			// at all.
1:eac0369: 			return false;
1:eac0369: 		}
1:9c68d54: 
1:eac0369: 
1:eac0369: 		Exception e;
2:2544922: 		try {
1:eac0369: 			Properties env = (Properties) initDirContextEnv.clone();
1:eac0369: 			String userDN = null;
1:eac0369: 			//
1:eac0369: 			// Retrieve the user's DN (Distinguished Name)
1:eac0369: 			// If we're asked to look it up locally, do it first
1:eac0369: 			// and if we don't find it, we go against the LDAP
1:eac0369: 			// server for a look-up (search)
1:eac0369: 			//
1:eac0369: 			if (useUserPropertyAsDN)
1:eac0369: 				userDN =
1:eac0369: 					authenticationService.getProperty(
1:eac0369: 						org.apache.derby.iapi.reference.Property.USER_PROPERTY_PREFIX);
1:eac0369: 
1:eac0369: 			if (userDN == (String) null) {
1:eac0369: 				userDN = getDNFromUID(userName);
1:9c68d54: 			}
1:eac0369: 		
2:eac0369: 			if (SanityManager.DEBUG)
1:eac0369: 			{
2:eac0369: 				if (SanityManager.DEBUG_ON(
2:eac0369: 						AuthenticationServiceBase.AuthenticationTrace)) {
1:eac0369: 					SanityManager.DEBUG(AuthenticationServiceBase.AuthenticationTrace,
1:eac0369: 					"User DN = ["+ userDN+"]\n");
1:2544922: 				}
1:eac0369: 			}
1:2544922: 
1:eac0369: 			env.put(Context.SECURITY_PRINCIPAL, userDN);
1:eac0369: 			env.put(Context.SECURITY_CREDENTIALS, userPassword);
1:2544922: 			
1:eac0369: 			// Connect & authenticate (bind) to the LDAP server now
1:eac0369: 
1:eac0369: 			// it is happening right here
1:2544922: 
1:2544922:             DirContext ctx =   privInitialDirContext(env);
1:2544922:           
1:2544922:             
1:eac0369: 
1:eac0369: 			// if the above was successfull, then username and
1:eac0369: 			// password must be correct
1:eac0369: 			return true;
1:eac0369: 
1:eac0369: 		} catch (javax.naming.AuthenticationException jndiae) {
1:eac0369: 			return false;
1:eac0369: 
1:eac0369: 		} catch (javax.naming.NameNotFoundException jndinnfe) {
1:eac0369: 			return false;
1:eac0369: 
1:eac0369: 		} catch (javax.naming.NamingException jndine) {
1:eac0369: 			e = jndine;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		throw getLoginSQLException(e);
1:eac0369: 	}
1:2544922: 
1:2544922: 	
1:eac0369: 
1:2544922:     /**
1:2544922:      * Call new InitialDirContext in a privilege block
1:2544922:      * @param env environment used to create the initial DirContext. Null indicates an empty environment.
1:2544922:      * @return an initial DirContext using the supplied environment. 
1:2544922:      */
1:2544922:     private DirContext privInitialDirContext(final Properties env) throws NamingException {
1:2544922:         try {
1:850aba4:             return AccessController.doPrivileged(
1:850aba4:                     new PrivilegedExceptionAction<DirContext>() {
1:850aba4:                         public DirContext run() throws NamingException {
1:2544922:                             return new InitialDirContext(env);
1:2544922:                     }
1:850aba4:                 });
1:850aba4:         } catch (PrivilegedActionException pae) {
1:850aba4:             throw (NamingException) pae.getCause();
1:850aba4:         }
1:850aba4:     }
1:2544922: 
1:2544922:     /**
1:eac0369: 	 * This method basically tests and sets default/expected JNDI properties
1:eac0369: 	 * for the JNDI provider scheme (here it is LDAP).
1:eac0369: 	 *
1:eac0369: 	 **/
1:eac0369: 	protected void setJNDIProviderProperties()
1:eac0369: 	{
1:2544922: 
1:eac0369: 		// check if we're told to use a different initial context factory
1:eac0369: 		if (initDirContextEnv.getProperty(
1:eac0369: 							Context.INITIAL_CONTEXT_FACTORY) == (String) null)
1:eac0369: 		{
1:eac0369: 			initDirContextEnv.put(Context.INITIAL_CONTEXT_FACTORY,
1:eac0369: 									  "com.sun.jndi.ldap.LdapCtxFactory");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// retrieve LDAP server name/port# and construct LDAP url
1:eac0369: 		if (initDirContextEnv.getProperty(
1:eac0369: 							Context.PROVIDER_URL) == (String) null)
1:eac0369: 		{
1:eac0369: 			// Now we construct the LDAP url and expect to find the LDAP Server
1:eac0369: 			// name.
1:eac0369: 			//
1:eac0369: 			String ldapServer = authenticationService.getProperty(
1:eac0369: 						org.apache.derby.iapi.reference.Property.AUTHENTICATION_SERVER_PARAMETER);
1:eac0369: 
1:eac0369: 			if (ldapServer == (String) null) {
1:eac0369: 
1:eac0369: 				// we do expect a LDAP Server name to be configured
1:eac0369: 				Monitor.logTextMessage(
1:eac0369: 					MessageId.AUTH_NO_LDAP_HOST_MENTIONED,
1:eac0369: 						 org.apache.derby.iapi.reference.Property.AUTHENTICATION_SERVER_PARAMETER);
1:eac0369: 
1:eac0369: 				this.providerURL = dfltLDAPURL + "/";
1:eac0369: 
1:eac0369: 			} else {
1:eac0369: 
1:a70379d: 				if (ldapServer.startsWith(dfltLDAPURL) || ldapServer.startsWith("ldaps://") )
1:eac0369: 					this.providerURL = ldapServer;
1:eac0369: 				else if (ldapServer.startsWith("//"))
1:eac0369: 					this.providerURL = "ldap:" + ldapServer;
1:2544922: 				else
1:eac0369: 					this.providerURL = dfltLDAPURL + ldapServer;
1:2544922: 			}
1:eac0369: 			initDirContextEnv.put(Context.PROVIDER_URL, providerURL);
1:2544922: 		}
1:2544922: 
1:eac0369: 		// check if we should we use a particular authentication method
1:eac0369: 		// we assume the ldap server supports this authentication method
1:eac0369: 		// (Netscape DS 3.1.1 does not support CRAM-MD5 for instance)
1:eac0369: 		if (initDirContextEnv.getProperty(
1:eac0369: 							Context.SECURITY_AUTHENTICATION) == (String) null)
1:eac0369: 		{
1:eac0369: 			// set the default to be clear userName/Password as not of all the
1:eac0369: 			// LDAP server(s) support CRAM-MD5 (especially ldap v2 ones)
1:eac0369: 			// Netscape Directory Server 3.1.1 does not support CRAM-MD5
1:eac0369: 			// (told by Sun JNDI engineering). Netscape DS 4.0 allows SASL
1:eac0369: 			// plug-ins to be installed and that can be used as authentication
1:eac0369: 			// method.
1:eac0369: 			//
1:eac0369: 			initDirContextEnv.put(Context.SECURITY_AUTHENTICATION,
1:eac0369: 									  "simple"
1:eac0369: 									  );
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// Retrieve and set the search base (root) DN to use on the ldap
1:eac0369: 		// server.
1:eac0369: 		String ldapSearchBase =
1:eac0369: 					authenticationService.getProperty(LDAP_SEARCH_BASE);
1:eac0369: 		if (ldapSearchBase != (String) null)
1:eac0369: 			this.searchBaseDN = ldapSearchBase;
2:eac0369: 		else
1:eac0369: 			this.searchBaseDN = "";
1:eac0369: 
1:eac0369: 		// retrieve principal and credentials for the search bind as the
1:eac0369: 		// user may not want to allow anonymous binds (for searches)
1:eac0369: 		this.searchAuthDN =
1:eac0369: 					authenticationService.getProperty(LDAP_SEARCH_AUTH_DN);
1:eac0369: 		this.searchAuthPW =
1:eac0369: 					authenticationService.getProperty(LDAP_SEARCH_AUTH_PW);
1:eac0369: 
1:eac0369: 		//
1:eac0369: 		// Construct the LDAP search filter:
1:eac0369: 		//
1:eac0369: 		// If we were told to use a special search filther, we do so;
1:eac0369: 		// otherwise we use our default search filter.
1:eac0369: 		// The user may have set the search filter 3 different ways:
1:eac0369: 		//
1:eac0369: 		// - if %USERNAME% was found in the search filter, then we
1:eac0369: 		// will substitute this with the passed-in uid at runtime.
1:eac0369: 		//
1:eac0369: 		// - if "derby.user" is the search filter value, then we
1:eac0369: 		// will assume the user's DN can be found in the system or
1:eac0369: 		// database property "derby.user.<uid>" . If the property
1:eac0369: 		// does not exist, then we will do a normal lookup with our
1:eac0369: 		// default search filter; otherwise we will perform an
1:eac0369: 		// authenticated bind to the LDAP server using the found DN.
1:eac0369: 		//
1:eac0369: 		// - if neither of the 2 previous values were found, then we use
1:eac0369: 		// our default search filter and we will substitute insert the
1:eac0369: 		// uid passed at runtime into our default search filter.
1:eac0369: 		//
1:eac0369: 		String searchFilterProp =
1:eac0369: 					authenticationService.getProperty(LDAP_SEARCH_FILTER);
1:eac0369: 		
1:eac0369: 		if (searchFilterProp == (String) null)
1:eac0369: 		{
1:eac0369: 			// use our default search filter
1:eac0369: 			this.leftSearchFilter = "(&(objectClass=inetOrgPerson)(uid=";
1:eac0369: 			this.rightSearchFilter = "))";
1:eac0369: 
1:eac0369: 		} else if (StringUtil.SQLEqualsIgnoreCase(searchFilterProp,LDAP_LOCAL_USER_DN)) {
1:eac0369: 
1:eac0369: 			// use local user DN in derby.user.<uid>
1:eac0369: 			this.leftSearchFilter = "(&(objectClass=inetOrgPerson)(uid=";
1:eac0369: 			this.rightSearchFilter = "))";
1:eac0369: 			this.useUserPropertyAsDN = true;
1:eac0369: 
1:eac0369: 		} else if (searchFilterProp.indexOf(
1:eac0369: 									LDAP_SEARCH_FILTER_USERNAME) != -1) {
1:eac0369: 
1:eac0369: 			// user has set %USERNAME% in the search filter
1:eac0369: 			this.leftSearchFilter = searchFilterProp.substring(0,
1:eac0369: 				searchFilterProp.indexOf(LDAP_SEARCH_FILTER_USERNAME));
1:eac0369: 			this.rightSearchFilter = searchFilterProp.substring(
1:eac0369: 				searchFilterProp.indexOf(LDAP_SEARCH_FILTER_USERNAME)+
1:eac0369: 				(int) LDAP_SEARCH_FILTER_USERNAME.length());
1:eac0369: 
1:eac0369: 
1:eac0369: 		} else	{ // add this search filter to ours
1:eac0369: 
1:eac0369: 			// complement this search predicate to ours
1:eac0369: 			this.leftSearchFilter = "(&("+searchFilterProp+")"+
1:eac0369: 									"(objectClass=inetOrgPerson)(uid=";
1:eac0369: 			this.rightSearchFilter = "))";
1:eac0369: 
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			if (SanityManager.DEBUG_ON(
1:eac0369: 						AuthenticationServiceBase.AuthenticationTrace)) {
1:eac0369: 
1:eac0369: 				java.io.PrintWriter iDbgStream =
1:eac0369: 					SanityManager.GET_DEBUG_STREAM();
1:eac0369: 
1:eac0369: 				iDbgStream.println(
1:eac0369: 								"\n\n+ LDAP Authentication Configuration:\n"+
1:eac0369: 								"   - provider URL ["+this.providerURL+"]\n"+
1:eac0369: 								"   - search base ["+this.searchBaseDN+"]\n"+
1:eac0369: 								"   - search filter to be [" +
1:eac0369: 								this.leftSearchFilter + "<uid>" +
1:eac0369: 								this.rightSearchFilter + "]\n" +
1:eac0369: 								"   - use local DN [" +
1:eac0369: 								(useUserPropertyAsDN ? "true" : "false") +
1:eac0369: 								"]\n"
1:eac0369: 								);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:850aba4:         if (SanityManager.DEBUG &&
1:850aba4:             SanityManager.DEBUG_ON(
1:850aba4:                 AuthenticationServiceBase.AuthenticationTrace)) {
1:eac0369: 
1:850aba4:             // This tracing needs some investigation and cleanup.
1:850aba4:             // 1) It creates the file in user.dir instead of derby.system.home
1:850aba4:             // 2) It doesn't seem to work. The file is empty after successful
1:850aba4:             //    and unsuccessful ldap connects. Perhaps the fileOutputStream
1:850aba4:             // is never flushed and closed.
1:850aba4:             // I (Kathey Marsden) wrapped this in a priv block and kept the
1:850aba4:             // previous behaviour that it will not stop processing if file
1:850aba4:             // creation fails. Perhaps that should be investigated as well.
1:850aba4:             FileOutputStream fos = null;
1:850aba4:             try {
1:850aba4:                 fos = AccessController.doPrivileged(
1:850aba4:                     new PrivilegedExceptionAction<FileOutputStream>() {
1:850aba4:                         public FileOutputStream run() throws IOException {
1:850aba4:                             return new FileOutputStream("DerbyLDAP.out");
1:850aba4:                         }
1:850aba4:                     });
1:850aba4:             } catch (PrivilegedActionException pae) {
1:850aba4:                 // If trace file creation fails do not stop execution.
1:850aba4:             }
1:850aba4:             if (fos != null) {
1:850aba4:                 initDirContextEnv.put("com.sun.naming.ldap.trace.ber", fos);
1:850aba4:             }
1:850aba4:         }
1:2544922: 	}
1:2544922: 
1:2544922: 
1:2544922: 	/**
1:eac0369: 	 * Search for the full user's DN in the LDAP server.
1:eac0369: 	 * LDAP server bind may or not be anonymous.
1:2544922: 	 *
1:eac0369: 	 * If the admin does not want us to do anonymous bind/search, then we
1:eac0369: 	 * must have been given principal/credentials in order to successfully
1:eac0369: 	 * bind to perform the user's DN search.
1:eac0369: 	 *
1:eac0369: 	 * @exception NamingException if could not retrieve the user DN.
1:eac0369: 	 **/
1:eac0369: 	private String getDNFromUID(String uid)
1:eac0369: 		throws javax.naming.NamingException
1:eac0369: 	{
1:eac0369: 		//
1:eac0369: 		// We bind to the LDAP server here
1:eac0369: 		// Note that this bind might be anonymous (if anonymous searches
1:eac0369: 		// are allowed in the LDAP server, or authenticated if we were
1:eac0369: 		// told/configured to.
1:eac0369: 		//
1:eac0369: 		Properties env = null;
1:eac0369: 		if (this.searchAuthDN != (String) null) {
1:eac0369: 			env = (Properties) initDirContextEnv.clone();
1:eac0369: 			env.put(Context.SECURITY_PRINCIPAL, this.searchAuthDN);
1:eac0369: 			env.put(Context.SECURITY_CREDENTIALS, this.searchAuthPW);
1:2544922: 		}
1:eac0369: 		else
1:eac0369: 			env = initDirContextEnv;
1:2544922: 
1:2544922: 		DirContext ctx = privInitialDirContext(env);
1:eac0369: 
1:eac0369: 		// Construct Search Filter
1:eac0369: 		SearchControls ctls = new SearchControls();
1:eac0369: 		// Set-up a LDAP subtree search scope
1:eac0369: 		ctls.setSearchScope(SearchControls.SUBTREE_SCOPE);
1:eac0369: 
1:eac0369: 		// Just retrieve the DN
1:eac0369: 		ctls.setReturningAttributes(attrDN);
1:eac0369: 
1:eac0369: 		String searchFilter =
1:eac0369: 						this.leftSearchFilter + uid + this.rightSearchFilter; 
1:eac0369: 		NamingEnumeration results =
1:eac0369: 						ctx.search(searchBaseDN, searchFilter, ctls);
1:eac0369: 			
1:eac0369: 		// If we did not find anything then login failed
1:eac0369: 		if (results == null || !results.hasMore())
1:eac0369: 			throw new NameNotFoundException();
1:eac0369: 			
1:eac0369: 		SearchResult result = (SearchResult)results.next();
1:eac0369: 		
1:eac0369: 		if (results.hasMore())
1:eac0369: 		{
1:eac0369: 			// This is a login failure as we cannot assume the first one
1:eac0369: 			// is the valid one.
1:eac0369: 			if (SanityManager.DEBUG)
1:eac0369: 			{
1:eac0369: 				if (SanityManager.DEBUG_ON(
1:eac0369: 						AuthenticationServiceBase.AuthenticationTrace)) {
1:eac0369: 
1:eac0369: 					java.io.PrintWriter iDbgStream =
1:eac0369: 						SanityManager.GET_DEBUG_STREAM();
1:eac0369: 
1:eac0369: 					iDbgStream.println(
1:eac0369: 						" - LDAP Authentication request failure: "+
1:eac0369: 						"search filter [" + searchFilter + "]"+
1:eac0369: 						", retrieve more than one occurence in "+
1:eac0369: 						"LDAP server [" + this.providerURL + "]");
1:2544922: 				}
1:eac0369: 			}
1:eac0369: 			throw new NameNotFoundException();
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		NameParser parser = ctx.getNameParser(searchBaseDN);
1:eac0369: 		Name userDN = parser.parse(searchBaseDN);
1:eac0369: 
1:eac0369: 		if (userDN == (Name) null)
1:eac0369: 			// This should not happen in theory
1:eac0369: 			throw new NameNotFoundException();
1:eac0369: 		else
1:eac0369: 			userDN.addAll(parser.parse(result.getName()));
1:eac0369: 		
1:eac0369: 		// Return the full user's DN
1:eac0369: 		return userDN.toString();
1:eac0369: 	}
1:eac0369: }
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:850aba4
/////////////////////////////////////////////////////////////////////////
1: import java.util.Properties;
1: import javax.naming.*;
1: import javax.naming.directory.*;
1: import org.apache.derby.authentication.UserAuthenticator;
1: import org.apache.derby.iapi.reference.MessageId;
1: import org.apache.derby.iapi.services.monitor.Monitor;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.util.StringUtil;
/////////////////////////////////////////////////////////////////////////
1:             return AccessController.doPrivileged(
1:                     new PrivilegedExceptionAction<DirContext>() {
1:                         public DirContext run() throws NamingException {
1:                 });
1:         } catch (PrivilegedActionException pae) {
1:             throw (NamingException) pae.getCause();
1:         }
1:     }
/////////////////////////////////////////////////////////////////////////
1:         if (SanityManager.DEBUG &&
1:             SanityManager.DEBUG_ON(
1:                 AuthenticationServiceBase.AuthenticationTrace)) {
1:             // This tracing needs some investigation and cleanup.
1:             // 1) It creates the file in user.dir instead of derby.system.home
1:             // 2) It doesn't seem to work. The file is empty after successful
1:             //    and unsuccessful ldap connects. Perhaps the fileOutputStream
1:             // is never flushed and closed.
1:             // I (Kathey Marsden) wrapped this in a priv block and kept the
1:             // previous behaviour that it will not stop processing if file
1:             // creation fails. Perhaps that should be investigated as well.
1:             FileOutputStream fos = null;
1:             try {
1:                 fos = AccessController.doPrivileged(
1:                     new PrivilegedExceptionAction<FileOutputStream>() {
1:                         public FileOutputStream run() throws IOException {
1:                             return new FileOutputStream("DerbyLDAP.out");
1:                         }
1:                     });
1:             } catch (PrivilegedActionException pae) {
1:                 // If trace file creation fails do not stop execution.
1:             }
1:             if (fos != null) {
1:                 initDirContextEnv.put("com.sun.naming.ldap.trace.ber", fos);
1:             }
1:         }
commit:a70379d
/////////////////////////////////////////////////////////////////////////
1: 				if (ldapServer.startsWith(dfltLDAPURL) || ldapServer.startsWith("ldaps://") )
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:9c68d54
/////////////////////////////////////////////////////////////////////////
0:                                     fos =  ((FileOutputStream)AccessController.doPrivileged(
0:                                                 new PrivilegedExceptionAction() {
0:                                                     public Object run() throws SecurityException, java.io.IOException {
0:                                                         return new  FileOutputStream("DerbyLDAP.out");
1:                                                     }
0:                                                 }));
0:                                 } catch (PrivilegedActionException pae) {
0:                                     // If trace file creation fails do not stop execution.                                    
/////////////////////////////////////////////////////////////////////////
1: 	
1: 	
commit:2544922
/////////////////////////////////////////////////////////////////////////
1: import java.io.FileOutputStream;
1: import java.io.IOException;
1: import java.security.AccessController;
1: import java.security.PrivilegedActionException;
1: import java.security.PrivilegedExceptionAction;
/////////////////////////////////////////////////////////////////////////
1: 
1:             DirContext ctx =   privInitialDirContext(env);
1:           
1:             
/////////////////////////////////////////////////////////////////////////
1: 	
1: 
1:     /**
1:      * Call new InitialDirContext in a privilege block
1:      * @param env environment used to create the initial DirContext. Null indicates an empty environment.
1:      * @return an initial DirContext using the supplied environment. 
1:      */
1:     private DirContext privInitialDirContext(final Properties env) throws NamingException {
1:         try {
0:             return ((InitialDirContext)AccessController.doPrivileged(
0:                     new PrivilegedExceptionAction() {
0:                         public Object run() throws SecurityException, NamingException {
1:                             return new InitialDirContext(env);
1:                     }
0:                 }));
0:     } catch (PrivilegedActionException pae) {
0:             Exception e = pae.getException();
1:        
0:             if (e instanceof NamingException)
0:                     throw (NamingException)e;
1:             else
0:                 throw (SecurityException)e;
1:         }   
1:    
1:     }   
1: 
1:     /**
/////////////////////////////////////////////////////////////////////////
1:                              
0:                                 // This tracing needs some investigation and cleanup.
0:                                 // 1) It creates the file in user.dir instead of derby.system.home
0:                                 // 2) It doesn't seem to work. The file is empty after successful
0:                                 //    and unsuccessful ldap connects.  Perhaps the fileOutputStream
0:                                 // is never flushed and closed.
0:                                 // I (Kathey Marsden) wrapped this in a priv block and kept the previous
0:                                 // behaviour that it will not stop processing if file 
0:                                 // creation fails. Perhaps that should be investigated as well.
0:                                 FileOutputStream fos = null;
1:                                 try {
0:                                     fos = privNewFileOutputStream("DerbyLDAP.out");
0:                                 } catch (Exception e) {
0:                                     // If file creation fails do not stop execution.
1:                                 }
0:                                 if (fos != null)
0:                                     initDirContextEnv.put("com.sun.naming.ldap.trace.ber",fos);
1: 
1: 				
0:      * Construct a new FileOutputStream in a privilege block.
1:      * 
0: 	 * @param fileName Filename to create
0: 	 * @return 
0: 	 * @throws IOException
1: 	 */
0: 	private FileOutputStream privNewFileOutputStream(final String fileName) throws IOException{
1: 	    try {
0:             return ((FileOutputStream)AccessController.doPrivileged(
0:                         new PrivilegedExceptionAction() {
0:                             public Object run() throws SecurityException, java.io.IOException {
0:                                 return new  FileOutputStream(fileName);
1:                             }
0:                         }));
0:         } catch (PrivilegedActionException pae) {
0:             throw (SecurityException)pae.getException();
1:         }
1:     }
1: 	
1: 
1: 	/**
/////////////////////////////////////////////////////////////////////////
1: 		DirContext ctx = privInitialDirContext(env);
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:94f158a
/////////////////////////////////////////////////////////////////////////
1:  * This is the Derby LDAP authentication scheme implementation.
/////////////////////////////////////////////////////////////////////////
1:  * the the Derby database or system to avoid the initial lookup.
/////////////////////////////////////////////////////////////////////////
1: 	// Derby LDAP Configuration properties
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:88a3cb9
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.jdbc.authentication.LDAPAuthenticationSchemeImpl
1: 
0:    Copyright 1999, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:1f9b9c4
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.jdbc.authentication
0:    (C) Copyright IBM Corp. 1999, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.jdbc.authentication;
1: 
0: import org.apache.derby.iapi.reference.MessageId;
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.services.i18n.MessageService;
0: import org.apache.derby.iapi.jdbc.AuthenticationService;
1: 
0: import org.apache.derby.authentication.UserAuthenticator;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.util.StringUtil;
1: 
0: import javax.naming.*;
0: import javax.naming.directory.*;
1: 
1: 
0: import java.util.Properties;
0: import java.sql.SQLException;
1: 
1: /**
0:  * This is the Cloudscape LDAP authentication scheme implementation.
1:  *
1:  * JNDI system/environment properties can be set at the database
1:  * level as database properties. They will be picked-up and set in
1:  * the JNDI initial context if any are found.
1:  *
1:  * We do connect first to the LDAP server in order to retrieve the
1:  * user's distinguished name (DN) and then we reconnect and try to
1:  * authenticate with the user's DN and passed-in password.
1:  *
1:  * In 2.0 release, we first connect to do a search (user full DN lookup).
1:  * This initial lookup can be done through anonymous bind or using special
1:  * LDAP search credentials that the user may have configured on the
1:  * LDAP settings for the database or the system.
1:  * It is a typical operation with LDAP servers where sometimes it is
1:  * hard to tell/guess in advance a users' full DN's.
1:  *
1:  * NOTE: In a future release, we will cache/maintain the user DN within
0:  * the the cloudscape database or system to avoid the initial lookup.
1:  * Also note that LDAP search/retrieval operations are usually very fast.
1:  *
1:  * The default LDAP url is ldap:/// (ldap://localhost:389/)
1:  *
1:  * @see org.apache.derby.authentication.UserAuthenticator 
1:  *
1:  */
1: 
1: public final class LDAPAuthenticationSchemeImpl
1: extends JNDIAuthenticationSchemeBase
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1999_2004;
1: 	private static final String dfltLDAPURL = "ldap://";
1: 
1: 	private String searchBaseDN;
1: 
1: 	private String leftSearchFilter; // stick in uid in between
1: 	private String rightSearchFilter;
1: 	private boolean useUserPropertyAsDN;
1: 
1: 	// Search Auth DN & Password if anonymous search not allowed
1: 	private String searchAuthDN;
1: 	private String searchAuthPW;
1: 	// we only want the user's full DN in return
1: 	private static final String[] attrDN = {"dn"};								;
1: 
1: 	//
0: 	// Cloudscape LDAP Configuration properties
1: 	//
1: 	private static final String LDAP_SEARCH_BASE =
1: 								"derby.authentication.ldap.searchBase";
1: 	private static final String LDAP_SEARCH_FILTER =
1: 								"derby.authentication.ldap.searchFilter";
1: 	private static final String LDAP_SEARCH_AUTH_DN =
1: 								"derby.authentication.ldap.searchAuthDN";
1: 	private static final String LDAP_SEARCH_AUTH_PW =
1: 								"derby.authentication.ldap.searchAuthPW";
1: 	private static final String LDAP_LOCAL_USER_DN =
1: 								"derby.user";
1: 	private static final String LDAP_SEARCH_FILTER_USERNAME =
1: 								"%USERNAME%";
1: 
1: 	public LDAPAuthenticationSchemeImpl(JNDIAuthenticationService as, Properties dbProperties) {
1: 
1: 		super(as, dbProperties);
1: 	}
1: 
1: 	/**
1: 	 * Authenticate the passed-in user's credentials.
1: 	 *
1: 	 * We authenticate against a LDAP Server.
1: 	 *
1: 	 *
1: 	 * @param userName		The user's name used to connect to JBMS system
1: 	 * @param userPassword	The user's password used to connect to JBMS system
1: 	 * @param databaseName	The database which the user wants to connect to.
1: 	 * @param info			Additional jdbc connection info.
1: 	 */
1: 	public boolean	authenticateUser(String userName,
1: 								 String userPassword,
1: 								 String databaseName,
1: 								 Properties info
1: 								)
1: 								throws java.sql.SQLException
1: 	{
1: 		if ( ((userName == null) || (userName.length() == 0)) ||
1: 			 ((userPassword == null) || (userPassword.length() == 0)) )
1: 		{
1: 			// We don't tolerate 'guest' user for now as well as
1: 			// null password.
1: 			// If a null password is passed upon authenticating a user
1: 			// through LDAP, then the LDAP server might consider this as
1: 			// anonymous bind and therefore no authentication will be done
1: 			// at all.
1: 			return false;
1: 		}
1: 
1: 
1: 		Exception e;
0: 		try {
1: 			Properties env = (Properties) initDirContextEnv.clone();
1: 			String userDN = null;
1: 			//
1: 			// Retrieve the user's DN (Distinguished Name)
1: 			// If we're asked to look it up locally, do it first
1: 			// and if we don't find it, we go against the LDAP
1: 			// server for a look-up (search)
1: 			//
1: 			if (useUserPropertyAsDN)
1: 				userDN =
1: 					authenticationService.getProperty(
1: 						org.apache.derby.iapi.reference.Property.USER_PROPERTY_PREFIX);
1: 
1: 			if (userDN == (String) null) {
1: 				userDN = getDNFromUID(userName);
1: 			}
1: 		
1: 			if (SanityManager.DEBUG)
1: 			{
1: 				if (SanityManager.DEBUG_ON(
1: 						AuthenticationServiceBase.AuthenticationTrace)) {
1: 					SanityManager.DEBUG(AuthenticationServiceBase.AuthenticationTrace,
1: 					"User DN = ["+ userDN+"]\n");
1: 				}
1: 			}
1: 
1: 			env.put(Context.SECURITY_PRINCIPAL, userDN);
1: 			env.put(Context.SECURITY_CREDENTIALS, userPassword);
1: 			
1: 			// Connect & authenticate (bind) to the LDAP server now
1: 
1: 			// it is happening right here
0: 			DirContext ctx = new InitialDirContext(env);
1: 
1: 			// if the above was successfull, then username and
1: 			// password must be correct
1: 			return true;
1: 
1: 		} catch (javax.naming.AuthenticationException jndiae) {
1: 			return false;
1: 
1: 		} catch (javax.naming.NameNotFoundException jndinnfe) {
1: 			return false;
1: 
1: 		} catch (javax.naming.NamingException jndine) {
1: 			e = jndine;
1: 		}
1: 
1: 		throw getLoginSQLException(e);
1: 	}
1: 
1: 	/**
1: 	 * This method basically tests and sets default/expected JNDI properties
1: 	 * for the JNDI provider scheme (here it is LDAP).
1: 	 *
1: 	 **/
1: 	protected void setJNDIProviderProperties()
1: 	{
1: 
1: 		// check if we're told to use a different initial context factory
1: 		if (initDirContextEnv.getProperty(
1: 							Context.INITIAL_CONTEXT_FACTORY) == (String) null)
1: 		{
1: 			initDirContextEnv.put(Context.INITIAL_CONTEXT_FACTORY,
1: 									  "com.sun.jndi.ldap.LdapCtxFactory");
1: 		}
1: 
1: 		// retrieve LDAP server name/port# and construct LDAP url
1: 		if (initDirContextEnv.getProperty(
1: 							Context.PROVIDER_URL) == (String) null)
1: 		{
1: 			// Now we construct the LDAP url and expect to find the LDAP Server
1: 			// name.
1: 			//
1: 			String ldapServer = authenticationService.getProperty(
1: 						org.apache.derby.iapi.reference.Property.AUTHENTICATION_SERVER_PARAMETER);
1: 
1: 			if (ldapServer == (String) null) {
1: 
1: 				// we do expect a LDAP Server name to be configured
1: 				Monitor.logTextMessage(
1: 					MessageId.AUTH_NO_LDAP_HOST_MENTIONED,
1: 						 org.apache.derby.iapi.reference.Property.AUTHENTICATION_SERVER_PARAMETER);
1: 
1: 				this.providerURL = dfltLDAPURL + "/";
1: 
1: 			} else {
1: 
0: 				if (ldapServer.startsWith(dfltLDAPURL))
1: 					this.providerURL = ldapServer;
1: 				else if (ldapServer.startsWith("//"))
1: 					this.providerURL = "ldap:" + ldapServer;
1: 				else
1: 					this.providerURL = dfltLDAPURL + ldapServer;
1: 			}
1: 			initDirContextEnv.put(Context.PROVIDER_URL, providerURL);
1: 		}
1: 
1: 		// check if we should we use a particular authentication method
1: 		// we assume the ldap server supports this authentication method
1: 		// (Netscape DS 3.1.1 does not support CRAM-MD5 for instance)
1: 		if (initDirContextEnv.getProperty(
1: 							Context.SECURITY_AUTHENTICATION) == (String) null)
1: 		{
1: 			// set the default to be clear userName/Password as not of all the
1: 			// LDAP server(s) support CRAM-MD5 (especially ldap v2 ones)
1: 			// Netscape Directory Server 3.1.1 does not support CRAM-MD5
1: 			// (told by Sun JNDI engineering). Netscape DS 4.0 allows SASL
1: 			// plug-ins to be installed and that can be used as authentication
1: 			// method.
1: 			//
1: 			initDirContextEnv.put(Context.SECURITY_AUTHENTICATION,
1: 									  "simple"
1: 									  );
1: 		}
1: 
1: 		// Retrieve and set the search base (root) DN to use on the ldap
1: 		// server.
1: 		String ldapSearchBase =
1: 					authenticationService.getProperty(LDAP_SEARCH_BASE);
1: 		if (ldapSearchBase != (String) null)
1: 			this.searchBaseDN = ldapSearchBase;
1: 		else
1: 			this.searchBaseDN = "";
1: 
1: 		// retrieve principal and credentials for the search bind as the
1: 		// user may not want to allow anonymous binds (for searches)
1: 		this.searchAuthDN =
1: 					authenticationService.getProperty(LDAP_SEARCH_AUTH_DN);
1: 		this.searchAuthPW =
1: 					authenticationService.getProperty(LDAP_SEARCH_AUTH_PW);
1: 
1: 		//
1: 		// Construct the LDAP search filter:
1: 		//
1: 		// If we were told to use a special search filther, we do so;
1: 		// otherwise we use our default search filter.
1: 		// The user may have set the search filter 3 different ways:
1: 		//
1: 		// - if %USERNAME% was found in the search filter, then we
1: 		// will substitute this with the passed-in uid at runtime.
1: 		//
1: 		// - if "derby.user" is the search filter value, then we
1: 		// will assume the user's DN can be found in the system or
1: 		// database property "derby.user.<uid>" . If the property
1: 		// does not exist, then we will do a normal lookup with our
1: 		// default search filter; otherwise we will perform an
1: 		// authenticated bind to the LDAP server using the found DN.
1: 		//
1: 		// - if neither of the 2 previous values were found, then we use
1: 		// our default search filter and we will substitute insert the
1: 		// uid passed at runtime into our default search filter.
1: 		//
1: 		String searchFilterProp =
1: 					authenticationService.getProperty(LDAP_SEARCH_FILTER);
1: 		
1: 		if (searchFilterProp == (String) null)
1: 		{
1: 			// use our default search filter
1: 			this.leftSearchFilter = "(&(objectClass=inetOrgPerson)(uid=";
1: 			this.rightSearchFilter = "))";
1: 
1: 		} else if (StringUtil.SQLEqualsIgnoreCase(searchFilterProp,LDAP_LOCAL_USER_DN)) {
1: 
1: 			// use local user DN in derby.user.<uid>
1: 			this.leftSearchFilter = "(&(objectClass=inetOrgPerson)(uid=";
1: 			this.rightSearchFilter = "))";
1: 			this.useUserPropertyAsDN = true;
1: 
1: 		} else if (searchFilterProp.indexOf(
1: 									LDAP_SEARCH_FILTER_USERNAME) != -1) {
1: 
1: 			// user has set %USERNAME% in the search filter
1: 			this.leftSearchFilter = searchFilterProp.substring(0,
1: 				searchFilterProp.indexOf(LDAP_SEARCH_FILTER_USERNAME));
1: 			this.rightSearchFilter = searchFilterProp.substring(
1: 				searchFilterProp.indexOf(LDAP_SEARCH_FILTER_USERNAME)+
1: 				(int) LDAP_SEARCH_FILTER_USERNAME.length());
1: 
1: 
1: 		} else	{ // add this search filter to ours
1: 
1: 			// complement this search predicate to ours
1: 			this.leftSearchFilter = "(&("+searchFilterProp+")"+
1: 									"(objectClass=inetOrgPerson)(uid=";
1: 			this.rightSearchFilter = "))";
1: 
1: 		}
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			if (SanityManager.DEBUG_ON(
1: 						AuthenticationServiceBase.AuthenticationTrace)) {
1: 
1: 				java.io.PrintWriter iDbgStream =
1: 					SanityManager.GET_DEBUG_STREAM();
1: 
1: 				iDbgStream.println(
1: 								"\n\n+ LDAP Authentication Configuration:\n"+
1: 								"   - provider URL ["+this.providerURL+"]\n"+
1: 								"   - search base ["+this.searchBaseDN+"]\n"+
1: 								"   - search filter to be [" +
1: 								this.leftSearchFilter + "<uid>" +
1: 								this.rightSearchFilter + "]\n" +
1: 								"   - use local DN [" +
1: 								(useUserPropertyAsDN ? "true" : "false") +
1: 								"]\n"
1: 								);
1: 			}
1: 		}
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			if (SanityManager.DEBUG_ON(
1: 						AuthenticationServiceBase.AuthenticationTrace)) {
0: 				try {
0: 					initDirContextEnv.put("com.sun.naming.ldap.trace.ber",
0: 								new java.io.FileOutputStream("CloudLDAP.out"));
0: 				} catch (java.io.IOException ie) {}
1: 			}
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Search for the full user's DN in the LDAP server.
1: 	 * LDAP server bind may or not be anonymous.
1: 	 *
1: 	 * If the admin does not want us to do anonymous bind/search, then we
1: 	 * must have been given principal/credentials in order to successfully
1: 	 * bind to perform the user's DN search.
1: 	 *
1: 	 * @exception NamingException if could not retrieve the user DN.
1: 	 **/
1: 	private String getDNFromUID(String uid)
1: 		throws javax.naming.NamingException
1: 	{
1: 		//
1: 		// We bind to the LDAP server here
1: 		// Note that this bind might be anonymous (if anonymous searches
1: 		// are allowed in the LDAP server, or authenticated if we were
1: 		// told/configured to.
1: 		//
1: 		Properties env = null;
1: 		if (this.searchAuthDN != (String) null) {
1: 			env = (Properties) initDirContextEnv.clone();
1: 			env.put(Context.SECURITY_PRINCIPAL, this.searchAuthDN);
1: 			env.put(Context.SECURITY_CREDENTIALS, this.searchAuthPW);
1: 		}
1: 		else
1: 			env = initDirContextEnv;
1: 
0: 		DirContext ctx = new InitialDirContext(env);
1: 
1: 		// Construct Search Filter
1: 		SearchControls ctls = new SearchControls();
1: 		// Set-up a LDAP subtree search scope
1: 		ctls.setSearchScope(SearchControls.SUBTREE_SCOPE);
1: 
1: 		// Just retrieve the DN
1: 		ctls.setReturningAttributes(attrDN);
1: 
1: 		String searchFilter =
1: 						this.leftSearchFilter + uid + this.rightSearchFilter; 
1: 		NamingEnumeration results =
1: 						ctx.search(searchBaseDN, searchFilter, ctls);
1: 			
1: 		// If we did not find anything then login failed
1: 		if (results == null || !results.hasMore())
1: 			throw new NameNotFoundException();
1: 			
1: 		SearchResult result = (SearchResult)results.next();
1: 		
1: 		if (results.hasMore())
1: 		{
1: 			// This is a login failure as we cannot assume the first one
1: 			// is the valid one.
1: 			if (SanityManager.DEBUG)
1: 			{
1: 				if (SanityManager.DEBUG_ON(
1: 						AuthenticationServiceBase.AuthenticationTrace)) {
1: 
1: 					java.io.PrintWriter iDbgStream =
1: 						SanityManager.GET_DEBUG_STREAM();
1: 
1: 					iDbgStream.println(
1: 						" - LDAP Authentication request failure: "+
1: 						"search filter [" + searchFilter + "]"+
1: 						", retrieve more than one occurence in "+
1: 						"LDAP server [" + this.providerURL + "]");
1: 				}
1: 			}
1: 			throw new NameNotFoundException();
1: 		}
1: 
1: 		NameParser parser = ctx.getNameParser(searchBaseDN);
1: 		Name userDN = parser.parse(searchBaseDN);
1: 
1: 		if (userDN == (Name) null)
1: 			// This should not happen in theory
1: 			throw new NameNotFoundException();
1: 		else
1: 			userDN.addAll(parser.parse(result.getName()));
1: 		
1: 		// Return the full user's DN
1: 		return userDN.toString();
1: 	}
1: }
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.jdbc.authentication
0:    (C) Copyright IBM Corp. 1999, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.jdbc.authentication;
0: 
0: import org.apache.derby.iapi.reference.MessageId;
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.services.i18n.MessageService;
0: import org.apache.derby.iapi.jdbc.AuthenticationService;
0: 
0: import org.apache.derby.authentication.UserAuthenticator;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.util.StringUtil;
0: 
0: import javax.naming.*;
0: import javax.naming.directory.*;
0: 
0: 
0: import java.util.Properties;
0: import java.sql.SQLException;
0: 
0: /**
0:  * This is the Cloudscape LDAP authentication scheme implementation.
0:  *
0:  * JNDI system/environment properties can be set at the database
0:  * level as database properties. They will be picked-up and set in
0:  * the JNDI initial context if any are found.
0:  *
0:  * We do connect first to the LDAP server in order to retrieve the
0:  * user's distinguished name (DN) and then we reconnect and try to
0:  * authenticate with the user's DN and passed-in password.
0:  *
0:  * In 2.0 release, we first connect to do a search (user full DN lookup).
0:  * This initial lookup can be done through anonymous bind or using special
0:  * LDAP search credentials that the user may have configured on the
0:  * LDAP settings for the database or the system.
0:  * It is a typical operation with LDAP servers where sometimes it is
0:  * hard to tell/guess in advance a users' full DN's.
0:  *
0:  * NOTE: In a future release, we will cache/maintain the user DN within
0:  * the the cloudscape database or system to avoid the initial lookup.
0:  * Also note that LDAP search/retrieval operations are usually very fast.
0:  *
0:  * The default LDAP url is ldap:/// (ldap://localhost:389/)
0:  *
0:  * @see org.apache.derby.authentication.UserAuthenticator 
0:  *
0:  */
0: 
0: public final class LDAPAuthenticationSchemeImpl
0: extends JNDIAuthenticationSchemeBase
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1999_2004;
0: 	private static final String dfltLDAPURL = "ldap://";
0: 
0: 	private String searchBaseDN;
0: 
0: 	private String leftSearchFilter; // stick in uid in between
0: 	private String rightSearchFilter;
0: 	private boolean useUserPropertyAsDN;
0: 
0: 	// Search Auth DN & Password if anonymous search not allowed
0: 	private String searchAuthDN;
0: 	private String searchAuthPW;
0: 	// we only want the user's full DN in return
0: 	private static final String[] attrDN = {"dn"};								;
0: 
0: 	//
0: 	// Cloudscape LDAP Configuration properties
0: 	//
0: 	private static final String LDAP_SEARCH_BASE =
0: 								"derby.authentication.ldap.searchBase";
0: 	private static final String LDAP_SEARCH_FILTER =
0: 								"derby.authentication.ldap.searchFilter";
0: 	private static final String LDAP_SEARCH_AUTH_DN =
0: 								"derby.authentication.ldap.searchAuthDN";
0: 	private static final String LDAP_SEARCH_AUTH_PW =
0: 								"derby.authentication.ldap.searchAuthPW";
0: 	private static final String LDAP_LOCAL_USER_DN =
0: 								"derby.user";
0: 	private static final String LDAP_SEARCH_FILTER_USERNAME =
0: 								"%USERNAME%";
0: 
0: 	public LDAPAuthenticationSchemeImpl(JNDIAuthenticationService as, Properties dbProperties) {
0: 
0: 		super(as, dbProperties);
0: 	}
0: 
0: 	/**
0: 	 * Authenticate the passed-in user's credentials.
0: 	 *
0: 	 * We authenticate against a LDAP Server.
0: 	 *
0: 	 *
0: 	 * @param userName		The user's name used to connect to JBMS system
0: 	 * @param userPassword	The user's password used to connect to JBMS system
0: 	 * @param databaseName	The database which the user wants to connect to.
0: 	 * @param info			Additional jdbc connection info.
0: 	 */
0: 	public boolean	authenticateUser(String userName,
0: 								 String userPassword,
0: 								 String databaseName,
0: 								 Properties info
0: 								)
0: 								throws java.sql.SQLException
0: 	{
0: 		if ( ((userName == null) || (userName.length() == 0)) ||
0: 			 ((userPassword == null) || (userPassword.length() == 0)) )
0: 		{
0: 			// We don't tolerate 'guest' user for now as well as
0: 			// null password.
0: 			// If a null password is passed upon authenticating a user
0: 			// through LDAP, then the LDAP server might consider this as
0: 			// anonymous bind and therefore no authentication will be done
0: 			// at all.
0: 			return false;
0: 		}
0: 
0: 
0: 		Exception e;
0: 		try {
0: 			Properties env = (Properties) initDirContextEnv.clone();
0: 			String userDN = null;
0: 			//
0: 			// Retrieve the user's DN (Distinguished Name)
0: 			// If we're asked to look it up locally, do it first
0: 			// and if we don't find it, we go against the LDAP
0: 			// server for a look-up (search)
0: 			//
0: 			if (useUserPropertyAsDN)
0: 				userDN =
0: 					authenticationService.getProperty(
0: 						org.apache.derby.iapi.reference.Property.USER_PROPERTY_PREFIX);
0: 
0: 			if (userDN == (String) null) {
0: 				userDN = getDNFromUID(userName);
0: 			}
0: 		
0: 			if (SanityManager.DEBUG)
0: 			{
0: 				if (SanityManager.DEBUG_ON(
0: 						AuthenticationServiceBase.AuthenticationTrace)) {
0: 					SanityManager.DEBUG(AuthenticationServiceBase.AuthenticationTrace,
0: 					"User DN = ["+ userDN+"]\n");
0: 				}
0: 			}
0: 
0: 			env.put(Context.SECURITY_PRINCIPAL, userDN);
0: 			env.put(Context.SECURITY_CREDENTIALS, userPassword);
0: 			
0: 			// Connect & authenticate (bind) to the LDAP server now
0: 
0: 			// it is happening right here
0: 			DirContext ctx = new InitialDirContext(env);
0: 
0: 			// if the above was successfull, then username and
0: 			// password must be correct
0: 			return true;
0: 
0: 		} catch (javax.naming.AuthenticationException jndiae) {
0: 			return false;
0: 
0: 		} catch (javax.naming.NameNotFoundException jndinnfe) {
0: 			return false;
0: 
0: 		} catch (javax.naming.NamingException jndine) {
0: 			e = jndine;
0: 		}
0: 
0: 		throw getLoginSQLException(e);
0: 	}
0: 
0: 	/**
0: 	 * This method basically tests and sets default/expected JNDI properties
0: 	 * for the JNDI provider scheme (here it is LDAP).
0: 	 *
0: 	 **/
0: 	protected void setJNDIProviderProperties()
0: 	{
0: 
0: 		// check if we're told to use a different initial context factory
0: 		if (initDirContextEnv.getProperty(
0: 							Context.INITIAL_CONTEXT_FACTORY) == (String) null)
0: 		{
0: 			initDirContextEnv.put(Context.INITIAL_CONTEXT_FACTORY,
0: 									  "com.sun.jndi.ldap.LdapCtxFactory");
0: 		}
0: 
0: 		// retrieve LDAP server name/port# and construct LDAP url
0: 		if (initDirContextEnv.getProperty(
0: 							Context.PROVIDER_URL) == (String) null)
0: 		{
0: 			// Now we construct the LDAP url and expect to find the LDAP Server
0: 			// name.
0: 			//
0: 			String ldapServer = authenticationService.getProperty(
0: 						org.apache.derby.iapi.reference.Property.AUTHENTICATION_SERVER_PARAMETER);
0: 
0: 			if (ldapServer == (String) null) {
0: 
0: 				// we do expect a LDAP Server name to be configured
0: 				Monitor.logTextMessage(
0: 					MessageId.AUTH_NO_LDAP_HOST_MENTIONED,
0: 						 org.apache.derby.iapi.reference.Property.AUTHENTICATION_SERVER_PARAMETER);
0: 
0: 				this.providerURL = dfltLDAPURL + "/";
0: 
0: 			} else {
0: 
0: 				if (ldapServer.startsWith(dfltLDAPURL))
0: 					this.providerURL = ldapServer;
0: 				else if (ldapServer.startsWith("//"))
0: 					this.providerURL = "ldap:" + ldapServer;
0: 				else
0: 					this.providerURL = dfltLDAPURL + ldapServer;
0: 			}
0: 			initDirContextEnv.put(Context.PROVIDER_URL, providerURL);
0: 		}
0: 
0: 		// check if we should we use a particular authentication method
0: 		// we assume the ldap server supports this authentication method
0: 		// (Netscape DS 3.1.1 does not support CRAM-MD5 for instance)
0: 		if (initDirContextEnv.getProperty(
0: 							Context.SECURITY_AUTHENTICATION) == (String) null)
0: 		{
0: 			// set the default to be clear userName/Password as not of all the
0: 			// LDAP server(s) support CRAM-MD5 (especially ldap v2 ones)
0: 			// Netscape Directory Server 3.1.1 does not support CRAM-MD5
0: 			// (told by Sun JNDI engineering). Netscape DS 4.0 allows SASL
0: 			// plug-ins to be installed and that can be used as authentication
0: 			// method.
0: 			//
0: 			initDirContextEnv.put(Context.SECURITY_AUTHENTICATION,
0: 									  "simple"
0: 									  );
0: 		}
0: 
0: 		// Retrieve and set the search base (root) DN to use on the ldap
0: 		// server.
0: 		String ldapSearchBase =
0: 					authenticationService.getProperty(LDAP_SEARCH_BASE);
0: 		if (ldapSearchBase != (String) null)
0: 			this.searchBaseDN = ldapSearchBase;
0: 		else
0: 			this.searchBaseDN = "";
0: 
0: 		// retrieve principal and credentials for the search bind as the
0: 		// user may not want to allow anonymous binds (for searches)
0: 		this.searchAuthDN =
0: 					authenticationService.getProperty(LDAP_SEARCH_AUTH_DN);
0: 		this.searchAuthPW =
0: 					authenticationService.getProperty(LDAP_SEARCH_AUTH_PW);
0: 
0: 		//
0: 		// Construct the LDAP search filter:
0: 		//
0: 		// If we were told to use a special search filther, we do so;
0: 		// otherwise we use our default search filter.
0: 		// The user may have set the search filter 3 different ways:
0: 		//
0: 		// - if %USERNAME% was found in the search filter, then we
0: 		// will substitute this with the passed-in uid at runtime.
0: 		//
0: 		// - if "derby.user" is the search filter value, then we
0: 		// will assume the user's DN can be found in the system or
0: 		// database property "derby.user.<uid>" . If the property
0: 		// does not exist, then we will do a normal lookup with our
0: 		// default search filter; otherwise we will perform an
0: 		// authenticated bind to the LDAP server using the found DN.
0: 		//
0: 		// - if neither of the 2 previous values were found, then we use
0: 		// our default search filter and we will substitute insert the
0: 		// uid passed at runtime into our default search filter.
0: 		//
0: 		String searchFilterProp =
0: 					authenticationService.getProperty(LDAP_SEARCH_FILTER);
0: 		
0: 		if (searchFilterProp == (String) null)
0: 		{
0: 			// use our default search filter
0: 			this.leftSearchFilter = "(&(objectClass=inetOrgPerson)(uid=";
0: 			this.rightSearchFilter = "))";
0: 
0: 		} else if (StringUtil.SQLEqualsIgnoreCase(searchFilterProp,LDAP_LOCAL_USER_DN)) {
0: 
0: 			// use local user DN in derby.user.<uid>
0: 			this.leftSearchFilter = "(&(objectClass=inetOrgPerson)(uid=";
0: 			this.rightSearchFilter = "))";
0: 			this.useUserPropertyAsDN = true;
0: 
0: 		} else if (searchFilterProp.indexOf(
0: 									LDAP_SEARCH_FILTER_USERNAME) != -1) {
0: 
0: 			// user has set %USERNAME% in the search filter
0: 			this.leftSearchFilter = searchFilterProp.substring(0,
0: 				searchFilterProp.indexOf(LDAP_SEARCH_FILTER_USERNAME));
0: 			this.rightSearchFilter = searchFilterProp.substring(
0: 				searchFilterProp.indexOf(LDAP_SEARCH_FILTER_USERNAME)+
0: 				(int) LDAP_SEARCH_FILTER_USERNAME.length());
0: 
0: 
0: 		} else	{ // add this search filter to ours
0: 
0: 			// complement this search predicate to ours
0: 			this.leftSearchFilter = "(&("+searchFilterProp+")"+
0: 									"(objectClass=inetOrgPerson)(uid=";
0: 			this.rightSearchFilter = "))";
0: 
0: 		}
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (SanityManager.DEBUG_ON(
0: 						AuthenticationServiceBase.AuthenticationTrace)) {
0: 
0: 				java.io.PrintWriter iDbgStream =
0: 					SanityManager.GET_DEBUG_STREAM();
0: 
0: 				iDbgStream.println(
0: 								"\n\n+ LDAP Authentication Configuration:\n"+
0: 								"   - provider URL ["+this.providerURL+"]\n"+
0: 								"   - search base ["+this.searchBaseDN+"]\n"+
0: 								"   - search filter to be [" +
0: 								this.leftSearchFilter + "<uid>" +
0: 								this.rightSearchFilter + "]\n" +
0: 								"   - use local DN [" +
0: 								(useUserPropertyAsDN ? "true" : "false") +
0: 								"]\n"
0: 								);
0: 			}
0: 		}
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (SanityManager.DEBUG_ON(
0: 						AuthenticationServiceBase.AuthenticationTrace)) {
0: 				try {
0: 					initDirContextEnv.put("com.sun.naming.ldap.trace.ber",
0: 								new java.io.FileOutputStream("CloudLDAP.out"));
0: 				} catch (java.io.IOException ie) {}
0: 			}
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Search for the full user's DN in the LDAP server.
0: 	 * LDAP server bind may or not be anonymous.
0: 	 *
0: 	 * If the admin does not want us to do anonymous bind/search, then we
0: 	 * must have been given principal/credentials in order to successfully
0: 	 * bind to perform the user's DN search.
0: 	 *
0: 	 * @exception NamingException if could not retrieve the user DN.
0: 	 **/
0: 	private String getDNFromUID(String uid)
0: 		throws javax.naming.NamingException
0: 	{
0: 		//
0: 		// We bind to the LDAP server here
0: 		// Note that this bind might be anonymous (if anonymous searches
0: 		// are allowed in the LDAP server, or authenticated if we were
0: 		// told/configured to.
0: 		//
0: 		Properties env = null;
0: 		if (this.searchAuthDN != (String) null) {
0: 			env = (Properties) initDirContextEnv.clone();
0: 			env.put(Context.SECURITY_PRINCIPAL, this.searchAuthDN);
0: 			env.put(Context.SECURITY_CREDENTIALS, this.searchAuthPW);
0: 		}
0: 		else
0: 			env = initDirContextEnv;
0: 
0: 		DirContext ctx = new InitialDirContext(env);
0: 
0: 		// Construct Search Filter
0: 		SearchControls ctls = new SearchControls();
0: 		// Set-up a LDAP subtree search scope
0: 		ctls.setSearchScope(SearchControls.SUBTREE_SCOPE);
0: 
0: 		// Just retrieve the DN
0: 		ctls.setReturningAttributes(attrDN);
0: 
0: 		String searchFilter =
0: 						this.leftSearchFilter + uid + this.rightSearchFilter; 
0: 		NamingEnumeration results =
0: 						ctx.search(searchBaseDN, searchFilter, ctls);
0: 			
0: 		// If we did not find anything then login failed
0: 		if (results == null || !results.hasMore())
0: 			throw new NameNotFoundException();
0: 			
0: 		SearchResult result = (SearchResult)results.next();
0: 		
0: 		if (results.hasMore())
0: 		{
0: 			// This is a login failure as we cannot assume the first one
0: 			// is the valid one.
0: 			if (SanityManager.DEBUG)
0: 			{
0: 				if (SanityManager.DEBUG_ON(
0: 						AuthenticationServiceBase.AuthenticationTrace)) {
0: 
0: 					java.io.PrintWriter iDbgStream =
0: 						SanityManager.GET_DEBUG_STREAM();
0: 
0: 					iDbgStream.println(
0: 						" - LDAP Authentication request failure: "+
0: 						"search filter [" + searchFilter + "]"+
0: 						", retrieve more than one occurence in "+
0: 						"LDAP server [" + this.providerURL + "]");
0: 				}
0: 			}
0: 			throw new NameNotFoundException();
0: 		}
0: 
0: 		NameParser parser = ctx.getNameParser(searchBaseDN);
0: 		Name userDN = parser.parse(searchBaseDN);
0: 
0: 		if (userDN == (Name) null)
0: 			// This should not happen in theory
0: 			throw new NameNotFoundException();
0: 		else
0: 			userDN.addAll(parser.parse(result.getName()));
0: 		
0: 		// Return the full user's DN
0: 		return userDN.toString();
0: 	}
0: }
============================================================================