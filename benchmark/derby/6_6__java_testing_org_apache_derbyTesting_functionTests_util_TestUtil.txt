1:f68f62f: /*
13:f68f62f: 
1:f68f62f:    Derby - Class org.apache.derbyTesting.functionTests.util.TestUtil
1:0bbfdac: 
1:15651f5:    Licensed to the Apache Software Foundation (ASF) under one or more
1:15651f5:    contributor license agreements.  See the NOTICE file distributed with
1:15651f5:    this work for additional information regarding copyright ownership.
1:15651f5:    The ASF licenses this file to You under the Apache License, Version 2.0
1:15651f5:    (the "License"); you may not use this file except in compliance with
1:15651f5:    the License.  You may obtain a copy of the License at
1:0bbfdac: 
1:f68f62f:       http://www.apache.org/licenses/LICENSE-2.0
1:0bbfdac: 
1:f68f62f:    Unless required by applicable law or agreed to in writing, software
1:f68f62f:    distributed under the License is distributed on an "AS IS" BASIS,
1:f68f62f:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:f68f62f:    See the License for the specific language governing permissions and
1:f68f62f:    limitations under the License.
1:0bbfdac: 
1:f68f62f:  */
1:0bbfdac: 
1:0bbfdac: 
1:f68f62f: package org.apache.derbyTesting.functionTests.util;
1:0bbfdac: 
1:f68f62f: import java.sql.*;
1:f68f62f: import java.io.*;
1:91bb4f2: import java.lang.reflect.*;
1:91bb4f2: import java.util.Enumeration;
1:91bb4f2: import java.util.Hashtable;
1:0bbfdac: import java.util.Locale;
1:91bb4f2: import java.util.Properties;
1:b16ad1f: import java.util.StringTokenizer;
1:b16ad1f: import java.util.NoSuchElementException;
1:bc50840: import java.security.AccessController;
1:bc50840: import java.security.PrivilegedAction;
1:bc50840: import java.security.PrivilegedExceptionAction;
1:bc50840: import java.security.PrivilegedActionException;
1:923a60f: import javax.sql.ConnectionPoolDataSource;
1:39aa8c4: import javax.sql.DataSource;
1:923a60f: import javax.sql.XADataSource;
1:39aa8c4: 
1:6eb4ff8: import org.apache.derbyTesting.functionTests.harness.JavaVersionHolder;
1:d1c8b24: import org.apache.derbyTesting.functionTests.harness.RunTest;
1:39aa8c4: 
1:39aa8c4: 
1:39aa8c4: 
1:0bbfdac: 
1:0bbfdac: /**
1:0bbfdac: 	Utility methods for tests, in order to bring some consistency to test
1:0bbfdac: 	output and handle testing framework differences
1:0bbfdac: 
1:f68f62f: */
1:f68f62f: public class TestUtil {
1:39aa8c4: 	
1:39aa8c4: 	//Used for JSR169
1:39aa8c4: 	public static boolean HAVE_DRIVER_CLASS;
1:39aa8c4: 	static{
1:39aa8c4: 		try{
1:39aa8c4: 			Class.forName("java.sql.Driver");
1:39aa8c4: 			HAVE_DRIVER_CLASS = true;
1:39aa8c4: 		}
1:39aa8c4: 		catch(ClassNotFoundException e){
1:39aa8c4: 			//Used for JSR169
1:39aa8c4: 			HAVE_DRIVER_CLASS = false;
1:39aa8c4: 		}
1:39aa8c4: 	}
1:c12c97d: 
1:0bbfdac: 	public static final int UNKNOWN_FRAMEWORK = -1;
1:39aa8c4: 
1:c12c97d: 	/**
1:0bbfdac: 	   framework = embedded (or null) jdbc:derby:
1:0bbfdac: 	*/
1:0bbfdac: 	public static final int EMBEDDED_FRAMEWORK = 0;
1:91bb4f2: 	
1:91bb4f2: 	/**
1:0bbfdac: 	   framework = DerbyNet for JCC  jdbc:derby:net:
1:0bbfdac: 	*/
1:0bbfdac: 	public static final int DERBY_NET_FRAMEWORK = 1;
1:0bbfdac: 
1:0bbfdac: 	/**
1:0bbfdac: 	   framework = DB2JCC  for testing JCC against DB2 for 
1:0bbfdac: 	   debugging jcc problems jdbc:db2://
1:0bbfdac: 	*/
1:0bbfdac: 
1:0bbfdac: 	public  static final int DB2JCC_FRAMEWORK = 2; // jdbc:db2//
1:0bbfdac: 	
1:0bbfdac: 	/**
1:0bbfdac: 	   framework = DerbyNetClient  for Derby cient  jdbc:derby://
1:0bbfdac: 	*/
1:0bbfdac: 	public static final int DERBY_NET_CLIENT_FRAMEWORK = 3; // jdbc:derby://
1:0bbfdac: 
1:0bbfdac: 
1:0bbfdac: 	/**
1:0bbfdac: 	   framework = DB2jNet 
1:0bbfdac: 	   OLD_NET_FRAMEWORK is for tests that have not yet been contributed.
1:0bbfdac: 	   it can be removed once all tests are at apache
1:0bbfdac: 	*/
1:0bbfdac: 	public  static final int OLD_NET_FRAMEWORK = 4;          // jdbc:derby:net:
1:0bbfdac: 
1:0bbfdac: 
1:0bbfdac: 	private static int framework = UNKNOWN_FRAMEWORK;
1:91bb4f2: 
1:0bbfdac: 
1:91bb4f2: 	// DataSource Type strings used to build up datasource names.
1:91bb4f2: 	// e.g. "Embed" + XA_DATASOURCE_STRING + "DataSource
1:91bb4f2: 	private static String XA_DATASOURCE_STRING = "XA";
1:91bb4f2: 	private static String CONNECTION_POOL_DATASOURCE_STRING = "ConnectionPool";
1:91bb4f2: 	private static String REGULAR_DATASOURCE_STRING = "";
1:91bb4f2: 	
1:0bbfdac: 	// Methods for making framework dependent decisions in tests.
1:0bbfdac: 
1:0bbfdac: 	/**
1:0bbfdac: 	 * Is this a network testingframework? 
1:0bbfdac: 	 * return true if the System Property framework is set to Derby Network
1:0bbfdac: 	 * client or JCC
1:0bbfdac: 	 *
1:0bbfdac: 	 * @return true if this is a Network Server test
1:0bbfdac: 	 */
1:0bbfdac: 	public static boolean isNetFramework()
1:0bbfdac: 	{
1:0bbfdac: 		framework = getFramework();
1:0bbfdac: 		switch (framework)
1:26ea443: 		{
1:0bbfdac: 			case DERBY_NET_FRAMEWORK:
1:0bbfdac: 			case DERBY_NET_CLIENT_FRAMEWORK:
1:0bbfdac: 			case DB2JCC_FRAMEWORK:
1:0bbfdac: 			case OLD_NET_FRAMEWORK:
1:0bbfdac: 				return true;
1:0bbfdac: 			default:
1:0bbfdac: 				return false;
1:26ea443: 		}
1:26ea443: 	}
1:448ecb0: 			
1:448ecb0: 	/** 
1:0bbfdac: 		Is the JCC driver being used
1:26ea443: 	  
1:0bbfdac: 		@return true for JCC driver
1:448ecb0: 	*/
1:0bbfdac: 	public static boolean isJCCFramework()
1:26ea443: 	{
1:0bbfdac: 		int framework = getFramework();
1:0bbfdac: 		switch (framework)
1:0bbfdac: 		{
1:0bbfdac: 			case DERBY_NET_FRAMEWORK:
1:0bbfdac: 			case DB2JCC_FRAMEWORK:
1:0bbfdac: 			case OLD_NET_FRAMEWORK:
1:0bbfdac: 				return true;
1:0bbfdac: 		}
1:0bbfdac: 		return false;
1:0bbfdac: 	}
1:0bbfdac: 
1:91eacad: 	public static boolean isDerbyNetClientFramework()
1:91eacad: 	{
1:91eacad: 		return (getFramework() == DERBY_NET_CLIENT_FRAMEWORK);
1:91eacad: 	}
1:91eacad: 
1:97a334e: 	public static boolean isEmbeddedFramework()
1:97a334e: 	{
1:97a334e: 		return (getFramework() == EMBEDDED_FRAMEWORK);
1:97a334e: 	}
1:97a334e: 
1:6eb4ff8: 	/**
1:0bbfdac: 	   Get the framework from the System Property framework
1:0bbfdac: 	   @return  constant for framework being used
1:0bbfdac: 	       TestUtil.EMBEDDED_FRAMEWORK  for embedded
1:0bbfdac: 		   TestUtil.DERBY_NET_CLIENT_FRAMEWORK  for Derby Network Client 
1:0bbfdac: 		   TestUtil.DERBY_NET_FRAMEWORK for JCC to Network Server
1:0bbfdac: 		   TestUtil.DB2JCC_FRAMEWORK for JCC to DB2
1:0bbfdac: 	*/
1:0bbfdac: 	private static int getFramework()
1:0bbfdac: 	{
1:0bbfdac: 		if (framework != UNKNOWN_FRAMEWORK)
1:0bbfdac: 			return framework;
1:3f5c48a:               String frameworkString = AccessController.doPrivileged
1:3f5c48a:                   (new PrivilegedAction<String>() {
1:3f5c48a:                           public String run() {
1:bc50840:                               return System.getProperty("framework");
1:0bbfdac:                           }
1:0bbfdac:                       }
1:bc50840:                    );              
1:d1c8b24: 		// last attempt to get useprocess to do networkserver stuff.
1:d1c8b24: 		// If a suite has useprocess, it's possible there was no property set.
1:d1c8b24: 		if (frameworkString == null)
1:0bbfdac: 		{
1:d1c8b24: 		   String useprocessFramework = RunTest.framework;
1:d1c8b24: 		   if (useprocessFramework != null)
1:d1c8b24: 			frameworkString = useprocessFramework;
1:d1c8b24: 		}
1:0bbfdac: 		if (frameworkString == null || 
1:0bbfdac: 		   frameworkString.toUpperCase(Locale.ENGLISH).equals("EMBEDDED"))
1:0bbfdac: 			framework = EMBEDDED_FRAMEWORK;
1:0bbfdac: 		else if (frameworkString.toUpperCase(Locale.ENGLISH).equals("DERBYNETCLIENT"))
1:0bbfdac: 			framework = DERBY_NET_CLIENT_FRAMEWORK;
1:0bbfdac: 		else if (frameworkString.toUpperCase(Locale.ENGLISH).equals("DERBYNET"))
1:0bbfdac: 			framework = DERBY_NET_FRAMEWORK;
1:0bbfdac: 		else if (frameworkString.toUpperCase(Locale.ENGLISH).indexOf("DB2JNET") != -1)
1:0bbfdac: 			framework = OLD_NET_FRAMEWORK;
1:0bbfdac: 
1:0bbfdac: 		return framework;
1:0bbfdac: 
1:0bbfdac: 	}
1:0bbfdac: 
1:0bbfdac: 	/**
1:0bbfdac: 	    Get URL prefix for current framework.
1:0bbfdac: 		
1:5ff5941: 		@return url, assume localhost - unless set differently in System property - 
1:5ff5941: 		             and assume port 1527 for Network Tests
1:df4020d: 		@see #getJdbcUrlPrefix(String server, int port)
1:0bbfdac: 		
1:0bbfdac: 	*/
1:0bbfdac:     public static String getJdbcUrlPrefix()
1:0bbfdac:     {
1:5ff5941:         String hostName=getHostName();
1:5ff5941:         return getJdbcUrlPrefix(hostName, 1527);
1:0bbfdac:     }
1:0bbfdac: 
1:5ff5941:     /** Get hostName as passed in - if not, set it to "localhost" 
1:5ff5941:         @return hostName, as passed into system properties, or "localhost"
1:0bbfdac:     */
1:5ff5941:     public static String getHostName()
1:0bbfdac:     {
1:3f5c48a:         String hostName = AccessController.doPrivileged
1:3f5c48a:             (new PrivilegedAction<String>() {
1:3f5c48a:                     public String run() {
1:bc50840:                         return System.getProperty("hostName");
1:5ff5941:                     }
1:5ff5941:                 }
1:bc50840:              );    
1:5ff5941:         if (hostName == null)
1:5ff5941:             hostName="localhost";
1:5ff5941:         return hostName;
1:5ff5941:     }
1:0bbfdac: 
1:0bbfdac: 	/** 
1:0bbfdac: 		Get URL prefix for current framework		
1:0bbfdac: 		
1:0bbfdac: 		@param server  host to connect to with client driver 
1:0bbfdac: 		               ignored for embedded driver
1:0bbfdac: 		@param port    port to connect to with client driver
1:0bbfdac: 		               ignored with embedded driver
1:0bbfdac: 		@return URL prefix
1:0bbfdac: 		        EMBEDDED_FRAMEWORK returns "jdbc:derby"
1:0bbfdac: 				DERBY_NET_FRAMEWORK = "jdbc:derby:net://<server>:port/"
1:0bbfdac: 				DERBY_NET_CLIENT_FRAMEWORK = "jdbc:derby://<server>:port/"
1:0bbfdac: 				DB2_JCC_FRAMEWORK = "jdbc:db2://<server>:port/"
1:0bbfdac: 	*/
1:0bbfdac: 	public static String getJdbcUrlPrefix(String server, int port)
1:0bbfdac: 	{
1:0bbfdac: 		int framework = getFramework();
1:0bbfdac: 		switch (framework)
1:0bbfdac: 		{
1:0bbfdac: 			case EMBEDDED_FRAMEWORK:
1:0bbfdac: 				return "jdbc:derby:";
1:0bbfdac: 			case DERBY_NET_FRAMEWORK:
1:0bbfdac: 			case OLD_NET_FRAMEWORK:								
1:0bbfdac: 				return "jdbc:derby:net://" + server + ":" + port + "/";
1:0bbfdac: 			case DERBY_NET_CLIENT_FRAMEWORK:
1:0bbfdac: 				return "jdbc:derby://" + server + ":" + port + "/";
1:0bbfdac: 			case DB2JCC_FRAMEWORK:				
1:0bbfdac: 				return "jdbc:db2://" + server + ":" + port + "/";
1:0bbfdac: 		}
1:0bbfdac: 		// Unknown framework
1:0bbfdac: 		return null;
1:97a334e: 		
1:0bbfdac: 	}
1:97a334e: 
1:0bbfdac: 	/**
1:0bbfdac: 	   Load the appropriate driver for the current framework
1:0bbfdac: 	*/
1:0bbfdac: 	public static void loadDriver() throws Exception
1:0bbfdac: 	{
1:bc50840:               final String driverName;
1:0bbfdac: 		framework = getFramework();
1:0bbfdac: 		switch (framework)
1:0bbfdac: 		{
1:0bbfdac: 			case EMBEDDED_FRAMEWORK:
1:0bbfdac: 				driverName =  "org.apache.derby.jdbc.EmbeddedDriver";
1:0bbfdac: 				break;
1:0bbfdac: 			case DERBY_NET_FRAMEWORK:
1:0bbfdac: 			case OLD_NET_FRAMEWORK:				
1:0bbfdac: 			case DB2JCC_FRAMEWORK:				
1:0bbfdac: 				driverName = "com.ibm.db2.jcc.DB2Driver";
1:0bbfdac: 				break;
1:0bbfdac: 			case DERBY_NET_CLIENT_FRAMEWORK:
1:0bbfdac: 				driverName = "org.apache.derby.jdbc.ClientDriver";
1:0bbfdac: 				break;
1:bc50840:                       default: 
1:bc50840:                             driverName=  "org.apache.derby.jdbc.EmbeddedDriver";
1:e72bcdd:                             break;
1:0bbfdac: 		}
1:0bbfdac:                                 
1:448ecb0:               try {
1:bc50840:                   AccessController.doPrivileged
1:3f5c48a:                       (new PrivilegedExceptionAction<Void>() {
1:3f5c48a:                               public Void run() throws Exception {
1:4469400:                                   Class<?> clazz = Class.forName(driverName);
1:4469400:                                   clazz.getConstructor().newInstance();
1:3f5c48a:                                   return null;
1:448ecb0:                               }
1:448ecb0:                           }
1:bc50840:                        );
1:bc50840:               } catch (PrivilegedActionException e) {
1:bc50840:                   throw e.getException();
1:28162f6:               }
1:0bbfdac:         }
1:39aa8c4: 
1:0bbfdac: 
1:0bbfdac: 	/**
1:91bb4f2: 	 * Get a data source for the appropriate framework
1:91bb4f2: 	 * @param attrs  A set of attribute values to set on the datasource.
1:91bb4f2: 	 *                The appropriate setter method wil b
1:91bb4f2: 	 *                For example the property databaseName with value wombat,
1:91bb4f2: 	 *                will mean ds.setDatabaseName("wombat") will be called
1:91bb4f2: 	 *  @return datasource for current framework
1:91bb4f2: 	 */
1:923a60f:     public static DataSource getDataSource(Properties attrs)
1:91bb4f2: 	{
1:923a60f:         String classname =
1:923a60f:             getDataSourcePrefix() + REGULAR_DATASOURCE_STRING + "DataSource40";
1:923a60f:         return (DataSource) getDataSourceWithReflection(classname, attrs);
1:91bb4f2: 	}
1:91bb4f2: 
1:91bb4f2: 	/**
1:91bb4f2: 	 * Get an xa  data source for the appropriate framework
1:91bb4f2: 	 * @param attrs  A set of attribute values to set on the datasource.
1:91bb4f2: 	 *                The appropriate setter method wil b
1:91bb4f2: 	 *                For example the property databaseName with value wombat,
1:91bb4f2: 	 *                will mean ds.setDatabaseName("wombat") will be called
1:91bb4f2: 	 *  @return datasource for current framework
1:91bb4f2: 	 */
1:923a60f:     public static XADataSource getXADataSource(Properties attrs)
1:91bb4f2: 	{
1:923a60f:         String classname =
1:923a60f:             getDataSourcePrefix() + XA_DATASOURCE_STRING + "DataSource40";
1:923a60f:         return (XADataSource) getDataSourceWithReflection(classname, attrs);
1:91bb4f2: 	}
1:91bb4f2: 
1:91bb4f2: 	
1:91bb4f2: 	/**
1:91bb4f2: 	 * Get a ConnectionPoolDataSource  for the appropriate framework
1:91bb4f2: 	 * @param attrs  A set of attribute values to set on the datasource.
1:91bb4f2: 	 *                The appropriate setter method wil b
1:91bb4f2: 	 *                For example the property databaseName with value wombat,
1:91bb4f2: 	 *                will mean ds.setDatabaseName("wombat") will be called
1:91bb4f2: 	 *  @return datasource for current framework
1:91bb4f2: 	 */
1:923a60f:     public static ConnectionPoolDataSource
1:923a60f:             getConnectionPoolDataSource(Properties attrs)
1:91bb4f2: 	{
1:923a60f:         String classname = getDataSourcePrefix() +
1:923a60f:                 CONNECTION_POOL_DATASOURCE_STRING + "DataSource40";
1:923a60f:         return (ConnectionPoolDataSource)
1:923a60f:                 getDataSourceWithReflection(classname, attrs);
1:91bb4f2: 	}
1:91bb4f2: 
1:97a334e: 	public static String getDataSourcePrefix()
1:91bb4f2: 		{
1:91bb4f2: 			framework = getFramework();
1:91bb4f2: 			switch(framework)
1:91bb4f2: 			{
1:91bb4f2: 				case OLD_NET_FRAMEWORK:
1:91bb4f2: 				case DERBY_NET_FRAMEWORK:
1:91bb4f2: 				case DB2JCC_FRAMEWORK:
1:91bb4f2: 					return "com.ibm.db2.jcc.DB2";
1:91bb4f2: 				case DERBY_NET_CLIENT_FRAMEWORK:
1:91bb4f2: 					return "org.apache.derby.jdbc.Client";
1:91bb4f2: 				case EMBEDDED_FRAMEWORK:
1:97a334e: 					return "org.apache.derby.jdbc.Embedded";
1:91bb4f2: 				default:
1:91bb4f2: 					Exception e = new Exception("FAIL: No DataSource Prefix for framework: " + framework);
1:91bb4f2: 					e.printStackTrace();
1:91bb4f2: 			}
1:91bb4f2: 			return null;
1:91bb4f2: 		}
1:91bb4f2: 
1:91bb4f2: 
1:91bb4f2: 
1:91bb4f2: 	static private Class[] STRING_ARG_TYPE = {String.class};
1:91bb4f2: 	static private Class[] INT_ARG_TYPE = {Integer.TYPE};
1:91bb4f2: 	static private Class[] BOOLEAN_ARG_TYPE = { Boolean.TYPE };
1:91bb4f2: 	// A hashtable of special non-string attributes.
1:3f5c48a: 	private static Hashtable<String, Class[]> specialAttributes = null;
1:91bb4f2: 	
1:91bb4f2: 
1:91bb4f2: 	private static Object getDataSourceWithReflection(String classname, Properties attrs)
1:91bb4f2: 	{
1:91bb4f2: 		Object[] args = null;
1:91bb4f2: 		Object ds = null;
1:91bb4f2: 		Method sh = null;
1:91eacad: 		String methodName = null;
1:91bb4f2: 		
1:91bb4f2: 		if (specialAttributes == null)
1:91bb4f2: 		{
1:3f5c48a: 			specialAttributes = new Hashtable<String, Class[]>();
1:91bb4f2: 			specialAttributes.put("portNumber",INT_ARG_TYPE);
1:91bb4f2: 			specialAttributes.put("driverType",INT_ARG_TYPE);
1:91bb4f2: 			specialAttributes.put("retrieveMessagesFromServerOnGetMessage",
1:91bb4f2: 								  BOOLEAN_ARG_TYPE);
1:91eacad: 			specialAttributes.put("retrieveMessageText",
1:91eacad: 								  BOOLEAN_ARG_TYPE);
1:91bb4f2: 		}
1:91bb4f2: 		
1:28162f6: 		try {
1:4469400:             Class<?> clazz = Class.forName(classname);
1:4469400:             ds = clazz.getConstructor().newInstance();
1:91bb4f2: 
1:4a95eeb: 		// for remote server testing, check whether the hostName is set for the test
1:4a95eeb: 		// if so, and serverName is not yet set explicitly for the datasource, set it now
1:4a95eeb: 		String hostName = getHostName();
1:4a95eeb: 		if ( (!isEmbeddedFramework()) && (hostName != null ) && (attrs.getProperty("serverName") == null) )
1:4a95eeb: 			attrs.setProperty("serverName", hostName);
1:91bb4f2: 
1:91bb4f2: 		for (Enumeration propNames = attrs.propertyNames(); 
1:91bb4f2: 			 propNames.hasMoreElements();)
1:91bb4f2: 		{
1:91bb4f2: 			String key = (String) propNames.nextElement();
1:91bb4f2: 			Class[] argType = (Class[]) specialAttributes.get(key);
1:91bb4f2: 			if (argType == null) 
1:91bb4f2: 				argType = STRING_ARG_TYPE;
1:91bb4f2: 			String value = attrs.getProperty(key);
1:91bb4f2: 			if (argType  == INT_ARG_TYPE)
1:91bb4f2: 			{
1:91bb4f2: 				args = new Integer[] 
1:39b3237: 				{ Integer.valueOf(value) };	
1:91bb4f2: 			}
1:91bb4f2: 			else if (argType  == BOOLEAN_ARG_TYPE)
1:91bb4f2: 			{
1:39b3237: 				args = new Boolean[] { Boolean.valueOf(value) };	
1:91bb4f2: 			}
1:91bb4f2: 			else if (argType == STRING_ARG_TYPE)
1:91bb4f2: 			{
1:91bb4f2: 				args = new String[] { value };
1:91bb4f2: 			}
1:91bb4f2: 			else  // No other property types supported right now
1:91bb4f2: 			{
1:91bb4f2: 				throw new Exception("FAIL: getDataSourceWithReflection: Argument type " + argType[0].getName() +  " not supportted for attribute: " +
1:91bb4f2: 									" key:" + key + " value:" +value);
1:91bb4f2: 			   
1:91bb4f2: 			}
1:91eacad: 			methodName = getSetterName(key);
1:91bb4f2: 
1:91bb4f2: 			
1:91bb4f2: 			// Need to use reflection to load indirectly
1:91bb4f2: 			// setDatabaseName
1:91bb4f2: 			sh = ds.getClass().getMethod(methodName, argType);
1:91bb4f2: 			sh.invoke(ds, args);
1:91bb4f2: 		}
1:91bb4f2: 
1:91bb4f2: 		} catch (Exception e)
1:91bb4f2: 		{
1:91eacad: 			System.out.println("Error accessing method " + methodName);
1:91bb4f2: 			System.out.println(e.getMessage());
1:91bb4f2: 			e.printStackTrace();
1:91bb4f2: 		}
1:91bb4f2: 		return ds;
1:91bb4f2: 	}
1:91bb4f2: 
1:91bb4f2: 	
1:91eacad: 	public static String  getSetterName(String attribute)
1:91bb4f2: 	{
1:91bb4f2: 		return "set" + Character.toUpperCase(attribute.charAt(0)) + attribute.substring(1);
1:91bb4f2: 	}
1:91bb4f2: 
1:91bb4f2: 	
1:ce773cf: 	public static String  getGetterName(String attribute)
1:ce773cf: 	{
1:ce773cf: 		return "get" + Character.toUpperCase(attribute.charAt(0)) + attribute.substring(1);
1:ce773cf: 	}
1:ce773cf: 
1:91bb4f2: 	// Some methods for test output.
1:f68f62f: 	public static void dumpSQLExceptions(SQLException sqle) {
1:f68f62f: 		TestUtil.dumpSQLExceptions(sqle, false);
1:f68f62f: 	}
1:91bb4f2: 
1:f68f62f: 	public static void dumpSQLExceptions(SQLException sqle, boolean expected) {
1:f68f62f: 		String prefix = "";
1:f68f62f: 		if (!expected) {
1:f68f62f: 			System.out.println("FAIL -- unexpected exception ****************");
1:f68f62f: 		}
1:39aa8c4: 		else
1:f68f62f: 		{
1:f68f62f: 			prefix = "EXPECTED ";
1:f68f62f: 		}
1:0bbfdac: 
1:f68f62f: 		do
1:f68f62f: 		{
1:f68f62f: 			System.out.println(prefix + "SQLSTATE("+sqle.getSQLState()+"): " + sqle.getMessage());
1:f68f62f: 			sqle = sqle.getNextException();
1:f68f62f: 		} while (sqle != null);
1:f68f62f: 	}
1:f68f62f: 
1:f68f62f: 
1:f68f62f: 	  public static String sqlNameFromJdbc(int jdbcType) {
1:f68f62f: 		switch (jdbcType) {
1:f68f62f: 			case Types.BIT 		:  return "Types.BIT";
1:1a4ea31: 			case Types.BOOLEAN  : return "Types.BOOLEAN";
1:f68f62f: 			case Types.TINYINT 	:  return "Types.TINYINT";
1:f68f62f: 			case Types.SMALLINT	:  return "SMALLINT";
1:f68f62f: 			case Types.INTEGER 	:  return "INTEGER";
1:f68f62f: 			case Types.BIGINT 	:  return "BIGINT";
1:f68f62f: 
1:f68f62f: 			case Types.FLOAT 	:  return "Types.FLOAT";
1:f68f62f: 			case Types.REAL 	:  return "REAL";
1:f68f62f: 			case Types.DOUBLE 	:  return "DOUBLE";
1:f68f62f: 
1:f68f62f: 			case Types.NUMERIC 	:  return "Types.NUMERIC";
1:f68f62f: 			case Types.DECIMAL	:  return "DECIMAL";
1:f68f62f: 
1:f68f62f: 			case Types.CHAR		:  return "CHAR";
1:f68f62f: 			case Types.VARCHAR 	:  return "VARCHAR";
1:f68f62f: 			case Types.LONGVARCHAR 	:  return "LONG VARCHAR";
1:f68f62f:             case Types.CLOB     :  return "CLOB";
1:f68f62f: 
1:f68f62f: 			case Types.DATE 		:  return "DATE";
1:f68f62f: 			case Types.TIME 		:  return "TIME";
1:f68f62f: 			case Types.TIMESTAMP 	:  return "TIMESTAMP";
1:f68f62f: 
1:f68f62f: 			case Types.BINARY			:  return "CHAR () FOR BIT DATA";
1:f68f62f: 			case Types.VARBINARY	 	:  return "VARCHAR () FOR BIT DATA";
1:f68f62f: 			case Types.LONGVARBINARY 	:  return "LONG VARCHAR FOR BIT DATA";
1:f68f62f:             case Types.BLOB             :  return "BLOB";
1:f68f62f: 
1:f68f62f: 			case Types.OTHER		:  return "Types.OTHER";
1:f68f62f: 			case Types.NULL		:  return "Types.NULL";
1:f68f62f: 			default : return String.valueOf(jdbcType);
1:f68f62f: 		}
1:f68f62f: 	}
1:cd24ce3: 	  public static String getNameFromJdbcType(int jdbcType) {
1:f68f62f: 		switch (jdbcType) {
1:f68f62f: 			case Types.BIT 		:  return "Types.BIT";
1:1a4ea31: 			case Types.BOOLEAN  : return "Types.BOOLEAN";
1:f68f62f: 			case Types.TINYINT 	:  return "Types.TINYINT";
1:f68f62f: 			case Types.SMALLINT	:  return "Types.SMALLINT";
1:f68f62f: 			case Types.INTEGER 	:  return "Types.INTEGER";
1:f68f62f: 			case Types.BIGINT 	:  return "Types.BIGINT";
1:f68f62f: 
1:f68f62f: 			case Types.FLOAT 	:  return "Types.FLOAT";
1:f68f62f: 			case Types.REAL 	:  return "Types.REAL";
1:f68f62f: 			case Types.DOUBLE 	:  return "Types.DOUBLE";
1:f68f62f: 
1:f68f62f: 			case Types.NUMERIC 	:  return "Types.NUMERIC";
1:f68f62f: 			case Types.DECIMAL	:  return "Types.DECIMAL";
1:f68f62f: 
1:f68f62f: 			case Types.CHAR		:  return "Types.CHAR";
1:f68f62f: 			case Types.VARCHAR 	:  return "Types.VARCHAR";
1:f68f62f: 			case Types.LONGVARCHAR 	:  return "Types.LONGVARCHAR";
1:f68f62f:             case Types.CLOB     :  return "Types.CLOB";
1:f68f62f: 
1:f68f62f: 			case Types.DATE 		:  return "Types.DATE";
1:f68f62f: 			case Types.TIME 		:  return "Types.TIME";
1:f68f62f: 			case Types.TIMESTAMP 	:  return "Types.TIMESTAMP";
1:f68f62f: 
1:f68f62f: 			case Types.BINARY			:  return "Types.BINARY";
1:f68f62f: 			case Types.VARBINARY	 	:  return "Types.VARBINARY";
1:f68f62f: 			case Types.LONGVARBINARY 	:  return "Types.LONGVARBINARY";
1:f68f62f:             case Types.BLOB             :  return "Types.BLOB";
1:f68f62f: 
1:f68f62f: 			case Types.OTHER		:  return "Types.OTHER";
1:f68f62f: 			case Types.NULL		:  return "Types.NULL";
1:f68f62f: 			default : return String.valueOf(jdbcType);
1:f68f62f: 		}
1:f68f62f: 	}
1:f68f62f: 
1:f68f62f: 	/*** Some routines for printing test information to html  **/
1:f68f62f: 
1:f68f62f: 	public static String TABLE_START_TAG =  "<TABLE border=1 cellspacing=1 cellpadding=1  bgcolor=white  style='width:100%'>";
1:f68f62f: 	public static String TABLE_END_TAG = "</TABLE>";
1:f68f62f: 	public static String TD_INVERSE =
1:f68f62f: 		"<td  valign=bottom align=center style=background:#DADADA;  padding:.75pt .75pt .75pt .75pt'> <p class=MsoNormal style='margin-top:6.0pt;margin-right:0in;margin-bottom:  6.0pt;margin-left:0in'><b><span style='font-size:8.5pt;font-family:Arial;  color:black'>";
1:f68f62f: 
1:f68f62f: 	public static String TD_CENTER = "<TD valign=center align=center> <p class=MsoNormal style='margin-top:6.0pt;margin-right:0in;margin-bottom:6.0pt;margin-left:0in'><b><span style='font-size:8.5pt;font-family:Arial;  color:black'>";
1:f68f62f: 
1:f68f62f: 	public static String TD_LEFT = "<TD valign=center align=left> <p class=MsoNormal style='margin-top:6.0pt;margin-right:0in;margin-bottom:6.0pt;margin-left:0in'><b><span style='font-size:8.5pt;font-family:Arial;  color:black'>";
1:f68f62f: 
1:f68f62f: 	
1:f68f62f: 	public static String TD_END = "</SPAN></TD>";
1:f68f62f: 
1:f68f62f: 	public static String END_HTML_PAGE="</BODY> </HTML>";
1:f68f62f: 	
1:f68f62f: 
1:f68f62f: 	public static void startHTMLPage(String title, String author)
1:f68f62f: 	{
1:f68f62f: 		System.out.println("<HTML> \n <HEAD>");
1:f68f62f: 		System.out.println(" <meta http-equiv=\"Content-Type\"content=\"text/html; charset=iso-8859-1\">");
1:f68f62f: 		System.out.println("<meta name=\"Author\" content=\"" + author +  "\">");
1:f68f62f: 		System.out.println("<title>" + title + "</title>");
1:f68f62f: 		System.out.println("</HEAD> <BODY>");
1:f68f62f: 		System.out.println("<H1>" + title + "</H1>");
1:f68f62f: 	}
1:f68f62f: 
1:f68f62f: 	public static void endHTMLPage()
1:f68f62f: 	{
1:f68f62f: 		System.out.println(END_HTML_PAGE);
1:f68f62f: 	}
1:f68f62f: 
1:f68f62f: /*	public static void main(String[] argv)
1:f68f62f: 	{
1:f68f62f: 		testBoolArrayToHTMLTable();
1:f68f62f: 	}
1:f68f62f: */
1:f68f62f: 
1:0bbfdac: 	/** 
1:f68f62f: 	 * Converts 2 dimensional boolean array into an HTML table.
1:f68f62f: 	 * used by casting.java to print out casting doc
1:f68f62f: 	 *
1:f68f62f: 	 * @param rowLabels   - Row labels
1:f68f62f: 	 * @param colLabels   - Column labels
1:f68f62f: 	 **/
1:f68f62f: 	public static void printBoolArrayHTMLTable(String rowDescription,
1:f68f62f: 											   String columnDescription,
1:f68f62f: 											   String [] rowLabels, 
1:f68f62f: 											   String [] colLabels,
1:f68f62f: 											   boolean[][] array,
1:f68f62f: 											   String tableInfo)
1:f68f62f: 	{
1:f68f62f: 
1:f68f62f: 		System.out.println("<H2>" + tableInfo + "</H2>");
1:f68f62f: 
1:f68f62f: 		System.out.println(TABLE_START_TAG);
1:f68f62f: 		System.out.println("<TR>");
1:f68f62f: 		// Print corner with labels
1:f68f62f: 		System.out.println(TD_INVERSE +columnDescription + "---><BR><BR><BR><BR><BR>");
1:f68f62f: 		System.out.println("<---" +rowDescription);
1:f68f62f: 		System.out.println(TD_END);
1:f68f62f: 
1:f68f62f: 		
1:f68f62f: 		// Print column headers
1:f68f62f: 		for (int i = 0; i < colLabels.length; i++)
1:f68f62f: 		{
1:f68f62f: 			System.out.println(TD_INVERSE);
1:f68f62f: 			for (int c = 0; c < colLabels[i].length() && c < 20; c++)
1:f68f62f: 			{
1:f68f62f: 				System.out.println(colLabels[i].charAt(c) + "<BR>");
1:f68f62f: 			}
1:f68f62f: 			System.out.println(TD_END);
1:f68f62f: 		}
1:f68f62f: 
1:f68f62f: 		System.out.println("</TR>");
1:f68f62f: 
1:f68f62f: 		// Print the Row Labels and Data
1:f68f62f: 		for (int i = 0; i < rowLabels.length; i ++)
1:f68f62f: 		{
1:f68f62f: 			System.out.println("<TR>");
1:f68f62f: 			System.out.println(TD_LEFT);
1:f68f62f: 			System.out.println("<C> " +  rowLabels[i] + "</C>");
1:f68f62f: 			System.out.println(TD_END);
1:f68f62f: 
1:f68f62f: 			for (int j = 0; j < colLabels.length; j ++)
1:f68f62f: 			{
1:f68f62f: 				System.out.println(TD_CENTER);
1:f68f62f: 				System.out.println((array[i][j]) ? "Y" : "-");
1:f68f62f: 				System.out.println(TD_END);
1:f68f62f: 			}
1:f68f62f: 			System.out.println("</TR>");
1:f68f62f: 		}
1:f68f62f: 
1:f68f62f: 
1:f68f62f: 		System.out.println(TABLE_END_TAG);
1:f68f62f: 		System.out.println("<P><P>");
1:f68f62f: 
1:f68f62f: 	}
1:f68f62f: 
1:0bbfdac: 	/**
1:f68f62f: 	 * Just converts a string to a hex literal to assist in converting test
1:f68f62f: 	 * cases that used to insert strings into bit data tables
1:f68f62f: 	 * Converts using UTF-16BE just like the old casts used to.
1:f68f62f: 	 *
1:df4020d: 	 * @param s  String to convert  (e.g
1:df4020d: 	 * @return hex literal that can be inserted into a bit column.
1:f68f62f: 	 */
1:f68f62f: 	public static String stringToHexLiteral(String s)
1:f68f62f: 	{
1:f68f62f: 		byte[] bytes;
1:f68f62f: 		String hexLiteral = null;
1:91bb4f2: 		try {
1:f68f62f: 			bytes = s.getBytes("UTF-16BE");
1:f68f62f: 			hexLiteral = convertToHexString(bytes);
1:f68f62f: 		}
1:f68f62f: 		catch (UnsupportedEncodingException ue)
1:f68f62f: 		{
1:f68f62f: 			System.out.println("This shouldn't happen as UTF-16BE should be supported");
1:f68f62f: 			ue.printStackTrace();
1:f68f62f: 		}
1:f68f62f: 
1:f68f62f: 		return hexLiteral;
1:f68f62f: 	}
1:f68f62f: 
1:f68f62f: 	private static String convertToHexString(byte [] buf)
1:f68f62f: 	{
1:f68f62f: 		StringBuffer str = new StringBuffer();
1:f68f62f: 		str.append("X'");
1:f68f62f: 		String val;
1:f68f62f: 		int byteVal;
1:f68f62f: 		for (int i = 0; i < buf.length; i++)
1:f68f62f: 		{
1:f68f62f: 			byteVal = buf[i] & 0xff;
1:f68f62f: 			val = Integer.toHexString(byteVal);
1:f68f62f: 			if (val.length() < 2)
1:f68f62f: 				str.append("0");
1:f68f62f: 			str.append(val);
1:f68f62f: 		}
1:f68f62f: 		return str.toString() +"'";
1:f68f62f: 	}
1:f68f62f: 
1:f68f62f: 
1:f68f62f: 
1:f68f62f: 	/**
1:f68f62f: 		Get the JDBC version, inferring it from the driver.
1:f68f62f: 	*/
1:f68f62f: 
1:f68f62f: 	public static int getJDBCMajorVersion(Connection conn)
1:f68f62f: 	{
1:f68f62f: 		try {
1:7d7cb63: 			// DatabaseMetaData.getJDBCMajorVersion() was not part of JDBC 2.0.
1:7d7cb63: 			// Check if setSavepoint() is present to decide whether the version
1:7d7cb63: 			// is > 2.0.
1:f68f62f: 			conn.getClass().getMethod("setSavepoint", null);
1:7d7cb63: 			DatabaseMetaData meta = conn.getMetaData();
1:7d7cb63: 			Method method =
1:7d7cb63: 				meta.getClass().getMethod("getJDBCMajorVersion", null);
1:7d7cb63: 			return ((Number) method.invoke(meta, null)).intValue();
1:7d7cb63: 		} catch (Throwable t) {
1:7d7cb63: 			// Error probably means that either setSavepoint() or
1:7d7cb63: 			// getJDBCMajorVersion() is not present. Assume JDBC 2.0.
2:f68f62f: 			return 2;
1:f68f62f: 		}
1:f68f62f: 
1:f68f62f: 	}
1:f68f62f: 
1:f68f62f:     /**
1:5ff5941:         Drop the test objects passed in as a string identifying the
1:5ff5941:         type of object (e.g. TABLE, PROCEDURE) and its name.
1:5ff5941:         Thus, for example, a testObject array could be:
1:5ff5941:         {"TABLE MYSCHEMA.MYTABLE", "PROCEDURE THISDUMMY"}
1:5ff5941:         The statement passed in must be a 'live' statement in the test.
1:5ff5941:     */
1:5ff5941:     public static void cleanUpTest (Statement s, String[] testObjects)
1:5ff5941:                                     throws SQLException {
1:5ff5941:         /* drop each object named */
1:5ff5941:         for (int i=0; i < testObjects.length; i++) {
1:f68f62f:             try {
1:5ff5941:                 s.execute("drop " + testObjects[i]);
1:5ff5941:                 //System.out.println("now dropping " + testObjects[i]);
1:5ff5941:             } catch (SQLException se) { // ignore...
1:f68f62f:             }
1:e72bcdd:         }	
1:5ff5941:     }
1:f68f62f: 
1:f68f62f:     
1:f68f62f:     /**
1:c12c97d:      * Get connection to given database using the connection attributes. This
1:c12c97d:      * method is used by tests to get a secondary connection with 
1:c12c97d:      * different set of attributes. It does not use what is specified in 
1:c12c97d:      * app_properties file or system properties. This method uses DataSource 
1:c12c97d:      * class for CDC/Foundation Profile environments, which are based on 
1:c12c97d:      * JSR169. Using DataSource will not work with other j9 profiles. So
1:c12c97d:      * DriverManager is used for non-JSR169. The method is used as a wrapper to
1:c12c97d:      * hide this difference in getting connections in different environments.
1:c12c97d:      *  
1:c12c97d:      * @param databaseName
1:c12c97d:      * @param connAttrs
1:c12c97d:      * @return Connection to database 
1:c12c97d:      * @throws SQLException on failure to connect.
1:c12c97d:      * @throws ClassNotFoundException on failure to load driver.
1:c12c97d:      * @throws InstantiationException on failure to load driver.
1:c12c97d:      * @throws IllegalAccessException on failure to load driver.
1:c12c97d:      */
1:e72bcdd:     public static Connection getConnection(String databaseName, String connAttrs)
1:e72bcdd:     	throws SQLException {
1:e72bcdd:         try {
1:c12c97d:             Connection conn;
1:c12c97d:             if(TestUtil.HAVE_DRIVER_CLASS) {
1:e72bcdd:                 // following is like loadDriver(), but
1:e72bcdd:                 // that method throws Exception, we want finer granularity
1:e72bcdd:                 String driverName;
1:e72bcdd:                 int framework = getFramework();
1:e72bcdd:                 switch (framework)
1:d1c8b24:                 {
1:e72bcdd:                     case EMBEDDED_FRAMEWORK:
1:e72bcdd:                         driverName =  "org.apache.derby.jdbc.EmbeddedDriver";
1:e72bcdd:                         break;
1:e72bcdd:                     case DERBY_NET_FRAMEWORK:
1:e72bcdd:                     case OLD_NET_FRAMEWORK:				
1:e72bcdd:                     case DB2JCC_FRAMEWORK:				
1:e72bcdd:                         driverName = "com.ibm.db2.jcc.DB2Driver";
1:e72bcdd:                         break;
1:e72bcdd:                     case DERBY_NET_CLIENT_FRAMEWORK:
1:e72bcdd:                         driverName = "org.apache.derby.jdbc.ClientDriver";
1:e72bcdd:                         break;
1:e72bcdd:                     default:
1:e72bcdd:                         driverName =  "org.apache.derby.jdbc.EmbeddedDriver";
1:bc50840:                         break;
1:c12c97d:                 } 
1:e72bcdd:                 // q: do we need a privileged action here, like in loadDriver?
1:4469400:                 Class<?> clazz = Class.forName(driverName);
1:4469400:                 clazz.getConstructor().newInstance();
1:c12c97d: 				
1:e72bcdd:                 String url = getJdbcUrlPrefix() + databaseName;
1:e72bcdd:                 if (connAttrs != null) url += ";" + connAttrs;
1:e72bcdd:                 if (framework == DERBY_NET_FRAMEWORK)
2:e72bcdd:                 {
1:e72bcdd:                     if (( connAttrs == null) || ((connAttrs != null) && (connAttrs.indexOf("user") < 0)))
1:37952cf:                         url += ":" + "user=APP;password=APP;retrieveMessagesFromServerOnGetMessage=true;";
1:e72bcdd:                 }
1:e72bcdd:                 conn = DriverManager.getConnection(url);
1:e72bcdd:     	    }
1:c12c97d:     	    else {
1:c12c97d:     		    //Use DataSource for JSR169
1:c12c97d: 	    	    Properties prop = new Properties();
1:c12c97d: 	            prop.setProperty("databaseName", databaseName);
1:e72bcdd:     		    if (connAttrs != null)
1:c12c97d: 	                prop.setProperty("connectionAttributes", connAttrs);
1:c12c97d: 	            conn = getDataSourceConnection(prop);
1:c12c97d:     	    }
1:c12c97d:             return conn;
1:e72bcdd:     	} catch (ClassNotFoundException cnfe) { 
1:e72bcdd: 		    System.out.println("FAILure: Class not found!");
1:e72bcdd: 		    cnfe.printStackTrace();
1:e72bcdd: 		    return null;
1:e72bcdd:     	} catch (InstantiationException inste) {
1:e72bcdd:     		System.out.println("FAILure: Cannot instantiate class");
1:e72bcdd:     		inste.printStackTrace();
1:e72bcdd:     		return null;
1:e72bcdd:     	} catch (IllegalAccessException ille) {
1:e72bcdd:     		System.out.println("FAILure: Not allowed to use class");
1:e72bcdd:     		ille.printStackTrace();
1:e72bcdd:     		return null;
1:4469400:     	} catch (NoSuchMethodException ille) {
1:4469400:     		System.out.println("FAILure: No such constructor");
1:4469400:     		ille.printStackTrace();
1:4469400:     		return null;
1:4469400:     	} catch (java.lang.reflect.InvocationTargetException ille) {
1:4469400:     		System.out.println("FAILure: Cannot execute constructor");
1:4469400:     		ille.printStackTrace();
1:4469400:     		return null;
1:c12c97d:     	}
1:e72bcdd:     }
1:c12c97d:     
1:c12c97d:     public static Connection getDataSourceConnection (Properties prop) throws SQLException {
1:39aa8c4: 		DataSource ds = TestUtil.getDataSource(prop);
1:39aa8c4: 		try {
1:39aa8c4: 			Connection conn = ds.getConnection();
1:39aa8c4: 			return conn;
1:39aa8c4: 		}
1:39aa8c4: 		catch (SQLException e) {
1:39aa8c4: 			throw e;
1:39aa8c4: 		}
1:39aa8c4: 	}
1:b16ad1f: 	
1:39aa8c4: 	public static void shutdownUsingDataSource (String dbName) throws SQLException {
1:39aa8c4: 		Properties prop = new Properties();
1:39aa8c4: 		prop.setProperty("databaseName", dbName );
1:39aa8c4: 		prop.setProperty("shutdownDatabase", "shutdown" );
1:39aa8c4: 		DataSource ds = TestUtil.getDataSource(prop);
1:39aa8c4: 		try {
1:39aa8c4: 			Connection conn = ds.getConnection();
1:39aa8c4: 		}
1:39aa8c4: 		catch (SQLException e) {
1:39aa8c4: 			throw e;
1:39aa8c4: 		}
1:39aa8c4: 	}
1:f68f62f: 	
1:b16ad1f: 	//Used by metadata tests for DatabaseMetadata.getURL
1:b16ad1f: 	public static boolean compareURL(String url) {
1:b16ad1f: 			
1:b16ad1f: 		if(isEmbeddedFramework()) {
1:b16ad1f: 			if(url.compareTo("jdbc:derby:wombat") == 0)
1:b16ad1f: 				return true;
1:b16ad1f: 		} else if(isNetFramework()) {
1:b16ad1f: 			try {
1:b16ad1f: 				StringTokenizer urlTokenizer = new StringTokenizer(url, "/");
1:b16ad1f: 				String urlStart = urlTokenizer.nextToken();
1:b16ad1f: 				urlTokenizer.nextToken();
1:b16ad1f: 				String urlEnd = urlTokenizer.nextToken();
1:b16ad1f: 				
1:b16ad1f: 				if(urlEnd.compareTo("wombat;create=true") != 0)
1:b16ad1f: 					return false;
1:b16ad1f: 				
1:b16ad1f: 				if(isJCCFramework() && (urlStart.compareTo("jdbc:derby:net:") == 0))
1:b16ad1f: 					return true;
1:b16ad1f: 				
1:b16ad1f: 				if(isDerbyNetClientFramework() && (urlStart.compareTo("jdbc:derby:") == 0))
1:b16ad1f: 					return true;
1:b16ad1f: 				
1:b16ad1f: 			} catch (NoSuchElementException nsee) {
1:b16ad1f: 				//Should not reach here.
1:b16ad1f: 				return false;
1:b16ad1f: 			}
1:b16ad1f: 		}
1:b16ad1f: 		
1:b16ad1f: 		return false;
1:b16ad1f: 	}
1:f68f62f: 
1:f68f62f: 	/**
1:6eb4ff8: 	 * For JDK 1.5 or higher print all stack traces to the
1:6eb4ff8: 	 * specified PrintWriter.
1:6eb4ff8: 	 * 
1:6eb4ff8: 	 * @param log  PrintWriter to print to
1:6eb4ff8: 	 */
1:6eb4ff8:     public static void dumpAllStackTracesIfSupported(PrintWriter log)
1:6eb4ff8: 	{
1:6eb4ff8: 		try {
1:3f5c48a: 			String version = AccessController.doPrivileged
1:3f5c48a: 				(new PrivilegedAction<String>(){
1:3f5c48a: 						public String run(){
1:6eb4ff8: 							return System.getProperty("java.version");
1:6eb4ff8: 						}
1:6eb4ff8: 					}
1:6eb4ff8: 				 );
1:6eb4ff8:                    
1:6eb4ff8: 			JavaVersionHolder j=  new JavaVersionHolder(version); 
1:6eb4ff8: 			
1:6eb4ff8: 			if (j.atLeast(1,5)){
1:3f5c48a: 				Class<?> c = Class.forName("org.apache.derbyTesting.functionTests.util.ThreadDump");
1:6eb4ff8: 				final Method m = c.getMethod("getStackDumpString",new Class[] {});
1:6eb4ff8: 				
1:6eb4ff8: 				String dump;
1:6eb4ff8: 				try {
1:3f5c48a: 					dump = AccessController.doPrivileged
1:3f5c48a: 						(new PrivilegedExceptionAction<String>(){
1:3f5c48a: 								public String run() throws
1:6eb4ff8: 									IllegalArgumentException, 
1:6eb4ff8: 									IllegalAccessException, 
1:6eb4ff8: 									InvocationTargetException{
1:3f5c48a: 									return (String) m.invoke(null);
1:6eb4ff8: 								}
1:6eb4ff8: 							}
1:6eb4ff8: 						 );
1:6eb4ff8: 				}     catch (PrivilegedActionException e) {
1:6eb4ff8: 					throw  e.getException();
1:6eb4ff8: 				}
1:6eb4ff8: 				log.println(dump);                    
1:6eb4ff8: 			}                     
1:6eb4ff8: 		}
1:6eb4ff8: 		catch (Exception e){
1:6eb4ff8: 			// if we get an exception trying to get a thread dump. Just print it to the log and continue.
1:6eb4ff8: 			log.println("Error trying to dump thread stack traces");
1:6eb4ff8: 			if (e instanceof InvocationTargetException)
1:6eb4ff8: 				((InvocationTargetException) e).getTargetException().printStackTrace(log);
1:6eb4ff8: 			else
1:6eb4ff8: 				e.printStackTrace(log);
1:6eb4ff8: 		}
1:6eb4ff8: 		
1:6eb4ff8: 	}
1:5ff5941: }
1:6eb4ff8: 
1:f68f62f: 
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:4469400
/////////////////////////////////////////////////////////////////////////
1:                                   Class<?> clazz = Class.forName(driverName);
1:                                   clazz.getConstructor().newInstance();
/////////////////////////////////////////////////////////////////////////
1:             Class<?> clazz = Class.forName(classname);
1:             ds = clazz.getConstructor().newInstance();
/////////////////////////////////////////////////////////////////////////
1:                 Class<?> clazz = Class.forName(driverName);
1:                 clazz.getConstructor().newInstance();
/////////////////////////////////////////////////////////////////////////
1:     	} catch (NoSuchMethodException ille) {
1:     		System.out.println("FAILure: No such constructor");
1:     		ille.printStackTrace();
1:     		return null;
1:     	} catch (java.lang.reflect.InvocationTargetException ille) {
1:     		System.out.println("FAILure: Cannot execute constructor");
1:     		ille.printStackTrace();
1:     		return null;
commit:39b3237
/////////////////////////////////////////////////////////////////////////
1: 				{ Integer.valueOf(value) };	
1: 				args = new Boolean[] { Boolean.valueOf(value) };	
commit:448ecb0
/////////////////////////////////////////////////////////////////////////
0: 			classname = checkForJDBC40Implementation(classname);
/////////////////////////////////////////////////////////////////////////
0:                 classname = checkForJDBC40Implementation(classname);
1:         
1:         /**
0:          * returns the class name for the JDBC40 implementation
0:          * if present. otherwise returns the class name of the class
0:          * written for the lower jdk versions
0:          * @param classname String
0:          * @return String containing the name of the appropriate 
0:          *         implementation
1:          */
0:         public static String checkForJDBC40Implementation(String classname) {
0:                 String classname_ = classname;
0:                 // The JDBC 4.0 implementation of the  
0:                 // interface is suffixed with "40". Use it if it is available 
0:                 // and the JVM version is at least 1.6.
0:                 if (JVMInfo.JDK_ID >= JVMInfo.J2SE_16) {
0:                         String classname40 = classname_ + "40";
1:                         try {
0:                                 Class.forName(classname40);
0:                                 classname_ = classname40;
0:                         } catch (ClassNotFoundException e) {}
1:                 }
0:                 return classname_;
1:         }
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:923a60f
/////////////////////////////////////////////////////////////////////////
1: import javax.sql.ConnectionPoolDataSource;
1: import javax.sql.XADataSource;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     public static DataSource getDataSource(Properties attrs)
1:         String classname =
1:             getDataSourcePrefix() + REGULAR_DATASOURCE_STRING + "DataSource40";
1:         return (DataSource) getDataSourceWithReflection(classname, attrs);
/////////////////////////////////////////////////////////////////////////
1:     public static XADataSource getXADataSource(Properties attrs)
1:         String classname =
1:             getDataSourcePrefix() + XA_DATASOURCE_STRING + "DataSource40";
1:         return (XADataSource) getDataSourceWithReflection(classname, attrs);
/////////////////////////////////////////////////////////////////////////
1:     public static ConnectionPoolDataSource
1:             getConnectionPoolDataSource(Properties attrs)
1:         String classname = getDataSourcePrefix() +
1:                 CONNECTION_POOL_DATASOURCE_STRING + "DataSource40";
1:         return (ConnectionPoolDataSource)
1:                 getDataSourceWithReflection(classname, attrs);
commit:3f5c48a
/////////////////////////////////////////////////////////////////////////
1:               String frameworkString = AccessController.doPrivileged
1:                   (new PrivilegedAction<String>() {
1:                           public String run() {
/////////////////////////////////////////////////////////////////////////
1:         String hostName = AccessController.doPrivileged
1:             (new PrivilegedAction<String>() {
1:                     public String run() {
/////////////////////////////////////////////////////////////////////////
1:                       (new PrivilegedExceptionAction<Void>() {
1:                               public Void run() throws Exception {
0:                                   Class.forName(driverName).newInstance();
1:                                   return null;
/////////////////////////////////////////////////////////////////////////
1: 	private static Hashtable<String, Class[]> specialAttributes = null;
/////////////////////////////////////////////////////////////////////////
1: 			specialAttributes = new Hashtable<String, Class[]>();
/////////////////////////////////////////////////////////////////////////
1: 			String version = AccessController.doPrivileged
1: 				(new PrivilegedAction<String>(){
1: 						public String run(){
/////////////////////////////////////////////////////////////////////////
1: 				Class<?> c = Class.forName("org.apache.derbyTesting.functionTests.util.ThreadDump");
1: 					dump = AccessController.doPrivileged
1: 						(new PrivilegedExceptionAction<String>(){
1: 								public String run() throws
1: 									return (String) m.invoke(null);
commit:7d7cb63
/////////////////////////////////////////////////////////////////////////
1: 			// DatabaseMetaData.getJDBCMajorVersion() was not part of JDBC 2.0.
1: 			// Check if setSavepoint() is present to decide whether the version
1: 			// is > 2.0.
1: 			DatabaseMetaData meta = conn.getMetaData();
1: 			Method method =
1: 				meta.getClass().getMethod("getJDBCMajorVersion", null);
1: 			return ((Number) method.invoke(meta, null)).intValue();
1: 		} catch (Throwable t) {
1: 			// Error probably means that either setSavepoint() or
1: 			// getJDBCMajorVersion() is not present. Assume JDBC 2.0.
commit:712b41b
/////////////////////////////////////////////////////////////////////////
0: 		classname = checkForJDBC40Implementation(classname);
commit:28162f6
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.services.info.JVMInfo;
/////////////////////////////////////////////////////////////////////////
0: 			// The JDBC 4.0 implementation of the DataSource interface
0: 			// is suffixed with "40". Use it if it is available and
0: 			// the JVM version is at least 1.6.
0: 			if (JVMInfo.JDK_ID >= JVMInfo.J2SE_16) {
0: 				String classname40 = classname + "40";
1: 				try {
0: 					Class.forName(classname40);
0: 					classname = classname40;
0: 				} catch (ClassNotFoundException e) {}
1: 			}
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:6eb4ff8
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.functionTests.harness.JavaVersionHolder;
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * For JDK 1.5 or higher print all stack traces to the
1: 	 * specified PrintWriter.
1: 	 * 
1: 	 * @param log  PrintWriter to print to
1: 	 */
1:     public static void dumpAllStackTracesIfSupported(PrintWriter log)
1: 	{
1: 		try {
0: 			String version =  (String) AccessController.doPrivileged
0: 				(new java.security.PrivilegedAction(){
0: 						public Object run(){
1: 							return System.getProperty("java.version");
1: 						}
1: 					}
1: 				 );
1:                    
1: 			JavaVersionHolder j=  new JavaVersionHolder(version); 
1: 			
1: 			if (j.atLeast(1,5)){
0: 				Class c = Class.forName("org.apache.derbyTesting.functionTests.util.ThreadDump");
1: 				final Method m = c.getMethod("getStackDumpString",new Class[] {});
1: 				
1: 				String dump;
1: 				try {
0: 					dump = (String) AccessController.doPrivileged
0: 						(new PrivilegedExceptionAction(){
0: 								public Object run() throws 
1: 									IllegalArgumentException, 
1: 									IllegalAccessException, 
1: 									InvocationTargetException{
0: 									return m.invoke(null, null);
1: 								}
1: 							}
1: 						 );
1: 				}     catch (PrivilegedActionException e) {
1: 					throw  e.getException();
1: 				}
1: 				log.println(dump);                    
1: 			}                     
1: 		}
1: 		catch (Exception e){
1: 			// if we get an exception trying to get a thread dump. Just print it to the log and continue.
1: 			log.println("Error trying to dump thread stack traces");
1: 			if (e instanceof InvocationTargetException)
1: 				((InvocationTargetException) e).getTargetException().printStackTrace(log);
1: 			else
1: 				e.printStackTrace(log);
1: 		}
1: 		
1: 	}
1: 
commit:26ea443
/////////////////////////////////////////////////////////////////////////
1: 		{
0: 			return (javax.sql.DataSource) getDataSourceWithReflection(classname, attrs);
1: 		}
0: 			return getSimpleDataSource(attrs);
0: 	public static DataSource getSimpleDataSource(Properties attrs)
1: 	{
0: 		String classname = getDataSourcePrefix() + JSR169_DATASOURCE_STRING + "DataSource";
0: 		return (javax.sql.DataSource) getDataSourceWithReflection(classname, attrs);
1: 	}
1: 	
commit:c12c97d
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Get connection to given database using the connection attributes. This
1:      * method is used by tests to get a secondary connection with 
1:      * different set of attributes. It does not use what is specified in 
1:      * app_properties file or system properties. This method uses DataSource 
1:      * class for CDC/Foundation Profile environments, which are based on 
1:      * JSR169. Using DataSource will not work with other j9 profiles. So
1:      * DriverManager is used for non-JSR169. The method is used as a wrapper to
1:      * hide this difference in getting connections in different environments.
1:      *  
1:      * @param databaseName
1:      * @param connAttrs
1:      * @return Connection to database 
1:      * @throws SQLException on failure to connect.
1:      * @throws ClassNotFoundException on failure to load driver.
1:      * @throws InstantiationException on failure to load driver.
1:      * @throws IllegalAccessException on failure to load driver.
1:      */
0:     public static Connection getConnection(String databaseName, 
0:     									   String connAttrs) 
0:     	throws SQLException, ClassNotFoundException, 
0: 				InstantiationException, IllegalAccessException {
1:     	
1:     	Connection conn;
1:     	if(TestUtil.HAVE_DRIVER_CLASS) {
0:     		String driver = "org.apache.derby.jdbc.EmbeddedDriver";
0:     		Class.forName(driver).newInstance();
0:     		conn = DriverManager.getConnection("jdbc:derby:" + databaseName 
0: 												+ ";" + connAttrs );
1:     	}
1:     	else {
1:     		//Use DataSource for JSR169
1: 	    	Properties prop = new Properties();
1: 	        prop.setProperty("databaseName", databaseName);
1: 	        prop.setProperty("connectionAttributes", connAttrs);
1: 	        conn = getDataSourceConnection(prop);
1:     	}
1:         return conn;
1:     }
1:     
1:     public static Connection getDataSourceConnection (Properties prop) throws SQLException {
commit:b16ad1f
/////////////////////////////////////////////////////////////////////////
1: import java.util.StringTokenizer;
1: import java.util.NoSuchElementException;
/////////////////////////////////////////////////////////////////////////
1: 	
1: 	//Used by metadata tests for DatabaseMetadata.getURL
1: 	public static boolean compareURL(String url) {
1: 			
1: 		if(isEmbeddedFramework()) {
1: 			if(url.compareTo("jdbc:derby:wombat") == 0)
1: 				return true;
1: 		} else if(isNetFramework()) {
1: 			try {
1: 				StringTokenizer urlTokenizer = new StringTokenizer(url, "/");
1: 				String urlStart = urlTokenizer.nextToken();
1: 				urlTokenizer.nextToken();
1: 				String urlEnd = urlTokenizer.nextToken();
1: 				
1: 				if(urlEnd.compareTo("wombat;create=true") != 0)
1: 					return false;
1: 				
1: 				if(isJCCFramework() && (urlStart.compareTo("jdbc:derby:net:") == 0))
1: 					return true;
1: 				
1: 				if(isDerbyNetClientFramework() && (urlStart.compareTo("jdbc:derby:") == 0))
1: 					return true;
1: 				
1: 			} catch (NoSuchElementException nsee) {
1: 				//Should not reach here.
1: 				return false;
1: 			}
1: 		}
1: 		
1: 		return false;
1: 	}
commit:39aa8c4
/////////////////////////////////////////////////////////////////////////
1: 
1: import javax.sql.DataSource;
1: 
1: 
1: 
1: 	
1: 	//Used for JSR169
1: 	public static boolean HAVE_DRIVER_CLASS;
1: 	static{
1: 		try{
1: 			Class.forName("java.sql.Driver");
1: 			HAVE_DRIVER_CLASS = true;
1: 		}
1: 		catch(ClassNotFoundException e){
1: 			//Used for JSR169
1: 			HAVE_DRIVER_CLASS = false;
1: 		}
1: 	}
/////////////////////////////////////////////////////////////////////////
0: 	private static String JSR169_DATASOURCE_STRING = "Simple";
/////////////////////////////////////////////////////////////////////////
0: 		String classname;
0: 		if(HAVE_DRIVER_CLASS)
0: 			classname = getDataSourcePrefix() + REGULAR_DATASOURCE_STRING + "DataSource";
1: 		else
0: 			classname = getDataSourcePrefix() + JSR169_DATASOURCE_STRING + "DataSource";
/////////////////////////////////////////////////////////////////////////
1: 	
0: 	public static Connection getDataSourceConnection (Properties prop) throws SQLException {
1: 		DataSource ds = TestUtil.getDataSource(prop);
1: 		try {
1: 			Connection conn = ds.getConnection();
1: 			return conn;
1: 		}
1: 		catch (SQLException e) {
1: 			throw e;
1: 		}
1: 	}
1: 	
1: 	public static void shutdownUsingDataSource (String dbName) throws SQLException {
1: 		Properties prop = new Properties();
1: 		prop.setProperty("databaseName", dbName );
1: 		prop.setProperty("shutdownDatabase", "shutdown" );
1: 		DataSource ds = TestUtil.getDataSource(prop);
1: 		try {
1: 			Connection conn = ds.getConnection();
1: 		}
1: 		catch (SQLException e) {
1: 			throw e;
1: 		}
1: 	}
commit:cd24ce3
/////////////////////////////////////////////////////////////////////////
1: 	  public static String getNameFromJdbcType(int jdbcType) {
commit:ce773cf
/////////////////////////////////////////////////////////////////////////
1: 	public static String  getGetterName(String attribute)
1: 	{
1: 		return "get" + Character.toUpperCase(attribute.charAt(0)) + attribute.substring(1);
1: 	}
1: 
commit:91eacad
/////////////////////////////////////////////////////////////////////////
1: 	public static boolean isDerbyNetClientFramework()
1: 	{
1: 		return (getFramework() == DERBY_NET_CLIENT_FRAMEWORK);
1: 	}
1: 
/////////////////////////////////////////////////////////////////////////
1: 		String methodName = null;
/////////////////////////////////////////////////////////////////////////
1: 			specialAttributes.put("retrieveMessageText",
1: 								  BOOLEAN_ARG_TYPE);
/////////////////////////////////////////////////////////////////////////
1: 			methodName = getSetterName(key);
/////////////////////////////////////////////////////////////////////////
1: 			System.out.println("Error accessing method " + methodName);
/////////////////////////////////////////////////////////////////////////
1: 	public static String  getSetterName(String attribute)
commit:97a334e
/////////////////////////////////////////////////////////////////////////
1: 	public static boolean isEmbeddedFramework()
1: 	{
1: 		return (getFramework() == EMBEDDED_FRAMEWORK);
1: 	}
1: 
/////////////////////////////////////////////////////////////////////////
0: 	public static javax.sql.XADataSource getXADataSource(Properties attrs)
/////////////////////////////////////////////////////////////////////////
1: 	public static String getDataSourcePrefix()
/////////////////////////////////////////////////////////////////////////
1: 					return "org.apache.derby.jdbc.Embedded";
/////////////////////////////////////////////////////////////////////////
1: 
1: 
commit:91bb4f2
/////////////////////////////////////////////////////////////////////////
1: import java.lang.reflect.*;
1: import java.util.Enumeration;
1: import java.util.Hashtable;
1: import java.util.Properties;
/////////////////////////////////////////////////////////////////////////
1: 
1: 	// DataSource Type strings used to build up datasource names.
1: 	// e.g. "Embed" + XA_DATASOURCE_STRING + "DataSource
1: 	private static String XA_DATASOURCE_STRING = "XA";
1: 	private static String CONNECTION_POOL_DATASOURCE_STRING = "ConnectionPool";
1: 	private static String REGULAR_DATASOURCE_STRING = "";
1: 	
/////////////////////////////////////////////////////////////////////////
1: 
1: 	/**
1: 	 * Get a data source for the appropriate framework
1: 	 * @param attrs  A set of attribute values to set on the datasource.
1: 	 *                The appropriate setter method wil b
1: 	 *                For example the property databaseName with value wombat,
1: 	 *                will mean ds.setDatabaseName("wombat") will be called
1: 	 *  @return datasource for current framework
1: 	 */
0: 	public static javax.sql.DataSource getDataSource(Properties attrs)
1: 	{
1: 		
0: 		String classname = getDataSourcePrefix() + REGULAR_DATASOURCE_STRING + "DataSource";
0: 		return (javax.sql.DataSource) getDataSourceWithReflection(classname, attrs);
1: 	}
1: 
1: 	/**
1: 	 * Get an xa  data source for the appropriate framework
1: 	 * @param attrs  A set of attribute values to set on the datasource.
1: 	 *                The appropriate setter method wil b
1: 	 *                For example the property databaseName with value wombat,
1: 	 *                will mean ds.setDatabaseName("wombat") will be called
1: 	 *  @return datasource for current framework
1: 	 */
0: 	public static javax.sql.XADataSource getXADatasource(Properties attrs)
1: 	{
1: 		
0: 		String classname = getDataSourcePrefix() + XA_DATASOURCE_STRING + "DataSource";
0: 		return (javax.sql.XADataSource) getDataSourceWithReflection(classname, attrs);
1: 	}
1: 
1: 	
1: 	/**
1: 	 * Get a ConnectionPoolDataSource  for the appropriate framework
1: 	 * @param attrs  A set of attribute values to set on the datasource.
1: 	 *                The appropriate setter method wil b
1: 	 *                For example the property databaseName with value wombat,
1: 	 *                will mean ds.setDatabaseName("wombat") will be called
1: 	 *  @return datasource for current framework
1: 	 */
0: 	public static javax.sql.ConnectionPoolDataSource getConnectionPoolDataSource(Properties attrs)
1: 	{
1: 		
0: 		String classname = getDataSourcePrefix() + CONNECTION_POOL_DATASOURCE_STRING + "DataSource";
0: 		return (javax.sql.ConnectionPoolDataSource) getDataSourceWithReflection(classname, attrs);
1: 	}
1: 
0: 	private static String getDataSourcePrefix()
1: 		{
1: 			framework = getFramework();
1: 			switch(framework)
1: 			{
1: 				case OLD_NET_FRAMEWORK:
1: 				case DERBY_NET_FRAMEWORK:
1: 				case DB2JCC_FRAMEWORK:
1: 					return "com.ibm.db2.jcc.DB2";
1: 				case DERBY_NET_CLIENT_FRAMEWORK:
1: 					return "org.apache.derby.jdbc.Client";
1: 				case EMBEDDED_FRAMEWORK:
0: 					return "org.apache.derby.jdbc.Embed";
1: 				default:
1: 					Exception e = new Exception("FAIL: No DataSource Prefix for framework: " + framework);
1: 					e.printStackTrace();
1: 			}
1: 			return null;
1: 		}
1: 
1: 	static private Class[] STRING_ARG_TYPE = {String.class};
1: 	static private Class[] INT_ARG_TYPE = {Integer.TYPE};
1: 	static private Class[] BOOLEAN_ARG_TYPE = { Boolean.TYPE };
1: 	// A hashtable of special non-string attributes.
0: 	private static Hashtable specialAttributes = null;
1: 	
1: 
1: 	private static Object getDataSourceWithReflection(String classname, Properties attrs)
1: 	{
1: 		Object[] args = null;
1: 		Object ds = null;
1: 		Method sh = null;
1: 
1: 		
1: 		if (specialAttributes == null)
1: 		{
0: 			specialAttributes = new Hashtable();
1: 			specialAttributes.put("portNumber",INT_ARG_TYPE);
1: 			specialAttributes.put("driverType",INT_ARG_TYPE);
1: 			specialAttributes.put("retrieveMessagesFromServerOnGetMessage",
1: 								  BOOLEAN_ARG_TYPE);
1: 		}
1: 		
1: 		try {
0: 		ds  = Class.forName(classname).newInstance();
1: 
1: 		for (Enumeration propNames = attrs.propertyNames(); 
1: 			 propNames.hasMoreElements();)
1: 		{
1: 			String key = (String) propNames.nextElement();
1: 			Class[] argType = (Class[]) specialAttributes.get(key);
1: 			if (argType == null) 
1: 				argType = STRING_ARG_TYPE;
1: 			String value = attrs.getProperty(key);
1: 			if (argType  == INT_ARG_TYPE)
1: 			{
1: 				args = new Integer[] 
0: 				{ new Integer(Integer.parseInt(value)) };	
1: 			}
1: 			else if (argType  == BOOLEAN_ARG_TYPE)
1: 			{
0: 				args = new Boolean[] { new Boolean(value) };	
1: 			}
1: 			else if (argType == STRING_ARG_TYPE)
1: 			{
1: 				args = new String[] { value };
1: 			}
1: 			else  // No other property types supported right now
1: 			{
1: 				throw new Exception("FAIL: getDataSourceWithReflection: Argument type " + argType[0].getName() +  " not supportted for attribute: " +
1: 									" key:" + key + " value:" +value);
1: 			   
1: 			}
0: 			String methodName = getSetterName(key);
1: 
1: 			
1: 			// Need to use reflection to load indirectly
1: 			// setDatabaseName
1: 			sh = ds.getClass().getMethod(methodName, argType);
1: 			sh.invoke(ds, args);
1: 		}
1: 
1: 		} catch (Exception e)
1: 		{
1: 			System.out.println(e.getMessage());
1: 			e.printStackTrace();
1: 		}
1: 		return ds;
1: 	}
1: 
1: 	
0: 	private static String  getSetterName(String attribute)
1: 	{
1: 		return "set" + Character.toUpperCase(attribute.charAt(0)) + attribute.substring(1);
1: 	}
1: 
1: 	
1: 	// Some methods for test output.
/////////////////////////////////////////////////////////////////////////
commit:0bbfdac
/////////////////////////////////////////////////////////////////////////
1: import java.util.Locale;
1: 	Utility methods for tests, in order to bring some consistency to test
1: 	output and handle testing framework differences
1: 
1: 	public static final int UNKNOWN_FRAMEWORK = -1;
1: 
1: 	/**
1: 	   framework = embedded (or null) jdbc:derby:
1: 	*/
1: 	public static final int EMBEDDED_FRAMEWORK = 0;
1: 	
1: 	/**
1: 	   framework = DerbyNet for JCC  jdbc:derby:net:
1: 	*/
1: 	public static final int DERBY_NET_FRAMEWORK = 1;
1: 
1: 	/**
1: 	   framework = DB2JCC  for testing JCC against DB2 for 
1: 	   debugging jcc problems jdbc:db2://
1: 	*/
1: 
1: 	public  static final int DB2JCC_FRAMEWORK = 2; // jdbc:db2//
1: 	
1: 	/**
1: 	   framework = DerbyNetClient  for Derby cient  jdbc:derby://
1: 	*/
1: 	public static final int DERBY_NET_CLIENT_FRAMEWORK = 3; // jdbc:derby://
1: 
1: 
1: 	/**
1: 	   framework = DB2jNet 
1: 	   OLD_NET_FRAMEWORK is for tests that have not yet been contributed.
1: 	   it can be removed once all tests are at apache
1: 	*/
1: 	public  static final int OLD_NET_FRAMEWORK = 4;          // jdbc:derby:net:
1: 
1: 
1: 	private static int framework = UNKNOWN_FRAMEWORK;
1: 
1: 	// Methods for making framework dependent decisions in tests.
1: 
1: 	/**
1: 	 * Is this a network testingframework? 
1: 	 * return true if the System Property framework is set to Derby Network
1: 	 * client or JCC
1: 	 *
1: 	 * @return true if this is a Network Server test
1: 	 */
1: 	public static boolean isNetFramework()
1: 	{
1: 		framework = getFramework();
1: 		switch (framework)
1: 		{
1: 			case DERBY_NET_FRAMEWORK:
1: 			case DERBY_NET_CLIENT_FRAMEWORK:
1: 			case DB2JCC_FRAMEWORK:
1: 			case OLD_NET_FRAMEWORK:
1: 				return true;
1: 			default:
1: 				return false;
1: 		}
1: 	}
1: 			
1: 	/** 
1: 		Is the JCC driver being used
1: 	  
1: 		@return true for JCC driver
1: 	*/
1: 	public static boolean isJCCFramework()
1: 	{
1: 		int framework = getFramework();
1: 		switch (framework)
1: 		{
1: 			case DERBY_NET_FRAMEWORK:
1: 			case DB2JCC_FRAMEWORK:
1: 			case OLD_NET_FRAMEWORK:
1: 				return true;
1: 		}
1: 		return false;
1: 	}
1: 
1: 	/**
1: 	   Get the framework from the System Property framework
1: 	   @return  constant for framework being used
1: 	       TestUtil.EMBEDDED_FRAMEWORK  for embedded
1: 		   TestUtil.DERBY_NET_CLIENT_FRAMEWORK  for Derby Network Client 
1: 		   TestUtil.DERBY_NET_FRAMEWORK for JCC to Network Server
1: 		   TestUtil.DB2JCC_FRAMEWORK for JCC to DB2
1: 	*/
1: 	private static int getFramework()
1: 	{
1: 		if (framework != UNKNOWN_FRAMEWORK)
1: 			return framework;
0: 		String frameworkString = System.getProperty("framework");
1: 		if (frameworkString == null || 
1: 		   frameworkString.toUpperCase(Locale.ENGLISH).equals("EMBEDDED"))
1: 			framework = EMBEDDED_FRAMEWORK;
1: 		else if (frameworkString.toUpperCase(Locale.ENGLISH).equals("DERBYNETCLIENT"))
1: 			framework = DERBY_NET_CLIENT_FRAMEWORK;
1: 		else if (frameworkString.toUpperCase(Locale.ENGLISH).equals("DERBYNET"))
1: 			framework = DERBY_NET_FRAMEWORK;
1: 		else if (frameworkString.toUpperCase(Locale.ENGLISH).indexOf("DB2JNET") != -1)
1: 			framework = OLD_NET_FRAMEWORK;
1: 
1: 		return framework;
1: 
1: 	}
1: 
1: 	/**
1: 	    Get URL prefix for current framework.
1: 		
0: 		@return url, assume localhost and port 1527 for Network Tests
0: 		@see getJdbcUrlPrefix(String server, int port)
1: 		
1: 	*/
1: 	public static String getJdbcUrlPrefix()
1: 	{
0: 		return getJdbcUrlPrefix("localhost", 1527);
1: 	}
1: 
1: 	/** 
1: 		Get URL prefix for current framework		
1: 		
1: 		@param server  host to connect to with client driver 
1: 		               ignored for embedded driver
1: 		@param port    port to connect to with client driver
1: 		               ignored with embedded driver
1: 		@return URL prefix
1: 		        EMBEDDED_FRAMEWORK returns "jdbc:derby"
1: 				DERBY_NET_FRAMEWORK = "jdbc:derby:net://<server>:port/"
1: 				DERBY_NET_CLIENT_FRAMEWORK = "jdbc:derby://<server>:port/"
1: 				DB2_JCC_FRAMEWORK = "jdbc:db2://<server>:port/"
1: 	*/
1: 	public static String getJdbcUrlPrefix(String server, int port)
1: 	{
1: 		int framework = getFramework();
1: 		switch (framework)
1: 		{
1: 			case EMBEDDED_FRAMEWORK:
1: 				return "jdbc:derby:";
1: 			case DERBY_NET_FRAMEWORK:
1: 			case OLD_NET_FRAMEWORK:								
1: 				return "jdbc:derby:net://" + server + ":" + port + "/";
1: 			case DERBY_NET_CLIENT_FRAMEWORK:
1: 				return "jdbc:derby://" + server + ":" + port + "/";
1: 			case DB2JCC_FRAMEWORK:				
1: 				return "jdbc:db2://" + server + ":" + port + "/";
1: 		}
1: 		// Unknown framework
1: 		return null;
1: 		
1: 	}
1: 
1: 	/**
1: 	   Load the appropriate driver for the current framework
1: 	*/
1: 	public static void loadDriver() throws Exception
1: 	{
0: 		String driverName = null;
1: 		framework = getFramework();
1: 		switch (framework)
1: 		{
1: 			case EMBEDDED_FRAMEWORK:
1: 				driverName =  "org.apache.derby.jdbc.EmbeddedDriver";
1: 				break;
1: 			case DERBY_NET_FRAMEWORK:
1: 			case OLD_NET_FRAMEWORK:				
1: 			case DB2JCC_FRAMEWORK:				
1: 				driverName = "com.ibm.db2.jcc.DB2Driver";
1: 				break;
1: 			case DERBY_NET_CLIENT_FRAMEWORK:
1: 				driverName = "org.apache.derby.jdbc.ClientDriver";
1: 				break;
1: 		}
0: 		Class.forName(driverName).newInstance();
1: 	}
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1: 
1: 
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:1a4ea31
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 			case Types.BOOLEAN  : return "Types.BOOLEAN";
/////////////////////////////////////////////////////////////////////////
1: 			case Types.BOOLEAN  : return "Types.BOOLEAN";
commit:f68f62f
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derbyTesting.functionTests.util.TestUtil
1: 
0:    Copyright 1999, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: 
1: package org.apache.derbyTesting.functionTests.util;
1: 
1: import java.sql.*;
1: import java.io.*;
0: import org.apache.derby.iapi.reference.JDBC30Translation;
1: 
1: 
1: /**
0: 	Utility methods for tests, in order to bring some consistency to test output.
1: */
1: public class TestUtil {
1: 
1: 	public static void dumpSQLExceptions(SQLException sqle) {
1: 		TestUtil.dumpSQLExceptions(sqle, false);
1: 	}
1: 
1: 	public static void dumpSQLExceptions(SQLException sqle, boolean expected) {
1: 		String prefix = "";
1: 		if (!expected) {
1: 			System.out.println("FAIL -- unexpected exception ****************");
1: 		}
0: 		else
1: 		{
1: 			prefix = "EXPECTED ";
1: 		}
1: 
1: 		do
1: 		{
1: 			System.out.println(prefix + "SQLSTATE("+sqle.getSQLState()+"): " + sqle.getMessage());
1: 			sqle = sqle.getNextException();
1: 		} while (sqle != null);
1: 	}
1: 
1: 
1: 	  public static String sqlNameFromJdbc(int jdbcType) {
1: 		switch (jdbcType) {
1: 			case Types.BIT 		:  return "Types.BIT";
0: 			case JDBC30Translation.SQL_TYPES_BOOLEAN  : return "Types.BOOLEAN";
1: 			case Types.TINYINT 	:  return "Types.TINYINT";
1: 			case Types.SMALLINT	:  return "SMALLINT";
1: 			case Types.INTEGER 	:  return "INTEGER";
1: 			case Types.BIGINT 	:  return "BIGINT";
1: 
1: 			case Types.FLOAT 	:  return "Types.FLOAT";
1: 			case Types.REAL 	:  return "REAL";
1: 			case Types.DOUBLE 	:  return "DOUBLE";
1: 
1: 			case Types.NUMERIC 	:  return "Types.NUMERIC";
1: 			case Types.DECIMAL	:  return "DECIMAL";
1: 
1: 			case Types.CHAR		:  return "CHAR";
1: 			case Types.VARCHAR 	:  return "VARCHAR";
1: 			case Types.LONGVARCHAR 	:  return "LONG VARCHAR";
1:             case Types.CLOB     :  return "CLOB";
1: 
1: 			case Types.DATE 		:  return "DATE";
1: 			case Types.TIME 		:  return "TIME";
1: 			case Types.TIMESTAMP 	:  return "TIMESTAMP";
1: 
1: 			case Types.BINARY			:  return "CHAR () FOR BIT DATA";
1: 			case Types.VARBINARY	 	:  return "VARCHAR () FOR BIT DATA";
1: 			case Types.LONGVARBINARY 	:  return "LONG VARCHAR FOR BIT DATA";
1:             case Types.BLOB             :  return "BLOB";
1: 
1: 			case Types.OTHER		:  return "Types.OTHER";
1: 			case Types.NULL		:  return "Types.NULL";
1: 			default : return String.valueOf(jdbcType);
1: 		}
1: 	}
0: 	  public static String jdbcNameFromJdbc(int jdbcType) {
1: 		switch (jdbcType) {
1: 			case Types.BIT 		:  return "Types.BIT";
0: 			case JDBC30Translation.SQL_TYPES_BOOLEAN  : return "Types.BOOLEAN";
1: 			case Types.TINYINT 	:  return "Types.TINYINT";
1: 			case Types.SMALLINT	:  return "Types.SMALLINT";
1: 			case Types.INTEGER 	:  return "Types.INTEGER";
1: 			case Types.BIGINT 	:  return "Types.BIGINT";
1: 
1: 			case Types.FLOAT 	:  return "Types.FLOAT";
1: 			case Types.REAL 	:  return "Types.REAL";
1: 			case Types.DOUBLE 	:  return "Types.DOUBLE";
1: 
1: 			case Types.NUMERIC 	:  return "Types.NUMERIC";
1: 			case Types.DECIMAL	:  return "Types.DECIMAL";
1: 
1: 			case Types.CHAR		:  return "Types.CHAR";
1: 			case Types.VARCHAR 	:  return "Types.VARCHAR";
1: 			case Types.LONGVARCHAR 	:  return "Types.LONGVARCHAR";
1:             case Types.CLOB     :  return "Types.CLOB";
1: 
1: 			case Types.DATE 		:  return "Types.DATE";
1: 			case Types.TIME 		:  return "Types.TIME";
1: 			case Types.TIMESTAMP 	:  return "Types.TIMESTAMP";
1: 
1: 			case Types.BINARY			:  return "Types.BINARY";
1: 			case Types.VARBINARY	 	:  return "Types.VARBINARY";
1: 			case Types.LONGVARBINARY 	:  return "Types.LONGVARBINARY";
1:             case Types.BLOB             :  return "Types.BLOB";
1: 
1: 			case Types.OTHER		:  return "Types.OTHER";
1: 			case Types.NULL		:  return "Types.NULL";
1: 			default : return String.valueOf(jdbcType);
1: 		}
1: 	}
1: 
1: 	/*** Some routines for printing test information to html  **/
1: 
1: 	public static String TABLE_START_TAG =  "<TABLE border=1 cellspacing=1 cellpadding=1  bgcolor=white  style='width:100%'>";
1: 	public static String TABLE_END_TAG = "</TABLE>";
1: 	public static String TD_INVERSE =
1: 		"<td  valign=bottom align=center style=background:#DADADA;  padding:.75pt .75pt .75pt .75pt'> <p class=MsoNormal style='margin-top:6.0pt;margin-right:0in;margin-bottom:  6.0pt;margin-left:0in'><b><span style='font-size:8.5pt;font-family:Arial;  color:black'>";
1: 
1: 	public static String TD_CENTER = "<TD valign=center align=center> <p class=MsoNormal style='margin-top:6.0pt;margin-right:0in;margin-bottom:6.0pt;margin-left:0in'><b><span style='font-size:8.5pt;font-family:Arial;  color:black'>";
1: 
1: 	public static String TD_LEFT = "<TD valign=center align=left> <p class=MsoNormal style='margin-top:6.0pt;margin-right:0in;margin-bottom:6.0pt;margin-left:0in'><b><span style='font-size:8.5pt;font-family:Arial;  color:black'>";
1: 
1: 	
1: 	public static String TD_END = "</SPAN></TD>";
1: 
1: 	public static String END_HTML_PAGE="</BODY> </HTML>";
1: 	
1: 
1: 	public static void startHTMLPage(String title, String author)
1: 	{
1: 		System.out.println("<HTML> \n <HEAD>");
1: 		System.out.println(" <meta http-equiv=\"Content-Type\"content=\"text/html; charset=iso-8859-1\">");
1: 		System.out.println("<meta name=\"Author\" content=\"" + author +  "\">");
1: 		System.out.println("<title>" + title + "</title>");
1: 		System.out.println("</HEAD> <BODY>");
1: 		System.out.println("<H1>" + title + "</H1>");
1: 	}
1: 
1: 	public static void endHTMLPage()
1: 	{
1: 		System.out.println(END_HTML_PAGE);
1: 	}
1: 
1: /*	public static void main(String[] argv)
1: 	{
1: 		testBoolArrayToHTMLTable();
1: 	}
1: */
1: 
1: 	/** 
1: 	 * Converts 2 dimensional boolean array into an HTML table.
1: 	 * used by casting.java to print out casting doc
1: 	 *
1: 	 * @param rowLabels   - Row labels
1: 	 * @param colLabels   - Column labels
1: 	 **/
1: 	public static void printBoolArrayHTMLTable(String rowDescription,
1: 											   String columnDescription,
1: 											   String [] rowLabels, 
1: 											   String [] colLabels,
1: 											   boolean[][] array,
1: 											   String tableInfo)
1: 	{
1: 
1: 		System.out.println("<H2>" + tableInfo + "</H2>");
1: 
1: 		System.out.println(TABLE_START_TAG);
1: 		System.out.println("<TR>");
1: 		// Print corner with labels
1: 		System.out.println(TD_INVERSE +columnDescription + "---><BR><BR><BR><BR><BR>");
1: 		System.out.println("<---" +rowDescription);
1: 		System.out.println(TD_END);
1: 
1: 		
1: 		// Print column headers
1: 		for (int i = 0; i < colLabels.length; i++)
1: 		{
1: 			System.out.println(TD_INVERSE);
1: 			for (int c = 0; c < colLabels[i].length() && c < 20; c++)
1: 			{
1: 				System.out.println(colLabels[i].charAt(c) + "<BR>");
1: 			}
1: 			System.out.println(TD_END);
1: 		}
1: 
1: 		System.out.println("</TR>");
1: 
1: 		// Print the Row Labels and Data
1: 		for (int i = 0; i < rowLabels.length; i ++)
1: 		{
1: 			System.out.println("<TR>");
1: 			System.out.println(TD_LEFT);
1: 			System.out.println("<C> " +  rowLabels[i] + "</C>");
1: 			System.out.println(TD_END);
1: 
1: 			for (int j = 0; j < colLabels.length; j ++)
1: 			{
1: 				System.out.println(TD_CENTER);
1: 				System.out.println((array[i][j]) ? "Y" : "-");
1: 				System.out.println(TD_END);
1: 			}
1: 			System.out.println("</TR>");
1: 		}
1: 
1: 
1: 		System.out.println(TABLE_END_TAG);
1: 		System.out.println("<P><P>");
1: 
1: 	}
1: 
1: 	/**
1: 	 * Just converts a string to a hex literal to assist in converting test
1: 	 * cases that used to insert strings into bit data tables
1: 	 * Converts using UTF-16BE just like the old casts used to.
1: 	 *
0: 	 * @ param s  String to convert  (e.g
0: 	 * @ resturns hex literal that can be inserted into a bit column.
1: 	 */
1: 	public static String stringToHexLiteral(String s)
1: 	{
1: 		byte[] bytes;
1: 		String hexLiteral = null;
1: 		try {
1: 			bytes = s.getBytes("UTF-16BE");
1: 			hexLiteral = convertToHexString(bytes);
1: 		}
1: 		catch (UnsupportedEncodingException ue)
1: 		{
1: 			System.out.println("This shouldn't happen as UTF-16BE should be supported");
1: 			ue.printStackTrace();
1: 		}
1: 
1: 		return hexLiteral;
1: 	}
1: 
1: 	private static String convertToHexString(byte [] buf)
1: 	{
1: 		StringBuffer str = new StringBuffer();
1: 		str.append("X'");
1: 		String val;
1: 		int byteVal;
1: 		for (int i = 0; i < buf.length; i++)
1: 		{
1: 			byteVal = buf[i] & 0xff;
1: 			val = Integer.toHexString(byteVal);
1: 			if (val.length() < 2)
1: 				str.append("0");
1: 			str.append(val);
1: 		}
1: 		return str.toString() +"'";
1: 	}
1: 
1: 
1: 
1: 	/**
1: 		Get the JDBC version, inferring it from the driver.
0: 		We cannot use the JDBC DatabaseMetaData method
0: 		as it is not present in JDBC 2.0.
1: 	*/
1: 
1: 	public static int getJDBCMajorVersion(Connection conn)
1: 	{
1: 		try {
1: 			conn.getClass().getMethod("setSavepoint", null);
0: 			return 3;
0: 		} catch (NoSuchMethodException e) {
1: 			return 2;
0: 		} catch (NoClassDefFoundError e2) {
1: 			return 2;
1: 		}
1: 
1: 	}
1: 
1: 
1: }
1: 
1: 
1: 
commit:c1c71ef
/////////////////////////////////////////////////////////////////////////
0:    Derby - Class org.apache.derbyTesting.functionTests.util.TestUtil
0: 
0:    Copyright 1999, 2004 The Apache Software Foundation or its licensors, as applicable.
0: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
0: 
0:       http://www.apache.org/licenses/LICENSE-2.0
0: 
0:    Unless required by applicable law or agreed to in writing, software
0:    distributed under the License is distributed on an "AS IS" BASIS,
0:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:    See the License for the specific language governing permissions and
0:    limitations under the License.
commit:cb1ca12
/////////////////////////////////////////////////////////////////////////
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:df4020d
/////////////////////////////////////////////////////////////////////////
1: 		@see #getJdbcUrlPrefix(String server, int port)
/////////////////////////////////////////////////////////////////////////
1: 	 * @param s  String to convert  (e.g
1: 	 * @return hex literal that can be inserted into a bit column.
commit:15651f5
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:d1c8b24
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.functionTests.harness.RunTest;
/////////////////////////////////////////////////////////////////////////
1: 		// last attempt to get useprocess to do networkserver stuff.
1: 		// If a suite has useprocess, it's possible there was no property set.
1: 		if (frameworkString == null)
1: 		{
1: 		   String useprocessFramework = RunTest.framework;
1: 		   if (useprocessFramework != null)
1: 			frameworkString = useprocessFramework;
1: 		}
commit:37952cf
/////////////////////////////////////////////////////////////////////////
1:                         url += ":" + "user=APP;password=APP;retrieveMessagesFromServerOnGetMessage=true;";
commit:4a95eeb
/////////////////////////////////////////////////////////////////////////
1: 		// for remote server testing, check whether the hostName is set for the test
1: 		// if so, and serverName is not yet set explicitly for the datasource, set it now
1: 		String hostName = getHostName();
1: 		if ( (!isEmbeddedFramework()) && (hostName != null ) && (attrs.getProperty("serverName") == null) )
1: 			attrs.setProperty("serverName", hostName);
0: 
commit:e72bcdd
/////////////////////////////////////////////////////////////////////////
1:     public static Connection getConnection(String databaseName, String connAttrs)
1:     	throws SQLException {
1:         try {
0:             Connection conn;
0:             if(TestUtil.HAVE_DRIVER_CLASS) {
1:                 // following is like loadDriver(), but
1:                 // that method throws Exception, we want finer granularity
1:                 String driverName;
1:                 int framework = getFramework();
1:                 switch (framework)
1:                 {
1:                     case EMBEDDED_FRAMEWORK:
1:                         driverName =  "org.apache.derby.jdbc.EmbeddedDriver";
1:                         break;
1:                     case DERBY_NET_FRAMEWORK:
1:                     case OLD_NET_FRAMEWORK:				
1:                     case DB2JCC_FRAMEWORK:				
1:                         driverName = "com.ibm.db2.jcc.DB2Driver";
1:                         break;
1:                     case DERBY_NET_CLIENT_FRAMEWORK:
1:                         driverName = "org.apache.derby.jdbc.ClientDriver";
1:                         break;
1:                     default:
1:                         driverName =  "org.apache.derby.jdbc.EmbeddedDriver";
1:                         break;
1:                 } 
1:                 // q: do we need a privileged action here, like in loadDriver?
0:                 Class.forName(driverName).newInstance();
0: 				
1:                 String url = getJdbcUrlPrefix() + databaseName;
1:                 if (connAttrs != null) url += ";" + connAttrs;
1:                 if (framework == DERBY_NET_FRAMEWORK)
1:                 {
1:                     if (( connAttrs == null) || ((connAttrs != null) && (connAttrs.indexOf("user") < 0)))
0:                         url += ":" + "user=me;password=mine;retrieveMessagesFromServerOnGetMessage=true;";
1:                 }
1:                 conn = DriverManager.getConnection(url);
1:     	    }
0:     	    else {
0:     		    //Use DataSource for JSR169
0: 	    	    Properties prop = new Properties();
0: 	            prop.setProperty("databaseName", databaseName);
1:     		    if (connAttrs != null)
0: 	                prop.setProperty("connectionAttributes", connAttrs);
0: 	            conn = getDataSourceConnection(prop);
1:     	    }
0:             return conn;
1:     	} catch (ClassNotFoundException cnfe) { 
1: 		    System.out.println("FAILure: Class not found!");
1: 		    cnfe.printStackTrace();
1: 		    return null;
1:     	} catch (InstantiationException inste) {
1:     		System.out.println("FAILure: Cannot instantiate class");
1:     		inste.printStackTrace();
1:     		return null;
1:     	} catch (IllegalAccessException ille) {
1:     		System.out.println("FAILure: Not allowed to use class");
1:     		ille.printStackTrace();
1:     		return null;
commit:5ff5941
/////////////////////////////////////////////////////////////////////////
1: 		@return url, assume localhost - unless set differently in System property - 
1: 		             and assume port 1527 for Network Tests
0:     public static String getJdbcUrlPrefix()
0:     {
1:         String hostName=getHostName();
1:         return getJdbcUrlPrefix(hostName, 1527);
1:     }
0: 
1:     /** Get hostName as passed in - if not, set it to "localhost" 
1:         @return hostName, as passed into system properties, or "localhost"
1:     */
1:     public static String getHostName()
0:     {
0:         String hostName = (System.getProperty("hostName"));
1:         if (hostName == null)
1:             hostName="localhost";
1:         return hostName;
1:     }
/////////////////////////////////////////////////////////////////////////
0: 
0:     /**
1:         Drop the test objects passed in as a string identifying the
1:         type of object (e.g. TABLE, PROCEDURE) and its name.
1:         Thus, for example, a testObject array could be:
1:         {"TABLE MYSCHEMA.MYTABLE", "PROCEDURE THISDUMMY"}
1:         The statement passed in must be a 'live' statement in the test.
0:     */
1:     public static void cleanUpTest (Statement s, String[] testObjects)
1:                                     throws SQLException {
1:         /* drop each object named */
1:         for (int i=0; i < testObjects.length; i++) {
0:             try {
1:                 s.execute("drop " + testObjects[i]);
1:                 //System.out.println("now dropping " + testObjects[i]);
1:             } catch (SQLException se) { // ignore...
1:             }
1:         }	
1:     }
0: 
/////////////////////////////////////////////////////////////////////////
0: 
commit:67614ad
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derbyTesting.functionTests.util
0:    (C) Copyright IBM Corp. 1999, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: 
0: package org.apache.derbyTesting.functionTests.util;
0: 
0: import java.sql.*;
0: import java.io.*;
0: import org.apache.derby.iapi.reference.JDBC30Translation;
0: 
0: 
0: /**
0: 	Utility methods for tests, in order to bring some consistency to test output.
0: */
0: public class TestUtil {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1999_2004;
0: 
0: 	public static void dumpSQLExceptions(SQLException sqle) {
0: 		TestUtil.dumpSQLExceptions(sqle, false);
0: 	}
0: 
0: 	public static void dumpSQLExceptions(SQLException sqle, boolean expected) {
0: 		String prefix = "";
0: 		if (!expected) {
0: 			System.out.println("FAIL -- unexpected exception ****************");
0: 		}
0: 		else
0: 		{
0: 			prefix = "EXPECTED ";
0: 		}
0: 
0: 		do
0: 		{
0: 			System.out.println(prefix + "SQLSTATE("+sqle.getSQLState()+"): " + sqle.getMessage());
0: 			sqle = sqle.getNextException();
0: 		} while (sqle != null);
0: 	}
0: 
0: 
0: 	  public static String sqlNameFromJdbc(int jdbcType) {
0: 		switch (jdbcType) {
0: 			case Types.BIT 		:  return "Types.BIT";
0: 			case JDBC30Translation.SQL_TYPES_BOOLEAN  : return "Types.BOOLEAN";
0: 			case Types.TINYINT 	:  return "Types.TINYINT";
0: 			case Types.SMALLINT	:  return "SMALLINT";
0: 			case Types.INTEGER 	:  return "INTEGER";
0: 			case Types.BIGINT 	:  return "BIGINT";
0: 
0: 			case Types.FLOAT 	:  return "Types.FLOAT";
0: 			case Types.REAL 	:  return "REAL";
0: 			case Types.DOUBLE 	:  return "DOUBLE";
0: 
0: 			case Types.NUMERIC 	:  return "Types.NUMERIC";
0: 			case Types.DECIMAL	:  return "DECIMAL";
0: 
0: 			case Types.CHAR		:  return "CHAR";
0: 			case Types.VARCHAR 	:  return "VARCHAR";
0: 			case Types.LONGVARCHAR 	:  return "LONG VARCHAR";
0:             case Types.CLOB     :  return "CLOB";
0: 
0: 			case Types.DATE 		:  return "DATE";
0: 			case Types.TIME 		:  return "TIME";
0: 			case Types.TIMESTAMP 	:  return "TIMESTAMP";
0: 
0: 			case Types.BINARY			:  return "CHAR () FOR BIT DATA";
0: 			case Types.VARBINARY	 	:  return "VARCHAR () FOR BIT DATA";
0: 			case Types.LONGVARBINARY 	:  return "LONG VARCHAR FOR BIT DATA";
0:             case Types.BLOB             :  return "BLOB";
0: 
0: 			case Types.OTHER		:  return "Types.OTHER";
0: 			case Types.NULL		:  return "Types.NULL";
0: 			default : return String.valueOf(jdbcType);
0: 		}
0: 	}
0: 	  public static String jdbcNameFromJdbc(int jdbcType) {
0: 		switch (jdbcType) {
0: 			case Types.BIT 		:  return "Types.BIT";
0: 			case JDBC30Translation.SQL_TYPES_BOOLEAN  : return "Types.BOOLEAN";
0: 			case Types.TINYINT 	:  return "Types.TINYINT";
0: 			case Types.SMALLINT	:  return "Types.SMALLINT";
0: 			case Types.INTEGER 	:  return "Types.INTEGER";
0: 			case Types.BIGINT 	:  return "Types.BIGINT";
0: 
0: 			case Types.FLOAT 	:  return "Types.FLOAT";
0: 			case Types.REAL 	:  return "Types.REAL";
0: 			case Types.DOUBLE 	:  return "Types.DOUBLE";
0: 
0: 			case Types.NUMERIC 	:  return "Types.NUMERIC";
0: 			case Types.DECIMAL	:  return "Types.DECIMAL";
0: 
0: 			case Types.CHAR		:  return "Types.CHAR";
0: 			case Types.VARCHAR 	:  return "Types.VARCHAR";
0: 			case Types.LONGVARCHAR 	:  return "Types.LONGVARCHAR";
0:             case Types.CLOB     :  return "Types.CLOB";
0: 
0: 			case Types.DATE 		:  return "Types.DATE";
0: 			case Types.TIME 		:  return "Types.TIME";
0: 			case Types.TIMESTAMP 	:  return "Types.TIMESTAMP";
0: 
0: 			case Types.BINARY			:  return "Types.BINARY";
0: 			case Types.VARBINARY	 	:  return "Types.VARBINARY";
0: 			case Types.LONGVARBINARY 	:  return "Types.LONGVARBINARY";
0:             case Types.BLOB             :  return "Types.BLOB";
0: 
0: 			case Types.OTHER		:  return "Types.OTHER";
0: 			case Types.NULL		:  return "Types.NULL";
0: 			default : return String.valueOf(jdbcType);
0: 		}
0: 	}
0: 
0: 	/*** Some routines for printing test information to html  **/
0: 
0: 	public static String TABLE_START_TAG =  "<TABLE border=1 cellspacing=1 cellpadding=1  bgcolor=white  style='width:100%'>";
0: 	public static String TABLE_END_TAG = "</TABLE>";
0: 	public static String TD_INVERSE =
0: 		"<td  valign=bottom align=center style=background:#DADADA;  padding:.75pt .75pt .75pt .75pt'> <p class=MsoNormal style='margin-top:6.0pt;margin-right:0in;margin-bottom:  6.0pt;margin-left:0in'><b><span style='font-size:8.5pt;font-family:Arial;  color:black'>";
0: 
0: 	public static String TD_CENTER = "<TD valign=center align=center> <p class=MsoNormal style='margin-top:6.0pt;margin-right:0in;margin-bottom:6.0pt;margin-left:0in'><b><span style='font-size:8.5pt;font-family:Arial;  color:black'>";
0: 
0: 	public static String TD_LEFT = "<TD valign=center align=left> <p class=MsoNormal style='margin-top:6.0pt;margin-right:0in;margin-bottom:6.0pt;margin-left:0in'><b><span style='font-size:8.5pt;font-family:Arial;  color:black'>";
0: 
0: 	
0: 	public static String TD_END = "</SPAN></TD>";
0: 
0: 	public static String END_HTML_PAGE="</BODY> </HTML>";
0: 	
0: 
0: 	public static void startHTMLPage(String title, String author)
0: 	{
0: 		System.out.println("<HTML> \n <HEAD>");
0: 		System.out.println(" <meta http-equiv=\"Content-Type\"content=\"text/html; charset=iso-8859-1\">");
0: 		System.out.println("<meta name=\"Author\" content=\"" + author +  "\">");
0: 		System.out.println("<title>" + title + "</title>");
0: 		System.out.println("</HEAD> <BODY>");
0: 		System.out.println("<H1>" + title + "</H1>");
0: 	}
0: 
0: 	public static void endHTMLPage()
0: 	{
0: 		System.out.println(END_HTML_PAGE);
0: 	}
0: 
0: /*	public static void main(String[] argv)
0: 	{
0: 		testBoolArrayToHTMLTable();
0: 	}
0: */
0: 
0: 	/** 
0: 	 * Converts 2 dimensional boolean array into an HTML table.
0: 	 * used by casting.java to print out casting doc
0: 	 *
0: 	 * @param rowLabels   - Row labels
0: 	 * @param colLabels   - Column labels
0: 	 **/
0: 	public static void printBoolArrayHTMLTable(String rowDescription,
0: 											   String columnDescription,
0: 											   String [] rowLabels, 
0: 											   String [] colLabels,
0: 											   boolean[][] array,
0: 											   String tableInfo)
0: 	{
0: 
0: 		System.out.println("<H2>" + tableInfo + "</H2>");
0: 
0: 		System.out.println(TABLE_START_TAG);
0: 		System.out.println("<TR>");
0: 		// Print corner with labels
0: 		System.out.println(TD_INVERSE +columnDescription + "---><BR><BR><BR><BR><BR>");
0: 		System.out.println("<---" +rowDescription);
0: 		System.out.println(TD_END);
0: 
0: 		
0: 		// Print column headers
0: 		for (int i = 0; i < colLabels.length; i++)
0: 		{
0: 			System.out.println(TD_INVERSE);
0: 			for (int c = 0; c < colLabels[i].length() && c < 20; c++)
0: 			{
0: 				System.out.println(colLabels[i].charAt(c) + "<BR>");
0: 			}
0: 			System.out.println(TD_END);
0: 		}
0: 
0: 		System.out.println("</TR>");
0: 
0: 		// Print the Row Labels and Data
0: 		for (int i = 0; i < rowLabels.length; i ++)
0: 		{
0: 			System.out.println("<TR>");
0: 			System.out.println(TD_LEFT);
0: 			System.out.println("<C> " +  rowLabels[i] + "</C>");
0: 			System.out.println(TD_END);
0: 
0: 			for (int j = 0; j < colLabels.length; j ++)
0: 			{
0: 				System.out.println(TD_CENTER);
0: 				System.out.println((array[i][j]) ? "Y" : "-");
0: 				System.out.println(TD_END);
0: 			}
0: 			System.out.println("</TR>");
0: 		}
0: 
0: 
0: 		System.out.println(TABLE_END_TAG);
0: 		System.out.println("<P><P>");
0: 
0: 	}
0: 
0: 	/**
0: 	 * Just converts a string to a hex literal to assist in converting test
0: 	 * cases that used to insert strings into bit data tables
0: 	 * Converts using UTF-16BE just like the old casts used to.
0: 	 *
0: 	 * @ param s  String to convert  (e.g
0: 	 * @ resturns hex literal that can be inserted into a bit column.
0: 	 */
0: 	public static String stringToHexLiteral(String s)
0: 	{
0: 		byte[] bytes;
0: 		String hexLiteral = null;
0: 		try {
0: 			bytes = s.getBytes("UTF-16BE");
0: 			hexLiteral = convertToHexString(bytes);
0: 		}
0: 		catch (UnsupportedEncodingException ue)
0: 		{
0: 			System.out.println("This shouldn't happen as UTF-16BE should be supported");
0: 			ue.printStackTrace();
0: 		}
0: 
0: 		return hexLiteral;
0: 	}
0: 
0: 	private static String convertToHexString(byte [] buf)
0: 	{
0: 		StringBuffer str = new StringBuffer();
0: 		str.append("X'");
0: 		String val;
0: 		int byteVal;
0: 		for (int i = 0; i < buf.length; i++)
0: 		{
0: 			byteVal = buf[i] & 0xff;
0: 			val = Integer.toHexString(byteVal);
0: 			if (val.length() < 2)
0: 				str.append("0");
0: 			str.append(val);
0: 		}
0: 		return str.toString() +"'";
0: 	}
0: 
0: 
0: 
0: 	/**
0: 		Get the JDBC version, inferring it from the driver.
0: 		We cannot use the JDBC DatabaseMetaData method
0: 		as it is not present in JDBC 2.0.
0: 	*/
0: 
0: 	public static int getJDBCMajorVersion(Connection conn)
0: 	{
0: 		try {
0: 			conn.getClass().getMethod("setSavepoint", null);
0: 			return 3;
0: 		} catch (NoSuchMethodException e) {
0: 			return 2;
0: 		} catch (NoClassDefFoundError e2) {
0: 			return 2;
0: 		}
0: 
0: 	}
0: 
0: 
0: }
0: 
0: 
0: 
author:David Van Couvering
-------------------------------------------------------------------------------
commit:bc50840
/////////////////////////////////////////////////////////////////////////
1: import java.security.AccessController;
1: import java.security.PrivilegedAction;
1: import java.security.PrivilegedExceptionAction;
1: import java.security.PrivilegedActionException;
/////////////////////////////////////////////////////////////////////////
0:               String frameworkString = (String) AccessController.doPrivileged
0:                   (new PrivilegedAction() {
0:                           public Object run() {
1:                               return System.getProperty("framework");
0:                           }
0:                       }
1:                    );              
/////////////////////////////////////////////////////////////////////////
0:         String hostName = (String) AccessController.doPrivileged
0:             (new PrivilegedAction() {
0:                     public Object run() {
1:                         return System.getProperty("hostName");
0:                     }
0:                 }
1:              );    
/////////////////////////////////////////////////////////////////////////
1:               final String driverName;
/////////////////////////////////////////////////////////////////////////
1:                       default: 
1:                             driverName=  "org.apache.derby.jdbc.EmbeddedDriver";
1:                             break;
0:                                 
0:               try {
1:                   AccessController.doPrivileged
0:                       (new PrivilegedExceptionAction() {
0:                               public Object run() throws Exception {
0:                                   return Class.forName(driverName).newInstance();
0:                               }
0:                           }
1:                        );
1:               } catch (PrivilegedActionException e) {
1:                   throw e.getException();
0:               }
0:         }
============================================================================