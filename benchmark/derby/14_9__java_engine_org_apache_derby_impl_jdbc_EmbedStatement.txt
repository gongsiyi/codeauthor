1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.jdbc.EmbedStatement
1:345de35: 
1:88a3cb9:    Licensed to the Apache Software Foundation (ASF) under one or more
1:88a3cb9:    contributor license agreements.  See the NOTICE file distributed with
1:88a3cb9:    this work for additional information regarding copyright ownership.
1:88a3cb9:    The ASF licenses this file to you under the Apache License, Version 2.0
1:88a3cb9:    (the "License"); you may not use this file except in compliance with
1:88a3cb9:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
20:eac0369: 
1:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.jdbc;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.reference.SQLState;
1:eac0369: 
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.sql.Activation;
1:eac0369: import org.apache.derby.iapi.sql.PreparedStatement;
1:eac0369: import org.apache.derby.iapi.sql.ResultSet;
1:eac0369: import org.apache.derby.iapi.sql.ParameterValueSet;
1:eac0369: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:4e3b1b6: import org.apache.derby.iapi.jdbc.EngineStatement;
1:eac0369: 
1:0d57d84: import java.sql.BatchUpdateException;
1:eac0369: import java.sql.SQLException;
1:eac0369: import java.sql.SQLWarning;
1:a0118e1: import java.sql.Statement;
1:0d57d84: import java.util.Arrays;
1:eac0369: import java.util.Vector;
1:3a6f4cf: import org.apache.derby.iapi.util.InterruptStatus;
1:eac0369: 
1:eac0369: /*
1:eac0369:  We would import these, but have name-overlap
1:eac0369: import java.sql.Statement;
1:eac0369: import java.sql.ResultSet;
1:eac0369: */
1:eac0369: 
1:eac0369: /**
1:eac0369:  * EmbedStatement is a local JDBC statement.
1:b5f2776:  * It supports JDBC 4.1.
1:eac0369:  */
1:b5f2776: public class EmbedStatement extends ConnectionChild
1:4e3b1b6:     implements EngineStatement {
1:eac0369: 
1:eac0369: 	private final java.sql.Connection applicationConnection;
1:175a740:     
1:175a740:     /**
1:175a740:      * Statement reference the application is using to execute
1:175a740:      * this Statement. Normally set to this, but if this was
1:175a740:      * created by a Connection from an XAConnection then this
1:175a740:      * will be a reference to the BrokeredStatement.
1:712b41b:      *
1:712b41b:      * Making it protected to allow access from EmbedPreparedStatement40
1:712b41b:      * to be used for StatementEvents
1:712b41b:      *
1:175a740:      */
1:712b41b:     protected EngineStatement applicationStatement;
1:4153b27: 
1:7fb9956: 	long updateCount = -1;
1:4f278dd: 	EmbedResultSet results;
1:eac0369: 	//for jdbc3.0 feature, where you can get a resultset of rows inserted
1:eac0369: 	//for auto generated columns after an insert
1:eac0369: 	private java.sql.ResultSet autoGeneratedKeysResultSet;
1:23b4f8b: 	private String cursorName;
1:eac0369: 
1:23b4f8b: 	private final boolean forMetaData;
1:72cc553: 	final int resultSetType;
1:3657462: 	final int resultSetConcurrency;
1:72cc553: 	private final int resultSetHoldability;
1:23b4f8b: 	final LanguageConnectionContext lcc;
1:eac0369: 
1:eac0369: 	private SQLWarning warnings;
1:23b4f8b: 	String SQLText;
1:eac0369: 
1:eac0369:     private int fetchSize = 1;
1:1e8a20f:     private int fetchDirection = java.sql.ResultSet.FETCH_FORWARD;
1:eac0369:     int MaxFieldSize;
1:c601222: 	/**
1:c601222: 	 * Query timeout in milliseconds. By default, no statements time
1:c601222: 	 * out. Timeout is set explicitly with setQueryTimeout().
1:c601222: 	 */
1:c601222:     long timeoutMillis;
1:eac0369: 
1:eac0369: 	//the state of this statement, set to false when close() is called
1:23b4f8b: 	private boolean active = true;
1:eac0369: 
1:eac0369:     //in case of batch update, save the individual statements in the batch in this vector
1:eac0369:  	//this is only used by JDBC 2.0
1:71c8e86:  	Vector<Object> batchStatements;
1:eac0369: 	
1:eac0369: 	// The maximum # of rows to return per result set.
1:eac0369: 	// (0 means no limit.)
1:47a8183: 	long maxRows;
1:eac0369: 
1:eac0369: 	private ParameterValueSet pvs;
1:eac0369: 
1:7eed914: 	// An EmbedStatement is NOT poolable by default. The constructor for
1:7eed914: 	// PreparedStatement overrides this.
1:7eed914: 	protected boolean isPoolable = false;
1:7eed914: 
1:de8ba18:     private boolean closeOnCompletion = false;
1:de8ba18:     private boolean closingResultSets = false;
1:de8ba18:     
1:eac0369: 	//
1:eac0369: 	// constructor
1:eac0369: 	//
1:eac0369: 	public EmbedStatement (EmbedConnection connection, boolean forMetaData,
1:eac0369: 							  int resultSetType, int resultSetConcurrency, int resultSetHoldability)
2:eac0369: 	{
1:eac0369: 	    super(connection);
1:eac0369: 		this.forMetaData = forMetaData;
1:eac0369: 		this.resultSetType = resultSetType;
1:eac0369: 		this.resultSetConcurrency = resultSetConcurrency;
1:eac0369: 		this.resultSetHoldability = resultSetHoldability;
1:eac0369: 
1:1ae0d7d: 		lcc = getLanguageConnectionContext( getEmbedConnection() );
1:eac0369: 		applicationConnection = getEmbedConnection().getApplicationConnection();
1:175a740:         applicationStatement = this;
1:eac0369: 	}
1:3fcea8a: 
1:eac0369: 	//
1:eac0369: 	// java.sql.Statement interface
1:eac0369: 	// the comments are those from the JDBC interface,
1:eac0369: 	// so we know what we're supposed to to.
1:eac0369: 
1:4f278dd: 	/**
1:eac0369:      * Execute a SQL statement that returns a single ResultSet.
1:7fb9956:      *
1:eac0369:      * @param sql					typically this is a static SQL SELECT statement
1:eac0369: 	 * @return a ResultSet that contains the data produced by the
1:eac0369:      * query; never null
1:eac0369: 	 * @exception SQLException thrown on failure.
1:eac0369:      */
1:eac0369: 	public java.sql.ResultSet executeQuery(String sql)
1:eac0369: 		throws SQLException
1:eac0369: 	{
1:a0118e1: 		execute(sql, true, false, Statement.NO_GENERATED_KEYS, null, null);
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG) {
1:eac0369: 			if (results == null)
1:eac0369: 				SanityManager.THROWASSERT("no results returned on executeQuery()");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return results;
1:eac0369: 	}
1:eac0369: 
1:72cc553:     /**
1:eac0369:      * Execute a SQL INSERT, UPDATE or DELETE statement. In addition,
1:eac0369:      * SQL statements that return nothing such as SQL DDL statements
1:eac0369:      * can be executed.
2:eac0369:      *
1:eac0369:      * @param sql a SQL INSERT, UPDATE or DELETE statement or a SQL
1:eac0369:      * statement that returns nothing
1:eac0369:      * @return either the row count for INSERT, UPDATE or DELETE; or 0
1:eac0369:      * for SQL statements that return nothing
1:eac0369: 	 * @exception SQLException thrown on failure.
1:eac0369:      */
1:eac0369: 	public int executeUpdate(String sql) throws SQLException
1:eac0369: 	{
1:7fb9956: 		return (int) executeLargeUpdate( sql );
1:7fb9956: 	}
1:7fb9956: 
1:7fb9956:     /**
1:f26c60c:      * JDBC 4.2
1:f26c60c:      *
1:7fb9956:      * Execute a SQL INSERT, UPDATE or DELETE statement. For use with
1:7fb9956:      * statements which may touch more than Integer.MAX_VALUE rows.
1:7fb9956:      */
1:7fb9956: 	public long executeLargeUpdate(String sql) throws SQLException
1:7fb9956: 	{
1:a0118e1: 		execute(sql, false, true, Statement.NO_GENERATED_KEYS, null, null);
1:eac0369: 		return updateCount;
1:eac0369: 	}
1:eac0369: 
1:a1a7f8b:     /**
1:eac0369:      * JDBC 3.0
1:eac0369:      *
1:eac0369:      * Execute the given SQL statement and signals the driver with the given flag
1:eac0369:      * about whether the auto-generated keys produced by this Statement object
1:eac0369:      * should be made available for retrieval.
1:eac0369:      *
1:eac0369:      * @param sql a SQL INSERT, UPDATE or DELETE statement or a SQL
1:eac0369:      * statement that returns nothing
1:eac0369:      * @param autoGeneratedKeys - a flag indicating whether auto-generated keys
1:eac0369:      * should be made available for retrieval; one of the following constants:
1:eac0369:      * Statement.RETURN_GENERATED_KEYS Statement.NO_GENERATED_KEYS
1:eac0369:      * @return either the row count for INSERT, UPDATE or DELETE; or 0
1:eac0369:      * for SQL statements that return nothing
1:eac0369:      * @exception SQLException if a database access error occurs
1:eac0369:      */
1:eac0369: 	public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException
1:eac0369: 	{
1:7fb9956: 		return (int) executeLargeUpdate( sql, autoGeneratedKeys );
1:7fb9956: 	}
1:7fb9956: 
1:7fb9956:     /**
1:7fb9956:      * JDBC 4.2
1:7fb9956:      *
1:7fb9956:      * Execute the given SQL statement and signals the driver with the given flag
1:7fb9956:      * about whether the auto-generated keys produced by this Statement object
1:7fb9956:      * should be made available for retrieval. For use with
1:7fb9956:      * statements which may touch more than Integer.MAX_VALUE rows.
1:7fb9956:      */
1:7fb9956: 	public long executeLargeUpdate( String sql, int autoGeneratedKeys ) throws SQLException
1:7fb9956: 	{
1:7fb9956: 		execute( sql, false, true, autoGeneratedKeys, null, null );
1:eac0369: 		return updateCount;
1:eac0369: 	}
1:eac0369: 
1:3fcea8a:     /**
1:eac0369:      * JDBC 3.0
1:eac0369:      *
1:eac0369:      * Executes the given SQL statement and signals the driver that the
1:eac0369:      * auto-generated keys indicated in the given array should be made
1:eac0369:      * available for retrieval. The driver will ignore the array if the SQL
1:eac0369:      * statement is not an INSERT statement
1:eac0369:      *
1:eac0369:      * @param sql a SQL INSERT, UPDATE or DELETE statement or a SQL
1:eac0369:      * statement that returns nothing
1:eac0369:      * @param columnIndexes - an array of column indexes indicating the
1:eac0369:      * columns that should be returned from the inserted row
1:eac0369:      * @return either the row count for INSERT, UPDATE or DELETE; or 0
1:eac0369:      * for SQL statements that return nothing
1:eac0369:      * @exception SQLException if a database access error occurs
1:eac0369:      */
1:eac0369: 	public int executeUpdate(String sql, int[] columnIndexes) throws SQLException
1:eac0369: 	{
1:7fb9956: 		return (int) executeLargeUpdate( sql, columnIndexes );
1:7fb9956: 	}
1:7fb9956: 
1:7fb9956:     /**
1:7fb9956:      * JDBC 4.2
1:7fb9956:      *
1:7fb9956:      * Executes the given SQL statement and signals the driver that the
1:7fb9956:      * auto-generated keys indicated in the given array should be made
1:7fb9956:      * available for retrieval. The driver will ignore the array if the SQL
1:aa302c3:      * statement is not an INSERT/UPDATE statement. For use with
1:7fb9956:      * statements which may touch more than Integer.MAX_VALUE rows.
1:7fb9956:      */
1:7fb9956: 	public long executeLargeUpdate( String sql, int[] columnIndexes ) throws SQLException
1:7fb9956: 	{
1:e3bd4bb: 		execute(sql, false, true,
1:e3bd4bb: 			((columnIndexes == null) || (columnIndexes.length == 0))
1:a0118e1: 				? Statement.NO_GENERATED_KEYS
1:a0118e1: 				: Statement.RETURN_GENERATED_KEYS,
1:e3bd4bb: 			columnIndexes,
1:e3bd4bb: 			null);
1:e3bd4bb: 		return updateCount;
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * JDBC 3.0
1:eac0369:      *
1:eac0369:      * Executes the given SQL statement and signals the driver that the
1:eac0369:      * auto-generated keys indicated in the given array should be made
1:eac0369:      * available for retrieval. The driver will ignore the array if the SQL
1:eac0369:      * statement is not an INSERT statement
1:eac0369:      *
1:eac0369:      * @param sql a SQL INSERT, UPDATE or DELETE statement or a SQL
1:eac0369:      * statement that returns nothing
1:eac0369:      * @param columnNames - an array of the names of the columns
1:eac0369:      * that should be returned from the inserted row
1:eac0369:      * @return either the row count for INSERT, UPDATE or DELETE; or 0
1:eac0369:      * for SQL statements that return nothing
1:eac0369:      * @exception SQLException if a database access error occurs
1:eac0369:      */
1:eac0369: 	public int executeUpdate(String sql, String[] columnNames) throws SQLException
1:eac0369: 	{
1:7fb9956: 		return (int) executeLargeUpdate( sql, columnNames );
1:7fb9956: 	}
1:7fb9956: 
1:7fb9956:     /**
1:7fb9956:      * JDBC 4.2
1:7fb9956:      *
1:7fb9956:      * Executes the given SQL statement and signals the driver that the
1:7fb9956:      * auto-generated keys indicated in the given array should be made
1:7fb9956:      * available for retrieval. The driver will ignore the array if the SQL
1:aa302c3:      * statement is not an INSERT/UPDATE statement. For use with
1:7fb9956:      * statements which may touch more than Integer.MAX_VALUE rows.
1:7fb9956:      */
1:7fb9956: 	public long executeLargeUpdate(String sql, String[] columnNames) throws SQLException
1:7fb9956: 	{
1:e3bd4bb: 		execute(sql, false, true,
1:e3bd4bb: 			((columnNames == null) || (columnNames.length == 0))
1:a0118e1: 				? Statement.NO_GENERATED_KEYS
1:a0118e1: 				: Statement.RETURN_GENERATED_KEYS,
1:e3bd4bb: 			null,
1:e3bd4bb: 			columnNames);
1:eac0369: 		return updateCount;
1:eac0369: 	}
1:eac0369: 
1:23b4f8b: 	final void checkIfInMiddleOfBatch() throws SQLException {
1:eac0369: 		/* If batchStatements is not null then we are in the middle
1:eac0369: 		 * of a batch. That's an invalid state. We need to finish the
1:eac0369: 		 * batch either by clearing the batch or executing the batch.
1:eac0369: 		 * executeUpdate is not allowed inside the batch.
1:eac0369: 		 */
1:eac0369: 		if (batchStatements != null)
1:eac0369:   		throw newSQLException(SQLState.MIDDLE_OF_BATCH);
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:64e1768:      * Tell whether this statment has been closed or not.
1:eac0369:      *
1:64e1768:      * @return <code>true</code> is closed, <code>false</code> otherwise.
1:64e1768:      * @exception SQLException if a database access error occurs.
1:eac0369:      */
1:64e1768:     public boolean isClosed() throws SQLException {
1:64e1768:         // If active, verify state by consulting parent connection.
1:64e1768:         if (active) {
1:64e1768:             try {
1:64e1768:                 checkExecStatus();
1:64e1768:             } catch (SQLException sqle) {
1:eac0369:             }
1:0568a6c:         }
1:64e1768:         return !active;
1:0568a6c:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * In many cases, it is desirable to immediately release a
1:eac0369:      * Statements's database and JDBC resources instead of waiting for
1:eac0369:      * this to happen when it is automatically closed; the close
1:eac0369:      * method provides this immediate release.
1:eac0369:      *
1:eac0369:      * <P><B>Note:</B> A Statement is automatically closed when it is
1:eac0369:      * garbage collected. When a Statement is closed its current
1:eac0369:      * ResultSet, if one exists, is also closed.
1:eac0369: 	 * @exception SQLException thrown on failure.
1:eac0369:      */
1:eac0369: 	public final void close() throws SQLException {
1:eac0369: 
1:eac0369: 		/* The close() method is the only method
1:eac0369: 		 * that is allowed to be called on a closed
1:eac0369: 		 * Statement, as per Jon Ellis.
1:eac0369: 		 */
2:eac0369: 		if (!active)
1:eac0369: 		{
1:eac0369: 			return;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 	  synchronized (getConnectionSynchronization()) {
1:eac0369: 
1:eac0369: 		  closeActions();
1:eac0369: 		  
1:eac0369: 		  //we first set the status
1:eac0369: 		  active = false;
1:eac0369: 
1:de8ba18: 		  // first, clear the result sets.
1:eac0369: 		  clearResultSets();
1:eac0369: 		  
1:eac0369: 		  //next, release other resource
1:eac0369: 		  cursorName = null;
1:eac0369: 		  warnings = null;
1:eac0369: 		  SQLText = null;
1:eac0369: 		  batchStatements = null;
1:eac0369: 	  }
1:eac0369: 	}
1:175a740: 
1:175a740:     /**
1:4f278dd:      * Mark the statement and its single-use activation as unused. This method
1:4f278dd:      * should be called from <code>EmbedPreparedStatement</code>'s finalizer as
1:4f278dd:      * well, even though prepared statements reuse activations, since
1:4f278dd:      * <code>getGeneratedKeys()</code> uses a single-use activation regardless
1:4f278dd:      * of statement type.
1:e836c59:      * <BR>
1:e836c59:      * Dynamic result sets (those in dynamicResults array) need not
1:e836c59:      * be handled here as they will be handled by the statement object
1:e836c59:      * that created them. In some cases results will point to a
1:e836c59:      * ResultSet in dynamicResults but all that will happen is that
1:e836c59:      * the activation will get marked as unused twice.
1:4f278dd:      */
1:4f278dd:     protected void finalize() throws Throwable {
1:4f278dd:         super.finalize();
1:4f278dd: 
1:4f278dd:         // We mark the activation as not being used and
1:4f278dd:         // that is it.  We rely on the connection to sweep
1:4f278dd:         // through the activations to find the ones that
1:4f278dd:         // aren't in use, and to close them.  We cannot
1:4f278dd:         // do a activation.close() here because there are
1:4f278dd:         // synchronized methods under close that cannot
1:4f278dd:         // be called during finalization.
1:4f278dd:         if (results != null && results.singleUseActivation != null) {
1:4f278dd:             results.singleUseActivation.markUnused();
1:4f278dd:         }
1:4f278dd:     }
1:4f278dd: 
1:eac0369: 	// allow sub-classes to execute additional close
1:eac0369: 	// logic while holding the synchronization.
1:0c13195: 	void closeActions() throws SQLException {
1:eac0369: 	}
1:eac0369: 
1:eac0369:     //----------------------------------------------------------------------
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * The maxFieldSize limit (in bytes) is the maximum amount of data
1:eac0369:      * returned for any column value; it only applies to BINARY,
1:eac0369:      * VARBINARY, LONGVARBINARY, CHAR, VARCHAR, and LONGVARCHAR
1:eac0369:      * columns.  If the limit is exceeded, the excess data is silently
1:eac0369:      * discarded.
1:eac0369:      *
1:eac0369:      * @return the current max column size limit; zero means unlimited
1:eac0369: 	 * @exception SQLException thrown on failure.
1:eac0369:      */
1:eac0369: 	public int getMaxFieldSize() throws SQLException {
1:eac0369: 		checkStatus();
1:eac0369: 
1:eac0369:         return MaxFieldSize;
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * The maxFieldSize limit (in bytes) is set to limit the size of
1:eac0369:      * data that can be returned for any column value; it only applies
1:eac0369:      * to BINARY, VARBINARY, LONGVARBINARY, CHAR, VARCHAR, and
1:eac0369:      * LONGVARCHAR fields.  If the limit is exceeded, the excess data
1:eac0369:      * is silently discarded.
1:eac0369:      *
1:eac0369:      * @param max the new max column size limit; zero means unlimited
1:eac0369: 	 * @exception SQLException thrown on failure.
1:eac0369:      */
1:eac0369: 	public void setMaxFieldSize(int max) throws SQLException {
1:eac0369: 		checkStatus();
1:eac0369: 
2:eac0369: 		if (max < 0)
1:eac0369: 		{
1:ce40a31: 			throw newSQLException(SQLState.INVALID_MAXFIELD_SIZE, max);
1:eac0369: 		}
1:eac0369:         this.MaxFieldSize = max;
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * The maxRows limit is the maximum number of rows that a
1:eac0369:      * ResultSet can contain.  If the limit is exceeded, the excess
1:eac0369:      * rows are silently dropped.
1:eac0369:      *
1:eac0369:      * @return the current max row limit; zero means unlimited
1:eac0369: 	 * @exception SQLException thrown on failure.
1:eac0369:      */
1:eac0369: 	public int getMaxRows() throws SQLException 
1:eac0369: 	{
1:47a8183:         return (int) getLargeMaxRows();
1:47a8183: 	}
1:47a8183: 
1:47a8183:     /**
1:47a8183:      * JDBC 4.2
1:47a8183:      *
1:47a8183:      * The maxRows limit is the maximum number of rows that a
1:47a8183:      * ResultSet can contain.  If the limit is exceeded, the excess
1:47a8183:      * rows are silently dropped. For use with
1:47a8183:      * statements which may touch more than Integer.MAX_VALUE rows.
1:47a8183:      *
1:47a8183:      * @return the current max row limit; zero means unlimited
1:47a8183: 	 * @exception SQLException thrown on failure.
1:47a8183:      */
1:47a8183: 	public long getLargeMaxRows() throws SQLException 
1:47a8183: 	{
1:eac0369: 		checkStatus();
1:eac0369: 		return maxRows;
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * The maxRows limit is set to limit the number of rows that any
1:eac0369:      * ResultSet can contain.  If the limit is exceeded, the excess
1:eac0369:      * rows are silently dropped.
1:eac0369:      *
1:eac0369:      * @param max the new max rows limit; zero means unlimited
1:eac0369: 	 * @exception SQLException thrown on failure.
1:eac0369:      */
1:eac0369: 	public void setMaxRows(int max) throws SQLException	
1:eac0369: 	{
1:47a8183:         setLargeMaxRows( max );
1:47a8183: 	}
1:47a8183: 
1:47a8183:     /**
1:47a8183:      * The maxRows limit is set to limit the number of rows that any
1:47a8183:      * ResultSet can contain.  If the limit is exceeded, the excess
1:47a8183:      * rows are silently dropped.
1:47a8183:      *
1:47a8183:      * @param max the new max rows limit; zero means unlimited
1:47a8183: 	 * @exception SQLException thrown on failure.
1:47a8183:      */
1:47a8183: 	public void setLargeMaxRows(long max) throws SQLException	
1:47a8183: 	{
1:eac0369: 		checkStatus();
1:47a8183: 		if (max < 0L)
1:eac0369: 		{
1:ce40a31: 			throw newSQLException(SQLState.INVALID_MAX_ROWS_VALUE, max);
1:eac0369: 		}
1:eac0369: 		this.maxRows = max;
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * If escape scanning is on (the default) the driver will do
1:eac0369:      * escape substitution before sending the SQL to the database.
1:eac0369:      *
1:eac0369:      * @param enable true to enable; false to disable
1:eac0369: 	 * @exception SQLException thrown on failure.
1:eac0369:      */
1:eac0369: 	public void setEscapeProcessing(boolean enable) throws SQLException	{
1:eac0369: 		checkStatus();
1:eac0369:         // Nothing to do in our server , just ignore it.
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * The queryTimeout limit is the number of seconds the driver will
1:eac0369:      * wait for a Statement to execute. If the limit is exceeded a
1:eac0369:      * SQLException is thrown.
1:eac0369:      *
1:eac0369:      * @return the current query timeout limit in seconds; zero means unlimited
1:eac0369: 	 * @exception SQLException thrown on failure.
1:eac0369:      */
1:3fcea8a: 	public final int getQueryTimeout() throws SQLException {
1:050b616:         checkStatus();
1:c601222:         return (int) (timeoutMillis / 1000);
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * The queryTimeout limit is the number of seconds the driver will
1:eac0369:      * wait for a Statement to execute. If the limit is exceeded a
1:eac0369:      * SQLException is thrown.
1:eac0369:      *
1:eac0369:      * @param seconds the new query timeout limit in seconds; zero means unlimited
1:eac0369: 	 * @exception SQLException thrown on failure.
1:eac0369:      */
1:3fcea8a: 	public final void setQueryTimeout(int seconds) throws SQLException {
1:3fcea8a: 		checkStatus();
1:3fcea8a:         if (seconds < 0) {
1:ce40a31:             throw newSQLException(SQLState.INVALID_QUERYTIMEOUT_VALUE, seconds);
1:3fcea8a:         }
1:c601222:         timeoutMillis = (long) seconds * 1000;
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Cancel can be used by one thread to cancel a statement that
1:eac0369:      * is being executed by another thread.
1:eac0369: 	 * @exception SQLException thrown on failure.
1:eac0369:      */
1:eac0369: 	public void cancel() throws SQLException {
1:eac0369: 		throw Util.notImplemented("cancel");
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * The first warning reported by calls on this Statement is
1:eac0369:      * returned.  A Statment's execute methods clear its SQLWarning
1:eac0369:      * chain. Subsequent Statement warnings will be chained to this
1:eac0369:      * SQLWarning.
1:eac0369:      *
1:eac0369:      * <p>The warning chain is automatically cleared each time
1:eac0369:      * a statement is (re)executed.
1:eac0369:      *
1:eac0369:      * <P><B>Note:</B> If you are processing a ResultSet then any
1:eac0369:      * warnings associated with ResultSet reads will be chained on the
1:eac0369:      * ResultSet object.
1:eac0369:      *
1:eac0369:      * @return the first SQLWarning or null
1:eac0369: 	 * @exception SQLException thrown on failure.
1:eac0369:      */
1:eac0369: 	public SQLWarning getWarnings() throws SQLException	{
1:eac0369: 		checkStatus();
1:eac0369: 		return warnings;
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * After this call getWarnings returns null until a new warning is
1:eac0369:      * reported for this Statement.
1:eac0369: 	 * @exception SQLException thrown on failure.
1:eac0369:      */
1:eac0369: 	public void clearWarnings() throws SQLException	{
1:eac0369: 		checkStatus();
1:eac0369: 		warnings = null;
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * setCursorName defines the SQL cursor name that will be used by
1:eac0369:      * subsequent Statement execute methods. This name can then be
1:eac0369:      * used in SQL positioned update/delete statements to identify the
1:eac0369:      * current row in the ResultSet generated by this statement.  If
1:eac0369:      * the database doesn't support positioned update/delete, this
1:eac0369:      * method is a noop.
1:eac0369:      *
1:eac0369:      * <P><B>Note:</B> By definition, positioned update/delete
1:eac0369:      * execution must be done by a different Statement than the one
1:eac0369:      * which generated the ResultSet being used for positioning. Also,
1:eac0369:      * cursor names must be unique within a Connection.
1:eac0369:      *
1:eac0369:      * @param name the new cursor name.
1:eac0369:      */
1:eac0369: 	public void setCursorName(String name) throws SQLException {
1:eac0369: 		checkStatus();
1:eac0369: 		cursorName = name;
1:eac0369: 	}
1:eac0369: 
1:eac0369:     //----------------------- Multiple Results --------------------------
1:eac0369: 
1:eac0369:     /**
1:3fcea8a:      * Execute a SQL statement that may return multiple results.
1:3fcea8a:      * Under some (uncommon) situations a single SQL statement may return
1:3fcea8a:      * multiple result sets and/or update counts.  Normally you can ignore
1:3fcea8a:      * this, unless you're executing a stored procedure that you know may
1:3fcea8a:      * return multiple results, or unless you're dynamically executing an
1:3fcea8a:      * unknown SQL string.  The "execute", "getMoreResults", "getResultSet"
1:3fcea8a:      * and "getUpdateCount" methods let you navigate through multiple results.
1:3fcea8a:      *
1:3fcea8a:      * The "execute" method executes a SQL statement and indicates the
1:3fcea8a:      * form of the first result.  You can then use getResultSet or
1:3fcea8a:      * getUpdateCount to retrieve the result, and getMoreResults to
1:3fcea8a:      * move to any subsequent result(s).
1:3fcea8a:      *
1:3fcea8a:      * @param sql					any SQL statement
1:eac0369: 	 *
1:eac0369:      * @return true if the first result is a ResultSet; false if it is an integer
1:eac0369:      * @see #getResultSet
1:eac0369:      * @see #getUpdateCount
1:eac0369:      * @see #getMoreResults
1:eac0369: 	 * @exception SQLException thrown on failure
1:eac0369:      */
1:eac0369: 	public boolean execute(String sql)
1:eac0369: 		throws SQLException
1:eac0369: 	{
1:a0118e1: 		return execute(sql, false, false, Statement.NO_GENERATED_KEYS, null, null);
1:eac0369: 	}
1:eac0369: 	
1:eac0369:     /**
1:eac0369:      * Execute a SQL statement that may return multiple results.
1:eac0369:      * Under some (uncommon) situations a single SQL statement may return
1:eac0369:      * multiple result sets and/or update counts.  Normally you can ignore
1:eac0369:      * this, unless you're executing a stored procedure that you know may
1:eac0369:      * return multiple results, or unless you're dynamically executing an
1:eac0369:      * unknown SQL string.  The "execute", "getMoreResults", "getResultSet"
1:eac0369:      * and "getUpdateCount" methods let you navigate through multiple results.
1:eac0369:      *
1:eac0369:      * The "execute" method executes a SQL statement and indicates the
1:eac0369:      * form of the first result.  You can then use getResultSet or
1:eac0369:      * getUpdateCount to retrieve the result, and getMoreResults to
1:eac0369:      * move to any subsequent result(s).
1:eac0369:      *
1:eac0369:      * @param sql					any SQL statement
1:3fcea8a: 	 * @param executeQuery			caller is executeQuery()
1:3fcea8a: 	 * @param executeUpdate			caller is executeUpdate()
1:3fcea8a:      * @param autoGeneratedKeys
1:3fcea8a:      * @param columnIndexes
1:3fcea8a:      * @param columnNames
1:3fcea8a: 	 *
1:3fcea8a:      * @return true if the first result is a ResultSet; false if it is an integer
1:3fcea8a:      * @see #getResultSet
1:3fcea8a:      * @see #getUpdateCount
1:3fcea8a:      * @see #getMoreResults
1:3fcea8a: 	 * @exception SQLException thrown on failure
1:3fcea8a:      */
1:23b4f8b: 	private boolean execute(String sql, boolean executeQuery, boolean executeUpdate,
1:eac0369: 		int autoGeneratedKeys, int[] columnIndexes, String[] columnNames) throws SQLException
1:eac0369: 	{
1:eac0369: 	  synchronized (getConnectionSynchronization()) {
1:eac0369: 
1:eac0369: 		checkExecStatus();
1:050b616: 		if (sql == null) {
1:050b616: 			throw newSQLException(SQLState.NULL_SQL_TEXT);
1:050b616: 		}
1:eac0369: 		checkIfInMiddleOfBatch();
1:eac0369: 		clearResultSets(); // release the last statement executed, if any.
1:eac0369: 
1:eac0369:         setupContextStack(); // make sure there's context
1:eac0369: 
1:eac0369: 
1:eac0369: 		// try to remember the SQL statement in case anybody asks for it
1:eac0369: 		SQLText = sql;		
1:eac0369: 
1:eac0369: 		try {
1:eac0369: 			Activation activation;
1:eac0369: 			try {
1:5087be8: 				PreparedStatement preparedStatement = lcc.prepareInternalStatement
1:1e8a20f: 				    (lcc.getDefaultSchema(), sql, resultSetConcurrency==
1:1e8a20f:                         java.sql.ResultSet.CONCUR_READ_ONLY, false);
1:eac0369: 				activation =
1:1e8a20f: 					preparedStatement.getActivation(lcc, resultSetType ==
1:1e8a20f:                         java.sql.ResultSet.TYPE_SCROLL_INSENSITIVE);
1:eac0369: 				checkRequiresCallableStatement(activation);
1:3a6f4cf:                 InterruptStatus.restoreIntrFlagIfSeen(lcc);
2:eac0369: 			 } catch (Throwable t) {
1:eac0369: 				throw handleException(t);
1:eac0369: 			 }
1:eac0369: 
1:eac0369: 
1:eac0369: 			// this is for a Statement execution
1:eac0369: 			activation.setSingleExecution();
1:eac0369: 
1:eac0369: 			//bug 4838 - save the auto-generated key information in activation. keeping this
1:eac0369: 			//information in lcc will not work work it can be tampered by a nested trasaction
1:a0118e1: 			if (autoGeneratedKeys == Statement.RETURN_GENERATED_KEYS)
1:706f2eb:             {
1:eac0369: 				activation.setAutoGeneratedKeysResultsetInfo(columnIndexes, columnNames);
1:706f2eb:             }
1:eac0369: 			return executeStatement(activation, executeQuery, executeUpdate);
1:eac0369: 		} finally {
1:eac0369: 		    restoreContextStack();
1:eac0369: 		}
1:eac0369: 	  }
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * JDBC 3.0
1:eac0369:      *
1:eac0369:      * Executes the given SQL statement, which may return multiple
1:eac0369:      * results, and signals the driver that any auto-generated keys
1:eac0369:      * should be made available for retrieval. The driver will ignore
1:aa302c3:      * this signal if the SQL statement is not an INSERT/UPDATE statement.
1:eac0369:      *
1:eac0369:      * @param sql any SQL statement
1:eac0369:      * @param autoGeneratedKeys - a constant indicating whether
1:eac0369:      * auto-generated keys should be made available for retrieval using
1:eac0369:      * the method getGeneratedKeys; one of the following constants:
1:eac0369:      * Statement.RETURN_GENERATED_KEYS or Statement.NO_GENERATED_KEYS
1:eac0369:      * @return rue if the first result is a ResultSet object; false if
1:eac0369:      * it is an update count or there are no results
1:eac0369:      * @exception SQLException if a database access error occurs
1:eac0369:      */
1:eac0369: 	public boolean execute(String sql, int autoGeneratedKeys) throws SQLException
1:eac0369: 	{
1:eac0369: 		return execute(sql, false, false, autoGeneratedKeys, null, null);
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * JDBC 3.0
1:eac0369:      *
1:eac0369:      * Executes the given SQL statement, which may return multiple
1:eac0369:      * results, and signals the driver that the auto-generated keys
1:eac0369:      * indicated in the given array should be made available for retrieval.
1:eac0369:      * This array contains the indexes of the columns in the target table
1:eac0369:      * that contain the auto-generated keys that should be made available.
1:eac0369:      * The driver will ignore the array if the given SQL statement is not an
1:aa302c3:      * INSERT/UPDATE statement.
1:eac0369:      *
1:eac0369:      * @param sql any SQL statement
1:eac0369:      * @param columnIndexes - an array of the indexes of the columns in the
1:aa302c3:      * inserted/updated row that should be made available for retrieval by a
1:aa302c3:      * call to the method getGeneratedKeys
1:eac0369:      * @return rue if the first result is a ResultSet object; false if
1:eac0369:      * it is an update count or there are no results
1:eac0369:      * @exception SQLException if a database access error occurs
1:eac0369:      */
1:eac0369: 	public boolean execute(String sql, int[] columnIndexes) throws SQLException
1:eac0369: 	{
1:e3bd4bb: 		return execute(sql, false, true,
1:e3bd4bb: 			((columnIndexes == null) || (columnIndexes.length == 0))
1:a0118e1: 				? Statement.NO_GENERATED_KEYS
1:a0118e1: 				: Statement.RETURN_GENERATED_KEYS,
1:e3bd4bb: 			columnIndexes,
1:e3bd4bb: 			null);
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * JDBC 3.0
1:eac0369:      *
1:eac0369:      * Executes the given SQL statement, which may return multiple
1:eac0369:      * results, and signals the driver that the auto-generated keys
1:eac0369:      * indicated in the given array should be made available for retrieval.
1:eac0369:      * This array contains the names of the columns in the target table
1:eac0369:      * that contain the auto-generated keys that should be made available.
1:eac0369:      * The driver will ignore the array if the given SQL statement is not an
1:aa302c3:      * INSERT/UPDATE statement.
1:eac0369:      *
1:eac0369:      * @param sql any SQL statement
1:eac0369:      * @param columnNames - an array of the names of the columns in the
1:aa302c3:      * inserted/updated row that should be made available for retrieval by a
1:aa302c3:      * call to the method getGeneratedKeys
1:eac0369:      * @return rue if the first result is a ResultSet object; false if
1:eac0369:      * it is an update count or there are no results
1:eac0369:      * @exception SQLException if a database access error occurs
1:eac0369:      */
1:eac0369: 	public boolean execute(String sql, String[] columnNames) throws SQLException
1:eac0369: 	{
1:e3bd4bb: 		return execute(sql, false, true,
1:e3bd4bb: 			((columnNames == null) || (columnNames.length == 0))
1:a0118e1: 				? Statement.NO_GENERATED_KEYS
1:a0118e1: 				: Statement.RETURN_GENERATED_KEYS,
1:e3bd4bb: 			null,
1:e3bd4bb: 			columnNames);
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      *  getResultSet returns the current result as a ResultSet.  It
1:eac0369:      *  should only be called once per result.
1:eac0369:      *
1:eac0369:      * @return the current result as a ResultSet; null if the result
1:eac0369:      * is an update count or there are no more results or the statement
1:eac0369: 	 * was closed.
1:eac0369:      * @see #execute
1:eac0369:      */
1:eac0369: 	public final java.sql.ResultSet getResultSet() throws SQLException  {
1:eac0369: 		checkStatus();
1:eac0369: 
1:eac0369: 		return results;
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      *  getUpdateCount returns the current result as an update count;
1:eac0369:      *  if the result is a ResultSet or there are no more results -1
1:eac0369:      *  is returned.  It should only be called once per result.
1:eac0369:      *
1:eac0369:      * <P>The only way to tell for sure that the result is an update
1:eac0369:      *  count is to first test to see if it is a ResultSet. If it is
1:eac0369:      *  not a ResultSet it is either an update count or there are no
1:eac0369:      *  more results.
1:eac0369:      *
1:eac0369:      * @return the current result as an update count; -1 if it is a
1:eac0369:      * ResultSet or there are no more results
1:eac0369:      * @see #execute
1:eac0369:      */
1:eac0369: 	public final int getUpdateCount()	throws SQLException  {
1:eac0369: 		checkStatus();
1:7fb9956: 		return (int) updateCount;
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:7fb9956:      * JDBC 4.2
1:eac0369:      *
1:f26c60c:      *  getLargeUpdateCount returns the current result as an update count;
1:f26c60c:      *  if the result is a ResultSet or there are no more results -1
1:f26c60c:      *  is returned.  It should only be called once per result. For use with
1:f26c60c:      * statements which may touch more than Integer.MAX_VALUE rows.
1:f26c60c:      */
1:f26c60c: 	public final long getLargeUpdateCount()	throws SQLException  {
1:f26c60c: 		checkStatus();
1:f26c60c: 		return updateCount;
1:f26c60c: 	}
1:f26c60c: 
1:f26c60c:     /**
1:eac0369:      * getMoreResults moves to a Statement's next result.  It returns true if
1:eac0369:      * this result is a ResultSet.  getMoreResults also implicitly
1:eac0369:      * closes any current ResultSet obtained with getResultSet.
1:eac0369:      *
1:dbed020:      * There are no more results when (!getMoreResults() &amp;&amp;
1:eac0369:      * (getUpdateCount() == -1)
1:eac0369:      *
1:eac0369:      * @return true if the next result is a ResultSet; false if it is
1:eac0369:      * an update count or there are no more results
1:eac0369:      * @see #execute
1:eac0369: 	 * @exception SQLException thrown on failure.
1:eac0369:      */
1:eac0369: 	public final boolean getMoreResults() throws SQLException	{
1:a0118e1: 		return getMoreResults(Statement.CLOSE_ALL_RESULTS);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/////////////////////////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	//	JDBC 2.0 methods that are implemented here because EmbedPreparedStatement
1:eac0369: 	//  and EmbedCallableStatement in Local20 need access to them, and those
1:eac0369: 	//	classes extend their peer classes in Local, instead of EmbedStatement
1:eac0369: 	//	in Local20
1:eac0369: 	//
1:eac0369: 	//  We do the same of JDBC 3.0 methods.
1:eac0369: 	/////////////////////////////////////////////////////////////////////////
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * JDBC 2.0
1:eac0369:      *
1:eac0369:      * Determine the result set type.
1:eac0369:      *
1:eac0369:      * @exception SQLException Feature not implemented for now.
1:eac0369:      */
1:eac0369:     public final int getResultSetType()
1:eac0369: 		throws SQLException 
1:eac0369: 	{
1:eac0369: 		checkStatus();
1:eac0369: 		return resultSetType;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * JDBC 2.0
1:eac0369:      *
1:eac0369:      * Give a hint as to the direction in which the rows in a result set
1:eac0369:      * will be processed. The hint applies only to result sets created
1:eac0369:      * using this Statement object.  The default value is 
1:eac0369:      * ResultSet.FETCH_FORWARD.
1:eac0369:      *
1:eac0369:      * @param direction the initial direction for processing rows
1:eac0369:      * @exception SQLException if a database-access error occurs or direction
1:eac0369:      * is not one of ResultSet.FETCH_FORWARD, ResultSet.FETCH_REVERSE, or
1:eac0369:      * ResultSet.FETCH_UNKNOWN
1:eac0369:      */
1:eac0369:     public void setFetchDirection(int direction) throws SQLException {
1:eac0369: 		
1:eac0369: 		checkStatus();
1:eac0369:                 /* fetch direction is meaningless to us. we just save
1:eac0369:                  * it off if it is valid  and return the current value if asked.
1:eac0369:                  */
1:1e8a20f:                 if (direction == java.sql.ResultSet.FETCH_FORWARD || 
1:1e8a20f:                     direction == java.sql.ResultSet.FETCH_REVERSE ||
1:1e8a20f:                     direction == java.sql.ResultSet.FETCH_UNKNOWN )
1:eac0369:                 {
1:eac0369:                     fetchDirection = direction;
1:eac0369:                 }else
1:ce40a31:                     throw newSQLException(SQLState.INVALID_FETCH_DIRECTION, direction);
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * JDBC 2.0
1:eac0369:      *
1:eac0369:      * Determine the fetch direction.
1:eac0369:      *
1:eac0369:      * @return the default fetch direction
1:eac0369:      * @exception SQLException if a database-access error occurs
1:eac0369:      */
1:eac0369:     public int getFetchDirection() throws SQLException {
1:eac0369: 		checkStatus();
1:eac0369: 		return fetchDirection;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * JDBC 2.0
1:eac0369:      *
1:eac0369:      * Give the JDBC driver a hint as to the number of rows that should
1:eac0369:      * be fetched from the database when more rows are needed.  The number 
1:eac0369:      * of rows specified only affects result sets created using this 
1:eac0369:      * statement. If the value specified is zero, then the hint is ignored.
1:eac0369:      * The default value is zero.
1:eac0369:      *
1:eac0369:      * @param rows the number of rows to fetch
1:eac0369:      * @exception SQLException if a database-access error occurs, or the
1:dbed020:      * condition 0 &lt;= rows &lt;= this.getMaxRows() is not satisfied.
1:eac0369:      */
1:eac0369:     public void setFetchSize(int rows) throws SQLException {
1:eac0369: 		checkStatus();
1:eac0369:         if (rows < 0  || (this.getMaxRows() != 0 && 
1:eac0369:                              rows > this.getMaxRows()))
1:eac0369:         {
1:ce40a31: 	        throw newSQLException(SQLState.INVALID_ST_FETCH_SIZE, rows);
1:eac0369:         }else if ( rows > 0 ) // ignore the call if the value is zero
1:eac0369:             fetchSize = rows;
1:eac0369: 	}
1:eac0369:   
1:eac0369:     /**
1:eac0369:      * JDBC 2.0
1:eac0369:      *
1:eac0369:      * Determine the default fetch size.
1:eac0369:      * @exception SQLException if a database-access error occurs
1:eac0369:      *
1:eac0369:      */
1:eac0369:     public int getFetchSize() throws SQLException {
1:eac0369: 		checkStatus();
1:eac0369: 		return fetchSize;
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * JDBC 2.0
1:eac0369:      *
1:eac0369:      * Determine the result set concurrency.
1:eac0369:      *
1:eac0369:      * @exception SQLException Feature not implemented for now.
1:eac0369:      */
1:eac0369:     public int getResultSetConcurrency() throws SQLException {
1:eac0369: 		checkStatus();
1:eac0369: 		return resultSetConcurrency;
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * JDBC 3.0
1:eac0369:      *
1:eac0369:      * Retrieves the result set holdability for ResultSet objects
1:eac0369:      * generated by this Statement object.
1:eac0369:      *
1:eac0369:      * @return either ResultSet.HOLD_CURSORS_OVER_COMMIT or
1:eac0369:      * ResultSet.CLOSE_CURSORS_AT_COMMIT
1:eac0369:      * @exception SQLException Feature not implemented for now.
1:eac0369:      */
1:72cc553:     public final int getResultSetHoldability() throws SQLException {
1:eac0369: 		checkStatus();
1:eac0369: 		return resultSetHoldability;
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * JDBC 2.0
1:eac0369:      *
1:eac0369:      * Adds a SQL command to the current batch of commmands for the statement.
1:eac0369:      * This method is optional.
1:eac0369:      *
1:eac0369:      * @param sql typically this is a static SQL INSERT or UPDATE statement
1:eac0369:      * @exception SQLException if a database-access error occurs, or the
1:eac0369:      * driver does not support batch statements
1:eac0369:      */
1:eac0369:     public void addBatch( String sql ) throws SQLException {
1:eac0369: 		checkStatus();
1:eac0369:   	  synchronized (getConnectionSynchronization()) {
1:eac0369: 		  if (batchStatements == null)
1:71c8e86: 			  batchStatements = new Vector<Object>();
1:a32eb9f:         batchStatements.add(sql);
1:eac0369:   		}
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * JDBC 2.0
1:eac0369:      *
1:eac0369:      * Make the set of commands in the current batch empty.
1:eac0369:      * This method is optional.
1:eac0369:      *
1:eac0369:      * @exception SQLException if a database-access error occurs, or the
1:eac0369:      * driver does not support batch statements
1:eac0369:      */
1:eac0369:     public final void clearBatch() throws SQLException {
1:eac0369: 		checkStatus();
1:eac0369:   	  synchronized (getConnectionSynchronization()) {
1:eac0369:         batchStatements = null;
1:eac0369:   		}
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * JDBC 2.0
1:eac0369:      * 
1:eac0369:      * Submit a batch of commands to the database for execution.
1:eac0369:      * This method is optional.
1:eac0369: 	 *
1:eac0369: 	 * Moving jdbc2.0 batch related code in this class because
1:eac0369: 	 * callableStatement in jdbc 20 needs this code too and it doesn't derive
1:eac0369: 	 * from prepared statement in jdbc 20 in our implementation. 
1:eac0369: 	 * BatchUpdateException is the only new class from jdbc 20 which is being
1:eac0369: 	 * referenced here and in order to avoid any jdk11x problems, using
1:eac0369: 	 * reflection code to make an instance of that class. 
1:eac0369:      *
1:eac0369:      * @return an array of update counts containing one element for each
1:eac0369:      * command in the batch.  The array is ordered according
1:eac0369:      * to the order in which commands were inserted into the batch
1:eac0369:      * @exception SQLException if a database-access error occurs, or the
1:eac0369:      * driver does not support batch statements
1:eac0369:      */
1:eac0369:     public int[] executeBatch() throws SQLException {
1:0b0a105:         return Util.squashLongs( executeLargeBatch() );
1:0b0a105:     }
1:0b0a105:     
1:0b0a105:     /**
1:0b0a105:      * JDBC 4.2
1:0b0a105:      * 
1:0b0a105:      * Submit a batch of commands to the database for execution.
1:0b0a105:      * This method is optional. For use with
1:0b0a105:      * statements which may touch more than Integer.MAX_VALUE rows.
1:0b0a105:      */
1:0b0a105:     public long[] executeLargeBatch() throws SQLException {
1:eac0369: 		checkExecStatus();
1:eac0369: 		synchronized (getConnectionSynchronization()) 
1:eac0369: 		{
1:0b0a105:             setupContextStack();
1:eac0369: 			int i = 0;
1:eac0369: 			// As per the jdbc 2.0 specs, close the statement object's current resultset
1:eac0369: 			// if one is open.
1:eac0369: 			// Are there results?
1:eac0369: 			// outside of the lower try/finally since results will
1:eac0369: 			// setup and restore themselves.
1:eac0369: 			clearResultSets();
1:eac0369: 
1:71c8e86: 			Vector<Object> stmts = batchStatements;
1:eac0369: 			batchStatements = null;
1:eac0369: 			int size;
1:eac0369: 			if (stmts == null)
1:eac0369: 				size = 0;
1:eac0369: 			else
1:eac0369: 				size = stmts.size();
1:eac0369: 
1:0b0a105: 			long[] returnUpdateCountForBatch = new long[size];
1:eac0369: 
1:eac0369: 			SQLException sqle;
1:eac0369: 			try {
1:eac0369: 				for (; i< size; i++) 
1:eac0369: 				{
1:3a6f4cf:                     // If we saw an interrupt, stop execution of batch now.
1:3a6f4cf:                     // throwIf will likely only throw after at least one stm
1:3a6f4cf:                     // has been executed, since first time around we probably
1:3a6f4cf:                     // didn't do anything to notice interrupts yet.
1:3a6f4cf:                     InterruptStatus.throwIf(lcc);
1:a32eb9f: 					if (executeBatchElement(stmts.get(i)))
1:eac0369: 						throw newSQLException(SQLState.RESULTSET_RETURN_NOT_ALLOWED);
1:0b0a105: 					returnUpdateCountForBatch[ i ] = getLargeUpdateCount();
1:eac0369: 				}
1:3a6f4cf: 
1:3a6f4cf:                 InterruptStatus.restoreIntrFlagIfSeen(lcc);
1:eac0369: 				return returnUpdateCountForBatch;
1:eac0369: 			}
1:eac0369: 			catch (StandardException se) {
1:eac0369: 
1:eac0369: 				sqle = handleException(se);
1:eac0369: 			}
1:eac0369: 			catch (SQLException sqle2) 
1:eac0369: 			{
1:eac0369: 				sqle = sqle2;
1:eac0369: 			}
1:eac0369: 			finally 
1:eac0369: 			{
1:eac0369: 				restoreContextStack();
1:eac0369: 			}
1:eac0369: 
1:0d57d84:             long[] successfulUpdateCount =
1:0d57d84:                     Arrays.copyOf(returnUpdateCountForBatch, i);
1:eac0369: 
1:0d57d84:             throw new BatchUpdateException(sqle.getMessage(),
1:0d57d84:                                            sqle.getSQLState(),
1:0d57d84:                                            sqle.getErrorCode(),
1:0d57d84:                                            successfulUpdateCount,
1:0d57d84:                                            sqle );
1:0d57d84:         }
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Execute a single element of the batch. Overridden by EmbedPreparedStatement
1:eac0369: 	*/
1:23b4f8b: 	boolean executeBatchElement(Object batchElement) throws SQLException, StandardException {
1:a0118e1: 		return execute((String)batchElement, false, true, Statement.NO_GENERATED_KEYS, null, null);
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * JDBC 2.0
1:eac0369:      *
1:eac0369:      * Return the Connection that produced the Statement.
1:eac0369:      *
1:eac0369:      * @exception SQLException Exception if it cannot find the connection
1:eac0369:      * associated to this statement.
1:eac0369:      */
1:eac0369:     public final java.sql.Connection getConnection()  throws SQLException {
1:eac0369: 		checkStatus();
1:eac0369: 
1:eac0369:     	java.sql.Connection appConn = getEmbedConnection().getApplicationConnection();
1:0c13195: 		if ((appConn != applicationConnection) || (appConn == null)) {
1:0c13195: 
1:eac0369: 			throw Util.noCurrentConnection();
1:0c13195:         }
1:eac0369: 		return appConn;
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * JDBC 3.0
1:eac0369:      *
1:eac0369:      * Moves to this Statement obect's next result, deals with any current ResultSet
1:eac0369:      * object(s) according to the instructions specified by the given flag, and
1:eac0369:      * returns true if the next result is a ResultSet object
1:eac0369:      *
1:eac0369:      * @param current - one of the following Statement constants indicating what
1:eac0369:      * should happen to current ResultSet objects obtained using the method
1:eac0369:      * getResultSetCLOSE_CURRENT_RESULT, KEEP_CURRENT_RESULT, or CLOSE_ALL_RESULTS
1:eac0369:      * @return true if the next result is a ResultSet; false if it is
1:eac0369:      * an update count or there are no more results
1:eac0369:      * @see #execute
1:eac0369:      * @exception SQLException thrown on failure.
1:eac0369:      */
1:eac0369: 	public final boolean getMoreResults(int current) throws SQLException	{
1:eac0369: 		checkExecStatus();
1:eac0369: 
1:eac0369: 		synchronized (getConnectionSynchronization()) {
1:eac0369: 			if (dynamicResults == null) {
1:eac0369: 				// we only have the one resultset, so this is
1:eac0369: 				// simply a close for us.
1:eac0369: 				clearResultSets();
1:de8ba18:                 closeMeOnCompletion();
2:eac0369: 				return false;
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			int startingClose;
1:eac0369: 			switch (current) {
1:eac0369: 			default:
1:a0118e1: 			case Statement.CLOSE_ALL_RESULTS:
1:eac0369: 				startingClose = 0;
1:eac0369: 				break;
1:a0118e1: 			case Statement.CLOSE_CURRENT_RESULT:
1:eac0369: 				// just close the current result set.
1:eac0369: 				startingClose = currentDynamicResultSet;
1:eac0369: 				break;
1:a0118e1: 			case Statement.KEEP_CURRENT_RESULT:
1:eac0369: 				// make the close loop a no-op.
1:eac0369: 				startingClose = dynamicResults.length;
1:eac0369: 				break;
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			// Close loop.
1:eac0369: 			SQLException se = null;
1:eac0369: 			for (int i = startingClose; i <= currentDynamicResultSet && i < dynamicResults.length; i++) {
1:eac0369: 				EmbedResultSet lrs = dynamicResults[i];
1:eac0369: 				if (lrs == null)
5:eac0369: 					continue;
1:eac0369: 
1:eac0369: 
1:eac0369: 				try {
1:0c13195: 					lrs.close();
1:eac0369: 				} catch (SQLException sqle) {
1:eac0369: 					if (se == null)
1:eac0369: 						se = sqle;
1:eac0369: 					else
1:eac0369: 						se.setNextException(sqle);
1:eac0369: 				} finally {
1:eac0369: 					dynamicResults[i] = null;
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			if (se != null) {
1:eac0369: 				// leave positioned on the current result set (?)
1:eac0369: 				throw se;
1:eac0369: 			}
1:eac0369: 
1:7fb9956: 			updateCount = -1L;
1:eac0369: 
1:eac0369: 			while (++currentDynamicResultSet < dynamicResults.length) {
1:eac0369: 
1:eac0369: 				EmbedResultSet lrs = dynamicResults[currentDynamicResultSet];
1:eac0369: 				if (lrs != null) {
1:eac0369: 					if (lrs.isClosed) {
1:eac0369: 						dynamicResults[currentDynamicResultSet] = null;
1:eac0369: 						continue;
1:eac0369: 					}
1:eac0369: 
1:eac0369: 					results = lrs;
1:eac0369: 
1:562671e: 					return true;
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 
2:eac0369: 			results = null;
1:eac0369: 			return false;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * JDBC 3.0
1:eac0369:      *
1:eac0369:      * Retrieves any auto-generated keys created as a result of executing this
1:eac0369:      * Statement object. If this Statement is a non-insert statement,
1:eac0369:      * a null ResultSet object is returned.
1:eac0369:      *
1:eac0369:      * @return a ResultSet object containing the auto-generated key(s) generated by
1:eac0369:      * the execution of this Statement object
1:eac0369:      * @exception SQLException if a database access error occurs
1:eac0369:      */
1:eac0369: 	public final java.sql.ResultSet getGeneratedKeys() throws SQLException	{
1:050b616: 		checkStatus();
1:eac0369: 		if (autoGeneratedKeysResultSet == null)
1:5b2b352: 			return null;
1:eac0369: 		else {
1:a0118e1: 			execute("VALUES IDENTITY_VAL_LOCAL()", true, false, Statement.NO_GENERATED_KEYS, null, null);
1:eac0369: 			return results;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/////////////////////////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	//	Implementation specific methods	
1:eac0369: 	//
1:eac0369: 	/////////////////////////////////////////////////////////////////////////
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Execute the current statement.
1:eac0369: 	    @exception SQLException thrown on failure.
1:eac0369: 	*/
1:23b4f8b: 	boolean executeStatement(Activation a,
1:eac0369:                      boolean executeQuery, boolean executeUpdate)
1:eac0369:                      throws SQLException {
1:eac0369: 
1:eac0369: 		// we don't differentiate the update from the resultset case.
1:eac0369: 		// so, there could be a result set.
1:eac0369: 
1:eac0369: 		// note: the statement interface will paste together
1:eac0369: 		// an activation and make sure the prepared statement
1:eac0369: 		// is still valid, so it is preferrable, for now,
1:eac0369: 		// to creating our own activation and stuffing it in
1:eac0369: 		// the prepared statement.
1:d281462: 
1:eac0369: 		synchronized (getConnectionSynchronization()) {
1:eac0369:             
1:d281462:             if (SanityManager.DEBUG)
1:d281462:             {
1:d281462:                 // Ensure that clearResultSets has been called
1:d281462:                 // to fulfill [JDBC4: section 15.2.5 ]
1:d281462:                 // A ResultSet object is implicitly closed when:
1:d281462:                 // The associated Statement object is re-executed
1:d281462:                 
1:d281462:                 SanityManager.ASSERT(results == null);
1:d281462:                 SanityManager.ASSERT(dynamicResults == null);
1:d281462:                 SanityManager.ASSERT(autoGeneratedKeysResultSet == null);
1:d281462:            }
1:d281462:             
1:eac0369:                         setupContextStack(); // make sure there's context
1:eac0369: 			boolean retval;
1:eac0369: 
1:eac0369: 			pvs = a.getParameterValueSet();
1:eac0369: 
1:eac0369: 			try {
1:eac0369: 
1:eac0369: 				clearWarnings();
1:eac0369: 
1:eac0369: 				if (! forMetaData) {
1:eac0369: 					commitIfNeeded(); // commit the last statement if needed
1:eac0369: 					needCommit();
1:eac0369: 				} else {
1:eac0369: 
1:eac0369: 
1:eac0369: 		        	if (lcc.getActivationCount() > 1) {
1:eac0369: 		     		  // we do not want to commit here as there seems to be other
1:eac0369: 					  // statements/resultSets currently opened for this connection.
1:eac0369: 					} else {
1:eac0369: 						commitIfNeeded(); // we can legitimately commit
1:eac0369: 						needCommit();
1:eac0369: 					}
1:eac0369: 				}
1:eac0369: 
1:245209a: 				// Get the statement. We don't care if it's invalid, because it
1:245209a: 				// will be recompiled when we execute it if needed (DERBY-3024).
1:eac0369: 				PreparedStatement ps = a.getPreparedStatement();
1:eac0369: 
1:eac0369: 				/*
1:eac0369: 				** WARNING WARNING
1:eac0369: 				**
1:eac0369: 				** Any state set in the activation before execution *must* be copied
1:eac0369: 				** to the new activation in GenericActivationHolder.execute() when
1:eac0369: 				** the statement has been recompiled. State such as
1:eac0369: 				** singleExecution, cursorName, holdability, maxRows.
1:eac0369: 				*/
1:eac0369: 
1:eac0369: 				if (cursorName != null)
1:eac0369: 				{
1:eac0369: 					a.setCursorName(cursorName);
1:eac0369: 				}
1:562671e:                 
1:562671e:                 boolean executeHoldable = getExecuteHoldable();
1:562671e:  
1:562671e: 				a.setResultSetHoldability(executeHoldable);
1:72cc553: 
1:eac0369: 				//reset the activation to clear warnings
1:eac0369: 				//and clear existing result sets in case this has been cached
1:eac0369: 				a.reset();
1:eac0369: 				a.setMaxRows(maxRows);
1:7b6ad6d:                 ResultSet resultsToWrap =
1:7b6ad6d:                         ps.execute(a, forMetaData, timeoutMillis);
1:245209a:                 addWarning(ps.getCompileTimeWarnings());
1:72cc553: 				addWarning(a.getWarnings());
1:eac0369: 
1:eac0369: 
1:eac0369: 				if (resultsToWrap.returnsRows()) {
1:fade7e9: 
1:fade7e9:                     // The statement returns rows, so calling it with
1:fade7e9:                     // executeUpdate() is not allowed.
1:fade7e9:                     if (executeUpdate) {
1:fade7e9:                         throw StandardException.newException(
1:fade7e9:                                 SQLState.LANG_INVALID_CALL_TO_EXECUTE_UPDATE);
1:fade7e9:                     }
1:fade7e9: 
1:eac0369: 					EmbedResultSet lresults = factory.newEmbedResultSet(getEmbedConnection(), resultsToWrap, forMetaData, this, ps.isAtomic());
1:eac0369: 					results = lresults;
1:eac0369: 
1:eac0369: 
1:eac0369: 					// Set up the finalization of the ResultSet to
1:eac0369: 					// mark the activation as unused. It will be
1:eac0369: 					// closed sometime later by the connection
1:eac0369: 					// outside of finalization.
1:eac0369: 					if (a.isSingleExecution())
1:2f015be: 						lresults.singleUseActivation = a;
1:eac0369: 
1:7fb9956: 					updateCount = -1L;
1:eac0369: 					retval = true;
1:eac0369: 				}
1:eac0369: 				else {
1:eac0369: 
1:aa302c3: 					// Only applicable for an insert/update statement, which does not return rows.
1:aa302c3: 					//the auto-generated keys resultset will be null if used for other statement
1:eac0369: 					if (a.getAutoGeneratedKeysResultsetMode() && (resultsToWrap.getAutoGeneratedKeysResultset() != null))
1:eac0369: 					{
1:eac0369: 						resultsToWrap.getAutoGeneratedKeysResultset().open();
1:eac0369: 						autoGeneratedKeysResultSet = factory.newEmbedResultSet(getEmbedConnection(),
1:eac0369: 							resultsToWrap.getAutoGeneratedKeysResultset(), false, this, ps.isAtomic());
1:eac0369: 					}
1:eac0369: 
1:eac0369: 					updateCount = resultsToWrap.modifiedRowCount();
1:eac0369: 					results = null; // note that we have none.
1:eac0369: 
1:fade7e9:                     int dynamicResultCount = 0;
1:eac0369: 					if (a.getDynamicResults() != null) {
1:fade7e9:                         dynamicResultCount =
1:fade7e9:                             processDynamicResults(a.getDynamicResults(),
1:fade7e9:                                                   a.getMaxDynamicResults());
1:eac0369: 					}
1:fade7e9:                     
1:0f4ab91:                     resultsToWrap.close(); // Don't need the result set any more
1:5b2b352: 
1:fade7e9:                     // executeQuery() is not allowed if the statement
1:fade7e9:                     // doesn't return exactly one ResultSet.
1:fade7e9:                     if (executeQuery && dynamicResultCount != 1) {
1:fade7e9:                         throw StandardException.newException(
1:fade7e9:                                 SQLState.LANG_INVALID_CALL_TO_EXECUTE_QUERY);
1:fade7e9:                     }
1:fade7e9: 
1:fade7e9:                     // executeUpdate() is not allowed if the statement
1:fade7e9:                     // returns ResultSets.
1:fade7e9:                     if (executeUpdate && dynamicResultCount > 0) {
1:fade7e9:                         throw StandardException.newException(
1:fade7e9:                                 SQLState.LANG_INVALID_CALL_TO_EXECUTE_UPDATE);
1:fade7e9:                     }
1:eac0369: 					
1:fade7e9:                     if (dynamicResultCount == 0) {
1:eac0369: 						if (a.isSingleExecution()) {
1:eac0369: 							a.close();
1:eac0369: 						}
1:eac0369: 
1:eac0369: 						if (!forMetaData)
1:eac0369: 							commitIfNeeded();
1:eac0369: 						else {
1:eac0369: 
1:eac0369: 							if (lcc.getActivationCount() > 1) {
1:eac0369: 							  // we do not want to commit here as there seems to be other
1:eac0369: 							  // statements/resultSets currently opened for this connection.
1:eac0369: 							} else {
1:eac0369: 								commitIfNeeded(); // we can legitimately commit
1:eac0369: 							}
1:eac0369: 						}
1:eac0369: 					}
1:eac0369: 
1:fade7e9:                     retval = (dynamicResultCount > 0);
1:eac0369: 				}
1:3a6f4cf: 
1:3a6f4cf:                 InterruptStatus.restoreIntrFlagIfSeen(lcc);
1:3a6f4cf: 
1:3a6f4cf:             } catch (Throwable t) {
1:eac0369: 				if (a.isSingleExecution()) {
1:eac0369: 					try { a.close(); } catch (Throwable tt) {;}
1:eac0369: 				}
1:eac0369: 		        throw handleException(t);
1:eac0369: 			} finally {
1:eac0369: 			    restoreContextStack();
1:eac0369: 			}
1:eac0369: 			return retval;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:72cc553:      * Add a SQLWarning to this Statement object.
1:72cc553:      * If the Statement already has a SQLWarning then it
1:72cc553:      * is added to the end of the chain.
1:72cc553:      * 
1:72cc553:      * @see #getWarnings()
1:72cc553:      */
1:72cc553: 	final void addWarning(SQLWarning sw)
1:eac0369: 	{
1:eac0369: 		if (sw != null) {
1:eac0369: 			if (warnings == null)
1:eac0369: 				warnings = sw;
1:eac0369: 			else
1:eac0369: 				warnings.setNextException(sw);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/* package */
1:eac0369: 	public String getSQLText()
1:eac0369: 	{
1:eac0369: 		// no need to synchronize - accessing a reference is atomic
1:eac0369: 		// synchronized (getConnectionSynchronization()) 
1:eac0369: 		return SQLText;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public ParameterValueSet getParameterValueSet()
1:eac0369: 	{
1:eac0369: 		return pvs;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:a1a7f8b:      * Throw an exception if this Statement has been closed explictly
1:a1a7f8b:      * or it has noticed it has been closed implicitly.
1:a1a7f8b:      * JDBC specifications require nearly all methods throw a SQLException
1:a1a7f8b:      * if the Statement has been closed, thus most methods call this
1:a1a7f8b:      * method or checkExecStatus first.
1:a1a7f8b:      * 
1:a1a7f8b:      * @exception SQLException Thrown if the statement is marked as closed.
1:a1a7f8b:      * 
1:a1a7f8b:      * @see #checkExecStatus()
1:a1a7f8b: 	 */
1:0c13195:     final void checkStatus() throws SQLException {
1:0568a6c: 		if (!active) {
1:0568a6c:             // 
1:0568a6c:             // Check the status of the connection first
1:0568a6c:             //
1:0568a6c:             java.sql.Connection appConn = getEmbedConnection().getApplicationConnection();
1:0568a6c:             if (appConn == null || appConn.isClosed()) {
1:0568a6c:                 throw Util.noCurrentConnection();
1:eac0369:             }
1:eac0369: 
1:eac0369:             throw newSQLException(SQLState.ALREADY_CLOSED, "Statement");
1:eac0369:         }
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		A heavier weight version of checkStatus() that ensures the application's Connection
1:eac0369: 		object is still open. This is to stop errors or unexpected behaviour when a [Prepared]Statement
1:eac0369: 		object is used after the application has been closed. In particular to ensure that
1:eac0369: 		a Statement obtained from a PooledConnection cannot be used after the application has closed
1:eac0369: 		its connection (as the underlying Connection is still active).
1:eac0369: 		To avoid this heavier weight check on every method of [Prepared]Statement it is only used
1:eac0369: 		on those methods that would end up using the database's connection to read or modify data.
1:eac0369: 		E.g. execute*(), but not setXXX, etc.
1:a1a7f8b:         <BR>
1:d192b7d:         If this Statement's Connection is closed an exception will
1:a1a7f8b:         be thrown and the active field will be set to false,
1:a1a7f8b:         completely marking the Statement as closed.
1:a1a7f8b:         <BR>
1:a1a7f8b:         If the Statement is not currently connected to an active
1:a1a7f8b:         transaction, i.e. a suspended global transaction, then
1:a1a7f8b:         this method will throw a SQLException but the Statement
1:a1a7f8b:         will remain open. The Statement is open but unable to
1:a1a7f8b:         process any new requests until its global transaction
1:a1a7f8b:         is resumed.
1:a1a7f8b:         <BR>
1:a1a7f8b:         Upon return from the method, with or without a SQLException
1:a1a7f8b:         the field active will correctly represent the open state of
1:a1a7f8b:         the Statement.
1:a1a7f8b:         
1:a1a7f8b:         @exception SQLException Thrown if the statement is marked as closed
1:a1a7f8b:         or the Statement's transaction is suspended.
1:a1a7f8b:         
1:a1a7f8b:         @see #checkStatus()
1:eac0369: 	*/
1:a1a7f8b: 	final void checkExecStatus() throws SQLException {
1:eac0369: 		// getConnection() checks if the Statement is closed
1:eac0369: 		if (!getConnection().isClosed())
1:eac0369: 			return;
1:dd1bd91:         
1:dd1bd91:         // Now this connection is closed for all
1:dd1bd91:         // future use.
1:dd1bd91:         active = false;
1:dd1bd91:         	
1:eac0369: 		throw Util.noCurrentConnection();
1:eac0369: 	}
1:0c13195: 
1:eac0369: 	/**
1:eac0369: 		Close and clear all result sets associated with this statement
1:eac0369: 		from the last execution.
1:eac0369: 	*/
1:de8ba18: 	void clearResultSets() throws SQLException
1:de8ba18:     {
1:de8ba18:         //
1:de8ba18:         // Try not to let closeDependentResultSet() close this Statement
1:de8ba18:         // when we are just cleaning up before the next operation.
1:de8ba18:         //
1:de8ba18:         try {
1:de8ba18:             closingResultSets = true;
1:de8ba18:             clearResultSetsMinion();
1:de8ba18:         }
1:de8ba18:         finally { closingResultSets = false; }
1:eac0369: 
1:de8ba18:     }
1:de8ba18:     // don't call this directly. call clearResultSets() instead.
1:de8ba18:     private void    clearResultSetsMinion() throws SQLException
1:de8ba18:     {
1:eac0369: 		SQLException sqle = null;
1:eac0369: 
1:eac0369: 		try {
1:eac0369: 			// Are there results?
1:eac0369: 			// outside of the lower try/finally since results will
1:eac0369: 			// setup and restore themselves.
2:eac0369: 			if (results != null) {
2:eac0369: 				results.close();
1:eac0369: 				results = null;
1:eac0369: 			}
1:eac0369: 		} catch (SQLException s1) {
1:eac0369: 			sqle = s1;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		try {
1:eac0369: 			if (autoGeneratedKeysResultSet != null) {
1:eac0369: 				autoGeneratedKeysResultSet.close();
1:eac0369: 				autoGeneratedKeysResultSet = null;
1:eac0369: 			}
1:eac0369: 		} catch (SQLException sauto) {
1:eac0369: 			if (sqle == null)
1:eac0369: 				sqle = sauto;
1:eac0369: 			else
1:eac0369: 				sqle.setNextException(sauto);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// close all the dynamic result sets.
1:eac0369: 		if (dynamicResults != null) {
1:eac0369: 			for (int i = 0; i < dynamicResults.length; i++) {
1:eac0369: 				EmbedResultSet lrs = dynamicResults[i];
1:eac0369: 				if (lrs == null)
1:eac0369: 					continue;
1:eac0369: 
1:eac0369: 				try {
1:0c13195: 					lrs.close();
1:eac0369: 				} catch (SQLException sdynamic) {
1:eac0369: 					if (sqle == null)
1:eac0369: 						sqle = sdynamic;
1:eac0369: 					else
1:eac0369: 						sqle.setNextException(sdynamic);
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 			dynamicResults = null;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 			  We don't reset statement to null because PreparedStatement
1:eac0369: 			  relies on it being there for subsequent (post-close) execution
1:eac0369: 			  requests.  There is no close method on database statement objects.
1:eac0369: 		*/
1:eac0369: 
1:7fb9956: 		updateCount = -1L; // reset field
1:eac0369: 
1:eac0369: 		if (sqle != null)
1:eac0369: 			throw sqle;
1:eac0369: 	 }  
1:eac0369: 	
1:eac0369: 	/**
1:eac0369: 		Check to see if a statement requires to be executed via a callable statement.
1:eac0369: 	*/
1:23b4f8b: 	void checkRequiresCallableStatement(Activation activation) throws SQLException {
1:eac0369: 
1:eac0369: 		ParameterValueSet pvs = activation.getParameterValueSet();
1:eac0369: 
1:eac0369: 		if (pvs == null)
1:eac0369: 			return;
1:eac0369: 
1:eac0369: 		if (pvs.checkNoDeclaredOutputParameters()) {
1:eac0369: 			try {
1:eac0369: 				activation.close();
1:eac0369: 			} catch (StandardException se) {
1:eac0369: 			}
1:eac0369: 			throw newSQLException(SQLState.REQUIRES_CALLABLE_STATEMENT, SQLText);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Transfer my batch of Statements to a newly created Statement.
1:eac0369: 	*/
1:eac0369: 	public void transferBatch(EmbedStatement other) throws SQLException {
1:eac0369: 		
1:eac0369: 		synchronized (getConnectionSynchronization()) {
1:eac0369: 			other.batchStatements = batchStatements;
1:eac0369: 			batchStatements = null;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369:     
1:eac0369:     /**
1:175a740:      * Set the application statement for this Statement.
1:175a740:     */
1:175a740:     public final void setApplicationStatement(EngineStatement s) {
1:175a740:         this.applicationStatement = s;
1:175a740:     }
1:eac0369: 
1:eac0369: 	private EmbedResultSet[] dynamicResults;
1:eac0369: 	private int currentDynamicResultSet;
1:fade7e9: 
1:fade7e9:     /**
1:fade7e9:      * Go through a holder of dynamic result sets, remove those that
1:fade7e9:      * should not be returned, and sort the result sets according to
1:fade7e9:      * their creation.
1:fade7e9:      *
1:fade7e9:      * @param holder a holder of dynamic result sets
1:fade7e9:      * @param maxDynamicResultSets the maximum number of result sets
1:fade7e9:      * to be returned
1:fade7e9:      * @return the actual number of result sets
1:fade7e9:      * @exception SQLException if an error occurs
1:fade7e9:      */
1:fade7e9:     private int processDynamicResults(java.sql.ResultSet[][] holder,
1:fade7e9:                                       int maxDynamicResultSets)
1:fade7e9:         throws SQLException
1:fade7e9:     {
1:eac0369: 
1:eac0369: 		EmbedResultSet[] sorted = new EmbedResultSet[holder.length];
1:eac0369: 
1:eac0369: 		int actualCount = 0;
1:eac0369: 		for (int i = 0; i < holder.length; i++) {
1:eac0369: 
1:eac0369: 			java.sql.ResultSet[] param = holder[i];
1:eac0369: 
1:eac0369: 			java.sql.ResultSet rs = param[0];
1:5b2b352: 
1:5b2b352:             // Clear the JDBC dynamic ResultSet from the language
1:5b2b352:             // ResultSet for the CALL statement. This stops the
1:5b2b352:             // CALL statement closing the ResultSet when its language
1:5b2b352:             // ResultSet is closed, which will happen just after the
1:5b2b352:             // call to the processDynamicResults() method.
1:eac0369: 			param[0] = null;
1:5b2b352:             
1:5b2b352:             // ignore non-Derby result sets or results sets from another connection
1:5b2b352:             // and closed result sets.
1:5b2b352:             EmbedResultSet lrs = EmbedStatement.processDynamicResult(
1:5b2b352:                     getEmbedConnection(), rs, this);
1:5b2b352:             
1:5b2b352:             if (lrs == null)
1:5b2b352:             {
1:5b2b352:                 continue;
1:5b2b352:             }
1:eac0369: 
1:eac0369: 			sorted[actualCount++] = lrs;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (actualCount != 0) {
1:eac0369: 
1:eac0369: 			// results are defined to be ordered according to their creation
1:eac0369: 			if (actualCount != 1) {
1:eac0369: 				java.util.Arrays.sort(sorted, 0, actualCount);
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			dynamicResults = sorted;
1:eac0369: 
1:eac0369: 			if (actualCount > maxDynamicResultSets) {
1:72cc553: 				addWarning(StandardException.newWarning(SQLState.LANG_TOO_MANY_DYNAMIC_RESULTS_RETURNED));
1:eac0369: 
1:eac0369: 				for (int i = maxDynamicResultSets; i < actualCount; i++) {
1:eac0369: 					sorted[i].close();
1:eac0369: 					sorted[i] = null;
1:eac0369: 				}
1:eac0369: 
1:eac0369: 				actualCount = maxDynamicResultSets;
1:eac0369: 			}
1:eac0369: 
1:eac0369: 
1:7fb9956: 			updateCount = -1L;
1:eac0369: 			results = sorted[0];
1:eac0369: 			currentDynamicResultSet = 0;
1:eac0369: 
1:eac0369: 			// 0100C is not returned for procedures written in Java, from the SQL2003 spec.
1:eac0369: 			// getWarnings(StandardException.newWarning(SQLState.LANG_DYNAMIC_RESULTS_RETURNED));
1:eac0369: 		}
1:eac0369: 
1:eac0369: 
1:fade7e9: 		return actualCount;
1:eac0369: 	}
1:5b2b352:     
1:5b2b352:     /**
1:5b2b352:      * Process a ResultSet created in a Java procedure as a dynamic result.
1:5b2b352:      * To be a valid dynamic result the ResultSet must be:
1:5b2b352:      * <UL>
1:5b2b352:      * <LI> From a Derby system
1:5b2b352:      * <LI> From a nested connection of connection passed in
1:5b2b352:      * or from the connection itself.
1:5b2b352:      * <LI> Open
1:5b2b352:      * </UL>
1:5b2b352:      * Any invalid ResultSet is ignored.
1:5b2b352:      * 
1:5b2b352:      * 
1:5b2b352:      * @param conn Connection ResultSet needs to belong to
1:5b2b352:      * @param resultSet ResultSet to be tested
1:5b2b352:      * @param callStatement Statement that executed the CALL, null if 
1:5b2b352:      * @return The result set cast down to EmbedResultSet, null if not a valid
1:5b2b352:      * dynamic result.
1:5b2b352:      */
1:5b2b352:     static EmbedResultSet processDynamicResult(EmbedConnection conn,
1:5b2b352:             java.sql.ResultSet resultSet,
1:5b2b352:             EmbedStatement callStatement)
1:5b2b352:     {
1:5b2b352:         if (resultSet == null)
1:5b2b352:             return null;
1:5b2b352: 
1:5b2b352:         // ignore non-Derby result sets or results sets from another connection
1:5b2b352:         if (!(resultSet instanceof EmbedResultSet))
1:5b2b352:             return null;
1:5b2b352: 
1:5b2b352:         EmbedResultSet lrs = (EmbedResultSet) resultSet;
1:5b2b352: 
1:5b2b352:         if (lrs.getEmbedConnection().rootConnection != conn.rootConnection)
1:5b2b352:             return null;
1:5b2b352: 
1:5b2b352:         // ignore closed result sets.
1:782354a:         try {
1:782354a:         	//following will check if the JDBC ResultSet or the language
1:782354a:         	//ResultSet is closed. If yes, then it will throw an exception.
1:782354a:         	//So, the exception indicates that the ResultSet is closed and
1:782354a:         	//hence we should ignore it. 
1:782354a:         	lrs.checkIfClosed("");
1:782354a:         } catch (SQLException ex) {
1:782354a:             return null;        	
1:782354a:         }
1:5b2b352:         
1:5b2b352:         lrs.setDynamicResultSet(callStatement);
1:5b2b352: 
1:5b2b352:         return lrs;
1:5b2b352:     }
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Callback on the statement when one of its result sets is closed.
1:eac0369: 		This allows the statement to control when it completes and hence
1:eac0369: 		when it commits in auto commit mode.
1:eac0369: 
1:eac0369:         Must have connection synchronization and setupContextStack(), this
1:eac0369:         is required for the call to commitIfNeeded().
1:eac0369: 	*/
1:eac0369: 	void resultSetClosing(EmbedResultSet closingLRS) throws SQLException {
1:eac0369: 
1:eac0369: 		// If the Connection is not in auto commit then this statement completion
1:eac0369: 		// cannot cause a commit.
1:eac0369: 		if (!getEmbedConnection().autoCommit)
1:eac0369: 			return;
1:eac0369: 
1:eac0369: 		// If we have dynamic results, see if there is another result set open.
1:eac0369: 		// If so, then no commit. The last result set to close will close the statement.
1:eac0369: 		if (dynamicResults != null) {
1:eac0369: 			for (int i = 0; i < dynamicResults.length; i++) {
1:eac0369: 				EmbedResultSet lrs = dynamicResults[i];
1:eac0369: 				if (lrs == null)
1:eac0369: 					continue;
1:5b2b352: 				if (lrs.isClosed)
1:eac0369: 					continue;
1:eac0369: 				if (lrs == closingLRS)
1:eac0369: 					continue;
1:eac0369: 
1:eac0369: 				// at least one still open so no commit now.
1:eac0369: 				return;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// new Throwable("COMMIT ON " + SQLText).printStackTrace(System.out);
1:eac0369: 
1:eac0369:         // beetle 5383.  Force a commit in autocommit always.  Before this
1:eac0369:         // change if client in autocommit opened a result set, did a commit,
1:eac0369:         // then next then close a commit would not be forced on the close.
1:eac0369: 		commitIfAutoCommit();
1:eac0369: 	}
1:562671e:     
1:562671e:     /**
1:562671e:      * Get the execute time holdability for the Statement.
1:562671e:      * When in a global transaction holdabilty defaults to false.
1:175a740:      * @throws SQLException Error from getResultSetHoldability.
1:562671e:      */
1:175a740:     private boolean getExecuteHoldable() throws SQLException
1:562671e:     {
1:1e8a20f:         if (resultSetHoldability  == java.sql.ResultSet.CLOSE_CURSORS_AT_COMMIT)
1:562671e:             return false;
1:562671e:         
1:175a740:         // Simple non-XA case
1:175a740:         if (applicationStatement == this)
1:175a740:             return true;
1:175a740:         
1:175a740:         return applicationStatement.getResultSetHoldability() ==
1:1e8a20f:             java.sql.ResultSet.HOLD_CURSORS_OVER_COMMIT;
1:562671e:     }
1:7eed914: 
1:7eed914: 	/**
1:7eed914: 	 * Returns the value of the EmbedStatement's poolable hint,
1:7eed914: 	 * indicating whether pooling is requested.
1:7eed914: 	 *
1:7eed914: 	 * @return The value of the poolable hint.
1:7eed914: 	 * @throws SQLException if the Statement has been closed.
1:7eed914: 	 */
1:7eed914: 
1:7eed914: 	public boolean isPoolable() throws SQLException {
1:7eed914: 		// Assert the statement is still active (not closed)
1:7eed914: 		checkStatus();
1:7eed914: 
1:7eed914: 		return isPoolable;
1:7eed914: 	}                
1:7eed914: 
1:7eed914: 	/**
1:7eed914: 	 * Requests that an EmbedStatement be pooled or not.
1:7eed914: 	 *
1:7eed914: 	 * @param poolable requests that the EmbedStatement be pooled if true
1:7eed914: 	 * and not be pooled if false.
1:7eed914: 	 * @throws SQLException if the EmbedStatement has been closed.
1:7eed914: 	 */
1:7eed914:      
1:7eed914: 	public void setPoolable(boolean poolable) throws SQLException {
1:7eed914: 		// Assert the statement is still active (not closed)
1:7eed914: 		checkStatus();
1:7eed914: 
1:7eed914: 		isPoolable = poolable;
1:7eed914: 	}
1:de8ba18: 
1:b5f2776:     /**
1:b5f2776:      * Returns false unless {@code interfaces} is implemented.
1:b5f2776:      *
1:b5f2776:      * @param interfaces a Class defining an interface.
1:b5f2776:      * @return true if this implements the interface or directly or indirectly
1:b5f2776:      * wraps an object that does.
1:b5f2776:      * @throws SQLException if an error occurs while determining
1:b5f2776:      * whether this is a wrapper for an object with the given interface.
1:b5f2776:      */
1:b5f2776:     public final boolean isWrapperFor(Class<?> interfaces) throws SQLException {
1:b5f2776:         checkStatus();
1:b5f2776:         return interfaces.isInstance(this);
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     /**
1:b5f2776:      * Returns {@code this} if this class implements the interface.
1:b5f2776:      *
1:b5f2776:      * @param interfaces a Class defining an interface
1:b5f2776:      * @return an object that implements the interface
1:b5f2776:      * @throws SQLException if no object if found that implements the interface
1:b5f2776:      */
1:b5f2776:     public final <T> T unwrap(java.lang.Class<T> interfaces)
1:b5f2776:             throws SQLException {
1:b5f2776:         checkStatus();
1:b5f2776:         try {
1:b5f2776:             return interfaces.cast(this);
1:b5f2776:         } catch (ClassCastException cce) {
1:b5f2776:             throw newSQLException(SQLState.UNABLE_TO_UNWRAP, interfaces);
1:b5f2776:         }
1:b5f2776:     }
1:b5f2776: 
1:de8ba18:     ////////////////////////////////////////////////////////////////////
1:de8ba18:     //
1:de8ba18:     // INTRODUCED BY JDBC 4.1 IN JAVA 7
1:de8ba18:     //
1:de8ba18:     ////////////////////////////////////////////////////////////////////
1:de8ba18: 
1:de8ba18:     public  void    closeOnCompletion() throws SQLException
1:de8ba18:     {
1:de8ba18: 		// Assert the statement is still active (not closed)
1:de8ba18:         checkStatus();
1:de8ba18:         
1:de8ba18:         closeOnCompletion = true;
1:de8ba18:     }
1:de8ba18: 
1:de8ba18:     public  boolean isCloseOnCompletion() throws SQLException
1:de8ba18:     {
1:de8ba18: 		// Assert the statement is still active (not closed)
1:de8ba18:         checkStatus();
1:de8ba18:         
1:de8ba18:         return closeOnCompletion;
1:de8ba18:     }
1:de8ba18: 
1:de8ba18:     //
1:de8ba18:     // For tracking all of the ResultSets produced by this Statement so
1:de8ba18:     // that the Statement can be cleaned up if closeOnCompletion() was invoked.
1:de8ba18:     //
1:de8ba18:     void    closeMeOnCompletion()
1:de8ba18:     {
1:de8ba18:         // If necessary, close the Statement after all of its dependent
1:de8ba18:         // ResultSets have closed.
1:de8ba18:         if ( active && (!closingResultSets) && closeOnCompletion )
1:de8ba18:         {
1:de8ba18:             try {
1:de8ba18:                 if ( isOpen( results ) ) { return; }
1:de8ba18:                 if ( autoGeneratedKeysResultSet != null ) { return; }
1:de8ba18: 
1:de8ba18:                 if ( dynamicResults != null )
1:de8ba18:                 {
1:de8ba18:                     int count = dynamicResults.length;
1:de8ba18:                     for ( int i = 0; i < count; i++ )
1:de8ba18:                     {
1:de8ba18:                         if ( isOpen( dynamicResults[ i ] ) ) { return; }
1:de8ba18:                     }
1:de8ba18:                 }
1:de8ba18: 
1:de8ba18:                 // if we got here, then the Statement has no open ResultSets left
1:de8ba18:                 close();
1:de8ba18:             }
1:de8ba18:             catch (SQLException se) { Util.logSQLException( se ); }
1:de8ba18:         }
1:de8ba18:     }
1:de8ba18:     private boolean isOpen( EmbedResultSet rs ) throws SQLException
1:de8ba18:     {
1:de8ba18:         return ( (rs != null) && (!rs.isClosed()) );
1:de8ba18:     }
1:de8ba18:     
1:eac0369: }
1:eac0369: 
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1:      * There are no more results when (!getMoreResults() &amp;&amp;
/////////////////////////////////////////////////////////////////////////
1:      * condition 0 &lt;= rows &lt;= this.getMaxRows() is not satisfied.
commit:ce40a31
/////////////////////////////////////////////////////////////////////////
1: 			throw newSQLException(SQLState.INVALID_MAXFIELD_SIZE, max);
/////////////////////////////////////////////////////////////////////////
1: 			throw newSQLException(SQLState.INVALID_MAX_ROWS_VALUE, max);
/////////////////////////////////////////////////////////////////////////
1:             throw newSQLException(SQLState.INVALID_QUERYTIMEOUT_VALUE, seconds);
/////////////////////////////////////////////////////////////////////////
1:                     throw newSQLException(SQLState.INVALID_FETCH_DIRECTION, direction);
/////////////////////////////////////////////////////////////////////////
1: 	        throw newSQLException(SQLState.INVALID_ST_FETCH_SIZE, rows);
commit:1ae0d7d
/////////////////////////////////////////////////////////////////////////
0: import java.security.AccessController;
0: import java.security.PrivilegedAction;
/////////////////////////////////////////////////////////////////////////
1: 		lcc = getLanguageConnectionContext( getEmbedConnection() );
commit:71c8e86
/////////////////////////////////////////////////////////////////////////
1:  	Vector<Object> batchStatements;
/////////////////////////////////////////////////////////////////////////
1: 			  batchStatements = new Vector<Object>();
/////////////////////////////////////////////////////////////////////////
1: 			Vector<Object> stmts = batchStatements;
commit:eec86ed
/////////////////////////////////////////////////////////////////////////
0: public abstract class EmbedStatement extends ConnectionChild
commit:706f2eb
/////////////////////////////////////////////////////////////////////////
1:             {
1:             }
commit:cd1db93
/////////////////////////////////////////////////////////////////////////
0:                 ( sqle.getMessage(), sqle.getSQLState(),sqle.getErrorCode(), successfulUpdateCount, sqle );
commit:47a8183
/////////////////////////////////////////////////////////////////////////
1: 	long maxRows;
/////////////////////////////////////////////////////////////////////////
1:         return (int) getLargeMaxRows();
1: 	}
1: 
1:     /**
1:      * JDBC 4.2
1:      *
1:      * The maxRows limit is the maximum number of rows that a
1:      * ResultSet can contain.  If the limit is exceeded, the excess
1:      * rows are silently dropped. For use with
1:      * statements which may touch more than Integer.MAX_VALUE rows.
1:      *
1:      * @return the current max row limit; zero means unlimited
1: 	 * @exception SQLException thrown on failure.
1:      */
1: 	public long getLargeMaxRows() throws SQLException 
1: 	{
/////////////////////////////////////////////////////////////////////////
1:         setLargeMaxRows( max );
1: 	}
1: 
1:     /**
1:      * The maxRows limit is set to limit the number of rows that any
1:      * ResultSet can contain.  If the limit is exceeded, the excess
1:      * rows are silently dropped.
1:      *
1:      * @param max the new max rows limit; zero means unlimited
1: 	 * @exception SQLException thrown on failure.
1:      */
1: 	public void setLargeMaxRows(long max) throws SQLException	
1: 	{
1: 		if (max < 0L)
0: 			throw newSQLException(SQLState.INVALID_MAX_ROWS_VALUE, new Long(max));
commit:0b0a105
/////////////////////////////////////////////////////////////////////////
1:         return Util.squashLongs( executeLargeBatch() );
1:     }
1:     
1:     /**
1:      * JDBC 4.2
1:      * 
1:      * Submit a batch of commands to the database for execution.
1:      * This method is optional. For use with
1:      * statements which may touch more than Integer.MAX_VALUE rows.
1:      */
1:     public long[] executeLargeBatch() throws SQLException {
1:             setupContextStack();
/////////////////////////////////////////////////////////////////////////
1: 			long[] returnUpdateCountForBatch = new long[size];
/////////////////////////////////////////////////////////////////////////
1: 					returnUpdateCountForBatch[ i ] = getLargeUpdateCount();
/////////////////////////////////////////////////////////////////////////
0: 			long[] successfulUpdateCount = new long[ i ];
0: 			SQLException batch = Util.newBatchUpdateException
0:                 ( sqle.getMessage(), sqle.getSQLState(),sqle.getErrorCode(), successfulUpdateCount );
commit:f26c60c
/////////////////////////////////////////////////////////////////////////
1:      * JDBC 4.2
1:      *
1:      *  getLargeUpdateCount returns the current result as an update count;
1:      *  if the result is a ResultSet or there are no more results -1
1:      *  is returned.  It should only be called once per result. For use with
1:      * statements which may touch more than Integer.MAX_VALUE rows.
1:      */
1: 	public final long getLargeUpdateCount()	throws SQLException  {
1: 		checkStatus();
1: 		return updateCount;
1: 	}
1: 
1:     /**
commit:7fb9956
/////////////////////////////////////////////////////////////////////////
1: 	long updateCount = -1;
/////////////////////////////////////////////////////////////////////////
1: 		return (int) executeLargeUpdate( sql );
1: 	}
1: 
1:     /**
1:      * JDBC 4.2
1:      *
1:      * Execute a SQL INSERT, UPDATE or DELETE statement. For use with
1:      * statements which may touch more than Integer.MAX_VALUE rows.
1:      */
1: 	public long executeLargeUpdate(String sql) throws SQLException
1: 	{
/////////////////////////////////////////////////////////////////////////
1: 		return (int) executeLargeUpdate( sql, autoGeneratedKeys );
1: 	}
1: 
1:     /**
1:      * JDBC 4.2
1:      *
1:      * Execute the given SQL statement and signals the driver with the given flag
1:      * about whether the auto-generated keys produced by this Statement object
1:      * should be made available for retrieval. For use with
1:      * statements which may touch more than Integer.MAX_VALUE rows.
1:      */
1: 	public long executeLargeUpdate( String sql, int autoGeneratedKeys ) throws SQLException
1: 	{
1: 		execute( sql, false, true, autoGeneratedKeys, null, null );
/////////////////////////////////////////////////////////////////////////
1: 		return (int) executeLargeUpdate( sql, columnIndexes );
1: 	}
1: 
1:     /**
1:      * JDBC 4.2
1:      *
1:      * Executes the given SQL statement and signals the driver that the
1:      * auto-generated keys indicated in the given array should be made
1:      * available for retrieval. The driver will ignore the array if the SQL
0:      * statement is not an INSERT statement. For use with
1:      * statements which may touch more than Integer.MAX_VALUE rows.
1:      */
1: 	public long executeLargeUpdate( String sql, int[] columnIndexes ) throws SQLException
1: 	{
/////////////////////////////////////////////////////////////////////////
1: 		return (int) executeLargeUpdate( sql, columnNames );
1: 	}
1: 
1:     /**
1:      * JDBC 4.2
1:      *
1:      * Executes the given SQL statement and signals the driver that the
1:      * auto-generated keys indicated in the given array should be made
1:      * available for retrieval. The driver will ignore the array if the SQL
0:      * statement is not an INSERT statement. For use with
1:      * statements which may touch more than Integer.MAX_VALUE rows.
1:      */
1: 	public long executeLargeUpdate(String sql, String[] columnNames) throws SQLException
1: 	{
/////////////////////////////////////////////////////////////////////////
1: 		return (int) updateCount;
/////////////////////////////////////////////////////////////////////////
1: 			updateCount = -1L;
/////////////////////////////////////////////////////////////////////////
1: 					updateCount = -1L;
/////////////////////////////////////////////////////////////////////////
1: 		updateCount = -1L; // reset field
/////////////////////////////////////////////////////////////////////////
1: 			updateCount = -1L;
commit:de8ba18
/////////////////////////////////////////////////////////////////////////
1:     private boolean closeOnCompletion = false;
1:     private boolean closingResultSets = false;
1:     
/////////////////////////////////////////////////////////////////////////
1: 		  // first, clear the result sets.
/////////////////////////////////////////////////////////////////////////
1:                 closeMeOnCompletion();
/////////////////////////////////////////////////////////////////////////
1: 	void clearResultSets() throws SQLException
1:     {
1:         //
1:         // Try not to let closeDependentResultSet() close this Statement
1:         // when we are just cleaning up before the next operation.
1:         //
1:         try {
1:             closingResultSets = true;
1:             clearResultSetsMinion();
1:         }
1:         finally { closingResultSets = false; }
1:     }
1:     // don't call this directly. call clearResultSets() instead.
1:     private void    clearResultSetsMinion() throws SQLException
1:     {
/////////////////////////////////////////////////////////////////////////
1: 
1:     ////////////////////////////////////////////////////////////////////
1:     //
1:     // INTRODUCED BY JDBC 4.1 IN JAVA 7
1:     //
1:     ////////////////////////////////////////////////////////////////////
1: 
1:     public  void    closeOnCompletion() throws SQLException
1:     {
1: 		// Assert the statement is still active (not closed)
1:         checkStatus();
1:         
1:         closeOnCompletion = true;
1:     }
1: 
1:     public  boolean isCloseOnCompletion() throws SQLException
1:     {
1: 		// Assert the statement is still active (not closed)
1:         checkStatus();
1:         
1:         return closeOnCompletion;
1:     }
1: 
1:     //
1:     // For tracking all of the ResultSets produced by this Statement so
1:     // that the Statement can be cleaned up if closeOnCompletion() was invoked.
1:     //
1:     void    closeMeOnCompletion()
1:     {
1:         // If necessary, close the Statement after all of its dependent
1:         // ResultSets have closed.
1:         if ( active && (!closingResultSets) && closeOnCompletion )
1:         {
1:             try {
1:                 if ( isOpen( results ) ) { return; }
1:                 if ( autoGeneratedKeysResultSet != null ) { return; }
1: 
1:                 if ( dynamicResults != null )
1:                 {
1:                     int count = dynamicResults.length;
1:                     for ( int i = 0; i < count; i++ )
1:                     {
1:                         if ( isOpen( dynamicResults[ i ] ) ) { return; }
1:                     }
1:                 }
1: 
1:                 // if we got here, then the Statement has no open ResultSets left
1:                 close();
1:             }
1:             catch (SQLException se) { Util.logSQLException( se ); }
1:         }
1:     }
1:     private boolean isOpen( EmbedResultSet rs ) throws SQLException
1:     {
1:         return ( (rs != null) && (!rs.isClosed()) );
1:     }
1:     
commit:88a3cb9
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:0d57d84
/////////////////////////////////////////////////////////////////////////
1: import java.sql.BatchUpdateException;
1: import java.util.Arrays;
/////////////////////////////////////////////////////////////////////////
1:             long[] successfulUpdateCount =
1:                     Arrays.copyOf(returnUpdateCountForBatch, i);
1:             throw new BatchUpdateException(sqle.getMessage(),
1:                                            sqle.getSQLState(),
1:                                            sqle.getErrorCode(),
1:                                            successfulUpdateCount,
1:                                            sqle );
1:         }
commit:7b6ad6d
/////////////////////////////////////////////////////////////////////////
1:                 ResultSet resultsToWrap =
1:                         ps.execute(a, forMetaData, timeoutMillis);
commit:b5f2776
/////////////////////////////////////////////////////////////////////////
1:  * It supports JDBC 4.1.
1: public class EmbedStatement extends ConnectionChild
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Returns false unless {@code interfaces} is implemented.
1:      *
1:      * @param interfaces a Class defining an interface.
1:      * @return true if this implements the interface or directly or indirectly
1:      * wraps an object that does.
1:      * @throws SQLException if an error occurs while determining
1:      * whether this is a wrapper for an object with the given interface.
1:      */
1:     public final boolean isWrapperFor(Class<?> interfaces) throws SQLException {
1:         checkStatus();
1:         return interfaces.isInstance(this);
1:     }
1: 
1:     /**
1:      * Returns {@code this} if this class implements the interface.
1:      *
1:      * @param interfaces a Class defining an interface
1:      * @return an object that implements the interface
1:      * @throws SQLException if no object if found that implements the interface
1:      */
1:     public final <T> T unwrap(java.lang.Class<T> interfaces)
1:             throws SQLException {
1:         checkStatus();
1:         try {
1:             return interfaces.cast(this);
1:         } catch (ClassCastException cce) {
1:             throw newSQLException(SQLState.UNABLE_TO_UNWRAP, interfaces);
1:         }
1:     }
1: 
commit:a32eb9f
/////////////////////////////////////////////////////////////////////////
1:         batchStatements.add(sql);
/////////////////////////////////////////////////////////////////////////
1: 					if (executeBatchElement(stmts.get(i)))
commit:b3e9947
/////////////////////////////////////////////////////////////////////////
0:             System.arraycopy(returnUpdateCountForBatch, 0, successfulUpdateCount, 0, i);
commit:245209a
/////////////////////////////////////////////////////////////////////////
1: 				// Get the statement. We don't care if it's invalid, because it
1: 				// will be recompiled when we execute it if needed (DERBY-3024).
/////////////////////////////////////////////////////////////////////////
1:                 addWarning(ps.getCompileTimeWarnings());
commit:4f278dd
/////////////////////////////////////////////////////////////////////////
1: 	EmbedResultSet results;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Mark the statement and its single-use activation as unused. This method
1:      * should be called from <code>EmbedPreparedStatement</code>'s finalizer as
1:      * well, even though prepared statements reuse activations, since
1:      * <code>getGeneratedKeys()</code> uses a single-use activation regardless
1:      * of statement type.
1:      */
1:     protected void finalize() throws Throwable {
1:         super.finalize();
1: 
1:         // We mark the activation as not being used and
1:         // that is it.  We rely on the connection to sweep
1:         // through the activations to find the ones that
1:         // aren't in use, and to close them.  We cannot
1:         // do a activation.close() here because there are
1:         // synchronized methods under close that cannot
1:         // be called during finalization.
1:         if (results != null && results.singleUseActivation != null) {
1:             results.singleUseActivation.markUnused();
1:         }
1:     }
1: 
commit:7478b0d
/////////////////////////////////////////////////////////////////////////
0: 			batch.initCause(sqle);
commit:c601222
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * Query timeout in milliseconds. By default, no statements time
1: 	 * out. Timeout is set explicitly with setQueryTimeout().
1: 	 */
1:     long timeoutMillis;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         return (int) (timeoutMillis / 1000);
/////////////////////////////////////////////////////////////////////////
1:         timeoutMillis = (long) seconds * 1000;
/////////////////////////////////////////////////////////////////////////
commit:fade7e9
/////////////////////////////////////////////////////////////////////////
1: 
1:                     // The statement returns rows, so calling it with
1:                     // executeUpdate() is not allowed.
1:                     if (executeUpdate) {
1:                         throw StandardException.newException(
1:                                 SQLState.LANG_INVALID_CALL_TO_EXECUTE_UPDATE);
1:                     }
1: 
/////////////////////////////////////////////////////////////////////////
1:                     int dynamicResultCount = 0;
1:                         dynamicResultCount =
1:                             processDynamicResults(a.getDynamicResults(),
1:                                                   a.getMaxDynamicResults());
1: 
1:                     // executeQuery() is not allowed if the statement
1:                     // doesn't return exactly one ResultSet.
1:                     if (executeQuery && dynamicResultCount != 1) {
1:                         throw StandardException.newException(
1:                                 SQLState.LANG_INVALID_CALL_TO_EXECUTE_QUERY);
1:                     }
1: 
1:                     // executeUpdate() is not allowed if the statement
1:                     // returns ResultSets.
1:                     if (executeUpdate && dynamicResultCount > 0) {
1:                         throw StandardException.newException(
1:                                 SQLState.LANG_INVALID_CALL_TO_EXECUTE_UPDATE);
1:                     }
1:                     if (dynamicResultCount == 0) {
/////////////////////////////////////////////////////////////////////////
1:                     retval = (dynamicResultCount > 0);
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Go through a holder of dynamic result sets, remove those that
1:      * should not be returned, and sort the result sets according to
1:      * their creation.
1:      *
1:      * @param holder a holder of dynamic result sets
1:      * @param maxDynamicResultSets the maximum number of result sets
1:      * to be returned
1:      * @return the actual number of result sets
1:      * @exception SQLException if an error occurs
1:      */
1:     private int processDynamicResults(java.sql.ResultSet[][] holder,
1:                                       int maxDynamicResultSets)
1:         throws SQLException
1:     {
/////////////////////////////////////////////////////////////////////////
1: 		return actualCount;
commit:7eed914
/////////////////////////////////////////////////////////////////////////
1: 	// An EmbedStatement is NOT poolable by default. The constructor for
1: 	// PreparedStatement overrides this.
1: 	protected boolean isPoolable = false;
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 	/**
1: 	 * Returns the value of the EmbedStatement's poolable hint,
1: 	 * indicating whether pooling is requested.
1: 	 *
1: 	 * @return The value of the poolable hint.
1: 	 * @throws SQLException if the Statement has been closed.
1: 	 */
1: 
1: 	public boolean isPoolable() throws SQLException {
1: 		// Assert the statement is still active (not closed)
1: 		checkStatus();
1: 
1: 		return isPoolable;
1: 	}                
1: 
1: 	/**
1: 	 * Requests that an EmbedStatement be pooled or not.
1: 	 *
1: 	 * @param poolable requests that the EmbedStatement be pooled if true
1: 	 * and not be pooled if false.
1: 	 * @throws SQLException if the EmbedStatement has been closed.
1: 	 */
1:      
1: 	public void setPoolable(boolean poolable) throws SQLException {
1: 		// Assert the statement is still active (not closed)
1: 		checkStatus();
1: 
1: 		isPoolable = poolable;
1: 	}
commit:050b616
/////////////////////////////////////////////////////////////////////////
1:         checkStatus();
/////////////////////////////////////////////////////////////////////////
1: 		if (sql == null) {
1: 			throw newSQLException(SQLState.NULL_SQL_TEXT);
1: 		}
/////////////////////////////////////////////////////////////////////////
1: 		checkStatus();
commit:712b41b
/////////////////////////////////////////////////////////////////////////
1:      *
1:      * Making it protected to allow access from EmbedPreparedStatement40
1:      * to be used for StatementEvents
1:      *
1:     protected EngineStatement applicationStatement;
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:aa302c3
/////////////////////////////////////////////////////////////////////////
1:      * statement is not an INSERT/UPDATE statement. For use with
/////////////////////////////////////////////////////////////////////////
1:      * statement is not an INSERT/UPDATE statement. For use with
/////////////////////////////////////////////////////////////////////////
1:      * this signal if the SQL statement is not an INSERT/UPDATE statement.
/////////////////////////////////////////////////////////////////////////
1:      * INSERT/UPDATE statement.
1:      * inserted/updated row that should be made available for retrieval by a
1:      * call to the method getGeneratedKeys
/////////////////////////////////////////////////////////////////////////
1:      * INSERT/UPDATE statement.
1:      * inserted/updated row that should be made available for retrieval by a
1:      * call to the method getGeneratedKeys
/////////////////////////////////////////////////////////////////////////
1: 					// Only applicable for an insert/update statement, which does not return rows.
1: 					//the auto-generated keys resultset will be null if used for other statement
commit:782354a
/////////////////////////////////////////////////////////////////////////
1:         try {
1:         	//following will check if the JDBC ResultSet or the language
1:         	//ResultSet is closed. If yes, then it will throw an exception.
1:         	//So, the exception indicates that the ResultSet is closed and
1:         	//hence we should ignore it. 
1:         	lrs.checkIfClosed("");
1:         } catch (SQLException ex) {
1:             return null;        	
1:         }
commit:0f4ab91
/////////////////////////////////////////////////////////////////////////
1:                     resultsToWrap.close(); // Don't need the result set any more
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:3a6f4cf
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.util.InterruptStatus;
/////////////////////////////////////////////////////////////////////////
1:                 InterruptStatus.restoreIntrFlagIfSeen(lcc);
/////////////////////////////////////////////////////////////////////////
1:                     // If we saw an interrupt, stop execution of batch now.
1:                     // throwIf will likely only throw after at least one stm
1:                     // has been executed, since first time around we probably
1:                     // didn't do anything to notice interrupts yet.
1:                     InterruptStatus.throwIf(lcc);
1: 
1:                 InterruptStatus.restoreIntrFlagIfSeen(lcc);
/////////////////////////////////////////////////////////////////////////
1: 
1:                 InterruptStatus.restoreIntrFlagIfSeen(lcc);
1: 
1:             } catch (Throwable t) {
commit:e3883f5
/////////////////////////////////////////////////////////////////////////
0:                 ResultSet resultsToWrap = ps.execute(a, timeoutMillis);
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:1e8a20f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private int fetchDirection = java.sql.ResultSet.FETCH_FORWARD;
/////////////////////////////////////////////////////////////////////////
1: 				    (lcc.getDefaultSchema(), sql, resultSetConcurrency==
1:                         java.sql.ResultSet.CONCUR_READ_ONLY, false);
1: 					preparedStatement.getActivation(lcc, resultSetType ==
1:                         java.sql.ResultSet.TYPE_SCROLL_INSENSITIVE);
/////////////////////////////////////////////////////////////////////////
1:                 if (direction == java.sql.ResultSet.FETCH_FORWARD || 
1:                     direction == java.sql.ResultSet.FETCH_REVERSE ||
1:                     direction == java.sql.ResultSet.FETCH_UNKNOWN )
/////////////////////////////////////////////////////////////////////////
1:         if (resultSetHoldability  == java.sql.ResultSet.CLOSE_CURSORS_AT_COMMIT)
/////////////////////////////////////////////////////////////////////////
1:             java.sql.ResultSet.HOLD_CURSORS_OVER_COMMIT;
commit:a0118e1
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Statement;
/////////////////////////////////////////////////////////////////////////
1: 		execute(sql, true, false, Statement.NO_GENERATED_KEYS, null, null);
/////////////////////////////////////////////////////////////////////////
1: 		execute(sql, false, true, Statement.NO_GENERATED_KEYS, null, null);
/////////////////////////////////////////////////////////////////////////
1: 				? Statement.NO_GENERATED_KEYS
1: 				: Statement.RETURN_GENERATED_KEYS,
/////////////////////////////////////////////////////////////////////////
1: 				? Statement.NO_GENERATED_KEYS
1: 				: Statement.RETURN_GENERATED_KEYS,
/////////////////////////////////////////////////////////////////////////
1: 		return execute(sql, false, false, Statement.NO_GENERATED_KEYS, null, null);
/////////////////////////////////////////////////////////////////////////
1: 			if (autoGeneratedKeys == Statement.RETURN_GENERATED_KEYS)
/////////////////////////////////////////////////////////////////////////
1: 				? Statement.NO_GENERATED_KEYS
1: 				: Statement.RETURN_GENERATED_KEYS,
/////////////////////////////////////////////////////////////////////////
1: 				? Statement.NO_GENERATED_KEYS
1: 				: Statement.RETURN_GENERATED_KEYS,
/////////////////////////////////////////////////////////////////////////
1: 		return getMoreResults(Statement.CLOSE_ALL_RESULTS);
/////////////////////////////////////////////////////////////////////////
1: 		return execute((String)batchElement, false, true, Statement.NO_GENERATED_KEYS, null, null);
/////////////////////////////////////////////////////////////////////////
1: 			case Statement.CLOSE_ALL_RESULTS:
1: 			case Statement.CLOSE_CURRENT_RESULT:
1: 			case Statement.KEEP_CURRENT_RESULT:
/////////////////////////////////////////////////////////////////////////
1: 			execute("VALUES IDENTITY_VAL_LOCAL()", true, false, Statement.NO_GENERATED_KEYS, null, null);
commit:048eb34
/////////////////////////////////////////////////////////////////////////
commit:5b2b352
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                     
0:                     resultsToWrap.finish(); // Don't need the result set any more
/////////////////////////////////////////////////////////////////////////
1: 
1:             // Clear the JDBC dynamic ResultSet from the language
1:             // ResultSet for the CALL statement. This stops the
1:             // CALL statement closing the ResultSet when its language
1:             // ResultSet is closed, which will happen just after the
1:             // call to the processDynamicResults() method.
1:             
1:             // ignore non-Derby result sets or results sets from another connection
1:             // and closed result sets.
1:             EmbedResultSet lrs = EmbedStatement.processDynamicResult(
1:                     getEmbedConnection(), rs, this);
1:             
1:             if (lrs == null)
1:             {
1:                 continue;
1:             }
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Process a ResultSet created in a Java procedure as a dynamic result.
1:      * To be a valid dynamic result the ResultSet must be:
1:      * <UL>
1:      * <LI> From a Derby system
1:      * <LI> From a nested connection of connection passed in
1:      * or from the connection itself.
1:      * <LI> Open
1:      * </UL>
1:      * Any invalid ResultSet is ignored.
1:      * 
0:      * <P>
0:      * if b
1:      * 
1:      * @param conn Connection ResultSet needs to belong to
1:      * @param resultSet ResultSet to be tested
1:      * @param callStatement Statement that executed the CALL, null if 
1:      * @return The result set cast down to EmbedResultSet, null if not a valid
1:      * dynamic result.
1:      */
1:     static EmbedResultSet processDynamicResult(EmbedConnection conn,
1:             java.sql.ResultSet resultSet,
1:             EmbedStatement callStatement)
1:     {
1:         if (resultSet == null)
1:             return null;
1: 
1:         // ignore non-Derby result sets or results sets from another connection
1:         if (!(resultSet instanceof EmbedResultSet))
1:             return null;
1: 
1:         EmbedResultSet lrs = (EmbedResultSet) resultSet;
1: 
1:         if (lrs.getEmbedConnection().rootConnection != conn.rootConnection)
1:             return null;
1: 
1:         // ignore closed result sets.
1:         if (lrs.isClosed)
1:             return null;
1:         
1:         lrs.setDynamicResultSet(callStatement);
1: 
1:         return lrs;
1:     }
commit:e836c59
/////////////////////////////////////////////////////////////////////////
1:      * <BR>
1:      * Dynamic result sets (those in dynamicResults array) need not
1:      * be handled here as they will be handled by the statement object
1:      * that created them. In some cases results will point to a
1:      * ResultSet in dynamicResults but all that will happen is that
1:      * the activation will get marked as unused twice.
commit:d281462
/////////////////////////////////////////////////////////////////////////
1:             
1:             if (SanityManager.DEBUG)
1:             {
1:                 // Ensure that clearResultSets has been called
1:                 // to fulfill [JDBC4: section 15.2.5 ]
1:                 // A ResultSet object is implicitly closed when:
1:                 // The associated Statement object is re-executed
1:                 
1:                 SanityManager.ASSERT(results == null);
1:                 SanityManager.ASSERT(dynamicResults == null);
1:                 SanityManager.ASSERT(autoGeneratedKeysResultSet == null);
1:            }
1:             
commit:3657462
/////////////////////////////////////////////////////////////////////////
1: 	final int resultSetConcurrency;
commit:2f015be
/////////////////////////////////////////////////////////////////////////
1: 						lresults.singleUseActivation = a;
commit:175a740
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Statement reference the application is using to execute
1:      * this Statement. Normally set to this, but if this was
1:      * created by a Connection from an XAConnection then this
1:      * will be a reference to the BrokeredStatement.
1:      */
0:     private EngineStatement applicationStatement;
/////////////////////////////////////////////////////////////////////////
1:         applicationStatement = this;
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Set the application statement for this Statement.
1:     */
1:     public final void setApplicationStatement(EngineStatement s) {
1:         this.applicationStatement = s;
1:     }
/////////////////////////////////////////////////////////////////////////
1:      * @throws SQLException Error from getResultSetHoldability.
1:     private boolean getExecuteHoldable() throws SQLException
1:         // Simple non-XA case
1:         if (applicationStatement == this)
1:             return true;
1:         
1:         return applicationStatement.getResultSetHoldability() ==
0:             JDBC30Translation.HOLD_CURSORS_OVER_COMMIT;
commit:562671e
/////////////////////////////////////////////////////////////////////////
1:                 
1:                 boolean executeHoldable = getExecuteHoldable();
1:  
1: 				a.setResultSetHoldability(executeHoldable);
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Get the execute time holdability for the Statement.
1:      * When in a global transaction holdabilty defaults to false.
1:      */
0:     private boolean getExecuteHoldable()
1:     {
0:         if (resultSetHoldability  == JDBC30Translation.CLOSE_CURSORS_AT_COMMIT)
1:             return false;
1:         
1:         return true;
1:     }
commit:4e3b1b6
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.jdbc.EngineStatement;
/////////////////////////////////////////////////////////////////////////
1:     implements EngineStatement {
commit:23b4f8b
/////////////////////////////////////////////////////////////////////////
0: 	int updateCount = -1;
0: 	java.sql.ResultSet results;
1: 	private String cursorName;
1: 	private final boolean forMetaData;
1: 	final LanguageConnectionContext lcc;
1: 	String SQLText;
/////////////////////////////////////////////////////////////////////////
1: 	private boolean active = true;
0:  	Vector batchStatements;
/////////////////////////////////////////////////////////////////////////
1: 	final void checkIfInMiddleOfBatch() throws SQLException {
/////////////////////////////////////////////////////////////////////////
1: 	private boolean execute(String sql, boolean executeQuery, boolean executeUpdate,
/////////////////////////////////////////////////////////////////////////
1: 	boolean executeBatchElement(Object batchElement) throws SQLException, StandardException {
/////////////////////////////////////////////////////////////////////////
1: 	boolean executeStatement(Activation a,
/////////////////////////////////////////////////////////////////////////
0: 	void clearResultSets() throws SQLException {
/////////////////////////////////////////////////////////////////////////
1: 	void checkRequiresCallableStatement(Activation activation) throws SQLException {
commit:72cc553
/////////////////////////////////////////////////////////////////////////
1: 	final int resultSetType;
0: 	private final int resultSetConcurrency;
1: 	private final int resultSetHoldability;
/////////////////////////////////////////////////////////////////////////
1:     public final int getResultSetHoldability() throws SQLException {
/////////////////////////////////////////////////////////////////////////
0: 				addWarning(ps.getCompileTimeWarnings());
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 				addWarning(a.getWarnings());
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Add a SQLWarning to this Statement object.
1:      * If the Statement already has a SQLWarning then it
1:      * is added to the end of the chain.
1:      * 
1:      * @see #getWarnings()
1:      */
1: 	final void addWarning(SQLWarning sw)
/////////////////////////////////////////////////////////////////////////
1: 				addWarning(StandardException.newWarning(SQLState.LANG_TOO_MANY_DYNAMIC_RESULTS_RETURNED));
commit:d192b7d
/////////////////////////////////////////////////////////////////////////
1:         If this Statement's Connection is closed an exception will
commit:a1a7f8b
/////////////////////////////////////////////////////////////////////////
1: 	/**
1:      * Throw an exception if this Statement has been closed explictly
1:      * or it has noticed it has been closed implicitly.
1:      * JDBC specifications require nearly all methods throw a SQLException
1:      * if the Statement has been closed, thus most methods call this
1:      * method or checkExecStatus first.
1:      * 
1:      * @exception SQLException Thrown if the statement is marked as closed.
1:      * 
1:      * @see #checkExecStatus()
1: 	 */
/////////////////////////////////////////////////////////////////////////
1:         <BR>
0:         If this Statement's exception is actually closed an exception will
1:         be thrown and the active field will be set to false,
1:         completely marking the Statement as closed.
1:         <BR>
1:         If the Statement is not currently connected to an active
1:         transaction, i.e. a suspended global transaction, then
1:         this method will throw a SQLException but the Statement
1:         will remain open. The Statement is open but unable to
1:         process any new requests until its global transaction
1:         is resumed.
1:         <BR>
1:         Upon return from the method, with or without a SQLException
1:         the field active will correctly represent the open state of
1:         the Statement.
1:         
1:         @exception SQLException Thrown if the statement is marked as closed
1:         or the Statement's transaction is suspended.
1:         
1:         @see #checkStatus()
1: 	final void checkExecStatus() throws SQLException {
commit:dd1bd91
/////////////////////////////////////////////////////////////////////////
1:         
1:         // Now this connection is closed for all
1:         // future use.
1:         active = false;
1:         	
commit:0c13195
/////////////////////////////////////////////////////////////////////////
1: 	void closeActions() throws SQLException {
/////////////////////////////////////////////////////////////////////////
1: 		if ((appConn != applicationConnection) || (appConn == null)) {
1: 
1:         }
/////////////////////////////////////////////////////////////////////////
1: 					lrs.close();
/////////////////////////////////////////////////////////////////////////
1:     final void checkStatus() throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:               	
/////////////////////////////////////////////////////////////////////////
1: 					lrs.close();
commit:3fcea8a
/////////////////////////////////////////////////////////////////////////
0:     private int timeoutSeconds;
/////////////////////////////////////////////////////////////////////////
1: 
0:         // By default, no statements time out.
0:         // Timeout is set explicitly with setQueryTimeout().
0:         timeoutSeconds = 0;
/////////////////////////////////////////////////////////////////////////
1: 	public final int getQueryTimeout() throws SQLException {
0:         return timeoutSeconds;
/////////////////////////////////////////////////////////////////////////
1: 	public final void setQueryTimeout(int seconds) throws SQLException {
1: 		checkStatus();
1:         if (seconds < 0) {
0:             throw newSQLException(SQLState.INVALID_QUERYTIMEOUT_VALUE,
0:                                   new Integer(seconds));
1:         }
0:         timeoutSeconds = seconds;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Execute a SQL statement that may return multiple results.
1:      * Under some (uncommon) situations a single SQL statement may return
1:      * multiple result sets and/or update counts.  Normally you can ignore
1:      * this, unless you're executing a stored procedure that you know may
1:      * return multiple results, or unless you're dynamically executing an
1:      * unknown SQL string.  The "execute", "getMoreResults", "getResultSet"
1:      * and "getUpdateCount" methods let you navigate through multiple results.
1:      *
1:      * The "execute" method executes a SQL statement and indicates the
1:      * form of the first result.  You can then use getResultSet or
1:      * getUpdateCount to retrieve the result, and getMoreResults to
1:      * move to any subsequent result(s).
1:      *
1:      * @param sql					any SQL statement
1: 	 * @param executeQuery			caller is executeQuery()
1: 	 * @param executeUpdate			caller is executeUpdate()
1:      * @param autoGeneratedKeys
1:      * @param columnIndexes
1:      * @param columnNames
1: 	 *
1:      * @return true if the first result is a ResultSet; false if it is an integer
1:      * @see #getResultSet
1:      * @see #getUpdateCount
1:      * @see #getMoreResults
1: 	 * @exception SQLException thrown on failure
1:      */
/////////////////////////////////////////////////////////////////////////
0:                 long timeoutMillis = (long)timeoutSeconds * 1000L;
0:                 ps.setQueryTimeout(timeoutMillis);
commit:4153b27
/////////////////////////////////////////////////////////////////////////
0:    <P><B>Supports</B>
0:    <UL>
0:    <LI> JSR169 - no subsetting for java.sql.Statement
0:    <LI> JDBC 2.0
0:    <LI> JDBC 3.0 - no new dependencies on new JDBC 3.0 or JDK 1.4 classes,
0:         new methods can safely be added into implementation.
0:    </UL>
1: 
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.jdbc.EmbedStatement
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:1f9b9c4
/////////////////////////////////////////////////////////////////////////
0:     implements java.sql.Statement {
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.jdbc
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.jdbc;
1: 
0: import org.apache.derby.iapi.reference.JDBC20Translation;
0: import org.apache.derby.iapi.reference.JDBC30Translation;
1: import org.apache.derby.iapi.reference.SQLState;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: import org.apache.derby.iapi.sql.Activation;
1: import org.apache.derby.iapi.sql.PreparedStatement;
1: import org.apache.derby.iapi.sql.ResultSet;
1: import org.apache.derby.iapi.sql.ParameterValueSet;
1: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1: import org.apache.derby.iapi.error.StandardException;
1: 
1: import java.sql.SQLException;
1: import java.sql.SQLWarning;
1: import java.util.Vector;
1: 
1: /*
1:  We would import these, but have name-overlap
1: import java.sql.Statement;
1: import java.sql.ResultSet;
1: */
1: 
1: /**
1:  *
1:  * EmbedStatement is a local JDBC statement.
1:  *
0:  * @author ames
1:  */
0: public class EmbedStatement extends ConnectionChild
0:     implements java.sql.Statement { 
1: 
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 
1: 	private final java.sql.Connection applicationConnection;
1: 
0: 	protected int updateCount = -1;
0: 	protected java.sql.ResultSet results;
1: 	//for jdbc3.0 feature, where you can get a resultset of rows inserted
1: 	//for auto generated columns after an insert
1: 	private java.sql.ResultSet autoGeneratedKeysResultSet;
0: 	protected String cursorName;
1: 
0: 	protected final boolean forMetaData;
0: 	public final int resultSetType;
0: 	protected final int resultSetConcurrency;
0: 	protected final int resultSetHoldability;
0: 	protected final LanguageConnectionContext lcc;
1: 
1: 	private SQLWarning warnings;
0: 	protected String SQLText;
1: 
1:     private int fetchSize = 1;
0:     private int fetchDirection = JDBC20Translation.FETCH_FORWARD;
1:     int MaxFieldSize;
1: 
1: 	//the state of this statement, set to false when close() is called
0: 	protected boolean active = true;
1: 
1:     //in case of batch update, save the individual statements in the batch in this vector
1:  	//this is only used by JDBC 2.0
0:  	protected Vector batchStatements;
1: 	
1: 	// The maximum # of rows to return per result set.
1: 	// (0 means no limit.)
0: 	int maxRows;
1: 
1: 	private ParameterValueSet pvs;
1: 
1: 	//
1: 	// constructor
1: 	//
1: 	public EmbedStatement (EmbedConnection connection, boolean forMetaData,
1: 							  int resultSetType, int resultSetConcurrency, int resultSetHoldability)
1: 	{
1: 	    super(connection);
1: 		this.forMetaData = forMetaData;
1: 		this.resultSetType = resultSetType;
1: 		this.resultSetConcurrency = resultSetConcurrency;
1: 		this.resultSetHoldability = resultSetHoldability;
1: 
0: 		lcc = getEmbedConnection().getLanguageConnection();
1: 		applicationConnection = getEmbedConnection().getApplicationConnection();
1: 	}
1: 
1: 	//
1: 	// java.sql.Statement interface
1: 	// the comments are those from the JDBC interface,
1: 	// so we know what we're supposed to to.
1: 
1: 	/**
1:      * Execute a SQL statement that returns a single ResultSet.
1:      *
1:      * @param sql					typically this is a static SQL SELECT statement
1: 	 * @return a ResultSet that contains the data produced by the
1:      * query; never null
1: 	 * @exception SQLException thrown on failure.
1:      */
1: 	public java.sql.ResultSet executeQuery(String sql)
1: 		throws SQLException
1: 	{
0: 		execute(sql, true, false, JDBC30Translation.NO_GENERATED_KEYS, null, null);
1: 
1: 		if (SanityManager.DEBUG) {
1: 			if (results == null)
1: 				SanityManager.THROWASSERT("no results returned on executeQuery()");
1: 		}
1: 
1: 		return results;
1: 	}
1: 
1:     /**
1:      * Execute a SQL INSERT, UPDATE or DELETE statement. In addition,
1:      * SQL statements that return nothing such as SQL DDL statements
1:      * can be executed.
1:      *
1:      * @param sql a SQL INSERT, UPDATE or DELETE statement or a SQL
1:      * statement that returns nothing
1:      * @return either the row count for INSERT, UPDATE or DELETE; or 0
1:      * for SQL statements that return nothing
1: 	 * @exception SQLException thrown on failure.
1:      */
1: 	public int executeUpdate(String sql) throws SQLException
1: 	{
0: 		execute(sql, false, true, JDBC30Translation.NO_GENERATED_KEYS, null, null);
1: 		return updateCount;
1: 	}
1: 
1:     /**
1:      * JDBC 3.0
1:      *
1:      * Execute the given SQL statement and signals the driver with the given flag
1:      * about whether the auto-generated keys produced by this Statement object
1:      * should be made available for retrieval.
1:      *
1:      * @param sql a SQL INSERT, UPDATE or DELETE statement or a SQL
1:      * statement that returns nothing
1:      * @param autoGeneratedKeys - a flag indicating whether auto-generated keys
1:      * should be made available for retrieval; one of the following constants:
1:      * Statement.RETURN_GENERATED_KEYS Statement.NO_GENERATED_KEYS
1:      * @return either the row count for INSERT, UPDATE or DELETE; or 0
1:      * for SQL statements that return nothing
1:      * @exception SQLException if a database access error occurs
1:      */
1: 	public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException
1: 	{
0: 		execute(sql, false, true, autoGeneratedKeys, null, null);
1: 		return updateCount;
1: 	}
1: 
1:     /**
1:      * JDBC 3.0
1:      *
1:      * Executes the given SQL statement and signals the driver that the
1:      * auto-generated keys indicated in the given array should be made
1:      * available for retrieval. The driver will ignore the array if the SQL
1:      * statement is not an INSERT statement
1:      *
1:      * @param sql a SQL INSERT, UPDATE or DELETE statement or a SQL
1:      * statement that returns nothing
1:      * @param columnIndexes - an array of column indexes indicating the
1:      * columns that should be returned from the inserted row
1:      * @return either the row count for INSERT, UPDATE or DELETE; or 0
1:      * for SQL statements that return nothing
1:      * @exception SQLException if a database access error occurs
1:      */
1: 	public int executeUpdate(String sql, int[] columnIndexes) throws SQLException
1: 	{
0:  		throw Util.notImplemented("executeUpdate(String, int[])");
1: 	}
1: 
1:     /**
1:      * JDBC 3.0
1:      *
1:      * Executes the given SQL statement and signals the driver that the
1:      * auto-generated keys indicated in the given array should be made
1:      * available for retrieval. The driver will ignore the array if the SQL
1:      * statement is not an INSERT statement
1:      *
1:      * @param sql a SQL INSERT, UPDATE or DELETE statement or a SQL
1:      * statement that returns nothing
1:      * @param columnNames - an array of the names of the columns
1:      * that should be returned from the inserted row
1:      * @return either the row count for INSERT, UPDATE or DELETE; or 0
1:      * for SQL statements that return nothing
1:      * @exception SQLException if a database access error occurs
1:      */
1: 	public int executeUpdate(String sql, String[] columnNames) throws SQLException
1: 	{
0:  		throw Util.notImplemented("executeUpdate(String, String[])");
1: 	}
1: 
0: 	protected final void checkIfInMiddleOfBatch() throws SQLException {
1: 		/* If batchStatements is not null then we are in the middle
1: 		 * of a batch. That's an invalid state. We need to finish the
1: 		 * batch either by clearing the batch or executing the batch.
1: 		 * executeUpdate is not allowed inside the batch.
1: 		 */
1: 		if (batchStatements != null)
1:   		throw newSQLException(SQLState.MIDDLE_OF_BATCH);
1: 	}
1: 
1:     /**
1:      * In many cases, it is desirable to immediately release a
1:      * Statements's database and JDBC resources instead of waiting for
1:      * this to happen when it is automatically closed; the close
1:      * method provides this immediate release.
1:      *
1:      * <P><B>Note:</B> A Statement is automatically closed when it is
1:      * garbage collected. When a Statement is closed its current
1:      * ResultSet, if one exists, is also closed.
1: 	 * @exception SQLException thrown on failure.
1:      */
1: 	public final void close() throws SQLException {
1: 
1: 		/* The close() method is the only method
1: 		 * that is allowed to be called on a closed
1: 		 * Statement, as per Jon Ellis.
1: 		 */
1: 		if (!active)
1: 		{
1: 			return;
1: 		}
1: 
1: 	  synchronized (getConnectionSynchronization()) {
1: 
1: 		  closeActions();
1: 		  
1: 		  //we first set the status
1: 		  active = false;
1: 
0: 		  //first, clear the resutl set
1: 		  clearResultSets();
1: 		  
1: 		  //next, release other resource
1: 		  cursorName = null;
1: 		  warnings = null;
1: 		  SQLText = null;
1: 		  batchStatements = null;
1: 	  }
1: 	}
1: 
1: 	// allow sub-classes to execute additional close
1: 	// logic while holding the synchronization.
0: 	protected void closeActions() throws SQLException {
1: 	}
1: 
1:     //----------------------------------------------------------------------
1: 
1:     /**
1:      * The maxFieldSize limit (in bytes) is the maximum amount of data
1:      * returned for any column value; it only applies to BINARY,
1:      * VARBINARY, LONGVARBINARY, CHAR, VARCHAR, and LONGVARCHAR
1:      * columns.  If the limit is exceeded, the excess data is silently
1:      * discarded.
1:      *
1:      * @return the current max column size limit; zero means unlimited
1: 	 * @exception SQLException thrown on failure.
1:      */
1: 	public int getMaxFieldSize() throws SQLException {
1: 		checkStatus();
1: 
1:         return MaxFieldSize;
1: 	}
1: 
1:     /**
1:      * The maxFieldSize limit (in bytes) is set to limit the size of
1:      * data that can be returned for any column value; it only applies
1:      * to BINARY, VARBINARY, LONGVARBINARY, CHAR, VARCHAR, and
1:      * LONGVARCHAR fields.  If the limit is exceeded, the excess data
1:      * is silently discarded.
1:      *
1:      * @param max the new max column size limit; zero means unlimited
1: 	 * @exception SQLException thrown on failure.
1:      */
1: 	public void setMaxFieldSize(int max) throws SQLException {
1: 		checkStatus();
1: 
1: 		if (max < 0)
1: 		{
0: 			throw newSQLException(SQLState.INVALID_MAXFIELD_SIZE, new Integer(max));
1: 		}
1:         this.MaxFieldSize = max;
1: 	}
1: 
1:     /**
1:      * The maxRows limit is the maximum number of rows that a
1:      * ResultSet can contain.  If the limit is exceeded, the excess
1:      * rows are silently dropped.
1:      *
1:      * @return the current max row limit; zero means unlimited
1: 	 * @exception SQLException thrown on failure.
1:      */
1: 	public int getMaxRows() throws SQLException 
1: 	{
1: 		checkStatus();
1: 		return maxRows;
1: 	}
1: 
1:     /**
1:      * The maxRows limit is set to limit the number of rows that any
1:      * ResultSet can contain.  If the limit is exceeded, the excess
1:      * rows are silently dropped.
1:      *
1:      * @param max the new max rows limit; zero means unlimited
1: 	 * @exception SQLException thrown on failure.
1:      */
1: 	public void setMaxRows(int max) throws SQLException	
1: 	{
1: 		checkStatus();
1: 		if (max < 0)
1: 		{
0: 			throw newSQLException(SQLState.INVALID_MAX_ROWS_VALUE, new Integer(max));
1: 		}
1: 		this.maxRows = max;
1: 	}
1: 
1:     /**
1:      * If escape scanning is on (the default) the driver will do
1:      * escape substitution before sending the SQL to the database.
1:      *
1:      * @param enable true to enable; false to disable
1: 	 * @exception SQLException thrown on failure.
1:      */
1: 	public void setEscapeProcessing(boolean enable) throws SQLException	{
1: 		checkStatus();
1:         // Nothing to do in our server , just ignore it.
1: 
1: 	}
1: 
1:     /**
1:      * The queryTimeout limit is the number of seconds the driver will
1:      * wait for a Statement to execute. If the limit is exceeded a
1:      * SQLException is thrown.
1:      *
1:      * @return the current query timeout limit in seconds; zero means unlimited
1: 	 * @exception SQLException thrown on failure.
1:      */
0: 	public int getQueryTimeout() throws SQLException {
0:         // Currently Cloudscape does not support any sort of timeout, so always
0:         // return 0, which means that timeout is unlimited.
0:         return(0);
1: 	}
1: 
1:     /**
1:      * The queryTimeout limit is the number of seconds the driver will
1:      * wait for a Statement to execute. If the limit is exceeded a
1:      * SQLException is thrown.
1:      *
1:      * @param seconds the new query timeout limit in seconds; zero means unlimited
1: 	 * @exception SQLException thrown on failure.
1:      */
0: 	public void setQueryTimeout(int seconds) throws SQLException {
0: 		if (seconds != 0)
0: 			throw Util.notImplemented("setQueryTimeout");
1: 	}
1: 
1:     /**
1:      * Cancel can be used by one thread to cancel a statement that
1:      * is being executed by another thread.
1: 	 * @exception SQLException thrown on failure.
1:      */
1: 	public void cancel() throws SQLException {
1: 		throw Util.notImplemented("cancel");
1: 	}
1: 
1:     /**
1:      * The first warning reported by calls on this Statement is
1:      * returned.  A Statment's execute methods clear its SQLWarning
1:      * chain. Subsequent Statement warnings will be chained to this
1:      * SQLWarning.
1:      *
1:      * <p>The warning chain is automatically cleared each time
1:      * a statement is (re)executed.
1:      *
1:      * <P><B>Note:</B> If you are processing a ResultSet then any
1:      * warnings associated with ResultSet reads will be chained on the
1:      * ResultSet object.
1:      *
1:      * @return the first SQLWarning or null
1: 	 * @exception SQLException thrown on failure.
1:      */
1: 	public SQLWarning getWarnings() throws SQLException	{
1: 		checkStatus();
1: 		return warnings;
1: 	}
1: 
1:     /**
1:      * After this call getWarnings returns null until a new warning is
1:      * reported for this Statement.
1: 	 * @exception SQLException thrown on failure.
1:      */
1: 	public void clearWarnings() throws SQLException	{
1: 		checkStatus();
1: 		warnings = null;
1: 	}
1: 
1:     /**
1:      * setCursorName defines the SQL cursor name that will be used by
1:      * subsequent Statement execute methods. This name can then be
1:      * used in SQL positioned update/delete statements to identify the
1:      * current row in the ResultSet generated by this statement.  If
1:      * the database doesn't support positioned update/delete, this
1:      * method is a noop.
1:      *
1:      * <P><B>Note:</B> By definition, positioned update/delete
1:      * execution must be done by a different Statement than the one
1:      * which generated the ResultSet being used for positioning. Also,
1:      * cursor names must be unique within a Connection.
1:      *
1:      * @param name the new cursor name.
1:      */
1: 	public void setCursorName(String name) throws SQLException {
1: 		checkStatus();
1: 		cursorName = name;
1: 	}
1: 
1:     //----------------------- Multiple Results --------------------------
1: 
1:     /**
1:      * Execute a SQL statement that may return multiple results.
1:      * Under some (uncommon) situations a single SQL statement may return
1:      * multiple result sets and/or update counts.  Normally you can ignore
1:      * this, unless you're executing a stored procedure that you know may
1:      * return multiple results, or unless you're dynamically executing an
1:      * unknown SQL string.  The "execute", "getMoreResults", "getResultSet"
1:      * and "getUpdateCount" methods let you navigate through multiple results.
1:      *
1:      * The "execute" method executes a SQL statement and indicates the
1:      * form of the first result.  You can then use getResultSet or
1:      * getUpdateCount to retrieve the result, and getMoreResults to
1:      * move to any subsequent result(s).
1:      *
1:      * @param sql					any SQL statement
0: 	 * @param executeQuery			caller is executeQuery()
0: 	 * @param executeUpdate			caller is executeUpdate()
1: 	 *
1:      * @return true if the first result is a ResultSet; false if it is an integer
1:      * @see #getResultSet
1:      * @see #getUpdateCount
1:      * @see #getMoreResults
1: 	 * @exception SQLException thrown on failure
1:      */
1: 	public boolean execute(String sql)
1: 		throws SQLException
1: 	{
0: 		return execute(sql, false, false, JDBC30Translation.NO_GENERATED_KEYS, null, null);
1: 	}
1: 	
0: 	protected boolean execute(String sql, boolean executeQuery, boolean executeUpdate,
1: 		int autoGeneratedKeys, int[] columnIndexes, String[] columnNames) throws SQLException
1: 	{
1: 
0: 	// if sql is null, raise an error
0: 	if (sql == null)
0:   		throw newSQLException(SQLState.NULL_SQL_TEXT);
1: 
1: 	  synchronized (getConnectionSynchronization()) {
1: 
1: 		checkExecStatus();
1: 		checkIfInMiddleOfBatch();
1: 		clearResultSets(); // release the last statement executed, if any.
1: 
1:         setupContextStack(); // make sure there's context
1: 
1: 
1: 		// try to remember the SQL statement in case anybody asks for it
1: 		SQLText = sql;		
1: 
1: 		try {
1: 			Activation activation;
1: 			try {
0: 				PreparedStatement preparedStatement = lcc.prepareInternalStatement(sql);
1: 				activation =
0: 					preparedStatement.getActivation(lcc, resultSetType == JDBC20Translation.TYPE_SCROLL_INSENSITIVE);
1: 				checkRequiresCallableStatement(activation);
1: 			 } catch (Throwable t) {
1: 				throw handleException(t);
1: 			 }
1: 
1: 
1: 			// this is for a Statement execution
1: 			activation.setSingleExecution();
1: 
1: 			//bug 4838 - save the auto-generated key information in activation. keeping this
1: 			//information in lcc will not work work it can be tampered by a nested trasaction
0: 			if (autoGeneratedKeys == JDBC30Translation.RETURN_GENERATED_KEYS)
1: 				activation.setAutoGeneratedKeysResultsetInfo(columnIndexes, columnNames);
1: 			return executeStatement(activation, executeQuery, executeUpdate);
1: 		} finally {
1: 		    restoreContextStack();
1: 		}
1: 	  }
1: 	}
1: 
1:     /**
1:      * JDBC 3.0
1:      *
1:      * Executes the given SQL statement, which may return multiple
1:      * results, and signals the driver that any auto-generated keys
1:      * should be made available for retrieval. The driver will ignore
0:      * this signal if the SQL statement is not an INSERT statement.
1:      *
1:      * @param sql any SQL statement
1:      * @param autoGeneratedKeys - a constant indicating whether
1:      * auto-generated keys should be made available for retrieval using
1:      * the method getGeneratedKeys; one of the following constants:
1:      * Statement.RETURN_GENERATED_KEYS or Statement.NO_GENERATED_KEYS
1:      * @return rue if the first result is a ResultSet object; false if
1:      * it is an update count or there are no results
1:      * @exception SQLException if a database access error occurs
1:      */
1: 	public boolean execute(String sql, int autoGeneratedKeys) throws SQLException
1: 	{
1: 		return execute(sql, false, false, autoGeneratedKeys, null, null);
1: 	}
1: 
1:     /**
1:      * JDBC 3.0
1:      *
1:      * Executes the given SQL statement, which may return multiple
1:      * results, and signals the driver that the auto-generated keys
1:      * indicated in the given array should be made available for retrieval.
1:      * This array contains the indexes of the columns in the target table
1:      * that contain the auto-generated keys that should be made available.
1:      * The driver will ignore the array if the given SQL statement is not an
0:      * INSERT statement.
1:      *
1:      * @param sql any SQL statement
1:      * @param columnIndexes - an array of the indexes of the columns in the
0:      * inserted row that should be made available for retrieval by a call to
0:      * the method getGeneratedKeys
1:      * @return rue if the first result is a ResultSet object; false if
1:      * it is an update count or there are no results
1:      * @exception SQLException if a database access error occurs
1:      */
1: 	public boolean execute(String sql, int[] columnIndexes) throws SQLException
1: 	{
0:  		throw Util.notImplemented("execute(String, int[])");
1: 	}
1: 
1:     /**
1:      * JDBC 3.0
1:      *
1:      * Executes the given SQL statement, which may return multiple
1:      * results, and signals the driver that the auto-generated keys
1:      * indicated in the given array should be made available for retrieval.
1:      * This array contains the names of the columns in the target table
1:      * that contain the auto-generated keys that should be made available.
1:      * The driver will ignore the array if the given SQL statement is not an
0:      * INSERT statement.
1:      *
1:      * @param sql any SQL statement
1:      * @param columnNames - an array of the names of the columns in the
0:      * inserted row that should be made available for retrieval by a call to
0:      * the method getGeneratedKeys
1:      * @return rue if the first result is a ResultSet object; false if
1:      * it is an update count or there are no results
1:      * @exception SQLException if a database access error occurs
1:      */
1: 	public boolean execute(String sql, String[] columnNames) throws SQLException
1: 	{
0:  		throw Util.notImplemented("execute(String, String[])");
1: 	}
1: 
1:     /**
1:      *  getResultSet returns the current result as a ResultSet.  It
1:      *  should only be called once per result.
1:      *
1:      * @return the current result as a ResultSet; null if the result
1:      * is an update count or there are no more results or the statement
1: 	 * was closed.
1:      * @see #execute
1:      */
1: 	public final java.sql.ResultSet getResultSet() throws SQLException  {
1: 		checkStatus();
1: 
1: 		return results;
1: 	}
1: 
1:     /**
1:      *  getUpdateCount returns the current result as an update count;
1:      *  if the result is a ResultSet or there are no more results -1
1:      *  is returned.  It should only be called once per result.
1:      *
1:      * <P>The only way to tell for sure that the result is an update
1:      *  count is to first test to see if it is a ResultSet. If it is
1:      *  not a ResultSet it is either an update count or there are no
1:      *  more results.
1:      *
1:      * @return the current result as an update count; -1 if it is a
1:      * ResultSet or there are no more results
1:      * @see #execute
1:      */
1: 	public final int getUpdateCount()	throws SQLException  {
1: 		checkStatus();
1: 		return updateCount;
1: 	}
1: 
1:     /**
1:      * getMoreResults moves to a Statement's next result.  It returns true if
1:      * this result is a ResultSet.  getMoreResults also implicitly
1:      * closes any current ResultSet obtained with getResultSet.
1:      *
0:      * There are no more results when (!getMoreResults() &&
1:      * (getUpdateCount() == -1)
1:      *
1:      * @return true if the next result is a ResultSet; false if it is
1:      * an update count or there are no more results
1:      * @see #execute
1: 	 * @exception SQLException thrown on failure.
1:      */
1: 	public final boolean getMoreResults() throws SQLException	{
0: 		return getMoreResults(JDBC30Translation.CLOSE_ALL_RESULTS);
1: 	}
1: 
1: 	/////////////////////////////////////////////////////////////////////////
1: 	//
1: 	//	JDBC 2.0 methods that are implemented here because EmbedPreparedStatement
1: 	//  and EmbedCallableStatement in Local20 need access to them, and those
1: 	//	classes extend their peer classes in Local, instead of EmbedStatement
1: 	//	in Local20
1: 	//
1: 	//  We do the same of JDBC 3.0 methods.
1: 	/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * JDBC 2.0
1:      *
1:      * Determine the result set type.
1:      *
1:      * @exception SQLException Feature not implemented for now.
1:      */
1:     public final int getResultSetType()
1: 		throws SQLException 
1: 	{
1: 		checkStatus();
1: 		return resultSetType;
1: 	}
1: 
1: 
1:     /**
1:      * JDBC 2.0
1:      *
1:      * Give a hint as to the direction in which the rows in a result set
1:      * will be processed. The hint applies only to result sets created
1:      * using this Statement object.  The default value is 
1:      * ResultSet.FETCH_FORWARD.
1:      *
1:      * @param direction the initial direction for processing rows
1:      * @exception SQLException if a database-access error occurs or direction
1:      * is not one of ResultSet.FETCH_FORWARD, ResultSet.FETCH_REVERSE, or
1:      * ResultSet.FETCH_UNKNOWN
1:      */
1:     public void setFetchDirection(int direction) throws SQLException {
1: 		
1: 		checkStatus();
1:                 /* fetch direction is meaningless to us. we just save
1:                  * it off if it is valid  and return the current value if asked.
1:                  */
0:                 if (direction == JDBC20Translation.FETCH_FORWARD || 
0:                     direction == JDBC20Translation.FETCH_REVERSE ||
0:                     direction == JDBC20Translation.FETCH_UNKNOWN )
1:                 {
1:                     fetchDirection = direction;
1:                 }else
0:                     throw newSQLException(SQLState.INVALID_FETCH_DIRECTION, 
0:                                    new Integer(direction));
1: 	}
1: 
1:     /**
1:      * JDBC 2.0
1:      *
1:      * Determine the fetch direction.
1:      *
1:      * @return the default fetch direction
1:      * @exception SQLException if a database-access error occurs
1:      */
1:     public int getFetchDirection() throws SQLException {
1: 		checkStatus();
1: 		return fetchDirection;
1: 	}
1: 
1: 
1:     /**
1:      * JDBC 2.0
1:      *
1:      * Give the JDBC driver a hint as to the number of rows that should
1:      * be fetched from the database when more rows are needed.  The number 
1:      * of rows specified only affects result sets created using this 
1:      * statement. If the value specified is zero, then the hint is ignored.
1:      * The default value is zero.
1:      *
1:      * @param rows the number of rows to fetch
1:      * @exception SQLException if a database-access error occurs, or the
0:      * condition 0 <= rows <= this.getMaxRows() is not satisfied.
1:      */
1:     public void setFetchSize(int rows) throws SQLException {
1: 		checkStatus();
1:         if (rows < 0  || (this.getMaxRows() != 0 && 
1:                              rows > this.getMaxRows()))
1:         {
0: 	        throw newSQLException(SQLState.INVALID_ST_FETCH_SIZE, new Integer(rows));
1:         }else if ( rows > 0 ) // ignore the call if the value is zero
1:             fetchSize = rows;
1: 	}
1:   
1:     /**
1:      * JDBC 2.0
1:      *
1:      * Determine the default fetch size.
1:      * @exception SQLException if a database-access error occurs
1:      *
1:      */
1:     public int getFetchSize() throws SQLException {
1: 		checkStatus();
1: 		return fetchSize;
1: 	}
1: 
1:     /**
1:      * JDBC 2.0
1:      *
1:      * Determine the result set concurrency.
1:      *
1:      * @exception SQLException Feature not implemented for now.
1:      */
1:     public int getResultSetConcurrency() throws SQLException {
1: 		checkStatus();
1: 		return resultSetConcurrency;
1: 	}
1: 
1:     /**
1:      * JDBC 3.0
1:      *
1:      * Retrieves the result set holdability for ResultSet objects
1:      * generated by this Statement object.
1:      *
1:      * @return either ResultSet.HOLD_CURSORS_OVER_COMMIT or
1:      * ResultSet.CLOSE_CURSORS_AT_COMMIT
1:      * @exception SQLException Feature not implemented for now.
1:      */
0:     public int getResultSetHoldability() throws SQLException {
1: 		checkStatus();
1: 		return resultSetHoldability;
1: 	}
1: 
1:     /**
1:      * JDBC 2.0
1:      *
1:      * Adds a SQL command to the current batch of commmands for the statement.
1:      * This method is optional.
1:      *
1:      * @param sql typically this is a static SQL INSERT or UPDATE statement
1:      * @exception SQLException if a database-access error occurs, or the
1:      * driver does not support batch statements
1:      */
1:     public void addBatch( String sql ) throws SQLException {
1: 		checkStatus();
1:   	  synchronized (getConnectionSynchronization()) {
1: 		  if (batchStatements == null)
0: 			  batchStatements = new Vector();
0:         batchStatements.addElement(sql);
1:   		}
1: 	}
1: 
1:     /**
1:      * JDBC 2.0
1:      *
1:      * Make the set of commands in the current batch empty.
1:      * This method is optional.
1:      *
1:      * @exception SQLException if a database-access error occurs, or the
1:      * driver does not support batch statements
1:      */
1:     public final void clearBatch() throws SQLException {
1: 		checkStatus();
1:   	  synchronized (getConnectionSynchronization()) {
1:         batchStatements = null;
1:   		}
1: 	}
1: 
1:     /**
1:      * JDBC 2.0
1:      * 
1:      * Submit a batch of commands to the database for execution.
1:      * This method is optional.
1: 	 *
1: 	 * Moving jdbc2.0 batch related code in this class because
1: 	 * callableStatement in jdbc 20 needs this code too and it doesn't derive
1: 	 * from prepared statement in jdbc 20 in our implementation. 
1: 	 * BatchUpdateException is the only new class from jdbc 20 which is being
1: 	 * referenced here and in order to avoid any jdk11x problems, using
1: 	 * reflection code to make an instance of that class. 
1:      *
1:      * @return an array of update counts containing one element for each
1:      * command in the batch.  The array is ordered according
1:      * to the order in which commands were inserted into the batch
1:      * @exception SQLException if a database-access error occurs, or the
1:      * driver does not support batch statements
1:      */
1:     public int[] executeBatch() throws SQLException {
1: 		checkExecStatus();
1: 		synchronized (getConnectionSynchronization()) 
1: 		{
0:                         setupContextStack();
1: 			int i = 0;
1: 			// As per the jdbc 2.0 specs, close the statement object's current resultset
1: 			// if one is open.
1: 			// Are there results?
1: 			// outside of the lower try/finally since results will
1: 			// setup and restore themselves.
1: 			clearResultSets();
1: 
0: 			Vector stmts = batchStatements;
1: 			batchStatements = null;
1: 			int size;
1: 			if (stmts == null)
1: 				size = 0;
1: 			else
1: 				size = stmts.size();
1: 
0: 			int[] returnUpdateCountForBatch = new int[size];
1: 
1: 			SQLException sqle;
1: 			try {
1: 				for (; i< size; i++) 
1: 				{
0: 					if (executeBatchElement(stmts.elementAt(i)))
1: 						throw newSQLException(SQLState.RESULTSET_RETURN_NOT_ALLOWED);
0: 					returnUpdateCountForBatch[i] = getUpdateCount();
1: 				}
1: 				return returnUpdateCountForBatch;
1: 			}
1: 			catch (StandardException se) {
1: 
1: 				sqle = handleException(se);
1: 			}
1: 			catch (SQLException sqle2) 
1: 			{
1: 				sqle = sqle2;
1: 			}
1: 			finally 
1: 			{
1: 				restoreContextStack();
1: 			}
1: 
0: 			int successfulUpdateCount[] = new int[i];
0: 			for (int j=0; j<i; j++)
1: 			{
0: 				successfulUpdateCount[j] = returnUpdateCountForBatch[j];
1: 			}
1: 
0: 			SQLException batch =
0: 			new java.sql.BatchUpdateException(sqle.getMessage(), sqle.getSQLState(),
0: 									sqle.getErrorCode(), successfulUpdateCount);
1: 
0: 			batch.setNextException(sqle);
0: 			throw batch;
1:       }
1: 	}
1: 
1: 	/**
1: 		Execute a single element of the batch. Overridden by EmbedPreparedStatement
1: 	*/
0: 	protected boolean executeBatchElement(Object batchElement) throws SQLException, StandardException {
0: 		return execute((String)batchElement, false, true, JDBC30Translation.NO_GENERATED_KEYS, null, null);
1: 	}
1: 
1:     /**
1:      * JDBC 2.0
1:      *
1:      * Return the Connection that produced the Statement.
1:      *
1:      * @exception SQLException Exception if it cannot find the connection
1:      * associated to this statement.
1:      */
1:     public final java.sql.Connection getConnection()  throws SQLException {
1: 		checkStatus();
1: 
1:     	java.sql.Connection appConn = getEmbedConnection().getApplicationConnection();
0: 		if ((appConn != applicationConnection) || (appConn == null))
1: 			throw Util.noCurrentConnection();
1: 		return appConn;
1:     }
1: 
1:     /**
1:      * JDBC 3.0
1:      *
1:      * Moves to this Statement obect's next result, deals with any current ResultSet
1:      * object(s) according to the instructions specified by the given flag, and
1:      * returns true if the next result is a ResultSet object
1:      *
1:      * @param current - one of the following Statement constants indicating what
1:      * should happen to current ResultSet objects obtained using the method
1:      * getResultSetCLOSE_CURRENT_RESULT, KEEP_CURRENT_RESULT, or CLOSE_ALL_RESULTS
1:      * @return true if the next result is a ResultSet; false if it is
1:      * an update count or there are no more results
1:      * @see #execute
1:      * @exception SQLException thrown on failure.
1:      */
1: 	public final boolean getMoreResults(int current) throws SQLException	{
1: 		checkExecStatus();
1: 
1: 		synchronized (getConnectionSynchronization()) {
1: 			if (dynamicResults == null) {
1: 				// we only have the one resultset, so this is
1: 				// simply a close for us.
1: 				clearResultSets();
1: 				return false;
1: 			}
1: 
1: 			int startingClose;
1: 			switch (current) {
1: 			default:
0: 			case JDBC30Translation.CLOSE_ALL_RESULTS:
1: 				startingClose = 0;
1: 				break;
0: 			case JDBC30Translation.CLOSE_CURRENT_RESULT:
1: 				// just close the current result set.
1: 				startingClose = currentDynamicResultSet;
1: 				break;
0: 			case JDBC30Translation.KEEP_CURRENT_RESULT:
1: 				// make the close loop a no-op.
1: 				startingClose = dynamicResults.length;
1: 				break;
1: 			}
1: 
1: 			// Close loop.
1: 			SQLException se = null;
1: 			for (int i = startingClose; i <= currentDynamicResultSet && i < dynamicResults.length; i++) {
1: 				EmbedResultSet lrs = dynamicResults[i];
1: 				if (lrs == null)
1: 					continue;
1: 
1: 
1: 				try {
0: 					if (!lrs.isClosed)
0: 						lrs.close();
1: 				} catch (SQLException sqle) {
1: 					if (se == null)
1: 						se = sqle;
1: 					else
1: 						se.setNextException(sqle);
1: 				} finally {
1: 					dynamicResults[i] = null;
1: 				}
1: 			}
1: 
1: 			if (se != null) {
1: 				// leave positioned on the current result set (?)
1: 				throw se;
1: 			}
1: 
0: 			updateCount = -1;
1: 
1: 			while (++currentDynamicResultSet < dynamicResults.length) {
1: 
1: 				EmbedResultSet lrs = dynamicResults[currentDynamicResultSet];
1: 				if (lrs != null) {
1: 					if (lrs.isClosed) {
1: 						dynamicResults[currentDynamicResultSet] = null;
1: 						continue;
1: 					}
1: 
1: 					results = lrs;
1: 
0: 					return true;
1: 				}
1: 			}
1: 
1: 			results = null;
1: 			return false;
1: 		}
1: 	}
1: 
1:     /**
1:      * JDBC 3.0
1:      *
1:      * Retrieves any auto-generated keys created as a result of executing this
1:      * Statement object. If this Statement is a non-insert statement,
1:      * a null ResultSet object is returned.
1:      *
1:      * @return a ResultSet object containing the auto-generated key(s) generated by
1:      * the execution of this Statement object
1:      * @exception SQLException if a database access error occurs
1:      */
1: 	public final java.sql.ResultSet getGeneratedKeys() throws SQLException	{
1: 		if (autoGeneratedKeysResultSet == null)
0: 			return null;
1: 		else {
0: 			execute("VALUES IDENTITY_VAL_LOCAL()", true, false, JDBC30Translation.NO_GENERATED_KEYS, null, null);
1: 			return results;
1: 		}
1: 	}
1: 
1: 	/////////////////////////////////////////////////////////////////////////
1: 	//
1: 	//	Implementation specific methods	
1: 	//
1: 	/////////////////////////////////////////////////////////////////////////
1: 
1: 	/**
1: 		Execute the current statement.
1: 	    @exception SQLException thrown on failure.
1: 	*/
0: 	protected boolean executeStatement(Activation a,
1:                      boolean executeQuery, boolean executeUpdate)
1:                      throws SQLException {
1: 
1: 		// we don't differentiate the update from the resultset case.
1: 		// so, there could be a result set.
1: 
1: 		// note: the statement interface will paste together
1: 		// an activation and make sure the prepared statement
1: 		// is still valid, so it is preferrable, for now,
1: 		// to creating our own activation and stuffing it in
1: 		// the prepared statement.
1: 
1: 		synchronized (getConnectionSynchronization()) {
1:                         setupContextStack(); // make sure there's context
1: 			boolean retval;
1: 
1: 			pvs = a.getParameterValueSet();
1: 
1: 			try {
0: 				// The following is from the javadoc for java.sql.Statement
0: 				// Only one ResultSet per Statement can be open at any point in time.
0: 				// Therefore, if the reading of one ResultSet is interleaved with the
0: 				// reading of another, each must have been generated by different Statements.
0: 				// All statement execute methods implicitly close a
0: 				// statment's current ResultSet if an open one exists. 
1: 				if (results != null) {
1: 					results.close();
1: 					results = null;
1: 				}
1: 
1: 				clearWarnings();
1: 
1: 				if (! forMetaData) {
1: 					commitIfNeeded(); // commit the last statement if needed
1: 					needCommit();
1: 				} else {
1: 
1: 
1: 		        	if (lcc.getActivationCount() > 1) {
1: 		     		  // we do not want to commit here as there seems to be other
1: 					  // statements/resultSets currently opened for this connection.
1: 					} else {
1: 						commitIfNeeded(); // we can legitimately commit
1: 						needCommit();
1: 					}
1: 				}
1: 
0: 				// if this was a prepared statement, this just
0: 				// gets it for us, it won't recompile unless it is invalid.
1: 				PreparedStatement ps = a.getPreparedStatement();
0: 				ps.rePrepare(lcc);
0: 				getWarnings(ps.getCompileTimeWarnings());
1: 
1: 
1: 				/*
1: 				** WARNING WARNING
1: 				**
1: 				** Any state set in the activation before execution *must* be copied
1: 				** to the new activation in GenericActivationHolder.execute() when
1: 				** the statement has been recompiled. State such as
1: 				** singleExecution, cursorName, holdability, maxRows.
1: 				*/
1: 
1: 				if (cursorName != null)
1: 				{
1: 					a.setCursorName(cursorName);
1: 				}
0: 				a.setResultSetHoldability(resultSetHoldability != JDBC30Translation.CLOSE_CURSORS_AT_COMMIT);
1: 
1: 				//reset the activation to clear warnings
1: 				//and clear existing result sets in case this has been cached
1: 				a.reset();
1: 				a.setMaxRows(maxRows);
0: 				ResultSet resultsToWrap = ps.execute(a, executeQuery, executeUpdate, false);
0: 				getWarnings(a.getWarnings());
1: 
1: 
1: 				if (resultsToWrap.returnsRows()) {
1: 					EmbedResultSet lresults = factory.newEmbedResultSet(getEmbedConnection(), resultsToWrap, forMetaData, this, ps.isAtomic());
1: 					results = lresults;
1: 
1: 
1: 					// Set up the finalization of the ResultSet to
1: 					// mark the activation as unused. It will be
1: 					// closed sometime later by the connection
1: 					// outside of finalization.
1: 					if (a.isSingleExecution())
0: 						lresults.finalizeActivation = a;
1: 
0: 					updateCount = -1;
1: 					retval = true;
1: 				}
1: 				else {
1: 
0: 					// Only applipable for an insert statement, which does not return rows.
0: 					//the auto-generated keys resultset will be null if used for non-insert statement
1: 					if (a.getAutoGeneratedKeysResultsetMode() && (resultsToWrap.getAutoGeneratedKeysResultset() != null))
1: 					{
1: 						resultsToWrap.getAutoGeneratedKeysResultset().open();
1: 						autoGeneratedKeysResultSet = factory.newEmbedResultSet(getEmbedConnection(),
1: 							resultsToWrap.getAutoGeneratedKeysResultset(), false, this, ps.isAtomic());
1: 					}
1: 
1: 					updateCount = resultsToWrap.modifiedRowCount();
1: 
0: 					resultsToWrap.finish();	// Don't need the result set any more
1: 					results = null; // note that we have none.
1: 
0: 					boolean haveDynamicResults = false;
1: 					if (a.getDynamicResults() != null) {
0: 						haveDynamicResults = processDynamicResults(a.getDynamicResults(), a.getMaxDynamicResults());
1: 					}
1: 					
0: 					if (!haveDynamicResults) {
1: 						if (a.isSingleExecution()) {
1: 							a.close();
1: 						}
1: 
1: 						if (!forMetaData)
1: 							commitIfNeeded();
1: 						else {
1: 
1: 							if (lcc.getActivationCount() > 1) {
1: 							  // we do not want to commit here as there seems to be other
1: 							  // statements/resultSets currently opened for this connection.
1: 							} else {
1: 								commitIfNeeded(); // we can legitimately commit
1: 							}
1: 						}
1: 					}
1: 
0: 					retval = haveDynamicResults;
1: 				}
1: 	        } catch (Throwable t) {
1: 				if (a.isSingleExecution()) {
1: 					try { a.close(); } catch (Throwable tt) {;}
1: 				}
1: 		        throw handleException(t);
1: 			} finally {
1: 			    restoreContextStack();
1: 			}
1: 			return retval;
1: 		}
1: 	}
1: 
0: 	protected void getWarnings(SQLWarning sw)
1: 	{
1: 		if (sw != null) {
1: 			if (warnings == null)
1: 				warnings = sw;
1: 			else
1: 				warnings.setNextException(sw);
1: 		}
1: 	}
1: 
1: 
1: 	/* package */
1: 	public String getSQLText()
1: 	{
1: 		// no need to synchronize - accessing a reference is atomic
1: 		// synchronized (getConnectionSynchronization()) 
1: 		return SQLText;
1: 	}
1: 
1: 	public ParameterValueSet getParameterValueSet()
1: 	{
1: 		return pvs;
1: 	}
1: 
0: 	//check the status of this statement, if it has already been closed,
0:     //we throw an exception, need to be called by every public method
0:     protected final void checkStatus() throws SQLException {
1: 
1: 		if (!active)
1: 			throw newSQLException(SQLState.ALREADY_CLOSED, "Statement");
1: 	}
1: 
1: 	/**
1: 		A heavier weight version of checkStatus() that ensures the application's Connection
1: 		object is still open. This is to stop errors or unexpected behaviour when a [Prepared]Statement
1: 		object is used after the application has been closed. In particular to ensure that
1: 		a Statement obtained from a PooledConnection cannot be used after the application has closed
1: 		its connection (as the underlying Connection is still active).
1: 		To avoid this heavier weight check on every method of [Prepared]Statement it is only used
1: 		on those methods that would end up using the database's connection to read or modify data.
1: 		E.g. execute*(), but not setXXX, etc.
1: 	*/
0: 	protected final void checkExecStatus() throws SQLException {
1: 		// getConnection() checks if the Statement is closed
1: 		if (!getConnection().isClosed())
1: 			return;
1: 	
1: 		throw Util.noCurrentConnection();
1: 	}
1: 
1: 	/**
1: 		Close and clear all result sets associated with this statement
1: 		from the last execution.
1: 	*/
0: 	protected void clearResultSets() throws SQLException {
1: 
1: 		SQLException sqle = null;
1: 
1: 		try {
1: 			// Are there results?
1: 			// outside of the lower try/finally since results will
1: 			// setup and restore themselves.
1: 			if (results != null) {
1: 				results.close();
1: 				results = null;
1: 			}
1: 		} catch (SQLException s1) {
1: 			sqle = s1;
1: 		}
1: 
1: 		try {
1: 			if (autoGeneratedKeysResultSet != null) {
1: 				autoGeneratedKeysResultSet.close();
1: 				autoGeneratedKeysResultSet = null;
1: 			}
1: 		} catch (SQLException sauto) {
1: 			if (sqle == null)
1: 				sqle = sauto;
1: 			else
1: 				sqle.setNextException(sauto);
1: 		}
1: 
1: 		// close all the dynamic result sets.
1: 		if (dynamicResults != null) {
1: 			for (int i = 0; i < dynamicResults.length; i++) {
1: 				EmbedResultSet lrs = dynamicResults[i];
1: 				if (lrs == null)
1: 					continue;
1: 
1: 				try {
0: 					if (!lrs.isClosed)
0: 						lrs.close();
1: 				} catch (SQLException sdynamic) {
1: 					if (sqle == null)
1: 						sqle = sdynamic;
1: 					else
1: 						sqle.setNextException(sdynamic);
1: 				}
1: 			}
1: 			dynamicResults = null;
1: 		}
1: 
1: 		/*
1: 			  We don't reset statement to null because PreparedStatement
1: 			  relies on it being there for subsequent (post-close) execution
1: 			  requests.  There is no close method on database statement objects.
1: 		*/
1: 
0: 		updateCount = -1; // reset field
1: 
1: 		if (sqle != null)
1: 			throw sqle;
1: 	 }  
1: 	
1: 	/**
1: 		Check to see if a statement requires to be executed via a callable statement.
1: 	*/
0: 	protected void checkRequiresCallableStatement(Activation activation) throws SQLException {
1: 
1: 		ParameterValueSet pvs = activation.getParameterValueSet();
1: 
1: 		if (pvs == null)
1: 			return;
1: 
1: 		if (pvs.checkNoDeclaredOutputParameters()) {
1: 			try {
1: 				activation.close();
1: 			} catch (StandardException se) {
1: 			}
1: 			throw newSQLException(SQLState.REQUIRES_CALLABLE_STATEMENT, SQLText);
1: 		}
1: 	}
1: 
1: 	/**
1: 		Transfer my batch of Statements to a newly created Statement.
1: 	*/
1: 	public void transferBatch(EmbedStatement other) throws SQLException {
1: 		
1: 		synchronized (getConnectionSynchronization()) {
1: 			other.batchStatements = batchStatements;
1: 			batchStatements = null;
1: 		}
1: 	}
1: 
1: 
1: 	private EmbedResultSet[] dynamicResults;
1: 	private int currentDynamicResultSet;
0: 	private boolean processDynamicResults(java.sql.ResultSet[][] holder, int maxDynamicResultSets) throws SQLException {
1: 
1: 		EmbedResultSet[] sorted = new EmbedResultSet[holder.length];
1: 
1: 		int actualCount = 0;
1: 		for (int i = 0; i < holder.length; i++) {
1: 
1: 			java.sql.ResultSet[] param = holder[i];
1: 
0: 			if (param[0] == null)
1: 				continue;
1: 
1: 			java.sql.ResultSet rs = param[0];
1: 			param[0] = null;
1: 
0: 			// ignore non-cloudscape result sets or results sets from another connection
0: 			if (!(rs instanceof EmbedResultSet))
1: 				continue;
1: 
0: 			EmbedResultSet lrs = (EmbedResultSet) rs;
1: 
0: 			if (lrs.getEmbedConnection().rootConnection != getEmbedConnection().rootConnection)
1: 				continue;
1: 
0: 			// ignore closed result sets.
0: 			if (lrs.isClosed)
1: 				continue;
1: 
0: 			lrs.setDynamicResultSet(this);
1: 			sorted[actualCount++] = lrs;
1: 		}
1: 
1: 		if (actualCount != 0) {
1: 
1: 			// results are defined to be ordered according to their creation
1: 			if (actualCount != 1) {
1: 				java.util.Arrays.sort(sorted, 0, actualCount);
1: 			}
1: 
1: 			dynamicResults = sorted;
1: 
1: 			if (actualCount > maxDynamicResultSets) {
0: 				getWarnings(StandardException.newWarning(SQLState.LANG_TOO_MANY_DYNAMIC_RESULTS_RETURNED));
1: 
1: 				for (int i = maxDynamicResultSets; i < actualCount; i++) {
1: 					sorted[i].close();
1: 					sorted[i] = null;
1: 				}
1: 
1: 				actualCount = maxDynamicResultSets;
1: 			}
1: 
1: 
0: 			updateCount = -1;
1: 			results = sorted[0];
1: 			currentDynamicResultSet = 0;
1: 
1: 			// 0100C is not returned for procedures written in Java, from the SQL2003 spec.
1: 			// getWarnings(StandardException.newWarning(SQLState.LANG_DYNAMIC_RESULTS_RETURNED));
1: 
0: 			return true;
1: 		}
1: 
1: 
1: 		return false;
1: 	}
1: 
1: 	/**
1: 		Callback on the statement when one of its result sets is closed.
1: 		This allows the statement to control when it completes and hence
1: 		when it commits in auto commit mode.
1: 
1:         Must have connection synchronization and setupContextStack(), this
1:         is required for the call to commitIfNeeded().
1: 	*/
1: 	void resultSetClosing(EmbedResultSet closingLRS) throws SQLException {
1: 
1: 		// If the Connection is not in auto commit then this statement completion
1: 		// cannot cause a commit.
1: 		if (!getEmbedConnection().autoCommit)
1: 			return;
1: 
1: 		// If we have dynamic results, see if there is another result set open.
1: 		// If so, then no commit. The last result set to close will close the statement.
1: 		if (dynamicResults != null) {
1: 			for (int i = 0; i < dynamicResults.length; i++) {
1: 				EmbedResultSet lrs = dynamicResults[i];
1: 				if (lrs == null)
1: 					continue;
0: 				if (lrs.isClosed)
1: 					continue;
1: 				if (lrs == closingLRS)
1: 					continue;
1: 
1: 				// at least one still open so no commit now.
1: 				return;
1: 			}
1: 		}
1: 
1: 		// new Throwable("COMMIT ON " + SQLText).printStackTrace(System.out);
1: 
1:         // beetle 5383.  Force a commit in autocommit always.  Before this
1:         // change if client in autocommit opened a result set, did a commit,
1:         // then next then close a commit would not be forced on the close.
1: 		commitIfAutoCommit();
1: 	}
1: 
1: }
1: 
author:Army
-------------------------------------------------------------------------------
commit:e3bd4bb
/////////////////////////////////////////////////////////////////////////
1: 		execute(sql, false, true,
1: 			((columnIndexes == null) || (columnIndexes.length == 0))
0: 				? JDBC30Translation.NO_GENERATED_KEYS
0: 				: JDBC30Translation.RETURN_GENERATED_KEYS,
1: 			columnIndexes,
1: 			null);
1: 		return updateCount;
/////////////////////////////////////////////////////////////////////////
1: 		execute(sql, false, true,
1: 			((columnNames == null) || (columnNames.length == 0))
0: 				? JDBC30Translation.NO_GENERATED_KEYS
0: 				: JDBC30Translation.RETURN_GENERATED_KEYS,
1: 			null,
1: 			columnNames);
0: 		return updateCount;
/////////////////////////////////////////////////////////////////////////
1: 		return execute(sql, false, true,
1: 			((columnIndexes == null) || (columnIndexes.length == 0))
0: 				? JDBC30Translation.NO_GENERATED_KEYS
0: 				: JDBC30Translation.RETURN_GENERATED_KEYS,
1: 			columnIndexes,
1: 			null);
/////////////////////////////////////////////////////////////////////////
1: 		return execute(sql, false, true,
1: 			((columnNames == null) || (columnNames.length == 0))
0: 				? JDBC30Translation.NO_GENERATED_KEYS
0: 				: JDBC30Translation.RETURN_GENERATED_KEYS,
1: 			null,
1: 			columnNames);
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:94f158a
/////////////////////////////////////////////////////////////////////////
0: 			// ignore non-Derby result sets or results sets from another connection
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:David Van Couvering
-------------------------------------------------------------------------------
commit:0568a6c
/////////////////////////////////////////////////////////////////////////
1: 		if (!active) {
1:             // 
1:             // Check the status of the connection first
1:             //
1:             java.sql.Connection appConn = getEmbedConnection().getApplicationConnection();
1:             if (appConn == null || appConn.isClosed()) {
1:                 throw Util.noCurrentConnection();
1:             }
0:             throw newSQLException(SQLState.ALREADY_CLOSED, "Statement");
1:         }
commit:64e1768
/////////////////////////////////////////////////////////////////////////
1:      * Tell whether this statment has been closed or not.
0:      *
1:      * @return <code>true</code> is closed, <code>false</code> otherwise.
1:      * @exception SQLException if a database access error occurs.
0:      */
1:     public boolean isClosed() throws SQLException {
1:         // If active, verify state by consulting parent connection.
1:         if (active) {
1:             try {
1:                 checkExecStatus();
1:             } catch (SQLException sqle) {
0:             }
0:         }
1:         return !active;
0:     }
0: 
0:     /**
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:2dc0b91
/////////////////////////////////////////////////////////////////////////
0: 				    (lcc.getDefaultSchema(), sql, resultSetConcurrency==JDBC20Translation.CONCUR_READ_ONLY, false);
author:Bernt Johnsen
-------------------------------------------------------------------------------
commit:5087be8
/////////////////////////////////////////////////////////////////////////
1: 				PreparedStatement preparedStatement = lcc.prepareInternalStatement
0: 				    (lcc.getDefaultSchema(), sql, resultSetConcurrency==JDBC20Translation.CONCUR_READ_ONLY);
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
commit:1373f5a
/////////////////////////////////////////////////////////////////////////
0:                 ResultSet resultsToWrap = ps.execute(a,
0:                                                      executeQuery,
0:                                                      executeUpdate,
0:                                                      false,
0:                                                      timeoutMillis);
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.jdbc
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.jdbc;
0: 
0: import org.apache.derby.iapi.reference.JDBC20Translation;
0: import org.apache.derby.iapi.reference.JDBC30Translation;
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.sql.Activation;
0: import org.apache.derby.iapi.sql.PreparedStatement;
0: import org.apache.derby.iapi.sql.ResultSet;
0: import org.apache.derby.iapi.sql.ParameterValueSet;
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import java.sql.SQLException;
0: import java.sql.SQLWarning;
0: import java.util.Vector;
0: 
0: /*
0:  We would import these, but have name-overlap
0: import java.sql.Statement;
0: import java.sql.ResultSet;
0: */
0: 
0: /**
0:  *
0:  * EmbedStatement is a local JDBC statement.
0:  *
0:  * @author ames
0:  */
0: public class EmbedStatement extends ConnectionChild
0:     implements java.sql.Statement { 
0: 
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 
0: 	private final java.sql.Connection applicationConnection;
0: 
0: 	protected int updateCount = -1;
0: 	protected java.sql.ResultSet results;
0: 	//for jdbc3.0 feature, where you can get a resultset of rows inserted
0: 	//for auto generated columns after an insert
0: 	private java.sql.ResultSet autoGeneratedKeysResultSet;
0: 	protected String cursorName;
0: 
0: 	protected final boolean forMetaData;
0: 	public final int resultSetType;
0: 	protected final int resultSetConcurrency;
0: 	protected final int resultSetHoldability;
0: 	protected final LanguageConnectionContext lcc;
0: 
0: 	private SQLWarning warnings;
0: 	protected String SQLText;
0: 
0:     private int fetchSize = 1;
0:     private int fetchDirection = JDBC20Translation.FETCH_FORWARD;
0:     int MaxFieldSize;
0: 
0: 	//the state of this statement, set to false when close() is called
0: 	protected boolean active = true;
0: 
0:     //in case of batch update, save the individual statements in the batch in this vector
0:  	//this is only used by JDBC 2.0
0:  	protected Vector batchStatements;
0: 	
0: 	// The maximum # of rows to return per result set.
0: 	// (0 means no limit.)
0: 	int maxRows;
0: 
0: 	private ParameterValueSet pvs;
0: 
0: 	//
0: 	// constructor
0: 	//
0: 	public EmbedStatement (EmbedConnection connection, boolean forMetaData,
0: 							  int resultSetType, int resultSetConcurrency, int resultSetHoldability)
0: 	{
0: 	    super(connection);
0: 		this.forMetaData = forMetaData;
0: 		this.resultSetType = resultSetType;
0: 		this.resultSetConcurrency = resultSetConcurrency;
0: 		this.resultSetHoldability = resultSetHoldability;
0: 
0: 		lcc = getEmbedConnection().getLanguageConnection();
0: 		applicationConnection = getEmbedConnection().getApplicationConnection();
0: 	}
0: 
0: 	//
0: 	// java.sql.Statement interface
0: 	// the comments are those from the JDBC interface,
0: 	// so we know what we're supposed to to.
0: 
0: 	/**
0:      * Execute a SQL statement that returns a single ResultSet.
0:      *
0:      * @param sql					typically this is a static SQL SELECT statement
0: 	 * @return a ResultSet that contains the data produced by the
0:      * query; never null
0: 	 * @exception SQLException thrown on failure.
0:      */
0: 	public java.sql.ResultSet executeQuery(String sql)
0: 		throws SQLException
0: 	{
0: 		execute(sql, true, false, JDBC30Translation.NO_GENERATED_KEYS, null, null);
0: 
0: 		if (SanityManager.DEBUG) {
0: 			if (results == null)
0: 				SanityManager.THROWASSERT("no results returned on executeQuery()");
0: 		}
0: 
0: 		return results;
0: 	}
0: 
0:     /**
0:      * Execute a SQL INSERT, UPDATE or DELETE statement. In addition,
0:      * SQL statements that return nothing such as SQL DDL statements
0:      * can be executed.
0:      *
0:      * @param sql a SQL INSERT, UPDATE or DELETE statement or a SQL
0:      * statement that returns nothing
0:      * @return either the row count for INSERT, UPDATE or DELETE; or 0
0:      * for SQL statements that return nothing
0: 	 * @exception SQLException thrown on failure.
0:      */
0: 	public int executeUpdate(String sql) throws SQLException
0: 	{
0: 		execute(sql, false, true, JDBC30Translation.NO_GENERATED_KEYS, null, null);
0: 		return updateCount;
0: 	}
0: 
0:     /**
0:      * JDBC 3.0
0:      *
0:      * Execute the given SQL statement and signals the driver with the given flag
0:      * about whether the auto-generated keys produced by this Statement object
0:      * should be made available for retrieval.
0:      *
0:      * @param sql a SQL INSERT, UPDATE or DELETE statement or a SQL
0:      * statement that returns nothing
0:      * @param autoGeneratedKeys - a flag indicating whether auto-generated keys
0:      * should be made available for retrieval; one of the following constants:
0:      * Statement.RETURN_GENERATED_KEYS Statement.NO_GENERATED_KEYS
0:      * @return either the row count for INSERT, UPDATE or DELETE; or 0
0:      * for SQL statements that return nothing
0:      * @exception SQLException if a database access error occurs
0:      */
0: 	public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException
0: 	{
0: 		execute(sql, false, true, autoGeneratedKeys, null, null);
0: 		return updateCount;
0: 	}
0: 
0:     /**
0:      * JDBC 3.0
0:      *
0:      * Executes the given SQL statement and signals the driver that the
0:      * auto-generated keys indicated in the given array should be made
0:      * available for retrieval. The driver will ignore the array if the SQL
0:      * statement is not an INSERT statement
0:      *
0:      * @param sql a SQL INSERT, UPDATE or DELETE statement or a SQL
0:      * statement that returns nothing
0:      * @param columnIndexes - an array of column indexes indicating the
0:      * columns that should be returned from the inserted row
0:      * @return either the row count for INSERT, UPDATE or DELETE; or 0
0:      * for SQL statements that return nothing
0:      * @exception SQLException if a database access error occurs
0:      */
0: 	public int executeUpdate(String sql, int[] columnIndexes) throws SQLException
0: 	{
0:  		throw Util.notImplemented("executeUpdate(String, int[])");
0: 	}
0: 
0:     /**
0:      * JDBC 3.0
0:      *
0:      * Executes the given SQL statement and signals the driver that the
0:      * auto-generated keys indicated in the given array should be made
0:      * available for retrieval. The driver will ignore the array if the SQL
0:      * statement is not an INSERT statement
0:      *
0:      * @param sql a SQL INSERT, UPDATE or DELETE statement or a SQL
0:      * statement that returns nothing
0:      * @param columnNames - an array of the names of the columns
0:      * that should be returned from the inserted row
0:      * @return either the row count for INSERT, UPDATE or DELETE; or 0
0:      * for SQL statements that return nothing
0:      * @exception SQLException if a database access error occurs
0:      */
0: 	public int executeUpdate(String sql, String[] columnNames) throws SQLException
0: 	{
0:  		throw Util.notImplemented("executeUpdate(String, String[])");
0: 	}
0: 
0: 	protected final void checkIfInMiddleOfBatch() throws SQLException {
0: 		/* If batchStatements is not null then we are in the middle
0: 		 * of a batch. That's an invalid state. We need to finish the
0: 		 * batch either by clearing the batch or executing the batch.
0: 		 * executeUpdate is not allowed inside the batch.
0: 		 */
0: 		if (batchStatements != null)
0:   		throw newSQLException(SQLState.MIDDLE_OF_BATCH);
0: 	}
0: 
0:     /**
0:      * In many cases, it is desirable to immediately release a
0:      * Statements's database and JDBC resources instead of waiting for
0:      * this to happen when it is automatically closed; the close
0:      * method provides this immediate release.
0:      *
0:      * <P><B>Note:</B> A Statement is automatically closed when it is
0:      * garbage collected. When a Statement is closed its current
0:      * ResultSet, if one exists, is also closed.
0: 	 * @exception SQLException thrown on failure.
0:      */
0: 	public final void close() throws SQLException {
0: 
0: 		/* The close() method is the only method
0: 		 * that is allowed to be called on a closed
0: 		 * Statement, as per Jon Ellis.
0: 		 */
0: 		if (!active)
0: 		{
0: 			return;
0: 		}
0: 
0: 	  synchronized (getConnectionSynchronization()) {
0: 
0: 		  closeActions();
0: 		  
0: 		  //we first set the status
0: 		  active = false;
0: 
0: 		  //first, clear the resutl set
0: 		  clearResultSets();
0: 		  
0: 		  //next, release other resource
0: 		  cursorName = null;
0: 		  warnings = null;
0: 		  SQLText = null;
0: 		  batchStatements = null;
0: 	  }
0: 	}
0: 
0: 	// allow sub-classes to execute additional close
0: 	// logic while holding the synchronization.
0: 	protected void closeActions() throws SQLException {
0: 	}
0: 
0:     //----------------------------------------------------------------------
0: 
0:     /**
0:      * The maxFieldSize limit (in bytes) is the maximum amount of data
0:      * returned for any column value; it only applies to BINARY,
0:      * VARBINARY, LONGVARBINARY, CHAR, VARCHAR, and LONGVARCHAR
0:      * columns.  If the limit is exceeded, the excess data is silently
0:      * discarded.
0:      *
0:      * @return the current max column size limit; zero means unlimited
0: 	 * @exception SQLException thrown on failure.
0:      */
0: 	public int getMaxFieldSize() throws SQLException {
0: 		checkStatus();
0: 
0:         return MaxFieldSize;
0: 	}
0: 
0:     /**
0:      * The maxFieldSize limit (in bytes) is set to limit the size of
0:      * data that can be returned for any column value; it only applies
0:      * to BINARY, VARBINARY, LONGVARBINARY, CHAR, VARCHAR, and
0:      * LONGVARCHAR fields.  If the limit is exceeded, the excess data
0:      * is silently discarded.
0:      *
0:      * @param max the new max column size limit; zero means unlimited
0: 	 * @exception SQLException thrown on failure.
0:      */
0: 	public void setMaxFieldSize(int max) throws SQLException {
0: 		checkStatus();
0: 
0: 		if (max < 0)
0: 		{
0: 			throw newSQLException(SQLState.INVALID_MAXFIELD_SIZE, new Integer(max));
0: 		}
0:         this.MaxFieldSize = max;
0: 	}
0: 
0:     /**
0:      * The maxRows limit is the maximum number of rows that a
0:      * ResultSet can contain.  If the limit is exceeded, the excess
0:      * rows are silently dropped.
0:      *
0:      * @return the current max row limit; zero means unlimited
0: 	 * @exception SQLException thrown on failure.
0:      */
0: 	public int getMaxRows() throws SQLException 
0: 	{
0: 		checkStatus();
0: 		return maxRows;
0: 	}
0: 
0:     /**
0:      * The maxRows limit is set to limit the number of rows that any
0:      * ResultSet can contain.  If the limit is exceeded, the excess
0:      * rows are silently dropped.
0:      *
0:      * @param max the new max rows limit; zero means unlimited
0: 	 * @exception SQLException thrown on failure.
0:      */
0: 	public void setMaxRows(int max) throws SQLException	
0: 	{
0: 		checkStatus();
0: 		if (max < 0)
0: 		{
0: 			throw newSQLException(SQLState.INVALID_MAX_ROWS_VALUE, new Integer(max));
0: 		}
0: 		this.maxRows = max;
0: 	}
0: 
0:     /**
0:      * If escape scanning is on (the default) the driver will do
0:      * escape substitution before sending the SQL to the database.
0:      *
0:      * @param enable true to enable; false to disable
0: 	 * @exception SQLException thrown on failure.
0:      */
0: 	public void setEscapeProcessing(boolean enable) throws SQLException	{
0: 		checkStatus();
0:         // Nothing to do in our server , just ignore it.
0: 
0: 	}
0: 
0:     /**
0:      * The queryTimeout limit is the number of seconds the driver will
0:      * wait for a Statement to execute. If the limit is exceeded a
0:      * SQLException is thrown.
0:      *
0:      * @return the current query timeout limit in seconds; zero means unlimited
0: 	 * @exception SQLException thrown on failure.
0:      */
0: 	public int getQueryTimeout() throws SQLException {
0:         // Currently Cloudscape does not support any sort of timeout, so always
0:         // return 0, which means that timeout is unlimited.
0:         return(0);
0: 	}
0: 
0:     /**
0:      * The queryTimeout limit is the number of seconds the driver will
0:      * wait for a Statement to execute. If the limit is exceeded a
0:      * SQLException is thrown.
0:      *
0:      * @param seconds the new query timeout limit in seconds; zero means unlimited
0: 	 * @exception SQLException thrown on failure.
0:      */
0: 	public void setQueryTimeout(int seconds) throws SQLException {
0: 		if (seconds != 0)
0: 			throw Util.notImplemented("setQueryTimeout");
0: 	}
0: 
0:     /**
0:      * Cancel can be used by one thread to cancel a statement that
0:      * is being executed by another thread.
0: 	 * @exception SQLException thrown on failure.
0:      */
0: 	public void cancel() throws SQLException {
0: 		throw Util.notImplemented("cancel");
0: 	}
0: 
0:     /**
0:      * The first warning reported by calls on this Statement is
0:      * returned.  A Statment's execute methods clear its SQLWarning
0:      * chain. Subsequent Statement warnings will be chained to this
0:      * SQLWarning.
0:      *
0:      * <p>The warning chain is automatically cleared each time
0:      * a statement is (re)executed.
0:      *
0:      * <P><B>Note:</B> If you are processing a ResultSet then any
0:      * warnings associated with ResultSet reads will be chained on the
0:      * ResultSet object.
0:      *
0:      * @return the first SQLWarning or null
0: 	 * @exception SQLException thrown on failure.
0:      */
0: 	public SQLWarning getWarnings() throws SQLException	{
0: 		checkStatus();
0: 		return warnings;
0: 	}
0: 
0:     /**
0:      * After this call getWarnings returns null until a new warning is
0:      * reported for this Statement.
0: 	 * @exception SQLException thrown on failure.
0:      */
0: 	public void clearWarnings() throws SQLException	{
0: 		checkStatus();
0: 		warnings = null;
0: 	}
0: 
0:     /**
0:      * setCursorName defines the SQL cursor name that will be used by
0:      * subsequent Statement execute methods. This name can then be
0:      * used in SQL positioned update/delete statements to identify the
0:      * current row in the ResultSet generated by this statement.  If
0:      * the database doesn't support positioned update/delete, this
0:      * method is a noop.
0:      *
0:      * <P><B>Note:</B> By definition, positioned update/delete
0:      * execution must be done by a different Statement than the one
0:      * which generated the ResultSet being used for positioning. Also,
0:      * cursor names must be unique within a Connection.
0:      *
0:      * @param name the new cursor name.
0:      */
0: 	public void setCursorName(String name) throws SQLException {
0: 		checkStatus();
0: 		cursorName = name;
0: 	}
0: 
0:     //----------------------- Multiple Results --------------------------
0: 
0:     /**
0:      * Execute a SQL statement that may return multiple results.
0:      * Under some (uncommon) situations a single SQL statement may return
0:      * multiple result sets and/or update counts.  Normally you can ignore
0:      * this, unless you're executing a stored procedure that you know may
0:      * return multiple results, or unless you're dynamically executing an
0:      * unknown SQL string.  The "execute", "getMoreResults", "getResultSet"
0:      * and "getUpdateCount" methods let you navigate through multiple results.
0:      *
0:      * The "execute" method executes a SQL statement and indicates the
0:      * form of the first result.  You can then use getResultSet or
0:      * getUpdateCount to retrieve the result, and getMoreResults to
0:      * move to any subsequent result(s).
0:      *
0:      * @param sql					any SQL statement
0: 	 * @param executeQuery			caller is executeQuery()
0: 	 * @param executeUpdate			caller is executeUpdate()
0: 	 *
0:      * @return true if the first result is a ResultSet; false if it is an integer
0:      * @see #getResultSet
0:      * @see #getUpdateCount
0:      * @see #getMoreResults
0: 	 * @exception SQLException thrown on failure
0:      */
0: 	public boolean execute(String sql)
0: 		throws SQLException
0: 	{
0: 		return execute(sql, false, false, JDBC30Translation.NO_GENERATED_KEYS, null, null);
0: 	}
0: 	
0: 	protected boolean execute(String sql, boolean executeQuery, boolean executeUpdate,
0: 		int autoGeneratedKeys, int[] columnIndexes, String[] columnNames) throws SQLException
0: 	{
0: 
0: 	// if sql is null, raise an error
0: 	if (sql == null)
0:   		throw newSQLException(SQLState.NULL_SQL_TEXT);
0: 
0: 	  synchronized (getConnectionSynchronization()) {
0: 
0: 		checkExecStatus();
0: 		checkIfInMiddleOfBatch();
0: 		clearResultSets(); // release the last statement executed, if any.
0: 
0:         setupContextStack(); // make sure there's context
0: 
0: 
0: 		// try to remember the SQL statement in case anybody asks for it
0: 		SQLText = sql;		
0: 
0: 		try {
0: 			Activation activation;
0: 			try {
0: 				PreparedStatement preparedStatement = lcc.prepareInternalStatement(sql);
0: 				activation =
0: 					preparedStatement.getActivation(lcc, resultSetType == JDBC20Translation.TYPE_SCROLL_INSENSITIVE);
0: 				checkRequiresCallableStatement(activation);
0: 			 } catch (Throwable t) {
0: 				throw handleException(t);
0: 			 }
0: 
0: 
0: 			// this is for a Statement execution
0: 			activation.setSingleExecution();
0: 
0: 			//bug 4838 - save the auto-generated key information in activation. keeping this
0: 			//information in lcc will not work work it can be tampered by a nested trasaction
0: 			if (autoGeneratedKeys == JDBC30Translation.RETURN_GENERATED_KEYS)
0: 				activation.setAutoGeneratedKeysResultsetInfo(columnIndexes, columnNames);
0: 			return executeStatement(activation, executeQuery, executeUpdate);
0: 		} finally {
0: 		    restoreContextStack();
0: 		}
0: 	  }
0: 	}
0: 
0:     /**
0:      * JDBC 3.0
0:      *
0:      * Executes the given SQL statement, which may return multiple
0:      * results, and signals the driver that any auto-generated keys
0:      * should be made available for retrieval. The driver will ignore
0:      * this signal if the SQL statement is not an INSERT statement.
0:      *
0:      * @param sql any SQL statement
0:      * @param autoGeneratedKeys - a constant indicating whether
0:      * auto-generated keys should be made available for retrieval using
0:      * the method getGeneratedKeys; one of the following constants:
0:      * Statement.RETURN_GENERATED_KEYS or Statement.NO_GENERATED_KEYS
0:      * @return rue if the first result is a ResultSet object; false if
0:      * it is an update count or there are no results
0:      * @exception SQLException if a database access error occurs
0:      */
0: 	public boolean execute(String sql, int autoGeneratedKeys) throws SQLException
0: 	{
0: 		return execute(sql, false, false, autoGeneratedKeys, null, null);
0: 	}
0: 
0:     /**
0:      * JDBC 3.0
0:      *
0:      * Executes the given SQL statement, which may return multiple
0:      * results, and signals the driver that the auto-generated keys
0:      * indicated in the given array should be made available for retrieval.
0:      * This array contains the indexes of the columns in the target table
0:      * that contain the auto-generated keys that should be made available.
0:      * The driver will ignore the array if the given SQL statement is not an
0:      * INSERT statement.
0:      *
0:      * @param sql any SQL statement
0:      * @param columnIndexes - an array of the indexes of the columns in the
0:      * inserted row that should be made available for retrieval by a call to
0:      * the method getGeneratedKeys
0:      * @return rue if the first result is a ResultSet object; false if
0:      * it is an update count or there are no results
0:      * @exception SQLException if a database access error occurs
0:      */
0: 	public boolean execute(String sql, int[] columnIndexes) throws SQLException
0: 	{
0:  		throw Util.notImplemented("execute(String, int[])");
0: 	}
0: 
0:     /**
0:      * JDBC 3.0
0:      *
0:      * Executes the given SQL statement, which may return multiple
0:      * results, and signals the driver that the auto-generated keys
0:      * indicated in the given array should be made available for retrieval.
0:      * This array contains the names of the columns in the target table
0:      * that contain the auto-generated keys that should be made available.
0:      * The driver will ignore the array if the given SQL statement is not an
0:      * INSERT statement.
0:      *
0:      * @param sql any SQL statement
0:      * @param columnNames - an array of the names of the columns in the
0:      * inserted row that should be made available for retrieval by a call to
0:      * the method getGeneratedKeys
0:      * @return rue if the first result is a ResultSet object; false if
0:      * it is an update count or there are no results
0:      * @exception SQLException if a database access error occurs
0:      */
0: 	public boolean execute(String sql, String[] columnNames) throws SQLException
0: 	{
0:  		throw Util.notImplemented("execute(String, String[])");
0: 	}
0: 
0:     /**
0:      *  getResultSet returns the current result as a ResultSet.  It
0:      *  should only be called once per result.
0:      *
0:      * @return the current result as a ResultSet; null if the result
0:      * is an update count or there are no more results or the statement
0: 	 * was closed.
0:      * @see #execute
0:      */
0: 	public final java.sql.ResultSet getResultSet() throws SQLException  {
0: 		checkStatus();
0: 
0: 		return results;
0: 	}
0: 
0:     /**
0:      *  getUpdateCount returns the current result as an update count;
0:      *  if the result is a ResultSet or there are no more results -1
0:      *  is returned.  It should only be called once per result.
0:      *
0:      * <P>The only way to tell for sure that the result is an update
0:      *  count is to first test to see if it is a ResultSet. If it is
0:      *  not a ResultSet it is either an update count or there are no
0:      *  more results.
0:      *
0:      * @return the current result as an update count; -1 if it is a
0:      * ResultSet or there are no more results
0:      * @see #execute
0:      */
0: 	public final int getUpdateCount()	throws SQLException  {
0: 		checkStatus();
0: 		return updateCount;
0: 	}
0: 
0:     /**
0:      * getMoreResults moves to a Statement's next result.  It returns true if
0:      * this result is a ResultSet.  getMoreResults also implicitly
0:      * closes any current ResultSet obtained with getResultSet.
0:      *
0:      * There are no more results when (!getMoreResults() &&
0:      * (getUpdateCount() == -1)
0:      *
0:      * @return true if the next result is a ResultSet; false if it is
0:      * an update count or there are no more results
0:      * @see #execute
0: 	 * @exception SQLException thrown on failure.
0:      */
0: 	public final boolean getMoreResults() throws SQLException	{
0: 		return getMoreResults(JDBC30Translation.CLOSE_ALL_RESULTS);
0: 	}
0: 
0: 	/////////////////////////////////////////////////////////////////////////
0: 	//
0: 	//	JDBC 2.0 methods that are implemented here because EmbedPreparedStatement
0: 	//  and EmbedCallableStatement in Local20 need access to them, and those
0: 	//	classes extend their peer classes in Local, instead of EmbedStatement
0: 	//	in Local20
0: 	//
0: 	//  We do the same of JDBC 3.0 methods.
0: 	/////////////////////////////////////////////////////////////////////////
0: 
0:     /**
0:      * JDBC 2.0
0:      *
0:      * Determine the result set type.
0:      *
0:      * @exception SQLException Feature not implemented for now.
0:      */
0:     public final int getResultSetType()
0: 		throws SQLException 
0: 	{
0: 		checkStatus();
0: 		return resultSetType;
0: 	}
0: 
0: 
0:     /**
0:      * JDBC 2.0
0:      *
0:      * Give a hint as to the direction in which the rows in a result set
0:      * will be processed. The hint applies only to result sets created
0:      * using this Statement object.  The default value is 
0:      * ResultSet.FETCH_FORWARD.
0:      *
0:      * @param direction the initial direction for processing rows
0:      * @exception SQLException if a database-access error occurs or direction
0:      * is not one of ResultSet.FETCH_FORWARD, ResultSet.FETCH_REVERSE, or
0:      * ResultSet.FETCH_UNKNOWN
0:      */
0:     public void setFetchDirection(int direction) throws SQLException {
0: 		
0: 		checkStatus();
0:                 /* fetch direction is meaningless to us. we just save
0:                  * it off if it is valid  and return the current value if asked.
0:                  */
0:                 if (direction == JDBC20Translation.FETCH_FORWARD || 
0:                     direction == JDBC20Translation.FETCH_REVERSE ||
0:                     direction == JDBC20Translation.FETCH_UNKNOWN )
0:                 {
0:                     fetchDirection = direction;
0:                 }else
0:                     throw newSQLException(SQLState.INVALID_FETCH_DIRECTION, 
0:                                    new Integer(direction));
0: 	}
0: 
0:     /**
0:      * JDBC 2.0
0:      *
0:      * Determine the fetch direction.
0:      *
0:      * @return the default fetch direction
0:      * @exception SQLException if a database-access error occurs
0:      */
0:     public int getFetchDirection() throws SQLException {
0: 		checkStatus();
0: 		return fetchDirection;
0: 	}
0: 
0: 
0:     /**
0:      * JDBC 2.0
0:      *
0:      * Give the JDBC driver a hint as to the number of rows that should
0:      * be fetched from the database when more rows are needed.  The number 
0:      * of rows specified only affects result sets created using this 
0:      * statement. If the value specified is zero, then the hint is ignored.
0:      * The default value is zero.
0:      *
0:      * @param rows the number of rows to fetch
0:      * @exception SQLException if a database-access error occurs, or the
0:      * condition 0 <= rows <= this.getMaxRows() is not satisfied.
0:      */
0:     public void setFetchSize(int rows) throws SQLException {
0: 		checkStatus();
0:         if (rows < 0  || (this.getMaxRows() != 0 && 
0:                              rows > this.getMaxRows()))
0:         {
0: 	        throw newSQLException(SQLState.INVALID_ST_FETCH_SIZE, new Integer(rows));
0:         }else if ( rows > 0 ) // ignore the call if the value is zero
0:             fetchSize = rows;
0: 	}
0:   
0:     /**
0:      * JDBC 2.0
0:      *
0:      * Determine the default fetch size.
0:      * @exception SQLException if a database-access error occurs
0:      *
0:      */
0:     public int getFetchSize() throws SQLException {
0: 		checkStatus();
0: 		return fetchSize;
0: 	}
0: 
0:     /**
0:      * JDBC 2.0
0:      *
0:      * Determine the result set concurrency.
0:      *
0:      * @exception SQLException Feature not implemented for now.
0:      */
0:     public int getResultSetConcurrency() throws SQLException {
0: 		checkStatus();
0: 		return resultSetConcurrency;
0: 	}
0: 
0:     /**
0:      * JDBC 3.0
0:      *
0:      * Retrieves the result set holdability for ResultSet objects
0:      * generated by this Statement object.
0:      *
0:      * @return either ResultSet.HOLD_CURSORS_OVER_COMMIT or
0:      * ResultSet.CLOSE_CURSORS_AT_COMMIT
0:      * @exception SQLException Feature not implemented for now.
0:      */
0:     public int getResultSetHoldability() throws SQLException {
0: 		checkStatus();
0: 		return resultSetHoldability;
0: 	}
0: 
0:     /**
0:      * JDBC 2.0
0:      *
0:      * Adds a SQL command to the current batch of commmands for the statement.
0:      * This method is optional.
0:      *
0:      * @param sql typically this is a static SQL INSERT or UPDATE statement
0:      * @exception SQLException if a database-access error occurs, or the
0:      * driver does not support batch statements
0:      */
0:     public void addBatch( String sql ) throws SQLException {
0: 		checkStatus();
0:   	  synchronized (getConnectionSynchronization()) {
0: 		  if (batchStatements == null)
0: 			  batchStatements = new Vector();
0:         batchStatements.addElement(sql);
0:   		}
0: 	}
0: 
0:     /**
0:      * JDBC 2.0
0:      *
0:      * Make the set of commands in the current batch empty.
0:      * This method is optional.
0:      *
0:      * @exception SQLException if a database-access error occurs, or the
0:      * driver does not support batch statements
0:      */
0:     public final void clearBatch() throws SQLException {
0: 		checkStatus();
0:   	  synchronized (getConnectionSynchronization()) {
0:         batchStatements = null;
0:   		}
0: 	}
0: 
0:     /**
0:      * JDBC 2.0
0:      * 
0:      * Submit a batch of commands to the database for execution.
0:      * This method is optional.
0: 	 *
0: 	 * Moving jdbc2.0 batch related code in this class because
0: 	 * callableStatement in jdbc 20 needs this code too and it doesn't derive
0: 	 * from prepared statement in jdbc 20 in our implementation. 
0: 	 * BatchUpdateException is the only new class from jdbc 20 which is being
0: 	 * referenced here and in order to avoid any jdk11x problems, using
0: 	 * reflection code to make an instance of that class. 
0:      *
0:      * @return an array of update counts containing one element for each
0:      * command in the batch.  The array is ordered according
0:      * to the order in which commands were inserted into the batch
0:      * @exception SQLException if a database-access error occurs, or the
0:      * driver does not support batch statements
0:      */
0:     public int[] executeBatch() throws SQLException {
0: 		checkExecStatus();
0: 		synchronized (getConnectionSynchronization()) 
0: 		{
0:                         setupContextStack();
0: 			int i = 0;
0: 			// As per the jdbc 2.0 specs, close the statement object's current resultset
0: 			// if one is open.
0: 			// Are there results?
0: 			// outside of the lower try/finally since results will
0: 			// setup and restore themselves.
0: 			clearResultSets();
0: 
0: 			Vector stmts = batchStatements;
0: 			batchStatements = null;
0: 			int size;
0: 			if (stmts == null)
0: 				size = 0;
0: 			else
0: 				size = stmts.size();
0: 
0: 			int[] returnUpdateCountForBatch = new int[size];
0: 
0: 			SQLException sqle;
0: 			try {
0: 				for (; i< size; i++) 
0: 				{
0: 					if (executeBatchElement(stmts.elementAt(i)))
0: 						throw newSQLException(SQLState.RESULTSET_RETURN_NOT_ALLOWED);
0: 					returnUpdateCountForBatch[i] = getUpdateCount();
0: 				}
0: 				return returnUpdateCountForBatch;
0: 			}
0: 			catch (StandardException se) {
0: 
0: 				sqle = handleException(se);
0: 			}
0: 			catch (SQLException sqle2) 
0: 			{
0: 				sqle = sqle2;
0: 			}
0: 			finally 
0: 			{
0: 				restoreContextStack();
0: 			}
0: 
0: 			int successfulUpdateCount[] = new int[i];
0: 			for (int j=0; j<i; j++)
0: 			{
0: 				successfulUpdateCount[j] = returnUpdateCountForBatch[j];
0: 			}
0: 
0: 			SQLException batch =
0: 			new java.sql.BatchUpdateException(sqle.getMessage(), sqle.getSQLState(),
0: 									sqle.getErrorCode(), successfulUpdateCount);
0: 
0: 			batch.setNextException(sqle);
0: 			throw batch;
0:       }
0: 	}
0: 
0: 	/**
0: 		Execute a single element of the batch. Overridden by EmbedPreparedStatement
0: 	*/
0: 	protected boolean executeBatchElement(Object batchElement) throws SQLException, StandardException {
0: 		return execute((String)batchElement, false, true, JDBC30Translation.NO_GENERATED_KEYS, null, null);
0: 	}
0: 
0:     /**
0:      * JDBC 2.0
0:      *
0:      * Return the Connection that produced the Statement.
0:      *
0:      * @exception SQLException Exception if it cannot find the connection
0:      * associated to this statement.
0:      */
0:     public final java.sql.Connection getConnection()  throws SQLException {
0: 		checkStatus();
0: 
0:     	java.sql.Connection appConn = getEmbedConnection().getApplicationConnection();
0: 		if ((appConn != applicationConnection) || (appConn == null))
0: 			throw Util.noCurrentConnection();
0: 		return appConn;
0:     }
0: 
0:     /**
0:      * JDBC 3.0
0:      *
0:      * Moves to this Statement obect's next result, deals with any current ResultSet
0:      * object(s) according to the instructions specified by the given flag, and
0:      * returns true if the next result is a ResultSet object
0:      *
0:      * @param current - one of the following Statement constants indicating what
0:      * should happen to current ResultSet objects obtained using the method
0:      * getResultSetCLOSE_CURRENT_RESULT, KEEP_CURRENT_RESULT, or CLOSE_ALL_RESULTS
0:      * @return true if the next result is a ResultSet; false if it is
0:      * an update count or there are no more results
0:      * @see #execute
0:      * @exception SQLException thrown on failure.
0:      */
0: 	public final boolean getMoreResults(int current) throws SQLException	{
0: 		checkExecStatus();
0: 
0: 		synchronized (getConnectionSynchronization()) {
0: 			if (dynamicResults == null) {
0: 				// we only have the one resultset, so this is
0: 				// simply a close for us.
0: 				clearResultSets();
0: 				return false;
0: 			}
0: 
0: 			int startingClose;
0: 			switch (current) {
0: 			default:
0: 			case JDBC30Translation.CLOSE_ALL_RESULTS:
0: 				startingClose = 0;
0: 				break;
0: 			case JDBC30Translation.CLOSE_CURRENT_RESULT:
0: 				// just close the current result set.
0: 				startingClose = currentDynamicResultSet;
0: 				break;
0: 			case JDBC30Translation.KEEP_CURRENT_RESULT:
0: 				// make the close loop a no-op.
0: 				startingClose = dynamicResults.length;
0: 				break;
0: 			}
0: 
0: 			// Close loop.
0: 			SQLException se = null;
0: 			for (int i = startingClose; i <= currentDynamicResultSet && i < dynamicResults.length; i++) {
0: 				EmbedResultSet lrs = dynamicResults[i];
0: 				if (lrs == null)
0: 					continue;
0: 
0: 
0: 				try {
0: 					if (!lrs.isClosed)
0: 						lrs.close();
0: 				} catch (SQLException sqle) {
0: 					if (se == null)
0: 						se = sqle;
0: 					else
0: 						se.setNextException(sqle);
0: 				} finally {
0: 					dynamicResults[i] = null;
0: 				}
0: 			}
0: 
0: 			if (se != null) {
0: 				// leave positioned on the current result set (?)
0: 				throw se;
0: 			}
0: 
0: 			updateCount = -1;
0: 
0: 			while (++currentDynamicResultSet < dynamicResults.length) {
0: 
0: 				EmbedResultSet lrs = dynamicResults[currentDynamicResultSet];
0: 				if (lrs != null) {
0: 					if (lrs.isClosed) {
0: 						dynamicResults[currentDynamicResultSet] = null;
0: 						continue;
0: 					}
0: 
0: 					results = lrs;
0: 
0: 					return true;
0: 				}
0: 			}
0: 
0: 			results = null;
0: 			return false;
0: 		}
0: 	}
0: 
0:     /**
0:      * JDBC 3.0
0:      *
0:      * Retrieves any auto-generated keys created as a result of executing this
0:      * Statement object. If this Statement is a non-insert statement,
0:      * a null ResultSet object is returned.
0:      *
0:      * @return a ResultSet object containing the auto-generated key(s) generated by
0:      * the execution of this Statement object
0:      * @exception SQLException if a database access error occurs
0:      */
0: 	public final java.sql.ResultSet getGeneratedKeys() throws SQLException	{
0: 		if (autoGeneratedKeysResultSet == null)
0: 			return null;
0: 		else {
0: 			execute("VALUES IDENTITY_VAL_LOCAL()", true, false, JDBC30Translation.NO_GENERATED_KEYS, null, null);
0: 			return results;
0: 		}
0: 	}
0: 
0: 	/////////////////////////////////////////////////////////////////////////
0: 	//
0: 	//	Implementation specific methods	
0: 	//
0: 	/////////////////////////////////////////////////////////////////////////
0: 
0: 	/**
0: 		Execute the current statement.
0: 	    @exception SQLException thrown on failure.
0: 	*/
0: 	protected boolean executeStatement(Activation a,
0:                      boolean executeQuery, boolean executeUpdate)
0:                      throws SQLException {
0: 
0: 		// we don't differentiate the update from the resultset case.
0: 		// so, there could be a result set.
0: 
0: 		// note: the statement interface will paste together
0: 		// an activation and make sure the prepared statement
0: 		// is still valid, so it is preferrable, for now,
0: 		// to creating our own activation and stuffing it in
0: 		// the prepared statement.
0: 
0: 		synchronized (getConnectionSynchronization()) {
0:                         setupContextStack(); // make sure there's context
0: 			boolean retval;
0: 
0: 			pvs = a.getParameterValueSet();
0: 
0: 			try {
0: 				// The following is from the javadoc for java.sql.Statement
0: 				// Only one ResultSet per Statement can be open at any point in time.
0: 				// Therefore, if the reading of one ResultSet is interleaved with the
0: 				// reading of another, each must have been generated by different Statements.
0: 				// All statement execute methods implicitly close a
0: 				// statment's current ResultSet if an open one exists. 
0: 				if (results != null) {
0: 					results.close();
0: 					results = null;
0: 				}
0: 
0: 				clearWarnings();
0: 
0: 				if (! forMetaData) {
0: 					commitIfNeeded(); // commit the last statement if needed
0: 					needCommit();
0: 				} else {
0: 
0: 
0: 		        	if (lcc.getActivationCount() > 1) {
0: 		     		  // we do not want to commit here as there seems to be other
0: 					  // statements/resultSets currently opened for this connection.
0: 					} else {
0: 						commitIfNeeded(); // we can legitimately commit
0: 						needCommit();
0: 					}
0: 				}
0: 
0: 				// if this was a prepared statement, this just
0: 				// gets it for us, it won't recompile unless it is invalid.
0: 				PreparedStatement ps = a.getPreparedStatement();
0: 				ps.rePrepare(lcc);
0: 				getWarnings(ps.getCompileTimeWarnings());
0: 
0: 
0: 				/*
0: 				** WARNING WARNING
0: 				**
0: 				** Any state set in the activation before execution *must* be copied
0: 				** to the new activation in GenericActivationHolder.execute() when
0: 				** the statement has been recompiled. State such as
0: 				** singleExecution, cursorName, holdability, maxRows.
0: 				*/
0: 
0: 				if (cursorName != null)
0: 				{
0: 					a.setCursorName(cursorName);
0: 				}
0: 				a.setResultSetHoldability(resultSetHoldability != JDBC30Translation.CLOSE_CURSORS_AT_COMMIT);
0: 
0: 				//reset the activation to clear warnings
0: 				//and clear existing result sets in case this has been cached
0: 				a.reset();
0: 				a.setMaxRows(maxRows);
0: 				ResultSet resultsToWrap = ps.execute(a, executeQuery, executeUpdate, false);
0: 				getWarnings(a.getWarnings());
0: 
0: 
0: 				if (resultsToWrap.returnsRows()) {
0: 					EmbedResultSet lresults = factory.newEmbedResultSet(getEmbedConnection(), resultsToWrap, forMetaData, this, ps.isAtomic());
0: 					results = lresults;
0: 
0: 
0: 					// Set up the finalization of the ResultSet to
0: 					// mark the activation as unused. It will be
0: 					// closed sometime later by the connection
0: 					// outside of finalization.
0: 					if (a.isSingleExecution())
0: 						lresults.finalizeActivation = a;
0: 
0: 					updateCount = -1;
0: 					retval = true;
0: 				}
0: 				else {
0: 
0: 					// Only applipable for an insert statement, which does not return rows.
0: 					//the auto-generated keys resultset will be null if used for non-insert statement
0: 					if (a.getAutoGeneratedKeysResultsetMode() && (resultsToWrap.getAutoGeneratedKeysResultset() != null))
0: 					{
0: 						resultsToWrap.getAutoGeneratedKeysResultset().open();
0: 						autoGeneratedKeysResultSet = factory.newEmbedResultSet(getEmbedConnection(),
0: 							resultsToWrap.getAutoGeneratedKeysResultset(), false, this, ps.isAtomic());
0: 					}
0: 
0: 					updateCount = resultsToWrap.modifiedRowCount();
0: 
0: 					resultsToWrap.finish();	// Don't need the result set any more
0: 					results = null; // note that we have none.
0: 
0: 					boolean haveDynamicResults = false;
0: 					if (a.getDynamicResults() != null) {
0: 						haveDynamicResults = processDynamicResults(a.getDynamicResults(), a.getMaxDynamicResults());
0: 					}
0: 					
0: 					if (!haveDynamicResults) {
0: 						if (a.isSingleExecution()) {
0: 							a.close();
0: 						}
0: 
0: 						if (!forMetaData)
0: 							commitIfNeeded();
0: 						else {
0: 
0: 							if (lcc.getActivationCount() > 1) {
0: 							  // we do not want to commit here as there seems to be other
0: 							  // statements/resultSets currently opened for this connection.
0: 							} else {
0: 								commitIfNeeded(); // we can legitimately commit
0: 							}
0: 						}
0: 					}
0: 
0: 					retval = haveDynamicResults;
0: 				}
0: 	        } catch (Throwable t) {
0: 				if (a.isSingleExecution()) {
0: 					try { a.close(); } catch (Throwable tt) {;}
0: 				}
0: 		        throw handleException(t);
0: 			} finally {
0: 			    restoreContextStack();
0: 			}
0: 			return retval;
0: 		}
0: 	}
0: 
0: 	protected void getWarnings(SQLWarning sw)
0: 	{
0: 		if (sw != null) {
0: 			if (warnings == null)
0: 				warnings = sw;
0: 			else
0: 				warnings.setNextException(sw);
0: 		}
0: 	}
0: 
0: 
0: 	/* package */
0: 	public String getSQLText()
0: 	{
0: 		// no need to synchronize - accessing a reference is atomic
0: 		// synchronized (getConnectionSynchronization()) 
0: 		return SQLText;
0: 	}
0: 
0: 	public ParameterValueSet getParameterValueSet()
0: 	{
0: 		return pvs;
0: 	}
0: 
0: 	//check the status of this statement, if it has already been closed,
0:     //we throw an exception, need to be called by every public method
0:     protected final void checkStatus() throws SQLException {
0: 
0: 		if (!active)
0: 			throw newSQLException(SQLState.ALREADY_CLOSED, "Statement");
0: 	}
0: 
0: 	/**
0: 		A heavier weight version of checkStatus() that ensures the application's Connection
0: 		object is still open. This is to stop errors or unexpected behaviour when a [Prepared]Statement
0: 		object is used after the application has been closed. In particular to ensure that
0: 		a Statement obtained from a PooledConnection cannot be used after the application has closed
0: 		its connection (as the underlying Connection is still active).
0: 		To avoid this heavier weight check on every method of [Prepared]Statement it is only used
0: 		on those methods that would end up using the database's connection to read or modify data.
0: 		E.g. execute*(), but not setXXX, etc.
0: 	*/
0: 	protected final void checkExecStatus() throws SQLException {
0: 		// getConnection() checks if the Statement is closed
0: 		if (!getConnection().isClosed())
0: 			return;
0: 	
0: 		throw Util.noCurrentConnection();
0: 	}
0: 
0: 	/**
0: 		Close and clear all result sets associated with this statement
0: 		from the last execution.
0: 	*/
0: 	protected void clearResultSets() throws SQLException {
0: 
0: 		SQLException sqle = null;
0: 
0: 		try {
0: 			// Are there results?
0: 			// outside of the lower try/finally since results will
0: 			// setup and restore themselves.
0: 			if (results != null) {
0: 				results.close();
0: 				results = null;
0: 			}
0: 		} catch (SQLException s1) {
0: 			sqle = s1;
0: 		}
0: 
0: 		try {
0: 			if (autoGeneratedKeysResultSet != null) {
0: 				autoGeneratedKeysResultSet.close();
0: 				autoGeneratedKeysResultSet = null;
0: 			}
0: 		} catch (SQLException sauto) {
0: 			if (sqle == null)
0: 				sqle = sauto;
0: 			else
0: 				sqle.setNextException(sauto);
0: 		}
0: 
0: 		// close all the dynamic result sets.
0: 		if (dynamicResults != null) {
0: 			for (int i = 0; i < dynamicResults.length; i++) {
0: 				EmbedResultSet lrs = dynamicResults[i];
0: 				if (lrs == null)
0: 					continue;
0: 
0: 				try {
0: 					if (!lrs.isClosed)
0: 						lrs.close();
0: 				} catch (SQLException sdynamic) {
0: 					if (sqle == null)
0: 						sqle = sdynamic;
0: 					else
0: 						sqle.setNextException(sdynamic);
0: 				}
0: 			}
0: 			dynamicResults = null;
0: 		}
0: 
0: 		/*
0: 			  We don't reset statement to null because PreparedStatement
0: 			  relies on it being there for subsequent (post-close) execution
0: 			  requests.  There is no close method on database statement objects.
0: 		*/
0: 
0: 		updateCount = -1; // reset field
0: 
0: 		if (sqle != null)
0: 			throw sqle;
0: 	 }  
0: 	
0: 	/**
0: 		Check to see if a statement requires to be executed via a callable statement.
0: 	*/
0: 	protected void checkRequiresCallableStatement(Activation activation) throws SQLException {
0: 
0: 		ParameterValueSet pvs = activation.getParameterValueSet();
0: 
0: 		if (pvs == null)
0: 			return;
0: 
0: 		if (pvs.checkNoDeclaredOutputParameters()) {
0: 			try {
0: 				activation.close();
0: 			} catch (StandardException se) {
0: 			}
0: 			throw newSQLException(SQLState.REQUIRES_CALLABLE_STATEMENT, SQLText);
0: 		}
0: 	}
0: 
0: 	/**
0: 		Transfer my batch of Statements to a newly created Statement.
0: 	*/
0: 	public void transferBatch(EmbedStatement other) throws SQLException {
0: 		
0: 		synchronized (getConnectionSynchronization()) {
0: 			other.batchStatements = batchStatements;
0: 			batchStatements = null;
0: 		}
0: 	}
0: 
0: 
0: 	private EmbedResultSet[] dynamicResults;
0: 	private int currentDynamicResultSet;
0: 	private boolean processDynamicResults(java.sql.ResultSet[][] holder, int maxDynamicResultSets) throws SQLException {
0: 
0: 		EmbedResultSet[] sorted = new EmbedResultSet[holder.length];
0: 
0: 		int actualCount = 0;
0: 		for (int i = 0; i < holder.length; i++) {
0: 
0: 			java.sql.ResultSet[] param = holder[i];
0: 
0: 			if (param[0] == null)
0: 				continue;
0: 
0: 			java.sql.ResultSet rs = param[0];
0: 			param[0] = null;
0: 
0: 			// ignore non-cloudscape result sets or results sets from another connection
0: 			if (!(rs instanceof EmbedResultSet))
0: 				continue;
0: 
0: 			EmbedResultSet lrs = (EmbedResultSet) rs;
0: 
0: 			if (lrs.getEmbedConnection().rootConnection != getEmbedConnection().rootConnection)
0: 				continue;
0: 
0: 			// ignore closed result sets.
0: 			if (lrs.isClosed)
0: 				continue;
0: 
0: 			lrs.setDynamicResultSet(this);
0: 			sorted[actualCount++] = lrs;
0: 		}
0: 
0: 		if (actualCount != 0) {
0: 
0: 			// results are defined to be ordered according to their creation
0: 			if (actualCount != 1) {
0: 				java.util.Arrays.sort(sorted, 0, actualCount);
0: 			}
0: 
0: 			dynamicResults = sorted;
0: 
0: 			if (actualCount > maxDynamicResultSets) {
0: 				getWarnings(StandardException.newWarning(SQLState.LANG_TOO_MANY_DYNAMIC_RESULTS_RETURNED));
0: 
0: 				for (int i = maxDynamicResultSets; i < actualCount; i++) {
0: 					sorted[i].close();
0: 					sorted[i] = null;
0: 				}
0: 
0: 				actualCount = maxDynamicResultSets;
0: 			}
0: 
0: 
0: 			updateCount = -1;
0: 			results = sorted[0];
0: 			currentDynamicResultSet = 0;
0: 
0: 			// 0100C is not returned for procedures written in Java, from the SQL2003 spec.
0: 			// getWarnings(StandardException.newWarning(SQLState.LANG_DYNAMIC_RESULTS_RETURNED));
0: 
0: 			return true;
0: 		}
0: 
0: 
0: 		return false;
0: 	}
0: 
0: 	/**
0: 		Callback on the statement when one of its result sets is closed.
0: 		This allows the statement to control when it completes and hence
0: 		when it commits in auto commit mode.
0: 
0:         Must have connection synchronization and setupContextStack(), this
0:         is required for the call to commitIfNeeded().
0: 	*/
0: 	void resultSetClosing(EmbedResultSet closingLRS) throws SQLException {
0: 
0: 		// If the Connection is not in auto commit then this statement completion
0: 		// cannot cause a commit.
0: 		if (!getEmbedConnection().autoCommit)
0: 			return;
0: 
0: 		// If we have dynamic results, see if there is another result set open.
0: 		// If so, then no commit. The last result set to close will close the statement.
0: 		if (dynamicResults != null) {
0: 			for (int i = 0; i < dynamicResults.length; i++) {
0: 				EmbedResultSet lrs = dynamicResults[i];
0: 				if (lrs == null)
0: 					continue;
0: 				if (lrs.isClosed)
0: 					continue;
0: 				if (lrs == closingLRS)
0: 					continue;
0: 
0: 				// at least one still open so no commit now.
0: 				return;
0: 			}
0: 		}
0: 
0: 		// new Throwable("COMMIT ON " + SQLText).printStackTrace(System.out);
0: 
0:         // beetle 5383.  Force a commit in autocommit always.  Before this
0:         // change if client in autocommit opened a result set, did a commit,
0:         // then next then close a commit would not be forced on the close.
0: 		commitIfAutoCommit();
0: 	}
0: 
0: }
0: 
============================================================================