1:33776ff: /*
1:c247315: 
1:33776ff:    Derby - Class org.apache.derby.client.am.Cursor
108:33776ff: 
1:59bf37d:    Licensed to the Apache Software Foundation (ASF) under one or more
1:59bf37d:    contributor license agreements.  See the NOTICE file distributed with
1:59bf37d:    this work for additional information regarding copyright ownership.
1:59bf37d:    The ASF licenses this file to You under the Apache License, Version 2.0
1:59bf37d:    (the "License"); you may not use this file except in compliance with
1:59bf37d:    the License.  You may obtain a copy of the License at
1:33776ff: 
1:33776ff:       http://www.apache.org/licenses/LICENSE-2.0
1:33776ff: 
1:33776ff:    Unless required by applicable law or agreed to in writing, software
1:33776ff:    distributed under the License is distributed on an "AS IS" BASIS,
1:33776ff:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:33776ff:    See the License for the specific language governing permissions and
1:33776ff:    limitations under the License.
1:33776ff: 
1:33776ff: */
1:33776ff: 
1:33776ff: package org.apache.derby.client.am;
1:3d650b1: import org.apache.derby.shared.common.reference.SQLState;
1:90731d5: 
1:d506170: import java.sql.SQLException;
1:c6ed70e: import java.io.BufferedInputStream;
1:c6ed70e: import java.io.BufferedReader;
1:506f4c8: import java.io.ByteArrayInputStream;
1:69e3d06: import java.io.ByteArrayOutputStream;
1:b13b17c: import java.io.InputStream;
1:b13b17c: import java.io.InputStreamReader;
1:506f4c8: import java.io.ObjectInputStream;
1:b13b17c: import java.io.Reader;
1:69e3d06: import java.io.StringReader;
1:b13b17c: import java.math.BigDecimal;
1:a0b8943: import java.nio.charset.Charset;
1:b13b17c: import java.sql.Array;
1:69e3d06: import java.sql.Blob;
1:69e3d06: import java.sql.Clob;
1:7d521f5: import java.sql.Date;
1:b13b17c: import java.sql.Ref;
1:7d521f5: import java.sql.Time;
1:b13b17c: import java.sql.Timestamp;
1:69e3d06: import java.sql.Types;
1:4772c7e: import java.util.ArrayList;
1:7d521f5: import java.util.Calendar;
1:69e3d06: import java.util.GregorianCalendar;
1:d506170: 
1:33776ff: // When we calculate column offsets make sure we calculate the correct offsets for double byte charactr5er data
1:33776ff: // length from server is number of chars, not bytes
1:33776ff: // Direct byte-level converters are called directly by this class, cross converters are deferred to the CrossConverters class.
1:33776ff: 
1:70f7692: public abstract class Cursor {
1:70f7692:     protected Agent agent_;
1:33776ff: 
1:70f7692:     //-----------------------------varchar representations------------------------
1:33776ff: 
1:70f7692:     public final static int STRING = 0;
1:70f7692:     public final static int VARIABLE_STRING = 2;       // uses a 2-byte length indicator
1:70f7692:     public final static int VARIABLE_SHORT_STRING = 1; // aka Pascal L; uses a 1-byte length indicator
1:70f7692:     public final static int NULL_TERMINATED_STRING = 3;
1:33776ff: 
1:70f7692:     public final static int BYTES = 4;
1:b565f41:     // unused protocol element: VARIABLE_BYTES = 5;
1:b13b17c:     // unused protocol element: VARIABLE_SHORT_BYTES = 6;
1:70f7692:     public final static int NULL_TERMINATED_BYTES = 7;
1:33776ff: 
1:a0b8943:     // Charsets
1:a0b8943:     static final Charset UTF_16BE = Charset.forName("UTF-16BE");
1:a0b8943:     static final Charset UTF_8 = Charset.forName("UTF-8");
1:a0b8943:     static final Charset ISO_8859_1 = Charset.forName("ISO-8859-1");
1:a0b8943: 
1:b565f41:     // unused protocol element: SBCS_CLOB = 8;
1:b565f41:     // unused protocol element: MBCS_CLOB = 9;
1:b565f41:     // unused protocol element: DBCS_CLOB = 10;
1:70f7692:     //-----------------------------internal state---------------------------------
1:33776ff: 
1:70f7692:     //-------------Structures for holding and scrolling the data -----------------
1:70f7692:     public byte[] dataBuffer_;
1:69e3d06:     public ByteArrayOutputStream dataBufferStream_;
1:70f7692:     public int position_; // This is the read head
1:70f7692:     public int lastValidBytePosition_;
1:70f7692:     public boolean hasLobs_; // is there at least one LOB column?
1:33776ff: 
1:70f7692:     // Current row positioning
1:70f7692:     protected int currentRowPosition_;
1:70f7692:     private int nextRowPosition_;
1:70f7692:     // Let's new up a 2-dimensional array based on fetch-size and reuse so that
1:70f7692:     protected int[] columnDataPosition_;
1:70f7692: 
1:70f7692:     // This is the actual, computed lengths of varchar fields, not the max length from query descriptor or DA
1:70f7692:     protected int[] columnDataComputedLength_;
1:70f7692:     // populate this for
1:70f7692: 
1:70f7692:     // All the data is in the buffers, but user may not have necessarily stepped to the last row yet.
1:70f7692:     // This flag indicates that the server has returned all the rows, and is positioned
1:70f7692:     // after last, for both scrollable and forward-only cursors.
1:70f7692:     // For singleton cursors, this memeber will be set to true as soon as next is called.
1:5e88312:     private boolean allRowsReceivedFromServer_;
1:70f7692: 
1:70f7692:     // Total number of rows read so far.
1:70f7692:     // This should never exceed this.statement.maxRows
1:47a8183:     long rowsRead_;
1:70f7692: 
1:70f7692:     // Maximum column size limit in bytes.
1:70f7692:     int maxFieldSize_ = 0;
1:70f7692: 
1:70f7692:     // Row positioning for all cached rows
1:70f7692:     // For scrollable result sets, these lists hold the offsets into the cached rowset buffer for each row of data.
1:4772c7e:     protected ArrayList<int[]> columnDataPositionCache_ = new ArrayList<int[]>();
1:4772c7e:     protected ArrayList<int[]> columnDataLengthCache_ = new ArrayList<int[]>();
1:4772c7e:     protected ArrayList<boolean[]> columnDataIsNullCache_ = new ArrayList<boolean[]>();
1:4772c7e:     ArrayList<Boolean> isUpdateDeleteHoleCache_ = new ArrayList<Boolean>();
1:4772c7e:     boolean isUpdateDeleteHole_;
1:70f7692: 
1:c247315:     // State to keep track of when a row has been updated,
1:c247315:     // cf. corresponding set and get accessors.  Only implemented for
1:c247315:     // scrollable updatable insensitive result sets for now.
1:c247315:     private boolean isRowUpdated_;
1:c247315: 
1:4772c7e:     final static Boolean ROW_IS_NULL = Boolean.TRUE;
1:b565f41:     private final static Boolean ROW_IS_NOT_NULL = Boolean.FALSE;
1:70f7692: 
1:b565f41:     private Calendar recyclableCalendar_ = null;
1:70f7692: 
1:70f7692:     // For the net, this data comes from the query descriptor.
1:70f7692: 
1:70f7692:     public int[] jdbcTypes_;
1:70f7692:     public int columns_;
1:70f7692:     public boolean[] nullable_;
1:a0b8943:     public Charset[] charset_;
1:70f7692:     public boolean[] isNull_;
1:70f7692:     public int[] fdocaLength_; // this is the max length for
1:70f7692: 
1:70f7692:     //----------------------------------------------------------------------------
1:70f7692: 
1:70f7692:     public int[] ccsid_;
1:b565f41:     private char[] charBuffer_;
1:70f7692: 
1:70f7692:     //---------------------constructors/finalizer---------------------------------
1:70f7692: 
1:70f7692:     public Cursor(Agent agent) {
1:70f7692:         agent_ = agent;
1:c247315:         isRowUpdated_ = false;
1:69e3d06:         dataBufferStream_ = new ByteArrayOutputStream();
43:70f7692:     }
1:70f7692: 
1:70f7692:     public void setNumberOfColumns(int numberOfColumns) {
1:70f7692:         columnDataPosition_ = new int[numberOfColumns];
1:70f7692:         columnDataComputedLength_ = new int[numberOfColumns];
1:70f7692: 
1:70f7692:         columns_ = numberOfColumns;
1:70f7692:         nullable_ = new boolean[numberOfColumns];
1:a0b8943:         charset_ = new Charset[numberOfColumns];
1:70f7692: 
1:70f7692:         ccsid_ = new int[numberOfColumns];
1:70f7692: 
1:70f7692:         isNull_ = new boolean[numberOfColumns];
1:70f7692:         jdbcTypes_ = new int[numberOfColumns];
1:70f7692:     }
1:70f7692: 
1:5e88312:     /**
1:5e88312:      * Makes the next row the current row. Returns true if the current
1:5e88312:      * row position is a valid row position.
1:5e88312:      *
1:5e88312:      * @param allowServerFetch if false, don't fetch more data from
1:5e88312:      * the server even if more data is needed
1:b13b17c:      * @return {@code true} if current row position is valid
1:5e88312:      * @exception SqlException if an error occurs
1:5e88312:      */
1:5e88312:     protected boolean stepNext(boolean allowServerFetch) throws SqlException {
1:70f7692:         // reset lob data
1:70f7692:         // clears out Cursor.lobs_ calculated for the current row when cursor is moved.
1:70f7692:         clearLobData_();
1:70f7692: 
1:70f7692:         // mark the start of a new row.
1:70f7692:         makeNextRowPositionCurrent();
1:11ee500:         
1:11ee500:         // Moving out of the hole, set isUpdateDeleteHole to false
1:11ee500:         isUpdateDeleteHole_ = false;
1:c247315: 
1:c247315:         isRowUpdated_ = false;
1:70f7692: 
1:70f7692:         // Drive the CNTQRY outside of calculateColumnOffsetsForRow() if the dataBuffer_
1:70f7692:         // contains no data since it has no abilities to handle replies other than
1:70f7692:         // the QRYDTA, i.e. ENDQRYRM when the result set contains no more rows.
1:70f7692:         while (!dataBufferHasUnprocessedData()) {
1:70f7692:             if (allRowsReceivedFromServer_) {
1:70f7692:                 return false;
1:70f7692:             }
1:70f7692:             getMoreData_();
1:70f7692:         }
1:70f7692: 
1:70f7692:         // The parameter passed in here is used as an index into the cached rowset for
1:70f7692:         // scrollable cursors, for the arrays to be reused.  It is not used for forward-only
1:70f7692:         // cursors, so just pass in 0.
1:b13b17c:         boolean rowPositionIsValid =
1:b13b17c:             calculateColumnOffsetsForRow_(0, allowServerFetch);
1:70f7692:         markNextRowPosition();
1:70f7692:         return rowPositionIsValid;
1:70f7692:     }
1:70f7692: 
1:5e88312:     /**
1:5e88312:      * Makes the next row the current row. Returns true if the current
1:5e88312:      * row position is a valid row position.
1:5e88312:      *
1:b13b17c:      * @return {@code true} if current row position is valid
1:5e88312:      * @exception SqlException if an error occurs
1:5e88312:      */
1:5e88312:     public boolean next() throws SqlException {
1:5e88312:         return stepNext(true);
1:5e88312:     }
1:5e88312: 
1:70f7692:     //--------------------------reseting cursor state-----------------------------
1:70f7692: 
1:5e88312:     /**
1:5e88312:      * Set the value of value of allRowsReceivedFromServer_.
1:5e88312:      *
1:b13b17c:      * @param b a {@code boolean} value indicating whether all
1:5e88312:      * rows are received from the server
1:5e88312:      */
1:5e88312:     public void setAllRowsReceivedFromServer(boolean b) {
1:70f7692:         allRowsReceivedFromServer_ = b;
1:70f7692:     }
1:70f7692: 
1:5e88312:     /**
1:b13b17c:      * Return {@code true} if all rows are received from the
1:5e88312:      * server.
1:5e88312:      *
1:b13b17c:      * @return {@code true} if all rows are received from the
1:5e88312:      * server.
1:5e88312:      */
1:5e88312:     public final boolean allRowsReceivedFromServer() {
1:5e88312:         return allRowsReceivedFromServer_;
1:5e88312:     }
1:5e88312: 
1:ee33904:     final boolean currentRowPositionIsEqualToNextRowPosition() {
1:70f7692:         return (currentRowPosition_ == nextRowPosition_);
1:70f7692:     }
1:70f7692: 
1:70f7692:     // reset the beginning and ending position in the data buffer to 0
1:70f7692:     // reset the currentRowPosition and nextRowPosition to 0
1:70f7692:     // reset lastRowReached and sqlcode100Received to false
1:70f7692:     // clear the column data offsets cache
1:70f7692:     public final void resetDataBuffer() {
1:70f7692:         position_ = 0;
1:70f7692:         lastValidBytePosition_ = 0;
1:70f7692:         currentRowPosition_ = 0;
1:70f7692:         nextRowPosition_ = 0;
1:5e88312:         setAllRowsReceivedFromServer(false);
1:70f7692:         dataBufferStream_.reset();
1:70f7692:     }
1:70f7692: 
1:ee33904:     final boolean dataBufferHasUnprocessedData() {
1:70f7692:         return (lastValidBytePosition_ - position_) > 0;
1:70f7692:     }
1:70f7692: 
1:5e88312:     /**
1:5e88312:      * Calculate the column offsets for a row.
1:5e88312:      *
1:5e88312:      * @param row row index
1:5e88312:      * @param allowServerFetch if true, allow fetching more data from
1:5e88312:      * server
1:b13b17c:      * @return {@code true} if the current row position is a
1:5e88312:      * valid row position.
1:5e88312:      * @exception SqlException
1:5e88312:      * @exception DisconnectException
1:5e88312:      */
1:5e88312:     protected abstract boolean
1:5e88312:         calculateColumnOffsetsForRow_(int row, boolean allowServerFetch)
1:5e88312:         throws SqlException, DisconnectException;
1:70f7692: 
1:70f7692:     protected abstract void clearLobData_();
1:70f7692: 
1:70f7692:     protected abstract void getMoreData_() throws SqlException;
1:70f7692: 
1:70f7692:     public final void setIsUpdataDeleteHole(int row, boolean isRowNull) {
1:70f7692:         isUpdateDeleteHole_ = isRowNull;
1:70f7692:         Boolean nullIndicator = (isUpdateDeleteHole_ == true) ? ROW_IS_NULL : ROW_IS_NOT_NULL;
1:70f7692:         if (isUpdateDeleteHoleCache_.size() == row) {
1:70f7692:             isUpdateDeleteHoleCache_.add(nullIndicator);
1:70f7692:         } else {
1:70f7692:             isUpdateDeleteHoleCache_.set(row, nullIndicator);
1:70f7692:         }
1:70f7692:     }
1:c247315: 
1:c247315:     /**
1:c247315:      * Keep track of updated status for this row.
1:c247315:      *
1:c247315:      * @param isRowUpdated true if row has been updated
1:c247315:      *
1:c247315:      * @see Cursor#getIsRowUpdated
1:c247315:      */
1:c247315:     public final void setIsRowUpdated(boolean isRowUpdated) {
1:c247315:         isRowUpdated_ = isRowUpdated;
1:c247315:     }
1:c247315: 
1:c247315:     /**
1:c247315:      * Get updated status for this row. 
1:c247315:      * Minion of ResultSet#rowUpdated.
1:c247315:      *
1:c247315:      * @see Cursor#setIsRowUpdated
1:c247315:      */
1:c247315:     public final boolean getIsRowUpdated() {
1:c247315:         return isRowUpdated_;
1:c247315:     }
1:c247315: 
1:c247315:     /**
1:c247315:      * Get deleted status for this row. 
1:c247315:      * Minion of ResultSet#rowDeleted.
1:c247315:      *
1:c247315:      * @see Cursor#setIsUpdataDeleteHole
1:c247315:      */
1:c247315:     public final boolean getIsUpdateDeleteHole() {
1:c247315:         return isUpdateDeleteHole_;
1:c247315:     }
1:c247315:     
1:70f7692:     //---------------------------cursor positioning-------------------------------
1:70f7692: 
1:0326967:     protected final void markNextRowPosition() {
1:70f7692:         nextRowPosition_ = position_;
1:70f7692:     }
1:70f7692: 
1:0326967:     protected final void makeNextRowPositionCurrent() {
1:70f7692:         currentRowPosition_ = nextRowPosition_;
1:70f7692:     }
1:70f7692: 
1:70f7692:     // This tracks the total number of rows read into the client side buffer for
1:70f7692:     // this result set, irregardless of scrolling.
1:70f7692:     // Per jdbc semantics, this should never exceed statement.maxRows.
1:70f7692:     // This event should be generated in the materialized cursor's implementation
1:70f7692:     // of calculateColumnOffsetsForRow().
1:70f7692:     public final void incrementRowsReadEvent() {
1:70f7692:         rowsRead_++;
1:70f7692:     }
1:70f7692: 
1:70f7692:     //------- the following getters are called on known column types -------------
1:70f7692:     // Direct conversions only, cross conversions are handled by another set of getters.
1:90731d5: 
1:eff3919:     // Build a Java boolean from a 1-byte signed binary representation.
1:0326967:     private boolean get_BOOLEAN(int column) {
1:b13b17c:         if ( SignedBinary.getByte
1:eff3919:              ( dataBuffer_, columnDataPosition_[column - 1] ) == 0 )
1:eff3919:         { return false; }
1:eff3919:         else { return true; }
1:eff3919:     }
1:eff3919: 
1:70f7692:     // Build a Java short from a 2-byte signed binary representation.
1:69e3d06:     private final short get_SMALLINT(int column) {
1:b13b17c:         return SignedBinary.getShort(dataBuffer_,
1:90731d5:                 columnDataPosition_[column - 1]);
1:90731d5:     }
1:70f7692: 
1:70f7692:     // Build a Java int from a 4-byte signed binary representation.
1:1a66a1a:     protected final int get_INTEGER(int column) {
1:b13b17c:         return SignedBinary.getInt(dataBuffer_,
2:70f7692:                 columnDataPosition_[column - 1]);
1:70f7692:     }
1:70f7692: 
1:70f7692:     // Build a Java long from an 8-byte signed binary representation.
1:69e3d06:     private final long get_BIGINT(int column) {
1:b13b17c:         return SignedBinary.getLong(dataBuffer_,
1:70f7692:                 columnDataPosition_[column - 1]);
1:70f7692:     }
1:70f7692: 
1:70f7692:     // Build a Java float from a 4-byte floating point representation.
1:69e3d06:     private final float get_FLOAT(int column) {
1:b13b17c:         return FloatingPoint.getFloat(dataBuffer_,
1:70f7692:                 columnDataPosition_[column - 1]);
1:70f7692:     }
1:70f7692: 
1:70f7692:     // Build a Java double from an 8-byte floating point representation.
1:69e3d06:     private final double get_DOUBLE(int column) {
1:b13b17c:         return FloatingPoint.getDouble(dataBuffer_,
1:70f7692:                 columnDataPosition_[column - 1]);
1:70f7692:     }
1:70f7692: 
1:70f7692:     // Build a java.math.BigDecimal from a fixed point decimal byte representation.
1:69e3d06:     private final BigDecimal get_DECIMAL(int column) throws SqlException {
1:a0b8943:         return Decimal.getBigDecimal(dataBuffer_,
1:a0b8943:                 columnDataPosition_[column - 1],
1:a0b8943:                 getColumnPrecision(column - 1),
1:a0b8943:                 getColumnScale(column - 1));
1:70f7692:     }
1:70f7692: 
1:70f7692: 
1:70f7692:     // Build a Java double from a fixed point decimal byte representation.
1:b13b17c:     private double getDoubleFromDECIMAL(int column) throws SqlException {
4:491c5b6:         try {
1:b13b17c:             return Decimal.getDouble(dataBuffer_,
4:491c5b6:                     columnDataPosition_[column - 1],
2:70f7692:                     getColumnPrecision(column - 1),
2:70f7692:                     getColumnScale(column - 1));
1:69e3d06:         } catch (IllegalArgumentException e) {
1:3d650b1:             throw new SqlException(agent_.logWriter_, 
1:e65b4db:                 new ClientMessageId (SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE),
1:e1a79c3:                 e, "double");
1:70f7692:         }
1:70f7692:     }
1:491c5b6: 
1:70f7692:     // Build a Java long from a fixed point decimal byte representation.
1:b13b17c:     private long getLongFromDECIMAL(int column, String targetType)
1:3419748:             throws SqlException {
1:491c5b6:         try {
1:b13b17c:             return Decimal.getLong(dataBuffer_,
1:491c5b6:                     columnDataPosition_[column - 1],
1:70f7692:                     getColumnPrecision(column - 1),
1:70f7692:                     getColumnScale(column - 1));
1:3419748:         } catch (ArithmeticException e) {
1:3419748:             throw new SqlException(agent_.logWriter_,
1:3419748:                 new ClientMessageId (SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE),
1:e1a79c3:                 e, targetType);
1:69e3d06:         } catch (IllegalArgumentException e) {
1:3d650b1:             throw new SqlException(agent_.logWriter_,
1:e65b4db:                 new ClientMessageId (SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE),
1:e1a79c3:                 e, targetType);
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:70f7692:     // Build a Java String from a database VARCHAR or LONGVARCHAR field.
1:70f7692:     //
1:70f7692:     // Depending on the ccsid, length is the number of chars or number of bytes.
1:70f7692:     // For 2-byte character ccsids, length is the number of characters,
1:70f7692:     // for all other cases length is the number of bytes.
1:70f7692:     // The length does not include the null terminator.
1:b13b17c:     private String getVARCHAR(int column) throws SqlException {
1:a0b8943:         if (ccsid_[column - 1] == 1200) {
1:a0b8943:             return getStringWithoutConvert(columnDataPosition_[column - 1] + 2,
1:a0b8943:                     columnDataComputedLength_[column - 1] - 2);
1:70f7692:         }
1:a0b8943: 
1:a0b8943:         // check for null encoding is needed because the net layer
1:a0b8943:         // will no longer throw an exception if the server didn't specify
1:a0b8943:         // a mixed or double byte ccsid (ccsid = 0).  this check for null in the
1:a0b8943:         // cursor is only required for types which can have mixed or double
1:a0b8943:         // byte ccsids.
1:a0b8943:         if (charset_[column - 1] == null) {
1:a0b8943:             throw new SqlException(agent_.logWriter_,
1:a0b8943:                 new ClientMessageId(SQLState.CHARACTER_CONVERTER_NOT_AVAILABLE));
1:a0b8943:         }
1:a0b8943: 
1:a0b8943:         String tempString = new String(dataBuffer_,
1:a0b8943:                 columnDataPosition_[column - 1] + 2,
1:a0b8943:                 columnDataComputedLength_[column - 1] - 2,
1:a0b8943:                 charset_[column - 1]);
1:a0b8943:         return (maxFieldSize_ == 0) ? tempString :
1:a0b8943:                 tempString.substring(0, Math.min(maxFieldSize_,
1:a0b8943:                                                  tempString.length()));
1:70f7692:     }
1:70f7692: 
1:70f7692:     // Build a Java String from a database CHAR field.
1:b13b17c:     private String getCHAR(int column) throws SqlException {
2:70f7692:         if (ccsid_[column - 1] == 1200) {
1:70f7692:             return getStringWithoutConvert(columnDataPosition_[column - 1], columnDataComputedLength_[column - 1]);
1:70f7692:         }
1:a0b8943: 
1:a0b8943:         // check for null encoding is needed because the net layer
1:a0b8943:         // will no longer throw an exception if the server didn't specify
1:a0b8943:         // a mixed or double byte ccsid (ccsid = 0).  this check for null in the
1:a0b8943:         // cursor is only required for types which can have mixed or double
1:a0b8943:         // byte ccsids.
1:a0b8943:         if (charset_[column - 1] == null) {
1:3d650b1:             throw new SqlException(agent_.logWriter_,
1:a0b8943:                 new ClientMessageId(SQLState.CHARACTER_CONVERTER_NOT_AVAILABLE));
1:70f7692:         }
1:70f7692: 
1:a0b8943:         String tempString = new String(dataBuffer_,
1:a0b8943:                 columnDataPosition_[column - 1],
1:a0b8943:                 columnDataComputedLength_[column - 1],
1:a0b8943:                 charset_[column - 1]);
1:a0b8943:         return (maxFieldSize_ == 0) ? tempString :
1:a0b8943:                 tempString.substring(0, Math.min(maxFieldSize_,
1:a0b8943:                                                  tempString.length()));
1:70f7692:     }
1:70f7692: 
1:70f7692:     // Build a JDBC Date object from the DERBY ISO DATE field.
1:b13b17c:     private Date getDATE(int column, Calendar cal) throws SqlException {
1:a0b8943:         return DateTime.dateBytesToDate(dataBuffer_,
1:a0b8943:             columnDataPosition_[column - 1],
1:a0b8943:             cal,
1:a0b8943:             charset_[column - 1]);
1:491c5b6:     }
1:491c5b6: 
1:70f7692:     // Build a JDBC Time object from the DERBY ISO TIME field.
1:b13b17c:     private Time getTIME(int column, Calendar cal) throws SqlException {
1:a0b8943:         return DateTime.timeBytesToTime(dataBuffer_,
1:a0b8943:                 columnDataPosition_[column - 1],
1:a0b8943:                 cal,
1:a0b8943:                 charset_[column - 1]);
1:491c5b6:     }
1:491c5b6: 
1:70f7692:     // Build a JDBC Timestamp object from the DERBY ISO TIMESTAMP field.
1:69e3d06:     private final Timestamp getTIMESTAMP(int column, Calendar cal)
1:7d521f5:             throws SqlException {
1:a0b8943:         return DateTime.timestampBytesToTimestamp(
1:a0b8943:             dataBuffer_,
1:a0b8943:             columnDataPosition_[column - 1],
1:a0b8943:             cal,
1:a0b8943:             charset_[column - 1],
1:a0b8943:             agent_.connection_.serverSupportsTimestampNanoseconds());
1:491c5b6:     }
1:70f7692: 
1:70f7692:     // Build a JDBC Timestamp object from the DERBY ISO DATE field.
1:69e3d06:     private final Timestamp getTimestampFromDATE(
1:7d521f5:             int column, Calendar cal) throws SqlException {
1:a0b8943:         return DateTime.dateBytesToTimestamp(dataBuffer_,
1:a0b8943:                 columnDataPosition_[column - 1],
1:a0b8943:                 cal,
1:a0b8943:                 charset_[column -1]);
1:491c5b6:     }
1:70f7692: 
1:70f7692:     // Build a JDBC Timestamp object from the DERBY ISO TIME field.
1:69e3d06:     private final Timestamp getTimestampFromTIME(
1:7d521f5:             int column, Calendar cal) throws SqlException {
1:a0b8943:         return DateTime.timeBytesToTimestamp(dataBuffer_,
1:a0b8943:                 columnDataPosition_[column - 1],
1:a0b8943:                 cal,
1:a0b8943:                 charset_[column -1]);
1:491c5b6:     }
1:70f7692: 
1:70f7692:     // Build a JDBC Date object from the DERBY ISO TIMESTAMP field.
1:69e3d06:     private final Date getDateFromTIMESTAMP(int column, Calendar cal)
1:7d521f5:             throws SqlException {
1:a0b8943:         return DateTime.timestampBytesToDate(dataBuffer_,
1:a0b8943:                 columnDataPosition_[column - 1],
1:a0b8943:                 cal,
1:a0b8943:                 charset_[column -1]);
1:491c5b6:     }
1:70f7692: 
1:70f7692:     // Build a JDBC Time object from the DERBY ISO TIMESTAMP field.
1:69e3d06:     private final Time getTimeFromTIMESTAMP(int column, Calendar cal)
1:7d521f5:             throws SqlException {
1:a0b8943:         return DateTime.timestampBytesToTime(dataBuffer_,
1:a0b8943:                 columnDataPosition_[column - 1],
1:a0b8943:                 cal,
1:a0b8943:                 charset_[column -1]);
1:491c5b6:     }
1:70f7692: 
1:b13b17c:     private String getStringFromDATE(int column) throws SqlException {
1:7d521f5:         return getDATE(column, getRecyclableCalendar()).toString();
1:70f7692:     }
1:70f7692: 
1:70f7692:     // Build a string object from the DERBY byte TIME representation.
1:b13b17c:     private String getStringFromTIME(int column) throws SqlException {
1:7d521f5:         return getTIME(column, getRecyclableCalendar()).toString();
1:70f7692:     }
1:70f7692: 
1:70f7692:     // Build a string object from the DERBY byte TIMESTAMP representation.
1:b13b17c:     private String getStringFromTIMESTAMP(int column) throws SqlException {
1:7d521f5:         return getTIMESTAMP(column, getRecyclableCalendar()).toString();
1:70f7692:     }
1:70f7692: 
1:69e3d06:     // Extract bytes from a database Types.BINARY field.
1:70f7692:     // This is the DERBY type CHAR(n) FOR BIT DATA.
1:b13b17c:     private byte[] get_CHAR_FOR_BIT_DATA(int column) throws SqlException {
1:70f7692:         // There is no limit to the size of a column if maxFieldSize is zero.
1:70f7692:         // Otherwise, use the smaller of maxFieldSize and the actual column length.
1:70f7692:         int columnLength = (maxFieldSize_ == 0) ? columnDataComputedLength_[column - 1] :
1:69e3d06:                 Math.min(maxFieldSize_, columnDataComputedLength_[column - 1]);
1:70f7692: 
1:70f7692:         byte[] bytes = new byte[columnLength];
1:70f7692:         System.arraycopy(dataBuffer_, columnDataPosition_[column - 1], bytes, 0, columnLength);
2:70f7692:         return bytes;
1:70f7692:     }
1:70f7692: 
1:69e3d06:     // Extract bytes from a database Types.VARBINARY or LONGVARBINARY field.
1:70f7692:     // This includes the DERBY types:
1:70f7692:     //   VARCHAR(n) FOR BIT DATA
1:70f7692:     //   LONG VARCHAR(n) FOR BIT DATA
1:b13b17c:     private byte[] get_VARCHAR_FOR_BIT_DATA(int column) throws SqlException {
2:70f7692:         byte[] bytes;
1:b13b17c:         int columnLength =
1:b13b17c:             (maxFieldSize_ == 0) ? columnDataComputedLength_[column - 1] - 2 :
1:b13b17c:             Math.min(maxFieldSize_, columnDataComputedLength_[column - 1] - 2);
1:70f7692:         bytes = new byte[columnLength];
2:70f7692:         System.arraycopy(dataBuffer_, columnDataPosition_[column - 1] + 2, bytes, 0, bytes.length);
1:70f7692:         return bytes;
1:70f7692:     }
1:70f7692: 
1:69e3d06:     // Deserialize a UDT from a database Types.JAVA_OBJECT field.
1:506f4c8:     // This is used for user defined types.
1:b13b17c:     private Object get_UDT(int column) throws SqlException {
1:506f4c8:         byte[] bytes;
1:b13b17c:         int columnLength =
1:b13b17c:             (maxFieldSize_ == 0) ? columnDataComputedLength_[column - 1] - 2 :
1:b13b17c:             Math.min(maxFieldSize_, columnDataComputedLength_[column - 1] - 2);
1:506f4c8:         bytes = new byte[columnLength];
1:506f4c8:         System.arraycopy(dataBuffer_, columnDataPosition_[column - 1] + 2, bytes, 0, bytes.length);
1:506f4c8: 
1:506f4c8:         try {
1:506f4c8:             ByteArrayInputStream bais = new ByteArrayInputStream( bytes );
1:506f4c8:             ObjectInputStream ois = new ObjectInputStream( bais );
1:506f4c8: 
1:506f4c8:             return ois.readObject();
1:506f4c8:         }
1:506f4c8:         catch (Exception e)
1:506f4c8:         {
1:506f4c8:             throw new SqlException
1:506f4c8:                 (
1:506f4c8:                  agent_.logWriter_, 
1:506f4c8:                  new ClientMessageId (SQLState.NET_MARSHALLING_UDT_ERROR),
1:e1a79c3:                  e,
1:e1a79c3:                  e.getMessage()
1:506f4c8:                  );
1:506f4c8:         }
1:506f4c8:     }
1:506f4c8: 
1:26b9e3c:     /**
1:26b9e3c:      * Instantiate an instance of Calendar that can be re-used for getting
1:26b9e3c:      * Time, Timestamp, and Date values from this cursor.  Assumption is
1:26b9e3c:      * that all users of the returned Calendar object will clear it as
1:26b9e3c:      * appropriate before using it.
1:26b9e3c:      */
1:69e3d06:     private Calendar getRecyclableCalendar()
1:c6ed70e:     {
1:26b9e3c:         if (recyclableCalendar_ == null)
1:69e3d06:             recyclableCalendar_ = new GregorianCalendar();
1:26b9e3c: 
1:26b9e3c:         return recyclableCalendar_;
1:26b9e3c:     }
1:26b9e3c: 
1:f55d30a:     /**
1:f55d30a:      * Returns a reference to the locator procedures.
1:f55d30a:      * <p>
1:f55d30a:      * These procedures are used to operate on large objects referenced on the
1:f55d30a:      * server by locators.
1:f55d30a:      *
1:f55d30a:      * @return The locator procedures object.
1:f55d30a:      */
1:f55d30a:     CallableLocatorProcedures getLocatorProcedures() {
1:f55d30a:         return agent_.connection_.locatorProcedureCall();
1:f55d30a:     }
1:f55d30a: 
1:f55d30a:     /**
1:c2af295:      * Returns the locator for the specified LOB column, or {@link
1:c2af295:      * Lob#INVALID_LOCATOR} if the LOB was not sent as a locator. The server
1:c2af295:      * may send the LOB value instead of a locator if it is running an old
1:c2af295:      * version which doesn't support locators, or if the database it accesses
1:c2af295:      * is soft upgraded from a version that doesn't have the necessary
1:c2af295:      * stored procedures for locator support.
1:f55d30a:      * <p>
1:f55d30a:      * Note that this method cannot be invoked on a LOB column that is NULL.
1:f55d30a:      *
1:f55d30a:      * @param column 1-based column index
1:f55d30a:      * @return A positive integer locator if valid, {@link Lob#INVALID_LOCATOR}
1:f55d30a:      *      otherwise.
1:f55d30a:      */
1:f55d30a:     protected abstract int locator(int column);
1:f55d30a: 
1:4015c92:     /**
1:4015c92:      * Returns a {@code Blob} object.
1:4015c92:      *
1:4015c92:      * @param column 1-based column index
1:4015c92:      * @param agent associated agent
1:4015c92:      * @param toBePublished whether the Blob will be published to the user
1:4015c92:      * @return A {@linkplain java.sql.Blob Blob} object.
1:4015c92:      * @throws SqlException if getting the {@code Blob} fails
1:4015c92:      */
1:69e3d06:     public abstract ClientBlob getBlobColumn_(int column, Agent agent,
1:4015c92:                                         boolean toBePublished)
1:4015c92:             throws SqlException;
1:70f7692: 
1:4015c92:     /**
1:4015c92:      * Returns a {@code Clob} object.
1:4015c92:      *
1:4015c92:      * @param column 1-based column index
1:4015c92:      * @param agent associated agent
1:4015c92:      * @param toBePublished whether the Clob will be published to the user
1:69e3d06:      * @return A {@code java.sql.Clob} object.
1:4015c92:      * @throws SqlException if getting the {@code Clob} fails
1:4015c92:      */
1:69e3d06:     public abstract ClientClob getClobColumn_(int column, Agent agent,
1:4015c92:                                         boolean toBePublished)
1:4015c92:             throws SqlException;
1:70f7692: 
1:70f7692:     //------- the following getters perform any necessary cross-conversion _------
1:70f7692: 
1:70f7692:     final boolean getBoolean(int column) throws SqlException {
1:c6ed70e:         switch (jdbcTypes_[column - 1]) {
1:69e3d06:         case Types.BOOLEAN:
1:66527ec:             return get_BOOLEAN(column);
1:69e3d06:         case Types.SMALLINT:
1:70f7692:             return agent_.crossConverters_.getBooleanFromShort(get_SMALLINT(column));
1:69e3d06:         case Types.INTEGER:
1:70f7692:             return agent_.crossConverters_.getBooleanFromInt(get_INTEGER(column));
1:69e3d06:         case Types.BIGINT:
1:70f7692:             return agent_.crossConverters_.getBooleanFromLong(get_BIGINT(column));
1:69e3d06:         case Types.REAL:
1:70f7692:             return agent_.crossConverters_.getBooleanFromFloat(get_FLOAT(column));
1:69e3d06:         case Types.DOUBLE:
1:70f7692:             return agent_.crossConverters_.getBooleanFromDouble(get_DOUBLE(column));
1:69e3d06:         case Types.DECIMAL:
1:70f7692:             // For performance we don't materialize the BigDecimal, but convert directly from decimal bytes to a long.
1:3419748:             return agent_.crossConverters_.getBooleanFromLong(
1:3419748:                 getLongFromDECIMAL(column, "boolean"));
1:69e3d06:         case Types.CHAR:
1:70f7692:             return agent_.crossConverters_.getBooleanFromString(getCHAR(column));
1:69e3d06:         case Types.VARCHAR:
1:69e3d06:         case Types.LONGVARCHAR:
1:70f7692:             return agent_.crossConverters_.getBooleanFromString(getVARCHAR(column));
1:d506170:         default:
1:6ef238b:             throw coercionError( "boolean", column );
1:d506170:         }
1:70f7692:     }
1:c6ed70e: 
1:70f7692:     final byte getByte(int column) throws SqlException {
1:70f7692:         // This needs to be changed to use jdbcTypes[]
11:70f7692:         switch (jdbcTypes_[column - 1]) {
1:69e3d06:         case Types.BOOLEAN:
1:eff3919:             return agent_.crossConverters_.getByteFromBoolean(get_BOOLEAN(column));
1:69e3d06:         case Types.SMALLINT:
1:70f7692:             return agent_.crossConverters_.getByteFromShort(get_SMALLINT(column));
1:69e3d06:         case Types.INTEGER:
1:70f7692:             return agent_.crossConverters_.getByteFromInt(get_INTEGER(column));
1:69e3d06:         case Types.BIGINT:
1:70f7692:             return agent_.crossConverters_.getByteFromLong(get_BIGINT(column));
1:69e3d06:         case Types.REAL:
1:70f7692:             return agent_.crossConverters_.getByteFromFloat(get_FLOAT(column));
1:69e3d06:         case Types.DOUBLE:
1:70f7692:             return agent_.crossConverters_.getByteFromDouble(get_DOUBLE(column));
1:69e3d06:         case Types.DECIMAL:
1:70f7692:             // For performance we don't materialize the BigDecimal, but convert directly from decimal bytes to a long.
1:3419748:             return agent_.crossConverters_.getByteFromLong(
1:3419748:                 getLongFromDECIMAL(column, "byte"));
1:69e3d06:         case Types.CHAR:
1:70f7692:             return agent_.crossConverters_.getByteFromString(getCHAR(column));
1:69e3d06:         case Types.VARCHAR:
1:69e3d06:         case Types.LONGVARCHAR:
1:70f7692:             return agent_.crossConverters_.getByteFromString(getVARCHAR(column));
8:70f7692:         default:
1:6ef238b:             throw coercionError( "byte", column );
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:70f7692:     final short getShort(int column) throws SqlException {
1:70f7692:         switch (jdbcTypes_[column - 1]) {
1:69e3d06:         case Types.BOOLEAN:
1:eff3919:             return agent_.crossConverters_.getShortFromBoolean(get_BOOLEAN(column));
1:69e3d06:         case Types.SMALLINT:
1:70f7692:             return get_SMALLINT(column);
1:69e3d06:         case Types.INTEGER:
1:70f7692:             return agent_.crossConverters_.getShortFromInt(get_INTEGER(column));
1:69e3d06:         case Types.BIGINT:
1:70f7692:             return agent_.crossConverters_.getShortFromLong(get_BIGINT(column));
1:69e3d06:         case Types.REAL:
1:70f7692:             return agent_.crossConverters_.getShortFromFloat(get_FLOAT(column));
1:69e3d06:         case Types.DOUBLE:
1:70f7692:             return agent_.crossConverters_.getShortFromDouble(get_DOUBLE(column));
1:69e3d06:         case Types.DECIMAL:
1:70f7692:             // For performance we don't materialize the BigDecimal, but convert directly from decimal bytes to a long.
1:3419748:             return agent_.crossConverters_.getShortFromLong(
1:3419748:                 getLongFromDECIMAL(column, "short"));
1:69e3d06:         case Types.CHAR:
1:70f7692:             return agent_.crossConverters_.getShortFromString(getCHAR(column));
1:69e3d06:         case Types.VARCHAR:
1:69e3d06:         case Types.LONGVARCHAR:
1:70f7692:             return agent_.crossConverters_.getShortFromString(getVARCHAR(column));
1:70f7692:         default:
1:6ef238b:             throw coercionError( "short", column );
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:70f7692:     final int getInt(int column) throws SqlException {
1:70f7692:         switch (jdbcTypes_[column - 1]) {
1:69e3d06:         case Types.BOOLEAN:
1:eff3919:             return agent_.crossConverters_.getIntFromBoolean(get_BOOLEAN(column));
1:69e3d06:         case Types.SMALLINT:
1:70f7692:             return (int) get_SMALLINT(column);
1:69e3d06:         case Types.INTEGER:
1:70f7692:             return get_INTEGER(column);
1:69e3d06:         case Types.BIGINT:
1:70f7692:             return agent_.crossConverters_.getIntFromLong(get_BIGINT(column));
1:69e3d06:         case Types.REAL:
1:70f7692:             return agent_.crossConverters_.getIntFromFloat(get_FLOAT(column));
1:69e3d06:         case Types.DOUBLE:
1:70f7692:             return agent_.crossConverters_.getIntFromDouble(get_DOUBLE(column));
1:69e3d06:         case Types.DECIMAL:
1:70f7692:             // For performance we don't materialize the BigDecimal, but convert directly from decimal bytes to a long.
1:3419748:             return agent_.crossConverters_.getIntFromLong(
1:3419748:                 getLongFromDECIMAL(column, "int"));
1:69e3d06:         case Types.CHAR:
1:70f7692:             return agent_.crossConverters_.getIntFromString(getCHAR(column));
1:69e3d06:         case Types.VARCHAR:
1:69e3d06:         case Types.LONGVARCHAR:
1:70f7692:             return agent_.crossConverters_.getIntFromString(getVARCHAR(column));
1:70f7692:         default:
1:6ef238b:             throw coercionError(  "int", column );
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:70f7692:     final long getLong(int column) throws SqlException {
1:70f7692:         switch (jdbcTypes_[column - 1]) {
1:69e3d06:         case Types.BOOLEAN:
1:eff3919:             return agent_.crossConverters_.getLongFromBoolean(get_BOOLEAN(column));
1:69e3d06:         case Types.SMALLINT:
1:70f7692:             return (long) get_SMALLINT(column);
1:69e3d06:         case Types.INTEGER:
1:70f7692:             return (long) get_INTEGER(column);
1:69e3d06:         case Types.BIGINT:
1:70f7692:             return get_BIGINT(column);
1:69e3d06:         case Types.REAL:
1:70f7692:             return agent_.crossConverters_.getLongFromFloat(get_FLOAT(column));
1:69e3d06:         case Types.DOUBLE:
1:70f7692:             return agent_.crossConverters_.getLongFromDouble(get_DOUBLE(column));
1:69e3d06:         case Types.DECIMAL:
1:70f7692:             // For performance we don't materialize the BigDecimal, but convert directly from decimal bytes to a long.
1:3419748:             return getLongFromDECIMAL(column, "long");
1:69e3d06:         case Types.CHAR:
1:70f7692:             return agent_.crossConverters_.getLongFromString(getCHAR(column));
1:69e3d06:         case Types.VARCHAR:
1:69e3d06:         case Types.LONGVARCHAR:
1:70f7692:             return agent_.crossConverters_.getLongFromString(getVARCHAR(column));
1:70f7692:         default:
1:6ef238b:             throw coercionError( "long", column );
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:70f7692:     final float getFloat(int column) throws SqlException {
1:70f7692:         switch (jdbcTypes_[column - 1]) {
1:69e3d06:         case Types.BOOLEAN:
1:eff3919:             return agent_.crossConverters_.getFloatFromBoolean(get_BOOLEAN(column));
1:69e3d06:         case Types.REAL:
1:70f7692:             return get_FLOAT(column);
1:69e3d06:         case Types.DOUBLE:
1:70f7692:             return agent_.crossConverters_.getFloatFromDouble(get_DOUBLE(column));
1:69e3d06:         case Types.DECIMAL:
1:70f7692:             // For performance we don't materialize the BigDecimal, but convert directly from decimal bytes to a long.
1:70f7692:             return agent_.crossConverters_.getFloatFromDouble(getDoubleFromDECIMAL(column));
1:69e3d06:         case Types.SMALLINT:
1:70f7692:             return (float) get_SMALLINT(column);
1:69e3d06:         case Types.INTEGER:
1:70f7692:             return (float) get_INTEGER(column);
1:69e3d06:         case Types.BIGINT:
1:70f7692:             return (float) get_BIGINT(column);
1:69e3d06:         case Types.CHAR:
1:70f7692:             return agent_.crossConverters_.getFloatFromString(getCHAR(column));
1:69e3d06:         case Types.VARCHAR:
1:69e3d06:         case Types.LONGVARCHAR:
1:70f7692:             return agent_.crossConverters_.getFloatFromString(getVARCHAR(column));
1:70f7692:         default:
1:6ef238b:             throw coercionError( "float", column );
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:70f7692:     final double getDouble(int column) throws SqlException {
1:70f7692:         switch (jdbcTypes_[column - 1]) {
1:69e3d06:         case Types.BOOLEAN:
1:eff3919:             return agent_.crossConverters_.getDoubleFromBoolean(get_BOOLEAN(column));
1:69e3d06:         case Types.REAL:
1:70f7692:             double d = (double) get_FLOAT(column);
1:70f7692:             return d;
1:70f7692:             //return (double) get_FLOAT (column);
1:69e3d06:         case Types.DOUBLE:
1:70f7692:             return get_DOUBLE(column);
1:69e3d06:         case Types.DECIMAL:
1:70f7692:             // For performance we don't materialize the BigDecimal, but convert directly from decimal bytes to a long.
1:70f7692:             return getDoubleFromDECIMAL(column);
1:69e3d06:         case Types.SMALLINT:
1:70f7692:             return (double) get_SMALLINT(column);
1:69e3d06:         case Types.INTEGER:
1:70f7692:             return (double) get_INTEGER(column);
1:69e3d06:         case Types.BIGINT:
1:70f7692:             return (double) get_BIGINT(column);
1:69e3d06:         case Types.CHAR:
1:70f7692:             return agent_.crossConverters_.getDoubleFromString(getCHAR(column));
1:69e3d06:         case Types.VARCHAR:
1:69e3d06:         case Types.LONGVARCHAR:
1:70f7692:             return agent_.crossConverters_.getDoubleFromString(getVARCHAR(column));
1:70f7692:         default:
1:6ef238b:             throw coercionError( "double", column );
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:69e3d06:     final BigDecimal getBigDecimal(int column) throws SqlException {
1:70f7692:         switch (jdbcTypes_[column - 1]) {
1:69e3d06:         case Types.BOOLEAN:
1:69e3d06:             return BigDecimal.valueOf(getLong(column));
1:69e3d06:         case Types.DECIMAL:
1:70f7692:             return get_DECIMAL(column);
1:69e3d06:         case Types.REAL:
2:70f7692:             // Can't use the following commented out line because it changes precision of the result.
1:70f7692:             //return new java.math.BigDecimal (get_FLOAT (column));
1:70f7692:             float f = get_FLOAT(column);
1:69e3d06:             return new BigDecimal(String.valueOf(f));
1:69e3d06:         case Types.DOUBLE:
1:69e3d06:             return BigDecimal.valueOf(get_DOUBLE(column));
1:69e3d06:         case Types.SMALLINT:
1:69e3d06:             return BigDecimal.valueOf(get_SMALLINT(column));
1:69e3d06:         case Types.INTEGER:
1:69e3d06:             return BigDecimal.valueOf(get_INTEGER(column));
1:69e3d06:         case Types.BIGINT:
1:69e3d06:             return BigDecimal.valueOf(get_BIGINT(column));
1:69e3d06:         case Types.CHAR:
1:70f7692:             return agent_.crossConverters_.getBigDecimalFromString(getCHAR(column));
1:69e3d06:         case Types.VARCHAR:
1:69e3d06:         case Types.LONGVARCHAR:
1:70f7692:             return agent_.crossConverters_.getBigDecimalFromString(getVARCHAR(column));
1:70f7692:         default:
1:6ef238b:             throw coercionError( "java.math.BigDecimal", column );
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:69e3d06:     final Date getDate(int column, Calendar cal) throws SqlException {
1:70f7692:         switch (jdbcTypes_[column - 1]) {
1:69e3d06:         case Types.DATE:
1:7d521f5:             return getDATE(column, cal);
1:69e3d06:         case Types.TIMESTAMP:
1:7d521f5:             return getDateFromTIMESTAMP(column, cal);
1:69e3d06:         case Types.CHAR:
1:7d521f5:             return agent_.crossConverters_.
1:7d521f5:                     getDateFromString(getCHAR(column), cal);
1:69e3d06:         case Types.VARCHAR:
1:69e3d06:         case Types.LONGVARCHAR:
1:7d521f5:             return agent_.crossConverters_.
1:7d521f5:                     getDateFromString(getVARCHAR(column), cal);
1:70f7692:         default:
1:6ef238b:             throw coercionError( "java.sql.Date", column );
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:69e3d06:     final Time getTime(int column, Calendar cal) throws SqlException {
1:70f7692:         switch (jdbcTypes_[column - 1]) {
1:69e3d06:         case Types.TIME:
1:7d521f5:             return getTIME(column, cal);
1:69e3d06:         case Types.TIMESTAMP:
1:7d521f5:             return getTimeFromTIMESTAMP(column, cal);
1:69e3d06:         case Types.CHAR:
1:7d521f5:             return agent_.crossConverters_.
1:7d521f5:                     getTimeFromString(getCHAR(column), cal);
1:69e3d06:         case Types.VARCHAR:
1:69e3d06:         case Types.LONGVARCHAR:
1:7d521f5:             return agent_.crossConverters_.
1:7d521f5:                     getTimeFromString(getVARCHAR(column), cal);
1:70f7692:         default:
1:6ef238b:             throw coercionError( "java.sql.Time", column );
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:69e3d06:     final Timestamp getTimestamp(int column, Calendar cal)
1:7d521f5:             throws SqlException {
1:70f7692:         switch (jdbcTypes_[column - 1]) {
1:69e3d06:         case Types.TIMESTAMP:
1:7d521f5:             return getTIMESTAMP(column, cal);
1:69e3d06:         case Types.DATE:
1:7d521f5:             return getTimestampFromDATE(column, cal);
1:69e3d06:         case Types.TIME:
1:7d521f5:             return getTimestampFromTIME(column, cal);
1:69e3d06:         case Types.CHAR:
1:7d521f5:             return agent_.crossConverters_.
1:7d521f5:                     getTimestampFromString(getCHAR(column), cal);
1:69e3d06:         case Types.VARCHAR:
1:69e3d06:         case Types.LONGVARCHAR:
1:7d521f5:             return agent_.crossConverters_.
1:7d521f5:                     getTimestampFromString(getVARCHAR(column), cal);
1:70f7692:         default:
1:6ef238b:             throw coercionError( "java.sql.Timestamp", column );
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:70f7692:     final String getString(int column) throws SqlException {
1:491c5b6:         try {
1:b13b17c:             String tempString;
1:d506170:             switch (jdbcTypes_[column - 1]) {
1:69e3d06:             case Types.BOOLEAN:
1:eff3919:                 if ( get_BOOLEAN( column ) ) { return Boolean.TRUE.toString(); }
1:eff3919:                 else { return Boolean.FALSE.toString(); }
1:69e3d06:             case Types.CHAR:
1:d506170:                 return getCHAR(column);
1:69e3d06:             case Types.VARCHAR:
1:69e3d06:             case Types.LONGVARCHAR:
1:d506170:                 return getVARCHAR(column);
1:70f7692: 
1:69e3d06:             case Types.SMALLINT:
1:d506170:                 return String.valueOf(get_SMALLINT(column));
1:69e3d06:             case Types.INTEGER:
1:d506170:                 return String.valueOf(get_INTEGER(column));
1:69e3d06:             case Types.BIGINT:
1:d506170:                 return String.valueOf(get_BIGINT(column));
1:69e3d06:             case Types.REAL:
1:d506170:                 return String.valueOf(get_FLOAT(column));
1:69e3d06:             case Types.DOUBLE:
1:d506170:                 return String.valueOf(get_DOUBLE(column));
1:69e3d06:             case Types.DECIMAL:
1:d506170:                 // We could get better performance here if we didn't materialize the BigDecimal,
1:d506170:                 // but converted directly from decimal bytes to a string.
1:d506170:                 return String.valueOf(get_DECIMAL(column));
1:69e3d06:             case Types.DATE:
1:d506170:                 return getStringFromDATE(column);
1:69e3d06:             case Types.TIME:
1:d506170:                 return getStringFromTIME(column);
1:69e3d06:             case Types.TIMESTAMP:
1:d506170:                 return getStringFromTIMESTAMP(column);
1:69e3d06:             case ClientTypes.BINARY:
1:d506170:                 tempString =
1:d506170:                         agent_.crossConverters_.getStringFromBytes(get_CHAR_FOR_BIT_DATA(column));
1:d506170:                 return (maxFieldSize_ == 0) ? tempString :
1:69e3d06:                         tempString.substring(0, Math.min(maxFieldSize_,
1:69e3d06:                                                          tempString.length()));
1:69e3d06:             case Types.VARBINARY:
1:69e3d06:             case Types.LONGVARBINARY:
1:d506170:                 tempString =
1:d506170:                         agent_.crossConverters_.getStringFromBytes(get_VARCHAR_FOR_BIT_DATA(column));
1:d506170:                 return (maxFieldSize_ == 0) ? tempString :
1:69e3d06:                         tempString.substring(0, Math.min(maxFieldSize_,
1:69e3d06:                                                          tempString.length()));
1:69e3d06:             case Types.JAVA_OBJECT:
1:506f4c8:                 Object obj = get_UDT( column );
1:506f4c8:                 if ( obj == null ) { return null; }
1:506f4c8:                 else { return obj.toString(); }
1:69e3d06:             case Types.BLOB:
1:69e3d06:                 ClientBlob b = getBlobColumn_(column, agent_, false);
1:c6ed70e:                 tempString = agent_.crossConverters_.
1:c6ed70e:                         getStringFromBytes(b.getBytes(1, (int) b.length()));
1:c6ed70e:                 return tempString;
1:69e3d06:             case Types.CLOB:
1:69e3d06:                 ClientClob c = getClobColumn_(column, agent_, false);
1:c6ed70e:                 tempString = c.getSubString(1, (int) c.length());
1:c6ed70e:                 return tempString;
1:d506170:             default:
1:6ef238b:                 throw coercionError( "String", column );
1:d506170:             }
4:d506170:         } catch ( SQLException se ) {
5:d506170:             throw new SqlException(se);
1:d506170:         }
1:d506170:     }
1:70f7692: 
1:70f7692:     final byte[] getBytes(int column) throws SqlException {
1:491c5b6:         try {
1:d506170:             switch (jdbcTypes_[column - 1]) {
1:69e3d06:             case Types.BINARY:
1:d506170:                 return get_CHAR_FOR_BIT_DATA(column);
1:69e3d06:             case Types.VARBINARY:
1:69e3d06:             case Types.LONGVARBINARY:
1:d506170:                 return get_VARCHAR_FOR_BIT_DATA(column);
1:69e3d06:             case Types.BLOB:
1:69e3d06:                 ClientBlob b = getBlobColumn_(column, agent_, false);
1:c6ed70e:                 byte[] bytes = b.getBytes(1, (int) b.length());
1:c6ed70e:                 return bytes;
1:d506170:             default:
1:6ef238b:                 throw coercionError( "byte[]", column );
1:d506170:             }
1:d506170:         } catch ( SQLException se ) {
1:d506170:             throw new SqlException(se);
1:d506170:         }
1:d506170:     }
1:70f7692: 
1:b13b17c:     final InputStream getBinaryStream(int column) throws SqlException
1:26b9e3c:     {
1:d506170:         switch (jdbcTypes_[column - 1]) {
1:69e3d06:             case Types.BINARY:
1:69e3d06:                 return new ByteArrayInputStream(get_CHAR_FOR_BIT_DATA(column));
1:69e3d06:             case Types.VARBINARY:
1:69e3d06:             case Types.LONGVARBINARY:
1:69e3d06:                 return
1:69e3d06:                     new ByteArrayInputStream(get_VARCHAR_FOR_BIT_DATA(column));
1:69e3d06:             case Types.BLOB:
1:69e3d06:                 ClientBlob b = getBlobColumn_(column, agent_, false);
1:c6ed70e:                 if (b.isLocator()) {
1:c6ed70e:                     BlobLocatorInputStream is 
1:c6ed70e:                             = new BlobLocatorInputStream(agent_.connection_, b);
1:c6ed70e:                     return new BufferedInputStream(is);
1:c6ed70e:                 } else {
1:c6ed70e:                     return b.getBinaryStreamX();
1:c6ed70e:                 }
1:d506170:             default:
1:6ef238b:                 throw coercionError( "java.io.InputStream", column );
1:d506170:         }
1:d506170:     }
1:70f7692: 
1:b13b17c:     final InputStream getAsciiStream(int column) throws SqlException
1:c6ed70e:     {
1:c6ed70e:         switch (jdbcTypes_[column - 1]) {
1:69e3d06:             case Types.CLOB:
1:69e3d06:                 ClientClob c = getClobColumn_(column, agent_, false);
1:c6ed70e:                 if (c.isLocator()) {
1:c6ed70e:                     ClobLocatorInputStream is 
1:c6ed70e:                             = new ClobLocatorInputStream(agent_.connection_, c);
1:c6ed70e:                     return new BufferedInputStream(is);
1:c6ed70e:                 } else {
1:c6ed70e:                     return c.getAsciiStreamX();
1:d506170:                 }
1:69e3d06:             case Types.CHAR:
1:a0b8943:                 return new ByteArrayInputStream(
1:a0b8943:                         getCHAR(column).getBytes(ISO_8859_1));
1:69e3d06:             case Types.VARCHAR:
1:69e3d06:             case Types.LONGVARCHAR:
1:a0b8943:                 return new ByteArrayInputStream(
1:a0b8943:                         getVARCHAR(column).getBytes(ISO_8859_1));
1:69e3d06:             case Types.BINARY:
1:69e3d06:                 return new ByteArrayInputStream(get_CHAR_FOR_BIT_DATA(column));
1:69e3d06:             case Types.VARBINARY:
1:69e3d06:             case Types.LONGVARBINARY:
1:69e3d06:                 return
1:69e3d06:                     new ByteArrayInputStream(get_VARCHAR_FOR_BIT_DATA(column));
1:69e3d06:             case Types.BLOB:
1:c6ed70e:                 return getBinaryStream(column);
1:d506170:             default:
1:6ef238b:                 throw coercionError( "java.io.InputStream", column );
1:d506170:         }
1:d506170:     }
1:70f7692:  
1:b13b17c:     final Reader getCharacterStream(int column)
2:c6ed70e:             throws SqlException 
1:c6ed70e:     {
1:c6ed70e:         switch (jdbcTypes_[column - 1]) {
1:69e3d06:             case Types.CLOB:
1:69e3d06:                 ClientClob c = getClobColumn_(column, agent_, false);
1:c6ed70e:                 if (c.isLocator()) {
1:c6ed70e:                     ClobLocatorReader reader
1:c6ed70e:                             = new ClobLocatorReader(agent_.connection_, c);
1:c6ed70e:                     return new BufferedReader(reader);
1:c6ed70e:                 } else {
1:c6ed70e:                     return c.getCharacterStreamX();
1:c6ed70e:                 }
1:69e3d06:             case Types.CHAR:
1:69e3d06:                 return new StringReader(getCHAR(column));
1:69e3d06:             case Types.VARCHAR:
1:69e3d06:             case Types.LONGVARCHAR:
1:69e3d06:                 return new StringReader(getVARCHAR(column));
1:69e3d06:             case Types.BINARY:
1:a0b8943:                 return new InputStreamReader(
1:a0b8943:                     new ByteArrayInputStream(
1:a0b8943:                         get_CHAR_FOR_BIT_DATA(column)), UTF_16BE);
1:69e3d06:             case Types.VARBINARY:
1:69e3d06:             case Types.LONGVARBINARY:
1:a0b8943:                 return new InputStreamReader(
1:a0b8943:                     new ByteArrayInputStream(
1:a0b8943:                         get_VARCHAR_FOR_BIT_DATA(column)), UTF_16BE);
1:69e3d06:             case Types.BLOB:
1:a0b8943:                 return new InputStreamReader(getBinaryStream(column), UTF_16BE);
1:d506170:             default:
1:6ef238b:                 throw coercionError( "java.io.Reader", column );
1:c6ed70e:             }
1:d506170:     }
1:70f7692: 
1:69e3d06:     final Blob getBlob(int column) throws SqlException {
1:d506170:         switch (jdbcTypes_[column - 1]) {
1:69e3d06:         case ClientTypes.BLOB:
1:4015c92:             return getBlobColumn_(column, agent_, true);
1:70f7692:         default:
1:6ef238b:             throw coercionError( "java.sql.Blob", column );
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:69e3d06:     final Clob getClob(int column) throws SqlException {
1:d506170:         switch (jdbcTypes_[column - 1]) {
1:69e3d06:         case ClientTypes.CLOB:
1:4015c92:             return getClobColumn_(column, agent_, true);
1:70f7692:         default:
1:6ef238b:             throw coercionError( "java.sql.Clob", column );
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:b13b17c:     final Array getArray(int column) throws SqlException {
1:3d650b1:         throw new SqlException(agent_.logWriter_, 
1:e65b4db:             new ClientMessageId (SQLState.NOT_IMPLEMENTED),
1:3d650b1:             "getArray(int)");
1:70f7692:     }
1:70f7692: 
1:b13b17c:     final Ref getRef(int column) throws SqlException {
1:3d650b1:         throw new SqlException(agent_.logWriter_, 
1:e65b4db:             new ClientMessageId (SQLState.NOT_IMPLEMENTED), "getRef(int)");
1:70f7692:     }
1:70f7692: 
1:ee33904:     final Object getObject(int column) throws SqlException {
1:d506170:         switch (jdbcTypes_[column - 1]) {
1:69e3d06:         case Types.BOOLEAN:
1:eff3919:             return get_BOOLEAN(column);
1:69e3d06:         case Types.SMALLINT:
1:66527ec:             // See Table 4 in JDBC 1 spec (pg. 932 in jdbc book)
1:66527ec:             return Integer.valueOf(get_SMALLINT(column));
1:69e3d06:         case Types.INTEGER:
1:66527ec:             return get_INTEGER(column);
1:69e3d06:         case Types.BIGINT:
1:66527ec:             return get_BIGINT(column);
1:69e3d06:         case Types.REAL:
1:66527ec:             return get_FLOAT(column);
1:69e3d06:         case Types.DOUBLE:
1:66527ec:             return get_DOUBLE(column);
1:69e3d06:         case Types.DECIMAL:
1:70f7692:             return get_DECIMAL(column);
1:69e3d06:         case Types.DATE:
1:7d521f5:             return getDATE(column, getRecyclableCalendar());
1:69e3d06:         case Types.TIME:
1:7d521f5:             return getTIME(column, getRecyclableCalendar());
1:69e3d06:         case Types.TIMESTAMP:
1:7d521f5:             return getTIMESTAMP(column, getRecyclableCalendar());
1:69e3d06:         case Types.CHAR:
2:70f7692:             return getCHAR(column);
1:69e3d06:         case Types.VARCHAR:
1:69e3d06:         case Types.LONGVARCHAR:
2:70f7692:             return getVARCHAR(column);
1:69e3d06:         case ClientTypes.BINARY:
2:70f7692:             return get_CHAR_FOR_BIT_DATA(column);
1:69e3d06:         case Types.VARBINARY:
1:69e3d06:         case Types.LONGVARBINARY:
2:70f7692:             return get_VARCHAR_FOR_BIT_DATA(column);
1:69e3d06:         case Types.JAVA_OBJECT:
1:506f4c8:             return get_UDT( column );
1:69e3d06:         case Types.BLOB:
1:4015c92:             return getBlobColumn_(column, agent_, true);
1:69e3d06:         case Types.CLOB:
1:4015c92:             return getClobColumn_(column, agent_, true);
1:70f7692:         default:
1:6ef238b:             throw coercionError( "Object", column );
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:70f7692:     public final void allocateCharBuffer() {
1:70f7692:         // compute the maximum char length
1:70f7692:         int maxCharLength = 0;
1:70f7692:         for (int i = 0; i < columns_; i++) {
1:70f7692:             switch (jdbcTypes_[i]) {
1:69e3d06:             case ClientTypes.CHAR:
1:69e3d06:             case ClientTypes.VARCHAR:
1:69e3d06:             case ClientTypes.LONGVARCHAR:
1:70f7692:                 if (fdocaLength_[i] > maxCharLength) {
1:70f7692:                     maxCharLength = fdocaLength_[i];
1:70f7692:                 }
1:70f7692:             }
1:70f7692:         }
1:70f7692: 
1:70f7692:         // allocate char buffer to accomodate largest result column
1:70f7692:         charBuffer_ = new char[maxCharLength];
1:70f7692:     }
1:70f7692: 
1:ee33904:     private String getStringWithoutConvert(int position, int actualLength) {
1:70f7692:         int start = position;
1:70f7692:         int end = position + actualLength;
1:70f7692: 
1:70f7692:         int charCount = 0;
1:70f7692:         while (start < end) {
1:70f7692:             charBuffer_[charCount++] = (char) (((dataBuffer_[start] & 0xff) << 8) | (dataBuffer_[start + 1] & 0xff));
1:70f7692:             start += 2;
1:70f7692:         }
1:70f7692: 
1:70f7692:         return new String(charBuffer_, 0, charCount);
1:70f7692:     }
1:70f7692: 
1:6ef238b:     private ColumnTypeConversionException coercionError
1:6ef238b:         ( String targetType, int sourceColumn )
1:6ef238b:     {
1:6ef238b:         return new ColumnTypeConversionException
1:69e3d06:             (agent_.logWriter_,
1:69e3d06:              targetType,
1:69e3d06:              ClientTypes.getTypeString(jdbcTypes_[sourceColumn -1]));
1:6ef238b:     }
1:6ef238b: 
1:70f7692:     public void nullDataForGC() {
1:70f7692:         dataBuffer_ = null;
1:70f7692:         dataBufferStream_ = null;
1:70f7692:         columnDataPosition_ = null;
1:70f7692:         columnDataComputedLength_ = null;
1:70f7692:         columnDataPositionCache_ = null;
1:70f7692:         columnDataLengthCache_ = null;
1:70f7692:         columnDataIsNullCache_ = null;
1:70f7692:         jdbcTypes_ = null;
1:70f7692:         nullable_ = null;
1:a0b8943:         charset_ = null;
1:70f7692:         this.ccsid_ = null;
1:70f7692:         isUpdateDeleteHoleCache_ = null;
1:70f7692:         isNull_ = null;
1:70f7692:         fdocaLength_ = null;
1:70f7692:         charBuffer_ = null;
1:70f7692:     }
1:70f7692: 
1:ee33904:     private int getColumnPrecision(int column) {
1:70f7692:         return ((fdocaLength_[column] >> 8) & 0xff);
1:70f7692:     }
1:70f7692: 
1:ee33904:     private int getColumnScale(int column) {
1:70f7692:         return (fdocaLength_[column] & 0xff);
1:70f7692:     }
1:70f7692: }
============================================================================
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:e1a79c3
/////////////////////////////////////////////////////////////////////////
1:                 e, "double");
/////////////////////////////////////////////////////////////////////////
1:                 e, targetType);
1:                 e, targetType);
/////////////////////////////////////////////////////////////////////////
1:                  e,
1:                  e.getMessage()
commit:a0b8943
/////////////////////////////////////////////////////////////////////////
1: import java.nio.charset.Charset;
/////////////////////////////////////////////////////////////////////////
1:     // Charsets
1:     static final Charset UTF_16BE = Charset.forName("UTF-16BE");
1:     static final Charset UTF_8 = Charset.forName("UTF-8");
1:     static final Charset ISO_8859_1 = Charset.forName("ISO-8859-1");
1: 
/////////////////////////////////////////////////////////////////////////
1:     public Charset[] charset_;
/////////////////////////////////////////////////////////////////////////
1:         charset_ = new Charset[numberOfColumns];
/////////////////////////////////////////////////////////////////////////
1:         return Decimal.getBigDecimal(dataBuffer_,
1:                 columnDataPosition_[column - 1],
1:                 getColumnPrecision(column - 1),
1:                 getColumnScale(column - 1));
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         if (ccsid_[column - 1] == 1200) {
1:             return getStringWithoutConvert(columnDataPosition_[column - 1] + 2,
1:                     columnDataComputedLength_[column - 1] - 2);
1: 
1:         // check for null encoding is needed because the net layer
1:         // will no longer throw an exception if the server didn't specify
1:         // a mixed or double byte ccsid (ccsid = 0).  this check for null in the
1:         // cursor is only required for types which can have mixed or double
1:         // byte ccsids.
1:         if (charset_[column - 1] == null) {
1:             throw new SqlException(agent_.logWriter_,
1:                 new ClientMessageId(SQLState.CHARACTER_CONVERTER_NOT_AVAILABLE));
1:         }
1: 
1:         String tempString = new String(dataBuffer_,
1:                 columnDataPosition_[column - 1] + 2,
1:                 columnDataComputedLength_[column - 1] - 2,
1:                 charset_[column - 1]);
1:         return (maxFieldSize_ == 0) ? tempString :
1:                 tempString.substring(0, Math.min(maxFieldSize_,
1:                                                  tempString.length()));
/////////////////////////////////////////////////////////////////////////
1:         // check for null encoding is needed because the net layer
1:         // will no longer throw an exception if the server didn't specify
1:         // a mixed or double byte ccsid (ccsid = 0).  this check for null in the
1:         // cursor is only required for types which can have mixed or double
1:         // byte ccsids.
1:         if (charset_[column - 1] == null) {
1:                 new ClientMessageId(SQLState.CHARACTER_CONVERTER_NOT_AVAILABLE));
1: 
1:         String tempString = new String(dataBuffer_,
1:                 columnDataPosition_[column - 1],
1:                 columnDataComputedLength_[column - 1],
1:                 charset_[column - 1]);
1:         return (maxFieldSize_ == 0) ? tempString :
1:                 tempString.substring(0, Math.min(maxFieldSize_,
1:                                                  tempString.length()));
1:         return DateTime.dateBytesToDate(dataBuffer_,
1:             columnDataPosition_[column - 1],
1:             cal,
1:             charset_[column - 1]);
1:         return DateTime.timeBytesToTime(dataBuffer_,
1:                 columnDataPosition_[column - 1],
1:                 cal,
1:                 charset_[column - 1]);
1:         return DateTime.timestampBytesToTimestamp(
1:             dataBuffer_,
1:             columnDataPosition_[column - 1],
1:             cal,
1:             charset_[column - 1],
1:             agent_.connection_.serverSupportsTimestampNanoseconds());
1:         return DateTime.dateBytesToTimestamp(dataBuffer_,
1:                 columnDataPosition_[column - 1],
1:                 cal,
1:                 charset_[column -1]);
1:         return DateTime.timeBytesToTimestamp(dataBuffer_,
1:                 columnDataPosition_[column - 1],
1:                 cal,
1:                 charset_[column -1]);
1:         return DateTime.timestampBytesToDate(dataBuffer_,
1:                 columnDataPosition_[column - 1],
1:                 cal,
1:                 charset_[column -1]);
1:         return DateTime.timestampBytesToTime(dataBuffer_,
1:                 columnDataPosition_[column - 1],
1:                 cal,
1:                 charset_[column -1]);
/////////////////////////////////////////////////////////////////////////
1:                 return new ByteArrayInputStream(
1:                         getCHAR(column).getBytes(ISO_8859_1));
1:                 return new ByteArrayInputStream(
1:                         getVARCHAR(column).getBytes(ISO_8859_1));
/////////////////////////////////////////////////////////////////////////
1:                 return new InputStreamReader(
1:                     new ByteArrayInputStream(
1:                         get_CHAR_FOR_BIT_DATA(column)), UTF_16BE);
1:                 return new InputStreamReader(
1:                     new ByteArrayInputStream(
1:                         get_VARCHAR_FOR_BIT_DATA(column)), UTF_16BE);
1:                 return new InputStreamReader(getBinaryStream(column), UTF_16BE);
/////////////////////////////////////////////////////////////////////////
1:         charset_ = null;
commit:4020781
/////////////////////////////////////////////////////////////////////////
0:             return java.math.BigDecimal.valueOf(get_DOUBLE(column));
commit:66527ec
/////////////////////////////////////////////////////////////////////////
1:             return get_BOOLEAN(column);
1:             // See Table 4 in JDBC 1 spec (pg. 932 in jdbc book)
1:             return Integer.valueOf(get_SMALLINT(column));
1:             return get_INTEGER(column);
1:             return get_BIGINT(column);
1:             return get_FLOAT(column);
1:             return get_DOUBLE(column);
commit:4772c7e
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayList;
/////////////////////////////////////////////////////////////////////////
1:     protected ArrayList<int[]> columnDataPositionCache_ = new ArrayList<int[]>();
1:     protected ArrayList<int[]> columnDataLengthCache_ = new ArrayList<int[]>();
1:     protected ArrayList<boolean[]> columnDataIsNullCache_ = new ArrayList<boolean[]>();
1:     ArrayList<Boolean> isUpdateDeleteHoleCache_ = new ArrayList<Boolean>();
1:     boolean isUpdateDeleteHole_;
1:     final static Boolean ROW_IS_NULL = Boolean.TRUE;
0:     final static Boolean ROW_IS_NOT_NULL = Boolean.FALSE;
commit:5250aca
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:2349a90
/////////////////////////////////////////////////////////////////////////
0:     private final String getStringWithoutConvert(int position, int actualLength) {
commit:54b4e5f
/////////////////////////////////////////////////////////////////////////
0:             return java.math.BigDecimal.valueOf(getLong(column));
commit:7d521f5
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Date;
1: import java.sql.Time;
1: import java.util.Calendar;
/////////////////////////////////////////////////////////////////////////
0:     private final Date getDATE(int column, Calendar cal) throws SqlException {
0:                 cal,
/////////////////////////////////////////////////////////////////////////
0:     private final Time getTIME(int column, Calendar cal) throws SqlException {
0:                     cal,
/////////////////////////////////////////////////////////////////////////
0:     private final java.sql.Timestamp getTIMESTAMP(int column, Calendar cal)
1:             throws SqlException {
0:                 cal,
/////////////////////////////////////////////////////////////////////////
0:     private final java.sql.Timestamp getTimestampFromDATE(
1:             int column, Calendar cal) throws SqlException {
0:                     cal,
/////////////////////////////////////////////////////////////////////////
0:     private final java.sql.Timestamp getTimestampFromTIME(
1:             int column, Calendar cal) throws SqlException {
0:                     cal,
/////////////////////////////////////////////////////////////////////////
0:     private final java.sql.Date getDateFromTIMESTAMP(int column, Calendar cal)
1:             throws SqlException {
0:                     cal,
/////////////////////////////////////////////////////////////////////////
0:     private final java.sql.Time getTimeFromTIMESTAMP(int column, Calendar cal)
1:             throws SqlException {
0:                     cal,
/////////////////////////////////////////////////////////////////////////
1:         return getDATE(column, getRecyclableCalendar()).toString();
1:         return getTIME(column, getRecyclableCalendar()).toString();
1:         return getTIMESTAMP(column, getRecyclableCalendar()).toString();
/////////////////////////////////////////////////////////////////////////
0:     final java.sql.Date getDate(int column, Calendar cal) throws SqlException {
1:             return getDATE(column, cal);
1:             return getDateFromTIMESTAMP(column, cal);
1:             return agent_.crossConverters_.
1:                     getDateFromString(getCHAR(column), cal);
1:             return agent_.crossConverters_.
1:                     getDateFromString(getVARCHAR(column), cal);
0:     final java.sql.Time getTime(int column, Calendar cal) throws SqlException {
1:             return getTIME(column, cal);
1:             return getTimeFromTIMESTAMP(column, cal);
1:             return agent_.crossConverters_.
1:                     getTimeFromString(getCHAR(column), cal);
1:             return agent_.crossConverters_.
1:                     getTimeFromString(getVARCHAR(column), cal);
0:     final java.sql.Timestamp getTimestamp(int column, Calendar cal)
1:             throws SqlException {
1:             return getTIMESTAMP(column, cal);
1:             return getTimestampFromDATE(column, cal);
1:             return getTimestampFromTIME(column, cal);
1:             return agent_.crossConverters_.
1:                     getTimestampFromString(getCHAR(column), cal);
1:             return agent_.crossConverters_.
1:                     getTimestampFromString(getVARCHAR(column), cal);
/////////////////////////////////////////////////////////////////////////
1:             return getDATE(column, getRecyclableCalendar());
1:             return getTIME(column, getRecyclableCalendar());
1:             return getTIMESTAMP(column, getRecyclableCalendar());
commit:c2af295
/////////////////////////////////////////////////////////////////////////
1:      * Returns the locator for the specified LOB column, or {@link
1:      * Lob#INVALID_LOCATOR} if the LOB was not sent as a locator. The server
1:      * may send the LOB value instead of a locator if it is running an old
1:      * version which doesn't support locators, or if the database it accesses
1:      * is soft upgraded from a version that doesn't have the necessary
1:      * stored procedures for locator support.
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:b565f41
/////////////////////////////////////////////////////////////////////////
1:     // unused protocol element: VARIABLE_BYTES = 5;
1:     // unused protocol element: SBCS_CLOB = 8;
1:     // unused protocol element: MBCS_CLOB = 9;
1:     // unused protocol element: DBCS_CLOB = 10;
/////////////////////////////////////////////////////////////////////////
1:     private final static Boolean ROW_IS_NOT_NULL = Boolean.FALSE;
1:     private Calendar recyclableCalendar_ = null;
/////////////////////////////////////////////////////////////////////////
1:     private char[] charBuffer_;
commit:0326967
/////////////////////////////////////////////////////////////////////////
1:     protected final void markNextRowPosition() {
1:     protected final void makeNextRowPositionCurrent() {
/////////////////////////////////////////////////////////////////////////
1:     private boolean get_BOOLEAN(int column) {
commit:69e3d06
/////////////////////////////////////////////////////////////////////////
1: import java.io.ByteArrayOutputStream;
1: import java.io.StringReader;
1: import java.sql.Blob;
1: import java.sql.Clob;
1: import java.sql.Types;
1: import java.util.GregorianCalendar;
/////////////////////////////////////////////////////////////////////////
1:     public ByteArrayOutputStream dataBufferStream_;
/////////////////////////////////////////////////////////////////////////
0:     Calendar recyclableCalendar_ = null;
/////////////////////////////////////////////////////////////////////////
1:         dataBufferStream_ = new ByteArrayOutputStream();
/////////////////////////////////////////////////////////////////////////
0:     private final boolean get_BOOLEAN(int column) {
/////////////////////////////////////////////////////////////////////////
1:     private final short get_SMALLINT(int column) {
/////////////////////////////////////////////////////////////////////////
1:     private final long get_BIGINT(int column) {
1:     private final float get_FLOAT(int column) {
1:     private final double get_DOUBLE(int column) {
1:     private final BigDecimal get_DECIMAL(int column) throws SqlException {
0:         } catch (UnsupportedEncodingException e) {
/////////////////////////////////////////////////////////////////////////
1:         } catch (IllegalArgumentException e) {
0:         } catch (UnsupportedEncodingException e) {
/////////////////////////////////////////////////////////////////////////
1:         } catch (IllegalArgumentException e) {
0:         } catch (UnsupportedEncodingException e) {
/////////////////////////////////////////////////////////////////////////
1:                     tempString.substring(0, Math.min(maxFieldSize_,
1:                                                      tempString.length()));
0:         } catch (UnsupportedEncodingException e) {
/////////////////////////////////////////////////////////////////////////
1:                     tempString.substring(0, Math.min(maxFieldSize_,
1:                                                      tempString.length()));
0:         } catch (UnsupportedEncodingException e) {
/////////////////////////////////////////////////////////////////////////
1:     private final Timestamp getTIMESTAMP(int column, Calendar cal)
/////////////////////////////////////////////////////////////////////////
0:     } catch (UnsupportedEncodingException e) {
/////////////////////////////////////////////////////////////////////////
1:     private final Timestamp getTimestampFromDATE(
/////////////////////////////////////////////////////////////////////////
1:     private final Timestamp getTimestampFromTIME(
/////////////////////////////////////////////////////////////////////////
1:     private final Date getDateFromTIMESTAMP(int column, Calendar cal)
/////////////////////////////////////////////////////////////////////////
1:     private final Time getTimeFromTIMESTAMP(int column, Calendar cal)
/////////////////////////////////////////////////////////////////////////
1:     // Extract bytes from a database Types.BINARY field.
1:                 Math.min(maxFieldSize_, columnDataComputedLength_[column - 1]);
1:     // Extract bytes from a database Types.VARBINARY or LONGVARBINARY field.
/////////////////////////////////////////////////////////////////////////
1:     // Deserialize a UDT from a database Types.JAVA_OBJECT field.
/////////////////////////////////////////////////////////////////////////
1:     private Calendar getRecyclableCalendar()
1:             recyclableCalendar_ = new GregorianCalendar();
/////////////////////////////////////////////////////////////////////////
1:     public abstract ClientBlob getBlobColumn_(int column, Agent agent,
/////////////////////////////////////////////////////////////////////////
1:      * @return A {@code java.sql.Clob} object.
1:     public abstract ClientClob getClobColumn_(int column, Agent agent,
/////////////////////////////////////////////////////////////////////////
1:         case Types.BOOLEAN:
1:         case Types.SMALLINT:
1:         case Types.INTEGER:
1:         case Types.BIGINT:
1:         case Types.REAL:
1:         case Types.DOUBLE:
1:         case Types.DECIMAL:
1:         case Types.CHAR:
1:         case Types.VARCHAR:
1:         case Types.LONGVARCHAR:
/////////////////////////////////////////////////////////////////////////
1:         case Types.BOOLEAN:
1:         case Types.SMALLINT:
1:         case Types.INTEGER:
1:         case Types.BIGINT:
1:         case Types.REAL:
1:         case Types.DOUBLE:
1:         case Types.DECIMAL:
1:         case Types.CHAR:
1:         case Types.VARCHAR:
1:         case Types.LONGVARCHAR:
/////////////////////////////////////////////////////////////////////////
1:         case Types.BOOLEAN:
1:         case Types.SMALLINT:
1:         case Types.INTEGER:
1:         case Types.BIGINT:
1:         case Types.REAL:
1:         case Types.DOUBLE:
1:         case Types.DECIMAL:
1:         case Types.CHAR:
1:         case Types.VARCHAR:
1:         case Types.LONGVARCHAR:
/////////////////////////////////////////////////////////////////////////
1:         case Types.BOOLEAN:
1:         case Types.SMALLINT:
1:         case Types.INTEGER:
1:         case Types.BIGINT:
1:         case Types.REAL:
1:         case Types.DOUBLE:
1:         case Types.DECIMAL:
1:         case Types.CHAR:
1:         case Types.VARCHAR:
1:         case Types.LONGVARCHAR:
/////////////////////////////////////////////////////////////////////////
1:         case Types.BOOLEAN:
1:         case Types.SMALLINT:
1:         case Types.INTEGER:
1:         case Types.BIGINT:
1:         case Types.REAL:
1:         case Types.DOUBLE:
1:         case Types.DECIMAL:
1:         case Types.CHAR:
1:         case Types.VARCHAR:
1:         case Types.LONGVARCHAR:
/////////////////////////////////////////////////////////////////////////
1:         case Types.BOOLEAN:
1:         case Types.REAL:
1:         case Types.DOUBLE:
1:         case Types.DECIMAL:
1:         case Types.SMALLINT:
1:         case Types.INTEGER:
1:         case Types.BIGINT:
1:         case Types.CHAR:
1:         case Types.VARCHAR:
1:         case Types.LONGVARCHAR:
/////////////////////////////////////////////////////////////////////////
1:         case Types.BOOLEAN:
1:         case Types.REAL:
1:         case Types.DOUBLE:
1:         case Types.DECIMAL:
1:         case Types.SMALLINT:
1:         case Types.INTEGER:
1:         case Types.BIGINT:
1:         case Types.CHAR:
1:         case Types.VARCHAR:
1:         case Types.LONGVARCHAR:
1:     final BigDecimal getBigDecimal(int column) throws SqlException {
1:         case Types.BOOLEAN:
1:             return BigDecimal.valueOf(getLong(column));
1:         case Types.DECIMAL:
1:         case Types.REAL:
1:             return new BigDecimal(String.valueOf(f));
1:         case Types.DOUBLE:
1:             return BigDecimal.valueOf(get_DOUBLE(column));
1:         case Types.SMALLINT:
1:             return BigDecimal.valueOf(get_SMALLINT(column));
1:         case Types.INTEGER:
1:             return BigDecimal.valueOf(get_INTEGER(column));
1:         case Types.BIGINT:
1:             return BigDecimal.valueOf(get_BIGINT(column));
1:         case Types.CHAR:
1:         case Types.VARCHAR:
1:         case Types.LONGVARCHAR:
1:     final Date getDate(int column, Calendar cal) throws SqlException {
1:         case Types.DATE:
1:         case Types.TIMESTAMP:
1:         case Types.CHAR:
1:         case Types.VARCHAR:
1:         case Types.LONGVARCHAR:
/////////////////////////////////////////////////////////////////////////
1:     final Time getTime(int column, Calendar cal) throws SqlException {
1:         case Types.TIME:
1:         case Types.TIMESTAMP:
1:         case Types.CHAR:
1:         case Types.VARCHAR:
1:         case Types.LONGVARCHAR:
/////////////////////////////////////////////////////////////////////////
1:     final Timestamp getTimestamp(int column, Calendar cal)
1:         case Types.TIMESTAMP:
1:         case Types.DATE:
1:         case Types.TIME:
1:         case Types.CHAR:
1:         case Types.VARCHAR:
1:         case Types.LONGVARCHAR:
/////////////////////////////////////////////////////////////////////////
1:             case Types.BOOLEAN:
1:             case Types.CHAR:
1:             case Types.VARCHAR:
1:             case Types.LONGVARCHAR:
1:             case Types.SMALLINT:
1:             case Types.INTEGER:
1:             case Types.BIGINT:
1:             case Types.REAL:
1:             case Types.DOUBLE:
1:             case Types.DECIMAL:
1:             case Types.DATE:
1:             case Types.TIME:
1:             case Types.TIMESTAMP:
1:             case ClientTypes.BINARY:
0:                         tempString.substring(0, Math.min(maxFieldSize_,
0:                                                          tempString.length()));
1:             case Types.VARBINARY:
1:             case Types.LONGVARBINARY:
0:                         tempString.substring(0, Math.min(maxFieldSize_,
0:                                                          tempString.length()));
1:             case Types.JAVA_OBJECT:
1:             case Types.BLOB:
1:                 ClientBlob b = getBlobColumn_(column, agent_, false);
1:             case Types.CLOB:
1:                 ClientClob c = getClobColumn_(column, agent_, false);
/////////////////////////////////////////////////////////////////////////
1:             case Types.BINARY:
1:             case Types.VARBINARY:
1:             case Types.LONGVARBINARY:
1:             case Types.BLOB:
1:                 ClientBlob b = getBlobColumn_(column, agent_, false);
/////////////////////////////////////////////////////////////////////////
1:             case Types.BINARY:
1:                 return new ByteArrayInputStream(get_CHAR_FOR_BIT_DATA(column));
1:             case Types.VARBINARY:
1:             case Types.LONGVARBINARY:
1:                 return
1:                     new ByteArrayInputStream(get_VARCHAR_FOR_BIT_DATA(column));
1:             case Types.BLOB:
1:                 ClientBlob b = getBlobColumn_(column, agent_, false);
/////////////////////////////////////////////////////////////////////////
1:             case Types.CLOB:
1:                 ClientClob c = getClobColumn_(column, agent_, false);
/////////////////////////////////////////////////////////////////////////
1:             case Types.CHAR:
0:                     return new ByteArrayInputStream(
0:                         getCHAR(column).getBytes("ISO-8859-1"));
0:                 } catch (UnsupportedEncodingException e) {
1:             case Types.VARCHAR:
1:             case Types.LONGVARCHAR:
0:                     return new ByteArrayInputStream(
0:                         getVARCHAR(column).getBytes("ISO-8859-1"));
0:                 } catch (UnsupportedEncodingException e) {
1:             case Types.BINARY:
1:                 return new ByteArrayInputStream(get_CHAR_FOR_BIT_DATA(column));
1:             case Types.VARBINARY:
1:             case Types.LONGVARBINARY:
1:                 return
1:                     new ByteArrayInputStream(get_VARCHAR_FOR_BIT_DATA(column));
1:             case Types.BLOB:
/////////////////////////////////////////////////////////////////////////
1:             case Types.CLOB:
1:                 ClientClob c = getClobColumn_(column, agent_, false);
/////////////////////////////////////////////////////////////////////////
1:             case Types.CHAR:
1:                 return new StringReader(getCHAR(column));
1:             case Types.VARCHAR:
1:             case Types.LONGVARCHAR:
1:                 return new StringReader(getVARCHAR(column));
1:             case Types.BINARY:
0:                     return new InputStreamReader(
0:                         new ByteArrayInputStream(
1:             case Types.VARBINARY:
1:             case Types.LONGVARBINARY:
0:                     return new InputStreamReader(
0:                         new ByteArrayInputStream(
1:             case Types.BLOB:
/////////////////////////////////////////////////////////////////////////
1:     final Blob getBlob(int column) throws SqlException {
1:         case ClientTypes.BLOB:
1:     final Clob getClob(int column) throws SqlException {
1:         case ClientTypes.CLOB:
/////////////////////////////////////////////////////////////////////////
1:         case Types.BOOLEAN:
1:         case Types.SMALLINT:
1:         case Types.INTEGER:
1:         case Types.BIGINT:
1:         case Types.REAL:
1:         case Types.DOUBLE:
1:         case Types.DECIMAL:
1:         case Types.DATE:
1:         case Types.TIME:
1:         case Types.TIMESTAMP:
1:         case Types.CHAR:
1:         case Types.VARCHAR:
1:         case Types.LONGVARCHAR:
1:         case ClientTypes.BINARY:
1:         case Types.VARBINARY:
1:         case Types.LONGVARBINARY:
1:         case Types.JAVA_OBJECT:
1:         case Types.BLOB:
1:         case Types.CLOB:
/////////////////////////////////////////////////////////////////////////
1:             case ClientTypes.CHAR:
1:             case ClientTypes.VARCHAR:
1:             case ClientTypes.LONGVARCHAR:
/////////////////////////////////////////////////////////////////////////
1:             (agent_.logWriter_,
1:              targetType,
1:              ClientTypes.getTypeString(jdbcTypes_[sourceColumn -1]));
commit:b13b17c
/////////////////////////////////////////////////////////////////////////
1: import java.io.InputStream;
1: import java.io.InputStreamReader;
1: import java.io.Reader;
1: import java.math.BigDecimal;
1: import java.sql.Array;
1: import java.sql.Ref;
1: import java.sql.Timestamp;
/////////////////////////////////////////////////////////////////////////
1:     // unused protocol element: VARIABLE_SHORT_BYTES = 6;
/////////////////////////////////////////////////////////////////////////
1:      * @return {@code true} if current row position is valid
/////////////////////////////////////////////////////////////////////////
1:         boolean rowPositionIsValid =
1:             calculateColumnOffsetsForRow_(0, allowServerFetch);
/////////////////////////////////////////////////////////////////////////
1:      * @return {@code true} if current row position is valid
/////////////////////////////////////////////////////////////////////////
1:      * @param b a {@code boolean} value indicating whether all
/////////////////////////////////////////////////////////////////////////
1:      * Return {@code true} if all rows are received from the
1:      * @return {@code true} if all rows are received from the
/////////////////////////////////////////////////////////////////////////
1:      * @return {@code true} if the current row position is a
/////////////////////////////////////////////////////////////////////////
0:     private boolean get_BOOLEAN(int column) {
1:         if ( SignedBinary.getByte
0:     private short get_SMALLINT(int column) {
1:         return SignedBinary.getShort(dataBuffer_,
1:         return SignedBinary.getInt(dataBuffer_,
0:     private long get_BIGINT(int column) {
1:         return SignedBinary.getLong(dataBuffer_,
0:     private float get_FLOAT(int column) {
1:         return FloatingPoint.getFloat(dataBuffer_,
0:     private double get_DOUBLE(int column) {
1:         return FloatingPoint.getDouble(dataBuffer_,
0:     private BigDecimal get_DECIMAL(int column) throws SqlException {
0:             return Decimal.getBigDecimal(dataBuffer_,
/////////////////////////////////////////////////////////////////////////
1:     private double getDoubleFromDECIMAL(int column) throws SqlException {
1:             return Decimal.getDouble(dataBuffer_,
/////////////////////////////////////////////////////////////////////////
1:     private long getLongFromDECIMAL(int column, String targetType)
1:             return Decimal.getLong(dataBuffer_,
/////////////////////////////////////////////////////////////////////////
1:     private String getVARCHAR(int column) throws SqlException {
/////////////////////////////////////////////////////////////////////////
0:             String tempString = new String(dataBuffer_,
/////////////////////////////////////////////////////////////////////////
1:     private String getCHAR(int column) throws SqlException {
/////////////////////////////////////////////////////////////////////////
0:             String tempString = new String(dataBuffer_,
/////////////////////////////////////////////////////////////////////////
1:     private Date getDATE(int column, Calendar cal) throws SqlException {
0:             return DateTime.dateBytesToDate(dataBuffer_,
/////////////////////////////////////////////////////////////////////////
1:     private Time getTIME(int column, Calendar cal) throws SqlException {
0:             return DateTime.timeBytesToTime(dataBuffer_,
/////////////////////////////////////////////////////////////////////////
0:     private Timestamp getTIMESTAMP(int column, Calendar cal)
0:             return DateTime.timestampBytesToTimestamp(
/////////////////////////////////////////////////////////////////////////
0:     private Timestamp getTimestampFromDATE(
0:             return DateTime.dateBytesToTimestamp(dataBuffer_,
/////////////////////////////////////////////////////////////////////////
0:     private java.sql.Timestamp getTimestampFromTIME(
0:             return DateTime.timeBytesToTimestamp(dataBuffer_,
/////////////////////////////////////////////////////////////////////////
0:     private Date getDateFromTIMESTAMP(int column, Calendar cal)
0:             return DateTime.timestampBytesToDate(dataBuffer_,
/////////////////////////////////////////////////////////////////////////
0:     private Time getTimeFromTIMESTAMP(int column, Calendar cal)
0:             return DateTime.timestampBytesToTime(dataBuffer_,
/////////////////////////////////////////////////////////////////////////
1:     private String getStringFromDATE(int column) throws SqlException {
1:     private String getStringFromTIME(int column) throws SqlException {
1:     private String getStringFromTIMESTAMP(int column) throws SqlException {
1:     private byte[] get_CHAR_FOR_BIT_DATA(int column) throws SqlException {
/////////////////////////////////////////////////////////////////////////
1:     private byte[] get_VARCHAR_FOR_BIT_DATA(int column) throws SqlException {
1:         int columnLength =
1:             (maxFieldSize_ == 0) ? columnDataComputedLength_[column - 1] - 2 :
1:             Math.min(maxFieldSize_, columnDataComputedLength_[column - 1] - 2);
/////////////////////////////////////////////////////////////////////////
1:     private Object get_UDT(int column) throws SqlException {
1:         int columnLength =
1:             (maxFieldSize_ == 0) ? columnDataComputedLength_[column - 1] - 2 :
1:             Math.min(maxFieldSize_, columnDataComputedLength_[column - 1] - 2);
/////////////////////////////////////////////////////////////////////////
1:             String tempString;
/////////////////////////////////////////////////////////////////////////
1:     final InputStream getBinaryStream(int column) throws SqlException
/////////////////////////////////////////////////////////////////////////
1:     final InputStream getAsciiStream(int column) throws SqlException
/////////////////////////////////////////////////////////////////////////
1:     final Reader getCharacterStream(int column)
/////////////////////////////////////////////////////////////////////////
0:                     return new InputStreamReader(new ByteArrayInputStream(
0:                             get_CHAR_FOR_BIT_DATA(column)), "UTF-16BE");
0:                 } catch (UnsupportedEncodingException e) {
/////////////////////////////////////////////////////////////////////////
0:                     return new InputStreamReader(new ByteArrayInputStream(
0:                             get_VARCHAR_FOR_BIT_DATA(column)), "UTF-16BE");
0:                 } catch (UnsupportedEncodingException e) {
0:                     return new InputStreamReader(getBinaryStream(column),
0:                 } catch (UnsupportedEncodingException e) {
/////////////////////////////////////////////////////////////////////////
1:     final Array getArray(int column) throws SqlException {
1:     final Ref getRef(int column) throws SqlException {
commit:ee33904
/////////////////////////////////////////////////////////////////////////
1:     final boolean currentRowPositionIsEqualToNextRowPosition() {
/////////////////////////////////////////////////////////////////////////
1:     final boolean dataBufferHasUnprocessedData() {
/////////////////////////////////////////////////////////////////////////
0:     final java.io.InputStream getBinaryStream(int column) throws SqlException
/////////////////////////////////////////////////////////////////////////
0:     final java.io.InputStream getAsciiStream(int column) throws SqlException
/////////////////////////////////////////////////////////////////////////
0:     final java.io.Reader getCharacterStream(int column)
/////////////////////////////////////////////////////////////////////////
0:     final java.sql.Blob getBlob(int column) throws SqlException {
/////////////////////////////////////////////////////////////////////////
0:     final java.sql.Clob getClob(int column) throws SqlException {
/////////////////////////////////////////////////////////////////////////
0:     final java.sql.Array getArray(int column) throws SqlException {
0:     final java.sql.Ref getRef(int column) throws SqlException {
1:     final Object getObject(int column) throws SqlException {
/////////////////////////////////////////////////////////////////////////
1:     private String getStringWithoutConvert(int position, int actualLength) {
/////////////////////////////////////////////////////////////////////////
1:     private int getColumnPrecision(int column) {
1:     private int getColumnScale(int column) {
commit:3419748
/////////////////////////////////////////////////////////////////////////
0:     private final long getLongFromDECIMAL(int column, String targetType) 
1:             throws SqlException {
1:         } catch (ArithmeticException e) {
1:             throw new SqlException(agent_.logWriter_,
1:                 new ClientMessageId (SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE),
0:                 targetType, e);
0:                 targetType, e);
0:                 "DECIMAL", targetType, e);
/////////////////////////////////////////////////////////////////////////
1:             return agent_.crossConverters_.getBooleanFromLong(
1:                 getLongFromDECIMAL(column, "boolean"));
/////////////////////////////////////////////////////////////////////////
1:             return agent_.crossConverters_.getByteFromLong(
1:                 getLongFromDECIMAL(column, "byte"));
/////////////////////////////////////////////////////////////////////////
1:             return agent_.crossConverters_.getShortFromLong(
1:                 getLongFromDECIMAL(column, "short"));
/////////////////////////////////////////////////////////////////////////
1:             return agent_.crossConverters_.getIntFromLong(
1:                 getLongFromDECIMAL(column, "int"));
/////////////////////////////////////////////////////////////////////////
1:             return getLongFromDECIMAL(column, "long");
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:47a8183
/////////////////////////////////////////////////////////////////////////
1:     long rowsRead_;
commit:6ef238b
/////////////////////////////////////////////////////////////////////////
1:             throw coercionError( "boolean", column );
/////////////////////////////////////////////////////////////////////////
1:             throw coercionError( "byte", column );
/////////////////////////////////////////////////////////////////////////
1:             throw coercionError( "short", column );
/////////////////////////////////////////////////////////////////////////
1:             throw coercionError(  "int", column );
/////////////////////////////////////////////////////////////////////////
1:             throw coercionError( "long", column );
/////////////////////////////////////////////////////////////////////////
1:             throw coercionError( "float", column );
/////////////////////////////////////////////////////////////////////////
1:             throw coercionError( "double", column );
/////////////////////////////////////////////////////////////////////////
1:             throw coercionError( "java.math.BigDecimal", column );
/////////////////////////////////////////////////////////////////////////
1:             throw coercionError( "java.sql.Date", column );
/////////////////////////////////////////////////////////////////////////
1:             throw coercionError( "java.sql.Time", column );
/////////////////////////////////////////////////////////////////////////
1:             throw coercionError( "java.sql.Timestamp", column );
/////////////////////////////////////////////////////////////////////////
1:                 throw coercionError( "String", column );
/////////////////////////////////////////////////////////////////////////
1:                 throw coercionError( "byte[]", column );
/////////////////////////////////////////////////////////////////////////
1:                 throw coercionError( "java.io.InputStream", column );
/////////////////////////////////////////////////////////////////////////
1:                 throw coercionError( "java.io.InputStream", column );
/////////////////////////////////////////////////////////////////////////
0:                 throw coercionError( "UnicodeStream", column );
/////////////////////////////////////////////////////////////////////////
1:                 throw coercionError( "java.io.Reader", column );
/////////////////////////////////////////////////////////////////////////
1:             throw coercionError( "java.sql.Blob", column );
/////////////////////////////////////////////////////////////////////////
1:             throw coercionError( "java.sql.Clob", column );
/////////////////////////////////////////////////////////////////////////
1:             throw coercionError( "Object", column );
/////////////////////////////////////////////////////////////////////////
1:     private ColumnTypeConversionException coercionError
1:         ( String targetType, int sourceColumn )
1:     {
1:         return new ColumnTypeConversionException
0:                 ( agent_.logWriter_, targetType, Types.getTypeString( jdbcTypes_[sourceColumn -1] ));
1:     }
1: 
commit:eff3919
/////////////////////////////////////////////////////////////////////////
1:     // Build a Java boolean from a 1-byte signed binary representation.
0:     private final boolean get_BOOLEAN(int column) {
0:         if ( org.apache.derby.client.am.SignedBinary.getByte
1:              ( dataBuffer_, columnDataPosition_[column - 1] ) == 0 )
1:         { return false; }
1:         else { return true; }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:         case java.sql.Types.BOOLEAN:
1:             return get_BOOLEAN(column);
/////////////////////////////////////////////////////////////////////////
0:         case java.sql.Types.BOOLEAN:
1:             return agent_.crossConverters_.getByteFromBoolean(get_BOOLEAN(column));
/////////////////////////////////////////////////////////////////////////
0:         case java.sql.Types.BOOLEAN:
1:             return agent_.crossConverters_.getShortFromBoolean(get_BOOLEAN(column));
/////////////////////////////////////////////////////////////////////////
0:         case java.sql.Types.BOOLEAN:
1:             return agent_.crossConverters_.getIntFromBoolean(get_BOOLEAN(column));
/////////////////////////////////////////////////////////////////////////
0:         case java.sql.Types.BOOLEAN:
1:             return agent_.crossConverters_.getLongFromBoolean(get_BOOLEAN(column));
/////////////////////////////////////////////////////////////////////////
0:         case java.sql.Types.BOOLEAN:
1:             return agent_.crossConverters_.getFloatFromBoolean(get_BOOLEAN(column));
/////////////////////////////////////////////////////////////////////////
0:         case java.sql.Types.BOOLEAN:
1:             return agent_.crossConverters_.getDoubleFromBoolean(get_BOOLEAN(column));
/////////////////////////////////////////////////////////////////////////
0:         case java.sql.Types.BOOLEAN:
0:             return new java.math.BigDecimal( getInt( column ) );
/////////////////////////////////////////////////////////////////////////
0:             case java.sql.Types.BOOLEAN:
1:                 if ( get_BOOLEAN( column ) ) { return Boolean.TRUE.toString(); }
1:                 else { return Boolean.FALSE.toString(); }
/////////////////////////////////////////////////////////////////////////
0:         case java.sql.Types.BOOLEAN:
0:             return new Boolean(get_BOOLEAN(column));
commit:bead0ab
/////////////////////////////////////////////////////////////////////////
0:                 charsetName_[column - 1],
0:                 agent_.connection_.serverSupportsTimestampNanoseconds());
commit:506f4c8
/////////////////////////////////////////////////////////////////////////
1: import java.io.ByteArrayInputStream;
1: import java.io.ObjectInputStream;
/////////////////////////////////////////////////////////////////////////
0:     // Deserialize a UDT from a database java.sql.Types.JAVA_OBJECT field.
1:     // This is used for user defined types.
0:     private final Object get_UDT(int column) throws SqlException {
1:         byte[] bytes;
0:         int columnLength = 0;
0:         columnLength = (maxFieldSize_ == 0) ? columnDataComputedLength_[column - 1] - 2 :
0:                 java.lang.Math.min(maxFieldSize_, columnDataComputedLength_[column - 1] - 2);
1:         bytes = new byte[columnLength];
1:         System.arraycopy(dataBuffer_, columnDataPosition_[column - 1] + 2, bytes, 0, bytes.length);
1: 
1:         try {
1:             ByteArrayInputStream bais = new ByteArrayInputStream( bytes );
1:             ObjectInputStream ois = new ObjectInputStream( bais );
1: 
1:             return ois.readObject();
1:         }
1:         catch (Exception e)
1:         {
1:             throw new SqlException
1:                 (
1:                  agent_.logWriter_, 
1:                  new ClientMessageId (SQLState.NET_MARSHALLING_UDT_ERROR),
0:                  e.getMessage(),
0:                  e
1:                  );
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:             case java.sql.Types.JAVA_OBJECT:
1:                 Object obj = get_UDT( column );
1:                 if ( obj == null ) { return null; }
1:                 else { return obj.toString(); }
/////////////////////////////////////////////////////////////////////////
0:         case java.sql.Types.JAVA_OBJECT:
1:             return get_UDT( column );
commit:1a66a1a
/////////////////////////////////////////////////////////////////////////
1:     protected final int get_INTEGER(int column) {
commit:93cfc7f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:6eb29f6
/////////////////////////////////////////////////////////////////////////
0:                     new ClientMessageId (SQLState.UNSUPPORTED_ENCODING), 
0:                     "VARCHAR", "String", e);
/////////////////////////////////////////////////////////////////////////
0:                             new ClientMessageId (SQLState.UNSUPPORTED_ENCODING), 
0:                             "CHAR", "java.io.InputStream", e);
/////////////////////////////////////////////////////////////////////////
0:                             new ClientMessageId (SQLState.UNSUPPORTED_ENCODING), 
0:                             "VARCHAR/LONGVARCHAR", "java.io.InputStream", e);
/////////////////////////////////////////////////////////////////////////
0:                                 new ClientMessageId (SQLState.UNSUPPORTED_ENCODING), 
0:                                 "CLOB", "UnicodeStream", e);
/////////////////////////////////////////////////////////////////////////
0:                                 new ClientMessageId (SQLState.UNSUPPORTED_ENCODING), 
0:                                 "CHAR", "UnicodeStream", e);
/////////////////////////////////////////////////////////////////////////
0:                             new ClientMessageId (SQLState.UNSUPPORTED_ENCODING), 
0:                             "VARCHAR/LONGVARCHAR", "UnicodeStream", e);
/////////////////////////////////////////////////////////////////////////
0:                             new ClientMessageId (SQLState.UNSUPPORTED_ENCODING), 
0:                             "BINARY", "java.io.Reader", e);
/////////////////////////////////////////////////////////////////////////
0:                             new ClientMessageId (SQLState.UNSUPPORTED_ENCODING), 
0:                             "VARBINARY/LONGVARBINARY", "java.io.Reader", e);
/////////////////////////////////////////////////////////////////////////
0:                             new ClientMessageId (SQLState.UNSUPPORTED_ENCODING), 
0:                             "BLOB", "java.io.Reader", e);
commit:c6ed70e
/////////////////////////////////////////////////////////////////////////
1: import java.io.BufferedInputStream;
1: import java.io.BufferedReader;
/////////////////////////////////////////////////////////////////////////
0:                 Blob b = getBlobColumn_(column, agent_);
1:                 tempString = agent_.crossConverters_.
1:                         getStringFromBytes(b.getBytes(1, (int) b.length()));
0:                 b.free();  // Free resources from underlying Blob
1:                 return tempString;
1:                 tempString = c.getSubString(1, (int) c.length());
0:                 c.free();  // Free resources from underlying Clob
1:                 return tempString;
/////////////////////////////////////////////////////////////////////////
0:                 Blob b = getBlobColumn_(column, agent_);
1:                 byte[] bytes = b.getBytes(1, (int) b.length());
0:                 b.free(); // Free resources from underlying Blob
1:                 return bytes;
/////////////////////////////////////////////////////////////////////////
0:     public final java.io.InputStream getBinaryStream(int column) 
1:             throws SqlException 
1:     {
1:         switch (jdbcTypes_[column - 1]) {
0:                 Blob b = getBlobColumn_(column, agent_);
1:                 if (b.isLocator()) {
1:                     BlobLocatorInputStream is 
1:                             = new BlobLocatorInputStream(agent_.connection_, b);
0:                     // Underlying Blob should be released when stream is closed
0:                     is.setFreeBlobOnClose();
1:                     return new BufferedInputStream(is);
1:                 } else {
1:                     return b.getBinaryStreamX();
1:                 }
0:     public final java.io.InputStream getAsciiStream(int column) 
1:             throws SqlException
1:     {
1:         switch (jdbcTypes_[column - 1]) {
1:                 if (c.isLocator()) {
1:                     ClobLocatorInputStream is 
1:                             = new ClobLocatorInputStream(agent_.connection_, c);
0:                     // Underlying Clob should be released when stream is closed
0:                     is.setFreeClobOnClose();
1:                     return new BufferedInputStream(is);
1:                 } else {
1:                     return c.getAsciiStreamX();
1:                 }
/////////////////////////////////////////////////////////////////////////
1:                 return getBinaryStream(column);
1:  
/////////////////////////////////////////////////////////////////////////
0:                     c.free(); // Release resources from underlying Clob
/////////////////////////////////////////////////////////////////////////
0:                 return getBinaryStream(column);
/////////////////////////////////////////////////////////////////////////
0:     public final java.io.Reader getCharacterStream(int column) 
0:             throws SqlException 
1:     {
1:         switch (jdbcTypes_[column - 1]) {
1:                 if (c.isLocator()) {
1:                     ClobLocatorReader reader
1:                             = new ClobLocatorReader(agent_.connection_, c);
0:                     //  Make sure underlying Blob is released when reader is closed
0:                     reader.setFreeClobOnClose();
1:                     return new BufferedReader(reader);
1:                 } else {
1:                     return c.getCharacterStreamX();
1:                 }
/////////////////////////////////////////////////////////////////////////
0:                     return new java.io.InputStreamReader(getBinaryStream(column),
0:                                                          "UTF-16BE");
/////////////////////////////////////////////////////////////////////////
commit:491c5b6
/////////////////////////////////////////////////////////////////////////
0: import java.io.UnsupportedEncodingException;
/////////////////////////////////////////////////////////////////////////
1:         try {
0:             return org.apache.derby.client.am.DateTime.dateBytesToDate(dataBuffer_,
0:                 recyclableDate_, 
0:                 charsetName_[column - 1]);
0:         }catch (UnsupportedEncodingException e) {
0:              throw new SqlException(agent_.logWriter_, e, 
0:                     "Encoding is unsupported for conversion to DATE");
1:         }
1: 
1:         
1:         try {
0:             return org.apache.derby.client.am.DateTime.timeBytesToTime(dataBuffer_,
1:                     columnDataPosition_[column - 1],
0:                     recyclableTime_,
0:                     charsetName_[column - 1]);
0:         } catch (UnsupportedEncodingException e) {
0:             throw new SqlException(agent_.logWriter_, e, 
0:                     "Encoding is unsupported for conversion to TIME");
1:         }
1: 
1:         try {
0:         return org.apache.derby.client.am.DateTime.timestampBytesToTimestamp(
0:                 dataBuffer_,
0:                 recyclableTimestamp_, 
0:                 charsetName_[column - 1]);
0:     } catch (java.io.UnsupportedEncodingException e) {
0:         throw new SqlException(agent_.logWriter_, e, 
0:                 "Encoding is unsupported for conversion to TIMESTAMP");
1:     }
1:         try {
0:             return org.apache.derby.client.am.DateTime.dateBytesToTimestamp(dataBuffer_,
1:                     columnDataPosition_[column - 1],
0:                     recyclableTimestamp_, 
0:                     charsetName_[column -1]);
0:         } catch (UnsupportedEncodingException e) {
0:               throw new SqlException(agent_.logWriter_, e, 
0:                       "Encoding is unsupported for conversion to TIMESTAMP");            
1:         }
1:         try {
0:             return org.apache.derby.client.am.DateTime.timeBytesToTimestamp(dataBuffer_,
1:                     columnDataPosition_[column - 1],
0:                     recyclableTimestamp_,
0:                     charsetName_[column -1]);
0:         } catch (UnsupportedEncodingException e) {
0:             throw new SqlException(agent_.logWriter_, e, 
0:                     "Encoding is unsupported for conversion to TIMESTAMP");
1:         }
1:         try {
0:             return org.apache.derby.client.am.DateTime.timestampBytesToDate(dataBuffer_,
1:                     columnDataPosition_[column - 1],
0:                     recyclableDate_,
0:                     charsetName_[column -1]);
0:         } catch (UnsupportedEncodingException e) {
0:              throw new SqlException(agent_.logWriter_, e, 
0:                      "Encoding is unsupported for conversion to DATE");
1:         }
1:         try {
0:             return org.apache.derby.client.am.DateTime.timestampBytesToTime(dataBuffer_,
1:                     columnDataPosition_[column - 1],
0:                     recyclableTime_,
0:                     charsetName_[column -1]);
0:         } catch (UnsupportedEncodingException e) {
0:              throw new SqlException(agent_.logWriter_, e, 
0:                      "Encoding is unsupported for conversion to TIME");
1:         }
0:         return getDATE(column).toString();
0:         return getTIME(column).toString();
0:         return getTIMESTAMP(column).toString();
author:Lily Wei
-------------------------------------------------------------------------------
commit:321c68c
/////////////////////////////////////////////////////////////////////////
0:             return get_BOOLEAN(column) ? Boolean.TRUE : Boolean.FALSE;
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:4015c92
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Returns a {@code Blob} object.
1:      *
1:      * @param column 1-based column index
1:      * @param agent associated agent
1:      * @param toBePublished whether the Blob will be published to the user
1:      * @return A {@linkplain java.sql.Blob Blob} object.
1:      * @throws SqlException if getting the {@code Blob} fails
1:      */
0:     public abstract Blob getBlobColumn_(int column, Agent agent,
1:                                         boolean toBePublished)
1:             throws SqlException;
1:     /**
1:      * Returns a {@code Clob} object.
1:      *
1:      * @param column 1-based column index
1:      * @param agent associated agent
1:      * @param toBePublished whether the Clob will be published to the user
0:      * @return A {@linkplain java.sql.Clob Clob} object.
1:      * @throws SqlException if getting the {@code Clob} fails
1:      */
0:     public abstract Clob getClobColumn_(int column, Agent agent,
1:                                         boolean toBePublished)
1:             throws SqlException;
/////////////////////////////////////////////////////////////////////////
0:                 Blob b = getBlobColumn_(column, agent_, false);
0:                 Clob c = getClobColumn_(column, agent_, false);
/////////////////////////////////////////////////////////////////////////
0:                 Blob b = getBlobColumn_(column, agent_, false);
/////////////////////////////////////////////////////////////////////////
0:                 Blob b = getBlobColumn_(column, agent_, false);
/////////////////////////////////////////////////////////////////////////
0:                 Clob c = getClobColumn_(column, agent_, false);
/////////////////////////////////////////////////////////////////////////
0:                     Clob c = getClobColumn_(column, agent_, false);
/////////////////////////////////////////////////////////////////////////
0:                 Clob c = getClobColumn_(column, agent_, false);
/////////////////////////////////////////////////////////////////////////
1:             return getBlobColumn_(column, agent_, true);
/////////////////////////////////////////////////////////////////////////
1:             return getClobColumn_(column, agent_, true);
/////////////////////////////////////////////////////////////////////////
1:             return getBlobColumn_(column, agent_, true);
1:             return getClobColumn_(column, agent_, true);
commit:f55d30a
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Returns a reference to the locator procedures.
1:      * <p>
1:      * These procedures are used to operate on large objects referenced on the
1:      * server by locators.
1:      *
1:      * @return The locator procedures object.
1:      */
1:     CallableLocatorProcedures getLocatorProcedures() {
1:         return agent_.connection_.locatorProcedureCall();
1:     }
1: 
1:     /**
0:      * Obtains the locator for the specified LOB column.
1:      * <p>
1:      * Note that this method cannot be invoked on a LOB column that is NULL.
1:      *
1:      * @param column 1-based column index
1:      * @return A positive integer locator if valid, {@link Lob#INVALID_LOCATOR}
1:      *      otherwise.
1:      */
1:     protected abstract int locator(int column);
1: 
commit:faf6742
/////////////////////////////////////////////////////////////////////////
0:                     return new java.io.ByteArrayInputStream(getCHAR(column).getBytes("ISO-8859-1"));
/////////////////////////////////////////////////////////////////////////
0:                     return new java.io.ByteArrayInputStream(getVARCHAR(column).getBytes("ISO-8859-1"));
author:Army
-------------------------------------------------------------------------------
commit:26b9e3c
/////////////////////////////////////////////////////////////////////////
0:     java.util.Calendar recyclableCalendar_ = null;
/////////////////////////////////////////////////////////////////////////
0:                 getRecyclableCalendar(), 
/////////////////////////////////////////////////////////////////////////
0:                     getRecyclableCalendar(),
/////////////////////////////////////////////////////////////////////////
0:             return org.apache.derby.client.am.DateTime.timestampBytesToTimestamp(
0:                 getRecyclableCalendar(), 
/////////////////////////////////////////////////////////////////////////
0:                     getRecyclableCalendar(), 
/////////////////////////////////////////////////////////////////////////
0:                     getRecyclableCalendar(),
/////////////////////////////////////////////////////////////////////////
0:                     getRecyclableCalendar(),
/////////////////////////////////////////////////////////////////////////
0:                     getRecyclableCalendar(),
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Instantiate an instance of Calendar that can be re-used for getting
1:      * Time, Timestamp, and Date values from this cursor.  Assumption is
1:      * that all users of the returned Calendar object will clear it as
1:      * appropriate before using it.
1:      */
0:     private java.util.Calendar getRecyclableCalendar()
1:     {
1:         if (recyclableCalendar_ == null)
0:             recyclableCalendar_ = new java.util.GregorianCalendar();
1: 
1:         return recyclableCalendar_;
1:     }
1: 
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:59bf37d
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:David Van Couvering
-------------------------------------------------------------------------------
commit:e65b4db
/////////////////////////////////////////////////////////////////////////
0:                 new ClientMessageId (SQLState.UNSUPPORTED_ENCODING),  
/////////////////////////////////////////////////////////////////////////
1:                 new ClientMessageId (SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE),
0:                 new ClientMessageId (SQLState.UNSUPPORTED_ENCODING), 
/////////////////////////////////////////////////////////////////////////
1:                 new ClientMessageId (SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE),
0:                 new ClientMessageId (SQLState.UNSUPPORTED_ENCODING), 
/////////////////////////////////////////////////////////////////////////
0:                     new ClientMessageId(SQLState.CHARACTER_CONVERTER_NOT_AVAILABLE));
/////////////////////////////////////////////////////////////////////////
0:             		new ClientMessageId (SQLState.UNSUPPORTED_ENCODING), 
/////////////////////////////////////////////////////////////////////////
0:                     new ClientMessageId(SQLState.CHARACTER_CONVERTER_NOT_AVAILABLE));
/////////////////////////////////////////////////////////////////////////
0:                 new ClientMessageId (SQLState.UNSUPPORTED_ENCODING),
/////////////////////////////////////////////////////////////////////////
0:                  new ClientMessageId(SQLState.UNSUPPORTED_ENCODING),
/////////////////////////////////////////////////////////////////////////
0:                  new ClientMessageId(SQLState.UNSUPPORTED_ENCODING),
/////////////////////////////////////////////////////////////////////////
0:                  new ClientMessageId(SQLState.UNSUPPORTED_ENCODING),
/////////////////////////////////////////////////////////////////////////
0:                  new ClientMessageId(SQLState.UNSUPPORTED_ENCODING),
/////////////////////////////////////////////////////////////////////////
0:                  new ClientMessageId(SQLState.UNSUPPORTED_ENCODING),
/////////////////////////////////////////////////////////////////////////
0:                  new ClientMessageId(SQLState.UNSUPPORTED_ENCODING),
/////////////////////////////////////////////////////////////////////////
0:                  new ClientMessageId(SQLState.UNSUPPORTED_ENCODING),
/////////////////////////////////////////////////////////////////////////
0:                     		new ClientMessageId (SQLState.UNSUPPORTED_ENCODING), 
/////////////////////////////////////////////////////////////////////////
0:                     		new ClientMessageId (SQLState.UNSUPPORTED_ENCODING), 
/////////////////////////////////////////////////////////////////////////
0:                         		new ClientMessageId (SQLState.UNSUPPORTED_ENCODING), 
/////////////////////////////////////////////////////////////////////////
0:                         		new ClientMessageId (SQLState.UNSUPPORTED_ENCODING), 
/////////////////////////////////////////////////////////////////////////
0:                     		new ClientMessageId (SQLState.UNSUPPORTED_ENCODING), 
/////////////////////////////////////////////////////////////////////////
0:                     		new ClientMessageId (SQLState.UNSUPPORTED_ENCODING), 
/////////////////////////////////////////////////////////////////////////
0:                     		new ClientMessageId (SQLState.UNSUPPORTED_ENCODING), 
/////////////////////////////////////////////////////////////////////////
0:                     		new ClientMessageId (SQLState.UNSUPPORTED_ENCODING), 
/////////////////////////////////////////////////////////////////////////
1:             new ClientMessageId (SQLState.NOT_IMPLEMENTED),
1:             new ClientMessageId (SQLState.NOT_IMPLEMENTED), "getRef(int)");
commit:3d650b1
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.reference.SQLState;
/////////////////////////////////////////////////////////////////////////
1:             throw new SqlException(agent_.logWriter_, 
0:                 new MessageId (SQLState.UNSUPPORTED_ENCODING),  
0:                 "DECIMAL", "java.math.BigDecimal", e);
/////////////////////////////////////////////////////////////////////////
1:             throw new SqlException(agent_.logWriter_, 
0:                 new MessageId (SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE),
0:                 "double", e);
1:             throw new SqlException(agent_.logWriter_, 
0:                 new MessageId (SQLState.UNSUPPORTED_ENCODING), 
0:                 "DECIMAL", "double", e);
/////////////////////////////////////////////////////////////////////////
1:             throw new SqlException(agent_.logWriter_,
0:                 new MessageId (SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE),
0:                 "long", e);
1:             throw new SqlException(agent_.logWriter_,
0:                 new MessageId (SQLState.UNSUPPORTED_ENCODING), 
0:                 "DECIMAL", "long", e);
/////////////////////////////////////////////////////////////////////////
0:                     new MessageId(SQLState.CHARACTER_CONVERTER_NOT_AVAILABLE));
/////////////////////////////////////////////////////////////////////////
0:             throw new SqlException(agent_.logWriter_, 
0:             		new MessageId (SQLState.UNSUPPORTED_ENCODING), 
0:             		"VARCHAR", "String", e);
/////////////////////////////////////////////////////////////////////////
0:                     new MessageId(SQLState.CHARACTER_CONVERTER_NOT_AVAILABLE));
/////////////////////////////////////////////////////////////////////////
0:             throw new SqlException(agent_.logWriter_,
0:                 new MessageId (SQLState.UNSUPPORTED_ENCODING),
0:                 "CHAR", "String", e);
/////////////////////////////////////////////////////////////////////////
0:              throw new SqlException(agent_.logWriter_, 
0:                  new MessageId(SQLState.UNSUPPORTED_ENCODING),
0:                  "DATE", "java.sql.Date", e);
/////////////////////////////////////////////////////////////////////////
0:              throw new SqlException(agent_.logWriter_, 
0:                  new MessageId(SQLState.UNSUPPORTED_ENCODING),
0:                  "TIME", "java.sql.Time", e);
/////////////////////////////////////////////////////////////////////////
0:              throw new SqlException(agent_.logWriter_, 
0:                  new MessageId(SQLState.UNSUPPORTED_ENCODING),
0:                  "TIMESTAMP", "java.sql.Timestamp", e);
/////////////////////////////////////////////////////////////////////////
0:              throw new SqlException(agent_.logWriter_, 
0:                  new MessageId(SQLState.UNSUPPORTED_ENCODING),
0:                  "DATE", "java.sql.Timestamp", e);
/////////////////////////////////////////////////////////////////////////
0:              throw new SqlException(agent_.logWriter_, 
0:                  new MessageId(SQLState.UNSUPPORTED_ENCODING),
0:                  "TIME", "java.sql.Timestamp", e);
/////////////////////////////////////////////////////////////////////////
0:              throw new SqlException(agent_.logWriter_, 
0:                  new MessageId(SQLState.UNSUPPORTED_ENCODING),
0:                  "TIMESTAMP", "java.sql.Date", e);
/////////////////////////////////////////////////////////////////////////
0:              throw new SqlException(agent_.logWriter_, 
0:                  new MessageId(SQLState.UNSUPPORTED_ENCODING),
0:                  "TIMESTAMP", "java.sql.Time", e);
/////////////////////////////////////////////////////////////////////////
0:             throw new ColumnTypeConversionException(agent_.logWriter_,
0:                 "java.sql.Types " + jdbcTypes_[column -1], "boolean");
/////////////////////////////////////////////////////////////////////////
0:             throw new ColumnTypeConversionException(agent_.logWriter_,
0:                 "java.sql.Types " + jdbcTypes_[column -1], "byte");
/////////////////////////////////////////////////////////////////////////
0:             throw new ColumnTypeConversionException(agent_.logWriter_,
0:                 "java.sql.Types " + jdbcTypes_[column -1], "short");
/////////////////////////////////////////////////////////////////////////
0:             throw new ColumnTypeConversionException(agent_.logWriter_,
0:                 "java.sql.Types " + jdbcTypes_[column -1], "int");
/////////////////////////////////////////////////////////////////////////
0:             throw new ColumnTypeConversionException(agent_.logWriter_,
0:                 "java.sql.Types " + jdbcTypes_[column -1], "long");
/////////////////////////////////////////////////////////////////////////
0:             throw new ColumnTypeConversionException(agent_.logWriter_,
0:                 "java.sql.Types " + jdbcTypes_[column -1], "float");
/////////////////////////////////////////////////////////////////////////
0:             throw new ColumnTypeConversionException(agent_.logWriter_,
0:                 "java.sql.Types " + jdbcTypes_[column -1], "double");
/////////////////////////////////////////////////////////////////////////
0:             throw new ColumnTypeConversionException(agent_.logWriter_,
0:                 "java.sql.Types " + jdbcTypes_[column -1], "java.math.BigDecimal");
/////////////////////////////////////////////////////////////////////////
0:             throw new ColumnTypeConversionException(agent_.logWriter_,
0:                 "java.sql.Types " + jdbcTypes_[column -1], "java.sql.Date");
/////////////////////////////////////////////////////////////////////////
0:             throw new ColumnTypeConversionException(agent_.logWriter_,
0:                 "java.sql.Types " + jdbcTypes_[column -1], "java.sql.Time");
/////////////////////////////////////////////////////////////////////////
0:             throw new ColumnTypeConversionException(agent_.logWriter_,
0:                 "java.sql.Types " + jdbcTypes_[column -1], "java.sql.Timestamp");
/////////////////////////////////////////////////////////////////////////
0:                 throw new ColumnTypeConversionException(agent_.logWriter_,
0:                     "java.sql.Types " + jdbcTypes_[column -1], "String");
/////////////////////////////////////////////////////////////////////////
0:                 throw new ColumnTypeConversionException(agent_.logWriter_,
0:                     "java.sql.Types " + jdbcTypes_[column -1], "byte[]");
/////////////////////////////////////////////////////////////////////////
0:                 throw new ColumnTypeConversionException(agent_.logWriter_,
0:                     "java.sql.Types " + jdbcTypes_[column -1], "java.io.InputStream");
/////////////////////////////////////////////////////////////////////////
0:                     throw new SqlException(agent_.logWriter_, 
0:                     		new MessageId (SQLState.UNSUPPORTED_ENCODING), 
0:                     		"CHAR", "java.io.InputStream", e);
0:                     throw new SqlException(agent_.logWriter_, 
0:                     		new MessageId (SQLState.UNSUPPORTED_ENCODING), 
0:                     		"VARCHAR/LONGVARCHAR", "java.io.InputStream", e);
/////////////////////////////////////////////////////////////////////////
0:                 throw new ColumnTypeConversionException(agent_.logWriter_,
0:                     "java.sql.Types " + jdbcTypes_[column -1], "java.io.InputStream");
/////////////////////////////////////////////////////////////////////////
0:                         throw new SqlException(agent_.logWriter_, 
0:                         		new MessageId (SQLState.UNSUPPORTED_ENCODING), 
0:                         		"CLOB", "UnicodeStream", e);
/////////////////////////////////////////////////////////////////////////
0:                         throw new SqlException(agent_.logWriter_, 
0:                         		new MessageId (SQLState.UNSUPPORTED_ENCODING), 
0:                         		"CHAR", "UnicodeStream", e);
/////////////////////////////////////////////////////////////////////////
0:                     throw new SqlException(agent_.logWriter_, 
0:                     		new MessageId (SQLState.UNSUPPORTED_ENCODING), 
0:                     		"VARCHAR/LONGVARCHAR", "UnicodeStream", e);
/////////////////////////////////////////////////////////////////////////
0:                 throw new ColumnTypeConversionException(agent_.logWriter_,
0:                     "java.sql.Types " + jdbcTypes_[column -1], "UnicodeStream");
/////////////////////////////////////////////////////////////////////////
0:                     throw new SqlException(agent_.logWriter_, 
0:                     		new MessageId (SQLState.UNSUPPORTED_ENCODING), 
0:                     		"BINARY", "java.io.Reader", e);
0:                     throw new SqlException(agent_.logWriter_, 
0:                     		new MessageId (SQLState.UNSUPPORTED_ENCODING), 
0:                     		"VARBINARY/LONGVARBINARY", "java.io.Reader", e);
0:                     throw new SqlException(agent_.logWriter_, 
0:                     		new MessageId (SQLState.UNSUPPORTED_ENCODING), 
0:                     		"BLOB", "java.io.Reader", e);
0:                 throw new ColumnTypeConversionException(agent_.logWriter_,
0:                     "java.sql.Types " + jdbcTypes_[column -1], "java.io.Reader");
/////////////////////////////////////////////////////////////////////////
0:             throw new ColumnTypeConversionException(agent_.logWriter_,
0:                 "java.sql.Types " + jdbcTypes_[column -1], "java.sql.Blob");
/////////////////////////////////////////////////////////////////////////
0:             throw new ColumnTypeConversionException(agent_.logWriter_,
0:                 "java.sql.Types " + jdbcTypes_[column -1], "java.sql.Clob");
0:         throw new SqlException(agent_.logWriter_, 
0:             new MessageId (SQLState.NOT_IMPLEMENTED),
1:             "getArray(int)");
0:         throw new SqlException(agent_.logWriter_, 
0:             new MessageId (SQLState.NOT_IMPLEMENTED), "getRef(int)");
/////////////////////////////////////////////////////////////////////////
0:             throw new ColumnTypeConversionException(agent_.logWriter_,
0:                 "java.sql.Types " + jdbcTypes_[column -1], "Object");
commit:d506170
/////////////////////////////////////////////////////////////////////////
1: import java.sql.SQLException;
1: 
/////////////////////////////////////////////////////////////////////////
0:         try {
0:             String tempString = null;
1:             switch (jdbcTypes_[column - 1]) {
0:             case JDBC30Translation.BOOLEAN:
0:                 return agent_.crossConverters_.getStringFromBoolean( getBoolean(column) );
0:             case java.sql.Types.CHAR:
1:                 return getCHAR(column);
0:             case java.sql.Types.VARCHAR:
0:             case java.sql.Types.LONGVARCHAR:
1:                 return getVARCHAR(column);
0:             case java.sql.Types.SMALLINT:
1:                 return String.valueOf(get_SMALLINT(column));
0:             case java.sql.Types.INTEGER:
1:                 return String.valueOf(get_INTEGER(column));
0:             case java.sql.Types.BIGINT:
1:                 return String.valueOf(get_BIGINT(column));
0:             case java.sql.Types.REAL:
1:                 return String.valueOf(get_FLOAT(column));
0:             case java.sql.Types.DOUBLE:
1:                 return String.valueOf(get_DOUBLE(column));
0:             case java.sql.Types.DECIMAL:
1:                 // We could get better performance here if we didn't materialize the BigDecimal,
1:                 // but converted directly from decimal bytes to a string.
1:                 return String.valueOf(get_DECIMAL(column));
0:             case java.sql.Types.DATE:
1:                 return getStringFromDATE(column);
0:             case java.sql.Types.TIME:
1:                 return getStringFromTIME(column);
0:             case java.sql.Types.TIMESTAMP:
1:                 return getStringFromTIMESTAMP(column);
0:             case Types.BINARY:
1:                 tempString =
1:                         agent_.crossConverters_.getStringFromBytes(get_CHAR_FOR_BIT_DATA(column));
1:                 return (maxFieldSize_ == 0) ? tempString :
0:                         tempString.substring(0, java.lang.Math.min(maxFieldSize_, tempString.length()));
0:             case java.sql.Types.VARBINARY:
0:             case java.sql.Types.LONGVARBINARY:
1:                 tempString =
1:                         agent_.crossConverters_.getStringFromBytes(get_VARCHAR_FOR_BIT_DATA(column));
1:                 return (maxFieldSize_ == 0) ? tempString :
0:                         tempString.substring(0, java.lang.Math.min(maxFieldSize_, tempString.length()));
0:             case java.sql.Types.BLOB:
0:                 Blob b = (Blob) getBlobColumn_(column, agent_);
0:                 return agent_.crossConverters_.getStringFromBytes(b.getBytes(1, (int) b.length()));
0:             case java.sql.Types.CLOB:
0:                 Clob c = getClobColumn_(column, agent_);
0:                 return c.getSubString(1, (int) c.length());
1:             default:
0:                 throw new ColumnTypeConversionException(agent_.logWriter_);
1:             }
1:         } catch ( SQLException se ) {
1:             throw new SqlException(se);
0:         try {
1:             switch (jdbcTypes_[column - 1]) {
0:             case java.sql.Types.BINARY:
1:                 return get_CHAR_FOR_BIT_DATA(column);
0:             case java.sql.Types.VARBINARY:
0:             case java.sql.Types.LONGVARBINARY:
1:                 return get_VARCHAR_FOR_BIT_DATA(column);
0:             case java.sql.Types.BLOB:
0:                 Blob b = (Blob) getBlobColumn_(column, agent_);
0:                 return b.getBytes(1, (int) b.length());
1:             default:
0:                 throw new ColumnTypeConversionException(agent_.logWriter_);
1:             }
1:         } catch ( SQLException se ) {
1:             throw new SqlException(se);
0:         try {
1:             switch (jdbcTypes_[column - 1]) {
0:             case java.sql.Types.BINARY:
0:                 return new java.io.ByteArrayInputStream(get_CHAR_FOR_BIT_DATA(column));
0:             case java.sql.Types.VARBINARY:
0:             case java.sql.Types.LONGVARBINARY:
0:                 return new java.io.ByteArrayInputStream(get_VARCHAR_FOR_BIT_DATA(column));
0:             case java.sql.Types.BLOB:
0:                 Blob b = (Blob) getBlobColumn_(column, agent_);
0:                 return b.getBinaryStream();
1:             default:
0:                 throw new ColumnTypeConversionException(agent_.logWriter_);
1:             }
1:         } catch ( SQLException se ) {
1:             throw new SqlException(se);
0:         try {
1:             switch (jdbcTypes_[column - 1]) {
0:             case java.sql.Types.CLOB:
0:                 Clob c = getClobColumn_(column, agent_);
0:                 return c.getAsciiStream();
0:             case java.sql.Types.CHAR:
0:                 try {
0:                     return new java.io.ByteArrayInputStream(getCHAR(column).getBytes("US-ASCII"));
0:                 } catch (java.io.UnsupportedEncodingException e) {
0:                     throw new SqlException(agent_.logWriter_, e.getMessage());
1:                 }
0:             case java.sql.Types.VARCHAR:
0:             case java.sql.Types.LONGVARCHAR:
0:                 try {
0:                     return new java.io.ByteArrayInputStream(getVARCHAR(column).getBytes("US-ASCII"));
0:                 } catch (java.io.UnsupportedEncodingException e) {
0:                     throw new SqlException(agent_.logWriter_, e.getMessage());
1:                 }
0:             case java.sql.Types.BINARY:
0:                 return new java.io.ByteArrayInputStream(get_CHAR_FOR_BIT_DATA(column));
0:             case java.sql.Types.VARBINARY:
0:             case java.sql.Types.LONGVARBINARY:
0:                 return new java.io.ByteArrayInputStream(get_VARCHAR_FOR_BIT_DATA(column));
0:             case java.sql.Types.BLOB:
0:                 Blob b = (Blob) getBlobColumn_(column, agent_);
0:                 return b.getBinaryStream();
1:             default:
0:                 throw new ColumnTypeConversionException(agent_.logWriter_);
1:         }
0:         catch ( SQLException se ) {
1:             throw new SqlException(se);
0:         try {
1:             switch (jdbcTypes_[column - 1]) {
0:             case java.sql.Types.CLOB:
0:                 {
0:                     Clob c = getClobColumn_(column, agent_);
0:                     String s = c.getSubString(1L, (int) c.length());
0:                     try {
0:                         return new java.io.ByteArrayInputStream(s.getBytes("UTF-8"));
0:                     } catch (java.io.UnsupportedEncodingException e) {
0:                         throw new SqlException(agent_.logWriter_, e.getMessage());
1:                     }
1:                 }
0:             case java.sql.Types.CHAR:
0:                 {
0:                     try {
0:                         return new java.io.ByteArrayInputStream(getCHAR(column).getBytes("UTF-8"));
0:                     } catch (java.io.UnsupportedEncodingException e) {
0:                         throw new SqlException(agent_.logWriter_, e.getMessage());
1:                     }
1:                 }
0:             case java.sql.Types.VARCHAR:
0:             case java.sql.Types.LONGVARCHAR:
0:                     return new java.io.ByteArrayInputStream(getVARCHAR(column).getBytes("UTF-8"));
0:             case java.sql.Types.BINARY:
0:                 return new java.io.ByteArrayInputStream(get_CHAR_FOR_BIT_DATA(column));
0:             case java.sql.Types.VARBINARY:
0:             case java.sql.Types.LONGVARBINARY:
0:                 return new java.io.ByteArrayInputStream(get_VARCHAR_FOR_BIT_DATA(column));
0:             case java.sql.Types.BLOB:
0:                 Blob b = (Blob) getBlobColumn_(column, agent_);
0:                 return b.getBinaryStream();
1:             default:
0:                 throw new ColumnTypeConversionException(agent_.logWriter_);
1:         } catch ( SQLException se ) {
1:             throw new SqlException(se);
0:         try {
1:             switch (jdbcTypes_[column - 1]) {
0:             case java.sql.Types.CLOB:
0:                 Clob c = getClobColumn_(column, agent_);
0:                 return c.getCharacterStream();
0:             case java.sql.Types.CHAR:
0:                 return new java.io.StringReader(getCHAR(column));
0:             case java.sql.Types.VARCHAR:
0:             case java.sql.Types.LONGVARCHAR:
0:                 return new java.io.StringReader(getVARCHAR(column));
0:             case java.sql.Types.BINARY:
0:                 try {
0:                     return new java.io.InputStreamReader(new java.io.ByteArrayInputStream(get_CHAR_FOR_BIT_DATA(column)), "UTF-16BE");
0:                 } catch (java.io.UnsupportedEncodingException e) {
0:                     throw new SqlException(agent_.logWriter_, "UnsupportedEncodingException: " + e.getMessage());
1:                 }
0:             case java.sql.Types.VARBINARY:
0:             case java.sql.Types.LONGVARBINARY:
0:                 try {
0:                     return new java.io.InputStreamReader(new java.io.ByteArrayInputStream(get_VARCHAR_FOR_BIT_DATA(column)), "UTF-16BE");
0:                 } catch (java.io.UnsupportedEncodingException e) {
0:                     throw new SqlException(agent_.logWriter_, "UnsupportedEncodingException: " + e.getMessage());
1:                 }
0:             case java.sql.Types.BLOB:
0:                 try {
0:                     Blob b = (Blob) getBlobColumn_(column, agent_);
0:                     return new java.io.InputStreamReader(b.getBinaryStream(), "UTF-16BE");
0:                 } catch (java.io.UnsupportedEncodingException e) {
0:                     throw new SqlException(agent_.logWriter_, "UnsupportedEncodingException: " + e.getMessage());
1:                 }
1:             default:
0:                 throw new ColumnTypeConversionException(agent_.logWriter_);
1:         } catch ( SQLException se ) {
1:             throw new SqlException(se);
author:Bernt Johnsen
-------------------------------------------------------------------------------
commit:c247315
/////////////////////////////////////////////////////////////////////////
1: 
1:     // State to keep track of when a row has been updated,
1:     // cf. corresponding set and get accessors.  Only implemented for
1:     // scrollable updatable insensitive result sets for now.
1:     private boolean isRowUpdated_;
1: 
/////////////////////////////////////////////////////////////////////////
1:         isRowUpdated_ = false;
/////////////////////////////////////////////////////////////////////////
1:         isRowUpdated_ = false;
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Keep track of updated status for this row.
1:      *
1:      * @param isRowUpdated true if row has been updated
1:      *
1:      * @see Cursor#getIsRowUpdated
1:      */
1:     public final void setIsRowUpdated(boolean isRowUpdated) {
1:         isRowUpdated_ = isRowUpdated;
1:     }
1: 
1:     /**
1:      * Get updated status for this row. 
1:      * Minion of ResultSet#rowUpdated.
1:      *
1:      * @see Cursor#setIsRowUpdated
1:      */
1:     public final boolean getIsRowUpdated() {
1:         return isRowUpdated_;
1:     }
1: 
1:     /**
1:      * Get deleted status for this row. 
1:      * Minion of ResultSet#rowDeleted.
1:      *
1:      * @see Cursor#setIsUpdataDeleteHole
1:      */
1:     public final boolean getIsUpdateDeleteHole() {
1:         return isUpdateDeleteHole_;
1:     }
1:     
commit:5e88312
/////////////////////////////////////////////////////////////////////////
1:     private boolean allRowsReceivedFromServer_;
/////////////////////////////////////////////////////////////////////////
1:         setAllRowsReceivedFromServer(false);
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Makes the next row the current row. Returns true if the current
1:      * row position is a valid row position.
1:      *
1:      * @param allowServerFetch if false, don't fetch more data from
1:      * the server even if more data is needed
0:      * @return <code>true</code> if current row position is valid
1:      * @exception SqlException if an error occurs
1:      */
1:     protected boolean stepNext(boolean allowServerFetch) throws SqlException {
/////////////////////////////////////////////////////////////////////////
0:         rowPositionIsValid = calculateColumnOffsetsForRow_(0, allowServerFetch);
1:     /**
1:      * Makes the next row the current row. Returns true if the current
1:      * row position is a valid row position.
1:      *
0:      * @return <code>true</code> if current row position is valid
1:      * @exception SqlException if an error occurs
1:      */
1:     public boolean next() throws SqlException {
1:         return stepNext(true);
1:     }
1: 
1:     /**
1:      * Set the value of value of allRowsReceivedFromServer_.
1:      *
0:      * @param b a <code>boolean</code> value indicating whether all
1:      * rows are received from the server
1:      */
1:     public void setAllRowsReceivedFromServer(boolean b) {
1:     /**
0:      * Return <code>true</code> if all rows are received from the
1:      * server.
1:      *
0:      * @return <code>true</code> if all rows are received from the
1:      * server.
1:      */
1:     public final boolean allRowsReceivedFromServer() {
1:         return allRowsReceivedFromServer_;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:         setAllRowsReceivedFromServer(false);
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Calculate the column offsets for a row.
1:      *
1:      * @param row row index
1:      * @param allowServerFetch if true, allow fetching more data from
1:      * server
0:      * @return <code>true</code> if the current row position is a
1:      * valid row position.
1:      * @exception SqlException
1:      * @exception DisconnectException
1:      */
1:     protected abstract boolean
1:         calculateColumnOffsetsForRow_(int row, boolean allowServerFetch)
1:         throws SqlException, DisconnectException;
commit:11ee500
/////////////////////////////////////////////////////////////////////////
1:         
1:         // Moving out of the hole, set isUpdateDeleteHole to false
1:         isUpdateDeleteHole_ = false;
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:90731d5
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.reference.JDBC30Translation;
1: 
/////////////////////////////////////////////////////////////////////////
0:     // Build a Java boolean from a 1-byte signed binary representation.
0:     private final boolean get_BOOLEAN(int column) {
0:         return org.apache.derby.client.am.SignedBinary.getBoolean(dataBuffer_,
1:                 columnDataPosition_[column - 1]);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:         case JDBC30Translation.BOOLEAN:
0:             return get_BOOLEAN(column);
/////////////////////////////////////////////////////////////////////////
0:         case JDBC30Translation.BOOLEAN:
0:             return agent_.crossConverters_.getByteFromBoolean( getBoolean(column) );
/////////////////////////////////////////////////////////////////////////
0:         case JDBC30Translation.BOOLEAN:
0:             return agent_.crossConverters_.getShortFromBoolean( getBoolean(column) );
/////////////////////////////////////////////////////////////////////////
0:         case JDBC30Translation.BOOLEAN:
0:             return agent_.crossConverters_.getIntFromBoolean( getBoolean(column) );
/////////////////////////////////////////////////////////////////////////
0:         case JDBC30Translation.BOOLEAN:
0:             return agent_.crossConverters_.getLongFromBoolean( getBoolean(column) );
/////////////////////////////////////////////////////////////////////////
0:         case JDBC30Translation.BOOLEAN:
0:             return agent_.crossConverters_.getFloatFromBoolean( getBoolean(column) );
/////////////////////////////////////////////////////////////////////////
0:         case JDBC30Translation.BOOLEAN:
0:             return agent_.crossConverters_.getDoubleFromBoolean( getBoolean(column) );
/////////////////////////////////////////////////////////////////////////
0:         case JDBC30Translation.BOOLEAN:
0:             return agent_.crossConverters_.getBigDecimalFromBoolean( getBoolean(column) );
/////////////////////////////////////////////////////////////////////////
0:         case JDBC30Translation.BOOLEAN:
0:             return agent_.crossConverters_.getStringFromBoolean( getBoolean(column) );
/////////////////////////////////////////////////////////////////////////
0:         case JDBC30Translation.BOOLEAN:
0:             return new Boolean( getBoolean(column) );
author:Jeremy Boynes
-------------------------------------------------------------------------------
commit:70f7692
/////////////////////////////////////////////////////////////////////////
1: public abstract class Cursor {
1:     protected Agent agent_;
1:     //-----------------------------varchar representations------------------------
1:     public final static int STRING = 0;
1:     public final static int VARIABLE_STRING = 2;       // uses a 2-byte length indicator
1:     public final static int VARIABLE_SHORT_STRING = 1; // aka Pascal L; uses a 1-byte length indicator
1:     public final static int NULL_TERMINATED_STRING = 3;
1:     public final static int BYTES = 4;
0:     public final static int VARIABLE_BYTES = 5;
0:     public final static int VARIABLE_SHORT_BYTES = 6;
1:     public final static int NULL_TERMINATED_BYTES = 7;
0:     public final static int SBCS_CLOB = 8;
0:     public final static int MBCS_CLOB = 9;
0:     public final static int DBCS_CLOB = 10;
1:     //-----------------------------internal state---------------------------------
1:     //-------------Structures for holding and scrolling the data -----------------
1:     public byte[] dataBuffer_;
0:     public java.io.ByteArrayOutputStream dataBufferStream_;
1:     public int position_; // This is the read head
1:     public int lastValidBytePosition_;
1:     public boolean hasLobs_; // is there at least one LOB column?
1:     // Current row positioning
1:     protected int currentRowPosition_;
1:     private int nextRowPosition_;
1:     // Let's new up a 2-dimensional array based on fetch-size and reuse so that
1:     protected int[] columnDataPosition_;
1:     // This is the actual, computed lengths of varchar fields, not the max length from query descriptor or DA
1:     protected int[] columnDataComputedLength_;
1:     // populate this for
1:     // All the data is in the buffers, but user may not have necessarily stepped to the last row yet.
1:     // This flag indicates that the server has returned all the rows, and is positioned
1:     // after last, for both scrollable and forward-only cursors.
1:     // For singleton cursors, this memeber will be set to true as soon as next is called.
0:     public boolean allRowsReceivedFromServer_;
1:     // Total number of rows read so far.
1:     // This should never exceed this.statement.maxRows
0:     int rowsRead_;
1:     // Maximum column size limit in bytes.
1:     int maxFieldSize_ = 0;
1:     // Row positioning for all cached rows
1:     // For scrollable result sets, these lists hold the offsets into the cached rowset buffer for each row of data.
0:     protected java.util.ArrayList columnDataPositionCache_ = new java.util.ArrayList();
0:     protected java.util.ArrayList columnDataLengthCache_ = new java.util.ArrayList();
0:     protected java.util.ArrayList columnDataIsNullCache_ = new java.util.ArrayList();
0:     public java.util.ArrayList isUpdateDeleteHoleCache_ = new java.util.ArrayList();
0:     public boolean isUpdateDeleteHole_;
0:     final static public java.lang.Boolean ROW_IS_NULL = new Boolean(true);
0:     final static public java.lang.Boolean ROW_IS_NOT_NULL = new Boolean(false);
0:     java.sql.Date recyclableDate_ = null;
0:     java.sql.Time recyclableTime_ = null;
0:     java.sql.Timestamp recyclableTimestamp_ = null;
1:     // For the net, this data comes from the query descriptor.
1:     public int[] jdbcTypes_;
1:     public int columns_;
1:     public boolean[] nullable_;
0:     public String[] charsetName_;
1:     public boolean[] isNull_;
1:     public int[] fdocaLength_; // this is the max length for
1:     //----------------------------------------------------------------------------
1:     public int[] ccsid_;
0:     char[] charBuffer_;
1:     //---------------------constructors/finalizer---------------------------------
1:     public Cursor(Agent agent) {
1:         agent_ = agent;
0:         dataBufferStream_ = new java.io.ByteArrayOutputStream();
0:     public Cursor(Agent agent, byte[] dataBuffer) {
0:         this(agent);
0:         dataBuffer_ = dataBuffer;
0:         allRowsReceivedFromServer_ = false;
1:     public void setNumberOfColumns(int numberOfColumns) {
1:         columnDataPosition_ = new int[numberOfColumns];
1:         columnDataComputedLength_ = new int[numberOfColumns];
1:         columns_ = numberOfColumns;
1:         nullable_ = new boolean[numberOfColumns];
0:         charsetName_ = new String[numberOfColumns];
1:         ccsid_ = new int[numberOfColumns];
1: 
1:         isNull_ = new boolean[numberOfColumns];
1:         jdbcTypes_ = new int[numberOfColumns];
0:     // Makes the next row the current row.
0:     // Returns true if the current row position is a valid row position.
0:     public boolean next() throws SqlException {
0:         // local variable usd to hold the returned value from calculateColumnOffsetsForRow()
0:         boolean rowPositionIsValid = true;
1:         // reset lob data
1:         // clears out Cursor.lobs_ calculated for the current row when cursor is moved.
1:         clearLobData_();
1:         // mark the start of a new row.
1:         makeNextRowPositionCurrent();
1:         // Drive the CNTQRY outside of calculateColumnOffsetsForRow() if the dataBuffer_
1:         // contains no data since it has no abilities to handle replies other than
1:         // the QRYDTA, i.e. ENDQRYRM when the result set contains no more rows.
1:         while (!dataBufferHasUnprocessedData()) {
1:             if (allRowsReceivedFromServer_) {
1:                 return false;
1:             }
1:             getMoreData_();
1:         }
1:         // The parameter passed in here is used as an index into the cached rowset for
1:         // scrollable cursors, for the arrays to be reused.  It is not used for forward-only
1:         // cursors, so just pass in 0.
0:         rowPositionIsValid = calculateColumnOffsetsForRow_(0);  // readFetchedRows()
1:         markNextRowPosition();
1:         return rowPositionIsValid;
1:     }
1: 
1:     //--------------------------reseting cursor state-----------------------------
1: 
0:     public final void setAllRowsReceivedFromServer(boolean b) {
1:         allRowsReceivedFromServer_ = b;
1:     }
1: 
0:     public final boolean currentRowPositionIsEqualToNextRowPosition() {
1:         return (currentRowPosition_ == nextRowPosition_);
1:     }
1: 
1:     // reset the beginning and ending position in the data buffer to 0
1:     // reset the currentRowPosition and nextRowPosition to 0
1:     // reset lastRowReached and sqlcode100Received to false
1:     // clear the column data offsets cache
1:     public final void resetDataBuffer() {
1:         position_ = 0;
1:         lastValidBytePosition_ = 0;
1:         currentRowPosition_ = 0;
1:         nextRowPosition_ = 0;
0:         allRowsReceivedFromServer_ = false;
1:         dataBufferStream_.reset();
1:     }
1: 
0:     public final boolean dataBufferHasUnprocessedData() {
1:         return (lastValidBytePosition_ - position_) > 0;
1:     }
1: 
0:     protected abstract boolean calculateColumnOffsetsForRow_(int row) throws SqlException, DisconnectException;
1: 
1:     protected abstract void clearLobData_();
1: 
1:     protected abstract void getMoreData_() throws SqlException;
1: 
0:     // Associate a new underlying COM or SQLDA output data buffer for this converter.
0:     public final void setBuffer(byte[] dataBuffer) {
0:         dataBuffer_ = dataBuffer;
1:     }
1: 
1:     public final void setIsUpdataDeleteHole(int row, boolean isRowNull) {
1:         isUpdateDeleteHole_ = isRowNull;
1:         Boolean nullIndicator = (isUpdateDeleteHole_ == true) ? ROW_IS_NULL : ROW_IS_NOT_NULL;
1:         if (isUpdateDeleteHoleCache_.size() == row) {
1:             isUpdateDeleteHoleCache_.add(nullIndicator);
1:         } else {
1:             isUpdateDeleteHoleCache_.set(row, nullIndicator);
1:         }
1:     }
1:     //---------------------------cursor positioning-------------------------------
1: 
0:     final int getPosition() {
0:         return position_;
1:     }
1: 
0:     final void setPosition(int newPosition) {
0:         position_ = newPosition;
1:     }
1: 
0:     public final void markCurrentRowPosition() {
0:         currentRowPosition_ = position_;
1:     }
1: 
0:     public final void markNextRowPosition() {
1:         nextRowPosition_ = position_;
1:     }
1: 
0:     public final void makeNextRowPositionCurrent() {
1:         currentRowPosition_ = nextRowPosition_;
1:     }
1: 
0:     final void repositionCursorToCurrentRow() {
0:         position_ = currentRowPosition_;
1:     }
1: 
0:     final void repositionCursorToNextRow() {
0:         position_ = nextRowPosition_;
1:     }
1: 
0:     public final byte[] getDataBuffer() {
0:         return dataBuffer_;
1:     }
1: 
0:     public final int getDataBufferLength() {
0:         return dataBuffer_.length;
1:     }
1: 
0:     public final int getLastValidBytePosition() {
0:         return lastValidBytePosition_;
1:     }
1: 
1:     // This tracks the total number of rows read into the client side buffer for
1:     // this result set, irregardless of scrolling.
1:     // Per jdbc semantics, this should never exceed statement.maxRows.
1:     // This event should be generated in the materialized cursor's implementation
1:     // of calculateColumnOffsetsForRow().
1:     public final void incrementRowsReadEvent() {
1:         rowsRead_++;
1:     }
1: 
1:     //------- the following getters are called on known column types -------------
1:     // Direct conversions only, cross conversions are handled by another set of getters.
1: 
1:     // Build a Java short from a 2-byte signed binary representation.
0:     private final short get_SMALLINT(int column) {
0:         return org.apache.derby.client.am.SignedBinary.getShort(dataBuffer_,
1:                 columnDataPosition_[column - 1]);
1:     }
1: 
1:     // Build a Java int from a 4-byte signed binary representation.
0:     private final int get_INTEGER(int column) {
0:         return org.apache.derby.client.am.SignedBinary.getInt(dataBuffer_,
1:                 columnDataPosition_[column - 1]);
1:     }
1: 
1:     // Build a Java long from an 8-byte signed binary representation.
0:     private final long get_BIGINT(int column) {
0:         return org.apache.derby.client.am.SignedBinary.getLong(dataBuffer_,
1:                 columnDataPosition_[column - 1]);
1:     }
1: 
1:     // Build a Java float from a 4-byte floating point representation.
0:     private final float get_FLOAT(int column) {
0:         return org.apache.derby.client.am.FloatingPoint.getFloat(dataBuffer_,
1:                 columnDataPosition_[column - 1]);
1:     }
1: 
1:     // Build a Java double from an 8-byte floating point representation.
0:     private final double get_DOUBLE(int column) {
0:         return org.apache.derby.client.am.FloatingPoint.getDouble(dataBuffer_,
1:                 columnDataPosition_[column - 1]);
1:     }
1: 
1:     // Build a java.math.BigDecimal from a fixed point decimal byte representation.
0:     private final java.math.BigDecimal get_DECIMAL(int column) throws SqlException {
0:         try {
0:             return org.apache.derby.client.am.Decimal.getBigDecimal(dataBuffer_,
0:                     columnDataPosition_[column - 1],
1:                     getColumnPrecision(column - 1),
1:                     getColumnScale(column - 1));
0:         } catch (java.io.UnsupportedEncodingException e) {
0:             throw new SqlException(agent_.logWriter_, e, "Encoding is unsupported for conversion to BigDecimal");
1:         }
1:     }
1: 
1: 
1:     // Build a Java double from a fixed point decimal byte representation.
0:     private final double getDoubleFromDECIMAL(int column) throws SqlException {
0:         try {
0:             return org.apache.derby.client.am.Decimal.getDouble(dataBuffer_,
0:                     columnDataPosition_[column - 1],
1:                     getColumnPrecision(column - 1),
1:                     getColumnScale(column - 1));
0:         } catch (java.lang.IllegalArgumentException e) {
0:             throw new SqlException(agent_.logWriter_, e, "Decimal value is out of range for conversion to double");
0:         } catch (java.io.UnsupportedEncodingException e) {
0:             throw new SqlException(agent_.logWriter_, e, "Encoding is unsupported for conversion to BigDecimal");
1:         }
1:     }
1: 
1:     // Build a Java long from a fixed point decimal byte representation.
0:     private final long getLongFromDECIMAL(int column) throws SqlException {
0:         try {
0:             return org.apache.derby.client.am.Decimal.getLong(dataBuffer_,
0:                     columnDataPosition_[column - 1],
1:                     getColumnPrecision(column - 1),
1:                     getColumnScale(column - 1));
0:         } catch (java.lang.IllegalArgumentException e) {
0:             throw new SqlException(agent_.logWriter_, e, "Decimal value is out of range for conversion to long");
0:         } catch (java.io.UnsupportedEncodingException e) {
0:             throw new SqlException(agent_.logWriter_, e, "Encoding is unsupported for conversion to BigDecimal");
1:         }
1:     }
1: 
1:     // Build a Java String from a database VARCHAR or LONGVARCHAR field.
1:     //
1:     // Depending on the ccsid, length is the number of chars or number of bytes.
1:     // For 2-byte character ccsids, length is the number of characters,
1:     // for all other cases length is the number of bytes.
1:     // The length does not include the null terminator.
0:     private final String getVARCHAR(int column) throws SqlException {
0:         String tempString = null;
0:         try {
1:             if (ccsid_[column - 1] == 1200) {
0:                 return getStringWithoutConvert(columnDataPosition_[column - 1] + 2, columnDataComputedLength_[column - 1] - 2);
1:             }
1: 
0:             // check for null encoding is needed because the net layer
0:             // will no longer throw an exception if the server didn't specify
0:             // a mixed or double byte ccsid (ccsid = 0).  this check for null in the
0:             // cursor is only required for types which can have mixed or double
0:             // byte ccsids.
0:             if (charsetName_[column - 1] == null) {
0:                 throw new SqlException(agent_.logWriter_,
0:                         "Required character converter not available for data type.");
1:             }
1: 
0:             tempString = new String(dataBuffer_,
0:                     columnDataPosition_[column - 1] + 2,
0:                     columnDataComputedLength_[column - 1] - 2,
0:                     charsetName_[column - 1]);
0:             return (maxFieldSize_ == 0) ? tempString :
0:                     tempString.substring(0, java.lang.Math.min(maxFieldSize_, tempString.length()));
0:         } catch (java.io.UnsupportedEncodingException e) {
0:             throw new SqlException(agent_.logWriter_, e, "unsupported encoding for result set column " + column);
1:         }
1:     }
1: 
1:     // Build a Java String from a database CHAR field.
0:     private final String getCHAR(int column) throws SqlException {
0:         String tempString = null;
1:         if (ccsid_[column - 1] == 1200) {
1:             return getStringWithoutConvert(columnDataPosition_[column - 1], columnDataComputedLength_[column - 1]);
1:         }
1: 
0:         try {
0:             // check for null encoding is needed because the net layer
0:             // will no longer throw an exception if the server didn't specify
0:             // a mixed or double byte ccsid (ccsid = 0).  this check for null in the
0:             // cursor is only required for types which can have mixed or double
0:             // byte ccsids.
0:             if (charsetName_[column - 1] == null) {
0:                 throw new SqlException(agent_.logWriter_,
0:                         "Required character converter not available for data type.");
1:             }
1: 
0:             tempString = new String(dataBuffer_,
0:                     columnDataPosition_[column - 1],
0:                     columnDataComputedLength_[column - 1],
0:                     charsetName_[column - 1]);
0:             return (maxFieldSize_ == 0) ? tempString :
0:                     tempString.substring(0, java.lang.Math.min(maxFieldSize_, tempString.length()));
0:         } catch (java.io.UnsupportedEncodingException e) {
0:             throw new SqlException(agent_.logWriter_, e, "unsupported encoding for result set column " + column);
1:         }
1:     }
1: 
1:     // Build a JDBC Date object from the DERBY ISO DATE field.
0:     private final java.sql.Date getDATE(int column) throws SqlException {
0:         return org.apache.derby.client.am.DateTime.dateBytesToDate(dataBuffer_,
0:                 columnDataPosition_[column - 1],
0:                 recyclableDate_);
1:     }
1: 
1:     // Build a JDBC Time object from the DERBY ISO TIME field.
0:     private final java.sql.Time getTIME(int column) throws SqlException {
0:         return org.apache.derby.client.am.DateTime.timeBytesToTime(dataBuffer_,
0:                 columnDataPosition_[column - 1],
0:                 recyclableTime_);
1:     }
1: 
1:     // Build a JDBC Timestamp object from the DERBY ISO TIMESTAMP field.
0:     private final java.sql.Timestamp getTIMESTAMP(int column) throws SqlException {
0:         return org.apache.derby.client.am.DateTime.timestampBytesToTimestamp(dataBuffer_,
0:                 columnDataPosition_[column - 1],
0:                 recyclableTimestamp_);
1:     }
1: 
1:     // Build a JDBC Timestamp object from the DERBY ISO DATE field.
0:     private final java.sql.Timestamp getTimestampFromDATE(int column) throws SqlException {
0:         return org.apache.derby.client.am.DateTime.dateBytesToTimestamp(dataBuffer_,
0:                 columnDataPosition_[column - 1],
0:                 recyclableTimestamp_);
1:     }
1: 
1:     // Build a JDBC Timestamp object from the DERBY ISO TIME field.
0:     private final java.sql.Timestamp getTimestampFromTIME(int column) throws SqlException {
0:         return org.apache.derby.client.am.DateTime.timeBytesToTimestamp(dataBuffer_,
0:                 columnDataPosition_[column - 1],
0:                 recyclableTimestamp_);
1:     }
1: 
1:     // Build a JDBC Date object from the DERBY ISO TIMESTAMP field.
0:     private final java.sql.Date getDateFromTIMESTAMP(int column) throws SqlException {
0:         return org.apache.derby.client.am.DateTime.timestampBytesToDate(dataBuffer_,
0:                 columnDataPosition_[column - 1],
0:                 recyclableDate_);
1:     }
1: 
1:     // Build a JDBC Time object from the DERBY ISO TIMESTAMP field.
0:     private final java.sql.Time getTimeFromTIMESTAMP(int column) throws SqlException {
0:         return org.apache.derby.client.am.DateTime.timestampBytesToTime(dataBuffer_,
0:                 columnDataPosition_[column - 1],
0:                 recyclableTime_);
1:     }
1: 
0:     private final String getStringFromDATE(int column) throws SqlException {
0:         return org.apache.derby.client.am.DateTime.dateBytesToDate(dataBuffer_,
0:                 columnDataPosition_[column - 1],
0:                 recyclableDate_).toString();
1:     }
1: 
1:     // Build a string object from the DERBY byte TIME representation.
0:     private final String getStringFromTIME(int column) throws SqlException {
0:         return org.apache.derby.client.am.DateTime.timeBytesToTime(dataBuffer_,
0:                 columnDataPosition_[column - 1],
0:                 recyclableTime_).toString();
1:     }
1: 
1:     // Build a string object from the DERBY byte TIMESTAMP representation.
0:     private final String getStringFromTIMESTAMP(int column) throws SqlException {
0:         return org.apache.derby.client.am.DateTime.timestampBytesToTimestamp(dataBuffer_,
0:                 columnDataPosition_[column - 1],
0:                 recyclableTimestamp_).toString();
1:     }
1: 
0:     // Extract bytes from a database java.sql.Types.BINARY field.
1:     // This is the DERBY type CHAR(n) FOR BIT DATA.
0:     private final byte[] get_CHAR_FOR_BIT_DATA(int column) throws SqlException {
1:         // There is no limit to the size of a column if maxFieldSize is zero.
1:         // Otherwise, use the smaller of maxFieldSize and the actual column length.
1:         int columnLength = (maxFieldSize_ == 0) ? columnDataComputedLength_[column - 1] :
0:                 java.lang.Math.min(maxFieldSize_, columnDataComputedLength_[column - 1]);
1: 
1:         byte[] bytes = new byte[columnLength];
1:         System.arraycopy(dataBuffer_, columnDataPosition_[column - 1], bytes, 0, columnLength);
1:         return bytes;
1:     }
1: 
0:     // Extract bytes from a database java.sql.Types.VARBINARY or LONGVARBINARY field.
1:     // This includes the DERBY types:
1:     //   VARCHAR(n) FOR BIT DATA
1:     //   LONG VARCHAR(n) FOR BIT DATA
0:     private final byte[] get_VARCHAR_FOR_BIT_DATA(int column) throws SqlException {
1:         byte[] bytes;
0:         int columnLength = 0;
0:         columnLength = (maxFieldSize_ == 0) ? columnDataComputedLength_[column - 1] - 2 :
0:                 java.lang.Math.min(maxFieldSize_, columnDataComputedLength_[column - 1] - 2);
1:         bytes = new byte[columnLength];
1:         System.arraycopy(dataBuffer_, columnDataPosition_[column - 1] + 2, bytes, 0, bytes.length);
1:         return bytes;
1:     }
1: 
0:     abstract public Blob getBlobColumn_(int column, Agent agent) throws SqlException;
1: 
0:     abstract public Clob getClobColumn_(int column, Agent agent) throws SqlException;
1: 
0:     // get the raw clob bytes, without translation.  dataOffset must be int[1]
0:     abstract public byte[] getClobBytes_(int column, int[] dataOffset /*output*/) throws SqlException;
1: 
1:     //------- the following getters perform any necessary cross-conversion _------
1: 
1:     final boolean getBoolean(int column) throws SqlException {
1:         switch (jdbcTypes_[column - 1]) {
0:         case java.sql.Types.SMALLINT:
1:             return agent_.crossConverters_.getBooleanFromShort(get_SMALLINT(column));
0:         case java.sql.Types.INTEGER:
1:             return agent_.crossConverters_.getBooleanFromInt(get_INTEGER(column));
0:         case java.sql.Types.BIGINT:
1:             return agent_.crossConverters_.getBooleanFromLong(get_BIGINT(column));
0:         case java.sql.Types.REAL:
1:             return agent_.crossConverters_.getBooleanFromFloat(get_FLOAT(column));
0:         case java.sql.Types.DOUBLE:
1:             return agent_.crossConverters_.getBooleanFromDouble(get_DOUBLE(column));
0:         case java.sql.Types.DECIMAL:
1:             // For performance we don't materialize the BigDecimal, but convert directly from decimal bytes to a long.
0:             return agent_.crossConverters_.getBooleanFromLong(getLongFromDECIMAL(column));
0:         case java.sql.Types.CHAR:
1:             return agent_.crossConverters_.getBooleanFromString(getCHAR(column));
0:         case java.sql.Types.VARCHAR:
0:         case java.sql.Types.LONGVARCHAR:
1:             return agent_.crossConverters_.getBooleanFromString(getVARCHAR(column));
1:         default:
0:             throw new ColumnTypeConversionException(agent_.logWriter_);
1:         }
1:     }
1: 
1:     final byte getByte(int column) throws SqlException {
1:         // This needs to be changed to use jdbcTypes[]
1:         switch (jdbcTypes_[column - 1]) {
0:         case java.sql.Types.SMALLINT:
1:             return agent_.crossConverters_.getByteFromShort(get_SMALLINT(column));
0:         case java.sql.Types.INTEGER:
1:             return agent_.crossConverters_.getByteFromInt(get_INTEGER(column));
0:         case java.sql.Types.BIGINT:
1:             return agent_.crossConverters_.getByteFromLong(get_BIGINT(column));
0:         case java.sql.Types.REAL:
1:             return agent_.crossConverters_.getByteFromFloat(get_FLOAT(column));
0:         case java.sql.Types.DOUBLE:
1:             return agent_.crossConverters_.getByteFromDouble(get_DOUBLE(column));
0:         case java.sql.Types.DECIMAL:
1:             // For performance we don't materialize the BigDecimal, but convert directly from decimal bytes to a long.
0:             return agent_.crossConverters_.getByteFromLong(getLongFromDECIMAL(column));
0:         case java.sql.Types.CHAR:
1:             return agent_.crossConverters_.getByteFromString(getCHAR(column));
0:         case java.sql.Types.VARCHAR:
0:         case java.sql.Types.LONGVARCHAR:
1:             return agent_.crossConverters_.getByteFromString(getVARCHAR(column));
1:         default:
0:             throw new ColumnTypeConversionException(agent_.logWriter_);
1:         }
1:     }
1: 
1:     final short getShort(int column) throws SqlException {
1:         switch (jdbcTypes_[column - 1]) {
0:         case java.sql.Types.SMALLINT:
1:             return get_SMALLINT(column);
0:         case java.sql.Types.INTEGER:
1:             return agent_.crossConverters_.getShortFromInt(get_INTEGER(column));
0:         case java.sql.Types.BIGINT:
1:             return agent_.crossConverters_.getShortFromLong(get_BIGINT(column));
0:         case java.sql.Types.REAL:
1:             return agent_.crossConverters_.getShortFromFloat(get_FLOAT(column));
0:         case java.sql.Types.DOUBLE:
1:             return agent_.crossConverters_.getShortFromDouble(get_DOUBLE(column));
0:         case java.sql.Types.DECIMAL:
1:             // For performance we don't materialize the BigDecimal, but convert directly from decimal bytes to a long.
0:             return agent_.crossConverters_.getShortFromLong(getLongFromDECIMAL(column));
0:         case java.sql.Types.CHAR:
1:             return agent_.crossConverters_.getShortFromString(getCHAR(column));
0:         case java.sql.Types.VARCHAR:
0:         case java.sql.Types.LONGVARCHAR:
1:             return agent_.crossConverters_.getShortFromString(getVARCHAR(column));
1:         default:
0:             throw new ColumnTypeConversionException(agent_.logWriter_);
1:         }
1:     }
1: 
1:     final int getInt(int column) throws SqlException {
1:         switch (jdbcTypes_[column - 1]) {
0:         case java.sql.Types.SMALLINT:
1:             return (int) get_SMALLINT(column);
0:         case java.sql.Types.INTEGER:
1:             return get_INTEGER(column);
0:         case java.sql.Types.BIGINT:
1:             return agent_.crossConverters_.getIntFromLong(get_BIGINT(column));
0:         case java.sql.Types.REAL:
1:             return agent_.crossConverters_.getIntFromFloat(get_FLOAT(column));
0:         case java.sql.Types.DOUBLE:
1:             return agent_.crossConverters_.getIntFromDouble(get_DOUBLE(column));
0:         case java.sql.Types.DECIMAL:
1:             // For performance we don't materialize the BigDecimal, but convert directly from decimal bytes to a long.
0:             return agent_.crossConverters_.getIntFromLong(getLongFromDECIMAL(column));
0:         case java.sql.Types.CHAR:
1:             return agent_.crossConverters_.getIntFromString(getCHAR(column));
0:         case java.sql.Types.VARCHAR:
0:         case java.sql.Types.LONGVARCHAR:
1:             return agent_.crossConverters_.getIntFromString(getVARCHAR(column));
1:         default:
0:             throw new ColumnTypeConversionException(agent_.logWriter_);
1:         }
1:     }
1: 
1:     final long getLong(int column) throws SqlException {
1:         switch (jdbcTypes_[column - 1]) {
0:         case java.sql.Types.SMALLINT:
1:             return (long) get_SMALLINT(column);
0:         case java.sql.Types.INTEGER:
1:             return (long) get_INTEGER(column);
0:         case java.sql.Types.BIGINT:
1:             return get_BIGINT(column);
0:         case java.sql.Types.REAL:
1:             return agent_.crossConverters_.getLongFromFloat(get_FLOAT(column));
0:         case java.sql.Types.DOUBLE:
1:             return agent_.crossConverters_.getLongFromDouble(get_DOUBLE(column));
0:         case java.sql.Types.DECIMAL:
1:             // For performance we don't materialize the BigDecimal, but convert directly from decimal bytes to a long.
0:             return getLongFromDECIMAL(column);
0:         case java.sql.Types.CHAR:
1:             return agent_.crossConverters_.getLongFromString(getCHAR(column));
0:         case java.sql.Types.VARCHAR:
0:         case java.sql.Types.LONGVARCHAR:
1:             return agent_.crossConverters_.getLongFromString(getVARCHAR(column));
1:         default:
0:             throw new ColumnTypeConversionException(agent_.logWriter_);
1:         }
1:     }
1: 
1:     final float getFloat(int column) throws SqlException {
1:         switch (jdbcTypes_[column - 1]) {
0:         case java.sql.Types.REAL:
1:             return get_FLOAT(column);
0:         case java.sql.Types.DOUBLE:
1:             return agent_.crossConverters_.getFloatFromDouble(get_DOUBLE(column));
0:         case java.sql.Types.DECIMAL:
1:             // For performance we don't materialize the BigDecimal, but convert directly from decimal bytes to a long.
1:             return agent_.crossConverters_.getFloatFromDouble(getDoubleFromDECIMAL(column));
0:         case java.sql.Types.SMALLINT:
1:             return (float) get_SMALLINT(column);
0:         case java.sql.Types.INTEGER:
1:             return (float) get_INTEGER(column);
0:         case java.sql.Types.BIGINT:
1:             return (float) get_BIGINT(column);
0:         case java.sql.Types.CHAR:
1:             return agent_.crossConverters_.getFloatFromString(getCHAR(column));
0:         case java.sql.Types.VARCHAR:
0:         case java.sql.Types.LONGVARCHAR:
1:             return agent_.crossConverters_.getFloatFromString(getVARCHAR(column));
1:         default:
0:             throw new ColumnTypeConversionException(agent_.logWriter_);
1:         }
1:     }
1: 
1:     final double getDouble(int column) throws SqlException {
1:         switch (jdbcTypes_[column - 1]) {
0:         case java.sql.Types.REAL:
1:             double d = (double) get_FLOAT(column);
1:             return d;
1:             //return (double) get_FLOAT (column);
0:         case java.sql.Types.DOUBLE:
1:             return get_DOUBLE(column);
0:         case java.sql.Types.DECIMAL:
1:             // For performance we don't materialize the BigDecimal, but convert directly from decimal bytes to a long.
1:             return getDoubleFromDECIMAL(column);
0:         case java.sql.Types.SMALLINT:
1:             return (double) get_SMALLINT(column);
0:         case java.sql.Types.INTEGER:
1:             return (double) get_INTEGER(column);
0:         case java.sql.Types.BIGINT:
1:             return (double) get_BIGINT(column);
0:         case java.sql.Types.CHAR:
1:             return agent_.crossConverters_.getDoubleFromString(getCHAR(column));
0:         case java.sql.Types.VARCHAR:
0:         case java.sql.Types.LONGVARCHAR:
1:             return agent_.crossConverters_.getDoubleFromString(getVARCHAR(column));
1:         default:
0:             throw new ColumnTypeConversionException(agent_.logWriter_);
1:         }
1:     }
1: 
0:     final java.math.BigDecimal getBigDecimal(int column) throws SqlException {
1:         switch (jdbcTypes_[column - 1]) {
0:         case java.sql.Types.DECIMAL:
1:             return get_DECIMAL(column);
0:         case java.sql.Types.REAL:
1:             // Can't use the following commented out line because it changes precision of the result.
1:             //return new java.math.BigDecimal (get_FLOAT (column));
1:             float f = get_FLOAT(column);
0:             return new java.math.BigDecimal(String.valueOf(f));
0:         case java.sql.Types.DOUBLE:
1:             // Can't use the following commented out line because it changes precision of the result.
0:             return new java.math.BigDecimal(String.valueOf(get_DOUBLE(column)));
0:         case java.sql.Types.SMALLINT:
0:             return java.math.BigDecimal.valueOf(get_SMALLINT(column));
0:         case java.sql.Types.INTEGER:
0:             return java.math.BigDecimal.valueOf(get_INTEGER(column));
0:         case java.sql.Types.BIGINT:
0:             return java.math.BigDecimal.valueOf(get_BIGINT(column));
0:         case java.sql.Types.CHAR:
1:             return agent_.crossConverters_.getBigDecimalFromString(getCHAR(column));
0:         case java.sql.Types.VARCHAR:
0:         case java.sql.Types.LONGVARCHAR:
1:             return agent_.crossConverters_.getBigDecimalFromString(getVARCHAR(column));
1:         default:
0:             throw new ColumnTypeConversionException(agent_.logWriter_);
1:         }
1:     }
1: 
0:     final java.sql.Date getDate(int column) throws SqlException {
1:         switch (jdbcTypes_[column - 1]) {
0:         case java.sql.Types.DATE:
0:             return getDATE(column);
0:         case java.sql.Types.TIMESTAMP:
0:             return getDateFromTIMESTAMP(column);
0:         case java.sql.Types.CHAR:
0:             return agent_.crossConverters_.getDateFromString(getCHAR(column));
0:         case java.sql.Types.VARCHAR:
0:         case java.sql.Types.LONGVARCHAR:
0:             return agent_.crossConverters_.getDateFromString(getVARCHAR(column));
1:         default:
0:             throw new ColumnTypeConversionException(agent_.logWriter_);
1:         }
1:     }
1: 
0:     final java.sql.Time getTime(int column) throws SqlException {
1:         switch (jdbcTypes_[column - 1]) {
0:         case java.sql.Types.TIME:
0:             return getTIME(column);
0:         case java.sql.Types.TIMESTAMP:
0:             return getTimeFromTIMESTAMP(column);
0:         case java.sql.Types.CHAR:
0:             return agent_.crossConverters_.getTimeFromString(getCHAR(column));
0:         case java.sql.Types.VARCHAR:
0:         case java.sql.Types.LONGVARCHAR:
0:             return agent_.crossConverters_.getTimeFromString(getVARCHAR(column));
1:         default:
0:             throw new ColumnTypeConversionException(agent_.logWriter_);
1:         }
1:     }
1: 
0:     final java.sql.Timestamp getTimestamp(int column) throws SqlException {
1:         switch (jdbcTypes_[column - 1]) {
0:         case java.sql.Types.TIMESTAMP:
0:             return getTIMESTAMP(column);
0:         case java.sql.Types.DATE:
0:             return getTimestampFromDATE(column);
0:         case java.sql.Types.TIME:
0:             return getTimestampFromTIME(column);
0:         case java.sql.Types.CHAR:
0:             return agent_.crossConverters_.getTimestampFromString(getCHAR(column));
0:         case java.sql.Types.VARCHAR:
0:         case java.sql.Types.LONGVARCHAR:
0:             return agent_.crossConverters_.getTimestampFromString(getVARCHAR(column));
1:         default:
0:             throw new ColumnTypeConversionException(agent_.logWriter_);
1:         }
1:     }
1: 
1:     final String getString(int column) throws SqlException {
0:         String tempString = null;
1:         switch (jdbcTypes_[column - 1]) {
0:         case java.sql.Types.CHAR:
1:             return getCHAR(column);
0:         case java.sql.Types.VARCHAR:
0:         case java.sql.Types.LONGVARCHAR:
1:             return getVARCHAR(column);
1: 
0:         case java.sql.Types.SMALLINT:
0:             return String.valueOf(get_SMALLINT(column));
0:         case java.sql.Types.INTEGER:
0:             return String.valueOf(get_INTEGER(column));
0:         case java.sql.Types.BIGINT:
0:             return String.valueOf(get_BIGINT(column));
0:         case java.sql.Types.REAL:
0:             return String.valueOf(get_FLOAT(column));
0:         case java.sql.Types.DOUBLE:
0:             return String.valueOf(get_DOUBLE(column));
0:         case java.sql.Types.DECIMAL:
0:             // We could get better performance here if we didn't materialize the BigDecimal,
0:             // but converted directly from decimal bytes to a string.
0:             return String.valueOf(get_DECIMAL(column));
0:         case java.sql.Types.DATE:
0:             return getStringFromDATE(column);
0:         case java.sql.Types.TIME:
0:             return getStringFromTIME(column);
0:         case java.sql.Types.TIMESTAMP:
0:             return getStringFromTIMESTAMP(column);
0:         case Types.BINARY:
0:             tempString =
0:                     agent_.crossConverters_.getStringFromBytes(get_CHAR_FOR_BIT_DATA(column));
0:             return (maxFieldSize_ == 0) ? tempString :
0:                     tempString.substring(0, java.lang.Math.min(maxFieldSize_, tempString.length()));
0:         case java.sql.Types.VARBINARY:
0:         case java.sql.Types.LONGVARBINARY:
0:             tempString =
0:                     agent_.crossConverters_.getStringFromBytes(get_VARCHAR_FOR_BIT_DATA(column));
0:             return (maxFieldSize_ == 0) ? tempString :
0:                     tempString.substring(0, java.lang.Math.min(maxFieldSize_, tempString.length()));
0:         case java.sql.Types.BLOB:
0:             Blob b = (Blob) getBlobColumn_(column, agent_);
0:             return agent_.crossConverters_.getStringFromBytes(b.getBytes(1, (int) b.length()));
0:         case java.sql.Types.CLOB:
0:             Clob c = getClobColumn_(column, agent_);
0:             return c.getSubString(1, (int) c.length());
1:         default:
0:             throw new ColumnTypeConversionException(agent_.logWriter_);
1:         }
1:     }
1: 
1:     final byte[] getBytes(int column) throws SqlException {
1:         switch (jdbcTypes_[column - 1]) {
0:         case java.sql.Types.BINARY:
1:             return get_CHAR_FOR_BIT_DATA(column);
0:         case java.sql.Types.VARBINARY:
0:         case java.sql.Types.LONGVARBINARY:
1:             return get_VARCHAR_FOR_BIT_DATA(column);
0:         case java.sql.Types.BLOB:
0:             Blob b = (Blob) getBlobColumn_(column, agent_);
0:             return b.getBytes(1, (int) b.length());
1:         default:
0:             throw new ColumnTypeConversionException(agent_.logWriter_);
1:         }
1:     }
1: 
0:     public final java.io.InputStream getBinaryStream(int column) throws SqlException {
1:         switch (jdbcTypes_[column - 1]) {
0:         case java.sql.Types.BINARY:
0:             return new java.io.ByteArrayInputStream(get_CHAR_FOR_BIT_DATA(column));
0:         case java.sql.Types.VARBINARY:
0:         case java.sql.Types.LONGVARBINARY:
0:             return new java.io.ByteArrayInputStream(get_VARCHAR_FOR_BIT_DATA(column));
0:         case java.sql.Types.BLOB:
0:             Blob b = (Blob) getBlobColumn_(column, agent_);
0:             return b.getBinaryStream();
1:         default:
0:             throw new ColumnTypeConversionException(agent_.logWriter_);
1:         }
1:     }
1: 
0:     public final java.io.InputStream getAsciiStream(int column) throws SqlException {
1:         switch (jdbcTypes_[column - 1]) {
0:         case java.sql.Types.CLOB:
0:             Clob c = getClobColumn_(column, agent_);
0:             return c.getAsciiStream();
0:         case java.sql.Types.CHAR:
0:             try {
0:                 return new java.io.ByteArrayInputStream(getCHAR(column).getBytes("US-ASCII"));
0:             } catch (java.io.UnsupportedEncodingException e) {
0:                 throw new SqlException(agent_.logWriter_, e.getMessage());
1:             }
0:         case java.sql.Types.VARCHAR:
0:         case java.sql.Types.LONGVARCHAR:
0:             try {
0:                 return new java.io.ByteArrayInputStream(getVARCHAR(column).getBytes("US-ASCII"));
0:             } catch (java.io.UnsupportedEncodingException e) {
0:                 throw new SqlException(agent_.logWriter_, e.getMessage());
1:             }
0:         case java.sql.Types.BINARY:
0:             return new java.io.ByteArrayInputStream(get_CHAR_FOR_BIT_DATA(column));
0:         case java.sql.Types.VARBINARY:
0:         case java.sql.Types.LONGVARBINARY:
0:             return new java.io.ByteArrayInputStream(get_VARCHAR_FOR_BIT_DATA(column));
0:         case java.sql.Types.BLOB:
0:             Blob b = (Blob) getBlobColumn_(column, agent_);
0:             return b.getBinaryStream();
1:         default:
0:             throw new ColumnTypeConversionException(agent_.logWriter_);
1:         }
1:     }
1: 
0:     public final java.io.InputStream getUnicodeStream(int column) throws SqlException {
1:         switch (jdbcTypes_[column - 1]) {
0:         case java.sql.Types.CLOB:
0:             {
0:                 Clob c = getClobColumn_(column, agent_);
0:                 String s = c.getSubString(1L, (int) c.length());
0:                 try {
0:                     return new java.io.ByteArrayInputStream(s.getBytes("UTF-8"));
0:                 } catch (java.io.UnsupportedEncodingException e) {
0:                     throw new SqlException(agent_.logWriter_, e.getMessage());
1:                 }
1:             }
0:         case java.sql.Types.CHAR:
0:             {
0:                 try {
0:                     return new java.io.ByteArrayInputStream(getCHAR(column).getBytes("UTF-8"));
0:                 } catch (java.io.UnsupportedEncodingException e) {
0:                     throw new SqlException(agent_.logWriter_, e.getMessage());
1:                 }
1:             }
0:         case java.sql.Types.VARCHAR:
0:         case java.sql.Types.LONGVARCHAR:
0:             try {
0:                 return new java.io.ByteArrayInputStream(getVARCHAR(column).getBytes("UTF-8"));
0:             } catch (java.io.UnsupportedEncodingException e) {
0:                 throw new SqlException(agent_.logWriter_, e.getMessage());
1:             }
0:         case java.sql.Types.BINARY:
0:             return new java.io.ByteArrayInputStream(get_CHAR_FOR_BIT_DATA(column));
0:         case java.sql.Types.VARBINARY:
0:         case java.sql.Types.LONGVARBINARY:
0:             return new java.io.ByteArrayInputStream(get_VARCHAR_FOR_BIT_DATA(column));
0:         case java.sql.Types.BLOB:
0:             Blob b = (Blob) getBlobColumn_(column, agent_);
0:             return b.getBinaryStream();
1:         default:
0:             throw new ColumnTypeConversionException(agent_.logWriter_);
1:         }
1:     }
1: 
0:     public final java.io.Reader getCharacterStream(int column) throws SqlException {
1:         switch (jdbcTypes_[column - 1]) {
0:         case java.sql.Types.CLOB:
0:             Clob c = getClobColumn_(column, agent_);
0:             return c.getCharacterStream();
0:         case java.sql.Types.CHAR:
0:             return new java.io.StringReader(getCHAR(column));
0:         case java.sql.Types.VARCHAR:
0:         case java.sql.Types.LONGVARCHAR:
0:             return new java.io.StringReader(getVARCHAR(column));
0:         case java.sql.Types.BINARY:
0:             try {
0:                 return new java.io.InputStreamReader(new java.io.ByteArrayInputStream(get_CHAR_FOR_BIT_DATA(column)), "UTF-16BE");
0:             } catch (java.io.UnsupportedEncodingException e) {
0:                 throw new SqlException(agent_.logWriter_, "UnsupportedEncodingException: " + e.getMessage());
1:             }
0:         case java.sql.Types.VARBINARY:
0:         case java.sql.Types.LONGVARBINARY:
0:             try {
0:                 return new java.io.InputStreamReader(new java.io.ByteArrayInputStream(get_VARCHAR_FOR_BIT_DATA(column)), "UTF-16BE");
0:             } catch (java.io.UnsupportedEncodingException e) {
0:                 throw new SqlException(agent_.logWriter_, "UnsupportedEncodingException: " + e.getMessage());
1:             }
0:         case java.sql.Types.BLOB:
0:             try {
0:                 Blob b = (Blob) getBlobColumn_(column, agent_);
0:                 return new java.io.InputStreamReader(b.getBinaryStream(), "UTF-16BE");
0:             } catch (java.io.UnsupportedEncodingException e) {
0:                 throw new SqlException(agent_.logWriter_, "UnsupportedEncodingException: " + e.getMessage());
1:             }
1:         default:
0:             throw new ColumnTypeConversionException(agent_.logWriter_);
1:         }
1:     }
1: 
0:     public final java.sql.Blob getBlob(int column) throws SqlException {
1:         switch (jdbcTypes_[column - 1]) {
0:         case Types.BLOB:
0:             return getBlobColumn_(column, agent_);
1:         default:
0:             throw new ColumnTypeConversionException(agent_.logWriter_);
1:         }
1:     }
1: 
0:     public final java.sql.Clob getClob(int column) throws SqlException {
1:         switch (jdbcTypes_[column - 1]) {
0:         case Types.CLOB:
0:             return getClobColumn_(column, agent_);
1:         default:
0:             throw new ColumnTypeConversionException(agent_.logWriter_);
1:         }
1:     }
1: 
0:     public final java.sql.Array getArray(int column) throws SqlException {
0:         throw new SqlException(agent_.logWriter_, "not yet implemented");
1:     }
1: 
0:     public final java.sql.Ref getRef(int column) throws SqlException {
0:         throw new SqlException(agent_.logWriter_, "not yet implemented");
1:     }
1: 
0:     public final Object getObject(int column) throws SqlException {
1:         switch (jdbcTypes_[column - 1]) {
0:         case java.sql.Types.SMALLINT:
0:             return new Integer(get_SMALLINT(column)); // See Table 4 in JDBC 1 spec (pg. 932 in jdbc book)
0:         case java.sql.Types.INTEGER:
0:             return new Integer(get_INTEGER(column));
0:         case java.sql.Types.BIGINT:
0:             return new Long(get_BIGINT(column));
0:         case java.sql.Types.REAL:
0:             return new Float(get_FLOAT(column));
0:         case java.sql.Types.DOUBLE:
0:             return new Double(get_DOUBLE(column));
0:         case java.sql.Types.DECIMAL:
1:             return get_DECIMAL(column);
0:         case java.sql.Types.DATE:
0:             return getDATE(column);
0:         case java.sql.Types.TIME:
0:             return getTIME(column);
0:         case java.sql.Types.TIMESTAMP:
0:             return getTIMESTAMP(column);
0:         case java.sql.Types.CHAR:
1:             return getCHAR(column);
0:         case java.sql.Types.VARCHAR:
0:         case java.sql.Types.LONGVARCHAR:
1:             return getVARCHAR(column);
0:         case Types.BINARY:
1:             return get_CHAR_FOR_BIT_DATA(column);
0:         case java.sql.Types.VARBINARY:
0:         case java.sql.Types.LONGVARBINARY:
1:             return get_VARCHAR_FOR_BIT_DATA(column);
0:         case java.sql.Types.BLOB:
0:             return getBlobColumn_(column, agent_);
0:         case java.sql.Types.CLOB:
0:             return getClobColumn_(column, agent_);
1:         default:
0:             throw new ColumnTypeConversionException(agent_.logWriter_);
1:         }
1:     }
1: 
1:     public final void allocateCharBuffer() {
1:         // compute the maximum char length
1:         int maxCharLength = 0;
1:         for (int i = 0; i < columns_; i++) {
1:             switch (jdbcTypes_[i]) {
0:             case Types.CHAR:
0:             case Types.VARCHAR:
0:             case Types.LONGVARCHAR:
1:                 if (fdocaLength_[i] > maxCharLength) {
1:                     maxCharLength = fdocaLength_[i];
1:                 }
1:             }
1:         }
1: 
1:         // allocate char buffer to accomodate largest result column
1:         charBuffer_ = new char[maxCharLength];
1:     }
1: 
0:     private final String getStringWithoutConvert(int position, int actualLength) throws SqlException {
1:         int start = position;
1:         int end = position + actualLength;
1: 
1:         int charCount = 0;
1:         while (start < end) {
1:             charBuffer_[charCount++] = (char) (((dataBuffer_[start] & 0xff) << 8) | (dataBuffer_[start + 1] & 0xff));
1:             start += 2;
1:         }
1: 
1:         return new String(charBuffer_, 0, charCount);
1:     }
1: 
1:     public void nullDataForGC() {
1:         dataBuffer_ = null;
1:         dataBufferStream_ = null;
1:         columnDataPosition_ = null;
1:         columnDataComputedLength_ = null;
1:         columnDataPositionCache_ = null;
1:         columnDataLengthCache_ = null;
1:         columnDataIsNullCache_ = null;
1:         jdbcTypes_ = null;
1:         nullable_ = null;
0:         charsetName_ = null;
1:         this.ccsid_ = null;
1:         isUpdateDeleteHoleCache_ = null;
1:         isNull_ = null;
1:         fdocaLength_ = null;
1:         charBuffer_ = null;
1:     }
1: 
0:     private final int getColumnPrecision(int column) {
1:         return ((fdocaLength_[column] >> 8) & 0xff);
1:     }
1: 
0:     private final int getColumnScale(int column) {
1:         return (fdocaLength_[column] & 0xff);
1:     }
1: 
0:     // Only used by Sqlca.getMessage() when using a locale encoding
0:     // to convert errror message text instead of relying on server encoding as usual.
0:     final byte[] getBytesFromVARCHAR(int column) throws SqlException {
1:         byte[] bytes;
0:         bytes = new byte[columnDataComputedLength_[column - 1] - 2];
1:         System.arraycopy(dataBuffer_, columnDataPosition_[column - 1] + 2, bytes, 0, bytes.length);
1:         return bytes;
1:     }
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:33776ff
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derby.client.am.Cursor
1: 
0:    Copyright (c) 2001, 2005 The Apache Software Foundation or its licensors, where applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1: */
1: 
1: package org.apache.derby.client.am;
1: 
1: // When we calculate column offsets make sure we calculate the correct offsets for double byte charactr5er data
1: // length from server is number of chars, not bytes
1: // Direct byte-level converters are called directly by this class, cross converters are deferred to the CrossConverters class.
0: public abstract class Cursor
0: {
0:   protected Agent agent_;
1: 
0:   //-----------------------------varchar representations------------------------
1: 
0:   public final static int STRING = 0; 
0:   public final static int VARIABLE_STRING = 2;       // uses a 2-byte length indicator
0:   public final static int VARIABLE_SHORT_STRING = 1; // aka Pascal L; uses a 1-byte length indicator
0:   public final static int NULL_TERMINATED_STRING = 3;
1: 
0:   public final static int BYTES = 4; 
0:   public final static int VARIABLE_BYTES = 5;
0:   public final static int VARIABLE_SHORT_BYTES = 6;
0:   public final static int NULL_TERMINATED_BYTES = 7;
1: 
0:   public final static int SBCS_CLOB = 8;
0:   public final static int MBCS_CLOB = 9;
0:   public final static int DBCS_CLOB = 10;
0:   //-----------------------------internal state---------------------------------
1: 
0:   //-------------Structures for holding and scrolling the data -----------------
0:   public byte[] dataBuffer_;
0:   public java.io.ByteArrayOutputStream dataBufferStream_;
0:   public int position_; // This is the read head
0:   public int lastValidBytePosition_;
0:   public boolean hasLobs_; // is there at least one LOB column?
1: 
0:   // Current row positioning
0:   protected int currentRowPosition_;
0:   private int nextRowPosition_;
0:   // Let's new up a 2-dimensional array based on fetch-size and reuse so that
0:   protected int[] columnDataPosition_; 
1: 
0:   // This is the actual, computed lengths of varchar fields, not the max length from query descriptor or DA
0:   protected int[] columnDataComputedLength_;
0:   // populate this for
1: 
0:   // All the data is in the buffers, but user may not have necessarily stepped to the last row yet.
0:   // This flag indicates that the server has returned all the rows, and is positioned
0:   // after last, for both scrollable and forward-only cursors.
0:   // For singleton cursors, this memeber will be set to true as soon as next is called.
0:   public boolean allRowsReceivedFromServer_;
1: 
0:   // Total number of rows read so far.
0:   // This should never exceed this.statement.maxRows
0:   int rowsRead_;
1: 
0:   // Maximum column size limit in bytes.
0:   int maxFieldSize_ = 0;
1: 
0:   // Row positioning for all cached rows
0:   // For scrollable result sets, these lists hold the offsets into the cached rowset buffer for each row of data.
0:   protected java.util.ArrayList columnDataPositionCache_ = new java.util.ArrayList();
0:   protected java.util.ArrayList columnDataLengthCache_ = new java.util.ArrayList();
0:   protected java.util.ArrayList columnDataIsNullCache_ = new java.util.ArrayList();
0:   public java.util.ArrayList isUpdateDeleteHoleCache_ = new java.util.ArrayList();
0:   public boolean isUpdateDeleteHole_;
0:   final static public java.lang.Boolean ROW_IS_NULL = new Boolean (true);
0:   final static public java.lang.Boolean ROW_IS_NOT_NULL = new Boolean (false);
1: 
0:   java.sql.Date recyclableDate_ = null;
0:   java.sql.Time recyclableTime_ = null;
0:   java.sql.Timestamp recyclableTimestamp_ = null;
1: 
0:   // For the net, this data comes from the query descriptor.
1: 
0:   public int[] jdbcTypes_;
0:   public int columns_;
0:   public boolean[] nullable_;
0:   public String[] charsetName_;
0:   public boolean[] isNull_;
0:   public int[] fdocaLength_; // this is the max length for
1: 
0:   //----------------------------------------------------------------------------
1: 
0:   public int [] ccsid_;
0:   char[] charBuffer_;
1: 
0:   //---------------------constructors/finalizer---------------------------------
1: 
0:   public Cursor (Agent agent)
0:   {
0:     agent_ = agent;
0:     dataBufferStream_ = new java.io.ByteArrayOutputStream ();
0:   }
1: 
0:   public Cursor (Agent agent, byte[] dataBuffer)
0:   {
0:     this (agent);
0:     dataBuffer_ = dataBuffer;
0:     allRowsReceivedFromServer_ = false;
0:   }
1: 
0:   public void setNumberOfColumns (int numberOfColumns)
0:   {
0:     columnDataPosition_ = new int[numberOfColumns];
0:     columnDataComputedLength_ = new int[numberOfColumns];
1: 
0:     columns_ = numberOfColumns;
0:     nullable_ = new boolean[numberOfColumns];
0:     charsetName_ = new String[numberOfColumns];
1: 
0:     ccsid_ = new int [numberOfColumns];
1: 
0:     isNull_ = new boolean[numberOfColumns];
0:     jdbcTypes_ = new int[numberOfColumns];
0:   }
1: 
0:   // Makes the next row the current row.
0:   // Returns true if the current row position is a valid row position.
0:   public boolean next () throws SqlException
0:   {
0:     // local variable usd to hold the returned value from calculateColumnOffsetsForRow()
0:     boolean rowPositionIsValid = true;
1: 
0:     // reset lob data
0:     // clears out Cursor.lobs_ calculated for the current row when cursor is moved.
0:     clearLobData_ ();
1: 
0:     // mark the start of a new row.
0:     makeNextRowPositionCurrent ();
1: 
0:     // Drive the CNTQRY outside of calculateColumnOffsetsForRow() if the dataBuffer_
0:     // contains no data since it has no abilities to handle replies other than
0:     // the QRYDTA, i.e. ENDQRYRM when the result set contains no more rows.
0:     while (!dataBufferHasUnprocessedData()) {
0:       if (allRowsReceivedFromServer_)
0:         return false;
0:       getMoreData_();
0:     }
1: 
0:     // The parameter passed in here is used as an index into the cached rowset for
0:     // scrollable cursors, for the arrays to be reused.  It is not used for forward-only
0:     // cursors, so just pass in 0.
0:     rowPositionIsValid = calculateColumnOffsetsForRow_(0);  // readFetchedRows()
0:     markNextRowPosition ();
0:     return rowPositionIsValid;
0:   }
1: 
0:   //--------------------------reseting cursor state-----------------------------
1: 
0:   public final void setAllRowsReceivedFromServer (boolean b)
0:   {
0:     allRowsReceivedFromServer_ = b;
0:   }
1: 
0:   public final boolean currentRowPositionIsEqualToNextRowPosition ()
0:   {
0:     return (currentRowPosition_ == nextRowPosition_);
0:   }
1: 
0:   // reset the beginning and ending position in the data buffer to 0
0:   // reset the currentRowPosition and nextRowPosition to 0
0:   // reset lastRowReached and sqlcode100Received to false
0:   // clear the column data offsets cache
0:   public final void resetDataBuffer ()
0:   {
0:     position_ = 0;
0:     lastValidBytePosition_ = 0;
0:     currentRowPosition_ = 0;
0:     nextRowPosition_ = 0;
0:     allRowsReceivedFromServer_ = false;
0:     dataBufferStream_.reset();
0:   }
1: 
0:   public final boolean dataBufferHasUnprocessedData ()
0:   {
0:     return (lastValidBytePosition_ - position_) > 0;
0:   }
1: 
0:   protected abstract boolean calculateColumnOffsetsForRow_ (int row) throws SqlException, DisconnectException;
0:   protected abstract void clearLobData_();
0:   protected abstract void getMoreData_() throws SqlException;
1: 
0:   // Associate a new underlying COM or SQLDA output data buffer for this converter.
0:   public final void setBuffer (byte[] dataBuffer)
0:   {
0:     dataBuffer_ = dataBuffer;
0:   }
1: 
0:   public final void setIsUpdataDeleteHole (int row, boolean isRowNull)
0:   {
0:     isUpdateDeleteHole_ = isRowNull;
0:     Boolean nullIndicator = (isUpdateDeleteHole_ == true) ? ROW_IS_NULL : ROW_IS_NOT_NULL;
0:     if (isUpdateDeleteHoleCache_.size() == row)
0:       isUpdateDeleteHoleCache_.add (nullIndicator);
0:     else
0:       isUpdateDeleteHoleCache_.set (row, nullIndicator);
0:   }
0:   //---------------------------cursor positioning-------------------------------
1: 
0:   final int getPosition ()
0:   {
0:     return position_;
0:   }
1: 
0:   final void setPosition (int newPosition)
0:   {
0:     position_ = newPosition;
0:   }
1: 
0:   public final void markCurrentRowPosition ()
0:   {
0:     currentRowPosition_ = position_;
0:   }
1: 
0:   public final void markNextRowPosition ()
0:   {
0:     nextRowPosition_ = position_;
0:   }
1: 
0:   public final void makeNextRowPositionCurrent ()
0:   {
0:     currentRowPosition_ = nextRowPosition_;
0:   }
1: 
0:   final void repositionCursorToCurrentRow ()
0:   {
0:     position_ = currentRowPosition_;
0:   }
1: 
0:   final void repositionCursorToNextRow ()
0:   {
0:     position_ = nextRowPosition_;
0:   }
1: 
0:   public final byte[] getDataBuffer ()
0:   {
0:     return dataBuffer_;
0:   }
1: 
0:   public final int getDataBufferLength()
0:   {
0:     return dataBuffer_.length;
0:   }
1: 
0:   public final int getLastValidBytePosition ()
0:   {
0:     return lastValidBytePosition_;
0:   }
1: 
0:   // This tracks the total number of rows read into the client side buffer for
0:   // this result set, irregardless of scrolling.
0:   // Per jdbc semantics, this should never exceed statement.maxRows.
0:   // This event should be generated in the materialized cursor's implementation
0:   // of calculateColumnOffsetsForRow().
0:   public final void incrementRowsReadEvent()
0:   {
0:     rowsRead_++;
0:   }
1: 
0:   //------- the following getters are called on known column types -------------
0:   // Direct conversions only, cross conversions are handled by another set of getters.
1: 
0:   // Build a Java short from a 2-byte signed binary representation.
0:   private final short get_SMALLINT (int column)
0:   {
0:     return org.apache.derby.client.am.SignedBinary.getShort (dataBuffer_,
0:                                                              columnDataPosition_[column-1]);
0:   }
1: 
0:   // Build a Java int from a 4-byte signed binary representation.
0:   private final int get_INTEGER (int column)
0:   {
0:     return org.apache.derby.client.am.SignedBinary.getInt (dataBuffer_,
0:                                                            columnDataPosition_[column-1]);
0:   }
1: 
0:   // Build a Java long from an 8-byte signed binary representation.
0:   private final long get_BIGINT (int column)
0:   {
0:     return org.apache.derby.client.am.SignedBinary.getLong (dataBuffer_,
0:                                                             columnDataPosition_[column-1]);
0:   }
1: 
0:   // Build a Java float from a 4-byte floating point representation.
0:   private final float get_FLOAT (int column)
0:   {
0:     return org.apache.derby.client.am.FloatingPoint.getFloat (dataBuffer_,
0:                                                       columnDataPosition_[column-1]);
0:   }
1: 
0:   // Build a Java double from an 8-byte floating point representation.
0:   private final double get_DOUBLE (int column)
0:   {
0:     return org.apache.derby.client.am.FloatingPoint.getDouble (dataBuffer_,
0:                                                        columnDataPosition_[column-1]);
0:   }
1: 
0:   // Build a java.math.BigDecimal from a fixed point decimal byte representation.
0:   private final java.math.BigDecimal get_DECIMAL (int column) throws SqlException
0:   {
0:     try {
0:       return org.apache.derby.client.am.Decimal.getBigDecimal (dataBuffer_,
0:                                                        columnDataPosition_[column-1],
0:                                                        getColumnPrecision (column-1),
0:                                                        getColumnScale (column-1));
0:     }
0:     catch (java.io.UnsupportedEncodingException e) {
0:       throw new SqlException (agent_.logWriter_, e, "Encoding is unsupported for conversion to BigDecimal");
0:     }
0:   }
1: 
1: 
0:   // Build a Java double from a fixed point decimal byte representation.
0:   private final double getDoubleFromDECIMAL (int column) throws SqlException
0:   {
0:     try {
0:       return org.apache.derby.client.am.Decimal.getDouble (dataBuffer_,
0:                                                    columnDataPosition_[column-1],
0:                                                    getColumnPrecision (column-1),
0:                                                    getColumnScale (column-1));
0:     }
0:     catch (java.lang.IllegalArgumentException e) {
0:       throw new SqlException (agent_.logWriter_, e, "Decimal value is out of range for conversion to double");
0:     }
0:     catch (java.io.UnsupportedEncodingException e) {
0:       throw new SqlException (agent_.logWriter_, e, "Encoding is unsupported for conversion to BigDecimal");
0:     }
0:   }
1: 
0:   // Build a Java long from a fixed point decimal byte representation.
0:   private final long getLongFromDECIMAL (int column) throws SqlException
0:   {
0:     try {
0:       return org.apache.derby.client.am.Decimal.getLong (dataBuffer_,
0:                                                  columnDataPosition_[column-1],
0:                                                  getColumnPrecision (column-1),
0:                                                  getColumnScale (column-1));
0:     }
0:     catch (java.lang.IllegalArgumentException e) {
0:       throw new SqlException (agent_.logWriter_, e, "Decimal value is out of range for conversion to long");
0:     }
0:     catch (java.io.UnsupportedEncodingException e) {
0:       throw new SqlException (agent_.logWriter_, e, "Encoding is unsupported for conversion to BigDecimal");
0:     }
0:   }
1: 
0:   // Build a Java String from a database VARCHAR or LONGVARCHAR field.
0:   //
0:   // Depending on the ccsid, length is the number of chars or number of bytes.
0:   // For 2-byte character ccsids, length is the number of characters,
0:   // for all other cases length is the number of bytes.
0:   // The length does not include the null terminator.
0:   private final String getVARCHAR (int column) throws SqlException
0:   {
0:     String tempString = null;
0:     try {
0:       if(ccsid_[column-1] == 1200)
0:         return getStringWithoutConvert (columnDataPosition_[column-1] + 2, columnDataComputedLength_[column-1] - 2 );
1: 
0:       // check for null encoding is needed because the net layer
0:       // will no longer throw an exception if the server didn't specify
0:       // a mixed or double byte ccsid (ccsid = 0).  this check for null in the
0:       // cursor is only required for types which can have mixed or double
0:       // byte ccsids.
0:       if (charsetName_[column-1] == null)
0:         throw new SqlException (agent_.logWriter_,
0:           "Required character converter not available for data type.");
1: 
0:       tempString = new String (dataBuffer_,
0: 			           columnDataPosition_[column-1] + 2,
0: 			           columnDataComputedLength_[column-1] - 2,
0: 			           charsetName_[column-1]);
0:       return (maxFieldSize_ == 0) ? tempString :
0:         tempString.substring(0, java.lang.Math.min (maxFieldSize_, tempString.length()));
0:     }
0:     catch (java.io.UnsupportedEncodingException e) {
0:       throw new SqlException (agent_.logWriter_, e, "unsupported encoding for result set column " + column);
0:     }
0:   }
1: 
0:   // Build a Java String from a database CHAR field.
0:   private final String getCHAR (int column) throws SqlException
0:   {
0:     String tempString = null;
0:     if (ccsid_[column - 1] == 1200)
0:       return getStringWithoutConvert(columnDataPosition_[column - 1], columnDataComputedLength_[column - 1]);
1: 
0:     try {
0:       // check for null encoding is needed because the net layer
0:       // will no longer throw an exception if the server didn't specify
0:       // a mixed or double byte ccsid (ccsid = 0).  this check for null in the
0:       // cursor is only required for types which can have mixed or double
0:       // byte ccsids.
0:       if (charsetName_[column-1] == null)
0:         throw new SqlException (agent_.logWriter_,
0:           "Required character converter not available for data type.");
1: 
0:       tempString = new String (dataBuffer_,
0:                                columnDataPosition_[column-1],
0:  		         columnDataComputedLength_[column-1],
0: 	         charsetName_[column-1]);
0:       return (maxFieldSize_ == 0) ? tempString :
0:         tempString.substring(0, java.lang.Math.min (maxFieldSize_, tempString.length()));
0:     }
0:     catch (java.io.UnsupportedEncodingException e) {
0:       throw new SqlException (agent_.logWriter_, e, "unsupported encoding for result set column " + column);
0:     }
0:   }
1: 
0:   // Build a JDBC Date object from the DERBY ISO DATE field.
0:   private final java.sql.Date getDATE (int column) throws SqlException
0:   {
0:     return org.apache.derby.client.am.DateTime.dateBytesToDate (dataBuffer_,
0:                                                                   columnDataPosition_[column-1],
0:                                                                   recyclableDate_);
0:   }
1: 
0:   // Build a JDBC Time object from the DERBY ISO TIME field.
0:   private final java.sql.Time getTIME (int column) throws SqlException
0:   {
0:     return org.apache.derby.client.am.DateTime.timeBytesToTime (dataBuffer_,
0:                                                                   columnDataPosition_[column-1],
0:                                                                    recyclableTime_);
0:   }
1: 
0:   // Build a JDBC Timestamp object from the DERBY ISO TIMESTAMP field.
0:   private final java.sql.Timestamp getTIMESTAMP (int column) throws SqlException
0:   {
0:     return org.apache.derby.client.am.DateTime.timestampBytesToTimestamp (dataBuffer_,
0:                                                                             columnDataPosition_[column-1],
0:                                                                             recyclableTimestamp_);
0:   }
1: 
0:   // Build a JDBC Timestamp object from the DERBY ISO DATE field.
0:   private final java.sql.Timestamp getTimestampFromDATE (int column) throws SqlException
0:   {
0:     return org.apache.derby.client.am.DateTime.dateBytesToTimestamp (dataBuffer_,
0:                                                                        columnDataPosition_[column-1],
0:                                                                        recyclableTimestamp_);
0:   }
1: 
0:   // Build a JDBC Timestamp object from the DERBY ISO TIME field.
0:   private final java.sql.Timestamp getTimestampFromTIME (int column) throws SqlException
0:   {
0:     return org.apache.derby.client.am.DateTime.timeBytesToTimestamp (dataBuffer_,
0:                                                                        columnDataPosition_[column-1],
0:                                                                        recyclableTimestamp_);
0:   }
1: 
0:   // Build a JDBC Date object from the DERBY ISO TIMESTAMP field.
0:   private final java.sql.Date getDateFromTIMESTAMP (int column) throws SqlException
0:   {
0:     return org.apache.derby.client.am.DateTime.timestampBytesToDate (dataBuffer_,
0:                                                                        columnDataPosition_[column-1],
0:                                                                        recyclableDate_);
0:   }
1: 
0:   // Build a JDBC Time object from the DERBY ISO TIMESTAMP field.
0:   private final java.sql.Time getTimeFromTIMESTAMP (int column) throws SqlException
0:   {
0:     return org.apache.derby.client.am.DateTime.timestampBytesToTime (dataBuffer_,
0:                                                                        columnDataPosition_[column-1],
0:                                                                        recyclableTime_);
0:   }
1: 
0:  private final String getStringFromDATE (int column) throws SqlException
0:   {
0:     return org.apache.derby.client.am.DateTime.dateBytesToDate (
0:                dataBuffer_,
0:                columnDataPosition_[column-1],
0:                recyclableDate_).toString();
0:   }
1: 
0:   // Build a string object from the DERBY byte TIME representation.
0:   private final String getStringFromTIME (int column) throws SqlException
0:   {
0:     return org.apache.derby.client.am.DateTime.timeBytesToTime (
0:                dataBuffer_,
0:                columnDataPosition_[column-1],
0:                recyclableTime_).toString();
0:   }
1: 
0:   // Build a string object from the DERBY byte TIMESTAMP representation.
0:   private final String getStringFromTIMESTAMP (int column) throws SqlException
0:   {
0:     return org.apache.derby.client.am.DateTime.timestampBytesToTimestamp (
0:                dataBuffer_,
0:                columnDataPosition_[column-1],
0:                recyclableTimestamp_).toString();
0:   }
1: 
0:   // Extract bytes from a database java.sql.Types.BINARY field.
0:   // This is the DERBY type CHAR(n) FOR BIT DATA.
0:   private final byte[] get_CHAR_FOR_BIT_DATA (int column) throws SqlException
0:   {
0:     // There is no limit to the size of a column if maxFieldSize is zero.
0:     // Otherwise, use the smaller of maxFieldSize and the actual column length.
0:     int columnLength = (maxFieldSize_ == 0) ? columnDataComputedLength_[column-1] :
0:       java.lang.Math.min (maxFieldSize_, columnDataComputedLength_[column-1]);
1: 
0:     byte[] bytes = new byte[columnLength];
0:     System.arraycopy (dataBuffer_, columnDataPosition_[column-1], bytes, 0, columnLength);
0:     return bytes;
0:   }
1: 
0:   // Extract bytes from a database java.sql.Types.VARBINARY or LONGVARBINARY field.
0:   // This includes the DERBY types:
0:   //   VARCHAR(n) FOR BIT DATA
0:   //   LONG VARCHAR(n) FOR BIT DATA
0:   private final byte[] get_VARCHAR_FOR_BIT_DATA (int column) throws SqlException
0:   {
0:     byte[] bytes;
0:     int columnLength = 0;
0:     columnLength = (maxFieldSize_ == 0) ? columnDataComputedLength_[column-1]-2 :
0:       java.lang.Math.min (maxFieldSize_, columnDataComputedLength_[column-1]-2);
0:     bytes = new byte[columnLength];
0:     System.arraycopy (dataBuffer_, columnDataPosition_[column-1] + 2, bytes, 0, bytes.length);
0:     return bytes;
0:   }
1: 
0:   abstract public Blob getBlobColumn_ (int column, Agent agent) throws SqlException;
0:   abstract public Clob getClobColumn_ (int column, Agent agent) throws SqlException;
1: 
0:   // get the raw clob bytes, without translation.  dataOffset must be int[1]
0:   abstract public byte[] getClobBytes_ (int column, int[] dataOffset /*output*/) throws SqlException;
1: 
0:   //------- the following getters perform any necessary cross-conversion _------
1: 
0:   final boolean getBoolean (int column) throws SqlException
0:   {
0:     switch (jdbcTypes_[column-1]) {
0:     case java.sql.Types.SMALLINT:
0:       return agent_.crossConverters_.getBooleanFromShort (get_SMALLINT (column));
0:     case java.sql.Types.INTEGER:
0:       return agent_.crossConverters_.getBooleanFromInt (get_INTEGER (column));
0:     case java.sql.Types.BIGINT:
0:       return agent_.crossConverters_.getBooleanFromLong (get_BIGINT (column));
0:     case java.sql.Types.REAL:
0:       return agent_.crossConverters_.getBooleanFromFloat (get_FLOAT (column));
0:     case java.sql.Types.DOUBLE:
0:       return agent_.crossConverters_.getBooleanFromDouble (get_DOUBLE (column));
0:     case java.sql.Types.DECIMAL:
0:       // For performance we don't materialize the BigDecimal, but convert directly from decimal bytes to a long.
0:       return agent_.crossConverters_.getBooleanFromLong (getLongFromDECIMAL (column));
0:     case java.sql.Types.CHAR:
0:       return agent_.crossConverters_.getBooleanFromString (getCHAR (column));
0:     case java.sql.Types.VARCHAR:
0:     case java.sql.Types.LONGVARCHAR:
0:       return agent_.crossConverters_.getBooleanFromString (getVARCHAR (column));
0:     default:
0:       throw new ColumnTypeConversionException (agent_.logWriter_);
0:     }
0:   }
1: 
0:   final byte getByte (int column) throws SqlException
0:   {
0:     // This needs to be changed to use jdbcTypes[] 
0:     switch (jdbcTypes_[column-1]) {
0:     case java.sql.Types.SMALLINT:
0:       return agent_.crossConverters_.getByteFromShort (get_SMALLINT (column));
0:     case java.sql.Types.INTEGER:
0:       return agent_.crossConverters_.getByteFromInt (get_INTEGER (column));
0:     case java.sql.Types.BIGINT:
0:       return agent_.crossConverters_.getByteFromLong (get_BIGINT (column));
0:     case java.sql.Types.REAL:
0:       return agent_.crossConverters_.getByteFromFloat (get_FLOAT (column));
0:     case java.sql.Types.DOUBLE:
0:       return agent_.crossConverters_.getByteFromDouble (get_DOUBLE (column));
0:     case java.sql.Types.DECIMAL:
0:       // For performance we don't materialize the BigDecimal, but convert directly from decimal bytes to a long.
0:       return agent_.crossConverters_.getByteFromLong (getLongFromDECIMAL (column));
0:     case java.sql.Types.CHAR:
0:       return agent_.crossConverters_.getByteFromString (getCHAR (column));
0:     case java.sql.Types.VARCHAR:
0:     case java.sql.Types.LONGVARCHAR:
0:       return agent_.crossConverters_.getByteFromString (getVARCHAR (column));
0:     default:
0:       throw new ColumnTypeConversionException (agent_.logWriter_);
0:     }
0:   }
1: 
0:   final short getShort (int column) throws SqlException
0:   {
0:     switch (jdbcTypes_[column-1]) {
0:     case java.sql.Types.SMALLINT:
0:       return get_SMALLINT (column);
0:     case java.sql.Types.INTEGER:
0:       return agent_.crossConverters_.getShortFromInt (get_INTEGER (column));
0:     case java.sql.Types.BIGINT:
0:       return agent_.crossConverters_.getShortFromLong (get_BIGINT (column));
0:     case java.sql.Types.REAL:
0:       return agent_.crossConverters_.getShortFromFloat (get_FLOAT (column));
0:     case java.sql.Types.DOUBLE:
0:       return agent_.crossConverters_.getShortFromDouble (get_DOUBLE (column));
0:     case java.sql.Types.DECIMAL:
0:       // For performance we don't materialize the BigDecimal, but convert directly from decimal bytes to a long.
0:       return agent_.crossConverters_.getShortFromLong (getLongFromDECIMAL (column));
0:     case java.sql.Types.CHAR:
0:       return agent_.crossConverters_.getShortFromString (getCHAR (column));
0:     case java.sql.Types.VARCHAR:
0:     case java.sql.Types.LONGVARCHAR:
0:       return agent_.crossConverters_.getShortFromString (getVARCHAR (column));
0:     default:
0:       throw new ColumnTypeConversionException (agent_.logWriter_);
0:     }
0:   }
1: 
0:   final int getInt (int column) throws SqlException
0:   {
0:     switch (jdbcTypes_[column-1]) {
0:     case java.sql.Types.SMALLINT:
0:       return (int) get_SMALLINT (column);
0:     case java.sql.Types.INTEGER:
0:       return get_INTEGER (column);
0:     case java.sql.Types.BIGINT:
0:       return agent_.crossConverters_.getIntFromLong (get_BIGINT (column));
0:     case java.sql.Types.REAL:
0:       return agent_.crossConverters_.getIntFromFloat (get_FLOAT (column));
0:     case java.sql.Types.DOUBLE:
0:       return agent_.crossConverters_.getIntFromDouble (get_DOUBLE (column));
0:     case java.sql.Types.DECIMAL:
0:       // For performance we don't materialize the BigDecimal, but convert directly from decimal bytes to a long.
0:       return agent_.crossConverters_.getIntFromLong (getLongFromDECIMAL (column));
0:     case java.sql.Types.CHAR:
0:       return agent_.crossConverters_.getIntFromString (getCHAR (column));
0:     case java.sql.Types.VARCHAR:
0:     case java.sql.Types.LONGVARCHAR:
0:       return agent_.crossConverters_.getIntFromString (getVARCHAR (column));
0:     default:
0:       throw new ColumnTypeConversionException (agent_.logWriter_);
0:     }
0:   }
1: 
0:   final long getLong (int column) throws SqlException
0:   {
0:     switch (jdbcTypes_[column-1]) {
0:     case java.sql.Types.SMALLINT:
0:       return (long) get_SMALLINT (column);
0:     case java.sql.Types.INTEGER:
0:       return (long) get_INTEGER (column);
0:     case java.sql.Types.BIGINT:
0:       return get_BIGINT (column);
0:     case java.sql.Types.REAL:
0:       return agent_.crossConverters_.getLongFromFloat (get_FLOAT (column));
0:     case java.sql.Types.DOUBLE:
0:       return agent_.crossConverters_.getLongFromDouble (get_DOUBLE (column));
0:     case java.sql.Types.DECIMAL:
0:       // For performance we don't materialize the BigDecimal, but convert directly from decimal bytes to a long.
0:       return getLongFromDECIMAL (column);
0:     case java.sql.Types.CHAR:
0:       return agent_.crossConverters_.getLongFromString (getCHAR (column));
0:     case java.sql.Types.VARCHAR:
0:     case java.sql.Types.LONGVARCHAR:
0:       return agent_.crossConverters_.getLongFromString (getVARCHAR (column));
0:     default:
0:       throw new ColumnTypeConversionException (agent_.logWriter_);
0:     }
0:   }
1: 
0:   final float getFloat (int column) throws SqlException
0:   {
0:     switch (jdbcTypes_[column-1]) {
0:     case java.sql.Types.REAL:
0:       return get_FLOAT (column);
0:     case java.sql.Types.DOUBLE:
0:       return agent_.crossConverters_.getFloatFromDouble (get_DOUBLE (column));
0:     case java.sql.Types.DECIMAL:
0:       // For performance we don't materialize the BigDecimal, but convert directly from decimal bytes to a long.
0:       return agent_.crossConverters_.getFloatFromDouble (getDoubleFromDECIMAL (column));
0:     case java.sql.Types.SMALLINT:
0:       return (float) get_SMALLINT (column);
0:     case java.sql.Types.INTEGER:
0:       return (float) get_INTEGER (column);
0:     case java.sql.Types.BIGINT:
0:       return (float) get_BIGINT (column);
0:     case java.sql.Types.CHAR:
0:       return agent_.crossConverters_.getFloatFromString (getCHAR (column));
0:     case java.sql.Types.VARCHAR:
0:     case java.sql.Types.LONGVARCHAR:
0:       return agent_.crossConverters_.getFloatFromString (getVARCHAR (column));
0:     default:
0:       throw new ColumnTypeConversionException (agent_.logWriter_);
0:     }
0:   }
1: 
0:   final double getDouble (int column) throws SqlException
0:   {
0:     switch (jdbcTypes_[column-1]) {
0:     case java.sql.Types.REAL:
0:       double d = (double) get_FLOAT (column);
0:       return d;
0:       //return (double) get_FLOAT (column);
0:     case java.sql.Types.DOUBLE:
0:       return get_DOUBLE (column);
0:     case java.sql.Types.DECIMAL:
0:       // For performance we don't materialize the BigDecimal, but convert directly from decimal bytes to a long.
0:       return getDoubleFromDECIMAL (column);
0:     case java.sql.Types.SMALLINT:
0:       return (double) get_SMALLINT (column);
0:     case java.sql.Types.INTEGER:
0:       return (double) get_INTEGER (column);
0:     case java.sql.Types.BIGINT:
0:       return (double) get_BIGINT (column);
0:     case java.sql.Types.CHAR:
0:       return agent_.crossConverters_.getDoubleFromString (getCHAR (column));
0:     case java.sql.Types.VARCHAR:
0:     case java.sql.Types.LONGVARCHAR:
0:       return agent_.crossConverters_.getDoubleFromString (getVARCHAR (column));
0:     default:
0:       throw new ColumnTypeConversionException (agent_.logWriter_);
0:     }
0:   }
1: 
0:   final java.math.BigDecimal getBigDecimal (int column) throws SqlException
0:   {
0:     switch (jdbcTypes_[column-1]) {
0:     case java.sql.Types.DECIMAL:
0:       return get_DECIMAL (column);
0:     case java.sql.Types.REAL:
0:       // Can't use the following commented out line because it changes precision of the result.
0:       //return new java.math.BigDecimal (get_FLOAT (column));
0:       float f = get_FLOAT (column);
0:       return new java.math.BigDecimal (String.valueOf(f));
0:     case java.sql.Types.DOUBLE:
0:       // Can't use the following commented out line because it changes precision of the result.
0:       return new java.math.BigDecimal (String.valueOf (get_DOUBLE (column)));
0:     case java.sql.Types.SMALLINT:
0:       return java.math.BigDecimal.valueOf (get_SMALLINT (column));
0:     case java.sql.Types.INTEGER:
0:       return java.math.BigDecimal.valueOf (get_INTEGER (column));
0:     case java.sql.Types.BIGINT:
0:       return java.math.BigDecimal.valueOf (get_BIGINT (column));
0:     case java.sql.Types.CHAR:
0:       return agent_.crossConverters_.getBigDecimalFromString (getCHAR (column));
0:     case java.sql.Types.VARCHAR:
0:     case java.sql.Types.LONGVARCHAR:
0:       return agent_.crossConverters_.getBigDecimalFromString (getVARCHAR (column));
0:     default:
0:       throw new ColumnTypeConversionException (agent_.logWriter_);
0:     }
0:   }
1: 
0:   final java.sql.Date getDate (int column) throws SqlException
0:   {
0:     switch (jdbcTypes_[column-1]) {
0:     case java.sql.Types.DATE:
0:       return getDATE (column);
0:     case java.sql.Types.TIMESTAMP:
0:       return getDateFromTIMESTAMP (column);
0:     case java.sql.Types.CHAR:
0:       return agent_.crossConverters_.getDateFromString (getCHAR (column));
0:     case java.sql.Types.VARCHAR:
0:     case java.sql.Types.LONGVARCHAR:
0:       return agent_.crossConverters_.getDateFromString (getVARCHAR (column));
0:     default:
0:       throw new ColumnTypeConversionException (agent_.logWriter_);
0:     }
0:   }
1: 
0:   final java.sql.Time getTime (int column) throws SqlException
0:   {
0:     switch (jdbcTypes_[column-1]) {
0:     case java.sql.Types.TIME:
0:       return getTIME (column);
0:     case java.sql.Types.TIMESTAMP:
0:       return getTimeFromTIMESTAMP (column);
0:     case java.sql.Types.CHAR:
0:       return agent_.crossConverters_.getTimeFromString (getCHAR (column));
0:     case java.sql.Types.VARCHAR:
0:     case java.sql.Types.LONGVARCHAR:
0:       return agent_.crossConverters_.getTimeFromString (getVARCHAR (column));
0:     default:
0:       throw new ColumnTypeConversionException (agent_.logWriter_);
0:     }
0:   }
1: 
0:   final java.sql.Timestamp getTimestamp (int column) throws SqlException
0:   {
0:     switch (jdbcTypes_[column-1]) {
0:     case java.sql.Types.TIMESTAMP:
0:       return getTIMESTAMP (column);
0:     case java.sql.Types.DATE:
0:       return getTimestampFromDATE (column);
0:     case java.sql.Types.TIME:
0:       return getTimestampFromTIME (column);
0:     case java.sql.Types.CHAR:
0:       return agent_.crossConverters_.getTimestampFromString (getCHAR (column));
0:     case java.sql.Types.VARCHAR:
0:     case java.sql.Types.LONGVARCHAR:
0:       return agent_.crossConverters_.getTimestampFromString (getVARCHAR (column));
0:     default:
0:       throw new ColumnTypeConversionException (agent_.logWriter_);
0:     }
0:   }
1: 
0:   final String getString (int column) throws SqlException
0:   {
0:     String tempString = null;
0:     switch (jdbcTypes_[column-1]) {
0:     case java.sql.Types.CHAR:
0:       return getCHAR (column);
0:     case java.sql.Types.VARCHAR:
0:     case java.sql.Types.LONGVARCHAR:
0:       return getVARCHAR (column);
1: 
0:     case java.sql.Types.SMALLINT:
0:       return String.valueOf (get_SMALLINT (column));
0:     case java.sql.Types.INTEGER:
0:       return String.valueOf (get_INTEGER (column));
0:     case java.sql.Types.BIGINT:
0:       return String.valueOf (get_BIGINT (column));
0:     case java.sql.Types.REAL:
0:       return String.valueOf (get_FLOAT (column));
0:     case java.sql.Types.DOUBLE:
0:       return String.valueOf (get_DOUBLE (column));
0:     case java.sql.Types.DECIMAL:
0:       // We could get better performance here if we didn't materialize the BigDecimal,
0:       // but converted directly from decimal bytes to a string.
0:       return String.valueOf (get_DECIMAL (column));
0:     case java.sql.Types.DATE:
0:       return getStringFromDATE (column);
0:     case java.sql.Types.TIME:
0:       return getStringFromTIME (column);
0:     case java.sql.Types.TIMESTAMP:
0:       return getStringFromTIMESTAMP (column);
0:     case Types.BINARY:
0:       tempString =
0:         agent_.crossConverters_.getStringFromBytes (get_CHAR_FOR_BIT_DATA (column));
0:       return (maxFieldSize_ == 0) ? tempString :
0:         tempString.substring(0, java.lang.Math.min (maxFieldSize_, tempString.length()));
0:     case java.sql.Types.VARBINARY:
0:     case java.sql.Types.LONGVARBINARY:
0:       tempString =
0:         agent_.crossConverters_.getStringFromBytes (get_VARCHAR_FOR_BIT_DATA (column));
0:       return (maxFieldSize_ == 0) ? tempString :
0:         tempString.substring(0, java.lang.Math.min (maxFieldSize_, tempString.length()));
0:     case java.sql.Types.BLOB:
0:       Blob b = (Blob) getBlobColumn_ (column, agent_);
0:       return agent_.crossConverters_.getStringFromBytes (b.getBytes(1, (int) b.length()));
0:     case java.sql.Types.CLOB:
0:       Clob c = getClobColumn_ (column, agent_);
0:       return c.getSubString (1, (int) c.length());
0:     default:
0:       throw new ColumnTypeConversionException (agent_.logWriter_);
0:     }
0:   }
1: 
0:   final byte[] getBytes (int column) throws SqlException
0:   {
0:     switch (jdbcTypes_[column-1]) {
0:     case java.sql.Types.BINARY:
0:       return get_CHAR_FOR_BIT_DATA (column);
0:     case java.sql.Types.VARBINARY:
0:     case java.sql.Types.LONGVARBINARY:
0:       return get_VARCHAR_FOR_BIT_DATA (column);
0:     case java.sql.Types.BLOB:
0:       Blob b = (Blob) getBlobColumn_ (column, agent_);
0:       return b.getBytes (1, (int) b.length()); 
0:     default:
0:       throw new ColumnTypeConversionException (agent_.logWriter_);
0:     }
0:   }
1: 
0:   public final java.io.InputStream getBinaryStream (int column) throws SqlException
0:   {
0:     switch (jdbcTypes_[column-1]) {
0:     case java.sql.Types.BINARY:
0:       return new java.io.ByteArrayInputStream (get_CHAR_FOR_BIT_DATA (column));
0:     case java.sql.Types.VARBINARY:
0:     case java.sql.Types.LONGVARBINARY:
0:       return new java.io.ByteArrayInputStream (get_VARCHAR_FOR_BIT_DATA (column));
0:     case java.sql.Types.BLOB:
0:       Blob b = (Blob) getBlobColumn_ (column, agent_);
0:       return b.getBinaryStream();
0:     default:
0:       throw new ColumnTypeConversionException (agent_.logWriter_);
0:     }
0:   }
1: 
0:   public final java.io.InputStream getAsciiStream (int column) throws SqlException
0:   {
0:     switch (jdbcTypes_[column-1]) {
0:     case java.sql.Types.CLOB:
0:       Clob c = getClobColumn_ (column, agent_);
0:       return c.getAsciiStream();
0:     case java.sql.Types.CHAR:
0:       try {
0:         return new java.io.ByteArrayInputStream (getCHAR(column).getBytes("US-ASCII"));
0:       }
0:       catch (java.io.UnsupportedEncodingException e) {
0:         throw new SqlException (agent_.logWriter_, e.getMessage());
0:       }
0:     case java.sql.Types.VARCHAR:
0:     case java.sql.Types.LONGVARCHAR:
0:       try {
0:         return new java.io.ByteArrayInputStream (getVARCHAR(column).getBytes("US-ASCII"));
0:       }
0:       catch (java.io.UnsupportedEncodingException e) {
0:         throw new SqlException (agent_.logWriter_, e.getMessage());
0:       }
0:     case java.sql.Types.BINARY:
0:       return new java.io.ByteArrayInputStream (get_CHAR_FOR_BIT_DATA (column));
0:     case java.sql.Types.VARBINARY:
0:     case java.sql.Types.LONGVARBINARY:
0:       return new java.io.ByteArrayInputStream (get_VARCHAR_FOR_BIT_DATA (column));
0:     case java.sql.Types.BLOB:
0:       Blob b = (Blob) getBlobColumn_ (column, agent_);
0:       return b.getBinaryStream();
0:     default:
0:       throw new ColumnTypeConversionException (agent_.logWriter_);
0:     }
0:   }
1: 
0:   public final java.io.InputStream getUnicodeStream (int column) throws SqlException
0:   {
0:     switch (jdbcTypes_[column-1]) {
0:     case java.sql.Types.CLOB: {
0:       Clob c = getClobColumn_ (column, agent_);
0:       String s = c.getSubString (1L, (int) c.length());
0:       try {
0:         return new java.io.ByteArrayInputStream (s.getBytes ("UTF-8"));
0:       }
0:       catch (java.io.UnsupportedEncodingException e) {
0:         throw new SqlException (agent_.logWriter_, e.getMessage());
0:       }
0:     }
0:     case java.sql.Types.CHAR: {
0:       try {
0:         return new java.io.ByteArrayInputStream (getCHAR (column).getBytes ("UTF-8"));
0:       }
0:       catch (java.io.UnsupportedEncodingException e) {
0:         throw new SqlException (agent_.logWriter_, e.getMessage());
0:       }
0:     }
0:     case java.sql.Types.VARCHAR:
0:     case java.sql.Types.LONGVARCHAR:
0:       try {
0:         return new java.io.ByteArrayInputStream (getVARCHAR(column).getBytes ("UTF-8"));
0:       }
0:       catch (java.io.UnsupportedEncodingException e) {
0:         throw new SqlException (agent_.logWriter_, e.getMessage());
0:       }
0:     case java.sql.Types.BINARY:
0:       return new java.io.ByteArrayInputStream (get_CHAR_FOR_BIT_DATA (column));
0:     case java.sql.Types.VARBINARY:
0:     case java.sql.Types.LONGVARBINARY:
0:       return new java.io.ByteArrayInputStream (get_VARCHAR_FOR_BIT_DATA (column));
0:     case java.sql.Types.BLOB:
0:       Blob b = (Blob) getBlobColumn_ (column, agent_);
0:       return b.getBinaryStream();
0:     default:
0:       throw new ColumnTypeConversionException (agent_.logWriter_);
0:     }
0:   }
1: 
0:   public final java.io.Reader getCharacterStream (int column) throws SqlException
0:   {
0:     switch (jdbcTypes_[column-1]) {
0:     case java.sql.Types.CLOB:
0:       Clob c = getClobColumn_ (column, agent_);
0:       return c.getCharacterStream();
0:     case java.sql.Types.CHAR:
0:       return new java.io.StringReader (getCHAR (column));
0:     case java.sql.Types.VARCHAR:
0:     case java.sql.Types.LONGVARCHAR:
0:       return new java.io.StringReader (getVARCHAR (column));
0:     case java.sql.Types.BINARY:
0:       try {
0:         return new java.io.InputStreamReader (new java.io.ByteArrayInputStream (get_CHAR_FOR_BIT_DATA (column)), "UTF-16BE");
0:       }
0:       catch (java.io.UnsupportedEncodingException e) {
0:         throw new SqlException (agent_.logWriter_, "UnsupportedEncodingException: " + e.getMessage());
0:       }
0:     case java.sql.Types.VARBINARY:
0:     case java.sql.Types.LONGVARBINARY:
0:       try {
0:         return new java.io.InputStreamReader (new java.io.ByteArrayInputStream (get_VARCHAR_FOR_BIT_DATA (column)), "UTF-16BE");
0:       }
0:       catch (java.io.UnsupportedEncodingException e) {
0:         throw new SqlException (agent_.logWriter_, "UnsupportedEncodingException: " + e.getMessage());
0:       }
0:     case java.sql.Types.BLOB:
0:       try {
0:         Blob b = (Blob) getBlobColumn_ (column, agent_);
0:         return new java.io.InputStreamReader (b.getBinaryStream(), "UTF-16BE");
0:       }
0:       catch (java.io.UnsupportedEncodingException e) {
0:         throw new SqlException (agent_.logWriter_, "UnsupportedEncodingException: " + e.getMessage());
0:       }
0:     default:
0:       throw new ColumnTypeConversionException (agent_.logWriter_);
0:     }
0:   }
1: 
0:   public final java.sql.Blob getBlob (int column) throws SqlException
0:   {
0:     switch (jdbcTypes_[column-1]) {
0:     case Types.BLOB:
0:       return getBlobColumn_ (column, agent_);
0:     default:
0:       throw new ColumnTypeConversionException (agent_.logWriter_);
0:     }
0:   }
1: 
0:   public final java.sql.Clob getClob (int column) throws SqlException
0:   {
0:     switch (jdbcTypes_[column-1]) {
0:     case Types.CLOB:
0:       return getClobColumn_ (column, agent_);
0:     default:
0:       throw new ColumnTypeConversionException (agent_.logWriter_);
0:     }
0:   }
1: 
0:   public final java.sql.Array getArray (int column) throws SqlException
0:   {
0:     throw new SqlException (agent_.logWriter_, "not yet implemented");
0:   }
1: 
0:   public final java.sql.Ref getRef (int column) throws SqlException
0:   {
0:     throw new SqlException (agent_.logWriter_, "not yet implemented");
0:   }
1: 
0:   public final Object getObject (int column) throws SqlException
0:   {
0:     switch (jdbcTypes_[column-1]) {
0:     case java.sql.Types.SMALLINT:
0:       return new Integer (get_SMALLINT (column)); // See Table 4 in JDBC 1 spec (pg. 932 in jdbc book)
0:     case java.sql.Types.INTEGER:
0:       return new Integer (get_INTEGER (column));
0:     case java.sql.Types.BIGINT:
0:       return new Long (get_BIGINT (column));
0:     case java.sql.Types.REAL:
0:       return new Float (get_FLOAT (column));
0:     case java.sql.Types.DOUBLE:
0:       return new Double (get_DOUBLE (column));
0:     case java.sql.Types.DECIMAL:
0:       return get_DECIMAL (column);
0:     case java.sql.Types.DATE:
0:       return getDATE (column);
0:     case java.sql.Types.TIME:
0:       return getTIME (column);
0:     case java.sql.Types.TIMESTAMP:
0:       return getTIMESTAMP (column);
0:     case java.sql.Types.CHAR:
0:       return getCHAR (column);
0:     case java.sql.Types.VARCHAR:
0:     case java.sql.Types.LONGVARCHAR:
0:       return getVARCHAR (column);
0:     case Types.BINARY:
0:       return get_CHAR_FOR_BIT_DATA (column);
0:     case java.sql.Types.VARBINARY:
0:     case java.sql.Types.LONGVARBINARY:
0:       return get_VARCHAR_FOR_BIT_DATA (column);
0:     case java.sql.Types.BLOB:
0:       return getBlobColumn_ (column, agent_);
0:     case java.sql.Types.CLOB:
0:       return getClobColumn_ (column, agent_);
0:     default:
0:       throw new ColumnTypeConversionException (agent_.logWriter_);
0:     }
0:   }
1: 
0:   public final void allocateCharBuffer ()
0:   {
0:     // compute the maximum char length
0:     int maxCharLength = 0;
0:     for (int i=0; i<columns_; i++) {
0:       switch (jdbcTypes_[i]) {
0:       case Types.CHAR:
0:       case Types.VARCHAR:
0:       case Types.LONGVARCHAR:
0:         if (fdocaLength_[i] > maxCharLength) maxCharLength = fdocaLength_[i];
0:       }
0:     }
1: 
0:     // allocate char buffer to accomodate largest result column
0:     charBuffer_ = new char[maxCharLength]; 
0:   }
1: 
0:   private final String getStringWithoutConvert (int position, int actualLength) throws SqlException
0:   {
0:     int start = position;
0:     int end = position + actualLength;
1: 
0:     int charCount = 0;
0:       while (start < end)
0:       {
0:          charBuffer_[charCount++] = (char) (((dataBuffer_[start]&0xff)<<8) | (dataBuffer_[start+1]&0xff));
0:          start += 2;
0:     }
1: 
0:     return new String(charBuffer_, 0, charCount);
0:   }
1: 
0:   public void nullDataForGC ()
0:   {
0:     dataBuffer_ = null;
0:     dataBufferStream_ = null;
0:     columnDataPosition_ = null;
0:     columnDataComputedLength_ = null;
0:     columnDataPositionCache_ = null;
0:     columnDataLengthCache_ = null;
0:     columnDataIsNullCache_ = null;
0:     jdbcTypes_ = null;
0:     nullable_ = null;
0:     charsetName_ = null;
0:     this.ccsid_ = null;
0:     isUpdateDeleteHoleCache_ = null;
0:     isNull_ = null;
0:     fdocaLength_ = null;
0:     charBuffer_ = null;
0:   }
1: 
0:   private final int getColumnPrecision (int column)
0:   {
0:     return ((fdocaLength_[column] >> 8) & 0xff);
0:   }
1: 
0:   private final int getColumnScale (int column)
0:   {
0:     return (fdocaLength_[column] & 0xff);
0:   }
1: 
0:   // Only used by Sqlca.getMessage() when using a locale encoding
0:   // to convert errror message text instead of relying on server encoding as usual.
0:   final byte[] getBytesFromVARCHAR (int column) throws SqlException
0:   {
0:     byte[] bytes;
0:     bytes = new byte[columnDataComputedLength_[column-1]-2];
0:     System.arraycopy (dataBuffer_, columnDataPosition_[column-1]+2, bytes, 0, bytes.length);
0:     return bytes;
0:   }
0: }
============================================================================