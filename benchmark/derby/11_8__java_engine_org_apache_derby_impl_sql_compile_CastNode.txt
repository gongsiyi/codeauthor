8:eac0369: /*
69:eac0369: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.compile.CastNode
1:345de35: 
1:2d37fd6:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2d37fd6:    contributor license agreements.  See the NOTICE file distributed with
1:2d37fd6:    this work for additional information regarding copyright ownership.
1:2d37fd6:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2d37fd6:    (the "License"); you may not use this file except in compliance with
1:2d37fd6:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:345de35: 
15:eac0369:  */
1:eac0369: 
1:eac0369: package	org.apache.derby.impl.sql.compile;
1:eac0369: 
1:eac0369: import java.lang.reflect.Modifier;
1:3bb140c: import java.sql.Types;
1:f33fbaf: import java.util.List;
1:3bb140c: import org.apache.derby.iapi.error.StandardException;
1:3bb140c: import org.apache.derby.iapi.reference.ClassName;
1:401938a: import org.apache.derby.iapi.reference.Limits;
1:3bb140c: import org.apache.derby.iapi.reference.SQLState;
1:3bb140c: import org.apache.derby.iapi.services.classfile.VMOpcode;
1:3bb140c: import org.apache.derby.iapi.services.compiler.LocalField;
1:3bb140c: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1:3bb140c: import org.apache.derby.iapi.services.context.ContextManager;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:3bb140c: import org.apache.derby.iapi.sql.compile.TypeCompiler;
1:3bb140c: import org.apache.derby.iapi.sql.compile.Visitor;
1:3bb140c: import org.apache.derby.iapi.types.DataTypeDescriptor;
1:3bb140c: import org.apache.derby.iapi.types.DataTypeUtilities;
1:3bb140c: import org.apache.derby.iapi.types.DataValueDescriptor;
1:eac0369: import org.apache.derby.iapi.types.NumberDataType;
1:3bb140c: import org.apache.derby.iapi.types.TypeId;
1:eac0369: import org.apache.derby.iapi.util.JBitSet;
1:3bb140c: import org.apache.derby.iapi.util.StringUtil;
1:eac0369: 
4:eac0369: /**
1:3bb140c:  * An CastNode represents a cast expression.
9:eac0369:  *
1:eac0369:  */
1:eac0369: 
1:3bb140c: class CastNode extends ValueNode
22:eac0369: {
1:eac0369: 	ValueNode			castOperand;
1:d5ce63a: 	private int					targetCharType;
1:eac0369: 	TypeId	sourceCTI = null;
1:d5ce63a: 	private boolean forDataTypeFunction = false;
1:35c061a: 
1:35c061a:     /** The original, unbound descriptor for the target type, if it is a UDT. */
1:35c061a:     private DataTypeDescriptor targetUDT;
1:35c061a: 
1:3bb140c:     /** This variable gets set by the parser to indicate that this CAST node
1:d8b9ea3: 	 * has been generated by the parser. This means that we should use the 
1:3bb140c:      * collation info of the current compilation schema for this node's
1:d8b9ea3: 	 * collation setting. If this variable does not get set to true, then it 
1:d8b9ea3: 	 * means that this CAST node has been an internally generated node and we 
1:d8b9ea3: 	 * should not touch the collation info set for this CAST node because it 
1:d8b9ea3: 	 * has been already set correctly by the class that generated this CAST 
1:d8b9ea3: 	 * node. Collation info is part of the DataTypeDescriptor that's defined
1:d8b9ea3: 	 * on the ValueNode (the super class of this CastNode class)
1:eac0369: 	 */ 
1:d5ce63a: 	private boolean externallyGeneratedCastNode = false;
1:d5ce63a: 
1:3bb140c: 	/*
1:eac0369: 	** Static array of valid casts.  Dimentions
1:eac0369: 	** produce a single boolean which indicates
1:eac0369: 	** whether the case is possible or not.
1:eac0369: 	*/
1:806114c: 
1:eff9169:     /**
1:eff9169:      * Method calls:
1:eff9169:      * Argument type has the same semantics as assignment:
1:eff9169:      * Section 9.2 (Store assignment). There, General Rule
1:eff9169:      * 2.b.v.2 says that the database should raise an exception
1:eff9169:      * if truncation occurs when stuffing a string value into a
1:eff9169:      * VARCHAR, so make sure CAST doesn't issue warning only.
1:eff9169:      */
1:eff9169:     private boolean assignmentSemantics = false;
1:eff9169: 
1:9d9f6dd:     /**
1:9d9f6dd:      * The name of the target type if it's a UDT. It is partly redundant, as
1:9d9f6dd:      * the name can also be retrieved from the type descriptor. Additionally,
1:9d9f6dd:      * it contains information about the location of the UDT name in the
1:9d9f6dd:      * query text, which is useful if the query text needs to be rewritten.
1:9d9f6dd:      * (Useful for example when rewriting a CHECK constraint definition to
1:9d9f6dd:      * have fully qualified names before storing it in the dictionary.) This
1:9d9f6dd:      * field is only set for <b>explicit</b> casts to a UDT.
1:9d9f6dd:      */
1:9d9f6dd:     private TableName udtTargetName;
1:9d9f6dd: 
1:eac0369: 	/**
1:3bb140c:      * Constructor for a CastNode
1:eac0369: 	 *
1:eac0369: 	 * @param castOperand	The operand of the node
1:eac0369: 	 * @param castTarget	DataTypeServices (target type of cast)
1:3bb140c:      * @param cm            The context manager
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 
1:3bb140c:     CastNode(ValueNode castOperand,
1:3bb140c:              DataTypeDescriptor castTarget,
1:3bb140c:              ContextManager cm) throws StandardException {
1:3bb140c:         super(cm);
1:3bb140c:         this.castOperand = castOperand;
1:35c061a: 
1:35c061a:         // DERBY-6421: setType() tries to bind user defined types. We don't
1:35c061a:         // want to do any binding here, since we could be called during
1:35c061a:         // parsing. If the target type is a UDT, just store it for now and
1:35c061a:         // do the binding later when bindExpression() or bindCastNodeOnly()
1:35c061a:         // is called.
1:35c061a:         if (castTarget.getTypeId().isUserDefinedTypeId()) {
1:35c061a:             targetUDT = castTarget;
1:35c061a:         } else {
1:35c061a:             setType(castTarget);
1:35c061a:         }
22:eac0369: 	}
1:01217c2: 
1:01217c2: 	/**
1:3bb140c:      * Constructor for a CastNode
1:eac0369: 	 *
1:eac0369: 	 * @param castOperand	The operand of the node
1:eac0369: 	 * @param charType		CHAR or VARCHAR JDBC type as target
1:eac0369: 	 * @param charLength	target type length
1:3bb140c:      * @param cm            The context manager
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:3bb140c: 	 */
1:eac0369: 
1:3bb140c:     CastNode(ValueNode castOperand,
1:3bb140c:              int charType,
1:3bb140c:              int charLength,
1:3bb140c:              ContextManager cm) throws StandardException {
1:3bb140c:         super(cm);
1:3bb140c:         this.castOperand = castOperand;
1:3bb140c:         int charLen = charLength;
1:3bb140c:         targetCharType = charType;
1:eac0369: 		if (charLen < 0)	// unknown, figure out later
2:eac0369: 			return;
1:d5ce63a: 		setType(DataTypeDescriptor.getBuiltInDataTypeDescriptor(targetCharType, charLen));
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
1:eac0369: 	 * for how this should be done for tree printing.
1:eac0369: 	 *
1:eac0369: 	 * @return		This object as a String
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	public String toString()
1:3bb140c: 	{
1:ed82406: 	    if (SanityManager.DEBUG)
1:ed82406: 	    {
1:ed82406: 	        return "castTarget: " + getTypeServices() + "\n" +
1:ed82406: 	        super.toString();
1:ed82406: 	    }
1:ed82406: 	    else
1:ed82406: 	    {
1:ed82406: 	        return "";
1:ed82406: 	    }
1:d5ce63a: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
1:eac0369: 	 * how tree printing is supposed to work.
1:eac0369: 	 *
1:eac0369: 	 * @param depth		The depth of this node in the tree
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     void printSubNodes(int depth)
1:01217c2: 	{
2:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			super.printSubNodes(depth);
1:eac0369: 
1:eac0369: 			if (castOperand != null)
1:eac0369: 			{
1:eac0369: 				printLabel(depth, "castOperand: ");
1:eac0369: 				castOperand.treePrint(depth + 1);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 	protected int getOrderableVariantType() throws StandardException
1:eac0369: 	{
1:eac0369: 		return castOperand.getOrderableVariantType();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Bind this expression.  This means binding the sub-expressions,
1:eac0369: 	 * as well as figuring out what the return type is for this expression.
1:eac0369: 	 *
1:eac0369: 	 * @param fromList		The FROM list for the query this
1:eac0369: 	 *				expression is in, for binding columns.
1:eac0369: 	 * @param subqueryList		The subquery list being built as we find SubqueryNodes
1:09c2697:      * @param aggregates        The aggregate list being built as we find AggregateNodes
1:eac0369: 	 *
1:eac0369: 	 * @return	The new top of the expression tree.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:e1f49ca:     @Override @SuppressWarnings("fallthrough")
1:71c8e86:     ValueNode bindExpression(FromList fromList, SubqueryList subqueryList, List<AggregateNode> aggregates)
4:eac0369: 				throws StandardException
1:eac0369: 	{
1:eac0369: 		castOperand = castOperand.bindExpression(
1:eac0369: 								fromList, subqueryList,
1:09c2697:                                 aggregates);
1:eac0369: 
1:35c061a:         // Bind the target UDT.
1:35c061a:         if (targetUDT != null) {
1:35c061a:             setType(targetUDT);
1:35c061a:         }
1:35c061a: 
1:d5ce63a: 		if (getTypeServices() == null)   //CHAR or VARCHAR function without specifying target length
1:eac0369: 		{
1:eac0369: 			DataTypeDescriptor opndType = castOperand.getTypeServices();
1:eac0369: 			int length = -1;
1:eac0369: 			TypeId srcTypeId = opndType.getTypeId();
1:3bb140c: 
1:3bb140c:             if (srcTypeId.isNumericTypeId())
1:3bb140c:             {
1:3bb140c:                 length = opndType.getPrecision() + 1; // 1 for the sign
1:3bb140c:                 if (opndType.getScale() > 0)
1:3bb140c:                     length += 1;               // 1 for the decimal .
1:3bb140c: 
1:3bb140c:             }
1:401938a:             /*
1:401938a:              * Derby-1132 : The length for the target type was calculated
1:401938a:              * incorrectly while Char & Varchar functions were used. Thus
1:401938a:              * adding the check for Char & Varchar and calculating the
1:401938a:              * length based on the operand type.
1:401938a:              */
1:401938a:             else if(srcTypeId.isStringTypeId())
1:401938a:             {
1:401938a:                 length = opndType.getMaximumWidth();
1:401938a: 
1:401938a:                 // Truncate the target type width to the max width of the
1:401938a:                 // data type
1:401938a:                 if (this.targetCharType == Types.CHAR)
1:401938a:                     length = Math.min(length, Limits.DB2_CHAR_MAXWIDTH);
1:401938a:                 else if (this.targetCharType == Types.VARCHAR)
1:401938a:                     length = Math.min(length, Limits.DB2_VARCHAR_MAXWIDTH);
1:401938a:             }
1:3bb140c:             else
1:3bb140c:             {
1:3bb140c:                 TypeId typeid = opndType.getTypeId();
1:3bb140c: 
1:3bb140c:                 if (length < 0) {
1:3bb140c:                     length = DataTypeUtilities.getColumnDisplaySize(
1:3bb140c:                         typeid.getJDBCTypeId(), -1);
1:3bb140c:                 }
1:3bb140c:             }
1:3bb140c: 
1:3bb140c:             if (length < 0)
1:3bb140c:                 length = 1;  // same default as in parser
1:d5ce63a: 			setType(DataTypeDescriptor.getBuiltInDataTypeDescriptor(targetCharType, length));
1:eac0369: 			
1:3bb140c: 		}
1:eac0369: 
1:eac0369: 		/* 
1:eac0369: 		** If castOperand is an untyped null, 
1:eac0369: 		** then we must set the type.
1:eac0369: 		*/
1:eac0369: 		if (castOperand instanceof UntypedNullConstantNode)
1:eac0369: 		{
1:d5ce63a: 			castOperand.setType(getTypeServices());
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		bindCastNodeOnly();
1:eac0369: 		
1:eac0369: 		/* We can't chop out cast above an untyped null because
1:eac0369: 		 * the store can't handle it.
1:eac0369: 		 */
1:eac0369: 		if ((castOperand instanceof ConstantNode) &&
1:eac0369: 			!(castOperand instanceof UntypedNullConstantNode))
1:eac0369: 		{
1:eac0369: 			/* If the castOperand is a typed constant then we do the cast at
1:eac0369: 			 * bind time and return a constant of the correct type.
1:eac0369: 			 * NOTE: This could return an exception, but we're prepared to 
1:eac0369: 			 * deal with that. (NumberFormatException, etc.)
1:eac0369: 			 * We only worry about the easy (and useful)
1:eac0369: 			 * converions at bind time.
1:eac0369: 			 * Here's what we support:
1:eac0369: 			 *			source					destination
1:eac0369: 			 *			------					-----------
1:eac0369: 			 *			boolean					boolean
1:eac0369: 			 *			boolean					char
1:eac0369: 			 *			char					boolean
1:eac0369: 			 *			char					date/time/ts
1:eac0369: 			 *			char					non-decimal numeric
1:eac0369: 			 *			date/time/ts			char
1:eac0369: 			 *			numeric					char
1:eac0369: 			 *			numeric					non-decimal numeric
1:eac0369: 			 */
1:eac0369: 			/* RESOLVE - to be filled in. */
2:eac0369: 			ValueNode retNode = this;
1:eac0369: 			int		  sourceJDBCTypeId = sourceCTI.getJDBCTypeId();
1:d5ce63a: 			int		  destJDBCTypeId = getTypeId().getJDBCTypeId();
1:eac0369: 
1:eac0369: 			switch (sourceJDBCTypeId)
1:eac0369: 			{
1:eac0369: 				case Types.BIT:
1:1a4ea31: 				case Types.BOOLEAN:
1:eac0369: 					// (BIT is boolean)
1:1a4ea31: 					if (destJDBCTypeId == Types.BIT || destJDBCTypeId == Types.BOOLEAN)
1:eac0369: 					{
1:eac0369: 						retNode = castOperand;
1:eac0369: 					}
1:eac0369: 					else if (destJDBCTypeId == Types.CHAR)
1:eac0369: 					{
1:eac0369: 						BooleanConstantNode bcn = (BooleanConstantNode) castOperand;
1:eac0369: 						String booleanString = bcn.getValueAsString();
1:3bb140c:                        retNode = new CharConstantNode(
1:3bb140c:                                 booleanString,
1:3bb140c:                                 getTypeServices().getMaximumWidth(),
1:3bb140c:                                 getContextManager());
1:eac0369: 					}
3:509ccb9: 					break;
1:31342ae: 
1:eac0369: 					case Types.CHAR:
1:eac0369: 						retNode = getCastFromCharConstant(destJDBCTypeId);
1:509ccb9: 						break;
1:31342ae: 
2:eac0369: 					case Types.DATE:
2:eac0369: 					case Types.TIME:
2:eac0369: 					case Types.TIMESTAMP:
1:eac0369: 						if (destJDBCTypeId == Types.CHAR)
1:eac0369: 						{
1:eac0369: 							String castValue =  
1:eac0369: 								((UserTypeConstantNode) castOperand).
1:eac0369: 											getObjectValue().
1:eac0369: 												toString();
1:3bb140c:                            retNode = new CharConstantNode(
1:3bb140c:                                castValue,
1:3bb140c:                                getTypeServices().getMaximumWidth(),
1:31342ae:                                getContextManager());
1:eac0369: 						}
1:509ccb9: 						break;
1:509ccb9: 
1:509ccb9: 					case Types.DECIMAL:
1:509ccb9: 						// ignore decimal -> decimal casts for now
1:509ccb9: 						if (destJDBCTypeId == Types.DECIMAL ||
1:509ccb9: 							destJDBCTypeId == Types.NUMERIC)
1:509ccb9: 							break;
1:509ccb9: 						// fall through
1:eac0369: 					case Types.TINYINT:
1:eac0369: 					case Types.SMALLINT:
1:eac0369: 					case Types.INTEGER:
1:eac0369: 					case Types.BIGINT:
1:eac0369: 					case Types.DOUBLE:
1:eac0369: 					case Types.REAL:
1:509ccb9: 						retNode = getCastFromNumericType(
1:509ccb9: 											((ConstantNode) castOperand).getValue(), 
3:eac0369: 											destJDBCTypeId);
1:509ccb9: 						break;
1:eac0369: 
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			// Return the new constant if the cast was performed
2:eac0369: 			return retNode;
1:eac0369: 		}
1:eac0369: 
2:eac0369: 		return this;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Bind this node but not its child.  Caller has already bound
1:eac0369: 	 * the child.
1:eac0369: 	 * This is useful for when we generate a CastNode during binding
1:eac0369: 	 * after having already bound the child.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     void bindCastNodeOnly()
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:35c061a:         // Bind the target UDT.
1:35c061a:         if (targetUDT != null) {
1:35c061a:             setType(targetUDT);
1:35c061a:         }
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** The result type is always castTarget.
1:eac0369: 		*/
1:eac0369: 		sourceCTI = castOperand.getTypeId();
1:eac0369: 
1:244952e: 		//If the result type of cast is string data type, then that data type 
1:244952e: 		//should get it's collation type from the current schema. 
1:d5ce63a: 		if (externallyGeneratedCastNode && getTypeId().isStringTypeId()) {
1:b80f8ae: 			//set the collation type to be same as the compilation schema's 
1:b80f8ae: 			//collation type. Collation derivation will be set to "IMPLICIT".
1:9ed7c4d: 			setCollationUsingCompilationSchema();
1:eac0369: 		}
1:eac0369: 		/* 
1:eac0369: 		** If it is a java cast, do some work to make sure
1:eac0369: 		** the classes are ok and that they are compatible
1:eac0369: 		*/
1:d5ce63a: 		if (getTypeId().userType())
1:eac0369: 		{
1:816219f:             setType( bindUserType( getTypeServices() ) );
1:816219f:             
1:ef158f2: 			String className = getTypeId().getCorrespondingJavaTypeName();
1:eac0369: 
1:2e1b5e8: 			verifyClassExist(className);
1:eac0369: 		}
1:eac0369: 
1:9d9f6dd:         // Set the schema name of the UDT target type.
1:9d9f6dd:         if (udtTargetName != null) {
1:9d9f6dd:             udtTargetName.setSchemaName(
1:9d9f6dd:                     getTypeId().getBaseTypeId().getSchemaName());
1:9d9f6dd:         }
1:9d9f6dd: 
1:ac12b1f:         // Obviously the type of a parameter that
1:ac12b1f:         // requires its type from context (a parameter)
1:ac12b1f:         // gets its type from the type of the CAST.
1:d5bc20f: 		if (castOperand.requiresTypeFromContext())
1:eac0369: 		{
1:ac12b1f:             castOperand.setType(getTypeServices());
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** If it isn't null, then we have
1:eac0369: 		** a cast from one JBMS type to another.  So we
1:eac0369: 		** have to figure out if it is legit.
1:eac0369: 		*/
1:eac0369: 		else if (!(castOperand instanceof UntypedNullConstantNode))
1:eac0369: 		{
1:eac0369: 			/*
1:eac0369: 			** Make sure we can assign the two classes
1:eac0369: 			*/
1:eac0369: 			TypeCompiler tc = castOperand.getTypeCompiler();
1:d5ce63a: 			if (! tc.convertible(getTypeId(), forDataTypeFunction))
1:eac0369: 			{
1:eac0369: 				throw StandardException.newException(SQLState.LANG_INVALID_CAST, 
1:eac0369: 						sourceCTI.getSQLTypeName(),
1:d5ce63a:                         getTypeId().getSQLTypeName());
1:50a8c62: 			}
1:eac0369: 		}	
1:0859d5b: 
1:0859d5b:         //
1:50a8c62: 		// Preserve the nullability of the operand since a CAST
1:0859d5b: 		// of a non-NULL value is also non-NULL. However, if the source type is
1:0859d5b:         // a non-nullable string type and the target type is a boolean, then the result
1:0859d5b:         // still must be nullable because the string "unknown" casts to boolean NULL.
1:0859d5b:         //
1:0859d5b:         if (
1:0859d5b:             castOperand.getTypeServices().getTypeId().isStringTypeId() &&
1:0859d5b:             getTypeId().isBooleanTypeId()
1:0859d5b:             )
1:0859d5b:         { setNullability( true ); }
1:0859d5b: 		else { setNullability(castOperand.getTypeServices().isNullable()); }
1:9a9d658:         
1:9a9d658:         if (targetUDT != null)
1:9a9d658:         {
1:9a9d658:             addUDTUsagePriv( this );
1:9a9d658:         }
1:eac0369: 	}
1:50a8c62: 
1:eac0369: 	/**
1:eac0369: 	 * Get a constant representing the cast from a CHAR to another
1:eac0369: 	 * type.  If this is not an "easy" cast to perform, then just
1:eac0369: 	 * return this cast node.
1:eac0369: 	 * Here's what we think is "easy":
1:eac0369: 	 *			source			destination
1:eac0369: 	 *			------			-----------
1:eac0369: 	 *			char			boolean
1:eac0369: 	 *			char			date/time/ts
1:eac0369: 	 *			char			non-decimal numeric
1:eac0369: 	 *
1:eac0369: 	 * @param destJDBCTypeId	The destination JDBC TypeId
1:eac0369: 	 *
1:eac0369: 	 * @return The new top of the tree (this CastNode or a new Constant)
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	private ValueNode getCastFromCharConstant(int destJDBCTypeId)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		String	  charValue = ((CharConstantNode) castOperand).getString();
1:eac0369: 		String	  cleanCharValue = StringUtil.SQLToUpperCase(charValue.trim());
1:eac0369: 		ValueNode retNode = this;
1:eac0369: 
1:eac0369: 		switch (destJDBCTypeId)
1:eac0369: 		{
1:eac0369: 			case Types.BIT:
1:1a4ea31: 			case Types.BOOLEAN:
1:eac0369: 				if (cleanCharValue.equals("TRUE"))
1:eac0369: 				{
1:3bb140c:                    return new BooleanConstantNode(true, getContextManager());
1:eac0369: 				}
1:eac0369: 				else if (cleanCharValue.equals("FALSE"))
1:eac0369: 				{
1:3bb140c:                    return new BooleanConstantNode(false, getContextManager());
1:eac0369: 				}
1:31342ae: 				else if (cleanCharValue.equals("UNKNOWN"))
1:31342ae: 				{
1:3bb140c:                    return new BooleanConstantNode(getContextManager());
1:31342ae: 				}
4:eac0369: 				else
1:eac0369: 				{
1:eac0369: 					throw StandardException.newException(SQLState.LANG_FORMAT_EXCEPTION, "boolean");
1:eac0369: 				}
1:eac0369: 
1:eac0369: 			case Types.DATE:
1:3bb140c:                return new UserTypeConstantNode(
1:eac0369: 										getDataValueFactory().getDateValue(cleanCharValue, false),
1:3bb140c: 										getContextManager());
1:eac0369: 
1:eac0369: 			case Types.TIMESTAMP:
1:3bb140c:                return new UserTypeConstantNode(
1:eac0369: 									getDataValueFactory().getTimestampValue(cleanCharValue, false),
1:509ccb9: 									getContextManager());
1:eac0369: 
1:eac0369: 			case Types.TIME:
1:3bb140c:                return new UserTypeConstantNode(
1:eac0369: 										getDataValueFactory().getTimeValue(cleanCharValue, false),
23:eac0369: 										getContextManager());
1:eac0369: 
1:eac0369: 			case Types.TINYINT:
1:eac0369: 			case Types.SMALLINT:
1:eac0369: 			case Types.INTEGER:
1:eac0369: 			case Types.BIGINT:				
1:eac0369: 				try 
1:eac0369: 				{
1:eac0369: 					// #3756 - Truncate decimal portion for casts to integer
1:ce40a31:                   return getCastFromIntegralType((long) Double.parseDouble(cleanCharValue),
1:eac0369: 												   destJDBCTypeId);
1:eac0369: 				}
1:eac0369: 				catch (NumberFormatException nfe)
1:eac0369: 				{
1:eac0369: 					String sqlName = TypeId.getBuiltInTypeId(destJDBCTypeId).getSQLTypeName();
1:eac0369: 					throw StandardException.newException(SQLState.LANG_FORMAT_EXCEPTION, sqlName);
1:eac0369: 				}
1:eac0369: 			case Types.REAL:
1:eac0369: 				Float floatValue;
1:eac0369: 				try
1:eac0369: 				{
1:eac0369: 					floatValue = Float.valueOf(cleanCharValue);
1:eac0369: 				}
1:eac0369: 				catch (NumberFormatException nfe)
1:eac0369: 				{
1:eac0369: 					throw StandardException.newException(SQLState.LANG_FORMAT_EXCEPTION, "float");
1:eac0369: 				}
1:3bb140c:                return new NumericConstantNode(
1:3bb140c:                        TypeId.getBuiltInTypeId(Types.REAL),
1:3bb140c:                        floatValue,
1:3bb140c:                        getContextManager());
1:eac0369: 			case Types.DOUBLE:
1:eac0369: 				Double doubleValue;
1:eac0369: 				try
1:eac0369: 				{
1:ce40a31: 					doubleValue = Double.parseDouble(cleanCharValue);
1:eac0369: 				}
1:eac0369: 				catch (NumberFormatException nfe)
1:eac0369: 				{
1:eac0369: 					throw StandardException.newException(SQLState.LANG_FORMAT_EXCEPTION, "double");
1:eac0369: 				}
1:3bb140c:                return new NumericConstantNode(
1:3bb140c:                        TypeId.getBuiltInTypeId(Types.DOUBLE),
1:3bb140c:                        doubleValue,
1:3bb140c:                        getContextManager());
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return retNode;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get a constant representing the cast from an integral type to another
1:eac0369: 	 * type.  If this is not an "easy" cast to perform, then just
1:eac0369: 	 * return this cast node.
1:eac0369: 	 * Here's what we think is "easy":
1:eac0369: 	 *			source				destination
1:eac0369: 	 *			------				-----------
1:eac0369: 	 *			integral type		 non-decimal numeric
1:eac0369: 	 *			integral type		 char
1:eac0369: 	 *
1:eac0369: 	 * @param longValue			integral type as a long to cast from
1:eac0369: 	 * @param destJDBCTypeId	The destination JDBC TypeId
1:eac0369: 	 *
1:eac0369: 	 * @return The new top of the tree (this CastNode or a new Constant)
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	private ValueNode getCastFromIntegralType(
1:eac0369: 									  long longValue, 
1:eac0369: 									  int destJDBCTypeId)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		ValueNode retNode = this;
1:eac0369: 
1:eac0369: 		switch (destJDBCTypeId)
1:eac0369: 		{
1:eac0369: 			case Types.CHAR:
1:3bb140c:                return new CharConstantNode(
1:3bb140c:                         Long.toString(longValue),
1:3bb140c:                         getTypeServices().getMaximumWidth(),
1:3bb140c:                         getContextManager());
1:eac0369: 			case Types.TINYINT:
1:eac0369: 				if (longValue < Byte.MIN_VALUE ||
1:eac0369: 					longValue > Byte.MAX_VALUE)
1:eac0369: 				{
2:eac0369: 					throw StandardException.newException(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, "TINYINT");
1:eac0369: 				}
1:3bb140c:                return new NumericConstantNode(
1:3bb140c:                        TypeId.getBuiltInTypeId(Types.TINYINT),
1:bb5be6f:                        (byte) longValue,
1:3bb140c:                        getContextManager());
1:eac0369: 
1:eac0369: 			case Types.SMALLINT:
1:eac0369: 				if (longValue < Short.MIN_VALUE ||
1:eac0369: 					longValue > Short.MAX_VALUE)
1:eac0369: 				{
1:eac0369: 					throw StandardException.newException(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, "SHORT");
1:eac0369: 				}
1:3bb140c:                return new NumericConstantNode(
1:3bb140c:                    TypeId.getBuiltInTypeId(destJDBCTypeId),
1:bb5be6f:                    (short) longValue,
1:3bb140c:                    getContextManager());
1:eac0369: 
1:eac0369: 			case Types.INTEGER:
1:eac0369: 				if (longValue < Integer.MIN_VALUE ||
1:eac0369: 					longValue > Integer.MAX_VALUE)
1:eac0369: 				{
2:eac0369: 					throw StandardException.newException(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, "INTEGER");
1:eac0369: 				}
1:3bb140c:                return new NumericConstantNode(
1:3bb140c:                    TypeId.getBuiltInTypeId(destJDBCTypeId),
1:bb5be6f:                    (int) longValue,
1:3bb140c:                    getContextManager());
1:eac0369: 
1:eac0369: 			case Types.BIGINT:
1:3bb140c:                return new NumericConstantNode(
1:3bb140c:                    TypeId.getBuiltInTypeId(destJDBCTypeId),
1:bb5be6f:                    longValue,
1:3bb140c:                    getContextManager());
1:eac0369: 
1:eac0369: 			case Types.REAL:
1:eac0369: 				if (Math.abs(longValue) > Float.MAX_VALUE)
1:eac0369: 				{
1:eac0369: 					throw StandardException.newException(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, "REAL");
1:eac0369: 				}
1:3bb140c:                return new NumericConstantNode(
1:3bb140c:                    TypeId.getBuiltInTypeId(destJDBCTypeId),
1:ce40a31:                    (float) longValue,
1:3bb140c:                    getContextManager());
1:eac0369: 
1:eac0369: 			case Types.DOUBLE:
1:3bb140c:                return new NumericConstantNode(
1:3bb140c:                    TypeId.getBuiltInTypeId(destJDBCTypeId),
1:ce40a31:                    (double) longValue,
1:3bb140c:                    getContextManager());
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return retNode;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get a constant representing the cast from a non-integral type to another
1:eac0369: 	 * type.  If this is not an "easy" cast to perform, then just
1:eac0369: 	 * return this cast node.
1:eac0369: 	 * Here's what we think is "easy":
1:eac0369: 	 *			source				destination
1:eac0369: 	 *			------				-----------
1:eac0369: 	 *			non-integral type	 non-decimal numeric
1:eac0369: 	 *			non-integral type	 char
1:eac0369: 	 *
1:6b50965: 	 * @param constantValue		non-integral type a a double to cast from
1:eac0369: 	 * @param destJDBCTypeId	The destination JDBC TypeId
1:eac0369: 	 *
1:eac0369: 	 * @return The new top of the tree (this CastNode or a new Constant)
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:509ccb9: 	private ValueNode getCastFromNumericType(
1:509ccb9: 									  DataValueDescriptor constantValue, 
1:eac0369: 									  int destJDBCTypeId)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		switch (destJDBCTypeId)
1:eac0369: 		{
1:eac0369: 			case Types.CHAR:
1:3bb140c:                return new CharConstantNode(
1:3bb140c:                         constantValue.getString(),
1:3bb140c:                         getTypeServices().getMaximumWidth(),
1:3bb140c:                         getContextManager());
1:509ccb9: 
1:eac0369: 			case Types.TINYINT:
1:3bb140c:                 return new NumericConstantNode(
1:3bb140c:                         TypeId.getBuiltInTypeId(destJDBCTypeId),
1:3bb140c:                         Byte.valueOf(constantValue.getByte()),
1:3bb140c:                         getContextManager());
1:509ccb9: 
1:eac0369: 			case Types.SMALLINT:
1:3bb140c:                 return new NumericConstantNode(
1:3bb140c:                         TypeId.getBuiltInTypeId(destJDBCTypeId),
1:3bb140c:                         Short.valueOf(constantValue.getShort()),
1:3bb140c:                         getContextManager());
1:eac0369: 
1:eac0369: 			case Types.INTEGER:
1:3bb140c:                 return new NumericConstantNode(
1:3bb140c:                         TypeId.getBuiltInTypeId(destJDBCTypeId),
1:3bb140c:                         Integer.valueOf(constantValue.getInt()),
1:3bb140c:                         getContextManager());
1:eac0369: 
1:eac0369: 			case Types.BIGINT:
1:3bb140c:                 return new NumericConstantNode(
1:3bb140c:                         TypeId.getBuiltInTypeId(destJDBCTypeId),
1:3bb140c:                         Long.valueOf(constantValue.getLong()),
1:3bb140c:                         getContextManager());
1:eac0369: 
1:eac0369: 			case Types.REAL:
1:3bb140c:                 return new NumericConstantNode(
1:3bb140c:                         TypeId.getBuiltInTypeId(destJDBCTypeId),
1:3bb140c:                         Float.valueOf(NumberDataType.normalizeREAL(
1:3bb140c:                                       constantValue.getDouble())),
1:3bb140c:                         getContextManager());
1:eac0369: 
1:eac0369: 			case Types.DOUBLE:
1:509ccb9: 				// no need to normalize here because no constant could be out of range for a double
1:3bb140c:                 return new NumericConstantNode(
1:3bb140c:                         TypeId.getBuiltInTypeId(destJDBCTypeId),
1:3bb140c:                        Double.valueOf(constantValue.getDouble()),
1:3bb140c:                         getContextManager());
1:eac0369: 		}
1:509ccb9: 
1:3bb140c:         return this;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Preprocess an expression tree.  We do a number of transformations
1:eac0369: 	 * here (including subqueries, IN lists, LIKE and BETWEEN) plus
1:eac0369: 	 * subquery flattening.
1:eac0369: 	 * NOTE: This is done before the outer ResultSetNode is preprocessed.
1:eac0369: 	 *
1:eac0369: 	 * @param	numTables			Number of tables in the DML Statement
1:eac0369: 	 * @param	outerFromList		FromList from outer query block
1:eac0369: 	 * @param	outerSubqueryList	SubqueryList from outer query block
1:eac0369: 	 * @param	outerPredicateList	PredicateList from outer query block
1:eac0369: 	 *
1:eac0369: 	 * @return		The modified expression
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     ValueNode preprocess(int numTables,
1:eac0369: 								FromList outerFromList,
1:eac0369: 								SubqueryList outerSubqueryList,
1:eac0369: 								PredicateList outerPredicateList) 
1:eac0369: 					throws StandardException
1:eac0369: 	{
1:eac0369: 		castOperand = castOperand.preprocess(numTables,
1:eac0369: 											 outerFromList, outerSubqueryList,
1:eac0369: 											 outerPredicateList);
1:509ccb9: 		return this;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Categorize this predicate.  Initially, this means
1:eac0369: 	 * building a bit map of the referenced tables for each predicate.
1:eac0369: 	 * If the source of this ColumnReference (at the next underlying level) 
1:eac0369: 	 * is not a ColumnReference or a VirtualColumnNode then this predicate
1:eac0369: 	 * will not be pushed down.
1:eac0369: 	 *
1:eac0369: 	 * For example, in:
1:eac0369: 	 *		select * from (select 1 from s) a (x) where x = 1
1:eac0369: 	 * we will not push down x = 1.
1:eac0369: 	 * NOTE: It would be easy to handle the case of a constant, but if the
1:eac0369: 	 * inner SELECT returns an arbitrary expression, then we would have to copy
1:eac0369: 	 * that tree into the pushed predicate, and that tree could contain
1:eac0369: 	 * subqueries and method calls.
1:eac0369: 	 * RESOLVE - revisit this issue once we have views.
1:eac0369: 	 *
1:eac0369: 	 * @param referencedTabs	JBitSet with bit map of referenced FromTables
1:eac0369: 	 * @param simplePredsOnly	Whether or not to consider method
1:eac0369: 	 *							calls, field references and conditional nodes
1:eac0369: 	 *							when building bit map
1:eac0369: 	 *
1:eac0369: 	 * @return boolean		Whether or not source.expression is a ColumnReference
1:eac0369: 	 *						or a VirtualColumnNode.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException			Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     boolean categorize(JBitSet referencedTabs, boolean simplePredsOnly)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		return castOperand.categorize(referencedTabs, simplePredsOnly);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Remap all ColumnReferences in this tree to be clones of the
1:eac0369: 	 * underlying expression.
1:eac0369: 	 *
1:eac0369: 	 * @return ValueNode			The remapped expression tree.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException			Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     ValueNode remapColumnReferencesToExpressions()
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		castOperand = castOperand.remapColumnReferencesToExpressions();
1:eac0369: 		return this;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return whether or not this expression tree represents a constant expression.
1:eac0369: 	 *
1:eac0369: 	 * @return	Whether or not this expression tree represents a constant expression.
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     boolean isConstantExpression()
1:eac0369: 	{
1:eac0369: 		return castOperand.isConstantExpression();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see ValueNode#constantExpression */
1:3bb140c:     @Override
1:3bb140c:     boolean constantExpression(PredicateList whereClause)
1:eac0369: 	{
1:eac0369: 		return castOperand.constantExpression(whereClause);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return an Object representing the bind time value of this
1:eac0369: 	 * expression tree.  If the expression tree does not evaluate to
1:eac0369: 	 * a constant at bind time then we return null.
1:eac0369: 	 * This is useful for bind time resolution of VTIs.
1:eac0369: 	 * RESOLVE: What do we do for primitives?
1:eac0369: 	 *
1:eac0369: 	 * @return	An Object representing the bind time value of this expression tree.
1:eac0369: 	 *			(null if not a bind time constant.)
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	Object getConstantValueAsObject()
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		Object sourceObject = castOperand.getConstantValueAsObject();
1:eac0369: 
1:eac0369: 		// RESOLVE - need to figure out how to handle casts
1:eac0369: 		if (sourceObject == null)
1:eac0369: 		{
1:eac0369: 			return null;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// Simple if source and destination are of same type
1:eac0369: 		if (sourceCTI.getCorrespondingJavaTypeName().equals(
1:d5ce63a:                 getTypeId().getCorrespondingJavaTypeName()))
1:eac0369: 		{
1:eac0369: 			return sourceObject;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// RESOLVE - simply return null until we can figure out how to 
1:eac0369: 		// do the cast
1:eac0369: 		return null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Do code generation for this unary operator.
1:eac0369: 	 *
1:eac0369: 	 * @param acb	The ExpressionClassBuilder for the class we're generating
1:eac0369: 	 * @param mb	The method the code to place the code
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:8fe3166:     void generateExpression(ExpressionClassBuilder acb, MethodBuilder mb)
1:eac0369: 									throws StandardException
1:eac0369: 	{
1:eac0369: 		castOperand.generateExpression(acb, mb);
1:eac0369: 
1:eac0369: 		/* No need to generate code for null constants */
1:eac0369: 		if (castOperand instanceof UntypedNullConstantNode)
1:eac0369: 		{
1:eac0369: 			return;
1:eac0369: 		}
1:eac0369: 		/* HACK ALERT. When casting a parameter, there
1:eac0369: 		 * is not sourceCTI.  Code generation requires one,
1:eac0369: 		 * so we simply set it to be the same as the
1:eac0369: 		 * destCTI.  The user can still pass whatever
1:eac0369: 		 * type they'd like in as a parameter.
1:eac0369: 		 * They'll get an exception, as expected, if the
1:eac0369: 		 * conversion cannot be performed.
1:eac0369: 		 */
1:d5bc20f: 		else if (castOperand.requiresTypeFromContext())
1:eac0369: 		{
1:d5ce63a: 			sourceCTI = getTypeId();
1:eac0369: 		}
1:eac0369: 	
1:eac0369: 		genDataValueConversion(acb, mb);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	private void genDataValueConversion(ExpressionClassBuilder acb,
2:eac0369: 											  MethodBuilder mb)
1:eac0369: 			throws StandardException
1:eac0369: 	{
1:eac0369: 		MethodBuilder	acbConstructor = acb.getConstructor();
1:eac0369: 
1:eac0369: 		String resultTypeName = getTypeCompiler().interfaceName();
1:eac0369: 
1:eac0369: 		/* field = method call */
1:eac0369: 		/* Allocate an object for re-use to hold the result of the operator */
1:eac0369: 		LocalField field = acb.newFieldDeclaration(Modifier.PRIVATE, resultTypeName);
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** Store the result of the method call in the field, so we can re-use
1:eac0369: 		** the object.
1:eac0369: 		*/
1:eac0369: 
1:d5ce63a: 		acb.generateNull(acbConstructor, getTypeCompiler(getTypeId()), 
1:d5ce63a:                 getTypeServices().getCollationType());
1:afa871e: 		acbConstructor.setField(field);
1:eac0369: 
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 			For most types generate
1:eac0369: 
1:eac0369: 			targetDVD.setValue(sourceDVD);
1:806114c: 			
1:806114c: 			For source or destination java types generate
1:806114c: 			
1:806114c: 			Object o = sourceDVD.getObject();
1:806114c: 			targetDVD.setObjectForCast(o, o instanceof dest java type, dest java type);
1:eac0369: 
1:eac0369: 			// optional for variable length types
1:eac0369: 			targetDVD.setWidth();
1:eac0369: 		*/
1:eac0369: 
1:d5ce63a: 		if (!sourceCTI.userType() && !getTypeId().userType()) {
1:806114c: 			mb.getField(field); // targetDVD reference for the setValue method call
1:806114c: 			mb.swap();
1:806114c: 			mb.upCast(ClassName.DataValueDescriptor);
1:806114c: 			mb.callMethod(VMOpcode.INVOKEINTERFACE, ClassName.DataValueDescriptor,
1:806114c: 					"setValue", "void", 1);
1:eac0369: 		}
1:806114c: 		else
1:eac0369: 		{
1:806114c: 			/* 
1:806114c: 			** generate: expr.getObject()
1:806114c: 			*/
1:806114c: 			mb.callMethod(VMOpcode.INVOKEINTERFACE, ClassName.DataValueDescriptor,
1:806114c: 					"getObject", "java.lang.Object", 0);
1:eac0369: 
1:806114c: 			//castExpr
1:eac0369: 
1:806114c: 			mb.getField(field); // instance for the setValue/setObjectForCast method call
1:806114c: 			mb.swap(); // push it before the value
1:eac0369: 
1:806114c: 			/*
1:806114c: 			** We are casting a java type, generate:
1:806114c: 			**
1:806114c: 			**		DataValueDescriptor.setObjectForCast(java.lang.Object castExpr, boolean instanceOfExpr, destinationClassName)
1:806114c: 			** where instanceOfExpr is "source instanceof destinationClass".
1:806114c: 			**
1:806114c: 			*/
1:eac0369: 			String destinationType = getTypeId().getCorrespondingJavaTypeName();
1:eac0369: 
1:eac0369: 			// at this point method instance and cast result are on the stack
1:eac0369: 			// we duplicate the cast value in order to perform the instanceof check
1:eac0369: 			mb.dup();
1:eac0369: 			mb.isInstanceOf(destinationType);
1:eac0369: 			mb.push(destinationType);
1:806114c: 			mb.callMethod(VMOpcode.INVOKEINTERFACE, ClassName.DataValueDescriptor,
1:806114c: 					"setObjectForCast", "void", 3);
1:806114c: 
1:eac0369: 		}
1:806114c: 
2:eac0369: 		mb.getField(field);
1:eac0369: 
1:eac0369: 		/* 
2:eac0369: 		** If we are casting to a variable length datatype, we
2:eac0369: 		** have to make sure we have set it to the correct
2:eac0369: 		** length.
1:eac0369: 		*/
1:d5ce63a: 		if (getTypeId().variableLength()) 
1:eac0369: 		{
1:d5ce63a: 			boolean isNumber = getTypeId().isNumericTypeId();
1:eac0369: 			
1:806114c: 			// to leave the DataValueDescriptor value on the stack, since setWidth is void
1:806114c: 			mb.dup();
1:eac0369: 
2:eac0369: 			/* setWidth() is on VSDV - upcast since
2:eac0369: 			 * decimal implements subinterface
2:eac0369: 			 * of VSDV.
1:eac0369: 			 */
1:806114c: 			
1:d5ce63a: 			mb.push(isNumber ? getTypeServices().getPrecision() : getTypeServices().getMaximumWidth());
1:d5ce63a: 			mb.push(getTypeServices().getScale());
1:eff9169:             mb.push(!sourceCTI.variableLength() ||
1:eff9169:                     isNumber ||
1:eff9169:                     assignmentSemantics);
1:806114c: 			mb.callMethod(VMOpcode.INVOKEINTERFACE, ClassName.VariableSizeDataValue,
1:806114c: 					"setWidth", "void", 3);
1:eac0369: 
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:dd2f5a8: 	 * Accept the visitor for all visitable children of this node.
1:eac0369: 	 * 
1:eac0369: 	 * @param v the visitor
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:dd2f5a8: 	void acceptChildren(Visitor v)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:dd2f5a8: 		super.acceptChildren(v);
1:eac0369: 
1:aebfb28: 		if (castOperand != null)
1:eac0369: 		{
1:eac0369: 			castOperand = (ValueNode)castOperand.accept(v);
1:eac0369: 		}
1:9d9f6dd: 
1:9d9f6dd:         if (udtTargetName != null)
1:9d9f6dd:         {
1:9d9f6dd:             udtTargetName = (TableName) udtTargetName.accept(v);
1:9d9f6dd:         }
1:eac0369: 	}
1:eac0369: 
1:d8b9ea3: 	/** This method gets called by the parser to indiciate that this CAST node 
1:d8b9ea3: 	 * has been generated by the parser. This means that we should use the 
1:d8b9ea3: 	 * collation info of the current compilation schmea for this node's 
1:d8b9ea3: 	 * collation setting. If this method does not get called, then it means
1:d8b9ea3: 	 * that this CAST node has been an internally generated node and we should
1:d8b9ea3: 	 * not touch the collation of this CAST node because it has been already 
1:d8b9ea3: 	 * set correctly by the class that generated this CAST node. 
1:eac0369: 	 */
1:d5ce63a: 	void setForExternallyGeneratedCASTnode()
1:eac0369: 	{
1:d8b9ea3: 		externallyGeneratedCastNode = true;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** set this to be a dataTypeScalarFunction
1:eac0369: 	 * 
1:eac0369: 	 * @param b true to use function conversion rules
1:eac0369: 	 */
1:d5ce63a: 	void setForDataTypeFunction(boolean b)
1:eac0369: 	{
1:eac0369: 		forDataTypeFunction = b;
1:eac0369: 	}
1:eac0369: 
1:eff9169:     /**
1:eff9169:      * Set assignmentSemantics to true. Used by method calls for casting actual
1:eff9169:      * arguments
1:eff9169:      */
1:eff9169:     void setAssignmentSemantics()
1:eff9169:     {
1:eff9169:         assignmentSemantics = true;
1:eff9169:     }
1:eff9169: 
1:eff9169:     
1:eac0369: 	/**
1:01217c2: 	 * {@inheritDoc}
1:01217c2: 	 * @throws StandardException 
1:01217c2: 	 */
1:2706d1f:     boolean isEquivalent(ValueNode o) throws StandardException
1:01217c2: 	{
1:2706d1f:         if (isSameNodeKind(o)) {
1:01217c2: 			CastNode other = (CastNode)o;
1:d5ce63a: 			return getTypeServices().equals(other.getTypeServices())
1:01217c2: 				&& castOperand.isEquivalent(other.castOperand);
1:01217c2: 		}
1:2706d1f: 
1:01217c2: 		return false;
1:01217c2: 	}
1:9d9f6dd: 
1:9d9f6dd:     /**
1:9d9f6dd:      * Set the target type name if this is a cast to a UDT.
1:9d9f6dd:      * @param name the name of the target type
1:9d9f6dd:      */
1:9d9f6dd:     void setTargetUDTName(TableName name) {
1:9d9f6dd:         udtTargetName = name;
1:9d9f6dd:     }
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:ce40a31
/////////////////////////////////////////////////////////////////////////
1:                   return getCastFromIntegralType((long) Double.parseDouble(cleanCharValue),
/////////////////////////////////////////////////////////////////////////
1: 					doubleValue = Double.parseDouble(cleanCharValue);
/////////////////////////////////////////////////////////////////////////
1:                    (float) longValue,
1:                    (double) longValue,
commit:9a9d658
/////////////////////////////////////////////////////////////////////////
1:         
1:         if (targetUDT != null)
1:         {
1:             addUDTUsagePriv( this );
1:         }
commit:71c8e86
/////////////////////////////////////////////////////////////////////////
1:     ValueNode bindExpression(FromList fromList, SubqueryList subqueryList, List<AggregateNode> aggregates)
commit:0859d5b
/////////////////////////////////////////////////////////////////////////
1: 
1:         //
1: 		// of a non-NULL value is also non-NULL. However, if the source type is
1:         // a non-nullable string type and the target type is a boolean, then the result
1:         // still must be nullable because the string "unknown" casts to boolean NULL.
1:         //
1:         if (
1:             castOperand.getTypeServices().getTypeId().isStringTypeId() &&
1:             getTypeId().isBooleanTypeId()
1:             )
1:         { setNullability( true ); }
1: 		else { setNullability(castOperand.getTypeServices().isNullable()); }
commit:31342ae
/////////////////////////////////////////////////////////////////////////
1: 				else if (cleanCharValue.equals("UNKNOWN"))
1: 				{
0: 					ConstantNode cn = (ConstantNode) getNodeFactory().getNode(
0: 											C_NodeTypes.BOOLEAN_CONSTANT_NODE,
0: 											null,
1: 											getContextManager());
1: 
0:                     cn.setNullability( true );
1: 
0:                     return cn;
1: 				}
commit:816219f
/////////////////////////////////////////////////////////////////////////
1:             setType( bindUserType( getTypeServices() ) );
1:             
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:bb5be6f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                        (byte) longValue,
/////////////////////////////////////////////////////////////////////////
1:                    (short) longValue,
/////////////////////////////////////////////////////////////////////////
1:                    (int) longValue,
1:                    longValue,
commit:9d9f6dd
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * The name of the target type if it's a UDT. It is partly redundant, as
1:      * the name can also be retrieved from the type descriptor. Additionally,
1:      * it contains information about the location of the UDT name in the
1:      * query text, which is useful if the query text needs to be rewritten.
1:      * (Useful for example when rewriting a CHECK constraint definition to
1:      * have fully qualified names before storing it in the dictionary.) This
1:      * field is only set for <b>explicit</b> casts to a UDT.
1:      */
1:     private TableName udtTargetName;
1: 
/////////////////////////////////////////////////////////////////////////
1:         // Set the schema name of the UDT target type.
1:         if (udtTargetName != null) {
1:             udtTargetName.setSchemaName(
1:                     getTypeId().getBaseTypeId().getSchemaName());
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:         if (udtTargetName != null)
1:         {
1:             udtTargetName = (TableName) udtTargetName.accept(v);
1:         }
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Set the target type name if this is a cast to a UDT.
1:      * @param name the name of the target type
1:      */
1:     void setTargetUDTName(TableName name) {
1:         udtTargetName = name;
1:     }
commit:35c061a
/////////////////////////////////////////////////////////////////////////
1: 
1:     /** The original, unbound descriptor for the target type, if it is a UDT. */
1:     private DataTypeDescriptor targetUDT;
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:         // DERBY-6421: setType() tries to bind user defined types. We don't
1:         // want to do any binding here, since we could be called during
1:         // parsing. If the target type is a UDT, just store it for now and
1:         // do the binding later when bindExpression() or bindCastNodeOnly()
1:         // is called.
1:         if (castTarget.getTypeId().isUserDefinedTypeId()) {
1:             targetUDT = castTarget;
1:         } else {
1:             setType(castTarget);
1:         }
/////////////////////////////////////////////////////////////////////////
1:         // Bind the target UDT.
1:         if (targetUDT != null) {
1:             setType(targetUDT);
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1:         // Bind the target UDT.
1:         if (targetUDT != null) {
1:             setType(targetUDT);
1:         }
commit:8fe3166
/////////////////////////////////////////////////////////////////////////
1:     void generateExpression(ExpressionClassBuilder acb, MethodBuilder mb)
commit:09c2697
/////////////////////////////////////////////////////////////////////////
1:      * @param aggregates        The aggregate list being built as we find AggregateNodes
0:     ValueNode bindExpression(FromList fromList, SubqueryList subqueryList, List aggregates)
1:                                 aggregates);
commit:f33fbaf
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
0: 									List aggregateVector)
commit:f903d9b
/////////////////////////////////////////////////////////////////////////
0: 					return (ValueNode) getNodeFactory().getNode(
commit:aebfb28
/////////////////////////////////////////////////////////////////////////
1: 		if (castOperand != null)
commit:dd2f5a8
/////////////////////////////////////////////////////////////////////////
1: 	 * Accept the visitor for all visitable children of this node.
1: 	void acceptChildren(Visitor v)
1: 		super.acceptChildren(v);
commit:4622bd1
/////////////////////////////////////////////////////////////////////////
commit:401938a
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.reference.Limits;
/////////////////////////////////////////////////////////////////////////
1: 				/*
1: 				 * Derby-1132 : The length for the target type was calculated
1: 				 * incorrectly while Char & Varchar functions were used. Thus
1: 				 * adding the check for Char & Varchar and calculating the
1: 				 * length based on the operand type.
1: 				 */
1: 				else if(srcTypeId.isStringTypeId())
1: 				{
1: 					length = opndType.getMaximumWidth();
1: 			
1: 					// Truncate the target type width to the max width of the
1: 					// data type
1: 					if (this.targetCharType == Types.CHAR)
1: 						length = Math.min(length, Limits.DB2_CHAR_MAXWIDTH);
1: 					else if (this.targetCharType == Types.VARCHAR)
1: 						length = Math.min(length, Limits.DB2_VARCHAR_MAXWIDTH);
1: 				}
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:2706d1f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     boolean isEquivalent(ValueNode o) throws StandardException
1:         if (isSameNodeKind(o)) {
1: 
commit:e1f49ca
/////////////////////////////////////////////////////////////////////////
1:     @Override @SuppressWarnings("fallthrough")
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Types;
0: import java.util.List;
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.reference.ClassName;
0: import org.apache.derby.iapi.reference.Limits;
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.services.classfile.VMOpcode;
1: import org.apache.derby.iapi.services.compiler.LocalField;
1: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1: import org.apache.derby.iapi.services.context.ContextManager;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
1: import org.apache.derby.iapi.sql.compile.TypeCompiler;
1: import org.apache.derby.iapi.sql.compile.Visitor;
1: import org.apache.derby.iapi.types.DataTypeDescriptor;
1: import org.apache.derby.iapi.types.DataTypeUtilities;
1: import org.apache.derby.iapi.types.DataValueDescriptor;
1: import org.apache.derby.iapi.types.TypeId;
1: import org.apache.derby.iapi.util.StringUtil;
1:  * An CastNode represents a cast expression.
1: class CastNode extends ValueNode
1:     /** This variable gets set by the parser to indicate that this CAST node
1:      * collation info of the current compilation schema for this node's
/////////////////////////////////////////////////////////////////////////
1:      * Constructor for a CastNode
1:      * @param cm            The context manager
1:     CastNode(ValueNode castOperand,
1:              DataTypeDescriptor castTarget,
1:              ContextManager cm) throws StandardException {
1:         super(cm);
0:         setNodeType(C_NodeTypes.CAST_NODE);
1:         this.castOperand = castOperand;
0:         setType(castTarget);
1:      * Constructor for a CastNode
1:      * @param cm            The context manager
1:     CastNode(ValueNode castOperand,
1:              int charType,
1:              int charLength,
1:              ContextManager cm) throws StandardException {
1:         super(cm);
0:         setNodeType(C_NodeTypes.CAST_NODE);
1:         this.castOperand = castOperand;
1:         int charLen = charLength;
1:         targetCharType = charType;
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     void printSubNodes(int depth)
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:             if (srcTypeId.isNumericTypeId())
1:             {
1:                 length = opndType.getPrecision() + 1; // 1 for the sign
1:                 if (opndType.getScale() > 0)
1:                     length += 1;               // 1 for the decimal .
1: 
1:             }
1:             /*
0:              * Derby-1132 : The length for the target type was calculated
0:              * incorrectly while Char & Varchar functions were used. Thus
0:              * adding the check for Char & Varchar and calculating the
0:              * length based on the operand type.
1:              */
0:             else if(srcTypeId.isStringTypeId())
1:             {
0:                 length = opndType.getMaximumWidth();
1: 
0:                 // Truncate the target type width to the max width of the
0:                 // data type
0:                 if (this.targetCharType == Types.CHAR)
0:                     length = Math.min(length, Limits.DB2_CHAR_MAXWIDTH);
0:                 else if (this.targetCharType == Types.VARCHAR)
0:                     length = Math.min(length, Limits.DB2_VARCHAR_MAXWIDTH);
1:             }
1:             else
1:             {
1:                 TypeId typeid = opndType.getTypeId();
1: 
1:                 if (length < 0) {
1:                     length = DataTypeUtilities.getColumnDisplaySize(
1:                         typeid.getJDBCTypeId(), -1);
1:                 }
1:             }
1: 
1:             if (length < 0)
1:                 length = 1;  // same default as in parser
/////////////////////////////////////////////////////////////////////////
1:                        retNode = new CharConstantNode(
1:                                 booleanString,
1:                                 getTypeServices().getMaximumWidth(),
1:                                 getContextManager());
/////////////////////////////////////////////////////////////////////////
1:                            retNode = new CharConstantNode(
1:                                castValue,
1:                                getTypeServices().getMaximumWidth(),
1:                                getContextManager());
/////////////////////////////////////////////////////////////////////////
1:     void bindCastNodeOnly()
/////////////////////////////////////////////////////////////////////////
1:                    return new BooleanConstantNode(true, getContextManager());
1:                    return new BooleanConstantNode(false, getContextManager());
1:                    return new BooleanConstantNode(getContextManager());
/////////////////////////////////////////////////////////////////////////
1:                return new UserTypeConstantNode(
1:                return new UserTypeConstantNode(
1:                return new UserTypeConstantNode(
/////////////////////////////////////////////////////////////////////////
1:                return new NumericConstantNode(
1:                        TypeId.getBuiltInTypeId(Types.REAL),
1:                        floatValue,
1:                        getContextManager());
/////////////////////////////////////////////////////////////////////////
1:                return new NumericConstantNode(
1:                        TypeId.getBuiltInTypeId(Types.DOUBLE),
1:                        doubleValue,
1:                        getContextManager());
/////////////////////////////////////////////////////////////////////////
1:                return new CharConstantNode(
1:                         Long.toString(longValue),
1:                         getTypeServices().getMaximumWidth(),
1:                         getContextManager());
1:                return new NumericConstantNode(
1:                        TypeId.getBuiltInTypeId(Types.TINYINT),
0:                        ReuseFactory.getByte((byte) longValue),
1:                        getContextManager());
/////////////////////////////////////////////////////////////////////////
1:                return new NumericConstantNode(
1:                    TypeId.getBuiltInTypeId(destJDBCTypeId),
0:                    ReuseFactory.getShort(
0:                        (short) longValue),
1:                    getContextManager());
/////////////////////////////////////////////////////////////////////////
1:                return new NumericConstantNode(
1:                    TypeId.getBuiltInTypeId(destJDBCTypeId),
0:                    ReuseFactory.getInteger(
0:                        (int) longValue),
1:                    getContextManager());
1:                return new NumericConstantNode(
1:                    TypeId.getBuiltInTypeId(destJDBCTypeId),
0:                    ReuseFactory.getLong(longValue),
1:                    getContextManager());
1:                return new NumericConstantNode(
1:                    TypeId.getBuiltInTypeId(destJDBCTypeId),
0:                    new Float((float) longValue),
1:                    getContextManager());
1:                return new NumericConstantNode(
1:                    TypeId.getBuiltInTypeId(destJDBCTypeId),
0:                    new Double((double) longValue),
1:                    getContextManager());
/////////////////////////////////////////////////////////////////////////
1:                return new CharConstantNode(
1:                         constantValue.getString(),
1:                         getTypeServices().getMaximumWidth(),
1:                         getContextManager());
1:                 return new NumericConstantNode(
1:                         TypeId.getBuiltInTypeId(destJDBCTypeId),
1:                         Byte.valueOf(constantValue.getByte()),
1:                         getContextManager());
1:                 return new NumericConstantNode(
1:                         TypeId.getBuiltInTypeId(destJDBCTypeId),
1:                         Short.valueOf(constantValue.getShort()),
1:                         getContextManager());
1:                 return new NumericConstantNode(
1:                         TypeId.getBuiltInTypeId(destJDBCTypeId),
1:                         Integer.valueOf(constantValue.getInt()),
1:                         getContextManager());
1:                 return new NumericConstantNode(
1:                         TypeId.getBuiltInTypeId(destJDBCTypeId),
1:                         Long.valueOf(constantValue.getLong()),
1:                         getContextManager());
1:                 return new NumericConstantNode(
1:                         TypeId.getBuiltInTypeId(destJDBCTypeId),
1:                         Float.valueOf(NumberDataType.normalizeREAL(
1:                                       constantValue.getDouble())),
1:                         getContextManager());
1:                 return new NumericConstantNode(
1:                         TypeId.getBuiltInTypeId(destJDBCTypeId),
1:                        Double.valueOf(constantValue.getDouble()),
1:                         getContextManager());
1:         return this;
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     ValueNode preprocess(int numTables,
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     boolean categorize(JBitSet referencedTabs, boolean simplePredsOnly)
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     ValueNode remapColumnReferencesToExpressions()
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     boolean isConstantExpression()
1:     @Override
1:     boolean constantExpression(PredicateList whereClause)
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
0:     @Override
commit:eff9169
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Method calls:
1:      * Argument type has the same semantics as assignment:
1:      * Section 9.2 (Store assignment). There, General Rule
1:      * 2.b.v.2 says that the database should raise an exception
1:      * if truncation occurs when stuffing a string value into a
1:      * VARCHAR, so make sure CAST doesn't issue warning only.
1:      */
1:     private boolean assignmentSemantics = false;
1: 
/////////////////////////////////////////////////////////////////////////
1:             mb.push(!sourceCTI.variableLength() ||
1:                     isNumber ||
1:                     assignmentSemantics);
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Set assignmentSemantics to true. Used by method calls for casting actual
1:      * arguments
1:      */
1:     void setAssignmentSemantics()
1:     {
1:         assignmentSemantics = true;
1:     }
1: 
1:     
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:1a4ea31
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 				case Types.BOOLEAN:
1: 					if (destJDBCTypeId == Types.BIT || destJDBCTypeId == Types.BOOLEAN)
/////////////////////////////////////////////////////////////////////////
1: 			case Types.BOOLEAN:
commit:9ed7c4d
/////////////////////////////////////////////////////////////////////////
1: 			setCollationUsingCompilationSchema();
commit:50a8c62
/////////////////////////////////////////////////////////////////////////
1: 		}	
1: 		
1: 		// Preserve the nullability of the operand since a CAST
0: 		// of a non-NULL value is also non-NULL.
0: 		setNullability(castOperand.getTypeServices().isNullable());
commit:ed82406
/////////////////////////////////////////////////////////////////////////
1: 	    if (SanityManager.DEBUG)
1: 	    {
1: 	        return "castTarget: " + getTypeServices() + "\n" +
1: 	        super.toString();
1: 	    }
1: 	    else
1: 	    {
1: 	        return "";
1: 	    }
commit:ac12b1f
/////////////////////////////////////////////////////////////////////////
1:         // Obviously the type of a parameter that
1:         // requires its type from context (a parameter)
1:         // gets its type from the type of the CAST.
1:             castOperand.setType(getTypeServices());
/////////////////////////////////////////////////////////////////////////
commit:d5ce63a
/////////////////////////////////////////////////////////////////////////
1: 	private int					targetCharType;
1: 	private boolean forDataTypeFunction = false;
1:     
/////////////////////////////////////////////////////////////////////////
1: 	private boolean externallyGeneratedCastNode = false;
/////////////////////////////////////////////////////////////////////////
0: 		setType((DataTypeDescriptor) castTarget);
/////////////////////////////////////////////////////////////////////////
1: 		setType(DataTypeDescriptor.getBuiltInDataTypeDescriptor(targetCharType, charLen));
/////////////////////////////////////////////////////////////////////////
0: 			try {
0:                 return "castTarget: " + getTypeServices() + "\n" +
0:                 	super.toString();
0:             } catch (StandardException e) {
0:                 // TEMP - getTypeServices() should not be throwing an exception
0:                 return "";
1:             }
/////////////////////////////////////////////////////////////////////////
1: 		if (getTypeServices() == null)   //CHAR or VARCHAR function without specifying target length
/////////////////////////////////////////////////////////////////////////
1: 			setType(DataTypeDescriptor.getBuiltInDataTypeDescriptor(targetCharType, length));
/////////////////////////////////////////////////////////////////////////
1: 			castOperand.setType(getTypeServices());
/////////////////////////////////////////////////////////////////////////
1: 			int		  destJDBCTypeId = getTypeId().getJDBCTypeId();
/////////////////////////////////////////////////////////////////////////
0:                                                     getTypeServices().getMaximumWidth()),
/////////////////////////////////////////////////////////////////////////
0:                                                         getTypeServices().getMaximumWidth()),
/////////////////////////////////////////////////////////////////////////
1: 		if (externallyGeneratedCastNode && getTypeId().isStringTypeId()) {
/////////////////////////////////////////////////////////////////////////
1: 		if (getTypeId().userType())
0: 			setType(new DataTypeDescriptor(TypeId.getUserDefinedTypeId(className, false),
0: 													));
/////////////////////////////////////////////////////////////////////////
1: 			if (! tc.convertible(getTypeId(), forDataTypeFunction))
1:                         getTypeId().getSQLTypeName());
/////////////////////////////////////////////////////////////////////////
0:                                                 getTypeServices().getMaximumWidth()),
/////////////////////////////////////////////////////////////////////////
0:                                                 getTypeServices().getMaximumWidth()),
/////////////////////////////////////////////////////////////////////////
0: 		castOperand.setType(getTypeServices());
/////////////////////////////////////////////////////////////////////////
1:                 getTypeId().getCorrespondingJavaTypeName()))
/////////////////////////////////////////////////////////////////////////
1: 			sourceCTI = getTypeId();
/////////////////////////////////////////////////////////////////////////
1: 		acb.generateNull(acbConstructor, getTypeCompiler(getTypeId()), 
1:                 getTypeServices().getCollationType());
/////////////////////////////////////////////////////////////////////////
1: 		if (!sourceCTI.userType() && !getTypeId().userType()) {
/////////////////////////////////////////////////////////////////////////
1: 		if (getTypeId().variableLength()) 
1: 			boolean isNumber = getTypeId().isNumericTypeId();
/////////////////////////////////////////////////////////////////////////
1: 			mb.push(isNumber ? getTypeServices().getPrecision() : getTypeServices().getMaximumWidth());
1: 			mb.push(getTypeServices().getScale());
/////////////////////////////////////////////////////////////////////////
1: 	void setForExternallyGeneratedCASTnode()
/////////////////////////////////////////////////////////////////////////
1: 	void setForDataTypeFunction(boolean b)
/////////////////////////////////////////////////////////////////////////
1: 			return getTypeServices().equals(other.getTypeServices())
commit:ef158f2
/////////////////////////////////////////////////////////////////////////
1: 			String className = getTypeId().getCorrespondingJavaTypeName();
commit:2e1b5e8
/////////////////////////////////////////////////////////////////////////
0: 			String className = dataTypeServices.getTypeId().getCorrespondingJavaTypeName();
1: 			verifyClassExist(className);
commit:01217c2
/////////////////////////////////////////////////////////////////////////
1:         
1: 	/**
1: 	 * {@inheritDoc}
1: 	 * @throws StandardException 
1: 	 */
0: 	protected boolean isEquivalent(ValueNode o) throws StandardException
1: 	{
0: 		if (isSameNodeType(o)) 
1: 		{
1: 			CastNode other = (CastNode)o;
0: 			return castTarget.equals(other.castTarget)
1: 				&& castOperand.isEquivalent(other.castOperand);
1: 		}
1: 		return false;
1: 	}
commit:806114c
/////////////////////////////////////////////////////////////////////////
1: 			
1: 			For source or destination java types generate
1: 			
1: 			Object o = sourceDVD.getObject();
1: 			targetDVD.setObjectForCast(o, o instanceof dest java type, dest java type);
0: 		if (!sourceCTI.userType() && !destCTI.userType()) {
1: 			mb.getField(field); // targetDVD reference for the setValue method call
1: 			mb.swap();
1: 			mb.upCast(ClassName.DataValueDescriptor);
1: 			mb.callMethod(VMOpcode.INVOKEINTERFACE, ClassName.DataValueDescriptor,
1: 					"setValue", "void", 1);
1: 		else
1: 			/* 
1: 			** generate: expr.getObject()
1: 			*/
1: 			mb.callMethod(VMOpcode.INVOKEINTERFACE, ClassName.DataValueDescriptor,
1: 					"getObject", "java.lang.Object", 0);
1: 			//castExpr
1: 			mb.getField(field); // instance for the setValue/setObjectForCast method call
1: 			mb.swap(); // push it before the value
1: 			/*
1: 			** We are casting a java type, generate:
1: 			**
1: 			**		DataValueDescriptor.setObjectForCast(java.lang.Object castExpr, boolean instanceOfExpr, destinationClassName)
1: 			** where instanceOfExpr is "source instanceof destinationClass".
1: 			**
1: 			*/
/////////////////////////////////////////////////////////////////////////
1: 			mb.callMethod(VMOpcode.INVOKEINTERFACE, ClassName.DataValueDescriptor,
1: 					"setObjectForCast", "void", 3);
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 			
1: 			// to leave the DataValueDescriptor value on the stack, since setWidth is void
1: 			mb.dup();
1: 			
1: 			mb.callMethod(VMOpcode.INVOKEINTERFACE, ClassName.VariableSizeDataValue,
1: 					"setWidth", "void", 3);
commit:08d6ce2
/////////////////////////////////////////////////////////////////////////
0: 		if (destCTI.userType())
/////////////////////////////////////////////////////////////////////////
commit:afa871e
/////////////////////////////////////////////////////////////////////////
1: 		acbConstructor.setField(field);
commit:509ccb9
/////////////////////////////////////////////////////////////////////////
1: 					case Types.DECIMAL:
1: 						// ignore decimal -> decimal casts for now
1: 						if (destJDBCTypeId == Types.DECIMAL ||
1: 							destJDBCTypeId == Types.NUMERIC)
1: 							break;
1: 						// fall through
1: 						retNode = getCastFromNumericType(
1: 											((ConstantNode) castOperand).getValue(), 
/////////////////////////////////////////////////////////////////////////
1: 	private ValueNode getCastFromNumericType(
1: 									  DataValueDescriptor constantValue, 
0: 		int nodeType = -1;
0: 		Object constantObject = null;
0: 				nodeType = C_NodeTypes.CHAR_CONSTANT_NODE;
0: 				constantObject = constantValue.getString();
0: 										nodeType,
0: 										constantObject, 
1: 
0: 				nodeType = C_NodeTypes.TINYINT_CONSTANT_NODE;
0: 				constantObject = new Byte(constantValue.getByte());
1: 				break;
0: 				nodeType = C_NodeTypes.SMALLINT_CONSTANT_NODE;
0: 				constantObject = ReuseFactory.getShort(constantValue.getShort());
1: 				break;
0: 				nodeType = C_NodeTypes.INT_CONSTANT_NODE;
0: 				constantObject = ReuseFactory.getInteger(constantValue.getInt());
1: 				break;
0: 				nodeType = C_NodeTypes.LONGINT_CONSTANT_NODE;
0: 				constantObject = ReuseFactory.getLong(constantValue.getLong());
1: 				break;
0: 				nodeType = C_NodeTypes.FLOAT_CONSTANT_NODE;
0: 				constantObject = new Float(NumberDataType.normalizeREAL(constantValue.getDouble()));
1: 				break;
1: 				// no need to normalize here because no constant could be out of range for a double
0: 				nodeType = C_NodeTypes.DOUBLE_CONSTANT_NODE;
0: 				constantObject = new Double(constantValue.getDouble());
1: 				break;
0: 		if (nodeType == -1)
1: 			return this;
1: 
1: 
0: 		return (ValueNode) getNodeFactory().getNode(
0: 										nodeType,
0: 										constantObject, 
1: 										getContextManager());
1: 
commit:3d77775
/////////////////////////////////////////////////////////////////////////
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.compile.CastNode
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:61070a6
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package	org.apache.derby.impl.sql.compile;
1: 
0: import org.apache.derby.iapi.services.context.ContextManager;
1: 
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
0: import org.apache.derby.iapi.services.compiler.LocalField;
1: 
0: import org.apache.derby.iapi.services.monitor.Monitor;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
0: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1: 
0: import org.apache.derby.iapi.sql.compile.CompilerContext;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
1: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1: 
0: import org.apache.derby.iapi.types.DataTypeUtilities;
0: import org.apache.derby.iapi.types.TypeId;
1: 
0: import org.apache.derby.iapi.reference.SQLState;
1: 
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: import org.apache.derby.iapi.types.DataValueFactory;
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.types.VariableSizeDataValue;
1: 
0: import org.apache.derby.iapi.sql.compile.TypeCompiler;
1: 
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.util.StringUtil;
1: 
0: import org.apache.derby.iapi.reference.ClassName;
0: import org.apache.derby.iapi.reference.JDBC30Translation;
0: import org.apache.derby.iapi.services.classfile.VMOpcode;
1: 
0: import org.apache.derby.iapi.types.DataValueDescriptor;
1: 
0: import org.apache.derby.iapi.services.loader.ClassInspector;
1: 
0: import org.apache.derby.iapi.sql.compile.Visitable;
0: import org.apache.derby.iapi.sql.compile.Visitor;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
1: 
1: import java.lang.reflect.Modifier;
1: 
0: import org.apache.derby.impl.sql.compile.ExpressionClassBuilder;
1: import org.apache.derby.iapi.types.NumberDataType;
1: 
1: import org.apache.derby.iapi.util.JBitSet;
0: import org.apache.derby.iapi.util.ReuseFactory;
1: 
0: import org.apache.derby.catalog.AliasInfo;
0: import org.apache.derby.catalog.TypeDescriptor;
1: 
0: import org.apache.derby.iapi.types.SQLReal;
1: 
0: import java.math.BigDecimal;
1: 
0: import java.sql.Date;
0: import java.sql.Time;
0: import java.sql.Timestamp;
0: import java.sql.Types;
1: 
0: import java.util.Vector;
1: 
1: /**
0:  * An CastNode represents a cast expressionr.
1:  *
0:  * @author Jerry Brenner
1:  */
1: 
0: public class CastNode extends ValueNode
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	DataTypeDescriptor	castTarget;
1: 	ValueNode			castOperand;
0: 	int					targetCharType;
0: 	TypeId	destCTI = null;
1: 	TypeId	sourceCTI = null;
0: 	boolean forDataTypeFunction = false;
1: 
1: 	/*
1: 	** Static array of valid casts.  Dimentions
1: 	** produce a single boolean which indicates
1: 	** whether the case is possible or not.
1: 	*/
1: 
1: 	/**
0: 	 * Initializer for a CastNode
1: 	 *
1: 	 * @param castOperand	The operand of the node
1: 	 * @param castTarget	DataTypeServices (target type of cast)
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public void init(Object castOperand, Object castTarget)
1: 		throws StandardException
1: 	{
0: 		this.castOperand = (ValueNode) castOperand;
0: 		this.castTarget = (DataTypeDescriptor) castTarget;
1: 	}
1: 
1: 	/**
0: 	 * Initializer for a CastNode
1: 	 *
1: 	 * @param castOperand	The operand of the node
1: 	 * @param charType		CHAR or VARCHAR JDBC type as target
1: 	 * @param charLength	target type length
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public void init(Object castOperand, Object charType, Object charLength)
1: 		throws StandardException
1: 	{
0: 		this.castOperand = (ValueNode) castOperand;
0: 		int charLen = ((Integer) charLength).intValue();
0: 		targetCharType = ((Integer) charType).intValue();
1: 		if (charLen < 0)	// unknown, figure out later
1: 			return;
0: 		this.castTarget = DataTypeDescriptor.getBuiltInDataTypeDescriptor(targetCharType, charLen);
1: 	}
1: 
1: 	/**
1: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
1: 	 * for how this should be done for tree printing.
1: 	 *
1: 	 * @return		This object as a String
1: 	 */
1: 
1: 	public String toString()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			return "castTarget: " + castTarget + "\n" +
0: 				super.toString();
1: 		}
1: 		else
1: 		{
0: 			return "";
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
1: 	 * how tree printing is supposed to work.
1: 	 *
1: 	 * @param depth		The depth of this node in the tree
1: 	 *
0: 	 * @return	Nothing
1: 	 */
1: 
0: 	public void printSubNodes(int depth)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			super.printSubNodes(depth);
1: 
1: 			if (castOperand != null)
1: 			{
1: 				printLabel(depth, "castOperand: ");
1: 				castOperand.treePrint(depth + 1);
1: 			}
1: 		}
1: 	}
1: 	protected int getOrderableVariantType() throws StandardException
1: 	{
1: 		return castOperand.getOrderableVariantType();
1: 	}
1: 
1: 	/**
0: 	 * Set the clause that this node appears in.
1: 	 *
0: 	 * @param clause	The clause that this node appears in.
1: 	 *
0: 	 * @return Nothing.
1: 	 */
0: 	public void setClause(int clause)
1: 	{
0: 		super.setClause(clause);
0: 		castOperand.setClause(clause);
1: 	}
1: 
1: 	/**
1: 	 * Bind this expression.  This means binding the sub-expressions,
1: 	 * as well as figuring out what the return type is for this expression.
1: 	 *
1: 	 * @param fromList		The FROM list for the query this
1: 	 *				expression is in, for binding columns.
1: 	 * @param subqueryList		The subquery list being built as we find SubqueryNodes
0: 	 * @param aggregateVector	The aggregate vector being built as we find AggregateNodes
1: 	 *
1: 	 * @return	The new top of the expression tree.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public ValueNode bindExpression(FromList fromList, SubqueryList subqueryList,
0: 									Vector aggregateVector)
1: 				throws StandardException
1: 	{
1: 		castOperand = castOperand.bindExpression(
1: 								fromList, subqueryList,
0: 								aggregateVector);
1: 
0: 		if (castTarget == null)   //CHAR or VARCHAR function without specifying target length
1: 		{
1: 			DataTypeDescriptor opndType = castOperand.getTypeServices();
1: 			int length = -1;
1: 			TypeId srcTypeId = opndType.getTypeId();
0: 			if (opndType != null)
1: 			{
0: 				if (srcTypeId.isNumericTypeId())
1: 				{
0: 					length = opndType.getPrecision() + 1; // 1 for the sign
0: 					if (opndType.getScale() > 0)
0: 						length += 1;               // 1 for the decimal .
1: 				 
1: 				}
1: 				else 
1: 				{
0: 					TypeId typeid = opndType.getTypeId();
0: 					if (length < 0)
0: 						length = DataTypeUtilities.getColumnDisplaySize(typeid.getJDBCTypeId(),-1);
1: 
1: 				}
1: 			}
0: 			if (length < 0)
0: 				length = 1;  // same default as in parser
0: 			castTarget = DataTypeDescriptor.getBuiltInDataTypeDescriptor(targetCharType, length);
1: 			
1: 		}
1: 
1: 		/* 
1: 		** If castOperand is an untyped null, 
1: 		** then we must set the type.
1: 		*/
1: 		if (castOperand instanceof UntypedNullConstantNode)
1: 		{
0: 			castOperand.setType(castTarget);
1: 		}
1: 
1: 		bindCastNodeOnly();
1: 		
1: 		/* We can't chop out cast above an untyped null because
1: 		 * the store can't handle it.
1: 		 */
1: 		if ((castOperand instanceof ConstantNode) &&
1: 			!(castOperand instanceof UntypedNullConstantNode))
1: 		{
1: 			/* If the castOperand is a typed constant then we do the cast at
1: 			 * bind time and return a constant of the correct type.
1: 			 * NOTE: This could return an exception, but we're prepared to 
1: 			 * deal with that. (NumberFormatException, etc.)
1: 			 * We only worry about the easy (and useful)
1: 			 * converions at bind time.
1: 			 * Here's what we support:
1: 			 *			source					destination
1: 			 *			------					-----------
1: 			 *			boolean					boolean
1: 			 *			boolean					char
1: 			 *			char					boolean
1: 			 *			char					date/time/ts
1: 			 *			char					non-decimal numeric
1: 			 *			date/time/ts			char
1: 			 *			numeric					char
1: 			 *			numeric					non-decimal numeric
1: 			 */
1: 			/* RESOLVE - to be filled in. */
1: 			ValueNode retNode = this;
1: 			int		  sourceJDBCTypeId = sourceCTI.getJDBCTypeId();
0: 			int		  destJDBCTypeId = destCTI.getJDBCTypeId();
1: 
1: 			switch (sourceJDBCTypeId)
1: 			{
1: 				case Types.BIT:
0: 				case JDBC30Translation.SQL_TYPES_BOOLEAN:
1: 					// (BIT is boolean)
0: 					if (destJDBCTypeId == Types.BIT || destJDBCTypeId == JDBC30Translation.SQL_TYPES_BOOLEAN)
1: 					{
1: 						retNode = castOperand;
1: 					}
1: 					else if (destJDBCTypeId == Types.CHAR)
1: 					{
1: 						BooleanConstantNode bcn = (BooleanConstantNode) castOperand;
1: 						String booleanString = bcn.getValueAsString();
0: 						retNode = (ValueNode) getNodeFactory().getNode(
0: 											C_NodeTypes.CHAR_CONSTANT_NODE,
0: 											booleanString,
0: 											ReuseFactory.getInteger(
0: 												castTarget.getMaximumWidth()),
1: 											getContextManager());
1: 					}
0: 					break;
1: 
1: 					case Types.CHAR:
1: 						retNode = getCastFromCharConstant(destJDBCTypeId);
0: 						break;
1: 
1: 					case Types.DATE:
1: 					case Types.TIME:
1: 					case Types.TIMESTAMP:
1: 						if (destJDBCTypeId == Types.CHAR)
1: 						{
1: 							String castValue =  
1: 								((UserTypeConstantNode) castOperand).
1: 											getObjectValue().
1: 												toString();
0: 							retNode = (ValueNode) getNodeFactory().getNode(
0: 												C_NodeTypes.CHAR_CONSTANT_NODE,
0: 												castValue, 
0: 												ReuseFactory.getInteger(
0: 												  castTarget.getMaximumWidth()),
1: 												getContextManager());
1: 						}
0: 						break;
1: 
1: 					case Types.TINYINT:
1: 					case Types.SMALLINT:
1: 					case Types.INTEGER:
1: 					case Types.BIGINT:
0: 						long longValue = ((NumericConstantNode) castOperand).getLong();
0: 						retNode = getCastFromIntegralType(
0: 											longValue, 
1: 											destJDBCTypeId);
0: 						break;
1: 
1: 					case Types.DOUBLE:
1: 					case Types.REAL:
0: 						double doubleValue = ((NumericConstantNode) castOperand).getDouble();
0: 						retNode = getCastFromNonIntegralType(
0: 											doubleValue, 
1: 											destJDBCTypeId);
0: 						break;
1: 
0: 					case Types.DECIMAL:
0: 						// ignore decimal -> decimal casts for now
0: 						if (destJDBCTypeId != Types.DECIMAL &&
0: 							destJDBCTypeId != Types.NUMERIC)
1: 						{
0: 							/* SQLDecimal.getDouble() throws an exception if the
0: 							 * BigDecimal is outside of the range of double.
1: 							 */
0: 							doubleValue = ((ConstantNode) castOperand).getValue().getDouble();
0: 							retNode = getCastFromNonIntegralType(
0: 												doubleValue, 
1: 												destJDBCTypeId);
1: 						}
0: 						break;
1: 			}
1: 
1: 			// Return the new constant if the cast was performed
1: 			return retNode;
1: 		}
1: 
1: 		return this;
1: 	}
1: 
1: 	/**
1: 	 * Bind this node but not its child.  Caller has already bound
1: 	 * the child.
1: 	 * This is useful for when we generate a CastNode during binding
1: 	 * after having already bound the child.
1: 	 *
0: 	 * @return	Nothing
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public void bindCastNodeOnly()
1: 		throws StandardException
1: 	{
1: 
1: 		/*
1: 		** The result type is always castTarget.
1: 		*/
0: 		setType(castTarget);
0: 		destCTI = castTarget.getTypeId();
1: 		sourceCTI = castOperand.getTypeId();
1: 
1: 		/* 
1: 		** If it is a java cast, do some work to make sure
1: 		** the classes are ok and that they are compatible
1: 		*/
0: 		if (! destCTI.systemBuiltIn())
1: 		{
0: 			String className = ((TypeId) dataTypeServices.getTypeId()).getCorrespondingJavaTypeName();
1: 
0: 			boolean convertCase = ! destCTI.getClassNameWasDelimitedIdentifier();
1: 
0: 			className = verifyClassExist(className, convertCase);
1: 
0: 			castTarget = new DataTypeDescriptor(TypeId.getUserDefinedTypeId(className, false),
0: 														true /* assume nullable for now, change it if not nullable */
0: 													);
0: 			setType(castTarget);
0: 			destCTI = castTarget.getTypeId();
1: 		}
1: 
0: 		if (castOperand.isParameterNode())
1: 		{
0: 			bindParameter();
1: 		}
1: 
1: 		/*
1: 		** If it isn't null, then we have
1: 		** a cast from one JBMS type to another.  So we
1: 		** have to figure out if it is legit.
1: 		*/
1: 		else if (!(castOperand instanceof UntypedNullConstantNode))
1: 		{
1: 			/*
1: 			** Make sure we can assign the two classes
1: 			*/
1: 			TypeCompiler tc = castOperand.getTypeCompiler();
0: 			if (! tc.convertible(destCTI, forDataTypeFunction))
1: 			{
1: 				throw StandardException.newException(SQLState.LANG_INVALID_CAST, 
1: 						sourceCTI.getSQLTypeName(),
0: 						destCTI.getSQLTypeName());
1: 			}
1: 		}		
1: 	}
1: 
1: 	/**
1: 	 * Get a constant representing the cast from a CHAR to another
1: 	 * type.  If this is not an "easy" cast to perform, then just
1: 	 * return this cast node.
1: 	 * Here's what we think is "easy":
1: 	 *			source			destination
1: 	 *			------			-----------
1: 	 *			char			boolean
1: 	 *			char			date/time/ts
1: 	 *			char			non-decimal numeric
1: 	 *
1: 	 * @param destJDBCTypeId	The destination JDBC TypeId
1: 	 *
1: 	 * @return The new top of the tree (this CastNode or a new Constant)
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	private ValueNode getCastFromCharConstant(int destJDBCTypeId)
1: 		throws StandardException
1: 	{
1: 		String	  charValue = ((CharConstantNode) castOperand).getString();
1: 		String	  cleanCharValue = StringUtil.SQLToUpperCase(charValue.trim());
1: 		ValueNode retNode = this;
1: 
1: 		switch (destJDBCTypeId)
1: 		{
1: 			case Types.BIT:
0: 			case JDBC30Translation.SQL_TYPES_BOOLEAN:
1: 				if (cleanCharValue.equals("TRUE"))
1: 				{
0: 					return (ValueNode) getNodeFactory().getNode(
0: 											C_NodeTypes.BOOLEAN_CONSTANT_NODE,
0: 											Boolean.TRUE,
1: 											getContextManager());
1: 				}
1: 				else if (cleanCharValue.equals("FALSE"))
1: 				{
0: 					return (ValueNode) getNodeFactory().getNode(
0: 											C_NodeTypes.BOOLEAN_CONSTANT_NODE,
0: 											Boolean.FALSE,
1: 											getContextManager());
1: 				}
1: 				else
1: 				{
1: 					throw StandardException.newException(SQLState.LANG_FORMAT_EXCEPTION, "boolean");
1: 				}
1: 
1: 			case Types.DATE:
0: 				return (ValueNode) getNodeFactory().getNode(
0: 										C_NodeTypes.USERTYPE_CONSTANT_NODE,
1: 										getDataValueFactory().getDateValue(cleanCharValue, false),
1: 										getContextManager());
1: 
1: 			case Types.TIMESTAMP:
0: 				return (ValueNode) getNodeFactory().getNode(
0: 									C_NodeTypes.USERTYPE_CONSTANT_NODE,
1: 									getDataValueFactory().getTimestampValue(cleanCharValue, false),
1: 									getContextManager());
1: 
1: 			case Types.TIME:
0: 				return (ValueNode) getNodeFactory().getNode(
0: 										C_NodeTypes.USERTYPE_CONSTANT_NODE,
1: 										getDataValueFactory().getTimeValue(cleanCharValue, false),
1: 										getContextManager());
1: 
1: 			case Types.TINYINT:
1: 			case Types.SMALLINT:
1: 			case Types.INTEGER:
1: 			case Types.BIGINT:				
1: 				try 
1: 				{
1: 					// #3756 - Truncate decimal portion for casts to integer
0: 					return getCastFromIntegralType((new Double(cleanCharValue)).longValue(),
1: 												   destJDBCTypeId);
1: 				}
1: 				catch (NumberFormatException nfe)
1: 				{
1: 					String sqlName = TypeId.getBuiltInTypeId(destJDBCTypeId).getSQLTypeName();
1: 					throw StandardException.newException(SQLState.LANG_FORMAT_EXCEPTION, sqlName);
1: 				}
1: 			case Types.REAL:
1: 				Float floatValue;
1: 				try
1: 				{
1: 					floatValue = Float.valueOf(cleanCharValue);
1: 				}
1: 				catch (NumberFormatException nfe)
1: 				{
1: 					throw StandardException.newException(SQLState.LANG_FORMAT_EXCEPTION, "float");
1: 				}
0: 				return (ValueNode) getNodeFactory().getNode(
0: 											C_NodeTypes.FLOAT_CONSTANT_NODE,
0: 											floatValue,
1: 											getContextManager());
1: 			case Types.DOUBLE:
1: 				Double doubleValue;
1: 				try
1: 				{
0: 					doubleValue = new Double(cleanCharValue);
1: 				}
1: 				catch (NumberFormatException nfe)
1: 				{
1: 					throw StandardException.newException(SQLState.LANG_FORMAT_EXCEPTION, "double");
1: 				}
0: 				return (ValueNode) getNodeFactory().getNode(
0: 											C_NodeTypes.DOUBLE_CONSTANT_NODE,
0: 											doubleValue,
1: 											getContextManager());
1: 		}
1: 
1: 		return retNode;
1: 	}
1: 
1: 
1: 	/**
1: 	 * Get a constant representing the cast from an integral type to another
1: 	 * type.  If this is not an "easy" cast to perform, then just
1: 	 * return this cast node.
1: 	 * Here's what we think is "easy":
1: 	 *			source				destination
1: 	 *			------				-----------
1: 	 *			integral type		 non-decimal numeric
1: 	 *			integral type		 char
1: 	 *
1: 	 * @param longValue			integral type as a long to cast from
1: 	 * @param destJDBCTypeId	The destination JDBC TypeId
1: 	 *
1: 	 * @return The new top of the tree (this CastNode or a new Constant)
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	private ValueNode getCastFromIntegralType(
1: 									  long longValue, 
1: 									  int destJDBCTypeId)
1: 		throws StandardException
1: 	{
1: 		ValueNode retNode = this;
1: 
1: 		switch (destJDBCTypeId)
1: 		{
1: 			case Types.CHAR:
0: 				return (ValueNode) getNodeFactory().getNode(
0: 										C_NodeTypes.CHAR_CONSTANT_NODE,
0: 										Long.toString(longValue), 
0: 										ReuseFactory.getInteger(
0: 											castTarget.getMaximumWidth()),
1: 										getContextManager());
1: 			case Types.TINYINT:
1: 				if (longValue < Byte.MIN_VALUE ||
1: 					longValue > Byte.MAX_VALUE)
1: 				{
1: 					throw StandardException.newException(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, "TINYINT");
1: 				}
0: 				return (ValueNode) getNodeFactory().getNode(
0: 										C_NodeTypes.TINYINT_CONSTANT_NODE,
0: 										ReuseFactory.getByte((byte) longValue),
1: 										getContextManager());
1: 
1: 			case Types.SMALLINT:
1: 				if (longValue < Short.MIN_VALUE ||
1: 					longValue > Short.MAX_VALUE)
1: 				{
1: 					throw StandardException.newException(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, "SHORT");
1: 				}
0: 				return (ValueNode) getNodeFactory().getNode(
0: 											C_NodeTypes.SMALLINT_CONSTANT_NODE,
0: 											ReuseFactory.getShort(
0: 															(short) longValue),
1: 											getContextManager());
1: 
1: 			case Types.INTEGER:
1: 				if (longValue < Integer.MIN_VALUE ||
1: 					longValue > Integer.MAX_VALUE)
1: 				{
1: 					throw StandardException.newException(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, "INTEGER");
1: 				}
0: 				return (ValueNode) getNodeFactory().getNode(
0: 												C_NodeTypes.INT_CONSTANT_NODE,
0: 												ReuseFactory.getInteger(
0: 															(int) longValue),
1: 												getContextManager());
1: 
1: 			case Types.BIGINT:
0: 				return (ValueNode) getNodeFactory().getNode(
0: 								C_NodeTypes.LONGINT_CONSTANT_NODE,
0: 								ReuseFactory.getLong(longValue),
1: 								getContextManager());
1: 
1: 			case Types.REAL:
1: 				if (Math.abs(longValue) > Float.MAX_VALUE)
1: 				{
1: 					throw StandardException.newException(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, "REAL");
1: 				}
0: 				return (ValueNode) getNodeFactory().getNode(
0: 											C_NodeTypes.FLOAT_CONSTANT_NODE,
0: 											new Float((float) longValue),
1: 											getContextManager());
1: 
1: 			case Types.DOUBLE:
0: 				return (ValueNode) getNodeFactory().getNode(
0: 									C_NodeTypes.DOUBLE_CONSTANT_NODE,
0: 									new Double((double) longValue),
1: 									getContextManager());
1: 		}
1: 
1: 		return retNode;
1: 	}
1: 
1: 	/**
1: 	 * Get a constant representing the cast from a non-integral type to another
1: 	 * type.  If this is not an "easy" cast to perform, then just
1: 	 * return this cast node.
1: 	 * Here's what we think is "easy":
1: 	 *			source				destination
1: 	 *			------				-----------
1: 	 *			non-integral type	 non-decimal numeric
1: 	 *			non-integral type	 char
1: 	 *
0: 	 * @param doubleValue		non-integral type a a double to cast from
1: 	 * @param destJDBCTypeId	The destination JDBC TypeId
1: 	 *
1: 	 * @return The new top of the tree (this CastNode or a new Constant)
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	private ValueNode getCastFromNonIntegralType(
0: 									  double doubleValue, 
1: 									  int destJDBCTypeId)
1: 		throws StandardException
1: 	{
0: 		String	  stringValue = null;
1: 		ValueNode retNode = this;
1: 
1: 		switch (destJDBCTypeId)
1: 		{
1: 			case Types.CHAR:
0: 				return (ValueNode) getNodeFactory().getNode(
0: 										C_NodeTypes.CHAR_CONSTANT_NODE,
0: 										Double.toString(doubleValue), 
0: 										ReuseFactory.getInteger(
0: 											castTarget.getMaximumWidth()),
1: 										getContextManager());
1: 			case Types.TINYINT:
0: 				doubleValue = Math.floor(doubleValue);
0: 				if (doubleValue < Byte.MIN_VALUE ||
0: 					doubleValue > Byte.MAX_VALUE)
1: 				{
1: 					throw StandardException.newException(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, "TINYINT");
1: 				}
0: 				return (ValueNode) getNodeFactory().getNode(
0: 											C_NodeTypes.TINYINT_CONSTANT_NODE,
0: 											ReuseFactory.getByte(
0: 															(byte) doubleValue),
1: 											getContextManager());
1: 
1: 			case Types.SMALLINT:
0: 				doubleValue = Math.floor(doubleValue);
0: 				if (doubleValue < Short.MIN_VALUE ||
0: 					doubleValue > Short.MAX_VALUE)
1: 				{
0: 					throw StandardException.newException(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, "SMALLINT");
1: 				}
0: 				return (ValueNode) getNodeFactory().getNode(
0: 											C_NodeTypes.SMALLINT_CONSTANT_NODE,
0: 											ReuseFactory.getShort(
0: 														(short) doubleValue),
1: 											getContextManager());
1: 
1: 			case Types.INTEGER:
0: 				doubleValue = Math.floor(doubleValue);
0: 				if (doubleValue < Integer.MIN_VALUE ||
0: 					doubleValue > Integer.MAX_VALUE)
1: 				{
1: 					throw StandardException.newException(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, "INTEGER");
1: 				}
0: 				return (ValueNode) getNodeFactory().getNode(
0: 												C_NodeTypes.INT_CONSTANT_NODE,
0: 												ReuseFactory.getInteger(
0: 															(int) doubleValue),
1: 												getContextManager());
1: 
1: 			case Types.BIGINT:
0: 				doubleValue = Math.floor(doubleValue);
0: 				if (doubleValue < Long.MIN_VALUE ||
0: 					doubleValue > Long.MAX_VALUE)
1: 				{
0: 					throw StandardException.newException(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, "BIGINT");
1: 				}
0: 				return (ValueNode) getNodeFactory().getNode(
0: 									C_NodeTypes.LONGINT_CONSTANT_NODE,
0: 									ReuseFactory.getLong((long) doubleValue),
1: 									getContextManager());
1: 
1: 			case Types.REAL:
0: //                System.out.println("cast to real!");
0: //				if (Math.abs(doubleValue) > Float.MAX_VALUE)
0: //                    throw...
0: //                SQLReal.check(doubleValue);
0: // jsk: rounding problem???
0: 				return (ValueNode) getNodeFactory().getNode(
0: 											C_NodeTypes.FLOAT_CONSTANT_NODE,
0: 											new Float(NumberDataType.normalizeREAL(doubleValue)),
1: 											getContextManager());
1: 
1: 			case Types.DOUBLE:
0: 				return (ValueNode) getNodeFactory().getNode(
0: 										C_NodeTypes.DOUBLE_CONSTANT_NODE,
0: 										new Double(doubleValue),
1: 										getContextManager());
1: 		}
1: 
1: 		return retNode;
1: 	}
1: 
1: 	/**
1: 	 * Preprocess an expression tree.  We do a number of transformations
1: 	 * here (including subqueries, IN lists, LIKE and BETWEEN) plus
1: 	 * subquery flattening.
1: 	 * NOTE: This is done before the outer ResultSetNode is preprocessed.
1: 	 *
1: 	 * @param	numTables			Number of tables in the DML Statement
1: 	 * @param	outerFromList		FromList from outer query block
1: 	 * @param	outerSubqueryList	SubqueryList from outer query block
1: 	 * @param	outerPredicateList	PredicateList from outer query block
1: 	 *
1: 	 * @return		The modified expression
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public ValueNode preprocess(int numTables,
1: 								FromList outerFromList,
1: 								SubqueryList outerSubqueryList,
1: 								PredicateList outerPredicateList) 
1: 					throws StandardException
1: 	{
1: 		castOperand = castOperand.preprocess(numTables,
1: 											 outerFromList, outerSubqueryList,
1: 											 outerPredicateList);
1: 		return this;
1: 	}
1: 
1: 	/**
1: 	 * Categorize this predicate.  Initially, this means
1: 	 * building a bit map of the referenced tables for each predicate.
1: 	 * If the source of this ColumnReference (at the next underlying level) 
1: 	 * is not a ColumnReference or a VirtualColumnNode then this predicate
1: 	 * will not be pushed down.
1: 	 *
1: 	 * For example, in:
1: 	 *		select * from (select 1 from s) a (x) where x = 1
1: 	 * we will not push down x = 1.
1: 	 * NOTE: It would be easy to handle the case of a constant, but if the
1: 	 * inner SELECT returns an arbitrary expression, then we would have to copy
1: 	 * that tree into the pushed predicate, and that tree could contain
1: 	 * subqueries and method calls.
1: 	 * RESOLVE - revisit this issue once we have views.
1: 	 *
1: 	 * @param referencedTabs	JBitSet with bit map of referenced FromTables
1: 	 * @param simplePredsOnly	Whether or not to consider method
1: 	 *							calls, field references and conditional nodes
1: 	 *							when building bit map
1: 	 *
1: 	 * @return boolean		Whether or not source.expression is a ColumnReference
1: 	 *						or a VirtualColumnNode.
1: 	 *
1: 	 * @exception StandardException			Thrown on error
1: 	 */
0: 	public boolean categorize(JBitSet referencedTabs, boolean simplePredsOnly)
1: 		throws StandardException
1: 	{
1: 		return castOperand.categorize(referencedTabs, simplePredsOnly);
1: 	}
1: 
1: 	/**
1: 	 * Remap all ColumnReferences in this tree to be clones of the
1: 	 * underlying expression.
1: 	 *
1: 	 * @return ValueNode			The remapped expression tree.
1: 	 *
1: 	 * @exception StandardException			Thrown on error
1: 	 */
0: 	public ValueNode remapColumnReferencesToExpressions()
1: 		throws StandardException
1: 	{
1: 		castOperand = castOperand.remapColumnReferencesToExpressions();
1: 		return this;
1: 	}
1: 
1: 	/**
1: 	 * Return whether or not this expression tree represents a constant expression.
1: 	 *
1: 	 * @return	Whether or not this expression tree represents a constant expression.
1: 	 */
0: 	public boolean isConstantExpression()
1: 	{
1: 		return castOperand.isConstantExpression();
1: 	}
1: 
1: 	/** @see ValueNode#constantExpression */
0: 	public boolean constantExpression(PredicateList whereClause)
1: 	{
1: 		return castOperand.constantExpression(whereClause);
1: 	}
1: 
1: 	/**
0: 	 * By default unary operators don't accept ? parameters as operands.
0: 	 * This can be over-ridden for particular unary operators.
1: 	 *
0: 	 * @return	Nothing
1: 	 *
0: 	 * @exception StandardException		Always thrown to indicate a
0: 	 *									? parameter where it isn't allowed.
1: 	 */
1: 
0: 	void bindParameter()
1: 					throws StandardException
1: 	{
0: 		((ParameterNode) castOperand).setDescriptor(castTarget);
1: 	}
1: 
1: 	/**
1: 	 * Return an Object representing the bind time value of this
1: 	 * expression tree.  If the expression tree does not evaluate to
1: 	 * a constant at bind time then we return null.
1: 	 * This is useful for bind time resolution of VTIs.
1: 	 * RESOLVE: What do we do for primitives?
1: 	 *
1: 	 * @return	An Object representing the bind time value of this expression tree.
1: 	 *			(null if not a bind time constant.)
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	Object getConstantValueAsObject()
1: 		throws StandardException
1: 	{
1: 		Object sourceObject = castOperand.getConstantValueAsObject();
1: 
1: 		// RESOLVE - need to figure out how to handle casts
1: 		if (sourceObject == null)
1: 		{
1: 			return null;
1: 		}
1: 
1: 		// Simple if source and destination are of same type
1: 		if (sourceCTI.getCorrespondingJavaTypeName().equals(
0: 				destCTI.getCorrespondingJavaTypeName()))
1: 		{
1: 			return sourceObject;
1: 		}
1: 
1: 		// RESOLVE - simply return null until we can figure out how to 
1: 		// do the cast
1: 		return null;
1: 	}
1: 
1: 	/**
1: 	 * Do code generation for this unary operator.
1: 	 *
1: 	 * @param acb	The ExpressionClassBuilder for the class we're generating
1: 	 * @param mb	The method the code to place the code
1: 	 *
0: 	 * @return	An expression to evaluate this operator
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public void generateExpression(ExpressionClassBuilder acb,
1: 											MethodBuilder mb)
1: 									throws StandardException
1: 	{
1: 		castOperand.generateExpression(acb, mb);
1: 
1: 		/* No need to generate code for null constants */
1: 		if (castOperand instanceof UntypedNullConstantNode)
1: 		{
1: 			return;
1: 		}
1: 		/* HACK ALERT. When casting a parameter, there
1: 		 * is not sourceCTI.  Code generation requires one,
1: 		 * so we simply set it to be the same as the
1: 		 * destCTI.  The user can still pass whatever
1: 		 * type they'd like in as a parameter.
1: 		 * They'll get an exception, as expected, if the
1: 		 * conversion cannot be performed.
1: 		 */
0: 		else if (castOperand.isParameterNode())
1: 		{
0: 			sourceCTI = destCTI;
1: 		}
1: 	
1: 		genDataValueConversion(acb, mb);
1: 	}
1: 
1: 	private void genDataValueConversion(ExpressionClassBuilder acb,
1: 											  MethodBuilder mb)
1: 			throws StandardException
1: 	{
1: 		MethodBuilder	acbConstructor = acb.getConstructor();
1: 
1: 		String resultTypeName = getTypeCompiler().interfaceName();
1: 
1: 		/* field = method call */
1: 		/* Allocate an object for re-use to hold the result of the operator */
1: 		LocalField field = acb.newFieldDeclaration(Modifier.PRIVATE, resultTypeName);
1: 
1: 		/*
1: 		** Store the result of the method call in the field, so we can re-use
1: 		** the object.
1: 		*/
1: 
0: 		acb.generateNull(acbConstructor, getTypeCompiler(destCTI));
0: 		acbConstructor.putField(field);
0: 		acbConstructor.endStatement();
1: 
1: 
1: 
1: 		/*
1: 			For most types generate
1: 
1: 			targetDVD.setValue(sourceDVD);
1: 
1: 			// optional for variable length types
1: 			targetDVD.setWidth();
1: 		*/
1: 
0: 		if (!sourceCTI.isNationalStringTypeId() && !sourceCTI.userType() && !destCTI.userType()) {
0: 		mb.getField(field); // targetDVD reference for the setValue method call
0: 		mb.swap();
0: 		mb.cast(ClassName.DataValueDescriptor);
0: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, ClassName.DataValueDescriptor, "setValue", "void", 1);
1: 
1: 		mb.getField(field);
1: 		/* 
1: 		** If we are casting to a variable length datatype, we
1: 		** have to make sure we have set it to the correct
1: 		** length.
1: 		*/
0: 		if (destCTI.variableLength()) 
1: 		{
0: 			boolean isNumber = destCTI.isNumericTypeId();
1: 
1: 			/* setWidth() is on VSDV - upcast since
1: 			 * decimal implements subinterface
1: 			 * of VSDV.
1: 			 */
0: 			mb.push(isNumber ? castTarget.getPrecision() : castTarget.getMaximumWidth());
0: 			mb.push(castTarget.getScale());
0: 			mb.push(!sourceCTI.variableLength() || isNumber);
0: 			mb.callMethod(VMOpcode.INVOKEINTERFACE, ClassName.VariableSizeDataValue, "setWidth", ClassName.DataValueDescriptor, 3);
1: 
0: 			/* setWidth returns DataValueDescriptor - we need
0:  			 * to cast result to actual subinterface getting returned.
1: 			 */
0: 			mb.cast(resultTypeName);
1: 		}
1: 
1: 		return;
1: 		}
1: 
1: 
1: 
1: 
1: 
1: 
1: 		/*
0: 		** If we are casting from a national string to a date, time,
0: 		** or timestamp, do a getDate(), getTime(), or getTimestamp()
0: 		** rather than a getObject(). This is because getObject() returns
0: 		** a String, and setValue() can't tell whether the String comes
0: 		** from a national or non-national character type, so it can't tell
0: 		** whether to use the database locale to do the conversion.
1: 		*/
0: 		String getMethod = "getObject";
0: 		String getType = "java.lang.Object";
0: 		String castType = sourceCTI.getCorrespondingJavaTypeName();
0: 		int argCount = 0;
0: 		if (sourceCTI.isNationalStringTypeId())
1: 		{
0: 			switch (destCTI.getJDBCTypeId())
1: 			{
1: 			  case Types.DATE:
0: 				getMethod = "getDate";
0: 				getType = "java.sql.Date";
0: 				castType = getType;
0: 				break;
1: 
1: 			  case Types.TIME:
0: 				getMethod = "getTime";
0: 				getType = "java.sql.Time";
0: 				castType = getType;
0: 				break;
1: 
1: 			  case Types.TIMESTAMP:
0: 				getMethod = "getTimestamp";
0: 				getType = "java.sql.Timestamp";
0: 				castType = getType;
0: 				break;
1: 			}
1: 
0: 			if (!getMethod.equals("getObject")) {
1: 
0: 				mb.pushThis();
0: 				mb.callMethod(VMOpcode.INVOKEVIRTUAL, 
0: 					acb.getBaseClassName(), 
0: 					"getCalendar", "java.util.Calendar", 0);
1: 
0: 				argCount++;
1: 			}
1: 		}
1: 
1: 		/* 
0: 		** generate: field.setValue((<type>) expr.getObject ) 
0: 		** or		 field.setValue((<type>) expr.getDate )
0: 		** or		 field.setValue((<type>) expr.getTime )
0: 		** or		 field.setValue((<type>) expr.getTimestamp )
1: 		*/
0: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, ClassName.DataValueDescriptor, getMethod, getType, argCount);
1: 
1: 		/* 
0: 		** Cast to java.lang.Object if source or destination type 
0: 		** is a java type because that's how the interface is defined.
1: 		*/
0: 		mb.cast(destCTI.userType() || sourceCTI.userType() ? "java.lang.Object" : castType);
0: 		//castExpr
1: 
0: 		mb.getField(field); // instance for the setValue/setObjectForCast method call
0: 		mb.swap(); // push it before the value
1: 
1: 		/*
0: 		** If we are casting a java type, then
0: 		** we generate:
0: 		**
0: 		**		DataValueDescriptor.setObjectForCast(java.lang.Object castExpr, boolean instanceOfExpr, destinationClassName)
0: 		** where instanceOfExpr is "source instanceof destinationClass".
0: 		**
0: 		** otherwise:
0: 		**
0: 		**		<specificDataValue>.setValue(<type>castExpr)
1: 		*/
0: 		if (sourceCTI.userType())
1: 		{
1: 
1: 			String destinationType = getTypeId().getCorrespondingJavaTypeName();
1: 
1: 			// at this point method instance and cast result are on the stack
1: 			// we duplicate the cast value in order to perform the instanceof check
1: 			mb.dup();
1: 			mb.isInstanceOf(destinationType);
1: 			mb.push(destinationType);
0: 			mb.callMethod(VMOpcode.INVOKEINTERFACE, ClassName.DataValueDescriptor, "setObjectForCast", "void", 3);
1: 		}
1: 		else
1: 		{
0: 			String itype = ClassName.DataValueDescriptor;
0: 			if (castType.startsWith("java.lang.")) {
0: 				if (!castType.equals("java.lang.String") && !castType.equals("java.lang.Object"))
0: 					itype = resultTypeName;
1: 			}
0: 			// System.out.println("type = " + castType);
0: 			mb.callMethod(VMOpcode.INVOKEINTERFACE, itype, "setValue", "void", 1);
0: 			// mb.endStatement();
1: 		}
1: 		mb.getField(field);
1: 
1: 		/* 
1: 		** If we are casting to a variable length datatype, we
1: 		** have to make sure we have set it to the correct
1: 		** length.
1: 		*/
0: 		if (destCTI.variableLength()) 
1: 		{
0: 			boolean isNumber = destCTI.isNumericTypeId();
1: 
1: 			/* setWidth() is on VSDV - upcast since
1: 			 * decimal implements subinterface
1: 			 * of VSDV.
1: 			 */
0: 			mb.push(isNumber ? castTarget.getPrecision() : castTarget.getMaximumWidth());
0: 			mb.push(castTarget.getScale());
0: 			mb.push(!sourceCTI.variableLength() || isNumber);
0: 			mb.callMethod(VMOpcode.INVOKEINTERFACE, ClassName.VariableSizeDataValue, "setWidth", ClassName.DataValueDescriptor, 3);
1: 
1: 								/*
0: 								** The last argument is true if we should
0: 								** throw error on truncation.  We throw an
0: 								** error on all but Bits and Strings
0: 								** (everything with variable length that
0: 								** isn't a number -- all variable length
0: 								** except DECIMAL/NUMERIC).
1: 								*/
0: 								/* RESOLVE:
0: 								** NOTE: If the source is a parameter
0: 								** then the user can pass any type
0: 								** in as the parameter.  We will not
0: 								** raise a truncation exception in
0: 								** this case, even if we would if the
0: 								** cast was directly on the value
0: 								** being passed in as a parameter.
0: 								** For example:
0: 								**	cast(123 as char(1)) throws truncation
0: 								**			exception
0: 								**	cast(? as char(1)), user passes 123
0: 								**		no truncation exception
0: 								** We are considering this behavior to be
0: 								** an extension, at least for now. We may 
0: 								** need to revisit this if there's a
0: 								** SQL-J compliance test with this.
0: 								** (The solution would be to add a method
0: 								** off of ParameterValueSet to get some
0: 								** info about the data type of the
0: 								** actual parameter and generate code for
0: 								** the 3rd parameter to setWidth() based
0: 								** on the execution time data type.
1: 								*/
0: 			/* setWidth returns DataValueDescriptor - we need
0:  			 * to cast result to actual subinterface getting returned.
1: 			 */
0: 			mb.cast(resultTypeName);
1: 		}
1: 	
1: 	}
1: 
1: 	/**
0: 	 * Accept a visitor, and call v.visit()
0: 	 * on child nodes as necessary.  
1: 	 * 
1: 	 * @param v the visitor
1: 	 *
1: 	 * @exception StandardException on error
1: 	 */
0: 	public Visitable accept(Visitor v) 
1: 		throws StandardException
1: 	{
0: 		Visitable returnNode = v.visit(this);
1: 	
0: 		if (v.skipChildren(this))
1: 		{
0: 			return returnNode;
1: 		}
1: 
0: 		if (castOperand != null && !v.stopTraversal())
1: 		{
1: 			castOperand = (ValueNode)castOperand.accept(v);
1: 		}
1: 
0: 		return returnNode;
1: 	}
1: 
1: 	/** set this to be a dataTypeScalarFunction
1: 	 * 
1: 	 * @param b true to use function conversion rules
1: 	 */
0: 	public void setForDataTypeFunction(boolean b)
1: 	{
1: 		forDataTypeFunction = b;
1: 	}
1: 
0: 	/** is this a cast node for a data type scalar function?
0: 	 * @return true if this is  a function, false for regular cast node
1: 	 *
1: 	 */
0: 	public boolean getForDataTypeFunction()
1: 	{
0: 		return forDataTypeFunction;
1: 	}
1: }
1: 
1: 
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:b80f8ae
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.types.StringDataValue;
/////////////////////////////////////////////////////////////////////////
1: 			//set the collation type to be same as the compilation schema's 
1: 			//collation type. Collation derivation will be set to "IMPLICIT".
0: 			setCollationUsingCompilationSchema(
0: 					StringDataValue.COLLATION_DERIVATION_IMPLICIT);
commit:d8b9ea3
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 	/** This variable gets set by the parser to indiciate that this CAST node 
1: 	 * has been generated by the parser. This means that we should use the 
1: 	 * collation info of the current compilation schmea for this node's 
1: 	 * collation setting. If this variable does not get set to true, then it 
1: 	 * means that this CAST node has been an internally generated node and we 
1: 	 * should not touch the collation info set for this CAST node because it 
1: 	 * has been already set correctly by the class that generated this CAST 
1: 	 * node. Collation info is part of the DataTypeDescriptor that's defined
1: 	 * on the ValueNode (the super class of this CastNode class)
0: 	 */ 
0: 	boolean externallyGeneratedCastNode = false;
/////////////////////////////////////////////////////////////////////////
0: 		if (externallyGeneratedCastNode && destCTI.isStringTypeId()) {
/////////////////////////////////////////////////////////////////////////
1: 	/** This method gets called by the parser to indiciate that this CAST node 
1: 	 * has been generated by the parser. This means that we should use the 
0: 	 * collation info of the current compilation schmea for this node's 
1: 	 * collation setting. If this method does not get called, then it means
1: 	 * that this CAST node has been an internally generated node and we should
1: 	 * not touch the collation of this CAST node because it has been already 
1: 	 * set correctly by the class that generated this CAST node. 
0: 	 * 
0: 	 * @param b true to use function conversion rules
0: 	 */
0: 	public void setForExternallyGeneratedCASTnode()
0: 	{
1: 		externallyGeneratedCastNode = true;
0: 	}
0: 
commit:6a52150
/////////////////////////////////////////////////////////////////////////
commit:7c5fbc4
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.types.StringDataValue;
/////////////////////////////////////////////////////////////////////////
0: 		//collation of ? operand should be same as the current schema
0: 		castOperand.getTypeServices().setCollationDerivation(
0: 				StringDataValue.COLLATION_DERIVATION_IMPLICIT);
0: 		castOperand.getTypeServices().setCollationType(
0: 				getLanguageConnectionContext().getDefaultSchema()
0: 						.getCollationType());
commit:244952e
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		//If the result type of cast is string data type, then that data type 
1: 		//should get it's collation type from the current schema. 
0: 			//set the collation type to be same as the current schema's 
0: 			//collation type. Collation derivation is already initialized
0: 			//to correct value by default which is "IMPLICIT"
commit:fc245d8
/////////////////////////////////////////////////////////////////////////
0: 		//If we are dealing with result type of cast to be string data type, 
0: 		//then that data type should get it's collation type from the 
0: 		//current schema. That is what we are doing below 
0: 		if (destCTI.isStringTypeId()) {
0: 			getTypeServices().setCollationType(
0: 					getLanguageConnectionContext().getDefaultSchema().getCollationType());
0: 		}
commit:ba7683c
/////////////////////////////////////////////////////////////////////////
0: 		acb.generateNull(acbConstructor, getTypeCompiler(destCTI), 
0: 				castTarget.getCollationType());
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:b3bf9ca
/////////////////////////////////////////////////////////////////////////
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2d37fd6
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	 * @param constantValue		non-integral type a a double to cast from
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:d5bc20f
/////////////////////////////////////////////////////////////////////////
1: 		if (castOperand.requiresTypeFromContext())
/////////////////////////////////////////////////////////////////////////
0: 		castOperand.setType(castTarget);
/////////////////////////////////////////////////////////////////////////
1: 		else if (castOperand.requiresTypeFromContext())
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package	org.apache.derby.impl.sql.compile;
0: 
0: import org.apache.derby.iapi.services.context.ContextManager;
0: 
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
0: import org.apache.derby.iapi.services.compiler.LocalField;
0: 
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: 
0: import org.apache.derby.iapi.sql.compile.CompilerContext;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
0: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: 
0: import org.apache.derby.iapi.types.DataTypeUtilities;
0: import org.apache.derby.iapi.types.TypeId;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: import org.apache.derby.iapi.types.DataValueFactory;
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.types.VariableSizeDataValue;
0: 
0: import org.apache.derby.iapi.sql.compile.TypeCompiler;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.util.StringUtil;
0: 
0: import org.apache.derby.iapi.reference.ClassName;
0: import org.apache.derby.iapi.reference.JDBC30Translation;
0: import org.apache.derby.iapi.services.classfile.VMOpcode;
0: 
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: 
0: import org.apache.derby.iapi.services.loader.ClassInspector;
0: 
0: import org.apache.derby.iapi.sql.compile.Visitable;
0: import org.apache.derby.iapi.sql.compile.Visitor;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
0: 
0: import java.lang.reflect.Modifier;
0: 
0: import org.apache.derby.impl.sql.compile.ExpressionClassBuilder;
0: import org.apache.derby.iapi.types.NumberDataType;
0: 
0: import org.apache.derby.iapi.util.JBitSet;
0: import org.apache.derby.iapi.util.ReuseFactory;
0: 
0: import org.apache.derby.catalog.AliasInfo;
0: import org.apache.derby.catalog.TypeDescriptor;
0: 
0: import org.apache.derby.iapi.types.SQLReal;
0: 
0: import java.math.BigDecimal;
0: 
0: import java.sql.Date;
0: import java.sql.Time;
0: import java.sql.Timestamp;
0: import java.sql.Types;
0: 
0: import java.util.Vector;
0: 
0: /**
0:  * An CastNode represents a cast expressionr.
0:  *
0:  * @author Jerry Brenner
0:  */
0: 
0: public class CastNode extends ValueNode
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	DataTypeDescriptor	castTarget;
0: 	ValueNode			castOperand;
0: 	int					targetCharType;
0: 	TypeId	destCTI = null;
0: 	TypeId	sourceCTI = null;
0: 	boolean forDataTypeFunction = false;
0: 
0: 	/*
0: 	** Static array of valid casts.  Dimentions
0: 	** produce a single boolean which indicates
0: 	** whether the case is possible or not.
0: 	*/
0: 
0: 	/**
0: 	 * Initializer for a CastNode
0: 	 *
0: 	 * @param castOperand	The operand of the node
0: 	 * @param castTarget	DataTypeServices (target type of cast)
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public void init(Object castOperand, Object castTarget)
0: 		throws StandardException
0: 	{
0: 		this.castOperand = (ValueNode) castOperand;
0: 		this.castTarget = (DataTypeDescriptor) castTarget;
0: 	}
0: 
0: 	/**
0: 	 * Initializer for a CastNode
0: 	 *
0: 	 * @param castOperand	The operand of the node
0: 	 * @param charType		CHAR or VARCHAR JDBC type as target
0: 	 * @param charLength	target type length
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public void init(Object castOperand, Object charType, Object charLength)
0: 		throws StandardException
0: 	{
0: 		this.castOperand = (ValueNode) castOperand;
0: 		int charLen = ((Integer) charLength).intValue();
0: 		targetCharType = ((Integer) charType).intValue();
0: 		if (charLen < 0)	// unknown, figure out later
0: 			return;
0: 		this.castTarget = DataTypeDescriptor.getBuiltInDataTypeDescriptor(targetCharType, charLen);
0: 	}
0: 
0: 	/**
0: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
0: 	 * for how this should be done for tree printing.
0: 	 *
0: 	 * @return		This object as a String
0: 	 */
0: 
0: 	public String toString()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			return "castTarget: " + castTarget + "\n" +
0: 				super.toString();
0: 		}
0: 		else
0: 		{
0: 			return "";
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
0: 	 * how tree printing is supposed to work.
0: 	 *
0: 	 * @param depth		The depth of this node in the tree
0: 	 *
0: 	 * @return	Nothing
0: 	 */
0: 
0: 	public void printSubNodes(int depth)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			super.printSubNodes(depth);
0: 
0: 			if (castOperand != null)
0: 			{
0: 				printLabel(depth, "castOperand: ");
0: 				castOperand.treePrint(depth + 1);
0: 			}
0: 		}
0: 	}
0: 	protected int getOrderableVariantType() throws StandardException
0: 	{
0: 		return castOperand.getOrderableVariantType();
0: 	}
0: 
0: 	/**
0: 	 * Set the clause that this node appears in.
0: 	 *
0: 	 * @param clause	The clause that this node appears in.
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	public void setClause(int clause)
0: 	{
0: 		super.setClause(clause);
0: 		castOperand.setClause(clause);
0: 	}
0: 
0: 	/**
0: 	 * Bind this expression.  This means binding the sub-expressions,
0: 	 * as well as figuring out what the return type is for this expression.
0: 	 *
0: 	 * @param fromList		The FROM list for the query this
0: 	 *				expression is in, for binding columns.
0: 	 * @param subqueryList		The subquery list being built as we find SubqueryNodes
0: 	 * @param aggregateVector	The aggregate vector being built as we find AggregateNodes
0: 	 *
0: 	 * @return	The new top of the expression tree.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public ValueNode bindExpression(FromList fromList, SubqueryList subqueryList,
0: 									Vector aggregateVector)
0: 				throws StandardException
0: 	{
0: 		castOperand = castOperand.bindExpression(
0: 								fromList, subqueryList,
0: 								aggregateVector);
0: 
0: 		if (castTarget == null)   //CHAR or VARCHAR function without specifying target length
0: 		{
0: 			DataTypeDescriptor opndType = castOperand.getTypeServices();
0: 			int length = -1;
0: 			TypeId srcTypeId = opndType.getTypeId();
0: 			if (opndType != null)
0: 			{
0: 				if (srcTypeId.isNumericTypeId())
0: 				{
0: 					length = opndType.getPrecision() + 1; // 1 for the sign
0: 					if (opndType.getScale() > 0)
0: 						length += 1;               // 1 for the decimal .
0: 				 
0: 				}
0: 				else 
0: 				{
0: 					TypeId typeid = opndType.getTypeId();
0: 					if (length < 0)
0: 						length = DataTypeUtilities.getColumnDisplaySize(typeid.getJDBCTypeId(),-1);
0: 
0: 				}
0: 			}
0: 			if (length < 0)
0: 				length = 1;  // same default as in parser
0: 			castTarget = DataTypeDescriptor.getBuiltInDataTypeDescriptor(targetCharType, length);
0: 			
0: 		}
0: 
0: 		/* 
0: 		** If castOperand is an untyped null, 
0: 		** then we must set the type.
0: 		*/
0: 		if (castOperand instanceof UntypedNullConstantNode)
0: 		{
0: 			castOperand.setType(castTarget);
0: 		}
0: 
0: 		bindCastNodeOnly();
0: 		
0: 		/* We can't chop out cast above an untyped null because
0: 		 * the store can't handle it.
0: 		 */
0: 		if ((castOperand instanceof ConstantNode) &&
0: 			!(castOperand instanceof UntypedNullConstantNode))
0: 		{
0: 			/* If the castOperand is a typed constant then we do the cast at
0: 			 * bind time and return a constant of the correct type.
0: 			 * NOTE: This could return an exception, but we're prepared to 
0: 			 * deal with that. (NumberFormatException, etc.)
0: 			 * We only worry about the easy (and useful)
0: 			 * converions at bind time.
0: 			 * Here's what we support:
0: 			 *			source					destination
0: 			 *			------					-----------
0: 			 *			boolean					boolean
0: 			 *			boolean					char
0: 			 *			char					boolean
0: 			 *			char					date/time/ts
0: 			 *			char					non-decimal numeric
0: 			 *			date/time/ts			char
0: 			 *			numeric					char
0: 			 *			numeric					non-decimal numeric
0: 			 */
0: 			/* RESOLVE - to be filled in. */
0: 			ValueNode retNode = this;
0: 			int		  sourceJDBCTypeId = sourceCTI.getJDBCTypeId();
0: 			int		  destJDBCTypeId = destCTI.getJDBCTypeId();
0: 
0: 			switch (sourceJDBCTypeId)
0: 			{
0: 				case Types.BIT:
0: 				case JDBC30Translation.SQL_TYPES_BOOLEAN:
0: 					// (BIT is boolean)
0: 					if (destJDBCTypeId == Types.BIT || destJDBCTypeId == JDBC30Translation.SQL_TYPES_BOOLEAN)
0: 					{
0: 						retNode = castOperand;
0: 					}
0: 					else if (destJDBCTypeId == Types.CHAR)
0: 					{
0: 						BooleanConstantNode bcn = (BooleanConstantNode) castOperand;
0: 						String booleanString = bcn.getValueAsString();
0: 						retNode = (ValueNode) getNodeFactory().getNode(
0: 											C_NodeTypes.CHAR_CONSTANT_NODE,
0: 											booleanString,
0: 											ReuseFactory.getInteger(
0: 												castTarget.getMaximumWidth()),
0: 											getContextManager());
0: 					}
0: 					break;
0: 
0: 					case Types.CHAR:
0: 						retNode = getCastFromCharConstant(destJDBCTypeId);
0: 						break;
0: 
0: 					case Types.DATE:
0: 					case Types.TIME:
0: 					case Types.TIMESTAMP:
0: 						if (destJDBCTypeId == Types.CHAR)
0: 						{
0: 							String castValue =  
0: 								((UserTypeConstantNode) castOperand).
0: 											getObjectValue().
0: 												toString();
0: 							retNode = (ValueNode) getNodeFactory().getNode(
0: 												C_NodeTypes.CHAR_CONSTANT_NODE,
0: 												castValue, 
0: 												ReuseFactory.getInteger(
0: 												  castTarget.getMaximumWidth()),
0: 												getContextManager());
0: 						}
0: 						break;
0: 
0: 					case Types.TINYINT:
0: 					case Types.SMALLINT:
0: 					case Types.INTEGER:
0: 					case Types.BIGINT:
0: 						long longValue = ((NumericConstantNode) castOperand).getLong();
0: 						retNode = getCastFromIntegralType(
0: 											longValue, 
0: 											destJDBCTypeId);
0: 						break;
0: 
0: 					case Types.DOUBLE:
0: 					case Types.REAL:
0: 						double doubleValue = ((NumericConstantNode) castOperand).getDouble();
0: 						retNode = getCastFromNonIntegralType(
0: 											doubleValue, 
0: 											destJDBCTypeId);
0: 						break;
0: 
0: 					case Types.DECIMAL:
0: 						// ignore decimal -> decimal casts for now
0: 						if (destJDBCTypeId != Types.DECIMAL &&
0: 							destJDBCTypeId != Types.NUMERIC)
0: 						{
0: 							/* SQLDecimal.getDouble() throws an exception if the
0: 							 * BigDecimal is outside of the range of double.
0: 							 */
0: 							doubleValue = ((ConstantNode) castOperand).getValue().getDouble();
0: 							retNode = getCastFromNonIntegralType(
0: 												doubleValue, 
0: 												destJDBCTypeId);
0: 						}
0: 						break;
0: 			}
0: 
0: 			// Return the new constant if the cast was performed
0: 			return retNode;
0: 		}
0: 
0: 		return this;
0: 	}
0: 
0: 	/**
0: 	 * Bind this node but not its child.  Caller has already bound
0: 	 * the child.
0: 	 * This is useful for when we generate a CastNode during binding
0: 	 * after having already bound the child.
0: 	 *
0: 	 * @return	Nothing
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void bindCastNodeOnly()
0: 		throws StandardException
0: 	{
0: 
0: 		/*
0: 		** The result type is always castTarget.
0: 		*/
0: 		setType(castTarget);
0: 		destCTI = castTarget.getTypeId();
0: 		sourceCTI = castOperand.getTypeId();
0: 
0: 		/* 
0: 		** If it is a java cast, do some work to make sure
0: 		** the classes are ok and that they are compatible
0: 		*/
0: 		if (! destCTI.systemBuiltIn())
0: 		{
0: 			String className = ((TypeId) dataTypeServices.getTypeId()).getCorrespondingJavaTypeName();
0: 
0: 			boolean convertCase = ! destCTI.getClassNameWasDelimitedIdentifier();
0: 
0: 			className = verifyClassExist(className, convertCase);
0: 
0: 			castTarget = new DataTypeDescriptor(TypeId.getUserDefinedTypeId(className, false),
0: 														true /* assume nullable for now, change it if not nullable */
0: 													);
0: 			setType(castTarget);
0: 			destCTI = castTarget.getTypeId();
0: 		}
0: 
0: 		if (castOperand.isParameterNode())
0: 		{
0: 			bindParameter();
0: 		}
0: 
0: 		/*
0: 		** If it isn't null, then we have
0: 		** a cast from one JBMS type to another.  So we
0: 		** have to figure out if it is legit.
0: 		*/
0: 		else if (!(castOperand instanceof UntypedNullConstantNode))
0: 		{
0: 			/*
0: 			** Make sure we can assign the two classes
0: 			*/
0: 			TypeCompiler tc = castOperand.getTypeCompiler();
0: 			if (! tc.convertible(destCTI, forDataTypeFunction))
0: 			{
0: 				throw StandardException.newException(SQLState.LANG_INVALID_CAST, 
0: 						sourceCTI.getSQLTypeName(),
0: 						destCTI.getSQLTypeName());
0: 			}
0: 		}		
0: 	}
0: 
0: 	/**
0: 	 * Get a constant representing the cast from a CHAR to another
0: 	 * type.  If this is not an "easy" cast to perform, then just
0: 	 * return this cast node.
0: 	 * Here's what we think is "easy":
0: 	 *			source			destination
0: 	 *			------			-----------
0: 	 *			char			boolean
0: 	 *			char			date/time/ts
0: 	 *			char			non-decimal numeric
0: 	 *
0: 	 * @param destJDBCTypeId	The destination JDBC TypeId
0: 	 *
0: 	 * @return The new top of the tree (this CastNode or a new Constant)
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	private ValueNode getCastFromCharConstant(int destJDBCTypeId)
0: 		throws StandardException
0: 	{
0: 		String	  charValue = ((CharConstantNode) castOperand).getString();
0: 		String	  cleanCharValue = StringUtil.SQLToUpperCase(charValue.trim());
0: 		ValueNode retNode = this;
0: 
0: 		switch (destJDBCTypeId)
0: 		{
0: 			case Types.BIT:
0: 			case JDBC30Translation.SQL_TYPES_BOOLEAN:
0: 				if (cleanCharValue.equals("TRUE"))
0: 				{
0: 					return (ValueNode) getNodeFactory().getNode(
0: 											C_NodeTypes.BOOLEAN_CONSTANT_NODE,
0: 											Boolean.TRUE,
0: 											getContextManager());
0: 				}
0: 				else if (cleanCharValue.equals("FALSE"))
0: 				{
0: 					return (ValueNode) getNodeFactory().getNode(
0: 											C_NodeTypes.BOOLEAN_CONSTANT_NODE,
0: 											Boolean.FALSE,
0: 											getContextManager());
0: 				}
0: 				else
0: 				{
0: 					throw StandardException.newException(SQLState.LANG_FORMAT_EXCEPTION, "boolean");
0: 				}
0: 
0: 			case Types.DATE:
0: 				return (ValueNode) getNodeFactory().getNode(
0: 										C_NodeTypes.USERTYPE_CONSTANT_NODE,
0: 										getDataValueFactory().getDateValue(cleanCharValue, false),
0: 										getContextManager());
0: 
0: 			case Types.TIMESTAMP:
0: 				return (ValueNode) getNodeFactory().getNode(
0: 									C_NodeTypes.USERTYPE_CONSTANT_NODE,
0: 									getDataValueFactory().getTimestampValue(cleanCharValue, false),
0: 									getContextManager());
0: 
0: 			case Types.TIME:
0: 				return (ValueNode) getNodeFactory().getNode(
0: 										C_NodeTypes.USERTYPE_CONSTANT_NODE,
0: 										getDataValueFactory().getTimeValue(cleanCharValue, false),
0: 										getContextManager());
0: 
0: 			case Types.TINYINT:
0: 			case Types.SMALLINT:
0: 			case Types.INTEGER:
0: 			case Types.BIGINT:				
0: 				try 
0: 				{
0: 					// #3756 - Truncate decimal portion for casts to integer
0: 					return getCastFromIntegralType((new Double(cleanCharValue)).longValue(),
0: 												   destJDBCTypeId);
0: 				}
0: 				catch (NumberFormatException nfe)
0: 				{
0: 					String sqlName = TypeId.getBuiltInTypeId(destJDBCTypeId).getSQLTypeName();
0: 					throw StandardException.newException(SQLState.LANG_FORMAT_EXCEPTION, sqlName);
0: 				}
0: 			case Types.REAL:
0: 				Float floatValue;
0: 				try
0: 				{
0: 					floatValue = Float.valueOf(cleanCharValue);
0: 				}
0: 				catch (NumberFormatException nfe)
0: 				{
0: 					throw StandardException.newException(SQLState.LANG_FORMAT_EXCEPTION, "float");
0: 				}
0: 				return (ValueNode) getNodeFactory().getNode(
0: 											C_NodeTypes.FLOAT_CONSTANT_NODE,
0: 											floatValue,
0: 											getContextManager());
0: 			case Types.DOUBLE:
0: 				Double doubleValue;
0: 				try
0: 				{
0: 					doubleValue = new Double(cleanCharValue);
0: 				}
0: 				catch (NumberFormatException nfe)
0: 				{
0: 					throw StandardException.newException(SQLState.LANG_FORMAT_EXCEPTION, "double");
0: 				}
0: 				return (ValueNode) getNodeFactory().getNode(
0: 											C_NodeTypes.DOUBLE_CONSTANT_NODE,
0: 											doubleValue,
0: 											getContextManager());
0: 		}
0: 
0: 		return retNode;
0: 	}
0: 
0: 
0: 	/**
0: 	 * Get a constant representing the cast from an integral type to another
0: 	 * type.  If this is not an "easy" cast to perform, then just
0: 	 * return this cast node.
0: 	 * Here's what we think is "easy":
0: 	 *			source				destination
0: 	 *			------				-----------
0: 	 *			integral type		 non-decimal numeric
0: 	 *			integral type		 char
0: 	 *
0: 	 * @param longValue			integral type as a long to cast from
0: 	 * @param destJDBCTypeId	The destination JDBC TypeId
0: 	 *
0: 	 * @return The new top of the tree (this CastNode or a new Constant)
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	private ValueNode getCastFromIntegralType(
0: 									  long longValue, 
0: 									  int destJDBCTypeId)
0: 		throws StandardException
0: 	{
0: 		ValueNode retNode = this;
0: 
0: 		switch (destJDBCTypeId)
0: 		{
0: 			case Types.CHAR:
0: 				return (ValueNode) getNodeFactory().getNode(
0: 										C_NodeTypes.CHAR_CONSTANT_NODE,
0: 										Long.toString(longValue), 
0: 										ReuseFactory.getInteger(
0: 											castTarget.getMaximumWidth()),
0: 										getContextManager());
0: 			case Types.TINYINT:
0: 				if (longValue < Byte.MIN_VALUE ||
0: 					longValue > Byte.MAX_VALUE)
0: 				{
0: 					throw StandardException.newException(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, "TINYINT");
0: 				}
0: 				return (ValueNode) getNodeFactory().getNode(
0: 										C_NodeTypes.TINYINT_CONSTANT_NODE,
0: 										ReuseFactory.getByte((byte) longValue),
0: 										getContextManager());
0: 
0: 			case Types.SMALLINT:
0: 				if (longValue < Short.MIN_VALUE ||
0: 					longValue > Short.MAX_VALUE)
0: 				{
0: 					throw StandardException.newException(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, "SHORT");
0: 				}
0: 				return (ValueNode) getNodeFactory().getNode(
0: 											C_NodeTypes.SMALLINT_CONSTANT_NODE,
0: 											ReuseFactory.getShort(
0: 															(short) longValue),
0: 											getContextManager());
0: 
0: 			case Types.INTEGER:
0: 				if (longValue < Integer.MIN_VALUE ||
0: 					longValue > Integer.MAX_VALUE)
0: 				{
0: 					throw StandardException.newException(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, "INTEGER");
0: 				}
0: 				return (ValueNode) getNodeFactory().getNode(
0: 												C_NodeTypes.INT_CONSTANT_NODE,
0: 												ReuseFactory.getInteger(
0: 															(int) longValue),
0: 												getContextManager());
0: 
0: 			case Types.BIGINT:
0: 				return (ValueNode) getNodeFactory().getNode(
0: 								C_NodeTypes.LONGINT_CONSTANT_NODE,
0: 								ReuseFactory.getLong(longValue),
0: 								getContextManager());
0: 
0: 			case Types.REAL:
0: 				if (Math.abs(longValue) > Float.MAX_VALUE)
0: 				{
0: 					throw StandardException.newException(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, "REAL");
0: 				}
0: 				return (ValueNode) getNodeFactory().getNode(
0: 											C_NodeTypes.FLOAT_CONSTANT_NODE,
0: 											new Float((float) longValue),
0: 											getContextManager());
0: 
0: 			case Types.DOUBLE:
0: 				return (ValueNode) getNodeFactory().getNode(
0: 									C_NodeTypes.DOUBLE_CONSTANT_NODE,
0: 									new Double((double) longValue),
0: 									getContextManager());
0: 		}
0: 
0: 		return retNode;
0: 	}
0: 
0: 	/**
0: 	 * Get a constant representing the cast from a non-integral type to another
0: 	 * type.  If this is not an "easy" cast to perform, then just
0: 	 * return this cast node.
0: 	 * Here's what we think is "easy":
0: 	 *			source				destination
0: 	 *			------				-----------
0: 	 *			non-integral type	 non-decimal numeric
0: 	 *			non-integral type	 char
0: 	 *
0: 	 * @param doubleValue		non-integral type a a double to cast from
0: 	 * @param destJDBCTypeId	The destination JDBC TypeId
0: 	 *
0: 	 * @return The new top of the tree (this CastNode or a new Constant)
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	private ValueNode getCastFromNonIntegralType(
0: 									  double doubleValue, 
0: 									  int destJDBCTypeId)
0: 		throws StandardException
0: 	{
0: 		String	  stringValue = null;
0: 		ValueNode retNode = this;
0: 
0: 		switch (destJDBCTypeId)
0: 		{
0: 			case Types.CHAR:
0: 				return (ValueNode) getNodeFactory().getNode(
0: 										C_NodeTypes.CHAR_CONSTANT_NODE,
0: 										Double.toString(doubleValue), 
0: 										ReuseFactory.getInteger(
0: 											castTarget.getMaximumWidth()),
0: 										getContextManager());
0: 			case Types.TINYINT:
0: 				doubleValue = Math.floor(doubleValue);
0: 				if (doubleValue < Byte.MIN_VALUE ||
0: 					doubleValue > Byte.MAX_VALUE)
0: 				{
0: 					throw StandardException.newException(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, "TINYINT");
0: 				}
0: 				return (ValueNode) getNodeFactory().getNode(
0: 											C_NodeTypes.TINYINT_CONSTANT_NODE,
0: 											ReuseFactory.getByte(
0: 															(byte) doubleValue),
0: 											getContextManager());
0: 
0: 			case Types.SMALLINT:
0: 				doubleValue = Math.floor(doubleValue);
0: 				if (doubleValue < Short.MIN_VALUE ||
0: 					doubleValue > Short.MAX_VALUE)
0: 				{
0: 					throw StandardException.newException(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, "SMALLINT");
0: 				}
0: 				return (ValueNode) getNodeFactory().getNode(
0: 											C_NodeTypes.SMALLINT_CONSTANT_NODE,
0: 											ReuseFactory.getShort(
0: 														(short) doubleValue),
0: 											getContextManager());
0: 
0: 			case Types.INTEGER:
0: 				doubleValue = Math.floor(doubleValue);
0: 				if (doubleValue < Integer.MIN_VALUE ||
0: 					doubleValue > Integer.MAX_VALUE)
0: 				{
0: 					throw StandardException.newException(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, "INTEGER");
0: 				}
0: 				return (ValueNode) getNodeFactory().getNode(
0: 												C_NodeTypes.INT_CONSTANT_NODE,
0: 												ReuseFactory.getInteger(
0: 															(int) doubleValue),
0: 												getContextManager());
0: 
0: 			case Types.BIGINT:
0: 				doubleValue = Math.floor(doubleValue);
0: 				if (doubleValue < Long.MIN_VALUE ||
0: 					doubleValue > Long.MAX_VALUE)
0: 				{
0: 					throw StandardException.newException(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, "BIGINT");
0: 				}
0: 				return (ValueNode) getNodeFactory().getNode(
0: 									C_NodeTypes.LONGINT_CONSTANT_NODE,
0: 									ReuseFactory.getLong((long) doubleValue),
0: 									getContextManager());
0: 
0: 			case Types.REAL:
0: //                System.out.println("cast to real!");
0: //				if (Math.abs(doubleValue) > Float.MAX_VALUE)
0: //                    throw...
0: //                SQLReal.check(doubleValue);
0: // jsk: rounding problem???
0: 				return (ValueNode) getNodeFactory().getNode(
0: 											C_NodeTypes.FLOAT_CONSTANT_NODE,
0: 											new Float(NumberDataType.normalizeREAL(doubleValue)),
0: 											getContextManager());
0: 
0: 			case Types.DOUBLE:
0: 				return (ValueNode) getNodeFactory().getNode(
0: 										C_NodeTypes.DOUBLE_CONSTANT_NODE,
0: 										new Double(doubleValue),
0: 										getContextManager());
0: 		}
0: 
0: 		return retNode;
0: 	}
0: 
0: 	/**
0: 	 * Preprocess an expression tree.  We do a number of transformations
0: 	 * here (including subqueries, IN lists, LIKE and BETWEEN) plus
0: 	 * subquery flattening.
0: 	 * NOTE: This is done before the outer ResultSetNode is preprocessed.
0: 	 *
0: 	 * @param	numTables			Number of tables in the DML Statement
0: 	 * @param	outerFromList		FromList from outer query block
0: 	 * @param	outerSubqueryList	SubqueryList from outer query block
0: 	 * @param	outerPredicateList	PredicateList from outer query block
0: 	 *
0: 	 * @return		The modified expression
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public ValueNode preprocess(int numTables,
0: 								FromList outerFromList,
0: 								SubqueryList outerSubqueryList,
0: 								PredicateList outerPredicateList) 
0: 					throws StandardException
0: 	{
0: 		castOperand = castOperand.preprocess(numTables,
0: 											 outerFromList, outerSubqueryList,
0: 											 outerPredicateList);
0: 		return this;
0: 	}
0: 
0: 	/**
0: 	 * Categorize this predicate.  Initially, this means
0: 	 * building a bit map of the referenced tables for each predicate.
0: 	 * If the source of this ColumnReference (at the next underlying level) 
0: 	 * is not a ColumnReference or a VirtualColumnNode then this predicate
0: 	 * will not be pushed down.
0: 	 *
0: 	 * For example, in:
0: 	 *		select * from (select 1 from s) a (x) where x = 1
0: 	 * we will not push down x = 1.
0: 	 * NOTE: It would be easy to handle the case of a constant, but if the
0: 	 * inner SELECT returns an arbitrary expression, then we would have to copy
0: 	 * that tree into the pushed predicate, and that tree could contain
0: 	 * subqueries and method calls.
0: 	 * RESOLVE - revisit this issue once we have views.
0: 	 *
0: 	 * @param referencedTabs	JBitSet with bit map of referenced FromTables
0: 	 * @param simplePredsOnly	Whether or not to consider method
0: 	 *							calls, field references and conditional nodes
0: 	 *							when building bit map
0: 	 *
0: 	 * @return boolean		Whether or not source.expression is a ColumnReference
0: 	 *						or a VirtualColumnNode.
0: 	 *
0: 	 * @exception StandardException			Thrown on error
0: 	 */
0: 	public boolean categorize(JBitSet referencedTabs, boolean simplePredsOnly)
0: 		throws StandardException
0: 	{
0: 		return castOperand.categorize(referencedTabs, simplePredsOnly);
0: 	}
0: 
0: 	/**
0: 	 * Remap all ColumnReferences in this tree to be clones of the
0: 	 * underlying expression.
0: 	 *
0: 	 * @return ValueNode			The remapped expression tree.
0: 	 *
0: 	 * @exception StandardException			Thrown on error
0: 	 */
0: 	public ValueNode remapColumnReferencesToExpressions()
0: 		throws StandardException
0: 	{
0: 		castOperand = castOperand.remapColumnReferencesToExpressions();
0: 		return this;
0: 	}
0: 
0: 	/**
0: 	 * Return whether or not this expression tree represents a constant expression.
0: 	 *
0: 	 * @return	Whether or not this expression tree represents a constant expression.
0: 	 */
0: 	public boolean isConstantExpression()
0: 	{
0: 		return castOperand.isConstantExpression();
0: 	}
0: 
0: 	/** @see ValueNode#constantExpression */
0: 	public boolean constantExpression(PredicateList whereClause)
0: 	{
0: 		return castOperand.constantExpression(whereClause);
0: 	}
0: 
0: 	/**
0: 	 * By default unary operators don't accept ? parameters as operands.
0: 	 * This can be over-ridden for particular unary operators.
0: 	 *
0: 	 * @return	Nothing
0: 	 *
0: 	 * @exception StandardException		Always thrown to indicate a
0: 	 *									? parameter where it isn't allowed.
0: 	 */
0: 
0: 	void bindParameter()
0: 					throws StandardException
0: 	{
0: 		((ParameterNode) castOperand).setDescriptor(castTarget);
0: 	}
0: 
0: 	/**
0: 	 * Return an Object representing the bind time value of this
0: 	 * expression tree.  If the expression tree does not evaluate to
0: 	 * a constant at bind time then we return null.
0: 	 * This is useful for bind time resolution of VTIs.
0: 	 * RESOLVE: What do we do for primitives?
0: 	 *
0: 	 * @return	An Object representing the bind time value of this expression tree.
0: 	 *			(null if not a bind time constant.)
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	Object getConstantValueAsObject()
0: 		throws StandardException
0: 	{
0: 		Object sourceObject = castOperand.getConstantValueAsObject();
0: 
0: 		// RESOLVE - need to figure out how to handle casts
0: 		if (sourceObject == null)
0: 		{
0: 			return null;
0: 		}
0: 
0: 		// Simple if source and destination are of same type
0: 		if (sourceCTI.getCorrespondingJavaTypeName().equals(
0: 				destCTI.getCorrespondingJavaTypeName()))
0: 		{
0: 			return sourceObject;
0: 		}
0: 
0: 		// RESOLVE - simply return null until we can figure out how to 
0: 		// do the cast
0: 		return null;
0: 	}
0: 
0: 	/**
0: 	 * Do code generation for this unary operator.
0: 	 *
0: 	 * @param acb	The ExpressionClassBuilder for the class we're generating
0: 	 * @param mb	The method the code to place the code
0: 	 *
0: 	 * @return	An expression to evaluate this operator
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public void generateExpression(ExpressionClassBuilder acb,
0: 											MethodBuilder mb)
0: 									throws StandardException
0: 	{
0: 		castOperand.generateExpression(acb, mb);
0: 
0: 		/* No need to generate code for null constants */
0: 		if (castOperand instanceof UntypedNullConstantNode)
0: 		{
0: 			return;
0: 		}
0: 		/* HACK ALERT. When casting a parameter, there
0: 		 * is not sourceCTI.  Code generation requires one,
0: 		 * so we simply set it to be the same as the
0: 		 * destCTI.  The user can still pass whatever
0: 		 * type they'd like in as a parameter.
0: 		 * They'll get an exception, as expected, if the
0: 		 * conversion cannot be performed.
0: 		 */
0: 		else if (castOperand.isParameterNode())
0: 		{
0: 			sourceCTI = destCTI;
0: 		}
0: 	
0: 		genDataValueConversion(acb, mb);
0: 	}
0: 
0: 	private void genDataValueConversion(ExpressionClassBuilder acb,
0: 											  MethodBuilder mb)
0: 			throws StandardException
0: 	{
0: 		MethodBuilder	acbConstructor = acb.getConstructor();
0: 
0: 		String resultTypeName = getTypeCompiler().interfaceName();
0: 
0: 		/* field = method call */
0: 		/* Allocate an object for re-use to hold the result of the operator */
0: 		LocalField field = acb.newFieldDeclaration(Modifier.PRIVATE, resultTypeName);
0: 
0: 		/*
0: 		** Store the result of the method call in the field, so we can re-use
0: 		** the object.
0: 		*/
0: 
0: 		acb.generateNull(acbConstructor, getTypeCompiler(destCTI));
0: 		acbConstructor.putField(field);
0: 		acbConstructor.endStatement();
0: 
0: 
0: 
0: 		/*
0: 			For most types generate
0: 
0: 			targetDVD.setValue(sourceDVD);
0: 
0: 			// optional for variable length types
0: 			targetDVD.setWidth();
0: 		*/
0: 
0: 		if (!sourceCTI.isNationalStringTypeId() && !sourceCTI.userType() && !destCTI.userType()) {
0: 		mb.getField(field); // targetDVD reference for the setValue method call
0: 		mb.swap();
0: 		mb.cast(ClassName.DataValueDescriptor);
0: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, ClassName.DataValueDescriptor, "setValue", "void", 1);
0: 
0: 		mb.getField(field);
0: 		/* 
0: 		** If we are casting to a variable length datatype, we
0: 		** have to make sure we have set it to the correct
0: 		** length.
0: 		*/
0: 		if (destCTI.variableLength()) 
0: 		{
0: 			boolean isNumber = destCTI.isNumericTypeId();
0: 
0: 			/* setWidth() is on VSDV - upcast since
0: 			 * decimal implements subinterface
0: 			 * of VSDV.
0: 			 */
0: 			mb.push(isNumber ? castTarget.getPrecision() : castTarget.getMaximumWidth());
0: 			mb.push(castTarget.getScale());
0: 			mb.push(!sourceCTI.variableLength() || isNumber);
0: 			mb.callMethod(VMOpcode.INVOKEINTERFACE, ClassName.VariableSizeDataValue, "setWidth", ClassName.DataValueDescriptor, 3);
0: 
0: 			/* setWidth returns DataValueDescriptor - we need
0:  			 * to cast result to actual subinterface getting returned.
0: 			 */
0: 			mb.cast(resultTypeName);
0: 		}
0: 
0: 		return;
0: 		}
0: 
0: 
0: 
0: 
0: 
0: 
0: 		/*
0: 		** If we are casting from a national string to a date, time,
0: 		** or timestamp, do a getDate(), getTime(), or getTimestamp()
0: 		** rather than a getObject(). This is because getObject() returns
0: 		** a String, and setValue() can't tell whether the String comes
0: 		** from a national or non-national character type, so it can't tell
0: 		** whether to use the database locale to do the conversion.
0: 		*/
0: 		String getMethod = "getObject";
0: 		String getType = "java.lang.Object";
0: 		String castType = sourceCTI.getCorrespondingJavaTypeName();
0: 		int argCount = 0;
0: 		if (sourceCTI.isNationalStringTypeId())
0: 		{
0: 			switch (destCTI.getJDBCTypeId())
0: 			{
0: 			  case Types.DATE:
0: 				getMethod = "getDate";
0: 				getType = "java.sql.Date";
0: 				castType = getType;
0: 				break;
0: 
0: 			  case Types.TIME:
0: 				getMethod = "getTime";
0: 				getType = "java.sql.Time";
0: 				castType = getType;
0: 				break;
0: 
0: 			  case Types.TIMESTAMP:
0: 				getMethod = "getTimestamp";
0: 				getType = "java.sql.Timestamp";
0: 				castType = getType;
0: 				break;
0: 			}
0: 
0: 			if (!getMethod.equals("getObject")) {
0: 
0: 				mb.pushThis();
0: 				mb.callMethod(VMOpcode.INVOKEVIRTUAL, 
0: 					acb.getBaseClassName(), 
0: 					"getCalendar", "java.util.Calendar", 0);
0: 
0: 				argCount++;
0: 			}
0: 		}
0: 
0: 		/* 
0: 		** generate: field.setValue((<type>) expr.getObject ) 
0: 		** or		 field.setValue((<type>) expr.getDate )
0: 		** or		 field.setValue((<type>) expr.getTime )
0: 		** or		 field.setValue((<type>) expr.getTimestamp )
0: 		*/
0: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, ClassName.DataValueDescriptor, getMethod, getType, argCount);
0: 
0: 		/* 
0: 		** Cast to java.lang.Object if source or destination type 
0: 		** is a java type because that's how the interface is defined.
0: 		*/
0: 		mb.cast(destCTI.userType() || sourceCTI.userType() ? "java.lang.Object" : castType);
0: 		//castExpr
0: 
0: 		mb.getField(field); // instance for the setValue/setObjectForCast method call
0: 		mb.swap(); // push it before the value
0: 
0: 		/*
0: 		** If we are casting a java type, then
0: 		** we generate:
0: 		**
0: 		**		DataValueDescriptor.setObjectForCast(java.lang.Object castExpr, boolean instanceOfExpr, destinationClassName)
0: 		** where instanceOfExpr is "source instanceof destinationClass".
0: 		**
0: 		** otherwise:
0: 		**
0: 		**		<specificDataValue>.setValue(<type>castExpr)
0: 		*/
0: 		if (sourceCTI.userType())
0: 		{
0: 
0: 			String destinationType = getTypeId().getCorrespondingJavaTypeName();
0: 
0: 			// at this point method instance and cast result are on the stack
0: 			// we duplicate the cast value in order to perform the instanceof check
0: 			mb.dup();
0: 			mb.isInstanceOf(destinationType);
0: 			mb.push(destinationType);
0: 			mb.callMethod(VMOpcode.INVOKEINTERFACE, ClassName.DataValueDescriptor, "setObjectForCast", "void", 3);
0: 		}
0: 		else
0: 		{
0: 			String itype = ClassName.DataValueDescriptor;
0: 			if (castType.startsWith("java.lang.")) {
0: 				if (!castType.equals("java.lang.String") && !castType.equals("java.lang.Object"))
0: 					itype = resultTypeName;
0: 			}
0: 			// System.out.println("type = " + castType);
0: 			mb.callMethod(VMOpcode.INVOKEINTERFACE, itype, "setValue", "void", 1);
0: 			// mb.endStatement();
0: 		}
0: 		mb.getField(field);
0: 
0: 		/* 
0: 		** If we are casting to a variable length datatype, we
0: 		** have to make sure we have set it to the correct
0: 		** length.
0: 		*/
0: 		if (destCTI.variableLength()) 
0: 		{
0: 			boolean isNumber = destCTI.isNumericTypeId();
0: 
0: 			/* setWidth() is on VSDV - upcast since
0: 			 * decimal implements subinterface
0: 			 * of VSDV.
0: 			 */
0: 			mb.push(isNumber ? castTarget.getPrecision() : castTarget.getMaximumWidth());
0: 			mb.push(castTarget.getScale());
0: 			mb.push(!sourceCTI.variableLength() || isNumber);
0: 			mb.callMethod(VMOpcode.INVOKEINTERFACE, ClassName.VariableSizeDataValue, "setWidth", ClassName.DataValueDescriptor, 3);
0: 
0: 								/*
0: 								** The last argument is true if we should
0: 								** throw error on truncation.  We throw an
0: 								** error on all but Bits and Strings
0: 								** (everything with variable length that
0: 								** isn't a number -- all variable length
0: 								** except DECIMAL/NUMERIC).
0: 								*/
0: 								/* RESOLVE:
0: 								** NOTE: If the source is a parameter
0: 								** then the user can pass any type
0: 								** in as the parameter.  We will not
0: 								** raise a truncation exception in
0: 								** this case, even if we would if the
0: 								** cast was directly on the value
0: 								** being passed in as a parameter.
0: 								** For example:
0: 								**	cast(123 as char(1)) throws truncation
0: 								**			exception
0: 								**	cast(? as char(1)), user passes 123
0: 								**		no truncation exception
0: 								** We are considering this behavior to be
0: 								** an extension, at least for now. We may 
0: 								** need to revisit this if there's a
0: 								** SQL-J compliance test with this.
0: 								** (The solution would be to add a method
0: 								** off of ParameterValueSet to get some
0: 								** info about the data type of the
0: 								** actual parameter and generate code for
0: 								** the 3rd parameter to setWidth() based
0: 								** on the execution time data type.
0: 								*/
0: 			/* setWidth returns DataValueDescriptor - we need
0:  			 * to cast result to actual subinterface getting returned.
0: 			 */
0: 			mb.cast(resultTypeName);
0: 		}
0: 	
0: 	}
0: 
0: 	/**
0: 	 * Accept a visitor, and call v.visit()
0: 	 * on child nodes as necessary.  
0: 	 * 
0: 	 * @param v the visitor
0: 	 *
0: 	 * @exception StandardException on error
0: 	 */
0: 	public Visitable accept(Visitor v) 
0: 		throws StandardException
0: 	{
0: 		Visitable returnNode = v.visit(this);
0: 	
0: 		if (v.skipChildren(this))
0: 		{
0: 			return returnNode;
0: 		}
0: 
0: 		if (castOperand != null && !v.stopTraversal())
0: 		{
0: 			castOperand = (ValueNode)castOperand.accept(v);
0: 		}
0: 
0: 		return returnNode;
0: 	}
0: 
0: 	/** set this to be a dataTypeScalarFunction
0: 	 * 
0: 	 * @param b true to use function conversion rules
0: 	 */
0: 	public void setForDataTypeFunction(boolean b)
0: 	{
0: 		forDataTypeFunction = b;
0: 	}
0: 
0: 	/** is this a cast node for a data type scalar function?
0: 	 * @return true if this is  a function, false for regular cast node
0: 	 *
0: 	 */
0: 	public boolean getForDataTypeFunction()
0: 	{
0: 		return forDataTypeFunction;
0: 	}
0: }
0: 
0: 
============================================================================