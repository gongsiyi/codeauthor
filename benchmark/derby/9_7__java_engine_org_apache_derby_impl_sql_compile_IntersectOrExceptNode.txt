1:47f9d0a: /*
13:47f9d0a: 
1:47f9d0a:    Derby - Class org.apache.derby.impl.sql.compile.IntersectNode
1:47f9d0a: 
1:2d37fd6:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2d37fd6:    contributor license agreements.  See the NOTICE file distributed with
1:2d37fd6:    this work for additional information regarding copyright ownership.
1:2d37fd6:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2d37fd6:    (the "License"); you may not use this file except in compliance with
1:2d37fd6:    the License.  You may obtain a copy of the License at
1:47f9d0a: 
1:47f9d0a:       http://www.apache.org/licenses/LICENSE-2.0
1:47f9d0a: 
1:47f9d0a:    Unless required by applicable law or agreed to in writing, software
1:47f9d0a:    distributed under the License is distributed on an "AS IS" BASIS,
1:47f9d0a:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:47f9d0a:    See the License for the specific language governing permissions and
1:47f9d0a:    limitations under the License.
1:47f9d0a: 
1:47f9d0a:  */
1:47f9d0a: 
1:47f9d0a: package	org.apache.derby.impl.sql.compile;
1:47f9d0a: 
1:3bb140c: import java.sql.Types;
1:3bb140c: import java.util.BitSet;
1:3bb140c: import java.util.Properties;
1:3bb140c: import org.apache.derby.iapi.error.StandardException;
1:47f9d0a: import org.apache.derby.iapi.reference.ClassName;
1:47f9d0a: import org.apache.derby.iapi.services.classfile.VMOpcode;
1:47f9d0a: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1:47f9d0a: import org.apache.derby.iapi.services.context.ContextManager;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:3bb140c: import org.apache.derby.iapi.sql.compile.CostEstimate;
1:47f9d0a: import org.apache.derby.iapi.sql.compile.Optimizable;
1:47f9d0a: import org.apache.derby.iapi.sql.compile.OptimizablePredicateList;
1:47f9d0a: import org.apache.derby.iapi.sql.compile.Optimizer;
1:47f9d0a: import org.apache.derby.iapi.sql.compile.RowOrdering;
1:47f9d0a: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
1:3bb140c: import org.apache.derby.iapi.types.TypeId;
1:47f9d0a: import org.apache.derby.iapi.util.JBitSet;
1:47f9d0a: 
1:47f9d0a: /**
1:47f9d0a:  * A IntersectOrExceptNode represents an INTERSECT or EXCEPT DML statement.
2:47f9d0a:  *
1:47f9d0a:  */
1:47f9d0a: 
1:47f9d0a: public class IntersectOrExceptNode extends SetOperatorNode
2:47f9d0a: {
1:47f9d0a:     /* Currently we implement INTERSECT and EXCEPT by rewriting
1:47f9d0a:      *   t1 (INTERSECT|EXCEPT) [ALL] t2
1:47f9d0a:      * as (roughly)
1:47f9d0a:      *   setOpResultSet( opType, all, (select * from t1 order by 1,2,...n), (select * from t2 ORDER BY 1,2,...,n))
1:47f9d0a:      * where n is the number of columns in t1 (which must be the same as the number of columns in t2),
1:47f9d0a:      * and opType is INTERSECT, or EXCEPT.
1:47f9d0a:      *
1:47f9d0a:      * The setOpResultSet result set simultaneously scans through its two ordered inputs and
1:47f9d0a:      * performs the intersect or except.
1:47f9d0a:      *
1:47f9d0a:      * There are other query plans that may be more efficient, depending on the sizes. One plan is
1:47f9d0a:      * to make a hash table from one of the input tables and then look up each row of the other input
1:47f9d0a:      * table in the hash table.  However, we have not yet implemented spilling to disk in the
1:47f9d0a:      * BackingStoreHashtable class: currently the whole hash table is in RAM. If we were to use it
1:47f9d0a:      * we would blow up on large input tables.
1:47f9d0a:      */
1:47f9d0a: 
1:47f9d0a:     private int opType;
1:47f9d0a:     public static final int INTERSECT_OP = 1;
1:47f9d0a:     public static final int EXCEPT_OP = 2;
1:47f9d0a: 
1:47f9d0a: 	/* Only optimize it once */
1:47f9d0a: 	/* Only call addNewNodes() once */
1:47f9d0a: 	private boolean addNewNodesCalled;
1:47f9d0a: 
1:47f9d0a:     private int[] intermediateOrderByColumns; // The input result sets will be ordered on these columns. 0 indexed
1:47f9d0a:     private int[] intermediateOrderByDirection; // ascending = 1, descending = -1
1:cc30c0c:     private boolean[] intermediateOrderByNullsLow; // TRUE means NULL values should be ordered lower than non-NULL values
1:47f9d0a: 
1:47f9d0a: 	/**
1:3bb140c:      * Constructor for a SetOperatorNode.
1:47f9d0a: 	 *
1:3bb140c:      * @param opType            The operator type: one of {@link #EXCEPT_OP} or
1:3bb140c:      *                          {@link #INTERSECT_OP}.
1:47f9d0a: 	 * @param leftResult		The ResultSetNode on the left side of this union
1:47f9d0a: 	 * @param rightResult		The ResultSetNode on the right side of this union
1:3bb140c:      * @param all               {@code true} if this is an ALL set operation.
1:47f9d0a: 	 * @param tableProperties	Properties list associated with the table
1:3bb140c:      * @param cm                The context manager
1:47f9d0a: 	 * @exception StandardException		Thrown on error
1:47f9d0a: 	 */
1:3bb140c:     IntersectOrExceptNode(int            opType,
1:3bb140c:                           ResultSetNode  leftResult,
1:3bb140c:                           ResultSetNode  rightResult,
1:3bb140c:                           boolean        all,
1:3bb140c:                           Properties     tableProperties,
1:3bb140c:                           ContextManager cm) throws StandardException {
1:47f9d0a: 
1:3bb140c:         super(leftResult, rightResult, all, tableProperties, cm);
1:3bb140c:         this.opType = opType;
1:108305b:     }
1:47f9d0a: 
1:47f9d0a:     private int getOpType()
1:47f9d0a:     {
1:47f9d0a:         return opType;
2:47f9d0a:     }
1:47f9d0a:     
1:47f9d0a:     /**
1:47f9d0a:      * Push order by lists down to the children so that we can implement the intersect/except
1:47f9d0a:      * by scan of the two sorted inputs.
1:47f9d0a: 	 *
1:47f9d0a: 	 * @param numTables			Number of tables in the DML Statement
1:47f9d0a: 	 * @param gbl				The group by list, if any
1:47f9d0a: 	 * @param fromList			The from list, if any
1:47f9d0a: 	 *
1:47f9d0a: 	 * @return The preprocessed ResultSetNode that can be optimized
1:47f9d0a: 	 *
1:47f9d0a: 	 * @exception StandardException		Thrown on error
1:47f9d0a: 	 */
1:47f9d0a: 
1:3bb140c:     @Override
1:3bb140c:     ResultSetNode preprocess(int numTables,
1:47f9d0a: 									GroupByList gbl,
1:47f9d0a: 									FromList fromList)
2:47f9d0a: 								throws StandardException
1:47f9d0a: 	{
1:47f9d0a:         // RESOLVE: We are in a quandary as to when and how we should generate order by lists. SelectNode processing
1:47f9d0a:         // requires order by lists at the start of preprocess. That is why we are doing it here. However we can
1:47f9d0a:         // pick any column ordering. Depending on the child expressions the optimizer may be able to avoid a
1:47f9d0a:         // sort if we pick the right column ordering. For instance if one of the child expressions is
1:47f9d0a:         // "select <key columns>, <other expressions> from T" where there is a unique index on <key columns>
1:47f9d0a:         // then we can just generate an order by on the key columns and the optimizer should use the unique index
1:47f9d0a:         // to produce the sorted result set. However the ResultSetNode class does not make it easy to
1:47f9d0a:         // find the structure of the query expression. Furthermore we most want to avoid a sort on the larger
1:47f9d0a:         // input, but the size estimate is not available at preprocess time.
1:47f9d0a: 
1:47f9d0a:         intermediateOrderByColumns = new int[ getResultColumns().size()];
1:47f9d0a:         intermediateOrderByDirection = new int[ intermediateOrderByColumns.length];
1:cc30c0c:         intermediateOrderByNullsLow = new boolean[ intermediateOrderByColumns.length];
1:b4cda60: 
1:b4cda60:         /* If there is an order by on the result of the intersect then use
1:b4cda60:          * that because we know that doing so will avoid a sort.  If the
1:b4cda60:          * output of the intersect/except is small relative to its inputs then
1:b4cda60:          * in some cases it would be better to sort the inputs on a different
1:b4cda60:          * sequence of columns, but it is hard to analyze the input query
1:b4cda60:          * expressions to see if a sort can be avoided.
1:47f9d0a:          */
1:b4cda60:         final OrderByList obl = qec.getOrderByList(0);
1:b4cda60: 
1:b4cda60:         if( obl != null)
1:47f9d0a:         {
1:47f9d0a:             BitSet colsOrdered = new BitSet( intermediateOrderByColumns.length);
1:b4cda60:             int orderByListSize = obl.size();
1:47f9d0a:             int intermediateOrderByIdx = 0;
1:47f9d0a:             for( int i = 0; i < orderByListSize; i++)
1:47f9d0a:             {
1:47f9d0a:                 if( colsOrdered.get(i))
1:47f9d0a:                     continue;
1:4d044a3:                 OrderByColumn orderByColumn =
1:b4cda60:                     obl.getOrderByColumn(i);
1:47f9d0a:                 intermediateOrderByDirection[intermediateOrderByIdx] = orderByColumn.isAscending() ? 1 : -1;
1:cc30c0c:                 intermediateOrderByNullsLow[intermediateOrderByIdx] = orderByColumn.isNullsOrderedLow();
1:47f9d0a:                 int columnIdx = orderByColumn.getResultColumn().getColumnPosition() - 1;
1:47f9d0a:                 intermediateOrderByColumns[intermediateOrderByIdx] = columnIdx;
1:47f9d0a:                 colsOrdered.set( columnIdx);
1:47f9d0a:                 intermediateOrderByIdx++;
1:47f9d0a:             }
1:47f9d0a:             for( int i = 0; i < intermediateOrderByColumns.length; i++)
1:47f9d0a:             {
1:47f9d0a:                 if( ! colsOrdered.get(i))
1:47f9d0a:                 {
1:47f9d0a:                     intermediateOrderByDirection[intermediateOrderByIdx] = 1;
1:cc30c0c:                     intermediateOrderByNullsLow[intermediateOrderByIdx] = false;
1:47f9d0a:                     intermediateOrderByColumns[intermediateOrderByIdx] = i;
1:47f9d0a:                     intermediateOrderByIdx++;
1:47f9d0a:                 }
1:47f9d0a:             }
1:b4cda60:             qec.setOrderByList(0, null); // It will be pushed down.
1:47f9d0a:         }
1:47f9d0a:         else // The output of the intersect/except does not have to be ordered
1:47f9d0a:         {
1:47f9d0a:             // Pick an intermediate ordering that minimizes the cost.
1:47f9d0a:             // RESOLVE: how do you do that?
1:47f9d0a:             for( int i = 0; i < intermediateOrderByColumns.length; i++)
1:47f9d0a:             {
1:47f9d0a:                 intermediateOrderByDirection[i] = 1;
1:cc30c0c:                 intermediateOrderByNullsLow[i] = false;
1:47f9d0a:                 intermediateOrderByColumns[i] = i;
1:47f9d0a:             }
1:47f9d0a:         }
1:47f9d0a:         pushOrderingDown( leftResultSet);
1:47f9d0a:         pushOrderingDown( rightResultSet);
1:47f9d0a: 
1:47f9d0a:         return super.preprocess( numTables, gbl, fromList);
1:47f9d0a:     } // end of preprocess
1:47f9d0a: 
1:47f9d0a:     private void pushOrderingDown( ResultSetNode rsn)
1:47f9d0a:         throws StandardException
1:47f9d0a:     {
1:47f9d0a:         ContextManager cm = getContextManager();
1:3bb140c:         OrderByList orderByList = new OrderByList(null, cm);
1:3bb140c: 
1:47f9d0a:         for( int i = 0; i < intermediateOrderByColumns.length; i++)
1:47f9d0a:         {
1:3bb140c:             OrderByColumn orderByColumn =
1:3bb140c:                 new OrderByColumn(
1:3bb140c:                     new NumericConstantNode(
1:3bb140c:                         TypeId.getBuiltInTypeId(Types.INTEGER),
1:bb5be6f:                         intermediateOrderByColumns[i] + 1,
1:3bb140c:                         cm),
1:3bb140c:                     cm);
1:3bb140c: 
1:3bb140c:             if( intermediateOrderByDirection[i] < 0) {
1:47f9d0a:                 orderByColumn.setDescending();
1:3bb140c:             }
1:3bb140c: 
1:3bb140c:             if( intermediateOrderByNullsLow[i]) {
1:cc30c0c:                 orderByColumn.setNullsOrderedLow();
1:3bb140c:             }
1:3bb140c: 
1:47f9d0a:             orderByList.addOrderByColumn( orderByColumn);
1:47f9d0a:         }
1:47f9d0a:         orderByList.bindOrderByColumns( rsn);
1:b4cda60:         rsn.pushQueryExpressionSuffix();
1:47f9d0a:         rsn.pushOrderByList( orderByList);
1:47f9d0a:     } // end of pushOrderingDown
1:47f9d0a:                                                             
1:47f9d0a:     /**
1:47f9d0a:      * @see org.apache.derby.iapi.sql.compile.Optimizable#estimateCost
1:47f9d0a:      */
1:3bb140c:     @Override
1:47f9d0a:     public CostEstimate estimateCost( OptimizablePredicateList predList,
1:47f9d0a:                                       ConglomerateDescriptor cd,
1:47f9d0a:                                       CostEstimate outerCost,
1:47f9d0a:                                       Optimizer optimizer,
1:47f9d0a:                                       RowOrdering rowOrdering)
1:47f9d0a:                           throws StandardException
1:47f9d0a:     {
1:66c825f: 		leftResultSet = optimizeSource(
1:66c825f: 							optimizer,
1:66c825f: 							leftResultSet,
1:66c825f: 							(PredicateList) null,
1:66c825f: 							outerCost);
1:66c825f: 
1:66c825f: 		rightResultSet = optimizeSource(
1:66c825f: 							optimizer,
1:66c825f: 							rightResultSet,
1:66c825f: 							(PredicateList) null,
1:66c825f: 							outerCost);
1:66c825f: 
1:3bb140c:         CostEstimate costEst = getCostEstimate(optimizer);
1:47f9d0a:         CostEstimate leftCostEstimate = leftResultSet.getCostEstimate();
1:47f9d0a:         CostEstimate rightCostEstimate = rightResultSet.getCostEstimate();
1:47f9d0a: 
1:3bb140c:         // The cost is the sum of the two child costs plus the cost of
1:3bb140c:         // sorting the union.
1:3bb140c:         costEst.setCost(
1:3bb140c:             leftCostEstimate.getEstimatedCost() +
1:3bb140c:                 rightCostEstimate.getEstimatedCost(),
1:3bb140c:             getRowCountEstimate(
1:3bb140c:                 leftCostEstimate.rowCount(),
1:3bb140c:                 rightCostEstimate.rowCount()),
1:3bb140c:             getSingleScanRowCountEstimate(
1:3bb140c:                 leftCostEstimate.singleScanRowCount(),
1:3bb140c:                 rightCostEstimate.singleScanRowCount()));
1:3bb140c: 
1:3bb140c:         return costEst;
1:47f9d0a:     } // End of estimateCost
1:47f9d0a: 
1:47f9d0a: 	/**
1:47f9d0a: 	 * @see Optimizable#modifyAccessPath
1:47f9d0a: 	 *
1:47f9d0a: 	 * @exception StandardException		Thrown on error
1:47f9d0a: 	 */
1:3bb140c:     @Override
1:47f9d0a: 	public Optimizable modifyAccessPath(JBitSet outerTables) throws StandardException
1:47f9d0a: 	{
1:47f9d0a: 		Optimizable retOptimizable;
1:47f9d0a: 		retOptimizable = super.modifyAccessPath(outerTables);
1:47f9d0a: 
1:47f9d0a: 		/* We only want call addNewNodes() once */
1:47f9d0a: 		if (addNewNodesCalled)
1:47f9d0a: 		{
1:47f9d0a: 			return retOptimizable;
1:47f9d0a: 		}
1:47f9d0a: 		return (Optimizable) addNewNodes();
1:47f9d0a: 	}
1:47f9d0a: 
1:47f9d0a: 	/**
1:47f9d0a: 	 * @see ResultSetNode#modifyAccessPaths
1:47f9d0a: 	 *
1:47f9d0a: 	 * @exception StandardException		Thrown on error
1:47f9d0a: 	 */
1:3bb140c:     @Override
1:3bb140c:     ResultSetNode modifyAccessPaths() throws StandardException
1:47f9d0a: 	{
1:47f9d0a: 		ResultSetNode retRSN;
1:47f9d0a: 		retRSN = super.modifyAccessPaths();
1:47f9d0a: 
1:47f9d0a: 		/* We only want call addNewNodes() once */
1:47f9d0a: 		if (addNewNodesCalled)
1:47f9d0a: 		{
1:47f9d0a: 			return retRSN;
1:47f9d0a: 		}
1:47f9d0a: 		return addNewNodes();
1:47f9d0a: 	}
1:47f9d0a: 
1:47f9d0a: 	/**
1:47f9d0a: 	 * Add any new ResultSetNodes that are necessary to the tree.
1:47f9d0a: 	 * We wait until after optimization to do this in order to
1:47f9d0a: 	 * make it easier on the optimizer.
1:47f9d0a: 	 *
1:47f9d0a: 	 * @return (Potentially new) head of the ResultSetNode tree.
1:47f9d0a: 	 *
1:47f9d0a: 	 * @exception StandardException		Thrown on error
1:47f9d0a: 	 */
1:47f9d0a: 	private ResultSetNode addNewNodes()
1:47f9d0a: 		throws StandardException
1:47f9d0a: 	{
1:47f9d0a: 		/* Only call addNewNodes() once */
1:47f9d0a: 		if (addNewNodesCalled)
1:47f9d0a: 		{
2:47f9d0a: 			return this;
1:47f9d0a: 		}
1:47f9d0a: 
1:47f9d0a: 		addNewNodesCalled = true;
1:108305b: 
1:108305b:         ResultSetNode treeTop = this;
1:108305b: 
1:b4cda60:         for (int i = 0; i < qec.size(); i++) {
1:b4cda60:             final OrderByList obl = qec.getOrderByList(i);
1:b4cda60: 
1:b4cda60:             if(obl != null) {
1:b4cda60:                 // Generate an order by node on top of the intersect/except
1:b4cda60:                 treeTop = new OrderByNode(
1:b4cda60:                         treeTop,
1:b4cda60:                         obl,
1:b4cda60:                         tableProperties,
1:b4cda60:                         getContextManager());
1:b4cda60:             }
1:b4cda60: 
1:b4cda60:             final ValueNode offset = qec.getOffset(i);
1:b4cda60:             final ValueNode fetchFirst = qec.getFetchFirst(i);
1:b4cda60: 
1:b4cda60:             if (offset != null || fetchFirst != null) {
1:b4cda60:                 ResultColumnList newRcl =
1:b4cda60:                     treeTop.getResultColumns().copyListAndObjects();
1:b4cda60:                 newRcl.genVirtualColumnNodes(
1:b4cda60:                     treeTop, treeTop.getResultColumns());
1:b4cda60: 
1:b4cda60:                 treeTop = new RowCountNode(
1:b4cda60:                         treeTop,
1:b4cda60:                         newRcl,
1:b4cda60:                         offset,
1:b4cda60:                         fetchFirst,
1:b4cda60:                         qec.getHasJDBCLimitClause()[i].booleanValue(),
1:b4cda60:                         getContextManager());
1:b4cda60:             }
1:108305b:         }
1:108305b: 
1:108305b:         return treeTop;
1:108305b: 
1:47f9d0a:     } // end of addNewNodes
1:108305b: 
1:47f9d0a:     /**
1:47f9d0a: 	 * Generate the code.
1:47f9d0a: 	 *
1:47f9d0a: 	 * @exception StandardException		Thrown on error
1:47f9d0a:      */
1:3bb140c:     @Override
1:8fe3166:     void generate( ActivationClassBuilder acb, MethodBuilder mb)
1:47f9d0a:         throws StandardException
1:47f9d0a: 	{
1:47f9d0a: 
1:47f9d0a: 		/* Get the next ResultSet #, so that we can number this ResultSetNode, its
1:47f9d0a: 		 * ResultColumnList and ResultSet.
1:47f9d0a: 		 */
1:47f9d0a: 		assignResultSetNumber();
1:47f9d0a: 
1:ab10884: 		// Get our final cost estimate based on the child estimates.
1:11f7ee3: 		setCostEstimate( getFinalCostEstimate() );
1:ab10884: 
1:47f9d0a: 		// build up the tree.
1:47f9d0a: 
1:47f9d0a:         /* Generate the SetOpResultSet. Arguments:
1:47f9d0a:          *  1) expression for left child ResultSet
1:47f9d0a:          *  2) expression for right child ResultSet
1:47f9d0a:          *  3) activation
1:47f9d0a:          *  4) resultSetNumber
1:47f9d0a:          *  5) estimated row count
1:47f9d0a:          *  6) estimated cost
1:47f9d0a:          *  7) opType
1:47f9d0a:          *  8) all
1:cc30c0c:          *  9) intermediateOrderByColumns saved object index
1:cc30c0c:          *  10) intermediateOrderByDirection saved object index
1:cc30c0c:          *  11) intermediateOrderByNullsLow saved object index
1:47f9d0a:          */
1:47f9d0a: 
1:6b26ee1: 		acb.pushGetResultSetFactoryExpression(mb); // instance for getSetOpResultSet
1:47f9d0a: 
1:47f9d0a: 		getLeftResultSet().generate( acb, mb);
1:47f9d0a: 		getRightResultSet().generate( acb, mb);
1:47f9d0a: 
1:47f9d0a: 		acb.pushThisAsActivation(mb);
1:11f7ee3: 		mb.push(getResultSetNumber());
1:11f7ee3:         mb.push( getCostEstimate().getEstimatedRowCount());
1:11f7ee3:         mb.push( getCostEstimate().getEstimatedCost());
1:47f9d0a:         mb.push( getOpType());
1:47f9d0a:         mb.push( all);
1:47f9d0a:         mb.push( getCompilerContext().addSavedObject( intermediateOrderByColumns));
1:47f9d0a:         mb.push( getCompilerContext().addSavedObject( intermediateOrderByDirection));
1:cc30c0c:         mb.push( getCompilerContext().addSavedObject( intermediateOrderByNullsLow));
1:47f9d0a: 
1:47f9d0a: 		mb.callMethod(VMOpcode.INVOKEINTERFACE,
1:47f9d0a:                       (String) null,
1:47f9d0a:                       "getSetOpResultSet",
1:cc30c0c:                       ClassName.NoPutResultSet, 11);
1:47f9d0a: 	} // end of generate
1:47f9d0a: 
1:ab10884: 	/**
1:ab10884: 	 * @see ResultSetNode#getFinalCostEstimate
1:ab10884: 	 *
1:ab10884: 	 * Get the final CostEstimate for this IntersectOrExceptNode.
1:ab10884: 	 *
1:ab10884: 	 * @return	The final CostEstimate for this IntersectOrExceptNode,
1:ab10884: 	 *  which is the sum of the two child costs.  The final number of
1:ab10884: 	 *  rows depends on whether this is an INTERSECT or EXCEPT (see
1:ab10884: 	 *  getRowCountEstimate() in this class for more).
1:ab10884: 	 */
1:3bb140c:     @Override
1:3bb140c:     CostEstimate getFinalCostEstimate()
1:ab10884: 		throws StandardException
1:ab10884: 	{
1:11f7ee3: 		if (getCandidateFinalCostEstimate() != null)
1:11f7ee3:         {
1:11f7ee3: 			return getCandidateFinalCostEstimate();
1:11f7ee3:         }
1:ab10884: 
1:ab10884: 		CostEstimate leftCE = leftResultSet.getFinalCostEstimate();
1:ab10884: 		CostEstimate rightCE = rightResultSet.getFinalCostEstimate();
1:ab10884: 
1:11f7ee3: 		setCandidateFinalCostEstimate( getNewCostEstimate() );
1:11f7ee3: 		getCandidateFinalCostEstimate().setCost(
1:ab10884: 			leftCE.getEstimatedCost() + rightCE.getEstimatedCost(),
1:ab10884: 			getRowCountEstimate(leftCE.rowCount(), rightCE.rowCount()),
1:ab10884: 			getSingleScanRowCountEstimate(leftCE.singleScanRowCount(),
1:ab10884: 				rightCE.singleScanRowCount()));
1:ab10884: 
1:11f7ee3: 		return getCandidateFinalCostEstimate();
1:ab10884: 	}
1:ab10884: 
1:47f9d0a:     String getOperatorName()
1:47f9d0a:     {
1:47f9d0a:         switch( opType)
1:47f9d0a:         {
1:47f9d0a:         case INTERSECT_OP:
1:47f9d0a:             return "INTERSECT";
1:47f9d0a: 
1:47f9d0a:         case EXCEPT_OP:
1:47f9d0a:             return "EXCEPT";
1:47f9d0a:         }
1:47f9d0a:         if( SanityManager.DEBUG)
1:47f9d0a:             SanityManager.THROWASSERT( "Invalid intersectOrExcept opType: " + opType);
1:47f9d0a:         return "?";
1:47f9d0a:     }
1:47f9d0a:     
1:47f9d0a:     double getRowCountEstimate( double leftRowCount, double rightRowCount)
1:47f9d0a:     {
1:47f9d0a:         switch( opType)
1:47f9d0a:         {
1:47f9d0a:         case INTERSECT_OP:
1:47f9d0a:             // The result has at most min( leftRowCount, rightRowCount). Estimate the actual row count at
1:47f9d0a:             // half that.
1:47f9d0a:             return Math.min( leftRowCount, rightRowCount)/2;
1:47f9d0a: 
1:47f9d0a:         case EXCEPT_OP:
1:ab10884:             // The result has at most leftRowCount rows and at least
1:ab10884:             // max(0, leftRowCount - rightRowCount) rows.  Use the mean
1:ab10884:             // of those two as the estimate.
1:ab10884:             return (leftRowCount + Math.max(0, leftRowCount - rightRowCount))/2;
1:47f9d0a:         }
1:47f9d0a:         if( SanityManager.DEBUG)
1:47f9d0a:             SanityManager.THROWASSERT( "Invalid intersectOrExcept opType: " + opType);
1:47f9d0a:         return 1.0;
1:47f9d0a:     } // end of getRowCountEstimate
1:47f9d0a:     
1:47f9d0a:     double getSingleScanRowCountEstimate( double leftSingleScanRowCount, double rightSingleScanRowCount)
1:47f9d0a:     {
1:47f9d0a:         return getRowCountEstimate( leftSingleScanRowCount, rightSingleScanRowCount);
1:47f9d0a:     }
1:47f9d0a: }
============================================================================
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:bb5be6f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                         intermediateOrderByColumns[i] + 1,
commit:8fe3166
/////////////////////////////////////////////////////////////////////////
1:     void generate( ActivationClassBuilder acb, MethodBuilder mb)
commit:7af858d
/////////////////////////////////////////////////////////////////////////
0:             treeTop = (ResultSetNode)getNodeFactory().getNode(
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:11f7ee3
/////////////////////////////////////////////////////////////////////////
1: 		setCostEstimate( getFinalCostEstimate() );
/////////////////////////////////////////////////////////////////////////
1: 		mb.push(getResultSetNumber());
1:         mb.push( getCostEstimate().getEstimatedRowCount());
1:         mb.push( getCostEstimate().getEstimatedCost());
/////////////////////////////////////////////////////////////////////////
1: 		if (getCandidateFinalCostEstimate() != null)
1:         {
1: 			return getCandidateFinalCostEstimate();
1:         }
1: 		setCandidateFinalCostEstimate( getNewCostEstimate() );
1: 		getCandidateFinalCostEstimate().setCost(
1: 		return getCandidateFinalCostEstimate();
commit:87d06c2
/////////////////////////////////////////////////////////////////////////
0:                 Boolean.valueOf( hasJDBClimitClause ),
commit:57c1b5c
/////////////////////////////////////////////////////////////////////////
0:                 new Boolean( hasJDBClimitClause ),
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:b4cda60
/////////////////////////////////////////////////////////////////////////
1: 
1:         /* If there is an order by on the result of the intersect then use
1:          * that because we know that doing so will avoid a sort.  If the
1:          * output of the intersect/except is small relative to its inputs then
1:          * in some cases it would be better to sort the inputs on a different
1:          * sequence of columns, but it is hard to analyze the input query
1:          * expressions to see if a sort can be avoided.
1:         final OrderByList obl = qec.getOrderByList(0);
1: 
1:         if( obl != null)
1:             int orderByListSize = obl.size();
1:                     obl.getOrderByColumn(i);
/////////////////////////////////////////////////////////////////////////
1:             qec.setOrderByList(0, null); // It will be pushed down.
/////////////////////////////////////////////////////////////////////////
1:         rsn.pushQueryExpressionSuffix();
/////////////////////////////////////////////////////////////////////////
1:         for (int i = 0; i < qec.size(); i++) {
1:             final OrderByList obl = qec.getOrderByList(i);
1: 
1:             if(obl != null) {
1:                 // Generate an order by node on top of the intersect/except
1:                 treeTop = new OrderByNode(
1:                         treeTop,
1:                         obl,
1:                         tableProperties,
1:                         getContextManager());
1:             }
1: 
1:             final ValueNode offset = qec.getOffset(i);
1:             final ValueNode fetchFirst = qec.getFetchFirst(i);
1: 
1:             if (offset != null || fetchFirst != null) {
1:                 ResultColumnList newRcl =
1:                     treeTop.getResultColumns().copyListAndObjects();
1:                 newRcl.genVirtualColumnNodes(
1:                     treeTop, treeTop.getResultColumns());
1: 
1:                 treeTop = new RowCountNode(
1:                         treeTop,
1:                         newRcl,
1:                         offset,
1:                         fetchFirst,
1:                         qec.getHasJDBCLimitClause()[i].booleanValue(),
1:                         getContextManager());
1:             }
commit:2706d1f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Types;
1: import java.util.BitSet;
1: import java.util.Properties;
1: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
1: import org.apache.derby.iapi.sql.compile.CostEstimate;
1: import org.apache.derby.iapi.types.TypeId;
/////////////////////////////////////////////////////////////////////////
1:      * Constructor for a SetOperatorNode.
1:      * @param opType            The operator type: one of {@link #EXCEPT_OP} or
1:      *                          {@link #INTERSECT_OP}.
1:      * @param all               {@code true} if this is an ALL set operation.
1:      * @param cm                The context manager
1:     IntersectOrExceptNode(int            opType,
1:                           ResultSetNode  leftResult,
1:                           ResultSetNode  rightResult,
1:                           boolean        all,
1:                           Properties     tableProperties,
1:                           ContextManager cm) throws StandardException {
1:         super(leftResult, rightResult, all, tableProperties, cm);
0:         setNodeType(C_NodeTypes.INTERSECT_OR_EXCEPT_NODE);
1:         this.opType = opType;
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     ResultSetNode preprocess(int numTables,
/////////////////////////////////////////////////////////////////////////
1:         OrderByList orderByList = new OrderByList(null, cm);
1: 
1:             OrderByColumn orderByColumn =
1:                 new OrderByColumn(
1:                     new NumericConstantNode(
1:                         TypeId.getBuiltInTypeId(Types.INTEGER),
0:                         ReuseFactory.getInteger(
0:                             intermediateOrderByColumns[i] + 1),
1:                         cm),
1:                     cm);
1: 
1:             if( intermediateOrderByDirection[i] < 0) {
1:             }
1: 
1:             if( intermediateOrderByNullsLow[i]) {
1:             }
1: 
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:         CostEstimate costEst = getCostEstimate(optimizer);
1:         // The cost is the sum of the two child costs plus the cost of
1:         // sorting the union.
1:         costEst.setCost(
1:             leftCostEstimate.getEstimatedCost() +
1:                 rightCostEstimate.getEstimatedCost(),
1:             getRowCountEstimate(
1:                 leftCostEstimate.rowCount(),
1:                 rightCostEstimate.rowCount()),
1:             getSingleScanRowCountEstimate(
1:                 leftCostEstimate.singleScanRowCount(),
1:                 rightCostEstimate.singleScanRowCount()));
1: 
1:         return costEst;
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     ResultSetNode modifyAccessPaths() throws StandardException
/////////////////////////////////////////////////////////////////////////
0:             treeTop = new OrderByNode(
/////////////////////////////////////////////////////////////////////////
0:             treeTop = new RowCountNode(
0:                 hasJDBClimitClause,
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     CostEstimate getFinalCostEstimate()
commit:4d044a3
/////////////////////////////////////////////////////////////////////////
0:         if( orderByLists[0] != null)
0:             int orderByListSize = orderByLists[0].size();
1:                 OrderByColumn orderByColumn =
0:                     orderByLists[0].getOrderByColumn(i);
/////////////////////////////////////////////////////////////////////////
0:             orderByLists[0] = null; // It will be pushed down.
/////////////////////////////////////////////////////////////////////////
0:         if( orderByLists[0] != null) {
0:                 orderByLists[0],
/////////////////////////////////////////////////////////////////////////
commit:108305b
/////////////////////////////////////////////////////////////////////////
1:         ResultSetNode treeTop = this;
1: 
0:         if( orderByList != null) {
0:             // Generate an order by node on top of the intersect/except
0:             treeTop = (ResultSetNode) getNodeFactory().getNode(
0:                 C_NodeTypes.ORDER_BY_NODE,
0:                 treeTop,
0:                 orderByList,
0:                 tableProperties,
0:                 getContextManager());
1:         }
1: 
0:         if (offset != null || fetchFirst != null) {
0:             ResultColumnList newRcl =
0:                 treeTop.getResultColumns().copyListAndObjects();
0:             newRcl.genVirtualColumnNodes(treeTop, treeTop.getResultColumns());
1: 
0:             treeTop = (RowCountNode)getNodeFactory().getNode(
0:                 C_NodeTypes.ROW_COUNT_NODE,
0:                 treeTop,
0:                 newRcl,
0:                 offset,
0:                 fetchFirst,
0:                 getContextManager());
1:         }
1: 
1:         return treeTop;
1: 
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
commit:cc30c0c
/////////////////////////////////////////////////////////////////////////
1:     private boolean[] intermediateOrderByNullsLow; // TRUE means NULL values should be ordered lower than non-NULL values
/////////////////////////////////////////////////////////////////////////
1:         intermediateOrderByNullsLow = new boolean[ intermediateOrderByColumns.length];
/////////////////////////////////////////////////////////////////////////
1:                 intermediateOrderByNullsLow[intermediateOrderByIdx] = orderByColumn.isNullsOrderedLow();
/////////////////////////////////////////////////////////////////////////
1:                     intermediateOrderByNullsLow[intermediateOrderByIdx] = false;
/////////////////////////////////////////////////////////////////////////
1:                 intermediateOrderByNullsLow[i] = false;
/////////////////////////////////////////////////////////////////////////
0:             if( intermediateOrderByNullsLow[i])
1:                 orderByColumn.setNullsOrderedLow();
/////////////////////////////////////////////////////////////////////////
1:          *  9) intermediateOrderByColumns saved object index
1:          *  10) intermediateOrderByDirection saved object index
1:          *  11) intermediateOrderByNullsLow saved object index
/////////////////////////////////////////////////////////////////////////
1:         mb.push( getCompilerContext().addSavedObject( intermediateOrderByNullsLow));
1:                       ClassName.NoPutResultSet, 11);
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:9e6e461
/////////////////////////////////////////////////////////////////////////
0:                       ClassName.NoPutResultSet, 10);
commit:6b26ee1
/////////////////////////////////////////////////////////////////////////
1: 		acb.pushGetResultSetFactoryExpression(mb); // instance for getSetOpResultSet
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2d37fd6
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:ab10884
/////////////////////////////////////////////////////////////////////////
1: 		// Get our final cost estimate based on the child estimates.
0: 		costEstimate = getFinalCostEstimate();
1: 
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * @see ResultSetNode#getFinalCostEstimate
1: 	 *
1: 	 * Get the final CostEstimate for this IntersectOrExceptNode.
1: 	 *
1: 	 * @return	The final CostEstimate for this IntersectOrExceptNode,
1: 	 *  which is the sum of the two child costs.  The final number of
1: 	 *  rows depends on whether this is an INTERSECT or EXCEPT (see
1: 	 *  getRowCountEstimate() in this class for more).
1: 	 */
0: 	public CostEstimate getFinalCostEstimate()
1: 		throws StandardException
1: 	{
0: 		if (finalCostEstimate != null)
0: 			return finalCostEstimate;
1: 
1: 		CostEstimate leftCE = leftResultSet.getFinalCostEstimate();
1: 		CostEstimate rightCE = rightResultSet.getFinalCostEstimate();
1: 
0: 		finalCostEstimate = getNewCostEstimate();
0: 		finalCostEstimate.setCost(
1: 			leftCE.getEstimatedCost() + rightCE.getEstimatedCost(),
1: 			getRowCountEstimate(leftCE.rowCount(), rightCE.rowCount()),
1: 			getSingleScanRowCountEstimate(leftCE.singleScanRowCount(),
1: 				rightCE.singleScanRowCount()));
1: 
0: 		return finalCostEstimate;
1: 	}
1: 
/////////////////////////////////////////////////////////////////////////
1:             // The result has at most leftRowCount rows and at least
1:             // max(0, leftRowCount - rightRowCount) rows.  Use the mean
1:             // of those two as the estimate.
1:             return (leftRowCount + Math.max(0, leftRowCount - rightRowCount))/2;
commit:66c825f
/////////////////////////////////////////////////////////////////////////
1: 		leftResultSet = optimizeSource(
1: 							optimizer,
1: 							leftResultSet,
1: 							(PredicateList) null,
1: 							outerCost);
1: 
1: 		rightResultSet = optimizeSource(
1: 							optimizer,
1: 							rightResultSet,
1: 							(PredicateList) null,
1: 							outerCost);
1: 
commit:a15163c
/////////////////////////////////////////////////////////////////////////
0: 			  nf.getNode(C_NodeTypes.INT_CONSTANT_NODE,
0: 				     ReuseFactory.getInteger( intermediateOrderByColumns[i] + 1),
0: 				     cm),
commit:47f9d0a
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derby.impl.sql.compile.IntersectNode
1: 
0:    Copyright 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package	org.apache.derby.impl.sql.compile;
1: 
1: import org.apache.derby.iapi.reference.ClassName;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.services.classfile.VMOpcode;
1: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1: import org.apache.derby.iapi.services.context.ContextManager;
1: 
0: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.iapi.sql.compile.NodeFactory;
1: import org.apache.derby.iapi.sql.compile.Optimizable;
0: import org.apache.derby.iapi.sql.compile.OptimizablePredicate;
1: import org.apache.derby.iapi.sql.compile.OptimizablePredicateList;
1: import org.apache.derby.iapi.sql.compile.Optimizer;
0: import org.apache.derby.iapi.sql.compile.CostEstimate;
1: import org.apache.derby.iapi.sql.compile.RowOrdering;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
1: 
1: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
1: 
0: import org.apache.derby.iapi.reference.SQLState;
1: 
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
1: 
1: import org.apache.derby.iapi.util.JBitSet;
0: import org.apache.derby.iapi.util.ReuseFactory;
1: 
0: import java.sql.Types;
1: 
0: import java.util.BitSet;
1: 
1: /**
1:  * A IntersectOrExceptNode represents an INTERSECT or EXCEPT DML statement.
1:  *
0:  * @author Jack Klebanoff
1:  */
1: 
1: public class IntersectOrExceptNode extends SetOperatorNode
1: {
1:     /* Currently we implement INTERSECT and EXCEPT by rewriting
1:      *   t1 (INTERSECT|EXCEPT) [ALL] t2
1:      * as (roughly)
1:      *   setOpResultSet( opType, all, (select * from t1 order by 1,2,...n), (select * from t2 ORDER BY 1,2,...,n))
1:      * where n is the number of columns in t1 (which must be the same as the number of columns in t2),
1:      * and opType is INTERSECT, or EXCEPT.
1:      *
1:      * The setOpResultSet result set simultaneously scans through its two ordered inputs and
1:      * performs the intersect or except.
1:      *
1:      * There are other query plans that may be more efficient, depending on the sizes. One plan is
1:      * to make a hash table from one of the input tables and then look up each row of the other input
1:      * table in the hash table.  However, we have not yet implemented spilling to disk in the
1:      * BackingStoreHashtable class: currently the whole hash table is in RAM. If we were to use it
1:      * we would blow up on large input tables.
1:      */
1: 
1:     private int opType;
1:     public static final int INTERSECT_OP = 1;
1:     public static final int EXCEPT_OP = 2;
1: 
1: 	/* Only optimize it once */
1: 	/* Only call addNewNodes() once */
1: 	private boolean addNewNodesCalled;
1: 
1:     private int[] intermediateOrderByColumns; // The input result sets will be ordered on these columns. 0 indexed
1:     private int[] intermediateOrderByDirection; // ascending = 1, descending = -1
1: 
1: 	/**
0: 	 * Initializer for a SetOperatorNode.
1: 	 *
1: 	 * @param leftResult		The ResultSetNode on the left side of this union
1: 	 * @param rightResult		The ResultSetNode on the right side of this union
0: 	 * @param all				Whether or not this is an ALL.
1: 	 * @param tableProperties	Properties list associated with the table
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public void init( Object opType,
0:                       Object leftResult,
0:                       Object rightResult,
0:                       Object all,
0:                       Object tableProperties)
1:         throws StandardException
1: 	{
0:         super.init( leftResult, rightResult, all, tableProperties);
0:         this.opType = ((Integer) opType).intValue();
1:     }
1: 
1:     private int getOpType()
1:     {
1:         return opType;
1:     }
1:     
1:     /**
1:      * Push order by lists down to the children so that we can implement the intersect/except
1:      * by scan of the two sorted inputs.
1: 	 *
1: 	 * @param numTables			Number of tables in the DML Statement
1: 	 * @param gbl				The group by list, if any
1: 	 * @param fromList			The from list, if any
1: 	 *
1: 	 * @return The preprocessed ResultSetNode that can be optimized
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public ResultSetNode preprocess(int numTables,
1: 									GroupByList gbl,
1: 									FromList fromList)
1: 								throws StandardException
1: 	{
1:         // RESOLVE: We are in a quandary as to when and how we should generate order by lists. SelectNode processing
1:         // requires order by lists at the start of preprocess. That is why we are doing it here. However we can
1:         // pick any column ordering. Depending on the child expressions the optimizer may be able to avoid a
1:         // sort if we pick the right column ordering. For instance if one of the child expressions is
1:         // "select <key columns>, <other expressions> from T" where there is a unique index on <key columns>
1:         // then we can just generate an order by on the key columns and the optimizer should use the unique index
1:         // to produce the sorted result set. However the ResultSetNode class does not make it easy to
1:         // find the structure of the query expression. Furthermore we most want to avoid a sort on the larger
1:         // input, but the size estimate is not available at preprocess time.
1: 
1:         intermediateOrderByColumns = new int[ getResultColumns().size()];
1:         intermediateOrderByDirection = new int[ intermediateOrderByColumns.length];
0:         /* If there is an order by on the result of the intersect then use that because we know that doing so
0:          * will avoid a sort.  If the output of the intersect/except is small relative to its inputs then in some
0:          * cases it would be better to sort the inputs on a different sequence of columns, but it is hard to analyze
0:          * the input query expressions to see if a sort can be avoided.
1:          */
0:         if( orderByList != null)
1:         {
1:             BitSet colsOrdered = new BitSet( intermediateOrderByColumns.length);
0:             int orderByListSize = orderByList.size();
1:             int intermediateOrderByIdx = 0;
1:             for( int i = 0; i < orderByListSize; i++)
1:             {
1:                 if( colsOrdered.get(i))
1:                     continue;
0:                 OrderByColumn orderByColumn = orderByList.getOrderByColumn(i);
1:                 intermediateOrderByDirection[intermediateOrderByIdx] = orderByColumn.isAscending() ? 1 : -1;
1:                 int columnIdx = orderByColumn.getResultColumn().getColumnPosition() - 1;
1:                 intermediateOrderByColumns[intermediateOrderByIdx] = columnIdx;
1:                 colsOrdered.set( columnIdx);
1:                 intermediateOrderByIdx++;
1:             }
1:             for( int i = 0; i < intermediateOrderByColumns.length; i++)
1:             {
1:                 if( ! colsOrdered.get(i))
1:                 {
1:                     intermediateOrderByDirection[intermediateOrderByIdx] = 1;
1:                     intermediateOrderByColumns[intermediateOrderByIdx] = i;
1:                     intermediateOrderByIdx++;
1:                 }
1:             }
0:             orderByList = null; // It will be pushed down.
1:         }
1:         else // The output of the intersect/except does not have to be ordered
1:         {
1:             // Pick an intermediate ordering that minimizes the cost.
1:             // RESOLVE: how do you do that?
1:             for( int i = 0; i < intermediateOrderByColumns.length; i++)
1:             {
1:                 intermediateOrderByDirection[i] = 1;
1:                 intermediateOrderByColumns[i] = i;
1:             }
1:         }
1:         pushOrderingDown( leftResultSet);
1:         pushOrderingDown( rightResultSet);
1: 
1:         return super.preprocess( numTables, gbl, fromList);
1:     } // end of preprocess
1: 
1:     private void pushOrderingDown( ResultSetNode rsn)
1:         throws StandardException
1:     {
1:         ContextManager cm = getContextManager();
0:         NodeFactory nf = getNodeFactory();
0:         OrderByList orderByList = (OrderByList) nf.getNode( C_NodeTypes.ORDER_BY_LIST, cm);
1:         for( int i = 0; i < intermediateOrderByColumns.length; i++)
1:         {
0:             OrderByColumn orderByColumn = (OrderByColumn)
0:               nf.getNode( C_NodeTypes.ORDER_BY_COLUMN,
0:                           ReuseFactory.getInteger( intermediateOrderByColumns[i] + 1),
0:                           cm);
0:             if( intermediateOrderByDirection[i] < 0)
1:                 orderByColumn.setDescending();
1:             orderByList.addOrderByColumn( orderByColumn);
1:         }
1:         orderByList.bindOrderByColumns( rsn);
1:         rsn.pushOrderByList( orderByList);
1:     } // end of pushOrderingDown
1:                                                             
1:     /**
1:      * @see org.apache.derby.iapi.sql.compile.Optimizable#estimateCost
1:      */
1:     public CostEstimate estimateCost( OptimizablePredicateList predList,
1:                                       ConglomerateDescriptor cd,
1:                                       CostEstimate outerCost,
1:                                       Optimizer optimizer,
1:                                       RowOrdering rowOrdering)
1:                           throws StandardException
1:     {
0: 		CostEstimate costEstimate = getCostEstimate(optimizer);
1:         CostEstimate leftCostEstimate = leftResultSet.getCostEstimate();
1:         CostEstimate rightCostEstimate = rightResultSet.getCostEstimate();
0:         // The cost is the sum of the two child costs plus the cost of sorting the union.
0:         costEstimate.setCost( leftCostEstimate.getEstimatedCost() + rightCostEstimate.getEstimatedCost(),
0:                               getRowCountEstimate( leftCostEstimate.rowCount(),
0:                                                    rightCostEstimate.rowCount()),
0:                               getSingleScanRowCountEstimate( leftCostEstimate.singleScanRowCount(),
0:                                                              rightCostEstimate.singleScanRowCount()));
1: 
0:         return costEstimate;
1:     } // End of estimateCost
1: 
1: 	/**
1: 	 * @see Optimizable#modifyAccessPath
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public Optimizable modifyAccessPath(JBitSet outerTables) throws StandardException
1: 	{
1: 		Optimizable retOptimizable;
1: 		retOptimizable = super.modifyAccessPath(outerTables);
1: 
1: 		/* We only want call addNewNodes() once */
1: 		if (addNewNodesCalled)
1: 		{
1: 			return retOptimizable;
1: 		}
1: 		return (Optimizable) addNewNodes();
1: 	}
1: 
1: 	/**
1: 	 * @see ResultSetNode#modifyAccessPaths
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public ResultSetNode modifyAccessPaths() throws StandardException
1: 	{
1: 		ResultSetNode retRSN;
1: 		retRSN = super.modifyAccessPaths();
1: 
1: 		/* We only want call addNewNodes() once */
1: 		if (addNewNodesCalled)
1: 		{
1: 			return retRSN;
1: 		}
1: 		return addNewNodes();
1: 	}
1: 
1: 	/**
1: 	 * Add any new ResultSetNodes that are necessary to the tree.
1: 	 * We wait until after optimization to do this in order to
1: 	 * make it easier on the optimizer.
1: 	 *
1: 	 * @return (Potentially new) head of the ResultSetNode tree.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	private ResultSetNode addNewNodes()
1: 		throws StandardException
1: 	{
1: 		/* Only call addNewNodes() once */
1: 		if (addNewNodesCalled)
1: 		{
1: 			return this;
1: 		}
1: 
1: 		addNewNodesCalled = true;
1: 
0:         if( orderByList == null)
1:             return this;
0:         // Generate an order by node on top of the intersect/except
0:         return (ResultSetNode) getNodeFactory().getNode( C_NodeTypes.ORDER_BY_NODE,
0:                                                          this,
0:                                                          orderByList,
0:                                                          tableProperties,
0:                                                          getContextManager());
1:     } // end of addNewNodes
1: 
1:     /**
1: 	 * Generate the code.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1:      */
0: 	public void generate( ActivationClassBuilder acb,
0:                           MethodBuilder mb)
1:         throws StandardException
1: 	{
1: 
1: 		/* Get the next ResultSet #, so that we can number this ResultSetNode, its
1: 		 * ResultColumnList and ResultSet.
1: 		 */
1: 		assignResultSetNumber();
1: 
1: 		// build up the tree.
1: 
1:         /* Generate the SetOpResultSet. Arguments:
1:          *  1) expression for left child ResultSet
1:          *  2) expression for right child ResultSet
1:          *  3) activation
1:          *  4) resultSetNumber
1:          *  5) estimated row count
1:          *  6) estimated cost
1:          *  7) opType
1:          *  8) all
0:          *  9) close method
0:          *  10) intermediateOrderByColumns saved object index
0:          *  11) intermediateOrderByDirection saved object index
1:          */
1: 
0: 		acb.pushGetResultSetFactoryExpression(mb); // instance for getUnionResultSet
1: 
1: 		getLeftResultSet().generate( acb, mb);
1: 		getRightResultSet().generate( acb, mb);
1: 
1: 		acb.pushThisAsActivation(mb);
0: 		mb.push(resultSetNumber);
0:         mb.push( costEstimate.getEstimatedRowCount());
0:         mb.push( costEstimate.getEstimatedCost());
1:         mb.push( getOpType());
1:         mb.push( all);
0:         closeMethodArgument(acb, mb);
1:         mb.push( getCompilerContext().addSavedObject( intermediateOrderByColumns));
1:         mb.push( getCompilerContext().addSavedObject( intermediateOrderByDirection));
1: 
1: 		mb.callMethod(VMOpcode.INVOKEINTERFACE,
1:                       (String) null,
1:                       "getSetOpResultSet",
0:                       ClassName.NoPutResultSet, 11);
1: 	} // end of generate
1: 
1:     String getOperatorName()
1:     {
1:         switch( opType)
1:         {
1:         case INTERSECT_OP:
1:             return "INTERSECT";
1: 
1:         case EXCEPT_OP:
1:             return "EXCEPT";
1:         }
1:         if( SanityManager.DEBUG)
1:             SanityManager.THROWASSERT( "Invalid intersectOrExcept opType: " + opType);
1:         return "?";
1:     }
1:     
1:     double getRowCountEstimate( double leftRowCount, double rightRowCount)
1:     {
1:         switch( opType)
1:         {
1:         case INTERSECT_OP:
1:             // The result has at most min( leftRowCount, rightRowCount). Estimate the actual row count at
1:             // half that.
1:             return Math.min( leftRowCount, rightRowCount)/2;
1: 
1:         case EXCEPT_OP:
0:             // The result has at most leftRowCount rows and at least min( 0, leftRowCount - rightRowCount) rows.
0:             // Use the mean of those two as the estimate.
0:             return (leftRowCount + Math.min( 0, leftRowCount - rightRowCount))/2;
1:         }
1:         if( SanityManager.DEBUG)
1:             SanityManager.THROWASSERT( "Invalid intersectOrExcept opType: " + opType);
1:         return 1.0;
1:     } // end of getRowCountEstimate
1:     
1:     double getSingleScanRowCountEstimate( double leftSingleScanRowCount, double rightSingleScanRowCount)
1:     {
1:         return getRowCountEstimate( leftSingleScanRowCount, rightSingleScanRowCount);
1:     }
1: }
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Derby - Class org.apache.derby.impl.sql.compile.IntersectNode
0: 
0:    Copyright 2004 The Apache Software Foundation or its licensors, as applicable.
0: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
0: 
0:       http://www.apache.org/licenses/LICENSE-2.0
0: 
0:    Unless required by applicable law or agreed to in writing, software
0:    distributed under the License is distributed on an "AS IS" BASIS,
0:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:    See the License for the specific language governing permissions and
0:    limitations under the License.
0: 
0:  */
0: 
0: package	org.apache.derby.impl.sql.compile;
0: 
0: import org.apache.derby.iapi.reference.ClassName;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.services.classfile.VMOpcode;
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
0: import org.apache.derby.iapi.services.context.ContextManager;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.sql.compile.NodeFactory;
0: import org.apache.derby.iapi.sql.compile.Optimizable;
0: import org.apache.derby.iapi.sql.compile.OptimizablePredicate;
0: import org.apache.derby.iapi.sql.compile.OptimizablePredicateList;
0: import org.apache.derby.iapi.sql.compile.Optimizer;
0: import org.apache.derby.iapi.sql.compile.CostEstimate;
0: import org.apache.derby.iapi.sql.compile.RowOrdering;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
0: 
0: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: 
0: import org.apache.derby.iapi.util.JBitSet;
0: import org.apache.derby.iapi.util.ReuseFactory;
0: 
0: import java.sql.Types;
0: 
0: import java.util.BitSet;
0: 
0: /**
0:  * A IntersectOrExceptNode represents an INTERSECT or EXCEPT DML statement.
0:  *
0:  * @author Jack Klebanoff
0:  */
0: 
0: public class IntersectOrExceptNode extends SetOperatorNode
0: {
0:     /* Currently we implement INTERSECT and EXCEPT by rewriting
0:      *   t1 (INTERSECT|EXCEPT) [ALL] t2
0:      * as (roughly)
0:      *   setOpResultSet( opType, all, (select * from t1 order by 1,2,...n), (select * from t2 ORDER BY 1,2,...,n))
0:      * where n is the number of columns in t1 (which must be the same as the number of columns in t2),
0:      * and opType is INTERSECT, or EXCEPT.
0:      *
0:      * The setOpResultSet result set simultaneously scans through its two ordered inputs and
0:      * performs the intersect or except.
0:      *
0:      * There are other query plans that may be more efficient, depending on the sizes. One plan is
0:      * to make a hash table from one of the input tables and then look up each row of the other input
0:      * table in the hash table.  However, we have not yet implemented spilling to disk in the
0:      * BackingStoreHashtable class: currently the whole hash table is in RAM. If we were to use it
0:      * we would blow up on large input tables.
0:      */
0: 
0:     private int opType;
0:     public static final int INTERSECT_OP = 1;
0:     public static final int EXCEPT_OP = 2;
0: 
0: 	/* Only optimize it once */
0: 	/* Only call addNewNodes() once */
0: 	private boolean addNewNodesCalled;
0: 
0:     private int[] intermediateOrderByColumns; // The input result sets will be ordered on these columns. 0 indexed
0:     private int[] intermediateOrderByDirection; // ascending = 1, descending = -1
0: 
0: 	/**
0: 	 * Initializer for a SetOperatorNode.
0: 	 *
0: 	 * @param leftResult		The ResultSetNode on the left side of this union
0: 	 * @param rightResult		The ResultSetNode on the right side of this union
0: 	 * @param all				Whether or not this is an ALL.
0: 	 * @param tableProperties	Properties list associated with the table
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public void init( Object opType,
0:                       Object leftResult,
0:                       Object rightResult,
0:                       Object all,
0:                       Object tableProperties)
0:         throws StandardException
0: 	{
0:         super.init( leftResult, rightResult, all, tableProperties);
0:         this.opType = ((Integer) opType).intValue();
0:     }
0: 
0:     private int getOpType()
0:     {
0:         return opType;
0:     }
0:     
0:     /**
0:      * Push order by lists down to the children so that we can implement the intersect/except
0:      * by scan of the two sorted inputs.
0: 	 *
0: 	 * @param numTables			Number of tables in the DML Statement
0: 	 * @param gbl				The group by list, if any
0: 	 * @param fromList			The from list, if any
0: 	 *
0: 	 * @return The preprocessed ResultSetNode that can be optimized
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public ResultSetNode preprocess(int numTables,
0: 									GroupByList gbl,
0: 									FromList fromList)
0: 								throws StandardException
0: 	{
0:         // RESOLVE: We are in a quandary as to when and how we should generate order by lists. SelectNode processing
0:         // requires order by lists at the start of preprocess. That is why we are doing it here. However we can
0:         // pick any column ordering. Depending on the child expressions the optimizer may be able to avoid a
0:         // sort if we pick the right column ordering. For instance if one of the child expressions is
0:         // "select <key columns>, <other expressions> from T" where there is a unique index on <key columns>
0:         // then we can just generate an order by on the key columns and the optimizer should use the unique index
0:         // to produce the sorted result set. However the ResultSetNode class does not make it easy to
0:         // find the structure of the query expression. Furthermore we most want to avoid a sort on the larger
0:         // input, but the size estimate is not available at preprocess time.
0: 
0:         intermediateOrderByColumns = new int[ getResultColumns().size()];
0:         intermediateOrderByDirection = new int[ intermediateOrderByColumns.length];
0:         /* If there is an order by on the result of the intersect then use that because we know that doing so
0:          * will avoid a sort.  If the output of the intersect/except is small relative to its inputs then in some
0:          * cases it would be better to sort the inputs on a different sequence of columns, but it is hard to analyze
0:          * the input query expressions to see if a sort can be avoided.
0:          */
0:         if( orderByList != null)
0:         {
0:             BitSet colsOrdered = new BitSet( intermediateOrderByColumns.length);
0:             int orderByListSize = orderByList.size();
0:             int intermediateOrderByIdx = 0;
0:             for( int i = 0; i < orderByListSize; i++)
0:             {
0:                 if( colsOrdered.get(i))
0:                     continue;
0:                 OrderByColumn orderByColumn = orderByList.getOrderByColumn(i);
0:                 intermediateOrderByDirection[intermediateOrderByIdx] = orderByColumn.isAscending() ? 1 : -1;
0:                 int columnIdx = orderByColumn.getResultColumn().getColumnPosition() - 1;
0:                 intermediateOrderByColumns[intermediateOrderByIdx] = columnIdx;
0:                 colsOrdered.set( columnIdx);
0:                 intermediateOrderByIdx++;
0:             }
0:             for( int i = 0; i < intermediateOrderByColumns.length; i++)
0:             {
0:                 if( ! colsOrdered.get(i))
0:                 {
0:                     intermediateOrderByDirection[intermediateOrderByIdx] = 1;
0:                     intermediateOrderByColumns[intermediateOrderByIdx] = i;
0:                     intermediateOrderByIdx++;
0:                 }
0:             }
0:             orderByList = null; // It will be pushed down.
0:         }
0:         else // The output of the intersect/except does not have to be ordered
0:         {
0:             // Pick an intermediate ordering that minimizes the cost.
0:             // RESOLVE: how do you do that?
0:             for( int i = 0; i < intermediateOrderByColumns.length; i++)
0:             {
0:                 intermediateOrderByDirection[i] = 1;
0:                 intermediateOrderByColumns[i] = i;
0:             }
0:         }
0:         pushOrderingDown( leftResultSet);
0:         pushOrderingDown( rightResultSet);
0: 
0:         return super.preprocess( numTables, gbl, fromList);
0:     } // end of preprocess
0: 
0:     private void pushOrderingDown( ResultSetNode rsn)
0:         throws StandardException
0:     {
0:         ContextManager cm = getContextManager();
0:         NodeFactory nf = getNodeFactory();
0:         OrderByList orderByList = (OrderByList) nf.getNode( C_NodeTypes.ORDER_BY_LIST, cm);
0:         for( int i = 0; i < intermediateOrderByColumns.length; i++)
0:         {
0:             OrderByColumn orderByColumn = (OrderByColumn)
0:               nf.getNode( C_NodeTypes.ORDER_BY_COLUMN,
0: 			  nf.getNode(C_NodeTypes.INT_CONSTANT_NODE,
0: 				     ReuseFactory.getInteger( intermediateOrderByColumns[i] + 1),
0: 				     cm),
0:                           cm);
0:             if( intermediateOrderByDirection[i] < 0)
0:                 orderByColumn.setDescending();
0:             orderByList.addOrderByColumn( orderByColumn);
0:         }
0:         orderByList.bindOrderByColumns( rsn);
0:         rsn.pushOrderByList( orderByList);
0:     } // end of pushOrderingDown
0:                                                             
0:     /**
0:      * @see org.apache.derby.iapi.sql.compile.Optimizable#estimateCost
0:      */
0:     public CostEstimate estimateCost( OptimizablePredicateList predList,
0:                                       ConglomerateDescriptor cd,
0:                                       CostEstimate outerCost,
0:                                       Optimizer optimizer,
0:                                       RowOrdering rowOrdering)
0:                           throws StandardException
0:     {
0: 		leftResultSet = optimizeSource(
0: 							optimizer,
0: 							leftResultSet,
0: 							(PredicateList) null,
0: 							outerCost);
0: 
0: 		rightResultSet = optimizeSource(
0: 							optimizer,
0: 							rightResultSet,
0: 							(PredicateList) null,
0: 							outerCost);
0: 
0: 		CostEstimate costEstimate = getCostEstimate(optimizer);
0:         CostEstimate leftCostEstimate = leftResultSet.getCostEstimate();
0:         CostEstimate rightCostEstimate = rightResultSet.getCostEstimate();
0:         // The cost is the sum of the two child costs plus the cost of sorting the union.
0:         costEstimate.setCost( leftCostEstimate.getEstimatedCost() + rightCostEstimate.getEstimatedCost(),
0:                               getRowCountEstimate( leftCostEstimate.rowCount(),
0:                                                    rightCostEstimate.rowCount()),
0:                               getSingleScanRowCountEstimate( leftCostEstimate.singleScanRowCount(),
0:                                                              rightCostEstimate.singleScanRowCount()));
0: 
0:         return costEstimate;
0:     } // End of estimateCost
0: 
0: 	/**
0: 	 * @see Optimizable#modifyAccessPath
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public Optimizable modifyAccessPath(JBitSet outerTables) throws StandardException
0: 	{
0: 		Optimizable retOptimizable;
0: 		retOptimizable = super.modifyAccessPath(outerTables);
0: 
0: 		/* We only want call addNewNodes() once */
0: 		if (addNewNodesCalled)
0: 		{
0: 			return retOptimizable;
0: 		}
0: 		return (Optimizable) addNewNodes();
0: 	}
0: 
0: 	/**
0: 	 * @see ResultSetNode#modifyAccessPaths
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public ResultSetNode modifyAccessPaths() throws StandardException
0: 	{
0: 		ResultSetNode retRSN;
0: 		retRSN = super.modifyAccessPaths();
0: 
0: 		/* We only want call addNewNodes() once */
0: 		if (addNewNodesCalled)
0: 		{
0: 			return retRSN;
0: 		}
0: 		return addNewNodes();
0: 	}
0: 
0: 	/**
0: 	 * Add any new ResultSetNodes that are necessary to the tree.
0: 	 * We wait until after optimization to do this in order to
0: 	 * make it easier on the optimizer.
0: 	 *
0: 	 * @return (Potentially new) head of the ResultSetNode tree.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	private ResultSetNode addNewNodes()
0: 		throws StandardException
0: 	{
0: 		/* Only call addNewNodes() once */
0: 		if (addNewNodesCalled)
0: 		{
0: 			return this;
0: 		}
0: 
0: 		addNewNodesCalled = true;
0: 
0:         if( orderByList == null)
0:             return this;
0:         // Generate an order by node on top of the intersect/except
0:         return (ResultSetNode) getNodeFactory().getNode( C_NodeTypes.ORDER_BY_NODE,
0:                                                          this,
0:                                                          orderByList,
0:                                                          tableProperties,
0:                                                          getContextManager());
0:     } // end of addNewNodes
0: 
0:     /**
0: 	 * Generate the code.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0:      */
0: 	public void generate( ActivationClassBuilder acb,
0:                           MethodBuilder mb)
0:         throws StandardException
0: 	{
0: 
0: 		/* Get the next ResultSet #, so that we can number this ResultSetNode, its
0: 		 * ResultColumnList and ResultSet.
0: 		 */
0: 		assignResultSetNumber();
0: 
0: 		// build up the tree.
0: 
0:         /* Generate the SetOpResultSet. Arguments:
0:          *  1) expression for left child ResultSet
0:          *  2) expression for right child ResultSet
0:          *  3) activation
0:          *  4) resultSetNumber
0:          *  5) estimated row count
0:          *  6) estimated cost
0:          *  7) opType
0:          *  8) all
0:          *  9) close method
0:          *  10) intermediateOrderByColumns saved object index
0:          *  11) intermediateOrderByDirection saved object index
0:          */
0: 
0: 		acb.pushGetResultSetFactoryExpression(mb); // instance for getUnionResultSet
0: 
0: 		getLeftResultSet().generate( acb, mb);
0: 		getRightResultSet().generate( acb, mb);
0: 
0: 		acb.pushThisAsActivation(mb);
0: 		mb.push(resultSetNumber);
0:         mb.push( costEstimate.getEstimatedRowCount());
0:         mb.push( costEstimate.getEstimatedCost());
0:         mb.push( getOpType());
0:         mb.push( all);
0:         closeMethodArgument(acb, mb);
0:         mb.push( getCompilerContext().addSavedObject( intermediateOrderByColumns));
0:         mb.push( getCompilerContext().addSavedObject( intermediateOrderByDirection));
0: 
0: 		mb.callMethod(VMOpcode.INVOKEINTERFACE,
0:                       (String) null,
0:                       "getSetOpResultSet",
0:                       ClassName.NoPutResultSet, 11);
0: 	} // end of generate
0: 
0:     String getOperatorName()
0:     {
0:         switch( opType)
0:         {
0:         case INTERSECT_OP:
0:             return "INTERSECT";
0: 
0:         case EXCEPT_OP:
0:             return "EXCEPT";
0:         }
0:         if( SanityManager.DEBUG)
0:             SanityManager.THROWASSERT( "Invalid intersectOrExcept opType: " + opType);
0:         return "?";
0:     }
0:     
0:     double getRowCountEstimate( double leftRowCount, double rightRowCount)
0:     {
0:         switch( opType)
0:         {
0:         case INTERSECT_OP:
0:             // The result has at most min( leftRowCount, rightRowCount). Estimate the actual row count at
0:             // half that.
0:             return Math.min( leftRowCount, rightRowCount)/2;
0: 
0:         case EXCEPT_OP:
0:             // The result has at most leftRowCount rows and at least min( 0, leftRowCount - rightRowCount) rows.
0:             // Use the mean of those two as the estimate.
0:             return (leftRowCount + Math.min( 0, leftRowCount - rightRowCount))/2;
0:         }
0:         if( SanityManager.DEBUG)
0:             SanityManager.THROWASSERT( "Invalid intersectOrExcept opType: " + opType);
0:         return 1.0;
0:     } // end of getRowCountEstimate
0:     
0:     double getSingleScanRowCountEstimate( double leftSingleScanRowCount, double rightSingleScanRowCount)
0:     {
0:         return getRowCountEstimate( leftSingleScanRowCount, rightSingleScanRowCount);
0:     }
0: }
============================================================================