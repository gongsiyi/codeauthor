1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.jdbc.EmbedResultSetMetaData
1:345de35: 
1:88a3cb9:    Licensed to the Apache Software Foundation (ASF) under one or more
1:88a3cb9:    contributor license agreements.  See the NOTICE file distributed with
1:88a3cb9:    this work for additional information regarding copyright ownership.
1:88a3cb9:    The ASF licenses this file to you under the Apache License, Version 2.0
1:88a3cb9:    (the "License"); you may not use this file except in compliance with
1:88a3cb9:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
6:eac0369: 
2:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.jdbc;
1:eac0369: 
1:2e87a4c: import org.apache.derby.iapi.services.io.ArrayUtil;
1:eac0369: import org.apache.derby.iapi.sql.ResultColumnDescriptor;
1:eac0369: import org.apache.derby.iapi.types.DataTypeDescriptor;
1:eac0369: import org.apache.derby.iapi.types.DataTypeUtilities;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.reference.SQLState;
1:eac0369: 
1:eac0369: import java.sql.ResultSetMetaData;
1:eac0369: import java.sql.SQLException;
1:eac0369: import java.sql.Types;
1:eac0369: 
2:eac0369: /**
1:eac0369:  * A ResultSetMetaData object can be used to find out about the types
1:eac0369:  * and properties of the columns in a ResultSet.
1:eac0369:  *
1:eac0369:  * <p>
1:f512b2f:  * We take the (Derby) ResultDescription and examine it, to return
1:eac0369:  * the appropriate information.
1:eac0369: 
1:eac0369:    <P>
1:eac0369:    This class can be used outside of this package to convert a
1:eac0369:    ResultDescription into a ResultSetMetaData object.
1:f512b2f:    <P>
1:f512b2f:    EmbedResultSetMetaData objects are shared across multiple threads
1:f512b2f:    by being stored in the ResultDescription for a compiled plan.
1:f512b2f:    If the required api for ResultSetMetaData ever changes so
1:f512b2f:    that it has a close() method, a getConnection() method or
1:f512b2f:    any other Connection or ResultSet specific method then
1:f512b2f:    this sharing must be removed.
1:eac0369:  *
1:eac0369:  */
1:8514aa2: public class EmbedResultSetMetaData implements ResultSetMetaData {
1:eac0369: 
1:eac0369: 	private final ResultColumnDescriptor[] columnInfo;
1:eac0369: 
1:eac0369: 	//
1:eac0369: 	// constructor
1:eac0369: 	//
1:eac0369: 	public EmbedResultSetMetaData(ResultColumnDescriptor[] columnInfo) {
1:3f7581c:         this.columnInfo = ArrayUtil.copy(columnInfo);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	//
1:eac0369: 	// ResultSetMetaData interface
1:eac0369: 	//
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * What's the number of columns in the ResultSet?
1:eac0369:      *
1:eac0369:      * @return the number
1:eac0369:      */
1:f512b2f: 	public final int getColumnCount()	{
1:f512b2f: 		return columnInfo.length;
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Is the column automatically numbered, thus read-only?
1:eac0369:      *
1:eac0369:      * @param column the first column is 1, the second is 2, ...
2:eac0369:      * @return true if so
2:eac0369: 	 * @exception SQLException thrown on failure
1:eac0369:      *
1:eac0369:      */
1:f512b2f: 	public final boolean isAutoIncrement(int column) throws SQLException	{
1:f512b2f:         validColumnNumber(column);
1:eac0369: 		ResultColumnDescriptor rcd = columnInfo[column - 1];
1:eac0369: 		return rcd.isAutoincrement();
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Does a column's case matter?
1:eac0369:      *
1:eac0369:      * @param column the first column is 1, the second is 2, ...
1:eac0369:      * @return true if so
1:eac0369: 	 * @exception SQLException thrown on failure
1:eac0369:      */
1:f512b2f: 	public final boolean isCaseSensitive(int column) throws SQLException	{
1:eac0369: 	  return DataTypeUtilities.isCaseSensitive(getColumnTypeDescriptor(column));
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Can the column be used in a where clause?
1:eac0369:      *
1:eac0369:      * @param column the first column is 1, the second is 2, ...
1:eac0369:      * @return true if so
1:eac0369: 	 * @exception SQLException thrown on failure
1:eac0369:      */
1:f512b2f: 	public final boolean isSearchable(int column) throws SQLException	{
1:eac0369: 		validColumnNumber(column);
1:eac0369: 
1:eac0369: 		// we have no restrictions yet, so this is always true
1:eac0369: 		// might eventually be false for e.g. extra-long columns?
1:eac0369: 		return true;
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:c66c15d:      * Is the column a cash value? Always returns false since there
1:c66c15d:      * are no currency data types in Derby.
1:eac0369:      *
1:eac0369:      * @param column the first column is 1, the second is 2, ...
1:c66c15d:      * @return false, always
1:c66c15d:      * @exception SQLException thrown on failure
1:eac0369:      */
1:f512b2f: 	public final boolean isCurrency(int column) throws SQLException	{
1:c66c15d: 		return false;
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Can you put a NULL in this column?
1:eac0369:      *
1:eac0369:      * @param column the first column is 1, the second is 2, ...
1:eac0369:      * @return columnNoNulls, columnNullable or columnNullableUnknown
1:eac0369: 	 * @exception SQLException thrown on failure
1:eac0369:      */
1:f512b2f: 	public final int isNullable(int column) throws SQLException	{
1:eac0369: 		return DataTypeUtilities.isNullable(getColumnTypeDescriptor(column));
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Is the column a signed number?
1:eac0369:      *
1:eac0369:      * @param column the first column is 1, the second is 2, ...
1:eac0369:      * @return true if so
1:eac0369: 	 * @exception SQLException thrown on failure
1:eac0369:      */
1:f512b2f: 	public final boolean isSigned(int column) throws SQLException	{
1:eac0369: 		return DataTypeUtilities.isSigned(getColumnTypeDescriptor(column));
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * What's the column's normal max width in chars?
1:eac0369:      *
1:eac0369:      * @param column the first column is 1, the second is 2, ...
1:eac0369:      * @return max width
1:eac0369: 	 * @exception SQLException thrown on failure
1:eac0369:      */
1:f512b2f: 	public final int getColumnDisplaySize(int column) throws SQLException	{
1:eac0369: 		return DataTypeUtilities.getColumnDisplaySize(getColumnTypeDescriptor(column));
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * What's the suggested column title for use in printouts and
1:eac0369:      * displays?
1:eac0369:      *
1:eac0369:      * @param column the first column is 1, the second is 2, ...
1:eac0369:      * @return true if so
1:eac0369: 	 * @exception SQLException thrown on failure
1:eac0369:      */
1:f512b2f: 	public final String getColumnLabel(int column) throws SQLException {
1:eac0369: 		ResultColumnDescriptor cd = columnInfo[column - 1];
1:eac0369: 		String s = cd.getName();
1:eac0369: 
1:eac0369: 		// we could get fancier than this, but it's simple
1:eac0369:     	return (s==null? "Column"+Integer.toString(column) : s);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * What's a column's name?
1:eac0369:      *
1:eac0369:      * @param column the first column is 1, the second is 2, ...
1:eac0369:      * @return column name
1:eac0369: 	 * @exception SQLException thrown on failure
1:eac0369:      */
1:f512b2f: 	public final String getColumnName(int column) throws SQLException	{
1:eac0369: 		ResultColumnDescriptor cd = columnInfo[column - 1];
1:eac0369: 		String s = cd.getName();
1:eac0369: 		// database returns null when no column name to differentiate from empty name
1:eac0369:     	return (s==null? "" : s);
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * What's a column's table's schema?
1:eac0369:      *
1:eac0369:      * @param column the first column is 1, the second is 2, ...
1:eac0369:      * @return schema name or "" if not applicable
1:eac0369: 	 * @exception SQLException thrown on failure
1:eac0369:      */
1:f512b2f: 	public final String getSchemaName(int column) throws SQLException	{
1:eac0369: 		ResultColumnDescriptor cd = columnInfo[column - 1];
1:eac0369: 
1:b57ee34: 		String s = cd.getSourceSchemaName();
1:eac0369: 		// database returns null when no schema name to differentiate from empty name
1:eac0369: 		return (s==null? "" : s);
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * What's a column's number of decimal digits?
1:eac0369:      *
1:eac0369:      * @param column the first column is 1, the second is 2, ...
1:eac0369:      * @return precision
1:eac0369: 	 * @exception SQLException thrown on failure
1:eac0369:      */
1:f512b2f: 	public final int getPrecision(int column) throws SQLException	{
1:eac0369: 		return DataTypeUtilities.getDigitPrecision(getColumnTypeDescriptor(column));
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * What's a column's number of digits to right of the decimal point?
1:eac0369:      *
1:eac0369:      * @param column the first column is 1, the second is 2, ...
1:eac0369:      * @return scale
1:eac0369: 	 * @exception SQLException thrown on failure
1:eac0369:      */
1:f512b2f: 	public final int getScale(int column) throws SQLException	{
1:eac0369: 		DataTypeDescriptor dtd = getColumnTypeDescriptor(column);
1:eac0369: 		// REMIND -- check it is valid to ask for scale
1:eac0369: 		return dtd.getScale();
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * What's a column's table name?
1:eac0369:      *
1:eac0369:      * @return table name or "" if not applicable
1:eac0369: 	 * @exception SQLException thrown on failure
1:eac0369:      */
1:f512b2f: 	public final String getTableName(int column) throws SQLException {
1:eac0369: 		ResultColumnDescriptor cd = columnInfo[column - 1];
1:eac0369: 		String s = cd.getSourceTableName();
1:eac0369: 
1:eac0369: 		// database returns null when no table name to differentiate from empty name
1:eac0369: 		return (s==null? "" : s);
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * What's a column's table's catalog name?
1:eac0369:      *
1:eac0369:      * @param column the first column is 1, the second is 2, ...
1:eac0369:      * @return column name or "" if not applicable.
1:eac0369: 	 * @exception SQLException thrown on failure
1:eac0369:      */
1:f512b2f: 	public final String getCatalogName(int column) throws SQLException {
1:eac0369: 		validColumnNumber(column);
1:eac0369: 		return "";
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * What's a column's SQL type?
1:eac0369:      *
1:eac0369:      * @param column the first column is 1, the second is 2, ...
1:eac0369:      * @return SQL type
1:eac0369:      * @see Types
1:eac0369: 	 * @exception SQLException thrown on failure
1:eac0369:      */
1:f512b2f: 	public final int getColumnType(int column) throws SQLException {
1:eac0369: 		DataTypeDescriptor dtd = getColumnTypeDescriptor(column);
1:eac0369: 		return dtd.getTypeId().getJDBCTypeId();
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * What's a column's data source specific type name?
1:eac0369:      *
1:eac0369:      * @param column the first column is 1, the second is 2, ...
1:eac0369:      * @return type name
1:eac0369: 	 * @exception SQLException thrown on failure
1:eac0369:      */
1:f512b2f: 	public final String getColumnTypeName(int column) throws SQLException	{
1:eac0369: 		DataTypeDescriptor dtd = getColumnTypeDescriptor(column);
1:eac0369: 		return dtd.getTypeId().getSQLTypeName();
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Is a column definitely not writable?
1:eac0369:      *
1:eac0369:      * @param column the first column is 1, the second is 2, ...
1:eac0369:      * @return true if so
1:eac0369: 	 * @exception SQLException thrown on failure
1:eac0369:      */
1:f512b2f: 	public final boolean isReadOnly(int column) throws SQLException {
1:eac0369: 		validColumnNumber(column);
1:eac0369: 
2:eac0369: 		// we just don't know if it is a base table column or not
2:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Is it possible for a write on the column to succeed?
1:eac0369:      *
1:eac0369:      * @param column the first column is 1, the second is 2, ...
1:eac0369:      * @return true if so
1:eac0369: 	 * @exception SQLException thrown on failure
1:eac0369:      */
1:f512b2f: 	public final boolean isWritable(int column) throws SQLException {
1:eac0369: 		validColumnNumber(column);
1:b57ee34: 		return columnInfo[column - 1].updatableByCursor();
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Will a write on the column definitely succeed?
1:eac0369:      *
1:eac0369:      * @param column the first column is 1, the second is 2, ...
1:eac0369:      * @return true if so
1:eac0369: 	 * @exception SQLException thrown on failure
1:eac0369:      */
1:f512b2f: 	public final boolean isDefinitelyWritable(int column) throws SQLException	{
1:eac0369: 		validColumnNumber(column);
1:eac0369: 
1:eac0369: 		// we just don't know if it is a base table column or not
1:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * class interface
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	private void validColumnNumber(int column) throws SQLException {
1:eac0369: 	  if (column < 1 ||
1:eac0369: 		        column > getColumnCount() )
1:eac0369: 			    throw Util.generateCsSQLException(
1:ce40a31:                       SQLState.COLUMN_NOT_FOUND, column);
1:eac0369: 	}
1:eac0369: 
1:f512b2f: 	private DataTypeDescriptor getColumnTypeDescriptor(int column) throws SQLException 
1:eac0369: 	{
1:eac0369: 		validColumnNumber(column);
1:eac0369: 
1:eac0369: 		ResultColumnDescriptor cd = columnInfo[column - 1];
1:eac0369: 
1:eac0369: 		return cd.getType();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/////////////////////////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	//	JDBC 2.0	-	New public methods
1:eac0369: 	//
1:eac0369: 	/////////////////////////////////////////////////////////////////////////
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * JDBC 2.0
1:eac0369:      *
1:eac0369:      * <p>Return the fully qualified name of the Java class whose instances 
1:eac0369:      * are manufactured if ResultSet.getObject() is called to retrieve a value 
1:eac0369:      * from the column.  ResultSet.getObject() may return a subClass of the
1:eac0369:      * class returned by this method.
1:eac0369: 	 *
1:eac0369: 	 * @exception SQLException Feature not inplemented for now.
1:eac0369:      */
1:f512b2f:     public final String getColumnClassName(int column) throws SQLException {
1:eac0369: 		
1:eac0369: 		return getColumnTypeDescriptor(column).getTypeId().getResultSetMetaDataTypeName();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	public static ResultColumnDescriptor getResultColumnDescriptor(String name, int jdcbTypeId, boolean nullable) {
1:eac0369: 
1:eac0369: 		return new org.apache.derby.impl.sql.GenericColumnDescriptor(
1:eac0369: 			name, DataTypeDescriptor.getBuiltInDataTypeDescriptor(jdcbTypeId, nullable));
1:eac0369: 	}
1:eac0369: 	public static ResultColumnDescriptor getResultColumnDescriptor(String name, int jdcbTypeId, boolean nullable, int length) {
1:eac0369: 
1:eac0369: 		return new org.apache.derby.impl.sql.GenericColumnDescriptor(
1:eac0369: 			name, DataTypeDescriptor.getBuiltInDataTypeDescriptor(jdcbTypeId, nullable, length));
1:eac0369: 	}
1:eac0369: 	public static ResultColumnDescriptor getResultColumnDescriptor(String name, DataTypeDescriptor dtd) {
1:eac0369: 		return new org.apache.derby.impl.sql.GenericColumnDescriptor(name, dtd);
1:eac0369: 	}
1:8514aa2: 
1:8514aa2:     // JDBC 4.0 - java.sql.Wrapper interface
1:8514aa2: 
1:8514aa2:     /**
1:8514aa2:      * Returns whether or not this instance implements the specified interface.
1:8514aa2:      *
1:8514aa2:      * @param iface the interface to check for
1:8514aa2:      * @return true if this implements the interface
1:8514aa2:      */
1:8514aa2:     public final boolean isWrapperFor(Class<?> iface) {
1:8514aa2:         return iface.isInstance(this);
1:8514aa2:     }
1:8514aa2: 
1:8514aa2:     /**
1:8514aa2:      * Returns {@code this} if this class implements the interface.
1:8514aa2:      *
1:8514aa2:      * @param iface the interface
1:8514aa2:      * @return an object that implements the interface
1:8514aa2:      * @throws SQLException if no object is found that implements the
1:8514aa2:      * interface
1:8514aa2:      */
1:8514aa2:     public final <T> T unwrap(Class<T> iface) throws SQLException {
1:8514aa2:         // Derby does not implement non-standard methods on JDBC objects,
1:8514aa2:         // hence return this if this class implements the interface
1:8514aa2:         // or throw an SQLException.
1:8514aa2:         try {
1:8514aa2:             return iface.cast(this);
1:8514aa2:         } catch (ClassCastException cce) {
1:8514aa2:             throw Util.generateCsSQLException(SQLState.UNABLE_TO_UNWRAP, iface);
1:8514aa2:         }
1:8514aa2:     }
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:ce40a31
/////////////////////////////////////////////////////////////////////////
1:                       SQLState.COLUMN_NOT_FOUND, column);
commit:eec86ed
/////////////////////////////////////////////////////////////////////////
0: public abstract class EmbedResultSetMetaData
commit:2e87a4c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.io.ArrayUtil;
/////////////////////////////////////////////////////////////////////////
0: 		this.columnInfo = (ResultColumnDescriptor[]) ArrayUtil.copy( columnInfo );
commit:88a3cb9
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Dyre Tjeldvoll
-------------------------------------------------------------------------------
commit:c66c15d
/////////////////////////////////////////////////////////////////////////
1:      * Is the column a cash value? Always returns false since there
1:      * are no currency data types in Derby.
1:      * @return false, always
1:      * @exception SQLException thrown on failure
1: 		return false;
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:8514aa2
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: public class EmbedResultSetMetaData implements ResultSetMetaData {
/////////////////////////////////////////////////////////////////////////
1: 
1:     // JDBC 4.0 - java.sql.Wrapper interface
1: 
1:     /**
1:      * Returns whether or not this instance implements the specified interface.
1:      *
1:      * @param iface the interface to check for
1:      * @return true if this implements the interface
1:      */
1:     public final boolean isWrapperFor(Class<?> iface) {
1:         return iface.isInstance(this);
1:     }
1: 
1:     /**
1:      * Returns {@code this} if this class implements the interface.
1:      *
1:      * @param iface the interface
1:      * @return an object that implements the interface
1:      * @throws SQLException if no object is found that implements the
1:      * interface
1:      */
1:     public final <T> T unwrap(Class<T> iface) throws SQLException {
1:         // Derby does not implement non-standard methods on JDBC objects,
1:         // hence return this if this class implements the interface
1:         // or throw an SQLException.
1:         try {
1:             return iface.cast(this);
1:         } catch (ClassCastException cce) {
1:             throw Util.generateCsSQLException(SQLState.UNABLE_TO_UNWRAP, iface);
1:         }
1:     }
commit:3f7581c
/////////////////////////////////////////////////////////////////////////
1:         this.columnInfo = ArrayUtil.copy(columnInfo);
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:f512b2f
/////////////////////////////////////////////////////////////////////////
1:  * We take the (Derby) ResultDescription and examine it, to return
1:    <P>
1:    EmbedResultSetMetaData objects are shared across multiple threads
1:    by being stored in the ResultDescription for a compiled plan.
1:    If the required api for ResultSetMetaData ever changes so
1:    that it has a close() method, a getConnection() method or
1:    any other Connection or ResultSet specific method then
1:    this sharing must be removed.
/////////////////////////////////////////////////////////////////////////
1: 	public final int getColumnCount()	{
1: 		return columnInfo.length;
/////////////////////////////////////////////////////////////////////////
1: 	public final boolean isAutoIncrement(int column) throws SQLException	{
1:         validColumnNumber(column);
/////////////////////////////////////////////////////////////////////////
1: 	public final boolean isCaseSensitive(int column) throws SQLException	{
/////////////////////////////////////////////////////////////////////////
1: 	public final boolean isSearchable(int column) throws SQLException	{
/////////////////////////////////////////////////////////////////////////
1: 	public final boolean isCurrency(int column) throws SQLException	{
/////////////////////////////////////////////////////////////////////////
1: 	public final int isNullable(int column) throws SQLException	{
/////////////////////////////////////////////////////////////////////////
1: 	public final boolean isSigned(int column) throws SQLException	{
/////////////////////////////////////////////////////////////////////////
1: 	public final int getColumnDisplaySize(int column) throws SQLException	{
/////////////////////////////////////////////////////////////////////////
1: 	public final String getColumnLabel(int column) throws SQLException {
/////////////////////////////////////////////////////////////////////////
1: 	public final String getColumnName(int column) throws SQLException	{
/////////////////////////////////////////////////////////////////////////
1: 	public final String getSchemaName(int column) throws SQLException	{
/////////////////////////////////////////////////////////////////////////
1: 	public final int getPrecision(int column) throws SQLException	{
/////////////////////////////////////////////////////////////////////////
1: 	public final int getScale(int column) throws SQLException	{
/////////////////////////////////////////////////////////////////////////
1: 	public final String getTableName(int column) throws SQLException {
/////////////////////////////////////////////////////////////////////////
1: 	public final String getCatalogName(int column) throws SQLException {
/////////////////////////////////////////////////////////////////////////
1: 	public final int getColumnType(int column) throws SQLException {
/////////////////////////////////////////////////////////////////////////
1: 	public final String getColumnTypeName(int column) throws SQLException	{
/////////////////////////////////////////////////////////////////////////
1: 	public final boolean isReadOnly(int column) throws SQLException {
/////////////////////////////////////////////////////////////////////////
1: 	public final boolean isWritable(int column) throws SQLException {
/////////////////////////////////////////////////////////////////////////
1: 	public final boolean isDefinitelyWritable(int column) throws SQLException	{
/////////////////////////////////////////////////////////////////////////
1: 	private DataTypeDescriptor getColumnTypeDescriptor(int column) throws SQLException 
/////////////////////////////////////////////////////////////////////////
1:     public final String getColumnClassName(int column) throws SQLException {
commit:b57ee34
/////////////////////////////////////////////////////////////////////////
1: 		String s = cd.getSourceSchemaName();
/////////////////////////////////////////////////////////////////////////
1: 		return columnInfo[column - 1].updatableByCursor();
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.jdbc.EmbedResultSetMetaData
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:1f9b9c4
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.jdbc
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.jdbc;
1: 
0: import org.apache.derby.iapi.sql.ResultDescription;
1: import org.apache.derby.iapi.sql.ResultColumnDescriptor;
1: import org.apache.derby.iapi.types.DataTypeDescriptor;
1: import org.apache.derby.iapi.types.DataTypeUtilities;
0: import org.apache.derby.iapi.types.TypeId;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: import org.apache.derby.iapi.reference.SQLState;
1: 
1: import java.sql.ResultSetMetaData;
1: import java.sql.SQLException;
1: import java.sql.Types;
0: import java.sql.ResultSet;
1: 
1: /**
1:  * A ResultSetMetaData object can be used to find out about the types
1:  * and properties of the columns in a ResultSet.
1:  *
1:  * <p>
0:  * We take the (cloudscape) ResultDescription and examine it, to return
1:  * the appropriate information.
1: 
1:    <P>
1:    This class can be used outside of this package to convert a
1:    ResultDescription into a ResultSetMetaData object.
1:  *
0:  * @author ames
1:  */
0: public class EmbedResultSetMetaData
0: 	implements ResultSetMetaData {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 
1: 	private final ResultColumnDescriptor[] columnInfo;
1: 
1: 	//
1: 	// constructor
1: 	//
1: 	public EmbedResultSetMetaData(ResultColumnDescriptor[] columnInfo) {
0: 		this.columnInfo = columnInfo;
1: 	}
1: 
1: 	//
1: 	// ResultSetMetaData interface
1: 	//
1: 
1:     /**
1:      * What's the number of columns in the ResultSet?
1:      *
1:      * @return the number
1:      */
0: 	public int getColumnCount()	{
0: 		return columnInfo == null ? 0 : columnInfo.length;
1: 	}
1: 
1:     /**
1:      * Is the column automatically numbered, thus read-only?
1:      *
1:      * @param column the first column is 1, the second is 2, ...
1:      * @return true if so
1: 	 * @exception SQLException thrown on failure
1:      *
1:      */
0: 	public boolean isAutoIncrement(int column) throws SQLException	{
1: 
1: 		ResultColumnDescriptor rcd = columnInfo[column - 1];
1: 		return rcd.isAutoincrement();
1: 	}
1: 
1:     /**
1:      * Does a column's case matter?
1:      *
1:      * @param column the first column is 1, the second is 2, ...
1:      * @return true if so
1: 	 * @exception SQLException thrown on failure
1:      */
0: 	public boolean isCaseSensitive(int column) throws SQLException	{
1: 	  return DataTypeUtilities.isCaseSensitive(getColumnTypeDescriptor(column));
1: 	}
1: 
1: 
1:     /**
1:      * Can the column be used in a where clause?
1:      *
1:      * @param column the first column is 1, the second is 2, ...
1:      * @return true if so
1: 	 * @exception SQLException thrown on failure
1:      */
0: 	public boolean isSearchable(int column) throws SQLException	{
1: 		validColumnNumber(column);
1: 
1: 		// we have no restrictions yet, so this is always true
1: 		// might eventually be false for e.g. extra-long columns?
1: 		return true;
1: 	}
1: 
1:     /**
0:      * Is the column a cash value?
1:      *
1:      * @param column the first column is 1, the second is 2, ...
1:      * @return true if so
1: 	 * @exception SQLException thrown on failure
1:      */
0: 	public boolean isCurrency(int column) throws SQLException	{
1: 
0: 		return DataTypeUtilities.isCurrency(getColumnTypeDescriptor(column));
1: 	}
1: 
1:     /**
1:      * Can you put a NULL in this column?
1:      *
1:      * @param column the first column is 1, the second is 2, ...
1:      * @return columnNoNulls, columnNullable or columnNullableUnknown
1: 	 * @exception SQLException thrown on failure
1:      */
0: 	public int isNullable(int column) throws SQLException	{
1: 		return DataTypeUtilities.isNullable(getColumnTypeDescriptor(column));
1: 	}
1: 
1:     /**
1:      * Is the column a signed number?
1:      *
1:      * @param column the first column is 1, the second is 2, ...
1:      * @return true if so
1: 	 * @exception SQLException thrown on failure
1:      */
0: 	public boolean isSigned(int column) throws SQLException	{
1: 		return DataTypeUtilities.isSigned(getColumnTypeDescriptor(column));
1: 	}
1: 
1: 
1:     /**
1:      * What's the column's normal max width in chars?
1:      *
1:      * @param column the first column is 1, the second is 2, ...
1:      * @return max width
1: 	 * @exception SQLException thrown on failure
1:      */
0: 	public int getColumnDisplaySize(int column) throws SQLException	{
1: 		return DataTypeUtilities.getColumnDisplaySize(getColumnTypeDescriptor(column));
1: 	}
1: 
1:     /**
1:      * What's the suggested column title for use in printouts and
1:      * displays?
1:      *
1:      * @param column the first column is 1, the second is 2, ...
1:      * @return true if so
1: 	 * @exception SQLException thrown on failure
1:      */
0: 	public String getColumnLabel(int column) throws SQLException {
1: 		ResultColumnDescriptor cd = columnInfo[column - 1];
1: 		String s = cd.getName();
1: 
1: 		// we could get fancier than this, but it's simple
1:     	return (s==null? "Column"+Integer.toString(column) : s);
1: 	}
1: 
1: 
1:     /**
1:      * What's a column's name?
1:      *
1:      * @param column the first column is 1, the second is 2, ...
1:      * @return column name
1: 	 * @exception SQLException thrown on failure
1:      */
0: 	public String getColumnName(int column) throws SQLException	{
1: 		ResultColumnDescriptor cd = columnInfo[column - 1];
1: 		String s = cd.getName();
1: 		// database returns null when no column name to differentiate from empty name
1:     	return (s==null? "" : s);
1: 
1: 	}
1: 
1: 
1:     /**
1:      * What's a column's table's schema?
1:      *
1:      * @param column the first column is 1, the second is 2, ...
1:      * @return schema name or "" if not applicable
1: 	 * @exception SQLException thrown on failure
1:      */
0: 	public String getSchemaName(int column) throws SQLException	{
1: 		ResultColumnDescriptor cd = columnInfo[column - 1];
1: 
0: 		String s = cd.getSchemaName();
1: 		// database returns null when no schema name to differentiate from empty name
1: 		return (s==null? "" : s);
1: 	}
1: 
1:     /**
1:      * What's a column's number of decimal digits?
1:      *
1:      * @param column the first column is 1, the second is 2, ...
1:      * @return precision
1: 	 * @exception SQLException thrown on failure
1:      */
0: 	public int getPrecision(int column) throws SQLException	{
1: 		return DataTypeUtilities.getDigitPrecision(getColumnTypeDescriptor(column));
1: 	}
1: 
1: 
1:     /**
1:      * What's a column's number of digits to right of the decimal point?
1:      *
1:      * @param column the first column is 1, the second is 2, ...
1:      * @return scale
1: 	 * @exception SQLException thrown on failure
1:      */
0: 	public int getScale(int column) throws SQLException	{
1: 		DataTypeDescriptor dtd = getColumnTypeDescriptor(column);
1: 		// REMIND -- check it is valid to ask for scale
1: 		return dtd.getScale();
1: 	}
1: 
1:     /**
1:      * What's a column's table name?
1:      *
1:      * @return table name or "" if not applicable
1: 	 * @exception SQLException thrown on failure
1:      */
0: 	public String getTableName(int column) throws SQLException {
1: 		ResultColumnDescriptor cd = columnInfo[column - 1];
1: 		String s = cd.getSourceTableName();
1: 
1: 		// database returns null when no table name to differentiate from empty name
1: 		return (s==null? "" : s);
1: 	}
1: 
1:     /**
1:      * What's a column's table's catalog name?
1:      *
1:      * @param column the first column is 1, the second is 2, ...
1:      * @return column name or "" if not applicable.
1: 	 * @exception SQLException thrown on failure
1:      */
0: 	public String getCatalogName(int column) throws SQLException {
1: 		validColumnNumber(column);
1: 		return "";
1: 	}
1: 
1:     /**
1:      * What's a column's SQL type?
1:      *
1:      * @param column the first column is 1, the second is 2, ...
1:      * @return SQL type
1:      * @see Types
1: 	 * @exception SQLException thrown on failure
1:      */
0: 	public int getColumnType(int column) throws SQLException {
1: 		DataTypeDescriptor dtd = getColumnTypeDescriptor(column);
1: 		return dtd.getTypeId().getJDBCTypeId();
1: 	}
1: 
1:     /**
1:      * What's a column's data source specific type name?
1:      *
1:      * @param column the first column is 1, the second is 2, ...
1:      * @return type name
1: 	 * @exception SQLException thrown on failure
1:      */
0: 	public String getColumnTypeName(int column) throws SQLException	{
1: 		DataTypeDescriptor dtd = getColumnTypeDescriptor(column);
1: 		return dtd.getTypeId().getSQLTypeName();
1: 	}
1: 
1:     /**
1:      * Is a column definitely not writable?
1:      *
1:      * @param column the first column is 1, the second is 2, ...
1:      * @return true if so
1: 	 * @exception SQLException thrown on failure
1:      */
0: 	public boolean isReadOnly(int column) throws SQLException {
1: 		validColumnNumber(column);
1: 
1: 		// we just don't know if it is a base table column or not
1: 		return false;
1: 	}
1: 
1:     /**
1:      * Is it possible for a write on the column to succeed?
1:      *
1:      * @param column the first column is 1, the second is 2, ...
1:      * @return true if so
1: 	 * @exception SQLException thrown on failure
1:      */
0: 	public boolean isWritable(int column) throws SQLException {
1: 		validColumnNumber(column);
1: 
1: 		// we just don't know if it is a base table column or not
1: 		return false;
1: 	}
1: 
1:     /**
1:      * Will a write on the column definitely succeed?
1:      *
1:      * @param column the first column is 1, the second is 2, ...
1:      * @return true if so
1: 	 * @exception SQLException thrown on failure
1:      */
0: 	public boolean isDefinitelyWritable(int column) throws SQLException	{
1: 		validColumnNumber(column);
1: 
1: 		// we just don't know if it is a base table column or not
1: 		return false;
1: 	}
1: 
1: 	/*
1: 	 * class interface
1: 	 */
1: 
1: 	private void validColumnNumber(int column) throws SQLException {
1: 	  if (column < 1 ||
1: 		        column > getColumnCount() )
1: 			    throw Util.generateCsSQLException(
0:                       SQLState.COLUMN_NOT_FOUND, new Integer(column));
1: 	}
1: 
0: 	public DataTypeDescriptor getColumnTypeDescriptor(int column) throws SQLException 
1: 	{
1: 		validColumnNumber(column);
1: 
1: 		ResultColumnDescriptor cd = columnInfo[column - 1];
1: 
1: 		return cd.getType();
1: 	}
1: 
1: 	/////////////////////////////////////////////////////////////////////////
1: 	//
1: 	//	JDBC 2.0	-	New public methods
1: 	//
1: 	/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * JDBC 2.0
1:      *
1:      * <p>Return the fully qualified name of the Java class whose instances 
1:      * are manufactured if ResultSet.getObject() is called to retrieve a value 
1:      * from the column.  ResultSet.getObject() may return a subClass of the
1:      * class returned by this method.
1: 	 *
1: 	 * @exception SQLException Feature not inplemented for now.
1:      */
0:     public String getColumnClassName(int column) throws SQLException {
1: 		
1: 		return getColumnTypeDescriptor(column).getTypeId().getResultSetMetaDataTypeName();
1: 	}
1: 
1: 
1: 	public static ResultColumnDescriptor getResultColumnDescriptor(String name, int jdcbTypeId, boolean nullable) {
1: 
1: 		return new org.apache.derby.impl.sql.GenericColumnDescriptor(
1: 			name, DataTypeDescriptor.getBuiltInDataTypeDescriptor(jdcbTypeId, nullable));
1: 	}
1: 	public static ResultColumnDescriptor getResultColumnDescriptor(String name, int jdcbTypeId, boolean nullable, int length) {
1: 
1: 		return new org.apache.derby.impl.sql.GenericColumnDescriptor(
1: 			name, DataTypeDescriptor.getBuiltInDataTypeDescriptor(jdcbTypeId, nullable, length));
1: 	}
1: 	public static ResultColumnDescriptor getResultColumnDescriptor(String name, DataTypeDescriptor dtd) {
1: 		return new org.apache.derby.impl.sql.GenericColumnDescriptor(name, dtd);
1: 	}
1: }
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.jdbc
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.jdbc;
0: 
0: import org.apache.derby.iapi.sql.ResultDescription;
0: import org.apache.derby.iapi.sql.ResultColumnDescriptor;
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: import org.apache.derby.iapi.types.DataTypeUtilities;
0: import org.apache.derby.iapi.types.TypeId;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import java.sql.ResultSetMetaData;
0: import java.sql.SQLException;
0: import java.sql.Types;
0: import java.sql.ResultSet;
0: 
0: /**
0:  * A ResultSetMetaData object can be used to find out about the types
0:  * and properties of the columns in a ResultSet.
0:  *
0:  * <p>
0:  * We take the (cloudscape) ResultDescription and examine it, to return
0:  * the appropriate information.
0: 
0:    <P>
0:    This class can be used outside of this package to convert a
0:    ResultDescription into a ResultSetMetaData object.
0:  *
0:  * @author ames
0:  */
0: public class EmbedResultSetMetaData
0: 	implements ResultSetMetaData {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 
0: 	private final ResultColumnDescriptor[] columnInfo;
0: 
0: 	//
0: 	// constructor
0: 	//
0: 	public EmbedResultSetMetaData(ResultColumnDescriptor[] columnInfo) {
0: 		this.columnInfo = columnInfo;
0: 	}
0: 
0: 	//
0: 	// ResultSetMetaData interface
0: 	//
0: 
0:     /**
0:      * What's the number of columns in the ResultSet?
0:      *
0:      * @return the number
0:      */
0: 	public int getColumnCount()	{
0: 		return columnInfo == null ? 0 : columnInfo.length;
0: 	}
0: 
0:     /**
0:      * Is the column automatically numbered, thus read-only?
0:      *
0:      * @param column the first column is 1, the second is 2, ...
0:      * @return true if so
0: 	 * @exception SQLException thrown on failure
0:      *
0:      */
0: 	public boolean isAutoIncrement(int column) throws SQLException	{
0: 
0: 		ResultColumnDescriptor rcd = columnInfo[column - 1];
0: 		return rcd.isAutoincrement();
0: 	}
0: 
0:     /**
0:      * Does a column's case matter?
0:      *
0:      * @param column the first column is 1, the second is 2, ...
0:      * @return true if so
0: 	 * @exception SQLException thrown on failure
0:      */
0: 	public boolean isCaseSensitive(int column) throws SQLException	{
0: 	  return DataTypeUtilities.isCaseSensitive(getColumnTypeDescriptor(column));
0: 	}
0: 
0: 
0:     /**
0:      * Can the column be used in a where clause?
0:      *
0:      * @param column the first column is 1, the second is 2, ...
0:      * @return true if so
0: 	 * @exception SQLException thrown on failure
0:      */
0: 	public boolean isSearchable(int column) throws SQLException	{
0: 		validColumnNumber(column);
0: 
0: 		// we have no restrictions yet, so this is always true
0: 		// might eventually be false for e.g. extra-long columns?
0: 		return true;
0: 	}
0: 
0:     /**
0:      * Is the column a cash value?
0:      *
0:      * @param column the first column is 1, the second is 2, ...
0:      * @return true if so
0: 	 * @exception SQLException thrown on failure
0:      */
0: 	public boolean isCurrency(int column) throws SQLException	{
0: 
0: 		return DataTypeUtilities.isCurrency(getColumnTypeDescriptor(column));
0: 	}
0: 
0:     /**
0:      * Can you put a NULL in this column?
0:      *
0:      * @param column the first column is 1, the second is 2, ...
0:      * @return columnNoNulls, columnNullable or columnNullableUnknown
0: 	 * @exception SQLException thrown on failure
0:      */
0: 	public int isNullable(int column) throws SQLException	{
0: 		return DataTypeUtilities.isNullable(getColumnTypeDescriptor(column));
0: 	}
0: 
0:     /**
0:      * Is the column a signed number?
0:      *
0:      * @param column the first column is 1, the second is 2, ...
0:      * @return true if so
0: 	 * @exception SQLException thrown on failure
0:      */
0: 	public boolean isSigned(int column) throws SQLException	{
0: 		return DataTypeUtilities.isSigned(getColumnTypeDescriptor(column));
0: 	}
0: 
0: 
0:     /**
0:      * What's the column's normal max width in chars?
0:      *
0:      * @param column the first column is 1, the second is 2, ...
0:      * @return max width
0: 	 * @exception SQLException thrown on failure
0:      */
0: 	public int getColumnDisplaySize(int column) throws SQLException	{
0: 		return DataTypeUtilities.getColumnDisplaySize(getColumnTypeDescriptor(column));
0: 	}
0: 
0:     /**
0:      * What's the suggested column title for use in printouts and
0:      * displays?
0:      *
0:      * @param column the first column is 1, the second is 2, ...
0:      * @return true if so
0: 	 * @exception SQLException thrown on failure
0:      */
0: 	public String getColumnLabel(int column) throws SQLException {
0: 		ResultColumnDescriptor cd = columnInfo[column - 1];
0: 		String s = cd.getName();
0: 
0: 		// we could get fancier than this, but it's simple
0:     	return (s==null? "Column"+Integer.toString(column) : s);
0: 	}
0: 
0: 
0:     /**
0:      * What's a column's name?
0:      *
0:      * @param column the first column is 1, the second is 2, ...
0:      * @return column name
0: 	 * @exception SQLException thrown on failure
0:      */
0: 	public String getColumnName(int column) throws SQLException	{
0: 		ResultColumnDescriptor cd = columnInfo[column - 1];
0: 		String s = cd.getName();
0: 		// database returns null when no column name to differentiate from empty name
0:     	return (s==null? "" : s);
0: 
0: 	}
0: 
0: 
0:     /**
0:      * What's a column's table's schema?
0:      *
0:      * @param column the first column is 1, the second is 2, ...
0:      * @return schema name or "" if not applicable
0: 	 * @exception SQLException thrown on failure
0:      */
0: 	public String getSchemaName(int column) throws SQLException	{
0: 		ResultColumnDescriptor cd = columnInfo[column - 1];
0: 
0: 		String s = cd.getSchemaName();
0: 		// database returns null when no schema name to differentiate from empty name
0: 		return (s==null? "" : s);
0: 	}
0: 
0:     /**
0:      * What's a column's number of decimal digits?
0:      *
0:      * @param column the first column is 1, the second is 2, ...
0:      * @return precision
0: 	 * @exception SQLException thrown on failure
0:      */
0: 	public int getPrecision(int column) throws SQLException	{
0: 		return DataTypeUtilities.getDigitPrecision(getColumnTypeDescriptor(column));
0: 	}
0: 
0: 
0:     /**
0:      * What's a column's number of digits to right of the decimal point?
0:      *
0:      * @param column the first column is 1, the second is 2, ...
0:      * @return scale
0: 	 * @exception SQLException thrown on failure
0:      */
0: 	public int getScale(int column) throws SQLException	{
0: 		DataTypeDescriptor dtd = getColumnTypeDescriptor(column);
0: 		// REMIND -- check it is valid to ask for scale
0: 		return dtd.getScale();
0: 	}
0: 
0:     /**
0:      * What's a column's table name?
0:      *
0:      * @return table name or "" if not applicable
0: 	 * @exception SQLException thrown on failure
0:      */
0: 	public String getTableName(int column) throws SQLException {
0: 		ResultColumnDescriptor cd = columnInfo[column - 1];
0: 		String s = cd.getSourceTableName();
0: 
0: 		// database returns null when no table name to differentiate from empty name
0: 		return (s==null? "" : s);
0: 	}
0: 
0:     /**
0:      * What's a column's table's catalog name?
0:      *
0:      * @param column the first column is 1, the second is 2, ...
0:      * @return column name or "" if not applicable.
0: 	 * @exception SQLException thrown on failure
0:      */
0: 	public String getCatalogName(int column) throws SQLException {
0: 		validColumnNumber(column);
0: 		return "";
0: 	}
0: 
0:     /**
0:      * What's a column's SQL type?
0:      *
0:      * @param column the first column is 1, the second is 2, ...
0:      * @return SQL type
0:      * @see Types
0: 	 * @exception SQLException thrown on failure
0:      */
0: 	public int getColumnType(int column) throws SQLException {
0: 		DataTypeDescriptor dtd = getColumnTypeDescriptor(column);
0: 		return dtd.getTypeId().getJDBCTypeId();
0: 	}
0: 
0:     /**
0:      * What's a column's data source specific type name?
0:      *
0:      * @param column the first column is 1, the second is 2, ...
0:      * @return type name
0: 	 * @exception SQLException thrown on failure
0:      */
0: 	public String getColumnTypeName(int column) throws SQLException	{
0: 		DataTypeDescriptor dtd = getColumnTypeDescriptor(column);
0: 		return dtd.getTypeId().getSQLTypeName();
0: 	}
0: 
0:     /**
0:      * Is a column definitely not writable?
0:      *
0:      * @param column the first column is 1, the second is 2, ...
0:      * @return true if so
0: 	 * @exception SQLException thrown on failure
0:      */
0: 	public boolean isReadOnly(int column) throws SQLException {
0: 		validColumnNumber(column);
0: 
0: 		// we just don't know if it is a base table column or not
0: 		return false;
0: 	}
0: 
0:     /**
0:      * Is it possible for a write on the column to succeed?
0:      *
0:      * @param column the first column is 1, the second is 2, ...
0:      * @return true if so
0: 	 * @exception SQLException thrown on failure
0:      */
0: 	public boolean isWritable(int column) throws SQLException {
0: 		validColumnNumber(column);
0: 
0: 		// we just don't know if it is a base table column or not
0: 		return false;
0: 	}
0: 
0:     /**
0:      * Will a write on the column definitely succeed?
0:      *
0:      * @param column the first column is 1, the second is 2, ...
0:      * @return true if so
0: 	 * @exception SQLException thrown on failure
0:      */
0: 	public boolean isDefinitelyWritable(int column) throws SQLException	{
0: 		validColumnNumber(column);
0: 
0: 		// we just don't know if it is a base table column or not
0: 		return false;
0: 	}
0: 
0: 	/*
0: 	 * class interface
0: 	 */
0: 
0: 	private void validColumnNumber(int column) throws SQLException {
0: 	  if (column < 1 ||
0: 		        column > getColumnCount() )
0: 			    throw Util.generateCsSQLException(
0:                       SQLState.COLUMN_NOT_FOUND, new Integer(column));
0: 	}
0: 
0: 	public DataTypeDescriptor getColumnTypeDescriptor(int column) throws SQLException 
0: 	{
0: 		validColumnNumber(column);
0: 
0: 		ResultColumnDescriptor cd = columnInfo[column - 1];
0: 
0: 		return cd.getType();
0: 	}
0: 
0: 	/////////////////////////////////////////////////////////////////////////
0: 	//
0: 	//	JDBC 2.0	-	New public methods
0: 	//
0: 	/////////////////////////////////////////////////////////////////////////
0: 
0:     /**
0:      * JDBC 2.0
0:      *
0:      * <p>Return the fully qualified name of the Java class whose instances 
0:      * are manufactured if ResultSet.getObject() is called to retrieve a value 
0:      * from the column.  ResultSet.getObject() may return a subClass of the
0:      * class returned by this method.
0: 	 *
0: 	 * @exception SQLException Feature not inplemented for now.
0:      */
0:     public String getColumnClassName(int column) throws SQLException {
0: 		
0: 		return getColumnTypeDescriptor(column).getTypeId().getResultSetMetaDataTypeName();
0: 	}
0: 
0: 
0: 	public static ResultColumnDescriptor getResultColumnDescriptor(String name, int jdcbTypeId, boolean nullable) {
0: 
0: 		return new org.apache.derby.impl.sql.GenericColumnDescriptor(
0: 			name, DataTypeDescriptor.getBuiltInDataTypeDescriptor(jdcbTypeId, nullable));
0: 	}
0: 	public static ResultColumnDescriptor getResultColumnDescriptor(String name, int jdcbTypeId, boolean nullable, int length) {
0: 
0: 		return new org.apache.derby.impl.sql.GenericColumnDescriptor(
0: 			name, DataTypeDescriptor.getBuiltInDataTypeDescriptor(jdcbTypeId, nullable, length));
0: 	}
0: 	public static ResultColumnDescriptor getResultColumnDescriptor(String name, DataTypeDescriptor dtd) {
0: 		return new org.apache.derby.impl.sql.GenericColumnDescriptor(name, dtd);
0: 	}
0: }
============================================================================