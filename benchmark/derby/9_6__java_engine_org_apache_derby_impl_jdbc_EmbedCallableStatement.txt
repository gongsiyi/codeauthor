2:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.jdbc.EmbedCallableStatement
1:345de35: 
1:88a3cb9:    Licensed to the Apache Software Foundation (ASF) under one or more
1:88a3cb9:    contributor license agreements.  See the NOTICE file distributed with
1:88a3cb9:    this work for additional information regarding copyright ownership.
1:88a3cb9:    The ASF licenses this file to you under the Apache License, Version 2.0
1:88a3cb9:    (the "License"); you may not use this file except in compliance with
1:88a3cb9:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
5:eac0369: 
6:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.jdbc;
1:eac0369: 
1:b5f2776: import java.io.ByteArrayInputStream;
1:b5f2776: import java.io.InputStream;
1:b5f2776: import java.io.InputStreamReader;
1:b5f2776: import java.io.Reader;
1:b5f2776: import java.io.StringReader;
1:b5f2776: import java.io.UnsupportedEncodingException;
1:eac0369: import org.apache.derby.iapi.sql.ParameterValueSet;
1:eac0369: import org.apache.derby.iapi.sql.Activation;
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: import org.apache.derby.iapi.types.DataValueDescriptor;
1:eac0369: 
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.reference.SQLState;
1:eac0369: 
1:10608cf: import java.math.BigDecimal;
1:3ff53d4: import java.net.URL;
1:b5f2776: import java.sql.Array;
1:3ff53d4: import java.sql.Blob;
1:eac0369: import java.sql.CallableStatement;
1:3ff53d4: import java.sql.Clob;
1:eac0369: import java.sql.SQLException;
1:eac0369: import java.sql.Date;
1:b5f2776: import java.sql.NClob;
1:e33b8d8: import java.sql.ParameterMetaData;
1:b5f2776: import java.sql.Ref;
1:b5f2776: import java.sql.RowId;
1:b5f2776: import java.sql.SQLXML;
1:a0118e1: import java.sql.Statement;
1:eac0369: import java.sql.Time;
1:eac0369: import java.sql.Timestamp;
1:b5f2776: import java.sql.Types;
1:3ff53d4: import java.util.Calendar;
1:b5f2776: import java.util.Map;
1:b5f2776: import org.apache.derby.iapi.jdbc.CharacterStreamDescriptor;
1:b5f2776: import org.apache.derby.iapi.jdbc.EngineCallableStatement;
1:b5f2776: import org.apache.derby.iapi.types.StringDataValue;
1:eac0369: 
5:eac0369: /**
1:eac0369:  * Local implementation.
1:3ff53d4:  *
1:eac0369:  */
1:b5f2776: public class EmbedCallableStatement extends EmbedPreparedStatement
1:b5f2776:     implements EngineCallableStatement
5:eac0369: {
1:eac0369: 	/*
1:eac0369: 	** True if we are of the form ? = CALL() -- i.e. true
1:eac0369: 	** if we have a return output parameter.
1:eac0369: 	*/
1:eac0369: 	private boolean hasReturnOutputParameter;
1:eac0369: 
1:eac0369: 	protected boolean	wasNull;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @exception SQLException thrown on failure
1:eac0369: 	 */
1:eac0369: 	public EmbedCallableStatement (EmbedConnection conn, String sql,
1:eac0369: 								   int resultSetType,
1:eac0369: 								   int resultSetConcurrency,
1:eac0369: 								   int resultSetHoldability)
1:eac0369: 		throws SQLException
1:eac0369: 	{
1:eac0369: 	    super(conn, sql, false, 
1:eac0369: 			  resultSetType,
1:eac0369: 			  resultSetConcurrency,
1:eac0369: 			  resultSetHoldability,
1:a0118e1: 			  Statement.NO_GENERATED_KEYS,
1:eac0369: 			  null,
1:eac0369: 			  null);
1:eac0369: 
1:eac0369: 		// mark our parameters as for a callable statement 
1:eac0369: 		ParameterValueSet pvs = getParms();
1:eac0369: 
1:eac0369: 		// do we have a return parameter?
1:eac0369: 		hasReturnOutputParameter = pvs.hasReturnOutputParameter();
5:eac0369: 	}
1:b5f2776: 
1:eac0369: 	protected void checkRequiresCallableStatement(Activation activation) {
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	protected final boolean executeStatement(Activation a,
1:eac0369:                      boolean executeQuery, boolean executeUpdate)
1:eac0369: 		throws SQLException
1:eac0369: 	{
1:eac0369: 		// need this additional check (it's also in the super.executeStatement
1:eac0369: 		// to ensure we have an activation for the getParams
1:eac0369: 		checkExecStatus();
1:eac0369: 		synchronized (getConnectionSynchronization())
1:eac0369: 		{
1:eac0369: 			wasNull = false;
1:616634f: 			//Don't fetch the getParms into a local varibale
1:616634f: 			//at this point because it is possible that the activation
1:616634f: 			//associated with this callable statement may have become
1:616634f: 			//stale. If the current activation is invalid, a new activation 
1:616634f: 			//will be created for it in executeStatement call below. 
1:616634f: 			//We should be using the ParameterValueSet associated with
1:616634f: 			//the activation associated to the CallableStatement after
1:616634f: 			//the executeStatement below. That ParameterValueSet is the
1:616634f: 			//right object to hold the return value from the CallableStatement.
1:eac0369: 			try
1:eac0369: 			{
1:616634f: 				getParms().validate();
4:eac0369: 			} catch (StandardException e)
1:eac0369: 			{
4:eac0369: 				throw EmbedResultSet.noStateChangeException(e);
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			/* KLUDGE - ? = CALL ... returns a ResultSet().  We
1:eac0369: 			 * need executeUpdate to be false in that case.
1:10608cf: 			 */
1:eac0369: 			boolean execResult = super.executeStatement(a, executeQuery,
1:eac0369: 				(executeUpdate && (! hasReturnOutputParameter)));
1:eac0369: 
1:616634f: 			//Fetch the getParms into a local variable now because the
1:616634f: 			//activation associated with a CallableStatement at this 
1:616634f: 			//point(after the executStatement) is the current activation. 
1:616634f: 			//We can now safely stuff the return value of the 
1:616634f: 			//CallableStatement into the following ParameterValueSet object.
1:eac0369: 			ParameterValueSet pvs = getParms();
1:eac0369: 
1:10608cf: 			/*
1:eac0369: 			** If we have a return parameter, then we
1:eac0369: 			** consume it from the returned ResultSet
1:eac0369: 			** reset the ResultSet set to null.
1:eac0369: 			*/
1:eac0369: 			if (hasReturnOutputParameter)
1:eac0369: 			{
1:eac0369: 				if (SanityManager.DEBUG)
1:eac0369: 				{
1:eac0369: 					SanityManager.ASSERT(results!=null, "null results even though we are supposed to have a return parameter");
1:eac0369: 				}
1:eac0369: 				boolean gotRow = results.next();
1:eac0369: 				if (SanityManager.DEBUG)
1:eac0369: 				{
1:eac0369: 					SanityManager.ASSERT(gotRow, "the return resultSet didn't have any rows");
1:eac0369: 				}
1:eac0369: 
1:eac0369: 				try
1:eac0369: 				{
1:698e318: 					DataValueDescriptor returnValue = pvs.getReturnValueForSet();
1:698e318: 					returnValue.setValueFromResultSet(results, 1, true);
1:eac0369: 				} catch (StandardException e)
1:eac0369: 				{
1:eac0369: 					throw EmbedResultSet.noStateChangeException(e);
1:eac0369: 				}
1:eac0369: 				finally {
1:4c8f570: 					results.close();
1:eac0369: 					results = null;
1:eac0369: 				}
1:eac0369: 
1:eac0369: 				// This is a form of ? = CALL which current is not a procedure call.
1:eac0369: 				// Thus there cannot be any user result sets, so return false. execResult
1:eac0369: 				// is set to true since a result set was returned, for the return parameter.
1:eac0369: 				execResult = false;
1:eac0369: 			}
1:eac0369: 			return execResult;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	* CallableStatement interface
1:eac0369: 	* (the PreparedStatement part implemented by EmbedPreparedStatement)
1:eac0369: 	*/
1:eac0369: 
1:10608cf: 	/**
1:eac0369: 	 * @see CallableStatement#registerOutParameter
2:eac0369: 	 * @exception SQLException NoOutputParameters thrown.
1:eac0369: 	 */
1:eac0369: 	public final void registerOutParameter(int parameterIndex, int sqlType)
1:eac0369: 		throws SQLException 
1:eac0369: 	{
4:eac0369: 		checkStatus();
1:eac0369: 
4:eac0369: 		try {
1:eac0369: 			getParms().registerOutParameter(parameterIndex-1, sqlType, -1);
1:eac0369: 		} catch (StandardException e)
1:eac0369: 		{
1:eac0369: 			throw EmbedResultSet.noStateChangeException(e);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:94df7fb:     /**
1:eac0369: 	 * @see CallableStatement#registerOutParameter
1:eac0369:      * @exception SQLException NoOutputParameters thrown.
1:eac0369:      */
1:eac0369:     public final void registerOutParameter(int parameterIndex, int sqlType, int scale)
1:eac0369: 	    throws SQLException 
1:eac0369: 	{
1:eac0369: 		checkStatus();
1:eac0369: 
1:eac0369: 		if (scale < 0)
1:ce40a31: 			throw newSQLException(SQLState.BAD_SCALE_VALUE, scale);
1:eac0369: 		try {
1:eac0369: 			getParms().registerOutParameter(parameterIndex-1, sqlType, scale);
1:eac0369: 		} catch (StandardException e)
1:eac0369: 		{
1:eac0369: 			throw EmbedResultSet.noStateChangeException(e);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:3ff53d4: 	/**
1:10608cf: 	 * JDBC 2.0
1:10608cf: 	 *
1:9206d5b: 	 * Derby ignores the typeName argument because UDTs don't need it.
1:94df7fb: 	 *
1:94df7fb: 	 * @exception SQLException if a database-access error occurs.
1:94df7fb: 	 */
1:eac0369:  	public void registerOutParameter(int parameterIndex, int sqlType, 
1:eac0369:  									 String typeName) 
1:eac0369:  		 throws SQLException
1:eac0369:  	{
1:9206d5b:  		registerOutParameter( parameterIndex, sqlType );
1:eac0369:  	}
1:eac0369:  		 
1:eac0369:  
1:eac0369: 
1:3ff53d4:     /**
1:eac0369: 	 * @see CallableStatement#wasNull
1:eac0369:      * @exception SQLException NoOutputParameters thrown.
1:eac0369:      */
1:eac0369:     public boolean wasNull() throws SQLException 
1:eac0369: 	{
1:94df7fb: 		checkStatus();
1:eac0369: 		return wasNull;
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369: 	 * @see CallableStatement#getString
1:eac0369:      * @exception SQLException NoOutputParameters thrown.
1:eac0369:      */
1:eac0369:     public String getString(int parameterIndex) throws SQLException 
1:eac0369: 	{
1:b5f2776: 		checkStatus();
1:94df7fb: 		try {
1:eac0369: 			String v =  getParms().getParameterForGet(parameterIndex-1).getString();
1:94df7fb: 			wasNull = (v == null);
4:eac0369: 			return v;
1:eac0369: 
1:eac0369: 		} catch (StandardException e)
1:eac0369: 		{
1:eac0369: 			throw EmbedResultSet.noStateChangeException(e);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369: 	 * @see CallableStatement#getBoolean
1:eac0369:      * @exception SQLException NoOutputParameters thrown.
1:eac0369:      */
1:eac0369:     public boolean getBoolean(int parameterIndex) throws SQLException 
1:eac0369: 	{
1:eac0369: 		checkStatus();
1:eac0369: 		try {
1:94df7fb: 			DataValueDescriptor param = getParms().getParameterForGet(parameterIndex-1);
1:eac0369: 			boolean v = param.getBoolean();
1:eac0369: 			wasNull = (!v) && param.isNull();
1:94df7fb: 			return v;
1:94df7fb: 		} catch (StandardException e)
1:94df7fb: 		{
1:94df7fb: 			throw EmbedResultSet.noStateChangeException(e);
1:94df7fb: 		}
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:94df7fb:     /**
1:eac0369: 	 * @see CallableStatement#getByte
1:eac0369:      * @exception SQLException NoOutputParameters thrown.
1:94df7fb:      */
1:eac0369:     public byte getByte(int parameterIndex) throws SQLException 
1:94df7fb: 	{
1:eac0369: 		checkStatus();
1:eac0369: 		try {
1:94df7fb: 			DataValueDescriptor param = getParms().getParameterForGet(parameterIndex-1);
1:eac0369: 			byte b = param.getByte();
1:eac0369: 			wasNull = (b == 0) && param.isNull();
1:eac0369: 			return b;
1:94df7fb: 		} catch (StandardException e)
1:eac0369: 		{
1:94df7fb: 			throw EmbedResultSet.noStateChangeException(e);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369: 	 * @see CallableStatement#getShort
1:eac0369:      * @exception SQLException NoOutputParameters thrown.
1:eac0369:      */
1:eac0369:     public short getShort(int parameterIndex) throws SQLException 
1:eac0369: 	{
1:eac0369: 		checkStatus();
1:eac0369: 		try {
3:eac0369: 			DataValueDescriptor param = getParms().getParameterForGet(parameterIndex-1);
1:eac0369: 			short s = param.getShort();
1:eac0369: 			wasNull = (s == 0) && param.isNull();
1:eac0369: 			return s;
1:eac0369: 		} catch (StandardException e)
1:eac0369: 		{
1:eac0369: 			throw EmbedResultSet.noStateChangeException(e);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369: 	 * @see CallableStatement#getInt
1:eac0369:      * @exception SQLException NoOutputParameters thrown.
1:eac0369:      */
1:eac0369:     public int getInt(int parameterIndex) throws SQLException 
1:eac0369: 	{
1:eac0369: 		checkStatus();
1:eac0369: 
1:eac0369: 		try {
1:eac0369: 			DataValueDescriptor param = getParms().getParameterForGet(parameterIndex-1);
1:eac0369: 			int v = param.getInt();
1:eac0369: 			wasNull = (v == 0) && param.isNull();
1:94df7fb: 			return v;
1:eac0369: 
1:eac0369: 		} catch (StandardException e)
1:eac0369: 		{
1:eac0369: 			throw EmbedResultSet.noStateChangeException(e);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369: 	 * @see CallableStatement#getLong
1:eac0369:      * @exception SQLException NoOutputParameters thrown.
1:eac0369:      */
1:eac0369:     public long getLong(int parameterIndex) throws SQLException 
1:eac0369: 	{
1:eac0369: 		checkStatus();
1:eac0369: 		try {
1:eac0369: 			DataValueDescriptor param = getParms().getParameterForGet(parameterIndex-1);
1:eac0369: 			long v = param.getLong();
1:eac0369: 			wasNull = (v == 0L) && param.isNull();
1:eac0369: 			return v;
1:eac0369: 		} catch (StandardException e)
1:eac0369: 		{
1:eac0369: 			throw EmbedResultSet.noStateChangeException(e);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:94df7fb:      * JDBC 2.0
1:94df7fb:      *
1:10608cf:      * Get the value of a NUMERIC parameter as a java.math.BigDecimal object.
1:10608cf:      *
1:10608cf:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:10608cf:      * @return the parameter value (full precision); if the value is SQL NULL, 
1:10608cf:      * the result is null 
1:10608cf:      * @exception SQLException if a database-access error occurs.
1:10608cf:      */
1:10608cf:     public final BigDecimal getBigDecimal(int parameterIndex) throws SQLException 
1:10608cf: 	{
1:10608cf: 		checkStatus();
1:10608cf: 		try {
1:10608cf: 			DataValueDescriptor dvd = getParms().getParameterForGet(parameterIndex-1);
1:10608cf: 			if (wasNull = dvd.isNull())
1:10608cf: 				return null;
1:10608cf: 			
1:10608cf: 			return org.apache.derby.iapi.types.SQLDecimal.getBigDecimal(dvd);
1:10608cf: 			
1:10608cf: 		} catch (StandardException e)
1:10608cf: 		{
1:10608cf: 			throw EmbedResultSet.noStateChangeException(e);
1:10608cf: 		}
1:10608cf: 	}
1:10608cf: 
1:10608cf:     /**
1:10608cf: 	 * @see CallableStatement#getBigDecimal
1:10608cf:      * @exception SQLException NoOutputParameters thrown.
1:10608cf:      * @deprecated
1:10608cf:      */
1:10608cf:     public final BigDecimal getBigDecimal(int parameterIndex, int scale) throws SQLException
1:10608cf: 	{
1:10608cf:     	BigDecimal v = getBigDecimal(parameterIndex);
1:10608cf:     	if (v != null)
1:10608cf:     		v = v.setScale(scale, BigDecimal.ROUND_HALF_DOWN);
1:10608cf:     	return v;
1:10608cf: 	}
1:10608cf: 
1:eac0369:     /**
1:eac0369: 	 * @see CallableStatement#getFloat
1:eac0369:      * @exception SQLException NoOutputParameters thrown.
1:eac0369:      */
1:eac0369:     public float getFloat(int parameterIndex) throws SQLException 
1:eac0369: 	{
1:eac0369: 		checkStatus();
1:eac0369: 		try {
1:eac0369: 			DataValueDescriptor param = getParms().getParameterForGet(parameterIndex-1);
1:eac0369: 			float v = param.getFloat();
1:eac0369: 			wasNull = (v == 0.0) && param.isNull();
1:eac0369: 			return v;
1:eac0369: 		} catch (StandardException e)
1:eac0369: 		{
1:eac0369: 			throw EmbedResultSet.noStateChangeException(e);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369: 	 * @see CallableStatement#getDouble
1:eac0369:      * @exception SQLException NoOutputParameters thrown.
1:eac0369:      */
1:eac0369:     public double getDouble(int parameterIndex) throws SQLException 
1:eac0369: 	{
1:eac0369: 		checkStatus();
1:eac0369: 		try {
1:eac0369: 			DataValueDescriptor param = getParms().getParameterForGet(parameterIndex-1);
1:eac0369: 			double v = param.getDouble();
1:eac0369: 			wasNull = (v == 0.0) && param.isNull();
1:eac0369: 			return v;
1:eac0369: 		} catch (StandardException e)
1:eac0369: 		{
1:eac0369: 			throw EmbedResultSet.noStateChangeException(e);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369: 	 * @see CallableStatement#getBytes
1:eac0369:      * @exception SQLException NoOutputParameters thrown.
1:eac0369:      */
1:eac0369:     public byte[] getBytes(int parameterIndex) throws SQLException 
1:eac0369: 	{
1:eac0369: 		checkStatus();
1:eac0369: 		try {
1:eac0369: 			byte[] v =  getParms().getParameterForGet(parameterIndex-1).getBytes();
1:94df7fb: 			wasNull = (v == null);
1:eac0369: 			return v;
1:eac0369: 		} catch (StandardException e)
1:eac0369: 		{
1:eac0369: 			throw EmbedResultSet.noStateChangeException(e);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369: 	 * @see CallableStatement#getDate
1:eac0369:      * @exception SQLException NoOutputParameters thrown.
1:eac0369:      */
1:866573f:     public Date getDate(int parameterIndex, Calendar cal) throws SQLException
1:eac0369: 	{
1:eac0369: 		checkStatus();
1:eac0369: 		try {
1:866573f:             Date v = getParms().
1:866573f:                     getParameterForGet(parameterIndex-1).getDate(cal);
4:eac0369: 			wasNull = (v == null);
1:eac0369: 			return v;
1:eac0369: 		} catch (StandardException e)
1:eac0369: 		{
1:eac0369: 			throw EmbedResultSet.noStateChangeException(e);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369: 	 * @see CallableStatement#getTime
1:eac0369:      * @exception SQLException NoOutputParameters thrown.
1:eac0369:      */
1:866573f:     public Time getTime(int parameterIndex, Calendar cal) throws SQLException
1:eac0369: 	{
1:eac0369: 		checkStatus();
1:eac0369: 		try {
1:866573f:             Time v = getParms().
1:866573f:                     getParameterForGet(parameterIndex-1).getTime(cal);
1:eac0369: 			wasNull = (v == null);
1:eac0369: 			return v;
1:eac0369: 		} catch (StandardException e)
1:eac0369: 		{
1:eac0369: 			throw EmbedResultSet.noStateChangeException(e);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369: 	 * @see CallableStatement#getTimestamp
1:eac0369:      * @exception SQLException NoOutputParameters thrown.
1:eac0369:      */
1:866573f:     public Timestamp getTimestamp(int parameterIndex, Calendar cal)
1:eac0369: 	    throws SQLException 
1:eac0369: 	{
1:eac0369: 		checkStatus();
1:eac0369: 		try {
1:866573f:             Timestamp v = getParms().
1:866573f:                     getParameterForGet(parameterIndex-1).getTimestamp(cal);
1:eac0369: 			wasNull = (v == null);
1:eac0369: 			return v;
1:eac0369: 		} catch (StandardException e)
1:eac0369: 		{
1:eac0369: 			throw EmbedResultSet.noStateChangeException(e);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369:     /**
1:3ff53d4:      * Get the value of a SQL DATE parameter as a java.sql.Date object
1:94df7fb:      *
1:3ff53d4:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:3ff53d4:      * @return the parameter value; if the value is SQL NULL, the result is 
1:3ff53d4:      * null
1:3ff53d4:      * @exception SQLException if a database-access error occurs.
1:3ff53d4:      */
1:866573f:     public java.sql.Date getDate(int parameterIndex)
1:3ff53d4:       throws SQLException 
1:3ff53d4: 	{
1:866573f:         return getDate(parameterIndex, getCal());
1:3ff53d4: 	}
1:3ff53d4: 
1:3ff53d4:     /**
1:3ff53d4:      * Get the value of a SQL TIME parameter as a java.sql.Time object.
1:94df7fb:      *
1:3ff53d4:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:3ff53d4:      * @return the parameter value; if the value is SQL NULL, the result is 
1:3ff53d4: 	 * null
1:3ff53d4:      * @exception SQLException if a database-access error occurs.
1:3ff53d4:      */
1:866573f:     public java.sql.Time getTime(int parameterIndex)
1:3ff53d4:       throws SQLException 
1:3ff53d4: 	{
1:866573f:         return getTime(parameterIndex, getCal());
1:3ff53d4: 	}
1:3ff53d4: 
1:3ff53d4:     /**
1:3ff53d4:      * Get the value of a SQL TIMESTAMP parameter as a java.sql.Timestamp 
1:3ff53d4:      * object.
1:3ff53d4:      *
1:3ff53d4:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:3ff53d4:      * @return the parameter value; if the value is SQL NULL, the result is 
1:3ff53d4:      * null
1:3ff53d4:      * @exception SQLException if a database-access error occurs.
1:3ff53d4:      */
1:866573f:     public java.sql.Timestamp getTimestamp(int parameterIndex)
1:3ff53d4:       throws SQLException 
1:3ff53d4: 	{
1:866573f:         return getTimestamp(parameterIndex, getCal());
1:3ff53d4: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369: 	 * @see CallableStatement#getObject
1:eac0369:      * @exception SQLException NoOutputParameters thrown.
1:eac0369:      */
1:45075cc: 	public final Object getObject(int parameterIndex) throws SQLException 
1:eac0369: 	{
1:eac0369: 		checkStatus();
1:b5f2776: 		try {
1:45075cc: 			Object v = getParms().getParameterForGet(parameterIndex-1).getObject();
1:eac0369: 			wasNull = (v == null);
1:eac0369: 			return v;
1:eac0369: 
1:eac0369: 		} catch (StandardException e)
1:eac0369: 		{
1:eac0369: 			throw EmbedResultSet.noStateChangeException(e);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 	/**
1:3ff53d4: 	    * JDBC 3.0
1:3ff53d4: 	    *
1:3ff53d4: 	    * Retrieve the value of the designated JDBC DATALINK parameter as a java.net.URL object
2:3ff53d4: 	    *
1:3ff53d4: 	    * @param parameterIndex - the first parameter is 1, the second is 2
1:3ff53d4: 	    * @return a java.net.URL object that represents the JDBC DATALINK value used as
1:3ff53d4: 	    * the designated parameter
1:3ff53d4: 	    * @exception SQLException Feature not implemented for now.
1:3ff53d4: 		*/
1:3ff53d4: 		public URL getURL(int parameterIndex)
1:3ff53d4: 	    throws SQLException
1:3ff53d4: 		{
3:3ff53d4: 			throw Util.notImplemented();
1:3ff53d4: 		}
1:eac0369: 
1:3ff53d4: 		/**
1:3ff53d4: 	    * JDBC 3.0
1:3ff53d4: 	    *
1:3ff53d4: 	    * Sets the designated parameter to the given java.net.URL object. The driver
1:3ff53d4: 	    * converts this to an SQL DATALINK value when it sends it to the database.
1:3ff53d4: 	    *
1:3ff53d4: 	    * @param parameterName - the name of the parameter
1:3ff53d4: 	    * @param val - the parameter value
1:3ff53d4: 	    * @exception SQLException Feature not implemented for now.
1:3ff53d4: 		*/
1:3ff53d4: 		public void setURL(String parameterName, URL val)
1:3ff53d4: 	    throws SQLException
1:3ff53d4: 		{
1:3ff53d4: 			throw Util.notImplemented();
1:3ff53d4: 		}
1:3ff53d4: 
1:3ff53d4: 		/**
1:3ff53d4: 	    * JDBC 3.0
1:3ff53d4: 	    *
1:3ff53d4: 	    * Retrieves the value of a JDBC DATALINK parameter as a java.net.URL object
1:3ff53d4: 	    *
1:3ff53d4: 	    * @param parameterName - the name of the parameter
1:3ff53d4: 	    * @return the parameter value. If the value is SQL NULL, the result is null.
1:3ff53d4: 	    * @exception SQLException Feature not implemented for now.
1:3ff53d4: 		*/
1:3ff53d4: 		public URL getURL(String parameterName)
1:3ff53d4: 	    throws SQLException
1:3ff53d4: 		{
1:3ff53d4: 			throw Util.notImplemented();
1:3ff53d4: 		}
1:3ff53d4: 
1:3ff53d4:     /**
2:3ff53d4:      * JDBC 2.0
1:3ff53d4:      *
1:94df7fb:      * Get a BLOB OUT parameter.
1:3ff53d4:      *
1:147e86d:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:94df7fb:      * @return an object representing a BLOB
2:3ff53d4:      * @exception SQLException if a database-access error occurs.
1:3ff53d4:      */
1:94df7fb:     public Blob getBlob (int parameterIndex) throws SQLException {
1:0252fa4:         Object o = getObject(parameterIndex);
1:0252fa4:         if (o == null || o instanceof Blob) {
1:0252fa4:             return (Blob) o;
1:0252fa4:         }
1:0252fa4:         throw newSQLException(SQLState.LANG_DATA_TYPE_GET_MISMATCH,
1:0252fa4:                 Blob.class.getName(),
1:0252fa4:                 Util.typeName(getParameterJDBCType(parameterIndex)));
1:3ff53d4:     }
1:3ff53d4: 
1:3ff53d4:     /**
1:94df7fb:      * JDBC 2.0
1:3ff53d4:      *
1:94df7fb:      * Get a CLOB OUT parameter.
1:3ff53d4:      *
1:147e86d:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:94df7fb:      * @return an object representing a CLOB
1:94df7fb:      * @exception SQLException if a database-access error occurs.
1:3ff53d4:      */
1:94df7fb:     public Clob getClob (int parameterIndex) throws SQLException {
1:0252fa4:         Object o = getObject(parameterIndex);
1:0252fa4:         if (o == null || o instanceof Clob) {
1:0252fa4:             return (Clob) o;
1:0252fa4:         }
1:0252fa4:         throw newSQLException(SQLState.LANG_DATA_TYPE_GET_MISMATCH,
1:0252fa4:                 Clob.class.getName(),
1:0252fa4:                 Util.typeName(getParameterJDBCType(parameterIndex)));
1:3ff53d4:     }
1:eac0369:     
1:eac0369: 	public void addBatch() throws SQLException {
1:eac0369: 
1:eac0369: 		checkStatus();
1:eac0369: 		ParameterValueSet pvs = getParms();
1:eac0369: 
1:eac0369: 		int numberOfParameters = pvs.getParameterCount();
1:eac0369: 
1:eac0369: 		for (int j=1; j<=numberOfParameters; j++) {
1:eac0369: 
1:eac0369: 			switch (pvs.getParameterMode(j)) {
1:e33b8d8:             case (ParameterMetaData.parameterModeIn):
1:e33b8d8:             case (ParameterMetaData.parameterModeUnknown):
1:eac0369: 				break;
1:e33b8d8:             case (ParameterMetaData.parameterModeOut):
1:e33b8d8:             case (ParameterMetaData.parameterModeInOut):
1:eac0369: 				throw newSQLException(SQLState.OUTPUT_PARAMS_NOT_ALLOWED);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		super.addBatch();
1:b5f2776: 	}
1:b5f2776: 
1:b5f2776:     /**
1:b5f2776:      * JDBC 2.0
1:b5f2776:      *
1:b5f2776:      * Returns an object representing the value of OUT parameter {@code i}.
1:b5f2776:      * Use the map to determine the class from which to construct data of SQL
1:b5f2776:      * structured and distinct types.
1:b5f2776:      *
1:94df7fb:      * @param i the first parameter is 1, the second is 2, ...
1:b5f2776:      * @param map the mapping from SQL type names to Java classes
1:b5f2776:      * @return a java.lang.Object holding the OUT parameter value.
1:b5f2776:      * @exception SQLException if a database-access error occurs.
1:b5f2776:      */
1:b5f2776:     public final Object getObject(int i, Map<String, Class<?>> map) throws SQLException {
1:94df7fb:         checkStatus();
1:b5f2776:         if (map == null) {
1:b5f2776:             throw Util.generateCsSQLException(SQLState.INVALID_API_PARAMETER, map, "map",
1:b5f2776:                     "java.sql.CallableStatement.getObject");
1:94df7fb:         }
1:b5f2776:         if (!map.isEmpty()) {
1:b5f2776:             throw Util.notImplemented();
1:b5f2776:         }
1:b5f2776:         // Map is empty call the normal getObject method.
1:b5f2776:         return getObject(i);
1:b5f2776:     }
1:94df7fb: 
1:b5f2776:     /**
1:b5f2776:      * JDBC 2.0
1:b5f2776:      *
1:b5f2776:      * Get a REF(&lt;structured-type&gt;) OUT parameter.
1:b5f2776:      *
1:94df7fb:      * @param i the first parameter is 1, the second is 2, ...
1:b5f2776:      * @return an object representing data of an SQL REF Type
1:b5f2776:      * @exception SQLException if a database-access error occurs.
1:b5f2776:      */
1:b5f2776:     public final Ref getRef(int i) throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     /**
1:b5f2776:      * JDBC 2.0
1:b5f2776:      *
1:b5f2776:      * Get an Array OUT parameter.
1:b5f2776:      *
3:b5f2776:      * @param i the first parameter is 1, the second is 2, ...
1:b5f2776:      * @return an object representing an SQL array
1:b5f2776:      * @exception SQLException if a database-access error occurs.
1:b5f2776:      */
1:b5f2776:     public final Array getArray(int i) throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     // JDBC 3.0 methods
1:b5f2776: 
1:b5f2776:     /**
1:b5f2776:      * JDBC 3.0
1:b5f2776:      *
1:b5f2776:      * Registers the OUT parameter named parameterName to the JDBC type sqlType.
1:b5f2776:      * All OUT parameters must be registered before a stored procedure is
1:b5f2776:      * executed.
1:b5f2776:      *
1:b5f2776:      * @param parameterName - the name of the parameter
1:b5f2776:      * @param sqlType - the JDBC type code defined by java.sql.Types. If the
1:b5f2776:      * parameter is of JDBC type NUMERIC or DECIMAL, the version of
1:b5f2776:      * registerOutParameter that accepts a scale value should be used.
1:b5f2776:      * @exception SQLException Feature not implemented for now.
1:b5f2776:      */
1:b5f2776:     public final void registerOutParameter(String parameterName, int sqlType)
1:b5f2776:             throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     /**
1:b5f2776:      * JDBC 3.0
1:b5f2776:      *
1:b5f2776:      * Registers the designated output parameter. This version of the method
1:b5f2776:      * registerOutParameter should be used for a user-named or REF output
1:b5f2776:      * parameter.
1:b5f2776:      *
1:b5f2776:      * @param parameterName - the name of the parameter
1:b5f2776:      * @param sqlType - the SQL type code defined by java.sql.Types.
1:b5f2776:      * @param typeName - the fully-qualified name of an SQL structure type
1:b5f2776:      * @exception SQLException Feature not implemented for now.
1:b5f2776:      */
1:b5f2776:     public final void registerOutParameter(String parameterName,
1:b5f2776:             int sqlType, String typeName)
1:b5f2776:             throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     /**
1:b5f2776:      * JDBC 3.0
1:b5f2776:      *
1:b5f2776:      * Registers the parameter named parameterName to the JDBC type sqlType.
1:b5f2776:      * This method must be called before a stored procedure is executed.
1:b5f2776:      *
1:b5f2776:      * @param parameterName - the name of the parameter
1:b5f2776:      * @param sqlType - the SQL type code defined by java.sql.Types.
1:b5f2776:      * @param scale - the desired number of digits to the right of the decimal
1:b5f2776:      * point. It must be greater than or equal to zero.
1:b5f2776:      * @exception SQLException Feature not implemented for now.
1:b5f2776:      */
1:b5f2776:     public final void registerOutParameter(String parameterName,
1:b5f2776:             int sqlType, int scale) throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     /**
1:b5f2776:      * JDBC 3.0
1:b5f2776:      *
1:dbed020:      * Retrieves the value of a JDBC REF (structured-type) parameter as a Ref
1:b5f2776:      * object in the Java programming language.
1:b5f2776:      *
1:b5f2776:      * @param parameterName - the name of the parameter
1:b5f2776:      * @return the parameter value as a Ref object in the Java Programming
1:b5f2776:      * language. If the value is SQL NULL, the result is null.
1:b5f2776:      * @exception SQLException Feature not implemented for now.
1:b5f2776:      */
1:b5f2776:     public final Ref getRef(String parameterName) throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     /**
1:b5f2776:      * JDBC 3.0
1:b5f2776:      *
1:b5f2776:      * Retrieves the value of a JDBC BLOB parameter as a Blob object in the Java
1:b5f2776:      * programming language.
1:b5f2776:      *
1:b5f2776:      * @param parameterName - the name of the parameter
1:b5f2776:      * @return the parameter value as a Blob object in the Java Programming
1:b5f2776:      * language. If the value is SQL NULL, the result is null.
1:b5f2776:      * @exception SQLException Feature not implemented for now.
1:b5f2776:      */
1:b5f2776:     public final Blob getBlob(String parameterName) throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     /**
1:b5f2776:      * JDBC 3.0
1:b5f2776:      *
1:b5f2776:      * Retrieves the value of a JDBC CLOB parameter as a Clob object in the Java
1:b5f2776:      * programming language.
1:b5f2776:      *
1:b5f2776:      * @param parameterName - the name of the parameter
1:b5f2776:      * @return the parameter value as a Clob object in the Java Programming
1:b5f2776:      * language. If the value is SQL NULL, the result is null.
1:b5f2776:      * @exception SQLException Feature not implemented for now.
1:b5f2776:      */
1:b5f2776:     public final Clob getClob(String parameterName) throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     /**
1:b5f2776:      * JDBC 3.0
1:b5f2776:      *
1:b5f2776:      * Retrieves the value of a JDBC ARRAY parameter as an Array object in the
1:b5f2776:      * Java programming language.
1:b5f2776:      *
1:b5f2776:      * @param parameterName - the name of the parameter
1:b5f2776:      * @return the parameter value as a Array object in the Java Programming
1:b5f2776:      * language. If the value is SQL NULL, the result is null.
1:b5f2776:      * @exception SQLException Feature not implemented for now.
1:b5f2776:      */
1:b5f2776:     public final Array getArray(String parameterName) throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     /**
1:b5f2776:      * JDBC 3.0
1:b5f2776:      *
1:b5f2776:      * Sets the designated parameter to SQL NULL.
1:b5f2776:      *
1:b5f2776:      * @param parameterName - the name of the parameter
1:b5f2776:      * @param sqlType - the SQL type code defined in java.sql.Types
1:b5f2776:      * @exception SQLException Feature not implemented for now.
1:b5f2776:      */
1:b5f2776:     public final void setNull(String parameterName, int sqlType)
1:b5f2776:             throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     /**
1:b5f2776:      * JDBC 3.0
1:b5f2776:      *
1:b5f2776:      * Sets the designated parameter to SQL NULL.
1:b5f2776:      *
1:b5f2776:      * @param parameterName - the name of the parameter
1:b5f2776:      * @param sqlType - the SQL type code defined in java.sql.Types
1:b5f2776:      * @param typeName - the fully-qualified name of an SQL user-defined type
1:b5f2776:      * @exception SQLException Feature not implemented for now.
1:b5f2776:      */
1:b5f2776:     public final void setNull(String parameterName, int sqlType, String typeName)
1:b5f2776:             throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     /**
1:b5f2776:      * JDBC 3.0
1:b5f2776:      *
1:b5f2776:      * Sets the designated parameter to the given Java boolean value. The driver
1:b5f2776:      * converts this to an SQL BIT value when it sends it to the database.
1:b5f2776:      *
1:b5f2776:      * @param parameterName - the name of the parameter
1:b5f2776:      * @param x - the parameter value
1:b5f2776:      * @exception SQLException Feature not implemented for now.
1:b5f2776:      */
1:b5f2776:     public final void setBoolean(String parameterName, boolean x)
1:b5f2776:             throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     /**
1:b5f2776:      * JDBC 3.0
1:b5f2776:      *
1:b5f2776:      * Retrieves the value of a JDBC BIT parameter as a boolean in the Java
1:b5f2776:      * programming language.
1:b5f2776:      *
1:b5f2776:      * @param parameterName - the name of the parameter
1:b5f2776:      * @return the parameter value. If the value is SQL NULL, the result is
1:b5f2776:      * false.
1:b5f2776:      * @exception SQLException Feature not implemented for now.
1:b5f2776:      */
1:b5f2776:     public final boolean getBoolean(String parameterName) throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     /**
1:b5f2776:      * JDBC 3.0
1:b5f2776:      *
1:b5f2776:      * Sets the designated parameter to the given Java byte value. The driver
1:b5f2776:      * converts this to an SQL TINYINT value when it sends it to the database.
1:b5f2776:      *
1:b5f2776:      * @param parameterName - the name of the parameter
1:b5f2776:      * @param x - the parameter value
1:b5f2776:      * @exception SQLException Feature not implemented for now.
1:b5f2776:      */
1:b5f2776:     public final void setByte(String parameterName, byte x)
1:b5f2776:             throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     /**
1:b5f2776:      * JDBC 3.0
1:b5f2776:      *
1:b5f2776:      * Retrieves the value of a JDBC TINYINT parameter as a byte in the Java
1:b5f2776:      * programming language.
1:b5f2776:      *
1:b5f2776:      * @param parameterName - the name of the parameter
1:b5f2776:      * @return the parameter value. If the value is SQL NULL, the result is 0.
1:b5f2776:      * @exception SQLException Feature not implemented for now.
1:b5f2776:      */
1:b5f2776:     public final byte getByte(String parameterName) throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     /**
1:b5f2776:      * JDBC 3.0
1:b5f2776:      *
1:b5f2776:      * Sets the designated parameter to the given Java short value. The driver
1:b5f2776:      * converts this to an SQL SMALLINT value when it sends it to the database.
1:b5f2776:      *
1:b5f2776:      * @param parameterName - the name of the parameter
1:b5f2776:      * @param x - the parameter value
1:b5f2776:      * @exception SQLException Feature not implemented for now.
1:b5f2776:      */
1:b5f2776:     public final void setShort(String parameterName, short x)
1:b5f2776:             throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     /**
1:b5f2776:      * JDBC 3.0
1:b5f2776:      *
1:b5f2776:      * Retrieves the value of a JDBC SMALLINT parameter as a short in the Java
1:b5f2776:      * programming language.
1:b5f2776:      *
1:b5f2776:      * @param parameterName - the name of the parameter
1:b5f2776:      * @return the parameter value. If the value is SQL NULL, the result is 0.
1:b5f2776:      * @exception SQLException Feature not implemented for now.
1:b5f2776:      */
1:b5f2776:     public final short getShort(String parameterName) throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     /**
1:b5f2776:      * JDBC 3.0
1:b5f2776:      *
1:b5f2776:      * Sets the designated parameter to the given Java int value. The driver
1:b5f2776:      * converts this to an SQL INTEGER value when it sends it to the database.
1:b5f2776:      *
1:b5f2776:      * @param parameterName - the name of the parameter
1:b5f2776:      * @param x - the parameter value
1:b5f2776:      * @exception SQLException Feature not implemented for now.
1:b5f2776:      */
1:b5f2776:     public final void setInt(String parameterName, int x) throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     /**
1:b5f2776:      * JDBC 3.0
1:b5f2776:      *
1:b5f2776:      * Retrieves the value of a JDBC INTEGER parameter as a int in the Java
1:b5f2776:      * programming language.
1:b5f2776:      *
1:b5f2776:      * @param parameterName - the name of the parameter
1:b5f2776:      * @return the parameter value. If the value is SQL NULL, the result is 0.
1:b5f2776:      * @exception SQLException Feature not implemented for now.
1:b5f2776:      */
1:b5f2776:     public final int getInt(String parameterName) throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     /**
1:b5f2776:      * JDBC 3.0
1:b5f2776:      *
1:b5f2776:      * Sets the designated parameter to the given Java long value. The driver
1:b5f2776:      * converts this to an SQL BIGINT value when it sends it to the database.
1:b5f2776:      *
1:b5f2776:      * @param parameterName - the name of the parameter
1:b5f2776:      * @param x - the parameter value
1:b5f2776:      * @exception SQLException Feature not implemented for now.
1:b5f2776:      */
1:b5f2776:     public final void setLong(String parameterName, long x)
1:b5f2776:             throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     /**
1:b5f2776:      * JDBC 3.0
1:b5f2776:      *
1:b5f2776:      * Retrieves the value of a JDBC BIGINT parameter as a long in the Java
1:b5f2776:      * programming language.
1:b5f2776:      *
1:b5f2776:      * @param parameterName - the name of the parameter
1:b5f2776:      * @return the parameter value. If the value is SQL NULL, the result is 0.
1:b5f2776:      * @exception SQLException Feature not implemented for now.
1:b5f2776:      */
1:b5f2776:     public final long getLong(String parameterName) throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     /**
1:b5f2776:      * JDBC 3.0
1:b5f2776:      *
1:b5f2776:      * Sets the designated parameter to the given Java float value. The driver
1:b5f2776:      * converts this to an SQL FLOAT value when it sends it to the database.
1:b5f2776:      *
1:b5f2776:      * @param parameterName - the name of the parameter
1:b5f2776:      * @param x - the parameter value
1:b5f2776:      * @exception SQLException Feature not implemented for now.
1:b5f2776:      */
1:b5f2776:     public final void setFloat(String parameterName, float x)
1:b5f2776:             throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     /**
1:b5f2776:      * JDBC 3.0
1:b5f2776:      *
1:b5f2776:      * Retrieves the value of a JDBC FLOAT parameter as a float in the Java
1:b5f2776:      * programming language.
1:b5f2776:      *
1:b5f2776:      * @param parameterName - the name of the parameter
1:b5f2776:      * @return the parameter value. If the value is SQL NULL, the result is 0.
1:b5f2776:      * @exception SQLException Feature not implemented for now.
1:b5f2776:      */
1:b5f2776:     public final float getFloat(String parameterName)
1:b5f2776:             throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     /**
1:b5f2776:      * JDBC 3.0
1:b5f2776:      *
1:b5f2776:      * Sets the designated parameter to the given Java double value. The driver
1:b5f2776:      * converts this to an SQL DOUBLE value when it sends it to the database.
1:b5f2776:      *
1:b5f2776:      * @param parameterName - the name of the parameter
1:b5f2776:      * @param x - the parameter value
1:b5f2776:      * @exception SQLException Feature not implemented for now.
1:b5f2776:      */
1:b5f2776:     public final void setDouble(String parameterName, double x)
1:b5f2776:             throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     /**
1:b5f2776:      * JDBC 3.0
1:b5f2776:      *
1:b5f2776:      * Retrieves the value of a JDBC DOUBLE parameter as a double in the Java
1:b5f2776:      * programming language.
1:b5f2776:      *
1:b5f2776:      * @param parameterName - the name of the parameter
1:b5f2776:      * @return the parameter value. If the value is SQL NULL, the result is 0.
1:b5f2776:      * @exception SQLException Feature not implemented for now.
1:b5f2776:      */
1:b5f2776:     public final double getDouble(String parameterName) throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     /**
1:b5f2776:      * JDBC 3.0
1:b5f2776:      *
1:b5f2776:      * Sets the designated parameter to the given java.math.BigDecimal value.
1:b5f2776:      * The driver converts this to an SQL NUMERIC value when it sends it to the
1:b5f2776:      * database.
1:b5f2776:      *
1:b5f2776:      * @param parameterName - the name of the parameter
1:b5f2776:      * @param x - the parameter value
1:b5f2776:      * @exception SQLException Feature not implemented for now.
1:b5f2776:      */
1:b5f2776:     public final void setBigDecimal(String parameterName, BigDecimal x)
1:b5f2776:             throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     /**
1:b5f2776:      * JDBC 3.0
1:b5f2776:      *
1:b5f2776:      * Retrieves the value of a JDBC NUMERIC parameter as a java.math.BigDecimal
1:b5f2776:      * object with as many digits to the right of the decimal point as the value
1:b5f2776:      * contains
1:b5f2776:      *
1:b5f2776:      * @param parameterName - the name of the parameter
1:b5f2776:      * @return the parameter value. If the value is SQL NULL, the result is 0.
1:b5f2776:      * @exception SQLException Feature not implemented for now.
1:b5f2776:      */
1:b5f2776:     public final BigDecimal getBigDecimal(String parameterName)
1:b5f2776:             throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     /**
1:b5f2776:      * JDBC 3.0
1:b5f2776:      *
1:b5f2776:      * Sets the designated parameter to the given Java String value. The driver
1:b5f2776:      * converts this to an SQL VARCHAR OR LONGVARCHAR value (depending on the
1:b5f2776:      * argument's size relative the driver's limits on VARCHAR values) when it
1:b5f2776:      * sends it to the database.
1:b5f2776:      *
1:b5f2776:      * @param parameterName - the name of the parameter
1:b5f2776:      * @param x - the parameter value
1:b5f2776:      * @exception SQLException Feature not implemented for now.
1:b5f2776:      */
1:b5f2776:     public final void setString(String parameterName, String x)
1:b5f2776:             throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     /**
1:b5f2776:      * JDBC 3.0
1:b5f2776:      *
1:b5f2776:      * Retrieves the value of a JDBC CHAR, VARCHAR, or LONGVARCHAR parameter as
1:b5f2776:      * a String in the Java programming language.
1:b5f2776:      *
1:b5f2776:      * @param parameterName - the name of the parameter
1:b5f2776:      * @return the parameter value. If the value is SQL NULL, the result is
1:b5f2776:      * null.
1:b5f2776:      * @exception SQLException Feature not implemented for now.
1:b5f2776:      */
1:b5f2776:     public final String getString(String parameterName) throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     /**
1:b5f2776:      * JDBC 3.0
1:b5f2776:      *
1:b5f2776:      * Sets the designated parameter to the given Java array of bytes. The
1:b5f2776:      * driver converts this to an SQL VARBINARY OR LONGVARBINARY (depending on
1:b5f2776:      * the argument's size relative to the driver's limits on VARBINARY
1:b5f2776:      * values)when it sends it to the database.
1:b5f2776:      *
1:b5f2776:      * @param parameterName - the name of the parameter
1:b5f2776:      * @param x - the parameter value
1:b5f2776:      * @exception SQLException Feature not implemented for now.
1:b5f2776:      */
1:b5f2776:     public final void setBytes(String parameterName, byte[] x)
1:b5f2776:             throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     /**
1:b5f2776:      * JDBC 3.0
1:b5f2776:      *
1:b5f2776:      * Retrieves the value of a JDBC BINARY or VARBINARY parameter as an array
1:b5f2776:      * of byte values in the Java programming language.
1:b5f2776:      *
1:b5f2776:      * @param parameterName - the name of the parameter
1:b5f2776:      * @return the parameter value. If the value is SQL NULL, the result is
1:b5f2776:      * null.
1:b5f2776:      * @exception SQLException Feature not implemented for now.
1:b5f2776:      */
1:b5f2776:     public final byte[] getBytes(String parameterName) throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     /**
1:b5f2776:      * JDBC 3.0
1:b5f2776:      *
1:b5f2776:      * Sets the designated parameter to the given java.sql.Date value. The
1:b5f2776:      * driver converts this to an SQL DATE value when it sends it to the
1:b5f2776:      * database.
1:b5f2776:      *
1:b5f2776:      * @param parameterName - the name of the parameter
1:b5f2776:      * @param x - the parameter value
1:b5f2776:      * @exception SQLException Feature not implemented for now.
1:b5f2776:      */
1:b5f2776:     public final void setDate(String parameterName, Date x)
1:b5f2776:             throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     /**
1:b5f2776:      * JDBC 3.0
1:b5f2776:      *
1:b5f2776:      * Sets the designated parameter to the given java.sql.Date value, using the
1:b5f2776:      * given Calendar object.
1:b5f2776:      *
1:b5f2776:      * @param parameterName - the name of the parameter
1:b5f2776:      * @param x - the parameter value
1:b5f2776:      * @param cal - the Calendar object the driver will use to construct the
1:b5f2776:      * date
1:b5f2776:      * @exception SQLException Feature not implemented for now.
1:b5f2776:      */
1:b5f2776:     public final void setDate(String parameterName, Date x, Calendar cal)
1:b5f2776:             throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     /**
1:b5f2776:      * JDBC 3.0
1:b5f2776:      *
1:b5f2776:      * Retrieves the value of a JDBC DATE parameter as a java.sql.Date object
1:b5f2776:      *
1:b5f2776:      * @param parameterName - the name of the parameter
1:b5f2776:      * @return the parameter value. If the value is SQL NULL, the result is
1:b5f2776:      * null.
1:b5f2776:      * @exception SQLException Feature not implemented for now.
1:b5f2776:      */
1:b5f2776:     public final Date getDate(String parameterName) throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     /**
1:b5f2776:      * JDBC 3.0
1:b5f2776:      *
1:b5f2776:      * Retrieves the value of a JDBC DATE parameter as a java.sql.Date object,
1:b5f2776:      * using the given Calendar object to construct the date object.
1:b5f2776:      *
1:b5f2776:      * @param parameterName - the name of the parameter
1:b5f2776:      * @param cal - the Calendar object the driver will use to construct the
1:b5f2776:      * date
1:b5f2776:      * @return the parameter value. If the value is SQL NULL, the result is
1:b5f2776:      * null.
1:b5f2776:      * @exception SQLException Feature not implemented for now.
1:b5f2776:      */
1:b5f2776:     public final Date getDate(String parameterName, Calendar cal)
1:b5f2776:             throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     /**
1:b5f2776:      * JDBC 3.0
1:b5f2776:      *
1:b5f2776:      * Sets the designated parameter to the given java.sql.Time value. The
1:b5f2776:      * driver converts this to an SQL TIME value when it sends it to the
1:b5f2776:      * database.
1:b5f2776:      *
1:b5f2776:      * @param parameterName - the name of the parameter
1:b5f2776:      * @param x - the parameter value
1:b5f2776:      * @exception SQLException Feature not implemented for now.
1:b5f2776:      */
1:b5f2776:     public final void setTime(String parameterName, Time x)
1:b5f2776:             throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     /**
1:b5f2776:      * JDBC 3.0
1:b5f2776:      *
1:b5f2776:      * Retrieves the value of a JDBC TIME parameter as ajava.sql.Time object
1:b5f2776:      *
1:b5f2776:      * @param parameterName - the name of the parameter
1:b5f2776:      * @return the parameter value. If the value is SQL NULL, the result is
1:b5f2776:      * null.
1:b5f2776:      * @exception SQLException Feature not implemented for now.
1:b5f2776:      */
1:b5f2776:     public final Time getTime(String parameterName) throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     /**
1:b5f2776:      * JDBC 3.0
1:b5f2776:      *
1:b5f2776:      * Retrieves the value of a JDBC TIME parameter as a java.sql.Time object,
1:b5f2776:      * using the given Calendar object to construct the time object.
1:b5f2776:      *
1:b5f2776:      * @param parameterName - the name of the parameter
1:b5f2776:      * @param cal - the Calendar object the driver will use to construct the
1:b5f2776:      * time
1:b5f2776:      * @return the parameter value. If the value is SQL NULL, the result is
1:b5f2776:      * null.
1:b5f2776:      * @exception SQLException Feature not implemented for now.
1:b5f2776:      */
1:b5f2776:     public final Time getTime(String parameterName, Calendar cal)
1:b5f2776:             throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     /**
1:b5f2776:      * JDBC 3.0
1:b5f2776:      *
1:b5f2776:      * Sets the designated parameter to the given java.sql.Time value using the
1:b5f2776:      * Calendar object
1:b5f2776:      *
1:b5f2776:      * @param parameterName - the name of the parameter
1:b5f2776:      * @param x - the parameter value
1:b5f2776:      * @param cal - the Calendar object the driver will use to construct the
1:b5f2776:      * time
1:b5f2776:      * @exception SQLException Feature not implemented for now.
1:b5f2776:      */
1:b5f2776:     public final void setTime(String parameterName, Time x, Calendar cal)
1:b5f2776:             throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     /**
1:b5f2776:      * JDBC 3.0
1:b5f2776:      *
1:b5f2776:      * Sets the designated parameter to the given java.sql.Timestamp value. The
1:b5f2776:      * driver converts this to an SQL TIMESTAMP value when it sends it to the
1:b5f2776:      * database.
1:b5f2776:      *
1:b5f2776:      * @param parameterName - the name of the parameter
1:b5f2776:      * @param x - the parameter value
1:b5f2776:      * @exception SQLException Feature not implemented for now.
1:b5f2776:      */
1:b5f2776:     public final void setTimestamp(String parameterName, Timestamp x)
1:b5f2776:             throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     /**
1:b5f2776:      * JDBC 3.0
1:b5f2776:      *
1:b5f2776:      * Sets the designated parameter to the given java.sql.Timestamp value,
1:b5f2776:      * using the given Calendar object
1:b5f2776:      *
1:b5f2776:      * @param parameterName - the name of the parameter
1:b5f2776:      * @param x - the parameter value
1:b5f2776:      * @param cal - the Calendar object the driver will use to construct the
1:b5f2776:      * timestamp.
1:b5f2776:      * @exception SQLException Feature not implemented for now.
1:b5f2776:      */
1:b5f2776:     public final void setTimestamp(String parameterName, Timestamp x, Calendar cal)
1:b5f2776:             throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     /**
1:b5f2776:      * JDBC 3.0
1:b5f2776:      *
1:b5f2776:      * Retrieves the value of a JDBC TIMESTAMP parameter as a java.sql.Timestamp
1:b5f2776:      * object
1:b5f2776:      *
1:b5f2776:      * @param parameterName - the name of the parameter
1:b5f2776:      * @return the parameter value. If the value is SQL NULL, the result is
1:b5f2776:      * null.
1:b5f2776:      * @exception SQLException Feature not implemented for now.
1:b5f2776:      */
1:b5f2776:     public final Timestamp getTimestamp(String parameterName)
1:b5f2776:             throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     /**
1:b5f2776:      * JDBC 3.0
1:b5f2776:      *
1:b5f2776:      * Retrieves the value of a JDBC TIMESTAMP parameter as a java.sql.Timestamp
1:b5f2776:      * object, using the given Calendar object to construct the Timestamp
1:b5f2776:      * object.
1:b5f2776:      *
1:b5f2776:      * @param parameterName - the name of the parameter
1:b5f2776:      * @param cal - the Calendar object the driver will use to construct the
1:b5f2776:      * Timestamp
1:b5f2776:      * @return the parameter value. If the value is SQL NULL, the result is
1:b5f2776:      * null.
1:b5f2776:      * @exception SQLException Feature not implemented for now.
1:b5f2776:      */
1:b5f2776:     public final Timestamp getTimestamp(String parameterName, Calendar cal)
1:b5f2776:             throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     /**
1:b5f2776:      * JDBC 3.0
1:b5f2776:      *
1:b5f2776:      * Sets the designated parameter to the given input stream, which will have
1:b5f2776:      * the specified number of bytes.
1:b5f2776:      *
1:b5f2776:      * @param parameterName - the name of the parameter
1:b5f2776:      * @param x - the Java input stream that contains the ASCII parameter value
1:b5f2776:      * @param length - the number of bytes in the stream
1:b5f2776:      * @exception SQLException Feature not implemented for now.
1:b5f2776:      */
1:b5f2776:     public final void setAsciiStream(String parameterName, InputStream x, int length)
1:b5f2776:             throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     /**
1:b5f2776:      * JDBC 3.0
1:b5f2776:      *
1:b5f2776:      * Sets the designated parameter to the given input stream, which will have
1:b5f2776:      * the specified number of bytes.
1:b5f2776:      *
1:b5f2776:      * @param parameterName - the name of the parameter
1:b5f2776:      * @param x - the Java input stream that contains the binary parameter value
1:b5f2776:      * @param length - the number of bytes in the stream
1:b5f2776:      * @exception SQLException Feature not implemented for now.
1:b5f2776:      */
1:b5f2776:     public final void setBinaryStream(String parameterName, InputStream x, int length)
1:b5f2776:             throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     /**
1:b5f2776:      * JDBC 3.0
1:b5f2776:      *
1:b5f2776:      * Sets the designated parameter to the given Reader object, which is the
1:b5f2776:      * given number of characters long.
1:b5f2776:      *
1:b5f2776:      * @param parameterName - the name of the parameter
1:b5f2776:      * @param reader - the java.io.Reader object that contains the UNICODE data
1:b5f2776:      * @param length - the number of characters in the stream
1:b5f2776:      * @exception SQLException Feature not implemented for now.
1:b5f2776:      */
1:b5f2776:     public final void setCharacterStream(String parameterName, Reader reader, int length)
1:b5f2776:             throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     /**
1:b5f2776:      * JDBC 3.0
1:b5f2776:      *
1:b5f2776:      * Sets the value of the designated parameter with the given object. The
1:b5f2776:      * second argument must be an object type; for integral values, the
1:b5f2776:      * java.lang equivalent objects should be used.
1:b5f2776:      *
1:b5f2776:      * @param parameterName - the name of the parameter
1:b5f2776:      * @param x - the object containing the input parameter value
1:b5f2776:      * @param targetSqlType - the SQL type (as defined in java.sql.Types) to be
1:b5f2776:      * sent to the database. The scale argument may further qualify this type.
1:b5f2776:      * @param scale - for java.sql.Types.DECIMAL or java.sql.Types.NUMERIC
1:b5f2776:      * types, this is the number of digits after the decimal point. For all
1:b5f2776:      * other types, this value will be ignored.
1:b5f2776:      * @exception SQLException Feature not implemented for now.
1:b5f2776:      */
1:b5f2776:     public final void setObject(String parameterName, Object x, int targetSqlType, int scale)
1:b5f2776:             throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     /**
1:b5f2776:      * JDBC 3.0
1:b5f2776:      *
1:b5f2776:      * Retrieves the value of a parameter as an Object in the java programming
1:b5f2776:      * language.
1:b5f2776:      *
1:b5f2776:      * @param parameterName - the name of the parameter
1:b5f2776:      * @return a java.lang.Object holding the OUT parameter value
1:b5f2776:      * @exception SQLException Feature not implemented for now.
1:b5f2776:      */
1:b5f2776:     public final Object getObject(String parameterName) throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     /**
1:b5f2776:      * JDBC 3.0
1:b5f2776:      *
1:b5f2776:      * Returns an object representing the value of OUT parameter i and uses map
1:b5f2776:      * for the custom mapping of the parameter value.
1:b5f2776:      *
1:b5f2776:      * @param parameterName - the name of the parameter
1:b5f2776:      * @param map - the mapping from SQL type names to Java classes
1:b5f2776:      * @return a java.lang.Object holding the OUT parameter value
1:b5f2776:      * @exception SQLException Feature not implemented for now.
1:b5f2776:      */
1:b5f2776:     public final Object getObject(String parameterName, Map<String, Class<?>> map)
1:b5f2776:             throws SQLException {
1:b5f2776:         checkStatus();
1:b5f2776:         if (map == null) {
1:b5f2776:             throw Util.generateCsSQLException(SQLState.INVALID_API_PARAMETER, map, "map",
1:b5f2776:                     "java.sql.CallableStatement.getObject");
1:b5f2776:         }
1:b5f2776:         if (!(map.isEmpty())) {
1:b5f2776:             throw Util.notImplemented();
1:b5f2776:         }
1:b5f2776: 
1:b5f2776:         // Map is empty so call the normal getObject method.
1:b5f2776:         return getObject(parameterName);
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     /**
1:b5f2776:      * JDBC 3.0
1:b5f2776:      *
1:b5f2776:      * Sets the value of the designated parameter with the given object. This
1:b5f2776:      * method is like the method setObject above, except that it assumes a scale
1:b5f2776:      * of zero.
1:b5f2776:      *
1:b5f2776:      * @param parameterName - the name of the parameter
1:b5f2776:      * @param x - the object containing the input parameter value
1:b5f2776:      * @param targetSqlType - the SQL type (as defined in java.sql.Types) to be
1:b5f2776:      * sent to the database.
1:b5f2776:      * @exception SQLException Feature not implemented for now.
1:b5f2776:      */
1:b5f2776:     public final void setObject(String parameterName, Object x, int targetSqlType)
1:b5f2776:             throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     /**
1:b5f2776:      * JDBC 3.0
1:b5f2776:      *
1:b5f2776:      * Sets the value of the designated parameter with the given object. The
1:b5f2776:      * second parameter must be of type Object; therefore, the java.lang
1:b5f2776:      * equivalent objects should be used for built-in types.
1:b5f2776:      *
1:b5f2776:      * @param parameterName - the name of the parameter
1:b5f2776:      * @param x - the object containing the input parameter value
1:b5f2776:      * @exception SQLException Feature not implemented for now.
1:b5f2776:      */
1:b5f2776:     public final void setObject(String parameterName, Object x)
1:b5f2776:             throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     // JDBC 4.0 methods
1:b5f2776: 
1:b5f2776:     /**
1:b5f2776:      * Retrieves the value of the designated parameter as a
1:b5f2776:      * <code>java.io.Reader</code> object in the Java programming language.
1:b5f2776:      * Introduced in JDBC 4.0.
1:b5f2776:      *
1:b5f2776:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:b5f2776:      * @return a <code>java.io.Reader</code> object that contains the parameter
1:b5f2776:      * value; if the value is SQL <code>NULL</code>, the value returned
1:b5f2776:      * is <code>null</code> in the Java programming language.
1:b5f2776:      * @throws SQLException if a database access error occurs or this method is
1:b5f2776:      * called on a closed <code>CallableStatement</code>
1:b5f2776:      */
1:b5f2776:     public final Reader getCharacterStream(int parameterIndex)
1:b5f2776:             throws SQLException {
1:b5f2776:         checkStatus();
1:b5f2776:         // Make sure the specified parameter has mode OUT or IN/OUT.
1:b5f2776:         switch (getParms().getParameterMode(parameterIndex)) {
1:b5f2776:             case (ParameterMetaData.parameterModeIn):
1:b5f2776:             case (ParameterMetaData.parameterModeUnknown):
1:b5f2776:                 throw newSQLException(SQLState.LANG_NOT_OUTPUT_PARAMETER,
1:b5f2776:                         Integer.toString(parameterIndex));
1:b5f2776:         }
1:b5f2776:         Reader reader = null;
1:b5f2776:         int paramType = getParameterJDBCType(parameterIndex);
1:b5f2776:         switch (paramType) {
1:b5f2776:             // Handle character/string types.
1:b5f2776:             case Types.CHAR:
1:b5f2776:             case Types.VARCHAR:
1:b5f2776:             case Types.LONGVARCHAR:
1:b5f2776:             case Types.CLOB:
1:b5f2776:                 boolean pushStack = false;
1:b5f2776:                 Object syncObject = getConnectionSynchronization();
1:b5f2776:                 synchronized (syncObject) {
1:94df7fb:                     try {
1:b5f2776:                         StringDataValue param = (StringDataValue) getParms().getParameterForGet(parameterIndex - 1);
1:b5f2776:                         if (param.isNull()) {
1:b5f2776:                             break;
1:b5f2776:                         }
1:b5f2776:                         pushStack = true;
1:b5f2776:                         setupContextStack();
1:b5f2776: 
1:b5f2776:                         if (param.hasStream()) {
1:b5f2776:                             CharacterStreamDescriptor csd =
1:b5f2776:                                     param.getStreamWithDescriptor();
1:b5f2776:                             reader = new UTF8Reader(csd, this, syncObject);
1:b5f2776:                         } else {
1:b5f2776:                             reader = new StringReader(param.getString());
1:b5f2776:                         }
1:b5f2776:                     } catch (Throwable t) {
1:b5f2776:                         throw EmbedResultSet.noStateChangeException(t);
1:b5f2776:                     } finally {
1:b5f2776:                         if (pushStack) {
1:b5f2776:                             restoreContextStack();
1:b5f2776:                         }
1:b5f2776:                     }
1:b5f2776:                 } // End synchronized block
1:b5f2776:                 break;
1:b5f2776: 
1:b5f2776:             // Handle binary types.
1:b5f2776:             // JDBC says to support these, but no defintion exists for the output.
1:b5f2776:             // Match JCC which treats the bytes as a UTF-16BE stream.
1:b5f2776:             case Types.BINARY:
1:b5f2776:             case Types.VARBINARY:
1:b5f2776:             case Types.LONGVARBINARY:
1:b5f2776:             case Types.BLOB:
1:b5f2776:                 try {
1:b5f2776:                     InputStream is = getBinaryStream(parameterIndex);
1:b5f2776:                     if (is != null) {
1:b5f2776:                         reader = new InputStreamReader(is, "UTF-16BE");
1:b5f2776:                     }
1:b5f2776:                     break;
1:b5f2776:                 } catch (UnsupportedEncodingException uee) {
1:b5f2776:                     throw newSQLException(uee.getMessage());
1:b5f2776:                 }
1:b5f2776: 
1:b5f2776:             default:
1:b5f2776:                 throw newSQLException(SQLState.LANG_DATA_TYPE_GET_MISMATCH,
1:b5f2776:                         "java.io.Reader", Util.typeName(paramType));
1:b5f2776:         }
1:b5f2776:         // Update wasNull.
1:b5f2776:         wasNull = (reader == null);
1:b5f2776:         return reader;
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     /**
1:b5f2776:      * Get binary stream for a parameter.
1:b5f2776:      *
1:b5f2776:      * @param parameterIndex first parameter is 1, second is 2 etc.
1:b5f2776:      * @return a stream for the binary parameter, or <code>null</code>.
1:b5f2776:      *
1:b5f2776:      * @throws SQLException if a database access error occurs.
1:b5f2776:      */
1:b5f2776:     private InputStream getBinaryStream(int parameterIndex)
1:b5f2776:             throws SQLException {
1:b5f2776:         int paramType = getParameterJDBCType(parameterIndex);
1:b5f2776:         switch (paramType) {
1:b5f2776:             case Types.BINARY:
1:b5f2776:             case Types.VARBINARY:
1:b5f2776:             case Types.LONGVARBINARY:
1:b5f2776:             case Types.BLOB:
1:b5f2776:                 break;
1:b5f2776:             default:
1:b5f2776:                 throw newSQLException(SQLState.LANG_DATA_TYPE_GET_MISMATCH,
1:b5f2776:                         "java.io.InputStream", Util.typeName(paramType));
1:b5f2776:         }
1:b5f2776: 
1:b5f2776:         boolean pushStack = false;
1:b5f2776:         synchronized (getConnectionSynchronization()) {
1:b5f2776:             try {
1:b5f2776:                 DataValueDescriptor param =
1:b5f2776:                         getParms().getParameterForGet(parameterIndex - 1);
1:b5f2776:                 wasNull = param.isNull();
1:b5f2776:                 if (wasNull) {
1:b5f2776:                     return null;
1:b5f2776:                 }
1:b5f2776:                 pushStack = true;
1:b5f2776:                 setupContextStack();
1:b5f2776: 
1:b5f2776:                 InputStream stream; // The stream we will return to the user
1:b5f2776:                 if (param.hasStream()) {
1:b5f2776:                     stream = new BinaryToRawStream(param.getStream(), param);
1:b5f2776:                 } else {
1:b5f2776:                     stream = new ByteArrayInputStream(param.getBytes());
1:b5f2776:                 }
1:b5f2776:                 return stream;
1:b5f2776:             } catch (Throwable t) {
1:b5f2776:                 throw EmbedResultSet.noStateChangeException(t);
1:b5f2776:             } finally {
1:b5f2776:                 if (pushStack) {
1:b5f2776:                     restoreContextStack();
1:b5f2776:                 }
1:b5f2776:             }
1:b5f2776:         } // End synchronized block
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     public final Reader getCharacterStream(String parameterName)
1:b5f2776:             throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     public final Reader getNCharacterStream(int parameterIndex)
1:b5f2776:             throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     public final Reader getNCharacterStream(String parameterName)
1:b5f2776:             throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     public final String getNString(int parameterIndex)
1:b5f2776:             throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     public final String getNString(String parameterName)
1:b5f2776:             throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     public final void setBlob(String parameterName, Blob x)
1:b5f2776:             throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     public final void setClob(String parameterName, Clob x)
1:b5f2776:             throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     public final RowId getRowId(int parameterIndex) throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     public final RowId getRowId(String parameterName) throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     public final void setRowId(String parameterName, RowId x) throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     public final void setNString(String parameterName, String value)
1:b5f2776:             throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     public final void setNCharacterStream(String parameterName, Reader value, long length)
1:b5f2776:             throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     public final void setNClob(String parameterName, NClob value) throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     public final void setClob(String parameterName, Reader reader, long length)
1:b5f2776:             throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776: 
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     public final void setBlob(String parameterName, InputStream inputStream, long length)
1:b5f2776:             throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     public final void setNClob(String parameterName, Reader reader, long length)
1:b5f2776:             throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     public final NClob getNClob(int i) throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     public final NClob getNClob(String parameterName) throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     public final void setSQLXML(String parameterName, SQLXML xmlObject) throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776: 
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     public final SQLXML getSQLXML(int parameterIndex) throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     public final SQLXML getSQLXML(String parametername) throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     public final void setAsciiStream(String parameterName, InputStream x)
1:b5f2776:             throws SQLException {
1:b5f2776:         throw Util.notImplemented("setAsciiStream(String,InputStream)");
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     public final void setBinaryStream(String parameterName, InputStream x)
1:b5f2776:             throws SQLException {
1:b5f2776:         throw Util.notImplemented("setBinaryStream(String,InputStream)");
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     public final void setBlob(String parameterName, InputStream inputStream)
1:b5f2776:             throws SQLException {
1:b5f2776:         throw Util.notImplemented("setBlob(String,InputStream)");
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     public final void setCharacterStream(String parameterName, Reader reader)
1:b5f2776:             throws SQLException {
1:b5f2776:         throw Util.notImplemented("setCharacterStream(String,Reader)");
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     public final void setClob(String parameterName, Reader reader)
1:b5f2776:             throws SQLException {
1:b5f2776:         throw Util.notImplemented("setClob(String,Reader)");
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     public final void setNCharacterStream(String parameterName, Reader value)
1:b5f2776:             throws SQLException {
1:b5f2776:         throw Util.notImplemented("setNCharacterStream(String,Reader)");
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     public final void setNClob(String parameterName, Reader reader)
1:b5f2776:             throws SQLException {
1:b5f2776:         throw Util.notImplemented("setNClob(String,Reader)");
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     /**
1:b5f2776:      * Sets the designated parameter to the given input stream, which will have
1:b5f2776:      * the specified number of bytes.
1:b5f2776:      *
1:b5f2776:      * @param parameterName the name of the first parameter
1:b5f2776:      * @param x the java input stream which contains the ASCII parameter value
1:b5f2776:      * @param length the number of bytes in the stream
1:b5f2776:      * @exception SQLException thrown on failure.
1:b5f2776:      *
1:b5f2776:      */
1:b5f2776:     public final void setAsciiStream(String parameterName, InputStream x, long length)
1:b5f2776:             throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     /**
1:b5f2776:      * Sets the designated parameter to the given input stream, which will have
1:b5f2776:      * the specified number of bytes.
1:b5f2776:      *
1:b5f2776:      * @param parameterName the name of the first parameter
1:b5f2776:      * @param x the java input stream which contains the binary parameter value
1:b5f2776:      * @param length the number of bytes in the stream
1:b5f2776:      * @exception SQLException thrown on failure.
1:b5f2776:      *
1:b5f2776:      */
1:b5f2776:     public final void setBinaryStream(String parameterName, InputStream x, long length)
1:b5f2776:             throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     /**
1:b5f2776:      * Sets the designated parameter to the given Reader, which will have the
1:b5f2776:      * specified number of bytes.
1:b5f2776:      *
1:b5f2776:      * @param parameterName the name of the first parameter
1:b5f2776:      * @param x the java Reader which contains the UNICODE value
1:b5f2776:      * @param length the number of bytes in the stream
1:b5f2776:      * @exception SQLException thrown on failure.
1:b5f2776:      *
1:b5f2776:      */
1:b5f2776:     public final void setCharacterStream(String parameterName, Reader x, long length)
1:b5f2776:             throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     ////////////////////////////////////////////////////////////////////
1:b5f2776:     //
1:b5f2776:     // INTRODUCED BY JDBC 4.1 IN JAVA 7
1:b5f2776:     //
1:b5f2776:     ////////////////////////////////////////////////////////////////////
1:b5f2776:     public final <T> T getObject(int parameterIndex, Class<T> type)
1:b5f2776:             throws SQLException {
1:b5f2776:         checkStatus();
1:b5f2776: 
1:b5f2776:         if (type == null) {
1:b5f2776:             throw mismatchException("NULL", parameterIndex);
1:b5f2776:         }
1:b5f2776: 
1:b5f2776:         Object retval;
1:b5f2776: 
1:b5f2776:         if (String.class.equals(type)) {
1:b5f2776:             retval = getString(parameterIndex);
1:b5f2776:         } else if (BigDecimal.class.equals(type)) {
1:b5f2776:             retval = getBigDecimal(parameterIndex);
1:b5f2776:         } else if (Boolean.class.equals(type)) {
1:b5f2776:             retval = getBoolean(parameterIndex);
1:b5f2776:         } else if (Byte.class.equals(type)) {
1:b5f2776:             retval = getByte(parameterIndex);
1:b5f2776:         } else if (Short.class.equals(type)) {
1:b5f2776:             retval = getShort(parameterIndex);
1:b5f2776:         } else if (Integer.class.equals(type)) {
1:b5f2776:             retval = getInt(parameterIndex);
1:b5f2776:         } else if (Long.class.equals(type)) {
1:b5f2776:             retval = getLong(parameterIndex);
1:b5f2776:         } else if (Float.class.equals(type)) {
1:b5f2776:             retval = getFloat(parameterIndex);
1:b5f2776:         } else if (Double.class.equals(type)) {
1:b5f2776:             retval = getDouble(parameterIndex);
1:b5f2776:         } else if (Date.class.equals(type)) {
1:b5f2776:             retval = getDate(parameterIndex);
1:b5f2776:         } else if (Time.class.equals(type)) {
1:b5f2776:             retval = getTime(parameterIndex);
1:b5f2776:         } else if (Timestamp.class.equals(type)) {
1:b5f2776:             retval = getTimestamp(parameterIndex);
1:b5f2776:         } else if (Blob.class.equals(type)) {
1:b5f2776:             retval = getBlob(parameterIndex);
1:b5f2776:         } else if (Clob.class.equals(type)) {
1:b5f2776:             retval = getClob(parameterIndex);
1:b5f2776:         } else if (type.isArray() && type.getComponentType().equals(byte.class)) {
1:b5f2776:             retval = getBytes(parameterIndex);
1:b5f2776:         } else {
1:b5f2776:             retval = getObject(parameterIndex);
1:b5f2776:         }
1:b5f2776: 
1:b5f2776:         if (wasNull()) {
1:b5f2776:             retval = null;
1:b5f2776:         }
1:b5f2776: 
1:b5f2776:         if ((retval == null) || (type.isInstance(retval))) {
1:b5f2776:             return type.cast(retval);
1:b5f2776:         }
1:b5f2776: 
1:b5f2776:         throw mismatchException(type.getName(), parameterIndex);
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     private SQLException mismatchException(String targetTypeName, int parameterIndex)
1:b5f2776:             throws SQLException {
1:b5f2776:         String sourceTypeName = getParameterMetaData().getParameterTypeName(parameterIndex);
1:b5f2776:         return newSQLException(SQLState.LANG_DATA_TYPE_GET_MISMATCH, targetTypeName, sourceTypeName);
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     public final <T> T getObject(String parameterName, Class<T> type)
1:b5f2776:             throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776:     }
1:b5f2776: 
1:eac0369: }
1:eac0369: 
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1:      * Retrieves the value of a JDBC REF (structured-type) parameter as a Ref
commit:ce40a31
/////////////////////////////////////////////////////////////////////////
1: 			throw newSQLException(SQLState.BAD_SCALE_VALUE, scale);
commit:eec86ed
/////////////////////////////////////////////////////////////////////////
0: public abstract class EmbedCallableStatement extends EmbedPreparedStatement
commit:9206d5b
/////////////////////////////////////////////////////////////////////////
1: 	 * Derby ignores the typeName argument because UDTs don't need it.
/////////////////////////////////////////////////////////////////////////
1:  		registerOutParameter( parameterIndex, sqlType );
commit:10608cf
/////////////////////////////////////////////////////////////////////////
1: import java.math.BigDecimal;
/////////////////////////////////////////////////////////////////////////
1: 	/*
0: 	** Methods using BigDecimal, moved back into EmbedCallableStatement
0:     ** because our small device implementation now requires CDC/FP 1.1.
1: 	*/
1:     /**
1:      * JDBC 2.0
1:      *
1:      * Get the value of a NUMERIC parameter as a java.math.BigDecimal object.
1:      *
1:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:      * @return the parameter value (full precision); if the value is SQL NULL, 
1:      * the result is null 
1:      * @exception SQLException if a database-access error occurs.
1:      */
1:     public final BigDecimal getBigDecimal(int parameterIndex) throws SQLException 
1: 	{
1: 		checkStatus();
1: 		try {
1: 			DataValueDescriptor dvd = getParms().getParameterForGet(parameterIndex-1);
1: 			if (wasNull = dvd.isNull())
1: 				return null;
1: 			
1: 			return org.apache.derby.iapi.types.SQLDecimal.getBigDecimal(dvd);
1: 			
1: 		} catch (StandardException e)
1: 		{
1: 			throw EmbedResultSet.noStateChangeException(e);
1: 		}
1: 	}
1: 
1:     /**
1: 	 * @see CallableStatement#getBigDecimal
1:      * @exception SQLException NoOutputParameters thrown.
1:      * @deprecated
1:      */
1:     public final BigDecimal getBigDecimal(int parameterIndex, int scale) throws SQLException
1: 	{
1:     	BigDecimal v = getBigDecimal(parameterIndex);
1:     	if (v != null)
1:     		v = v.setScale(scale, BigDecimal.ROUND_HALF_DOWN);
1:     	return v;
1: 	}
1: 
commit:147e86d
/////////////////////////////////////////////////////////////////////////
1:      * @param parameterIndex the first parameter is 1, the second is 2, ...
/////////////////////////////////////////////////////////////////////////
1:      * @param parameterIndex the first parameter is 1, the second is 2, ...
commit:94df7fb
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * JDBC 2.0
1:      *
1:      * Get a BLOB OUT parameter.
1:      *
1:      * @param i the first parameter is 1, the second is 2, ...
1:      * @return an object representing a BLOB
1:      * @exception SQLException if a database-access error occurs.
1:      */
1:     public Blob getBlob (int parameterIndex) throws SQLException {
1: 		checkStatus();
1: 		try {
1: 			DataValueDescriptor param = getParms().getParameterForGet(parameterIndex-1);
0: 			Blob v = (Blob) param.getObject();
1: 			wasNull = (v == null);
1: 			return v;
1: 		} catch (StandardException e)
1: 		{
1: 			throw EmbedResultSet.noStateChangeException(e);
1:     }
1:     /**
1:      * JDBC 2.0
1:      *
1:      * Get a CLOB OUT parameter.
1:      *
1:      * @param i the first parameter is 1, the second is 2, ...
1:      * @return an object representing a CLOB
1:      * @exception SQLException if a database-access error occurs.
1:      */
1:     public Clob getClob (int parameterIndex) throws SQLException {
1: 		checkStatus();
1: 		try {
1: 			DataValueDescriptor param = getParms().getParameterForGet(parameterIndex-1);
0: 			Clob v = (Clob) param.getObject();
1: 			wasNull = (v == null);
1: 			return v;
1: 		} catch (StandardException e)
1: 		{
1: 			throw EmbedResultSet.noStateChangeException(e);
1:     }
1:     
commit:88a3cb9
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:5465561
/////////////////////////////////////////////////////////////////////////
commit:b5f2776
/////////////////////////////////////////////////////////////////////////
1: import java.io.ByteArrayInputStream;
1: import java.io.InputStream;
1: import java.io.InputStreamReader;
1: import java.io.Reader;
1: import java.io.StringReader;
1: import java.io.UnsupportedEncodingException;
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Array;
1: import java.sql.NClob;
1: import java.sql.Ref;
1: import java.sql.RowId;
1: import java.sql.SQLXML;
1: import java.sql.Types;
1: import java.util.Map;
1: import org.apache.derby.iapi.jdbc.CharacterStreamDescriptor;
1: import org.apache.derby.iapi.jdbc.EngineCallableStatement;
1: import org.apache.derby.iapi.types.StringDataValue;
1: public class EmbedCallableStatement extends EmbedPreparedStatement
1:     implements EngineCallableStatement
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * JDBC 2.0
1:      *
1:      * Returns an object representing the value of OUT parameter {@code i}.
1:      * Use the map to determine the class from which to construct data of SQL
1:      * structured and distinct types.
1:      *
1:      * @param i the first parameter is 1, the second is 2, ...
1:      * @param map the mapping from SQL type names to Java classes
1:      * @return a java.lang.Object holding the OUT parameter value.
1:      * @exception SQLException if a database-access error occurs.
1:      */
1:     public final Object getObject(int i, Map<String, Class<?>> map) throws SQLException {
1:         checkStatus();
1:         if (map == null) {
1:             throw Util.generateCsSQLException(SQLState.INVALID_API_PARAMETER, map, "map",
1:                     "java.sql.CallableStatement.getObject");
1:         }
1:         if (!map.isEmpty()) {
1:             throw Util.notImplemented();
1:         }
1:         // Map is empty call the normal getObject method.
1:         return getObject(i);
1:     }
1: 
1:     /**
1:      * JDBC 2.0
1:      *
1:      * Get a REF(&lt;structured-type&gt;) OUT parameter.
1:      *
1:      * @param i the first parameter is 1, the second is 2, ...
1:      * @return an object representing data of an SQL REF Type
1:      * @exception SQLException if a database-access error occurs.
1:      */
1:     public final Ref getRef(int i) throws SQLException {
1:         throw Util.notImplemented();
1:     }
1: 
1:     /**
1:      * JDBC 2.0
1:      *
1:      * Get an Array OUT parameter.
1:      *
1:      * @param i the first parameter is 1, the second is 2, ...
1:      * @return an object representing an SQL array
1:      * @exception SQLException if a database-access error occurs.
1:      */
1:     public final Array getArray(int i) throws SQLException {
1:         throw Util.notImplemented();
1:     }
1: 
1:     // JDBC 3.0 methods
1: 
1:     /**
1:      * JDBC 3.0
1:      *
1:      * Registers the OUT parameter named parameterName to the JDBC type sqlType.
1:      * All OUT parameters must be registered before a stored procedure is
1:      * executed.
1:      *
1:      * @param parameterName - the name of the parameter
1:      * @param sqlType - the JDBC type code defined by java.sql.Types. If the
1:      * parameter is of JDBC type NUMERIC or DECIMAL, the version of
1:      * registerOutParameter that accepts a scale value should be used.
1:      * @exception SQLException Feature not implemented for now.
1:      */
1:     public final void registerOutParameter(String parameterName, int sqlType)
1:             throws SQLException {
1:         throw Util.notImplemented();
1:     }
1: 
1:     /**
1:      * JDBC 3.0
1:      *
1:      * Registers the designated output parameter. This version of the method
1:      * registerOutParameter should be used for a user-named or REF output
1:      * parameter.
1:      *
1:      * @param parameterName - the name of the parameter
1:      * @param sqlType - the SQL type code defined by java.sql.Types.
1:      * @param typeName - the fully-qualified name of an SQL structure type
1:      * @exception SQLException Feature not implemented for now.
1:      */
1:     public final void registerOutParameter(String parameterName,
1:             int sqlType, String typeName)
1:             throws SQLException {
1:         throw Util.notImplemented();
1:     }
1: 
1:     /**
1:      * JDBC 3.0
1:      *
1:      * Registers the parameter named parameterName to the JDBC type sqlType.
1:      * This method must be called before a stored procedure is executed.
1:      *
1:      * @param parameterName - the name of the parameter
1:      * @param sqlType - the SQL type code defined by java.sql.Types.
1:      * @param scale - the desired number of digits to the right of the decimal
1:      * point. It must be greater than or equal to zero.
1:      * @exception SQLException Feature not implemented for now.
1:      */
1:     public final void registerOutParameter(String parameterName,
1:             int sqlType, int scale) throws SQLException {
1:         throw Util.notImplemented();
1:     }
1: 
1:     /**
1:      * JDBC 3.0
1:      *
0:      * Retrieves the value of a JDBC REF (<structured-type) parameter as a Ref
1:      * object in the Java programming language.
1:      *
1:      * @param parameterName - the name of the parameter
1:      * @return the parameter value as a Ref object in the Java Programming
1:      * language. If the value is SQL NULL, the result is null.
1:      * @exception SQLException Feature not implemented for now.
1:      */
1:     public final Ref getRef(String parameterName) throws SQLException {
1:         throw Util.notImplemented();
1:     }
1: 
1:     /**
1:      * JDBC 3.0
1:      *
1:      * Retrieves the value of a JDBC BLOB parameter as a Blob object in the Java
1:      * programming language.
1:      *
1:      * @param parameterName - the name of the parameter
1:      * @return the parameter value as a Blob object in the Java Programming
1:      * language. If the value is SQL NULL, the result is null.
1:      * @exception SQLException Feature not implemented for now.
1:      */
1:     public final Blob getBlob(String parameterName) throws SQLException {
1:         throw Util.notImplemented();
1:     }
1: 
1:     /**
1:      * JDBC 3.0
1:      *
1:      * Retrieves the value of a JDBC CLOB parameter as a Clob object in the Java
1:      * programming language.
1:      *
1:      * @param parameterName - the name of the parameter
1:      * @return the parameter value as a Clob object in the Java Programming
1:      * language. If the value is SQL NULL, the result is null.
1:      * @exception SQLException Feature not implemented for now.
1:      */
1:     public final Clob getClob(String parameterName) throws SQLException {
1:         throw Util.notImplemented();
1:     }
1: 
1:     /**
1:      * JDBC 3.0
1:      *
1:      * Retrieves the value of a JDBC ARRAY parameter as an Array object in the
1:      * Java programming language.
1:      *
1:      * @param parameterName - the name of the parameter
1:      * @return the parameter value as a Array object in the Java Programming
1:      * language. If the value is SQL NULL, the result is null.
1:      * @exception SQLException Feature not implemented for now.
1:      */
1:     public final Array getArray(String parameterName) throws SQLException {
1:         throw Util.notImplemented();
1:     }
1: 
1:     /**
1:      * JDBC 3.0
1:      *
1:      * Sets the designated parameter to SQL NULL.
1:      *
1:      * @param parameterName - the name of the parameter
1:      * @param sqlType - the SQL type code defined in java.sql.Types
1:      * @exception SQLException Feature not implemented for now.
1:      */
1:     public final void setNull(String parameterName, int sqlType)
1:             throws SQLException {
1:         throw Util.notImplemented();
1:     }
1: 
1:     /**
1:      * JDBC 3.0
1:      *
1:      * Sets the designated parameter to SQL NULL.
1:      *
1:      * @param parameterName - the name of the parameter
1:      * @param sqlType - the SQL type code defined in java.sql.Types
1:      * @param typeName - the fully-qualified name of an SQL user-defined type
1:      * @exception SQLException Feature not implemented for now.
1:      */
1:     public final void setNull(String parameterName, int sqlType, String typeName)
1:             throws SQLException {
1:         throw Util.notImplemented();
1:     }
1: 
1:     /**
1:      * JDBC 3.0
1:      *
1:      * Sets the designated parameter to the given Java boolean value. The driver
1:      * converts this to an SQL BIT value when it sends it to the database.
1:      *
1:      * @param parameterName - the name of the parameter
1:      * @param x - the parameter value
1:      * @exception SQLException Feature not implemented for now.
1:      */
1:     public final void setBoolean(String parameterName, boolean x)
1:             throws SQLException {
1:         throw Util.notImplemented();
1:     }
1: 
1:     /**
1:      * JDBC 3.0
1:      *
1:      * Retrieves the value of a JDBC BIT parameter as a boolean in the Java
1:      * programming language.
1:      *
1:      * @param parameterName - the name of the parameter
1:      * @return the parameter value. If the value is SQL NULL, the result is
1:      * false.
1:      * @exception SQLException Feature not implemented for now.
1:      */
1:     public final boolean getBoolean(String parameterName) throws SQLException {
1:         throw Util.notImplemented();
1:     }
1: 
1:     /**
1:      * JDBC 3.0
1:      *
1:      * Sets the designated parameter to the given Java byte value. The driver
1:      * converts this to an SQL TINYINT value when it sends it to the database.
1:      *
1:      * @param parameterName - the name of the parameter
1:      * @param x - the parameter value
1:      * @exception SQLException Feature not implemented for now.
1:      */
1:     public final void setByte(String parameterName, byte x)
1:             throws SQLException {
1:         throw Util.notImplemented();
1:     }
1: 
1:     /**
1:      * JDBC 3.0
1:      *
1:      * Retrieves the value of a JDBC TINYINT parameter as a byte in the Java
1:      * programming language.
1:      *
1:      * @param parameterName - the name of the parameter
1:      * @return the parameter value. If the value is SQL NULL, the result is 0.
1:      * @exception SQLException Feature not implemented for now.
1:      */
1:     public final byte getByte(String parameterName) throws SQLException {
1:         throw Util.notImplemented();
1:     }
1: 
1:     /**
1:      * JDBC 3.0
1:      *
1:      * Sets the designated parameter to the given Java short value. The driver
1:      * converts this to an SQL SMALLINT value when it sends it to the database.
1:      *
1:      * @param parameterName - the name of the parameter
1:      * @param x - the parameter value
1:      * @exception SQLException Feature not implemented for now.
1:      */
1:     public final void setShort(String parameterName, short x)
1:             throws SQLException {
1:         throw Util.notImplemented();
1:     }
1: 
1:     /**
1:      * JDBC 3.0
1:      *
1:      * Retrieves the value of a JDBC SMALLINT parameter as a short in the Java
1:      * programming language.
1:      *
1:      * @param parameterName - the name of the parameter
1:      * @return the parameter value. If the value is SQL NULL, the result is 0.
1:      * @exception SQLException Feature not implemented for now.
1:      */
1:     public final short getShort(String parameterName) throws SQLException {
1:         throw Util.notImplemented();
1:     }
1: 
1:     /**
1:      * JDBC 3.0
1:      *
1:      * Sets the designated parameter to the given Java int value. The driver
1:      * converts this to an SQL INTEGER value when it sends it to the database.
1:      *
1:      * @param parameterName - the name of the parameter
1:      * @param x - the parameter value
1:      * @exception SQLException Feature not implemented for now.
1:      */
1:     public final void setInt(String parameterName, int x) throws SQLException {
1:         throw Util.notImplemented();
1:     }
1: 
1:     /**
1:      * JDBC 3.0
1:      *
1:      * Retrieves the value of a JDBC INTEGER parameter as a int in the Java
1:      * programming language.
1:      *
1:      * @param parameterName - the name of the parameter
1:      * @return the parameter value. If the value is SQL NULL, the result is 0.
1:      * @exception SQLException Feature not implemented for now.
1:      */
1:     public final int getInt(String parameterName) throws SQLException {
1:         throw Util.notImplemented();
1:     }
1: 
1:     /**
1:      * JDBC 3.0
1:      *
1:      * Sets the designated parameter to the given Java long value. The driver
1:      * converts this to an SQL BIGINT value when it sends it to the database.
1:      *
1:      * @param parameterName - the name of the parameter
1:      * @param x - the parameter value
1:      * @exception SQLException Feature not implemented for now.
1:      */
1:     public final void setLong(String parameterName, long x)
1:             throws SQLException {
1:         throw Util.notImplemented();
1:     }
1: 
1:     /**
1:      * JDBC 3.0
1:      *
1:      * Retrieves the value of a JDBC BIGINT parameter as a long in the Java
1:      * programming language.
1:      *
1:      * @param parameterName - the name of the parameter
1:      * @return the parameter value. If the value is SQL NULL, the result is 0.
1:      * @exception SQLException Feature not implemented for now.
1:      */
1:     public final long getLong(String parameterName) throws SQLException {
1:         throw Util.notImplemented();
1:     }
1: 
1:     /**
1:      * JDBC 3.0
1:      *
1:      * Sets the designated parameter to the given Java float value. The driver
1:      * converts this to an SQL FLOAT value when it sends it to the database.
1:      *
1:      * @param parameterName - the name of the parameter
1:      * @param x - the parameter value
1:      * @exception SQLException Feature not implemented for now.
1:      */
1:     public final void setFloat(String parameterName, float x)
1:             throws SQLException {
1:         throw Util.notImplemented();
1:     }
1: 
1:     /**
1:      * JDBC 3.0
1:      *
1:      * Retrieves the value of a JDBC FLOAT parameter as a float in the Java
1:      * programming language.
1:      *
1:      * @param parameterName - the name of the parameter
1:      * @return the parameter value. If the value is SQL NULL, the result is 0.
1:      * @exception SQLException Feature not implemented for now.
1:      */
1:     public final float getFloat(String parameterName)
1:             throws SQLException {
1:         throw Util.notImplemented();
1:     }
1: 
1:     /**
1:      * JDBC 3.0
1:      *
1:      * Sets the designated parameter to the given Java double value. The driver
1:      * converts this to an SQL DOUBLE value when it sends it to the database.
1:      *
1:      * @param parameterName - the name of the parameter
1:      * @param x - the parameter value
1:      * @exception SQLException Feature not implemented for now.
1:      */
1:     public final void setDouble(String parameterName, double x)
1:             throws SQLException {
1:         throw Util.notImplemented();
1:     }
1: 
1:     /**
1:      * JDBC 3.0
1:      *
1:      * Retrieves the value of a JDBC DOUBLE parameter as a double in the Java
1:      * programming language.
1:      *
1:      * @param parameterName - the name of the parameter
1:      * @return the parameter value. If the value is SQL NULL, the result is 0.
1:      * @exception SQLException Feature not implemented for now.
1:      */
1:     public final double getDouble(String parameterName) throws SQLException {
1:         throw Util.notImplemented();
1:     }
1: 
1:     /**
1:      * JDBC 3.0
1:      *
1:      * Sets the designated parameter to the given java.math.BigDecimal value.
1:      * The driver converts this to an SQL NUMERIC value when it sends it to the
1:      * database.
1:      *
1:      * @param parameterName - the name of the parameter
1:      * @param x - the parameter value
1:      * @exception SQLException Feature not implemented for now.
1:      */
1:     public final void setBigDecimal(String parameterName, BigDecimal x)
1:             throws SQLException {
1:         throw Util.notImplemented();
1:     }
1: 
1:     /**
1:      * JDBC 3.0
1:      *
1:      * Retrieves the value of a JDBC NUMERIC parameter as a java.math.BigDecimal
1:      * object with as many digits to the right of the decimal point as the value
1:      * contains
1:      *
1:      * @param parameterName - the name of the parameter
1:      * @return the parameter value. If the value is SQL NULL, the result is 0.
1:      * @exception SQLException Feature not implemented for now.
1:      */
1:     public final BigDecimal getBigDecimal(String parameterName)
1:             throws SQLException {
1:         throw Util.notImplemented();
1:     }
1: 
1:     /**
1:      * JDBC 3.0
1:      *
1:      * Sets the designated parameter to the given Java String value. The driver
1:      * converts this to an SQL VARCHAR OR LONGVARCHAR value (depending on the
1:      * argument's size relative the driver's limits on VARCHAR values) when it
1:      * sends it to the database.
1:      *
1:      * @param parameterName - the name of the parameter
1:      * @param x - the parameter value
1:      * @exception SQLException Feature not implemented for now.
1:      */
1:     public final void setString(String parameterName, String x)
1:             throws SQLException {
1:         throw Util.notImplemented();
1:     }
1: 
1:     /**
1:      * JDBC 3.0
1:      *
1:      * Retrieves the value of a JDBC CHAR, VARCHAR, or LONGVARCHAR parameter as
1:      * a String in the Java programming language.
1:      *
1:      * @param parameterName - the name of the parameter
1:      * @return the parameter value. If the value is SQL NULL, the result is
1:      * null.
1:      * @exception SQLException Feature not implemented for now.
1:      */
1:     public final String getString(String parameterName) throws SQLException {
1:         throw Util.notImplemented();
1:     }
1: 
1:     /**
1:      * JDBC 3.0
1:      *
1:      * Sets the designated parameter to the given Java array of bytes. The
1:      * driver converts this to an SQL VARBINARY OR LONGVARBINARY (depending on
1:      * the argument's size relative to the driver's limits on VARBINARY
1:      * values)when it sends it to the database.
1:      *
1:      * @param parameterName - the name of the parameter
1:      * @param x - the parameter value
1:      * @exception SQLException Feature not implemented for now.
1:      */
1:     public final void setBytes(String parameterName, byte[] x)
1:             throws SQLException {
1:         throw Util.notImplemented();
1:     }
1: 
1:     /**
1:      * JDBC 3.0
1:      *
1:      * Retrieves the value of a JDBC BINARY or VARBINARY parameter as an array
1:      * of byte values in the Java programming language.
1:      *
1:      * @param parameterName - the name of the parameter
1:      * @return the parameter value. If the value is SQL NULL, the result is
1:      * null.
1:      * @exception SQLException Feature not implemented for now.
1:      */
1:     public final byte[] getBytes(String parameterName) throws SQLException {
1:         throw Util.notImplemented();
1:     }
1: 
1:     /**
1:      * JDBC 3.0
1:      *
1:      * Sets the designated parameter to the given java.sql.Date value. The
1:      * driver converts this to an SQL DATE value when it sends it to the
1:      * database.
1:      *
1:      * @param parameterName - the name of the parameter
1:      * @param x - the parameter value
1:      * @exception SQLException Feature not implemented for now.
1:      */
1:     public final void setDate(String parameterName, Date x)
1:             throws SQLException {
1:         throw Util.notImplemented();
1:     }
1: 
1:     /**
1:      * JDBC 3.0
1:      *
1:      * Sets the designated parameter to the given java.sql.Date value, using the
1:      * given Calendar object.
1:      *
1:      * @param parameterName - the name of the parameter
1:      * @param x - the parameter value
1:      * @param cal - the Calendar object the driver will use to construct the
1:      * date
1:      * @exception SQLException Feature not implemented for now.
1:      */
1:     public final void setDate(String parameterName, Date x, Calendar cal)
1:             throws SQLException {
1:         throw Util.notImplemented();
1:     }
1: 
1:     /**
1:      * JDBC 3.0
1:      *
1:      * Retrieves the value of a JDBC DATE parameter as a java.sql.Date object
1:      *
1:      * @param parameterName - the name of the parameter
1:      * @return the parameter value. If the value is SQL NULL, the result is
1:      * null.
1:      * @exception SQLException Feature not implemented for now.
1:      */
1:     public final Date getDate(String parameterName) throws SQLException {
1:         throw Util.notImplemented();
1:     }
1: 
1:     /**
1:      * JDBC 3.0
1:      *
1:      * Retrieves the value of a JDBC DATE parameter as a java.sql.Date object,
1:      * using the given Calendar object to construct the date object.
1:      *
1:      * @param parameterName - the name of the parameter
1:      * @param cal - the Calendar object the driver will use to construct the
1:      * date
1:      * @return the parameter value. If the value is SQL NULL, the result is
1:      * null.
1:      * @exception SQLException Feature not implemented for now.
1:      */
1:     public final Date getDate(String parameterName, Calendar cal)
1:             throws SQLException {
1:         throw Util.notImplemented();
1:     }
1: 
1:     /**
1:      * JDBC 3.0
1:      *
1:      * Sets the designated parameter to the given java.sql.Time value. The
1:      * driver converts this to an SQL TIME value when it sends it to the
1:      * database.
1:      *
1:      * @param parameterName - the name of the parameter
1:      * @param x - the parameter value
1:      * @exception SQLException Feature not implemented for now.
1:      */
1:     public final void setTime(String parameterName, Time x)
1:             throws SQLException {
1:         throw Util.notImplemented();
1:     }
1: 
1:     /**
1:      * JDBC 3.0
1:      *
1:      * Retrieves the value of a JDBC TIME parameter as ajava.sql.Time object
1:      *
1:      * @param parameterName - the name of the parameter
1:      * @return the parameter value. If the value is SQL NULL, the result is
1:      * null.
1:      * @exception SQLException Feature not implemented for now.
1:      */
1:     public final Time getTime(String parameterName) throws SQLException {
1:         throw Util.notImplemented();
1:     }
1: 
1:     /**
1:      * JDBC 3.0
1:      *
1:      * Retrieves the value of a JDBC TIME parameter as a java.sql.Time object,
1:      * using the given Calendar object to construct the time object.
1:      *
1:      * @param parameterName - the name of the parameter
1:      * @param cal - the Calendar object the driver will use to construct the
1:      * time
1:      * @return the parameter value. If the value is SQL NULL, the result is
1:      * null.
1:      * @exception SQLException Feature not implemented for now.
1:      */
1:     public final Time getTime(String parameterName, Calendar cal)
1:             throws SQLException {
1:         throw Util.notImplemented();
1:     }
1: 
1:     /**
1:      * JDBC 3.0
1:      *
1:      * Sets the designated parameter to the given java.sql.Time value using the
1:      * Calendar object
1:      *
1:      * @param parameterName - the name of the parameter
1:      * @param x - the parameter value
1:      * @param cal - the Calendar object the driver will use to construct the
1:      * time
1:      * @exception SQLException Feature not implemented for now.
1:      */
1:     public final void setTime(String parameterName, Time x, Calendar cal)
1:             throws SQLException {
1:         throw Util.notImplemented();
1:     }
1: 
1:     /**
1:      * JDBC 3.0
1:      *
1:      * Sets the designated parameter to the given java.sql.Timestamp value. The
1:      * driver converts this to an SQL TIMESTAMP value when it sends it to the
1:      * database.
1:      *
1:      * @param parameterName - the name of the parameter
1:      * @param x - the parameter value
1:      * @exception SQLException Feature not implemented for now.
1:      */
1:     public final void setTimestamp(String parameterName, Timestamp x)
1:             throws SQLException {
1:         throw Util.notImplemented();
1:     }
1: 
1:     /**
1:      * JDBC 3.0
1:      *
1:      * Sets the designated parameter to the given java.sql.Timestamp value,
1:      * using the given Calendar object
1:      *
1:      * @param parameterName - the name of the parameter
1:      * @param x - the parameter value
1:      * @param cal - the Calendar object the driver will use to construct the
1:      * timestamp.
1:      * @exception SQLException Feature not implemented for now.
1:      */
1:     public final void setTimestamp(String parameterName, Timestamp x, Calendar cal)
1:             throws SQLException {
1:         throw Util.notImplemented();
1:     }
1: 
1:     /**
1:      * JDBC 3.0
1:      *
1:      * Retrieves the value of a JDBC TIMESTAMP parameter as a java.sql.Timestamp
1:      * object
1:      *
1:      * @param parameterName - the name of the parameter
1:      * @return the parameter value. If the value is SQL NULL, the result is
1:      * null.
1:      * @exception SQLException Feature not implemented for now.
1:      */
1:     public final Timestamp getTimestamp(String parameterName)
1:             throws SQLException {
1:         throw Util.notImplemented();
1:     }
1: 
1:     /**
1:      * JDBC 3.0
1:      *
1:      * Retrieves the value of a JDBC TIMESTAMP parameter as a java.sql.Timestamp
1:      * object, using the given Calendar object to construct the Timestamp
1:      * object.
1:      *
1:      * @param parameterName - the name of the parameter
1:      * @param cal - the Calendar object the driver will use to construct the
1:      * Timestamp
1:      * @return the parameter value. If the value is SQL NULL, the result is
1:      * null.
1:      * @exception SQLException Feature not implemented for now.
1:      */
1:     public final Timestamp getTimestamp(String parameterName, Calendar cal)
1:             throws SQLException {
1:         throw Util.notImplemented();
1:     }
1: 
1:     /**
1:      * JDBC 3.0
1:      *
1:      * Sets the designated parameter to the given input stream, which will have
1:      * the specified number of bytes.
1:      *
1:      * @param parameterName - the name of the parameter
1:      * @param x - the Java input stream that contains the ASCII parameter value
1:      * @param length - the number of bytes in the stream
1:      * @exception SQLException Feature not implemented for now.
1:      */
1:     public final void setAsciiStream(String parameterName, InputStream x, int length)
1:             throws SQLException {
1:         throw Util.notImplemented();
1:     }
1: 
1:     /**
1:      * JDBC 3.0
1:      *
1:      * Sets the designated parameter to the given input stream, which will have
1:      * the specified number of bytes.
1:      *
1:      * @param parameterName - the name of the parameter
1:      * @param x - the Java input stream that contains the binary parameter value
1:      * @param length - the number of bytes in the stream
1:      * @exception SQLException Feature not implemented for now.
1:      */
1:     public final void setBinaryStream(String parameterName, InputStream x, int length)
1:             throws SQLException {
1:         throw Util.notImplemented();
1:     }
1: 
1:     /**
1:      * JDBC 3.0
1:      *
1:      * Sets the designated parameter to the given Reader object, which is the
1:      * given number of characters long.
1:      *
1:      * @param parameterName - the name of the parameter
1:      * @param reader - the java.io.Reader object that contains the UNICODE data
1:      * @param length - the number of characters in the stream
1:      * @exception SQLException Feature not implemented for now.
1:      */
1:     public final void setCharacterStream(String parameterName, Reader reader, int length)
1:             throws SQLException {
1:         throw Util.notImplemented();
1:     }
1: 
1:     /**
1:      * JDBC 3.0
1:      *
1:      * Sets the value of the designated parameter with the given object. The
1:      * second argument must be an object type; for integral values, the
1:      * java.lang equivalent objects should be used.
1:      *
1:      * @param parameterName - the name of the parameter
1:      * @param x - the object containing the input parameter value
1:      * @param targetSqlType - the SQL type (as defined in java.sql.Types) to be
1:      * sent to the database. The scale argument may further qualify this type.
1:      * @param scale - for java.sql.Types.DECIMAL or java.sql.Types.NUMERIC
1:      * types, this is the number of digits after the decimal point. For all
1:      * other types, this value will be ignored.
1:      * @exception SQLException Feature not implemented for now.
1:      */
1:     public final void setObject(String parameterName, Object x, int targetSqlType, int scale)
1:             throws SQLException {
1:         throw Util.notImplemented();
1:     }
1: 
1:     /**
1:      * JDBC 3.0
1:      *
1:      * Retrieves the value of a parameter as an Object in the java programming
1:      * language.
1:      *
1:      * @param parameterName - the name of the parameter
1:      * @return a java.lang.Object holding the OUT parameter value
1:      * @exception SQLException Feature not implemented for now.
1:      */
1:     public final Object getObject(String parameterName) throws SQLException {
1:         throw Util.notImplemented();
1:     }
1: 
1:     /**
1:      * JDBC 3.0
1:      *
1:      * Returns an object representing the value of OUT parameter i and uses map
1:      * for the custom mapping of the parameter value.
1:      *
1:      * @param parameterName - the name of the parameter
1:      * @param map - the mapping from SQL type names to Java classes
1:      * @return a java.lang.Object holding the OUT parameter value
1:      * @exception SQLException Feature not implemented for now.
1:      */
1:     public final Object getObject(String parameterName, Map<String, Class<?>> map)
1:             throws SQLException {
1:         checkStatus();
1:         if (map == null) {
1:             throw Util.generateCsSQLException(SQLState.INVALID_API_PARAMETER, map, "map",
1:                     "java.sql.CallableStatement.getObject");
1:         }
1:         if (!(map.isEmpty())) {
1:             throw Util.notImplemented();
1:         }
1: 
1:         // Map is empty so call the normal getObject method.
1:         return getObject(parameterName);
1:     }
1: 
1:     /**
1:      * JDBC 3.0
1:      *
1:      * Sets the value of the designated parameter with the given object. This
1:      * method is like the method setObject above, except that it assumes a scale
1:      * of zero.
1:      *
1:      * @param parameterName - the name of the parameter
1:      * @param x - the object containing the input parameter value
1:      * @param targetSqlType - the SQL type (as defined in java.sql.Types) to be
1:      * sent to the database.
1:      * @exception SQLException Feature not implemented for now.
1:      */
1:     public final void setObject(String parameterName, Object x, int targetSqlType)
1:             throws SQLException {
1:         throw Util.notImplemented();
1:     }
1: 
1:     /**
1:      * JDBC 3.0
1:      *
1:      * Sets the value of the designated parameter with the given object. The
1:      * second parameter must be of type Object; therefore, the java.lang
1:      * equivalent objects should be used for built-in types.
1:      *
1:      * @param parameterName - the name of the parameter
1:      * @param x - the object containing the input parameter value
1:      * @exception SQLException Feature not implemented for now.
1:      */
1:     public final void setObject(String parameterName, Object x)
1:             throws SQLException {
1:         throw Util.notImplemented();
1:     }
1: 
1:     // JDBC 4.0 methods
1: 
1:     /**
1:      * Retrieves the value of the designated parameter as a
1:      * <code>java.io.Reader</code> object in the Java programming language.
1:      * Introduced in JDBC 4.0.
1:      *
1:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:      * @return a <code>java.io.Reader</code> object that contains the parameter
1:      * value; if the value is SQL <code>NULL</code>, the value returned
1:      * is <code>null</code> in the Java programming language.
1:      * @throws SQLException if a database access error occurs or this method is
1:      * called on a closed <code>CallableStatement</code>
1:      */
1:     public final Reader getCharacterStream(int parameterIndex)
1:             throws SQLException {
1:         checkStatus();
1:         // Make sure the specified parameter has mode OUT or IN/OUT.
1:         switch (getParms().getParameterMode(parameterIndex)) {
1:             case (ParameterMetaData.parameterModeIn):
1:             case (ParameterMetaData.parameterModeUnknown):
1:                 throw newSQLException(SQLState.LANG_NOT_OUTPUT_PARAMETER,
1:                         Integer.toString(parameterIndex));
1:         }
1:         Reader reader = null;
1:         int paramType = getParameterJDBCType(parameterIndex);
1:         switch (paramType) {
1:             // Handle character/string types.
1:             case Types.CHAR:
1:             case Types.VARCHAR:
1:             case Types.LONGVARCHAR:
1:             case Types.CLOB:
1:                 boolean pushStack = false;
1:                 Object syncObject = getConnectionSynchronization();
1:                 synchronized (syncObject) {
1:                     try {
1:                         StringDataValue param = (StringDataValue) getParms().getParameterForGet(parameterIndex - 1);
1:                         if (param.isNull()) {
1:                             break;
1:                         }
1:                         pushStack = true;
1:                         setupContextStack();
1: 
1:                         if (param.hasStream()) {
1:                             CharacterStreamDescriptor csd =
1:                                     param.getStreamWithDescriptor();
1:                             reader = new UTF8Reader(csd, this, syncObject);
1:                         } else {
1:                             reader = new StringReader(param.getString());
1:                         }
1:                     } catch (Throwable t) {
1:                         throw EmbedResultSet.noStateChangeException(t);
1:                     } finally {
1:                         if (pushStack) {
1:                             restoreContextStack();
1:                         }
1:                     }
1:                 } // End synchronized block
1:                 break;
1: 
1:             // Handle binary types.
1:             // JDBC says to support these, but no defintion exists for the output.
1:             // Match JCC which treats the bytes as a UTF-16BE stream.
1:             case Types.BINARY:
1:             case Types.VARBINARY:
1:             case Types.LONGVARBINARY:
1:             case Types.BLOB:
1:                 try {
1:                     InputStream is = getBinaryStream(parameterIndex);
1:                     if (is != null) {
1:                         reader = new InputStreamReader(is, "UTF-16BE");
1:                     }
1:                     break;
1:                 } catch (UnsupportedEncodingException uee) {
1:                     throw newSQLException(uee.getMessage());
1:                 }
1: 
1:             default:
1:                 throw newSQLException(SQLState.LANG_DATA_TYPE_GET_MISMATCH,
1:                         "java.io.Reader", Util.typeName(paramType));
1:         }
1:         // Update wasNull.
1:         wasNull = (reader == null);
1:         return reader;
1:     }
1: 
1:     /**
1:      * Get binary stream for a parameter.
1:      *
1:      * @param parameterIndex first parameter is 1, second is 2 etc.
1:      * @return a stream for the binary parameter, or <code>null</code>.
1:      *
1:      * @throws SQLException if a database access error occurs.
1:      */
1:     private InputStream getBinaryStream(int parameterIndex)
1:             throws SQLException {
1:         int paramType = getParameterJDBCType(parameterIndex);
1:         switch (paramType) {
1:             case Types.BINARY:
1:             case Types.VARBINARY:
1:             case Types.LONGVARBINARY:
1:             case Types.BLOB:
1:                 break;
1:             default:
1:                 throw newSQLException(SQLState.LANG_DATA_TYPE_GET_MISMATCH,
1:                         "java.io.InputStream", Util.typeName(paramType));
1:         }
1: 
1:         boolean pushStack = false;
1:         synchronized (getConnectionSynchronization()) {
1:             try {
1:                 DataValueDescriptor param =
1:                         getParms().getParameterForGet(parameterIndex - 1);
1:                 wasNull = param.isNull();
1:                 if (wasNull) {
1:                     return null;
1:                 }
1:                 pushStack = true;
1:                 setupContextStack();
1: 
1:                 InputStream stream; // The stream we will return to the user
1:                 if (param.hasStream()) {
1:                     stream = new BinaryToRawStream(param.getStream(), param);
1:                 } else {
1:                     stream = new ByteArrayInputStream(param.getBytes());
1:                 }
1:                 return stream;
1:             } catch (Throwable t) {
1:                 throw EmbedResultSet.noStateChangeException(t);
1:             } finally {
1:                 if (pushStack) {
1:                     restoreContextStack();
1:                 }
1:             }
1:         } // End synchronized block
1:     }
1: 
1:     public final Reader getCharacterStream(String parameterName)
1:             throws SQLException {
1:         throw Util.notImplemented();
1:     }
1: 
1:     public final Reader getNCharacterStream(int parameterIndex)
1:             throws SQLException {
1:         throw Util.notImplemented();
1:     }
1: 
1:     public final Reader getNCharacterStream(String parameterName)
1:             throws SQLException {
1:         throw Util.notImplemented();
1:     }
1: 
1:     public final String getNString(int parameterIndex)
1:             throws SQLException {
1:         throw Util.notImplemented();
1:     }
1: 
1:     public final String getNString(String parameterName)
1:             throws SQLException {
1:         throw Util.notImplemented();
1:     }
1: 
1:     public final void setBlob(String parameterName, Blob x)
1:             throws SQLException {
1:         throw Util.notImplemented();
1:     }
1: 
1:     public final void setClob(String parameterName, Clob x)
1:             throws SQLException {
1:         throw Util.notImplemented();
1:     }
1: 
1:     public final RowId getRowId(int parameterIndex) throws SQLException {
1:         throw Util.notImplemented();
1:     }
1: 
1:     public final RowId getRowId(String parameterName) throws SQLException {
1:         throw Util.notImplemented();
1:     }
1: 
1:     public final void setRowId(String parameterName, RowId x) throws SQLException {
1:         throw Util.notImplemented();
1:     }
1: 
1:     public final void setNString(String parameterName, String value)
1:             throws SQLException {
1:         throw Util.notImplemented();
1:     }
1: 
1:     public final void setNCharacterStream(String parameterName, Reader value, long length)
1:             throws SQLException {
1:         throw Util.notImplemented();
1:     }
1: 
1:     public final void setNClob(String parameterName, NClob value) throws SQLException {
1:         throw Util.notImplemented();
1:     }
1: 
1:     public final void setClob(String parameterName, Reader reader, long length)
1:             throws SQLException {
1:         throw Util.notImplemented();
1: 
1:     }
1: 
1:     public final void setBlob(String parameterName, InputStream inputStream, long length)
1:             throws SQLException {
1:         throw Util.notImplemented();
1:     }
1: 
1:     public final void setNClob(String parameterName, Reader reader, long length)
1:             throws SQLException {
1:         throw Util.notImplemented();
1:     }
1: 
1:     public final NClob getNClob(int i) throws SQLException {
1:         throw Util.notImplemented();
1:     }
1: 
1:     public final NClob getNClob(String parameterName) throws SQLException {
1:         throw Util.notImplemented();
1:     }
1: 
1:     public final void setSQLXML(String parameterName, SQLXML xmlObject) throws SQLException {
1:         throw Util.notImplemented();
1: 
1:     }
1: 
1:     public final SQLXML getSQLXML(int parameterIndex) throws SQLException {
1:         throw Util.notImplemented();
1:     }
1: 
1:     public final SQLXML getSQLXML(String parametername) throws SQLException {
1:         throw Util.notImplemented();
1:     }
1: 
1:     public final void setAsciiStream(String parameterName, InputStream x)
1:             throws SQLException {
1:         throw Util.notImplemented("setAsciiStream(String,InputStream)");
1:     }
1: 
1:     public final void setBinaryStream(String parameterName, InputStream x)
1:             throws SQLException {
1:         throw Util.notImplemented("setBinaryStream(String,InputStream)");
1:     }
1: 
1:     public final void setBlob(String parameterName, InputStream inputStream)
1:             throws SQLException {
1:         throw Util.notImplemented("setBlob(String,InputStream)");
1:     }
1: 
1:     public final void setCharacterStream(String parameterName, Reader reader)
1:             throws SQLException {
1:         throw Util.notImplemented("setCharacterStream(String,Reader)");
1:     }
1: 
1:     public final void setClob(String parameterName, Reader reader)
1:             throws SQLException {
1:         throw Util.notImplemented("setClob(String,Reader)");
1:     }
1: 
1:     public final void setNCharacterStream(String parameterName, Reader value)
1:             throws SQLException {
1:         throw Util.notImplemented("setNCharacterStream(String,Reader)");
1:     }
1: 
1:     public final void setNClob(String parameterName, Reader reader)
1:             throws SQLException {
1:         throw Util.notImplemented("setNClob(String,Reader)");
1:     }
1: 
1:     /**
1:      * Sets the designated parameter to the given input stream, which will have
1:      * the specified number of bytes.
1:      *
1:      * @param parameterName the name of the first parameter
1:      * @param x the java input stream which contains the ASCII parameter value
1:      * @param length the number of bytes in the stream
1:      * @exception SQLException thrown on failure.
1:      *
1:      */
1:     public final void setAsciiStream(String parameterName, InputStream x, long length)
1:             throws SQLException {
1:         throw Util.notImplemented();
1:     }
1: 
1:     /**
1:      * Sets the designated parameter to the given input stream, which will have
1:      * the specified number of bytes.
1:      *
1:      * @param parameterName the name of the first parameter
1:      * @param x the java input stream which contains the binary parameter value
1:      * @param length the number of bytes in the stream
1:      * @exception SQLException thrown on failure.
1:      *
1:      */
1:     public final void setBinaryStream(String parameterName, InputStream x, long length)
1:             throws SQLException {
1:         throw Util.notImplemented();
1:     }
1: 
1:     /**
1:      * Sets the designated parameter to the given Reader, which will have the
1:      * specified number of bytes.
1:      *
1:      * @param parameterName the name of the first parameter
1:      * @param x the java Reader which contains the UNICODE value
1:      * @param length the number of bytes in the stream
1:      * @exception SQLException thrown on failure.
1:      *
1:      */
1:     public final void setCharacterStream(String parameterName, Reader x, long length)
1:             throws SQLException {
1:         throw Util.notImplemented();
1:     }
1: 
1:     ////////////////////////////////////////////////////////////////////
1:     //
1:     // INTRODUCED BY JDBC 4.1 IN JAVA 7
1:     //
1:     ////////////////////////////////////////////////////////////////////
1:     public final <T> T getObject(int parameterIndex, Class<T> type)
1:             throws SQLException {
1:         checkStatus();
1: 
1:         if (type == null) {
1:             throw mismatchException("NULL", parameterIndex);
1:         }
1: 
1:         Object retval;
1: 
1:         if (String.class.equals(type)) {
1:             retval = getString(parameterIndex);
1:         } else if (BigDecimal.class.equals(type)) {
1:             retval = getBigDecimal(parameterIndex);
1:         } else if (Boolean.class.equals(type)) {
1:             retval = getBoolean(parameterIndex);
1:         } else if (Byte.class.equals(type)) {
1:             retval = getByte(parameterIndex);
1:         } else if (Short.class.equals(type)) {
1:             retval = getShort(parameterIndex);
1:         } else if (Integer.class.equals(type)) {
1:             retval = getInt(parameterIndex);
1:         } else if (Long.class.equals(type)) {
1:             retval = getLong(parameterIndex);
1:         } else if (Float.class.equals(type)) {
1:             retval = getFloat(parameterIndex);
1:         } else if (Double.class.equals(type)) {
1:             retval = getDouble(parameterIndex);
1:         } else if (Date.class.equals(type)) {
1:             retval = getDate(parameterIndex);
1:         } else if (Time.class.equals(type)) {
1:             retval = getTime(parameterIndex);
1:         } else if (Timestamp.class.equals(type)) {
1:             retval = getTimestamp(parameterIndex);
1:         } else if (Blob.class.equals(type)) {
1:             retval = getBlob(parameterIndex);
1:         } else if (Clob.class.equals(type)) {
1:             retval = getClob(parameterIndex);
1:         } else if (type.isArray() && type.getComponentType().equals(byte.class)) {
1:             retval = getBytes(parameterIndex);
1:         } else {
1:             retval = getObject(parameterIndex);
1:         }
1: 
1:         if (wasNull()) {
1:             retval = null;
1:         }
1: 
1:         if ((retval == null) || (type.isInstance(retval))) {
1:             return type.cast(retval);
1:         }
1: 
1:         throw mismatchException(type.getName(), parameterIndex);
1:     }
1: 
1:     private SQLException mismatchException(String targetTypeName, int parameterIndex)
1:             throws SQLException {
1:         String sourceTypeName = getParameterMetaData().getParameterTypeName(parameterIndex);
1:         return newSQLException(SQLState.LANG_DATA_TYPE_GET_MISMATCH, targetTypeName, sourceTypeName);
1:     }
1: 
1:     public final <T> T getObject(String parameterName, Class<T> type)
1:             throws SQLException {
1:         throw Util.notImplemented();
1:     }
1: 
commit:e33b8d8
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import java.sql.ParameterMetaData;
/////////////////////////////////////////////////////////////////////////
1:             case (ParameterMetaData.parameterModeIn):
1:             case (ParameterMetaData.parameterModeUnknown):
1:             case (ParameterMetaData.parameterModeOut):
1:             case (ParameterMetaData.parameterModeInOut):
commit:f17b81f
/////////////////////////////////////////////////////////////////////////
0: public class EmbedCallableStatement extends EmbedPreparedStatement
commit:0252fa4
/////////////////////////////////////////////////////////////////////////
1:         Object o = getObject(parameterIndex);
1:         if (o == null || o instanceof Blob) {
1:             return (Blob) o;
1:         }
1:         throw newSQLException(SQLState.LANG_DATA_TYPE_GET_MISMATCH,
1:                 Blob.class.getName(),
1:                 Util.typeName(getParameterJDBCType(parameterIndex)));
/////////////////////////////////////////////////////////////////////////
1:         Object o = getObject(parameterIndex);
1:         if (o == null || o instanceof Clob) {
1:             return (Clob) o;
1:         }
1:         throw newSQLException(SQLState.LANG_DATA_TYPE_GET_MISMATCH,
1:                 Clob.class.getName(),
1:                 Util.typeName(getParameterJDBCType(parameterIndex)));
commit:866573f
/////////////////////////////////////////////////////////////////////////
1:     public Date getDate(int parameterIndex, Calendar cal) throws SQLException
1:             Date v = getParms().
1:                     getParameterForGet(parameterIndex-1).getDate(cal);
/////////////////////////////////////////////////////////////////////////
1:     public Time getTime(int parameterIndex, Calendar cal) throws SQLException
1:             Time v = getParms().
1:                     getParameterForGet(parameterIndex-1).getTime(cal);
/////////////////////////////////////////////////////////////////////////
1:     public Timestamp getTimestamp(int parameterIndex, Calendar cal)
1:             Timestamp v = getParms().
1:                     getParameterForGet(parameterIndex-1).getTimestamp(cal);
/////////////////////////////////////////////////////////////////////////
1:     public java.sql.Date getDate(int parameterIndex)
1:         return getDate(parameterIndex, getCal());
/////////////////////////////////////////////////////////////////////////
1:     public java.sql.Time getTime(int parameterIndex)
1:         return getTime(parameterIndex, getCal());
/////////////////////////////////////////////////////////////////////////
1:     public java.sql.Timestamp getTimestamp(int parameterIndex)
1:         return getTimestamp(parameterIndex, getCal());
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Dyre Tjeldvoll
-------------------------------------------------------------------------------
commit:4c8f570
/////////////////////////////////////////////////////////////////////////
1: 					results.close();
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:a0118e1
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Statement;
/////////////////////////////////////////////////////////////////////////
1: 			  Statement.NO_GENERATED_KEYS,
commit:698e318
/////////////////////////////////////////////////////////////////////////
1: 					DataValueDescriptor returnValue = pvs.getReturnValueForSet();
1: 					returnValue.setValueFromResultSet(results, 1, true);
commit:45075cc
/////////////////////////////////////////////////////////////////////////
1: 	public final Object getObject(int parameterIndex) throws SQLException 
1: 			Object v = getParms().getParameterForGet(parameterIndex-1).getObject();
commit:3ff53d4
/////////////////////////////////////////////////////////////////////////
1: import java.net.URL;
1: import java.sql.Blob;
1: import java.sql.Clob;
1: import java.util.Calendar;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Get the value of a SQL DATE parameter as a java.sql.Date object
1:      *
1:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:      * @return the parameter value; if the value is SQL NULL, the result is 
1:      * null
1:      * @exception SQLException if a database-access error occurs.
1:      */
0:     public java.sql.Date getDate(int parameterIndex, Calendar cal) 
1:       throws SQLException 
1: 	{
0: 		return getDate(parameterIndex);
1: 	}
1: 
1:     /**
1:      * Get the value of a SQL TIME parameter as a java.sql.Time object.
1:      *
1:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:      * @return the parameter value; if the value is SQL NULL, the result is 
1: 	 * null
1:      * @exception SQLException if a database-access error occurs.
1:      */
0:     public java.sql.Time getTime(int parameterIndex, Calendar cal) 
1:       throws SQLException 
1: 	{
0: 		return getTime(parameterIndex);
1: 	}
1: 
1:     /**
1:      * Get the value of a SQL TIMESTAMP parameter as a java.sql.Timestamp 
1:      * object.
1:      *
1:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:      * @return the parameter value; if the value is SQL NULL, the result is 
1:      * null
1:      * @exception SQLException if a database-access error occurs.
1:      */
0:     public java.sql.Timestamp getTimestamp(int parameterIndex, Calendar cal) 
1:       throws SQLException 
1: 	{
0: 		return getTimestamp(parameterIndex);
1: 	}
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	    * JDBC 3.0
1: 	    *
1: 	    * Retrieve the value of the designated JDBC DATALINK parameter as a java.net.URL object
1: 	    *
1: 	    * @param parameterIndex - the first parameter is 1, the second is 2
1: 	    * @return a java.net.URL object that represents the JDBC DATALINK value used as
1: 	    * the designated parameter
1: 	    * @exception SQLException Feature not implemented for now.
1: 		*/
1: 		public URL getURL(int parameterIndex)
1: 	    throws SQLException
1: 		{
1: 			throw Util.notImplemented();
1: 		}
1: 		/**
1: 	    * JDBC 3.0
1: 	    *
1: 	    * Sets the designated parameter to the given java.net.URL object. The driver
1: 	    * converts this to an SQL DATALINK value when it sends it to the database.
1: 	    *
1: 	    * @param parameterName - the name of the parameter
1: 	    * @param val - the parameter value
1: 	    * @exception SQLException Feature not implemented for now.
1: 		*/
1: 		public void setURL(String parameterName, URL val)
1: 	    throws SQLException
1: 		{
1: 			throw Util.notImplemented();
1: 		}
1: 
1: 		/**
1: 	    * JDBC 3.0
1: 	    *
1: 	    * Retrieves the value of a JDBC DATALINK parameter as a java.net.URL object
1: 	    *
1: 	    * @param parameterName - the name of the parameter
1: 	    * @return the parameter value. If the value is SQL NULL, the result is null.
1: 	    * @exception SQLException Feature not implemented for now.
1: 		*/
1: 		public URL getURL(String parameterName)
1: 	    throws SQLException
1: 		{
1: 			throw Util.notImplemented();
1: 		}
1: 
1: 		/**
1: 	     * JDBC 2.0
1: 	     *
0: 	     * Get a BLOB OUT parameter.
1: 	     *
0: 	     * @param i the first parameter is 1, the second is 2, ...
0: 	     * @return an object representing a BLOB
1: 	     * @exception SQLException if a database-access error occurs.
1: 	     */
0: 	    public Blob getBlob (int i) throws SQLException {
1: 			throw Util.notImplemented();
1: 		}
1: 
1: 	    /**
1: 	     * JDBC 2.0
1: 	     *
0: 	     * Get a CLOB OUT parameter.
1: 	     *
0: 	     * @param i the first parameter is 1, the second is 2, ...
0: 	     * @return an object representing a CLOB
1: 	     * @exception SQLException if a database-access error occurs.
1: 	     */
0: 	    public Clob getClob (int i) throws SQLException {
1: 			throw Util.notImplemented();
1: 		}
commit:75fbaa9
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.jdbc.EmbedCallableStatement
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:1f9b9c4
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.jdbc
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.jdbc;
1: 
1: import org.apache.derby.iapi.sql.ParameterValueSet;
1: import org.apache.derby.iapi.sql.Activation;
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.types.DataValueDescriptor;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
0: import org.apache.derby.iapi.reference.JDBC30Translation;
1: import org.apache.derby.iapi.reference.SQLState;
1: 
0: import java.math.BigDecimal;
1: import java.sql.CallableStatement;
1: import java.sql.SQLException;
1: import java.sql.Date;
1: import java.sql.Time;
1: import java.sql.Timestamp;
1: 
1: /**
1:  * Local implementation.
0:  *
0:  * @author ames
1:  */
0: public abstract class EmbedCallableStatement extends EmbedPreparedStatement
0: 	implements CallableStatement
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 	/*
1: 	** True if we are of the form ? = CALL() -- i.e. true
1: 	** if we have a return output parameter.
1: 	*/
1: 	private boolean hasReturnOutputParameter;
1: 
1: 	protected boolean	wasNull;
1: 
1: 	/**
1: 	 * @exception SQLException thrown on failure
1: 	 */
1: 	public EmbedCallableStatement (EmbedConnection conn, String sql,
1: 								   int resultSetType,
1: 								   int resultSetConcurrency,
1: 								   int resultSetHoldability)
1: 		throws SQLException
1: 	{
1: 	    super(conn, sql, false, 
1: 			  resultSetType,
1: 			  resultSetConcurrency,
1: 			  resultSetHoldability,
0: 			  JDBC30Translation.NO_GENERATED_KEYS,
1: 			  null,
1: 			  null);
1: 
1: 		// mark our parameters as for a callable statement 
1: 		ParameterValueSet pvs = getParms();
1: 
1: 		// do we have a return parameter?
1: 		hasReturnOutputParameter = pvs.hasReturnOutputParameter();
1: 	}
1: 
1: 	protected void checkRequiresCallableStatement(Activation activation) {
1: 	}
1: 
1: 	protected final boolean executeStatement(Activation a,
1:                      boolean executeQuery, boolean executeUpdate)
1: 		throws SQLException
1: 	{
1: 		// need this additional check (it's also in the super.executeStatement
1: 		// to ensure we have an activation for the getParams
1: 		checkExecStatus();
1: 		synchronized (getConnectionSynchronization())
1: 		{
1: 			wasNull = false;
1: 			ParameterValueSet pvs = getParms();
1: 			try
1: 			{
0: 				pvs.validate();
1: 
1: 			} catch (StandardException e)
1: 			{
1: 				throw EmbedResultSet.noStateChangeException(e);
1: 			}
1: 
1: 			/* KLUDGE - ? = CALL ... returns a ResultSet().  We
1: 			 * need executeUpdate to be false in that case.
1: 			 */
1: 			boolean execResult = super.executeStatement(a, executeQuery,
1: 				(executeUpdate && (! hasReturnOutputParameter)));
1: 
1: 			/*
1: 			** If we have a return parameter, then we
1: 			** consume it from the returned ResultSet
1: 			** reset the ResultSet set to null.
1: 			*/
1: 			if (hasReturnOutputParameter)
1: 			{
1: 				if (SanityManager.DEBUG)
1: 				{
1: 					SanityManager.ASSERT(results!=null, "null results even though we are supposed to have a return parameter");
1: 				}
1: 				boolean gotRow = results.next();
1: 				if (SanityManager.DEBUG)
1: 				{
1: 					SanityManager.ASSERT(gotRow, "the return resultSet didn't have any rows");
1: 				}
1: 
1: 				try
1: 				{
0: 					pvs.setReturnValue(results.getObject(1));
1: 
1: 				} catch (StandardException e)
1: 				{
1: 					throw EmbedResultSet.noStateChangeException(e);
1: 				}
1: 				finally {
1: 					results = null;
1: 				}
1: 
1: 				// This is a form of ? = CALL which current is not a procedure call.
1: 				// Thus there cannot be any user result sets, so return false. execResult
1: 				// is set to true since a result set was returned, for the return parameter.
1: 				execResult = false;
1: 			}
1: 			return execResult;
1: 		}
1: 	}
1: 
1: 	/*
1: 	* CallableStatement interface
1: 	* (the PreparedStatement part implemented by EmbedPreparedStatement)
1: 	*/
1: 
1: 	/**
1: 	 * @see CallableStatement#registerOutParameter
1: 	 * @exception SQLException NoOutputParameters thrown.
1: 	 */
1: 	public final void registerOutParameter(int parameterIndex, int sqlType)
1: 		throws SQLException 
1: 	{
1: 		checkStatus();
1: 
1: 		try {
1: 			getParms().registerOutParameter(parameterIndex-1, sqlType, -1);
1: 		} catch (StandardException e)
1: 		{
1: 			throw EmbedResultSet.noStateChangeException(e);
1: 		}
1: 	}
1: 
1:     /**
1: 	 * @see CallableStatement#registerOutParameter
1:      * @exception SQLException NoOutputParameters thrown.
1:      */
1:     public final void registerOutParameter(int parameterIndex, int sqlType, int scale)
1: 	    throws SQLException 
1: 	{
1: 		checkStatus();
1: 
1: 		if (scale < 0)
0: 			throw newSQLException(SQLState.BAD_SCALE_VALUE, new Integer(scale));
1: 		try {
1: 			getParms().registerOutParameter(parameterIndex-1, sqlType, scale);
1: 		} catch (StandardException e)
1: 		{
1: 			throw EmbedResultSet.noStateChangeException(e);
1: 		}
1: 
1: 	}
1: 
1: 
1: 	/**
0: 	 * JDBC 2.0
0: 	 *
0: 	 * Registers the designated output parameter
0: 	 *
0: 	 * @exception SQLException if a database-access error occurs.
1: 	 */
1:  	public void registerOutParameter(int parameterIndex, int sqlType, 
1:  									 String typeName) 
1:  		 throws SQLException
1:  	{
0:  		throw Util.notImplemented("registerOutParameter");
1:  	}
1:  		 
1:  
1: 
1:     /**
1: 	 * @see CallableStatement#wasNull
1:      * @exception SQLException NoOutputParameters thrown.
1:      */
1:     public boolean wasNull() throws SQLException 
1: 	{
1: 		checkStatus();
1: 		return wasNull;
1: 	}
1: 
1:     /**
1: 	 * @see CallableStatement#getString
1:      * @exception SQLException NoOutputParameters thrown.
1:      */
1:     public String getString(int parameterIndex) throws SQLException 
1: 	{
1: 		checkStatus();
1: 		try {
1: 			String v =  getParms().getParameterForGet(parameterIndex-1).getString();
1: 			wasNull = (v == null);
1: 			return v;
1: 
1: 		} catch (StandardException e)
1: 		{
1: 			throw EmbedResultSet.noStateChangeException(e);
1: 		}
1: 	}
1: 
1:     /**
1: 	 * @see CallableStatement#getBoolean
1:      * @exception SQLException NoOutputParameters thrown.
1:      */
1:     public boolean getBoolean(int parameterIndex) throws SQLException 
1: 	{
1: 		checkStatus();
1: 		try {
1: 			DataValueDescriptor param = getParms().getParameterForGet(parameterIndex-1);
1: 			boolean v = param.getBoolean();
1: 			wasNull = (!v) && param.isNull();
1: 			return v;
1: 		} catch (StandardException e)
1: 		{
1: 			throw EmbedResultSet.noStateChangeException(e);
1: 		}
1: 
1: 	}
1: 
1:     /**
1: 	 * @see CallableStatement#getByte
1:      * @exception SQLException NoOutputParameters thrown.
1:      */
1:     public byte getByte(int parameterIndex) throws SQLException 
1: 	{
1: 		checkStatus();
1: 		try {
1: 			DataValueDescriptor param = getParms().getParameterForGet(parameterIndex-1);
1: 			byte b = param.getByte();
1: 			wasNull = (b == 0) && param.isNull();
1: 			return b;
1: 		} catch (StandardException e)
1: 		{
1: 			throw EmbedResultSet.noStateChangeException(e);
1: 		}
1: 
1: 	}
1: 
1:     /**
1: 	 * @see CallableStatement#getShort
1:      * @exception SQLException NoOutputParameters thrown.
1:      */
1:     public short getShort(int parameterIndex) throws SQLException 
1: 	{
1: 		checkStatus();
1: 		try {
1: 			DataValueDescriptor param = getParms().getParameterForGet(parameterIndex-1);
1: 			short s = param.getShort();
1: 			wasNull = (s == 0) && param.isNull();
1: 			return s;
1: 		} catch (StandardException e)
1: 		{
1: 			throw EmbedResultSet.noStateChangeException(e);
1: 		}
1: 
1: 	}
1: 
1:     /**
1: 	 * @see CallableStatement#getInt
1:      * @exception SQLException NoOutputParameters thrown.
1:      */
1:     public int getInt(int parameterIndex) throws SQLException 
1: 	{
1: 		checkStatus();
1: 
1: 		try {
1: 			DataValueDescriptor param = getParms().getParameterForGet(parameterIndex-1);
1: 			int v = param.getInt();
1: 			wasNull = (v == 0) && param.isNull();
1: 			return v;
1: 
1: 		} catch (StandardException e)
1: 		{
1: 			throw EmbedResultSet.noStateChangeException(e);
1: 		}
1: 	}
1: 
1:     /**
1: 	 * @see CallableStatement#getLong
1:      * @exception SQLException NoOutputParameters thrown.
1:      */
1:     public long getLong(int parameterIndex) throws SQLException 
1: 	{
1: 		checkStatus();
1: 		try {
1: 			DataValueDescriptor param = getParms().getParameterForGet(parameterIndex-1);
1: 			long v = param.getLong();
1: 			wasNull = (v == 0L) && param.isNull();
1: 			return v;
1: 		} catch (StandardException e)
1: 		{
1: 			throw EmbedResultSet.noStateChangeException(e);
1: 		}
1: 
1: 	}
1: 
1:     /**
1: 	 * @see CallableStatement#getFloat
1:      * @exception SQLException NoOutputParameters thrown.
1:      */
1:     public float getFloat(int parameterIndex) throws SQLException 
1: 	{
1: 		checkStatus();
1: 		try {
1: 			DataValueDescriptor param = getParms().getParameterForGet(parameterIndex-1);
1: 			float v = param.getFloat();
1: 			wasNull = (v == 0.0) && param.isNull();
1: 			return v;
1: 		} catch (StandardException e)
1: 		{
1: 			throw EmbedResultSet.noStateChangeException(e);
1: 		}
1: 	}
1: 
1:     /**
1: 	 * @see CallableStatement#getDouble
1:      * @exception SQLException NoOutputParameters thrown.
1:      */
1:     public double getDouble(int parameterIndex) throws SQLException 
1: 	{
1: 		checkStatus();
1: 		try {
1: 			DataValueDescriptor param = getParms().getParameterForGet(parameterIndex-1);
1: 			double v = param.getDouble();
1: 			wasNull = (v == 0.0) && param.isNull();
1: 			return v;
1: 		} catch (StandardException e)
1: 		{
1: 			throw EmbedResultSet.noStateChangeException(e);
1: 		}
1: 
1: 	}
1: 
1:     /**
0: 	 * @see CallableStatement#getBigDecimal
1:      * @exception SQLException NoOutputParameters thrown.
1:      */
0:     public BigDecimal getBigDecimal(int parameterIndex, int scale) throws SQLException
1: 	{
1: 		checkStatus();
1: 		try {
0: 			BigDecimal v =  getParms().getParameterForGet(parameterIndex-1).getBigDecimal();
1: 			wasNull = (v == null);
1: 			return v;
1: 		} catch (StandardException e)
1: 		{
1: 			throw EmbedResultSet.noStateChangeException(e);
1: 		}
1: 
1: 	}
1: 
1:     /**
1: 	 * @see CallableStatement#getBytes
1:      * @exception SQLException NoOutputParameters thrown.
1:      */
1:     public byte[] getBytes(int parameterIndex) throws SQLException 
1: 	{
1: 		checkStatus();
1: 		try {
1: 			byte[] v =  getParms().getParameterForGet(parameterIndex-1).getBytes();
1: 			wasNull = (v == null);
1: 			return v;
1: 		} catch (StandardException e)
1: 		{
1: 			throw EmbedResultSet.noStateChangeException(e);
1: 		}
1: 
1: 	}
1: 
1:     /**
1: 	 * @see CallableStatement#getDate
1:      * @exception SQLException NoOutputParameters thrown.
1:      */
0:     public Date getDate(int parameterIndex) throws SQLException
1: 	{
1: 		checkStatus();
1: 		try {
0: 			Date v =  getParms().getParameterForGet(parameterIndex-1).getDate(getCal());
1: 			wasNull = (v == null);
1: 			return v;
1: 		} catch (StandardException e)
1: 		{
1: 			throw EmbedResultSet.noStateChangeException(e);
1: 		}
1: 
1: 	}
1: 
1:     /**
1: 	 * @see CallableStatement#getTime
1:      * @exception SQLException NoOutputParameters thrown.
1:      */
0: 	public Time getTime(int parameterIndex) throws SQLException 
1: 	{
1: 		checkStatus();
1: 		try {
0: 			Time v =  getParms().getParameterForGet(parameterIndex-1).getTime(getCal());
1: 			wasNull = (v == null);
1: 			return v;
1: 		} catch (StandardException e)
1: 		{
1: 			throw EmbedResultSet.noStateChangeException(e);
1: 		}
1: 
1: 	}
1: 
1:     /**
1: 	 * @see CallableStatement#getTimestamp
1:      * @exception SQLException NoOutputParameters thrown.
1:      */
0:     public Timestamp getTimestamp(int parameterIndex)
1: 	    throws SQLException 
1: 	{
1: 		checkStatus();
1: 		try {
0: 			Timestamp v =  getParms().getParameterForGet(parameterIndex-1).getTimestamp(getCal());
1: 			wasNull = (v == null);
1: 			return v;
1: 		} catch (StandardException e)
1: 		{
1: 			throw EmbedResultSet.noStateChangeException(e);
1: 		}
1: 	}
1: 
1:     /**
1: 	 * @see CallableStatement#getObject
1:      * @exception SQLException NoOutputParameters thrown.
1:      */
0: 	public Object getObject(int parameterIndex) throws SQLException 
1: 	{
1: 		checkStatus();
1: 		try {
0: 			Object v = getParms().getObject(parameterIndex-1);
1: 			wasNull = (v == null);
1: 			return v;
1: 
1: 		} catch (StandardException e)
1: 		{
1: 			throw EmbedResultSet.noStateChangeException(e);
1: 		}
1: 	}
1: 
1: 	public void addBatch() throws SQLException {
1: 
1: 		checkStatus();
1: 		ParameterValueSet pvs = getParms();
1: 
1: 		int numberOfParameters = pvs.getParameterCount();
1: 
1: 		for (int j=1; j<=numberOfParameters; j++) {
1: 
1: 			switch (pvs.getParameterMode(j)) {
0: 			case JDBC30Translation.PARAMETER_MODE_IN:
0: 			case JDBC30Translation.PARAMETER_MODE_UNKNOWN:
1: 				break;
0: 			case JDBC30Translation.PARAMETER_MODE_OUT:
0: 			case JDBC30Translation.PARAMETER_MODE_IN_OUT:
1: 				throw newSQLException(SQLState.OUTPUT_PARAMS_NOT_ALLOWED);
1: 			}
1: 		}
1: 
1: 		super.addBatch();
1: 	}
1: }
1: 
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:616634f
/////////////////////////////////////////////////////////////////////////
1: 			//Don't fetch the getParms into a local varibale
1: 			//at this point because it is possible that the activation
1: 			//associated with this callable statement may have become
1: 			//stale. If the current activation is invalid, a new activation 
1: 			//will be created for it in executeStatement call below. 
1: 			//We should be using the ParameterValueSet associated with
1: 			//the activation associated to the CallableStatement after
1: 			//the executeStatement below. That ParameterValueSet is the
1: 			//right object to hold the return value from the CallableStatement.
1: 				getParms().validate();
/////////////////////////////////////////////////////////////////////////
1: 			//Fetch the getParms into a local variable now because the
1: 			//activation associated with a CallableStatement at this 
1: 			//point(after the executStatement) is the current activation. 
1: 			//We can now safely stuff the return value of the 
1: 			//CallableStatement into the following ParameterValueSet object.
0: 			ParameterValueSet pvs = getParms();
0: 
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.jdbc
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.jdbc;
0: 
0: import org.apache.derby.iapi.sql.ParameterValueSet;
0: import org.apache.derby.iapi.sql.Activation;
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.reference.JDBC30Translation;
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import java.math.BigDecimal;
0: import java.sql.CallableStatement;
0: import java.sql.SQLException;
0: import java.sql.Date;
0: import java.sql.Time;
0: import java.sql.Timestamp;
0: 
0: /**
0:  * Local implementation.
0:  *
0:  * @author ames
0:  */
0: public abstract class EmbedCallableStatement extends EmbedPreparedStatement
0: 	implements CallableStatement
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	/*
0: 	** True if we are of the form ? = CALL() -- i.e. true
0: 	** if we have a return output parameter.
0: 	*/
0: 	private boolean hasReturnOutputParameter;
0: 
0: 	protected boolean	wasNull;
0: 
0: 	/**
0: 	 * @exception SQLException thrown on failure
0: 	 */
0: 	public EmbedCallableStatement (EmbedConnection conn, String sql,
0: 								   int resultSetType,
0: 								   int resultSetConcurrency,
0: 								   int resultSetHoldability)
0: 		throws SQLException
0: 	{
0: 	    super(conn, sql, false, 
0: 			  resultSetType,
0: 			  resultSetConcurrency,
0: 			  resultSetHoldability,
0: 			  JDBC30Translation.NO_GENERATED_KEYS,
0: 			  null,
0: 			  null);
0: 
0: 		// mark our parameters as for a callable statement 
0: 		ParameterValueSet pvs = getParms();
0: 
0: 		// do we have a return parameter?
0: 		hasReturnOutputParameter = pvs.hasReturnOutputParameter();
0: 	}
0: 
0: 	protected void checkRequiresCallableStatement(Activation activation) {
0: 	}
0: 
0: 	protected final boolean executeStatement(Activation a,
0:                      boolean executeQuery, boolean executeUpdate)
0: 		throws SQLException
0: 	{
0: 		// need this additional check (it's also in the super.executeStatement
0: 		// to ensure we have an activation for the getParams
0: 		checkExecStatus();
0: 		synchronized (getConnectionSynchronization())
0: 		{
0: 			wasNull = false;
0: 			ParameterValueSet pvs = getParms();
0: 			try
0: 			{
0: 				pvs.validate();
0: 
0: 			} catch (StandardException e)
0: 			{
0: 				throw EmbedResultSet.noStateChangeException(e);
0: 			}
0: 
0: 			/* KLUDGE - ? = CALL ... returns a ResultSet().  We
0: 			 * need executeUpdate to be false in that case.
0: 			 */
0: 			boolean execResult = super.executeStatement(a, executeQuery,
0: 				(executeUpdate && (! hasReturnOutputParameter)));
0: 
0: 			/*
0: 			** If we have a return parameter, then we
0: 			** consume it from the returned ResultSet
0: 			** reset the ResultSet set to null.
0: 			*/
0: 			if (hasReturnOutputParameter)
0: 			{
0: 				if (SanityManager.DEBUG)
0: 				{
0: 					SanityManager.ASSERT(results!=null, "null results even though we are supposed to have a return parameter");
0: 				}
0: 				boolean gotRow = results.next();
0: 				if (SanityManager.DEBUG)
0: 				{
0: 					SanityManager.ASSERT(gotRow, "the return resultSet didn't have any rows");
0: 				}
0: 
0: 				try
0: 				{
0: 					pvs.setReturnValue(results.getObject(1));
0: 
0: 				} catch (StandardException e)
0: 				{
0: 					throw EmbedResultSet.noStateChangeException(e);
0: 				}
0: 				finally {
0: 					results = null;
0: 				}
0: 
0: 				// This is a form of ? = CALL which current is not a procedure call.
0: 				// Thus there cannot be any user result sets, so return false. execResult
0: 				// is set to true since a result set was returned, for the return parameter.
0: 				execResult = false;
0: 			}
0: 			return execResult;
0: 		}
0: 	}
0: 
0: 	/*
0: 	* CallableStatement interface
0: 	* (the PreparedStatement part implemented by EmbedPreparedStatement)
0: 	*/
0: 
0: 	/**
0: 	 * @see CallableStatement#registerOutParameter
0: 	 * @exception SQLException NoOutputParameters thrown.
0: 	 */
0: 	public final void registerOutParameter(int parameterIndex, int sqlType)
0: 		throws SQLException 
0: 	{
0: 		checkStatus();
0: 
0: 		try {
0: 			getParms().registerOutParameter(parameterIndex-1, sqlType, -1);
0: 		} catch (StandardException e)
0: 		{
0: 			throw EmbedResultSet.noStateChangeException(e);
0: 		}
0: 	}
0: 
0:     /**
0: 	 * @see CallableStatement#registerOutParameter
0:      * @exception SQLException NoOutputParameters thrown.
0:      */
0:     public final void registerOutParameter(int parameterIndex, int sqlType, int scale)
0: 	    throws SQLException 
0: 	{
0: 		checkStatus();
0: 
0: 		if (scale < 0)
0: 			throw newSQLException(SQLState.BAD_SCALE_VALUE, new Integer(scale));
0: 		try {
0: 			getParms().registerOutParameter(parameterIndex-1, sqlType, scale);
0: 		} catch (StandardException e)
0: 		{
0: 			throw EmbedResultSet.noStateChangeException(e);
0: 		}
0: 
0: 	}
0: 
0: 
0: 	/**
0: 	 * JDBC 2.0
0: 	 *
0: 	 * Registers the designated output parameter
0: 	 *
0: 	 * @exception SQLException if a database-access error occurs.
0: 	 */
0:  	public void registerOutParameter(int parameterIndex, int sqlType, 
0:  									 String typeName) 
0:  		 throws SQLException
0:  	{
0:  		throw Util.notImplemented("registerOutParameter");
0:  	}
0:  		 
0:  
0: 
0:     /**
0: 	 * @see CallableStatement#wasNull
0:      * @exception SQLException NoOutputParameters thrown.
0:      */
0:     public boolean wasNull() throws SQLException 
0: 	{
0: 		checkStatus();
0: 		return wasNull;
0: 	}
0: 
0:     /**
0: 	 * @see CallableStatement#getString
0:      * @exception SQLException NoOutputParameters thrown.
0:      */
0:     public String getString(int parameterIndex) throws SQLException 
0: 	{
0: 		checkStatus();
0: 		try {
0: 			String v =  getParms().getParameterForGet(parameterIndex-1).getString();
0: 			wasNull = (v == null);
0: 			return v;
0: 
0: 		} catch (StandardException e)
0: 		{
0: 			throw EmbedResultSet.noStateChangeException(e);
0: 		}
0: 	}
0: 
0:     /**
0: 	 * @see CallableStatement#getBoolean
0:      * @exception SQLException NoOutputParameters thrown.
0:      */
0:     public boolean getBoolean(int parameterIndex) throws SQLException 
0: 	{
0: 		checkStatus();
0: 		try {
0: 			DataValueDescriptor param = getParms().getParameterForGet(parameterIndex-1);
0: 			boolean v = param.getBoolean();
0: 			wasNull = (!v) && param.isNull();
0: 			return v;
0: 		} catch (StandardException e)
0: 		{
0: 			throw EmbedResultSet.noStateChangeException(e);
0: 		}
0: 
0: 	}
0: 
0:     /**
0: 	 * @see CallableStatement#getByte
0:      * @exception SQLException NoOutputParameters thrown.
0:      */
0:     public byte getByte(int parameterIndex) throws SQLException 
0: 	{
0: 		checkStatus();
0: 		try {
0: 			DataValueDescriptor param = getParms().getParameterForGet(parameterIndex-1);
0: 			byte b = param.getByte();
0: 			wasNull = (b == 0) && param.isNull();
0: 			return b;
0: 		} catch (StandardException e)
0: 		{
0: 			throw EmbedResultSet.noStateChangeException(e);
0: 		}
0: 
0: 	}
0: 
0:     /**
0: 	 * @see CallableStatement#getShort
0:      * @exception SQLException NoOutputParameters thrown.
0:      */
0:     public short getShort(int parameterIndex) throws SQLException 
0: 	{
0: 		checkStatus();
0: 		try {
0: 			DataValueDescriptor param = getParms().getParameterForGet(parameterIndex-1);
0: 			short s = param.getShort();
0: 			wasNull = (s == 0) && param.isNull();
0: 			return s;
0: 		} catch (StandardException e)
0: 		{
0: 			throw EmbedResultSet.noStateChangeException(e);
0: 		}
0: 
0: 	}
0: 
0:     /**
0: 	 * @see CallableStatement#getInt
0:      * @exception SQLException NoOutputParameters thrown.
0:      */
0:     public int getInt(int parameterIndex) throws SQLException 
0: 	{
0: 		checkStatus();
0: 
0: 		try {
0: 			DataValueDescriptor param = getParms().getParameterForGet(parameterIndex-1);
0: 			int v = param.getInt();
0: 			wasNull = (v == 0) && param.isNull();
0: 			return v;
0: 
0: 		} catch (StandardException e)
0: 		{
0: 			throw EmbedResultSet.noStateChangeException(e);
0: 		}
0: 	}
0: 
0:     /**
0: 	 * @see CallableStatement#getLong
0:      * @exception SQLException NoOutputParameters thrown.
0:      */
0:     public long getLong(int parameterIndex) throws SQLException 
0: 	{
0: 		checkStatus();
0: 		try {
0: 			DataValueDescriptor param = getParms().getParameterForGet(parameterIndex-1);
0: 			long v = param.getLong();
0: 			wasNull = (v == 0L) && param.isNull();
0: 			return v;
0: 		} catch (StandardException e)
0: 		{
0: 			throw EmbedResultSet.noStateChangeException(e);
0: 		}
0: 
0: 	}
0: 
0:     /**
0: 	 * @see CallableStatement#getFloat
0:      * @exception SQLException NoOutputParameters thrown.
0:      */
0:     public float getFloat(int parameterIndex) throws SQLException 
0: 	{
0: 		checkStatus();
0: 		try {
0: 			DataValueDescriptor param = getParms().getParameterForGet(parameterIndex-1);
0: 			float v = param.getFloat();
0: 			wasNull = (v == 0.0) && param.isNull();
0: 			return v;
0: 		} catch (StandardException e)
0: 		{
0: 			throw EmbedResultSet.noStateChangeException(e);
0: 		}
0: 	}
0: 
0:     /**
0: 	 * @see CallableStatement#getDouble
0:      * @exception SQLException NoOutputParameters thrown.
0:      */
0:     public double getDouble(int parameterIndex) throws SQLException 
0: 	{
0: 		checkStatus();
0: 		try {
0: 			DataValueDescriptor param = getParms().getParameterForGet(parameterIndex-1);
0: 			double v = param.getDouble();
0: 			wasNull = (v == 0.0) && param.isNull();
0: 			return v;
0: 		} catch (StandardException e)
0: 		{
0: 			throw EmbedResultSet.noStateChangeException(e);
0: 		}
0: 
0: 	}
0: 
0:     /**
0: 	 * @see CallableStatement#getBigDecimal
0:      * @exception SQLException NoOutputParameters thrown.
0:      */
0:     public BigDecimal getBigDecimal(int parameterIndex, int scale) throws SQLException
0: 	{
0: 		checkStatus();
0: 		try {
0: 			BigDecimal v =  getParms().getParameterForGet(parameterIndex-1).getBigDecimal();
0: 			wasNull = (v == null);
0: 			return v;
0: 		} catch (StandardException e)
0: 		{
0: 			throw EmbedResultSet.noStateChangeException(e);
0: 		}
0: 
0: 	}
0: 
0:     /**
0: 	 * @see CallableStatement#getBytes
0:      * @exception SQLException NoOutputParameters thrown.
0:      */
0:     public byte[] getBytes(int parameterIndex) throws SQLException 
0: 	{
0: 		checkStatus();
0: 		try {
0: 			byte[] v =  getParms().getParameterForGet(parameterIndex-1).getBytes();
0: 			wasNull = (v == null);
0: 			return v;
0: 		} catch (StandardException e)
0: 		{
0: 			throw EmbedResultSet.noStateChangeException(e);
0: 		}
0: 
0: 	}
0: 
0:     /**
0: 	 * @see CallableStatement#getDate
0:      * @exception SQLException NoOutputParameters thrown.
0:      */
0:     public Date getDate(int parameterIndex) throws SQLException
0: 	{
0: 		checkStatus();
0: 		try {
0: 			Date v =  getParms().getParameterForGet(parameterIndex-1).getDate(getCal());
0: 			wasNull = (v == null);
0: 			return v;
0: 		} catch (StandardException e)
0: 		{
0: 			throw EmbedResultSet.noStateChangeException(e);
0: 		}
0: 
0: 	}
0: 
0:     /**
0: 	 * @see CallableStatement#getTime
0:      * @exception SQLException NoOutputParameters thrown.
0:      */
0: 	public Time getTime(int parameterIndex) throws SQLException 
0: 	{
0: 		checkStatus();
0: 		try {
0: 			Time v =  getParms().getParameterForGet(parameterIndex-1).getTime(getCal());
0: 			wasNull = (v == null);
0: 			return v;
0: 		} catch (StandardException e)
0: 		{
0: 			throw EmbedResultSet.noStateChangeException(e);
0: 		}
0: 
0: 	}
0: 
0:     /**
0: 	 * @see CallableStatement#getTimestamp
0:      * @exception SQLException NoOutputParameters thrown.
0:      */
0:     public Timestamp getTimestamp(int parameterIndex)
0: 	    throws SQLException 
0: 	{
0: 		checkStatus();
0: 		try {
0: 			Timestamp v =  getParms().getParameterForGet(parameterIndex-1).getTimestamp(getCal());
0: 			wasNull = (v == null);
0: 			return v;
0: 		} catch (StandardException e)
0: 		{
0: 			throw EmbedResultSet.noStateChangeException(e);
0: 		}
0: 	}
0: 
0:     /**
0: 	 * @see CallableStatement#getObject
0:      * @exception SQLException NoOutputParameters thrown.
0:      */
0: 	public Object getObject(int parameterIndex) throws SQLException 
0: 	{
0: 		checkStatus();
0: 		try {
0: 			Object v = getParms().getObject(parameterIndex-1);
0: 			wasNull = (v == null);
0: 			return v;
0: 
0: 		} catch (StandardException e)
0: 		{
0: 			throw EmbedResultSet.noStateChangeException(e);
0: 		}
0: 	}
0: 
0: 	public void addBatch() throws SQLException {
0: 
0: 		checkStatus();
0: 		ParameterValueSet pvs = getParms();
0: 
0: 		int numberOfParameters = pvs.getParameterCount();
0: 
0: 		for (int j=1; j<=numberOfParameters; j++) {
0: 
0: 			switch (pvs.getParameterMode(j)) {
0: 			case JDBC30Translation.PARAMETER_MODE_IN:
0: 			case JDBC30Translation.PARAMETER_MODE_UNKNOWN:
0: 				break;
0: 			case JDBC30Translation.PARAMETER_MODE_OUT:
0: 			case JDBC30Translation.PARAMETER_MODE_IN_OUT:
0: 				throw newSQLException(SQLState.OUTPUT_PARAMS_NOT_ALLOWED);
0: 			}
0: 		}
0: 
0: 		super.addBatch();
0: 	}
0: }
0: 
============================================================================