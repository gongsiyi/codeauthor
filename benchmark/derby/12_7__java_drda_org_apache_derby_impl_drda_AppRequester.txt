1:eac0369: /*
1:d7258ed: 
1:d7258ed:    Derby - Class org.apache.derby.impl.drda.AppRequester
1:d7258ed: 
1:59e5225:    Licensed to the Apache Software Foundation (ASF) under one or more
1:59e5225:    contributor license agreements.  See the NOTICE file distributed with
1:59e5225:    this work for additional information regarding copyright ownership.
1:59e5225:    The ASF licenses this file to You under the Apache License, Version 2.0
1:59e5225:    (the "License"); you may not use this file except in compliance with
1:59e5225:    the License.  You may obtain a copy of the License at
1:d7258ed: 
1:d7258ed:       http://www.apache.org/licenses/LICENSE-2.0
1:d7258ed: 
1:d7258ed:    Unless required by applicable law or agreed to in writing, software
1:d7258ed:    distributed under the License is distributed on an "AS IS" BASIS,
1:d7258ed:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:d7258ed:    See the License for the specific language governing permissions and
1:d7258ed:    limitations under the License.
12:eac0369: 
1:90731d5:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.drda;
1:90731d5: import org.apache.derby.iapi.reference.DRDAConstants;
1:16aa6a4: import org.apache.derby.shared.common.error.MessageUtils;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: 
1:4383496: /**
1:4f996a4:     AppRequester stores information about the application requester.
1:4f996a4:     It is used so that multiple sessions can share information when they are
1:4f996a4:     started from the same version of the application requester.
1:4f996a4: */
1:eac0369: class AppRequester
1:4f996a4: {
1:eac0369: 
1:4f996a4:     protected static final int MGR_LEVEL_UNKNOWN = -1;
1:eac0369: 
1:4f996a4:     protected static final int UNKNOWN_CLIENT = 0;
1:b0902f1: 
1:db9a013:     protected static final int DNC_CLIENT = 3;      // derby net client
1:eac0369: 
1:4f996a4:     private static final int [] MIN_MGR_LEVELS = {
1:4f996a4:                                             3, // AGENT - JCC comes in at 3
1:db9a013:                                             4, // CCSIDMGR
1:4f996a4:                                             3, // CMNAPPC, 
1:4f996a4:                                             4, // CMNSYNCPT
1:4f996a4:                                             5, // CMNTCPIP
1:4f996a4:                                             1, // DICTIONARY
1:4f996a4:                                             3, // RDB
1:4f996a4:                                             4, // RSYNCMGR
1:4f996a4:                                             1, // SECMGR    
1:4f996a4:                                             6, // SQLAM
1:4f996a4:                                             1, // SUPERVISOR    
1:4f996a4:                                             5, // SYNCPTMGR
1:816270f:                                             1208, // UNICODEMGR
1:4f996a4:                                             0  // XAMGR
1:4f996a4:                                             };
1:4f996a4:     
1:4f996a4:     // Application requester information
1:db9a013:     protected String    extnam;         // External Name - EXCSAT
1:db9a013:     protected String    srvnam;         // Server Name - EXCSAT
1:db9a013:     protected String    srvrlslv;       // Server Product Release Level - EXCSAT
1:db9a013:     protected String    srvclsnm;       // Server Class Name - EXCSAT
1:db9a013:     protected String    spvnam;         // Supervisor Name - EXCSAT
1:db9a013:     protected String    prdid;          // Product specific identifier - ACCRDB protected
1:db9a013:     private int[]       managerLevels = new int[CodePoint.MGR_CODEPOINTS.length];
1:4f996a4:     private int         clientType;
1:db9a013:     protected int       versionLevel;
1:db9a013:     protected int       releaseLevel;
1:db9a013:     protected int       modifyLevel;
1:4f996a4:     
1:90731d5: 
1:4f996a4:     // constructor 
1:4f996a4:     /** 
1:4f996a4:      * AppRequester constructor
1:4f996a4:      * 
1:4f996a4:      * @exception throws IOException
1:4f996a4:      */
1:4f996a4:     AppRequester () 
1:4f996a4:     {
1:4f996a4:         for (int i = 0; i < CodePoint.MGR_CODEPOINTS.length; i++)
1:4f996a4:             managerLevels[i] = MGR_LEVEL_UNKNOWN;
1:4f996a4:     }
1:cf5cebf: 
1:4f996a4:     /**
1:4f996a4:      * get the Application requester manager level
1:4f996a4:      *
1:db9a013:      * @param manager   codepoint for manager we are looking for
1:4f996a4:      *
1:4f996a4:      * @return manager level for that manager
1:4f996a4:      */
1:4f996a4:     protected int getManagerLevel(int manager)
1:4f996a4:     {
1:4f996a4:         int mindex = CodePoint.getManagerIndex(manager);
1:4f996a4:         if (SanityManager.DEBUG)
1:4f996a4:         {
1:4f996a4:             if (mindex < 0 || mindex > managerLevels.length)
1:4f996a4:                 SanityManager.THROWASSERT("Unknown manager "+ manager + " mindex = "+
1:4f996a4:                     mindex);
1:4f996a4:         }
1:4f996a4:         return managerLevels[mindex];
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     protected void setClientVersion(String productId)
1:4f996a4:     {
1:4f996a4:         prdid = productId;
1:eac0369: 
1:4f996a4:         versionLevel = Integer.parseInt(prdid.substring (3, 5));
1:4f996a4:         releaseLevel = Integer.parseInt(prdid.substring (5, 7));
1:4f996a4:         modifyLevel = Integer.parseInt(prdid.substring (7, 8));
1:b0902f1:         if ((prdid.indexOf(DRDAConstants.DERBY_DRDA_CLIENT_ID) != -1)) {
1:b0902f1:             clientType = DNC_CLIENT;
1:b0902f1:         } else {
1:b0902f1:             clientType = UNKNOWN_CLIENT;
1:4f996a4:         }
1:4f996a4:     }
1:90731d5: 
1:4f996a4:     /**
1:7233e33:      * Returns true if Derby's client driver supports SECMEC_USRSSBPWD 
1:7233e33:      * DRDA security mechanism.
1:7233e33:      */
1:7233e33:     protected boolean supportsSecMecUSRSSBPWD()
1:7233e33:     {
1:7233e33:         return
1:7233e33:             (
1:7233e33:                 ( clientType == DNC_CLIENT ) &&
1:7233e33:                 ( greaterThanOrEqualTo( 10, 2, 0 ) )
1:7233e33:             );
1:7233e33:     }
1:7233e33: 
1:7233e33:     /**
1:4f996a4:      * Check if the client expects QRYCLSIMP to be supported when the
1:4f996a4:      * protocol is LMTBLKPRC.
1:4f996a4:      *
1:4f996a4:      * @return <code>true</code> if QRYCLSIMP is supported for
1:4f996a4:      * LMTBLKPRC
1:4f996a4:      */
1:4f996a4:     protected final boolean supportsQryclsimpForLmtblkprc() {
1:4f996a4:         return clientType == DNC_CLIENT;
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * Check if provided JCC version level is greaterThanOrEqualTo current level
1:4f996a4:      *
1:4f996a4:      * @param vLevel    Version level
1:4f996a4:      * @param rLevel    Release level
1:4f996a4:      * @param mLevel    Modification level
1:4f996a4:      */
1:4f996a4:      
1:4f996a4:     protected boolean greaterThanOrEqualTo(int vLevel, int rLevel, int mLevel)
1:4f996a4:     {
1:4f996a4:         if (versionLevel > vLevel)
1:4f996a4:                 return true;
1:4f996a4:         else if (versionLevel == vLevel) {
1:4f996a4:                 if (releaseLevel > rLevel)
1:4f996a4:                         return true;
1:4f996a4:                 else if (releaseLevel == rLevel)
1:4f996a4:                         if (modifyLevel >= mLevel)
1:4f996a4:                                 return true;
1:4f996a4:         }
1:4f996a4:         return false;
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /** 
1:4f996a4:      * set Application requester manager level
1:4f996a4:      * if the manager level is less than the minimum manager level,
1:4f996a4:      * set the manager level to zero (saying we can't handle this
1:4f996a4:      * level), this will be returned
1:4f996a4:      * to the application requester and he can decide whether or not to
1:4f996a4:      * proceed
1:4f996a4:      * For CCSIDMGR, if the target server supports the CCSID manager but
1:4f996a4:      * not the CCSID requested, the value returned is FFFF
1:4f996a4:      * For now, we won't support the CCSIDMGR since JCC doesn't request it.
1:4f996a4:      *
1:db9a013:      * @param manager   codepoint of the manager
1:db9a013:      * @param managerLevel  level for that manager
1:4f996a4:      *
1:4f996a4:      */
1:4f996a4:     protected void setManagerLevel(int manager, int managerLevel)
1:4f996a4:     {
1:4f996a4:         int i = CodePoint.getManagerIndex(manager);
1:4f996a4:         if (SanityManager.DEBUG)
1:4f996a4:         {
1:4f996a4:             if (i < 0 || i > managerLevels.length)
1:4f996a4:                 SanityManager.THROWASSERT("Unknown manager "+ manager + " i = " + i);
1:4f996a4:         }
1:4f996a4:         if (managerLevel >= MIN_MGR_LEVELS[i])
1:4f996a4:             managerLevels[i] = managerLevel;    
1:4f996a4:         else
1:4f996a4:             managerLevels[i] = 0;
1:4f996a4:     }
1:4f996a4:     
1:4f996a4:     /**
1:4f996a4:      * Check if the application requester is the same as this one
1:4f996a4:      *
1:db9a013:      * @param a application requester to compare to
1:4f996a4:      * @return true if same false otherwise
1:4f996a4:      */
1:4f996a4:     protected boolean equals(AppRequester a)
1:4f996a4:     {
1:4f996a4:         // check prdid - this should be different if they are different
1:4f996a4:         if (!prdid.equals(a.prdid))
1:4f996a4:             return false;
1:eac0369: 
1:4f996a4:         // check server product release level
1:4f996a4:         if (notEquals(srvrlslv, a.srvrlslv))
1:4f996a4:             return false;
1:eac0369: 
1:4f996a4:         // check server names
1:4f996a4:         if (notEquals(extnam, a.extnam))
1:4f996a4:             return false;
1:eac0369: 
1:4f996a4:         if (notEquals(srvnam, a.srvnam))
1:4f996a4:             return false;
1:eac0369: 
1:4f996a4:         if (notEquals(srvclsnm, a.srvclsnm))
1:4f996a4:             return false;
1:eac0369: 
1:4f996a4:         if (notEquals(spvnam, a.spvnam))
1:4f996a4:             return false;
1:eac0369: 
1:4f996a4:         // check manager levels
1:4f996a4:         for (int i = 0; i < managerLevels.length; i++)
1:4f996a4:             if (managerLevels[i] != a.managerLevels[i])
1:4f996a4:                 return false;
1:eac0369: 
1:4f996a4:         // O.K. looks good
1:4f996a4:         return true;
1:4f996a4:     }
1:4f996a4:     /**
1:4f996a4:      * Check whether two objects are not equal when 1 of the objects could
1:4f996a4:      * be null
1:4f996a4:      *
1:db9a013:      * @param a first object
1:4f996a4:      * @param b second object
1:4f996a4:      * @return true if not equals false otherwise
1:4f996a4:      */
1:4f996a4:     private boolean notEquals(Object a, Object b)
1:4f996a4:     {
1:4f996a4:         if (a != null && b == null)
1:4f996a4:             return true;
1:4f996a4:         if (a == null && b != null)
1:4f996a4:             return true;
1:4f996a4:         if (a != null && !a.equals(b))
1:4f996a4:             return true;
1:4f996a4:         return false;
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * Get the maximum length supported for an exception's message
1:4f996a4:      * parameter string.
1:4f996a4:      */
1:eac0369: 
1:4f996a4:     protected int supportedMessageParamLength() {
1:16aa6a4:         return MessageUtils.DB2_JCC_MAX_EXCEPTION_PARAM_LENGTH;
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * Get the type of the client.
1:4f996a4:      */
1:eac0369: 
1:4f996a4:     protected int getClientType() {
1:eac0369: 
1:4f996a4:         return clientType;
1:eac0369: 
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * Is this an AppRequester that supports XA 
1:4f996a4:      *
1:dbed020:      * return true if XAMGR &gt;= 7, false otherwise
1:4f996a4:      **/
1:4383496: 
1:4f996a4:     protected  boolean isXARequester()
1:4f996a4:     {
1:4f996a4:         return (getManagerLevel(CodePoint.XAMGR) >= 7);
1:4f996a4:         
1:4f996a4:     }
1:4383496: 
1:4f996a4:     /**
1:cf5cebf:      * Tells whether the client sends a trailing Derby-specific status byte
1:cf5cebf:      * when transferring EXTDTA objects.
1:4383496:      *
1:cf5cebf:      * @return {@code true} if the status byte is sent, {@code false} if not
1:cf5cebf:      */
1:cf5cebf:     protected boolean supportsEXTDTAAbort() {
2:4f996a4:         return (clientType == DNC_CLIENT && greaterThanOrEqualTo(10, 6, 0));
2:4f996a4:     }
1:816270f:     
1:816270f:     /**
1:816270f:      * Returns whether our AppRequester's UNICODEMGR supports UTF8 (CCSID 1208)
1:816270f:      * @return {@code true} if the AppRequester supports CCSID 1208, {@code false} if not
1:816270f:      */
1:816270f:     protected boolean supportsUtf8Ccsid() {
1:816270f:         return (getManagerLevel(CodePoint.UNICODEMGR) == CcsidManager.UTF8_CCSID);
1:816270f:     }
1:4383496: 
1:4f996a4:     protected boolean supportsSessionDataCaching() {
1:4f996a4:         return (clientType == DNC_CLIENT && greaterThanOrEqualTo(10, 4, 0));
1:4f996a4:     }
1:506f4c8: 
1:506f4c8:     protected boolean supportsUDTs() {
1:506f4c8:         return (clientType == DNC_CLIENT && greaterThanOrEqualTo(10, 6, 0));
1:506f4c8:     }
1:bead0ab: 
1:bead0ab:     protected boolean supportsTimestampNanoseconds() {
1:bead0ab:         return (clientType == DNC_CLIENT && greaterThanOrEqualTo(10, 6, 0));
1:bead0ab:     }
1:bead0ab: 
1:eff3919:     protected boolean supportsBooleanValues() {
1:eff3919:         return (clientType == DNC_CLIENT && greaterThanOrEqualTo(10, 7, 0));
1:eff3919:     }
1:eff3919: 
1:bead0ab:     /**
1:9b3e218:      * Return true if the client contains the fix for DERBY-5236, which allows
1:9b3e218:      * DDMWriter.writeLDString() to write strings that need up to 64K-1 bytes
1:9b3e218:      * when represented in UTF-8. Otherwise, writeLDString() should use the
1:9b3e218:      * old maximum length, which is 32700 bytes.
1:9b3e218:      */
1:9b3e218:     protected boolean supportsLongerLDStrings() {
1:774b7ed:         // The fix for DERBY-5236 went into the 10.8 branch after the first
1:774b7ed:         // release off that branch. The DRDA maintenance version was bumped
1:774b7ed:         // to 1 when the fix went in (the third argument in the call to
1:774b7ed:         // greaterThanOrEqualTo() refers to that maintenance version, not to
1:774b7ed:         // the third digit of the product's version number).
1:774b7ed:         return clientType == DNC_CLIENT && greaterThanOrEqualTo(10, 8, 1);
1:9b3e218:     }
1:9b3e218: 
1:9b3e218:     /**
1:bead0ab:      * The timestamp length may be truncated for old versions of Derby.
1:bead0ab:      * See DERBY-2602.
1:bead0ab:      */
1:bead0ab:     protected int getTimestampLength()
1:bead0ab:     {
1:bead0ab:         return supportsTimestampNanoseconds() ?
1:60f5182:             DRDAConstants.JDBC_TIMESTAMP_LENGTH : DRDAConstants.DRDA_OLD_TIMESTAMP_LENGTH;
1:bead0ab:     }
1:bead0ab: 
1:4f996a4: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1:      * return true if XAMGR &gt;= 7, false otherwise
commit:60f5182
/////////////////////////////////////////////////////////////////////////
1:             DRDAConstants.JDBC_TIMESTAMP_LENGTH : DRDAConstants.DRDA_OLD_TIMESTAMP_LENGTH;
commit:eff3919
/////////////////////////////////////////////////////////////////////////
1: 	protected boolean supportsBooleanValues() {
1: 		return (clientType == DNC_CLIENT && greaterThanOrEqualTo(10, 7, 0));
1: 	}
1: 
commit:bead0ab
/////////////////////////////////////////////////////////////////////////
1: 
1: 	protected boolean supportsTimestampNanoseconds() {
1: 		return (clientType == DNC_CLIENT && greaterThanOrEqualTo(10, 6, 0));
1: 	}
1: 
1:     /**
1:      * The timestamp length may be truncated for old versions of Derby.
1:      * See DERBY-2602.
1:      */
1:     protected int getTimestampLength()
1:     {
1:         return supportsTimestampNanoseconds() ?
0:             DRDAConstants.JDBC_TIMESTAMP_LENGTH : DRDAConstants.DRDA_TIMESTAMP_LENGTH;
1:     }
1: 
commit:506f4c8
/////////////////////////////////////////////////////////////////////////
1: 
1: 	protected boolean supportsUDTs() {
1: 		return (clientType == DNC_CLIENT && greaterThanOrEqualTo(10, 6, 0));
1: 	}
commit:7233e33
/////////////////////////////////////////////////////////////////////////
1: 	 * Returns true if Derby's client driver supports SECMEC_USRSSBPWD 
1: 	 * DRDA security mechanism.
1: 	 */
1: 	protected boolean supportsSecMecUSRSSBPWD()
1: 	{
1: 		return
1: 			(
1: 			    ( clientType == DNC_CLIENT ) &&
1: 			    ( greaterThanOrEqualTo( 10, 2, 0 ) )
1: 			);
1: 	}
1: 
1: 	/**
commit:93cfc7f
/////////////////////////////////////////////////////////////////////////
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:16aa6a4
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.error.MessageUtils;
/////////////////////////////////////////////////////////////////////////
1:         return MessageUtils.DB2_JCC_MAX_EXCEPTION_PARAM_LENGTH;
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
commit:816270f
/////////////////////////////////////////////////////////////////////////
1: 											1208, // UNICODEMGR
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Returns whether our AppRequester's UNICODEMGR supports UTF8 (CCSID 1208)
1:      * @return {@code true} if the AppRequester supports CCSID 1208, {@code false} if not
1:      */
1:     protected boolean supportsUtf8Ccsid() {
1:         return (getManagerLevel(CodePoint.UNICODEMGR) == CcsidManager.UTF8_CCSID);
1:     }
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:db9a013
/////////////////////////////////////////////////////////////////////////
1:     protected static final int DNC_CLIENT = 3;      // derby net client
1:                                             4, // CCSIDMGR
/////////////////////////////////////////////////////////////////////////
1:     protected String    extnam;         // External Name - EXCSAT
1:     protected String    srvnam;         // Server Name - EXCSAT
1:     protected String    srvrlslv;       // Server Product Release Level - EXCSAT
1:     protected String    srvclsnm;       // Server Class Name - EXCSAT
1:     protected String    spvnam;         // Supervisor Name - EXCSAT
1:     protected String    prdid;          // Product specific identifier - ACCRDB protected
1:     private int[]       managerLevels = new int[CodePoint.MGR_CODEPOINTS.length];
1:     protected int       versionLevel;
1:     protected int       releaseLevel;
1:     protected int       modifyLevel;
/////////////////////////////////////////////////////////////////////////
1:      * @param manager   codepoint for manager we are looking for
/////////////////////////////////////////////////////////////////////////
1:      * @param manager   codepoint of the manager
1:      * @param managerLevel  level for that manager
/////////////////////////////////////////////////////////////////////////
1:      * @param a application requester to compare to
/////////////////////////////////////////////////////////////////////////
1:      * @param a first object
commit:db4c995
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.services.sanity.SanityManager;
commit:774b7ed
/////////////////////////////////////////////////////////////////////////
1:         // The fix for DERBY-5236 went into the 10.8 branch after the first
1:         // release off that branch. The DRDA maintenance version was bumped
1:         // to 1 when the fix went in (the third argument in the call to
1:         // greaterThanOrEqualTo() refers to that maintenance version, not to
1:         // the third digit of the product's version number).
1:         return clientType == DNC_CLIENT && greaterThanOrEqualTo(10, 8, 1);
commit:9b3e218
/////////////////////////////////////////////////////////////////////////
1:      * Return true if the client contains the fix for DERBY-5236, which allows
1:      * DDMWriter.writeLDString() to write strings that need up to 64K-1 bytes
1:      * when represented in UTF-8. Otherwise, writeLDString() should use the
1:      * old maximum length, which is 32700 bytes.
1:      */
1:     protected boolean supportsLongerLDStrings() {
0:         return clientType == DNC_CLIENT && greaterThanOrEqualTo(10, 8, 2);
1:     }
1: 
1:     /**
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:4f996a4
/////////////////////////////////////////////////////////////////////////
1:     AppRequester stores information about the application requester.
1:     It is used so that multiple sessions can share information when they are
1:     started from the same version of the application requester.
1:     protected static final int MGR_LEVEL_UNKNOWN = -1;
1:     protected static final int UNKNOWN_CLIENT = 0;
0:     protected static final int DNC_CLIENT = 3;        // derby net client 
1:     private static final int [] MIN_MGR_LEVELS = {
1:                                             3, // AGENT - JCC comes in at 3
0:                                             4, // CCSIDMGR    
1:                                             3, // CMNAPPC, 
1:                                             4, // CMNSYNCPT
1:                                             5, // CMNTCPIP
1:                                             1, // DICTIONARY
1:                                             3, // RDB
1:                                             4, // RSYNCMGR
1:                                             1, // SECMGR    
1:                                             6, // SQLAM
1:                                             1, // SUPERVISOR    
1:                                             5, // SYNCPTMGR
0:                                             1208, // UNICODEMGR
1:                                             0  // XAMGR
1:                                             };
1:     
1:     // Application requester information
0:     protected String    extnam;            // External Name - EXCSAT
0:     protected String    srvnam;            // Server Name - EXCSAT
0:     protected String     srvrlslv;        // Server Product Release Level - EXCSAT
0:     protected String    srvclsnm;        // Server Class Name - EXCSAT
0:     protected String    spvnam;            // Supervisor Name - EXCSAT
0:     protected String    prdid;            // Product specific identifier - ACCRDB protected
0:     private int[]        managerLevels = new int[CodePoint.MGR_CODEPOINTS.length];
1:     private int         clientType;
0:     protected int        versionLevel;
0:     protected int        releaseLevel;
0:     protected int        modifyLevel;
1:     
1:     // constructor 
1:     /** 
1:      * AppRequester constructor
1:      * 
1:      * @exception throws IOException
1:      */
1:     AppRequester () 
1:     {
1:         for (int i = 0; i < CodePoint.MGR_CODEPOINTS.length; i++)
1:             managerLevels[i] = MGR_LEVEL_UNKNOWN;
1:     }
1:     /**
1:      * get the Application requester manager level
1:      *
0:      * @param manager    codepoint for manager we are looking for
1:      *
1:      * @return manager level for that manager
1:      */
1:     protected int getManagerLevel(int manager)
1:     {
1:         int mindex = CodePoint.getManagerIndex(manager);
1:         if (SanityManager.DEBUG)
1:         {
1:             if (mindex < 0 || mindex > managerLevels.length)
1:                 SanityManager.THROWASSERT("Unknown manager "+ manager + " mindex = "+
1:                     mindex);
1:         }
1:         return managerLevels[mindex];
1:     }
1:     protected void setClientVersion(String productId)
1:     {
1:         prdid = productId;
1:         versionLevel = Integer.parseInt(prdid.substring (3, 5));
1:         releaseLevel = Integer.parseInt(prdid.substring (5, 7));
1:         modifyLevel = Integer.parseInt(prdid.substring (7, 8));
1:     }
1:     /**
0:      * Returns true if Derby's client driver supports SECMEC_USRSSBPWD 
0:      * DRDA security mechanism.
1:      */
0:     protected boolean supportsSecMecUSRSSBPWD()
1:     {
0:         return
0:             (
0:                 ( clientType == DNC_CLIENT ) &&
0:                 ( greaterThanOrEqualTo( 10, 2, 0 ) )
0:             );
1:     }
1:     /**
1:      * Check if the client expects QRYCLSIMP to be supported when the
1:      * protocol is LMTBLKPRC.
1:      *
1:      * @return <code>true</code> if QRYCLSIMP is supported for
1:      * LMTBLKPRC
1:      */
1:     protected final boolean supportsQryclsimpForLmtblkprc() {
1:         return clientType == DNC_CLIENT;
1:     }
1:     /**
1:      * Check if provided JCC version level is greaterThanOrEqualTo current level
1:      *
1:      * @param vLevel    Version level
1:      * @param rLevel    Release level
1:      * @param mLevel    Modification level
1:      */
1:      
1:     protected boolean greaterThanOrEqualTo(int vLevel, int rLevel, int mLevel)
1:     {
1:         if (versionLevel > vLevel)
1:                 return true;
1:         else if (versionLevel == vLevel) {
1:                 if (releaseLevel > rLevel)
1:                         return true;
1:                 else if (releaseLevel == rLevel)
1:                         if (modifyLevel >= mLevel)
1:                                 return true;
1:         }
1:         return false;
1:     }
1:     /** 
1:      * set Application requester manager level
1:      * if the manager level is less than the minimum manager level,
1:      * set the manager level to zero (saying we can't handle this
1:      * level), this will be returned
1:      * to the application requester and he can decide whether or not to
1:      * proceed
1:      * For CCSIDMGR, if the target server supports the CCSID manager but
1:      * not the CCSID requested, the value returned is FFFF
1:      * For now, we won't support the CCSIDMGR since JCC doesn't request it.
1:      *
0:      * @param manager    codepoint of the manager
0:      * @param managerLevel    level for that manager
1:      *
1:      */
1:     protected void setManagerLevel(int manager, int managerLevel)
1:     {
1:         int i = CodePoint.getManagerIndex(manager);
1:         if (SanityManager.DEBUG)
1:         {
1:             if (i < 0 || i > managerLevels.length)
1:                 SanityManager.THROWASSERT("Unknown manager "+ manager + " i = " + i);
1:         }
1:         if (managerLevel >= MIN_MGR_LEVELS[i])
1:             managerLevels[i] = managerLevel;    
1:         else
1:             managerLevels[i] = 0;
1:     }
1:     
1:     /**
1:      * Check if the application requester is the same as this one
1:      *
0:      * @param a    application requester to compare to
1:      * @return true if same false otherwise
1:      */
1:     protected boolean equals(AppRequester a)
1:     {
1:         // check prdid - this should be different if they are different
1:         if (!prdid.equals(a.prdid))
1:             return false;
1:         // check server product release level
1:         if (notEquals(srvrlslv, a.srvrlslv))
1:             return false;
1:         // check server names
1:         if (notEquals(extnam, a.extnam))
1:             return false;
1:         if (notEquals(srvnam, a.srvnam))
1:             return false;
1:         if (notEquals(srvclsnm, a.srvclsnm))
1:             return false;
1:         if (notEquals(spvnam, a.spvnam))
1:             return false;
1:         // check manager levels
1:         for (int i = 0; i < managerLevels.length; i++)
1:             if (managerLevels[i] != a.managerLevels[i])
1:                 return false;
1:         // O.K. looks good
1:         return true;
1:     }
1:     /**
1:      * Check whether two objects are not equal when 1 of the objects could
1:      * be null
1:      *
0:       * @param a    first object
1:      * @param b second object
1:      * @return true if not equals false otherwise
1:      */
1:     private boolean notEquals(Object a, Object b)
1:     {
1:         if (a != null && b == null)
1:             return true;
1:         if (a == null && b != null)
1:             return true;
1:         if (a != null && !a.equals(b))
1:             return true;
1:         return false;
1:     }
1:     /**
1:      * Get the maximum length supported for an exception's message
1:      * parameter string.
1:      */
1:     protected int supportedMessageParamLength() {
1:     }
1:     /**
1:      * Get the type of the client.
1:      */
1:     protected int getClientType() {
1:         return clientType;
1:     }
1:     /**
1:      * Is this an AppRequester that supports XA 
1:      *
0:      * return true if XAMGR >= 7, false otherwise
1:      **/
1:     protected  boolean isXARequester()
1:     {
1:         return (getManagerLevel(CodePoint.XAMGR) >= 7);
1:         
1:     }
/////////////////////////////////////////////////////////////////////////
1:     protected boolean supportsSessionDataCaching() {
1:         return (clientType == DNC_CLIENT && greaterThanOrEqualTo(10, 4, 0));
1:     }
0:     protected boolean supportsUDTs() {
1:         return (clientType == DNC_CLIENT && greaterThanOrEqualTo(10, 6, 0));
1:     }
0:     protected boolean supportsTimestampNanoseconds() {
1:         return (clientType == DNC_CLIENT && greaterThanOrEqualTo(10, 6, 0));
1:     }
0:     protected boolean supportsBooleanValues() {
0:         return (clientType == DNC_CLIENT && greaterThanOrEqualTo(10, 7, 0));
1:     }
commit:b0902f1
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:         if ((prdid.indexOf(DRDAConstants.DERBY_DRDA_CLIENT_ID) != -1)) {
1:             clientType = DNC_CLIENT;
1:         } else {
1:             clientType = UNKNOWN_CLIENT;
0:         }
/////////////////////////////////////////////////////////////////////////
0:         return Limits.DB2_JCC_MAX_EXCEPTION_PARAM_LENGTH;
commit:4383496
/////////////////////////////////////////////////////////////////////////
0: 											0  // XAMGR
/////////////////////////////////////////////////////////////////////////
1: 	/**
0: 	 * Is this an AppRequester that supports XA 
1: 	 *
0: 	 * return true if XAMGR >= 7, false otherwise
0: 	 **/
1: 
0: 	protected  boolean isXARequester()
0: 	{
0: 		return (getManagerLevel(CodePoint.XAMGR) >= 7);
1: 		
0: 	}
1: 
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:cf5cebf
/////////////////////////////////////////////////////////////////////////
0:     /**
1:      * Tells whether the client sends a trailing Derby-specific status byte
1:      * when transferring EXTDTA objects.
0:      *
1:      * @return {@code true} if the status byte is sent, {@code false} if not
1:      */
1:     protected boolean supportsEXTDTAAbort() {
0:         return (clientType == DNC_CLIENT && greaterThanOrEqualTo(10, 6, 0));
0:     }
1: 
author:Dyre Tjeldvoll
-------------------------------------------------------------------------------
commit:c6c4d4d
/////////////////////////////////////////////////////////////////////////
0: 	protected boolean supportsSessionDataCaching() {
0: 		return (clientType == DNC_CLIENT && greaterThanOrEqualTo(10, 4, 0));
0: 	}
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:59e5225
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:7df5ffe
/////////////////////////////////////////////////////////////////////////
0: 	AppRequester () 
commit:90731d5
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.reference.DRDAConstants;
/////////////////////////////////////////////////////////////////////////
1: 	
/////////////////////////////////////////////////////////////////////////
0: 		{ clientType = UNKNOWN_CLIENT; }
0: 		{ clientType = JCC_CLIENT; }
0: 		else if
0: 			(
0: 			    (srvrlslv.indexOf(DRDAConstants.DERBY_DRDA_CLIENT_ID) != -1)
0: 			)
0: 		{ clientType = DNC_CLIENT; }
0: 		{ clientType = UNKNOWN_CLIENT; }
0: 	}
1: 
0: 	/**
0: 	 * Returns true if the client supports Derby's protocol for
0: 	 * transmitting BOOLEAN values.
1: 	 */
0: 	protected	boolean	supportsBoolean()
0: 	{
0: 		return
0: 			(
0: 			    ( clientType == DNC_CLIENT ) &&
0: 			    ( greaterThanOrEqualTo( 10, 2, 0 ) )
0: 			);
commit:d7258ed
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.drda.AppRequester
1: 
0:    Copyright 2002, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:141cd31
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.drda
0:    (C) Copyright IBM Corp. 2002, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
0:  */
1: 
1: package org.apache.derby.impl.drda;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.reference.DB2Limit;
1: 
0: /**
0: 	AppRequester stores information about the application requester.
0: 	It is used so that multiple sessions can share information when they are
0: 	started from the same version of the application requester.
0: */
1: class AppRequester
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
1: 
0: 	private static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2002_2004;
1: 
0: 	protected static final int MGR_LEVEL_UNKNOWN = -1;
1: 
0: 	protected static final int UNKNOWN_CLIENT = 0;
0: 	protected static final int JCC_CLIENT = 1;
0: 	protected static final int CCC_CLIENT = 2;		// not yet supported.
1: 
0: 	private static final int [] MIN_MGR_LEVELS = {
0: 											3, // AGENT - JCC comes in at 3
0: 											4, // CCSIDMGR	
0: 											3, // CMNAPPC, 
0: 											4, // CMNSYNCPT
0: 											5, // CMNTCPIP
0: 											1, // DICTIONARY
0: 											3, // RDB
0: 											4, // RSYNCMGR
0: 											1, // SECMGR	
0: 											6, // SQLAM
0: 											1, // SUPERVISOR	
0: 											5, // SYNCPTMGR
0: 											7  // XAMGR
0: 											};
0: 	// Application requester information
0: 	protected String	extnam;			// External Name - EXCSAT
0: 	protected String	srvnam;			// Server Name - EXCSAT
0: 	protected String 	srvrlslv;		// Server Product Release Level - EXCSAT
0: 	protected String	srvclsnm;		// Server Class Name - EXCSAT
0: 	protected String	spvnam;			// Supervisor Name - EXCSAT
0: 	protected String	prdid;			// Product specific identifier - ACCRDB protected
0: 	private int[]		managerLevels = new int[CodePoint.MGR_CODEPOINTS.length];
0: 	private int 		clientType;
0: 	protected int		versionLevel;
0: 	protected int		releaseLevel;
0: 	protected int		modifyLevel;
1: 	
1: 
0: 	// constructor 
0: 	/** 
0: 	 * AppRequester constructor
0: 	 * 
0: 	 * @exception throws IOException
0: 	 */
0: 	protected AppRequester () 
0: 	{
0: 		for (int i = 0; i < CodePoint.MGR_CODEPOINTS.length; i++)
0: 			managerLevels[i] = MGR_LEVEL_UNKNOWN;
0: 	}
1: 
0: 	/**
0: 	 * get the Application requester manager level
0: 	 *
0: 	 * @param manager	codepoint for manager we are looking for
0: 	 *
0: 	 * @return manager level for that manager
0: 	 */
0: 	protected int getManagerLevel(int manager)
0: 	{
0: 		int mindex = CodePoint.getManagerIndex(manager);
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (mindex < 0 || mindex > managerLevels.length)
0: 				SanityManager.THROWASSERT("Unknown manager "+ manager + " mindex = "+
0: 					mindex);
0: 		}
0: 		return managerLevels[mindex];
0: 	}
1: 
0: 	protected void setClientVersion(String productId)
0: 	{
0: 		prdid = productId;
1: 
0: 		versionLevel = Integer.parseInt(prdid.substring (3, 5));
0: 		releaseLevel = Integer.parseInt(prdid.substring (5, 7));
0: 		modifyLevel = Integer.parseInt(prdid.substring (7, 8));
0: 		if (srvrlslv == null)
0: 			clientType = UNKNOWN_CLIENT;
0: 		else if (srvrlslv.indexOf("JCC") != -1)
0: 			clientType = JCC_CLIENT;
0: 		else
0: 			clientType = UNKNOWN_CLIENT;
0: 	}
1: 
0: 	/**
0: 	 * Check if provided JCC version level is greaterThanOrEqualTo current level
0: 	 *
0: 	 * @param vLevel	Version level
0: 	 * @param rLevel	Release level
0: 	 * @param mLevel	Modification level
0: 	 */
1: 	 
0: 	protected boolean greaterThanOrEqualTo(int vLevel, int rLevel, int mLevel)
0: 	{
0: 		if (versionLevel > vLevel)
0: 				return true;
0: 		else if (versionLevel == vLevel) {
0: 				if (releaseLevel > rLevel)
0: 						return true;
0: 				else if (releaseLevel == rLevel)
0: 						if (modifyLevel >= mLevel)
0: 								return true;
0: 		}
0:     	return false;
0: 	}
1: 
0: 	/** 
0: 	 * set Application requester manager level
0: 	 * if the manager level is less than the minimum manager level,
0: 	 * set the manager level to zero (saying we can't handle this
0: 	 * level), this will be returned
0: 	 * to the application requester and he can decide whether or not to
0: 	 * proceed
0: 	 * For CCSIDMGR, if the target server supports the CCSID manager but
0: 	 * not the CCSID requested, the value returned is FFFF
0: 	 * For now, we won't support the CCSIDMGR since JCC doesn't request it.
0: 	 *
0: 	 * @param manager	codepoint of the manager
0: 	 * @param managerLevel	level for that manager
0: 	 *
0: 	 */
0: 	protected void setManagerLevel(int manager, int managerLevel)
0: 	{
0: 		int i = CodePoint.getManagerIndex(manager);
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (i < 0 || i > managerLevels.length)
0: 				SanityManager.THROWASSERT("Unknown manager "+ manager + " i = " + i);
0: 		}
0: 		if (managerLevel >= MIN_MGR_LEVELS[i])
0: 			managerLevels[i] = managerLevel;	
0: 		else
0: 			managerLevels[i] = 0;
0: 	}
1: 	
0: 	/**
0: 	 * Check if the application requester is the same as this one
0: 	 *
0: 	 * @param a	application requester to compare to
0: 	 * @return true if same false otherwise
0: 	 */
0: 	protected boolean equals(AppRequester a)
0: 	{
0: 		// check prdid - this should be different if they are different
0: 		if (!prdid.equals(a.prdid))
0: 			return false;
1: 
0: 		// check server product release level
0: 		if (notEquals(srvrlslv, a.srvrlslv))
0: 			return false;
1: 
0: 		// check server names
0: 		if (notEquals(extnam, a.extnam))
0: 			return false;
1: 
0: 		if (notEquals(srvnam, a.srvnam))
0: 			return false;
1: 
0: 		if (notEquals(srvclsnm, a.srvclsnm))
0: 			return false;
1: 
0: 		if (notEquals(spvnam, a.spvnam))
0: 			return false;
1: 
0: 		// check manager levels
0: 		for (int i = 0; i < managerLevels.length; i++)
0: 			if (managerLevels[i] != a.managerLevels[i])
0: 				return false;
1: 
0: 		// O.K. looks good
0: 		return true;
0: 	}
0: 	/**
0: 	 * Check whether two objects are not equal when 1 of the objects could
0: 	 * be null
0: 	 *
0:  	 * @param a	first object
0: 	 * @param b second object
0: 	 * @return true if not equals false otherwise
0: 	 */
0: 	private boolean notEquals(Object a, Object b)
0: 	{
0: 		if (a != null && b == null)
0: 			return true;
0: 		if (a == null && b != null)
0: 			return true;
0: 		if (a != null && !a.equals(b))
0: 			return true;
0: 		return false;
0: 	}
1: 
0: 	/**
0: 	 * Get the maximum length supported for an exception's message
0: 	 * parameter string.
0: 	 */
1: 
0: 	protected int supportedMessageParamLength() {
1: 
0: 		switch (clientType) {
1: 
0: 			case JCC_CLIENT:
0: 				return DB2Limit.DB2_JCC_MAX_EXCEPTION_PARAM_LENGTH;
0: 			default:
0: 			// Default is the max for C clients, since that is more
0: 			// restricted than for JCC clients.  Note, though, that
0: 			// JCC clients are the only ones supported right now.
0: 				return DB2Limit.DB2_CCC_MAX_EXCEPTION_PARAM_LENGTH;
1: 
0: 		}
1: 
0: 	}
1: 
0: 	/**
0: 	 * Get the type of the client.
0: 	 */
1: 
0: 	protected int getClientType() {
1: 
0: 		return clientType;
1: 
0: 	}
1: 
0: }
author:Bernt Johnsen
-------------------------------------------------------------------------------
commit:5e88312
/////////////////////////////////////////////////////////////////////////
0: 	 * Check if the client expects QRYCLSIMP to be supported when the
0: 	 * protocol is LMTBLKPRC.
0: 	 *
0: 	 * @return <code>true</code> if QRYCLSIMP is supported for
0: 	 * LMTBLKPRC
0: 	 */
0: 	protected final boolean supportsQryclsimpForLmtblkprc() {
0: 		return clientType == DNC_CLIENT;
0: 	}
0: 
0: 	/**
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:b1f84c1
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.reference.Limits;
/////////////////////////////////////////////////////////////////////////
0: 				return Limits.DB2_JCC_MAX_EXCEPTION_PARAM_LENGTH;
0: 				return Limits.DB2_CCC_MAX_EXCEPTION_PARAM_LENGTH;
commit:3d3820d
/////////////////////////////////////////////////////////////////////////
0: 	protected static final int DNC_CLIENT = 3;		// derby net client 
/////////////////////////////////////////////////////////////////////////
0: 		else if (srvrlslv.indexOf("DNC") != -1)
0: 			clientType = DNC_CLIENT;
/////////////////////////////////////////////////////////////////////////
0: 			case DNC_CLIENT:
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.drda
0:    (C) Copyright IBM Corp. 2002, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.drda;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.reference.DB2Limit;
0: 
0: /**
0: 	AppRequester stores information about the application requester.
0: 	It is used so that multiple sessions can share information when they are
0: 	started from the same version of the application requester.
0: */
0: class AppRequester
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 
0: 	private static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2002_2004;
0: 
0: 	protected static final int MGR_LEVEL_UNKNOWN = -1;
0: 
0: 	protected static final int UNKNOWN_CLIENT = 0;
0: 	protected static final int JCC_CLIENT = 1;
0: 	protected static final int CCC_CLIENT = 2;		// not yet supported.
0: 
0: 	private static final int [] MIN_MGR_LEVELS = {
0: 											3, // AGENT - JCC comes in at 3
0: 											4, // CCSIDMGR	
0: 											3, // CMNAPPC, 
0: 											4, // CMNSYNCPT
0: 											5, // CMNTCPIP
0: 											1, // DICTIONARY
0: 											3, // RDB
0: 											4, // RSYNCMGR
0: 											1, // SECMGR	
0: 											6, // SQLAM
0: 											1, // SUPERVISOR	
0: 											5, // SYNCPTMGR
0: 											7  // XAMGR
0: 											};
0: 	// Application requester information
0: 	protected String	extnam;			// External Name - EXCSAT
0: 	protected String	srvnam;			// Server Name - EXCSAT
0: 	protected String 	srvrlslv;		// Server Product Release Level - EXCSAT
0: 	protected String	srvclsnm;		// Server Class Name - EXCSAT
0: 	protected String	spvnam;			// Supervisor Name - EXCSAT
0: 	protected String	prdid;			// Product specific identifier - ACCRDB protected
0: 	private int[]		managerLevels = new int[CodePoint.MGR_CODEPOINTS.length];
0: 	private int 		clientType;
0: 	protected int		versionLevel;
0: 	protected int		releaseLevel;
0: 	protected int		modifyLevel;
0: 	
0: 
0: 	// constructor 
0: 	/** 
0: 	 * AppRequester constructor
0: 	 * 
0: 	 * @exception throws IOException
0: 	 */
0: 	protected AppRequester () 
0: 	{
0: 		for (int i = 0; i < CodePoint.MGR_CODEPOINTS.length; i++)
0: 			managerLevels[i] = MGR_LEVEL_UNKNOWN;
0: 	}
0: 
0: 	/**
0: 	 * get the Application requester manager level
0: 	 *
0: 	 * @param manager	codepoint for manager we are looking for
0: 	 *
0: 	 * @return manager level for that manager
0: 	 */
0: 	protected int getManagerLevel(int manager)
0: 	{
0: 		int mindex = CodePoint.getManagerIndex(manager);
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (mindex < 0 || mindex > managerLevels.length)
0: 				SanityManager.THROWASSERT("Unknown manager "+ manager + " mindex = "+
0: 					mindex);
0: 		}
0: 		return managerLevels[mindex];
0: 	}
0: 
0: 	protected void setClientVersion(String productId)
0: 	{
0: 		prdid = productId;
0: 
0: 		versionLevel = Integer.parseInt(prdid.substring (3, 5));
0: 		releaseLevel = Integer.parseInt(prdid.substring (5, 7));
0: 		modifyLevel = Integer.parseInt(prdid.substring (7, 8));
0: 		if (srvrlslv == null)
0: 			clientType = UNKNOWN_CLIENT;
0: 		else if (srvrlslv.indexOf("JCC") != -1)
0: 			clientType = JCC_CLIENT;
0: 		else
0: 			clientType = UNKNOWN_CLIENT;
0: 	}
0: 
0: 	/**
0: 	 * Check if provided JCC version level is greaterThanOrEqualTo current level
0: 	 *
0: 	 * @param vLevel	Version level
0: 	 * @param rLevel	Release level
0: 	 * @param mLevel	Modification level
0: 	 */
0: 	 
0: 	protected boolean greaterThanOrEqualTo(int vLevel, int rLevel, int mLevel)
0: 	{
0: 		if (versionLevel > vLevel)
0: 				return true;
0: 		else if (versionLevel == vLevel) {
0: 				if (releaseLevel > rLevel)
0: 						return true;
0: 				else if (releaseLevel == rLevel)
0: 						if (modifyLevel >= mLevel)
0: 								return true;
0: 		}
0:     	return false;
0: 	}
0: 
0: 	/** 
0: 	 * set Application requester manager level
0: 	 * if the manager level is less than the minimum manager level,
0: 	 * set the manager level to zero (saying we can't handle this
0: 	 * level), this will be returned
0: 	 * to the application requester and he can decide whether or not to
0: 	 * proceed
0: 	 * For CCSIDMGR, if the target server supports the CCSID manager but
0: 	 * not the CCSID requested, the value returned is FFFF
0: 	 * For now, we won't support the CCSIDMGR since JCC doesn't request it.
0: 	 *
0: 	 * @param manager	codepoint of the manager
0: 	 * @param managerLevel	level for that manager
0: 	 *
0: 	 */
0: 	protected void setManagerLevel(int manager, int managerLevel)
0: 	{
0: 		int i = CodePoint.getManagerIndex(manager);
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (i < 0 || i > managerLevels.length)
0: 				SanityManager.THROWASSERT("Unknown manager "+ manager + " i = " + i);
0: 		}
0: 		if (managerLevel >= MIN_MGR_LEVELS[i])
0: 			managerLevels[i] = managerLevel;	
0: 		else
0: 			managerLevels[i] = 0;
0: 	}
0: 	
0: 	/**
0: 	 * Check if the application requester is the same as this one
0: 	 *
0: 	 * @param a	application requester to compare to
0: 	 * @return true if same false otherwise
0: 	 */
0: 	protected boolean equals(AppRequester a)
0: 	{
0: 		// check prdid - this should be different if they are different
0: 		if (!prdid.equals(a.prdid))
0: 			return false;
0: 
0: 		// check server product release level
0: 		if (notEquals(srvrlslv, a.srvrlslv))
0: 			return false;
0: 
0: 		// check server names
0: 		if (notEquals(extnam, a.extnam))
0: 			return false;
0: 
0: 		if (notEquals(srvnam, a.srvnam))
0: 			return false;
0: 
0: 		if (notEquals(srvclsnm, a.srvclsnm))
0: 			return false;
0: 
0: 		if (notEquals(spvnam, a.spvnam))
0: 			return false;
0: 
0: 		// check manager levels
0: 		for (int i = 0; i < managerLevels.length; i++)
0: 			if (managerLevels[i] != a.managerLevels[i])
0: 				return false;
0: 
0: 		// O.K. looks good
0: 		return true;
0: 	}
0: 	/**
0: 	 * Check whether two objects are not equal when 1 of the objects could
0: 	 * be null
0: 	 *
0:  	 * @param a	first object
0: 	 * @param b second object
0: 	 * @return true if not equals false otherwise
0: 	 */
0: 	private boolean notEquals(Object a, Object b)
0: 	{
0: 		if (a != null && b == null)
0: 			return true;
0: 		if (a == null && b != null)
0: 			return true;
0: 		if (a != null && !a.equals(b))
0: 			return true;
0: 		return false;
0: 	}
0: 
0: 	/**
0: 	 * Get the maximum length supported for an exception's message
0: 	 * parameter string.
0: 	 */
0: 
0: 	protected int supportedMessageParamLength() {
0: 
0: 		switch (clientType) {
0: 
0: 			case JCC_CLIENT:
0: 				return DB2Limit.DB2_JCC_MAX_EXCEPTION_PARAM_LENGTH;
0: 			default:
0: 			// Default is the max for C clients, since that is more
0: 			// restricted than for JCC clients.  Note, though, that
0: 			// JCC clients are the only ones supported right now.
0: 				return DB2Limit.DB2_CCC_MAX_EXCEPTION_PARAM_LENGTH;
0: 
0: 		}
0: 
0: 	}
0: 
0: 	/**
0: 	 * Get the type of the client.
0: 	 */
0: 
0: 	protected int getClientType() {
0: 
0: 		return clientType;
0: 
0: 	}
0: 
0: }
============================================================================