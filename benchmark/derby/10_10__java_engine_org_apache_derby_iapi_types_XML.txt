5:099e28f: /*
48:099e28f: 
1:099e28f:    Derby - Class org.apache.derby.iapi.types.XML
1:099e28f: 
1:2431ece:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2431ece:    contributor license agreements.  See the NOTICE file distributed with
1:2431ece:    this work for additional information regarding copyright ownership.
1:2431ece:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2431ece:    (the "License"); you may not use this file except in compliance with
1:2431ece:    the License.  You may obtain a copy of the License at
1:099e28f: 
1:099e28f:       http://www.apache.org/licenses/LICENSE-2.0
1:099e28f: 
1:099e28f:    Unless required by applicable law or agreed to in writing, software
1:099e28f:    distributed under the License is distributed on an "AS IS" BASIS,
1:099e28f:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:099e28f:    See the License for the specific language governing permissions and
1:099e28f:    limitations under the License.
1:099e28f: 
10:099e28f:  */
1:099e28f: 
1:099e28f: package org.apache.derby.iapi.types;
1:099e28f: 
1:099e28f: import org.apache.derby.iapi.error.StandardException;
1:099e28f: 
1:099e28f: import org.apache.derby.iapi.services.cache.ClassSize;
1:099e28f: import org.apache.derby.iapi.services.io.ArrayInputStream;
1:099e28f: import org.apache.derby.iapi.services.io.StoredFormatIds;
1:099e28f: import org.apache.derby.iapi.services.io.StreamStorable;
1:6b50965: import org.apache.derby.iapi.services.io.Storable;
1:6b50965: import org.apache.derby.iapi.services.io.TypedFormat;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:27f9fd6: import org.apache.derby.iapi.sql.conn.ConnectionUtil;
1:099e28f: 
1:099e28f: import org.apache.derby.iapi.reference.SQLState;
1:099e28f: 
1:099e28f: import java.sql.ResultSet;
1:099e28f: import java.sql.SQLException;
1:099e28f: import java.sql.Types;
1:27f9fd6: import java.text.RuleBasedCollator;
1:099e28f: 
1:099e28f: import java.io.InputStream;
1:099e28f: import java.io.IOException;
1:099e28f: import java.io.ObjectOutput;
1:099e28f: import java.io.ObjectInput;
1:9f654e5: 
1:5283796: import java.util.List;
1:099e28f: 
7:099e28f: /**
1:099e28f:  * This type implements the XMLDataValue interface and thus is
1:099e28f:  * the type on which all XML related operations are executed.
1:9f654e5:  *
1:099e28f:  * The first and simplest XML store implementation is a UTF-8
1:099e28f:  * based one--all XML data is stored on disk as a UTF-8 string,
1:099e28f:  * just like the other Derby string types.  In order to make
1:099e28f:  * it possible for smarter XML implementations to exist in
1:099e28f:  * the future, this class always writes an "XML implementation
1:099e28f:  * id" to disk before writing the rest of its data.  When
1:099e28f:  * reading the data, the impl id is read first and serves
1:099e28f:  * as an indicator of how the rest of the data should be
1:099e28f:  * read.
1:1198ab7:  *
1:099e28f:  * So long as there's only one implementation (UTF-8)
1:099e28f:  * the impl id can be ignored; but when smarter implementations
1:099e28f:  * are written, the impl id will be the key to figuring out
1:099e28f:  * how an XML value should be read, written, and processed.
1:099e28f:  */
1:099e28f: public class XML
1:099e28f:     extends DataType implements XMLDataValue, StreamStorable
1:92268ac: {
1:099e28f:     // Id for this implementation.  Should be unique
1:099e28f:     // across all XML type implementations.
1:099e28f:     protected static final short UTF8_IMPL_ID = 0;
1:099e28f: 
1:099e28f:     // Guess at how much memory this type will take.
1:099e28f:     private static final int BASE_MEMORY_USAGE =
1:099e28f:         ClassSize.estimateBaseFromCatalog(XML.class);
1:099e28f: 
1:9f654e5:     // Some syntax-related constants used to determine
1:9f654e5:     // operator behavior.
1:9f654e5:     public static final short XQ_PASS_BY_REF = 1;
1:9f654e5:     public static final short XQ_PASS_BY_VALUE = 2;
1:9f654e5:     public static final short XQ_RETURN_SEQUENCE = 3;
1:9f654e5:     public static final short XQ_RETURN_CONTENT = 4;
1:9f654e5:     public static final short XQ_EMPTY_ON_EMPTY = 5;
1:9f654e5:     public static final short XQ_NULL_ON_EMPTY = 6;
1:9f654e5: 
1:9f654e5:     /* Per SQL/XML[2006] 4.2.2, there are several different
1:9f654e5:      * XML "types" defined through use of primary and secondary
1:9f654e5:      * "type modifiers".  For Derby we only support two kinds:
1:9f654e5:      *
1:9f654e5:      * XML(DOCUMENT(ANY)) : A valid and well-formed XML
1:9f654e5:      *  document as defined by W3C, meaning that there is
1:9f654e5:      *  exactly one root element node.  This is the only
1:9f654e5:      *  type of XML that can be stored into a Derby XML
1:9f654e5:      *  column.  This is also the type returned by a call
1:9f654e5:      *  to XMLPARSE since we require the DOCUMENT keyword.
1:9f654e5:      *
1:9f654e5:      * XML(SEQUENCE): A sequence of items (could be nodes or
1:9f654e5:      *  atomic values).  This is the type returned from an
1:9f654e5:      *  XMLQUERY operation.  Any node that is XML(DOCUMENT(ANY))
1:9f654e5:      *  is also XML(SEQUENCE).  Note that an XML(SEQUENCE)
1:9f654e5:      *  value is *only* storable into a Derby XML column
1:9f654e5:      *  if it is also an XML(DOCUMENT(ANY)).  See the
1:9f654e5:      *  normalize method below for the code that enforces
1:9f654e5:      *  this.
1:9f654e5:      */
1:9f654e5:     public static final int XML_DOC_ANY = 0;
1:9f654e5:     public static final int XML_SEQUENCE = 1;
1:9f654e5: 
1:9f654e5:     // The fully-qualified type for this XML value.
1:9f654e5:     private int xType;
1:24f43da: 
1:099e28f:     // The actual XML data in this implementation is just a simple
1:099e28f:     // string, so this class really just wraps a SQLChar and
1:099e28f:     // defers most calls to the corresponding calls on that
1:099e28f:     // SQLChar.  Note that, even though a SQLChar is the
1:099e28f:     // underlying implementation, an XML value is nonetheless
1:099e28f:     // NOT considered comparable nor compatible with any of
1:099e28f:     // Derby string types.
1:099e28f:     private SQLChar xmlStringValue;
1:099e28f: 
1:3bcc92e:     /*
1:3bcc92e:      * Status variable used to verify that user's classpath contains
1:3bcc92e:      * required classes for accessing/operating on XML data values.
1:6e7bbc8:      */
1:3bcc92e:     private static String xmlReqCheck = null;
1:099e28f: 
1:0c5a8eb:     /*
1:0c5a8eb:      * Whether or not this XML value corresponds to a sequence
1:0c5a8eb:      * that has one or more top-level ("parentless") attribute
1:0c5a8eb:      * nodes.  If so then we have to throw an error if the user
1:0c5a8eb:      * attempts to serialize this value, per XML serialization
1:0c5a8eb:      * rules.
1:0c5a8eb:      */
1:0c5a8eb:     private boolean containsTopLevelAttr;
1:0c5a8eb: 
1:1198ab7:     private SqlXmlUtil tmpUtil;
1:1198ab7: 
1:9f654e5:     /**
1:099e28f:      * Default constructor.
1:099e28f:      */
1:099e28f:     public XML()
1:92268ac:     {
1:099e28f:         xmlStringValue = null;
1:9f654e5:         xType = -1;
1:0c5a8eb:         containsTopLevelAttr = false;
1:9f654e5:     }
1:9f654e5: 
1:3bcc92e:     /**
1:854dd10:      * Private constructor used for the {@code cloneValue} method.
1:cfda298:      * Returns a new instance of XML whose fields are clones
1:cfda298:      * of the values received.
1:0c5a8eb:      *
1:9f654e5:      * @param val A SQLChar instance to clone and use for
1:9f654e5:      *  this XML value.
1:0c5a8eb:      * @param xmlType Qualified XML type for "val"
1:0c5a8eb:      * @param seqWithAttr Whether or not "val" corresponds to
1:0c5a8eb:      *  sequence with one or more top-level attribute nodes.
1:854dd10:      * @param materialize whether or not to force materialization of the
1:854dd10:      *      underlying source data
1:9f654e5:      */
1:854dd10:     private XML(SQLChar val, int xmlType, boolean seqWithAttr,
1:9495437:             boolean materialize) {
1:854dd10:         xmlStringValue = (val == null ? null
1:854dd10:                                       : (SQLChar)val.cloneValue(materialize));
1:9f654e5:         setXType(xmlType);
1:0c5a8eb:         if (seqWithAttr)
1:0c5a8eb:             markAsHavingTopLevelAttr();
22:099e28f:     }
1:099e28f: 
2:099e28f:     /* ****
1:099e28f:      * DataValueDescriptor interface.
2:099e28f:      * */
1:099e28f: 
1:9f654e5:     /**
1:854dd10:      * @see DataValueDescriptor#cloneValue
1:9f654e5:      */
1:9495437:     public DataValueDescriptor cloneValue(boolean forceMaterialization) {
1:854dd10:         return new XML(xmlStringValue, getXType(), hasTopLevelAttr(),
1:854dd10:                 forceMaterialization);
1:099e28f:     }
1:099e28f: 
1:6e7bbc8:     /**
1:099e28f:      * @see DataValueDescriptor#getNewNull
1:099e28f:      */
1:099e28f:     public DataValueDescriptor getNewNull()
1:9f654e5:     {
1:099e28f:         return new XML();
1:099e28f:     }
1:099e28f: 
1:099e28f:     /**
1:099e28f:      * @see DataValueDescriptor#getTypeName
1:099e28f:      */
1:099e28f:     public String getTypeName()
18:099e28f:     {
1:099e28f:         return TypeId.XML_NAME;
1:099e28f:     }
1:099e28f: 
1:099e28f:     /**
1:099e28f:      * @see DataValueDescriptor#typePrecedence
1:099e28f:      */
1:099e28f:     public int typePrecedence()
1:099e28f:     {
1:099e28f:         return TypeId.XML_PRECEDENCE;
1:099e28f:     }
1:099e28f: 
1:099e28f:     /**
1:099e28f:      * @see DataValueDescriptor#getString
1:099e28f:      */
1:099e28f:     public String getString() throws StandardException
1:099e28f:     {
1:099e28f:         return (xmlStringValue == null) ? null : xmlStringValue.getString();
1:099e28f:     }
1:099e28f: 
1:099e28f:     /**
1:099e28f:      * @see DataValueDescriptor#getLength
1:099e28f:      */
1:099e28f:     public int    getLength() throws StandardException
1:099e28f:     {
1:099e28f:         return ((xmlStringValue == null) ? 0 : xmlStringValue.getLength());
1:099e28f:     }
1:099e28f: 
1:099e28f:     /** 
1:099e28f:      * @see DataValueDescriptor#estimateMemoryUsage
1:099e28f:      */
1:099e28f:     public int estimateMemoryUsage()
1:099e28f:     {
1:099e28f:         int sz = BASE_MEMORY_USAGE;
1:099e28f:         if (xmlStringValue != null)
1:099e28f:             sz += xmlStringValue.estimateMemoryUsage();
1:099e28f:         return sz;
1:099e28f:     }
1:099e28f: 
1:099e28f:     /**
1:099e28f:      * @see DataValueDescriptor#readExternalFromArray
1:099e28f:      */
1:099e28f:     public void readExternalFromArray(ArrayInputStream in)
1:099e28f:         throws IOException
1:099e28f:     {
1:099e28f:         if (xmlStringValue == null)
1:099e28f:             xmlStringValue = new SQLChar();
1:1198ab7: 
1:099e28f:         // Read the XML implementation id.  Right now there's
1:099e28f:         // only one implementation (UTF-8 based), so we don't
1:099e28f:         // use this value.  But if better implementations come
1:099e28f:         // up in the future, we'll have to use this impl id to
1:099e28f:         // figure out how to read the data.
1:099e28f:         in.readShort();
1:1198ab7: 
1:099e28f:         // Now just read the XML data as UTF-8.
1:099e28f:         xmlStringValue.readExternalFromArray(in);
1:9f654e5: 
1:9f654e5:         // If we read it from disk then it must have type
1:9f654e5:         // XML_DOC_ANY because that's all we allow to be
1:9f654e5:         // written into an XML column.
1:9f654e5:         setXType(XML_DOC_ANY);
1:099e28f:     }
1:9f654e5: 
1:099e28f:     /**
1:bb67ebd:      * @see DataType#setFrom
1:099e28f:      */
1:099e28f:     protected void setFrom(DataValueDescriptor theValue)
1:92268ac:         throws StandardException
1:099e28f:     {
1:9f654e5:         String strVal = theValue.getString();
1:9f654e5:         if (strVal == null)
1:9f654e5:         {
1:9f654e5:             xmlStringValue = null;
1:3bcc92e: 
1:9f654e5:             // Null is a valid value for DOCUMENT(ANY)
1:9f654e5:             setXType(XML_DOC_ANY);
1:9f654e5:             return;
1:9f654e5:         }
1:9f654e5: 
1:9f654e5:         // Here we just store the received value locally.
1:099e28f:         if (xmlStringValue == null)
1:099e28f:             xmlStringValue = new SQLChar();
1:9f654e5:         xmlStringValue.setValue(strVal);
1:9f654e5: 
1:9f654e5:         /*
1:9f654e5:          * Assumption is that if theValue is not an XML
1:9f654e5:          * value then the caller is aware of whether or
1:9f654e5:          * not theValue constitutes a valid XML(DOCUMENT(ANY))
1:9f654e5:          * and will behave accordingly (see in particular the
1:9f654e5:          * XMLQuery method of this class, which calls the
1:9f654e5:          * setValue() method of XMLDataValue which in turn
1:9f654e5:          * brings us to this method).
1:5283796:          */
1:9f654e5:         if (theValue instanceof XMLDataValue)
1:0c5a8eb:         {
1:3bcc92e:             setXType(((XMLDataValue)theValue).getXType());
1:0c5a8eb:             if (((XMLDataValue)theValue).hasTopLevelAttr())
1:0c5a8eb:                 markAsHavingTopLevelAttr();
1:0c5a8eb:         }
1:099e28f:     }
1:1198ab7: 
1:5283796:     /** 
1:099e28f:      * @see DataValueDescriptor#setValueFromResultSet 
1:9f654e5:      */
1:099e28f:     public final void setValueFromResultSet(
1:099e28f:         ResultSet resultSet, int colNumber, boolean isNullable)
1:099e28f:         throws SQLException
1:099e28f:     {
1:099e28f:         if (xmlStringValue == null)
1:099e28f:             xmlStringValue = new SQLChar();
1:099e28f: 
1:1198ab7:         String valAsStr = resultSet.getString(colNumber);
1:1198ab7: 
1:1198ab7:         /* As there is no guarantee that the specified column within
1:1198ab7:          * resultSet is well-formed XML (is there??), we have to try
1:1198ab7:          * to parse it in order to set the "xType" field correctly.
1:1198ab7:          * This is required to ensure that we only store well-formed
1:1198ab7:          * XML on disk (see "normalize()" method of this class).  So
1:1198ab7:          * create an instance of SqlXmlUtil and use that to see if the
1:1198ab7:          * text satisifies the requirements of a well-formed DOCUMENT.
1:5283796:          *
1:1198ab7:          * RESOLVE: If there is anyway to guarantee that the column
1:1198ab7:          * is in fact well-formed XML then we can skip all of this
1:1198ab7:          * logic and simply set xType to XML_DOC_ANY.  But do we
1:1198ab7:          * have such a guarantee...?
1:1198ab7:          */
1:1198ab7:         if (tmpUtil == null)
1:1198ab7:         {
1:5283796:             try {
1:5283796: 
1:1198ab7:                 tmpUtil = new SqlXmlUtil();
1:5283796: 
1:1198ab7:             } catch (StandardException se) {
1:5283796: 
1:1198ab7:                 if (SanityManager.DEBUG)
1:1198ab7:                 {
1:1198ab7:                     SanityManager.THROWASSERT(
1:1198ab7:                         "Failed to instantiate SqlXmlUtil for XML parsing.");
1:1198ab7:                 }
1:5283796: 
1:1198ab7:                 /* If we failed to get a SqlXmlUtil then we can't parse
1:1198ab7:                  * the string, which means we don't know if it constitutes
1:1198ab7:                  * a well-formed XML document or not.  In this case we
1:1198ab7:                  * set the value, but intentionally leave xType as -1
1:1198ab7:                  * so that the resultant value canNOT be stored on disk.
1:1198ab7:                  */
1:1198ab7:                 xmlStringValue.setValue(valAsStr);
1:1198ab7:                 setXType(-1);
1:9f654e5:                 return;
1:1198ab7: 
1:1198ab7:             }
1:1198ab7:         }
1:1198ab7: 
1:1198ab7:         try {
1:1198ab7: 
1:1198ab7:             /* The following call parses the string into a DOM and
1:1198ab7:              * then serializes it, which is exactly what we do for
1:1198ab7:              * normal insertion of XML values.  If the parse finishes
1:1198ab7:              * with no error then we know the type is XML_DOC_ANY,
1:1198ab7:              * so set it.
1:1198ab7:              */
1:1198ab7:             valAsStr = tmpUtil.serializeToString(valAsStr);
1:1198ab7:             xmlStringValue.setValue(valAsStr);
1:1198ab7:             setXType(XML_DOC_ANY);
1:1198ab7: 
1:1198ab7:         } catch (Throwable t) {
1:1198ab7: 
1:1198ab7:             /* It's possible that the string value was either 1) an
1:1198ab7:              * XML SEQUENCE or 2) not XML at all.  We don't know
1:1198ab7:              * which one it was, so make xType invalid to ensure this
1:1198ab7:              * field doesn't end up on disk.
1:1198ab7:              */
1:1198ab7:             xmlStringValue.setValue(valAsStr);
1:1198ab7:             setXType(-1);
1:1198ab7: 
1:1198ab7:         }
1:099e28f:     }
1:1198ab7: 
1:099e28f:     /**
1:099e28f:      * Compare two XML DataValueDescriptors.  NOTE: This method
1:099e28f:      * should only be used by the database store for the purpose of
1:099e28f:      * index positioning--comparisons of XML type are not allowed
1:099e28f:      * from the language side of things.  That said, all store
1:099e28f:      * wants to do is order the NULLs, so we don't actually
1:099e28f:      * have to do a full comparison.  Just return an order
1:099e28f:      * value based on whether or not this XML value and the
1:099e28f:      * other XML value are null.  As mentioned in the "compare"
1:099e28f:      * method of DataValueDescriptor, nulls are considered
1:099e28f:      * equal to other nulls and less than all other values.
8:099e28f:      *
1:099e28f:      * An example of when this method might be used is if the
1:099e28f:      * user executed a query like:
1:099e28f:      *
1:099e28f:      * select i from x_table where x_col is not null
1:099e28f:      *
1:099e28f:      * @see DataValueDescriptor#compare
1:099e28f:      */
1:099e28f:     public int compare(DataValueDescriptor other)
1:92268ac:         throws StandardException
1:099e28f:     {
1:099e28f:         if (SanityManager.DEBUG) {
1:099e28f:             SanityManager.ASSERT(other instanceof XMLDataValue,
1:099e28f:                 "Store should NOT have tried to compare an XML value " +
1:099e28f:                 "with a non-XML value.");
1:099e28f:         }
1:1198ab7: 
1:099e28f:         if (isNull()) {
1:099e28f:             if (other.isNull())
1:099e28f:             // both null, so call them 'equal'.
1:099e28f:                 return 0;
1:099e28f:             // This XML is 'less than' the other.
1:099e28f:             return -1;
1:099e28f:         }
1:099e28f: 
1:099e28f:         if (other.isNull())
1:099e28f:         // This XML is 'greater than' the other.
1:099e28f:             return 1;
1:099e28f: 
1:099e28f:         // Two non-null values: we shouldn't ever get here,
1:099e28f:         // since that would necessitate a comparsion of XML
1:099e28f:         // values, which isn't allowed.
1:099e28f:         if (SanityManager.DEBUG) {
1:099e28f:             SanityManager.THROWASSERT(
1:099e28f:                 "Store tried to compare two non-null XML values, " +
1:099e28f:                 "which isn't allowed.");
1:099e28f:         }
1:099e28f:         return 0;
1:099e28f:     }
1:099e28f: 
1:9f654e5:     /**
1:9f654e5:      * Normalization method - this method will always be called when
1:9f654e5:      * storing an XML value into an XML column, for example, when
1:9f654e5:      * inserting/updating.  We always force normalization in this
1:9f654e5:      * case because we need to make sure the qualified type of the
1:9f654e5:      * value we're trying to store is XML_DOC_ANY--we don't allow
1:9f654e5:      * anything else.
1:9f654e5:      *
1:9f654e5:      * @param desiredType   The type to normalize the source column to
1:9f654e5:      * @param source        The value to normalize
1:9f654e5:      *
1:9f654e5:      * @exception StandardException Thrown if source is not
1:9f654e5:      *  XML_DOC_ANY.
1:9f654e5:      */
1:9f654e5:     public void normalize(
1:9f654e5:                 DataTypeDescriptor desiredType,
1:9f654e5:                 DataValueDescriptor source)
1:9f654e5:                     throws StandardException
1:9f654e5:     {
1:9f654e5:         if (SanityManager.DEBUG) {
1:9f654e5:             SanityManager.ASSERT(source instanceof XMLDataValue,
1:9f654e5:                 "Tried to store non-XML value into XML column; " +
1:9f654e5:                 "should have thrown error at compile time.");
1:9f654e5:         }
1:9f654e5: 
1:9f654e5:         if (((XMLDataValue)source).getXType() != XML_DOC_ANY) {
1:9f654e5:             throw StandardException.newException(
1:e185894:                 SQLState.LANG_NOT_AN_XML_DOCUMENT);
1:9f654e5:         }
1:9f654e5: 
1:9f654e5:         ((DataValueDescriptor) this).setValue(source);
1:3bcc92e:         return;
1:9f654e5: 
1:9f654e5:     }
1:9f654e5: 
1:099e28f:     /* ****
1:099e28f:      * Storable interface, implies Externalizable, TypedFormat
1:099e28f:      */
1:099e28f: 
1:099e28f:     /**
1:099e28f:      * @see TypedFormat#getTypeFormatId
1:099e28f:      *
1:099e28f:      * From the engine's perspective, all XML implementations share
1:099e28f:      * the same format id.
1:099e28f:      */
1:099e28f:     public int getTypeFormatId() {
1:099e28f:         return StoredFormatIds.XML_ID;
1:099e28f:     }
1:099e28f: 
1:099e28f:     /**
1:099e28f:      * @see Storable#isNull
1:099e28f:      */
1:099e28f:     public boolean isNull()
1:099e28f:     {
1:099e28f:         return ((xmlStringValue == null) || xmlStringValue.isNull());
1:099e28f:     }
1:099e28f: 
1:099e28f:     /**
1:099e28f:      * @see Storable#restoreToNull
1:099e28f:      */
1:099e28f:     public void restoreToNull()
1:099e28f:     {
1:099e28f:         if (xmlStringValue != null)
1:099e28f:             xmlStringValue.restoreToNull();
1:099e28f:     }
1:099e28f: 
1:099e28f:     /**
1:099e28f:      * Read an XML value from an input stream.
1:099e28f:      * @param in The stream from which we're reading.
1:099e28f:      */
1:099e28f:     public void readExternal(ObjectInput in) throws IOException
1:099e28f:     {
1:099e28f:         if (xmlStringValue == null)
1:099e28f:             xmlStringValue = new SQLChar();
1:099e28f: 
1:099e28f:         // Read the XML implementation id.  Right now there's
1:099e28f:         // only one implementation (UTF-8 based), so we don't
1:099e28f:         // use this value.  But if better implementations come
1:099e28f:         // up in the future, we'll have to use this impl id to
1:099e28f:         // figure out how to read the data.
1:099e28f:         in.readShort();
1:099e28f: 
1:099e28f:         // Now just read the XML data as UTF-8.
1:099e28f:         xmlStringValue.readExternal(in);
1:9f654e5: 
1:9f654e5:         // If we read it from disk then it must have type
1:9f654e5:         // XML_DOC_ANY because that's all we allow to be
1:9f654e5:         // written into an XML column.
1:9f654e5:         setXType(XML_DOC_ANY);
1:099e28f:     }
1:099e28f: 
1:099e28f:     /**
1:099e28f:      * Write an XML value. 
1:099e28f:      * @param out The stream to which we're writing.
1:099e28f:      */
1:099e28f:     public void writeExternal(ObjectOutput out) throws IOException
1:099e28f:     {
1:099e28f:         // never called when value is null
1:099e28f:         if (SanityManager.DEBUG)
1:099e28f:             SanityManager.ASSERT(!isNull());
1:099e28f: 
1:099e28f:         // Write out the XML store impl id.
1:099e28f:         out.writeShort(UTF8_IMPL_ID);
1:099e28f: 
1:099e28f:         // Now write out the data.
1:099e28f:         xmlStringValue.writeExternal(out);
1:099e28f:     }
1:099e28f: 
1:099e28f:     /* ****
1:099e28f:      * StreamStorable interface
1:099e28f:      * */
1:099e28f: 
1:099e28f:     /**
1:099e28f:      * @see StreamStorable#returnStream
1:099e28f:      */
1:099e28f:     public InputStream returnStream()
1:099e28f:     {
1:099e28f:         return
1:099e28f:             (xmlStringValue == null) ? null : xmlStringValue.returnStream();
1:099e28f:     }
1:099e28f: 
1:099e28f:     /**
1:099e28f:      * @see StreamStorable#setStream
1:099e28f:      */
1:099e28f:     public void setStream(InputStream newStream)
1:099e28f:     {
1:099e28f:         if (xmlStringValue == null)
1:099e28f:             xmlStringValue = new SQLChar();
1:099e28f: 
1:099e28f:         // The stream that we receive is for an XML data value,
1:099e28f:         // which means it has an XML implementation id stored
1:099e28f:         // at the front (we put it there when we wrote it out).
1:099e28f:         // If we leave that there we'll get a failure when
1:099e28f:         // our underlying SQLChar tries to read from the
1:099e28f:         // stream, because the extra impl id will throw
1:099e28f:         // off the UTF format.  So we need to read in (and
1:099e28f:         // ignore) the impl id before using the stream.
1:1198ab7:         try {
1:099e28f:             // 2 bytes equal a short, which is what an impl id is.
1:099e28f:             newStream.read();
1:099e28f:             newStream.read();
1:099e28f:         } catch (Exception e) {
1:099e28f:             if (SanityManager.DEBUG)
1:099e28f:                 SanityManager.THROWASSERT("Failed to read impl id" +
1:099e28f:                     "bytes in setStream.");
1:099e28f:         }
1:099e28f: 
1:099e28f:         // Now go ahead and use the stream.
1:099e28f:         xmlStringValue.setStream(newStream);
1:9f654e5: 
1:9f654e5:         // If we read it from disk then it must have type
1:9f654e5:         // XML_DOC_ANY because that's all we allow to be
1:9f654e5:         // written into an XML column.
1:9f654e5:         setXType(XML_DOC_ANY);
1:099e28f:     }
1:099e28f: 
1:099e28f:     /**
1:099e28f:      * @see StreamStorable#loadStream
1:099e28f:      */
1:099e28f:     public void loadStream() throws StandardException
1:099e28f:     {
1:099e28f:         getString();
1:099e28f:     }
1:099e28f: 
1:099e28f:     /* ****
1:099e28f:      * XMLDataValue interface.
1:099e28f:      * */
1:099e28f: 
1:099e28f:     /**
1:099e28f:      * Method to parse an XML string and, if it's valid,
1:6e7bbc8:      * store the _serialized_ version locally and then return
1:6e7bbc8:      * this XMLDataValue.
1:6e7bbc8:      *
1:d09782a:      * @param stringValue The string value to check.
1:099e28f:      * @param preserveWS Whether or not to preserve
1:099e28f:      *  ignorable whitespace.
1:6e7bbc8:      * @param sqlxUtil Contains SQL/XML objects and util
1:6e7bbc8:      *  methods that facilitate execution of XML-related
1:6e7bbc8:      *  operations
1:6e7bbc8:      * @return If 'text' constitutes a valid XML document,
1:6e7bbc8:      *  it has been stored in this XML value and this XML
1:6e7bbc8:      *  value is returned; otherwise, an exception is thrown. 
1:6e7bbc8:      * @exception StandardException Thrown on error.
1:099e28f:      */
1:d09782a:     public XMLDataValue XMLParse(
1:d09782a:             StringDataValue stringValue,
1:d09782a:             boolean preserveWS,
1:d09782a:             SqlXmlUtil sqlxUtil)
1:d09782a:         throws StandardException
1:099e28f:     {
1:d09782a:         if (stringValue.isNull()) {
1:d09782a:             setToNull();
1:d09782a:             return this;
1:d09782a:         }
1:d09782a: 
1:d09782a:         String text = stringValue.getString();
3:099e28f:         try {
1:099e28f: 
1:099e28f:             if (preserveWS) {
1:6e7bbc8:             // Currently the only way a user can view the contents of
1:6e7bbc8:             // an XML value is by explicitly calling XMLSERIALIZE.
1:6e7bbc8:             // So do a serialization now and just store the result,
1:6e7bbc8:             // so that we don't have to re-serialize every time a
1:6e7bbc8:             // call is made to XMLSERIALIZE.
1:6e7bbc8:                 text = sqlxUtil.serializeToString(text);
1:099e28f:             }
1:6e7bbc8:             else {
1:099e28f:             // We don't support this yet, so we shouldn't
1:099e28f:             // get here.
1:099e28f:                 if (SanityManager.DEBUG)
1:099e28f:                     SanityManager.THROWASSERT("Tried to STRIP whitespace " +
1:099e28f:                         "but we shouldn't have made it this far");
1:099e28f:             }
1:099e28f: 
1:f67c2ee:         } catch (Throwable t) {
1:f67c2ee:         /* Couldn't parse the XML document.  Throw a StandardException
1:f67c2ee:          * with the parse exception (or other error) nested in it.
1:f67c2ee:          * Note: we catch "Throwable" here to catch as many external
1:f67c2ee:          * errors as possible in order to minimize the chance of an
1:f67c2ee:          * uncaught JAXP/Xalan error (such as a NullPointerException)
1:f67c2ee:          * causing Derby to fail in a more serious way.  In particular,
1:f67c2ee:          * an uncaught Java exception like NPE can result in Derby
1:f67c2ee:          * throwing "ERROR 40XT0: An internal error was identified by
1:f67c2ee:          * RawStore module" for all statements on the connection after
1:f67c2ee:          * the failure--which we clearly don't want.  If we catch the
1:f67c2ee:          * error and wrap it, though, the statement will fail but Derby
1:f67c2ee:          * will continue to run as normal.
1:f67c2ee:          */ 
1:6e7bbc8:             throw StandardException.newException(
1:8cefbbc:                 SQLState.LANG_INVALID_XML_DOCUMENT, t, t.getMessage());
1:f67c2ee: 
1:099e28f:         }
1:099e28f: 
1:099e28f:         // If we get here, the text is valid XML so go ahead
1:099e28f:         // and load/store it.
1:9f654e5:         setXType(XML_DOC_ANY);
1:099e28f:         if (xmlStringValue == null)
1:099e28f:             xmlStringValue = new SQLChar();
1:099e28f:         xmlStringValue.setValue(text);
1:6e7bbc8:         return this;
1:099e28f:     }
1:099e28f: 
1:099e28f:     /**
1:099e28f:      * The SQL/XML XMLSerialize operator.
1:6e7bbc8:      * Serializes this XML value into a string with a user-specified
1:6e7bbc8:      * character type, and returns that string via the received
1:6e7bbc8:      * StringDataValue (if the received StringDataValue is non-null
1:6e7bbc8:      * and of the correct type; else, a new StringDataValue is
1:6e7bbc8:      * returned).
1:6e7bbc8:      *
1:099e28f:      * @param result The result of a previous call to this method,
1:099e28f:      *    null if not called yet.
1:099e28f:      * @param targetType The string type to which we want to serialize.
1:099e28f:      * @param targetWidth The width of the target type.
1:099e28f:      * @return A serialized (to string) version of this XML object,
1:099e28f:      *  in the form of a StringDataValue object.
1:099e28f:      * @exception StandardException    Thrown on error
1:099e28f:      */
1:099e28f:     public StringDataValue XMLSerialize(StringDataValue result,
1:27f9fd6:         int targetType, int targetWidth, int targetCollationType) 
1:27f9fd6:     throws StandardException
1:099e28f:     {
1:099e28f:         if (result == null) {
1:099e28f:             switch (targetType)
1:099e28f:             {
1:099e28f:                 case Types.CHAR:        result = new SQLChar(); break;
1:099e28f:                 case Types.VARCHAR:     result = new SQLVarchar(); break;
1:099e28f:                 case Types.LONGVARCHAR: result = new SQLLongvarchar(); break;
1:099e28f:                 case Types.CLOB:        result = new SQLClob(); break;
1:099e28f:                 default:
1:099e28f:                 // Shouldn't ever get here, as this check was performed
1:099e28f:                 // at bind time.
1:099e28f: 
1:099e28f:                     if (SanityManager.DEBUG) {
1:099e28f:                         SanityManager.THROWASSERT(
1:099e28f:                             "Should NOT have made it to XMLSerialize " +
1:6e7bbc8:                             "with a non-string target type: " + targetType);
1:099e28f:                     }
1:5283796:                     return null;
1:099e28f:             }
1:27f9fd6:             // If the collation type is territory based, then we should use
1:27f9fd6:             // CollatorSQLxxx rather than SQLxxx types for StringDataValue. 
1:27f9fd6:             // eg
1:27f9fd6:             // CREATE TABLE T_MAIN1 (ID INT  GENERATED ALWAYS AS IDENTITY 
1:27f9fd6:             //       PRIMARY KEY, V XML);
1:27f9fd6:             // INSERT INTO T_MAIN1(V) VALUES NULL;
1:27f9fd6:             // SELECT ID, XMLSERIALIZE(V AS CLOB), XMLSERIALIZE(V AS CLOB) 
1:27f9fd6:             //       FROM T_MAIN1 ORDER BY 1;
1:27f9fd6:             // Following code is for (V AS CLOB) inside XMLSERIALIZE. The
1:27f9fd6:             // StringDataValue returned for (V AS CLOB) should consider the 
1:27f9fd6:             // passed collation type in determining whether we should
1:27f9fd6:             // generate SQLChar vs CollatorSQLChar for instance. Keep in mind
1:27f9fd6:             // that collation applies only to character string types.
1:7f7477d:             try {
1:7f7477d:                 RuleBasedCollator rbs = ConnectionUtil.getCurrentLCC().getDataValueFactory().
1:7f7477d:                 getCharacterCollator(targetCollationType);
1:7f7477d:                 result = ((StringDataValue)result).getValue(rbs);
1:7f7477d:             }
1:7f7477d:             catch( java.sql.SQLException sqle)
1:7f7477d:             {
1:7f7477d:                 throw StandardException.plainWrapException( sqle);
1:7f7477d:             }
1:27f9fd6:         }
1:099e28f: 
1:099e28f:         // Else we're reusing a StringDataValue.  We only reuse
1:099e28f:         // the result if we're executing the _same_ XMLSERIALIZE
1:099e28f:         // call on multiple rows.  That means that all rows
1:099e28f:         // must have the same result type (targetType) and thus
1:099e28f:         // we know that the StringDataValue already has the
1:099e28f:         // correct type.  So we're set.
1:099e28f: 
1:099e28f:         if (this.isNull()) {
1:099e28f:         // Attempts to serialize a null XML value lead to a null
1:099e28f:         // result (SQL/XML[2003] section 10.13).
1:099e28f:             result.setToNull();
1:099e28f:             return result;
1:27f9fd6:         }
1:9f654e5: 
1:0c5a8eb:         /* XML serialization rules say that sequence "normalization"
1:0c5a8eb:          * must occur before serialization, and normalization dictates
1:0c5a8eb:          * that a serialization error must be thrown if the XML value
1:0c5a8eb:          * is a sequence with a top-level attribute.  We normalized
1:0c5a8eb:          * (and serialized) this XML value when it was first created,
1:0c5a8eb:          * and at that time we took note of whether or not there is
1:0c5a8eb:          * a top-level attribute.  So throw the error here if needed.
1:0c5a8eb:          * See SqlXmlUtil.serializeToString() for more on sequence
1:0c5a8eb:          * normalization.
1:0c5a8eb:          */
1:0c5a8eb:         if (this.hasTopLevelAttr())
1:0c5a8eb:         {
1:0c5a8eb:             throw StandardException.newException(
1:0c5a8eb:                 SQLState.LANG_XQUERY_SERIALIZATION_ERROR);
1:0c5a8eb:         }
1:0c5a8eb: 
1:099e28f:         // Get the XML value as a string.  For this UTF-8 impl,
1:6e7bbc8:         // we already have it as a UTF-8 string, so just use
1:6e7bbc8:         // that.
1:6e7bbc8:         result.setValue(getString());
1:099e28f: 
1:099e28f:         // Seems wrong to trunc an XML document, as it then becomes non-
1:099e28f:         // well-formed and thus useless.  So we throw an error (that's
1:099e28f:         // what the "true" in the next line says).
1:099e28f:         result.setWidth(targetWidth, 0, true);
1:099e28f:         return result;
1:27f9fd6:     }
1:099e28f: 
1:099e28f:     /**
1:099e28f:      * The SQL/XML XMLExists operator.
1:6e7bbc8:      * Checks to see if evaluation of the query expression contained
1:6e7bbc8:      * within the received util object against this XML value returns
1:6e7bbc8:      * at least one item. NOTE: For now, the query expression must be
1:6e7bbc8:      * XPath only (XQuery not supported) because that's what Xalan
1:6e7bbc8:      * supports.
1:6e7bbc8:      *
1:6e7bbc8:      * @param sqlxUtil Contains SQL/XML objects and util
1:6e7bbc8:      *  methods that facilitate execution of XML-related
1:6e7bbc8:      *  operations
1:6e7bbc8:      * @return True if evaluation of the query expression stored
1:6e7bbc8:      *  in sqlxUtil returns at least one node for this XML value;
1:6e7bbc8:      *  unknown if the xml value is NULL; false otherwise.
1:099e28f:      * @exception StandardException Thrown on error
1:099e28f:      */
1:6e7bbc8:     public BooleanDataValue XMLExists(SqlXmlUtil sqlxUtil)
1:6e7bbc8:         throws StandardException
1:27f9fd6:     {
1:6e7bbc8:         if (this.isNull()) {
1:6e7bbc8:         // if the user specified a context node and that context
1:6e7bbc8:         // is null, result of evaluating the query is null
1:6e7bbc8:         // (per SQL/XML 6.17:General Rules:1.a), which means that we
1:6e7bbc8:         // return "unknown" here (per SQL/XML 8.4:General Rules:2.a).
2:099e28f:             return SQLBoolean.unknownTruthValue();
1:6e7bbc8:         }
1:099e28f: 
1:6e7bbc8:         // Make sure we have a compiled query (and associated XML
1:6e7bbc8:         // objects) to evaluate.
1:6e7bbc8:         if (SanityManager.DEBUG) {
1:6e7bbc8:             SanityManager.ASSERT(
1:6e7bbc8:                 sqlxUtil != null,
1:6e7bbc8:                 "Tried to evaluate XML xquery, but no XML objects were loaded.");
1:6e7bbc8:         }
1:099e28f: 
1:27f9fd6:         try {
1:099e28f: 
1:9f654e5:             return new SQLBoolean(null !=
1:9f654e5:                 sqlxUtil.evalXQExpression(this, false, new int[1]));
1:f67c2ee: 
1:f67c2ee:         } catch (StandardException se) {
1:099e28f: 
1:f67c2ee:             // Just re-throw it.
1:f67c2ee:             throw se;
1:f67c2ee: 
1:f67c2ee:         } catch (Throwable xe) {
1:f67c2ee:         /* Failed somewhere during evaluation of the XML query expression;
1:f67c2ee:          * turn error into a StandardException and throw it.  Note: we
1:f67c2ee:          * catch "Throwable" here to catch as many Xalan-produced errors
1:f67c2ee:          * as possible in order to minimize the chance of an uncaught Xalan
1:f67c2ee:          * error (such as a NullPointerException) causing Derby to fail in
1:f67c2ee:          * a more serious way.  In particular, an uncaught Java exception
1:f67c2ee:          * like NPE can result in Derby throwing "ERROR 40XT0: An internal
1:f67c2ee:          * error was identified by RawStore module" for all statements on
1:f67c2ee:          * the connection after the failure--which we clearly don't want.  
1:f67c2ee:          * If we catch the error and wrap it, though, the statement will
1:f67c2ee:          * fail but Derby will continue to run as normal. 
1:f67c2ee:          */
1:f67c2ee:             throw StandardException.newException(
1:1ffa77b:                 SQLState.LANG_XML_QUERY_ERROR, xe,
1:8cefbbc:                 "XMLEXISTS", xe.getMessage());
1:6e7bbc8:         }
1:099e28f:     }
1:099e28f: 
1:099e28f:     /**
1:9f654e5:      * Evaluate the XML query expression contained within the received
1:9f654e5:      * util object against this XML value and store the results into
1:9f654e5:      * the received XMLDataValue "result" param (assuming "result" is
1:9f654e5:      * non-null; else create a new XMLDataValue).
1:9f654e5:      *
1:9f654e5:      * @param sqlxUtil Contains SQL/XML objects and util methods that
1:9f654e5:      *  facilitate execution of XML-related operations
1:d09782a:      * @param result The result of a previous call to this method; null
1:d09782a:      *  if not called yet.
1:9f654e5:      * @return An XMLDataValue whose content corresponds to the serialized
1:9f654e5:      *  version of the results from evaluation of the query expression.
1:9f654e5:      *  Note: this XMLDataValue may not be storable into Derby XML
1:9f654e5:      *  columns.
1:f668d94:      * @exception StandardException thrown on error
1:f67c2ee:      */
1:d09782a:     public XMLDataValue XMLQuery(SqlXmlUtil sqlxUtil, XMLDataValue result)
1:d09782a:             throws StandardException
1:9f654e5:     {
1:9f654e5:         if (this.isNull()) {
1:9f654e5:         // if the context is null, we return null,
1:9f654e5:         // per SQL/XML[2006] 6.17:GR.1.a.ii.1.
1:9f654e5:             if (result == null)
1:9f654e5:                 result = (XMLDataValue)getNewNull();
2:9f654e5:             else
1:9f654e5:                 result.setToNull();
1:9f654e5:             return result;
1:9f654e5:         }
1:9f654e5: 
1:9f654e5:         try {
1:9f654e5:  
1:9f654e5:             // Return an XML data value whose contents are the
1:9f654e5:             // serialized version of the query results.
1:9f654e5:             int [] xType = new int[1];
1:5283796:             List itemRefs = sqlxUtil.evalXQExpression(
1:9f654e5:                 this, true, xType);
1:9f654e5: 
1:9f654e5:             if (result == null)
1:0c5a8eb:                 result = new XML();
1:0c5a8eb:             String strResult = sqlxUtil.serializeToString(itemRefs, result);
1:0c5a8eb:             result.setValue(new SQLChar(strResult));
1:9f654e5: 
1:9f654e5:             // Now that we've set the result value, make sure
1:9f654e5:             // to indicate what kind of XML value we have.
1:9f654e5:             result.setXType(xType[0]);
1:9f654e5: 
1:9f654e5:             // And finally we return the query result as an XML value.
1:9f654e5:             return result;
1:9f654e5: 
1:9f654e5:         } catch (StandardException se) {
1:9f654e5: 
1:9f654e5:             // Just re-throw it.
1:9f654e5:             throw se;
1:9f654e5: 
1:f67c2ee:         } catch (Throwable xe) {
1:f67c2ee:         /* Failed somewhere during evaluation of the XML query expression;
1:f67c2ee:          * turn error into a StandardException and throw it.  Note: we
1:f67c2ee:          * catch "Throwable" here to catch as many Xalan-produced errors
1:f67c2ee:          * as possible in order to minimize the chance of an uncaught Xalan
1:f67c2ee:          * error (such as a NullPointerException) causing Derby to fail in
1:f67c2ee:          * a more serious way.  In particular, an uncaught Java exception
1:f67c2ee:          * like NPE can result in Derby throwing "ERROR 40XT0: An internal
1:f67c2ee:          * error was identified by RawStore module" for all statements on
1:f67c2ee:          * the connection after the failure--which we clearly don't want.  
1:f67c2ee:          * If we catch the error and wrap it, though, the statement will
1:f67c2ee:          * fail but Derby will continue to run as normal. 
1:099e28f:          */
1:9f654e5:             throw StandardException.newException(
1:1ffa77b:                 SQLState.LANG_XML_QUERY_ERROR, xe,
1:8cefbbc:                 "XMLQUERY", xe.getMessage());
1:9f654e5:         }
1:9f654e5:     }
1:9f654e5: 
1:9f654e5:     /* ****
1:9f654e5:      * Helper classes and methods.
1:9f654e5:      * */
1:9f654e5: 
1:9f654e5:     /**
1:9f654e5:      * Set this XML value's qualified type.
1:9f654e5:      */
1:9f654e5:     public void setXType(int xtype)
1:9f654e5:     {
1:9f654e5:         this.xType = xtype;
1:0c5a8eb: 
1:0c5a8eb:         /* If the target type is XML_DOC_ANY then this XML value
1:0c5a8eb:          * holds a single well-formed Document.  So we know that
1:0c5a8eb:          * we do NOT have any top-level attribute nodes.  Note: if
1:0c5a8eb:          * xtype is SEQUENCE we don't set "containsTopLevelAttr"
1:0c5a8eb:          * here; assumption is that the caller of this method will
1:0c5a8eb:          * then set the field as appropriate.  Ex. see "setFrom()"
1:0c5a8eb:          * in this class.
1:0c5a8eb:          */
1:0c5a8eb:         if (xtype == XML_DOC_ANY)
1:0c5a8eb:             containsTopLevelAttr = false;
1:9f654e5:     }
1:9f654e5: 
1:9f654e5:     /**
1:9f654e5:      * Retrieve this XML value's qualified type.
1:9f654e5:      */
1:9f654e5:     public int getXType()
1:9f654e5:     {
1:9f654e5:         return xType;
1:9f654e5:     }
1:9f654e5: 
1:099e28f:     /**
1:0c5a8eb:      * Take note of the fact this XML value represents an XML
1:0c5a8eb:      * sequence that has one or more top-level attribute nodes.
1:0c5a8eb:      */
1:0c5a8eb:     public void markAsHavingTopLevelAttr()
1:0c5a8eb:     {
1:0c5a8eb:         this.containsTopLevelAttr = true;
1:0c5a8eb:     }
1:0c5a8eb: 
1:0c5a8eb:     /**
1:0c5a8eb:      * Return whether or not this XML value represents a sequence
1:0c5a8eb:      * that has one or more top-level attribute nodes.
1:0c5a8eb:      */
1:0c5a8eb:     public boolean hasTopLevelAttr()
1:0c5a8eb:     {
1:0c5a8eb:         return containsTopLevelAttr;
1:0c5a8eb:     }
1:0c5a8eb: 
1:0c5a8eb:     /**
1:3bcc92e:      * See if the required JAXP and Xalan classes are in the
1:3bcc92e:      * user's classpath.  Assumption is that we will always
1:3bcc92e:      * call this method before instantiating an instance of
1:3bcc92e:      * SqlXmlUtil, and thus we will never get a ClassNotFound
1:3bcc92e:      * exception caused by missing JAXP/Xalan classes.  Instead,
1:3bcc92e:      * if either is missing we should throw an informative
1:3bcc92e:      * error indicating what the problem is.
1:3bcc92e:      *
1:3bcc92e:      * NOTE: This method only does the checks necessary to
1:3bcc92e:      * allow successful instantiation of the SqlXmlUtil
1:3bcc92e:      * class.  Further checks (esp. the presence of a JAXP
1:3bcc92e:      * _implementation_ in addition to the JAXP _interfaces_)
1:3bcc92e:      * are performed in the SqlXmlUtil constructor.
1:3bcc92e:      *
1:3bcc92e:      * @exception StandardException thrown if the required
1:3bcc92e:      *  classes cannot be located in the classpath.
1:3bcc92e:      */
1:3bcc92e:     public static void checkXMLRequirements()
1:3bcc92e:         throws StandardException
1:3bcc92e:     {
1:3bcc92e:         // Only check once; after that, just re-use the result.
1:3bcc92e:         if (xmlReqCheck == null)
1:3bcc92e:         {
1:3bcc92e:             xmlReqCheck = "";
1:3bcc92e: 
1:1ffa77b:             /* If the DocumentBuilderFactory class exists, then we
1:3bcc92e:              * assume a JAXP implementation is present in
1:3bcc92e:              * the classpath.  If this assumption is incorrect
1:3bcc92e:              * then we at least know that the JAXP *interface*
1:3bcc92e:              * exists and thus we'll be able to instantiate
1:3bcc92e:              * the SqlXmlUtil class.  We can then do a check
1:3bcc92e:              * for an actual JAXP *implementation* from within
1:3bcc92e:              * the SqlXmlUtil class (see the constructor of
1:3bcc92e:              * that class).
1:3bcc92e:              *
1:3bcc92e:              * Note: The JAXP API and implementation are
1:3bcc92e:              * provided as part the JVM if it is jdk 1.4 or
1:3bcc92e:              * greater.
1:3bcc92e:              */
1:1ffa77b:             if (!checkJAXPRequirement()) {
1:3bcc92e:                 xmlReqCheck = "JAXP";
1:1ffa77b:             }
1:3bcc92e: 
1:1ffa77b:             /* If the XPathFactory class exists, then we assume that
1:1ffa77b:              * our XML query processor is present in the classpath.
1:3bcc92e:              */
1:1ffa77b:             else if (!checkXPathRequirement()) {
1:1ffa77b:                 xmlReqCheck = "XPath";
1:1ffa77b:             }
1:3bcc92e:         }
1:3bcc92e: 
1:3bcc92e:         if (xmlReqCheck.length() != 0)
1:3bcc92e:         {
1:3bcc92e:             throw StandardException.newException(
1:3bcc92e:                 SQLState.LANG_MISSING_XML_CLASSES, xmlReqCheck);
1:3bcc92e:         }
1:3bcc92e:     }
1:3bcc92e: 
1:099e28f:     /**
1:5283796:      * Check if we have a JAXP implementation installed.
1:099e28f:      *
1:1ffa77b:      * @return {@code true} if JAXP is installed, or {@code false} otherwise
1:099e28f:      */
1:1ffa77b:     private static boolean checkJAXPRequirement() {
1:099e28f:         try {
1:1ffa77b:             Class.forName("javax.xml.parsers.DocumentBuilderFactory");
1:1ffa77b:             return true;
1:5283796:         } catch (Throwable t) {
1:1ffa77b:             // Oops... Couldn't load the DocumentBuilderFactory class for
1:5283796:             // some reason. Assume we don't have JAXP.
1:1ffa77b:             return false;
1:5283796:         }
1:5283796:     }
1:5283796: 
1:5283796:     /**
1:1ffa77b:      * Check if XPath is supported on this platform.
1:5283796:      *
1:1ffa77b:      * @return {@code true} if XPath is supported, or {@code false} otherwise
1:5283796:      */
1:1ffa77b:     private static boolean checkXPathRequirement() {
1:5283796:         try {
1:1ffa77b:             Class.forName("javax.xml.xpath.XPathFactory");
1:1ffa77b:             return true;
1:5283796:         } catch (Throwable t) {
1:5283796:             // Oops... Something went wrong when checking for XPath
1:1ffa77b:             // support. Assume we don't have it.
1:5283796:             return false;
1:5283796:         }
1:5283796:     }
1:099e28f: }
============================================================================
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:1ffa77b
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 SQLState.LANG_XML_QUERY_ERROR, xe,
/////////////////////////////////////////////////////////////////////////
1:                 SQLState.LANG_XML_QUERY_ERROR, xe,
/////////////////////////////////////////////////////////////////////////
1:             /* If the DocumentBuilderFactory class exists, then we
/////////////////////////////////////////////////////////////////////////
1:             if (!checkJAXPRequirement()) {
1:             }
1:             /* If the XPathFactory class exists, then we assume that
1:              * our XML query processor is present in the classpath.
1:             else if (!checkXPathRequirement()) {
1:                 xmlReqCheck = "XPath";
1:             }
/////////////////////////////////////////////////////////////////////////
1:      * @return {@code true} if JAXP is installed, or {@code false} otherwise
1:     private static boolean checkJAXPRequirement() {
1:             Class.forName("javax.xml.parsers.DocumentBuilderFactory");
1:             return true;
1:             // Oops... Couldn't load the DocumentBuilderFactory class for
1:             return false;
1:      * Check if XPath is supported on this platform.
1:      * @return {@code true} if XPath is supported, or {@code false} otherwise
1:     private static boolean checkXPathRequirement() {
1:             Class.forName("javax.xml.xpath.XPathFactory");
1:             return true;
1:             // support. Assume we don't have it.
commit:f668d94
/////////////////////////////////////////////////////////////////////////
1:      * @exception StandardException thrown on error
commit:d09782a
/////////////////////////////////////////////////////////////////////////
1:      * @param stringValue The string value to check.
/////////////////////////////////////////////////////////////////////////
1:     public XMLDataValue XMLParse(
1:             StringDataValue stringValue,
1:             boolean preserveWS,
1:             SqlXmlUtil sqlxUtil)
1:         throws StandardException
1:         if (stringValue.isNull()) {
1:             setToNull();
1:             return this;
1:         }
1: 
1:         String text = stringValue.getString();
/////////////////////////////////////////////////////////////////////////
1:      * @param result The result of a previous call to this method; null
1:      *  if not called yet.
/////////////////////////////////////////////////////////////////////////
1:     public XMLDataValue XMLQuery(SqlXmlUtil sqlxUtil, XMLDataValue result)
1:             throws StandardException
commit:5283796
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import java.lang.reflect.Method;
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
1:             List itemRefs = sqlxUtil.evalXQExpression(
/////////////////////////////////////////////////////////////////////////
0:             Object docImpl = checkJAXPRequirement();
0:             if (docImpl == null)
/////////////////////////////////////////////////////////////////////////
0:             else if (!checkXPathRequirement(docImpl))
0:                 xmlReqCheck = "XPath 3.0";
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Check if we have a JAXP implementation installed.
1:      *
0:      * @return a {@code DOMImplementation} object retrieved from the
0:      * JAXP implementation, if one is installed, or {@code null} if an
0:      * implementation couldn't be found
1:      */
0:     private static Object checkJAXPRequirement() {
1:         try {
0:             Class factoryClass =
0:                     Class.forName("javax.xml.parsers.DocumentBuilderFactory");
0:             Method newFactory = factoryClass.getMethod(
0:                     "newInstance", new Class[0]);
0:             Method newBuilder = factoryClass.getMethod(
0:                     "newDocumentBuilder", new Class[0]);
1: 
0:             Class builderClass =
0:                     Class.forName("javax.xml.parsers.DocumentBuilder");
0:             Method getImpl = builderClass.getMethod(
0:                     "getDOMImplementation", new Class[0]);
1: 
0:             Object factory = newFactory.invoke(null, new Object[0]);
0:             Object builder = newBuilder.invoke(factory, new Object[0]);
0:             Object impl = getImpl.invoke(builder, new Object[0]);
1: 
0:             return impl;
1: 
1:         } catch (Throwable t) {
0:             // Oops... Couldn't get a DOMImplementation object for
1:             // some reason. Assume we don't have JAXP.
1:             return null;
1:         }
1:     }
1: 
1:     /**
0:      * Check if the supplied {@code DOMImplementation} object has
0:      * support for DOM Level 3 XPath.
1:      *
0:      * @param domImpl the {@code DOMImplementation} instance to check
0:      * @return {@code true} if the required XPath level is supported,
0:      * {@code false} otherwise
1:      */
0:     private static boolean checkXPathRequirement(Object domImpl) {
1:         try {
0:             Class domImplClass = Class.forName("org.w3c.dom.DOMImplementation");
0:             Method getFeature = domImplClass.getMethod(
0:                     "getFeature", new Class[] {String.class, String.class});
0:             Object impl =
0:                     getFeature.invoke(domImpl, new Object[] {"+XPath", "3.0"});
0:             return impl != null;
1:         } catch (Throwable t) {
1:             // Oops... Something went wrong when checking for XPath
0:             // 3.0 support. Assume we don't have it.
1:             return false;
1:         }
1:     }
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
commit:0c5a8eb
/////////////////////////////////////////////////////////////////////////
1:     /*
1:      * Whether or not this XML value corresponds to a sequence
1:      * that has one or more top-level ("parentless") attribute
1:      * nodes.  If so then we have to throw an error if the user
1:      * attempts to serialize this value, per XML serialization
1:      * rules.
1:      */
1:     private boolean containsTopLevelAttr;
1: 
/////////////////////////////////////////////////////////////////////////
1:         containsTopLevelAttr = false;
1:      *
1:      * @param xmlType Qualified XML type for "val"
1:      * @param seqWithAttr Whether or not "val" corresponds to
1:      *  sequence with one or more top-level attribute nodes.
0:      * @return A new instance of XML whose fields are clones
0:      *  of the values received.
0:     private XML(SQLChar val, int xmlType, boolean seqWithAttr)
1:         if (seqWithAttr)
1:             markAsHavingTopLevelAttr();
/////////////////////////////////////////////////////////////////////////
0:         return new XML(xmlStringValue, getXType(), hasTopLevelAttr());
/////////////////////////////////////////////////////////////////////////
1:         {
1:             if (((XMLDataValue)theValue).hasTopLevelAttr())
1:                 markAsHavingTopLevelAttr();
1:         }
/////////////////////////////////////////////////////////////////////////
1:         /* XML serialization rules say that sequence "normalization"
1:          * must occur before serialization, and normalization dictates
1:          * that a serialization error must be thrown if the XML value
1:          * is a sequence with a top-level attribute.  We normalized
1:          * (and serialized) this XML value when it was first created,
1:          * and at that time we took note of whether or not there is
1:          * a top-level attribute.  So throw the error here if needed.
1:          * See SqlXmlUtil.serializeToString() for more on sequence
1:          * normalization.
1:          */
1:         if (this.hasTopLevelAttr())
1:         {
1:             throw StandardException.newException(
1:                 SQLState.LANG_XQUERY_SERIALIZATION_ERROR);
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1:                 result = new XML();
1:             String strResult = sqlxUtil.serializeToString(itemRefs, result);
1:             result.setValue(new SQLChar(strResult));
/////////////////////////////////////////////////////////////////////////
1: 
1:         /* If the target type is XML_DOC_ANY then this XML value
1:          * holds a single well-formed Document.  So we know that
1:          * we do NOT have any top-level attribute nodes.  Note: if
1:          * xtype is SEQUENCE we don't set "containsTopLevelAttr"
1:          * here; assumption is that the caller of this method will
1:          * then set the field as appropriate.  Ex. see "setFrom()"
1:          * in this class.
1:          */
1:         if (xtype == XML_DOC_ANY)
1:             containsTopLevelAttr = false;
/////////////////////////////////////////////////////////////////////////
1:      * Take note of the fact this XML value represents an XML
1:      * sequence that has one or more top-level attribute nodes.
1:      */
1:     public void markAsHavingTopLevelAttr()
1:     {
1:         this.containsTopLevelAttr = true;
1:     }
1: 
1:     /**
1:      * Return whether or not this XML value represents a sequence
1:      * that has one or more top-level attribute nodes.
1:      */
1:     public boolean hasTopLevelAttr()
1:     {
1:         return containsTopLevelAttr;
1:     }
1: 
1:     /**
commit:f67c2ee
/////////////////////////////////////////////////////////////////////////
1:         } catch (Throwable t) {
1:         /* Couldn't parse the XML document.  Throw a StandardException
1:          * with the parse exception (or other error) nested in it.
1:          * Note: we catch "Throwable" here to catch as many external
1:          * errors as possible in order to minimize the chance of an
1:          * uncaught JAXP/Xalan error (such as a NullPointerException)
1:          * causing Derby to fail in a more serious way.  In particular,
1:          * an uncaught Java exception like NPE can result in Derby
1:          * throwing "ERROR 40XT0: An internal error was identified by
1:          * RawStore module" for all statements on the connection after
1:          * the failure--which we clearly don't want.  If we catch the
1:          * error and wrap it, though, the statement will fail but Derby
1:          * will continue to run as normal.
1:          */ 
0:                 SQLState.LANG_INVALID_XML_DOCUMENT, t);
1: 
/////////////////////////////////////////////////////////////////////////
1:         } catch (StandardException se) {
1: 
1:             // Just re-throw it.
1:             throw se;
1: 
1:         } catch (Throwable xe) {
1:         /* Failed somewhere during evaluation of the XML query expression;
1:          * turn error into a StandardException and throw it.  Note: we
1:          * catch "Throwable" here to catch as many Xalan-produced errors
1:          * as possible in order to minimize the chance of an uncaught Xalan
1:          * error (such as a NullPointerException) causing Derby to fail in
1:          * a more serious way.  In particular, an uncaught Java exception
1:          * like NPE can result in Derby throwing "ERROR 40XT0: An internal
1:          * error was identified by RawStore module" for all statements on
1:          * the connection after the failure--which we clearly don't want.  
1:          * If we catch the error and wrap it, though, the statement will
1:          * fail but Derby will continue to run as normal. 
1:          */
1:             throw StandardException.newException(
0:                 SQLState.LANG_XML_QUERY_ERROR, xe, "XMLEXISTS");
/////////////////////////////////////////////////////////////////////////
1:         } catch (Throwable xe) {
1:         /* Failed somewhere during evaluation of the XML query expression;
1:          * turn error into a StandardException and throw it.  Note: we
1:          * catch "Throwable" here to catch as many Xalan-produced errors
1:          * as possible in order to minimize the chance of an uncaught Xalan
1:          * error (such as a NullPointerException) causing Derby to fail in
1:          * a more serious way.  In particular, an uncaught Java exception
1:          * like NPE can result in Derby throwing "ERROR 40XT0: An internal
1:          * error was identified by RawStore module" for all statements on
1:          * the connection after the failure--which we clearly don't want.  
1:          * If we catch the error and wrap it, though, the statement will
1:          * fail but Derby will continue to run as normal. 
1:          */
commit:e185894
/////////////////////////////////////////////////////////////////////////
1:                 SQLState.LANG_NOT_AN_XML_DOCUMENT);
/////////////////////////////////////////////////////////////////////////
0:                 SQLState.LANG_INVALID_XML_DOCUMENT, xe);
/////////////////////////////////////////////////////////////////////////
0:         // Failed somewhere during evaluation of the XML query expression;
0:         // turn error into a StandardException and throw it.
0:                     SQLState.LANG_XML_QUERY_ERROR, xe, "XMLEXISTS");
/////////////////////////////////////////////////////////////////////////
0:         // Failed somewhere during evaluation of the XML query expression;
0:         // turn error into a StandardException and throw it.
0:                 SQLState.LANG_XML_QUERY_ERROR, xe, "XMLQUERY");
commit:3bcc92e
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.services.loader.ClassInspector;
/////////////////////////////////////////////////////////////////////////
1:     /*
1:      * Status variable used to verify that user's classpath contains
1:      * required classes for accessing/operating on XML data values.
1:     private static String xmlReqCheck = null;
/////////////////////////////////////////////////////////////////////////
1:             setXType(((XMLDataValue)theValue).getXType());
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * See if the required JAXP and Xalan classes are in the
1:      * user's classpath.  Assumption is that we will always
1:      * call this method before instantiating an instance of
1:      * SqlXmlUtil, and thus we will never get a ClassNotFound
1:      * exception caused by missing JAXP/Xalan classes.  Instead,
1:      * if either is missing we should throw an informative
1:      * error indicating what the problem is.
1:      *
1:      * NOTE: This method only does the checks necessary to
1:      * allow successful instantiation of the SqlXmlUtil
1:      * class.  Further checks (esp. the presence of a JAXP
1:      * _implementation_ in addition to the JAXP _interfaces_)
1:      * are performed in the SqlXmlUtil constructor.
1:      *
1:      * @exception StandardException thrown if the required
1:      *  classes cannot be located in the classpath.
1:      */
1:     public static void checkXMLRequirements()
1:         throws StandardException
1:     {
1:         // Only check once; after that, just re-use the result.
1:         if (xmlReqCheck == null)
1:         {
1:             xmlReqCheck = "";
1: 
0:             /* If the w3c Document class exists, then we
1:              * assume a JAXP implementation is present in
1:              * the classpath.  If this assumption is incorrect
1:              * then we at least know that the JAXP *interface*
1:              * exists and thus we'll be able to instantiate
1:              * the SqlXmlUtil class.  We can then do a check
1:              * for an actual JAXP *implementation* from within
1:              * the SqlXmlUtil class (see the constructor of
1:              * that class).
1:              *
1:              * Note: The JAXP API and implementation are
1:              * provided as part the JVM if it is jdk 1.4 or
1:              * greater.
1:              */
0:             if (!ClassInspector.classIsLoadable("org.w3c.dom.Document"))
1:                 xmlReqCheck = "JAXP";
1: 
0:             /* If the XPath class exists, then we assume that our XML
0:              * query processor (in this case, Xalan), is present in the
0:              * classpath.  Note: if JAXP API classes aren't present
0:              * then the following check will return false even if the
0:              * Xalan classes *are* present; this is because the Xalan
0:              * XPath class relies on JAXP, as well.  Thus there's no
0:              * point in checking for Xalan unless we've already confirmed
0:              * that we have the JAXP interfaces.
1:              */
0:             else if (!ClassInspector.classIsLoadable("org.apache.xpath.XPath"))
0:                 xmlReqCheck = "Xalan";
1:         }
1: 
1:         if (xmlReqCheck.length() != 0)
1:         {
1:             throw StandardException.newException(
1:                 SQLState.LANG_MISSING_XML_CLASSES, xmlReqCheck);
1:         }
1: 
1:         return;
1:     }
1: 
commit:9f654e5
/////////////////////////////////////////////////////////////////////////
0: import java.util.ArrayList;
1: 
/////////////////////////////////////////////////////////////////////////
1:     // Some syntax-related constants used to determine
1:     // operator behavior.
1:     public static final short XQ_PASS_BY_REF = 1;
1:     public static final short XQ_PASS_BY_VALUE = 2;
1:     public static final short XQ_RETURN_SEQUENCE = 3;
1:     public static final short XQ_RETURN_CONTENT = 4;
1:     public static final short XQ_EMPTY_ON_EMPTY = 5;
1:     public static final short XQ_NULL_ON_EMPTY = 6;
1: 
1:     /* Per SQL/XML[2006] 4.2.2, there are several different
1:      * XML "types" defined through use of primary and secondary
1:      * "type modifiers".  For Derby we only support two kinds:
1:      *
1:      * XML(DOCUMENT(ANY)) : A valid and well-formed XML
1:      *  document as defined by W3C, meaning that there is
1:      *  exactly one root element node.  This is the only
1:      *  type of XML that can be stored into a Derby XML
1:      *  column.  This is also the type returned by a call
1:      *  to XMLPARSE since we require the DOCUMENT keyword.
1:      *
1:      * XML(SEQUENCE): A sequence of items (could be nodes or
1:      *  atomic values).  This is the type returned from an
1:      *  XMLQUERY operation.  Any node that is XML(DOCUMENT(ANY))
1:      *  is also XML(SEQUENCE).  Note that an XML(SEQUENCE)
1:      *  value is *only* storable into a Derby XML column
1:      *  if it is also an XML(DOCUMENT(ANY)).  See the
1:      *  normalize method below for the code that enforces
1:      *  this.
1:      */
1:     public static final int XML_DOC_ANY = 0;
1:     public static final int XML_SEQUENCE = 1;
1: 
1:     // The fully-qualified type for this XML value.
1:     private int xType;
/////////////////////////////////////////////////////////////////////////
1:         xType = -1;
/////////////////////////////////////////////////////////////////////////
0:         xType = -1;
1:     }
1: 
1:     /**
0:      * Private constructor used for the getClone() method.
0:      * Takes a SQLChar and clones it and also takes a
0:      * qualified XML type and stores that as this XML
0:      * object's qualified type.
1:      * @param val A SQLChar instance to clone and use for
1:      *  this XML value.
0:      * @param qualXType Qualified XML type.
1:      */
0:     private XML(SQLChar val, int xmlType)
1:     {
0:         xmlStringValue = (val == null ? null : (SQLChar)val.getClone());
1:         setXType(xmlType);
/////////////////////////////////////////////////////////////////////////
0:         return new XML(xmlStringValue, getXType());
/////////////////////////////////////////////////////////////////////////
1: 
1:         // If we read it from disk then it must have type
1:         // XML_DOC_ANY because that's all we allow to be
1:         // written into an XML column.
1:         setXType(XML_DOC_ANY);
0:      * @see DataValueDescriptor#setFrom
1:      *
0:      * Note: 
1:         String strVal = theValue.getString();
1:         if (strVal == null)
1:         {
1:             xmlStringValue = null;
1: 
1:             // Null is a valid value for DOCUMENT(ANY)
1:             setXType(XML_DOC_ANY);
1:             return;
1:         }
1: 
1:         // Here we just store the received value locally.
1:         xmlStringValue.setValue(strVal);
1: 
1:         /*
1:          * Assumption is that if theValue is not an XML
1:          * value then the caller is aware of whether or
1:          * not theValue constitutes a valid XML(DOCUMENT(ANY))
1:          * and will behave accordingly (see in particular the
1:          * XMLQuery method of this class, which calls the
1:          * setValue() method of XMLDataValue which in turn
1:          * brings us to this method).
1:          */
1:         if (theValue instanceof XMLDataValue)
0:         	setXType(((XMLDataValue)theValue).getXType());
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Normalization method - this method will always be called when
1:      * storing an XML value into an XML column, for example, when
1:      * inserting/updating.  We always force normalization in this
1:      * case because we need to make sure the qualified type of the
1:      * value we're trying to store is XML_DOC_ANY--we don't allow
1:      * anything else.
1:      *
1:      * @param desiredType   The type to normalize the source column to
1:      * @param source        The value to normalize
1:      *
1:      * @exception StandardException Thrown if source is not
1:      *  XML_DOC_ANY.
1:      */
1:     public void normalize(
1:                 DataTypeDescriptor desiredType,
1:                 DataValueDescriptor source)
1:                     throws StandardException
1:     {
1:         if (SanityManager.DEBUG) {
1:             SanityManager.ASSERT(source instanceof XMLDataValue,
1:                 "Tried to store non-XML value into XML column; " +
1:                 "should have thrown error at compile time.");
1:         }
1: 
1:         if (((XMLDataValue)source).getXType() != XML_DOC_ANY) {
1:             throw StandardException.newException(
0:                 SQLState.LANG_INVALID_XML_COLUMN_ASSIGN);
1:         }
1: 
1:         ((DataValueDescriptor) this).setValue(source);
1:         return;
1: 
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:         // If we read it from disk then it must have type
1:         // XML_DOC_ANY because that's all we allow to be
1:         // written into an XML column.
1:         setXType(XML_DOC_ANY);
/////////////////////////////////////////////////////////////////////////
1: 
1:         // If we read it from disk then it must have type
1:         // XML_DOC_ANY because that's all we allow to be
1:         // written into an XML column.
1:         setXType(XML_DOC_ANY);
/////////////////////////////////////////////////////////////////////////
1:         setXType(XML_DOC_ANY);
/////////////////////////////////////////////////////////////////////////
1:             return new SQLBoolean(null !=
1:                 sqlxUtil.evalXQExpression(this, false, new int[1]));
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Evaluate the XML query expression contained within the received
1:      * util object against this XML value and store the results into
1:      * the received XMLDataValue "result" param (assuming "result" is
1:      * non-null; else create a new XMLDataValue).
1:      *
0:      * @param result The result of a previous call to this method; null
0:      *  if not called yet.
1:      * @param sqlxUtil Contains SQL/XML objects and util methods that
1:      *  facilitate execution of XML-related operations
1:      * @return An XMLDataValue whose content corresponds to the serialized
1:      *  version of the results from evaluation of the query expression.
1:      *  Note: this XMLDataValue may not be storable into Derby XML
1:      *  columns.
0:      * @exception Exception thrown on error (and turned into a
0:      *  StandardException by the caller).
1:      */
0:     public XMLDataValue XMLQuery(XMLDataValue result,
0:         SqlXmlUtil sqlxUtil) throws StandardException
1:     {
1:         if (this.isNull()) {
1:         // if the context is null, we return null,
1:         // per SQL/XML[2006] 6.17:GR.1.a.ii.1.
1:             if (result == null)
1:                 result = (XMLDataValue)getNewNull();
1:             else
1:                 result.setToNull();
1:             return result;
1:         }
1: 
1:         try {
1:  
1:             // Return an XML data value whose contents are the
1:             // serialized version of the query results.
1:             int [] xType = new int[1];
0:             ArrayList itemRefs = sqlxUtil.evalXQExpression(
1:                 this, true, xType);
1: 
0:             String strResult = sqlxUtil.serializeToString(itemRefs);
1:             if (result == null)
0:                 result = new XML(new SQLChar(strResult));
1:             else
0:                 result.setValue(new SQLChar(strResult));
1: 
1:             // Now that we've set the result value, make sure
1:             // to indicate what kind of XML value we have.
1:             result.setXType(xType[0]);
1: 
1:             // And finally we return the query result as an XML value.
1:             return result;
1: 
1:         } catch (StandardException se) {
1: 
1:             // Just re-throw it.
1:             throw se;
1: 
0:         } catch (Exception xe) {
0:         // We don't expect to get here.  Turn it into a
0:         // StandardException and throw it.
1: 
1:             throw StandardException.newException(
0:                 SQLState.LANG_UNEXPECTED_XML_EXCEPTION, xe);
1:         }
1:     }
1: 
1:     /* ****
1:      * Helper classes and methods.
1:      * */
1: 
1:     /**
1:      * Set this XML value's qualified type.
1:      */
1:     public void setXType(int xtype)
1:     {
1:         this.xType = xtype;
1:     }
1: 
1:     /**
1:      * Retrieve this XML value's qualified type.
1:      */
1:     public int getXType()
1:     {
1:         return xType;
1:     }
1: 
commit:24f43da
/////////////////////////////////////////////////////////////////////////
0: 	// Some syntax-related constants used to determine
0: 	// operator behavior.
0: 	public static final short XQ_PASS_BY_REF = 1;
0: 	public static final short XQ_PASS_BY_VALUE = 2;
0: 	public static final short XQ_RETURN_SEQUENCE = 3;
0: 	public static final short XQ_RETURN_CONTENT = 4;
0: 	public static final short XQ_EMPTY_ON_EMPTY = 5;
0: 	public static final short XQ_NULL_ON_EMPTY = 6;
1: 
commit:6e7bbc8
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     /**
0:       Loaded at execution time, this holds XML-related objects
0:       that were created once during compilation but can be re-used
0:       for each row in the target result set for the current
0:       SQL statement.  In other words, we create the objects
0:       once per SQL statement, instead of once per row.  In the
0:       case of XMLEXISTS, one of the "objects" is the compiled
0:       query expression, which means we don't have to compile
0:       the expression for each row and thus we save some time.
1:      */
0:     private SqlXmlUtil sqlxUtil;
/////////////////////////////////////////////////////////////////////////
1:      * store the _serialized_ version locally and then return
1:      * this XMLDataValue.
1:      *
1:      * @param sqlxUtil Contains SQL/XML objects and util
1:      *  methods that facilitate execution of XML-related
1:      *  operations
1:      * @return If 'text' constitutes a valid XML document,
1:      *  it has been stored in this XML value and this XML
1:      *  value is returned; otherwise, an exception is thrown. 
1:      * @exception StandardException Thrown on error.
0:     public XMLDataValue XMLParse(String text, boolean preserveWS,
0:         SqlXmlUtil sqlxUtil) throws StandardException
1:             // Currently the only way a user can view the contents of
1:             // an XML value is by explicitly calling XMLSERIALIZE.
1:             // So do a serialization now and just store the result,
1:             // so that we don't have to re-serialize every time a
1:             // call is made to XMLSERIALIZE.
1:                 text = sqlxUtil.serializeToString(text);
/////////////////////////////////////////////////////////////////////////
0:         // Couldn't parse the XML document.  Throw a StandardException
/////////////////////////////////////////////////////////////////////////
1:         return this;
1:      * Serializes this XML value into a string with a user-specified
1:      * character type, and returns that string via the received
1:      * StringDataValue (if the received StringDataValue is non-null
1:      * and of the correct type; else, a new StringDataValue is
1:      * returned).
1:      *
/////////////////////////////////////////////////////////////////////////
1:                             "with a non-string target type: " + targetType);
/////////////////////////////////////////////////////////////////////////
1:         // we already have it as a UTF-8 string, so just use
1:         // that.
1:         result.setValue(getString());
/////////////////////////////////////////////////////////////////////////
1:      * Checks to see if evaluation of the query expression contained
1:      * within the received util object against this XML value returns
1:      * at least one item. NOTE: For now, the query expression must be
1:      * XPath only (XQuery not supported) because that's what Xalan
1:      * supports.
1:      *
1:      * @param sqlxUtil Contains SQL/XML objects and util
1:      *  methods that facilitate execution of XML-related
1:      *  operations
1:      * @return True if evaluation of the query expression stored
1:      *  in sqlxUtil returns at least one node for this XML value;
1:      *  unknown if the xml value is NULL; false otherwise.
1:     public BooleanDataValue XMLExists(SqlXmlUtil sqlxUtil)
1:         throws StandardException
1:         if (this.isNull()) {
1:         // if the user specified a context node and that context
1:         // is null, result of evaluating the query is null
1:         // (per SQL/XML 6.17:General Rules:1.a), which means that we
1:         // return "unknown" here (per SQL/XML 8.4:General Rules:2.a).
1:         }
1:         // Make sure we have a compiled query (and associated XML
1:         // objects) to evaluate.
1:         if (SanityManager.DEBUG) {
1:             SanityManager.ASSERT(
1:                 sqlxUtil != null,
1:                 "Tried to evaluate XML xquery, but no XML objects were loaded.");
1:         }
0:             return new SQLBoolean(sqlxUtil.evalXQExpression(this));
0:         // We don't expect to get here.  Turn it into a StandardException
0:         // (if needed), then throw it.
0:             if (xe instanceof StandardException)
0:                 throw (StandardException)xe;
1:             else {
1:                 throw StandardException.newException(
0:                     SQLState.LANG_UNEXPECTED_XML_EXCEPTION, xe);
1:             }
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:073b862
/////////////////////////////////////////////////////////////////////////
0:             Class<?> factoryClass =
0:             Class<?> builderClass =
/////////////////////////////////////////////////////////////////////////
0:             Class<?> domImplClass = Class.forName("org.w3c.dom.DOMImplementation");
commit:870f7cd
/////////////////////////////////////////////////////////////////////////
0:                 SQLState.LANG_XML_QUERY_ERROR,
/////////////////////////////////////////////////////////////////////////
0:                 SQLState.LANG_XML_QUERY_ERROR,
commit:9495437
/////////////////////////////////////////////////////////////////////////
1:             boolean materialize) {
/////////////////////////////////////////////////////////////////////////
1:     public DataValueDescriptor cloneValue(boolean forceMaterialization) {
commit:92268ac
/////////////////////////////////////////////////////////////////////////
0:             boolean materialize)
1:         throws StandardException
1:     {
/////////////////////////////////////////////////////////////////////////
0:     public DataValueDescriptor cloneValue(boolean forceMaterialization)
1:         throws StandardException
1:     {
commit:2431ece
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:7f7477d
/////////////////////////////////////////////////////////////////////////
1:             try {
1:                 RuleBasedCollator rbs = ConnectionUtil.getCurrentLCC().getDataValueFactory().
1:                 getCharacterCollator(targetCollationType);
1:                 result = ((StringDataValue)result).getValue(rbs);
1:             }
1:             catch( java.sql.SQLException sqle)
1:             {
1:                 throw StandardException.plainWrapException( sqle);
1:             }
commit:854dd10
/////////////////////////////////////////////////////////////////////////
1:      * Private constructor used for the {@code cloneValue} method.
/////////////////////////////////////////////////////////////////////////
1:      * @param materialize whether or not to force materialization of the
1:      *      underlying source data
1:     private XML(SQLChar val, int xmlType, boolean seqWithAttr,
0:             boolean materialize) {
1:         xmlStringValue = (val == null ? null
1:                                       : (SQLChar)val.cloneValue(materialize));
/////////////////////////////////////////////////////////////////////////
1:      * @see DataValueDescriptor#cloneValue
0:     public DataValueDescriptor cloneValue(boolean forceMaterialization) {
1:         return new XML(xmlStringValue, getXType(), hasTopLevelAttr(),
1:                 forceMaterialization);
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:27f9fd6
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.conn.ConnectionUtil;
/////////////////////////////////////////////////////////////////////////
1: import java.text.RuleBasedCollator;
/////////////////////////////////////////////////////////////////////////
1:         int targetType, int targetWidth, int targetCollationType) 
1:     throws StandardException
/////////////////////////////////////////////////////////////////////////
1:             // If the collation type is territory based, then we should use
1:             // CollatorSQLxxx rather than SQLxxx types for StringDataValue. 
1:             // eg
1:             // CREATE TABLE T_MAIN1 (ID INT  GENERATED ALWAYS AS IDENTITY 
1:             //       PRIMARY KEY, V XML);
1:             // INSERT INTO T_MAIN1(V) VALUES NULL;
1:             // SELECT ID, XMLSERIALIZE(V AS CLOB), XMLSERIALIZE(V AS CLOB) 
1:             //       FROM T_MAIN1 ORDER BY 1;
1:             // Following code is for (V AS CLOB) inside XMLSERIALIZE. The
1:             // StringDataValue returned for (V AS CLOB) should consider the 
1:             // passed collation type in determining whether we should
1:             // generate SQLChar vs CollatorSQLChar for instance. Keep in mind
1:             // that collation applies only to character string types.
0:     		if (result instanceof StringDataValue) {
1:     			try {
0:     				RuleBasedCollator rbs = ConnectionUtil.getCurrentLCC().getDataValueFactory().
0:     				getCharacterCollator(targetCollationType);
0:     				result = ((StringDataValue)result).getValue(rbs);
1:     			}
0:     			catch( java.sql.SQLException sqle)
1:     			{
0:     				throw StandardException.plainWrapException( sqle);
1:     			}
1:     		}
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:1198ab7
/////////////////////////////////////////////////////////////////////////
1:     private SqlXmlUtil tmpUtil;
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:         String valAsStr = resultSet.getString(colNumber);
1: 
1:         /* As there is no guarantee that the specified column within
1:          * resultSet is well-formed XML (is there??), we have to try
1:          * to parse it in order to set the "xType" field correctly.
1:          * This is required to ensure that we only store well-formed
1:          * XML on disk (see "normalize()" method of this class).  So
1:          * create an instance of SqlXmlUtil and use that to see if the
1:          * text satisifies the requirements of a well-formed DOCUMENT.
1:          *
1:          * RESOLVE: If there is anyway to guarantee that the column
1:          * is in fact well-formed XML then we can skip all of this
1:          * logic and simply set xType to XML_DOC_ANY.  But do we
1:          * have such a guarantee...?
1:          */
1:         if (tmpUtil == null)
1:         {
1:             try {
1: 
1:                 tmpUtil = new SqlXmlUtil();
1: 
1:             } catch (StandardException se) {
1: 
1:                 if (SanityManager.DEBUG)
1:                 {
1:                     SanityManager.THROWASSERT(
1:                         "Failed to instantiate SqlXmlUtil for XML parsing.");
1:                 }
1: 
1:                 /* If we failed to get a SqlXmlUtil then we can't parse
1:                  * the string, which means we don't know if it constitutes
1:                  * a well-formed XML document or not.  In this case we
1:                  * set the value, but intentionally leave xType as -1
1:                  * so that the resultant value canNOT be stored on disk.
1:                  */
1:                 xmlStringValue.setValue(valAsStr);
1:                 setXType(-1);
0:                 return;
1: 
1:             }
1:         }
1: 
1:         try {
1: 
1:             /* The following call parses the string into a DOM and
1:              * then serializes it, which is exactly what we do for
1:              * normal insertion of XML values.  If the parse finishes
1:              * with no error then we know the type is XML_DOC_ANY,
1:              * so set it.
1:              */
1:             valAsStr = tmpUtil.serializeToString(valAsStr);
1:             xmlStringValue.setValue(valAsStr);
1:             setXType(XML_DOC_ANY);
1: 
1:         } catch (Throwable t) {
1: 
1:             /* It's possible that the string value was either 1) an
1:              * XML SEQUENCE or 2) not XML at all.  We don't know
1:              * which one it was, so make xType invalid to ensure this
1:              * field doesn't end up on disk.
1:              */
1:             xmlStringValue.setValue(valAsStr);
1:             setXType(-1);
1: 
1:         }
commit:8cefbbc
/////////////////////////////////////////////////////////////////////////
1:                 SQLState.LANG_INVALID_XML_DOCUMENT, t, t.getMessage());
/////////////////////////////////////////////////////////////////////////
0:                 SQLState.LANG_XML_QUERY_ERROR, xe,
1:                 "XMLEXISTS", xe.getMessage());
/////////////////////////////////////////////////////////////////////////
0:                 SQLState.LANG_XML_QUERY_ERROR, xe,
1:                 "XMLQUERY", xe.getMessage());
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:cfda298
/////////////////////////////////////////////////////////////////////////
1:      * Returns a new instance of XML whose fields are clones
1:      * of the values received.
author:Suresh Thalamati
-------------------------------------------------------------------------------
commit:bb67ebd
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:      * @see DataType#setFrom
author:David Van Couvering
-------------------------------------------------------------------------------
commit:6b50965
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.io.Storable;
1: import org.apache.derby.iapi.services.io.TypedFormat;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 	 * If 'text' constitutes a valid XML document,
0:      *  it has been stored in this XML value and nothing
0:      *  is returned; otherwise, an exception is thrown.
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:099e28f
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derby.iapi.types.XML
1: 
0:    Copyright 2005 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derby.iapi.types;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: 
1: import org.apache.derby.iapi.services.cache.ClassSize;
1: import org.apache.derby.iapi.services.io.ArrayInputStream;
1: import org.apache.derby.iapi.services.io.StoredFormatIds;
1: import org.apache.derby.iapi.services.io.StreamStorable;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.types.StringDataValue;
0: import org.apache.derby.iapi.types.BooleanDataValue;
1: 
1: import org.apache.derby.iapi.reference.SQLState;
1: 
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: import java.sql.Types;
1: 
1: import java.io.InputStream;
1: import java.io.IOException;
1: import java.io.ObjectOutput;
1: import java.io.ObjectInput;
0: import java.io.StringReader;
1: 
0: import org.xml.sax.ErrorHandler;
0: import org.xml.sax.XMLReader;
0: import org.xml.sax.SAXException;
0: import org.xml.sax.SAXParseException;
0: import org.xml.sax.InputSource;
1: 
0: import org.xml.sax.helpers.DefaultHandler;
0: import org.xml.sax.helpers.XMLReaderFactory;
1: 
0: import javax.xml.transform.Templates;
0: import javax.xml.transform.TransformerFactory;
1: 
0: import javax.xml.transform.sax.SAXResult;
0: import javax.xml.transform.sax.TemplatesHandler;
0: import javax.xml.transform.sax.TransformerHandler;
1: 
0: // Note that even though the following has a Xalan
0: // package name, it IS part of the JDK 1.4 API, and
0: // thus we can compile it without having Xalan in
0: // our classpath.
0: import org.apache.xalan.processor.TransformerFactoryImpl;
1: 
1: /**
1:  * This type implements the XMLDataValue interface and thus is
1:  * the type on which all XML related operations are executed.
1:  *
1:  * The first and simplest XML store implementation is a UTF-8
1:  * based one--all XML data is stored on disk as a UTF-8 string,
1:  * just like the other Derby string types.  In order to make
1:  * it possible for smarter XML implementations to exist in
1:  * the future, this class always writes an "XML implementation
1:  * id" to disk before writing the rest of its data.  When
1:  * reading the data, the impl id is read first and serves
1:  * as an indicator of how the rest of the data should be
1:  * read.
1:  *
1:  * So long as there's only one implementation (UTF-8)
1:  * the impl id can be ignored; but when smarter implementations
1:  * are written, the impl id will be the key to figuring out
1:  * how an XML value should be read, written, and processed.
1:  */
1: public class XML
1:     extends DataType implements XMLDataValue, StreamStorable
1: {
1:     // Id for this implementation.  Should be unique
1:     // across all XML type implementations.
1:     protected static final short UTF8_IMPL_ID = 0;
1: 
0:     // Parser class to use for parsing XML.  We use the
0:     // Xerces parser, so (for now) we require that Xerces
0:     // be in the user's classpath.  Note that we load
0:     // the Xerces class dynamically (using the class 
0:     // name) so that Derby will build even if Xerces
0:     // isn't in the build environment; i.e. Xerces is
0:     // only required if XML is actually going to be used
0:     // at runtime; it's not required for a successful
0:     // build nor for non-XML database use.
0:     protected static final String XML_PARSER_CLASS =
0:         "org.apache.xerces.parsers.SAXParser";
1: 
1:     // Guess at how much memory this type will take.
1:     private static final int BASE_MEMORY_USAGE =
1:         ClassSize.estimateBaseFromCatalog(XML.class);
1: 
1:     // The actual XML data in this implementation is just a simple
1:     // string, so this class really just wraps a SQLChar and
1:     // defers most calls to the corresponding calls on that
1:     // SQLChar.  Note that, even though a SQLChar is the
1:     // underlying implementation, an XML value is nonetheless
1:     // NOT considered comparable nor compatible with any of
1:     // Derby string types.
1:     private SQLChar xmlStringValue;
1: 
0:     // An XML reader for reading and parsing SAX events.
0:     protected XMLReader saxReader;
1: 
0:     // XSLT objects used when performing an XSLT query, which
0:     // is the query mechanism for this UTF8-based implementation.
0:     private static final String XPATH_PLACEHOLDER = "XPATH_PLACEHOLDER";
0:     private static final String QUERY_MATCH_STRING = "MATCH";
0:     private static String xsltStylesheet;
0:     private XMLReader xsltReader;
0:     private TransformerFactoryImpl saxTFactory;
1: 
1:     /**
1:      * Default constructor.
1:      */
1:     public XML()
1:     {
1:         xmlStringValue = null;
1:     }
1: 
1:     /**
0:      * Private constructor used for the getClone() method.
0:      * Takes a SQLChar and clones it.
0:      * @param val A SQLChar instance to clone and use for
0:      *  this XML value.
1:      */
0:     private XML(SQLChar val)
1:     {
0:         xmlStringValue = (val == null ? null : (SQLChar)val.getClone());
1:     }
1: 
1:     /* ****
1:      * DataValueDescriptor interface.
1:      * */
1: 
1:     /**
0:      * @see DataValueDescriptor#getClone
1:      */
0:     public DataValueDescriptor getClone()
1:     {
0:         return new XML(xmlStringValue);
1:     }
1: 
1:     /**
1:      * @see DataValueDescriptor#getNewNull
1:      */
1:     public DataValueDescriptor getNewNull()
1:     {
1:         return new XML();
1:     }
1: 
1:     /**
1:      * @see DataValueDescriptor#getTypeName
1:      */
1:     public String getTypeName()
1:     {
1:         return TypeId.XML_NAME;
1:     }
1: 
1:     /**
1:      * @see DataValueDescriptor#typePrecedence
1:      */
1:     public int typePrecedence()
1:     {
1:         return TypeId.XML_PRECEDENCE;
1:     }
1: 
1:     /**
1:      * @see DataValueDescriptor#getString
1:      */
1:     public String getString() throws StandardException
1:     {
1:         return (xmlStringValue == null) ? null : xmlStringValue.getString();
1:     }
1: 
1:     /**
1:      * @see DataValueDescriptor#getLength
1:      */
1:     public int    getLength() throws StandardException
1:     {
1:         return ((xmlStringValue == null) ? 0 : xmlStringValue.getLength());
1:     }
1: 
1:     /** 
1:      * @see DataValueDescriptor#estimateMemoryUsage
1:      */
1:     public int estimateMemoryUsage()
1:     {
1:         int sz = BASE_MEMORY_USAGE;
1:         if (xmlStringValue != null)
1:             sz += xmlStringValue.estimateMemoryUsage();
1:         return sz;
1:     }
1: 
1:     /**
1:      * @see DataValueDescriptor#readExternalFromArray
1:      */
1:     public void readExternalFromArray(ArrayInputStream in)
1:         throws IOException
1:     {
1:         if (xmlStringValue == null)
1:             xmlStringValue = new SQLChar();
1: 
1:         // Read the XML implementation id.  Right now there's
1:         // only one implementation (UTF-8 based), so we don't
1:         // use this value.  But if better implementations come
1:         // up in the future, we'll have to use this impl id to
1:         // figure out how to read the data.
1:         in.readShort();
1: 
1:         // Now just read the XML data as UTF-8.
1:         xmlStringValue.readExternalFromArray(in);
1:     }
1: 
1:     /**
0:      * @see DataValueDescriptor#setFrom
1:      */
1:     protected void setFrom(DataValueDescriptor theValue)
0:         throws StandardException
1:     {
1:         if (xmlStringValue == null)
1:             xmlStringValue = new SQLChar();
0:         xmlStringValue.setValue(theValue.getString());
1:     }
1: 
1:     /** 
1:      * @see DataValueDescriptor#setValueFromResultSet 
1:      */
1:     public final void setValueFromResultSet(
1:         ResultSet resultSet, int colNumber, boolean isNullable)
1:         throws SQLException
1:     {
1:         if (xmlStringValue == null)
1:             xmlStringValue = new SQLChar();
0:         xmlStringValue.setValue(resultSet.getString(colNumber));
1:     }
1: 
1:     /**
1:      * Compare two XML DataValueDescriptors.  NOTE: This method
1:      * should only be used by the database store for the purpose of
1:      * index positioning--comparisons of XML type are not allowed
1:      * from the language side of things.  That said, all store
1:      * wants to do is order the NULLs, so we don't actually
1:      * have to do a full comparison.  Just return an order
1:      * value based on whether or not this XML value and the
1:      * other XML value are null.  As mentioned in the "compare"
1:      * method of DataValueDescriptor, nulls are considered
1:      * equal to other nulls and less than all other values.
1:      *
1:      * An example of when this method might be used is if the
1:      * user executed a query like:
1:      *
1:      * select i from x_table where x_col is not null
1:      *
1:      * @see DataValueDescriptor#compare
1:      */
1:     public int compare(DataValueDescriptor other)
0:         throws StandardException
1:     {
1:         if (SanityManager.DEBUG) {
1:             SanityManager.ASSERT(other instanceof XMLDataValue,
1:                 "Store should NOT have tried to compare an XML value " +
1:                 "with a non-XML value.");
1:         }
1: 
1:         if (isNull()) {
1:             if (other.isNull())
1:             // both null, so call them 'equal'.
1:                 return 0;
1:             // This XML is 'less than' the other.
1:             return -1;
1:         }
1: 
1:         if (other.isNull())
1:         // This XML is 'greater than' the other.
1:             return 1;
1: 
1:         // Two non-null values: we shouldn't ever get here,
1:         // since that would necessitate a comparsion of XML
1:         // values, which isn't allowed.
1:         if (SanityManager.DEBUG) {
1:             SanityManager.THROWASSERT(
1:                 "Store tried to compare two non-null XML values, " +
1:                 "which isn't allowed.");
1:         }
1:         return 0;
1:     }
1: 
1:     /* ****
1:      * Storable interface, implies Externalizable, TypedFormat
1:      */
1: 
1:     /**
1:      * @see TypedFormat#getTypeFormatId
1:      *
1:      * From the engine's perspective, all XML implementations share
1:      * the same format id.
1:      */
1:     public int getTypeFormatId() {
1:         return StoredFormatIds.XML_ID;
1:     }
1: 
1:     /**
1:      * @see Storable#isNull
1:      */
1:     public boolean isNull()
1:     {
1:         return ((xmlStringValue == null) || xmlStringValue.isNull());
1:     }
1: 
1:     /**
1:      * @see Storable#restoreToNull
1:      */
1:     public void restoreToNull()
1:     {
1:         if (xmlStringValue != null)
1:             xmlStringValue.restoreToNull();
1:     }
1: 
1:     /**
1:      * Read an XML value from an input stream.
1:      * @param in The stream from which we're reading.
1:      */
1:     public void readExternal(ObjectInput in) throws IOException
1:     {
1:         if (xmlStringValue == null)
1:             xmlStringValue = new SQLChar();
1: 
1:         // Read the XML implementation id.  Right now there's
1:         // only one implementation (UTF-8 based), so we don't
1:         // use this value.  But if better implementations come
1:         // up in the future, we'll have to use this impl id to
1:         // figure out how to read the data.
1:         in.readShort();
1: 
1:         // Now just read the XML data as UTF-8.
1:         xmlStringValue.readExternal(in);
1:     }
1: 
1:     /**
1:      * Write an XML value. 
1:      * @param out The stream to which we're writing.
1:      */
1:     public void writeExternal(ObjectOutput out) throws IOException
1:     {
1:         // never called when value is null
1:         if (SanityManager.DEBUG)
1:             SanityManager.ASSERT(!isNull());
1: 
1:         // Write out the XML store impl id.
1:         out.writeShort(UTF8_IMPL_ID);
1: 
1:         // Now write out the data.
1:         xmlStringValue.writeExternal(out);
1:     }
1: 
1:     /* ****
1:      * StreamStorable interface
1:      * */
1: 
1:     /**
1:      * @see StreamStorable#returnStream
1:      */
1:     public InputStream returnStream()
1:     {
1:         return
1:             (xmlStringValue == null) ? null : xmlStringValue.returnStream();
1:     }
1: 
1:     /**
1:      * @see StreamStorable#setStream
1:      */
1:     public void setStream(InputStream newStream)
1:     {
1:         if (xmlStringValue == null)
1:             xmlStringValue = new SQLChar();
1: 
1:         // The stream that we receive is for an XML data value,
1:         // which means it has an XML implementation id stored
1:         // at the front (we put it there when we wrote it out).
1:         // If we leave that there we'll get a failure when
1:         // our underlying SQLChar tries to read from the
1:         // stream, because the extra impl id will throw
1:         // off the UTF format.  So we need to read in (and
1:         // ignore) the impl id before using the stream.
1:         try {
1:             // 2 bytes equal a short, which is what an impl id is.
1:             newStream.read();
1:             newStream.read();
1:         } catch (Exception e) {
1:             if (SanityManager.DEBUG)
1:                 SanityManager.THROWASSERT("Failed to read impl id" +
1:                     "bytes in setStream.");
1:         }
1: 
1:         // Now go ahead and use the stream.
1:         xmlStringValue.setStream(newStream);
1:     }
1: 
1:     /**
1:      * @see StreamStorable#loadStream
1:      */
1:     public void loadStream() throws StandardException
1:     {
1:         getString();
1:     }
1: 
1:     /* ****
1:      * XMLDataValue interface.
1:      * */
1: 
1:     /**
1:      * Method to parse an XML string and, if it's valid,
0:      * store the _parsed_ version for subsequent use.
0:      * @param text The string value to check.
1:      * @param preserveWS Whether or not to preserve
1:      *  ignorable whitespace.
0:      * @return  If 'text' constitutes a valid XML document,
0:      *  it has been stored in this XML value and nothing
0:      *  is returned; otherwise, an exception is thrown.
0:      * @exception StandardException Thrown on parse error.
1:      */
0:     public void parseAndLoadXML(String text, boolean preserveWS)
0:         throws StandardException
1:     {
1:         try {
1: 
1:             if (preserveWS) {
0:             // We're just going to use the text exactly as it
0:             // is, so we just need to see if it parses. 
0:                 loadSAXReader();
0:                 saxReader.parse(
0:                     new InputSource(new StringReader(text)));
1:             }
0:             else {
1:             // We don't support this yet, so we shouldn't
1:             // get here.
1:                 if (SanityManager.DEBUG)
1:                     SanityManager.THROWASSERT("Tried to STRIP whitespace " +
1:                         "but we shouldn't have made it this far");
1:             }
1: 
0:         } catch (Exception xe) {
0:         // The text isn't a valid XML document.  Throw a StandardException
0:         // with the parse exception nested in it.
0:             throw StandardException.newException(
0:                 SQLState.LANG_NOT_AN_XML_DOCUMENT, xe);
1:         }
1: 
1:         // If we get here, the text is valid XML so go ahead
1:         // and load/store it.
1:         if (xmlStringValue == null)
1:             xmlStringValue = new SQLChar();
1:         xmlStringValue.setValue(text);
0:         return;
1:     }
1: 
1:     /**
1:      * The SQL/XML XMLSerialize operator.
0:      * Converts this XML value into a string with a user-specified
0:      * type, and returns that string via the received StringDataValue
0:      * (if the received StringDataValue is non-null; else a new
0:      * StringDataValue is returned).
1:      * @param result The result of a previous call to this method,
1:      *    null if not called yet.
1:      * @param targetType The string type to which we want to serialize.
1:      * @param targetWidth The width of the target type.
1:      * @return A serialized (to string) version of this XML object,
1:      *  in the form of a StringDataValue object.
1:      * @exception StandardException    Thrown on error
1:      */
1:     public StringDataValue XMLSerialize(StringDataValue result,
0:         int targetType, int targetWidth) throws StandardException
1:     {
1:         if (result == null) {
1:             switch (targetType)
1:             {
1:                 case Types.CHAR:        result = new SQLChar(); break;
1:                 case Types.VARCHAR:     result = new SQLVarchar(); break;
1:                 case Types.LONGVARCHAR: result = new SQLLongvarchar(); break;
1:                 case Types.CLOB:        result = new SQLClob(); break;
1:                 default:
1:                 // Shouldn't ever get here, as this check was performed
1:                 // at bind time.
1: 
1:                     if (SanityManager.DEBUG) {
1:                         SanityManager.THROWASSERT(
1:                             "Should NOT have made it to XMLSerialize " +
0:                             "with a non-string target type.");
1:                     }
0:                     return null;
1:             }
1:         }
1: 
1:         // Else we're reusing a StringDataValue.  We only reuse
1:         // the result if we're executing the _same_ XMLSERIALIZE
1:         // call on multiple rows.  That means that all rows
1:         // must have the same result type (targetType) and thus
1:         // we know that the StringDataValue already has the
1:         // correct type.  So we're set.
1: 
1:         if (this.isNull()) {
1:         // Attempts to serialize a null XML value lead to a null
1:         // result (SQL/XML[2003] section 10.13).
1:             result.setToNull();
1:             return result;
1:         }
1: 
1:         // Get the XML value as a string.  For this UTF-8 impl,
0:         // we already have it as a string, so just use that.
0:         result.setValue(xmlStringValue.getString());
1: 
1:         // Seems wrong to trunc an XML document, as it then becomes non-
1:         // well-formed and thus useless.  So we throw an error (that's
1:         // what the "true" in the next line says).
1:         result.setWidth(targetWidth, 0, true);
1:         return result;
1:     }
1: 
1:     /**
1:      * The SQL/XML XMLExists operator.
0:      * Takes an XML query expression (as a string) and an XML
0:      * value and checks if at least one node in the XML
0:      * value matches the query expression.  NOTE: For now,
0:      * the query expression must be XPath only (XQuery not
0:      * supported).
0:      * @param xExpr The query expression, as a string.
0:      * @param xml The XML value being queried.
0:      * @return True if the received query expression matches at
0:      *  least one node in the received XML value; unknown if
0:      *  either the query expression or the xml value is null;
0:      *  false otherwise.
1:      * @exception StandardException Thrown on error
1:      */
0:     public BooleanDataValue XMLExists(StringDataValue xExpr,
0:         XMLDataValue xml) throws StandardException
1:     {
0:         if ((xExpr == null) || xExpr.isNull())
0:         // If the query is null, we assume unknown.
1:             return SQLBoolean.unknownTruthValue();
1: 
0:         if ((xml == null) || xml.isNull())
0:         // Then per SQL/XML spec 8.4, we return UNKNOWN.
1:             return SQLBoolean.unknownTruthValue();
1: 
0:         return new SQLBoolean(xml.exists(xExpr.getString()));
1:     }
1: 
1:     /**
0:      * Helper method for XMLExists.
0:      * See if the received XPath expression returns at least
0:      * one node when evaluated against _this_ XML value.
0:      * @param xExpr The XPath expression.
0:      * @return True if at least one node in this XML value
0:      *  matches the received xExpr; false otherwise.
1:      */
0:     public boolean exists(String xExpr) throws StandardException
1:     {
0:         // NOTE: At some point we'll probably need to implement some
0:         // some kind of query cache so that we don't have to recompile
0:         // the same query over and over for every single XML row
0:         // in a table.  That's what we do right now...
1: 
1:         try {
1: 
0:             xExpr = replaceDoubleQuotes(xExpr);
0:             loadXSLTObjects();
1: 
0:             // Take our simple stylesheet and plug in the query.
0:             int pos = xsltStylesheet.indexOf(XPATH_PLACEHOLDER);
0:             StringBuffer stylesheet = new StringBuffer(xsltStylesheet);
0:             stylesheet.replace(pos, pos + XPATH_PLACEHOLDER.length(), xExpr);
1: 
0:             // Create a Templates ContentHandler to handle parsing of the 
0:             // stylesheet.
0:             TemplatesHandler templatesHandler = 
0:                 saxTFactory.newTemplatesHandler();
0:             xsltReader.setContentHandler(templatesHandler);
1:     
0:             // Now parse the generic stylesheet we created.
0:             xsltReader.parse(
0:                 new InputSource(new StringReader(stylesheet.toString())));
1: 
0:             // Get the Templates object (generated during the parsing of
0:             // the stylesheet) from the TemplatesHandler.
0:             Templates compiledQuery = templatesHandler.getTemplates();
1: 
0:             // Create a Transformer ContentHandler to handle parsing of 
0:             // the XML Source.  
0:             TransformerHandler transformerHandler 
0:                 = saxTFactory.newTransformerHandler(compiledQuery);
1: 
0:             // Reset the XMLReader's ContentHandler to the TransformerHandler.
0:             xsltReader.setContentHandler(transformerHandler);
1: 
0:             // Create an ExistsHandler.  When the XSLT transformation
0:             // occurs, a period (".") will be thrown to this handler
0:             // (via a SAX 'characters' event) for every matching
0:             // node that XSLT finds.  This is how we know if a
0:             // match was found.
0:             ExistsHandler eH = new ExistsHandler();
0:             transformerHandler.setResult(new SAXResult(eH));
1: 
0:             // This call to "parse" is what does the query, because we
0:             // passed in an XSLT handler with the compiled query above.
1:             try {
0:                 xsltReader.parse(
0:                     new InputSource(new StringReader(getString())));
0:             } catch (Throwable th) {
0:                 if (th.getMessage().indexOf(
0:                     "SAXException: " + QUERY_MATCH_STRING) == -1)
0:                 { // then this isn't the exception that means we have
0:                   // a match; so re-throw it.
0:                     throw new Exception(th.getMessage());
1:                 }
1:             }
1: 
0:             // Did we have any matches?
0:             return eH.exists();
1: 
0:         } catch (Exception xe) {
0:         // We don't expect to get here.  Turn it into a
0:         // StandardException, then throw it.
0:             throw StandardException.newException(
0:                 SQLState.LANG_UNEXPECTED_XML_EXCEPTION, xe);
1:         }
1:     }
1: 
1:     /* ****
0:      * Helper classes and methods.
1:      * */
1: 
1:     /**
0:      * Load an XMLReader for SAX events that can be used
0:      * for parsing XML data.
1:      *
0:      * This method is currently only used for XMLPARSE, and
0:      * the SQL/XML[2003] spec says that XMLPARSE should NOT
0:      * perform validation -- Seciont 6.11:
1:      *
0:      *    "Perform a non-validating parse of a character string to
0:      *    produce an XML value."
1:      *
0:      * Thus, we make sure to disable validation on the XMLReader
0:      * loaded here.  At some point in the future we will probably
0:      * want to add support for the XMLVALIDATE function--but until
0:      * then, user is unable to validate the XML values s/he inserts.
1:      *
0:      * Note that, even with validation turned off, XMLPARSE
0:      * _will_ still check the well-formedness of the values,
0:      * and it _will_ still process DTDs to get default values,
0:      * etc--but that's it; no validation errors will be thrown.
1:      *
0:      * For future reference: the features needed to perform
0:      * validation (with Xerces) are:
1:      *
0:      * http://apache.org/xml/features/validation/schema
0:      * http://apache.org/xml/features/validation/dynamic
1:      */
0:     protected void loadSAXReader() throws Exception
1:     {
0:         if (saxReader != null)
0:         // already loaded.
0:             return;
1: 
0:         // Get an instance of an XMLReader.
0:         saxReader = XMLReaderFactory.createXMLReader(XML_PARSER_CLASS);
1: 
0:         // Turn off validation, since it's not allowed by
0:         // SQL/XML[2003] spec.
0:         saxReader.setFeature(
0:             "http://xml.org/sax/features/validation", false);
1: 
0:         // Make the parser namespace aware.
0:         saxReader.setFeature(
0:             "http://xml.org/sax/features/namespaces", true);
1: 
0:         // We have to set the error handler in order to properly
0:         // receive the parse errors.
0:         saxReader.setErrorHandler(new XMLErrorHandler());
1:     }
1: 
1:     /**
0:      * Prepare for an XSLT query by loading the objects
0:      * required for such a query.  We should only have
0:      * to do this once per XML object.
1:      */
0:     private void loadXSLTObjects() throws SAXException
1:     {
0:         if (xsltReader != null)
0:         // we already loaded everything.
0:             return;
1: 
0:         // Instantiate a TransformerFactory.
0:         TransformerFactory tFactory = TransformerFactory.newInstance();
1: 
0:         // Cast the TransformerFactory to SAXTransformerFactory.
0:         saxTFactory = (TransformerFactoryImpl)tFactory;
1: 
0:         // Get an XML reader.
0:         xsltReader = XMLReaderFactory.createXMLReader(XML_PARSER_CLASS);
1: 
0:         // Make the parser namespace aware.  Note that because we
0:         // only support a small subset of SQL/XML, and because we
0:         // only allow XPath (as opposed to XQuery) expressions,
0:         // there is no way for a user to specify namespace
0:         // bindings as part of the XMLEXISTS operator.  This means
0:         // that in order to query for a node name, the user must
0:         // use the XPath functions "name()" and "local-name()"
0:         // in conjunction with XPath 1.0 'namespace' axis.  For
0:         // example:
0:         //
0:         // To see if any elements exist that have a specific name
0:         // with ANY namespace:
0:         //     //child::*[local-name()="someName"]
0:         //
0:         // To see if any elements exist that have a specific name
0:         // with NO namespace:
0:         //     //child::*[name()="someName"]
0:         //
0:         // To see if any elements exist that have a specific name
0:         // in a specific namespace:
0:         //     //child::*[local-name()=''someName'' and
0:         //        namespace::*[string()=''http://www.some.namespace'']]
0:         //
0:         xsltReader.setFeature(
0:             "http://xml.org/sax/features/namespaces", true);
1: 
0:         // Create a very simple XSLT stylesheet.  This stylesheet
0:         // will execute the XPath expression and, for every match,
0:         // write a period (".") to the ExistsHandler (see the exists()
0:         // method above).  Then, in order to see if at least one
0:         // node matches, we just check to see if the ExistsHandler
0:         // caught at least one 'characters' event.  If it did, then
0:         // we know we had a match.
0:         if (xsltStylesheet == null) {
0:             StringBuffer sb = new StringBuffer();
0:             sb.append("<xsl:stylesheet version=\"1.0\"\n");
0:             sb.append("xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n");
0:             sb.append(" <xsl:template match=\"/\">\n"); // Search whole doc...
0:             sb.append("  <xsl:for-each select=\"");     // For every match...
0:             sb.append(XPATH_PLACEHOLDER);               // using XPath expr...
0:             sb.append("\">.</xsl:for-each>\n");         // Write a "."
0:             sb.append(" </xsl:template>\n");
0:             sb.append("</xsl:stylesheet>\n");
0:             xsltStylesheet = sb.toString();
1:         }
1:     }
1: 
1:     /**
0:      * Takes a string (which is an XPath query specified by
0:      * the user) and replaces any double quotes with single
0:      * quotes.  We have to do this because a double quote
0:      * in the XSLT stylesheet (which is where the user's
0:      * query ends up) will be parsed as a query terminator
0:      * thus will cause XSLT execution errors.
0:      * @param queryText Text in which we want to replace double
0:      *  quotes.
0:      * @return queryText with all double quotes replaced by
0:      *  single quotes.
1:      */
0:     private String replaceDoubleQuotes(String queryText)
1:     {
0:         int pos = queryText.indexOf("\"");
0:         if (pos == -1)
0:         // nothing to do.
0:             return queryText;
1: 
0:         StringBuffer sBuf = new StringBuffer(queryText);
0:         while (pos >= 0) {
0:             sBuf.replace(pos, pos+1, "'");
0:             pos = queryText.indexOf("\"", pos+1);
1:         }
0:         return sBuf.toString();
1:     }
1: 
1:     /*
0:      ** The XMLErrorHandler class is just a generic implementation
0:      ** of the ErrorHandler interface.  It allows us to catch
0:      ** and process XML parsing errors in a graceful manner.
1:      */
0:     private class XMLErrorHandler implements ErrorHandler
1:     {
0:         public void error (SAXParseException exception)
0:             throws SAXException
1:         {
0:             throw new SAXException (exception);
1:         }
1: 
0:         public void fatalError (SAXParseException exception)
0:             throws SAXException
1:         {
0:             throw new SAXException (exception);
1:         }
1: 
0:         public void warning (SAXParseException exception)
0:             throws SAXException
1:         {
0:             throw new SAXException (exception);
1:         }
1:     }
1: 
1:     /*
0:      ** The ExistsHandler is what we pass to the XSLT processor
0:      ** when we query.  The generic xsltStylesheet that we defined
0:      ** above will throw a 'characters' event for every matching
0:      ** node that is found by the XSLT transformation.  This
0:      ** handler is the one that catches the event, and thus
0:      ** it tells us whether or not we had a match.
1:      */
0:     private class ExistsHandler extends DefaultHandler
1:     {
0:         // Did we catch at least one 'characters' event?
0:         private boolean atLeastOneMatch;
1: 
0:         public ExistsHandler() {
0:             atLeastOneMatch = false;
1:         }
1: 
1:         /*
0:          * Catch a SAX 'characters' event, which tells us that
0:          * we had at least one matching node.
1:          */
0:         public void characters(char[] ch, int start, int length)
0:             throws SAXException
1:         {
0:             // If we get here, we had at least one matching node.
0:             // Since that's all we need to know, we don't have
0:             // to continue querying--we can stop the XSLT
0:             // transformation now by throwing a SAX exception.
0:             atLeastOneMatch = true;
0:             throw new SAXException(QUERY_MATCH_STRING);
1:         }
1: 
1:         /*
0:          * Tell whether or not this handler caught a match.
1:          */
0:         public boolean exists()
1:         {
0:             return atLeastOneMatch;
1:         }
1:     }
1: }
============================================================================