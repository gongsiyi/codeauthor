1:3fcea8a: /*
6:3fcea8a: 
1:8e4ceb1:    Derby - Class org.apache.derbyTesting.functionTests.tests.jdbcapi.SetQueryTimeoutTest
1:3fcea8a: 
1:dff95a1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:dff95a1:    contributor license agreements.  See the NOTICE file distributed with
1:dff95a1:    this work for additional information regarding copyright ownership.
1:dff95a1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:dff95a1:    (the "License"); you may not use this file except in compliance with
1:dff95a1:    the License.  You may obtain a copy of the License at
1:3fcea8a: 
1:3fcea8a:       http://www.apache.org/licenses/LICENSE-2.0
1:3fcea8a: 
1:3fcea8a:    Unless required by applicable law or agreed to in writing, software
1:3fcea8a:    distributed under the License is distributed on an "AS IS" BASIS,
1:3fcea8a:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:3fcea8a:    See the License for the specific language governing permissions and
1:3fcea8a:    limitations under the License.
1:3fcea8a: 
1:3fcea8a:  */
1:3fcea8a: 
1:3fcea8a: package org.apache.derbyTesting.functionTests.tests.jdbcapi;
1:3fcea8a: 
1:c83b48a: import java.sql.CallableStatement;
1:3fcea8a: import java.sql.Connection;
1:3fcea8a: import java.sql.SQLException;
1:3fcea8a: import java.sql.Statement;
1:3fcea8a: import java.sql.PreparedStatement;
1:3fcea8a: import java.sql.ResultSet;
1:3fcea8a: 
1:3fcea8a: import java.util.Collection;
1:3fcea8a: import java.util.HashSet;
1:3fcea8a: import java.util.Collections;
1:3fcea8a: 
1:3fcea8a: import org.apache.derby.tools.ij;
1:3fcea8a: 
1:3fcea8a: /**
1:3fcea8a:  * Functional test for the Statement.setQueryTimeout() method.
1:3fcea8a:  *
1:c83b48a:  * This test consists of four parts:
1:3fcea8a:  *
1:3fcea8a:  * 1. Executes a SELECT query in 4 different threads concurrently.
1:1373f5a:  *    The query calls a user-defined, server-side function which
1:1373f5a:  *    delays the execution, so that it takes several seconds even
1:1373f5a:  *    though the data volume is really low. The fetch operations
1:1373f5a:  *    take longer time than the timeout value set. Hence, this part
1:1373f5a:  *    tests getting timeouts from calls to ResultSet.next().
1:3fcea8a:  * 
1:3fcea8a:  *    Two connections are used, two threads execute their statement
1:3fcea8a:  *    in the context of one connection, the other two threads in the
1:3fcea8a:  *    context of the other connection. Of the 4 threads, only one
1:3fcea8a:  *    executes its statement with a timeout value. This way, the test
1:3fcea8a:  *    ensures that the correct statement is affected by setQueryTimeout(),
1:3fcea8a:  *    regardless of what connection/transaction it and other statements
1:3fcea8a:  *    are executed in the context of.
1:3fcea8a:  *    
1:1373f5a:  * 2. Executes an INSERT query in multiple threads.
1:3fcea8a:  *    This part tests getting timeouts from calls to Statement.execute().
1:3fcea8a:  *    Each thread executes the query in the context of a separate
1:3fcea8a:  *    connection. There is no point in executing multiple statements
1:3fcea8a:  *    on the same connection; since only one statement per connection
1:3fcea8a:  *    executes at a time, there will be no interleaving of execution
1:3fcea8a:  *    between them (contrary to the first part of this test, where
1:3fcea8a:  *    calls to ResultSet.next() may be interleaved between the different
1:3fcea8a:  *    threads).
1:3fcea8a:  *
1:1373f5a:  *    Half of the threads execute their statement with a timeout value set,
1:1373f5a:  *    this is to verify that the correct statements are affected by the
1:1373f5a:  *    timeout, while the other statements execute to completion.
1:3fcea8a:  *
1:3fcea8a:  * 3. Sets an invalid (negative) timeout. Verifies that the correct
1:3fcea8a:  *    exception is thrown.
1:3fcea8a:  *
1:c83b48a:  * 4. Tests that the query timeout value is not forgotten after the execution
1:c83b48a:  *    of a statement (DERBY-1692).
1:3fcea8a:  */
1:3fcea8a: public class SetQueryTimeoutTest
1:3fcea8a: {
1:1373f5a:     private static final int TIMEOUT = 1; // In seconds
1:1373f5a:     private static final int CONNECTIONS = 100;
1:3fcea8a: 
1:3fcea8a:     private static void printSQLException(SQLException e)
1:3fcea8a:     {
1:3fcea8a:         while (e != null)
1:3fcea8a:         {
1:3fcea8a:             e.printStackTrace();
1:3fcea8a:             e = e.getNextException();
1:3fcea8a:         }
1:3fcea8a:     }
1:3fcea8a: 
1:3fcea8a:     /**
1:3fcea8a:      * This Exception class is used for getting fail-fast behaviour in
1:3fcea8a:      * this test. There is no point in wasting cycles running a test to
1:3fcea8a:      * the end when we know that it has failed.
1:3fcea8a:      *
1:3fcea8a:      * In order to enable chaining of exceptions in J2ME, this class defines
1:3fcea8a:      * its own "cause", duplicating existing functionality in J2SE.
1:3fcea8a:      */
1:3fcea8a:     private static class TestFailedException
1:3fcea8a:         extends
1:3fcea8a:             Exception
1:3fcea8a:     {
1:3fcea8a:         private Throwable cause;
1:3fcea8a: 
1:3fcea8a:         public TestFailedException(Throwable t)
1:3fcea8a:         {
1:3fcea8a:             super();
1:3fcea8a:             cause = t;
1:3fcea8a:         }
1:3fcea8a:         
1:3fcea8a:         public TestFailedException(String message)
1:3fcea8a:         {
1:3fcea8a:             super(message);
1:3fcea8a:             cause = null;
1:3fcea8a:         }
1:3fcea8a:         
1:3fcea8a:         public TestFailedException(String message, Throwable t)
1:3fcea8a:         {
1:3fcea8a:             super(message);
1:3fcea8a:             cause = t;
1:3fcea8a:         }
1:3fcea8a:         
1:3fcea8a:         public String toString()
1:3fcea8a:         {
1:3fcea8a:             if (cause != null) {
1:3fcea8a:                 return super.toString() + ": " + cause.toString();
1:3fcea8a:             } else {
1:3fcea8a:                 return super.toString();
1:3fcea8a:             }
1:3fcea8a:         }
1:3fcea8a:         
1:3fcea8a:         public void printStackTrace()
1:3fcea8a:         {
1:3fcea8a:             super.printStackTrace();
1:3fcea8a:             if (cause != null) {
1:3fcea8a:                 if (cause instanceof SQLException) {
1:3fcea8a:                     SetQueryTimeoutTest.printSQLException((SQLException)cause);
1:3fcea8a:                 } else {
1:3fcea8a:                     cause.printStackTrace();
1:3fcea8a:                 }
1:3fcea8a:             }
1:3fcea8a:         }
1:3fcea8a:     }
1:3fcea8a: 
1:3fcea8a:     /**
1:3fcea8a:      * Used for executing the SQL statements for setting up this test
1:3fcea8a:      * (the preparation phase). The queries testing setQueryTimeout()
1:3fcea8a:      * are run by the StatementExecutor class.
1:3fcea8a:      */
1:3fcea8a:     private static void exec(Connection connection,
1:3fcea8a:                              String queryString,
1:3fcea8a:                              Collection ignoreExceptions)
1:3fcea8a:         throws
1:3fcea8a:             TestFailedException
1:3fcea8a:     {
1:1373f5a:         Statement statement = null;
1:3fcea8a:         try {
1:1373f5a:             statement = connection.createStatement();
1:1373f5a:             statement.execute(queryString);
1:3fcea8a:         } catch (SQLException e) {
1:3fcea8a:             String sqlState = e.getSQLState();
1:3fcea8a:             if (!ignoreExceptions.contains(sqlState)) {
1:3fcea8a:                 throw new TestFailedException(e); // See finally block below
1:3fcea8a:             }
1:3fcea8a:         } finally {
1:3fcea8a:             if (statement != null) {
1:3fcea8a:                 try {
1:3fcea8a:                     statement.close();
1:3fcea8a:                 } catch (SQLException ee) {
1:3fcea8a:                     // This will discard an exception possibly thrown above :-(
1:3fcea8a:                     // But we don't worry too much about this, since:
1:3fcea8a:                     // 1. This is just a test
1:3fcea8a:                     // 2. We don't expect close() to throw
1:3fcea8a:                     // 3. If it does, this will be inspected by a developer
1:3fcea8a:                     throw new TestFailedException(ee);
1:3fcea8a:                 }
1:3fcea8a:             }
1:3fcea8a:         }
1:3fcea8a:     }
1:3fcea8a: 
1:3fcea8a:     // Convenience method
1:3fcea8a:     private static void exec(Connection connection,
1:3fcea8a:                              String queryString)
1:3fcea8a:         throws
1:3fcea8a:             TestFailedException
1:3fcea8a:     {
1:3fcea8a:         exec(connection, queryString, Collections.EMPTY_SET);
1:3fcea8a:     }
1:3fcea8a:     
1:3fcea8a:     private static void dropTables(Connection conn, String tablePrefix)
1:3fcea8a:         throws
1:3fcea8a:             TestFailedException
1:3fcea8a:     {
1:e18f54b:         HashSet<String> ignore = new HashSet<String>();
1:c83b48a:         ignore.add("42Y55");
1:3fcea8a:         
1:1373f5a:         exec(conn, "drop table " + tablePrefix + "_orig", ignore);
1:1373f5a:         exec(conn, "drop table " + tablePrefix + "_copy", ignore);
1:3fcea8a:     }
1:3fcea8a:     
1:3fcea8a:     private static void prepareTables(Connection conn, String tablePrefix)
1:3fcea8a:         throws
1:3fcea8a:             TestFailedException
1:3fcea8a:     {
1:3fcea8a:         System.out.println("Initializing tables with prefix " + tablePrefix);
1:3fcea8a: 
1:3fcea8a:         dropTables(conn, tablePrefix);
1:3fcea8a:         
7:3fcea8a:         exec(conn,
1:1373f5a:              "create table " + tablePrefix + "_orig (a int)");
1:3fcea8a: 
1:3fcea8a:         exec(conn,
1:1373f5a:              "create table " + tablePrefix + "_copy (a int)");
1:3fcea8a: 
1:3fcea8a:         exec(conn,
4:3fcea8a:              "insert into "
1:1373f5a:              + tablePrefix + "_orig"
1:1373f5a:              + " values(0),(1),(2),(3),(4),(5),(6)");
1:3fcea8a:     }
1:3fcea8a: 
1:1373f5a:     /**
1:1373f5a:      * This is the user-defined function which is called from our queries
1:1373f5a:      */
1:1373f5a:     public static int delay(int seconds, int value)
1:1373f5a:         throws
1:1373f5a:             SQLException
1:b9df96a:     {
1:c8ceb5f:         try {
1:1373f5a:             Thread.sleep(seconds * 1000);
1:1373f5a:         } catch (InterruptedException e) {
1:1373f5a:             // Ignore
1:1373f5a:         }
1:1373f5a:         return value;
1:1373f5a:     }
1:3fcea8a: 
1:3fcea8a:     private static void prepareForTimedQueries(Connection conn)
1:3fcea8a:         throws
1:3fcea8a:             TestFailedException
1:3fcea8a:     {
1:3fcea8a:         System.out.println("Preparing for testing queries with timeout");
1:3fcea8a: 
1:3fcea8a:         try {
1:3fcea8a:             conn.setAutoCommit(true);
1:3fcea8a:         } catch (SQLException e) {
1:3fcea8a:             throw new TestFailedException("Should not happen", e);
1:3fcea8a:         }
1:3fcea8a:         
1:3fcea8a:         try {
1:c8ceb5f:             exec(conn, "DROP FUNCTION DELAY");
1:c8ceb5f:         } catch (Exception e) {
1:c8ceb5f:             // Ignore
1:c8ceb5f:         }
1:3fcea8a: 
1:1373f5a:         exec(conn, "CREATE FUNCTION DELAY(SECONDS INTEGER, VALUE INTEGER) RETURNS INTEGER PARAMETER STYLE JAVA NO SQL LANGUAGE JAVA EXTERNAL NAME 'org.apache.derbyTesting.functionTests.tests.jdbcapi.SetQueryTimeoutTest.delay'");
1:3fcea8a: 
1:3fcea8a:         prepareTables(conn, "t");
1:3fcea8a:     }
1:3fcea8a:     
1:3fcea8a:     private static String getFetchQuery(String tablePrefix)
1:3fcea8a:     {
1:1373f5a:         /**
1:1373f5a:          * The reason for using the mod function here is to force
1:1373f5a:          * at least one invocation of ResultSet.next() to read
1:1373f5a:          * more than one row from the table before returning.
1:1373f5a:          * This is necessary since timeout is checked only when
1:1373f5a:          * reading rows from base tables, and when the first row
1:1373f5a:          * is read, the query still has not exceeded the timeout.
1:1373f5a:          */
1:1373f5a:         return "select a from " + tablePrefix + "_orig where mod(DELAY(1,a),3)=0";
1:3fcea8a:     }
1:3fcea8a:     
1:3fcea8a:     private static String getExecQuery(String tablePrefix)
1:3fcea8a:     {
1:3fcea8a:         return "insert into "
1:1373f5a:             + tablePrefix + "_copy select a from "
1:1373f5a:             + tablePrefix + "_orig where DELAY(1,1)=1";
1:3fcea8a:     }
1:3fcea8a:     
1:4eb3fed:     public static class StatementExecutor
1:3fcea8a:         extends
1:3fcea8a:             Thread
1:3fcea8a:     {
1:3fcea8a:         private PreparedStatement statement;
1:3fcea8a:         private boolean doFetch;
1:3fcea8a:         private int timeout;
1:3fcea8a:         private SQLException sqlException;
1:3fcea8a:         private String name;
1:3fcea8a:         private long highestRunTime;
1:3fcea8a:         
1:3fcea8a:         public StatementExecutor(PreparedStatement statement,
1:3fcea8a:                                  boolean doFetch,
1:3fcea8a:                                  int timeout)
1:3fcea8a:         {
1:3fcea8a:             this.statement = statement;
1:3fcea8a:             this.doFetch = doFetch;
1:3fcea8a:             this.timeout = timeout;
1:3fcea8a:             highestRunTime = 0;
1:3fcea8a:             sqlException = null;
1:1373f5a:             if (timeout > 0) {
1:3fcea8a:                 try {
1:3fcea8a:                     statement.setQueryTimeout(timeout);
1:3fcea8a:                 } catch (SQLException e) {
1:3fcea8a:                     sqlException = e;
1:3fcea8a:                 }
1:3fcea8a:             }
1:1373f5a:         }
1:3fcea8a:         
1:3fcea8a:         private void setHighestRunTime(long runTime)
1:3fcea8a:         {
1:3fcea8a:             synchronized (this) {
1:3fcea8a:                 highestRunTime = runTime;
1:3fcea8a:             }
1:3fcea8a:         }
1:3fcea8a:         
1:3fcea8a:         public long getHighestRunTime()
1:3fcea8a:         {
1:3fcea8a:             synchronized (this) {
1:3fcea8a:                 return highestRunTime;
1:3fcea8a:             }
1:3fcea8a:         }
1:3fcea8a:         
1:3fcea8a:         private boolean fetchRow(ResultSet resultSet)
1:3fcea8a:             throws
1:3fcea8a:                 SQLException
1:3fcea8a:         {
1:3fcea8a:             long startTime = System.currentTimeMillis();
1:3fcea8a:             boolean hasNext = resultSet.next();
1:3fcea8a:             long endTime = System.currentTimeMillis();
1:3fcea8a:             long runTime = endTime - startTime;
1:3fcea8a:             if (runTime > highestRunTime) setHighestRunTime(runTime);
1:3fcea8a:             return hasNext;
1:3fcea8a:         }
1:3fcea8a: 
1:3fcea8a:         public void run()
1:3fcea8a:         {
1:3fcea8a:             if (sqlException != null)
1:3fcea8a:                 return;
1:3fcea8a: 
1:3fcea8a:             ResultSet resultSet = null;
1:3fcea8a: 
1:3fcea8a:             try {
1:3fcea8a:                 if (doFetch) {
1:3fcea8a:                     long startTime = System.currentTimeMillis();
1:3fcea8a:                     resultSet = statement.executeQuery();
1:3fcea8a:                     long endTime = System.currentTimeMillis();
1:3fcea8a:                     setHighestRunTime(endTime - startTime);
1:3fcea8a:                     while (fetchRow(resultSet)) {
1:3fcea8a:                         yield();
1:3fcea8a:                     }
1:3fcea8a:                 } else {
1:3fcea8a:                     long startTime = System.currentTimeMillis();
2:3fcea8a:                     statement.execute();
1:3fcea8a:                     long endTime = System.currentTimeMillis();
1:3fcea8a:                     setHighestRunTime(endTime - startTime);
1:3fcea8a:                 }
1:3fcea8a:             } catch (SQLException e) {
1:3fcea8a:                 synchronized (this) {
1:3fcea8a:                     sqlException = e;
1:3fcea8a:                 }
1:3fcea8a:             } finally {
1:3fcea8a:                 if (resultSet != null) {
1:3fcea8a:                     try {
1:3fcea8a:                         resultSet.close();
2:3fcea8a:                     } catch (SQLException ex) {
1:3fcea8a:                         if (sqlException != null) {
1:3fcea8a:                             System.err.println("Discarding previous exception");
1:3fcea8a:                             sqlException.printStackTrace();
1:3fcea8a:                         }
1:3fcea8a:                         sqlException = ex;
1:3fcea8a:                     }
1:3fcea8a:                 }
1:3fcea8a:             }
1:3fcea8a:         }
1:3fcea8a: 
1:3fcea8a:         public SQLException getSQLException()
1:3fcea8a:         {
1:3fcea8a:             synchronized (this) {
1:3fcea8a:                 return sqlException;
1:3fcea8a:             }
1:3fcea8a:         }
1:3fcea8a:     }
1:3fcea8a: 
1:3fcea8a:     /**
1:3fcea8a:      * This method compares a thrown SQLException's SQLState value
1:3fcea8a:      * to an expected SQLState. If they do not match, a
1:3fcea8a:      * TestFailedException is thrown with the given message string.
1:3fcea8a:      */
1:3fcea8a:     private static void expectException(String expectSqlState,
1:3fcea8a:                                         SQLException sqlException,
1:3fcea8a:                                         String failMsg)
1:3fcea8a:         throws
1:3fcea8a:             TestFailedException
1:3fcea8a:     {
1:3fcea8a:         if (sqlException == null) {
1:3fcea8a:             throw new TestFailedException(failMsg);
1:3fcea8a:         } else {
1:3fcea8a:             String sqlState = sqlException.getSQLState();
1:c83b48a:             if (!expectSqlState.equals(sqlState)) {
1:3fcea8a:                 throw new TestFailedException(sqlException);
1:3fcea8a:             }
1:3fcea8a:         }
1:3fcea8a:     }
1:3fcea8a: 
1:3fcea8a:     // A convenience method which wraps a SQLException
1:3fcea8a:     private static PreparedStatement prepare(Connection conn, String query)
1:3fcea8a:         throws
1:3fcea8a:             TestFailedException
1:3fcea8a:     {
1:3fcea8a:         try {
1:3fcea8a:             return conn.prepareStatement(query);
1:3fcea8a:         } catch (SQLException e) {
1:3fcea8a:             throw new TestFailedException(e);
1:3fcea8a:         }
1:3fcea8a:     }
1:3fcea8a: 
1:3fcea8a:     /**
1:3fcea8a:      * Part 1 of this test.
1:3fcea8a:      */
1:3fcea8a:     private static void testTimeoutWithFetch(Connection conn1,
2:3fcea8a:                                              Connection conn2)
1:3fcea8a:         throws
1:3fcea8a:             TestFailedException
1:3fcea8a:     {
1:3fcea8a:         System.out.println("Testing timeout with fetch operations");
1:3fcea8a: 
1:3fcea8a:         try {
1:3fcea8a:             conn1.setAutoCommit(false);
1:3fcea8a:             conn2.setAutoCommit(false);
1:3fcea8a:         } catch (SQLException e) {
1:3fcea8a:             throw new TestFailedException("Should not happen", e);
1:3fcea8a:         }
1:3fcea8a:         
1:3fcea8a:         // The idea with these 4 statements is as follows:
1:3fcea8a:         // A - should time out
1:3fcea8a:         // B - different stmt on the same connection; should NOT time out
1:3fcea8a:         // C - different stmt on different connection; should NOT time out
1:3fcea8a:         // D - here just to create equal contention on conn1 and conn2
1:3fcea8a: 
1:3fcea8a:         PreparedStatement statementA = prepare(conn1, getFetchQuery("t"));
1:2f02954:         PreparedStatement statementB = prepare(conn1, getFetchQuery("t"));
1:1373f5a:         PreparedStatement statementC = prepare(conn2, getFetchQuery("t"));
1:1373f5a:         PreparedStatement statementD = prepare(conn2, getFetchQuery("t"));
1:3fcea8a: 
1:3fcea8a:         StatementExecutor[] statementExecutor = new StatementExecutor[4];
1:3fcea8a:         statementExecutor[0] = new StatementExecutor(statementA, true, TIMEOUT);
1:3fcea8a:         statementExecutor[1] = new StatementExecutor(statementB, true, 0);
1:3fcea8a:         statementExecutor[2] = new StatementExecutor(statementC, true, 0);
1:3fcea8a:         statementExecutor[3] = new StatementExecutor(statementD, true, 0);
1:3fcea8a:         
1:3fcea8a:         for (int i = 3; i >= 0; --i) {
1:3fcea8a:             statementExecutor[i].start();
1:3fcea8a:         }
1:3fcea8a:         
1:3fcea8a:         for (int i = 0; i < 4; ++i) {
1:3fcea8a:             try {
1:3fcea8a:                 statementExecutor[i].join();
1:3fcea8a:             } catch (InterruptedException e) {
1:3fcea8a:                 throw new TestFailedException("Should never happen", e);
1:3fcea8a:             }
1:3fcea8a:         }
1:3fcea8a: 
1:3fcea8a:         /**
1:3fcea8a:          * Actually, there is no guarantee that setting a query timeout
1:3fcea8a:          * for a statement will actually cause a timeout, even if execution
1:3fcea8a:          * of the statement takes longer than the specified timeout.
1:3fcea8a:          *
1:3fcea8a:          * However, these queries execute significantly longer than the
1:3fcea8a:          * specified query timeout. Also, the cancellation mechanism
1:3fcea8a:          * implemented should be quite responsive. In sum, we expect
1:3fcea8a:          * the statement to always time out.
1:3fcea8a:          *
1:3fcea8a:          * If it does not time out, however, we print the highest
1:3fcea8a:          * execution time for the query, as an assistance in determining
1:3fcea8a:          * why it failed. Compare the number to the TIMEOUT constant
1:3fcea8a:          * in this class (note that the TIMEOUT constant is in seconds,
1:3fcea8a:          * while the execution time is in milliseconds). 
1:3fcea8a:          */
1:c83b48a:         expectException("XCL52",
1:3fcea8a:                         statementExecutor[0].getSQLException(),
1:3fcea8a:                         "fetch did not time out. Highest execution time: "
1:3fcea8a:                         + statementExecutor[0].getHighestRunTime() + " ms");
1:3fcea8a: 
2:3fcea8a:         System.out.println("Statement 0 timed out");
1:3fcea8a: 
1:3fcea8a:         for (int i = 1; i < 4; ++i) {
1:3fcea8a:             SQLException sqlException = statementExecutor[i].getSQLException();
1:3fcea8a:             if (sqlException != null) {
1:3fcea8a:                 throw new TestFailedException("Unexpected exception in " + i,
1:3fcea8a:                                               sqlException);
1:3fcea8a:             }
1:3fcea8a:             System.out.println("Statement " + i + " completed");
1:3fcea8a:         }
1:3fcea8a: 
1:3fcea8a:         try {
2:3fcea8a:             statementA.close();
2:3fcea8a:             statementB.close();
1:3fcea8a:             statementC.close();
1:3fcea8a:             statementD.close();
1:3fcea8a:             conn1.commit();
1:3fcea8a:             conn2.commit();
1:3fcea8a:         } catch (SQLException e) {
1:3fcea8a:             throw new TestFailedException(e);
1:3fcea8a:         }
1:3fcea8a:     }
1:3fcea8a: 
1:3fcea8a:     /**
1:3fcea8a:      * Part two of this test.
1:3fcea8a:      */
1:1373f5a:     private static void testTimeoutWithExec(Connection[] connections)
1:3fcea8a:         throws
1:3fcea8a:             TestFailedException
1:3fcea8a:     {
1:3fcea8a:         System.out.println("Testing timeout with an execute operation");
1:3fcea8a: 
1:1373f5a:         for (int i = 0; i < connections.length; ++i) {
1:3fcea8a:             try {
1:1373f5a:                 connections[i].setAutoCommit(true);
1:3fcea8a:             } catch (SQLException e) {
1:3fcea8a:                 throw new TestFailedException("Should not happen", e);
1:3fcea8a:             }
1:3fcea8a:         }
1:3fcea8a: 
1:1373f5a:         PreparedStatement statements[] = new PreparedStatement[connections.length];
1:1373f5a:         for (int i = 0; i < statements.length; ++i) {
1:1373f5a:             statements[i] = prepare(connections[i], getExecQuery("t"));
1:1373f5a:         }
1:3fcea8a: 
1:1373f5a:         StatementExecutor[] executors = new StatementExecutor[statements.length];
1:1373f5a:         for (int i = 0; i < executors.length; ++i) {
1:1373f5a:             int timeout =
1:1373f5a:                 (i % 2 == 0)
1:1373f5a:                 ? TIMEOUT
1:1373f5a:                 : 0;
1:1373f5a:             executors[i] = new StatementExecutor(statements[i], false, timeout);
1:1373f5a:         }
1:3fcea8a: 
1:1373f5a:         for (int i = 0; i < executors.length; ++i) {
1:1373f5a:             executors[i].start();
1:1373f5a:         }
1:3fcea8a: 
1:1373f5a:         for (int i = 0; i < executors.length; ++i) {
1:3fcea8a:             try {
1:1373f5a:                 executors[i].join();
1:3fcea8a:             } catch (InterruptedException e) {
1:3fcea8a:                 throw new TestFailedException("Should never happen", e);
1:1373f5a:             }
1:1373f5a:         }
1:3fcea8a:         
1:3fcea8a:         /**
1:3fcea8a:          * Actually, there is no guarantee that setting a query timeout
1:3fcea8a:          * for a statement will actually cause a timeout, even if execution
1:3fcea8a:          * of the statement takes longer than the specified timeout.
1:3fcea8a:          *
1:3fcea8a:          * However, these queries execute significantly longer than the
1:3fcea8a:          * specified query timeout. Also, the cancellation mechanism
1:3fcea8a:          * implemented should be quite responsive. In sum, we expect
1:3fcea8a:          * the statement to always time out.
1:3fcea8a:          *
1:3fcea8a:          * If it does not time out, however, we print the highest
1:3fcea8a:          * execution time for the query, as an assistance in determining
1:3fcea8a:          * why it failed. Compare the number to the TIMEOUT constant
1:3fcea8a:          * in this class (note that the TIMEOUT constant is in seconds,
1:3fcea8a:          * while the execution time is in milliseconds). 
1:3fcea8a:          */
1:1373f5a:         for (int i = 0; i < executors.length; ++i) {
1:1373f5a:             int timeout =
1:1373f5a:                 (i % 2 == 0)
1:1373f5a:                 ? TIMEOUT
1:1373f5a:                 : 0;
1:1373f5a:             if (timeout > 0) {
1:c83b48a:                 expectException("XCL52",
1:1373f5a:                                 executors[i].getSQLException(),
1:3fcea8a:                                 "exec did not time out. Execution time: "
1:1373f5a:                                 + executors[i].getHighestRunTime() + " ms");
1:1373f5a:             } else {
1:1373f5a:                 SQLException sqlException = executors[i].getSQLException();
1:3fcea8a:                 if (sqlException != null) {
1:3fcea8a:                     throw new TestFailedException(sqlException);
1:3fcea8a:                 }
1:3fcea8a:             }
1:3fcea8a:         }
1:3fcea8a: 
1:1373f5a:         System.out.println("Statements that should time out timed out, and statements that should complete completed");
1:3fcea8a: 
1:1373f5a:         for (int i = 0; i < statements.length; ++i) {
1:3fcea8a:             try {
1:1373f5a:                 statements[i].close();
1:3fcea8a:             } catch (SQLException e) {
1:3fcea8a:                 throw new TestFailedException(e);
1:1373f5a:             }
1:1373f5a:         }
1:1373f5a:     }
1:3fcea8a:     
1:3fcea8a:     private static void testInvalidTimeoutValue(Connection conn)
1:3fcea8a:         throws
1:3fcea8a:             TestFailedException
1:3fcea8a:     {
1:3fcea8a:         System.out.println("Testing setting a negative timeout value");
1:3fcea8a: 
1:3fcea8a:         try {
1:3fcea8a:             conn.setAutoCommit(true);
1:3fcea8a:         } catch (SQLException e) {
1:3fcea8a:             throw new TestFailedException("Should not happen", e);
1:3fcea8a:         }
1:3fcea8a: 
1:3fcea8a:         // Create statement
1:3fcea8a:         PreparedStatement stmt = null;
1:3fcea8a:         try {
1:3fcea8a:             stmt = conn.prepareStatement("select * from sys.systables");
1:3fcea8a:         } catch (SQLException e) {
1:3fcea8a:             throw new TestFailedException("Should not happen", e);
1:3fcea8a:         }
1:3fcea8a:         
1:3fcea8a:         // Set (invalid) timeout value - expect exception
1:3fcea8a:         try {
1:3fcea8a:             stmt.setQueryTimeout(-1);
1:3fcea8a:         } catch (SQLException e) {
1:c83b48a:             expectException("XJ074", e,
1:3fcea8a:                         "negative timeout value should give exception");
1:3fcea8a:         }
1:3fcea8a:         
1:3fcea8a:         System.out.println("Negative timeout value caused exception, as expected");
1:3fcea8a:         
1:3fcea8a:         // Execute the statement and fetch result
1:3fcea8a:         ResultSet rs = null;
1:3fcea8a:         try {
1:3fcea8a:             rs = stmt.executeQuery();
1:3fcea8a:             System.out.println("Execute returned a ResultSet");
1:3fcea8a:             rs.close();
1:3fcea8a:         } catch (SQLException e) {
1:3fcea8a:             throw new TestFailedException("Should not happen", e);
1:3fcea8a:         } finally {
1:3fcea8a:             try {
1:3fcea8a:                 stmt.close();
1:3fcea8a:             } catch (SQLException e) {
1:3fcea8a:                 // This will discard an exception possibly thrown above :-(
1:3fcea8a:                 // But we don't worry too much about this, since:
1:3fcea8a:                 // 1. This is just a test
1:3fcea8a:                 // 2. We don't expect close() to throw
1:3fcea8a:                 // 3. If it does, this will be inspected by a developer
1:3fcea8a:                 throw new TestFailedException("close should not throw", e);
1:3fcea8a:             }
1:3fcea8a:         }
1:3fcea8a:     }
1:3fcea8a: 
1:b9df96a:     /** This tests timeout with executeUpdate call. */
1:b9df96a:     private static void testTimeoutWithExecuteUpdate(Connection conn)
1:c83b48a:         throws TestFailedException
1:c83b48a:     {
1:b9df96a:     	System.out.println("Testing timeout with executeUpdate call.");
1:b9df96a:         try{
1:b9df96a:             Statement stmt = conn.createStatement();
1:b9df96a:             stmt.setQueryTimeout(TIMEOUT);
1:b9df96a:             stmt.executeUpdate(getExecQuery("t"));    
1:b9df96a:         } catch (SQLException sqle) {
2:c83b48a:         	expectException("XCL52", sqle, "Should have timed out.");
1:b9df96a:         }
1:b9df96a:     }
1:3fcea8a:     
1:c83b48a:     /** Test for DERBY-1692. */
1:c83b48a:     private static void testRememberTimeoutValue(Connection conn)
1:b9df96a:         throws TestFailedException
1:1373f5a:     {
1:c83b48a:         String sql = getFetchQuery("t");
1:c83b48a:         try {
1:c83b48a:             Statement stmt = conn.createStatement();
1:c83b48a:             testStatementRemembersTimeout(stmt);
1:c83b48a:             PreparedStatement ps = conn.prepareStatement(sql);
1:c83b48a:             testStatementRemembersTimeout(ps);
1:c83b48a:             CallableStatement cs = conn.prepareCall(sql);
1:c83b48a:             testStatementRemembersTimeout(cs);
1:c83b48a:         } catch (SQLException sqle) {
1:c83b48a:             throw new TestFailedException("Should not happen", sqle);
1:c83b48a:         }
1:c83b48a:     }
1:c83b48a: 
1:c83b48a:     /** Test that a statement remembers its timeout value when executed
1:c83b48a:      * multiple times. */
1:c83b48a:     private static void testStatementRemembersTimeout(Statement stmt)
1:c83b48a:         throws SQLException, TestFailedException
1:c83b48a:     {
1:c83b48a:         System.out.println("Testing that Statement remembers timeout.");
1:c83b48a:         stmt.setQueryTimeout(1);
1:2935711:         long runTime=0;
1:c83b48a:         for (int i = 0; i < 3; i++) {
1:c83b48a:             try {
1:2935711:                 long startTime = System.currentTimeMillis();
1:e71eb46:                 ResultSet rs = stmt.executeQuery(getFetchQuery("t"));
1:c83b48a:                 while (rs.next());
1:2935711:                 long endTime = System.currentTimeMillis();
1:2935711:                 runTime = endTime - startTime;
1:2935711:                 throw new TestFailedException("Should have timed out, for " +
1:2935711:                     "statement, iteration: " +i+ ", took (millis): "+runTime);
1:c83b48a:             } catch (SQLException sqle) {
1:2935711:                 expectException("XCL52", sqle, "Should have timed out, got " +
1:2935711:                     "unexpected exception, for statement, iteration: " + i + 
1:2935711:                     ", time taken (millis): " + runTime);
1:c83b48a:             }
1:c83b48a:         }
1:c83b48a:         stmt.close();
1:c83b48a:     }
1:c83b48a: 
1:c83b48a:     /** Test that a prepared statement remembers its timeout value when
1:c83b48a:      * executed multiple times. */
1:c83b48a:     private static void testStatementRemembersTimeout(PreparedStatement ps)
1:c83b48a:         throws SQLException, TestFailedException
1:c83b48a:     {
1:c83b48a:         String name = (ps instanceof CallableStatement) ?
1:c83b48a:             "CallableStatement" : "PreparedStatement";
1:c83b48a:         System.out.println("Testing that " + name + " remembers timeout.");
1:c83b48a:         ps.setQueryTimeout(1);
1:c83b48a:         for (int i = 0; i < 3; i++) {
1:2935711:             long runTime=0;
1:c83b48a:             try {
1:2935711:                 long startTime = System.currentTimeMillis();
1:2b60655:                 ResultSet rs = ps.executeQuery();
1:c83b48a:                 while (rs.next()); 
1:2935711:                 long endTime = System.currentTimeMillis();
1:2935711:                 runTime = endTime - startTime;
1:2935711:                 throw new TestFailedException(
1:2935711:                     "Should have timed out, for " + name + ", on iteration " 
1:2935711:                     + i + ", runtime(millis): " + runTime);
1:c83b48a:            } catch (SQLException sqle) {
1:2935711:                 expectException("XCL52", sqle, "Should have timed out, " +
1:2935711:                     "got unexpected exception, for " + name + ", on iteration "
1:2935711:                     + i + ", runtime(millis): " + runTime);
1:c83b48a:             }
1:c83b48a:         }
1:c83b48a:         ps.close();
1:c83b48a:     }
1:c83b48a: 
1:3fcea8a:     /**
1:3fcea8a:      * Main program, makes this class invocable from the command line
1:3fcea8a:      */
1:3fcea8a:     public static void main(String[] args)
1:3fcea8a:     {
1:3fcea8a:         new SetQueryTimeoutTest().go(args);
1:3fcea8a:     }
1:3fcea8a: 
1:3fcea8a:     /**
1:3fcea8a:      * The actual main bulk of this test.
1:3fcea8a:      * Sets up the environment, prepares tables,
1:c83b48a:      * runs the tests, and shuts down.
1:3fcea8a:      */
1:3fcea8a:     public void go(String[] args)
1:3fcea8a:     {
1:3fcea8a:         System.out.println("Test SetQueryTimeoutTest starting");
1:3fcea8a: 
1:1373f5a:         Connection[] connections = new Connection[CONNECTIONS];
1:3fcea8a: 
1:3fcea8a:         try {
1:3fcea8a:             // Load the JDBC Driver class
1:3fcea8a:             // use the ij utility to read the property file and
1:3fcea8a:             // create connections
1:3fcea8a:             ij.getPropertyArg(args);
2:1373f5a:             for (int i = 0; i < connections.length; ++i) {
1:1373f5a:                 connections[i] = ij.startJBMS();
4:1373f5a:             }
1:3fcea8a: 
1:3fcea8a:             System.out.println("Got connections");
1:3fcea8a: 
1:1373f5a:             for (int i = 0; i < connections.length; ++i) {
1:1373f5a:                 connections[i].setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);
1:3fcea8a:             }
1:3fcea8a: 
1:1373f5a:             prepareForTimedQueries(connections[0]);
1:1373f5a:             testTimeoutWithFetch(connections[0], connections[1]);
1:1373f5a:             testTimeoutWithExec(connections);
1:1373f5a:             testInvalidTimeoutValue(connections[0]);
1:c83b48a:             testRememberTimeoutValue(connections[0]);
1:b9df96a:             testTimeoutWithExecuteUpdate(connections[0]);
1:3fcea8a:   
1:3fcea8a:             System.out.println("Test SetQueryTimeoutTest PASSED");
1:3fcea8a:         } catch (Throwable e) {
1:3fcea8a:             System.out.println("Test SetQueryTimeoutTest FAILED");
1:3fcea8a:             e.printStackTrace();
1:3fcea8a:         } finally {
1:1373f5a:             for (int i = connections.length - 1; i >= 0; --i) {
1:1373f5a:                 if (connections[i] != null) {
1:3fcea8a:                     try {
1:1373f5a:                         connections[i].close();
1:3fcea8a:                     } catch (SQLException ex) {
2:3fcea8a:                         printSQLException(ex);
1:3fcea8a:                     }
1:3fcea8a:                 }
1:3fcea8a:             }
1:3fcea8a:             System.out.println("Closed connections");
1:3fcea8a:         }
1:3fcea8a:     }
1:3fcea8a: }
============================================================================
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:2b60655
/////////////////////////////////////////////////////////////////////////
1:                 ResultSet rs = ps.executeQuery();
commit:e71eb46
/////////////////////////////////////////////////////////////////////////
1:                 ResultSet rs = stmt.executeQuery(getFetchQuery("t"));
commit:2935711
/////////////////////////////////////////////////////////////////////////
1:         long runTime=0;
1:                 long startTime = System.currentTimeMillis();
1:                 long endTime = System.currentTimeMillis();
1:                 runTime = endTime - startTime;
1:                 throw new TestFailedException("Should have timed out, for " +
1:                     "statement, iteration: " +i+ ", took (millis): "+runTime);
1:                 expectException("XCL52", sqle, "Should have timed out, got " +
1:                     "unexpected exception, for statement, iteration: " + i + 
1:                     ", time taken (millis): " + runTime);
/////////////////////////////////////////////////////////////////////////
1:             long runTime=0;
1:                 long startTime = System.currentTimeMillis();
1:                 long endTime = System.currentTimeMillis();
1:                 runTime = endTime - startTime;
1:                 throw new TestFailedException(
1:                     "Should have timed out, for " + name + ", on iteration " 
1:                     + i + ", runtime(millis): " + runTime);
1:                 expectException("XCL52", sqle, "Should have timed out, " +
1:                     "got unexpected exception, for " + name + ", on iteration "
1:                     + i + ", runtime(millis): " + runTime);
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:e18f54b
/////////////////////////////////////////////////////////////////////////
1:         HashSet<String> ignore = new HashSet<String>();
commit:2f02954
/////////////////////////////////////////////////////////////////////////
1:         PreparedStatement statementB = prepare(conn1, getFetchQuery("t"));
commit:c83b48a
/////////////////////////////////////////////////////////////////////////
1: import java.sql.CallableStatement;
/////////////////////////////////////////////////////////////////////////
1:  * This test consists of four parts:
/////////////////////////////////////////////////////////////////////////
1:  * 4. Tests that the query timeout value is not forgotten after the execution
1:  *    of a statement (DERBY-1692).
/////////////////////////////////////////////////////////////////////////
1:         ignore.add("42Y55");
/////////////////////////////////////////////////////////////////////////
1:             if (!expectSqlState.equals(sqlState)) {
/////////////////////////////////////////////////////////////////////////
1:         expectException("XCL52",
/////////////////////////////////////////////////////////////////////////
1:                 expectException("XCL52",
/////////////////////////////////////////////////////////////////////////
1:             expectException("XJ074", e,
/////////////////////////////////////////////////////////////////////////
1:     /** Test for DERBY-1692. */
1:     private static void testRememberTimeoutValue(Connection conn)
1:         throws TestFailedException
1:     {
1:         String sql = getFetchQuery("t");
1:         try {
1:             Statement stmt = conn.createStatement();
1:             testStatementRemembersTimeout(stmt);
1:             PreparedStatement ps = conn.prepareStatement(sql);
1:             testStatementRemembersTimeout(ps);
1:             CallableStatement cs = conn.prepareCall(sql);
1:             testStatementRemembersTimeout(cs);
1:         } catch (SQLException sqle) {
1:             throw new TestFailedException("Should not happen", sqle);
1:         }
1:     }
1: 
1:     /** Test that a statement remembers its timeout value when executed
1:      * multiple times. */
1:     private static void testStatementRemembersTimeout(Statement stmt)
1:         throws SQLException, TestFailedException
1:     {
1:         System.out.println("Testing that Statement remembers timeout.");
1:         stmt.setQueryTimeout(1);
1:         for (int i = 0; i < 3; i++) {
1:             try {
0:                 ResultSet rs = stmt.executeQuery(getFetchQuery("t"));
1:                 while (rs.next());
0:                 throw new TestFailedException("Should have timed out.");
1:             } catch (SQLException sqle) {
1:                 expectException("XCL52", sqle, "Should have timed out.");
1:             }
1:         }
1:         stmt.close();
1:     }
1: 
1:     /** Test that a prepared statement remembers its timeout value when
1:      * executed multiple times. */
1:     private static void testStatementRemembersTimeout(PreparedStatement ps)
1:         throws SQLException, TestFailedException
1:     {
1:         String name = (ps instanceof CallableStatement) ?
1:             "CallableStatement" : "PreparedStatement";
1:         System.out.println("Testing that " + name + " remembers timeout.");
1:         ps.setQueryTimeout(1);
1:         for (int i = 0; i < 3; i++) {
1:             try {
0:                 ResultSet rs = ps.executeQuery();
1:                 while (rs.next()); 
0:                 throw new TestFailedException("Should have timed out.");
1:            } catch (SQLException sqle) {
1:                 expectException("XCL52", sqle, "Should have timed out.");
1:             }
1:         }
1:         ps.close();
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:      * runs the tests, and shuts down.
/////////////////////////////////////////////////////////////////////////
1:             testRememberTimeoutValue(connections[0]);
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:4eb3fed
/////////////////////////////////////////////////////////////////////////
1:     public static class StatementExecutor
commit:8e4ceb1
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derbyTesting.functionTests.tests.jdbcapi.SetQueryTimeoutTest
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:d029255
/////////////////////////////////////////////////////////////////////////
commit:3fcea8a
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Derby - Class org.apache.derbyTesting.functionTests.tests.lang.SetQueryTimeoutTest
1: 
0:    Copyright 2005 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.tests.jdbcapi;
1: 
1: import java.sql.Connection;
1: import java.sql.SQLException;
1: import java.sql.Statement;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: 
1: import java.util.Collection;
1: import java.util.HashSet;
1: import java.util.Collections;
1: 
1: import org.apache.derby.tools.ij;
0: import org.apache.derby.iapi.reference.SQLState;
1: 
1: /**
1:  * Functional test for the Statement.setQueryTimeout() method.
1:  *
0:  * This test consists of three parts:
1:  *
1:  * 1. Executes a SELECT query in 4 different threads concurrently.
0:  *    The query is designed to make the execution time for each
0:  *    ResultSet.next() operation unpredictable, and in the order
0:  *    of seconds for many of them. The executeQuery() call finishes
0:  *    quickly, but the fetch operations may take longer time than
0:  *    the timeout value set. Hence, this part tests getting timeouts
0:  *    from calls to ResultSet.next().
1:  * 
1:  *    Two connections are used, two threads execute their statement
1:  *    in the context of one connection, the other two threads in the
1:  *    context of the other connection. Of the 4 threads, only one
1:  *    executes its statement with a timeout value. This way, the test
1:  *    ensures that the correct statement is affected by setQueryTimeout(),
1:  *    regardless of what connection/transaction it and other statements
1:  *    are executed in the context of.
1:  *    
0:  * 2. Executes a long-running INSERT query in two threads.
1:  *    This part tests getting timeouts from calls to Statement.execute().
1:  *    Each thread executes the query in the context of a separate
1:  *    connection. There is no point in executing multiple statements
1:  *    on the same connection; since only one statement per connection
1:  *    executes at a time, there will be no interleaving of execution
1:  *    between them (contrary to the first part of this test, where
1:  *    calls to ResultSet.next() may be interleaved between the different
1:  *    threads).
1:  *
0:  *    Only one thread executes its statement with a timeout value set,
0:  *    this is to verify that the correct statement is affected by the
0:  *    timeout, while the other statement executes to completion.
1:  *
1:  * 3. Sets an invalid (negative) timeout. Verifies that the correct
1:  *    exception is thrown.
1:  *
0:  * @author oyvind.bakksjo@sun.com
1:  */
1: public class SetQueryTimeoutTest
1: {
0:     private static final int TIMEOUT = 3; // In seconds
1: 
1:     private static void printSQLException(SQLException e)
1:     {
1:         while (e != null)
1:         {
1:             e.printStackTrace();
1:             e = e.getNextException();
1:         }
1:     }
1: 
1:     /**
1:      * This Exception class is used for getting fail-fast behaviour in
1:      * this test. There is no point in wasting cycles running a test to
1:      * the end when we know that it has failed.
1:      *
1:      * In order to enable chaining of exceptions in J2ME, this class defines
1:      * its own "cause", duplicating existing functionality in J2SE.
1:      */
1:     private static class TestFailedException
1:         extends
1:             Exception
1:     {
1:         private Throwable cause;
1: 
1:         public TestFailedException(Throwable t)
1:         {
1:             super();
1:             cause = t;
1:         }
1:         
1:         public TestFailedException(String message)
1:         {
1:             super(message);
1:             cause = null;
1:         }
1:         
1:         public TestFailedException(String message, Throwable t)
1:         {
1:             super(message);
1:             cause = t;
1:         }
1:         
1:         public String toString()
1:         {
1:             if (cause != null) {
1:                 return super.toString() + ": " + cause.toString();
1:             } else {
1:                 return super.toString();
1:             }
1:         }
1:         
1:         public void printStackTrace()
1:         {
1:             super.printStackTrace();
1:             if (cause != null) {
1:                 if (cause instanceof SQLException) {
1:                     SetQueryTimeoutTest.printSQLException((SQLException)cause);
1:                 } else {
1:                     cause.printStackTrace();
1:                 }
1:             }
1:         }
1:     }
1: 
1:     /**
1:      * Used for executing the SQL statements for setting up this test
1:      * (the preparation phase). The queries testing setQueryTimeout()
1:      * are run by the StatementExecutor class.
1:      */
1:     private static void exec(Connection connection,
1:                              String queryString,
1:                              Collection ignoreExceptions)
1:         throws
1:             TestFailedException
1:     {
0:         PreparedStatement statement = null;
1:         try {
0:             statement = connection.prepareStatement(queryString);
1:             statement.execute();
1:         } catch (SQLException e) {
1:             String sqlState = e.getSQLState();
1:             if (!ignoreExceptions.contains(sqlState)) {
1:                 throw new TestFailedException(e); // See finally block below
1:             }
1:         } finally {
1:             if (statement != null) {
1:                 try {
1:                     statement.close();
1:                 } catch (SQLException ee) {
1:                     // This will discard an exception possibly thrown above :-(
1:                     // But we don't worry too much about this, since:
1:                     // 1. This is just a test
1:                     // 2. We don't expect close() to throw
1:                     // 3. If it does, this will be inspected by a developer
1:                     throw new TestFailedException(ee);
1:                 }
1:             }
1:         }
1:     }
1: 
1:     // Convenience method
1:     private static void exec(Connection connection,
1:                              String queryString)
1:         throws
1:             TestFailedException
1:     {
1:         exec(connection, queryString, Collections.EMPTY_SET);
1:     }
1:     
1:     private static void dropTables(Connection conn, String tablePrefix)
1:         throws
1:             TestFailedException
1:     {
0:         Collection ignore = new HashSet();
0:         ignore.add(SQLState.LANG_OBJECT_DOES_NOT_EXIST.substring(0,5));
1:         
0:         exec(conn, "drop table " + tablePrefix + "0", ignore);
0:         exec(conn, "drop table " + tablePrefix + "1", ignore);
0:         exec(conn, "drop table " + tablePrefix + "2", ignore);
0:         exec(conn, "drop table " + tablePrefix + "3", ignore);
0:         exec(conn, "drop table " + tablePrefix + "4", ignore);
0:         exec(conn, "drop table " + tablePrefix + "5", ignore);
1:     }
1:     
1:     private static void prepareTables(Connection conn, String tablePrefix)
1:         throws
1:             TestFailedException
1:     {
1:         System.out.println("Initializing tables with prefix " + tablePrefix);
1: 
1:         dropTables(conn, tablePrefix);
1:         
1:         exec(conn,
0:              "create table " + tablePrefix + "1 (a int, b char(1))");
1: 
1:         exec(conn,
0:              "create table " + tablePrefix + "2 (a int, b char(2))");
1:         
1:         exec(conn,
0:              "create table " + tablePrefix + "3 (a int, b char(4))");
1: 
1:         exec(conn,
0:              "create table " + tablePrefix + "4 (a int, b char(6))");
1: 
1:         exec(conn,
0:              "create table " + tablePrefix + "5 (a int, b char(8))");
1: 
1:         exec(conn,
1:              "insert into "
0:              + tablePrefix + "1"
0:              + " values(3,'a')"
0:              + ",(7,'b')"
0:              + ",(13,'c')"
0:              + ",(37,'d')"
0:              + ",(141,'e')"
0:              + ",(1,'f')");
1:         
1: 
1:         exec(conn,
1:              "insert into "
0:              + tablePrefix + "2 select "
0:              + tablePrefix + "1.a+"
0:              + tablePrefix + "x.a,"
0:              + tablePrefix + "1.b||"
0:              + tablePrefix + "x.b from "
0:              + tablePrefix + "1 join "
0:              + tablePrefix + "1 as "
0:              + tablePrefix + "x on 1=1");
1:         
1:         exec(conn,
1:              "insert into "
0:              + tablePrefix + "3 select "
0:              + tablePrefix + "2.a+"
0:              + tablePrefix + "x.a,"
0:              + tablePrefix + "2.b||"
0:              + tablePrefix + "x.b from "
0:              + tablePrefix + "2 join "
0:              + tablePrefix + "2 as "
0:              + tablePrefix + "x on 1=1");
1:         
1:         exec(conn,
1:              "insert into "
0:              + tablePrefix + "4 select "
0:              + tablePrefix + "3.a+"
0:              + tablePrefix + "2.a,"
0:              + tablePrefix + "3.b||"
0:              + tablePrefix + "2.b from "
0:              + tablePrefix + "3 join "
0:              + tablePrefix + "2 on 1=1");
1:     }
1:     
1:     private static void prepareForTimedQueries(Connection conn)
1:         throws
1:             TestFailedException
1:     {
1:         System.out.println("Preparing for testing queries with timeout");
1: 
1:         try {
1:             conn.setAutoCommit(true);
1:         } catch (SQLException e) {
1:             throw new TestFailedException("Should not happen", e);
1:         }
1: 
1:         prepareTables(conn, "t");
0:         prepareTables(conn, "u");
0:         prepareTables(conn, "v");
0:         prepareTables(conn, "x");
1:     }
1:     
1:     private static String getFetchQuery(String tablePrefix)
1:     {
0:         return "select "
0:             + tablePrefix + "4.a+"
0:             + tablePrefix + "3.a,"
0:             + tablePrefix + "4.b||"
0:             + tablePrefix + "3.b from "
0:             + tablePrefix + "4 left join "
0:             + tablePrefix + "3 on 1=1 where mod("
0:             + tablePrefix + "4.a+"
0:             + tablePrefix + "3.a,1000)=0";
1:     }
1:     
1:     private static String getExecQuery(String tablePrefix)
1:     {
1:         return "insert into "
0:             + tablePrefix + "5 select "
0:             + tablePrefix + "3.a+"
0:             + tablePrefix + "x.a,"
0:             + tablePrefix + "3.b from "
0:             + tablePrefix + "3 left join "
0:             + tablePrefix + "3 as "
0:             + tablePrefix + "x on 1=1";
1:     }
1:     
0:     private static class StatementExecutor
1:         extends
1:             Thread
1:     {
1:         private PreparedStatement statement;
1:         private boolean doFetch;
1:         private int timeout;
1:         private SQLException sqlException;
1:         private String name;
1:         private long highestRunTime;
1:         
1:         public StatementExecutor(PreparedStatement statement,
1:                                  boolean doFetch,
1:                                  int timeout)
1:         {
1:             this.statement = statement;
1:             this.doFetch = doFetch;
1:             this.timeout = timeout;
1:             highestRunTime = 0;
1:             sqlException = null;
1:             try {
1:                 statement.setQueryTimeout(timeout);
1:             } catch (SQLException e) {
1:                 sqlException = e;
1:             }
1:         }
1:         
1:         private void setHighestRunTime(long runTime)
1:         {
1:             synchronized (this) {
1:                 highestRunTime = runTime;
1:             }
1:         }
1:         
1:         public long getHighestRunTime()
1:         {
1:             synchronized (this) {
1:                 return highestRunTime;
1:             }
1:         }
1:         
1:         private boolean fetchRow(ResultSet resultSet)
1:             throws
1:                 SQLException
1:         {
1:             long startTime = System.currentTimeMillis();
1:             boolean hasNext = resultSet.next();
1:             long endTime = System.currentTimeMillis();
1:             long runTime = endTime - startTime;
1:             if (runTime > highestRunTime) setHighestRunTime(runTime);
1:             return hasNext;
1:         }
1: 
1:         public void run()
1:         {
1:             if (sqlException != null)
1:                 return;
1: 
1:             ResultSet resultSet = null;
1: 
1:             try {
1:                 if (doFetch) {
1:                     long startTime = System.currentTimeMillis();
1:                     resultSet = statement.executeQuery();
1:                     long endTime = System.currentTimeMillis();
1:                     setHighestRunTime(endTime - startTime);
1:                     while (fetchRow(resultSet)) {
1:                         yield();
1:                     }
1:                 } else {
1:                     long startTime = System.currentTimeMillis();
1:                     statement.execute();
1:                     long endTime = System.currentTimeMillis();
1:                     setHighestRunTime(endTime - startTime);
1:                 }
1:             } catch (SQLException e) {
1:                 synchronized (this) {
1:                     sqlException = e;
1:                 }
1:             } finally {
1:                 if (resultSet != null) {
1:                     try {
1:                         resultSet.close();
1:                     } catch (SQLException ex) {
1:                         if (sqlException != null) {
1:                             System.err.println("Discarding previous exception");
1:                             sqlException.printStackTrace();
1:                         }
1:                         sqlException = ex;
1:                     }
1:                 }
1:             }
1:         }
1: 
1:         public SQLException getSQLException()
1:         {
1:             synchronized (this) {
1:                 return sqlException;
1:             }
1:         }
1:     }
1: 
1:     /**
1:      * This method compares a thrown SQLException's SQLState value
1:      * to an expected SQLState. If they do not match, a
1:      * TestFailedException is thrown with the given message string.
1:      */
1:     private static void expectException(String expectSqlState,
1:                                         SQLException sqlException,
1:                                         String failMsg)
1:         throws
1:             TestFailedException
1:     {
1:         if (sqlException == null) {
1:             throw new TestFailedException(failMsg);
1:         } else {
1:             String sqlState = sqlException.getSQLState();
0:             if (!expectSqlState.startsWith(sqlState)) {
1:                 throw new TestFailedException(sqlException);
1:             }
1:         }
1:     }
1: 
1:     // A convenience method which wraps a SQLException
1:     private static PreparedStatement prepare(Connection conn, String query)
1:         throws
1:             TestFailedException
1:     {
1:         try {
1:             return conn.prepareStatement(query);
1:         } catch (SQLException e) {
1:             throw new TestFailedException(e);
1:         }
1:     }
1: 
1:     /**
1:      * Part 1 of this test.
1:      */
1:     private static void testTimeoutWithFetch(Connection conn1,
1:                                              Connection conn2)
1:         throws
1:             TestFailedException
1:     {
1:         System.out.println("Testing timeout with fetch operations");
1: 
1:         try {
1:             conn1.setAutoCommit(false);
1:             conn2.setAutoCommit(false);
1:         } catch (SQLException e) {
1:             throw new TestFailedException("Should not happen", e);
1:         }
1:         
1:         // The idea with these 4 statements is as follows:
1:         // A - should time out
1:         // B - different stmt on the same connection; should NOT time out
1:         // C - different stmt on different connection; should NOT time out
1:         // D - here just to create equal contention on conn1 and conn2
1:         
1:         PreparedStatement statementA = prepare(conn1, getFetchQuery("t"));
0:         PreparedStatement statementB = prepare(conn1, getFetchQuery("u"));
0:         PreparedStatement statementC = prepare(conn2, getFetchQuery("v"));
0:         PreparedStatement statementD = prepare(conn2, getFetchQuery("x"));
1: 
1:         StatementExecutor[] statementExecutor = new StatementExecutor[4];
1:         statementExecutor[0] = new StatementExecutor(statementA, true, TIMEOUT);
1:         statementExecutor[1] = new StatementExecutor(statementB, true, 0);
1:         statementExecutor[2] = new StatementExecutor(statementC, true, 0);
1:         statementExecutor[3] = new StatementExecutor(statementD, true, 0);
1:         
1:         for (int i = 3; i >= 0; --i) {
1:             statementExecutor[i].start();
1:         }
1:         
1:         for (int i = 0; i < 4; ++i) {
1:             try {
1:                 statementExecutor[i].join();
1:             } catch (InterruptedException e) {
1:                 throw new TestFailedException("Should never happen", e);
1:             }
1:         }
1: 
1:         /**
1:          * Actually, there is no guarantee that setting a query timeout
1:          * for a statement will actually cause a timeout, even if execution
1:          * of the statement takes longer than the specified timeout.
1:          *
1:          * However, these queries execute significantly longer than the
1:          * specified query timeout. Also, the cancellation mechanism
1:          * implemented should be quite responsive. In sum, we expect
1:          * the statement to always time out.
1:          *
1:          * If it does not time out, however, we print the highest
1:          * execution time for the query, as an assistance in determining
1:          * why it failed. Compare the number to the TIMEOUT constant
1:          * in this class (note that the TIMEOUT constant is in seconds,
1:          * while the execution time is in milliseconds). 
1:          */
0:         expectException(SQLState.LANG_STATEMENT_CANCELLED_OR_TIMED_OUT,
1:                         statementExecutor[0].getSQLException(),
1:                         "fetch did not time out. Highest execution time: "
1:                         + statementExecutor[0].getHighestRunTime() + " ms");
1: 
1:         System.out.println("Statement 0 timed out");
1: 
1:         for (int i = 1; i < 4; ++i) {
1:             SQLException sqlException = statementExecutor[i].getSQLException();
1:             if (sqlException != null) {
1:                 throw new TestFailedException("Unexpected exception in " + i,
1:                                               sqlException);
1:             }
1:             System.out.println("Statement " + i + " completed");
1:         }
1: 
1:         try {
1:             statementA.close();
1:             statementB.close();
1:             statementC.close();
1:             statementD.close();
1:             conn1.commit();
1:             conn2.commit();
1:         } catch (SQLException e) {
1:             throw new TestFailedException(e);
1:         }
1:     }
1: 
1:     /**
1:      * Part two of this test.
1:      */
0:     private static void testTimeoutWithExec(Connection conn1,
1:                                             Connection conn2)
1:         throws
1:             TestFailedException
1:     {
1:         System.out.println("Testing timeout with an execute operation");
1: 
1:         try {
0:             conn1.setAutoCommit(true);
0:             conn2.setAutoCommit(true);
1:         } catch (SQLException e) {
1:             throw new TestFailedException("Should not happen", e);
1:         }
1: 
0:         PreparedStatement statementA = prepare(conn1, getExecQuery("t"));
0:         PreparedStatement statementB = prepare(conn2, getExecQuery("u"));
1:         
0:         StatementExecutor exec0 = new StatementExecutor(statementA, false, TIMEOUT);
0:         StatementExecutor exec1 = new StatementExecutor(statementB, false, 0);
1:         
0:         exec1.start();
0:         exec0.start();
1: 
1:         try {
0:             exec0.join();
0:             exec1.join();
1:         } catch (InterruptedException e) {
1:             throw new TestFailedException("Should never happen", e);
1:         }
1:         
1:         /**
1:          * Actually, there is no guarantee that setting a query timeout
1:          * for a statement will actually cause a timeout, even if execution
1:          * of the statement takes longer than the specified timeout.
1:          *
1:          * However, these queries execute significantly longer than the
1:          * specified query timeout. Also, the cancellation mechanism
1:          * implemented should be quite responsive. In sum, we expect
1:          * the statement to always time out.
1:          *
1:          * If it does not time out, however, we print the highest
1:          * execution time for the query, as an assistance in determining
1:          * why it failed. Compare the number to the TIMEOUT constant
1:          * in this class (note that the TIMEOUT constant is in seconds,
1:          * while the execution time is in milliseconds). 
1:          */
0:         expectException(SQLState.LANG_STATEMENT_CANCELLED_OR_TIMED_OUT,
0:                         exec0.getSQLException(),
1:                         "exec did not time out. Execution time: "
0:                         + exec0.getHighestRunTime() + " ms");
1: 
1:         System.out.println("Statement 0 timed out");
1: 
0:         SQLException sqlException = exec1.getSQLException();
1:         if (sqlException != null) {
1:             throw new TestFailedException(sqlException);
1:         }
1: 
0:         System.out.println("Statement 1 completed");
1:         try {
1:             statementA.close();
1:             statementB.close();
1:         } catch (SQLException e) {
1:             throw new TestFailedException(e);
1:         }
1:     }
1:     
1:     private static void testInvalidTimeoutValue(Connection conn)
1:         throws
1:             TestFailedException
1:     {
1:         System.out.println("Testing setting a negative timeout value");
1: 
1:         try {
1:             conn.setAutoCommit(true);
1:         } catch (SQLException e) {
1:             throw new TestFailedException("Should not happen", e);
1:         }
1: 
1:         // Create statement
1:         PreparedStatement stmt = null;
1:         try {
1:             stmt = conn.prepareStatement("select * from sys.systables");
1:         } catch (SQLException e) {
1:             throw new TestFailedException("Should not happen", e);
1:         }
1:         
1:         // Set (invalid) timeout value - expect exception
1:         try {
1:             stmt.setQueryTimeout(-1);
1:         } catch (SQLException e) {
0:             expectException(SQLState.INVALID_QUERYTIMEOUT_VALUE, e,
1:                         "negative timeout value should give exception");
1:         }
1:         
1:         System.out.println("Negative timeout value caused exception, as expected");
1:         
1:         // Execute the statement and fetch result
1:         ResultSet rs = null;
1:         try {
1:             rs = stmt.executeQuery();
1:             System.out.println("Execute returned a ResultSet");
1:             rs.close();
1:         } catch (SQLException e) {
1:             throw new TestFailedException("Should not happen", e);
1:         } finally {
1:             try {
1:                 stmt.close();
1:             } catch (SQLException e) {
1:                 // This will discard an exception possibly thrown above :-(
1:                 // But we don't worry too much about this, since:
1:                 // 1. This is just a test
1:                 // 2. We don't expect close() to throw
1:                 // 3. If it does, this will be inspected by a developer
1:                 throw new TestFailedException("close should not throw", e);
1:             }
1:         }
1:     }
1: 
1:     /**
1:      * Main program, makes this class invocable from the command line
1:      */
1:     public static void main(String[] args)
1:     {
1:         new SetQueryTimeoutTest().go(args);
1:     }
1: 
1:     /**
1:      * The actual main bulk of this test.
1:      * Sets up the environment, prepares tables,
0:      * runs part 1 and 2, and shuts down.
1:      */
1:     public void go(String[] args)
1:     {
1:         System.out.println("Test SetQueryTimeoutTest starting");
1:         
0:         Connection conn1 = null;
0:         Connection conn2 = null;
1: 
1:         try {
1:             // Load the JDBC Driver class
1:             // use the ij utility to read the property file and
1:             // create connections
1:             ij.getPropertyArg(args);
0:             conn1 = ij.startJBMS();
0:             conn2 = ij.startJBMS();
1: 
1:             System.out.println("Got connections");
1:             
0:             conn1.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);
0:             conn2.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);
1: 
0:             prepareForTimedQueries(conn1);
0:             testTimeoutWithFetch(conn1, conn2);
0:             testTimeoutWithExec(conn1, conn2);
0:             testInvalidTimeoutValue(conn1);
1:   
1:             System.out.println("Test SetQueryTimeoutTest PASSED");
1:         } catch (Throwable e) {
1:             System.out.println("Test SetQueryTimeoutTest FAILED");
1:             e.printStackTrace();
1:         } finally {
0:             if (conn2 != null) {
1:                 try {
0:                     conn2.close();
1:                 } catch (SQLException ex) {
1:                     printSQLException(ex);
1:                 }
1:             }
0:             if (conn1 != null) {
1:                 try {
0:                     conn1.close();
1:                 } catch (SQLException ex) {
1:                     printSQLException(ex);
1:                 }
1:             }
1:             System.out.println("Closed connections");
1:         }
1:     }
1: }
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:b9df96a
/////////////////////////////////////////////////////////////////////////
1:     /** This tests timeout with executeUpdate call. */
1:     private static void testTimeoutWithExecuteUpdate(Connection conn)
1:         throws TestFailedException
1:     {
1:     	System.out.println("Testing timeout with executeUpdate call.");
1:         try{
1:             Statement stmt = conn.createStatement();
1:             stmt.setQueryTimeout(TIMEOUT);
1:             stmt.executeUpdate(getExecQuery("t"));    
1:         } catch (SQLException sqle) {
0:         	expectException("XCL52", sqle, "Should have timed out.");
1:         }
1:     }
0:     
/////////////////////////////////////////////////////////////////////////
1:             testTimeoutWithExecuteUpdate(connections[0]);
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:dff95a1
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:c8ceb5f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         
1:         try {
1:             exec(conn, "DROP FUNCTION DELAY");
1:         } catch (Exception e) {
1:             // Ignore
1:         }
/////////////////////////////////////////////////////////////////////////
0: 
0:         // FIXME: Should have used conn1 for statementB below, but
0:         // this is blocked by DERBY-694
0:         PreparedStatement statementB = prepare(conn2, getFetchQuery("t"));
commit:1373f5a
/////////////////////////////////////////////////////////////////////////
1:  *    The query calls a user-defined, server-side function which
1:  *    delays the execution, so that it takes several seconds even
1:  *    though the data volume is really low. The fetch operations
1:  *    take longer time than the timeout value set. Hence, this part
1:  *    tests getting timeouts from calls to ResultSet.next().
/////////////////////////////////////////////////////////////////////////
1:  * 2. Executes an INSERT query in multiple threads.
/////////////////////////////////////////////////////////////////////////
1:  *    Half of the threads execute their statement with a timeout value set,
1:  *    this is to verify that the correct statements are affected by the
1:  *    timeout, while the other statements execute to completion.
/////////////////////////////////////////////////////////////////////////
1:     private static final int TIMEOUT = 1; // In seconds
1:     private static final int CONNECTIONS = 100;
/////////////////////////////////////////////////////////////////////////
1:         Statement statement = null;
1:             statement = connection.createStatement();
1:             statement.execute(queryString);
/////////////////////////////////////////////////////////////////////////
1:         exec(conn, "drop table " + tablePrefix + "_orig", ignore);
1:         exec(conn, "drop table " + tablePrefix + "_copy", ignore);
/////////////////////////////////////////////////////////////////////////
1:              "create table " + tablePrefix + "_orig (a int)");
1:              "create table " + tablePrefix + "_copy (a int)");
1:              + tablePrefix + "_orig"
1:              + " values(0),(1),(2),(3),(4),(5),(6)");
0: 
1:     /**
1:      * This is the user-defined function which is called from our queries
1:      */
1:     public static int delay(int seconds, int value)
1:         throws
1:             SQLException
1:     {
0:         try {
1:             Thread.sleep(seconds * 1000);
1:         } catch (InterruptedException e) {
1:             // Ignore
1:         }
1:         return value;
1:     }
0: 
/////////////////////////////////////////////////////////////////////////
1:         exec(conn, "CREATE FUNCTION DELAY(SECONDS INTEGER, VALUE INTEGER) RETURNS INTEGER PARAMETER STYLE JAVA NO SQL LANGUAGE JAVA EXTERNAL NAME 'org.apache.derbyTesting.functionTests.tests.jdbcapi.SetQueryTimeoutTest.delay'");
0: 
1:         /**
1:          * The reason for using the mod function here is to force
1:          * at least one invocation of ResultSet.next() to read
1:          * more than one row from the table before returning.
1:          * This is necessary since timeout is checked only when
1:          * reading rows from base tables, and when the first row
1:          * is read, the query still has not exceeded the timeout.
1:          */
1:         return "select a from " + tablePrefix + "_orig where mod(DELAY(1,a),3)=0";
1:             + tablePrefix + "_copy select a from "
1:             + tablePrefix + "_orig where DELAY(1,1)=1";
/////////////////////////////////////////////////////////////////////////
1:             if (timeout > 0) {
0:                 try {
0:                     statement.setQueryTimeout(timeout);
0:                 } catch (SQLException e) {
0:                     sqlException = e;
1:                 }
/////////////////////////////////////////////////////////////////////////
0:         PreparedStatement statementB = prepare(conn1, getFetchQuery("t"));
1:         PreparedStatement statementC = prepare(conn2, getFetchQuery("t"));
1:         PreparedStatement statementD = prepare(conn2, getFetchQuery("t"));
/////////////////////////////////////////////////////////////////////////
1:     private static void testTimeoutWithExec(Connection[] connections)
1:         for (int i = 0; i < connections.length; ++i) {
0:             try {
1:                 connections[i].setAutoCommit(true);
0:             } catch (SQLException e) {
0:                 throw new TestFailedException("Should not happen", e);
1:             }
1:         PreparedStatement statements[] = new PreparedStatement[connections.length];
1:         for (int i = 0; i < statements.length; ++i) {
1:             statements[i] = prepare(connections[i], getExecQuery("t"));
1:         }
1:         StatementExecutor[] executors = new StatementExecutor[statements.length];
1:         for (int i = 0; i < executors.length; ++i) {
1:             int timeout =
1:                 (i % 2 == 0)
1:                 ? TIMEOUT
1:                 : 0;
1:             executors[i] = new StatementExecutor(statements[i], false, timeout);
1:         }
0: 
1:         for (int i = 0; i < executors.length; ++i) {
1:             executors[i].start();
1:         }
0: 
1:         for (int i = 0; i < executors.length; ++i) {
0:             try {
1:                 executors[i].join();
0:             } catch (InterruptedException e) {
0:                 throw new TestFailedException("Should never happen", e);
1:             }
/////////////////////////////////////////////////////////////////////////
1:         for (int i = 0; i < executors.length; ++i) {
1:             int timeout =
1:                 (i % 2 == 0)
1:                 ? TIMEOUT
1:                 : 0;
1:             if (timeout > 0) {
0:                 expectException(SQLState.LANG_STATEMENT_CANCELLED_OR_TIMED_OUT,
1:                                 executors[i].getSQLException(),
0:                                 "exec did not time out. Execution time: "
1:                                 + executors[i].getHighestRunTime() + " ms");
1:             } else {
1:                 SQLException sqlException = executors[i].getSQLException();
0:                 if (sqlException != null) {
0:                     throw new TestFailedException(sqlException);
1:                 }
1:             }
1:         System.out.println("Statements that should time out timed out, and statements that should complete completed");
0: 
1:         for (int i = 0; i < statements.length; ++i) {
0:             try {
1:                 statements[i].close();
0:             } catch (SQLException e) {
0:                 throw new TestFailedException(e);
1:             }
/////////////////////////////////////////////////////////////////////////
0: 
1:         Connection[] connections = new Connection[CONNECTIONS];
1:         for (int i = 0; i < connections.length; ++i) {
0:             connections[i] = null;
1:         }
1:             for (int i = 0; i < connections.length; ++i) {
1:                 connections[i] = ij.startJBMS();
1:             }
1:             for (int i = 0; i < connections.length; ++i) {
1:                 connections[i].setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);
1:             }
0: 
1:             prepareForTimedQueries(connections[0]);
1:             testTimeoutWithFetch(connections[0], connections[1]);
1:             testTimeoutWithExec(connections);
1:             testInvalidTimeoutValue(connections[0]);
1:             for (int i = connections.length - 1; i >= 0; --i) {
1:                 if (connections[i] != null) {
0:                     try {
1:                         connections[i].close();
0:                     } catch (SQLException ex) {
0:                         printSQLException(ex);
1:                     }
============================================================================