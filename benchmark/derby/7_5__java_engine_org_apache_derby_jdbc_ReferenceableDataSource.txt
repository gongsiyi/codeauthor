5:eac0369: /*
1:5179dd9: 
1:345de35:    Derby - Class org.apache.derby.jdbc.ReferenceableDataSource
1:f337728: 
1:2f36947:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2f36947:    contributor license agreements.  See the NOTICE file distributed with
1:2f36947:    this work for additional information regarding copyright ownership.
1:2f36947:    The ASF licenses this file to You under the Apache License, Version 2.0
1:2f36947:    (the "License"); you may not use this file except in compliance with
1:2f36947:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:345de35: 
1:58bf06e:  */
1:eac0369: package org.apache.derby.jdbc;
1:345de35: 
1:a086620: import java.lang.reflect.Method;
1:eac0369: import java.util.Enumeration;
1:58bf06e: import javax.naming.RefAddr;
1:58bf06e: import javax.naming.Reference;
1:58bf06e: import javax.naming.spi.ObjectFactory;
61:eac0369: 
2:58bf06e: /**
1:58bf06e:  * The data source factory for Derby embedded driver data sources.
1:58bf06e:  * <p>
1:58bf06e:  * This factory reconstructs a Derby data source object when it is retrieved
1:58bf06e:  * from JNDI. References are needed since many naming services don't have the
1:58bf06e:  * ability to store Java objects in their serialized form. When a data source
1:58bf06e:  * object is bound in this type of naming service the
1:58bf06e:  * {@link javax.naming.Reference} for that object is actually stored by the
1:58bf06e:  * JNDI implementation, not the data source object itself.
1:58bf06e:  * <p>
1:58bf06e:  * A JNDI administrator is responsible for making sure that both the object
1:58bf06e:  * factory and data source implementation classes provided by a JDBC driver
1:58bf06e:  * vendor are accessible to the JNDI service provider at runtime.
1:58bf06e:  * <p>
1:58bf06e:  * An object factory implements the {@link javax.naming.spi.ObjectFactory}
1:58bf06e:  * interface. This interface contains a single method, {@code getObjectInstance}
1:58bf06e:  * which is called by a JNDI service provider to reconstruct an object when that
1:58bf06e:  * object is retrieved from JNDI. A JDBC driver vendor should provide an object
1:58bf06e:  * factory as part of their JDBC product.
1:58bf06e:  *
1:58bf06e:  * @see org.apache.derby.jdbc.EmbeddedDataSource
1:58bf06e:  * @see org.apache.derby.jdbc.EmbeddedConnectionPoolDataSource
1:58bf06e:  * @see org.apache.derby.jdbc.EmbeddedXADataSource
1:58bf06e:  */
1:eac0369: 
1:a086620: public class ReferenceableDataSource extends BasicEmbeddedDataSource40
1:58bf06e:                                      implements ObjectFactory {
1:eac0369: 
1:58bf06e:     private static final long serialVersionUID = 1872877359127597176L;
1:eac0369: 
1:58bf06e:     /**
1:58bf06e:      * Reconstructs a Derby embedded-driver data source object from a JNDI data
1:58bf06e:      * source reference.
1:58bf06e:      * <p>
1:58bf06e:      * The {@code getObjectInstance} method is passed a reference that
1:58bf06e:      * corresponds to the object being retrieved as its first parameter. The
1:58bf06e:      * other parameters are optional in the case of JDBC data source objects.
1:58bf06e:      * The object factory should use the information contained in the reference
1:58bf06e:      * to reconstruct the data source. If for some reason, a data source
1:58bf06e:      * object cannot be reconstructed from the reference, a value of
1:58bf06e:      * {@code null} may be returned. This allows other object factories that may
1:58bf06e:      * be registered in JNDI to be tried. If an exception is thrown then no
1:58bf06e:      * other object factories are tried.
1:58bf06e:      *
1:58bf06e:      * @param refObj the possibly {@code null} object containing location or
1:58bf06e:      *      reference information that can be used in creating an object
1:58bf06e:      * @param name the name of this object relative to {@code nameContext}, or
1:58bf06e:      *      {@code null} if no name is specified
1:58bf06e:      * @param nameContext context relative to which the name parameter is
1:58bf06e:      *      specified, or {@code null} if name is relative to the default
1:58bf06e:      *      initial context.
1:58bf06e:      * @param environment possibly {@code null} environment that is used in
1:58bf06e:      *      creating the object.
1:58bf06e:      *
1:58bf06e:      * @return Object created, or {@code null} if no attempt to create the
1:58bf06e:      *      object is made.
1:58bf06e:      * @throws Exception if recreating the object fails
1:58bf06e:      */
1:a086620:     @Override
1:58bf06e:     public Object getObjectInstance(Object refObj,
1:58bf06e:                                     javax.naming.Name name,
1:58bf06e:                                     javax.naming.Context nameContext,
1:7863d83:                                     java.util.Hashtable<?,?> environment)
1:58bf06e:             throws java.lang.Exception {
1:eac0369: 
1:58bf06e:         Object ds = null;
1:58bf06e:         if (refObj instanceof javax.naming.Reference) {
1:58bf06e:             javax.naming.Reference ref = (javax.naming.Reference) refObj;
1:eac0369: 
1:58bf06e:             // See if this object belongs to Derby.
1:58bf06e:             String className = ref.getClassName();
1:58bf06e:             if (className != null &&
1:58bf06e:                     className.startsWith("org.apache.derby.jdbc.Embedded")) {
1:58bf06e:                 // Create the proper data source object shell.
1:4469400:                 ds = Class.forName(className).getConstructor().newInstance();
1:eac0369: 
1:58bf06e:                 // Fill in the data source object shell with values from the
1:58bf06e:                 // jndi reference.
1:58bf06e:                 setBeanProperties(ds, ref);
1:58bf06e:             }
1:58bf06e:         }
1:58bf06e:         return ds;
1:58bf06e:     }
1:5179dd9: 
1:a086620:     // Reflect lookup for Java bean method taking a single String arg
1:a086620:     private static final Class<?>[] STRING_ARG = { "".getClass() };
1:a086620:     // Reflect lookup for Java bean method taking a single int arg
1:a086620:     private static final Class<?>[] INT_ARG = { Integer.TYPE };
1:a086620:     // Reflect lookup for Java bean method taking a single boolean arg
1:a086620:     private static final Class<?>[] BOOLEAN_ARG = { Boolean.TYPE };
1:a086620:     // Reflect lookup for Java bean method taking a single short arg
1:a086620:     private static final Class<?>[] SHORT_ARG = { Short.TYPE };
1:f337728: 
1:a086620:     // Set the Java bean properties for an object from its Reference. The
1:a086620:     // Reference contains a set of StringRefAddr values with the key being the
1:a086620:     // bean name and the value a String representation of the bean's value. This
1:a086620:     // code looks for setXXX() method where the set method corresponds to the
1:a086620:     // standard bean naming scheme and has a single parameter of type String,
1:a086620:     // int, boolean or short.
1:58bf06e:     private static void setBeanProperties(Object ds, Reference ref)
1:58bf06e:             throws Exception {
1:eac0369: 
1:a086620:         for (Enumeration<RefAddr> e = ref.getAll(); e.hasMoreElements();) {
1:eac0369: 
1:a086620:             RefAddr attribute = e.nextElement();
1:eac0369: 
1:58bf06e:             String propertyName = attribute.getType();
1:eac0369: 
1:58bf06e:             String value = (String) attribute.getContent();
1:eac0369: 
1:58bf06e:             String methodName = "set"
1:58bf06e:                     + propertyName.substring(0, 1).toUpperCase(
1:58bf06e:                             java.util.Locale.ENGLISH)
1:58bf06e:                     + propertyName.substring(1);
1:eac0369: 
1:58bf06e:             Method m;
1:eac0369: 
1:58bf06e:             Object argValue;
1:58bf06e:             try {
1:58bf06e:                 m = ds.getClass().getMethod(methodName, STRING_ARG);
1:58bf06e:                 argValue = value;
1:58bf06e:             } catch (NoSuchMethodException nsme) {
1:58bf06e:                 try {
1:58bf06e:                     m = ds.getClass().getMethod(methodName, INT_ARG);
1:58bf06e:                     argValue = Integer.valueOf(value);
1:58bf06e:                 } catch (NoSuchMethodException nsme2) {
1:58bf06e:                     try {
1:58bf06e:                         m = ds.getClass().getMethod(methodName, BOOLEAN_ARG);
1:58bf06e:                         argValue = Boolean.valueOf(value);
1:58bf06e:                     } catch (NoSuchMethodException nsme3) {
1:58bf06e:                         m = ds.getClass().getMethod(methodName, SHORT_ARG);
1:58bf06e:                         argValue = Short.valueOf(value);
1:58bf06e:                     }
1:58bf06e:                 }
1:58bf06e:             }
1:58bf06e:             m.invoke(ds, new Object[] { argValue });
1:58bf06e:         }
1:58bf06e:     }
3:5179dd9: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:4469400
/////////////////////////////////////////////////////////////////////////
1:                 ds = Class.forName(className).getConstructor().newInstance();
commit:589941f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:a086620
/////////////////////////////////////////////////////////////////////////
1: import java.lang.reflect.Method;
/////////////////////////////////////////////////////////////////////////
1: public class ReferenceableDataSource extends BasicEmbeddedDataSource40
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     // Reflect lookup for Java bean method taking a single String arg
1:     private static final Class<?>[] STRING_ARG = { "".getClass() };
1:     // Reflect lookup for Java bean method taking a single int arg
1:     private static final Class<?>[] INT_ARG = { Integer.TYPE };
1:     // Reflect lookup for Java bean method taking a single boolean arg
1:     private static final Class<?>[] BOOLEAN_ARG = { Boolean.TYPE };
1:     // Reflect lookup for Java bean method taking a single short arg
1:     private static final Class<?>[] SHORT_ARG = { Short.TYPE };
1:     // Set the Java bean properties for an object from its Reference. The
1:     // Reference contains a set of StringRefAddr values with the key being the
1:     // bean name and the value a String representation of the bean's value. This
1:     // code looks for setXXX() method where the set method corresponds to the
1:     // standard bean naming scheme and has a single parameter of type String,
1:     // int, boolean or short.
1:         for (Enumeration<RefAddr> e = ref.getAll(); e.hasMoreElements();) {
1:             RefAddr attribute = e.nextElement();
commit:7863d83
/////////////////////////////////////////////////////////////////////////
1:                                     java.util.Hashtable<?,?> environment)
commit:58bf06e
/////////////////////////////////////////////////////////////////////////
1: import javax.naming.RefAddr;
1: import javax.naming.Reference;
1: import javax.naming.spi.ObjectFactory;
1: /**
1:  * The data source factory for Derby embedded driver data sources.
1:  * <p>
1:  * This factory reconstructs a Derby data source object when it is retrieved
1:  * from JNDI. References are needed since many naming services don't have the
1:  * ability to store Java objects in their serialized form. When a data source
1:  * object is bound in this type of naming service the
1:  * {@link javax.naming.Reference} for that object is actually stored by the
1:  * JNDI implementation, not the data source object itself.
1:  * <p>
1:  * A JNDI administrator is responsible for making sure that both the object
1:  * factory and data source implementation classes provided by a JDBC driver
1:  * vendor are accessible to the JNDI service provider at runtime.
1:  * <p>
1:  * An object factory implements the {@link javax.naming.spi.ObjectFactory}
1:  * interface. This interface contains a single method, {@code getObjectInstance}
1:  * which is called by a JNDI service provider to reconstruct an object when that
1:  * object is retrieved from JNDI. A JDBC driver vendor should provide an object
1:  * factory as part of their JDBC product.
1:  *
1:  * @see org.apache.derby.jdbc.EmbeddedDataSource
0:  * @see org.apache.derby.jdbc.EmbeddedDataSource40
1:  * @see org.apache.derby.jdbc.EmbeddedConnectionPoolDataSource
0:  * @see org.apache.derby.jdbc.EmbeddedConnectionPoolDataSource40
1:  * @see org.apache.derby.jdbc.EmbeddedXADataSource
0:  * @see org.apache.derby.jdbc.EmbeddedXADataSource40
1:  */
0: public class ReferenceableDataSource extends EmbeddedBaseDataSource
1:                                      implements ObjectFactory {
1:     private static final long serialVersionUID = 1872877359127597176L;
1:     /**
1:      * Reconstructs a Derby embedded-driver data source object from a JNDI data
1:      * source reference.
1:      * <p>
1:      * The {@code getObjectInstance} method is passed a reference that
1:      * corresponds to the object being retrieved as its first parameter. The
1:      * other parameters are optional in the case of JDBC data source objects.
1:      * The object factory should use the information contained in the reference
1:      * to reconstruct the data source. If for some reason, a data source
1:      * object cannot be reconstructed from the reference, a value of
1:      * {@code null} may be returned. This allows other object factories that may
1:      * be registered in JNDI to be tried. If an exception is thrown then no
1:      * other object factories are tried.
1:      *
1:      * @param refObj the possibly {@code null} object containing location or
1:      *      reference information that can be used in creating an object
1:      * @param name the name of this object relative to {@code nameContext}, or
1:      *      {@code null} if no name is specified
1:      * @param nameContext context relative to which the name parameter is
1:      *      specified, or {@code null} if name is relative to the default
1:      *      initial context.
1:      * @param environment possibly {@code null} environment that is used in
1:      *      creating the object.
1:      *
1:      * @return Object created, or {@code null} if no attempt to create the
1:      *      object is made.
1:      * @throws Exception if recreating the object fails
1:      */
1:     public Object getObjectInstance(Object refObj,
1:                                     javax.naming.Name name,
1:                                     javax.naming.Context nameContext,
0:                                     java.util.Hashtable environment)
1:             throws java.lang.Exception {
1:         Object ds = null;
1:         if (refObj instanceof javax.naming.Reference) {
1:             javax.naming.Reference ref = (javax.naming.Reference) refObj;
1:             // See if this object belongs to Derby.
1:             String className = ref.getClassName();
1:             if (className != null &&
1:                     className.startsWith("org.apache.derby.jdbc.Embedded")) {
1:                 // Create the proper data source object shell.
0:                 ds = Class.forName(className).newInstance();
1:                 // Fill in the data source object shell with values from the
1:                 // jndi reference.
1:                 setBeanProperties(ds, ref);
1:             }
1:         }
1:         return ds;
1:     }
0:     /** Reflect lookup for Java bean method taking a single String arg */
0:     private static final Class[] STRING_ARG = { "".getClass() };
0:     /** Reflect lookup for Java bean method taking a single int arg */
0:     private static final Class[] INT_ARG = { Integer.TYPE };
0:     /** Reflect lookup for Java bean method taking a single boolean arg */
0:     private static final Class[] BOOLEAN_ARG = { Boolean.TYPE };
0:     /** Reflect lookup for Java bean method taking a single short arg */
0:     private static final Class[] SHORT_ARG = { Short.TYPE };
1:     /**
0:      * Set the Java bean properties for an object from its Reference. The
0:      * Reference contains a set of StringRefAddr values with the key being the
0:      * bean name and the value a String representation of the bean's value. This
0:      * code looks for setXXX() method where the set method corresponds to the
0:      * standard bean naming scheme and has a single parameter of type String,
0:      * int, boolean or short.
1:      */
1:     private static void setBeanProperties(Object ds, Reference ref)
1:             throws Exception {
0:         for (Enumeration e = ref.getAll(); e.hasMoreElements();) {
0:             RefAddr attribute = (RefAddr) e.nextElement();
1:             String propertyName = attribute.getType();
1:             String value = (String) attribute.getContent();
1:             String methodName = "set"
1:                     + propertyName.substring(0, 1).toUpperCase(
1:                             java.util.Locale.ENGLISH)
1:                     + propertyName.substring(1);
1:             Method m;
1:             Object argValue;
1:             try {
1:                 m = ds.getClass().getMethod(methodName, STRING_ARG);
1:                 argValue = value;
1:             } catch (NoSuchMethodException nsme) {
1:                 try {
1:                     m = ds.getClass().getMethod(methodName, INT_ARG);
1:                     argValue = Integer.valueOf(value);
1:                 } catch (NoSuchMethodException nsme2) {
1:                     try {
1:                         m = ds.getClass().getMethod(methodName, BOOLEAN_ARG);
1:                         argValue = Boolean.valueOf(value);
1:                     } catch (NoSuchMethodException nsme3) {
1:                         m = ds.getClass().getMethod(methodName, SHORT_ARG);
1:                         argValue = Short.valueOf(value);
1:                     }
1:                 }
1:             }
1:             m.invoke(ds, new Object[] { argValue });
1:         }
1:     }
author:Tiago Aur¨¦lio Rodrigues Espinha
-------------------------------------------------------------------------------
commit:5179dd9
/////////////////////////////////////////////////////////////////////////
0: 	/** shortDatabaseName has attributes of databaseName stripped */
0: 	private String shortDatabaseName;	
1: 
/////////////////////////////////////////////////////////////////////////
0: 		if( databaseName!= null && (databaseName.indexOf(";") >= 0)){
0: 			String[] dbShort = databaseName.split(";");
0: 			this.shortDatabaseName = dbShort[0];
1: 		}
0: 		else {
0: 			this.shortDatabaseName = databaseName;
1: 		}
1: 	
0: 	/**
0: 	 * @return databaseName with attributes stripped.
0: 	 */
0: 	protected String getShortDatabaseName() {
0: 		return shortDatabaseName;
1: 	}
commit:f337728
/////////////////////////////////////////////////////////////////////////
0: 	/** shortDatabaseName has attributes of databaseName stripped */
0: 	private String shortDatabaseName;	
1: 
/////////////////////////////////////////////////////////////////////////
0: 		if( databaseName!= null && databaseName.contains(";")){
0: 			String[] dbShort = databaseName.split(";");
0: 			this.shortDatabaseName = dbShort[0];
0: 		}
0: 		else {
0: 			this.shortDatabaseName = databaseName;
0: 		}
1: 	
0: 	/**
0: 	 * @return databaseName with attributes stripped.
0: 	 */
0: 	protected String getShortDatabaseName() {
0: 		return shortDatabaseName;
0: 	}
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:2c21843
/////////////////////////////////////////////////////////////////////////
0:         Derby DataSource implementation base class.
0: 	as the ObjectFactory to generate Derby DataSource implementations.
/////////////////////////////////////////////////////////////////////////
0: 	See the specific Derby DataSource implementation for details on their meaning.
/////////////////////////////////////////////////////////////////////////
0: 		Derby ignores this property.
/////////////////////////////////////////////////////////////////////////
0: 		Re-Create Derby datasource given a reference.
/////////////////////////////////////////////////////////////////////////
0: 		@return One of the Derby datasource object created; null if an
/////////////////////////////////////////////////////////////////////////
0: 		Return a connection for the Derby family of data source implementations.
commit:2f36947
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.jdbc.ReferenceableDataSource
1: 
0:    Copyright 2003, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:4dede3b
/////////////////////////////////////////////////////////////////////////
commit:e23c6af
/////////////////////////////////////////////////////////////////////////
0: 	private static final Class[] STRING_ARG = { "".getClass() };
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.jdbc
0:    (C) Copyright IBM Corp. 2003, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
0:  */
1: package org.apache.derby.jdbc;
1: 
0: import java.sql.SQLException;
0: import java.lang.reflect.*;
1: 
1: 
0: import java.io.Serializable;
0: import java.io.PrintWriter;
0: import java.util.Properties;
1: 
0: /* -- JNDI -- */
0: import javax.naming.NamingException;
0: import javax.naming.Referenceable;
0: import javax.naming.Reference;
0: import javax.naming.StringRefAddr;
0: import javax.naming.spi.ObjectFactory;
0: import javax.naming.Context;
0: import javax.naming.Name;
0: import javax.naming.Reference;
0: import javax.naming.RefAddr;
0: import java.util.Hashtable;
1: import java.util.Enumeration;
1: 
0: /** 
1: 
0: 	Cloudscape DataSource implementation base class.
0: 	ReferenceableDataSource provides support for JDBC standard DataSource attributes and acts
0: 	as the ObjectFactory to generate Cloudscape DataSource implementations.
0: 	<P>
0: 	The standard attributes provided by this class are:
0: 	<UL>
0: 	<LI>databaseName
0: 	<LI>dataSourceName
0: 	<LI>description
0: 	<LI>password
0: 	<LI>user
0: 	</UL>
0: 	<BR>
0: 	See the specific Cloudscape DataSource implementation for details on their meaning.
0: 	<BR>
0: 	See the JDBC 3.0 specification for more details.
1: 
1: 
0: */
0: public class ReferenceableDataSource implements
0: 				javax.naming.Referenceable,
0: 				java.io.Serializable,
0: 				ObjectFactory
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2003_2004;
1: 
1: 
0: 	private static final long serialVersionUID = 1872877359127597176L;
1: 
1: 
0: 	private static final Class[] STRING_ARG = { copyrightNotice.getClass() };
0: 	private static final Class[] INT_ARG = { Integer.TYPE };
0: 	private static final Class[] BOOLEAN_ARG = { Boolean.TYPE };
1: 
0: 	private String description;
0: 	private String dataSourceName;
0: 	private String databaseName;
0: 	private String password;
0: 	private String user;
0: 	private int loginTimeout;
1: 
1: 
0: 	/** instance variables that will not be serialized */
0: 	transient private PrintWriter printer;
1: 
0: 	/**
0: 		No-arg constructor.
0: 	 */
0: 	public ReferenceableDataSource() {
0: 		update();
0: 	}
1: 
1: 
1: 	/*
0: 	 * Properties to be seen by Bean - access thru reflection.
0: 	 */
1: 
0: 	/** 
0: 		Set the database name.  Setting this property is mandatory.  If a
0: 		database named wombat at g:/db needs to be accessed, database name
0: 		should be set to "g:/db/wombat".  The database will be booted if it
0: 		is not already running in the system.
1: 
0: 		@param databaseName the name of the database 
0: 	*/
0: 	public final synchronized void setDatabaseName(String databaseName) {
0: 		this.databaseName = databaseName;
0: 		update();
0: 	}
0: 	public String getDatabaseName() {
0: 		return databaseName;
0: 	}
1: 
0: 	/** 
0: 		Set the data source name.  The property is not mandatory.  It is used
0: 		for informational purposes only.
1: 
0: 		@param dsn the name of the data source
0: 	*/
0: 	public final void setDataSourceName(String dsn) {
0: 		dataSourceName = dsn;
0: 	}
0: 	/** @return data source name */
0: 	public final String getDataSourceName() {
0: 		return dataSourceName;
0: 	}
1: 
0: 	/**
0: 		Set the data source descripton. This property is not mandatory.
0: 		It is used for informational purposes only.
1: 
0: 		@param desc the description of the data source
0: 	 */
0: 	public final void setDescription(String desc) {
0: 		description = desc;
0: 	}
0: 	/** @return description */
0: 	public final String getDescription() {
0: 		return description;
0: 	}
1: 
0: 	/**
0: 		Set the <code>user</code> property for the data source.
0: 		This is user name for any data source getConnection() call
0: 		that takes no arguments.
0: 	*/
0: 	public final void setUser(String user) {
0: 		this.user = user;
0: 	}
0: 	/** @return user */
0: 	public final String getUser() {
0: 		return user;
0: 	}
1: 
0: 	/**
0: 		Set the <code>password</code> property for the data source.
0: 		This is user's password for any data source getConnection() call
0: 		that takes no arguments.
0: 	*/
0: 	public final void setPassword(String password) {
0: 		this.password = password;
0: 	}
0: 	/** @return password */
0: 	public final String getPassword() {
0: 		return password;
0: 	}
1: 
1: 	/*
0: 	 * DataSource methods 
0: 	 */
1: 
1: 
0: 	/**
0: 	 * Gets the maximum time in seconds that this data source can wait
0: 	 * while attempting to connect to a database.  A value of zero
0: 	 * means that the timeout is the default system timeout 
0: 	 * if there is one; otherwise it means that there is no timeout.
0: 	 * When a data source object is created, the login timeout is
0: 	 * initially zero.
0: 	 *
0: 	 * @return the data source login time limit
0: 	 * @exception SQLException if a database access error occurs.
0: 	 */
0: 	public int getLoginTimeout() throws SQLException
0: 	{
0: 		return loginTimeout;
0: 	}
1: 
0: 	/**
0: 	 * Sets the maximum time in seconds that this data source will wait
0: 	 * while attempting to connect to a database.  A value of zero
0: 	 * specifies that the timeout is the default system timeout 
0: 	 * if there is one; otherwise it specifies that there is no timeout.
0: 	 * When a data source object is created, the login timeout is
0: 	 * initially zero.
0: 	 <P>
0: 		Cloudscape ignores this property.
0: 	 * @param seconds the data source login time limit
0: 	 * @exception SQLException if a database access error occurs.
0: 	 */
0: 	public void setLoginTimeout(int seconds) throws SQLException
0: 	{
0: 		loginTimeout = seconds;
0: 	}
1: 
1: 
0: 	/** 
0: 	 * Get the log writer for this data source.  
0: 	 *
0: 	 * <p>The log writer is a character output stream to which all logging
0: 	 * and tracing messages for this data source object instance will be
0: 	 * printed.  This includes messages printed by the methods of this
0: 	 * object, messages printed by methods of other objects manufactured
0: 	 * by this object, and so on.  Messages printed to a data source
0: 	 * specific log writer are not printed to the log writer associated
0: 	 * with the java.sql.Drivermanager class.  When a data source object is
0: 	 * created the log writer is initially null, in other words, logging
0: 	 * is disabled.
0: 	 *
0: 	 * @return the log writer for this data source, null if disabled
0: 	 * @exception SQLException if a database-access error occurs.  
0: 	 */
0: 	public PrintWriter getLogWriter() throws SQLException
0: 	{
0: 		return printer;
0: 	}
1: 
0: 	/**
0: 	 * Set the log writer for this data source.
0: 	 *
0: 	 * <p>The log writer is a character output stream to which all logging
0: 	 * and tracing messages for this data source object instance will be
0: 	 * printed.  This includes messages printed by the methods of this
0: 	 * object, messages printed by methods of other objects manufactured
0: 	 * by this object, and so on.  Messages printed to a data source
0: 	 * specific log writer are not printed to the log writer associated
0: 	 * with the java.sql.Drivermanager class. When a data source object is
0: 	 * created the log writer is initially null, in other words, logging
0: 	 * is disabled.
0: 	 *
0: 	 * @param out the new log writer; to disable, set to null
0: 	 * @exception SQLException if a database-access error occurs.  
0: 	 */
0: 	public void setLogWriter(PrintWriter out) throws SQLException
0: 	{
0: 		printer = out;
0: 	}
1: 
1: 	/*
0: 	** Reference methods etc.
0: 	*/
1: 
1: 	/*
0: 	 * Object Factory method
0: 	 */
1: 
0: 	/**
0: 		Re-Create Cloudscape datasource given a reference.
1: 
0: 		@param obj The possibly null object containing location or reference
0: 		information that can be used in creating an object. 
0: 		@param name The name of this object relative to nameCtx, or null if no
0: 		name is specified. 
0: 		@param nameCtx The context relative to which the name parameter is
0: 		specified, or null if name is relative to the default initial context. 
0: 		@param environment The possibly null environment that is used in
0: 		creating the object. 
1: 
0: 		@return One of the Cloudscape datasource object created; null if an
0: 		object cannot be created. 
1: 
0: 		@exception Exception  if this object factory encountered an exception
0: 		while attempting to create an object, and no other object factories are
0: 		to be tried. 
0: 	 */
0: 	public Object getObjectInstance(Object obj,
0: 									Name name,
0: 									Context nameCtx,
0: 									Hashtable environment)
0: 		 throws Exception
0: 	{
0: 		Reference ref = (Reference)obj;
0: 		String classname = ref.getClassName();
1: 
0: 		Object ds = Class.forName(classname).newInstance();
1: 
0: 		for (Enumeration e = ref.getAll(); e.hasMoreElements(); ) {
1: 			
0: 			RefAddr attribute = (RefAddr) e.nextElement();
1: 
0: 			String propertyName = attribute.getType();
1: 
0: 			String value = (String) attribute.getContent();
1: 
0: 			String methodName = "set" + propertyName.substring(0,1).toUpperCase(java.util.Locale.ENGLISH) + propertyName.substring(1);
1: 
0: 			Method m;
1: 			
0: 			Object argValue;
0: 			try {
0: 				m = ds.getClass().getMethod(methodName, STRING_ARG);
0: 				argValue = value;
0: 			} catch (NoSuchMethodException nsme) {
0: 				try {
0: 					m = ds.getClass().getMethod(methodName, INT_ARG);
0: 					argValue = Integer.valueOf(value);
0: 				} catch (NoSuchMethodException nsme2) {
0: 					m = ds.getClass().getMethod(methodName, BOOLEAN_ARG);
0: 					argValue = Boolean.valueOf(value);
0: 				}
0: 			}
0: 			m.invoke(ds, new Object[] { argValue });
0: 		}
1: 
0: 		return ds;
0: 	}
1: 
0: 	/**
0: 		Referenceable method.
1: 
0: 		@exception NamingException cannot find named object
0: 	 */
0: 	public final Reference getReference() throws NamingException 
0: 	{
0: 		// These fields will be set by the JNDI server when it decides to
0: 		// materialize a data source.
0: 		Reference ref = new Reference(this.getClass().getName(),
0: 									  "org.apache.derby.jdbc.ReferenceableDataSource",
0: 									  null);
1: 
1: 
0: 		// Look for all the getXXX methods in the class that take no arguments.
0: 		Method[] methods = this.getClass().getMethods();
1: 
0: 		for (int i = 0; i < methods.length; i++) {
1: 
0: 			Method m = methods[i];
1: 
0: 			// only look for simple getter methods.
0: 			if (m.getParameterTypes().length != 0)
0: 				continue;
1: 
0: 			// only non-static methods
0: 			if (Modifier.isStatic(m.getModifiers()))
0: 				continue;
1: 
0: 			// Only getXXX methods
0: 			String methodName = m.getName();
0: 			if ((methodName.length() < 5) || !methodName.startsWith("get"))
0: 				continue;
1: 
1: 
1: 
0: 			Class returnType = m.getReturnType();
1: 
0: 			if (Integer.TYPE.equals(returnType) || STRING_ARG[0].equals(returnType) || Boolean.TYPE.equals(returnType)) {
1: 
0: 				// setSomeProperty
0: 				// 01234
1: 
0: 				String propertyName = methodName.substring(3,4).toLowerCase(java.util.Locale.ENGLISH).concat(methodName.substring(4));
1: 
0: 				try {
0: 					Object ov = m.invoke(this, null);
1: 
0: 					//Need to check for nullability for all the properties, otherwise
0: 					//rather than null, "null" string gets stored in jndi.
0: 					if (ov != null) {
0: 						ref.add(new StringRefAddr(propertyName, ov.toString()));
0: 					}
0: 				} catch (IllegalAccessException iae) {
0: 				} catch (InvocationTargetException ite) {
0: 				}
1: 
1: 
0: 			}
0: 		}
1: 
0: 		return ref;
0: 	}
1: 
1: 
0: 	void update() {
0: 	}
1: 
0: 	/**
0: 		Return a connection for the Cloudscape family of data source implementations.
0: 	*/
0: 	java.sql.Connection getConnection(String username, String password, boolean requestPassword) throws SQLException {
0: 		return null;
0: 	}
1: 
0: }
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.jdbc
0:    (C) Copyright IBM Corp. 2003, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: package org.apache.derby.jdbc;
0: 
0: import java.sql.SQLException;
0: import java.lang.reflect.*;
0: 
0: 
0: import java.io.Serializable;
0: import java.io.PrintWriter;
0: import java.util.Properties;
0: 
0: /* -- JNDI -- */
0: import javax.naming.NamingException;
0: import javax.naming.Referenceable;
0: import javax.naming.Reference;
0: import javax.naming.StringRefAddr;
0: import javax.naming.spi.ObjectFactory;
0: import javax.naming.Context;
0: import javax.naming.Name;
0: import javax.naming.Reference;
0: import javax.naming.RefAddr;
0: import java.util.Hashtable;
0: import java.util.Enumeration;
0: 
0: /** 
0: 
0: 	Cloudscape DataSource implementation base class.
0: 	ReferenceableDataSource provides support for JDBC standard DataSource attributes and acts
0: 	as the ObjectFactory to generate Cloudscape DataSource implementations.
0: 	<P>
0: 	The standard attributes provided by this class are:
0: 	<UL>
0: 	<LI>databaseName
0: 	<LI>dataSourceName
0: 	<LI>description
0: 	<LI>password
0: 	<LI>user
0: 	</UL>
0: 	<BR>
0: 	See the specific Cloudscape DataSource implementation for details on their meaning.
0: 	<BR>
0: 	See the JDBC 3.0 specification for more details.
0: 
0: 
0: */
0: public class ReferenceableDataSource implements
0: 				javax.naming.Referenceable,
0: 				java.io.Serializable,
0: 				ObjectFactory
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2003_2004;
0: 
0: 
0: 	private static final long serialVersionUID = 1872877359127597176L;
0: 
0: 
0: 	private static final Class[] STRING_ARG = { copyrightNotice.getClass() };
0: 	private static final Class[] INT_ARG = { Integer.TYPE };
0: 	private static final Class[] BOOLEAN_ARG = { Boolean.TYPE };
0: 
0: 	private String description;
0: 	private String dataSourceName;
0: 	private String databaseName;
0: 	private String password;
0: 	private String user;
0: 	private int loginTimeout;
0: 
0: 
0: 	/** instance variables that will not be serialized */
0: 	transient private PrintWriter printer;
0: 
0: 	/**
0: 		No-arg constructor.
0: 	 */
0: 	public ReferenceableDataSource() {
0: 		update();
0: 	}
0: 
0: 
0: 	/*
0: 	 * Properties to be seen by Bean - access thru reflection.
0: 	 */
0: 
0: 	/** 
0: 		Set the database name.  Setting this property is mandatory.  If a
0: 		database named wombat at g:/db needs to be accessed, database name
0: 		should be set to "g:/db/wombat".  The database will be booted if it
0: 		is not already running in the system.
0: 
0: 		@param databaseName the name of the database 
0: 	*/
0: 	public final synchronized void setDatabaseName(String databaseName) {
0: 		this.databaseName = databaseName;
0: 		update();
0: 	}
0: 	public String getDatabaseName() {
0: 		return databaseName;
0: 	}
0: 
0: 	/** 
0: 		Set the data source name.  The property is not mandatory.  It is used
0: 		for informational purposes only.
0: 
0: 		@param dsn the name of the data source
0: 	*/
0: 	public final void setDataSourceName(String dsn) {
0: 		dataSourceName = dsn;
0: 	}
0: 	/** @return data source name */
0: 	public final String getDataSourceName() {
0: 		return dataSourceName;
0: 	}
0: 
0: 	/**
0: 		Set the data source descripton. This property is not mandatory.
0: 		It is used for informational purposes only.
0: 
0: 		@param desc the description of the data source
0: 	 */
0: 	public final void setDescription(String desc) {
0: 		description = desc;
0: 	}
0: 	/** @return description */
0: 	public final String getDescription() {
0: 		return description;
0: 	}
0: 
0: 	/**
0: 		Set the <code>user</code> property for the data source.
0: 		This is user name for any data source getConnection() call
0: 		that takes no arguments.
0: 	*/
0: 	public final void setUser(String user) {
0: 		this.user = user;
0: 	}
0: 	/** @return user */
0: 	public final String getUser() {
0: 		return user;
0: 	}
0: 
0: 	/**
0: 		Set the <code>password</code> property for the data source.
0: 		This is user's password for any data source getConnection() call
0: 		that takes no arguments.
0: 	*/
0: 	public final void setPassword(String password) {
0: 		this.password = password;
0: 	}
0: 	/** @return password */
0: 	public final String getPassword() {
0: 		return password;
0: 	}
0: 
0: 	/*
0: 	 * DataSource methods 
0: 	 */
0: 
0: 
0: 	/**
0: 	 * Gets the maximum time in seconds that this data source can wait
0: 	 * while attempting to connect to a database.  A value of zero
0: 	 * means that the timeout is the default system timeout 
0: 	 * if there is one; otherwise it means that there is no timeout.
0: 	 * When a data source object is created, the login timeout is
0: 	 * initially zero.
0: 	 *
0: 	 * @return the data source login time limit
0: 	 * @exception SQLException if a database access error occurs.
0: 	 */
0: 	public int getLoginTimeout() throws SQLException
0: 	{
0: 		return loginTimeout;
0: 	}
0: 
0: 	/**
0: 	 * Sets the maximum time in seconds that this data source will wait
0: 	 * while attempting to connect to a database.  A value of zero
0: 	 * specifies that the timeout is the default system timeout 
0: 	 * if there is one; otherwise it specifies that there is no timeout.
0: 	 * When a data source object is created, the login timeout is
0: 	 * initially zero.
0: 	 <P>
0: 		Cloudscape ignores this property.
0: 	 * @param seconds the data source login time limit
0: 	 * @exception SQLException if a database access error occurs.
0: 	 */
0: 	public void setLoginTimeout(int seconds) throws SQLException
0: 	{
0: 		loginTimeout = seconds;
0: 	}
0: 
0: 
0: 	/** 
0: 	 * Get the log writer for this data source.  
0: 	 *
0: 	 * <p>The log writer is a character output stream to which all logging
0: 	 * and tracing messages for this data source object instance will be
0: 	 * printed.  This includes messages printed by the methods of this
0: 	 * object, messages printed by methods of other objects manufactured
0: 	 * by this object, and so on.  Messages printed to a data source
0: 	 * specific log writer are not printed to the log writer associated
0: 	 * with the java.sql.Drivermanager class.  When a data source object is
0: 	 * created the log writer is initially null, in other words, logging
0: 	 * is disabled.
0: 	 *
0: 	 * @return the log writer for this data source, null if disabled
0: 	 * @exception SQLException if a database-access error occurs.  
0: 	 */
0: 	public PrintWriter getLogWriter() throws SQLException
0: 	{
0: 		return printer;
0: 	}
0: 
0: 	/**
0: 	 * Set the log writer for this data source.
0: 	 *
0: 	 * <p>The log writer is a character output stream to which all logging
0: 	 * and tracing messages for this data source object instance will be
0: 	 * printed.  This includes messages printed by the methods of this
0: 	 * object, messages printed by methods of other objects manufactured
0: 	 * by this object, and so on.  Messages printed to a data source
0: 	 * specific log writer are not printed to the log writer associated
0: 	 * with the java.sql.Drivermanager class. When a data source object is
0: 	 * created the log writer is initially null, in other words, logging
0: 	 * is disabled.
0: 	 *
0: 	 * @param out the new log writer; to disable, set to null
0: 	 * @exception SQLException if a database-access error occurs.  
0: 	 */
0: 	public void setLogWriter(PrintWriter out) throws SQLException
0: 	{
0: 		printer = out;
0: 	}
0: 
0: 	/*
0: 	** Reference methods etc.
0: 	*/
0: 
0: 	/*
0: 	 * Object Factory method
0: 	 */
0: 
0: 	/**
0: 		Re-Create Cloudscape datasource given a reference.
0: 
0: 		@param obj The possibly null object containing location or reference
0: 		information that can be used in creating an object. 
0: 		@param name The name of this object relative to nameCtx, or null if no
0: 		name is specified. 
0: 		@param nameCtx The context relative to which the name parameter is
0: 		specified, or null if name is relative to the default initial context. 
0: 		@param environment The possibly null environment that is used in
0: 		creating the object. 
0: 
0: 		@return One of the Cloudscape datasource object created; null if an
0: 		object cannot be created. 
0: 
0: 		@exception Exception  if this object factory encountered an exception
0: 		while attempting to create an object, and no other object factories are
0: 		to be tried. 
0: 	 */
0: 	public Object getObjectInstance(Object obj,
0: 									Name name,
0: 									Context nameCtx,
0: 									Hashtable environment)
0: 		 throws Exception
0: 	{
0: 		Reference ref = (Reference)obj;
0: 		String classname = ref.getClassName();
0: 
0: 		Object ds = Class.forName(classname).newInstance();
0: 
0: 		for (Enumeration e = ref.getAll(); e.hasMoreElements(); ) {
0: 			
0: 			RefAddr attribute = (RefAddr) e.nextElement();
0: 
0: 			String propertyName = attribute.getType();
0: 
0: 			String value = (String) attribute.getContent();
0: 
0: 			String methodName = "set" + propertyName.substring(0,1).toUpperCase(java.util.Locale.ENGLISH) + propertyName.substring(1);
0: 
0: 			Method m;
0: 			
0: 			Object argValue;
0: 			try {
0: 				m = ds.getClass().getMethod(methodName, STRING_ARG);
0: 				argValue = value;
0: 			} catch (NoSuchMethodException nsme) {
0: 				try {
0: 					m = ds.getClass().getMethod(methodName, INT_ARG);
0: 					argValue = Integer.valueOf(value);
0: 				} catch (NoSuchMethodException nsme2) {
0: 					m = ds.getClass().getMethod(methodName, BOOLEAN_ARG);
0: 					argValue = Boolean.valueOf(value);
0: 				}
0: 			}
0: 			m.invoke(ds, new Object[] { argValue });
0: 		}
0: 
0: 		return ds;
0: 	}
0: 
0: 	/**
0: 		Referenceable method.
0: 
0: 		@exception NamingException cannot find named object
0: 	 */
0: 	public final Reference getReference() throws NamingException 
0: 	{
0: 		// These fields will be set by the JNDI server when it decides to
0: 		// materialize a data source.
0: 		Reference ref = new Reference(this.getClass().getName(),
0: 									  "org.apache.derby.jdbc.ReferenceableDataSource",
0: 									  null);
0: 
0: 
0: 		// Look for all the getXXX methods in the class that take no arguments.
0: 		Method[] methods = this.getClass().getMethods();
0: 
0: 		for (int i = 0; i < methods.length; i++) {
0: 
0: 			Method m = methods[i];
0: 
0: 			// only look for simple getter methods.
0: 			if (m.getParameterTypes().length != 0)
0: 				continue;
0: 
0: 			// only non-static methods
0: 			if (Modifier.isStatic(m.getModifiers()))
0: 				continue;
0: 
0: 			// Only getXXX methods
0: 			String methodName = m.getName();
0: 			if ((methodName.length() < 5) || !methodName.startsWith("get"))
0: 				continue;
0: 
0: 
0: 
0: 			Class returnType = m.getReturnType();
0: 
0: 			if (Integer.TYPE.equals(returnType) || STRING_ARG[0].equals(returnType) || Boolean.TYPE.equals(returnType)) {
0: 
0: 				// setSomeProperty
0: 				// 01234
0: 
0: 				String propertyName = methodName.substring(3,4).toLowerCase(java.util.Locale.ENGLISH).concat(methodName.substring(4));
0: 
0: 				try {
0: 					Object ov = m.invoke(this, null);
0: 
0: 					//Need to check for nullability for all the properties, otherwise
0: 					//rather than null, "null" string gets stored in jndi.
0: 					if (ov != null) {
0: 						ref.add(new StringRefAddr(propertyName, ov.toString()));
0: 					}
0: 				} catch (IllegalAccessException iae) {
0: 				} catch (InvocationTargetException ite) {
0: 				}
0: 
0: 
0: 			}
0: 		}
0: 
0: 		return ref;
0: 	}
0: 
0: 
0: 	void update() {
0: 	}
0: 
0: 	/**
0: 		Return a connection for the Cloudscape family of data source implementations.
0: 	*/
0: 	java.sql.Connection getConnection(String username, String password, boolean requestPassword) throws SQLException {
0: 		return null;
0: 	}
0: 
0: }
============================================================================