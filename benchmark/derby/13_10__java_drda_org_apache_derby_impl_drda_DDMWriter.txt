2:eac0369: /*
1:d7258ed: 
1:d7258ed:    Derby - Class org.apache.derby.impl.drda.DDMWriter
1:f81f610: 
1:59e5225:    Licensed to the Apache Software Foundation (ASF) under one or more
1:59e5225:    contributor license agreements.  See the NOTICE file distributed with
1:59e5225:    this work for additional information regarding copyright ownership.
1:59e5225:    The ASF licenses this file to You under the Apache License, Version 2.0
1:59e5225:    (the "License"); you may not use this file except in compliance with
1:59e5225:    the License.  You may obtain a copy of the License at
1:cdfb2d1: 
1:d7258ed:       http://www.apache.org/licenses/LICENSE-2.0
1:d7258ed: 
1:d7258ed:    Unless required by applicable law or agreed to in writing, software
1:d7258ed:    distributed under the License is distributed on an "AS IS" BASIS,
1:d7258ed:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:d7258ed:    See the License for the specific language governing permissions and
1:d7258ed:    limitations under the License.
1:d7258ed: 
1:4f996a4:  */
1:d7258ed: 
1:eac0369: package org.apache.derby.impl.drda;
50:eac0369: 
1:f3ab04f: import java.io.BufferedOutputStream;
1:f3ab04f: import java.io.IOException;
1:efb1bd2: import java.io.InputStream;
1:506f4c8: import java.io.ObjectOutputStream;
1:efb1bd2: import java.io.OutputStream;
1:a1f0068: import java.math.BigDecimal;
1:298ff5e: import java.nio.ByteBuffer;
1:9f8e1eb: import java.nio.CharBuffer;
1:9f8e1eb: import java.nio.charset.CharsetEncoder;
1:9f8e1eb: import java.nio.charset.CoderResult;
1:9f8e1eb: import java.nio.charset.CodingErrorAction;
1:b850119: import java.sql.DataTruncation;
1:efb1bd2: import java.sql.SQLException;
1:efb1bd2: import java.util.Arrays;
1:506f4c8: import org.apache.derby.iapi.reference.DRDAConstants;
1:efb1bd2: import org.apache.derby.iapi.reference.Property;
1:506f4c8: import org.apache.derby.iapi.services.io.DynamicByteArrayOutputStream;
1:efb1bd2: import org.apache.derby.iapi.services.property.PropertyUtil;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:efb1bd2: 
1:298ff5e: /**
1:4f996a4:     The DDMWriter is used to write DRDA protocol.   The DRDA Protocol is
1:4f996a4:     described in the DDMReader class.
1:4f996a4:     For more details, see DRDA Volume 3 (Distributed Data Management(DDM)
1:4f996a4:         Architecture (DDS definition)
1:298ff5e: */
1:eac0369: class DDMWriter
2:d79abcf: {
1:eac0369: 
1:4f996a4:     // number of nesting levels for collections.  We need to mark the length
1:4f996a4:     // location of the collection so that we can update it as we add more stuff
1:4f996a4:     // to the collection
1:4f996a4:     private final static int MAX_MARKS_NESTING = 10;
1:eac0369: 
1:4f996a4:     // Default buffer size
1:4f996a4:     private final static int DEFAULT_BUFFER_SIZE = 32767;
1:eac0369: 
1:c6e4294:     /**
1:c6e4294:      * The maximum length in bytes for strings sent by {@code writeLDString()},
1:c6e4294:      * which is the maximum unsigned integer value that fits in two bytes.
1:c6e4294:      */
1:4a2a038:     final static int MAX_VARCHAR_BYTE_LENGTH = 0xFFFF;
1:c6e4294: 
1:298ff5e:     /**
1:298ff5e:      * Output buffer.
1:298ff5e:      */
1:298ff5e:     private ByteBuffer buffer;
1:eac0369: 
1:4f996a4:     // A saved mark in the stream is saved temporarily to revisit the location.
1:4f996a4:     private int[] markStack = new int[MAX_MARKS_NESTING];
1:eac0369: 
1:4f996a4:     // top of the stack
1:4f996a4:     private int top;
1:eac0369: 
1:4f996a4:     // CCSID manager for translation of strings in the protocol to UTF-8 and EBCDIC
1:4f996a4:     private EbcdicCcsidManager ebcdicCcsidManager;
1:4f996a4:     private Utf8CcsidManager utf8CcsidManager;
1:4f996a4:     
1:4f996a4:     // Current CCSID manager
1:4f996a4:     private CcsidManager ccsidManager;
1:cdfb2d1: 
1:4f996a4:     // DRDA connection thread for this writer
1:4f996a4:     private DRDAConnThread agent;
1:eac0369: 
1:db9a013:     //  This Object tracks the location of the current
1:db9a013:     //  Dss header length bytes.    This is done so
1:db9a013:     //  the length bytes can be automatically
1:db9a013:     //  updated as information is added to this stream.
1:4f996a4:     private int dssLengthLocation;
1:eac0369: 
1:4f996a4:     // Current correlation ID
1:db9a013:     private int correlationID;
1:eac0369: 
1:4f996a4:     // Next correlation ID
1:4f996a4:     private int nextCorrelationID;
1:eac0369: 
1:4f996a4:     // is this DRDA protocol or CMD protocol
1:4f996a4:     private boolean isDRDAProtocol;
1:4f996a4:     // trace object of the associated session
1:4f996a4:     private DssTrace dssTrace;
1:eac0369: 
1:a0adefe:     // Location of the start of the header
1:4f996a4:     // of the DSS most recently written to the buffer.
1:4f996a4:     private int prevHdrLocation;
1:eac0369: 
1:4f996a4:     // Correlation id of the last DSS that was written to buffer.
1:4f996a4:     private int previousCorrId;
1:eac0369: 
1:4f996a4:     // Chaining bit of the last DSS that was written to buffer.
1:4f996a4:     private byte previousChainByte;
1:d79abcf: 
1:4f996a4:     // Whether or not the current DSS is a continuation DSS.
1:4f996a4:     private boolean isContinuationDss;
1:a54b657: 
1:4f996a4:     // In situations where we want to "mark" a buffer location so that
1:4f996a4:     // we can "back-out" of a write to handle errors, this holds the
1:a0adefe:     // location within the buffer of the start of the header
1:4f996a4:     // that immediately precedes the mark.
1:4f996a4:     private int lastDSSBeforeMark;
1:a54b657: 
1:9f8e1eb:     /** Encoder which encodes strings with the server's default encoding. */
1:9f8e1eb:     private final CharsetEncoder encoder;
1:d79abcf: 
1:1ab256e:     // For JMX statistics. Volatile to ensure we 
1:1ab256e:     // get one complete long, but we don't bother to synchronize, 
1:1ab256e:     // since this is just statistics.
1:1ab256e:     
1:1ab256e:     volatile long totalByteCount = 0;
1:1ab256e:     
1:4f996a4:     DDMWriter (DRDAConnThread agent, DssTrace dssTrace)
1:4f996a4:     {
1:4f996a4:         // Create instances of the two ccsid managers and default to EBCDIC
1:4f996a4:         this.ebcdicCcsidManager = new EbcdicCcsidManager();
1:4f996a4:         this.utf8CcsidManager = new Utf8CcsidManager();
1:4f996a4:         this.ccsidManager = this.ebcdicCcsidManager;
1:4f996a4:         
1:a0adefe:         this.buffer = ByteBuffer.allocate(DEFAULT_BUFFER_SIZE);
1:4f996a4:         this.agent = agent;
1:4f996a4:         this.prevHdrLocation = -1;
1:4f996a4:         this.previousCorrId = DssConstants.CORRELATION_ID_UNKNOWN;
1:4f996a4:         this.previousChainByte = DssConstants.DSS_NOCHAIN;
1:4f996a4:         this.isContinuationDss = false;
1:4f996a4:         this.lastDSSBeforeMark = -1;
1:4f996a4:         reset(dssTrace);
1:9f8e1eb:         // create an encoder which inserts the charset's default replacement
1:9f8e1eb:         // character for characters it can't encode
1:9f8e1eb:         encoder = NetworkServerControlImpl.DEFAULT_CHARSET.newEncoder()
1:9f8e1eb:             .onMalformedInput(CodingErrorAction.REPLACE)
1:9f8e1eb:             .onUnmappableCharacter(CodingErrorAction.REPLACE);
1:4f996a4:     }
1:cdfb2d1: 
1:4f996a4:     // Switch the ccsidManager to the UTF-8 instance
1:4f996a4:     protected void setUtf8Ccsid() {
1:4f996a4:         ccsidManager = utf8CcsidManager;
1:f81f610:     }
1:4f996a4:     
1:4f996a4:     // Switch the ccsidManager to the EBCDIC instance
1:4f996a4:     protected void setEbcdicCcsid() {
1:4f996a4:         ccsidManager = ebcdicCcsidManager;
1:4f996a4:     }
1:4f996a4:     
1:4f996a4:     // Get the current ccsidManager
1:4f996a4:     protected CcsidManager getCurrentCcsidManager() {
1:4f996a4:         return ccsidManager;
1:4f996a4:     }
1:4f996a4:     
1:9f8e1eb:     /**
1:4f996a4:      * reset values for sending next message
1:4f996a4:      *
1:4f996a4:      */
1:4f996a4:     protected void reset(DssTrace dssTrace)
1:4f996a4:     {
1:298ff5e:         buffer.clear();
1:4f996a4:         top = 0;
1:4f996a4:         dssLengthLocation = 0;
1:4f996a4:         nextCorrelationID = 1;
1:4f996a4:         correlationID = DssConstants.CORRELATION_ID_UNKNOWN;
1:4f996a4:         isDRDAProtocol = true;
1:4f996a4:         this.dssTrace = dssTrace;
1:4f996a4:     }
1:cdfb2d1: 
1:b850119:     /**
1:b850119:      * Get the current position in the output buffer.
1:b850119:      * @return current position
1:b850119:      */
1:b850119:     protected int getBufferPosition() {
1:b850119:         return buffer.position();
1:b850119:     }
1:b850119: 
1:b850119:     /**
1:b850119:      * Change the current position in the output buffer.
1:b850119:      * @param position new position
1:b850119:      */
1:b850119:     protected void setBufferPosition(int position) {
1:b850119:         buffer.position(position);
1:b850119:     }
1:b850119: 
1:b850119:     /**
1:b850119:      * Get a copy of a subsequence of the output buffer, starting at the
1:b850119:      * specified position and ending at the current buffer position.
1:b850119:      *
1:b850119:      * @param startPos the position of the first byte to copy
1:b850119:      * @return all bytes from {@code startPos} up to the current position
1:b850119:      */
1:b850119:     protected byte[] getBufferContents(int startPos) {
1:b850119:         byte[] bytes = new byte[buffer.position() - startPos];
1:b850119:         System.arraycopy(buffer.array(), startPos, bytes, 0, bytes.length);
1:b850119:         return bytes;
1:b850119:     }
1:b850119: 
1:4f996a4:     /**
1:4f996a4:      * set protocol to CMD protocol
1:4f996a4:      */
1:4f996a4:     protected void setCMDProtocol()
1:4f996a4:     {
1:4f996a4:         isDRDAProtocol = false;
1:4f996a4:     }
1:cdfb2d1: 
1:4f996a4:     /**
1:4f996a4:      * Create DSS reply object
1:4f996a4:      */
1:4f996a4:     protected void createDssReply()
1:4f996a4:     {
1:4f996a4:         beginDss(DssConstants.DSSFMT_RPYDSS, true);
1:4f996a4:     }
1:d79abcf: 
1:4f996a4:     /**
1:4f996a4:      * Create DSS request object
1:4f996a4:      * NOTE: This is _ONLY_ used for testing the protocol
1:c3c7b7b:     * (via the ProtocolTestAdapter.java file in this package)!
1:4f996a4:      * We should never create a DSS request in normal
1:4f996a4:      * DRDA processing (we should only create DSS replies
1:4f996a4:      * and DSS objects).
1:4f996a4:      */
1:4f996a4:     protected void createDssRequest()
1:4f996a4:     {
1:4f996a4:         beginDss(DssConstants.DSSFMT_RQSDSS, true);
1:4f996a4:     }
1:d79abcf: 
1:4f996a4:     /**
1:4f996a4:      * Create DSS data object
1:4f996a4:      */
1:4f996a4:     protected void createDssObject()
1:4f996a4:     {
1:4f996a4:         beginDss(DssConstants.DSSFMT_OBJDSS, true);
1:4f996a4:     }
1:d79abcf: 
1:4f996a4:     /**
1:4f996a4:      * Mark the DSS that we're currently writing as
1:4f996a4:      * a continued DSS, which is done by setting
1:4f996a4:      * the high-order bit to "1", per DDM spec.
1:4f996a4:      * This means:
1:4f996a4:      *
1:db9a013:      *  1. One or more continuation DSSes will immediately
1:db9a013:      *      follow the current (continued) DSS.
1:db9a013:      *  2. All continuation DSSes will have a 2-byte
1:db9a013:      *      continuation header, followed by data; in
1:db9a013:      *      other words, chaining state, correlation
1:db9a013:      *      id, dss format info, and code point will
1:db9a013:      *      NOT be included.  All of that info is
1:db9a013:      *      present ONLY in the FIRST DSS in the
1:db9a013:      *      list of continued DSSes.
1:4f996a4:      *
1:db9a013:      *  NOTE: A DSS can be a "continuation" DSS _and_
1:db9a013:      *  a "continued" DSS at the same time.  However,
1:db9a013:      *  the FIRST DSS to be continued canNOT be
1:db9a013:      *  a continuation DSS.
1:4f996a4:      */
1:4f996a4:     private void markDssAsContinued(boolean forLob)
1:4f996a4:     {
1:d79abcf: 
1:4f996a4:         if (!forLob) {
1:4f996a4:         // continuation bit defaults to '1' for lobs, so
1:4f996a4:         // we only have to switch it if we're not writing
1:4f996a4:         // lobs.
1:a1f0068:             byte b = (byte) (buffer.get(dssLengthLocation) | 0x80);
1:a1f0068:             buffer.put(dssLengthLocation, b);
1:4f996a4:         }
1:d79abcf: 
1:4f996a4:         // We need to set the chaining state, but ONLY
1:4f996a4:         // IF this is the FIRST DSS in the continuation
1:4f996a4:         // list (only the first one has chaining state
1:4f996a4:         // in it's header; the others do not).
1:4f996a4:         if (!isContinuationDss)
1:4f996a4:             endDss(!forLob);
1:d79abcf: 
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * End DSS header by writing the length in the length location
1:4f996a4:      * and setting the chain bit.  Unlike the other two endDss
1:4f996a4:      * methods, this one overrides the default chaining byte
1:4f996a4:      * (which is set in beginDss) with the chaining byte that
1:4f996a4:      * is passed in.  NOTE: This method is only used in
1:4f996a4:      * association with createDssRequest, and thus is for
1:c3c7b7b:     * TESTING purposes only (via ProtocolTestAdpater.java).  No calls
1:4f996a4:      * should be made to this method in normal DRDA processing
1:4f996a4:      * (because for normal processing, chaining must be
1:4f996a4:      * determined automatically based on DSS requests).
1:4f996a4:      */
1:4f996a4:     protected void endDss(byte chainByte)
1:4f996a4:     {
1:d79abcf: 
1:4f996a4:         // Do regular endDss processing.
1:4f996a4:         endDss(true);
1:d79abcf: 
1:4f996a4:         // Now override default chain state.
1:a1f0068:         overrideChainByte(dssLengthLocation + 3, chainByte);
1:4f996a4:         previousChainByte = chainByte;
1:d79abcf: 
1:4f996a4:     }
1:d79abcf: 
1:a1f0068:     /**
1:a1f0068:      * Override the default chaining byte with the chaining byte that is passed
1:a1f0068:      * in.
1:a1f0068:      *
1:a1f0068:      * @param pos the position on which the chaining byte is located
1:a1f0068:      * @param chainByte the chaining byte that overrides the default
1:a1f0068:      */
1:a1f0068:     private void overrideChainByte(int pos, byte chainByte) {
1:a1f0068:         byte b = buffer.get(pos);
1:a1f0068:         b &= 0x0F;              // Zero out default
1:a1f0068:         b |= chainByte;
1:a1f0068:         buffer.put(pos, b);
1:a1f0068:     }
1:a1f0068: 
1:4f996a4:     /**
1:4f996a4:      * End DSS header by writing the length in the length location
1:4f996a4:      * and setting the chain bit.
1:4f996a4:      */
1:4f996a4:     protected void endDss() {
1:4f996a4:         endDss(true);
1:4f996a4:     }
1:d79abcf: 
1:4f996a4:     /**
1:4f996a4:      * End DSS header by writing the length in the length location
1:4f996a4:      * and setting the chain bit.
1:4f996a4:      */
1:4f996a4:     private void endDss (boolean finalizeLength)
1:4f996a4:     {
1:d79abcf: 
1:4f996a4:         if (finalizeLength)
1:4f996a4:             finalizeDssLength();
1:d79abcf: 
1:4f996a4:         if (isContinuationDss) {
1:4f996a4:         // no chaining information for this DSS; so we're done.
1:4f996a4:             isContinuationDss = false;
1:4f996a4:             return;
1:4f996a4:         }
1:d79abcf: 
1:4f996a4:         previousCorrId = correlationID;
1:4f996a4:         prevHdrLocation = dssLengthLocation;
1:4f996a4:         previousChainByte = DssConstants.DSSCHAIN_SAME_ID;
1:d79abcf: 
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * End final DDM and DSS header by writing the length in the length location
1:4f996a4:      *
1:4f996a4:      */
1:4f996a4:     protected void endDdmAndDss ()
1:4f996a4:     {
1:db9a013:         endDdm();   // updates last DDM object
1:4f996a4:         endDss();
1:4f996a4:     }
1:4f996a4:     /**
1:4f996a4:      * Copy Data to End
1:4f996a4:      * Create a buffer and copy from the position given to the end of data
1:4f996a4:      *
1:4f996a4:      * Note that the position given is treated as relative to the
1:4f996a4:      * current DSS, for there may be other DSS blocks (chained, presumably)
1:4f996a4:      * which are sitting unwritten in the buffer. The caller doesn't
1:4f996a4:      * know this, though, and works only with the current DSS.
1:4f996a4:      *
1:4f996a4:      * getDSSLength, copyDSSDataToEnd, and truncateDSS work together to
1:4f996a4:      * provide a sub-protocol for DRDAConnThread to use in its
1:4f996a4:      * implementation of the LMTBLKPRC protocol. They enable the caller
1:4f996a4:      * to determine when it has written too much data into the current
1:4f996a4:      * DSS, to reclaim the extra data that won't fit, and to truncate
1:4f996a4:      * that extra data once it has been reclaimed and stored elsewhere.
1:4f996a4:      * Note that this support only works for the current DSS. Earlier,
1:4f996a4:      * chained DSS blocks cannot be accessed using these methods. For
1:4f996a4:      * additional background information, the interested reader should
1:4f996a4:      * investigate bugs DERBY-491 and 492 at:
1:4f996a4:      * http://issues.apache.org/jira/browse/DERBY-491 and
1:4f996a4:      * http://issues.apache.org/jira/browse/DERBY-492
1:4f996a4:      *
1:4f996a4:      * @param start
1:4f996a4:      */
1:4f996a4:     protected byte [] copyDSSDataToEnd(int start)
1:4f996a4:     {
1:4f996a4:         start = start + dssLengthLocation;
1:298ff5e:         int length = buffer.position() - start;
1:4f996a4:         byte [] temp = new byte[length];
1:a1f0068:         buffer.position(start);
1:a1f0068:         buffer.get(temp);
1:4f996a4:         return temp;
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     // Collection methods
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * Mark the location of the length bytes for the collection so they
1:4f996a4:      * can be updated later
1:4f996a4:      *
1:4f996a4:      */
1:4f996a4:     protected void startDdm (int codePoint)
1:4f996a4:     {
1:4f996a4:         // save the location of the beginning of the collection so
1:4f996a4:         // that we can come back and fill in the length bytes
1:298ff5e:         final int offset = buffer.position();
1:4f996a4:         markStack[top++] = offset;
1:10e7778:         ensureLength (4); // verify space for length bytes and code point
1:298ff5e:         // move past the length bytes before writing the code point
1:298ff5e:         buffer.position(offset + 2);
1:298ff5e:         buffer.putShort((short) codePoint);
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * Erase all writes for the current ddm and reset the
1:4f996a4:      * top
1:4f996a4:      */
1:4f996a4:     protected void clearDdm ()
1:4f996a4:     {
1:298ff5e:         buffer.position(markStack[top--]);
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * Clear the entire send buffer
1:4f996a4:      *
1:4f996a4:      */
1:4f996a4:     protected void clearBuffer()
1:4f996a4:     {
1:298ff5e:         buffer.clear();
1:4f996a4:         top = 0;
1:4f996a4:         dssLengthLocation = 0;
1:4f996a4:         correlationID = DssConstants.CORRELATION_ID_UNKNOWN;
1:4f996a4:         nextCorrelationID = 1;
1:4f996a4:         isDRDAProtocol = true;
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * End the current DDM
1:4f996a4:      *
1:4f996a4:      */
1:4f996a4:     protected void endDdm ()
1:4f996a4:     {
1:4f996a4:         // remove the top length location offset from the mark stack
1:4f996a4:         // calculate the length based on the marked location and end of data.
1:4f996a4:         int lengthLocation = markStack[--top];
1:a0adefe:         int length = buffer.position() - lengthLocation;
1:eac0369: 
1:db9a013:         // determine if any extended length bytes are needed.   the value returned
1:4f996a4:         // from calculateExtendedLengthByteCount is the number of extended length
1:4f996a4:         // bytes required. 0 indicates no exteneded length.
1:4f996a4:         int extendedLengthByteCount = calculateExtendedLengthByteCount (length);
1:4f996a4:         if (extendedLengthByteCount != 0)
1:4f996a4:         {
1:4f996a4:             // ensure there is enough room in the buffer for the extended length bytes.
1:4f996a4:             ensureLength (extendedLengthByteCount);
1:eac0369: 
1:4f996a4:             // calculate the length to be placed in the extended length bytes.
1:4f996a4:             // this length does not include the 4 byte llcp.
1:4f996a4:             int extendedLength = length - 4;
1:eac0369: 
1:a0adefe:             // the extended length should be written right after the length and
1:a0adefe:             // the codepoint (2+2 bytes)
1:a0adefe:             final int extendedLengthLocation = lengthLocation + 4;
1:a0adefe: 
1:4f996a4:             // shift the data to the right by the number of extended
1:4f996a4:             // length bytes needed.
1:a0adefe:             buffer.position(extendedLengthLocation + extendedLengthByteCount);
1:a0adefe:             buffer.put(buffer.array(), extendedLengthLocation, extendedLength);
1:eac0369: 
1:a1f0068:             // write the extended length (a variable number of bytes in
1:a1f0068:             // big-endian order)
1:a1f0068:             for (int pos = extendedLengthLocation + extendedLengthByteCount - 1;
1:a1f0068:                  pos >= extendedLengthLocation; pos--) {
1:a1f0068:                 buffer.put(pos, (byte) extendedLength);
1:a1f0068:                 extendedLength >>= 8;
1:4f996a4:             }
1:eac0369: 
1:4f996a4:             // the two byte length field before the codepoint contains the length
1:4f996a4:             // of itself, the length of the codepoint, and the number of bytes used
1:db9a013:             // to hold the extended length. the 2 byte length field also has the first
1:4f996a4:             // bit on to indicate extended length bytes were used.
1:4f996a4:             length = extendedLengthByteCount + 4;
1:4f996a4:             length |= DssConstants.CONTINUATION_BIT;
1:4f996a4:         }
1:eac0369: 
1:4f996a4:         // write the 2 byte length field (2 bytes before codepoint).
1:a1f0068:         buffer.putShort(lengthLocation, (short) length);
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:974609a:      * Get the length of the current DSS block we're working on. This is
1:974609a:      * used by the LMTBLKPRC protocol, which does its own conversational
1:974609a:      * blocking protocol above the layer of the DRDA blocking. The LMTBLKPRC
1:974609a:      * implementation (in DRDAConnThread) needs to be able to truncate a
1:974609a:      * DSS block when splitting a QRYDTA response.
1:4f996a4:      *
1:974609a:      * @return current DSS block length
1:4f996a4:     */
1:974609a:     protected int getDSSLength()
1:4f996a4:     {
1:298ff5e:         return buffer.position() - dssLengthLocation;
1:4f996a4:     }
1:974609a:  
1:4f996a4:     /**
1:974609a:      * Truncate the current DSS. Before making this call, you should ensure
1:974609a:      * that you have copied the data to be truncated somewhere else, by
1:974609a:      * calling copyDSSDataToEnd
1:4f996a4:      *
1:6b50965:      * @param value DSS length
1:4f996a4:     */
1:974609a:     protected void truncateDSS(int value)
1:4f996a4:     {
1:298ff5e:         buffer.position(dssLengthLocation + value);
1:4f996a4:     }
1:eac0369: 
1:eac0369: 
1:4f996a4:     // Write routines
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * Write byte
1:4f996a4:      *
1:db9a013:      * @param   value   byte to be written
1:4f996a4:      */
1:4f996a4:     protected void writeByte (int value)
1:4f996a4:     {
1:4f996a4:         if (SanityManager.DEBUG)
1:4f996a4:         {
1:4f996a4:             if (value > 255)
1:4f996a4:                 SanityManager.THROWASSERT(
1:4f996a4:                                        "writeByte value: " + value +
1:4f996a4:                                        " may not be > 255");
1:4f996a4:         }
1:eac0369: 
1:4f996a4:         ensureLength (1);
1:298ff5e:         buffer.put((byte) value);
1:4f996a4:     }
1:eac0369: 
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * Write network short
1:4f996a4:      *
1:db9a013:      * @param   value   value to be written
1:4f996a4:      */
1:4f996a4:     protected void writeNetworkShort (int value)
1:4f996a4:     {
1:4f996a4:         ensureLength (2);
1:298ff5e:         buffer.putShort((short) value);
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * Write network int
1:4f996a4:      *
1:db9a013:      * @param   value   value to be written
1:4f996a4:      */
1:4f996a4:     protected void writeNetworkInt (int value)
1:4f996a4:     {
1:4f996a4:         ensureLength (4);
1:298ff5e:         buffer.putInt(value);
1:4f996a4:     }
1:eac0369: 
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * Write byte array
1:4f996a4:      *
1:db9a013:      * @param   buf byte array to be written
1:db9a013:      * @param   length  - length to write
1:4f996a4:      */
1:4f996a4:     protected void writeBytes (byte[] buf, int length)
1:4f996a4:     {
1:4f996a4:         writeBytes(buf, 0,length);
1:4f996a4:     }
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * Write byte array
1:4f996a4:      *
1:db9a013:      * @param   buf byte array to be written
1:db9a013:      * @param   start  - starting position
1:db9a013:      * @param   length  - length to write
1:4f996a4:      */
1:4f996a4:     protected void writeBytes (byte[] buf, int start, int length)
1:4f996a4:     {
1:eac0369: 
1:4f996a4:         if (SanityManager.DEBUG)
1:4f996a4:         {
1:4f996a4:             if (buf == null && length > 0)
1:4f996a4:                 SanityManager.THROWASSERT("Buf is null");
1:4f996a4:             if (length + start - 1 > buf.length)
1:4f996a4:                 SanityManager.THROWASSERT("Not enough bytes in buffer");
1:eac0369: 
1:4f996a4:         }
1:4f996a4:         ensureLength (length);
1:298ff5e:         buffer.put(buf, start, length);
1:4f996a4:     }
1:4f996a4:     /**
1:4f996a4:      * Write byte array
1:4f996a4:      *
1:db9a013:      * @param   buf byte array to be written
1:4f996a4:      **/
1:4f996a4:     protected void writeBytes (byte[] buf)
1:4f996a4:     {
1:4f996a4:         writeBytes(buf,buf.length);
1:4f996a4:     }
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:4f996a4:     protected void writeLDBytes(byte[] buf)
1:4f996a4:     {
1:4f996a4:         writeLDBytes(buf, 0);
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     protected void writeLDBytes(byte[] buf, int index)
1:4f996a4:     {
1:4f996a4:         int writeLen =  buf.length;
1:eac0369: 
1:4f996a4:         writeShort(writeLen);
1:eac0369: 
1:4f996a4:         writeBytes(buf,0,writeLen);
1:4f996a4:     }
1:eac0369: 
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * Write code point and 4 bytes
1:4f996a4:      *
1:db9a013:      * @param   codePoint - code point to write
1:db9a013:      * @param   value  - value to write after code point
1:4f996a4:      */
1:4f996a4:     void writeCodePoint4Bytes (int codePoint, int value)
1:4f996a4:     {
1:4f996a4:         ensureLength (4);
1:298ff5e:         buffer.putShort((short) codePoint);
1:298ff5e:         buffer.putShort((short) value);
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * Write scalar 1 byte object includes length, codepoint and value
1:4f996a4:      *
1:db9a013:      * @param   codePoint - code point to write
1:db9a013:      * @param   value  - value to write after code point
1:4f996a4:      */
1:4f996a4:     void writeScalar1Byte (int codePoint, int value)
1:4f996a4:     {
1:4f996a4:         ensureLength (5);
1:298ff5e:         buffer.putShort((short) 0x0005);
1:298ff5e:         buffer.putShort((short) codePoint);
1:298ff5e:         buffer.put((byte) value);
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * Write scalar 2 byte object includes length, codepoint and value
1:4f996a4:      *
1:db9a013:      * @param   codePoint - code point to write
1:db9a013:      * @param   value  - value to write after code point
1:4f996a4:      */
1:4f996a4:     protected void writeScalar2Bytes (int codePoint, int value)
1:4f996a4:     {
1:4f996a4:         ensureLength (6);
1:298ff5e:         buffer.putShort((short) 0x0006);
1:298ff5e:         buffer.putShort((short) codePoint);
1:298ff5e:         buffer.putShort((short) value);
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     protected void writeScalar2Bytes ( int value)
1:4f996a4:     {
1:4f996a4:         ensureLength (2);
1:298ff5e:         buffer.putShort((short) value);
1:4f996a4:     }
1:eac0369:     
1:f3ab04f:     protected void writeScalarStream (boolean chainedWithSameCorrelator,
1:4f996a4:                                       int codePoint,
1:4f996a4:                       EXTDTAInputStream in,
1:4f996a4:                                       boolean writeNullByte) 
1:4f996a4:         throws DRDAProtocolException
1:4f996a4:     {
1:4f996a4: 
1:d79abcf:         
1:eac0369: 
1:4f996a4:         // Stream equivalent of "beginDss"...
1:4f996a4:         int spareDssLength = prepScalarStream( chainedWithSameCorrelator,
1:4f996a4:                                             codePoint,
1:4f996a4:                                             writeNullByte);
1:4f996a4:         
1:4f996a4:         // write the data
1:4f996a4:                 try {
1:4f996a4:                     
1:4f996a4:         OutputStream out = 
1:4f996a4:             placeLayerBStreamingBuffer( agent.getOutputStream() );
1:4f996a4:         
1:4f996a4:         boolean isLastSegment = false;
1:4f996a4:         
1:4f996a4:         while( !isLastSegment ){
1:4f996a4:             
1:4f996a4:             if( SanityManager.DEBUG ){
1:4f996a4:         
1:4f996a4:             if( PropertyUtil.getSystemBoolean("derby.debug.suicideOfLayerBStreaming") )
1:4f996a4:                 throw new IOException();
1:4f996a4:                 }
1:298ff5e: 
1:a0adefe:             // read as many bytes as possible directly into the backing array
1:298ff5e:             final int offset = buffer.position();
1:a0adefe:             final int bytesRead =
1:a0adefe:                 in.read(buffer.array(), offset,
1:a0adefe:                         Math.min(spareDssLength, buffer.remaining()));
1:a0adefe: 
1:a0adefe:             // update the buffer position
1:298ff5e:             buffer.position(offset + bytesRead);
1:a0adefe: 
1:4f996a4:             spareDssLength -= bytesRead;
1:d79abcf: 
1:4f996a4:             isLastSegment = peekStream(in) < 0;
1:4f996a4:             
1:4f996a4:             if(isLastSegment || 
1:4f996a4:                spareDssLength == 0){
1:4f996a4:             
1:4f996a4:             flushScalarStreamSegment (isLastSegment, 
1:4f996a4:                           out);
1:4f996a4:             
1:4f996a4:             if( ! isLastSegment )
1:4f996a4:                 spareDssLength = DssConstants.MAX_DSS_LENGTH - 2;
1:4f996a4: 
1:4f996a4:             }
1:4f996a4:             
1:4f996a4:         }
1:eac0369:         
1:4f996a4:         out.flush();
1:4f996a4:         
1:4f996a4:         }catch(IOException e){
1:4f996a4:         agent.markCommunicationsFailure (e,"DDMWriter.writeScalarStream()",
1:4f996a4:                          "",
1:4f996a4:                          e.getMessage(),
1:4f996a4:                          "*");
1:4f996a4:         }
1:4f996a4:                 
1:4f996a4:     }
1:4f996a4:     
1:4f996a4:     /**
1:4f996a4:      * Begins a DSS stream (for writing LOB data).
1:4f996a4:      */
1:4f996a4:     private void beginDss (boolean chainedToNextStructure,
1:4f996a4:                            int dssType)
1:4f996a4:     {
1:db9a013:         beginDss(dssType, false);   // false => don't ensure length.
1:eac0369: 
1:4f996a4:         // always turn on continuation flags... this is helpful for lobs...
1:4f996a4:         // these bytes will get rest if dss lengths are finalized.
1:a1f0068:         buffer.putShort(dssLengthLocation, (short) 0xFFFF);
1:eac0369: 
1:4f996a4:         // Set whether or not this DSS should be chained to
1:4f996a4:         // the next one.  If it's chained, it has to be chained
1:4f996a4:         // with same id (that's the nature of EXTDTA chaining).
1:4f996a4:         if (chainedToNextStructure) {
1:4f996a4:             dssType |= DssConstants.GDSCHAIN_SAME_ID;
1:4f996a4:         }
1:eac0369: 
1:a1f0068:         buffer.put(dssLengthLocation + 3, (byte) dssType);
1:4f996a4:     }
1:eac0369: 
1:eac0369: 
1:4f996a4:     /**
1:f3ab04f:      * prepScalarStream does the following prep for writing stream data:
1:f3ab04f:      * 1.  Flushes an existing DSS segment, if necessary
1:f3ab04f:      * 2.  Determines if extended length bytes are needed
1:f3ab04f:      * 3.  Creates a new DSS/DDM header and a null byte indicator, if applicable
1:4f996a4:      *
1:f3ab04f:      * If value of length was less than 0, this method processes streaming as Layer B Streaming.
1:f3ab04f:      * cf. page 315 of specification of DRDA, Version 3, Volume 3 
2:d79abcf:      *
2:a54b657:      */
1:977561c:   private int prepScalarStream( boolean chainedWithSameCorrelator,
2:eac0369:                                    int codePoint,
1:977561c:                                    boolean writeNullByte) throws DRDAProtocolException
1:4f996a4:   {
1:eac0369: 
1:298ff5e:       ensureLength( DEFAULT_BUFFER_SIZE - buffer.position() );
1:eac0369:       
1:977561c:       final int nullIndicatorSize = writeNullByte ? 1:0;
1:eac0369: 
1:eac0369:     
1:977561c:       // flush the existing DSS segment ,
1:977561c:       // if this stream will not fit in the send buffer or 
1:977561c:       // length of this stream is unknown.
1:977561c:       // Here, 10 stands for sum of headers of layer A and B.
1:eac0369: 
1:d79abcf:       try {
1:4f996a4:         // The existing DSS segment was finalized by endDss; all
1:4f996a4:         // we have to do is send it across the wire.
1:eac0369:         sendBytes(agent.getOutputStream());
1:4f996a4:       }
3:eac0369:       catch (java.io.IOException e) {
1:eac0369:          agent.markCommunicationsFailure ("DDMWriter.writeScalarStream()",
1:d79abcf:                                               "OutputStream.flush()",
1:d79abcf:                                               e.getMessage(),"*");
1:4f996a4:       }
1:eac0369: 
1:eac0369:     // buildStreamDss should not call ensure length.
1:4f996a4:     beginDss(chainedWithSameCorrelator, DssConstants.GDSFMT_OBJDSS);
1:eac0369: 
1:977561c:       writeLengthCodePoint(0x8004,codePoint);
1:eac0369: 
1:eac0369: 
1:eac0369:     // write the null byte, if necessary
5:eac0369:     if (writeNullByte)
1:eac0369:       writeByte(0x0);
1:eac0369: 
1:977561c:       //Here, 6 stands for header of layer A and 
1:977561c:       //4 stands for header of layer B.
1:977561c:       return DssConstants.MAX_DSS_LENGTH - 6 - 4 - nullIndicatorSize;
1:eac0369: 
1:eac0369: 
1:4f996a4:   }
1:eac0369: 
1:eac0369: 
1:eac0369:   // method to determine if any data is in the request.
1:eac0369:   // this indicates there is a dss object already in the buffer.
1:4f996a4:     protected boolean doesRequestContainData()
1:4f996a4:     {
1:298ff5e:         return buffer.position() != 0;
1:4f996a4:     }
1:eac0369: 
1:eac0369: 
1:4f996a4:     // Writes out a scalar stream DSS segment, along with DSS continuation
1:4f996a4:     // headers if necessary.
1:4f996a4:     private void flushScalarStreamSegment ( boolean lastSegment,
1:4f996a4:                             OutputStream out)
1:4f996a4:         throws DRDAProtocolException
1:4f996a4:     {
1:eac0369: 
1:4f996a4:         // either at end of data, end of dss segment, or both.
1:4f996a4:         if (! lastSegment) {
1:d79abcf: 
1:4f996a4:         // 32k segment filled and not at end of data.
1:4f996a4:                 try {
1:4f996a4:                 // Mark current DSS as continued, set its chaining state,
1:4f996a4:                 // then send the data across.
1:db9a013:                     markDssAsContinued(true);   // true => for lobs
1:4f996a4:                     sendBytes (out,
1:4f996a4:                            false);
1:4f996a4:                 
1:4f996a4:             }catch (java.io.IOException ioe) {
1:4f996a4:                     agent.markCommunicationsFailure ("DDMWriter.flushScalarStreamSegment()",
1:eac0369:                                                "",
1:eac0369:                                                ioe.getMessage(),
1:eac0369:                                                "*");
1:4f996a4:                 }
1:eac0369: 
1:eac0369: 
1:4f996a4:             // Prepare a DSS continuation header for next DSS.
1:298ff5e:             dssLengthLocation = buffer.position();
1:298ff5e:             buffer.putShort((short) 0xFFFF);
1:4f996a4:             isContinuationDss = true;
1:4f996a4:         }else{
1:4f996a4:         // we're done writing the data, so end the DSS.
1:4f996a4:             endDss();
1:eac0369: 
1:4f996a4:     }
1:eac0369: 
1:4f996a4:   }
1:eac0369: 
1:eac0369: 
1:eac0369:   // insert a 4 byte length/codepoint pair into the buffer.
1:eac0369:   // total of 4 bytes inserted in buffer.
1:eac0369:   // Note: the length value inserted in the buffer is the same as the value
1:eac0369:   // passed in as an argument (this value is NOT incremented by 4 before being
1:eac0369:   // inserted).
1:eac0369:   void writeLengthCodePoint (int length, int codePoint)
1:a54b657:   {
4:eac0369:     ensureLength (4);
1:298ff5e:     buffer.putShort((short) length);
1:298ff5e:     buffer.putShort((short) codePoint);
1:cdfb2d1:   }
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * Write scalar object header includes length and codepoint
1:4f996a4:      *
1:db9a013:      * @param   codePoint - code point to write
1:db9a013:      * @param   dataLength - length of object data
1:4f996a4:      */
1:4f996a4:     protected void writeScalarHeader (int codePoint, int dataLength)
1:4f996a4:     {
1:4f996a4:         ensureLength (dataLength + 4);
1:298ff5e:         buffer.putShort((short) (dataLength + 4));
1:298ff5e:         buffer.putShort((short) codePoint);
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * Write scalar string object includes length, codepoint and value
1:4f996a4:      * the string is converted into the appropriate codeset (EBCDIC)
1:4f996a4:      *
1:db9a013:      * @param   codePoint - code point to write
1:db9a013:      * @param   string - string to be written
1:4f996a4:      */
1:4f996a4:     void writeScalarString (int codePoint, String string)
1:4f996a4:     {
1:4f996a4:         int stringLength = ccsidManager.getByteLength(string);
1:4f996a4:         ensureLength ((stringLength * 2)  + 4);
1:298ff5e:         buffer.putShort((short) (stringLength + 4));
1:298ff5e:         buffer.putShort((short) codePoint);
1:4f996a4:         ccsidManager.convertFromJavaString(string, buffer);
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * Write padded scalar string object includes length, codepoint and value
1:4f996a4:      * the string is converted into the appropriate codeset (EBCDIC)
1:4f996a4:      *
1:db9a013:      * @param   codePoint - code point to write
1:db9a013:      * @param   string - string to be written
1:db9a013:      * @param   paddedLength - length to pad string to
1:4f996a4:      */
1:4f996a4:     void writeScalarPaddedString (int codePoint, String string, int paddedLength)
1:4f996a4:     {
1:4f996a4:         int stringLength = ccsidManager.getByteLength(string);
1:4f996a4:         int fillLength = paddedLength - stringLength;
1:4f996a4:         ensureLength (paddedLength + 4);
1:298ff5e:         buffer.putShort((short) (paddedLength + 4));
1:298ff5e:         buffer.putShort((short) codePoint);
1:4f996a4:         ccsidManager.convertFromJavaString(string, buffer);
1:a1f0068:         padBytes(ccsidManager.space, fillLength);
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * Write padded scalar <code>DRDAString</code> object value. The
1:4f996a4:      * string is converted into the appropriate codeset.
1:4f996a4:      *
1:4f996a4:      * @param drdaString string to be written
1:4f996a4:      * @param paddedLength length to pad string to
1:4f996a4:      */
1:4f996a4:     protected void writeScalarPaddedString (DRDAString drdaString, int paddedLength)
1:4f996a4:     {
1:4f996a4:         /* This .length() call is valid as this is a DRDAString */
1:4f996a4:         int stringLength = drdaString.length();
1:4f996a4:         int fillLength = paddedLength - stringLength;
1:4f996a4:         ensureLength(paddedLength);
1:298ff5e:         buffer.put(drdaString.getBytes(), 0, stringLength);
1:a1f0068:         padBytes(ccsidManager.space, fillLength);
1:4f996a4:     }
1:ee2a860: 
1:4f996a4:     /**
1:4f996a4:      * Write padded scalar byte array object includes length, codepoint and value
1:4f996a4:      *
1:db9a013:      * @param   codePoint - code point to write
1:db9a013:      * @param   buf - byte array to be written
1:db9a013:      * @param   paddedLength - length to pad string to
1:db9a013:      * @param   padByte - byte to be used for padding
1:4f996a4:      */
1:4f996a4:     protected void writeScalarPaddedBytes (int codePoint, byte[] buf, int paddedLength, byte padByte)
1:4f996a4:     {
1:4f996a4:         ensureLength (paddedLength + 4);
1:298ff5e:         buffer.putShort((short) (paddedLength + 4));
1:298ff5e:         buffer.putShort((short) codePoint);
1:298ff5e:         buffer.put(buf);
1:a1f0068:         padBytes(padByte, paddedLength - buf.length);
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * Write padded scalar byte array object  value
1:4f996a4:      *
1:db9a013:      * @param   buf - byte array to be written
1:db9a013:      * @param   paddedLength - length to pad string to
1:db9a013:      * @param   padByte - byte to be used for padding
1:4f996a4:      */
1:4f996a4:     protected void writeScalarPaddedBytes (byte[] buf, int paddedLength, byte padByte)
1:4f996a4:     {
1:4f996a4:         ensureLength (paddedLength);
1:298ff5e:         buffer.put(buf);
1:a1f0068:         padBytes(padByte, paddedLength - buf.length);
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * Write scalar byte array object includes length, codepoint and value
1:4f996a4:      *
1:db9a013:      * @param   codePoint - code point to write
1:db9a013:      * @param   buf - byte array to be written
1:4f996a4:      */
1:4f996a4:     protected void writeScalarBytes (int codePoint, byte[] buf)
1:4f996a4:     {
1:298ff5e:         ensureLength(buf.length + 4);
1:298ff5e:         buffer.putShort((short) (buf.length + 4));
1:298ff5e:         buffer.putShort((short) codePoint);
1:298ff5e:         buffer.put(buf);
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     // The following methods write data in the platform format
1:4f996a4:     // The platform format was indicated during connection time as ASC since
1:4f996a4:     // JCC doesn't read JVM platform (yet)
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * Write platform short
1:4f996a4:      *
1:db9a013:      * @param   v   value to be written
1:4f996a4:      */
1:4f996a4:     protected void writeShort (int v)
1:4f996a4:     {
1:4f996a4:         writeNetworkShort(v);
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * Write boolean as short
1:4f996a4:      * @param b boolean value true = 1 false = 0
1:4f996a4:      *
1:4f996a4:      */
1:4f996a4:     protected void writeShort(boolean b)
1:4f996a4:     {
1:4f996a4:         writeNetworkShort(b ? 1 : 0);
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * Write platform int
1:4f996a4:      *
1:db9a013:      * @param   v   value to be written
1:4f996a4:      */
1:4f996a4:     protected void writeInt (int v)
1:4f996a4:     {
1:4f996a4:         writeNetworkInt(v);
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * Write platform long
1:4f996a4:      *
1:db9a013:      * @param   v   value to be written
1:4f996a4:      */
1:4f996a4:     protected void writeLong (long v)
1:4f996a4:     {
1:4f996a4:         ensureLength (8);
1:298ff5e:         buffer.putLong(v);
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * Write platform float
1:4f996a4:      *
1:db9a013:      * @param   v   value to be written
1:4f996a4:      */
1:4f996a4:     protected void writeFloat (float v)
1:4f996a4:     {
1:4f996a4:         writeInt (Float.floatToIntBits (v));
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * Write platform double
1:4f996a4:      *
1:db9a013:      * @param   v   value to be written
1:4f996a4:      */
1:4f996a4:     protected void writeDouble (double v)
1:4f996a4:     {
1:4f996a4:         writeLong (Double.doubleToLongBits (v));
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * Write platform boolean
1:4f996a4:      *
1:db9a013:      * @param   v   value to be written
1:4f996a4:      */
1:4f996a4:     protected void writeBoolean (boolean v)
1:4f996a4:     {
1:298ff5e:         writeByte(v ? 1 : 0);
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * Write length delimited string
1:4f996a4:      *
1:4f996a4:      * @param s value to be written with integer
1:4f996a4:      *
1:4f996a4:      * @exception DRDAProtocolException
1:4f996a4:      */
1:4f996a4:     protected void writeLDString(String s) throws DRDAProtocolException
1:506f4c8:     {
1:b850119:         writeLDString(s, 0, null, false);
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:506f4c8:      * Write a value of a user defined type.
1:506f4c8:      *
1:506f4c8:      * @param val object to be written
1:506f4c8:      *
1:506f4c8:      * @exception DRDAProtocolException
1:506f4c8:      */
1:506f4c8:     protected void writeUDT( Object val, int index ) throws DRDAProtocolException
1:506f4c8:     {
1:506f4c8:         // should not be called if val is null
1:a519191:         if (SanityManager.DEBUG)
1:a519191:         {
1:a519191:             if ( val == null )
1:a519191:             {
1:a519191:                 SanityManager.THROWASSERT( "UDT is null" );
1:a519191:             }
1:506f4c8:         }
1:506f4c8: 
1:506f4c8:         byte[] buffer = null;
1:506f4c8:         int length = 0;
1:506f4c8: 
1:506f4c8:         try {
1:506f4c8:             DynamicByteArrayOutputStream dbaos = new DynamicByteArrayOutputStream();
1:506f4c8:             ObjectOutputStream oos = new ObjectOutputStream( dbaos );
1:506f4c8: 
1:506f4c8:             oos.writeObject( val );
1:506f4c8: 
1:506f4c8:             buffer = dbaos.getByteArray();
1:506f4c8:             length = dbaos.getUsed();
1:506f4c8:             
1:506f4c8:         } catch(IOException e)
1:506f4c8:         {
1:506f4c8:             agent.markCommunicationsFailure
1:506f4c8:                 ( e,"DDMWriter.writeUDT()", "", e.getMessage(), "" );
1:506f4c8:         }
1:506f4c8: 
1:506f4c8:         if ( length > DRDAConstants.MAX_DRDA_UDT_SIZE )
1:506f4c8:         {
1:506f4c8:             agent.markCommunicationsFailure
1:506f4c8:                 ( "DDMWriter.writeUDT()", "User defined type is longer than " + DRDAConstants.MAX_DRDA_UDT_SIZE + " bytes.", "", "" );
1:506f4c8:         }
1:506f4c8:         else
1:506f4c8:         {
1:506f4c8:             writeShort( length );
1:506f4c8:             writeBytes( buffer, 0, length );
1:506f4c8:         }
1:506f4c8:     }
1:506f4c8: 
1:506f4c8:     /**
1:9f8e1eb:      * Find the maximum number of bytes needed to represent the string in the
1:9f8e1eb:      * default encoding.
1:9f8e1eb:      *
1:9f8e1eb:      * @param s the string to encode
1:9f8e1eb:      * @return an upper limit for the number of bytes needed to encode the
1:9f8e1eb:      * string
1:9f8e1eb:      */
1:9f8e1eb:     private int maxEncodedLength(String s) {
1:9f8e1eb:         // maxBytesPerChar() returns a float, which can only hold 24 bits of an
1:9f8e1eb:         // integer. Therefore, promote the float to a double so that all bits
1:9f8e1eb:         // are preserved in the intermediate result.
1:9f8e1eb:         return (int) (s.length() * (double) encoder.maxBytesPerChar());
1:9f8e1eb:     }
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * Write length delimited string
1:4f996a4:      *
1:4f996a4:      * @param s              value to be written with integer
1:4f996a4:      * @param index          column index to put in warning
1:b850119:      * @param stmt           the executing statement (null if not invoked as
1:b850119:      *                       part of statement execution)
1:b850119:      * @param isParameter    true if the value written is for an output
1:b850119:      *                       parameter in a procedure call
1:4f996a4:      * @exception DRDAProtocolException
1:4f996a4:      */
1:b850119:     protected void writeLDString(String s, int index, DRDAStatement stmt,
1:b850119:                                  boolean isParameter)
1:b850119:             throws DRDAProtocolException
1:4f996a4:     {
1:9f8e1eb:         // Position on which to write the length of the string (in bytes). The
1:9f8e1eb:         // actual writing of the length is delayed until we have encoded the
1:9f8e1eb:         // string.
1:9f8e1eb:         final int lengthPos = buffer.position();
1:eac0369: 
1:c6e4294:         // Reserve two bytes for the length field and move the position to
1:c6e4294:         // where the string should be inserted.
1:c6e4294:         ensureLength(2);
1:c6e4294:         final int stringPos = lengthPos + 2;
1:c6e4294:         buffer.position(stringPos);
1:eac0369: 
1:c6e4294:         // Write the string.
1:c6e4294:         writeString(s);
1:eac0369: 
1:9b3e218:         // Find out how long strings the client supports, and possibly
1:9b3e218:         // truncate the string before sending it.
1:9b3e218: 
1:9b3e218:         int maxByteLength = MAX_VARCHAR_BYTE_LENGTH;
1:9b3e218:         boolean warnOnTruncation = true;
1:9b3e218: 
1:9b3e218:         AppRequester appRequester = agent.getSession().appRequester;
1:9b3e218:         if (appRequester != null && !appRequester.supportsLongerLDStrings()) {
1:9b3e218:             // The client suffers from DERBY-5236, and it doesn't support
1:9b3e218:             // receiving as long strings as newer clients do. It also doesn't
1:9b3e218:             // know exactly what to do with a DataTruncation warning, so skip
1:9b3e218:             // sending it to old clients.
1:9b3e218:             maxByteLength = FdocaConstants.LONGVARCHAR_MAX_LEN;
1:9b3e218:             warnOnTruncation = false;
1:9b3e218:         }
1:9b3e218: 
1:c6e4294:         int byteLength = buffer.position() - stringPos;
1:eac0369: 
1:c6e4294:         // If the byte representation of the string is too long, it needs to
1:c6e4294:         // be truncated.
1:9b3e218:         if (byteLength > maxByteLength) {
1:c6e4294:             // Truncate the string down to the maximum byte length.
1:9b3e218:             byteLength = maxByteLength;
1:c6e4294:             // Align with character boundaries so that we don't send over
1:c6e4294:             // half a character.
1:c6e4294:             while (isContinuationByte(buffer.get(stringPos + byteLength))) {
1:c6e4294:                 byteLength--;
1:c6e4294:             }
1:b850119: 
1:b850119:             // Check how many chars that were truncated.
1:b850119:             int truncatedChars = 0;
1:b850119:             for (int i = stringPos + byteLength; i < buffer.position(); i++) {
1:b850119:                 if (!isContinuationByte(buffer.get(i))) {
1:b850119:                     truncatedChars++;
1:b850119:                 }
1:b850119:             }
1:b850119: 
1:c6e4294:             // Set the buffer position right after the truncated string.
1:c6e4294:             buffer.position(stringPos + byteLength);
1:b850119: 
1:9b3e218:             // If invoked as part of statement execution, and the client
1:9b3e218:             // supports receiving DataTruncation warnings, add a warning about
1:b850119:             // the string being truncated.
1:9b3e218:             if (warnOnTruncation && stmt != null) {
1:b850119:                 DataTruncation dt = new DataTruncation(
1:b850119:                         index,
1:b850119:                         isParameter,
1:b850119:                         true,  // this is a warning for a read operation
1:b850119:                         s.length(),                   // dataSize
1:b850119:                         s.length() - truncatedChars); // transferSize
1:b850119:                 stmt.addTruncationWarning(dt);
1:b850119:             }
1:c6e4294:         }
1:eac0369: 
1:c6e4294:         // Go back and write the length in bytes.
1:c6e4294:         buffer.putShort(lengthPos, (short) byteLength);
1:4f996a4:     }
1:eac0369: 
1:c6e4294:     /**
1:c6e4294:      * Check if a byte value represents a continuation byte in a UTF-8 byte
1:c6e4294:      * sequence. Continuation bytes in UTF-8 always match the bit pattern
1:c6e4294:      * {@code 10xxxxxx}.
1:c6e4294:      *
1:c6e4294:      * @param b the byte to check
1:c6e4294:      * @return {@code true} if {@code b} is a continuation byte, or
1:c6e4294:      * {@code false} if it is the first byte in a UTF-8 sequence
1:c6e4294:      */
1:c6e4294:     private static boolean isContinuationByte(byte b) {
1:c6e4294:         // Check the values of the two most significant bits. If they are
1:c6e4294:         // 10xxxxxx, it's a continuation byte.
1:c6e4294:         return (b & 0xC0) == 0x80;
1:c6e4294:     }
1:c6e4294: 
1:4f996a4:     /**
1:4f996a4:      * Write string with default encoding
1:4f996a4:      *
1:4f996a4:      * @param s value to be written
1:4f996a4:      *
1:4f996a4:      * @exception DRDAProtocolException
1:4f996a4:      */
1:4f996a4:     protected void writeString(String s) throws DRDAProtocolException
1:4f996a4:     {
1:9f8e1eb:         ensureLength(maxEncodedLength(s));
1:9f8e1eb:         CharBuffer input = CharBuffer.wrap(s);
1:a6bc42e:         encoder.reset();
1:9f8e1eb:         CoderResult res = encoder.encode(input, buffer, true);
1:a6bc42e:         if (res == CoderResult.UNDERFLOW) {
1:a6bc42e:             res = encoder.flush(buffer);
1:a6bc42e:         }
1:9f8e1eb:         if (SanityManager.DEBUG) {
1:9f8e1eb:             SanityManager.ASSERT(res == CoderResult.UNDERFLOW,
1:9f8e1eb:                                  "CharBuffer was not exhausted: res = " + res);
1:a6bc42e:         }
1:4f996a4:     }
1:9f8e1eb: 
1:4f996a4:     /**
1:4f996a4:      * Write pad bytes using spaceChar
1:4f996a4:      *
1:db9a013:      * @param   val value to be written
1:db9a013:      * @param   length      length to be written
1:4f996a4:      */
1:4f996a4:     protected void padBytes (byte val, int length)
1:4f996a4:     {
1:298ff5e:         final int offset = buffer.position();
1:298ff5e:         final int end = offset + length;
1:a1f0068:         Arrays.fill(buffer.array(), offset, end, val);
1:298ff5e:         buffer.position(end);
1:4f996a4:     }
1:9f8e1eb: 
1:4f996a4:     /**
1:4f996a4:      * Flush buffer to outputstream
1:4f996a4:      *
1:4f996a4:      *
1:4f996a4:      * @exception IOException
1:4f996a4:      */
1:4f996a4:     protected void flush () throws java.io.IOException
1:4f996a4:     {
1:4f996a4:         flush(agent.getOutputStream());
1:4f996a4:     }
1:d79abcf: 
1:4f996a4:     /**
1:4f996a4:      * Flush buffer to specified stream
1:4f996a4:      *
1:4f996a4:      * @param socketOutputStream
1:4f996a4:      *
1:4f996a4:      * @exception IOException
1:4f996a4:      */
1:4f996a4:     protected void flush(OutputStream socketOutputStream)
1:4f996a4:         throws java.io.IOException
1:4f996a4:     {
1:a1f0068:         final byte[] bytes = buffer.array();
1:4f996a4:         final int length = buffer.position();
1:4f996a4:         try {
1:4f996a4:             socketOutputStream.write (bytes, 0, length);
1:4f996a4:             socketOutputStream.flush();
1:4f996a4:         }
1:4f996a4:         finally {
1:4f996a4:             if ((dssTrace != null) && dssTrace.isComBufferTraceOn()) {
1:4f996a4:               dssTrace.writeComBufferData (bytes,
1:4f996a4:                                            0,
1:a1f0068:                                            length,
1:4f996a4:                                            DssTrace.TYPE_TRACE_SEND,
1:4f996a4:                                            "Reply",
1:4f996a4:                                            "flush",
1:4f996a4:                                            5);
1:4f996a4:             }
1:4f996a4:             reset(dssTrace);
1:4f996a4:         }
1:1ab256e:         totalByteCount += length;
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     // private methods
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * Write DSS header
1:4f996a4:      * DSS Header format is
1:db9a013:      *  2 bytes - length
1:db9a013:      *  1 byte  - 'D0'  - indicates DDM data
1:db9a013:      *  1 byte  - DSS format
1:db9a013:      *      |---|---------|----------|
1:db9a013:      *      | 0 |   flags | type     |
1:db9a013:      *      |---|---------|----------|
1:db9a013:      *      | 0 | 1 2   3 | 4 5 6 7  |
1:db9a013:      *      |---|---------|----------|
1:db9a013:      *      bit 0 - '0'
1:db9a013:      *      bit 1 - '0' - unchained, '1' - chained
1:db9a013:      *      bit 2 - '0' - do not continue on error, '1' - continue on error
1:db9a013:      *      bit 3 - '0' - next DSS has different correlator, '1' - next DSS has
1:db9a013:      *                      same correlator
1:db9a013:      *      type - 1 - Request DSS
1:db9a013:      *           - 2 - Reply DSS
1:db9a013:      *           - 3 - Object DSS
1:db9a013:      *           - 4 - Communications DSS
1:db9a013:      *           - 5 - Request DSS where no reply is expected
1:4f996a4:      */
1:4f996a4:     private void beginDss (int dssType, boolean ensureLen)
1:4f996a4:     {
1:d79abcf: 
1:4f996a4:         // save length position, the length will be written at the end
1:298ff5e:         dssLengthLocation = buffer.position();
1:eac0369: 
1:4f996a4:         // Should this really only be for non-stream DSSes?
1:4f996a4:         if (ensureLen)
1:4f996a4:             ensureLength(6);
1:d79abcf: 
1:4f996a4:         // Skip past length; we'll come back and set it later.
1:298ff5e:         buffer.position(dssLengthLocation + 2);
1:eac0369: 
1:4f996a4:         // write gds info
1:298ff5e:         buffer.put((byte) 0xD0);
1:eac0369: 
1:4f996a4:         // Write DSS type, and default chain bit to be 
1:4f996a4:         // DssConstants.DSSCHAIN_SAME_ID.  This default
1:4f996a4:         // will be overridden by calls to "finalizeChain()"
1:4f996a4:         // and/or calls to "beginDss(boolean, int)" for
1:4f996a4:         // writing LOB data.
1:298ff5e:         buffer.put((byte) (dssType | DssConstants.DSSCHAIN_SAME_ID));
1:d79abcf: 
1:4f996a4:         // save correlationID for use in error messages while processing
1:4f996a4:         // this DSS
1:4f996a4:         correlationID = getCorrelationID();
1:d79abcf: 
1:4f996a4:         // write the reply correlation id
1:298ff5e:         buffer.putShort((short) correlationID);
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:eac0369:      * Finish a DSS Layer A object.
1:4f996a4:      * The length of dss object will be calculated based on the difference between the
1:4f996a4:      * start of the dss, saved on the beginDss call, and the current
1:db9a013:      * offset into the buffer which marks the end of the data.  In the event
1:4f996a4:      * the length requires the use of continuation Dss headers, one for each 32k
1:4f996a4:      * chunk of data, the data will be shifted and the continuation headers
1:4f996a4:      * will be inserted with the correct values as needed.
1:4f996a4:      */
1:4f996a4:     private void finalizeDssLength ()
1:4f996a4:     {
1:298ff5e:         // initial position in the byte buffer
1:298ff5e:         final int offset = buffer.position();
1:298ff5e: 
1:4f996a4:         // calculate the total size of the dss and the number of bytes which would
1:4f996a4:         // require continuation dss headers.    The total length already includes the
1:db9a013:         // the 6 byte dss header located at the beginning of the dss.   It does not
1:4f996a4:         // include the length of any continuation headers.
1:4f996a4:         int totalSize = offset - dssLengthLocation;
1:4f996a4:         int bytesRequiringContDssHeader = totalSize - DssConstants.MAX_DSS_LENGTH;
1:eac0369: 
1:4f996a4:         // determine if continuation headers are needed
1:4f996a4:         if (bytesRequiringContDssHeader > 0)
1:4f996a4:         {
1:4f996a4:             // the continuation headers are needed, so calculate how many.
1:4f996a4:             // after the first 32767 worth of data, a continuation header is
1:4f996a4:             // needed for every 32765 bytes (32765 bytes of data + 2 bytes of
1:4f996a4:             // continuation header = 32767 Dss Max Size).
1:4f996a4:             int contDssHeaderCount = bytesRequiringContDssHeader / 32765;
1:4f996a4:             if (bytesRequiringContDssHeader % 32765 != 0)
1:4f996a4:                 contDssHeaderCount++;
1:eac0369: 
1:db9a013:             // right now the code will shift to the right.  In the future we may want
1:4f996a4:             // to try something fancier to help reduce the copying (maybe keep
1:4f996a4:             // space in the beginning of the buffer??).
1:4f996a4:             // the offset points to the next available offset in the buffer to place
1:4f996a4:             // a piece of data, so the last dataByte is at offset -1.
1:4f996a4:             // various bytes will need to be shifted by different amounts
1:4f996a4:             // depending on how many dss headers to insert so the amount to shift
1:db9a013:             // will be calculated and adjusted as needed.   ensure there is enough room
1:4f996a4:             // for all the conutinuation headers and adjust the offset to point to the
1:4f996a4:             // new end of the data.
1:4f996a4:             int dataByte = offset - 1;
1:4f996a4:             int shiftSize = contDssHeaderCount * 2;
1:4f996a4:             ensureLength (shiftSize);
1:a1f0068: 
1:a1f0068:             // We're going to access the buffer with absolute positions, so
1:a1f0068:             // just move the current position pointer right away to where it's
1:a1f0068:             // supposed to be after we have finished the shifting.
1:298ff5e:             buffer.position(offset + shiftSize);
1:eac0369: 
1:4f996a4:             // Notes on the behavior of the Layer B segmenting loop below:
1:f81f610:             //
1:4f996a4:             // We start with the right most chunk. For a 3-segment object we'd
1:4f996a4:             // shift 2 segments: shift the first (rightmost) one 4 bytes and 
1:4f996a4:             // the second one 2. Note that by 'first' we mean 'first time
1:4f996a4:             // through the loop', but that is actually the last segment
1:4f996a4:             // of data since we are moving right-to-left. For an object
1:4f996a4:             // of K segments we will pass through this loop K-1 times.
1:4f996a4:             // The 0th (leftmost) segment is not shifted, as it is
1:4f996a4:             // already in the right place. When we are done, we will
1:4f996a4:             // have made room in each segment for an additional
1:4f996a4:             // 2 bytes for the continuation header. Thus, each
1:4f996a4:             // segment K is shifted K*2 bytes to the right.
1:f81f610:             //
1:4f996a4:             // Each time through the loop, "dataByte" points to the
1:4f996a4:             // last byte in the segment; "dataToShift" is the amount of
1:4f996a4:             // data that we need to shift, and "shiftSize" is the
1:4f996a4:             // distance that we need to shift it. Since dataByte points
1:4f996a4:             // at the last byte, not one byte beyond it (as with the
1:4f996a4:             // "offset" variable used elsewhere in DDMWriter), the start
1:4f996a4:             // of the segement is actually at (dataByte-dataToShift+1).
3:4f996a4:             //
1:4f996a4:             // After we have shifted the segment, we move back to the
1:4f996a4:             // start of the segment and set the value of the 2-byte DSS
1:4f996a4:             // continuation header, which needs to hold the length of
1:4f996a4:             // this segment's data, together with the continuation flag
1:4f996a4:             // if this is not the rightmost (passOne) segment.
1:4f996a4:             //
1:4f996a4:             // In general, each segment except the rightmost will contain
1:4f996a4:             // 32765 bytes of data, plus the 2-byte header, and its
1:4f996a4:             // continuation flag will be set, so the header value will
1:4f996a4:             // be 0xFFFF. The rightmost segment will not have the
1:4f996a4:             // continuation flag set, so its value may be anything from
1:4f996a4:             // 0x0001 to 0x7FFF, depending on the amount of data in that
1:4f996a4:             // segment.
1:4f996a4:             //
1:4f996a4:             // Note that the 0th (leftmost) segment also has a 2-byte
1:4f996a4:             // DSS header, which needs to have its continuation flag set.
1:4f996a4:             // This is done by resetting the "totalSize" variable below,
1:4f996a4:             // at which point that variable no longer holds the total size
1:4f996a4:             // of the object, but rather just the length of segment 0. The
1:4f996a4:             // total size of the object was written using extended length
1:4f996a4:             // bytes by the endDdm() method earlier.
1:4f996a4:             //
1:4f996a4:             // Additional information about this routine is available in the
1:4f996a4:             // bug notes for DERBY-125:
1:4f996a4:             // http://issues.apache.org/jira/browse/DERBY-125
1:f81f610:             
1:4f996a4:             // mark passOne to help with calculating the length of the final (first or
1:4f996a4:             // rightmost) continuation header.
1:4f996a4:             boolean passOne = true;
1:4f996a4:             do {
1:4f996a4:                 // calculate chunk of data to shift
1:4f996a4:                 int dataToShift = bytesRequiringContDssHeader % 32765;
1:4f996a4:                 if (dataToShift == 0)
1:4f996a4:                     dataToShift = 32765;
1:4f996a4:                 int startOfCopyData = dataByte - dataToShift + 1;
1:a1f0068:                 // perform the shift directly on the backing array
1:a1f0068:                 final byte[] bytes = buffer.array();
1:4f996a4:                 System.arraycopy(bytes,startOfCopyData, bytes, 
1:4f996a4:                                  startOfCopyData + shiftSize, dataToShift);
1:4f996a4:                 dataByte -= dataToShift;
1:4f996a4: 
1:1adb9d7: 
1:4f996a4:                 // calculate the value the value of the 2 byte continuation dss
1:4f996a4:                 // header which includes the length of itself.  On the first pass,
1:4f996a4:                 // if the length is 32767
1:4f996a4:                 // we do not want to set the continuation dss header flag.
1:4f996a4:                 int twoByteContDssHeader = dataToShift + 2;
1:4f996a4:                 if (passOne)
1:4f996a4:                     passOne = false;
1:4f996a4:                 else
1:4f996a4:                 {
1:4f996a4:                     if (twoByteContDssHeader == DssConstants.MAX_DSS_LENGTH)
1:4f996a4:                     twoByteContDssHeader = (twoByteContDssHeader |
1:4f996a4:                         DssConstants.CONTINUATION_BIT);
1:1adb9d7: 
1:f81f610:                 }
1:eac0369: 
1:4f996a4:                 // insert the header's length bytes
1:a1f0068:                 buffer.putShort(dataByte + shiftSize - 1,
1:a1f0068:                                 (short) twoByteContDssHeader);
1:eac0369: 
1:4f996a4:                 // adjust the bytesRequiringContDssHeader and the amount to shift for
1:4f996a4:                 // data in upstream headers.
1:4f996a4:                 bytesRequiringContDssHeader -= dataToShift;
1:4f996a4:                 shiftSize -= 2;
1:eac0369: 
1:4f996a4:                 // shift and insert another header for more data.
1:4f996a4:             }
1:4f996a4:             while (bytesRequiringContDssHeader > 0);
1:eac0369: 
1:4f996a4:             // set the continuation dss header flag on for the first header
1:4f996a4:             totalSize = (DssConstants.MAX_DSS_LENGTH |
1:4f996a4:                     DssConstants.CONTINUATION_BIT);
1:1adb9d7: 
1:eac0369: 
1:4f996a4:         }
1:eac0369: 
1:4f996a4:         // insert the length bytes in the 6 byte dss header.
1:298ff5e:         buffer.putShort(dssLengthLocation, (short) totalSize);
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     protected void writeExtendedLength(long size)
1:4f996a4:     {
1:4f996a4:         int numbytes = calculateExtendedLengthByteCount(size);
1:4f996a4:         if (size > 0)
1:4f996a4:             writeInt(0x8000 | numbytes);
1:4f996a4:         else
1:4f996a4:             writeInt(numbytes);
1:4f996a4:     }
1:eac0369: 
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * Calculate extended length byte count which follows the DSS header
1:4f996a4:      * for extended DDM.
1:4f996a4:      *
1:4f996a4:      * @param ddmSize - size of DDM command
1:4f996a4:      * @return minimum number of extended length bytes needed. 0 indicates no
1:db9a013:      *  extended length needed.
1:4f996a4:      */
1:4f996a4:     private int calculateExtendedLengthByteCount (long ddmSize)
1:4f996a4:     {
1:4f996a4:         if (ddmSize <= 0x7fff)
1:4f996a4:             return 0;
1:4f996a4:         // JCC does not support 2 at this time, so we always send
1:4f996a4:         // at least 4
1:db9a013:         //      else if (ddmSize <= 0xffff)
1:db9a013:         //  return 2;
1:4f996a4:         else if (ddmSize <= 0xffffffffL)
1:4f996a4:             return 4;
1:4f996a4:         else if (ddmSize <= 0xffffffffffffL)
1:4f996a4:             return 6;
1:4f996a4:         else if (ddmSize <= 0x7fffffffffffffffL)
1:4f996a4:             return 8;
1:4f996a4:         else
1:4f996a4:             // shouldn't happen
1:4f996a4:             // XXX - add sanity debug stuff here
1:4f996a4:             return 0;
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * Ensure that there is space in the buffer
1:4f996a4:      *
1:4f996a4:      * @param length space required
1:4f996a4:      */
1:4f996a4:     private void ensureLength (int length)
1:4f996a4:     {
1:298ff5e:         if (buffer.remaining() < length) {
1:4f996a4:             if (SanityManager.DEBUG)
1:4f996a4:             {
1:4f996a4:                 agent.trace("DANGER - Expensive expansion of  buffer");
1:4f996a4:             }
1:298ff5e:             int newLength =
1:4f996a4:                 Math.max(buffer.capacity() * 2, buffer.position() + length);
1:298ff5e:             // copy the old buffer into a new one
1:298ff5e:             buffer.flip();
1:298ff5e:             buffer = ByteBuffer.allocate(newLength).put(buffer);
1:4f996a4:         }
1:4f996a4:     }
1:eac0369: 
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * Write a Java <code>java.math.BigDecimal</code> to packed decimal bytes.
1:4f996a4:      *
1:4f996a4:      * @param b BigDecimal to write
1:4f996a4:      * @param precision Precision of decimal or numeric type
1:a1f0068:      * @param scale declared scale
1:4f996a4:      *
1:dbed020:      * @exception SQLException Thrown if # digits &gt; 31
1:4f996a4:      */
1:a1f0068:     void writeBigDecimal(BigDecimal b, int precision, int scale)
1:4f996a4:     throws SQLException
1:4f996a4:     {
1:a1f0068:         final int encodedLength = precision / 2 + 1;
1:a1f0068:         ensureLength(encodedLength);
1:a1f0068: 
1:a1f0068:         // The bytes are processed from right to left. Therefore, save starting
1:a1f0068:         // offset and use absolute positioning.
1:a1f0068:         final int offset = buffer.position();
1:a1f0068:         // Move current position to the end of the encoded decimal.
1:a1f0068:         buffer.position(offset + encodedLength);
1:a1f0068: 
1:4f996a4:         int declaredPrecision = precision;
1:4f996a4:         int declaredScale = scale;
1:eac0369: 
1:4f996a4:         // packed decimal may only be up to 31 digits.
1:4f996a4:         if (declaredPrecision > 31) // this is a bugcheck only !!!
1:4f996a4:         {
1:4f996a4:             clearDdm ();
1:4f996a4:             throw new java.sql.SQLException ("Packed decimal may only be up to 31 digits!");
1:4f996a4:         }
1:eac0369: 
1:4f996a4:         // get absolute unscaled value of the BigDecimal as a String.
1:4f996a4:         String unscaledStr = b.unscaledValue().abs().toString();
1:eac0369: 
1:4f996a4:         // get precision of the BigDecimal.
1:db9a013:         int bigPrecision = unscaledStr.length();
1:eac0369: 
1:4f996a4:         if (bigPrecision > 31)
1:4f996a4:         {
1:4f996a4:             clearDdm ();
1:db9a013:             throw new SQLException ("The numeric literal \"" +
1:eac0369:                              b.toString() +
1:eac0369:                              "\" is not valid because its value is out of range.",
1:eac0369:                              "42820",
1:eac0369:                              -405);
1:4f996a4:         }
1:4f996a4:         int bigScale = b.scale();
1:db9a013:         int bigWholeIntegerLength = bigPrecision - bigScale;
1:4f996a4:         if ( (bigWholeIntegerLength > 0) && (!unscaledStr.equals ("0")) ) {
1:eac0369:             // if whole integer part exists, check if overflow.
1:eac0369:             int declaredWholeIntegerLength = declaredPrecision - declaredScale;
1:eac0369:             if (bigWholeIntegerLength > declaredWholeIntegerLength)
1:4f996a4:             {
1:4f996a4:                 clearDdm ();
1:eac0369:                 throw new SQLException ("Overflow occurred during numeric data type conversion of \"" +
1:eac0369:                                        b.toString() +
1:eac0369:                                        "\".",
1:eac0369:                                        "22003",
1:eac0369:                                        -413);
1:4f996a4:             }
1:cdfb2d1:         }
1:eac0369: 
1:eac0369:         // convert the unscaled value to a packed decimal bytes.
1:eac0369: 
1:eac0369:         // get unicode '0' value.
1:eac0369:         int zeroBase = '0';
1:eac0369: 
1:eac0369:         // start index in target packed decimal.
1:eac0369:         int packedIndex = declaredPrecision-1;
1:eac0369: 
1:eac0369:         // start index in source big decimal.
1:eac0369:         int bigIndex;
1:298ff5e: 
1:a1f0068:         byte signByte = (byte) ((b.signum() >= 0) ? 12 : 13);
1:eac0369: 
1:eac0369:         if (bigScale >= declaredScale) {
1:eac0369:           // If target scale is less than source scale,
1:eac0369:           // discard excessive fraction.
1:eac0369: 
1:eac0369:           // set start index in source big decimal to ignore excessive fraction.
1:eac0369:           bigIndex = bigPrecision-1-(bigScale-declaredScale);
1:eac0369: 
1:a1f0068:           if (bigIndex >= 0) {
1:a1f0068:               // process the last nybble together with the sign nybble.
1:a1f0068:               signByte |= (unscaledStr.charAt(bigIndex) - zeroBase) << 4;
1:cdfb2d1:           }
1:a1f0068:           buffer.put(offset + (packedIndex+1)/2, signByte);
2:eac0369:           packedIndex-=2;
1:eac0369:           bigIndex-=2;
1:a54b657:         }
1:a54b657:         else {
1:eac0369:           // If target scale is greater than source scale,
1:eac0369:           // pad the fraction with zero.
1:d79abcf: 
1:eac0369:           // set start index in source big decimal to pad fraction with zero.
1:eac0369:           bigIndex = declaredScale-bigScale-1;
1:d79abcf: 
1:eac0369:           // process the sign nybble.
1:a1f0068:           buffer.put(offset + (packedIndex+1)/2, signByte);
1:eac0369: 
1:eac0369:           for (packedIndex-=2, bigIndex-=2; bigIndex>=0; packedIndex-=2, bigIndex-=2)
1:a1f0068:               buffer.put(offset + (packedIndex+1)/2, (byte) 0);
1:eac0369: 
1:eac0369:           if (bigIndex == -1) {
1:a1f0068:             byte bt = (byte)
1:a1f0068:                 ((unscaledStr.charAt(bigPrecision - 1) - zeroBase) << 4);
1:a1f0068:             buffer.put(offset + (packedIndex+1)/2, bt);
1:eac0369:             packedIndex-=2;
1:eac0369:             bigIndex = bigPrecision-3;
1:d79abcf:           }
2:d79abcf:           else {
1:eac0369:             bigIndex = bigPrecision-2;
1:d79abcf:           }
1:d79abcf:         }
1:eac0369: 
1:eac0369:         // process the rest.
1:eac0369:         for (; bigIndex>=0; packedIndex-=2, bigIndex-=2) {
1:a1f0068:             byte bt = (byte)
1:a1f0068:                 (((unscaledStr.charAt(bigIndex)-zeroBase) << 4) | // high nybble
1:a1f0068:                   (unscaledStr.charAt(bigIndex+1)-zeroBase));     // low nybble
1:a1f0068:             buffer.put(offset + (packedIndex+1)/2, bt);
1:d79abcf:         }
1:eac0369: 
1:eac0369:         // process the first nybble when there is one left.
1:eac0369:         if (bigIndex == -1) {
1:a1f0068:             buffer.put(offset + (packedIndex+1)/2,
1:a1f0068:                        (byte) (unscaledStr.charAt(0) - zeroBase));
1:eac0369: 
1:a1f0068:             packedIndex-=2;
1:d79abcf:         }
1:eac0369: 
1:eac0369:         // pad zero in front of the big decimal if necessary.
1:eac0369:         for (; packedIndex>=-1; packedIndex-=2)
1:a1f0068:             buffer.put(offset + (packedIndex+1)/2, (byte) 0);
1:4f996a4:     }
1:eac0369: 
1:eac0369: 
1:f3ab04f:     private void sendBytes (java.io.OutputStream socketOutputStream) 
1:4f996a4:     throws java.io.IOException{
1:4f996a4:     
1:4f996a4:     sendBytes(socketOutputStream,
1:4f996a4:           true);
1:4f996a4:     
1:d79abcf:     }
1:eac0369:     
1:eac0369: 
1:977561c:   private void sendBytes (java.io.OutputStream socketOutputStream,
1:4f996a4:               boolean flashStream ) 
1:d79abcf:       throws java.io.IOException
1:a54b657:   {
1:4f996a4:     resetChainState();
1:a1f0068:     final byte[] bytes = buffer.array();
1:a1f0068:     final int length = buffer.position();
1:d79abcf:     try {
1:a1f0068:       socketOutputStream.write(bytes, 0, length);
1:357ad1c:       totalByteCount += length;
1:977561c:       if(flashStream)
1:4f996a4:       socketOutputStream.flush();
1:d79abcf:     }
2:eac0369:     finally {
1:4f996a4:         if ((dssTrace != null) && dssTrace.isComBufferTraceOn()) {
1:4f996a4:             dssTrace.writeComBufferData (bytes,
1:4f996a4:                                            0,
1:4f996a4:                                            length,
1:4f996a4:                                            DssTrace.TYPE_TRACE_SEND,
1:4f996a4:                                            "Reply",
1:4f996a4:                                            "flush",
1:4f996a4:                                            5);
3:d79abcf:       }
1:eac0369:       clearBuffer();
1:d79abcf:     }
1:d79abcf:   }
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * Reset any chaining state that needs to be reset
1:4f996a4:      * at time of the send
1:4f996a4:      */
1:4f996a4:     protected void resetChainState()
1:4f996a4:     {
1:4f996a4:         prevHdrLocation = -1;
1:4f996a4:     }
1:d79abcf: 
1:4f996a4:     /**
1:4f996a4:      * Looks at chaining info for previous DSS written, and use
1:4f996a4:      * that to figure out what the correlation id for the current
1:4f996a4:      * DSS should be.  Return that correlation id.
1:4f996a4:      */
1:4f996a4:     private int getCorrelationID() {
1:d79abcf: 
1:4f996a4:         int cId;
1:4f996a4:         if (previousCorrId != DssConstants.CORRELATION_ID_UNKNOWN) {
1:4f996a4:             if (previousChainByte == DssConstants.DSSCHAIN_SAME_ID)
1:4f996a4:             // then we have to use the last correlation id we sent.
1:4f996a4:                 cId = previousCorrId;
1:4f996a4:             else
1:4f996a4:             // get correlation id as normal.
1:4f996a4:                 cId = nextCorrelationID++;
1:4f996a4:         }
1:4f996a4:         else {
1:4f996a4:         // must be the case that this is the first DSS we're
1:4f996a4:         // writing for this connection (because we haven't
1:4f996a4:         // called "endDss" yet).  So, get the corr id as
1:4f996a4:         // normal.
1:4f996a4:             cId = nextCorrelationID++;
1:4f996a4:         }
1:d79abcf: 
1:4f996a4:         return cId;
1:d79abcf: 
1:4f996a4:     }
1:d79abcf: 
1:4f996a4:     /**
1:4f996a4:      * Finalize the current DSS chain and send it if
1:4f996a4:      * needed.
1:4f996a4:      *
1:4f996a4:      * Updates the chaining state of the most recently-written-
1:4f996a4:      * to-buffer DSS to correspond to the most recently-read-
1:4f996a4:      * from-client request.  If that chaining state indicates
1:4f996a4:      * we've reached the end of a chain, then we go ahead
1:4f996a4:      * and send the buffer across the wire.
1:4f996a4:      * @param socketOutputStream Output stream to which we're flushing.
1:4f996a4:      */
1:4f996a4:     protected void finalizeChain(byte currChainByte,
1:4f996a4:         OutputStream socketOutputStream) throws DRDAProtocolException
1:4f996a4:     {
1:d79abcf: 
1:4f996a4:         // Go back to previous DSS and override the default
1:4f996a4:         // chain state (WITH_SAME_ID) with whatever the last
1:4f996a4:         // request dictates.
1:d79abcf: 
1:4f996a4:         if (prevHdrLocation != -1) {
1:4f996a4:         // Note: == -1 => the previous DSS was already sent; this
1:4f996a4:         // should only happen in cases where the buffer filled up
1:4f996a4:         // and we had to send it (which means we were probably
1:4f996a4:         // writing EXTDTA).  In such cases, proper chaining
1:4f996a4:         // should already have been handled @ time of send.
1:a1f0068:             overrideChainByte(prevHdrLocation + 3, currChainByte);
1:4f996a4:         }
1:d79abcf: 
1:4f996a4:         // previousChainByte needs to match what we just did.
1:4f996a4:         previousChainByte = currChainByte;
1:d79abcf: 
1:4f996a4:         if (currChainByte != DssConstants.DSS_NOCHAIN)
1:4f996a4:         // then we're still inside a chain, so don't send.
1:4f996a4:             return;
1:d79abcf: 
1:4f996a4:         // Else, we just ended the chain, so send it across.
1:d79abcf: 
1:4f996a4:         if ((SanityManager.DEBUG) && (agent != null))
1:4f996a4:             agent.trace("Sending data");
1:d79abcf: 
1:4f996a4:         resetChainState();
1:4f996a4:         if (doesRequestContainData()) {
1:4f996a4:             try {
1:4f996a4:                 flush(socketOutputStream);
1:4f996a4:             } catch (java.io.IOException e) {
1:4f996a4:                 agent.markCommunicationsFailure(
1:4f996a4:                     "DDMWriter.finalizeChain()",
1:4f996a4:                     "OutputStream.flush()",
1:4f996a4:                     e.getMessage(),"*");
1:4f996a4:             }
1:4f996a4:         }
1:d79abcf: 
1:4f996a4:     }
1:d79abcf: 
1:4f996a4:     /**
1:4f996a4:      * Takes note of the location of the most recently completed
1:4f996a4:      * DSS in the buffer, and then returns the current offset.
1:4f996a4:      * This method is used in conjunction with "clearDSSesBackToMark"
1:4f996a4:      * to allow for DRDAConnThread to "back-out" DSSes in the
1:4f996a4:      * event of errors.
1:4f996a4:      */
1:4f996a4:     protected int markDSSClearPoint()
1:4f996a4:     {
1:a54b657: 
1:4f996a4:         lastDSSBeforeMark = prevHdrLocation;
1:298ff5e:         return buffer.position();
1:a54b657: 
1:4f996a4:     }
1:a54b657: 
1:4f996a4:     /**
1:4f996a4:      * Does a logical "clear" of everything written to the buffer after
1:4f996a4:      * the received mark.  It's assumed that this method will be used
1:4f996a4:      * in error cases when we've started writing one or more DSSes,
1:4f996a4:      * but then hit an error and need to back out.  After backing out,
1:4f996a4:      * we'll always need to write _something_ back to the client to
1:4f996a4:      * indicate an error (typically, we just write an SQLCARD) but what
1:4f996a4:      * exactly gets written is handled in DRDAConnThread.  Here, we
1:4f996a4:      * just do the necessary prep so that whatever comes next will
1:4f996a4:      * succeed.
1:4f996a4:      */
1:4f996a4:     protected void clearDSSesBackToMark(int mark)
1:4f996a4:     {
1:a54b657: 
1:4f996a4:         // Logical clear.
1:298ff5e:         buffer.position(mark);
1:a54b657: 
1:4f996a4:         // Because we've just cleared out the most recently-
1:4f996a4:         // written DSSes, we have to make sure the next thing
1:4f996a4:         // we write will have the correct correlation id.  We
1:4f996a4:         // do this by setting the value of 'nextCorrelationID'
1:4f996a4:         // based on the chaining byte from the last remaining
1:4f996a4:         // DSS (where "remaining" means that it still exists
1:4f996a4:         // in the buffer after the clear).
1:4f996a4:         if (lastDSSBeforeMark == -1)
1:4f996a4:         // we cleared out the entire buffer; reset corr id.
1:4f996a4:             nextCorrelationID = 1;
1:4f996a4:         else {
1:4f996a4:         // last remaining DSS had chaining, so we set "nextCorrelationID"
1:4f996a4:         // to be 1 greater than whatever the last remaining DSS had as
1:4f996a4:         // its correlation id.
1:db9a013:             nextCorrelationID =
1:a1f0068:                 (buffer.getShort(lastDSSBeforeMark + 4) & 0xFFFF) + 1;
1:4f996a4:         }
1:4f996a4: 
1:4f996a4:     }
1:a54b657: 
1:a54b657:     
1:977561c:     private static int peekStream(InputStream in) throws IOException{
1:4f996a4:         
1:4f996a4:     in.mark(1);
1:eac0369: 
1:4f996a4:     try{
1:4f996a4:         return in.read();
1:4f996a4:         
1:4f996a4:     }finally{
1:4f996a4:         in.reset();
1:4f996a4:         
1:4f996a4:     }
1:a54b657:     }
1:eac0369: 
1:eac0369:     
1:f3ab04f:     private static int getLayerBStreamingBufferSize(){
1:4f996a4:     return PropertyUtil.getSystemInt( Property.DRDA_PROP_STREAMOUTBUFFERSIZE , 0 );
1:a54b657:     }
1:eac0369:     
1:eac0369:     
1:f3ab04f:     private static OutputStream placeLayerBStreamingBuffer(OutputStream original){
1:4f996a4:     
1:4f996a4:     int size = getLayerBStreamingBufferSize();
1:4f996a4:     
1:4f996a4:     if(size < 1)
1:4f996a4:         return original;
1:4f996a4:     else
1:4f996a4:         return new BufferedOutputStream( original, size );
1:eac0369: 
1:d79abcf:     }
1:eac0369:     
1:d79abcf: }
1:eac0369: 
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1:      * @exception SQLException Thrown if # digits &gt; 31
commit:a519191
/////////////////////////////////////////////////////////////////////////
1: 		if (SanityManager.DEBUG)
1: 		{
1:             if ( val == null )
1:             {
1:                 SanityManager.THROWASSERT( "UDT is null" );
1:             }
commit:506f4c8
/////////////////////////////////////////////////////////////////////////
1: import java.io.ObjectOutputStream;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.reference.DRDAConstants;
1: import org.apache.derby.iapi.services.io.DynamicByteArrayOutputStream;
/////////////////////////////////////////////////////////////////////////
1: 	 * Write a value of a user defined type.
1: 	 *
1: 	 * @param val object to be written
1: 	 *
1: 	 * @exception DRDAProtocolException
1: 	 */
1: 	protected void writeUDT( Object val, int index ) throws DRDAProtocolException
1: 	{
1:         // should not be called if val is null
0:         if ( val == null )
1:         {
0:             SanityManager.THROWASSERT( "UDT is null" );
1:         }
1: 
1:         byte[] buffer = null;
1:         int length = 0;
1: 
1:         try {
1:             DynamicByteArrayOutputStream dbaos = new DynamicByteArrayOutputStream();
1:             ObjectOutputStream oos = new ObjectOutputStream( dbaos );
1: 
1:             oos.writeObject( val );
1: 
1:             buffer = dbaos.getByteArray();
1:             length = dbaos.getUsed();
1:             
1:         } catch(IOException e)
1:         {
1:             agent.markCommunicationsFailure
1:                 ( e,"DDMWriter.writeUDT()", "", e.getMessage(), "" );
1:         }
1: 
1:         if ( length > DRDAConstants.MAX_DRDA_UDT_SIZE )
1:         {
1:             agent.markCommunicationsFailure
1:                 ( "DDMWriter.writeUDT()", "User defined type is longer than " + DRDAConstants.MAX_DRDA_UDT_SIZE + " bytes.", "", "" );
1:         }
1:         else
1:         {
1:             writeShort( length );
1:             writeBytes( buffer, 0, length );
1:         }
1: 	}
1: 
1: 	/**
commit:f81f610
/////////////////////////////////////////////////////////////////////////
1:         
0: 	private static final byte MULTI_BYTE_MASK = (byte) 0xC0;
0: 	private static final byte CONTINUATION_BYTE = (byte) 0x80;
/////////////////////////////////////////////////////////////////////////
0: 			if (writeLen != origLen) {
0: 				//find the first byte of the multibyte char in case
0: 				//the last byte is part of a multibyte char
0: 				while (isContinuationChar (byteval [writeLen])) {
1: 				//
0: 				// Now byteval[ writeLen ] is either a standalone 1-byte char
0: 				// or the first byte of a multi-byte character. That means that
0: 				// byteval[ writeLen -1 ] is the last (perhaps only) byte of the
0: 				// previous character.
1: 				//
1: 			}
1:                         
/////////////////////////////////////////////////////////////////////////
0: 	private boolean isContinuationChar( byte b ) {    
0: 		return ( (b & MULTI_BYTE_MASK) == CONTINUATION_BYTE );
1: 	}
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:4a2a038
/////////////////////////////////////////////////////////////////////////
1:     final static int MAX_VARCHAR_BYTE_LENGTH = 0xFFFF;
commit:db9a013
/////////////////////////////////////////////////////////////////////////
1:     //  This Object tracks the location of the current
1:     //  Dss header length bytes.    This is done so
1:     //  the length bytes can be automatically
1:     //  updated as information is added to this stream.
1:     private int correlationID;
/////////////////////////////////////////////////////////////////////////
1:      *  1. One or more continuation DSSes will immediately
1:      *      follow the current (continued) DSS.
1:      *  2. All continuation DSSes will have a 2-byte
1:      *      continuation header, followed by data; in
1:      *      other words, chaining state, correlation
1:      *      id, dss format info, and code point will
1:      *      NOT be included.  All of that info is
1:      *      present ONLY in the FIRST DSS in the
1:      *      list of continued DSSes.
1:      *  NOTE: A DSS can be a "continuation" DSS _and_
1:      *  a "continued" DSS at the same time.  However,
1:      *  the FIRST DSS to be continued canNOT be
1:      *  a continuation DSS.
/////////////////////////////////////////////////////////////////////////
1:         endDdm();   // updates last DDM object
/////////////////////////////////////////////////////////////////////////
1:         // determine if any extended length bytes are needed.   the value returned
/////////////////////////////////////////////////////////////////////////
1:             // to hold the extended length. the 2 byte length field also has the first
/////////////////////////////////////////////////////////////////////////
1:      * @param   value   byte to be written
/////////////////////////////////////////////////////////////////////////
1:      * @param   value   value to be written
/////////////////////////////////////////////////////////////////////////
1:      * @param   value   value to be written
/////////////////////////////////////////////////////////////////////////
1:      * @param   buf byte array to be written
1:      * @param   length  - length to write
/////////////////////////////////////////////////////////////////////////
1:      * @param   buf byte array to be written
1:      * @param   start  - starting position
1:      * @param   length  - length to write
/////////////////////////////////////////////////////////////////////////
1:      * @param   buf byte array to be written
/////////////////////////////////////////////////////////////////////////
1:      * @param   codePoint - code point to write
1:      * @param   value  - value to write after code point
/////////////////////////////////////////////////////////////////////////
1:      * @param   codePoint - code point to write
1:      * @param   value  - value to write after code point
/////////////////////////////////////////////////////////////////////////
1:      * @param   codePoint - code point to write
1:      * @param   value  - value to write after code point
/////////////////////////////////////////////////////////////////////////
1:         beginDss(dssType, false);   // false => don't ensure length.
/////////////////////////////////////////////////////////////////////////
1:                     markDssAsContinued(true);   // true => for lobs
/////////////////////////////////////////////////////////////////////////
1:      * @param   codePoint - code point to write
1:      * @param   dataLength - length of object data
/////////////////////////////////////////////////////////////////////////
1:      * @param   codePoint - code point to write
1:      * @param   string - string to be written
/////////////////////////////////////////////////////////////////////////
1:      * @param   codePoint - code point to write
1:      * @param   string - string to be written
1:      * @param   paddedLength - length to pad string to
/////////////////////////////////////////////////////////////////////////
1:      * @param   codePoint - code point to write
1:      * @param   buf - byte array to be written
1:      * @param   paddedLength - length to pad string to
1:      * @param   padByte - byte to be used for padding
/////////////////////////////////////////////////////////////////////////
1:      * @param   buf - byte array to be written
1:      * @param   paddedLength - length to pad string to
1:      * @param   padByte - byte to be used for padding
/////////////////////////////////////////////////////////////////////////
1:      * @param   codePoint - code point to write
1:      * @param   buf - byte array to be written
/////////////////////////////////////////////////////////////////////////
1:      * @param   v   value to be written
/////////////////////////////////////////////////////////////////////////
1:      * @param   v   value to be written
/////////////////////////////////////////////////////////////////////////
1:      * @param   v   value to be written
/////////////////////////////////////////////////////////////////////////
1:      * @param   v   value to be written
/////////////////////////////////////////////////////////////////////////
1:      * @param   v   value to be written
/////////////////////////////////////////////////////////////////////////
1:      * @param   v   value to be written
/////////////////////////////////////////////////////////////////////////
1:      * @param   val value to be written
1:      * @param   length      length to be written
/////////////////////////////////////////////////////////////////////////
1:      *  2 bytes - length
1:      *  1 byte  - 'D0'  - indicates DDM data
1:      *  1 byte  - DSS format
1:      *      |---|---------|----------|
1:      *      | 0 |   flags | type     |
1:      *      |---|---------|----------|
1:      *      | 0 | 1 2   3 | 4 5 6 7  |
1:      *      |---|---------|----------|
1:      *      bit 0 - '0'
1:      *      bit 1 - '0' - unchained, '1' - chained
1:      *      bit 2 - '0' - do not continue on error, '1' - continue on error
1:      *      bit 3 - '0' - next DSS has different correlator, '1' - next DSS has
1:      *                      same correlator
1:      *      type - 1 - Request DSS
1:      *           - 2 - Reply DSS
1:      *           - 3 - Object DSS
1:      *           - 4 - Communications DSS
1:      *           - 5 - Request DSS where no reply is expected
/////////////////////////////////////////////////////////////////////////
1:      * offset into the buffer which marks the end of the data.  In the event
/////////////////////////////////////////////////////////////////////////
1:         // the 6 byte dss header located at the beginning of the dss.   It does not
/////////////////////////////////////////////////////////////////////////
1:             // right now the code will shift to the right.  In the future we may want
1:             // will be calculated and adjusted as needed.   ensure there is enough room
/////////////////////////////////////////////////////////////////////////
1:      *  extended length needed.
/////////////////////////////////////////////////////////////////////////
1:         //      else if (ddmSize <= 0xffff)
1:         //  return 2;
/////////////////////////////////////////////////////////////////////////
1:         int bigPrecision = unscaledStr.length();
1:             throw new SQLException ("The numeric literal \"" +
1:         int bigWholeIntegerLength = bigPrecision - bigScale;
/////////////////////////////////////////////////////////////////////////
1:             nextCorrelationID =
commit:db4c995
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.services.io.DynamicByteArrayOutputStream;
commit:542c2b7
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:9b3e218
/////////////////////////////////////////////////////////////////////////
1:         // Find out how long strings the client supports, and possibly
1:         // truncate the string before sending it.
1: 
1:         int maxByteLength = MAX_VARCHAR_BYTE_LENGTH;
1:         boolean warnOnTruncation = true;
1: 
1:         AppRequester appRequester = agent.getSession().appRequester;
1:         if (appRequester != null && !appRequester.supportsLongerLDStrings()) {
1:             // The client suffers from DERBY-5236, and it doesn't support
1:             // receiving as long strings as newer clients do. It also doesn't
1:             // know exactly what to do with a DataTruncation warning, so skip
1:             // sending it to old clients.
1:             maxByteLength = FdocaConstants.LONGVARCHAR_MAX_LEN;
1:             warnOnTruncation = false;
1:         }
1: 
1:         if (byteLength > maxByteLength) {
1:             byteLength = maxByteLength;
/////////////////////////////////////////////////////////////////////////
1:             // If invoked as part of statement execution, and the client
1:             // supports receiving DataTruncation warnings, add a warning about
1:             if (warnOnTruncation && stmt != null) {
commit:b850119
/////////////////////////////////////////////////////////////////////////
1: import java.sql.DataTruncation;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Get the current position in the output buffer.
1:      * @return current position
1:      */
1:     protected int getBufferPosition() {
1:         return buffer.position();
1:     }
1: 
1:     /**
1:      * Change the current position in the output buffer.
1:      * @param position new position
1:      */
1:     protected void setBufferPosition(int position) {
1:         buffer.position(position);
1:     }
1: 
1:     /**
1:      * Get a copy of a subsequence of the output buffer, starting at the
1:      * specified position and ending at the current buffer position.
1:      *
1:      * @param startPos the position of the first byte to copy
1:      * @return all bytes from {@code startPos} up to the current position
1:      */
1:     protected byte[] getBufferContents(int startPos) {
1:         byte[] bytes = new byte[buffer.position() - startPos];
1:         System.arraycopy(buffer.array(), startPos, bytes, 0, bytes.length);
1:         return bytes;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1: 		writeLDString(s, 0, null, false);
/////////////////////////////////////////////////////////////////////////
1:      * @param stmt           the executing statement (null if not invoked as
1:      *                       part of statement execution)
1:      * @param isParameter    true if the value written is for an output
1:      *                       parameter in a procedure call
1: 	protected void writeLDString(String s, int index, DRDAStatement stmt,
1:                                  boolean isParameter)
1:             throws DRDAProtocolException
/////////////////////////////////////////////////////////////////////////
1: 
1:             // Check how many chars that were truncated.
1:             int truncatedChars = 0;
1:             for (int i = stringPos + byteLength; i < buffer.position(); i++) {
1:                 if (!isContinuationByte(buffer.get(i))) {
1:                     truncatedChars++;
1:                 }
1:             }
1: 
1: 
0:             // If invoked as part of statement execution, add a warning about
1:             // the string being truncated.
0:             if (stmt != null) {
1:                 DataTruncation dt = new DataTruncation(
1:                         index,
1:                         isParameter,
1:                         true,  // this is a warning for a read operation
1:                         s.length(),                   // dataSize
1:                         s.length() - truncatedChars); // transferSize
1:                 stmt.addTruncationWarning(dt);
1:             }
commit:c6e4294
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * The maximum length in bytes for strings sent by {@code writeLDString()},
1:      * which is the maximum unsigned integer value that fits in two bytes.
1:      */
0:     private final static int MAX_VARCHAR_BYTE_LENGTH = 0xFFFF;
1: 
/////////////////////////////////////////////////////////////////////////
1:         // Reserve two bytes for the length field and move the position to
1:         // where the string should be inserted.
1:         ensureLength(2);
1:         final int stringPos = lengthPos + 2;
1:         buffer.position(stringPos);
1:         // Write the string.
1:         writeString(s);
1:         int byteLength = buffer.position() - stringPos;
1:         // If the byte representation of the string is too long, it needs to
1:         // be truncated.
0:         if (byteLength > MAX_VARCHAR_BYTE_LENGTH) {
1:             // Truncate the string down to the maximum byte length.
0:             byteLength = MAX_VARCHAR_BYTE_LENGTH;
1:             // Align with character boundaries so that we don't send over
1:             // half a character.
1:             while (isContinuationByte(buffer.get(stringPos + byteLength))) {
1:                 byteLength--;
1:             }
1:             // Set the buffer position right after the truncated string.
1:             buffer.position(stringPos + byteLength);
1:         }
1:         // Go back and write the length in bytes.
1:         buffer.putShort(lengthPos, (short) byteLength);
1:     /**
1:      * Check if a byte value represents a continuation byte in a UTF-8 byte
1:      * sequence. Continuation bytes in UTF-8 always match the bit pattern
1:      * {@code 10xxxxxx}.
1:      *
1:      * @param b the byte to check
1:      * @return {@code true} if {@code b} is a continuation byte, or
1:      * {@code false} if it is the first byte in a UTF-8 sequence
1:      */
1:     private static boolean isContinuationByte(byte b) {
1:         // Check the values of the two most significant bits. If they are
1:         // 10xxxxxx, it's a continuation byte.
1:         return (b & 0xC0) == 0x80;
1:     }
1: 
commit:a6bc42e
/////////////////////////////////////////////////////////////////////////
1: 		encoder.reset();
1: 		if (res == CoderResult.UNDERFLOW) {
1: 			res = encoder.flush(buffer);
1: 		}
/////////////////////////////////////////////////////////////////////////
0: 		encoder.reset();
0: 		if (res == CoderResult.UNDERFLOW) {
0: 			res = encoder.flush(buffer);
1: 		}
commit:a0adefe
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	// Location of the start of the header
/////////////////////////////////////////////////////////////////////////
1: 	// location within the buffer of the start of the header
/////////////////////////////////////////////////////////////////////////
1: 		this.buffer = ByteBuffer.allocate(DEFAULT_BUFFER_SIZE);
/////////////////////////////////////////////////////////////////////////
1: 		int length = buffer.position() - lengthLocation;
/////////////////////////////////////////////////////////////////////////
1: 			// the extended length should be written right after the length and
1: 			// the codepoint (2+2 bytes)
1: 			final int extendedLengthLocation = lengthLocation + 4;
1: 
1: 			buffer.position(extendedLengthLocation + extendedLengthByteCount);
1: 			buffer.put(buffer.array(), extendedLengthLocation, extendedLength);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 			// read as many bytes as possible directly into the backing array
1: 			final int bytesRead =
1: 				in.read(buffer.array(), offset,
1: 						Math.min(spareDssLength, buffer.remaining()));
1: 
1: 			// update the buffer position
1: 
/////////////////////////////////////////////////////////////////////////
commit:a1f0068
/////////////////////////////////////////////////////////////////////////
1: import java.math.BigDecimal;
/////////////////////////////////////////////////////////////////////////
1: 			byte b = (byte) (buffer.get(dssLengthLocation) | 0x80);
1: 			buffer.put(dssLengthLocation, b);
/////////////////////////////////////////////////////////////////////////
1: 		overrideChainByte(dssLengthLocation + 3, chainByte);
1:     /**
1:      * Override the default chaining byte with the chaining byte that is passed
1:      * in.
1:      *
1:      * @param pos the position on which the chaining byte is located
1:      * @param chainByte the chaining byte that overrides the default
1:      */
1:     private void overrideChainByte(int pos, byte chainByte) {
1:         byte b = buffer.get(pos);
1:         b &= 0x0F;              // Zero out default
1:         b |= chainByte;
1:         buffer.put(pos, b);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1: 		buffer.position(start);
1: 		buffer.get(temp);
/////////////////////////////////////////////////////////////////////////
1: 			// write the extended length (a variable number of bytes in
1: 			// big-endian order)
1: 			for (int pos = extendedLengthLocation + extendedLengthByteCount - 1;
1: 				 pos >= extendedLengthLocation; pos--) {
1: 				buffer.put(pos, (byte) extendedLength);
1: 				extendedLength >>= 8;
/////////////////////////////////////////////////////////////////////////
1: 		buffer.putShort(lengthLocation, (short) length);
/////////////////////////////////////////////////////////////////////////
1: 		buffer.putShort(dssLengthLocation, (short) 0xFFFF);
/////////////////////////////////////////////////////////////////////////
1: 		buffer.put(dssLengthLocation + 3, (byte) dssType);
/////////////////////////////////////////////////////////////////////////
0: 		ccsidManager.convertFromUCS2(string, buffer);
/////////////////////////////////////////////////////////////////////////
0: 		ccsidManager.convertFromUCS2(string, buffer);
1: 		padBytes(ccsidManager.space, fillLength);
/////////////////////////////////////////////////////////////////////////
0: 		ccsidManager.convertFromUCS2(string, buffer);
1: 		padBytes(ccsidManager.space, fillLength);
/////////////////////////////////////////////////////////////////////////
0: 		padBytes(ccsidManager.space, fillLength);
/////////////////////////////////////////////////////////////////////////
1: 		padBytes(padByte, paddedLength - buf.length);
/////////////////////////////////////////////////////////////////////////
1: 		padBytes(padByte, paddedLength - buf.length);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		Arrays.fill(buffer.array(), offset, end, val);
/////////////////////////////////////////////////////////////////////////
1: 		final byte[] bytes = buffer.array();
/////////////////////////////////////////////////////////////////////////
1: 
1: 			// We're going to access the buffer with absolute positions, so
1: 			// just move the current position pointer right away to where it's
1: 			// supposed to be after we have finished the shifting.
/////////////////////////////////////////////////////////////////////////
1: 				// perform the shift directly on the backing array
1: 				final byte[] bytes = buffer.array();
/////////////////////////////////////////////////////////////////////////
1: 				buffer.putShort(dataByte + shiftSize - 1,
1: 								(short) twoByteContDssHeader);
/////////////////////////////////////////////////////////////////////////
1: 	 * @param scale declared scale
1: 	void writeBigDecimal(BigDecimal b, int precision, int scale)
1:         final int encodedLength = precision / 2 + 1;
1:         ensureLength(encodedLength);
1: 
1:         // The bytes are processed from right to left. Therefore, save starting
1:         // offset and use absolute positioning.
1:         final int offset = buffer.position();
1:         // Move current position to the end of the encoded decimal.
1:         buffer.position(offset + encodedLength);
1: 
/////////////////////////////////////////////////////////////////////////
1:         byte signByte = (byte) ((b.signum() >= 0) ? 12 : 13);
/////////////////////////////////////////////////////////////////////////
1:           if (bigIndex >= 0) {
1:               // process the last nybble together with the sign nybble.
1:               signByte |= (unscaledStr.charAt(bigIndex) - zeroBase) << 4;
1:           buffer.put(offset + (packedIndex+1)/2, signByte);
/////////////////////////////////////////////////////////////////////////
1:           buffer.put(offset + (packedIndex+1)/2, signByte);
1:               buffer.put(offset + (packedIndex+1)/2, (byte) 0);
1:             byte bt = (byte)
1:                 ((unscaledStr.charAt(bigPrecision - 1) - zeroBase) << 4);
1:             buffer.put(offset + (packedIndex+1)/2, bt);
/////////////////////////////////////////////////////////////////////////
1:             byte bt = (byte)
1:                 (((unscaledStr.charAt(bigIndex)-zeroBase) << 4) | // high nybble
1:                   (unscaledStr.charAt(bigIndex+1)-zeroBase));     // low nybble
1:             buffer.put(offset + (packedIndex+1)/2, bt);
1:             buffer.put(offset + (packedIndex+1)/2,
1:                        (byte) (unscaledStr.charAt(0) - zeroBase));
1:             packedIndex-=2;
1:             buffer.put(offset + (packedIndex+1)/2, (byte) 0);
/////////////////////////////////////////////////////////////////////////
1: 	final byte[] bytes = buffer.array();
1: 	final int length = buffer.position();
1:       socketOutputStream.write(bytes, 0, length);
/////////////////////////////////////////////////////////////////////////
1: 			                               length,
/////////////////////////////////////////////////////////////////////////
0: 		int len = (buffer != null) ? buffer.capacity() : 0;
0: 		s += indent + "byte buffer length  = " + len + "\n";
/////////////////////////////////////////////////////////////////////////
1: 			overrideChainByte(prevHdrLocation + 3, currChainByte);
/////////////////////////////////////////////////////////////////////////
0:  			nextCorrelationID =
1: 				(buffer.getShort(lastDSSBeforeMark + 4) & 0xFFFF) + 1;
commit:9f8e1eb
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import java.nio.CharBuffer;
1: import java.nio.charset.CharsetEncoder;
1: import java.nio.charset.CoderResult;
1: import java.nio.charset.CodingErrorAction;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	/** Encoder which encodes strings with the server's default encoding. */
1: 	private final CharsetEncoder encoder;
/////////////////////////////////////////////////////////////////////////
1: 		// create an encoder which inserts the charset's default replacement
1: 		// character for characters it can't encode
1: 		encoder = NetworkServerControlImpl.DEFAULT_CHARSET.newEncoder()
1: 			.onMalformedInput(CodingErrorAction.REPLACE)
1: 			.onUnmappableCharacter(CodingErrorAction.REPLACE);
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * Find the maximum number of bytes needed to represent the string in the
1: 	 * default encoding.
1: 	 *
1: 	 * @param s the string to encode
1: 	 * @return an upper limit for the number of bytes needed to encode the
1: 	 * string
1: 	 */
1: 	private int maxEncodedLength(String s) {
1: 		// maxBytesPerChar() returns a float, which can only hold 24 bits of an
1: 		// integer. Therefore, promote the float to a double so that all bits
1: 		// are preserved in the intermediate result.
1: 		return (int) (s.length() * (double) encoder.maxBytesPerChar());
1: 	}
/////////////////////////////////////////////////////////////////////////
1: 		// Position on which to write the length of the string (in bytes). The
1: 		// actual writing of the length is delayed until we have encoded the
1: 		// string.
1: 		final int lengthPos = buffer.position();
0: 		// Position on which to start writing the string (right after length,
0: 		// which is 2 bytes long).
0: 		final int stringPos = lengthPos + 2;
0: 		// don't send more than LONGVARCHAR_MAX_LEN bytes
0: 		final int maxStrLen =
0: 			Math.min(maxEncodedLength(s), FdocaConstants.LONGVARCHAR_MAX_LEN);
0: 		ensureLength(2 + maxStrLen);
0: 		// limit the writable area of the output buffer
0: 		buffer.position(stringPos);
0: 		buffer.limit(stringPos + maxStrLen);
0: 		// encode the string
1: 		CharBuffer input = CharBuffer.wrap(s);
1: 		CoderResult res = encoder.encode(input, buffer, true);
1: 		if (SanityManager.DEBUG) {
0: 			// UNDERFLOW is returned if the entire string was encoded, OVERFLOW
0: 			// is returned if the string was truncated at LONGVARCHAR_MAX_LEN
0: 			SanityManager.ASSERT(
0: 				res == CoderResult.UNDERFLOW || res == CoderResult.OVERFLOW,
0: 				"Unexpected coder result: " + res);
1: 
0: 		// write the length in bytes
0: 		buffer.putShort(lengthPos, (short) (maxStrLen - buffer.remaining()));
1: 
0: 		// remove the limit on the output buffer
0: 		buffer.limit(buffer.capacity());
/////////////////////////////////////////////////////////////////////////
1: 		ensureLength(maxEncodedLength(s));
0: 		CharBuffer input = CharBuffer.wrap(s);
0: 		CoderResult res = encoder.encode(input, buffer, true);
0: 		if (SanityManager.DEBUG) {
1: 			SanityManager.ASSERT(res == CoderResult.UNDERFLOW,
1: 								 "CharBuffer was not exhausted: res = " + res);
commit:298ff5e
/////////////////////////////////////////////////////////////////////////
1: import java.nio.ByteBuffer;
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * Output buffer.
0: 	 * @see #bytes
1: 	 */
1: 	/**
0: 	 * Wrapper around the output buffer (<code>bytes</code>) which enables the
0: 	 * use of utility methods for easy encoding of primitive values and
0: 	 * strings. Changes to the output buffer are visible in the wrapper, and
0: 	 * vice versa.
1: 	 */
1: 	private ByteBuffer buffer;
/////////////////////////////////////////////////////////////////////////
0: 		this.buffer = ByteBuffer.wrap(bytes);
/////////////////////////////////////////////////////////////////////////
0: 		this.buffer = ByteBuffer.wrap(bytes);
/////////////////////////////////////////////////////////////////////////
1: 		buffer.clear();
/////////////////////////////////////////////////////////////////////////
1: 		int length = buffer.position() - start;
/////////////////////////////////////////////////////////////////////////
1: 		final int offset = buffer.position();
1: 		// move past the length bytes before writing the code point
1: 		buffer.position(offset + 2);
1: 		buffer.putShort((short) codePoint);
/////////////////////////////////////////////////////////////////////////
1: 		buffer.position(markStack[top--]);
/////////////////////////////////////////////////////////////////////////
1: 		buffer.clear();
/////////////////////////////////////////////////////////////////////////
1: 		final int offset = buffer.position();
/////////////////////////////////////////////////////////////////////////
0: 			buffer.position(offset + extendedLengthByteCount);
/////////////////////////////////////////////////////////////////////////
1:         return buffer.position() - dssLengthLocation;
/////////////////////////////////////////////////////////////////////////
1:         buffer.position(dssLengthLocation + value);
/////////////////////////////////////////////////////////////////////////
1: 		buffer.put((byte) value);
/////////////////////////////////////////////////////////////////////////
1: 		buffer.putShort((short) value);
/////////////////////////////////////////////////////////////////////////
1: 		buffer.putInt(value);
/////////////////////////////////////////////////////////////////////////
1: 		buffer.put(buf, start, length);
/////////////////////////////////////////////////////////////////////////
1: 		buffer.putShort((short) codePoint);
1: 		buffer.putShort((short) value);
/////////////////////////////////////////////////////////////////////////
1: 		buffer.putShort((short) 0x0005);
1: 		buffer.putShort((short) codePoint);
1: 		buffer.put((byte) value);
/////////////////////////////////////////////////////////////////////////
1: 		buffer.putShort((short) 0x0006);
1: 		buffer.putShort((short) codePoint);
1: 		buffer.putShort((short) value);
1: 		buffer.putShort((short) value);
/////////////////////////////////////////////////////////////////////////
1: 		buffer.putShort((short) length);
1: 		buffer.putShort((short) codePoint);
/////////////////////////////////////////////////////////////////////////
0: 		buffer.putShort((short) length);
1: 		buffer.putShort((short) codePoint);
0: 		buffer.put(buf, 0, length);
/////////////////////////////////////////////////////////////////////////
0: 		    int spareBufferLength = buffer.remaining();
1: 
1: 			final int offset = buffer.position();
0: 			totalBytesRead += bytesRead;
1: 			buffer.position(offset + bytesRead);
/////////////////////////////////////////////////////////////////////////
1:       ensureLength( DEFAULT_BUFFER_SIZE - buffer.position() );
/////////////////////////////////////////////////////////////////////////
1: 		return buffer.position() != 0;
/////////////////////////////////////////////////////////////////////////
1: 			dssLengthLocation = buffer.position();
1: 			buffer.putShort((short) 0xFFFF);
/////////////////////////////////////////////////////////////////////////
0:       buffer.put((byte) (length >>> shiftSize));
/////////////////////////////////////////////////////////////////////////
0: 	buffer.putShort((short) length);
1: 	buffer.putShort((short) codePoint);
/////////////////////////////////////////////////////////////////////////
1: 		buffer.putShort((short) (dataLength + 4));
1: 		buffer.putShort((short) codePoint);
/////////////////////////////////////////////////////////////////////////
1: 		buffer.putShort((short) (stringLength + 4));
1: 		buffer.putShort((short) codePoint);
0: 		buffer.position(
0: 			ccsidManager.convertFromUCS2(string, bytes, buffer.position()));
/////////////////////////////////////////////////////////////////////////
1: 		buffer.putShort((short) (paddedLength + 4));
1: 		buffer.putShort((short) codePoint);
0: 		final int offset =
0: 			ccsidManager.convertFromUCS2(string, bytes, buffer.position());
0: 		final int end = offset + fillLength;
0: 		Arrays.fill(bytes, offset, end, ccsidManager.space);
1: 		buffer.position(end);
/////////////////////////////////////////////////////////////////////////
0: 		final int offset =
0: 			ccsidManager.convertFromUCS2(string, bytes, buffer.position());
0: 		final int end = offset + fillLength;
0: 		Arrays.fill(bytes, offset, end, ccsidManager.space);
0: 		buffer.position(end);
/////////////////////////////////////////////////////////////////////////
1: 		buffer.put(drdaString.getBytes(), 0, stringLength);
1: 		final int offset = buffer.position();
0: 		final int end = offset + fillLength;
0: 		Arrays.fill(bytes, offset, end, ccsidManager.space);
0: 		buffer.position(end);
/////////////////////////////////////////////////////////////////////////
1: 		buffer.putShort((short) (paddedLength + 4));
0: 		buffer.putShort((short) codePoint);
1: 		buffer.put(buf);
0: 		final int offset = buffer.position();
0: 		final int end = offset + (paddedLength - buf.length);
0: 		Arrays.fill(bytes, offset, end, padByte);
0: 		buffer.position(end);
/////////////////////////////////////////////////////////////////////////
1: 		buffer.put(buf);
0: 		final int offset = buffer.position();
0: 		final int end = offset + (paddedLength - buf.length);
0: 		Arrays.fill(bytes, offset, end, padByte);
0: 		buffer.position(end);
/////////////////////////////////////////////////////////////////////////
1: 		ensureLength(buf.length + 4);
1: 		buffer.putShort((short) (buf.length + 4));
0: 		buffer.putShort((short) codePoint);
1: 		buffer.put(buf);
/////////////////////////////////////////////////////////////////////////
0: 		buffer.putShort((short) (numBytes + 4));
0: 		buffer.putShort((short) codePoint);
0: 		buffer.put(buf, start, length);
/////////////////////////////////////////////////////////////////////////
1: 		buffer.putLong(v);
/////////////////////////////////////////////////////////////////////////
0: 		ensureLength(length);
0: 		buffer.position(buffer.position() + length);
/////////////////////////////////////////////////////////////////////////
1: 		writeByte(v ? 1 : 0);
/////////////////////////////////////////////////////////////////////////
0: 		final int offset = buffer.position();
1: 		final int end = offset + length;
0: 		Arrays.fill(bytes, offset, end, val);
0: 		buffer.position(end);
/////////////////////////////////////////////////////////////////////////
0: 		final int offset = buffer.position();
/////////////////////////////////////////////////////////////////////////
1: 		dssLengthLocation = buffer.position();
1: 		buffer.position(dssLengthLocation + 2);
1: 		buffer.put((byte) 0xD0);
1: 		buffer.put((byte) (dssType | DssConstants.DSSCHAIN_SAME_ID));
1: 		buffer.putShort((short) correlationID);
/////////////////////////////////////////////////////////////////////////
1: 		// initial position in the byte buffer
0: 		final int offset = buffer.position();
1: 
/////////////////////////////////////////////////////////////////////////
1: 			buffer.position(offset + shiftSize);
/////////////////////////////////////////////////////////////////////////
1: 		buffer.putShort(dssLengthLocation, (short) totalSize);
/////////////////////////////////////////////////////////////////////////
1: 		if (buffer.remaining() < length) {
1: 			int newLength =
0: 				Math.max(buffer.capacity() << 1, buffer.position() + length);
1: 			// copy the old buffer into a new one
1: 			buffer.flip();
1: 			buffer = ByteBuffer.allocate(newLength).put(buffer);
0: 			// update the reference to the new backing array
0: 			bytes = buffer.array();
/////////////////////////////////////////////////////////////////////////
0:         final int offset = buffer.position();
1: 
/////////////////////////////////////////////////////////////////////////
0: 	final int offset = buffer.position();
/////////////////////////////////////////////////////////////////////////
1: 		return buffer.position();
/////////////////////////////////////////////////////////////////////////
1: 		buffer.position(mark);
commit:10b5337
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:f949e07
/////////////////////////////////////////////////////////////////////////
0: import java.io.UnsupportedEncodingException;
/////////////////////////////////////////////////////////////////////////
0: 		catch (UnsupportedEncodingException e) {
/////////////////////////////////////////////////////////////////////////
0: 		} catch (UnsupportedEncodingException e) {
/////////////////////////////////////////////////////////////////////////
0: 		} catch (UnsupportedEncodingException e) {
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
commit:10e7778
/////////////////////////////////////////////////////////////////////////
1: 		ensureLength (4); // verify space for length bytes and code point
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:4f996a4
/////////////////////////////////////////////////////////////////////////
1:     The DDMWriter is used to write DRDA protocol.   The DRDA Protocol is
1:     described in the DDMReader class.
1:     For more details, see DRDA Volume 3 (Distributed Data Management(DDM)
1:         Architecture (DDS definition)
1:     // number of nesting levels for collections.  We need to mark the length
1:     // location of the collection so that we can update it as we add more stuff
1:     // to the collection
1:     private final static int MAX_MARKS_NESTING = 10;
1:     // Default buffer size
1:     private final static int DEFAULT_BUFFER_SIZE = 32767;
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * Output buffer.
1:      */
0:     private ByteBuffer buffer;
1:     // A saved mark in the stream is saved temporarily to revisit the location.
1:     private int[] markStack = new int[MAX_MARKS_NESTING];
1:     // top of the stack
1:     private int top;
1:     // CCSID manager for translation of strings in the protocol to UTF-8 and EBCDIC
1:     private EbcdicCcsidManager ebcdicCcsidManager;
1:     private Utf8CcsidManager utf8CcsidManager;
1:     
1:     // Current CCSID manager
1:     private CcsidManager ccsidManager;
1:     // DRDA connection thread for this writer
1:     private DRDAConnThread agent;
0:     //    This Object tracks the location of the current
0:     //    Dss header length bytes.    This is done so
0:     //    the length bytes can be automatically
0:     //    updated as information is added to this stream.
1:     private int dssLengthLocation;
1:     // Current correlation ID
0:     private    int correlationID;
1:     // Next correlation ID
1:     private int nextCorrelationID;
1:     // is this DRDA protocol or CMD protocol
1:     private boolean isDRDAProtocol;
1:     // trace object of the associated session
1:     private DssTrace dssTrace;
0:     // Location of the start of the header
1:     // of the DSS most recently written to the buffer.
1:     private int prevHdrLocation;
1:     // Correlation id of the last DSS that was written to buffer.
1:     private int previousCorrId;
1:     // Chaining bit of the last DSS that was written to buffer.
1:     private byte previousChainByte;
1:     // Whether or not the current DSS is a continuation DSS.
1:     private boolean isContinuationDss;
1:     // In situations where we want to "mark" a buffer location so that
1:     // we can "back-out" of a write to handle errors, this holds the
0:     // location within the buffer of the start of the header
1:     // that immediately precedes the mark.
1:     private int lastDSSBeforeMark;
0:     /** Encoder which encodes strings with the server's default encoding. */
0:     private final CharsetEncoder encoder;
/////////////////////////////////////////////////////////////////////////
1:     DDMWriter (DRDAConnThread agent, DssTrace dssTrace)
1:     {
1:         // Create instances of the two ccsid managers and default to EBCDIC
1:         this.ebcdicCcsidManager = new EbcdicCcsidManager();
1:         this.utf8CcsidManager = new Utf8CcsidManager();
1:         this.ccsidManager = this.ebcdicCcsidManager;
1:         
0:         this.buffer = ByteBuffer.allocate(DEFAULT_BUFFER_SIZE);
1:         this.agent = agent;
1:         this.prevHdrLocation = -1;
1:         this.previousCorrId = DssConstants.CORRELATION_ID_UNKNOWN;
1:         this.previousChainByte = DssConstants.DSS_NOCHAIN;
1:         this.isContinuationDss = false;
1:         this.lastDSSBeforeMark = -1;
1:         reset(dssTrace);
0:         // create an encoder which inserts the charset's default replacement
0:         // character for characters it can't encode
0:         encoder = NetworkServerControlImpl.DEFAULT_CHARSET.newEncoder()
0:             .onMalformedInput(CodingErrorAction.REPLACE)
0:             .onUnmappableCharacter(CodingErrorAction.REPLACE);
1:     }
1:     // Switch the ccsidManager to the UTF-8 instance
1:     protected void setUtf8Ccsid() {
1:         ccsidManager = utf8CcsidManager;
1:     }
1:     
1:     // Switch the ccsidManager to the EBCDIC instance
1:     protected void setEbcdicCcsid() {
1:         ccsidManager = ebcdicCcsidManager;
1:     }
1:     
1:     // Get the current ccsidManager
1:     protected CcsidManager getCurrentCcsidManager() {
1:         return ccsidManager;
1:     }
1:     
1:     /**
1:      * reset values for sending next message
1:      *
1:      */
1:     protected void reset(DssTrace dssTrace)
1:     {
0:         buffer.clear();
1:         top = 0;
1:         dssLengthLocation = 0;
1:         nextCorrelationID = 1;
1:         correlationID = DssConstants.CORRELATION_ID_UNKNOWN;
1:         isDRDAProtocol = true;
1:         this.dssTrace = dssTrace;
1:     }
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * set protocol to CMD protocol
1:      */
1:     protected void setCMDProtocol()
1:     {
1:         isDRDAProtocol = false;
1:     }
1:     /**
1:      * Create DSS reply object
1:      */
1:     protected void createDssReply()
1:     {
1:         beginDss(DssConstants.DSSFMT_RPYDSS, true);
1:     }
1:     /**
1:      * Create DSS request object
1:      * NOTE: This is _ONLY_ used for testing the protocol
1:      * We should never create a DSS request in normal
1:      * DRDA processing (we should only create DSS replies
1:      * and DSS objects).
1:      */
1:     protected void createDssRequest()
1:     {
1:         beginDss(DssConstants.DSSFMT_RQSDSS, true);
1:     }
1:     /**
1:      * Create DSS data object
1:      */
1:     protected void createDssObject()
1:     {
1:         beginDss(DssConstants.DSSFMT_OBJDSS, true);
1:     }
1:     /**
1:      * Mark the DSS that we're currently writing as
1:      * a continued DSS, which is done by setting
1:      * the high-order bit to "1", per DDM spec.
1:      * This means:
1:      *
0:      *    1. One or more continuation DSSes will immediately
0:      *         follow the current (continued) DSS.
0:      *    2. All continuation DSSes will have a 2-byte
0:      *         continuation header, followed by data; in
0:      *         other words, chaining state, correlation
0:      *        id, dss format info, and code point will
0:      *         NOT be included.  All of that info is 
0:      *         present ONLY in the FIRST DSS in the
0:      *        list of continued DSSes.
1:      *
0:      *    NOTE: A DSS can be a "continuation" DSS _and_
0:      *     a "continued" DSS at the same time.  However,
0:      *     the FIRST DSS to be continued canNOT be
0:      *    a continuation DSS.
1:      */
1:     private void markDssAsContinued(boolean forLob)
1:     {
1:         if (!forLob) {
1:         // continuation bit defaults to '1' for lobs, so
1:         // we only have to switch it if we're not writing
1:         // lobs.
0:             byte b = (byte) (buffer.get(dssLengthLocation) | 0x80);
0:             buffer.put(dssLengthLocation, b);
1:         }
1:         // We need to set the chaining state, but ONLY
1:         // IF this is the FIRST DSS in the continuation
1:         // list (only the first one has chaining state
1:         // in it's header; the others do not).
1:         if (!isContinuationDss)
1:             endDss(!forLob);
1:     }
1:     /**
1:      * End DSS header by writing the length in the length location
1:      * and setting the chain bit.  Unlike the other two endDss
1:      * methods, this one overrides the default chaining byte
1:      * (which is set in beginDss) with the chaining byte that
1:      * is passed in.  NOTE: This method is only used in
1:      * association with createDssRequest, and thus is for
1:      * should be made to this method in normal DRDA processing
1:      * (because for normal processing, chaining must be
1:      * determined automatically based on DSS requests).
1:      */
1:     protected void endDss(byte chainByte)
1:     {
1:         // Do regular endDss processing.
1:         endDss(true);
1:         // Now override default chain state.
0:         overrideChainByte(dssLengthLocation + 3, chainByte);
1:         previousChainByte = chainByte;
1:     }
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * End DSS header by writing the length in the length location
1:      * and setting the chain bit.
1:      */
1:     protected void endDss() {
1:         endDss(true);
1:     }
1:     /**
1:      * End DSS header by writing the length in the length location
1:      * and setting the chain bit.
1:      */
1:     private void endDss (boolean finalizeLength)
1:     {
1:         if (finalizeLength)
1:             finalizeDssLength();
1:         if (isContinuationDss) {
1:         // no chaining information for this DSS; so we're done.
1:             isContinuationDss = false;
1:             return;
1:         }
1:         previousCorrId = correlationID;
1:         prevHdrLocation = dssLengthLocation;
1:         previousChainByte = DssConstants.DSSCHAIN_SAME_ID;
1:     }
1:     /**
1:      * End final DDM and DSS header by writing the length in the length location
1:      *
1:      */
1:     protected void endDdmAndDss ()
1:     {
0:         endDdm();    // updates last DDM object
1:         endDss();
1:     }
1:     /**
1:      * Copy Data to End
1:      * Create a buffer and copy from the position given to the end of data
1:      *
1:      * Note that the position given is treated as relative to the
1:      * current DSS, for there may be other DSS blocks (chained, presumably)
1:      * which are sitting unwritten in the buffer. The caller doesn't
1:      * know this, though, and works only with the current DSS.
1:      *
1:      * getDSSLength, copyDSSDataToEnd, and truncateDSS work together to
1:      * provide a sub-protocol for DRDAConnThread to use in its
1:      * implementation of the LMTBLKPRC protocol. They enable the caller
1:      * to determine when it has written too much data into the current
1:      * DSS, to reclaim the extra data that won't fit, and to truncate
1:      * that extra data once it has been reclaimed and stored elsewhere.
1:      * Note that this support only works for the current DSS. Earlier,
1:      * chained DSS blocks cannot be accessed using these methods. For
1:      * additional background information, the interested reader should
1:      * investigate bugs DERBY-491 and 492 at:
1:      * http://issues.apache.org/jira/browse/DERBY-491 and
1:      * http://issues.apache.org/jira/browse/DERBY-492
1:      *
1:      * @param start
1:      */
1:     protected byte [] copyDSSDataToEnd(int start)
1:     {
1:         start = start + dssLengthLocation;
0:         int length = buffer.position() - start;
1:         byte [] temp = new byte[length];
0:         buffer.position(start);
0:         buffer.get(temp);
1:         return temp;
1:     }
1:     // Collection methods
1:     /**
1:      * Mark the location of the length bytes for the collection so they
1:      * can be updated later
1:      *
1:      */
1:     protected void startDdm (int codePoint)
1:     {
1:         // save the location of the beginning of the collection so
1:         // that we can come back and fill in the length bytes
0:         final int offset = buffer.position();
1:         markStack[top++] = offset;
0:         ensureLength (4); // verify space for length bytes and code point
0:         // move past the length bytes before writing the code point
0:         buffer.position(offset + 2);
0:         buffer.putShort((short) codePoint);
1:     }
1:     /**
1:      * Erase all writes for the current ddm and reset the
1:      * top
1:      */
1:     protected void clearDdm ()
1:     {
0:         buffer.position(markStack[top--]);
1:     }
1:     /**
1:      * Clear the entire send buffer
1:      *
1:      */
1:     protected void clearBuffer()
1:     {
0:         buffer.clear();
1:         top = 0;
1:         dssLengthLocation = 0;
1:         correlationID = DssConstants.CORRELATION_ID_UNKNOWN;
1:         nextCorrelationID = 1;
1:         isDRDAProtocol = true;
1:     }
1:     /**
1:      * End the current DDM
1:      *
1:      */
1:     protected void endDdm ()
1:     {
1:         // remove the top length location offset from the mark stack
1:         // calculate the length based on the marked location and end of data.
1:         int lengthLocation = markStack[--top];
0:         int length = buffer.position() - lengthLocation;
0:         // determine if any extended length bytes are needed.    the value returned
1:         // from calculateExtendedLengthByteCount is the number of extended length
1:         // bytes required. 0 indicates no exteneded length.
1:         int extendedLengthByteCount = calculateExtendedLengthByteCount (length);
1:         if (extendedLengthByteCount != 0)
1:         {
1:             // ensure there is enough room in the buffer for the extended length bytes.
1:             ensureLength (extendedLengthByteCount);
1:             // calculate the length to be placed in the extended length bytes.
1:             // this length does not include the 4 byte llcp.
1:             int extendedLength = length - 4;
0:             // the extended length should be written right after the length and
0:             // the codepoint (2+2 bytes)
0:             final int extendedLengthLocation = lengthLocation + 4;
1:             // shift the data to the right by the number of extended
1:             // length bytes needed.
0:             buffer.position(extendedLengthLocation + extendedLengthByteCount);
0:             buffer.put(buffer.array(), extendedLengthLocation, extendedLength);
0:             // write the extended length (a variable number of bytes in
0:             // big-endian order)
0:             for (int pos = extendedLengthLocation + extendedLengthByteCount - 1;
0:                  pos >= extendedLengthLocation; pos--) {
0:                 buffer.put(pos, (byte) extendedLength);
0:                 extendedLength >>= 8;
1:             }
1:             // the two byte length field before the codepoint contains the length
1:             // of itself, the length of the codepoint, and the number of bytes used
0:             // to hold the extended length.    the 2 byte length field also has the first
1:             // bit on to indicate extended length bytes were used.
1:             length = extendedLengthByteCount + 4;
1:             length |= DssConstants.CONTINUATION_BIT;
1:         }
1:         // write the 2 byte length field (2 bytes before codepoint).
0:         buffer.putShort(lengthLocation, (short) length);
1:     }
/////////////////////////////////////////////////////////////////////////
1:     // Write routines
1:     /**
1:      * Write byte
1:      *
0:      * @param     value    byte to be written
1:      */
1:     protected void writeByte (int value)
1:     {
1:         if (SanityManager.DEBUG)
1:         {
1:             if (value > 255)
1:                 SanityManager.THROWASSERT(
1:                                        "writeByte value: " + value +
1:                                        " may not be > 255");
1:         }
1:         ensureLength (1);
0:         buffer.put((byte) value);
1:     }
1:     /**
1:      * Write network short
1:      *
0:      * @param     value    value to be written
1:      */
1:     protected void writeNetworkShort (int value)
1:     {
1:         ensureLength (2);
0:         buffer.putShort((short) value);
1:     }
1:     /**
1:      * Write network int
1:      *
0:      * @param     value    value to be written
1:      */
1:     protected void writeNetworkInt (int value)
1:     {
1:         ensureLength (4);
0:         buffer.putInt(value);
1:     }
1:     /**
1:      * Write byte array
1:      *
0:      * @param     buf    byte array to be written
0:      * @param    length  - length to write
1:      */
1:     protected void writeBytes (byte[] buf, int length)
1:     {
1:         writeBytes(buf, 0,length);
1:     }
1:     /**
1:      * Write byte array
1:      *
0:      * @param     buf    byte array to be written
0:      * @param    start  - starting position
0:      * @param    length  - length to write
1:      */
1:     protected void writeBytes (byte[] buf, int start, int length)
1:     {
1:         if (SanityManager.DEBUG)
1:         {
1:             if (buf == null && length > 0)
1:                 SanityManager.THROWASSERT("Buf is null");
1:             if (length + start - 1 > buf.length)
1:                 SanityManager.THROWASSERT("Not enough bytes in buffer");
1:         }
1:         ensureLength (length);
0:         buffer.put(buf, start, length);
1:     }
1:     /**
1:      * Write byte array
1:      *
0:      * @param     buf    byte array to be written
1:      **/
1:     protected void writeBytes (byte[] buf)
1:     {
1:         writeBytes(buf,buf.length);
1:     }
1:     protected void writeLDBytes(byte[] buf)
1:     {
1:         writeLDBytes(buf, 0);
1:     }
1:     protected void writeLDBytes(byte[] buf, int index)
1:     {
1:         int writeLen =  buf.length;
1:         writeShort(writeLen);
1:         writeBytes(buf,0,writeLen);
1:     }
1:     /**
1:      * Write code point and 4 bytes
1:      *
0:      * @param     codePoint - code point to write
0:      * @param    value  - value to write after code point
1:      */
1:     void writeCodePoint4Bytes (int codePoint, int value)
1:     {
1:         ensureLength (4);
0:         buffer.putShort((short) codePoint);
0:         buffer.putShort((short) value);
1:     }
1:     /**
1:      * Write scalar 1 byte object includes length, codepoint and value
1:      *
0:      * @param     codePoint - code point to write
0:      * @param    value  - value to write after code point
1:      */
1:     void writeScalar1Byte (int codePoint, int value)
1:     {
1:         ensureLength (5);
0:         buffer.putShort((short) 0x0005);
0:         buffer.putShort((short) codePoint);
0:         buffer.put((byte) value);
1:     }
1:     /**
1:      * Write scalar 2 byte object includes length, codepoint and value
1:      *
0:      * @param     codePoint - code point to write
0:      * @param    value  - value to write after code point
1:      */
1:     protected void writeScalar2Bytes (int codePoint, int value)
1:     {
1:         ensureLength (6);
0:         buffer.putShort((short) 0x0006);
0:         buffer.putShort((short) codePoint);
0:         buffer.putShort((short) value);
1:     }
1:     protected void writeScalar2Bytes ( int value)
1:     {
1:         ensureLength (2);
0:         buffer.putShort((short) value);
1:     }
1:                                       int codePoint,
1:                       EXTDTAInputStream in,
1:                                       boolean writeNullByte) 
1:         throws DRDAProtocolException
1:     {
1:         
1:         // Stream equivalent of "beginDss"...
1:         int spareDssLength = prepScalarStream( chainedWithSameCorrelator,
1:                                             codePoint,
1:                                             writeNullByte);
1:         
1:         // write the data
1:                 try {
1:                     
1:         OutputStream out = 
1:             placeLayerBStreamingBuffer( agent.getOutputStream() );
1:         
1:         boolean isLastSegment = false;
1:         
1:         while( !isLastSegment ){
1:             
1:             if( SanityManager.DEBUG ){
1:         
1:             if( PropertyUtil.getSystemBoolean("derby.debug.suicideOfLayerBStreaming") )
1:                 throw new IOException();
1:                 }
0:             // read as many bytes as possible directly into the backing array
0:             final int offset = buffer.position();
0:             final int bytesRead =
0:                 in.read(buffer.array(), offset,
0:                         Math.min(spareDssLength, buffer.remaining()));
0:             // update the buffer position
0:             buffer.position(offset + bytesRead);
1:             spareDssLength -= bytesRead;
1:             isLastSegment = peekStream(in) < 0;
1:             
1:             if(isLastSegment || 
1:                spareDssLength == 0){
1:             
1:             flushScalarStreamSegment (isLastSegment, 
1:                           out);
1:             
1:             if( ! isLastSegment )
1:                 spareDssLength = DssConstants.MAX_DSS_LENGTH - 2;
1:             }
1:             
1:         }
1:         
1:         out.flush();
1:         
1:         }catch(IOException e){
1:         agent.markCommunicationsFailure (e,"DDMWriter.writeScalarStream()",
1:                          "",
1:                          e.getMessage(),
1:                          "*");
1:         }
1:                 
1:     }
1:     
1:     /**
1:      * Begins a DSS stream (for writing LOB data).
1:      */
1:     private void beginDss (boolean chainedToNextStructure,
1:                            int dssType)
1:     {
0:         beginDss(dssType, false);    // false => don't ensure length.
1:         // always turn on continuation flags... this is helpful for lobs...
1:         // these bytes will get rest if dss lengths are finalized.
0:         buffer.putShort(dssLengthLocation, (short) 0xFFFF);
1:         // Set whether or not this DSS should be chained to
1:         // the next one.  If it's chained, it has to be chained
1:         // with same id (that's the nature of EXTDTA chaining).
1:         if (chainedToNextStructure) {
1:             dssType |= DssConstants.GDSCHAIN_SAME_ID;
1:         }
0:         buffer.put(dssLengthLocation + 3, (byte) dssType);
1:     }
/////////////////////////////////////////////////////////////////////////
1:         // The existing DSS segment was finalized by endDss; all
1:         // we have to do is send it across the wire.
/////////////////////////////////////////////////////////////////////////
1:     beginDss(chainedWithSameCorrelator, DssConstants.GDSFMT_OBJDSS);
/////////////////////////////////////////////////////////////////////////
1:     protected boolean doesRequestContainData()
1:     {
0:         return buffer.position() != 0;
1:     }
1:     // Writes out a scalar stream DSS segment, along with DSS continuation
1:     // headers if necessary.
1:     private void flushScalarStreamSegment ( boolean lastSegment,
1:                             OutputStream out)
1:         throws DRDAProtocolException
1:     {
1:         // either at end of data, end of dss segment, or both.
1:         if (! lastSegment) {
1:         // 32k segment filled and not at end of data.
1:                 try {
1:                 // Mark current DSS as continued, set its chaining state,
1:                 // then send the data across.
0:                     markDssAsContinued(true);     // true => for lobs
1:                     sendBytes (out,
1:                            false);
1:                 
1:             }catch (java.io.IOException ioe) {
1:                     agent.markCommunicationsFailure ("DDMWriter.flushScalarStreamSegment()",
1:                 }
1:             // Prepare a DSS continuation header for next DSS.
0:             dssLengthLocation = buffer.position();
0:             buffer.putShort((short) 0xFFFF);
1:             isContinuationDss = true;
1:         }else{
1:         // we're done writing the data, so end the DSS.
1:             endDss();
1:     }
/////////////////////////////////////////////////////////////////////////
0:     buffer.putShort((short) length);
0:     buffer.putShort((short) codePoint);
1:     /**
1:      * Write scalar object header includes length and codepoint
1:      *
0:      * @param     codePoint - code point to write
0:      * @param    dataLength - length of object data
1:      */
1:     protected void writeScalarHeader (int codePoint, int dataLength)
1:     {
1:         ensureLength (dataLength + 4);
0:         buffer.putShort((short) (dataLength + 4));
0:         buffer.putShort((short) codePoint);
1:     }
1:     /**
1:      * Write scalar string object includes length, codepoint and value
1:      * the string is converted into the appropriate codeset (EBCDIC)
1:      *
0:      * @param     codePoint - code point to write
0:      * @param    string - string to be written
1:      */
1:     void writeScalarString (int codePoint, String string)
1:     {
1:         int stringLength = ccsidManager.getByteLength(string);
1:         ensureLength ((stringLength * 2)  + 4);
0:         buffer.putShort((short) (stringLength + 4));
0:         buffer.putShort((short) codePoint);
1:         ccsidManager.convertFromJavaString(string, buffer);
1:     }
1:     /**
1:      * Write padded scalar string object includes length, codepoint and value
1:      * the string is converted into the appropriate codeset (EBCDIC)
1:      *
0:      * @param     codePoint - code point to write
0:      * @param    string - string to be written
0:      * @param     paddedLength - length to pad string to
1:      */
1:     void writeScalarPaddedString (int codePoint, String string, int paddedLength)
1:     {
1:         int stringLength = ccsidManager.getByteLength(string);
1:         int fillLength = paddedLength - stringLength;
1:         ensureLength (paddedLength + 4);
0:         buffer.putShort((short) (paddedLength + 4));
0:         buffer.putShort((short) codePoint);
1:         ccsidManager.convertFromJavaString(string, buffer);
0:         padBytes(ccsidManager.space, fillLength);
1:     }
1:     /**
1:      * Write padded scalar <code>DRDAString</code> object value. The
1:      * string is converted into the appropriate codeset.
1:      *
1:      * @param drdaString string to be written
1:      * @param paddedLength length to pad string to
1:      */
1:     protected void writeScalarPaddedString (DRDAString drdaString, int paddedLength)
1:     {
1:         /* This .length() call is valid as this is a DRDAString */
1:         int stringLength = drdaString.length();
1:         int fillLength = paddedLength - stringLength;
1:         ensureLength(paddedLength);
0:         buffer.put(drdaString.getBytes(), 0, stringLength);
0:         padBytes(ccsidManager.space, fillLength);
1:     }
1:     /**
1:      * Write padded scalar byte array object includes length, codepoint and value
1:      *
0:      * @param     codePoint - code point to write
0:      * @param    buf - byte array to be written
0:      * @param     paddedLength - length to pad string to
0:      * @param    padByte - byte to be used for padding
1:      */
1:     protected void writeScalarPaddedBytes (int codePoint, byte[] buf, int paddedLength, byte padByte)
1:     {
1:         ensureLength (paddedLength + 4);
0:         buffer.putShort((short) (paddedLength + 4));
0:         buffer.putShort((short) codePoint);
0:         buffer.put(buf);
0:         padBytes(padByte, paddedLength - buf.length);
1:     }
1:     /**
1:      * Write padded scalar byte array object  value
1:      *
0:      * @param    buf - byte array to be written
0:      * @param     paddedLength - length to pad string to
0:      * @param    padByte - byte to be used for padding
1:      */
1:     protected void writeScalarPaddedBytes (byte[] buf, int paddedLength, byte padByte)
1:     {
1:         ensureLength (paddedLength);
0:         buffer.put(buf);
0:         padBytes(padByte, paddedLength - buf.length);
1:     }
1:     /**
1:      * Write scalar byte array object includes length, codepoint and value
1:      *
0:      * @param     codePoint - code point to write
0:      * @param    buf - byte array to be written
1:      */
1:     protected void writeScalarBytes (int codePoint, byte[] buf)
1:     {
0:         ensureLength(buf.length + 4);
0:         buffer.putShort((short) (buf.length + 4));
0:         buffer.putShort((short) codePoint);
0:         buffer.put(buf);
1:     }
1:     // The following methods write data in the platform format
1:     // The platform format was indicated during connection time as ASC since
1:     // JCC doesn't read JVM platform (yet)
1:     /**
1:      * Write platform short
1:      *
0:      * @param     v    value to be written
1:      */
1:     protected void writeShort (int v)
1:     {
1:         writeNetworkShort(v);
1:     }
1:     /**
1:      * Write boolean as short
1:      * @param b boolean value true = 1 false = 0
1:      *
1:      */
1:     protected void writeShort(boolean b)
1:     {
1:         writeNetworkShort(b ? 1 : 0);
1:     }
1:     /**
1:      * Write platform int
1:      *
0:      * @param     v    value to be written
1:      */
1:     protected void writeInt (int v)
1:     {
1:         writeNetworkInt(v);
1:     }
1:     /**
1:      * Write platform long
1:      *
0:      * @param     v    value to be written
1:      */
1:     protected void writeLong (long v)
1:     {
1:         ensureLength (8);
0:         buffer.putLong(v);
1:     }
1:     /**
1:      * Write platform float
1:      *
0:      * @param     v    value to be written
1:      */
1:     protected void writeFloat (float v)
1:     {
1:         writeInt (Float.floatToIntBits (v));
1:     }
1:     /**
1:      * Write platform double
1:      *
0:      * @param     v    value to be written
1:      */
1:     protected void writeDouble (double v)
1:     {
1:         writeLong (Double.doubleToLongBits (v));
1:     }
1:     /**
1:      * Write platform boolean
1:      *
0:      * @param     v    value to be written
1:      */
1:     protected void writeBoolean (boolean v)
1:     {
0:         writeByte(v ? 1 : 0);
1:     }
1:     /**
1:      * Write length delimited string
1:      *
1:      * @param s value to be written with integer
1:      *
1:      * @exception DRDAProtocolException
1:      */
1:     protected void writeLDString(String s) throws DRDAProtocolException
1:     {
0:         writeLDString(s, 0, null, false);
1:     }
1:     /**
0:      * Write a value of a user defined type.
1:      *
0:      * @param val object to be written
1:      *
1:      * @exception DRDAProtocolException
1:      */
0:     protected void writeUDT( Object val, int index ) throws DRDAProtocolException
1:     {
1:         if (SanityManager.DEBUG)
1:         {
/////////////////////////////////////////////////////////////////////////
1:     }
1:     /**
0:      * Find the maximum number of bytes needed to represent the string in the
0:      * default encoding.
1:      *
0:      * @param s the string to encode
0:      * @return an upper limit for the number of bytes needed to encode the
0:      * string
1:      */
0:     private int maxEncodedLength(String s) {
0:         // maxBytesPerChar() returns a float, which can only hold 24 bits of an
0:         // integer. Therefore, promote the float to a double so that all bits
0:         // are preserved in the intermediate result.
0:         return (int) (s.length() * (double) encoder.maxBytesPerChar());
1:     }
1:     /**
1:      * Write length delimited string
1:      *
1:      * @param s              value to be written with integer
1:      * @param index          column index to put in warning
1:      * @exception DRDAProtocolException
1:      */
0:     protected void writeLDString(String s, int index, DRDAStatement stmt,
1:     {
0:         // Position on which to write the length of the string (in bytes). The
0:         // actual writing of the length is delayed until we have encoded the
0:         // string.
0:         final int lengthPos = buffer.position();
/////////////////////////////////////////////////////////////////////////
1:     }
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Write string with default encoding
1:      *
1:      * @param s value to be written
1:      *
0:      * @exception DRDAProtocolException
1:      */
1:     protected void writeString(String s) throws DRDAProtocolException
1:     {
0:         ensureLength(maxEncodedLength(s));
0:         CharBuffer input = CharBuffer.wrap(s);
0:         encoder.reset();
0:         CoderResult res = encoder.encode(input, buffer, true);
0:         if (res == CoderResult.UNDERFLOW) {
0:             res = encoder.flush(buffer);
1:         }
0:         if (SanityManager.DEBUG) {
0:             SanityManager.ASSERT(res == CoderResult.UNDERFLOW,
0:                                  "CharBuffer was not exhausted: res = " + res);
1:         }
1:     }
1:     /**
1:      * Write pad bytes using spaceChar
1:      *
0:      * @param   val    value to be written
0:      * @param    length        length to be written
1:      */
1:     protected void padBytes (byte val, int length)
1:     {
0:         final int offset = buffer.position();
0:         final int end = offset + length;
0:         Arrays.fill(buffer.array(), offset, end, val);
0:         buffer.position(end);
1:     }
1:     /**
1:      * Flush buffer to outputstream
1:      *
1:      *
1:      * @exception IOException
1:      */
1:     protected void flush () throws java.io.IOException
1:     {
1:         flush(agent.getOutputStream());
1:     }
1:     /**
1:      * Flush buffer to specified stream
1:      *
1:      * @param socketOutputStream
1:      *
1:      * @exception IOException
1:      */
1:     protected void flush(OutputStream socketOutputStream)
1:         throws java.io.IOException
1:     {
0:         final byte[] bytes = buffer.array();
1:         final int length = buffer.position();
1:         try {
1:             socketOutputStream.write (bytes, 0, length);
1:             socketOutputStream.flush();
1:         }
1:         finally {
1:             if ((dssTrace != null) && dssTrace.isComBufferTraceOn()) {
1:               dssTrace.writeComBufferData (bytes,
1:                                            0,
1:                                            DssTrace.TYPE_TRACE_SEND,
1:                                            "Reply",
1:                                            "flush",
1:                                            5);
1:             }
1:             reset(dssTrace);
1:         }
1:     }
1:     // private methods
1:     /**
1:      * Write DSS header
1:      * DSS Header format is
0:      *     2 bytes    - length
0:      *    1 byte    - 'D0'    - indicates DDM data
0:      *     1 byte    - DSS format
0:      *        |---|---------|----------|
0:      *        | 0    |    flags |    type     |
0:      *        |---|---------|----------|
0:      *        | 0 | 1    2    3 | 4 5 6 7     |
0:      *        |---|---------|----------|
0:      *        bit 0 - '0'
0:      *        bit 1 - '0' - unchained, '1' - chained
0:      *        bit 2 - '0'    - do not continue on error, '1' - continue on error
0:      *        bit 3 - '0' - next DSS has different correlator, '1' - next DSS has
0:      *                        same correlator
0:      *        type - 1 - Request DSS
0:      *             - 2 - Reply DSS
0:      *             - 3 - Object DSS
0:      *             - 4 - Communications DSS
0:      *             - 5 - Request DSS where no reply is expected
1:      */
1:     private void beginDss (int dssType, boolean ensureLen)
1:     {
1:         // save length position, the length will be written at the end
0:         dssLengthLocation = buffer.position();
1:         // Should this really only be for non-stream DSSes?
1:         if (ensureLen)
1:             ensureLength(6);
1:         // Skip past length; we'll come back and set it later.
0:         buffer.position(dssLengthLocation + 2);
1:         // write gds info
0:         buffer.put((byte) 0xD0);
1:         // Write DSS type, and default chain bit to be 
1:         // DssConstants.DSSCHAIN_SAME_ID.  This default
1:         // will be overridden by calls to "finalizeChain()"
1:         // and/or calls to "beginDss(boolean, int)" for
1:         // writing LOB data.
0:         buffer.put((byte) (dssType | DssConstants.DSSCHAIN_SAME_ID));
1:         // save correlationID for use in error messages while processing
1:         // this DSS
1:         correlationID = getCorrelationID();
1:         // write the reply correlation id
0:         buffer.putShort((short) correlationID);
1:     }
1:     /**
1:      * The length of dss object will be calculated based on the difference between the
1:      * start of the dss, saved on the beginDss call, and the current
0:      * offset into the buffer which marks the end of the data.    In the event
1:      * the length requires the use of continuation Dss headers, one for each 32k
1:      * chunk of data, the data will be shifted and the continuation headers
1:      * will be inserted with the correct values as needed.
1:      */
1:     private void finalizeDssLength ()
1:     {
0:         // initial position in the byte buffer
0:         final int offset = buffer.position();
1:         // calculate the total size of the dss and the number of bytes which would
1:         // require continuation dss headers.    The total length already includes the
0:         // the 6 byte dss header located at the beginning of the dss.    It does not
1:         // include the length of any continuation headers.
1:         int totalSize = offset - dssLengthLocation;
1:         int bytesRequiringContDssHeader = totalSize - DssConstants.MAX_DSS_LENGTH;
1:         // determine if continuation headers are needed
1:         if (bytesRequiringContDssHeader > 0)
1:         {
1:             // the continuation headers are needed, so calculate how many.
1:             // after the first 32767 worth of data, a continuation header is
1:             // needed for every 32765 bytes (32765 bytes of data + 2 bytes of
1:             // continuation header = 32767 Dss Max Size).
1:             int contDssHeaderCount = bytesRequiringContDssHeader / 32765;
1:             if (bytesRequiringContDssHeader % 32765 != 0)
1:                 contDssHeaderCount++;
0:             // right now the code will shift to the right.    In the future we may want
1:             // to try something fancier to help reduce the copying (maybe keep
1:             // space in the beginning of the buffer??).
1:             // the offset points to the next available offset in the buffer to place
1:             // a piece of data, so the last dataByte is at offset -1.
1:             // various bytes will need to be shifted by different amounts
1:             // depending on how many dss headers to insert so the amount to shift
0:             // will be calculated and adjusted as needed.    ensure there is enough room
1:             // for all the conutinuation headers and adjust the offset to point to the
1:             // new end of the data.
1:             int dataByte = offset - 1;
1:             int shiftSize = contDssHeaderCount * 2;
1:             ensureLength (shiftSize);
0:             // We're going to access the buffer with absolute positions, so
0:             // just move the current position pointer right away to where it's
0:             // supposed to be after we have finished the shifting.
0:             buffer.position(offset + shiftSize);
1:             // Notes on the behavior of the Layer B segmenting loop below:
1:             //
1:             // We start with the right most chunk. For a 3-segment object we'd
1:             // shift 2 segments: shift the first (rightmost) one 4 bytes and 
1:             // the second one 2. Note that by 'first' we mean 'first time
1:             // through the loop', but that is actually the last segment
1:             // of data since we are moving right-to-left. For an object
1:             // of K segments we will pass through this loop K-1 times.
1:             // The 0th (leftmost) segment is not shifted, as it is
1:             // already in the right place. When we are done, we will
1:             // have made room in each segment for an additional
1:             // 2 bytes for the continuation header. Thus, each
1:             // segment K is shifted K*2 bytes to the right.
1:             //
1:             // Each time through the loop, "dataByte" points to the
1:             // last byte in the segment; "dataToShift" is the amount of
1:             // data that we need to shift, and "shiftSize" is the
1:             // distance that we need to shift it. Since dataByte points
1:             // at the last byte, not one byte beyond it (as with the
1:             // "offset" variable used elsewhere in DDMWriter), the start
1:             // of the segement is actually at (dataByte-dataToShift+1).
1:             //
1:             // After we have shifted the segment, we move back to the
1:             // start of the segment and set the value of the 2-byte DSS
1:             // continuation header, which needs to hold the length of
1:             // this segment's data, together with the continuation flag
1:             // if this is not the rightmost (passOne) segment.
1:             //
1:             // In general, each segment except the rightmost will contain
1:             // 32765 bytes of data, plus the 2-byte header, and its
1:             // continuation flag will be set, so the header value will
1:             // be 0xFFFF. The rightmost segment will not have the
1:             // continuation flag set, so its value may be anything from
1:             // 0x0001 to 0x7FFF, depending on the amount of data in that
1:             // segment.
1:             //
1:             // Note that the 0th (leftmost) segment also has a 2-byte
1:             // DSS header, which needs to have its continuation flag set.
1:             // This is done by resetting the "totalSize" variable below,
1:             // at which point that variable no longer holds the total size
1:             // of the object, but rather just the length of segment 0. The
1:             // total size of the object was written using extended length
1:             // bytes by the endDdm() method earlier.
1:             //
1:             // Additional information about this routine is available in the
1:             // bug notes for DERBY-125:
1:             // http://issues.apache.org/jira/browse/DERBY-125
1:             
1:             // mark passOne to help with calculating the length of the final (first or
1:             // rightmost) continuation header.
1:             boolean passOne = true;
1:             do {
1:                 // calculate chunk of data to shift
1:                 int dataToShift = bytesRequiringContDssHeader % 32765;
1:                 if (dataToShift == 0)
1:                     dataToShift = 32765;
1:                 int startOfCopyData = dataByte - dataToShift + 1;
0:                 // perform the shift directly on the backing array
0:                 final byte[] bytes = buffer.array();
1:                 System.arraycopy(bytes,startOfCopyData, bytes, 
1:                                  startOfCopyData + shiftSize, dataToShift);
1:                 dataByte -= dataToShift;
1:                 // calculate the value the value of the 2 byte continuation dss
1:                 // header which includes the length of itself.  On the first pass,
1:                 // if the length is 32767
1:                 // we do not want to set the continuation dss header flag.
1:                 int twoByteContDssHeader = dataToShift + 2;
1:                 if (passOne)
1:                     passOne = false;
1:                 else
1:                 {
1:                     if (twoByteContDssHeader == DssConstants.MAX_DSS_LENGTH)
1:                     twoByteContDssHeader = (twoByteContDssHeader |
1:                         DssConstants.CONTINUATION_BIT);
1:                 }
1:                 // insert the header's length bytes
0:                 buffer.putShort(dataByte + shiftSize - 1,
0:                                 (short) twoByteContDssHeader);
1:                 // adjust the bytesRequiringContDssHeader and the amount to shift for
1:                 // data in upstream headers.
1:                 bytesRequiringContDssHeader -= dataToShift;
1:                 shiftSize -= 2;
1:                 // shift and insert another header for more data.
1:             }
1:             while (bytesRequiringContDssHeader > 0);
1:             // set the continuation dss header flag on for the first header
1:             totalSize = (DssConstants.MAX_DSS_LENGTH |
1:                     DssConstants.CONTINUATION_BIT);
1:         }
1:         // insert the length bytes in the 6 byte dss header.
0:         buffer.putShort(dssLengthLocation, (short) totalSize);
1:     }
1:     protected void writeExtendedLength(long size)
1:     {
1:         int numbytes = calculateExtendedLengthByteCount(size);
1:         if (size > 0)
1:             writeInt(0x8000 | numbytes);
1:         else
1:             writeInt(numbytes);
1:     }
1:     /**
1:      * Calculate extended length byte count which follows the DSS header
1:      * for extended DDM.
1:      *
1:      * @param ddmSize - size of DDM command
1:      * @return minimum number of extended length bytes needed. 0 indicates no
0:      *     extended length needed.
1:      */
1:     private int calculateExtendedLengthByteCount (long ddmSize)
1:     {
1:         if (ddmSize <= 0x7fff)
1:             return 0;
1:         // JCC does not support 2 at this time, so we always send
1:         // at least 4
0:         //        else if (ddmSize <= 0xffff)
0:         //    return 2;
1:         else if (ddmSize <= 0xffffffffL)
1:             return 4;
1:         else if (ddmSize <= 0xffffffffffffL)
1:             return 6;
1:         else if (ddmSize <= 0x7fffffffffffffffL)
1:             return 8;
1:         else
1:             // shouldn't happen
1:             // XXX - add sanity debug stuff here
1:             return 0;
1:     }
1:     /**
1:      * Ensure that there is space in the buffer
1:      *
1:      * @param length space required
1:      */
1:     private void ensureLength (int length)
1:     {
0:         if (buffer.remaining() < length) {
0:             if (SanityManager.DEBUG)
1:             {
1:                 agent.trace("DANGER - Expensive expansion of  buffer");
1:             }
0:             int newLength =
1:                 Math.max(buffer.capacity() * 2, buffer.position() + length);
0:             // copy the old buffer into a new one
0:             buffer.flip();
0:             buffer = ByteBuffer.allocate(newLength).put(buffer);
1:         }
1:     }
1:     /**
1:      * Write a Java <code>java.math.BigDecimal</code> to packed decimal bytes.
1:      *
1:      * @param b BigDecimal to write
1:      * @param precision Precision of decimal or numeric type
0:      * @param scale declared scale
1:      *
0:      * @exception SQLException Thrown if # digits > 31
1:      */
0:     void writeBigDecimal(BigDecimal b, int precision, int scale)
1:     throws SQLException
1:     {
/////////////////////////////////////////////////////////////////////////
1:         int declaredPrecision = precision;
1:         int declaredScale = scale;
1:         // packed decimal may only be up to 31 digits.
1:         if (declaredPrecision > 31) // this is a bugcheck only !!!
1:         {
1:             clearDdm ();
1:             throw new java.sql.SQLException ("Packed decimal may only be up to 31 digits!");
1:         }
1:         // get absolute unscaled value of the BigDecimal as a String.
1:         String unscaledStr = b.unscaledValue().abs().toString();
1:         // get precision of the BigDecimal.
0:           int bigPrecision = unscaledStr.length();
1:         if (bigPrecision > 31)
1:         {
1:             clearDdm ();
0:               throw new SQLException ("The numeric literal \"" +
1:         }
1:         int bigScale = b.scale();
0:           int bigWholeIntegerLength = bigPrecision - bigScale;
1:         if ( (bigWholeIntegerLength > 0) && (!unscaledStr.equals ("0")) ) {
1:             {
1:                 clearDdm ();
1:             }
/////////////////////////////////////////////////////////////////////////
1:     }
1:     throws java.io.IOException{
1:     
1:     sendBytes(socketOutputStream,
1:           true);
1:     
1:               boolean flashStream ) 
1:     resetChainState();
0:     final byte[] bytes = buffer.array();
0:     final int length = buffer.position();
1:       socketOutputStream.flush();
1:         if ((dssTrace != null) && dssTrace.isComBufferTraceOn()) {
1:             dssTrace.writeComBufferData (bytes,
1:                                            0,
1:                                            length,
1:                                            DssTrace.TYPE_TRACE_SEND,
1:                                            "Reply",
1:                                            "flush",
1:                                            5);
1:     /**
1:      * Reset any chaining state that needs to be reset
1:      * at time of the send
1:      */
1:     protected void resetChainState()
1:     {
1:         prevHdrLocation = -1;
1:     }
1:     /**
1:      * Looks at chaining info for previous DSS written, and use
1:      * that to figure out what the correlation id for the current
1:      * DSS should be.  Return that correlation id.
1:      */
1:     private int getCorrelationID() {
1:         int cId;
1:         if (previousCorrId != DssConstants.CORRELATION_ID_UNKNOWN) {
1:             if (previousChainByte == DssConstants.DSSCHAIN_SAME_ID)
1:             // then we have to use the last correlation id we sent.
1:                 cId = previousCorrId;
1:             else
1:             // get correlation id as normal.
1:                 cId = nextCorrelationID++;
1:         }
1:         else {
1:         // must be the case that this is the first DSS we're
1:         // writing for this connection (because we haven't
1:         // called "endDss" yet).  So, get the corr id as
1:         // normal.
1:             cId = nextCorrelationID++;
1:         }
1:         return cId;
1:     }
1:     /**
1:      * Finalize the current DSS chain and send it if
1:      * needed.
1:      *
1:      * Updates the chaining state of the most recently-written-
1:      * to-buffer DSS to correspond to the most recently-read-
1:      * from-client request.  If that chaining state indicates
1:      * we've reached the end of a chain, then we go ahead
1:      * and send the buffer across the wire.
1:      * @param socketOutputStream Output stream to which we're flushing.
1:      */
1:     protected void finalizeChain(byte currChainByte,
1:         OutputStream socketOutputStream) throws DRDAProtocolException
1:     {
1:         // Go back to previous DSS and override the default
1:         // chain state (WITH_SAME_ID) with whatever the last
1:         // request dictates.
1:         if (prevHdrLocation != -1) {
1:         // Note: == -1 => the previous DSS was already sent; this
1:         // should only happen in cases where the buffer filled up
1:         // and we had to send it (which means we were probably
1:         // writing EXTDTA).  In such cases, proper chaining
1:         // should already have been handled @ time of send.
0:             overrideChainByte(prevHdrLocation + 3, currChainByte);
1:         }
1:         // previousChainByte needs to match what we just did.
1:         previousChainByte = currChainByte;
1:         if (currChainByte != DssConstants.DSS_NOCHAIN)
1:         // then we're still inside a chain, so don't send.
1:             return;
1:         // Else, we just ended the chain, so send it across.
1:         if ((SanityManager.DEBUG) && (agent != null))
1:             agent.trace("Sending data");
1:         resetChainState();
1:         if (doesRequestContainData()) {
1:             try {
1:                 flush(socketOutputStream);
1:             } catch (java.io.IOException e) {
1:                 agent.markCommunicationsFailure(
1:                     "DDMWriter.finalizeChain()",
1:                     "OutputStream.flush()",
1:                     e.getMessage(),"*");
1:             }
1:         }
1:     }
1:     /**
1:      * Takes note of the location of the most recently completed
1:      * DSS in the buffer, and then returns the current offset.
1:      * This method is used in conjunction with "clearDSSesBackToMark"
1:      * to allow for DRDAConnThread to "back-out" DSSes in the
1:      * event of errors.
1:      */
1:     protected int markDSSClearPoint()
1:     {
1:         lastDSSBeforeMark = prevHdrLocation;
0:         return buffer.position();
1:     }
1:     /**
1:      * Does a logical "clear" of everything written to the buffer after
1:      * the received mark.  It's assumed that this method will be used
1:      * in error cases when we've started writing one or more DSSes,
1:      * but then hit an error and need to back out.  After backing out,
1:      * we'll always need to write _something_ back to the client to
1:      * indicate an error (typically, we just write an SQLCARD) but what
1:      * exactly gets written is handled in DRDAConnThread.  Here, we
1:      * just do the necessary prep so that whatever comes next will
1:      * succeed.
1:      */
1:     protected void clearDSSesBackToMark(int mark)
1:     {
1:         // Logical clear.
0:         buffer.position(mark);
1:         // Because we've just cleared out the most recently-
1:         // written DSSes, we have to make sure the next thing
1:         // we write will have the correct correlation id.  We
1:         // do this by setting the value of 'nextCorrelationID'
1:         // based on the chaining byte from the last remaining
1:         // DSS (where "remaining" means that it still exists
1:         // in the buffer after the clear).
1:         if (lastDSSBeforeMark == -1)
1:         // we cleared out the entire buffer; reset corr id.
1:             nextCorrelationID = 1;
1:         else {
1:         // last remaining DSS had chaining, so we set "nextCorrelationID"
1:         // to be 1 greater than whatever the last remaining DSS had as
1:         // its correlation id.
0:              nextCorrelationID =
0:                 (buffer.getShort(lastDSSBeforeMark + 4) & 0xFFFF) + 1;
1:         }
1:     }
1:     
1:         
1:     in.mark(1);
1:     try{
1:         return in.read();
1:         
1:     }finally{
1:         in.reset();
1:         
1:     }
1:     return PropertyUtil.getSystemInt( Property.DRDA_PROP_STREAMOUTBUFFERSIZE , 0 );
1:     
1:     int size = getLayerBStreamingBufferSize();
1:     
1:     if(size < 1)
1:         return original;
1:     else
1:         return new BufferedOutputStream( original, size );
commit:9b816c6
/////////////////////////////////////////////////////////////////////////
0: 		int stringLength = ccsidManager.getByteLength(string);
commit:cdfb2d1
/////////////////////////////////////////////////////////////////////////
0: 	// CCSID manager for translation of strings in the protocol to UTF-8 and EBCDIC
0: 	private EbcdicCcsidManager ebcdicCcsidManager;
0: 	private Utf8CcsidManager utf8CcsidManager;
1: 	
0: 	// Current CCSID manager
/////////////////////////////////////////////////////////////////////////
0: 	DDMWriter (DRDAConnThread agent, DssTrace dssTrace)
0: 	    // Create instances of the two ccsid managers and default to EBCDIC
0: 	    this.ebcdicCcsidManager = new EbcdicCcsidManager();
0: 	    this.utf8CcsidManager = new Utf8CcsidManager();
0: 	    this.ccsidManager = this.ebcdicCcsidManager;
1: 	    
/////////////////////////////////////////////////////////////////////////
0: 	// Switch the ccsidManager to the UTF-8 instance
0: 	protected void setUtf8Ccsid() {
0: 	    ccsidManager = utf8CcsidManager;
1: 	}
1: 	
0: 	// Switch the ccsidManager to the EBCDIC instance
0: 	protected void setEbcdicCcsid() {
0: 	    ccsidManager = ebcdicCcsidManager;
1: 	}
1: 	
0: 	// Get the current ccsidManager
0: 	protected CcsidManager getCurrentCcsidManager() {
0: 	    return ccsidManager;
1: 	}
1: 	
/////////////////////////////////////////////////////////////////////////
0: 		ccsidManager.convertFromJavaString(string, buffer);
/////////////////////////////////////////////////////////////////////////
0: 		ccsidManager.convertFromJavaString(string, buffer);
/////////////////////////////////////////////////////////////////////////
0: 		ccsidManager.convertFromJavaString(string, buffer);
commit:b672fd0
/////////////////////////////////////////////////////////////////////////
0: 		agent.markCommunicationsFailure (e,"DDMWriter.writeScalarStream()",
commit:1adb9d7
/////////////////////////////////////////////////////////////////////////
0: 			// Notes on the behavior of the Layer B segmenting loop below:
0: 			//
0: 			// We start with the right most chunk. For a 3-segment object we'd
0: 			// shift 2 segments: shift the first (rightmost) one 4 bytes and 
0: 			// the second one 2. Note that by 'first' we mean 'first time
0: 			// through the loop', but that is actually the last segment
0: 			// of data since we are moving right-to-left. For an object
0: 			// of K segments we will pass through this loop K-1 times.
0: 			// The 0th (leftmost) segment is not shifted, as it is
0: 			// already in the right place. When we are done, we will
0: 			// have made room in each segment for an additional
0: 			// 2 bytes for the continuation header. Thus, each
0: 			// segment K is shifted K*2 bytes to the right.
0: 			//
0: 			// Each time through the loop, "dataByte" points to the
0: 			// last byte in the segment; "dataToShift" is the amount of
0: 			// data that we need to shift, and "shiftSize" is the
0: 			// distance that we need to shift it. Since dataByte points
0: 			// at the last byte, not one byte beyond it (as with the
0: 			// "offset" variable used elsewhere in DDMWriter), the start
0: 			// of the segement is actually at (dataByte-dataToShift+1).
0: 			//
0: 			// After we have shifted the segment, we move back to the
0: 			// start of the segment and set the value of the 2-byte DSS
0: 			// continuation header, which needs to hold the length of
0: 			// this segment's data, together with the continuation flag
0: 			// if this is not the rightmost (passOne) segment.
0: 			//
0: 			// In general, each segment except the rightmost will contain
0: 			// 32765 bytes of data, plus the 2-byte header, and its
0: 			// continuation flag will be set, so the header value will
0: 			// be 0xFFFF. The rightmost segment will not have the
0: 			// continuation flag set, so its value may be anything from
0: 			// 0x0001 to 0x7FFF, depending on the amount of data in that
0: 			// segment.
0: 			//
0: 			// Note that the 0th (leftmost) segment also has a 2-byte
0: 			// DSS header, which needs to have its continuation flag set.
0: 			// This is done by resetting the "totalSize" variable below,
0: 			// at which point that variable no longer holds the total size
0: 			// of the object, but rather just the length of segment 0. The
0: 			// total size of the object was written using extended length
0: 			// bytes by the endDdm() method earlier.
0: 			//
0: 			// Additional information about this routine is available in the
0: 			// bug notes for DERBY-125:
0: 			// http://issues.apache.org/jira/browse/DERBY-125
1: 			
/////////////////////////////////////////////////////////////////////////
0: 				int startOfCopyData = dataByte - dataToShift + 1;
/////////////////////////////////////////////////////////////////////////
0: 					twoByteContDssHeader = (twoByteContDssHeader |
0: 						DssConstants.CONTINUATION_BIT);
1: 
/////////////////////////////////////////////////////////////////////////
0: 			totalSize = (DssConstants.MAX_DSS_LENGTH |
0: 					DssConstants.CONTINUATION_BIT);
1: 
commit:2e4a44e
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 		if (doesRequestContainData()) {
commit:4359236
/////////////////////////////////////////////////////////////////////////
0: 	// TODO: Rewrite writeScalarStream to avoid passing a length.
0: 	// The length is never written and not required by the DRDA spec.
0: 	// Also looks like on IOException we just pad out the stream instead
0: 	// of actually sending an exception.  Similar code is in client, so 
0: 	// should be fixed in both places.
/////////////////////////////////////////////////////////////////////////
commit:9085abb
/////////////////////////////////////////////////////////////////////////
0: 			byte [] byteval = s.getBytes(NetworkServerControlImpl.DEFAULT_ENCODING);
/////////////////////////////////////////////////////////////////////////
0: 			We assume that NetworkServerControlImpl.DEFAULT_ENCODING remains UTF-8
0: 				if (!(NetworkServerControlImpl.DEFAULT_ENCODING.equals("UTF8")))
0: 					SanityManager.THROWASSERT("Encoding assumed to be UTF8, but is actually" + NetworkServerControlImpl.DEFAULT_ENCODING);
/////////////////////////////////////////////////////////////////////////
0: 			agent.agentError("Encoding " + NetworkServerControlImpl.DEFAULT_ENCODING + " not supported");
/////////////////////////////////////////////////////////////////////////
0: 			writeBytes(s.getBytes(NetworkServerControlImpl.DEFAULT_ENCODING));
0: 			agent.agentError("Encoding " + NetworkServerControlImpl.DEFAULT_ENCODING + " not supported");
/////////////////////////////////////////////////////////////////////////
0: 			bs = s.getBytes(NetworkServerControlImpl.DEFAULT_ENCODING);
0: 			agent.agentError("Encoding " + NetworkServerControlImpl.DEFAULT_ENCODING + " not supported");
/////////////////////////////////////////////////////////////////////////
0: 			padBytes(NetworkServerControlImpl.SPACE_CHAR, length-len);
commit:a54b657
/////////////////////////////////////////////////////////////////////////
1: 
0: 	// In situations where we want to "mark" a buffer location so that
0: 	// we can "back-out" of a write to handle errors, this holds the
0: 	// location within the "bytes" array of the start of the header
0: 	// that immediately precedes the mark.
0: 	private int lastDSSBeforeMark;
1: 
/////////////////////////////////////////////////////////////////////////
0: 		this.lastDSSBeforeMark = -1;
/////////////////////////////////////////////////////////////////////////
0: 		this.lastDSSBeforeMark = -1;
/////////////////////////////////////////////////////////////////////////
0: 	/**
0: 	 * Takes note of the location of the most recently completed
0: 	 * DSS in the buffer, and then returns the current offset.
0: 	 * This method is used in conjunction with "clearDSSesBackToMark"
0: 	 * to allow for DRDAConnThread to "back-out" DSSes in the
0: 	 * event of errors.
1: 	 */
0: 	protected int markDSSClearPoint()
1: 	{
1: 
0: 		lastDSSBeforeMark = prevHdrLocation;
0: 		return getOffset();
1: 
1: 	}
1: 
0: 	/**
0: 	 * Does a logical "clear" of everything written to the buffer after
0: 	 * the received mark.  It's assumed that this method will be used
0: 	 * in error cases when we've started writing one or more DSSes,
0: 	 * but then hit an error and need to back out.  After backing out,
0: 	 * we'll always need to write _something_ back to the client to
0: 	 * indicate an error (typically, we just write an SQLCARD) but what
0: 	 * exactly gets written is handled in DRDAConnThread.  Here, we
0: 	 * just do the necessary prep so that whatever comes next will
0: 	 * succeed.
1: 	 */
0: 	protected void clearDSSesBackToMark(int mark)
1: 	{
1: 
0: 		// Logical clear.
0: 		setOffset(mark);
1: 
0: 		// Because we've just cleared out the most recently-
0: 		// written DSSes, we have to make sure the next thing
0: 		// we write will have the correct correlation id.  We
0: 		// do this by setting the value of 'nextCorrelationID'
0: 		// based on the chaining byte from the last remaining
0: 		// DSS (where "remaining" means that it still exists
0: 		// in the buffer after the clear).
0: 		if (lastDSSBeforeMark == -1)
0: 		// we cleared out the entire buffer; reset corr id.
0: 			nextCorrelationID = 1;
1: 		else {
0: 		// last remaining DSS had chaining, so we set "nextCorrelationID"
0: 		// to be 1 greater than whatever the last remaining DSS had as
0: 		// its correlation id.
0:  			nextCorrelationID = 1 + (int)
0: 				(((bytes[lastDSSBeforeMark + 4] & 0xff) << 8) +
0: 				(bytes[lastDSSBeforeMark + 5] & 0xff));
1: 		}
1: 
1: 	}
1: 
commit:d79abcf
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 	// Location within the "bytes" array of the start of the header
0: 	// of the DSS most recently written to the buffer.
0: 	private int prevHdrLocation;
0: 	// Correlation id of the last DSS that was written to buffer.
0: 	private int previousCorrId;
0: 	// Chaining bit of the last DSS that was written to buffer.
0: 	private byte previousChainByte;
1: 
0: 	// Whether or not the current DSS is a continuation DSS.
0: 	private boolean isContinuationDss;
1: 	
0: 		this.prevHdrLocation = -1;
0: 		this.previousCorrId = DssConstants.CORRELATION_ID_UNKNOWN;
0: 		this.previousChainByte = DssConstants.DSS_NOCHAIN;
0: 		this.isContinuationDss = false;
/////////////////////////////////////////////////////////////////////////
0: 		this.prevHdrLocation = -1;
0: 		this.previousCorrId = DssConstants.CORRELATION_ID_UNKNOWN;
0: 		this.previousChainByte = DssConstants.DSS_NOCHAIN;
0: 		this.isContinuationDss = false;
/////////////////////////////////////////////////////////////////////////
0: 		beginDss(DssConstants.DSSFMT_RPYDSS, true);
0: 	 * NOTE: This is _ONLY_ used for testing the protocol
0: 	 * (via the TestProto.java file in this package)!
0: 	 * We should never create a DSS request in normal
0: 	 * DRDA processing (we should only create DSS replies
0: 	 * and DSS objects).
0: 	protected void createDssRequest()
0: 		beginDss(DssConstants.DSSFMT_RQSDSS, true);
1: 
0: 		beginDss(DssConstants.DSSFMT_OBJDSS, true);
1: 	}
1: 
0: 	/**
0: 	 * Mark the DSS that we're currently writing as
0: 	 * a continued DSS, which is done by setting
0: 	 * the high-order bit to "1", per DDM spec.
0: 	 * This means:
1: 	 *
0: 	 *	1. One or more continuation DSSes will immediately
0: 	 * 		follow the current (continued) DSS.
0: 	 *	2. All continuation DSSes will have a 2-byte
0: 	 * 		continuation header, followed by data; in
0: 	 * 		other words, chaining state, correlation
0: 	 *		id, dss format info, and code point will
0: 	 * 		NOT be included.  All of that info is 
0: 	 * 		present ONLY in the FIRST DSS in the
0: 	 *		list of continued DSSes.
1: 	 *
0: 	 *	NOTE: A DSS can be a "continuation" DSS _and_
0: 	 * 	a "continued" DSS at the same time.  However,
0: 	 * 	the FIRST DSS to be continued canNOT be
0: 	 *	a continuation DSS.
0: 	 */
0: 	private void markDssAsContinued(boolean forLob)
1: 	{
1: 
0: 		if (!forLob) {
0: 		// continuation bit defaults to '1' for lobs, so
0: 		// we only have to switch it if we're not writing
0: 		// lobs.
0: 			bytes[dssLengthLocation] |= 0x80;
1: 		}
1: 
0: 		// We need to set the chaining state, but ONLY
0: 		// IF this is the FIRST DSS in the continuation
0: 		// list (only the first one has chaining state
0: 		// in it's header; the others do not).
0: 		if (!isContinuationDss)
0: 			endDss(!forLob);
1: 
0: 	 * and setting the chain bit.  Unlike the other two endDss
0: 	 * methods, this one overrides the default chaining byte
0: 	 * (which is set in beginDss) with the chaining byte that
0: 	 * is passed in.  NOTE: This method is only used in
0: 	 * association with createDssRequest, and thus is for
0: 	 * TESTING purposes only (via TestProto.java).  No calls
0: 	 * should be made to this method in normal DRDA processing
0: 	 * (because for normal processing, chaining must be
0: 	 * determined automatically based on DSS requests).
0: 	protected void endDss(byte chainByte)
1: 
0: 		// Do regular endDss processing.
0: 		endDss(true);
1: 
0: 		// Now override default chain state.
0: 		bytes[dssLengthLocation + 3] &= 0x0F;	// Zero out default
0: 		bytes[dssLengthLocation + 3] |= chainByte;
0: 		previousChainByte = chainByte;
1: 
1: 	}
1: 
0: 	/**
0: 	 * End DSS header by writing the length in the length location
0: 	 * and setting the chain bit.
0: 	 */
0: 	protected void endDss() {
0: 		endDss(true);
1: 	}
1: 
0: 	/**
0: 	 * End DSS header by writing the length in the length location
0: 	 * and setting the chain bit.
0: 	 */
0: 	private void endDss (boolean finalizeLength)
1: 	{
1: 
0: 		if (finalizeLength)
0: 			finalizeDssLength();
1: 
0: 		if (isContinuationDss) {
0: 		// no chaining information for this DSS; so we're done.
0: 			isContinuationDss = false;
0: 			return;
1: 		}
1: 
0: 		previousCorrId = correlationID;
0: 		prevHdrLocation = dssLengthLocation;
0: 		previousChainByte = DssConstants.DSSCHAIN_SAME_ID;
1: 
/////////////////////////////////////////////////////////////////////////
0: 		nextCorrelationID = 1;
/////////////////////////////////////////////////////////////////////////
0: 	protected int  writeScalarStream (boolean chainedWithSameCorrelator,
1: 
0: 		// Stream equivalent of "beginDss"...
0: 		int bytesToRead = prepScalarStream (chainedWithSameCorrelator,
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0: 	/**
0: 	 * Begins a DSS stream (for writing LOB data).
0: 	 */
0: 	private void beginDss (boolean chainedToNextStructure,
0: 						   int dssType)
0: 	{
0: 		beginDss(dssType, false);	// false => don't ensure length.
0: 		// always turn on continuation flags... this is helpful for lobs...
0: 		// these bytes will get rest if dss lengths are finalized.
0:   		bytes[dssLengthLocation] = (byte) 0xFF;
0:   		bytes[dssLengthLocation + 1] = (byte) 0xFF;
0: 		// Set whether or not this DSS should be chained to
0: 		// the next one.  If it's chained, it has to be chained
0: 		// with same id (that's the nature of EXTDTA chaining).
0: 		if (chainedToNextStructure) {
0: 			dssType |= DssConstants.GDSCHAIN_SAME_ID;
1: 		}
0: 		bytes[dssLengthLocation + 3] = (byte) (dssType & 0xff);
1: 	}
0:   protected int prepScalarStream  (boolean chainedWithSameCorrelator,
/////////////////////////////////////////////////////////////////////////
0: 	    // The existing DSS segment was finalized by endDss; all
0: 	    // we have to do is send it across the wire.
/////////////////////////////////////////////////////////////////////////
0: 	beginDss(chainedWithSameCorrelator, DssConstants.GDSFMT_OBJDSS);
/////////////////////////////////////////////////////////////////////////
0: 	{
0: 		int newBytesToRead = bytesToRead;
0: 		// either at end of data, end of dss segment, or both.
0: 		if (leftToRead != 0) {
0: 		// 32k segment filled and not at end of data.
1: 
0: 			if ((Math.min (2 + leftToRead, 32767)) > (bytes.length - offset)) {
1: 				try {
0: 				// Mark current DSS as continued, set its chaining state,
0: 				// then send the data across.
0: 					markDssAsContinued(true); 	// true => for lobs
0: 					sendBytes (agent.getOutputStream());
1: 				}
0: 				catch (java.io.IOException ioe) {
0: 					agent.markCommunicationsFailure ("DDMWriter.flushScalarStreamSegment()",
1: 				}
1: 			}
1: 			else {
0: 			// DSS is full, but we still have space in the buffer.  So
0: 			// end the DSS, then start the next DSS right after it.
0: 				endDss(false);		// false => don't finalize length.
1: 			}
0: 			// Prepare a DSS continuation header for next DSS.
0: 			dssLengthLocation = offset;
0: 			bytes[offset++] = (byte) (0xff);
0: 			bytes[offset++] = (byte) (0xff);
0: 			newBytesToRead = Math.min (leftToRead,32765);
0: 			isContinuationDss = true;
1:   		}
1: 		else {
0: 		// we're done writing the data, so end the DSS.
0: 			endDss();
1: 		}
1: 
0: 		return newBytesToRead;
1: 
1: 	}
/////////////////////////////////////////////////////////////////////////
0: 		flush(agent.getOutputStream());
0: 	}
1: 
0: 	/**
0: 	 * Flush buffer to specified stream
0: 	 *
0: 	 * @param socketOutputStream
0: 	 *
0: 	 * @exception IOException
0: 	 */
0: 	protected void flush(OutputStream socketOutputStream)
1: 		throws java.io.IOException
0: 	{
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 	private void beginDss (int dssType, boolean ensureLen)
1: 
0: 		// Should this really only be for non-stream DSSes?
0: 		if (ensureLen)
0: 			ensureLength(6);
1: 
0: 		// Skip past length; we'll come back and set it later.
0: 		// Write DSS type, and default chain bit to be 
0: 		// DssConstants.DSSCHAIN_SAME_ID.  This default
0: 		// will be overridden by calls to "finalizeChain()"
0: 		// and/or calls to "beginDss(boolean, int)" for
0: 		// writing LOB data.
0: 		bytes[offset + 1] = (byte) dssType;
0: 		bytes[offset + 1] |= DssConstants.DSSCHAIN_SAME_ID;
1: 
0: 		// save correlationID for use in error messages while processing
0: 		// this DSS
0: 		correlationID = getCorrelationID();
1: 
0: 		// write the reply correlation id
0: 		bytes[offset + 2] = (byte) ((correlationID >>> 8) & 0xff);
0: 		bytes[offset + 3] = (byte) (correlationID & 0xff);
/////////////////////////////////////////////////////////////////////////
0: 	resetChainState();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 	/**
0: 	 * Reset any chaining state that needs to be reset
0: 	 * at time of the send
0: 	 */
0: 	protected void resetChainState()
0: 	{
0: 		prevHdrLocation = -1;
0: 	}
1: 
0: 	/**
0: 	 * Looks at chaining info for previous DSS written, and use
0: 	 * that to figure out what the correlation id for the current
0: 	 * DSS should be.  Return that correlation id.
0: 	 */
0: 	private int getCorrelationID() {
1: 
0: 		int cId;
0: 		if (previousCorrId != DssConstants.CORRELATION_ID_UNKNOWN) {
0: 			if (previousChainByte == DssConstants.DSSCHAIN_SAME_ID)
0: 			// then we have to use the last correlation id we sent.
0: 				cId = previousCorrId;
0: 			else
0: 			// get correlation id as normal.
0: 				cId = nextCorrelationID++;
0: 		}
0: 		else {
0: 		// must be the case that this is the first DSS we're
0: 		// writing for this connection (because we haven't
0: 		// called "endDss" yet).  So, get the corr id as
0: 		// normal.
0: 			cId = nextCorrelationID++;
0: 		}
1: 
0: 		return cId;
1: 
0: 	}
1: 
0: 	/**
0: 	 * Finalize the current DSS chain and send it if
0: 	 * needed.
0: 	 *
0: 	 * Updates the chaining state of the most recently-written-
0: 	 * to-buffer DSS to correspond to the most recently-read-
0: 	 * from-client request.  If that chaining state indicates
0: 	 * we've reached the end of a chain, then we go ahead
0: 	 * and send the buffer across the wire.
0: 	 * @param socketOutputStream Output stream to which we're flushing.
0: 	 */
0: 	protected void finalizeChain(byte currChainByte,
0: 		OutputStream socketOutputStream) throws DRDAProtocolException
0: 	{
1: 
0: 		// Go back to previous DSS and override the default
0: 		// chain state (WITH_SAME_ID) with whatever the last
0: 		// request dictates.
1: 
0: 		if (prevHdrLocation != -1) {
0: 		// Note: == -1 => the previous DSS was already sent; this
0: 		// should only happen in cases where the buffer filled up
0: 		// and we had to send it (which means we were probably
0: 		// writing EXTDTA).  In such cases, proper chaining
0: 		// should already have been handled @ time of send.
0: 			bytes[prevHdrLocation + 3] &= 0x0F;	// Zero out old chain value.
0: 			bytes[prevHdrLocation + 3] |= currChainByte;
0: 		}
1: 
0: 		// previousChainByte needs to match what we just did.
0: 		previousChainByte = currChainByte;
1: 
0: 		if (currChainByte != DssConstants.DSS_NOCHAIN)
0: 		// then we're still inside a chain, so don't send.
0: 			return;
1: 
0: 		// Else, we just ended the chain, so send it across.
1: 
0: 		if ((SanityManager.DEBUG) && (agent != null))
0: 			agent.trace("Sending data");
1: 
0: 		resetChainState();
0: 		if (offset != 0) {
1: 			try {
0: 				flush(socketOutputStream);
0: 			} catch (java.io.IOException e) {
0: 				agent.markCommunicationsFailure(
0: 					"DDMWriter.finalizeChain()",
1: 					"OutputStream.flush()",
1: 					e.getMessage(),"*");
0: 			}
0: 		}
1: 
0: 	}
1: 
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:c3c7b7b
/////////////////////////////////////////////////////////////////////////
1:     * (via the ProtocolTestAdapter.java file in this package)!
/////////////////////////////////////////////////////////////////////////
1:     * TESTING purposes only (via ProtocolTestAdpater.java).  No calls
commit:90e68d8
/////////////////////////////////////////////////////////////////////////
0: 			if( PropertyUtil.getSystemBoolean("derby.debug.suicideOfLayerBStreaming") )
author:Tiago Aurlio Rodrigues Espinha
-------------------------------------------------------------------------------
commit:c7bf46c
/////////////////////////////////////////////////////////////////////////
0: 		int stringLength = ccsidManager.getByteLength(string);
/////////////////////////////////////////////////////////////////////////
0: 		int stringLength = ccsidManager.getByteLength(string);
/////////////////////////////////////////////////////////////////////////
0: 	    /* This .length() call is valid as this is a DRDAString */
author:Bernt Johnsen
-------------------------------------------------------------------------------
commit:357ad1c
/////////////////////////////////////////////////////////////////////////
1:       totalByteCount += length;
commit:1ab256e
/////////////////////////////////////////////////////////////////////////
1:     // For JMX statistics. Volatile to ensure we 
1:     // get one complete long, but we don't bother to synchronize, 
1:     // since this is just statistics.
1:     
1:     volatile long totalByteCount = 0;
1:     
/////////////////////////////////////////////////////////////////////////
1:         totalByteCount += length;
commit:974609a
/////////////////////////////////////////////////////////////////////////
0: 	 * Note that the position given is treated as relative to the
0: 	 * current DSS, for there may be other DSS blocks (chained, presumably)
0: 	 * which are sitting unwritten in the buffer. The caller doesn't
0: 	 * know this, though, and works only with the current DSS.
0: 	 *
0: 	 * getDSSLength, copyDSSDataToEnd, and truncateDSS work together to
0: 	 * provide a sub-protocol for DRDAConnThread to use in its
0: 	 * implementation of the LMTBLKPRC protocol. They enable the caller
0: 	 * to determine when it has written too much data into the current
0: 	 * DSS, to reclaim the extra data that won't fit, and to truncate
0: 	 * that extra data once it has been reclaimed and stored elsewhere.
0: 	 * Note that this support only works for the current DSS. Earlier,
0: 	 * chained DSS blocks cannot be accessed using these methods. For
0: 	 * additional background information, the interested reader should
0: 	 * investigate bugs DERBY-491 and 492 at:
0: 	 * http://issues.apache.org/jira/browse/DERBY-491 and
0: 	 * http://issues.apache.org/jira/browse/DERBY-492
0: 	 *
0: 	protected byte [] copyDSSDataToEnd(int start)
0: 		start = start + dssLengthLocation;
/////////////////////////////////////////////////////////////////////////
0:     /**
1:      * Get the length of the current DSS block we're working on. This is
1:      * used by the LMTBLKPRC protocol, which does its own conversational
1:      * blocking protocol above the layer of the DRDA blocking. The LMTBLKPRC
1:      * implementation (in DRDAConnThread) needs to be able to truncate a
1:      * DSS block when splitting a QRYDTA response.
0:      *
1:      * @return current DSS block length
0:     */
1:     protected int getDSSLength()
0:     {
0:         return offset - dssLengthLocation;
0:     }
1:  
0:     /**
1:      * Truncate the current DSS. Before making this call, you should ensure
1:      * that you have copied the data to be truncated somewhere else, by
1:      * calling copyDSSDataToEnd
0:      *
0:      * @param desired DSS length
0:     */
1:     protected void truncateDSS(int value)
0:     {
0:         offset = dssLengthLocation + value;
0:     }
/////////////////////////////////////////////////////////////////////////
0: 		return offset;
/////////////////////////////////////////////////////////////////////////
0: 		offset = mark;
commit:ee2a860
/////////////////////////////////////////////////////////////////////////
0: 	 * Write padded scalar <code>DRDAString</code> object value. The
0: 	 * string is converted into the appropriate codeset.
0: 	 *
0: 	 * @param drdaString string to be written
0: 	 * @param paddedLength length to pad string to
0: 	 */
0: 	protected void writeScalarPaddedString (DRDAString drdaString, int paddedLength)
0: 	{
0: 		int stringLength = drdaString.length();
0: 		int fillLength = paddedLength - stringLength;
0: 		ensureLength(paddedLength);
0: 		System.arraycopy(drdaString.getBytes(), 0, bytes, offset, stringLength);
0: 		offset += stringLength;
0: 		Arrays.fill(bytes, offset, offset + fillLength, ccsidManager.space);
0: 		offset += fillLength;
0: 	}
1: 
0: 	/**
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:efb1bd2
/////////////////////////////////////////////////////////////////////////
1: import java.io.InputStream;
1: import java.io.OutputStream;
1: import java.sql.SQLException;
1: import java.util.Arrays;
1: 
1: import org.apache.derby.iapi.reference.Property;
1: import org.apache.derby.iapi.services.property.PropertyUtil;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 		final int length = buffer.position();
0: 			socketOutputStream.write (bytes, 0, length);
0:                                            length,
/////////////////////////////////////////////////////////////////////////
0: 				Math.max(buffer.capacity() * 2, buffer.position() + length);
commit:d7258ed
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.drda.DDMWriter
1: 
0:    Copyright 2001, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:141cd31
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.drda
0:    (C) Copyright IBM Corp. 2001, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
0:  */
1: 
1: package org.apache.derby.impl.drda;
1: 
0: import java.io.OutputStream;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import java.sql.SQLException;
0: import java.sql.DataTruncation;
0: import java.math.BigDecimal;
0: import org.apache.derby.iapi.error.ExceptionSeverity;
0: import java.util.Arrays;
1: 
0: /**
0: 	The DDMWriter is used to write DRDA protocol.   The DRDA Protocol is
0: 	described in the DDMReader class.
0: 	For more details, see DRDA Volume 3 (Distributed Data Management(DDM)
0: 		Architecture (DDS definition)
0: */
1: class DDMWriter
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
1: 
0: 	private static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2001_2004;
1: 
0: 	// number of nesting levels for collections.  We need to mark the length
0: 	// location of the collection so that we can update it as we add more stuff
0: 	// to the collection
0: 	private final static int MAX_MARKS_NESTING = 10;
1: 
0: 	// Default buffer size
0: 	private final static int DEFAULT_BUFFER_SIZE = 32767;
1: 
1: 
0: 	static final BigDecimal ZERO = BigDecimal.valueOf(0L);
1: 
0: 	// output buffer
0: 	private byte[] bytes;
1: 
0: 	// offset into output buffer
0: 	private int offset;
1: 
0: 	// A saved mark in the stream is saved temporarily to revisit the location.
0: 	private int[] markStack = new int[MAX_MARKS_NESTING];
1: 
0: 	// top of the stack
0: 	private int top;
1: 
0: 	private boolean simpleDssFinalize = false;
1: 
0: 	// CCSID manager for translation of strings in the protocol to EBCDIC
0: 	private CcsidManager ccsidManager;
1: 
0: 	// DRDA connection thread for this writer
0: 	private DRDAConnThread agent;
1: 
0: 	//	This Object tracks the location of the current
0: 	//	Dss header length bytes.	This is done so
0: 	//	the length bytes can be automatically
0: 	//	updated as information is added to this stream.
0: 	private int dssLengthLocation;
1: 
0: 	// Current correlation ID
0: 	private	int correlationID;
1: 
0: 	// Next correlation ID
0: 	private int nextCorrelationID;
1: 
0: 	// is this DRDA protocol or CMD protocol
0: 	private boolean isDRDAProtocol;
0: 	// trace object of the associated session
0: 	private DssTrace dssTrace;
1: 
1: 
1: 
0: 	// Constructors
0: 	DDMWriter (int minSize, CcsidManager ccsidManager, DRDAConnThread agent, DssTrace dssTrace)
0: 	{
0: 		this.bytes = new byte[minSize];
0: 		this.ccsidManager = ccsidManager;
0: 		this.agent = agent;
0: 		reset(dssTrace);
0: 	}
1: 
0: 	DDMWriter (CcsidManager ccsidManager, DRDAConnThread agent, DssTrace dssTrace)
0: 	{
0: 		this.bytes = new byte[DEFAULT_BUFFER_SIZE];
0: 		this.ccsidManager = ccsidManager;
0: 		this.agent = agent;
0: 		reset(dssTrace);
0: 	}
1: 
0: 	/**
0: 	 * reset values for sending next message
0: 	 *
0: 	 */
0: 	protected void reset(DssTrace dssTrace)
0: 	{
0: 		offset = 0;
0: 		top = 0;
0: 		dssLengthLocation = 0;
0: 		nextCorrelationID = 1;
0: 		correlationID = DssConstants.CORRELATION_ID_UNKNOWN;
0: 		isDRDAProtocol = true;
0: 		this.dssTrace = dssTrace;
0: 	}
1: 
0: 	/**
0: 	 * set protocol to CMD protocol
0: 	 */
0: 	protected void setCMDProtocol()
0: 	{
0: 		isDRDAProtocol = false;
0: 	}
1: 
0: 	/**
0: 	 * Create DSS reply object
0: 	 */
0: 	protected void createDssReply()
0: 	{
0: 		// finish off previous DSS
0:     	if (offset != 0)
0:     		finalizePreviousChainedDss(false);
0: 		beginDss(DssConstants.DSSFMT_RPYDSS, nextCorrelationID++);
0: 		simpleDssFinalize = false;
0: 	}
1: 
0: 	/**
0: 	 * Create DSS request object
0: 	 */
0: 	protected void createDssRequest(int corrID)
0: 	{
0: 		// finish off previous DSS
0:     	if (offset != 0)
0:     		finalizePreviousChainedDss((correlationID == corrID));
0: 		beginDss(DssConstants.DSSFMT_RQSDSS, corrID);
0: 		simpleDssFinalize = false;
0: 	}
0: 	/**
0: 	 * Create DSS data object
0: 	 */
0: 	protected void createDssObject(boolean reuseCorrID)
0: 	{
0: 		// finish off previous DSS - objects are always part of a previous
0: 		// DSS reply - so correlation id should be the same
0:     	if (offset != 0)
0:     		finalizePreviousChainedDss (reuseCorrID);
0: 		beginDss(DssConstants.DSSFMT_OBJDSS, (reuseCorrID ? correlationID : nextCorrelationID++));
0: 		simpleDssFinalize = false;
0: 	}
0: 	/**
0: 	 * Create DSS data object
0: 	 */
0: 	protected void createDssObject()
0: 	{
0: 		createDssObject(true);
0: 	}
1: 
0: 	/**
0: 	 * End DSS header by writing the length in the length location
0: 	 *
0: 	 */
0: 	protected void endDss ()
0: 	{
0: 		int val = offset - dssLengthLocation;
0: 		bytes[dssLengthLocation] = (byte) ((val >>> 8) & 0xff);
0: 		bytes[dssLengthLocation + 1] = (byte) (val & 0xff);
0: 	}
1: 
0: 	/**
0: 	 * End final DDM and DSS header by writing the length in the length location
0: 	 *
0: 	 */
0: 	protected void endDdmAndDss ()
0: 	{
0: 		endDdm();	// updates last DDM object
0: 		endDss();
0: 	}
0: 	/**
0: 	 * Copy Data to End
0: 	 * Create a buffer and copy from the position given to the end of data
0: 	 *
0: 	 * @param start
0: 	 */
0: 	protected byte [] copyDataToEnd(int start)
0: 	{
0: 		int length = offset - start;
0: 		byte [] temp = new byte[length];
0: 		System.arraycopy(bytes,start,temp,0,length);
0: 		return temp;
0: 	}
1: 
0: 	// Collection methods
1: 
0: 	/**
0: 	 * Mark the location of the length bytes for the collection so they
0: 	 * can be updated later
0: 	 *
0: 	 */
0: 	protected void startDdm (int codePoint)
0: 	{
0: 		// save the location of the beginning of the collection so
0: 		// that we can come back and fill in the length bytes
0: 		markStack[top++] = offset;
0: 		offset += 2; // move past the length bytes before writing the code point
0: 		bytes[offset] = (byte) ((codePoint >>> 8) & 0xff);
0: 		bytes[offset + 1] = (byte) (codePoint & 0xff);
0: 		offset += 2;
0: 	}
1: 
0: 	/**
0: 	 * Erase all writes for the current ddm and reset the
0: 	 * top
0: 	 */
0: 	protected void clearDdm ()
0: 	{
0: 		offset = markStack[top--];
0: 	}
1: 
0: 	/**
0: 	 * Clear the entire send buffer
0: 	 *
0: 	 */
0: 	protected void clearBuffer()
0: 	{
0: 		offset = 0;
0: 		top = 0;
0: 		dssLengthLocation = 0;
0: 		correlationID = DssConstants.CORRELATION_ID_UNKNOWN;
0: 		isDRDAProtocol = true;
0: 	}
1: 
0: 	/**
0: 	 * End the current DDM
0: 	 *
0: 	 */
0: 	protected void endDdm ()
0: 	{
0: 		// remove the top length location offset from the mark stack
0: 		// calculate the length based on the marked location and end of data.
0: 		int lengthLocation = markStack[--top];
0: 		int length = offset - lengthLocation;
1: 
0: 		// determine if any extended length bytes are needed.	the value returned
0: 		// from calculateExtendedLengthByteCount is the number of extended length
0: 		// bytes required. 0 indicates no exteneded length.
0: 		int extendedLengthByteCount = calculateExtendedLengthByteCount (length);
0: 		if (extendedLengthByteCount != 0)
0: 		{
0: 			// ensure there is enough room in the buffer for the extended length bytes.
0: 			ensureLength (extendedLengthByteCount);
1: 
0: 			// calculate the length to be placed in the extended length bytes.
0: 			// this length does not include the 4 byte llcp.
0: 			int extendedLength = length - 4;
1: 
0: 			// shift the data to the right by the number of extended
0: 			// length bytes needed.
0: 			int extendedLengthLocation = lengthLocation + 4;
0: 			System.arraycopy (bytes,
0: 					              extendedLengthLocation,
0: 					              bytes,
0: 					              extendedLengthLocation + extendedLengthByteCount,
0: 					              extendedLength);
1: 
0: 			// write the extended length
0: 			int shiftSize = (extendedLengthByteCount -1) * 8;
0: 			for (int i = 0; i < extendedLengthByteCount; i++)
0: 			{
0: 				bytes[extendedLengthLocation++] =
0: 					(byte) ((extendedLength >>> shiftSize ) & 0xff);
0: 				shiftSize -= 8;
0: 			}
1: 
0: 			// adjust the offset to account for the shift and insert
0: 			offset += extendedLengthByteCount;
1: 
0: 			// the two byte length field before the codepoint contains the length
0: 			// of itself, the length of the codepoint, and the number of bytes used
0: 			// to hold the extended length.	the 2 byte length field also has the first
0: 			// bit on to indicate extended length bytes were used.
0: 			length = extendedLengthByteCount + 4;
0: 			length |= DssConstants.CONTINUATION_BIT;
0: 		}
1: 
0: 		// write the 2 byte length field (2 bytes before codepoint).
0: 		bytes[lengthLocation] = (byte) ((length >>> 8) & 0xff);
0: 		bytes[lengthLocation+1] = (byte) (length & 0xff);
1: 
0: 	}
1: 
0: 	/**
0: 	 * Get offset
0: 	 *
0: 	 * @return offset into the buffer
0: 	 */
0: 	protected int getOffset()
0: 	{
0: 		return offset;
0: 	}
1: 
0: 	/**
0: 	 * Set offset
0: 	 *
0: 	 * @param value new offset value
0: 	 */
0: 	protected void setOffset(int value)
0: 	{
0: 		offset = value;
0: 	}
1: 
1: 
1: 
0: 	// Write routines
1: 
0: 	/**
0: 	 * Write byte
0: 	 *
0: 	 * @param 	value	byte to be written
0: 	 */
0: 	protected void writeByte (int value)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (value > 255)
0: 				SanityManager.THROWASSERT(
0: 									   "writeByte value: " + value +
0: 									   " may not be > 255");
0: 		}
1: 
0: 		ensureLength (1);
0: 		bytes[offset++] = (byte) (value & 0xff);
0: 	}
1: 
1: 
0: 	/**
0: 	 * Write network short
0: 	 *
0: 	 * @param 	value	value to be written
0: 	 */
0: 	protected void writeNetworkShort (int value)
0: 	{
0: 		ensureLength (2);
0: 		bytes[offset] = (byte) ((value >>> 8) & 0xff);
0: 		bytes[offset + 1] = (byte) (value & 0xff);
0: 		offset += 2;
0: 	}
1: 
0: 	/**
0: 	 * Write network int
0: 	 *
0: 	 * @param 	value	value to be written
0: 	 */
0: 	protected void writeNetworkInt (int value)
0: 	{
1: 		ensureLength (4);
0: 		bytes[offset] = (byte) ((value >>> 24) & 0xff);
0: 		bytes[offset + 1] = (byte) ((value >>> 16) & 0xff);
0: 		bytes[offset + 2] = (byte) ((value >>> 8) & 0xff);
0: 		bytes[offset + 3] = (byte) (value & 0xff);
0: 		offset += 4;
0: 	}
1: 
1: 
0: 	/**
0: 	 * Write byte array
0: 	 *
0: 	 * @param 	buf	byte array to be written
0: 	 * @param	length  - length to write
0: 	 */
0: 	protected void writeBytes (byte[] buf, int length)
0: 	{
0: 		writeBytes(buf, 0,length);
0: 	}
1: 
1: 
1: 
0: 	/**
0: 	 * Write byte array
0: 	 *
0: 	 * @param 	buf	byte array to be written
0: 	 * @param	start  - starting position
0: 	 * @param	length  - length to write
0: 	 */
0: 	protected void writeBytes (byte[] buf, int start, int length)
0: 	{
1: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (buf == null && length > 0)
0: 		    	SanityManager.THROWASSERT("Buf is null");
0: 			if (length + start - 1 > buf.length)
0: 		    	SanityManager.THROWASSERT("Not enough bytes in buffer");
1: 
0: 		}
0: 		ensureLength (length);
0: 		System.arraycopy(buf,start,bytes,offset,length);
0: 		offset += length;
0: 	}
0: 	/**
0: 	 * Write byte array
0: 	 *
0: 	 * @param 	buf	byte array to be written
0: 	 **/
0: 	protected void writeBytes (byte[] buf)
0: 	{
0: 		writeBytes(buf,buf.length);
0: 	}
1: 
1: 
1: 
0: 	protected void writeLDBytes(byte[] buf)
0: 	{
0: 		writeLDBytes(buf, 0);
0: 	}
1: 
0: 	protected void writeLDBytes(byte[] buf, int index)
0: 	{
1: 
0: 		int length = buf.length;
0: 		int writeLen =  buf.length;
1: 
0: 		writeShort(writeLen);
1: 
0: 		writeBytes(buf,0,writeLen);
0: 	}
1: 
1: 
0: 	/**
0: 	 * Write code point and 4 bytes
0: 	 *
0: 	 * @param 	codePoint - code point to write
0: 	 * @param	value  - value to write after code point
0: 	 */
0: 	void writeCodePoint4Bytes (int codePoint, int value)
0: 	{
1: 		ensureLength (4);
0: 		bytes[offset] = (byte) ((codePoint >>> 8) & 0xff);
0: 		bytes[offset + 1] = (byte) (codePoint & 0xff);
0: 		bytes[offset + 2] = (byte) ((value >>> 8) & 0xff);
0: 		bytes[offset + 3] = (byte) (value & 0xff);
0: 		offset += 4;
0: 	}
1: 
0: 	/**
0: 	 * Write scalar 1 byte object includes length, codepoint and value
0: 	 *
0: 	 * @param 	codePoint - code point to write
0: 	 * @param	value  - value to write after code point
0: 	 */
0: 	void writeScalar1Byte (int codePoint, int value)
0: 	{
0: 		ensureLength (5);
0: 		bytes[offset] = 0x00;
0: 		bytes[offset + 1] = 0x05;
0: 		bytes[offset + 2] = (byte) ((codePoint >>> 8) & 0xff);
0: 		bytes[offset + 3] = (byte) (codePoint & 0xff);
0: 		bytes[offset + 4] = (byte) (value & 0xff);
0: 		offset += 5;
0: 	}
1: 
0: 	/**
0: 	 * Write scalar 2 byte object includes length, codepoint and value
0: 	 *
0: 	 * @param 	codePoint - code point to write
0: 	 * @param	value  - value to write after code point
0: 	 */
0: 	protected void writeScalar2Bytes (int codePoint, int value)
0: 	{
0: 		ensureLength (6);
0: 		bytes[offset] = 0x00;
0: 		bytes[offset + 1] = 0x06;
0: 		bytes[offset + 2] = (byte) ((codePoint >>> 8) & 0xff);
0: 		bytes[offset + 3] = (byte) (codePoint & 0xff);
0: 		bytes[offset + 4] = (byte) ((value >>> 8) & 0xff);
0: 		bytes[offset + 5] = (byte) (value & 0xff);
0: 		offset += 6;
0: 	}
1: 
0: 	protected void writeScalar2Bytes ( int value)
0: 	{
0: 		ensureLength (2);
0: 		bytes[offset] = (byte) ((value >>> 8) & 0xff);
0: 		bytes[offset + 1] = (byte) (value & 0xff);
0: 		offset += 2;
0: 	}
1: 
0: 	/**
0: 	 * Write length and codepoint
0: 	 *
0: 	 * @param 	length - length of object
0: 	 * @param 	codePoint - code point to write
0: 	 */
0: 	protected void startDdm (int length, int codePoint)
0: 	{
1: 		ensureLength (4);
0: 		bytes[offset] = (byte) ((length >>> 8) & 0xff);
0: 		bytes[offset + 1] = (byte) (length & 0xff);
0: 		bytes[offset + 2] = (byte) ((codePoint >>> 8) & 0xff);
0: 		bytes[offset + 3] = (byte) (codePoint & 0xff);
0: 		offset += 4;
0: 	}
1: 
0: 	/**
0: 	 * Write scalar byte array object includes length, codepoint and value
0: 	 *
0: 	 * @param 	codePoint - code point to write
0: 	 * @param	buf  - value to write after code point
0: 	 * @param	length - number of bytes to write
0: 	 */
0: 	protected void writeScalarBytes (int codePoint, byte[] buf, int length)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (buf == null && length > 0)
0: 		    	SanityManager.THROWASSERT("Buf is null");
0: 			if (length > buf.length)
0: 		    	SanityManager.THROWASSERT("Not enough bytes in buffer");
0: 		}
0: 		ensureLength (length + 4);
0: 		bytes[offset] = (byte) (((length+4) >>> 8) & 0xff);
0: 		bytes[offset + 1] = (byte) ((length+4) & 0xff);
0: 		bytes[offset + 2] = (byte) ((codePoint >>> 8) & 0xff);
0: 		bytes[offset + 3] = (byte) (codePoint & 0xff);
0: 		System.arraycopy(buf,0,bytes,offset + 4, length);
0: 		offset += length + 4;
0: 	}
1: 
1: 
0: 	protected int  writeScalarStream (boolean chained,
0: 									  boolean chainedWithSameCorrelator,
1: 									  int codePoint,
0: 									  int length,
0: 									  java.io.InputStream in,
0: 									  boolean writeNullByte) 
0: 		throws DRDAProtocolException
0: 	{
0: 		int leftToRead = length;
0: 		int bytesToRead = prepScalarStream (chained,
0: 											chainedWithSameCorrelator,
0: 											codePoint,
0: 											writeNullByte,
0: 											leftToRead);
1: 		
0: 		if (length == 0)
0: 			return 0;
1: 
0: 		// write the data
0: 		int bytesRead = 0;
0: 		int totalBytesRead = 0;
0: 		do {
0: 			do {
0: 				try {
0: 					bytesRead = in.read (bytes, offset, bytesToRead);
0: 					totalBytesRead += bytesRead;
0: 				}
1: 				catch (java.io.IOException e) {
0: 					padScalarStreamForError (leftToRead, bytesToRead);
0: 					return totalBytesRead;
0: 				}
0: 				if (bytesRead == -1) {
0: 					padScalarStreamForError (leftToRead, bytesToRead);
0: 					return totalBytesRead;
0: 				}
0: 				else {
0: 					bytesToRead -= bytesRead;
0: 					offset += bytesRead;
0: 					leftToRead -= bytesRead;
0: 				}
0: 			} while (bytesToRead > 0);
1: 			
0: 			bytesToRead = flushScalarStreamSegment (leftToRead, bytesToRead);
0: 		} while (leftToRead > 0);
1: 		
0: 		// check to make sure that the specified length wasn't too small
0: 		try {
0: 			if (in.read() != -1) {
0: 				totalBytesRead += 1;
0: 			}
0: 		}
1: 		catch (java.io.IOException e) {
0: 			// Encountered error in stream length verification for 
0: 			// InputStream, parameter #" + parameterIndex + ".  
0: 			// Don't think we need to error for this condition
0: 		}
0: 		return totalBytesRead;
0: 	}
1: 	
1: 	
0: 	private void beginDss (boolean dssHasSameCorrelator,
0: 						   boolean chainedToNextStructure,
0: 						   boolean nextHasSameCorrelator,
0: 						   int dssType,
0: 						   int corrId,
0: 						   boolean simpleFinalizeBuildingNextDss)
0:   {
0: 	  if (doesRequestContainData()) {
0: 		  if (simpleDssFinalize)
0: 		  {
0: 			  finalizeDssLength();
1: 
0: 		  }
0: 		  else
0: 			  finalizePreviousChainedDss (dssHasSameCorrelator);
0: 	  }
1: 
0: 	  ensureLength (6);
1: 
0: 	  // save the length position and skip
0: 	  // note: the length position is saved so it can be updated
0: 	  // with a different value later.
0: 	  dssLengthLocation = offset;
0: 	  // always turn on chaining flags... this is helpful for lobs...
0: 	  // these bytes will get rest if dss lengths are finalized.
0: 	  bytes[offset] = (byte) 0xFF;
0: 	  bytes[offset + 1] = (byte) 0xFF;
1: 
0: 	  // insert the manditory 0xD0 and the dssType
0: 	  bytes[offset + 2] = (byte) 0xD0;
1: 
0:     if (chainedToNextStructure) {
0:       dssType |= DssConstants.GDSCHAIN;
0:       if (nextHasSameCorrelator)
0:         dssType |= DssConstants.GDSCHAIN_SAME_ID;
0:     }
0:     bytes[offset + 3] = (byte) (dssType & 0xff);
1: 
0:     // write the request correlation id
0:     // use method that writes a short !!!
0:     bytes[offset + 4] = (byte) ((corrId >>> 8) & 0xff);
0:     bytes[offset + 5] = (byte) (corrId & 0xff);
0: 	offset +=6;
0:     simpleDssFinalize = simpleFinalizeBuildingNextDss;
0:   }
1: 
1: 
0:   // prepScalarStream does the following prep for writing stream data:
0:   // 1.  Flushes an existing DSS segment, if necessary
0:   // 2.  Determines if extended length bytes are needed
0:   // 3.  Creates a new DSS/DDM header and a null byte indicator, if applicable
0:   protected int prepScalarStream  (boolean chained,
0:                                    boolean chainedWithSameCorrelator,
1:                                    int codePoint,
0:                                    boolean writeNullByte,
0:                                    int leftToRead) throws DRDAProtocolException
0:   {
0:     int extendedLengthByteCount;
1: 
0:     int nullIndicatorSize = 0;
1:     if (writeNullByte) 
0: 		nullIndicatorSize = 1;
0: 	extendedLengthByteCount = calculateExtendedLengthByteCount (leftToRead + 4 + nullIndicatorSize);
1: 
0:     // flush the existing DSS segment if this stream will not fit in the send buffer
0:     if (10 + extendedLengthByteCount + nullIndicatorSize + leftToRead + offset > DssConstants.MAX_DSS_LENGTH) {
0:       try {
0:         if (simpleDssFinalize)
0:           finalizeDssLength();
0:         else
0:           finalizePreviousChainedDss (true);
1:         sendBytes(agent.getOutputStream());
0:       }
1:       catch (java.io.IOException e) {
1:          agent.markCommunicationsFailure ("DDMWriter.writeScalarStream()",
0:                                               "OutputStream.flush()",
0:                                               e.getMessage(),"*");
0:       }
0:     }
1: 
1:     // buildStreamDss should not call ensure length.
0:     beginDss (true,
0: 			  chained,
0: 			  chainedWithSameCorrelator,
0: 			  DssConstants.GDSFMT_OBJDSS,
0: 			  correlationID,
0: 			  true);
1: 
0:     if (extendedLengthByteCount > 0) {
0:       // method should never ensure length
0:       writeLengthCodePoint (0x8004 + extendedLengthByteCount, codePoint);
1: 
1:       if (writeNullByte)
0:         writeExtendedLengthBytes (extendedLengthByteCount, leftToRead + 1);
0:       else
0:         writeExtendedLengthBytes (extendedLengthByteCount, leftToRead);
0:     }
0:     else {
1:       if (writeNullByte)
0:         writeLengthCodePoint (leftToRead + 4 + 1, codePoint);
0:       else
0:         writeLengthCodePoint (leftToRead + 4, codePoint);
0:     }
1: 
1:     // write the null byte, if necessary
1:     if (writeNullByte)
1:       writeByte(0x0);
1: 
0:     int bytesToRead;
1: 
1:     if (writeNullByte)
0:       bytesToRead = Math.min (leftToRead, DssConstants.MAX_DSS_LENGTH - 6 - 4 - 1 - extendedLengthByteCount);
0:     else
0:       bytesToRead = Math.min (leftToRead, DssConstants.MAX_DSS_LENGTH - 6 - 4 - extendedLengthByteCount);
1: 
0:     return bytesToRead;
0:   }
1: 
1: 
1:   // method to determine if any data is in the request.
1:   // this indicates there is a dss object already in the buffer.
0: 	protected boolean doesRequestContainData()
0: 	{
0: 		return offset != 0;
0: 	}
1: 
1: 
0: 	// Writes out a scalar stream DSS segment, along with DSS continuation
0: 	// headers if necessary.
0: 	protected int flushScalarStreamSegment (int leftToRead,
0: 											int bytesToRead)
0: 		throws DRDAProtocolException
0:   {
0: 	  int newBytesToRead = bytesToRead;
1: 
0: 	  // either at end of data, end of dss segment, or both.
0: 	  if (leftToRead != 0) {
0: 		  // 32k segment filled and not at end of data.
0: 		  if ((Math.min (2 + leftToRead, 32767)) > (bytes.length - offset)) {
0:         try {
0:           sendBytes (agent.getOutputStream());
0:         }
0:         catch (java.io.IOException ioe) {
0: 			agent.markCommunicationsFailure ("DDMWriter.flushScalarStreamSegment()",
1:                                                "",
1:                                                ioe.getMessage(),
1:                                                "*");
0:         }
0:       }
0:       dssLengthLocation = offset;
0:       bytes[offset++] = (byte) (0xff);
0:       bytes[offset++] = (byte) (0xff);
0:       newBytesToRead = Math.min (leftToRead,32765);
0:     }
1: 
0:     return newBytesToRead;
0:   }
1: 
0:   // the offset must not be updated when an error is encountered
0:   // note valid data may be overwritten
0:   protected void padScalarStreamForError (int leftToRead, int bytesToRead) throws DRDAProtocolException
0:   {
0:     do {
0:       do {
0:         bytes[offset++] = (byte)(0x0); // use 0x0 as the padding byte
0:         bytesToRead--;
0:         leftToRead--;
0:       } while (bytesToRead > 0);
1: 
0:       bytesToRead = flushScalarStreamSegment (leftToRead, bytesToRead);
0:     } while(leftToRead > 0);
0:   }
1: 
1: 
1: 
0: 	private void writeExtendedLengthBytes (int extendedLengthByteCount, long length)
0: 	{
0: 	int shiftSize = (extendedLengthByteCount -1) * 8;
0:     for (int i = 0; i < extendedLengthByteCount; i++) {
0:       bytes[offset + i] = (byte) ((length >>> shiftSize) & 0xff);
0:       shiftSize -= 8;
0:     }
0: 	offset += extendedLengthByteCount;
0:   }
1: 
1: 
1:   // insert a 4 byte length/codepoint pair into the buffer.
1:   // total of 4 bytes inserted in buffer.
1:   // Note: the length value inserted in the buffer is the same as the value
1:   // passed in as an argument (this value is NOT incremented by 4 before being
1:   // inserted).
1:   void writeLengthCodePoint (int length, int codePoint)
0:   {
1:     ensureLength (4);
0:     bytes[offset] = (byte) ((length >>> 8) & 0xff);
0:     bytes[offset + 1] = (byte) (length & 0xff);
0:     bytes[offset + 2] = (byte) ((codePoint >>> 8) & 0xff);
0:     bytes[offset + 3] = (byte) (codePoint & 0xff);
0: 	offset +=4;
0:   }
1: 
0: 	/**
0: 	 * Write scalar object header includes length and codepoint
0: 	 *
0: 	 * @param 	codePoint - code point to write
0: 	 * @param	dataLength - length of object data
0: 	 * @param	length - number of bytes to write
0: 	 */
0: 	protected void writeScalarHeader (int codePoint, int dataLength)
0: 	{
0: 		ensureLength (dataLength + 4);
0: 		bytes[offset] = (byte) (((dataLength+4) >>> 8) & 0xff);
0: 		bytes[offset + 1] = (byte) ((dataLength+4) & 0xff);
0: 		bytes[offset + 2] = (byte) ((codePoint >>> 8) & 0xff);
0: 		bytes[offset + 3] = (byte) (codePoint & 0xff);
0: 		offset += 4;
0: 	}
1: 
0: 	/**
0: 	 * Write scalar string object includes length, codepoint and value
0: 	 * the string is converted into the appropriate codeset (EBCDIC)
0: 	 *
0: 	 * @param 	codePoint - code point to write
0: 	 * @param	string - string to be written
0: 	 */
0: 	void writeScalarString (int codePoint, String string)
0: 	{
0: 		int stringLength = string.length();
0: 		ensureLength ((stringLength * 2)  + 4);
0: 		bytes[offset] = (byte) (((stringLength+4) >>> 8) & 0xff);
0: 		bytes[offset + 1] = (byte) ((stringLength+4) & 0xff);
0: 		bytes[offset + 2] = (byte) ((codePoint >>> 8) & 0xff);
0: 		bytes[offset + 3] = (byte) (codePoint & 0xff);
0: 		offset = ccsidManager.convertFromUCS2 (string, bytes, offset + 4);
0: 	}
1: 
0: 	/**
0: 	 * Write padded scalar string object includes length, codepoint and value
0: 	 * the string is converted into the appropriate codeset (EBCDIC)
0: 	 *
0: 	 * @param 	codePoint - code point to write
0: 	 * @param	string - string to be written
0: 	 * @param 	paddedLength - length to pad string to
0: 	 */
0: 	void writeScalarPaddedString (int codePoint, String string, int paddedLength)
0: 	{
0: 		int stringLength = string.length();
0: 		int fillLength = paddedLength - stringLength;
0: 		ensureLength (paddedLength + 4);
0: 		bytes[offset] = (byte) (((paddedLength+4) >>> 8) & 0xff);
0: 		bytes[offset + 1] = (byte) ((paddedLength+4) & 0xff);
0: 		bytes[offset + 2] = (byte) ((codePoint >>> 8) & 0xff);
0: 		bytes[offset + 3] = (byte) (codePoint & 0xff);
0: 		offset = ccsidManager.convertFromUCS2 (string, bytes, offset + 4);
0: 		Arrays.fill(bytes,offset, offset + fillLength,ccsidManager.space);
0: 		offset += fillLength;
0: 	}
1: 
0: 	/**
0: 	 * Write padded scalar string object value
0: 	 * the string is converted into the appropriate codeset (EBCDIC)
0: 	 *
0: 	 * @param	string - string to be written
0: 	 * @param 	paddedLength - length to pad string to
0: 	 */
0: 	protected void writeScalarPaddedString (String string, int paddedLength)
0: 	{
0: 		int stringLength = string.length();
1: 
0: 		int fillLength = paddedLength -stringLength;
0: 		ensureLength (paddedLength);
0: 		offset = ccsidManager.convertFromUCS2 (string, bytes, offset);
0: 		Arrays.fill(bytes,offset, offset + fillLength,ccsidManager.space);
0: 		offset += fillLength;
0: 	}
1: 
0: 	/**
0: 	 * Write padded scalar byte array object includes length, codepoint and value
0: 	 *
0: 	 * @param 	codePoint - code point to write
0: 	 * @param	buf - byte array to be written
0: 	 * @param 	paddedLength - length to pad string to
0: 	 * @param	padByte - byte to be used for padding
0: 	 */
0: 	protected void writeScalarPaddedBytes (int codePoint, byte[] buf, int paddedLength, byte padByte)
0: 	{
0: 		int bufLength = buf.length;
0: 		ensureLength (paddedLength + 4);
0: 		bytes[offset] = (byte) (((paddedLength+4) >>> 8) & 0xff);
0: 		bytes[offset + 1] = (byte) ((paddedLength+4) & 0xff);
0: 		bytes[offset + 2] = (byte) ((codePoint >>> 8) & 0xff);
0: 		bytes[offset + 3] = (byte) (codePoint & 0xff);
0: 		offset += 4;
0: 		System.arraycopy(buf,0,bytes,offset,bufLength);
0: 		offset += bufLength;
0: 		int fillLength = paddedLength - bufLength;
0: 		Arrays.fill(bytes,offset,offset + fillLength,padByte);
0: 		offset += fillLength;
0: 	}
1: 
0: 	/**
0: 	 * Write padded scalar byte array object  value
0: 	 *
0: 	 * @param	buf - byte array to be written
0: 	 * @param 	paddedLength - length to pad string to
0: 	 * @param	padByte - byte to be used for padding
0: 	 */
0: 	protected void writeScalarPaddedBytes (byte[] buf, int paddedLength, byte padByte)
0: 	{
0: 		int bufLength = buf.length;
0: 		int fillLength = paddedLength - bufLength;
0: 		ensureLength (paddedLength);
0: 		System.arraycopy(buf,0,bytes,offset,bufLength);
0: 		offset +=bufLength;
0: 		Arrays.fill(bytes,offset,offset + fillLength,padByte);
0: 		offset += fillLength;
0: 	}
1: 
0: 	/**
0: 	 * Write scalar byte array object includes length, codepoint and value
0: 	 *
0: 	 * @param 	codePoint - code point to write
0: 	 * @param	buf - byte array to be written
0: 	 */
0: 	protected void writeScalarBytes (int codePoint, byte[] buf)
0: 	{
0: 		int bufLength = buf.length;
0: 		ensureLength (bufLength + 4);
0: 		bytes[offset] = (byte) (((bufLength+4) >>> 8) & 0xff);
0: 		bytes[offset + 1] = (byte) ((bufLength+4) & 0xff);
0: 		bytes[offset + 2] = (byte) ((codePoint >>> 8) & 0xff);
0: 		bytes[offset + 3] = (byte) (codePoint & 0xff);
0: 		System.arraycopy(buf,0,bytes,offset + 4,bufLength);
0: 		offset += bufLength + 4;
0: 	}
1: 
0: 	/**
0: 	 * Write scalar byte array object includes length, codepoint and value
0: 	 *
0: 	 * @param 	codePoint - code point to write
0: 	 * @param	buf - byte array to be written
0: 	 * @param	start - starting point
0: 	 * @param 	length - length to write
0: 	 */
0: 	protected void writeScalarBytes (int codePoint, byte[] buf, int start, int length)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (buf == null && length > start)
0: 		    	SanityManager.THROWASSERT("Buf is null");
0: 			if (length - start > buf.length)
0: 				SanityManager.THROWASSERT("Not enough bytes in buffer");
0: 		}
0: 		int numBytes = length - start;
0: 		ensureLength (numBytes + 4);
0: 		bytes[offset] = (byte) (((numBytes+4) >>> 8) & 0xff);
0: 		bytes[offset + 1] = (byte) ((numBytes+4) & 0xff);
0: 		bytes[offset + 2] = (byte) ((codePoint >>> 8) & 0xff);
0: 		bytes[offset + 3] = (byte) (codePoint & 0xff);
0: 		offset += 4;
0: 		System.arraycopy(buf,start,bytes,offset,numBytes);
0: 		offset += numBytes;
0: 	}
0: 	// The following methods write data in the platform format
0: 	// The platform format was indicated during connection time as ASC since
0: 	// JCC doesn't read JVM platform (yet)
1: 
0: 	/**
0: 	 * Write platform short
0: 	 *
0: 	 * @param 	v	value to be written
0: 	 */
0: 	protected void writeShort (int v)
0: 	{
0: 		writeNetworkShort(v);
0: 	}
1: 
0: 	/**
0: 	 * Write boolean as short
0: 	 * @param b boolean value true = 1 false = 0
0: 	 *
0: 	 */
0: 	protected void writeShort(boolean b)
0: 	{
0: 		writeNetworkShort(b ? 1 : 0);
0: 	}
1: 
0: 	/**
0: 	 * Write platform int
0: 	 *
0: 	 * @param 	v	value to be written
0: 	 */
0: 	protected void writeInt (int v)
0: 	{
0: 		writeNetworkInt(v);
0: 	}
1: 
0: 	/**
0: 	 * Write platform long
0: 	 *
0: 	 * @param 	v	value to be written
0: 	 */
0: 	protected void writeLong (long v)
0: 	{
0: 		ensureLength (8);
0: 		bytes[offset] =	(byte) ((v >>> 56) & 0xff);
0: 		bytes[offset + 1] =	(byte) ((v >>> 48) & 0xff);
0: 		bytes[offset + 2] =	(byte) ((v >>> 40) & 0xff);
0: 		bytes[offset + 3] =	(byte) ((v >>> 32) & 0xff);
0: 		bytes[offset + 4] =	(byte) ((v >>> 24) & 0xff);
0: 		bytes[offset + 5] =	(byte) ((v >>> 16) & 0xff);
0: 		bytes[offset + 6] =	(byte) ((v >>>  8) & 0xff);
0: 		bytes[offset + 7] =	(byte) ((v >>>  0) & 0xff);
0: 		offset += 8;
0: 	}
1: 
0: 	/**
0: 	 * Write platform float
0: 	 *
0: 	 * @param 	v	value to be written
0: 	 */
0: 	protected void writeFloat (float v)
0: 	{
0: 		writeInt (Float.floatToIntBits (v));
0: 	}
1: 
0: 	/**
0: 	 * Write platform double
0: 	 *
0: 	 * @param 	v	value to be written
0: 	 */
0: 	protected void writeDouble (double v)
0: 	{
0: 		writeLong (Double.doubleToLongBits (v));
0: 	}
1: 
0: 	/**
0: 	 * Write big decimal to buffer
0: 	 *
0: 	 * @param v value to write
0: 	 * @param precision Precison of decimal or numeric type
0: 	 * @param declared scale
0: 	 * @exception SQLException thrown if number of digits > 31
0: 	 */
0: 	protected void writeBigDecimal (java.math.BigDecimal v, int precision, int scale)
0: 		throws SQLException
0: 	{
0: 		int length = precision / 2 + 1;
0: 		ensureLength (offset + length);
0: 		bigDecimalToPackedDecimalBytes (v,precision, scale);
0: 		offset += length;
0: 	}
1: 
0: 	/**
0: 	 * Write platform boolean
0: 	 *
0: 	 * @param 	v	value to be written
0: 	 */
0: 	protected void writeBoolean (boolean v)
0: 	{
0: 		ensureLength (1);
0: 		bytes[offset++] = (byte) ((v ? 1 : 0) & 0xff);
0: 	}
1: 
0: 	/**
0: 	 * Write length delimited string
0: 	 *
0: 	 * @param s value to be written with integer
0: 	 *
0: 	 * @exception DRDAProtocolException
0: 	 */
0: 	protected void writeLDString(String s) throws DRDAProtocolException
0: 	{
0: 		writeLDString(s,0);
0: 	}
1: 
1: 
0: 	/**
0: 	 * Write length delimited string
0: 	 *
0: 	 * @param s              value to be written with integer
0: 	 * @param index          column index to put in warning
0: 	 * @exception DRDAProtocolException
0: 	 */
0: 	protected void writeLDString(String s, int index) throws DRDAProtocolException
0: 	{
0: 		try {
0: 			byte [] byteval = s.getBytes(DB2jServerImpl.DEFAULT_ENCODING);
0: 			int origLen = byteval.length;
0: 			boolean multiByteTrunc = false;
0: 			int writeLen =
0: 				java.lang.Math.min(FdocaConstants.LONGVARCHAR_MAX_LEN,
0: 								   origLen);
1: 			/*
0: 			Need to make sure we truncate on character boundaries.
0: 			We are assuming
0: 			http://www.sun.com/developers/gadc/technicalpublications/articles/utf8.html
0: 			To find the beginning of a multibyte character:
0: 			1) Does the current byte start with the bit pattern 10xxxxxx?
0: 			2) If yes, move left and go to step #1.
0: 			3) Finished
0: 			We assume that DB2jServerImpl.DEFAULT_ENCODING remains UTF-8
0: 			*/
1: 
0: 			if (SanityManager.DEBUG)
0: 			{
0: 				if (!(DB2jServerImpl.DEFAULT_ENCODING.equals("UTF8")))
0: 					SanityManager.THROWASSERT("Encoding assumed to be UTF8, but is actually" + DB2jServerImpl.DEFAULT_ENCODING);
0: 			}
1: 
0: 			if (writeLen != origLen)
0: 				// first position on the first byte of the multibyte char
0: 				while ((byteval[writeLen -1] & 0xC0) == 0x80)
0: 				{
0: 					multiByteTrunc = true;
0: 					writeLen--;
0: 					// Then subtract one more to get to the end of the
0: 					// previous character
0: 					if (multiByteTrunc == true)
0: 					{
0: 						writeLen = writeLen -1;
0: 					}
0: 				}
1: 
0: 			writeShort(writeLen);
0: 			writeBytes(byteval,writeLen);
0: 		}
0: 		catch (Exception e) {
0: 			//this should never happen
0: 			agent.agentError("Encoding " + DB2jServerImpl.DEFAULT_ENCODING + " not supported");
0: 		}
0: 	}
1: 
0: 	/**
0: 	 * Write string with default encoding
0: 	 *
0: 	 * @param s value to be written
0: 	 *
0: 	 * @exception DRDAProtocolException
0: 	 */
0: 	protected void writeString(String s) throws DRDAProtocolException
0: 	{
0: 		try {
0: 			writeBytes(s.getBytes(DB2jServerImpl.DEFAULT_ENCODING));
0: 		} catch (Exception e) {
0: 			//this should never happen
0: 			agent.agentError("Encoding " + DB2jServerImpl.DEFAULT_ENCODING + " not supported");
0: 		}
0: 	}
1: 
0: 	/**
0: 	 * Write string with default encoding and specified length
0: 	 *
0: 	 * @param s value to be written
0: 	 * @param length number of bytes to be written
0: 	 *
0: 	 * @exception DRDAProtocolException
0: 	 */
0: 	protected void writeString(String s, int length) throws DRDAProtocolException
0: 	{
0: 		byte[] bs = null;
0: 		try {
0: 			bs = s.getBytes(DB2jServerImpl.DEFAULT_ENCODING);
0: 		} catch (Exception e) {
0: 			//this should never happen
0: 			agent.agentError("Encoding " + DB2jServerImpl.DEFAULT_ENCODING + " not supported");
0: 		}
0: 		int len = bs.length;
0: 		if (len >= length)
0: 			writeBytes(bs, length);
0: 		else
0: 		{
0: 			writeBytes(bs);
0: 			padBytes(DB2jServerImpl.SPACE_CHAR, length-len);
0: 		}
0: 	}
1: 
0: 	/**
0: 	 * Write pad bytes using spaceChar
0: 	 *
0: 	 * @param   val	value to be written
0: 	 * @param	length		length to be written
0: 	 */
0: 	protected void padBytes (byte val, int length)
0: 	{
0: 		Arrays.fill(bytes,offset, offset + length,val);
0: 		offset += length;
0: 	}
1: 
0: 	/**
0: 	 * Flush buffer to outputstream
0: 	 *
0: 	 *
0: 	 * @exception IOException
0: 	 */
0: 	protected void flush () throws java.io.IOException
0: 	{
0: 		OutputStream socketOutputStream = agent.getOutputStream();
0: 		try {
0: 			if (isDRDAProtocol)
0: 			{
0: 				finalizeDssLength();
0: 			}
0: 			socketOutputStream.write (bytes, 0, offset);
0: 			socketOutputStream.flush();
0: 		}
1: 		finally {
0: 			if ((dssTrace != null) && dssTrace.isComBufferTraceOn()) {
0: 			  dssTrace.writeComBufferData (bytes,
0: 			                               0,
0: 			                               offset,
0: 			                               DssTrace.TYPE_TRACE_SEND,
0: 			                               "Reply",
0: 			                               "flush",
0: 			                               5);
0: 			}
0: 			reset(dssTrace);
0: 		}
0: 	}
0: 	/**
0: 	 * Flush buffer to specified stream
0: 	 *
0: 	 * @param socketOutputStream
0: 	 *
0: 	 * @exception IOException
0: 	 */
0: 	protected void flush(OutputStream os) throws java.io.IOException
0: 	{
0: 		os.write(bytes, 0, offset);
0: 		os.flush();
0: 	}
1: 
0: 	// private methods
1: 
0: 	/**
0: 	 * Write DSS header
0: 	 * DSS Header format is
0: 	 * 	2 bytes	- length
0: 	 *	1 byte	- 'D0'	- indicates DDM data
0: 	 * 	1 byte	- DSS format
0: 	 *		|---|---------|----------|
0: 	 *		| 0	|	flags |	type     |
0: 	 *		|---|---------|----------|
0: 	 *		| 0 | 1	2	3 | 4 5 6 7	 |
0: 	 *		|---|---------|----------|
0: 	 *		bit 0 - '0'
0: 	 *		bit 1 - '0' - unchained, '1' - chained
0: 	 *		bit 2 - '0'	- do not continue on error, '1' - continue on error
0: 	 *		bit 3 - '0' - next DSS has different correlator, '1' - next DSS has
0: 	 *						same correlator
0: 	 *		type - 1 - Request DSS
0: 	 *			 - 2 - Reply DSS
0: 	 *			 - 3 - Object DSS
0: 	 *			 - 4 - Communications DSS
0: 	 *			 - 5 - Request DSS where no reply is expected
0: 	 */
0: 	private void beginDss (int dssType, int corrID)
0: 	{
0: 		// save correlationID for use in error messages while processing
0: 		// this DSS
0: 		correlationID = corrID;
0: 		// save length position, the length will be written at the end
0: 		dssLengthLocation = offset;
1: 
0: 		ensureLength(6);
0: 		offset += 2;
1: 
0: 		// write gds info
0: 		bytes[offset] = (byte) 0xD0;
0: 		bytes[offset + 1] = (byte) dssType;
1: 
0: 		// write the request correlation id
0: 		bytes[offset + 2] = (byte) ((corrID >>> 8) & 0xff);
0: 		bytes[offset + 3] = (byte) (corrID & 0xff);
0: 		offset += 4;
0: 	}
1: 
0: 	/**
0: 	 * finish the DSS in the buffer by updating the length and chaining bits
0: 	 *
0: 	 * @param nextDssHasSameCorrelator - how to set chaining bits
0: 	 */
0:   	private void finalizePreviousChainedDss (boolean nextDssHasSameCorrelator)
0: 	{
0: 		finalizeDssLength();
0: 		bytes[dssLengthLocation + 3] |= 0x40;
0: 		if (nextDssHasSameCorrelator)
0: 			bytes[dssLengthLocation + 3] |= 0x10;
1: 		
0: 	}
0: 	/**
1:      * Finish a DSS Layer A object.
0: 	 * The length of dss object will be calculated based on the difference between the
0: 	 * start of the dss, saved on the beginDss call, and the current
0: 	 * offset into the buffer which marks the end of the data.	In the event
0: 	 * the length requires the use of continuation Dss headers, one for each 32k
0: 	 * chunk of data, the data will be shifted and the continuation headers
0: 	 * will be inserted with the correct values as needed.
0: 	 */
0: 	private void finalizeDssLength ()
0: 	{
0: 		// calculate the total size of the dss and the number of bytes which would
0: 		// require continuation dss headers.	The total length already includes the
0: 		// the 6 byte dss header located at the beginning of the dss.	It does not
0: 		// include the length of any continuation headers.
0: 		int totalSize = offset - dssLengthLocation;
0: 		int bytesRequiringContDssHeader = totalSize - DssConstants.MAX_DSS_LENGTH;
1: 
0: 		// determine if continuation headers are needed
0: 		if (bytesRequiringContDssHeader > 0)
0: 		{
0: 			// the continuation headers are needed, so calculate how many.
0: 			// after the first 32767 worth of data, a continuation header is
0: 			// needed for every 32765 bytes (32765 bytes of data + 2 bytes of
0: 			// continuation header = 32767 Dss Max Size).
0: 			int contDssHeaderCount = bytesRequiringContDssHeader / 32765;
0: 			if (bytesRequiringContDssHeader % 32765 != 0)
0: 				contDssHeaderCount++;
1: 
0: 			// right now the code will shift to the right.	In the future we may want
0: 			// to try something fancier to help reduce the copying (maybe keep
0: 			// space in the beginning of the buffer??).
0: 			// the offset points to the next available offset in the buffer to place
0: 			// a piece of data, so the last dataByte is at offset -1.
0: 			// various bytes will need to be shifted by different amounts
0: 			// depending on how many dss headers to insert so the amount to shift
0: 			// will be calculated and adjusted as needed.	ensure there is enough room
0: 			// for all the conutinuation headers and adjust the offset to point to the
0: 			// new end of the data.
0: 			int dataByte = offset - 1;
0: 			int shiftSize = contDssHeaderCount * 2;
0: 			ensureLength (shiftSize);
0: 			offset += shiftSize;
1: 
0: 			// mark passOne to help with calculating the length of the final (first or
0: 			// rightmost) continuation header.
0: 			boolean passOne = true;
0: 			do {
0: 				// calculate chunk of data to shift
0: 				int dataToShift = bytesRequiringContDssHeader % 32765;
0: 				if (dataToShift == 0)
0: 					dataToShift = 32765;
0: 				// We start with the right most chunk. If we had to copy two
0: 				// chunks we would shift the first one 4 bytes and then 
0: 				// the second one
0: 				// 2 when we come back on the next loop so they would each have
0: 				// 2 bytes for the continuation header
0: 				int startOfCopyData = dataByte - dataToShift;
0: 				System.arraycopy(bytes,startOfCopyData, bytes, 
0: 								 startOfCopyData + shiftSize, dataToShift);
0: 				dataByte -= dataToShift;
1: 
1: 
0: 				// calculate the value the value of the 2 byte continuation dss
0: 				// header which includes the length of itself.  On the first pass,
0: 				// if the length is 32767
0: 				// we do not want to set the continuation dss header flag.
0: 				int twoByteContDssHeader = dataToShift + 2;
0: 				if (passOne)
0: 					passOne = false;
0: 				else
0: 				{
0: 					if (twoByteContDssHeader == DssConstants.MAX_DSS_LENGTH)
0: 				    	twoByteContDssHeader = DssConstants.CONTINUATION_BIT;
0: 				}
1: 
0: 				// insert the header's length bytes
0: 				bytes[dataByte + shiftSize - 1] = (byte)
0: 					((twoByteContDssHeader >>> 8) & 0xff);
0: 				bytes[dataByte + shiftSize] = (byte)
0: 					(twoByteContDssHeader & 0xff);
1: 
0: 				// adjust the bytesRequiringContDssHeader and the amount to shift for
0: 				// data in upstream headers.
0: 				bytesRequiringContDssHeader -= dataToShift;
0: 				shiftSize -= 2;
1: 
0: 				// shift and insert another header for more data.
0: 			}
0: 			while (bytesRequiringContDssHeader > 0);
1: 
0: 			// set the continuation dss header flag on for the first header
0: 			totalSize = DssConstants.CONTINUATION_BIT;
1: 
0: 		}
1: 
0: 		// insert the length bytes in the 6 byte dss header.
0: 		bytes[dssLengthLocation] = (byte) ((totalSize >>> 8) & 0xff);
0: 		bytes[dssLengthLocation + 1] = (byte) (totalSize & 0xff);
0: 	}
1: 
0: 	protected void writeExtendedLength(long size)
0: 	{
0: 		int numbytes = calculateExtendedLengthByteCount(size);
0: 		if (size > 0)
0: 			writeInt(0x8000 | numbytes);
0: 		else
0: 			writeInt(numbytes);
0: 	}
1: 
1: 
0: 	/**
0: 	 * Calculate extended length byte count which follows the DSS header
0: 	 * for extended DDM.
0: 	 *
0: 	 * @param ddmSize - size of DDM command
0: 	 * @return minimum number of extended length bytes needed. 0 indicates no
0: 	 * 	extended length needed.
0: 	 */
0: 	private int calculateExtendedLengthByteCount (long ddmSize)
0: 	{
0: 		if (ddmSize <= 0x7fff)
0: 			return 0;
0: 		// JCC does not support 2 at this time, so we always send
0: 		// at least 4
0: 		//		else if (ddmSize <= 0xffff)
0: 		//	return 2;
0: 		else if (ddmSize <= 0xffffffffL)
0: 			return 4;
0: 		else if (ddmSize <= 0xffffffffffffL)
0: 			return 6;
0: 		else if (ddmSize <= 0x7fffffffffffffffL)
0: 			return 8;
0: 		else
0: 			// shouldn't happen
0: 			// XXX - add sanity debug stuff here
0: 			return 0;
0: 	}
1: 
0: 	/**
0: 	 * Ensure that there is space in the buffer
0: 	 *
0: 	 * @param length space required
0: 	 */
0: 	private void ensureLength (int length)
0: 	{
0: 		length += offset;
0: 		if (length > bytes.length) {
0: 			if (SanityManager.DEBUG)
0: 			{
0: 				agent.trace("DANGER - Expensive expansion of  buffer");
0: 			}
0: 			byte newBytes[] = new byte[Math.max (bytes.length << 1, length)];
0: 			System.arraycopy (bytes, 0, newBytes, 0, offset);
0: 			bytes = newBytes;
0: 		}
0: 	}
1: 
1: 
0: 	/**
0: 	 * Write a Java <code>java.math.BigDecimal</code> to packed decimal bytes.
0: 	 *
0: 	 * @param b BigDecimal to write
0: 	 * @param precision Precision of decimal or numeric type
0: 	 * @return length written.
0: 	 *
0: 	 * @exception SQLException Thrown if # digits > 31
0: 	 */
0: 	private int bigDecimalToPackedDecimalBytes (java.math.BigDecimal b,
0: 												int precision, int scale)
0: 	throws SQLException
0: 	{
0: 		int declaredPrecision = precision;
0: 		int declaredScale = scale;
1: 
0: 		// packed decimal may only be up to 31 digits.
0: 		if (declaredPrecision > 31) // this is a bugcheck only !!!
0: 		{
0: 			clearDdm ();
0: 			throw new java.sql.SQLException ("Packed decimal may only be up to 31 digits!");
0: 		}
1: 
0: 		// get absolute unscaled value of the BigDecimal as a String.
0: 		String unscaledStr = b.unscaledValue().abs().toString();
1: 
0: 		// get precision of the BigDecimal.
0:   	    int bigPrecision = unscaledStr.length();
1: 
0: 		if (bigPrecision > 31)
0: 		{
0: 			clearDdm ();
0:   		    throw new SQLException ("The numeric literal \"" +
1:                              b.toString() +
1:                              "\" is not valid because its value is out of range.",
1:                              "42820",
1:                              -405);
0: 		}
0:     	int bigScale = b.scale();
0:   	    int bigWholeIntegerLength = bigPrecision - bigScale;
0: 	    if ( (bigWholeIntegerLength > 0) && (!unscaledStr.equals ("0")) ) {
1:             // if whole integer part exists, check if overflow.
1:             int declaredWholeIntegerLength = declaredPrecision - declaredScale;
1:             if (bigWholeIntegerLength > declaredWholeIntegerLength)
0: 			{
0: 				clearDdm ();
1:                 throw new SQLException ("Overflow occurred during numeric data type conversion of \"" +
1:                                        b.toString() +
1:                                        "\".",
1:                                        "22003",
1:                                        -413);
0: 			}
0:         }
1: 
1:         // convert the unscaled value to a packed decimal bytes.
1: 
1:         // get unicode '0' value.
1:         int zeroBase = '0';
1: 
1:         // start index in target packed decimal.
1:         int packedIndex = declaredPrecision-1;
1: 
1:         // start index in source big decimal.
1:         int bigIndex;
1: 
1:         if (bigScale >= declaredScale) {
1:           // If target scale is less than source scale,
1:           // discard excessive fraction.
1: 
1:           // set start index in source big decimal to ignore excessive fraction.
1:           bigIndex = bigPrecision-1-(bigScale-declaredScale);
1: 
0:           if (bigIndex < 0) {
0:             // all digits are discarded, so only process the sign nybble.
0:             bytes[offset+(packedIndex+1)/2] =
0:               (byte) ( (b.signum()>=0)?12:13 ); // sign nybble
0:           }
0:           else {
0:             // process the last nybble together with the sign nybble.
0:             bytes[offset+(packedIndex+1)/2] =
0:               (byte) ( ( (unscaledStr.charAt(bigIndex)-zeroBase) << 4 ) + // last nybble
0:                      ( (b.signum()>=0)?12:13 ) ); // sign nybble
0:           }
1:           packedIndex-=2;
1:           bigIndex-=2;
0:         }
0:         else {
1:           // If target scale is greater than source scale,
1:           // pad the fraction with zero.
1: 
1:           // set start index in source big decimal to pad fraction with zero.
1:           bigIndex = declaredScale-bigScale-1;
1: 
1:           // process the sign nybble.
0:           bytes[offset+(packedIndex+1)/2] =
0:             (byte) ( (b.signum()>=0)?12:13 ); // sign nybble
1: 
1:           for (packedIndex-=2, bigIndex-=2; bigIndex>=0; packedIndex-=2, bigIndex-=2)
0:             bytes[offset+(packedIndex+1)/2] = (byte) 0;
1: 
1:           if (bigIndex == -1) {
0:             bytes[offset+(packedIndex+1)/2] =
0:               (byte) ( (unscaledStr.charAt(bigPrecision-1)-zeroBase) << 4 ); // high nybble
1: 
1:             packedIndex-=2;
1:             bigIndex = bigPrecision-3;
0:           }
0:           else {
1:             bigIndex = bigPrecision-2;
0:           }
0:         }
1: 
1:         // process the rest.
1:         for (; bigIndex>=0; packedIndex-=2, bigIndex-=2) {
0:           bytes[offset+(packedIndex+1)/2] =
0:             (byte) ( ( (unscaledStr.charAt(bigIndex)-zeroBase) << 4 ) + // high nybble
0:                    ( unscaledStr.charAt(bigIndex+1)-zeroBase ) ); // low nybble
0:         }
1: 
1:         // process the first nybble when there is one left.
1:         if (bigIndex == -1) {
0:           bytes[offset+(packedIndex+1)/2] =
0:             (byte) (unscaledStr.charAt(0) - zeroBase);
1: 
1:           packedIndex-=2;
0:         }
1: 
1:         // pad zero in front of the big decimal if necessary.
1:         for (; packedIndex>=-1; packedIndex-=2)
0:           bytes[offset+(packedIndex+1)/2] = (byte) 0;
1: 
0:         return declaredPrecision/2 + 1;
0: 	}
1: 
1: 
0: 	/***
0: 	 * Prepend zeros to numeric string
0: 	 *
0: 	 * @param s string
0: 	 * @param precision - length of padded string
0:  	 *
0: 	 * @return zero padded string
0: 	 */
0: 	public static String zeroPadString(String s, int precision)
0: 	{
1: 
0: 		if (s == null)
0: 			return s;
1: 
0: 		int slen = s.length();
0: 		if (precision == slen)
0: 			return s;
0: 		else if (precision > slen)
0: 		{
0: 			char[] ca  = new char[precision - slen];
0: 			Arrays.fill(ca,0,precision - slen,'0');
0: 			return new String(ca) + s;
0: 		}
0: 		else
0: 		{
0: 			// Shouldn't happen but just in case 
0: 			// truncate
0: 			return s.substring(0,precision);
0: 		}
1: 
0: 	}
1: 
1: 
1: 
0:   private void sendBytes (java.io.OutputStream socketOutputStream) throws java.io.IOException
0:   {
0:     try {
0:       socketOutputStream.write (bytes, 0, offset);
0:       socketOutputStream.flush();
0:     }
1:     finally {
0: 		if ((dssTrace != null) && dssTrace.isComBufferTraceOn()) {
0: 			dssTrace.writeComBufferData (bytes,
0: 			                               0,
0: 			                               offset,
0: 			                               DssTrace.TYPE_TRACE_SEND,
0: 			                               "Reply",
0: 			                               "flush",
0: 			                               5);
0:       }
1:       clearBuffer();
0:     }
0:   }
1: 
1: 
0: private void buildStreamDssObject (boolean chainedToNextStructure,
0: 								   boolean nextHasSameCorrelator,
0: 								   int corrID)
0:   {
0: 	int dssType =   DssConstants.GDSFMT_OBJDSS;
0:     if (offset != 0) {
0:         finalizePreviousChainedDss (true);
0: 	}
1: 
0:     ensureLength (6);
1: 
0:     // save the length position and skip
0:     // note: the length position is saved so it can be updated
0:     // with a different value later.
0:     dssLengthLocation = offset;
0:     // always turn on chaining flags... this is helpful for lobs...
0:     // these bytes will get rest if dss lengths are finalized.
0:     bytes[offset] = (byte) 0xFF;
0:     bytes[offset + 1] = (byte) 0xFF;
1: 
0:     // insert the manditory 0xD0 and the dssType
0:     bytes[offset + 2] = (byte) 0xD0;
0:     if (chainedToNextStructure) {
0:       dssType |= DssConstants.GDSCHAIN;
0:       if (nextHasSameCorrelator)
0:         dssType |= DssConstants.GDSCHAIN_SAME_ID;
0:     }
0:     bytes[offset + 3] = (byte) (  dssType & 0xff);
1: 
0:     // write the request correlation id
0:     // use method that writes a short !!!
0:     bytes[offset + 4] = (byte) ((corrID >>> 8) & 0xff);
0:     bytes[offset + 5] = (byte) (corrID & 0xff);
0: 	offset += 6;
0: 	}
1: 
1: 
0: 	private static int min (int i, int j)
0: 	{
0: 		return (i < j) ? i : j;
0: 	}
1: 
0: 	protected String toDebugString(String indent)
0: 	{
0: 		String s = indent + "***** DDMWriter toDebugString ******\n";
0: 		int byteslen = 0;
0: 		if ( bytes != null)
0: 			byteslen = bytes.length;
0: 		s += indent + "byte array length  = " + bytes.length + "\n";
0: 		return s;
0: 	}
1: 
0: }
1: 
1: 
1: 
1: 
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:59e5225
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:f0b0870
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 	 * @param scale declared scale
author:Tomohito Nakayama
-------------------------------------------------------------------------------
commit:977561c
/////////////////////////////////////////////////////////////////////////
0:    Derby - Class org.apache.derby.impl.drda.DDMWriter
0:    Copyright 2001, 2004 The Apache Software Foundation or its licensors, as applicable.
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
0:       http://www.apache.org/licenses/LICENSE-2.0
0:    Unless required by applicable law or agreed to in writing, software
0:    distributed under the License is distributed on an "AS IS" BASIS,
0:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:    See the License for the specific language governing permissions and
0:    limitations under the License.
0:  */
/////////////////////////////////////////////////////////////////////////
0: 	The DDMWriter is used to write DRDA protocol.   The DRDA Protocol is
0: 	described in the DDMReader class.
0: 	For more details, see DRDA Volume 3 (Distributed Data Management(DDM)
0: 		Architecture (DDS definition)
0: class DDMWriter
0: {
0: 	// number of nesting levels for collections.  We need to mark the length
0: 	// location of the collection so that we can update it as we add more stuff
0: 	// to the collection
0: 	private final static int MAX_MARKS_NESTING = 10;
0: 	// Default buffer size
0: 	private final static int DEFAULT_BUFFER_SIZE = 32767;
0: 	static final BigDecimal ZERO = BigDecimal.valueOf(0L);
0: 	// output buffer
0: 	private byte[] bytes;
0: 	// offset into output buffer
0: 	private int offset;
0: 	// A saved mark in the stream is saved temporarily to revisit the location.
0: 	private int[] markStack = new int[MAX_MARKS_NESTING];
0: 	// top of the stack
0: 	private int top;
0: 	// CCSID manager for translation of strings in the protocol to EBCDIC
0: 	private CcsidManager ccsidManager;
0: 	// DRDA connection thread for this writer
0: 	private DRDAConnThread agent;
0: 	//	This Object tracks the location of the current
0: 	//	Dss header length bytes.	This is done so
0: 	//	the length bytes can be automatically
0: 	//	updated as information is added to this stream.
0: 	private int dssLengthLocation;
0: 	// Current correlation ID
0: 	private	int correlationID;
0: 	// Next correlation ID
0: 	private int nextCorrelationID;
0: 	// is this DRDA protocol or CMD protocol
0: 	private boolean isDRDAProtocol;
0: 	// trace object of the associated session
0: 	private DssTrace dssTrace;
0: 	// Location within the "bytes" array of the start of the header
0: 	// of the DSS most recently written to the buffer.
0: 	private int prevHdrLocation;
0: 	// Correlation id of the last DSS that was written to buffer.
0: 	private int previousCorrId;
0: 	// Chaining bit of the last DSS that was written to buffer.
0: 	private byte previousChainByte;
0: 	// Whether or not the current DSS is a continuation DSS.
0: 	private boolean isContinuationDss;
0: 	// In situations where we want to "mark" a buffer location so that
0: 	// we can "back-out" of a write to handle errors, this holds the
0: 	// location within the "bytes" array of the start of the header
0: 	// that immediately precedes the mark.
0: 	private int lastDSSBeforeMark;
0: 	// Constructors
0: 	DDMWriter (int minSize, CcsidManager ccsidManager, DRDAConnThread agent, DssTrace dssTrace)
0: 	{
0: 		this.bytes = new byte[minSize];
0: 		this.ccsidManager = ccsidManager;
0: 		this.agent = agent;
0: 		this.prevHdrLocation = -1;
0: 		this.previousCorrId = DssConstants.CORRELATION_ID_UNKNOWN;
0: 		this.previousChainByte = DssConstants.DSS_NOCHAIN;
0: 		this.isContinuationDss = false;
0: 		this.lastDSSBeforeMark = -1;
0: 		reset(dssTrace);
0: 	}
0: 	DDMWriter (CcsidManager ccsidManager, DRDAConnThread agent, DssTrace dssTrace)
0: 	{
0: 		this.bytes = new byte[DEFAULT_BUFFER_SIZE];
0: 		this.ccsidManager = ccsidManager;
0: 		this.agent = agent;
0: 		this.prevHdrLocation = -1;
0: 		this.previousCorrId = DssConstants.CORRELATION_ID_UNKNOWN;
0: 		this.previousChainByte = DssConstants.DSS_NOCHAIN;
0: 		this.isContinuationDss = false;
0: 		this.lastDSSBeforeMark = -1;
0: 		reset(dssTrace);
0: 	}
0: 	/**
0: 	 * reset values for sending next message
0: 	 *
0: 	 */
0: 	protected void reset(DssTrace dssTrace)
0: 	{
0: 		offset = 0;
0: 		top = 0;
0: 		dssLengthLocation = 0;
0: 		nextCorrelationID = 1;
0: 		correlationID = DssConstants.CORRELATION_ID_UNKNOWN;
0: 		isDRDAProtocol = true;
0: 		this.dssTrace = dssTrace;
0: 	}
0: 	/**
0: 	 * set protocol to CMD protocol
0: 	 */
0: 	protected void setCMDProtocol()
0: 	{
0: 		isDRDAProtocol = false;
0: 	}
0: 	/**
0: 	 * Create DSS reply object
0: 	 */
0: 	protected void createDssReply()
0: 	{
0: 		beginDss(DssConstants.DSSFMT_RPYDSS, true);
0: 	}
0: 	/**
0: 	 * Create DSS request object
0: 	 * NOTE: This is _ONLY_ used for testing the protocol
0: 	 * (via the TestProto.java file in this package)!
0: 	 * We should never create a DSS request in normal
0: 	 * DRDA processing (we should only create DSS replies
0: 	 * and DSS objects).
0: 	 */
0: 	protected void createDssRequest()
0: 	{
0: 		beginDss(DssConstants.DSSFMT_RQSDSS, true);
0: 	}
0: 	/**
0: 	 * Create DSS data object
0: 	 */
0: 	protected void createDssObject()
0: 	{
0: 		beginDss(DssConstants.DSSFMT_OBJDSS, true);
0: 	}
0: 	/**
0: 	 * Mark the DSS that we're currently writing as
0: 	 * a continued DSS, which is done by setting
0: 	 * the high-order bit to "1", per DDM spec.
0: 	 * This means:
0: 	 *
0: 	 *	1. One or more continuation DSSes will immediately
0: 	 * 		follow the current (continued) DSS.
0: 	 *	2. All continuation DSSes will have a 2-byte
0: 	 * 		continuation header, followed by data; in
0: 	 * 		other words, chaining state, correlation
0: 	 *		id, dss format info, and code point will
0: 	 * 		NOT be included.  All of that info is 
0: 	 * 		present ONLY in the FIRST DSS in the
0: 	 *		list of continued DSSes.
0: 	 *
0: 	 *	NOTE: A DSS can be a "continuation" DSS _and_
0: 	 * 	a "continued" DSS at the same time.  However,
0: 	 * 	the FIRST DSS to be continued canNOT be
0: 	 *	a continuation DSS.
0: 	 */
0: 	private void markDssAsContinued(boolean forLob)
0: 	{
0: 		if (!forLob) {
0: 		// continuation bit defaults to '1' for lobs, so
0: 		// we only have to switch it if we're not writing
0: 		// lobs.
0: 			bytes[dssLengthLocation] |= 0x80;
0: 		}
0: 		// We need to set the chaining state, but ONLY
0: 		// IF this is the FIRST DSS in the continuation
0: 		// list (only the first one has chaining state
0: 		// in it's header; the others do not).
0: 		if (!isContinuationDss)
0: 			endDss(!forLob);
0: 	}
0: 	/**
0: 	 * End DSS header by writing the length in the length location
0: 	 * and setting the chain bit.  Unlike the other two endDss
0: 	 * methods, this one overrides the default chaining byte
0: 	 * (which is set in beginDss) with the chaining byte that
0: 	 * is passed in.  NOTE: This method is only used in
0: 	 * association with createDssRequest, and thus is for
0: 	 * TESTING purposes only (via TestProto.java).  No calls
0: 	 * should be made to this method in normal DRDA processing
0: 	 * (because for normal processing, chaining must be
0: 	 * determined automatically based on DSS requests).
0: 	 */
0: 	protected void endDss(byte chainByte)
0: 	{
0: 		// Do regular endDss processing.
0: 		endDss(true);
0: 		// Now override default chain state.
0: 		bytes[dssLengthLocation + 3] &= 0x0F;	// Zero out default
0: 		bytes[dssLengthLocation + 3] |= chainByte;
0: 		previousChainByte = chainByte;
0: 	}
0: 	/**
0: 	 * End DSS header by writing the length in the length location
0: 	 * and setting the chain bit.
0: 	 */
0: 	protected void endDss() {
0: 		endDss(true);
0: 	}
0: 	/**
0: 	 * End DSS header by writing the length in the length location
0: 	 * and setting the chain bit.
0: 	 */
0: 	private void endDss (boolean finalizeLength)
0: 	{
0: 		if (finalizeLength)
0: 			finalizeDssLength();
0: 		if (isContinuationDss) {
0: 		// no chaining information for this DSS; so we're done.
0: 			isContinuationDss = false;
0: 			return;
0: 		}
0: 		previousCorrId = correlationID;
0: 		prevHdrLocation = dssLengthLocation;
0: 		previousChainByte = DssConstants.DSSCHAIN_SAME_ID;
0: 	}
0: 	/**
0: 	 * End final DDM and DSS header by writing the length in the length location
0: 	 *
0: 	 */
0: 	protected void endDdmAndDss ()
0: 	{
0: 		endDdm();	// updates last DDM object
0: 		endDss();
0: 	}
0: 	/**
0: 	 * Copy Data to End
0: 	 * Create a buffer and copy from the position given to the end of data
0: 	 *
0: 	 * Note that the position given is treated as relative to the
0: 	 * current DSS, for there may be other DSS blocks (chained, presumably)
0: 	 * which are sitting unwritten in the buffer. The caller doesn't
0: 	 * know this, though, and works only with the current DSS.
0: 	 *
0: 	 * getDSSLength, copyDSSDataToEnd, and truncateDSS work together to
0: 	 * provide a sub-protocol for DRDAConnThread to use in its
0: 	 * implementation of the LMTBLKPRC protocol. They enable the caller
0: 	 * to determine when it has written too much data into the current
0: 	 * DSS, to reclaim the extra data that won't fit, and to truncate
0: 	 * that extra data once it has been reclaimed and stored elsewhere.
0: 	 * Note that this support only works for the current DSS. Earlier,
0: 	 * chained DSS blocks cannot be accessed using these methods. For
0: 	 * additional background information, the interested reader should
0: 	 * investigate bugs DERBY-491 and 492 at:
0: 	 * http://issues.apache.org/jira/browse/DERBY-491 and
0: 	 * http://issues.apache.org/jira/browse/DERBY-492
0: 	 *
0: 	 * @param start
0: 	 */
0: 	protected byte [] copyDSSDataToEnd(int start)
0: 	{
0: 		start = start + dssLengthLocation;
0: 		int length = offset - start;
0: 		byte [] temp = new byte[length];
0: 		System.arraycopy(bytes,start,temp,0,length);
0: 		return temp;
0: 	}
0: 	// Collection methods
0: 	/**
0: 	 * Mark the location of the length bytes for the collection so they
0: 	 * can be updated later
0: 	 *
0: 	 */
0: 	protected void startDdm (int codePoint)
0: 	{
0: 		// save the location of the beginning of the collection so
0: 		// that we can come back and fill in the length bytes
0: 		markStack[top++] = offset;
0: 		ensureLength (4); // verify space for length bytes and code point
0: 		offset += 2; // move past the length bytes before writing the code point
0: 		bytes[offset] = (byte) ((codePoint >>> 8) & 0xff);
0: 		bytes[offset + 1] = (byte) (codePoint & 0xff);
0: 		offset += 2;
0: 	}
0: 	/**
0: 	 * Erase all writes for the current ddm and reset the
0: 	 * top
0: 	 */
0: 	protected void clearDdm ()
0: 	{
0: 		offset = markStack[top--];
0: 	}
0: 	/**
0: 	 * Clear the entire send buffer
0: 	 *
0: 	 */
0: 	protected void clearBuffer()
0: 	{
0: 		offset = 0;
0: 		top = 0;
0: 		dssLengthLocation = 0;
0: 		correlationID = DssConstants.CORRELATION_ID_UNKNOWN;
0: 		nextCorrelationID = 1;
0: 		isDRDAProtocol = true;
0: 	}
0: 	/**
0: 	 * End the current DDM
0: 	 *
0: 	 */
0: 	protected void endDdm ()
0: 	{
0: 		// remove the top length location offset from the mark stack
0: 		// calculate the length based on the marked location and end of data.
0: 		int lengthLocation = markStack[--top];
0: 		int length = offset - lengthLocation;
0: 		// determine if any extended length bytes are needed.	the value returned
0: 		// from calculateExtendedLengthByteCount is the number of extended length
0: 		// bytes required. 0 indicates no exteneded length.
0: 		int extendedLengthByteCount = calculateExtendedLengthByteCount (length);
0: 		if (extendedLengthByteCount != 0)
0: 		{
0: 			// ensure there is enough room in the buffer for the extended length bytes.
0: 			ensureLength (extendedLengthByteCount);
0: 			// calculate the length to be placed in the extended length bytes.
0: 			// this length does not include the 4 byte llcp.
0: 			int extendedLength = length - 4;
0: 			// shift the data to the right by the number of extended
0: 			// length bytes needed.
0: 			int extendedLengthLocation = lengthLocation + 4;
0: 			System.arraycopy (bytes,
0: 					              extendedLengthLocation,
0: 					              bytes,
0: 					              extendedLengthLocation + extendedLengthByteCount,
0: 					              extendedLength);
0: 			// write the extended length
0: 			int shiftSize = (extendedLengthByteCount -1) * 8;
0: 			for (int i = 0; i < extendedLengthByteCount; i++)
0: 			{
0: 				bytes[extendedLengthLocation++] =
0: 					(byte) ((extendedLength >>> shiftSize ) & 0xff);
0: 				shiftSize -= 8;
0: 			}
0: 			// adjust the offset to account for the shift and insert
0: 			offset += extendedLengthByteCount;
0: 			// the two byte length field before the codepoint contains the length
0: 			// of itself, the length of the codepoint, and the number of bytes used
0: 			// to hold the extended length.	the 2 byte length field also has the first
0: 			// bit on to indicate extended length bytes were used.
0: 			length = extendedLengthByteCount + 4;
0: 			length |= DssConstants.CONTINUATION_BIT;
0: 		}
0: 		// write the 2 byte length field (2 bytes before codepoint).
0: 		bytes[lengthLocation] = (byte) ((length >>> 8) & 0xff);
0: 		bytes[lengthLocation+1] = (byte) (length & 0xff);
0: 	}
/////////////////////////////////////////////////////////////////////////
0:     */
0:     protected int getDSSLength()
0:     {
/////////////////////////////////////////////////////////////////////////
0:     */
0:     protected void truncateDSS(int value)
0:     {
0: 	// Write routines
0: 	/**
0: 	 * Write byte
0: 	 *
0: 	 * @param 	value	byte to be written
0: 	 */
0: 	protected void writeByte (int value)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (value > 255)
0: 				SanityManager.THROWASSERT(
0: 									   "writeByte value: " + value +
0: 									   " may not be > 255");
0: 		}
0: 		ensureLength (1);
0: 		bytes[offset++] = (byte) (value & 0xff);
0: 	}
0: 	/**
0: 	 * Write network short
0: 	 *
0: 	 * @param 	value	value to be written
0: 	 */
0: 	protected void writeNetworkShort (int value)
0: 	{
0: 		ensureLength (2);
0: 		bytes[offset] = (byte) ((value >>> 8) & 0xff);
0: 		bytes[offset + 1] = (byte) (value & 0xff);
0: 		offset += 2;
0: 	}
0: 	/**
0: 	 * Write network int
0: 	 *
0: 	 * @param 	value	value to be written
0: 	 */
0: 	protected void writeNetworkInt (int value)
0: 	{
0: 		ensureLength (4);
0: 		bytes[offset] = (byte) ((value >>> 24) & 0xff);
0: 		bytes[offset + 1] = (byte) ((value >>> 16) & 0xff);
0: 		bytes[offset + 2] = (byte) ((value >>> 8) & 0xff);
0: 		bytes[offset + 3] = (byte) (value & 0xff);
0: 		offset += 4;
0: 	}
0: 	/**
0: 	 * Write byte array
0: 	 *
0: 	 * @param 	buf	byte array to be written
0: 	 * @param	length  - length to write
0: 	 */
0: 	protected void writeBytes (byte[] buf, int length)
0: 	{
0: 		writeBytes(buf, 0,length);
0: 	}
0: 	/**
0: 	 * Write byte array
0: 	 *
0: 	 * @param 	buf	byte array to be written
0: 	 * @param	start  - starting position
0: 	 * @param	length  - length to write
0: 	 */
0: 	protected void writeBytes (byte[] buf, int start, int length)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (buf == null && length > 0)
0: 		    	SanityManager.THROWASSERT("Buf is null");
0: 			if (length + start - 1 > buf.length)
0: 		    	SanityManager.THROWASSERT("Not enough bytes in buffer");
0: 		}
0: 		ensureLength (length);
0: 		System.arraycopy(buf,start,bytes,offset,length);
0: 		offset += length;
0: 	}
0: 	/**
0: 	 * Write byte array
0: 	 *
0: 	 * @param 	buf	byte array to be written
0: 	 **/
0: 	protected void writeBytes (byte[] buf)
0: 	{
0: 		writeBytes(buf,buf.length);
0: 	}
0: 	protected void writeLDBytes(byte[] buf)
0: 	{
0: 		writeLDBytes(buf, 0);
0: 	}
0: 	protected void writeLDBytes(byte[] buf, int index)
0: 	{
0: 		int length = buf.length;
0: 		int writeLen =  buf.length;
0: 		writeShort(writeLen);
0: 		writeBytes(buf,0,writeLen);
0: 	}
0: 	/**
0: 	 * Write code point and 4 bytes
0: 	 *
0: 	 * @param 	codePoint - code point to write
0: 	 * @param	value  - value to write after code point
0: 	 */
0: 	void writeCodePoint4Bytes (int codePoint, int value)
0: 	{
0: 		ensureLength (4);
0: 		bytes[offset] = (byte) ((codePoint >>> 8) & 0xff);
0: 		bytes[offset + 1] = (byte) (codePoint & 0xff);
0: 		bytes[offset + 2] = (byte) ((value >>> 8) & 0xff);
0: 		bytes[offset + 3] = (byte) (value & 0xff);
0: 		offset += 4;
0: 	}
0: 	/**
0: 	 * Write scalar 1 byte object includes length, codepoint and value
0: 	 *
0: 	 * @param 	codePoint - code point to write
0: 	 * @param	value  - value to write after code point
0: 	 */
0: 	void writeScalar1Byte (int codePoint, int value)
0: 	{
0: 		ensureLength (5);
0: 		bytes[offset] = 0x00;
0: 		bytes[offset + 1] = 0x05;
0: 		bytes[offset + 2] = (byte) ((codePoint >>> 8) & 0xff);
0: 		bytes[offset + 3] = (byte) (codePoint & 0xff);
0: 		bytes[offset + 4] = (byte) (value & 0xff);
0: 		offset += 5;
0: 	}
0: 	/**
0: 	 * Write scalar 2 byte object includes length, codepoint and value
0: 	 *
0: 	 * @param 	codePoint - code point to write
0: 	 * @param	value  - value to write after code point
0: 	 */
0: 	protected void writeScalar2Bytes (int codePoint, int value)
0: 	{
0: 		ensureLength (6);
0: 		bytes[offset] = 0x00;
0: 		bytes[offset + 1] = 0x06;
0: 		bytes[offset + 2] = (byte) ((codePoint >>> 8) & 0xff);
0: 		bytes[offset + 3] = (byte) (codePoint & 0xff);
0: 		bytes[offset + 4] = (byte) ((value >>> 8) & 0xff);
0: 		bytes[offset + 5] = (byte) (value & 0xff);
0: 		offset += 6;
0: 	}
0: 	protected void writeScalar2Bytes ( int value)
0: 	{
0: 		ensureLength (2);
0: 		bytes[offset] = (byte) ((value >>> 8) & 0xff);
0: 		bytes[offset + 1] = (byte) (value & 0xff);
0: 		offset += 2;
0: 	}
0: 	/**
0: 	 * Write length and codepoint
0: 	 *
0: 	 * @param 	length - length of object
0: 	 * @param 	codePoint - code point to write
0: 	 */
0: 	protected void startDdm (int length, int codePoint)
0: 	{
0: 		ensureLength (4);
0: 		bytes[offset] = (byte) ((length >>> 8) & 0xff);
0: 		bytes[offset + 1] = (byte) (length & 0xff);
0: 		bytes[offset + 2] = (byte) ((codePoint >>> 8) & 0xff);
0: 		bytes[offset + 3] = (byte) (codePoint & 0xff);
0: 		offset += 4;
0: 	}
0: 	/**
0: 	 * Write scalar byte array object includes length, codepoint and value
0: 	 *
0: 	 * @param 	codePoint - code point to write
0: 	 * @param	buf  - value to write after code point
0: 	 * @param	length - number of bytes to write
0: 	 */
0: 	protected void writeScalarBytes (int codePoint, byte[] buf, int length)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (buf == null && length > 0)
0: 		    	SanityManager.THROWASSERT("Buf is null");
0: 			if (length > buf.length)
0: 		    	SanityManager.THROWASSERT("Not enough bytes in buffer");
0: 		}
0: 		ensureLength (length + 4);
0: 		bytes[offset] = (byte) (((length+4) >>> 8) & 0xff);
0: 		bytes[offset + 1] = (byte) ((length+4) & 0xff);
0: 		bytes[offset + 2] = (byte) ((codePoint >>> 8) & 0xff);
0: 		bytes[offset + 3] = (byte) (codePoint & 0xff);
0: 		System.arraycopy(buf,0,bytes,offset + 4, length);
0: 		offset += length + 4;
0: 	}
0: 									  int codePoint,
0: 				      EXTDTAInputStream in,
0: 									  boolean writeNullByte) 
0: 		throws DRDAProtocolException
0: 	{
0: 	    
0: 		// Stream equivalent of "beginDss"...
0: 	    int spareDssLength = prepScalarStream( chainedWithSameCorrelator,
0: 											codePoint,
0: 											writeNullByte);
0: 	    
0: 		// write the data
0: 		int bytesRead = 0;
0: 		int totalBytesRead = 0;
0: 				try {
0: 				    
0: 		OutputStream out = 
0: 		    placeLayerBStreamingBuffer( agent.getOutputStream() );
0: 		
0: 		boolean isLastSegment = false;
0: 		
0: 		while( !isLastSegment ){
0: 		    
0: 		    int spareBufferLength = bytes.length - offset;
0: 		    
0: 		    if( SanityManager.DEBUG ){
0: 		
0: 			if( PropertyUtil.getSystemProperty("derby.debug.suicideOfLayerBStreaming") != null )
0: 			    throw new IOException();
0: 				}
0: 		    
0: 		    bytesRead = in.read(bytes,
0: 					offset,
0: 					Math.min(spareDssLength,
0: 						 spareBufferLength));
0: 		    
0: 					totalBytesRead += bytesRead;
0: 					offset += bytesRead;
0: 		    spareDssLength -= bytesRead;
0: 		    spareBufferLength -= bytesRead;
0: 		    isLastSegment = peekStream(in) < 0;
0: 		    
0: 		    if(isLastSegment || 
0: 		       spareDssLength == 0){
0: 			
0: 			flushScalarStreamSegment (isLastSegment, 
0: 						  out);
0: 			
0: 			if( ! isLastSegment )
0: 			    spareDssLength = DssConstants.MAX_DSS_LENGTH - 2;
0: 			}
0: 		    
0: 		}
0: 		
0: 		out.flush();
0: 		
0: 	    }catch(IOException e){
0: 		agent.markCommunicationsFailure ("DDMWriter.writeScalarStream()",
0: 						 "",
0: 						 e.getMessage(),
0: 						 "*");
0: 		}
0: 				
0: 	}
0: 	
0: 	/**
0: 	 * Begins a DSS stream (for writing LOB data).
0: 	 */
0: 	private void beginDss (boolean chainedToNextStructure,
0: 						   int dssType)
0: 	{
0: 		beginDss(dssType, false);	// false => don't ensure length.
0: 		// always turn on continuation flags... this is helpful for lobs...
0: 		// these bytes will get rest if dss lengths are finalized.
0:   		bytes[dssLengthLocation] = (byte) 0xFF;
0:   		bytes[dssLengthLocation + 1] = (byte) 0xFF;
0: 
0: 		// Set whether or not this DSS should be chained to
0: 		// the next one.  If it's chained, it has to be chained
0: 		// with same id (that's the nature of EXTDTA chaining).
0: 		if (chainedToNextStructure) {
0: 			dssType |= DssConstants.GDSCHAIN_SAME_ID;
0: 		}
0: 
0: 		bytes[dssLengthLocation + 3] = (byte) (dssType & 0xff);
0: 	}
/////////////////////////////////////////////////////////////////////////
1:   private int prepScalarStream( boolean chainedWithSameCorrelator,
0:                                    int codePoint,
1:                                    boolean writeNullByte) throws DRDAProtocolException
0:   {
0:       ensureLength( DEFAULT_BUFFER_SIZE - offset );
1:       final int nullIndicatorSize = writeNullByte ? 1:0;
1:       // flush the existing DSS segment ,
1:       // if this stream will not fit in the send buffer or 
1:       // length of this stream is unknown.
1:       // Here, 10 stands for sum of headers of layer A and B.
0:       try {
0: 	    // The existing DSS segment was finalized by endDss; all
0: 	    // we have to do is send it across the wire.
0:         sendBytes(agent.getOutputStream());
0:       }
0:       catch (java.io.IOException e) {
0:          agent.markCommunicationsFailure ("DDMWriter.writeScalarStream()",
0:                                               "OutputStream.flush()",
0:                                               e.getMessage(),"*");
0:       }
0:     // buildStreamDss should not call ensure length.
0: 	beginDss(chainedWithSameCorrelator, DssConstants.GDSFMT_OBJDSS);
1:       writeLengthCodePoint(0x8004,codePoint);
0:     // write the null byte, if necessary
0:     if (writeNullByte)
0:       writeByte(0x0);
1:       //Here, 6 stands for header of layer A and 
1:       //4 stands for header of layer B.
1:       return DssConstants.MAX_DSS_LENGTH - 6 - 4 - nullIndicatorSize;
0:   }
0: 
0: 
0:   // method to determine if any data is in the request.
0:   // this indicates there is a dss object already in the buffer.
0: 	protected boolean doesRequestContainData()
0: 	{
0: 		return offset != 0;
0: 	}
0: 
0: 
0: 	// Writes out a scalar stream DSS segment, along with DSS continuation
0: 	// headers if necessary.
0: 	private void flushScalarStreamSegment ( boolean lastSegment,
0: 					        OutputStream out)
0: 		throws DRDAProtocolException
0: 	{
0: 
0: 		// either at end of data, end of dss segment, or both.
0: 	    if (! lastSegment) {
0: 
0: 		// 32k segment filled and not at end of data.
0: 				try {
0: 				// Mark current DSS as continued, set its chaining state,
0: 				// then send the data across.
0: 					markDssAsContinued(true); 	// true => for lobs
0: 					sendBytes (out,
0: 						   false);
0: 			    
0: 			}catch (java.io.IOException ioe) {
0: 					agent.markCommunicationsFailure ("DDMWriter.flushScalarStreamSegment()",
0:                                                "",
0:                                                ioe.getMessage(),
0:                                                "*");
0: 				}
0: 
0: 
0: 			// Prepare a DSS continuation header for next DSS.
0: 			dssLengthLocation = offset;
0: 			bytes[offset++] = (byte) (0xff);
0: 			bytes[offset++] = (byte) (0xff);
0: 			isContinuationDss = true;
0: 	    }else{
0: 		// we're done writing the data, so end the DSS.
0: 			endDss();
0: 
0: 	}
0: 
0:   }
0: 
0: 
0: 	private void writeExtendedLengthBytes (int extendedLengthByteCount, long length)
0: 	{
0: 	int shiftSize = (extendedLengthByteCount -1) * 8;
0:     for (int i = 0; i < extendedLengthByteCount; i++) {
0:       bytes[offset + i] = (byte) ((length >>> shiftSize) & 0xff);
0:       shiftSize -= 8;
0: 	offset += extendedLengthByteCount;
0:   }
0:   // insert a 4 byte length/codepoint pair into the buffer.
0:   // total of 4 bytes inserted in buffer.
0:   // Note: the length value inserted in the buffer is the same as the value
0:   // passed in as an argument (this value is NOT incremented by 4 before being
0:   // inserted).
0:   void writeLengthCodePoint (int length, int codePoint)
0:   {
0:     ensureLength (4);
0:     bytes[offset] = (byte) ((length >>> 8) & 0xff);
0:     bytes[offset + 1] = (byte) (length & 0xff);
0:     bytes[offset + 2] = (byte) ((codePoint >>> 8) & 0xff);
0:     bytes[offset + 3] = (byte) (codePoint & 0xff);
0: 	offset +=4;
0:   }
0: 
0: 	/**
0: 	 * Write scalar object header includes length and codepoint
0: 	 *
0: 	 * @param 	codePoint - code point to write
0: 	 * @param	dataLength - length of object data
0: 	 */
0: 	protected void writeScalarHeader (int codePoint, int dataLength)
0: 	{
0: 		ensureLength (dataLength + 4);
0: 		bytes[offset] = (byte) (((dataLength+4) >>> 8) & 0xff);
0: 		bytes[offset + 1] = (byte) ((dataLength+4) & 0xff);
0: 		bytes[offset + 2] = (byte) ((codePoint >>> 8) & 0xff);
0: 		bytes[offset + 3] = (byte) (codePoint & 0xff);
0: 		offset += 4;
0: 	}
0: 
0: 	/**
0: 	 * Write scalar string object includes length, codepoint and value
0: 	 * the string is converted into the appropriate codeset (EBCDIC)
0: 	 *
0: 	 * @param 	codePoint - code point to write
0: 	 * @param	string - string to be written
0: 	 */
0: 	void writeScalarString (int codePoint, String string)
0: 	{
0: 		int stringLength = string.length();
0: 		ensureLength ((stringLength * 2)  + 4);
0: 		bytes[offset] = (byte) (((stringLength+4) >>> 8) & 0xff);
0: 		bytes[offset + 1] = (byte) ((stringLength+4) & 0xff);
0: 		bytes[offset + 2] = (byte) ((codePoint >>> 8) & 0xff);
0: 		bytes[offset + 3] = (byte) (codePoint & 0xff);
0: 		offset = ccsidManager.convertFromUCS2 (string, bytes, offset + 4);
0: 	}
0: 
0: 	/**
0: 	 * Write padded scalar string object includes length, codepoint and value
0: 	 * the string is converted into the appropriate codeset (EBCDIC)
0: 	 *
0: 	 * @param 	codePoint - code point to write
0: 	 * @param	string - string to be written
0: 	 * @param 	paddedLength - length to pad string to
0: 	 */
0: 	void writeScalarPaddedString (int codePoint, String string, int paddedLength)
0: 	{
0: 		int stringLength = string.length();
0: 		int fillLength = paddedLength - stringLength;
0: 		ensureLength (paddedLength + 4);
0: 		bytes[offset] = (byte) (((paddedLength+4) >>> 8) & 0xff);
0: 		bytes[offset + 1] = (byte) ((paddedLength+4) & 0xff);
0: 		bytes[offset + 2] = (byte) ((codePoint >>> 8) & 0xff);
0: 		bytes[offset + 3] = (byte) (codePoint & 0xff);
0: 		offset = ccsidManager.convertFromUCS2 (string, bytes, offset + 4);
0: 		Arrays.fill(bytes,offset, offset + fillLength,ccsidManager.space);
0: 		offset += fillLength;
0: 	}
0: 
0: 	/**
0: 	 * Write padded scalar string object value
0: 	 * the string is converted into the appropriate codeset (EBCDIC)
0: 	 *
0: 	 * @param	string - string to be written
0: 	 * @param 	paddedLength - length to pad string to
0: 	 */
0: 	protected void writeScalarPaddedString (String string, int paddedLength)
0: 	{
0: 		int stringLength = string.length();
0: 
0: 		int fillLength = paddedLength -stringLength;
0: 		ensureLength (paddedLength);
0: 		offset = ccsidManager.convertFromUCS2 (string, bytes, offset);
0: 		Arrays.fill(bytes,offset, offset + fillLength,ccsidManager.space);
0: 		offset += fillLength;
0: 	}
0: 
0: 	/**
0: 	 * Write padded scalar <code>DRDAString</code> object value. The
0: 	 * string is converted into the appropriate codeset.
0: 	 *
0: 	 * @param drdaString string to be written
0: 	 * @param paddedLength length to pad string to
0: 	 */
0: 	protected void writeScalarPaddedString (DRDAString drdaString, int paddedLength)
0: 	{
0: 		int stringLength = drdaString.length();
0: 		int fillLength = paddedLength - stringLength;
0: 		ensureLength(paddedLength);
0: 		System.arraycopy(drdaString.getBytes(), 0, bytes, offset, stringLength);
0: 		offset += stringLength;
0: 		Arrays.fill(bytes, offset, offset + fillLength, ccsidManager.space);
0: 		offset += fillLength;
0: 	}
0: 
0: 	/**
0: 	 * Write padded scalar byte array object includes length, codepoint and value
0: 	 *
0: 	 * @param 	codePoint - code point to write
0: 	 * @param	buf - byte array to be written
0: 	 * @param 	paddedLength - length to pad string to
0: 	 * @param	padByte - byte to be used for padding
0: 	 */
0: 	protected void writeScalarPaddedBytes (int codePoint, byte[] buf, int paddedLength, byte padByte)
0: 	{
0: 		int bufLength = buf.length;
0: 		ensureLength (paddedLength + 4);
0: 		bytes[offset] = (byte) (((paddedLength+4) >>> 8) & 0xff);
0: 		bytes[offset + 1] = (byte) ((paddedLength+4) & 0xff);
0: 		bytes[offset + 2] = (byte) ((codePoint >>> 8) & 0xff);
0: 		bytes[offset + 3] = (byte) (codePoint & 0xff);
0: 		offset += 4;
0: 		System.arraycopy(buf,0,bytes,offset,bufLength);
0: 		offset += bufLength;
0: 		int fillLength = paddedLength - bufLength;
0: 		Arrays.fill(bytes,offset,offset + fillLength,padByte);
0: 		offset += fillLength;
0: 	}
0: 
0: 	/**
0: 	 * Write padded scalar byte array object  value
0: 	 *
0: 	 * @param	buf - byte array to be written
0: 	 * @param 	paddedLength - length to pad string to
0: 	 * @param	padByte - byte to be used for padding
0: 	 */
0: 	protected void writeScalarPaddedBytes (byte[] buf, int paddedLength, byte padByte)
0: 	{
0: 		int bufLength = buf.length;
0: 		int fillLength = paddedLength - bufLength;
0: 		ensureLength (paddedLength);
0: 		System.arraycopy(buf,0,bytes,offset,bufLength);
0: 		offset +=bufLength;
0: 		Arrays.fill(bytes,offset,offset + fillLength,padByte);
0: 		offset += fillLength;
0: 	}
0: 
0: 	/**
0: 	 * Write scalar byte array object includes length, codepoint and value
0: 	 *
0: 	 * @param 	codePoint - code point to write
0: 	 * @param	buf - byte array to be written
0: 	 */
0: 	protected void writeScalarBytes (int codePoint, byte[] buf)
0: 	{
0: 		int bufLength = buf.length;
0: 		ensureLength (bufLength + 4);
0: 		bytes[offset] = (byte) (((bufLength+4) >>> 8) & 0xff);
0: 		bytes[offset + 1] = (byte) ((bufLength+4) & 0xff);
0: 		bytes[offset + 2] = (byte) ((codePoint >>> 8) & 0xff);
0: 		bytes[offset + 3] = (byte) (codePoint & 0xff);
0: 		System.arraycopy(buf,0,bytes,offset + 4,bufLength);
0: 		offset += bufLength + 4;
0: 	}
0: 
0: 	/**
0: 	 * Write scalar byte array object includes length, codepoint and value
0: 	 *
0: 	 * @param 	codePoint - code point to write
0: 	 * @param	buf - byte array to be written
0: 	 * @param	start - starting point
0: 	 * @param 	length - length to write
0: 	 */
0: 	protected void writeScalarBytes (int codePoint, byte[] buf, int start, int length)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (buf == null && length > start)
0: 		    	SanityManager.THROWASSERT("Buf is null");
0: 			if (length - start > buf.length)
0: 				SanityManager.THROWASSERT("Not enough bytes in buffer");
0: 		}
0: 		int numBytes = length - start;
0: 		ensureLength (numBytes + 4);
0: 		bytes[offset] = (byte) (((numBytes+4) >>> 8) & 0xff);
0: 		bytes[offset + 1] = (byte) ((numBytes+4) & 0xff);
0: 		bytes[offset + 2] = (byte) ((codePoint >>> 8) & 0xff);
0: 		bytes[offset + 3] = (byte) (codePoint & 0xff);
0: 		offset += 4;
0: 		System.arraycopy(buf,start,bytes,offset,numBytes);
0: 		offset += numBytes;
0: 	}
0: 	// The following methods write data in the platform format
0: 	// The platform format was indicated during connection time as ASC since
0: 	// JCC doesn't read JVM platform (yet)
0: 
0: 	/**
0: 	 * Write platform short
0: 	 *
0: 	 * @param 	v	value to be written
0: 	 */
0: 	protected void writeShort (int v)
0: 	{
0: 		writeNetworkShort(v);
0: 	}
0: 
0: 	/**
0: 	 * Write boolean as short
0: 	 * @param b boolean value true = 1 false = 0
0: 	 *
0: 	 */
0: 	protected void writeShort(boolean b)
0: 	{
0: 		writeNetworkShort(b ? 1 : 0);
0: 	}
0: 
0: 	/**
0: 	 * Write platform int
0: 	 *
0: 	 * @param 	v	value to be written
0: 	 */
0: 	protected void writeInt (int v)
0: 	{
0: 		writeNetworkInt(v);
0: 	}
0: 
0: 	/**
0: 	 * Write platform long
0: 	 *
0: 	 * @param 	v	value to be written
0: 	 */
0: 	protected void writeLong (long v)
0: 	{
0: 		ensureLength (8);
0: 		bytes[offset] =	(byte) ((v >>> 56) & 0xff);
0: 		bytes[offset + 1] =	(byte) ((v >>> 48) & 0xff);
0: 		bytes[offset + 2] =	(byte) ((v >>> 40) & 0xff);
0: 		bytes[offset + 3] =	(byte) ((v >>> 32) & 0xff);
0: 		bytes[offset + 4] =	(byte) ((v >>> 24) & 0xff);
0: 		bytes[offset + 5] =	(byte) ((v >>> 16) & 0xff);
0: 		bytes[offset + 6] =	(byte) ((v >>>  8) & 0xff);
0: 		bytes[offset + 7] =	(byte) ((v >>>  0) & 0xff);
0: 		offset += 8;
0: 	}
0: 
0: 	/**
0: 	 * Write platform float
0: 	 *
0: 	 * @param 	v	value to be written
0: 	 */
0: 	protected void writeFloat (float v)
0: 	{
0: 		writeInt (Float.floatToIntBits (v));
0: 	}
0: 
0: 	/**
0: 	 * Write platform double
0: 	 *
0: 	 * @param 	v	value to be written
0: 	 */
0: 	protected void writeDouble (double v)
0: 	{
0: 		writeLong (Double.doubleToLongBits (v));
0: 	}
0: 
0: 	/**
0: 	 * Write big decimal to buffer
0: 	 *
0: 	 * @param v value to write
0: 	 * @param precision Precison of decimal or numeric type
0: 	 * @param scale declared scale
0: 	 * @exception SQLException thrown if number of digits > 31
0: 	 */
0: 	protected void writeBigDecimal (java.math.BigDecimal v, int precision, int scale)
0: 		throws SQLException
0: 	{
0: 		int length = precision / 2 + 1;
0: 		ensureLength (offset + length);
0: 		bigDecimalToPackedDecimalBytes (v,precision, scale);
0: 		offset += length;
0: 	}
0: 
0: 	/**
0: 	 * Write platform boolean
0: 	 *
0: 	 * @param 	v	value to be written
0: 	 */
0: 	protected void writeBoolean (boolean v)
0: 	{
0: 		ensureLength (1);
0: 		bytes[offset++] = (byte) ((v ? 1 : 0) & 0xff);
0: 	}
0: 
0: 	/**
0: 	 * Write length delimited string
0: 	 *
0: 	 * @param s value to be written with integer
0: 	 *
0: 	 * @exception DRDAProtocolException
0: 	 */
0: 	protected void writeLDString(String s) throws DRDAProtocolException
0: 	{
0: 		writeLDString(s,0);
0: 	}
0: 	/**
0: 	 * Write length delimited string
0: 	 *
0: 	 * @param s              value to be written with integer
0: 	 * @param index          column index to put in warning
0: 	 * @exception DRDAProtocolException
0: 	 */
0: 	protected void writeLDString(String s, int index) throws DRDAProtocolException
0: 	{
0: 		try {
0: 			byte [] byteval = s.getBytes(NetworkServerControlImpl.DEFAULT_ENCODING);
0: 			int origLen = byteval.length;
0: 			boolean multiByteTrunc = false;
0: 			int writeLen =
0: 				java.lang.Math.min(FdocaConstants.LONGVARCHAR_MAX_LEN,
0: 								   origLen);
0: 			/*
0: 			Need to make sure we truncate on character boundaries.
0: 			We are assuming
0: 			http://www.sun.com/developers/gadc/technicalpublications/articles/utf8.html
0: 			To find the beginning of a multibyte character:
0: 			1) Does the current byte start with the bit pattern 10xxxxxx?
0: 			2) If yes, move left and go to step #1.
0: 			3) Finished
0: 			We assume that NetworkServerControlImpl.DEFAULT_ENCODING remains UTF-8
0: 			*/
0: 			if (SanityManager.DEBUG)
0: 			{
0: 				if (!(NetworkServerControlImpl.DEFAULT_ENCODING.equals("UTF8")))
0: 					SanityManager.THROWASSERT("Encoding assumed to be UTF8, but is actually" + NetworkServerControlImpl.DEFAULT_ENCODING);
0: 			}
0: 			if (writeLen != origLen)
0: 				// first position on the first byte of the multibyte char
0: 				while ((byteval[writeLen -1] & 0xC0) == 0x80)
0: 				{
0: 					multiByteTrunc = true;
0: 					writeLen--;
0: 					// Then subtract one more to get to the end of the
0: 					// previous character
0: 					if (multiByteTrunc == true)
0: 					{
0: 						writeLen = writeLen -1;
0: 					}
0: 				}
0: 			writeShort(writeLen);
0: 			writeBytes(byteval,writeLen);
0: 		}
0: 		catch (Exception e) {
0: 			//this should never happen
0: 			agent.agentError("Encoding " + NetworkServerControlImpl.DEFAULT_ENCODING + " not supported");
0: 		}
0: 	}
0: 	/**
0: 	 * Write string with default encoding
0: 	 *
0: 	 * @param s value to be written
0: 	 *
0: 	 * @exception DRDAProtocolException
0: 	 */
0: 	protected void writeString(String s) throws DRDAProtocolException
0: 	{
0: 		try {
0: 			writeBytes(s.getBytes(NetworkServerControlImpl.DEFAULT_ENCODING));
0: 		} catch (Exception e) {
0: 			//this should never happen
0: 			agent.agentError("Encoding " + NetworkServerControlImpl.DEFAULT_ENCODING + " not supported");
0: 		}
0: 	}
0: 	/**
0: 	 * Write string with default encoding and specified length
0: 	 *
0: 	 * @param s value to be written
0: 	 * @param length number of bytes to be written
0: 	 *
0: 	 * @exception DRDAProtocolException
0: 	 */
0: 	protected void writeString(String s, int length) throws DRDAProtocolException
0: 	{
0: 		byte[] bs = null;
0: 		try {
0: 			bs = s.getBytes(NetworkServerControlImpl.DEFAULT_ENCODING);
0: 		} catch (Exception e) {
0: 			//this should never happen
0: 			agent.agentError("Encoding " + NetworkServerControlImpl.DEFAULT_ENCODING + " not supported");
0: 		}
0: 		int len = bs.length;
0: 		if (len >= length)
0: 			writeBytes(bs, length);
0: 		else
0: 		{
0: 			writeBytes(bs);
0: 			padBytes(NetworkServerControlImpl.SPACE_CHAR, length-len);
0: 		}
0: 	}
0: 	/**
0: 	 * Write pad bytes using spaceChar
0: 	 *
0: 	 * @param   val	value to be written
0: 	 * @param	length		length to be written
0: 	 */
0: 	protected void padBytes (byte val, int length)
0: 	{
0: 		Arrays.fill(bytes,offset, offset + length,val);
0: 		offset += length;
0: 	}
0: 	/**
0: 	 * Flush buffer to outputstream
0: 	 *
0: 	 *
0: 	 * @exception IOException
0: 	 */
0: 	protected void flush () throws java.io.IOException
0: 	{
0: 		flush(agent.getOutputStream());
0: 	}
0: 	/**
0: 	 * Flush buffer to specified stream
0: 	 *
0: 	 * @param socketOutputStream
0: 	 *
0: 	 * @exception IOException
0: 	 */
0: 	protected void flush(OutputStream socketOutputStream)
0: 		throws java.io.IOException
0: 	{
0: 		try {
0: 			socketOutputStream.write (bytes, 0, offset);
0: 			socketOutputStream.flush();
0: 		}
0: 		finally {
0: 			if ((dssTrace != null) && dssTrace.isComBufferTraceOn()) {
0: 			  dssTrace.writeComBufferData (bytes,
0: 			                               0,
0: 			                               offset,
0: 			                               DssTrace.TYPE_TRACE_SEND,
0: 			                               "Reply",
0: 			                               "flush",
0: 			                               5);
0: 			}
0: 			reset(dssTrace);
0: 		}
0: 	}
0: 	// private methods
0: 	/**
0: 	 * Write DSS header
0: 	 * DSS Header format is
0: 	 * 	2 bytes	- length
0: 	 *	1 byte	- 'D0'	- indicates DDM data
0: 	 * 	1 byte	- DSS format
0: 	 *		|---|---------|----------|
0: 	 *		| 0	|	flags |	type     |
0: 	 *		|---|---------|----------|
0: 	 *		| 0 | 1	2	3 | 4 5 6 7	 |
0: 	 *		|---|---------|----------|
0: 	 *		bit 0 - '0'
0: 	 *		bit 1 - '0' - unchained, '1' - chained
0: 	 *		bit 2 - '0'	- do not continue on error, '1' - continue on error
0: 	 *		bit 3 - '0' - next DSS has different correlator, '1' - next DSS has
0: 	 *						same correlator
0: 	 *		type - 1 - Request DSS
0: 	 *			 - 2 - Reply DSS
0: 	 *			 - 3 - Object DSS
0: 	 *			 - 4 - Communications DSS
0: 	 *			 - 5 - Request DSS where no reply is expected
0: 	 */
0: 	private void beginDss (int dssType, boolean ensureLen)
0: 	{
0: 		// save length position, the length will be written at the end
0: 		dssLengthLocation = offset;
0: 		// Should this really only be for non-stream DSSes?
0: 		if (ensureLen)
0: 			ensureLength(6);
0: 		// Skip past length; we'll come back and set it later.
0: 		offset += 2;
0: 		// write gds info
0: 		bytes[offset] = (byte) 0xD0;
0: 		// Write DSS type, and default chain bit to be 
0: 		// DssConstants.DSSCHAIN_SAME_ID.  This default
0: 		// will be overridden by calls to "finalizeChain()"
0: 		// and/or calls to "beginDss(boolean, int)" for
0: 		// writing LOB data.
0: 		bytes[offset + 1] = (byte) dssType;
0: 		bytes[offset + 1] |= DssConstants.DSSCHAIN_SAME_ID;
0: 		// save correlationID for use in error messages while processing
0: 		// this DSS
0: 		correlationID = getCorrelationID();
0: 		// write the reply correlation id
0: 		bytes[offset + 2] = (byte) ((correlationID >>> 8) & 0xff);
0: 		bytes[offset + 3] = (byte) (correlationID & 0xff);
0: 		offset += 4;
0: 	}
0: 	/**
0: 	 * The length of dss object will be calculated based on the difference between the
0: 	 * start of the dss, saved on the beginDss call, and the current
0: 	 * offset into the buffer which marks the end of the data.	In the event
0: 	 * the length requires the use of continuation Dss headers, one for each 32k
0: 	 * chunk of data, the data will be shifted and the continuation headers
0: 	 * will be inserted with the correct values as needed.
0: 	 */
0: 	private void finalizeDssLength ()
0: 	{
0: 		// calculate the total size of the dss and the number of bytes which would
0: 		// require continuation dss headers.	The total length already includes the
0: 		// the 6 byte dss header located at the beginning of the dss.	It does not
0: 		// include the length of any continuation headers.
0: 		int totalSize = offset - dssLengthLocation;
0: 		int bytesRequiringContDssHeader = totalSize - DssConstants.MAX_DSS_LENGTH;
0: 		// determine if continuation headers are needed
0: 		if (bytesRequiringContDssHeader > 0)
0: 		{
0: 			// the continuation headers are needed, so calculate how many.
0: 			// after the first 32767 worth of data, a continuation header is
0: 			// needed for every 32765 bytes (32765 bytes of data + 2 bytes of
0: 			// continuation header = 32767 Dss Max Size).
0: 			int contDssHeaderCount = bytesRequiringContDssHeader / 32765;
0: 			if (bytesRequiringContDssHeader % 32765 != 0)
0: 				contDssHeaderCount++;
0: 			// right now the code will shift to the right.	In the future we may want
0: 			// to try something fancier to help reduce the copying (maybe keep
0: 			// space in the beginning of the buffer??).
0: 			// the offset points to the next available offset in the buffer to place
0: 			// a piece of data, so the last dataByte is at offset -1.
0: 			// various bytes will need to be shifted by different amounts
0: 			// depending on how many dss headers to insert so the amount to shift
0: 			// will be calculated and adjusted as needed.	ensure there is enough room
0: 			// for all the conutinuation headers and adjust the offset to point to the
0: 			// new end of the data.
0: 			int dataByte = offset - 1;
0: 			int shiftSize = contDssHeaderCount * 2;
0: 			ensureLength (shiftSize);
0: 			offset += shiftSize;
0: 			// Notes on the behavior of the Layer B segmenting loop below:
0: 			//
0: 			// We start with the right most chunk. For a 3-segment object we'd
0: 			// shift 2 segments: shift the first (rightmost) one 4 bytes and 
0: 			// the second one 2. Note that by 'first' we mean 'first time
0: 			// through the loop', but that is actually the last segment
0: 			// of data since we are moving right-to-left. For an object
0: 			// of K segments we will pass through this loop K-1 times.
0: 			// The 0th (leftmost) segment is not shifted, as it is
0: 			// already in the right place. When we are done, we will
0: 			// have made room in each segment for an additional
0: 			// 2 bytes for the continuation header. Thus, each
0: 			// segment K is shifted K*2 bytes to the right.
0: 			//
0: 			// Each time through the loop, "dataByte" points to the
0: 			// last byte in the segment; "dataToShift" is the amount of
0: 			// data that we need to shift, and "shiftSize" is the
0: 			// distance that we need to shift it. Since dataByte points
0: 			// at the last byte, not one byte beyond it (as with the
0: 			// "offset" variable used elsewhere in DDMWriter), the start
0: 			// of the segement is actually at (dataByte-dataToShift+1).
0: 			//
0: 			// After we have shifted the segment, we move back to the
0: 			// start of the segment and set the value of the 2-byte DSS
0: 			// continuation header, which needs to hold the length of
0: 			// this segment's data, together with the continuation flag
0: 			// if this is not the rightmost (passOne) segment.
0: 			//
0: 			// In general, each segment except the rightmost will contain
0: 			// 32765 bytes of data, plus the 2-byte header, and its
0: 			// continuation flag will be set, so the header value will
0: 			// be 0xFFFF. The rightmost segment will not have the
0: 			// continuation flag set, so its value may be anything from
0: 			// 0x0001 to 0x7FFF, depending on the amount of data in that
0: 			// segment.
0: 			//
0: 			// Note that the 0th (leftmost) segment also has a 2-byte
0: 			// DSS header, which needs to have its continuation flag set.
0: 			// This is done by resetting the "totalSize" variable below,
0: 			// at which point that variable no longer holds the total size
0: 			// of the object, but rather just the length of segment 0. The
0: 			// total size of the object was written using extended length
0: 			// bytes by the endDdm() method earlier.
0: 			//
0: 			// Additional information about this routine is available in the
0: 			// bug notes for DERBY-125:
0: 			// http://issues.apache.org/jira/browse/DERBY-125
0: 			
0: 			// mark passOne to help with calculating the length of the final (first or
0: 			// rightmost) continuation header.
0: 			boolean passOne = true;
0: 			do {
0: 				// calculate chunk of data to shift
0: 				int dataToShift = bytesRequiringContDssHeader % 32765;
0: 				if (dataToShift == 0)
0: 					dataToShift = 32765;
0: 				int startOfCopyData = dataByte - dataToShift + 1;
0: 				System.arraycopy(bytes,startOfCopyData, bytes, 
0: 								 startOfCopyData + shiftSize, dataToShift);
0: 				dataByte -= dataToShift;
0: 				// calculate the value the value of the 2 byte continuation dss
0: 				// header which includes the length of itself.  On the first pass,
0: 				// if the length is 32767
0: 				// we do not want to set the continuation dss header flag.
0: 				int twoByteContDssHeader = dataToShift + 2;
0: 				if (passOne)
0: 					passOne = false;
0: 				else
0: 				{
0: 					if (twoByteContDssHeader == DssConstants.MAX_DSS_LENGTH)
0: 					twoByteContDssHeader = (twoByteContDssHeader |
0: 						DssConstants.CONTINUATION_BIT);
0: 				}
0: 				// insert the header's length bytes
0: 				bytes[dataByte + shiftSize - 1] = (byte)
0: 					((twoByteContDssHeader >>> 8) & 0xff);
0: 				bytes[dataByte + shiftSize] = (byte)
0: 					(twoByteContDssHeader & 0xff);
0: 				// adjust the bytesRequiringContDssHeader and the amount to shift for
0: 				// data in upstream headers.
0: 				bytesRequiringContDssHeader -= dataToShift;
0: 				shiftSize -= 2;
0: 				// shift and insert another header for more data.
0: 			}
0: 			while (bytesRequiringContDssHeader > 0);
0: 			// set the continuation dss header flag on for the first header
0: 			totalSize = (DssConstants.MAX_DSS_LENGTH |
0: 					DssConstants.CONTINUATION_BIT);
0: 		}
0: 		// insert the length bytes in the 6 byte dss header.
0: 		bytes[dssLengthLocation] = (byte) ((totalSize >>> 8) & 0xff);
0: 		bytes[dssLengthLocation + 1] = (byte) (totalSize & 0xff);
0: 	}
0: 	protected void writeExtendedLength(long size)
0: 	{
0: 		int numbytes = calculateExtendedLengthByteCount(size);
0: 		if (size > 0)
0: 			writeInt(0x8000 | numbytes);
0: 		else
0: 			writeInt(numbytes);
0: 	}
0: 	/**
0: 	 * Calculate extended length byte count which follows the DSS header
0: 	 * for extended DDM.
0: 	 *
0: 	 * @param ddmSize - size of DDM command
0: 	 * @return minimum number of extended length bytes needed. 0 indicates no
0: 	 * 	extended length needed.
0: 	 */
0: 	private int calculateExtendedLengthByteCount (long ddmSize)
0: 	{
0: 		if (ddmSize <= 0x7fff)
0: 			return 0;
0: 		// JCC does not support 2 at this time, so we always send
0: 		// at least 4
0: 		//		else if (ddmSize <= 0xffff)
0: 		//	return 2;
0: 		else if (ddmSize <= 0xffffffffL)
0: 			return 4;
0: 		else if (ddmSize <= 0xffffffffffffL)
0: 			return 6;
0: 		else if (ddmSize <= 0x7fffffffffffffffL)
0: 			return 8;
0: 		else
0: 			// shouldn't happen
0: 			// XXX - add sanity debug stuff here
0: 			return 0;
0: 	}
0: 	/**
0: 	 * Ensure that there is space in the buffer
0: 	 *
0: 	 * @param length space required
0: 	 */
0: 	private void ensureLength (int length)
0: 	{
0: 		length += offset;
0: 		if (length > bytes.length) {
0: 			if (SanityManager.DEBUG)
0: 			{
0: 				agent.trace("DANGER - Expensive expansion of  buffer");
0: 			}
0: 			byte newBytes[] = new byte[Math.max (bytes.length << 1, length)];
0: 			System.arraycopy (bytes, 0, newBytes, 0, offset);
0: 			bytes = newBytes;
0: 		}
0: 	}
0: 	/**
0: 	 * Write a Java <code>java.math.BigDecimal</code> to packed decimal bytes.
0: 	 *
0: 	 * @param b BigDecimal to write
0: 	 * @param precision Precision of decimal or numeric type
0: 	 * @return length written.
0: 	 *
0: 	 * @exception SQLException Thrown if # digits > 31
0: 	 */
0: 	private int bigDecimalToPackedDecimalBytes (java.math.BigDecimal b,
0: 												int precision, int scale)
0: 	throws SQLException
0: 	{
0: 		int declaredPrecision = precision;
0: 		int declaredScale = scale;
0: 		// packed decimal may only be up to 31 digits.
0: 		if (declaredPrecision > 31) // this is a bugcheck only !!!
0: 		{
0: 			clearDdm ();
0: 			throw new java.sql.SQLException ("Packed decimal may only be up to 31 digits!");
0: 		}
0: 		// get absolute unscaled value of the BigDecimal as a String.
0: 		String unscaledStr = b.unscaledValue().abs().toString();
0: 		// get precision of the BigDecimal.
0:   	    int bigPrecision = unscaledStr.length();
0: 		if (bigPrecision > 31)
0: 		{
0: 			clearDdm ();
0:   		    throw new SQLException ("The numeric literal \"" +
0:                              b.toString() +
0:                              "\" is not valid because its value is out of range.",
0:                              "42820",
0:                              -405);
0: 		}
0:     	int bigScale = b.scale();
0:   	    int bigWholeIntegerLength = bigPrecision - bigScale;
0: 	    if ( (bigWholeIntegerLength > 0) && (!unscaledStr.equals ("0")) ) {
0:             if (bigWholeIntegerLength > declaredWholeIntegerLength)
0: 			{
0: 				clearDdm ();
0:                                        b.toString() +
0:                                        "\".",
0:                                        "22003",
0:                                        -413);
0: 			}
/////////////////////////////////////////////////////////////////////////
0:           // If target scale is less than source scale,
0:           // discard excessive fraction.
0:           // set start index in source big decimal to ignore excessive fraction.
0:           bigIndex = bigPrecision-1-(bigScale-declaredScale);
0:           if (bigIndex < 0) {
0:             // all digits are discarded, so only process the sign nybble.
0:               (byte) ( (b.signum()>=0)?12:13 ); // sign nybble
0:           }
0:           else {
0:             // process the last nybble together with the sign nybble.
0:             bytes[offset+(packedIndex+1)/2] =
0:               (byte) ( ( (unscaledStr.charAt(bigIndex)-zeroBase) << 4 ) + // last nybble
0:                      ( (b.signum()>=0)?12:13 ) ); // sign nybble
0:           }
0:           packedIndex-=2;
0:           bigIndex-=2;
0:         }
0:         else {
0:           // If target scale is greater than source scale,
0:           // pad the fraction with zero.
0:           // set start index in source big decimal to pad fraction with zero.
0:           bigIndex = declaredScale-bigScale-1;
0:           // process the sign nybble.
0:           bytes[offset+(packedIndex+1)/2] =
0:             (byte) ( (b.signum()>=0)?12:13 ); // sign nybble
0:           for (packedIndex-=2, bigIndex-=2; bigIndex>=0; packedIndex-=2, bigIndex-=2)
0:             bytes[offset+(packedIndex+1)/2] = (byte) 0;
0: 
0:           if (bigIndex == -1) {
0:             bytes[offset+(packedIndex+1)/2] =
0:               (byte) ( (unscaledStr.charAt(bigPrecision-1)-zeroBase) << 4 ); // high nybble
0: 
0:             packedIndex-=2;
0:             bigIndex = bigPrecision-3;
0:           }
0:           else {
0:             bigIndex = bigPrecision-2;
0:           }
0:           bytes[offset+(packedIndex+1)/2] =
0:             (byte) ( ( (unscaledStr.charAt(bigIndex)-zeroBase) << 4 ) + // high nybble
0:                    ( unscaledStr.charAt(bigIndex+1)-zeroBase ) ); // low nybble
0:           bytes[offset+(packedIndex+1)/2] =
0:             (byte) (unscaledStr.charAt(0) - zeroBase);
0:           packedIndex-=2;
0:           bytes[offset+(packedIndex+1)/2] = (byte) 0;
0: 	}
0: 	/***
0: 	 * Prepend zeros to numeric string
0: 	 *
0: 	 * @param s string
0: 	 * @param precision - length of padded string
0:  	 *
0: 	 * @return zero padded string
0: 	 */
0: 	public static String zeroPadString(String s, int precision)
0: 	{
0: 		if (s == null)
0: 			return s;
0: 		int slen = s.length();
0: 		if (precision == slen)
0: 			return s;
0: 		else if (precision > slen)
0: 		{
0: 			char[] ca  = new char[precision - slen];
0: 			Arrays.fill(ca,0,precision - slen,'0');
0: 			return new String(ca) + s;
0: 		}
0: 		else
0: 		{
0: 			// Shouldn't happen but just in case 
0: 			// truncate
0: 			return s.substring(0,precision);
0: 		}
0: 	}
0: 	throws java.io.IOException{
0: 	
0: 	sendBytes(socketOutputStream,
0: 		  true);
0: 	
1:   private void sendBytes (java.io.OutputStream socketOutputStream,
0: 			  boolean flashStream ) 
0:       throws java.io.IOException
0:   {
0: 	resetChainState();
0:     try {
0:       socketOutputStream.write (bytes, 0, offset);
1:       if(flashStream)
0: 	  socketOutputStream.flush();
0:     finally {
0: 		if ((dssTrace != null) && dssTrace.isComBufferTraceOn()) {
0: 			dssTrace.writeComBufferData (bytes,
0: 			                               0,
0: 			                               offset,
0: 			                               DssTrace.TYPE_TRACE_SEND,
0: 			                               "Reply",
0: 			                               "flush",
0: 			                               5);
0:       }
0:       clearBuffer();
0:   }
0: 	protected String toDebugString(String indent)
0: 	{
0: 		String s = indent + "***** DDMWriter toDebugString ******\n";
0: 		int byteslen = 0;
0: 		if ( bytes != null)
0: 			byteslen = bytes.length;
0: 		s += indent + "byte array length  = " + bytes.length + "\n";
0: 		return s;
0: 	}
0: 	/**
0: 	 * Reset any chaining state that needs to be reset
0: 	 * at time of the send
0: 	 */
0: 	protected void resetChainState()
0: 	{
0: 		prevHdrLocation = -1;
0: 	}
0: 	/**
0: 	 * Looks at chaining info for previous DSS written, and use
0: 	 * that to figure out what the correlation id for the current
0: 	 * DSS should be.  Return that correlation id.
0: 	 */
0: 	private int getCorrelationID() {
0: 		int cId;
0: 		if (previousCorrId != DssConstants.CORRELATION_ID_UNKNOWN) {
0: 			if (previousChainByte == DssConstants.DSSCHAIN_SAME_ID)
0: 			// then we have to use the last correlation id we sent.
0: 				cId = previousCorrId;
0: 			else
0: 			// get correlation id as normal.
0: 				cId = nextCorrelationID++;
0: 		}
0: 		else {
0: 		// must be the case that this is the first DSS we're
0: 		// writing for this connection (because we haven't
0: 		// called "endDss" yet).  So, get the corr id as
0: 		// normal.
0: 			cId = nextCorrelationID++;
0: 		}
0: 		return cId;
0: 	}
0: 	/**
0: 	 * Finalize the current DSS chain and send it if
0: 	 * needed.
0: 	 *
0: 	 * Updates the chaining state of the most recently-written-
0: 	 * to-buffer DSS to correspond to the most recently-read-
0: 	 * from-client request.  If that chaining state indicates
0: 	 * we've reached the end of a chain, then we go ahead
0: 	 * and send the buffer across the wire.
0: 	 * @param socketOutputStream Output stream to which we're flushing.
0: 	 */
0: 	protected void finalizeChain(byte currChainByte,
0: 		OutputStream socketOutputStream) throws DRDAProtocolException
0: 	{
0: 		// Go back to previous DSS and override the default
0: 		// chain state (WITH_SAME_ID) with whatever the last
0: 		// request dictates.
0: 		if (prevHdrLocation != -1) {
0: 		// Note: == -1 => the previous DSS was already sent; this
0: 		// should only happen in cases where the buffer filled up
0: 		// and we had to send it (which means we were probably
0: 		// writing EXTDTA).  In such cases, proper chaining
0: 		// should already have been handled @ time of send.
0: 			bytes[prevHdrLocation + 3] &= 0x0F;	// Zero out old chain value.
0: 			bytes[prevHdrLocation + 3] |= currChainByte;
0: 		}
0: 		// previousChainByte needs to match what we just did.
0: 		previousChainByte = currChainByte;
0: 		if (currChainByte != DssConstants.DSS_NOCHAIN)
0: 		// then we're still inside a chain, so don't send.
0: 			return;
0: 		// Else, we just ended the chain, so send it across.
0: 		if ((SanityManager.DEBUG) && (agent != null))
0: 			agent.trace("Sending data");
0: 		resetChainState();
0: 		if (doesRequestContainData()) {
0: 			try {
0: 				flush(socketOutputStream);
0: 			} catch (java.io.IOException e) {
0: 				agent.markCommunicationsFailure(
0: 					"DDMWriter.finalizeChain()",
0: 					"OutputStream.flush()",
0: 					e.getMessage(),"*");
0: 			}
0: 		}
0: 	}
0: 	/**
0: 	 * Takes note of the location of the most recently completed
0: 	 * DSS in the buffer, and then returns the current offset.
0: 	 * This method is used in conjunction with "clearDSSesBackToMark"
0: 	 * to allow for DRDAConnThread to "back-out" DSSes in the
0: 	 * event of errors.
0: 	 */
0: 	protected int markDSSClearPoint()
0: 	{
0: 		lastDSSBeforeMark = prevHdrLocation;
0: 		return offset;
0: 	}
0: 	/**
0: 	 * Does a logical "clear" of everything written to the buffer after
0: 	 * the received mark.  It's assumed that this method will be used
0: 	 * in error cases when we've started writing one or more DSSes,
0: 	 * but then hit an error and need to back out.  After backing out,
0: 	 * we'll always need to write _something_ back to the client to
0: 	 * indicate an error (typically, we just write an SQLCARD) but what
0: 	 * exactly gets written is handled in DRDAConnThread.  Here, we
0: 	 * just do the necessary prep so that whatever comes next will
0: 	 * succeed.
0: 	 */
0: 	protected void clearDSSesBackToMark(int mark)
0: 	{
0: 		// Logical clear.
0: 		offset = mark;
0: 		// Because we've just cleared out the most recently-
0: 		// written DSSes, we have to make sure the next thing
0: 		// we write will have the correct correlation id.  We
0: 		// do this by setting the value of 'nextCorrelationID'
0: 		// based on the chaining byte from the last remaining
0: 		// DSS (where "remaining" means that it still exists
0: 		// in the buffer after the clear).
0: 		if (lastDSSBeforeMark == -1)
0: 		// we cleared out the entire buffer; reset corr id.
0: 			nextCorrelationID = 1;
0: 		else {
0: 		// last remaining DSS had chaining, so we set "nextCorrelationID"
0: 		// to be 1 greater than whatever the last remaining DSS had as
0: 		// its correlation id.
0:  			nextCorrelationID = 1 + (int)
0: 				(((bytes[lastDSSBeforeMark + 4] & 0xff) << 8) +
0: 				(bytes[lastDSSBeforeMark + 5] & 0xff));
0: 		}
0: 	}
0: 	
1:     private static int peekStream(InputStream in) throws IOException{
0: 	    
0: 	in.mark(1);
0: 
0: 	try{
0: 	    return in.read();
0: 	    
0: 	}finally{
0: 	    in.reset();
0: 	    
0: 	}
0: 	return PropertyUtil.getSystemInt( Property.DRDA_PROP_STREAMOUTBUFFERSIZE , 0 );
0: 	
0: 	int size = getLayerBStreamingBufferSize();
0: 	
0: 	if(size < 1)
0: 	    return original;
0: 	else
0: 	    return new BufferedOutputStream( original, size );
commit:d2989b7
/////////////////////////////////////////////////////////////////////////
0: class DDMWriter {
0:     
/////////////////////////////////////////////////////////////////////////
0:     //  This Object tracks the location of the current
0:     //  Dss header length bytes.        This is done so
0:     //  the length bytes can be automatically
0:     //  updated as information is added to this stream.
0:     private     int correlationID;
/////////////////////////////////////////////////////////////////////////
0:     DDMWriter (int minSize, CcsidManager ccsidManager, DRDAConnThread agent, DssTrace dssTrace) {
0:         this.bytes = new byte[minSize];
0:         this.ccsidManager = ccsidManager;
0:         this.agent = agent;
0:         this.prevHdrLocation = -1;
0:         this.previousCorrId = DssConstants.CORRELATION_ID_UNKNOWN;
0:         this.previousChainByte = DssConstants.DSS_NOCHAIN;
0:         this.isContinuationDss = false;
0:         this.lastDSSBeforeMark = -1;
0:         reset(dssTrace);
0:     DDMWriter (CcsidManager ccsidManager, DRDAConnThread agent, DssTrace dssTrace) {
0:         this.bytes = new byte[DEFAULT_BUFFER_SIZE];
0:         this.ccsidManager = ccsidManager;
0:         this.agent = agent;
0:         this.prevHdrLocation = -1;
0:         this.previousCorrId = DssConstants.CORRELATION_ID_UNKNOWN;
0:         this.previousChainByte = DssConstants.DSS_NOCHAIN;
0:         this.isContinuationDss = false;
0:         this.lastDSSBeforeMark = -1;
0:         reset(dssTrace);
0:     protected void reset(DssTrace dssTrace) {
0:         offset = 0;
0:         top = 0;
0:         dssLengthLocation = 0;
0:         nextCorrelationID = 1;
0:         correlationID = DssConstants.CORRELATION_ID_UNKNOWN;
0:         isDRDAProtocol = true;
0:         this.dssTrace = dssTrace;
0:     protected void setCMDProtocol() {
0:         isDRDAProtocol = false;
0:     protected void createDssReply() {
0:         beginDss(DssConstants.DSSFMT_RPYDSS, true);
/////////////////////////////////////////////////////////////////////////
0:     protected void createDssRequest() {
0:         beginDss(DssConstants.DSSFMT_RQSDSS, true);
0:     protected void createDssObject() {
0:         beginDss(DssConstants.DSSFMT_OBJDSS, true);
/////////////////////////////////////////////////////////////////////////
0:      *  1. One or more continuation DSSes will immediately
0:      *          follow the current (continued) DSS.
0:      *  2. All continuation DSSes will have a 2-byte
0:      *          continuation header, followed by data; in
0:      *          other words, chaining state, correlation
0:      *          id, dss format info, and code point will
0:      *          NOT be included.  All of that info is 
0:      *          present ONLY in the FIRST DSS in the
0:      *          list of continued DSSes.
0:      *  NOTE: A DSS can be a "continuation" DSS _and_
0:      *  a "continued" DSS at the same time.  However,
0:      *  the FIRST DSS to be continued canNOT be
0:      *  a continuation DSS.
0:     private void markDssAsContinued(boolean forLob) {
0:         if (!forLob) {
0:             // continuation bit defaults to '1' for lobs, so
0:             // we only have to switch it if we're not writing
0:             // lobs.
0:             bytes[dssLengthLocation] |= 0x80;
0:         }
0:         // We need to set the chaining state, but ONLY
0:         // IF this is the FIRST DSS in the continuation
0:         // list (only the first one has chaining state
0:         // in it's header; the others do not).
0:         if (!isContinuationDss)
0:             endDss(!forLob);
/////////////////////////////////////////////////////////////////////////
0:     protected void endDss(byte chainByte) {
0:         // Do regular endDss processing.
0:         endDss(true);
0:         // Now override default chain state.
0:         bytes[dssLengthLocation + 3] &= 0x0F;   // Zero out default
0:         bytes[dssLengthLocation + 3] |= chainByte;
0:         previousChainByte = chainByte;
/////////////////////////////////////////////////////////////////////////
0:         endDss(true);
0:     private void endDss (boolean finalizeLength) {
0:         if (finalizeLength)
0:             finalizeDssLength();
0:         if (isContinuationDss) {
0:             // no chaining information for this DSS; so we're done.
0:             isContinuationDss = false;
0:             return;
0:         }
0:         previousCorrId = correlationID;
0:         prevHdrLocation = dssLengthLocation;
0:         previousChainByte = DssConstants.DSSCHAIN_SAME_ID;
/////////////////////////////////////////////////////////////////////////
0:     protected void endDdmAndDss () {
0:         endDdm();       // updates last DDM object
0:         endDss();
/////////////////////////////////////////////////////////////////////////
0:     protected byte [] copyDSSDataToEnd(int start) {
0:         start = start + dssLengthLocation;
0:         int length = offset - start;
0:         byte [] temp = new byte[length];
0:         System.arraycopy(bytes,start,temp,0,length);
0:         return temp;
/////////////////////////////////////////////////////////////////////////
0:     protected void startDdm (int codePoint) {
0:         // save the location of the beginning of the collection so
0:         // that we can come back and fill in the length bytes
0:         markStack[top++] = offset;
0:         ensureLength (4); // verify space for length bytes and code point
0:         offset += 2; // move past the length bytes before writing the code point
0:         bytes[offset] = (byte) ((codePoint >>> 8) & 0xff);
0:         bytes[offset + 1] = (byte) (codePoint & 0xff);
0:         offset += 2;
0:     protected void clearDdm () {
0:         offset = markStack[top--];
0:     protected void clearBuffer() {
0:         offset = 0;
0:         top = 0;
0:         dssLengthLocation = 0;
0:         correlationID = DssConstants.CORRELATION_ID_UNKNOWN;
0:         nextCorrelationID = 1;
0:         isDRDAProtocol = true;
0:     protected void endDdm () {
0:         // remove the top length location offset from the mark stack
0:         // calculate the length based on the marked location and end of data.
0:         int lengthLocation = markStack[--top];
0:         int length = offset - lengthLocation;
0:         // determine if any extended length bytes are needed.   the value returned
0:         // from calculateExtendedLengthByteCount is the number of extended length
0:         // bytes required. 0 indicates no exteneded length.
0:         int extendedLengthByteCount = calculateExtendedLengthByteCount (length);
0:         if (extendedLengthByteCount != 0) {
0:             // ensure there is enough room in the buffer for the extended length bytes.
0:             ensureLength (extendedLengthByteCount);
0:             // calculate the length to be placed in the extended length bytes.
0:             // this length does not include the 4 byte llcp.
0:             int extendedLength = length - 4;
0:             // shift the data to the right by the number of extended
0:             // length bytes needed.
0:             int extendedLengthLocation = lengthLocation + 4;
0:             System.arraycopy (bytes,
0:                               extendedLengthLocation,
0:                               bytes,
0:                               extendedLengthLocation + extendedLengthByteCount,
0:                               extendedLength);
0:             // write the extended length
0:             int shiftSize = (extendedLengthByteCount -1) * 8;
0:             for (int i = 0; i < extendedLengthByteCount; i++) {
0:                 bytes[extendedLengthLocation++] =
0:                     (byte) ((extendedLength >>> shiftSize ) & 0xff);
0:                 shiftSize -= 8;
0:             }
0:             // adjust the offset to account for the shift and insert
0:             offset += extendedLengthByteCount;
0:             // the two byte length field before the codepoint contains the length
0:             // of itself, the length of the codepoint, and the number of bytes used
0:             // to hold the extended length.     the 2 byte length field also has the first
0:             // bit on to indicate extended length bytes were used.
0:             length = extendedLengthByteCount + 4;
0:             length |= DssConstants.CONTINUATION_BIT;
0:         }
0:         // write the 2 byte length field (2 bytes before codepoint).
0:         bytes[lengthLocation] = (byte) ((length >>> 8) & 0xff);
0:         bytes[lengthLocation+1] = (byte) (length & 0xff);
/////////////////////////////////////////////////////////////////////////
0:     protected int getDSSLength() {
/////////////////////////////////////////////////////////////////////////
0:     protected void truncateDSS(int value) {
/////////////////////////////////////////////////////////////////////////
0:      * @param   value   byte to be written
0:     protected void writeByte (int value) {
0:         if (SanityManager.DEBUG) {
0:             if (value > 255)
0:                 SanityManager.THROWASSERT(
0:                                           "writeByte value: " + value +
0:                                           " may not be > 255");
0:         }
0:         ensureLength (1);
0:         bytes[offset++] = (byte) (value & 0xff);
0:      * @param   value   value to be written
0:     protected void writeNetworkShort (int value) {
0:         ensureLength (2);
0:         bytes[offset] = (byte) ((value >>> 8) & 0xff);
0:         bytes[offset + 1] = (byte) (value & 0xff);
0:         offset += 2;
0:      * @param   value   value to be written
0:     protected void writeNetworkInt (int value) {
0:         ensureLength (4);
0:         bytes[offset] = (byte) ((value >>> 24) & 0xff);
0:         bytes[offset + 1] = (byte) ((value >>> 16) & 0xff);
0:         bytes[offset + 2] = (byte) ((value >>> 8) & 0xff);
0:         bytes[offset + 3] = (byte) (value & 0xff);
0:         offset += 4;
0:      * @param   buf     byte array to be written
0:      * @param   length  - length to write
0:     protected void writeBytes (byte[] buf, int length) {
0:         writeBytes(buf, 0,length);
/////////////////////////////////////////////////////////////////////////
0:      * @param   buf     byte array to be written
0:      * @param   start  - starting position
0:      * @param   length  - length to write
0:     protected void writeBytes (byte[] buf, int start, int length) {
0:         if (SanityManager.DEBUG) {
0:             if (buf == null && length > 0)
0:                 SanityManager.THROWASSERT("Buf is null");
0:             if (length + start - 1 > buf.length)
0:                 SanityManager.THROWASSERT("Not enough bytes in buffer");
0:         }
0:         ensureLength (length);
0:         System.arraycopy(buf,start,bytes,offset,length);
0:         offset += length;
0:      * @param   buf     byte array to be written
0:     protected void writeBytes (byte[] buf) {
0:         writeBytes(buf,buf.length);
0:     protected void writeLDBytes(byte[] buf) {
0:         writeLDBytes(buf, 0);
0:     protected void writeLDBytes(byte[] buf, int index) {
0:         int length = buf.length;
0:         int writeLen =  buf.length;
0:         writeShort(writeLen);
0:         writeBytes(buf,0,writeLen);
0:      * @param   codePoint - code point to write
0:      * @param   value  - value to write after code point
0:     void writeCodePoint4Bytes (int codePoint, int value) {
0:         ensureLength (4);
0:         bytes[offset] = (byte) ((codePoint >>> 8) & 0xff);
0:         bytes[offset + 1] = (byte) (codePoint & 0xff);
0:         bytes[offset + 2] = (byte) ((value >>> 8) & 0xff);
0:         bytes[offset + 3] = (byte) (value & 0xff);
0:         offset += 4;
0:      * @param   codePoint - code point to write
0:      * @param   value  - value to write after code point
0:     void writeScalar1Byte (int codePoint, int value) {
0:         ensureLength (5);
0:         bytes[offset] = 0x00;
0:         bytes[offset + 1] = 0x05;
0:         bytes[offset + 2] = (byte) ((codePoint >>> 8) & 0xff);
0:         bytes[offset + 3] = (byte) (codePoint & 0xff);
0:         bytes[offset + 4] = (byte) (value & 0xff);
0:         offset += 5;
0:      * @param   codePoint - code point to write
0:      * @param   value  - value to write after code point
0:     protected void writeScalar2Bytes (int codePoint, int value) {
0:         ensureLength (6);
0:         bytes[offset] = 0x00;
0:         bytes[offset + 1] = 0x06;
0:         bytes[offset + 2] = (byte) ((codePoint >>> 8) & 0xff);
0:         bytes[offset + 3] = (byte) (codePoint & 0xff);
0:         bytes[offset + 4] = (byte) ((value >>> 8) & 0xff);
0:         bytes[offset + 5] = (byte) (value & 0xff);
0:         offset += 6;
0:     protected void writeScalar2Bytes ( int value) {
0:         ensureLength (2);
0:         bytes[offset] = (byte) ((value >>> 8) & 0xff);
0:         bytes[offset + 1] = (byte) (value & 0xff);
0:         offset += 2;
0:      * @param   length - length of object
0:      * @param   codePoint - code point to write
0:     protected void startDdm (int length, int codePoint) {
0:         ensureLength (4);
0:         bytes[offset] = (byte) ((length >>> 8) & 0xff);
0:         bytes[offset + 1] = (byte) (length & 0xff);
0:         bytes[offset + 2] = (byte) ((codePoint >>> 8) & 0xff);
0:         bytes[offset + 3] = (byte) (codePoint & 0xff);
0:         offset += 4;
0:      * @param   codePoint - code point to write
0:      * @param   buf  - value to write after code point
0:      * @param   length - number of bytes to write
0:     protected void writeScalarBytes (int codePoint, byte[] buf, int length) {
0:         if (SanityManager.DEBUG) {
0:             if (buf == null && length > 0)
0:                 SanityManager.THROWASSERT("Buf is null");
0:             if (length > buf.length)
0:                 SanityManager.THROWASSERT("Not enough bytes in buffer");
0:         }
0:         ensureLength (length + 4);
0:         bytes[offset] = (byte) (((length+4) >>> 8) & 0xff);
0:         bytes[offset + 1] = (byte) ((length+4) & 0xff);
0:         bytes[offset + 2] = (byte) ((codePoint >>> 8) & 0xff);
0:         bytes[offset + 3] = (byte) (codePoint & 0xff);
0:         System.arraycopy(buf,0,bytes,offset + 4, length);
0:         offset += length + 4;
0:                                       int codePoint,
0:                                       EXTDTAInputStream in,
0:                                       boolean writeNullByte) 
0:         throws DRDAProtocolException {
0:         
0:         // Stream equivalent of "beginDss"...
0:         int spareDssLength = prepScalarStream( chainedWithSameCorrelator,
0:                                                codePoint,
0:                                                writeNullByte);
0:             
0:         // write the data
0:         int bytesRead = 0;
0:         int totalBytesRead = 0;
0:         try {
0:                                     
0:             OutputStream out = 
0:                 placeLayerBStreamingBuffer( agent.getOutputStream() );
0:                 
0:             boolean isLastSegment = false;
0:                 
0:             while( !isLastSegment ){
0:                     
0:                 int spareBufferLength = bytes.length - offset;
0:                     
0:                 if( SanityManager.DEBUG ){
0:                 
0:                     if( PropertyUtil.getSystemProperty("derby.debug.suicideOfLayerBStreaming") != null )
0:                         throw new IOException();
0:                 }
0:                     
0:                 bytesRead = in.read(bytes,
0:                                     offset,
0:                                     Math.min(spareDssLength,
0:                                              spareBufferLength));
0:                     
0:                 totalBytesRead += bytesRead;
0:                 offset += bytesRead;
0:                 spareDssLength -= bytesRead;
0:                 spareBufferLength -= bytesRead;
0:                 isLastSegment = peekStream(in) < 0;
0:                     
0:                 if(isLastSegment || 
0:                    spareDssLength == 0){
0:                         
0:                     flushScalarStreamSegment (isLastSegment, 
0:                                               out);
0:                         
0:                     if( ! isLastSegment )
0:                         spareDssLength = DssConstants.MAX_DSS_LENGTH - 2;
0:                 }
0:                     
0:             }
0:                 
0:             out.flush();
0:                 
0:         }catch(IOException e){
0:             agent.markCommunicationsFailure ("DDMWriter.writeScalarStream()",
0:                                              "",
0:                                              e.getMessage(),
0:                                              "*");
0:         }
0:                                 
0:         
0:                            int dssType) {
0:         beginDss(dssType, false);       // false => don't ensure length.
0:         // always turn on continuation flags... this is helpful for lobs...
0:         // these bytes will get rest if dss lengths are finalized.
0:         bytes[dssLengthLocation] = (byte) 0xFF;
0:         bytes[dssLengthLocation + 1] = (byte) 0xFF;
0:         // Set whether or not this DSS should be chained to
0:         // the next one.  If it's chained, it has to be chained
0:         // with same id (that's the nature of EXTDTA chaining).
0:         if (chainedToNextStructure) {
0:             dssType |= DssConstants.GDSCHAIN_SAME_ID;
0:         }
0:         bytes[dssLengthLocation + 3] = (byte) (dssType & 0xff);
/////////////////////////////////////////////////////////////////////////
0:                                   int codePoint,
0:                                   boolean writeNullByte) 
0:         throws DRDAProtocolException {
0:         ensureLength( DEFAULT_BUFFER_SIZE - offset );
0:         final int nullIndicatorSize = writeNullByte ? 1:0;
0:         // flush the existing DSS segment ,
0:         // if this stream will not fit in the send buffer or 
0:         // length of this stream is unknown.
0:         // Here, 10 stands for sum of headers of layer A and B.
0:         try {
0:             // The existing DSS segment was finalized by endDss; all
0:             // we have to do is send it across the wire.
0:             sendBytes(agent.getOutputStream());
0:         } catch (java.io.IOException e) {
0:             agent.markCommunicationsFailure ("DDMWriter.writeScalarStream()",
0:                                              "OutputStream.flush()",
0:                                              e.getMessage(),"*");
0:         }
0:         // buildStreamDss should not call ensure length.
0:         beginDss(chainedWithSameCorrelator, DssConstants.GDSFMT_OBJDSS);
0:         writeLengthCodePoint(0x8004,codePoint);
0:         // write the null byte, if necessary
0:         if (writeNullByte)
0:             writeByte(0x0);
0:         //Here, 6 stands for header of layer A and 
0:         //4 stands for header of layer B.
0:         return DssConstants.MAX_DSS_LENGTH - 6 - 4 - nullIndicatorSize;
/////////////////////////////////////////////////////////////////////////
0:     protected boolean doesRequestContainData() {
0:         return offset != 0;
0:                                             OutputStream out)
0:         throws DRDAProtocolException {
0:         // either at end of data, end of dss segment, or both.
0:         if (! lastSegment) {
0:             // 32k segment filled and not at end of data.
0:             try {
0:                 // Mark current DSS as continued, set its chaining state,
0:                 // then send the data across.
0:                 markDssAsContinued(true);       // true => for lobs
0:                 sendBytes (out,
0:                            false);
0:                             
0:             }catch (java.io.IOException ioe) {
0:                 agent.markCommunicationsFailure ("DDMWriter.flushScalarStreamSegment()",
0:                                                  "",
0:                                                  ioe.getMessage(),
0:                                                  "*");
0:             }
0:             // Prepare a DSS continuation header for next DSS.
0:             dssLengthLocation = offset;
0:             bytes[offset++] = (byte) (0xff);
0:             bytes[offset++] = (byte) (0xff);
0:             isContinuationDss = true;
0:         }else{
0:             // we're done writing the data, so end the DSS.
0:             endDss();
0:         }
0:     private void writeExtendedLengthBytes (int extendedLengthByteCount, long length) {
0:         int shiftSize = (extendedLengthByteCount -1) * 8;
0:         for (int i = 0; i < extendedLengthByteCount; i++) {
0:             bytes[offset + i] = (byte) ((length >>> shiftSize) & 0xff);
0:             shiftSize -= 8;
0:         }
0:         offset += extendedLengthByteCount;
/////////////////////////////////////////////////////////////////////////
0:     void writeLengthCodePoint (int length, int codePoint) {
0:         ensureLength (4);
0:         bytes[offset] = (byte) ((length >>> 8) & 0xff);
0:         bytes[offset + 1] = (byte) (length & 0xff);
0:         bytes[offset + 2] = (byte) ((codePoint >>> 8) & 0xff);
0:         bytes[offset + 3] = (byte) (codePoint & 0xff);
0:         offset +=4;
0:      * @param   codePoint - code point to write
0:      * @param   dataLength - length of object data
0:     protected void writeScalarHeader (int codePoint, int dataLength) {
0:         ensureLength (dataLength + 4);
0:         bytes[offset] = (byte) (((dataLength+4) >>> 8) & 0xff);
0:         bytes[offset + 1] = (byte) ((dataLength+4) & 0xff);
0:         bytes[offset + 2] = (byte) ((codePoint >>> 8) & 0xff);
0:         bytes[offset + 3] = (byte) (codePoint & 0xff);
0:         offset += 4;
0:      * @param   codePoint - code point to write
0:      * @param   string - string to be written
0:     void writeScalarString (int codePoint, String string) {
0:         int stringLength = string.length();
0:         ensureLength ((stringLength * 2)  + 4);
0:         bytes[offset] = (byte) (((stringLength+4) >>> 8) & 0xff);
0:         bytes[offset + 1] = (byte) ((stringLength+4) & 0xff);
0:         bytes[offset + 2] = (byte) ((codePoint >>> 8) & 0xff);
0:         bytes[offset + 3] = (byte) (codePoint & 0xff);
0:         offset = ccsidManager.convertFromUCS2 (string, bytes, offset + 4);
0:      * @param   codePoint - code point to write
0:      * @param   string - string to be written
0:      * @param   paddedLength - length to pad string to
0:     void writeScalarPaddedString (int codePoint, String string, int paddedLength) {
0:         int stringLength = string.length();
0:         int fillLength = paddedLength - stringLength;
0:         ensureLength (paddedLength + 4);
0:         bytes[offset] = (byte) (((paddedLength+4) >>> 8) & 0xff);
0:         bytes[offset + 1] = (byte) ((paddedLength+4) & 0xff);
0:         bytes[offset + 2] = (byte) ((codePoint >>> 8) & 0xff);
0:         bytes[offset + 3] = (byte) (codePoint & 0xff);
0:         offset = ccsidManager.convertFromUCS2 (string, bytes, offset + 4);
0:         Arrays.fill(bytes,offset, offset + fillLength,ccsidManager.space);
0:         offset += fillLength;
0:      * @param   string - string to be written
0:      * @param   paddedLength - length to pad string to
0:     protected void writeScalarPaddedString (String string, int paddedLength) {
0:         int stringLength = string.length();
0:         int fillLength = paddedLength -stringLength;
0:         ensureLength (paddedLength);
0:         offset = ccsidManager.convertFromUCS2 (string, bytes, offset);
0:         Arrays.fill(bytes,offset, offset + fillLength,ccsidManager.space);
0:         offset += fillLength;
/////////////////////////////////////////////////////////////////////////
0:     protected void writeScalarPaddedString (DRDAString drdaString, int paddedLength) {
0:         int stringLength = drdaString.length();
0:         int fillLength = paddedLength - stringLength;
0:         ensureLength(paddedLength);
0:         System.arraycopy(drdaString.getBytes(), 0, bytes, offset, stringLength);
0:         offset += stringLength;
0:         Arrays.fill(bytes, offset, offset + fillLength, ccsidManager.space);
0:         offset += fillLength;
0:      * @param   codePoint - code point to write
0:      * @param   buf - byte array to be written
0:      * @param   paddedLength - length to pad string to
0:      * @param   padByte - byte to be used for padding
0:     protected void writeScalarPaddedBytes (int codePoint, byte[] buf, int paddedLength, byte padByte) {
0:         int bufLength = buf.length;
0:         ensureLength (paddedLength + 4);
0:         bytes[offset] = (byte) (((paddedLength+4) >>> 8) & 0xff);
0:         bytes[offset + 1] = (byte) ((paddedLength+4) & 0xff);
0:         bytes[offset + 2] = (byte) ((codePoint >>> 8) & 0xff);
0:         bytes[offset + 3] = (byte) (codePoint & 0xff);
0:         offset += 4;
0:         System.arraycopy(buf,0,bytes,offset,bufLength);
0:         offset += bufLength;
0:         int fillLength = paddedLength - bufLength;
0:         Arrays.fill(bytes,offset,offset + fillLength,padByte);
0:         offset += fillLength;
0:      * @param   buf - byte array to be written
0:      * @param   paddedLength - length to pad string to
0:      * @param   padByte - byte to be used for padding
0:     protected void writeScalarPaddedBytes (byte[] buf, int paddedLength, byte padByte) {
0:         int bufLength = buf.length;
0:         int fillLength = paddedLength - bufLength;
0:         ensureLength (paddedLength);
0:         System.arraycopy(buf,0,bytes,offset,bufLength);
0:         offset +=bufLength;
0:         Arrays.fill(bytes,offset,offset + fillLength,padByte);
0:         offset += fillLength;
0:      * @param   codePoint - code point to write
0:      * @param   buf - byte array to be written
0:     protected void writeScalarBytes (int codePoint, byte[] buf) {
0:         int bufLength = buf.length;
0:         ensureLength (bufLength + 4);
0:         bytes[offset] = (byte) (((bufLength+4) >>> 8) & 0xff);
0:         bytes[offset + 1] = (byte) ((bufLength+4) & 0xff);
0:         bytes[offset + 2] = (byte) ((codePoint >>> 8) & 0xff);
0:         bytes[offset + 3] = (byte) (codePoint & 0xff);
0:         System.arraycopy(buf,0,bytes,offset + 4,bufLength);
0:         offset += bufLength + 4;
0:      * @param   codePoint - code point to write
0:      * @param   buf - byte array to be written
0:      * @param   start - starting point
0:      * @param   length - length to write
0:     protected void writeScalarBytes (int codePoint, byte[] buf, int start, int length) {
0:         if (SanityManager.DEBUG) {
0:             if (buf == null && length > start)
0:                 SanityManager.THROWASSERT("Buf is null");
0:             if (length - start > buf.length)
0:                 SanityManager.THROWASSERT("Not enough bytes in buffer");
0:         }
0:         int numBytes = length - start;
0:         ensureLength (numBytes + 4);
0:         bytes[offset] = (byte) (((numBytes+4) >>> 8) & 0xff);
0:         bytes[offset + 1] = (byte) ((numBytes+4) & 0xff);
0:         bytes[offset + 2] = (byte) ((codePoint >>> 8) & 0xff);
0:         bytes[offset + 3] = (byte) (codePoint & 0xff);
0:         offset += 4;
0:         System.arraycopy(buf,start,bytes,offset,numBytes);
0:         offset += numBytes;
/////////////////////////////////////////////////////////////////////////
0:      * @param   v       value to be written
0:     protected void writeShort (int v) {
0:         writeNetworkShort(v);
/////////////////////////////////////////////////////////////////////////
0:     protected void writeShort(boolean b) {
0:         writeNetworkShort(b ? 1 : 0);
0:      * @param   v       value to be written
0:     protected void writeInt (int v) {
0:         writeNetworkInt(v);
0:      * @param   v       value to be written
0:     protected void writeLong (long v) {
0:         ensureLength (8);
0:         bytes[offset] = (byte) ((v >>> 56) & 0xff);
0:         bytes[offset + 1] =     (byte) ((v >>> 48) & 0xff);
0:         bytes[offset + 2] =     (byte) ((v >>> 40) & 0xff);
0:         bytes[offset + 3] =     (byte) ((v >>> 32) & 0xff);
0:         bytes[offset + 4] =     (byte) ((v >>> 24) & 0xff);
0:         bytes[offset + 5] =     (byte) ((v >>> 16) & 0xff);
0:         bytes[offset + 6] =     (byte) ((v >>>  8) & 0xff);
0:         bytes[offset + 7] =     (byte) ((v >>>  0) & 0xff);
0:         offset += 8;
0:      * @param   v       value to be written
0:     protected void writeFloat (float v) {
0:         writeInt (Float.floatToIntBits (v));
0:      * @param   v       value to be written
0:     protected void writeDouble (double v) {
0:         writeLong (Double.doubleToLongBits (v));
/////////////////////////////////////////////////////////////////////////
0:         throws SQLException {
0:         int length = precision / 2 + 1;
0:         ensureLength (offset + length);
0:         bigDecimalToPackedDecimalBytes (v,precision, scale);
0:         offset += length;
0:      * @param   v       value to be written
0:     protected void writeBoolean (boolean v) {
0:         ensureLength (1);
0:         bytes[offset++] = (byte) ((v ? 1 : 0) & 0xff);
/////////////////////////////////////////////////////////////////////////
0:     protected void writeLDString(String s) throws DRDAProtocolException {
0:         writeLDString(s,0);
/////////////////////////////////////////////////////////////////////////
0:     protected void writeLDString(String s, int index) 
0:         throws DRDAProtocolException {
0:         try {
0:             byte [] byteval = s.getBytes(NetworkServerControlImpl.DEFAULT_ENCODING);
0:             int origLen = byteval.length;
0:             boolean multiByteTrunc = false;
0:             int writeLen =
0:                 java.lang.Math.min(FdocaConstants.LONGVARCHAR_MAX_LEN,
0:                                    origLen);
0:             /*
0:               Need to make sure we truncate on character boundaries.
0:               We are assuming
0:               http://www.sun.com/developers/gadc/technicalpublications/articles/utf8.html
0:               To find the beginning of a multibyte character:
0:               1) Does the current byte start with the bit pattern 10xxxxxx?
0:               2) If yes, move left and go to step #1.
0:               3) Finished
0:               We assume that NetworkServerControlImpl.DEFAULT_ENCODING remains UTF-8
0:             */
0:             if (SanityManager.DEBUG) {
0:                 if (!(NetworkServerControlImpl.DEFAULT_ENCODING.equals("UTF8")))
0:                     SanityManager.THROWASSERT("Encoding assumed to be UTF8, but is actually" + NetworkServerControlImpl.DEFAULT_ENCODING);
0:             }
0:             if (writeLen != origLen)
0:                 // first position on the first byte of the multibyte char
0:                 while ((byteval[writeLen -1] & 0xC0) == 0x80) {
0:                     multiByteTrunc = true;
0:                     writeLen--;
0:                     // Then subtract one more to get to the end of the
0:                     // previous character
0:                     if (multiByteTrunc == true) {
0:                         writeLen = writeLen -1;
0:                     }
0:                 }
0:             writeShort(writeLen);
0:             writeBytes(byteval,writeLen);
0:         } catch (Exception e) {
0:             //this should never happen
0:             agent.agentError("Encoding " + NetworkServerControlImpl.DEFAULT_ENCODING + " not supported");
0:         }
/////////////////////////////////////////////////////////////////////////
0:     protected void writeString(String s) throws DRDAProtocolException {
0:         try {
0:             writeBytes(s.getBytes(NetworkServerControlImpl.DEFAULT_ENCODING));
0:         } catch (Exception e) {
0:             //this should never happen
0:             agent.agentError("Encoding " + NetworkServerControlImpl.DEFAULT_ENCODING + " not supported");
0:         }
/////////////////////////////////////////////////////////////////////////
0:     protected void writeString(String s, int length) throws DRDAProtocolException {
0:         byte[] bs = null;
0:         try {
0:             bs = s.getBytes(NetworkServerControlImpl.DEFAULT_ENCODING);
0:         } catch (Exception e) {
0:             //this should never happen
0:             agent.agentError("Encoding " + NetworkServerControlImpl.DEFAULT_ENCODING + " not supported");
0:         }
0:         int len = bs.length;
0:         if (len >= length)
0:             writeBytes(bs, length);
0:         else {
0:             writeBytes(bs);
0:             padBytes(NetworkServerControlImpl.SPACE_CHAR, length-len);
0:         }
0:      * @param   val     value to be written
0:      * @param   length          length to be written
0:     protected void padBytes (byte val, int length) {
0:         Arrays.fill(bytes,offset, offset + length,val);
0:         offset += length;
/////////////////////////////////////////////////////////////////////////
0:     protected void flush () 
0:         throws java.io.IOException {
0:         flush(agent.getOutputStream());
/////////////////////////////////////////////////////////////////////////
0:         throws java.io.IOException {
0:         try {
0:             socketOutputStream.write (bytes, 0, offset);
0:             socketOutputStream.flush();
0:         } finally {
0:             if ((dssTrace != null) && dssTrace.isComBufferTraceOn()) {
0:                 dssTrace.writeComBufferData (bytes,
0:                                              0,
0:                                              offset,
0:                                              DssTrace.TYPE_TRACE_SEND,
0:                                              "Reply",
0:                                              "flush",
0:                                              5);
0:             }
0:             reset(dssTrace);
0:         }
/////////////////////////////////////////////////////////////////////////
0:      *  2 bytes - length
0:      *  1 byte  - 'D0'  - indicates DDM data
0:      *  1 byte  - DSS format
0:      *          |---|---------|----------|
0:      *          | 0     |       flags | type     |
0:      *          |---|---------|----------|
0:      *          | 0 | 1 2       3 | 4 5 6 7      |
0:      *          |---|---------|----------|
0:      *          bit 0 - '0'
0:      *          bit 1 - '0' - unchained, '1' - chained
0:      *          bit 2 - '0'     - do not continue on error, '1' - continue on error
0:      *          bit 3 - '0' - next DSS has different correlator, '1' - next DSS has
0:      *                                          same correlator
0:      *          type - 1 - Request DSS
0:      *                   - 2 - Reply DSS
0:      *                   - 3 - Object DSS
0:      *                   - 4 - Communications DSS
0:      *                   - 5 - Request DSS where no reply is expected
0:     private void beginDss (int dssType, boolean ensureLen) {
0:         // save length position, the length will be written at the end
0:         dssLengthLocation = offset;
0:         // Should this really only be for non-stream DSSes?
0:         if (ensureLen)
0:             ensureLength(6);
0:         // Skip past length; we'll come back and set it later.
0:         offset += 2;
0:         // write gds info
0:         bytes[offset] = (byte) 0xD0;
0:         // Write DSS type, and default chain bit to be 
0:         // DssConstants.DSSCHAIN_SAME_ID.  This default
0:         // will be overridden by calls to "finalizeChain()"
0:         // and/or calls to "beginDss(boolean, int)" for
0:         // writing LOB data.
0:         bytes[offset + 1] = (byte) dssType;
0:         bytes[offset + 1] |= DssConstants.DSSCHAIN_SAME_ID;
0:         // save correlationID for use in error messages while processing
0:         // this DSS
0:         correlationID = getCorrelationID();
0:         // write the reply correlation id
0:         bytes[offset + 2] = (byte) ((correlationID >>> 8) & 0xff);
0:         bytes[offset + 3] = (byte) (correlationID & 0xff);
0:         offset += 4;
0:      * offset into the buffer which marks the end of the data.  In the event
0:     private void finalizeDssLength () {
0:         // calculate the total size of the dss and the number of bytes which would
0:         // require continuation dss headers.    The total length already includes the
0:         // the 6 byte dss header located at the beginning of the dss.   It does not
0:         // include the length of any continuation headers.
0:         int totalSize = offset - dssLengthLocation;
0:         int bytesRequiringContDssHeader = totalSize - DssConstants.MAX_DSS_LENGTH;
0:         // determine if continuation headers are needed
0:         if (bytesRequiringContDssHeader > 0){
0:             // the continuation headers are needed, so calculate how many.
0:             // after the first 32767 worth of data, a continuation header is
0:             // needed for every 32765 bytes (32765 bytes of data + 2 bytes of
0:             // continuation header = 32767 Dss Max Size).
0:             int contDssHeaderCount = bytesRequiringContDssHeader / 32765;
0:             if (bytesRequiringContDssHeader % 32765 != 0)
0:                 contDssHeaderCount++;
0:             // right now the code will shift to the right.  In the future we may want
0:             // to try something fancier to help reduce the copying (maybe keep
0:             // space in the beginning of the buffer??).
0:             // the offset points to the next available offset in the buffer to place
0:             // a piece of data, so the last dataByte is at offset -1.
0:             // various bytes will need to be shifted by different amounts
0:             // depending on how many dss headers to insert so the amount to shift
0:             // will be calculated and adjusted as needed.   ensure there is enough room
0:             // for all the conutinuation headers and adjust the offset to point to the
0:             // new end of the data.
0:             int dataByte = offset - 1;
0:             int shiftSize = contDssHeaderCount * 2;
0:             ensureLength (shiftSize);
0:             offset += shiftSize;
0:             // Notes on the behavior of the Layer B segmenting loop below:
0:             //
0:             // We start with the right most chunk. For a 3-segment object we'd
0:             // shift 2 segments: shift the first (rightmost) one 4 bytes and 
0:             // the second one 2. Note that by 'first' we mean 'first time
0:             // through the loop', but that is actually the last segment
0:             // of data since we are moving right-to-left. For an object
0:             // of K segments we will pass through this loop K-1 times.
0:             // The 0th (leftmost) segment is not shifted, as it is
0:             // already in the right place. When we are done, we will
0:             // have made room in each segment for an additional
0:             // 2 bytes for the continuation header. Thus, each
0:             // segment K is shifted K*2 bytes to the right.
0:             //
0:             // Each time through the loop, "dataByte" points to the
0:             // last byte in the segment; "dataToShift" is the amount of
0:             // data that we need to shift, and "shiftSize" is the
0:             // distance that we need to shift it. Since dataByte points
0:             // at the last byte, not one byte beyond it (as with the
0:             // "offset" variable used elsewhere in DDMWriter), the start
0:             // of the segement is actually at (dataByte-dataToShift+1).
0:             //
0:             // After we have shifted the segment, we move back to the
0:             // start of the segment and set the value of the 2-byte DSS
0:             // continuation header, which needs to hold the length of
0:             // this segment's data, together with the continuation flag
0:             // if this is not the rightmost (passOne) segment.
0:             //
0:             // In general, each segment except the rightmost will contain
0:             // 32765 bytes of data, plus the 2-byte header, and its
0:             // continuation flag will be set, so the header value will
0:             // be 0xFFFF. The rightmost segment will not have the
0:             // continuation flag set, so its value may be anything from
0:             // 0x0001 to 0x7FFF, depending on the amount of data in that
0:             // segment.
0:             //
0:             // Note that the 0th (leftmost) segment also has a 2-byte
0:             // DSS header, which needs to have its continuation flag set.
0:             // This is done by resetting the "totalSize" variable below,
0:             // at which point that variable no longer holds the total size
0:             // of the object, but rather just the length of segment 0. The
0:             // total size of the object was written using extended length
0:             // bytes by the endDdm() method earlier.
0:             //
0:             // Additional information about this routine is available in the
0:             // bug notes for DERBY-125:
0:             // http://issues.apache.org/jira/browse/DERBY-125
0:                         
0:             // mark passOne to help with calculating the length of the final (first or
0:             // rightmost) continuation header.
0:             boolean passOne = true;
0:             do {
0:                 // calculate chunk of data to shift
0:                 int dataToShift = bytesRequiringContDssHeader % 32765;
0:                 if (dataToShift == 0)
0:                     dataToShift = 32765;
0:                 int startOfCopyData = dataByte - dataToShift + 1;
0:                 System.arraycopy(bytes,startOfCopyData, bytes, 
0:                                  startOfCopyData + shiftSize, dataToShift);
0:                 dataByte -= dataToShift;
0:                 // calculate the value the value of the 2 byte continuation dss
0:                 // header which includes the length of itself.  On the first pass,
0:                 // if the length is 32767
0:                 // we do not want to set the continuation dss header flag.
0:                 int twoByteContDssHeader = dataToShift + 2;
0:                 if (passOne)
0:                     passOne = false;
0:                 else {
0:                     if (twoByteContDssHeader == DssConstants.MAX_DSS_LENGTH)
0:                         twoByteContDssHeader = (twoByteContDssHeader |
0:                                                 DssConstants.CONTINUATION_BIT);
0:                 }
0:                 // insert the header's length bytes
0:                 bytes[dataByte + shiftSize - 1] = (byte)
0:                     ((twoByteContDssHeader >>> 8) & 0xff);
0:                 bytes[dataByte + shiftSize] = (byte)
0:                     (twoByteContDssHeader & 0xff);
0:                 // adjust the bytesRequiringContDssHeader and the amount to shift for
0:                 // data in upstream headers.
0:                 bytesRequiringContDssHeader -= dataToShift;
0:                 shiftSize -= 2;
0:                 // shift and insert another header for more data.
0:             } while (bytesRequiringContDssHeader > 0);
0:             // set the continuation dss header flag on for the first header
0:             totalSize = (DssConstants.MAX_DSS_LENGTH |
0:                          DssConstants.CONTINUATION_BIT);
0:         }
0:         // insert the length bytes in the 6 byte dss header.
0:         bytes[dssLengthLocation] = (byte) ((totalSize >>> 8) & 0xff);
0:         bytes[dssLengthLocation + 1] = (byte) (totalSize & 0xff);
0:     protected void writeExtendedLength(long size) {
0:         int numbytes = calculateExtendedLengthByteCount(size);
0:         if (size > 0)
0:             writeInt(0x8000 | numbytes);
0:         else
0:             writeInt(numbytes);
/////////////////////////////////////////////////////////////////////////
0:      *  extended length needed.
0:     private int calculateExtendedLengthByteCount (long ddmSize) {
0:         if (ddmSize <= 0x7fff)
0:             return 0;
0:         // JCC does not support 2 at this time, so we always send
0:         // at least 4
0:         //              else if (ddmSize <= 0xffff)
0:         //      return 2;
0:         else if (ddmSize <= 0xffffffffL)
0:             return 4;
0:         else if (ddmSize <= 0xffffffffffffL)
0:             return 6;
0:         else if (ddmSize <= 0x7fffffffffffffffL)
0:             return 8;
0:         else
0:             // shouldn't happen
0:             // XXX - add sanity debug stuff here
0:             return 0;
/////////////////////////////////////////////////////////////////////////
0:     private void ensureLength (int length) {
0:         length += offset;
0:         if (length > bytes.length) {
0:             if (SanityManager.DEBUG) {
0:                 agent.trace("DANGER - Expensive expansion of  buffer");
0:             }
0:             byte newBytes[] = new byte[Math.max (bytes.length << 1, length)];
0:             System.arraycopy (bytes, 0, newBytes, 0, offset);
0:             bytes = newBytes;
0:         }
/////////////////////////////////////////////////////////////////////////
0:                                                 int precision, int scale)
0:         throws SQLException {
0:         int declaredPrecision = precision;
0:         int declaredScale = scale;
0:         // packed decimal may only be up to 31 digits.
0:         if (declaredPrecision > 31) { // this is a bugcheck only !!! 
0:             clearDdm ();
0:             throw new java.sql.SQLException ("Packed decimal may only be up to 31 digits!");
0:         }
0:         // get absolute unscaled value of the BigDecimal as a String.
0:         String unscaledStr = b.unscaledValue().abs().toString();
0:         // get precision of the BigDecimal.
0:         int bigPrecision = unscaledStr.length();
0:         if (bigPrecision > 31) {
0:             clearDdm ();
0:             throw new SQLException ("The numeric literal \"" +
0:                                     b.toString() +
0:                                     "\" is not valid because its value is out of range.",
0:                                     "42820",
0:                                     -405);
0:         }
0:         int bigScale = b.scale();
0:         int bigWholeIntegerLength = bigPrecision - bigScale;
0:         if ( (bigWholeIntegerLength > 0) && (!unscaledStr.equals ("0")) ) {
0:             if (bigWholeIntegerLength > declaredWholeIntegerLength) {
0:                 clearDdm ();
0:                 throw new SQLException ("Overflow occurred during numeric data type conversion of \"" +
0:                                         b.toString() +
0:                                         "\".",
0:                                         "22003",
0:                                         -413);
0:             }
/////////////////////////////////////////////////////////////////////////
0:             // If target scale is less than source scale,
0:             // discard excessive fraction.
0:             // set start index in source big decimal to ignore excessive fraction.
0:             bigIndex = bigPrecision-1-(bigScale-declaredScale);
0:             if (bigIndex < 0) {
0:                 // all digits are discarded, so only process the sign nybble.
0:                 bytes[offset+(packedIndex+1)/2] =
0:                     (byte) ( (b.signum()>=0)?12:13 ); // sign nybble
0:             } else {
0:                 // process the last nybble together with the sign nybble.
0:                 bytes[offset+(packedIndex+1)/2] =
0:                     (byte) ( ( (unscaledStr.charAt(bigIndex)-zeroBase) << 4 ) + // last nybble
0:                              ( (b.signum()>=0)?12:13 ) ); // sign nybble
0:             }
0:             packedIndex-=2;
0:             bigIndex-=2;
0:         } else {
0:             // If target scale is greater than source scale,
0:             // pad the fraction with zero.
0:             // set start index in source big decimal to pad fraction with zero.
0:             bigIndex = declaredScale-bigScale-1;
0:             // process the sign nybble.
0:             bytes[offset+(packedIndex+1)/2] =
0:                 (byte) ( (b.signum()>=0)?12:13 ); // sign nybble
0:             for (packedIndex-=2, bigIndex-=2; bigIndex>=0; packedIndex-=2, bigIndex-=2)
0:                 bytes[offset+(packedIndex+1)/2] = (byte) 0;
0:             if (bigIndex == -1) {
0:                 bytes[offset+(packedIndex+1)/2] =
0:                     (byte) ( (unscaledStr.charAt(bigPrecision-1)-zeroBase) << 4 ); // high nybble
0:                 packedIndex-=2;
0:                 bigIndex = bigPrecision-3;
0:             } else {
0:                 bigIndex = bigPrecision-2;
0:             }
0:             bytes[offset+(packedIndex+1)/2] =
0:                 (byte) ( ( (unscaledStr.charAt(bigIndex)-zeroBase) << 4 ) + // high nybble
0:                          ( unscaledStr.charAt(bigIndex+1)-zeroBase ) ); // low nybble
0:             bytes[offset+(packedIndex+1)/2] =
0:                 (byte) (unscaledStr.charAt(0) - zeroBase);
0:             packedIndex-=2;
0:             bytes[offset+(packedIndex+1)/2] = (byte) 0;
/////////////////////////////////////////////////////////////////////////
0:     public static String zeroPadString(String s, int precision) {
0:         if (s == null)
0:             return s;
0:         int slen = s.length();
0:         if (precision == slen)
0:             return s;
0:         else if (precision > slen) {
0:             char[] ca  = new char[precision - slen];
0:             Arrays.fill(ca,0,precision - slen,'0');
0:             return new String(ca) + s;
0:         } else {
0:             // Shouldn't happen but just in case 
0:             // truncate
0:             return s.substring(0,precision);
0:         }
0:         throws java.io.IOException{
0:         
0:         sendBytes(socketOutputStream,
0:                   true);
0:         
0:                             boolean flashStream ) 
0:         throws java.io.IOException{
0:         resetChainState();
0:         try {
0:             socketOutputStream.write (bytes, 0, offset);
0:             if(flashStream)
0:                 socketOutputStream.flush();
0:         } finally {
0:             if ((dssTrace != null) && dssTrace.isComBufferTraceOn()) {
0:                 dssTrace.writeComBufferData (bytes,
0:                                              0,
0:                                              offset,
0:                                              DssTrace.TYPE_TRACE_SEND,
0:                                              "Reply",
0:                                              "flush",
0:                                              5);
0:             }
0:             clearBuffer();
0:         }
0:     protected String toDebugString(String indent) {
0:         String s = indent + "***** DDMWriter toDebugString ******\n";
0:         int byteslen = 0;
0:         if ( bytes != null)
0:             byteslen = bytes.length;
0:         s += indent + "byte array length  = " + bytes.length + "\n";
0:         return s;
0:     protected void resetChainState() {
0:         prevHdrLocation = -1;
/////////////////////////////////////////////////////////////////////////
0:         int cId;
0:         if (previousCorrId != DssConstants.CORRELATION_ID_UNKNOWN) {
0:             if (previousChainByte == DssConstants.DSSCHAIN_SAME_ID)
0:                 // then we have to use the last correlation id we sent.
0:                 cId = previousCorrId;
0:             else
0:                 // get correlation id as normal.
0:                 cId = nextCorrelationID++;
0:         } else {
0:             // must be the case that this is the first DSS we're
0:             // writing for this connection (because we haven't
0:             // called "endDss" yet).  So, get the corr id as
0:             // normal.
0:             cId = nextCorrelationID++;
0:         }
0:         return cId;
/////////////////////////////////////////////////////////////////////////
0:                                  OutputStream socketOutputStream) 
0:         throws DRDAProtocolException {
0:         // Go back to previous DSS and override the default
0:         // chain state (WITH_SAME_ID) with whatever the last
0:         // request dictates.
0:         if (prevHdrLocation != -1) {
0:             // Note: == -1 => the previous DSS was already sent; this
0:             // should only happen in cases where the buffer filled up
0:             // and we had to send it (which means we were probably
0:             // writing EXTDTA).  In such cases, proper chaining
0:             // should already have been handled @ time of send.
0:             bytes[prevHdrLocation + 3] &= 0x0F; // Zero out old chain value.
0:             bytes[prevHdrLocation + 3] |= currChainByte;
0:         }
0:         // previousChainByte needs to match what we just did.
0:         previousChainByte = currChainByte;
0:         if (currChainByte != DssConstants.DSS_NOCHAIN)
0:             // then we're still inside a chain, so don't send.
0:             return;
0:         // Else, we just ended the chain, so send it across.
0:         if ((SanityManager.DEBUG) && (agent != null))
0:             agent.trace("Sending data");
0:         resetChainState();
0:         if (doesRequestContainData()) {
0:             try {
0:                 flush(socketOutputStream);
0:             } catch (java.io.IOException e) {
0:                 agent.markCommunicationsFailure(
0:                                                 "DDMWriter.finalizeChain()",
0:                                                 "OutputStream.flush()",
0:                                                 e.getMessage(),"*");
0:             }
0:         }
/////////////////////////////////////////////////////////////////////////
0:     protected int markDSSClearPoint() {
0:         lastDSSBeforeMark = prevHdrLocation;
0:         return offset;
/////////////////////////////////////////////////////////////////////////
0:     protected void clearDSSesBackToMark(int mark) {
0:         // Logical clear.
0:         offset = mark;
0:         // Because we've just cleared out the most recently-
0:         // written DSSes, we have to make sure the next thing
0:         // we write will have the correct correlation id.  We
0:         // do this by setting the value of 'nextCorrelationID'
0:         // based on the chaining byte from the last remaining
0:         // DSS (where "remaining" means that it still exists
0:         // in the buffer after the clear).
0:         if (lastDSSBeforeMark == -1)
0:             // we cleared out the entire buffer; reset corr id.
0:             nextCorrelationID = 1;
0:         else {
0:             // last remaining DSS had chaining, so we set "nextCorrelationID"
0:             // to be 1 greater than whatever the last remaining DSS had as
0:             // its correlation id.
0:             nextCorrelationID = 1 + (int)
0:                 (((bytes[lastDSSBeforeMark + 4] & 0xff) << 8) +
0:                  (bytes[lastDSSBeforeMark + 5] & 0xff));
0:         }
0:         
0:     private static int peekStream(InputStream in) 
0:         throws IOException{
0:             
0:         in.mark(1);
0:         try{
0:             return in.read();
0:             
0:         }finally{
0:             in.reset();
0:             
0:         }
0:         return PropertyUtil.getSystemInt( Property.DRDA_PROP_STREAMOUTBUFFERSIZE , 0 );
0:         
0:         int size = getLayerBStreamingBufferSize();
0:         
0:         if(size < 1)
0:             return original;
0:         else
0:             return new BufferedOutputStream( original, size );
commit:9ab36fe
/////////////////////////////////////////////////////////////////////////
0: Derby - Class org.apache.derby.impl.drda.DDMWriter
0: Copyright 2001, 2004 The Apache Software Foundation or its licensors, as applicable.
0: Licensed under the Apache License, Version 2.0 (the "License");
0: you may not use this file except in compliance with the License.
0: You may obtain a copy of the License at
0: http://www.apache.org/licenses/LICENSE-2.0
0: Unless required by applicable law or agreed to in writing, software
0: distributed under the License is distributed on an "AS IS" BASIS,
0: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0: See the License for the specific language governing permissions and
0: limitations under the License.
0: */
/////////////////////////////////////////////////////////////////////////
0:    The DDMWriter is used to write DRDA protocol.   The DRDA Protocol is
0:    described in the DDMReader class.
0:    For more details, see DRDA Volume 3 (Distributed Data Management(DDM)
0:    Architecture (DDS definition)
0:     // number of nesting levels for collections.  We need to mark the length
0:     // location of the collection so that we can update it as we add more stuff
0:     // to the collection
0:     private final static int MAX_MARKS_NESTING = 10;
0:     // Default buffer size
0:     private final static int DEFAULT_BUFFER_SIZE = 32767;
0:     static final BigDecimal ZERO = BigDecimal.valueOf(0L);
0:     // output buffer
0:     private byte[] bytes;
0:     // offset into output buffer
0:     private int offset;
0:     // A saved mark in the stream is saved temporarily to revisit the location.
0:     private int[] markStack = new int[MAX_MARKS_NESTING];
0:     // top of the stack
0:     private int top;
0:     // CCSID manager for translation of strings in the protocol to EBCDIC
0:     private CcsidManager ccsidManager;
0:     // DRDA connection thread for this writer
0:     private DRDAConnThread agent;
0:     //	This Object tracks the location of the current
0:     //	Dss header length bytes.	This is done so
0:     //	the length bytes can be automatically
0:     //	updated as information is added to this stream.
0:     private int dssLengthLocation;
0:     // Current correlation ID
0:     private	int correlationID;
0:     // Next correlation ID
0:     private int nextCorrelationID;
0:     // is this DRDA protocol or CMD protocol
0:     private boolean isDRDAProtocol;
0:     // trace object of the associated session
0:     private DssTrace dssTrace;
0:     // Location within the "bytes" array of the start of the header
0:     // of the DSS most recently written to the buffer.
0:     private int prevHdrLocation;
0:     // Correlation id of the last DSS that was written to buffer.
0:     private int previousCorrId;
0:     // Chaining bit of the last DSS that was written to buffer.
0:     private byte previousChainByte;
0:     // Whether or not the current DSS is a continuation DSS.
0:     private boolean isContinuationDss;
0:     // In situations where we want to "mark" a buffer location so that
0:     // we can "back-out" of a write to handle errors, this holds the
0:     // location within the "bytes" array of the start of the header
0:     // that immediately precedes the mark.
0:     private int lastDSSBeforeMark;
0:     // Constructors
0:     DDMWriter (int minSize, CcsidManager ccsidManager, DRDAConnThread agent, DssTrace dssTrace)
0:     {
0: 	this.bytes = new byte[minSize];
0: 	this.ccsidManager = ccsidManager;
0: 	this.agent = agent;
0: 	this.prevHdrLocation = -1;
0: 	this.previousCorrId = DssConstants.CORRELATION_ID_UNKNOWN;
0: 	this.previousChainByte = DssConstants.DSS_NOCHAIN;
0: 	this.isContinuationDss = false;
0: 	this.lastDSSBeforeMark = -1;
0: 	reset(dssTrace);
0:     }
0: 
0:     DDMWriter (CcsidManager ccsidManager, DRDAConnThread agent, DssTrace dssTrace)
0:     {
0: 	this.bytes = new byte[DEFAULT_BUFFER_SIZE];
0: 	this.ccsidManager = ccsidManager;
0: 	this.agent = agent;
0: 	this.prevHdrLocation = -1;
0: 	this.previousCorrId = DssConstants.CORRELATION_ID_UNKNOWN;
0: 	this.previousChainByte = DssConstants.DSS_NOCHAIN;
0: 	this.isContinuationDss = false;
0: 	this.lastDSSBeforeMark = -1;
0: 	reset(dssTrace);
0:     }
0: 
0:     /**
0:      * reset values for sending next message
0:      *
0:      */
0:     protected void reset(DssTrace dssTrace)
0:     {
0: 	offset = 0;
0: 	top = 0;
0: 	dssLengthLocation = 0;
0: 	nextCorrelationID = 1;
0: 	correlationID = DssConstants.CORRELATION_ID_UNKNOWN;
0: 	isDRDAProtocol = true;
0: 	this.dssTrace = dssTrace;
0:     }
0: 
0:     /**
0:      * set protocol to CMD protocol
0:      */
0:     protected void setCMDProtocol()
0:     {
0: 	isDRDAProtocol = false;
0:     }
0: 
0:     /**
0:      * Create DSS reply object
0:      */
0:     protected void createDssReply()
0:     {
0: 	beginDss(DssConstants.DSSFMT_RPYDSS, true);
0:     }
0: 
0:     /**
0:      * Create DSS request object
0:      * NOTE: This is _ONLY_ used for testing the protocol
0:      * (via the TestProto.java file in this package)!
0:      * We should never create a DSS request in normal
0:      * DRDA processing (we should only create DSS replies
0:      * and DSS objects).
0:      */
0:     protected void createDssRequest()
0:     {
0: 	beginDss(DssConstants.DSSFMT_RQSDSS, true);
0:     }
0: 
0:     /**
0:      * Create DSS data object
0:      */
0:     protected void createDssObject()
0:     {
0: 	beginDss(DssConstants.DSSFMT_OBJDSS, true);
0:     }
0: 
0:     /**
0:      * Mark the DSS that we're currently writing as
0:      * a continued DSS, which is done by setting
0:      * the high-order bit to "1", per DDM spec.
0:      * This means:
0:      *
0:      *	1. One or more continuation DSSes will immediately
0:      * 		follow the current (continued) DSS.
0:      *	2. All continuation DSSes will have a 2-byte
0:      * 		continuation header, followed by data; in
0:      * 		other words, chaining state, correlation
0:      *		id, dss format info, and code point will
0:      * 		NOT be included.  All of that info is 
0:      * 		present ONLY in the FIRST DSS in the
0:      *		list of continued DSSes.
0:      *
0:      *	NOTE: A DSS can be a "continuation" DSS _and_
0:      * 	a "continued" DSS at the same time.  However,
0:      * 	the FIRST DSS to be continued canNOT be
0:      *	a continuation DSS.
0:      */
0:     private void markDssAsContinued(boolean forLob)
0:     {
0: 
0: 	if (!forLob) {
0: 	    // continuation bit defaults to '1' for lobs, so
0: 	    // we only have to switch it if we're not writing
0: 	    // lobs.
0: 	    bytes[dssLengthLocation] |= 0x80;
0: 	// We need to set the chaining state, but ONLY
0: 	// IF this is the FIRST DSS in the continuation
0: 	// list (only the first one has chaining state
0: 	// in it's header; the others do not).
0: 	if (!isContinuationDss)
0: 	    endDss(!forLob);
0: 
0:     }
0: 
0:     /**
0:      * End DSS header by writing the length in the length location
0:      * and setting the chain bit.  Unlike the other two endDss
0:      * methods, this one overrides the default chaining byte
0:      * (which is set in beginDss) with the chaining byte that
0:      * is passed in.  NOTE: This method is only used in
0:      * association with createDssRequest, and thus is for
0:      * TESTING purposes only (via TestProto.java).  No calls
0:      * should be made to this method in normal DRDA processing
0:      * (because for normal processing, chaining must be
0:      * determined automatically based on DSS requests).
0:      */
0:     protected void endDss(byte chainByte)
0:     {
0: 
0: 	// Do regular endDss processing.
0: 	endDss(true);
0: 
0: 	// Now override default chain state.
0: 	bytes[dssLengthLocation + 3] &= 0x0F;	// Zero out default
0: 	bytes[dssLengthLocation + 3] |= chainByte;
0: 	previousChainByte = chainByte;
0: 
0:     }
0: 
0:     /**
0:      * End DSS header by writing the length in the length location
0:      * and setting the chain bit.
0:      */
0:     protected void endDss() {
0: 	endDss(true);
0:     }
0: 
0:     /**
0:      * End DSS header by writing the length in the length location
0:      * and setting the chain bit.
0:      */
0:     private void endDss (boolean finalizeLength)
0:     {
0: 
0: 	if (finalizeLength)
0: 	    finalizeDssLength();
0: 
0: 	if (isContinuationDss) {
0: 	    // no chaining information for this DSS; so we're done.
0: 	    isContinuationDss = false;
0: 	    return;
0: 	previousCorrId = correlationID;
0: 	prevHdrLocation = dssLengthLocation;
0: 	previousChainByte = DssConstants.DSSCHAIN_SAME_ID;
0:     }
0:     /**
0:      * End final DDM and DSS header by writing the length in the length location
0:      *
0:      */
0:     protected void endDdmAndDss ()
0:     {
0: 	endDdm();	// updates last DDM object
0: 	endDss();
0:     }
0:     /**
0:      * Copy Data to End
0:      * Create a buffer and copy from the position given to the end of data
0:      *
0:      * Note that the position given is treated as relative to the
0:      * current DSS, for there may be other DSS blocks (chained, presumably)
0:      * which are sitting unwritten in the buffer. The caller doesn't
0:      * know this, though, and works only with the current DSS.
0:      *
0:      * getDSSLength, copyDSSDataToEnd, and truncateDSS work together to
0:      * provide a sub-protocol for DRDAConnThread to use in its
0:      * implementation of the LMTBLKPRC protocol. They enable the caller
0:      * to determine when it has written too much data into the current
0:      * DSS, to reclaim the extra data that won't fit, and to truncate
0:      * that extra data once it has been reclaimed and stored elsewhere.
0:      * Note that this support only works for the current DSS. Earlier,
0:      * chained DSS blocks cannot be accessed using these methods. For
0:      * additional background information, the interested reader should
0:      * investigate bugs DERBY-491 and 492 at:
0:      * http://issues.apache.org/jira/browse/DERBY-491 and
0:      * http://issues.apache.org/jira/browse/DERBY-492
0:      *
0:      * @param start
0:      */
0:     protected byte [] copyDSSDataToEnd(int start)
0:     {
0: 	start = start + dssLengthLocation;
0: 	int length = offset - start;
0: 	byte [] temp = new byte[length];
0: 	System.arraycopy(bytes,start,temp,0,length);
0: 	return temp;
0:     }
0:     // Collection methods
0:     /**
0:      * Mark the location of the length bytes for the collection so they
0:      * can be updated later
0:      *
0:      */
0:     protected void startDdm (int codePoint)
0:     {
0: 	// save the location of the beginning of the collection so
0: 	// that we can come back and fill in the length bytes
0: 	markStack[top++] = offset;
0: 	ensureLength (4); // verify space for length bytes and code point
0: 	offset += 2; // move past the length bytes before writing the code point
0: 	bytes[offset] = (byte) ((codePoint >>> 8) & 0xff);
0: 	bytes[offset + 1] = (byte) (codePoint & 0xff);
0: 	offset += 2;
0:     }
0:     /**
0:      * Erase all writes for the current ddm and reset the
0:      * top
0:      */
0:     protected void clearDdm ()
0:     {
0: 	offset = markStack[top--];
0:     }
0:     /**
0:      * Clear the entire send buffer
0:      *
0:      */
0:     protected void clearBuffer()
0:     {
0: 	offset = 0;
0: 	top = 0;
0: 	dssLengthLocation = 0;
0: 	correlationID = DssConstants.CORRELATION_ID_UNKNOWN;
0: 	nextCorrelationID = 1;
0: 	isDRDAProtocol = true;
0:     }
0:     /**
0:      * End the current DDM
0:      *
0:      */
0:     protected void endDdm ()
0:     {
0: 	// remove the top length location offset from the mark stack
0: 	// calculate the length based on the marked location and end of data.
0: 	int lengthLocation = markStack[--top];
0: 	int length = offset - lengthLocation;
0: 	// determine if any extended length bytes are needed.	the value returned
0: 	// from calculateExtendedLengthByteCount is the number of extended length
0: 	// bytes required. 0 indicates no exteneded length.
0: 	int extendedLengthByteCount = calculateExtendedLengthByteCount (length);
0: 	if (extendedLengthByteCount != 0)
0: 	    {
0: 		// ensure there is enough room in the buffer for the extended length bytes.
0: 		ensureLength (extendedLengthByteCount);
0: 		// calculate the length to be placed in the extended length bytes.
0: 		// this length does not include the 4 byte llcp.
0: 		int extendedLength = length - 4;
0: 		// shift the data to the right by the number of extended
0: 		// length bytes needed.
0: 		int extendedLengthLocation = lengthLocation + 4;
0: 		System.arraycopy (bytes,
0: 				  extendedLengthLocation,
0: 				  bytes,
0: 				  extendedLengthLocation + extendedLengthByteCount,
0: 				  extendedLength);
0: 		// write the extended length
0: 		int shiftSize = (extendedLengthByteCount -1) * 8;
0: 		for (int i = 0; i < extendedLengthByteCount; i++)
0: 		    {
0: 			bytes[extendedLengthLocation++] =
0: 			    (byte) ((extendedLength >>> shiftSize ) & 0xff);
0: 			shiftSize -= 8;
0: 		    }
0: 		// adjust the offset to account for the shift and insert
0: 		offset += extendedLengthByteCount;
0: 		// the two byte length field before the codepoint contains the length
0: 		// of itself, the length of the codepoint, and the number of bytes used
0: 		// to hold the extended length.	the 2 byte length field also has the first
0: 		// bit on to indicate extended length bytes were used.
0: 		length = extendedLengthByteCount + 4;
0: 		length |= DssConstants.CONTINUATION_BIT;
0: 	    }
0: 	// write the 2 byte length field (2 bytes before codepoint).
0: 	bytes[lengthLocation] = (byte) ((length >>> 8) & 0xff);
0: 	bytes[lengthLocation+1] = (byte) (length & 0xff);
0:     }
/////////////////////////////////////////////////////////////////////////
0:      */
/////////////////////////////////////////////////////////////////////////
0:      */
0:     // Write routines
0:     /**
0:      * Write byte
0:      *
0:      * @param 	value	byte to be written
0:      */
0:     protected void writeByte (int value)
0:     {
0: 	if (SanityManager.DEBUG)
0: 	    {
0: 		if (value > 255)
0: 		    SanityManager.THROWASSERT(
0: 					      "writeByte value: " + value +
0: 					      " may not be > 255");
0: 	    }
0: 	ensureLength (1);
0: 	bytes[offset++] = (byte) (value & 0xff);
0:     }
0:     /**
0:      * Write network short
0:      *
0:      * @param 	value	value to be written
0:      */
0:     protected void writeNetworkShort (int value)
0:     {
0: 	ensureLength (2);
0: 	bytes[offset] = (byte) ((value >>> 8) & 0xff);
0: 	bytes[offset + 1] = (byte) (value & 0xff);
0: 	offset += 2;
0:     }
0:     /**
0:      * Write network int
0:      *
0:      * @param 	value	value to be written
0:      */
0:     protected void writeNetworkInt (int value)
0:     {
0: 	ensureLength (4);
0: 	bytes[offset] = (byte) ((value >>> 24) & 0xff);
0: 	bytes[offset + 1] = (byte) ((value >>> 16) & 0xff);
0: 	bytes[offset + 2] = (byte) ((value >>> 8) & 0xff);
0: 	bytes[offset + 3] = (byte) (value & 0xff);
0: 	offset += 4;
0:     }
0:     /**
0:      * Write byte array
0:      *
0:      * @param 	buf	byte array to be written
0:      * @param	length  - length to write
0:      */
0:     protected void writeBytes (byte[] buf, int length)
0:     {
0: 	writeBytes(buf, 0,length);
0:     }
0:     /**
0:      * Write byte array
0:      *
0:      * @param 	buf	byte array to be written
0:      * @param	start  - starting position
0:      * @param	length  - length to write
0:      */
0:     protected void writeBytes (byte[] buf, int start, int length)
0:     {
0: 	if (SanityManager.DEBUG)
0: 	    {
0: 		if (buf == null && length > 0)
0: 		    SanityManager.THROWASSERT("Buf is null");
0: 		if (length + start - 1 > buf.length)
0: 		    SanityManager.THROWASSERT("Not enough bytes in buffer");
0: 	    }
0: 	ensureLength (length);
0: 	System.arraycopy(buf,start,bytes,offset,length);
0: 	offset += length;
0:     }
0:     /**
0:      * Write byte array
0:      *
0:      * @param 	buf	byte array to be written
0:      **/
0:     protected void writeBytes (byte[] buf)
0:     {
0: 	writeBytes(buf,buf.length);
0:     }
0:     protected void writeLDBytes(byte[] buf)
0:     {
0: 	writeLDBytes(buf, 0);
0:     }
0:     protected void writeLDBytes(byte[] buf, int index)
0:     {
0: 	int length = buf.length;
0: 	int writeLen =  buf.length;
0: 	writeShort(writeLen);
0: 	writeBytes(buf,0,writeLen);
0:     }
0:     /**
0:      * Write code point and 4 bytes
0:      *
0:      * @param 	codePoint - code point to write
0:      * @param	value  - value to write after code point
0:      */
0:     void writeCodePoint4Bytes (int codePoint, int value)
0:     {
0: 	ensureLength (4);
0: 	bytes[offset] = (byte) ((codePoint >>> 8) & 0xff);
0: 	bytes[offset + 1] = (byte) (codePoint & 0xff);
0: 	bytes[offset + 2] = (byte) ((value >>> 8) & 0xff);
0: 	bytes[offset + 3] = (byte) (value & 0xff);
0: 	offset += 4;
0:     }
0:     /**
0:      * Write scalar 1 byte object includes length, codepoint and value
0:      *
0:      * @param 	codePoint - code point to write
0:      * @param	value  - value to write after code point
0:      */
0:     void writeScalar1Byte (int codePoint, int value)
0:     {
0: 	ensureLength (5);
0: 	bytes[offset] = 0x00;
0: 	bytes[offset + 1] = 0x05;
0: 	bytes[offset + 2] = (byte) ((codePoint >>> 8) & 0xff);
0: 	bytes[offset + 3] = (byte) (codePoint & 0xff);
0: 	bytes[offset + 4] = (byte) (value & 0xff);
0: 	offset += 5;
0:     }
0:     /**
0:      * Write scalar 2 byte object includes length, codepoint and value
0:      *
0:      * @param 	codePoint - code point to write
0:      * @param	value  - value to write after code point
0:      */
0:     protected void writeScalar2Bytes (int codePoint, int value)
0:     {
0: 	ensureLength (6);
0: 	bytes[offset] = 0x00;
0: 	bytes[offset + 1] = 0x06;
0: 	bytes[offset + 2] = (byte) ((codePoint >>> 8) & 0xff);
0: 	bytes[offset + 3] = (byte) (codePoint & 0xff);
0: 	bytes[offset + 4] = (byte) ((value >>> 8) & 0xff);
0: 	bytes[offset + 5] = (byte) (value & 0xff);
0: 	offset += 6;
0:     }
0:     protected void writeScalar2Bytes ( int value)
0:     {
0: 	ensureLength (2);
0: 	bytes[offset] = (byte) ((value >>> 8) & 0xff);
0: 	bytes[offset + 1] = (byte) (value & 0xff);
0: 	offset += 2;
0:     }
0:     /**
0:      * Write length and codepoint
0:      *
0:      * @param 	length - length of object
0:      * @param 	codePoint - code point to write
0:      */
0:     protected void startDdm (int length, int codePoint)
0:     {
0: 	ensureLength (4);
0: 	bytes[offset] = (byte) ((length >>> 8) & 0xff);
0: 	bytes[offset + 1] = (byte) (length & 0xff);
0: 	bytes[offset + 2] = (byte) ((codePoint >>> 8) & 0xff);
0: 	bytes[offset + 3] = (byte) (codePoint & 0xff);
0: 	offset += 4;
0:     }
0:     /**
0:      * Write scalar byte array object includes length, codepoint and value
0:      *
0:      * @param 	codePoint - code point to write
0:      * @param	buf  - value to write after code point
0:      * @param	length - number of bytes to write
0:      */
0:     protected void writeScalarBytes (int codePoint, byte[] buf, int length)
0:     {
0: 	if (SanityManager.DEBUG)
0: 	    {
0: 		if (buf == null && length > 0)
0: 		    SanityManager.THROWASSERT("Buf is null");
0: 		if (length > buf.length)
0: 		    SanityManager.THROWASSERT("Not enough bytes in buffer");
0: 	    }
0: 	ensureLength (length + 4);
0: 	bytes[offset] = (byte) (((length+4) >>> 8) & 0xff);
0: 	bytes[offset + 1] = (byte) ((length+4) & 0xff);
0: 	bytes[offset + 2] = (byte) ((codePoint >>> 8) & 0xff);
0: 	bytes[offset + 3] = (byte) (codePoint & 0xff);
0: 	System.arraycopy(buf,0,bytes,offset + 4, length);
0: 	offset += length + 4;
0:     }
0: 				      int codePoint,
0: 				      boolean writeNullByte) 
0: 	throws DRDAProtocolException
0:     {
0: 	// Stream equivalent of "beginDss"...
0: 	int spareDssLength = prepScalarStream( chainedWithSameCorrelator,
0: 					       codePoint,
0: 					       writeNullByte);
0: 	// write the data
0: 	int bytesRead = 0;
0: 	int totalBytesRead = 0;
0: 	try {
0: 	    OutputStream out = 
0: 		placeLayerBStreamingBuffer( agent.getOutputStream() );
0: 	    boolean isLastSegment = false;
0: 	    while( !isLastSegment ){
0: 		int spareBufferLength = bytes.length - offset;
0: 		if( SanityManager.DEBUG ){
0: 		    if( PropertyUtil.getSystemProperty("derby.debug.suicideOfLayerBStreaming") != null )
0: 			throw new IOException();
0: 		    
0: 		bytesRead = in.read(bytes,
0: 				    offset,
0: 				    Math.min(spareDssLength,
0: 					     spareBufferLength));
0: 		    
0: 		totalBytesRead += bytesRead;
0: 		offset += bytesRead;
0: 		spareDssLength -= bytesRead;
0: 		spareBufferLength -= bytesRead;
0: 
0: 		isLastSegment = peekStream(in) < 0;
0: 		    
0: 		if(isLastSegment || 
0: 		   spareDssLength == 0){
0: 			
0: 		    flushScalarStreamSegment (isLastSegment, 
0: 					      out);
0: 			
0: 		    if( ! isLastSegment )
0: 			spareDssLength = DssConstants.MAX_DSS_LENGTH - 2;
0: 
0: 		    
0: 	    }
0: 		
0: 	    out.flush();
0: 		
0: 	}catch(IOException e){
0: 	    agent.markCommunicationsFailure ("DDMWriter.writeScalarStream()",
0: 					     "",
0: 					     e.getMessage(),
0: 					     "*");
0: 	}
0:     }
0:     /**
0:      * Begins a DSS stream (for writing LOB data).
0:      */
0:     private void beginDss (boolean chainedToNextStructure,
0: 			   int dssType)
0:     {
0: 	beginDss(dssType, false);	// false => don't ensure length.
0: 	// always turn on continuation flags... this is helpful for lobs...
0: 	// these bytes will get rest if dss lengths are finalized.
0: 	bytes[dssLengthLocation] = (byte) 0xFF;
0: 	bytes[dssLengthLocation + 1] = (byte) 0xFF;
0: 	// Set whether or not this DSS should be chained to
0: 	// the next one.  If it's chained, it has to be chained
0: 	// with same id (that's the nature of EXTDTA chaining).
0: 	if (chainedToNextStructure) {
0: 	    dssType |= DssConstants.GDSCHAIN_SAME_ID;
0: 	bytes[dssLengthLocation + 3] = (byte) (dssType & 0xff);
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0:     private int prepScalarStream( boolean chainedWithSameCorrelator,
0: 				  int codePoint,
0: 				  boolean writeNullByte) throws DRDAProtocolException
0:     {
0: 	ensureLength( DEFAULT_BUFFER_SIZE - offset );
0: 	final int nullIndicatorSize = writeNullByte ? 1:0;
0: 	// flush the existing DSS segment ,
0: 	// if this stream will not fit in the send buffer or 
0: 	// length of this stream is unknown.
0: 	// Here, 10 stands for sum of headers of layer A and B.
0: 	try {
0: 	    sendBytes(agent.getOutputStream());
0: 	}
0: 	catch (java.io.IOException e) {
0: 	    agent.markCommunicationsFailure ("DDMWriter.writeScalarStream()",
0: 					     "OutputStream.flush()",
0: 					     e.getMessage(),"*");
0: 	}
0: 	// buildStreamDss should not call ensure length.
0: 	writeLengthCodePoint(0x8004,codePoint);
0: 	// write the null byte, if necessary
0: 	if (writeNullByte)
0: 	    writeByte(0x0);
0: 	//Here, 6 stands for header of layer A and 
0: 	//4 stands for header of layer B.
0: 	return DssConstants.MAX_DSS_LENGTH - 6 - 4 - nullIndicatorSize;
0: 
0: 
0:     // method to determine if any data is in the request.
0:     // this indicates there is a dss object already in the buffer.
0:     protected boolean doesRequestContainData()
0:     {
0: 	return offset != 0;
0:     }
0: 
0: 
0:     // Writes out a scalar stream DSS segment, along with DSS continuation
0:     // headers if necessary.
0:     private void flushScalarStreamSegment ( boolean lastSegment,
0: 					    OutputStream out)
0: 	throws DRDAProtocolException
0:     {
0: 
0: 	// either at end of data, end of dss segment, or both.
0: 	if (! lastSegment) {
0: 
0: 	    // 32k segment filled and not at end of data.
0: 	    try {
0: 		// Mark current DSS as continued, set its chaining state,
0: 		// then send the data across.
0: 		markDssAsContinued(true); 	// true => for lobs
0: 		sendBytes (out,
0: 			   false);
0: 			    
0: 	    }catch (java.io.IOException ioe) {
0: 		agent.markCommunicationsFailure ("DDMWriter.flushScalarStreamSegment()",
0: 						 "",
0: 						 ioe.getMessage(),
0: 						 "*");
0: 	    }
0: 
0: 
0: 	    // Prepare a DSS continuation header for next DSS.
0: 	    dssLengthLocation = offset;
0: 	    bytes[offset++] = (byte) (0xff);
0: 	    bytes[offset++] = (byte) (0xff);
0: 	    isContinuationDss = true;
0: 	}else{
0: 	    // we're done writing the data, so end the DSS.
0: 	    endDss();
0: 
0: 	}
0: 
0:     }
0: 
0: 
0:     private void writeExtendedLengthBytes (int extendedLengthByteCount, long length)
0:     {
0: 	int shiftSize = (extendedLengthByteCount -1) * 8;
0: 	for (int i = 0; i < extendedLengthByteCount; i++) {
0: 	    bytes[offset + i] = (byte) ((length >>> shiftSize) & 0xff);
0: 	    shiftSize -= 8;
0: 	}
0:     }
0:     // insert a 4 byte length/codepoint pair into the buffer.
0:     // total of 4 bytes inserted in buffer.
0:     // Note: the length value inserted in the buffer is the same as the value
0:     // passed in as an argument (this value is NOT incremented by 4 before being
0:     // inserted).
0:     void writeLengthCodePoint (int length, int codePoint)
0:     {
0: 	ensureLength (4);
0: 	bytes[offset] = (byte) ((length >>> 8) & 0xff);
0: 	bytes[offset + 1] = (byte) (length & 0xff);
0: 	bytes[offset + 2] = (byte) ((codePoint >>> 8) & 0xff);
0: 	bytes[offset + 3] = (byte) (codePoint & 0xff);
0:     }
0:     /**
0:      * Write scalar object header includes length and codepoint
0:      *
0:      * @param 	codePoint - code point to write
0:      * @param	dataLength - length of object data
0:      */
0:     protected void writeScalarHeader (int codePoint, int dataLength)
0:     {
0: 	ensureLength (dataLength + 4);
0: 	bytes[offset] = (byte) (((dataLength+4) >>> 8) & 0xff);
0: 	bytes[offset + 1] = (byte) ((dataLength+4) & 0xff);
0: 	bytes[offset + 2] = (byte) ((codePoint >>> 8) & 0xff);
0: 	bytes[offset + 3] = (byte) (codePoint & 0xff);
0: 	offset += 4;
0:     }
0:     /**
0:      * Write scalar string object includes length, codepoint and value
0:      * the string is converted into the appropriate codeset (EBCDIC)
0:      *
0:      * @param 	codePoint - code point to write
0:      * @param	string - string to be written
0:      */
0:     void writeScalarString (int codePoint, String string)
0:     {
0: 	int stringLength = string.length();
0: 	ensureLength ((stringLength * 2)  + 4);
0: 	bytes[offset] = (byte) (((stringLength+4) >>> 8) & 0xff);
0: 	bytes[offset + 1] = (byte) ((stringLength+4) & 0xff);
0: 	bytes[offset + 2] = (byte) ((codePoint >>> 8) & 0xff);
0: 	bytes[offset + 3] = (byte) (codePoint & 0xff);
0: 	offset = ccsidManager.convertFromUCS2 (string, bytes, offset + 4);
0:     }
0:     /**
0:      * Write padded scalar string object includes length, codepoint and value
0:      * the string is converted into the appropriate codeset (EBCDIC)
0:      *
0:      * @param 	codePoint - code point to write
0:      * @param	string - string to be written
0:      * @param 	paddedLength - length to pad string to
0:      */
0:     void writeScalarPaddedString (int codePoint, String string, int paddedLength)
0:     {
0: 	int stringLength = string.length();
0: 	int fillLength = paddedLength - stringLength;
0: 	ensureLength (paddedLength + 4);
0: 	bytes[offset] = (byte) (((paddedLength+4) >>> 8) & 0xff);
0: 	bytes[offset + 1] = (byte) ((paddedLength+4) & 0xff);
0: 	bytes[offset + 2] = (byte) ((codePoint >>> 8) & 0xff);
0: 	bytes[offset + 3] = (byte) (codePoint & 0xff);
0: 	offset = ccsidManager.convertFromUCS2 (string, bytes, offset + 4);
0: 	Arrays.fill(bytes,offset, offset + fillLength,ccsidManager.space);
0: 	offset += fillLength;
0:     }
0:     /**
0:      * Write padded scalar string object value
0:      * the string is converted into the appropriate codeset (EBCDIC)
0:      *
0:      * @param	string - string to be written
0:      * @param 	paddedLength - length to pad string to
0:      */
0:     protected void writeScalarPaddedString (String string, int paddedLength)
0:     {
0: 	int stringLength = string.length();
0: 	int fillLength = paddedLength -stringLength;
0: 	ensureLength (paddedLength);
0: 	offset = ccsidManager.convertFromUCS2 (string, bytes, offset);
0: 	Arrays.fill(bytes,offset, offset + fillLength,ccsidManager.space);
0: 	offset += fillLength;
0:     }
0:     /**
0:      * Write padded scalar <code>DRDAString</code> object value. The
0:      * string is converted into the appropriate codeset.
0:      *
0:      * @param drdaString string to be written
0:      * @param paddedLength length to pad string to
0:      */
0:     protected void writeScalarPaddedString (DRDAString drdaString, int paddedLength)
0:     {
0: 	int stringLength = drdaString.length();
0: 	int fillLength = paddedLength - stringLength;
0: 	ensureLength(paddedLength);
0: 	System.arraycopy(drdaString.getBytes(), 0, bytes, offset, stringLength);
0: 	offset += stringLength;
0: 	Arrays.fill(bytes, offset, offset + fillLength, ccsidManager.space);
0: 	offset += fillLength;
0:     }
0:     /**
0:      * Write padded scalar byte array object includes length, codepoint and value
0:      *
0:      * @param 	codePoint - code point to write
0:      * @param	buf - byte array to be written
0:      * @param 	paddedLength - length to pad string to
0:      * @param	padByte - byte to be used for padding
0:      */
0:     protected void writeScalarPaddedBytes (int codePoint, byte[] buf, int paddedLength, byte padByte)
0:     {
0: 	int bufLength = buf.length;
0: 	ensureLength (paddedLength + 4);
0: 	bytes[offset] = (byte) (((paddedLength+4) >>> 8) & 0xff);
0: 	bytes[offset + 1] = (byte) ((paddedLength+4) & 0xff);
0: 	bytes[offset + 2] = (byte) ((codePoint >>> 8) & 0xff);
0: 	bytes[offset + 3] = (byte) (codePoint & 0xff);
0: 	offset += 4;
0: 	System.arraycopy(buf,0,bytes,offset,bufLength);
0: 	offset += bufLength;
0: 	int fillLength = paddedLength - bufLength;
0: 	Arrays.fill(bytes,offset,offset + fillLength,padByte);
0: 	offset += fillLength;
0:     }
0:     /**
0:      * Write padded scalar byte array object  value
0:      *
0:      * @param	buf - byte array to be written
0:      * @param 	paddedLength - length to pad string to
0:      * @param	padByte - byte to be used for padding
0:      */
0:     protected void writeScalarPaddedBytes (byte[] buf, int paddedLength, byte padByte)
0:     {
0: 	int bufLength = buf.length;
0: 	int fillLength = paddedLength - bufLength;
0: 	ensureLength (paddedLength);
0: 	System.arraycopy(buf,0,bytes,offset,bufLength);
0: 	offset +=bufLength;
0: 	Arrays.fill(bytes,offset,offset + fillLength,padByte);
0: 	offset += fillLength;
0:     }
0:     /**
0:      * Write scalar byte array object includes length, codepoint and value
0:      *
0:      * @param 	codePoint - code point to write
0:      * @param	buf - byte array to be written
0:      */
0:     protected void writeScalarBytes (int codePoint, byte[] buf)
0:     {
0: 	int bufLength = buf.length;
0: 	ensureLength (bufLength + 4);
0: 	bytes[offset] = (byte) (((bufLength+4) >>> 8) & 0xff);
0: 	bytes[offset + 1] = (byte) ((bufLength+4) & 0xff);
0: 	bytes[offset + 2] = (byte) ((codePoint >>> 8) & 0xff);
0: 	bytes[offset + 3] = (byte) (codePoint & 0xff);
0: 	System.arraycopy(buf,0,bytes,offset + 4,bufLength);
0: 	offset += bufLength + 4;
0:     }
0:     /**
0:      * Write scalar byte array object includes length, codepoint and value
0:      *
0:      * @param 	codePoint - code point to write
0:      * @param	buf - byte array to be written
0:      * @param	start - starting point
0:      * @param 	length - length to write
0:      */
0:     protected void writeScalarBytes (int codePoint, byte[] buf, int start, int length)
0:     {
0: 	if (SanityManager.DEBUG)
0: 	    {
0: 		if (buf == null && length > start)
0: 		    SanityManager.THROWASSERT("Buf is null");
0: 		if (length - start > buf.length)
0: 		    SanityManager.THROWASSERT("Not enough bytes in buffer");
0: 	    }
0: 	int numBytes = length - start;
0: 	ensureLength (numBytes + 4);
0: 	bytes[offset] = (byte) (((numBytes+4) >>> 8) & 0xff);
0: 	bytes[offset + 1] = (byte) ((numBytes+4) & 0xff);
0: 	bytes[offset + 2] = (byte) ((codePoint >>> 8) & 0xff);
0: 	bytes[offset + 3] = (byte) (codePoint & 0xff);
0: 	offset += 4;
0: 	System.arraycopy(buf,start,bytes,offset,numBytes);
0: 	offset += numBytes;
0:     }
0:     // The following methods write data in the platform format
0:     // The platform format was indicated during connection time as ASC since
0:     // JCC doesn't read JVM platform (yet)
0:     /**
0:      * Write platform short
0:      *
0:      * @param 	v	value to be written
0:      */
0:     protected void writeShort (int v)
0:     {
0: 	writeNetworkShort(v);
0:     }
0:     /**
0:      * Write boolean as short
0:      * @param b boolean value true = 1 false = 0
0:      *
0:      */
0:     protected void writeShort(boolean b)
0:     {
0: 	writeNetworkShort(b ? 1 : 0);
0:     }
0:     /**
0:      * Write platform int
0:      *
0:      * @param 	v	value to be written
0:      */
0:     protected void writeInt (int v)
0:     {
0: 	writeNetworkInt(v);
0:     }
0:     /**
0:      * Write platform long
0:      *
0:      * @param 	v	value to be written
0:      */
0:     protected void writeLong (long v)
0:     {
0: 	ensureLength (8);
0: 	bytes[offset] =	(byte) ((v >>> 56) & 0xff);
0: 	bytes[offset + 1] =	(byte) ((v >>> 48) & 0xff);
0: 	bytes[offset + 2] =	(byte) ((v >>> 40) & 0xff);
0: 	bytes[offset + 3] =	(byte) ((v >>> 32) & 0xff);
0: 	bytes[offset + 4] =	(byte) ((v >>> 24) & 0xff);
0: 	bytes[offset + 5] =	(byte) ((v >>> 16) & 0xff);
0: 	bytes[offset + 6] =	(byte) ((v >>>  8) & 0xff);
0: 	bytes[offset + 7] =	(byte) ((v >>>  0) & 0xff);
0: 	offset += 8;
0:     }
0:     /**
0:      * Write platform float
0:      *
0:      * @param 	v	value to be written
0:      */
0:     protected void writeFloat (float v)
0:     {
0: 	writeInt (Float.floatToIntBits (v));
0:     }
0:     /**
0:      * Write platform double
0:      *
0:      * @param 	v	value to be written
0:      */
0:     protected void writeDouble (double v)
0:     {
0: 	writeLong (Double.doubleToLongBits (v));
0:     }
0:     /**
0:      * Write big decimal to buffer
0:      *
0:      * @param v value to write
0:      * @param precision Precison of decimal or numeric type
0:      * @param scale declared scale
0:      * @exception SQLException thrown if number of digits > 31
0:      */
0:     protected void writeBigDecimal (java.math.BigDecimal v, int precision, int scale)
0:     {
0: 	int length = precision / 2 + 1;
0: 	ensureLength (offset + length);
0: 	bigDecimalToPackedDecimalBytes (v,precision, scale);
0: 	offset += length;
0:     }
0:     /**
0:      * Write platform boolean
0:      *
0:      * @param 	v	value to be written
0:      */
0:     protected void writeBoolean (boolean v)
0:     {
0: 	ensureLength (1);
0: 	bytes[offset++] = (byte) ((v ? 1 : 0) & 0xff);
0:     }
0: 
0:     /**
0:      * Write length delimited string
0:      *
0:      * @param s value to be written with integer
0:      *
0:      * @exception DRDAProtocolException
0:      */
0:     protected void writeLDString(String s) throws DRDAProtocolException
0:     {
0: 	writeLDString(s,0);
0:     }
0: 
0: 
0:     /**
0:      * Write length delimited string
0:      *
0:      * @param s              value to be written with integer
0:      * @param index          column index to put in warning
0:      * @exception DRDAProtocolException
0:      */
0:     protected void writeLDString(String s, int index) throws DRDAProtocolException
0:     {
0: 	try {
0: 	    byte [] byteval = s.getBytes(NetworkServerControlImpl.DEFAULT_ENCODING);
0: 	    int origLen = byteval.length;
0: 	    boolean multiByteTrunc = false;
0: 	    int writeLen =
0: 		java.lang.Math.min(FdocaConstants.LONGVARCHAR_MAX_LEN,
0: 				   origLen);
0: 	    /*
0: 	      Need to make sure we truncate on character boundaries.
0: 	      We are assuming
0: 	      http://www.sun.com/developers/gadc/technicalpublications/articles/utf8.html
0: 	      To find the beginning of a multibyte character:
0: 	      1) Does the current byte start with the bit pattern 10xxxxxx?
0: 	      2) If yes, move left and go to step #1.
0: 	      3) Finished
0: 	      We assume that NetworkServerControlImpl.DEFAULT_ENCODING remains UTF-8
0: 	    */
0: 
0: 	    if (SanityManager.DEBUG)
0: 		    if (!(NetworkServerControlImpl.DEFAULT_ENCODING.equals("UTF8")))
0: 			SanityManager.THROWASSERT("Encoding assumed to be UTF8, but is actually" + NetworkServerControlImpl.DEFAULT_ENCODING);
0: 	    if (writeLen != origLen)
0: 		// first position on the first byte of the multibyte char
0: 		while ((byteval[writeLen -1] & 0xC0) == 0x80)
0: 		    {
0: 			multiByteTrunc = true;
0: 			writeLen--;
0: 			// Then subtract one more to get to the end of the
0: 			// previous character
0: 			if (multiByteTrunc == true)
0: 			    {
0: 				writeLen = writeLen -1;
0: 			    }
0: 		    }
0: 	    writeShort(writeLen);
0: 	    writeBytes(byteval,writeLen);
0: 	}
0: 	catch (Exception e) {
0: 	    //this should never happen
0: 	    agent.agentError("Encoding " + NetworkServerControlImpl.DEFAULT_ENCODING + " not supported");
0: 	}
0:     }
0:     /**
0:      * Write string with default encoding
0:      *
0:      * @param s value to be written
0:      *
0:      * @exception DRDAProtocolException
0:      */
0:     protected void writeString(String s) throws DRDAProtocolException
0:     {
0: 	try {
0: 	    writeBytes(s.getBytes(NetworkServerControlImpl.DEFAULT_ENCODING));
0: 	} catch (Exception e) {
0: 	    //this should never happen
0: 	    agent.agentError("Encoding " + NetworkServerControlImpl.DEFAULT_ENCODING + " not supported");
0: 	}
0:     }
0: 
0:     /**
0:      * Write string with default encoding and specified length
0:      *
0:      * @param s value to be written
0:      * @param length number of bytes to be written
0:      *
0:      * @exception DRDAProtocolException
0:      */
0:     protected void writeString(String s, int length) throws DRDAProtocolException
0:     {
0: 	byte[] bs = null;
0: 	try {
0: 	    bs = s.getBytes(NetworkServerControlImpl.DEFAULT_ENCODING);
0: 	} catch (Exception e) {
0: 	    //this should never happen
0: 	    agent.agentError("Encoding " + NetworkServerControlImpl.DEFAULT_ENCODING + " not supported");
0: 	}
0: 	int len = bs.length;
0: 	if (len >= length)
0: 	    writeBytes(bs, length);
0: 	else
0: 	    {
0: 		writeBytes(bs);
0: 		padBytes(NetworkServerControlImpl.SPACE_CHAR, length-len);
0: 	    }
0:     }
0: 
0:     /**
0:      * Write pad bytes using spaceChar
0:      *
0:      * @param   val	value to be written
0:      * @param	length		length to be written
0:      */
0:     protected void padBytes (byte val, int length)
0:     {
0: 	Arrays.fill(bytes,offset, offset + length,val);
0: 	offset += length;
0:     }
0: 
0:     /**
0:      * Flush buffer to outputstream
0:      *
0:      *
0:      * @exception IOException
0:      */
0:     protected void flush () throws java.io.IOException
0:     {
0: 	flush(agent.getOutputStream());
0:     }
0: 
0:     /**
0:      * Flush buffer to specified stream
0:      *
0:      * @param socketOutputStream
0:      *
0:      * @exception IOException
0:      */
0:     protected void flush(OutputStream socketOutputStream)
0: 	throws java.io.IOException
0:     {
0: 	try {
0: 	    socketOutputStream.write (bytes, 0, offset);
0: 	    socketOutputStream.flush();
0: 	}
0: 	finally {
0: 	    if ((dssTrace != null) && dssTrace.isComBufferTraceOn()) {
0: 		dssTrace.writeComBufferData (bytes,
0: 					     0,
0: 					     offset,
0: 					     DssTrace.TYPE_TRACE_SEND,
0: 					     "Reply",
0: 					     "flush",
0: 					     5);
0: 	    }
0: 	    reset(dssTrace);
0: 	}
0:     }
0: 
0:     // private methods
0: 
0:     /**
0:      * Write DSS header
0:      * DSS Header format is
0:      * 	2 bytes	- length
0:      *	1 byte	- 'D0'	- indicates DDM data
0:      * 	1 byte	- DSS format
0:      *		|---|---------|----------|
0:      *		| 0	|	flags |	type     |
0:      *		|---|---------|----------|
0:      *		| 0 | 1	2	3 | 4 5 6 7	 |
0:      *		|---|---------|----------|
0:      *		bit 0 - '0'
0:      *		bit 1 - '0' - unchained, '1' - chained
0:      *		bit 2 - '0'	- do not continue on error, '1' - continue on error
0:      *		bit 3 - '0' - next DSS has different correlator, '1' - next DSS has
0:      *						same correlator
0:      *		type - 1 - Request DSS
0:      *			 - 2 - Reply DSS
0:      *			 - 3 - Object DSS
0:      *			 - 4 - Communications DSS
0:      *			 - 5 - Request DSS where no reply is expected
0:      */
0:     private void beginDss (int dssType, boolean ensureLen)
0:     {
0: 
0: 	// save length position, the length will be written at the end
0: 	dssLengthLocation = offset;
0: 
0: 	// Should this really only be for non-stream DSSes?
0: 	if (ensureLen)
0: 	    ensureLength(6);
0: 
0: 	// Skip past length; we'll come back and set it later.
0: 	offset += 2;
0: 
0: 	// write gds info
0: 	bytes[offset] = (byte) 0xD0;
0: 
0: 	// Write DSS type, and default chain bit to be 
0: 	// DssConstants.DSSCHAIN_SAME_ID.  This default
0: 	// will be overridden by calls to "finalizeChain()"
0: 	// and/or calls to "beginDss(boolean, int)" for
0: 	// writing LOB data.
0: 	bytes[offset + 1] = (byte) dssType;
0: 	bytes[offset + 1] |= DssConstants.DSSCHAIN_SAME_ID;
0: 
0: 	// save correlationID for use in error messages while processing
0: 	// this DSS
0: 	correlationID = getCorrelationID();
0: 
0: 	// write the reply correlation id
0: 	bytes[offset + 2] = (byte) ((correlationID >>> 8) & 0xff);
0: 	bytes[offset + 3] = (byte) (correlationID & 0xff);
0: 	offset += 4;
0:     }
0: 
0:     /**
0:      * Finish a DSS Layer A object.
0:      * The length of dss object will be calculated based on the difference between the
0:      * start of the dss, saved on the beginDss call, and the current
0:      * offset into the buffer which marks the end of the data.	In the event
0:      * the length requires the use of continuation Dss headers, one for each 32k
0:      * chunk of data, the data will be shifted and the continuation headers
0:      * will be inserted with the correct values as needed.
0:      */
0:     private void finalizeDssLength ()
0:     {
0: 	// calculate the total size of the dss and the number of bytes which would
0: 	// require continuation dss headers.	The total length already includes the
0: 	// the 6 byte dss header located at the beginning of the dss.	It does not
0: 	// include the length of any continuation headers.
0: 	int totalSize = offset - dssLengthLocation;
0: 	int bytesRequiringContDssHeader = totalSize - DssConstants.MAX_DSS_LENGTH;
0: 
0: 	// determine if continuation headers are needed
0: 	if (bytesRequiringContDssHeader > 0)
0: 	    {
0: 		// the continuation headers are needed, so calculate how many.
0: 		// after the first 32767 worth of data, a continuation header is
0: 		// needed for every 32765 bytes (32765 bytes of data + 2 bytes of
0: 		// continuation header = 32767 Dss Max Size).
0: 		int contDssHeaderCount = bytesRequiringContDssHeader / 32765;
0: 		if (bytesRequiringContDssHeader % 32765 != 0)
0: 		    contDssHeaderCount++;
0: 
0: 		// right now the code will shift to the right.	In the future we may want
0: 		// to try something fancier to help reduce the copying (maybe keep
0: 		// space in the beginning of the buffer??).
0: 		// the offset points to the next available offset in the buffer to place
0: 		// a piece of data, so the last dataByte is at offset -1.
0: 		// various bytes will need to be shifted by different amounts
0: 		// depending on how many dss headers to insert so the amount to shift
0: 		// will be calculated and adjusted as needed.	ensure there is enough room
0: 		// for all the conutinuation headers and adjust the offset to point to the
0: 		// new end of the data.
0: 		int dataByte = offset - 1;
0: 		int shiftSize = contDssHeaderCount * 2;
0: 		ensureLength (shiftSize);
0: 		offset += shiftSize;
0: 
0: 		// Notes on the behavior of the Layer B segmenting loop below:
0: 		//
0: 		// We start with the right most chunk. For a 3-segment object we'd
0: 		// shift 2 segments: shift the first (rightmost) one 4 bytes and 
0: 		// the second one 2. Note that by 'first' we mean 'first time
0: 		// through the loop', but that is actually the last segment
0: 		// of data since we are moving right-to-left. For an object
0: 		// of K segments we will pass through this loop K-1 times.
0: 		// The 0th (leftmost) segment is not shifted, as it is
0: 		// already in the right place. When we are done, we will
0: 		// have made room in each segment for an additional
0: 		// 2 bytes for the continuation header. Thus, each
0: 		// segment K is shifted K*2 bytes to the right.
0: 		//
0: 		// Each time through the loop, "dataByte" points to the
0: 		// last byte in the segment; "dataToShift" is the amount of
0: 		// data that we need to shift, and "shiftSize" is the
0: 		// distance that we need to shift it. Since dataByte points
0: 		// at the last byte, not one byte beyond it (as with the
0: 		// "offset" variable used elsewhere in DDMWriter), the start
0: 		// of the segement is actually at (dataByte-dataToShift+1).
0: 		//
0: 		// After we have shifted the segment, we move back to the
0: 		// start of the segment and set the value of the 2-byte DSS
0: 		// continuation header, which needs to hold the length of
0: 		// this segment's data, together with the continuation flag
0: 		// if this is not the rightmost (passOne) segment.
0: 		//
0: 		// In general, each segment except the rightmost will contain
0: 		// 32765 bytes of data, plus the 2-byte header, and its
0: 		// continuation flag will be set, so the header value will
0: 		// be 0xFFFF. The rightmost segment will not have the
0: 		// continuation flag set, so its value may be anything from
0: 		// 0x0001 to 0x7FFF, depending on the amount of data in that
0: 		// segment.
0: 		//
0: 		// Note that the 0th (leftmost) segment also has a 2-byte
0: 		// DSS header, which needs to have its continuation flag set.
0: 		// This is done by resetting the "totalSize" variable below,
0: 		// at which point that variable no longer holds the total size
0: 		// of the object, but rather just the length of segment 0. The
0: 		// total size of the object was written using extended length
0: 		// bytes by the endDdm() method earlier.
0: 		//
0: 		// Additional information about this routine is available in the
0: 		// bug notes for DERBY-125:
0: 		// http://issues.apache.org/jira/browse/DERBY-125
0: 			
0: 		// mark passOne to help with calculating the length of the final (first or
0: 		// rightmost) continuation header.
0: 		boolean passOne = true;
0: 		do {
0: 		    // calculate chunk of data to shift
0: 		    int dataToShift = bytesRequiringContDssHeader % 32765;
0: 		    if (dataToShift == 0)
0: 			dataToShift = 32765;
0: 		    int startOfCopyData = dataByte - dataToShift + 1;
0: 		    System.arraycopy(bytes,startOfCopyData, bytes, 
0: 				     startOfCopyData + shiftSize, dataToShift);
0: 		    dataByte -= dataToShift;
0: 
0: 
0: 		    // calculate the value the value of the 2 byte continuation dss
0: 		    // header which includes the length of itself.  On the first pass,
0: 		    // if the length is 32767
0: 		    // we do not want to set the continuation dss header flag.
0: 		    int twoByteContDssHeader = dataToShift + 2;
0: 		    if (passOne)
0: 			passOne = false;
0: 		    else
0: 			{
0: 			    if (twoByteContDssHeader == DssConstants.MAX_DSS_LENGTH)
0: 				twoByteContDssHeader = (twoByteContDssHeader |
0: 							DssConstants.CONTINUATION_BIT);
0: 
0: 			}
0: 
0: 		    // insert the header's length bytes
0: 		    bytes[dataByte + shiftSize - 1] = (byte)
0: 			((twoByteContDssHeader >>> 8) & 0xff);
0: 		    bytes[dataByte + shiftSize] = (byte)
0: 			(twoByteContDssHeader & 0xff);
0: 
0: 		    // adjust the bytesRequiringContDssHeader and the amount to shift for
0: 		    // data in upstream headers.
0: 		    bytesRequiringContDssHeader -= dataToShift;
0: 		    shiftSize -= 2;
0: 
0: 		    // shift and insert another header for more data.
0: 		while (bytesRequiringContDssHeader > 0);
0: 
0: 		// set the continuation dss header flag on for the first header
0: 		totalSize = (DssConstants.MAX_DSS_LENGTH |
0: 			     DssConstants.CONTINUATION_BIT);
0: 
0: 
0: 	    }
0: 
0: 	// insert the length bytes in the 6 byte dss header.
0: 	bytes[dssLengthLocation] = (byte) ((totalSize >>> 8) & 0xff);
0: 	bytes[dssLengthLocation + 1] = (byte) (totalSize & 0xff);
0:     }
0: 
0:     protected void writeExtendedLength(long size)
0:     {
0: 	int numbytes = calculateExtendedLengthByteCount(size);
0: 	if (size > 0)
0: 	    writeInt(0x8000 | numbytes);
0: 	else
0: 	    writeInt(numbytes);
0:     }
0: 
0: 
0:     /**
0:      * Calculate extended length byte count which follows the DSS header
0:      * for extended DDM.
0:      *
0:      * @param ddmSize - size of DDM command
0:      * @return minimum number of extended length bytes needed. 0 indicates no
0:      * 	extended length needed.
0:      */
0:     private int calculateExtendedLengthByteCount (long ddmSize)
0:     {
0: 	if (ddmSize <= 0x7fff)
0: 	    return 0;
0: 	// JCC does not support 2 at this time, so we always send
0: 	// at least 4
0: 	//		else if (ddmSize <= 0xffff)
0: 	//	return 2;
0: 	else if (ddmSize <= 0xffffffffL)
0: 	    return 4;
0: 	else if (ddmSize <= 0xffffffffffffL)
0: 	    return 6;
0: 	else if (ddmSize <= 0x7fffffffffffffffL)
0: 	    return 8;
0: 	else
0: 	    // shouldn't happen
0: 	    // XXX - add sanity debug stuff here
0: 	    return 0;
0:     }
0: 
0:     /**
0:      * Ensure that there is space in the buffer
0:      *
0:      * @param length space required
0:      */
0:     private void ensureLength (int length)
0:     {
0: 	length += offset;
0: 	if (length > bytes.length) {
0: 	    if (SanityManager.DEBUG)
0: 		{
0: 		    agent.trace("DANGER - Expensive expansion of  buffer");
0: 		}
0: 	    byte newBytes[] = new byte[Math.max (bytes.length << 1, length)];
0: 	    System.arraycopy (bytes, 0, newBytes, 0, offset);
0: 	    bytes = newBytes;
0: 	}
0:     }
0: 
0: 
0:     /**
0:      * Write a Java <code>java.math.BigDecimal</code> to packed decimal bytes.
0:      *
0:      * @param b BigDecimal to write
0:      * @param precision Precision of decimal or numeric type
0:      * @return length written.
0:      *
0:      * @exception SQLException Thrown if # digits > 31
0:      */
0:     private int bigDecimalToPackedDecimalBytes (java.math.BigDecimal b,
0: 						int precision, int scale)
0: 	throws SQLException
0:     {
0: 	int declaredPrecision = precision;
0: 	int declaredScale = scale;
0: 
0: 	// packed decimal may only be up to 31 digits.
0: 	if (declaredPrecision > 31) // this is a bugcheck only !!!
0: 	    {
0: 		clearDdm ();
0: 		throw new java.sql.SQLException ("Packed decimal may only be up to 31 digits!");
0: 	    }
0: 
0: 	// get absolute unscaled value of the BigDecimal as a String.
0: 	String unscaledStr = b.unscaledValue().abs().toString();
0: 
0: 	// get precision of the BigDecimal.
0: 	int bigPrecision = unscaledStr.length();
0: 
0: 	if (bigPrecision > 31)
0: 	    {
0: 		clearDdm ();
0: 		throw new SQLException ("The numeric literal \"" +
0: 					b.toString() +
0: 					"\" is not valid because its value is out of range.",
0: 					"42820",
0: 					-405);
0: 	    }
0: 	int bigWholeIntegerLength = bigPrecision - bigScale;
0: 	if ( (bigWholeIntegerLength > 0) && (!unscaledStr.equals ("0")) ) {
0: 		{
0: 		    clearDdm ();
0: 		    throw new SQLException ("Overflow occurred during numeric data type conversion of \"" +
0: 					    b.toString() +
0: 					    "\".",
0: 					    "22003",
0: 					    -413);
0: 		}
/////////////////////////////////////////////////////////////////////////
0: 	    // If target scale is less than source scale,
0: 	    // discard excessive fraction.
0: 	    // set start index in source big decimal to ignore excessive fraction.
0: 	    bigIndex = bigPrecision-1-(bigScale-declaredScale);
0: 	    if (bigIndex < 0) {
0: 		// all digits are discarded, so only process the sign nybble.
0: 		bytes[offset+(packedIndex+1)/2] =
0: 		    (byte) ( (b.signum()>=0)?12:13 ); // sign nybble
0: 	    }
0: 	    else {
0: 		// process the last nybble together with the sign nybble.
0: 		bytes[offset+(packedIndex+1)/2] =
0: 		    (byte) ( ( (unscaledStr.charAt(bigIndex)-zeroBase) << 4 ) + // last nybble
0: 			     ( (b.signum()>=0)?12:13 ) ); // sign nybble
0: 	    }
0: 	    packedIndex-=2;
0: 	    bigIndex-=2;
0: 	    // If target scale is greater than source scale,
0: 	    // pad the fraction with zero.
0: 	    // set start index in source big decimal to pad fraction with zero.
0: 	    bigIndex = declaredScale-bigScale-1;
0: 	    // process the sign nybble.
0: 	    bytes[offset+(packedIndex+1)/2] =
0: 		(byte) ( (b.signum()>=0)?12:13 ); // sign nybble
0: 	    for (packedIndex-=2, bigIndex-=2; bigIndex>=0; packedIndex-=2, bigIndex-=2)
0: 		bytes[offset+(packedIndex+1)/2] = (byte) 0;
0: 	    if (bigIndex == -1) {
0: 		bytes[offset+(packedIndex+1)/2] =
0: 		    (byte) ( (unscaledStr.charAt(bigPrecision-1)-zeroBase) << 4 ); // high nybble
0: 		packedIndex-=2;
0: 		bigIndex = bigPrecision-3;
0: 	    }
0: 	    else {
0: 		bigIndex = bigPrecision-2;
0: 	    }
0: 	    bytes[offset+(packedIndex+1)/2] =
0: 		(byte) ( ( (unscaledStr.charAt(bigIndex)-zeroBase) << 4 ) + // high nybble
0: 			 ( unscaledStr.charAt(bigIndex+1)-zeroBase ) ); // low nybble
0: 	    bytes[offset+(packedIndex+1)/2] =
0: 		(byte) (unscaledStr.charAt(0) - zeroBase);
0: 	    packedIndex-=2;
0: 	    bytes[offset+(packedIndex+1)/2] = (byte) 0;
0:     }
0:     /***
0:      * Prepend zeros to numeric string
0:      *
0:      * @param s string
0:      * @param precision - length of padded string
0:      *
0:      * @return zero padded string
0:      */
0:     public static String zeroPadString(String s, int precision)
0:     {
0: 	if (s == null)
0: 	    return s;
0: 	int slen = s.length();
0: 	if (precision == slen)
0: 	    return s;
0: 	else if (precision > slen)
0: 	    {
0: 		char[] ca  = new char[precision - slen];
0: 		Arrays.fill(ca,0,precision - slen,'0');
0: 		return new String(ca) + s;
0: 	    }
0: 	else
0: 	    {
0: 		// Shouldn't happen but just in case 
0: 		// truncate
0: 		return s.substring(0,precision);
0: 	    }
0:     }
/////////////////////////////////////////////////////////////////////////
0:     private void sendBytes (java.io.OutputStream socketOutputStream,
0: 			    boolean flashStream ) 
0: 	throws java.io.IOException
0:     {
0: 	try {
0: 	    socketOutputStream.write (bytes, 0, offset);
0: 	    if(flashStream)
0: 		socketOutputStream.flush();
0: 	}
0: 	finally {
0: 	    if ((dssTrace != null) && dssTrace.isComBufferTraceOn()) {
0: 		dssTrace.writeComBufferData (bytes,
0: 					     0,
0: 					     offset,
0: 					     DssTrace.TYPE_TRACE_SEND,
0: 					     "Reply",
0: 					     "flush",
0: 					     5);
0: 	    }
0: 	    clearBuffer();
0: 	}
0: 
0:     protected String toDebugString(String indent)
0:     {
0: 	String s = indent + "***** DDMWriter toDebugString ******\n";
0: 	int byteslen = 0;
0: 	if ( bytes != null)
0: 	    byteslen = bytes.length;
0: 	s += indent + "byte array length  = " + bytes.length + "\n";
0: 	return s;
0:     /**
0:      * Reset any chaining state that needs to be reset
0:      * at time of the send
0:      */
0:     protected void resetChainState()
0:     {
0: 	prevHdrLocation = -1;
0:     }
0: 
0:     /**
0:      * Looks at chaining info for previous DSS written, and use
0:      * that to figure out what the correlation id for the current
0:      * DSS should be.  Return that correlation id.
0:      */
0:     private int getCorrelationID() {
0: 
0: 	int cId;
0: 	if (previousCorrId != DssConstants.CORRELATION_ID_UNKNOWN) {
0: 	    if (previousChainByte == DssConstants.DSSCHAIN_SAME_ID)
0: 		// then we have to use the last correlation id we sent.
0: 		cId = previousCorrId;
0: 	    else
0: 		// get correlation id as normal.
0: 		cId = nextCorrelationID++;
0: 	}
0: 	else {
0: 	    // must be the case that this is the first DSS we're
0: 	    // writing for this connection (because we haven't
0: 	    // called "endDss" yet).  So, get the corr id as
0: 	    // normal.
0: 	    cId = nextCorrelationID++;
0: 	return cId;
0: 
0:     }
0: 
0:     /**
0:      * Finalize the current DSS chain and send it if
0:      * needed.
0:      *
0:      * Updates the chaining state of the most recently-written-
0:      * to-buffer DSS to correspond to the most recently-read-
0:      * from-client request.  If that chaining state indicates
0:      * we've reached the end of a chain, then we go ahead
0:      * and send the buffer across the wire.
0:      * @param socketOutputStream Output stream to which we're flushing.
0:      */
0:     protected void finalizeChain(byte currChainByte,
0: 				 OutputStream socketOutputStream) throws DRDAProtocolException
0:     {
0: 
0: 	// Go back to previous DSS and override the default
0: 	// chain state (WITH_SAME_ID) with whatever the last
0: 	// request dictates.
0: 
0: 	if (prevHdrLocation != -1) {
0: 	    // Note: == -1 => the previous DSS was already sent; this
0: 	    // should only happen in cases where the buffer filled up
0: 	    // and we had to send it (which means we were probably
0: 	    // writing EXTDTA).  In such cases, proper chaining
0: 	    // should already have been handled @ time of send.
0: 	    bytes[prevHdrLocation + 3] &= 0x0F;	// Zero out old chain value.
0: 	    bytes[prevHdrLocation + 3] |= currChainByte;
0: 	// previousChainByte needs to match what we just did.
0: 	previousChainByte = currChainByte;
0: 	if (currChainByte != DssConstants.DSS_NOCHAIN)
0: 	    // then we're still inside a chain, so don't send.
0: 	    return;
0: 	// Else, we just ended the chain, so send it across.
0: 	if ((SanityManager.DEBUG) && (agent != null))
0: 	    agent.trace("Sending data");
0: 
0: 	resetChainState();
0: 	if (doesRequestContainData()) {
0: 	    try {
0: 		flush(socketOutputStream);
0: 	    } catch (java.io.IOException e) {
0: 		agent.markCommunicationsFailure(
0: 						"DDMWriter.finalizeChain()",
0: 						"OutputStream.flush()",
0: 						e.getMessage(),"*");
0: 	    }
0:     }
0:     /**
0:      * Takes note of the location of the most recently completed
0:      * DSS in the buffer, and then returns the current offset.
0:      * This method is used in conjunction with "clearDSSesBackToMark"
0:      * to allow for DRDAConnThread to "back-out" DSSes in the
0:      * event of errors.
0:      */
0:     protected int markDSSClearPoint()
0:     {
0: 	lastDSSBeforeMark = prevHdrLocation;
0: 	return offset;
0:     }
0:     /**
0:      * Does a logical "clear" of everything written to the buffer after
0:      * the received mark.  It's assumed that this method will be used
0:      * in error cases when we've started writing one or more DSSes,
0:      * but then hit an error and need to back out.  After backing out,
0:      * we'll always need to write _something_ back to the client to
0:      * indicate an error (typically, we just write an SQLCARD) but what
0:      * exactly gets written is handled in DRDAConnThread.  Here, we
0:      * just do the necessary prep so that whatever comes next will
0:      * succeed.
0:      */
0:     protected void clearDSSesBackToMark(int mark)
0:     {
0: 	// Logical clear.
0: 	offset = mark;
0: 	// Because we've just cleared out the most recently-
0: 	// written DSSes, we have to make sure the next thing
0: 	// we write will have the correct correlation id.  We
0: 	// do this by setting the value of 'nextCorrelationID'
0: 	// based on the chaining byte from the last remaining
0: 	// DSS (where "remaining" means that it still exists
0: 	// in the buffer after the clear).
0: 	if (lastDSSBeforeMark == -1)
0: 	    // we cleared out the entire buffer; reset corr id.
0: 	    nextCorrelationID = 1;
0: 	else {
0: 	    // last remaining DSS had chaining, so we set "nextCorrelationID"
0: 	    // to be 1 greater than whatever the last remaining DSS had as
0: 	    // its correlation id.
0: 	    nextCorrelationID = 1 + (int)
0: 		(((bytes[lastDSSBeforeMark + 4] & 0xff) << 8) +
0: 		 (bytes[lastDSSBeforeMark + 5] & 0xff));
0:     }
commit:f3ab04f
/////////////////////////////////////////////////////////////////////////
0: import java.io.InputStream;
0: import java.io.BufferedInputStream;
1: import java.io.BufferedOutputStream;
0: import org.apache.derby.iapi.reference.Property;
0: import org.apache.derby.iapi.services.property.PropertyUtil;
0: 
1: import java.io.IOException;
/////////////////////////////////////////////////////////////////////////
0:     
1:     protected void writeScalarStream (boolean chainedWithSameCorrelator,
0: 				      EXTDTAInputStream in,
0: 	    
0: 
0: 	    int spareDssLength = prepScalarStream( chainedWithSameCorrelator,
0: 											writeNullByte);
0: 	    
0: 				try {
0: 				    
0: 		OutputStream out = 
0: 		    placeLayerBStreamingBuffer( agent.getOutputStream() );
0: 		
0: 		boolean isLastSegment = false;
0: 		
0: 		while( !isLastSegment ){
0: 		    
0: 		    int spareBufferLength = bytes.length - offset;
0: 		    
0: 		    if( SanityManager.DEBUG ){
0: 		
0: 			if( PropertyUtil.getSystemProperty("derby.debug.suicideOfLayerBStreaming") != null )
0: 			    throw new IOException();
0: 				}
0: 		    
0: 		    bytesRead = in.read(bytes,
0: 					offset,
0: 					Math.min(spareDssLength,
0: 						 spareBufferLength));
0: 		    
0: 					totalBytesRead += bytesRead;
0: 					offset += bytesRead;
0: 		    spareDssLength -= bytesRead;
0: 		    spareBufferLength -= bytesRead;
0: 
0: 		    isLastSegment = peekStream(in) < 0;
0: 		    
0: 		    if(isLastSegment || 
0: 		       spareDssLength == 0){
0: 			
0: 			flushScalarStreamSegment (isLastSegment, 
0: 						  out);
0: 			
0: 			if( ! isLastSegment )
0: 			    spareDssLength = DssConstants.MAX_DSS_LENGTH - 2;
0: 
0: 		    
0: 		
0: 		out.flush();
0: 		
0: 	    }catch(IOException e){
0: 		agent.markCommunicationsFailure ("DDMWriter.writeScalarStream()",
0: 						 "",
0: 						 e.getMessage(),
0: 						 "*");
0: 				
/////////////////////////////////////////////////////////////////////////
0:     /**
1:      * prepScalarStream does the following prep for writing stream data:
1:      * 1.  Flushes an existing DSS segment, if necessary
1:      * 2.  Determines if extended length bytes are needed
1:      * 3.  Creates a new DSS/DDM header and a null byte indicator, if applicable
0:      *
1:      * If value of length was less than 0, this method processes streaming as Layer B Streaming.
1:      * cf. page 315 of specification of DRDA, Version 3, Volume 3 
0:      *
0:      */
0:   private int prepScalarStream( boolean chainedWithSameCorrelator,
0:                                    boolean writeNullByte) throws DRDAProtocolException
0:       ensureLength( DEFAULT_BUFFER_SIZE - offset );
0:       
0:       final int nullIndicatorSize = writeNullByte ? 1:0;
0:     
0:       // flush the existing DSS segment ,
0:       // if this stream will not fit in the send buffer or 
0:       // length of this stream is unknown.
0:       // Here, 10 stands for sum of headers of layer A and B.
0: 
/////////////////////////////////////////////////////////////////////////
0:       writeLengthCodePoint(0x8004,codePoint);
0:       //Here, 6 stands for header of layer A and 
0:       //4 stands for header of layer B.
0:       return DssConstants.MAX_DSS_LENGTH - 6 - 4 - nullIndicatorSize;
/////////////////////////////////////////////////////////////////////////
0: 	private void flushScalarStreamSegment ( boolean lastSegment,
0: 					        OutputStream out)
0: 	    if (! lastSegment) {
0: 		// 32k segment filled and not at end of data.
0: 					sendBytes (out,
0: 						   false);
0: 			    
0: 			}catch (java.io.IOException ioe) {
0: 
0: 	    }else{
/////////////////////////////////////////////////////////////////////////
0:     
1:     private void sendBytes (java.io.OutputStream socketOutputStream) 
0: 	throws java.io.IOException{
0: 	
0: 	sendBytes(socketOutputStream,
0: 		  true);
0: 	
0:     }
0:     
0:   private void sendBytes (java.io.OutputStream socketOutputStream,
0: 			  boolean flashStream ) 
0:       throws java.io.IOException
0:       if(flashStream)
0: 	  socketOutputStream.flush();
/////////////////////////////////////////////////////////////////////////
0: 	
0:     private static int peekStream(InputStream in) throws IOException{
0: 	    
0: 	in.mark(1);
0: 
0: 	try{
0: 	    return in.read();
0: 	    
0: 	}finally{
0: 	    in.reset();
0: 	    
0: 	}
0:     }
0: 
0:     
1:     private static int getLayerBStreamingBufferSize(){
0: 	return PropertyUtil.getSystemInt( Property.DRDA_PROP_STREAMOUTBUFFERSIZE , 0 );
0:     }
0:     
0:     
1:     private static OutputStream placeLayerBStreamingBuffer(OutputStream original){
0: 	
0: 	int size = getLayerBStreamingBufferSize();
0: 	
0: 	if(size < 1)
0: 	    return original;
0: 	else
0: 	    return new BufferedOutputStream( original, size );
0: 
0:     }
0:     
author:David Van Couvering
-------------------------------------------------------------------------------
commit:6b50965
/////////////////////////////////////////////////////////////////////////
1:      * @param value DSS length
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.drda
0:    (C) Copyright IBM Corp. 2001, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.drda;
0: 
0: import java.io.OutputStream;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import java.sql.SQLException;
0: import java.sql.DataTruncation;
0: import java.math.BigDecimal;
0: import org.apache.derby.iapi.error.ExceptionSeverity;
0: import java.util.Arrays;
0: 
0: /**
0: 	The DDMWriter is used to write DRDA protocol.   The DRDA Protocol is
0: 	described in the DDMReader class.
0: 	For more details, see DRDA Volume 3 (Distributed Data Management(DDM)
0: 		Architecture (DDS definition)
0: */
0: class DDMWriter
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 
0: 	private static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2001_2004;
0: 
0: 	// number of nesting levels for collections.  We need to mark the length
0: 	// location of the collection so that we can update it as we add more stuff
0: 	// to the collection
0: 	private final static int MAX_MARKS_NESTING = 10;
0: 
0: 	// Default buffer size
0: 	private final static int DEFAULT_BUFFER_SIZE = 32767;
0: 
0: 
0: 	static final BigDecimal ZERO = BigDecimal.valueOf(0L);
0: 
0: 	// output buffer
0: 	private byte[] bytes;
0: 
0: 	// offset into output buffer
0: 	private int offset;
0: 
0: 	// A saved mark in the stream is saved temporarily to revisit the location.
0: 	private int[] markStack = new int[MAX_MARKS_NESTING];
0: 
0: 	// top of the stack
0: 	private int top;
0: 
0: 	private boolean simpleDssFinalize = false;
0: 
0: 	// CCSID manager for translation of strings in the protocol to EBCDIC
0: 	private CcsidManager ccsidManager;
0: 
0: 	// DRDA connection thread for this writer
0: 	private DRDAConnThread agent;
0: 
0: 	//	This Object tracks the location of the current
0: 	//	Dss header length bytes.	This is done so
0: 	//	the length bytes can be automatically
0: 	//	updated as information is added to this stream.
0: 	private int dssLengthLocation;
0: 
0: 	// Current correlation ID
0: 	private	int correlationID;
0: 
0: 	// Next correlation ID
0: 	private int nextCorrelationID;
0: 
0: 	// is this DRDA protocol or CMD protocol
0: 	private boolean isDRDAProtocol;
0: 	// trace object of the associated session
0: 	private DssTrace dssTrace;
0: 
0: 
0: 
0: 	// Constructors
0: 	DDMWriter (int minSize, CcsidManager ccsidManager, DRDAConnThread agent, DssTrace dssTrace)
0: 	{
0: 		this.bytes = new byte[minSize];
0: 		this.ccsidManager = ccsidManager;
0: 		this.agent = agent;
0: 		reset(dssTrace);
0: 	}
0: 
0: 	DDMWriter (CcsidManager ccsidManager, DRDAConnThread agent, DssTrace dssTrace)
0: 	{
0: 		this.bytes = new byte[DEFAULT_BUFFER_SIZE];
0: 		this.ccsidManager = ccsidManager;
0: 		this.agent = agent;
0: 		reset(dssTrace);
0: 	}
0: 
0: 	/**
0: 	 * reset values for sending next message
0: 	 *
0: 	 */
0: 	protected void reset(DssTrace dssTrace)
0: 	{
0: 		offset = 0;
0: 		top = 0;
0: 		dssLengthLocation = 0;
0: 		nextCorrelationID = 1;
0: 		correlationID = DssConstants.CORRELATION_ID_UNKNOWN;
0: 		isDRDAProtocol = true;
0: 		this.dssTrace = dssTrace;
0: 	}
0: 
0: 	/**
0: 	 * set protocol to CMD protocol
0: 	 */
0: 	protected void setCMDProtocol()
0: 	{
0: 		isDRDAProtocol = false;
0: 	}
0: 
0: 	/**
0: 	 * Create DSS reply object
0: 	 */
0: 	protected void createDssReply()
0: 	{
0: 		// finish off previous DSS
0:     	if (offset != 0)
0:     		finalizePreviousChainedDss(false);
0: 		beginDss(DssConstants.DSSFMT_RPYDSS, nextCorrelationID++);
0: 		simpleDssFinalize = false;
0: 	}
0: 
0: 	/**
0: 	 * Create DSS request object
0: 	 */
0: 	protected void createDssRequest(int corrID)
0: 	{
0: 		// finish off previous DSS
0:     	if (offset != 0)
0:     		finalizePreviousChainedDss((correlationID == corrID));
0: 		beginDss(DssConstants.DSSFMT_RQSDSS, corrID);
0: 		simpleDssFinalize = false;
0: 	}
0: 	/**
0: 	 * Create DSS data object
0: 	 */
0: 	protected void createDssObject(boolean reuseCorrID)
0: 	{
0: 		// finish off previous DSS - objects are always part of a previous
0: 		// DSS reply - so correlation id should be the same
0:     	if (offset != 0)
0:     		finalizePreviousChainedDss (reuseCorrID);
0: 		beginDss(DssConstants.DSSFMT_OBJDSS, (reuseCorrID ? correlationID : nextCorrelationID++));
0: 		simpleDssFinalize = false;
0: 	}
0: 	/**
0: 	 * Create DSS data object
0: 	 */
0: 	protected void createDssObject()
0: 	{
0: 		createDssObject(true);
0: 	}
0: 
0: 	/**
0: 	 * End DSS header by writing the length in the length location
0: 	 *
0: 	 */
0: 	protected void endDss ()
0: 	{
0: 		int val = offset - dssLengthLocation;
0: 		bytes[dssLengthLocation] = (byte) ((val >>> 8) & 0xff);
0: 		bytes[dssLengthLocation + 1] = (byte) (val & 0xff);
0: 	}
0: 
0: 	/**
0: 	 * End final DDM and DSS header by writing the length in the length location
0: 	 *
0: 	 */
0: 	protected void endDdmAndDss ()
0: 	{
0: 		endDdm();	// updates last DDM object
0: 		endDss();
0: 	}
0: 	/**
0: 	 * Copy Data to End
0: 	 * Create a buffer and copy from the position given to the end of data
0: 	 *
0: 	 * @param start
0: 	 */
0: 	protected byte [] copyDataToEnd(int start)
0: 	{
0: 		int length = offset - start;
0: 		byte [] temp = new byte[length];
0: 		System.arraycopy(bytes,start,temp,0,length);
0: 		return temp;
0: 	}
0: 
0: 	// Collection methods
0: 
0: 	/**
0: 	 * Mark the location of the length bytes for the collection so they
0: 	 * can be updated later
0: 	 *
0: 	 */
0: 	protected void startDdm (int codePoint)
0: 	{
0: 		// save the location of the beginning of the collection so
0: 		// that we can come back and fill in the length bytes
0: 		markStack[top++] = offset;
0: 		offset += 2; // move past the length bytes before writing the code point
0: 		bytes[offset] = (byte) ((codePoint >>> 8) & 0xff);
0: 		bytes[offset + 1] = (byte) (codePoint & 0xff);
0: 		offset += 2;
0: 	}
0: 
0: 	/**
0: 	 * Erase all writes for the current ddm and reset the
0: 	 * top
0: 	 */
0: 	protected void clearDdm ()
0: 	{
0: 		offset = markStack[top--];
0: 	}
0: 
0: 	/**
0: 	 * Clear the entire send buffer
0: 	 *
0: 	 */
0: 	protected void clearBuffer()
0: 	{
0: 		offset = 0;
0: 		top = 0;
0: 		dssLengthLocation = 0;
0: 		correlationID = DssConstants.CORRELATION_ID_UNKNOWN;
0: 		isDRDAProtocol = true;
0: 	}
0: 
0: 	/**
0: 	 * End the current DDM
0: 	 *
0: 	 */
0: 	protected void endDdm ()
0: 	{
0: 		// remove the top length location offset from the mark stack
0: 		// calculate the length based on the marked location and end of data.
0: 		int lengthLocation = markStack[--top];
0: 		int length = offset - lengthLocation;
0: 
0: 		// determine if any extended length bytes are needed.	the value returned
0: 		// from calculateExtendedLengthByteCount is the number of extended length
0: 		// bytes required. 0 indicates no exteneded length.
0: 		int extendedLengthByteCount = calculateExtendedLengthByteCount (length);
0: 		if (extendedLengthByteCount != 0)
0: 		{
0: 			// ensure there is enough room in the buffer for the extended length bytes.
0: 			ensureLength (extendedLengthByteCount);
0: 
0: 			// calculate the length to be placed in the extended length bytes.
0: 			// this length does not include the 4 byte llcp.
0: 			int extendedLength = length - 4;
0: 
0: 			// shift the data to the right by the number of extended
0: 			// length bytes needed.
0: 			int extendedLengthLocation = lengthLocation + 4;
0: 			System.arraycopy (bytes,
0: 					              extendedLengthLocation,
0: 					              bytes,
0: 					              extendedLengthLocation + extendedLengthByteCount,
0: 					              extendedLength);
0: 
0: 			// write the extended length
0: 			int shiftSize = (extendedLengthByteCount -1) * 8;
0: 			for (int i = 0; i < extendedLengthByteCount; i++)
0: 			{
0: 				bytes[extendedLengthLocation++] =
0: 					(byte) ((extendedLength >>> shiftSize ) & 0xff);
0: 				shiftSize -= 8;
0: 			}
0: 
0: 			// adjust the offset to account for the shift and insert
0: 			offset += extendedLengthByteCount;
0: 
0: 			// the two byte length field before the codepoint contains the length
0: 			// of itself, the length of the codepoint, and the number of bytes used
0: 			// to hold the extended length.	the 2 byte length field also has the first
0: 			// bit on to indicate extended length bytes were used.
0: 			length = extendedLengthByteCount + 4;
0: 			length |= DssConstants.CONTINUATION_BIT;
0: 		}
0: 
0: 		// write the 2 byte length field (2 bytes before codepoint).
0: 		bytes[lengthLocation] = (byte) ((length >>> 8) & 0xff);
0: 		bytes[lengthLocation+1] = (byte) (length & 0xff);
0: 
0: 	}
0: 
0: 	/**
0: 	 * Get offset
0: 	 *
0: 	 * @return offset into the buffer
0: 	 */
0: 	protected int getOffset()
0: 	{
0: 		return offset;
0: 	}
0: 
0: 	/**
0: 	 * Set offset
0: 	 *
0: 	 * @param value new offset value
0: 	 */
0: 	protected void setOffset(int value)
0: 	{
0: 		offset = value;
0: 	}
0: 
0: 
0: 
0: 	// Write routines
0: 
0: 	/**
0: 	 * Write byte
0: 	 *
0: 	 * @param 	value	byte to be written
0: 	 */
0: 	protected void writeByte (int value)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (value > 255)
0: 				SanityManager.THROWASSERT(
0: 									   "writeByte value: " + value +
0: 									   " may not be > 255");
0: 		}
0: 
0: 		ensureLength (1);
0: 		bytes[offset++] = (byte) (value & 0xff);
0: 	}
0: 
0: 
0: 	/**
0: 	 * Write network short
0: 	 *
0: 	 * @param 	value	value to be written
0: 	 */
0: 	protected void writeNetworkShort (int value)
0: 	{
0: 		ensureLength (2);
0: 		bytes[offset] = (byte) ((value >>> 8) & 0xff);
0: 		bytes[offset + 1] = (byte) (value & 0xff);
0: 		offset += 2;
0: 	}
0: 
0: 	/**
0: 	 * Write network int
0: 	 *
0: 	 * @param 	value	value to be written
0: 	 */
0: 	protected void writeNetworkInt (int value)
0: 	{
0: 		ensureLength (4);
0: 		bytes[offset] = (byte) ((value >>> 24) & 0xff);
0: 		bytes[offset + 1] = (byte) ((value >>> 16) & 0xff);
0: 		bytes[offset + 2] = (byte) ((value >>> 8) & 0xff);
0: 		bytes[offset + 3] = (byte) (value & 0xff);
0: 		offset += 4;
0: 	}
0: 
0: 
0: 	/**
0: 	 * Write byte array
0: 	 *
0: 	 * @param 	buf	byte array to be written
0: 	 * @param	length  - length to write
0: 	 */
0: 	protected void writeBytes (byte[] buf, int length)
0: 	{
0: 		writeBytes(buf, 0,length);
0: 	}
0: 
0: 
0: 
0: 	/**
0: 	 * Write byte array
0: 	 *
0: 	 * @param 	buf	byte array to be written
0: 	 * @param	start  - starting position
0: 	 * @param	length  - length to write
0: 	 */
0: 	protected void writeBytes (byte[] buf, int start, int length)
0: 	{
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (buf == null && length > 0)
0: 		    	SanityManager.THROWASSERT("Buf is null");
0: 			if (length + start - 1 > buf.length)
0: 		    	SanityManager.THROWASSERT("Not enough bytes in buffer");
0: 
0: 		}
0: 		ensureLength (length);
0: 		System.arraycopy(buf,start,bytes,offset,length);
0: 		offset += length;
0: 	}
0: 	/**
0: 	 * Write byte array
0: 	 *
0: 	 * @param 	buf	byte array to be written
0: 	 **/
0: 	protected void writeBytes (byte[] buf)
0: 	{
0: 		writeBytes(buf,buf.length);
0: 	}
0: 
0: 
0: 
0: 	protected void writeLDBytes(byte[] buf)
0: 	{
0: 		writeLDBytes(buf, 0);
0: 	}
0: 
0: 	protected void writeLDBytes(byte[] buf, int index)
0: 	{
0: 
0: 		int length = buf.length;
0: 		int writeLen =  buf.length;
0: 
0: 		writeShort(writeLen);
0: 
0: 		writeBytes(buf,0,writeLen);
0: 	}
0: 
0: 
0: 	/**
0: 	 * Write code point and 4 bytes
0: 	 *
0: 	 * @param 	codePoint - code point to write
0: 	 * @param	value  - value to write after code point
0: 	 */
0: 	void writeCodePoint4Bytes (int codePoint, int value)
0: 	{
0: 		ensureLength (4);
0: 		bytes[offset] = (byte) ((codePoint >>> 8) & 0xff);
0: 		bytes[offset + 1] = (byte) (codePoint & 0xff);
0: 		bytes[offset + 2] = (byte) ((value >>> 8) & 0xff);
0: 		bytes[offset + 3] = (byte) (value & 0xff);
0: 		offset += 4;
0: 	}
0: 
0: 	/**
0: 	 * Write scalar 1 byte object includes length, codepoint and value
0: 	 *
0: 	 * @param 	codePoint - code point to write
0: 	 * @param	value  - value to write after code point
0: 	 */
0: 	void writeScalar1Byte (int codePoint, int value)
0: 	{
0: 		ensureLength (5);
0: 		bytes[offset] = 0x00;
0: 		bytes[offset + 1] = 0x05;
0: 		bytes[offset + 2] = (byte) ((codePoint >>> 8) & 0xff);
0: 		bytes[offset + 3] = (byte) (codePoint & 0xff);
0: 		bytes[offset + 4] = (byte) (value & 0xff);
0: 		offset += 5;
0: 	}
0: 
0: 	/**
0: 	 * Write scalar 2 byte object includes length, codepoint and value
0: 	 *
0: 	 * @param 	codePoint - code point to write
0: 	 * @param	value  - value to write after code point
0: 	 */
0: 	protected void writeScalar2Bytes (int codePoint, int value)
0: 	{
0: 		ensureLength (6);
0: 		bytes[offset] = 0x00;
0: 		bytes[offset + 1] = 0x06;
0: 		bytes[offset + 2] = (byte) ((codePoint >>> 8) & 0xff);
0: 		bytes[offset + 3] = (byte) (codePoint & 0xff);
0: 		bytes[offset + 4] = (byte) ((value >>> 8) & 0xff);
0: 		bytes[offset + 5] = (byte) (value & 0xff);
0: 		offset += 6;
0: 	}
0: 
0: 	protected void writeScalar2Bytes ( int value)
0: 	{
0: 		ensureLength (2);
0: 		bytes[offset] = (byte) ((value >>> 8) & 0xff);
0: 		bytes[offset + 1] = (byte) (value & 0xff);
0: 		offset += 2;
0: 	}
0: 
0: 	/**
0: 	 * Write length and codepoint
0: 	 *
0: 	 * @param 	length - length of object
0: 	 * @param 	codePoint - code point to write
0: 	 */
0: 	protected void startDdm (int length, int codePoint)
0: 	{
0: 		ensureLength (4);
0: 		bytes[offset] = (byte) ((length >>> 8) & 0xff);
0: 		bytes[offset + 1] = (byte) (length & 0xff);
0: 		bytes[offset + 2] = (byte) ((codePoint >>> 8) & 0xff);
0: 		bytes[offset + 3] = (byte) (codePoint & 0xff);
0: 		offset += 4;
0: 	}
0: 
0: 	/**
0: 	 * Write scalar byte array object includes length, codepoint and value
0: 	 *
0: 	 * @param 	codePoint - code point to write
0: 	 * @param	buf  - value to write after code point
0: 	 * @param	length - number of bytes to write
0: 	 */
0: 	protected void writeScalarBytes (int codePoint, byte[] buf, int length)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (buf == null && length > 0)
0: 		    	SanityManager.THROWASSERT("Buf is null");
0: 			if (length > buf.length)
0: 		    	SanityManager.THROWASSERT("Not enough bytes in buffer");
0: 		}
0: 		ensureLength (length + 4);
0: 		bytes[offset] = (byte) (((length+4) >>> 8) & 0xff);
0: 		bytes[offset + 1] = (byte) ((length+4) & 0xff);
0: 		bytes[offset + 2] = (byte) ((codePoint >>> 8) & 0xff);
0: 		bytes[offset + 3] = (byte) (codePoint & 0xff);
0: 		System.arraycopy(buf,0,bytes,offset + 4, length);
0: 		offset += length + 4;
0: 	}
0: 
0: 
0: 	protected int  writeScalarStream (boolean chained,
0: 									  boolean chainedWithSameCorrelator,
0: 									  int codePoint,
0: 									  int length,
0: 									  java.io.InputStream in,
0: 									  boolean writeNullByte) 
0: 		throws DRDAProtocolException
0: 	{
0: 		int leftToRead = length;
0: 		int bytesToRead = prepScalarStream (chained,
0: 											chainedWithSameCorrelator,
0: 											codePoint,
0: 											writeNullByte,
0: 											leftToRead);
0: 		
0: 		if (length == 0)
0: 			return 0;
0: 
0: 		// write the data
0: 		int bytesRead = 0;
0: 		int totalBytesRead = 0;
0: 		do {
0: 			do {
0: 				try {
0: 					bytesRead = in.read (bytes, offset, bytesToRead);
0: 					totalBytesRead += bytesRead;
0: 				}
0: 				catch (java.io.IOException e) {
0: 					padScalarStreamForError (leftToRead, bytesToRead);
0: 					return totalBytesRead;
0: 				}
0: 				if (bytesRead == -1) {
0: 					padScalarStreamForError (leftToRead, bytesToRead);
0: 					return totalBytesRead;
0: 				}
0: 				else {
0: 					bytesToRead -= bytesRead;
0: 					offset += bytesRead;
0: 					leftToRead -= bytesRead;
0: 				}
0: 			} while (bytesToRead > 0);
0: 			
0: 			bytesToRead = flushScalarStreamSegment (leftToRead, bytesToRead);
0: 		} while (leftToRead > 0);
0: 		
0: 		// check to make sure that the specified length wasn't too small
0: 		try {
0: 			if (in.read() != -1) {
0: 				totalBytesRead += 1;
0: 			}
0: 		}
0: 		catch (java.io.IOException e) {
0: 			// Encountered error in stream length verification for 
0: 			// InputStream, parameter #" + parameterIndex + ".  
0: 			// Don't think we need to error for this condition
0: 		}
0: 		return totalBytesRead;
0: 	}
0: 	
0: 	
0: 	private void beginDss (boolean dssHasSameCorrelator,
0: 						   boolean chainedToNextStructure,
0: 						   boolean nextHasSameCorrelator,
0: 						   int dssType,
0: 						   int corrId,
0: 						   boolean simpleFinalizeBuildingNextDss)
0:   {
0: 	  if (doesRequestContainData()) {
0: 		  if (simpleDssFinalize)
0: 		  {
0: 			  finalizeDssLength();
0: 
0: 		  }
0: 		  else
0: 			  finalizePreviousChainedDss (dssHasSameCorrelator);
0: 	  }
0: 
0: 	  ensureLength (6);
0: 
0: 	  // save the length position and skip
0: 	  // note: the length position is saved so it can be updated
0: 	  // with a different value later.
0: 	  dssLengthLocation = offset;
0: 	  // always turn on chaining flags... this is helpful for lobs...
0: 	  // these bytes will get rest if dss lengths are finalized.
0: 	  bytes[offset] = (byte) 0xFF;
0: 	  bytes[offset + 1] = (byte) 0xFF;
0: 
0: 	  // insert the manditory 0xD0 and the dssType
0: 	  bytes[offset + 2] = (byte) 0xD0;
0: 
0:     if (chainedToNextStructure) {
0:       dssType |= DssConstants.GDSCHAIN;
0:       if (nextHasSameCorrelator)
0:         dssType |= DssConstants.GDSCHAIN_SAME_ID;
0:     }
0:     bytes[offset + 3] = (byte) (dssType & 0xff);
0: 
0:     // write the request correlation id
0:     // use method that writes a short !!!
0:     bytes[offset + 4] = (byte) ((corrId >>> 8) & 0xff);
0:     bytes[offset + 5] = (byte) (corrId & 0xff);
0: 	offset +=6;
0:     simpleDssFinalize = simpleFinalizeBuildingNextDss;
0:   }
0: 
0: 
0:   // prepScalarStream does the following prep for writing stream data:
0:   // 1.  Flushes an existing DSS segment, if necessary
0:   // 2.  Determines if extended length bytes are needed
0:   // 3.  Creates a new DSS/DDM header and a null byte indicator, if applicable
0:   protected int prepScalarStream  (boolean chained,
0:                                    boolean chainedWithSameCorrelator,
0:                                    int codePoint,
0:                                    boolean writeNullByte,
0:                                    int leftToRead) throws DRDAProtocolException
0:   {
0:     int extendedLengthByteCount;
0: 
0:     int nullIndicatorSize = 0;
0:     if (writeNullByte) 
0: 		nullIndicatorSize = 1;
0: 	extendedLengthByteCount = calculateExtendedLengthByteCount (leftToRead + 4 + nullIndicatorSize);
0: 
0:     // flush the existing DSS segment if this stream will not fit in the send buffer
0:     if (10 + extendedLengthByteCount + nullIndicatorSize + leftToRead + offset > DssConstants.MAX_DSS_LENGTH) {
0:       try {
0:         if (simpleDssFinalize)
0:           finalizeDssLength();
0:         else
0:           finalizePreviousChainedDss (true);
0:         sendBytes(agent.getOutputStream());
0:       }
0:       catch (java.io.IOException e) {
0:          agent.markCommunicationsFailure ("DDMWriter.writeScalarStream()",
0:                                               "OutputStream.flush()",
0:                                               e.getMessage(),"*");
0:       }
0:     }
0: 
0:     // buildStreamDss should not call ensure length.
0:     beginDss (true,
0: 			  chained,
0: 			  chainedWithSameCorrelator,
0: 			  DssConstants.GDSFMT_OBJDSS,
0: 			  correlationID,
0: 			  true);
0: 
0:     if (extendedLengthByteCount > 0) {
0:       // method should never ensure length
0:       writeLengthCodePoint (0x8004 + extendedLengthByteCount, codePoint);
0: 
0:       if (writeNullByte)
0:         writeExtendedLengthBytes (extendedLengthByteCount, leftToRead + 1);
0:       else
0:         writeExtendedLengthBytes (extendedLengthByteCount, leftToRead);
0:     }
0:     else {
0:       if (writeNullByte)
0:         writeLengthCodePoint (leftToRead + 4 + 1, codePoint);
0:       else
0:         writeLengthCodePoint (leftToRead + 4, codePoint);
0:     }
0: 
0:     // write the null byte, if necessary
0:     if (writeNullByte)
0:       writeByte(0x0);
0: 
0:     int bytesToRead;
0: 
0:     if (writeNullByte)
0:       bytesToRead = Math.min (leftToRead, DssConstants.MAX_DSS_LENGTH - 6 - 4 - 1 - extendedLengthByteCount);
0:     else
0:       bytesToRead = Math.min (leftToRead, DssConstants.MAX_DSS_LENGTH - 6 - 4 - extendedLengthByteCount);
0: 
0:     return bytesToRead;
0:   }
0: 
0: 
0:   // method to determine if any data is in the request.
0:   // this indicates there is a dss object already in the buffer.
0: 	protected boolean doesRequestContainData()
0: 	{
0: 		return offset != 0;
0: 	}
0: 
0: 
0: 	// Writes out a scalar stream DSS segment, along with DSS continuation
0: 	// headers if necessary.
0: 	protected int flushScalarStreamSegment (int leftToRead,
0: 											int bytesToRead)
0: 		throws DRDAProtocolException
0:   {
0: 	  int newBytesToRead = bytesToRead;
0: 
0: 	  // either at end of data, end of dss segment, or both.
0: 	  if (leftToRead != 0) {
0: 		  // 32k segment filled and not at end of data.
0: 		  if ((Math.min (2 + leftToRead, 32767)) > (bytes.length - offset)) {
0:         try {
0:           sendBytes (agent.getOutputStream());
0:         }
0:         catch (java.io.IOException ioe) {
0: 			agent.markCommunicationsFailure ("DDMWriter.flushScalarStreamSegment()",
0:                                                "",
0:                                                ioe.getMessage(),
0:                                                "*");
0:         }
0:       }
0:       dssLengthLocation = offset;
0:       bytes[offset++] = (byte) (0xff);
0:       bytes[offset++] = (byte) (0xff);
0:       newBytesToRead = Math.min (leftToRead,32765);
0:     }
0: 
0:     return newBytesToRead;
0:   }
0: 
0:   // the offset must not be updated when an error is encountered
0:   // note valid data may be overwritten
0:   protected void padScalarStreamForError (int leftToRead, int bytesToRead) throws DRDAProtocolException
0:   {
0:     do {
0:       do {
0:         bytes[offset++] = (byte)(0x0); // use 0x0 as the padding byte
0:         bytesToRead--;
0:         leftToRead--;
0:       } while (bytesToRead > 0);
0: 
0:       bytesToRead = flushScalarStreamSegment (leftToRead, bytesToRead);
0:     } while(leftToRead > 0);
0:   }
0: 
0: 
0: 
0: 	private void writeExtendedLengthBytes (int extendedLengthByteCount, long length)
0: 	{
0: 	int shiftSize = (extendedLengthByteCount -1) * 8;
0:     for (int i = 0; i < extendedLengthByteCount; i++) {
0:       bytes[offset + i] = (byte) ((length >>> shiftSize) & 0xff);
0:       shiftSize -= 8;
0:     }
0: 	offset += extendedLengthByteCount;
0:   }
0: 
0: 
0:   // insert a 4 byte length/codepoint pair into the buffer.
0:   // total of 4 bytes inserted in buffer.
0:   // Note: the length value inserted in the buffer is the same as the value
0:   // passed in as an argument (this value is NOT incremented by 4 before being
0:   // inserted).
0:   void writeLengthCodePoint (int length, int codePoint)
0:   {
0:     ensureLength (4);
0:     bytes[offset] = (byte) ((length >>> 8) & 0xff);
0:     bytes[offset + 1] = (byte) (length & 0xff);
0:     bytes[offset + 2] = (byte) ((codePoint >>> 8) & 0xff);
0:     bytes[offset + 3] = (byte) (codePoint & 0xff);
0: 	offset +=4;
0:   }
0: 
0: 	/**
0: 	 * Write scalar object header includes length and codepoint
0: 	 *
0: 	 * @param 	codePoint - code point to write
0: 	 * @param	dataLength - length of object data
0: 	 * @param	length - number of bytes to write
0: 	 */
0: 	protected void writeScalarHeader (int codePoint, int dataLength)
0: 	{
0: 		ensureLength (dataLength + 4);
0: 		bytes[offset] = (byte) (((dataLength+4) >>> 8) & 0xff);
0: 		bytes[offset + 1] = (byte) ((dataLength+4) & 0xff);
0: 		bytes[offset + 2] = (byte) ((codePoint >>> 8) & 0xff);
0: 		bytes[offset + 3] = (byte) (codePoint & 0xff);
0: 		offset += 4;
0: 	}
0: 
0: 	/**
0: 	 * Write scalar string object includes length, codepoint and value
0: 	 * the string is converted into the appropriate codeset (EBCDIC)
0: 	 *
0: 	 * @param 	codePoint - code point to write
0: 	 * @param	string - string to be written
0: 	 */
0: 	void writeScalarString (int codePoint, String string)
0: 	{
0: 		int stringLength = string.length();
0: 		ensureLength ((stringLength * 2)  + 4);
0: 		bytes[offset] = (byte) (((stringLength+4) >>> 8) & 0xff);
0: 		bytes[offset + 1] = (byte) ((stringLength+4) & 0xff);
0: 		bytes[offset + 2] = (byte) ((codePoint >>> 8) & 0xff);
0: 		bytes[offset + 3] = (byte) (codePoint & 0xff);
0: 		offset = ccsidManager.convertFromUCS2 (string, bytes, offset + 4);
0: 	}
0: 
0: 	/**
0: 	 * Write padded scalar string object includes length, codepoint and value
0: 	 * the string is converted into the appropriate codeset (EBCDIC)
0: 	 *
0: 	 * @param 	codePoint - code point to write
0: 	 * @param	string - string to be written
0: 	 * @param 	paddedLength - length to pad string to
0: 	 */
0: 	void writeScalarPaddedString (int codePoint, String string, int paddedLength)
0: 	{
0: 		int stringLength = string.length();
0: 		int fillLength = paddedLength - stringLength;
0: 		ensureLength (paddedLength + 4);
0: 		bytes[offset] = (byte) (((paddedLength+4) >>> 8) & 0xff);
0: 		bytes[offset + 1] = (byte) ((paddedLength+4) & 0xff);
0: 		bytes[offset + 2] = (byte) ((codePoint >>> 8) & 0xff);
0: 		bytes[offset + 3] = (byte) (codePoint & 0xff);
0: 		offset = ccsidManager.convertFromUCS2 (string, bytes, offset + 4);
0: 		Arrays.fill(bytes,offset, offset + fillLength,ccsidManager.space);
0: 		offset += fillLength;
0: 	}
0: 
0: 	/**
0: 	 * Write padded scalar string object value
0: 	 * the string is converted into the appropriate codeset (EBCDIC)
0: 	 *
0: 	 * @param	string - string to be written
0: 	 * @param 	paddedLength - length to pad string to
0: 	 */
0: 	protected void writeScalarPaddedString (String string, int paddedLength)
0: 	{
0: 		int stringLength = string.length();
0: 
0: 		int fillLength = paddedLength -stringLength;
0: 		ensureLength (paddedLength);
0: 		offset = ccsidManager.convertFromUCS2 (string, bytes, offset);
0: 		Arrays.fill(bytes,offset, offset + fillLength,ccsidManager.space);
0: 		offset += fillLength;
0: 	}
0: 
0: 	/**
0: 	 * Write padded scalar byte array object includes length, codepoint and value
0: 	 *
0: 	 * @param 	codePoint - code point to write
0: 	 * @param	buf - byte array to be written
0: 	 * @param 	paddedLength - length to pad string to
0: 	 * @param	padByte - byte to be used for padding
0: 	 */
0: 	protected void writeScalarPaddedBytes (int codePoint, byte[] buf, int paddedLength, byte padByte)
0: 	{
0: 		int bufLength = buf.length;
0: 		ensureLength (paddedLength + 4);
0: 		bytes[offset] = (byte) (((paddedLength+4) >>> 8) & 0xff);
0: 		bytes[offset + 1] = (byte) ((paddedLength+4) & 0xff);
0: 		bytes[offset + 2] = (byte) ((codePoint >>> 8) & 0xff);
0: 		bytes[offset + 3] = (byte) (codePoint & 0xff);
0: 		offset += 4;
0: 		System.arraycopy(buf,0,bytes,offset,bufLength);
0: 		offset += bufLength;
0: 		int fillLength = paddedLength - bufLength;
0: 		Arrays.fill(bytes,offset,offset + fillLength,padByte);
0: 		offset += fillLength;
0: 	}
0: 
0: 	/**
0: 	 * Write padded scalar byte array object  value
0: 	 *
0: 	 * @param	buf - byte array to be written
0: 	 * @param 	paddedLength - length to pad string to
0: 	 * @param	padByte - byte to be used for padding
0: 	 */
0: 	protected void writeScalarPaddedBytes (byte[] buf, int paddedLength, byte padByte)
0: 	{
0: 		int bufLength = buf.length;
0: 		int fillLength = paddedLength - bufLength;
0: 		ensureLength (paddedLength);
0: 		System.arraycopy(buf,0,bytes,offset,bufLength);
0: 		offset +=bufLength;
0: 		Arrays.fill(bytes,offset,offset + fillLength,padByte);
0: 		offset += fillLength;
0: 	}
0: 
0: 	/**
0: 	 * Write scalar byte array object includes length, codepoint and value
0: 	 *
0: 	 * @param 	codePoint - code point to write
0: 	 * @param	buf - byte array to be written
0: 	 */
0: 	protected void writeScalarBytes (int codePoint, byte[] buf)
0: 	{
0: 		int bufLength = buf.length;
0: 		ensureLength (bufLength + 4);
0: 		bytes[offset] = (byte) (((bufLength+4) >>> 8) & 0xff);
0: 		bytes[offset + 1] = (byte) ((bufLength+4) & 0xff);
0: 		bytes[offset + 2] = (byte) ((codePoint >>> 8) & 0xff);
0: 		bytes[offset + 3] = (byte) (codePoint & 0xff);
0: 		System.arraycopy(buf,0,bytes,offset + 4,bufLength);
0: 		offset += bufLength + 4;
0: 	}
0: 
0: 	/**
0: 	 * Write scalar byte array object includes length, codepoint and value
0: 	 *
0: 	 * @param 	codePoint - code point to write
0: 	 * @param	buf - byte array to be written
0: 	 * @param	start - starting point
0: 	 * @param 	length - length to write
0: 	 */
0: 	protected void writeScalarBytes (int codePoint, byte[] buf, int start, int length)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (buf == null && length > start)
0: 		    	SanityManager.THROWASSERT("Buf is null");
0: 			if (length - start > buf.length)
0: 				SanityManager.THROWASSERT("Not enough bytes in buffer");
0: 		}
0: 		int numBytes = length - start;
0: 		ensureLength (numBytes + 4);
0: 		bytes[offset] = (byte) (((numBytes+4) >>> 8) & 0xff);
0: 		bytes[offset + 1] = (byte) ((numBytes+4) & 0xff);
0: 		bytes[offset + 2] = (byte) ((codePoint >>> 8) & 0xff);
0: 		bytes[offset + 3] = (byte) (codePoint & 0xff);
0: 		offset += 4;
0: 		System.arraycopy(buf,start,bytes,offset,numBytes);
0: 		offset += numBytes;
0: 	}
0: 	// The following methods write data in the platform format
0: 	// The platform format was indicated during connection time as ASC since
0: 	// JCC doesn't read JVM platform (yet)
0: 
0: 	/**
0: 	 * Write platform short
0: 	 *
0: 	 * @param 	v	value to be written
0: 	 */
0: 	protected void writeShort (int v)
0: 	{
0: 		writeNetworkShort(v);
0: 	}
0: 
0: 	/**
0: 	 * Write boolean as short
0: 	 * @param b boolean value true = 1 false = 0
0: 	 *
0: 	 */
0: 	protected void writeShort(boolean b)
0: 	{
0: 		writeNetworkShort(b ? 1 : 0);
0: 	}
0: 
0: 	/**
0: 	 * Write platform int
0: 	 *
0: 	 * @param 	v	value to be written
0: 	 */
0: 	protected void writeInt (int v)
0: 	{
0: 		writeNetworkInt(v);
0: 	}
0: 
0: 	/**
0: 	 * Write platform long
0: 	 *
0: 	 * @param 	v	value to be written
0: 	 */
0: 	protected void writeLong (long v)
0: 	{
0: 		ensureLength (8);
0: 		bytes[offset] =	(byte) ((v >>> 56) & 0xff);
0: 		bytes[offset + 1] =	(byte) ((v >>> 48) & 0xff);
0: 		bytes[offset + 2] =	(byte) ((v >>> 40) & 0xff);
0: 		bytes[offset + 3] =	(byte) ((v >>> 32) & 0xff);
0: 		bytes[offset + 4] =	(byte) ((v >>> 24) & 0xff);
0: 		bytes[offset + 5] =	(byte) ((v >>> 16) & 0xff);
0: 		bytes[offset + 6] =	(byte) ((v >>>  8) & 0xff);
0: 		bytes[offset + 7] =	(byte) ((v >>>  0) & 0xff);
0: 		offset += 8;
0: 	}
0: 
0: 	/**
0: 	 * Write platform float
0: 	 *
0: 	 * @param 	v	value to be written
0: 	 */
0: 	protected void writeFloat (float v)
0: 	{
0: 		writeInt (Float.floatToIntBits (v));
0: 	}
0: 
0: 	/**
0: 	 * Write platform double
0: 	 *
0: 	 * @param 	v	value to be written
0: 	 */
0: 	protected void writeDouble (double v)
0: 	{
0: 		writeLong (Double.doubleToLongBits (v));
0: 	}
0: 
0: 	/**
0: 	 * Write big decimal to buffer
0: 	 *
0: 	 * @param v value to write
0: 	 * @param precision Precison of decimal or numeric type
0: 	 * @param declared scale
0: 	 * @exception SQLException thrown if number of digits > 31
0: 	 */
0: 	protected void writeBigDecimal (java.math.BigDecimal v, int precision, int scale)
0: 		throws SQLException
0: 	{
0: 		int length = precision / 2 + 1;
0: 		ensureLength (offset + length);
0: 		bigDecimalToPackedDecimalBytes (v,precision, scale);
0: 		offset += length;
0: 	}
0: 
0: 	/**
0: 	 * Write platform boolean
0: 	 *
0: 	 * @param 	v	value to be written
0: 	 */
0: 	protected void writeBoolean (boolean v)
0: 	{
0: 		ensureLength (1);
0: 		bytes[offset++] = (byte) ((v ? 1 : 0) & 0xff);
0: 	}
0: 
0: 	/**
0: 	 * Write length delimited string
0: 	 *
0: 	 * @param s value to be written with integer
0: 	 *
0: 	 * @exception DRDAProtocolException
0: 	 */
0: 	protected void writeLDString(String s) throws DRDAProtocolException
0: 	{
0: 		writeLDString(s,0);
0: 	}
0: 
0: 
0: 	/**
0: 	 * Write length delimited string
0: 	 *
0: 	 * @param s              value to be written with integer
0: 	 * @param index          column index to put in warning
0: 	 * @exception DRDAProtocolException
0: 	 */
0: 	protected void writeLDString(String s, int index) throws DRDAProtocolException
0: 	{
0: 		try {
0: 			byte [] byteval = s.getBytes(DB2jServerImpl.DEFAULT_ENCODING);
0: 			int origLen = byteval.length;
0: 			boolean multiByteTrunc = false;
0: 			int writeLen =
0: 				java.lang.Math.min(FdocaConstants.LONGVARCHAR_MAX_LEN,
0: 								   origLen);
0: 			/*
0: 			Need to make sure we truncate on character boundaries.
0: 			We are assuming
0: 			http://www.sun.com/developers/gadc/technicalpublications/articles/utf8.html
0: 			To find the beginning of a multibyte character:
0: 			1) Does the current byte start with the bit pattern 10xxxxxx?
0: 			2) If yes, move left and go to step #1.
0: 			3) Finished
0: 			We assume that DB2jServerImpl.DEFAULT_ENCODING remains UTF-8
0: 			*/
0: 
0: 			if (SanityManager.DEBUG)
0: 			{
0: 				if (!(DB2jServerImpl.DEFAULT_ENCODING.equals("UTF8")))
0: 					SanityManager.THROWASSERT("Encoding assumed to be UTF8, but is actually" + DB2jServerImpl.DEFAULT_ENCODING);
0: 			}
0: 
0: 			if (writeLen != origLen)
0: 				// first position on the first byte of the multibyte char
0: 				while ((byteval[writeLen -1] & 0xC0) == 0x80)
0: 				{
0: 					multiByteTrunc = true;
0: 					writeLen--;
0: 					// Then subtract one more to get to the end of the
0: 					// previous character
0: 					if (multiByteTrunc == true)
0: 					{
0: 						writeLen = writeLen -1;
0: 					}
0: 				}
0: 
0: 			writeShort(writeLen);
0: 			writeBytes(byteval,writeLen);
0: 		}
0: 		catch (Exception e) {
0: 			//this should never happen
0: 			agent.agentError("Encoding " + DB2jServerImpl.DEFAULT_ENCODING + " not supported");
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Write string with default encoding
0: 	 *
0: 	 * @param s value to be written
0: 	 *
0: 	 * @exception DRDAProtocolException
0: 	 */
0: 	protected void writeString(String s) throws DRDAProtocolException
0: 	{
0: 		try {
0: 			writeBytes(s.getBytes(DB2jServerImpl.DEFAULT_ENCODING));
0: 		} catch (Exception e) {
0: 			//this should never happen
0: 			agent.agentError("Encoding " + DB2jServerImpl.DEFAULT_ENCODING + " not supported");
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Write string with default encoding and specified length
0: 	 *
0: 	 * @param s value to be written
0: 	 * @param length number of bytes to be written
0: 	 *
0: 	 * @exception DRDAProtocolException
0: 	 */
0: 	protected void writeString(String s, int length) throws DRDAProtocolException
0: 	{
0: 		byte[] bs = null;
0: 		try {
0: 			bs = s.getBytes(DB2jServerImpl.DEFAULT_ENCODING);
0: 		} catch (Exception e) {
0: 			//this should never happen
0: 			agent.agentError("Encoding " + DB2jServerImpl.DEFAULT_ENCODING + " not supported");
0: 		}
0: 		int len = bs.length;
0: 		if (len >= length)
0: 			writeBytes(bs, length);
0: 		else
0: 		{
0: 			writeBytes(bs);
0: 			padBytes(DB2jServerImpl.SPACE_CHAR, length-len);
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Write pad bytes using spaceChar
0: 	 *
0: 	 * @param   val	value to be written
0: 	 * @param	length		length to be written
0: 	 */
0: 	protected void padBytes (byte val, int length)
0: 	{
0: 		Arrays.fill(bytes,offset, offset + length,val);
0: 		offset += length;
0: 	}
0: 
0: 	/**
0: 	 * Flush buffer to outputstream
0: 	 *
0: 	 *
0: 	 * @exception IOException
0: 	 */
0: 	protected void flush () throws java.io.IOException
0: 	{
0: 		OutputStream socketOutputStream = agent.getOutputStream();
0: 		try {
0: 			if (isDRDAProtocol)
0: 			{
0: 				finalizeDssLength();
0: 			}
0: 			socketOutputStream.write (bytes, 0, offset);
0: 			socketOutputStream.flush();
0: 		}
0: 		finally {
0: 			if ((dssTrace != null) && dssTrace.isComBufferTraceOn()) {
0: 			  dssTrace.writeComBufferData (bytes,
0: 			                               0,
0: 			                               offset,
0: 			                               DssTrace.TYPE_TRACE_SEND,
0: 			                               "Reply",
0: 			                               "flush",
0: 			                               5);
0: 			}
0: 			reset(dssTrace);
0: 		}
0: 	}
0: 	/**
0: 	 * Flush buffer to specified stream
0: 	 *
0: 	 * @param socketOutputStream
0: 	 *
0: 	 * @exception IOException
0: 	 */
0: 	protected void flush(OutputStream os) throws java.io.IOException
0: 	{
0: 		os.write(bytes, 0, offset);
0: 		os.flush();
0: 	}
0: 
0: 	// private methods
0: 
0: 	/**
0: 	 * Write DSS header
0: 	 * DSS Header format is
0: 	 * 	2 bytes	- length
0: 	 *	1 byte	- 'D0'	- indicates DDM data
0: 	 * 	1 byte	- DSS format
0: 	 *		|---|---------|----------|
0: 	 *		| 0	|	flags |	type     |
0: 	 *		|---|---------|----------|
0: 	 *		| 0 | 1	2	3 | 4 5 6 7	 |
0: 	 *		|---|---------|----------|
0: 	 *		bit 0 - '0'
0: 	 *		bit 1 - '0' - unchained, '1' - chained
0: 	 *		bit 2 - '0'	- do not continue on error, '1' - continue on error
0: 	 *		bit 3 - '0' - next DSS has different correlator, '1' - next DSS has
0: 	 *						same correlator
0: 	 *		type - 1 - Request DSS
0: 	 *			 - 2 - Reply DSS
0: 	 *			 - 3 - Object DSS
0: 	 *			 - 4 - Communications DSS
0: 	 *			 - 5 - Request DSS where no reply is expected
0: 	 */
0: 	private void beginDss (int dssType, int corrID)
0: 	{
0: 		// save correlationID for use in error messages while processing
0: 		// this DSS
0: 		correlationID = corrID;
0: 		// save length position, the length will be written at the end
0: 		dssLengthLocation = offset;
0: 
0: 		ensureLength(6);
0: 		offset += 2;
0: 
0: 		// write gds info
0: 		bytes[offset] = (byte) 0xD0;
0: 		bytes[offset + 1] = (byte) dssType;
0: 
0: 		// write the request correlation id
0: 		bytes[offset + 2] = (byte) ((corrID >>> 8) & 0xff);
0: 		bytes[offset + 3] = (byte) (corrID & 0xff);
0: 		offset += 4;
0: 	}
0: 
0: 	/**
0: 	 * finish the DSS in the buffer by updating the length and chaining bits
0: 	 *
0: 	 * @param nextDssHasSameCorrelator - how to set chaining bits
0: 	 */
0:   	private void finalizePreviousChainedDss (boolean nextDssHasSameCorrelator)
0: 	{
0: 		finalizeDssLength();
0: 		bytes[dssLengthLocation + 3] |= 0x40;
0: 		if (nextDssHasSameCorrelator)
0: 			bytes[dssLengthLocation + 3] |= 0x10;
0: 		
0: 	}
0: 	/**
0:      * Finish a DSS Layer A object.
0: 	 * The length of dss object will be calculated based on the difference between the
0: 	 * start of the dss, saved on the beginDss call, and the current
0: 	 * offset into the buffer which marks the end of the data.	In the event
0: 	 * the length requires the use of continuation Dss headers, one for each 32k
0: 	 * chunk of data, the data will be shifted and the continuation headers
0: 	 * will be inserted with the correct values as needed.
0: 	 */
0: 	private void finalizeDssLength ()
0: 	{
0: 		// calculate the total size of the dss and the number of bytes which would
0: 		// require continuation dss headers.	The total length already includes the
0: 		// the 6 byte dss header located at the beginning of the dss.	It does not
0: 		// include the length of any continuation headers.
0: 		int totalSize = offset - dssLengthLocation;
0: 		int bytesRequiringContDssHeader = totalSize - DssConstants.MAX_DSS_LENGTH;
0: 
0: 		// determine if continuation headers are needed
0: 		if (bytesRequiringContDssHeader > 0)
0: 		{
0: 			// the continuation headers are needed, so calculate how many.
0: 			// after the first 32767 worth of data, a continuation header is
0: 			// needed for every 32765 bytes (32765 bytes of data + 2 bytes of
0: 			// continuation header = 32767 Dss Max Size).
0: 			int contDssHeaderCount = bytesRequiringContDssHeader / 32765;
0: 			if (bytesRequiringContDssHeader % 32765 != 0)
0: 				contDssHeaderCount++;
0: 
0: 			// right now the code will shift to the right.	In the future we may want
0: 			// to try something fancier to help reduce the copying (maybe keep
0: 			// space in the beginning of the buffer??).
0: 			// the offset points to the next available offset in the buffer to place
0: 			// a piece of data, so the last dataByte is at offset -1.
0: 			// various bytes will need to be shifted by different amounts
0: 			// depending on how many dss headers to insert so the amount to shift
0: 			// will be calculated and adjusted as needed.	ensure there is enough room
0: 			// for all the conutinuation headers and adjust the offset to point to the
0: 			// new end of the data.
0: 			int dataByte = offset - 1;
0: 			int shiftSize = contDssHeaderCount * 2;
0: 			ensureLength (shiftSize);
0: 			offset += shiftSize;
0: 
0: 			// mark passOne to help with calculating the length of the final (first or
0: 			// rightmost) continuation header.
0: 			boolean passOne = true;
0: 			do {
0: 				// calculate chunk of data to shift
0: 				int dataToShift = bytesRequiringContDssHeader % 32765;
0: 				if (dataToShift == 0)
0: 					dataToShift = 32765;
0: 				// We start with the right most chunk. If we had to copy two
0: 				// chunks we would shift the first one 4 bytes and then 
0: 				// the second one
0: 				// 2 when we come back on the next loop so they would each have
0: 				// 2 bytes for the continuation header
0: 				int startOfCopyData = dataByte - dataToShift;
0: 				System.arraycopy(bytes,startOfCopyData, bytes, 
0: 								 startOfCopyData + shiftSize, dataToShift);
0: 				dataByte -= dataToShift;
0: 
0: 
0: 				// calculate the value the value of the 2 byte continuation dss
0: 				// header which includes the length of itself.  On the first pass,
0: 				// if the length is 32767
0: 				// we do not want to set the continuation dss header flag.
0: 				int twoByteContDssHeader = dataToShift + 2;
0: 				if (passOne)
0: 					passOne = false;
0: 				else
0: 				{
0: 					if (twoByteContDssHeader == DssConstants.MAX_DSS_LENGTH)
0: 				    	twoByteContDssHeader = DssConstants.CONTINUATION_BIT;
0: 				}
0: 
0: 				// insert the header's length bytes
0: 				bytes[dataByte + shiftSize - 1] = (byte)
0: 					((twoByteContDssHeader >>> 8) & 0xff);
0: 				bytes[dataByte + shiftSize] = (byte)
0: 					(twoByteContDssHeader & 0xff);
0: 
0: 				// adjust the bytesRequiringContDssHeader and the amount to shift for
0: 				// data in upstream headers.
0: 				bytesRequiringContDssHeader -= dataToShift;
0: 				shiftSize -= 2;
0: 
0: 				// shift and insert another header for more data.
0: 			}
0: 			while (bytesRequiringContDssHeader > 0);
0: 
0: 			// set the continuation dss header flag on for the first header
0: 			totalSize = DssConstants.CONTINUATION_BIT;
0: 
0: 		}
0: 
0: 		// insert the length bytes in the 6 byte dss header.
0: 		bytes[dssLengthLocation] = (byte) ((totalSize >>> 8) & 0xff);
0: 		bytes[dssLengthLocation + 1] = (byte) (totalSize & 0xff);
0: 	}
0: 
0: 	protected void writeExtendedLength(long size)
0: 	{
0: 		int numbytes = calculateExtendedLengthByteCount(size);
0: 		if (size > 0)
0: 			writeInt(0x8000 | numbytes);
0: 		else
0: 			writeInt(numbytes);
0: 	}
0: 
0: 
0: 	/**
0: 	 * Calculate extended length byte count which follows the DSS header
0: 	 * for extended DDM.
0: 	 *
0: 	 * @param ddmSize - size of DDM command
0: 	 * @return minimum number of extended length bytes needed. 0 indicates no
0: 	 * 	extended length needed.
0: 	 */
0: 	private int calculateExtendedLengthByteCount (long ddmSize)
0: 	{
0: 		if (ddmSize <= 0x7fff)
0: 			return 0;
0: 		// JCC does not support 2 at this time, so we always send
0: 		// at least 4
0: 		//		else if (ddmSize <= 0xffff)
0: 		//	return 2;
0: 		else if (ddmSize <= 0xffffffffL)
0: 			return 4;
0: 		else if (ddmSize <= 0xffffffffffffL)
0: 			return 6;
0: 		else if (ddmSize <= 0x7fffffffffffffffL)
0: 			return 8;
0: 		else
0: 			// shouldn't happen
0: 			// XXX - add sanity debug stuff here
0: 			return 0;
0: 	}
0: 
0: 	/**
0: 	 * Ensure that there is space in the buffer
0: 	 *
0: 	 * @param length space required
0: 	 */
0: 	private void ensureLength (int length)
0: 	{
0: 		length += offset;
0: 		if (length > bytes.length) {
0: 			if (SanityManager.DEBUG)
0: 			{
0: 				agent.trace("DANGER - Expensive expansion of  buffer");
0: 			}
0: 			byte newBytes[] = new byte[Math.max (bytes.length << 1, length)];
0: 			System.arraycopy (bytes, 0, newBytes, 0, offset);
0: 			bytes = newBytes;
0: 		}
0: 	}
0: 
0: 
0: 	/**
0: 	 * Write a Java <code>java.math.BigDecimal</code> to packed decimal bytes.
0: 	 *
0: 	 * @param b BigDecimal to write
0: 	 * @param precision Precision of decimal or numeric type
0: 	 * @return length written.
0: 	 *
0: 	 * @exception SQLException Thrown if # digits > 31
0: 	 */
0: 	private int bigDecimalToPackedDecimalBytes (java.math.BigDecimal b,
0: 												int precision, int scale)
0: 	throws SQLException
0: 	{
0: 		int declaredPrecision = precision;
0: 		int declaredScale = scale;
0: 
0: 		// packed decimal may only be up to 31 digits.
0: 		if (declaredPrecision > 31) // this is a bugcheck only !!!
0: 		{
0: 			clearDdm ();
0: 			throw new java.sql.SQLException ("Packed decimal may only be up to 31 digits!");
0: 		}
0: 
0: 		// get absolute unscaled value of the BigDecimal as a String.
0: 		String unscaledStr = b.unscaledValue().abs().toString();
0: 
0: 		// get precision of the BigDecimal.
0:   	    int bigPrecision = unscaledStr.length();
0: 
0: 		if (bigPrecision > 31)
0: 		{
0: 			clearDdm ();
0:   		    throw new SQLException ("The numeric literal \"" +
0:                              b.toString() +
0:                              "\" is not valid because its value is out of range.",
0:                              "42820",
0:                              -405);
0: 		}
0:     	int bigScale = b.scale();
0:   	    int bigWholeIntegerLength = bigPrecision - bigScale;
0: 	    if ( (bigWholeIntegerLength > 0) && (!unscaledStr.equals ("0")) ) {
0:             // if whole integer part exists, check if overflow.
0:             int declaredWholeIntegerLength = declaredPrecision - declaredScale;
0:             if (bigWholeIntegerLength > declaredWholeIntegerLength)
0: 			{
0: 				clearDdm ();
0:                 throw new SQLException ("Overflow occurred during numeric data type conversion of \"" +
0:                                        b.toString() +
0:                                        "\".",
0:                                        "22003",
0:                                        -413);
0: 			}
0:         }
0: 
0:         // convert the unscaled value to a packed decimal bytes.
0: 
0:         // get unicode '0' value.
0:         int zeroBase = '0';
0: 
0:         // start index in target packed decimal.
0:         int packedIndex = declaredPrecision-1;
0: 
0:         // start index in source big decimal.
0:         int bigIndex;
0: 
0:         if (bigScale >= declaredScale) {
0:           // If target scale is less than source scale,
0:           // discard excessive fraction.
0: 
0:           // set start index in source big decimal to ignore excessive fraction.
0:           bigIndex = bigPrecision-1-(bigScale-declaredScale);
0: 
0:           if (bigIndex < 0) {
0:             // all digits are discarded, so only process the sign nybble.
0:             bytes[offset+(packedIndex+1)/2] =
0:               (byte) ( (b.signum()>=0)?12:13 ); // sign nybble
0:           }
0:           else {
0:             // process the last nybble together with the sign nybble.
0:             bytes[offset+(packedIndex+1)/2] =
0:               (byte) ( ( (unscaledStr.charAt(bigIndex)-zeroBase) << 4 ) + // last nybble
0:                      ( (b.signum()>=0)?12:13 ) ); // sign nybble
0:           }
0:           packedIndex-=2;
0:           bigIndex-=2;
0:         }
0:         else {
0:           // If target scale is greater than source scale,
0:           // pad the fraction with zero.
0: 
0:           // set start index in source big decimal to pad fraction with zero.
0:           bigIndex = declaredScale-bigScale-1;
0: 
0:           // process the sign nybble.
0:           bytes[offset+(packedIndex+1)/2] =
0:             (byte) ( (b.signum()>=0)?12:13 ); // sign nybble
0: 
0:           for (packedIndex-=2, bigIndex-=2; bigIndex>=0; packedIndex-=2, bigIndex-=2)
0:             bytes[offset+(packedIndex+1)/2] = (byte) 0;
0: 
0:           if (bigIndex == -1) {
0:             bytes[offset+(packedIndex+1)/2] =
0:               (byte) ( (unscaledStr.charAt(bigPrecision-1)-zeroBase) << 4 ); // high nybble
0: 
0:             packedIndex-=2;
0:             bigIndex = bigPrecision-3;
0:           }
0:           else {
0:             bigIndex = bigPrecision-2;
0:           }
0:         }
0: 
0:         // process the rest.
0:         for (; bigIndex>=0; packedIndex-=2, bigIndex-=2) {
0:           bytes[offset+(packedIndex+1)/2] =
0:             (byte) ( ( (unscaledStr.charAt(bigIndex)-zeroBase) << 4 ) + // high nybble
0:                    ( unscaledStr.charAt(bigIndex+1)-zeroBase ) ); // low nybble
0:         }
0: 
0:         // process the first nybble when there is one left.
0:         if (bigIndex == -1) {
0:           bytes[offset+(packedIndex+1)/2] =
0:             (byte) (unscaledStr.charAt(0) - zeroBase);
0: 
0:           packedIndex-=2;
0:         }
0: 
0:         // pad zero in front of the big decimal if necessary.
0:         for (; packedIndex>=-1; packedIndex-=2)
0:           bytes[offset+(packedIndex+1)/2] = (byte) 0;
0: 
0:         return declaredPrecision/2 + 1;
0: 	}
0: 
0: 
0: 	/***
0: 	 * Prepend zeros to numeric string
0: 	 *
0: 	 * @param s string
0: 	 * @param precision - length of padded string
0:  	 *
0: 	 * @return zero padded string
0: 	 */
0: 	public static String zeroPadString(String s, int precision)
0: 	{
0: 
0: 		if (s == null)
0: 			return s;
0: 
0: 		int slen = s.length();
0: 		if (precision == slen)
0: 			return s;
0: 		else if (precision > slen)
0: 		{
0: 			char[] ca  = new char[precision - slen];
0: 			Arrays.fill(ca,0,precision - slen,'0');
0: 			return new String(ca) + s;
0: 		}
0: 		else
0: 		{
0: 			// Shouldn't happen but just in case 
0: 			// truncate
0: 			return s.substring(0,precision);
0: 		}
0: 
0: 	}
0: 
0: 
0: 
0:   private void sendBytes (java.io.OutputStream socketOutputStream) throws java.io.IOException
0:   {
0:     try {
0:       socketOutputStream.write (bytes, 0, offset);
0:       socketOutputStream.flush();
0:     }
0:     finally {
0: 		if ((dssTrace != null) && dssTrace.isComBufferTraceOn()) {
0: 			dssTrace.writeComBufferData (bytes,
0: 			                               0,
0: 			                               offset,
0: 			                               DssTrace.TYPE_TRACE_SEND,
0: 			                               "Reply",
0: 			                               "flush",
0: 			                               5);
0:       }
0:       clearBuffer();
0:     }
0:   }
0: 
0: 
0: private void buildStreamDssObject (boolean chainedToNextStructure,
0: 								   boolean nextHasSameCorrelator,
0: 								   int corrID)
0:   {
0: 	int dssType =   DssConstants.GDSFMT_OBJDSS;
0:     if (offset != 0) {
0:         finalizePreviousChainedDss (true);
0: 	}
0: 
0:     ensureLength (6);
0: 
0:     // save the length position and skip
0:     // note: the length position is saved so it can be updated
0:     // with a different value later.
0:     dssLengthLocation = offset;
0:     // always turn on chaining flags... this is helpful for lobs...
0:     // these bytes will get rest if dss lengths are finalized.
0:     bytes[offset] = (byte) 0xFF;
0:     bytes[offset + 1] = (byte) 0xFF;
0: 
0:     // insert the manditory 0xD0 and the dssType
0:     bytes[offset + 2] = (byte) 0xD0;
0:     if (chainedToNextStructure) {
0:       dssType |= DssConstants.GDSCHAIN;
0:       if (nextHasSameCorrelator)
0:         dssType |= DssConstants.GDSCHAIN_SAME_ID;
0:     }
0:     bytes[offset + 3] = (byte) (  dssType & 0xff);
0: 
0:     // write the request correlation id
0:     // use method that writes a short !!!
0:     bytes[offset + 4] = (byte) ((corrID >>> 8) & 0xff);
0:     bytes[offset + 5] = (byte) (corrID & 0xff);
0: 	offset += 6;
0: 	}
0: 
0: 
0: 	private static int min (int i, int j)
0: 	{
0: 		return (i < j) ? i : j;
0: 	}
0: 
0: 	protected String toDebugString(String indent)
0: 	{
0: 		String s = indent + "***** DDMWriter toDebugString ******\n";
0: 		int byteslen = 0;
0: 		if ( bytes != null)
0: 			byteslen = bytes.length;
0: 		s += indent + "byte array length  = " + bytes.length + "\n";
0: 		return s;
0: 	}
0: 
0: }
0: 
0: 
0: 
0: 
============================================================================