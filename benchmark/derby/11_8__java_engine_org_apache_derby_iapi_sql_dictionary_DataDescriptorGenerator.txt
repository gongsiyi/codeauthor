1:eac0369: /*
1:7ecc1f2: 
1:7ecc1f2:    Derby - Class org.apache.derby.iapi.sql.dictionary.DataDescriptorGenerator
1:c69c8b0: 
1:2e658c2:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2e658c2:    contributor license agreements.  See the NOTICE file distributed with
1:2e658c2:    this work for additional information regarding copyright ownership.
1:2e658c2:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2e658c2:    (the "License"); you may not use this file except in compliance with
1:2e658c2:    the License.  You may obtain a copy of the License at
1:c69c8b0: 
1:7ecc1f2:       http://www.apache.org/licenses/LICENSE-2.0
1:51572c8: 
1:7ecc1f2:    Unless required by applicable law or agreed to in writing, software
1:7ecc1f2:    distributed under the License is distributed on an "AS IS" BASIS,
1:7ecc1f2:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7ecc1f2:    See the License for the specific language governing permissions and
1:7ecc1f2:    limitations under the License.
1:7ecc1f2: 
1:eac0369:  */
1:7ecc1f2: 
1:eac0369: package org.apache.derby.iapi.sql.dictionary;
1:c69c8b0: 
1:56c1dc2: import java.security.AccessController;
1:56c1dc2: import java.security.PrivilegedAction;
1:c69c8b0: import java.sql.Timestamp;
1:c69c8b0: import org.apache.derby.catalog.ReferencedColumns;
1:c69c8b0: import org.apache.derby.catalog.UUID;
1:c69c8b0: import org.apache.derby.catalog.types.ReferencedColumnsDescriptorImpl;
1:801cf0d: import org.apache.derby.iapi.error.StandardException;
1:c69c8b0: import org.apache.derby.iapi.services.io.FormatableBitSet;
1:56c1dc2: import org.apache.derby.iapi.services.monitor.ModuleFactory;
1:c69c8b0: import org.apache.derby.iapi.services.monitor.Monitor;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:801cf0d: import org.apache.derby.iapi.services.uuid.UUIDFactory;
1:bb40bcb: import org.apache.derby.iapi.types.DataTypeDescriptor;
1:7ecc1f2: 
1:eac0369: /**
1:eac0369:  * This is an implementation of the DataDescriptorGenerator interface
1:eac0369:  * that lives in the DataDictionary protocol.  See that interface for
1:eac0369:  * a description of what this class is supposed to do.
1:eac0369:  *
1:eac0369:  * @version 0.1
1:eac0369:  */
7:eac0369: 
1:eac0369: public class DataDescriptorGenerator 
1:eac0369: {
1:eac0369: 	private 	UUIDFactory uuidf;
1:eac0369: 
1:eac0369:     protected	final DataDictionary	dataDictionary; // the data dictionary that this generator operates on
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  *	Make a generator. Specify the data dictionary that it operates on.
1:eac0369: 	  *
1:eac0369: 	  *	@param	dataDictionary	the data dictionary that this generator makes objects for
1:eac0369: 	  */
1:eac0369: 	public	DataDescriptorGenerator( DataDictionary dataDictionary )
1:eac0369: 	{
1:eac0369: 		this.dataDictionary = dataDictionary;
1:d9878ca: 	}
1:aa609d5: 
1:eac0369: 	/**
1:eac0369: 	 * Create a descriptor for the named schema with a null UUID. 
1:eac0369: 	 *
1:eac0369: 	 * @param schemaName	The name of the schema we're interested in.
1:eac0369: 	 *			If the name is NULL, get the descriptor for the
1:eac0369: 	 *			current schema.
1:eac0369: 	 * @param aid	The authorization ID associated with the schema.
1:eac0369: 	 *		The owner of the schema.
1:eac0369: 	 *
1:eac0369: 	 * @param oid	The object ID 
1:eac0369: 	 *
1:eac0369: 	 * @return	The descriptor for the schema.
1:eac0369: 	 * @exception StandardException		Thrown on failure
1:eac0369: 	 */
1:eac0369: 	public SchemaDescriptor	newSchemaDescriptor(String schemaName, 
1:eac0369: 		String aid, UUID oid)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		return new SchemaDescriptor(
1:eac0369:             dataDictionary, schemaName, aid, oid, 
1:eac0369:             dataDictionary.isSystemSchemaName(schemaName));
1:eac0369: 	}
1:d9878ca: 
1:eac0369: 	/**
1:eac0369: 	 * Create a descriptor for the named table within the given schema.
1:eac0369: 	 * If the schema parameter is NULL, it creates a schema descriptor
1:eac0369: 	 * using the current default schema.
1:eac0369: 	 *
1:eac0369: 	 * @param tableName	The name of the table to get the descriptor for
1:eac0369: 	 * @param schema	The descriptor for the schema the table lives in.
1:eac0369: 	 *			If null, use the current (default) schema.
1:eac0369: 	 * @param tableType	The type of the table: base table or view.
1:eac0369: 	 * @param lockGranularity	The lock granularity.
1:eac0369: 	 *
1:eac0369: 	 * @return	The descriptor for the table.
1:eac0369: 	 */
1:eac0369: 	public TableDescriptor	newTableDescriptor
1:eac0369: 	(
1:eac0369: 		String 				tableName,
1:eac0369: 		SchemaDescriptor	schema,
1:eac0369: 		int					tableType,
1:eac0369: 		char				lockGranularity
2:eac0369:     )
1:eac0369: 	{
1:eac0369: 		return new TableDescriptor
1:eac0369: 			(dataDictionary, tableName, schema, tableType, lockGranularity);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Create a descriptor for the temporary table within the given schema.
1:eac0369: 	 *
1:eac0369: 	 * @param tableName	The name of the temporary table to get the descriptor for
1:eac0369: 	 * @param schema	The descriptor for the schema the table lives in.
1:eac0369: 	 * @param tableType	The type of the table: temporary table
1:eac0369: 	 * @param onCommitDeleteRows	If true, on commit delete rows else on commit preserve rows of temporary table.
1:eac0369: 	 * @param onRollbackDeleteRows	If true, on rollback, delete rows from temp tables which were logically modified. true is the only supported value
1:eac0369: 	 *
1:eac0369: 	 * @return	The descriptor for the table.
1:eac0369: 	 */
1:eac0369: 	public TableDescriptor	newTableDescriptor
1:eac0369: 	(
1:eac0369: 		String 				tableName,
1:eac0369: 		SchemaDescriptor	schema,
1:eac0369: 		int					tableType,
1:eac0369: 		boolean				onCommitDeleteRows,
1:eac0369: 		boolean				onRollbackDeleteRows
1:eac0369:     )
1:eac0369: 	{
1:eac0369: 		return new TableDescriptor
1:eac0369: 			(dataDictionary, tableName, schema, tableType, onCommitDeleteRows, onRollbackDeleteRows);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Create a viewDescriptor for the view with the given UUID.
1:eac0369: 	 *
1:eac0369: 	 * @param viewID	the UUID for the view.
1:eac0369: 	 * @param viewName	the name of the view
1:eac0369: 	 * @param viewText	the text of the view's query.
1:eac0369: 	 * @param checkOption	int for check option type 
1:eac0369: 	 * @param compSchemaId	the UUID of the schema this was compiled in
1:eac0369: 	 *
1:eac0369: 	 * @return	A descriptor for the view
1:eac0369: 	 */
1:eac0369: 	public ViewDescriptor newViewDescriptor(UUID viewID,
1:eac0369: 				String viewName, String viewText, int checkOption,
1:eac0369: 				UUID compSchemaId)
1:eac0369: 	{
1:eac0369: 		return new ViewDescriptor(dataDictionary, viewID, viewName, 
1:eac0369: 				viewText, checkOption, compSchemaId);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see DataDescriptorGenerator#newUniqueConstraintDescriptor
1:eac0369: 	 */
1:eac0369: 	public ReferencedKeyConstraintDescriptor	newUniqueConstraintDescriptor(
1:eac0369: 						TableDescriptor table,
1:eac0369: 						String constraintName,
1:eac0369: 						boolean deferrable,
1:eac0369: 						boolean initiallyDeferred,
1:eac0369: 						int[] referencedColumns,
1:eac0369: 						UUID		constraintId,
1:eac0369: 						UUID		indexId,
1:eac0369: 						SchemaDescriptor schemaDesc,
1:eac0369: 						boolean isEnabled,
1:eac0369: 						int referenceCount
1:eac0369: 						)
1:eac0369: 	{
1:eac0369: 		return new ReferencedKeyConstraintDescriptor(DataDictionary.UNIQUE_CONSTRAINT,
1:eac0369: 			dataDictionary, table, constraintName,
1:eac0369: 				deferrable, initiallyDeferred, 
1:eac0369: 				referencedColumns, constraintId, 
1:eac0369: 				indexId, schemaDesc, isEnabled, referenceCount);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see DataDescriptorGenerator#newPrimaryKeyConstraintDescriptor
1:eac0369: 	 */
1:eac0369: 	public ReferencedKeyConstraintDescriptor	newPrimaryKeyConstraintDescriptor(
1:eac0369: 						TableDescriptor table,
1:eac0369: 						String constraintName,
1:eac0369: 						boolean deferrable,
1:eac0369: 						boolean initiallyDeferred,
1:eac0369: 						int[] referencedColumns,
1:eac0369: 						UUID		constraintId,
1:eac0369: 						UUID indexId,
1:eac0369: 						SchemaDescriptor schemaDesc,
1:eac0369: 						boolean isEnabled,
1:eac0369: 						int referenceCount
1:eac0369: 						)
1:eac0369: 	{
1:eac0369: 		return new ReferencedKeyConstraintDescriptor(DataDictionary.PRIMARYKEY_CONSTRAINT,
1:eac0369: 			dataDictionary, table, constraintName,
1:eac0369: 				deferrable, initiallyDeferred, 
1:eac0369: 				referencedColumns, constraintId, 
1:eac0369: 				indexId, schemaDesc, isEnabled, referenceCount);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see DataDescriptorGenerator#newForeignKeyConstraintDescriptor
1:eac0369: 	 */
1:eac0369: 	public ForeignKeyConstraintDescriptor	newForeignKeyConstraintDescriptor(
1:eac0369: 						TableDescriptor table,
1:eac0369: 						String constraintName,
1:eac0369: 						boolean deferrable,
1:eac0369: 						boolean initiallyDeferred,
1:eac0369: 						int[] fkColumns,
1:eac0369: 						UUID	constraintId,
1:eac0369: 						UUID indexId,
1:eac0369: 						SchemaDescriptor schemaDesc,
1:eac0369: 						ReferencedKeyConstraintDescriptor	referencedConstraintDescriptor,
1:eac0369: 						boolean isEnabled,
1:eac0369: 						int raDeleteRule,
1:eac0369: 						int raUpdateRule
1:eac0369: 						)
1:eac0369: 	{
1:eac0369: 		return new ForeignKeyConstraintDescriptor(dataDictionary, table, constraintName,
1:eac0369: 				deferrable, initiallyDeferred, 
1:eac0369: 				fkColumns, constraintId, 
1:eac0369: 				indexId, schemaDesc, 
1:eac0369: 				referencedConstraintDescriptor, isEnabled, raDeleteRule, raUpdateRule);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see DataDescriptorGenerator#newForeignKeyConstraintDescriptor
1:eac0369: 	 */
1:eac0369: 	public ForeignKeyConstraintDescriptor	newForeignKeyConstraintDescriptor(
1:eac0369: 						TableDescriptor table,
1:eac0369: 						String constraintName,
1:eac0369: 						boolean deferrable,
1:eac0369: 						boolean initiallyDeferred,
1:eac0369: 						int[] fkColumns,
1:eac0369: 						UUID	constraintId,
1:eac0369: 						UUID indexId,
1:eac0369: 						SchemaDescriptor schemaDesc,
1:eac0369: 						UUID	referencedConstraintId,
1:eac0369: 						boolean isEnabled,
1:eac0369: 						int raDeleteRule,
1:eac0369: 						int raUpdateRule
1:eac0369: 						)
1:eac0369: 	{
1:eac0369: 		return new ForeignKeyConstraintDescriptor(dataDictionary, table, constraintName,
1:eac0369: 				deferrable, initiallyDeferred, 
1:eac0369: 				fkColumns, constraintId, 
1:eac0369: 				indexId, schemaDesc, 
1:eac0369: 				referencedConstraintId, isEnabled, raDeleteRule, raUpdateRule);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see DataDescriptorGenerator#newCheckConstraintDescriptor
1:eac0369: 	 */
1:eac0369: 	public CheckConstraintDescriptor	newCheckConstraintDescriptor(
1:eac0369: 						TableDescriptor table,
1:eac0369: 						String constraintName,
1:eac0369: 						boolean deferrable,
1:eac0369: 						boolean initiallyDeferred,
1:eac0369: 						UUID		constraintId,
1:eac0369: 						String constraintText,
1:eac0369: 						ReferencedColumns referencedColumns,
1:eac0369: 						SchemaDescriptor schemaDesc,
1:eac0369: 						boolean isEnabled
1:eac0369: 						)
1:eac0369: 	{
1:eac0369: 		return new CheckConstraintDescriptor(dataDictionary, table, constraintName,
1:eac0369: 				deferrable, initiallyDeferred, 
1:eac0369: 				constraintId, 
1:eac0369: 				constraintText, referencedColumns, schemaDesc, isEnabled);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public CheckConstraintDescriptor	newCheckConstraintDescriptor(
1:eac0369: 						TableDescriptor table,
1:eac0369: 						String constraintName,
1:eac0369: 						boolean deferrable,
1:eac0369: 						boolean initiallyDeferred,
1:eac0369: 						UUID		constraintId,
1:eac0369: 						String constraintText,
1:eac0369: 						int[] refCols,
1:eac0369: 						SchemaDescriptor schemaDesc,
1:eac0369: 						boolean isEnabled
1:eac0369: 						)
1:eac0369: 	{
1:eac0369: 		ReferencedColumns referencedColumns = new ReferencedColumnsDescriptorImpl(refCols);
1:eac0369: 		return new CheckConstraintDescriptor(dataDictionary, table, constraintName,
1:eac0369: 				deferrable, initiallyDeferred, 
1:eac0369: 				constraintId, 
1:eac0369: 				constraintText, referencedColumns, schemaDesc, isEnabled);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Create a conglomerate descriptor for the given conglomerate id.
1:eac0369: 	 *
1:6b50965: 	 * @param conglomerateId	The identifier for the conglomerate
1:eac0369: 	 *				we're interested in
1:eac0369: 	 * @param name			The name of the conglomerate, if any
1:eac0369: 	 * @param indexable		TRUE means the conglomerate is indexable,
1:eac0369: 	 *				FALSE means it isn't
1:eac0369: 	 * @param indexRowGenerator	The IndexRowGenerator for the conglomerate,
1:eac0369: 	 *							null if it's a heap
1:eac0369: 	 * @param isConstraint	TRUE means the conglomerate is an index backing 
1:eac0369: 	 *						up a constraint, FALSE means it isn't
1:eac0369: 	 *
1:eac0369: 	 * @param uuid	UUID  for this conglomerate
1:eac0369: 	 * @param tableID	UUID for the table that this conglomerate belongs to
1:eac0369: 	 * @param schemaID	UUID for the schema that conglomerate belongs to
1:eac0369: 	 *
1:eac0369: 	 * @return	A ConglomerateDescriptor describing the 
1:eac0369: 	 *		conglomerate. 
1:eac0369: 	 */
1:eac0369: 	public ConglomerateDescriptor	newConglomerateDescriptor(
1:eac0369: 						long conglomerateId,
1:eac0369: 						String name,
1:eac0369: 						boolean indexable,
1:eac0369: 						IndexRowGenerator indexRowGenerator,
1:eac0369: 						boolean isConstraint,
1:eac0369: 						UUID uuid,
1:eac0369: 						UUID tableID,
1:eac0369: 						UUID schemaID
1:eac0369: 						)
1:eac0369: 	{
1:801cf0d:         return new ConglomerateDescriptor(dataDictionary,
1:801cf0d:                                           conglomerateId,
1:801cf0d:                                           name,
1:801cf0d:                                           indexable,
1:801cf0d:                                           indexRowGenerator,
1:801cf0d:                                           isConstraint,
1:801cf0d:                                           uuid,
1:801cf0d:                                           tableID,
1:801cf0d:                                           schemaID);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Create a new trigger descriptor.
1:eac0369: 	 *
1:eac0369: 	 * @param sd	the schema descriptor for this trigger
1:6b50965: 	 * @param uuid	the trigger id
1:eac0369: 	 * @param name	the trigger name
1:eac0369: 	 * @param eventMask	TriggerDescriptor.TRIGGER_EVENT_XXXX
1:eac0369: 	 * @param isBefore	is this a before (as opposed to after) trigger 
1:eac0369: 	 * @param isRow		is this a row trigger or statement trigger
1:eac0369: 	 * @param isEnabled	is this trigger enabled or disabled
1:eac0369: 	 * @param td		the table upon which this trigger is defined
1:eac0369: 	 * @param whenSPSId	the sps id for the when clause (may be null)
1:eac0369: 	 * @param actionSPSId	the spsid for the trigger action (may be null)
1:eac0369: 	 * @param creationTimestamp	when was this trigger created?
1:eac0369: 	 * @param referencedCols	what columns does this trigger reference (may be null)
1:a6f9586: 	 * @param referencedColsInTriggerAction	what columns does the trigger 
1:a6f9586: 	 *						action reference through old/new transition variables
1:a6f9586: 	 *						(may be null)
1:eac0369: 	 * @param triggerDefinition The original user text of the trigger action
1:eac0369: 	 * @param referencingOld whether or not OLD appears in REFERENCING clause
1:eac0369: 	 * @param referencingNew whether or not NEW appears in REFERENCING clause
1:eac0369: 	 * @param oldReferencingName old referencing table name, if any, that appears in REFERCING clause
1:eac0369: 	 * @param newReferencingName new referencing table name, if any, that appears in REFERCING clause
1:d9878ca:      * @param whenClauseText the SQL text of the WHEN clause (may be null)
1:d9878ca:      * @return a trigger descriptor
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException on error
1:eac0369: 	 */
1:eac0369: 	public TriggerDescriptor newTriggerDescriptor
1:eac0369: 	(
1:eac0369: 		SchemaDescriptor	sd,
1:eac0369: 		UUID				uuid,
1:eac0369: 		String				name,
1:eac0369: 		int					eventMask,
1:eac0369: 		boolean				isBefore,
1:eac0369: 		boolean 			isRow,
1:eac0369: 		boolean 			isEnabled,
1:eac0369: 		TableDescriptor		td,
1:eac0369: 		UUID				whenSPSId,
1:eac0369: 		UUID				actionSPSId,
1:eac0369: 		Timestamp			creationTimestamp,
1:eac0369: 		int[]				referencedCols,
1:a6f9586: 		int[]				referencedColsInTriggerAction,
1:eac0369: 		String				triggerDefinition,
1:eac0369: 		boolean				referencingOld,
1:eac0369: 		boolean				referencingNew,
1:eac0369: 		String				oldReferencingName,
1:d9878ca:         String              newReferencingName,
1:d9878ca:         String              whenClauseText
1:eac0369: 	) throws StandardException
1:eac0369: 	{
1:211adc3:         return new TriggerDescriptor(
1:d9878ca: 					dataDictionary,
1:d9878ca: 					sd,
1:d9878ca: 					uuid,
1:d9878ca: 					name,
1:d9878ca: 					eventMask,
1:d9878ca: 					isBefore,
1:d9878ca: 					isRow,
1:d9878ca: 					isEnabled,
1:d9878ca: 					td,
1:d9878ca: 					whenSPSId,
1:d9878ca: 					actionSPSId,
1:d9878ca: 					creationTimestamp,
1:d9878ca: 					referencedCols,
1:d9878ca: 					referencedColsInTriggerAction,
1:d9878ca: 					triggerDefinition,
1:d9878ca: 					referencingOld,
1:d9878ca: 					referencingNew,
1:d9878ca: 					oldReferencingName,
1:d9878ca:                     newReferencingName,
1:d9878ca:                     whenClauseText
1:eac0369: 					);
1:eac0369: 	}
1:eac0369: 		
1:eac0369: 	/*
1:eac0369: 	  get a UUIDFactory. This uses the Monitor to get one the
1:eac0369: 	  first time and holds onto it for later.
1:eac0369: 	  */
1:eac0369: 	protected UUIDFactory getUUIDFactory()
1:eac0369: 	{
1:c69c8b0: 		if (uuidf == null)
1:56c1dc2: 			uuidf = getMonitor().getUUIDFactory();
1:eac0369: 		return uuidf;
1:eac0369: 	}
1:eac0369: 
1:78c2db1:     /**
1:78c2db1:      * Create  a new {@code FileInfoDescriptor} using the supplied arguments.
1:78c2db1:      * 
1:78c2db1:      * id unique id to be used for the new file descriptor
1:78c2db1:      * sd schema of the new file to be stored in the database
1:78c2db1:      * SQLName the SQL name of the new schema object representing the file
1:78c2db1:      * generationID version numberof the file the descriptor describes
1:78c2db1:      * 
1:78c2db1:      * @return the newly created file info descriptor
1:78c2db1:      */
1:78c2db1:     public FileInfoDescriptor newFileInfoDescriptor(
1:78c2db1:                                 UUID             id,
1:78c2db1:                                 SchemaDescriptor sd,
1:78c2db1:                                 String           sqlName,
1:78c2db1:                                 long             generationId
1:78c2db1:                                 )
1:78c2db1:     {
1:78c2db1:         if (SanityManager.DEBUG) {
1:78c2db1:             SanityManager.ASSERT(id != null);
1:78c2db1:         }
1:78c2db1: 
1:78c2db1:         return new FileInfoDescriptor(
1:78c2db1:                 dataDictionary, id, sd, sqlName, generationId);
1:78c2db1:     }
1:eac0369: 
1:aa609d5: 	public UserDescriptor newUserDescriptor
1:aa609d5:         (
1:aa609d5:          String userName,
1:aa609d5:          String hashingScheme,
1:aa609d5:          char[] password,
1:aa609d5:          Timestamp lastModified
1:aa609d5:          )
1:aa609d5: 	{
1:aa609d5: 		return new UserDescriptor( dataDictionary, userName, hashingScheme, password, lastModified );
1:aa609d5: 	}
1:eac0369: 	 	
1:b7730e4:     public TablePermsDescriptor newTablePermsDescriptor( TableDescriptor td,
1:b7730e4:                                                          String selectPerm,
1:b7730e4:                                                          String deletePerm,
1:b7730e4:                                                          String insertPerm,
1:b7730e4:                                                          String updatePerm,
1:b7730e4:                                                          String referencesPerm,
1:b7730e4:                                                          String triggerPerm,
2:b7730e4:                                                          String grantor)
1:2d2e717: 	throws StandardException
1:eac0369:     {
1:b7730e4:         if( "N".equals( selectPerm) && "N".equals( deletePerm) && "N".equals( insertPerm)
1:b7730e4:             && "N".equals( updatePerm) && "N".equals( referencesPerm) && "N".equals( triggerPerm))
1:b7730e4:             return null;
1:eac0369:         
1:b7730e4:         return new TablePermsDescriptor( dataDictionary,
1:b7730e4:                                          (String) null,
2:b7730e4:                                          grantor,
1:b7730e4:                                          td.getUUID(),
1:b7730e4:                                          selectPerm,
1:b7730e4:                                          deletePerm,
1:b7730e4:                                          insertPerm,
1:b7730e4:                                          updatePerm,
1:b7730e4:                                          referencesPerm,
1:b7730e4:                                          triggerPerm);
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:b7730e4:      * Manufacture a new ColPermsDescriptor.
1:b7730e4:      *
1:b7730e4:      * @param td The descriptor of the table.
1:b7730e4:      * @param type The action type:
1:b7730e4:      *<ol>
1:b7730e4:      *<li>"s" - select without grant
1:b7730e4:      *<li>"S" - select with grant
1:b7730e4:      *<li>"u" - update without grant
1:b7730e4:      *<li>"U" - update with grant
1:b7730e4:      *<li>"r" - references without grant
1:b7730e4:      *<li>"R" - references with grant
1:b7730e4:      *</ol>
1:b7730e4:      * @param columns the set of columns
1:eac0369:      */
1:b7730e4:     public ColPermsDescriptor newColPermsDescriptor( TableDescriptor td,
1:b7730e4:                                                      String type,
1:b7730e4:                                                      FormatableBitSet columns,
1:2d2e717:                                                      String grantor) throws StandardException
2:b7730e4:     {
1:b7730e4:         return new ColPermsDescriptor( dataDictionary,
1:b7730e4:                                        (String) null,
1:ee59de8:                                        grantor,
1:b7730e4:                                        td.getUUID(),
1:b7730e4:                                        type,
1:b7730e4:                                        columns);
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:b7730e4:      * Create a new routine permissions descriptor
1:b7730e4:      *
1:b7730e4:      * @param ad The routine's alias descriptor
1:b7730e4:      * @param grantor
1:eac0369:      */
1:b7730e4:     public RoutinePermsDescriptor newRoutinePermsDescriptor( AliasDescriptor ad, String grantor)
1:2d2e717: 	throws StandardException
1:b7730e4:     {
1:b7730e4:         return new RoutinePermsDescriptor( dataDictionary,
1:b7730e4:                                            (String) null,
1:b7730e4:                                            grantor,
1:b7730e4:                                            ad.getUUID());
1:eac0369:     }
1:ee59de8: 
1:ee59de8: 
1:ee59de8:     /**
1:4e3ddd7:      * Create a new role grant descriptor
1:ee59de8:      *
1:4e3ddd7: 	 * @param uuid unique identifier for this role grant descriptor in
1:4e3ddd7: 	 *        time and space
1:ee59de8:      * @param roleName the name of the role for which a new descriptor
1:ee59de8:      *                 is created
1:ee59de8:      * @param grantee authorization identifier of grantee
1:ee59de8:      * @param grantor authorization identifier of grantor
1:ee59de8: 	 * @param withadminoption if true, WITH ADMIN OPTION is set for
1:ee59de8: 	 *        this descriptor
1:ee59de8:      * @param isDef if true, this descriptor represents a role
1:ee59de8:      *              definition, otherwise it represents a grant.
1:ee59de8:      */
1:4e3ddd7:     public RoleGrantDescriptor newRoleGrantDescriptor(UUID uuid,
1:4e3ddd7: 													  String roleName,
1:4e3ddd7: 													  String grantee,
1:4e3ddd7: 													  String grantor,
1:4e3ddd7: 													  boolean withadminoption,
1:4e3ddd7: 													  boolean isDef)
1:ee59de8:         throws StandardException
1:ee59de8:     {
1:4e3ddd7:         return new RoleGrantDescriptor(dataDictionary,
1:4e3ddd7: 									   uuid,
1:4e3ddd7: 									   roleName,
1:4e3ddd7: 									   grantee,
1:4e3ddd7: 									   grantor,
1:4e3ddd7: 									   withadminoption,
1:4e3ddd7: 									   isDef);
1:ee59de8:     }
1:bb40bcb: 
1:bb40bcb:     /**
1:bb40bcb:      * Create a new sequence descriptor
1:bb40bcb:      * @param uuid
1:bb40bcb:      * @param sequenceName
1:e4c98e2:      * @return SequenceDescriptor
1:bb40bcb:      */
1:bb40bcb:     public SequenceDescriptor newSequenceDescriptor(
1:bb40bcb:             SchemaDescriptor sd,
1:bb40bcb:             UUID uuid,
1:bb40bcb:             String sequenceName,
1:bb40bcb:             DataTypeDescriptor dataType,
1:139ca85:             Long currentValue,
1:bb40bcb:             long startValue,
1:bb40bcb:             long minimumValue,
1:bb40bcb:             long maximumValue,
1:bb40bcb:             long increment,
1:bb40bcb:             boolean cycle) {
1:bb40bcb:         return new SequenceDescriptor(
1:bb40bcb:                 dataDictionary,
1:bb40bcb:                 sd,
1:bb40bcb:                 uuid,
1:bb40bcb:                 sequenceName,
1:bb40bcb:                 dataType,
1:bb40bcb:                 currentValue,
1:bb40bcb:                 startValue,
1:bb40bcb:                 minimumValue,
1:bb40bcb:                 maximumValue,
1:bb40bcb:                 increment,
1:bb40bcb:                 cycle);
1:bb40bcb:     }
1:bb40bcb: 
1:bb40bcb:     public PermDescriptor newPermDescriptor(
1:bb40bcb:             UUID uuid,
1:bb40bcb:             String objectType,
1:bb40bcb:             UUID permObjectId,
1:bb40bcb:             String permission,
1:bb40bcb:             String grantor,
1:bb40bcb:             String grantee,
1:bb40bcb:             boolean grantable) {
1:bb40bcb:         return new PermDescriptor(dataDictionary,
1:bb40bcb:                 uuid,
1:bb40bcb:                 objectType,
1:bb40bcb:                 permObjectId,
1:bb40bcb:                 permission,
1:bb40bcb:                 grantor,
1:bb40bcb:                 grantee,
1:bb40bcb:                 grantable);
1:bb40bcb:     }
1:56c1dc2:     
1:56c1dc2:     /**
1:56c1dc2:      * Privileged Monitor lookup. Must be package private so that user code
1:56c1dc2:      * can't call this entry point.
1:56c1dc2:      */
1:56c1dc2:     static  ModuleFactory  getMonitor()
1:56c1dc2:     {
1:56c1dc2:         return AccessController.doPrivileged
1:56c1dc2:             (
1:56c1dc2:              new PrivilegedAction<ModuleFactory>()
1:56c1dc2:              {
1:56c1dc2:                  public ModuleFactory run()
1:56c1dc2:                  {
1:56c1dc2:                      return Monitor.getMonitor();
1:56c1dc2:                  }
1:56c1dc2:              }
1:56c1dc2:              );
1:56c1dc2:     }
1:56c1dc2: 
3:b7730e4: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:56c1dc2
/////////////////////////////////////////////////////////////////////////
1: import java.security.AccessController;
1: import java.security.PrivilegedAction;
1: import org.apache.derby.iapi.services.monitor.ModuleFactory;
/////////////////////////////////////////////////////////////////////////
1: 			uuidf = getMonitor().getUUIDFactory();
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Privileged Monitor lookup. Must be package private so that user code
1:      * can't call this entry point.
1:      */
1:     static  ModuleFactory  getMonitor()
1:     {
1:         return AccessController.doPrivileged
1:             (
1:              new PrivilegedAction<ModuleFactory>()
1:              {
1:                  public ModuleFactory run()
1:                  {
1:                      return Monitor.getMonitor();
1:                  }
1:              }
1:              );
1:     }
1: 
commit:aa609d5
/////////////////////////////////////////////////////////////////////////
1: 
1: 	public UserDescriptor newUserDescriptor
1:         (
1:          String userName,
1:          String hashingScheme,
1:          char[] password,
1:          Timestamp lastModified
1:          )
1: 	{
1: 		return new UserDescriptor( dataDictionary, userName, hashingScheme, password, lastModified );
1: 	}
commit:139ca85
/////////////////////////////////////////////////////////////////////////
1:             Long currentValue,
commit:bb40bcb
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.types.DataTypeDescriptor;
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Create a new sequence descriptor
1:      * @param uuid
1:      * @param sequenceName
0:      * @return
1:      */
1:     public SequenceDescriptor newSequenceDescriptor(
1:             SchemaDescriptor sd,
1:             UUID uuid,
1:             String sequenceName,
1:             DataTypeDescriptor dataType,
0:             long currentValue,
1:             long startValue,
1:             long minimumValue,
1:             long maximumValue,
1:             long increment,
1:             boolean cycle) {
1:         return new SequenceDescriptor(
1:                 dataDictionary,
1:                 sd,
1:                 uuid,
1:                 sequenceName,
1:                 dataType,
1:                 currentValue,
1:                 startValue,
1:                 minimumValue,
1:                 maximumValue,
1:                 increment,
1:                 cycle);
1:     }
1: 
1:     public PermDescriptor newPermDescriptor(
1:             UUID uuid,
1:             String objectType,
1:             UUID permObjectId,
1:             String permission,
1:             String grantor,
1:             String grantee,
1:             boolean grantable) {
1:         return new PermDescriptor(dataDictionary,
1:                 uuid,
1:                 objectType,
1:                 permObjectId,
1:                 permission,
1:                 grantor,
1:                 grantee,
1:                 grantable);
1:     }
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:211adc3
/////////////////////////////////////////////////////////////////////////
1:         return new TriggerDescriptor(
/////////////////////////////////////////////////////////////////////////
commit:d9878ca
/////////////////////////////////////////////////////////////////////////
1:      * @param whenClauseText the SQL text of the WHEN clause (may be null)
1:      * @return a trigger descriptor
/////////////////////////////////////////////////////////////////////////
1:         String              newReferencingName,
1:         String              whenClauseText
0:         if (dataDictionary.checkVersion(
0:                 DataDictionary.DD_VERSION_DERBY_10_11, null)) {
0:             // The dictionary version is recent enough to support the WHEN
0:             // clause (DERBY-534). Create a descriptor that uses the new
0:             // format.
0:             return new TriggerDescriptor(
/////////////////////////////////////////////////////////////////////////
1:                     newReferencingName,
1:                     whenClauseText
1:         }
1: 
0:         // This is a soft-upgraded database whose dictionary version is 10.10
0:         // or lower. Create a descriptor that uses the legacy format so that
0:         // it can be read by older database versions.
0:         return new TriggerDescriptor_v10_10(
1:                 dataDictionary,
1:                 sd,
1:                 uuid,
1:                 name,
1:                 eventMask,
1:                 isBefore,
1:                 isRow,
1:                 isEnabled,
1:                 td,
1:                 whenSPSId,
1:                 actionSPSId,
1:                 creationTimestamp,
1:                 referencedCols,
1:                 referencedColsInTriggerAction,
1:                 triggerDefinition,
1:                 referencingOld,
1:                 referencingNew,
1:                 oldReferencingName,
0:                 newReferencingName);
commit:c69c8b0
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.monitor.Monitor;
1: 
0: import org.apache.derby.iapi.sql.dictionary.*;
1: 
0: import org.apache.derby.iapi.types.TypeId;
0: import org.apache.derby.iapi.sql.depend.Dependent;
0: import org.apache.derby.iapi.sql.depend.Provider;
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.sql.execute.ConstantAction;
0: import org.apache.derby.iapi.sql.execute.ExecPreparedStatement;
1: import org.apache.derby.iapi.services.io.FormatableBitSet;
1: 
0: import org.apache.derby.catalog.AliasInfo;
0: import org.apache.derby.catalog.DefaultInfo;
0: import org.apache.derby.catalog.Dependable;
0: import org.apache.derby.catalog.DependableFinder;
1: import org.apache.derby.catalog.ReferencedColumns;
1: import org.apache.derby.catalog.types.ReferencedColumnsDescriptorImpl;
1: import org.apache.derby.catalog.UUID;
0: import org.apache.derby.catalog.Statistics;
1: import java.sql.Timestamp;
0: import java.io.InputStream;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		if (uuidf == null)
0: 			uuidf = Monitor.getMonitor().getUUIDFactory();
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:801cf0d
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.catalog.ReferencedColumns;
0: import org.apache.derby.catalog.UUID;
0: import org.apache.derby.catalog.types.ReferencedColumnsDescriptorImpl;
1: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: import org.apache.derby.iapi.services.monitor.Monitor;
1: import org.apache.derby.iapi.services.uuid.UUIDFactory;
/////////////////////////////////////////////////////////////////////////
1:         return new ConglomerateDescriptor(dataDictionary,
1:                                           conglomerateId,
1:                                           name,
1:                                           indexable,
1:                                           indexRowGenerator,
1:                                           isConstraint,
1:                                           uuid,
1:                                           tableID,
1:                                           schemaID);
commit:78c2db1
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.services.sanity.SanityManager;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Create  a new {@code FileInfoDescriptor} using the supplied arguments.
1:      * 
1:      * id unique id to be used for the new file descriptor
1:      * sd schema of the new file to be stored in the database
1:      * SQLName the SQL name of the new schema object representing the file
1:      * generationID version numberof the file the descriptor describes
1:      * 
1:      * @return the newly created file info descriptor
1:      */
1:     public FileInfoDescriptor newFileInfoDescriptor(
1:                                 UUID             id,
1:                                 SchemaDescriptor sd,
1:                                 String           sqlName,
1:                                 long             generationId
1:                                 )
1:     {
1:         if (SanityManager.DEBUG) {
1:             SanityManager.ASSERT(id != null);
1:         }
1: 
1:         return new FileInfoDescriptor(
1:                 dataDictionary, id, sd, sqlName, generationId);
1:     }
commit:4e3ddd7
/////////////////////////////////////////////////////////////////////////
1:      * Create a new role grant descriptor
1: 	 * @param uuid unique identifier for this role grant descriptor in
1: 	 *        time and space
/////////////////////////////////////////////////////////////////////////
1:     public RoleGrantDescriptor newRoleGrantDescriptor(UUID uuid,
1: 													  String roleName,
1: 													  String grantee,
1: 													  String grantor,
1: 													  boolean withadminoption,
1: 													  boolean isDef)
1:         return new RoleGrantDescriptor(dataDictionary,
1: 									   uuid,
1: 									   roleName,
1: 									   grantee,
1: 									   grantor,
1: 									   withadminoption,
1: 									   isDef);
commit:f717f79
/////////////////////////////////////////////////////////////////////////
0: 	 * @param uuid unique identifier for this role descriptor in time and space
/////////////////////////////////////////////////////////////////////////
0:     public RoleDescriptor newRoleDescriptor(UUID uuid,
0: 											String roleName,
/////////////////////////////////////////////////////////////////////////
0: 								  uuid,
commit:ee59de8
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:     /**
0:      * Create a new role descriptor
1:      *
1:      * @param roleName the name of the role for which a new descriptor
1:      *                 is created
1:      * @param grantee authorization identifier of grantee
1:      * @param grantor authorization identifier of grantor
1: 	 * @param withadminoption if true, WITH ADMIN OPTION is set for
1: 	 *        this descriptor
1:      * @param isDef if true, this descriptor represents a role
1:      *              definition, otherwise it represents a grant.
1:      */
0:     public RoleDescriptor newRoleDescriptor(String roleName,
0: 											String grantee,
0: 											String grantor,
0:                                             boolean withadminoption,
0: 											boolean isDef)
1:         throws StandardException
1:     {
0:         return new RoleDescriptor(dataDictionary,
0:                                   roleName,
0:                                   grantee,
1:                                   grantor,
0: 								  withadminoption,
0:                                   isDef);
1:     }
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:a6f9586
/////////////////////////////////////////////////////////////////////////
1: 	 * @param referencedColsInTriggerAction	what columns does the trigger 
1: 	 *						action reference through old/new transition variables
1: 	 *						(may be null)
/////////////////////////////////////////////////////////////////////////
1: 		int[]				referencedColsInTriggerAction,
/////////////////////////////////////////////////////////////////////////
0: 					referencedColsInTriggerAction,
commit:e4c98e2
/////////////////////////////////////////////////////////////////////////
1:      * @return SequenceDescriptor
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:51572c8
/////////////////////////////////////////////////////////////////////////
1: 
0: import org.apache.derby.catalog.ReferencedColumns;
0: import org.apache.derby.catalog.UUID;
0: import org.apache.derby.catalog.types.ReferencedColumnsDescriptorImpl;
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: import org.apache.derby.iapi.services.uuid.UUIDFactory;
/////////////////////////////////////////////////////////////////////////
0:         uuidf = dataDictionary.getUUIDFactory();
/////////////////////////////////////////////////////////////////////////
commit:2d2e717
/////////////////////////////////////////////////////////////////////////
1: 	throws StandardException
/////////////////////////////////////////////////////////////////////////
1:                                                      String grantor) throws StandardException
/////////////////////////////////////////////////////////////////////////
1: 	throws StandardException
commit:7ecc1f2
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.iapi.sql.dictionary.DataDescriptorGenerator
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:5d24b1a
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.sql.dictionary
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.iapi.sql.dictionary;
1: 
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.iapi.sql.dictionary.*;
1: 
0: import org.apache.derby.iapi.types.TypeId;
0: import org.apache.derby.iapi.sql.depend.Dependent;
0: import org.apache.derby.iapi.sql.depend.Provider;
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.sql.execute.ConstantAction;
0: import org.apache.derby.iapi.sql.execute.ExecPreparedStatement;
0: import org.apache.derby.iapi.services.uuid.UUIDFactory;
1: 
0: import org.apache.derby.catalog.AliasInfo;
0: import org.apache.derby.catalog.DefaultInfo;
0: import org.apache.derby.catalog.Dependable;
0: import org.apache.derby.catalog.DependableFinder;
0: import org.apache.derby.catalog.ReferencedColumns;
0: import org.apache.derby.catalog.types.ReferencedColumnsDescriptorImpl;
0: import org.apache.derby.catalog.UUID;
0: import org.apache.derby.catalog.Statistics;
0: import java.sql.Timestamp;
0: import java.io.InputStream;
1: 
1: /**
1:  * This is an implementation of the DataDescriptorGenerator interface
1:  * that lives in the DataDictionary protocol.  See that interface for
1:  * a description of what this class is supposed to do.
1:  *
1:  * @version 0.1
0:  * @author Jeff Lichtman
1:  */
1: 
1: public class DataDescriptorGenerator 
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 	private 	UUIDFactory uuidf;
1: 
1:     protected	final DataDictionary	dataDictionary; // the data dictionary that this generator operates on
1: 
1: 	/**
1: 	  *	Make a generator. Specify the data dictionary that it operates on.
1: 	  *
1: 	  *	@param	dataDictionary	the data dictionary that this generator makes objects for
1: 	  */
1: 	public	DataDescriptorGenerator( DataDictionary dataDictionary )
1: 	{
1: 		this.dataDictionary = dataDictionary;
1: 	}
1: 
1: 	/**
1: 	 * Create a descriptor for the named schema with a null UUID. 
1: 	 *
1: 	 * @param schemaName	The name of the schema we're interested in.
1: 	 *			If the name is NULL, get the descriptor for the
1: 	 *			current schema.
1: 	 * @param aid	The authorization ID associated with the schema.
1: 	 *		The owner of the schema.
1: 	 *
1: 	 * @param oid	The object ID 
1: 	 *
1: 	 * @return	The descriptor for the schema.
1: 	 * @exception StandardException		Thrown on failure
1: 	 */
1: 	public SchemaDescriptor	newSchemaDescriptor(String schemaName, 
1: 		String aid, UUID oid)
1: 		throws StandardException
1: 	{
1: 		return new SchemaDescriptor(
1:             dataDictionary, schemaName, aid, oid, 
1:             dataDictionary.isSystemSchemaName(schemaName));
1: 	}
1: 
1: 	/**
1: 	 * Create a descriptor for the named table within the given schema.
1: 	 * If the schema parameter is NULL, it creates a schema descriptor
1: 	 * using the current default schema.
1: 	 *
1: 	 * @param tableName	The name of the table to get the descriptor for
1: 	 * @param schema	The descriptor for the schema the table lives in.
1: 	 *			If null, use the current (default) schema.
1: 	 * @param tableType	The type of the table: base table or view.
1: 	 * @param lockGranularity	The lock granularity.
1: 	 *
1: 	 * @return	The descriptor for the table.
1: 	 */
1: 	public TableDescriptor	newTableDescriptor
1: 	(
1: 		String 				tableName,
1: 		SchemaDescriptor	schema,
1: 		int					tableType,
1: 		char				lockGranularity
1:     )
1: 	{
1: 		return new TableDescriptor
1: 			(dataDictionary, tableName, schema, tableType, lockGranularity);
1: 	}
1: 
1: 	/**
1: 	 * Create a descriptor for the temporary table within the given schema.
1: 	 *
1: 	 * @param tableName	The name of the temporary table to get the descriptor for
1: 	 * @param schema	The descriptor for the schema the table lives in.
1: 	 * @param tableType	The type of the table: temporary table
1: 	 * @param onCommitDeleteRows	If true, on commit delete rows else on commit preserve rows of temporary table.
1: 	 * @param onRollbackDeleteRows	If true, on rollback, delete rows from temp tables which were logically modified. true is the only supported value
1: 	 *
1: 	 * @return	The descriptor for the table.
1: 	 */
1: 	public TableDescriptor	newTableDescriptor
1: 	(
1: 		String 				tableName,
1: 		SchemaDescriptor	schema,
1: 		int					tableType,
1: 		boolean				onCommitDeleteRows,
1: 		boolean				onRollbackDeleteRows
1:     )
1: 	{
1: 		return new TableDescriptor
1: 			(dataDictionary, tableName, schema, tableType, onCommitDeleteRows, onRollbackDeleteRows);
1: 	}
1: 
1: 	/**
1: 	 * Create a viewDescriptor for the view with the given UUID.
1: 	 *
1: 	 * @param viewID	the UUID for the view.
1: 	 * @param viewName	the name of the view
1: 	 * @param viewText	the text of the view's query.
1: 	 * @param checkOption	int for check option type 
1: 	 * @param compSchemaId	the UUID of the schema this was compiled in
1: 	 *
1: 	 * @return	A descriptor for the view
1: 	 */
1: 	public ViewDescriptor newViewDescriptor(UUID viewID,
1: 				String viewName, String viewText, int checkOption,
1: 				UUID compSchemaId)
1: 	{
1: 		return new ViewDescriptor(dataDictionary, viewID, viewName, 
1: 				viewText, checkOption, compSchemaId);
1: 	}
1: 
1: 
1: 	/**
1: 	 * @see DataDescriptorGenerator#newUniqueConstraintDescriptor
1: 	 */
1: 	public ReferencedKeyConstraintDescriptor	newUniqueConstraintDescriptor(
1: 						TableDescriptor table,
1: 						String constraintName,
1: 						boolean deferrable,
1: 						boolean initiallyDeferred,
1: 						int[] referencedColumns,
1: 						UUID		constraintId,
1: 						UUID		indexId,
1: 						SchemaDescriptor schemaDesc,
1: 						boolean isEnabled,
1: 						int referenceCount
1: 						)
1: 	{
1: 		return new ReferencedKeyConstraintDescriptor(DataDictionary.UNIQUE_CONSTRAINT,
1: 			dataDictionary, table, constraintName,
1: 				deferrable, initiallyDeferred, 
1: 				referencedColumns, constraintId, 
1: 				indexId, schemaDesc, isEnabled, referenceCount);
1: 	}
1: 
1: 	/**
1: 	 * @see DataDescriptorGenerator#newPrimaryKeyConstraintDescriptor
1: 	 */
1: 	public ReferencedKeyConstraintDescriptor	newPrimaryKeyConstraintDescriptor(
1: 						TableDescriptor table,
1: 						String constraintName,
1: 						boolean deferrable,
1: 						boolean initiallyDeferred,
1: 						int[] referencedColumns,
1: 						UUID		constraintId,
1: 						UUID indexId,
1: 						SchemaDescriptor schemaDesc,
1: 						boolean isEnabled,
1: 						int referenceCount
1: 						)
1: 	{
1: 		return new ReferencedKeyConstraintDescriptor(DataDictionary.PRIMARYKEY_CONSTRAINT,
1: 			dataDictionary, table, constraintName,
1: 				deferrable, initiallyDeferred, 
1: 				referencedColumns, constraintId, 
1: 				indexId, schemaDesc, isEnabled, referenceCount);
1: 	}
1: 
1: 	/**
1: 	 * @see DataDescriptorGenerator#newForeignKeyConstraintDescriptor
1: 	 */
1: 	public ForeignKeyConstraintDescriptor	newForeignKeyConstraintDescriptor(
1: 						TableDescriptor table,
1: 						String constraintName,
1: 						boolean deferrable,
1: 						boolean initiallyDeferred,
1: 						int[] fkColumns,
1: 						UUID	constraintId,
1: 						UUID indexId,
1: 						SchemaDescriptor schemaDesc,
1: 						ReferencedKeyConstraintDescriptor	referencedConstraintDescriptor,
1: 						boolean isEnabled,
1: 						int raDeleteRule,
1: 						int raUpdateRule
1: 						)
1: 	{
1: 		return new ForeignKeyConstraintDescriptor(dataDictionary, table, constraintName,
1: 				deferrable, initiallyDeferred, 
1: 				fkColumns, constraintId, 
1: 				indexId, schemaDesc, 
1: 				referencedConstraintDescriptor, isEnabled, raDeleteRule, raUpdateRule);
1: 	}
1: 
1: 
1: 	/**
1: 	 * @see DataDescriptorGenerator#newForeignKeyConstraintDescriptor
1: 	 */
1: 	public ForeignKeyConstraintDescriptor	newForeignKeyConstraintDescriptor(
1: 						TableDescriptor table,
1: 						String constraintName,
1: 						boolean deferrable,
1: 						boolean initiallyDeferred,
1: 						int[] fkColumns,
1: 						UUID	constraintId,
1: 						UUID indexId,
1: 						SchemaDescriptor schemaDesc,
1: 						UUID	referencedConstraintId,
1: 						boolean isEnabled,
1: 						int raDeleteRule,
1: 						int raUpdateRule
1: 						)
1: 	{
1: 		return new ForeignKeyConstraintDescriptor(dataDictionary, table, constraintName,
1: 				deferrable, initiallyDeferred, 
1: 				fkColumns, constraintId, 
1: 				indexId, schemaDesc, 
1: 				referencedConstraintId, isEnabled, raDeleteRule, raUpdateRule);
1: 	}
1: 
1: 	/**
1: 	 * @see DataDescriptorGenerator#newCheckConstraintDescriptor
1: 	 */
1: 	public CheckConstraintDescriptor	newCheckConstraintDescriptor(
1: 						TableDescriptor table,
1: 						String constraintName,
1: 						boolean deferrable,
1: 						boolean initiallyDeferred,
1: 						UUID		constraintId,
1: 						String constraintText,
1: 						ReferencedColumns referencedColumns,
1: 						SchemaDescriptor schemaDesc,
1: 						boolean isEnabled
1: 						)
1: 	{
1: 		return new CheckConstraintDescriptor(dataDictionary, table, constraintName,
1: 				deferrable, initiallyDeferred, 
1: 				constraintId, 
1: 				constraintText, referencedColumns, schemaDesc, isEnabled);
1: 	}
1: 
1: 	public CheckConstraintDescriptor	newCheckConstraintDescriptor(
1: 						TableDescriptor table,
1: 						String constraintName,
1: 						boolean deferrable,
1: 						boolean initiallyDeferred,
1: 						UUID		constraintId,
1: 						String constraintText,
1: 						int[] refCols,
1: 						SchemaDescriptor schemaDesc,
1: 						boolean isEnabled
1: 						)
1: 	{
1: 		ReferencedColumns referencedColumns = new ReferencedColumnsDescriptorImpl(refCols);
1: 		return new CheckConstraintDescriptor(dataDictionary, table, constraintName,
1: 				deferrable, initiallyDeferred, 
1: 				constraintId, 
1: 				constraintText, referencedColumns, schemaDesc, isEnabled);
1: 	}
1: 
1: 	/**
1: 	 * Create a conglomerate descriptor for the given conglomerate id.
1: 	 *
0: 	 * @param conglomerateID	The identifier for the conglomerate
1: 	 *				we're interested in
1: 	 * @param name			The name of the conglomerate, if any
1: 	 * @param indexable		TRUE means the conglomerate is indexable,
1: 	 *				FALSE means it isn't
1: 	 * @param indexRowGenerator	The IndexRowGenerator for the conglomerate,
1: 	 *							null if it's a heap
1: 	 * @param isConstraint	TRUE means the conglomerate is an index backing 
1: 	 *						up a constraint, FALSE means it isn't
1: 	 *
1: 	 * @param uuid	UUID  for this conglomerate
1: 	 * @param tableID	UUID for the table that this conglomerate belongs to
1: 	 * @param schemaID	UUID for the schema that conglomerate belongs to
1: 	 *
1: 	 * @return	A ConglomerateDescriptor describing the 
1: 	 *		conglomerate. 
1: 	 */
1: 	public ConglomerateDescriptor	newConglomerateDescriptor(
1: 						long conglomerateId,
1: 						String name,
1: 						boolean indexable,
1: 						IndexRowGenerator indexRowGenerator,
1: 						boolean isConstraint,
1: 						UUID uuid,
1: 						UUID tableID,
1: 						UUID schemaID
1: 						)
1: 	{
0: 		return (ConglomerateDescriptor)
0: 				new ConglomerateDescriptor(dataDictionary, conglomerateId,
0: 												name,
0: 												indexable,
0: 												indexRowGenerator,
0: 												isConstraint,
0: 												uuid,
0: 											    tableID,
0: 												schemaID);
1: 	}
1: 
1: 	/**
1: 	 * Create a new trigger descriptor.
1: 	 *
1: 	 * @param sd	the schema descriptor for this trigger
0: 	 * @param id	the trigger id
1: 	 * @param name	the trigger name
1: 	 * @param eventMask	TriggerDescriptor.TRIGGER_EVENT_XXXX
1: 	 * @param isBefore	is this a before (as opposed to after) trigger 
1: 	 * @param isRow		is this a row trigger or statement trigger
1: 	 * @param isEnabled	is this trigger enabled or disabled
1: 	 * @param td		the table upon which this trigger is defined
1: 	 * @param whenSPSId	the sps id for the when clause (may be null)
1: 	 * @param actionSPSId	the spsid for the trigger action (may be null)
1: 	 * @param creationTimestamp	when was this trigger created?
1: 	 * @param referencedCols	what columns does this trigger reference (may be null)
1: 	 * @param triggerDefinition The original user text of the trigger action
1: 	 * @param referencingOld whether or not OLD appears in REFERENCING clause
1: 	 * @param referencingNew whether or not NEW appears in REFERENCING clause
1: 	 * @param oldReferencingName old referencing table name, if any, that appears in REFERCING clause
1: 	 * @param newReferencingName new referencing table name, if any, that appears in REFERCING clause
1: 	 *
1: 	 * @exception StandardException on error
1: 	 */
1: 	public TriggerDescriptor newTriggerDescriptor
1: 	(
1: 		SchemaDescriptor	sd,
1: 		UUID				uuid,
1: 		String				name,
1: 		int					eventMask,
1: 		boolean				isBefore,
1: 		boolean 			isRow,
1: 		boolean 			isEnabled,
1: 		TableDescriptor		td,
1: 		UUID				whenSPSId,
1: 		UUID				actionSPSId,
1: 		Timestamp			creationTimestamp,
1: 		int[]				referencedCols,
1: 		String				triggerDefinition,
1: 		boolean				referencingOld,
1: 		boolean				referencingNew,
1: 		String				oldReferencingName,
0: 		String				newReferencingName
1: 	) throws StandardException
1: 	{
0: 		return new TriggerDescriptor(
0: 					dataDictionary,
0: 					sd,
0: 					uuid,
0: 					name,
0: 					eventMask,
0: 					isBefore,
0: 					isRow,
0: 					isEnabled,
0: 					td,
0: 					whenSPSId,
0: 					actionSPSId,
0: 					creationTimestamp,
0: 					referencedCols,
0: 					triggerDefinition,
0: 					referencingOld,
0: 					referencingNew,
0: 					oldReferencingName,
0: 					newReferencingName
1: 					);
1: 	}
1: 		
1: 	/*
1: 	  get a UUIDFactory. This uses the Monitor to get one the
1: 	  first time and holds onto it for later.
1: 	  */
1: 	protected UUIDFactory getUUIDFactory()
1: 	{
0: 		if (uuidf == null)
0: 			uuidf = Monitor.getMonitor().getUUIDFactory();
1: 		return uuidf;
1: 	}
1: 
1: 	/**
0: 	  @see DataDescriptorGenerator#newFileInfoDescriptor
1: 	  */
0: 	public FileInfoDescriptor newFileInfoDescriptor(
0: 								UUID             id,
0: 								SchemaDescriptor sd,
0: 								String           SQLName,
0: 								long              generationId
1: 								)
1: 	{
0: 		if (id == null) id = getUUIDFactory().createUUID();
0: 		return new FileInfoDescriptor(dataDictionary, id,sd,SQLName,generationId);
1: 	}
1: 	 	
1: }
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2e658c2
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
1: 	 * @param conglomerateId	The identifier for the conglomerate
/////////////////////////////////////////////////////////////////////////
1: 	 * @param uuid	the trigger id
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:b7730e4
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
/////////////////////////////////////////////////////////////////////////
1:     public TablePermsDescriptor newTablePermsDescriptor( TableDescriptor td,
1:                                                          String selectPerm,
1:                                                          String deletePerm,
1:                                                          String insertPerm,
1:                                                          String updatePerm,
1:                                                          String referencesPerm,
1:                                                          String triggerPerm,
1:                                                          String grantor)
1:     {
1:         if( "N".equals( selectPerm) && "N".equals( deletePerm) && "N".equals( insertPerm)
1:             && "N".equals( updatePerm) && "N".equals( referencesPerm) && "N".equals( triggerPerm))
1:             return null;
0:         
1:         return new TablePermsDescriptor( dataDictionary,
1:                                          (String) null,
1:                                          grantor,
1:                                          td.getUUID(),
1:                                          selectPerm,
1:                                          deletePerm,
1:                                          insertPerm,
1:                                          updatePerm,
1:                                          referencesPerm,
1:                                          triggerPerm);
1:     }
0: 
0:     /**
1:      * Manufacture a new ColPermsDescriptor.
1:      *
1:      * @param td The descriptor of the table.
1:      * @param type The action type:
1:      *<ol>
1:      *<li>"s" - select without grant
1:      *<li>"S" - select with grant
1:      *<li>"u" - update without grant
1:      *<li>"U" - update with grant
1:      *<li>"r" - references without grant
1:      *<li>"R" - references with grant
1:      *</ol>
1:      * @param columns the set of columns
0:      */
1:     public ColPermsDescriptor newColPermsDescriptor( TableDescriptor td,
1:                                                      String type,
1:                                                      FormatableBitSet columns,
1:                                                      String grantor)
1:     {
1:         return new ColPermsDescriptor( dataDictionary,
1:                                        (String) null,
1:                                        grantor,
1:                                        td.getUUID(),
1:                                        type,
1:                                        columns);
1:     }
0: 
0:     /**
1:      * Create a new routine permissions descriptor
1:      *
1:      * @param ad The routine's alias descriptor
1:      * @param grantor
0:      */
1:     public RoutinePermsDescriptor newRoutinePermsDescriptor( AliasDescriptor ad, String grantor)
1:     {
1:         return new RoutinePermsDescriptor( dataDictionary,
1:                                            (String) null,
1:                                            grantor,
1:                                            ad.getUUID());
1:     }
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.sql.dictionary
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.iapi.sql.dictionary;
0: 
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.sql.dictionary.*;
0: 
0: import org.apache.derby.iapi.types.TypeId;
0: import org.apache.derby.iapi.sql.depend.Dependent;
0: import org.apache.derby.iapi.sql.depend.Provider;
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.sql.execute.ConstantAction;
0: import org.apache.derby.iapi.sql.execute.ExecPreparedStatement;
0: import org.apache.derby.iapi.services.uuid.UUIDFactory;
0: 
0: import org.apache.derby.catalog.AliasInfo;
0: import org.apache.derby.catalog.DefaultInfo;
0: import org.apache.derby.catalog.Dependable;
0: import org.apache.derby.catalog.DependableFinder;
0: import org.apache.derby.catalog.ReferencedColumns;
0: import org.apache.derby.catalog.types.ReferencedColumnsDescriptorImpl;
0: import org.apache.derby.catalog.UUID;
0: import org.apache.derby.catalog.Statistics;
0: import java.sql.Timestamp;
0: import java.io.InputStream;
0: 
0: /**
0:  * This is an implementation of the DataDescriptorGenerator interface
0:  * that lives in the DataDictionary protocol.  See that interface for
0:  * a description of what this class is supposed to do.
0:  *
0:  * @version 0.1
0:  * @author Jeff Lichtman
0:  */
0: 
0: public class DataDescriptorGenerator 
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	private 	UUIDFactory uuidf;
0: 
0:     protected	final DataDictionary	dataDictionary; // the data dictionary that this generator operates on
0: 
0: 	/**
0: 	  *	Make a generator. Specify the data dictionary that it operates on.
0: 	  *
0: 	  *	@param	dataDictionary	the data dictionary that this generator makes objects for
0: 	  */
0: 	public	DataDescriptorGenerator( DataDictionary dataDictionary )
0: 	{
0: 		this.dataDictionary = dataDictionary;
0: 	}
0: 
0: 	/**
0: 	 * Create a descriptor for the named schema with a null UUID. 
0: 	 *
0: 	 * @param schemaName	The name of the schema we're interested in.
0: 	 *			If the name is NULL, get the descriptor for the
0: 	 *			current schema.
0: 	 * @param aid	The authorization ID associated with the schema.
0: 	 *		The owner of the schema.
0: 	 *
0: 	 * @param oid	The object ID 
0: 	 *
0: 	 * @return	The descriptor for the schema.
0: 	 * @exception StandardException		Thrown on failure
0: 	 */
0: 	public SchemaDescriptor	newSchemaDescriptor(String schemaName, 
0: 		String aid, UUID oid)
0: 		throws StandardException
0: 	{
0: 		return new SchemaDescriptor(
0:             dataDictionary, schemaName, aid, oid, 
0:             dataDictionary.isSystemSchemaName(schemaName));
0: 	}
0: 
0: 	/**
0: 	 * Create a descriptor for the named table within the given schema.
0: 	 * If the schema parameter is NULL, it creates a schema descriptor
0: 	 * using the current default schema.
0: 	 *
0: 	 * @param tableName	The name of the table to get the descriptor for
0: 	 * @param schema	The descriptor for the schema the table lives in.
0: 	 *			If null, use the current (default) schema.
0: 	 * @param tableType	The type of the table: base table or view.
0: 	 * @param lockGranularity	The lock granularity.
0: 	 *
0: 	 * @return	The descriptor for the table.
0: 	 */
0: 	public TableDescriptor	newTableDescriptor
0: 	(
0: 		String 				tableName,
0: 		SchemaDescriptor	schema,
0: 		int					tableType,
0: 		char				lockGranularity
0:     )
0: 	{
0: 		return new TableDescriptor
0: 			(dataDictionary, tableName, schema, tableType, lockGranularity);
0: 	}
0: 
0: 	/**
0: 	 * Create a descriptor for the temporary table within the given schema.
0: 	 *
0: 	 * @param tableName	The name of the temporary table to get the descriptor for
0: 	 * @param schema	The descriptor for the schema the table lives in.
0: 	 * @param tableType	The type of the table: temporary table
0: 	 * @param onCommitDeleteRows	If true, on commit delete rows else on commit preserve rows of temporary table.
0: 	 * @param onRollbackDeleteRows	If true, on rollback, delete rows from temp tables which were logically modified. true is the only supported value
0: 	 *
0: 	 * @return	The descriptor for the table.
0: 	 */
0: 	public TableDescriptor	newTableDescriptor
0: 	(
0: 		String 				tableName,
0: 		SchemaDescriptor	schema,
0: 		int					tableType,
0: 		boolean				onCommitDeleteRows,
0: 		boolean				onRollbackDeleteRows
0:     )
0: 	{
0: 		return new TableDescriptor
0: 			(dataDictionary, tableName, schema, tableType, onCommitDeleteRows, onRollbackDeleteRows);
0: 	}
0: 
0: 	/**
0: 	 * Create a viewDescriptor for the view with the given UUID.
0: 	 *
0: 	 * @param viewID	the UUID for the view.
0: 	 * @param viewName	the name of the view
0: 	 * @param viewText	the text of the view's query.
0: 	 * @param checkOption	int for check option type 
0: 	 * @param compSchemaId	the UUID of the schema this was compiled in
0: 	 *
0: 	 * @return	A descriptor for the view
0: 	 */
0: 	public ViewDescriptor newViewDescriptor(UUID viewID,
0: 				String viewName, String viewText, int checkOption,
0: 				UUID compSchemaId)
0: 	{
0: 		return new ViewDescriptor(dataDictionary, viewID, viewName, 
0: 				viewText, checkOption, compSchemaId);
0: 	}
0: 
0: 
0: 	/**
0: 	 * @see DataDescriptorGenerator#newUniqueConstraintDescriptor
0: 	 */
0: 	public ReferencedKeyConstraintDescriptor	newUniqueConstraintDescriptor(
0: 						TableDescriptor table,
0: 						String constraintName,
0: 						boolean deferrable,
0: 						boolean initiallyDeferred,
0: 						int[] referencedColumns,
0: 						UUID		constraintId,
0: 						UUID		indexId,
0: 						SchemaDescriptor schemaDesc,
0: 						boolean isEnabled,
0: 						int referenceCount
0: 						)
0: 	{
0: 		return new ReferencedKeyConstraintDescriptor(DataDictionary.UNIQUE_CONSTRAINT,
0: 			dataDictionary, table, constraintName,
0: 				deferrable, initiallyDeferred, 
0: 				referencedColumns, constraintId, 
0: 				indexId, schemaDesc, isEnabled, referenceCount);
0: 	}
0: 
0: 	/**
0: 	 * @see DataDescriptorGenerator#newPrimaryKeyConstraintDescriptor
0: 	 */
0: 	public ReferencedKeyConstraintDescriptor	newPrimaryKeyConstraintDescriptor(
0: 						TableDescriptor table,
0: 						String constraintName,
0: 						boolean deferrable,
0: 						boolean initiallyDeferred,
0: 						int[] referencedColumns,
0: 						UUID		constraintId,
0: 						UUID indexId,
0: 						SchemaDescriptor schemaDesc,
0: 						boolean isEnabled,
0: 						int referenceCount
0: 						)
0: 	{
0: 		return new ReferencedKeyConstraintDescriptor(DataDictionary.PRIMARYKEY_CONSTRAINT,
0: 			dataDictionary, table, constraintName,
0: 				deferrable, initiallyDeferred, 
0: 				referencedColumns, constraintId, 
0: 				indexId, schemaDesc, isEnabled, referenceCount);
0: 	}
0: 
0: 	/**
0: 	 * @see DataDescriptorGenerator#newForeignKeyConstraintDescriptor
0: 	 */
0: 	public ForeignKeyConstraintDescriptor	newForeignKeyConstraintDescriptor(
0: 						TableDescriptor table,
0: 						String constraintName,
0: 						boolean deferrable,
0: 						boolean initiallyDeferred,
0: 						int[] fkColumns,
0: 						UUID	constraintId,
0: 						UUID indexId,
0: 						SchemaDescriptor schemaDesc,
0: 						ReferencedKeyConstraintDescriptor	referencedConstraintDescriptor,
0: 						boolean isEnabled,
0: 						int raDeleteRule,
0: 						int raUpdateRule
0: 						)
0: 	{
0: 		return new ForeignKeyConstraintDescriptor(dataDictionary, table, constraintName,
0: 				deferrable, initiallyDeferred, 
0: 				fkColumns, constraintId, 
0: 				indexId, schemaDesc, 
0: 				referencedConstraintDescriptor, isEnabled, raDeleteRule, raUpdateRule);
0: 	}
0: 
0: 
0: 	/**
0: 	 * @see DataDescriptorGenerator#newForeignKeyConstraintDescriptor
0: 	 */
0: 	public ForeignKeyConstraintDescriptor	newForeignKeyConstraintDescriptor(
0: 						TableDescriptor table,
0: 						String constraintName,
0: 						boolean deferrable,
0: 						boolean initiallyDeferred,
0: 						int[] fkColumns,
0: 						UUID	constraintId,
0: 						UUID indexId,
0: 						SchemaDescriptor schemaDesc,
0: 						UUID	referencedConstraintId,
0: 						boolean isEnabled,
0: 						int raDeleteRule,
0: 						int raUpdateRule
0: 						)
0: 	{
0: 		return new ForeignKeyConstraintDescriptor(dataDictionary, table, constraintName,
0: 				deferrable, initiallyDeferred, 
0: 				fkColumns, constraintId, 
0: 				indexId, schemaDesc, 
0: 				referencedConstraintId, isEnabled, raDeleteRule, raUpdateRule);
0: 	}
0: 
0: 	/**
0: 	 * @see DataDescriptorGenerator#newCheckConstraintDescriptor
0: 	 */
0: 	public CheckConstraintDescriptor	newCheckConstraintDescriptor(
0: 						TableDescriptor table,
0: 						String constraintName,
0: 						boolean deferrable,
0: 						boolean initiallyDeferred,
0: 						UUID		constraintId,
0: 						String constraintText,
0: 						ReferencedColumns referencedColumns,
0: 						SchemaDescriptor schemaDesc,
0: 						boolean isEnabled
0: 						)
0: 	{
0: 		return new CheckConstraintDescriptor(dataDictionary, table, constraintName,
0: 				deferrable, initiallyDeferred, 
0: 				constraintId, 
0: 				constraintText, referencedColumns, schemaDesc, isEnabled);
0: 	}
0: 
0: 	public CheckConstraintDescriptor	newCheckConstraintDescriptor(
0: 						TableDescriptor table,
0: 						String constraintName,
0: 						boolean deferrable,
0: 						boolean initiallyDeferred,
0: 						UUID		constraintId,
0: 						String constraintText,
0: 						int[] refCols,
0: 						SchemaDescriptor schemaDesc,
0: 						boolean isEnabled
0: 						)
0: 	{
0: 		ReferencedColumns referencedColumns = new ReferencedColumnsDescriptorImpl(refCols);
0: 		return new CheckConstraintDescriptor(dataDictionary, table, constraintName,
0: 				deferrable, initiallyDeferred, 
0: 				constraintId, 
0: 				constraintText, referencedColumns, schemaDesc, isEnabled);
0: 	}
0: 
0: 	/**
0: 	 * Create a conglomerate descriptor for the given conglomerate id.
0: 	 *
0: 	 * @param conglomerateID	The identifier for the conglomerate
0: 	 *				we're interested in
0: 	 * @param name			The name of the conglomerate, if any
0: 	 * @param indexable		TRUE means the conglomerate is indexable,
0: 	 *				FALSE means it isn't
0: 	 * @param indexRowGenerator	The IndexRowGenerator for the conglomerate,
0: 	 *							null if it's a heap
0: 	 * @param isConstraint	TRUE means the conglomerate is an index backing 
0: 	 *						up a constraint, FALSE means it isn't
0: 	 *
0: 	 * @param uuid	UUID  for this conglomerate
0: 	 * @param tableID	UUID for the table that this conglomerate belongs to
0: 	 * @param schemaID	UUID for the schema that conglomerate belongs to
0: 	 *
0: 	 * @return	A ConglomerateDescriptor describing the 
0: 	 *		conglomerate. 
0: 	 */
0: 	public ConglomerateDescriptor	newConglomerateDescriptor(
0: 						long conglomerateId,
0: 						String name,
0: 						boolean indexable,
0: 						IndexRowGenerator indexRowGenerator,
0: 						boolean isConstraint,
0: 						UUID uuid,
0: 						UUID tableID,
0: 						UUID schemaID
0: 						)
0: 	{
0: 		return (ConglomerateDescriptor)
0: 				new ConglomerateDescriptor(dataDictionary, conglomerateId,
0: 												name,
0: 												indexable,
0: 												indexRowGenerator,
0: 												isConstraint,
0: 												uuid,
0: 											    tableID,
0: 												schemaID);
0: 	}
0: 
0: 	/**
0: 	 * Create a new trigger descriptor.
0: 	 *
0: 	 * @param sd	the schema descriptor for this trigger
0: 	 * @param id	the trigger id
0: 	 * @param name	the trigger name
0: 	 * @param eventMask	TriggerDescriptor.TRIGGER_EVENT_XXXX
0: 	 * @param isBefore	is this a before (as opposed to after) trigger 
0: 	 * @param isRow		is this a row trigger or statement trigger
0: 	 * @param isEnabled	is this trigger enabled or disabled
0: 	 * @param td		the table upon which this trigger is defined
0: 	 * @param whenSPSId	the sps id for the when clause (may be null)
0: 	 * @param actionSPSId	the spsid for the trigger action (may be null)
0: 	 * @param creationTimestamp	when was this trigger created?
0: 	 * @param referencedCols	what columns does this trigger reference (may be null)
0: 	 * @param triggerDefinition The original user text of the trigger action
0: 	 * @param referencingOld whether or not OLD appears in REFERENCING clause
0: 	 * @param referencingNew whether or not NEW appears in REFERENCING clause
0: 	 * @param oldReferencingName old referencing table name, if any, that appears in REFERCING clause
0: 	 * @param newReferencingName new referencing table name, if any, that appears in REFERCING clause
0: 	 *
0: 	 * @exception StandardException on error
0: 	 */
0: 	public TriggerDescriptor newTriggerDescriptor
0: 	(
0: 		SchemaDescriptor	sd,
0: 		UUID				uuid,
0: 		String				name,
0: 		int					eventMask,
0: 		boolean				isBefore,
0: 		boolean 			isRow,
0: 		boolean 			isEnabled,
0: 		TableDescriptor		td,
0: 		UUID				whenSPSId,
0: 		UUID				actionSPSId,
0: 		Timestamp			creationTimestamp,
0: 		int[]				referencedCols,
0: 		String				triggerDefinition,
0: 		boolean				referencingOld,
0: 		boolean				referencingNew,
0: 		String				oldReferencingName,
0: 		String				newReferencingName
0: 	) throws StandardException
0: 	{
0: 		return new TriggerDescriptor(
0: 					dataDictionary,
0: 					sd,
0: 					uuid,
0: 					name,
0: 					eventMask,
0: 					isBefore,
0: 					isRow,
0: 					isEnabled,
0: 					td,
0: 					whenSPSId,
0: 					actionSPSId,
0: 					creationTimestamp,
0: 					referencedCols,
0: 					triggerDefinition,
0: 					referencingOld,
0: 					referencingNew,
0: 					oldReferencingName,
0: 					newReferencingName
0: 					);
0: 	}
0: 		
0: 	/*
0: 	  get a UUIDFactory. This uses the Monitor to get one the
0: 	  first time and holds onto it for later.
0: 	  */
0: 	protected UUIDFactory getUUIDFactory()
0: 	{
0: 		if (uuidf == null)
0: 			uuidf = Monitor.getMonitor().getUUIDFactory();
0: 		return uuidf;
0: 	}
0: 
0: 	/**
0: 	  @see DataDescriptorGenerator#newFileInfoDescriptor
0: 	  */
0: 	public FileInfoDescriptor newFileInfoDescriptor(
0: 								UUID             id,
0: 								SchemaDescriptor sd,
0: 								String           SQLName,
0: 								long              generationId
0: 								)
0: 	{
0: 		if (id == null) id = getUUIDFactory().createUUID();
0: 		return new FileInfoDescriptor(dataDictionary, id,sd,SQLName,generationId);
0: 	}
0: 	 	
0: }
============================================================================