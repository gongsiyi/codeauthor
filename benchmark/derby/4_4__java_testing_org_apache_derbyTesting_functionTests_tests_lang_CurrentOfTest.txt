1:0ceeb86: /*
1:0ceeb86:  *
1:0ceeb86:  * Derby - Class org.apache.derbyTesting.functionTests.tests.lang.CurrentOfTest
1:0ceeb86:  *
1:0ceeb86:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:0ceeb86:  * contributor license agreements.  See the NOTICE file distributed with
1:0ceeb86:  * this work for additional information regarding copyright ownership.
1:0ceeb86:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:7907d9f:  * (the "License"); you may not use this file ecept in compliance with
1:0ceeb86:  * the License.  You may obtain a copy of the License at
1:0ceeb86:  *
1:0ceeb86:  *    http://www.apache.org/licenses/LICENSE-2.0
1:0ceeb86:  *
1:0ceeb86:  * Unless required by applicable law or agreed to in writing, 
1:0ceeb86:  * software distributed under the License is distributed on an 
1:0ceeb86:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, 
1:0ceeb86:  * either express or implied. See the License for the specific 
1:0ceeb86:  * language governing permissions and limitations under the License.
1:0ceeb86:  */
1:0ceeb86: 
1:10ded9d: package org.apache.derbyTesting.functionTests.tests.lang;
25:10ded9d: 
1:10ded9d: import java.sql.PreparedStatement;
1:10ded9d: import java.sql.ResultSet;
1:10ded9d: import java.sql.SQLException;
1:10ded9d: import java.sql.Statement;
1:10ded9d: import junit.framework.Test;
1:10ded9d: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:4b16d4c: import org.apache.derbyTesting.junit.JDBC;
1:10ded9d: 
1:0ceeb86: /** This tests the current of statements, i.e.
1:0ceeb86:      * delete where current of and update where current of.
1:0ceeb86:  * Not done in ij since the cursor names may not be stable.
1:0ceeb86:  */
1:10ded9d: public class CurrentOfTest extends BaseJDBCTestCase {
1:0ceeb86: 
1:0ceeb86: 	
1:0ceeb86: 	/**
1:0ceeb86:      * Public constructor required for running test as standalone JUnit.
1:0ceeb86:      */
1:10ded9d: 	public CurrentOfTest(String name) {
1:10ded9d: 		super(name);
4:10ded9d: 	}
1:0ceeb86: 	/**
1:0ceeb86:      * Create a suite of tests.
1:0ceeb86:      */
1:10ded9d: 	public static Test suite() {
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite("CurrentOfTest");
1:10ded9d: 		suite.addTestSuite(CurrentOfTest.class);
1:0ceeb86: 		//To run the test in both embedded and client/server mode
1:0ceeb86: 		//commenting it for the time being sicne the test fails in the client/server mode
1:0ceeb86: 		//return   TestConfiguration.defaultSuite(CurrentOfTest.class);
1:10ded9d: 		return suite;
1:10ded9d: 	}
1:0ceeb86: 	 /**
1:0ceeb86:      * Set the fixture up with tables t and s and insert 4 rows in table t.
1:0ceeb86:      */
1:10ded9d: 	protected void setUp() throws SQLException {
1:10ded9d: 		getConnection().setAutoCommit(false);
2:10ded9d: 		Statement stmt = createStatement();
1:10ded9d: 		stmt.executeUpdate("create table t (i int, c char(50))");
1:10ded9d: 		stmt.executeUpdate("create table s (i int, c char(50))");
1:10ded9d: 		stmt.executeUpdate("insert into t values (1956, 'hello world')");
1:10ded9d: 		stmt.executeUpdate("insert into t values (456, 'hi yourself')");
1:10ded9d: 		stmt.executeUpdate("insert into t values (180, 'rubber ducky')");
1:10ded9d: 		stmt.executeUpdate("insert into t values (3, 'you are the one')");
2:10ded9d: 		stmt.close();
2:10ded9d: 		commit();
1:10ded9d: 	}
1:0ceeb86: 	/**
1:0ceeb86:      * Tear-down the fixture by removing the tables
1:0ceeb86:      */
1:10ded9d: 	protected void tearDown() throws Exception {
1:4b16d4c:         JDBC.dropSchema(getConnection().getMetaData(),
1:4b16d4c:                 getTestConfiguration().getUserName());
1:10ded9d: 		super.tearDown();
1:10ded9d: 	}
1:49cfc7d: 	
1:49cfc7d: 	/**
1:49cfc7d:      * Test read only statements.
1:49cfc7d: 	 */
1:49cfc7d: 	public void testReadOnlyCursors() throws SQLException {
1:49cfc7d: 		
1:49cfc7d: 		String[] readOnlySQL = 
1:49cfc7d: 		{
1:49cfc7d:             "select I, C from t for read only",
1:49cfc7d:             "select I, C from t for fetch only",
1:7907d9f:             "select I, C FROM T ORDER BY 1",
1:49cfc7d:             "values (1, 2, 3)",
1:49cfc7d:             
1:49cfc7d:             // TEST: Update of cursor with a union
1:49cfc7d:             "select I, C from t union all select I, C from t",
1:49cfc7d:             // TEST: Update of cursor with a join
1:49cfc7d:             "select t1.I, t1.C from t t1, t t2 where t1.I = t2.I",
1:49cfc7d:             // TEST: Update of cursor with a derived table
1:49cfc7d:             "select I, C from (select * from t) t1",
1:49cfc7d:             // TEST: Update of cursor with a subquery
1:49cfc7d:             "select I, C from t where I in (select I from t)"
1:49cfc7d:                    
1:49cfc7d: 		};
1:49cfc7d:         
1:49cfc7d:         // NOTE: JDK 1.4 javadoc for ResultSet.getCursorName()
1:49cfc7d:         // says it will throw an execption if the statement
1:49cfc7d:         // cannot support a positioned update. However that
1:49cfc7d:         // line was removed in JavaSE 6 (JDBC 4) javadoc.
1:49cfc7d:         
1:49cfc7d:         for (int i = 0; i < readOnlySQL.length; i++)
1:49cfc7d:         {
1:49cfc7d:             // The system will not give a cursor name
1:49cfc7d:             // to a read only statement.
1:49cfc7d:             PreparedStatement select = prepareStatement(readOnlySQL[i]);
1:49cfc7d:             ResultSet cursor = select.executeQuery();
1:49cfc7d:             assertNull(readOnlySQL[i], cursor.getCursorName());
1:49cfc7d:             cursor.close();
1:4b16d4c:             
1:49cfc7d:             // but will if the user supplies one.
1:49cfc7d:             select.setCursorName("PLEASE_UPDATE");
1:49cfc7d:             cursor = select.executeQuery();
1:49cfc7d:             assertEquals(readOnlySQL[i], "PLEASE_UPDATE", cursor.getCursorName());
1:49cfc7d:             
1:49cfc7d:             // but the cursor is marked as read only so positioned
1:49cfc7d:             // statements will fail.
1:49cfc7d:             assertCompileError("42X23",
1:49cfc7d:                     "DELETE FROM T WHERE CURRENT OF PLEASE_UPDATE");
1:49cfc7d:             
1:49cfc7d:             assertCompileError("42X23",
1:49cfc7d:                 "UPDATE T SET I = 3 WHERE CURRENT OF PLEASE_UPDATE");
1:49cfc7d:             
1:49cfc7d:             cursor.close();
1:49cfc7d:             select.close();
1:49cfc7d:         }
1:49cfc7d: 	}
1:4b16d4c: 	/**
1:0ceeb86:     * Test delete with the current of statements.
1:0ceeb86:     * Also do some negative testing to see whether correct
1:0ceeb86:     * exceptions are thrown or not.
1:0ceeb86:     * @throws Exception
1:0ceeb86:     */
1:10ded9d: 	public void testDelete() throws SQLException {
1:10ded9d: 		PreparedStatement select, delete;
1:74592e2: 		Statement delete1,delete2;
1:10ded9d: 		ResultSet cursor;
1:74592e2: 		String tableRows = "select i, c from t for read only";
1:74592e2: 		
1:74592e2: 		delete1 = createStatement();
1:74592e2: 		Object[][] expectedRows = new Object[][]{{new String("1956"),new String("hello world")},                                       
1:74592e2: 												 {new String("456"),new String("hi yourself")},                                       
1:74592e2: 												 {new String("180"),new String("rubber ducky")},                                      
1:74592e2: 												 {new String("3"),new String("you are the one")}}; 
1:74592e2: 		JDBC.assertFullResultSet(delete1.executeQuery(tableRows), expectedRows, true);
1:74592e2: 		
1:10ded9d: 		select = prepareStatement("select i, c from t for update");
8:10ded9d: 		cursor = select.executeQuery(); // cursor is now open
1:4b16d4c: 
1:10ded9d: 		// would like to test a delete attempt before the cursor
1:10ded9d: 		// is open, but finagling to get the cursor name would
1:10ded9d: 		// destroy the spirit of the rest of the tests,
1:10ded9d: 		// which want to operate against the generated name.
1:49cfc7d: 
1:10ded9d: 		// TEST: cursor and target table mismatch
1:4bbdd92: 
1:0ceeb86: 		assertCompileError("42X28","delete from s where current of " + cursor.getCursorName()); 
1:0ceeb86: 		
1:10ded9d: 		// TEST: find the cursor during compilation
1:10ded9d: 		delete = prepareStatement("delete from t where current of "
4:10ded9d: 				+ cursor.getCursorName());
1:10ded9d: 		// TEST: delete before the cursor is on a row
2:10ded9d: 		assertStatementError("24000", delete);
3:10ded9d: 		cursor.next();
1:74592e2: 		assertEquals(1956, cursor.getInt(1));
1:74592e2: 		
1:74592e2: 		// TEST: find the cursor during execution and it is on a row
1:10ded9d: 		assertUpdateCount(delete, 1);
1:10ded9d: 		// skip a row and delete another row so that two rows will
1:10ded9d: 		// have been removed from the table when we are done.
1:74592e2: 		// skip this row
1:10ded9d: 		cursor.next();
1:74592e2: 		assertEquals(456, cursor.getInt(1));
1:74592e2: 		cursor.next();
1:74592e2: 		assertEquals(180, cursor.getInt(1));
1:10ded9d: 		assertUpdateCount(delete, 1);
1:74592e2: 		
1:10ded9d: 		// TEST: delete past the last row
1:10ded9d: 		cursor.next();// skip this row
1:74592e2: 		assertEquals(3, cursor.getInt(1));
1:10ded9d: 		assertFalse(cursor.next());
2:0ceeb86: 		if (usingEmbedded())
1:0ceeb86: 			assertStatementError("24000", delete);
2:0ceeb86: 		else
1:3b45118: 			assertStatementError("42X30", delete);
1:0ceeb86: 		
1:0ceeb86: 		
1:10ded9d: 		// TEST: delete off a closed cursor
1:10ded9d: 		// Once this is closed then the cursor no longer exists.
9:10ded9d: 		cursor.close();
1:0ceeb86: 		if (usingEmbedded())
1:3b45118: 			assertStatementError("42X30", delete);
1:0ceeb86: 		else 
1:0ceeb86: 			assertStatementError("XCL16", delete);
1:0ceeb86: 		
1:10ded9d: 		// TEST: no cursor with that name exists
1:10ded9d: 		delete2 = createStatement();
1:65d5b52: 		assertStatementError("42X30", delete2,"delete from t where current of myCursor" );
1:74592e2: 		expectedRows = new Object[][]{{new String("456"),new String("hi yourself")},                                       
1:74592e2: 				   					  {new String("3"),new String("you are the one")}}; 
1:74592e2: 		JDBC.assertFullResultSet(delete1.executeQuery(tableRows), expectedRows, true);
2:10ded9d: 		delete.close();
1:10ded9d: 		delete2.close();
8:10ded9d: 		select.close();
1:7907d9f:         
1:7907d9f:         // Test a cursor where not all the columns can be updated.
1:7907d9f:         // Positioned DELETE is still allowed.
1:7907d9f:         select = prepareStatement("SELECT I, C FROM T FOR UPDATE OF I");
1:7907d9f:         cursor = select.executeQuery();
1:7907d9f:         delete = prepareStatement("delete from t where current of "
1:7907d9f:                 + cursor.getCursorName());
1:7907d9f:         assertTrue(cursor.next());
1:7907d9f:         assertUpdateCount(delete, 1);
1:74592e2:         
1:7907d9f:         delete.close();
1:74592e2:         delete1.close();        
1:7907d9f:         cursor.close();
1:7907d9f:         select.close();
1:7907d9f:         
1:7907d9f: 
1:10ded9d: 		// TEST: attempt to do positioned delete before cursor execute'd
1:10ded9d: 		// TBD
1:7907d9f: 
1:10ded9d: 	}
1:0ceeb86: 	/**
1:0ceeb86: 	    * Test update with the current of statements.
1:0ceeb86: 	    * Also do some negative testing to see whether correct
1:0ceeb86: 	    * exceptions are thrown or not.
1:0ceeb86: 	    * @throws Exception
1:0ceeb86: 	    */
1:10ded9d: 	public void testUpdate() throws SQLException {
1:4bbdd92: 		PreparedStatement select;
1:4bbdd92: 		PreparedStatement update;
1:74592e2: 		Statement select1,update2;
1:4bbdd92: 		ResultSet cursor;
1:74592e2: 		String tableRows = "select i, c from t for read only";
1:10ded9d: 
1:10ded9d: 		// these are basic tests without a where clause on the select.
1:10ded9d: 		// all rows are in and stay in the cursor's set when updated.
1:10ded9d: 
1:10ded9d: 		// because there is no order by (nor can there be)
1:10ded9d: 		// the fact that this test prints out rows may someday
1:10ded9d: 		// be a problem. When that day comes, the row printing
1:10ded9d: 		// can (should) be removed from this test.
1:10ded9d: 
1:10ded9d: 		// TEST: Updated column not found in for update of list
1:10ded9d: 
1:10ded9d: 		select = prepareStatement("select I, C from t for update of I");
1:10ded9d: 		cursor = select.executeQuery(); // cursor is now open
1:0ceeb86: 		assertCompileError("42X31", "update t set C = 'abcde' where current of "+ cursor.getCursorName());
1:10ded9d: 		cursor.close();
1:10ded9d: 		select.close();
1:0ceeb86: 
1:74592e2: 		//Making sure we have the correct rows in the table to begin with
1:74592e2: 		select1 = createStatement();
1:74592e2: 		Object[][] expectedRows = new Object[][]{{new String("1956"),new String("hello world")},                                       
1:74592e2: 				 {new String("456"),new String("hi yourself")},                                       
1:74592e2: 				 {new String("180"),new String("rubber ducky")},                                      
1:74592e2: 				 {new String("3"),new String("you are the one")}}; 
1:74592e2: 		JDBC.assertFullResultSet(select1.executeQuery(tableRows), expectedRows, true);	
1:74592e2: 		
1:10ded9d: 		select = prepareStatement("select I, C from t for update");
1:10ded9d: 		cursor = select.executeQuery(); // cursor is now open
1:0ceeb86: 
1:10ded9d: 		// would like to test a update attempt before the cursor
1:10ded9d: 		// is open, but finagling to get the cursor name would
1:10ded9d: 		// destroy the spirit of the rest of the tests,
1:10ded9d: 		// which want to operate against the generated name.
1:10ded9d: 
1:10ded9d: 		// TEST: cursor and target table mismatch
1:10ded9d: 
1:0ceeb86: 		assertCompileError("42X29","update s set i=1 where current of " + cursor.getCursorName());
1:10ded9d: 
1:10ded9d: 		// TEST: find the cursor during compilation
1:10ded9d: 		update = prepareStatement("update t set i=i+10, c='Gumby was here' where current of "
1:10ded9d: 				+ cursor.getCursorName());
1:10ded9d: 
1:10ded9d: 		// TEST: update before the cursor is on a row
1:10ded9d: 		assertStatementError("24000", update);
1:10ded9d: 
2:10ded9d: 		// TEST: find the cursor during execution and it is on a row
1:10ded9d: 		cursor.next();
1:74592e2: 		assertEquals(1956,cursor.getInt(1));
1:10ded9d: 		assertUpdateCount(update, 1);
1:10ded9d: 
1:10ded9d: 		// TEST: update an already updated row; expect it to succeed.
1:10ded9d: 		// will it have a cumulative effect?
1:10ded9d: 		assertUpdateCount(update, 1);
1:10ded9d: 		// skip a row and update another row so that two rows will
1:10ded9d: 		// have been removed from the table when we are done.
2:10ded9d: 		cursor.next(); // skip this row
1:74592e2: 		assertEquals(456,cursor.getInt(1));
1:10ded9d: 		cursor.next();
1:74592e2: 		assertEquals(180,cursor.getInt(1));
1:10ded9d: 		assertUpdateCount(update, 1);
1:10ded9d: 
1:10ded9d: 		// TEST: update past the last row
1:10ded9d: 		cursor.next(); // skip this row
1:74592e2: 		assertEquals(3,cursor.getInt(1));
1:10ded9d: 		assertFalse(cursor.next());
1:10ded9d: 		assertStatementError("24000", update);
1:10ded9d: 
1:10ded9d: 		// TEST: update off a closed cursor
1:10ded9d: 		cursor.close();
1:10ded9d: 		select.close();
1:3b45118: 		assertStatementError("42X30", update);
1:10ded9d: 		update.close();
1:10ded9d: 
1:10ded9d: 		// TEST: no cursor with that name exists
1:10ded9d: 		update2 = createStatement();
1:10ded9d: 		assertStatementError("42X30", update2,"update t set i=1 where current of nosuchcursor");
1:10ded9d: 		update2.close();
1:74592e2: 		
1:74592e2: 		//Verifyin we have the correct updated rows in the table at the end
1:74592e2: 		expectedRows = new Object[][]{{new String("1976"),new String("Gumby was here")},                                       
1:74592e2: 				 {new String("456"),new String("hi yourself")},                                       
1:74592e2: 				 {new String("190"),new String("Gumby was here")},                                      
1:74592e2: 				 {new String("3"),new String("you are the one")}}; 
1:74592e2: 		JDBC.assertFullResultSet(select1.executeQuery(tableRows), expectedRows, true);
1:10ded9d: 		// TEST: attempt to do positioned update before cursor execute'd
1:10ded9d: 		// TBD
1:4bbdd92: 		
1:4bbdd92: 		cursor.close();
1:4bbdd92: 
1:10ded9d: 	}
1:10ded9d:     
1:4bbdd92:     /**
1:4b16d4c:      * Test the positioned update correctly recompiles when an index is added.
1:4b16d4c:      */
1:4b16d4c:     public void testUpdateRecompileCreateIndex() throws Exception
1:4b16d4c:     {
1:4b16d4c:         recompile("UPDATE T SET I = I + 1 WHERE CURRENT OF ",
1:4b16d4c:                 "CREATE INDEX IT ON T(I)", null);
1:4b16d4c:     }
1:4b16d4c:     
1:4b16d4c:     /**
1:4b16d4c:      * Test the positioned update correctly recompiles when the
1:4b16d4c:      * definition of a function is changed.
1:4b16d4c:      */
1:4b16d4c:     public void testUpdateRecompileChangeFunction() throws Exception
1:4b16d4c:     {
1:4b16d4c:         Statement s = createStatement();
1:4b16d4c:         s.execute("CREATE FUNCTION F(V INTEGER) RETURNS INTEGER " +
1:4b16d4c:                 "NO SQL LANGUAGE JAVA PARAMETER STYLE JAVA " +
1:4b16d4c:                 "EXTERNAL NAME '" + getClass().getName() + ".doubleValue'");
1:4b16d4c:         commit();
1:4b16d4c:         String changeSQL = "CREATE FUNCTION F(V INTEGER) RETURNS INTEGER " +
1:4b16d4c:             "NO SQL LANGUAGE JAVA PARAMETER STYLE JAVA " +
1:4b16d4c:             "EXTERNAL NAME '" + getClass().getName() + ".tripleValue'";
1:4b16d4c:         int firstI = recompile("UPDATE T SET I = F(I) WHERE CURRENT OF ",
1:4b16d4c:                 "DROP FUNCTION F", changeSQL);
1:4b16d4c:         
1:4b16d4c:         String[][] values = new String[][]
1:4b16d4c:               {{"3"}, {"180"}, {"456"}, {"1956"}};
1:4b16d4c:         
1:4b16d4c:         if (firstI == 180)
1:4b16d4c:         {
1:4b16d4c:             // 180 doubled to 360
1:4b16d4c:             // 456 tripled to 1368
1:4b16d4c:             values[1] = new String[] {"360"};
1:4b16d4c:             values[2] = new String[] {"1368"};
1:4b16d4c:         }
1:4b16d4c:         else
1:4b16d4c:         {
1:4b16d4c:             // 456 doubled to 912
1:4b16d4c:             // 180 tripled to 540
1:4b16d4c:             values[1] = new String[] {"540"};
1:4b16d4c:             values[2] = new String[] {"912"};
1:4b16d4c:              
1:4b16d4c:         }
1:4b16d4c: 
1:4b16d4c:         JDBC.assertFullResultSet(s.executeQuery("SELECT I FROM T ORDER BY I"),
1:4b16d4c:                 values);
1:4b16d4c:         
1:4b16d4c:         s.close();
1:4b16d4c:     }    
1:4b16d4c:     /**
1:4b16d4c:      * Test the positioned delete correctly recompiles when an index is added.
1:4b16d4c:      */
1:4b16d4c:     public void testDeleteRecompileCreateIndex()  throws Exception
1:4b16d4c:     {
1:4b16d4c:         recompile("DELETE FROM T WHERE CURRENT OF ",
1:4b16d4c:                 "CREATE INDEX IT ON T(I)", null);
1:4b16d4c:     }
1:4b16d4c:     
1:4b16d4c:     /**
1:4b16d4c:      * Execute a select and then the positioned statement against it.
1:4b16d4c:      * Then execute the changeSQL that should force a recompile of the
1:4b16d4c:      * positioned statement. Then execute the positioned statement
1:4b16d4c:      * again and finally check all is ok with check table.
1:4b16d4c:      * 
1:4b16d4c:      * The positioned statements are executed against the rows that
1:4b16d4c:      * have I=180 and I=456.
1:4b16d4c:      * 
1:4b16d4c:      * @return the value of I for the first row that had the positioned
1:4b16d4c:      * statement executed against it, ie. before the change SQl was executed.
1:4b16d4c:      */
1:4b16d4c:     private int recompile(String positionedSQL, String changeSQL1, String changeSQL2)
1:4b16d4c:          throws SQLException
1:4b16d4c:     {
1:4b16d4c:         Statement s = createStatement();
1:4b16d4c:         PreparedStatement select = prepareStatement("select I, C from t for update");
1:4b16d4c:         ResultSet cursor = select.executeQuery();
1:4b16d4c:         
1:4b16d4c:         
1:4b16d4c:         PreparedStatement update = prepareStatement(
1:4b16d4c:                 positionedSQL + cursor.getCursorName());
1:4b16d4c:         
1:4b16d4c:         // Execute the positioned statement against one row,
1:4b16d4c:         // either i=180 or 456, which ever comes first.
1:4b16d4c:         int firstRowI = -1;
1:4b16d4c:         while (cursor.next())
1:4b16d4c:         {
1:4b16d4c:             int i = cursor.getInt(1);
1:4b16d4c:             if (i == 180 || i == 456) {
1:4b16d4c:                 update.execute();
1:4b16d4c:                 firstRowI = i;
1:4b16d4c:                 break;
1:4b16d4c:             }
1:4b16d4c:         }
1:4b16d4c:         assertTrue(firstRowI == 180 || firstRowI == 456);
1:4b16d4c:  
1:4b16d4c:         s.execute(changeSQL1);
1:4b16d4c:         if (changeSQL2 != null)
1:4b16d4c:             s.execute(changeSQL2);
1:4b16d4c:         
1:4b16d4c:         // And one more execute against one more row
1:4b16d4c:         // either 180 or 456.
1:4b16d4c:         int secondRowI = -1;
1:4b16d4c:         while (cursor.next())
1:4b16d4c:         {
1:4b16d4c:             int i = cursor.getInt(1);
1:4b16d4c:             if (i == 180 || i == 456) {
1:4b16d4c:                 update.execute();
1:4b16d4c:                 secondRowI = i;
1:4b16d4c:                 break;
1:4b16d4c:             }
1:4b16d4c:         }
1:4b16d4c:         assertTrue(firstRowI !=secondRowI);
1:4b16d4c:         assertTrue(secondRowI == 180 || secondRowI == 456);
1:4b16d4c:         
1:4b16d4c:         update.close();
1:4b16d4c:         cursor.close();
1:4b16d4c:         select.close();
1:4b16d4c:         commit();
1:4b16d4c:         s.close();
1:4b16d4c:         
1:4b16d4c:         assertCheckTable("T");
1:4b16d4c:         
1:4b16d4c:         return firstRowI;
1:4b16d4c:     }
1:10ded9d: 
1:0ceeb86: 	/**
1:7907d9f: 	 * Change the current cursor from the one the positioned
1:7907d9f:      * UPDATE and DELETE was compiled against to one that only has a
1:7907d9f:      * subset of the columns being updatable.
1:4bbdd92: 	 */
1:7907d9f: 	public void testCursorChangeUpdateList() throws SQLException {
1:7907d9f:         
1:7907d9f:         // Update will fail
1:7907d9f:         cursorChange(
1:7907d9f:                 "42X31",
1:7907d9f:                 "select I, C from t for update",
1:7907d9f:                 "update t set i=i+19, c='OLD' || cast(i as CHAR(20)) where current of ",
1:7907d9f:                 "select I, C from t for update of I"
1:7907d9f:                 );
1:7907d9f:         
1:7907d9f:         // Delete will succeed.
1:7907d9f:         cursorChange(
1:7907d9f:                 null,
1:7907d9f:                 "select I, C from t for update",
1:7907d9f:                 "DELETE FROM t WHERE CURRENT OF ",
1:7907d9f:                 "select I, C from t for update of I"
1:7907d9f:                 );
1:10ded9d: 	}
1:7907d9f:     
1:7907d9f:     /**
1:7907d9f:      * Change the current cursor from the one the positioned
1:7907d9f:      * UPDATE/DELETE was compiled against to one that is read only
1:7907d9f:      * against the same table.
1:7907d9f:      */
1:7907d9f:     public void testCursorChangeToReadOnly() throws SQLException {
1:7907d9f:     
1:7907d9f:         cursorChange(
1:7907d9f:             "42X23", // cursor is read only
1:7907d9f:             "select I, C from t for update",
1:7907d9f:             "update t set i=i+23 where current of ",
1:7907d9f:             "select I, C from t for fetch only"
1:7907d9f:             );
1:7907d9f:         
1:7907d9f:         cursorChange(
1:7907d9f:                 "42X23", // cursor is read only
1:7907d9f:                 "select I, C from t for update",
1:7907d9f:                 "DELETE FROM t WHERE CURRENT OF ",
1:7907d9f:                 "select I, C from t for fetch only"
1:7907d9f:                 );
1:7907d9f:     }
1:10ded9d: 
1:7907d9f:     /**
1:7907d9f:      * Change the current cursor from the one the positioned
1:7907d9f:      * UPDATE was compiled against to one that is against
1:7907d9f:      * a different table.
1:7907d9f:      * 
1:7907d9f:      * test FAILS - once fixed should be renamed to lose
1:7907d9f:      * the FAIL prefix. Fails as the positioned update wor
1:7907d9f:      */
1:7907d9f:     public void testCursorChangeToDifferentTable() throws SQLException {
1:7907d9f:         
1:7907d9f:         Statement s = createStatement();
1:7907d9f:         s.executeUpdate("INSERT INTO S(I,C) SELECT I,C FROM T");
1:7907d9f:         s.close();
1:7907d9f:         commit();
1:7907d9f:            
1:7907d9f:         cursorChange(
1:7907d9f:             "42X29",  // this is the error testUpdate() sees.
1:7907d9f:             "select I, C from t for update",
1:7907d9f:             "update t set i=i+23 where current of ",
1:7907d9f:             "SELECT I, C FROM S FOR UPDATE"
1:7907d9f:             );
1:7907d9f:         
1:7907d9f:         cursorChange(
1:7907d9f:             "42X28", // this is the error testDelete() sees.
1:7907d9f:             "select I, C from t for update",
1:7907d9f:             "DELETE FROM t WHERE CURRENT OF ",
1:7907d9f:             "SELECT I, C FROM S FOR UPDATE"
1:7907d9f:            );
1:7907d9f:         
1:7907d9f:     }    
1:7907d9f:     
1:7907d9f:     
1:7907d9f:     /**
1:7907d9f:      * Run cursorChange() with an application provided name
1:7907d9f:      * and a system provided name.
1:7907d9f:      * 
1:7907d9f:      */
1:7907d9f:     private void cursorChange(String sqlState,
1:7907d9f:             String initialCursor,
1:7907d9f:             String positionedStatement,
1:7907d9f:             String changeToCursor) throws SQLException
1:7907d9f:     {
1:7907d9f:         // Since these tests delete rows we add a couple more to
1:7907d9f:         // ensure any cursor we open has at least one row.
1:7907d9f:         Statement s = createStatement();
1:7907d9f:         s.executeUpdate("insert into t values (425, 'apache db derby')");
1:7907d9f:         s.executeUpdate("insert into t values (280, 'derby-user users')");
1:7907d9f:         s.close();
1:7907d9f:         commit();
1:7907d9f:         
1:7907d9f:         cursorChange(sqlState, "CHANGE_ME", initialCursor, positionedStatement, changeToCursor);
1:7907d9f:         cursorChange(sqlState, null, initialCursor, positionedStatement, changeToCursor);
1:7907d9f:     }
1:7907d9f:     
1:7907d9f:     /**
1:7907d9f:      * Test what happens to a positioned update when the cursor
1:7907d9f:      * it is compiled against changes to the SQL provided, changeToSQL. 
1:7907d9f:      * This test first prepares a cursor initialCursor 
1:7907d9f:      * using with the given name (or system name if null is passed in)
1:7907d9f:      * A cursor is opened and a positioned update is opened that updates.
1:7907d9f:      * 
1:7907d9f:      * If sqlState is null then no error is expected and thus the
1:7907d9f:      * positioned statement must update a single row.
1:7907d9f:      * Otherwise sqlState is the exected exception for the update.
1:7907d9f:      * 
1:7907d9f:      * If no error is expected then three rows will be either
1:7907d9f:      * updated or deleted depending on the positioned statement.
1:7907d9f:      * 
1:7907d9f:      * If an error is expected then two rows will be updated
1:7907d9f:      * or deleted.
1:7907d9f:      */
1:7907d9f: 	private void cursorChange(String sqlState,
1:7907d9f:             String cursorName,
1:7907d9f:             String initialCursor,
1:7907d9f:             String positionedStatement,
1:7907d9f:             String changeToCursor) throws SQLException {
1:10ded9d: 
1:7907d9f: 		PreparedStatement select = prepareStatement(initialCursor);
1:10ded9d: 		if (cursorName != null)
1:10ded9d: 			select.setCursorName(cursorName);
1:10ded9d: 
1:10ded9d: 		ResultSet cursor = select.executeQuery(); // cursor is now open
1:10ded9d: 
1:10ded9d: 		// TEST: find the cursor during compilation
1:10ded9d: 		cursorName = cursor.getCursorName();
1:7907d9f: 		PreparedStatement update = prepareStatement(
1:7907d9f:                 positionedStatement + cursorName);
1:7907d9f: 		assertTrue(cursor.next());
1:10ded9d: 		assertUpdateCount(update, 1);
1:0ceeb86: 		cursor.close();
1:10ded9d: 
1:7907d9f: 		// now prepare the a cursor with the same name but different SQL.
1:7907d9f: 		PreparedStatement selectdd = prepareStatement(changeToCursor);
1:10ded9d: 		selectdd.setCursorName(cursorName);
2:10ded9d: 		cursor = selectdd.executeQuery();
1:7907d9f: 		assertTrue(cursor.next());
1:7907d9f:         if (sqlState != null)
1:7907d9f: 		    assertStatementError(sqlState,update);
1:7907d9f:         else
1:7907d9f:             assertUpdateCount(update, 1);
1:10ded9d: 
1:10ded9d: 		cursor.close();
1:10ded9d: 		
1:4bbdd92: 		// now execute the original statement again and the positioned update
1:4bbdd92: 		// will work.
1:4bbdd92: 		cursor = select.executeQuery();
1:10ded9d: 		cursor.next();
1:4bbdd92: 		assertUpdateCount(update, 1);
1:4bbdd92: 
1:10ded9d: 		cursor.close();
1:10ded9d: 		update.close();
1:10ded9d: 		selectdd.close();
1:10ded9d: 		select.close();
1:10ded9d: 
1:10ded9d: 	}
1:10ded9d:     
1:4b16d4c:     /*
1:4b16d4c:     ** Routines
1:4b16d4c:     */
1:4b16d4c:     
1:4b16d4c:     public static int doubleValue(int i)
1:4b16d4c:     {
1:4b16d4c:         return i * 2;
1:4b16d4c:     }
1:4b16d4c:     public static int tripleValue(int i)
1:4b16d4c:     {
1:4b16d4c:         return i * 3;
1:4b16d4c:     }
1:10ded9d: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.BaseTestSuite;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite("CurrentOfTest");
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:65d5b52
/////////////////////////////////////////////////////////////////////////
1: 		assertStatementError("42X30", delete2,"delete from t where current of myCursor" );
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:74592e2
/////////////////////////////////////////////////////////////////////////
1: 		Statement delete1,delete2;
1: 		String tableRows = "select i, c from t for read only";
1: 		
1: 		delete1 = createStatement();
1: 		Object[][] expectedRows = new Object[][]{{new String("1956"),new String("hello world")},                                       
1: 												 {new String("456"),new String("hi yourself")},                                       
1: 												 {new String("180"),new String("rubber ducky")},                                      
1: 												 {new String("3"),new String("you are the one")}}; 
1: 		JDBC.assertFullResultSet(delete1.executeQuery(tableRows), expectedRows, true);
1: 		
/////////////////////////////////////////////////////////////////////////
1: 		assertEquals(1956, cursor.getInt(1));
1: 		
1: 		// TEST: find the cursor during execution and it is on a row
1: 		// skip this row
1: 		assertEquals(456, cursor.getInt(1));
1: 		cursor.next();
1: 		assertEquals(180, cursor.getInt(1));
1: 		
1: 		assertEquals(3, cursor.getInt(1));
/////////////////////////////////////////////////////////////////////////
1: 		expectedRows = new Object[][]{{new String("456"),new String("hi yourself")},                                       
1: 				   					  {new String("3"),new String("you are the one")}}; 
1: 		JDBC.assertFullResultSet(delete1.executeQuery(tableRows), expectedRows, true);
/////////////////////////////////////////////////////////////////////////
1:         
1:         delete1.close();        
/////////////////////////////////////////////////////////////////////////
1: 		Statement select1,update2;
1: 		String tableRows = "select i, c from t for read only";
/////////////////////////////////////////////////////////////////////////
1: 		//Making sure we have the correct rows in the table to begin with
1: 		select1 = createStatement();
1: 		Object[][] expectedRows = new Object[][]{{new String("1956"),new String("hello world")},                                       
1: 				 {new String("456"),new String("hi yourself")},                                       
1: 				 {new String("180"),new String("rubber ducky")},                                      
1: 				 {new String("3"),new String("you are the one")}}; 
1: 		JDBC.assertFullResultSet(select1.executeQuery(tableRows), expectedRows, true);	
1: 		
/////////////////////////////////////////////////////////////////////////
1: 		assertEquals(1956,cursor.getInt(1));
/////////////////////////////////////////////////////////////////////////
1: 		assertEquals(456,cursor.getInt(1));
1: 		assertEquals(180,cursor.getInt(1));
1: 		assertEquals(3,cursor.getInt(1));
/////////////////////////////////////////////////////////////////////////
1: 		
1: 		//Verifyin we have the correct updated rows in the table at the end
1: 		expectedRows = new Object[][]{{new String("1976"),new String("Gumby was here")},                                       
1: 				 {new String("456"),new String("hi yourself")},                                       
1: 				 {new String("190"),new String("Gumby was here")},                                      
1: 				 {new String("3"),new String("you are the one")}}; 
1: 		JDBC.assertFullResultSet(select1.executeQuery(tableRows), expectedRows, true);
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:3b45118
/////////////////////////////////////////////////////////////////////////
1: 			assertStatementError("42X30", delete);
1: 			assertStatementError("42X30", delete);
/////////////////////////////////////////////////////////////////////////
1: 		assertStatementError("42X30", update);
commit:4b16d4c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.JDBC;
/////////////////////////////////////////////////////////////////////////
1:         JDBC.dropSchema(getConnection().getMetaData(),
1:                 getTestConfiguration().getUserName());
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Test the positioned update correctly recompiles when an index is added.
1:      */
1:     public void testUpdateRecompileCreateIndex() throws Exception
1:     {
1:         recompile("UPDATE T SET I = I + 1 WHERE CURRENT OF ",
1:                 "CREATE INDEX IT ON T(I)", null);
1:     }
1:     
1:     /**
1:      * Test the positioned update correctly recompiles when the
1:      * definition of a function is changed.
1:      */
1:     public void testUpdateRecompileChangeFunction() throws Exception
1:     {
1:         Statement s = createStatement();
1:         s.execute("CREATE FUNCTION F(V INTEGER) RETURNS INTEGER " +
1:                 "NO SQL LANGUAGE JAVA PARAMETER STYLE JAVA " +
1:                 "EXTERNAL NAME '" + getClass().getName() + ".doubleValue'");
1:         commit();
1:         String changeSQL = "CREATE FUNCTION F(V INTEGER) RETURNS INTEGER " +
1:             "NO SQL LANGUAGE JAVA PARAMETER STYLE JAVA " +
1:             "EXTERNAL NAME '" + getClass().getName() + ".tripleValue'";
1:         int firstI = recompile("UPDATE T SET I = F(I) WHERE CURRENT OF ",
1:                 "DROP FUNCTION F", changeSQL);
1:         
1:         String[][] values = new String[][]
1:               {{"3"}, {"180"}, {"456"}, {"1956"}};
1:         
1:         if (firstI == 180)
1:         {
1:             // 180 doubled to 360
1:             // 456 tripled to 1368
1:             values[1] = new String[] {"360"};
1:             values[2] = new String[] {"1368"};
1:         }
1:         else
1:         {
1:             // 456 doubled to 912
1:             // 180 tripled to 540
1:             values[1] = new String[] {"540"};
1:             values[2] = new String[] {"912"};
1:              
1:         }
1: 
1:         JDBC.assertFullResultSet(s.executeQuery("SELECT I FROM T ORDER BY I"),
1:                 values);
1:         
1:         s.close();
1:     }    
1:     /**
1:      * Test the positioned delete correctly recompiles when an index is added.
1:      */
1:     public void testDeleteRecompileCreateIndex()  throws Exception
1:     {
1:         recompile("DELETE FROM T WHERE CURRENT OF ",
1:                 "CREATE INDEX IT ON T(I)", null);
1:     }
1:     
1:     /**
1:      * Execute a select and then the positioned statement against it.
1:      * Then execute the changeSQL that should force a recompile of the
1:      * positioned statement. Then execute the positioned statement
1:      * again and finally check all is ok with check table.
1:      * 
1:      * The positioned statements are executed against the rows that
1:      * have I=180 and I=456.
1:      * 
1:      * @return the value of I for the first row that had the positioned
1:      * statement executed against it, ie. before the change SQl was executed.
1:      */
1:     private int recompile(String positionedSQL, String changeSQL1, String changeSQL2)
1:          throws SQLException
1:     {
1:         Statement s = createStatement();
1:         PreparedStatement select = prepareStatement("select I, C from t for update");
1:         ResultSet cursor = select.executeQuery();
1:         
1:         
1:         PreparedStatement update = prepareStatement(
1:                 positionedSQL + cursor.getCursorName());
1:         
1:         // Execute the positioned statement against one row,
1:         // either i=180 or 456, which ever comes first.
1:         int firstRowI = -1;
1:         while (cursor.next())
1:         {
1:             int i = cursor.getInt(1);
1:             if (i == 180 || i == 456) {
1:                 update.execute();
1:                 firstRowI = i;
1:                 break;
1:             }
1:         }
1:         assertTrue(firstRowI == 180 || firstRowI == 456);
1:  
1:         s.execute(changeSQL1);
1:         if (changeSQL2 != null)
1:             s.execute(changeSQL2);
1:         
1:         // And one more execute against one more row
1:         // either 180 or 456.
1:         int secondRowI = -1;
1:         while (cursor.next())
1:         {
1:             int i = cursor.getInt(1);
1:             if (i == 180 || i == 456) {
1:                 update.execute();
1:                 secondRowI = i;
1:                 break;
1:             }
1:         }
1:         assertTrue(firstRowI !=secondRowI);
1:         assertTrue(secondRowI == 180 || secondRowI == 456);
1:         
1:         update.close();
1:         cursor.close();
1:         select.close();
1:         commit();
1:         s.close();
1:         
1:         assertCheckTable("T");
1:         
1:         return firstRowI;
1:     }
/////////////////////////////////////////////////////////////////////////
1:     
1:     /*
1:     ** Routines
1:     */
1:     
1:     public static int doubleValue(int i)
1:     {
1:         return i * 2;
1:     }
1:     public static int tripleValue(int i)
1:     {
1:         return i * 3;
1:     }
commit:7907d9f
/////////////////////////////////////////////////////////////////////////
1:  * (the "License"); you may not use this file ecept in compliance with
/////////////////////////////////////////////////////////////////////////
1:             "select I, C FROM T ORDER BY 1",
/////////////////////////////////////////////////////////////////////////
1:         
1:         // Test a cursor where not all the columns can be updated.
1:         // Positioned DELETE is still allowed.
1:         select = prepareStatement("SELECT I, C FROM T FOR UPDATE OF I");
1:         cursor = select.executeQuery();
1:         delete = prepareStatement("delete from t where current of "
1:                 + cursor.getCursorName());
1:         assertTrue(cursor.next());
1:         assertUpdateCount(delete, 1);
1:         delete.close();
1:         
1:         
1:         cursor.close();
1:         select.close();
1:         
/////////////////////////////////////////////////////////////////////////
1: 	 * Change the current cursor from the one the positioned
1:      * UPDATE and DELETE was compiled against to one that only has a
1:      * subset of the columns being updatable.
1: 	public void testCursorChangeUpdateList() throws SQLException {
1:         
1:         // Update will fail
1:         cursorChange(
1:                 "42X31",
1:                 "select I, C from t for update",
1:                 "update t set i=i+19, c='OLD' || cast(i as CHAR(20)) where current of ",
1:                 "select I, C from t for update of I"
1:                 );
1:         
1:         // Delete will succeed.
1:         cursorChange(
1:                 null,
1:                 "select I, C from t for update",
1:                 "DELETE FROM t WHERE CURRENT OF ",
1:                 "select I, C from t for update of I"
1:                 );
1:     
1:     /**
1:      * Change the current cursor from the one the positioned
1:      * UPDATE/DELETE was compiled against to one that is read only
1:      * against the same table.
1:      */
1:     public void testCursorChangeToReadOnly() throws SQLException {
1:     
1:         cursorChange(
1:             "42X23", // cursor is read only
1:             "select I, C from t for update",
1:             "update t set i=i+23 where current of ",
1:             "select I, C from t for fetch only"
1:             );
1:         
1:         cursorChange(
1:                 "42X23", // cursor is read only
1:                 "select I, C from t for update",
1:                 "DELETE FROM t WHERE CURRENT OF ",
1:                 "select I, C from t for fetch only"
1:                 );
1:     }
1:     /**
1:      * Change the current cursor from the one the positioned
1:      * UPDATE was compiled against to one that is against
1:      * a different table.
1:      * 
1:      * test FAILS - once fixed should be renamed to lose
1:      * the FAIL prefix. Fails as the positioned update wor
1:      */
1:     public void testCursorChangeToDifferentTable() throws SQLException {
1:         
1:         Statement s = createStatement();
1:         s.executeUpdate("INSERT INTO S(I,C) SELECT I,C FROM T");
1:         s.close();
1:         commit();
1:            
1:         cursorChange(
1:             "42X29",  // this is the error testUpdate() sees.
1:             "select I, C from t for update",
1:             "update t set i=i+23 where current of ",
1:             "SELECT I, C FROM S FOR UPDATE"
1:             );
1:         
1:         cursorChange(
1:             "42X28", // this is the error testDelete() sees.
1:             "select I, C from t for update",
1:             "DELETE FROM t WHERE CURRENT OF ",
1:             "SELECT I, C FROM S FOR UPDATE"
1:            );
1:         
1:     }    
1:     
1:     
1:     /**
1:      * Run cursorChange() with an application provided name
1:      * and a system provided name.
1:      * 
1:      */
1:     private void cursorChange(String sqlState,
1:             String initialCursor,
1:             String positionedStatement,
1:             String changeToCursor) throws SQLException
1:     {
1:         // Since these tests delete rows we add a couple more to
1:         // ensure any cursor we open has at least one row.
1:         Statement s = createStatement();
1:         s.executeUpdate("insert into t values (425, 'apache db derby')");
1:         s.executeUpdate("insert into t values (280, 'derby-user users')");
1:         s.close();
1:         commit();
1:         
1:         cursorChange(sqlState, "CHANGE_ME", initialCursor, positionedStatement, changeToCursor);
1:         cursorChange(sqlState, null, initialCursor, positionedStatement, changeToCursor);
1:     }
1:     
1:     /**
1:      * Test what happens to a positioned update when the cursor
1:      * it is compiled against changes to the SQL provided, changeToSQL. 
1:      * This test first prepares a cursor initialCursor 
1:      * using with the given name (or system name if null is passed in)
1:      * A cursor is opened and a positioned update is opened that updates.
1:      * 
1:      * If sqlState is null then no error is expected and thus the
1:      * positioned statement must update a single row.
1:      * Otherwise sqlState is the exected exception for the update.
1:      * 
1:      * If no error is expected then three rows will be either
1:      * updated or deleted depending on the positioned statement.
1:      * 
1:      * If an error is expected then two rows will be updated
1:      * or deleted.
1:      */
1: 	private void cursorChange(String sqlState,
1:             String cursorName,
1:             String initialCursor,
1:             String positionedStatement,
1:             String changeToCursor) throws SQLException {
1: 		PreparedStatement select = prepareStatement(initialCursor);
/////////////////////////////////////////////////////////////////////////
1: 		PreparedStatement update = prepareStatement(
1:                 positionedStatement + cursorName);
1: 		assertTrue(cursor.next());
1: 		// now prepare the a cursor with the same name but different SQL.
1: 		PreparedStatement selectdd = prepareStatement(changeToCursor);
1: 		assertTrue(cursor.next());
1:         if (sqlState != null)
1: 		    assertStatementError(sqlState,update);
1:         else
1:             assertUpdateCount(update, 1);
/////////////////////////////////////////////////////////////////////////
commit:49cfc7d
/////////////////////////////////////////////////////////////////////////
1: 	
1: 	/**
1:      * Test read only statements.
1: 	 */
1: 	public void testReadOnlyCursors() throws SQLException {
1: 		
1: 		String[] readOnlySQL = 
1: 		{
1:             "select I, C from t for read only",
1:             "select I, C from t for fetch only",
1:             "values (1, 2, 3)",
1:             
1:             // TEST: Update of cursor with a union
1:             "select I, C from t union all select I, C from t",
1:             // TEST: Update of cursor with a join
1:             "select t1.I, t1.C from t t1, t t2 where t1.I = t2.I",
1:             // TEST: Update of cursor with a derived table
1:             "select I, C from (select * from t) t1",
1:             // TEST: Update of cursor with a subquery
1:             "select I, C from t where I in (select I from t)"
1:                    
1: 		};
1:         
1:         // NOTE: JDK 1.4 javadoc for ResultSet.getCursorName()
1:         // says it will throw an execption if the statement
1:         // cannot support a positioned update. However that
1:         // line was removed in JavaSE 6 (JDBC 4) javadoc.
1:         
1:         for (int i = 0; i < readOnlySQL.length; i++)
1:         {
1:             // The system will not give a cursor name
1:             // to a read only statement.
1:             PreparedStatement select = prepareStatement(readOnlySQL[i]);
1:             ResultSet cursor = select.executeQuery();
1:             assertNull(readOnlySQL[i], cursor.getCursorName());
1:             cursor.close();
1:             
1:             // but will if the user supplies one.
1:             select.setCursorName("PLEASE_UPDATE");
1:             cursor = select.executeQuery();
1:             assertEquals(readOnlySQL[i], "PLEASE_UPDATE", cursor.getCursorName());
1:             
1:             // but the cursor is marked as read only so positioned
1:             // statements will fail.
1:             assertCompileError("42X23",
1:                     "DELETE FROM T WHERE CURRENT OF PLEASE_UPDATE");
1:             
1:             assertCompileError("42X23",
1:                 "UPDATE T SET I = 3 WHERE CURRENT OF PLEASE_UPDATE");
1:             
1:             cursor.close();
1:             select.close();
1:         }
1: 	}
/////////////////////////////////////////////////////////////////////////
commit:4bbdd92
/////////////////////////////////////////////////////////////////////////
1: 		PreparedStatement select;
1: 		PreparedStatement update;
1: 		ResultSet cursor;
/////////////////////////////////////////////////////////////////////////
1: 		
1: 		cursor.close();
1: 
1: 	/**
0: 	 * Test that changing the cursor statement after the positioned
0: 	 * update is handled correctly when the positioned statement
0: 	 * is re-executed. In this case the list of update columns
0: 	 * in changed from all to a single column, while the update
0: 	 * statement is against two columns.
1: 	 */
0: 	public void testCursorChange1() throws SQLException { 
0: 		cursorChange1("CHANGE_ME"); // Application provided cursor name
0: 		cursorChange1(null); // system provided cursor name
0: 	private void cursorChange1(String cursorName) throws SQLException {
/////////////////////////////////////////////////////////////////////////
1: 		
1: 		// now execute the original statement again and the positioned update
1: 		// will work.
1: 		cursor = select.executeQuery();
0: 		update.setInt(1, 19);
0: 		update.setString(2, "switch back!");
1: 		assertUpdateCount(update, 1);
1: 
commit:0ceeb86
/////////////////////////////////////////////////////////////////////////
1: /*
1:  *
1:  * Derby - Class org.apache.derbyTesting.functionTests.tests.lang.CurrentOfTest
1:  *
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
0:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *    http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, 
1:  * software distributed under the License is distributed on an 
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, 
1:  * either express or implied. See the License for the specific 
1:  * language governing permissions and limitations under the License.
1:  */
1: 
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derbyTesting.junit.TestConfiguration;
1: /** This tests the current of statements, i.e.
1:      * delete where current of and update where current of.
1:  * Not done in ij since the cursor names may not be stable.
1:  */
1: 
1: 	
1: 	/**
1:      * Public constructor required for running test as standalone JUnit.
1:      */
1: 	/**
1:      * Create a suite of tests.
1:      */
0: 		TestSuite suite = new TestSuite("CurrentOfTest");
1: 		//To run the test in both embedded and client/server mode
1: 		//commenting it for the time being sicne the test fails in the client/server mode
1: 		//return   TestConfiguration.defaultSuite(CurrentOfTest.class);
1: 	 /**
1:      * Set the fixture up with tables t and s and insert 4 rows in table t.
1:      */
/////////////////////////////////////////////////////////////////////////
1: 	/**
1:      * Tear-down the fixture by removing the tables
1:      */
/////////////////////////////////////////////////////////////////////////
1: 	/**
1:     * Test delete with the current of statements.
1:     * Also do some negative testing to see whether correct
1:     * exceptions are thrown or not.
1:     * @throws Exception
1:     */
/////////////////////////////////////////////////////////////////////////
1: 		assertCompileError("42X28","delete from s where current of " + cursor.getCursorName()); 
/////////////////////////////////////////////////////////////////////////
1: 		if (usingEmbedded())
1: 			assertStatementError("24000", delete);
1: 		else
0: 			assertStatementError("XCL07", delete);
1: 		
1: 		
1: 		if (usingEmbedded())
0: 			assertStatementError("XCL07", delete);
1: 		else 
1: 			assertStatementError("XCL16", delete);
1: 		
1: 		if (usingEmbedded())
0: 			assertStatementError("42X30", delete2,"delete from t where current of myCursor" );
1: 		else
0: 			assertStatementError("XJ202", delete2,"delete from t where current of myCursor" );
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	    * Test update with the current of statements.
1: 	    * Also do some negative testing to see whether correct
1: 	    * exceptions are thrown or not.
1: 	    * @throws Exception
1: 	    */
/////////////////////////////////////////////////////////////////////////
1: 		assertCompileError("42X31", "update t set C = 'abcde' where current of "+ cursor.getCursorName());
1: 		
1: 		
1: 		
/////////////////////////////////////////////////////////////////////////
1: 		assertCompileError("42X29","update s set i=1 where current of " + cursor.getCursorName());
/////////////////////////////////////////////////////////////////////////
0: 		if(cursor != null)
1: 			cursor.close();
0: 		/**
0: 	    *TEST closing a cursor will close the related update
0: 	    */
commit:10ded9d
/////////////////////////////////////////////////////////////////////////
1: package org.apache.derbyTesting.functionTests.tests.lang;
1: 
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: import java.sql.Statement;
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: 
1: public class CurrentOfTest extends BaseJDBCTestCase {
1: 	public CurrentOfTest(String name) {
1: 		super(name);
1: 	}
1: 
1: 	public static Test suite() {
0: 		TestSuite suite = new TestSuite("CurrentOfJunit");
1: 		suite.addTestSuite(CurrentOfTest.class);
1: 		return suite;
1: 	}
1: 
1: 	protected void setUp() throws SQLException {
1: 		getConnection().setAutoCommit(false);
1: 		Statement stmt = createStatement();
1: 		stmt.executeUpdate("create table t (i int, c char(50))");
1: 		stmt.executeUpdate("create table s (i int, c char(50))");
1: 		stmt.executeUpdate("insert into t values (1956, 'hello world')");
1: 		stmt.executeUpdate("insert into t values (456, 'hi yourself')");
1: 		stmt.executeUpdate("insert into t values (180, 'rubber ducky')");
1: 		stmt.executeUpdate("insert into t values (3, 'you are the one')");
1: 		stmt.close();
1: 		commit();
1: 	}
1: 
1: 	protected void tearDown() throws Exception {
1: 		Statement stmt = createStatement();
0: 		stmt.executeUpdate("drop table t");
0: 		stmt.executeUpdate("drop table s");
1: 		stmt.close();
1: 		commit();
1: 		super.tearDown();
1: 	}
1: 
1: 	public void testDelete() throws SQLException {
1: 		PreparedStatement select, delete;
0: 		Statement delete2;
1: 		ResultSet cursor;
1: 		select = prepareStatement("select i, c from t for update");
1: 		cursor = select.executeQuery(); // cursor is now open
1: 
1: 		// would like to test a delete attempt before the cursor
1: 		// is open, but finagling to get the cursor name would
1: 		// destroy the spirit of the rest of the tests,
1: 		// which want to operate against the generated name.
1: 
1: 		// TEST: cursor and target table mismatch
1: 
0: 		try {
0: 			delete = prepareStatement("delete from s where current of "
1: 					+ cursor.getCursorName());
0: 			fail("Exception expected above!");
1: 			delete.close();	
0: 		}catch (SQLException e) {
0: 			assertSQLState("42X28", e);
1: 			
1: 		}
1: 		
1: 		// TEST: find the cursor during compilation
1: 		delete = prepareStatement("delete from t where current of "
1: 				+ cursor.getCursorName());
1: 		// TEST: delete before the cursor is on a row
1: 		assertStatementError("24000", delete);
1: 
1: 		// TEST: find the cursor during execution and it is on a row
1: 		cursor.next();
1: 		assertUpdateCount(delete, 1);
1: 		// skip a row and delete another row so that two rows will
1: 		// have been removed from the table when we are done.
1: 		cursor.next(); // skip this row
1: 		cursor.next();
1: 		assertUpdateCount(delete, 1);
1: 		// TEST: delete past the last row
1: 		cursor.next();// skip this row
1: 		assertFalse(cursor.next());
1: 		assertStatementError("24000", delete);
1: 		// TEST: delete off a closed cursor
1: 		// Once this is closed then the cursor no longer exists.
1: 		cursor.close();
0: 		assertStatementError("XCL07", delete);
1: 		// TEST: no cursor with that name exists
1: 		delete2 = createStatement();
0: 		assertStatementError("42X30", delete2,"delete from t where current of myCursor" );
1: 		delete.close();
1: 		delete2.close();
1: 		select.close();
1: 
1: 		// TEST: attempt to do positioned delete before cursor execute'd
1: 		// TBD
1: 
1: 	}
1: 
1: 	public void testUpdate() throws SQLException {
0: 		PreparedStatement select = null;
0: 		PreparedStatement update = null;
0: 		Statement update2;
0: 		ResultSet cursor = null;
1: 
1: 		// these are basic tests without a where clause on the select.
1: 		// all rows are in and stay in the cursor's set when updated.
1: 
1: 		// because there is no order by (nor can there be)
1: 		// the fact that this test prints out rows may someday
1: 		// be a problem. When that day comes, the row printing
1: 		// can (should) be removed from this test.
1: 
1: 		// TEST: Updated column not found in for update of list
1: 
1: 		select = prepareStatement("select I, C from t for update of I");
1: 		cursor = select.executeQuery(); // cursor is now open
0: 		try {
0: 			update = prepareStatement("update t set C = 'abcde' where current of "
1: 					+ cursor.getCursorName());
0: 			fail("Exception expected above!");
1: 
0: 		} catch (SQLException se) {
0: 			assertSQLState("42X31", se);
1: 		}
1: 
1: 		cursor.close();
1: 		select.close();
1: 
0: 		// TEST: Update of cursor declared READ ONLY
0: 		select = prepareStatement("select I, C from t for read only");
1: 		cursor = select.executeQuery(); // cursor is now open
0: 		assertNull(cursor.getCursorName());
1: 		cursor.close();
1: 		select.close();
1: 
0: 		// TEST: Update of cursor declared FETCH ONLY
0: 		select = prepareStatement("select I, C from t for fetch only");
1: 		cursor = select.executeQuery(); // cursor is now open
0: 		assertNull(cursor.getCursorName());
1: 		cursor.close();
1: 		select.close();
1: 
0: 		// TEST: Update of cursor with a union
0: 		select = prepareStatement("select I, C from t union all select I, C from t");
1: 		cursor = select.executeQuery(); // cursor is now open
0: 		assertNull(cursor.getCursorName());
1: 		cursor.close();
1: 		select.close();
1: 
0: 		// TEST: Update of cursor with a join
0: 		select = prepareStatement("select t1.I, t1.C from t t1, t t2 where t1.I = t2.I");
1: 		cursor = select.executeQuery(); // cursor is now open
0: 		assertNull(cursor.getCursorName());
1: 		cursor.close();
1: 		select.close();
1: 
0: 		// TEST: Update of cursor with a derived table
0: 		select = prepareStatement("select I, C from (select * from t) t1");
1: 		cursor = select.executeQuery(); // cursor is now open
0: 		assertNull(cursor.getCursorName());
1: 		cursor.close();
1: 		select.close();
1: 
0: 		// TEST: Update of cursor with a values clause
0: 		select = prepareStatement("values (1, 2, 3)");
1: 		cursor = select.executeQuery(); // cursor is now open
0: 		assertNull(cursor.getCursorName());
1: 		cursor.close();
1: 		select.close();
1: 
0: 		// TEST: Update of cursor with a subquery
0: 		select = prepareStatement("select I, C from t where I in (select I from t)");
1: 		cursor = select.executeQuery(); // cursor is now open
0: 		assertNull(cursor.getCursorName());
1: 		cursor.close();
1: 		select.close();
1: 
1: 		select = prepareStatement("select I, C from t for update");
1: 		cursor = select.executeQuery(); // cursor is now open
1: 
1: 		// would like to test a update attempt before the cursor
1: 		// is open, but finagling to get the cursor name would
1: 		// destroy the spirit of the rest of the tests,
1: 		// which want to operate against the generated name.
1: 
1: 		// TEST: cursor and target table mismatch
1: 
0: 		try {
0: 			update = prepareStatement("update s set i=1 where current of "
1: 					+ cursor.getCursorName());
0: 			fail("Exception expected above!");
1: 
0: 		} catch (SQLException se) {
0: 			assertSQLState("42X29", se);
1: 		}
1: 
1: 		// TEST: find the cursor during compilation
1: 		update = prepareStatement("update t set i=i+10, c='Gumby was here' where current of "
1: 				+ cursor.getCursorName());
1: 
1: 		// TEST: update before the cursor is on a row
1: 		assertStatementError("24000", update);
1: 
1: 		// TEST: find the cursor during execution and it is on a row
1: 		cursor.next();
1: 		assertUpdateCount(update, 1);
1: 
1: 		// TEST: update an already updated row; expect it to succeed.
1: 		// will it have a cumulative effect?
1: 		assertUpdateCount(update, 1);
1: 		// skip a row and update another row so that two rows will
1: 		// have been removed from the table when we are done.
1: 		cursor.next(); // skip this row
1: 		cursor.next();
1: 		assertUpdateCount(update, 1);
1: 
1: 		// TEST: update past the last row
1: 		cursor.next(); // skip this row
1: 		assertFalse(cursor.next());
1: 		assertStatementError("24000", update);
1: 
1: 		// TEST: update off a closed cursor
1: 		cursor.close();
1: 		select.close();
0: 		assertStatementError("XCL07", update);
1: 		update.close();
1: 
1: 		// TEST: no cursor with that name exists
1: 		update2 = createStatement();
1: 		assertStatementError("42X30", update2,"update t set i=1 where current of nosuchcursor");
1: 		update2.close();
1: 		// TEST: attempt to do positioned update before cursor execute'd
1: 		// TBD
1: 
1: 		
1: 	}
1: 
0: 	public void testbug4395() throws SQLException { 
0: //		 TEST closing a cursor will close the related update
0: 		bug4395("CS4395"); // Application provided cursor name
0: 		bug4395(null); // system provided cursor name
1: 	}
1: 
0: 	private void bug4395(String cursorName) throws SQLException {
1: 
0: 		PreparedStatement select = prepareStatement("select I, C from t for update");
1: 		if (cursorName != null)
1: 			select.setCursorName(cursorName);
1: 
1: 		ResultSet cursor = select.executeQuery(); // cursor is now open
1: 
1: 		// TEST: find the cursor during compilation
1: 		cursorName = cursor.getCursorName();
0: 		PreparedStatement update = prepareStatement("update t set i=i+?, c=? where current of "
0: 				+ cursorName);
1: 		cursor.next();
0: 		update.setInt(1, 10);
0: 		update.setString(2, "Dan was here");
1: 		assertUpdateCount(update, 1);
1: 		cursor.close();
1: 
0: 		// now prepare the a cursor with the same name but only column I for
0: 		// update
0: 		PreparedStatement selectdd = prepareStatement("select I, C from t for update of I");
1: 		selectdd.setCursorName(cursorName);
1: 		cursor = selectdd.executeQuery();
1: 		cursor.next();
0: 		update.setInt(1, 7);
0: 		update.setString(2, "no update");
0: 		assertStatementError("42X31",update);
1: 
1: 		cursor.close();
1: 		cursor = selectdd.executeQuery();
1: 		cursor.next();
1: 		cursor.close();
1: 		update.close();
1: 		selectdd.close();
1: 		select.close();
1: 
1: 	}
1: }
============================================================================