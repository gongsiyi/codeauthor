5:eac0369: /*
1:7ecc1f2: 
1:7ecc1f2:    Derby - Class org.apache.derby.iapi.sql.dictionary.DDUtils
1:7ecc1f2: 
1:2e658c2:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2e658c2:    contributor license agreements.  See the NOTICE file distributed with
1:2e658c2:    this work for additional information regarding copyright ownership.
1:2e658c2:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2e658c2:    (the "License"); you may not use this file except in compliance with
1:2e658c2:    the License.  You may obtain a copy of the License at
1:7ecc1f2: 
1:7ecc1f2:       http://www.apache.org/licenses/LICENSE-2.0
1:7ecc1f2: 
1:7ecc1f2:    Unless required by applicable law or agreed to in writing, software
1:7ecc1f2:    distributed under the License is distributed on an "AS IS" BASIS,
1:7ecc1f2:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7ecc1f2:    See the License for the specific language governing permissions and
1:7ecc1f2:    limitations under the License.
8:eac0369: 
5:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.iapi.sql.dictionary;
1:eac0369: 
1:eac0369: import java.util.Enumeration;
1:801cf0d: import java.util.Hashtable;
1:801cf0d: import org.apache.derby.iapi.error.StandardException;
1:801cf0d: import org.apache.derby.iapi.reference.SQLState;
1:801cf0d: import org.apache.derby.iapi.services.i18n.MessageService;
1:801cf0d: import org.apache.derby.iapi.sql.StatementType;
1:eac0369: 
2:eac0369: /**
1:eac0369:  *	Static Data dictionary utilities.
1:eac0369:  *
1:eac0369:  * @version 0.1
1:eac0369:  */
1:eac0369: 
1:eac0369: public	class	DDUtils
2:eac0369: {
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** For a foreign key, this is used to locate the referenced
1:eac0369: 	** key using the ConstraintInfo.  If it doesn't find the
1:eac0369: 	** correct constraint it will throw an error.
1:eac0369: 	*/
1:eac0369: 	public	static ReferencedKeyConstraintDescriptor locateReferencedConstraint
1:eac0369: 	(
1:eac0369: 		DataDictionary	dd,
1:eac0369: 		TableDescriptor	td,
1:eac0369: 		String			myConstraintName,	// for error messages
1:eac0369: 		String[]		myColumnNames,
1:eac0369: 		ConsInfo		otherConstraintInfo
1:eac0369: 	)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		TableDescriptor refTd = otherConstraintInfo.getReferencedTableDescriptor(dd);
1:eac0369: 		if (refTd == null)
1:eac0369: 		{
1:eac0369: 				throw StandardException.newException(SQLState.LANG_INVALID_FK_NO_REF_TAB, 
1:eac0369: 												myConstraintName, 
1:eac0369: 												otherConstraintInfo.getReferencedTableName());
2:eac0369: 		}
1:eac0369: 
1:eac0369: 
1:801cf0d:         ReferencedKeyConstraintDescriptor refCd;
1:eac0369: 
1:eac0369: 		String[]	refColumnNames = otherConstraintInfo.getReferencedColumnNames();
1:800a91d: 
1:eac0369: 		if (refColumnNames == null ||
1:eac0369: 			refColumnNames.length == 0)
1:eac0369: 		{
1:800a91d: 			/*
1:800a91d: 			** There were no column names specified, just find
1:800a91d: 			** the primary key on the table in question
1:800a91d: 			*/
1:eac0369: 			refCd = refTd.getPrimaryKey();
1:eac0369: 			if (refCd == null)
1:eac0369: 			{
1:eac0369: 				throw StandardException.newException(SQLState.LANG_INVALID_FK_NO_PK, 
1:eac0369: 												myConstraintName, 
1:eac0369: 												refTd.getQualifiedName());
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			ColumnDescriptorList cdl = getColumnDescriptors(dd, td, myColumnNames);
1:eac0369: 
1:eac0369: 			/*
1:eac0369: 			** Check the column list length to give a more informative
1:eac0369: 			** error in case they aren't the same.
1:eac0369: 			*/
1:eac0369: 			if (cdl.size() != refCd.getColumnDescriptors().size())
1:eac0369: 			{
1:eac0369: 				throw StandardException.newException(SQLState.LANG_INVALID_FK_DIFFERENT_COL_COUNT, 
1:eac0369: 												myConstraintName, String.valueOf(cdl.size()), 
1:eac0369: 												String.valueOf(refCd.getColumnDescriptors().size())); 
1:eac0369: 			}
1:eac0369: 	
1:eac0369: 			/*
1:eac0369: 			** Make sure all types are the same.
1:eac0369: 			*/	
1:eac0369: 			if (!refCd.areColumnsComparable(cdl))
1:eac0369: 			{
1:eac0369: 				throw StandardException.newException(SQLState.LANG_INVALID_FK_COL_TYPES_DO_NOT_MATCH, 
1:eac0369: 												myConstraintName);
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			return refCd;	
1:800a91d: 		} 
1:eac0369: 		else
1:eac0369: 		{
1:800a91d: 			/*
1:800a91d: 			** Check the referenced columns vs. each unique or primary key to
1:800a91d: 			** see if they match the foreign key.
1:800a91d: 			*/
1:eac0369: 			ConstraintDescriptor cd;
1:eac0369: 
1:eac0369: 			ColumnDescriptorList colDl = getColumnDescriptors(dd, td, myColumnNames);
1:eac0369: 			ConstraintDescriptorList refCDL = dd.getConstraintDescriptors(refTd);
1:eac0369: 
2:eac0369: 			int refCDLSize = refCDL.size();
2:eac0369: 			for (int index = 0; index < refCDLSize; index++)
1:eac0369: 			{
1:eac0369: 				cd = refCDL.elementAt(index);
1:eac0369: 
1:eac0369: 				/*
1:eac0369: 				** Matches if it is not a check or fk, and
1:eac0369: 				** all the types line up.
1:eac0369: 				*/
1:eac0369: 				if ((cd instanceof ReferencedKeyConstraintDescriptor) &&
1:eac0369: 					 cd.areColumnsComparable(colDl) &&
1:eac0369: 					 columnNamesMatch(refColumnNames, 
1:eac0369: 										cd.getColumnDescriptors()))
1:eac0369: 				{
1:45da2f5:                     if (cd.deferrable()) {
1:45da2f5:                         final int onDelete = otherConstraintInfo.
1:45da2f5:                                 getReferentialActionDeleteRule();
1:45da2f5: 
1:45da2f5:                         if (onDelete == StatementType.RA_CASCADE ||
1:45da2f5:                             onDelete == StatementType.RA_SETNULL) {
1:45da2f5:                             // DERBY-532: Not yet implemented
1:45da2f5:                             throw StandardException.newException(
1:45da2f5:                                     SQLState.LANG_INVALID_FK_REF_KEY,
1:45da2f5:                                     myConstraintName,
1:45da2f5:                                     refTd.getQualifiedName());
1:45da2f5:                         }
1:45da2f5:                     }
1:eac0369: 					return (ReferencedKeyConstraintDescriptor)cd;
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			/*
1:eac0369: 			** If we got here, we didn't find anything
1:eac0369: 			*/
1:eac0369: 			throw StandardException.newException(SQLState.LANG_INVALID_FK_NO_REF_KEY, myConstraintName, 
1:eac0369: 														refTd.getQualifiedName());
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369:     public	static ColumnDescriptorList getColumnDescriptors
1:eac0369: 	(
1:eac0369: 		DataDictionary	dd,
1:eac0369: 		TableDescriptor td,
1:eac0369: 		String[] 		columnNames
1:eac0369: 	)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		ColumnDescriptorList cdl = new ColumnDescriptorList();
1:eac0369: 		for (int colCtr = 0; colCtr < columnNames.length; colCtr++)
1:eac0369: 		{
1:eac0369: 			ColumnDescriptor cd = td.getColumnDescriptor(columnNames[colCtr]);
1:eac0369: 			cdl.add(td.getUUID(), cd);
1:eac0369: 		}
1:eac0369: 		return cdl;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public	static boolean columnNamesMatch(String []columnNames, ColumnDescriptorList cdl)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		if (columnNames.length != cdl.size())
1:eac0369: 		{
1:eac0369: 			return false;
1:eac0369: 		}
1:eac0369: 		
1:eac0369: 		for (int index = 0; index < columnNames.length; index++)
1:eac0369: 		{
1:801cf0d:             String name = cdl.elementAt(index).getColumnName();
1:eac0369: 			if (!name.equals(columnNames[index]))
1:eac0369: 			{
1:eac0369: 				return false;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return true;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	**checks whether the foreign key relation ships referential action
1:eac0369: 	**is violating the restrictions we have in the current system.
2:eac0369: 	**/
1:801cf0d:     @SuppressWarnings("UseOfObsoleteCollectionType")
1:eac0369: 	public static void validateReferentialActions
1:eac0369:     (
1:eac0369: 		DataDictionary	dd,
1:eac0369: 		TableDescriptor	td,
1:eac0369: 		String			myConstraintName,	// for error messages
1:eac0369: 		ConsInfo		otherConstraintInfo,
1:eac0369: 		String[]        columnNames
1:eac0369: 	)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 
1:eac0369: 
1:eac0369: 		int refAction = otherConstraintInfo.getReferentialActionDeleteRule();
1:eac0369: 
1:eac0369: 		//Do not allow ON DELETE SET NULL as a referential action 
1:eac0369: 		//if none of the foreign key columns are  nullable.
1:eac0369: 		if(refAction == StatementType.RA_SETNULL)
1:eac0369: 		{
1:eac0369: 			boolean foundNullableColumn = false;
1:eac0369: 			//check if we have a nullable foreign key column
1:eac0369: 			for (int colCtr = 0; colCtr < columnNames.length; colCtr++)
1:eac0369: 			{
1:eac0369: 				ColumnDescriptor cd = td.getColumnDescriptor(columnNames[colCtr]);
1:eac0369: 				if ((cd.getType().isNullable()))
1:eac0369: 				{
1:eac0369: 					foundNullableColumn = true;
2:eac0369: 					break;
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			if(!foundNullableColumn)
1:eac0369: 			{
1:eac0369: 				throw StandardException.newException(SQLState.LANG_INVALID_FK_COL_FOR_SETNULL, 
1:eac0369: 													 myConstraintName);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		//check whether the foreign key relation ships referential action
1:eac0369: 		//is not violating the restrictions we have in the current system.
1:eac0369: 		TableDescriptor refTd = otherConstraintInfo.getReferencedTableDescriptor(dd);
1:71c8e86: 		Hashtable<String,Integer> deleteConnHashtable = new Hashtable<String,Integer>();
1:eac0369: 		//find whether the foreign key is self referencing.
1:eac0369: 		boolean isSelfReferencingFk = (refTd.getUUID().equals(td.getUUID()));
2:eac0369: 		String refTableName = refTd.getSchemaName() + "." + refTd.getName();
1:eac0369: 		//look for the other foreign key constraints on this table first
1:eac0369: 		int currentSelfRefValue = getCurrentDeleteConnections(dd, td, -1, deleteConnHashtable, false, true);
1:eac0369: 		validateDeleteConnection(dd, td, refTd, 
1:eac0369: 								 refAction, 
1:b3b16bf:                                  deleteConnHashtable,
1:b3b16bf:                                  new Hashtable<String, Integer>(deleteConnHashtable),
1:eac0369: 								 true, myConstraintName, false , 
1:eac0369: 								 new StringBuffer(0), refTableName,
1:eac0369: 								 isSelfReferencingFk,
1:eac0369: 								 currentSelfRefValue);
1:eac0369: 
1:eac0369: 		//if it not a selfreferencing key check for violation of exiting connections.
1:eac0369: 		if(!isSelfReferencingFk)
1:eac0369: 		{
1:eac0369: 			checkForAnyExistingDeleteConnectionViolations(dd, td,
1:eac0369: 														  refAction, 
1:eac0369: 														  deleteConnHashtable, 
1:eac0369: 														  myConstraintName);
1:eac0369: 		}	
1:eac0369: 	}
1:eac0369: 
1:acd0d8b:     /**
1:acd0d8b:      * Finds the existing delete connection for the table and the referential
1:acd0d8b:      * actions that will occur and stores the information in the hash table.
1:acd0d8b:      * HashTable (key , value) = ( table name that this table is delete
1:acd0d8b:      * connected to, referential action that will occur if there is a delete on
1:acd0d8b:      * the table this table connected to [CASCADE, SET NULL, RESTRICT, NO
1:acd0d8b:      * ACTION] )
1:acd0d8b:      */
1:801cf0d:     @SuppressWarnings("UseOfObsoleteCollectionType")
1:eac0369: 	private	static int  getCurrentDeleteConnections
1:eac0369: 	(
1:eac0369: 	 DataDictionary	dd,
1:eac0369: 	 TableDescriptor	td,
1:eac0369: 	 int refActionType,
1:71c8e86: 	 Hashtable<String,Integer> dch,
1:eac0369: 	 boolean prevNotCascade,
1:eac0369: 	 boolean findSelfRef
1:eac0369: 	 )
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 
1:eac0369: 		int selfRefValue = -1; //store the self reference referential action 
1:eac0369: 
1:eac0369: 		//make sure we get any foreign key constraints added earlier in the same statement.
1:eac0369: 		td.emptyConstraintDescriptorList();
1:eac0369: 		ConstraintDescriptorList cdl = dd.getConstraintDescriptors(td);
1:eac0369: 		int cdlSize = cdl.size();
1:eac0369: 
1:eac0369: 		boolean passedInPrevNotCascade = prevNotCascade;
1:eac0369: 		for (int index = 0; index < cdlSize; index++)
1:eac0369: 		{
1:eac0369: 				ConstraintDescriptor cd = cdl.elementAt(index);
1:eac0369: 
1:eac0369: 				//look for  foreign keys
1:eac0369: 				if ((cd instanceof ForeignKeyConstraintDescriptor))
1:eac0369: 				{
1:eac0369: 					ForeignKeyConstraintDescriptor fkcd = (ForeignKeyConstraintDescriptor) cd;
1:eac0369: 					String constraintName = fkcd.getConstraintName();
1:eac0369: 					int raDeleteRule = fkcd.getRaDeleteRule();
1:eac0369: 					int raUpdateRule = fkcd.getRaUpdateRule();
1:eac0369: 
1:eac0369: 					 if(findSelfRef && fkcd.isSelfReferencingFK())
1:eac0369: 					 {
1:eac0369: 						 //All self references will have same  referential actions type
1:eac0369: 						 selfRefValue = raDeleteRule;
1:eac0369: 						 findSelfRef = false;
1:eac0369: 					 }
1:eac0369: 
1:eac0369: 					ReferencedKeyConstraintDescriptor refcd =
1:eac0369: 						fkcd.getReferencedConstraint(); 
1:eac0369: 					TableDescriptor refTd = refcd.getTableDescriptor();
1:eac0369: 					int childRefAction = refActionType == -1 ? raDeleteRule : refActionType;
1:eac0369: 				   
1:eac0369: 					String refTableName = refTd.getSchemaName() + "." + refTd.getName();
1:eac0369: 					//check with  the existing references.
1:801cf0d:                     Integer rAction = dch.get(refTableName);
1:801cf0d: 
1:eac0369: 					if(rAction != null) // we already looked at this table
1:eac0369: 					{
1:eac0369: 						prevNotCascade = passedInPrevNotCascade;
1:eac0369: 						continue;
1:eac0369: 					}
1:eac0369: 
1:eac0369: 					//if we are not cascading, check whether the link before
1:eac0369: 					//this was cascade or not. If we travel through  two NON CASCADE ACTION
1:eac0369: 					//links then the  delete connection is broken(only a delete can have further
1:eac0369: 					// referential effects)
1:eac0369: 					if(raDeleteRule != StatementType.RA_CASCADE)
1:eac0369: 					{
1:eac0369: 						if(prevNotCascade)
1:eac0369: 						{
1:eac0369: 							prevNotCascade = passedInPrevNotCascade;
1:eac0369: 							continue;
1:eac0369: 						}
1:eac0369: 						else
1:eac0369: 							prevNotCascade = true;
1:eac0369: 					}
1:eac0369: 
1:eac0369: 					//store the delete connection info in the hash table,
1:eac0369: 					//note that the referential action value is not what is
1:eac0369: 					//not specified on the current link. It is actually the 
1:eac0369: 					//value of what happens to the table whose delete
1:eac0369: 					// connections we are finding.
1:801cf0d:                     dch.put(refTableName, Integer.valueOf(childRefAction));
1:eac0369: 					
1:eac0369: 					//find the next delete conectiions on this path for non
1:eac0369: 					//self referencig delete connections.
1:eac0369: 					if(!fkcd.isSelfReferencingFK())
1:eac0369: 						getCurrentDeleteConnections(dd , refTd, childRefAction,
1:eac0369: 													dch, true, false);
1:eac0369: 					prevNotCascade = passedInPrevNotCascade;
1:eac0369: 				}
1:eac0369: 		}
1:eac0369: 		
1:eac0369: 		return selfRefValue;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:acd0d8b:     /**
1:acd0d8b:      * The following function validates whether the new foreign key relationship
1:acd0d8b:      * violates any restriction on the referential actions. The current
1:acd0d8b:      * refAction implementation does not allow cases where we can possible land
1:acd0d8b:      * up having multiple action for the same row in a table. This could happen
1:acd0d8b:      * because the user can possibly define different actions through multiple
1:acd0d8b:      * foreign key paths.  The following function throws an error while creating
1:acd0d8b:      * foreign keys if the new releationship leads to any such conditions.
1:acd0d8b:      * NOTE: The SQL99 standard also does not clearly says what we are supposed
1:acd0d8b:      * to do in these cases.  Our implementation just follows what is done in
1:acd0d8b:      * DB2 and throws error messaged similar to DB2 (sql0632N, sql0633N,
1:acd0d8b:      * sql0634N).
1:acd0d8b:      */
1:801cf0d:     @SuppressWarnings("UseOfObsoleteCollectionType")
1:eac0369: 	private	static void validateDeleteConnection
1:eac0369: 	(
1:eac0369: 		DataDictionary	dd,
1:eac0369: 		TableDescriptor actualTd,  // the table we are adding the foriegn key.
1:eac0369: 		TableDescriptor	refTd,
1:eac0369: 		int refActionType,
1:71c8e86: 		Hashtable<String,Integer> dch,
1:71c8e86: 		Hashtable<String,Integer> ech,  //existing delete connections
1:eac0369: 		boolean checkImmediateRefTable,
1:eac0369: 		String myConstraintName,
1:eac0369: 		boolean prevNotCascade,
1:eac0369: 		StringBuffer cycleString, 
1:eac0369: 		String currentRefTableName, //the name of the table we are referring too.
1:eac0369: 		boolean isSelfReferencingFk,
1:eac0369: 		int currentSelfRefValue
1:eac0369: 		)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 
1:eac0369: 		Integer rAction;
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** Validate the new referentail action value with respect to the 
1:eac0369: 		** already existing connections to this table we gathered  from
1:eac0369: 		** the getCurrentDeleteConnections() call.
1:eac0369: 		*/
1:eac0369: 
1:eac0369: 		if(checkImmediateRefTable)
1:eac0369: 		{
1:c7a1d17: 		    String refTableName = refTd.getSchemaName() + "." + refTd.getName();
1:801cf0d:             rAction = dch.get(refTableName);
1:eac0369: 			
1:eac0369: 			// check possible invalide cases incase of self referencing foreign key
1:eac0369: 			if(isSelfReferencingFk)
1:eac0369: 			{
1:eac0369: 				//All the relation ship referring to a table should have the
1:eac0369: 				//same refaction except incase of SET NULL. In this case
1:eac0369: 				//it is the same table , so we have to check with existing self
1:eac0369: 				//referencing actions.
1:eac0369: 				if(currentSelfRefValue !=  -1)
1:eac0369: 				{
1:eac0369: 					if(currentSelfRefValue != refActionType)
1:eac0369: 					{
1:eac0369: 						//If there is a SET NULL relation ship we can not have any
1:eac0369: 						// other relation ship with it.
1:eac0369: 						if(currentSelfRefValue == StatementType.RA_SETNULL)
1:eac0369: 							throw
1:eac0369: 								generateError(SQLState.LANG_CANT_BE_DEPENDENT_ESELF, 
1:eac0369: 										  myConstraintName, currentRefTableName);
1:eac0369: 						else
1:eac0369: 						{
1:eac0369: 								/*
1:eac0369: 								** case where we can cleary say what the
1:eac0369: 								** referential actions should be. Like,	   
1:eac0369: 								** if there is NO ACTION relationsip
1:eac0369: 								**already, new relation ship also shold be NO ACTION. 
1:eac0369: 								*/
1:eac0369: 							throw
1:eac0369: 								generateError(SQLState.LANG_DELETE_RULE_MUSTBE_ESELF,
1:eac0369: 											  myConstraintName, currentSelfRefValue);
1:eac0369: 						}
1:eac0369: 					}else
1:eac0369: 					{
1:eac0369: 						//more than one  ON DELET SET NULL to the same table is not allowed
1:eac0369: 						if(currentSelfRefValue == StatementType.RA_SETNULL &&
1:eac0369: 						   refActionType == StatementType.RA_SETNULL)
1:eac0369: 						{
1:eac0369: 							throw
1:eac0369: 								generateError(SQLState.LANG_CANT_BE_DEPENDENT_ESELF,
1:eac0369: 											  myConstraintName, currentRefTableName);
1:eac0369: 						}
1:eac0369: 					}
1:eac0369: 				}
1:eac0369: 
1:eac0369: 				/*
1:eac0369: 				** If the new releation ship is self referencing and if
1:eac0369: 				** the current existing relation ship to other tables is
1:eac0369: 				** CASCADE type them  new self reference should be of type
1:eac0369: 				** CASCADE, otherwise we should throw error.
1:eac0369: 				*/
1:eac0369: 
1:801cf0d:                 if( isSelfReferencingFk &&
1:801cf0d:                     dch.contains(Integer.valueOf(StatementType.RA_CASCADE)) &&
1:801cf0d:                     refActionType !=  StatementType.RA_CASCADE)
1:eac0369: 				{
1:eac0369: 					throw
1:eac0369: 						generateError(SQLState.LANG_DELETE_RULE_MUSTBE_ECASCADE,
1:eac0369: 									  myConstraintName,StatementType.RA_CASCADE);	
1:eac0369: 				}
1:eac0369: 
1:eac0369: 				//end of possible error case scenarios for self reference key additions
1:eac0369: 				return;
1:eac0369: 			}
1:eac0369: 		
1:eac0369: 			//cases where the new  reference is referring to  another table
1:eac0369: 
1:eac0369: 			//check whether it matched with existing self references.
1:eac0369: 			// If A self-referencing constraint exists with a delete rule of
1:eac0369: 			// SET NULL,  NO ACTION or RESTRICT. We can not add CASCADE
1:eac0369: 			// relationship with another table.
1:eac0369: 				
1:eac0369: 			if(currentSelfRefValue !=  -1)
1:eac0369: 			{
1:eac0369: 				if(refActionType == StatementType.RA_CASCADE && 
1:eac0369: 				   currentSelfRefValue != StatementType.RA_CASCADE) 
1:eac0369: 				{
1:eac0369: 					throw generateError(SQLState.LANG_DELETE_RULE_CANT_BE_CASCADE_ESELF,  myConstraintName);
1:eac0369: 					
1:eac0369: 				}
1:eac0369: 
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			
1:eac0369: 			//check for the cases with existing relationships to the
1:eac0369: 			//referenced table
1:eac0369: 			if(rAction != null)
1:eac0369: 			{
1:eac0369: 				checkForMultiplePathInvalidCases(rAction.intValue(),
1:eac0369: 												  refActionType,
1:eac0369: 												  myConstraintName,currentRefTableName);
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			
1:eac0369: 			//mark the current connect to the reference table to identify the cycle.
1:eac0369: 			if(refActionType != StatementType.RA_CASCADE)
1:eac0369: 			{
1:eac0369: 				prevNotCascade = true;
1:eac0369: 			}
1:eac0369: 			
1:eac0369: 			/*
1:eac0369: 			** cycle string is used to keep track of the referential actions of 
1:eac0369: 			** the nodes we visited, this is required to make sure that in case
1:eac0369: 			** of cycles , all the nodes in the cycle have same type of
1:eac0369: 			** referential action.
1:eac0369: 			**/
1:54dce44: 			cycleString.append(refActionType);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 
1:eac0369: 		boolean passedInPrevNotCascade = prevNotCascade;
1:eac0369: 
1:eac0369: 		//delete connection is broken for if we see ON DELET SET NULL link
1:eac0369: 		// one level deeper than the table we are adding the foreing key
1:eac0369: 		//Where as to check for cycles we need to go for more level also;
1:eac0369:         // To check cases like CASCADE CASCADE SET NULL cycle is not valid. 
1:eac0369: 		//Following variable is used make the distinction.
1:eac0369: 		boolean multiPathCheck = true;
1:eac0369: 
1:eac0369: 		// check for cases where the new connection we are forming to the 
1:eac0369: 		// reference table could create invalid any cycles or mutiple paths 
1:eac0369: 		// with the delete-connections the  referencing table might have already.
1:eac0369: 		ConstraintDescriptorList refCDL = dd.getConstraintDescriptors(refTd);
1:eac0369: 		int refCDLSize = refCDL.size();
1:eac0369: 		for (int index = 0; index < refCDLSize; index++)
1:eac0369: 		{
2:eac0369: 			ConstraintDescriptor cd = refCDL.elementAt(index);
1:eac0369: 
1:eac0369: 			if ((cd instanceof ForeignKeyConstraintDescriptor))
1:eac0369: 			{
1:eac0369: 				ForeignKeyConstraintDescriptor fkcd = (ForeignKeyConstraintDescriptor) cd;
1:eac0369: 				String constraintName = fkcd.getConstraintName();
1:eac0369: 				int raDeleteRule = fkcd.getRaDeleteRule();
1:eac0369: 				int raUpdateRule = fkcd.getRaUpdateRule();
1:eac0369: 				
1:eac0369: 				ReferencedKeyConstraintDescriptor refcd =
1:eac0369: 					fkcd.getReferencedConstraint(); 
1:eac0369: 				TableDescriptor nextRefTd = refcd.getTableDescriptor();
1:eac0369: 
1:eac0369: 				//if we are not cascading, check  whether the link before
1:eac0369: 				//this was cascade or not. If we travel through  two NON CASCADE ACTION
1:eac0369: 				//links then the delete connection is broken(only a delete can have further
1:eac0369: 				//referential effects)
1:eac0369: 				if(raDeleteRule != StatementType.RA_CASCADE)
1:eac0369: 				{
1:eac0369: 					if(prevNotCascade)
1:eac0369: 					{
1:eac0369: 						prevNotCascade = passedInPrevNotCascade;
1:eac0369: 						continue;
1:eac0369: 					}
1:eac0369: 					else
1:eac0369: 					{
1:eac0369: 						prevNotCascade = true;
1:eac0369: 						multiPathCheck = false;
1:eac0369: 					}
1:eac0369: 
1:eac0369: 				}
1:eac0369: 
1:eac0369: 				//check whether the current link is a self referencing one
1:eac0369: 				boolean isSelfRefLink = fkcd.isSelfReferencingFK();
1:eac0369: 				
1:eac0369: 				//check for this is non self referencing cycles case
1:eac0369: 				//In cases of cycle, whole cycle should have the same refAction
1:eac0369: 				// value. Other wise we should throw an exception
1:54dce44: 				cycleString.append(raDeleteRule);
1:eac0369: 				boolean isFormingCycle = (nextRefTd.getUUID().equals(actualTd.getUUID()));
1:eac0369: 				if(isFormingCycle)
1:eac0369: 				{
1:eac0369: 					//make sure that all the nodes in the cycle have the same
1:eac0369: 					//referential action  value, otherwise we should throw an error. 
1:eac0369: 					for(int i = 0 ; i < cycleString.length(); i++)
1:eac0369: 					{
1:eac0369: 						int otherRefAction = Character.getNumericValue(cycleString.charAt(i));
1:eac0369: 						if(otherRefAction != refActionType)
1:eac0369: 						{
1:eac0369: 							//cases where one of the existing relation ships in
1:eac0369: 							//the cycle is not cascade , so we can not have
1:eac0369: 							// cascade relation ship.
1:eac0369: 							if(otherRefAction != StatementType.RA_CASCADE)
1:eac0369: 							{
1:eac0369: 								throw generateError(SQLState.LANG_DELETE_RULE_CANT_BE_CASCADE_ECYCLE, myConstraintName);
1:eac0369: 							}
1:eac0369: 							else
1:eac0369: 							{
1:eac0369: 								//possibly all the other nodes in the cycle has
1:eac0369: 								//cascade relationsship , we can not add a non
1:eac0369: 								//cascade relation ship.
1:eac0369: 								throw
1:eac0369: 									generateError(SQLState.LANG_CANT_BE_DEPENDENT_ECYCLE, 
1:eac0369: 												  myConstraintName, currentRefTableName);
1:eac0369: 							}
1:eac0369: 						}
1:eac0369: 					}
1:eac0369: 				}	
1:eac0369: 
1:eac0369: 
1:eac0369: 				
1:eac0369: 
1:eac0369: 				String nextRefTableName =  nextRefTd.getSchemaName() + "." + nextRefTd.getName();
1:801cf0d:                 rAction = ech.get(nextRefTableName);
1:eac0369: 				if(rAction != null)
1:eac0369: 				{
1:eac0369: 					/*
1:eac0369: 					** If the table name has entry in the hash table means, there
1:eac0369: 					** is already  a path to this table exists from the table
1:eac0369: 					** the new foreign key relation ship is being formed.
1:eac0369: 					** Note: refValue in the hash table is how the table we are
1:eac0369: 					** adding the new relationsship is going to affected not
1:eac0369: 					** current path refvalue.
1:eac0369: 					**/
1:eac0369: 					if(!isSelfRefLink && multiPathCheck)
1:eac0369: 						checkForMultiplePathInvalidCases(rAction.intValue(),
1:eac0369: 														 refActionType, 
1:eac0369: 														 myConstraintName,currentRefTableName);
1:eac0369: 
1:eac0369: 				}else
1:eac0369: 				{
1:801cf0d:                     rAction = dch.get(nextRefTableName);
1:eac0369: 					if(rAction == null)
1:eac0369: 					{
1:801cf0d:                         if (multiPathCheck) {
1:801cf0d:                             dch.put(nextRefTableName,
1:801cf0d:                                     Integer.valueOf(refActionType));
1:801cf0d:                         }
1:801cf0d: 
1:eac0369: 						if(!isSelfRefLink)
1:eac0369: 						{
1:eac0369: 							validateDeleteConnection(dd, actualTd,  nextRefTd,
1:eac0369: 												 refActionType, dch, ech, false,
1:eac0369: 												 myConstraintName,prevNotCascade,
1:eac0369: 												 cycleString, currentRefTableName, 
1:eac0369: 												 isSelfReferencingFk, currentSelfRefValue); 
1:eac0369: 						}
1:eac0369: 					}
1:eac0369: 				}
1:eac0369: 				prevNotCascade = passedInPrevNotCascade;
1:eac0369: 				//removes the char added for the current call
1:eac0369: 				cycleString.setLength(cycleString.length() -1);
1:eac0369: 				
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	**Check whether the mulitple path case is valid or not following
1:eac0369: 	** cases are invalid:
1:eac0369: 	** case 1: The relationship causes the table to be delete-connected to
1:eac0369: 	** the indicated table through multiple relationships and the
1:eac0369: 	** delete rule of the existing relationship is SET NULL. 
1:eac0369: 	** case 2: The relationship would cause the table to be
1:eac0369: 	** delete-connected to the same table through multiple
1:eac0369: 	** relationships and such relationships must have the same 
1:eac0369: 	** delete rule (NO ACTION, RESTRICT or CASCADE). 
1:eac0369: 	** case 3: The relationship would cause another table to be
1:eac0369: 	** delete-connected to the same table through multiple paths
1:eac0369: 	** with different delete rules or with delete rule equal to SET NULL. 
1:eac0369: 	**/
1:eac0369: 
1:eac0369: 	private static void checkForMultiplePathInvalidCases(int currentRefAction,
1:eac0369: 														  int refActionType,
1:eac0369: 														  String myConstraintName,
1:eac0369: 														  String currentRefTableName)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 
1:eac0369: 		//All the relation ship referring to a table should have the
1:eac0369: 		//same refaction except incase of SET NULL
1:eac0369: 		if(currentRefAction != refActionType)
1:eac0369: 		{
1:eac0369: 
1:eac0369: 			//If there is a SET NULL relation ship we can not have any
1:eac0369: 			// other relation ship with it.
1:eac0369: 			if(currentRefAction == StatementType.RA_SETNULL)
1:eac0369: 				throw generateError(SQLState.LANG_CANT_BE_DEPENDENT_MPATH,
1:eac0369: 									myConstraintName, currentRefTableName);
1:eac0369: 			else
1:eac0369: 				//This error say what the delete rule must be for the
1:eac0369: 				// foreign key be valid 
1:eac0369: 				throw generateError(SQLState.LANG_DELETE_RULE_MUSTBE_MPATH,
1:eac0369: 									myConstraintName, currentRefAction);
1:eac0369: 
1:eac0369: 		}else
1:eac0369: 		{
1:eac0369: 			//more than one  ON DELET SET NULL to the same table is not allowed
1:eac0369: 			if(currentRefAction == StatementType.RA_SETNULL &&
1:eac0369: 			   refActionType == StatementType.RA_SETNULL)
1:eac0369: 			{
1:eac0369: 				throw		
1:eac0369: 					generateError(SQLState.LANG_CANT_BE_DEPENDENT_MPATH,
1:eac0369: 								  myConstraintName, currentRefTableName);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369:     /*
1:eac0369: 	** Check whether the delete rule of FOREIGN KEY  must not be CASCADE because
1:eac0369: 	** the  new relationship would cause another table to be delete-connected to
1:eac0369: 	** the same table through multiple paths with different delete rules or with 
1:eac0369: 	** delete rule equal to SET NULL. 
1:eac0369: 	**
1:eac0369: 	** For example :
1:eac0369: 	**                      t1
1:eac0369:     **  		 CASCADE   /  \  CASCADE
1:eac0369:     **                    /    \ 
1:eac0369: 	**                  t2      t3
1:eac0369:     **                   \      /   
1:eac0369:     **          SET NULL  \    /  CASCADE (Can we add this one ? NO)
1:eac0369:  	**			          \   /
1:eac0369: 	                       \t4/
1:eac0369: 	**					
1:eac0369:     **   existing links:
1:eac0369: 	**   t2 references t1   ON DELETE CASCADE  (fkey1)
1:eac0369: 	**   t3 references t1   ON DELETE CASCADE  (fkey2)
1:eac0369: 	**   t2 reference  t4   ON DELETE SET NULL (fkey3)
1:eac0369: 	**   Now if if try to add a new link i.e
1:eac0369: 	**   t4 references t3   ON DELETE SET NULL  (fkey4)
1:eac0369: 	**   Say if we add it,  then if we execute 'delete from t1' 
1:eac0369: 	**   Because of referential actions , we will try to delete a row through
1:eac0369: 	**   one path and tries to update  through another path. 
1:eac0369: 	**   Nothing in standard that say whether we are suppose to delete the row
1:eac0369: 	**   or update the row.  DB2UDB raises error when we try to create the
1:3fd26f3: 	**   foreign key fkey4, Derby also does the same.
1:eac0369: 	** 
1:eac0369: 	**   How we catch the error case ?
1:eac0369: 	**   Point to note here is the table(t4) we are  adding the foreign key does
1:eac0369: 	**   not have a problem in this scenarion because we are adding a
1:eac0369:     **   a CASACDE link , some other table(t2) that is referring  
1:eac0369: 	**   can get multiple referential action paths. We can not
1:eac0369: 	**   this error case for self referencing links.
1:eac0369: 	**   Algorithm:
1:eac0369: 	**   -Gather the foreign keys that are
1:eac0369: 	**   referring(ReferencedKeyConstraintDescriptor) to the table we are adding
1:eac0369: 	**   foreign key, in our example case we get (fkey3 - table t2 -t4 link)
1:eac0369: 	**   for each ReferencedKeyConstraintDescriptor
1:eac0369: 	**   {
1:eac0369: 	**    1)find the delete connections of the referring table.
1:eac0369: 	**    [getCurrentDeleteConnections() will return this hash table]
1:eac0369: 	**	  2) we already have collected the Delete connections 
1:eac0369:     **       in validDeleteConnections() for the actual table we are adding the 
1:eac0369:     **       foreign key.
1:eac0369: 	**    3) Now check whether the referring table  is also 
1:eac0369:     **       referring  any table that the table we are adding
1:eac0369:     **       foreign key has delete connection.
1:eac0369: 	**
1:eac0369: 	**     for each table referring table delete connection hash table
1:eac0369: 	**     {
1:eac0369: 	**      if it is there in the actual table delete connection hash table
1:eac0369:     **      {
1:eac0369: 	**         //In our example case we find t1 in both the hash tables.
1:eac0369: 	**         make sure we are having valid referential action
1:eac0369:     **         from the existing path and the new path we got from 
1:eac0369: 	**         new foreign key relation ship.
1:eac0369: 	**        //In our example case t2 has CASCADE relations with t1
1:eac0369: 	**        //Because of new foreign key added we also get 
1:eac0369: 	**        //SET NULL relation ship with t1. This is not valid
1:eac0369: 	**        //so we should throw error.
1:eac0369:     **      }  
1:eac0369: 	**     }
1:eac0369: 	** }	
1:eac0369: 	**/
1:eac0369: 
1:eac0369: 
1:801cf0d:     @SuppressWarnings("UseOfObsoleteCollectionType")
1:801cf0d:     private static void checkForAnyExistingDeleteConnectionViolations
1:eac0369: 	(
1:eac0369: 	 DataDictionary	dd,
1:eac0369: 	 TableDescriptor td,
1:eac0369: 	 int refActionType,
1:71c8e86: 	 Hashtable<String,Integer> newDconnHashTable,
1:eac0369: 	 String myConstraintName
1:eac0369: 	 )
1:eac0369: 	throws StandardException
1:eac0369: 	{
1:eac0369: 
1:eac0369: 		//We need to check for the condition in this function only when we are
1:eac0369: 		//adding ref action of type CASCADE
1:eac0369: 		if(refActionType != StatementType.RA_CASCADE)
1:eac0369: 			return;
1:eac0369: 		
1:eac0369: 		//find the tables that are referring to the table we 
1:eac0369: 		//are adding the foreign key and check whether we violate their existing rules.
1:eac0369: 		String addTableName = td.getSchemaName() + "." + td.getName();;
1:eac0369: 
1:801cf0d:         for (ConstraintDescriptor cd : dd.getConstraintDescriptors(td))
1:801cf0d:         {
1:eac0369: 			if ((cd instanceof ReferencedKeyConstraintDescriptor))
1:eac0369: 			{
1:eac0369: 				ConstraintDescriptorList fkcdl = dd.getActiveConstraintDescriptors
1:eac0369: 					( ((ReferencedKeyConstraintDescriptor)cd).getForeignKeyConstraints(ConstraintDescriptor.ALL));
1:eac0369: 	
1:eac0369: 				int size = fkcdl.size();
1:eac0369: 				if (size == 0) 
1:eac0369: 				{ 
1:eac0369: 					continue; 
1:eac0369: 				}
1:eac0369: 				
1:eac0369: 				//Note: More than one table can refer to the same
1:eac0369: 				//ReferencedKeyConstraintDescriptor, so we need to find all the tables.
1:71c8e86: 				Hashtable<String,Integer> dConnHashtable = new Hashtable<String,Integer>();
1:eac0369: 				for (int inner = 0; inner < size; inner++)
1:eac0369: 				{
1:eac0369: 					ForeignKeyConstraintDescriptor fkcd = (ForeignKeyConstraintDescriptor) fkcdl.elementAt(inner);
1:eac0369: 					TableDescriptor fktd = fkcd.getTableDescriptor();
1:eac0369: 					//Delete rule that we have to the table we are adding the
1:eac0369: 					// foreign key relation shop
1:eac0369: 					int raDeleteRuleToAddTable = fkcd.getRaDeleteRule();
1:eac0369: 
1:eac0369: 					//This check should not be done on self referencing references.
1:eac0369: 					if(!fkcd.isSelfReferencingFK())
1:eac0369: 					{
1:eac0369: 
1:eac0369: 						//gather the delete connections of the table that is
1:eac0369: 						//referring to the table we are adding foreign key relation ship
1:eac0369: 
1:eac0369: 						getCurrentDeleteConnections(dd, fktd, -1, dConnHashtable, false, true);
1:eac0369: 
1:eac0369: 						/*
1:eac0369: 						**Find out if we introduced more than one delete connection
1:eac0369: 						**paths to the table that are referring the table we adding
1:eac0369: 						**the foreign key relatiosn ship.
1:eac0369: 						**If we have multiple paths they should have the same type
1:eac0369: 						**referential action and only one SET NULL path.
1:eac0369: 						**/
1:eac0369: 
1:71c8e86: 						for (Enumeration<String> e = dConnHashtable.keys() ; e.hasMoreElements() ;) 
1:eac0369: 						{
1:71c8e86: 							String tName = e.nextElement();
1:eac0369: 							//we should not check for the table name to which  we are
1:eac0369: 							//adding the foreign key relation ship.
1:eac0369: 							if(!tName.equals(addTableName))
1:eac0369: 							{
1:eac0369: 								if(newDconnHashTable.containsKey(tName))
1:eac0369: 								{
1:71c8e86: 									int currentDeleteRule = (dConnHashtable.get(tName)).intValue();
1:eac0369: 									if((currentDeleteRule == StatementType.RA_SETNULL
1:eac0369: 										&& raDeleteRuleToAddTable == StatementType.RA_SETNULL) ||
1:eac0369: 									   currentDeleteRule  != raDeleteRuleToAddTable)
1:eac0369: 									{
1:eac0369: 										throw
1:eac0369: 											generateError(SQLState.LANG_DELETE_RULE_CANT_BE_CASCADE_MPATH, 
1:eac0369: 														  myConstraintName);
1:eac0369: 									}
1:eac0369: 								}
1:eac0369: 							}
1:eac0369: 						}
1:eac0369: 					}
1:eac0369: 					//same hash table can be used for the other referring tables
1:eac0369: 					//so clear the hash table.
1:eac0369: 					dConnHashtable.clear();
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	
1:eac0369: 	private static StandardException generateError(String messageId, 
1:eac0369: 												   String myConstraintName)
1:eac0369: 	{
1:eac0369: 		String message = MessageService.getTextMessage(messageId);
1:eac0369: 		return StandardException.newException(SQLState.LANG_DELETE_RULE_VIOLATION, 
1:eac0369: 												myConstraintName, message);
1:eac0369: 	}	
1:eac0369: 
1:eac0369: 	private static StandardException generateError(String messageId, 
1:eac0369: 												   String myConstraintName, 
1:eac0369: 												   int raRule)
1:eac0369: 	{
1:eac0369: 		String raRuleStringId;
1:eac0369: 		switch (raRule){
1:eac0369: 		case StatementType.RA_CASCADE:
1:62d63f6: 			raRuleStringId = "CASCADE";
1:eac0369: 			break;
1:eac0369: 		case StatementType.RA_RESTRICT:
1:62d63f6: 			raRuleStringId = "RESTRICT";
1:eac0369: 				break;
1:eac0369: 		case StatementType.RA_SETNULL:
1:62d63f6: 			raRuleStringId = "SET NULL";
1:eac0369: 			break;
1:eac0369: 		case StatementType.RA_SETDEFAULT:
1:62d63f6: 			raRuleStringId = "SET DEFAULT";
1:eac0369: 			break;
1:62d63f6: 		case StatementType.RA_NOACTION:
1:eac0369: 		default: 
1:62d63f6: 			raRuleStringId = "NO ACTION";
1:62d63f6: 			break;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		String raRuleMessageString = MessageService.getTextMessage(raRuleStringId); 
1:eac0369: 		String message = MessageService.getTextMessage(messageId, raRuleMessageString);
1:eac0369: 		return StandardException.newException(SQLState.LANG_DELETE_RULE_VIOLATION, 
1:eac0369: 												myConstraintName, message);
1:eac0369: 	}	
1:eac0369: 
1:eac0369: 	private static StandardException generateError(String messageId, 
1:eac0369: 												   String myConstraintName,
1:eac0369: 												   String refTableName)
1:eac0369: 	{
1:eac0369: 
1:eac0369: 		String message = MessageService.getTextMessage(messageId, refTableName);
1:eac0369: 		return StandardException.newException(SQLState.LANG_DELETE_RULE_VIOLATION, 
1:eac0369: 												myConstraintName, message);
1:eac0369: 	}	
1:eac0369: 
1:eac0369: }
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:45da2f5
/////////////////////////////////////////////////////////////////////////
1:                     if (cd.deferrable()) {
1:                         final int onDelete = otherConstraintInfo.
1:                                 getReferentialActionDeleteRule();
1: 
1:                         if (onDelete == StatementType.RA_CASCADE ||
1:                             onDelete == StatementType.RA_SETNULL) {
1:                             // DERBY-532: Not yet implemented
1:                             throw StandardException.newException(
1:                                     SQLState.LANG_INVALID_FK_REF_KEY,
1:                                     myConstraintName,
1:                                     refTd.getQualifiedName());
1:                         }
1:                     }
commit:acd0d8b
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Finds the existing delete connection for the table and the referential
1:      * actions that will occur and stores the information in the hash table.
1:      * HashTable (key , value) = ( table name that this table is delete
1:      * connected to, referential action that will occur if there is a delete on
1:      * the table this table connected to [CASCADE, SET NULL, RESTRICT, NO
1:      * ACTION] )
1:      */
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * The following function validates whether the new foreign key relationship
1:      * violates any restriction on the referential actions. The current
1:      * refAction implementation does not allow cases where we can possible land
1:      * up having multiple action for the same row in a table. This could happen
1:      * because the user can possibly define different actions through multiple
1:      * foreign key paths.  The following function throws an error while creating
1:      * foreign keys if the new releationship leads to any such conditions.
1:      * NOTE: The SQL99 standard also does not clearly says what we are supposed
1:      * to do in these cases.  Our implementation just follows what is done in
1:      * DB2 and throws error messaged similar to DB2 (sql0632N, sql0633N,
1:      * sql0634N).
1:      */
commit:800a91d
/////////////////////////////////////////////////////////////////////////
1: 
1: 			/*
1: 			** There were no column names specified, just find
1: 			** the primary key on the table in question
1: 			*/
/////////////////////////////////////////////////////////////////////////
1: 		} 
1: 			/*
1: 			** Check the referenced columns vs. each unique or primary key to
1: 			** see if they match the foreign key.
1: 			*/
commit:801cf0d
/////////////////////////////////////////////////////////////////////////
1: import java.util.Hashtable;
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.services.i18n.MessageService;
1: import org.apache.derby.iapi.sql.StatementType;
/////////////////////////////////////////////////////////////////////////
1:         ReferencedKeyConstraintDescriptor refCd;
/////////////////////////////////////////////////////////////////////////
1:             String name = cdl.elementAt(index).getColumnName();
/////////////////////////////////////////////////////////////////////////
1:     @SuppressWarnings("UseOfObsoleteCollectionType")
/////////////////////////////////////////////////////////////////////////
1:     @SuppressWarnings("UseOfObsoleteCollectionType")
/////////////////////////////////////////////////////////////////////////
1:                     Integer rAction = dch.get(refTableName);
1: 
/////////////////////////////////////////////////////////////////////////
1:                     dch.put(refTableName, Integer.valueOf(childRefAction));
/////////////////////////////////////////////////////////////////////////
1:     @SuppressWarnings("UseOfObsoleteCollectionType")
/////////////////////////////////////////////////////////////////////////
1:             rAction = dch.get(refTableName);
/////////////////////////////////////////////////////////////////////////
1:                 if( isSelfReferencingFk &&
1:                     dch.contains(Integer.valueOf(StatementType.RA_CASCADE)) &&
1:                     refActionType !=  StatementType.RA_CASCADE)
/////////////////////////////////////////////////////////////////////////
1:                 rAction = ech.get(nextRefTableName);
/////////////////////////////////////////////////////////////////////////
1:                     rAction = dch.get(nextRefTableName);
1:                         if (multiPathCheck) {
1:                             dch.put(nextRefTableName,
1:                                     Integer.valueOf(refActionType));
1:                         }
1: 
/////////////////////////////////////////////////////////////////////////
1:     @SuppressWarnings("UseOfObsoleteCollectionType")
1:     private static void checkForAnyExistingDeleteConnectionViolations
/////////////////////////////////////////////////////////////////////////
1:         for (ConstraintDescriptor cd : dd.getConstraintDescriptors(td))
1:         {
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:54dce44
/////////////////////////////////////////////////////////////////////////
1: 			cycleString.append(refActionType);
/////////////////////////////////////////////////////////////////////////
1: 				cycleString.append(raDeleteRule);
commit:b3b16bf
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                                  deleteConnHashtable,
1:                                  new Hashtable<String, Integer>(deleteConnHashtable),
commit:c7a1d17
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		    String refTableName = refTd.getSchemaName() + "." + refTd.getName();
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:71c8e86
/////////////////////////////////////////////////////////////////////////
0:     @SuppressWarnings("unchecked")
/////////////////////////////////////////////////////////////////////////
1: 		Hashtable<String,Integer> deleteConnHashtable = new Hashtable<String,Integer>();
/////////////////////////////////////////////////////////////////////////
0: 								 deleteConnHashtable, (Hashtable<String,Integer>) deleteConnHashtable.clone(),
/////////////////////////////////////////////////////////////////////////
1: 	 Hashtable<String,Integer> dch,
/////////////////////////////////////////////////////////////////////////
1: 		Hashtable<String,Integer> dch,
1: 		Hashtable<String,Integer> ech,  //existing delete connections
/////////////////////////////////////////////////////////////////////////
1: 	 Hashtable<String,Integer> newDconnHashTable,
/////////////////////////////////////////////////////////////////////////
1: 				Hashtable<String,Integer> dConnHashtable = new Hashtable<String,Integer>();
/////////////////////////////////////////////////////////////////////////
1: 						for (Enumeration<String> e = dConnHashtable.keys() ; e.hasMoreElements() ;) 
1: 							String tName = e.nextElement();
1: 									int currentDeleteRule = (dConnHashtable.get(tName)).intValue();
commit:62d63f6
/////////////////////////////////////////////////////////////////////////
1: 			raRuleStringId = "CASCADE";
1: 			raRuleStringId = "RESTRICT";
1: 			raRuleStringId = "SET NULL";
1: 			raRuleStringId = "SET DEFAULT";
1: 		case StatementType.RA_NOACTION:
1: 			raRuleStringId = "NO ACTION";
1: 			break;
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:3fd26f3
/////////////////////////////////////////////////////////////////////////
1: 	**   foreign key fkey4, Derby also does the same.
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2e658c2
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:7ecc1f2
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.iapi.sql.dictionary.DDUtils
1: 
0:    Copyright 2000, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:5d24b1a
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.sql.dictionary
0:    (C) Copyright IBM Corp. 2000, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.iapi.sql.dictionary;
1: 
0: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.sql.StatementType;
0: import java.util.Hashtable;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.services.i18n.MessageService;
1: import java.util.Enumeration;
1: 
1: /**
1:  *	Static Data dictionary utilities.
1:  *
1:  * @version 0.1
0:  * @author Rick Hillegas
1:  */
1: 
1: public	class	DDUtils
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2000_2004;
1: 
1: 	/*
1: 	** For a foreign key, this is used to locate the referenced
1: 	** key using the ConstraintInfo.  If it doesn't find the
1: 	** correct constraint it will throw an error.
1: 	*/
1: 	public	static ReferencedKeyConstraintDescriptor locateReferencedConstraint
1: 	(
1: 		DataDictionary	dd,
1: 		TableDescriptor	td,
1: 		String			myConstraintName,	// for error messages
1: 		String[]		myColumnNames,
1: 		ConsInfo		otherConstraintInfo
1: 	)
1: 		throws StandardException
1: 	{
1: 		TableDescriptor refTd = otherConstraintInfo.getReferencedTableDescriptor(dd);
1: 		if (refTd == null)
1: 		{
1: 				throw StandardException.newException(SQLState.LANG_INVALID_FK_NO_REF_TAB, 
1: 												myConstraintName, 
1: 												otherConstraintInfo.getReferencedTableName());
1: 		}
1: 
1: 
0: 		ReferencedKeyConstraintDescriptor refCd = null;
1: 
1: 		/*
0: 		** There were no column names specified, just find
0: 		** the primary key on the table in question
1: 		*/
1: 		String[]	refColumnNames = otherConstraintInfo.getReferencedColumnNames();
1: 		if (refColumnNames == null ||
1: 			refColumnNames.length == 0)
1: 		{
1: 			refCd = refTd.getPrimaryKey();
1: 			if (refCd == null)
1: 			{
1: 				throw StandardException.newException(SQLState.LANG_INVALID_FK_NO_PK, 
1: 												myConstraintName, 
1: 												refTd.getQualifiedName());
1: 			}
1: 
1: 			ColumnDescriptorList cdl = getColumnDescriptors(dd, td, myColumnNames);
1: 
1: 			/*
1: 			** Check the column list length to give a more informative
1: 			** error in case they aren't the same.
1: 			*/
1: 			if (cdl.size() != refCd.getColumnDescriptors().size())
1: 			{
1: 				throw StandardException.newException(SQLState.LANG_INVALID_FK_DIFFERENT_COL_COUNT, 
1: 												myConstraintName, String.valueOf(cdl.size()), 
1: 												String.valueOf(refCd.getColumnDescriptors().size())); 
1: 			}
1: 	
1: 			/*
1: 			** Make sure all types are the same.
1: 			*/	
1: 			if (!refCd.areColumnsComparable(cdl))
1: 			{
1: 				throw StandardException.newException(SQLState.LANG_INVALID_FK_COL_TYPES_DO_NOT_MATCH, 
1: 												myConstraintName);
1: 			}
1: 
1: 			return refCd;	
1: 		}
1: 
1: 		/*
0: 		** Check the referenced columns vs. each unique or primary key to
0: 		** see if they match the foreign key.
1: 		*/
1: 		else
1: 		{
1: 			ConstraintDescriptor cd;
1: 
1: 			ColumnDescriptorList colDl = getColumnDescriptors(dd, td, myColumnNames);
1: 			ConstraintDescriptorList refCDL = dd.getConstraintDescriptors(refTd);
1: 
1: 			int refCDLSize = refCDL.size();
1: 			for (int index = 0; index < refCDLSize; index++)
1: 			{
1: 				cd = refCDL.elementAt(index);
1: 
1: 				/*
1: 				** Matches if it is not a check or fk, and
1: 				** all the types line up.
1: 				*/
1: 				if ((cd instanceof ReferencedKeyConstraintDescriptor) &&
1: 					 cd.areColumnsComparable(colDl) &&
1: 					 columnNamesMatch(refColumnNames, 
1: 										cd.getColumnDescriptors()))
1: 				{
1: 					return (ReferencedKeyConstraintDescriptor)cd;
1: 				}
1: 			}
1: 
1: 			/*
1: 			** If we got here, we didn't find anything
1: 			*/
1: 			throw StandardException.newException(SQLState.LANG_INVALID_FK_NO_REF_KEY, myConstraintName, 
1: 														refTd.getQualifiedName());
1: 		}
1: 	}
1: 
1:     public	static ColumnDescriptorList getColumnDescriptors
1: 	(
1: 		DataDictionary	dd,
1: 		TableDescriptor td,
1: 		String[] 		columnNames
1: 	)
1: 		throws StandardException
1: 	{
1: 		ColumnDescriptorList cdl = new ColumnDescriptorList();
1: 		for (int colCtr = 0; colCtr < columnNames.length; colCtr++)
1: 		{
1: 			ColumnDescriptor cd = td.getColumnDescriptor(columnNames[colCtr]);
1: 			cdl.add(td.getUUID(), cd);
1: 		}
1: 		return cdl;
1: 	}
1: 
1: 	public	static boolean columnNamesMatch(String []columnNames, ColumnDescriptorList cdl)
1: 		throws StandardException
1: 	{
1: 		if (columnNames.length != cdl.size())
1: 		{
1: 			return false;
1: 		}
1: 		
0: 		String name;
1: 		for (int index = 0; index < columnNames.length; index++)
1: 		{
0: 			name = ((ColumnDescriptor) cdl.elementAt(index)).getColumnName();
1: 			if (!name.equals(columnNames[index]))
1: 			{
1: 				return false;
1: 			}
1: 		}
1: 
1: 		return true;
1: 	}
1: 
1: 
1: 	/*
1: 	**checks whether the foreign key relation ships referential action
1: 	**is violating the restrictions we have in the current system.
1: 	**/
1: 	public static void validateReferentialActions
1:     (
1: 		DataDictionary	dd,
1: 		TableDescriptor	td,
1: 		String			myConstraintName,	// for error messages
1: 		ConsInfo		otherConstraintInfo,
1: 		String[]        columnNames
1: 	)
1: 		throws StandardException
1: 	{
1: 
1: 
1: 		int refAction = otherConstraintInfo.getReferentialActionDeleteRule();
1: 
1: 		//Do not allow ON DELETE SET NULL as a referential action 
1: 		//if none of the foreign key columns are  nullable.
1: 		if(refAction == StatementType.RA_SETNULL)
1: 		{
1: 			boolean foundNullableColumn = false;
1: 			//check if we have a nullable foreign key column
1: 			for (int colCtr = 0; colCtr < columnNames.length; colCtr++)
1: 			{
1: 				ColumnDescriptor cd = td.getColumnDescriptor(columnNames[colCtr]);
1: 				if ((cd.getType().isNullable()))
1: 				{
1: 					foundNullableColumn = true;
1: 					break;
1: 				}
1: 			}
1: 
1: 			if(!foundNullableColumn)
1: 			{
1: 				throw StandardException.newException(SQLState.LANG_INVALID_FK_COL_FOR_SETNULL, 
1: 													 myConstraintName);
1: 			}
1: 		}
1: 
1: 		//check whether the foreign key relation ships referential action
1: 		//is not violating the restrictions we have in the current system.
1: 		TableDescriptor refTd = otherConstraintInfo.getReferencedTableDescriptor(dd);
0: 		Hashtable deleteConnHashtable = new Hashtable();
1: 		//find whether the foreign key is self referencing.
1: 		boolean isSelfReferencingFk = (refTd.getUUID().equals(td.getUUID()));
1: 		String refTableName = refTd.getSchemaName() + "." + refTd.getName();
1: 		//look for the other foreign key constraints on this table first
1: 		int currentSelfRefValue = getCurrentDeleteConnections(dd, td, -1, deleteConnHashtable, false, true);
1: 		validateDeleteConnection(dd, td, refTd, 
1: 								 refAction, 
0: 								 deleteConnHashtable, (Hashtable) deleteConnHashtable.clone(),
1: 								 true, myConstraintName, false , 
1: 								 new StringBuffer(0), refTableName,
1: 								 isSelfReferencingFk,
1: 								 currentSelfRefValue);
1: 
1: 		//if it not a selfreferencing key check for violation of exiting connections.
1: 		if(!isSelfReferencingFk)
1: 		{
1: 			checkForAnyExistingDeleteConnectionViolations(dd, td,
1: 														  refAction, 
1: 														  deleteConnHashtable, 
1: 														  myConstraintName);
1: 		}	
1: 	}
1: 
1: 	/*
0: 	** Finds the existing delete connection for the table and the referential
0: 	** actions that will occur  and stores the information in the hash table.
0: 	** HashTable (key , value) = ( table name that this table is delete
0: 	** connected to, referential action that will occur if there is a delete on
0: 	** the table this table connected to[CASACDE, SETNULL , RESTRICT ...etc).)
1: 	**/
1: 
1: 	private	static int  getCurrentDeleteConnections
1: 	(
1: 	 DataDictionary	dd,
1: 	 TableDescriptor	td,
1: 	 int refActionType,
0: 	 Hashtable dch,
1: 	 boolean prevNotCascade,
1: 	 boolean findSelfRef
1: 	 )
1: 		throws StandardException
1: 	{
1: 
1: 		int selfRefValue = -1; //store the self reference referential action 
1: 
1: 		//make sure we get any foreign key constraints added earlier in the same statement.
1: 		td.emptyConstraintDescriptorList();
1: 		ConstraintDescriptorList cdl = dd.getConstraintDescriptors(td);
1: 		int cdlSize = cdl.size();
1: 
1: 		boolean passedInPrevNotCascade = prevNotCascade;
1: 		for (int index = 0; index < cdlSize; index++)
1: 		{
1: 				ConstraintDescriptor cd = cdl.elementAt(index);
1: 
1: 				//look for  foreign keys
1: 				if ((cd instanceof ForeignKeyConstraintDescriptor))
1: 				{
1: 					ForeignKeyConstraintDescriptor fkcd = (ForeignKeyConstraintDescriptor) cd;
1: 					String constraintName = fkcd.getConstraintName();
1: 					int raDeleteRule = fkcd.getRaDeleteRule();
1: 					int raUpdateRule = fkcd.getRaUpdateRule();
1: 
1: 					 if(findSelfRef && fkcd.isSelfReferencingFK())
1: 					 {
1: 						 //All self references will have same  referential actions type
1: 						 selfRefValue = raDeleteRule;
1: 						 findSelfRef = false;
1: 					 }
1: 
1: 					ReferencedKeyConstraintDescriptor refcd =
1: 						fkcd.getReferencedConstraint(); 
1: 					TableDescriptor refTd = refcd.getTableDescriptor();
1: 					int childRefAction = refActionType == -1 ? raDeleteRule : refActionType;
1: 				   
1: 					String refTableName = refTd.getSchemaName() + "." + refTd.getName();
1: 					//check with  the existing references.
0: 					Integer rAction = ((Integer)dch.get(refTableName));
1: 					if(rAction != null) // we already looked at this table
1: 					{
1: 						prevNotCascade = passedInPrevNotCascade;
1: 						continue;
1: 					}
1: 
1: 					//if we are not cascading, check whether the link before
1: 					//this was cascade or not. If we travel through  two NON CASCADE ACTION
1: 					//links then the  delete connection is broken(only a delete can have further
1: 					// referential effects)
1: 					if(raDeleteRule != StatementType.RA_CASCADE)
1: 					{
1: 						if(prevNotCascade)
1: 						{
1: 							prevNotCascade = passedInPrevNotCascade;
1: 							continue;
1: 						}
1: 						else
1: 							prevNotCascade = true;
1: 					}
1: 
1: 					//store the delete connection info in the hash table,
1: 					//note that the referential action value is not what is
1: 					//not specified on the current link. It is actually the 
1: 					//value of what happens to the table whose delete
1: 					// connections we are finding.
0: 					dch.put(refTableName, (new Integer(childRefAction)));
1: 					
1: 					//find the next delete conectiions on this path for non
1: 					//self referencig delete connections.
1: 					if(!fkcd.isSelfReferencingFK())
1: 						getCurrentDeleteConnections(dd , refTd, childRefAction,
1: 													dch, true, false);
1: 					prevNotCascade = passedInPrevNotCascade;
1: 				}
1: 		}
1: 		
1: 		return selfRefValue;
1: 	}
1: 
1: 
1: 	/*
0: 	** Following function validates whether the new foreign key relation ship
0: 	** violates any restriction on the referential actions. Current refAction
0: 	** implementation does not allow cases where we can possible land up
0: 	** having multiple action for the same row in a table, this happens becase
0: 	** user can possibly define differential action through multiple paths.
0: 	** Following function throws error while creating foreign keys if the new
0: 	** releations ship leads to any such conditions.
0: 	** NOTE : SQL99 standard also does not cleary says what we are suppose to do
0: 	** in these non determenistic cases. 
0: 	** Our implementation just follows what is did in DB2 and throws error
0: 	** messaged similar to DB2 (sql0632N, sql0633N, sql0634N)
1: 	*/
1: 
1: 	private	static void validateDeleteConnection
1: 	(
1: 		DataDictionary	dd,
1: 		TableDescriptor actualTd,  // the table we are adding the foriegn key.
1: 		TableDescriptor	refTd,
1: 		int refActionType,
0: 		Hashtable dch,
0: 		Hashtable ech,  //existing delete connections
1: 		boolean checkImmediateRefTable,
1: 		String myConstraintName,
1: 		boolean prevNotCascade,
1: 		StringBuffer cycleString, 
1: 		String currentRefTableName, //the name of the table we are referring too.
1: 		boolean isSelfReferencingFk,
1: 		int currentSelfRefValue
1: 		)
1: 		throws StandardException
1: 	{
1: 
1: 		Integer rAction;
1: 
1: 		String refTableName = refTd.getSchemaName() + "." + refTd.getName();
1: 
1: 
1: 		/*
1: 		** Validate the new referentail action value with respect to the 
1: 		** already existing connections to this table we gathered  from
1: 		** the getCurrentDeleteConnections() call.
1: 		*/
1: 
1: 		if(checkImmediateRefTable)
1: 		{
0: 			rAction = ((Integer)dch.get(refTableName));
1: 			
1: 			// check possible invalide cases incase of self referencing foreign key
1: 			if(isSelfReferencingFk)
1: 			{
1: 				//All the relation ship referring to a table should have the
1: 				//same refaction except incase of SET NULL. In this case
1: 				//it is the same table , so we have to check with existing self
1: 				//referencing actions.
1: 				if(currentSelfRefValue !=  -1)
1: 				{
1: 					if(currentSelfRefValue != refActionType)
1: 					{
1: 						//If there is a SET NULL relation ship we can not have any
1: 						// other relation ship with it.
1: 						if(currentSelfRefValue == StatementType.RA_SETNULL)
1: 							throw
1: 								generateError(SQLState.LANG_CANT_BE_DEPENDENT_ESELF, 
1: 										  myConstraintName, currentRefTableName);
1: 						else
1: 						{
1: 								/*
1: 								** case where we can cleary say what the
1: 								** referential actions should be. Like,	   
1: 								** if there is NO ACTION relationsip
1: 								**already, new relation ship also shold be NO ACTION. 
1: 								*/
1: 							throw
1: 								generateError(SQLState.LANG_DELETE_RULE_MUSTBE_ESELF,
1: 											  myConstraintName, currentSelfRefValue);
1: 						}
1: 					}else
1: 					{
1: 						//more than one  ON DELET SET NULL to the same table is not allowed
1: 						if(currentSelfRefValue == StatementType.RA_SETNULL &&
1: 						   refActionType == StatementType.RA_SETNULL)
1: 						{
1: 							throw
1: 								generateError(SQLState.LANG_CANT_BE_DEPENDENT_ESELF,
1: 											  myConstraintName, currentRefTableName);
1: 						}
1: 					}
1: 				}
1: 
1: 				/*
1: 				** If the new releation ship is self referencing and if
1: 				** the current existing relation ship to other tables is
1: 				** CASCADE type them  new self reference should be of type
1: 				** CASCADE, otherwise we should throw error.
1: 				*/
1: 
0: 				if(isSelfReferencingFk && dch.contains(new Integer(StatementType.RA_CASCADE)) && 
0: 				   refActionType!=  StatementType.RA_CASCADE)
1: 				{
1: 					throw
1: 						generateError(SQLState.LANG_DELETE_RULE_MUSTBE_ECASCADE,
1: 									  myConstraintName,StatementType.RA_CASCADE);	
1: 				}
1: 
1: 				//end of possible error case scenarios for self reference key additions
1: 				return;
1: 			}
1: 		
1: 			//cases where the new  reference is referring to  another table
1: 
1: 			//check whether it matched with existing self references.
1: 			// If A self-referencing constraint exists with a delete rule of
1: 			// SET NULL,  NO ACTION or RESTRICT. We can not add CASCADE
1: 			// relationship with another table.
1: 				
1: 			if(currentSelfRefValue !=  -1)
1: 			{
1: 				if(refActionType == StatementType.RA_CASCADE && 
1: 				   currentSelfRefValue != StatementType.RA_CASCADE) 
1: 				{
1: 					throw generateError(SQLState.LANG_DELETE_RULE_CANT_BE_CASCADE_ESELF,  myConstraintName);
1: 					
1: 				}
1: 
1: 			}
1: 
1: 			
1: 			//check for the cases with existing relationships to the
1: 			//referenced table
1: 			if(rAction != null)
1: 			{
1: 				checkForMultiplePathInvalidCases(rAction.intValue(),
1: 												  refActionType,
1: 												  myConstraintName,currentRefTableName);
1: 			}
1: 
1: 			
1: 			//mark the current connect to the reference table to identify the cycle.
1: 			if(refActionType != StatementType.RA_CASCADE)
1: 			{
1: 				prevNotCascade = true;
1: 			}
1: 			
1: 			/*
1: 			** cycle string is used to keep track of the referential actions of 
1: 			** the nodes we visited, this is required to make sure that in case
1: 			** of cycles , all the nodes in the cycle have same type of
1: 			** referential action.
1: 			**/
0: 			cycleString = cycleString.append(refActionType);
1: 		}
1: 
1: 
1: 		boolean passedInPrevNotCascade = prevNotCascade;
1: 
1: 		//delete connection is broken for if we see ON DELET SET NULL link
1: 		// one level deeper than the table we are adding the foreing key
1: 		//Where as to check for cycles we need to go for more level also;
1:         // To check cases like CASCADE CASCADE SET NULL cycle is not valid. 
1: 		//Following variable is used make the distinction.
1: 		boolean multiPathCheck = true;
1: 
1: 		// check for cases where the new connection we are forming to the 
1: 		// reference table could create invalid any cycles or mutiple paths 
1: 		// with the delete-connections the  referencing table might have already.
1: 		ConstraintDescriptorList refCDL = dd.getConstraintDescriptors(refTd);
1: 		int refCDLSize = refCDL.size();
1: 		for (int index = 0; index < refCDLSize; index++)
1: 		{
1: 			ConstraintDescriptor cd = refCDL.elementAt(index);
1: 
1: 			if ((cd instanceof ForeignKeyConstraintDescriptor))
1: 			{
1: 				ForeignKeyConstraintDescriptor fkcd = (ForeignKeyConstraintDescriptor) cd;
1: 				String constraintName = fkcd.getConstraintName();
1: 				int raDeleteRule = fkcd.getRaDeleteRule();
1: 				int raUpdateRule = fkcd.getRaUpdateRule();
1: 				
1: 				ReferencedKeyConstraintDescriptor refcd =
1: 					fkcd.getReferencedConstraint(); 
1: 				TableDescriptor nextRefTd = refcd.getTableDescriptor();
1: 
1: 				//if we are not cascading, check  whether the link before
1: 				//this was cascade or not. If we travel through  two NON CASCADE ACTION
1: 				//links then the delete connection is broken(only a delete can have further
1: 				//referential effects)
1: 				if(raDeleteRule != StatementType.RA_CASCADE)
1: 				{
1: 					if(prevNotCascade)
1: 					{
1: 						prevNotCascade = passedInPrevNotCascade;
1: 						continue;
1: 					}
1: 					else
1: 					{
1: 						prevNotCascade = true;
1: 						multiPathCheck = false;
1: 					}
1: 
1: 				}
1: 
1: 				//check whether the current link is a self referencing one
1: 				boolean isSelfRefLink = fkcd.isSelfReferencingFK();
1: 				
1: 				//check for this is non self referencing cycles case
1: 				//In cases of cycle, whole cycle should have the same refAction
1: 				// value. Other wise we should throw an exception
0: 				cycleString = cycleString.append(raDeleteRule);
1: 				boolean isFormingCycle = (nextRefTd.getUUID().equals(actualTd.getUUID()));
1: 				if(isFormingCycle)
1: 				{
1: 					//make sure that all the nodes in the cycle have the same
1: 					//referential action  value, otherwise we should throw an error. 
1: 					for(int i = 0 ; i < cycleString.length(); i++)
1: 					{
1: 						int otherRefAction = Character.getNumericValue(cycleString.charAt(i));
1: 						if(otherRefAction != refActionType)
1: 						{
1: 							//cases where one of the existing relation ships in
1: 							//the cycle is not cascade , so we can not have
1: 							// cascade relation ship.
1: 							if(otherRefAction != StatementType.RA_CASCADE)
1: 							{
1: 								throw generateError(SQLState.LANG_DELETE_RULE_CANT_BE_CASCADE_ECYCLE, myConstraintName);
1: 							}
1: 							else
1: 							{
1: 								//possibly all the other nodes in the cycle has
1: 								//cascade relationsship , we can not add a non
1: 								//cascade relation ship.
1: 								throw
1: 									generateError(SQLState.LANG_CANT_BE_DEPENDENT_ECYCLE, 
1: 												  myConstraintName, currentRefTableName);
1: 							}
1: 						}
1: 					}
1: 				}	
1: 
1: 
1: 				
1: 
1: 				String nextRefTableName =  nextRefTd.getSchemaName() + "." + nextRefTd.getName();
0: 				rAction = ((Integer)ech.get(nextRefTableName));
1: 				if(rAction != null)
1: 				{
1: 					/*
1: 					** If the table name has entry in the hash table means, there
1: 					** is already  a path to this table exists from the table
1: 					** the new foreign key relation ship is being formed.
1: 					** Note: refValue in the hash table is how the table we are
1: 					** adding the new relationsship is going to affected not
1: 					** current path refvalue.
1: 					**/
1: 					if(!isSelfRefLink && multiPathCheck)
1: 						checkForMultiplePathInvalidCases(rAction.intValue(),
1: 														 refActionType, 
1: 														 myConstraintName,currentRefTableName);
1: 
1: 				}else
1: 				{
0: 					rAction = ((Integer)dch.get(nextRefTableName));
1: 					if(rAction == null)
1: 					{
0: 						if(multiPathCheck)
0: 							dch.put(nextRefTableName, (new Integer(refActionType)));
1: 						if(!isSelfRefLink)
1: 						{
1: 							validateDeleteConnection(dd, actualTd,  nextRefTd,
1: 												 refActionType, dch, ech, false,
1: 												 myConstraintName,prevNotCascade,
1: 												 cycleString, currentRefTableName, 
1: 												 isSelfReferencingFk, currentSelfRefValue); 
1: 						}
1: 					}
1: 				}
1: 				prevNotCascade = passedInPrevNotCascade;
1: 				//removes the char added for the current call
1: 				cycleString.setLength(cycleString.length() -1);
1: 				
1: 			}
1: 		}
1: 	}
1: 
1: 
1: 	/*
1: 	**Check whether the mulitple path case is valid or not following
1: 	** cases are invalid:
1: 	** case 1: The relationship causes the table to be delete-connected to
1: 	** the indicated table through multiple relationships and the
1: 	** delete rule of the existing relationship is SET NULL. 
1: 	** case 2: The relationship would cause the table to be
1: 	** delete-connected to the same table through multiple
1: 	** relationships and such relationships must have the same 
1: 	** delete rule (NO ACTION, RESTRICT or CASCADE). 
1: 	** case 3: The relationship would cause another table to be
1: 	** delete-connected to the same table through multiple paths
1: 	** with different delete rules or with delete rule equal to SET NULL. 
1: 	**/
1: 
1: 	private static void checkForMultiplePathInvalidCases(int currentRefAction,
1: 														  int refActionType,
1: 														  String myConstraintName,
1: 														  String currentRefTableName)
1: 		throws StandardException
1: 	{
1: 
1: 		//All the relation ship referring to a table should have the
1: 		//same refaction except incase of SET NULL
1: 		if(currentRefAction != refActionType)
1: 		{
1: 
1: 			//If there is a SET NULL relation ship we can not have any
1: 			// other relation ship with it.
1: 			if(currentRefAction == StatementType.RA_SETNULL)
1: 				throw generateError(SQLState.LANG_CANT_BE_DEPENDENT_MPATH,
1: 									myConstraintName, currentRefTableName);
1: 			else
1: 				//This error say what the delete rule must be for the
1: 				// foreign key be valid 
1: 				throw generateError(SQLState.LANG_DELETE_RULE_MUSTBE_MPATH,
1: 									myConstraintName, currentRefAction);
1: 
1: 		}else
1: 		{
1: 			//more than one  ON DELET SET NULL to the same table is not allowed
1: 			if(currentRefAction == StatementType.RA_SETNULL &&
1: 			   refActionType == StatementType.RA_SETNULL)
1: 			{
1: 				throw		
1: 					generateError(SQLState.LANG_CANT_BE_DEPENDENT_MPATH,
1: 								  myConstraintName, currentRefTableName);
1: 			}
1: 		}
1: 	}
1: 
1: 
1: 
1:     /*
1: 	** Check whether the delete rule of FOREIGN KEY  must not be CASCADE because
1: 	** the  new relationship would cause another table to be delete-connected to
1: 	** the same table through multiple paths with different delete rules or with 
1: 	** delete rule equal to SET NULL. 
1: 	**
1: 	** For example :
1: 	**                      t1
1:     **  		 CASCADE   /  \  CASCADE
1:     **                    /    \ 
1: 	**                  t2      t3
1:     **                   \      /   
1:     **          SET NULL  \    /  CASCADE (Can we add this one ? NO)
1:  	**			          \   /
1: 	                       \t4/
1: 	**					
1:     **   existing links:
1: 	**   t2 references t1   ON DELETE CASCADE  (fkey1)
1: 	**   t3 references t1   ON DELETE CASCADE  (fkey2)
1: 	**   t2 reference  t4   ON DELETE SET NULL (fkey3)
1: 	**   Now if if try to add a new link i.e
1: 	**   t4 references t3   ON DELETE SET NULL  (fkey4)
1: 	**   Say if we add it,  then if we execute 'delete from t1' 
1: 	**   Because of referential actions , we will try to delete a row through
1: 	**   one path and tries to update  through another path. 
1: 	**   Nothing in standard that say whether we are suppose to delete the row
1: 	**   or update the row.  DB2UDB raises error when we try to create the
0: 	**   foreign key fkey4, cloudscape also does the same.
1: 	** 
1: 	**   How we catch the error case ?
1: 	**   Point to note here is the table(t4) we are  adding the foreign key does
1: 	**   not have a problem in this scenarion because we are adding a
1:     **   a CASACDE link , some other table(t2) that is referring  
1: 	**   can get multiple referential action paths. We can not
1: 	**   this error case for self referencing links.
1: 	**   Algorithm:
1: 	**   -Gather the foreign keys that are
1: 	**   referring(ReferencedKeyConstraintDescriptor) to the table we are adding
1: 	**   foreign key, in our example case we get (fkey3 - table t2 -t4 link)
1: 	**   for each ReferencedKeyConstraintDescriptor
1: 	**   {
1: 	**    1)find the delete connections of the referring table.
1: 	**    [getCurrentDeleteConnections() will return this hash table]
1: 	**	  2) we already have collected the Delete connections 
1:     **       in validDeleteConnections() for the actual table we are adding the 
1:     **       foreign key.
1: 	**    3) Now check whether the referring table  is also 
1:     **       referring  any table that the table we are adding
1:     **       foreign key has delete connection.
1: 	**
1: 	**     for each table referring table delete connection hash table
1: 	**     {
1: 	**      if it is there in the actual table delete connection hash table
1:     **      {
1: 	**         //In our example case we find t1 in both the hash tables.
1: 	**         make sure we are having valid referential action
1:     **         from the existing path and the new path we got from 
1: 	**         new foreign key relation ship.
1: 	**        //In our example case t2 has CASCADE relations with t1
1: 	**        //Because of new foreign key added we also get 
1: 	**        //SET NULL relation ship with t1. This is not valid
1: 	**        //so we should throw error.
1:     **      }  
1: 	**     }
1: 	** }	
1: 	**/
1: 
1: 
0: 	private static void checkForAnyExistingDeleteConnectionViolations
1: 	(
1: 	 DataDictionary	dd,
1: 	 TableDescriptor td,
1: 	 int refActionType,
0: 	 Hashtable newDconnHashTable,
1: 	 String myConstraintName
1: 	 )
1: 	throws StandardException
1: 	{
1: 
1: 		//We need to check for the condition in this function only when we are
1: 		//adding ref action of type CASCADE
1: 		if(refActionType != StatementType.RA_CASCADE)
1: 			return;
1: 		
1: 		//find the tables that are referring to the table we 
1: 		//are adding the foreign key and check whether we violate their existing rules.
1: 		String addTableName = td.getSchemaName() + "." + td.getName();;
0: 		ConstraintDescriptorList refCDL = dd.getConstraintDescriptors(td);
1: 		int refCDLSize = refCDL.size();
1: 		for (int index = 0; index < refCDLSize; index++)
1: 		{
1: 			ConstraintDescriptor cd = refCDL.elementAt(index);
1: 
1: 			if ((cd instanceof ReferencedKeyConstraintDescriptor))
1: 			{
1: 				ConstraintDescriptorList fkcdl = dd.getActiveConstraintDescriptors
1: 					( ((ReferencedKeyConstraintDescriptor)cd).getForeignKeyConstraints(ConstraintDescriptor.ALL));
1: 	
1: 				int size = fkcdl.size();
1: 				if (size == 0) 
1: 				{ 
1: 					continue; 
1: 				}
1: 				
1: 				//Note: More than one table can refer to the same
1: 				//ReferencedKeyConstraintDescriptor, so we need to find all the tables.
0: 				Hashtable dConnHashtable = new Hashtable();
1: 				for (int inner = 0; inner < size; inner++)
1: 				{
1: 					ForeignKeyConstraintDescriptor fkcd = (ForeignKeyConstraintDescriptor) fkcdl.elementAt(inner);
1: 					TableDescriptor fktd = fkcd.getTableDescriptor();
1: 					//Delete rule that we have to the table we are adding the
1: 					// foreign key relation shop
1: 					int raDeleteRuleToAddTable = fkcd.getRaDeleteRule();
1: 
1: 					//This check should not be done on self referencing references.
1: 					if(!fkcd.isSelfReferencingFK())
1: 					{
1: 
1: 						//gather the delete connections of the table that is
1: 						//referring to the table we are adding foreign key relation ship
1: 
1: 						getCurrentDeleteConnections(dd, fktd, -1, dConnHashtable, false, true);
1: 
1: 						/*
1: 						**Find out if we introduced more than one delete connection
1: 						**paths to the table that are referring the table we adding
1: 						**the foreign key relatiosn ship.
1: 						**If we have multiple paths they should have the same type
1: 						**referential action and only one SET NULL path.
1: 						**/
1: 
0: 						for (Enumeration e = dConnHashtable.keys() ; e.hasMoreElements() ;) 
1: 						{
0: 							String tName = (String) e.nextElement();
1: 							//we should not check for the table name to which  we are
1: 							//adding the foreign key relation ship.
1: 							if(!tName.equals(addTableName))
1: 							{
1: 								if(newDconnHashTable.containsKey(tName))
1: 								{
0: 									int currentDeleteRule = ((Integer)	dConnHashtable.get(tName)).intValue();
1: 									if((currentDeleteRule == StatementType.RA_SETNULL
1: 										&& raDeleteRuleToAddTable == StatementType.RA_SETNULL) ||
1: 									   currentDeleteRule  != raDeleteRuleToAddTable)
1: 									{
1: 										throw
1: 											generateError(SQLState.LANG_DELETE_RULE_CANT_BE_CASCADE_MPATH, 
1: 														  myConstraintName);
1: 									}
1: 								}
1: 							}
1: 						}
1: 					}
1: 					//same hash table can be used for the other referring tables
1: 					//so clear the hash table.
1: 					dConnHashtable.clear();
1: 				}
1: 			}
1: 		}
1: 	}
1: 
1: 
1: 	
1: 	private static StandardException generateError(String messageId, 
1: 												   String myConstraintName)
1: 	{
1: 		String message = MessageService.getTextMessage(messageId);
1: 		return StandardException.newException(SQLState.LANG_DELETE_RULE_VIOLATION, 
1: 												myConstraintName, message);
1: 	}	
1: 
1: 	private static StandardException generateError(String messageId, 
1: 												   String myConstraintName, 
1: 												   int raRule)
1: 	{
1: 		String raRuleStringId;
1: 		switch (raRule){
1: 		case StatementType.RA_CASCADE:
0: 			raRuleStringId = SQLState.LANG_DELETE_RULE_CASCADE;
1: 			break;
1: 		case StatementType.RA_RESTRICT:
0: 			raRuleStringId = SQLState.LANG_DELETE_RULE_RESTRICT;
1: 				break;
0: 		case StatementType.RA_NOACTION:
0: 			raRuleStringId = SQLState.LANG_DELETE_RULE_NOACTION;
1: 			break;
1: 		case StatementType.RA_SETNULL:
0: 			raRuleStringId = SQLState.LANG_DELETE_RULE_SETNULL;
1: 			break;
1: 		case StatementType.RA_SETDEFAULT:
0: 			raRuleStringId = SQLState.LANG_DELETE_RULE_SETDEFAULT;
1: 			break;
1: 		default: 
0: 			raRuleStringId =SQLState.LANG_DELETE_RULE_NOACTION ; // NO ACTION (default value)
1: 		}
1: 
1: 		String raRuleMessageString = MessageService.getTextMessage(raRuleStringId); 
1: 		String message = MessageService.getTextMessage(messageId, raRuleMessageString);
1: 		return StandardException.newException(SQLState.LANG_DELETE_RULE_VIOLATION, 
1: 												myConstraintName, message);
1: 	}	
1: 
1: 	private static StandardException generateError(String messageId, 
1: 												   String myConstraintName,
1: 												   String refTableName)
1: 	{
1: 
1: 		String message = MessageService.getTextMessage(messageId, refTableName);
1: 		return StandardException.newException(SQLState.LANG_DELETE_RULE_VIOLATION, 
1: 												myConstraintName, message);
1: 	}	
1: 
1: }
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.sql.dictionary
0:    (C) Copyright IBM Corp. 2000, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.iapi.sql.dictionary;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.sql.StatementType;
0: import java.util.Hashtable;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.services.i18n.MessageService;
0: import java.util.Enumeration;
0: 
0: /**
0:  *	Static Data dictionary utilities.
0:  *
0:  * @version 0.1
0:  * @author Rick Hillegas
0:  */
0: 
0: public	class	DDUtils
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2000_2004;
0: 
0: 	/*
0: 	** For a foreign key, this is used to locate the referenced
0: 	** key using the ConstraintInfo.  If it doesn't find the
0: 	** correct constraint it will throw an error.
0: 	*/
0: 	public	static ReferencedKeyConstraintDescriptor locateReferencedConstraint
0: 	(
0: 		DataDictionary	dd,
0: 		TableDescriptor	td,
0: 		String			myConstraintName,	// for error messages
0: 		String[]		myColumnNames,
0: 		ConsInfo		otherConstraintInfo
0: 	)
0: 		throws StandardException
0: 	{
0: 		TableDescriptor refTd = otherConstraintInfo.getReferencedTableDescriptor(dd);
0: 		if (refTd == null)
0: 		{
0: 				throw StandardException.newException(SQLState.LANG_INVALID_FK_NO_REF_TAB, 
0: 												myConstraintName, 
0: 												otherConstraintInfo.getReferencedTableName());
0: 		}
0: 
0: 
0: 		ReferencedKeyConstraintDescriptor refCd = null;
0: 
0: 		/*
0: 		** There were no column names specified, just find
0: 		** the primary key on the table in question
0: 		*/
0: 		String[]	refColumnNames = otherConstraintInfo.getReferencedColumnNames();
0: 		if (refColumnNames == null ||
0: 			refColumnNames.length == 0)
0: 		{
0: 			refCd = refTd.getPrimaryKey();
0: 			if (refCd == null)
0: 			{
0: 				throw StandardException.newException(SQLState.LANG_INVALID_FK_NO_PK, 
0: 												myConstraintName, 
0: 												refTd.getQualifiedName());
0: 			}
0: 
0: 			ColumnDescriptorList cdl = getColumnDescriptors(dd, td, myColumnNames);
0: 
0: 			/*
0: 			** Check the column list length to give a more informative
0: 			** error in case they aren't the same.
0: 			*/
0: 			if (cdl.size() != refCd.getColumnDescriptors().size())
0: 			{
0: 				throw StandardException.newException(SQLState.LANG_INVALID_FK_DIFFERENT_COL_COUNT, 
0: 												myConstraintName, String.valueOf(cdl.size()), 
0: 												String.valueOf(refCd.getColumnDescriptors().size())); 
0: 			}
0: 	
0: 			/*
0: 			** Make sure all types are the same.
0: 			*/	
0: 			if (!refCd.areColumnsComparable(cdl))
0: 			{
0: 				throw StandardException.newException(SQLState.LANG_INVALID_FK_COL_TYPES_DO_NOT_MATCH, 
0: 												myConstraintName);
0: 			}
0: 
0: 			return refCd;	
0: 		}
0: 
0: 		/*
0: 		** Check the referenced columns vs. each unique or primary key to
0: 		** see if they match the foreign key.
0: 		*/
0: 		else
0: 		{
0: 			ConstraintDescriptor cd;
0: 
0: 			ColumnDescriptorList colDl = getColumnDescriptors(dd, td, myColumnNames);
0: 			ConstraintDescriptorList refCDL = dd.getConstraintDescriptors(refTd);
0: 
0: 			int refCDLSize = refCDL.size();
0: 			for (int index = 0; index < refCDLSize; index++)
0: 			{
0: 				cd = refCDL.elementAt(index);
0: 
0: 				/*
0: 				** Matches if it is not a check or fk, and
0: 				** all the types line up.
0: 				*/
0: 				if ((cd instanceof ReferencedKeyConstraintDescriptor) &&
0: 					 cd.areColumnsComparable(colDl) &&
0: 					 columnNamesMatch(refColumnNames, 
0: 										cd.getColumnDescriptors()))
0: 				{
0: 					return (ReferencedKeyConstraintDescriptor)cd;
0: 				}
0: 			}
0: 
0: 			/*
0: 			** If we got here, we didn't find anything
0: 			*/
0: 			throw StandardException.newException(SQLState.LANG_INVALID_FK_NO_REF_KEY, myConstraintName, 
0: 														refTd.getQualifiedName());
0: 		}
0: 	}
0: 
0:     public	static ColumnDescriptorList getColumnDescriptors
0: 	(
0: 		DataDictionary	dd,
0: 		TableDescriptor td,
0: 		String[] 		columnNames
0: 	)
0: 		throws StandardException
0: 	{
0: 		ColumnDescriptorList cdl = new ColumnDescriptorList();
0: 		for (int colCtr = 0; colCtr < columnNames.length; colCtr++)
0: 		{
0: 			ColumnDescriptor cd = td.getColumnDescriptor(columnNames[colCtr]);
0: 			cdl.add(td.getUUID(), cd);
0: 		}
0: 		return cdl;
0: 	}
0: 
0: 	public	static boolean columnNamesMatch(String []columnNames, ColumnDescriptorList cdl)
0: 		throws StandardException
0: 	{
0: 		if (columnNames.length != cdl.size())
0: 		{
0: 			return false;
0: 		}
0: 		
0: 		String name;
0: 		for (int index = 0; index < columnNames.length; index++)
0: 		{
0: 			name = ((ColumnDescriptor) cdl.elementAt(index)).getColumnName();
0: 			if (!name.equals(columnNames[index]))
0: 			{
0: 				return false;
0: 			}
0: 		}
0: 
0: 		return true;
0: 	}
0: 
0: 
0: 	/*
0: 	**checks whether the foreign key relation ships referential action
0: 	**is violating the restrictions we have in the current system.
0: 	**/
0: 	public static void validateReferentialActions
0:     (
0: 		DataDictionary	dd,
0: 		TableDescriptor	td,
0: 		String			myConstraintName,	// for error messages
0: 		ConsInfo		otherConstraintInfo,
0: 		String[]        columnNames
0: 	)
0: 		throws StandardException
0: 	{
0: 
0: 
0: 		int refAction = otherConstraintInfo.getReferentialActionDeleteRule();
0: 
0: 		//Do not allow ON DELETE SET NULL as a referential action 
0: 		//if none of the foreign key columns are  nullable.
0: 		if(refAction == StatementType.RA_SETNULL)
0: 		{
0: 			boolean foundNullableColumn = false;
0: 			//check if we have a nullable foreign key column
0: 			for (int colCtr = 0; colCtr < columnNames.length; colCtr++)
0: 			{
0: 				ColumnDescriptor cd = td.getColumnDescriptor(columnNames[colCtr]);
0: 				if ((cd.getType().isNullable()))
0: 				{
0: 					foundNullableColumn = true;
0: 					break;
0: 				}
0: 			}
0: 
0: 			if(!foundNullableColumn)
0: 			{
0: 				throw StandardException.newException(SQLState.LANG_INVALID_FK_COL_FOR_SETNULL, 
0: 													 myConstraintName);
0: 			}
0: 		}
0: 
0: 		//check whether the foreign key relation ships referential action
0: 		//is not violating the restrictions we have in the current system.
0: 		TableDescriptor refTd = otherConstraintInfo.getReferencedTableDescriptor(dd);
0: 		Hashtable deleteConnHashtable = new Hashtable();
0: 		//find whether the foreign key is self referencing.
0: 		boolean isSelfReferencingFk = (refTd.getUUID().equals(td.getUUID()));
0: 		String refTableName = refTd.getSchemaName() + "." + refTd.getName();
0: 		//look for the other foreign key constraints on this table first
0: 		int currentSelfRefValue = getCurrentDeleteConnections(dd, td, -1, deleteConnHashtable, false, true);
0: 		validateDeleteConnection(dd, td, refTd, 
0: 								 refAction, 
0: 								 deleteConnHashtable, (Hashtable) deleteConnHashtable.clone(),
0: 								 true, myConstraintName, false , 
0: 								 new StringBuffer(0), refTableName,
0: 								 isSelfReferencingFk,
0: 								 currentSelfRefValue);
0: 
0: 		//if it not a selfreferencing key check for violation of exiting connections.
0: 		if(!isSelfReferencingFk)
0: 		{
0: 			checkForAnyExistingDeleteConnectionViolations(dd, td,
0: 														  refAction, 
0: 														  deleteConnHashtable, 
0: 														  myConstraintName);
0: 		}	
0: 	}
0: 
0: 	/*
0: 	** Finds the existing delete connection for the table and the referential
0: 	** actions that will occur  and stores the information in the hash table.
0: 	** HashTable (key , value) = ( table name that this table is delete
0: 	** connected to, referential action that will occur if there is a delete on
0: 	** the table this table connected to[CASACDE, SETNULL , RESTRICT ...etc).)
0: 	**/
0: 
0: 	private	static int  getCurrentDeleteConnections
0: 	(
0: 	 DataDictionary	dd,
0: 	 TableDescriptor	td,
0: 	 int refActionType,
0: 	 Hashtable dch,
0: 	 boolean prevNotCascade,
0: 	 boolean findSelfRef
0: 	 )
0: 		throws StandardException
0: 	{
0: 
0: 		int selfRefValue = -1; //store the self reference referential action 
0: 
0: 		//make sure we get any foreign key constraints added earlier in the same statement.
0: 		td.emptyConstraintDescriptorList();
0: 		ConstraintDescriptorList cdl = dd.getConstraintDescriptors(td);
0: 		int cdlSize = cdl.size();
0: 
0: 		boolean passedInPrevNotCascade = prevNotCascade;
0: 		for (int index = 0; index < cdlSize; index++)
0: 		{
0: 				ConstraintDescriptor cd = cdl.elementAt(index);
0: 
0: 				//look for  foreign keys
0: 				if ((cd instanceof ForeignKeyConstraintDescriptor))
0: 				{
0: 					ForeignKeyConstraintDescriptor fkcd = (ForeignKeyConstraintDescriptor) cd;
0: 					String constraintName = fkcd.getConstraintName();
0: 					int raDeleteRule = fkcd.getRaDeleteRule();
0: 					int raUpdateRule = fkcd.getRaUpdateRule();
0: 
0: 					 if(findSelfRef && fkcd.isSelfReferencingFK())
0: 					 {
0: 						 //All self references will have same  referential actions type
0: 						 selfRefValue = raDeleteRule;
0: 						 findSelfRef = false;
0: 					 }
0: 
0: 					ReferencedKeyConstraintDescriptor refcd =
0: 						fkcd.getReferencedConstraint(); 
0: 					TableDescriptor refTd = refcd.getTableDescriptor();
0: 					int childRefAction = refActionType == -1 ? raDeleteRule : refActionType;
0: 				   
0: 					String refTableName = refTd.getSchemaName() + "." + refTd.getName();
0: 					//check with  the existing references.
0: 					Integer rAction = ((Integer)dch.get(refTableName));
0: 					if(rAction != null) // we already looked at this table
0: 					{
0: 						prevNotCascade = passedInPrevNotCascade;
0: 						continue;
0: 					}
0: 
0: 					//if we are not cascading, check whether the link before
0: 					//this was cascade or not. If we travel through  two NON CASCADE ACTION
0: 					//links then the  delete connection is broken(only a delete can have further
0: 					// referential effects)
0: 					if(raDeleteRule != StatementType.RA_CASCADE)
0: 					{
0: 						if(prevNotCascade)
0: 						{
0: 							prevNotCascade = passedInPrevNotCascade;
0: 							continue;
0: 						}
0: 						else
0: 							prevNotCascade = true;
0: 					}
0: 
0: 					//store the delete connection info in the hash table,
0: 					//note that the referential action value is not what is
0: 					//not specified on the current link. It is actually the 
0: 					//value of what happens to the table whose delete
0: 					// connections we are finding.
0: 					dch.put(refTableName, (new Integer(childRefAction)));
0: 					
0: 					//find the next delete conectiions on this path for non
0: 					//self referencig delete connections.
0: 					if(!fkcd.isSelfReferencingFK())
0: 						getCurrentDeleteConnections(dd , refTd, childRefAction,
0: 													dch, true, false);
0: 					prevNotCascade = passedInPrevNotCascade;
0: 				}
0: 		}
0: 		
0: 		return selfRefValue;
0: 	}
0: 
0: 
0: 	/*
0: 	** Following function validates whether the new foreign key relation ship
0: 	** violates any restriction on the referential actions. Current refAction
0: 	** implementation does not allow cases where we can possible land up
0: 	** having multiple action for the same row in a table, this happens becase
0: 	** user can possibly define differential action through multiple paths.
0: 	** Following function throws error while creating foreign keys if the new
0: 	** releations ship leads to any such conditions.
0: 	** NOTE : SQL99 standard also does not cleary says what we are suppose to do
0: 	** in these non determenistic cases. 
0: 	** Our implementation just follows what is did in DB2 and throws error
0: 	** messaged similar to DB2 (sql0632N, sql0633N, sql0634N)
0: 	*/
0: 
0: 	private	static void validateDeleteConnection
0: 	(
0: 		DataDictionary	dd,
0: 		TableDescriptor actualTd,  // the table we are adding the foriegn key.
0: 		TableDescriptor	refTd,
0: 		int refActionType,
0: 		Hashtable dch,
0: 		Hashtable ech,  //existing delete connections
0: 		boolean checkImmediateRefTable,
0: 		String myConstraintName,
0: 		boolean prevNotCascade,
0: 		StringBuffer cycleString, 
0: 		String currentRefTableName, //the name of the table we are referring too.
0: 		boolean isSelfReferencingFk,
0: 		int currentSelfRefValue
0: 		)
0: 		throws StandardException
0: 	{
0: 
0: 		Integer rAction;
0: 
0: 		String refTableName = refTd.getSchemaName() + "." + refTd.getName();
0: 
0: 
0: 		/*
0: 		** Validate the new referentail action value with respect to the 
0: 		** already existing connections to this table we gathered  from
0: 		** the getCurrentDeleteConnections() call.
0: 		*/
0: 
0: 		if(checkImmediateRefTable)
0: 		{
0: 			rAction = ((Integer)dch.get(refTableName));
0: 			
0: 			// check possible invalide cases incase of self referencing foreign key
0: 			if(isSelfReferencingFk)
0: 			{
0: 				//All the relation ship referring to a table should have the
0: 				//same refaction except incase of SET NULL. In this case
0: 				//it is the same table , so we have to check with existing self
0: 				//referencing actions.
0: 				if(currentSelfRefValue !=  -1)
0: 				{
0: 					if(currentSelfRefValue != refActionType)
0: 					{
0: 						//If there is a SET NULL relation ship we can not have any
0: 						// other relation ship with it.
0: 						if(currentSelfRefValue == StatementType.RA_SETNULL)
0: 							throw
0: 								generateError(SQLState.LANG_CANT_BE_DEPENDENT_ESELF, 
0: 										  myConstraintName, currentRefTableName);
0: 						else
0: 						{
0: 								/*
0: 								** case where we can cleary say what the
0: 								** referential actions should be. Like,	   
0: 								** if there is NO ACTION relationsip
0: 								**already, new relation ship also shold be NO ACTION. 
0: 								*/
0: 							throw
0: 								generateError(SQLState.LANG_DELETE_RULE_MUSTBE_ESELF,
0: 											  myConstraintName, currentSelfRefValue);
0: 						}
0: 					}else
0: 					{
0: 						//more than one  ON DELET SET NULL to the same table is not allowed
0: 						if(currentSelfRefValue == StatementType.RA_SETNULL &&
0: 						   refActionType == StatementType.RA_SETNULL)
0: 						{
0: 							throw
0: 								generateError(SQLState.LANG_CANT_BE_DEPENDENT_ESELF,
0: 											  myConstraintName, currentRefTableName);
0: 						}
0: 					}
0: 				}
0: 
0: 				/*
0: 				** If the new releation ship is self referencing and if
0: 				** the current existing relation ship to other tables is
0: 				** CASCADE type them  new self reference should be of type
0: 				** CASCADE, otherwise we should throw error.
0: 				*/
0: 
0: 				if(isSelfReferencingFk && dch.contains(new Integer(StatementType.RA_CASCADE)) && 
0: 				   refActionType!=  StatementType.RA_CASCADE)
0: 				{
0: 					throw
0: 						generateError(SQLState.LANG_DELETE_RULE_MUSTBE_ECASCADE,
0: 									  myConstraintName,StatementType.RA_CASCADE);	
0: 				}
0: 
0: 				//end of possible error case scenarios for self reference key additions
0: 				return;
0: 			}
0: 		
0: 			//cases where the new  reference is referring to  another table
0: 
0: 			//check whether it matched with existing self references.
0: 			// If A self-referencing constraint exists with a delete rule of
0: 			// SET NULL,  NO ACTION or RESTRICT. We can not add CASCADE
0: 			// relationship with another table.
0: 				
0: 			if(currentSelfRefValue !=  -1)
0: 			{
0: 				if(refActionType == StatementType.RA_CASCADE && 
0: 				   currentSelfRefValue != StatementType.RA_CASCADE) 
0: 				{
0: 					throw generateError(SQLState.LANG_DELETE_RULE_CANT_BE_CASCADE_ESELF,  myConstraintName);
0: 					
0: 				}
0: 
0: 			}
0: 
0: 			
0: 			//check for the cases with existing relationships to the
0: 			//referenced table
0: 			if(rAction != null)
0: 			{
0: 				checkForMultiplePathInvalidCases(rAction.intValue(),
0: 												  refActionType,
0: 												  myConstraintName,currentRefTableName);
0: 			}
0: 
0: 			
0: 			//mark the current connect to the reference table to identify the cycle.
0: 			if(refActionType != StatementType.RA_CASCADE)
0: 			{
0: 				prevNotCascade = true;
0: 			}
0: 			
0: 			/*
0: 			** cycle string is used to keep track of the referential actions of 
0: 			** the nodes we visited, this is required to make sure that in case
0: 			** of cycles , all the nodes in the cycle have same type of
0: 			** referential action.
0: 			**/
0: 			cycleString = cycleString.append(refActionType);
0: 		}
0: 
0: 
0: 		boolean passedInPrevNotCascade = prevNotCascade;
0: 
0: 		//delete connection is broken for if we see ON DELET SET NULL link
0: 		// one level deeper than the table we are adding the foreing key
0: 		//Where as to check for cycles we need to go for more level also;
0:         // To check cases like CASCADE CASCADE SET NULL cycle is not valid. 
0: 		//Following variable is used make the distinction.
0: 		boolean multiPathCheck = true;
0: 
0: 		// check for cases where the new connection we are forming to the 
0: 		// reference table could create invalid any cycles or mutiple paths 
0: 		// with the delete-connections the  referencing table might have already.
0: 		ConstraintDescriptorList refCDL = dd.getConstraintDescriptors(refTd);
0: 		int refCDLSize = refCDL.size();
0: 		for (int index = 0; index < refCDLSize; index++)
0: 		{
0: 			ConstraintDescriptor cd = refCDL.elementAt(index);
0: 
0: 			if ((cd instanceof ForeignKeyConstraintDescriptor))
0: 			{
0: 				ForeignKeyConstraintDescriptor fkcd = (ForeignKeyConstraintDescriptor) cd;
0: 				String constraintName = fkcd.getConstraintName();
0: 				int raDeleteRule = fkcd.getRaDeleteRule();
0: 				int raUpdateRule = fkcd.getRaUpdateRule();
0: 				
0: 				ReferencedKeyConstraintDescriptor refcd =
0: 					fkcd.getReferencedConstraint(); 
0: 				TableDescriptor nextRefTd = refcd.getTableDescriptor();
0: 
0: 				//if we are not cascading, check  whether the link before
0: 				//this was cascade or not. If we travel through  two NON CASCADE ACTION
0: 				//links then the delete connection is broken(only a delete can have further
0: 				//referential effects)
0: 				if(raDeleteRule != StatementType.RA_CASCADE)
0: 				{
0: 					if(prevNotCascade)
0: 					{
0: 						prevNotCascade = passedInPrevNotCascade;
0: 						continue;
0: 					}
0: 					else
0: 					{
0: 						prevNotCascade = true;
0: 						multiPathCheck = false;
0: 					}
0: 
0: 				}
0: 
0: 				//check whether the current link is a self referencing one
0: 				boolean isSelfRefLink = fkcd.isSelfReferencingFK();
0: 				
0: 				//check for this is non self referencing cycles case
0: 				//In cases of cycle, whole cycle should have the same refAction
0: 				// value. Other wise we should throw an exception
0: 				cycleString = cycleString.append(raDeleteRule);
0: 				boolean isFormingCycle = (nextRefTd.getUUID().equals(actualTd.getUUID()));
0: 				if(isFormingCycle)
0: 				{
0: 					//make sure that all the nodes in the cycle have the same
0: 					//referential action  value, otherwise we should throw an error. 
0: 					for(int i = 0 ; i < cycleString.length(); i++)
0: 					{
0: 						int otherRefAction = Character.getNumericValue(cycleString.charAt(i));
0: 						if(otherRefAction != refActionType)
0: 						{
0: 							//cases where one of the existing relation ships in
0: 							//the cycle is not cascade , so we can not have
0: 							// cascade relation ship.
0: 							if(otherRefAction != StatementType.RA_CASCADE)
0: 							{
0: 								throw generateError(SQLState.LANG_DELETE_RULE_CANT_BE_CASCADE_ECYCLE, myConstraintName);
0: 							}
0: 							else
0: 							{
0: 								//possibly all the other nodes in the cycle has
0: 								//cascade relationsship , we can not add a non
0: 								//cascade relation ship.
0: 								throw
0: 									generateError(SQLState.LANG_CANT_BE_DEPENDENT_ECYCLE, 
0: 												  myConstraintName, currentRefTableName);
0: 							}
0: 						}
0: 					}
0: 				}	
0: 
0: 
0: 				
0: 
0: 				String nextRefTableName =  nextRefTd.getSchemaName() + "." + nextRefTd.getName();
0: 				rAction = ((Integer)ech.get(nextRefTableName));
0: 				if(rAction != null)
0: 				{
0: 					/*
0: 					** If the table name has entry in the hash table means, there
0: 					** is already  a path to this table exists from the table
0: 					** the new foreign key relation ship is being formed.
0: 					** Note: refValue in the hash table is how the table we are
0: 					** adding the new relationsship is going to affected not
0: 					** current path refvalue.
0: 					**/
0: 					if(!isSelfRefLink && multiPathCheck)
0: 						checkForMultiplePathInvalidCases(rAction.intValue(),
0: 														 refActionType, 
0: 														 myConstraintName,currentRefTableName);
0: 
0: 				}else
0: 				{
0: 					rAction = ((Integer)dch.get(nextRefTableName));
0: 					if(rAction == null)
0: 					{
0: 						if(multiPathCheck)
0: 							dch.put(nextRefTableName, (new Integer(refActionType)));
0: 						if(!isSelfRefLink)
0: 						{
0: 							validateDeleteConnection(dd, actualTd,  nextRefTd,
0: 												 refActionType, dch, ech, false,
0: 												 myConstraintName,prevNotCascade,
0: 												 cycleString, currentRefTableName, 
0: 												 isSelfReferencingFk, currentSelfRefValue); 
0: 						}
0: 					}
0: 				}
0: 				prevNotCascade = passedInPrevNotCascade;
0: 				//removes the char added for the current call
0: 				cycleString.setLength(cycleString.length() -1);
0: 				
0: 			}
0: 		}
0: 	}
0: 
0: 
0: 	/*
0: 	**Check whether the mulitple path case is valid or not following
0: 	** cases are invalid:
0: 	** case 1: The relationship causes the table to be delete-connected to
0: 	** the indicated table through multiple relationships and the
0: 	** delete rule of the existing relationship is SET NULL. 
0: 	** case 2: The relationship would cause the table to be
0: 	** delete-connected to the same table through multiple
0: 	** relationships and such relationships must have the same 
0: 	** delete rule (NO ACTION, RESTRICT or CASCADE). 
0: 	** case 3: The relationship would cause another table to be
0: 	** delete-connected to the same table through multiple paths
0: 	** with different delete rules or with delete rule equal to SET NULL. 
0: 	**/
0: 
0: 	private static void checkForMultiplePathInvalidCases(int currentRefAction,
0: 														  int refActionType,
0: 														  String myConstraintName,
0: 														  String currentRefTableName)
0: 		throws StandardException
0: 	{
0: 
0: 		//All the relation ship referring to a table should have the
0: 		//same refaction except incase of SET NULL
0: 		if(currentRefAction != refActionType)
0: 		{
0: 
0: 			//If there is a SET NULL relation ship we can not have any
0: 			// other relation ship with it.
0: 			if(currentRefAction == StatementType.RA_SETNULL)
0: 				throw generateError(SQLState.LANG_CANT_BE_DEPENDENT_MPATH,
0: 									myConstraintName, currentRefTableName);
0: 			else
0: 				//This error say what the delete rule must be for the
0: 				// foreign key be valid 
0: 				throw generateError(SQLState.LANG_DELETE_RULE_MUSTBE_MPATH,
0: 									myConstraintName, currentRefAction);
0: 
0: 		}else
0: 		{
0: 			//more than one  ON DELET SET NULL to the same table is not allowed
0: 			if(currentRefAction == StatementType.RA_SETNULL &&
0: 			   refActionType == StatementType.RA_SETNULL)
0: 			{
0: 				throw		
0: 					generateError(SQLState.LANG_CANT_BE_DEPENDENT_MPATH,
0: 								  myConstraintName, currentRefTableName);
0: 			}
0: 		}
0: 	}
0: 
0: 
0: 
0:     /*
0: 	** Check whether the delete rule of FOREIGN KEY  must not be CASCADE because
0: 	** the  new relationship would cause another table to be delete-connected to
0: 	** the same table through multiple paths with different delete rules or with 
0: 	** delete rule equal to SET NULL. 
0: 	**
0: 	** For example :
0: 	**                      t1
0:     **  		 CASCADE   /  \  CASCADE
0:     **                    /    \ 
0: 	**                  t2      t3
0:     **                   \      /   
0:     **          SET NULL  \    /  CASCADE (Can we add this one ? NO)
0:  	**			          \   /
0: 	                       \t4/
0: 	**					
0:     **   existing links:
0: 	**   t2 references t1   ON DELETE CASCADE  (fkey1)
0: 	**   t3 references t1   ON DELETE CASCADE  (fkey2)
0: 	**   t2 reference  t4   ON DELETE SET NULL (fkey3)
0: 	**   Now if if try to add a new link i.e
0: 	**   t4 references t3   ON DELETE SET NULL  (fkey4)
0: 	**   Say if we add it,  then if we execute 'delete from t1' 
0: 	**   Because of referential actions , we will try to delete a row through
0: 	**   one path and tries to update  through another path. 
0: 	**   Nothing in standard that say whether we are suppose to delete the row
0: 	**   or update the row.  DB2UDB raises error when we try to create the
0: 	**   foreign key fkey4, cloudscape also does the same.
0: 	** 
0: 	**   How we catch the error case ?
0: 	**   Point to note here is the table(t4) we are  adding the foreign key does
0: 	**   not have a problem in this scenarion because we are adding a
0:     **   a CASACDE link , some other table(t2) that is referring  
0: 	**   can get multiple referential action paths. We can not
0: 	**   this error case for self referencing links.
0: 	**   Algorithm:
0: 	**   -Gather the foreign keys that are
0: 	**   referring(ReferencedKeyConstraintDescriptor) to the table we are adding
0: 	**   foreign key, in our example case we get (fkey3 - table t2 -t4 link)
0: 	**   for each ReferencedKeyConstraintDescriptor
0: 	**   {
0: 	**    1)find the delete connections of the referring table.
0: 	**    [getCurrentDeleteConnections() will return this hash table]
0: 	**	  2) we already have collected the Delete connections 
0:     **       in validDeleteConnections() for the actual table we are adding the 
0:     **       foreign key.
0: 	**    3) Now check whether the referring table  is also 
0:     **       referring  any table that the table we are adding
0:     **       foreign key has delete connection.
0: 	**
0: 	**     for each table referring table delete connection hash table
0: 	**     {
0: 	**      if it is there in the actual table delete connection hash table
0:     **      {
0: 	**         //In our example case we find t1 in both the hash tables.
0: 	**         make sure we are having valid referential action
0:     **         from the existing path and the new path we got from 
0: 	**         new foreign key relation ship.
0: 	**        //In our example case t2 has CASCADE relations with t1
0: 	**        //Because of new foreign key added we also get 
0: 	**        //SET NULL relation ship with t1. This is not valid
0: 	**        //so we should throw error.
0:     **      }  
0: 	**     }
0: 	** }	
0: 	**/
0: 
0: 
0: 	private static void checkForAnyExistingDeleteConnectionViolations
0: 	(
0: 	 DataDictionary	dd,
0: 	 TableDescriptor td,
0: 	 int refActionType,
0: 	 Hashtable newDconnHashTable,
0: 	 String myConstraintName
0: 	 )
0: 	throws StandardException
0: 	{
0: 
0: 		//We need to check for the condition in this function only when we are
0: 		//adding ref action of type CASCADE
0: 		if(refActionType != StatementType.RA_CASCADE)
0: 			return;
0: 		
0: 		//find the tables that are referring to the table we 
0: 		//are adding the foreign key and check whether we violate their existing rules.
0: 		String addTableName = td.getSchemaName() + "." + td.getName();;
0: 		ConstraintDescriptorList refCDL = dd.getConstraintDescriptors(td);
0: 		int refCDLSize = refCDL.size();
0: 		for (int index = 0; index < refCDLSize; index++)
0: 		{
0: 			ConstraintDescriptor cd = refCDL.elementAt(index);
0: 
0: 			if ((cd instanceof ReferencedKeyConstraintDescriptor))
0: 			{
0: 				ConstraintDescriptorList fkcdl = dd.getActiveConstraintDescriptors
0: 					( ((ReferencedKeyConstraintDescriptor)cd).getForeignKeyConstraints(ConstraintDescriptor.ALL));
0: 	
0: 				int size = fkcdl.size();
0: 				if (size == 0) 
0: 				{ 
0: 					continue; 
0: 				}
0: 				
0: 				//Note: More than one table can refer to the same
0: 				//ReferencedKeyConstraintDescriptor, so we need to find all the tables.
0: 				Hashtable dConnHashtable = new Hashtable();
0: 				for (int inner = 0; inner < size; inner++)
0: 				{
0: 					ForeignKeyConstraintDescriptor fkcd = (ForeignKeyConstraintDescriptor) fkcdl.elementAt(inner);
0: 					TableDescriptor fktd = fkcd.getTableDescriptor();
0: 					//Delete rule that we have to the table we are adding the
0: 					// foreign key relation shop
0: 					int raDeleteRuleToAddTable = fkcd.getRaDeleteRule();
0: 
0: 					//This check should not be done on self referencing references.
0: 					if(!fkcd.isSelfReferencingFK())
0: 					{
0: 
0: 						//gather the delete connections of the table that is
0: 						//referring to the table we are adding foreign key relation ship
0: 
0: 						getCurrentDeleteConnections(dd, fktd, -1, dConnHashtable, false, true);
0: 
0: 						/*
0: 						**Find out if we introduced more than one delete connection
0: 						**paths to the table that are referring the table we adding
0: 						**the foreign key relatiosn ship.
0: 						**If we have multiple paths they should have the same type
0: 						**referential action and only one SET NULL path.
0: 						**/
0: 
0: 						for (Enumeration e = dConnHashtable.keys() ; e.hasMoreElements() ;) 
0: 						{
0: 							String tName = (String) e.nextElement();
0: 							//we should not check for the table name to which  we are
0: 							//adding the foreign key relation ship.
0: 							if(!tName.equals(addTableName))
0: 							{
0: 								if(newDconnHashTable.containsKey(tName))
0: 								{
0: 									int currentDeleteRule = ((Integer)	dConnHashtable.get(tName)).intValue();
0: 									if((currentDeleteRule == StatementType.RA_SETNULL
0: 										&& raDeleteRuleToAddTable == StatementType.RA_SETNULL) ||
0: 									   currentDeleteRule  != raDeleteRuleToAddTable)
0: 									{
0: 										throw
0: 											generateError(SQLState.LANG_DELETE_RULE_CANT_BE_CASCADE_MPATH, 
0: 														  myConstraintName);
0: 									}
0: 								}
0: 							}
0: 						}
0: 					}
0: 					//same hash table can be used for the other referring tables
0: 					//so clear the hash table.
0: 					dConnHashtable.clear();
0: 				}
0: 			}
0: 		}
0: 	}
0: 
0: 
0: 	
0: 	private static StandardException generateError(String messageId, 
0: 												   String myConstraintName)
0: 	{
0: 		String message = MessageService.getTextMessage(messageId);
0: 		return StandardException.newException(SQLState.LANG_DELETE_RULE_VIOLATION, 
0: 												myConstraintName, message);
0: 	}	
0: 
0: 	private static StandardException generateError(String messageId, 
0: 												   String myConstraintName, 
0: 												   int raRule)
0: 	{
0: 		String raRuleStringId;
0: 		switch (raRule){
0: 		case StatementType.RA_CASCADE:
0: 			raRuleStringId = SQLState.LANG_DELETE_RULE_CASCADE;
0: 			break;
0: 		case StatementType.RA_RESTRICT:
0: 			raRuleStringId = SQLState.LANG_DELETE_RULE_RESTRICT;
0: 				break;
0: 		case StatementType.RA_NOACTION:
0: 			raRuleStringId = SQLState.LANG_DELETE_RULE_NOACTION;
0: 			break;
0: 		case StatementType.RA_SETNULL:
0: 			raRuleStringId = SQLState.LANG_DELETE_RULE_SETNULL;
0: 			break;
0: 		case StatementType.RA_SETDEFAULT:
0: 			raRuleStringId = SQLState.LANG_DELETE_RULE_SETDEFAULT;
0: 			break;
0: 		default: 
0: 			raRuleStringId =SQLState.LANG_DELETE_RULE_NOACTION ; // NO ACTION (default value)
0: 		}
0: 
0: 		String raRuleMessageString = MessageService.getTextMessage(raRuleStringId); 
0: 		String message = MessageService.getTextMessage(messageId, raRuleMessageString);
0: 		return StandardException.newException(SQLState.LANG_DELETE_RULE_VIOLATION, 
0: 												myConstraintName, message);
0: 	}	
0: 
0: 	private static StandardException generateError(String messageId, 
0: 												   String myConstraintName,
0: 												   String refTableName)
0: 	{
0: 
0: 		String message = MessageService.getTextMessage(messageId, refTableName);
0: 		return StandardException.newException(SQLState.LANG_DELETE_RULE_VIOLATION, 
0: 												myConstraintName, message);
0: 	}	
0: 
0: }
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
============================================================================