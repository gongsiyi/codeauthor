1:a84fc26: /*
1:a84fc26: 
1:a84fc26:    Derby - Class org.apache.derby.iapi.sql.dictionary.PasswordHasher
1:a84fc26: 
1:a84fc26:    Licensed to the Apache Software Foundation (ASF) under one or more
1:a84fc26:    contributor license agreements.  See the NOTICE file distributed with
1:a84fc26:    this work for additional information regarding copyright ownership.
1:a84fc26:    The ASF licenses this file to you under the Apache License, Version 2.0
1:a84fc26:    (the "License"); you may not use this file except in compliance with
1:a84fc26:    the License.  You may obtain a copy of the License at
1:a84fc26: 
1:a84fc26:       http://www.apache.org/licenses/LICENSE-2.0
1:a84fc26: 
1:a84fc26:    Unless required by applicable law or agreed to in writing, software
1:a84fc26:    distributed under the License is distributed on an "AS IS" BASIS,
1:a84fc26:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:a84fc26:    See the License for the specific language governing permissions and
1:a84fc26:    limitations under the License.
1:a84fc26: 
1:a84fc26:  */
1:a84fc26: package org.apache.derby.iapi.sql.dictionary;
1:a84fc26: 
1:a84fc26: import java.io.UnsupportedEncodingException;
1:a84fc26: import java.security.MessageDigest;
1:a84fc26: import java.security.NoSuchAlgorithmException;
1:a84fc26: 
1:a84fc26: import org.apache.derby.iapi.error.StandardException;
1:bc2c59e: import org.apache.derby.iapi.services.io.ArrayUtil;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:a84fc26: import org.apache.derby.iapi.util.StringUtil;
1:a84fc26: import org.apache.derby.shared.common.reference.SQLState;
1:a84fc26: 
1:a84fc26: /**
1:a84fc26:  * <p>
1:a84fc26:  * This machine performs the hashing of Derby passwords.
1:a84fc26:  * </p>
1:a84fc26:  */
1:a84fc26: public  class   PasswordHasher
1:a84fc26: {
1:a84fc26:     ///////////////////////////////////////////////////////////////////////////////////
1:a84fc26:     //
1:a84fc26:     // CONSTANTS
1:a84fc26:     //
1:a84fc26:     ///////////////////////////////////////////////////////////////////////////////////
1:a84fc26: 
1:a84fc26:      /**
1:a84fc26:      * The encoding to use when converting the credentials to a byte array
1:a84fc26:      * that can be passed to the hash function in the configurable hash scheme.
1:a84fc26:      */
1:a84fc26:     private static final String ENCODING = "UTF-8";
1:a84fc26: 
1:a84fc26:     /**
1:a84fc26:      * Pattern that is prefixed to the stored password in the SHA-1
1:a84fc26:      * authentication scheme.
1:a84fc26:      */
1:a84fc26:     public static final String ID_PATTERN_SHA1_SCHEME = "3b60";
1:a84fc26: 
1:a84fc26:     /**
1:a84fc26:      * Pattern that is prefixed to the stored password in the configurable
1:a84fc26:      * hash authentication scheme.
1:a84fc26:      */
1:a84fc26:     public static final String ID_PATTERN_CONFIGURABLE_HASH_SCHEME = "3b61";
1:a84fc26: 
1:a84fc26:     /**
1:a84fc26:      * Pattern that is prefixed to the stored password in the configurable
1:a84fc26:      * hash authentication scheme if key stretching has been applied. This
1:a84fc26:      * scheme extends the configurable hash scheme by adding a random salt and
1:a84fc26:      * applying the hash function multiple times when generating the hashed
1:a84fc26:      * token.
1:a84fc26:      */
1:a84fc26:     public static final String
1:a84fc26:             ID_PATTERN_CONFIGURABLE_STRETCHED_SCHEME = "3b62";
1:a84fc26: 
1:a84fc26:     /**
1:a84fc26:      * Character that separates the hash value from the name of the hash
1:a84fc26:      * algorithm in the stored password generated by the configurable hash
1:a84fc26:      * authentication scheme.
1:a84fc26:      */
1:a84fc26:     private static final char SEPARATOR_CHAR = ':';
1:a84fc26: 
1:a84fc26:     ///////////////////////////////////////////////////////////////////////////////////
1:a84fc26:     //
1:a84fc26:     // STATE
1:a84fc26:     //
1:a84fc26:     ///////////////////////////////////////////////////////////////////////////////////
1:a84fc26: 
1:a84fc26:     private String  _messageDigestAlgorithm;
1:a84fc26:     private byte[]  _salt;  // can be null
1:a84fc26:     private int         _iterations;
1:a84fc26:     
1:a84fc26: 
1:a84fc26:     ///////////////////////////////////////////////////////////////////////////////////
1:a84fc26:     //
1:a84fc26:     // CONSTRUCTORS
1:a84fc26:     //
1:a84fc26:     ///////////////////////////////////////////////////////////////////////////////////
1:a84fc26: 
1:a84fc26:     /**
1:a84fc26:      * <p>
1:a84fc26:      * Construct from pieces. Used for databases at rev level 10.6 or later.
1:a84fc26:      * </p>
1:a84fc26:      */
1:a84fc26:     public  PasswordHasher
1:a84fc26:         (
1:a84fc26:          String messageDigestAlgorithm,
1:a84fc26:          byte[]   salt,
1:a84fc26:          int    iterations
1:a84fc26:          )
1:a84fc26:     {
1:a84fc26:         _messageDigestAlgorithm = messageDigestAlgorithm;
1:bc2c59e:         _salt = ArrayUtil.copy( salt );
1:a84fc26:         _iterations = iterations;
1:a84fc26:     }
1:a84fc26: 
1:a84fc26:     /**
1:a84fc26:      * <p>
1:a84fc26:      * Construct from a hashed BUILTIN password stored in the PropertyConglomerate
1:a84fc26:      * or from a SYSUSERS.HASHINGSCHEME column.
1:a84fc26:      * </p>
1:a84fc26:      */
1:a84fc26:     public  PasswordHasher( String hashingScheme )
1:a84fc26:     {
1:a84fc26:         if ( hashingScheme.startsWith( ID_PATTERN_CONFIGURABLE_HASH_SCHEME) )
1:a84fc26:         {
1:a84fc26:             _messageDigestAlgorithm = hashingScheme.substring
1:a84fc26:                 ( hashingScheme.indexOf( SEPARATOR_CHAR) +  1);
1:a84fc26:             _salt = null;
1:a84fc26:             _iterations = 1;
1:a84fc26:         }
1:a84fc26:         else if ( hashingScheme.startsWith( ID_PATTERN_CONFIGURABLE_STRETCHED_SCHEME) )
1:a84fc26:         {
1:a84fc26:             int saltPos = hashingScheme.indexOf(SEPARATOR_CHAR) + 1;
1:a84fc26:             int iterPos = hashingScheme.indexOf(SEPARATOR_CHAR, saltPos) + 1;
1:a84fc26:             int algoPos = hashingScheme.indexOf(SEPARATOR_CHAR, iterPos) + 1;
1:a84fc26: 
1:a84fc26:             _salt = StringUtil.fromHexString
1:a84fc26:                 ( hashingScheme, saltPos, iterPos - saltPos - 1 );
1:a84fc26:             _iterations = Integer.parseInt
1:a84fc26:                 ( hashingScheme.substring(iterPos, algoPos - 1) );
1:a84fc26:             _messageDigestAlgorithm = hashingScheme.substring(algoPos);
1:a84fc26:         }
1:a84fc26:         else
1:a84fc26:         {
1:a84fc26:             if (SanityManager.DEBUG)
1:a84fc26:             {
1:a84fc26:                 SanityManager.THROWASSERT
1:a84fc26:                     (
1:a84fc26:                         "Unknown authentication scheme for token " +
1:a84fc26:                         hashingScheme
1:a84fc26:                      );
1:a84fc26:             }
1:a84fc26:         }
1:a84fc26:     }
1:a84fc26:     
1:a84fc26:     ///////////////////////////////////////////////////////////////////////////////////
1:a84fc26:     //
1:a84fc26:     // PUBLIC BEHAVIOR
1:a84fc26:     //
1:a84fc26:     ///////////////////////////////////////////////////////////////////////////////////
1:a84fc26: 
1:a84fc26:     /**
1:a84fc26:      * <p>
1:a84fc26:      * Produce a hashed password using a plaintext username and password. Turn it into
1:a84fc26:      * a printable string.
1:a84fc26:      * </p>
1:a84fc26:      */
1:a84fc26:     public  String  hashPasswordIntoString( String userName, String password )
1:a84fc26:         throws StandardException
1:a84fc26:     {
1:a84fc26:         if (password == null) {
1:a84fc26:             return null;
1:a84fc26:         }
1:a84fc26: 
1:a84fc26:         byte[] userBytes;
1:a84fc26:         byte[] passwordBytes;
1:a84fc26:         try {
1:a84fc26:             userBytes = userName.getBytes(ENCODING);
1:a84fc26:             passwordBytes = password.getBytes(ENCODING);
1:a84fc26:         } catch (UnsupportedEncodingException uee) {
1:a84fc26:             // UTF-8 should always be available, so this should never happen.
1:a84fc26:             throw StandardException.plainWrapException(uee);
1:a84fc26:         }
1:a84fc26: 
1:a84fc26:         MessageDigest md = getEmptyMessageDigest();
1:a84fc26: 
1:a84fc26:         byte[] digest = null;
1:a84fc26:         for (int i = 0; i < _iterations; i++)
1:a84fc26:         {
1:a84fc26:             md.reset();
1:a84fc26:             if (digest != null) {
1:a84fc26:                 md.update(digest);
1:a84fc26:             }
1:a84fc26:             md.update(userBytes);
1:a84fc26:             md.update(passwordBytes);
1:a84fc26:             if ( _salt != null) {
1:a84fc26:                 md.update( _salt );
1:a84fc26:             }
1:a84fc26:             digest = md.digest();
1:a84fc26:         }
1:a84fc26: 
1:a84fc26:         return StringUtil.toHexString( digest, 0, digest.length );
1:a84fc26:     }
1:a84fc26:     private MessageDigest   getEmptyMessageDigest()
1:a84fc26:         throws StandardException
1:a84fc26:     {
1:a84fc26:         if ( _messageDigestAlgorithm == null ) { throw badMessageDigest( null ); }
1:a84fc26:         try {
1:a84fc26:             return MessageDigest.getInstance( _messageDigestAlgorithm );
1:a84fc26:         } catch (NoSuchAlgorithmException nsae) { throw badMessageDigest( nsae ); }
1:a84fc26:     }
1:a84fc26:     private StandardException   badMessageDigest( Throwable t )
1:a84fc26:     {
1:a84fc26:         String  digestName = (_messageDigestAlgorithm == null) ? "NULL" : _messageDigestAlgorithm;
1:a84fc26: 
1:a84fc26:         return StandardException.newException( SQLState.DIGEST_NO_SUCH_ALGORITHM, t, digestName );
1:a84fc26:     }
1:a84fc26: 
1:a84fc26:     /**
1:a84fc26:      * <p>
1:a84fc26:      * Encodes the hashing algorithm in a string suitable for storing in SYSUSERS.HASHINGSCHEME.
1:a84fc26:      * </p>
1:a84fc26:      */
1:a84fc26:     public  String  encodeHashingScheme( )
1:a84fc26:     {
1:a84fc26:         return hashAndEncode( "" );
1:a84fc26:     }
1:a84fc26:     
1:a84fc26:     /**
1:a84fc26:      * <p>
1:a84fc26:      * Hash a username/password pair and return an encoded representation suitable
1:a84fc26:      * for storing as a BUILTIN password value in the PropertyConglomerate.
1:a84fc26:      * </p>
1:a84fc26:      */
1:a84fc26:     public  String  hashAndEncode( String userName, String password )
1:a84fc26:         throws StandardException
1:a84fc26:     {
1:a84fc26:         String  stringDigest = hashPasswordIntoString( userName, password );
1:a84fc26: 
1:a84fc26:         return hashAndEncode( stringDigest );
1:a84fc26:     }
1:a84fc26:     private String  hashAndEncode( String stringDigest )
1:a84fc26:     {
1:a84fc26:         if (( _salt == null || _salt.length == 0) && _iterations == 1)
1:a84fc26:         {
1:a84fc26:             // No salt was used, and only a single iteration, which is
1:a84fc26:             // identical to the default hashing scheme in 10.6-10.8. Generate
1:a84fc26:             // a token on a format compatible with those old versions.
1:a84fc26:             return ID_PATTERN_CONFIGURABLE_HASH_SCHEME +
1:a84fc26:                 stringDigest +
1:a84fc26:                 SEPARATOR_CHAR + _messageDigestAlgorithm;
1:a84fc26:         } else {
1:a84fc26:             // Salt and/or multiple iterations was used, so we need to add
1:a84fc26:             // those parameters to the token in order to verify the credentials
1:a84fc26:             // later.
1:a84fc26:             return ID_PATTERN_CONFIGURABLE_STRETCHED_SCHEME +
1:a84fc26:                 stringDigest +
1:a84fc26:                 SEPARATOR_CHAR + StringUtil.toHexString( _salt, 0, _salt.length) +
1:a84fc26:                 SEPARATOR_CHAR + _iterations + SEPARATOR_CHAR + _messageDigestAlgorithm;
1:a84fc26:         }
1:a84fc26:     }
1:a84fc26: }
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:bc2c59e
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.io.ArrayUtil;
/////////////////////////////////////////////////////////////////////////
1:         _salt = ArrayUtil.copy( salt );
commit:a84fc26
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derby.iapi.sql.dictionary.PasswordHasher
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: package org.apache.derby.iapi.sql.dictionary;
1: 
1: import java.io.UnsupportedEncodingException;
1: import java.security.MessageDigest;
1: import java.security.NoSuchAlgorithmException;
1: 
1: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.util.StringUtil;
1: import org.apache.derby.shared.common.reference.SQLState;
1: 
1: /**
1:  * <p>
1:  * This machine performs the hashing of Derby passwords.
1:  * </p>
1:  */
1: public  class   PasswordHasher
1: {
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // CONSTANTS
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:      /**
1:      * The encoding to use when converting the credentials to a byte array
1:      * that can be passed to the hash function in the configurable hash scheme.
1:      */
1:     private static final String ENCODING = "UTF-8";
1: 
1:     /**
1:      * Pattern that is prefixed to the stored password in the SHA-1
1:      * authentication scheme.
1:      */
1:     public static final String ID_PATTERN_SHA1_SCHEME = "3b60";
1: 
1:     /**
1:      * Pattern that is prefixed to the stored password in the configurable
1:      * hash authentication scheme.
1:      */
1:     public static final String ID_PATTERN_CONFIGURABLE_HASH_SCHEME = "3b61";
1: 
1:     /**
1:      * Pattern that is prefixed to the stored password in the configurable
1:      * hash authentication scheme if key stretching has been applied. This
1:      * scheme extends the configurable hash scheme by adding a random salt and
1:      * applying the hash function multiple times when generating the hashed
1:      * token.
1:      */
1:     public static final String
1:             ID_PATTERN_CONFIGURABLE_STRETCHED_SCHEME = "3b62";
1: 
1:     /**
1:      * Character that separates the hash value from the name of the hash
1:      * algorithm in the stored password generated by the configurable hash
1:      * authentication scheme.
1:      */
1:     private static final char SEPARATOR_CHAR = ':';
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // STATE
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     private String  _messageDigestAlgorithm;
1:     private byte[]  _salt;  // can be null
1:     private int         _iterations;
1:     
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // CONSTRUCTORS
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * <p>
1:      * Construct from pieces. Used for databases at rev level 10.6 or later.
1:      * </p>
1:      */
1:     public  PasswordHasher
1:         (
1:          String messageDigestAlgorithm,
1:          byte[]   salt,
1:          int    iterations
1:          )
1:     {
1:         _messageDigestAlgorithm = messageDigestAlgorithm;
0:         _salt = salt;
1:         _iterations = iterations;
1:     }
1: 
1:     /**
1:      * <p>
1:      * Construct from a hashed BUILTIN password stored in the PropertyConglomerate
1:      * or from a SYSUSERS.HASHINGSCHEME column.
1:      * </p>
1:      */
1:     public  PasswordHasher( String hashingScheme )
1:     {
1:         if ( hashingScheme.startsWith( ID_PATTERN_CONFIGURABLE_HASH_SCHEME) )
1:         {
1:             _messageDigestAlgorithm = hashingScheme.substring
1:                 ( hashingScheme.indexOf( SEPARATOR_CHAR) +  1);
1:             _salt = null;
1:             _iterations = 1;
1:         }
1:         else if ( hashingScheme.startsWith( ID_PATTERN_CONFIGURABLE_STRETCHED_SCHEME) )
1:         {
1:             int saltPos = hashingScheme.indexOf(SEPARATOR_CHAR) + 1;
1:             int iterPos = hashingScheme.indexOf(SEPARATOR_CHAR, saltPos) + 1;
1:             int algoPos = hashingScheme.indexOf(SEPARATOR_CHAR, iterPos) + 1;
1: 
1:             _salt = StringUtil.fromHexString
1:                 ( hashingScheme, saltPos, iterPos - saltPos - 1 );
1:             _iterations = Integer.parseInt
1:                 ( hashingScheme.substring(iterPos, algoPos - 1) );
1:             _messageDigestAlgorithm = hashingScheme.substring(algoPos);
1:         }
1:         else
1:         {
1:             if (SanityManager.DEBUG)
1:             {
1:                 SanityManager.THROWASSERT
1:                     (
1:                         "Unknown authentication scheme for token " +
1:                         hashingScheme
1:                      );
1:             }
1:         }
1:     }
1:     
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // PUBLIC BEHAVIOR
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * <p>
1:      * Produce a hashed password using a plaintext username and password. Turn it into
1:      * a printable string.
1:      * </p>
1:      */
1:     public  String  hashPasswordIntoString( String userName, String password )
1:         throws StandardException
1:     {
1:         if (password == null) {
1:             return null;
1:         }
1: 
1:         byte[] userBytes;
1:         byte[] passwordBytes;
1:         try {
1:             userBytes = userName.getBytes(ENCODING);
1:             passwordBytes = password.getBytes(ENCODING);
1:         } catch (UnsupportedEncodingException uee) {
1:             // UTF-8 should always be available, so this should never happen.
1:             throw StandardException.plainWrapException(uee);
1:         }
1: 
1:         MessageDigest md = getEmptyMessageDigest();
1: 
1:         byte[] digest = null;
1:         for (int i = 0; i < _iterations; i++)
1:         {
1:             md.reset();
1:             if (digest != null) {
1:                 md.update(digest);
1:             }
1:             md.update(userBytes);
1:             md.update(passwordBytes);
1:             if ( _salt != null) {
1:                 md.update( _salt );
1:             }
1:             digest = md.digest();
1:         }
1: 
1:         return StringUtil.toHexString( digest, 0, digest.length );
1:     }
1:     private MessageDigest   getEmptyMessageDigest()
1:         throws StandardException
1:     {
1:         if ( _messageDigestAlgorithm == null ) { throw badMessageDigest( null ); }
1:         try {
1:             return MessageDigest.getInstance( _messageDigestAlgorithm );
1:         } catch (NoSuchAlgorithmException nsae) { throw badMessageDigest( nsae ); }
1:     }
1:     private StandardException   badMessageDigest( Throwable t )
1:     {
1:         String  digestName = (_messageDigestAlgorithm == null) ? "NULL" : _messageDigestAlgorithm;
1: 
1:         return StandardException.newException( SQLState.DIGEST_NO_SUCH_ALGORITHM, t, digestName );
1:     }
1: 
1:     /**
1:      * <p>
1:      * Encodes the hashing algorithm in a string suitable for storing in SYSUSERS.HASHINGSCHEME.
1:      * </p>
1:      */
1:     public  String  encodeHashingScheme( )
1:     {
1:         return hashAndEncode( "" );
1:     }
1:     
1:     /**
1:      * <p>
1:      * Hash a username/password pair and return an encoded representation suitable
1:      * for storing as a BUILTIN password value in the PropertyConglomerate.
1:      * </p>
1:      */
1:     public  String  hashAndEncode( String userName, String password )
1:         throws StandardException
1:     {
1:         String  stringDigest = hashPasswordIntoString( userName, password );
1: 
1:         return hashAndEncode( stringDigest );
1:     }
1:     private String  hashAndEncode( String stringDigest )
1:     {
1:         if (( _salt == null || _salt.length == 0) && _iterations == 1)
1:         {
1:             // No salt was used, and only a single iteration, which is
1:             // identical to the default hashing scheme in 10.6-10.8. Generate
1:             // a token on a format compatible with those old versions.
1:             return ID_PATTERN_CONFIGURABLE_HASH_SCHEME +
1:                 stringDigest +
1:                 SEPARATOR_CHAR + _messageDigestAlgorithm;
1:         } else {
1:             // Salt and/or multiple iterations was used, so we need to add
1:             // those parameters to the token in order to verify the credentials
1:             // later.
1:             return ID_PATTERN_CONFIGURABLE_STRETCHED_SCHEME +
1:                 stringDigest +
1:                 SEPARATOR_CHAR + StringUtil.toHexString( _salt, 0, _salt.length) +
1:                 SEPARATOR_CHAR + _iterations + SEPARATOR_CHAR + _messageDigestAlgorithm;
1:         }
1:     }
1: }
============================================================================