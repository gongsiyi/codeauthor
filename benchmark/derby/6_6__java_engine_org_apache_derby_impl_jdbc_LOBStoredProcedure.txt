1:6aa0b12: /*
1:6aa0b12: 
1:6aa0b12:    Derby - Class org.apache.derby.impl.jdbc.LOBStoredProcedure
1:6aa0b12: 
1:6aa0b12:    Licensed to the Apache Software Foundation (ASF) under one or more
1:6aa0b12:    contributor license agreements.  See the NOTICE file distributed with
1:6aa0b12:    this work for additional information regarding copyright ownership.
1:6aa0b12:    The ASF licenses this file to you under the Apache License, Version 2.0
1:6aa0b12:    (the "License"); you may not use this file except in compliance with
1:6aa0b12:    the License.  You may obtain a copy of the License at
1:6aa0b12: 
1:6aa0b12:       http://www.apache.org/licenses/LICENSE-2.0
1:6aa0b12: 
1:6aa0b12:    Unless required by applicable law or agreed to in writing, software
1:6aa0b12:    distributed under the License is distributed on an "AS IS" BASIS,
1:6aa0b12:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:6aa0b12:    See the License for the specific language governing permissions and
1:6aa0b12:    limitations under the License.
1:6aa0b12: 
1:6aa0b12:  */
1:6aa0b12: 
1:6aa0b12: package org.apache.derby.impl.jdbc;
1:6aa0b12: 
1:6aa0b12: import java.sql.Blob;
1:6aa0b12: import java.sql.Clob;
1:6aa0b12: import java.sql.SQLException;
1:6aa0b12: 
1:1d6c1a5: import org.apache.derby.iapi.jdbc.EngineLOB;
1:46244ea: import org.apache.derby.iapi.reference.Limits;
1:6aa0b12: import org.apache.derby.iapi.reference.SQLState;
1:a452105: import org.apache.derby.jdbc.InternalDriver;
1:6aa0b12: 
1:6aa0b12: /**
1:6aa0b12:  * Contains the stored procedures that will be used in the
1:6aa0b12:  * LOB client side methods.
1:6aa0b12:  */
1:6aa0b12: public class LOBStoredProcedure {
1:6aa0b12: 
1:6aa0b12:     /**
1:6aa0b12:      * Creates a new empty Clob and registers it in the HashMap in the
1:6aa0b12:      * Connection and returns the locator value corresponding to this Clob.
1:6aa0b12:      * @return an integer that maps to the Clob value created.
1:b9d138d:      * @throws SQLException
1:6aa0b12:      */
1:6aa0b12:     public static int CLOBCREATELOCATOR() throws SQLException {
1:1d6c1a5:         EngineLOB clob = (EngineLOB)getEmbedConnection().createClob();
1:456b8a1:         return clob.getLocator();
1:6aa0b12:     }
1:6aa0b12: 
1:6aa0b12:     /**
1:6aa0b12:      * Removes the supplied LOCATOR entry from the hash map.
1:6aa0b12:      * @param LOCATOR an integer that represents the locator that needs to be
1:6aa0b12:      *                removed from the hash map.
1:b9d138d:      * @throws SQLException
1:6aa0b12:      */
1:6aa0b12:     public static void CLOBRELEASELOCATOR(int LOCATOR) throws SQLException {
1:6aa0b12:         Clob clob = (Clob)getEmbedConnection().getLOBMapping(LOCATOR);
1:6aa0b12:         if (clob == null) {
1:45a4a1d:             // DERBY-5605. Do not throw exception if already freed.
1:45a4a1d:             return;
1:6aa0b12:         }
1:6aa0b12:         EmbedClob embedClob = (EmbedClob)clob;
1:6aa0b12:         embedClob.free();
1:6aa0b12:         getEmbedConnection().removeLOBMapping(LOCATOR);
1:6aa0b12:     }
1:6aa0b12: 
1:6aa0b12:     /**
1:6aa0b12:      * returns the first occurrence of the given search string from the
1:6aa0b12:      * given start search position inside the Clob.
1:6aa0b12:      *
1:6aa0b12:      * @param LOCATOR an integer that represents the locator of the Clob
1:6aa0b12:      *                in which the given position of the given sub-string
1:6aa0b12:      *                needs to be found.
1:6aa0b12:      *
1:6aa0b12:      * @param searchLiteral a String whose occurence inside the Clob needs to
1:6aa0b12:      *                      be found starting from pos.
1:6aa0b12:      *
1:4ef879d:      * @param fromPosition an integer that represents the position inside
1:4ef879d:      *         the Clob from which the search needs to begin.
1:6aa0b12:      *
1:6aa0b12:      * @return an integer that represents the position inside the Clob of the
1:6aa0b12:      *         first occurrence of the sub-string from the given starting
1:6aa0b12:      *         position.
1:6aa0b12:      *
1:b9d138d:      * @throws SQLException
1:6aa0b12:      */
1:6aa0b12:     public static long CLOBGETPOSITIONFROMSTRING(int LOCATOR, String searchLiteral,
1:6aa0b12:         long fromPosition) throws SQLException {
1:6aa0b12:         return getClobObjectCorrespondingtoLOCATOR(LOCATOR).
1:6aa0b12:             position(searchLiteral, fromPosition);
1:6aa0b12:     }
1:6aa0b12: 
1:6aa0b12:     /**
1:6aa0b12:      * returns the first occurrence of the given search string from the
1:6aa0b12:      * given start search position inside the Clob.
1:6aa0b12:      *
1:6aa0b12:      * @param LOCATOR an integer that represents the locator of the Clob
1:6aa0b12:      *                in which the given position of the given sub-string
1:6aa0b12:      *                needs to be found.
1:6aa0b12:      *
1:6aa0b12:      * @param searchLocator a Locator representing a Clob whose occurence inside
1:6aa0b12:      *                      the Clob needs to be found starting from pos.
1:6aa0b12:      *
1:4ef879d:      * @param fromPosition an integer that represents the position inside
1:4ef879d:      *         the Clob from which the search needs to begin.
1:6aa0b12:      *
1:6aa0b12:      * @return an integer that represents the position inside the Clob of the
1:6aa0b12:      *         first occurrence of the sub-string from the given starting
1:6aa0b12:      *         position.
1:6aa0b12:      *
1:b9d138d:      * @throws SQLException
1:6aa0b12:      */
1:6aa0b12:     public static long CLOBGETPOSITIONFROMLOCATOR(int LOCATOR, int searchLocator,
1:6aa0b12:         long fromPosition) throws SQLException {
1:6aa0b12:         return getClobObjectCorrespondingtoLOCATOR(LOCATOR).position(
1:6aa0b12:             getClobObjectCorrespondingtoLOCATOR(searchLocator), fromPosition);
1:6aa0b12:     }
1:6aa0b12: 
1:6aa0b12:     /**
1:6aa0b12:      * returns the length of the Clob corresponding to the LOCATOR value.
1:6aa0b12:      *
1:6aa0b12:      * @param LOCATOR an integer that represents the locator of the Clob whose
1:6aa0b12:      *        length needs to be obtained.
1:6aa0b12:      * @return an integer that represents the length of the Clob.
1:b9d138d:      * @throws java.sql.SQLException 
1:6aa0b12:      *
1:6aa0b12:      */
1:6aa0b12:     public static long CLOBGETLENGTH(int LOCATOR) throws SQLException {
1:6aa0b12:         return getClobObjectCorrespondingtoLOCATOR(LOCATOR).length();
1:6aa0b12:     }
1:6aa0b12: 
1:6aa0b12:     /**
1:46244ea:      * Returns the {@code String} starting from {@code pos} and consisting of
1:46244ea:      * up to {@code len} consecutive characters from the {@code Clob}
1:46244ea:      * corresponding to {@code LOCATOR}.
1:46244ea:      *
1:6aa0b12:      * @param LOCATOR an integer that represents the LOCATOR used
1:6aa0b12:      *                to retrieve an instance of the LOB.
1:6aa0b12:      * @param pos a long that represents the position from which
1:6aa0b12:      *            the substring begins.
1:46244ea:      * @param len an integer representing the maximum length of the substring.
1:46244ea:      *      The value will be reduced to the maximum allowed return length if
1:6ae5bb7:      *      required (see {@link Limits#MAX_CLOB_RETURN_LEN}).
1:46244ea:      * @return A substring from the {@code Clob} starting at the given position,
1:46244ea:      *      not longer than {@code len} characters.
1:b9d138d:      * @throws SQLException
1:6aa0b12:      */
1:6aa0b12:     public static String CLOBGETSUBSTRING(int LOCATOR,
1:6aa0b12:         long pos, int len) throws SQLException {
1:46244ea:         // Don't read more than what we can represent as a VARCHAR.
1:46244ea:         // See DERBY-3769.
1:a6532d0:         len = Math.min(len, Limits.MAX_CLOB_RETURN_LEN);
1:6aa0b12:         return getClobObjectCorrespondingtoLOCATOR(LOCATOR).getSubString(pos, len);
1:6aa0b12:     }
1:6aa0b12: 
1:6aa0b12:     /**
1:6aa0b12:      * replaces the characters starting at fromPosition and with length ForLength
1:6aa0b12:      *
1:6aa0b12:      * @param LOCATOR an integer that represents the locator of the Clob in which
1:6aa0b12:      *                the characters need to be replaced.
1:6aa0b12:      *
1:6aa0b12:      * @param pos an integer that represents the position inside the Clob from which
1:6aa0b12:      *            the string needs to be replaced.
1:6aa0b12:      *
1:6aa0b12:      * @param length the number of characters from the string that need to be used for
1:6aa0b12:      *               replacement.
1:6aa0b12:      *
1:6aa0b12:      * @param str the string from which the repalcement characters are built.
1:6aa0b12:      *
1:b9d138d:      * @throws SQLException
1:6aa0b12:      */
1:6aa0b12:     public static void CLOBSETSTRING(int LOCATOR, long pos, int length,
1:6aa0b12:         String str) throws SQLException {
1:6aa0b12:         getClobObjectCorrespondingtoLOCATOR(LOCATOR).setString(pos, str, 0, length);
1:6aa0b12:     }
1:6aa0b12: 
1:6aa0b12:     /**
1:6aa0b12:      * truncates the Clob value represented by LOCATOR to have a length
1:6aa0b12:      * of length.
1:6aa0b12:      *
1:6aa0b12:      * @param LOCATOR an integer that represents the LOCATOR used to retrieve an
1:6aa0b12:      *                instance of the LOB.
1:6aa0b12:      * @param length an integer that represents the length to which the Clob
1:6aa0b12:      *               must be truncated to.
1:b9d138d:      * @throws SQLException
1:6aa0b12:      */
1:6aa0b12:     public static void CLOBTRUNCATE(int LOCATOR, long length) throws SQLException {
1:6aa0b12:         getClobObjectCorrespondingtoLOCATOR(LOCATOR).truncate(length);
1:6aa0b12:     }
1:6aa0b12: 
1:6aa0b12:     /**
1:6aa0b12:      * returns the Clob object corresponding to the locator.
1:6aa0b12:      * @param LOCATOR an integer that represents the locator corresponding
1:6aa0b12:      *                to the Clob object requested.
1:6aa0b12:      * @return a Clob object that is mapped to the LOCATOR object passed in.
11:6aa0b12:      * @throws a SQLException.
1:6aa0b12:      */
1:6aa0b12:     private static Clob getClobObjectCorrespondingtoLOCATOR(int LOCATOR)
1:6aa0b12:     throws SQLException {
1:6aa0b12:         Clob clob = (Clob)getEmbedConnection().getLOBMapping(LOCATOR);
1:6aa0b12:         if (clob == null) {
3:6aa0b12:             throw newSQLException(SQLState.LOB_LOCATOR_INVALID);
1:6aa0b12:         }
1:6aa0b12:         return clob;
1:6aa0b12:     }
1:6aa0b12: 
1:6aa0b12:     /**
1:6aa0b12:      * Creates a new empty Blob and registers it in the HashMap in the
1:6aa0b12:      * Connection and returns the locator value corresponding to this Blob.
1:6aa0b12:      * @return an integer that maps to the Blob value created.
1:b9d138d:      * @throws SQLException
1:6aa0b12:      */
1:6aa0b12:     public static int BLOBCREATELOCATOR() throws SQLException {
1:1d6c1a5:         EngineLOB blob = (EngineLOB)getEmbedConnection().createBlob();
1:456b8a1:         return blob.getLocator();
1:6aa0b12:     }
1:6aa0b12: 
1:6aa0b12:     /**
1:6aa0b12:      * Removes the supplied LOCATOR entry from the hash map.
1:6aa0b12:      * @param LOCATOR an integer that represents the locator that needs to be
1:6aa0b12:      *                removed from the hash map.
1:b9d138d:      * @throws SQLException
1:6aa0b12:      */
1:6aa0b12:     public static void BLOBRELEASELOCATOR(int LOCATOR) throws SQLException {
1:6aa0b12:         Blob blob = (Blob)getEmbedConnection().getLOBMapping(LOCATOR);
1:6aa0b12:         if (blob == null) {
1:45a4a1d:             // DERBY-5605 - noop if already released. 
1:45a4a1d:             return;
1:6aa0b12:         }
1:6aa0b12:         EmbedBlob embedBlob = (EmbedBlob)blob;
1:6aa0b12:         embedBlob.free();
1:6aa0b12:         getEmbedConnection().removeLOBMapping(LOCATOR);
1:6aa0b12:     }
1:6aa0b12: 
1:6aa0b12:     /**
1:6aa0b12:      *
1:6aa0b12:      * Returns the first occurrence of locator in the Blob.
1:6aa0b12:      *
1:6aa0b12:      * @param LOCATOR the locator value of the Blob in which the seaching needs
1:6aa0b12:      *                to be done.
1:6aa0b12:      * @param searchLocator the locator value of the Blob whose position needs
1:6aa0b12:      *                      needs to be found.
1:6aa0b12:      * @param pos the position from which the seaching needs to be done.
1:6aa0b12:      * @return the position at which the first occurrence of the Blob is
1:6aa0b12:      *         found.
1:b9d138d:      * @throws SQLException
1:6aa0b12:      *
1:6aa0b12:      */
1:6aa0b12:     public static long BLOBGETPOSITIONFROMLOCATOR(int LOCATOR,
1:6aa0b12:         int searchLocator, long pos) throws SQLException {
1:6aa0b12:         return getBlobObjectCorrespondingtoLOCATOR(LOCATOR).position(
1:6aa0b12:             getBlobObjectCorrespondingtoLOCATOR(searchLocator), pos);
1:6aa0b12:     }
1:6aa0b12: 
1:6aa0b12:     /**
1:6aa0b12:      *
1:6aa0b12:      * Returns the first occurrence of the byte array in the Blob.
1:6aa0b12:      *
1:6aa0b12:      * @param LOCATOR the locator value of the Blob in which the seaching needs
1:6aa0b12:      *                to be done.
1:6aa0b12:      * @param searchBytes the byte array whose position needs needs to be found.
1:6aa0b12:      * @param pos the position from which the seaching needs to be done.
1:6aa0b12:      * @return the position at which the first occurrence of the Byte array is
1:6aa0b12:      *         found.
1:b9d138d:      * @throws SQLException
1:6aa0b12:      *
1:6aa0b12:      */
1:6aa0b12:     public static long BLOBGETPOSITIONFROMBYTES(int LOCATOR,
1:6aa0b12:         byte [] searchBytes, long pos) throws SQLException {
1:6aa0b12:         return getBlobObjectCorrespondingtoLOCATOR(LOCATOR).position(searchBytes, pos);
1:6aa0b12:     }
1:6aa0b12: 
1:6aa0b12:     /**
1:6aa0b12:      *
1:6aa0b12:      * Returns the length in bytes of the Blob.
1:6aa0b12:      *
1:6aa0b12:      * @param LOCATOR the locator value of the Blob whose length needs to
1:6aa0b12:      *                be found.
1:6aa0b12:      * @return the length of the Blob object mapped to the locator .
1:b9d138d:      * @throws SQLException
1:6aa0b12:      *
1:6aa0b12:      */
1:6aa0b12:     public static long BLOBGETLENGTH(int LOCATOR) throws SQLException {
1:6aa0b12:         return getBlobObjectCorrespondingtoLOCATOR(LOCATOR).length();
1:6aa0b12:     }
1:6aa0b12: 
1:6aa0b12:     /**
1:46244ea:      * Reads up to len bytes from the associated {@code Blob} and returns a
1:46244ea:      * byte array containing the bytes read.
2:1028de4:      * <p>
1:46244ea:      * Note that a smaller number of bytes than requested might be returned. The
1:46244ea:      * number of bytes returned can be found by checking the length of the
1:46244ea:      * returned byte array.
1:6aa0b12:      *
1:6aa0b12:      * @param LOCATOR the locator value of the Blob from which the byte array
1:6aa0b12:      *                needs to be retrieved.
1:46244ea:      * @param len the maximum number of bytes to read. The value will be
1:46244ea:      *      reduced to the maximum allowed return length if required
1:6ae5bb7:      *      (see {@link Limits#MAX_BLOB_RETURN_LEN}).
1:6aa0b12:      * @param pos the position from which the bytes from the Blob need to be
1:6aa0b12:      *            retrieved.
1:46244ea:      * @return A byte array containing the bytes read, starting from position
1:46244ea:      *      {@code pos} in the {@code Blob}.
1:b9d138d:      * @throws SQLException
1:6aa0b12:      *
1:6aa0b12:      */
1:6aa0b12:     public static byte[] BLOBGETBYTES(int LOCATOR, long pos, int len)
1:6aa0b12:     throws SQLException {
1:46244ea:         // Don't read more than what we can represent as a VARBINARY.
1:46244ea:         // See DERBY-3769.
1:a6532d0:         len = Math.min(len, Limits.MAX_BLOB_RETURN_LEN);
1:6aa0b12:         return getBlobObjectCorrespondingtoLOCATOR(LOCATOR).getBytes(pos, len);
1:6aa0b12:     }
1:6aa0b12: 
1:6aa0b12:     /**
1:6aa0b12:      *
1:6aa0b12:      * Replaces the bytes at pos with len bytes
1:6aa0b12:      *
1:6aa0b12:      * @param LOCATOR the integer that represents the Blob in which the bytes
1:6aa0b12:      *                need to be replaced.
1:6aa0b12:      * @param pos the position stating from which the byte replacement needs to
1:6aa0b12:      *            happen.
1:6aa0b12:      * @param len the number of bytes that need to be used in replacement.
1:6aa0b12:      * @param replaceBytes the byte array that contains the bytes that needs to
1:6aa0b12:      *                     be used for replacement.
1:b9d138d:      * @throws SQLException
1:6aa0b12:      *
1:6aa0b12:      */
1:6aa0b12:     public static void BLOBSETBYTES(int LOCATOR, long pos, int len,
1:6aa0b12:         byte [] replaceBytes) throws SQLException {
1:6aa0b12:         getBlobObjectCorrespondingtoLOCATOR(LOCATOR).setBytes
1:6aa0b12:             (pos, replaceBytes, 0, len);
1:6aa0b12:     }
1:6aa0b12: 
1:6aa0b12:     /**
1:6aa0b12:      * truncates the Blob value represented by LOCATOR to have a length
1:6aa0b12:      * of length.
1:6aa0b12:      *
1:6aa0b12:      * @param LOCATOR an integer that represents the LOCATOR used to retrieve an
1:6aa0b12:      *                instance of the LOB.
1:6aa0b12:      * @param length an integer that represents the length to which the Blob
1:6aa0b12:      *               must be truncated to.
1:b9d138d:      * @throws SQLException
1:6aa0b12:      */
1:6aa0b12:     public static void BLOBTRUNCATE(int LOCATOR, long length) throws SQLException {
1:6aa0b12:         getBlobObjectCorrespondingtoLOCATOR(LOCATOR).truncate(length);
1:6aa0b12:     }
1:6aa0b12: 
1:6aa0b12:     /**
1:6aa0b12:      * returns the Blob object corresponding to the locator.
1:6aa0b12:      * @param LOCATOR an integer that represents the locator corresponding
1:6aa0b12:      *                to the Blob object requested.
1:6aa0b12:      * @return a Blob object that is mapped to the LOCATOR object passed in.
1:b9d138d:      * @throws SQLException
1:6aa0b12:      */
1:6aa0b12:     private static Blob getBlobObjectCorrespondingtoLOCATOR(int LOCATOR)
1:6aa0b12:     throws SQLException {
1:6aa0b12:         Blob blob = (Blob)getEmbedConnection().getLOBMapping(LOCATOR);
1:6aa0b12:         if (blob == null) {
1:6aa0b12:             throw newSQLException(SQLState.LOB_LOCATOR_INVALID);
1:6aa0b12:         }
1:6aa0b12:         return blob;
1:6aa0b12:     }
1:6aa0b12: 
1:6aa0b12:     /**
1:6aa0b12:      * Returns the EmbedConnection object.
3:6aa0b12:      * @throws SQLException.
1:6aa0b12:      */
1:6aa0b12:     private static EmbedConnection getEmbedConnection() throws SQLException {
1:a452105:         //DERBY-4664 Do not use DriverManager("jdbc:default:connection") because
1:a452105:         // some other product's Driver might hijack our stored procedure.
1:a452105:         InternalDriver id = InternalDriver.activeDriver();
1:a452105:         if (id != null) { 
1:25c1e7b:             EmbedConnection conn = (EmbedConnection) id.connect( "jdbc:default:connection", null, 0 );
1:a452105:             if (conn != null)
1:a452105:                 return conn;
1:a452105:         }
1:a452105:         throw Util.noCurrentConnection();
1:a452105:         
1:6aa0b12:     }
1:6aa0b12: 
1:6aa0b12:     /**
1:6aa0b12:      * Generate the SQLException with the appropriate
1:6aa0b12:      * SQLState.
1:6aa0b12:      *
1:6aa0b12:      * @param messageId The messageId of the message associated with this message.
1:6aa0b12:      * @return a SQLEXception.
1:6aa0b12:      */
1:6aa0b12:     private static SQLException newSQLException(String messageId) {
1:6aa0b12:         return Util.generateCsSQLException(messageId);
1:6aa0b12:     }
1:6aa0b12: }
============================================================================
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:45a4a1d
/////////////////////////////////////////////////////////////////////////
1:             // DERBY-5605. Do not throw exception if already freed.
1:             return;
/////////////////////////////////////////////////////////////////////////
1:             // DERBY-5605 - noop if already released. 
1:             return;
commit:a452105
/////////////////////////////////////////////////////////////////////////
0: import java.sql.Connection;
1: import org.apache.derby.jdbc.InternalDriver;
/////////////////////////////////////////////////////////////////////////
1:         //DERBY-4664 Do not use DriverManager("jdbc:default:connection") because
1:         // some other product's Driver might hijack our stored procedure.
1:         InternalDriver id = InternalDriver.activeDriver();
1:         if (id != null) { 
0:             EmbedConnection conn = (EmbedConnection) id.connect("jdbc:default:connection", null);
1:             if (conn != null)
1:                 return conn;
1:         }
1:         throw Util.noCurrentConnection();
1:         
commit:456b8a1
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.jdbc.EngineBlob;
0: import org.apache.derby.iapi.jdbc.EngineClob;
/////////////////////////////////////////////////////////////////////////
0:         EngineClob clob = (EngineClob) getEmbedConnection().createClob();
1:         return clob.getLocator();
/////////////////////////////////////////////////////////////////////////
0:         EngineBlob blob = (EngineBlob) getEmbedConnection().createBlob();
1:         return blob.getLocator();
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:25c1e7b
/////////////////////////////////////////////////////////////////////////
1:             EmbedConnection conn = (EmbedConnection) id.connect( "jdbc:default:connection", null, 0 );
commit:b6d2a1c
/////////////////////////////////////////////////////////////////////////
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:6ae5bb7
/////////////////////////////////////////////////////////////////////////
1:      *      required (see {@link Limits#MAX_CLOB_RETURN_LEN}).
/////////////////////////////////////////////////////////////////////////
1:      *      (see {@link Limits#MAX_BLOB_RETURN_LEN}).
commit:a6532d0
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         len = Math.min(len, Limits.MAX_CLOB_RETURN_LEN);
/////////////////////////////////////////////////////////////////////////
1:         len = Math.min(len, Limits.MAX_BLOB_RETURN_LEN);
commit:6aa0b12
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derby.impl.jdbc.LOBStoredProcedure
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derby.impl.jdbc;
1: 
1: import java.sql.Blob;
0: import java.sql.Connection;
1: import java.sql.Clob;
0: import java.sql.DriverManager;
1: import java.sql.SQLException;
1: 
1: import org.apache.derby.iapi.reference.SQLState;
1: 
1: /**
1:  * Contains the stored procedures that will be used in the
1:  * LOB client side methods.
1:  */
1: public class LOBStoredProcedure {
1: 
1:     /**
1:      * Creates a new empty Clob and registers it in the HashMap in the
1:      * Connection and returns the locator value corresponding to this Clob.
1:      * @return an integer that maps to the Clob value created.
1:      * @throws a SQLException.
1:      */
1:     public static int CLOBCREATELOCATOR() throws SQLException {
0:         Clob clob = getEmbedConnection().createClob();
0:         return getEmbedConnection().addLOBMapping(clob);
1:     }
1: 
1:     /**
1:      * Removes the supplied LOCATOR entry from the hash map.
1:      * @param LOCATOR an integer that represents the locator that needs to be
1:      *                removed from the hash map.
1:      * @throws SQLException.
1:      */
1:     public static void CLOBRELEASELOCATOR(int LOCATOR) throws SQLException {
1:         Clob clob = (Clob)getEmbedConnection().getLOBMapping(LOCATOR);
1:         if (clob == null) {
1:             throw newSQLException(SQLState.LOB_LOCATOR_INVALID);
1:         }
1:         EmbedClob embedClob = (EmbedClob)clob;
1:         embedClob.free();
1:         getEmbedConnection().removeLOBMapping(LOCATOR);
1:     }
1: 
1:     /**
1:      * returns the first occurrence of the given search string from the
1:      * given start search position inside the Clob.
1:      *
1:      * @param LOCATOR an integer that represents the locator of the Clob
1:      *                in which the given position of the given sub-string
1:      *                needs to be found.
1:      *
1:      * @param searchLiteral a String whose occurence inside the Clob needs to
1:      *                      be found starting from pos.
1:      *
0:      * @param pos an integer that represents the position inside the Clob from
0:      *            which the search needs to begin.
1:      *
1:      * @return an integer that represents the position inside the Clob of the
1:      *         first occurrence of the sub-string from the given starting
1:      *         position.
1:      *
0:      * @throws an SQLException
1:      */
1:     public static long CLOBGETPOSITIONFROMSTRING(int LOCATOR, String searchLiteral,
1:         long fromPosition) throws SQLException {
1:         return getClobObjectCorrespondingtoLOCATOR(LOCATOR).
1:             position(searchLiteral, fromPosition);
1:     }
1: 
1:     /**
1:      * returns the first occurrence of the given search string from the
1:      * given start search position inside the Clob.
1:      *
1:      * @param LOCATOR an integer that represents the locator of the Clob
1:      *                in which the given position of the given sub-string
1:      *                needs to be found.
1:      *
1:      * @param searchLocator a Locator representing a Clob whose occurence inside
1:      *                      the Clob needs to be found starting from pos.
1:      *
0:      * @param pos an integer that represents the position inside the Clob from
0:      *            which the search needs to begin.
1:      *
1:      * @return an integer that represents the position inside the Clob of the
1:      *         first occurrence of the sub-string from the given starting
1:      *         position.
1:      *
0:      * @throws an SQLException
1:      */
1:     public static long CLOBGETPOSITIONFROMLOCATOR(int LOCATOR, int searchLocator,
1:         long fromPosition) throws SQLException {
1:         return getClobObjectCorrespondingtoLOCATOR(LOCATOR).position(
1:             getClobObjectCorrespondingtoLOCATOR(searchLocator), fromPosition);
1:     }
1: 
1:     /**
1:      * returns the length of the Clob corresponding to the LOCATOR value.
1:      *
1:      * @param LOCATOR an integer that represents the locator of the Clob whose
1:      *        length needs to be obtained.
1:      * @return an integer that represents the length of the Clob.
1:      *
1:      */
1:     public static long CLOBGETLENGTH(int LOCATOR) throws SQLException {
1:         return getClobObjectCorrespondingtoLOCATOR(LOCATOR).length();
1:     }
1: 
1:     /**
0:      * returns the String starting from pos and of len length
0:      * from the LOB corresponding to LOCATOR.
0:      * @param LOCATOR_TYPE an integer that defines if the LOCATOR is
0:      *                     a CLOB or a BLOB locator.
1:      * @param LOCATOR an integer that represents the LOCATOR used
1:      *                to retrieve an instance of the LOB.
1:      * @param pos a long that represents the position from which
1:      *            the substring begins.
0:      * @param len an integer that represents the length of the substring.
0:      * @return the substring conforming to the indexes we requested for from
0:      *         inside the LOB.
0:      * @throws a SQLException
1:      */
1:     public static String CLOBGETSUBSTRING(int LOCATOR,
1:         long pos, int len) throws SQLException {
1:         return getClobObjectCorrespondingtoLOCATOR(LOCATOR).getSubString(pos, len);
1:     }
1: 
1:     /**
1:      * replaces the characters starting at fromPosition and with length ForLength
1:      *
1:      * @param LOCATOR an integer that represents the locator of the Clob in which
1:      *                the characters need to be replaced.
1:      *
1:      * @param pos an integer that represents the position inside the Clob from which
1:      *            the string needs to be replaced.
1:      *
1:      * @param length the number of characters from the string that need to be used for
1:      *               replacement.
1:      *
1:      * @param str the string from which the repalcement characters are built.
1:      *
0:      * @throws an SQLException.
1:      */
1:     public static void CLOBSETSTRING(int LOCATOR, long pos, int length,
1:         String str) throws SQLException {
0:         //Temporary code that will insert a clob with data into
0:         //the hashmap and will allow the testing of the locator
0:         //stored procedures.
0:         //This code will be removed once the set methods are implemented.
0:         java.util.HashMap hm = getEmbedConnection().getlobHMObj();
0:         EmbedClob clob = new EmbedClob(str, getEmbedConnection());
0:         hm.remove(new Integer(LOCATOR));
0:         hm.put(new Integer(LOCATOR), clob);
1:         getClobObjectCorrespondingtoLOCATOR(LOCATOR).setString(pos, str, 0, length);
1:     }
1: 
1:     /**
1:      * truncates the Clob value represented by LOCATOR to have a length
1:      * of length.
1:      *
1:      * @param LOCATOR an integer that represents the LOCATOR used to retrieve an
1:      *                instance of the LOB.
1:      * @param length an integer that represents the length to which the Clob
1:      *               must be truncated to.
1:      * @throws a SQLException.
1:      */
1:     public static void CLOBTRUNCATE(int LOCATOR, long length) throws SQLException {
1:         getClobObjectCorrespondingtoLOCATOR(LOCATOR).truncate(length);
1:     }
1: 
1:     /**
1:      * returns the Clob object corresponding to the locator.
1:      * @param LOCATOR an integer that represents the locator corresponding
1:      *                to the Clob object requested.
1:      * @return a Clob object that is mapped to the LOCATOR object passed in.
1:      * @throws a SQLException.
1:      */
1:     private static Clob getClobObjectCorrespondingtoLOCATOR(int LOCATOR)
1:     throws SQLException {
1:         Clob clob = (Clob)getEmbedConnection().getLOBMapping(LOCATOR);
1:         if (clob == null) {
1:             throw newSQLException(SQLState.LOB_LOCATOR_INVALID);
1:         }
1:         return clob;
1:     }
1: 
1:     /**
1:      * Creates a new empty Blob and registers it in the HashMap in the
1:      * Connection and returns the locator value corresponding to this Blob.
1:      * @return an integer that maps to the Blob value created.
1:      * @throws a SQLException.
1:      */
1:     public static int BLOBCREATELOCATOR() throws SQLException {
0:         Blob blob = getEmbedConnection().createBlob();
0:         return getEmbedConnection().addLOBMapping(blob);
1:     }
1: 
1:     /**
1:      * Removes the supplied LOCATOR entry from the hash map.
1:      * @param LOCATOR an integer that represents the locator that needs to be
1:      *                removed from the hash map.
1:      * @throws SQLException.
1:      */
1:     public static void BLOBRELEASELOCATOR(int LOCATOR) throws SQLException {
1:         Blob blob = (Blob)getEmbedConnection().getLOBMapping(LOCATOR);
1:         if (blob == null) {
1:             throw newSQLException(SQLState.LOB_LOCATOR_INVALID);
1:         }
1:         EmbedBlob embedBlob = (EmbedBlob)blob;
1:         embedBlob.free();
1:         getEmbedConnection().removeLOBMapping(LOCATOR);
1:     }
1: 
1:     /**
1:      *
1:      * Returns the first occurrence of locator in the Blob.
1:      *
1:      * @param LOCATOR the locator value of the Blob in which the seaching needs
1:      *                to be done.
1:      * @param searchLocator the locator value of the Blob whose position needs
1:      *                      needs to be found.
1:      * @param pos the position from which the seaching needs to be done.
1:      * @return the position at which the first occurrence of the Blob is
1:      *         found.
1:      * @throws a SQLException.
1:      *
1:      */
1:     public static long BLOBGETPOSITIONFROMLOCATOR(int LOCATOR,
1:         int searchLocator, long pos) throws SQLException {
1:         return getBlobObjectCorrespondingtoLOCATOR(LOCATOR).position(
1:             getBlobObjectCorrespondingtoLOCATOR(searchLocator), pos);
1:     }
1: 
1:     /**
1:      *
1:      * Returns the first occurrence of the byte array in the Blob.
1:      *
1:      * @param LOCATOR the locator value of the Blob in which the seaching needs
1:      *                to be done.
1:      * @param searchBytes the byte array whose position needs needs to be found.
1:      * @param pos the position from which the seaching needs to be done.
1:      * @return the position at which the first occurrence of the Byte array is
1:      *         found.
1:      * @throws a SQLException.
1:      *
1:      */
1:     public static long BLOBGETPOSITIONFROMBYTES(int LOCATOR,
1:         byte [] searchBytes, long pos) throws SQLException {
1:         return getBlobObjectCorrespondingtoLOCATOR(LOCATOR).position(searchBytes, pos);
1:     }
1: 
1:     /**
1:      *
1:      * Returns the length in bytes of the Blob.
1:      *
1:      * @param LOCATOR the locator value of the Blob whose length needs to
1:      *                be found.
1:      * @return the length of the Blob object mapped to the locator .
1:      * @throws a SQLException.
1:      *
1:      */
1:     public static long BLOBGETLENGTH(int LOCATOR) throws SQLException {
1:         return getBlobObjectCorrespondingtoLOCATOR(LOCATOR).length();
1:     }
1: 
1:     /**
0:      * Returns the Byte array containing the bytes starting from pos and
0:      * of length len
1:      *
1:      * @param LOCATOR the locator value of the Blob from which the byte array
1:      *                needs to be retrieved.
0:      * @param len the length of te byte array that needs to be retrieved from
0:      *            pos
1:      * @param pos the position from which the bytes from the Blob need to be
1:      *            retrieved.
0:      * @return a byte array containing the bytes stating from pos and
0:      *         of length len.
1:      * @throws a SQLException.
1:      *
1:      */
1:     public static byte[] BLOBGETBYTES(int LOCATOR, long pos, int len)
1:     throws SQLException {
1:         return getBlobObjectCorrespondingtoLOCATOR(LOCATOR).getBytes(pos, len);
1:     }
1: 
1:     /**
1:      *
1:      * Replaces the bytes at pos with len bytes
1:      *
1:      * @param LOCATOR the integer that represents the Blob in which the bytes
1:      *                need to be replaced.
1:      * @param pos the position stating from which the byte replacement needs to
1:      *            happen.
1:      * @param len the number of bytes that need to be used in replacement.
1:      * @param replaceBytes the byte array that contains the bytes that needs to
1:      *                     be used for replacement.
0:      * @return the number of bytes that have been replaced.
1:      * @throws a SQLException.
1:      *
1:      */
1:     public static void BLOBSETBYTES(int LOCATOR, long pos, int len,
1:         byte [] replaceBytes) throws SQLException {
1:         getBlobObjectCorrespondingtoLOCATOR(LOCATOR).setBytes
1:             (pos, replaceBytes, 0, len);
1:     }
1: 
1:     /**
1:      * truncates the Blob value represented by LOCATOR to have a length
1:      * of length.
1:      *
1:      * @param LOCATOR an integer that represents the LOCATOR used to retrieve an
1:      *                instance of the LOB.
1:      * @param length an integer that represents the length to which the Blob
1:      *               must be truncated to.
1:      * @throws a SQLException.
1:      */
1:     public static void BLOBTRUNCATE(int LOCATOR, long length) throws SQLException {
1:         getBlobObjectCorrespondingtoLOCATOR(LOCATOR).truncate(length);
1:     }
1: 
1:     /**
1:      * returns the Blob object corresponding to the locator.
1:      * @param LOCATOR an integer that represents the locator corresponding
1:      *                to the Blob object requested.
1:      * @return a Blob object that is mapped to the LOCATOR object passed in.
1:      * @throws a SQLException.
1:      */
1:     private static Blob getBlobObjectCorrespondingtoLOCATOR(int LOCATOR)
1:     throws SQLException {
1:         Blob blob = (Blob)getEmbedConnection().getLOBMapping(LOCATOR);
1:         if (blob == null) {
1:             throw newSQLException(SQLState.LOB_LOCATOR_INVALID);
1:         }
1:         return blob;
1:     }
1: 
1:     /**
1:      * Returns the EmbedConnection object.
1:      * @throws SQLException.
1:      */
1:     private static EmbedConnection getEmbedConnection() throws SQLException {
0:         return (EmbedConnection)DriverManager
0:             .getConnection("jdbc:default:connection");
1:     }
1: 
1:     /**
1:      * Generate the SQLException with the appropriate
1:      * SQLState.
1:      *
1:      * @param messageId The messageId of the message associated with this message.
1:      * @return a SQLEXception.
1:      */
1:     private static SQLException newSQLException(String messageId) {
1:         return Util.generateCsSQLException(messageId);
1:     }
1: }
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:1028de4
/////////////////////////////////////////////////////////////////////////
0:      * The maximum length of the data returned from the BLOB stored procedures.
0:     public static final int MAX_BLOB_RETURN_LEN = Limits.DB2_VARCHAR_MAXWIDTH;
0: 
0:     /**
0:      * The maximum length of the data returned from the CLOB stored procedures.
1:      * <p>
0:      * This value is currently dictated by the maximum length of
0:      * VARCHAR/VARBINARY, because these are the return types of the stored
0:      * procedures, and the modified UTF8 encoding used for CLOB data. This
0:      * threshold value could be higher (equal to {@code MAX_BLOB_RETURN_LEN}),
0:      * but then the procedure fetching data from the CLOB must be rewritten to
0:      * have more logic.
1:      * <p>
0:      * For now we use the defensive assumption that all characters are
0:      * represented by three bytes.
0:      */
0:     public static final int MAX_CLOB_RETURN_LEN = MAX_BLOB_RETURN_LEN / 3;
/////////////////////////////////////////////////////////////////////////
0:      *      required (see {@link #MAX_CLOB_RETURN_LEN}).
/////////////////////////////////////////////////////////////////////////
0:         len = Math.min(len, MAX_CLOB_RETURN_LEN);
/////////////////////////////////////////////////////////////////////////
0:      *      (see {@link #MAX_BLOB_RETURN_LEN}).
/////////////////////////////////////////////////////////////////////////
0:         len = Math.min(len, MAX_BLOB_RETURN_LEN);
commit:46244ea
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.reference.Limits;
/////////////////////////////////////////////////////////////////////////
0:      * The maximum length of the data returned from the LOB stored procedures.
0:      * <p>
0:      * This value is currently dictated by the maximum length of
0:      * VARCHAR/VARBINARY, because these are the return types of the stored
0:      * procedures.
0:      */
0:     public static final int MAX_RETURN_LENGTH = Limits.DB2_VARCHAR_MAXWIDTH;
0: 
0:     /**
/////////////////////////////////////////////////////////////////////////
1:      * Returns the {@code String} starting from {@code pos} and consisting of
1:      * up to {@code len} consecutive characters from the {@code Clob}
1:      * corresponding to {@code LOCATOR}.
1:      *
1:      * @param len an integer representing the maximum length of the substring.
1:      *      The value will be reduced to the maximum allowed return length if
0:      *      required (see {@link #MAX_RETURN_LENGTH}).
1:      * @return A substring from the {@code Clob} starting at the given position,
1:      *      not longer than {@code len} characters.
1:         // Don't read more than what we can represent as a VARCHAR.
1:         // See DERBY-3769.
0:         len = Math.min(len, MAX_RETURN_LENGTH);
/////////////////////////////////////////////////////////////////////////
1:      * Reads up to len bytes from the associated {@code Blob} and returns a
1:      * byte array containing the bytes read.
0:      * <p>
1:      * Note that a smaller number of bytes than requested might be returned. The
1:      * number of bytes returned can be found by checking the length of the
1:      * returned byte array.
1:      * @param len the maximum number of bytes to read. The value will be
1:      *      reduced to the maximum allowed return length if required
0:      *      (see {@link #MAX_RETURN_LENGTH}).
1:      * @return A byte array containing the bytes read, starting from position
1:      *      {@code pos} in the {@code Blob}.
1:         // Don't read more than what we can represent as a VARBINARY.
1:         // See DERBY-3769.
0:         len = Math.min(len, MAX_RETURN_LENGTH);
commit:1d6c1a5
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.jdbc.EngineLOB;
/////////////////////////////////////////////////////////////////////////
1:         EngineLOB clob = (EngineLOB)getEmbedConnection().createClob();
/////////////////////////////////////////////////////////////////////////
1:         EngineLOB blob = (EngineLOB)getEmbedConnection().createBlob();
author:Oystein Grovlen
-------------------------------------------------------------------------------
commit:b9d138d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:      * @throws SQLException
/////////////////////////////////////////////////////////////////////////
1:      * @throws SQLException
/////////////////////////////////////////////////////////////////////////
1:      * @throws SQLException
/////////////////////////////////////////////////////////////////////////
1:      * @throws SQLException
/////////////////////////////////////////////////////////////////////////
1:      * @throws java.sql.SQLException 
/////////////////////////////////////////////////////////////////////////
1:      * @throws SQLException
/////////////////////////////////////////////////////////////////////////
1:      * @throws SQLException
/////////////////////////////////////////////////////////////////////////
1:      * @throws SQLException
/////////////////////////////////////////////////////////////////////////
1:      * @throws SQLException
/////////////////////////////////////////////////////////////////////////
1:      * @throws SQLException
/////////////////////////////////////////////////////////////////////////
1:      * @throws SQLException
/////////////////////////////////////////////////////////////////////////
1:      * @throws SQLException
/////////////////////////////////////////////////////////////////////////
1:      * @throws SQLException
/////////////////////////////////////////////////////////////////////////
0:      * @param len the length of the byte array that needs to be retrieved from
1:      * @throws SQLException
/////////////////////////////////////////////////////////////////////////
1:      * @throws SQLException
/////////////////////////////////////////////////////////////////////////
1:      * @throws SQLException
/////////////////////////////////////////////////////////////////////////
1:      * @throws SQLException
author:Army
-------------------------------------------------------------------------------
commit:4ef879d
/////////////////////////////////////////////////////////////////////////
1:      * @param fromPosition an integer that represents the position inside
1:      *         the Clob from which the search needs to begin.
/////////////////////////////////////////////////////////////////////////
1:      * @param fromPosition an integer that represents the position inside
1:      *         the Clob from which the search needs to begin.
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
============================================================================