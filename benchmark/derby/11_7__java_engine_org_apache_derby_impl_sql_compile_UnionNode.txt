4:eac0369: /*
51:eac0369: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.compile.UnionNode
1:345de35: 
1:2d37fd6:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2d37fd6:    contributor license agreements.  See the NOTICE file distributed with
1:2d37fd6:    this work for additional information regarding copyright ownership.
1:2d37fd6:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2d37fd6:    (the "License"); you may not use this file except in compliance with
1:2d37fd6:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:345de35: 
31:eac0369:  */
1:eac0369: 
1:eac0369: package	org.apache.derby.impl.sql.compile;
1:eac0369: 
1:3bb140c: import java.util.Properties;
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:3bb140c: import org.apache.derby.iapi.reference.ClassName;
1:3bb140c: import org.apache.derby.iapi.reference.SQLState;
1:3bb140c: import org.apache.derby.iapi.services.classfile.VMOpcode;
1:3bb140c: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1:3bb140c: import org.apache.derby.iapi.services.context.ContextManager;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:3bb140c: import org.apache.derby.iapi.sql.compile.CostEstimate;
1:eac0369: import org.apache.derby.iapi.sql.compile.Optimizable;
1:eac0369: import org.apache.derby.iapi.sql.compile.OptimizablePredicateList;
1:eac0369: import org.apache.derby.iapi.sql.compile.Optimizer;
1:eac0369: import org.apache.derby.iapi.sql.compile.RowOrdering;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
2:eac0369: import org.apache.derby.iapi.types.DataTypeDescriptor;
1:eac0369: import org.apache.derby.iapi.util.JBitSet;
1:eac0369: 
17:eac0369: /**
1:eac0369:  * A UnionNode represents a UNION in a DML statement.  It contains a boolean
1:eac0369:  * telling whether the union operation should eliminate duplicate rows.
36:eac0369:  *
1:eac0369:  */
1:eac0369: 
1:3bb140c: class UnionNode extends SetOperatorNode
28:eac0369: {
1:6200b38: 	/* Only optimize it once */
1:eac0369: 	/* Only call addNewNodes() once */
1:eac0369: 	private boolean addNewNodesCalled;
1:eac0369: 
1:6200b38: 	/* Is this a UNION ALL generated for a table constructor -- a VALUES expression with multiple rows. */
1:eac0369: 	boolean			tableConstructor;
1:eac0369: 
1:eac0369: 	/* True if this is the top node of a table constructor */
1:eac0369: 	boolean			topTableConstructor;
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:3bb140c:      * Constructor for a UnionNode.
1:eac0369: 	 *
1:eac0369: 	 * @param leftResult		The ResultSetNode on the left side of this union
1:eac0369: 	 * @param rightResult		The ResultSetNode on the right side of this union
1:eac0369: 	 * @param all				Whether or not this is a UNION ALL.
1:eac0369: 	 * @param tableConstructor	Whether or not this is from a table constructor.
1:eac0369: 	 * @param tableProperties	Properties list associated with the table
1:eac0369: 	 *
13:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 
1:3bb140c:     UnionNode(ResultSetNode  leftResult,
1:3bb140c:               ResultSetNode  rightResult,
1:3bb140c:               boolean        all,
1:3bb140c:               boolean        tableConstructor,
1:3bb140c:               Properties     tableProperties,
1:3bb140c:               ContextManager cm) throws StandardException {
1:eac0369: 
1:3bb140c:         super(leftResult, rightResult, all, tableProperties, cm);
1:3bb140c: 
1:3bb140c:         // Is this a UNION ALL for a table constructor?
1:3bb140c:         this.tableConstructor = tableConstructor;
1:3bb140c:     }
1:eac0369: 
1:a8db665: 	/**
1:eac0369: 	 * Mark this as the top node of a table constructor.
1:eac0369: 	 */
1:3bb140c:     void markTopTableConstructor()
1:eac0369: 	{
1:eac0369: 		topTableConstructor = true;
27:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Tell whether this is a UNION for a table constructor.
1:eac0369: 	 */
1:eac0369: 	boolean tableConstructor()
1:eac0369: 	{
1:eac0369: 		return tableConstructor;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Check for (and reject) ? parameters directly under the ResultColumns.
1:eac0369: 	 * This is done for SELECT statements.  Don't reject parameters that
1:eac0369: 	 * are in a table constructor - these are allowed, as long as the
1:eac0369: 	 * table constructor is in an INSERT statement or each column of the
1:eac0369: 	 * table constructor has at least one non-? column.  The latter case
1:eac0369: 	 * is checked below, in bindExpressions().
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown if a ? parameter found
1:eac0369: 	 *									directly under a ResultColumn
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     void rejectParameters() throws StandardException
1:eac0369: 	{
1:eac0369: 		if ( ! tableConstructor())
1:eac0369: 			super.rejectParameters();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set the type of column in the result column lists of each
1:eac0369: 	 * source of this union tree to the type in the given result column list
1:eac0369: 	 * (which represents the result columns for an insert).
1:eac0369: 	 * This is only for table constructors that appear in insert statements.
1:eac0369: 	 *
1:eac0369: 	 * @param typeColumns	The ResultColumnList containing the desired result
1:eac0369: 	 *						types.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	void setTableConstructorTypes(ResultColumnList typeColumns)
12:eac0369: 			throws StandardException
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:11f7ee3: 			SanityManager.ASSERT(getResultColumns().size() <= typeColumns.size(),
1:eac0369: 				"More columns in ResultColumnList than in base table.");
1:eac0369: 		}
1:eac0369: 
2:eac0369: 		ResultSetNode	rsn;
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** Should only set types of ? parameters to types of result columns
1:eac0369: 		** if it's a table constructor.
1:eac0369: 		*/
1:eac0369: 		if (tableConstructor())
1:eac0369: 		{
1:eac0369: 			/* By looping through the union nodes, we avoid recursion */
3:eac0369: 			for (rsn = this; rsn instanceof UnionNode; )
1:eac0369: 			{
1:eac0369: 				UnionNode union = (UnionNode) rsn;
1:eac0369: 
1:eac0369: 				/*
1:eac0369: 				** Assume that table constructors are left-deep trees of UnionNodes
1:eac0369: 				** with RowResultSet nodes on the right.
1:eac0369: 				*/
1:eac0369: 				if (SanityManager.DEBUG)
1:eac0369: 					SanityManager.ASSERT(
2:eac0369: 						union.rightResultSet instanceof RowResultSetNode,
2:eac0369: 						"A " + union.rightResultSet.getClass().getName() +
1:eac0369: 						" is on the right of a union in a table constructor");
1:eac0369: 
1:eac0369: 				((RowResultSetNode) union.rightResultSet).setTableConstructorTypes(
1:eac0369: 																typeColumns);
1:eac0369: 
3:eac0369: 				rsn = union.leftResultSet;
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			/* The last node on the left should be a result set node */
1:eac0369: 			if (SanityManager.DEBUG)
1:eac0369: 				SanityManager.ASSERT(rsn instanceof RowResultSetNode,
1:eac0369: 					"A " + rsn.getClass().getName() +
1:eac0369: 					" is at the left end of a table constructor");
1:eac0369: 
1:eac0369: 			((RowResultSetNode) rsn).setTableConstructorTypes(typeColumns);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:a8db665: 	 * Make the RCL of this node match the target node for the insert. If this
1:a8db665: 	 * node represents a table constructor (a VALUES clause), we replace the
1:a8db665: 	 * RCL with an enhanced one if necessary, and recursively enhance the RCL
1:a8db665: 	 * of each child node. For table constructors, we also need to check that
1:a8db665: 	 * we don't attempt to override auto-increment columns in each child node
1:a8db665: 	 * (checking the top-level RCL isn't sufficient since a table constructor
1:a8db665: 	 * may contain the DEFAULT keyword, which makes it possible to specify a
1:a8db665: 	 * column without overriding its value).
1:a8db665: 	 *
1:a8db665: 	 * If this node represents a regular UNION, put a ProjectRestrictNode on
1:a8db665: 	 * top of this node and enhance the RCL in that node.
1:a8db665: 	 */
1:3bb140c:     @Override
1:a8db665: 	ResultSetNode enhanceRCLForInsert(
1:a8db665: 			InsertNode target, boolean inOrder, int[] colMap)
1:a8db665: 		throws StandardException
1:a8db665: 	{
1:a8db665: 		if (tableConstructor()) {
1:661c2e6: 			leftResultSet = target.enhanceAndCheckForAutoincrement
1:661c2e6:                 ( leftResultSet, inOrder, colMap, false );
1:661c2e6: 			rightResultSet = target.enhanceAndCheckForAutoincrement
1:661c2e6:                 ( rightResultSet, inOrder, colMap, false );
1:a8db665: 			if (!inOrder ||
1:11f7ee3:                 getResultColumns().size() < target.resultColumnList.size()) {
1:11f7ee3: 				setResultColumns( getRCLForInsert(target, colMap) );
1:a8db665: 			}
1:a8db665: 			return this;
1:a8db665: 		} else {
1:a8db665: 			// This is a regular UNION, so fall back to the default
1:a8db665: 			// implementation that adds a ProjectRestrictNode on top.
1:a8db665: 			return super.enhanceRCLForInsert(target, inOrder, colMap);
1:a8db665: 		}
1:a8db665: 	}
1:a8db665: 
1:eac0369: 	/*
1:eac0369: 	 *  Optimizable interface
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see org.apache.derby.iapi.sql.compile.Optimizable#optimizeIt
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	public CostEstimate optimizeIt(Optimizer optimizer,
1:eac0369: 							OptimizablePredicateList predList,
1:eac0369: 							CostEstimate outerCost,
1:eac0369: 							RowOrdering rowOrdering)
1:eac0369: 			throws StandardException
1:eac0369: 	{
1:eac0369: 		/*
1:eac0369: 		** RESOLVE: Most types of Optimizables only implement estimateCost(),
1:eac0369: 		** and leave it up to optimizeIt() in FromTable to figure out the
1:eac0369: 		** total cost of the join.  For unions, though, we want to figure out
1:eac0369: 		** the best plan for the sources knowing how many outer rows there are -
1:eac0369: 		** it could affect their strategies significantly.  So we implement
1:eac0369: 		** optimizeIt() here, which overrides the optimizeIt() in FromTable.
1:eac0369: 		** This assumes that the join strategy for which this union node is
1:eac0369: 		** the inner table is a nested loop join, which will not be a valid
1:eac0369: 		** assumption when we implement other strategies like materialization
1:eac0369: 		** (hash join can work only on base tables).
1:eac0369: 		*/
1:eac0369: 
1:eac0369: 		/* optimize() both resultSets */
1:eac0369: 
1:5872305: 		// If we have predicates from an outer block, we want to try
1:5872305: 		// to push them down to this node's children.  However, we can't
1:5872305: 		// just push the predicates down as they are; instead, we
1:5872305: 		// need to scope them for the child result sets first, and
1:5872305: 		// then push the scoped versions.  This is all done in the
1:5872305: 		// call to pushOptPredicate() here; for more, see that method's
1:e07631a: 		// definition in SetOperatorNode.  NOTE: If we're considering a
1:e07631a: 		// hash join then we do not push the predicates because we'll
1:e07631a: 		// need the predicates to be at this level in order to find
1:e07631a: 		// out if one of them is an equijoin predicate that can be used
1:e07631a: 		// for the hash join.
1:e07631a: 		if ((predList != null) &&
1:e07631a: 			!getCurrentAccessPath().getJoinStrategy().isHashJoin())
1:eac0369: 		{
1:5872305: 			for (int i = predList.size() - 1; i >= 0; i--) {
1:5872305: 				if (pushOptPredicate(predList.getOptPredicate(i)))
1:5872305: 					predList.removeOptPredicate(i);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:e07631a: 		// It's possible that a call to optimize the left/right will cause
1:e07631a: 		// a new "truly the best" plan to be stored in the underlying base
1:e07631a: 		// tables.  If that happens and then we decide to skip that plan
1:e07631a: 		// (which we might do if the call to "considerCost()" below decides
1:e07631a: 		// the current path is infeasible or not the best) we need to be
1:e07631a: 		// able to revert back to the "truly the best" plans that we had
1:e07631a: 		// saved before we got here.  So with this next call we save the
1:e07631a: 		// current plans using "this" node as the key.  If needed, we'll
1:e07631a: 		// then make the call to revert the plans in OptimizerImpl's
1:e07631a: 		// getNextDecoratedPermutation() method.
1:57abd06: 		updateBestPlanMap(ADD_PLAN, this);
1:eac0369: 
1:eac0369: 		leftResultSet = optimizeSource(
1:eac0369: 							optimizer,
1:eac0369: 							leftResultSet,
1:5872305: 							getLeftOptPredicateList(),
1:eac0369: 							outerCost);
1:eac0369: 
1:eac0369: 		rightResultSet = optimizeSource(
1:eac0369: 							optimizer,
1:eac0369: 							rightResultSet,
1:5872305: 							getRightOptPredicateList(),
1:eac0369: 							outerCost);
1:eac0369: 
1:3bb140c:         CostEstimate costEst = getCostEstimate(optimizer);
1:eac0369: 
1:eac0369: 		/* The cost is the sum of the two child costs */
1:3bb140c:         costEst.setCost(leftResultSet.getCostEstimate().getEstimatedCost(),
1:eac0369: 							 leftResultSet.getCostEstimate().rowCount(),
1:eac0369: 							 leftResultSet.getCostEstimate().singleScanRowCount() +
1:eac0369: 							 rightResultSet.getCostEstimate().singleScanRowCount());
1:eac0369: 
1:11f7ee3:         costEst.add(rightResultSet.getCostEstimate(), costEst);
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** Get the cost of this result set in the context of the whole plan.
1:eac0369: 		*/
1:eac0369: 		getCurrentAccessPath().
1:eac0369: 			getJoinStrategy().
1:eac0369: 				estimateCost(
2:eac0369: 							this,
1:eac0369: 							predList,
1:eac0369: 							(ConglomerateDescriptor) null,
1:eac0369: 							outerCost,
1:eac0369: 							optimizer,
1:3bb140c:                             costEst
1:eac0369: 							);
1:eac0369: 
1:3bb140c:         optimizer.considerCost(this, predList, costEst, outerCost);
1:eac0369: 
1:3bb140c:         return costEst;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:8091651: 	 * DERBY-649: Handle pushing predicates into UnionNodes. It is possible to push
1:8091651: 	 * single table predicates that are binaryOperations or inListOperations. 
1:eac0369: 	 *
1:8091651: 	 * Predicates of the form <columnReference> <RELOP> <constant> or <columnReference>
1:8091651: 	 * IN <constantList> are currently handled. Since these predicates would allow
1:8091651: 	 * optimizer to pick available indices, pushing them provides maximum benifit.
1:eac0369: 	 *
1:8091651: 	 * It should be possible to expand this logic to cover more cases. Even pushing
1:8091651: 	 * expressions (like a+b = 10) into SELECTs would improve performance, even if
1:8091651: 	 * they don't allow use of index. It would mean evaluating expressions closer to
1:8091651: 	 * data and hence could avoid sorting or other overheads that UNION may require.
1:eac0369: 	 *
1:c700973: 	 * Note that the predicates are not removed after pushing. This is to ensure if
1:c700973: 	 * pushing is not possible or only partially feasible.
1:eac0369: 	 *
1:8091651: 	 * @param 	predicateList		List of single table predicates to push
1:eac0369: 	 *
1:8091651: 	 * @exception	StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     void pushExpressions(PredicateList predicateList)
1:eac0369: 					throws StandardException
1:eac0369: 	{
1:c700973: 		// If left or right side is a UnionNode, further push the predicate list
1:c700973: 		// Note, it is OK not to push these predicates since they are also evaluated
1:8091651: 		// in the ProjectRestrictNode. There are other types of operations possible
1:8091651: 		// here in addition to UnionNode or SelectNode, like RowResultSetNode.
1:c700973: 		if (leftResultSet instanceof UnionNode)
1:c700973: 			((UnionNode)leftResultSet).pushExpressions(predicateList);
1:c700973: 		else if (leftResultSet instanceof SelectNode)
1:c700973: 			predicateList.pushExpressionsIntoSelect((SelectNode)leftResultSet, true);
1:eac0369: 
1:c700973: 		if (rightResultSet instanceof UnionNode)
1:c700973: 			((UnionNode)rightResultSet).pushExpressions(predicateList);
1:c700973: 		else if (rightResultSet instanceof SelectNode)
1:c700973: 			predicateList.pushExpressionsIntoSelect((SelectNode)rightResultSet, true);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see Optimizable#modifyAccessPath
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	public Optimizable modifyAccessPath(JBitSet outerTables) throws StandardException
1:eac0369: 	{
1:eac0369: 		Optimizable retOptimizable;
1:eac0369: 		retOptimizable = super.modifyAccessPath(outerTables);
1:eac0369: 
1:eac0369: 		/* We only want call addNewNodes() once */
1:eac0369: 		if (addNewNodesCalled)
1:eac0369: 		{
1:eac0369: 			return retOptimizable;
1:eac0369: 		}
1:eac0369: 		return (Optimizable) addNewNodes();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see ResultSetNode#modifyAccessPaths
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     ResultSetNode modifyAccessPaths() throws StandardException
1:eac0369: 	{
1:eac0369: 		ResultSetNode retRSN;
1:eac0369: 		retRSN = super.modifyAccessPaths();
1:eac0369: 
1:eac0369: 		/* We only want call addNewNodes() once */
1:eac0369: 		if (addNewNodesCalled)
1:eac0369: 		{
1:eac0369: 			return retRSN;
1:eac0369: 		}
1:eac0369: 		return addNewNodes();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Add any new ResultSetNodes that are necessary to the tree.
1:eac0369: 	 * We wait until after optimization to do this in order to
1:eac0369: 	 * make it easier on the optimizer.
1:eac0369: 	 *
1:eac0369: 	 * @return (Potentially new) head of the ResultSetNode tree.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	private ResultSetNode addNewNodes()
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		ResultSetNode treeTop = this;
1:eac0369: 
1:eac0369: 		/* Only call addNewNodes() once */
1:eac0369: 		if (addNewNodesCalled)
1:eac0369: 		{
1:eac0369: 			return this;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		addNewNodesCalled = true;
1:eac0369: 
1:eac0369: 		/* RESOLVE - We'd like to generate any necessary NormalizeResultSets
1:eac0369: 		 * above our children here, in the tree.  However, doing so causes
1:eac0369: 		 * the following query to fail because the where clause goes against
1:eac0369: 		 * the NRS instead of the Union:
1:eac0369: 		 *		SELECT TABLE_TYPE
1:eac0369: 		 *		FROM SYS.SYSTABLES, 
1:eac0369: 		 *			(VALUES ('T','TABLE') ,
1:eac0369: 		 *				('S','SYSTEM TABLE') , ('V', 'VIEW')) T(TTABBREV,TABLE_TYPE) 
1:eac0369: 		 *		WHERE TTABBREV=TABLETYPE;
1:eac0369: 		 * Thus, we are forced to skip over generating the nodes in the tree
1:eac0369: 		 * and directly generate the execution time code in generate() instead.
1:eac0369: 		 * This solves the problem for some unknown reason.
1:eac0369: 		 */
1:eac0369: 
1:eac0369: 		/* Simple solution (for now) to eliminating duplicates - 
1:eac0369: 		 * generate a distinct above the union.
1:eac0369: 		 */
1:eac0369: 		if (! all)
1:eac0369: 		{
1:eac0369: 			/* We need to generate a NormalizeResultSetNode above us if the column
1:eac0369: 			 * types and lengths don't match.  (We need to do it here, since they
1:eac0369: 			 * will end up agreeing in the PRN, which will be the immediate
1:eac0369: 			 * child of the DistinctNode, which means that the NormalizeResultSet
1:eac0369: 			 * won't get generated above the PRN.)
1:eac0369: 			 */
1:eac0369: 			if (! columnTypesAndLengthsMatch())
1:eac0369: 			{
1:3bb140c:                 treeTop = new NormalizeResultSetNode(
1:3bb140c:                         treeTop, null, null, false, getContextManager());
1:eac0369: 			}
1:eac0369: 
1:3bb140c:             treeTop = new DistinctNode(treeTop.genProjectRestrict(),
1:3bb140c:                                        false,
1:3bb140c:                                        tableProperties,
1:3bb140c:                                        getContextManager());
1:eac0369: 			/* HACK - propagate our table number up to the new DistinctNode
1:eac0369: 			 * so that arbitrary hash join will work correctly.  (Otherwise it
1:eac0369: 			 * could have a problem dividing up the predicate list at the end
1:eac0369: 			 * of modifyAccessPath() because the new child of the PRN above
1:eac0369: 			 * us would have a tableNumber of -1 instead of our tableNumber.)
1:eac0369: 			 */
1:eac0369: 			((FromTable)treeTop).setTableNumber(tableNumber);
1:11f7ee3: 			treeTop.setReferencedTableMap((JBitSet) getReferencedTableMap().clone());
1:eac0369: 			all = true;
1:eac0369: 		}
1:108305b: 
1:eac0369: 		/* Generate the OrderByNode if a sort is still required for
1:eac0369: 		 * the order by.
1:eac0369: 		 */
1:b4cda60:         for (int i=0; i < qec.size(); i++) {
1:b4cda60:             final OrderByList obl = qec.getOrderByList(i);
1:b4cda60: 
1:b4cda60:             if (obl != null)
1:4d044a3:             {
1:3bb140c:                 treeTop = new OrderByNode(treeTop,
1:b4cda60:                                           obl,
1:3bb140c:                                           tableProperties,
1:3bb140c:                                           getContextManager());
1:4d044a3:             }
1:108305b: 
1:4d044a3:             // Do this only after the main ORDER BY; any extra added by
1:b4cda60:             final ValueNode offset = qec.getOffset(i);
1:b4cda60:             final ValueNode fetchFirst = qec.getFetchFirst(i);
1:b4cda60: 
1:b4cda60:             if (offset != null || fetchFirst != null) {
1:4d044a3:                 ResultColumnList newRcl =
1:4d044a3:                         treeTop.getResultColumns().copyListAndObjects();
1:4d044a3:                 newRcl.genVirtualColumnNodes(treeTop,
1:4d044a3:                                              treeTop.getResultColumns());
1:108305b: 
1:3bb140c:                 treeTop = new RowCountNode(
2:4d044a3:                         treeTop,
1:4d044a3:                         newRcl,
1:4d044a3:                         offset,
1:4d044a3:                         fetchFirst,
1:b4cda60:                         qec.getHasJDBCLimitClause()[i].booleanValue(),
2:4d044a3:                         getContextManager());
1:4d044a3:             }
1:108305b:         }
1:108305b: 
1:eac0369: 		return treeTop;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
1:eac0369: 	 * for how this should be done for tree printing.
1:eac0369: 	 *
1:eac0369: 	 * @return	This object as a String
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	public String toString()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:6200b38: 			return 	"tableConstructor: " + tableConstructor + "\n" + super.toString();
1:eac0369: 		}
3:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return "";
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Bind the expressions under this TableOperatorNode.  This means
1:eac0369: 	 * binding the sub-expressions, as well as figuring out what the
1:eac0369: 	 * return type is for each expression.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	public void bindExpressions(FromList fromListParam)
1:eac0369: 				throws StandardException
1:eac0369: 	{
1:eac0369: 		super.bindExpressions(fromListParam);
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** Each ? parameter in a table constructor that is not in an insert
1:eac0369: 		** statement takes its type from the first non-? in its column
1:eac0369: 		** of the table constructor.  It's an error to have a column that
1:eac0369: 		** has all ?s.  Do this only for the top of the table constructor
1:eac0369: 		** list - we don't want to do this for every level of union node
1:eac0369: 		** in the table constructor.  Also, don't do this for an INSERT -
1:eac0369: 		** the types of the ? parameters come from the columns being inserted
1:eac0369: 		** into in that case.
1:eac0369: 		*/
1:11f7ee3: 		if (topTableConstructor && ( ! isInsertSource()) )
1:eac0369: 		{
1:eac0369: 			/*
1:eac0369: 			** Step through all the rows in the table constructor to
1:eac0369: 			** get the type of the first non-? in each column.
1:eac0369: 			*/
1:6200b38: 			DataTypeDescriptor[] types =
1:eac0369: 				new DataTypeDescriptor[leftResultSet.getResultColumns().size()];
1:eac0369: 			
1:6200b38: 			ResultSetNode rsn;
1:6200b38: 			int numTypes = 0;
1:eac0369: 
1:eac0369: 			/* By looping through the union nodes, we avoid recursion */
1:6200b38: 			for (rsn = this; rsn instanceof SetOperatorNode; )
1:eac0369: 			{
1:6200b38: 				SetOperatorNode		setOperator = (SetOperatorNode) rsn;
1:eac0369: 
1:eac0369: 				/*
1:eac0369: 				** Assume that table constructors are left-deep trees of
1:6200b38: 				** SetOperatorNodes with RowResultSet nodes on the right.
1:eac0369: 				*/
1:eac0369: 				if (SanityManager.DEBUG)
1:eac0369: 					SanityManager.ASSERT(
1:6200b38: 					 setOperator.rightResultSet instanceof RowResultSetNode,
1:6200b38: 					 "A " + setOperator.rightResultSet.getClass().getName() +
1:6200b38: 					 " is on the right side of a setOperator in a table constructor");
1:eac0369: 
2:eac0369: 				RowResultSetNode	rrsn =
1:6200b38: 										(RowResultSetNode) setOperator.rightResultSet;
1:eac0369: 
1:eac0369: 				numTypes += getParamColumnTypes(types, rrsn);
1:eac0369: 
1:6200b38: 				rsn = setOperator.leftResultSet;
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			/* The last node on the left should be a result set node */
1:eac0369: 			if (SanityManager.DEBUG)
1:eac0369: 				SanityManager.ASSERT(rsn instanceof RowResultSetNode);
1:eac0369: 
1:eac0369: 			numTypes += getParamColumnTypes(types, (RowResultSetNode) rsn);
1:eac0369: 
1:eac0369: 			/* Are there any columns that are all ? parameters? */
1:eac0369: 			if (numTypes < types.length)
1:eac0369: 			{
1:eac0369: 			  throw StandardException.newException(SQLState.LANG_TABLE_CONSTRUCTOR_ALL_PARAM_COLUMN);
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			/*
1:eac0369: 			** Loop through the nodes again. This time, look for parameter
1:eac0369: 			** nodes, and give them the type from the type array we just
1:eac0369: 			** constructed.
1:eac0369: 			*/
1:6200b38: 			for (rsn = this; rsn instanceof SetOperatorNode; )
1:eac0369: 			{
1:6200b38: 				SetOperatorNode	setOperator = (SetOperatorNode) rsn;
1:6200b38: 				RowResultSetNode rrsn = (RowResultSetNode) setOperator.rightResultSet;
1:eac0369: 
1:eac0369: 				setParamColumnTypes(types, rrsn);
1:eac0369: 
1:6200b38: 				rsn = setOperator.leftResultSet;
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			setParamColumnTypes(types, (RowResultSetNode) rsn);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369: 	 * Generate the code for this UnionNode.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369:      */
1:3bb140c:     @Override
1:8fe3166:     void generate(ActivationClassBuilder acb, MethodBuilder mb)
1:eac0369: 							throws StandardException
1:eac0369: 	{
1:eac0369: 		/*  By the time we get here we should be a union all.
1:eac0369: 		 *  (We created a DistinctNode above us, if needed,
1:eac0369: 		 *  to eliminate the duplicates earlier.)
1:eac0369: 		 */
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(all,
1:eac0369: 				"all expected to be true");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* Get the next ResultSet #, so that we can number this ResultSetNode, its
1:eac0369: 		 * ResultColumnList and ResultSet.
1:eac0369: 		 */
1:eac0369: 		assignResultSetNumber();
1:eac0369: 
1:ab10884: 		// Get our final cost estimate based on the child estimates.
1:11f7ee3: 		setCostEstimate( getFinalCostEstimate() );
1:eac0369: 
1:eac0369: 		// build up the tree.
1:eac0369: 
1:eac0369: 		acb.pushGetResultSetFactoryExpression(mb); // instance for getUnionResultSet
1:eac0369: 
1:eac0369: 
1:eac0369: 		/* Generate the left and right ResultSets */
1:eac0369: 		leftResultSet.generate(acb, mb);
1:eac0369: 
1:eac0369: 		/* Do we need a NormalizeResultSet above the left ResultSet? */
1:11f7ee3: 		if (! getResultColumns().isExactTypeAndLengthMatch(leftResultSet.getResultColumns()))
1:eac0369: 		{
1:eac0369: 			acb.pushGetResultSetFactoryExpression(mb);
1:eac0369: 			mb.swap();
1:eac0369: 			generateNormalizationResultSet(acb, mb, 
1:eac0369: 													getCompilerContext().getNextResultSetNumber(),
1:eac0369: 													makeResultDescription()
1:eac0369: 													);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		rightResultSet.generate(acb, mb);
1:eac0369: 
1:eac0369: 		/* Do we need a NormalizeResultSet above the right ResultSet? */
1:11f7ee3: 		if (! getResultColumns().isExactTypeAndLengthMatch(rightResultSet.getResultColumns()))
1:eac0369: 		{
1:eac0369: 			acb.pushGetResultSetFactoryExpression(mb);
1:eac0369: 			mb.swap();
1:eac0369: 			generateNormalizationResultSet(acb, mb,
1:eac0369: 													getCompilerContext().getNextResultSetNumber(),
1:eac0369: 													makeResultDescription()
1:eac0369: 													);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* Generate the UnionResultSet:
1:eac0369: 		 *	arg1: leftExpression - Expression for leftResultSet
1:eac0369: 		 *	arg2: rightExpression - Expression for rightResultSet
1:eac0369: 		 *  arg3: Activation
1:eac0369: 		 *  arg4: resultSetNumber
1:eac0369: 		 *  arg5: estimated row count
1:eac0369: 		 *  arg6: estimated cost
1:eac0369: 		 *  arg7: close method
1:eac0369: 		 */
1:eac0369: 
1:11f7ee3: 		mb.push(getResultSetNumber());
1:11f7ee3: 		mb.push(getCostEstimate().rowCount());
1:11f7ee3: 		mb.push(getCostEstimate().getEstimatedCost());
1:eac0369: 
1:9e6e461: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, "getUnionResultSet",
1:9e6e461:                 ClassName.NoPutResultSet, 5);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:ab10884: 	 * @see ResultSetNode#getFinalCostEstimate
1:eac0369: 	 *
1:ab10884: 	 * Get the final CostEstimate for this UnionNode.
1:eac0369: 	 *
1:ab10884: 	 * @return	The final CostEstimate for this UnionNode, which is
1:ab10884: 	 *  the sum of the two child costs.
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     CostEstimate getFinalCostEstimate()
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:ab10884: 		// If we already found it, just return it.
1:11f7ee3: 		if (getCandidateFinalCostEstimate() != null)
1:11f7ee3:         {
1:11f7ee3: 			return getCandidateFinalCostEstimate();
1:11f7ee3:         }
1:eac0369: 
1:ab10884: 		CostEstimate leftCE = leftResultSet.getFinalCostEstimate();
1:ab10884: 		CostEstimate rightCE = rightResultSet.getFinalCostEstimate();
1:eac0369: 
1:11f7ee3: 		setCandidateFinalCostEstimate( getNewCostEstimate() );
1:11f7ee3: 		getCandidateFinalCostEstimate().setCost(leftCE.getEstimatedCost(),
1:ab10884: 							 leftCE.rowCount(),
1:ab10884: 							 leftCE.singleScanRowCount() +
1:ab10884: 							 rightCE.singleScanRowCount());
1:eac0369: 
1:11f7ee3: 		getCandidateFinalCostEstimate().add(rightCE, getCandidateFinalCostEstimate());
1:11f7ee3: 		return getCandidateFinalCostEstimate();
1:eac0369: 	}
1:eac0369: 
1:6200b38:     String getOperatorName()
1:eac0369:     {
1:6200b38:         return "UNION";
1:eac0369:     }
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:11f7ee3
/////////////////////////////////////////////////////////////////////////
1: 			SanityManager.ASSERT(getResultColumns().size() <= typeColumns.size(),
/////////////////////////////////////////////////////////////////////////
1:                 getResultColumns().size() < target.resultColumnList.size()) {
1: 				setResultColumns( getRCLForInsert(target, colMap) );
/////////////////////////////////////////////////////////////////////////
1:         costEst.add(rightResultSet.getCostEstimate(), costEst);
/////////////////////////////////////////////////////////////////////////
1: 			treeTop.setReferencedTableMap((JBitSet) getReferencedTableMap().clone());
/////////////////////////////////////////////////////////////////////////
1: 		if (topTableConstructor && ( ! isInsertSource()) )
/////////////////////////////////////////////////////////////////////////
1: 		setCostEstimate( getFinalCostEstimate() );
/////////////////////////////////////////////////////////////////////////
1: 		if (! getResultColumns().isExactTypeAndLengthMatch(leftResultSet.getResultColumns()))
/////////////////////////////////////////////////////////////////////////
1: 		if (! getResultColumns().isExactTypeAndLengthMatch(rightResultSet.getResultColumns()))
/////////////////////////////////////////////////////////////////////////
1: 		mb.push(getResultSetNumber());
1: 		mb.push(getCostEstimate().rowCount());
1: 		mb.push(getCostEstimate().getEstimatedCost());
/////////////////////////////////////////////////////////////////////////
1: 		if (getCandidateFinalCostEstimate() != null)
1:         {
1: 			return getCandidateFinalCostEstimate();
1:         }
1: 		setCandidateFinalCostEstimate( getNewCostEstimate() );
1: 		getCandidateFinalCostEstimate().setCost(leftCE.getEstimatedCost(),
1: 		getCandidateFinalCostEstimate().add(rightCE, getCandidateFinalCostEstimate());
1: 		return getCandidateFinalCostEstimate();
commit:661c2e6
/////////////////////////////////////////////////////////////////////////
1: 			leftResultSet = target.enhanceAndCheckForAutoincrement
1:                 ( leftResultSet, inOrder, colMap, false );
1: 			rightResultSet = target.enhanceAndCheckForAutoincrement
1:                 ( rightResultSet, inOrder, colMap, false );
commit:87d06c2
/////////////////////////////////////////////////////////////////////////
0:                 Boolean.valueOf( hasJDBClimitClause ),
commit:57c1b5c
/////////////////////////////////////////////////////////////////////////
0:                 new Boolean( hasJDBClimitClause ),
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:b4cda60
/////////////////////////////////////////////////////////////////////////
1:         for (int i=0; i < qec.size(); i++) {
1:             final OrderByList obl = qec.getOrderByList(i);
1: 
1:             if (obl != null)
1:                                           obl,
1:             final ValueNode offset = qec.getOffset(i);
1:             final ValueNode fetchFirst = qec.getFetchFirst(i);
1: 
1:             if (offset != null || fetchFirst != null) {
/////////////////////////////////////////////////////////////////////////
1:                         qec.getHasJDBCLimitClause()[i].booleanValue(),
commit:2706d1f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
1: import java.util.Properties;
1: import org.apache.derby.iapi.reference.ClassName;
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.services.classfile.VMOpcode;
1: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1: import org.apache.derby.iapi.services.context.ContextManager;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
1: import org.apache.derby.iapi.sql.compile.CostEstimate;
/////////////////////////////////////////////////////////////////////////
1: class UnionNode extends SetOperatorNode
/////////////////////////////////////////////////////////////////////////
1:      * Constructor for a UnionNode.
/////////////////////////////////////////////////////////////////////////
1:     UnionNode(ResultSetNode  leftResult,
1:               ResultSetNode  rightResult,
1:               boolean        all,
1:               boolean        tableConstructor,
1:               Properties     tableProperties,
1:               ContextManager cm) throws StandardException {
1:         super(leftResult, rightResult, all, tableProperties, cm);
0:         setNodeType(C_NodeTypes.UNION_NODE);
1: 
1:         // Is this a UNION ALL for a table constructor?
1:         this.tableConstructor = tableConstructor;
1:     }
1:     void markTopTableConstructor()
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     void rejectParameters() throws StandardException
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:         CostEstimate costEst = getCostEstimate(optimizer);
1:         costEst.setCost(leftResultSet.getCostEstimate().getEstimatedCost(),
0:         costEst.add(rightResultSet.costEstimate, costEst);
/////////////////////////////////////////////////////////////////////////
1:                             costEst
1:         optimizer.considerCost(this, predList, costEst, outerCost);
1:         return costEst;
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     void pushExpressions(PredicateList predicateList)
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     ResultSetNode modifyAccessPaths() throws StandardException
/////////////////////////////////////////////////////////////////////////
1:                 treeTop = new NormalizeResultSetNode(
1:                         treeTop, null, null, false, getContextManager());
1:             treeTop = new DistinctNode(treeTop.genProjectRestrict(),
1:                                        false,
1:                                        tableProperties,
1:                                        getContextManager());
/////////////////////////////////////////////////////////////////////////
1:                 treeTop = new OrderByNode(treeTop,
0:                                           orderByLists[i],
1:                                           tableProperties,
1:                                           getContextManager());
/////////////////////////////////////////////////////////////////////////
1:                 treeTop = new RowCountNode(
0:                         hasJDBClimitClause,
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     CostEstimate getFinalCostEstimate()
commit:4d044a3
/////////////////////////////////////////////////////////////////////////
0:         for (int i=0; i < orderByLists.length; i++) {
0:             if (orderByLists[i] != null)
1:             {
0:                 treeTop = (ResultSetNode) getNodeFactory().getNode(
0:                         C_NodeTypes.ORDER_BY_NODE,
1:                         treeTop,
0:                         orderByLists[i],
0:                         tableProperties,
1:                         getContextManager());
1:             }
1:             // Do this only after the main ORDER BY; any extra added by
0:             // IntersectOrExceptNode should sit on top of us.
0:             if (i == 0 && (offset != null || fetchFirst != null)) {
1:                 ResultColumnList newRcl =
1:                         treeTop.getResultColumns().copyListAndObjects();
1:                 newRcl.genVirtualColumnNodes(treeTop,
1:                                              treeTop.getResultColumns());
0:                 treeTop = (ResultSetNode)getNodeFactory().getNode(
0:                         C_NodeTypes.ROW_COUNT_NODE,
1:                         treeTop,
1:                         newRcl,
1:                         offset,
1:                         fetchFirst,
0:                         Boolean.valueOf( hasJDBClimitClause ),
1:                         getContextManager());
1:             }
commit:108305b
/////////////////////////////////////////////////////////////////////////
1: 
1: 
0:         if (offset != null || fetchFirst != null) {
0:             ResultColumnList newRcl =
0:                 treeTop.getResultColumns().copyListAndObjects();
0:             newRcl.genVirtualColumnNodes(treeTop, treeTop.getResultColumns());
1: 
0:             treeTop = (RowCountNode)getNodeFactory().getNode(
0:                 C_NodeTypes.ROW_COUNT_NODE,
0:                 treeTop,
0:                 newRcl,
0:                 offset,
0:                 fetchFirst,
0:                 getContextManager());
1:         }
1: 
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:8fe3166
/////////////////////////////////////////////////////////////////////////
1:     void generate(ActivationClassBuilder acb, MethodBuilder mb)
commit:7af858d
/////////////////////////////////////////////////////////////////////////
0: 				(ResultSetNode) getNodeFactory().getNode(
/////////////////////////////////////////////////////////////////////////
0:             treeTop = (ResultSetNode)getNodeFactory().getNode(
commit:a8db665
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * Make the RCL of this node match the target node for the insert. If this
1: 	 * node represents a table constructor (a VALUES clause), we replace the
1: 	 * RCL with an enhanced one if necessary, and recursively enhance the RCL
1: 	 * of each child node. For table constructors, we also need to check that
1: 	 * we don't attempt to override auto-increment columns in each child node
1: 	 * (checking the top-level RCL isn't sufficient since a table constructor
1: 	 * may contain the DEFAULT keyword, which makes it possible to specify a
1: 	 * column without overriding its value).
1: 	 *
1: 	 * If this node represents a regular UNION, put a ProjectRestrictNode on
1: 	 * top of this node and enhance the RCL in that node.
1: 	 */
1: 	ResultSetNode enhanceRCLForInsert(
1: 			InsertNode target, boolean inOrder, int[] colMap)
1: 		throws StandardException
1: 	{
1: 		if (tableConstructor()) {
0: 			leftResultSet = target.enhanceAndCheckForAutoincrement(
0: 					leftResultSet, inOrder, colMap);
0: 			rightResultSet = target.enhanceAndCheckForAutoincrement(
0: 					rightResultSet, inOrder, colMap);
1: 			if (!inOrder ||
0: 					resultColumns.size() < target.resultColumnList.size()) {
0: 				resultColumns = getRCLForInsert(target, colMap);
1: 			}
1: 			return this;
1: 		} else {
1: 			// This is a regular UNION, so fall back to the default
1: 			// implementation that adds a ProjectRestrictNode on top.
1: 			return super.enhanceRCLForInsert(target, inOrder, colMap);
1: 		}
1: 	}
1: 
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:860148c
/////////////////////////////////////////////////////////////////////////
0: 				treeTop, null, null, Boolean.FALSE,
commit:bfc59e5
/////////////////////////////////////////////////////////////////////////
0: 			    treeTop = 
0: 				(NormalizeResultSetNode) getNodeFactory().getNode(
0: 				C_NodeTypes.NORMALIZE_RESULT_SET_NODE,
0: 				treeTop, null, Boolean.FALSE,
0: 				getContextManager());	
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:0dfa31c
/////////////////////////////////////////////////////////////////////////
0: 				treeTop = genNormalizeResultSetNode(false);	
commit:9e6e461
/////////////////////////////////////////////////////////////////////////
1: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, "getUnionResultSet",
1:                 ClassName.NoPutResultSet, 5);
commit:57abd06
/////////////////////////////////////////////////////////////////////////
1: 		updateBestPlanMap(ADD_PLAN, this);
commit:6b26ee1
/////////////////////////////////////////////////////////////////////////
0: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, "getUnionResultSet", ClassName.NoPutResultSet, 6);
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.compile.UnionNode
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:61070a6
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package	org.apache.derby.impl.sql.compile;
1: 
0: import org.apache.derby.iapi.services.context.ContextManager;
1: 
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.iapi.sql.compile.CompilerContext;
1: import org.apache.derby.iapi.sql.compile.Optimizable;
0: import org.apache.derby.iapi.sql.compile.OptimizablePredicate;
1: import org.apache.derby.iapi.sql.compile.OptimizablePredicateList;
1: import org.apache.derby.iapi.sql.compile.Optimizer;
0: import org.apache.derby.iapi.sql.compile.CostEstimate;
1: import org.apache.derby.iapi.sql.compile.RowOrdering;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
1: 
0: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.DefaultDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
1: 
1: import org.apache.derby.iapi.types.DataTypeDescriptor;
1: 
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.reference.ClassName;
1: 
0: import org.apache.derby.iapi.sql.Activation;
1: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: import org.apache.derby.iapi.sql.ResultSet;
0: import org.apache.derby.iapi.sql.Row;
1: 
0: import org.apache.derby.iapi.types.TypeId;
1: 
0: import org.apache.derby.impl.sql.compile.ActivationClassBuilder;
1: 
1: import org.apache.derby.iapi.util.JBitSet;
0: import org.apache.derby.iapi.services.classfile.VMOpcode;
1: 
0: import org.apache.derby.catalog.types.DefaultInfoImpl;
1: 
0: import java.util.Properties;
1: 
1: /**
1:  * A UnionNode represents a UNION in a DML statement.  It contains a boolean
1:  * telling whether the union operation should eliminate duplicate rows.
1:  *
0:  * @author Jeff Lichtman
1:  */
1: 
0: public class UnionNode extends TableOperatorNode
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 	/**
0: 	** Tells whether to eliminate duplicate rows.  all == TRUE means do
0: 	** not eliminate duplicates, all == FALSE means eliminate duplicates.
1: 	*/
0: 	boolean			all;
1: 
0: 	/* Is this a UNION ALL generated for a table constructor. */
1: 	boolean			tableConstructor;
1: 
1: 	/* True if this is the top node of a table constructor */
1: 	boolean			topTableConstructor;
1: 
0: 	/* Only optimize a UNION once */
1: 	/* Only call addNewNodes() once */
1: 	private boolean addNewNodesCalled;
1: 
0: 	private OrderByList orderByList;
1: 
1: 	/**
0: 	 * Initializer for a UnionNode.
1: 	 *
1: 	 * @param leftResult		The ResultSetNode on the left side of this union
1: 	 * @param rightResult		The ResultSetNode on the right side of this union
1: 	 * @param all				Whether or not this is a UNION ALL.
1: 	 * @param tableConstructor	Whether or not this is from a table constructor.
1: 	 * @param tableProperties	Properties list associated with the table
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public void init(
0: 					Object leftResult,
0: 					Object rightResult,
0: 					Object all,
0: 					Object tableConstructor,
0: 					Object tableProperties)
1: 			throws StandardException
1: 	{
0: 		super.init(leftResult, rightResult, tableProperties);
1: 
0: 		this.all = ((Boolean) all).booleanValue();
1: 
0: 		/* Is this a UNION ALL for a table constructor? */
0: 		this.tableConstructor = ((Boolean) tableConstructor).booleanValue();
1: 
0: 		/* resultColumns cannot be null, so we make a copy of the left RCL
0: 		 * for now.  At bind() time, we need to recopy the list because there
0: 		 * may have been a "*" in the list.  (We will set the names and
0: 		 * column types at that time, as expected.)
1: 		 */
0: 		resultColumns = leftResultSet.getResultColumns().copyListAndObjects();
1: 	}
1: 
1: 	/**
1: 	 * Mark this as the top node of a table constructor.
1: 	 */
0: 	public void markTopTableConstructor()
1: 	{
1: 		topTableConstructor = true;
1: 	}
1: 
1: 	/**
1: 	 * Tell whether this is a UNION for a table constructor.
1: 	 */
1: 	boolean tableConstructor()
1: 	{
1: 		return tableConstructor;
1: 	}
1: 
1: 	/**
1: 	 * Check for (and reject) ? parameters directly under the ResultColumns.
1: 	 * This is done for SELECT statements.  Don't reject parameters that
1: 	 * are in a table constructor - these are allowed, as long as the
1: 	 * table constructor is in an INSERT statement or each column of the
1: 	 * table constructor has at least one non-? column.  The latter case
1: 	 * is checked below, in bindExpressions().
1: 	 *
0: 	 * @return	Nothing
1: 	 *
1: 	 * @exception StandardException		Thrown if a ? parameter found
1: 	 *									directly under a ResultColumn
1: 	 */
0: 	public void rejectParameters() throws StandardException
1: 	{
1: 		if ( ! tableConstructor())
1: 			super.rejectParameters();
1: 	}
1: 
1: 	/**
1: 	 * Set the type of column in the result column lists of each
1: 	 * source of this union tree to the type in the given result column list
1: 	 * (which represents the result columns for an insert).
1: 	 * This is only for table constructors that appear in insert statements.
1: 	 *
1: 	 * @param typeColumns	The ResultColumnList containing the desired result
1: 	 *						types.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	void setTableConstructorTypes(ResultColumnList typeColumns)
1: 			throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			SanityManager.ASSERT(resultColumns.size() <= typeColumns.size(),
1: 				"More columns in ResultColumnList than in base table.");
1: 		}
1: 
1: 		ResultSetNode	rsn;
1: 
1: 		/*
1: 		** Should only set types of ? parameters to types of result columns
1: 		** if it's a table constructor.
1: 		*/
1: 		if (tableConstructor())
1: 		{
1: 			/* By looping through the union nodes, we avoid recursion */
1: 			for (rsn = this; rsn instanceof UnionNode; )
1: 			{
1: 				UnionNode union = (UnionNode) rsn;
1: 
1: 				/*
1: 				** Assume that table constructors are left-deep trees of UnionNodes
1: 				** with RowResultSet nodes on the right.
1: 				*/
1: 				if (SanityManager.DEBUG)
1: 					SanityManager.ASSERT(
1: 						union.rightResultSet instanceof RowResultSetNode,
1: 						"A " + union.rightResultSet.getClass().getName() +
1: 						" is on the right of a union in a table constructor");
1: 
1: 				((RowResultSetNode) union.rightResultSet).setTableConstructorTypes(
1: 																typeColumns);
1: 
1: 				rsn = union.leftResultSet;
1: 			}
1: 
1: 			/* The last node on the left should be a result set node */
1: 			if (SanityManager.DEBUG)
1: 				SanityManager.ASSERT(rsn instanceof RowResultSetNode,
1: 					"A " + rsn.getClass().getName() +
1: 					" is at the left end of a table constructor");
1: 
1: 			((RowResultSetNode) rsn).setTableConstructorTypes(typeColumns);
1: 		}
1: 	}
1: 
1: 	/*
1: 	 *  Optimizable interface
1: 	 */
1: 
1: 	/**
1: 	 * @see org.apache.derby.iapi.sql.compile.Optimizable#optimizeIt
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public CostEstimate optimizeIt(Optimizer optimizer,
1: 							OptimizablePredicateList predList,
1: 							CostEstimate outerCost,
1: 							RowOrdering rowOrdering)
1: 			throws StandardException
1: 	{
1: 		/*
1: 		** RESOLVE: Most types of Optimizables only implement estimateCost(),
1: 		** and leave it up to optimizeIt() in FromTable to figure out the
1: 		** total cost of the join.  For unions, though, we want to figure out
1: 		** the best plan for the sources knowing how many outer rows there are -
1: 		** it could affect their strategies significantly.  So we implement
1: 		** optimizeIt() here, which overrides the optimizeIt() in FromTable.
1: 		** This assumes that the join strategy for which this union node is
1: 		** the inner table is a nested loop join, which will not be a valid
1: 		** assumption when we implement other strategies like materialization
1: 		** (hash join can work only on base tables).
1: 		*/
1: 
1: 		/* optimize() both resultSets */
0: 		/* RESOLVE - don't try to push predicates through for now */
1: 		leftResultSet = optimizeSource(
1: 							optimizer,
1: 							leftResultSet,
0: 							(PredicateList) null,
1: 							outerCost);
1: 
1: 		rightResultSet = optimizeSource(
1: 							optimizer,
1: 							rightResultSet,
0: 							(PredicateList) null,
1: 							outerCost);
1: 
0: 		CostEstimate costEstimate = getCostEstimate(optimizer);
1: 
1: 		/* The cost is the sum of the two child costs */
0: 		costEstimate.setCost(leftResultSet.getCostEstimate().getEstimatedCost(),
1: 							 leftResultSet.getCostEstimate().rowCount(),
1: 							 leftResultSet.getCostEstimate().singleScanRowCount() +
1: 							 rightResultSet.getCostEstimate().singleScanRowCount());
1: 
0: 		costEstimate.add(rightResultSet.costEstimate, costEstimate);
1: 
1: 		/*
1: 		** Get the cost of this result set in the context of the whole plan.
1: 		*/
1: 		getCurrentAccessPath().
1: 			getJoinStrategy().
1: 				estimateCost(
1: 							this,
1: 							predList,
1: 							(ConglomerateDescriptor) null,
1: 							outerCost,
1: 							optimizer,
0: 							costEstimate
1: 							);
1: 
0: 		optimizer.considerCost(this, predList, costEstimate, outerCost);
1: 
0: 		return costEstimate;
1: 	}
1: 
1: 	/**
1: 	 * @see Optimizable#modifyAccessPath
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public Optimizable modifyAccessPath(JBitSet outerTables) throws StandardException
1: 	{
1: 		Optimizable retOptimizable;
1: 		retOptimizable = super.modifyAccessPath(outerTables);
1: 
1: 		/* We only want call addNewNodes() once */
1: 		if (addNewNodesCalled)
1: 		{
1: 			return retOptimizable;
1: 		}
1: 		return (Optimizable) addNewNodes();
1: 	}
1: 
1: 	/**
1: 	 * @see ResultSetNode#modifyAccessPaths
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public ResultSetNode modifyAccessPaths() throws StandardException
1: 	{
1: 		ResultSetNode retRSN;
1: 		retRSN = super.modifyAccessPaths();
1: 
1: 		/* We only want call addNewNodes() once */
1: 		if (addNewNodesCalled)
1: 		{
1: 			return retRSN;
1: 		}
1: 		return addNewNodes();
1: 	}
1: 
1: 	/**
1: 	 * Add any new ResultSetNodes that are necessary to the tree.
1: 	 * We wait until after optimization to do this in order to
1: 	 * make it easier on the optimizer.
1: 	 *
1: 	 * @return (Potentially new) head of the ResultSetNode tree.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	private ResultSetNode addNewNodes()
1: 		throws StandardException
1: 	{
1: 		ResultSetNode treeTop = this;
1: 
1: 		/* Only call addNewNodes() once */
1: 		if (addNewNodesCalled)
1: 		{
1: 			return this;
1: 		}
1: 
1: 		addNewNodesCalled = true;
1: 
1: 		/* RESOLVE - We'd like to generate any necessary NormalizeResultSets
1: 		 * above our children here, in the tree.  However, doing so causes
1: 		 * the following query to fail because the where clause goes against
1: 		 * the NRS instead of the Union:
1: 		 *		SELECT TABLE_TYPE
1: 		 *		FROM SYS.SYSTABLES, 
1: 		 *			(VALUES ('T','TABLE') ,
1: 		 *				('S','SYSTEM TABLE') , ('V', 'VIEW')) T(TTABBREV,TABLE_TYPE) 
1: 		 *		WHERE TTABBREV=TABLETYPE;
1: 		 * Thus, we are forced to skip over generating the nodes in the tree
1: 		 * and directly generate the execution time code in generate() instead.
1: 		 * This solves the problem for some unknown reason.
1: 		 */
1: 
1: 		/* Simple solution (for now) to eliminating duplicates - 
1: 		 * generate a distinct above the union.
1: 		 */
1: 		if (! all)
1: 		{
1: 			/* We need to generate a NormalizeResultSetNode above us if the column
1: 			 * types and lengths don't match.  (We need to do it here, since they
1: 			 * will end up agreeing in the PRN, which will be the immediate
1: 			 * child of the DistinctNode, which means that the NormalizeResultSet
1: 			 * won't get generated above the PRN.)
1: 			 */
1: 			if (! columnTypesAndLengthsMatch())
1: 			{
0: 				treeTop = genNormalizeResultSetNode(this, false);	
1: 			}
1: 
0: 			treeTop = (ResultSetNode) getNodeFactory().getNode(
0: 							C_NodeTypes.DISTINCT_NODE,
0: 							treeTop.genProjectRestrict(),
0: 							Boolean.FALSE,
0: 							tableProperties,
0: 							getContextManager());
1: 			/* HACK - propagate our table number up to the new DistinctNode
1: 			 * so that arbitrary hash join will work correctly.  (Otherwise it
1: 			 * could have a problem dividing up the predicate list at the end
1: 			 * of modifyAccessPath() because the new child of the PRN above
1: 			 * us would have a tableNumber of -1 instead of our tableNumber.)
1: 			 */
1: 			((FromTable)treeTop).setTableNumber(tableNumber);
0: 			treeTop.setReferencedTableMap((JBitSet) referencedTableMap.clone());
1: 			all = true;
1: 		}
1: 
1: 		/* Generate the OrderByNode if a sort is still required for
1: 		 * the order by.
1: 		 */
0: 		if (orderByList != null)
1: 		{
0: 			treeTop = (ResultSetNode) getNodeFactory().getNode(
0: 											C_NodeTypes.ORDER_BY_NODE,
0: 											treeTop,
0: 											orderByList,
0: 											tableProperties,
0: 											getContextManager());
1: 		}
1: 		return treeTop;
1: 	}
1: 
1: 	/**
1: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
1: 	 * for how this should be done for tree printing.
1: 	 *
1: 	 * @return	This object as a String
1: 	 */
1: 
1: 	public String toString()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			return 	"all: " + all + "\n" +
0: 			 	"tableConstructor: " + tableConstructor + "\n" +
0: 				"orderByList: " + 
0: 				(orderByList != null ? orderByList.toString() : "null") + "\n" +
0: 				super.toString();
1: 		}
1: 		else
1: 		{
1: 			return "";
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Bind the expressions under this TableOperatorNode.  This means
1: 	 * binding the sub-expressions, as well as figuring out what the
1: 	 * return type is for each expression.
1: 	 *
0: 	 * @return	Nothing
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
1: 	public void bindExpressions(FromList fromListParam)
1: 				throws StandardException
1: 	{
1: 		super.bindExpressions(fromListParam);
1: 
1: 		/*
1: 		** Each ? parameter in a table constructor that is not in an insert
1: 		** statement takes its type from the first non-? in its column
1: 		** of the table constructor.  It's an error to have a column that
1: 		** has all ?s.  Do this only for the top of the table constructor
1: 		** list - we don't want to do this for every level of union node
1: 		** in the table constructor.  Also, don't do this for an INSERT -
1: 		** the types of the ? parameters come from the columns being inserted
1: 		** into in that case.
1: 		*/
0: 		if (topTableConstructor && ( ! insertSource) )
1: 		{
1: 			/*
1: 			** Step through all the rows in the table constructor to
1: 			** get the type of the first non-? in each column.
1: 			*/
0: 			DataTypeDescriptor[]	types =
1: 				new DataTypeDescriptor[leftResultSet.getResultColumns().size()];
1: 			
1: 			ResultSetNode	rsn;
0: 			int				numTypes = 0;
1: 
1: 			/* By looping through the union nodes, we avoid recursion */
1: 			for (rsn = this; rsn instanceof UnionNode; )
1: 			{
0: 				UnionNode		union = (UnionNode) rsn;
1: 
1: 				/*
1: 				** Assume that table constructors are left-deep trees of
0: 				** UnionNodes with RowResultSet nodes on the right.
1: 				*/
1: 				if (SanityManager.DEBUG)
1: 					SanityManager.ASSERT(
1: 					 union.rightResultSet instanceof RowResultSetNode,
1: 					 "A " + union.rightResultSet.getClass().getName() +
0: 					 " is on the right side of a union in a table constructor");
1: 
1: 				RowResultSetNode	rrsn =
0: 										(RowResultSetNode) union.rightResultSet;
1: 
1: 				numTypes += getParamColumnTypes(types, rrsn);
1: 
1: 				rsn = union.leftResultSet;
1: 			}
1: 
1: 			/* The last node on the left should be a result set node */
1: 			if (SanityManager.DEBUG)
1: 				SanityManager.ASSERT(rsn instanceof RowResultSetNode);
1: 
1: 			numTypes += getParamColumnTypes(types, (RowResultSetNode) rsn);
1: 
1: 			/* Are there any columns that are all ? parameters? */
1: 			if (numTypes < types.length)
1: 			{
1: 			  throw StandardException.newException(SQLState.LANG_TABLE_CONSTRUCTOR_ALL_PARAM_COLUMN);
1: 			}
1: 
1: 			/*
1: 			** Loop through the nodes again. This time, look for parameter
1: 			** nodes, and give them the type from the type array we just
1: 			** constructed.
1: 			*/
1: 			for (rsn = this; rsn instanceof UnionNode; )
1: 			{
0: 				UnionNode		union = (UnionNode) rsn;
1: 				RowResultSetNode	rrsn =
0: 										(RowResultSetNode) union.rightResultSet;
1: 
1: 				setParamColumnTypes(types, rrsn);
1: 
1: 				rsn = union.leftResultSet;
1: 			}
1: 
1: 			setParamColumnTypes(types, (RowResultSetNode) rsn);
1: 		}
1: 	}
1: 
1: 	/**
0: 	 * Bind the result columns of this ResultSetNode when there is no
0: 	 * base table to bind them to.  This is useful for SELECT statements,
0: 	 * where the result columns get their types from the expressions that
0: 	 * live under them.
1: 	 *
0: 	 * @param fromListParam		FromList to use/append to.
1: 	 *
0: 	 * @return	Nothing
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public void bindResultColumns(FromList fromListParam)
1: 					throws StandardException
1: 	{
0: 		super.bindResultColumns(fromListParam);
1: 
0: 		/* Now we build our RCL */
0: 		buildRCL();
1: 	}
1: 
1: 	/**
0: 	 * Bind the result columns for this ResultSetNode to a base table.
0: 	 * This is useful for INSERT and UPDATE statements, where the
0: 	 * result columns get their types from the table being updated or
0: 	 * inserted into.
0: 	 * If a result column list is specified, then the verification that the 
0: 	 * result column list does not contain any duplicates will be done when
0: 	 * binding them by name.
1: 	 *
0: 	 * @param targetTableDescriptor	The TableDescriptor for the table being
0: 	 *				updated or inserted into
0: 	 * @param targetColumnList	For INSERT statements, the user
0: 	 *					does not have to supply column
0: 	 *					names (for example, "insert into t
0: 	 *					values (1,2,3)".  When this
0: 	 *					parameter is null, it means that
0: 	 *					the user did not supply column
0: 	 *					names, and so the binding should
0: 	 *					be done based on order.  When it
0: 	 *					is not null, it means do the binding
0: 	 *					by name, not position.
0: 	 * @param statement			Calling DMLStatementNode (Insert or Update)
0: 	 * @param fromListParam		FromList to use/append to.
1: 	 *
0: 	 * @return	Nothing
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public void bindResultColumns(TableDescriptor targetTableDescriptor,
0: 					FromVTI targetVTI,
0: 					ResultColumnList targetColumnList,
0: 					DMLStatementNode statement,
0: 					FromList fromListParam)
1: 				throws StandardException
1: 	{
0: 		super.bindResultColumns(targetTableDescriptor,
0: 								targetVTI,
0: 								targetColumnList, statement,
0: 								fromListParam);
1: 
0: 		/* Now we build our RCL */
0: 		buildRCL();
1: 	}
1: 
1: 	/**
0: 	 * Build the RCL for this node.  We propagate the RCL up from the
0: 	 * left child to form this node's RCL.
1: 	 *
0: 	 * @return	Nothing
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	private void buildRCL() throws StandardException
1: 	{
0: 		/* Verify that both sides of the union have the same # of columns in their
0: 		 * RCL.
1: 		 */
0: 		if (leftResultSet.getResultColumns().size() !=
0: 			rightResultSet.getResultColumns().size())
1: 		{
0: 			throw StandardException.newException(SQLState.LANG_UNION_UNMATCHED_COLUMNS);
1: 		}
1: 
0: 		/* We need to recreate resultColumns for this node, since there
0: 		 * may have been 1 or more *'s in the left's SELECT list.
1: 		 */
0: 		resultColumns = leftResultSet.getResultColumns().copyListAndObjects();
1: 
0: 		/* Create new expressions with the dominant types after verifying
0: 		 * union compatibility between left and right sides.
1: 		 */
0: 		resultColumns.setUnionResultExpression(rightResultSet.getResultColumns(), tableNumber, level);
1: 	}
1: 
1: 	/**
0: 	 * Bind the result columns of a table constructor to the types in the
0: 	 * given ResultColumnList.  Use when inserting from a table constructor,
0: 	 * and there are nulls in the values clauses.
1: 	 *
0: 	 * @param rcl	The ResultColumnList with the types to bind to
1: 	 *
0: 	 * @exception StandardException		Thrown on error.
1: 	 */
0: 	public void bindUntypedNullsToResultColumns(ResultColumnList rcl)
1: 				throws StandardException
1: 	{
1: 		/*
0: 		** If the RCL from the parent is null, then
0: 		** the types are coming from the union itself.
0: 		** So we have to cross check the two child
0: 		** rcls.
1: 		*/
0: 		if (rcl == null)
1: 		{
0: 			ResultColumnList lrcl = rightResultSet.getResultColumns();
0: 			ResultColumnList rrcl = leftResultSet.getResultColumns();
1: 
0: 			leftResultSet.bindUntypedNullsToResultColumns(rrcl);
0: 			rightResultSet.bindUntypedNullsToResultColumns(lrcl);
1: 		}
1: 		else	
1: 		{
0: 			leftResultSet.bindUntypedNullsToResultColumns(rcl);
0: 			rightResultSet.bindUntypedNullsToResultColumns(rcl);
1: 		}			
1: 	}
1: 
1: 	/**
0: 	 * Get the parameter types from the given RowResultSetNode into the
0: 	 * given array of types.  If an array position is already filled in,
0: 	 * don't clobber it.
1: 	 *
0: 	 * @param types	The array of types to fill in
0: 	 * @param rrsn	The RowResultSetNode from which to take the param types
1: 	 *
0: 	 * @return	The number of new types found in the RowResultSetNode
1: 	 */
0: 	int getParamColumnTypes(DataTypeDescriptor[] types, RowResultSetNode rrsn)
1: 	{
0: 		int	numTypes = 0;
1: 
0: 		/* Look for columns where we have not found a non-? yet. */
0: 		for (int i = 0; i < types.length; i++)
1: 		{
0: 			if (types[i] == null)
1: 			{
0: 				ResultColumn rc =
0: 					(ResultColumn) rrsn.getResultColumns().elementAt(i);
0: 				if ( ! (rc.getExpression().isParameterNode()))
1: 				{
0: 					types[i] = rc.getExpressionType();
0: 					numTypes++;
1: 				}
1: 			}
1: 		}
1: 
0: 		return numTypes;
1: 	}
1: 
1: 	/**
0: 	 * Set the type of each ? parameter in the given RowResultSetNode
0: 	 * according to its ordinal position in the given array of types.
1: 	 *
0: 	 * @param types	An array of types containing the proper type for each
0: 	 *				? parameter, by ordinal position.
0: 	 * @param rrsn	A RowResultSetNode that could contain ? parameters whose
0: 	 *				types need to be set.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	void setParamColumnTypes(DataTypeDescriptor[] types, RowResultSetNode rrsn)
1: 					throws StandardException
1: 	{
1: 		/*
0: 		** Look for ? parameters in the result column list
0: 		** of each RowResultSetNode
1: 		*/
0: 		ResultColumnList rrcl = rrsn.getResultColumns();
0: 		int rrclSize = rrcl.size();
0: 		for (int index = 0; index < rrclSize; index++)
1: 		{
0: 			ResultColumn	rc = (ResultColumn) rrcl.elementAt(index);
1: 
0: 			if (rc.getExpression().isParameterNode())
1: 			{
1: 				/*
0: 				** We found a ? - set its type to the type from the
0: 				** type array.
1: 				*/
0: 				((ParameterNode) rc.getExpression()).setDescriptor(
0: 											types[index]);
1: 			}
1: 		}
1: 	}
1: 
1: 	/**
0: 	 * Bind the expressions in the target list.  This means binding the
0: 	 * sub-expressions, as well as figuring out what the return type is
0: 	 * for each expression.  This is useful for EXISTS subqueries, where we
0: 	 * need to validate the target list before blowing it away and replacing
0: 	 * it with a SELECT true.
1: 	 *
0: 	 * @return	Nothing
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public void bindTargetExpressions(FromList fromListParam)
1: 					throws StandardException
1: 	{
0: 		leftResultSet.bindTargetExpressions(fromListParam);
0: 		rightResultSet.bindTargetExpressions(fromListParam);
1: 	}
1: 
1: 	/**
0: 	 * Push the order by list down from the cursor node
0: 	 * into its child result set so that the optimizer
0: 	 * has all of the information that it needs to 
0: 	 * consider sort avoidance.
1: 	 *
0: 	 * @param orderByList	The order by list
1: 	 *
0: 	 * @return Nothing.
1: 	 */
0: 	void pushOrderByList(OrderByList orderByList)
1: 	{
0: 		this.orderByList = orderByList;
1: 	}
1: 
1: 	/** 
0: 	 * Put a ProjectRestrictNode on top of each FromTable in the FromList.
0: 	 * ColumnReferences must continue to point to the same ResultColumn, so
0: 	 * that ResultColumn must percolate up to the new PRN.  However,
0: 	 * that ResultColumn will point to a new expression, a VirtualColumnNode, 
0: 	 * which points to the FromTable and the ResultColumn that is the source for
0: 	 * the ColumnReference.  
0: 	 * (The new PRN will have the original of the ResultColumnList and
0: 	 * the ResultColumns from that list.  The FromTable will get shallow copies
0: 	 * of the ResultColumnList and its ResultColumns.  ResultColumn.expression
0: 	 * will remain at the FromTable, with the PRN getting a new 
0: 	 * VirtualColumnNode for each ResultColumn.expression.)
0: 	 * We then project out the non-referenced columns.  If there are no referenced
0: 	 * columns, then the PRN's ResultColumnList will consist of a single ResultColumn
0: 	 * whose expression is 1.
1: 	 *
0: 	 * @param numTables			Number of tables in the DML Statement
0: 	 * @param gbl				The group by list, if any
0: 	 * @param fromList			The from list, if any
1: 	 *
0: 	 * @return The generated ProjectRestrictNode atop the original FromTable.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public ResultSetNode preprocess(int numTables,
0: 									GroupByList gbl,
0: 									FromList fromList)
1: 								throws StandardException
1: 	{
0: 		ResultSetNode newTop = this;
1: 
0: 		/* RESOLVE - what does numTables and referencedTableMap mean here? */
0: 		leftResultSet = leftResultSet.preprocess(numTables, gbl, fromList);
0: 		rightResultSet = rightResultSet.preprocess(numTables, gbl, fromList);
1: 
0: 		/* Build the referenced table map (left || right) */
0: 		referencedTableMap = (JBitSet) leftResultSet.getReferencedTableMap().clone();
0: 		referencedTableMap.or((JBitSet) rightResultSet.getReferencedTableMap());
1: 
0: 		/* If this is a UNION without an all and we have
0: 		 * an order by then we can consider eliminating the sort for the
0: 		 * order by.  All of the columns in the order by list must
0: 		 * be ascending in order to do this.  There are 2 cases:
0: 		 *	o	The order by list is an in order prefix of the columns
0: 		 *		in the select list.  In this case the output of the
0: 		 *		sort from the distinct will be in the right order
0: 		 *		so we simply eliminate the order by list.
0: 		 *	o	The order by list is a subset of the columns in the
0: 		 *		the select list.  In this case we need to reorder the
0: 		 *		columns in the select list so that the ordering columns
0: 		 *		are an in order prefix of the select list and put a PRN
0: 		 *		above the select so that the shape of the result set
0: 		 *		is as expected.
1: 		 */
0: 		if ((! all) && orderByList != null && orderByList.allAscending())
1: 		{
0: 			/* Order by list currently restricted to columns in select
0: 			 * list, so we will always eliminate the order by here.
1: 			 */
0: 			if (orderByList.isInOrderPrefix(resultColumns))
1: 			{
0: 				orderByList = null;
1: 			}
0: 			/* RESOLVE - We currently only eliminate the order by if it is
0: 			 * a prefix of the select list.  We do not currently do the 
0: 			 * elimination if the order by is not a prefix because the code
0: 			 * doesn't work.  The problem has something to do with the
0: 			 * fact that we generate additional nodes between the union
0: 			 * and the PRN (for reordering that we would generate here)
0: 			 * when modifying the access paths.  VCNs under the PRN can be
0: 			 * seen as correlated since their source resultset is the Union
0: 			 * which is no longer the result set directly under them.  This
0: 			 * causes the wrong code to get generated. (jerry - 11/3/98)
0: 			 * (bug 59)
1: 			 */
1: 		}
1: 
0: 		return newTop;
1: 	}
1: 	
1: 	/**
0: 	 * Ensure that the top of the RSN tree has a PredicateList.
1: 	 *
0: 	 * @param numTables			The number of tables in the query.
0: 	 * @return ResultSetNode	A RSN tree with a node which has a PredicateList on top.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public ResultSetNode ensurePredicateList(int numTables) 
1: 		throws StandardException
1: 	{
0: 		return genProjectRestrict(numTables);
1: 	}
1: 
1: 	/**
0: 	 * Verify that a SELECT * is valid for this type of subquery.
1: 	 *
0: 	 * @param outerFromList	The FromList from the outer query block(s)
0: 	 * @param subqueryType	The subquery type
1: 	 *
0: 	 * @return	None
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public void verifySelectStarSubquery(FromList outerFromList, int subqueryType) 
1: 					throws StandardException
1: 	{
0: 		/* Check both sides - SELECT * is not valid on either side */
0: 		leftResultSet.verifySelectStarSubquery(outerFromList, subqueryType);
0: 		rightResultSet.verifySelectStarSubquery(outerFromList, subqueryType);
1: 	}
1: 
1: 	/** 
0: 	 * Determine whether or not the specified name is an exposed name in
0: 	 * the current query block.
1: 	 *
0: 	 * @param name	The specified name to search for as an exposed name.
0: 	 * @param schemaName	Schema name, if non-null.
0: 	 * @param exactMatch	Whether or not we need an exact match on specified schema and table
0: 	 *						names or match on table id.
1: 	 *
0: 	 * @return The FromTable, if any, with the exposed name.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	protected FromTable getFromTableByName(String name, String schemaName, boolean exactMatch)
1: 		throws StandardException
1: 	{
0: 		/* We search both sides for a TableOperatorNode (join nodes)
0: 		 * but only the left side for a UnionNode.
1: 		 */
0: 		return leftResultSet.getFromTableByName(name, schemaName, exactMatch);
1: 	}
1: 
1: 	/**
0: 	 * Set the result column for the subquery to a boolean true,
0: 	 * Useful for transformations such as
0: 	 * changing:
0: 	 *		where exists (select ... from ...) 
0: 	 * to:
0: 	 *		where (select true from ...)
1: 	 *
0: 	 * NOTE: No transformation is performed if the ResultColumn.expression is
0: 	 * already the correct boolean constant.
1: 	 * 
0: 	 * @param onlyConvertAlls	Boolean, whether or not to just convert *'s
1: 	 *
0: 	 * @return Nothing.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public void setResultToBooleanTrueNode(boolean onlyConvertAlls)
1: 				throws StandardException
1: 	{
0: 		super.setResultToBooleanTrueNode(onlyConvertAlls);
0: 		leftResultSet.setResultToBooleanTrueNode(onlyConvertAlls);
0: 		rightResultSet.setResultToBooleanTrueNode(onlyConvertAlls);
1: 	}
1: 
1: 	/**
0: 	 * This ResultSet is the source for an Insert.  The target RCL
0: 	 * is in a different order and/or a superset of this RCL.  In most cases
0: 	 * we will reorder and/or add defaults to the current RCL so that is
0: 	 * matches the target RCL.  Those RSNs whose generate() method does
0: 	 * not handle projects will insert a PRN, with a new RCL which matches
0: 	 * the target RCL, above the current RSN.
0: 	 * NOTE - The new or enhanced RCL will be fully bound.
1: 	 *
0: 	 * @param numTargetColumns	# of columns in target RCL
0: 	 * @param colMap[]			int array representation of correspondence between
0: 	 *							RCLs - colmap[i] = -1 -> missing in current RCL
0: 	 *								   colmap[i] = j -> targetRCL(i) <-> thisRCL(j+1)
0: 	 * @param dataDictionary	DataDictionary to use
0: 	 * @param targetTD			TableDescriptor for target if the target is not a VTI, null if a VTI
0:      * @param targetVTI         Target description if it is a VTI, null if not a VTI
1: 	 *
0: 	 * @return ResultSetNode	The new top of the tree
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public ResultSetNode enhanceRCLForInsert(int numTargetColumns, int[] colMap, 
0: 											 DataDictionary dataDictionary,
0: 											 TableDescriptor targetTD,
0:                                              FromVTI targetVTI)
1: 			throws StandardException
1: 	{
0: 		// our newResultCols are put into the bound form straight away.
0: 		ResultColumnList newResultCols =
0: 								(ResultColumnList) getNodeFactory().getNode(
0: 												C_NodeTypes.RESULT_COLUMN_LIST,
0: 												getContextManager());
0: 		int numResultSetColumns = resultColumns.size();
1: 
0: 		/* Create a massaged version of the source RCL.
0: 		 * (Much simpler to build new list and then assign to source,
0: 		 * rather than massage the source list in place.)
1: 		 */
0: 		for (int index = 0; index < numTargetColumns; index++)
1: 		{
0: 			ResultColumn	newResultColumn;
0: 			ResultColumn	oldResultColumn;
0: 			ColumnReference newColumnReference;
1: 
0: 			if (colMap[index] != -1)
1: 			{
0: 				// getResultColumn uses 1-based positioning, so offset the colMap entry appropriately
0: 				oldResultColumn = resultColumns.getResultColumn(colMap[index]+1);
1: 
0: 				newColumnReference = (ColumnReference) getNodeFactory().getNode(
0: 												C_NodeTypes.COLUMN_REFERENCE,
0: 												oldResultColumn.getName(),
0: 												null,
0: 												getContextManager());
0: 				/* The ColumnReference points to the source of the value */
0: 				newColumnReference.setSource(oldResultColumn);
0: 				// colMap entry is 0-based, columnId is 1-based.
0: 				newColumnReference.setType(oldResultColumn.getExpressionType());
1: 
0: 				// Source of an insert, so nesting levels must be 0
0: 				newColumnReference.setNestingLevel(0);
0: 				newColumnReference.setSourceLevel(0);
1: 
0: 				// because the insert already copied the target table's
0: 				// column descriptors into the result, we grab it from there.
0: 				// alternatively, we could do what the else clause does,
0: 				// and look it up in the DD again.
0: 				newResultColumn = (ResultColumn) getNodeFactory().getNode(
0: 						C_NodeTypes.RESULT_COLUMN,
0: 						oldResultColumn.getType(),
0: 						newColumnReference,
0: 						getContextManager());
1: 			}
1: 			else
1: 			{
0: 				newResultColumn = genNewRCForInsert(targetTD, targetVTI, index + 1, dataDictionary);
1: 			}
1: 
0: 			newResultCols.addResultColumn(newResultColumn);
1: 		}
1: 
0: 		/* The generated ProjectRestrictNode now has the ResultColumnList
0: 		 * in the order that the InsertNode expects.
0: 		 * NOTE: This code here is an exception to several "rules":
0: 		 *		o  This is the only ProjectRestrictNode that is currently
0: 		 *		   generated outside of preprocess().
0: 		 *	    o  The UnionNode is the only node which is not at the
0: 		 *		   top of the query tree which has ColumnReferences under
0: 		 *		   its ResultColumnList prior to expression push down.
1: 		 */
0: 		return (ResultSetNode) getNodeFactory().getNode(
0: 									C_NodeTypes.PROJECT_RESTRICT_NODE,
1: 									this,
0: 									newResultCols,
0: 									null,
0: 									null,
0: 									null,
0: 									null,
0: 									tableProperties,
0: 									getContextManager());
1: 	}
1: 
1: 	/**
0: 	 * Evaluate whether or not the subquery in a FromSubquery is flattenable.  
0: 	 * Currently, a FSqry is flattenable if all of the following are true:
0: 	 *		o  Subquery is a SelectNode. (ie, not a RowResultSetNode or a UnionNode)
0: 	 *		o  It contains no top level subqueries.  (RESOLVE - we can relax this)
0: 	 *		o  It does not contain a group by or having clause
0: 	 *		o  It does not contain aggregates.
1: 	 *
0: 	 * @param fromList	The outer from list
1: 	 *
0: 	 * @return boolean	Whether or not the FromSubquery is flattenable.
1: 	 */
0: 	public boolean flattenableInFromSubquery(FromList fromList)
1: 	{
0: 		/* Unions in FromSubquerys are not flattenable.	 */
0: 		return false;
1: 	}
1: 
1: 	/**
0: 	 * Return whether or not to materialize this ResultSet tree.
1: 	 *
0: 	 * @return Whether or not to materialize this ResultSet tree.
0: 	 *			would return valid results.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public boolean performMaterialization(JBitSet outerTables)
1: 		throws StandardException
1: 	{
0: 		// RESOLVE - just say no to materialization right now - should be a cost based decision
0: 		return false;
1: 
0: 		/* Actual materialization, if appropriate, will be placed by our parent PRN.
0: 		 * This is because PRN might have a join condition to apply.  (Materialization
0: 		 * can only occur before that.
1: 		 */
0: 		//return true;
1: 	}
1: 
1:     /**
1: 	 * Generate the code for this UnionNode.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1:      */
0: 	public void generate(ActivationClassBuilder acb,
0: 								MethodBuilder mb)
1: 							throws StandardException
1: 	{
1: 		/*  By the time we get here we should be a union all.
1: 		 *  (We created a DistinctNode above us, if needed,
1: 		 *  to eliminate the duplicates earlier.)
1: 		 */
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(all,
1: 				"all expected to be true");
1: 		}
1: 
1: 		/* Get the next ResultSet #, so that we can number this ResultSetNode, its
1: 		 * ResultColumnList and ResultSet.
1: 		 */
1: 		assignResultSetNumber();
1: 
1: 		// build up the tree.
1: 
1: 		acb.pushGetResultSetFactoryExpression(mb); // instance for getUnionResultSet
1: 
1: 
1: 		/* Generate the left and right ResultSets */
1: 		leftResultSet.generate(acb, mb);
1: 
1: 		/* Do we need a NormalizeResultSet above the left ResultSet? */
0: 		if (! resultColumns.isExactTypeAndLengthMatch(leftResultSet.getResultColumns()))
1: 		{
1: 			acb.pushGetResultSetFactoryExpression(mb);
1: 			mb.swap();
1: 			generateNormalizationResultSet(acb, mb, 
1: 													getCompilerContext().getNextResultSetNumber(),
1: 													makeResultDescription()
1: 													);
1: 		}
1: 
1: 		rightResultSet.generate(acb, mb);
1: 
1: 		/* Do we need a NormalizeResultSet above the right ResultSet? */
0: 		if (! resultColumns.isExactTypeAndLengthMatch(rightResultSet.getResultColumns()))
1: 		{
1: 			acb.pushGetResultSetFactoryExpression(mb);
1: 			mb.swap();
1: 			generateNormalizationResultSet(acb, mb,
1: 													getCompilerContext().getNextResultSetNumber(),
1: 													makeResultDescription()
1: 													);
1: 		}
1: 
1: 		/* Generate the UnionResultSet:
1: 		 *	arg1: leftExpression - Expression for leftResultSet
1: 		 *	arg2: rightExpression - Expression for rightResultSet
1: 		 *  arg3: Activation
1: 		 *  arg4: resultSetNumber
1: 		 *  arg5: estimated row count
1: 		 *  arg6: estimated cost
1: 		 *  arg7: close method
1: 		 */
1: 
1: 
0: 		acb.pushThisAsActivation(mb);
0: 		mb.push(resultSetNumber);
0: 		mb.push(costEstimate.rowCount());
0: 		mb.push(costEstimate.getEstimatedCost());
0: 		closeMethodArgument(acb, mb);
1: 
0: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, "getUnionResultSet", ClassName.NoPutResultSet, 7);
1: 	}
1: }
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2d37fd6
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:e07631a
/////////////////////////////////////////////////////////////////////////
1: 		// definition in SetOperatorNode.  NOTE: If we're considering a
1: 		// hash join then we do not push the predicates because we'll
1: 		// need the predicates to be at this level in order to find
1: 		// out if one of them is an equijoin predicate that can be used
1: 		// for the hash join.
1: 		if ((predList != null) &&
1: 			!getCurrentAccessPath().getJoinStrategy().isHashJoin())
/////////////////////////////////////////////////////////////////////////
1: 		// It's possible that a call to optimize the left/right will cause
1: 		// a new "truly the best" plan to be stored in the underlying base
1: 		// tables.  If that happens and then we decide to skip that plan
1: 		// (which we might do if the call to "considerCost()" below decides
1: 		// the current path is infeasible or not the best) we need to be
1: 		// able to revert back to the "truly the best" plans that we had
1: 		// saved before we got here.  So with this next call we save the
1: 		// current plans using "this" node as the key.  If needed, we'll
1: 		// then make the call to revert the plans in OptimizerImpl's
1: 		// getNextDecoratedPermutation() method.
0: 		addOrLoadBestPlanMapping(true, this);
0: 
commit:5872305
/////////////////////////////////////////////////////////////////////////
0: 
1: 		// If we have predicates from an outer block, we want to try
1: 		// to push them down to this node's children.  However, we can't
1: 		// just push the predicates down as they are; instead, we
1: 		// need to scope them for the child result sets first, and
1: 		// then push the scoped versions.  This is all done in the
1: 		// call to pushOptPredicate() here; for more, see that method's
0: 		// definition in SetOperatorNode.
0: 		if (predList != null)
0: 		{
1: 			for (int i = predList.size() - 1; i >= 0; i--) {
1: 				if (pushOptPredicate(predList.getOptPredicate(i)))
1: 					predList.removeOptPredicate(i);
0: 			}
0: 		}
0: 
1: 							getLeftOptPredicateList(),
1: 							getRightOptPredicateList(),
commit:ab10884
/////////////////////////////////////////////////////////////////////////
1: 		// Get our final cost estimate based on the child estimates.
0: 		costEstimate = getFinalCostEstimate();
0: 
/////////////////////////////////////////////////////////////////////////
0: 	/**
1: 	 * @see ResultSetNode#getFinalCostEstimate
0: 	 *
1: 	 * Get the final CostEstimate for this UnionNode.
0: 	 *
1: 	 * @return	The final CostEstimate for this UnionNode, which is
1: 	 *  the sum of the two child costs.
0: 	 */
0: 	public CostEstimate getFinalCostEstimate()
0: 		throws StandardException
0: 	{
1: 		// If we already found it, just return it.
0: 		if (finalCostEstimate != null)
0: 			return finalCostEstimate;
0: 
1: 		CostEstimate leftCE = leftResultSet.getFinalCostEstimate();
1: 		CostEstimate rightCE = rightResultSet.getFinalCostEstimate();
0: 
0: 		finalCostEstimate = getNewCostEstimate();
0: 		finalCostEstimate.setCost(leftCE.getEstimatedCost(),
1: 							 leftCE.rowCount(),
1: 							 leftCE.singleScanRowCount() +
1: 							 rightCE.singleScanRowCount());
0: 
0: 		finalCostEstimate.add(rightCE, finalCostEstimate);
0: 		return finalCostEstimate;
0: 	}
0: 
commit:8091651
/////////////////////////////////////////////////////////////////////////
0: 	/**
1: 	 * DERBY-649: Handle pushing predicates into UnionNodes. It is possible to push
1: 	 * single table predicates that are binaryOperations or inListOperations. 
0: 	 *
1: 	 * Predicates of the form <columnReference> <RELOP> <constant> or <columnReference>
1: 	 * IN <constantList> are currently handled. Since these predicates would allow
1: 	 * optimizer to pick available indices, pushing them provides maximum benifit.
0: 	 *
1: 	 * It should be possible to expand this logic to cover more cases. Even pushing
1: 	 * expressions (like a+b = 10) into SELECTs would improve performance, even if
1: 	 * they don't allow use of index. It would mean evaluating expressions closer to
1: 	 * data and hence could avoid sorting or other overheads that UNION may require.
0: 	 *
1: 	 * @param 	predicateList		List of single table predicates to push
0: 	 *
0: 	 * @return	Nothing
0: 	 *
1: 	 * @exception	StandardException		Thrown on error
1: 		// in the ProjectRestrictNode. There are other types of operations possible
1: 		// here in addition to UnionNode or SelectNode, like RowResultSetNode.
commit:c700973
/////////////////////////////////////////////////////////////////////////
0: 	/*
0: 	 * DERBY-649: Handle pushing predicates into UnionNodes. For now, we only push simple
0: 	 * single column predicates that are binaryOperations. It should be possible to expand
0: 	 * this logic to cover more cases. Even pushing expressions (like a+b = 10) into SELECTs
0: 	 * would improve performance, even if they don't make Qualifiers. It would mean
0: 	 * evaluating expressions closer to data and hence could avoid sorting or other
0: 	 * overheads that UNION may require.
0: 	 *
1: 	 * Note that the predicates are not removed after pushing. This is to ensure if
1: 	 * pushing is not possible or only partially feasible.
0: 	 */
0: 	public void pushExpressions(PredicateList predicateList)
0: 					throws StandardException
0: 	{
1: 		// If left or right side is a UnionNode, further push the predicate list
1: 		// Note, it is OK not to push these predicates since they are also evaluated
0: 		// in the ProjectRestrictNode.
1: 		if (leftResultSet instanceof UnionNode)
1: 			((UnionNode)leftResultSet).pushExpressions(predicateList);
1: 		else if (leftResultSet instanceof SelectNode)
1: 			predicateList.pushExpressionsIntoSelect((SelectNode)leftResultSet, true);
0: 
1: 		if (rightResultSet instanceof UnionNode)
1: 			((UnionNode)rightResultSet).pushExpressions(predicateList);
1: 		else if (rightResultSet instanceof SelectNode)
1: 			predicateList.pushExpressionsIntoSelect((SelectNode)rightResultSet, true);
0: 	}
0: 
commit:6200b38
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: 
/////////////////////////////////////////////////////////////////////////
0: public class UnionNode extends SetOperatorNode
1: 	/* Only optimize it once */
0: 	/* Only call addNewNodes() once */
0: 	private boolean addNewNodesCalled;
1: 	/* Is this a UNION ALL generated for a table constructor -- a VALUES expression with multiple rows. */
/////////////////////////////////////////////////////////////////////////
0: 		super.init(leftResult, rightResult, all, tableProperties);
0:     } // end of init
/////////////////////////////////////////////////////////////////////////
1: 			return 	"tableConstructor: " + tableConstructor + "\n" + super.toString();
/////////////////////////////////////////////////////////////////////////
1: 			DataTypeDescriptor[] types =
1: 			ResultSetNode rsn;
1: 			int numTypes = 0;
1: 			for (rsn = this; rsn instanceof SetOperatorNode; )
1: 				SetOperatorNode		setOperator = (SetOperatorNode) rsn;
1: 				** SetOperatorNodes with RowResultSet nodes on the right.
1: 					 setOperator.rightResultSet instanceof RowResultSetNode,
1: 					 "A " + setOperator.rightResultSet.getClass().getName() +
1: 					 " is on the right side of a setOperator in a table constructor");
1: 										(RowResultSetNode) setOperator.rightResultSet;
1: 				rsn = setOperator.leftResultSet;
/////////////////////////////////////////////////////////////////////////
1: 			for (rsn = this; rsn instanceof SetOperatorNode; )
1: 				SetOperatorNode	setOperator = (SetOperatorNode) rsn;
1: 				RowResultSetNode rrsn = (RowResultSetNode) setOperator.rightResultSet;
1: 				rsn = setOperator.leftResultSet;
/////////////////////////////////////////////////////////////////////////
0: 
1:     String getOperatorName()
0:     {
1:         return "UNION";
0:     }
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package	org.apache.derby.impl.sql.compile;
0: 
0: import org.apache.derby.iapi.services.context.ContextManager;
0: 
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.sql.compile.CompilerContext;
0: import org.apache.derby.iapi.sql.compile.Optimizable;
0: import org.apache.derby.iapi.sql.compile.OptimizablePredicate;
0: import org.apache.derby.iapi.sql.compile.OptimizablePredicateList;
0: import org.apache.derby.iapi.sql.compile.Optimizer;
0: import org.apache.derby.iapi.sql.compile.CostEstimate;
0: import org.apache.derby.iapi.sql.compile.RowOrdering;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
0: 
0: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.DefaultDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
0: 
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.reference.ClassName;
0: 
0: import org.apache.derby.iapi.sql.Activation;
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: import org.apache.derby.iapi.sql.ResultSet;
0: import org.apache.derby.iapi.sql.Row;
0: 
0: import org.apache.derby.iapi.types.TypeId;
0: 
0: import org.apache.derby.impl.sql.compile.ActivationClassBuilder;
0: 
0: import org.apache.derby.iapi.util.JBitSet;
0: import org.apache.derby.iapi.services.classfile.VMOpcode;
0: 
0: import org.apache.derby.catalog.types.DefaultInfoImpl;
0: 
0: import java.util.Properties;
0: 
0: /**
0:  * A UnionNode represents a UNION in a DML statement.  It contains a boolean
0:  * telling whether the union operation should eliminate duplicate rows.
0:  *
0:  * @author Jeff Lichtman
0:  */
0: 
0: public class UnionNode extends TableOperatorNode
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	/**
0: 	** Tells whether to eliminate duplicate rows.  all == TRUE means do
0: 	** not eliminate duplicates, all == FALSE means eliminate duplicates.
0: 	*/
0: 	boolean			all;
0: 
0: 	/* Is this a UNION ALL generated for a table constructor. */
0: 	boolean			tableConstructor;
0: 
0: 	/* True if this is the top node of a table constructor */
0: 	boolean			topTableConstructor;
0: 
0: 	/* Only optimize a UNION once */
0: 	/* Only call addNewNodes() once */
0: 	private boolean addNewNodesCalled;
0: 
0: 	private OrderByList orderByList;
0: 
0: 	/**
0: 	 * Initializer for a UnionNode.
0: 	 *
0: 	 * @param leftResult		The ResultSetNode on the left side of this union
0: 	 * @param rightResult		The ResultSetNode on the right side of this union
0: 	 * @param all				Whether or not this is a UNION ALL.
0: 	 * @param tableConstructor	Whether or not this is from a table constructor.
0: 	 * @param tableProperties	Properties list associated with the table
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public void init(
0: 					Object leftResult,
0: 					Object rightResult,
0: 					Object all,
0: 					Object tableConstructor,
0: 					Object tableProperties)
0: 			throws StandardException
0: 	{
0: 		super.init(leftResult, rightResult, tableProperties);
0: 
0: 		this.all = ((Boolean) all).booleanValue();
0: 
0: 		/* Is this a UNION ALL for a table constructor? */
0: 		this.tableConstructor = ((Boolean) tableConstructor).booleanValue();
0: 
0: 		/* resultColumns cannot be null, so we make a copy of the left RCL
0: 		 * for now.  At bind() time, we need to recopy the list because there
0: 		 * may have been a "*" in the list.  (We will set the names and
0: 		 * column types at that time, as expected.)
0: 		 */
0: 		resultColumns = leftResultSet.getResultColumns().copyListAndObjects();
0: 	}
0: 
0: 	/**
0: 	 * Mark this as the top node of a table constructor.
0: 	 */
0: 	public void markTopTableConstructor()
0: 	{
0: 		topTableConstructor = true;
0: 	}
0: 
0: 	/**
0: 	 * Tell whether this is a UNION for a table constructor.
0: 	 */
0: 	boolean tableConstructor()
0: 	{
0: 		return tableConstructor;
0: 	}
0: 
0: 	/**
0: 	 * Check for (and reject) ? parameters directly under the ResultColumns.
0: 	 * This is done for SELECT statements.  Don't reject parameters that
0: 	 * are in a table constructor - these are allowed, as long as the
0: 	 * table constructor is in an INSERT statement or each column of the
0: 	 * table constructor has at least one non-? column.  The latter case
0: 	 * is checked below, in bindExpressions().
0: 	 *
0: 	 * @return	Nothing
0: 	 *
0: 	 * @exception StandardException		Thrown if a ? parameter found
0: 	 *									directly under a ResultColumn
0: 	 */
0: 	public void rejectParameters() throws StandardException
0: 	{
0: 		if ( ! tableConstructor())
0: 			super.rejectParameters();
0: 	}
0: 
0: 	/**
0: 	 * Set the type of column in the result column lists of each
0: 	 * source of this union tree to the type in the given result column list
0: 	 * (which represents the result columns for an insert).
0: 	 * This is only for table constructors that appear in insert statements.
0: 	 *
0: 	 * @param typeColumns	The ResultColumnList containing the desired result
0: 	 *						types.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	void setTableConstructorTypes(ResultColumnList typeColumns)
0: 			throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(resultColumns.size() <= typeColumns.size(),
0: 				"More columns in ResultColumnList than in base table.");
0: 		}
0: 
0: 		ResultSetNode	rsn;
0: 
0: 		/*
0: 		** Should only set types of ? parameters to types of result columns
0: 		** if it's a table constructor.
0: 		*/
0: 		if (tableConstructor())
0: 		{
0: 			/* By looping through the union nodes, we avoid recursion */
0: 			for (rsn = this; rsn instanceof UnionNode; )
0: 			{
0: 				UnionNode union = (UnionNode) rsn;
0: 
0: 				/*
0: 				** Assume that table constructors are left-deep trees of UnionNodes
0: 				** with RowResultSet nodes on the right.
0: 				*/
0: 				if (SanityManager.DEBUG)
0: 					SanityManager.ASSERT(
0: 						union.rightResultSet instanceof RowResultSetNode,
0: 						"A " + union.rightResultSet.getClass().getName() +
0: 						" is on the right of a union in a table constructor");
0: 
0: 				((RowResultSetNode) union.rightResultSet).setTableConstructorTypes(
0: 																typeColumns);
0: 
0: 				rsn = union.leftResultSet;
0: 			}
0: 
0: 			/* The last node on the left should be a result set node */
0: 			if (SanityManager.DEBUG)
0: 				SanityManager.ASSERT(rsn instanceof RowResultSetNode,
0: 					"A " + rsn.getClass().getName() +
0: 					" is at the left end of a table constructor");
0: 
0: 			((RowResultSetNode) rsn).setTableConstructorTypes(typeColumns);
0: 		}
0: 	}
0: 
0: 	/*
0: 	 *  Optimizable interface
0: 	 */
0: 
0: 	/**
0: 	 * @see org.apache.derby.iapi.sql.compile.Optimizable#optimizeIt
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public CostEstimate optimizeIt(Optimizer optimizer,
0: 							OptimizablePredicateList predList,
0: 							CostEstimate outerCost,
0: 							RowOrdering rowOrdering)
0: 			throws StandardException
0: 	{
0: 		/*
0: 		** RESOLVE: Most types of Optimizables only implement estimateCost(),
0: 		** and leave it up to optimizeIt() in FromTable to figure out the
0: 		** total cost of the join.  For unions, though, we want to figure out
0: 		** the best plan for the sources knowing how many outer rows there are -
0: 		** it could affect their strategies significantly.  So we implement
0: 		** optimizeIt() here, which overrides the optimizeIt() in FromTable.
0: 		** This assumes that the join strategy for which this union node is
0: 		** the inner table is a nested loop join, which will not be a valid
0: 		** assumption when we implement other strategies like materialization
0: 		** (hash join can work only on base tables).
0: 		*/
0: 
0: 		/* optimize() both resultSets */
0: 		/* RESOLVE - don't try to push predicates through for now */
0: 		leftResultSet = optimizeSource(
0: 							optimizer,
0: 							leftResultSet,
0: 							(PredicateList) null,
0: 							outerCost);
0: 
0: 		rightResultSet = optimizeSource(
0: 							optimizer,
0: 							rightResultSet,
0: 							(PredicateList) null,
0: 							outerCost);
0: 
0: 		CostEstimate costEstimate = getCostEstimate(optimizer);
0: 
0: 		/* The cost is the sum of the two child costs */
0: 		costEstimate.setCost(leftResultSet.getCostEstimate().getEstimatedCost(),
0: 							 leftResultSet.getCostEstimate().rowCount(),
0: 							 leftResultSet.getCostEstimate().singleScanRowCount() +
0: 							 rightResultSet.getCostEstimate().singleScanRowCount());
0: 
0: 		costEstimate.add(rightResultSet.costEstimate, costEstimate);
0: 
0: 		/*
0: 		** Get the cost of this result set in the context of the whole plan.
0: 		*/
0: 		getCurrentAccessPath().
0: 			getJoinStrategy().
0: 				estimateCost(
0: 							this,
0: 							predList,
0: 							(ConglomerateDescriptor) null,
0: 							outerCost,
0: 							optimizer,
0: 							costEstimate
0: 							);
0: 
0: 		optimizer.considerCost(this, predList, costEstimate, outerCost);
0: 
0: 		return costEstimate;
0: 	}
0: 
0: 	/**
0: 	 * @see Optimizable#modifyAccessPath
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public Optimizable modifyAccessPath(JBitSet outerTables) throws StandardException
0: 	{
0: 		Optimizable retOptimizable;
0: 		retOptimizable = super.modifyAccessPath(outerTables);
0: 
0: 		/* We only want call addNewNodes() once */
0: 		if (addNewNodesCalled)
0: 		{
0: 			return retOptimizable;
0: 		}
0: 		return (Optimizable) addNewNodes();
0: 	}
0: 
0: 	/**
0: 	 * @see ResultSetNode#modifyAccessPaths
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public ResultSetNode modifyAccessPaths() throws StandardException
0: 	{
0: 		ResultSetNode retRSN;
0: 		retRSN = super.modifyAccessPaths();
0: 
0: 		/* We only want call addNewNodes() once */
0: 		if (addNewNodesCalled)
0: 		{
0: 			return retRSN;
0: 		}
0: 		return addNewNodes();
0: 	}
0: 
0: 	/**
0: 	 * Add any new ResultSetNodes that are necessary to the tree.
0: 	 * We wait until after optimization to do this in order to
0: 	 * make it easier on the optimizer.
0: 	 *
0: 	 * @return (Potentially new) head of the ResultSetNode tree.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	private ResultSetNode addNewNodes()
0: 		throws StandardException
0: 	{
0: 		ResultSetNode treeTop = this;
0: 
0: 		/* Only call addNewNodes() once */
0: 		if (addNewNodesCalled)
0: 		{
0: 			return this;
0: 		}
0: 
0: 		addNewNodesCalled = true;
0: 
0: 		/* RESOLVE - We'd like to generate any necessary NormalizeResultSets
0: 		 * above our children here, in the tree.  However, doing so causes
0: 		 * the following query to fail because the where clause goes against
0: 		 * the NRS instead of the Union:
0: 		 *		SELECT TABLE_TYPE
0: 		 *		FROM SYS.SYSTABLES, 
0: 		 *			(VALUES ('T','TABLE') ,
0: 		 *				('S','SYSTEM TABLE') , ('V', 'VIEW')) T(TTABBREV,TABLE_TYPE) 
0: 		 *		WHERE TTABBREV=TABLETYPE;
0: 		 * Thus, we are forced to skip over generating the nodes in the tree
0: 		 * and directly generate the execution time code in generate() instead.
0: 		 * This solves the problem for some unknown reason.
0: 		 */
0: 
0: 		/* Simple solution (for now) to eliminating duplicates - 
0: 		 * generate a distinct above the union.
0: 		 */
0: 		if (! all)
0: 		{
0: 			/* We need to generate a NormalizeResultSetNode above us if the column
0: 			 * types and lengths don't match.  (We need to do it here, since they
0: 			 * will end up agreeing in the PRN, which will be the immediate
0: 			 * child of the DistinctNode, which means that the NormalizeResultSet
0: 			 * won't get generated above the PRN.)
0: 			 */
0: 			if (! columnTypesAndLengthsMatch())
0: 			{
0: 				treeTop = genNormalizeResultSetNode(this, false);	
0: 			}
0: 
0: 			treeTop = (ResultSetNode) getNodeFactory().getNode(
0: 							C_NodeTypes.DISTINCT_NODE,
0: 							treeTop.genProjectRestrict(),
0: 							Boolean.FALSE,
0: 							tableProperties,
0: 							getContextManager());
0: 			/* HACK - propagate our table number up to the new DistinctNode
0: 			 * so that arbitrary hash join will work correctly.  (Otherwise it
0: 			 * could have a problem dividing up the predicate list at the end
0: 			 * of modifyAccessPath() because the new child of the PRN above
0: 			 * us would have a tableNumber of -1 instead of our tableNumber.)
0: 			 */
0: 			((FromTable)treeTop).setTableNumber(tableNumber);
0: 			treeTop.setReferencedTableMap((JBitSet) referencedTableMap.clone());
0: 			all = true;
0: 		}
0: 
0: 		/* Generate the OrderByNode if a sort is still required for
0: 		 * the order by.
0: 		 */
0: 		if (orderByList != null)
0: 		{
0: 			treeTop = (ResultSetNode) getNodeFactory().getNode(
0: 											C_NodeTypes.ORDER_BY_NODE,
0: 											treeTop,
0: 											orderByList,
0: 											tableProperties,
0: 											getContextManager());
0: 		}
0: 		return treeTop;
0: 	}
0: 
0: 	/**
0: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
0: 	 * for how this should be done for tree printing.
0: 	 *
0: 	 * @return	This object as a String
0: 	 */
0: 
0: 	public String toString()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			return 	"all: " + all + "\n" +
0: 			 	"tableConstructor: " + tableConstructor + "\n" +
0: 				"orderByList: " + 
0: 				(orderByList != null ? orderByList.toString() : "null") + "\n" +
0: 				super.toString();
0: 		}
0: 		else
0: 		{
0: 			return "";
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Bind the expressions under this TableOperatorNode.  This means
0: 	 * binding the sub-expressions, as well as figuring out what the
0: 	 * return type is for each expression.
0: 	 *
0: 	 * @return	Nothing
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public void bindExpressions(FromList fromListParam)
0: 				throws StandardException
0: 	{
0: 		super.bindExpressions(fromListParam);
0: 
0: 		/*
0: 		** Each ? parameter in a table constructor that is not in an insert
0: 		** statement takes its type from the first non-? in its column
0: 		** of the table constructor.  It's an error to have a column that
0: 		** has all ?s.  Do this only for the top of the table constructor
0: 		** list - we don't want to do this for every level of union node
0: 		** in the table constructor.  Also, don't do this for an INSERT -
0: 		** the types of the ? parameters come from the columns being inserted
0: 		** into in that case.
0: 		*/
0: 		if (topTableConstructor && ( ! insertSource) )
0: 		{
0: 			/*
0: 			** Step through all the rows in the table constructor to
0: 			** get the type of the first non-? in each column.
0: 			*/
0: 			DataTypeDescriptor[]	types =
0: 				new DataTypeDescriptor[leftResultSet.getResultColumns().size()];
0: 			
0: 			ResultSetNode	rsn;
0: 			int				numTypes = 0;
0: 
0: 			/* By looping through the union nodes, we avoid recursion */
0: 			for (rsn = this; rsn instanceof UnionNode; )
0: 			{
0: 				UnionNode		union = (UnionNode) rsn;
0: 
0: 				/*
0: 				** Assume that table constructors are left-deep trees of
0: 				** UnionNodes with RowResultSet nodes on the right.
0: 				*/
0: 				if (SanityManager.DEBUG)
0: 					SanityManager.ASSERT(
0: 					 union.rightResultSet instanceof RowResultSetNode,
0: 					 "A " + union.rightResultSet.getClass().getName() +
0: 					 " is on the right side of a union in a table constructor");
0: 
0: 				RowResultSetNode	rrsn =
0: 										(RowResultSetNode) union.rightResultSet;
0: 
0: 				numTypes += getParamColumnTypes(types, rrsn);
0: 
0: 				rsn = union.leftResultSet;
0: 			}
0: 
0: 			/* The last node on the left should be a result set node */
0: 			if (SanityManager.DEBUG)
0: 				SanityManager.ASSERT(rsn instanceof RowResultSetNode);
0: 
0: 			numTypes += getParamColumnTypes(types, (RowResultSetNode) rsn);
0: 
0: 			/* Are there any columns that are all ? parameters? */
0: 			if (numTypes < types.length)
0: 			{
0: 			  throw StandardException.newException(SQLState.LANG_TABLE_CONSTRUCTOR_ALL_PARAM_COLUMN);
0: 			}
0: 
0: 			/*
0: 			** Loop through the nodes again. This time, look for parameter
0: 			** nodes, and give them the type from the type array we just
0: 			** constructed.
0: 			*/
0: 			for (rsn = this; rsn instanceof UnionNode; )
0: 			{
0: 				UnionNode		union = (UnionNode) rsn;
0: 				RowResultSetNode	rrsn =
0: 										(RowResultSetNode) union.rightResultSet;
0: 
0: 				setParamColumnTypes(types, rrsn);
0: 
0: 				rsn = union.leftResultSet;
0: 			}
0: 
0: 			setParamColumnTypes(types, (RowResultSetNode) rsn);
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Bind the result columns of this ResultSetNode when there is no
0: 	 * base table to bind them to.  This is useful for SELECT statements,
0: 	 * where the result columns get their types from the expressions that
0: 	 * live under them.
0: 	 *
0: 	 * @param fromListParam		FromList to use/append to.
0: 	 *
0: 	 * @return	Nothing
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void bindResultColumns(FromList fromListParam)
0: 					throws StandardException
0: 	{
0: 		super.bindResultColumns(fromListParam);
0: 
0: 		/* Now we build our RCL */
0: 		buildRCL();
0: 	}
0: 
0: 	/**
0: 	 * Bind the result columns for this ResultSetNode to a base table.
0: 	 * This is useful for INSERT and UPDATE statements, where the
0: 	 * result columns get their types from the table being updated or
0: 	 * inserted into.
0: 	 * If a result column list is specified, then the verification that the 
0: 	 * result column list does not contain any duplicates will be done when
0: 	 * binding them by name.
0: 	 *
0: 	 * @param targetTableDescriptor	The TableDescriptor for the table being
0: 	 *				updated or inserted into
0: 	 * @param targetColumnList	For INSERT statements, the user
0: 	 *					does not have to supply column
0: 	 *					names (for example, "insert into t
0: 	 *					values (1,2,3)".  When this
0: 	 *					parameter is null, it means that
0: 	 *					the user did not supply column
0: 	 *					names, and so the binding should
0: 	 *					be done based on order.  When it
0: 	 *					is not null, it means do the binding
0: 	 *					by name, not position.
0: 	 * @param statement			Calling DMLStatementNode (Insert or Update)
0: 	 * @param fromListParam		FromList to use/append to.
0: 	 *
0: 	 * @return	Nothing
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public void bindResultColumns(TableDescriptor targetTableDescriptor,
0: 					FromVTI targetVTI,
0: 					ResultColumnList targetColumnList,
0: 					DMLStatementNode statement,
0: 					FromList fromListParam)
0: 				throws StandardException
0: 	{
0: 		super.bindResultColumns(targetTableDescriptor,
0: 								targetVTI,
0: 								targetColumnList, statement,
0: 								fromListParam);
0: 
0: 		/* Now we build our RCL */
0: 		buildRCL();
0: 	}
0: 
0: 	/**
0: 	 * Build the RCL for this node.  We propagate the RCL up from the
0: 	 * left child to form this node's RCL.
0: 	 *
0: 	 * @return	Nothing
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	private void buildRCL() throws StandardException
0: 	{
0: 		/* Verify that both sides of the union have the same # of columns in their
0: 		 * RCL.
0: 		 */
0: 		if (leftResultSet.getResultColumns().size() !=
0: 			rightResultSet.getResultColumns().size())
0: 		{
0: 			throw StandardException.newException(SQLState.LANG_UNION_UNMATCHED_COLUMNS);
0: 		}
0: 
0: 		/* We need to recreate resultColumns for this node, since there
0: 		 * may have been 1 or more *'s in the left's SELECT list.
0: 		 */
0: 		resultColumns = leftResultSet.getResultColumns().copyListAndObjects();
0: 
0: 		/* Create new expressions with the dominant types after verifying
0: 		 * union compatibility between left and right sides.
0: 		 */
0: 		resultColumns.setUnionResultExpression(rightResultSet.getResultColumns(), tableNumber, level);
0: 	}
0: 
0: 	/**
0: 	 * Bind the result columns of a table constructor to the types in the
0: 	 * given ResultColumnList.  Use when inserting from a table constructor,
0: 	 * and there are nulls in the values clauses.
0: 	 *
0: 	 * @param rcl	The ResultColumnList with the types to bind to
0: 	 *
0: 	 * @exception StandardException		Thrown on error.
0: 	 */
0: 	public void bindUntypedNullsToResultColumns(ResultColumnList rcl)
0: 				throws StandardException
0: 	{
0: 		/*
0: 		** If the RCL from the parent is null, then
0: 		** the types are coming from the union itself.
0: 		** So we have to cross check the two child
0: 		** rcls.
0: 		*/
0: 		if (rcl == null)
0: 		{
0: 			ResultColumnList lrcl = rightResultSet.getResultColumns();
0: 			ResultColumnList rrcl = leftResultSet.getResultColumns();
0: 
0: 			leftResultSet.bindUntypedNullsToResultColumns(rrcl);
0: 			rightResultSet.bindUntypedNullsToResultColumns(lrcl);
0: 		}
0: 		else	
0: 		{
0: 			leftResultSet.bindUntypedNullsToResultColumns(rcl);
0: 			rightResultSet.bindUntypedNullsToResultColumns(rcl);
0: 		}			
0: 	}
0: 
0: 	/**
0: 	 * Get the parameter types from the given RowResultSetNode into the
0: 	 * given array of types.  If an array position is already filled in,
0: 	 * don't clobber it.
0: 	 *
0: 	 * @param types	The array of types to fill in
0: 	 * @param rrsn	The RowResultSetNode from which to take the param types
0: 	 *
0: 	 * @return	The number of new types found in the RowResultSetNode
0: 	 */
0: 	int getParamColumnTypes(DataTypeDescriptor[] types, RowResultSetNode rrsn)
0: 	{
0: 		int	numTypes = 0;
0: 
0: 		/* Look for columns where we have not found a non-? yet. */
0: 		for (int i = 0; i < types.length; i++)
0: 		{
0: 			if (types[i] == null)
0: 			{
0: 				ResultColumn rc =
0: 					(ResultColumn) rrsn.getResultColumns().elementAt(i);
0: 				if ( ! (rc.getExpression().isParameterNode()))
0: 				{
0: 					types[i] = rc.getExpressionType();
0: 					numTypes++;
0: 				}
0: 			}
0: 		}
0: 
0: 		return numTypes;
0: 	}
0: 
0: 	/**
0: 	 * Set the type of each ? parameter in the given RowResultSetNode
0: 	 * according to its ordinal position in the given array of types.
0: 	 *
0: 	 * @param types	An array of types containing the proper type for each
0: 	 *				? parameter, by ordinal position.
0: 	 * @param rrsn	A RowResultSetNode that could contain ? parameters whose
0: 	 *				types need to be set.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	void setParamColumnTypes(DataTypeDescriptor[] types, RowResultSetNode rrsn)
0: 					throws StandardException
0: 	{
0: 		/*
0: 		** Look for ? parameters in the result column list
0: 		** of each RowResultSetNode
0: 		*/
0: 		ResultColumnList rrcl = rrsn.getResultColumns();
0: 		int rrclSize = rrcl.size();
0: 		for (int index = 0; index < rrclSize; index++)
0: 		{
0: 			ResultColumn	rc = (ResultColumn) rrcl.elementAt(index);
0: 
0: 			if (rc.getExpression().isParameterNode())
0: 			{
0: 				/*
0: 				** We found a ? - set its type to the type from the
0: 				** type array.
0: 				*/
0: 				((ParameterNode) rc.getExpression()).setDescriptor(
0: 											types[index]);
0: 			}
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Bind the expressions in the target list.  This means binding the
0: 	 * sub-expressions, as well as figuring out what the return type is
0: 	 * for each expression.  This is useful for EXISTS subqueries, where we
0: 	 * need to validate the target list before blowing it away and replacing
0: 	 * it with a SELECT true.
0: 	 *
0: 	 * @return	Nothing
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public void bindTargetExpressions(FromList fromListParam)
0: 					throws StandardException
0: 	{
0: 		leftResultSet.bindTargetExpressions(fromListParam);
0: 		rightResultSet.bindTargetExpressions(fromListParam);
0: 	}
0: 
0: 	/**
0: 	 * Push the order by list down from the cursor node
0: 	 * into its child result set so that the optimizer
0: 	 * has all of the information that it needs to 
0: 	 * consider sort avoidance.
0: 	 *
0: 	 * @param orderByList	The order by list
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	void pushOrderByList(OrderByList orderByList)
0: 	{
0: 		this.orderByList = orderByList;
0: 	}
0: 
0: 	/** 
0: 	 * Put a ProjectRestrictNode on top of each FromTable in the FromList.
0: 	 * ColumnReferences must continue to point to the same ResultColumn, so
0: 	 * that ResultColumn must percolate up to the new PRN.  However,
0: 	 * that ResultColumn will point to a new expression, a VirtualColumnNode, 
0: 	 * which points to the FromTable and the ResultColumn that is the source for
0: 	 * the ColumnReference.  
0: 	 * (The new PRN will have the original of the ResultColumnList and
0: 	 * the ResultColumns from that list.  The FromTable will get shallow copies
0: 	 * of the ResultColumnList and its ResultColumns.  ResultColumn.expression
0: 	 * will remain at the FromTable, with the PRN getting a new 
0: 	 * VirtualColumnNode for each ResultColumn.expression.)
0: 	 * We then project out the non-referenced columns.  If there are no referenced
0: 	 * columns, then the PRN's ResultColumnList will consist of a single ResultColumn
0: 	 * whose expression is 1.
0: 	 *
0: 	 * @param numTables			Number of tables in the DML Statement
0: 	 * @param gbl				The group by list, if any
0: 	 * @param fromList			The from list, if any
0: 	 *
0: 	 * @return The generated ProjectRestrictNode atop the original FromTable.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public ResultSetNode preprocess(int numTables,
0: 									GroupByList gbl,
0: 									FromList fromList)
0: 								throws StandardException
0: 	{
0: 		ResultSetNode newTop = this;
0: 
0: 		/* RESOLVE - what does numTables and referencedTableMap mean here? */
0: 		leftResultSet = leftResultSet.preprocess(numTables, gbl, fromList);
0: 		rightResultSet = rightResultSet.preprocess(numTables, gbl, fromList);
0: 
0: 		/* Build the referenced table map (left || right) */
0: 		referencedTableMap = (JBitSet) leftResultSet.getReferencedTableMap().clone();
0: 		referencedTableMap.or((JBitSet) rightResultSet.getReferencedTableMap());
0: 
0: 		/* If this is a UNION without an all and we have
0: 		 * an order by then we can consider eliminating the sort for the
0: 		 * order by.  All of the columns in the order by list must
0: 		 * be ascending in order to do this.  There are 2 cases:
0: 		 *	o	The order by list is an in order prefix of the columns
0: 		 *		in the select list.  In this case the output of the
0: 		 *		sort from the distinct will be in the right order
0: 		 *		so we simply eliminate the order by list.
0: 		 *	o	The order by list is a subset of the columns in the
0: 		 *		the select list.  In this case we need to reorder the
0: 		 *		columns in the select list so that the ordering columns
0: 		 *		are an in order prefix of the select list and put a PRN
0: 		 *		above the select so that the shape of the result set
0: 		 *		is as expected.
0: 		 */
0: 		if ((! all) && orderByList != null && orderByList.allAscending())
0: 		{
0: 			/* Order by list currently restricted to columns in select
0: 			 * list, so we will always eliminate the order by here.
0: 			 */
0: 			if (orderByList.isInOrderPrefix(resultColumns))
0: 			{
0: 				orderByList = null;
0: 			}
0: 			/* RESOLVE - We currently only eliminate the order by if it is
0: 			 * a prefix of the select list.  We do not currently do the 
0: 			 * elimination if the order by is not a prefix because the code
0: 			 * doesn't work.  The problem has something to do with the
0: 			 * fact that we generate additional nodes between the union
0: 			 * and the PRN (for reordering that we would generate here)
0: 			 * when modifying the access paths.  VCNs under the PRN can be
0: 			 * seen as correlated since their source resultset is the Union
0: 			 * which is no longer the result set directly under them.  This
0: 			 * causes the wrong code to get generated. (jerry - 11/3/98)
0: 			 * (bug 59)
0: 			 */
0: 		}
0: 
0: 		return newTop;
0: 	}
0: 	
0: 	/**
0: 	 * Ensure that the top of the RSN tree has a PredicateList.
0: 	 *
0: 	 * @param numTables			The number of tables in the query.
0: 	 * @return ResultSetNode	A RSN tree with a node which has a PredicateList on top.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public ResultSetNode ensurePredicateList(int numTables) 
0: 		throws StandardException
0: 	{
0: 		return genProjectRestrict(numTables);
0: 	}
0: 
0: 	/**
0: 	 * Verify that a SELECT * is valid for this type of subquery.
0: 	 *
0: 	 * @param outerFromList	The FromList from the outer query block(s)
0: 	 * @param subqueryType	The subquery type
0: 	 *
0: 	 * @return	None
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void verifySelectStarSubquery(FromList outerFromList, int subqueryType) 
0: 					throws StandardException
0: 	{
0: 		/* Check both sides - SELECT * is not valid on either side */
0: 		leftResultSet.verifySelectStarSubquery(outerFromList, subqueryType);
0: 		rightResultSet.verifySelectStarSubquery(outerFromList, subqueryType);
0: 	}
0: 
0: 	/** 
0: 	 * Determine whether or not the specified name is an exposed name in
0: 	 * the current query block.
0: 	 *
0: 	 * @param name	The specified name to search for as an exposed name.
0: 	 * @param schemaName	Schema name, if non-null.
0: 	 * @param exactMatch	Whether or not we need an exact match on specified schema and table
0: 	 *						names or match on table id.
0: 	 *
0: 	 * @return The FromTable, if any, with the exposed name.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	protected FromTable getFromTableByName(String name, String schemaName, boolean exactMatch)
0: 		throws StandardException
0: 	{
0: 		/* We search both sides for a TableOperatorNode (join nodes)
0: 		 * but only the left side for a UnionNode.
0: 		 */
0: 		return leftResultSet.getFromTableByName(name, schemaName, exactMatch);
0: 	}
0: 
0: 	/**
0: 	 * Set the result column for the subquery to a boolean true,
0: 	 * Useful for transformations such as
0: 	 * changing:
0: 	 *		where exists (select ... from ...) 
0: 	 * to:
0: 	 *		where (select true from ...)
0: 	 *
0: 	 * NOTE: No transformation is performed if the ResultColumn.expression is
0: 	 * already the correct boolean constant.
0: 	 * 
0: 	 * @param onlyConvertAlls	Boolean, whether or not to just convert *'s
0: 	 *
0: 	 * @return Nothing.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void setResultToBooleanTrueNode(boolean onlyConvertAlls)
0: 				throws StandardException
0: 	{
0: 		super.setResultToBooleanTrueNode(onlyConvertAlls);
0: 		leftResultSet.setResultToBooleanTrueNode(onlyConvertAlls);
0: 		rightResultSet.setResultToBooleanTrueNode(onlyConvertAlls);
0: 	}
0: 
0: 	/**
0: 	 * This ResultSet is the source for an Insert.  The target RCL
0: 	 * is in a different order and/or a superset of this RCL.  In most cases
0: 	 * we will reorder and/or add defaults to the current RCL so that is
0: 	 * matches the target RCL.  Those RSNs whose generate() method does
0: 	 * not handle projects will insert a PRN, with a new RCL which matches
0: 	 * the target RCL, above the current RSN.
0: 	 * NOTE - The new or enhanced RCL will be fully bound.
0: 	 *
0: 	 * @param numTargetColumns	# of columns in target RCL
0: 	 * @param colMap[]			int array representation of correspondence between
0: 	 *							RCLs - colmap[i] = -1 -> missing in current RCL
0: 	 *								   colmap[i] = j -> targetRCL(i) <-> thisRCL(j+1)
0: 	 * @param dataDictionary	DataDictionary to use
0: 	 * @param targetTD			TableDescriptor for target if the target is not a VTI, null if a VTI
0:      * @param targetVTI         Target description if it is a VTI, null if not a VTI
0: 	 *
0: 	 * @return ResultSetNode	The new top of the tree
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public ResultSetNode enhanceRCLForInsert(int numTargetColumns, int[] colMap, 
0: 											 DataDictionary dataDictionary,
0: 											 TableDescriptor targetTD,
0:                                              FromVTI targetVTI)
0: 			throws StandardException
0: 	{
0: 		// our newResultCols are put into the bound form straight away.
0: 		ResultColumnList newResultCols =
0: 								(ResultColumnList) getNodeFactory().getNode(
0: 												C_NodeTypes.RESULT_COLUMN_LIST,
0: 												getContextManager());
0: 		int numResultSetColumns = resultColumns.size();
0: 
0: 		/* Create a massaged version of the source RCL.
0: 		 * (Much simpler to build new list and then assign to source,
0: 		 * rather than massage the source list in place.)
0: 		 */
0: 		for (int index = 0; index < numTargetColumns; index++)
0: 		{
0: 			ResultColumn	newResultColumn;
0: 			ResultColumn	oldResultColumn;
0: 			ColumnReference newColumnReference;
0: 
0: 			if (colMap[index] != -1)
0: 			{
0: 				// getResultColumn uses 1-based positioning, so offset the colMap entry appropriately
0: 				oldResultColumn = resultColumns.getResultColumn(colMap[index]+1);
0: 
0: 				newColumnReference = (ColumnReference) getNodeFactory().getNode(
0: 												C_NodeTypes.COLUMN_REFERENCE,
0: 												oldResultColumn.getName(),
0: 												null,
0: 												getContextManager());
0: 				/* The ColumnReference points to the source of the value */
0: 				newColumnReference.setSource(oldResultColumn);
0: 				// colMap entry is 0-based, columnId is 1-based.
0: 				newColumnReference.setType(oldResultColumn.getExpressionType());
0: 
0: 				// Source of an insert, so nesting levels must be 0
0: 				newColumnReference.setNestingLevel(0);
0: 				newColumnReference.setSourceLevel(0);
0: 
0: 				// because the insert already copied the target table's
0: 				// column descriptors into the result, we grab it from there.
0: 				// alternatively, we could do what the else clause does,
0: 				// and look it up in the DD again.
0: 				newResultColumn = (ResultColumn) getNodeFactory().getNode(
0: 						C_NodeTypes.RESULT_COLUMN,
0: 						oldResultColumn.getType(),
0: 						newColumnReference,
0: 						getContextManager());
0: 			}
0: 			else
0: 			{
0: 				newResultColumn = genNewRCForInsert(targetTD, targetVTI, index + 1, dataDictionary);
0: 			}
0: 
0: 			newResultCols.addResultColumn(newResultColumn);
0: 		}
0: 
0: 		/* The generated ProjectRestrictNode now has the ResultColumnList
0: 		 * in the order that the InsertNode expects.
0: 		 * NOTE: This code here is an exception to several "rules":
0: 		 *		o  This is the only ProjectRestrictNode that is currently
0: 		 *		   generated outside of preprocess().
0: 		 *	    o  The UnionNode is the only node which is not at the
0: 		 *		   top of the query tree which has ColumnReferences under
0: 		 *		   its ResultColumnList prior to expression push down.
0: 		 */
0: 		return (ResultSetNode) getNodeFactory().getNode(
0: 									C_NodeTypes.PROJECT_RESTRICT_NODE,
0: 									this,
0: 									newResultCols,
0: 									null,
0: 									null,
0: 									null,
0: 									null,
0: 									tableProperties,
0: 									getContextManager());
0: 	}
0: 
0: 	/**
0: 	 * Evaluate whether or not the subquery in a FromSubquery is flattenable.  
0: 	 * Currently, a FSqry is flattenable if all of the following are true:
0: 	 *		o  Subquery is a SelectNode. (ie, not a RowResultSetNode or a UnionNode)
0: 	 *		o  It contains no top level subqueries.  (RESOLVE - we can relax this)
0: 	 *		o  It does not contain a group by or having clause
0: 	 *		o  It does not contain aggregates.
0: 	 *
0: 	 * @param fromList	The outer from list
0: 	 *
0: 	 * @return boolean	Whether or not the FromSubquery is flattenable.
0: 	 */
0: 	public boolean flattenableInFromSubquery(FromList fromList)
0: 	{
0: 		/* Unions in FromSubquerys are not flattenable.	 */
0: 		return false;
0: 	}
0: 
0: 	/**
0: 	 * Return whether or not to materialize this ResultSet tree.
0: 	 *
0: 	 * @return Whether or not to materialize this ResultSet tree.
0: 	 *			would return valid results.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public boolean performMaterialization(JBitSet outerTables)
0: 		throws StandardException
0: 	{
0: 		// RESOLVE - just say no to materialization right now - should be a cost based decision
0: 		return false;
0: 
0: 		/* Actual materialization, if appropriate, will be placed by our parent PRN.
0: 		 * This is because PRN might have a join condition to apply.  (Materialization
0: 		 * can only occur before that.
0: 		 */
0: 		//return true;
0: 	}
0: 
0:     /**
0: 	 * Generate the code for this UnionNode.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0:      */
0: 	public void generate(ActivationClassBuilder acb,
0: 								MethodBuilder mb)
0: 							throws StandardException
0: 	{
0: 		/*  By the time we get here we should be a union all.
0: 		 *  (We created a DistinctNode above us, if needed,
0: 		 *  to eliminate the duplicates earlier.)
0: 		 */
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(all,
0: 				"all expected to be true");
0: 		}
0: 
0: 		/* Get the next ResultSet #, so that we can number this ResultSetNode, its
0: 		 * ResultColumnList and ResultSet.
0: 		 */
0: 		assignResultSetNumber();
0: 
0: 		// build up the tree.
0: 
0: 		acb.pushGetResultSetFactoryExpression(mb); // instance for getUnionResultSet
0: 
0: 
0: 		/* Generate the left and right ResultSets */
0: 		leftResultSet.generate(acb, mb);
0: 
0: 		/* Do we need a NormalizeResultSet above the left ResultSet? */
0: 		if (! resultColumns.isExactTypeAndLengthMatch(leftResultSet.getResultColumns()))
0: 		{
0: 			acb.pushGetResultSetFactoryExpression(mb);
0: 			mb.swap();
0: 			generateNormalizationResultSet(acb, mb, 
0: 													getCompilerContext().getNextResultSetNumber(),
0: 													makeResultDescription()
0: 													);
0: 		}
0: 
0: 		rightResultSet.generate(acb, mb);
0: 
0: 		/* Do we need a NormalizeResultSet above the right ResultSet? */
0: 		if (! resultColumns.isExactTypeAndLengthMatch(rightResultSet.getResultColumns()))
0: 		{
0: 			acb.pushGetResultSetFactoryExpression(mb);
0: 			mb.swap();
0: 			generateNormalizationResultSet(acb, mb,
0: 													getCompilerContext().getNextResultSetNumber(),
0: 													makeResultDescription()
0: 													);
0: 		}
0: 
0: 		/* Generate the UnionResultSet:
0: 		 *	arg1: leftExpression - Expression for leftResultSet
0: 		 *	arg2: rightExpression - Expression for rightResultSet
0: 		 *  arg3: Activation
0: 		 *  arg4: resultSetNumber
0: 		 *  arg5: estimated row count
0: 		 *  arg6: estimated cost
0: 		 *  arg7: close method
0: 		 */
0: 
0: 
0: 		acb.pushThisAsActivation(mb);
0: 		mb.push(resultSetNumber);
0: 		mb.push(costEstimate.rowCount());
0: 		mb.push(costEstimate.getEstimatedCost());
0: 		closeMethodArgument(acb, mb);
0: 
0: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, "getUnionResultSet", ClassName.NoPutResultSet, 7);
0: 	}
0: }
============================================================================