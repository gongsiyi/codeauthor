6:b343735: /*
1:0c7de0f: 
1:b343735:    Derby - Class org.apache.derbyTesting.functionTests.tests.jdbcapi.DataSourceTest
1:9cf3fb5: 
1:b343735:    Licensed to the Apache Software Foundation (ASF) under one or more
1:b343735:    contributor license agreements.  See the NOTICE file distributed with
1:b343735:    this work for additional information regarding copyright ownership.
1:b343735:    The ASF licenses this file to You under the Apache License, Version 2.0
1:b343735:    (the "License"); you may not use this file except in compliance with
1:b343735:    the License.  You may obtain a copy of the License at
1:78f94f1: 
1:b343735:       http://www.apache.org/licenses/LICENSE-2.0
283:b343735: 
1:b343735:    Unless required by applicable law or agreed to in writing, software
1:b343735:    distributed under the License is distributed on an "AS IS" BASIS,
1:b343735:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:b343735:    See the License for the specific language governing permissions and
1:b343735:    limitations under the License.
1:b343735: 
21:b343735:  */
1:b343735: 
1:b343735: package org.apache.derbyTesting.functionTests.tests.jdbcapi;
1:b343735: 
1:b343735: import java.io.File;
1:b343735: import java.sql.CallableStatement;
1:b343735: import java.sql.Connection;
1:b343735: import java.sql.ResultSet;
1:b343735: import java.sql.SQLException;
1:b343735: import java.sql.Statement;
1:b343735: import java.util.Hashtable;
1:b343735: import javax.sql.DataSource;
1:b343735: import junit.framework.Test;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:c35e4f0: import org.apache.derby.jdbc.ClientDataSourceInterface;
1:38667d9: import org.apache.derby.jdbc.BasicEmbeddedDataSource40;
1:e18f54b: import org.apache.derbyTesting.functionTests.util.PrivilegedFileOpsForTests;
1:b343735: import org.apache.derbyTesting.functionTests.util.SecurityCheck;
1:b343735: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:0c7de0f: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1:b343735: import org.apache.derbyTesting.junit.JDBC;
1:0f9b584: import org.apache.derbyTesting.junit.JDBCClient;
1:b343735: import org.apache.derbyTesting.junit.JDBCDataSource;
1:b343735: import org.apache.derbyTesting.junit.TestConfiguration;
1:b343735: 
1:0c7de0f: /**
1:0f9b584:  * Test the various DataSource implementations of Derby, but not
1:0f9b584:  * ConnectionPoolDataSource or XADataSource; those are tested in
1:0f9b584:  * J2EEDataSourceTest.
1:0c7de0f:  * 
1:b343735:  * Performs SecurityCheck analysis on the JDBC objects returned.
1:b343735:  * This is because this test returns to the client a number of
1:b343735:  * different implementations of Connection, Statement etc.
13:b343735:  * 
1:b343735:  * @see org.apache.derbyTesting.functionTests.util.SecurityCheck
1:b343735:  *
1:0c7de0f:  */
1:b343735: public class DataSourceTest extends BaseJDBCTestCase {
1:b343735: 
1:1fd325f:     private static final String dbName = 
1:b343735:         TestConfiguration.getCurrent().getDefaultDatabaseName();
1:b343735:     
19:b343735:     /**
1:b343735:      * A hashtable of opened connections.  This is used when checking to
1:b343735:      * make sure connection strings are unique; we need to make sure all
1:b343735:      * the connections are closed when we are done, so they are stored
1:b343735:      * in this hashtable
1:b343735:      */
1:e18f54b:     protected static Hashtable<String, Connection> conns =
1:e18f54b:             new Hashtable<String, Connection>();
1:b343735:     
1:b343735:     /** The expected format of a connection string. In English:
1:b343735:      * "<classname>@<hashcode> (XID=<xid>), (SESSION = <sessionid>),
1:b343735:      *  (DATABASE=<dbname>), (DRDAID = <drdaid>)"
1:b343735:      */
1:59c44b2:     private static final String CONNSTRING_FORMAT = 
1:73d44eb:         "\\S+@\\-?[0-9]+.* \\(XID = .*\\), \\(SESSIONID = [0-9]+\\), " +
1:59c44b2:         "\\(DATABASE = [A-Za-z]+\\), \\(DRDAID = .*\\) "; 
1:59c44b2:     
1:b343735:     
1:b343735:     /**
1:b343735:      * Hang onto the SecurityCheck class while running the
1:b343735:      * tests so that it is not garbage collected during the
1:b343735:      * test and lose the information it has collected,
1:b343735:      * in case it should get printed out.
1:b343735:      */
1:b343735:     private final Object nogc = SecurityCheck.class;
1:b343735:     
1:b343735:     public DataSourceTest(String name) {
1:b343735:         super(name);
1:0c7de0f:     }
1:4e0e1f1:     
1:5b20343:     /**
1:0c7de0f:      * Return a suite of tests that are run with both client and embedded
1:5b20343:      * 
1:5b20343:      * @param postfix suite name postfix
1:0c7de0f:      * @return A suite of tests to be run with client and/or embedded
1:5b20343:      */
1:0c7de0f:     private static Test baseSuite(String postfix) {
1:1ae02c9:         BaseTestSuite
1:1ae02c9:             suite = new BaseTestSuite("ClientAndEmbedded" + postfix);
1:1ae02c9: 
1:0c7de0f:         suite.addTest(new DataSourceTest("testBadConnectionAttributeSyntax"));
1:0c7de0f:         suite.addTest(new DataSourceTest("testDescriptionProperty"));
1:0c7de0f:         suite.addTest(new DataSourceTest("testAllDataSources"));
1:f9f8329:         suite.addTest(new DataSourceTest("testJira95ds"));
1:5b20343:         return suite;
1:5b20343:     }
1:5b20343: 
1:0c7de0f:     /**
1:0c7de0f:      * Return a suite of tests that are run with client only
1:0c7de0f:      * 
1:0c7de0f:      * @return A suite of tests being run with client only
1:0c7de0f:      */
1:0c7de0f:     private static Test getClientSuite() {
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite("Client/Server");
1:0c7de0f:         suite.addTest(new DataSourceTest("testClientDSConnectionAttributes"));
1:0c7de0f:         suite.addTest(new DataSourceTest(
1:0c7de0f:                 "testClientTraceFileDSConnectionAttribute"));
1:0c7de0f:         suite.addTest(new DataSourceTest(
1:0c7de0f:                 "testClientMessageTextConnectionAttribute"));
2:0c7de0f:         return suite;
1:0c7de0f:     }
1:0c7de0f:     
1:0c7de0f:     /**
1:0c7de0f:      * Return a suite of tests that are run with embedded only
1:0c7de0f:      * 
2:0c7de0f:      * @param postfix suite name postfix
1:0c7de0f:      * @return A suite of tests being run with embedded only
1:0c7de0f:      */
1:0c7de0f:     private static Test getEmbeddedSuite(String postfix) {
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite("Embedded" + postfix);
1:0c7de0f:         suite.addTest(new DataSourceTest("testDSRequestAuthentication"));
1:0c7de0f:         return suite;
1:0c7de0f:     }
1:0c7de0f:     
1:b343735:     public static Test suite() {
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite("DataSourceTest suite");
1:0f9b584:         // Add the tests that only run with embedded
1:0f9b584:         suite.addTest(getEmbeddedSuite("embedded"));
1:0f9b584:         // Add tests that will run with embedded
1:0f9b584:         suite.addTest(baseSuite(":embedded"));
1:0f9b584:         if (!JDBC.vmSupportsJSR169()) {
1:0c7de0f:             //  and network server/client
1:5b20343:             suite.addTest(TestConfiguration.clientServerDecorator(
1:0c7de0f:                     baseSuite(":client")));
1:0c7de0f:             // Add the tests that only run with client
2:0c7de0f:             suite.addTest(TestConfiguration.clientServerDecorator(
1:0c7de0f:                     getClientSuite()));
1:c005646:         }
1:0f9b584:         // wrap all in CleanDatabaseTestSetup that creates all database
1:0f9b584:         // objects any fixture might need.
1:0f9b584:         // Note that not all fixtures need (all of) these.
1:0f9b584:         return new CleanDatabaseTestSetup(suite) {
1:0f9b584:             /**
1:0f9b584:              * Create and populate database objects
1:0f9b584:              * 
1:0f9b584:              * @see org.apache.derbyTesting.junit.CleanDatabaseTestSetup#decorateSQL(java.sql.Statement)
1:0f9b584:              */
1:0f9b584:             protected void decorateSQL(Statement s) throws SQLException {
1:0f9b584:                 s.executeUpdate("create table intTable(i int)");
1:0f9b584:             }
1:0f9b584:         };
1:0c7de0f:     }
1:b343735:     
1:b343735:     public void tearDown() throws Exception {
1:b343735:         // attempt to get rid of any left-over trace files
1:e18f54b:         for (int i = 0; i < 6; i++) {
1:e18f54b:             String traceFileName = "trace" + (i + 1) + ".out";
1:e18f54b:             File traceFile = new File(traceFileName);
1:e18f54b:             if (PrivilegedFileOpsForTests.exists(traceFile)) {
1:e18f54b:                 // if it exists, attempt to get rid of it
1:e18f54b:                 PrivilegedFileOpsForTests.delete(traceFile);
1:e18f54b:             }
143:b343735:         }
1:c005646:         super.tearDown();
1:b343735:     }
1:b343735: 
1:0f9b584:     // the J2EEDataSourceTest version of this includes testing for
1:0f9b584:     // setTypeMap, which is supported for both EmbeddedDataSource and
1:5570eb0:     // ClientDataSource
1:b343735:     public void testAllDataSources() throws SQLException, Exception
58:b343735:     {
1:0f9b584:         //Connection dmc = getConnection();
1:0c7de0f:         
2:b343735:         Object[] expectedValues = {
1:39b3237:             ResultSet.HOLD_CURSORS_OVER_COMMIT, "XJ010",
1:39b3237:             2, true, false};
1:b343735: 
35:b343735:         if (usingEmbedded())
1:b343735:             assertTenConnectionsUnique();
1:b343735: 
1:1fd325f:         DataSource dscs = JDBCDataSource.getDataSource();
1:b343735:         if (usingEmbedded()) 
1:b343735:                 assertToString(dscs);
1:b343735: 
1:b343735:         DataSource ds = dscs;
1:b343735:         assertConnectionOK(expectedValues, "DataSource", ds.getConnection());
1:b343735:         
1:4e0e1f1:         if (JDBC.vmSupportsJDBC4()) {
1:38667d9:             BasicEmbeddedDataSource40 nds = new BasicEmbeddedDataSource40();
1:4e0e1f1:             nds.setDatabaseName(dbName);
1:4e0e1f1:             assertConnectionOK(
1:38667d9:                     expectedValues, "BasicDataSource", nds.getConnection());
1:4e0e1f1:         }
1:0f9b584:     }            
1:b343735:     
3:b343735:     // test jira-derby 95 - a NullPointerException was returned when passing
1:b343735:     // an incorrect database name, should now give error:
1:b343735:     // XCY00 - invalid valid for property ...  
1:b343735:     // with DataSource
1:b343735:     public void testJira95ds() throws SQLException {
1:0c7de0f:         try {
1:0c7de0f:             DataSource ds = JDBCDataSource.getDataSource();
1:0c7de0f:             // non-existent database
1:0c7de0f:             JDBCDataSource.setBeanProperty(ds, "databaseName", "jdbc:derby:wombat");
1:0c7de0f:             ds.getConnection();
1:0c7de0f:             fail ("expected an SQLException!");
1:0c7de0f:         } catch (SQLException sqle) {
1:f9f8329:             assertSQLState("XCY00", sqle);
1:0c7de0f:         } catch (Exception e) {
1:f9f8329:             fail ("unexpected exception: " + e.toString());
1:0c7de0f:         }
1:0c7de0f:     } 
1:b343735: 
1:0f9b584:     // this fixture has a counterpart for Pooled and XA DataSources in
1:0f9b584:     // J2EEDataSourceTest
1:b343735:     public void testBadConnectionAttributeSyntax() throws SQLException {
1:b343735:         
1:b343735:         // DataSource - bad connattr syntax
1:b343735:         DataSource ds = JDBCDataSource.getDataSource();
1:b343735:         JDBCDataSource.setBeanProperty(ds, "ConnectionAttributes", "bad");
39:b343735:         try {
3:b343735:             ds.getConnection();
3:b343735:             fail ("should have seen an error");
3:b343735:         } catch (SQLException e) {
1:9a82758:             assertSQLState("XJ028", e);
1:b343735:         } 
1:b343735:     } // End testBadConnectionAttributeSyntax
1:b343735:         
1:b343735:     /**
1:b343735:      * Check that database name set using setConnectionAttributes is not used
1:b343735:      * by ClientDataSource. This method tests DERBY-1130.
1:0f9b584:      * this fixture has a counterpart for Pooled and XA DataSources in 
1:0f9b584:      * J2EEDataSourceTest
1:b343735:      * 
7:b343735:      * @throws SQLException
1:b343735:      */
1:c35e4f0:     public void testClientDSConnectionAttributes() throws Exception {
1:0c7de0f:         if (usingEmbedded())
5:b343735:             return;
1:b343735:         
1:c35e4f0:         ClientDataSourceInterface ds = null;
1:c35e4f0: 
1:4469400:         Class<?> clazz;
1:4469400: 
1:c35e4f0:         if (JDBC.vmSupportsJNDI()) {
1:c35e4f0:             // Use reflection to avoid class not found in non-JNDI context
1:4469400:             clazz = Class.forName("org.apache.derby.jdbc.ClientDataSource");
1:4469400:             ds = (ClientDataSourceInterface)clazz.getConstructor().newInstance();
1:c35e4f0:         } else {
1:4469400:             clazz = Class.forName("org.apache.derby.jdbc.BasicClientDataSource40");
1:4469400:             ds = (ClientDataSourceInterface) clazz.getConstructor().newInstance();
1:c35e4f0:         }
1:c35e4f0: 
1:ad60cd5:         ds.setPortNumber(TestConfiguration.getCurrent().getPort());
1:ad60cd5:         
1:b343735:         // DataSource - EMPTY; expect error 08001 in all cases
1:b343735:         // 08001: Required Derby DataSource property databaseName not set.
7:b343735:         dsConnectionRequests(new String[]  
5:b343735:             {"08001","08001","08001","08001",
1:b343735:              "08001","08001","08001","08001","08001"}, ds);
1:b343735: 
1:b343735:         // DataSource - connectionAttributes=databaseName=<valid name>
2:b343735:         ds.setConnectionAttributes("databaseName=" + dbName);
1:b343735:         dsConnectionRequests(new String[]  
1:b343735:             {"08001","08001","08001","08001",
1:b343735:              "08001","08001","08001","08001","08001"}, ds);
4:b343735:         ds.setConnectionAttributes(null);
1:b343735: 
1:b343735:         // Test that (invalid) database name specified in connection
1:b343735:         // attributes is not used
1:b343735:         // DataSource - databaseName=<valid db> and 
3:b343735:         // connectionAttributes=databaseName=kangaroo
2:b343735:         ds.setConnectionAttributes("databaseName=kangaroo");
3:b343735:         ds.setDatabaseName(dbName);
1:b343735:         dsConnectionRequests(new String[]  
1:b343735:             {"OK","08001","OK","OK",
1:b343735:              "08001","08001","OK","OK","OK"}, ds);
1:b343735:         ds.setConnectionAttributes(null);
3:b343735:         ds.setDatabaseName(null);
1:b343735: 
1:b343735:     } // End testClientDSConnectionAttributes
1:b343735:             
1:0c7de0f:     // Following test is similar to testClientDSConnectionAttributes, but
1:b343735:     // for embedded datasources.
1:0f9b584:     // This fixture has a counterpart for Pooled and XA DataSources in
1:0f9b584:     // J2EEDataSourceTest. In that test, the corresponding fixture
1:0f9b584:     // also includes testing for setAttributesAsPassword.
1:0f9b584:     // Note that in this simple shape, there is no authentication done
1:0f9b584:     // but the fixture name is kept the same for reference to the J2EE one.
1:1fd325f:     public void testDSRequestAuthentication() throws SQLException {
1:b343735: 
1:0f9b584:         // Create an empty datasource of the type befitting the jvm/client/server
1:0f9b584:         JDBCClient dsclient = getTestConfiguration().getJDBCClient();
1:0f9b584:         String dsName = dsclient.getDataSourceClassName();
1:0f9b584:         DataSource ds = null;
1:4469400:         Class<?> clazz;
1:0f9b584:         try {
1:4469400:             clazz = Class.forName(dsName);
1:4469400:             ds = (javax.sql.DataSource) clazz.getConstructor().newInstance();
1:0f9b584:         } catch (Exception e) {
1:0f9b584:             fail("unable to complete test because unable to create new instance of datasource");
1:0f9b584:         }
1:b343735: 
1:b343735:         // DataSource - EMPTY
14:b343735:         dsConnectionRequests(new String[] {  
3:b343735:              "XJ004","XJ004","XJ004","XJ004",
1:b343735:              "XJ004","XJ004","XJ004","XJ004","XJ004"}, ds);
1:b343735:  
1:b343735:         // DataSource - connectionAttributes=databaseName=wombat");
1:0f9b584:         JDBCDataSource.setBeanProperty(ds, "connectionAttributes", "databaseName=" + dbName);
1:b343735:         dsConnectionRequests(new String[] {  
1:b343735:             "XJ004","XJ004","XJ004","XJ004",
1:b343735:             "XJ004","XJ004","XJ004","XJ004","XJ004"}, ds);
1:0f9b584:         JDBCDataSource.clearStringBeanProperty(ds, "connectionAttributes");
1:b343735:         ds = null;
1:b343735: 
4:b343735:         TestConfiguration.getCurrent().shutdownDatabase();
1:b343735:     }
1:b343735:     
1:b343735:     /**
1:b343735:      * Check that traceFile connection attribute functions correctly.
1:b343735:      * tracefile was tested in checkDriver, but not for DataSources.
1:b343735:      * tracefile= was used in datasourcepermissions_net, but that's 
1:b343735:      * incorrect syntax. Note that we're not checking the contents of
1:b343735:      * the tracefile.
1:0f9b584:      * 
1:0f9b584:      * This fixture has a counterpart for Pooled and XA DataSources in
1:0f9b584:      * J2EEDataSourceTest
1:b343735:      *
1:b343735:      * Note also that this test cannot run against a remote server.
1:b343735:      *  
1:b343735:      * @throws SQLException
1:b343735:      */
1:b343735:     public void testClientTraceFileDSConnectionAttribute() throws SQLException
1:b343735:     {
1:0c7de0f:         if (usingEmbedded())
1:b343735:             return;
1:b343735: 
1:b343735:         String traceFile;
1:b343735: 
2:b343735:         // DataSource
1:b343735:         DataSource ds = JDBCDataSource.getDataSource();
1:b343735: 
1:b343735:         // DataSource - setTransationAttributes
1:b343735:         traceFile = "trace1.out";
1:1fd325f:         JDBCDataSource.setBeanProperty(ds, "connectionAttributes",
3:1fd325f:         		"traceFile="+traceFile);
1:b343735: 
1:b343735:         // In this scenario, we *only* get a tracefile, if we first get a 
1:b343735:         // successful connection, followed by an unsuccessful connection. 
1:b343735:         // So, we cannot just use ds.getConnection()
1:b343735:         dsGetBadConnection(ds);
1:1fd325f:         JDBCDataSource.clearStringBeanProperty(ds, "connectionAttributes");
1:b343735: 
1:b343735:         // DataSource - setTraceFile
1:b343735:         traceFile = "trace2.out";
1:1fd325f:         JDBCDataSource.setBeanProperty(ds, "traceFile", traceFile);
1:b343735:         ds.getConnection();
1:1fd325f:         ds = null;
1:b343735: 
1:b343735:         assertTraceFilesExist();
1:b343735:     }
1:b343735:         
1:b343735:     /* -- Helper Methods for testClientTraceFileDSConnectionAttribute -- */
1:b343735:     
1:b343735:     private static void dsGetBadConnection(DataSource ds) {
1:b343735:         // first get a good connection, or we don't get a
1:b343735:         // traceFile when using connectionattributes.
1:b343735:         // also, we do not get a tracefile that way unless
1:b343735:         // we see an error.
1:b343735:         // with setTraceFile, we *always* get a file, even
1:b343735:         // with just a successful connection.
1:b343735:         try {
1:b343735:             ds.getConnection();
1:b343735:             ds.getConnection(null, null);
1:b343735:             fail("expected an sqlException");
25:b343735:         } catch (SQLException sqle) {
1:b343735:             assertSQLState("08001", sqle);
1:b343735:         }
1:b343735:     }
1:b343735:     
1:b343735:     /**
1:b343735:      * Check that trace file exists in <framework> directory
1:b343735:      */
1:b343735:     private static void assertTraceFilesExist() 
1:b343735:     {
1:e18f54b:         for (int i = 0; i < 2; i++) {
1:e18f54b:             String traceFileName = "trace" + (i + 1) + ".out";
1:e18f54b:             File traceFile = new File(traceFileName);
1:e18f54b:             assertTrue(PrivilegedFileOpsForTests.exists(traceFile));
1:e18f54b:         }
1:b343735:     }
1:b343735: 
1:b343735:     /**
1:b343735:      * Check that messageText connection attribute functions correctly.
1:b343735:      * retrievemessagetext was tested in checkdriver, and derbynet/testij,
1:b343735:      * but not tested for datasources, and in datasourcepermissions_net,
1:b343735:      * but as it has nothing to do with permissions/authentication,
1:b343735:      * this test seems a better place for it. 
1:0f9b584:      * 
1:0f9b584:      * This fixture has a counterpart for Pooled and XA DataSources in
1:0f9b584:      * J2EEDataSourceTest
1:0f9b584:      * 
1:b343735:      * @throws SQLException
1:b343735:      */
1:c35e4f0:     public void testClientMessageTextConnectionAttribute() throws Exception
1:b343735:     {
1:b343735:         if (usingEmbedded())
1:b343735:             return;
1:b343735:         
1:b343735:         String retrieveMessageTextProperty = "retrieveMessageText";
1:b343735:         Connection conn;
1:b343735: 
1:b343735:         // DataSource
1:b343735:         // DataSource - retrieveMessageTextProperty
1:c35e4f0:         ClientDataSourceInterface ds = null;
1:c35e4f0: 
1:4469400:         Class<?> clazz;
1:c35e4f0:         if (JDBC.vmSupportsJNDI()) {
1:c35e4f0:             // Use reflection to avoid class not found in non-JNDI context
1:4469400:             clazz = Class.forName("org.apache.derby.jdbc.ClientDataSource");
1:4469400:             ds = (ClientDataSourceInterface) clazz.getConstructor().newInstance();
1:c35e4f0:         } else {
1:4469400:             clazz = Class.forName("org.apache.derby.jdbc.BasicClientDataSource40");
1:4469400:             ds = (ClientDataSourceInterface)clazz.getConstructor().newInstance();
1:c35e4f0:         }
1:c35e4f0: 
1:ad60cd5:         ds.setPortNumber(TestConfiguration.getCurrent().getPort());
1:b343735:         ds.setDatabaseName(dbName);
1:b343735:         ds.setConnectionAttributes(retrieveMessageTextProperty + "=false");
1:b343735:         conn = ds.getConnection();
3:b343735:         assertMessageText(conn,"false");
10:b343735:         conn.close();
1:b343735:         // now try with retrieveMessageText = true
1:b343735:         ds.setConnectionAttributes(retrieveMessageTextProperty + "=true");
1:b343735:         conn = ds.getConnection();
3:b343735:         assertMessageText(conn,"true");
1:b343735:         ds.setConnectionAttributes(null);
1:b343735:         conn.close();
1:b343735:     }
1:b343735: 
1:b343735:     /* -- Helper Method for testClientMessageTextDSConnectionAttribute -- */
1:b343735: 
1:b343735:     private static void assertMessageText(
1:b343735:             Connection conn, String retrieveMessageTextValue) 
3:b343735:     throws SQLException
1:b343735:     {
1:b343735:         try {
1:b343735:             conn.createStatement().executeQuery("SELECT * FROM APP.NOTTHERE");
1:b343735:         }
2:b343735:         catch (SQLException e)
1:b343735:         {
1:b343735:             assertSQLState("42X05", e);
1:b343735:             if (retrieveMessageTextValue.equals("true") )
1:b343735:             {
1:b343735:                 assertTrue(e.getMessage().indexOf("does not exist") >= 0);
1:b343735:             }
6:b343735:             else
1:b343735:             {
1:b343735:                 // retrieveMessageTextValue is false
1:b343735:                 assertTrue(e.getMessage().indexOf("does not exist") == -1);
1:b343735:             }
1:b343735:         }
1:b343735:     }
1:b343735: 
1:0c7de0f:     /**
1:b343735:      * Check that messageText connection attribute functions correctly.
1:b343735:      * retrievemessagetext was tested in checkdriver, and derbynet/testij
1:b343735:      * (but not tested for datasources), and in datasourcepermissions_net,
1:b343735:      * but as it has nothing to do with permissions/authentication,
1:b343735:      * this test seems a better place for it. 
1:0f9b584:      * 
1:0f9b584:      * This fixture has a counterpart for Pooled and XA DataSources in
1:0f9b584:      * J2EEDataSourceTest
1:0c7de0f:      *  
1:b343735:      * @throws SQLException
1:0c7de0f:      */
1:1fd325f:     public void testDescriptionProperty() 
1:b343735:     throws SQLException, Exception {
1:b343735:         
1:b343735:         // DataSource - setDescription
1:1fd325f:         subTestDataSourceDescription(JDBCDataSource.getDataSource());
1:b343735:     }
1:b343735:     
1:b343735:     /**
1:1fd325f:      * Utility method for testing setting and fetching the description
1:1fd325f:      * property on a data source.
1:b343735:      */
1:1fd325f:     private void subTestDataSourceDescription(DataSource ds) throws Exception
1:b343735:     {
1:b343735:         String setDescription = 
1:b343735:             "Everything you ever wanted to know about this datasource";
1:b343735:         
1:1fd325f:         JDBCDataSource.setBeanProperty(ds, "description", setDescription);
1:b343735:         ds.getConnection();
1:1fd325f:         assertEquals(setDescription, JDBCDataSource.getBeanProperty(ds, "description"));
1:1fd325f:         JDBCDataSource.clearStringBeanProperty(ds, "description");
1:1fd325f:         assertNull(JDBCDataSource.getBeanProperty(ds, "description"));    	
1:b343735:     }
1:b343735: 
1:b343735:     private static void setDatabaseProperty(String property, String value) 
1:b343735:     throws SQLException
1:b343735:     {
1:b343735:         DataSource ds = JDBCDataSource.getDataSource();
1:b343735:         Connection cadmin = ds.getConnection();
1:b343735:         CallableStatement cs = cadmin.prepareCall(
1:b343735:             "CALL SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(?, ?)");
1:b343735:         cs.setString(1, property);
1:b343735:         cs.setString(2, value);
5:b343735:         cs.execute();
1:b343735:         
1:b343735:         cs.close();
1:b343735:         cadmin.close();
1:b343735:     }
1:b343735:     
3:b343735:     private static void dsConnectionRequests(
1:b343735:         String[] expectedValues, DataSource ds) {
1:b343735: 
6:b343735:         // checks currently only implemented for embedded 
1:b343735:         if (usingEmbedded())
1:b343735:         {
1:b343735:             SecurityCheck.assertSourceSecurity(ds, "javax.sql.DataSource");
1:b343735:         }
1:b343735:         
1:b343735:         try {
1:b343735:             ds.getConnection();
3:b343735:             if (!expectedValues[0].equals("OK"))
5:b343735:                 fail (" expected connection to fail, but was OK");
1:b343735:         } catch (SQLException sqle) {
3:b343735:             assertSQLState(expectedValues[0], sqle);
1:b343735:         }
3:b343735:         dsConnectionRequest(expectedValues[1], ds, null, null);
3:b343735:         dsConnectionRequest(expectedValues[2], ds, "fred", null);
3:b343735:         dsConnectionRequest(expectedValues[3], ds, "fred", "wilma");
3:b343735:         dsConnectionRequest(expectedValues[4], ds, null, "wilma");
5:b343735:         dsConnectionRequest(
2:b343735:             expectedValues[5], ds, null, "databaseName=wombat");
1:b343735:         dsConnectionRequest(
2:b343735:             expectedValues[6], ds, "fred", "databaseName=wombat");
3:b343735:         dsConnectionRequest(expectedValues[7], 
2:b343735:             ds, "fred", "databaseName=wombat;password=wilma");
3:b343735:         dsConnectionRequest(expectedValues[8], 
2:b343735:             ds, "fred", "databaseName=wombat;password=betty");
1:b343735:     }
1:b343735: 
1:b343735:     private static void dsConnectionRequest(
1:b343735:         String expectedValue, DataSource ds, String user, String ConnAttr)
1:b343735:     {
1:b343735:         try {
1:b343735:             ds.getConnection(user, ConnAttr);
3:b343735:             if (!expectedValue.equals("OK"))
1:b343735:                 fail (" expected connection to fail, but was OK");
1:b343735:         } catch (SQLException sqle) {
3:b343735:             assertSQLState(expectedValue, sqle);
1:b343735:         }
1:b343735:     }
1:b343735:     
1:b343735:     private void assertConnectionOK(
1:b343735:         Object[] expectedValues, String dsName, Connection conn) 
9:b343735:     throws SQLException { 
1:b343735:         
17:b343735:         assertEquals(
1:b343735:             ((Integer)expectedValues[0]).intValue(), conn.getHoldability());
1:b343735: 
1:b343735:         // check it's a 3.0 connection object by checking if 
1:b343735:         // set & release Savepoint is ok.
1:b343735:         try {
1:b343735:             conn.releaseSavepoint(conn.setSavepoint());
1:b343735:             if (conn.getAutoCommit())
1:b343735:                 fail("expected a SQLExpection (savepoint with autocommit on");
1:b343735:             if (!((String)expectedValues[1]).equals("OK"))
1:b343735:                 fail("expected a SQLExpection (savepoint with autocommit on");
1:b343735:         } catch (SQLException sqle) {
1:b343735:             // we expect savepoints exceptions because either
1:b343735:             // it's a global transaction, or it's in auto commit mode.
1:b343735:             if (conn.getAutoCommit())
1:b343735:                 assertSQLState("XJ010", sqle);
1:b343735:             else if (((String)expectedValues[1]).equals("OK"))
1:b343735:                 fail ("unexpected JDBC 3.0 savepoint SQL Exception");
1:b343735:             else 
1:b343735:                 assertSQLState((String)expectedValues[1], sqle);
1:b343735:         }
1:b343735: 
1:b343735:         // Running connection checks
1:b343735:         // connection checks currently only implemented for Embedded
1:b343735:         if (usingEmbedded())
1:b343735:         {
1:b343735:             SecurityCheck.assertSourceSecurity(conn, "java.sql.Connection");
4:b343735:             SecurityCheck.assertSourceSecurity(
1:b343735:                 conn.getMetaData(), "java.sql.DatabaseMetaData");
1:b343735:         }
1:b343735: 
1:b343735:         assertEquals(((Integer)expectedValues[2]).intValue(), 
1:b343735:             conn.getTransactionIsolation());
1:b343735:         assertEquals(((Boolean)expectedValues[3]).booleanValue(), 
1:b343735:             conn.getAutoCommit());
1:b343735:         assertEquals(((Boolean)expectedValues[4]).booleanValue(), 
1:b343735:             conn.isReadOnly());
1:b343735: 
1:0f9b584:         // if this fixture runs without the default db being created,
1:0f9b584:         // there will not be a warning. Otherwise,  the warning will be,
1:0f9b584:         // cannot create db, connecting to existing db
1:0f9b584:         if (conn.getWarnings() != null)
1:0f9b584:             assertSQLState("01J01", conn.getWarnings());
1:b343735: 
1:b343735:         Statement s1 = conn.createStatement();
1:b343735:         assertStatementOK(dsName, conn, s1);
1:b343735:         assertStatementOK(dsName, conn, conn.createStatement
1:b343735:             (ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY));
1:b343735: 
1:b343735:         Connection c1 = conn.getMetaData().getConnection();
1:b343735:         // c1 and conn should be the same connection object.
1:b343735:         if (!usingDerbyNetClient() && dsName.indexOf("DataSource")>=0)
1:b343735:             assertEquals(c1, conn);
1:b343735: 
1:b343735:         assertConnectionPreClose(dsName, conn);
1:b343735:         conn.close();
1:b343735: 
1:b343735:         // method calls on a closed connection
1:b343735:         try {
1:b343735:             conn.close(); // expect no error
1:b343735:         } catch (SQLException sqle) {
1:b343735:             fail(" unexpected exception on <closedconn>.close() ");
1:b343735:         }
1:b343735:         try {
1:b343735:             conn.createStatement();
1:b343735:             fail (dsName + " <closedconn>.createStatement(), " +
1:b343735:                 "expected 08003 - No current connection");
1:b343735:         } catch (SQLException sqle) {
7:b343735:             assertSQLState("08003", sqle);
1:b343735:         }
1:b343735:         try {
1:b343735:             s1.execute("values 1");
1:b343735:             fail(dsName + " <closedstmt>.execute(), " +
1:b343735:                 "expected 08003 - No current connection");
1:b343735:         } catch (SQLException sqle) {
1:b343735:             assertSQLState("08003", sqle);
1:b343735:         }
1:b343735:     }
1:b343735: 
1:b343735:     private void assertConnectionPreClose(String dsName, Connection conn) 
1:b343735:     throws SQLException {
1:b343735: 
1:b343735:         // before closing the connection, attempt to change holdability
1:b343735:         // and readOnly
3:b343735:         conn.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);
1:b343735: 
1:b343735:         if (!dsName.equals("Nested2"))
1:b343735:         {
1:b343735:             try {
1:b343735:                 conn.setReadOnly(true);
1:b343735:             } catch (SQLException sqle) {
1:b343735:                 // cannot set read-only in an active transaction, & sometimes
1:b343735:                 // connections are active at this point.
1:b343735:                 assertSQLState("25501", sqle);
1:b343735:             }
1:b343735:         }
1:b343735:     }
1:b343735:     
1:b343735:     private void assertStatementOK(String dsName, Connection conn, Statement s)
1:b343735:     throws SQLException {
1:b343735: 
1:b343735:         // checks currently only implemented for embedded 
1:b343735:         if (usingEmbedded())
1:b343735:         {
1:b343735:             SecurityCheck.assertSourceSecurity(s, "java.sql.Statement");
1:b343735:         }
1:b343735: 
1:b343735:         Connection c1 = s.getConnection();
1:b343735:         if (c1 != conn)
1:b343735:         {
1:b343735:             // with DerbyNetClient and any kind of DataSource, this goes wrong
1:b343735:             if (!usingDerbyNetClient() && (dsName.indexOf("DataSource") >= 0))
1:b343735:                 fail ("incorrect connection object returned for Statement.getConnection()");
1:b343735:         }
1:b343735: 
1:b343735:         s.addBatch("insert into intTable values 1");
1:b343735:         s.addBatch("insert into intTable values 2,3");
1:b343735:         int[] states = s.executeBatch();
1:b343735:         if (states[0] != 1)
1:b343735:             fail ("invalid update count for first batch statement");
1:b343735:         if (states[1] != 2)
1:b343735:             fail ("invalid update count for second batch statement");
1:b343735: 
1:b343735:         ResultSet rs = s.executeQuery("VALUES 1");
1:b343735:         if (rs.getStatement() != s)
1:b343735:             fail ("incorrect Statement object returned for ResultSet.getStatement for " + dsName);
8:b343735:         rs.close();
7:b343735:         s.close();
1:b343735:     }
1:b343735: 
1:b343735:     /**
1:b343735:      * Make sure this connection's string is unique (DERBY-243)
1:b343735:      */
1:b343735:     private static void assertToString(Connection conn) throws Exception
1:b343735:     {
1:b343735:         assertStringFormat(conn);
2:b343735:         String str = conn.toString();
1:b343735: 
1:b343735:         if ( conns.containsKey(str))
1:b343735:         {
1:b343735:             throw new Exception("ERROR: Connection toString() is not unique: " 
1:b343735:                     + str);
1:b343735:         }
1:b343735:         conns.put(str, conn);
1:b343735:     }
1:b343735: 
1:b343735:     /**
1:b343735:      * Check the format of the connection string.  This is the default test
1:b343735:      * to run if this is not a BrokeredConnection class
1:b343735:      */
1:59c44b2:     private static void assertStringFormat(Connection conn) //throws Exception
1:b343735:     {
1:59c44b2:         assertStringPrefix(conn);
1:59c44b2:         String str = conn.toString(); 
1:0f9b584:         // matches is not a supported method with JSR169
1:0f9b584:         if (!JDBC.vmSupportsJSR169())
1:0f9b584:             assertTrue("\nexpected format:\n " + CONNSTRING_FORMAT + "\nactual value:\n " + str,
1:0f9b584:                     str.matches(CONNSTRING_FORMAT));
1:b343735:     }
1:b343735: 
1:b343735:     /**
1:b343735:      * Make sure the connection string starts with the right prefix, which
1:b343735:      * is the classname@hashcode.
1:b343735:      *
1:b343735:      * @return the expected prefix string, this is used in further string
1:b343735:      *   format checking
1:b343735:      */
1:59c44b2:     private static String assertStringPrefix(Object conn) //throws Exception
1:b343735:     {
1:b343735:         String connstr = conn.toString();
1:b343735:         String prefix = conn.getClass().getName() + "@" + conn.hashCode();
1:b343735:         // Connection class and has code for connection string should
1:b343735:         // match prefix
1:b343735:         assertTrue(connstr.startsWith(prefix));
1:b343735: 
1:b343735:         return prefix;
1:b343735:     }
1:b343735: 
1:b343735:     /**
1:b343735:      * Check uniqueness of connection strings coming from a
1:b343735:      * DataSouce
1:b343735:      */
1:b343735:     private static void assertToString(DataSource ds) throws Exception
1:b343735:     {
5:b343735:         clearConnections();
1:b343735: 
3:b343735:         int numConnections = 10;
3:b343735:         for ( int i = 0 ; i < numConnections ; i++ )
1:b343735:         {
1:b343735:             Connection conn = ds.getConnection();
3:b343735:             assertToString(conn);
1:b343735:         }
1:b343735: 
1:b343735:         clearConnections();
1:b343735:     }
1:b343735: 
1:b343735:     /**
1:b343735:      * Clear out and close connections in the connections
1:b343735:      * hashtable. 
1:b343735:      */
1:b343735:     private static void clearConnections() throws SQLException
1:b343735:     {
1:e18f54b:         for (Connection conn : conns.values()) {
1:b343735:             conn.close();
1:b343735:         }
1:b343735:         conns.clear();
1:b343735:     }
1:b343735: 
1:b343735:     /**
1:b343735:      * Get connections  using getConnection() and make sure
1:b343735:      * they're unique
1:b343735:      */
1:b343735:     private void assertTenConnectionsUnique() throws Exception
1:b343735:     {
1:b343735:         clearConnections();
1:b343735:         // Open ten connections rather than just two to
1:b343735:         // try and catch any odd uniqueness bugs.  Still
1:b343735:         // no guarantee but is better than just two.
1:b343735:         int numConnections = 10;
1:b343735:         for ( int i = 0 ; i < numConnections ; i++ )
1:b343735:         {
1:b343735:             Connection conn = openDefaultConnection();
1:b343735:             assertToString(conn);
1:b343735:         }
1:b343735: 
1:b343735:         // Now close the connections
1:b343735:         clearConnections();
1:7fe51c3:     }
1:0f9b584: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:4469400
/////////////////////////////////////////////////////////////////////////
1:         Class<?> clazz;
1: 
1:             clazz = Class.forName("org.apache.derby.jdbc.ClientDataSource");
1:             ds = (ClientDataSourceInterface)clazz.getConstructor().newInstance();
1:             clazz = Class.forName("org.apache.derby.jdbc.BasicClientDataSource40");
1:             ds = (ClientDataSourceInterface) clazz.getConstructor().newInstance();
/////////////////////////////////////////////////////////////////////////
1:         Class<?> clazz;
1:             clazz = Class.forName(dsName);
1:             ds = (javax.sql.DataSource) clazz.getConstructor().newInstance();
/////////////////////////////////////////////////////////////////////////
1:         Class<?> clazz;
1:             clazz = Class.forName("org.apache.derby.jdbc.ClientDataSource");
1:             ds = (ClientDataSourceInterface) clazz.getConstructor().newInstance();
1:             clazz = Class.forName("org.apache.derby.jdbc.BasicClientDataSource40");
1:             ds = (ClientDataSourceInterface)clazz.getConstructor().newInstance();
commit:39b3237
/////////////////////////////////////////////////////////////////////////
1:             ResultSet.HOLD_CURSORS_OVER_COMMIT, "XJ010",
1:             2, true, false};
commit:5570eb0
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     // ClientDataSource
/////////////////////////////////////////////////////////////////////////
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.BaseTestSuite;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite
1:             suite = new BaseTestSuite("ClientAndEmbedded" + postfix);
1: 
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite("Client/Server");
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite("Embedded" + postfix);
1:         BaseTestSuite suite = new BaseTestSuite("DataSourceTest suite");
commit:38667d9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.jdbc.BasicEmbeddedDataSource40;
/////////////////////////////////////////////////////////////////////////
1:             BasicEmbeddedDataSource40 nds = new BasicEmbeddedDataSource40();
1:                     expectedValues, "BasicDataSource", nds.getConnection());
/////////////////////////////////////////////////////////////////////////
0:                     "org.apache.derby.jdbc.BasicClientDataSource40").
/////////////////////////////////////////////////////////////////////////
0:               "org.apache.derby.jdbc.BasicClientDataSource40").newInstance();
commit:c35e4f0
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.jdbc.ClientDataSourceInterface;
/////////////////////////////////////////////////////////////////////////
1:     public void testClientDSConnectionAttributes() throws Exception {
1:         ClientDataSourceInterface ds = null;
1: 
1:         if (JDBC.vmSupportsJNDI()) {
1:             // Use reflection to avoid class not found in non-JNDI context
0:             ds = (ClientDataSourceInterface)Class.forName(
0:                     "org.apache.derby.jdbc.ClientDataSource").newInstance();
1:         } else {
0:             ds = (ClientDataSourceInterface)Class.forName(
0:                     "org.apache.derby.jdbc.NonJNDIClientDataSource40").
0:                     newInstance();
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1:     public void testClientMessageTextConnectionAttribute() throws Exception
/////////////////////////////////////////////////////////////////////////
1:         ClientDataSourceInterface ds = null;
1: 
1:         if (JDBC.vmSupportsJNDI()) {
1:             // Use reflection to avoid class not found in non-JNDI context
0:             ds = (ClientDataSourceInterface)Class.forName(
0:               "org.apache.derby.jdbc.ClientDataSource").newInstance();
1:         } else {
0:             ds = (ClientDataSourceInterface)Class.forName(
0:               "org.apache.derby.jdbc.NonJNDIClientDataSource40").newInstance();
1:         }
1: 
commit:4e0e1f1
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.jdbc.NonJNDIEmbeddedDataSource40;
/////////////////////////////////////////////////////////////////////////
1: 
1:         if (JDBC.vmSupportsJDBC4()) {
0:             NonJNDIEmbeddedDataSource40 nds = new NonJNDIEmbeddedDataSource40();
1:             nds.setDatabaseName(dbName);
1:             assertConnectionOK(
0:                     expectedValues, "NonJNDIDataSource", nds.getConnection());
1:         }
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:e18f54b
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.functionTests.util.PrivilegedFileOpsForTests;
/////////////////////////////////////////////////////////////////////////
1:     protected static Hashtable<String, Connection> conns =
1:             new Hashtable<String, Connection>();
/////////////////////////////////////////////////////////////////////////
1:         for (int i = 0; i < 6; i++) {
1:             String traceFileName = "trace" + (i + 1) + ".out";
1:             File traceFile = new File(traceFileName);
1:             if (PrivilegedFileOpsForTests.exists(traceFile)) {
1:                 // if it exists, attempt to get rid of it
1:                 PrivilegedFileOpsForTests.delete(traceFile);
1:         }
/////////////////////////////////////////////////////////////////////////
1:         for (int i = 0; i < 2; i++) {
1:             String traceFileName = "trace" + (i + 1) + ".out";
1:             File traceFile = new File(traceFileName);
1:             assertTrue(PrivilegedFileOpsForTests.exists(traceFile));
1:         }
/////////////////////////////////////////////////////////////////////////
1:         for (Connection conn : conns.values()) {
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:ad60cd5
/////////////////////////////////////////////////////////////////////////
1:         ds.setPortNumber(TestConfiguration.getCurrent().getPort());
1:         
/////////////////////////////////////////////////////////////////////////
1:         ds.setPortNumber(TestConfiguration.getCurrent().getPort());
commit:bff5312
/////////////////////////////////////////////////////////////////////////
0:         Statement s4 = conn4.createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY, ResultSet.CLOSE_CURSORS_AT_COMMIT);
/////////////////////////////////////////////////////////////////////////
0:             rs4.getInt(1);            
0:             fail ("expected an exception indicating resultset is closed.");
0:             // Embedded gets 08003. No current connection DERBY-2620        	
0:         	if (usingDerbyNetClient())
0:         		assertSQLState("XCL16",sqle);
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:9a82758
/////////////////////////////////////////////////////////////////////////
1:             assertSQLState("XJ028", e);
commit:7fe51c3
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: }
commit:9cf3fb5
/////////////////////////////////////////////////////////////////////////
0:         JDBCDataSource.setBeanProperty(dscs, "createDatabase", "false");
/////////////////////////////////////////////////////////////////////////
0:         JDBCDataSource.setBeanProperty(dsx, "createDatabase", "false");
1: 
/////////////////////////////////////////////////////////////////////////
0:             JDBCDataSource.setBeanProperty(ds, "createDatabase", "false");
/////////////////////////////////////////////////////////////////////////
0:         JDBCDataSource.setBeanProperty(ds, "createDatabase", "false");
commit:5b20343
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derbyTesting.junit.DatabasePropertyTestSetup;
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * Return a suite of tests that are run with a lower lock timeout.
1:      *
1:      * @param postfix suite name postfix
0:      * @return A suite of tests being run with a lower lock timeout.
1:      */
0:     private static Test getTimeoutSuite(String postfix) {
0:         TestSuite suite = new TestSuite("Lower lock timeout" + postfix);
0:         suite.addTest(new DataSourceTest("timeoutTestDerby1144PooledDS"));
0:         suite.addTest(new DataSourceTest("timeoutTestDerby1144XADS"));
0:         // Reduce the timeout threshold to make the tests run faster.
0:         return DatabasePropertyTestSetup.setLockTimeouts(suite, 3, 5);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:             TestSuite suite = new TestSuite("DataSourceTest suite");
0:             suite.addTest(TestConfiguration.defaultSuite(DataSourceTest.class));
0:             // Add the tests relying on getting timeouts.
0:             suite.addTest(getTimeoutSuite(":embedded"));
1:             suite.addTest(TestConfiguration.clientServerDecorator(
0:                     getTimeoutSuite(":client")));
1:             return suite;
/////////////////////////////////////////////////////////////////////////
0:     public void timeoutTestDerby1144PooledDS() throws SQLException {
/////////////////////////////////////////////////////////////////////////
0:     public void timeoutTestDerby1144XADS() throws SQLException {
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:f9f8329
/////////////////////////////////////////////////////////////////////////
1:         suite.addTest(new DataSourceTest("testJira95ds"));
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             assertSQLState("XCY00", sqle);
1:             fail ("unexpected exception: " + e.toString());
commit:0f9b584
/////////////////////////////////////////////////////////////////////////
0: import java.util.HashMap;
1: import org.apache.derbyTesting.junit.JDBCClient;
1:  * Test the various DataSource implementations of Derby, but not
1:  * ConnectionPoolDataSource or XADataSource; those are tested in
1:  * J2EEDataSourceTest.
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         // when DERBY-2498 gets fixed, move this one to baseSuite
0:         TestSuite suite = new TestSuite("DataSourceTest suite");
1:         // Add the tests that only run with embedded
1:         suite.addTest(getEmbeddedSuite("embedded"));
1:         // Add tests that will run with embedded
1:         suite.addTest(baseSuite(":embedded"));
1:         if (!JDBC.vmSupportsJSR169()) {
1:         // wrap all in CleanDatabaseTestSetup that creates all database
1:         // objects any fixture might need.
1:         // Note that not all fixtures need (all of) these.
1:         return new CleanDatabaseTestSetup(suite) {
1:             /**
1:              * Create and populate database objects
1:              * 
1:              * @see org.apache.derbyTesting.junit.CleanDatabaseTestSetup#decorateSQL(java.sql.Statement)
1:              */
1:             protected void decorateSQL(Statement s) throws SQLException {
1:                 s.executeUpdate("create table intTable(i int)");
1:             }
1:         };
/////////////////////////////////////////////////////////////////////////
1:     // the J2EEDataSourceTest version of this includes testing for
1:     // setTypeMap, which is supported for both EmbeddedDataSource and
0:     // ClientDataSource, but not for JSR169/EmbeddedSimpleDataSource
1:         //Connection dmc = getConnection();
0:             new Integer(2), new Boolean(true), new Boolean(false)};
/////////////////////////////////////////////////////////////////////////
1:     }            
/////////////////////////////////////////////////////////////////////////
1:     // this fixture has a counterpart for Pooled and XA DataSources in
1:     // J2EEDataSourceTest
/////////////////////////////////////////////////////////////////////////
1:      * this fixture has a counterpart for Pooled and XA DataSources in 
1:      * J2EEDataSourceTest
/////////////////////////////////////////////////////////////////////////
1:     // This fixture has a counterpart for Pooled and XA DataSources in
1:     // J2EEDataSourceTest. In that test, the corresponding fixture
1:     // also includes testing for setAttributesAsPassword.
1:     // Note that in this simple shape, there is no authentication done
1:     // but the fixture name is kept the same for reference to the J2EE one.
1:         // Create an empty datasource of the type befitting the jvm/client/server
1:         JDBCClient dsclient = getTestConfiguration().getJDBCClient();
1:         String dsName = dsclient.getDataSourceClassName();
1:         DataSource ds = null;
1:         try {
0:             ds = (javax.sql.DataSource) Class.forName(dsName).newInstance();
1:         } catch (Exception e) {
1:             fail("unable to complete test because unable to create new instance of datasource");
1:         }
/////////////////////////////////////////////////////////////////////////
1:         JDBCDataSource.setBeanProperty(ds, "connectionAttributes", "databaseName=" + dbName);
1:         JDBCDataSource.clearStringBeanProperty(ds, "connectionAttributes");
/////////////////////////////////////////////////////////////////////////
1:      * 
1:      * This fixture has a counterpart for Pooled and XA DataSources in
1:      * J2EEDataSourceTest
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                 for (int i=0 ; i < 2 ; i++)
0:                     if (i == 2)
/////////////////////////////////////////////////////////////////////////
1:      * 
1:      * This fixture has a counterpart for Pooled and XA DataSources in
1:      * J2EEDataSourceTest
1:      * 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:      * 
1:      * This fixture has a counterpart for Pooled and XA DataSources in
1:      * J2EEDataSourceTest
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         // if this fixture runs without the default db being created,
1:         // there will not be a warning. Otherwise,  the warning will be,
1:         // cannot create db, connecting to existing db
1:         if (conn.getWarnings() != null)
1:             assertSQLState("01J01", conn.getWarnings());
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         // matches is not a supported method with JSR169
1:         if (!JDBC.vmSupportsJSR169())
1:             assertTrue("\nexpected format:\n " + CONNSTRING_FORMAT + "\nactual value:\n " + str,
1:                     str.matches(CONNSTRING_FORMAT));
/////////////////////////////////////////////////////////////////////////
1: }
commit:decb600
/////////////////////////////////////////////////////////////////////////
0:         // move to baseSuite.
0:         // when DERBY-2498 gets fixed, move these two to baseSuite
0:         // when fixed, this can be moved to baseSuite.
0:         suite.addTest(new DataSourceTest("testXAHoldability"));
commit:0c7de0f
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Return a suite of tests that are run with both client and embedded
1:      * 
1:      * @param postfix suite name postfix
1:      * @return A suite of tests to be run with client and/or embedded
1:      */
1:     private static Test baseSuite(String postfix) {
0:         TestSuite suite = new TestSuite("ClientAndEmbedded" + postfix);
0:         suite.addTest(new DataSourceTest("testGlobalLocalInterleaf"));
0:         suite.addTest(new DataSourceTest("testSetIsolationWithStatement"));
0:         suite.addTest(new DataSourceTest("testJira95xads"));
1:         suite.addTest(new DataSourceTest("testBadConnectionAttributeSyntax"));
1:         suite.addTest(new DataSourceTest("testDescriptionProperty"));
0:         suite.addTest(new DataSourceTest("testConnectionErrorEvent"));
0:         suite.addTest(new DataSourceTest("testReadOnlyToWritableTran"));
0:         suite.addTest(new DataSourceTest("testAutoCommitOnXAResourceStart"));
1:         suite.addTest(new DataSourceTest("testAllDataSources"));
0:         suite.addTest(new DataSourceTest("testClosedCPDSConnection"));
0:         suite.addTest(new DataSourceTest("testClosedXADSConnection"));
0:         suite.addTest(new DataSourceTest("testSetSchemaInXAConnection"));
1:         return suite;
1:     }
1:     /**
1:      * Return a suite of tests that are run with client only
1:      * 
1:      * @return A suite of tests being run with client only
1:      */
1:     private static Test getClientSuite() {
0:         TestSuite suite = new TestSuite("Client/Server");
1:         suite.addTest(new DataSourceTest("testClientDSConnectionAttributes"));
1:         suite.addTest(new DataSourceTest(
1:                 "testClientTraceFileDSConnectionAttribute"));
1:         suite.addTest(new DataSourceTest(
1:                 "testClientMessageTextConnectionAttribute"));
1:         return suite;
1:     }
1:     
1:     /**
1:      * Return a suite of tests that are run with embedded only
1:      * 
1:      * @param postfix suite name postfix
1:      * @return A suite of tests being run with embedded only
1:      */
1:     private static Test getEmbeddedSuite(String postfix) {
0:         TestSuite suite = new TestSuite("Embedded" + postfix);
1:         suite.addTest(new DataSourceTest("testDSRequestAuthentication"));
0:         // Due to a bug following cannot be run for client - DERBY-3379
0:         // To run this fixture with client, add to getClientSuite(),
0:         // when DERBY-3379 is fixed, remove from here (and client) and
0:         // move to getRunTwiceSuite.
0:         suite.addTest(new DataSourceTest("testPooledReuseOnClose"));
0:         // when DERBY-2498 gets fixed, move these two to getRunTwiceSuite
0:         suite.addTest(new DataSourceTest("testJira95ds"));
0:         suite.addTest(new DataSourceTest("testJira95pds"));
0:         // Following cannot run with client because of DERBY-2533; it hangs
0:         // when fixed, this can be moved to getRunTwiceSuite.
0:         suite.addTest(new DataSourceTest("testReuseAcrossGlobalLocal"));
0:         // Following cannot run with client because of DERBY-2533; it hangs
0:         // when fixed, this can be moved to getRunTwiceSuite.
0:         suite.addTest(new DataSourceTest("testAutoCommitOnXAResourceStart"));
1:         return suite;
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
0:             // Add tests that will run with both embedded
0:             suite.addTest(baseSuite(":embedded"));
1:             //  and network server/client
1:             suite.addTest(TestConfiguration.clientServerDecorator(
1:                     baseSuite(":client")));
1:             // Add the tests that only run with client
1:             suite.addTest(TestConfiguration.clientServerDecorator(
1:                     getClientSuite()));
0:             // Add the tests that only run with embedded
0:             suite.addTest(getEmbeddedSuite("embedded"));
0:             // wrap all in CleanDatabaseTestSetup that creates all database
0:             // objects any fixture might need.
0:             // Note that not all fixtures need (all of) these.
0:             return new CleanDatabaseTestSetup(suite) {
1:                 /**
0:                  * Create and populate database objects
1:                  * 
0:                  * @see org.apache.derbyTesting.junit.CleanDatabaseTestSetup#decorateSQL(java.sql.Statement)
1:                  */
0:                 protected void decorateSQL(Statement s) throws SQLException {
0:                     s.executeUpdate("create table autocommitxastart(i int)");
0:                     s.executeUpdate("insert into autocommitxastart values 1,2,3,4,5");
0:                     s.executeUpdate("create schema SCHEMA_Patricio");
0:                     s.executeUpdate("create table " +
0:                     "SCHEMA_Patricio.Patricio (id VARCHAR(255), value INTEGER)");
0:                     s.executeUpdate("create table intTable(i int)");
0:                     s.executeUpdate("create table hold_30 " +
0:                     "(id int not null primary key, b char(30))");
0:                     s.executeUpdate(
0:                             "create procedure checkConn2(in dsname varchar(20)) " +
0:                             "parameter style java language java modifies SQL DATA " +
0:                             "external name " +
0:                             "'org.apache.derbyTesting.functionTests.tests.jdbcapi.DataSourceTest." +
0:                             getNestedMethodName() +
0:                     "'");
1:                 }
0:             };
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         // start by deleting all rows from intTable
0:         s.executeUpdate("delete from intTable");
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         // This fixture will run twice, once with embedded, once with client,
0:         // and insert 2 rows in addition to the 5 rows inserted during setup. 
0:         // The fixture tests a commit, so before running, try to remove row 
0:         // 6 and 7 in case this is the second run of the fixture.
0:         Statement s = createStatement();
0:         s.executeUpdate("delete from autocommitxastart where i = 6");
0:         s.executeUpdate("delete from autocommitxastart where i = 7");
1:         
/////////////////////////////////////////////////////////////////////////
1:         try {
1:             DataSource ds = JDBCDataSource.getDataSource();
1:             // non-existent database
1:             JDBCDataSource.setBeanProperty(ds, "databaseName", "jdbc:derby:wombat");
1:             ds.getConnection();
1:             fail ("expected an SQLException!");
1:         } catch (SQLException sqle) {
0:             // DERBY-2498: with client, getting a NullPointerException.
0:             // Note also: the NPE does not occur with XADataSource - see
0:             // testJira95xads().
1:             if (usingEmbedded())
0:                 assertSQLState("XCY00", sqle);
1:         } catch (Exception e) {
0:             // DERBY-2498, when fixed, remove 'if'
1:             if (usingEmbedded())
0:                 fail ("unexpected exception: " + e.toString());
1:         }
1:     } 
/////////////////////////////////////////////////////////////////////////
1:     // Following test is similar to testClientDSConnectionAttributes, but
0:     // This subtest does not run for network server, it uses
0:     // setAttributesAsPassword, which isn't supported for client datasources.
/////////////////////////////////////////////////////////////////////////
0:     private static String getNestedMethodName()
0:         return "checkNesConn";
commit:44305f7
/////////////////////////////////////////////////////////////////////////
0:         assertTrue("\nexpected format:\n " + CONNSTRING_FORMAT + "\nactual value:\n " + str,
0:             str.matches(CONNSTRING_FORMAT));
commit:73d44eb
/////////////////////////////////////////////////////////////////////////
1:         "\\S+@\\-?[0-9]+.* \\(XID = .*\\), \\(SESSIONID = [0-9]+\\), " +
commit:4621c99
/////////////////////////////////////////////////////////////////////////
0:             // Embedded gets 08003. No current connection (DERBY-2620)        	
commit:78f94f1
/////////////////////////////////////////////////////////////////////////
0:         xac4.getXAResource().start(xid4a, XAResource.TMNOFLAGS);
0:         xac4.getXAResource().end(xid4a, XAResource.TMSUCCESS);
1: 
/////////////////////////////////////////////////////////////////////////
0:         rs4.next();
0:         assertEquals(3, rs4.getInt(1));
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:59c44b2
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private static final String CONNSTRING_FORMAT = 
0:         "\\S+@[0-9]+.* \\(XID = .*\\), \\(SESSIONID = [0-9]+\\), " +
1:         "\\(DATABASE = [A-Za-z]+\\), \\(DRDAID = .*\\) "; 
1:     
/////////////////////////////////////////////////////////////////////////
0:         String format = prefix + " \\(ID = [0-9]+\\), Physical Connection = " +
0:             "<none>|" + CONNSTRING_FORMAT;
0:         assertTrue(connstr.matches(format));
1:     private static void assertStringFormat(Connection conn) //throws Exception
1:         assertStringPrefix(conn);
1:         String str = conn.toString(); 
0:         assertTrue(str.matches(CONNSTRING_FORMAT));
/////////////////////////////////////////////////////////////////////////
1:     private static String assertStringPrefix(Object conn) //throws Exception
commit:c005646
/////////////////////////////////////////////////////////////////////////
1:         super.tearDown();
/////////////////////////////////////////////////////////////////////////
1: }
commit:3adfe75
/////////////////////////////////////////////////////////////////////////
commit:48e4237
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         // DERBY-2531
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         // see DERBY-911, ReadOnly state different for Embedded/DerbyNetClient
/////////////////////////////////////////////////////////////////////////
0:         // DERBY-2533 -
0:         // on tearDown. Embedded requires a database shutdown
/////////////////////////////////////////////////////////////////////////
0:             // DERBY-2532
/////////////////////////////////////////////////////////////////////////
0:         // DERBY-2533 - 
/////////////////////////////////////////////////////////////////////////
0:         // DERBY-2531: network server / DerbyNetClient has a different value 
0:         // than embedded.
/////////////////////////////////////////////////////////////////////////
0:             // DERBY-2531
commit:b343735
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derbyTesting.functionTests.tests.jdbcapi.DataSourceTest
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.tests.jdbcapi;
1: 
1: import java.io.File;
0: import java.io.Serializable;
0: import java.security.AccessController;
1: import java.sql.CallableStatement;
1: import java.sql.Connection;
0: import java.sql.DriverManager;
0: import java.sql.ParameterMetaData;
0: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: import java.sql.Statement;
1: import java.util.Hashtable;
0: import java.util.Iterator;
1: 
0: import javax.sql.ConnectionEvent;
0: import javax.sql.ConnectionEventListener;
0: import javax.sql.ConnectionPoolDataSource;
1: import javax.sql.DataSource;
0: import javax.sql.PooledConnection;
0: import javax.sql.XAConnection;
0: import javax.sql.XADataSource;
0: import javax.transaction.xa.XAException;
0: import javax.transaction.xa.XAResource;
0: import javax.transaction.xa.Xid;
1: 
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: 
0: import org.apache.derby.jdbc.ClientConnectionPoolDataSource;
0: import org.apache.derby.jdbc.ClientDataSource;
0: import org.apache.derby.jdbc.ClientXADataSource;
0: import org.apache.derby.jdbc.EmbeddedConnectionPoolDataSource;
0: import org.apache.derby.jdbc.EmbeddedDataSource;
0: import org.apache.derby.jdbc.EmbeddedSimpleDataSource;
0: import org.apache.derby.jdbc.EmbeddedXADataSource;
1: import org.apache.derbyTesting.functionTests.util.SecurityCheck;
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
0: import org.apache.derbyTesting.junit.J2EEDataSource;
1: import org.apache.derbyTesting.junit.JDBC;
1: import org.apache.derbyTesting.junit.JDBCDataSource;
1: import org.apache.derbyTesting.junit.TestConfiguration;
0: //import org.apache.oro.text.perl.Perl5Util;
1: 
1: /**
0:  * Test the various embedded DataSource implementations of Derby.
1:  * 
1:  * Performs SecurityCheck analysis on the JDBC objects returned.
1:  * This is because this test returns to the client a number of
1:  * different implementations of Connection, Statement etc.
1:  * 
1:  * @see org.apache.derbyTesting.functionTests.util.SecurityCheck
1:  *
1:  */
1: public class DataSourceTest extends BaseJDBCTestCase {
1: 
0:     protected static String dbName = 
1:         TestConfiguration.getCurrent().getDefaultDatabaseName();
1:     
1:     /**
1:      * A hashtable of opened connections.  This is used when checking to
1:      * make sure connection strings are unique; we need to make sure all
1:      * the connections are closed when we are done, so they are stored
1:      * in this hashtable
1:      */
0:     protected static Hashtable conns = new Hashtable();
1:     
1:     /**
0:      * This is a utility that knows how to do pattern matching.  Used
0:      * in checking the format of a connection string
1:      */
0: //    protected static Perl5Util p5u = new Perl5Util();
1:     
1:     /** The expected format of a connection string. In English:
1:      * "<classname>@<hashcode> (XID=<xid>), (SESSION = <sessionid>),
1:      *  (DATABASE=<dbname>), (DRDAID = <drdaid>)"
1:      */
0:     private static final String CONNSTRING_FORMAT = "\\S+@[0-9]+ " +
0:         "\\(XID = .*\\), \\(SESSIONID = [0-9]+\\), " +
0:         "\\(DATABASE = [A-Za-z]+\\), \\(DRDAID = .+\\)";
1:     
1:     /**
1:      * Hang onto the SecurityCheck class while running the
1:      * tests so that it is not garbage collected during the
1:      * test and lose the information it has collected,
1:      * in case it should get printed out.
1:      */
1:     private final Object nogc = SecurityCheck.class;
1:     
1:     public DataSourceTest(String name) {
1:         super(name);
1:     }
1:     
1:     public static Test suite() {
0:         // TODO: remove tearDown?
0:         if (JDBC.vmSupportsJSR169())
1:         {
0:             // test uses unsupported classes like DriverManager, XADataSource,
0:             // ConnectionPoolDataSource, ConnectionEvenListenere, as well as
0:             // unsupported methods, like Connection.setTypeMap()...
0:             TestSuite suite = 
0:                 new TestSuite("DatasourceTest cannot run with JSR169");
0:             return suite;
1:         }
1:         else
1:         {
0:             return TestConfiguration.defaultSuite(DataSourceTest.class);
1:         }
1:     }
1:     
1:     /**
0:      * Set up the conection to the database.
1:      */
0:     public void setUp() throws  Exception {
0:         Statement s = createStatement();
0:         s.executeUpdate("create table autocommitxastart(i int)");
0:         s.executeUpdate("insert into autocommitxastart values 1,2,3,4,5");
0:         s.executeUpdate("create schema SCHEMA_Patricio");
0:         s.executeUpdate("create table " +
0:             "SCHEMA_Patricio.Patricio (id VARCHAR(255), value INTEGER)");
0:         s.executeUpdate("create table intTable(i int)");
0:         s.executeUpdate("create table hold_30 " +
0:             "(id int not null primary key, b char(30))");
0:         s.executeUpdate(
0:             "create procedure checkConn2(in dsname varchar(20)) " +
0:             "parameter style java language java modifies SQL DATA " +
0:             "external name " +
0:             "'org.apache.derbyTesting.functionTests.tests.jdbcapi." +
0:             this.getNestedMethodName() +
0:             "'");
1: 
0:         // theoretically, commit should be unnecessary, because 
0:         // autocommit should be true by default.
0:         commit();
1:         s.close();
1:     }
1:     
1:     public void tearDown() throws Exception {
0:         getConnection().setAutoCommit(false);
0:         Statement s = createStatement();
0:         s.executeUpdate("drop table autocommitxastart");
0:         s.executeUpdate("drop table intTable");
0:         s.executeUpdate("drop table hold_30");
0:         s.executeUpdate("drop table SCHEMA_Patricio.Patricio");
0:         s.executeUpdate("drop schema SCHEMA_Patricio restrict");
0:         s.executeUpdate("drop procedure checkConn2");
0:         // should be automatic?        
0:         commit();
1:         s.close();
1: 
1:         // attempt to get rid of any left-over trace files
0:         AccessController.doPrivileged(new java.security.PrivilegedAction() {
0:             public Object run() {
0:                 for (int i=0 ; i < 6 ; i++)
1:                 {   
0:                     String traceFileName = "trace" + (i+1) + ".out";
0:                     File traceFile = new File(traceFileName);
0:                     if (traceFile.exists())
1:                     {
0:                         // if it exists, attempt to get rid of it
0:                         traceFile.delete();
1:                     }
1:                 } 
0:                 return null;
1:             }
0:         });
1:     }
1: 
0:     /* comment out. leaving in, just in case it's ever relevant.
0:      * when uncommented, this will run when network server tests are
0:      * started, and then reflect the results of the embedded checks.
0:     // perform security analysis of the public api for the embedded engine
0:     public void testDataSourceAPI() throws SQLException, ClassNotFoundException
1:     {
0:         SecurityCheck.report();
1:     }
1:      */
1:     
1:     public void testAllDataSources() throws SQLException, Exception
1:     {
0:         Connection dmc = getConnection();
0:         CallableStatement cs = dmc.prepareCall("call checkConn2(?)");
0:         cs.setString(1,"Nested");
1:         try {
1:             cs.execute();
1:         } catch (SQLException sqle) {
0:             assertSQLState("40XC0", sqle);
1:         }
0:         cs.setString(1,"Nested2");
1:         cs.execute();
1:         
0:         String EmptyMapValue=null;
0:         // Note: currently, not supported
0:         String NullMapValue=null;
0:         String MapMapValue=null;
1:         if (usingEmbedded())
1:         {
0:             EmptyMapValue="OK"; NullMapValue="XJ081"; MapMapValue="0A000";
1:         }
0:         else if (usingDerbyNetClient())
1:         {
0:             EmptyMapValue="0A000"; NullMapValue="0A000"; MapMapValue="0A000";
1:         }
1:         Object[] expectedValues = {
0:             new Integer(ResultSet.HOLD_CURSORS_OVER_COMMIT), "XJ010",
0:             new Integer(2), new Boolean(true), new Boolean(false), 
0:             EmptyMapValue, NullMapValue, MapMapValue};
1: 
0:         assertConnectionOK(expectedValues, "DriverManager ", dmc);
1:     
1:         if (usingEmbedded())
1:             assertTenConnectionsUnique();
1: 
0:         DataSource dscs = JDBCDataSource.getDataSource(dbName);
1:         if (usingEmbedded()) 
1:                 assertToString(dscs);
1: 
1:         DataSource ds = dscs;
1:         assertConnectionOK(expectedValues, "DataSource", ds.getConnection());
1:         
0:         DataSource dssimple = null;
0:         // simple datasource is only supported with embedded
1:         if (usingEmbedded())
1:         {
0:             EmbeddedSimpleDataSource realdssimple = 
0:                 new EmbeddedSimpleDataSource();
0:             realdssimple.setDatabaseName(dbName);
0:             ds = realdssimple;
0:             dssimple = (DataSource)realdssimple;
0:             assertConnectionOK(
0:                 expectedValues, "SimpleDataSource", ds.getConnection());
1:         }
1:             
0:         ConnectionPoolDataSource dsp = 
0:             J2EEDataSource.getConnectionPoolDataSource();
0:         JDBCDataSource.setBeanProperty(dsp, "DatabaseName", dbName);        
1:         
1:         if (usingEmbedded()) 
0:             assertToString(dsp);
1: 
0:         PooledConnection pc = dsp.getPooledConnection();
1:         // checks currently only implemented for embedded 
1:         if (usingEmbedded())
1:         {
1:             SecurityCheck.assertSourceSecurity(
0:                 pc, "javax.sql.PooledConnection");
1:         }
0:         pc.addConnectionEventListener(new AssertEventCatcher(1));
1: 
0:         // TODO: log bug / check if one exists
0:         // with Network Server / DerbyNetClient, the assertConnectionOK check
0:         // returns a different connection object...
0:         assertConnectionOK(
0:             expectedValues, "ConnectionPoolDataSource", pc.getConnection());
0:         assertConnectionOK(
0:             expectedValues, "ConnectionPoolDataSource", pc.getConnection());
1: 
0:         XADataSource dsx = J2EEDataSource.getXADataSource();
0:         JDBCDataSource.setBeanProperty(dsx, "DatabaseName", dbName);
1:         if (usingEmbedded())
0:             assertToString(dsx);
1: 
0:         // shutdown db and check all's still ok thereafter
1:         TestConfiguration.getCurrent().shutdownDatabase();
1: 
0:         dmc = getConnection();
0:         cs = dmc.prepareCall("call checkConn2(?)");
1:         // checks currently only implemented for embedded 
1:         if (usingEmbedded())
1:         {
1:             SecurityCheck.assertSourceSecurity(
0:                 cs, "java.sql.CallableStatement");
1:         }
0:         cs.setString(1,"Nested");
1:         try {
1:             cs.execute();
1:         } catch (SQLException sqle) {
0:             assertSQLState("40XC0", sqle);
1:         }
0:         cs.setString(1, "Nested2");
1:         cs.execute();
1: 
0:         XAConnection xac = dsx.getXAConnection();
1:         // checks currently only implemented for embedded 
1:         if (usingEmbedded())
1:         {
0:             SecurityCheck.assertSourceSecurity(xac, "javax.sql.XAConnection");
1:         }
0:         xac.addConnectionEventListener(new AssertEventCatcher(3));
0:         assertConnectionOK(
0:             expectedValues, "XADataSource", xac.getConnection());
1: 
0:         pc = dsp.getPooledConnection();
0:         pc.addConnectionEventListener(new AssertEventCatcher(2));
0:         assertConnectionOK(
0:             expectedValues, "ConnectionPoolDataSource", pc.getConnection());
1: 
0:         // test "local" XAConnections
0:         xac = dsx.getXAConnection();
0:         xac.addConnectionEventListener(new AssertEventCatcher(4));
0:         assertConnectionOK(
0:             expectedValues, "XADataSource", xac.getConnection());
0:         assertConnectionOK(
0:             expectedValues, "XADataSource", xac.getConnection());
0:         xac.close();
1: 
0:         // test "global" XAConnections
0:         xac = dsx.getXAConnection();
0:         xac.addConnectionEventListener(new AssertEventCatcher(5));
0:         XAResource xar = xac.getXAResource();
1:         // checks currently only implemented for embedded 
1:         if (usingEmbedded())
1:         {
1:            SecurityCheck.assertSourceSecurity(
0:                 xar, "javax.transaction.xa.XAResource");
1:         }
0:         Xid xid = new cdsXid(1, (byte) 35, (byte) 47);
0:         xar.start(xid, XAResource.TMNOFLAGS);
0:         Connection xacc = xac.getConnection();
0:         xacc.close();
0:         expectedValues[0] = new Integer(ResultSet.CLOSE_CURSORS_AT_COMMIT);
1:         if (usingEmbedded())
0:             expectedValues[1] = "XJ058";
0:         expectedValues[3] = new Boolean(false);
0:         assertConnectionOK(
0:             expectedValues, "Global XADataSource", xac.getConnection());
0:         assertConnectionOK(
0:             expectedValues, "Global XADataSource", xac.getConnection());
1: 
0:         xar.end(xid, XAResource.TMSUCCESS);
1: 
0:         expectedValues[0] = new Integer(ResultSet.HOLD_CURSORS_OVER_COMMIT);
0:         expectedValues[3] = new Boolean(true);
0:         assertConnectionOK(expectedValues, 
0:             "Switch to local XADataSource", xac.getConnection());
0:         assertConnectionOK(expectedValues, 
0:             "Switch to local XADataSource", xac.getConnection());
1: 
0:         Connection backtoGlobal = xac.getConnection();
1: 
0:         xar.start(xid, XAResource.TMJOIN);
0:         expectedValues[0] = new Integer(ResultSet.CLOSE_CURSORS_AT_COMMIT);
0:         expectedValues[3] = new Boolean(false);
0:         assertConnectionOK(expectedValues, 
0:             "Switch to global XADataSource", backtoGlobal);
0:         assertConnectionOK(expectedValues, 
0:             "Switch to global XADataSource", xac.getConnection());
0:         xar.end(xid, XAResource.TMSUCCESS);
0:         xar.commit(xid, true);
1: 
0:         xac.close();
1:     }
1:     
0:     public void testClosedCPDSConnection() throws SQLException, Exception {
0:         // verify that outstanding updates from a closed connection, obtained
0:         // from a ConnectionPoolDataSource, are not committed, but rolled back.
0:         ConnectionPoolDataSource dsp = 
0:             J2EEDataSource.getConnectionPoolDataSource();
0:         JDBCDataSource.setBeanProperty(dsp, "DatabaseName", dbName);        
0:         PooledConnection pc = dsp.getPooledConnection();
0:         Connection c1 = pc.getConnection();
0:         Statement s = c1.createStatement();
0:         c1.setAutoCommit(false);
1: 
0:         // this update should get rolled back later
0:         s.executeUpdate("insert into intTable values(1)");
0:         // this should automatically close the original connection
0:         c1 = pc.getConnection();
1: 
0:         ResultSet rs = 
0:             c1.createStatement().executeQuery("select count(*) from intTable");
0:         rs.next();
0:         assertEquals(0, rs.getInt(1));
0:         c1.close();
1:         
0:         // check connection objects are closed once connection is closed
1:         try {
0:             rs.next();
0:             fail("ResultSet is open for a closed connection obtained from PooledConnection");
1:         } catch (SQLException sqle) {
0:             // 08003 - No current connection; XCL16 - ResultSet not open
1:             if (usingEmbedded())
1:                 assertSQLState("08003", sqle);
0:             else if (usingDerbyNetClient())
0:                 assertSQLState("XCL16", sqle);
1:         }
1: 
1:         try {
0:             s.executeUpdate("update intTable set i = 1");
0:             fail("Statement is open for a closed connection " +
0:                 "obtained from PooledConnection");
1:         } catch (SQLException sqle) {
1:             assertSQLState("08003", sqle);
1:         }
1: 
0:         pc.close();
0:         pc = null;
0:         PoolReset("ConnectionPoolDataSource", dsp.getPooledConnection());
1:         s.close();
1:         rs.close();
0:         c1.close();
1:     }
1: 
0:     public void testClosedXADSConnection() throws SQLException, Exception {
0:         // verify that outstanding updates from a closed connection, obtained
0:         // from an XADataSource, are not committed, but rolled back.
0:         XADataSource dsx = J2EEDataSource.getXADataSource();
0:         JDBCDataSource.setBeanProperty(dsx, "DatabaseName", dbName);
0:         XAConnection xac = dsx.getXAConnection();
0:         Connection c1 = xac.getConnection();
0:         Statement s = c1.createStatement();
1: 
0:         c1.setAutoCommit(false);
1: 
0:         // this update should be rolled back
0:         s.executeUpdate("insert into intTable values(2)");
1:         
0:         c1 = xac.getConnection();
1: 
0:         ResultSet rs = c1.createStatement().executeQuery(
0:            "select count(*) from intTable");
0:         rs.next();
1: 
0:         assertEquals(0, rs.getInt(1));
1: 
1:         rs.close();
0:         c1.close();
0:         xac.close();
0:         xac = null;
1: 
0:         PoolReset("XADataSource", dsx.getXAConnection());
1:     }
1: 
0:     public void testGlobalLocalInterleaf() throws SQLException, XAException {    
0:         // now some explicit tests for how connection state behaves
0:         // when switching between global transactions and local
0:         // and setting connection state.
0:         // some of this may be tested elsewhere too.
0:         // TODO: there is a difference in ReadOnly state between
0:         // DerbyNetClient and embedded...Is this a bug?
1: 
0:         XADataSource dsx = J2EEDataSource.getXADataSource();
0:         JDBCDataSource.setBeanProperty(dsx, "DatabaseName", dbName);
0:         XAConnection xac = dsx.getXAConnection();
0:         xac.addConnectionEventListener(new AssertEventCatcher(6));
0:         XAResource xar = xac.getXAResource();
0:         Xid xid = new cdsXid(1, (byte) 93, (byte) 103);
1: 
0:         // series 1 - Single connection object
0:         Connection cs1 = xac.getConnection();
0:         // initial local
0:         assertConnectionState(
0:             ResultSet.HOLD_CURSORS_OVER_COMMIT, 
0:             Connection.TRANSACTION_READ_COMMITTED,
0:             true, false, cs1);
0:         xar.start(xid, XAResource.TMNOFLAGS);
0:         // initial X1
0:         assertConnectionState(
0:             ResultSet.CLOSE_CURSORS_AT_COMMIT, 
0:             Connection.TRANSACTION_READ_COMMITTED,
0:             false, false, cs1);
0:         cs1.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);
0:         cs1.setReadOnly(true);
0:         setHoldability(cs1, false); // close cursors
0:         // modified X1
0:         boolean ReadOnly = false;
1:         if (usingEmbedded())
0:             ReadOnly = true;
0:         assertConnectionState(
0:             ResultSet.CLOSE_CURSORS_AT_COMMIT, 
0:             Connection.TRANSACTION_READ_UNCOMMITTED,
0:             false, ReadOnly, cs1);
0:         xar.end(xid, XAResource.TMSUCCESS);
0:         // the underlying local transaction/connection must pick up the
0:         // state of the Connection handle cs1
0:         // modified local:
0:         assertConnectionState(
0:             ResultSet.CLOSE_CURSORS_AT_COMMIT, 
0:             Connection.TRANSACTION_READ_UNCOMMITTED,
0:             true, ReadOnly, cs1);
1:         
0:         cs1.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
0:         cs1.setReadOnly(false);
0:         setHoldability(cs1, false); // close cursors
1: 
0:         // reset local
0:         assertConnectionState(
0:             ResultSet.CLOSE_CURSORS_AT_COMMIT, 
0:             Connection.TRANSACTION_READ_COMMITTED,
0:             true, false, cs1);
1: 
0:         // now re-join the transaction, should pick up the read-only
0:         // and isolation level from the transaction,
0:         // holdability remains that of this handle.
0:         xar.start(xid, XAResource.TMJOIN);
0:         // re-join X1
0:         assertConnectionState(
0:             ResultSet.CLOSE_CURSORS_AT_COMMIT, 
0:             Connection.TRANSACTION_READ_UNCOMMITTED,
0:             false, ReadOnly, cs1);
0:         xar.end(xid, XAResource.TMSUCCESS);
1: 
0:         // back to local - should be the same as the reset local
0:         assertConnectionState(
0:             ResultSet.CLOSE_CURSORS_AT_COMMIT, 
0:             Connection.TRANSACTION_READ_COMMITTED,
0:             true, false, cs1);
1:         
0:         // test suspend/resume
0:         // now re-join the transaction (X1) for the second time, should pick
0:         // up the read-only and isolation level from the transaction,
0:         // holdability remains that of this handle.
0:         xar.start(xid, XAResource.TMJOIN);
0:         assertConnectionState(
0:             ResultSet.CLOSE_CURSORS_AT_COMMIT, 
0:             Connection.TRANSACTION_READ_UNCOMMITTED,
0:             false, ReadOnly, cs1);
1:         
0:         xar.end(xid, XAResource.TMSUSPEND);
0:         // local after suspend
0:         assertConnectionState(
0:             ResultSet.CLOSE_CURSORS_AT_COMMIT, 
0:             Connection.TRANSACTION_READ_COMMITTED,
0:             true, false, cs1);
1:         
0:         xar.start(xid, XAResource.TMRESUME);
0:         // resume X1
0:         assertConnectionState(
0:             ResultSet.CLOSE_CURSORS_AT_COMMIT, 
0:             Connection.TRANSACTION_READ_UNCOMMITTED,
0:             false, ReadOnly, cs1);
1:         
0:         xar.end(xid, XAResource.TMSUCCESS);
0:         // back to local (second time)
0:         assertConnectionState(
0:             ResultSet.CLOSE_CURSORS_AT_COMMIT, 
0:             Connection.TRANSACTION_READ_COMMITTED,
0:             true, false, cs1);
1:         
0:         cs1.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);
0:         cs1.setReadOnly(true);
0:         setHoldability(cs1, true); // hold
0:         cs1.close();
1:         
0:         cs1 = xac.getConnection();
0:         // new handle - local
0:         assertConnectionState(
0:             ResultSet.HOLD_CURSORS_OVER_COMMIT, 
0:             Connection.TRANSACTION_READ_COMMITTED,
0:             true, false, cs1);
0:         cs1.close();
1:         
0:         xar.start(xid, XAResource.TMJOIN);
0:         cs1 = xac.getConnection();
0:         // re-join with new handle X1
0:         assertConnectionState(
0:             ResultSet.CLOSE_CURSORS_AT_COMMIT, 
0:             Connection.TRANSACTION_READ_UNCOMMITTED,
0:             false, ReadOnly, cs1);
0:         cs1.close();
0:         xar.end(xid, XAResource.TMSUCCESS);
1: 
0:         // now get a connection (attached to a local)
0:         // attach to the global and commit it.
0:         // state should be that of the local after the commit.
0:         cs1 = xac.getConnection();
0:         cs1.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);
0:         // pre-X1 commit - local
0:         assertConnectionState(
0:             ResultSet.HOLD_CURSORS_OVER_COMMIT, 
0:             Connection.TRANSACTION_REPEATABLE_READ,
0:             true, false, cs1);
0:         xar.start(xid, XAResource.TMJOIN);
0:         // pre-X1 commit - X1
0:         assertConnectionState(
0:             ResultSet.CLOSE_CURSORS_AT_COMMIT, 
0:             Connection.TRANSACTION_READ_UNCOMMITTED,
0:             false, ReadOnly, cs1);
0:         xar.end(xid, XAResource.TMSUCCESS);
0:         // post-X1 end - local
0:         assertConnectionState(
0:             ResultSet.HOLD_CURSORS_OVER_COMMIT, 
0:             Connection.TRANSACTION_REPEATABLE_READ,
0:             true, false, cs1);
0:         xar.commit(xid, true);
0:         // post-X1 commit - local
0:         assertConnectionState(
0:             ResultSet.HOLD_CURSORS_OVER_COMMIT, 
0:             Connection.TRANSACTION_REPEATABLE_READ,
0:             true, false, cs1);
0:         cs1.close();
1:     }
1:     
0:     // really part of testGlobalLocalInterLeaf:
1:     /**
1:      * @throws SQLException
0:      * @throws XAException
1:      */
0:     public void testSetIsolationWithStatement() 
0:     throws SQLException, XAException {
0:         // DERBY-421 Setting isolation level with SQL was not getting 
0:         // handled correctly 
0:         // Some more isolation testing using SQL and JDBC api
0:         XADataSource dsx = J2EEDataSource.getXADataSource();
0:         JDBCDataSource.setBeanProperty(dsx, "DatabaseName", dbName);
0:         XAConnection xac = dsx.getXAConnection();
0:         xac.addConnectionEventListener(new AssertEventCatcher(6));
0:         XAResource xar = xac.getXAResource();
0:         Connection conn = xac.getConnection();
0:         Statement s = conn.createStatement();
0:         // initial local
0:         assertConnectionState(
0:             ResultSet.HOLD_CURSORS_OVER_COMMIT, 
0:             Connection.TRANSACTION_READ_COMMITTED,
0:             true, false, conn);
1: 
0:         // Issue setTransactionIsolation in local transaction
0:         conn.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);
0:         // setTransactionIsolation in local
0:         assertConnectionState(
0:             ResultSet.HOLD_CURSORS_OVER_COMMIT, 
0:             Connection.TRANSACTION_READ_UNCOMMITTED,
0:             true, false, conn);
1: 
0:         Xid xid;
0:         //Issue SQL to change isolation in local transaction
0:         s.executeUpdate("set current isolation = RR");
0:         assertConnectionState(ResultSet.HOLD_CURSORS_OVER_COMMIT, 
0:             Connection.TRANSACTION_SERIALIZABLE,
0:             true, false, conn);
1: 
0:         xid = new cdsXid(1, (byte) 35, (byte) 47);
0:         xar.start(xid, XAResource.TMNOFLAGS);
0:         // 1st global (new)
0:         assertConnectionState(ResultSet.CLOSE_CURSORS_AT_COMMIT,
0:             Connection.TRANSACTION_SERIALIZABLE,
0:             false, false, conn);
0:         xar.end(xid, XAResource.TMSUCCESS);
1: 
0:         // local
0:         assertConnectionState(ResultSet.HOLD_CURSORS_OVER_COMMIT,
0:             Connection.TRANSACTION_SERIALIZABLE,
0:             true, false, conn);
0:         //Issue SQL to change isolation in local transaction
0:         s.executeUpdate("set current isolation = RS");
0:         assertConnectionState(ResultSet.HOLD_CURSORS_OVER_COMMIT, 
0:             Connection.TRANSACTION_REPEATABLE_READ,
0:             true, false, conn);
1: 
0:         // DERBY-1325 - Isolation level of local connection does not get reset after ending 
0:         // a global transaction that was joined/resumed if the isolation level was changed 
0:         // using SQL 
0:         xar.start(xid, XAResource.TMJOIN);
0:         // 1st global(existing)
0:         assertConnectionState(ResultSet.CLOSE_CURSORS_AT_COMMIT, 
0:             Connection.TRANSACTION_SERIALIZABLE,
0:             false, false, conn);
0:         xar.end(xid, XAResource.TMSUCCESS);
0:         // local
0:         assertConnectionState(ResultSet.HOLD_CURSORS_OVER_COMMIT, 
0:             Connection.TRANSACTION_REPEATABLE_READ,
0:             true, false, conn);
0:         // DERBY-1325 end test 
1: 
0:         Xid xid2 = new cdsXid(1, (byte) 93, (byte) 103);
0:         xar.start(xid2, XAResource.TMNOFLAGS);
0:         // 2nd global (new)
0:         assertConnectionState(ResultSet.CLOSE_CURSORS_AT_COMMIT, 
0:             Connection.TRANSACTION_REPEATABLE_READ,
0:             false, false, conn);
0:         xar.end(xid2, XAResource.TMSUCCESS);
1: 
0:         xar.start(xid, XAResource.TMJOIN);
0:         // 1st global (existing)
0:         assertConnectionState(ResultSet.CLOSE_CURSORS_AT_COMMIT, 
0:             Connection.TRANSACTION_SERIALIZABLE,
0:             false, false, conn);
0:         xar.end(xid, XAResource.TMSUCCESS);
1: 
0:         //local 
0:         assertConnectionState(ResultSet.HOLD_CURSORS_OVER_COMMIT, 
0:             Connection.TRANSACTION_REPEATABLE_READ,
0:             true, false, conn);
1: 
0:         xar.start(xid, XAResource.TMJOIN);
1:         
0:         // 1st global (existing)
0:         assertConnectionState(ResultSet.CLOSE_CURSORS_AT_COMMIT, 
0:             Connection.TRANSACTION_SERIALIZABLE,
0:             false, false, conn);
0:         // Issue SQL to change isolation in 1st global transaction
0:         s.executeUpdate("set current isolation = UR");
0:         assertConnectionState(ResultSet.CLOSE_CURSORS_AT_COMMIT, 
0:             Connection.TRANSACTION_READ_UNCOMMITTED,
0:             false, false, conn);
0:         xar.end(xid, XAResource.TMSUCCESS);
1: 
0:         // local
0:         assertConnectionState(ResultSet.HOLD_CURSORS_OVER_COMMIT, 
0:             Connection.TRANSACTION_READ_UNCOMMITTED,
0:             true, false, conn);
1: 
0:         xar.start(xid2, XAResource.TMJOIN);
0:         // 2nd global (existing)
0:         assertConnectionState(ResultSet.CLOSE_CURSORS_AT_COMMIT, 
0:             Connection.TRANSACTION_REPEATABLE_READ,
0:             false, false, conn);
0:         xar.end(xid2, XAResource.TMSUCCESS);
0:         xar.rollback(xid2);
0:         // (After 2nd global rollback ) local
0:         assertConnectionState(ResultSet.HOLD_CURSORS_OVER_COMMIT, 
0:             Connection.TRANSACTION_READ_UNCOMMITTED,
0:             true, false, conn);
1: 
0:         xar.rollback(xid);
0:         // (After 1st global rollback) local
0:         assertConnectionState(ResultSet.HOLD_CURSORS_OVER_COMMIT, 
0:             Connection.TRANSACTION_READ_UNCOMMITTED,
0:             true, false, conn);
1:     }
1: 
0:     // This test includes some short-hand descriptions of the test cases
0:     // left in for reference to the original non-junit test
0:     public void testReuseAcrossGlobalLocal() throws SQLException, XAException {
1: 
0:         // TODO: analyze & log a bug if needed:
0:         // network server cannot run this test - it hits a protocol error
0:         // on tearDown.
0:         if (usingDerbyNetClient())
1:             return;
1:         
0:         int[] onetwothree = {1,2,3};
0:         int[] three = {3};
0:         int[] pspc = {1, 4}; // expected parameter count for prepared statements
0:         int[] cspc = {2, 12, 12}; // for callable statements
1:         
0:         // statics for testReuseAcrossGlobalLocal
0:         int[] StatementExpectedValues = {
0:             ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY,
0:             ResultSet.FETCH_REVERSE, 444, 713, 19, 
0:             ResultSet.HOLD_CURSORS_OVER_COMMIT};
0:             //ResultSet.CLOSE_CURSORS_AT_COMMIT};
0:         int[] PreparedStatementExpectedValues = { 
0:             ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY,
0:             ResultSet.FETCH_REVERSE, 888, 317, 91,
0:             ResultSet.HOLD_CURSORS_OVER_COMMIT};
0:         int[] CallableStatementExpectedValues = { 
0:             ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY,
0:             ResultSet.FETCH_REVERSE, 999, 137, 85,
0:             ResultSet.HOLD_CURSORS_OVER_COMMIT};
1: 
0:         XADataSource dsx = J2EEDataSource.getXADataSource();
0:         JDBCDataSource.setBeanProperty(dsx, "DatabaseName", dbName);
0:         XAConnection xac = dsx.getXAConnection();
0:         xac.addConnectionEventListener(new AssertEventCatcher(6));
0:         XAResource xar = xac.getXAResource();
0:         Xid xid = new cdsXid(1, (byte) 103, (byte) 119);
1: 
0:         // now check re-use of *Statement objects across local/global 
0:         // connections.
0:         Connection cs1 = xac.getConnection();
1: 
0:         // ensure read locks stay around until end-of transaction
0:         cs1.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);
0:         cs1.setAutoCommit(false);
0:         assertLocks(null, cs1);
1: 
0:         Statement sru1 = cs1.createStatement();
0:         sru1.setCursorName("SN1");
0:         sru1.executeUpdate("insert into intTable values 1,2,3");
0:         Statement sruBatch = cs1.createStatement();
0:         sruBatch.setCursorName("sruBatch");
0:         Statement sruState = createFloatStatementForStateChecking(
0:             StatementExpectedValues, cs1);
0:         PreparedStatement psruState = createFloatStatementForStateChecking(
0:             new int[] {1, 4}, PreparedStatementExpectedValues, cs1, 
0:             "select i from intTable where i = ?");
0:         CallableStatement csruState = createFloatCallForStateChecking(
0:             new int[] {2, 12, 12}, CallableStatementExpectedValues, cs1, 
0:             "CALL SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(?,?)");
0:         PreparedStatement psParams = 
0:             cs1.prepareStatement("select * from intTable where i > ?");
0:         psParams.setCursorName("params");
0:         psParams.setInt(1, 2);
0:         // Params-local-1
0:         resultSetQuery("params", three, psParams.executeQuery());
1: 
0:         sruBatch.addBatch("insert into intTable values 4");
0:         // sru1-local-1
0:         queryOnStatement("SN1", onetwothree, cs1, sru1);
0:         cs1.commit(); // need to commit to switch to an global connection;
1: 
0:         // simple case - underlying connection is re-used for global.
0:         xar.start(xid, XAResource.TMNOFLAGS); 
0:         // Expecting downgrade because global transaction sru1-global-2 is 
0:         // using a statement with holdability true
0:         // sru1-global-2
0:         queryOnStatement("SN1", onetwothree, cs1, sru1);
0:         sruBatch.addBatch("insert into intTable values 5");
0:         Statement sru2 = cs1.createStatement();
0:         sru2.setCursorName("OAK2");
0:         //sru2-global-3
0:         queryOnStatement("OAK2", onetwothree, cs1, sru2);
0:         // Expecting downgrade because global transaction sru1-global-4 is
0:         // using a statement with holdability true
0:         // sru1-global-4
0:         queryOnStatement("SN1", onetwothree, cs1, sru1);
0:         // Global statement
0:         StatementExpectedValues[6] = ResultSet.CLOSE_CURSORS_AT_COMMIT;
0:         PreparedStatementExpectedValues[6] = ResultSet.CLOSE_CURSORS_AT_COMMIT;
0:         CallableStatementExpectedValues[6] = ResultSet.CLOSE_CURSORS_AT_COMMIT;
0:         assertStatementState(null, StatementExpectedValues ,sruState);
0:         // Global PreparedStatement
0:         assertStatementState(pspc, PreparedStatementExpectedValues, psruState);
0:         // Global CallableStatement
0:         assertStatementState(cspc, CallableStatementExpectedValues, csruState);
0:         // Params-global-1
0:         resultSetQuery("params", three, psParams.executeQuery());
1: 
0:         xar.end(xid, XAResource.TMSUCCESS);
0:         // now a new underlying connection is created
0:         // sru1-local-5
0:         queryOnStatement("SN1", onetwothree, cs1, sru1);
0:         // sru2-local-6
0:         queryOnStatement("OAK2", onetwothree, cs1, sru2);
0:         sruBatch.addBatch("insert into intTable values 6,7");
0:         Statement sru3 = cs1.createStatement();
0:         sru3.setCursorName("SF3");
0:         // sru3-local-7
0:         queryOnStatement("SF3", onetwothree, cs1, sru3);
0:         // Two transactions should hold locks (global and the current XA);
0:         // LOCAL
0:         StatementExpectedValues[6] = ResultSet.HOLD_CURSORS_OVER_COMMIT;
0:         PreparedStatementExpectedValues[6] = ResultSet.HOLD_CURSORS_OVER_COMMIT;
0:         CallableStatementExpectedValues[6] = ResultSet.HOLD_CURSORS_OVER_COMMIT;
0:         assertStatementState(null, StatementExpectedValues, sruState); 
0:         assertStatementState(pspc, PreparedStatementExpectedValues, psruState);
0:         assertStatementState(cspc, CallableStatementExpectedValues, csruState);
0:         // Params-local-2
0:         resultSetQuery("params", three, psParams.executeQuery());
0:         assertLocks(new int[] {14,14}, cs1);
0:         cs1.commit();
1: 
0:         // attach the XA transaction to another connection and see what happens
0:         XAConnection xac2 = dsx.getXAConnection();
0:         xac2.addConnectionEventListener(new AssertEventCatcher(5));
0:         XAResource xar2 = xac2.getXAResource();
1: 
0:         xar2.start(xid, XAResource.TMJOIN);
0:         Connection cs2 = xac2.getConnection();
1: 
0:         // these statements were generated by cs1 and thus are still
0:         // in a local connection.
0:         // sru1-local-8
0:         queryOnStatement("SN1", onetwothree, cs1, sru1);
0:         // sru2-local-9
0:         queryOnStatement("OAK2", onetwothree, cs1, sru2);
0:         // sru3-local-10
0:         queryOnStatement("SF3", onetwothree, cs1, sru3);
0:         sruBatch.addBatch("insert into intTable values 8");
0:         // LOCAL 2
0:         assertStatementState(null, StatementExpectedValues, sruState);
0:         assertStatementState(pspc, PreparedStatementExpectedValues, psruState);
0:         assertStatementState(cspc, CallableStatementExpectedValues, csruState);
1: 
0:         assertLocks(new int[] {14, 12}, cs1);
1: 
0:         int[] updateCounts = sruBatch.executeBatch();
0:         int[] expectedUpdateCounts = {1, 1, 2, 1};
0:         // sruBatch update counts: 
0:         for (int i = 0; i < updateCounts.length; i++) {
0:             assertEquals(expectedUpdateCounts[i], updateCounts[i]);
1:         }
0:         // sruBatch
0:         queryOnStatement(
0:             "sruBatch", new int[] {1,2,3,4,5,6,7,8}, cs1, sruBatch);
1: 
0:         xar2.end(xid, XAResource.TMSUCCESS);
0:         xac2.close();
1: 
0:         // allow close on already closed XAConnection
0:         xac2.close();
0:         xac2.addConnectionEventListener(null);
0:         xac2.removeConnectionEventListener(null);
1: 
0:         // test methods against a closed XAConnection and its resource
1:         try {
0:             xac2.getXAResource();
0:             // TODO: is this a bug?: 
0:             // Network Server does not think this is worth an exception.
1:             if (usingEmbedded())
0:                 fail("expected SQLException on " +
0:                     "closed XAConnection.getXAResource");
1:         } catch (SQLException sqle) {
1:             assertSQLState("08003", sqle);
1:         }
1:         try {
0:             xac2.getConnection();
0:             fail ("expected SQLException on XAConnection.getConnection");
1:         } catch (SQLException sqle) {
1:             assertSQLState("08003", sqle);
1:         }
1:         try {
0:             xar2.start(xid, XAResource.TMJOIN);
0:             fail ("expected XAException on XAResource.TMJOIN");
0:         } catch (XAException xae) {
0:             assertXAException("XAResource.start", xae);
1:         }
1:         try {
0:             xar2.end(xid, XAResource.TMJOIN);
0:             fail ("expected XAException on XAResource.TMJOIN");
0:         } catch (XAException xae) {
0:             assertXAException("XAResource.end", xae);
1:         }
1:         try {
0:             xar2.commit(xid, true);
0:             fail ("expected XAException on XAResource.commit");
0:         } catch (XAException xae) {
0:             assertXAException("XAResource.commit", xae);
1:         }
1:         try {
0:             xar2.prepare(xid);
0:             fail ("expected XAException on XAResource.prepare");
0:         } catch (XAException xae) {
0:             assertXAException("XAResource.prepare", xae);
1:         }
1:         try {
0:             xar2.recover(0);
0:             fail ("expected XAException on XAResource.recover");
0:         } catch (XAException xae) {
0:             assertXAException("XAResource.recover", xae);
1:         }
1:         try {
0:             xar2.prepare(xid);
0:             fail ("expected XAException on XAResource.prepare");
0:         } catch (XAException xae) {
0:             assertXAException("XAResource.prepare", xae);
1:         }
1:         try {
0:             xar2.isSameRM(xar2);
0:             fail ("expected XAException on XAResource.isSameRM");
0:         } catch (XAException xae) {
0:             assertXAException("XAResource.isSameRM", xae);
1:         }
1:         
0:         // close everything
0:         cs1.rollback();
0:         sruState.close();
0:         psruState.close();
0:         csruState.close();
0:         psParams.close();
0:         sruBatch.close();
0:         sru1.close();
0:         sru2.close();
0:         sru3.close();
0:         cs1.close();
0:         cs2.close();
0:         xac.removeConnectionEventListener(null);
0:         xac.close();
0:         xac2.close();
1:         
0:         // but, still not enough.
0:         // what with all the switching between global and local transactions
0:         // we still have a lock open on intTable, which will interfere with
0:         // our tearDown efforts. Bounce the database.
1:         TestConfiguration.getCurrent().shutdownDatabase();
1:     }
1:     
0:     public void testSetSchemaInXAConnection() throws SQLException {
0:         // tests that set schema works correctly in an XA connection.
1: 
0:         XADataSource dsx = J2EEDataSource.getXADataSource();
0:         XAConnection xac3 = dsx.getXAConnection();
0:         Connection conn3 = xac3.getConnection();
0:         Statement st3 = conn3.createStatement();
0:         st3.execute("SET SCHEMA SCHEMA_Patricio");
0:         st3.close();
1: 
0:         PreparedStatement ps3 = 
0:             conn3.prepareStatement("INSERT INTO Patricio VALUES (?, ?)");
0:         ps3.setString(1, "Patricio");
0:         ps3.setInt(2, 3);
0:         ps3.executeUpdate();
1: 
0:         assertEquals(1, ps3.getUpdateCount());
0:         ps3.close();
0:         conn3.close();
0:         xac3.close();
1:     }
1:     
1:     
0:     // test that an xastart in auto commit mode commits the existing work.
0:     // test fix of a bug ('beetle 5178') wherein XAresource.start() when 
0:     // auto-commit is true did not implictly commit any transaction
0:     // Also tests DERBY-1025, same description, but for client.
0:     public void testAutoCommitOnXAResourceStart() throws SQLException, XAException {
1: 
0:         XADataSource dsx = J2EEDataSource.getXADataSource();
0:         XAConnection xac4 = dsx.getXAConnection();
0:         Xid xid4a= null;
1: 
0:         // We get an XAID_DUP error from networkserver when attempting
0:         // the XAResource.start below if we use the same xid.
0:         // Possibly because we're in the same jvm.
0:         // When the test is run with clientserverSuite, rather than default,
0:         // this wasn't needed, so just create a different id for client
1:         if (usingEmbedded())
0:             xid4a = new cdsXid(4, (byte) 23, (byte) 76);
0:         else if (usingDerbyNetClient())
0:             xid4a = new cdsXid(5, (byte) 23, (byte) 76);
1:             
0:         Connection conn4 = xac4.getConnection();
0:         assertTrue(conn4.getAutoCommit());
1: 
0:         Statement s4 = conn4.createStatement();
0:         ResultSet rs4 = s4.executeQuery("select i from autocommitxastart");
0:         rs4.next();
0:         assertEquals(1, rs4.getInt(1));
0:         rs4.next();
0:         assertEquals(2, rs4.getInt(1));
1: 
0:         // XAResource().start should commit the transaction
1:         try {
0:             xac4.getXAResource().start(xid4a, XAResource.TMNOFLAGS);
0:             xac4.getXAResource().end(xid4a, XAResource.TMSUCCESS);
0:         } catch (XAException xae) {
0:             fail("unexpected XAException on xac4.getXAResource.start or end");
0:         } catch (Exception e) {
0:             fail("unexpected Exception on xac4.getXAResource.start or end");
1:         }
1:         
0:         // DERBY-1025.
0:         // With Embedded, this will give error: 08003 - No current connection
0:         // But with NetworkServer / DerbyNetClient, the transaction does not
0:         // appear to be closed, and we actually get a value.
1:         try {
0:             rs4.next();
0:             rs4.getInt(1);
1:             if (usingEmbedded())
0:                 fail ("expected an exception indicating resultset is closed.");
1:         } catch (SQLException sqle) {
0:             // expect 08003 - No current connection (or similar).
0:             assertSQLState("08003",sqle);
1:         }
1: 
0:         conn4.setAutoCommit(false);
0:         assertFalse(conn4.getAutoCommit());
1: 
0:         rs4 = s4.executeQuery("select i from autocommitxastart");
0:         rs4.next();
0:         assertEquals(1, rs4.getInt(1));
0:         rs4.next();
0:         assertEquals(2, rs4.getInt(1));
1:         
0:          // Get a new xid to begin another transaction. 
1:         if (usingEmbedded())
0:             xid4a = new cdsXid(4, (byte) 93, (byte) 103);
0:         else if (usingDerbyNetClient())
0:             xid4a = new cdsXid(5, (byte) 93, (byte) 103);
1: 
1:         try {
0:             xac4.getXAResource().start(xid4a, XAResource.TMNOFLAGS);
0:         } catch (XAException xae) {
1:             if (usingEmbedded())
0:                 assertNull(xae.getMessage());
0:             else if (usingDerbyNetClient())
1:             {
0:                 // This should give XAER_OUTSIDE exception because
0:                 // the resource manager is busy in the local transaction
0:                 assertTrue(xae.getMessage().indexOf("XAER_OUTSIDE") >=0 );
1:             }
0:             assertEquals(-9, xae.errorCode);
1:         }
1:         
1:         try {
0:             rs4.next();
0:             assertEquals(3, rs4.getInt(1));
0:         } catch (Exception e) {
0:             fail (" unexpected exception");
1:         }
0:         rs4.close();
1: 
0:         conn4.rollback();
0:         conn4.close();
0:         xac4.close();
1:     }
1: 
0:     public void testReadOnlyToWritableTran() throws SQLException, Exception
1:     {
0:         // TESTING READ_ONLY TRANSACTION FOLLOWED BY WRITABLE TRANSACTION
0:         // Test following sequence of steps
0:         // 1)start a read-only global transaction 
0:         // 2)finish that read-only transaction
0:         // 3)start another global transaction 
1: 
0:         XADataSource dsx = J2EEDataSource.getXADataSource();
0:         JDBCDataSource.setBeanProperty(dsx, "DatabaseName", dbName);
0:         XAConnection xac5 = dsx.getXAConnection();
0:         Xid xid5a = new cdsXid(5, (byte) 119, (byte) 129);
0:         Connection conn5 = xac5.getConnection();
0:         Statement sru5a = conn5.createStatement();
0:         XAResource xar = xac5.getXAResource();
0:         xar.start(xid5a, XAResource.TMNOFLAGS);
0:         conn5.setReadOnly(true);
1: 
0:         // Read-Only XA transaction;
0:         // holdability: (hold, or close cursors over commit) , 
0:         // transaction isolation: read-committed, 
0:         // auto-commit false, read-only true (with embedded)
1:         if (usingEmbedded()) 
1:         {
0:             assertConnectionState(
0:                 ResultSet.CLOSE_CURSORS_AT_COMMIT, 
0:                 Connection.TRANSACTION_READ_COMMITTED,
0:                 false, true, conn5);
1:         }
0:         // Note: the original test had no comments about this difference
0:         //       between Embedded and DerbyNetClient, this has apparently
0:         //       been accepted behavior.
0:         else if (usingDerbyNetClient())
1:         {
0:             assertConnectionState(
0:                 ResultSet.CLOSE_CURSORS_AT_COMMIT, 
0:                 Connection.TRANSACTION_READ_COMMITTED,
0:                 false, false, conn5);
1:         }
1:         
0:         ResultSet rs5 = sru5a.executeQuery(
0:             "select count(*) from autocommitxastart");
0:         rs5.next();
0:         assertEquals(5, rs5.getInt(1));
0:         rs5.close();
0:         xar.end(xid5a, XAResource.TMSUCCESS);
0:         xar.commit(xid5a, true);
0:         conn5.close();
1:         
0:         //now start a new transaction
0:         conn5 = xac5.getConnection();
0:         sru5a = conn5.createStatement();
0:         xar.start(xid5a, XAResource.TMNOFLAGS);
1:         
0:         // Writeable XA transaction
0:         // holdability: (hold, or close cursors over commit) , 
0:         // transaction isolation: read-committed, 
0:         // auto-commit false, read-only false
0:         assertConnectionState(
0:                 ResultSet.CLOSE_CURSORS_AT_COMMIT, 
0:                 Connection.TRANSACTION_READ_COMMITTED,
0:                 false, false, conn5);
0:         sru5a.executeUpdate("insert into autocommitxastart values 6,7");
0:         rs5 = sru5a.executeQuery("select count(*) from autocommitxastart");
0:         rs5.next();
0:         assertEquals(7, rs5.getInt(1));
0:         xar.end(xid5a, XAResource.TMSUCCESS);
0:         xar.commit(xid5a, true);
0:         conn5.close();
0:         xac5.close();
0:         sru5a.close();
1:     }
1:     
1:     // test jira-derby 95 - a NullPointerException was returned when passing
1:     // an incorrect database name, should now give error:
1:     // XCY00 - invalid valid for property ...  
1:     // with DataSource
1:     public void testJira95ds() throws SQLException {
1:         if (usingEmbedded())
1:         {
1:             try {
1:                 DataSource ds = JDBCDataSource.getDataSource();
0:                 // non-existent database
0:                 JDBCDataSource.setBeanProperty(ds, "databaseName", "jdbc:derby:wombat");
1:                 ds.getConnection();
0:                 fail ("expected an SQLException!");
1:             } catch (SQLException sqle) {
0:                 // DERBY-2498: with client, getting a NullPointerException.
0:                 // Note also: the NPE does not occur with XADataSource - see
0:                 // testJira95xads().
1:                 if (usingEmbedded())
0:                     assertSQLState("XCY00", sqle);
0:             } catch (Exception e) {
0:                 e.printStackTrace();
0:                 // DERBY-2498, when fixed, remove 'if'
1:                 if (usingEmbedded())
0:                     fail ("unexpected exception: " + e.toString());
1:             }
1:         } 
1:     }
1: 
1:     // test jira-derby 95 - a NullPointerException was returned when passing
0:     // an incorrect database name, should now give error XCY00   
0:     // with ConnectionPoolDataSource
0:     public void testJira95pds() throws SQLException {
1:         try {
0:             ConnectionPoolDataSource pds = J2EEDataSource.getConnectionPoolDataSource();
0:             JDBCDataSource.setBeanProperty(pds, "databaseName", "jdbc:derby:boo");
0:             pds.getPooledConnection();
0:             fail ("expected an SQLException!");
1:         } catch (SQLException sqle) {
0:             // DERBY-2498 - when fixed, remove if
1:             if (usingEmbedded())
0:                 assertSQLState("XCY00", sqle);
0:         } catch (Exception e) {
0:             // DERBY-2498 - when fixed, remove if
1:             if (usingEmbedded())
0:                 fail ("unexpected exception: " + e.toString());
1:         }
1:     }
1:     
1:     // test jira-derby 95 - a NullPointerException was returned when passing
0:     // an incorrect database name, should now give error XCY00   
0:     // with XADataSource
0:     public void testJira95xads() throws SQLException {
1:         try {
0:             XADataSource dxs = J2EEDataSource.getXADataSource();
0:             JDBCDataSource.setBeanProperty(dxs, "databaseName", "jdbc:derby:boo");
0:             dxs.getXAConnection().getConnection();
0:             fail ("expected an SQLException!");
1:         } catch (SQLException sqle) {
0:             assertSQLState("XCY00", sqle);
0:         } catch (Exception e) {
0:             fail ("unexpected exception: " + e.toString());
1:         }
1:     }
1:     
1:     public void testBadConnectionAttributeSyntax() throws SQLException {
1:         
1:         // DataSource - bad connattr syntax
1:         DataSource ds = JDBCDataSource.getDataSource();
0:         JDBCDataSource.setBeanProperty(ds, "databaseName", dbName);
1:         JDBCDataSource.setBeanProperty(ds, "ConnectionAttributes", "bad");
1:         try {
1:             ds.getConnection();
1:             fail ("should have seen an error");
1:         } catch (SQLException e) {
1:             if (usingEmbedded())
0:                 assertSQLState("XJ028", e);
0:             else if (usingDerbyNetClient())
0:                 assertSQLState("XJ212", e);
1:         } 
0:         JDBCDataSource.clearStringBeanProperty(ds, "ConnectionAttributes");
1: 
0:         // ConnectionPoolDataSource - bad connatr syntax
0:         ConnectionPoolDataSource cpds = J2EEDataSource.getConnectionPoolDataSource();
0:         JDBCDataSource.setBeanProperty(cpds, "databaseName", dbName);
0:         JDBCDataSource.setBeanProperty(cpds, "ConnectionAttributes", "bad");
1:         try {
0:             cpds.getPooledConnection();
1:             fail ("should have seen an error");
1:         } catch (SQLException e) {
0:             assertSQLState("XJ028", e);
1:         } 
0:         JDBCDataSource.clearStringBeanProperty(cpds, "ConnectionAttributes");
1: 
0:         // XADataSource - bad connattr syntax");
0:         XADataSource xads = J2EEDataSource.getXADataSource();
0:         JDBCDataSource.setBeanProperty(xads, "databaseName", dbName);
0:         JDBCDataSource.setBeanProperty(xads, "ConnectionAttributes", "bad");
1:         try {
0:             xads.getXAConnection();
1:             fail ("should have seen an error");
1:         } catch (SQLException e) {
0:             assertSQLState("XJ028", e);
1:         } 
0:         JDBCDataSource.clearStringBeanProperty(xads, "ConnectionAttributes");
1:     } // End testBadConnectionAttributeSyntax
1:         
1:     /**
1:      * Check that database name set using setConnectionAttributes is not used
1:      * by ClientDataSource. This method tests DERBY-1130.
1:      * 
1:      * @throws SQLException
1:      */
0:     public void testClientDSConnectionAttributes() throws SQLException {
1:         if (usingEmbedded())
1:             return;
1:         
0:         ClientDataSource ds = new ClientDataSource();
1: 
1:         // DataSource - EMPTY; expect error 08001 in all cases
1:         // 08001: Required Derby DataSource property databaseName not set.
1:         dsConnectionRequests(new String[]  
1:             {"08001","08001","08001","08001",
1:              "08001","08001","08001","08001","08001"}, ds);
1: 
1:         // DataSource - connectionAttributes=databaseName=<valid name>
1:         ds.setConnectionAttributes("databaseName=" + dbName);
1:         dsConnectionRequests(new String[]  
1:             {"08001","08001","08001","08001",
1:              "08001","08001","08001","08001","08001"}, ds);
1:         ds.setConnectionAttributes(null);
1: 
1:         // Test that (invalid) database name specified in connection
1:         // attributes is not used
1:         // DataSource - databaseName=<valid db> and 
1:         // connectionAttributes=databaseName=kangaroo
1:         ds.setConnectionAttributes("databaseName=kangaroo");
1:         ds.setDatabaseName(dbName);
1:         dsConnectionRequests(new String[]  
1:             {"OK","08001","OK","OK",
1:              "08001","08001","OK","OK","OK"}, ds);
1:         ds.setConnectionAttributes(null);
1:         ds.setDatabaseName(null);
1: 
0:         // now with ConnectionPoolDataSource
0:         ClientConnectionPoolDataSource cpds = 
0:             new ClientConnectionPoolDataSource();
0:         // ConnectionPoolDataSource - EMPTY
1:         dsConnectionRequests(new String[]  
1:             {"08001","08001","08001","08001",
0:              "08001","08001","08001","08001","08001"}, 
0:             (ConnectionPoolDataSource)cpds);
1: 
0:         // ConnectionPoolDataSource 
0:         // - connectionAttributes=databaseName=<valid dbname>
0:         cpds.setConnectionAttributes("databaseName=" + dbName);
1:         dsConnectionRequests(new String[]  
1:             {"08001","08001","08001","08001",
0:              "08001","08001","08001","08001","08001"},
0:             (ConnectionPoolDataSource)cpds);
0:         cpds.setConnectionAttributes(null);
1: 
0:         // Test that database name specified in connection attributes is 
0:         // not used
0:         // ConnectionPoolDataSource - databaseName=wombat and 
1:         // connectionAttributes=databaseName=kangaroo
0:         cpds.setConnectionAttributes("databaseName=kangaroo");
0:         cpds.setDatabaseName(dbName);
1:         dsConnectionRequests(new String[]  
0:             {"OK","08001","OK","OK","08001","08001","OK","OK","OK"},
0:             (ConnectionPoolDataSource)cpds);
0:         cpds.setConnectionAttributes(null);
0:         cpds.setDatabaseName(null);
1: 
0:         // now with XADataSource
0:         ClientXADataSource xads = new ClientXADataSource();
0:         // XADataSource - EMPTY
1:         dsConnectionRequests(new String[]  
1:             {"08001","08001","08001","08001",
0:              "08001","08001","08001","08001","08001"}, 
0:             (XADataSource) xads);
1: 
0:         // XADataSource - connectionAttributes=databaseName=<valid dbname>
0:         xads.setConnectionAttributes("databaseName=wombat");
1:         dsConnectionRequests(new String[]  
1:             {"08001","08001","08001","08001",
0:              "08001","08001","08001","08001","08001"},
0:             (XADataSource) xads);
0:         xads.setConnectionAttributes(null);
1: 
0:         // Test that database name specified in connection attributes is not used
0:         // XADataSource - databaseName=wombat and 
1:         // connectionAttributes=databaseName=kangaroo
0:         xads.setConnectionAttributes("databaseName=kangaroo");
0:         xads.setDatabaseName("wombat");
1:         dsConnectionRequests(new String[]  
0:             {"OK","08001","OK","OK","08001","08001","OK","OK","OK"},
0:             (XADataSource) xads);
0:         xads.setConnectionAttributes(null);
0:         xads.setDatabaseName(null);
1:     } // End testClientDSConnectionAttributes
1:             
0:     // Following test is similar to testClientDSRequestAuthentication, but
1:     // for embedded datasources.
0:     // This subtest does not run for network server, the database shutdown
0:     // is done using setDatabaseShutdown.
0:     public static void testDSRequestAuthentication() throws SQLException {
1: 
0:         if (usingDerbyNetClient())
1:             return;
1:         
0:         EmbeddedDataSource ds = new EmbeddedDataSource();
1: 
1:         // DataSource - EMPTY
1:         dsConnectionRequests(new String[] {  
1:              "XJ004","XJ004","XJ004","XJ004",
1:              "XJ004","XJ004","XJ004","XJ004","XJ004"}, ds);
1:  
1:         // DataSource - connectionAttributes=databaseName=wombat");
1:         ds.setConnectionAttributes("databaseName=" + dbName);
1:         dsConnectionRequests(new String[] {  
1:             "XJ004","XJ004","XJ004","XJ004",
1:             "XJ004","XJ004","XJ004","XJ004","XJ004"}, ds);
1:         ds.setConnectionAttributes(null);
1: 
0:         // DataSource - attributesAsPassword=true");
0:         ds.setAttributesAsPassword(true);
1:         dsConnectionRequests(new String[] {  
0:             "XJ004","XJ004","XJ004","XJ028",
0:             "XJ028","XJ004","XJ004","XJ004","XJ004"}, ds);
0:         ds.setAttributesAsPassword(false);
1: 
0:         // DataSource - attributesAsPassword=true, 
0:         // connectionAttributes=databaseName=kangaroo");
0:         ds.setAttributesAsPassword(true);
1:         ds.setConnectionAttributes("databaseName=kangaroo");
1:         dsConnectionRequests(new String[] {  
0:             "XJ004","XJ004","XJ004","XJ028",
0:             "XJ028","XJ004","XJ004","XJ004","XJ004"}, ds);
0:         ds.setAttributesAsPassword(false);
1:         ds.setConnectionAttributes(null);
1: 
0:         // Enable Authentication;
1: 
0:         setDatabaseProperty("derby.user.fred", "wilma");
0:         setDatabaseProperty("derby.user.APP", "APP");
0:         setDatabaseProperty("derby.authentication.provider", "BUILTIN");
0:         setDatabaseProperty("derby.connection.requireAuthentication", "true");
1:         
0:         ds.setShutdownDatabase("shutdown");
1:         try {
1:             ds.getConnection();
1:         } catch (SQLException sqle) {
0:             assertSQLState("XJ015", sqle);
1:         }
1: 
1:         ds.setDatabaseName(null);
0:         ds.setShutdownDatabase(null);
1: 
0:         // "AUTHENTICATION NOW ENABLED");
1: 
0:         // DataSource - attributesAsPassword=true
0:         ds.setAttributesAsPassword(true);
1:         dsConnectionRequests(new String[] {  
0:             "XJ004","XJ004","XJ004","XJ028",
0:             "XJ028","XJ004","XJ004","XJ004","XJ004"}, ds);
0:         ds.setAttributesAsPassword(false);
1: 
0:         // ensure the DS property password is not treated as a set of 
0:         // attributes.
0:         // DataSource - attributesAsPassword=true, user=fred, 
0:         //     password=databaseName=wombat;password=wilma
0:         ds.setAttributesAsPassword(true);
0:         ds.setUser("fred");
0:         ds.setPassword("databaseName=" + dbName + ";password=wilma");
1:         dsConnectionRequests(new String[] {  
0:             "XJ004","XJ004","XJ004","XJ028",
0:             "XJ028","XJ004","XJ004","XJ004","XJ004"}, ds);
0:         ds.setAttributesAsPassword(false);
0:         ds.setUser(null);
0:         ds.setPassword(null);
1:         ds = null;
1: 
0:         // now with ConnectionPoolDataSource
0:         EmbeddedConnectionPoolDataSource cpds = new EmbeddedConnectionPoolDataSource();
0:         // ConnectionPoolDataSource - EMPTY
1:         dsConnectionRequests(new String[] {  
1:             "XJ004","XJ004","XJ004","XJ004",
0:             "XJ004","XJ004","XJ004","XJ004","XJ004"},
0:             (ConnectionPoolDataSource)cpds);
1: 
0:         // ConnectionPoolDataSource - 
0:         // connectionAttributes=databaseName=wombat
0:         cpds.setConnectionAttributes("databaseName=" + dbName);
1:         dsConnectionRequests(new String[] {  
1:             "XJ004","XJ004","XJ004","XJ004",
0:             "XJ004","XJ004","XJ004","XJ004","XJ004"},
0:             (ConnectionPoolDataSource)cpds);
0:         cpds.setConnectionAttributes(null);
1: 
0:         // ConnectionPoolDataSource - attributesAsPassword=true
0:         cpds.setAttributesAsPassword(true);
1:         dsConnectionRequests(new String[] {  
0:             "XJ004","XJ004","XJ004","XJ028",
0:             "XJ028","XJ004","XJ004","XJ004","XJ004"},
0:             (ConnectionPoolDataSource)cpds);
0:         cpds.setAttributesAsPassword(false);
1:         
0:         // ensure the DS property password is not treated as a set of
0:         // attributes.
0:         // ConnectionPoolDataSource - attributesAsPassword=true, 
0:         //     user=fred, password=databaseName=wombat;password=wilma");
0:         cpds.setAttributesAsPassword(true);
0:         cpds.setUser("fred");
0:         cpds.setPassword("databaseName=" + dbName + ";password=wilma");
1:         dsConnectionRequests(new String[] {  
0:             "XJ004","XJ004","XJ004","XJ028",
0:             "XJ028","XJ004","XJ004","XJ004","XJ004"},
0:             (ConnectionPoolDataSource)cpds);
0:         cpds.setAttributesAsPassword(false);
0:         cpds.setUser(null);
0:         cpds.setPassword(null);
0:         cpds = null;
1: 
0:         // now with XADataSource
0:         EmbeddedXADataSource xads = new EmbeddedXADataSource();
0:         // XADataSource - EMPTY
1:         dsConnectionRequests(new String[] {  
0:             "08006","08006","08006","08006",
0:             "08006","08006","08006","08006","08006"},
0:             (XADataSource) xads);
1: 
0:         // XADataSource - databaseName=wombat
0:         xads.setDatabaseName(dbName);
1:         dsConnectionRequests(new String[] {  
0:             "08004","08004","08004","OK",
0:             "08004","08004","08004","08004","08004"},
0:             (XADataSource) xads);
0:         xads.setDatabaseName(null);
1: 
0:         // XADataSource - connectionAttributes=databaseName=wombat");
0:         xads.setConnectionAttributes("databaseName=" + dbName);
1:         dsConnectionRequests(new String[] {  
0:             "08006","08006","08006","08006",
0:             "08006","08006","08006","08006","08006"},
0:             (XADataSource) xads);
0:         xads.setConnectionAttributes(null);
1: 
0:         // XADataSource - attributesAsPassword=true
0:         xads.setAttributesAsPassword(true);
1:         dsConnectionRequests(new String[] {  
0:             "08006","08006","08006","08006",
0:             "08006","08006","08006","08006","08006"},
0:             (XADataSource) xads);
0:         xads.setAttributesAsPassword(false);
1: 
0:         // XADataSource - databaseName=wombat, attributesAsPassword=true
0:         xads.setDatabaseName(dbName);
0:         xads.setAttributesAsPassword(true);
1:         dsConnectionRequests(new String[] {  
0:             "08004","08004","08004","XJ028",
0:             "XJ028","08004","08004","OK","08004"},
0:             (XADataSource) xads);
0:         xads.setAttributesAsPassword(false);
0:         xads.setDatabaseName(null);
1:         
0:         setDatabaseProperty("derby.connection.requireAuthentication", "false");
1:         TestConfiguration.getCurrent().shutdownDatabase();
1:     }
1:     
1:     /**
1:      * Check that traceFile connection attribute functions correctly.
1:      * tracefile was tested in checkDriver, but not for DataSources.
1:      * tracefile= was used in datasourcepermissions_net, but that's 
1:      * incorrect syntax. Note that we're not checking the contents of
1:      * the tracefile.
1:      *
1:      * Note also that this test cannot run against a remote server.
1:      *  
1:      * @throws SQLException
1:      */
1:     public void testClientTraceFileDSConnectionAttribute() throws SQLException
1:     {
1:         if (usingEmbedded())
1:             return;
1: 
1:         String traceFile;
1: 
1:         // DataSource
0:         ClientDataSource ds = new ClientDataSource();
1:         ds.setDatabaseName(dbName);
1: 
1:         // DataSource - setTransationAttributes
1:         traceFile = "trace1.out";
0:         ds.setConnectionAttributes("traceFile="+traceFile);
1:         // In this scenario, we *only* get a tracefile, if we first get a 
1:         // successful connection, followed by an unsuccessful connection. 
1:         // So, we cannot just use ds.getConnection()
1:         dsGetBadConnection(ds);
1:         ds.setConnectionAttributes(null);
1:         // DataSource - setTraceFile
1:         traceFile = "trace2.out";
0:         ds.setTraceFile(traceFile);
1:         ds.getConnection();
0:         ds.setTraceFile(null);
1:         ds.setDatabaseName(null);
1: 
0:         // now with ConnectionPoolDataSource
0:         ClientConnectionPoolDataSource cpds = new ClientConnectionPoolDataSource();
0:         cpds.setDatabaseName(dbName);
1: 
0:         traceFile = "trace3.out";
0:         cpds.setConnectionAttributes("traceFile="+traceFile);
0:         // DERBY-2468 - trace3.out does not get created
0:         cpds.getConnection();
0:         cpds.setConnectionAttributes(null);
1: 
0:         traceFile = "trace4.out";
0:         cpds.setTraceFile(traceFile);
0:         cpds.getConnection();
0:         cpds.setTraceFile(null);
0:         cpds.setDatabaseName(null);
1: 
0:         // now with XADataSource
0:         ClientXADataSource xads = new ClientXADataSource();
0:         xads.setDatabaseName(dbName);
1: 
0:         traceFile = "trace5.out";
0:         xads.setConnectionAttributes("traceFile="+traceFile);
0:         xads.getConnection();
0:         // DERBY-2468 - trace5.out does not get created
0:         xads.setConnectionAttributes(null);
1: 
0:         traceFile = "trace6.out";
0:         xads.setTraceFile(traceFile);
0:         xads.getConnection();
0:         xads.setTraceFile(null);
0:         xads.setDatabaseName(null);
1: 
1:         assertTraceFilesExist();
1:     }
1:         
1:     /* -- Helper Methods for testClientTraceFileDSConnectionAttribute -- */
1:     
1:     private static void dsGetBadConnection(DataSource ds) {
1:         // first get a good connection, or we don't get a
1:         // traceFile when using connectionattributes.
1:         // also, we do not get a tracefile that way unless
1:         // we see an error.
1:         // with setTraceFile, we *always* get a file, even
1:         // with just a successful connection.
1:         try {
1:             ds.getConnection();
1:             ds.getConnection(null, null);
1:             fail("expected an sqlException");
1:         } catch (SQLException sqle) {
1:             assertSQLState("08001", sqle);
1:         }
1:     }
1:     
1:     /**
1:      * Check that trace file exists in <framework> directory
1:      * 
0:      * @param filename Name of trace file
1:      */
1:     private static void assertTraceFilesExist() 
1:     {
0:         AccessController.doPrivileged(new java.security.PrivilegedAction() {
0:             public Object run() {
0:                 for (int i=0 ; i < 6 ; i++)
1:                 {   
0:                     String traceFileName = "trace" + (i+1) + ".out";
0:                     File traceFile = new File(traceFileName);
0:                     if (i == 2 || i == 4)
0:                         continue;
1:                     else
1:                     {
0:                         assertTrue(traceFile.exists());
1:                     }
1:                 } 
0:                 return null;
1:             }
0:         });
1:     }
1: 
1:     /**
1:      * Check that messageText connection attribute functions correctly.
1:      * retrievemessagetext was tested in checkdriver, and derbynet/testij,
1:      * but not tested for datasources, and in datasourcepermissions_net,
1:      * but as it has nothing to do with permissions/authentication,
1:      * this test seems a better place for it. 
1:      *  
1:      * @throws SQLException
1:      */
0:     public void testClientMessageTextConnectionAttribute() throws SQLException
1:     {
1:         if (usingEmbedded())
1:             return;
1:         
1:         String retrieveMessageTextProperty = "retrieveMessageText";
1:         Connection conn;
1: 
1:         // DataSource
1:         // DataSource - retrieveMessageTextProperty
0:         ClientDataSource ds = new ClientDataSource();
1:         ds.setDatabaseName(dbName);
1:         ds.setConnectionAttributes(retrieveMessageTextProperty + "=false");
1:         conn = ds.getConnection();
1:         assertMessageText(conn,"false");
1:         conn.close();
1:         // now try with retrieveMessageText = true
1:         ds.setConnectionAttributes(retrieveMessageTextProperty + "=true");
1:         conn = ds.getConnection();
1:         assertMessageText(conn,"true");
1:         ds.setConnectionAttributes(null);
1:         conn.close();
1: 
0:         // now with ConnectionPoolDataSource
0:         // ConnectionPoolDataSource - retrieveMessageTextProperty
0:         ClientConnectionPoolDataSource cpds = new ClientConnectionPoolDataSource();
0:         cpds.setDatabaseName(dbName);
0:         cpds.setConnectionAttributes(
0:                 retrieveMessageTextProperty + "=false");
0:         conn = cpds.getConnection();
1:         assertMessageText(conn,"false");
1:         conn.close();
0:         cpds.setConnectionAttributes(
0:                 retrieveMessageTextProperty + "=true");
0:         conn = cpds.getConnection();
1:         assertMessageText(conn,"true");
0:         cpds.setConnectionAttributes(null);
1:         conn.close();
1: 
0:         // now with XADataSource
0:         ClientXADataSource xads = new ClientXADataSource();
0:         //XADataSource - retrieveMessageTextProperty
0:         xads.setDatabaseName(dbName);
0:         xads.setConnectionAttributes(
0:                 retrieveMessageTextProperty + "=false");
0:         conn = xads.getConnection();
1:         assertMessageText(conn,"false");
1:         conn.close();
0:         xads.setConnectionAttributes(
0:                 retrieveMessageTextProperty + "=true");
0:         conn = xads.getConnection();
1:         assertMessageText(conn,"true");
1:         conn.close();
0:         xads.setConnectionAttributes(null);
1:     }
1: 
1:     /* -- Helper Method for testClientMessageTextDSConnectionAttribute -- */
1: 
1:     private static void assertMessageText(
1:             Connection conn, String retrieveMessageTextValue) 
1:     throws SQLException
1:     {
1:         try {
1:             conn.createStatement().executeQuery("SELECT * FROM APP.NOTTHERE");
1:         }
1:         catch (SQLException e)
1:         {
1:             assertSQLState("42X05", e);
1:             if (retrieveMessageTextValue.equals("true") )
1:             {
1:                 assertTrue(e.getMessage().indexOf("does not exist") >= 0);
1:             }
1:             else
1:             {
1:                 // retrieveMessageTextValue is false
1:                 assertTrue(e.getMessage().indexOf("does not exist") == -1);
1:             }
1:         }
1:     }
1: 
1:     /**
1:      * Check that messageText connection attribute functions correctly.
1:      * retrievemessagetext was tested in checkdriver, and derbynet/testij
1:      * (but not tested for datasources), and in datasourcepermissions_net,
1:      * but as it has nothing to do with permissions/authentication,
1:      * this test seems a better place for it. 
1:      *  
1:      * @throws SQLException
1:      */
0:     public void testClientDescriptionConnectionAttribute() 
1:     throws SQLException, Exception {
1: 
1:         if (usingEmbedded())
1:             return;
1:         
1:         // DataSource
1:         String setDescription = 
1:             "Everything you ever wanted to know about this datasource";
0:         String getDescription;
1: 
1:         // DataSource - setDescription
0:         ClientDataSource ds = new ClientDataSource();
1:         ds.setDatabaseName(dbName);
0:         ds.setDescription(setDescription);
1:         ds.getConnection();
0:         getDescription = ds.getDescription();
0:         assertEquals(setDescription, getDescription);
0:         ds.setDescription(null);
1: 
0:         // ConnectionPoolDataSource - setDescription
0:         ClientConnectionPoolDataSource cpds = 
0:             new ClientConnectionPoolDataSource();
0:         cpds.setDatabaseName(dbName);
0:         cpds.setDescription(setDescription);
0:         cpds.getConnection();
0:         getDescription = cpds.getDescription();
0:         assertEquals(setDescription, getDescription);
0:         cpds.setDescription(null);
1: 
0:         // XADataSource - setDescription
0:         ClientXADataSource xads = new ClientXADataSource();
0:         xads.setDatabaseName(dbName);
0:         xads.setDescription(setDescription);
0:         xads.getConnection();
0:         getDescription = xads.getDescription();
0:         assertEquals(setDescription, getDescription);
0:         xads.setDescription(null);
1:     }
1: 
0:     /* ------------------ JDBC30 (and up) Fixtures ------------------ */
1:     
0:     public void testXAHoldability() throws SQLException, XAException {
0:         // TODO: figure this out
0:         // This test, when run with Network server / DerbyNetClient
0:         // leaves the database is a bad state which results in a
0:         // network protocol error
0:         if (usingDerbyNetClient())
1:             return;
0:         // START XA HOLDABILITY TEST
0:         XADataSource dscsx = J2EEDataSource.getXADataSource();
0:         JDBCDataSource.setBeanProperty(dscsx, "databaseName", dbName);
1: 
0:         XAConnection xac = dscsx.getXAConnection();
0:         XAResource xr = xac.getXAResource();
0:         Xid xid = new cdsXid(25, (byte) 21, (byte) 01);
0:         Connection conn1 = xac.getConnection();
0:         // check that autocommit is true; default for a connection
0:         assertTrue(conn1.getAutoCommit());
0:         // check that holdability is HOLD_CURSORS_OVER_COMMIT in a default
0:         // CONNECTION(not in xa transaction yet)
1:         assertEquals(
0:             ResultSet.HOLD_CURSORS_OVER_COMMIT, conn1.getHoldability());
0:         // start a global transaction and default holdability and 
0:         // autocommit will be switched to match Derby XA restrictions
0:         xr.start(xid, XAResource.TMNOFLAGS);
0:         // So, now autocommit should be false for connection because it is
0:         // part of the global transaction
0:         assertFalse(conn1.getAutoCommit());
0:         // Connection's holdability is now CLOSE_CURSORS_AT_COMMIT because
0:         // it is part of the global transaction
1:         assertEquals(
0:             ResultSet.CLOSE_CURSORS_AT_COMMIT, conn1.getHoldability());
1:         
0:         xr.end(xid, XAResource.TMSUCCESS);
0:         conn1.commit();
0:         conn1.close();
1: 
0:         xid = new cdsXid(27, (byte) 21, (byte) 01);
0:         xr.start(xid, XAResource.TMNOFLAGS);
0:         conn1 = xac.getConnection();
0:         // CONNECTION(in xa transaction) HOLDABILITY:
1:         assertEquals(
0:             ResultSet.CLOSE_CURSORS_AT_COMMIT, conn1.getHoldability());
0:         // Autocommit on Connection inside global transaction should be false
0:         assertFalse(conn1.getAutoCommit());
0:         xr.end(xid, XAResource.TMSUCCESS);
0:         conn1.rollback();
1: 
0:         Connection conn = xac.getConnection();
0:         conn.setAutoCommit(false);
1:         conn.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);
0:         // CONNECTION(non-xa transaction) HOLDABILITY: 
1:         assertEquals(
0:             ResultSet.CLOSE_CURSORS_AT_COMMIT, conn.getHoldability());
1: 
0:         Statement s = conn.createStatement();
0:         // STATEMENT HOLDABILITY: 
1:         assertEquals(
0:             ResultSet.CLOSE_CURSORS_AT_COMMIT, s.getResultSetHoldability());
1: 
0:         s.executeUpdate("insert into hold_30 values " +
0:             "(1,'init2'), (2, 'init3'), (3,'init3')");
0:         s.executeUpdate("insert into hold_30 values " +
0:             "(4,'init4'), (5, 'init5'), (6,'init6')");
0:         s.executeUpdate("insert into hold_30 values " +
0:             "(7,'init7'), (8, 'init8'), (9,'init9')");
1: 
0:         // STATEMENT HOLDABILITY :
1:         assertEquals(
0:             ResultSet.CLOSE_CURSORS_AT_COMMIT, s.getResultSetHoldability());
1: 
0:         Statement sh = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY, 
0:             ResultSet.CONCUR_READ_ONLY, ResultSet.HOLD_CURSORS_OVER_COMMIT);
0:         PreparedStatement psh = conn.prepareStatement(
0:             "select id from hold_30 for update", ResultSet.TYPE_FORWARD_ONLY, 
0:             ResultSet.CONCUR_READ_ONLY, ResultSet.HOLD_CURSORS_OVER_COMMIT);
0:         CallableStatement csh = conn.prepareCall(
0:             "select id from hold_30 for update", ResultSet.TYPE_FORWARD_ONLY, 
0:             ResultSet.CONCUR_READ_ONLY, ResultSet.HOLD_CURSORS_OVER_COMMIT);
1: 
0:         // STATEMENT HOLDABILITY :
1:         assertEquals(
0:             ResultSet.HOLD_CURSORS_OVER_COMMIT, sh.getResultSetHoldability());
0:         // PREPARED STATEMENT HOLDABILITY :
1:         assertEquals(
0:             ResultSet.HOLD_CURSORS_OVER_COMMIT, psh.getResultSetHoldability());
0:         // CALLABLE STATEMENT HOLDABILITY :
1:         assertEquals(
0:             ResultSet.HOLD_CURSORS_OVER_COMMIT, csh.getResultSetHoldability());
1: 
0:         ResultSet rsh = sh.executeQuery("select id from hold_30 for update");
0:         rsh.next();  
0:         assertEquals(1, rsh.getInt(1)); // H@1 id
0:         rsh.next(); 
0:         assertEquals(2, rsh.getInt(1)); // H@2 id 
0:         conn.commit();
0:         rsh.next(); 
0:         assertEquals(3, rsh.getInt(1)); // H@3 id 
0:         conn.commit();
1: 
0:         xid = new cdsXid(23, (byte) 21, (byte) 01);
0:         xr.start(xid, XAResource.TMNOFLAGS);
0:         Statement stmtInsideGlobalTransaction = conn.createStatement();
0:         PreparedStatement prepstmtInsideGlobalTransaction = 
0:             conn.prepareStatement("select id from hold_30");
0:         CallableStatement callablestmtInsideGlobalTransaction = 
0:             conn.prepareCall("select id from hold_30");
1: 
0:         // CONNECTION(xa) HOLDABILITY:
0:         assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT, conn.getHoldability());
0:         // STATEMENT(this one was created with holdability false, outside the 
0:         // global transaction. Check its holdability inside global transaction
1:         assertEquals(
0:             ResultSet.CLOSE_CURSORS_AT_COMMIT, s.getResultSetHoldability());
0:         // STATEMENT(this one was created with holdability true, 
0:         // outside the global transaction. Check its holdability inside 
0:         // global transaction:
0:         // TODO: network server / DerbyNetClient has a different value than
0:         //       embedded. Log a bug or is there one?:
1:         if (usingEmbedded())
0:             assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT, 
0:                 sh.getResultSetHoldability());
0:         else if (usingDerbyNetClient())
0:             assertEquals(ResultSet.HOLD_CURSORS_OVER_COMMIT, 
0:                 sh.getResultSetHoldability());
0:         // STATEMENT(this one was created with default holdability inside this
0:         // global transaction. Check its holdability:
1:         assertEquals(
0:             ResultSet.CLOSE_CURSORS_AT_COMMIT, 
0:             stmtInsideGlobalTransaction.getResultSetHoldability());
0:         // PREPAREDSTATEMENT(this one was created with default holdability
0:         // inside this global transaction. Check its holdability:
0:         assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT, 
0:         prepstmtInsideGlobalTransaction.getResultSetHoldability());
0:         // CALLABLESTATEMENT(this one was created with default holdability 
0:         // inside this global transaction. Check its holdability:
0:         assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT,
0:         callablestmtInsideGlobalTransaction.getResultSetHoldability()); 
1: 
0:         ResultSet rsx = s.executeQuery("select id from hold_30 for update");
1: 
0:         rsx.next(); 
0:         assertEquals(1, rsx.getInt(1)); // X@1 id
0:         rsx.next(); 
0:         assertEquals(2, rsx.getInt(1)); // X@2 id
0:         xr.end(xid, XAResource.TMSUCCESS);
1: 
0:         // result set should not be useable, since it is part of a detached
0:         // XAConnection
1:         try {
0:             rsx.next();
0:             rsx.getInt(1);
0:             fail("rsx's connection not active id ");
1:         } catch (SQLException sqle) {
1:             assertSQLState("08003", sqle);
1:         }
1: 
0:         // result set should not be useable, it should have been closed by
0:         // the xa start.
1:         try {
0:             rsh.next();
0:             rsh.getInt(1);
0:             fail("rsh's connection not active id ");
1:         } catch (SQLException sqle) {
1:             if (usingEmbedded())
1:                 assertSQLState("08003", sqle);
0:             else if (usingDerbyNetClient())
0:                 assertSQLState("XCL16", sqle);
1:         }
1: 
0:         // resume XA transaction and keep using rs");
0:         xr.start(xid, XAResource.TMJOIN);
0:         Statement stmtAfterGlobalTransactionResume = conn.createStatement();
0:         PreparedStatement prepstmtAfterGlobalTransactionResume = 
0:             conn.prepareStatement("select id from hold_30");
0:         CallableStatement callablestmtAfterGlobalTransactionResume = 
0:             conn.prepareCall("select id from hold_30");
1: 
0:         // Check holdability of various jdbc objects after resuming XA 
0:         // transaction
0:         // CONNECTION(xa) HOLDABILITY:
0:         assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT,conn.getHoldability());
0:         // STATEMENT(this one was created with holdability false, outside the
0:         // global transaction. Check its holdability inside global transaction
1:         assertEquals(
0:             ResultSet.CLOSE_CURSORS_AT_COMMIT, s.getResultSetHoldability());
0:         // STATEMENT(this one was created with holdability true, outside the 
0:         // global transaction. Check its holdability inside global transaction
1:         if (usingEmbedded())
0:             assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT, 
0:                 sh.getResultSetHoldability());
0:         else if (usingDerbyNetClient())
0:             assertEquals(ResultSet.HOLD_CURSORS_OVER_COMMIT, 
0:                 sh.getResultSetHoldability());
0:         // STATEMENT(this one was created with default holdability inside the
0:         // global transaction when it was first started. Check its holdability
0:         assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT, 
0:             stmtInsideGlobalTransaction.getResultSetHoldability());
0:         // PREPAREDSTATEMENT(this one was created with default holdability 
0:         // inside the global transaction when it was first started. Check its
0:         // holdability) 
0:         assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT,
0:             prepstmtInsideGlobalTransaction.getResultSetHoldability());
0:         // CALLABLESTATEMENT(this one was created with default holdability 
0:         // inside the global transaction when it was first started. Check its
0:         // holdability) HOLDABILITY
0:         assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT,
0:             callablestmtInsideGlobalTransaction.getResultSetHoldability());
0:         // STATEMENT(this one was created with default holdability after the
0:         // global transaction was resumed. Check its holdability
0:         assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT, 
0:             stmtAfterGlobalTransactionResume.getResultSetHoldability());
0:         // PREPAREDSTATEMENT(this one was created with default holdability 
0:         // after the global transaction was resumed. Check its holdability
0:         assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT,
0:             prepstmtAfterGlobalTransactionResume.getResultSetHoldability());
0:         // CALLABLESTATEMENT(this one was created with default holdability
0:         // after the global transaction was resumed. Check its holdability
0:         assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT, 
0:             callablestmtAfterGlobalTransactionResume.getResultSetHoldability());
0:         // DERBY-1370           
1:         if (usingEmbedded())
1:         {
0:             // Network XA BUG gives result set closed
0:             rsx.next();  
0:             assertEquals(3, rsx.getInt(1)); // X@3 id
1:         }
0:         xr.end(xid, XAResource.TMSUCCESS);
1: 
0:         if (xr.prepare(xid) != XAResource.XA_RDONLY)
0:             xr.commit(xid, false);
1: 
0:         // try again once the xa transaction has been committed.            
1:         try {
0:             rsx.next(); 
0:             rsx.getInt(1);
0:             fail("rsx's connection not active id (B)");
1:         } catch (SQLException sqle) {
0:             assertSQLState("XCL16", sqle);
1:         }
1:         try {
0:             rsh.next(); 
0:             rsh.getInt(1);
0:             fail ("rsh's should be closed (B)");
1:         } catch (SQLException sqle) {
0:             assertSQLState("XCL16", sqle);
1:         }
1: 
0:         // Set connection to hold
0:         conn.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);
0:         // CONNECTION(held) HOLDABILITY:
0:         assertEquals(ResultSet.HOLD_CURSORS_OVER_COMMIT, 
0:             conn.getHoldability());
1: 
0:         xid = new cdsXid(24, (byte) 21, (byte) 01);
0:         xr.start(xid, XAResource.TMNOFLAGS);
0:         // CONNECTION(xa) HOLDABILITY:
0:         assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT, conn.getHoldability());
1:         try {
0:             conn.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);
0:             fail("allowed to set hold mode in xa transaction");
1:         } catch (SQLException sqle) {
0:             assertSQLState("XJ05C", sqle);
1:         }
1: 
0:         // JDBC 4.0 (proposed final draft) section 16.1.3.1 allows Statements 
0:         // to be created with a different holdability if the driver cannot 
0:         // support it. In this case the driver does not support holdability in
0:         // a global transaction, so a valid statement is returned with close 
0:         // cursors on commit.
0:         Statement shxa = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY,
0:             ResultSet.CONCUR_READ_ONLY, ResultSet.HOLD_CURSORS_OVER_COMMIT);
0:         // HOLDABLE Statement in global xact " 
0:         assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT, 
0:             s.getResultSetHoldability());
0:         assertEquals(10000, conn.getWarnings().getErrorCode());
0:         shxa.close();
1: 
0:         shxa = conn.prepareStatement("select id from hold_30",
0:             ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY,
0:             ResultSet.HOLD_CURSORS_OVER_COMMIT);
0:         // HOLDABLE PreparedStatement in global xact 
0:         assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT,
0:             s.getResultSetHoldability());
0:         assertEquals(10000, conn.getWarnings().getErrorCode());
0:         shxa.close();
1: 
0:         shxa = conn.prepareCall("CALL SYSCS_UTIL.SYSCS_CHECKPOINT_DATABASE()",
0:             ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY, 
0:             ResultSet.HOLD_CURSORS_OVER_COMMIT);
0:         // HOLDABLE CallableStatement in global xact:
0:         assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT,
0:             s.getResultSetHoldability());
0:         assertEquals(10000, conn.getWarnings().getErrorCode());
0:         shxa.close();
1: 
0:         // check we can use a holdable statement set up in local mode.
0:         // holdability is downgraded, tested in XATest.java
0:         // DERBY-1370           
0:         if(usingEmbedded()) {
0:             // STATEMENT HOLDABILITY:
0:             assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT,
0:                 sh.getResultSetHoldability());
0:             sh.executeQuery("select id from hold_30").close();
0:             sh.execute("select id from hold_30");
0:             sh.getResultSet().close();
1: 
0:             // PREPARED STATEMENT HOLDABILITY:
0:             assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT, 
0:                 psh.getResultSetHoldability());
0:             psh.executeQuery().close();
0:             psh.execute();
0:             psh.getResultSet().close();
1: 
0:             // CALLABLE STATEMENT HOLDABILITY:
0:             assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT,
0:                 csh.getResultSetHoldability());
0:             csh.executeQuery().close();
0:             csh.execute();
0:             csh.getResultSet().close();
1:         }        
1: 
0:         // but an update works
0:         sh.executeUpdate("insert into hold_30 values(10, 'init10')");
1: 
0:         xr.end(xid, XAResource.TMSUCCESS);
1: 
0:         // CONNECTION(held) HOLDABILITY:
1:         assertEquals(
0:             ResultSet.HOLD_CURSORS_OVER_COMMIT, conn.getHoldability());
1: 
1:         s.close();
0:         sh.close();
0:         csh.close();
0:         psh.close();
0:         rsx.close();
0:         stmtInsideGlobalTransaction.close();
0:         prepstmtInsideGlobalTransaction.close();
0:         callablestmtInsideGlobalTransaction.close();
0:         stmtAfterGlobalTransactionResume.close();
0:         prepstmtAfterGlobalTransactionResume.close();
0:         callablestmtAfterGlobalTransactionResume.close();
1:         conn.close();
0:         xac.close();
1:         TestConfiguration.getCurrent().shutdownDatabase();
0:         // END XA HOLDABILITY TEST");
1:     }
1:     
1:     /**
0:      * Tests for DERBY-1144
1:      * 
0:      * This test tests that holdability, autocomit, and transactionIsolation 
0:      * are reset on getConnection for PooledConnections obtaind from 
0:      * connectionPoolDataSources 
1:      * 
0:      * DERBY-1134 has been filed for more comprehensive testing of client 
0:      * connection state. 
1:      * 
1:      * @throws SQLException
1:      */
0:     public void testDerby1144PooledDS() throws SQLException {
1:     
0:         PooledConnection pc1 = null;
1: 
0:         // Test holdability   
0:         ConnectionPoolDataSource ds = 
0:             J2EEDataSource.getConnectionPoolDataSource();
0:         JDBCDataSource.setBeanProperty(ds, "databaseName", dbName);
0:         pc1 = ds.getPooledConnection();
0:         assertPooledConnHoldability("PooledConnection", pc1);
0:         pc1.close();
1:         
0:         // Test autocommit
0:         pc1 = ds.getPooledConnection();
0:         assertPooledConnAutoCommit("PooledConnection", pc1);
0:         pc1.close();
1:         
0:         // Test pooled connection isolation
0:         pc1 = ds.getPooledConnection();
0:         assertPooledConnIso("PooledConnection" , pc1);   
0:         pc1.close();
1:     }
1:     
0:     public void testDerby1144XADS() throws SQLException {
1:        
0:         XADataSource xds = J2EEDataSource.getXADataSource();
0:         JDBCDataSource.setBeanProperty(xds, "databaseName", dbName);
0:         // Test xa connection isolation
0:         XAConnection xpc1 = xds.getXAConnection();        
0:         assertPooledConnIso("XAConnection", xpc1);                 
0:         xpc1.close();
1:     }
1: 
0:     /* -------------- Helper Methods for testDerby1144 -------------- */
1:     
1:     /**
0:      * Make sure autocommit gets reset on PooledConnection.getConnection()
0:      * @param desc      description of connection
0:      * @param pc1       pooled connection to test
1:      * @throws SQLException
1:      */
0:     private static void assertPooledConnAutoCommit(
0:         String desc, PooledConnection pc1) throws SQLException 
1:     {
0:         // ** Verify autoCommit state
0:         Connection conn  = pc1.getConnection();
0:         conn.setAutoCommit(true);
0:         // reset the connection and see if the autocommit has changed 
0:         conn = pc1.getConnection();
0:         boolean autocommit  = conn.getAutoCommit();
0:         // autocommit should get reset on getConnection
0:         assertTrue(autocommit);
1:         conn.close();
1:     }
1: 
1: 
1:     /**
0:      * Checks that Holdability gets reset on PooledConnection.getConnection()
0:      * @param desc
0:      * @param pc1
1:      * @throws SQLException
1:      */
0:     private static void assertPooledConnHoldability(
0:         String desc, PooledConnection pc1) throws SQLException 
1:     { 
0:         // **Test holdability state
0:         Connection conn  = pc1.getConnection();
1:         conn.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);
0:         // reset the connection and see if the holdability gets reset
0:         // to HOLD_CURSORS_OVER_COMMIT
0:         conn = pc1.getConnection();
0:         assertConnHoldability(conn, ResultSet.HOLD_CURSORS_OVER_COMMIT);
1:         conn.close();
1:     }
1: 
1: 
1:     /**
0:      * Verify connection holdablity is expected holdability
0:      * @param conn
0:      * @param expectedHoldability 
0:      *   * @throws SQLException
1:      */
0:     private static void assertConnHoldability(
0:         Connection conn, int expectedHoldability) throws SQLException 
1:     {
0:         int holdability = conn.getHoldability();
0:         assertEquals (expectedHoldability, holdability);
1:     }
1: 
1:     /**
0:      * Test that isolation is reset on PooledConnection.getConnection()
0:      * @param pooledConnType   Descripiton of the type of pooled connection
0:      * @param pc               PooledConnection or XAConnection  
1:      * @throws SQLException
1:      */
0:     private void assertPooledConnIso(
0:         String pooledConnType, PooledConnection pc) throws SQLException {
0:         Connection conn = pc.getConnection();
1: 
0:         setupDerby1144Table(conn);
1: 
0:         // *** Test isolation level reset on conntype.getConnection()          
0:         conn.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);
0:         assertIsoLocks(conn, Connection.TRANSACTION_READ_UNCOMMITTED);
1: 
1:         conn.close();
0:         //Get a new connection with pooledConnType.getConnection()
0:         // Isolation level should be reset to READ_COMMITTED
0:         Connection newconn = pc.getConnection();
0:         assertIsoLocks(newconn, Connection.TRANSACTION_READ_COMMITTED);
1:     }
1: 
1:     /*
0:      * insert two rows into the simple table for DERBY-1144 tests
0:      * @param conn
1:      * @throws SQLException
1:      */
0:     private static void  setupDerby1144Table(Connection conn) 
1:     throws SQLException {
0:         Statement stmt = conn.createStatement();
0:         stmt.executeUpdate("INSERT INTO intTable VALUES(1)");
0:         stmt.executeUpdate("INSERT INTO intTable VALUES(2)");
1: 
0:         conn.commit ();
1:     }
1:     
1:     /* 
0:      * Checks locks for designated isolation level on the connection.
0:      * Currently only supports TRANSACTION_READ_COMMITTED and 
0:      * TRANSACTION_READ_UNCOMMITTED
0:      * @param conn   Connection to test
0:      * @param isoLevel expected isolation level
1:      *
1:      */
0:     private void assertIsoLocks(Connection conn, int expectedIsoLevel)
1:     throws SQLException {
0:         int conniso = conn.getTransactionIsolation();
0:         assertEquals(expectedIsoLevel, conniso);
1: 
0:         boolean selectTimedOut = selectTimesoutDuringUpdate(conn);
0:         // expect a lock timeout for READ_COMMITTED
0:         switch (conniso) {
0:             case Connection.TRANSACTION_READ_UNCOMMITTED:
0:                 assertFalse(selectTimedOut); break;
0:             case Connection.TRANSACTION_READ_COMMITTED:
0:                 assertTrue(selectTimedOut); break;
0:             default:
0:                 System.out.println("No test support for isolation level");
1:         }
1:     }
1:     
1:     /*
0:      * Determine if a select on this connection during update will timeout.
0:      * Used to establish isolation level.  If the connection isolation level
0:      * is <code> Connection.TRANSACTION_READ_UNCOMMITTED </code> it will not
0:      * timeout.  Otherwise it should.  
1:      * 
0:      * @param conn   Connection to test.
0:      * @return  true if the select got a lock timeout, false otherwise.
1:      */
0:     private boolean selectTimesoutDuringUpdate(Connection conn) 
1:     throws SQLException {
1: 
0:         Connection updateConn=null;
0:         conn.setAutoCommit(false);
1: 
1:         try {
0:             // create another connection and do an update but don't commit
0:             updateConn = openDefaultConnection();
0:             updateConn.setAutoCommit(false);
1: 
0:             // First update the rows on the update connection
0:             Statement upStmt = updateConn.createStatement();
0:             upStmt.executeUpdate("update intTable set i = 3");
1: 
0:             // now see if we can select them
0:             Statement stmt = conn.createStatement();
0:             ResultSet rs = stmt.executeQuery("Select * from intTable");
0:             while (rs.next()){};
1:             rs.close();
1:         }
1:         catch (SQLException e)
1:         {
0:             if (e.getSQLState().equals("40XL1"))
1:             {
0:                 // If we got a lock timeout this is not read uncommitted
0:                 return true;
1:             }   
1:         }
0:         finally {
1:             try {
0:                 conn.rollback();
0:                 updateConn.rollback();
0:             }catch (SQLException  se) {
0:                 se.printStackTrace();
1:             }
1:         }
0:         return false;
1:     }
1:     
0:     /* -------------------- Other Helper Methods -------------------- */
1:     
0:     private void assertConnectionState(
0:         int expectedHoldability, int expectedIsolation,
0:         boolean expectedCommitSetting, boolean expectedReadOnly, 
0:         Connection conn) throws SQLException 
1:     {
0:         assertEquals(expectedHoldability, conn.getHoldability());
0:         assertEquals(expectedIsolation, conn.getTransactionIsolation());
0:         assertEquals(expectedCommitSetting, conn.getAutoCommit());
0:         assertEquals(expectedReadOnly, conn.isReadOnly());
1:     }
1: 
1:     private static void setDatabaseProperty(String property, String value) 
1:     throws SQLException
1:     {
1:         DataSource ds = JDBCDataSource.getDataSource();
0:         JDBCDataSource.setBeanProperty(ds, "databaseName", dbName);
1:         Connection cadmin = ds.getConnection();
1:         CallableStatement cs = cadmin.prepareCall(
1:             "CALL SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(?, ?)");
1:         cs.setString(1, property);
1:         cs.setString(2, value);
1:         cs.execute();
1: 
0:         JDBCDataSource.setBeanProperty(ds, "databaseName", dbName);
1:         
1:         cs.close();
1:         cadmin.close();
1:     }
1:     
0:     private void setHoldability(Connection conn, boolean hold) throws SQLException {
1: 
0:         conn.setHoldability(hold ? ResultSet.HOLD_CURSORS_OVER_COMMIT : ResultSet.CLOSE_CURSORS_AT_COMMIT);
1:     }
1:     
1:     private static void dsConnectionRequests(
1:         String[] expectedValues, DataSource ds) {
1: 
1:         // checks currently only implemented for embedded 
1:         if (usingEmbedded())
1:         {
1:             SecurityCheck.assertSourceSecurity(ds, "javax.sql.DataSource");
1:         }
1:         
1:         try {
1:             ds.getConnection();
1:             if (!expectedValues[0].equals("OK"))
1:                 fail (" expected connection to fail, but was OK");
1:         } catch (SQLException sqle) {
1:             assertSQLState(expectedValues[0], sqle);
1:         }
1:         dsConnectionRequest(expectedValues[1], ds, null, null);
1:         dsConnectionRequest(expectedValues[2], ds, "fred", null);
1:         dsConnectionRequest(expectedValues[3], ds, "fred", "wilma");
1:         dsConnectionRequest(expectedValues[4], ds, null, "wilma");
1:         dsConnectionRequest(
1:             expectedValues[5], ds, null, "databaseName=wombat");
1:         dsConnectionRequest(
1:             expectedValues[6], ds, "fred", "databaseName=wombat");
1:         dsConnectionRequest(expectedValues[7], 
1:             ds, "fred", "databaseName=wombat;password=wilma");
1:         dsConnectionRequest(expectedValues[8], 
1:             ds, "fred", "databaseName=wombat;password=betty");
1:     }
1: 
1:     private static void dsConnectionRequest(
1:         String expectedValue, DataSource ds, String user, String ConnAttr)
1:     {
1:         try {
1:             ds.getConnection(user, ConnAttr);
1:             if (!expectedValue.equals("OK"))
1:                 fail (" expected connection to fail, but was OK");
1:         } catch (SQLException sqle) {
1:             assertSQLState(expectedValue, sqle);
1:         }
1:     }
1:     
1:     private static void dsConnectionRequests(
0:         String[] expectedValues, ConnectionPoolDataSource ds) {
1:         try {
0:             ds.getPooledConnection();
1:             if (!expectedValues[0].equals("OK"))
1:                 fail (" expected connection to fail, but was OK");
1:         } catch (SQLException sqle) {
1:             assertSQLState(expectedValues[0], sqle);
1:         }
1: 
1:         dsConnectionRequest(expectedValues[1], ds, null, null);
1:         dsConnectionRequest(expectedValues[2], ds, "fred", null);
1:         dsConnectionRequest(expectedValues[3], ds, "fred", "wilma");
1:         dsConnectionRequest(expectedValues[4], ds, null, "wilma");
1:         dsConnectionRequest(
1:             expectedValues[5], ds, null, "databaseName=wombat");
1:         dsConnectionRequest(
1:             expectedValues[6], ds, "fred", "databaseName=wombat");
1:         dsConnectionRequest(expectedValues[7], 
1:             ds, "fred", "databaseName=wombat;password=wilma");
1:         dsConnectionRequest(expectedValues[8], 
1:             ds, "fred", "databaseName=wombat;password=betty");
1:     }
1:     
0:     private static void dsConnectionRequest(String expectedValue, 
0:         ConnectionPoolDataSource ds, String user, String ConnAttr)
1:     {
1:         try {
0:             ds.getPooledConnection(user, ConnAttr);
1:             if (!expectedValue.equals("OK"))
1:                 fail (" expected connection to fail, but was OK");
1:         } catch (SQLException sqle) {
1:             assertSQLState(expectedValue, sqle);
1:         }
1:     }
1:         
1:     private static void dsConnectionRequests(
0:         String[] expectedValues, XADataSource ds) {
1:         try {
0:             ds.getXAConnection();
1:             if (!expectedValues[0].equals("OK"))
1:                 fail (" expected connection to fail, but was OK");
1:         } catch (SQLException sqle) {
1:             assertSQLState(expectedValues[0], sqle);
1:         }
1: 
1:         dsConnectionRequest(expectedValues[1], ds, null, null);
1:         dsConnectionRequest(expectedValues[2], ds, "fred", null);
1:         dsConnectionRequest(expectedValues[3], ds, "fred", "wilma");
1:         dsConnectionRequest(expectedValues[4], ds, null, "wilma");
1:         dsConnectionRequest(
0:             expectedValues[5], ds, null, "databaseName=" + dbName);
1:         dsConnectionRequest(
0:             expectedValues[6], ds, "fred", "databaseName=" + dbName);
1:         dsConnectionRequest(expectedValues[7], 
0:             ds, "fred", "databaseName=" + dbName + ";password=wilma");
1:         dsConnectionRequest(expectedValues[8], 
0:             ds, "fred", "databaseName=" + dbName + ";password=betty");
1:     }
1:     
0:     private static void dsConnectionRequest(String expectedValue, 
0:             XADataSource ds, String user, String ConnAttr)
1:     {
1:         try {
0:             ds.getXAConnection(user, ConnAttr);
1:             if (!expectedValue.equals("OK"))
1:                 fail (" expected connection to fail, but was OK");
1:         } catch (SQLException sqle) {
1:             assertSQLState(expectedValue, sqle);
1:         }
1:     }
1: 
0:     protected void assertXAException(String tag, XAException xae) {
1: 
0:         // for all our cases, we expect some kind of closed con error
0:         // but the message is different for embedded vs. network server
1:         if (usingEmbedded())
0:             assertEquals("No current connection.", xae.getMessage());
0:         else if (usingDerbyNetClient())
1:             assertEquals(
0:                 "XAER_RMFAIL : No current connection.", xae.getMessage());
0:         Throwable t = xae.getCause();
0:         if (t instanceof SQLException)
0:             assertSQLState("08003", (SQLException)t);
1:     }
1: 
0:     private static void queryOnStatement(String expectedCursorName,
0:         int[] expectedValues, Connection conn, Statement s) 
1:     throws SQLException {
1: 
1:         try {
0:             // TODO: is this a bug?
0:             // network server gives mismatched connections. See also
0:             // comment in testAllDataSources()
1:             if (usingEmbedded())
0:                 assertEquals(conn, s.getConnection());
0:             resultSetQuery(expectedCursorName, expectedValues,
0:                 s.executeQuery("select * from intTable"));
1:         } catch (SQLException sqle) {
0:             fail (" did not expect sql exception");
1:         }
1:     }
1: 
0:     private static void resultSetQuery(String expectedCursorName, 
0:         int[] expectedValues, ResultSet rs) throws SQLException 
1:     {
1:         // checks currently only implemented for embedded 
1:         if (usingEmbedded())
1:         {
0:             SecurityCheck.assertSourceSecurity(rs, "java.sql.ResultSet");
1:         }
0:         assertEquals(expectedCursorName, rs.getCursorName());
0:         int index=0;
0:         while (rs.next()) {
0:             assertEquals(expectedValues[index], rs.getInt(1));
0:             index++;
1:         }
0:         assertEquals(expectedValues.length, index++);
1:         rs.close();
1:     }
1: 
0:     private static void assertLocks(int[] expectedValues, Connection conn) 
1:     throws SQLException {
0:         Statement s = conn.createStatement();
0:         ResultSet rs = s.executeQuery(
0:             "SELECT XID, sum(cast (LOCKCOUNT AS INT)) " +
0:             "FROM SYSCS_DIAG.LOCK_TABLE AS L GROUP BY XID");
1: 
0:         // Don't output actual XID's as they tend for every catalog change
0:         // to the system.
0:         int xact_index = 0;
0:         while (rs.next()) {
0:             if (expectedValues != null)
0:                 assertEquals(expectedValues[xact_index], rs.getInt(2));
1:             else 
0:                 fail("expected no locks");
0:             xact_index++;
1:         }
0:         if (expectedValues != null)
0:             assertEquals(expectedValues.length, xact_index);
1:         
1:         rs.close();
1:         s.close();
1:     }
1: 
0:     private void assertStatementState(int[] parameterExpectedValues, 
0:         int[] expectedValues, Statement s) 
1:     throws SQLException {
0:         assertEquals(expectedValues[0], s.getResultSetType());
1:         assertEquals(
0:             expectedValues[1], s.getResultSetConcurrency());
1:         assertEquals(
0:             expectedValues[2], s.getFetchDirection());
0:         assertEquals(expectedValues[3], s.getFetchSize());
0:         assertEquals(expectedValues[4], s.getMaxFieldSize());
0:         assertEquals(expectedValues[5], s.getMaxRows());
0:         assertEquals(expectedValues[6], s.getResultSetHoldability());
1: 
0:         if (s instanceof PreparedStatement) {
0:             PreparedStatement ps = (PreparedStatement) s;
0:             ParameterMetaData psmd = ps.getParameterMetaData();
0:             // Parameter count:
0:             assertEquals(parameterExpectedValues[0], psmd.getParameterCount());
0:             for (int i = 1; i <= psmd.getParameterCount(); i++) {
0:                 assertEquals(parameterExpectedValues[i], psmd.getParameterType(i));
1:             }
1:         }
1:     }
1: 
1:     /**
0:     Create a statement with modified State.
1:      */
0:     private Statement createFloatStatementForStateChecking(
0:         int[] StatementExpectedValues, Connection conn)
1:     throws SQLException {
0:         Statement s = internalCreateFloatStatementForStateChecking(conn);
0:         s.setCursorName("StokeNewington");
0:         s.setFetchDirection(ResultSet.FETCH_REVERSE);
0:         s.setFetchSize(444);
0:         s.setMaxFieldSize(713);
0:         s.setMaxRows(19);
1: 
0:         // Create
0:         assertStatementState(null, StatementExpectedValues, s);
0:         return s;
1:     }
1: 
0:     private Statement internalCreateFloatStatementForStateChecking(
0:         Connection conn) throws SQLException {
0:         return conn.createStatement(
0:             ResultSet.TYPE_SCROLL_INSENSITIVE, 
0:             ResultSet.CONCUR_READ_ONLY, 
0:             ResultSet.HOLD_CURSORS_OVER_COMMIT);
1:     }
1: 
0:     private PreparedStatement createFloatStatementForStateChecking(
0:         int[] parameterExpectedValues, int[] PreparedStatementExpectedValues,
0:         Connection conn, String sql) 
1:     throws SQLException {
0:         PreparedStatement s = 
0:             internalCreateFloatStatementForStateChecking(conn, sql);
0:         s.setCursorName("StokeNewington");
0:         s.setFetchDirection(ResultSet.FETCH_REVERSE);
0:         s.setFetchSize(888);
0:         s.setMaxFieldSize(317);
0:         s.setMaxRows(91);
1: 
0:         // PreparedStatement Create        
0:         assertStatementState(
0:             parameterExpectedValues, PreparedStatementExpectedValues, s);
0:         return s;
1:     }
1:     
0:     private PreparedStatement internalCreateFloatStatementForStateChecking(
0:         Connection conn, String sql) throws SQLException {
0:         return conn.prepareStatement(sql, 
0:             ResultSet.TYPE_SCROLL_INSENSITIVE, 
0:             ResultSet.CONCUR_READ_ONLY, 
0:             ResultSet.HOLD_CURSORS_OVER_COMMIT);
1:     }
1: 
0:     private CallableStatement createFloatCallForStateChecking(
0:         int[] parameterExpectedValues, int[] CallableStatementExpectedValues,
0:         Connection conn, String sql) 
1:     throws SQLException 
1:     {
0:         CallableStatement s = 
0:             internalCreateFloatCallForStateChecking(conn, sql);
0:         s.setCursorName("StokeNewington");
0:         s.setFetchDirection(ResultSet.FETCH_REVERSE);
0:         s.setFetchSize(999);
0:         s.setMaxFieldSize(137);
0:         s.setMaxRows(85);
1: 
0:         // Callable Statement Create
0:         assertStatementState(
0:             parameterExpectedValues, CallableStatementExpectedValues, s);
0:         return s;
1:     }
1:     
0:     private CallableStatement internalCreateFloatCallForStateChecking(
0:         Connection conn, String sql) throws SQLException {
0:         return conn.prepareCall(sql, 
0:             ResultSet.TYPE_SCROLL_INSENSITIVE, 
0:             ResultSet.CONCUR_READ_ONLY, 
0:             ResultSet.HOLD_CURSORS_OVER_COMMIT);
1:     }
1: 
1:     private void assertConnectionOK(
1:         Object[] expectedValues, String dsName, Connection conn) 
1:     throws SQLException { 
1:         
1:         assertEquals(
1:             ((Integer)expectedValues[0]).intValue(), conn.getHoldability());
1: 
1:         // check it's a 3.0 connection object by checking if 
1:         // set & release Savepoint is ok.
1:         try {
1:             conn.releaseSavepoint(conn.setSavepoint());
1:             if (conn.getAutoCommit())
1:                 fail("expected a SQLExpection (savepoint with autocommit on");
1:             if (!((String)expectedValues[1]).equals("OK"))
1:                 fail("expected a SQLExpection (savepoint with autocommit on");
1:         } catch (SQLException sqle) {
1:             // we expect savepoints exceptions because either
1:             // it's a global transaction, or it's in auto commit mode.
1:             if (conn.getAutoCommit())
1:                 assertSQLState("XJ010", sqle);
1:             else if (((String)expectedValues[1]).equals("OK"))
1:                 fail ("unexpected JDBC 3.0 savepoint SQL Exception");
1:             else 
1:                 assertSQLState((String)expectedValues[1], sqle);
1:         }
1: 
1:         // Running connection checks
1:         // connection checks currently only implemented for Embedded
1:         if (usingEmbedded())
1:         {
1:             SecurityCheck.assertSourceSecurity(conn, "java.sql.Connection");
1:             SecurityCheck.assertSourceSecurity(
1:                 conn.getMetaData(), "java.sql.DatabaseMetaData");
1:         }
1: 
1:         assertEquals(((Integer)expectedValues[2]).intValue(), 
1:             conn.getTransactionIsolation());
1:         assertEquals(((Boolean)expectedValues[3]).booleanValue(), 
1:             conn.getAutoCommit());
1:         assertEquals(((Boolean)expectedValues[4]).booleanValue(), 
1:             conn.isReadOnly());
1: 
0:         if (dsName.endsWith("DataSource"))
0:             assertNull(conn.getWarnings());
1: 
1:         Statement s1 = conn.createStatement();
1:         assertStatementOK(dsName, conn, s1);
1:         assertStatementOK(dsName, conn, conn.createStatement
1:             (ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY));
1: 
1:         Connection c1 = conn.getMetaData().getConnection();
1:         // c1 and conn should be the same connection object.
1:         if (!usingDerbyNetClient() && dsName.indexOf("DataSource")>=0)
1:             assertEquals(c1, conn);
1: 
0:         // Derby-33 - setTypeMap on connection
1:         try {
0:             conn.setTypeMap(java.util.Collections.EMPTY_MAP);
0:             if (!((String)expectedValues[5]).equals("OK"))
0:                 fail (" expected an sqlexception on setTypeMap(EMPTY_MAP)");
1:         } catch (SQLException sqle) {
0:             if (((String)expectedValues[5]).equals("OK"))
0:                 fail ("setTypeMap(EMPTY_MAP) failed ");
1:             else
0:                 assertSQLState((String)expectedValues[5], sqle);
1:         }
1:         try {
0:             // expect 0A000 - not implemented for client,
0:             //        XJ081 - invalid null value passed as map for embedded
0:             conn.setTypeMap(null);
0:             fail ("setTypeMap(null) should throw exception");
1:         } catch (SQLException sqle) {
0:             assertSQLState((String)expectedValues[6], sqle);
1:         }
1:         try {
0:             // a populated map, not implemented
0:             java.util.Map map = new java.util.HashMap();
0:             map.put("name", "class");
0:             conn.setTypeMap(map);
0:             if (!((String)expectedValues[7]).equals("OK"))
0:                 fail (" expected an sqlexception on setTypeMap(map)");
1:         } catch (SQLException sqle) {
0:             if (((String)expectedValues[7]).equals("OK"))
0:                 fail ("setTypeMap(valid value) failed ");
1:             else
0:                 assertSQLState((String)expectedValues[7], sqle);
1:         }
1: 
1:         assertConnectionPreClose(dsName, conn);
1:         conn.close();
1: 
1:         // method calls on a closed connection
1:         try {
1:             conn.close(); // expect no error
1:         } catch (SQLException sqle) {
1:             fail(" unexpected exception on <closedconn>.close() ");
1:         }
1:         try {
1:             conn.createStatement();
1:             fail (dsName + " <closedconn>.createStatement(), " +
1:                 "expected 08003 - No current connection");
1:         } catch (SQLException sqle) {
1:             assertSQLState("08003", sqle);
1:         }
1:         try {
1:             s1.execute("values 1");
1:             fail(dsName + " <closedstmt>.execute(), " +
1:                 "expected 08003 - No current connection");
1:         } catch (SQLException sqle) {
1:             assertSQLState("08003", sqle);
1:         }
1:     }
1: 
1:     private void assertConnectionPreClose(String dsName, Connection conn) 
1:     throws SQLException {
1: 
1:         // before closing the connection, attempt to change holdability
1:         // and readOnly
1:         conn.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);
1: 
1:         if (!dsName.equals("Nested2"))
1:         {
1:             try {
1:                 conn.setReadOnly(true);
1:             } catch (SQLException sqle) {
1:                 // cannot set read-only in an active transaction, & sometimes
1:                 // connections are active at this point.
1:                 assertSQLState("25501", sqle);
1:             }
1:         }
1:     }
1:     
1:     private void assertStatementOK(String dsName, Connection conn, Statement s)
1:     throws SQLException {
1: 
1:         // checks currently only implemented for embedded 
1:         if (usingEmbedded())
1:         {
1:             SecurityCheck.assertSourceSecurity(s, "java.sql.Statement");
1:         }
1: 
1:         Connection c1 = s.getConnection();
1:         if (c1 != conn)
1:         {
1:             // with DerbyNetClient and any kind of DataSource, this goes wrong
1:             if (!usingDerbyNetClient() && (dsName.indexOf("DataSource") >= 0))
1:                 fail ("incorrect connection object returned for Statement.getConnection()");
1:         }
1: 
1:         s.addBatch("insert into intTable values 1");
1:         s.addBatch("insert into intTable values 2,3");
1:         int[] states = s.executeBatch();
1:         if (states[0] != 1)
1:             fail ("invalid update count for first batch statement");
1:         if (states[1] != 2)
1:             fail ("invalid update count for second batch statement");
1: 
1:         ResultSet rs = s.executeQuery("VALUES 1");
1:         if (rs.getStatement() != s)
1:             fail ("incorrect Statement object returned for ResultSet.getStatement for " + dsName);
1:         rs.close();
1:         s.close();
1:     }
1: 
1:     /**
0:     When a connection is being pooled, the underlying JDBC embedded
0:     connection object is re-used. As each application gets a new
0:     Connection object, that is really a wrapper around the old connection
0:     it should reset any connection spoecific state on the embedded connection
0:     object.
1:      */
0:     private static void PoolReset(String type, PooledConnection pc) throws SQLException
1:     {
0:         PoolResetWork("1", "C", pc.getConnection());
0:         PoolResetWork("2", "", pc.getConnection());
0:         PoolResetWork("3", "D", pc.getConnection());
1: 
0:         pc.close();
1:     }
1: 
0:     private static void PoolResetWork(
0:         String expectedID, String tableAction, Connection conn) 
1:     throws SQLException
1:     {
0:         Statement s = conn.createStatement();
0:         if (tableAction.equals("C"))
1:         {
0:             s.execute("CREATE TABLE PoolResetWork (id int generated always as identity, name varchar(25))");
1:         }
1: 
0:         ResultSet rs = s.executeQuery("VALUES IDENTITY_VAL_LOCAL()");
0:         rs.next();
0:         String val = rs.getString(1);
0:         if (!rs.wasNull() || (val != null))
0:             fail ("initial call to IDENTITY_VAL_LOCAL is not NULL!" + val);
1:         rs.close();
1: 
0:         s.executeUpdate("INSERT INTO PoolResetWork(name) values ('derby-222')");
1: 
0:         rs = s.executeQuery("VALUES IDENTITY_VAL_LOCAL()");
0:         rs.next();
0:         val = rs.getString(1);
0:         assertEquals(expectedID, val);
1:         rs.close();
1: 
0:         if (tableAction.equals("D"))
1:         {
0:             s.execute("DROP TABLE PoolResetWork");
1:         }
1: 
1:         s.close();
1:         conn.close();
1:     }
1: 
1:     /**
1:      * Make sure this connection's string is unique (DERBY-243)
1:      */
1:     private static void assertToString(Connection conn) throws Exception
1:     {
1:         assertStringFormat(conn);
1:         String str = conn.toString();
1: 
1:         if ( conns.containsKey(str))
1:         {
1:             throw new Exception("ERROR: Connection toString() is not unique: " 
1:                     + str);
1:         }
1:         conns.put(str, conn);
1:     }
1: 
1:     /** 
0:      * Check the format of a pooled connection
0:      **/
0:     private static void assertStringFormat(PooledConnection pc) throws Exception
1:     {
0:         String prefix = assertStringPrefix(pc);
0:         String connstr = pc.toString();
0:         String format = "/" + prefix + 
0:         " \\(ID = [0-9]+\\), Physical Connection = " +
0:         "<none>|" + CONNSTRING_FORMAT + "/";
1:         
0:         // TODO: figure out: add jakarta-oro2.0.8 so this can build & run,
0:         // or needed to put some other matching code in? 
1: /*
0:         if ( ! p5u.match(format, connstr) )
1:         {
0:             throw new Exception( "Connection.toString() (" + connstr + ") " +
0:                     "does not match expected format (" + format + ")");
1:         }
1: */        
1:     }
1: 
1:     /**
1:      * Check the format of the connection string.  This is the default test
1:      * to run if this is not a BrokeredConnection class
1:      */
0:     private static void assertStringFormat(Connection conn) throws Exception
1:     {
0:         // TODO: figure out: add jakarta-oro2.0.8 so this can build & run,
0:         // or needed to put some other matching code in? 
0:         String prefix = assertStringPrefix(conn);
1: 
1:         String str = conn.toString();        
1: 
1: /*        
0:         // See if the connection string matches the format pattern    
0:         if ( ! p5u.match("/" + CONNSTRING_FORMAT + "/", str) )
1:         {
0:             throw new Exception( "Connection.toString() (" + str + ") " +
0:                     "does not match expected format (" + CONNSTRING_FORMAT + ")");
1:         }
1: */        
1:     }
1: 
1:     /**
1:      * Make sure the connection string starts with the right prefix, which
1:      * is the classname@hashcode.
1:      *
1:      * @return the expected prefix string, this is used in further string
1:      *   format checking
1:      */
0:     private static String assertStringPrefix(Object conn) throws Exception
1:     {
1:         String connstr = conn.toString();
1:         String prefix = conn.getClass().getName() + "@" + conn.hashCode();
1:         // Connection class and has code for connection string should
1:         // match prefix
1:         assertTrue(connstr.startsWith(prefix));
1: 
1:         return prefix;
1:     }
1: 
1:     /**
1:      * Check uniqueness of connection strings coming from a
1:      * DataSouce
1:      */
1:     private static void assertToString(DataSource ds) throws Exception
1:     {
1:         clearConnections();
1: 
1:         int numConnections = 10;
1:         for ( int i = 0 ; i < numConnections ; i++ )
1:         {
1:             Connection conn = ds.getConnection();
1:             assertToString(conn);
1:         }
1: 
1:         clearConnections();
1:     }
1: 
1:     /**
1:      * Clear out and close connections in the connections
1:      * hashtable. 
1:      */
1:     private static void clearConnections() throws SQLException
1:     {
0:         java.util.Iterator it = conns.values().iterator();
0:         while ( it.hasNext() )
1:         {
0:             Connection conn = (Connection)it.next();
1:             conn.close();
1:         }
1:         conns.clear();
1:     }
1: 
1:     /**
1:      * Get connections  using getConnection() and make sure
1:      * they're unique
1:      */
1:     private void assertTenConnectionsUnique() throws Exception
1:     {
1:         clearConnections();
1:         // Open ten connections rather than just two to
1:         // try and catch any odd uniqueness bugs.  Still
1:         // no guarantee but is better than just two.
1:         int numConnections = 10;
1:         for ( int i = 0 ; i < numConnections ; i++ )
1:         {
1:             Connection conn = openDefaultConnection();
1:             assertToString(conn);
1:         }
1: 
1:         // Now close the connections
1:         clearConnections();
1:     }
1: 
1:     /**
0:      * Check uniqueness of strings for an XA data source
1:      */
0:     private static void assertToString(XADataSource xds) throws Exception
1:     {
1:         int numConnections = 10;
1: 
0:         //  First get a bunch of pooled connections
0:         //  and make sure they're all unique
0:         Hashtable xaConns = new Hashtable();
1:         for ( int i = 0 ; i < numConnections ; i++ )
1:         {
0:             XAConnection xc = xds.getXAConnection();
0:             assertStringFormat(xc);
0:             String str = xc.toString();
0:             // XA connection toString should be unique
0:             assertNull(xaConns.get(str));
0:             xaConns.put(str, xc);
1:         }
1: 
0:         // Now check that connections from each of these
0:         // pooled connections have different string values
0:         Iterator it = xaConns.values().iterator();
1:         clearConnections();
0:         while ( it.hasNext() )
1:         {
0:             XAConnection xc = (XAConnection)it.next();
0:             Connection conn = xc.getConnection();
1:             assertToString(conn);
1:         }
1:         clearConnections();
1: 
0:         // Now clear out the pooled connections
0:         it = xaConns.values().iterator();
0:         while ( it.hasNext() )
1:         {
0:             XAConnection xc = (XAConnection)it.next();
0:             xc.close();
1:         }
0:         xaConns.clear();
1:     }
1: 
1:     /**
0:      * Check uniqueness of strings with a pooled data source.
0:      * We want to check the PooledConnection as well as the
0:      * underlying physical connection. 
1:      */
0:     private static void assertToString(ConnectionPoolDataSource pds)
0:     throws Exception
1:     {
1:         int numConnections = 10;
1: 
0:         //  First get a bunch of pooled connections
0:         //  and make sure they're all unique
0:         Hashtable pooledConns = new Hashtable();
1:         for ( int i = 0 ; i < numConnections ; i++ )
1:         {
0:             PooledConnection pc = pds.getPooledConnection();
0:             assertStringFormat(pc);
0:             String str = pc.toString();
0:             // Pooled connection toString should be unique
0:             assertNull( pooledConns.get(str));
0:             pooledConns.put(str, pc);
1:         }
1: 
0:         // Now check that connections from each of these
0:         // pooled connections have different string values
0:         Iterator it = pooledConns.values().iterator();
1:         clearConnections();
0:         while ( it.hasNext() )
1:         {
0:             PooledConnection pc = (PooledConnection)it.next();
0:             Connection conn = pc.getConnection();
1:             assertToString(conn);
1:         }
1:         clearConnections();
1: 
0:         // Now clear out the pooled connections
0:         it = pooledConns.values().iterator();
0:         while ( it.hasNext() )
1:         {
0:             PooledConnection pc = (PooledConnection)it.next();
0:             pc.close();
1:         }
0:         pooledConns.clear();
1:     }
1: 
1:     /**
0:      * Return the Java class and method for the procedure
0:      * for the nested connection test.
0:      * checkDataSource 30 will override.
1:      */
0:     private String getNestedMethodName()
1:     {
0:         return "DataSourceTest.checkNesConn";
1:     }
1: 
0:     // calling checkConnection 
0:     // - for use in a procedure to get a nested connection.
0:     public static void checkNesConn (String dsName) throws SQLException {
0:         Connection conn = DriverManager.getConnection("jdbc:default:connection");
0:         String EmptyMapValue=null;
0:         // Note: currently, not supported
0:         String NullMapValue=null;
0:         String MapMapValue=null;
1:         if (usingEmbedded())
1:         {
0:             EmptyMapValue="OK"; NullMapValue="XJ081"; MapMapValue="0A000";
1:         }
0:         else if (usingDerbyNetClient())
1:         {
0:             EmptyMapValue="0A000"; NullMapValue="0A000"; MapMapValue="0A000";
1:         }
1:         Object[] expectedValues = { 
0:             new Integer(ResultSet.HOLD_CURSORS_OVER_COMMIT), "OK",
0:             new Integer(2), new Boolean(false), new Boolean(false), 
0:             EmptyMapValue, NullMapValue, MapMapValue};
1: 
0:         new DataSourceTest("DataSourceTest").assertConnectionOK(
0:             expectedValues, dsName, conn);
1:     }
1: }
1: 
0: class cdsXid implements Xid, Serializable
1: {
0:   private static final long serialVersionUID = 64467338100036L;
1: 
0:     private final int format_id;
0:     private byte[] global_id;
0:     private byte[] branch_id;
1: 
1: 
0:     cdsXid(int xid, byte b1, byte b2)
1:     {
0:         format_id = xid;
0:         global_id = new byte[Xid.MAXGTRIDSIZE];
0:         branch_id = new byte[Xid.MAXBQUALSIZE];
1: 
0:         for (int i = 0; i < global_id.length; i++) {
0:             global_id[i] = b1;
1:         }
1: 
0:         for (int i = 0; i < branch_id.length; i++) {
0:             branch_id[i] = b2;
1:         }
1:     }
1: 
1:     /**
0:      * Obtain the format id part of the Xid.
0:      * <p>
1:      *
0:      * @return Format identifier. O means the OSI CCR format.
0:      **/
0:     public int getFormatId()
1:     {
0:         return(format_id);
1:     }
1: 
1:     /**
0:      * Obtain the global transaction identifier part of XID as an array of 
0:      * bytes.
0:      * <p>
1:      *
0:      * @return A byte array containing the global transaction identifier.
0:      **/
0:     public byte[] getGlobalTransactionId()
1:     {
0:         return(global_id);
1:     }
1: 
1:     /**
0:      * Obtain the transaction branch qualifier part of the Xid in a byte array.
0:      * <p>
1:      *
0:      * @return A byte array containing the branch qualifier of the transaction.
0:      **/
0:     public byte[] getBranchQualifier()
1:     {
0:         return(branch_id);
1:     }
1: }
1: 
0: class AssertEventCatcher implements ConnectionEventListener
1: {
0:     private final int catcher;
1: 
0:     AssertEventCatcher(int which) {
0:         catcher=which;
1:     }
1: 
0:     // ConnectionEventListener methods
0:     public void connectionClosed(ConnectionEvent event)
1:     {
0:         // System.out.print("EVENT("+catcher+"):connectionClosed");
0:         SQLException sqle = event.getSQLException();
0:         if (sqle != null)
0:             System.out.print("DataSourceTest-" + catcher + "; SQLSTATE="
0:                 + sqle.getSQLState());
1:     }
1: 
0:     public void connectionErrorOccurred(ConnectionEvent event)
1:     {
0:         // System.out.print("EVENT("+catcher+"):connectionErrorOccurred");
0:         SQLException sqle = event.getSQLException();
0:         if (sqle != null)
0:             System.out.print("DataSourceTest-" + catcher + "; SQLSTATE=" +
0:                 sqle.getSQLState());
1:     }
1: }
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:2f817f3
/////////////////////////////////////////////////////////////////////////
0:         // DERBY-3401 - removing a callback during a close causes problems.
0:         //subtestPooledRemoveListenerOnClose(cpds.getPooledConnection());
0:         // DERBY-3401 - removing a callback during a close causes problems.
0:         //subtestPooledRemoveListenerOnClose(xads.getXAConnection());
/////////////////////////////////////////////////////////////////////////
0:     /**
0:      * Tests that a listener of a pooled connection can successfully
0:      * remove itself during the processing of its close event by its listener.
0:      */
0:     private void subtestPooledRemoveListenerOnClose(final PooledConnection pc) throws SQLException
0:     {
0:         
0:         final int[] count1 = new int[1];
0:         pc.addConnectionEventListener(new ConnectionEventListener() {
0: 
0:             /**
0:              * Mimic a pool handler that removes the listener during
0:              * a logical close.
0:              */
0:             public void connectionClosed(ConnectionEvent event) {
0:                 PooledConnection pce = (PooledConnection) event.getSource();
0:                 assertSame(pc, pce);
0:                 count1[0]++;
0:                 pce.removeConnectionEventListener(this);
0:             }
0: 
0:             public void connectionErrorOccurred(ConnectionEvent event) {
0:             }
0:             
0:         });
0:         
0:         // and have another listener to ensure removing one leaves
0:         // the other working and intact.
0:         final int[] count2 = new int[1];
0:         pc.addConnectionEventListener(new ConnectionEventListener() {
0: 
0:             /**
0:              * Mimic a pool handler that closes the PooledConnection
0:              * (say it no longer needs it, pool size being reduced)
0:              */
0:             public void connectionClosed(ConnectionEvent event) {             
0:                 PooledConnection pce = (PooledConnection) event.getSource();
0:                 assertSame(pc, pce);
0:                 count2[0]++;
0:             }
0: 
0:             public void connectionErrorOccurred(ConnectionEvent event) {
0:             }
0:             
0:         });        
0:         // no callback yet
0:         assertEquals(0, count1[0]);
0:         assertEquals(0, count2[0]);
0:         
0:         // Open and close a connection to invoke the logic above
0:         // through the callback
0:         pc.getConnection().close();
0:         
0:         // one callback for each
0:         assertEquals(1, count1[0]);
0:         assertEquals(1, count2[0]);
0:               
0:         // the callback (count1) that was removed is not called on the
0:         // second close but the second callback (count2) is called.
0:         pc.getConnection().close();
0:         assertEquals(1, count1[0]);
0:         assertEquals(2, count2[0]);
0:         
0:         pc.close();
0:     }
0: 
0:     
commit:e46ccc5
/////////////////////////////////////////////////////////////////////////
0:      * Test that a PooledConnection can be reused and closed
0:      * (separately) during the close event raised by the
0:      * closing of its logical connection.
0:         subtestPooledCloseOnClose(cpds.getPooledConnection());
0:         subtestPooledCloseOnClose(xads.getXAConnection());
/////////////////////////////////////////////////////////////////////////
0:     /**
0:      * Tests that a pooled connection can successfully be closed
0:      * during the processing of its close event by its listener.
0:      */
0:     private void subtestPooledCloseOnClose(final PooledConnection pc) throws SQLException
0:     {
0:         pc.addConnectionEventListener(new ConnectionEventListener() {
0: 
0:             /**
0:              * Mimic a pool handler that closes the PooledConnection
0:              * (say it no longer needs it, pool size being reduced)
0:              */
0:             public void connectionClosed(ConnectionEvent event) {
0:                 PooledConnection pce = (PooledConnection) event.getSource();
0:                 assertSame(pc, pce);
0:                 try {
0:                     pce.close();
0:                 } catch (SQLException e) {
0:                     // Need to catch the exception here because
0:                     // we cannot throw an exception through
0:                     // the api method.
0:                     fail(e.getMessage());
0:                 }
0:             }
0: 
0:             public void connectionErrorOccurred(ConnectionEvent event) {
0:             }
0:             
0:         });
0:         
0:         // Open and close a connection to invoke the logic above
0:         // through the callback
0:         pc.getConnection().close();
0:                 
0:         // The callback closed the actual pooled connection
0:         // so subsequent requests to get a logical connection
0:         // should fail.
0:         try {
0:             pc.getConnection();
0:             fail("PooledConnection should be closed");
0:         } catch (SQLException sqle) {
0:             assertSQLState("08003", sqle);
0:         }
0:     }
0:     
commit:fec3a1d
/////////////////////////////////////////////////////////////////////////
0:     /**
0:      * Test that a PooledConnection can be reused during the close
0:      * event raised by the closing of its logical connection.
0:      * DERBY-2142.
0:      * @throws SQLException 
0:      *
0:      */
0:     public void testPooledReuseOnClose() throws SQLException
0:     {
0:     	// TEMP - seems to fail on network client
0:     	if (!usingEmbedded())
0:     		return;
0:     	
0:     	// PooledConnection from a ConnectionPoolDataSource
0:     	ConnectionPoolDataSource cpds =
0:     		J2EEDataSource.getConnectionPoolDataSource();
0:     	subtestPooledReuseOnClose(cpds.getPooledConnection());
0: 
0:     	// PooledConnection from an XDataSource
0:     	XADataSource xads = J2EEDataSource.getXADataSource();
0:     	subtestPooledReuseOnClose(xads.getXAConnection());
0:     }
0:     
0:     /**
0:      * Tests that a pooled connection can successfully be reused
0:      * (a new connection obtained from it) during the processing
0:      * of its close event by its listener.
0:      * Sections 11.2 & 12.5 of JDBC 4 specification indicate that the
0:      * connection can be returned to the pool when the
0:      * ConnectionEventListener.connectionClosed() is called.
0:      */
0:     private void subtestPooledReuseOnClose(final PooledConnection pc) throws SQLException
0:     {
0:     	final Connection[] newConn = new Connection[1];
0:     	pc.addConnectionEventListener(new ConnectionEventListener() {
0: 
0:     		/**
0:     		 * Mimic a pool handler that returns the PooledConnection
0:     		 * to the pool and then reallocates it to a new logical connection.
0:     		 */
0: 			public void connectionClosed(ConnectionEvent event) {
0: 				PooledConnection pce = (PooledConnection) event.getSource();
0: 				assertSame(pc, pce);
0: 				try {
0: 					// open a new logical connection and pass
0: 					// back to the fixture.
0: 					newConn[0] = pce.getConnection();
0: 				} catch (SQLException e) {
0: 					// Need to catch the exception here because
0: 					// we cannot throw an exception through
0: 					// the api method.
0: 					fail(e.getMessage());
0: 				}
0: 			}
0: 
0: 			public void connectionErrorOccurred(ConnectionEvent event) {
0: 			}
0:     		
0:     	});
0:     	
0:     	// Open a connection then close it to trigger the
0:     	// fetching of a new connection in the callback.
0:     	Connection c1 = pc.getConnection();
0:     	c1.close();
0:     	
0:     	// Fetch the connection created in the close callback
0:     	Connection c2 = newConn[0];
0:     	assertNotNull(c2);
0:     	
0:     	// Ensure the connection is useable, this hit a NPE before DERBY-2142
0:     	// was fixed (for embedded).
0:     	c2.createStatement().close();
0:     	
0:     	pc.close();
0:     }
0:     
commit:1fd325f
/////////////////////////////////////////////////////////////////////////
0: 
0: import javax.sql.ConnectionEvent;
0: import javax.sql.ConnectionEventListener;
/////////////////////////////////////////////////////////////////////////
1:     private static final String dbName = 
/////////////////////////////////////////////////////////////////////////
1:         DataSource dscs = JDBCDataSource.getDataSource();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     public void testDSRequestAuthentication() throws SQLException {
/////////////////////////////////////////////////////////////////////////
0:         DataSource ds = JDBCDataSource.getDataSource();
1:         JDBCDataSource.setBeanProperty(ds, "connectionAttributes",
1:         		"traceFile="+traceFile);
0: 
1:         JDBCDataSource.clearStringBeanProperty(ds, "connectionAttributes");
0: 
1:         JDBCDataSource.setBeanProperty(ds, "traceFile", traceFile);
1:         ds = null;
0:         ConnectionPoolDataSource cpds = J2EEDataSource.getConnectionPoolDataSource();
0:         JDBCDataSource.setBeanProperty(cpds, "connectionAttributes",
1:         		"traceFile="+traceFile);
0:         ((ClientConnectionPoolDataSource) cpds).getConnection();
0:         JDBCDataSource.clearStringBeanProperty(cpds, "connectionAttributes");
0:         JDBCDataSource.setBeanProperty(cpds, "traceFile", traceFile);
0:         ((ClientConnectionPoolDataSource) cpds).getConnection();
0:         cpds = null;
0:         XADataSource xads = J2EEDataSource.getXADataSource();
0:         JDBCDataSource.setBeanProperty(xads, "connectionAttributes",
1:         		"traceFile="+traceFile);
0:         ((ClientXADataSource) xads).getConnection();
0:         JDBCDataSource.clearStringBeanProperty(xads, "connectionAttributes");
0:         JDBCDataSource.setBeanProperty(xads, "traceFile", traceFile);
0:         ((ClientXADataSource) xads).getConnection();
/////////////////////////////////////////////////////////////////////////
1:     public void testDescriptionProperty() 
1:         subTestDataSourceDescription(JDBCDataSource.getDataSource());
0:         subTestDataSourceDescription(
0:         		(DataSource) J2EEDataSource.getConnectionPoolDataSource());
0:         subTestDataSourceDescription(
0:         		(DataSource) J2EEDataSource.getXADataSource());
0: 
0:     }
0:     
0:     /**
1:      * Utility method for testing setting and fetching the description
1:      * property on a data source.
0:      */
1:     private void subTestDataSourceDescription(DataSource ds) throws Exception
0:     {
0:         String setDescription = 
0:             "Everything you ever wanted to know about this datasource";
0:         
1:         JDBCDataSource.setBeanProperty(ds, "description", setDescription);
0:         ds.getConnection();
1:         assertEquals(setDescription, JDBCDataSource.getBeanProperty(ds, "description"));
1:         JDBCDataSource.clearStringBeanProperty(ds, "description");
1:         assertNull(JDBCDataSource.getBeanProperty(ds, "description"));    	
commit:e5ddb68
/////////////////////////////////////////////////////////////////////////
0:         
0:         ConnectionPoolDataSource ds = J2EEDataSource.getConnectionPoolDataSource();
0: 
0:         PooledConnection pc = ds.getPooledConnection();
0:         Connection conn = pc.getConnection();
0:         Statement st = conn.createStatement();
0:         
0:         dropTable(conn, "TAB1");
0: 
/////////////////////////////////////////////////////////////////////////
0:             J2EEDataSource.getConnectionPoolDataSource();      
/////////////////////////////////////////////////////////////////////////
0:             J2EEDataSource.getConnectionPoolDataSource();       
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:836fc7b
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derbyTesting.functionTests.tests.jdbcapi.AssertEventCatcher;
/////////////////////////////////////////////////////////////////////////
commit:cb47a36
/////////////////////////////////////////////////////////////////////////
0: import java.sql.Savepoint;
/////////////////////////////////////////////////////////////////////////
0:     /**
0:      * Test case for DERBY-3172
0:      * When the Derby engine is shutdown or Network Server is brought down, any
0:      * api on JDBC Connection object should generate a Connection error event.
0:      */
0:     public void testConnectionErrorEvent() throws SQLException, Exception
0:     {
0:     	Connection conn;
0:     	ConnectionPoolDataSource ds;
0:     	PooledConnection pc;
0:     	Statement st;
0:         AssertEventCatcher aes12 = new AssertEventCatcher(12);
0:         //Get the correct ConnectionPoolDataSource object
0:         if (usingEmbedded())
0:         {
0:         	ds = new EmbeddedConnectionPoolDataSource();
0:             ((EmbeddedConnectionPoolDataSource)ds).setDatabaseName(dbName);
0:         } else
0:         {
0:             ds = new ClientConnectionPoolDataSource();
0:             ((ClientConnectionPoolDataSource)ds).setDatabaseName(dbName);
0:         }
0:         pc = ds.getPooledConnection();
0:         //Add a connection event listener to ConnectionPoolDataSource
0:         pc.addConnectionEventListener(aes12);
0:         conn = pc.getConnection();
0:         st = conn.createStatement();
0:         //TAB1 does not exist and hence catch the expected exception
0:         try {
0:             st.executeUpdate("drop table TAB1");
0:         } catch (SQLException sqle) {
0:             assertSQLState("42Y55", sqle);
0:         }
0:         //No event should have been generated at this point
0:         assertFalse(aes12.didConnectionClosedEventHappen());
0:         assertFalse(aes12.didConnectionErrorEventHappen());
0:         aes12.resetState();
0:         //Shutdown the Derby engine or Network Server depending on what 
0:         //mode we are running in.
0:         if (usingEmbedded())
0:         {
0:         	getTestConfiguration().shutdownDatabase();
0:         } else
0:         {
0:         	getTestConfiguration().stopNetworkServer();
0:         }
0:         //Now try to use various apis on the JDBC Connection object created 
0:         //before shutdown and they all should generate connection error event.
0:         try {
0:             conn.prepareStatement("CREATE TABLE TAB1(COL1 INT NOT NULL)");
0:         } catch (SQLException e) {
0:             //The first call on JDBC Connection object after Network Server
0:             //shutdown will generate a communication error and that's why we
0:             //are checking for SQL State 08006 rather than No current connection
0:             //SQL State 08003. In embedded mode, we will get SQL State 08003
0:         	//meaning No current connection
0:             if (usingEmbedded())
0:                 assertSQLState("08003", e);
0:             else
0:                 assertSQLState("08006", e);
0:         }
0:         assertFalse(aes12.didConnectionClosedEventHappen());
0:         assertTrue(aes12.didConnectionErrorEventHappen());
0:         aes12.resetState();
0:         try {
0:             conn.prepareStatement("CREATE TABLE TAB1(COL1 INT NOT NULL)", 1);
0:         } catch (SQLException e) {
0:             assertSQLState("08003", e);
0:         }
0:         assertFalse(aes12.didConnectionClosedEventHappen());
0:         assertTrue(aes12.didConnectionErrorEventHappen());
0:         aes12.resetState();
0:         try {
0:         	int[] columnIndexes = {1};
0:             conn.prepareStatement("CREATE TABLE TAB1(COL1 INT NOT NULL)", 
0:             		columnIndexes);
0:         } catch (SQLException e) {
0:             assertSQLState("08003", e);
0:         }
0:         assertFalse(aes12.didConnectionClosedEventHappen());
0:         assertTrue(aes12.didConnectionErrorEventHappen());
0:         aes12.resetState();
0:         try {
0:         	String[] columnNames = {"col1"};
0:             conn.prepareStatement("CREATE TABLE TAB1(COL1 INT NOT NULL)", 
0:             		columnNames);
0:         } catch (SQLException e) {
0:             assertSQLState("08003", e);
0:         }
0:         assertFalse(aes12.didConnectionClosedEventHappen());
0:         assertTrue(aes12.didConnectionErrorEventHappen());
0:         aes12.resetState();
0:         try {
0:             conn.prepareStatement("CREATE TABLE TAB1(COL1 INT NOT NULL)",
0:             		ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);
0:         } catch (SQLException e) {
0:                 assertSQLState("08003", e);
0:         }
0:         assertFalse(aes12.didConnectionClosedEventHappen());
0:         assertTrue(aes12.didConnectionErrorEventHappen());
0:         aes12.resetState();
0:         try {
0:             conn.prepareStatement("CREATE TABLE TAB1(COL1 INT NOT NULL)",
0:             		ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY,
0:             		ResultSet.CLOSE_CURSORS_AT_COMMIT);
0:         } catch (SQLException e) {
0:                 assertSQLState("08003", e);
0:         }
0:         assertFalse(aes12.didConnectionClosedEventHappen());
0:         assertTrue(aes12.didConnectionErrorEventHappen());
0:         aes12.resetState();
0:         try {
0:             conn.createStatement();
0:         } catch (SQLException e) {
0:             assertSQLState("08003", e);
0:         }
0:         assertFalse(aes12.didConnectionClosedEventHappen());
0:         assertTrue(aes12.didConnectionErrorEventHappen());
0:         aes12.resetState();
0:         try {
0:             conn.createStatement(ResultSet.TYPE_FORWARD_ONLY, 
0:             		ResultSet.CONCUR_READ_ONLY,
0:             		ResultSet.CLOSE_CURSORS_AT_COMMIT);
0:         } catch (SQLException e) {
0:                 assertSQLState("08003", e);
0:         }
0:         assertFalse(aes12.didConnectionClosedEventHappen());
0:         assertTrue(aes12.didConnectionErrorEventHappen());
0:         aes12.resetState();
0:         try {
0:             conn.createStatement(ResultSet.TYPE_FORWARD_ONLY, 
0:             ResultSet.CONCUR_READ_ONLY);
0:         } catch (SQLException e) {
0:             assertSQLState("08003", e);
0:         }
0:         assertFalse(aes12.didConnectionClosedEventHappen());
0:         assertTrue(aes12.didConnectionErrorEventHappen());
0:         aes12.resetState();
0:         try {
0:             conn.prepareCall("CREATE TABLE TAB1(COL1 INT NOT NULL)",
0:             		ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);
0:         } catch (SQLException e) {
0:                 assertSQLState("08003", e);
0:         }
0:         assertFalse(aes12.didConnectionClosedEventHappen());
0:         assertTrue(aes12.didConnectionErrorEventHappen());
0:         aes12.resetState();
0:         try {
0:             conn.prepareCall("CREATE TABLE TAB1(COL1 INT NOT NULL)");
0:         } catch (SQLException e) {
0:                 assertSQLState("08003", e);
0:         }
0:         assertFalse(aes12.didConnectionClosedEventHappen());
0:         assertTrue(aes12.didConnectionErrorEventHappen());
0:         aes12.resetState();
0:         try {
0:             conn.prepareCall("CREATE TABLE TAB1(COL1 INT NOT NULL)",
0:             		ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY,
0:             		ResultSet.CLOSE_CURSORS_AT_COMMIT);
0:         } catch (SQLException e) {
0:                 assertSQLState("08003", e);
0:         }
0:         assertFalse(aes12.didConnectionClosedEventHappen());
0:         assertTrue(aes12.didConnectionErrorEventHappen());
0:         aes12.resetState();
0:         try {
0:             conn.nativeSQL("CREATE TABLE TAB1(COL1 INT NOT NULL)");
0:         } catch (SQLException e) {
0:                 assertSQLState("08003", e);
0:         }
0:         assertFalse(aes12.didConnectionClosedEventHappen());
0:         assertTrue(aes12.didConnectionErrorEventHappen());
0:         aes12.resetState();
0:         try {
0:             conn.getAutoCommit();
0:         } catch (SQLException e) {
0:                 assertSQLState("08003", e);
0:         }
0:         assertFalse(aes12.didConnectionClosedEventHappen());
0:         assertTrue(aes12.didConnectionErrorEventHappen());
0:         aes12.resetState();
0:         try {
0:             conn.setAutoCommit(false);
0:         } catch (SQLException e) {
0:                 assertSQLState("08003", e);
0:         }
0:         assertFalse(aes12.didConnectionClosedEventHappen());
0:         assertTrue(aes12.didConnectionErrorEventHappen());
0:         aes12.resetState();
0:         try {
0:             conn.getHoldability();
0:         } catch (SQLException e) {
0:                 assertSQLState("08003", e);
0:         }
0:         assertFalse(aes12.didConnectionClosedEventHappen());
0:         assertTrue(aes12.didConnectionErrorEventHappen());
0:         aes12.resetState();
0:         try {
0:             conn.setHoldability(1);
0:         } catch (SQLException e) {
0:                 assertSQLState("08003", e);
0:         }
0:         assertFalse(aes12.didConnectionClosedEventHappen());
0:         assertTrue(aes12.didConnectionErrorEventHappen());
0:         aes12.resetState();
0:         try {
0:             conn.commit();
0:         } catch (SQLException e) {
0:                 assertSQLState("08003", e);
0:         }
0:         assertFalse(aes12.didConnectionClosedEventHappen());
0:         assertTrue(aes12.didConnectionErrorEventHappen());
0:         aes12.resetState();
0:         try {
0:             conn.rollback();
0:         } catch (SQLException e) {
0:                 assertSQLState("08003", e);
0:         }
0:         assertFalse(aes12.didConnectionClosedEventHappen());
0:         assertTrue(aes12.didConnectionErrorEventHappen());
0:         aes12.resetState();
0:         try {
0:             conn.setSavepoint();
0:         } catch (SQLException e) {
0:                 assertSQLState("08003", e);
0:         }
0:         assertFalse(aes12.didConnectionClosedEventHappen());
0:         assertTrue(aes12.didConnectionErrorEventHappen());
0:         aes12.resetState();
0:         try {
0:             conn.setSavepoint("savept1");
0:         } catch (SQLException e) {
0:                 assertSQLState("08003", e);
0:         }
0:         assertFalse(aes12.didConnectionClosedEventHappen());
0:         assertTrue(aes12.didConnectionErrorEventHappen());
0:         aes12.resetState();
0:         try {
0:             conn.rollback((Savepoint)null);
0:         } catch (SQLException e) {
0:                 assertSQLState("08003", e);
0:         }
0:         assertFalse(aes12.didConnectionClosedEventHappen());
0:         assertTrue(aes12.didConnectionErrorEventHappen());
0:         aes12.resetState();
0:         try {
0:             conn.releaseSavepoint((Savepoint)null);
0:         } catch (SQLException e) {
0:                 assertSQLState("08003", e);
0:         }
0:         assertFalse(aes12.didConnectionClosedEventHappen());
0:         assertTrue(aes12.didConnectionErrorEventHappen());
0:         aes12.resetState();
0:         try {
0:             conn.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
0:         } catch (SQLException e) {
0:                 assertSQLState("08003", e);
0:         }
0:         assertFalse(aes12.didConnectionClosedEventHappen());
0:         assertTrue(aes12.didConnectionErrorEventHappen());
0:         aes12.resetState();
0:         try {
0:             conn.getTransactionIsolation();
0:         } catch (SQLException e) {
0:                 assertSQLState("08003", e);
0:         }
0:         assertFalse(aes12.didConnectionClosedEventHappen());
0:         assertTrue(aes12.didConnectionErrorEventHappen());
0:         aes12.resetState();
0:         try {
0:             conn.getWarnings();
0:         } catch (SQLException e) {
0:                 assertSQLState("08003", e);
0:         }
0:         assertFalse(aes12.didConnectionClosedEventHappen());
0:         assertTrue(aes12.didConnectionErrorEventHappen());
0:         aes12.resetState();
0:         try {
0:             conn.clearWarnings();
0:         } catch (SQLException e) {
0:                 assertSQLState("08003", e);
0:         }
0:         assertFalse(aes12.didConnectionClosedEventHappen());
0:         assertTrue(aes12.didConnectionErrorEventHappen());
0:         aes12.resetState();
0:         try {
0:             conn.getMetaData();
0:         } catch (SQLException e) {
0:                 assertSQLState("08003", e);
0:         }
0:         assertFalse(aes12.didConnectionClosedEventHappen());
0:         assertTrue(aes12.didConnectionErrorEventHappen());
0:         aes12.resetState();
0:         try {
0:             conn.isReadOnly();
0:         } catch (SQLException e) {
0:                 assertSQLState("08003", e);
0:         }
0:         assertFalse(aes12.didConnectionClosedEventHappen());
0:         assertTrue(aes12.didConnectionErrorEventHappen());
0:         aes12.resetState();
0:         try {
0:             conn.setReadOnly(true);
0:         } catch (SQLException e) {
0:                 assertSQLState("08003", e);
0:         }
0:         assertFalse(aes12.didConnectionClosedEventHappen());
0:         assertTrue(aes12.didConnectionErrorEventHappen());
0:         aes12.resetState();
0:         try {
0:             conn.setCatalog(null);
0:         } catch (SQLException e) {
0:                 assertSQLState("08003", e);
0:         }
0:         assertFalse(aes12.didConnectionClosedEventHappen());
0:         assertTrue(aes12.didConnectionErrorEventHappen());
0:         aes12.resetState();
0:         try {
0:             conn.getCatalog();
0:         } catch (SQLException e) {
0:                 assertSQLState("08003", e);
0:         }
0:         assertFalse(aes12.didConnectionClosedEventHappen());
0:         assertTrue(aes12.didConnectionErrorEventHappen());
0:         aes12.resetState();
0:         try {
0:             conn.getTypeMap();
0:         } catch (SQLException e) {
0:                 assertSQLState("08003", e);
0:         }
0:         assertFalse(aes12.didConnectionClosedEventHappen());
0:         assertTrue(aes12.didConnectionErrorEventHappen());
0:         aes12.resetState();
0:         try {
0:             conn.setTypeMap(null);
0:         } catch (SQLException e) {
0:                 assertSQLState("08003", e);
0:         }
0:         assertFalse(aes12.didConnectionClosedEventHappen());
0:         assertTrue(aes12.didConnectionErrorEventHappen());
0:         aes12.resetState();
0:         if (usingEmbedded())
0:         {
0:             Class.forName("org.apache.derby.jdbc.EmbeddedDriver").newInstance();
0:         }else
0:         {
0:         	getTestConfiguration().startNetworkServer();
0:         }
0: 
0:         // Get a new connection to the database
0:         conn = getConnection();
0:         conn.close();
0:     }
0:     
/////////////////////////////////////////////////////////////////////////
commit:2216a40
/////////////////////////////////////////////////////////////////////////
0:         AssertEventCatcher aes1 = new AssertEventCatcher(1);
0:         pc.addConnectionEventListener(aes1);
0:         //Check if got connection closed event but not connection error event
0:         assertTrue(aes1.didConnectionClosedEventHappen());
0:         assertFalse(aes1.didConnectionErrorEventHappen());
0:         aes1.resetState();
0:         //Check if got connection closed event but not connection error event
0:         assertTrue(aes1.didConnectionClosedEventHappen());
0:         assertFalse(aes1.didConnectionErrorEventHappen());
0:         aes1.resetState();
/////////////////////////////////////////////////////////////////////////
0:         AssertEventCatcher aes3 = new AssertEventCatcher(3);
0:         xac.addConnectionEventListener(aes3);
0:         //Check if got connection closed event but not connection error event
0:         assertTrue(aes3.didConnectionClosedEventHappen());
0:         assertFalse(aes3.didConnectionErrorEventHappen());
0:         aes3.resetState();
0:                        
0:         AssertEventCatcher aes2 = new AssertEventCatcher(2);
0:         pc.addConnectionEventListener(aes2);
0:         //Check if got connection closed event but not connection error event
0:         assertTrue(aes2.didConnectionClosedEventHappen());
0:         assertFalse(aes2.didConnectionErrorEventHappen());
0:         aes2.resetState();
0:         AssertEventCatcher aes4 = new AssertEventCatcher(4);
0:         xac.addConnectionEventListener(aes4);
0:         //Check if got connection closed event but not connection error event
0:         assertTrue(aes4.didConnectionClosedEventHappen());
0:         assertFalse(aes4.didConnectionErrorEventHappen());
0:         aes4.resetState();
0:         //Check if got connection closed event but not connection error event
0:         assertTrue(aes4.didConnectionClosedEventHappen());
0:         assertFalse(aes4.didConnectionErrorEventHappen());
0:         aes4.resetState();
0:         AssertEventCatcher aes5 = new AssertEventCatcher(5);
0:         xac.addConnectionEventListener(aes5);
/////////////////////////////////////////////////////////////////////////
0:         //Check if got connection closed event but not connection error event
0:         assertTrue(aes5.didConnectionClosedEventHappen());
0:         assertFalse(aes5.didConnectionErrorEventHappen());
0:         aes5.resetState();
0:         //Check if got connection closed event but not connection error event
0:         assertTrue(aes5.didConnectionClosedEventHappen());
0:         assertFalse(aes5.didConnectionErrorEventHappen());
0:         aes5.resetState();
/////////////////////////////////////////////////////////////////////////
0:         //Check if got connection closed event but not connection error event
0:         assertTrue(aes5.didConnectionClosedEventHappen());
0:         assertFalse(aes5.didConnectionErrorEventHappen());
0:         aes5.resetState();
0:         //Check if got connection closed event but not connection error event
0:         assertTrue(aes5.didConnectionClosedEventHappen());
0:         assertFalse(aes5.didConnectionErrorEventHappen());
0:         aes5.resetState();
/////////////////////////////////////////////////////////////////////////
0:         //Check if got connection closed event but not connection error event
0:         assertTrue(aes5.didConnectionClosedEventHappen());
0:         assertFalse(aes5.didConnectionErrorEventHappen());
0:         aes5.resetState();
0:         //Check if got connection closed event but not connection error event
0:         assertTrue(aes5.didConnectionClosedEventHappen());
0:         assertFalse(aes5.didConnectionErrorEventHappen());
0:         aes5.resetState();
/////////////////////////////////////////////////////////////////////////
0:         AssertEventCatcher aes6 = new AssertEventCatcher(6);
0:         xac.addConnectionEventListener(aes6);
/////////////////////////////////////////////////////////////////////////
0:         //Confirm - no connection closed event & connection error event
0:         assertFalse(aes6.didConnectionClosedEventHappen());
0:         assertFalse(aes6.didConnectionErrorEventHappen());
0:         aes6.resetState();
0:         //Check if got connection closed event but not connection error event
0:         assertTrue(aes6.didConnectionClosedEventHappen());
0:         assertFalse(aes6.didConnectionErrorEventHappen());
0:         aes6.resetState();
/////////////////////////////////////////////////////////////////////////
0:         //Check if got connection closed event but not connection error event
0:         assertTrue(aes6.didConnectionClosedEventHappen());
0:         assertFalse(aes6.didConnectionErrorEventHappen());
0:         aes6.resetState();
/////////////////////////////////////////////////////////////////////////
0:         //Check if got connection closed event but not connection error event
0:         assertTrue(aes6.didConnectionClosedEventHappen());
0:         assertFalse(aes6.didConnectionErrorEventHappen());
0:         aes6.resetState();
/////////////////////////////////////////////////////////////////////////
0:         //Confirm - no connection closed event & connection error event
0:         assertFalse(aes6.didConnectionClosedEventHappen());
0:         assertFalse(aes6.didConnectionErrorEventHappen());
0:         aes6.resetState();
0:         //Check if got connection closed event but not connection error event
0:         assertTrue(aes6.didConnectionClosedEventHappen());
0:         assertFalse(aes6.didConnectionErrorEventHappen());
0:         aes6.resetState();
/////////////////////////////////////////////////////////////////////////
0:         AssertEventCatcher aes6 = new AssertEventCatcher(6);
0:         xac.addConnectionEventListener(aes6);
/////////////////////////////////////////////////////////////////////////
0:         //Confirm - no connection closed event & connection error event
0:         assertFalse(aes6.didConnectionClosedEventHappen());
0:         assertFalse(aes6.didConnectionErrorEventHappen());
0:         aes6.resetState();
/////////////////////////////////////////////////////////////////////////
0:         AssertEventCatcher aes6 = new AssertEventCatcher(6);
0:         xac.addConnectionEventListener(aes6);
/////////////////////////////////////////////////////////////////////////
0:         //Confirm - no connection closed event & connection error event
0:         assertFalse(aes6.didConnectionClosedEventHappen());
0:         assertFalse(aes6.didConnectionErrorEventHappen());
0:         aes6.resetState();
0:         AssertEventCatcher aes5 = new AssertEventCatcher(5);
0:         xac2.addConnectionEventListener(aes5);
/////////////////////////////////////////////////////////////////////////
0:         //Confirm - no connection closed event & connection error event
0:         assertFalse(aes5.didConnectionClosedEventHappen());
0:         assertFalse(aes5.didConnectionErrorEventHappen());
0:         aes5.resetState();
/////////////////////////////////////////////////////////////////////////
0:     //The following flags will indicate what kind of event was
0:     //received by this listener
0:     private boolean gotConnectionClosed = false;
0:     private boolean gotConnectionErrorOccured = false;
/////////////////////////////////////////////////////////////////////////
0:         gotConnectionClosed = true;
0:         gotConnectionErrorOccured = true;
0:     }
0: 
0:     /**
0:      * Tell the caller if we received Connection closed event
0:      * @return true if received Connection closed event
0:      */
0:     public boolean didConnectionClosedEventHappen() 
0:     {
0:     	return gotConnectionClosed;
0:     }
0:     
0:     /**
0:      * Tell the caller if we received Connection error event
0:      * @return true if received Connection error event
0:      */
0:     public boolean didConnectionErrorEventHappen() 
0:     {
0:     	return gotConnectionErrorOccured;
0:     }
0:     
0:     /**
0:      * Clear the event received flags for this listener.
0:      */
0:     public void resetState() 
0:     {
0:     	gotConnectionClosed = false;
0:     	gotConnectionErrorOccured = false;
============================================================================