1:782dbe1: /*
5:782dbe1: 
1:782dbe1:    Derby - Class org.apache.derby.impl.tools.planexporter.AccessDatabase
1:4e20a51: 
1:782dbe1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:782dbe1:    contributor license agreements.  See the NOTICE file distributed with
1:782dbe1:    this work for additional information regarding copyright ownership.
1:782dbe1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:782dbe1:    (the "License"); you may not use this file except in compliance with
1:782dbe1:    the License.  You may obtain a copy of the License at
1:4e20a51: 
1:782dbe1:       http://www.apache.org/licenses/LICENSE-2.0
1:4e20a51: 
1:782dbe1:    Unless required by applicable law or agreed to in writing, software
1:782dbe1:    distributed under the License is distributed on an "AS IS" BASIS,
1:782dbe1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:782dbe1:    See the License for the specific language governing permissions and
1:782dbe1:    limitations under the License.
1:782dbe1: 
1:4e20a51:  */
1:4e20a51: 
1:4e20a51: package org.apache.derby.impl.tools.planexporter;
1:4e20a51: 
1:4469400: import java.lang.reflect.InvocationTargetException;
1:4e20a51: import java.sql.Connection;
1:4e20a51: import java.sql.DriverManager;
1:65ee253: import java.sql.PreparedStatement;
1:4e20a51: import java.sql.ResultSet;
1:4e20a51: import java.sql.SQLException;
1:4e20a51: 
1:80d6162: import org.apache.derby.iapi.tools.ToolUtils;
1:80d6162: 
1:4e20a51: /**
1:4e20a51:  * This class will perform the database connection establishment,
1:4e20a51:  * querying the database, shut downing the database.
1:4e20a51:  * Created under DERBY-4587-PlanExporter tool
1:4e20a51:  */
1:4e20a51: public class AccessDatabase {
1:4e20a51: 
1:65ee253:     private final Connection conn;
1:65ee253:     private final String schema;
1:65ee253:     private final String query;
1:65ee253:     private final boolean schemaExists;
1:65ee253: 
1:4e20a51:     private TreeNode[] data;
1:4e20a51: 
1:4e20a51:     /**
1:ce855d2:      * @return the stmt_id
1:782dbe1:      */
1:ce855d2:     public String getQuery() {
1:ce855d2:         return query;
1:b1b255c:     }
1:4e20a51:     private int depth = 0;
1:4e20a51:     public int getDepth() {
1:4e20a51:         return depth;
1:0e72736:     }
1:4e20a51:     private String xmlDetails="";
1:65ee253: 
1:4e20a51:     //set of variables to identify values of XPlain tables
1:ce855d2:     private static final int ID =0 ;
1:ce855d2:     private static final int P_ID =1;
1:ce855d2:     private static final int NODE_TYPE=2;
1:ce855d2:     private static final int NO_OF_OPENS=3;
1:ce855d2:     private static final int INPUT_ROWS=4;
1:ce855d2:     private static final int RETURNED_ROWS=5;
1:ce855d2:     private static final int VISITED_PAGES=6;
1:ce855d2:     private static final int SCAN_QUALIFIERS=7;
1:ce855d2:     private static final int NEXT_QUALIFIERS=8;
1:ce855d2:     private static final int SCANNED_OBJECT=9;
1:ce855d2:     private static final int SCAN_TYPE=10;
1:ce855d2:     private static final int SORT_TYPE=11;
1:ce855d2:     private static final int NO_OF_OUTPUT_ROWS_BY_SORTER=12;
1:4e20a51: 
1:4e20a51: 
1:4e20a51:     /**
1:4e20a51:      *
1:4e20a51:      * @param dburl
1:4e20a51:      * @param aSchema
1:4e20a51:      * @param aQuery
1:4e20a51:      */
1:65ee253:     public AccessDatabase(String dburl, String aSchema, String aQuery)
1:65ee253:             throws InstantiationException, IllegalAccessException,
1:4469400:                    ClassNotFoundException, SQLException, NoSuchMethodException, InvocationTargetException
1:65ee253:     {
1:65ee253:         this(createConnection(dburl), aSchema, aQuery);
1:0e72736:     }
1:4e20a51: 
1:4e20a51:     /**
1:4e20a51:      *
1:4e20a51:      * @param aConn
1:4e20a51:      * @param aSchema
1:4e20a51:      * @param aQuery
1:4e20a51:      *
1:4e20a51:      */
1:65ee253:     public AccessDatabase(Connection aConn, String aSchema, String aQuery)
1:65ee253:             throws SQLException
1:65ee253:     {
1:4e20a51: 
1:4e20a51:         conn = aConn;
2:4e20a51:         schema = aSchema;
1:65ee253:         query = aQuery;
1:65ee253:         schemaExists = schemaExists();
1:4e20a51: 
1:65ee253:         if (schemaExists) {
1:65ee253:             setSchema();
1:65ee253:         }
7:4e20a51:     }
1:4e20a51: 
1:4e20a51:     /**
1:4e20a51:      *
1:4e20a51:      * @throws InstantiationException
1:4e20a51:      * @throws IllegalAccessException
1:4e20a51:      * @throws ClassNotFoundException
1:4e20a51:      * @throws SQLException
1:4e20a51:      */
1:65ee253:     private static Connection createConnection(String dbURL)
1:65ee253:             throws InstantiationException, IllegalAccessException,
1:4469400:                    ClassNotFoundException, SQLException, NoSuchMethodException,
1:4469400:                    InvocationTargetException
3:4e20a51:     {
1:4e20a51: 
1:4469400:         Class<?> clazz = (dbURL.indexOf("://") != -1) ?
1:4469400:           Class.forName("org.apache.derby.jdbc.ClientDriver")
1:4469400:           :
1:4469400:           Class.forName("org.apache.derby.jdbc.EmbeddedDriver");
1:4469400:         clazz.getConstructor().newInstance();
1:4e20a51: 
1:4e20a51:         //Get a connection
1:65ee253:         return DriverManager.getConnection(dbURL);
1:4e20a51: 
1:4e20a51:     }
1:4e20a51: 
1:65ee253:     /**
1:65ee253:      * Set the schema of the current connection to the XPLAIN schema in
1:65ee253:      * which the statistics can be found.
1:65ee253:      *
1:65ee253:      * @throws SQLException if an error happens while accessing the database
1:65ee253:      */
1:65ee253:     private void setSchema() throws SQLException {
1:65ee253:         PreparedStatement setSchema = conn.prepareStatement("SET SCHEMA ?");
1:65ee253:         setSchema.setString(1, schema);
1:65ee253:         setSchema.execute();
1:65ee253:         setSchema.close();
1:65ee253:     }
1:65ee253: 
1:65ee253:     /**
1:65ee253:      * Check if there is a schema in the database that matches the schema
1:65ee253:      * name that was passed in to this instance.
1:65ee253:      */
1:65ee253:     private boolean schemaExists() throws SQLException {
1:0e72736:     	ResultSet result = conn.getMetaData().getSchemas();
1:643e68c:         try {
1:643e68c:             while (result.next()) {
1:643e68c:                 if (result.getString(1).equals(schema)) {
1:643e68c:                     // Found it!
1:643e68c:                     return true;
1:643e68c:                 }
1:643e68c:             }
1:643e68c:         } finally {
1:643e68c:             result.close();
1:643e68c:         }
1:643e68c: 
1:643e68c:         // Didn't find the schema.
1:643e68c:         return false;
1:0e72736:     }
1:4e20a51: 
1:65ee253:     public boolean verifySchemaExistance() {
1:65ee253:         return schemaExists;
1:65ee253:     }
1:65ee253: 
1:4e20a51:     /**
1:4e20a51:      * <p>
1:4e20a51:      * This method creates the queries such that after execution
1:4e20a51:      * of the query it will return XML data fragments.
1:4e20a51:      * </P>
1:4e20a51:      * @throws SQLException
1:4e20a51:      * */
1:4e20a51:     public void createXMLFragment() throws SQLException{
1:4e20a51:         createXMLData(
1:4e20a51:                 "select 'id=\"' ||RS_ID|| '\"' " +
1:65ee253:                 "from SYSXPLAIN_RESULTSETS " +
1:65ee253:                 "where STMT_ID = ?", ID);
1:4e20a51: 
1:4e20a51:         createXMLData(
1:4e20a51:                 "select PARENT_RS_ID "+
1:65ee253:                 "from SYSXPLAIN_RESULTSETS " +
1:65ee253:                 "where STMT_ID = ?", P_ID);
1:4e20a51: 
1:4e20a51:         createXMLData(
1:4e20a51:                 "select 'name=\"' ||OP_IDENTIFIER|| '\"' " +
1:65ee253:                 "from SYSXPLAIN_RESULTSETS " +
1:65ee253:                 "where STMT_ID = ?", NODE_TYPE);
1:4e20a51: 
1:4e20a51:         createXMLData(
1:4e20a51:                 "select 'no_opens=\"' " +
1:4e20a51:                 "|| TRIM(CHAR(NO_OPENS))|| '\"' " +
1:65ee253:                 "from SYSXPLAIN_RESULTSETS " +
1:65ee253:                 "where STMT_ID = ?", NO_OF_OPENS);
1:4e20a51: 
1:4e20a51:         createXMLData(
1:4e20a51:                 "select 'input_rows=\"' " +
1:4e20a51:                 "|| TRIM(CHAR(INPUT_ROWS))|| '\"' " +
1:65ee253:                 "from SYSXPLAIN_RESULTSETS " +
1:65ee253:                 "where STMT_ID = ?", INPUT_ROWS);
1:4e20a51: 
1:4e20a51:         createXMLData(
1:4e20a51:                 "select 'returned_rows=\"' " +
1:4e20a51:                 "|| TRIM(CHAR(RETURNED_ROWS))|| '\"' " +
1:65ee253:                 "from SYSXPLAIN_RESULTSETS " +
1:65ee253:                 "where STMT_ID = ?", RETURNED_ROWS);
1:4e20a51: 
1:4e20a51:         createXMLData(
1:4e20a51:                 "select 'visited_pages=\"'" +
1:4e20a51:                 "|| TRIM(CHAR(NO_VISITED_PAGES))|| '\"' " +
1:65ee253:                 "from (SYSXPLAIN_SCAN_PROPS " +
1:65ee253:                 "NATURAL RIGHT OUTER JOIN SYSXPLAIN_RESULTSETS) " +
1:65ee253:                 "where STMT_ID = ?", VISITED_PAGES);
1:4e20a51: 
1:4e20a51:         createXMLData(
1:4e20a51:                 "select 'scan_qualifiers=\"'"+
1:4e20a51:                 "||SCAN_QUALIFIERS|| '\"' " +
1:65ee253:                 "from (SYSXPLAIN_SCAN_PROPS " +
1:65ee253:                 "NATURAL RIGHT OUTER JOIN SYSXPLAIN_RESULTSETS) " +
1:65ee253:                 "where STMT_ID = ?", SCAN_QUALIFIERS);
1:4e20a51: 
1:4e20a51:         createXMLData(
1:4e20a51:                 "select 'next_qualifiers=\"'"+
1:4e20a51:                 "||NEXT_QUALIFIERS|| '\"' " +
1:65ee253:                 "from (SYSXPLAIN_SCAN_PROPS " +
1:65ee253:                 "NATURAL RIGHT OUTER JOIN SYSXPLAIN_RESULTSETS) " +
1:65ee253:                 "where STMT_ID = ?", NEXT_QUALIFIERS);
1:4e20a51: 
1:4e20a51:         createXMLData(
1:4e20a51:                 "select 'scanned_object=\"'"+
1:4e20a51:                 "||SCAN_OBJECT_NAME|| '\"' " +
1:65ee253:                 "from (SYSXPLAIN_SCAN_PROPS " +
1:65ee253:                 "NATURAL RIGHT OUTER JOIN SYSXPLAIN_RESULTSETS) " +
1:65ee253:                 "where STMT_ID = ?", SCANNED_OBJECT);
1:4e20a51: 
1:4e20a51:         createXMLData(
1:4e20a51:                 "select 'scan_type=\"'"+
1:4e20a51:                 "||TRIM(SCAN_TYPE)|| '\"' " +
1:65ee253:                 "from (SYSXPLAIN_SCAN_PROPS " +
1:65ee253:                 "NATURAL RIGHT OUTER JOIN SYSXPLAIN_RESULTSETS) " +
1:65ee253:                 "where STMT_ID = ?", SCAN_TYPE);
1:4e20a51: 
1:4e20a51:         createXMLData(
1:4e20a51:                 "select 'sort_type=\"'"+
1:4e20a51:                 "||TRIM(SORT_TYPE)|| '\"' " +
1:65ee253:                 "from (SYSXPLAIN_SORT_PROPS " +
1:65ee253:                 "NATURAL RIGHT OUTER JOIN SYSXPLAIN_RESULTSETS) " +
1:65ee253:                 "where STMT_ID = ?", SORT_TYPE);
1:4e20a51: 
1:4e20a51:         createXMLData(
1:4e20a51:                 "select 'sorter_output=\"'"+
1:4e20a51:                 "||TRIM(CHAR(NO_OUTPUT_ROWS))|| '\"' " +
1:65ee253:                 "from (SYSXPLAIN_SORT_PROPS " +
1:65ee253:                 "NATURAL RIGHT OUTER JOIN SYSXPLAIN_RESULTSETS) " +
1:65ee253:                 "where STMT_ID = ?", NO_OF_OUTPUT_ROWS_BY_SORTER);
1:4e20a51: 
1:4e20a51:     }
1:4e20a51: 
1:4e20a51:     /**
1:ce855d2:      * Generating the XML tree
1:4e20a51:      * @return all xml elements as a String
1:4e20a51:      */
1:4e20a51:     public String getXmlString(){
1:4e20a51: 
1:4e20a51:         for(int i=0;i<data.length;i++){
1:4e20a51:             //assume only one root element for any query
1:ce855d2:             if(data[i].getDepth()==0){//root element
1:c85d5e1: 
1:4e20a51:                 xmlDetails += indent(1);
1:4e20a51:                 xmlDetails += data[i].toString();
1:4e20a51:                 getChildren(1, data[i].getId());
1:4e20a51:                 xmlDetails += indent(1)+"</node>\n";
1:0e72736:                 break;
1:4e20a51:             }
1:4e20a51:         }
1:4e20a51:         return xmlDetails;
1:4e20a51:     }
1:4e20a51: 
1:4e20a51:     /**
1:4e20a51:      *
1:4e20a51:      * @param currentLevel level of the XML tree (0 based) of current node
1:4e20a51:      * @param id current node's stmt_id
1:4e20a51:      */
1:ce855d2:     private void getChildren(int currentLevel,String id ){
1:4e20a51:         if(currentLevel <= depth){
1:4e20a51:             for(int i=0;i<data.length;i++){
1:ce855d2:                 if(data[i].getDepth()== currentLevel &&
1:4e20a51:                         (id.indexOf(data[i].getParent()) != -1))
1:4e20a51:                 {
1:4e20a51:                     xmlDetails += indent(currentLevel+1);
1:4e20a51:                     xmlDetails += data[i].toString();
1:4e20a51:                     getChildren(currentLevel+1, data[i].getId());
1:4e20a51:                     xmlDetails += indent(currentLevel+1)+"</node>\n";
1:4e20a51:                 }
1:4e20a51:             }
1:4e20a51:         }
1:4e20a51:     }
1:4e20a51: 
1:4e20a51:     /**
1:4e20a51:      *
1:4e20a51:      * @param j indent needed
1:4e20a51:      * @return indent as a string
1:4e20a51:      */
1:4e20a51:     public String indent(int j){
1:4e20a51:         String str="";
1:4e20a51:         for(int i=0;i<=j+1;i++)
1:ce855d2:             str +="    ";
1:4e20a51: 
1:4e20a51:         return str;
1:4e20a51:     }
1:4e20a51: 
1:4e20a51:     /**
1:4e20a51:      * marking the depth of each element
1:4e20a51:      */
1:4e20a51:     public void markTheDepth(){
1:4e20a51:         int i=0;
1:4e20a51:         while(data[i].getParent().indexOf("null")== -1)
1:4e20a51:             i++;
1:ce855d2:         data[i].setDepth(depth); //root
1:4e20a51:         findChildren(i,depth);
1:4e20a51:     }
1:4e20a51: 
1:4e20a51:     /**
1:4e20a51:      *
1:4e20a51:      * @param idx current element's index
1:4e20a51:      * @param dep current examining depth
1:4e20a51:      */
1:ce855d2:     private void findChildren(int idx, int dep) {
1:4e20a51:         if(dep>depth)
1:4e20a51:             depth =dep;
1:4e20a51: 
1:4e20a51:         for(int i=0;i<data.length;i++){
1:4e20a51: 
1:4e20a51:             if(data[i].getParent().indexOf("null")== -1){
1:4e20a51:                 if((data[idx].getId()).indexOf(data[i].getParent()) != -1
1:4e20a51:                         && i != idx)
1:4e20a51:                 {
1:ce855d2:                     data[i].setDepth(dep +1);
1:4e20a51:                     findChildren(i,dep+1);
1:4e20a51:                 }
1:4e20a51:             }
1:4e20a51:         }
1:4e20a51:     }
1:4e20a51: 
1:4e20a51: 
1:4e20a51:     /**
1:4e20a51:      *
1:4e20a51:      * @return whether the initialization is successful or not
1:4e20a51:      * @throws SQLException
1:4e20a51:      */
1:4e20a51:     public boolean initializeDataArray() throws SQLException{
1:4e20a51:         if(noOfNodes()==0)
1:4e20a51:             return false;
1:b1b255c:         else{
1:4e20a51:             data = new TreeNode[noOfNodes()];
1:4e20a51:             for(int i=0; i<data.length;i++){
1:4e20a51:                 data[i] = new TreeNode();
1:b1b255c:             }
1:4e20a51:             return true;
1:4e20a51:         }
1:4e20a51: 
1:4e20a51:     }
1:4e20a51: 
1:4e20a51:     /**
1:65ee253:      * Create XML data based on the query that's passed in. The query should
1:65ee253:      * have exactly one parameter, which will be initialized to the statement
1:65ee253:      * id before the query is executed.
1:4e20a51:      *
1:4e20a51:      * @param qry query to be executed
1:4e20a51:      * @throws SQLException
1:4e20a51:      */
1:4e20a51:     private void createXMLData(String qry, int x) throws SQLException{
1:4e20a51: 
1:65ee253:         PreparedStatement ps = conn.prepareStatement(qry);
1:65ee253:         ps.setString(1, getQuery());
1:65ee253: 
1:65ee253:         ResultSet results = ps.executeQuery();
1:4e20a51: 
1:4e20a51:         int i=0;
1:4e20a51:         while(results.next())
1:4e20a51:         {
1:4e20a51:             String text= results.getString(1);
1:c85d5e1: 
1:4e20a51:             if(text != null){
1:c85d5e1: 
1:c85d5e1:                 /*Removing possible occurrences of special XML characters
1:c85d5e1:                  * from XML node attributes in XML representation.*/
1:f67a9ca:                 text = escapeInAttribute(text);
1:c85d5e1: 
1:4e20a51:                 switch(x){
1:ce855d2:                 case ID:
1:4e20a51:                     data[i].setId(text+" ");
2:4e20a51:                     break;
1:ce855d2:                 case P_ID:
1:4e20a51:                     data[i].setParent(text);
1:4e20a51:                     break;
1:ce855d2:                 case NODE_TYPE:
1:4e20a51:                     data[i].setNodeType(text+" ");
1:4e20a51:                     break;
1:ce855d2:                 case NO_OF_OPENS:
1:4e20a51:                     data[i].setNoOfOpens(text+" ");
1:4e20a51:                     break;
1:ce855d2:                 case INPUT_ROWS:
1:4e20a51:                     data[i].setInputRows(text+" ");
1:4e20a51:                     break;
1:ce855d2:                 case RETURNED_ROWS:
1:4e20a51:                     data[i].setReturnedRows(text+" ");
1:4e20a51:                     break;
1:ce855d2:                 case VISITED_PAGES:
1:4e20a51:                     data[i].setVisitedPages(text+" ");
1:4e20a51:                     break;
1:ce855d2:                 case SCAN_QUALIFIERS:
1:4e20a51:                     data[i].setScanQualifiers(text+" ");
1:4e20a51:                     break;
1:ce855d2:                 case NEXT_QUALIFIERS:
1:4e20a51:                     data[i].setNextQualifiers(text+" ");
1:4e20a51:                     break;
1:ce855d2:                 case SCANNED_OBJECT:
1:4e20a51:                     data[i].setScannedObject(text+" ");
1:4e20a51:                     break;
1:ce855d2:                 case SCAN_TYPE:
1:4e20a51:                     data[i].setScanType(text+" ");
1:4e20a51:                     break;
1:ce855d2:                 case SORT_TYPE:
1:4e20a51:                     data[i].setSortType(text+" ");
1:4e20a51:                     break;
1:ce855d2:                 case NO_OF_OUTPUT_ROWS_BY_SORTER:
1:4e20a51:                     data[i].setSorterOutput(text+" ");
1:4e20a51:                     break;
1:4e20a51:                 }
1:4e20a51:             }
2:4e20a51:             else{
1:4e20a51:                 /*Other attributes are omitted from the xml document
1:4e20a51:                  * if they're null.
1:ce855d2:                  * P_ID can be null at the root.
1:4e20a51:                  * */
1:4e20a51:                 switch(x){
1:ce855d2:                 case P_ID:
1:4e20a51:                     data[i].setParent(text+"");
1:4e20a51:                     break;
1:4e20a51:                 }
1:4e20a51:             }
1:4e20a51:             i++;
1:4e20a51:         }
1:4e20a51:         results.close();
1:65ee253:         ps.close();
1:4e20a51:     }
1:4e20a51: 
1:4e20a51:     /**
1:4e20a51:      *
1:4e20a51:      * @return total # of nodes
1:4e20a51:      * @throws SQLException
1:4e20a51:      */
1:ce855d2:     private int noOfNodes() throws SQLException{
1:65ee253:         PreparedStatement ps = conn.prepareStatement(
1:65ee253:                 "select count(*) from SYSXPLAIN_RESULTSETS where STMT_ID = ?");
1:65ee253:         ps.setString(1, getQuery());
1:65ee253:         ResultSet results = ps.executeQuery();
1:4e20a51:         results.next();
1:4e20a51:         int no = results.getInt(1);
1:4e20a51:         results.close();
1:65ee253:         ps.close();
1:4e20a51:         return no;
1:4e20a51:     }
1:4e20a51: 
1:4e20a51: 
1:4e20a51:     /**
1:4e20a51:      *
1:ce855d2:      * @return the &lt;statement&gt; element
1:4e20a51:      * @throws SQLException
1:4e20a51:      */
1:4e20a51:     public String statement() throws SQLException{
1:65ee253:         PreparedStatement ps = conn.prepareStatement(
1:65ee253:                 "select STMT_TEXT from SYSXPLAIN_STATEMENTS where STMT_ID = ?");
1:65ee253:         ps.setString(1, getQuery());
1:65ee253:         ResultSet results = ps.executeQuery();
1:4e20a51:         results.next();
1:4e20a51:         String statement = results.getString(1);
1:4e20a51:         results.close();
1:65ee253:         ps.close();
1:c85d5e1: 
1:c85d5e1:         /*Removing possible occurrences of special XML characters
1:c85d5e1:          * from a query statement with XML representation.*/
1:f67a9ca:         statement = escapeForXML(statement);
1:c85d5e1: 
1:4e20a51:         return "<statement>"+statement+"</statement>\n";
1:c85d5e1:     }
1:c85d5e1: 
1:c85d5e1:     /**
1:f67a9ca:      * Escape characters that have a special meaning in XML.
1:4e20a51:      *
1:f67a9ca:      * @param text the text to escape
1:f67a9ca:      * @return the text with special characters escaped
19:ce855d2:      */
1:f67a9ca:     private static String escapeForXML(String text) {
1:f67a9ca:         StringBuffer sb = new StringBuffer();
1:f67a9ca: 
1:f67a9ca:         for (int i = 0; i < text.length(); i++) {
1:f67a9ca:             char ch = text.charAt(i);
1:f67a9ca:             switch (ch) {
1:f67a9ca:                 case '&':
1:f67a9ca:                     sb.append("&amp;");
1:f67a9ca:                     break;
1:f67a9ca:                 case '<':
1:f67a9ca:                     sb.append("&lt;");
1:f67a9ca:                     break;
1:f67a9ca:                 case '>':
1:f67a9ca:                     sb.append("&gt;");
1:f67a9ca:                     break;
1:f67a9ca:                 case '\'':
1:f67a9ca:                     sb.append("&apos;");
1:f67a9ca:                     break;
1:f67a9ca:                 case '"':
1:f67a9ca:                     sb.append("&quot;");
1:f67a9ca:                     break;
1:f67a9ca:                 default:
1:f67a9ca:                     sb.append(ch);
1:f67a9ca:             }
1:f67a9ca:         }
1:f67a9ca: 
1:f67a9ca:         return sb.toString();
1:4e20a51:     }
1:4e20a51: 
1:4e20a51:     /**
1:c85d5e1:      * This method is needed since in the case of XML attributes
1:c85d5e1:      * we have to filter the quotation (&quot;) marks that is compulsory.
1:c85d5e1:      * eg:
1:c85d5e1:      * scanned_object="A &quot;quoted&quot;  table name";
1:c85d5e1:      *
1:c85d5e1:      * @param text attribute string to be checked
1:c85d5e1:      * @return modified string
1:c85d5e1:      */
1:f67a9ca:     private String escapeInAttribute(String text) {
1:c85d5e1:         if (text.indexOf('"') == -1)
2:c85d5e1:             return text;
1:f67a9ca:         String correctXMLString = escapeForXML(
1:f67a9ca:                 text.substring(text.indexOf('"') + 1, text.length() - 1));
1:c85d5e1:         return text.substring(0,text.indexOf('"')+1)+correctXMLString+"\"";
1:158ccc5:     }
1:b1b255c:    
1:4e20a51:     /**
1:4e20a51:      *
1:ce855d2:      * @return XPLAIN_TIME of SYSXPLAIN_STATEMENTS
7:ce855d2:      * @throws SQLException
1:4e20a51:      */
1:ce855d2:     public String time() throws SQLException{
1:65ee253:         PreparedStatement ps = conn.prepareStatement(
1:ce855d2:                 "select '<time>'||TRIM(CHAR(XPLAIN_TIME))||" +
1:65ee253:                 "'</time>' from SYSXPLAIN_STATEMENTS " +
1:65ee253:                 "where STMT_ID = ?");
1:65ee253:         ps.setString(1, getQuery());
1:65ee253:         ResultSet results = ps.executeQuery();
3:ce855d2:         results.next();
1:ce855d2:         String time = results.getString(1);
4:ce855d2:         results.close();
1:65ee253:         ps.close();
1:4e20a51: 
1:0e72736:         return time+"\n";
1:4e20a51:     }
1:4e20a51: 
20:ce855d2:     /**
15:ce855d2:      *
1:ce855d2:      * @return stmt_id as a XML element
1:4e20a51:      */
1:ce855d2:     public String stmtID(){
1:0e72736:         return "<stmt_id>"+getQuery()+"</stmt_id>\n";
1:4e20a51:     }
1:4e20a51: 
1:ce855d2:     /**
1:ce855d2:      * closing the connection to the database
1:ce855d2:      */
1:ce855d2:     public void closeConnection()
1:158ccc5:     {
1:4e20a51:         try
1:4e20a51:         {
1:4e20a51:             if (conn != null)
1:4e20a51:             {
1:4e20a51:                 conn.close();
1:4e20a51:             }
1:4e20a51:         }
1:4e20a51:         catch (SQLException sqlExcept){}
1:4e20a51:     }
1:4e20a51: 
1:4e20a51:     /**
1:4e20a51:      *
1:4e20a51:      * @return data array of TreeNode Objects
1:4e20a51:      */
1:4e20a51:     public TreeNode[] getData() {
1:80d6162:         return (TreeNode[]) ToolUtils.copy( data );
1:4e20a51:     }
1:4e20a51: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:4469400
/////////////////////////////////////////////////////////////////////////
1: import java.lang.reflect.InvocationTargetException;
/////////////////////////////////////////////////////////////////////////
1:                    ClassNotFoundException, SQLException, NoSuchMethodException, InvocationTargetException
/////////////////////////////////////////////////////////////////////////
1:                    ClassNotFoundException, SQLException, NoSuchMethodException,
1:                    InvocationTargetException
1:         Class<?> clazz = (dbURL.indexOf("://") != -1) ?
1:           Class.forName("org.apache.derby.jdbc.ClientDriver")
1:           :
1:           Class.forName("org.apache.derby.jdbc.EmbeddedDriver");
1:         clazz.getConstructor().newInstance();
commit:80d6162
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.tools.ToolUtils;
1: 
/////////////////////////////////////////////////////////////////////////
1:         return (TreeNode[]) ToolUtils.copy( data );
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:643e68c
/////////////////////////////////////////////////////////////////////////
1:         try {
1:             while (result.next()) {
1:                 if (result.getString(1).equals(schema)) {
1:                     // Found it!
1:                     return true;
1:                 }
1:             }
1:         } finally {
1:             result.close();
1:         }
1: 
1:         // Didn't find the schema.
1:         return false;
commit:f67a9ca
/////////////////////////////////////////////////////////////////////////
1:                 text = escapeInAttribute(text);
/////////////////////////////////////////////////////////////////////////
1:         statement = escapeForXML(statement);
1:      * Escape characters that have a special meaning in XML.
1:      * @param text the text to escape
1:      * @return the text with special characters escaped
1:     private static String escapeForXML(String text) {
1:         StringBuffer sb = new StringBuffer();
1: 
1:         for (int i = 0; i < text.length(); i++) {
1:             char ch = text.charAt(i);
1:             switch (ch) {
1:                 case '&':
1:                     sb.append("&amp;");
1:                     break;
1:                 case '<':
1:                     sb.append("&lt;");
1:                     break;
1:                 case '>':
1:                     sb.append("&gt;");
1:                     break;
1:                 case '\'':
1:                     sb.append("&apos;");
1:                     break;
1:                 case '"':
1:                     sb.append("&quot;");
1:                     break;
1:                 default:
1:                     sb.append(ch);
1:             }
1:         }
1: 
1:         return sb.toString();
/////////////////////////////////////////////////////////////////////////
1:     private String escapeInAttribute(String text) {
1:         String correctXMLString = escapeForXML(
1:                 text.substring(text.indexOf('"') + 1, text.length() - 1));
commit:c85d5e1
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:                 /*Removing possible occurrences of special XML characters
1:                  * from XML node attributes in XML representation.*/
0:                 text = replaceInAttribute(text, '<',"&lt;");
0:                 text = replaceInAttribute(text, '>',"&gt;");
0:                 text = replaceInAttribute(text, '\'',"&apos;");
0:                 text = replaceInAttribute(text, '"',"&quot;");
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:         /*Removing possible occurrences of special XML characters
1:          * from a query statement with XML representation.*/
0:         statement = replace(statement, '<',"&lt;");
0:         statement = replace(statement, '>',"&gt;");
0:         statement = replace(statement, '\'',"&apos;");
0:         statement = replace(statement, '"',"&quot;");
1: 
0:      * @param text text to be checked
0:     private String replace(String text, char expr, String replace){
0:          int idx = text.indexOf(expr);
0:              text = text.substring(0, idx) + replace + text.substring(idx+1);
0:              idx = text.indexOf(expr);
1:          return text;
1:     }
1: 
1:     /**
1:      * This method is needed since in the case of XML attributes
1:      * we have to filter the quotation (&quot;) marks that is compulsory.
1:      * eg:
1:      * scanned_object="A &quot;quoted&quot;  table name";
1:      *
1:      * @param text attribute string to be checked
0:      * @param expr string to be removed
0:      * @param replace string to be added
1:      * @return modified string
1:      */
0:     private String replaceInAttribute(String text, char expr, String replace){
1:         if (text.indexOf('"') == -1)
1:             return text;
0:         String correctXMLString = replace(text.substring(text.indexOf('"')+1, text.length()-1), expr, replace);
1:         return text.substring(0,text.indexOf('"')+1)+correctXMLString+"\"";
commit:65ee253
/////////////////////////////////////////////////////////////////////////
1: import java.sql.PreparedStatement;
/////////////////////////////////////////////////////////////////////////
1:     private final Connection conn;
1:     private final String schema;
1:     private final String query;
1:     private final boolean schemaExists;
1: 
/////////////////////////////////////////////////////////////////////////
1:     public AccessDatabase(String dburl, String aSchema, String aQuery)
1:             throws InstantiationException, IllegalAccessException,
0:             ClassNotFoundException, SQLException
1:     {
1:         this(createConnection(dburl), aSchema, aQuery);
/////////////////////////////////////////////////////////////////////////
1:     public AccessDatabase(Connection aConn, String aSchema, String aQuery)
1:             throws SQLException
1:     {
1:         query = aQuery;
1:         schemaExists = schemaExists();
1:         if (schemaExists) {
1:             setSchema();
1:         }
/////////////////////////////////////////////////////////////////////////
1:     private static Connection createConnection(String dbURL)
1:             throws InstantiationException, IllegalAccessException,
0:             ClassNotFoundException, SQLException
/////////////////////////////////////////////////////////////////////////
1:         return DriverManager.getConnection(dbURL);
1:     /**
1:      * Set the schema of the current connection to the XPLAIN schema in
1:      * which the statistics can be found.
1:      *
1:      * @throws SQLException if an error happens while accessing the database
1:      */
1:     private void setSchema() throws SQLException {
1:         PreparedStatement setSchema = conn.prepareStatement("SET SCHEMA ?");
1:         setSchema.setString(1, schema);
1:         setSchema.execute();
1:         setSchema.close();
1:     }
1: 
1:     /**
1:      * Check if there is a schema in the database that matches the schema
1:      * name that was passed in to this instance.
1:      */
1:     private boolean schemaExists() throws SQLException {
/////////////////////////////////////////////////////////////////////////
1: 
1:     public boolean verifySchemaExistance() {
1:         return schemaExists;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:                 "from SYSXPLAIN_RESULTSETS " +
1:                 "where STMT_ID = ?", ID);
1:                 "from SYSXPLAIN_RESULTSETS " +
1:                 "where STMT_ID = ?", P_ID);
1:                 "from SYSXPLAIN_RESULTSETS " +
1:                 "where STMT_ID = ?", NODE_TYPE);
1:                 "from SYSXPLAIN_RESULTSETS " +
1:                 "where STMT_ID = ?", NO_OF_OPENS);
1:                 "from SYSXPLAIN_RESULTSETS " +
1:                 "where STMT_ID = ?", INPUT_ROWS);
1:                 "from SYSXPLAIN_RESULTSETS " +
1:                 "where STMT_ID = ?", RETURNED_ROWS);
1:                 "from (SYSXPLAIN_SCAN_PROPS " +
1:                 "NATURAL RIGHT OUTER JOIN SYSXPLAIN_RESULTSETS) " +
1:                 "where STMT_ID = ?", VISITED_PAGES);
1:                 "from (SYSXPLAIN_SCAN_PROPS " +
1:                 "NATURAL RIGHT OUTER JOIN SYSXPLAIN_RESULTSETS) " +
1:                 "where STMT_ID = ?", SCAN_QUALIFIERS);
1:                 "from (SYSXPLAIN_SCAN_PROPS " +
1:                 "NATURAL RIGHT OUTER JOIN SYSXPLAIN_RESULTSETS) " +
1:                 "where STMT_ID = ?", NEXT_QUALIFIERS);
1:                 "from (SYSXPLAIN_SCAN_PROPS " +
1:                 "NATURAL RIGHT OUTER JOIN SYSXPLAIN_RESULTSETS) " +
1:                 "where STMT_ID = ?", SCANNED_OBJECT);
1:                 "from (SYSXPLAIN_SCAN_PROPS " +
1:                 "NATURAL RIGHT OUTER JOIN SYSXPLAIN_RESULTSETS) " +
1:                 "where STMT_ID = ?", SCAN_TYPE);
1:                 "from (SYSXPLAIN_SORT_PROPS " +
1:                 "NATURAL RIGHT OUTER JOIN SYSXPLAIN_RESULTSETS) " +
1:                 "where STMT_ID = ?", SORT_TYPE);
1:                 "from (SYSXPLAIN_SORT_PROPS " +
1:                 "NATURAL RIGHT OUTER JOIN SYSXPLAIN_RESULTSETS) " +
1:                 "where STMT_ID = ?", NO_OF_OUTPUT_ROWS_BY_SORTER);
/////////////////////////////////////////////////////////////////////////
1:      * Create XML data based on the query that's passed in. The query should
1:      * have exactly one parameter, which will be initialized to the statement
1:      * id before the query is executed.
1:         PreparedStatement ps = conn.prepareStatement(qry);
1:         ps.setString(1, getQuery());
1: 
1:         ResultSet results = ps.executeQuery();
/////////////////////////////////////////////////////////////////////////
1:         ps.close();
/////////////////////////////////////////////////////////////////////////
1:         PreparedStatement ps = conn.prepareStatement(
1:                 "select count(*) from SYSXPLAIN_RESULTSETS where STMT_ID = ?");
1:         ps.setString(1, getQuery());
1:         ResultSet results = ps.executeQuery();
1:         ps.close();
/////////////////////////////////////////////////////////////////////////
1:         PreparedStatement ps = conn.prepareStatement(
1:                 "select STMT_TEXT from SYSXPLAIN_STATEMENTS where STMT_ID = ?");
1:         ps.setString(1, getQuery());
1:         ResultSet results = ps.executeQuery();
1:         ps.close();
/////////////////////////////////////////////////////////////////////////
1:         PreparedStatement ps = conn.prepareStatement(
1:                 "'</time>' from SYSXPLAIN_STATEMENTS " +
1:                 "where STMT_ID = ?");
1:         ps.setString(1, getQuery());
1:         ResultSet results = ps.executeQuery();
1:         ps.close();
/////////////////////////////////////////////////////////////////////////
commit:158ccc5
/////////////////////////////////////////////////////////////////////////
0:     	 int idx = stmt.indexOf(expr);
0:     	 while (idx >= 0)
1:     	 {
0:     	   stmt = stmt.substring(0, idx) + replace + stmt.substring(idx+1);
0:     	   idx = stmt.indexOf(expr);
1:     	 }
0:     	 return stmt;
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:b1b255c
/////////////////////////////////////////////////////////////////////////
0:     	if(stmt.indexOf(expr)!=-1){
0:     		stmt=stmt.substring(0, stmt.indexOf(expr))
0:     		+replace+stmt.substring(stmt.indexOf(expr)+1);
0:     		replace(stmt,expr,replace);
0:     		return "";
1:     	}
1:     	else{
0:     		return stmt;
1:     	}
1:    
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:0e72736
/////////////////////////////////////////////////////////////////////////
0:     public boolean verifySchemaExistance() throws SQLException{
0:     	boolean found=false;
1:     	ResultSet result = conn.getMetaData().getSchemas();
0:     	while(result.next()){
0:     		if(result.getString(1).equals(schema)){
0:     			found=true;
1:     			break;
1:     		}
1:     	}	
0:     	return found;
1:     }
/////////////////////////////////////////////////////////////////////////
1:         return time+"\n";
/////////////////////////////////////////////////////////////////////////
1:         return "<stmt_id>"+getQuery()+"</stmt_id>\n";
commit:4e20a51
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * This class will perform the database connection establishment,
1:  * querying the database, shut downing the database.
1:  * Created under DERBY-4587-PlanExporter tool
1:  */
1: 
1: package org.apache.derby.impl.tools.planexporter;
1: 
1: import java.sql.Connection;
1: import java.sql.DriverManager;
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
0: import java.sql.Statement;
1: 
1: 
1: /**
0:  * @author Nirmal
1:  *
1:  */
1: public class AccessDatabase {
1: 
0: 	private Connection conn = null;
0: 	private Statement stmt = null;
1: 	private TreeNode[] data;
0: 	private String dbURL = null;
0: 	private String schema = null;
0: 	private String query = null;
1: 	private int depth = 0;	
1: 	public int getDepth() {
1: 		return depth;
1: 	}
1: 	private String xmlDetails="";
1: 
1: 	//set of variables to identify values of XPlain tables
0: 	private final int id =0 ;
0: 	private final int p_id =1;
0: 	private final int nodeType=2;
0: 	private final int noOfOpens=3;
0: 	private final int inputRows=4;
0: 	private final int returnedRows=5;
0: 	private final int visitedPages=6;
0: 	private final int scanQualifiers=7;
0: 	private final int nextQualifiers=8;
0: 	private final int scannedObject=9;
0: 	private final int scanType=10;
0: 	private final int sortType=11;
0: 	private final int noOfOutputRowsBySorter=12;
1: 
1: 
1: 	/**
1: 	 * 
1: 	 * @param dburl
1: 	 * @param aSchema
1: 	 * @param aQuery
1: 	 */
0: 	public AccessDatabase(String dburl, String aSchema, String aQuery) {
1: 
0: 		dbURL = dburl;
1: 		schema = aSchema;
0: 		query = aQuery;
1: 
1: 	}
1: 
1: 	/**
1: 	 * 
1: 	 * @param aConn
1: 	 * @param aSchema
1: 	 * @param aQuery
1: 	 */
0: 	public AccessDatabase(Connection aConn, String aSchema, String aQuery) {
1: 
1: 		conn = aConn;
1: 		schema = aSchema;
0: 		query = aQuery;
1: 
1: 	}
1: 
1: 	/**
1: 	 * 
1: 	 * @throws InstantiationException
1: 	 * @throws IllegalAccessException
1: 	 * @throws ClassNotFoundException
1: 	 * @throws SQLException 
1: 	 */
0: 	public void createConnection() throws InstantiationException, IllegalAccessException, ClassNotFoundException, SQLException
1: 	{
1: 
0: 		if(dbURL.indexOf("//") != -1)
0: 			Class.forName("org.apache.derby.jdbc.ClientDriver").newInstance();
1: 
0: 		else
0: 			Class.forName("org.apache.derby.jdbc.EmbeddedDriver").newInstance();
1: 
1: 		//Get a connection
0: 		conn = DriverManager.getConnection(dbURL); 
1: 
1: 	}
1: 
1: 	/**
1: 	 * <p>
1: 	 * This method creates the queries such that after execution
1: 	 * of the query it will return XML data fragments.
1: 	 * </P>
1: 	 * @throws SQLException
1: 	 * */
1: 	public void createXMLFragment() throws SQLException{
1: 		createXMLData(
1: 				"select 'id=\"' ||RS_ID|| '\"' " +
0: 				"from "+schema+".SYSXPLAIN_RESULTSETS " +
0: 				"where STMT_ID = '"+query+"'", id);
1: 
1: 		createXMLData(
1: 				"select PARENT_RS_ID "+
0: 				"from "+schema+".SYSXPLAIN_RESULTSETS " +
0: 				"where STMT_ID = '"+query+"'", p_id);
1: 
1: 		createXMLData(
1: 				"select 'name=\"' ||OP_IDENTIFIER|| '\"' " +
0: 				"from "+schema+".SYSXPLAIN_RESULTSETS " +
0: 				"where STMT_ID = '"+query+"'", nodeType);
1: 
1: 		createXMLData(
1: 				"select 'no_opens=\"' " +
1: 				"|| TRIM(CHAR(NO_OPENS))|| '\"' " +
0: 				"from "+schema+".SYSXPLAIN_RESULTSETS " +
0: 				"where STMT_ID = '"+query+"'", noOfOpens);
1: 
1: 		createXMLData(
1: 				"select 'input_rows=\"' " +
1: 				"|| TRIM(CHAR(INPUT_ROWS))|| '\"' " +
0: 				"from "+schema+".SYSXPLAIN_RESULTSETS " +
0: 				"where STMT_ID = '"+query+"'", inputRows);
1: 
1: 		createXMLData(
1: 				"select 'returned_rows=\"' " +
1: 				"|| TRIM(CHAR(RETURNED_ROWS))|| '\"' " +
0: 				"from "+schema+".SYSXPLAIN_RESULTSETS " +
0: 				"where STMT_ID = '"+query+"'", returnedRows);
1: 
1: 		createXMLData(
1: 				"select 'visited_pages=\"'" +
1: 				"|| TRIM(CHAR(NO_VISITED_PAGES))|| '\"' " +
0: 				"from ("+schema+".SYSXPLAIN_SCAN_PROPS " +
0: 				"NATURAL RIGHT OUTER JOIN "+schema+".SYSXPLAIN_RESULTSETS) " +
0: 				"where STMT_ID = '"+query+"'", visitedPages);
1: 
1: 		createXMLData(
1: 				"select 'scan_qualifiers=\"'"+ 
1: 				"||SCAN_QUALIFIERS|| '\"' " +
0: 				"from ("+schema+".SYSXPLAIN_SCAN_PROPS " +
0: 				"NATURAL RIGHT OUTER JOIN "+schema+".SYSXPLAIN_RESULTSETS) " +
0: 				"where STMT_ID = '"+query+"'", scanQualifiers);
1: 
1: 		createXMLData(
1: 				"select 'next_qualifiers=\"'"+
1: 				"||NEXT_QUALIFIERS|| '\"' " +
0: 				"from ("+schema+".SYSXPLAIN_SCAN_PROPS " +
0: 				"NATURAL RIGHT OUTER JOIN "+schema+".SYSXPLAIN_RESULTSETS) " +
0: 				"where STMT_ID = '"+query+"'", nextQualifiers);
1: 
1: 		createXMLData(
1: 				"select 'scanned_object=\"'"+
1: 				"||SCAN_OBJECT_NAME|| '\"' " +
0: 				"from ("+schema+".SYSXPLAIN_SCAN_PROPS " +
0: 				"NATURAL RIGHT OUTER JOIN "+schema+".SYSXPLAIN_RESULTSETS) " +
0: 				"where STMT_ID = '"+query+"'", scannedObject);
1: 
1: 		createXMLData(
1: 				"select 'scan_type=\"'"+
1: 				"||TRIM(SCAN_TYPE)|| '\"' " +
0: 				"from ("+schema+".SYSXPLAIN_SCAN_PROPS " +
0: 				"NATURAL RIGHT OUTER JOIN "+schema+".SYSXPLAIN_RESULTSETS) " +
0: 				"where STMT_ID = '"+query+"'", scanType);
1: 
1: 		createXMLData(
1: 				"select 'sort_type=\"'"+
1: 				"||TRIM(SORT_TYPE)|| '\"' " +
0: 				"from ("+schema+".SYSXPLAIN_SORT_PROPS " +
0: 				"NATURAL RIGHT OUTER JOIN "+schema+".SYSXPLAIN_RESULTSETS) " +
0: 				"where STMT_ID = '"+query+"'", sortType);
1: 
1: 		createXMLData(
1: 				"select 'sorter_output=\"'"+
1: 				"||TRIM(CHAR(NO_OUTPUT_ROWS))|| '\"' " +
0: 				"from ("+schema+".SYSXPLAIN_SORT_PROPS " +
0: 				"NATURAL RIGHT OUTER JOIN "+schema+".SYSXPLAIN_RESULTSETS) " +
0: 				"where STMT_ID = '"+query+"'", noOfOutputRowsBySorter);
1: 
1: 	}
1: 
1: 	/**
1: 	 * 
1: 	 * @return all xml elements as a String
1: 	 */
1: 	public String getXmlString(){
1: 
1: 		for(int i=0;i<data.length;i++){
1: 			//assume only one root element for any query
0: 			if(Integer.parseInt(data[i].getDepth())==0){//root element
1: 				xmlDetails += indent(1);
1: 				xmlDetails += data[i].toString();
1: 				getChildren(1, data[i].getId());
1: 				xmlDetails += indent(1)+"</node>\n";
1: 				break;
1: 			}
1: 		}
1: 		return xmlDetails;
1: 	}
1: 
1: 	/**
1: 	 * 
1: 	 * @param currentLevel level of the XML tree (0 based) of current node
1: 	 * @param id current node's stmt_id
1: 	 */
0: 	public void getChildren(int currentLevel,String id ){
1: 		if(currentLevel <= depth){
1: 			for(int i=0;i<data.length;i++){
0: 				if(Integer.parseInt(data[i].getDepth())== currentLevel &&
1: 						(id.indexOf(data[i].getParent()) != -1))
1: 				{
1: 					xmlDetails += indent(currentLevel+1);
1: 					xmlDetails += data[i].toString();
1: 					getChildren(currentLevel+1, data[i].getId());
1: 					xmlDetails += indent(currentLevel+1)+"</node>\n";
1: 				}
1: 			}
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * 
1: 	 * @param j indent needed
1: 	 * @return indent as a string
1: 	 */
1: 	public String indent(int j){
1: 		String str="";
1: 		for(int i=0;i<=j+1;i++)
0: 			str +="	";
1: 
1: 		return str;
1: 	}
1: 
1: 	/**
1: 	 * marking the depth of each element
1: 	 */
1: 	public void markTheDepth(){
1: 		int i=0;
1: 		while(data[i].getParent().indexOf("null")== -1)
1: 			i++;
0: 		data[i].setDepth(""+depth); //root
1: 		findChildren(i,depth);
1: 	}
1: 
1: 	/**
1: 	 * 
1: 	 * @param idx current element's index
1: 	 * @param dep current examining depth
1: 	 */
0: 	public void findChildren(int idx, int dep) {
1: 		if(dep>depth)
1: 			depth =dep;
1: 
1: 		for(int i=0;i<data.length;i++){
1: 
1: 			if(data[i].getParent().indexOf("null")== -1){ 
1: 				if((data[idx].getId()).indexOf(data[i].getParent()) != -1
1: 						&& i != idx)
1: 				{
0: 					data[i].setDepth(""+(dep +1));
1: 					findChildren(i,dep+1);	 
1: 				}		
1: 			}
1: 		}
1: 	}
1: 
1: 
1: 	/**
1: 	 * 
1: 	 * @return whether the initialization is successful or not
1: 	 * @throws SQLException 
1: 	 */
1: 	public boolean initializeDataArray() throws SQLException{
1: 		if(noOfNodes()==0)
1: 			return false;
1: 		else{
1: 			data = new TreeNode[noOfNodes()];
1: 			for(int i=0; i<data.length;i++){
1: 				data[i] = new TreeNode();
1: 			}
1: 			return true;
1: 		}
1: 
1: 	}
1: 
1: 	/**
1: 	 * 
1: 	 * @param qry query to be executed
1: 	 * @throws SQLException 
1: 	 */
1: 	private void createXMLData(String qry, int x) throws SQLException{
1: 
0: 		stmt = conn.createStatement();
0: 		ResultSet results = stmt.executeQuery(qry);
1: 
1: 		int i=0;
1: 		while(results.next())
1: 		{
1: 			String text= results.getString(1);
1: 			if(text != null){
1: 				switch(x){
0: 				case id: 
1: 					data[i].setId(text+" ");
1: 					break;
0: 				case p_id:
1: 					data[i].setParent(text);
1: 					break;
0: 				case nodeType:
1: 					data[i].setNodeType(text+" ");
1: 					break;
0: 				case noOfOpens:
1: 					data[i].setNoOfOpens(text+" ");
1: 					break;
0: 				case inputRows:
1: 					data[i].setInputRows(text+" ");
1: 					break;
0: 				case returnedRows:
1: 					data[i].setReturnedRows(text+" ");
1: 					break;
0: 				case visitedPages:
1: 					data[i].setVisitedPages(text+" ");
1: 					break;	
0: 				case scanQualifiers:
1: 					data[i].setScanQualifiers(text+" ");
1: 					break;
0: 				case nextQualifiers:
1: 					data[i].setNextQualifiers(text+" ");
1: 					break;
0: 				case scannedObject:
1: 					data[i].setScannedObject(text+" ");
1: 					break;
0: 				case scanType:
1: 					data[i].setScanType(text+" ");
1: 					break;
0: 				case sortType:
1: 					data[i].setSortType(text+" ");
1: 					break;
0: 				case noOfOutputRowsBySorter:
1: 					data[i].setSorterOutput(text+" ");
1: 					break;
1: 				}
1: 			}
1: 			else{
1: 				/*Other attributes are omitted from the xml document 
1: 				 * if they're null.
0: 				 * p_id can be null at the root.
1: 				 * */
1: 				switch(x){
0: 				case p_id:
1: 					data[i].setParent(text+"");
1: 					break;
1: 				}
1: 			}
1: 			i++;	 
1: 		}
1: 		results.close();
0: 		stmt.close();
1: 	}
1: 
1: 	/**
1: 	 * 
1: 	 * @return total # of nodes
1: 	 * @throws SQLException 
1: 	 */
0: 	public int noOfNodes() throws SQLException{
1: 
0: 		stmt = conn.createStatement();
0: 		ResultSet results = stmt.executeQuery(
0: 				"select count(*) from " +
0: 				""+schema+".SYSXPLAIN_RESULTSETS " +
0: 				"where STMT_ID = '"+query+"'");
1: 		results.next();
1: 		int no = results.getInt(1);
1: 		results.close();
0: 		stmt.close();
1: 		return no;
1: 	}
1: 
1: 
1: 	/**
1: 	 * 
0: 	 * @return the <statement> element
1: 	 * @throws SQLException 
1: 	 */
1: 	public String statement() throws SQLException{
0: 		stmt = conn.createStatement();
0: 		ResultSet results = stmt.executeQuery(
0: 				"select STMT_TEXT "+
0: 				"from "+schema+".SYSXPLAIN_STATEMENTS " +
0: 				"where STMT_ID = '"+query+"'");
1: 		results.next();
1: 		String statement = results.getString(1);
1: 		results.close();
0: 		stmt.close();
0: 		/*Removing possible less than and greater than characters
0: 		 * in a query statement with XML representation.*/
0: 		if(statement.indexOf('<')!= -1){
0: 			statement = replace(statement, "<","&lt;");
1: 		}
0: 		if(statement.indexOf('>')!= -1){
0: 			statement = replace(statement, ">","&gt;");
1: 		}
1: 		return "<statement>"+statement+"</statement>\n";
1: 	}
1: 
1: 	/**
1: 	 * 
0: 	 * @param stmt statement to be changed
0: 	 * @param expr string to be removed
0: 	 * @param replace string to be added
0: 	 * @return modified string
1: 	 */
0: 	public String replace(String stmt, String expr, String replace){
0: 		String[] part=stmt.split(expr);
0: 		String newStmt= part[0];
0: 		for(int i=1;i<part.length;i++){
0: 			newStmt += " "+replace+" "+part[i];
1: 		}
1: 
0: 		return newStmt;
1: 	}
1: 
1: 	/**
0: 	 * shut downing the connection to the database
1: 	 */
0: 	public void shutdown()
1: 	{
1: 		try
1: 		{
0: 			if (stmt != null)
1: 			{
0: 				stmt.close();
1: 			}
1: 			if (conn != null)
1: 			{
0: 				DriverManager.getConnection(dbURL + ";shutdown=true");
1: 				conn.close();
1: 			}           
1: 		}
1: 		catch (SQLException sqlExcept){}
1: 	}
1: 
1: 	/**
1: 	 * 
1: 	 * @return data array of TreeNode Objects 
1: 	 */
1: 	public TreeNode[] getData() {
0: 		return data;
1: 	}
1: }
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:782dbe1
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derby.impl.tools.planexporter.AccessDatabase
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
commit:ce855d2
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: /**
0:  * This class will perform the database connection establishment,
0:  * querying the database, shut downing the database.
0:  * Created under DERBY-4587-PlanExporter tool
1:  */
0:     private Connection conn = null;
0:     private Statement stmt = null;
0:     private TreeNode[] data;
0:     private String dbURL = null;
0:     private String schema = null;
0:     private String query = null;
1:     /**
0:      * @param query the stmt_id to set
1:      */
0:     public void setQuery(String query) {
0:         this.query = query;
0:     }
1:     /**
1:      * @return the stmt_id
1:      */
1:     public String getQuery() {
1:         return query;
0:     }
0:     private int depth = 0;
0:     public int getDepth() {
0:         return depth;
0:     }
0:     private String xmlDetails="";
0:     //set of variables to identify values of XPlain tables
1:     private static final int ID =0 ;
1:     private static final int P_ID =1;
1:     private static final int NODE_TYPE=2;
1:     private static final int NO_OF_OPENS=3;
1:     private static final int INPUT_ROWS=4;
1:     private static final int RETURNED_ROWS=5;
1:     private static final int VISITED_PAGES=6;
1:     private static final int SCAN_QUALIFIERS=7;
1:     private static final int NEXT_QUALIFIERS=8;
1:     private static final int SCANNED_OBJECT=9;
1:     private static final int SCAN_TYPE=10;
1:     private static final int SORT_TYPE=11;
1:     private static final int NO_OF_OUTPUT_ROWS_BY_SORTER=12;
1:     /**
1:      *
0:      * @param dburl
0:      * @param aSchema
0:      * @param aQuery
1:      */
0:     public AccessDatabase(String dburl, String aSchema, String aQuery) {
0:         dbURL = dburl;
0:         schema = aSchema;
0:         setQuery(aQuery);
0:     }
1:     /**
1:      *
0:      * @param aConn
0:      * @param aSchema
0:      * @param aQuery
1:      *
1:      */
0:     public AccessDatabase(Connection aConn, String aSchema, String aQuery) {
0:         conn = aConn;
0:         schema = aSchema;
0:         setQuery(aQuery);
0:     }
1:     /**
1:      *
0:      * @throws InstantiationException
0:      * @throws IllegalAccessException
0:      * @throws ClassNotFoundException
1:      * @throws SQLException
1:      */
0:     public void createConnection() throws InstantiationException, IllegalAccessException, ClassNotFoundException, SQLException
0:     {
0:         if(dbURL.indexOf("://") != -1)
0:             Class.forName("org.apache.derby.jdbc.ClientDriver").newInstance();
0:         else
0:             Class.forName("org.apache.derby.jdbc.EmbeddedDriver").newInstance();
0:         //Get a connection
0:         conn = DriverManager.getConnection(dbURL);
0:     }
1:     /**
0:      * <p>
0:      * This method creates the queries such that after execution
0:      * of the query it will return XML data fragments.
0:      * </P>
1:      * @throws SQLException
0:      * */
0:     public void createXMLFragment() throws SQLException{
0:         createXMLData(
0:                 "select 'id=\"' ||RS_ID|| '\"' " +
0:                 "from "+schema+".SYSXPLAIN_RESULTSETS " +
0:                 "where STMT_ID = '"+getQuery()+"'", ID);
0:         createXMLData(
0:                 "select PARENT_RS_ID "+
0:                 "from "+schema+".SYSXPLAIN_RESULTSETS " +
0:                 "where STMT_ID = '"+getQuery()+"'", P_ID);
0:         createXMLData(
0:                 "select 'name=\"' ||OP_IDENTIFIER|| '\"' " +
0:                 "from "+schema+".SYSXPLAIN_RESULTSETS " +
0:                 "where STMT_ID = '"+getQuery()+"'", NODE_TYPE);
0:         createXMLData(
0:                 "select 'no_opens=\"' " +
0:                 "|| TRIM(CHAR(NO_OPENS))|| '\"' " +
0:                 "from "+schema+".SYSXPLAIN_RESULTSETS " +
0:                 "where STMT_ID = '"+getQuery()+"'", NO_OF_OPENS);
0:         createXMLData(
0:                 "select 'input_rows=\"' " +
0:                 "|| TRIM(CHAR(INPUT_ROWS))|| '\"' " +
0:                 "from "+schema+".SYSXPLAIN_RESULTSETS " +
0:                 "where STMT_ID = '"+getQuery()+"'", INPUT_ROWS);
0:         createXMLData(
0:                 "select 'returned_rows=\"' " +
0:                 "|| TRIM(CHAR(RETURNED_ROWS))|| '\"' " +
0:                 "from "+schema+".SYSXPLAIN_RESULTSETS " +
0:                 "where STMT_ID = '"+getQuery()+"'", RETURNED_ROWS);
0:         createXMLData(
0:                 "select 'visited_pages=\"'" +
0:                 "|| TRIM(CHAR(NO_VISITED_PAGES))|| '\"' " +
0:                 "from ("+schema+".SYSXPLAIN_SCAN_PROPS " +
0:                 "NATURAL RIGHT OUTER JOIN "+schema+".SYSXPLAIN_RESULTSETS) " +
0:                 "where STMT_ID = '"+getQuery()+"'", VISITED_PAGES);
0:         createXMLData(
0:                 "select 'scan_qualifiers=\"'"+
0:                 "||SCAN_QUALIFIERS|| '\"' " +
0:                 "from ("+schema+".SYSXPLAIN_SCAN_PROPS " +
0:                 "NATURAL RIGHT OUTER JOIN "+schema+".SYSXPLAIN_RESULTSETS) " +
0:                 "where STMT_ID = '"+getQuery()+"'", SCAN_QUALIFIERS);
0:         createXMLData(
0:                 "select 'next_qualifiers=\"'"+
0:                 "||NEXT_QUALIFIERS|| '\"' " +
0:                 "from ("+schema+".SYSXPLAIN_SCAN_PROPS " +
0:                 "NATURAL RIGHT OUTER JOIN "+schema+".SYSXPLAIN_RESULTSETS) " +
0:                 "where STMT_ID = '"+getQuery()+"'", NEXT_QUALIFIERS);
0:         createXMLData(
0:                 "select 'scanned_object=\"'"+
0:                 "||SCAN_OBJECT_NAME|| '\"' " +
0:                 "from ("+schema+".SYSXPLAIN_SCAN_PROPS " +
0:                 "NATURAL RIGHT OUTER JOIN "+schema+".SYSXPLAIN_RESULTSETS) " +
0:                 "where STMT_ID = '"+getQuery()+"'", SCANNED_OBJECT);
0:         createXMLData(
0:                 "select 'scan_type=\"'"+
0:                 "||TRIM(SCAN_TYPE)|| '\"' " +
0:                 "from ("+schema+".SYSXPLAIN_SCAN_PROPS " +
0:                 "NATURAL RIGHT OUTER JOIN "+schema+".SYSXPLAIN_RESULTSETS) " +
0:                 "where STMT_ID = '"+getQuery()+"'", SCAN_TYPE);
0:         createXMLData(
0:                 "select 'sort_type=\"'"+
0:                 "||TRIM(SORT_TYPE)|| '\"' " +
0:                 "from ("+schema+".SYSXPLAIN_SORT_PROPS " +
0:                 "NATURAL RIGHT OUTER JOIN "+schema+".SYSXPLAIN_RESULTSETS) " +
0:                 "where STMT_ID = '"+getQuery()+"'", SORT_TYPE);
0:         createXMLData(
0:                 "select 'sorter_output=\"'"+
0:                 "||TRIM(CHAR(NO_OUTPUT_ROWS))|| '\"' " +
0:                 "from ("+schema+".SYSXPLAIN_SORT_PROPS " +
0:                 "NATURAL RIGHT OUTER JOIN "+schema+".SYSXPLAIN_RESULTSETS) " +
0:                 "where STMT_ID = '"+getQuery()+"'", NO_OF_OUTPUT_ROWS_BY_SORTER);
0:     }
1:     /**
1:      * Generating the XML tree
0:      * @return all xml elements as a String
1:      */
0:     public String getXmlString(){
0:         for(int i=0;i<data.length;i++){
0:             //assume only one root element for any query
1:             if(data[i].getDepth()==0){//root element
0:                 xmlDetails += indent(1);
0:                 xmlDetails += data[i].toString();
0:                 getChildren(1, data[i].getId());
0:                 xmlDetails += indent(1)+"</node>\n";
0:                 break;
0:             }
0:         }
0:         return xmlDetails;
0:     }
1:     /**
1:      *
0:      * @param currentLevel level of the XML tree (0 based) of current node
0:      * @param id current node's stmt_id
1:      */
1:     private void getChildren(int currentLevel,String id ){
0:         if(currentLevel <= depth){
0:             for(int i=0;i<data.length;i++){
1:                 if(data[i].getDepth()== currentLevel &&
0:                         (id.indexOf(data[i].getParent()) != -1))
0:                 {
0:                     xmlDetails += indent(currentLevel+1);
0:                     xmlDetails += data[i].toString();
0:                     getChildren(currentLevel+1, data[i].getId());
0:                     xmlDetails += indent(currentLevel+1)+"</node>\n";
0:                 }
0:             }
0:         }
0:     }
1:     /**
1:      *
0:      * @param j indent needed
0:      * @return indent as a string
1:      */
0:     public String indent(int j){
0:         String str="";
0:         for(int i=0;i<=j+1;i++)
1:             str +="    ";
0:         return str;
0:     }
1:     /**
0:      * marking the depth of each element
1:      */
0:     public void markTheDepth(){
0:         int i=0;
0:         while(data[i].getParent().indexOf("null")== -1)
0:             i++;
1:         data[i].setDepth(depth); //root
0:         findChildren(i,depth);
0:     }
1:     /**
1:      *
0:      * @param idx current element's index
0:      * @param dep current examining depth
1:      */
1:     private void findChildren(int idx, int dep) {
0:         if(dep>depth)
0:             depth =dep;
0:         for(int i=0;i<data.length;i++){
0:             if(data[i].getParent().indexOf("null")== -1){
0:                 if((data[idx].getId()).indexOf(data[i].getParent()) != -1
0:                         && i != idx)
0:                 {
1:                     data[i].setDepth(dep +1);
0:                     findChildren(i,dep+1);
0:                 }
0:             }
0:         }
0:     }
1:     /**
1:      *
0:      * @return whether the initialization is successful or not
1:      * @throws SQLException
1:      */
0:     public boolean initializeDataArray() throws SQLException{
0:         if(noOfNodes()==0)
0:             return false;
0:         else{
0:             data = new TreeNode[noOfNodes()];
0:             for(int i=0; i<data.length;i++){
0:                 data[i] = new TreeNode();
0:             }
0:             return true;
0:         }
0:     }
1:     /**
1:      *
0:      * @param qry query to be executed
1:      * @throws SQLException
1:      */
0:     private void createXMLData(String qry, int x) throws SQLException{
0:         stmt = conn.createStatement();
0:         ResultSet results = stmt.executeQuery(qry);
0:         int i=0;
0:         while(results.next())
0:         {
0:             String text= results.getString(1);
0:             if(text != null){
0:                 switch(x){
1:                 case ID:
0:                     data[i].setId(text+" ");
0:                     break;
1:                 case P_ID:
0:                     data[i].setParent(text);
0:                     break;
1:                 case NODE_TYPE:
0:                     data[i].setNodeType(text+" ");
0:                     break;
1:                 case NO_OF_OPENS:
0:                     data[i].setNoOfOpens(text+" ");
0:                     break;
1:                 case INPUT_ROWS:
0:                     data[i].setInputRows(text+" ");
0:                     break;
1:                 case RETURNED_ROWS:
0:                     data[i].setReturnedRows(text+" ");
0:                     break;
1:                 case VISITED_PAGES:
0:                     data[i].setVisitedPages(text+" ");
0:                     break;
1:                 case SCAN_QUALIFIERS:
0:                     data[i].setScanQualifiers(text+" ");
0:                     break;
1:                 case NEXT_QUALIFIERS:
0:                     data[i].setNextQualifiers(text+" ");
0:                     break;
1:                 case SCANNED_OBJECT:
0:                     data[i].setScannedObject(text+" ");
0:                     break;
1:                 case SCAN_TYPE:
0:                     data[i].setScanType(text+" ");
0:                     break;
1:                 case SORT_TYPE:
0:                     data[i].setSortType(text+" ");
0:                     break;
1:                 case NO_OF_OUTPUT_ROWS_BY_SORTER:
0:                     data[i].setSorterOutput(text+" ");
0:                     break;
0:                 }
0:             }
0:             else{
0:                 /*Other attributes are omitted from the xml document
0:                  * if they're null.
1:                  * P_ID can be null at the root.
0:                  * */
0:                 switch(x){
1:                 case P_ID:
0:                     data[i].setParent(text+"");
0:                     break;
0:                 }
0:             }
0:             i++;
0:         }
1:         results.close();
0:         stmt.close();
0:     }
1:     /**
1:      *
0:      * @return total # of nodes
1:      * @throws SQLException
1:      */
1:     private int noOfNodes() throws SQLException{
0:         stmt = conn.createStatement();
0:         ResultSet results = stmt.executeQuery(
0:                 "select count(*) from " +
0:                 ""+schema+".SYSXPLAIN_RESULTSETS " +
0:                 "where STMT_ID = '"+getQuery()+"'");
1:         results.next();
0:         int no = results.getInt(1);
1:         results.close();
0:         stmt.close();
0:         return no;
0:     }
1:     /**
1:      *
1:      * @return the &lt;statement&gt; element
1:      * @throws SQLException
1:      */
0:     public String statement() throws SQLException{
0:         stmt = conn.createStatement();
0:         ResultSet results = stmt.executeQuery(
0:                 "select STMT_TEXT "+
0:                 "from "+schema+".SYSXPLAIN_STATEMENTS " +
0:                 "where STMT_ID = '"+getQuery()+"'");
1:         results.next();
0:         String statement = results.getString(1);
1:         results.close();
0:         stmt.close();
0:         /*Removing possible less than and greater than characters
0:          * in a query statement with XML representation.*/
0:         if(statement.indexOf('<')!= -1){
0:             statement = replace(statement, "<","&lt;");
0:         }
0:         if(statement.indexOf('>')!= -1){
0:             statement = replace(statement, ">","&gt;");
0:         }
0:         return "<statement>"+statement+"</statement>\n";
0:     }
1:     /**
1:      *
0:      * @param stmt statement to be changed
0:      * @param expr string to be removed
0:      * @param replace string to be added
0:      * @return modified string
1:      */
0:     private String replace(String stmt, String expr, String replace){
0:         String[] part=stmt.split(expr);
0:         String newStmt= part[0];
0:         for(int i=1;i<part.length;i++){
0:             newStmt += " "+replace+" "+part[i];
0:         }
0:         return newStmt;
0:     }
1:     /**
1:      *
1:      * @return XPLAIN_TIME of SYSXPLAIN_STATEMENTS
1:      * @throws SQLException
1:      */
1:     public String time() throws SQLException{
0:         stmt = conn.createStatement();
0:         ResultSet results = stmt.executeQuery(
1:                 "select '<time>'||TRIM(CHAR(XPLAIN_TIME))||" +
0:                 "'</time>' from "+schema+".SYSXPLAIN_STATEMENTS " +
0:                 "where STMT_ID = '"+getQuery()+"'");
1:         results.next();
1:         String time = results.getString(1);
1:         results.close();
0:         stmt.close();
0:         return time;
0:     }
0: 
1:     /**
1:      *
1:      * @return stmt_id as a XML element
1:      */
1:     public String stmtID(){
0:         return "<stmt_id>"+getQuery()+"</stmt_id>";
0:     }
0: 
1:     /**
1:      * closing the connection to the database
1:      */
1:     public void closeConnection()
0:     {
0:         try
0:         {
0:             if (stmt != null)
0:             {
0:                 stmt.close();
0:             }
0:             if (conn != null)
0:             {
0:                 conn.close();
0:             }
0:         }
0:         catch (SQLException sqlExcept){}
0:     }
0: 
1:     /**
1:      *
0:      * @return data array of TreeNode Objects
1:      */
0:     public TreeNode[] getData() {
0:         return data;
0:     }
commit:82d6586
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 	/**
0: 	 * @param query the stmt_id to set
0: 	 */
0: 	public void setQuery(String query) {
0: 		this.query = query;
0: 	}
0: 
0: 	/**
0: 	 * @return the stmt_id
0: 	 */
0: 	public String getQuery() {
0: 		return query;
0: 	}
/////////////////////////////////////////////////////////////////////////
0: 	private static final int ID =0 ;
0: 	private static final int P_ID =1;
0: 	private static final int NODE_TYPE=2;
0: 	private static final int NO_OF_OPENS=3;
0: 	private static final int INPUT_ROWS=4;
0: 	private static final int RETURNED_ROWS=5;
0: 	private static final int VISITED_PAGES=6;
0: 	private static final int SCAN_QUALIFIERS=7;
0: 	private static final int NEXT_QUALIFIERS=8;
0: 	private static final int SCANNED_OBJECT=9;
0: 	private static final int SCAN_TYPE=10;
0: 	private static final int SORT_TYPE=11;
0: 	private static final int NO_OF_OUTPUT_ROWS_BY_SORTER=12;
/////////////////////////////////////////////////////////////////////////
0: 		setQuery(aQuery);
/////////////////////////////////////////////////////////////////////////
0: 	 *
0: 		setQuery(aQuery);
/////////////////////////////////////////////////////////////////////////
0: 		if(dbURL.indexOf("://") != -1)
/////////////////////////////////////////////////////////////////////////
0: 				"where STMT_ID = '"+getQuery()+"'", ID);
0: 				"where STMT_ID = '"+getQuery()+"'", P_ID);
0: 				"where STMT_ID = '"+getQuery()+"'", NODE_TYPE);
0: 				"where STMT_ID = '"+getQuery()+"'", NO_OF_OPENS);
0: 				"where STMT_ID = '"+getQuery()+"'", INPUT_ROWS);
0: 				"where STMT_ID = '"+getQuery()+"'", RETURNED_ROWS);
0: 				"where STMT_ID = '"+getQuery()+"'", VISITED_PAGES);
0: 				"where STMT_ID = '"+getQuery()+"'", SCAN_QUALIFIERS);
0: 				"where STMT_ID = '"+getQuery()+"'", NEXT_QUALIFIERS);
0: 				"where STMT_ID = '"+getQuery()+"'", SCANNED_OBJECT);
0: 				"where STMT_ID = '"+getQuery()+"'", SCAN_TYPE);
0: 				"where STMT_ID = '"+getQuery()+"'", SORT_TYPE);
0: 				"where STMT_ID = '"+getQuery()+"'", NO_OF_OUTPUT_ROWS_BY_SORTER);
0: 	 * Generating the XML tree
0: 			if(data[i].getDepth()==0){//root element
/////////////////////////////////////////////////////////////////////////
0: 	private void getChildren(int currentLevel,String id ){
0: 				if(data[i].getDepth()== currentLevel &&
/////////////////////////////////////////////////////////////////////////
0: 		data[i].setDepth(depth); //root
/////////////////////////////////////////////////////////////////////////
0: 	private void findChildren(int idx, int dep) {
/////////////////////////////////////////////////////////////////////////
0: 					data[i].setDepth(dep +1);
/////////////////////////////////////////////////////////////////////////
0: 				case ID: 
0: 				case P_ID:
0: 				case NODE_TYPE:
0: 				case NO_OF_OPENS:
0: 				case INPUT_ROWS:
0: 				case RETURNED_ROWS:
0: 				case VISITED_PAGES:
0: 				case SCAN_QUALIFIERS:
0: 				case NEXT_QUALIFIERS:
0: 				case SCANNED_OBJECT:
0: 				case SCAN_TYPE:
0: 				case SORT_TYPE:
0: 				case NO_OF_OUTPUT_ROWS_BY_SORTER:
/////////////////////////////////////////////////////////////////////////
0: 				 * P_ID can be null at the root.
0: 				case P_ID:
/////////////////////////////////////////////////////////////////////////
0: 	private int noOfNodes() throws SQLException{
0: 				"where STMT_ID = '"+getQuery()+"'");
/////////////////////////////////////////////////////////////////////////
0: 	 * @return the &lt;statement&gt; element
/////////////////////////////////////////////////////////////////////////
0: 				"where STMT_ID = '"+getQuery()+"'");
/////////////////////////////////////////////////////////////////////////
0: 	private String replace(String stmt, String expr, String replace){
/////////////////////////////////////////////////////////////////////////
0: 	
0: 	/**
0: 	 * 
0: 	 * @return XPLAIN_TIME of SYSXPLAIN_STATEMENTS
0: 	 * @throws SQLException
0: 	 */
0: 	public String time() throws SQLException{
0: 		stmt = conn.createStatement();
0: 		ResultSet results = stmt.executeQuery(
0: 				"select '<time>'||TRIM(CHAR(XPLAIN_TIME))||" +
0: 				"'</time>' from "+schema+".SYSXPLAIN_STATEMENTS " +
0: 				"where STMT_ID = '"+getQuery()+"'");
0: 		results.next();
0: 		String time = results.getString(1);
0: 		results.close();
0: 		stmt.close();
0: 		
0: 		return time;
0: 	}
0: 	
0: 	/**
0: 	 * 
0: 	 * @return stmt_id as a XML element
0: 	 */
0: 	public String stmtID(){
0: 		return "<stmt_id>"+getQuery()+"</stmt_id>";
0: 	}
0: 	 * closing the connection to the database
0: 	public void closeConnection()
/////////////////////////////////////////////////////////////////////////
============================================================================