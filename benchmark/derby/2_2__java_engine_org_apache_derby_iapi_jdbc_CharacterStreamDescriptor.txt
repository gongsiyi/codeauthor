1:492f85a: /*
2:492f85a: 
1:492f85a:    Derby - Class org.apache.derby.iapi.jdbc.CharacterStreamDescriptor
1:492f85a: 
1:492f85a:    Licensed to the Apache Software Foundation (ASF) under one or more
1:492f85a:    contributor license agreements.  See the NOTICE file distributed with
1:492f85a:    this work for additional information regarding copyright ownership.
1:492f85a:    The ASF licenses this file to you under the Apache License, Version 2.0
1:492f85a:    (the "License"); you may not use this file except in compliance with
1:492f85a:    the License.  You may obtain a copy of the License at
1:492f85a: 
1:492f85a:       http://www.apache.org/licenses/LICENSE-2.0
1:492f85a: 
1:492f85a:    Unless required by applicable law or agreed to in writing, software
1:492f85a:    distributed under the License is distributed on an "AS IS" BASIS,
1:492f85a:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:492f85a:    See the License for the specific language governing permissions and
1:492f85a:    limitations under the License.
1:492f85a: 
1:492f85a:  */
1:492f85a: package org.apache.derby.iapi.jdbc;
1:492f85a: 
1:f07a7c3: import java.io.InputStream;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:f07a7c3: import org.apache.derby.iapi.types.PositionedStream;
1:492f85a: 
1:492f85a: /**
1:492f85a:  * A description of a byte stream representing characters. The description is
1:492f85a:  * used by decoders to properly configure themselves. Note that encoding is not
1:492f85a:  * included in the description, because all internal byte streams are expected
1:492f85a:  * to be using the modified UTF-8 encoding (see DataInput).
2:492f85a:  * <p>
1:e88c4ae:  * The information in the description is only guaranteed to be valid at the
1:492f85a:  * moment it is passed to the decoder object. As the decoder works on the
1:492f85a:  * stream, the information in the descriptor will be outdated.
1:492f85a:  * <p>
1:492f85a:  * To create a stream descriptor, obtain a {@code Builder} instance and set the
1:492f85a:  * required parameters.
1:492f85a:  *
1:492f85a:  * @see Builder
1:492f85a:  */
1:492f85a: //@Immutable
1:492f85a: public class CharacterStreamDescriptor {
1:492f85a: 
1:492f85a:     /**
1:492f85a:      * Constant for the character position, when it is positioned before the
1:492f85a:      * first character in the stream (i.e. at the very beginning of the stream
1:492f85a:      * or in the header).
1:492f85a:      */
1:492f85a:     public static final long BEFORE_FIRST = 0;
1:492f85a: 
1:492f85a:     /** First data byte in the byte stream. */
1:492f85a:     private final long dataOffset;
1:492f85a:     /** The current byte position. */
1:492f85a:     private final long curBytePos;
1:492f85a:     /** The current character position. */
1:492f85a:     private final long curCharPos;
1:492f85a:     /** The byte length of the stream, {@code 0} if unknown. */
1:492f85a:     private final long byteLength;
1:492f85a:     /** The character length of the stream, {@code 0} if unknown. */
1:492f85a:     private final long charLength;
1:492f85a:     /** The maximum allowed character length. */
1:492f85a:     private final long maxCharLength;
1:492f85a:     /** Tells if the stream can be buffered or not. */
1:492f85a:     private final boolean bufferable;
1:492f85a:     /** Tells if the stream is aware of its own position. */
1:492f85a:     private final boolean positionAware;
1:f07a7c3:     /** Reference to the stream we are describing. */
1:f07a7c3:     private final InputStream stream;
1:492f85a: 
1:492f85a:     /**
1:492f85a:      * Creates a character stream descriptor, using the supplied builder.
1:492f85a:      * <p>
1:492f85a:      * Use the builder to create instances of this class.
1:492f85a:      *
1:492f85a:      * @param b object builder
1:492f85a:      * @see Builder
1:492f85a:      */
1:492f85a:     private CharacterStreamDescriptor(Builder b) {
1:492f85a:         bufferable = b.bufferable;
1:492f85a:         positionAware = b.positionAware;
1:492f85a:         dataOffset = b.dataOffset;
1:492f85a:         curBytePos = b.curBytePos;
1:492f85a:         curCharPos = b.curCharPos;
1:492f85a:         byteLength = b.byteLength;
1:492f85a:         charLength = b.charLength;
1:492f85a:         maxCharLength = b.maxCharLength;
1:f07a7c3:         stream = b.stream;
1:492f85a:     }
1:492f85a: 
1:e88c4ae:     /**
1:492f85a:      * Tells if the described stream should be buffered or not.
1:492f85a:      * <p>
1:492f85a:      * Some of the reasons a stream should not be buffered at this level, are
1:492f85a:      * the stream is already buffered, or it serves bytes directly from a byte
1:492f85a:      * array in memory.
1:492f85a:      *
1:492f85a:      * @return {@code true} if the stream should be buffered for improved
1:492f85a:      *      performance, {@code false} if it should not be buffered.
1:492f85a:      */
1:492f85a:     public boolean isBufferable() {
1:492f85a:         return bufferable;
1:492f85a:     }
1:492f85a: 
1:492f85a:     /**
1:492f85a:      * Tells if the described stream is aware of its own position, and that it
1:e88c4ae:      * can reposition itself on request.
1:492f85a:      *
1:492f85a:      * @return {@code true} if the stream is position aware, @{code false}
1:492f85a:      *      otherwise.
1:492f85a:      */
1:492f85a:     public boolean isPositionAware() {
1:492f85a:         return positionAware;
1:492f85a:     }
1:492f85a: 
1:492f85a:     public long getByteLength() {
1:492f85a:         return byteLength;
1:492f85a:     }
1:492f85a: 
1:492f85a:     public long getCharLength() {
1:492f85a:         return charLength;
1:492f85a:     }
1:492f85a: 
1:492f85a:     public long getCurBytePos() {
1:492f85a:         return curBytePos;
1:492f85a:     }
1:492f85a: 
1:492f85a:     /**
1:492f85a:      * Returns the current character position.
1:492f85a:      *
1:492f85a:      * @return The current character position, where the first character is at
1:492f85a:      *      position {@code 1}, or {@code BEFORE_FIRST} if the stream is
1:492f85a:      *      positioned before the first character.
1:492f85a:      */
1:492f85a:     public long getCurCharPos() {
1:492f85a:         return curCharPos;
1:492f85a:     }
1:492f85a: 
1:492f85a:     /**
1:492f85a:      * Returns the first index of the described stream that contains real data.
1:492f85a:      * <p>
1:492f85a:      * The information is typically used to filter out meta data at the head of
1:492f85a:      * the stream, and to correctly reset the stream.
1:492f85a:      *
1:492f85a:      * @return The first position in the stream containing real data.
1:492f85a:      */
1:492f85a:     public long getDataOffset() {
1:492f85a:         return dataOffset;
1:492f85a:     }
1:492f85a: 
1:492f85a:     /**
1:492f85a:      * Returns the imposed maximum character length on the described stream.
1:492f85a:      * <p>
1:492f85a:      * The default value is {@code Long.MAX_VALUE}.
1:492f85a:      *
1:492f85a:      * @return The max allowed character length of the stream, or {@code 0} if
1:492f85a:      *      no limit has been set.
1:492f85a:      */
1:492f85a:     public long getMaxCharLength() {
1:492f85a:         return maxCharLength;
1:492f85a:     }
1:f07a7c3: 
1:492f85a:     /**
1:f07a7c3:      * Returns the associated stream.
1:492f85a:      *
1:f07a7c3:      * @return An {@code InputStream} reference.
1:492f85a:      */
1:f07a7c3:     public InputStream getStream() {
1:f07a7c3:         return stream;
1:f07a7c3:     }
1:f07a7c3: 
1:f07a7c3:     /**
1:f07a7c3:      * Returns the associated positioned stream, if the stream is position
1:f07a7c3:      * aware.
1:f07a7c3:      *
1:f07a7c3:      * @return A {@code PositionedStream} reference.
1:f07a7c3:      * @throws ClassCastException if the stream cannot be cast to
1:f07a7c3:      *      {@code PositionedStream}
1:f07a7c3:      * @throws IllegalArgumentException if the method is called and the
1:f07a7c3:      *      assoicated stream isn't described as position aware.
1:f07a7c3:      * @see #isPositionAware
1:f07a7c3:      */
1:f07a7c3:     public PositionedStream getPositionedStream() {
1:f07a7c3:         if (!positionAware) {
1:f07a7c3:             throw new IllegalStateException("stream is not position aware: " +
1:f07a7c3:                     stream.getClass().getName());
1:f07a7c3:         }
1:f07a7c3:         return (PositionedStream)stream;
1:492f85a:     }
1:492f85a: 
1:492f85a:     public String toString() {
1:492f85a:         return ("CharacterStreamDescriptor-" + hashCode() +"#bufferable=" +
1:492f85a:                 bufferable + ":positionAware=" +
1:492f85a:                 positionAware + ":byteLength=" + byteLength + ":charLength=" +
1:492f85a:                 charLength + ":curBytePos=" + curBytePos + ":curCharPos=" +
1:f07a7c3:                 curCharPos + ":dataOffset=" + dataOffset + ":stream=" +
1:f07a7c3:                 stream.getClass());
1:492f85a:     }
1:492f85a: 
1:492f85a:     /**
1:492f85a:      * The builder for the {@code CharacterStreamDescriptor} class. The builder
1:492f85a:      * is used to avoid having a large set of constructors. See the
1:492f85a:      * {@linkplain #build} method for pre-build field validation. Note that the
1:492f85a:      * validation is only performed in sane builds.
1:492f85a:      */
1:492f85a:     public static class Builder {
1:492f85a:  
1:492f85a:         /** Default max character length is unlimited. */
1:492f85a:         private static final long DEFAULT_MAX_CHAR_LENGTH = Long.MAX_VALUE;
1:492f85a: 
1:492f85a:         // See documentation for the fields in the CharacterStreamDescriptor
1:492f85a:         // class. The values below are the field defaults.
1:492f85a:         private boolean bufferable = false;
1:492f85a:         private boolean positionAware = false;
1:492f85a:         private long curBytePos = 0;
1:492f85a:         private long curCharPos = 1;
1:492f85a:         private long byteLength = 0;
1:492f85a:         private long charLength = 0;
1:492f85a:         private long dataOffset = 0;
1:492f85a:         private long maxCharLength = DEFAULT_MAX_CHAR_LENGTH;
1:f07a7c3:         private InputStream stream;
1:492f85a: 
1:492f85a:         /**
1:492f85a:          * Creates a builder object.
1:492f85a:          */
1:492f85a:         public Builder() {}
1:492f85a: 
1:e88c4ae:         /**
1:e88c4ae:          * Sets if the stream should be buffered, defaults to {@code false}.
1:e88c4ae:          *
1:e88c4ae:          * @param bufferable {@code true} if buffering is advised, {@code false}
1:e88c4ae:          *      if not
1:e88c4ae:          * @return The builder.
1:e88c4ae:          */
1:492f85a:         public Builder bufferable(boolean bufferable) {
1:492f85a:             this.bufferable = bufferable;
1:492f85a:             return this;
1:492f85a:         }
1:492f85a: 
1:f07a7c3:         /**
1:e88c4ae:          * Sets if the stream can reposition itself or not, defaults to
1:e88c4ae:          * {@code false}.
1:e88c4ae:          *
1:e88c4ae:          * @param positionAware {@code true} if the stream can reposition
1:e88c4ae:          *      itself, {@code false} if not
1:e88c4ae:          * @return The builder.
1:e88c4ae:          */
1:492f85a:         public Builder positionAware(boolean positionAware) {
1:492f85a:             this.positionAware = positionAware;
1:492f85a:             return this;
1:492f85a:         }
1:492f85a: 
1:e88c4ae:         /**
1:e88c4ae:          * Sets the current byte position, defaults to {@code 0}.
1:e88c4ae:          *
1:e88c4ae:          * @param pos the current byte position
1:e88c4ae:          * @return The builder.
1:e88c4ae:          */
1:492f85a:         public Builder curBytePos(long pos) {
1:492f85a:             this.curBytePos = pos;
1:492f85a:             return this;
1:492f85a:         }
1:492f85a: 
1:e88c4ae:         /**
1:e88c4ae:          * Sets the current character position, defaults to {@code 1}.
1:e88c4ae:          * <p>
1:e88c4ae:          * There is a special value for when the stream is position in the
1:e88c4ae:          * header area - {@code BEFORE_FIRST}.
1:e88c4ae:          *
1:e88c4ae:          * @param pos the current character position,starting at {@code 1}
1:e88c4ae:          * @return The builder.
1:e88c4ae:          * @see #BEFORE_FIRST
1:e88c4ae:          */
1:492f85a:         public Builder curCharPos(long pos) {
1:492f85a:             this.curCharPos = pos;
1:492f85a:             return this;
1:492f85a:         }
1:492f85a: 
1:e88c4ae:         /**
1:e88c4ae:          * Sets the byte length of the stream, defaults to {@code 0}.
1:e88c4ae:          * <p>
1:e88c4ae:          * A length of {@code 0} means the length is unknown.
1:e88c4ae:          *
1:e88c4ae:          * @param length the byte length of the stream (including header)
1:e88c4ae:          * @return The builder.
1:e88c4ae:          */
1:492f85a:         public Builder byteLength(long length) {
1:492f85a:             this.byteLength = length;
1:492f85a:             return this;
1:492f85a:         }
1:492f85a: 
1:e88c4ae:         /**
1:f07a7c3:          * Copies the state of the specified descriptor.
1:f07a7c3:          *
1:f07a7c3:          * @param csd the descriptor to copy
1:f07a7c3:          * @return The builder.
1:f07a7c3:          */
1:f07a7c3:         public Builder copyState(CharacterStreamDescriptor csd) {
1:f07a7c3:             this.bufferable = csd.bufferable;
1:f07a7c3:             this.byteLength = csd.byteLength;
1:f07a7c3:             this.charLength = csd.charLength;
1:f07a7c3:             this.curBytePos = csd.curBytePos;
1:f07a7c3:             this.curCharPos = csd.curCharPos;
1:f07a7c3:             this.dataOffset = csd.dataOffset;
1:f07a7c3:             this.maxCharLength = csd.maxCharLength;
1:f07a7c3:             this.positionAware = csd.positionAware;
1:f07a7c3:             this.stream = csd.stream;
1:f07a7c3:             return this;
1:f07a7c3:         }
1:f07a7c3: 
1:f07a7c3:         /**
1:e88c4ae:          * Sets the character length of the stream, defaults to {@code 0}.
1:e88c4ae:          * <p>
1:e88c4ae:          * Headers are not included in this length, only the user data.
1:e88c4ae:          * A length of {@code 0} means the length is unknown.
1:e88c4ae:          *
1:e88c4ae:          * @param length the character length of the stream
1:e88c4ae:          * @return The builder.
1:e88c4ae:          */
1:492f85a:         public Builder charLength(long length) {
1:492f85a:             this.charLength = length;
1:492f85a:             return this;
1:492f85a:         }
1:492f85a: 
1:e88c4ae:         /**
1:e88c4ae:          * Sets the offset of the user data, defaults to {@code 0}.
1:e88c4ae:          *
1:e88c4ae:          * @param offset first index with user data, zero based
1:e88c4ae:          * @return The builder.
1:e88c4ae:          */
1:492f85a:         public Builder dataOffset(long offset) {
1:492f85a:             this.dataOffset = offset;
1:492f85a:             return this;
1:492f85a:         }
1:492f85a: 
1:e88c4ae:         /**
1:e88c4ae:          * Imposes a length limit on the stream, expressed in number of
1:e88c4ae:          * characters, defaults to {@code Long.MAX_VALUE}.
1:e88c4ae:          *
1:e88c4ae:          * @param length maximum number of characters
1:e88c4ae:          * @return The builder.
1:e88c4ae:          */
1:492f85a:         public Builder maxCharLength(long length) {
1:492f85a:             this.maxCharLength = length;
1:492f85a:             return this;
1:492f85a:         }
1:492f85a: 
1:492f85a:         /**
1:f07a7c3:          * Sets the stream described by the descriptor.
1:f07a7c3:          * <p>
1:f07a7c3:          * The stream is not allowed to be {@code null}.
1:f07a7c3:          *
1:f07a7c3:          * @param stream the stream
1:f07a7c3:          * @return The builder.
1:f07a7c3:          */
1:f07a7c3:         public Builder stream(InputStream stream) {
1:f07a7c3:             if (SanityManager.DEBUG) {
1:f07a7c3:                 SanityManager.ASSERT(stream != null);
1:f07a7c3:             }
1:f07a7c3:             this.stream = stream;
1:492f85a:             return this;
1:492f85a:         }
1:492f85a: 
1:492f85a:         /**
1:492f85a:          * Creates a descriptor object based on the parameters kept in the
1:492f85a:          * builder instance.
1:492f85a:          * <p>
1:492f85a:          * Default values will be used for parameters for which a value hasn't
1:492f85a:          * been set.
1:492f85a:          * <p>
1:492f85a:          * <b>NOTE</b>: Parameter validation is only performed in sane builds.
1:492f85a:          *
1:492f85a:          * @return A character stream descriptor instance.
1:492f85a:          */
1:492f85a:         public CharacterStreamDescriptor build() {
1:492f85a:             // Do validation only in sane builds.
1:492f85a:             if (SanityManager.DEBUG) {
1:cf0fdc4:                 SanityManager.ASSERT(curBytePos >= 0, "Negative curBytePos");
1:492f85a:                 SanityManager.ASSERT(curCharPos >= 1 ||
1:cf0fdc4:                         curCharPos == BEFORE_FIRST, "Invalid curCharPos " +
1:cf0fdc4:                         "(BEFORE_FIRST=" + BEFORE_FIRST + "), " + toString());
1:cf0fdc4:                 SanityManager.ASSERT(byteLength >= 0, "Negative byteLength");
1:cf0fdc4:                 SanityManager.ASSERT(charLength >= 0, "Negative charLength");
1:cf0fdc4:                 SanityManager.ASSERT(dataOffset >= 0, "Negative dataOffset");
1:cf0fdc4:                 SanityManager.ASSERT(maxCharLength >= 0, "Negative max length");
1:492f85a: 
1:492f85a:                 // If current byte pos is set, require char pos to be set too.
1:492f85a:                 if ((curBytePos != 0 && curCharPos == 0) || 
1:492f85a:                         (curBytePos == 0 && curCharPos > 1)) {
1:492f85a:                     SanityManager.THROWASSERT("Invalid byte/char pos: " +
1:492f85a:                             curBytePos + "/" + curCharPos);
1:492f85a:                 }
1:492f85a:                 // The byte position cannot be smaller than the character
1:e88c4ae:                 // position minus one (at least one byte per char).
1:492f85a:                 SanityManager.ASSERT(curBytePos >= curCharPos -1);
1:492f85a:                 // If we're in the header section, the character position must
1:492f85a:                 // be before the first character.
1:492f85a:                 if (curBytePos < dataOffset) {
1:cf0fdc4:                     SanityManager.ASSERT(curCharPos == BEFORE_FIRST,
1:cf0fdc4:                             "curCharPos in header, " + toString());
1:492f85a:                 }
1:f07a7c3:                 // Byte length minus data offset must be equal to or greater
1:f07a7c3:                 // then the character length.
1:f07a7c3:                 if (byteLength > 0 && charLength > 0) {
1:cf0fdc4:                     SanityManager.ASSERT(byteLength - dataOffset >= charLength,
1:cf0fdc4:                             "Less than one byte per char, " + toString());
1:f07a7c3:                 }
1:f07a7c3:                 SanityManager.ASSERT(stream != null, "Stream cannot be null");
1:f07a7c3:                 if (positionAware) {
1:cf0fdc4:                     SanityManager.ASSERT(stream instanceof PositionedStream,
1:cf0fdc4:                             "Stream not a positioned stream, " + toString());
1:f07a7c3:                 }
1:f07a7c3:                 // Note that the character position can be greater than the
1:f07a7c3:                 // maximum character length, because the limit might be imposed
1:f07a7c3:                 // as part of extracting a substring of the contents.
1:492f85a:             }
1:492f85a:             return new CharacterStreamDescriptor(this);
1:492f85a:         }
1:cf0fdc4: 
1:cf0fdc4:         /**
1:cf0fdc4:          * Returns a textual representation of the builder.
1:cf0fdc4:          *
1:cf0fdc4:          * @return The textual representation of the builder.
1:cf0fdc4:          */
1:cf0fdc4:         public String toString() {
1:cf0fdc4:             String str = "CharacterStreamBuiler@"  + hashCode() +
1:cf0fdc4:                     ":bufferable=" + bufferable + ", isPositionAware=" +
1:cf0fdc4:                     positionAware + ", curBytePos=" + curBytePos +
1:cf0fdc4:                     ", curCharPos=" + curCharPos + ", dataOffset=" +
1:cf0fdc4:                     dataOffset + ", byteLength=" + byteLength +
1:cf0fdc4:                     ", charLength=" + charLength + ", maxCharLength=" +
1:cf0fdc4:                     maxCharLength + ", stream=" + stream.getClass();
1:cf0fdc4:             return str;
1:cf0fdc4:         }
1:492f85a:     }
1:492f85a: }
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:cf0fdc4
/////////////////////////////////////////////////////////////////////////
1:                 SanityManager.ASSERT(curBytePos >= 0, "Negative curBytePos");
1:                         curCharPos == BEFORE_FIRST, "Invalid curCharPos " +
1:                         "(BEFORE_FIRST=" + BEFORE_FIRST + "), " + toString());
1:                 SanityManager.ASSERT(byteLength >= 0, "Negative byteLength");
1:                 SanityManager.ASSERT(charLength >= 0, "Negative charLength");
1:                 SanityManager.ASSERT(dataOffset >= 0, "Negative dataOffset");
1:                 SanityManager.ASSERT(maxCharLength >= 0, "Negative max length");
/////////////////////////////////////////////////////////////////////////
1:                     SanityManager.ASSERT(curCharPos == BEFORE_FIRST,
1:                             "curCharPos in header, " + toString());
1:                     SanityManager.ASSERT(byteLength - dataOffset >= charLength,
1:                             "Less than one byte per char, " + toString());
1:                     SanityManager.ASSERT(stream instanceof PositionedStream,
1:                             "Stream not a positioned stream, " + toString());
/////////////////////////////////////////////////////////////////////////
1: 
1:         /**
1:          * Returns a textual representation of the builder.
1:          *
1:          * @return The textual representation of the builder.
1:          */
1:         public String toString() {
1:             String str = "CharacterStreamBuiler@"  + hashCode() +
1:                     ":bufferable=" + bufferable + ", isPositionAware=" +
1:                     positionAware + ", curBytePos=" + curBytePos +
1:                     ", curCharPos=" + curCharPos + ", dataOffset=" +
1:                     dataOffset + ", byteLength=" + byteLength +
1:                     ", charLength=" + charLength + ", maxCharLength=" +
1:                     maxCharLength + ", stream=" + stream.getClass();
1:             return str;
1:         }
commit:f07a7c3
/////////////////////////////////////////////////////////////////////////
1: import java.io.InputStream;
1: import org.apache.derby.iapi.types.PositionedStream;
/////////////////////////////////////////////////////////////////////////
1:     /** Reference to the stream we are describing. */
1:     private final InputStream stream;
/////////////////////////////////////////////////////////////////////////
1:         stream = b.stream;
/////////////////////////////////////////////////////////////////////////
1: 
1:      * Returns the associated stream.
1:      * @return An {@code InputStream} reference.
1:     public InputStream getStream() {
1:         return stream;
1:     }
1: 
1:     /**
1:      * Returns the associated positioned stream, if the stream is position
1:      * aware.
1:      *
1:      * @return A {@code PositionedStream} reference.
1:      * @throws ClassCastException if the stream cannot be cast to
1:      *      {@code PositionedStream}
1:      * @throws IllegalArgumentException if the method is called and the
1:      *      assoicated stream isn't described as position aware.
1:      * @see #isPositionAware
1:      */
1:     public PositionedStream getPositionedStream() {
1:         if (!positionAware) {
1:             throw new IllegalStateException("stream is not position aware: " +
1:                     stream.getClass().getName());
1:         }
1:         return (PositionedStream)stream;
/////////////////////////////////////////////////////////////////////////
1:                 curCharPos + ":dataOffset=" + dataOffset + ":stream=" +
1:                 stream.getClass());
/////////////////////////////////////////////////////////////////////////
1:         private InputStream stream;
/////////////////////////////////////////////////////////////////////////
1:          * Copies the state of the specified descriptor.
1:          *
1:          * @param csd the descriptor to copy
1:          * @return The builder.
1:          */
1:         public Builder copyState(CharacterStreamDescriptor csd) {
1:             this.bufferable = csd.bufferable;
1:             this.byteLength = csd.byteLength;
1:             this.charLength = csd.charLength;
1:             this.curBytePos = csd.curBytePos;
1:             this.curCharPos = csd.curCharPos;
1:             this.dataOffset = csd.dataOffset;
1:             this.maxCharLength = csd.maxCharLength;
1:             this.positionAware = csd.positionAware;
1:             this.stream = csd.stream;
1:             return this;
1:         }
1: 
1:         /**
/////////////////////////////////////////////////////////////////////////
1:         /**
1:          * Sets the stream described by the descriptor.
1:          * <p>
1:          * The stream is not allowed to be {@code null}.
1:          *
1:          * @param stream the stream
1:          * @return The builder.
1:          */
1:         public Builder stream(InputStream stream) {
1:             if (SanityManager.DEBUG) {
1:                 SanityManager.ASSERT(stream != null);
1:             }
1:             this.stream = stream;
/////////////////////////////////////////////////////////////////////////
1:                 // Byte length minus data offset must be equal to or greater
1:                 // then the character length.
1:                 if (byteLength > 0 && charLength > 0) {
0:                     SanityManager.ASSERT(byteLength - dataOffset >= charLength);
1:                 }
1:                 SanityManager.ASSERT(stream != null, "Stream cannot be null");
1:                 if (positionAware) {
0:                     SanityManager.ASSERT(stream instanceof PositionedStream);
1:                 }
1:                 // Note that the character position can be greater than the
1:                 // maximum character length, because the limit might be imposed
1:                 // as part of extracting a substring of the contents.
commit:e88c4ae
/////////////////////////////////////////////////////////////////////////
1:  * The information in the description is only guaranteed to be valid at the
/////////////////////////////////////////////////////////////////////////
1:      * can reposition itself on request.
/////////////////////////////////////////////////////////////////////////
1:         /**
1:          * Sets if the stream should be buffered, defaults to {@code false}.
1:          *
1:          * @param bufferable {@code true} if buffering is advised, {@code false}
1:          *      if not
1:          * @return The builder.
1:          */
1:         /**
1:          * Sets if the stream can reposition itself or not, defaults to
1:          * {@code false}.
1:          *
1:          * @param positionAware {@code true} if the stream can reposition
1:          *      itself, {@code false} if not
1:          * @return The builder.
1:          */
1:         /**
1:          * Sets the current byte position, defaults to {@code 0}.
1:          *
1:          * @param pos the current byte position
1:          * @return The builder.
1:          */
1:         /**
1:          * Sets the current character position, defaults to {@code 1}.
1:          * <p>
1:          * There is a special value for when the stream is position in the
1:          * header area - {@code BEFORE_FIRST}.
1:          *
1:          * @param pos the current character position,starting at {@code 1}
1:          * @return The builder.
1:          * @see #BEFORE_FIRST
1:          */
1:         /**
1:          * Sets the byte length of the stream, defaults to {@code 0}.
1:          * <p>
1:          * A length of {@code 0} means the length is unknown.
1:          *
1:          * @param length the byte length of the stream (including header)
1:          * @return The builder.
1:          */
1:         /**
1:          * Sets the character length of the stream, defaults to {@code 0}.
1:          * <p>
1:          * Headers are not included in this length, only the user data.
1:          * A length of {@code 0} means the length is unknown.
1:          *
1:          * @param length the character length of the stream
1:          * @return The builder.
1:          */
1:         /**
1:          * Sets the offset of the user data, defaults to {@code 0}.
1:          *
1:          * @param offset first index with user data, zero based
1:          * @return The builder.
1:          */
1:         /**
1:          * Imposes a length limit on the stream, expressed in number of
1:          * characters, defaults to {@code Long.MAX_VALUE}.
1:          *
1:          * @param length maximum number of characters
1:          * @return The builder.
1:          */
/////////////////////////////////////////////////////////////////////////
1:                 // position minus one (at least one byte per char).
commit:492f85a
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derby.iapi.jdbc.CharacterStreamDescriptor
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: package org.apache.derby.iapi.jdbc;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: /**
1:  * A description of a byte stream representing characters. The description is
1:  * used by decoders to properly configure themselves. Note that encoding is not
1:  * included in the description, because all internal byte streams are expected
1:  * to be using the modified UTF-8 encoding (see DataInput).
1:  * <p>
0:  * The information in the description is only guranteed to be valid at the
1:  * moment it is passed to the decoder object. As the decoder works on the
1:  * stream, the information in the descriptor will be outdated.
1:  * <p>
1:  * To create a stream descriptor, obtain a {@code Builder} instance and set the
1:  * required parameters.
1:  *
1:  * @see Builder
1:  */
1: //@Immutable
1: public class CharacterStreamDescriptor {
1: 
1:     /**
1:      * Constant for the character position, when it is positioned before the
1:      * first character in the stream (i.e. at the very beginning of the stream
1:      * or in the header).
1:      */
1:     public static final long BEFORE_FIRST = 0;
1: 
1:     /** First data byte in the byte stream. */
1:     private final long dataOffset;
1:     /** The current byte position. */
1:     private final long curBytePos;
1:     /** The current character position. */
1:     private final long curCharPos;
1:     /** The byte length of the stream, {@code 0} if unknown. */
1:     private final long byteLength;
1:     /** The character length of the stream, {@code 0} if unknown. */
1:     private final long charLength;
1:     /** The maximum allowed character length. */
1:     private final long maxCharLength;
1:     /** Tells if the stream can be buffered or not. */
1:     private final boolean bufferable;
1:     /** Tells if the stream is aware of its own position. */
1:     private final boolean positionAware;
0:     /** A (mostly) unique id for the associated stream. */
0:     private final int id;
1: 
1:     /**
1:      * Creates a character stream descriptor, using the supplied builder.
1:      * <p>
1:      * Use the builder to create instances of this class.
1:      *
1:      * @param b object builder
1:      * @see Builder
1:      */
1:     private CharacterStreamDescriptor(Builder b) {
1:         bufferable = b.bufferable;
1:         positionAware = b.positionAware;
1:         dataOffset = b.dataOffset;
1:         curBytePos = b.curBytePos;
1:         curCharPos = b.curCharPos;
1:         byteLength = b.byteLength;
1:         charLength = b.charLength;
1:         maxCharLength = b.maxCharLength;
0:         id = b.id;
1:     }
1: 
1:     /**
1:      * Tells if the described stream should be buffered or not.
1:      * <p>
1:      * Some of the reasons a stream should not be buffered at this level, are
1:      * the stream is already buffered, or it serves bytes directly from a byte
1:      * array in memory.
1:      *
1:      * @return {@code true} if the stream should be buffered for improved
1:      *      performance, {@code false} if it should not be buffered.
1:      */
1:     public boolean isBufferable() {
1:         return bufferable;
1:     }
1: 
1:     /**
1:      * Tells if the described stream is aware of its own position, and that it
0:      * can reposition itself on requrest.
1:      *
1:      * @return {@code true} if the stream is position aware, @{code false}
1:      *      otherwise.
1:      */
1:     public boolean isPositionAware() {
1:         return positionAware;
1:     }
1: 
1:     public long getByteLength() {
1:         return byteLength;
1:     }
1: 
1:     public long getCharLength() {
1:         return charLength;
1:     }
1: 
1:     public long getCurBytePos() {
1:         return curBytePos;
1:     }
1: 
1:     /**
1:      * Returns the current character position.
1:      *
1:      * @return The current character position, where the first character is at
1:      *      position {@code 1}, or {@code BEFORE_FIRST} if the stream is
1:      *      positioned before the first character.
1:      */
1:     public long getCurCharPos() {
1:         return curCharPos;
1:     }
1: 
1:     /**
1:      * Returns the first index of the described stream that contains real data.
1:      * <p>
1:      * The information is typically used to filter out meta data at the head of
1:      * the stream, and to correctly reset the stream.
1:      *
1:      * @return The first position in the stream containing real data.
1:      */
1:     public long getDataOffset() {
1:         return dataOffset;
1:     }
1: 
1:     /**
1:      * Returns the imposed maximum character length on the described stream.
1:      * <p>
1:      * The default value is {@code Long.MAX_VALUE}.
1:      *
1:      * @return The max allowed character length of the stream, or {@code 0} if
1:      *      no limit has been set.
1:      */
1:     public long getMaxCharLength() {
1:         return maxCharLength;
1:     }
1:     
1:     /**
0:      * Returns an id that can be used to identify the associated stream.
1:      * <p>
0:      * Mostly used for debugging and verification purposes.
1:      *
0:      * @return An integer id.
1:      */
0:     public int getStreamId() {
0:         return id;
1:     }
1: 
1:     public String toString() {
1:         return ("CharacterStreamDescriptor-" + hashCode() +"#bufferable=" +
1:                 bufferable + ":positionAware=" +
1:                 positionAware + ":byteLength=" + byteLength + ":charLength=" +
1:                 charLength + ":curBytePos=" + curBytePos + ":curCharPos=" +
0:                 curCharPos + ":dataOffset=" + dataOffset + ":id=" + id);
1:     }
1: 
1:     /**
1:      * The builder for the {@code CharacterStreamDescriptor} class. The builder
1:      * is used to avoid having a large set of constructors. See the
1:      * {@linkplain #build} method for pre-build field validation. Note that the
1:      * validation is only performed in sane builds.
1:      */
1:     public static class Builder {
1:  
1:         /** Default max character length is unlimited. */
1:         private static final long DEFAULT_MAX_CHAR_LENGTH = Long.MAX_VALUE;
1: 
1:         // See documentation for the fields in the CharacterStreamDescriptor
1:         // class. The values below are the field defaults.
1:         private boolean bufferable = false;
1:         private boolean positionAware = false;
1:         private long curBytePos = 0;
1:         private long curCharPos = 1;
1:         private long byteLength = 0;
1:         private long charLength = 0;
1:         private long dataOffset = 0;
1:         private long maxCharLength = DEFAULT_MAX_CHAR_LENGTH;
0:         private int id = -1;
1: 
1:         /**
1:          * Creates a builder object.
1:          */
1:         public Builder() {}
1: 
1:         public Builder bufferable(boolean bufferable) {
1:             this.bufferable = bufferable;
1:             return this;
1:         }
1: 
1:         public Builder positionAware(boolean positionAware) {
1:             this.positionAware = positionAware;
1:             return this;
1:         }
1: 
1:         public Builder curBytePos(long pos) {
1:             this.curBytePos = pos;
1:             return this;
1:         }
1: 
1:         public Builder curCharPos(long pos) {
1:             this.curCharPos = pos;
1:             return this;
1:         }
1: 
1:         public Builder byteLength(long length) {
1:             this.byteLength = length;
1:             return this;
1:         }
1: 
1:         public Builder charLength(long length) {
1:             this.charLength = length;
1:             return this;
1:         }
1: 
1:         public Builder dataOffset(long offset) {
1:             this.dataOffset = offset;
1:             return this;
1:         }
1: 
1:         public Builder maxCharLength(long length) {
1:             this.maxCharLength = length;
1:             return this;
1:         }
1: 
0:         public Builder id(int id) {
0:             this.id = id;
1:             return this;
1:         }
1: 
1:         /**
1:          * Creates a descriptor object based on the parameters kept in the
1:          * builder instance.
1:          * <p>
1:          * Default values will be used for parameters for which a value hasn't
1:          * been set.
1:          * <p>
1:          * <b>NOTE</b>: Parameter validation is only performed in sane builds.
1:          *
1:          * @return A character stream descriptor instance.
1:          */
1:         public CharacterStreamDescriptor build() {
1:             // Do validation only in sane builds.
1:             if (SanityManager.DEBUG) {
0:                 SanityManager.ASSERT(curBytePos >= 0);
1:                 SanityManager.ASSERT(curCharPos >= 1 ||
0:                         curCharPos == BEFORE_FIRST);
0:                 SanityManager.ASSERT(byteLength >= 0);
0:                 SanityManager.ASSERT(charLength >= 0);
0:                 SanityManager.ASSERT(dataOffset >= 0);
0:                 SanityManager.ASSERT(maxCharLength >= 0);
1: 
1:                 // If current byte pos is set, require char pos to be set too.
1:                 if ((curBytePos != 0 && curCharPos == 0) || 
1:                         (curBytePos == 0 && curCharPos > 1)) {
1:                     SanityManager.THROWASSERT("Invalid byte/char pos: " +
1:                             curBytePos + "/" + curCharPos);
1:                 }
1:                 // The byte position cannot be smaller than the character
0:                 // position minues one (at least one byte per char).
1:                 SanityManager.ASSERT(curBytePos >= curCharPos -1);
1:                 // If we're in the header section, the character position must
1:                 // be before the first character.
1:                 if (curBytePos < dataOffset) {
0:                     SanityManager.ASSERT(curCharPos == BEFORE_FIRST);
1:                 }
1:             }
1:             return new CharacterStreamDescriptor(this);
1:         }
1:     }
1: }
============================================================================