1:33776ff: /*
171:33776ff: 
1:33776ff:    Derby - Class org.apache.derby.client.am.Connection
1:ac53be6: 
1:59bf37d:    Licensed to the Apache Software Foundation (ASF) under one or more
1:59bf37d:    contributor license agreements.  See the NOTICE file distributed with
1:59bf37d:    this work for additional information regarding copyright ownership.
1:59bf37d:    The ASF licenses this file to You under the Apache License, Version 2.0
1:59bf37d:    (the "License"); you may not use this file except in compliance with
1:59bf37d:    the License.  You may obtain a copy of the License at
1:fdfc981: 
1:33776ff:       http://www.apache.org/licenses/LICENSE-2.0
1:33776ff: 
1:33776ff:    Unless required by applicable law or agreed to in writing, software
1:33776ff:    distributed under the License is distributed on an "AS IS" BASIS,
1:33776ff:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:33776ff:    See the License for the specific language governing permissions and
1:33776ff:    limitations under the License.
1:33776ff: 
1:33776ff: */
1:33776ff: 
1:33776ff: package org.apache.derby.client.am;
1:33776ff: 
1:69e3d06: import java.sql.Blob;
1:69e3d06: import java.sql.CallableStatement;
1:69e3d06: import java.sql.Clob;
1:69e3d06: import java.sql.Connection;
1:69e3d06: import java.sql.DatabaseMetaData;
1:69e3d06: import java.sql.PreparedStatement;
1:69e3d06: import java.sql.ResultSet;
1:4772c7e: import java.sql.SQLException;
1:9a0cdf1: import java.sql.SQLPermission;
1:69e3d06: import java.sql.SQLWarning;
1:69e3d06: import java.sql.Savepoint;
1:69e3d06: import java.sql.Statement;
1:4772c7e: import java.util.Collections;
1:c7f0048: import java.util.HashMap;
1:4772c7e: import java.util.Hashtable;
1:4772c7e: import java.util.Iterator;
1:4772c7e: import java.util.Map;
1:b13b17c: import java.util.Properties;
1:4772c7e: import java.util.Set;
1:4772c7e: import java.util.WeakHashMap;
1:9a0cdf1: import java.util.concurrent.Executor;
1:4772c7e: import org.apache.derby.client.net.NetXAResource;
1:7863d83: import org.apache.derby.jdbc.BasicClientDataSource40;
1:7863d83: import org.apache.derby.jdbc.ClientDataSourceInterface;
1:7680ab7: import org.apache.derby.shared.common.reference.SQLState;
1:c6c4d4d: import org.apache.derby.shared.common.sanity.SanityManager;
1:d506170: 
1:69e3d06: public abstract class ClientConnection
1:69e3d06:     implements Connection, ConnectionCallbackInterface
1:795f705: {
1:70f7692:     //---------------------navigational members-----------------------------------
1:33776ff: 
1:33776ff: 
1:70f7692:     public Agent agent_;
1:cff2860: 
1:69e3d06:     public ClientDatabaseMetaData databaseMetaData_;
1:dd7d579:     // DERBY-210 -  WeakHashMap is used to store references to objects to avoid
1:dd7d579:     // memory leaks. When there are no other references to the keys in a 
1:dd7d579:     // WeakHashMap, they will get removed from the map and can thus get 
1:dd7d579:     // garbage-collected. They do not have to wait till the Connection object 
1:dd7d579:     // is collected.
1:dd7d579:         
1:dd7d579:     // In Connection.markStatementsClosed() method, this list is traversed to get a
1:dd7d579:     // list of open statements, which are marked closed and removed from the list.
1:69e3d06:     final WeakHashMap<ClientStatement, Void> openStatements_ =
1:69e3d06:             new WeakHashMap<ClientStatement, Void>();
1:cff2860: 
1:ca8747c:     // Some statuses of DERBY objects may be invalid on server
1:ca8747c:     // after both commit and rollback. For example,
1:70f7692:     // (1) prepared statements need to be re-prepared
1:70f7692:     //     after both commit and rollback
1:70f7692:     // (2) result set will be unpositioned on server after both commit and rollback.
1:70f7692:     // If they depend on both commit and rollback, they need to get on CommitAndRollbackListeners_.
1:4772c7e:     final WeakHashMap<UnitOfWorkListener, Void> CommitAndRollbackListeners_ =
1:4772c7e:             new WeakHashMap<UnitOfWorkListener, Void>();
1:4772c7e: 
1:70f7692:     private SqlWarning warnings_ = null;
1:b16fdc6:     
1:b16fdc6:     //Constant representing an invalid locator value
1:b16fdc6:     private static final int INVALID_LOCATOR = -1;
1:33776ff: 
1:70f7692:     // ------------------------properties set for life of connection--------------
1:33776ff: 
1:70f7692:     // See ClientDataSource pre-connect settings
1:818ef2a:     protected final String user_;
1:0326967:     boolean retrieveMessageText_;
1:0326967:     private boolean jdbcReadOnly_;
1:902041a:     /**
1:fdfc981:      * Holdabilty for created statements.
1:fdfc981:      * Only access through the holdability method
1:fdfc981:      * to ensure the correct value is returned for an
1:fdfc981:      * XA connection.
1:fdfc981:      */
1:1e8a20f:     private int holdability = ResultSet.HOLD_CURSORS_OVER_COMMIT;
1:fdfc981:     
1:70f7692:     public String databaseName_;
1:33776ff: 
1:70f7692:     // Holds the Product-Specific Identifier which specifies
1:70f7692:     // the product release level of a DDM Server.
1:70f7692:     // The max length is 8.
1:70f7692:     public String productID_;
1:33776ff: 
1:70f7692:     // Used to get the public key and encrypt password and/or userid
1:70f7692:     protected EncryptionManager encryptionManager_;
1:33776ff: 
1:0b963b2:     //prepared statements associated with isolation level change are stored 
1:0b963b2:     // in isolationLevelPreparedStmts
1:69e3d06:     final private HashMap<String, ClientPreparedStatement>
1:c7f0048:         isolationLevelPreparedStmts = 
1:69e3d06:             new HashMap<String, ClientPreparedStatement>();
1:33776ff:     
1:ac53be6:     // used to get transaction isolation level
1:69e3d06:     private ClientPreparedStatement getTransactionIsolationPrepStmt = null;
1:ac53be6:     
1:70f7692:     // ------------------------dynamic properties---------------------------------
1:33776ff: 
1:70f7692:     protected boolean open_ = true;
1:795f705:     private boolean aborting_ = false;
1:d08d1a5:     private boolean availableForReuse_ = false;
1:33776ff: 
1:c6c4d4d:     /**
1:c6c4d4d:      * Constant indicating that isolation_ has not been updated through
1:c6c4d4d:      * piggy-backing, (or that the previously stored value was invalidated,
1:c6c4d4d:      * e.g. by an XA state change).
1:c6c4d4d:      */
1:c6c4d4d:     private static final int TRANSACTION_UNKNOWN = -1;
1:c6c4d4d:     /**
1:c6c4d4d:      * Cached copy of the isolation level. Kept in sync with server through
1:c6c4d4d:      * piggy-backing.
1:c6c4d4d:      */
1:c6c4d4d:     private int isolation_ = TRANSACTION_UNKNOWN;
1:c6c4d4d:     /**
1:2f3d052:      * The default isolation level, enforced on connection resets.
1:2f3d052:      * <p>
1:2f3d052:      * Note that this value may be changed upon connection initialization in
1:2f3d052:      * the future, as the server can piggy-back the isolation level.
1:2f3d052:      */
1:2f3d052:     private int defaultIsolation = TRANSACTION_READ_COMMITTED;
1:c6c4d4d: 
1:2f3d052:     /**
1:c6c4d4d:      * Cached copy of the schema name. Updated through piggy-backing and used
1:c6c4d4d:      * to implement statement caching.
1:c6c4d4d:      */
1:c6c4d4d:     private String currentSchemaName_ = null;
1:c6c4d4d: 
1:70f7692:     public boolean autoCommit_ = true;
1:70f7692:     protected boolean inUnitOfWork_ = false; // This means a transaction is in progress.
1:33776ff: 
1:70f7692:     private boolean accumulated440ForMessageProcFailure_ = false;
1:70f7692:     private boolean accumulated444ForMessageProcFailure_ = false;
1:8055511: 
1:8055511:     private int transactionID_ = 0;
1:66a9818: 
1:70f7692:     //---------------------XA-----------------------------------------------------
1:33776ff: 
1:70f7692:     protected boolean isXAConnection_ = false; // Indicates an XA connection
1:33776ff: 
1:70f7692:     // XA States
1:88c25bb:     // The client needs to keep track of the connection's transaction branch association
1:88c25bb:     // per table 2.6 in the XA+ specification in order to determine if commits should flow in
1:88c25bb:     // autocommit mode.  There is no need to keep track of suspended transactions separately from
1:88c25bb:     // XA_TO_NOT_ASSOCIATED.
1:88c25bb:     // 
1:88c25bb:     /**
1:88c25bb:      * <code>XA_T0_NOT_ASSOCIATED</code>
1:88c25bb:      * This connection is not currently associated with an XA transaction
1:88c25bb:      * In this state commits will flow in autocommit mode.
1:88c25bb:      */
1:88c25bb:     public static final int XA_T0_NOT_ASSOCIATED = 0;   
1:88c25bb:     
1:88c25bb:     /**
1:88c25bb:      * <code>XA_T1_ASSOCIATED</code>
1:88c25bb:      * In this state commits will not flow in autocommit mode.
1:88c25bb:      */
1:88c25bb:     public static final int XA_T1_ASSOCIATED = 1;  
1:88c25bb:     
1:88c25bb:     //TODO: Remove XA_RECOVER entirely once indoubtlist is gone.  
1:38083d6:     //public static final int XA_RECOVER = 14;
1:33776ff: 
1:33776ff: 
1:fdfc981:     private int xaState_ = XA_T0_NOT_ASSOCIATED;
1:33776ff: 
1:70f7692:     // XA Host Type
1:70f7692:     public int xaHostVersion_ = 0;
1:33776ff: 
1:0326967:     private int loginTimeout_;
1:7863d83:     public BasicClientDataSource40 dataSource_;
1:70f7692:     public String serverNameIP_;
1:70f7692:     public int portNumber_;
1:7863d83:     private int clientSSLMode_ = BasicClientDataSource40.SSL_OFF;
1:70f7692: 
1:4772c7e:     Hashtable<String, String> clientCursorNameCache_ =
1:4772c7e:             new Hashtable<String, String>();
1:4772c7e: 
1:70f7692:     public int commBufferSize_ = 32767;
1:70f7692: 
1:70f7692:     // indicates if a deferred reset connection is required
1:70f7692:     public boolean resetConnectionAtFirstSql_ = false;
1:70f7692: 
1:70f7692:     //---------------------constructors/finalizer---------------------------------
1:70f7692: 
1:70f7692:     // For jdbc 2 connections
1:69e3d06:     protected ClientConnection(
1:b13b17c:             LogWriter logWriter,
1:8269b78:             String user,
1:8269b78:             String password,
1:7863d83:             BasicClientDataSource40 dataSource)
1:8269b78:             throws SqlException {
1:8269b78: 
1:818ef2a:         this.user_ = user;
1:818ef2a:         initConnection(logWriter, dataSource);
25:70f7692:     }
1:ac53be6: 
1:69e3d06:     protected ClientConnection(
1:b13b17c:             LogWriter logWriter,
1:8269b78:             String user,
1:8269b78:             String password,
1:8269b78:             boolean isXAConn,
1:7863d83:             BasicClientDataSource40 dataSource)
1:69e3d06:             throws SqlException {
1:8269b78: 
1:818ef2a:         this.user_ = user;
1:70f7692:         isXAConnection_ = isXAConn;
1:818ef2a:         initConnection(logWriter, dataSource);
1:70f7692:     }
1:8269b78: 
1:70f7692:     // For jdbc 2 connections
1:0326967:     private void initConnection(
1:b13b17c:             LogWriter logWriter,
1:7863d83:             BasicClientDataSource40 dataSource)
1:69e3d06:             throws SqlException {
1:8269b78: 
2:70f7692:         if (logWriter != null) {
1:70f7692:             logWriter.traceConnectEntry(dataSource);
1:70f7692:         }
1:8269b78: 
1:70f7692:         // Extract common properties.
1:924602a:         // Derby-409 fix - Append connectionAttributes only if it is non-null. 
1:924602a:         // DERBY-1130 - Append connectionAttributes only if database name is
1:924602a:         // non-null. This will prevent use of database name set using 
1:924602a:         // "setConnectionAttributes" method.  
1:b1b9120:         databaseName_ = dataSource.getDatabaseName();
1:924602a:         String connAtrrs = dataSource.getConnectionAttributes();
1:f7b3a7a:         if (dataSource.getCreateDatabase() != null) // can be "create" or null
1:1837822:         {
1:f7b3a7a:             if (connAtrrs == null)
1:f7b3a7a:                 connAtrrs = "create=true";
1:ac53be6:             else
1:f7b3a7a:                 connAtrrs = connAtrrs + ";create=true";
1:b1b9120:         }
1:f7b3a7a:         if (dataSource.getShutdownDatabase() != null) // "shutdown" or null
1:1837822:         {
1:f7b3a7a:             if (connAtrrs == null)
1:f7b3a7a:                 connAtrrs = "shutdown=true";
2:f7b3a7a:             else
1:f7b3a7a:                 connAtrrs = connAtrrs + ";shutdown=true";
1:f7b3a7a:         }
1:924602a:         if(databaseName_ != null && connAtrrs != null)
1:f7b3a7a:             databaseName_ = databaseName_ + ";" + connAtrrs;
1:ac53be6: 
1:70f7692:         retrieveMessageText_ = dataSource.getRetrieveMessageText();
1:38083d6: 
1:70f7692:         loginTimeout_ = dataSource.getLoginTimeout();
1:70f7692:         dataSource_ = dataSource;
1:b16fdc6: 
1:70f7692:         serverNameIP_ = dataSource.getServerName();
1:70f7692:         portNumber_ = dataSource.getPortNumber();
1:fdfc981: 
1:5839503:         clientSSLMode_ = 
1:7863d83:             BasicClientDataSource40.getSSLModeFromString(dataSource.getSsl());
1:5839503: 
1:70f7692:         agent_ = newAgent_(logWriter,
1:70f7692:                 loginTimeout_,
1:70f7692:                 serverNameIP_,
1:6bc2e25:                 portNumber_,
1:5839503:                 clientSSLMode_);
1:f7b3a7a:     }
1:5839503: 
1:70f7692:     // For jdbc 2 connections
1:69e3d06:     protected ClientConnection(
1:ee33904:             LogWriter logWriter,
1:8269b78:             boolean isXAConn,
1:7863d83:             BasicClientDataSource40 dataSource)
1:69e3d06:             throws SqlException {
1:924602a: 
1:70f7692:         if (logWriter != null) {
1:70f7692:             logWriter.traceConnectEntry(dataSource);
1:70f7692:         }
1:70f7692: 
1:70f7692:         isXAConnection_ = isXAConn;
1:70f7692: 
1:7863d83:         user_ = ClientDataSourceInterface.propertyDefault_user;
1:70f7692: 
1:70f7692:         // Extract common properties.
1:924602a:         databaseName_ = dataSource.getDatabaseName();
1:70f7692:         retrieveMessageText_ = dataSource.getRetrieveMessageText();
1:70f7692: 
1:70f7692:         loginTimeout_ = dataSource.getLoginTimeout();
1:70f7692:         dataSource_ = dataSource;
1:70f7692: 
1:70f7692:         serverNameIP_ = dataSource.getServerName();
1:70f7692:         portNumber_ = dataSource.getPortNumber();
1:70f7692: 
1:5839503:         clientSSLMode_ = 
1:7863d83:             BasicClientDataSource40.getSSLModeFromString(dataSource.getSsl());
1:70f7692: 
1:70f7692:         agent_ = newAgent_(logWriter,
1:70f7692:                 loginTimeout_,
1:70f7692:                 serverNameIP_,
1:6bc2e25:                 portNumber_,
1:5839503:                 clientSSLMode_);
1:70f7692:     }
1:70f7692: 
1:70f7692:     // This is a callback method, called by subsystem - NetConnection
1:bbc2fd8:     protected void resetConnection(LogWriter logWriter)
1:69e3d06:             throws SqlException {
1:76af6ed:         // Transaction isolation level is handled in completeReset.
2:70f7692:         // clearWarningsX() will re-initialize the following properties
3:70f7692:         clearWarningsX();
1:70f7692: 
1:bbc2fd8:         // property encryptionManager_
1:bbc2fd8:         // if needed this will later be initialized by NET calls to initializePublicKeyForEncryption()
1:bbc2fd8:         encryptionManager_ = null;
1:70f7692: 
1:818ef2a:         // DERBY-3723: Reset schema to user name.
1:818ef2a:         currentSchemaName_ = this.user_;
1:bbc2fd8:         autoCommit_ = true;
1:bbc2fd8:         inUnitOfWork_ = false;
1:bbc2fd8:         holdability = ResultSet.HOLD_CURSORS_OVER_COMMIT;
1:ad94e28: 
1:bbc2fd8:         this.agent_.resetAgent(
1:bbc2fd8:                 this, logWriter, loginTimeout_, serverNameIP_, portNumber_);
1:70f7692:     }
1:70f7692: 
1:70f7692:     // For jdbc 1 connections
1:69e3d06:     protected ClientConnection(LogWriter logWriter,
1:70f7692:                          int driverManagerLoginTimeout,
1:70f7692:                          String serverName,
1:70f7692:                          int portNumber,
2:70f7692:                          String databaseName,
1:b13b17c:                          Properties properties) throws SqlException {
1:70f7692:         if (logWriter != null) {
1:70f7692:             logWriter.traceConnectEntry(serverName, portNumber, databaseName, properties);
1:70f7692:         }
1:70f7692: 
2:70f7692:         databaseName_ = databaseName;
1:70f7692: 
1:70f7692:         // Extract common properties.
1:7863d83:         user_ = BasicClientDataSource40.getUser(properties);
1:8269b78:         retrieveMessageText_ =
1:7863d83:             BasicClientDataSource40.getRetrieveMessageText(properties);
1:70f7692: 
1:70f7692:         loginTimeout_ = driverManagerLoginTimeout;
1:70f7692:         serverNameIP_ = serverName;
1:70f7692:         portNumber_ = portNumber;
1:7863d83:         clientSSLMode_ = BasicClientDataSource40.getClientSSLMode(properties);
1:70f7692: 
1:70f7692:         agent_ = newAgent_(logWriter,
1:70f7692:                 loginTimeout_,
1:70f7692:                 serverNameIP_,
1:6bc2e25:                 portNumber_,
1:37ce91b:                 clientSSLMode_);
1:70f7692:     }
1:70f7692: 
1:70f7692:     // Users are advised to call the method close() on Statement and Connection objects when they are done with them.
1:70f7692:     // However, some users will forget, and some code may get killed before it can close these objects.
1:70f7692:     // Therefore, if JDBC drivers have state associated with JDBC objects that need to get
1:70f7692:     // explicitly cleared up, they should provide finalize methods to take care of them.
1:70f7692:     // The garbage collector will call these finalize methods when the objects are found to be garbage,
1:70f7692:     // and this will give the driver a chance to close (or otherwise clean up) the objects.
1:70f7692:     // Note, however, that there is no guarantee that the garbage collector will ever run.
1:70f7692:     // If that is the case, the finalizers will not be called.
1:b13b17c:     protected void finalize() throws Throwable {
49:70f7692:         if (agent_.loggingEnabled()) {
1:70f7692:             agent_.logWriter_.traceEntry(this, "finalize");
1:70f7692:         }
1:a53b758: 
1:70f7692:         // finalize() differs from close() in that it will not throw an
1:70f7692:         // exception if a transaction is in progress.
1:70f7692:         // finalize() also differs from close() in that it will not drive
1:70f7692:         // an auto-commit before disconnecting.
1:795f705:         //
1:70f7692:         // If a transaction is in progress, a close() request will throw an SqlException.
1:70f7692:         // However, if a connection with an incomplete transaction is finalized,
1:70f7692:         // or is abruptly terminated by application exit,
1:70f7692:         // the normal rollback semantics imposed by the DERBY server are adopted.
1:70f7692:         // So we just pull the plug and let the server handle this default semantic.
1:70f7692: 
2:70f7692:         if (!open_) {
2:70f7692:             return;
1:70f7692:         }
1:70f7692:         agent_.disconnectEvent();
1:70f7692:         super.finalize();
1:70f7692:     }
1:70f7692: 
1:70f7692:     // ---------------------------jdbc 1------------------------------------------
1:70f7692: 
1:69e3d06:     synchronized public Statement createStatement() throws SQLException {
1:d506170:         try
1:795f705:         {
1:d506170:             if (agent_.loggingEnabled()) {
1:d506170:                 agent_.logWriter_.traceEntry(this, "createStatement");
1:d506170:             }
1:69e3d06: 
1:69e3d06:             ClientStatement s = createStatementX(
1:69e3d06:                 ResultSet.TYPE_FORWARD_ONLY,
1:69e3d06:                 ResultSet.CONCUR_READ_ONLY, holdability());
1:69e3d06: 
1:d506170:             if (agent_.loggingEnabled()) {
1:d506170:                 agent_.logWriter_.traceExit(this, "createStatement", s);
1:d506170:             }
1:d506170:             return s;
1:d506170:         }
1:d506170:         catch ( SqlException se )
1:f7b3a7a:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:69e3d06:     synchronized public PreparedStatement prepareStatement(String sql)
1:69e3d06:             throws SQLException {
1:d506170:         try
1:f7b3a7a:         {
1:d506170:             if (agent_.loggingEnabled()) {
1:d506170:                 agent_.logWriter_.traceEntry(this, "prepareStatement", sql);
1:d506170:             }
1:69e3d06:             ClientPreparedStatement ps = prepareStatementX(sql,
1:69e3d06:                     ResultSet.TYPE_FORWARD_ONLY,
1:69e3d06:                     ResultSet.CONCUR_READ_ONLY,
1:fdfc981:                     holdability(),
1:69e3d06:                     Statement.NO_GENERATED_KEYS,
1:b52081a:                     null, null);
1:d506170:             if (agent_.loggingEnabled()) {
1:d506170:                 agent_.logWriter_.traceExit(this, "prepareStatement", ps);
1:d506170:             }
1:d506170:             return ps;
1:70f7692:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:70f7692:     // For internal use only.  Use by updatable result set code.
1:0326967:     synchronized ClientPreparedStatement preparePositionedUpdateStatement (
1:69e3d06:             String sql,
1:69e3d06:             Section querySection) throws SqlException {
1:69e3d06: 
1:320777f:         checkForClosedConnection();
1:70f7692:         // create a net material prepared statement.
1:69e3d06:         ClientPreparedStatement preparedStatement =
1:69e3d06:             newPositionedUpdatePreparedStatement_(sql, querySection);
1:69e3d06: 
1:70f7692:         preparedStatement.flowPrepareDescribeInputOutput();
1:70f7692:         // The positioned update statement is not added to the list of open statements,
1:70f7692:         // because this would cause a java.util.ConcurrentModificationException when
1:70f7692:         // iterating thru the list of open statements to call completeRollback().
1:70f7692:         // An updatable result set is marked closed on a call to completeRollback(),
1:70f7692:         // and would therefore need to close the positioned update statement associated with the result set which would cause
1:70f7692:         // it to be removed from the open statements list. Resulting in concurrent modification
1:70f7692:         // on the open statements list.
1:70f7692:         // Notice that ordinary Statement.closeX() is never called on the positioned update statement,
1:70f7692:         // rather markClosed() is called to avoid trying to remove the statement from the openStatements_ list.
1:70f7692:         return preparedStatement;
1:70f7692:     }
1:ac53be6: 
1:69e3d06:     synchronized public CallableStatement prepareCall(String sql)
1:69e3d06:             throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             if (agent_.loggingEnabled()) {
1:d506170:                 agent_.logWriter_.traceEntry(this, "prepareCall", sql);
1:d506170:             }
1:69e3d06: 
1:69e3d06:             ClientCallableStatement cs = prepareCallX(
1:69e3d06:                 sql,
1:69e3d06:                 ResultSet.TYPE_FORWARD_ONLY,
1:69e3d06:                 ResultSet.CONCUR_READ_ONLY,
1:69e3d06:                 holdability());
1:69e3d06: 
1:d506170:             if (agent_.loggingEnabled()) {
1:d506170:                 agent_.logWriter_.traceExit(this, "prepareCall", cs);
1:d506170:             }
1:d506170:             return cs;
1:70f7692:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:2ba89c5: 
1:69e3d06:     synchronized ClientPreparedStatement prepareDynamicCatalogQuery(String sql)
1:69e3d06:             throws SqlException {
1:69e3d06:         ClientPreparedStatement ps = newPreparedStatement_(
1:69e3d06:             sql,
1:69e3d06:             ResultSet.TYPE_FORWARD_ONLY,
1:69e3d06:             ResultSet.CONCUR_READ_ONLY,
1:69e3d06:             holdability(),
1:69e3d06:             Statement.NO_GENERATED_KEYS,
1:69e3d06:             null,
1:69e3d06:             null);
1:70f7692:         ps.isCatalogQuery_ = true;
1:70f7692:         ps.prepare();
1:dd7d579:         openStatements_.put(ps, null);
6:70f7692:         return ps;
1:70f7692:     }
1:70f7692: 
1:d506170:     public String nativeSQL(String sql) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             if (agent_.loggingEnabled()) {
1:d506170:                 agent_.logWriter_.traceEntry(this, "nativeSQL", sql);
1:d506170:             }
1:d506170:             String nativeSql = nativeSQLX(sql);
1:d506170:             if (agent_.loggingEnabled()) {
1:d506170:                 agent_.logWriter_.traceExit(this, "nativeSQL", nativeSql);
1:d506170:             }
1:d506170:             return nativeSql;
1:70f7692:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:d506170: 
1:70f7692:     }
1:70f7692: 
1:0326967:     synchronized String nativeSQLX(String sql) throws SqlException {
1:d506170:         checkForClosedConnection();
1:70f7692:         if (sql == null) {
1:a53b758:             throw new SqlException(agent_.logWriter_,
1:e65b4db:                     new ClientMessageId (SQLState.NULL_SQL_TEXT));
1:70f7692:         }
1:70f7692: 
1:70f7692:         // Derby can handle the escape syntax directly so only needs escape
1:70f7692:         // processing for { ? = CALL  ....}
1:70f7692:         String trimSql = sql.trim();
1:70f7692:         if (trimSql.startsWith("{")) {
1:70f7692:             if (trimSql.lastIndexOf("}") >= 0) {
1:70f7692:                 return trimSql.substring(1, trimSql.lastIndexOf("}"));
1:70f7692:             }
1:70f7692:         }
1:70f7692: 
1:70f7692:         return trimSql;
1:70f7692:     }
1:70f7692: 
1:70f7692:     // Driver-specific determination if local COMMIT/ROLLBACK is allowed;
1:70f7692:     // primary usage is distinction between local and global trans. envs.;
1:69e3d06:     protected abstract boolean allowLocalCommitRollback_() throws SqlException;
1:70f7692: 
1:d506170:     synchronized public void setAutoCommit(boolean autoCommit) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             if (agent_.loggingEnabled()) {
1:d506170:                 agent_.logWriter_.traceEntry(this, "setAutoCommit", autoCommit);
1:d506170:             }
1:d506170:             checkForClosedConnection();
1:70f7692: 
1:38083d6:             if (! allowLocalCommitRollback_()) {
1:d506170:                 if (autoCommit) { // can't toggle to autocommit mode when between xars.start() and xars.end()
1:a53b758:                     throw new SqlException(agent_.logWriter_,
1:e65b4db:                             new ClientMessageId (SQLState.DRDA_NO_AUTOCOMMIT_UNDER_XA));                            
1:d506170:                 }
1:76af6ed:             } else {
1:d506170:                 if (autoCommit == autoCommit_) {
1:d506170:                     return; // don't flow a commit if nothing changed.
1:d506170:                 }
1:d506170:                 if (inUnitOfWork_) {
1:d506170:                     flowCommit(); // we are not between xars.start() and xars.end(), can flow commit
1:d506170:                 }
1:70f7692:             }
1:d506170:             autoCommit_ = autoCommit;
1:d506170:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:d506170:     public boolean getAutoCommit() throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             checkForClosedConnection();
1:d506170:             if (agent_.loggingEnabled()) {
1:d506170:                 agent_.logWriter_.traceExit(this, "getAutoCommit", autoCommit_);
1:d506170:             }
1:38083d6:             if (! allowLocalCommitRollback_()) { // autoCommit is always false between xars.start() and xars.end()
1:d506170:                 return false;
1:d506170:             }
1:d506170:             return autoCommit_;
1:70f7692:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:d506170:     synchronized public void commit() throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             if (agent_.loggingEnabled()) {
1:d506170:                 agent_.logWriter_.traceEntry(this, "commit");
1:d506170:             }
1:320777f:             checkForClosedConnection();
1:70f7692: 
1:d506170:             // the following XA State check must be in commit instead of commitX since
1:d506170:             // external application call commit, the SqlException should be thrown
1:d506170:             // only if an external application calls commit during a Global Transaction,
1:d506170:             // internal code will call commitX which will ignore the commit request
1:d506170:             // while in a Global transaction
1:d506170:             checkForInvalidXAStateOnCommitOrRollback();
1:66a9818:             flowCommit();
1:d506170:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:d506170:         }
1:70f7692:     }
1:70f7692: 
1:70f7692:     private void checkForInvalidXAStateOnCommitOrRollback() throws SqlException {
1:38083d6:         if (! allowLocalCommitRollback_()) {
1:a53b758:             throw new SqlException(agent_.logWriter_,
1:e65b4db:                 new ClientMessageId(SQLState.DRDA_INVALID_XA_STATE_ON_COMMIT_OR_ROLLBACK));
1:70f7692:         }
1:70f7692:     }
1:0326967: 
1:0326967:     private void flowCommit() throws SqlException {
1:70f7692:         // Per JDBC specification (see javadoc for Connection.commit()):
1:70f7692:         //   "This method should be used only when auto-commit mode has been disabled."
1:70f7692:         // However, some applications do this anyway, it is harmless, so
1:70f7692:         // if they ask to commit, we could go ahead and flow a commit.
1:70f7692:         // But note that rollback() is less harmless, rollback() shouldn't be used in auto-commit mode.
1:70f7692:         // This behavior is subject to further review.
1:70f7692: 
1:89c399d:         //DERBY-4653
1:89c399d:         //If we are not in a transaction, we don't want to flow commit. We just return.
1:89c399d:         if (!this.inUnitOfWork_)
1:89c399d:              return;       
1:70f7692:         if (isXAConnection_) {
1:70f7692:             agent_.beginWriteChainOutsideUOW();
1:70f7692:             writeCommit();
1:70f7692:             agent_.flowOutsideUOW();
1:70f7692:             readCommit(); // This will invoke the commitEvent() callback from the material layer.
1:70f7692:             agent_.endReadChain();
1:b1b9120:         } else {
1:70f7692:             agent_.beginWriteChain(null);
1:70f7692:             writeCommit();
1:70f7692:             agent_.flow(null);
1:70f7692:             readCommit(); // This will invoke the commitEvent() callback from the material layer.
1:70f7692:             agent_.endReadChain();
1:70f7692:         }
1:70f7692: 
1:70f7692:     }
1:70f7692: 
1:70f7692:     // precondition: autoCommit_ is true
1:e3acc4a:     public boolean flowAutoCommit() throws SqlException {
1:70f7692:         if (willAutoCommitGenerateFlow()) {
1:8055511:             flowCommit();
1:e3acc4a:             return true;
1:70f7692:         }
1:e3acc4a:         return false;
1:70f7692:     }
1:70f7692: 
1:b13b17c:     public boolean willAutoCommitGenerateFlow() throws SqlException {
1:70f7692:         if (!autoCommit_) {
3:70f7692:             return false;
1:70f7692:         }
1:38083d6:         if (! allowLocalCommitRollback_()) {
1:70f7692:             return false;
1:70f7692:         }
1:70f7692:         return true;
1:70f7692:     }
1:70f7692: 
1:70f7692:     // precondition: autoCommit_ is true
1:70f7692:     void writeAutoCommit() throws SqlException {
1:70f7692:         if (willAutoCommitGenerateFlow()) {
1:70f7692:             writeCommit();
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:0326967:     void writeCommit() throws SqlException {
1:70f7692:         if (isXAConnection_) {
1:dadd05a:             writeXACommit_ ();
1:d506170:         } else {
1:70f7692:             writeLocalCommit_();
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:70f7692:     // precondition: autoCommit_ is true
1:70f7692:     void readAutoCommit() throws SqlException {
1:70f7692:         if (willAutoCommitGenerateFlow()) {
1:70f7692:             readCommit();
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:0326967:     void readCommit() throws SqlException {
1:70f7692:         if (isXAConnection_) {
1:dadd05a:             readXACommit_ ();
4:70f7692:         } else {
1:70f7692:             readLocalCommit_();
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:d506170:     synchronized public void rollback() throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             if (agent_.loggingEnabled()) {
1:d506170:                 agent_.logWriter_.traceEntry(this, "rollback");
1:d506170:             }
1:a53b758:             
1:795f705:             if ( !isAborting() ) { checkForClosedConnection(); }
1:d506170:             checkForInvalidXAStateOnCommitOrRollback();
1:70f7692: 
1:d506170:             flowRollback();
1:d506170:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:70f7692:     // Even if we're not in a transaction, all open result sets will be closed.
1:70f7692:     // So we could probably just return if we're not in a transaction
1:70f7692:     // using the following code:
1:70f7692:     //     if (!this.inUnitOfWork)
1:70f7692:     //       return;
1:70f7692:     // But we'll just play it safe, and blindly flow the rollback.
1:70f7692:     // We won't try to be "too smart", if the user requests a rollback, we'll flow a rollback,
1:70f7692:     // regardless of whether or not we're in a unit of work or in auto-commit mode.
1:795f705:     //
1:70f7692:     // Per JDBC specification (see javadoc for Connection.rollback()):
1:70f7692:     //   "This method should be used only when auto-commit mode has been disabled."
1:70f7692:     // However, rather than trying to be too smart, we'll just flow the rollback anyway
1:70f7692:     // before throwing an exception.
1:70f7692:     // As a side-effect of invoking rollback() in auto-commit mode,
1:70f7692:     // we'll close all open result sets on this connection in the rollbackEvent().
1:795f705:     //
1:70f7692:     protected void flowRollback() throws SqlException {
1:70f7692:         if (isXAConnection_) {
1:70f7692:             agent_.beginWriteChainOutsideUOW();
1:70f7692:             writeRollback();
1:70f7692:             agent_.flowOutsideUOW();
1:70f7692:             readRollback(); // This method will invoke the rollbackEvent() callback from the material layer.
1:70f7692:             agent_.endReadChain();
1:70f7692:         } else {
1:70f7692:             agent_.beginWriteChain(null);
1:70f7692:             writeRollback();
1:70f7692:             agent_.flow(null);
1:70f7692:             readRollback(); // This method will invoke the rollbackEvent() callback from the material layer.
1:70f7692:             agent_.endReadChain();
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:0326967:     private void writeRollback() throws SqlException {
1:70f7692:         if (isXAConnection_) {
1:dadd05a:             writeXARollback_ ();
1:70f7692:         } else {
1:70f7692:             writeLocalRollback_();
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:0326967:     private void readRollback() throws SqlException {
1:70f7692:         if (isXAConnection_) {
1:70f7692:             readLocalXARollback_();
1:70f7692:         } else {
1:70f7692:             readLocalRollback_();
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:d506170:     synchronized public void close() throws SQLException {
1:d506170:         if (agent_.loggingEnabled()) {
1:70f7692:             agent_.logWriter_.traceEntry(this, "close");
1:70f7692:         }
1:70f7692:         closeX();
1:70f7692:     }
1:33776ff: 
1:c6c4d4d:     /**
1:902041a:      * Check if the transaction is in progress and the connection cannot be
1:902041a:      * closed.
1:902041a:      *
1:902041a:      * @throws SqlException if the connection cannot be closed because the
1:902041a:      * transaction is active
1:902041a:      */
1:70f7692:     void checkForTransactionInProgress() throws SqlException {
1:70f7692:         // The following precondition matches CLI semantics, see SQLDisconnect()
1:902041a:         if (transactionInProgress()) {
1:a53b758:             throw new SqlException(agent_.logWriter_,
1:e65b4db:                     new ClientMessageId (SQLState.CANNOT_CLOSE_ACTIVE_CONNECTION));                   
1:70f7692:         }
1:70f7692:     }
1:902041a: 
1:902041a:     /**
1:902041a:      * Check if there are uncommitted operations in the current transaction
1:902041a:      * that prevent us from closing the connection.
1:902041a:      *
1:902041a:      * @return {@code true} if the connection cannot be closed due to
1:902041a:      * uncommitted operations in the transaction
1:902041a:      */
1:494a328:     public boolean transactionInProgress() {
1:902041a:         return inUnitOfWork_ && !allowCloseInUOW_();
1:494a328:     }
1:b16fdc6: 
1:70f7692:     // This is a no-op if the connection is already closed.
1:68968aa:     private void closeX() throws SQLException {
1:795f705:         if (!open_ && !isAborting()) {
1:70f7692:             return;
1:70f7692:         }
1:70f7692:         closeResourcesX();
1:70f7692:     }
1:494a328: 
1:70f7692:     // Close physical socket or attachment even if connection is marked close.
1:70f7692:     // Used by ClientPooledConnection.close().
1:d506170:     synchronized public void closeResources() throws SQLException {
1:70f7692:         if (open_ || (!open_ && availableForReuse_)) {
1:70f7692:             availableForReuse_ = false;
1:70f7692:             closeResourcesX();
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:d506170:     private void closeResourcesX() throws SQLException {
1:795f705: 
1:d506170:         try
1:d506170:         {
1:d506170:             checkForTransactionInProgress();
1:d506170:         }
1:d506170:         catch ( SqlException e )
1:d506170:         {
1:d506170:             throw e.getSQLException();
1:d506170:         }
1:d506170:         
1:70f7692:         resetConnectionAtFirstSql_ = false; // unset indicator of deferred reset
1:d506170:         SQLException accumulatedExceptions = null;
1:0b963b2: 
1:0b963b2:         //Close prepared statements associated with isolation level change
1:69e3d06:         for (ClientPreparedStatement ps :
1:69e3d06:                  isolationLevelPreparedStmts.values()) {
1:c7f0048:             try {
1:c7f0048:                 ps.close();
1:c7f0048:             } catch (SQLException se) {
1:c7f0048:                 accumulatedExceptions = Utils.accumulateSQLException(
1:c7f0048:                         se, accumulatedExceptions);
1:0b963b2:             }
1:ac53be6:         }
1:c7f0048:         isolationLevelPreparedStmts.clear();
1:45a8204:         if (getTransactionIsolationPrepStmt != null) {
1:0b963b2:             try {
1:45a8204:                 getTransactionIsolationPrepStmt.close();
1:0b963b2:             } catch (SQLException se) {
1:0b963b2:                 accumulatedExceptions = Utils.accumulateSQLException(
1:0b963b2:                         se, accumulatedExceptions);
1:ac53be6:             }
1:795f705:         }
1:45a8204:         getTransactionIsolationPrepStmt = null;
1:ac53be6:         try {
1:70f7692:             flowClose();
4:70f7692:         } catch (SqlException e) {
1:70f7692:             accumulatedExceptions =
1:d506170:                     Utils.accumulateSQLException(
1:d506170:                         e.getSQLException(), accumulatedExceptions);
1:70f7692:         }
1:70f7692: 
1:76af6ed:         markClosed(false);
1:795f705:         aborting_ = false;
1:795f705:         try {
1:70f7692:             agent_.close();
1:70f7692:         } catch (SqlException e) {
1:d506170:             throw Utils.accumulateSQLException(e.getSQLException(), 
1:d506170:                 accumulatedExceptions);
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:70f7692:     protected abstract boolean isGlobalPending_();
1:70f7692: 
1:70f7692:     // Just like closeX except the socket is not pulled.
1:70f7692:     // Physical resources are not closed.
1:b565f41:     synchronized void closeForReuse(boolean statementPooling)
1:8269b78:             throws SqlException {
1:70f7692:         if (!open_) {
1:70f7692:             return;
1:70f7692:         }
1:70f7692:         resetConnectionAtFirstSql_ = false; // unset indicator of deferred reset
2:70f7692:         SqlException accumulatedExceptions = null;
9:70f7692:         try {
1:70f7692:             flowClose();
1:70f7692:         } catch (SqlException e) {
1:70f7692:             accumulatedExceptions = e;
1:70f7692:         }
1:70f7692:         if (open_) {
1:76af6ed:             markClosedForReuse(statementPooling);
1:70f7692:         }
1:70f7692:         if (accumulatedExceptions != null) {
1:70f7692:             throw accumulatedExceptions;
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:70f7692:     private void flowClose() throws SqlException {
1:70f7692:         agent_.beginWriteChainOutsideUOW();
1:70f7692:         if (doCloseStatementsOnClose_()) {
1:70f7692:             writeCloseStatements();
1:70f7692:         }
1:70f7692:         if (autoCommit_) {
1:70f7692:             writeAutoCommit();
1:70f7692:         }
1:70f7692:         agent_.flowOutsideUOW();
1:70f7692:         if (doCloseStatementsOnClose_()) {
1:70f7692:             readCloseStatements();
1:70f7692:         }
1:70f7692:         if (autoCommit_) {
1:70f7692:             readAutoCommit();
1:70f7692:         }
1:70f7692:         agent_.endReadChain();
1:70f7692:     }
1:70f7692: 
1:70f7692:     protected abstract void markClosed_();
1:70f7692: 
1:0326967:     private void markClosed(boolean statementPooling)
1:795f705:     {
1:70f7692:         open_ = false;
3:70f7692:         inUnitOfWork_ = false;
1:76af6ed:         if (!statementPooling) {
1:76af6ed:             markStatementsClosed();
1:76af6ed:         }
1:70f7692:         CommitAndRollbackListeners_.clear();
1:70f7692:         markClosed_();
1:70f7692:     }
1:70f7692: 
1:70f7692: 
1:76af6ed:     private void markClosedForReuse(boolean statementPooling) {
1:70f7692:         availableForReuse_ = true;
1:76af6ed:         markClosed(statementPooling);
1:70f7692:     }
1:70f7692: 
1:70f7692:     private void markStatementsClosed() {
1:69e3d06:         Set<ClientStatement> keySet = openStatements_.keySet();
1:69e3d06:         for (Iterator<ClientStatement> i = keySet.iterator(); i.hasNext();) {
1:69e3d06:             ClientStatement stmt = i.next();
1:70f7692:             stmt.markClosed();
1:70f7692:             i.remove();
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:70f7692:     private void writeCloseStatements() throws SqlException {
1:69e3d06:         Set<ClientStatement> keySet = openStatements_.keySet();
1:69e3d06:         for (Iterator<ClientStatement> i = keySet.iterator(); i.hasNext();) {
1:4772c7e:             i.next().writeClose(false); // false means don't permit auto-commits
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:70f7692:     private void readCloseStatements() throws SqlException {
1:69e3d06:         Set<ClientStatement> keySet = openStatements_.keySet();
1:69e3d06:         for (Iterator<ClientStatement> i = keySet.iterator(); i.hasNext();) {
1:4772c7e:             i.next().readClose(false); // false means don't permit auto-commits
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:38083d6:    /**
1:7f6e8aa:     *   Return true if the physical connection is still open.
1:7f6e8aa:     *   Might be logically closed but available for reuse.
1:38083d6:     *   @return true if physical connection still open
1:38083d6:     */
1:88c25bb:     public boolean isPhysicalConnClosed() {
1:38083d6:     return !open_ && !availableForReuse_; 
1:38083d6:    }
1:38083d6: 
1:70f7692:    
1:70f7692:     public boolean isClosed() {
1:d506170:         if (agent_.loggingEnabled()) {
1:70f7692:             agent_.logWriter_.traceExit(this, "isClosed", !open_);
1:70f7692:         }
1:70f7692:         return !open_;
1:70f7692:     }
1:38083d6: 
1:70f7692:    
1:70f7692:     public boolean isClosedX() {
1:70f7692:         return !open_;
1:70f7692:     }
1:70f7692: 
1:70f7692:     private static String DERBY_TRANSACTION_REPEATABLE_READ = "RS";
1:70f7692:     private static String DERBY_TRANSACTION_SERIALIZABLE = "RR";
1:70f7692:     private static String DERBY_TRANSACTION_READ_COMMITTED = "CS";
1:70f7692:     private static String DERBY_TRANSACTION_READ_UNCOMMITTED = "UR";
1:70f7692: 
1:d506170:     synchronized public void setTransactionIsolation(int level) throws SQLException {
1:2aa6cce:         if (agent_.loggingEnabled()) {
1:2aa6cce:             agent_.logWriter_.traceEntry(this, "setTransactionIsolation", level);
1:2aa6cce:         }
1:2f3d052:         //This avoids assertion like DERBY-4343 by short-circuiting
1:2f3d052:         //setTransactionIsolation. Before this check, for case as users
1:2f3d052:         //obtaining the pooled connection for the third time, the variable
1:2f3d052:         //isolation_ is reset Connection.completeReset. 
1:2f3d052:         //Isolation_ remain as UNKNOWN until getTransactionIsolation is called
1:2f3d052:         //or a different statement causing a change of the isolation level
1:2f3d052:         //is executed.We might think about change the default value for Isolation_
1:2f3d052:         //to DERBY_TRANSACTION_READ_COMMITTED. With introducing 
1:2f3d052:         //getTransactionIsolationX and this check, assertion is never reach. 
1:2f3d052:         //As part of DERBY-4314 fix, the client driver should act as embedded 
1:2f3d052:         //and return here, otherwise setTransactionIsolation will commit 
1:2f3d052:         //the transaction which is not the intention.
1:2f3d052:         if (level == getTransactionIsolationX()) 
1:6eb29f6:         return;
1:2f3d052: 
1:2aa6cce:         try {
1:69e3d06:             // Per jdbc spec (see Connection.close() javadoc).
1:d506170:             checkForClosedConnection();
1:2aa6cce:             setTransactionIsolationX(level);
1:2aa6cce:         } catch (SqlException se) {
1:d506170:             throw se.getSQLException();
1:d506170:         }
1:70f7692:     }
1:beecb26: 
1:ad94e28:     /**
1:2aa6cce:      * Set the transaction isolation level as specified.
1:2aa6cce:      * <p>
1:2aa6cce:      * If this method is called during a transaction, the result is
1:2aa6cce:      * implementation-defined.
1:2aa6cce:      * <p>
1:2aa6cce:      * Information about Derby specific isolation level handling:
1:2aa6cce:      * <ul> <li>REPEATABLE_READ = JDBC: TRANSACTION_SERIALIZABLE, DERBY: RR,
1:2aa6cce:      *          PROTOCOL: repeatable read</li>
1:2aa6cce:      *      <li>READ_STABILITY = JDBC: TRANSACTION_REPEATABLE_READ, DERBY: RS,
1:2aa6cce:      *          PROTOCOL: All</li>
1:2aa6cce:      *      <li>CURSOR_STABILITY = JDBC: TRANSACTION_READ_COMMITTED, DERBY: CS,
1:2aa6cce:      *          PROTOCOL: Cursor stability</li>
1:2aa6cce:      *      <li>UNCOMMITTED_READ = JDBC: TRANSACTION_READ_UNCOMMITTED,
1:2aa6cce:      *          DERBY: UR, PROTOCOL: Change</li>
1:2aa6cce:      *      <li>NO_COMMIT = JDBC: TRANSACTION_NONE, DERBY: NC, PROTOCOL:
1:2aa6cce:      *          No commit</li>
1:2aa6cce:      * </ul>
1:2aa6cce:      */
1:2aa6cce:     //@GuardedBy("this")
1:2aa6cce:     private void setTransactionIsolationX(int level)
1:8269b78:             throws SqlException {
1:2aa6cce:         String levelString = null;
1:2aa6cce:         switch (level) {
1:69e3d06:         case ClientConnection.TRANSACTION_REPEATABLE_READ:
1:2aa6cce:             levelString = DERBY_TRANSACTION_REPEATABLE_READ;
1:2aa6cce:             break;
1:69e3d06:         case ClientConnection.TRANSACTION_READ_COMMITTED:
1:2aa6cce:             levelString = DERBY_TRANSACTION_READ_COMMITTED;
1:2aa6cce:             break;
1:69e3d06:         case ClientConnection.TRANSACTION_SERIALIZABLE:
1:2aa6cce:             levelString = DERBY_TRANSACTION_SERIALIZABLE;
1:2aa6cce:             break;
1:69e3d06:         case ClientConnection.TRANSACTION_READ_UNCOMMITTED:
1:2aa6cce:             levelString = DERBY_TRANSACTION_READ_UNCOMMITTED;
1:2aa6cce:             break;
1:2aa6cce:             // Per javadoc:
1:2aa6cce:             //   Note that Connection.TRANSACTION_NONE cannot be used because it
1:2aa6cce:             //   specifies that transactions are not supported.
1:69e3d06:         case Connection.TRANSACTION_NONE:
1:2aa6cce:         default:
1:2aa6cce:             throw new SqlException(agent_.logWriter_,
1:2aa6cce:                 new ClientMessageId (SQLState.UNIMPLEMENTED_ISOLATION_LEVEL),
1:66527ec:                 level);
1:2aa6cce:         }
1:0b963b2:         //If we do not already have a prepared statement for the requested
1:0b963b2:         // isolation level change, then create one
1:69e3d06:         ClientPreparedStatement ps =
1:69e3d06:             (ClientPreparedStatement)isolationLevelPreparedStmts.
1:69e3d06:             get(levelString);
1:69e3d06: 
1:0b963b2:         if (ps == null  || !ps.openOnClient_) {
1:0b963b2:             ps = prepareStatementX(
1:0b963b2:                     "SET CURRENT ISOLATION = " + levelString,
1:69e3d06:                     ResultSet.TYPE_FORWARD_ONLY,
1:69e3d06:                     ResultSet.CONCUR_READ_ONLY,
1:0b963b2:                     holdability(),
1:69e3d06:                     Statement.NO_GENERATED_KEYS,
1:0b963b2:                     null, null);
1:0b963b2:             isolationLevelPreparedStmts.put(levelString, ps);
1:2aa6cce:         }
1:0b963b2:         //Execute the prepared statement to change the isolation level
1:2aa6cce:         try {
1:0b963b2:             ps.execute();
1:2aa6cce:         } catch (SQLException sqle) {
1:2aa6cce:             throw new SqlException(sqle);
1:2aa6cce:         }
1:b16fdc6: 
1:2aa6cce:         // The server has now implicitly committed the
1:2aa6cce:         // transaction so we have to clean up locally.
1:2aa6cce:         completeLocalCommit();
1:b16fdc6: 
1:c6c4d4d:         if (SanityManager.DEBUG && supportsSessionDataCaching()) {
1:c6c4d4d:             SanityManager.ASSERT(isolation_ == level);
1:c6c4d4d:         }
1:2aa6cce:     }
1:b16fdc6: 
1:76af6ed:     /**
1:c6c4d4d:      * Finds out if the underlaying database connection supports session data
1:c6c4d4d:      * caching.
1:c6c4d4d:      * @return true if sessionData is supported
1:c6c4d4d:      */
1:c6c4d4d:     protected abstract boolean supportsSessionDataCaching();
1:c6c4d4d: 
1:f55d30a:     /**
1:f55d30a:      * Checks whether the server supports locators for large objects.
1:c2af295:      * Note that even though the server supports LOB locators, the database
1:c2af295:      * that is accessed through the server may not have the necessary stored
1:c2af295:      * procedures to support LOB locators (e.g., because the database is
1:c2af295:      * soft upgraded from an earlier version).
1:ad94e28:      *
1:f55d30a:      * @return {@code true} if LOB locators are supported.
1:f55d30a:      */
1:f55d30a:     protected abstract boolean serverSupportsLocators();
1:f55d30a: 
1:bead0ab:     /** Return true if the server supports nanoseconds in timestamps */
1:bead0ab:     protected abstract boolean serverSupportsTimestampNanoseconds();
1:bead0ab: 
1:d506170:     public int getTransactionIsolation() throws SQLException {
1:2f3d052: 
1:2f3d052:         if (agent_.loggingEnabled()) {
1:2f3d052:             agent_.logWriter_.traceEntry(this, "getTransactionIsolation", isolation_);
1:2f3d052:         }
1:2f3d052:         try {
1:69e3d06:             // Per jdbc spec (see Connection.close() javadoc).
1:2f3d052:             checkForClosedConnection();
1:2f3d052:             return getTransactionIsolationX();
1:2f3d052:         } catch (SqlException se) {
1:2f3d052:             throw se.getSQLException();
1:2f3d052:         }
1:2f3d052:     }
1:2f3d052: 
1:2f3d052:     public int getTransactionIsolationX() throws SQLException {
1:6eb29f6:         // Store the current auto-commit value and use it to restore 
1:6eb29f6:         // at the end of this method.
1:6eb29f6:         boolean currentAutoCommit = autoCommit_;
1:69e3d06:         ResultSet rs = null;
1:d506170:         try
1:d506170:         {
1:d506170:             checkForClosedConnection();
1:6eb29f6:             
1:c6c4d4d:             if (isolation_ != TRANSACTION_UNKNOWN) {
1:c6c4d4d:                 if (SanityManager.DEBUG) {
1:c6c4d4d:                     SanityManager.ASSERT(supportsSessionDataCaching(),
1:c6c4d4d:                             "Cannot return cached isolation when caching is " +
1:c6c4d4d:                             "not supported!");
1:c6c4d4d:                 }
1:c6c4d4d:                 return isolation_;
1:c6c4d4d:             }
1:c6c4d4d: 
1:ac53be6:             // Set auto-commit to false when executing the statement as we do not want to
1:ac53be6:             // cause an auto-commit from getTransactionIsolation() method. 
1:ac53be6:             autoCommit_ = false;
1:ac53be6:             
1:45a8204:             // DERBY-6066(Client should use a prepared statement rather than 
1:45a8204:             //  regular statement for Connection.getTransactionIsolation)
1:45a8204:             // Following code(which actually sends the get transaction 
1:45a8204:             //  isolation call to the server on the wire) will be executed 
1:45a8204:             //  in at least following 2 cases
1:45a8204:             // 1)When a newer client is working with the older versions of 
1:45a8204:             //   servers(ie server that do not have support for isolation 
1:45a8204:             //   level caching) - Server version 10.3 and earlier do not 
1:45a8204:             //   support isolation level caching and hence when a newer 
1:45a8204:             //   client(10.4 and higher) is talking to a 10.3 and earlier 
1:45a8204:             //   server, the if condition above will be false and the code 
1:45a8204:             //   will reach here to get the isolation level from the server 
1:45a8204:             //   by sending "VALUES CURRENT ISOLATION" over the wire. For 
1:45a8204:             //   server versions 10.4 and above, the if condition above can 
1:45a8204:             //   be true if the isolation level was already piggybacked to 
1:45a8204:             //   the client as part of some other client server communication
1:45a8204:             //   and hence the current isolation level is already available to 
1:45a8204:             //   the client and there is no need to send 
1:45a8204:             //   "VALUES CURRENT ISOLATION" over the wire to the server.
1:45a8204:             // 2)Additionally, as per DERBY-4314 and write up on piggybacking
1:45a8204:             //    at http://wiki.apache.org/db-derby/Derby3192Writeup, there 
1:45a8204:             //    might be cases, where even though server has support for 
1:45a8204:             //    isolation level caching, server has not had a chance to 
1:45a8204:             //    send the isolation level piggybacked to the client as part  
1:45a8204:             //    of some other communication between client and server and 
1:45a8204:             //    hence the if condition above will be false and client will
1:45a8204:             //    actually need to send "VALUES CURRENT ISOLATION" to the 
1:45a8204:             //    server to get the current isolation level.
1:45a8204:             // 
1:ac53be6:             // DERBY-1148 - Client reports wrong isolation level. We need to get the isolation
1:ac53be6:             // level from the server. 'isolation_' maintained in the client's connection object
1:ac53be6:             // can be out of sync with the real isolation when in an XA transaction. This can 
1:ac53be6:             // also happen when isolation is set using SQL instead of JDBC. So we try to get the
1:ac53be6:             // value from the server by calling the "current isolation" function. If we fail to 
1:ac53be6:             // get the value, return the value stored in the client's connection object.
1:c6c4d4d:             // DERBY-3192 - Cache session data in the client driver allows
1:c6c4d4d:             // the re-introduction of isolation level caching. Changes to the
1:c6c4d4d:             // isolation level triggered from SQL are now handled by
1:c6c4d4d:             // piggybacking the modified isolation level on messages going
1:c6c4d4d:             // back to the client.
1:c6c4d4d:             // The XA-problem is handled by letting XA state changes set the
1:c6c4d4d:             // cached isolation level to TRANSACTION_UNKNOWN which will trigger
1:c6c4d4d:             // a refresh from the server.
1:45a8204:             if (getTransactionIsolationPrepStmt == null  || 
1:74fb1b0:                     !getTransactionIsolationPrepStmt.openOnClient_) {
1:45a8204:             	getTransactionIsolationPrepStmt =
1:45a8204:                         prepareStatementX(
1:45a8204:                                 "VALUES CURRENT ISOLATION",
1:69e3d06:                                 ResultSet.TYPE_FORWARD_ONLY,
1:69e3d06:                                 ResultSet.CONCUR_READ_ONLY,
1:45a8204:                                 holdability(),
1:69e3d06:                                 Statement.NO_GENERATED_KEYS,
1:45a8204:                                 null, null);
1:ac53be6:             }
1:ac53be6:             
1:00b1b6d:             boolean savedInUnitOfWork = inUnitOfWork_;
1:45a8204:             rs = getTransactionIsolationPrepStmt.executeQuery();
1:ac53be6:             rs.next();
1:ac53be6:             String isolationStr = rs.getString(1);
1:c6c4d4d: 
1:c6c4d4d:             int isolation = translateIsolation(isolationStr);
1:c6c4d4d:             if (isolation_ == TRANSACTION_UNKNOWN &&
1:c6c4d4d:                     supportsSessionDataCaching()) {
1:c6c4d4d:                 // isolation_ will be TRANSACTION_UNKNOWN if the connection has
1:c6c4d4d:                 // been reset on
1:c6c4d4d:                 // the client. The server will not observe a
1:c6c4d4d:                 // change in isolation level so no information is
1:c6c4d4d:                 // piggy-backed. Update the cached value here, rather than
1:c6c4d4d:                 // waiting for the isolation to change on the server.
1:c6c4d4d:                 isolation_ = isolation;
1:c6c4d4d:             }
1:c6c4d4d:             if (SanityManager.DEBUG) {
1:c6c4d4d:                 SanityManager.ASSERT(!supportsSessionDataCaching() ||
1:c6c4d4d:                         (isolation_ == isolation),
1:c6c4d4d:                         "Cached isolation_ not updated, (isolation_="+
1:c6c4d4d:                         isolation_+")!=(isolation="+isolation+")");
1:c6c4d4d:                 SanityManager.ASSERT(supportsSessionDataCaching() ||
1:c6c4d4d:                         (isolation_ == TRANSACTION_UNKNOWN),
1:c6c4d4d:                         "isolation_ modified when caching is not supported");
1:c6c4d4d:             }
1:7f6e8aa:             rs.close();
1:00b1b6d:             // So... of we did not have an active transaction before
1:00b1b6d:             // the query, we pretend to still not have an open
1:00b1b6d:             // transaction. The result set is closed, so this should
1:00b1b6d:             // not be problematic. DERBY-2084
1:00b1b6d:             inUnitOfWork_ = savedInUnitOfWork;
1:c6c4d4d: 
1:c6c4d4d:             return isolation;
1:2aa6cce:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:d506170:         }
1:ac53be6:         finally {
1:6eb29f6:             // Restore auto-commit value
1:6eb29f6:             autoCommit_ = currentAutoCommit;
1:6eb29f6:             if(rs != null)
1:6eb29f6:                 rs.close();
1:ac53be6:         }
1:ac53be6:     }
1:ac53be6:   
1:ac53be6:     /**
1:8055511:      * Returns the ID of the active transaction for this connection.
1:8055511:      * @return the ID of the active transaction
1:8055511:      */
1:8055511:     public int getTransactionID(){
1:66a9818:         return transactionID_;
1:8055511:     }
1:66a9818: 
1:8055511:     /**
1:c6c4d4d:      * Returns the current schema (the schema that would be used for
1:c6c4d4d:      * compilation. This is not part of the java.sql.Connection interface, and
1:c6c4d4d:      * is only intended for use with statement caching.
1:c6c4d4d:      * @return the name of the current schema
1:c6c4d4d:      * @throws java.sql.SQLException
1:c6c4d4d:      */
1:c6c4d4d:     public String getCurrentSchemaName() throws SQLException {
1:c6c4d4d:         try {
1:c6c4d4d:             checkForClosedConnection();
1:c6c4d4d:         } catch (SqlException se) {
1:c6c4d4d:             throw se.getSQLException();
1:c6c4d4d:         }
1:c6c4d4d:         if (currentSchemaName_ == null) {
1:c6c4d4d:             if (agent_.loggingEnabled()) {
1:c6c4d4d:                agent_.logWriter_.traceEntry(this,
1:c6c4d4d:                   "getCurrentSchemaName() executes query");
1:c6c4d4d:             }
1:69e3d06:             Statement s = createStatement();
1:69e3d06:             ResultSet rs = s.executeQuery("VALUES CURRENT SCHEMA");
1:c6c4d4d:             rs.next();
1:c6c4d4d:             String schema = rs.getString(1);
1:c6c4d4d:             rs.close();
1:c6c4d4d:             s.close();
1:c6c4d4d:             return schema;
1:c6c4d4d:         }
1:c6c4d4d:         if (SanityManager.DEBUG) {
1:c6c4d4d:             SanityManager.ASSERT(supportsSessionDataCaching(),
1:c6c4d4d:                     "A cached schema name ("+currentSchemaName_+
1:c6c4d4d:                     ") is not expected when session data caching is not" +
1:c6c4d4d:                     "supported");
1:c6c4d4d:         }
1:c6c4d4d:         return currentSchemaName_;
1:c6c4d4d:     }
1:c6c4d4d: 
1:c6c4d4d:     /**
1:ac53be6:      * Translates the isolation level from a SQL string to the JDBC int value
1:ac53be6:      *  
1:ac53be6:      * @param isolationStr SQL isolation string
1:583cd0f:      * @return isolation level as a JDBC integer value 
1:ac53be6:      */
1:ac53be6:     private int translateIsolation(String isolationStr) {
1:6eb29f6:         if(isolationStr.compareTo(DERBY_TRANSACTION_REPEATABLE_READ) == 0)
1:69e3d06:             return ClientConnection.TRANSACTION_REPEATABLE_READ;
1:6eb29f6:         else if (isolationStr.compareTo(DERBY_TRANSACTION_SERIALIZABLE) == 0)
1:69e3d06:             return ClientConnection.TRANSACTION_SERIALIZABLE;
1:6eb29f6:         else if (isolationStr.compareTo(DERBY_TRANSACTION_READ_COMMITTED) == 0)
1:69e3d06:             return ClientConnection.TRANSACTION_READ_COMMITTED;
1:6eb29f6:         else if (isolationStr.compareTo(DERBY_TRANSACTION_READ_UNCOMMITTED) == 0)
1:69e3d06:             return ClientConnection.TRANSACTION_READ_UNCOMMITTED;
1:6eb29f6:         else 
1:69e3d06:             return ClientConnection.TRANSACTION_NONE;
1:d506170:     }
1:8055511: 
1:69e3d06:     public SQLWarning getWarnings() throws SQLException {
1:d506170:         if (agent_.loggingEnabled()) {
1:70f7692:             agent_.logWriter_.traceExit(this, "getWarnings", warnings_);
1:320777f:         }
1:320777f:         try {
1:320777f:             checkForClosedConnection();
1:320777f:         } catch (SqlException se) {
1:320777f:             throw se.getSQLException();
1:d506170:         }
1:7680ab7:         return warnings_ == null ? null : warnings_.getSQLWarning();
1:d506170:     }
1:ac53be6: 
1:d506170:     synchronized public void clearWarnings() throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             if (agent_.loggingEnabled()) {
1:d506170:                 agent_.logWriter_.traceEntry(this, "clearWarnings");
1:d506170:             }
1:320777f:             checkForClosedConnection();
1:d506170:             clearWarningsX();
1:d506170:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:d506170:         }
1:d506170:     }
1:2aa6cce: 
1:70f7692:     // An untraced version of clearWarnings()
1:0326967:     private void clearWarningsX() throws SqlException {
1:70f7692:         warnings_ = null;
1:70f7692:         accumulated440ForMessageProcFailure_ = false;
1:70f7692:         accumulated444ForMessageProcFailure_ = false;
1:70f7692:     }
1:2aa6cce: 
1:70f7692:     //======================================================================
1:70f7692:     // Advanced features:
1:2aa6cce: 
1:69e3d06:     public DatabaseMetaData getMetaData() throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             checkForClosedConnection();
1:d506170:             if (agent_.loggingEnabled()) {
1:d506170:                 agent_.logWriter_.traceExit(this, "getMetaData", databaseMetaData_);
1:d506170:             }
1:d506170:             return databaseMetaData_;
1:d506170:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:2aa6cce: 
1:d506170:     synchronized public void setReadOnly(boolean readOnly) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             // This is a hint to the driver only, so this request is silently ignored.
1:d506170:             // PROTOCOL can only flow a set-read-only before the connection is established.
1:d506170:             if (agent_.loggingEnabled()) {
1:d506170:                 agent_.logWriter_.traceEntry(this, "setReadOnly", readOnly);
1:d506170:             }
1:d506170:             checkForClosedConnection();
1:d506170:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:2ba89c5: 
1:d506170:     public boolean isReadOnly() throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             checkForClosedConnection();
1:d506170:             if (agent_.loggingEnabled()) {
1:d506170:                 agent_.logWriter_.traceExit(this, "isReadOnly", jdbcReadOnly_);
1:d506170:             }
1:d506170:             return false;
1:d506170:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:d506170:     synchronized public void setCatalog(String catalog) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             if (agent_.loggingEnabled()) {
1:d506170:                 agent_.logWriter_.traceEntry(this, "setCatalog", catalog);
1:d506170:             }
1:d506170:             checkForClosedConnection();
1:d506170:             // Per jdbc spec: if the driver does not support catalogs, it will silently ignore this request.
1:d506170:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:d506170:     public String getCatalog() throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             checkForClosedConnection();
1:d506170:             if (agent_.loggingEnabled()) {
1:d506170:                 agent_.logWriter_.traceExit(this, "getCatalog", (String) null);
1:d506170:             }
1:d506170:             return null;
1:d506170:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:70f7692:     //--------------------------JDBC 2.0-----------------------------
1:70f7692: 
1:69e3d06:     synchronized public Statement createStatement(int resultSetType,
1:d506170:                                                            int resultSetConcurrency) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             if (agent_.loggingEnabled()) {
1:d506170:                 agent_.logWriter_.traceEntry(this, "createStatement", resultSetType, resultSetConcurrency);
1:d506170:             }
1:69e3d06: 
1:69e3d06:             ClientStatement s = createStatementX(
1:69e3d06:                 resultSetType,
1:69e3d06:                 resultSetConcurrency,
1:69e3d06:                 holdability());
1:69e3d06: 
1:d506170:             if (agent_.loggingEnabled()) {
1:d506170:                 agent_.logWriter_.traceExit(this, "createStatement", s);
1:d506170:             }
1:d506170:             return s;
1:70f7692:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:69e3d06:     synchronized public PreparedStatement prepareStatement(String sql,
1:70f7692:                                                                     int resultSetType,
1:d506170:                                                                     int resultSetConcurrency) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             if (agent_.loggingEnabled()) {
1:d506170:                 agent_.logWriter_.traceEntry(this, "prepareStatement", sql, resultSetType, resultSetConcurrency);
1:d506170:             }
1:69e3d06:             ClientPreparedStatement ps = prepareStatementX(sql,
1:d506170:                     resultSetType,
1:d506170:                     resultSetConcurrency,
1:fdfc981:                     holdability(),
1:69e3d06:                     ClientStatement.NO_GENERATED_KEYS,
1:b52081a:                     null, null);
1:d506170:             if (agent_.loggingEnabled()) {
1:d506170:                 agent_.logWriter_.traceExit(this, "prepareStatement", ps);
1:d506170:             }
1:d506170:             return ps;
1:70f7692:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:69e3d06:     synchronized public CallableStatement prepareCall(String sql,
1:70f7692:                                                                int resultSetType,
1:d506170:                                                                int resultSetConcurrency) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             if (agent_.loggingEnabled()) {
1:d506170:                 agent_.logWriter_.traceEntry(this, "prepareCall", sql, resultSetType, resultSetConcurrency);
1:d506170:             }
1:69e3d06: 
1:69e3d06:             ClientCallableStatement cs = prepareCallX(
1:69e3d06:                 sql,
1:69e3d06:                 resultSetType,
1:69e3d06:                 resultSetConcurrency,
1:69e3d06:                 holdability());
1:69e3d06: 
1:d506170:             if (agent_.loggingEnabled()) {
1:d506170:                 agent_.logWriter_.traceExit(this, "prepareCall", cs);
1:d506170:             }
1:d506170:             return cs;
1:70f7692:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:0326967:     synchronized ClientCallableStatement prepareMessageProc(String sql)
1:8269b78:             throws SqlException {
1:d506170:         checkForClosedConnection();
1:70f7692: 
1:69e3d06:         ClientCallableStatement cs = prepareCallX(
1:69e3d06:             sql,
1:69e3d06:             ResultSet.TYPE_FORWARD_ONLY,
1:69e3d06:             ResultSet.CONCUR_READ_ONLY,
1:69e3d06:             holdability());
4:70f7692:         return cs;
1:70f7692:     }
1:70f7692: 
1:70f7692:     // Per jdbc spec, when a result set type is unsupported, we downgrade and
2:70f7692:     // issue a warning rather than to throw an exception.
1:70f7692:     private int downgradeResultSetType(int resultSetType) {
1:69e3d06:         if (resultSetType == ResultSet.TYPE_SCROLL_SENSITIVE) {
1:7680ab7:             accumulateWarning(new SqlWarning(agent_.logWriter_, 
1:e65b4db:                 new ClientMessageId(SQLState.SCROLL_SENSITIVE_NOT_SUPPORTED)));
1:69e3d06:             return ResultSet.TYPE_SCROLL_INSENSITIVE;
1:70f7692:         }
1:70f7692:         return resultSetType;
1:70f7692:     }
1:70f7692: 
1:4772c7e:     public Map<String, Class<?>> getTypeMap() throws SQLException {
1:d506170:         try
1:d506170:         {
1:70f7692:             if (agent_.loggingEnabled()) {
1:d506170:                 agent_.logWriter_.traceEntry(this, "getTypeMap");
1:d506170:             }
1:d506170:             checkForClosedConnection();
1:4772c7e:             Map<String, Class<?>> map = Collections.emptyMap();
1:d506170:             if (agent_.loggingEnabled()) {
1:d506170:                 agent_.logWriter_.traceExit(this, "getTypeMap", map);
1:d506170:             }
1:d506170:             return map;
1:70f7692:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:4772c7e:     synchronized public void setTypeMap(Map map) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             if (agent_.loggingEnabled()) {
1:d506170:                 agent_.logWriter_.traceEntry(this, "setTypeMap", map);
1:d506170:             }
1:d506170:             checkForClosedConnection();
1:d1661b2:             if (map == null) {
1:d1661b2:                 throw new SqlException(agent_.logWriter_,
1:d1661b2:                         new ClientMessageId (SQLState.INVALID_API_PARAMETER),
1:d1661b2:                         map, "map", "setTypeMap");
1:d1661b2:             }
1:d1661b2: 
1:d1661b2:             if (!(map.isEmpty())) {
1:d1661b2:                 throw new SqlException(agent_.logWriter_, new ClientMessageId(
1:d1661b2:                         SQLState.NOT_IMPLEMENTED), "setTypeMap");
1:d1661b2:             }
1:d506170:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }        
1:70f7692:     }
1:70f7692: 
1:70f7692:     //--------------------------JDBC 3.0-----------------------------
1:70f7692: 
1:d506170:     synchronized public void setHoldability(int holdability) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             if (agent_.loggingEnabled()) {
1:d506170:                 agent_.logWriter_.traceEntry(this, "setHoldability", holdability);
1:d506170:             }
1:d506170:             checkForClosedConnection();
1:4388f15:             // In an XA global transaction do not allow the
1:4388f15:             // holdability to be set to hold cursors across
1:4388f15:             // commits, as the engine does not support it.
1:4388f15:             if (this.isXAConnection_ && this.xaState_ == XA_T1_ASSOCIATED)
1:4388f15:             {
1:1e8a20f:                 if (holdability == ResultSet.HOLD_CURSORS_OVER_COMMIT)
1:4388f15:                     throw new SqlException(agent_.logWriter_, 
1:e65b4db:                             new ClientMessageId(SQLState.CANNOT_HOLD_CURSOR_XA));
1:4388f15:             }
1:fdfc981:             this.holdability = holdability;
1:fdfc981:             
1:fdfc981:        }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:fdfc981:         }
1:d506170:     }
1:70f7692: 
1:d506170:     public int getHoldability() throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             checkForClosedConnection();
1:d506170:             if (agent_.loggingEnabled()) {
1:fdfc981:                 agent_.logWriter_.traceExit(this, "getHoldability", holdability());
1:d506170:             }
1:fdfc981:             return holdability();
1:d506170:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:d506170:         }
1:70f7692:     }
1:70f7692: 
1:0326967:     private int dncGeneratedSavepointId_;
1:70f7692:     // generated name used internally for unnamed savepoints
1:0326967:     private static final String
1:0326967:             dncGeneratedSavepointNamePrefix__ = "DNC_GENENERATED_NAME_";
1:70f7692: 
1:69e3d06:     synchronized public Savepoint setSavepoint() throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             if (agent_.loggingEnabled()) {
1:d506170:                 agent_.logWriter_.traceEntry(this, "setSavepoint");
1:d506170:             }
1:d506170:             checkForClosedConnection();
1:d506170:             if (autoCommit_) // Throw exception if auto-commit is on
1:d506170:             {
1:4388f15:                 throw new SqlException(agent_.logWriter_, 
1:e65b4db:                         new ClientMessageId (SQLState.NO_SAVEPOINT_WHEN_AUTO));
1:38083d6:             } 
1:d506170:             // create an un-named savepoint.
1:d506170:             if ((++dncGeneratedSavepointId_) < 0) {
1:d506170:                 dncGeneratedSavepointId_ = 1; // restart from 1 when overflow.
1:d506170:             }
1:69e3d06:             Object s = setSavepointX(
1:69e3d06:                 new ClientSavepoint(agent_, dncGeneratedSavepointId_));
1:69e3d06: 
1:69e3d06:             return (ClientSavepoint) s;
1:d506170:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:69e3d06:     synchronized public Savepoint setSavepoint(String name)
1:69e3d06:             throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             if (agent_.loggingEnabled()) {
1:d506170:                 agent_.logWriter_.traceEntry(this, "setSavepoint", name);
1:d506170:             }
1:d506170:             checkForClosedConnection();
1:d506170:             if (name == null) // Throw exception if savepoint name is null
1:d506170:             {
1:a53b758:                 throw new SqlException(agent_.logWriter_, 
1:e65b4db:                         new ClientMessageId (SQLState.NULL_NAME_FOR_SAVEPOINT));
1:d506170:             } else if (autoCommit_) // Throw exception if auto-commit is on
1:d506170:             {
1:a53b758:                 throw new SqlException(agent_.logWriter_, 
1:e65b4db:                         new ClientMessageId (SQLState.NO_SAVEPOINT_WHEN_AUTO));
1:38083d6:             }
1:d506170:             // create a named savepoint.
1:69e3d06:             Object s = setSavepointX(new ClientSavepoint(agent_, name));
1:69e3d06:             return (ClientSavepoint) s;
1:38083d6:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:d506170:         }
1:d506170:     }
1:70f7692: 
1:69e3d06:     private ClientSavepoint setSavepointX(ClientSavepoint savepoint)
1:69e3d06:             throws SQLException {
1:70f7692:         // Construct and flow a savepoint statement to server.
1:69e3d06:         ClientStatement stmt = null;
1:70f7692:         try {
1:69e3d06:             stmt = (ClientStatement) createStatementX(
1:69e3d06:                 ResultSet.TYPE_FORWARD_ONLY,
1:69e3d06:                 ResultSet.CONCUR_READ_ONLY,
1:69e3d06:                 holdability());
1:69e3d06: 
3:70f7692:             String savepointName;
1:70f7692:             try {
1:70f7692:                 savepointName = savepoint.getSavepointName();
1:d506170:             } catch (SQLException e) {
3:70f7692:                 // generate the name for an un-named savepoint.
3:70f7692:                 savepointName = dncGeneratedSavepointNamePrefix__ +
1:33776ff:                         savepoint.getSavepointId();
1:70f7692:             }
1:1146825:             stmt.executeX(
1:1146825:                     "SAVEPOINT " + Utils.quoteSqlIdentifier(savepointName) +
1:1146825:                     " ON ROLLBACK RETAIN CURSORS");
1:d506170:         } catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
3:70f7692:         } finally {
3:70f7692:             if (stmt != null) {
1:70f7692:                 try {
3:70f7692:                     stmt.closeX();
3:70f7692:                 } catch (SqlException doNothing) {
1:70f7692:                 }
1:70f7692:             }
1:70f7692:         }
1:70f7692: 
1:70f7692:         return savepoint;
1:70f7692:     }
1:70f7692: 
1:69e3d06:     synchronized public void rollback(Savepoint savepoint) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             int saveXaState = xaState_;
1:d506170:             if (agent_.loggingEnabled()) {
1:d506170:                 agent_.logWriter_.traceEntry(this, "rollback", savepoint);
1:d506170:             }
1:d506170:             checkForClosedConnection();
1:d506170:             if (savepoint == null) // Throw exception if savepoint is null
1:d506170:             {
1:a53b758:                 throw new SqlException(agent_.logWriter_, 
1:6eb29f6:                         new ClientMessageId (SQLState.XACT_SAVEPOINT_RELEASE_ROLLBACK_FAIL));
1:d506170:             } else if (autoCommit_) // Throw exception if auto-commit is on
1:d506170:             {
1:a53b758:                 throw new SqlException(agent_.logWriter_, 
1:6eb29f6:                         new ClientMessageId (SQLState.NO_SAVEPOINT_ROLLBACK_OR_RELEASE_WHEN_AUTO));
1:d506170:             } 
1:d506170:             // Only allow to rollback to a savepoint from the connection that create the savepoint.
1:d506170:             try {
1:69e3d06:                 if (this != ((ClientSavepoint) savepoint).agent_.connection_) {
1:a53b758:                     throw new SqlException(agent_.logWriter_,
1:6eb29f6:                             new ClientMessageId (SQLState.SAVEPOINT_NOT_CREATED_BY_CONNECTION));
1:d506170:                 }
1:69e3d06:             } catch (ClassCastException e) {
1:69e3d06:                  // savepoint is not an instance of am.Savepoint
1:a53b758:                 throw new SqlException(agent_.logWriter_,
1:6eb29f6:                         new ClientMessageId (SQLState.SAVEPOINT_NOT_CREATED_BY_CONNECTION));
1:70f7692:             }
1:70f7692: 
1:d506170:             // Construct and flow a savepoint rollback statement to server.
1:69e3d06:             ClientStatement stmt = null;
1:d506170:             try {
1:69e3d06:                 stmt = createStatementX(ResultSet.TYPE_FORWARD_ONLY,
1:69e3d06:                         ResultSet.CONCUR_READ_ONLY,
1:ac53be6:                         holdability());
1:d506170:                 String savepointName;
1:70f7692:                 try {
1:69e3d06:                     savepointName =
1:69e3d06:                         ((ClientSavepoint)savepoint).getSavepointName();
1:d506170:                 } catch (SQLException e) {
1:d506170:                     // generate the name for an un-named savepoint.
1:d506170:                     savepointName = dncGeneratedSavepointNamePrefix__ +
1:69e3d06:                             ((ClientSavepoint) savepoint).getSavepointId();
1:d506170:                 }
1:1146825:                 stmt.executeX(
1:1146825:                         "ROLLBACK TO SAVEPOINT " +
1:1146825:                         Utils.quoteSqlIdentifier(savepointName));
1:d506170:             } finally {
1:d506170:                 if (stmt != null) {
1:70f7692:                     try {
1:d506170:                         stmt.closeX();
1:d506170:                     } catch (SqlException doNothing) {
1:d506170:                     }
1:70f7692:                 }
1:d506170:                 xaState_ = saveXaState;
1:d506170:             }
1:70f7692:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:69e3d06:     synchronized public void releaseSavepoint(Savepoint savepoint)
1:69e3d06:             throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             int saveXaState = xaState_;
1:d506170:             if (agent_.loggingEnabled()) {
1:d506170:                 agent_.logWriter_.traceEntry(this, "releaseSavepoint", savepoint);
1:d506170:             }
1:d506170:             checkForClosedConnection();
1:d506170:             if (savepoint == null) // Throw exception if savepoint is null
1:d506170:             {
1:a53b758:                 throw new SqlException(agent_.logWriter_, 
1:e65b4db:                         new ClientMessageId (SQLState.XACT_SAVEPOINT_RELEASE_ROLLBACK_FAIL));
1:d506170:             } else if (autoCommit_) // Throw exception if auto-commit is on
1:d506170:             {
1:a53b758:                 throw new SqlException(agent_.logWriter_, 
1:e65b4db:                         new ClientMessageId (SQLState.NO_SAVEPOINT_ROLLBACK_OR_RELEASE_WHEN_AUTO));
1:d506170:             } 
1:d506170:             // Only allow to release a savepoint from the connection that create the savepoint.
1:d506170:             try {
1:69e3d06:                 if (this != ((ClientSavepoint) savepoint).agent_.connection_) {
2:e65b4db:                     throw new SqlException(agent_.logWriter_, new ClientMessageId 
1:b13b17c:                             (SQLState.SAVEPOINT_NOT_CREATED_BY_CONNECTION));
1:d506170:                 }
1:b13b17c:             } catch (ClassCastException e) {
1:b13b17c:                 // savepoint is not an instance of am.Savepoint
1:b13b17c:                 throw new SqlException(
1:b13b17c:                     agent_.logWriter_,
1:69e3d06:                     new ClientMessageId(
1:69e3d06:                         SQLState.SAVEPOINT_NOT_CREATED_BY_CONNECTION));
1:70f7692:             }
1:a53b758: 
1:d506170:             // Construct and flow a savepoint release statement to server.
1:69e3d06:             ClientStatement stmt = null;
1:d506170:             try {
1:69e3d06:                 stmt = (ClientStatement) createStatementX(
1:69e3d06:                         ResultSet.TYPE_FORWARD_ONLY,
1:69e3d06:                         ResultSet.CONCUR_READ_ONLY,
1:2aa6cce:                         holdability());
1:d506170:                 String savepointName;
1:70f7692:                 try {
1:69e3d06:                     savepointName =
1:69e3d06:                         ((ClientSavepoint) savepoint).getSavepointName();
1:d506170:                 } catch (SQLException e) {
1:d506170:                     // generate the name for an un-named savepoint.
1:d506170:                     savepointName = dncGeneratedSavepointNamePrefix__ +
1:69e3d06:                             ((ClientSavepoint) savepoint).getSavepointId();
1:d506170:                 }
1:1146825:                 stmt.executeX(
1:1146825:                         "RELEASE SAVEPOINT " +
1:1146825:                         Utils.quoteSqlIdentifier(savepointName));
1:d506170:             } finally {
1:d506170:                 if (stmt != null) {
1:70f7692:                     try {
1:d506170:                         stmt.closeX();
1:d506170:                     } catch (SqlException doNothing) {
1:d506170:                     }
1:d506170:                 }
1:d506170:                 xaState_ = saveXaState;
1:70f7692:             }
1:70f7692:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:69e3d06:     synchronized public Statement createStatement(int resultSetType,
1:70f7692:                                                            int resultSetConcurrency,
1:d506170:                                                            int resultSetHoldability) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             if (agent_.loggingEnabled()) {
1:d506170:                 agent_.logWriter_.traceEntry(this, "createStatement", resultSetType, resultSetConcurrency, resultSetHoldability);
1:d506170:             }
1:69e3d06: 
1:69e3d06:             ClientStatement s = createStatementX(
1:69e3d06:                 resultSetType,
1:69e3d06:                 resultSetConcurrency,
1:69e3d06:                 resultSetHoldability);
1:69e3d06: 
1:d506170:             if (agent_.loggingEnabled()) {
1:d506170:                 agent_.logWriter_.traceExit(this, "createStatement", s);
1:d506170:             }
1:d506170:             return s;
1:d506170:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:69e3d06:     private ClientStatement createStatementX(int resultSetType,
1:70f7692:                                        int resultSetConcurrency,
4:70f7692:                                        int resultSetHoldability) throws SqlException {
25:70f7692:         checkForClosedConnection();
1:70f7692:         resultSetType = downgradeResultSetType(resultSetType);
1:4388f15:         // In an XA global transaction do not allow the
1:4388f15:         // holdability to be set to hold cursors across
1:4388f15:         // commits, as the engine does not support it.
1:1128268:         // Downgrade the holdability to CLOSE_CURSORS_AT_COMMIT
1:1128268:         // and attach a warning. This is specified in
1:1128268:         // JDBC 4.0 (proposed final draft) section 16.1.3.1
1:1128268:         // Similar code is not needed for PreparedStatement
1:1128268:         // as the holdability gets pushed all the way to the
1:1128268:         // engine and handled there.
1:4388f15:         if (this.isXAConnection_ && this.xaState_ == XA_T1_ASSOCIATED)
1:4388f15:         {
1:1e8a20f:             if (resultSetHoldability == ResultSet.HOLD_CURSORS_OVER_COMMIT) {
1:1e8a20f:                 resultSetHoldability = ResultSet.CLOSE_CURSORS_AT_COMMIT;
1:1128268:                 accumulateWarning(new SqlWarning(agent_.logWriter_, 
1:e65b4db:                         new ClientMessageId(SQLState.HOLDABLE_RESULT_SET_NOT_AVAILABLE)));
1:1128268:             }
1:4388f15:         }
1:69e3d06: 
1:69e3d06:         ClientStatement s = newStatement_(
1:69e3d06:             resultSetType,
1:69e3d06:             resultSetConcurrency,
1:69e3d06:             resultSetHoldability);
1:69e3d06: 
1:70f7692:         s.cursorAttributesToSendOnPrepare_ = s.cacheCursorAttributesToSendOnPrepare();
1:dd7d579:         openStatements_.put(s, null);
4:70f7692:         return s;
1:70f7692:     }
1:70f7692: 
1:70f7692:     // not sure if holding on to cursorAttributesToSendOnPrepare and restoring it is the
1:70f7692:     // right thing to do here... because if property on the dataSource changes, we may have
1:70f7692:     // to send different attributes, i.e. SENSITIVE DYNAMIC, instead of SENSITIVE STATIC.
1:69e3d06:     protected void resetStatement(ClientStatement s) throws SqlException {
1:70f7692:         String cursorAttributesToSendOnPrepare = s.cursorAttributesToSendOnPrepare_;
1:70f7692:         resetStatement_(s, s.resultSetType_, s.resultSetConcurrency_, s.resultSetHoldability_);
1:70f7692:         s.cursorAttributesToSendOnPrepare_ = cursorAttributesToSendOnPrepare;
1:70f7692:     }
1:70f7692: 
1:69e3d06:     synchronized public PreparedStatement prepareStatement(String sql,
1:70f7692:                                                                     int resultSetType,
1:70f7692:                                                                     int resultSetConcurrency,
1:d506170:                                                                     int resultSetHoldability) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             if (agent_.loggingEnabled()) {
1:d506170:                 agent_.logWriter_.traceEntry(this, "prepareStatement", sql, resultSetType, resultSetConcurrency, resultSetHoldability);
1:d506170:             }
1:69e3d06:             ClientPreparedStatement ps = prepareStatementX(sql,
1:d506170:                     resultSetType,
1:d506170:                     resultSetConcurrency,
1:d506170:                     resultSetHoldability,
1:69e3d06:                     Statement.NO_GENERATED_KEYS,
1:b52081a:                     null, null);
1:d506170:             if (agent_.loggingEnabled()) {
1:d506170:                 agent_.logWriter_.traceExit(this, "prepareStatement", ps);
1:d506170:             }
1:d506170:             return ps;
1:70f7692:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:70f7692:     // used by DBMD
1:69e3d06:     ClientPreparedStatement prepareStatementX(String sql,
1:70f7692:                                         int resultSetType,
1:70f7692:                                         int resultSetConcurrency,
1:70f7692:                                         int resultSetHoldability,
1:70f7692:                                         int autoGeneratedKeys,
1:b52081a:                                         String[] columnNames,
1:b52081a:                                         int[] columnIndexes) throws SqlException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         resultSetType = downgradeResultSetType(resultSetType);
1:69e3d06: 
1:69e3d06:         ClientPreparedStatement ps = newPreparedStatement_(
1:69e3d06:             sql,
1:69e3d06:             resultSetType,
1:69e3d06:             resultSetConcurrency,
1:69e3d06:             resultSetHoldability,
1:69e3d06:             autoGeneratedKeys,
1:69e3d06:             columnNames,
1:69e3d06:             columnIndexes);
1:69e3d06: 
1:70f7692:         ps.cursorAttributesToSendOnPrepare_ = ps.cacheCursorAttributesToSendOnPrepare();
1:70f7692:         ps.prepare();
1:dd7d579:         openStatements_.put(ps,null);
1:70f7692:         return ps;
1:70f7692:     }
1:70f7692: 
1:70f7692:     // not sure if holding on to cursorAttributesToSendOnPrepare and restoring it is the
1:70f7692:     // right thing to do here... because if property on the dataSource changes, we may have
1:70f7692:     // to send different attributes, i.e. SENSITIVE DYNAMIC, instead of SENSITIVE STATIC.
1:69e3d06:     protected void resetPrepareStatement(ClientPreparedStatement ps)
1:69e3d06:             throws SqlException {
1:70f7692:         String cursorAttributesToSendOnPrepare = ps.cursorAttributesToSendOnPrepare_;
1:b52081a:         resetPreparedStatement_(ps, ps.sql_, ps.resultSetType_, ps.resultSetConcurrency_, ps.resultSetHoldability_, ps.autoGeneratedKeys_, ps.generatedKeysColumnNames_,
1:b52081a:                 ps.generatedKeysColumnIndexes_);
1:70f7692:         ps.cursorAttributesToSendOnPrepare_ = cursorAttributesToSendOnPrepare;
1:70f7692:         ps.prepare();
1:70f7692:     }
1:33776ff: 
1:69e3d06:     synchronized public CallableStatement prepareCall(String sql,
1:70f7692:                                                                int resultSetType,
1:70f7692:                                                                int resultSetConcurrency,
1:d506170:                                                                int resultSetHoldability) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             if (agent_.loggingEnabled()) {
1:d506170:                 agent_.logWriter_.traceEntry(this, "prepareCall", sql, resultSetType, resultSetConcurrency, resultSetHoldability);
1:d506170:             }
1:69e3d06: 
1:69e3d06:             ClientCallableStatement cs = prepareCallX(
1:69e3d06:                 sql,
1:69e3d06:                 resultSetType,
1:69e3d06:                 resultSetConcurrency,
1:69e3d06:                 resultSetHoldability);
1:69e3d06: 
1:d506170:             if (agent_.loggingEnabled()) {
1:d506170:                 agent_.logWriter_.traceExit(this, "prepareCall", cs);
1:70f7692:             }
1:d506170:             return cs;
1:70f7692:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:33776ff: 
1:69e3d06:     ClientCallableStatement prepareCallX(String sql,
1:70f7692:                                            int resultSetType,
1:70f7692:                                            int resultSetConcurrency,
1:70f7692:                                            int resultSetHoldability) throws SqlException {
1:d506170:         checkForClosedConnection();
1:70f7692:         resultSetType = downgradeResultSetType(resultSetType);
1:69e3d06:         ClientCallableStatement cs = newCallableStatement_(
1:69e3d06:             sql,
1:69e3d06:             resultSetType,
1:69e3d06:             resultSetConcurrency,
1:69e3d06:             resultSetHoldability);
1:70f7692:         cs.cursorAttributesToSendOnPrepare_ = cs.cacheCursorAttributesToSendOnPrepare();
1:70f7692:         cs.prepare();
1:dd7d579:         openStatements_.put(cs,null);
1:70f7692:         return cs;
1:70f7692:     }
1:33776ff: 
1:69e3d06:     protected void resetPrepareCall(ClientCallableStatement cs)
1:69e3d06:             throws SqlException {
1:70f7692:         String cursorAttributesToSendOnPrepare = cs.cursorAttributesToSendOnPrepare_;
1:70f7692:         resetCallableStatement_(cs, cs.sql_, cs.resultSetType_, cs.resultSetConcurrency_, cs.resultSetHoldability_);
1:70f7692:         cs.cursorAttributesToSendOnPrepare_ = cursorAttributesToSendOnPrepare;
1:70f7692:         cs.prepare();
1:70f7692:     }
1:33776ff: 
1:69e3d06:     public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys)
1:69e3d06:             throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             if (agent_.loggingEnabled()) {
1:d506170:                 agent_.logWriter_.traceEntry(this, "prepareStatement", sql, autoGeneratedKeys);
1:d506170:             }
1:69e3d06:             ClientPreparedStatement ps = prepareStatementX(sql,
1:69e3d06:                     ResultSet.TYPE_FORWARD_ONLY,
1:69e3d06:                     ResultSet.CONCUR_READ_ONLY,
1:fdfc981:                     holdability(),
1:d506170:                     autoGeneratedKeys,
1:b52081a:                     null, null);
1:d506170:             if (agent_.loggingEnabled()) {
1:d506170:                 agent_.logWriter_.traceExit(this, "prepareStatement", ps);
1:70f7692:             }
1:d506170:             return ps;
1:70f7692:         }
1:d506170:         catch ( SqlException se )
2:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:33776ff: 
1:69e3d06:     public PreparedStatement prepareStatement(String sql, int columnIndexes[])
1:69e3d06:             throws SQLException {
2:d506170:         try
1:d506170:         {
1:d506170:             if (agent_.loggingEnabled()) {
1:d506170:                 agent_.logWriter_.traceEntry(this, "prepareStatement", sql, columnIndexes);
1:d506170:             }
1:b52081a:             int genKeys = (columnIndexes == null ||
1:b52081a:                     columnIndexes.length == 0
1:69e3d06:                     ? ClientStatement.NO_GENERATED_KEYS:
1:69e3d06:                 ClientStatement.RETURN_GENERATED_KEYS);
1:69e3d06:             ClientPreparedStatement ps = prepareStatementX(sql,
1:69e3d06:                     ResultSet.TYPE_FORWARD_ONLY,
1:69e3d06:                     ResultSet.CONCUR_READ_ONLY,
1:b52081a:                     holdability(),
1:b52081a:                     genKeys,
1:b52081a:                     null, columnIndexes);
1:b52081a:             if (agent_.loggingEnabled()) {
1:b52081a:                 agent_.logWriter_.traceExit(this, "prepareStatement", ps);
1:b52081a:             } 
1:b52081a:             return ps;
1:d506170:         }
2:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:d506170:         }
1:70f7692:     }
1:33776ff: 
1:69e3d06:     public PreparedStatement prepareStatement(String sql, String columnNames[])
1:69e3d06:             throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             if (agent_.loggingEnabled()) {
1:d506170:                 agent_.logWriter_.traceEntry(this, "prepareStatement", sql, columnNames);
1:d506170:             }
1:aadfc18:             int genKeys = (columnNames == null ||
1:aadfc18:                     columnNames.length == 0
1:69e3d06:                     ? ClientStatement.NO_GENERATED_KEYS:
1:69e3d06:                 ClientStatement.RETURN_GENERATED_KEYS);
1:69e3d06:             ClientPreparedStatement ps = prepareStatementX(sql,
1:69e3d06:                     ResultSet.TYPE_FORWARD_ONLY,
1:69e3d06:                     ResultSet.CONCUR_READ_ONLY,
1:fdfc981:                     holdability(),
1:aadfc18:                     genKeys,
1:b52081a:                     columnNames, null);
1:d506170:             if (agent_.loggingEnabled()) {
1:d506170:                 agent_.logWriter_.traceExit(this, "prepareStatement", ps);
1:70f7692:             }
1:d506170:             return ps;
1:70f7692:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:33776ff: 
1:33776ff: 
1:70f7692:     // ---------------------------------------------------------------------------
1:33776ff: 
1:70f7692:     protected abstract boolean allowCloseInUOW_();
1:33776ff: 
1:70f7692:     protected abstract boolean doCloseStatementsOnClose_();
1:33776ff: 
1:0326967:     public abstract SectionManager newSectionManager(Agent agent);
1:70f7692:     //--------------------Abstract material factory methods-----------------
1:70f7692: 
1:37ce91b:     protected abstract Agent newAgent_(LogWriter logWriter, int loginTimeout, String serverName, int portNumber, int clientSSLMode) throws SqlException;
1:70f7692: 
1:33776ff: 
1:69e3d06:     protected abstract ClientDatabaseMetaData newDatabaseMetaData_();
1:33776ff: 
1:69e3d06:     protected abstract ClientStatement newStatement_(int type,
1:70f7692:                                                int concurrency,
1:70f7692:                                                int holdability) throws SqlException;
1:70f7692: 
1:69e3d06:     protected abstract void resetStatement_(ClientStatement statement,
1:70f7692:                                             int type,
1:70f7692:                                             int concurrency,
1:70f7692:                                             int holdability) throws SqlException;
1:33776ff: 
1:33776ff: 
1:69e3d06:     protected abstract ClientPreparedStatement
1:69e3d06:         newPositionedUpdatePreparedStatement_
1:69e3d06:             (String sql,
1:69e3d06:              Section section) throws SqlException;
1:33776ff: 
1:69e3d06:     protected abstract ClientPreparedStatement newPreparedStatement_(String sql,
1:70f7692:                                                                int type,
1:70f7692:                                                                int concurrency,
1:70f7692:                                                                int holdability,
1:70f7692:                                                                int autoGeneratedKeys,
1:b52081a:                                                                String[] columnNames, int[] columnIndexes) throws SqlException;
1:33776ff: 
1:69e3d06:     protected abstract void resetPreparedStatement_(ClientPreparedStatement ps,
1:70f7692:                                                     String sql,
1:70f7692:                                                     int resultSetType,
1:70f7692:                                                     int resultSetConcurrency,
1:70f7692:                                                     int resultSetHoldability,
1:70f7692:                                                     int autoGeneratedKeys,
1:b52081a:                                                     String[] columnNames,
1:b52081a:                                                     int[] columnIndexes) throws SqlException;
1:33776ff: 
1:69e3d06:     protected abstract ClientCallableStatement newCallableStatement_(String sql,
1:70f7692:                                                                int type,
1:70f7692:                                                                int concurrency,
1:70f7692:                                                                int holdability) throws SqlException;
1:33776ff: 
1:69e3d06:     protected abstract void resetCallableStatement_(ClientCallableStatement cs,
1:70f7692:                                                     String sql,
1:70f7692:                                                     int resultSetType,
1:70f7692:                                                     int resultSetConcurrency,
1:70f7692:                                                     int resultSetHoldability) throws SqlException;
1:70f7692: 
1:70f7692:     // ----------------------- abstract box car and callback methods ---------------------
1:70f7692:     // All callbacks must be client-side only operations.
1:33776ff: 
1:33776ff: 
1:68968aa:     public final void completeConnect() throws SqlException {
1:70f7692:         open_ = true;
1:70f7692:         databaseMetaData_ = newDatabaseMetaData_();
1:33776ff: 
1:70f7692:         agent_.sectionManager_ =
1:0326967:                 newSectionManager(
1:0326967:                         agent_);
1:70f7692:         if (agent_.loggingEnabled()) {
1:70f7692:             agent_.logWriter_.traceConnectExit(this);
1:70f7692:         }
1:70f7692:     }
1:33776ff: 
1:70f7692:     public abstract void writeCommitSubstitute_() throws SqlException;
1:70f7692: 
1:70f7692:     public abstract void readCommitSubstitute_() throws SqlException;
1:70f7692: 
1:70f7692:     public abstract void writeLocalXAStart_() throws SqlException;
1:70f7692: 
1:70f7692:     public abstract void readLocalXAStart_() throws SqlException;
1:70f7692: 
1:70f7692:     public abstract void writeLocalXACommit_() throws SqlException;
1:dadd05a:     
1:dadd05a:     protected abstract void writeXACommit_() throws SqlException;
1:70f7692: 
1:dadd05a:     public abstract void readLocalXACommit_() throws SqlException;   
1:dadd05a:     
1:dadd05a:     protected abstract void readXACommit_() throws SqlException;   
1:70f7692: 
1:70f7692:     public abstract void writeLocalCommit_() throws SqlException;
1:70f7692: 
1:70f7692:     public abstract void readLocalCommit_() throws SqlException;
1:dadd05a:     
1:69e3d06:     protected abstract void writeXATransactionStart(ClientStatement statement)
1:b13b17c:                                                 throws SqlException;
1:70f7692: 
1:70f7692:     public void completeLocalCommit() {
1:4772c7e:         Set<UnitOfWorkListener> keySet = CommitAndRollbackListeners_.keySet();
1:4772c7e:         for (Iterator<UnitOfWorkListener> i = keySet.iterator(); i.hasNext();) {
1:4772c7e:             i.next().completeLocalCommit(i);
1:70f7692:         }
1:70f7692:         inUnitOfWork_ = false;
1:8055511:         transactionID_++;
1:70f7692:     }
1:70f7692: 
1:70f7692:     public abstract void writeLocalRollback_() throws SqlException;
1:70f7692: 
1:70f7692:     public abstract void readLocalRollback_() throws SqlException;
1:70f7692: 
1:70f7692:     // A callback for certain non-fatal exceptions that occur when parsing error replies.
1:70f7692:     // This is a client-side only operation.
1:70f7692:     // This method will only throw an exception on bug check.
1:70f7692:     public void completeLocalRollback() {
1:4772c7e:         Set<UnitOfWorkListener> keySet = CommitAndRollbackListeners_.keySet();
1:4772c7e:         for (Iterator<UnitOfWorkListener> i = keySet.iterator(); i.hasNext();) {
1:4772c7e:             i.next().completeLocalRollback(i);
1:64b55c2:         }
1:70f7692:         inUnitOfWork_ = false;
1:8055511:         transactionID_++;
1:70f7692:     }
1:33776ff:     
1:2aa6cce:     /**
1:f55d30a:      * 
1:ad94e28:      * Rollback the specific UnitOfWorkListener. 
1:ad94e28:      * @param uwl The UnitOfWorkLitener to be rolled back
1:ad94e28:      *
1:ad94e28:      */
1:0326967:     private void completeSpecificRollback(UnitOfWorkListener uwl) {
1:4772c7e:         Set<UnitOfWorkListener> keySet = CommitAndRollbackListeners_.keySet();
1:4772c7e:         for (Iterator<UnitOfWorkListener> i = keySet.iterator(); i.hasNext();) {
1:4772c7e:             UnitOfWorkListener listener = i.next();
1:ad94e28:             if(listener == uwl) {
1:64b55c2:                 listener.completeLocalRollback(i);
1:ad94e28:                 break;
1:ad94e28:             }
1:ad94e28:         }
1:ad94e28:         inUnitOfWork_ = false;
1:ad94e28:     }
1:33776ff: 
1:33776ff: 
1:70f7692:     public abstract void writeLocalXARollback_() throws SqlException;
1:dadd05a:     
1:dadd05a:     protected abstract void writeXARollback_() throws SqlException;
1:33776ff: 
1:70f7692:     public abstract void readLocalXARollback_() throws SqlException;
1:dadd05a:     
1:dadd05a:     protected abstract void readXARollback_() throws SqlException;
1:70f7692: 
1:69e3d06:     public void writeTransactionStart(ClientStatement statement)
1:69e3d06:             throws SqlException {
1:dadd05a:         if (isXAConnection_) {
1:dadd05a:             writeXATransactionStart (statement);
1:dadd05a:         }
1:70f7692:     }
1:33776ff: 
1:70f7692:     public void readTransactionStart() throws SqlException {
1:70f7692:         completeTransactionStart();
1:70f7692:     }
1:70f7692: 
1:70f7692:     void completeTransactionStart() {
1:70f7692:         inUnitOfWork_ = true;
1:70f7692:     }
1:33776ff: 
1:70f7692:     // Occurs autonomously
1:70f7692:     public void completeAbnormalUnitOfWork() {
1:70f7692:         completeLocalRollback();
1:70f7692:     }
1:ad94e28:     
1:ad94e28:     /**
1:ad94e28:      *
1:ad94e28:      * Rollback the UnitOfWorkListener specifically.
1:ad94e28:      * @param uwl The UnitOfWorkListener to be rolled back.
1:ad94e28:      *
1:ad94e28:      */
1:ad94e28:     public void completeAbnormalUnitOfWork(UnitOfWorkListener uwl) {
1:ad94e28:         completeSpecificRollback(uwl);
1:ad94e28:     }
1:70f7692: 
1:70f7692:     // Called by Connection.close(), NetConnection.errorRollbackDisconnect().
1:70f7692:     // The Agent's client-side resources associated with database connection are reclaimed (eg. socket).
1:70f7692:     // And this connection and all associated statements and result sets are marked closed.
1:70f7692:     // This is a client-side only operation.
1:70f7692:     // This method will only throw an exception if the agent cannot be closed.
1:70f7692:     public void completeChainBreakingDisconnect() {
1:70f7692:         open_ = false;
1:70f7692:         completeLocalRollback();
2:70f7692:         markStatementsClosed();
1:70f7692:     }
1:70f7692: 
1:70f7692:     public void completeSqlca(Sqlca sqlca) {
1:70f7692:         if (sqlca == null) {
1:70f7692:         } else if (sqlca.getSqlCode() > 0) {
1:70f7692:             accumulateWarning(new SqlWarning(agent_.logWriter_, sqlca));
1:70f7692:         } else if (sqlca.getSqlCode() < 0) {
1:70f7692:             agent_.accumulateReadException(new SqlException(agent_.logWriter_, sqlca));
1:70f7692:         }
1:70f7692:     }
1:33776ff: 
1:c6c4d4d:     public void completePiggyBackIsolation(int pbIsolation) {
1:c6c4d4d:         if (SanityManager.DEBUG) {
1:c6c4d4d:             SanityManager.ASSERT(supportsSessionDataCaching());
1:c6c4d4d:         }
1:c6c4d4d:         isolation_ = pbIsolation;
1:c6c4d4d:     }
1:c6c4d4d: 
1:2f3d052:     /**
1:2f3d052:      * Sets the default isolation level of the connection upon connection
1:2f3d052:      * initialization.
1:2f3d052:      * <p>
1:2f3d052:      * Note that depending on the server version, the default isolation value
1:2f3d052:      * may not be piggy-backed on the initialization flow. In that case, the
1:2f3d052:      * default is assumed / hardcoded to be READ_COMMITTED.
1:2f3d052:      *
1:2f3d052:      * @param pbIsolation isolation level as specified by
1:2f3d052:      *      {@code java.sql.Connection}
1:2f3d052:      */
1:2f3d052:     public void completeInitialPiggyBackIsolation(int pbIsolation) {
1:2f3d052:         if (SanityManager.DEBUG) {
1:2f3d052:             SanityManager.ASSERT(
1:2f3d052:                     pbIsolation == 
1:69e3d06:                         Connection.TRANSACTION_READ_UNCOMMITTED ||
1:2f3d052:                     pbIsolation ==
1:69e3d06:                         Connection.TRANSACTION_READ_COMMITTED ||
1:2f3d052:                     pbIsolation ==
1:69e3d06:                         Connection.TRANSACTION_REPEATABLE_READ ||
1:2f3d052:                     pbIsolation ==
1:69e3d06:                         Connection.TRANSACTION_SERIALIZABLE,
1:2f3d052:                     "Invalid isolation level value: " + pbIsolation);
1:2f3d052:         }
1:2f3d052:         defaultIsolation = isolation_ = pbIsolation;
1:2f3d052:     }
1:2f3d052: 
1:c6c4d4d:     public void completePiggyBackSchema(String pbSchema) {
1:c6c4d4d:         if (SanityManager.DEBUG) {
1:c6c4d4d:             SanityManager.ASSERT(supportsSessionDataCaching());
1:c6c4d4d:         }
1:c6c4d4d:         currentSchemaName_ = pbSchema;
1:c6c4d4d:     }
1:c6c4d4d: 
1:2f3d052:     /**
1:2f3d052:      * Sets the current schema upon connection initialization.
1:2f3d052:      *
1:2f3d052:      * @param pbSchema the schema name
1:2f3d052:      */
1:2f3d052:     public void completeInitialPiggyBackSchema(String pbSchema) {
1:2f3d052:         currentSchemaName_ = pbSchema;
1:2f3d052:     }
1:2f3d052: 
1:70f7692:     // can this only be called by the PooledConnection
1:70f7692:     // can this be called on a closed connection
1:70f7692:     // can this be called in a unit of work
1:70f7692:     // can this be called from within a stored procedure
3:d506170:     //
1:bbc2fd8:     synchronized public void reset(LogWriter logWriter)
1:17d490d:             throws SqlException {
1:70f7692:         if (logWriter != null) {
1:080c38f:             logWriter.traceConnectResetEntry(this, logWriter, user_, 
1:ea141d7:                                              dataSource_);
1:70f7692:         }
1:70f7692:         try {
1:bbc2fd8:             reset_(logWriter);
2:70f7692:         } catch (SqlException sqle) {
1:5d2e2bd:             DisconnectException de = new DisconnectException(agent_, 
1:e65b4db:                 new ClientMessageId(SQLState.CONNECTION_FAILED_ON_RESET));
2:70f7692:             de.setNextException(sqle);
2:70f7692:             throw de;
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:70f7692:     synchronized public void lightReset() throws SqlException {
1:70f7692:         if (!open_ && !availableForReuse_) {
1:2f3d052:             return;
1:70f7692:         }
1:70f7692:         open_ = true;
1:70f7692:         availableForReuse_ = false;
1:70f7692:     }
1:70f7692: 
1:bbc2fd8:     abstract protected void reset_(LogWriter logWriter) throws SqlException;
1:70f7692: 
1:fdfc981:     /**
1:76af6ed:      * <br>NOTE:</br>The following comments are valid for the changes done as
1:76af6ed:      * part of implementing statement caching only (see DERBY-3313 and linked
1:76af6ed:      * issues).
1:76af6ed:      * <p>
1:76af6ed:      * We don't reset the isolation level to unknown unconditionally, as this
1:76af6ed:      * forces us to go to the server all the time. Since the value should now
1:76af6ed:      * be valid (DERBY-3192), we check if it has been changed from the default.
1:76af6ed:      *
1:bbc2fd8:      * @param closeStatementsOnClose is used to differentiate between
1:76af6ed:      *      cases where statement pooling is enabled or not. If {@code true}, it
1:76af6ed:      *      means statement pooling is disabled and the statements are fully
1:76af6ed:      *      reset, which includes a re-prepare. If {@code false}, statement
1:76af6ed:      *      pooling is enabled, and a more lightweight reset procedure is used.
1:76af6ed:      */
1:bbc2fd8:     protected void completeReset(boolean isDeferredReset,
1:2f3d052:                                  boolean closeStatementsOnClose,
1:2f3d052:                                  NetXAResource xares)
1:17d490d:             throws SqlException {
1:70f7692:         open_ = true;
1:70f7692: 
1:70f7692:         completeLocalRollback(); // this will close the cursors if the physical connection hadn't been closed for reuse properly
1:70f7692: 
1:70f7692:         // Reopen physical statement resources associated with previous uses of this physical connection.
1:70f7692:         // Notice that these physical statements may not belong to this logical connection.
1:70f7692:         // Iterate through the physical statements and re-enable them for reuse.
1:70f7692: 
1:bbc2fd8:         if (closeStatementsOnClose) {
1:69e3d06:             for (ClientStatement stmt : openStatements_.keySet()) {
1:4772c7e:                 stmt.reset(closeStatementsOnClose);
1:2f3d052:             }
1:76af6ed:         }
1:2f3d052:         // Must reset transaction isolation level if it has been changed,
1:2f3d052:         // except when we are doing XA and resuming/joining a global tx.
1:2f3d052:         if (xares != null && xares.keepCurrentIsolationLevel()) {
1:2f3d052:             // Reset the flag, do nothing else.
1:2f3d052:             xares.setKeepCurrentIsolationLevel(false);
1:2f3d052:         } else if (isolation_ != defaultIsolation) {
1:2f3d052:             // This might not fare well with connection pools, if it has
1:2f3d052:             // been configured to deliver connections with a different
1:2f3d052:             // isolation level, i.e. it has to set the isolation level again
1:2f3d052:             // when it returns connection to client.
1:2f3d052:             // TODO: Investigate optimization options.
1:2f3d052:             setTransactionIsolationX(defaultIsolation);
1:76af6ed:         }
1:70f7692: 
1:70f7692:         if (!isDeferredReset && agent_.loggingEnabled()) {
1:70f7692:             agent_.logWriter_.traceConnectResetExit(this);
1:70f7692:         }
1:70f7692:     }
1:6de69bd:     
1:6de69bd:     /**
1:6de69bd:      * Reference to object with prepared statements for calling the locator
1:6de69bd:      * procedures. Makes it possible to reuse prepared statements within 
1:6de69bd:      * the connection.
1:6de69bd:      */
1:6de69bd:     private CallableLocatorProcedures lobProcs;
1:6de69bd:     
1:6de69bd:     /**
1:6de69bd:      * Get handle to the object that contains prepared statements for calling
1:6de69bd:      * locator procedures for this connection.  The object will be created on 
1:6de69bd:      * the first invocation.
1:6de69bd:      *
1:6de69bd:      * An example of how to call a stored procedure via this method:
1:6de69bd:      * <pre> <code>
1:6de69bd:      *    connection.locatorProcedureCall().blobReleaseLocator(locator);
1:6de69bd:      * </code> </pre>
1:6de69bd:      *
1:6de69bd:      * @return object with prepared statements for calling locator procedures
1:6de69bd:      */
1:6de69bd:     CallableLocatorProcedures locatorProcedureCall() 
1:6de69bd:     {
1:6de69bd:         if (lobProcs == null) {
1:6de69bd:             lobProcs = new CallableLocatorProcedures(this);
1:6de69bd:         }
1:6de69bd:         return lobProcs;
1:6de69bd:     }    
1:70f7692: 
1:70f7692: 
1:70f7692:     //-------------------------------helper methods-------------------------------
1:70f7692: 
1:70f7692:     protected void checkForClosedConnection() throws SqlException {
1:70f7692:         if (!open_) {
1:70f7692:             agent_.checkForDeferredExceptions();
1:a53b758:             throw new SqlException(agent_.logWriter_, 
1:6eb29f6:                     new ClientMessageId (SQLState.NO_CURRENT_CONNECTION));
1:70f7692:         } else {
1:70f7692:             agent_.checkForDeferredExceptions();
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:70f7692:     public boolean isXAConnection() {
1:70f7692:         return isXAConnection_;
1:70f7692:     }
1:70f7692: 
1:70f7692:     public int getXAState() {
1:70f7692:         return xaState_;
1:70f7692:     }
1:70f7692: 
1:70f7692:     public void setXAState(int state) {
1:70f7692:         xaState_ = state;
1:70f7692:     }
1:33776ff: 
1:0326967:     private void accumulateWarning(SqlWarning e) {
1:70f7692:         if (warnings_ == null) {
1:70f7692:             warnings_ = e;
1:70f7692:         } else {
1:70f7692:             warnings_.setNextException(e);
1:70f7692:         }
1:70f7692:     }
1:33776ff: 
1:0326967:     void accumulate440WarningForMessageProcFailure(SqlWarning e) {
1:70f7692:         if (!accumulated440ForMessageProcFailure_) {
1:70f7692:             accumulateWarning(e);
1:70f7692:             accumulated440ForMessageProcFailure_ = true;
1:70f7692:         }
1:70f7692:     }
1:33776ff: 
1:0326967:     void accumulate444WarningForMessageProcFailure(SqlWarning e) {
1:70f7692:         if (!accumulated444ForMessageProcFailure_) {
1:70f7692:             accumulateWarning(e);
1:70f7692:             accumulated444ForMessageProcFailure_ = true;
1:70f7692:         }
1:70f7692:     }
1:33776ff: 
1:70f7692:     // get the server version
1:70f7692:     public int getServerVersion() {
1:70f7692:         return databaseMetaData_.productLevel_.versionLevel_;
1:70f7692:     }
1:33776ff: 
1:fdfc981:     /**
1:fdfc981:      * Return the holdabilty for the Connection. Matches the
1:fdfc981:      * embedded driver in the restriction that while in a
1:fdfc981:      * global (XA) transaction the holdability is CLOSE_CURSORS_AT_COMMIT.
1:fdfc981:      * Otherwise return the holdability set by the user.
1:fdfc981:      */
1:fdfc981:     final int holdability()
1:fdfc981:     {
1:fdfc981:         if (this.isXAConnection_ && this.xaState_ == XA_T1_ASSOCIATED)
1:1e8a20f:             return ResultSet.CLOSE_CURSORS_AT_COMMIT;
1:fdfc981:         return holdability;
1:b16fdc6:     }
1:b16fdc6:     
1:b16fdc6:     
1:b16fdc6:     /**
1:b16fdc6:      * Constructs an object that implements the <code>Clob</code> interface. 
1:b16fdc6:      * The object returned initially contains no data.
1:b16fdc6:      *
1:59a2580:      * @return An object that implements the <code>Clob</code> interface
1:b16fdc6:      * @throws java.sql.SQLException if an object that implements the
1:b16fdc6:      * <code>Clob</code> interface can not be constructed.
1:b16fdc6:      */
1:b16fdc6:     
1:69e3d06:     public Clob createClob() throws SQLException {
1:b16fdc6:         if (agent_.loggingEnabled()) {
1:b16fdc6:             agent_.logWriter_.traceEntry(this, "createClob");
1:b16fdc6:         }
1:b16fdc6:         
1:b16fdc6:         try {
1:b16fdc6:             checkForClosedConnection();
1:b16fdc6:         } catch (SqlException se) {
1:b16fdc6:             throw se.getSQLException();
1:b16fdc6:         }
1:b16fdc6:         
1:beecb26:         //Stores a locator value obtained by calling the
1:beecb26:         //stored procedure CLOBCREATELOCATOR.
1:beecb26:         int locator = INVALID_LOCATOR;
1:beecb26: 
1:69e3d06:         //Stores the Clob instance that is returned.
1:69e3d06:         ClientClob clob = null;
1:69e3d06: 
1:beecb26:         //Call the CLOBCREATELOCATOR stored procedure
1:beecb26:         //that will return a locator value.
1:beecb26:         try {
1:beecb26:             locator = locatorProcedureCall().clobCreateLocator();
1:beecb26:         }
1:beecb26:         catch(SqlException sqle) {
1:beecb26:             throw sqle.getSQLException();
1:beecb26:         }
1:beecb26: 
1:beecb26:         //If the locator value is -1 it means that we do not
1:beecb26:         //have locator support on the server.
1:beecb26: 
1:beecb26:         //The code here has been disabled because the Lob implementations
1:beecb26:         //have still not been completely converted to use locators. Once
1:beecb26:         //the Lob implementations are completed then this code can be enabled.
1:d3e6a71:         if (locator != INVALID_LOCATOR) {
1:beecb26:             //A valid locator value has been obtained.
1:69e3d06:             clob = new ClientClob(this.agent_, locator);
1:beecb26:         }
1:beecb26:         else {
1:beecb26:             //A valid locator value could not be obtained.
1:69e3d06:             clob = new ClientClob
1:69e3d06:                     (this.agent_, "");
1:beecb26:         }
1:b13b17c: 
1:b16fdc6:         if (agent_.loggingEnabled()) {
1:b16fdc6:             agent_.logWriter_.traceExit(this, "createClob", clob);
1:b16fdc6:         }
1:b13b17c:         
1:b16fdc6:         return clob;
1:b16fdc6:     }
1:beecb26: 
1:b16fdc6:     /**
1:b16fdc6:      * Constructs an object that implements the <code>Blob</code> interface. 
1:b16fdc6:      * The object returned initially contains no data.
1:b16fdc6:      *
1:b16fdc6:      * @return An object that implements the <code>Blob</code> interface
1:b16fdc6:      * @throws SQLException if an object that implements the
1:b16fdc6:      * </code>Blob</code> interface can not be constructed.
1:b16fdc6:      *
1:b16fdc6:      */
1:b16fdc6:     
1:69e3d06:     public Blob createBlob() throws SQLException {
1:b16fdc6:         if (agent_.loggingEnabled()) {
1:b16fdc6:             agent_.logWriter_.traceEntry(this, "createBlob");
1:b16fdc6:         }
1:b16fdc6:         
1:b16fdc6:         try {
1:b16fdc6:             checkForClosedConnection();
1:b16fdc6:         } catch (SqlException se) {
1:b16fdc6:             throw se.getSQLException();
1:b16fdc6:         }
1:b16fdc6:         
1:b16fdc6:         //Stores a locator value obtained by calling the
1:b16fdc6:         //stored procedure BLOBCREATELOCATOR.
1:b16fdc6:         int locator = INVALID_LOCATOR;
1:b16fdc6:         
1:69e3d06:         //Stores the Blob instance that is returned.
1:69e3d06:         ClientBlob blob = null;
1:69e3d06: 
1:b16fdc6:         //Call the BLOBCREATELOCATOR stored procedure
1:b16fdc6:         //that will return a locator value.
1:b16fdc6:         try {
1:b16fdc6:             locator = locatorProcedureCall().blobCreateLocator();
1:b16fdc6:         }
1:b16fdc6:         catch(SqlException sqle) {
1:b16fdc6:             throw sqle.getSQLException();
1:b16fdc6:         }
1:b13b17c:         
1:b16fdc6:         //If the locator value is -1 it means that we do not
1:b16fdc6:         //have locator support on the server.
1:b16fdc6:         
1:5b7bb25:         if (locator != INVALID_LOCATOR) {
1:b16fdc6:             //A valid locator value has been obtained.
1:69e3d06:             blob = new ClientBlob(this.agent_, locator);
1:b16fdc6:         } 
1:b16fdc6:         else {
1:b16fdc6:             //A valid locator value could not be obtained.
1:69e3d06:             blob = new ClientBlob
1:69e3d06:                     (new byte[0],this.agent_, 0);
1:b16fdc6:         }
1:b16fdc6:         
1:b16fdc6:         if (agent_.loggingEnabled()) {
1:b16fdc6:             agent_.logWriter_.traceExit(this, "createBlob", blob);
1:b16fdc6:         }
1:b16fdc6:         
1:b16fdc6:         return blob;
1:795f705:     }
1:795f705: 
1:795f705:     /** Return true if the connection is aborting */
1:795f705:     public  boolean isAborting() { return aborting_; }
1:b16fdc6:     
1:795f705:     /** Begin aborting the connection */
1:71e32dc:     protected  void    beginAborting()
1:795f705:     {
1:795f705:         aborting_ = true;
1:795f705:         markClosed( false );
1:795f705:     }
1:795f705:     
1:1837822:     ////////////////////////////////////////////////////////////////////
1:1837822:     //
1:1837822:     // INTRODUCED BY JDBC 4.1 IN JAVA 7
1:1837822:     //
1:1837822:     ////////////////////////////////////////////////////////////////////
1:1837822: 
1:1837822:     /**
1:1837822:      * Get the name of the current schema.
1:1837822:      */
1:1837822:     public String   getSchema() throws SQLException
1:6eb29f6:     {
1:1837822:         return getCurrentSchemaName();
1:1837822:     }
1:1837822:     
1:1837822:     /**
1:1837822:      * Set the default schema for the Connection.
1:1837822:      */
1:1837822:     public void   setSchema(  String schemaName ) throws SQLException
1:6eb29f6:     {
1:1837822:         try {
1:1837822:             checkForClosedConnection();
1:1837822:         } catch (SqlException se) {
1:1837822:             throw se.getSQLException();
1:1837822:         }
1:1837822: 
1:79bf1a8:         // nothing to do if the current schema name is cached and is the same
1:79bf1a8:         // as the new schema name
1:79bf1a8:         if ( ( currentSchemaName_ != null) && (currentSchemaName_.equals( schemaName )) )
1:79bf1a8:         { return; }
1:79bf1a8: 
1:69e3d06:         PreparedStatement   ps = null;
1:1837822: 
1:1837822:         try {
1:1837822:             ps = prepareStatement( "set schema ?" );
1:1837822:             ps.setString( 1, schemaName );
1:1837822:             ps.execute();
1:1837822:         }
1:1837822:         finally
1:1837822:         {
1:1837822:             if ( ps != null ) { ps.close(); }
1:6eb29f6:         }
1:1837822:     }
1:795f705: 
1:9a0cdf1:     public  void    abort( Executor executor )  throws SQLException
1:9a0cdf1:     {
1:9a0cdf1:         // NOP if called on a closed connection.
1:9a0cdf1:         if ( !open_ ) { return; }
1:9a0cdf1:         // Null executor not allowed.
1:9a0cdf1:         if ( executor == null )
1:9a0cdf1:         {
1:9a0cdf1:             ClientMessageId cmi = new ClientMessageId( SQLState.UU_INVALID_PARAMETER  );
1:9a0cdf1:             SqlException se = new SqlException( agent_.logWriter_, cmi, "executor", "null" );
1:9a0cdf1: 
1:9a0cdf1:             throw se.getSQLException();
1:9a0cdf1:         }
1:9a0cdf1: 
1:9a0cdf1:         //
1:9a0cdf1:         // Must have privilege to invoke this method.
1:9a0cdf1:         //
1:9a0cdf1:         // The derby jars should be granted this permission. We deliberately
1:9a0cdf1:         // do not wrap this check in an AccessController.doPrivileged() block.
1:9a0cdf1:         // If we did so, that would absolve outer code blocks of the need to
1:9a0cdf1:         // have this permission granted to them too. It is critical that the
1:9a0cdf1:         // outer code blocks enjoy this privilege. That is what allows
1:9a0cdf1:         // connection pools to prevent ordinary code from calling abort()
1:9a0cdf1:         // and restrict its usage to privileged tools.
1:9a0cdf1:         //
1:9a0cdf1:         SecurityManager securityManager = System.getSecurityManager();
1:9a0cdf1:         if ( securityManager != null )
1:9a0cdf1:         { securityManager.checkPermission( new SQLPermission( "callAbort" ) ); }
1:9a0cdf1: 
1:9a0cdf1:         // Mark the Connection as closed. Set the "aborting" flag to allow internal
1:9a0cdf1:         // processing in close() to proceed.
1:9a0cdf1:         beginAborting();
1:9a0cdf1: 
1:9a0cdf1:         //
1:9a0cdf1:         // Now pass the Executor a Runnable which does the real work.
1:9a0cdf1:         //
1:9a0cdf1:         executor.execute
1:9a0cdf1:             (
1:9a0cdf1:              new Runnable()
1:9a0cdf1:              {
1:9a0cdf1:                  public void run()
1:9a0cdf1:                  {
1:9a0cdf1:                      try {
1:9a0cdf1:                          rollback();
1:9a0cdf1:                          close();
1:9a0cdf1:                      } catch (SQLException se) { se.printStackTrace( agent_.getLogWriter() ); }
1:9a0cdf1:                  }
1:9a0cdf1:              }
1:9a0cdf1:              );
1:9a0cdf1:     }
1:9a0cdf1: 
1:9a0cdf1:     public int getNetworkTimeout() throws SQLException
1:9a0cdf1:     {
1:9a0cdf1:         throw SQLExceptionFactory.notImplemented("getNetworkTimeout");
1:9a0cdf1:     }
1:9a0cdf1: 
1:9a0cdf1:     public void setNetworkTimeout( Executor executor, int milliseconds ) throws SQLException
1:9a0cdf1:     {
1:9a0cdf1:         throw SQLExceptionFactory.notImplemented("setNetworkTimeout");
1:9a0cdf1:     }
1:9a0cdf1: 
1:1837822: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:7863d83
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.jdbc.BasicClientDataSource40;
1: import org.apache.derby.jdbc.ClientDataSourceInterface;
/////////////////////////////////////////////////////////////////////////
1:     public BasicClientDataSource40 dataSource_;
1:     private int clientSSLMode_ = BasicClientDataSource40.SSL_OFF;
/////////////////////////////////////////////////////////////////////////
1:             BasicClientDataSource40 dataSource)
/////////////////////////////////////////////////////////////////////////
1:             BasicClientDataSource40 dataSource)
/////////////////////////////////////////////////////////////////////////
1:             BasicClientDataSource40 dataSource)
/////////////////////////////////////////////////////////////////////////
1:             BasicClientDataSource40.getSSLModeFromString(dataSource.getSsl());
/////////////////////////////////////////////////////////////////////////
1:             BasicClientDataSource40 dataSource)
/////////////////////////////////////////////////////////////////////////
1:         user_ = ClientDataSourceInterface.propertyDefault_user;
/////////////////////////////////////////////////////////////////////////
1:             BasicClientDataSource40.getSSLModeFromString(dataSource.getSsl());
/////////////////////////////////////////////////////////////////////////
1:         user_ = BasicClientDataSource40.getUser(properties);
1:             BasicClientDataSource40.getRetrieveMessageText(properties);
1:         clientSSLMode_ = BasicClientDataSource40.getClientSSLMode(properties);
commit:b565f41
/////////////////////////////////////////////////////////////////////////
1:     synchronized void closeForReuse(boolean statementPooling)
commit:0326967
/////////////////////////////////////////////////////////////////////////
1:     boolean retrieveMessageText_;
1:     private boolean jdbcReadOnly_;
/////////////////////////////////////////////////////////////////////////
1:     private int loginTimeout_;
0:     private int clientSSLMode_ = ClientBaseDataSourceRoot.SSL_OFF;
/////////////////////////////////////////////////////////////////////////
1:     private void initConnection(
/////////////////////////////////////////////////////////////////////////
1:     synchronized ClientPreparedStatement preparePositionedUpdateStatement (
/////////////////////////////////////////////////////////////////////////
1:     synchronized String nativeSQLX(String sql) throws SqlException {
/////////////////////////////////////////////////////////////////////////
1: 
1:     private void flowCommit() throws SqlException {
/////////////////////////////////////////////////////////////////////////
1:     void writeCommit() throws SqlException {
/////////////////////////////////////////////////////////////////////////
1:     void readCommit() throws SqlException {
/////////////////////////////////////////////////////////////////////////
1:     private void writeRollback() throws SqlException {
/////////////////////////////////////////////////////////////////////////
1:     private void readRollback() throws SqlException {
/////////////////////////////////////////////////////////////////////////
1:     private void markClosed(boolean statementPooling)
/////////////////////////////////////////////////////////////////////////
1:     private void clearWarningsX() throws SqlException {
/////////////////////////////////////////////////////////////////////////
1:     synchronized ClientCallableStatement prepareMessageProc(String sql)
/////////////////////////////////////////////////////////////////////////
1:     private int dncGeneratedSavepointId_;
1:     private static final String
1:             dncGeneratedSavepointNamePrefix__ = "DNC_GENENERATED_NAME_";
/////////////////////////////////////////////////////////////////////////
1:     public abstract SectionManager newSectionManager(Agent agent);
/////////////////////////////////////////////////////////////////////////
1:                 newSectionManager(
1:                         agent_);
/////////////////////////////////////////////////////////////////////////
1:     private void completeSpecificRollback(UnitOfWorkListener uwl) {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private void accumulateWarning(SqlWarning e) {
/////////////////////////////////////////////////////////////////////////
1:     void accumulate440WarningForMessageProcFailure(SqlWarning e) {
1:     void accumulate444WarningForMessageProcFailure(SqlWarning e) {
commit:69e3d06
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Blob;
1: import java.sql.CallableStatement;
1: import java.sql.Clob;
1: import java.sql.Connection;
1: import java.sql.DatabaseMetaData;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.SQLWarning;
1: import java.sql.Savepoint;
1: import java.sql.Statement;
/////////////////////////////////////////////////////////////////////////
1: public abstract class ClientConnection
1:     implements Connection, ConnectionCallbackInterface
1:     public ClientDatabaseMetaData databaseMetaData_;
/////////////////////////////////////////////////////////////////////////
1:     final WeakHashMap<ClientStatement, Void> openStatements_ =
1:             new WeakHashMap<ClientStatement, Void>();
/////////////////////////////////////////////////////////////////////////
1:     final private HashMap<String, ClientPreparedStatement>
1:             new HashMap<String, ClientPreparedStatement>();
1:     private ClientPreparedStatement getTransactionIsolationPrepStmt = null;
/////////////////////////////////////////////////////////////////////////
1:     protected ClientConnection(
/////////////////////////////////////////////////////////////////////////
1:     protected ClientConnection(
0:             ClientBaseDataSourceRoot dataSource)
1:             throws SqlException {
/////////////////////////////////////////////////////////////////////////
0:     protected void initConnection(
0:             ClientBaseDataSourceRoot dataSource)
1:             throws SqlException {
/////////////////////////////////////////////////////////////////////////
1:     protected ClientConnection(
0:             ClientBaseDataSourceRoot dataSource)
1:             throws SqlException {
/////////////////////////////////////////////////////////////////////////
1:     protected ClientConnection(LogWriter logWriter,
/////////////////////////////////////////////////////////////////////////
1:     synchronized public Statement createStatement() throws SQLException {
1: 
1:             ClientStatement s = createStatementX(
1:                 ResultSet.TYPE_FORWARD_ONLY,
1:                 ResultSet.CONCUR_READ_ONLY, holdability());
1: 
/////////////////////////////////////////////////////////////////////////
1:     synchronized public PreparedStatement prepareStatement(String sql)
1:             throws SQLException {
1:             ClientPreparedStatement ps = prepareStatementX(sql,
1:                     ResultSet.TYPE_FORWARD_ONLY,
1:                     ResultSet.CONCUR_READ_ONLY,
1:                     Statement.NO_GENERATED_KEYS,
/////////////////////////////////////////////////////////////////////////
0:     synchronized
0:         public ClientPreparedStatement preparePositionedUpdateStatement (
1:             String sql,
1:             Section querySection) throws SqlException {
1: 
1:         ClientPreparedStatement preparedStatement =
1:             newPositionedUpdatePreparedStatement_(sql, querySection);
1: 
/////////////////////////////////////////////////////////////////////////
1:     synchronized public CallableStatement prepareCall(String sql)
1:             throws SQLException {
1: 
1:             ClientCallableStatement cs = prepareCallX(
1:                 sql,
1:                 ResultSet.TYPE_FORWARD_ONLY,
1:                 ResultSet.CONCUR_READ_ONLY,
1:                 holdability());
1: 
/////////////////////////////////////////////////////////////////////////
1:     synchronized ClientPreparedStatement prepareDynamicCatalogQuery(String sql)
1:             throws SqlException {
1:         ClientPreparedStatement ps = newPreparedStatement_(
1:             sql,
1:             ResultSet.TYPE_FORWARD_ONLY,
1:             ResultSet.CONCUR_READ_ONLY,
1:             holdability(),
1:             Statement.NO_GENERATED_KEYS,
1:             null,
1:             null);
/////////////////////////////////////////////////////////////////////////
1:     protected abstract boolean allowLocalCommitRollback_() throws SqlException;
/////////////////////////////////////////////////////////////////////////
1:         for (ClientPreparedStatement ps :
1:                  isolationLevelPreparedStmts.values()) {
/////////////////////////////////////////////////////////////////////////
1:         Set<ClientStatement> keySet = openStatements_.keySet();
1:         for (Iterator<ClientStatement> i = keySet.iterator(); i.hasNext();) {
1:             ClientStatement stmt = i.next();
1:         Set<ClientStatement> keySet = openStatements_.keySet();
1:         for (Iterator<ClientStatement> i = keySet.iterator(); i.hasNext();) {
1:         Set<ClientStatement> keySet = openStatements_.keySet();
1:         for (Iterator<ClientStatement> i = keySet.iterator(); i.hasNext();) {
/////////////////////////////////////////////////////////////////////////
1:             // Per jdbc spec (see Connection.close() javadoc).
/////////////////////////////////////////////////////////////////////////
1:         case ClientConnection.TRANSACTION_REPEATABLE_READ:
1:         case ClientConnection.TRANSACTION_READ_COMMITTED:
1:         case ClientConnection.TRANSACTION_SERIALIZABLE:
1:         case ClientConnection.TRANSACTION_READ_UNCOMMITTED:
1:         case Connection.TRANSACTION_NONE:
/////////////////////////////////////////////////////////////////////////
1:         ClientPreparedStatement ps =
1:             (ClientPreparedStatement)isolationLevelPreparedStmts.
1:             get(levelString);
1: 
1:                     ResultSet.TYPE_FORWARD_ONLY,
1:                     ResultSet.CONCUR_READ_ONLY,
1:                     Statement.NO_GENERATED_KEYS,
/////////////////////////////////////////////////////////////////////////
1:             // Per jdbc spec (see Connection.close() javadoc).
/////////////////////////////////////////////////////////////////////////
1:         ResultSet rs = null;
/////////////////////////////////////////////////////////////////////////
1:                                 ResultSet.TYPE_FORWARD_ONLY,
1:                                 ResultSet.CONCUR_READ_ONLY,
1:                                 Statement.NO_GENERATED_KEYS,
/////////////////////////////////////////////////////////////////////////
1:             Statement s = createStatement();
1:             ResultSet rs = s.executeQuery("VALUES CURRENT SCHEMA");
/////////////////////////////////////////////////////////////////////////
1:             return ClientConnection.TRANSACTION_REPEATABLE_READ;
1:             return ClientConnection.TRANSACTION_SERIALIZABLE;
1:             return ClientConnection.TRANSACTION_READ_COMMITTED;
1:             return ClientConnection.TRANSACTION_READ_UNCOMMITTED;
1:             return ClientConnection.TRANSACTION_NONE;
1:     public SQLWarning getWarnings() throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:     public DatabaseMetaData getMetaData() throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:     synchronized public Statement createStatement(int resultSetType,
1: 
1:             ClientStatement s = createStatementX(
1:                 resultSetType,
1:                 resultSetConcurrency,
1:                 holdability());
1: 
/////////////////////////////////////////////////////////////////////////
1:     synchronized public PreparedStatement prepareStatement(String sql,
/////////////////////////////////////////////////////////////////////////
1:             ClientPreparedStatement ps = prepareStatementX(sql,
1:                     ClientStatement.NO_GENERATED_KEYS,
/////////////////////////////////////////////////////////////////////////
1:     synchronized public CallableStatement prepareCall(String sql,
/////////////////////////////////////////////////////////////////////////
1: 
1:             ClientCallableStatement cs = prepareCallX(
1:                 sql,
1:                 resultSetType,
1:                 resultSetConcurrency,
1:                 holdability());
1: 
/////////////////////////////////////////////////////////////////////////
0:     synchronized public ClientCallableStatement prepareMessageProc(String sql)
1:             throws SqlException {
1:         ClientCallableStatement cs = prepareCallX(
1:             sql,
1:             ResultSet.TYPE_FORWARD_ONLY,
1:             ResultSet.CONCUR_READ_ONLY,
1:             holdability());
1:         if (resultSetType == ResultSet.TYPE_SCROLL_SENSITIVE) {
1:             return ResultSet.TYPE_SCROLL_INSENSITIVE;
/////////////////////////////////////////////////////////////////////////
1:     synchronized public Savepoint setSavepoint() throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:             Object s = setSavepointX(
1:                 new ClientSavepoint(agent_, dncGeneratedSavepointId_));
1: 
1:             return (ClientSavepoint) s;
/////////////////////////////////////////////////////////////////////////
1:     synchronized public Savepoint setSavepoint(String name)
1:             throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:             Object s = setSavepointX(new ClientSavepoint(agent_, name));
1:             return (ClientSavepoint) s;
/////////////////////////////////////////////////////////////////////////
1:     private ClientSavepoint setSavepointX(ClientSavepoint savepoint)
1:             throws SQLException {
1:         ClientStatement stmt = null;
1:             stmt = (ClientStatement) createStatementX(
1:                 ResultSet.TYPE_FORWARD_ONLY,
1:                 ResultSet.CONCUR_READ_ONLY,
1:                 holdability());
1: 
/////////////////////////////////////////////////////////////////////////
1:     synchronized public void rollback(Savepoint savepoint) throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:                 if (this != ((ClientSavepoint) savepoint).agent_.connection_) {
1:             } catch (ClassCastException e) {
1:                  // savepoint is not an instance of am.Savepoint
1:             ClientStatement stmt = null;
1:                 stmt = createStatementX(ResultSet.TYPE_FORWARD_ONLY,
1:                         ResultSet.CONCUR_READ_ONLY,
1:                     savepointName =
1:                         ((ClientSavepoint)savepoint).getSavepointName();
1:                             ((ClientSavepoint) savepoint).getSavepointId();
/////////////////////////////////////////////////////////////////////////
1:     synchronized public void releaseSavepoint(Savepoint savepoint)
1:             throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:                 if (this != ((ClientSavepoint) savepoint).agent_.connection_) {
/////////////////////////////////////////////////////////////////////////
1:                     new ClientMessageId(
1:                         SQLState.SAVEPOINT_NOT_CREATED_BY_CONNECTION));
1:             ClientStatement stmt = null;
1:                 stmt = (ClientStatement) createStatementX(
1:                         ResultSet.TYPE_FORWARD_ONLY,
1:                         ResultSet.CONCUR_READ_ONLY,
1:                     savepointName =
1:                         ((ClientSavepoint) savepoint).getSavepointName();
1:                             ((ClientSavepoint) savepoint).getSavepointId();
/////////////////////////////////////////////////////////////////////////
1:     synchronized public Statement createStatement(int resultSetType,
/////////////////////////////////////////////////////////////////////////
1: 
1:             ClientStatement s = createStatementX(
1:                 resultSetType,
1:                 resultSetConcurrency,
1:                 resultSetHoldability);
1: 
/////////////////////////////////////////////////////////////////////////
1:     private ClientStatement createStatementX(int resultSetType,
/////////////////////////////////////////////////////////////////////////
1: 
1:         ClientStatement s = newStatement_(
1:             resultSetType,
1:             resultSetConcurrency,
1:             resultSetHoldability);
1: 
/////////////////////////////////////////////////////////////////////////
1:     protected void resetStatement(ClientStatement s) throws SqlException {
1:     synchronized public PreparedStatement prepareStatement(String sql,
/////////////////////////////////////////////////////////////////////////
1:             ClientPreparedStatement ps = prepareStatementX(sql,
1:                     Statement.NO_GENERATED_KEYS,
/////////////////////////////////////////////////////////////////////////
1:     ClientPreparedStatement prepareStatementX(String sql,
/////////////////////////////////////////////////////////////////////////
1: 
1:         ClientPreparedStatement ps = newPreparedStatement_(
1:             sql,
1:             resultSetType,
1:             resultSetConcurrency,
1:             resultSetHoldability,
1:             autoGeneratedKeys,
1:             columnNames,
1:             columnIndexes);
1: 
/////////////////////////////////////////////////////////////////////////
1:     protected void resetPrepareStatement(ClientPreparedStatement ps)
1:             throws SqlException {
/////////////////////////////////////////////////////////////////////////
1:     synchronized public CallableStatement prepareCall(String sql,
/////////////////////////////////////////////////////////////////////////
1: 
1:             ClientCallableStatement cs = prepareCallX(
1:                 sql,
1:                 resultSetType,
1:                 resultSetConcurrency,
1:                 resultSetHoldability);
1: 
/////////////////////////////////////////////////////////////////////////
1:     ClientCallableStatement prepareCallX(String sql,
1:         ClientCallableStatement cs = newCallableStatement_(
1:             sql,
1:             resultSetType,
1:             resultSetConcurrency,
1:             resultSetHoldability);
1:     protected void resetPrepareCall(ClientCallableStatement cs)
1:             throws SqlException {
1:     public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys)
1:             throws SQLException {
1:             ClientPreparedStatement ps = prepareStatementX(sql,
1:                     ResultSet.TYPE_FORWARD_ONLY,
1:                     ResultSet.CONCUR_READ_ONLY,
/////////////////////////////////////////////////////////////////////////
1:     public PreparedStatement prepareStatement(String sql, int columnIndexes[])
1:             throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:                     ? ClientStatement.NO_GENERATED_KEYS:
1:                 ClientStatement.RETURN_GENERATED_KEYS);
1:             ClientPreparedStatement ps = prepareStatementX(sql,
1:                     ResultSet.TYPE_FORWARD_ONLY,
1:                     ResultSet.CONCUR_READ_ONLY,
/////////////////////////////////////////////////////////////////////////
1:     public PreparedStatement prepareStatement(String sql, String columnNames[])
1:             throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:                     ? ClientStatement.NO_GENERATED_KEYS:
1:                 ClientStatement.RETURN_GENERATED_KEYS);
1:             ClientPreparedStatement ps = prepareStatementX(sql,
1:                     ResultSet.TYPE_FORWARD_ONLY,
1:                     ResultSet.CONCUR_READ_ONLY,
/////////////////////////////////////////////////////////////////////////
1:     protected abstract ClientDatabaseMetaData newDatabaseMetaData_();
1:     protected abstract ClientStatement newStatement_(int type,
1:     protected abstract void resetStatement_(ClientStatement statement,
1:     protected abstract ClientPreparedStatement
1:         newPositionedUpdatePreparedStatement_
1:             (String sql,
1:              Section section) throws SqlException;
1:     protected abstract ClientPreparedStatement newPreparedStatement_(String sql,
1:     protected abstract void resetPreparedStatement_(ClientPreparedStatement ps,
/////////////////////////////////////////////////////////////////////////
1:     protected abstract ClientCallableStatement newCallableStatement_(String sql,
1:     protected abstract void resetCallableStatement_(ClientCallableStatement cs,
/////////////////////////////////////////////////////////////////////////
1:     protected abstract void writeXATransactionStart(ClientStatement statement)
/////////////////////////////////////////////////////////////////////////
1:     public void writeTransactionStart(ClientStatement statement)
1:             throws SqlException {
/////////////////////////////////////////////////////////////////////////
1:                         Connection.TRANSACTION_READ_UNCOMMITTED ||
1:                         Connection.TRANSACTION_READ_COMMITTED ||
1:                         Connection.TRANSACTION_REPEATABLE_READ ||
1:                         Connection.TRANSACTION_SERIALIZABLE,
/////////////////////////////////////////////////////////////////////////
1:             for (ClientStatement stmt : openStatements_.keySet()) {
/////////////////////////////////////////////////////////////////////////
1:     public Clob createClob() throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:         //Stores the Clob instance that is returned.
1:         ClientClob clob = null;
1: 
/////////////////////////////////////////////////////////////////////////
1:             clob = new ClientClob(this.agent_, locator);
1:             clob = new ClientClob
1:                     (this.agent_, "");
/////////////////////////////////////////////////////////////////////////
1:     public Blob createBlob() throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:         //Stores the Blob instance that is returned.
1:         ClientBlob blob = null;
1: 
/////////////////////////////////////////////////////////////////////////
1:             blob = new ClientBlob(this.agent_, locator);
1:             blob = new ClientBlob
1:                     (new byte[0],this.agent_, 0);
/////////////////////////////////////////////////////////////////////////
1:         PreparedStatement   ps = null;
commit:b13b17c
/////////////////////////////////////////////////////////////////////////
1: import java.util.Properties;
/////////////////////////////////////////////////////////////////////////
0:     public ClientBaseDataSourceRoot dataSource_;
/////////////////////////////////////////////////////////////////////////
1:             LogWriter logWriter,
0:             ClientBaseDataSourceRoot dataSource)
/////////////////////////////////////////////////////////////////////////
1:             LogWriter logWriter,
0:             ClientBaseDataSourceRoot dataSource) throws SqlException {
/////////////////////////////////////////////////////////////////////////
1:             LogWriter logWriter,
0:             ClientBaseDataSourceRoot dataSource) throws SqlException {
/////////////////////////////////////////////////////////////////////////
1:                          Properties properties) throws SqlException {
/////////////////////////////////////////////////////////////////////////
1:     protected void finalize() throws Throwable {
/////////////////////////////////////////////////////////////////////////
0:     protected abstract boolean allowLocalCommitRollback_()
1:             throws SqlException;
/////////////////////////////////////////////////////////////////////////
1:     public boolean willAutoCommitGenerateFlow() throws SqlException {
/////////////////////////////////////////////////////////////////////////
0:             } catch (java.lang.ClassCastException e) {
1:                 // savepoint is not an instance of am.Savepoint
/////////////////////////////////////////////////////////////////////////
1:             } catch (ClassCastException e) {
0:                 // savepoint is not an instance of am.Savepoint
1:                 throw new SqlException(
1:                     agent_.logWriter_,
0:                     new ClientMessageId
1:                     (SQLState.SAVEPOINT_NOT_CREATED_BY_CONNECTION));
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
0:         //Stores the Clob instance that is returned.
0:         Clob clob;
1: 
0:             clob = new Clob(this.agent_, locator);
0:             clob = new Clob(this.agent_, "");
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         //Stores the Blob instance that is returned.
0:         Blob blob;
1: 
0:             blob = new Blob(this.agent_, locator);
0:             blob = new Blob(new byte[0],this.agent_, 0);
commit:ee33904
/////////////////////////////////////////////////////////////////////////
0:     private void initConnection(
1:             LogWriter logWriter,
0:             ClientBaseDataSourceRoot dataSource) throws SqlException {
commit:68968aa
/////////////////////////////////////////////////////////////////////////
1:     private void closeX() throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:     public final void completeConnect() throws SqlException {
commit:8269b78
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.jdbc.ClientBaseDataSourceRoot;
/////////////////////////////////////////////////////////////////////////
0:     public org.apache.derby.jdbc.ClientBaseDataSourceRoot dataSource_;
0:     public int clientSSLMode_ = ClientBaseDataSourceRoot.SSL_OFF;
/////////////////////////////////////////////////////////////////////////
0:     protected Connection(
0:             org.apache.derby.client.am.LogWriter logWriter,
1:             String user,
1:             String password,
0:             org.apache.derby.jdbc.ClientBaseDataSourceRoot dataSource)
1:             throws SqlException {
1: 
0:     protected Connection(
0:             org.apache.derby.client.am.LogWriter logWriter,
1:             String user,
1:             String password,
1:             boolean isXAConn,
0:             org.apache.derby.jdbc.ClientBaseDataSourceRoot dataSource)
1:             throws SqlException {
1: 
0:     protected void initConnection(
0:             org.apache.derby.client.am.LogWriter logWriter,
0:             org.apache.derby.jdbc.ClientBaseDataSourceRoot dataSource)
1:             throws SqlException {
1: 
/////////////////////////////////////////////////////////////////////////
0:             ClientBaseDataSourceRoot.getSSLModeFromString(dataSource.getSsl());
/////////////////////////////////////////////////////////////////////////
0:     protected Connection(
0:             org.apache.derby.client.am.LogWriter logWriter,
1:             boolean isXAConn,
0:             org.apache.derby.jdbc.ClientBaseDataSourceRoot dataSource)
1:             throws SqlException {
1: 
1: 
0:         user_ = ClientBaseDataSourceRoot.propertyDefault_user;
/////////////////////////////////////////////////////////////////////////
0:             ClientBaseDataSourceRoot.getSSLModeFromString(dataSource.getSsl());
/////////////////////////////////////////////////////////////////////////
0:         user_ = ClientBaseDataSourceRoot.getUser(properties);
1:         retrieveMessageText_ =
0:             ClientBaseDataSourceRoot.getRetrieveMessageText(properties);
0:         clientSSLMode_ = ClientBaseDataSourceRoot.getClientSSLMode(properties);
author:Dyre Tjeldvoll
-------------------------------------------------------------------------------
commit:74fb1b0
/////////////////////////////////////////////////////////////////////////
1:                     !getTransactionIsolationPrepStmt.openOnClient_) {
commit:c6c4d4d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Constant indicating that isolation_ has not been updated through
1:      * piggy-backing, (or that the previously stored value was invalidated,
1:      * e.g. by an XA state change).
1:      */
1:     private static final int TRANSACTION_UNKNOWN = -1;
1:     /**
1:      * Cached copy of the isolation level. Kept in sync with server through
1:      * piggy-backing.
1:      */
1:     private int isolation_ = TRANSACTION_UNKNOWN;
1: 
1:     /**
1:      * Cached copy of the schema name. Updated through piggy-backing and used
1:      * to implement statement caching.
1:      */
1:     private String currentSchemaName_ = null;
1: 
/////////////////////////////////////////////////////////////////////////
0:             isolation_ = TRANSACTION_UNKNOWN;
0:             currentSchemaName_ = null;
/////////////////////////////////////////////////////////////////////////
0:         isolation_ = TRANSACTION_UNKNOWN;
0:         currentSchemaName_ = null;
/////////////////////////////////////////////////////////////////////////
1:             if (SanityManager.DEBUG && supportsSessionDataCaching()) {
1:                 SanityManager.ASSERT(isolation_ == level);
1:             }
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Finds out if the underlaying database connection supports session data
1:      * caching.
1:      * @return true if sessionData is supported
1:      */
1:     protected abstract boolean supportsSessionDataCaching();
1: 
/////////////////////////////////////////////////////////////////////////
1:             if (isolation_ != TRANSACTION_UNKNOWN) {
1:                 if (SanityManager.DEBUG) {
1:                     SanityManager.ASSERT(supportsSessionDataCaching(),
1:                             "Cannot return cached isolation when caching is " +
1:                             "not supported!");
1:                 }
1:                 return isolation_;
1:             }
1: 
/////////////////////////////////////////////////////////////////////////
1:             // DERBY-3192 - Cache session data in the client driver allows
1:             // the re-introduction of isolation level caching. Changes to the
1:             // isolation level triggered from SQL are now handled by
1:             // piggybacking the modified isolation level on messages going
1:             // back to the client.
1:             // The XA-problem is handled by letting XA state changes set the
1:             // cached isolation level to TRANSACTION_UNKNOWN which will trigger
1:             // a refresh from the server.
/////////////////////////////////////////////////////////////////////////
1: 
1:             int isolation = translateIsolation(isolationStr);
1:             if (isolation_ == TRANSACTION_UNKNOWN &&
1:                     supportsSessionDataCaching()) {
1:                 // isolation_ will be TRANSACTION_UNKNOWN if the connection has
1:                 // been reset on
1:                 // the client. The server will not observe a
1:                 // change in isolation level so no information is
1:                 // piggy-backed. Update the cached value here, rather than
1:                 // waiting for the isolation to change on the server.
1:                 isolation_ = isolation;
1:             }
1:             if (SanityManager.DEBUG) {
1:                 SanityManager.ASSERT(!supportsSessionDataCaching() ||
1:                         (isolation_ == isolation),
1:                         "Cached isolation_ not updated, (isolation_="+
1:                         isolation_+")!=(isolation="+isolation+")");
1:                 SanityManager.ASSERT(supportsSessionDataCaching() ||
1:                         (isolation_ == TRANSACTION_UNKNOWN),
1:                         "isolation_ modified when caching is not supported");
1:             }
1: 
1:             return isolation;
/////////////////////////////////////////////////////////////////////////
1:      * Returns the current schema (the schema that would be used for
1:      * compilation. This is not part of the java.sql.Connection interface, and
1:      * is only intended for use with statement caching.
1:      * @return the name of the current schema
1:      * @throws java.sql.SQLException
1:      */
1:     public String getCurrentSchemaName() throws SQLException {
1:         try {
1:             checkForClosedConnection();
1:         } catch (SqlException se) {
1:             throw se.getSQLException();
1:         }
1:         if (currentSchemaName_ == null) {
1:             if (agent_.loggingEnabled()) {
1:                agent_.logWriter_.traceEntry(this,
1:                   "getCurrentSchemaName() executes query");
1:             }
0:             java.sql.Statement s = createStatement();
0:             java.sql.ResultSet rs = s.executeQuery("VALUES CURRENT SCHEMA");
1:             rs.next();
1:             String schema = rs.getString(1);
1:             rs.close();
1:             s.close();
1:             return schema;
1:         }
1:         if (SanityManager.DEBUG) {
1:             SanityManager.ASSERT(supportsSessionDataCaching(),
1:                     "A cached schema name ("+currentSchemaName_+
1:                     ") is not expected when session data caching is not" +
1:                     "supported");
1:         }
1:         return currentSchemaName_;
1:     }
1: 
1:     /**
/////////////////////////////////////////////////////////////////////////
1:     public void completePiggyBackIsolation(int pbIsolation) {
1:         if (SanityManager.DEBUG) {
1:             SanityManager.ASSERT(supportsSessionDataCaching());
1:         }
1:         isolation_ = pbIsolation;
1:     }
1: 
1:     public void completePiggyBackSchema(String pbSchema) {
1:         if (SanityManager.DEBUG) {
1:             SanityManager.ASSERT(supportsSessionDataCaching());
1:         }
1:         currentSchemaName_ = pbSchema;
1:     }
1: 
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:9a0cdf1
/////////////////////////////////////////////////////////////////////////
1: import java.sql.SQLPermission;
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.Executor;
/////////////////////////////////////////////////////////////////////////
1:     public  void    abort( Executor executor )  throws SQLException
1:     {
1:         // NOP if called on a closed connection.
1:         if ( !open_ ) { return; }
1:         // Null executor not allowed.
1:         if ( executor == null )
1:         {
1:             ClientMessageId cmi = new ClientMessageId( SQLState.UU_INVALID_PARAMETER  );
1:             SqlException se = new SqlException( agent_.logWriter_, cmi, "executor", "null" );
1: 
1:             throw se.getSQLException();
1:         }
1: 
1:         //
1:         // Must have privilege to invoke this method.
1:         //
1:         // The derby jars should be granted this permission. We deliberately
1:         // do not wrap this check in an AccessController.doPrivileged() block.
1:         // If we did so, that would absolve outer code blocks of the need to
1:         // have this permission granted to them too. It is critical that the
1:         // outer code blocks enjoy this privilege. That is what allows
1:         // connection pools to prevent ordinary code from calling abort()
1:         // and restrict its usage to privileged tools.
1:         //
1:         SecurityManager securityManager = System.getSecurityManager();
1:         if ( securityManager != null )
1:         { securityManager.checkPermission( new SQLPermission( "callAbort" ) ); }
1: 
1:         // Mark the Connection as closed. Set the "aborting" flag to allow internal
1:         // processing in close() to proceed.
1:         beginAborting();
1: 
1:         //
1:         // Now pass the Executor a Runnable which does the real work.
1:         //
1:         executor.execute
1:             (
1:              new Runnable()
1:              {
1:                  public void run()
1:                  {
1:                      try {
1:                          rollback();
1:                          close();
1:                      } catch (SQLException se) { se.printStackTrace( agent_.getLogWriter() ); }
1:                  }
1:              }
1:              );
1:     }
1: 
1:     public int getNetworkTimeout() throws SQLException
1:     {
1:         throw SQLExceptionFactory.notImplemented("getNetworkTimeout");
1:     }
1: 
1:     public void setNetworkTimeout( Executor executor, int milliseconds ) throws SQLException
1:     {
1:         throw SQLExceptionFactory.notImplemented("setNetworkTimeout");
1:     }
1: 
commit:7f6e8aa
/////////////////////////////////////////////////////////////////////////
1:     *   Return true if the physical connection is still open.
1:     *   Might be logically closed but available for reuse.
/////////////////////////////////////////////////////////////////////////
1:             rs.close();
commit:66527ec
/////////////////////////////////////////////////////////////////////////
1:                 level);
commit:4772c7e
/////////////////////////////////////////////////////////////////////////
1: import java.sql.SQLException;
1: import java.util.Collections;
1: import java.util.Hashtable;
1: import java.util.Iterator;
1: import java.util.Map;
1: import java.util.Set;
1: import java.util.WeakHashMap;
1: import org.apache.derby.client.net.NetXAResource;
/////////////////////////////////////////////////////////////////////////
0:     final WeakHashMap<Statement, Void> openStatements_ =
0:             new WeakHashMap<Statement, Void>();
/////////////////////////////////////////////////////////////////////////
1:     final WeakHashMap<UnitOfWorkListener, Void> CommitAndRollbackListeners_ =
1:             new WeakHashMap<UnitOfWorkListener, Void>();
1: 
/////////////////////////////////////////////////////////////////////////
1:     Hashtable<String, String> clientCursorNameCache_ =
1:             new Hashtable<String, String>();
1: 
/////////////////////////////////////////////////////////////////////////
0:         Set<Statement> keySet = openStatements_.keySet();
0:         for (Iterator<Statement> i = keySet.iterator(); i.hasNext();) {
0:             Statement stmt = i.next();
0:         Set<Statement> keySet = openStatements_.keySet();
0:         for (Iterator<Statement> i = keySet.iterator(); i.hasNext();) {
1:             i.next().writeClose(false); // false means don't permit auto-commits
0:         Set<Statement> keySet = openStatements_.keySet();
0:         for (Iterator<Statement> i = keySet.iterator(); i.hasNext();) {
1:             i.next().readClose(false); // false means don't permit auto-commits
/////////////////////////////////////////////////////////////////////////
1:     public Map<String, Class<?>> getTypeMap() throws SQLException {
1:             Map<String, Class<?>> map = Collections.emptyMap();
/////////////////////////////////////////////////////////////////////////
1:     synchronized public void setTypeMap(Map map) throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:         Set<UnitOfWorkListener> keySet = CommitAndRollbackListeners_.keySet();
1:         for (Iterator<UnitOfWorkListener> i = keySet.iterator(); i.hasNext();) {
1:             i.next().completeLocalCommit(i);
/////////////////////////////////////////////////////////////////////////
1:         Set<UnitOfWorkListener> keySet = CommitAndRollbackListeners_.keySet();
1:         for (Iterator<UnitOfWorkListener> i = keySet.iterator(); i.hasNext();) {
1:             i.next().completeLocalRollback(i);
/////////////////////////////////////////////////////////////////////////
1:         Set<UnitOfWorkListener> keySet = CommitAndRollbackListeners_.keySet();
1:         for (Iterator<UnitOfWorkListener> i = keySet.iterator(); i.hasNext();) {
1:             UnitOfWorkListener listener = i.next();
/////////////////////////////////////////////////////////////////////////
0:             for (Statement stmt : openStatements_.keySet()) {
1:                 stmt.reset(closeStatementsOnClose);
commit:1146825
/////////////////////////////////////////////////////////////////////////
1:             stmt.executeX(
1:                     "SAVEPOINT " + Utils.quoteSqlIdentifier(savepointName) +
1:                     " ON ROLLBACK RETAIN CURSORS");
/////////////////////////////////////////////////////////////////////////
1:                 stmt.executeX(
1:                         "ROLLBACK TO SAVEPOINT " +
1:                         Utils.quoteSqlIdentifier(savepointName));
/////////////////////////////////////////////////////////////////////////
1:                 stmt.executeX(
1:                         "RELEASE SAVEPOINT " +
1:                         Utils.quoteSqlIdentifier(savepointName));
commit:c85d465
/////////////////////////////////////////////////////////////////////////
0: import java.util.Collections;
/////////////////////////////////////////////////////////////////////////
0:             java.util.Map map = Collections.EMPTY_MAP;
commit:d1661b2
/////////////////////////////////////////////////////////////////////////
1:             if (map == null) {
1:                 throw new SqlException(agent_.logWriter_,
1:                         new ClientMessageId (SQLState.INVALID_API_PARAMETER),
1:                         map, "map", "setTypeMap");
1:             }
1: 
1:             if (!(map.isEmpty())) {
1:                 throw new SqlException(agent_.logWriter_, new ClientMessageId(
1:                         SQLState.NOT_IMPLEMENTED), "setTypeMap");
1:             }
commit:902041a
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Check if the transaction is in progress and the connection cannot be
1:      * closed.
1:      *
1:      * @throws SqlException if the connection cannot be closed because the
1:      * transaction is active
1:      */
1:         if (transactionInProgress()) {
1: 
1:     /**
1:      * Check if there are uncommitted operations in the current transaction
1:      * that prevent us from closing the connection.
1:      *
1:      * @return {@code true} if the connection cannot be closed due to
1:      * uncommitted operations in the transaction
1:      */
1:         return inUnitOfWork_ && !allowCloseInUOW_();
commit:c2af295
/////////////////////////////////////////////////////////////////////////
1:      * Note that even though the server supports LOB locators, the database
1:      * that is accessed through the server may not have the necessary stored
1:      * procedures to support LOB locators (e.g., because the database is
1:      * soft upgraded from an earlier version).
commit:66a9818
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:             flowCommit();
/////////////////////////////////////////////////////////////////////////
1:         return transactionID_;
1: 
commit:d3e6a71
/////////////////////////////////////////////////////////////////////////
1:         if (locator != INVALID_LOCATOR) {
commit:59a2580
/////////////////////////////////////////////////////////////////////////
1:      * @return An object that implements the <code>Clob</code> interface
commit:beecb26
/////////////////////////////////////////////////////////////////////////
1:         //Stores a locator value obtained by calling the
1:         //stored procedure CLOBCREATELOCATOR.
1:         int locator = INVALID_LOCATOR;
1: 
0:         //Stores the Clob instance that is returned.
0:         org.apache.derby.client.am.Clob clob = null;
1: 
1:         //Call the CLOBCREATELOCATOR stored procedure
1:         //that will return a locator value.
1:         try {
1:             locator = locatorProcedureCall().clobCreateLocator();
1:         }
1:         catch(SqlException sqle) {
1:             throw sqle.getSQLException();
1:         }
1: 
1:         //If the locator value is -1 it means that we do not
1:         //have locator support on the server.
1: 
1:         //The code here has been disabled because the Lob implementations
1:         //have still not been completely converted to use locators. Once
1:         //the Lob implementations are completed then this code can be enabled.
0:         if (locator != INVALID_LOCATOR && false) {
1:             //A valid locator value has been obtained.
0:             clob = new org.apache.derby.client.am.Clob(this.agent_, locator);
1:         }
1:         else {
1:             //A valid locator value could not be obtained.
0:             clob = new org.apache.derby.client.am.Clob
0:                     (this.agent_, "");
1:         }
1: 
commit:5b7bb25
/////////////////////////////////////////////////////////////////////////
1:         if (locator != INVALID_LOCATOR) {
commit:320777f
/////////////////////////////////////////////////////////////////////////
1:             checkForClosedConnection();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             checkForClosedConnection();
/////////////////////////////////////////////////////////////////////////
0:     public java.sql.SQLWarning getWarnings() throws SQLException {
1:         try {
1:             checkForClosedConnection();
1:         } catch (SqlException se) {
1:             throw se.getSQLException();
1:         }
/////////////////////////////////////////////////////////////////////////
1:             checkForClosedConnection();
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:45a8204
/////////////////////////////////////////////////////////////////////////
0:     private PreparedStatement getTransactionIsolationPrepStmt = null;
/////////////////////////////////////////////////////////////////////////
1:         if (getTransactionIsolationPrepStmt != null) {
1:                 getTransactionIsolationPrepStmt.close();
1:         getTransactionIsolationPrepStmt = null;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             // DERBY-6066(Client should use a prepared statement rather than 
1:             //  regular statement for Connection.getTransactionIsolation)
1:             // Following code(which actually sends the get transaction 
1:             //  isolation call to the server on the wire) will be executed 
1:             //  in at least following 2 cases
1:             // 1)When a newer client is working with the older versions of 
1:             //   servers(ie server that do not have support for isolation 
1:             //   level caching) - Server version 10.3 and earlier do not 
1:             //   support isolation level caching and hence when a newer 
1:             //   client(10.4 and higher) is talking to a 10.3 and earlier 
1:             //   server, the if condition above will be false and the code 
1:             //   will reach here to get the isolation level from the server 
1:             //   by sending "VALUES CURRENT ISOLATION" over the wire. For 
1:             //   server versions 10.4 and above, the if condition above can 
1:             //   be true if the isolation level was already piggybacked to 
1:             //   the client as part of some other client server communication
1:             //   and hence the current isolation level is already available to 
1:             //   the client and there is no need to send 
1:             //   "VALUES CURRENT ISOLATION" over the wire to the server.
1:             // 2)Additionally, as per DERBY-4314 and write up on piggybacking
1:             //    at http://wiki.apache.org/db-derby/Derby3192Writeup, there 
1:             //    might be cases, where even though server has support for 
1:             //    isolation level caching, server has not had a chance to 
1:             //    send the isolation level piggybacked to the client as part  
1:             //    of some other communication between client and server and 
1:             //    hence the if condition above will be false and client will
1:             //    actually need to send "VALUES CURRENT ISOLATION" to the 
1:             //    server to get the current isolation level.
1:             // 
/////////////////////////////////////////////////////////////////////////
1:             if (getTransactionIsolationPrepStmt == null  || 
0:                     !(getTransactionIsolationPrepStmt.openOnClient_ &&
0:                             getTransactionIsolationPrepStmt.openOnServer_)) {
1:             	getTransactionIsolationPrepStmt =
1:                         prepareStatementX(
1:                                 "VALUES CURRENT ISOLATION",
0:                                 java.sql.ResultSet.TYPE_FORWARD_ONLY,
1:                                 holdability(),
0:                                 java.sql.Statement.NO_GENERATED_KEYS,
1:                                 null, null);
1:             rs = getTransactionIsolationPrepStmt.executeQuery();
commit:c7f0048
/////////////////////////////////////////////////////////////////////////
1: import java.util.HashMap;
/////////////////////////////////////////////////////////////////////////
0:     final private HashMap<String, PreparedStatement> 
1:         isolationLevelPreparedStmts = 
0:             new HashMap<String, PreparedStatement>();
/////////////////////////////////////////////////////////////////////////
0:         for (PreparedStatement ps : isolationLevelPreparedStmts.values() ) {
1:             try {
1:                 ps.close();
1:             } catch (SQLException se) {
1:                 accumulatedExceptions = Utils.accumulateSQLException(
1:                         se, accumulatedExceptions);
1:         isolationLevelPreparedStmts.clear();
commit:0b963b2
/////////////////////////////////////////////////////////////////////////
1:     //prepared statements associated with isolation level change are stored 
1:     // in isolationLevelPreparedStmts
0:     private Hashtable isolationLevelPreparedStmts = new Hashtable();
/////////////////////////////////////////////////////////////////////////
1: 
1:         //Close prepared statements associated with isolation level change
0:         if (isolationLevelPreparedStmts != null) {
0:             PreparedStatement ps;
0:             for (Iterator<PreparedStatement> it = isolationLevelPreparedStmts.keySet().iterator();
0:                     it.hasNext(); ) {
1:                 try {
0:                     Object key = it.next();
0:                     ps = (PreparedStatement)isolationLevelPreparedStmts.get(key);
0:                     ps.close();
0:                     ps = null;
1:                 } catch (SQLException se) {
1:                     accumulatedExceptions = Utils.accumulateSQLException(
1:                             se, accumulatedExceptions);
1:                 }
0:             isolationLevelPreparedStmts.clear();
/////////////////////////////////////////////////////////////////////////
1:         //If we do not already have a prepared statement for the requested
1:         // isolation level change, then create one
0:         PreparedStatement ps = (PreparedStatement)isolationLevelPreparedStmts.get(levelString);
1:         if (ps == null  || !ps.openOnClient_) {
1:             ps = prepareStatementX(
1:                     "SET CURRENT ISOLATION = " + levelString,
0:                     java.sql.ResultSet.TYPE_FORWARD_ONLY,
0:                     java.sql.ResultSet.CONCUR_READ_ONLY,
1:                     holdability(),
0:                     java.sql.Statement.NO_GENERATED_KEYS,
1:                     null, null);
1:             isolationLevelPreparedStmts.put(levelString, ps);
1:         //Execute the prepared statement to change the isolation level
1:             ps.execute();
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:6eb29f6
/////////////////////////////////////////////////////////////////////////
0:     *     Return true if the physical connection is still open.
0:     *     Might be logically closed but available for reuse.
/////////////////////////////////////////////////////////////////////////
1:         return;
/////////////////////////////////////////////////////////////////////////
1:         // Store the current auto-commit value and use it to restore 
1:         // at the end of this method.
1:         boolean currentAutoCommit = autoCommit_;
0:         java.sql.ResultSet rs = null;
1:         
/////////////////////////////////////////////////////////////////////////
0:                     !(getTransactionIsolationStmt.openOnClient_ &&
0:                             getTransactionIsolationStmt.openOnServer_)) {
/////////////////////////////////////////////////////////////////////////
1:             rs.close();    
/////////////////////////////////////////////////////////////////////////
1:             // Restore auto-commit value
1:             autoCommit_ = currentAutoCommit;
1:             if(rs != null)
0:                 rs.close();
/////////////////////////////////////////////////////////////////////////
1:         if(isolationStr.compareTo(DERBY_TRANSACTION_REPEATABLE_READ) == 0)
0:             return java.sql.Connection.TRANSACTION_REPEATABLE_READ;
1:         else if (isolationStr.compareTo(DERBY_TRANSACTION_SERIALIZABLE) == 0)
0:             return java.sql.Connection.TRANSACTION_SERIALIZABLE;
1:         else if (isolationStr.compareTo(DERBY_TRANSACTION_READ_COMMITTED) == 0)
0:             return java.sql.Connection.TRANSACTION_READ_COMMITTED;
1:         else if (isolationStr.compareTo(DERBY_TRANSACTION_READ_UNCOMMITTED) == 0)
0:             return java.sql.Connection.TRANSACTION_READ_UNCOMMITTED;
1:         else 
0:             return java.sql.Connection.TRANSACTION_NONE;
/////////////////////////////////////////////////////////////////////////
1:                         new ClientMessageId (SQLState.XACT_SAVEPOINT_RELEASE_ROLLBACK_FAIL));
1:                         new ClientMessageId (SQLState.NO_SAVEPOINT_ROLLBACK_OR_RELEASE_WHEN_AUTO));
1:                             new ClientMessageId (SQLState.SAVEPOINT_NOT_CREATED_BY_CONNECTION));
1:                         new ClientMessageId (SQLState.SAVEPOINT_NOT_CREATED_BY_CONNECTION));
/////////////////////////////////////////////////////////////////////////
1:                     new ClientMessageId (SQLState.NO_CURRENT_CONNECTION));
/////////////////////////////////////////////////////////////////////////
1:     {
/////////////////////////////////////////////////////////////////////////
1:     {
/////////////////////////////////////////////////////////////////////////
1:     }
commit:89c399d
/////////////////////////////////////////////////////////////////////////
1:         //DERBY-4653
1:         //If we are not in a transaction, we don't want to flow commit. We just return.
1:         if (!this.inUnitOfWork_)
1:              return;       
commit:2f3d052
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.client.net.NetXAResource;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * The default isolation level, enforced on connection resets.
1:      * <p>
1:      * Note that this value may be changed upon connection initialization in
1:      * the future, as the server can piggy-back the isolation level.
1:      */
1:     private int defaultIsolation = TRANSACTION_READ_COMMITTED;
/////////////////////////////////////////////////////////////////////////
1:         //This avoids assertion like DERBY-4343 by short-circuiting
1:         //setTransactionIsolation. Before this check, for case as users
1:         //obtaining the pooled connection for the third time, the variable
1:         //isolation_ is reset Connection.completeReset. 
1:         //Isolation_ remain as UNKNOWN until getTransactionIsolation is called
1:         //or a different statement causing a change of the isolation level
1:         //is executed.We might think about change the default value for Isolation_
1:         //to DERBY_TRANSACTION_READ_COMMITTED. With introducing 
1:         //getTransactionIsolationX and this check, assertion is never reach. 
1:         //As part of DERBY-4314 fix, the client driver should act as embedded 
1:         //and return here, otherwise setTransactionIsolation will commit 
1:         //the transaction which is not the intention.
1:         if (level == getTransactionIsolationX()) 
1: 	    return;
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:         if (agent_.loggingEnabled()) {
1:             agent_.logWriter_.traceEntry(this, "getTransactionIsolation", isolation_);
1:         }
1:         try {
0:             // Per jdbc spec (see java.sql.Connection.close() javadoc).
1:             checkForClosedConnection();
1:             return getTransactionIsolationX();
1:         } catch (SqlException se) {
1:             throw se.getSQLException();
1:         }
1:     }
1: 
1:     public int getTransactionIsolationX() throws SQLException {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Sets the default isolation level of the connection upon connection
1:      * initialization.
1:      * <p>
1:      * Note that depending on the server version, the default isolation value
1:      * may not be piggy-backed on the initialization flow. In that case, the
1:      * default is assumed / hardcoded to be READ_COMMITTED.
1:      *
1:      * @param pbIsolation isolation level as specified by
1:      *      {@code java.sql.Connection}
1:      */
1:     public void completeInitialPiggyBackIsolation(int pbIsolation) {
1:         if (SanityManager.DEBUG) {
1:             SanityManager.ASSERT(
1:                     pbIsolation == 
0:                         java.sql.Connection.TRANSACTION_READ_UNCOMMITTED ||
1:                     pbIsolation ==
0:                         java.sql.Connection.TRANSACTION_READ_COMMITTED ||
1:                     pbIsolation ==
0:                         java.sql.Connection.TRANSACTION_REPEATABLE_READ ||
1:                     pbIsolation ==
0:                         java.sql.Connection.TRANSACTION_SERIALIZABLE,
1:                     "Invalid isolation level value: " + pbIsolation);
1:         }
1:         defaultIsolation = isolation_ = pbIsolation;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Sets the current schema upon connection initialization.
1:      *
1:      * @param pbSchema the schema name
1:      */
1:     public void completeInitialPiggyBackSchema(String pbSchema) {
1:         currentSchemaName_ = pbSchema;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:                                  boolean closeStatementsOnClose,
1:                                  NetXAResource xares)
/////////////////////////////////////////////////////////////////////////
1:         }
1:         // Must reset transaction isolation level if it has been changed,
1:         // except when we are doing XA and resuming/joining a global tx.
1:         if (xares != null && xares.keepCurrentIsolationLevel()) {
1:             // Reset the flag, do nothing else.
1:             xares.setKeepCurrentIsolationLevel(false);
1:         } else if (isolation_ != defaultIsolation) {
1:             // This might not fare well with connection pools, if it has
1:             // been configured to deliver connections with a different
1:             // isolation level, i.e. it has to set the isolation level again
1:             // when it returns connection to client.
1:             // TODO: Investigate optimization options.
1:             setTransactionIsolationX(defaultIsolation);
commit:8055511
/////////////////////////////////////////////////////////////////////////
1:     private int transactionID_ = 0;
1:     
/////////////////////////////////////////////////////////////////////////
1:             flowCommit();            
/////////////////////////////////////////////////////////////////////////
1:      * Returns the ID of the active transaction for this connection.
1:      * @return the ID of the active transaction
1:      */
1:     public int getTransactionID(){
0:     	return transactionID_;
1:     }
1:     
1:     /**
/////////////////////////////////////////////////////////////////////////
1:         transactionID_++;
/////////////////////////////////////////////////////////////////////////
1:         transactionID_++;
commit:b52081a
/////////////////////////////////////////////////////////////////////////
1:                     null, null);
/////////////////////////////////////////////////////////////////////////
0:         PreparedStatement ps = newPreparedStatement_(sql, java.sql.ResultSet.TYPE_FORWARD_ONLY, java.sql.ResultSet.CONCUR_READ_ONLY, holdability(), java.sql.Statement.NO_GENERATED_KEYS, null,
0:                 null);
/////////////////////////////////////////////////////////////////////////
1:                     null, null);
/////////////////////////////////////////////////////////////////////////
1:                     null, null);
/////////////////////////////////////////////////////////////////////////
1:                                         String[] columnNames,
1:                                         int[] columnIndexes) throws SqlException {
0:         PreparedStatement ps = newPreparedStatement_(sql, resultSetType, resultSetConcurrency, resultSetHoldability, autoGeneratedKeys, columnNames,
0:                 columnIndexes);
/////////////////////////////////////////////////////////////////////////
1:         resetPreparedStatement_(ps, ps.sql_, ps.resultSetType_, ps.resultSetConcurrency_, ps.resultSetHoldability_, ps.autoGeneratedKeys_, ps.generatedKeysColumnNames_,
1:                 ps.generatedKeysColumnIndexes_);
/////////////////////////////////////////////////////////////////////////
1:                     null, null);
/////////////////////////////////////////////////////////////////////////
1:             int genKeys = (columnIndexes == null ||
1:                     columnIndexes.length == 0
0:                     ? Statement.NO_GENERATED_KEYS: 
0:                 Statement.RETURN_GENERATED_KEYS);
0:             PreparedStatement ps = prepareStatementX(sql,
0:                     java.sql.ResultSet.TYPE_FORWARD_ONLY,
0:                     java.sql.ResultSet.CONCUR_READ_ONLY,
1:                     holdability(),
1:                     genKeys,
1:                     null, columnIndexes);
1:             if (agent_.loggingEnabled()) {
1:                 agent_.logWriter_.traceExit(this, "prepareStatement", ps);
1:             } 
1:             return ps;
/////////////////////////////////////////////////////////////////////////
1:                     columnNames, null);
/////////////////////////////////////////////////////////////////////////
1:                                                                String[] columnNames, int[] columnIndexes) throws SqlException;
/////////////////////////////////////////////////////////////////////////
1:                                                     String[] columnNames,
1:                                                     int[] columnIndexes) throws SqlException;
commit:aadfc18
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             int genKeys = (columnNames == null ||
1:                     columnNames.length == 0
0:                     ? Statement.NO_GENERATED_KEYS: 
0:                 Statement.RETURN_GENERATED_KEYS);
1:                     genKeys,
/////////////////////////////////////////////////////////////////////////
commit:583cd0f
/////////////////////////////////////////////////////////////////////////
1:      * @return isolation level as a JDBC integer value 
commit:ac53be6
/////////////////////////////////////////////////////////////////////////
1:     
1:     // used to get transaction isolation level
0:     private Statement getTransactionIsolationStmt = null;
1:     
/////////////////////////////////////////////////////////////////////////
0:         setTransactionIsolationStmt = null;
0:         if (getTransactionIsolationStmt != null) {
1:             try {
0:                 getTransactionIsolationStmt.close();
0:             } catch (SQLException se) {
0:                 accumulatedExceptions = Utils.accumulateSQLException(
0:                         se, accumulatedExceptions);
1:             }
1:         }
0:         getTransactionIsolationStmt = null;
/////////////////////////////////////////////////////////////////////////
1:     	
0:     	// Store the current auto-commit value and use it to restore 
0:     	// at the end of this method.
0:     	boolean currentAutoCommit = autoCommit_;
0:     	java.sql.ResultSet rs = null;
1:     	
1:             
1:             // Set auto-commit to false when executing the statement as we do not want to
1:             // cause an auto-commit from getTransactionIsolation() method. 
1:             autoCommit_ = false;
1:             
1:             // DERBY-1148 - Client reports wrong isolation level. We need to get the isolation
1:             // level from the server. 'isolation_' maintained in the client's connection object
1:             // can be out of sync with the real isolation when in an XA transaction. This can 
1:             // also happen when isolation is set using SQL instead of JDBC. So we try to get the
1:             // value from the server by calling the "current isolation" function. If we fail to 
1:             // get the value, return the value stored in the client's connection object.
0:             if (getTransactionIsolationStmt == null  || 
0:             		!(getTransactionIsolationStmt.openOnClient_ &&
0:             				getTransactionIsolationStmt.openOnServer_)) {
0:                 getTransactionIsolationStmt =
0:                         createStatementX(java.sql.ResultSet.TYPE_FORWARD_ONLY,
0:                                 java.sql.ResultSet.CONCUR_READ_ONLY,
1:                                 holdability());
1:             }
1:             
0:             rs = getTransactionIsolationStmt.executeQuery("values current isolation");
1:             rs.next();
1:             String isolationStr = rs.getString(1);
0:             isolation_ = translateIsolation(isolationStr);
0:             rs.close();	
1:         finally {
0:         	// Restore auto-commit value
0:         	autoCommit_ = currentAutoCommit;
0:         	if(rs != null)
0:         		rs.close();
1:         }
1:         
0:         return isolation_;
1:     }
1:   
1:     /**
1:      * Translates the isolation level from a SQL string to the JDBC int value
1:      *  
1:      * @param isolationStr SQL isolation string
0:      * @return
1:      */
1:     private int translateIsolation(String isolationStr) {
0:     	if(isolationStr.compareTo(DERBY_TRANSACTION_REPEATABLE_READ) == 0)
0:     		return java.sql.Connection.TRANSACTION_REPEATABLE_READ;
0:     	else if (isolationStr.compareTo(DERBY_TRANSACTION_SERIALIZABLE) == 0)
0:     		return java.sql.Connection.TRANSACTION_SERIALIZABLE;
0:     	else if (isolationStr.compareTo(DERBY_TRANSACTION_READ_COMMITTED) == 0)
0:     		return java.sql.Connection.TRANSACTION_READ_COMMITTED;
0:     	else if (isolationStr.compareTo(DERBY_TRANSACTION_READ_UNCOMMITTED) == 0)
0:     		return java.sql.Connection.TRANSACTION_READ_UNCOMMITTED;
1:     	else 
0:     		return java.sql.Connection.TRANSACTION_NONE;
commit:dd7d579
/////////////////////////////////////////////////////////////////////////
1:     // DERBY-210 -  WeakHashMap is used to store references to objects to avoid
1:     // memory leaks. When there are no other references to the keys in a 
1:     // WeakHashMap, they will get removed from the map and can thus get 
1:     // garbage-collected. They do not have to wait till the Connection object 
1:     // is collected.
1:         
1:     // In Connection.markStatementsClosed() method, this list is traversed to get a
1:     // list of open statements, which are marked closed and removed from the list.
0:     final java.util.WeakHashMap openStatements_ = new java.util.WeakHashMap();
/////////////////////////////////////////////////////////////////////////
0:     final java.util.WeakHashMap CommitAndRollbackListeners_ = new java.util.WeakHashMap();
/////////////////////////////////////////////////////////////////////////
1:         openStatements_.put(ps, null);
/////////////////////////////////////////////////////////////////////////
0:     	java.util.Set keySet = openStatements_.keySet();
0:         for (java.util.Iterator i = keySet.iterator(); i.hasNext();) {
/////////////////////////////////////////////////////////////////////////
0:     	java.util.Set keySet = openStatements_.keySet();
0:         for (java.util.Iterator i = keySet.iterator(); i.hasNext();) {
0:     	java.util.Set keySet = openStatements_.keySet();
0:         for (java.util.Iterator i = keySet.iterator(); i.hasNext();) {
/////////////////////////////////////////////////////////////////////////
1:         openStatements_.put(s, null);
/////////////////////////////////////////////////////////////////////////
1:         openStatements_.put(ps,null);
/////////////////////////////////////////////////////////////////////////
1:         openStatements_.put(cs,null);
/////////////////////////////////////////////////////////////////////////
0:     	java.util.Set keySet = CommitAndRollbackListeners_.keySet();
0:         for (java.util.Iterator i = keySet.iterator(); i.hasNext();) {
/////////////////////////////////////////////////////////////////////////
0:     	java.util.Set keySet = CommitAndRollbackListeners_.keySet();
0:     	for (java.util.Iterator i = keySet.iterator(); i.hasNext();) {
/////////////////////////////////////////////////////////////////////////
0:         java.util.Set keySet = openStatements_.keySet();
0:         for (java.util.Iterator i = keySet.iterator(); i.hasNext();) {
commit:fe35a93
/////////////////////////////////////////////////////////////////////////
0:             if (setTransactionIsolationStmt == null  || 
0:             		!(setTransactionIsolationStmt.openOnClient_ &&
0:             				setTransactionIsolationStmt.openOnServer_)) {
commit:ca8747c
/////////////////////////////////////////////////////////////////////////
1:     // Some statuses of DERBY objects may be invalid on server
1:     // after both commit and rollback. For example,
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:64b55c2
/////////////////////////////////////////////////////////////////////////
0:     // Since DERBY prepared statements must be re-prepared after a commit,
0:     // then we must traverse this list after a commit and notify statements
0:     // that they are now in an un-prepared state.
0:     final java.util.LinkedList openStatements_ = new java.util.LinkedList();
0:     // Some statuses of DERBY objects may be invalid on server either after only rollback
0:     // or after both commit and rollback. For example,
0:     // If they only depend on rollback, they need to get on RollbackOnlyListeners_.
0:     final java.util.LinkedList RollbackOnlyListeners_ = new java.util.LinkedList();
0:     final java.util.LinkedList CommitAndRollbackListeners_ = new java.util.LinkedList();
/////////////////////////////////////////////////////////////////////////
0:         openStatements_.add(ps);
/////////////////////////////////////////////////////////////////////////
0:         RollbackOnlyListeners_.clear();
/////////////////////////////////////////////////////////////////////////
0:         for (java.util.ListIterator i = openStatements_.listIterator(); i.hasNext();) {
/////////////////////////////////////////////////////////////////////////
0:         for (java.util.ListIterator i = openStatements_.listIterator(); i.hasNext();) {
0:         for (java.util.ListIterator i = openStatements_.listIterator(); i.hasNext();) {
/////////////////////////////////////////////////////////////////////////
0:         openStatements_.add(s);
/////////////////////////////////////////////////////////////////////////
0:         openStatements_.add(ps);
/////////////////////////////////////////////////////////////////////////
0:         openStatements_.add(cs);
/////////////////////////////////////////////////////////////////////////
0:         for (java.util.Iterator i = CommitAndRollbackListeners_.iterator(); i.hasNext();) {
/////////////////////////////////////////////////////////////////////////
0:         for (java.util.Iterator i = CommitAndRollbackListeners_.iterator(); i.hasNext();) {
0:             UnitOfWorkListener listener = (UnitOfWorkListener) i.next();
1:             listener.completeLocalRollback(i);
1:         }
0:         for (java.util.Iterator i = RollbackOnlyListeners_.iterator(); i.hasNext();) {
/////////////////////////////////////////////////////////////////////////
0:         for (java.util.Iterator i = openStatements_.iterator(); i.hasNext();) {
commit:cff2860
/////////////////////////////////////////////////////////////////////////
1:     
0:     // WeakHashMap is used to store references so that the objects added to 
0:     // the map can get garbage-collected without waiting for the Connection object.
1:     
0:     // When Connection.close() is called, this list is traversed and markClosed() 
0:     // is called on all statements in this list.    
0:     final java.util.WeakHashMap openStatements_ = new java.util.WeakHashMap();
0:     // Some statuses of DERBY objects may be invalid on server after both 
0:     // commit and rollback. For example,
0:     final java.util.WeakHashMap CommitAndRollbackListeners_ = new java.util.WeakHashMap();
/////////////////////////////////////////////////////////////////////////
0:         openStatements_.put(ps,null);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     	java.util.Set keySet = openStatements_.keySet();
0:         for (java.util.Iterator i = keySet.iterator(); i.hasNext();) {
/////////////////////////////////////////////////////////////////////////
0:     	java.util.Set keySet = openStatements_.keySet();
0:         for (java.util.Iterator i = keySet.iterator(); i.hasNext();) {
0:     	java.util.Set keySet = openStatements_.keySet();
0:         for (java.util.Iterator i = keySet.iterator(); i.hasNext();) {
/////////////////////////////////////////////////////////////////////////
0:         openStatements_.put(s,null);
/////////////////////////////////////////////////////////////////////////
0:         openStatements_.put(ps,null);
/////////////////////////////////////////////////////////////////////////
0:         openStatements_.put(cs,null);
/////////////////////////////////////////////////////////////////////////
0:     	java.util.Set keySet = CommitAndRollbackListeners_.keySet();
0:         for (java.util.Iterator i = keySet.iterator(); i.hasNext();) {
/////////////////////////////////////////////////////////////////////////
0:     	java.util.Set keySet = CommitAndRollbackListeners_.keySet();
0:         for (java.util.Iterator i = keySet.iterator(); i.hasNext();) {
/////////////////////////////////////////////////////////////////////////
0:         java.util.Set keySet = openStatements_.keySet();
0:         for (java.util.Iterator i = keySet.iterator(); i.hasNext();) {
commit:e3acc4a
/////////////////////////////////////////////////////////////////////////
1:     public boolean flowAutoCommit() throws SqlException {
1:             return true;
1:         return false;
commit:88c25bb
/////////////////////////////////////////////////////////////////////////
1:     // The client needs to keep track of the connection's transaction branch association
1:     // per table 2.6 in the XA+ specification in order to determine if commits should flow in
1:     // autocommit mode.  There is no need to keep track of suspended transactions separately from
1:     // XA_TO_NOT_ASSOCIATED.
1:     // 
1:     /**
1:      * <code>XA_T0_NOT_ASSOCIATED</code>
1:      * This connection is not currently associated with an XA transaction
1:      * In this state commits will flow in autocommit mode.
1:      */
1:     public static final int XA_T0_NOT_ASSOCIATED = 0;   
1:     
1:     /**
1:      * <code>XA_T1_ASSOCIATED</code>
1:      * In this state commits will not flow in autocommit mode.
1:      */
1:     public static final int XA_T1_ASSOCIATED = 1;  
1:     
1:     //TODO: Remove XA_RECOVER entirely once indoubtlist is gone.  
0:     protected int xaState_ = XA_T0_NOT_ASSOCIATED;
/////////////////////////////////////////////////////////////////////////
0:             if ((xaState_ == XA_T0_NOT_ASSOCIATED) ) {
/////////////////////////////////////////////////////////////////////////
0:             if ((xaState_ == XA_T0_NOT_ASSOCIATED) ) {
/////////////////////////////////////////////////////////////////////////
1:     public boolean isPhysicalConnClosed() {
commit:38083d6
/////////////////////////////////////////////////////////////////////////
0:     public static final int XA_LOCAL = 0;   //  No global transaction in process
0:     public static final int XA_GLOBAL = 1;  // Global transaction in process
0:     //TODO: Remove entirely once indoubtlist is gone.  
1:     //public static final int XA_RECOVER = 14;
0:     protected int xaState_ = XA_LOCAL;
/////////////////////////////////////////////////////////////////////////
1:         
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     protected abstract boolean allowLocalCommitRollback_() throws org.apache.derby.client.am.SqlException;
/////////////////////////////////////////////////////////////////////////
1:         if (! allowLocalCommitRollback_()) {
/////////////////////////////////////////////////////////////////////////
1:         if (! allowLocalCommitRollback_()) { // autoCommit is always false between xars.start() and xars.end()
/////////////////////////////////////////////////////////////////////////
1:         if (! allowLocalCommitRollback_()) {
/////////////////////////////////////////////////////////////////////////
1:         if (! allowLocalCommitRollback_()) {
/////////////////////////////////////////////////////////////////////////
0:             if ((xaState_ == XA_LOCAL) ) {
/////////////////////////////////////////////////////////////////////////
0:             if ((xaState_ == XA_LOCAL) ) {
0:                 readLocalXACommit_();               
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:    /**
0:     * 	Return true if the physical connection is still open.
0:     * 	Might be logically closed but available for reuse.
1:     *   @return true if physical connection still open
1:     */
0:     public boolean isPhysicallyClosed() {
1:     return !open_ && !availableForReuse_; 
1:    }
1:    
/////////////////////////////////////////////////////////////////////////
1:    
/////////////////////////////////////////////////////////////////////////
1:         } 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         } 
/////////////////////////////////////////////////////////////////////////
1:         } 
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:79bf1a8
/////////////////////////////////////////////////////////////////////////
1:         // nothing to do if the current schema name is cached and is the same
1:         // as the new schema name
1:         if ( ( currentSchemaName_ != null) && (currentSchemaName_.equals( schemaName )) )
1:         { return; }
1: 
commit:1837822
/////////////////////////////////////////////////////////////////////////
1:     ////////////////////////////////////////////////////////////////////
1:     //
1:     // INTRODUCED BY JDBC 4.1 IN JAVA 7
1:     //
1:     ////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Get the name of the current schema.
1:      */
1:     public String   getSchema() throws SQLException
1: 	{
1:         return getCurrentSchemaName();
1:     }
1:     
1:     /**
1:      * Set the default schema for the Connection.
1:      */
1:     public void   setSchema(  String schemaName ) throws SQLException
1: 	{
1:         try {
1:             checkForClosedConnection();
1:         } catch (SqlException se) {
1:             throw se.getSQLException();
1:         }
1: 
0:         java.sql.PreparedStatement   ps = null;
1: 
1:         try {
1:             ps = prepareStatement( "set schema ?" );
1:             ps.setString( 1, schemaName );
1:             ps.execute();
1:         }
1:         finally
1:         {
1:             if ( ps != null ) { ps.close(); }
1:         }
1: 	}
commit:71e32dc
/////////////////////////////////////////////////////////////////////////
0:     implements java.sql.Connection, ConnectionCallbackInterface
/////////////////////////////////////////////////////////////////////////
1:     protected  void    beginAborting()
commit:795f705
/////////////////////////////////////////////////////////////////////////
0: public abstract class Connection
0:     implements java.sql.Connection, ConnectionCallbackInterface, Runnable
1: {
/////////////////////////////////////////////////////////////////////////
1:     private boolean aborting_ = false;
/////////////////////////////////////////////////////////////////////////
1:             if ( !isAborting() ) { checkForClosedConnection(); }
/////////////////////////////////////////////////////////////////////////
1:         if (!open_ && !isAborting()) {
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:         aborting_ = false;
/////////////////////////////////////////////////////////////////////////
1: 
1:     /** Return true if the connection is aborting */
1:     public  boolean isAborting() { return aborting_; }
1:     /** Begin aborting the connection */
0:     public  void    beginAborting()
1:     {
1:         aborting_ = true;
1:         markClosed( false );
1:     }
1:     
0: 	//////////////////////////////////////////////////////////
1:     //
0: 	// Runnable BEHAVIOR
1:     //
0:     // This class implements Runnable so that the JDBC 4.1 abort(Executor)
0:     // method can run the closeX() logic in a separate thread if necessary.
1:     //
0: 	//////////////////////////////////////////////////////////
1: 
0:     public  void    run()
1:     {
1:         try {
0:             rollback();
0:             close();
0:         } catch (SQLException se)
1:         {
0:             se.printStackTrace( agent_.getLogWriter() );
1:         }
1:     }
commit:bead0ab
/////////////////////////////////////////////////////////////////////////
1:     /** Return true if the server supports nanoseconds in timestamps */
1:     protected abstract boolean serverSupportsTimestampNanoseconds();
1: 
commit:b16fdc6
/////////////////////////////////////////////////////////////////////////
1:     
1:     //Constant representing an invalid locator value
1:     private static final int INVALID_LOCATOR = -1;
/////////////////////////////////////////////////////////////////////////
1:     
1:     
1:     /**
1:      * Constructs an object that implements the <code>Clob</code> interface. 
1:      * The object returned initially contains no data.
1:      *
0:      * @return An object that implements the <clob>Clob</clob> interface
1:      * @throws java.sql.SQLException if an object that implements the
1:      * <code>Clob</code> interface can not be constructed.
1:      */
1:     
0:     public Clob createClob() throws SQLException {
1:         if (agent_.loggingEnabled()) {
1:             agent_.logWriter_.traceEntry(this, "createClob");
1:         }
1:         
1:         try {
1:             checkForClosedConnection();
1:         } catch (SqlException se) {
1:             throw se.getSQLException();
1:         }
0:         org.apache.derby.client.am.Clob clob = new 
0:                 org.apache.derby.client.am.Clob(this.agent_,"");
1:         
1:         if (agent_.loggingEnabled()) {
1:             agent_.logWriter_.traceExit(this, "createClob", clob);
1:         }
1:         
1:         return clob;
1:     }
1: 
1:     /**
1:      * Constructs an object that implements the <code>Blob</code> interface. 
1:      * The object returned initially contains no data.
1:      *
1:      * @return An object that implements the <code>Blob</code> interface
1:      * @throws SQLException if an object that implements the
1:      * </code>Blob</code> interface can not be constructed.
1:      *
1:      */
1:     
0:     public Blob createBlob() throws SQLException {
1:         if (agent_.loggingEnabled()) {
1:             agent_.logWriter_.traceEntry(this, "createBlob");
1:         }
1:         
1:         try {
1:             checkForClosedConnection();
1:         } catch (SqlException se) {
1:             throw se.getSQLException();
1:         }
1:         
1:         //Stores a locator value obtained by calling the
1:         //stored procedure BLOBCREATELOCATOR.
1:         int locator = INVALID_LOCATOR;
1:         
0:         //Stores the Blob instance that is returned.
0:         org.apache.derby.client.am.Blob blob = null;
1: 
1:         //Call the BLOBCREATELOCATOR stored procedure
1:         //that will return a locator value.
1:         try {
1:             locator = locatorProcedureCall().blobCreateLocator();
1:         }
1:         catch(SqlException sqle) {
1:             throw sqle.getSQLException();
1:         }
1:         
1:         //If the locator value is -1 it means that we do not
1:         //have locator support on the server.
1:         
0:         //The code here has been disabled because the Lob implementations
0:         //have still not been completely converted to use locators. Once
0:         //the Lob implementations are completed then this code can be enabled.
0:         if (locator != INVALID_LOCATOR && false) {
1:             //A valid locator value has been obtained.
0:             blob = new org.apache.derby.client.am.Blob(this.agent_, locator);
1:         } 
1:         else {
1:             //A valid locator value could not be obtained.
0:             blob = new org.apache.derby.client.am.Blob
0:                     (new byte[0],this.agent_, 0);
1:         }
1:         
1:         if (agent_.loggingEnabled()) {
1:             agent_.logWriter_.traceExit(this, "createBlob", blob);
1:         }
1:         
1:         return blob;
1:     }
1:     
1:     
commit:ad94e28
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * 
1:      * Rollback the specific UnitOfWorkListener. 
1:      * @param uwl The UnitOfWorkLitener to be rolled back
1:      *
1:      */
0:     public void completeSpecificRollback(UnitOfWorkListener uwl) {
0:         java.util.Set keySet = CommitAndRollbackListeners_.keySet();
0:         for (java.util.Iterator i = keySet.iterator(); i.hasNext();) {
0:             UnitOfWorkListener listener = (UnitOfWorkListener) i.next();
1:             if(listener == uwl) {
0:                 listener.completeLocalRollback(i);
1:                 break;
1:             }
1:         }
1:         inUnitOfWork_ = false;
1:     }
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      *
1:      * Rollback the UnitOfWorkListener specifically.
1:      * @param uwl The UnitOfWorkListener to be rolled back.
1:      *
1:      */
1:     public void completeAbnormalUnitOfWork(UnitOfWorkListener uwl) {
1:         completeSpecificRollback(uwl);
1:     }
commit:17d490d
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.jdbc.ClientBaseDataSource;
/////////////////////////////////////////////////////////////////////////
0:     public org.apache.derby.jdbc.ClientBaseDataSource dataSource_;
/////////////////////////////////////////////////////////////////////////
0:                          org.apache.derby.jdbc.ClientBaseDataSource dataSource) 
1:                                                            throws SqlException {
/////////////////////////////////////////////////////////////////////////
0:                          org.apache.derby.jdbc.ClientBaseDataSource dataSource) 
1:                                                            throws SqlException {
/////////////////////////////////////////////////////////////////////////
0:                                   org.apache.derby.jdbc.ClientBaseDataSource
0:                                             dataSource) throws SqlException {
/////////////////////////////////////////////////////////////////////////
0:                          org.apache.derby.jdbc.ClientBaseDataSource dataSource) 
0:                                                             throws SqlException {
/////////////////////////////////////////////////////////////////////////
0:                                    ClientBaseDataSource ds,
/////////////////////////////////////////////////////////////////////////
0:     synchronized public void reset(LogWriter logWriter, String user, 
0:             String password, ClientBaseDataSource ds, 
0:             boolean recomputeFromDataSource) throws SqlException {
0:             logWriter.traceConnectResetEntry(this, logWriter, user, 
0:                                             (ds != null) ? ds : dataSource_);
/////////////////////////////////////////////////////////////////////////
0:     synchronized public void reset(LogWriter logWriter, ClientBaseDataSource ds, 
0:             boolean recomputeFromDataSource) throws SqlException {
/////////////////////////////////////////////////////////////////////////
0:     abstract protected void reset_(LogWriter logWriter, String user, 
0:             String password, ClientBaseDataSource ds, 
0:             boolean recomputerFromDataSource) throws SqlException;
0:     abstract protected void reset_(LogWriter logWriter, 
0:             ClientBaseDataSource ds, 
0:             boolean recomputerFromDataSource) throws SqlException;
commit:dadd05a
/////////////////////////////////////////////////////////////////////////
1:             writeXACommit_ ();
/////////////////////////////////////////////////////////////////////////
1:             readXACommit_ ();
/////////////////////////////////////////////////////////////////////////
1:             writeXARollback_ ();
/////////////////////////////////////////////////////////////////////////
1:     
1:     protected abstract void writeXACommit_() throws SqlException;
1:     public abstract void readLocalXACommit_() throws SqlException;   
1:     
1:     protected abstract void readXACommit_() throws SqlException;   
1:     
0:     protected abstract void writeXATransactionStart(Statement statement) 
0:                                                 throws SqlException;
/////////////////////////////////////////////////////////////////////////
1:     
1:     protected abstract void writeXARollback_() throws SqlException;
1:     
1:     protected abstract void readXARollback_() throws SqlException;
1:         if (isXAConnection_) {
1:             writeXATransactionStart (statement);
1:         }
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:7639017
/////////////////////////////////////////////////////////////////////////
commit:818ef2a
/////////////////////////////////////////////////////////////////////////
1:     protected final String user_;
/////////////////////////////////////////////////////////////////////////
1:         this.user_ = user;
1:         initConnection(logWriter, dataSource);
/////////////////////////////////////////////////////////////////////////
1:         this.user_ = user;
1:         initConnection(logWriter, dataSource);
/////////////////////////////////////////////////////////////////////////
1:         // DERBY-3723: Reset schema to user name.
1:         currentSchemaName_ = this.user_;
commit:bbc2fd8
/////////////////////////////////////////////////////////////////////////
1:     protected void resetConnection(LogWriter logWriter)
0:             throws SqlException {
1:         // property encryptionManager_
1:         // if needed this will later be initialized by NET calls to initializePublicKeyForEncryption()
1:         encryptionManager_ = null;
0:         currentSchemaName_ = null;
1:         autoCommit_ = true;
1:         inUnitOfWork_ = false;
1:         holdability = ResultSet.HOLD_CURSORS_OVER_COMMIT;
1:         this.agent_.resetAgent(
1:                 this, logWriter, loginTimeout_, serverNameIP_, portNumber_);
/////////////////////////////////////////////////////////////////////////
1:     synchronized public void reset(LogWriter logWriter)
0:             throws SqlException {
1:             reset_(logWriter);
/////////////////////////////////////////////////////////////////////////
1:     abstract protected void reset_(LogWriter logWriter) throws SqlException;
/////////////////////////////////////////////////////////////////////////
1:      * @param closeStatementsOnClose is used to differentiate between
1:     protected void completeReset(boolean isDeferredReset,
0:                                  boolean closeStatementsOnClose)
0:             throws SqlException {
/////////////////////////////////////////////////////////////////////////
1:         if (closeStatementsOnClose) {
0:                 ((Statement) o).reset(closeStatementsOnClose);
commit:ea141d7
/////////////////////////////////////////////////////////////////////////
0:         if (recomputeFromDataSource) { // no need to reinitialize connection state if ds hasn't changed
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     synchronized public void reset(LogWriter logWriter, 
1:                                              dataSource_);
0:             reset_(logWriter, recomputeFromDataSource);
/////////////////////////////////////////////////////////////////////////
0:     abstract protected void reset_(LogWriter logWriter, 
commit:7dfe267
/////////////////////////////////////////////////////////////////////////
0:     public java.sql.Clob createClob() throws SQLException {
/////////////////////////////////////////////////////////////////////////
0:     public java.sql.Blob createBlob() throws SQLException {
commit:080c38f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     synchronized public void reset(LogWriter logWriter, ClientBaseDataSource ds, 
1:             logWriter.traceConnectResetEntry(this, logWriter, user_, 
0:             reset_(logWriter, ds, recomputeFromDataSource);
/////////////////////////////////////////////////////////////////////////
0:     abstract protected void reset_(LogWriter logWriter, ClientBaseDataSource ds, 
commit:f55d30a
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Checks whether the server supports locators for large objects.
1:      *
1:      * @return {@code true} if LOB locators are supported.
1:      */
1:     protected abstract boolean serverSupportsLocators();
1: 
commit:f5e51e9
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:10cd940
/////////////////////////////////////////////////////////////////////////
commit:76af6ed
/////////////////////////////////////////////////////////////////////////
1:         // Transaction isolation level is handled in completeReset.
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         markClosed(false);
/////////////////////////////////////////////////////////////////////////
0:     synchronized public void closeForReuse(boolean statementPooling)
0:             throws SqlException {
/////////////////////////////////////////////////////////////////////////
1:             markClosedForReuse(statementPooling);
/////////////////////////////////////////////////////////////////////////
0:     public void markClosed(boolean statementPooling) // called by LogicalConnection.close()
1:         if (!statementPooling) {
1:             markStatementsClosed();
1:         }
1:     private void markClosedForReuse(boolean statementPooling) {
1:         markClosed(statementPooling);
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * <br>NOTE:</br>The following comments are valid for the changes done as
1:      * part of implementing statement caching only (see DERBY-3313 and linked
1:      * issues).
1:      * <p>
1:      * We don't reset the isolation level to unknown unconditionally, as this
1:      * forces us to go to the server all the time. Since the value should now
1:      * be valid (DERBY-3192), we check if it has been changed from the default.
1:      *
0:      * @param recomputeFromDataSource is now used to differentiate between
1:      *      cases where statement pooling is enabled or not. If {@code true}, it
1:      *      means statement pooling is disabled and the statements are fully
1:      *      reset, which includes a re-prepare. If {@code false}, statement
1:      *      pooling is enabled, and a more lightweight reset procedure is used.
1:      */
/////////////////////////////////////////////////////////////////////////
0:         if (recomputeFromDataSource) {
0:             // NOTE: This is to match previous behavior.
0:             //       Investigate and check if it is really necessary.
0:             this.isolation_ = TRANSACTION_UNKNOWN;
0:             java.util.Set keySet = openStatements_.keySet();
0:             for (java.util.Iterator i = keySet.iterator(); i.hasNext();) {
0:                 Object o = i.next();
0:                 ((Statement) o).reset(recomputeFromDataSource);
1:             }
1:         } else {
0:             // Must reset transaction isolation level if it has been changed.
0:             if (isolation_ != Connection.TRANSACTION_READ_COMMITTED) {
0:                 // This might not fare well with connection pools, if it has
0:                 // been configured to deliver connection with a different
0:                 // isolation level, i.e. it has to set the isolation level again
0:                 // when it returns connection to client.
0:                 // TODO: Investigate optimization options.
0:                 setTransactionIsolationX(Connection.TRANSACTION_READ_COMMITTED);
1:             }
commit:2aa6cce
/////////////////////////////////////////////////////////////////////////
1:         if (agent_.loggingEnabled()) {
1:             agent_.logWriter_.traceEntry(this, "setTransactionIsolation", level);
1:         }
1:         try {
1:             setTransactionIsolationX(level);
1:         } catch (SqlException se) {
1:      * Set the transaction isolation level as specified.
1:      * <p>
1:      * If this method is called during a transaction, the result is
1:      * implementation-defined.
1:      * <p>
1:      * Information about Derby specific isolation level handling:
1:      * <ul> <li>REPEATABLE_READ = JDBC: TRANSACTION_SERIALIZABLE, DERBY: RR,
1:      *          PROTOCOL: repeatable read</li>
1:      *      <li>READ_STABILITY = JDBC: TRANSACTION_REPEATABLE_READ, DERBY: RS,
1:      *          PROTOCOL: All</li>
1:      *      <li>CURSOR_STABILITY = JDBC: TRANSACTION_READ_COMMITTED, DERBY: CS,
1:      *          PROTOCOL: Cursor stability</li>
1:      *      <li>UNCOMMITTED_READ = JDBC: TRANSACTION_READ_UNCOMMITTED,
1:      *          DERBY: UR, PROTOCOL: Change</li>
1:      *      <li>NO_COMMIT = JDBC: TRANSACTION_NONE, DERBY: NC, PROTOCOL:
1:      *          No commit</li>
1:      * </ul>
1:      */
1:     //@GuardedBy("this")
1:     private void setTransactionIsolationX(int level)
0:             throws SqlException {
1:         String levelString = null;
1:         switch (level) {
0:         case java.sql.Connection.TRANSACTION_REPEATABLE_READ:
1:             levelString = DERBY_TRANSACTION_REPEATABLE_READ;
1:             break;
0:         case java.sql.Connection.TRANSACTION_READ_COMMITTED:
1:             levelString = DERBY_TRANSACTION_READ_COMMITTED;
1:             break;
0:         case java.sql.Connection.TRANSACTION_SERIALIZABLE:
1:             levelString = DERBY_TRANSACTION_SERIALIZABLE;
1:             break;
0:         case java.sql.Connection.TRANSACTION_READ_UNCOMMITTED:
1:             levelString = DERBY_TRANSACTION_READ_UNCOMMITTED;
1:             break;
1:             // Per javadoc:
1:             //   Note that Connection.TRANSACTION_NONE cannot be used because it
1:             //   specifies that transactions are not supported.
0:         case java.sql.Connection.TRANSACTION_NONE:
1:         default:
1:             throw new SqlException(agent_.logWriter_,
1:                 new ClientMessageId (SQLState.UNIMPLEMENTED_ISOLATION_LEVEL),
0:                 new Integer(level));
1:         }
0:         if (setTransactionIsolationStmt == null  ||
0:                 !(setTransactionIsolationStmt.openOnClient_ &&
0:                         setTransactionIsolationStmt.openOnServer_)) {
0:             setTransactionIsolationStmt =
0:                     createStatementX(java.sql.ResultSet.TYPE_FORWARD_ONLY,
0:                             java.sql.ResultSet.CONCUR_READ_ONLY,
1:                             holdability());
1:         }
1: 
1:         try {
0:             setTransactionIsolationStmt.executeUpdate(
0:                 "SET CURRENT ISOLATION = " + levelString);
1:         } catch (SQLException sqle) {
1:             throw new SqlException(sqle);
1:         }
1: 
1:         // The server has now implicitly committed the
1:         // transaction so we have to clean up locally.
1:         completeLocalCommit();
1: 
0:         if (SanityManager.DEBUG && supportsSessionDataCaching()) {
0:             SanityManager.ASSERT(isolation_ == level);
1:         }
1:     }
1: 
1:     /**
commit:7ad8ff6
/////////////////////////////////////////////////////////////////////////
commit:59e127a
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         // and accumulated444ForMessageProcFailure_
/////////////////////////////////////////////////////////////////////////
commit:6de69bd
/////////////////////////////////////////////////////////////////////////
0:     CallableStatement prepareCallX(String sql,
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Reference to object with prepared statements for calling the locator
1:      * procedures. Makes it possible to reuse prepared statements within 
1:      * the connection.
1:      */
1:     private CallableLocatorProcedures lobProcs;
1:     
1:     /**
1:      * Get handle to the object that contains prepared statements for calling
1:      * locator procedures for this connection.  The object will be created on 
1:      * the first invocation.
1:      *
1:      * An example of how to call a stored procedure via this method:
1:      * <pre> <code>
1:      *    connection.locatorProcedureCall().blobReleaseLocator(locator);
1:      * </code> </pre>
1:      *
1:      * @return object with prepared statements for calling locator procedures
1:      */
1:     CallableLocatorProcedures locatorProcedureCall() 
1:     {
1:         if (lobProcs == null) {
1:             lobProcs = new CallableLocatorProcedures(this);
1:         }
1:         return lobProcs;
1:     }    
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:1e8a20f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private int holdability = ResultSet.HOLD_CURSORS_OVER_COMMIT;
/////////////////////////////////////////////////////////////////////////
0:             holdability = ResultSet.HOLD_CURSORS_OVER_COMMIT;
/////////////////////////////////////////////////////////////////////////
1:                 if (holdability == ResultSet.HOLD_CURSORS_OVER_COMMIT)
/////////////////////////////////////////////////////////////////////////
1:             if (resultSetHoldability == ResultSet.HOLD_CURSORS_OVER_COMMIT) {
1:                 resultSetHoldability = ResultSet.CLOSE_CURSORS_AT_COMMIT;
/////////////////////////////////////////////////////////////////////////
1:             return ResultSet.CLOSE_CURSORS_AT_COMMIT;
commit:d08d1a5
/////////////////////////////////////////////////////////////////////////
1:     private boolean availableForReuse_ = false;
/////////////////////////////////////////////////////////////////////////
0:     java.util.Hashtable clientCursorNameCache_ = new java.util.Hashtable();
commit:1128268
/////////////////////////////////////////////////////////////////////////
1:         // Downgrade the holdability to CLOSE_CURSORS_AT_COMMIT
1:         // and attach a warning. This is specified in
1:         // JDBC 4.0 (proposed final draft) section 16.1.3.1
1:         // Similar code is not needed for PreparedStatement
1:         // as the holdability gets pushed all the way to the
1:         // engine and handled there.
0:             if (resultSetHoldability == JDBC30Translation.HOLD_CURSORS_OVER_COMMIT) {
0:                 resultSetHoldability = JDBC30Translation.CLOSE_CURSORS_AT_COMMIT;
1:                 accumulateWarning(new SqlWarning(agent_.logWriter_, 
0:                         new MessageId(SQLState.HOLDABLE_RESULT_SET_NOT_AVAILABLE)));
1:             }
commit:4388f15
/////////////////////////////////////////////////////////////////////////
1:             // In an XA global transaction do not allow the
1:             // holdability to be set to hold cursors across
1:             // commits, as the engine does not support it.
1:             if (this.isXAConnection_ && this.xaState_ == XA_T1_ASSOCIATED)
1:             {
0:                 if (holdability == JDBC30Translation.HOLD_CURSORS_OVER_COMMIT)
1:                     throw new SqlException(agent_.logWriter_, 
0:                             new MessageId(SQLState.CANNOT_HOLD_CURSOR_XA));
1:             }
/////////////////////////////////////////////////////////////////////////
1:         // In an XA global transaction do not allow the
1:         // holdability to be set to hold cursors across
1:         // commits, as the engine does not support it.
1:         if (this.isXAConnection_ && this.xaState_ == XA_T1_ASSOCIATED)
1:         {
0:             if (resultSetHoldability == JDBC30Translation.HOLD_CURSORS_OVER_COMMIT)
1:                 throw new SqlException(agent_.logWriter_, 
0:                         new MessageId(SQLState.CANNOT_HOLD_CURSOR_XA));
1:         }
commit:fdfc981
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.shared.common.reference.JDBC30Translation;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Holdabilty for created statements.
1:      * Only access through the holdability method
1:      * to ensure the correct value is returned for an
1:      * XA connection.
1:      */
0:     private int holdability = JDBC30Translation.HOLD_CURSORS_OVER_COMMIT;
1:     
/////////////////////////////////////////////////////////////////////////
1:     private int xaState_ = XA_T0_NOT_ASSOCIATED;
/////////////////////////////////////////////////////////////////////////
1:             
0:             holdability = JDBC30Translation.HOLD_CURSORS_OVER_COMMIT;
/////////////////////////////////////////////////////////////////////////
0:             Statement s = createStatementX(java.sql.ResultSet.TYPE_FORWARD_ONLY, java.sql.ResultSet.CONCUR_READ_ONLY, holdability());
/////////////////////////////////////////////////////////////////////////
1:                     holdability(),
/////////////////////////////////////////////////////////////////////////
0:             CallableStatement cs = prepareCallX(sql, java.sql.ResultSet.TYPE_FORWARD_ONLY, java.sql.ResultSet.CONCUR_READ_ONLY, holdability());
/////////////////////////////////////////////////////////////////////////
0:         PreparedStatement ps = newPreparedStatement_(sql, java.sql.ResultSet.TYPE_FORWARD_ONLY, java.sql.ResultSet.CONCUR_READ_ONLY, holdability(), java.sql.Statement.NO_GENERATED_KEYS, null);
/////////////////////////////////////////////////////////////////////////
0:                                 holdability());
/////////////////////////////////////////////////////////////////////////
0:             Statement s = createStatementX(resultSetType, resultSetConcurrency, holdability());
/////////////////////////////////////////////////////////////////////////
1:                     holdability(),
/////////////////////////////////////////////////////////////////////////
0:             CallableStatement cs = prepareCallX(sql, resultSetType, resultSetConcurrency, holdability());
/////////////////////////////////////////////////////////////////////////
0:         CallableStatement cs = prepareCallX(sql, java.sql.ResultSet.TYPE_FORWARD_ONLY, java.sql.ResultSet.CONCUR_READ_ONLY, holdability());
/////////////////////////////////////////////////////////////////////////
1:             this.holdability = holdability;
1:             
1:        }
/////////////////////////////////////////////////////////////////////////
1:                 agent_.logWriter_.traceExit(this, "getHoldability", holdability());
1:             return holdability();
/////////////////////////////////////////////////////////////////////////
0:                     holdability());
/////////////////////////////////////////////////////////////////////////
0:                         holdability());
/////////////////////////////////////////////////////////////////////////
0:                         holdability());
/////////////////////////////////////////////////////////////////////////
1:                     holdability(),
/////////////////////////////////////////////////////////////////////////
1:                     holdability(),
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Return the holdabilty for the Connection. Matches the
1:      * embedded driver in the restriction that while in a
1:      * global (XA) transaction the holdability is CLOSE_CURSORS_AT_COMMIT.
1:      * Otherwise return the holdability set by the user.
1:      */
1:     final int holdability()
1:     {
1:         if (this.isXAConnection_ && this.xaState_ == XA_T1_ASSOCIATED)
0:             return JDBC30Translation.CLOSE_CURSORS_AT_COMMIT;
1:         return holdability;
1:     }
commit:b1b9120
/////////////////////////////////////////////////////////////////////////
0:         if (dataSource.getConnectionAttributes() != null) {
0:             databaseName_ = dataSource.getDatabaseName() + ";" + dataSource.getConnectionAttributes();
1:         } else {
1:             databaseName_ = dataSource.getDatabaseName();
1:         }
commit:600628a
/////////////////////////////////////////////////////////////////////////
0:         // Derby-409 fix
0:         databaseName_ = dataSource.getDatabaseName() + ";" + dataSource.getConnectionAttributes();
author:Bernt Johnsen
-------------------------------------------------------------------------------
commit:5839503
/////////////////////////////////////////////////////////////////////////
0:     public int clientSSLMode_ = ClientBaseDataSource.SSL_OFF;
/////////////////////////////////////////////////////////////////////////
1:         clientSSLMode_ = 
0:             ClientBaseDataSource.getSSLModeFromString(dataSource.getSsl());
1: 
1:                 clientSSLMode_);
/////////////////////////////////////////////////////////////////////////
1:         clientSSLMode_ = 
0:             ClientBaseDataSource.getSSLModeFromString(dataSource.getSsl());
1: 
1:                 clientSSLMode_);
commit:37ce91b
/////////////////////////////////////////////////////////////////////////
0:     public int clientSSLMode_ = org.apache.derby.jdbc.ClientBaseDataSource.SSL_OFF;
/////////////////////////////////////////////////////////////////////////
0:                 0 /*TODO: SSL & Datasource*/);
/////////////////////////////////////////////////////////////////////////
0:                 0 /*TODO: SSL & Datasource*/);
/////////////////////////////////////////////////////////////////////////
0:         clientSSLMode_ = ClientDataSource.getClientSSLMode(properties);
1:                 clientSSLMode_);
/////////////////////////////////////////////////////////////////////////
1:     protected abstract Agent newAgent_(LogWriter logWriter, int loginTimeout, String serverName, int portNumber, int clientSSLMode) throws SqlException;
commit:6bc2e25
/////////////////////////////////////////////////////////////////////////
0:     public boolean useSSL_ = false;
/////////////////////////////////////////////////////////////////////////
1:                 portNumber_,
0:                 false /*TODO: SSL & Datasource*/);
/////////////////////////////////////////////////////////////////////////
1:                 portNumber_,
0:                 false /*TODO: SSL & Datasource*/);
/////////////////////////////////////////////////////////////////////////
0:         useSSL_ = ClientDataSource.getSsl(properties);
1:                 portNumber_,
0:                 useSSL_);
/////////////////////////////////////////////////////////////////////////
0:     protected abstract Agent newAgent_(LogWriter logWriter, int loginTimeout, String serverName, int portNumber, boolean useSSL) throws SqlException;
commit:00b1b6d
/////////////////////////////////////////////////////////////////////////
1:             boolean savedInUnitOfWork = inUnitOfWork_;
1:             // So... of we did not have an active transaction before
1:             // the query, we pretend to still not have an open
1:             // transaction. The result set is closed, so this should
1:             // not be problematic. DERBY-2084
1:             inUnitOfWork_ = savedInUnitOfWork;
commit:2ba89c5
/////////////////////////////////////////////////////////////////////////
1: 
0:             // The server has now implicitely committed the
0:             // transaction so we have to clean up locally.
0:             completeLocalCommit();
1: 
commit:c247315
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:f7b3a7a
/////////////////////////////////////////////////////////////////////////
1:         if (dataSource.getCreateDatabase() != null) // can be "create" or null
1:         {
1:             if (connAtrrs == null)
1:                 connAtrrs = "create=true";
1:             else
1:                 connAtrrs = connAtrrs + ";create=true";
1:         }
1:         if (dataSource.getShutdownDatabase() != null) // "shutdown" or null
1:         {
1:             if (connAtrrs == null)
1:                 connAtrrs = "shutdown=true";
1:             else
1:                 connAtrrs = connAtrrs + ";shutdown=true";
1:         }
1:             databaseName_ = databaseName_ + ";" + connAtrrs;
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:924602a
/////////////////////////////////////////////////////////////////////////
1:         // Derby-409 fix - Append connectionAttributes only if it is non-null. 
1:         // DERBY-1130 - Append connectionAttributes only if database name is
1:         // non-null. This will prevent use of database name set using 
1:         // "setConnectionAttributes" method.  
1:         databaseName_ = dataSource.getDatabaseName();
1:         String connAtrrs = dataSource.getConnectionAttributes();
1:         if(databaseName_ != null && connAtrrs != null)
0:         	databaseName_ = databaseName_ + ";" + connAtrrs;
1: 
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:59bf37d
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:30c01ec
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:David Van Couvering
-------------------------------------------------------------------------------
commit:494a328
/////////////////////////////////////////////////////////////////////////
0:         if (transactionInProgress() && !allowCloseInUOW_()) {
1:     
1:     public boolean transactionInProgress() {
0:         return !autoCommit_ && inUnitOfWork_;
1:     }
commit:e65b4db
/////////////////////////////////////////////////////////////////////////
1:                     new ClientMessageId (SQLState.NULL_SQL_TEXT));
/////////////////////////////////////////////////////////////////////////
1:                             new ClientMessageId (SQLState.DRDA_NO_AUTOCOMMIT_UNDER_XA));                            
/////////////////////////////////////////////////////////////////////////
1:                 new ClientMessageId(SQLState.DRDA_INVALID_XA_STATE_ON_COMMIT_OR_ROLLBACK));
/////////////////////////////////////////////////////////////////////////
1:                     new ClientMessageId (SQLState.CANNOT_CLOSE_ACTIVE_CONNECTION));                   
/////////////////////////////////////////////////////////////////////////
0:                     new ClientMessageId (SQLState.UNIMPLEMENTED_ISOLATION_LEVEL),
/////////////////////////////////////////////////////////////////////////
1:                 new ClientMessageId(SQLState.SCROLL_SENSITIVE_NOT_SUPPORTED)));
/////////////////////////////////////////////////////////////////////////
0:             		new ClientMessageId (SQLState.NOT_IMPLEMENTED),
/////////////////////////////////////////////////////////////////////////
1:                             new ClientMessageId(SQLState.CANNOT_HOLD_CURSOR_XA));
/////////////////////////////////////////////////////////////////////////
1:                         new ClientMessageId (SQLState.NO_SAVEPOINT_WHEN_AUTO));
/////////////////////////////////////////////////////////////////////////
1:                         new ClientMessageId (SQLState.NULL_NAME_FOR_SAVEPOINT));
1:                         new ClientMessageId (SQLState.NO_SAVEPOINT_WHEN_AUTO));
/////////////////////////////////////////////////////////////////////////
1:                 		new ClientMessageId (SQLState.XACT_SAVEPOINT_RELEASE_ROLLBACK_FAIL));
1:                 		new ClientMessageId (SQLState.NO_SAVEPOINT_ROLLBACK_OR_RELEASE_WHEN_AUTO));
0:                     		new ClientMessageId (SQLState.SAVEPOINT_NOT_CREATED_BY_CONNECTION));
0:                 		new ClientMessageId (SQLState.SAVEPOINT_NOT_CREATED_BY_CONNECTION));
/////////////////////////////////////////////////////////////////////////
0:                         new ClientMessageId (SQLState.XACT_SAVEPOINT_RELEASE_ROLLBACK_FAIL));
0:                         new ClientMessageId (SQLState.NO_SAVEPOINT_ROLLBACK_OR_RELEASE_WHEN_AUTO));
1:                     throw new SqlException(agent_.logWriter_, new ClientMessageId 
1:                     throw new SqlException(agent_.logWriter_, new ClientMessageId 
/////////////////////////////////////////////////////////////////////////
1:                         new ClientMessageId(SQLState.HOLDABLE_RESULT_SET_NOT_AVAILABLE)));
/////////////////////////////////////////////////////////////////////////
0:                 new ClientMessageId (SQLState.NOT_IMPLEMENTED),
/////////////////////////////////////////////////////////////////////////
1:                 new ClientMessageId(SQLState.CONNECTION_FAILED_ON_RESET));
/////////////////////////////////////////////////////////////////////////
0:                 new ClientMessageId(SQLState.CONNECTION_FAILED_ON_RESET));
/////////////////////////////////////////////////////////////////////////
0:             		new ClientMessageId (SQLState.NO_CURRENT_CONNECTION));
/////////////////////////////////////////////////////////////////////////
0:             		new ClientMessageId(SQLState.BAD_AUTO_GEN_KEY_VALUE), 
0:             		new ClientMessageId (SQLState.NOT_IMPLEMENTED),
commit:5d2e2bd
/////////////////////////////////////////////////////////////////////////
1:             DisconnectException de = new DisconnectException(agent_, 
0:                 new MessageId(SQLState.CONNECTION_FAILED_ON_RESET));
/////////////////////////////////////////////////////////////////////////
0:             DisconnectException de = new DisconnectException(agent_, 
0:                 new MessageId(SQLState.CONNECTION_FAILED_ON_RESET));
commit:e4ba4e1
/////////////////////////////////////////////////////////////////////////
0:                     new MessageId (SQLState.CANNOT_CLOSE_ACTIVE_CONNECTION));                   
commit:a53b758
/////////////////////////////////////////////////////////////////////////
1:             throw new SqlException(agent_.logWriter_,
0:                     new MessageId (SQLState.NULL_SQL_TEXT));
/////////////////////////////////////////////////////////////////////////
0:                             new MessageId (SQLState.DRDA_NO_AUTOCOMMIT_UNDER_XA));                            
/////////////////////////////////////////////////////////////////////////
0:                 new MessageId(SQLState.DRDA_INVALID_XA_STATE_ON_COMMIT_OR_ROLLBACK));
/////////////////////////////////////////////////////////////////////////
1:             
1: 
/////////////////////////////////////////////////////////////////////////
0:                     new MessageId (SQLState.CANNOT_CLOSE_ACTIVE_XA_CONNECTION));                   
/////////////////////////////////////////////////////////////////////////
0:                     new MessageId (SQLState.UNIMPLEMENTED_ISOLATION_LEVEL),
0:                     new Integer(level));                        
/////////////////////////////////////////////////////////////////////////
1:             throw new SqlException(agent_.logWriter_, 
0:             		new MessageId (SQLState.NOT_IMPLEMENTED),
0:                     "setTypeMap");
/////////////////////////////////////////////////////////////////////////
1:                 throw new SqlException(agent_.logWriter_, 
0:                         new MessageId (SQLState.NO_SAVEPOINT_WHEN_AUTO));
/////////////////////////////////////////////////////////////////////////
1:                 throw new SqlException(agent_.logWriter_, 
0:                         new MessageId (SQLState.NULL_NAME_FOR_SAVEPOINT));
1:                 throw new SqlException(agent_.logWriter_, 
0:                         new MessageId (SQLState.NO_SAVEPOINT_WHEN_AUTO));
/////////////////////////////////////////////////////////////////////////
1:                 throw new SqlException(agent_.logWriter_, 
0:                 		new MessageId (SQLState.XACT_SAVEPOINT_RELEASE_ROLLBACK_FAIL));
1:                 throw new SqlException(agent_.logWriter_, 
0:                 		new MessageId (SQLState.NO_SAVEPOINT_ROLLBACK_OR_RELEASE_WHEN_AUTO));
0:                     		new MessageId (SQLState.SAVEPOINT_NOT_CREATED_BY_CONNECTION));
0:                 		new MessageId (SQLState.SAVEPOINT_NOT_CREATED_BY_CONNECTION));
/////////////////////////////////////////////////////////////////////////
1:                 throw new SqlException(agent_.logWriter_, 
0:                         new MessageId (SQLState.XACT_SAVEPOINT_RELEASE_ROLLBACK_FAIL));
1:                 throw new SqlException(agent_.logWriter_, 
0:                         new MessageId (SQLState.NO_SAVEPOINT_ROLLBACK_OR_RELEASE_WHEN_AUTO));
0:                     throw new SqlException(agent_.logWriter_, new MessageId 
0:                             (SQLState.SAVEPOINT_NOT_CREATED_BY_CONNECTION));
0:                     throw new SqlException(agent_.logWriter_, new MessageId 
0:                             (SQLState.SAVEPOINT_NOT_CREATED_BY_CONNECTION));
1: 
/////////////////////////////////////////////////////////////////////////
1:             throw new SqlException(agent_.logWriter_, 
0:                 new MessageId (SQLState.NOT_IMPLEMENTED),
0:                 "prepareStatement(String, int[])");
/////////////////////////////////////////////////////////////////////////
1:             throw new SqlException(agent_.logWriter_, 
0:             		new MessageId (SQLState.NO_CURRENT_CONNECTION));
/////////////////////////////////////////////////////////////////////////
1:             throw new SqlException(agent_.logWriter_, 
0:             		new MessageId(SQLState.BAD_AUTO_GEN_KEY_VALUE), 
0:             		new Integer (autoGeneratedKeys));
1:             throw new SqlException(agent_.logWriter_,
0:             		new MessageId (SQLState.NOT_IMPLEMENTED),
0:                     "getAutoGeneratedKeys(columnNames == null)");
commit:7680ab7
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.reference.SQLState;
/////////////////////////////////////////////////////////////////////////
1:         return warnings_ == null ? null : warnings_.getSQLWarning();
/////////////////////////////////////////////////////////////////////////
1:             accumulateWarning(new SqlWarning(agent_.logWriter_, 
0:                 new MessageId(SQLState.SCROLL_SENSITIVE_NOT_SUPPORTED)));
/////////////////////////////////////////////////////////////////////////
0:             accumulateWarning(new SqlWarning(agent_.logWriter_, 
0:                 new MessageId(SQLState.INSENSITIVE_UPDATABLE_NOT_SUPPORTED)));
commit:d506170
/////////////////////////////////////////////////////////////////////////
0: import java.sql.SQLException;
1: 
/////////////////////////////////////////////////////////////////////////
0:     synchronized public java.sql.Statement createStatement() throws SQLException {
1:         try
1:         {
1:             if (agent_.loggingEnabled()) {
1:                 agent_.logWriter_.traceEntry(this, "createStatement");
1:             }
0:             Statement s = createStatementX(java.sql.ResultSet.TYPE_FORWARD_ONLY, java.sql.ResultSet.CONCUR_READ_ONLY, resultSetHoldability_);
1:             if (agent_.loggingEnabled()) {
1:                 agent_.logWriter_.traceExit(this, "createStatement", s);
1:             }
1:             return s;
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
0:     synchronized public java.sql.PreparedStatement prepareStatement(String sql) throws SQLException {
1:         try
1:         {
1:             if (agent_.loggingEnabled()) {
1:                 agent_.logWriter_.traceEntry(this, "prepareStatement", sql);
1:             }
0:             PreparedStatement ps = prepareStatementX(sql,
0:                     java.sql.ResultSet.TYPE_FORWARD_ONLY,
0:                     java.sql.ResultSet.CONCUR_READ_ONLY,
0:                     resultSetHoldability_,
0:                     java.sql.Statement.NO_GENERATED_KEYS,
0:                     null);
1:             if (agent_.loggingEnabled()) {
1:                 agent_.logWriter_.traceExit(this, "prepareStatement", ps);
1:             }
1:             return ps;
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
/////////////////////////////////////////////////////////////////////////
0:     synchronized public java.sql.CallableStatement prepareCall(String sql) throws SQLException {
1:         try
1:         {
1:             if (agent_.loggingEnabled()) {
1:                 agent_.logWriter_.traceEntry(this, "prepareCall", sql);
1:             }
0:             CallableStatement cs = prepareCallX(sql, java.sql.ResultSet.TYPE_FORWARD_ONLY, java.sql.ResultSet.CONCUR_READ_ONLY, resultSetHoldability_);
1:             if (agent_.loggingEnabled()) {
1:                 agent_.logWriter_.traceExit(this, "prepareCall", cs);
1:             }
1:             return cs;
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
/////////////////////////////////////////////////////////////////////////
1:     public String nativeSQL(String sql) throws SQLException {
1:         try
1:         {
1:             if (agent_.loggingEnabled()) {
1:                 agent_.logWriter_.traceEntry(this, "nativeSQL", sql);
1:             }
1:             String nativeSql = nativeSQLX(sql);
1:             if (agent_.loggingEnabled()) {
1:                 agent_.logWriter_.traceExit(this, "nativeSQL", nativeSql);
1:             }
1:             return nativeSql;
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
1: 
/////////////////////////////////////////////////////////////////////////
1:     synchronized public void setAutoCommit(boolean autoCommit) throws SQLException {
1:         try
1:         {
1:             if (agent_.loggingEnabled()) {
1:                 agent_.logWriter_.traceEntry(this, "setAutoCommit", autoCommit);
1:             }
1:             checkForClosedConnection();
0:             if (! allowLocalCommitRollback_()) {
1:                 if (autoCommit) { // can't toggle to autocommit mode when between xars.start() and xars.end()
0:                     throw new SqlException(agent_.logWriter_,
0:                             "setAutoCommit(true) invalid during global transaction",
0:                             SqlState._2D521, // Spec'ed by PROTOCOL
0:                             SqlCode.invalidSetAutoCommitUnderXA);
1:                 }
1:             } else {
1:                 if (autoCommit == autoCommit_) {
1:                     return; // don't flow a commit if nothing changed.
1:                 }
1:                 if (inUnitOfWork_) {
1:                     flowCommit(); // we are not between xars.start() and xars.end(), can flow commit
1:                 }
1:             autoCommit_ = autoCommit;
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
1:         }
1:     public boolean getAutoCommit() throws SQLException {
1:         try
1:         {
1:             checkForClosedConnection();
1:             if (agent_.loggingEnabled()) {
1:                 agent_.logWriter_.traceExit(this, "getAutoCommit", autoCommit_);
1:             }
0:             if (! allowLocalCommitRollback_()) { // autoCommit is always false between xars.start() and xars.end()
1:                 return false;
1:             }
1:             return autoCommit_;
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
1:     synchronized public void commit() throws SQLException {
1:         try
1:         {
1:             if (agent_.loggingEnabled()) {
1:                 agent_.logWriter_.traceEntry(this, "commit");
1:             }
1:             // the following XA State check must be in commit instead of commitX since
1:             // external application call commit, the SqlException should be thrown
1:             // only if an external application calls commit during a Global Transaction,
1:             // internal code will call commitX which will ignore the commit request
1:             // while in a Global transaction
1:             checkForInvalidXAStateOnCommitOrRollback();
1:             checkForClosedConnection();
0:             flowCommit();
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
1:         }
/////////////////////////////////////////////////////////////////////////
1:     synchronized public void rollback() throws SQLException {
1:         try
1:         {
1:             if (agent_.loggingEnabled()) {
1:                 agent_.logWriter_.traceEntry(this, "rollback");
1:             }
1:             checkForInvalidXAStateOnCommitOrRollback();
1:             checkForClosedConnection();
1:             flowRollback();
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
1:         }
/////////////////////////////////////////////////////////////////////////
1:     synchronized public void close() throws SQLException {
/////////////////////////////////////////////////////////////////////////
0:     synchronized public void closeX() throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:     synchronized public void closeResources() throws SQLException {
1:     private void closeResourcesX() throws SQLException {
1:         try
1:         {
1:             checkForTransactionInProgress();
1:         }
1:         catch ( SqlException e )
1:         {
1:             throw e.getSQLException();
1:         }
1:         
1:         SQLException accumulatedExceptions = null;
0:             } catch (SQLException se) {
/////////////////////////////////////////////////////////////////////////
1:                     Utils.accumulateSQLException(
1:                         e.getSQLException(), accumulatedExceptions);
1:             throw Utils.accumulateSQLException(e.getSQLException(), 
1:                 accumulatedExceptions);
/////////////////////////////////////////////////////////////////////////
1:     synchronized public void setTransactionIsolation(int level) throws SQLException {
1:         try
1:         {
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "setTransactionIsolation", level);
1:             }
0:             // Per jdbc spec (see java.sql.Connection.close() javadoc).
1:             checkForClosedConnection();
0:             // Javadoc for this method:
0:             //   If this method is called during a transaction, the result is implementation-defined.
1:             //
1:             //
0:             // REPEATABLE_READ = JDBC: TRANSACTION_SERIALIZABLE, DERBY: RR, PROTOCOL: repeatable read
0:             // READ_STABILITY = JDBC: TRANSACTION_REPEATABLE_READ, DERBY: RS, PROTOCOL: All
0:             // CURSOR_STABILITY = JDBC: TRANSACTION_READ_COMMITTED, DERBY: CS, PROTOCOL: Cursor stability
0:             // UNCOMMITTED_READ = JDBC: TRANSACTION_READ_UNCOMMITTED, DERBY: UR , PROTOCOL: Change
0:             // NO_COMMIT = JDBC: TRANSACTION_NONE, DERBY: NC, PROTOCOL: No commit
1:             //
0:             String levelString = null;
0:             switch (level) {
0:             case java.sql.Connection.TRANSACTION_REPEATABLE_READ:
0:                 levelString = DERBY_TRANSACTION_REPEATABLE_READ;
0:                 break;
0:             case java.sql.Connection.TRANSACTION_READ_COMMITTED:
0:                 levelString = DERBY_TRANSACTION_READ_COMMITTED;
0:                 break;
0:             case java.sql.Connection.TRANSACTION_SERIALIZABLE:
0:                 levelString = DERBY_TRANSACTION_SERIALIZABLE;
0:                 break;
0:             case java.sql.Connection.TRANSACTION_READ_UNCOMMITTED:
0:                 levelString = DERBY_TRANSACTION_READ_UNCOMMITTED;
0:                 break;
0:                 // Per javadoc:
0:                 //   Note that Connection.TRANSACTION_NONE cannot be used because it specifies that transactions are not supported.
0:             case java.sql.Connection.TRANSACTION_NONE:
0:             default:
0:                 throw new SqlException(agent_.logWriter_,
0:                         "Transaction isolation level " + level + " is an invalid argument for java.sql.Connection.setTransactionIsolation()." +
0:                         " See Javadoc specification for a list of valid arguments.", "XJ045");
1:             }
0:             if (setTransactionIsolationStmt == null) {
0:                 setTransactionIsolationStmt =
0:                         createStatementX(java.sql.ResultSet.TYPE_FORWARD_ONLY,
0:                                 java.sql.ResultSet.CONCUR_READ_ONLY,
0:                                 resultSetHoldability_);
1:             }
0:             setTransactionIsolationStmt.executeUpdate("SET CURRENT ISOLATION = " + levelString);
0:             isolation_ = level;
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
1:         }
1:     public int getTransactionIsolation() throws SQLException {
1:         try
1:         {
1:             checkForClosedConnection();
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceExit(this, "getTransactionIsolation", isolation_);
1:             }
0:             return isolation_;
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
1:         }
/////////////////////////////////////////////////////////////////////////
1:     synchronized public void clearWarnings() throws SQLException {
1:         try
1:         {
1:             if (agent_.loggingEnabled()) {
1:                 agent_.logWriter_.traceEntry(this, "clearWarnings");
1:             }
1:             clearWarningsX();
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
1:         }
/////////////////////////////////////////////////////////////////////////
0:     public java.sql.DatabaseMetaData getMetaData() throws SQLException {
1:         try
1:         {
1:             checkForClosedConnection();
1:             if (agent_.loggingEnabled()) {
1:                 agent_.logWriter_.traceExit(this, "getMetaData", databaseMetaData_);
1:             }
1:             return databaseMetaData_;
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
1:         }
1:     synchronized public void setReadOnly(boolean readOnly) throws SQLException {
1:         try
1:         {
1:             // This is a hint to the driver only, so this request is silently ignored.
1:             // PROTOCOL can only flow a set-read-only before the connection is established.
1:             if (agent_.loggingEnabled()) {
1:                 agent_.logWriter_.traceEntry(this, "setReadOnly", readOnly);
1:             }
1:             checkForClosedConnection();
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
1:         }
1:     public boolean isReadOnly() throws SQLException {
1:         try
1:         {
1:             checkForClosedConnection();
1:             if (agent_.loggingEnabled()) {
1:                 agent_.logWriter_.traceExit(this, "isReadOnly", jdbcReadOnly_);
1:             }
1:             return false;
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
1:         }
1:     synchronized public void setCatalog(String catalog) throws SQLException {
1:         try
1:         {
1:             if (agent_.loggingEnabled()) {
1:                 agent_.logWriter_.traceEntry(this, "setCatalog", catalog);
1:             }
1:             checkForClosedConnection();
1:             // Per jdbc spec: if the driver does not support catalogs, it will silently ignore this request.
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
1:         }
1:     public String getCatalog() throws SQLException {
1:         try
1:         {
1:             checkForClosedConnection();
1:             if (agent_.loggingEnabled()) {
1:                 agent_.logWriter_.traceExit(this, "getCatalog", (String) null);
1:             }
1:             return null;
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
1:         }
1:                                                            int resultSetConcurrency) throws SQLException {
1:         try
1:         {
1:             if (agent_.loggingEnabled()) {
1:                 agent_.logWriter_.traceEntry(this, "createStatement", resultSetType, resultSetConcurrency);
1:             }
0:             Statement s = createStatementX(resultSetType, resultSetConcurrency, resultSetHoldability_);
1:             if (agent_.loggingEnabled()) {
1:                 agent_.logWriter_.traceExit(this, "createStatement", s);
1:             }
1:             return s;
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
1:                                                                     int resultSetConcurrency) throws SQLException {
1:         try
1:         {
1:             if (agent_.loggingEnabled()) {
1:                 agent_.logWriter_.traceEntry(this, "prepareStatement", sql, resultSetType, resultSetConcurrency);
1:             }
0:             PreparedStatement ps = prepareStatementX(sql,
1:                     resultSetType,
1:                     resultSetConcurrency,
0:                     resultSetHoldability_,
0:                     java.sql.Statement.NO_GENERATED_KEYS,
0:                     null);
1:             if (agent_.loggingEnabled()) {
1:                 agent_.logWriter_.traceExit(this, "prepareStatement", ps);
1:             }
1:             return ps;
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
1:                                                                int resultSetConcurrency) throws SQLException {
1:         try
1:         {
1:             if (agent_.loggingEnabled()) {
1:                 agent_.logWriter_.traceEntry(this, "prepareCall", sql, resultSetType, resultSetConcurrency);
1:             }
0:             CallableStatement cs = prepareCallX(sql, resultSetType, resultSetConcurrency, resultSetHoldability_);
1:             if (agent_.loggingEnabled()) {
1:                 agent_.logWriter_.traceExit(this, "prepareCall", cs);
1:             }
1:             return cs;
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
/////////////////////////////////////////////////////////////////////////
0:     public java.util.Map getTypeMap() throws SQLException {
1:         try
1:         {
1:             if (agent_.loggingEnabled()) {
1:                 agent_.logWriter_.traceEntry(this, "getTypeMap");
1:             }
1:             checkForClosedConnection();
0:             java.util.Map map = new java.util.HashMap();
1:             if (agent_.loggingEnabled()) {
1:                 agent_.logWriter_.traceExit(this, "getTypeMap", map);
1:             }
1:             return map;
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
0:     synchronized public void setTypeMap(java.util.Map map) throws SQLException {
1:         try
1:         {
1:             if (agent_.loggingEnabled()) {
1:                 agent_.logWriter_.traceEntry(this, "setTypeMap", map);
1:             }
1:             checkForClosedConnection();
0:             throw new SqlException(agent_.logWriter_, "Connection.setTypeMap is not supported");
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
1:         }        
1:     synchronized public void setHoldability(int holdability) throws SQLException {
1:         try
1:         {
1:             if (agent_.loggingEnabled()) {
1:                 agent_.logWriter_.traceEntry(this, "setHoldability", holdability);
1:             }
1:             checkForClosedConnection();
0:             resultSetHoldability_ = holdability;
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
1:         }
1:     public int getHoldability() throws SQLException {
1:         try
1:         {
1:             checkForClosedConnection();
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceExit(this, "getHoldability", resultSetHoldability_);
1:             }
0:             return resultSetHoldability_;
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
1:         }
0:     synchronized public java.sql.Savepoint setSavepoint() throws SQLException {
1:         try
1:             if (agent_.loggingEnabled()) {
1:                 agent_.logWriter_.traceEntry(this, "setSavepoint");
1:             }
1:             checkForClosedConnection();
1:             if (autoCommit_) // Throw exception if auto-commit is on
1:             {
0:                 throw new SqlException(agent_.logWriter_, "Cannot set savepoint when in auto-commit mode.");
1:             } 
1:             // create an un-named savepoint.
1:             if ((++dncGeneratedSavepointId_) < 0) {
1:                 dncGeneratedSavepointId_ = 1; // restart from 1 when overflow.
1:             }
0:             Object s = setSavepointX(new Savepoint(agent_, dncGeneratedSavepointId_));
0:             return (java.sql.Savepoint) s;
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
1:         }
0:     synchronized public java.sql.Savepoint setSavepoint(String name) throws SQLException {
1:         try
1:             if (agent_.loggingEnabled()) {
1:                 agent_.logWriter_.traceEntry(this, "setSavepoint", name);
1:             }
1:             checkForClosedConnection();
1:             if (name == null) // Throw exception if savepoint name is null
1:             {
0:                 throw new SqlException(agent_.logWriter_, "Named savepoint needs a none-null name.");
1:             } else if (autoCommit_) // Throw exception if auto-commit is on
1:             {
0:                 throw new SqlException(agent_.logWriter_, "Cannot set savepoint when in auto-commit mode.");
1:             }
1:             // create a named savepoint.
0:             Object s = setSavepointX(new Savepoint(agent_, name));
0:             return (java.sql.Savepoint) s;
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
1:         }
0:     private Savepoint setSavepointX(Savepoint savepoint) throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:             } catch (SQLException e) {
1:         } catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
/////////////////////////////////////////////////////////////////////////
0:     synchronized public void rollback(java.sql.Savepoint savepoint) throws SQLException {
1:         try
1:             int saveXaState = xaState_;
1:             if (agent_.loggingEnabled()) {
1:                 agent_.logWriter_.traceEntry(this, "rollback", savepoint);
1:             }
1:             checkForClosedConnection();
1:             if (savepoint == null) // Throw exception if savepoint is null
1:             {
0:                 throw new SqlException(agent_.logWriter_, "Cannot rollback to a null savepoint.");
1:             } else if (autoCommit_) // Throw exception if auto-commit is on
1:             {
0:                 throw new SqlException(agent_.logWriter_, "Cannot rollback to a savepoint when in auto-commit mode.");
1:             } 
1:             // Only allow to rollback to a savepoint from the connection that create the savepoint.
1:             try {
0:                 if (this != ((Savepoint) savepoint).agent_.connection_) {
0:                     throw new SqlException(agent_.logWriter_,
0:                             "Rollback to a savepoint not created by this connection.");
1:                 }
0:             } catch (java.lang.ClassCastException e) { // savepoint is not an instance of am.Savepoint
1:             // Construct and flow a savepoint rollback statement to server.
0:             Statement stmt = null;
0:                 stmt = createStatementX(java.sql.ResultSet.TYPE_FORWARD_ONLY,
0:                         java.sql.ResultSet.CONCUR_READ_ONLY,
0:                         resultSetHoldability_);
1:                 String savepointName;
0:                     savepointName = ((Savepoint) savepoint).getSavepointName();
1:                 } catch (SQLException e) {
1:                     // generate the name for an un-named savepoint.
1:                     savepointName = dncGeneratedSavepointNamePrefix__ +
0:                             ((Savepoint) savepoint).getSavepointId();
0:                 String sql = "ROLLBACK TO SAVEPOINT \"" + savepointName + "\"";
0:                 stmt.executeX(sql);
1:             } finally {
1:                 if (stmt != null) {
1:                     try {
1:                         stmt.closeX();
1:                     } catch (SqlException doNothing) {
1:                     }
1:                 }
1:                 xaState_ = saveXaState;
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
0:     synchronized public void releaseSavepoint(java.sql.Savepoint savepoint) throws SQLException {
1:         try
1:             int saveXaState = xaState_;
1:             if (agent_.loggingEnabled()) {
1:                 agent_.logWriter_.traceEntry(this, "releaseSavepoint", savepoint);
1:             }
1:             checkForClosedConnection();
1:             if (savepoint == null) // Throw exception if savepoint is null
1:             {
0:                 throw new SqlException(agent_.logWriter_, "Cannot release a null savepoint.");
1:             } else if (autoCommit_) // Throw exception if auto-commit is on
1:             {
0:                 throw new SqlException(agent_.logWriter_, "Cannot release a savepoint when in auto-commit mode.");
1:             } 
1:             // Only allow to release a savepoint from the connection that create the savepoint.
1:             try {
0:                 if (this != ((Savepoint) savepoint).agent_.connection_) {
0:                     throw new SqlException(agent_.logWriter_,
0:                             "Cannot release a savepoint that was not created by this connection.");
1:                 }
0:             } catch (java.lang.ClassCastException e) { // savepoint is not an instance of am.Savepoint
1:             // Construct and flow a savepoint release statement to server.
0:             Statement stmt = null;
0:                 stmt = (Statement) createStatementX(java.sql.ResultSet.TYPE_FORWARD_ONLY,
0:                         java.sql.ResultSet.CONCUR_READ_ONLY,
0:                         resultSetHoldability_);
1:                 String savepointName;
0:                     savepointName = ((Savepoint) savepoint).getSavepointName();
1:                 } catch (SQLException e) {
1:                     // generate the name for an un-named savepoint.
1:                     savepointName = dncGeneratedSavepointNamePrefix__ +
0:                             ((Savepoint) savepoint).getSavepointId();
0:                 String sql = "RELEASE SAVEPOINT \"" + savepointName + "\"";
0:                 stmt.executeX(sql);
1:             } finally {
1:                 if (stmt != null) {
1:                     try {
1:                         stmt.closeX();
1:                     } catch (SqlException doNothing) {
1:                     }
1:                 }
1:                 xaState_ = saveXaState;
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
1:                                                            int resultSetHoldability) throws SQLException {
1:         try
1:         {
1:             if (agent_.loggingEnabled()) {
1:                 agent_.logWriter_.traceEntry(this, "createStatement", resultSetType, resultSetConcurrency, resultSetHoldability);
1:             }
0:             Statement s = createStatementX(resultSetType, resultSetConcurrency, resultSetHoldability);
1:             if (agent_.loggingEnabled()) {
1:                 agent_.logWriter_.traceExit(this, "createStatement", s);
1:             }
1:             return s;
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
/////////////////////////////////////////////////////////////////////////
1:                                                                     int resultSetHoldability) throws SQLException {
1:         try
1:         {
1:             if (agent_.loggingEnabled()) {
1:                 agent_.logWriter_.traceEntry(this, "prepareStatement", sql, resultSetType, resultSetConcurrency, resultSetHoldability);
1:             }
0:             PreparedStatement ps = prepareStatementX(sql,
1:                     resultSetType,
1:                     resultSetConcurrency,
1:                     resultSetHoldability,
0:                     java.sql.Statement.NO_GENERATED_KEYS,
0:                     null);
1:             if (agent_.loggingEnabled()) {
1:                 agent_.logWriter_.traceExit(this, "prepareStatement", ps);
1:             }
1:             return ps;
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
/////////////////////////////////////////////////////////////////////////
1:                                                                int resultSetHoldability) throws SQLException {
1:         try
1:         {
1:             if (agent_.loggingEnabled()) {
1:                 agent_.logWriter_.traceEntry(this, "prepareCall", sql, resultSetType, resultSetConcurrency, resultSetHoldability);
1:             }
0:             CallableStatement cs = prepareCallX(sql, resultSetType, resultSetConcurrency, resultSetHoldability);
1:             if (agent_.loggingEnabled()) {
1:                 agent_.logWriter_.traceExit(this, "prepareCall", cs);
1:             }
1:             return cs;
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
/////////////////////////////////////////////////////////////////////////
0:     public java.sql.PreparedStatement prepareStatement(String sql, int autoGeneratedKeys) throws SQLException {
1:         try
1:         {
1:             if (agent_.loggingEnabled()) {
1:                 agent_.logWriter_.traceEntry(this, "prepareStatement", sql, autoGeneratedKeys);
1:             }
0:             PreparedStatement ps = prepareStatementX(sql,
0:                     java.sql.ResultSet.TYPE_FORWARD_ONLY,
0:                     java.sql.ResultSet.CONCUR_READ_ONLY,
0:                     resultSetHoldability_,
1:                     autoGeneratedKeys,
0:                     null);
1:             if (agent_.loggingEnabled()) {
1:                 agent_.logWriter_.traceExit(this, "prepareStatement", ps);
1:             }
1:             return ps;
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
0:     public java.sql.PreparedStatement prepareStatement(String sql, int columnIndexes[]) throws SQLException {
1:         try
1:         {
1:             if (agent_.loggingEnabled()) {
1:                 agent_.logWriter_.traceEntry(this, "prepareStatement", sql, columnIndexes);
1:             }
1:             checkForClosedConnection();
0:             throw new SqlException(agent_.logWriter_, "Driver not capable");
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
1:         }
0:     public java.sql.PreparedStatement prepareStatement(String sql, String columnNames[]) throws SQLException {
1:         try
1:         {
1:             if (agent_.loggingEnabled()) {
1:                 agent_.logWriter_.traceEntry(this, "prepareStatement", sql, columnNames);
1:             }
0:             PreparedStatement ps = prepareStatementX(sql,
0:                     java.sql.ResultSet.TYPE_FORWARD_ONLY,
0:                     java.sql.ResultSet.CONCUR_READ_ONLY,
0:                     resultSetHoldability_,
0:                     java.sql.Statement.RETURN_GENERATED_KEYS,
0:                     columnNames);
1:             if (agent_.loggingEnabled()) {
1:                 agent_.logWriter_.traceExit(this, "prepareStatement", ps);
1:             }
1:             return ps;
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
author:Jeremy Boynes
-------------------------------------------------------------------------------
commit:70f7692
/////////////////////////////////////////////////////////////////////////
0:         ConnectionCallbackInterface {
1:     //---------------------navigational members-----------------------------------
1:     public Agent agent_;
0:     public DatabaseMetaData databaseMetaData_;
0:     // Since DERBY prepared statements must be re-prepared after a commit,
0:     // then we must traverse this list after a commit and notify statements
0:     // that they are now in an un-prepared state.
0:     final java.util.LinkedList openStatements_ = new java.util.LinkedList();
0:     // Some statuses of DERBY objects may be invalid on server either after only rollback
0:     // or after both commit and rollback. For example,
1:     // (1) prepared statements need to be re-prepared
1:     //     after both commit and rollback
1:     // (2) result set will be unpositioned on server after both commit and rollback.
0:     // If they only depend on rollback, they need to get on RollbackOnlyListeners_.
1:     // If they depend on both commit and rollback, they need to get on CommitAndRollbackListeners_.
0:     final java.util.LinkedList RollbackOnlyListeners_ = new java.util.LinkedList();
0:     final java.util.LinkedList CommitAndRollbackListeners_ = new java.util.LinkedList();
1:     private SqlWarning warnings_ = null;
1:     // ------------------------properties set for life of connection--------------
1:     // See ClientDataSource pre-connect settings
0:     public transient String user_;
0:     public boolean retrieveMessageText_;
0:     protected boolean jdbcReadOnly_;
0:     public int resultSetHoldability_;
1:     public String databaseName_;
1:     // Holds the Product-Specific Identifier which specifies
1:     // the product release level of a DDM Server.
1:     // The max length is 8.
1:     public String productID_;
1:     // Used to get the public key and encrypt password and/or userid
1:     protected EncryptionManager encryptionManager_;
0:     // used to set transaction isolation level
0:     private Statement setTransactionIsolationStmt = null;
1:     // ------------------------dynamic properties---------------------------------
1:     protected boolean open_ = true;
0:     protected boolean availableForReuse_ = false;
0:     public int isolation_ = Configuration.defaultIsolation;
1:     public boolean autoCommit_ = true;
1:     protected boolean inUnitOfWork_ = false; // This means a transaction is in progress.
1:     private boolean accumulated440ForMessageProcFailure_ = false;
1:     private boolean accumulated444ForMessageProcFailure_ = false;
0:     private boolean accumulatedSetReadOnlyWarning_ = false;
1:     //---------------------XA-----------------------------------------------------
1:     protected boolean isXAConnection_ = false; // Indicates an XA connection
1:     // XA States
0:     public static final int XA_OPEN_IDLE = 0;
0:     public static final int XA_LOCAL = 1; // local transaction started by DNC
0:     public static final int XA_LOCAL_CCC = 2; // local transaction started by CCC
0:     public static final int XA_ACTIVE = 3;
0:     public static final int XA_ENDED = 4;
0:     public static final int XA_HEUR_COMP = 5;
0:     public static final int XA_SUSPENDED = 6;
0:     public static final int XA_PREPARED = 7;
0:     public static final int XA_ROLLBACK = 8;
0:     public static final int XA_LOCAL_START_SENT = 9;
0:     public static final int XA_UNKNOWN = 10;
0:     public static final int XA_GLOBAL_START_SENT = 11;
0:     public static final int XA_PENDING_END = 12;
0:     public static final int XA_RBATHER = 13;
0:     public static final int XA_RECOVER = 14;
0:     public static final int XA_EMPTY_TRANSACTION = 15;
0:     public static final int XA_RBROLLBACK = 16;
0:     public static final int XA_PENDING_START = 17;
0:     public static final int XA_EMPTY_SUSPENDED = 18;
0:     protected int xaState_ = XA_OPEN_IDLE;
1:     // XA Host Type
1:     public int xaHostVersion_ = 0;
0:     public int loginTimeout_;
0:     public org.apache.derby.jdbc.ClientDataSource dataSource_;
1:     public String serverNameIP_;
1:     public int portNumber_;
0:     public java.util.Hashtable clientCursorNameCache_ = new java.util.Hashtable();
0:     public boolean canUseCachedConnectBytes_ = false;
1:     public int commBufferSize_ = 32767;
1:     // indicates if a deferred reset connection is required
1:     public boolean resetConnectionAtFirstSql_ = false;
1:     //---------------------constructors/finalizer---------------------------------
1:     // For jdbc 2 connections
0:     protected Connection(org.apache.derby.client.am.LogWriter logWriter,
0:                          String user,
0:                          String password,
0:                          org.apache.derby.jdbc.ClientDataSource dataSource) throws SqlException {
0:         initConnection(logWriter, user, dataSource);
1:     }
0:     protected Connection(org.apache.derby.client.am.LogWriter logWriter,
0:                          String user,
0:                          String password,
0:                          boolean isXAConn,
0:                          org.apache.derby.jdbc.ClientDataSource dataSource) throws SqlException {
1:         isXAConnection_ = isXAConn;
0:         initConnection(logWriter, user, dataSource);
1:     }
1:     // For jdbc 2 connections
0:     protected void initConnection(org.apache.derby.client.am.LogWriter logWriter,
0:                                   org.apache.derby.jdbc.ClientDataSource dataSource) throws SqlException {
1:         if (logWriter != null) {
1:             logWriter.traceConnectEntry(dataSource);
1:         }
0:         org.apache.derby.client.am.Configuration.checkForExceptionsFromLoadConfiguration(logWriter);
0:         user_ = user;
1:         // Extract common properties.
0:         databaseName_ = dataSource.getDatabaseName() + dataSource.getConnectionAttributes();
1:         retrieveMessageText_ = dataSource.getRetrieveMessageText();
1:         loginTimeout_ = dataSource.getLoginTimeout();
1:         dataSource_ = dataSource;
1: 
1:         serverNameIP_ = dataSource.getServerName();
1:         portNumber_ = dataSource.getPortNumber();
1:         agent_ = newAgent_(logWriter,
1:                 loginTimeout_,
1:                 serverNameIP_,
0:                 portNumber_);
1:     // For jdbc 2 connections
0:     protected Connection(org.apache.derby.client.am.LogWriter logWriter,
0:                          boolean isXAConn,
0:                          org.apache.derby.jdbc.ClientDataSource dataSource) throws SqlException {
1:         if (logWriter != null) {
1:             logWriter.traceConnectEntry(dataSource);
1:         }
1:         isXAConnection_ = isXAConn;
0:         org.apache.derby.client.am.Configuration.checkForExceptionsFromLoadConfiguration(logWriter);
0:         user_ = ClientDataSource.propertyDefault_user;
1:         // Extract common properties.
0:         databaseName_ = dataSource.getDatabaseName();
1:         retrieveMessageText_ = dataSource.getRetrieveMessageText();
1:         loginTimeout_ = dataSource.getLoginTimeout();
1:         dataSource_ = dataSource;
1:         serverNameIP_ = dataSource.getServerName();
1:         portNumber_ = dataSource.getPortNumber();
1:         agent_ = newAgent_(logWriter,
1:                 loginTimeout_,
1:                 serverNameIP_,
0:                 portNumber_);
1:     // This is a callback method, called by subsystem - NetConnection
0:     protected void resetConnection(LogWriter logWriter,
0:                                    String user,
0:                                    ClientDataSource ds,
0:                                    boolean recomputeFromDataSource) throws SqlException {
1:         // clearWarningsX() will re-initialize the following properties
1:         clearWarningsX();
0:         user_ = (user != null) ? user : user_;
0:         if (ds != null && recomputeFromDataSource) { // no need to reinitialize connection state if ds hasn't changed
0:             user_ = (user != null) ? user : ds.getUser();
0:             ;
0:             retrieveMessageText_ = ds.getRetrieveMessageText();
1: 
1: 
0:             // property encryptionManager_
0:             // if needed this will later be initialized by NET calls to initializePublicKeyForEncryption()
0:             encryptionManager_ = null;
1: 
0:             // property: open_
0:             // this should already be true
1: 
0:             isolation_ = Configuration.defaultIsolation;
0:             autoCommit_ = true;
1:             inUnitOfWork_ = false;
1: 
0:             loginTimeout_ = ds.getLoginTimeout();
0:             dataSource_ = ds;
1:         }
1: 
0:         // property isXAConnection_
0:         // leave set to current value.  this will impact which connect reset flows are used.
1: 
0:         xaState_ = XA_OPEN_IDLE;
0:         if (recomputeFromDataSource) {
0:             this.agent_.resetAgent(this, logWriter, loginTimeout_, serverNameIP_, portNumber_);
1:         }
1: 
0:     protected void resetConnection(LogWriter logWriter,
1:                                    String databaseName,
0:                                    java.util.Properties properties) throws SqlException {
1:         // clearWarningsX() will re-initialize the following properties
0:         // warnings_, accumulated440ForMessageProcFailure_,
0:         // accumulated444ForMessageProcFailure_, and accumulatedSetReadOnlyWarning_
1:         clearWarningsX();
1: 
1:         databaseName_ = databaseName;
0:         user_ = ClientDataSource.getUser(properties);
1: 
0:         retrieveMessageText_ = ClientDataSource.getRetrieveMessageText(properties);
1: 
1: 
0:         // property encryptionManager_
0:         // if needed this will later be initialized by NET calls to initializePublicKeyForEncryption()
0:         encryptionManager_ = null;
1: 
0:         // property: open_
0:         // this should already be true
1: 
0:         isolation_ = Configuration.defaultIsolation;
0:         autoCommit_ = true;
1:         inUnitOfWork_ = false;
1: 
0:         // property isXAConnection_
0:         // leave set to current value.  this will impact which connect reset flows are used.
1: 
0:         xaState_ = XA_OPEN_IDLE;
1: 
0:         this.agent_.resetAgent(this, logWriter, loginTimeout_, serverNameIP_, portNumber_);
1: 
1: 
1:     // For jdbc 1 connections
0:     protected Connection(LogWriter logWriter,
1:                          int driverManagerLoginTimeout,
1:                          String serverName,
1:                          int portNumber,
1:                          String databaseName,
0:                          java.util.Properties properties) throws SqlException {
1:         if (logWriter != null) {
1:             logWriter.traceConnectEntry(serverName, portNumber, databaseName, properties);
1:         }
0:         org.apache.derby.client.am.Configuration.checkForExceptionsFromLoadConfiguration(logWriter);
1: 
1:         databaseName_ = databaseName;
1: 
1:         // Extract common properties.
0:         user_ = ClientDataSource.getUser(properties);
0:         retrieveMessageText_ = ClientDataSource.getRetrieveMessageText(properties);
1: 
1:         loginTimeout_ = driverManagerLoginTimeout;
1:         serverNameIP_ = serverName;
1:         portNumber_ = portNumber;
1: 
1:         agent_ = newAgent_(logWriter,
1:                 loginTimeout_,
1:                 serverNameIP_,
0:                 portNumber_);
1:     // Users are advised to call the method close() on Statement and Connection objects when they are done with them.
1:     // However, some users will forget, and some code may get killed before it can close these objects.
1:     // Therefore, if JDBC drivers have state associated with JDBC objects that need to get
1:     // explicitly cleared up, they should provide finalize methods to take care of them.
1:     // The garbage collector will call these finalize methods when the objects are found to be garbage,
1:     // and this will give the driver a chance to close (or otherwise clean up) the objects.
1:     // Note, however, that there is no guarantee that the garbage collector will ever run.
1:     // If that is the case, the finalizers will not be called.
0:     protected void finalize() throws java.lang.Throwable {
1:         if (agent_.loggingEnabled()) {
1:             agent_.logWriter_.traceEntry(this, "finalize");
1:         }
1:         // finalize() differs from close() in that it will not throw an
1:         // exception if a transaction is in progress.
1:         // finalize() also differs from close() in that it will not drive
1:         // an auto-commit before disconnecting.
0:         //
1:         // If a transaction is in progress, a close() request will throw an SqlException.
1:         // However, if a connection with an incomplete transaction is finalized,
1:         // or is abruptly terminated by application exit,
1:         // the normal rollback semantics imposed by the DERBY server are adopted.
1:         // So we just pull the plug and let the server handle this default semantic.
1:         if (!open_) {
1:             return;
1:         }
1:         agent_.disconnectEvent();
1:         super.finalize();
1:     // ---------------------------jdbc 1------------------------------------------
0:     synchronized public java.sql.Statement createStatement() throws SqlException {
1:         if (agent_.loggingEnabled()) {
0:             agent_.logWriter_.traceEntry(this, "createStatement");
1:         }
0:         Statement s = createStatementX(java.sql.ResultSet.TYPE_FORWARD_ONLY, java.sql.ResultSet.CONCUR_READ_ONLY, resultSetHoldability_);
1:         if (agent_.loggingEnabled()) {
0:             agent_.logWriter_.traceExit(this, "createStatement", s);
1:         }
1:         return s;
1:     }
1: 
0:     synchronized public java.sql.PreparedStatement prepareStatement(String sql) throws SqlException {
1:         if (agent_.loggingEnabled()) {
0:             agent_.logWriter_.traceEntry(this, "prepareStatement", sql);
1:         }
0:         PreparedStatement ps = prepareStatementX(sql,
0:                 java.sql.ResultSet.TYPE_FORWARD_ONLY,
0:                 java.sql.ResultSet.CONCUR_READ_ONLY,
0:                 resultSetHoldability_,
0:                 java.sql.Statement.NO_GENERATED_KEYS,
0:                 null);
1:         if (agent_.loggingEnabled()) {
0:             agent_.logWriter_.traceExit(this, "prepareStatement", ps);
1:         }
1:         return ps;
1:     }
1: 
1:     // For internal use only.  Use by updatable result set code.
0:     synchronized public PreparedStatement preparePositionedUpdateStatement(String sql, Section querySection) throws SqlException {
1:         checkForClosedConnection();
1:         // create a net material prepared statement.
0:         PreparedStatement preparedStatement = newPositionedUpdatePreparedStatement_(sql, querySection);
1:         preparedStatement.flowPrepareDescribeInputOutput();
1:         // The positioned update statement is not added to the list of open statements,
1:         // because this would cause a java.util.ConcurrentModificationException when
1:         // iterating thru the list of open statements to call completeRollback().
1:         // An updatable result set is marked closed on a call to completeRollback(),
1:         // and would therefore need to close the positioned update statement associated with the result set which would cause
1:         // it to be removed from the open statements list. Resulting in concurrent modification
1:         // on the open statements list.
1:         // Notice that ordinary Statement.closeX() is never called on the positioned update statement,
1:         // rather markClosed() is called to avoid trying to remove the statement from the openStatements_ list.
1:         return preparedStatement;
1:     }
1: 
0:     synchronized public java.sql.CallableStatement prepareCall(String sql) throws SqlException {
1:         if (agent_.loggingEnabled()) {
0:             agent_.logWriter_.traceEntry(this, "prepareCall", sql);
1:         }
0:         CallableStatement cs = prepareCallX(sql, java.sql.ResultSet.TYPE_FORWARD_ONLY, java.sql.ResultSet.CONCUR_READ_ONLY, resultSetHoldability_);
1:         if (agent_.loggingEnabled()) {
0:             agent_.logWriter_.traceExit(this, "prepareCall", cs);
1:         }
1:         return cs;
1:     }
1: 
0:     synchronized PreparedStatement prepareDynamicCatalogQuery(String sql) throws SqlException {
0:         PreparedStatement ps = newPreparedStatement_(sql, java.sql.ResultSet.TYPE_FORWARD_ONLY, java.sql.ResultSet.CONCUR_READ_ONLY, resultSetHoldability_, java.sql.Statement.NO_GENERATED_KEYS, null);
1:         ps.isCatalogQuery_ = true;
1:         ps.prepare();
0:         openStatements_.add(ps);
1:         return ps;
1:     }
1: 
0:     public String nativeSQL(String sql) throws SqlException {
1:         if (agent_.loggingEnabled()) {
0:             agent_.logWriter_.traceEntry(this, "nativeSQL", sql);
1:         }
0:         String nativeSql = nativeSQLX(sql);
1:         if (agent_.loggingEnabled()) {
0:             agent_.logWriter_.traceExit(this, "nativeSQL", nativeSql);
1:         }
0:         return nativeSql;
1:     }
1: 
0:     synchronized public String nativeSQLX(String sql) throws SqlException {
1:         checkForClosedConnection();
1:         if (sql == null) {
0:             throw new SqlException(agent_.logWriter_, "Null SQL string passed.");
1:         }
1: 
1:         // Derby can handle the escape syntax directly so only needs escape
1:         // processing for { ? = CALL  ....}
1:         String trimSql = sql.trim();
1:         if (trimSql.startsWith("{")) {
1:             if (trimSql.lastIndexOf("}") >= 0) {
1:                 return trimSql.substring(1, trimSql.lastIndexOf("}"));
1:             }
1:         }
1: 
1:         return trimSql;
1:     }
1: 
1:     // Driver-specific determination if local COMMIT/ROLLBACK is allowed;
1:     // primary usage is distinction between local and global trans. envs.;
0:     protected abstract boolean disallowLocalCommitRollback_() throws org.apache.derby.client.am.SqlException;
1: 
0:     synchronized public void setAutoCommit(boolean autoCommit) throws SqlException {
1:         if (agent_.loggingEnabled()) {
0:             agent_.logWriter_.traceEntry(this, "setAutoCommit", autoCommit);
1:         }
1:         checkForClosedConnection();
1: 
0:         if (disallowLocalCommitRollback_()) {
0:             if (autoCommit) { // can't toggle to autocommit mode when between xars.start() and xars.end()
0:                 throw new SqlException(agent_.logWriter_,
0:                         "setAutoCommit(true) invalid during global transaction",
0:                         SqlState._2D521, // Spec'ed by PROTOCOL
0:                         SqlCode.invalidSetAutoCommitUnderXA);
1:             }
1:         } else {
0:             if (autoCommit == autoCommit_) {
0:                 return; // don't flow a commit if nothing changed.
1:             }
0:             if (inUnitOfWork_) {
0:                 flowCommit(); // we are not between xars.start() and xars.end(), can flow commit
1:             }
1:         }
0:         autoCommit_ = autoCommit;
1:     }
1: 
0:     public boolean getAutoCommit() throws SqlException {
1:         checkForClosedConnection();
1:         if (agent_.loggingEnabled()) {
0:             agent_.logWriter_.traceExit(this, "getAutoCommit", autoCommit_);
1:         }
0:         if (disallowLocalCommitRollback_()) { // autoCommit is always false between xars.start() and xars.end()
1:             return false;
1:         }
0:         return autoCommit_;
1:     }
1: 
0:     synchronized public void commit() throws SqlException {
1:         if (agent_.loggingEnabled()) {
0:             agent_.logWriter_.traceEntry(this, "commit");
1:         }
1: 
0:         // the following XA State check must be in commit instead of commitX since
0:         // external application call commit, the SqlException should be thrown
0:         // only if an external application calls commit during a Global Transaction,
0:         // internal code will call commitX which will ignore the commit request
0:         // while in a Global transaction
0:         checkForInvalidXAStateOnCommitOrRollback();
1:         checkForClosedConnection();
0:         flowCommit();
1:     }
1: 
1:     private void checkForInvalidXAStateOnCommitOrRollback() throws SqlException {
0:         if (disallowLocalCommitRollback_()) {
0:             throw new SqlException(agent_.logWriter_,
0:                     "COMMIT or ROLLBACK invalid for application execution environment",
0:                     SqlState._2D521, // Spec'ed by PROTOCOL
0:                     SqlCode.invalidCommitOrRollbackUnderXA);
1:         }
1:     }
1: 
0:     public void flowCommit() throws SqlException {
1:         // Per JDBC specification (see javadoc for Connection.commit()):
1:         //   "This method should be used only when auto-commit mode has been disabled."
1:         // However, some applications do this anyway, it is harmless, so
1:         // if they ask to commit, we could go ahead and flow a commit.
1:         // But note that rollback() is less harmless, rollback() shouldn't be used in auto-commit mode.
1:         // This behavior is subject to further review.
1: 
0:         //   if (!this.inUnitOfWork)
0:         //     return;
0:         // We won't try to be "too smart", if the user requests a commit, we'll flow a commit,
1:         // regardless of whether or not we're in a unit of work or in auto-commit mode.
0:         //
1:         if (isXAConnection_) {
1:             agent_.beginWriteChainOutsideUOW();
1:             writeCommit();
1:             agent_.flowOutsideUOW();
1:             readCommit(); // This will invoke the commitEvent() callback from the material layer.
1:             agent_.endReadChain();
1:         } else {
1:             agent_.beginWriteChain(null);
1:             writeCommit();
1:             agent_.flow(null);
1:             readCommit(); // This will invoke the commitEvent() callback from the material layer.
1:             agent_.endReadChain();
1:         }
1: 
1:     }
1: 
1:     // precondition: autoCommit_ is true
0:     public void flowAutoCommit() throws SqlException {
1:         if (willAutoCommitGenerateFlow()) {
0:             flowCommit();
1:         }
1:     }
1: 
0:     public boolean willAutoCommitGenerateFlow() throws org.apache.derby.client.am.SqlException {
1:         if (!autoCommit_) {
1:             return false;
1:         }
0:         if (disallowLocalCommitRollback_()) {
1:             return false;
1:         }
1:         return true;
1:     }
1: 
1:     // precondition: autoCommit_ is true
1:     void writeAutoCommit() throws SqlException {
1:         if (willAutoCommitGenerateFlow()) {
1:             writeCommit();
1:         }
1:     }
1: 
0:     public void writeCommit() throws SqlException {
1:         if (isXAConnection_) {
0:             if ((xaState_ == XA_LOCAL) ||
0:                     (xaState_ == XA_LOCAL_START_SENT)) {
0:                 writeLocalXACommit_();
1:             }
1:         } else {
1:             writeLocalCommit_();
1:         }
1:     }
1: 
1:     // precondition: autoCommit_ is true
1:     void readAutoCommit() throws SqlException {
1:         if (willAutoCommitGenerateFlow()) {
1:             readCommit();
1:         }
1:     }
1: 
0:     public void readCommit() throws SqlException {
1:         if (isXAConnection_) {
0:             if ((xaState_ == XA_LOCAL) ||
0:                     (xaState_ == XA_LOCAL_START_SENT)) {
0:                 readLocalXACommit_();
0:                 setXAState(XA_OPEN_IDLE);
1:             }
1:         } else {
1:             readLocalCommit_();
1:         }
1:     }
1: 
0:     synchronized public void rollback() throws SqlException {
1:         if (agent_.loggingEnabled()) {
0:             agent_.logWriter_.traceEntry(this, "rollback");
1:         }
0:         checkForInvalidXAStateOnCommitOrRollback();
1:         checkForClosedConnection();
0:         flowRollback();
1:     }
1: 
1:     // Even if we're not in a transaction, all open result sets will be closed.
1:     // So we could probably just return if we're not in a transaction
1:     // using the following code:
1:     //     if (!this.inUnitOfWork)
1:     //       return;
1:     // But we'll just play it safe, and blindly flow the rollback.
1:     // We won't try to be "too smart", if the user requests a rollback, we'll flow a rollback,
1:     // Per JDBC specification (see javadoc for Connection.rollback()):
1:     //   "This method should be used only when auto-commit mode has been disabled."
1:     // However, rather than trying to be too smart, we'll just flow the rollback anyway
1:     // before throwing an exception.
1:     // As a side-effect of invoking rollback() in auto-commit mode,
1:     // we'll close all open result sets on this connection in the rollbackEvent().
1:     protected void flowRollback() throws SqlException {
1:         if (isXAConnection_) {
1:             agent_.beginWriteChainOutsideUOW();
1:             writeRollback();
1:             agent_.flowOutsideUOW();
1:             readRollback(); // This method will invoke the rollbackEvent() callback from the material layer.
1:             agent_.endReadChain();
1:         } else {
1:             agent_.beginWriteChain(null);
1:             writeRollback();
1:             agent_.flow(null);
1:             readRollback(); // This method will invoke the rollbackEvent() callback from the material layer.
1:             agent_.endReadChain();
1:         }
0:     public void writeRollback() throws SqlException {
1:         if (isXAConnection_) {
0:             writeLocalXARollback_();
1:         } else {
1:             writeLocalRollback_();
1:         }
0:     public void readRollback() throws SqlException {
1:         if (isXAConnection_) {
1:             readLocalXARollback_();
0:             setXAState(XA_OPEN_IDLE);
1:         } else {
1:             readLocalRollback_();
1:         }
1:     }
0:     synchronized public void close() throws SqlException {
1:         if (agent_.loggingEnabled()) {
1:             agent_.logWriter_.traceEntry(this, "close");
1:         }
1:         closeX();
1:     }
1:     void checkForTransactionInProgress() throws SqlException {
1:         // The following precondition matches CLI semantics, see SQLDisconnect()
0:         if (!autoCommit_ && inUnitOfWork_ && !allowCloseInUOW_()) {
0:             throw new SqlException(agent_.logWriter_,
0:                     "java.sql.Connection.close() requested while a transaction is in progress on the connection." +
0:                     "The transaction remains active, and the connection cannot be closed.");
1:         }
1:     }
1:     // This is a no-op if the connection is already closed.
0:     synchronized public void closeX() throws SqlException {
1:         if (!open_) {
1:             return;
1:         }
1:         closeResourcesX();
1:     }
1:     // Close physical socket or attachment even if connection is marked close.
1:     // Used by ClientPooledConnection.close().
0:     synchronized public void closeResources() throws SqlException {
1:         if (open_ || (!open_ && availableForReuse_)) {
1:             availableForReuse_ = false;
1:             closeResourcesX();
1:         }
1:     }
0:     private void closeResourcesX() throws SqlException {
0:         checkForTransactionInProgress();
1:         resetConnectionAtFirstSql_ = false; // unset indicator of deferred reset
1:         SqlException accumulatedExceptions = null;
0:         if (setTransactionIsolationStmt != null) {
1:             try {
0:                 setTransactionIsolationStmt.close();
0:             } catch (SqlException se) {
0:                 accumulatedExceptions = se;
1:             }
1:         }
1:         try {
1:             flowClose();
1:         } catch (SqlException e) {
1:             accumulatedExceptions =
0:                     Utils.accumulateSQLException(e, accumulatedExceptions);
1:         }
0:         markClosed();
1:         try {
1:             agent_.close();
1:         } catch (SqlException e) {
0:             throw Utils.accumulateSQLException(e, accumulatedExceptions);
1:         }
1:     }
1:     protected abstract boolean isGlobalPending_();
1:     // Just like closeX except the socket is not pulled.
1:     // Physical resources are not closed.
0:     synchronized public void closeForReuse() throws SqlException {
1:         if (!open_) {
1:             return;
1:         }
0:         checkForTransactionInProgress();
1:         resetConnectionAtFirstSql_ = false; // unset indicator of deferred reset
1:         SqlException accumulatedExceptions = null;
1:         try {
1:             flowClose();
1:         } catch (SqlException e) {
1:             accumulatedExceptions = e;
1:         }
1:         if (open_) {
0:             markClosedForReuse();
1:         }
1:         if (accumulatedExceptions != null) {
1:             throw accumulatedExceptions;
1:         }
1:     }
1:     private void flowClose() throws SqlException {
1:         agent_.beginWriteChainOutsideUOW();
1:         if (doCloseStatementsOnClose_()) {
1:             writeCloseStatements();
1:         }
1:         if (autoCommit_) {
1:             writeAutoCommit();
1:         }
1:         agent_.flowOutsideUOW();
1:         if (doCloseStatementsOnClose_()) {
1:             readCloseStatements();
1:         }
1:         if (autoCommit_) {
1:             readAutoCommit();
1:         }
1:         agent_.endReadChain();
1:     }
1: 
1:     protected abstract void markClosed_();
1: 
0:     public void markClosed() // called by LogicalConnection.close()
0:     {
1:         open_ = false;
1:         inUnitOfWork_ = false;
1:         markStatementsClosed();
1:         CommitAndRollbackListeners_.clear();
0:         RollbackOnlyListeners_.clear();
1:         markClosed_();
1:     }
1: 
1: 
0:     private void markClosedForReuse() {
1:         availableForReuse_ = true;
0:         markClosed();
1:     }
1: 
1:     private void markStatementsClosed() {
0:         for (java.util.ListIterator i = openStatements_.listIterator(); i.hasNext();) {
0:             Statement stmt = (Statement) i.next();
1:             stmt.markClosed();
1:             i.remove();
1:         }
1:     }
1: 
1:     private void writeCloseStatements() throws SqlException {
0:         for (java.util.ListIterator i = openStatements_.listIterator(); i.hasNext();) {
0:             ((Statement) i.next()).writeClose(false);  // false means don't permit auto-commits
1:         }
1:     }
1: 
1:     private void readCloseStatements() throws SqlException {
0:         for (java.util.ListIterator i = openStatements_.listIterator(); i.hasNext();) {
0:             ((Statement) i.next()).readClose(false);  // false means don't permit auto-commits
1:         }
1:     }
1: 
1: 
1:     public boolean isClosed() {
1:         if (agent_.loggingEnabled()) {
1:             agent_.logWriter_.traceExit(this, "isClosed", !open_);
1:         }
1:         return !open_;
1:     }
1: 
1:     public boolean isClosedX() {
1:         return !open_;
1:     }
1: 
1:     private static String DERBY_TRANSACTION_REPEATABLE_READ = "RS";
1:     private static String DERBY_TRANSACTION_SERIALIZABLE = "RR";
1:     private static String DERBY_TRANSACTION_READ_COMMITTED = "CS";
1:     private static String DERBY_TRANSACTION_READ_UNCOMMITTED = "UR";
1: 
0:     synchronized public void setTransactionIsolation(int level) throws SqlException {
1:         if (agent_.loggingEnabled()) {
0:             agent_.logWriter_.traceEntry(this, "setTransactionIsolation", level);
1:         }
0:         // Per jdbc spec (see java.sql.Connection.close() javadoc).
1:         checkForClosedConnection();
1: 
0:         // Javadoc for this method:
0:         //   If this method is called during a transaction, the result is implementation-defined.
0:         //
0:         //
0:         // REPEATABLE_READ = JDBC: TRANSACTION_SERIALIZABLE, DERBY: RR, PROTOCOL: repeatable read
0:         // READ_STABILITY = JDBC: TRANSACTION_REPEATABLE_READ, DERBY: RS, PROTOCOL: All
0:         // CURSOR_STABILITY = JDBC: TRANSACTION_READ_COMMITTED, DERBY: CS, PROTOCOL: Cursor stability
0:         // UNCOMMITTED_READ = JDBC: TRANSACTION_READ_UNCOMMITTED, DERBY: UR , PROTOCOL: Change
0:         // NO_COMMIT = JDBC: TRANSACTION_NONE, DERBY: NC, PROTOCOL: No commit
0:         //
0:         String levelString = null;
0:         switch (level) {
0:         case java.sql.Connection.TRANSACTION_REPEATABLE_READ:
0:             levelString = DERBY_TRANSACTION_REPEATABLE_READ;
0:             break;
0:         case java.sql.Connection.TRANSACTION_READ_COMMITTED:
0:             levelString = DERBY_TRANSACTION_READ_COMMITTED;
0:             break;
0:         case java.sql.Connection.TRANSACTION_SERIALIZABLE:
0:             levelString = DERBY_TRANSACTION_SERIALIZABLE;
0:             break;
0:         case java.sql.Connection.TRANSACTION_READ_UNCOMMITTED:
0:             levelString = DERBY_TRANSACTION_READ_UNCOMMITTED;
0:             break;
0:             // Per javadoc:
0:             //   Note that Connection.TRANSACTION_NONE cannot be used because it specifies that transactions are not supported.
0:         case java.sql.Connection.TRANSACTION_NONE:
0:         default:
0:             throw new SqlException(agent_.logWriter_,
0:                     "Transaction isolation level " + level + " is an invalid argument for java.sql.Connection.setTransactionIsolation()." +
0:                     " See Javadoc specification for a list of valid arguments.", "XJ045");
1:         }
0:         if (setTransactionIsolationStmt == null) {
0:             setTransactionIsolationStmt =
0:                     createStatementX(java.sql.ResultSet.TYPE_FORWARD_ONLY,
0:                             java.sql.ResultSet.CONCUR_READ_ONLY,
0:                             resultSetHoldability_);
1:         }
0:         setTransactionIsolationStmt.executeUpdate("SET CURRENT ISOLATION = " + levelString);
1: 
0:         isolation_ = level;
1: 
1:     }
1: 
0:     public int getTransactionIsolation() throws SqlException {
1:         checkForClosedConnection();
1:         if (agent_.loggingEnabled()) {
0:             agent_.logWriter_.traceExit(this, "getTransactionIsolation", isolation_);
1:         }
0:         return isolation_;
1:     }
1: 
0:     public java.sql.SQLWarning getWarnings() {
1:         if (agent_.loggingEnabled()) {
1:             agent_.logWriter_.traceExit(this, "getWarnings", warnings_);
1:         }
0:         return warnings_;
1:     }
1: 
0:     synchronized public void clearWarnings() throws SqlException {
1:         if (agent_.loggingEnabled()) {
0:             agent_.logWriter_.traceEntry(this, "clearWarnings");
1:         }
1:         clearWarningsX();
1:     }
1: 
1:     // An untraced version of clearWarnings()
0:     public void clearWarningsX() throws SqlException {
1:         warnings_ = null;
1:         accumulated440ForMessageProcFailure_ = false;
1:         accumulated444ForMessageProcFailure_ = false;
0:         accumulatedSetReadOnlyWarning_ = false;
1:     }
1: 
1:     //======================================================================
1:     // Advanced features:
1: 
0:     public java.sql.DatabaseMetaData getMetaData() throws SqlException {
1:         checkForClosedConnection();
1:         if (agent_.loggingEnabled()) {
0:             agent_.logWriter_.traceExit(this, "getMetaData", databaseMetaData_);
1:         }
0:         return databaseMetaData_;
1:     }
1: 
0:     synchronized public void setReadOnly(boolean readOnly) throws SqlException {
0:         // This is a hint to the driver only, so this request is silently ignored.
0:         // PROTOCOL can only flow a set-read-only before the connection is established.
1:         if (agent_.loggingEnabled()) {
0:             agent_.logWriter_.traceEntry(this, "setReadOnly", readOnly);
1:         }
1:         checkForClosedConnection();
1:     }
1: 
0:     public boolean isReadOnly() throws SqlException {
1:         checkForClosedConnection();
1:         if (agent_.loggingEnabled()) {
0:             agent_.logWriter_.traceExit(this, "isReadOnly", jdbcReadOnly_);
1:         }
1:         return false;
1:     }
1: 
0:     synchronized public void setCatalog(String catalog) throws SqlException {
1:         if (agent_.loggingEnabled()) {
0:             agent_.logWriter_.traceEntry(this, "setCatalog", catalog);
1:         }
1:         checkForClosedConnection();
0:         // Per jdbc spec: if the driver does not support catalogs, it will silently ignore this request.
1:     }
1: 
0:     public String getCatalog() throws SqlException {
1:         checkForClosedConnection();
1:         if (agent_.loggingEnabled()) {
0:             agent_.logWriter_.traceExit(this, "getCatalog", (String) null);
1:         }
0:         return null;
1:     }
1: 
1:     //--------------------------JDBC 2.0-----------------------------
1: 
0:     synchronized public java.sql.Statement createStatement(int resultSetType,
0:                                                            int resultSetConcurrency) throws SqlException {
1:         if (agent_.loggingEnabled()) {
0:             agent_.logWriter_.traceEntry(this, "createStatement", resultSetType, resultSetConcurrency);
1:         }
0:         Statement s = createStatementX(resultSetType, resultSetConcurrency, resultSetHoldability_);
1:         if (agent_.loggingEnabled()) {
0:             agent_.logWriter_.traceExit(this, "createStatement", s);
1:         }
1:         return s;
1:     }
1: 
0:     synchronized public java.sql.PreparedStatement prepareStatement(String sql,
1:                                                                     int resultSetType,
0:                                                                     int resultSetConcurrency) throws SqlException {
1:         if (agent_.loggingEnabled()) {
0:             agent_.logWriter_.traceEntry(this, "prepareStatement", sql, resultSetType, resultSetConcurrency);
1:         }
0:         PreparedStatement ps = prepareStatementX(sql,
0:                 resultSetType,
0:                 resultSetConcurrency,
0:                 resultSetHoldability_,
0:                 java.sql.Statement.NO_GENERATED_KEYS,
0:                 null);
1:         if (agent_.loggingEnabled()) {
0:             agent_.logWriter_.traceExit(this, "prepareStatement", ps);
1:         }
1:         return ps;
1:     }
1: 
0:     synchronized public java.sql.CallableStatement prepareCall(String sql,
1:                                                                int resultSetType,
0:                                                                int resultSetConcurrency) throws SqlException {
1:         if (agent_.loggingEnabled()) {
0:             agent_.logWriter_.traceEntry(this, "prepareCall", sql, resultSetType, resultSetConcurrency);
1:         }
0:         CallableStatement cs = prepareCallX(sql, resultSetType, resultSetConcurrency, resultSetHoldability_);
1:         if (agent_.loggingEnabled()) {
0:             agent_.logWriter_.traceExit(this, "prepareCall", cs);
1:         }
1:         return cs;
1:     }
1: 
0:     synchronized public CallableStatement prepareMessageProc(String sql) throws SqlException {
1:         checkForClosedConnection();
1: 
0:         CallableStatement cs = prepareCallX(sql, java.sql.ResultSet.TYPE_FORWARD_ONLY, java.sql.ResultSet.CONCUR_READ_ONLY, resultSetHoldability_);
1:         return cs;
1:     }
1: 
1:     // Per jdbc spec, when a result set type is unsupported, we downgrade and
1:     // issue a warning rather than to throw an exception.
1:     private int downgradeResultSetType(int resultSetType) {
0:         if (resultSetType == java.sql.ResultSet.TYPE_SCROLL_SENSITIVE) {
0:             accumulateWarning(new SqlWarning(agent_.logWriter_, "Scroll sensitive result sets are not supported by server; remapping to forward-only cursor"));
0:             return java.sql.ResultSet.TYPE_SCROLL_INSENSITIVE;
1:         }
1:         return resultSetType;
1:     }
1: 
0:     // Per jdbc spec, when a result set concurrency is unsupported, we downgrade and
1:     // issue a warning rather than to throw an exception.
0:     private int downgradeResultSetConcurrency(int resultSetConcurrency, int resultSetType) {
0:         if (resultSetConcurrency == java.sql.ResultSet.CONCUR_UPDATABLE &&
0:                 resultSetType == java.sql.ResultSet.TYPE_SCROLL_INSENSITIVE) {
0:             accumulateWarning(new SqlWarning(agent_.logWriter_, "Insensitive updatable result sets are not supported by server; remapping to insensitive read-only cursor"));
0:             return java.sql.ResultSet.CONCUR_READ_ONLY;
1:         }
0:         return resultSetConcurrency;
1:     }
1: 
0:     public java.util.Map getTypeMap() throws SqlException {
1:         if (agent_.loggingEnabled()) {
0:             agent_.logWriter_.traceEntry(this, "getTypeMap");
1:         }
1:         checkForClosedConnection();
0:         java.util.Map map = new java.util.HashMap();
1:         if (agent_.loggingEnabled()) {
0:             agent_.logWriter_.traceExit(this, "getTypeMap", map);
1:         }
0:         return map;
1:     }
1: 
0:     synchronized public void setTypeMap(java.util.Map map) throws SqlException {
1:         if (agent_.loggingEnabled()) {
0:             agent_.logWriter_.traceEntry(this, "setTypeMap", map);
1:         }
1:         checkForClosedConnection();
0:         throw new SqlException(agent_.logWriter_, "Connection.setTypeMap is not supported");
1:     }
1: 
1:     //--------------------------JDBC 3.0-----------------------------
1: 
0:     synchronized public void setHoldability(int holdability) throws SqlException {
1:         if (agent_.loggingEnabled()) {
0:             agent_.logWriter_.traceEntry(this, "setHoldability", holdability);
1:         }
1:         checkForClosedConnection();
0:         resultSetHoldability_ = holdability;
1:     }
1: 
0:     public int getHoldability() throws SqlException {
1:         checkForClosedConnection();
1:         if (agent_.loggingEnabled()) {
0:             agent_.logWriter_.traceExit(this, "getHoldability", resultSetHoldability_);
1:         }
0:         return resultSetHoldability_;
1:     }
1: 
0:     public int dncGeneratedSavepointId_;
1:     // generated name used internally for unnamed savepoints
0:     public static final String dncGeneratedSavepointNamePrefix__ = "DNC_GENENERATED_NAME_";
1: 
0:     synchronized public java.sql.Savepoint setSavepoint() throws SqlException {
1:         if (agent_.loggingEnabled()) {
0:             agent_.logWriter_.traceEntry(this, "setSavepoint");
1:         }
1:         checkForClosedConnection();
0:         if (autoCommit_) // Throw exception if auto-commit is on
0:         {
0:             throw new SqlException(agent_.logWriter_, "Cannot set savepoint when in auto-commit mode.");
0:         } else if (xaState_ == XA_PENDING_START ||
0:                 xaState_ == XA_ACTIVE) // Throw exception if in distributed transaction
0:         {
0:             throw new SqlException(agent_.logWriter_, "Cannot set savepoint during distributed transaction.");
1:         }
0:         // create an un-named savepoint.
0:         if ((++dncGeneratedSavepointId_) < 0) {
0:             dncGeneratedSavepointId_ = 1; // restart from 1 when overflow.
1:         }
0:         Object s = setSavepointX(new Savepoint(agent_, dncGeneratedSavepointId_));
0:         return (java.sql.Savepoint) s;
1:     }
1: 
0:     synchronized public java.sql.Savepoint setSavepoint(String name) throws SqlException {
1:         if (agent_.loggingEnabled()) {
0:             agent_.logWriter_.traceEntry(this, "setSavepoint", name);
1:         }
1:         checkForClosedConnection();
0:         if (name == null) // Throw exception if savepoint name is null
0:         {
0:             throw new SqlException(agent_.logWriter_, "Named savepoint needs a none-null name.");
0:         } else if (autoCommit_) // Throw exception if auto-commit is on
0:         {
0:             throw new SqlException(agent_.logWriter_, "Cannot set savepoint when in auto-commit mode.");
0:         } else if (xaState_ == XA_PENDING_START ||
0:                 xaState_ == XA_ACTIVE) // Throw exception if in distributed transaction
0:         {
0:             throw new SqlException(agent_.logWriter_, "Cannot set savepoint during distributed transaction.");
1:         }
0:         // create a named savepoint.
0:         Object s = setSavepointX(new Savepoint(agent_, name));
0:         return (java.sql.Savepoint) s;
1:     }
1: 
0:     private Savepoint setSavepointX(Savepoint savepoint) throws SqlException {
1:         // Construct and flow a savepoint statement to server.
0:         Statement stmt = null;
1:         try {
0:             stmt = (Statement) createStatementX(java.sql.ResultSet.TYPE_FORWARD_ONLY,
0:                     java.sql.ResultSet.CONCUR_READ_ONLY,
0:                     resultSetHoldability_);
1:             String savepointName;
1:             try {
1:                 savepointName = savepoint.getSavepointName();
1:             } catch (SqlException e) {
1:                 // generate the name for an un-named savepoint.
1:                 savepointName = dncGeneratedSavepointNamePrefix__ +
1:             }
0:             String sql = "SAVEPOINT \"" + savepointName + "\" ON ROLLBACK RETAIN CURSORS";
0:             stmt.executeX(sql);
1:         } finally {
1:             if (stmt != null) {
1:                 try {
1:                     stmt.closeX();
1:                 } catch (SqlException doNothing) {
1:                 }
1:             }
1:         }
1: 
1:         return savepoint;
0:     synchronized public void rollback(java.sql.Savepoint savepoint) throws SqlException {
0:         int saveXaState = xaState_;
1:         if (agent_.loggingEnabled()) {
0:             agent_.logWriter_.traceEntry(this, "rollback", savepoint);
1:         }
1:         checkForClosedConnection();
0:         if (savepoint == null) // Throw exception if savepoint is null
0:         {
0:             throw new SqlException(agent_.logWriter_, "Cannot rollback to a null savepoint.");
0:         } else if (autoCommit_) // Throw exception if auto-commit is on
0:         {
0:             throw new SqlException(agent_.logWriter_, "Cannot rollback to a savepoint when in auto-commit mode.");
0:         } else if (xaState_ == XA_PENDING_START ||
0:                 xaState_ == XA_ACTIVE) // Throw exception if in distributed transaction
0:         {
0:             throw new SqlException(agent_.logWriter_, "Cannot rollback to a savepoint during distributed transaction.");
1:         }
0:         // Only allow to rollback to a savepoint from the connection that create the savepoint.
1:         try {
0:             if (this != ((Savepoint) savepoint).agent_.connection_) {
0:                 throw new SqlException(agent_.logWriter_,
0:                         "Rollback to a savepoint not created by this connection.");
1:             }
0:         } catch (java.lang.ClassCastException e) { // savepoint is not an instance of am.Savepoint
0:             throw new SqlException(agent_.logWriter_,
0:                     "Rollback to a savepoint not created by this connection.");
1:         }
0:         // Construct and flow a savepoint rollback statement to server.
0:         Statement stmt = null;
1:         try {
0:             stmt = createStatementX(java.sql.ResultSet.TYPE_FORWARD_ONLY,
0:                     java.sql.ResultSet.CONCUR_READ_ONLY,
0:                     resultSetHoldability_);
1:             String savepointName;
1:             try {
0:                 savepointName = ((Savepoint) savepoint).getSavepointName();
1:             } catch (SqlException e) {
1:                 // generate the name for an un-named savepoint.
1:                 savepointName = dncGeneratedSavepointNamePrefix__ +
1:             }
0:             String sql = "ROLLBACK TO SAVEPOINT \"" + savepointName + "\"";
0:             stmt.executeX(sql);
1:         } finally {
1:             if (stmt != null) {
1:                 try {
1:                     stmt.closeX();
1:                 } catch (SqlException doNothing) {
1:                 }
1:             }
0:             xaState_ = saveXaState;
1:         }
0:     synchronized public void releaseSavepoint(java.sql.Savepoint savepoint) throws SqlException {
0:         int saveXaState = xaState_;
1:         if (agent_.loggingEnabled()) {
0:             agent_.logWriter_.traceEntry(this, "releaseSavepoint", savepoint);
1:         }
1:         checkForClosedConnection();
0:         if (savepoint == null) // Throw exception if savepoint is null
0:         {
0:             throw new SqlException(agent_.logWriter_, "Cannot release a null savepoint.");
0:         } else if (autoCommit_) // Throw exception if auto-commit is on
0:         {
0:             throw new SqlException(agent_.logWriter_, "Cannot release a savepoint when in auto-commit mode.");
0:         } else if (xaState_ == XA_PENDING_START ||
0:                 xaState_ == XA_ACTIVE) // Throw exception if in distributed transaction
0:         {
0:             throw new SqlException(agent_.logWriter_, "Cannot release a savepoint during distributed transaction.");
1:         }
0:         // Only allow to release a savepoint from the connection that create the savepoint.
1:         try {
0:             if (this != ((Savepoint) savepoint).agent_.connection_) {
0:                 throw new SqlException(agent_.logWriter_,
0:                         "Cannot release a savepoint that was not created by this connection.");
1:             }
0:         } catch (java.lang.ClassCastException e) { // savepoint is not an instance of am.Savepoint
0:             throw new SqlException(agent_.logWriter_,
0:                     "Cannot release a savepoint that was not created by this connection.");
1:         }
1: 
0:         // Construct and flow a savepoint release statement to server.
0:         Statement stmt = null;
1:         try {
0:             stmt = (Statement) createStatementX(java.sql.ResultSet.TYPE_FORWARD_ONLY,
0:                     java.sql.ResultSet.CONCUR_READ_ONLY,
0:                     resultSetHoldability_);
1:             String savepointName;
1:             try {
0:                 savepointName = ((Savepoint) savepoint).getSavepointName();
1:             } catch (SqlException e) {
1:                 // generate the name for an un-named savepoint.
1:                 savepointName = dncGeneratedSavepointNamePrefix__ +
1:             }
0:             String sql = "RELEASE SAVEPOINT \"" + savepointName + "\"";
0:             stmt.executeX(sql);
1:         } finally {
1:             if (stmt != null) {
1:                 try {
1:                     stmt.closeX();
1:                 } catch (SqlException doNothing) {
1:                 }
1:             }
0:             xaState_ = saveXaState;
1:         }
1: 
0:     synchronized public java.sql.Statement createStatement(int resultSetType,
1:                                                            int resultSetConcurrency,
1:                                                            int resultSetHoldability) throws SqlException {
1:         if (agent_.loggingEnabled()) {
0:             agent_.logWriter_.traceEntry(this, "createStatement", resultSetType, resultSetConcurrency, resultSetHoldability);
1:         }
0:         Statement s = createStatementX(resultSetType, resultSetConcurrency, resultSetHoldability);
1:         if (agent_.loggingEnabled()) {
0:             agent_.logWriter_.traceExit(this, "createStatement", s);
1:         }
1:         return s;
0:     private Statement createStatementX(int resultSetType,
1:                                        int resultSetConcurrency,
1:                                        int resultSetHoldability) throws SqlException {
1:         checkForClosedConnection();
1:         resultSetType = downgradeResultSetType(resultSetType);
0:         resultSetConcurrency = downgradeResultSetConcurrency(resultSetConcurrency, resultSetType);
0:         Statement s = newStatement_(resultSetType, resultSetConcurrency, resultSetHoldability);
1:         s.cursorAttributesToSendOnPrepare_ = s.cacheCursorAttributesToSendOnPrepare();
0:         openStatements_.add(s);
1:         return s;
1:     }
1:     // not sure if holding on to cursorAttributesToSendOnPrepare and restoring it is the
1:     // right thing to do here... because if property on the dataSource changes, we may have
1:     // to send different attributes, i.e. SENSITIVE DYNAMIC, instead of SENSITIVE STATIC.
0:     protected void resetStatement(Statement s) throws SqlException {
1:         String cursorAttributesToSendOnPrepare = s.cursorAttributesToSendOnPrepare_;
1:         resetStatement_(s, s.resultSetType_, s.resultSetConcurrency_, s.resultSetHoldability_);
1:         s.cursorAttributesToSendOnPrepare_ = cursorAttributesToSendOnPrepare;
1:     }
0:     synchronized public java.sql.PreparedStatement prepareStatement(String sql,
1:                                                                     int resultSetType,
1:                                                                     int resultSetConcurrency,
1:                                                                     int resultSetHoldability) throws SqlException {
1:         if (agent_.loggingEnabled()) {
0:             agent_.logWriter_.traceEntry(this, "prepareStatement", sql, resultSetType, resultSetConcurrency, resultSetHoldability);
1:         }
0:         PreparedStatement ps = prepareStatementX(sql,
0:                 resultSetType,
0:                 resultSetConcurrency,
0:                 resultSetHoldability,
0:                 java.sql.Statement.NO_GENERATED_KEYS,
0:                 null);
1:         if (agent_.loggingEnabled()) {
0:             agent_.logWriter_.traceExit(this, "prepareStatement", ps);
1:         }
1:         return ps;
1:     }
1:     // used by DBMD
0:     PreparedStatement prepareStatementX(String sql,
1:                                         int resultSetType,
1:                                         int resultSetConcurrency,
1:                                         int resultSetHoldability,
1:                                         int autoGeneratedKeys,
0:                                         String[] columnNames) throws SqlException {
1:         checkForClosedConnection();
0:         checkAutoGeneratedKeysParameters(autoGeneratedKeys, columnNames);
1:         resultSetType = downgradeResultSetType(resultSetType);
0:         resultSetConcurrency = downgradeResultSetConcurrency(resultSetConcurrency, resultSetType);
0:         PreparedStatement ps = newPreparedStatement_(sql, resultSetType, resultSetConcurrency, resultSetHoldability, autoGeneratedKeys, columnNames);
1:         ps.cursorAttributesToSendOnPrepare_ = ps.cacheCursorAttributesToSendOnPrepare();
1:         ps.prepare();
0:         openStatements_.add(ps);
1:         return ps;
1:     }
1:     // not sure if holding on to cursorAttributesToSendOnPrepare and restoring it is the
1:     // right thing to do here... because if property on the dataSource changes, we may have
1:     // to send different attributes, i.e. SENSITIVE DYNAMIC, instead of SENSITIVE STATIC.
0:     protected void resetPrepareStatement(PreparedStatement ps) throws SqlException {
1:         String cursorAttributesToSendOnPrepare = ps.cursorAttributesToSendOnPrepare_;
0:         resetPreparedStatement_(ps, ps.sql_, ps.resultSetType_, ps.resultSetConcurrency_, ps.resultSetHoldability_, ps.autoGeneratedKeys_, ps.generatedKeysColumnNames_);
1:         ps.cursorAttributesToSendOnPrepare_ = cursorAttributesToSendOnPrepare;
1:         ps.prepare();
1:     }
0:     synchronized public java.sql.CallableStatement prepareCall(String sql,
1:                                                                int resultSetType,
1:                                                                int resultSetConcurrency,
1:                                                                int resultSetHoldability) throws SqlException {
1:         if (agent_.loggingEnabled()) {
0:             agent_.logWriter_.traceEntry(this, "prepareCall", sql, resultSetType, resultSetConcurrency, resultSetHoldability);
1:         }
0:         CallableStatement cs = prepareCallX(sql, resultSetType, resultSetConcurrency, resultSetHoldability);
1:         if (agent_.loggingEnabled()) {
0:             agent_.logWriter_.traceExit(this, "prepareCall", cs);
1:         }
1:         return cs;
1:     }
0:     private CallableStatement prepareCallX(String sql,
1:                                            int resultSetType,
1:                                            int resultSetConcurrency,
1:                                            int resultSetHoldability) throws SqlException {
1:         checkForClosedConnection();
1:         resultSetType = downgradeResultSetType(resultSetType);
0:         resultSetConcurrency = downgradeResultSetConcurrency(resultSetConcurrency, resultSetType);
0:         CallableStatement cs = newCallableStatement_(sql, resultSetType, resultSetConcurrency, resultSetHoldability);
1:         cs.cursorAttributesToSendOnPrepare_ = cs.cacheCursorAttributesToSendOnPrepare();
1:         cs.prepare();
0:         openStatements_.add(cs);
1:         return cs;
1:     }
0:     protected void resetPrepareCall(CallableStatement cs) throws SqlException {
1:         String cursorAttributesToSendOnPrepare = cs.cursorAttributesToSendOnPrepare_;
1:         resetCallableStatement_(cs, cs.sql_, cs.resultSetType_, cs.resultSetConcurrency_, cs.resultSetHoldability_);
1:         cs.cursorAttributesToSendOnPrepare_ = cursorAttributesToSendOnPrepare;
1:         cs.prepare();
1:     }
0:     public java.sql.PreparedStatement prepareStatement(String sql, int autoGeneratedKeys) throws SqlException {
1:         if (agent_.loggingEnabled()) {
0:             agent_.logWriter_.traceEntry(this, "prepareStatement", sql, autoGeneratedKeys);
1:         }
0:         PreparedStatement ps = prepareStatementX(sql,
0:                 java.sql.ResultSet.TYPE_FORWARD_ONLY,
0:                 java.sql.ResultSet.CONCUR_READ_ONLY,
0:                 resultSetHoldability_,
0:                 autoGeneratedKeys,
0:                 null);
1:         if (agent_.loggingEnabled()) {
0:             agent_.logWriter_.traceExit(this, "prepareStatement", ps);
1:         }
1:         return ps;
1:     }
0:     public java.sql.PreparedStatement prepareStatement(String sql, int columnIndexes[]) throws SqlException {
1:         if (agent_.loggingEnabled()) {
0:             agent_.logWriter_.traceEntry(this, "prepareStatement", sql, columnIndexes);
1:         }
1:         checkForClosedConnection();
0:         throw new SqlException(agent_.logWriter_, "Driver not capable");
1:     }
0:     public java.sql.PreparedStatement prepareStatement(String sql, String columnNames[]) throws SqlException {
1:         if (agent_.loggingEnabled()) {
0:             agent_.logWriter_.traceEntry(this, "prepareStatement", sql, columnNames);
1:         }
0:         PreparedStatement ps = prepareStatementX(sql,
0:                 java.sql.ResultSet.TYPE_FORWARD_ONLY,
0:                 java.sql.ResultSet.CONCUR_READ_ONLY,
0:                 resultSetHoldability_,
0:                 java.sql.Statement.RETURN_GENERATED_KEYS,
0:                 columnNames);
1:         if (agent_.loggingEnabled()) {
0:             agent_.logWriter_.traceExit(this, "prepareStatement", ps);
1:         }
1:         return ps;
1:     // ---------------------------------------------------------------------------
1:     protected abstract boolean allowCloseInUOW_();
1:     protected abstract boolean doCloseStatementsOnClose_();
0:     public abstract SectionManager newSectionManager(String collection,
0:                                                      Agent agent,
0:                                                      String databaseName);
1:     //--------------------Abstract material factory methods-----------------
1: 
0:     protected abstract Agent newAgent_(LogWriter logWriter, int loginTimeout, String serverName, int portNumber) throws SqlException;
0:     protected abstract DatabaseMetaData newDatabaseMetaData_();
1: 
0:     protected abstract Statement newStatement_(int type,
1:                                                int concurrency,
1:                                                int holdability) throws SqlException;
1: 
0:     protected abstract void resetStatement_(Statement statement,
1:                                             int type,
1:                                             int concurrency,
1:                                             int holdability) throws SqlException;
0:     protected abstract PreparedStatement newPositionedUpdatePreparedStatement_(String sql, Section section) throws SqlException;
0:     protected abstract PreparedStatement newPreparedStatement_(String sql,
1:                                                                int type,
1:                                                                int concurrency,
1:                                                                int holdability,
1:                                                                int autoGeneratedKeys,
0:                                                                String[] columnNames) throws SqlException;
0:     protected abstract void resetPreparedStatement_(PreparedStatement ps,
1:                                                     String sql,
1:                                                     int resultSetType,
1:                                                     int resultSetConcurrency,
1:                                                     int resultSetHoldability,
1:                                                     int autoGeneratedKeys,
0:                                                     String[] columnNames) throws SqlException;
0:     protected abstract CallableStatement newCallableStatement_(String sql,
1:                                                                int type,
1:                                                                int concurrency,
1:                                                                int holdability) throws SqlException;
0:     protected abstract void resetCallableStatement_(CallableStatement cs,
1:                                                     String sql,
1:                                                     int resultSetType,
1:                                                     int resultSetConcurrency,
1:                                                     int resultSetHoldability) throws SqlException;
1: 
1:     // ----------------------- abstract box car and callback methods ---------------------
1:     // All callbacks must be client-side only operations.
0:     public void completeConnect() throws SqlException {
1:         open_ = true;
1:         databaseMetaData_ = newDatabaseMetaData_();
1:         agent_.sectionManager_ =
0:                 newSectionManager("NULLID",
0:                         agent_,
0:                         databaseName_);
1:         if (agent_.loggingEnabled()) {
1:             agent_.logWriter_.traceConnectExit(this);
1:         }
1:     public abstract void writeCommitSubstitute_() throws SqlException;
1: 
1:     public abstract void readCommitSubstitute_() throws SqlException;
1: 
1:     public abstract void writeLocalXAStart_() throws SqlException;
1: 
1:     public abstract void readLocalXAStart_() throws SqlException;
1: 
1:     public abstract void writeLocalXACommit_() throws SqlException;
1: 
0:     public abstract void readLocalXACommit_() throws SqlException;
1: 
1:     public abstract void writeLocalCommit_() throws SqlException;
1: 
1:     public abstract void readLocalCommit_() throws SqlException;
1: 
1:     public void completeLocalCommit() {
0:         for (java.util.Iterator i = CommitAndRollbackListeners_.iterator(); i.hasNext();) {
0:             UnitOfWorkListener listener = (UnitOfWorkListener) i.next();
0:             listener.completeLocalCommit(i);
1:         }
1:         inUnitOfWork_ = false;
1: 
1:     public abstract void writeLocalRollback_() throws SqlException;
1: 
1:     public abstract void readLocalRollback_() throws SqlException;
1: 
1:     // A callback for certain non-fatal exceptions that occur when parsing error replies.
1:     // This is a client-side only operation.
1:     // This method will only throw an exception on bug check.
1:     public void completeLocalRollback() {
0:         for (java.util.Iterator i = CommitAndRollbackListeners_.iterator(); i.hasNext();) {
0:             UnitOfWorkListener listener = (UnitOfWorkListener) i.next();
0:             listener.completeLocalRollback(i);
1:         }
0:         for (java.util.Iterator i = RollbackOnlyListeners_.iterator(); i.hasNext();) {
0:             UnitOfWorkListener listener = (UnitOfWorkListener) i.next();
0:             listener.completeLocalRollback(i);
1:         }
1:         inUnitOfWork_ = false;
1:     public abstract void writeLocalXARollback_() throws SqlException;
1:     public abstract void readLocalXARollback_() throws SqlException;
0:     public void writeTransactionStart(Statement statement) throws SqlException {
1: 
1:     public void readTransactionStart() throws SqlException {
1:         completeTransactionStart();
1: 
1:     void completeTransactionStart() {
1:         inUnitOfWork_ = true;
1:     // Occurs autonomously
1:     public void completeAbnormalUnitOfWork() {
1:         completeLocalRollback();
1: 
1:     // Called by Connection.close(), NetConnection.errorRollbackDisconnect().
1:     // The Agent's client-side resources associated with database connection are reclaimed (eg. socket).
1:     // And this connection and all associated statements and result sets are marked closed.
1:     // This is a client-side only operation.
1:     // This method will only throw an exception if the agent cannot be closed.
1:     public void completeChainBreakingDisconnect() {
1:         open_ = false;
1:         completeLocalRollback();
1:         markStatementsClosed();
1: 
1:     public void completeSqlca(Sqlca sqlca) {
1:         if (sqlca == null) {
1:         } else if (sqlca.getSqlCode() > 0) {
1:             accumulateWarning(new SqlWarning(agent_.logWriter_, sqlca));
1:         } else if (sqlca.getSqlCode() < 0) {
1:             agent_.accumulateReadException(new SqlException(agent_.logWriter_, sqlca));
1:         }
0:     public abstract void addSpecialRegisters(String s);
1:     // can this only be called by the PooledConnection
1:     // can this be called on a closed connection
1:     // can this be called in a unit of work
1:     // can this be called from within a stored procedure
0:     //
0:     synchronized public void reset(LogWriter logWriter, String user, String password, ClientDataSource ds, boolean recomputeFromDataSource) throws SqlException {
1:         if (logWriter != null) {
0:             logWriter.traceConnectResetEntry(this, logWriter, user, (ds != null) ? ds : dataSource_);
1:         }
1:         try {
0:             reset_(logWriter, user, password, ds, recomputeFromDataSource);
1:         } catch (SqlException sqle) {
0:             DisconnectException de = new DisconnectException(agent_, "An error occurred during connect reset and the connection has been terminated.  See chained exceptions for details.");
1:             de.setNextException(sqle);
1:             throw de;
1:         }
1:     }
0:     synchronized public void reset(LogWriter logWriter, ClientDataSource ds, boolean recomputeFromDataSource) throws SqlException {
1:         if (logWriter != null) {
0:             logWriter.traceConnectResetEntry(this, logWriter, null, (ds != null) ? ds : dataSource_);
1:         }
1:         try {
0:             reset_(logWriter, ds, recomputeFromDataSource);
1:         } catch (SqlException sqle) {
0:             DisconnectException de = new DisconnectException(agent_, "An error occurred during connect reset and the connection has been terminated.  See chained exceptions for details.");
1:             de.setNextException(sqle);
1:             throw de;
1:         }
1:     }
1:     synchronized public void lightReset() throws SqlException {
1:         if (!open_ && !availableForReuse_) {
1:             return;
1:         }
1:         open_ = true;
1:         availableForReuse_ = false;
1:     }
0:     abstract protected void reset_(LogWriter logWriter, String user, String password, ClientDataSource ds, boolean recomputerFromDataSource) throws SqlException;
1: 
0:     abstract protected void reset_(LogWriter logWriter, ClientDataSource ds, boolean recomputerFromDataSource) throws SqlException;
1: 
0:     protected void completeReset(boolean isDeferredReset, boolean recomputeFromDataSource) throws SqlException {
1:         open_ = true;
1: 
1:         completeLocalRollback(); // this will close the cursors if the physical connection hadn't been closed for reuse properly
1: 
1:         // Reopen physical statement resources associated with previous uses of this physical connection.
1:         // Notice that these physical statements may not belong to this logical connection.
1:         // Iterate through the physical statements and re-enable them for reuse.
1: 
0:         for (java.util.Iterator i = openStatements_.iterator(); i.hasNext();) {
0:             Object o = i.next();
0:             ((Statement) o).reset(recomputeFromDataSource);
1: 
1:         }
1: 
1:         if (!isDeferredReset && agent_.loggingEnabled()) {
1:             agent_.logWriter_.traceConnectResetExit(this);
1:         }
1:     }
1: 
1: 
1:     //-------------------------------helper methods-------------------------------
1: 
1:     protected void checkForClosedConnection() throws SqlException {
1:         if (!open_) {
1:             agent_.checkForDeferredExceptions();
0:             throw new SqlException(agent_.logWriter_, "invalid operation: connection closed");
1:         } else {
1:             agent_.checkForDeferredExceptions();
1:         }
1:     }
1: 
0:     void checkAutoGeneratedKeysParameters(int autoGeneratedKeys, String[] columnNames) throws SqlException {
0:         if (autoGeneratedKeys != java.sql.Statement.NO_GENERATED_KEYS &&
0:                 autoGeneratedKeys != java.sql.Statement.RETURN_GENERATED_KEYS) {
0:             throw new SqlException(agent_.logWriter_, "Invalid argument: " +
0:                     "Statement auto-generated keys value " + autoGeneratedKeys +
0:                     " is invalid.");
1:         }
1: 
0:         if (columnNames != null) {
0:             throw new SqlException(agent_.logWriter_, "Driver not capable");
1:         }
1:     public boolean isXAConnection() {
1:         return isXAConnection_;
1: 
1:     public int getXAState() {
1:         return xaState_;
1:     public void setXAState(int state) {
1:         xaState_ = state;
1:     }
0:     public void accumulateWarning(SqlWarning e) {
1:         if (warnings_ == null) {
1:             warnings_ = e;
1:         } else {
1:             warnings_.setNextException(e);
1:         }
1:     }
0:     public void accumulate440WarningForMessageProcFailure(SqlWarning e) {
1:         if (!accumulated440ForMessageProcFailure_) {
1:             accumulateWarning(e);
1:             accumulated440ForMessageProcFailure_ = true;
1:         }
1:     }
0:     public void accumulate444WarningForMessageProcFailure(SqlWarning e) {
1:         if (!accumulated444ForMessageProcFailure_) {
1:             accumulateWarning(e);
1:             accumulated444ForMessageProcFailure_ = true;
1:         }
1:     }
1:     // get the server version
1:     public int getServerVersion() {
1:         return databaseMetaData_.productLevel_.versionLevel_;
1:     }
0:     public void setInUnitOfWork(boolean inUnitOfWork) {
0:         inUnitOfWork_ = inUnitOfWork;
1:     }
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:33776ff
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derby.client.am.Connection
1: 
0:    Copyright (c) 2001, 2005 The Apache Software Foundation or its licensors, where applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1: */
1: 
1: package org.apache.derby.client.am;
1: 
0: import org.apache.derby.jdbc.ClientDataSource;
0: import org.apache.derby.client.am.Section;
1: 
0: public abstract class Connection implements java.sql.Connection,
0:                                             ConnectionCallbackInterface
0: {
0:   //---------------------navigational members-----------------------------------
1: 
1: 
0:   public Agent agent_; 
1: 
0:   public DatabaseMetaData databaseMetaData_;
0:   // Since DERBY prepared statements must be re-prepared after a commit,
0:   // then we must traverse this list after a commit and notify statements
0:   // that they are now in an un-prepared state.
0:   final java.util.LinkedList openStatements_ = new java.util.LinkedList();
1: 
0:   // Some statuses of DERBY objects may be invalid on server either after only rollback
0:   // or after both commit and rollback. For example,
0:   // (1) prepared statements need to be re-prepared
0:   //     after both commit and rollback
0:   // (2) result set will be unpositioned on server after both commit and rollback.
0:   // If they only depend on rollback, they need to get on RollbackOnlyListeners_.
0:   // If they depend on both commit and rollback, they need to get on CommitAndRollbackListeners_.
0:   final java.util.LinkedList RollbackOnlyListeners_ = new java.util.LinkedList();
0:   final java.util.LinkedList CommitAndRollbackListeners_ = new java.util.LinkedList();
0:   private SqlWarning warnings_ = null;
1: 
0:   // ------------------------properties set for life of connection--------------
1: 
0:   // See ClientDataSource pre-connect settings
0:   public transient String user_;
0:   public boolean retrieveMessageText_;
0:   protected boolean jdbcReadOnly_;
0:   public int resultSetHoldability_;
0:   public String databaseName_;
1: 
0:   // Holds the Product-Specific Identifier which specifies
0:   // the product release level of a DDM Server.
0:   // The max length is 8.
0:   public String productID_;
1: 
0:   // Used to get the public key and encrypt password and/or userid
0:   protected EncryptionManager encryptionManager_;
1: 
0: 	// used to set transaction isolation level
0: 	private Statement setTransactionIsolationStmt = null;
0:   // ------------------------dynamic properties---------------------------------
1: 
0:   protected boolean open_ = true; 
0:   protected boolean availableForReuse_ = false;
1: 
0:   public int isolation_ = Configuration.defaultIsolation;
0:   public boolean autoCommit_ = true;
0:   protected boolean inUnitOfWork_ = false; // This means a transaction is in progress.
1: 
0:   private boolean accumulated440ForMessageProcFailure_ = false;
0:   private boolean accumulated444ForMessageProcFailure_ = false;
0:   private boolean accumulatedSetReadOnlyWarning_ = false;
1: 
1: 
1: 
0:   //---------------------XA-----------------------------------------------------
1: 
0:   protected boolean isXAConnection_ = false; // Indicates an XA connection
1: 
0:   // XA States
0:   public static final int XA_OPEN_IDLE = 0;
0:   public static final int XA_LOCAL = 1; // local transaction started by DNC
0:   public static final int XA_LOCAL_CCC = 2; // local transaction started by CCC
0:   public static final int XA_ACTIVE = 3;
0:   public static final int XA_ENDED = 4;
0:   public static final int XA_HEUR_COMP = 5;
0:   public static final int XA_SUSPENDED = 6;
0:   public static final int XA_PREPARED = 7;
0:   public static final int XA_ROLLBACK = 8;
0:   public static final int XA_LOCAL_START_SENT = 9;
0:   public static final int XA_UNKNOWN = 10;
0:   public static final int XA_GLOBAL_START_SENT = 11;
0:   public static final int XA_PENDING_END = 12;
0:   public static final int XA_RBATHER = 13;
0:   public static final int XA_RECOVER = 14;
0:   public static final int XA_EMPTY_TRANSACTION = 15;
0:   public static final int XA_RBROLLBACK = 16;
0:   public static final int XA_PENDING_START = 17;
0:   public static final int XA_EMPTY_SUSPENDED = 18;
1: 
1: 
0:   protected int xaState_ = XA_OPEN_IDLE;
1: 
0:   // XA Host Type
0:   public int xaHostVersion_ = 0;
1: 
0:   public int loginTimeout_;
0:   public org.apache.derby.jdbc.ClientDataSource dataSource_;
0:   public String serverNameIP_;
0:   public int portNumber_;
1: 
0:   public java.util.Hashtable clientCursorNameCache_ = new java.util.Hashtable();
0:   public boolean canUseCachedConnectBytes_ = false;
0:   public int commBufferSize_ = 32767;
1: 
0:   // indicates if a deferred reset connection is required
0:   public boolean resetConnectionAtFirstSql_ = false;
1: 
0:   //---------------------constructors/finalizer---------------------------------
1: 
0:   // For jdbc 2 connections
0:   protected Connection (org.apache.derby.client.am.LogWriter logWriter,
0:                         String user,
0:                         String password,
0:                         org.apache.derby.jdbc.ClientDataSource dataSource) throws SqlException
0:   {
0:     initConnection(logWriter, user, dataSource);
0:   }
1: 
0:   protected Connection (org.apache.derby.client.am.LogWriter logWriter,
0:                         String user,
0:                         String password,
0:                         boolean isXAConn,
0:                         org.apache.derby.jdbc.ClientDataSource dataSource) throws SqlException
0:   {
0:     isXAConnection_ = isXAConn;
0:     initConnection(logWriter, user, dataSource);
0:   }
1: 
0:   // For jdbc 2 connections
0:   protected void initConnection (org.apache.derby.client.am.LogWriter logWriter,
0:                                  String user,
0:                                  org.apache.derby.jdbc.ClientDataSource dataSource) throws SqlException
0:   {
0:     if (logWriter != null) logWriter.traceConnectEntry (dataSource);
0:     org.apache.derby.client.am.Configuration.checkForExceptionsFromLoadConfiguration (logWriter);
1: 
0:     user_ = user;
1: 
0:     // Extract common properties.
0:     databaseName_ = dataSource.getDatabaseName() + dataSource.getConnectionAttributes();
0:     retrieveMessageText_ = dataSource.getRetrieveMessageText();
1: 
0:     loginTimeout_ = dataSource.getLoginTimeout();
0:     dataSource_ = dataSource;
1: 
0:     serverNameIP_ = dataSource.getServerName();
0:     portNumber_ = dataSource.getPortNumber();
1: 
1: 
0:     agent_ = newAgent_ (logWriter,
0: 			loginTimeout_,
0:                         serverNameIP_,
0:                         portNumber_);
0:   }
1: 
0:   // For jdbc 2 connections
0:   protected Connection (org.apache.derby.client.am.LogWriter logWriter,
0:                         boolean isXAConn,
0:                         org.apache.derby.jdbc.ClientDataSource dataSource) throws SqlException
0:   {
0:     if (logWriter != null) logWriter.traceConnectEntry (dataSource);
0:     isXAConnection_ = isXAConn;
0:     org.apache.derby.client.am.Configuration.checkForExceptionsFromLoadConfiguration (logWriter);
1: 
0:     user_ = ClientDataSource.propertyDefault_user;
1: 
0:     // Extract common properties.
0:     databaseName_ = dataSource.getDatabaseName();
0:     retrieveMessageText_ = dataSource.getRetrieveMessageText();
1: 
0:     loginTimeout_= dataSource.getLoginTimeout();
0:     dataSource_ = dataSource;
1: 
0:     serverNameIP_ = dataSource.getServerName();
0:     portNumber_ = dataSource.getPortNumber();
1: 
1: 
0:     agent_ = newAgent_ (logWriter,
0:                         loginTimeout_,
0:                         serverNameIP_,
0:                         portNumber_);
0:   }
1: 
0:   // This is a callback method, called by subsystem - NetConnection
0:   protected void resetConnection (LogWriter logWriter,
0:                                   String user,
0:                                   ClientDataSource ds,
0:                                   boolean recomputeFromDataSource) throws SqlException
0:   {
0:     // clearWarningsX() will re-initialize the following properties
0:     clearWarningsX();
1: 
0:     user_ = (user != null) ? user : user_;
1: 
0:     if (ds != null && recomputeFromDataSource) { // no need to reinitialize connection state if ds hasn't changed
0:       user_ = (user != null) ? user : ds.getUser();;
1: 
0:       retrieveMessageText_ = ds.getRetrieveMessageText();
1: 
1: 
0:       // property encryptionManager_
0:       // if needed this will later be initialized by NET calls to initializePublicKeyForEncryption()
0:       encryptionManager_ = null;
1: 
0:       // property: open_
0:       // this should already be true
1: 
0:       isolation_ = Configuration.defaultIsolation;
0:       autoCommit_ = true;
0:       inUnitOfWork_ = false;
1: 
0:       loginTimeout_ = ds.getLoginTimeout();
0:       dataSource_ = ds;
0:     }
1: 
0:     // property isXAConnection_
0:     // leave set to current value.  this will impact which connect reset flows are used.
1: 
0:     xaState_ = XA_OPEN_IDLE;
0:     if (recomputeFromDataSource)
0:     this.agent_.resetAgent(this, logWriter, loginTimeout_, serverNameIP_, portNumber_);
0:   }
1: 
0:   protected void resetConnection (LogWriter logWriter,
0:                                   String databaseName,
0:                                   java.util.Properties properties) throws SqlException
0:   {
0:     // clearWarningsX() will re-initialize the following properties
0:     // warnings_, accumulated440ForMessageProcFailure_,
0:     // accumulated444ForMessageProcFailure_, and accumulatedSetReadOnlyWarning_
0:     clearWarningsX();
1: 
0:     databaseName_ = databaseName;
0:     user_ = ClientDataSource.getUser(properties);
1: 
0:     retrieveMessageText_ = ClientDataSource.getRetrieveMessageText(properties);
1: 
1: 
0:     // property encryptionManager_
0:     // if needed this will later be initialized by NET calls to initializePublicKeyForEncryption()
0:     encryptionManager_ = null;
1: 
0:     // property: open_
0:     // this should already be true
1: 
0:     isolation_ = Configuration.defaultIsolation;
0:     autoCommit_ = true;
0:     inUnitOfWork_ = false;
1: 
0:     // property isXAConnection_
0:     // leave set to current value.  this will impact which connect reset flows are used.
1: 
0:     xaState_ = XA_OPEN_IDLE;
1: 
0:     this.agent_.resetAgent(this, logWriter, loginTimeout_, serverNameIP_, portNumber_);
1: 
0:   }
1: 
1: 
1: 
0:   // For jdbc 1 connections
0:   protected Connection (LogWriter logWriter,
0:                        int driverManagerLoginTimeout,
0:                        String serverName,
0:                        int portNumber,
0:                        String databaseName,
0:                        java.util.Properties properties) throws SqlException
0:   {
0:     if (logWriter != null) logWriter.traceConnectEntry (serverName, portNumber, databaseName, properties);
0:     org.apache.derby.client.am.Configuration.checkForExceptionsFromLoadConfiguration (logWriter);
1: 
0:     databaseName_ = databaseName;
1: 
0:     // Extract common properties.
0:     user_ = ClientDataSource.getUser (properties);
0:     retrieveMessageText_ = ClientDataSource.getRetrieveMessageText (properties);
1: 
0:     loginTimeout_ = driverManagerLoginTimeout;
0:     serverNameIP_ = serverName;
0:     portNumber_ = portNumber;
1: 
0:     agent_ = newAgent_ (logWriter,
0:                         loginTimeout_,
0:                         serverNameIP_,
0:                         portNumber_);
0:   }
1: 
0:   // Users are advised to call the method close() on Statement and Connection objects when they are done with them.
0:   // However, some users will forget, and some code may get killed before it can close these objects.
0:   // Therefore, if JDBC drivers have state associated with JDBC objects that need to get
0:   // explicitly cleared up, they should provide finalize methods to take care of them.
0:   // The garbage collector will call these finalize methods when the objects are found to be garbage,
0:   // and this will give the driver a chance to close (or otherwise clean up) the objects.
0:   // Note, however, that there is no guarantee that the garbage collector will ever run.
0:   // If that is the case, the finalizers will not be called.
0:   protected void finalize () throws java.lang.Throwable
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "finalize");
1: 
0:     // finalize() differs from close() in that it will not throw an
0:     // exception if a transaction is in progress.
0:     // finalize() also differs from close() in that it will not drive
0:     // an auto-commit before disconnecting.
0:     //
0:     // If a transaction is in progress, a close() request will throw an SqlException.
0:     // However, if a connection with an incomplete transaction is finalized,
0:     // or is abruptly terminated by application exit,
0:     // the normal rollback semantics imposed by the DERBY server are adopted.
0:     // So we just pull the plug and let the server handle this default semantic.
1: 
0:     if (!open_) return;
0:     agent_.disconnectEvent ();
0:     super.finalize();
0:   }
1: 
0:   // ---------------------------jdbc 1------------------------------------------
1: 
0:   synchronized public java.sql.Statement createStatement () throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "createStatement");
0:     Statement s = createStatementX (java.sql.ResultSet.TYPE_FORWARD_ONLY, java.sql.ResultSet.CONCUR_READ_ONLY, resultSetHoldability_);
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceExit (this, "createStatement", s);
0:     return s;
0:   }
1: 
0:   synchronized public java.sql.PreparedStatement prepareStatement (String sql) throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "prepareStatement", sql);
0:     PreparedStatement ps = prepareStatementX (sql,
0:                                                 java.sql.ResultSet.TYPE_FORWARD_ONLY,
0:                                                 java.sql.ResultSet.CONCUR_READ_ONLY,
0:                                                 resultSetHoldability_,
0:                                                 java.sql.Statement.NO_GENERATED_KEYS,
0:                                                 null);
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceExit (this, "prepareStatement", ps);
0:     return ps;
0:   }
1: 
0:   // For internal use only.  Use by updatable result set code.
0:   synchronized public PreparedStatement preparePositionedUpdateStatement (String sql, Section querySection) throws SqlException
0:   {
0:     checkForClosedConnection ();
0:     // create a net material prepared statement.
0:     PreparedStatement preparedStatement = newPositionedUpdatePreparedStatement_ (sql, querySection);
0:     preparedStatement.flowPrepareDescribeInputOutput ();
0:     // The positioned update statement is not added to the list of open statements,
0:     // because this would cause a java.util.ConcurrentModificationException when
0:     // iterating thru the list of open statements to call completeRollback().
0:     // An updatable result set is marked closed on a call to completeRollback(),
0:     // and would therefore need to close the positioned update statement associated with the result set which would cause
0:     // it to be removed from the open statements list. Resulting in concurrent modification
0:     // on the open statements list.
0:     // Notice that ordinary Statement.closeX() is never called on the positioned update statement,
0:     // rather markClosed() is called to avoid trying to remove the statement from the openStatements_ list.
0:     return preparedStatement;
0:   }
1: 
0:   synchronized public java.sql.CallableStatement prepareCall (String sql) throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "prepareCall", sql);
0:     CallableStatement cs = prepareCallX (sql, java.sql.ResultSet.TYPE_FORWARD_ONLY, java.sql.ResultSet.CONCUR_READ_ONLY, resultSetHoldability_);
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceExit (this, "prepareCall", cs);
0:     return cs;
0:   }
1: 
0:   synchronized PreparedStatement prepareDynamicCatalogQuery (String sql) throws SqlException
0:   {
0:     PreparedStatement ps = newPreparedStatement_ (sql, java.sql.ResultSet.TYPE_FORWARD_ONLY, java.sql.ResultSet.CONCUR_READ_ONLY, resultSetHoldability_, java.sql.Statement.NO_GENERATED_KEYS, null);
0:     ps.isCatalogQuery_ = true;
0:     ps.prepare (); 
0:     openStatements_.add (ps);
0:     return ps;
0:   }
1: 
0:   public String nativeSQL (String sql) throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "nativeSQL", sql);
0:     String nativeSql = nativeSQLX (sql);
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceExit (this, "nativeSQL", nativeSql);
0:     return nativeSql;
0:   }
1: 
0:   synchronized public String nativeSQLX (String sql) throws SqlException
0:   {
0:     checkForClosedConnection();
0:     if (sql == null) throw new SqlException (agent_.logWriter_, "Null SQL string passed.");
1: 
0:     // Derby can handle the escape syntax directly so only needs escape
0:     // processing for { ? = CALL  ....}
0:     String trimSql = sql.trim();
0:     if (trimSql.startsWith ("{"))
0:     {
0: 	if (trimSql.lastIndexOf("}") >= 0)
0:         	return trimSql.substring(1, trimSql.lastIndexOf("}"));
0:     }
1: 
0:     return trimSql;
0:   }
1: 
0:   // Driver-specific determination if local COMMIT/ROLLBACK is allowed;
0:   // primary usage is distinction between local and global trans. envs.;
0:   protected abstract boolean disallowLocalCommitRollback_() throws org.apache.derby.client.am.SqlException;
1: 
0:   synchronized public void setAutoCommit (boolean autoCommit) throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "setAutoCommit", autoCommit);
0:     checkForClosedConnection();
1: 
0:     if ( disallowLocalCommitRollback_() ) {
0:       if (autoCommit) { // can't toggle to autocommit mode when between xars.start() and xars.end()
0:         throw new SqlException (agent_.logWriter_,
0:                                 "setAutoCommit(true) invalid during global transaction",
0:                                 SqlState._2D521, // Spec'ed by PROTOCOL
0:                                 SqlCode.invalidSetAutoCommitUnderXA);
0:       }
0:     }
0:     else {
0:       if (autoCommit == autoCommit_) return; // don't flow a commit if nothing changed.
0:       if (inUnitOfWork_) flowCommit(); // we are not between xars.start() and xars.end(), can flow commit
0:     }
0:     autoCommit_ = autoCommit;
0:   }
1: 
0:   public boolean getAutoCommit () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceExit (this, "getAutoCommit", autoCommit_);
0:     if ( disallowLocalCommitRollback_() )
0:     { // autoCommit is always false between xars.start() and xars.end()
0:       return false;
0:     }
0:     return autoCommit_;
0:   }
1: 
0:   synchronized public void commit () throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "commit");
1: 
0:     // the following XA State check must be in commit instead of commitX since
0:     // external application call commit, the SqlException should be thrown
0:     // only if an external application calls commit during a Global Transaction,
0:     // internal code will call commitX which will ignore the commit request
0:     // while in a Global transaction
0:     checkForInvalidXAStateOnCommitOrRollback ();
0:     checkForClosedConnection();
0:     flowCommit();
0:   }
1: 
0:   private void checkForInvalidXAStateOnCommitOrRollback () throws SqlException
0:   {
0:     if ( disallowLocalCommitRollback_() ) {
0:       throw new SqlException (agent_.logWriter_,
0:         "COMMIT or ROLLBACK invalid for application execution environment",
0:         SqlState._2D521, // Spec'ed by PROTOCOL
0:         SqlCode.invalidCommitOrRollbackUnderXA);
0:     }
0:   }
1: 
0:   public void flowCommit () throws SqlException
0:   {
0:     // Per JDBC specification (see javadoc for Connection.commit()):
0:     //   "This method should be used only when auto-commit mode has been disabled."
0:     // However, some applications do this anyway, it is harmless, so
0:     // if they ask to commit, we could go ahead and flow a commit.
0:     // But note that rollback() is less harmless, rollback() shouldn't be used in auto-commit mode.
0:     // This behavior is subject to further review.
1: 
0:     //   if (!this.inUnitOfWork)
0:     //     return;
0:     // We won't try to be "too smart", if the user requests a commit, we'll flow a commit,
0:     // regardless of whether or not we're in a unit of work or in auto-commit mode.
0:     //
0:     if (isXAConnection_) {
0:       agent_.beginWriteChainOutsideUOW ();
0:       writeCommit ();
0:       agent_.flowOutsideUOW ();
0:       readCommit (); // This will invoke the commitEvent() callback from the material layer.
0:       agent_.endReadChain();
0:     }
0:     else {
0:       agent_.beginWriteChain (null) ;
0:       writeCommit ();
0:       agent_.flow (null);
0:       readCommit (); // This will invoke the commitEvent() callback from the material layer.
0:       agent_.endReadChain();
0:     }
1: 
0:   }
1: 
0:   // precondition: autoCommit_ is true
0:   public void flowAutoCommit () throws SqlException
0:   {
0:     if (willAutoCommitGenerateFlow()) flowCommit();
0:   }
1: 
0:   public boolean willAutoCommitGenerateFlow() throws org.apache.derby.client.am.SqlException
0:   {
0:     if (!autoCommit_) return false;
0:     if (disallowLocalCommitRollback_()) return false;
0:     return true;
0:   }
1: 
0:   // precondition: autoCommit_ is true
0:   void writeAutoCommit() throws SqlException
0:   {
0:     if (willAutoCommitGenerateFlow()) writeCommit();
0:   }
1: 
0:   public void writeCommit () throws SqlException
0:   {
0:     if (isXAConnection_) {
0:       if ((xaState_ == XA_LOCAL) ||
0:           (xaState_ == XA_LOCAL_START_SENT))
0:         writeLocalXACommit_();
0:     }
0:     else
0:       writeLocalCommit_();
0:   }
1: 
0:   // precondition: autoCommit_ is true
0:   void readAutoCommit() throws SqlException
0:   {
0:     if (willAutoCommitGenerateFlow()) readCommit();
0:   }
1: 
0:   public void readCommit () throws SqlException
0:   {
0:     if (isXAConnection_) {
0:         if ((xaState_ == XA_LOCAL) ||
0:             (xaState_ == XA_LOCAL_START_SENT)) {
0:           readLocalXACommit_();
0:           setXAState( XA_OPEN_IDLE );
0:       }
0:     }
0:     else
0:       readLocalCommit_();
0:   }
1: 
0:   synchronized public void rollback () throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "rollback");
0:     checkForInvalidXAStateOnCommitOrRollback ();
0:     checkForClosedConnection();
0:     flowRollback();
0:   }
1: 
0:   // Even if we're not in a transaction, all open result sets will be closed.
0:   // So we could probably just return if we're not in a transaction
0:   // using the following code:
0:   //     if (!this.inUnitOfWork)
0:   //       return;
0:   // But we'll just play it safe, and blindly flow the rollback.
0:   // We won't try to be "too smart", if the user requests a rollback, we'll flow a rollback,
0:   // regardless of whether or not we're in a unit of work or in auto-commit mode.
0:   //
0:   // Per JDBC specification (see javadoc for Connection.rollback()):
0:   //   "This method should be used only when auto-commit mode has been disabled."
0:   // However, rather than trying to be too smart, we'll just flow the rollback anyway
0:   // before throwing an exception.
0:   // As a side-effect of invoking rollback() in auto-commit mode,
0:   // we'll close all open result sets on this connection in the rollbackEvent().
0:   //
0:   protected void flowRollback () throws SqlException
0:   {
0:     if(isXAConnection_) {
0:     agent_.beginWriteChainOutsideUOW ();
0:     writeRollback ();
0:     agent_.flowOutsideUOW ();
0:     readRollback (); // This method will invoke the rollbackEvent() callback from the material layer.
0:     agent_.endReadChain();
0:   }
0:     else {
0:       agent_.beginWriteChain(null);
0:       writeRollback ();
0:       agent_.flow(null);
0:       readRollback (); // This method will invoke the rollbackEvent() callback from the material layer.
0:       agent_.endReadChain();
0:     }
0:   }
1: 
0:   public void writeRollback () throws SqlException
0:   {
0:     if (isXAConnection_) {
0:         writeLocalXARollback_();
0:     }
0:     else
0:       writeLocalRollback_();
0:   }
1: 
0:   public void readRollback() throws SqlException
0:   {
0:     if (isXAConnection_) {
0:       readLocalXARollback_();
0:         setXAState( XA_OPEN_IDLE );
0:     }
0:     else
0:       readLocalRollback_();
0:   }
1: 
0:   synchronized public void close () throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "close");
0:     closeX();
0:   }
1: 
0:   void checkForTransactionInProgress () throws SqlException
0:   {
0:     // The following precondition matches CLI semantics, see SQLDisconnect()
0:     if (!autoCommit_ && inUnitOfWork_ && !allowCloseInUOW_()) {
0:       throw new SqlException (agent_.logWriter_,
0:         "java.sql.Connection.close() requested while a transaction is in progress on the connection." +
0:         "The transaction remains active, and the connection cannot be closed.");
0:     }
0:   }
1: 
0:   // This is a no-op if the connection is already closed.
0:   synchronized public void closeX () throws SqlException
0:   {
0:     if (!open_) return;
0:     closeResourcesX();
0:   }
1: 
0:   // Close physical socket or attachment even if connection is marked close.
0:   // Used by ClientPooledConnection.close().
0:   synchronized public void closeResources () throws SqlException
0:   {
0:     if (open_ || (!open_ && availableForReuse_)) {
0:       availableForReuse_ = false;
0:       closeResourcesX();
0:     }
0:   }
1: 
0:   private void closeResourcesX () throws SqlException
0:   {
0:     checkForTransactionInProgress ();
0:     resetConnectionAtFirstSql_ = false; // unset indicator of deferred reset
0:     SqlException accumulatedExceptions = null;
0: 	if (setTransactionIsolationStmt != null)
0: 		try {
0: 			setTransactionIsolationStmt.close();
0: 		} catch (SqlException se)
0: 		{
0: 			accumulatedExceptions = se; 
0: 		}
0:     try { flowClose(); } catch (SqlException e) 
0: 	{ accumulatedExceptions =
0: 		  Utils.accumulateSQLException(e,accumulatedExceptions); 
0: 	}
1: 
0:     markClosed();
0:     try { agent_.close(); }
0:     catch (SqlException e) {
0:       throw Utils.accumulateSQLException (e, accumulatedExceptions);
0:     }
0:   }
1: 
0:   protected abstract boolean isGlobalPending_ ();
1: 
0:   // Just like closeX except the socket is not pulled.
0:   // Physical resources are not closed.
0:   synchronized public void closeForReuse() throws SqlException
0:   {
0:     if (!open_) return;
0:     checkForTransactionInProgress ();
0:     resetConnectionAtFirstSql_ = false; // unset indicator of deferred reset
0:     SqlException accumulatedExceptions = null;
0:     try { flowClose(); } catch (SqlException e) { accumulatedExceptions = e; }
0:     if (open_) markClosedForReuse();
0:     if (accumulatedExceptions != null) throw accumulatedExceptions;
0:   }
1: 
0:   private void flowClose () throws SqlException
0:   {
0:     agent_.beginWriteChainOutsideUOW ();
0:     if (doCloseStatementsOnClose_()) writeCloseStatements();
0:     if (autoCommit_) writeAutoCommit ();
0:     agent_.flowOutsideUOW ();
0:     if (doCloseStatementsOnClose_()) readCloseStatements();
0:     if (autoCommit_) readAutoCommit ();
0:     agent_.endReadChain();
0:   }
1: 
0:   protected abstract void markClosed_();
0:   public void markClosed() // called by LogicalConnection.close()
0:   {
0:     open_ = false;
0:     inUnitOfWork_ = false;
0:     markStatementsClosed();
0:     CommitAndRollbackListeners_.clear();
0:     RollbackOnlyListeners_.clear();
0:     markClosed_();
0:   }
1: 
1: 
0:   private void markClosedForReuse()
0:   {
0:     availableForReuse_ = true;
0:     markClosed();
0:   } 
1: 
0:   private void markStatementsClosed ()
0:   {
0:     for (java.util.ListIterator i = openStatements_.listIterator(); i.hasNext(); ) {
0:       Statement stmt  = (Statement) i.next();
0:       stmt.markClosed();
0:       i.remove();
0:     }
0:   }
1: 
0:   private void writeCloseStatements () throws SqlException
0:   {
0:     for (java.util.ListIterator i = openStatements_.listIterator(); i.hasNext(); ) {
0:       ((Statement) i.next()).writeClose (false);  // false means don't permit auto-commits
0:     }
0:   }
1: 
0:   private void readCloseStatements () throws SqlException
0:   {
0:     for (java.util.ListIterator i = openStatements_.listIterator(); i.hasNext(); ) {
0:       ((Statement) i.next()).readClose (false);  // false means don't permit auto-commits
0:     }
0:   }
1: 
1: 
0:   public boolean isClosed ()
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceExit (this, "isClosed", !open_);
0:     return !open_;
0:   }
1: 
0:   public boolean isClosedX ()
0:   {
0:     return !open_;
0:   }
1: 
0: 	private static String DERBY_TRANSACTION_REPEATABLE_READ = "RS";
0: 	private static String DERBY_TRANSACTION_SERIALIZABLE = "RR";
0: 	private static String DERBY_TRANSACTION_READ_COMMITTED = "CS";
0: 	private static String DERBY_TRANSACTION_READ_UNCOMMITTED = "UR";
1: 
0:   synchronized public void setTransactionIsolation (int level) throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "setTransactionIsolation", level);
0:     // Per jdbc spec (see java.sql.Connection.close() javadoc).
0:     checkForClosedConnection ();
1: 
0:     // Javadoc for this method:
0:     //   If this method is called during a transaction, the result is implementation-defined.
0:     //
0:     //
0:     // REPEATABLE_READ = JDBC: TRANSACTION_SERIALIZABLE, DERBY: RR, PROTOCOL: repeatable read
0:     // READ_STABILITY = JDBC: TRANSACTION_REPEATABLE_READ, DERBY: RS, PROTOCOL: All
0:     // CURSOR_STABILITY = JDBC: TRANSACTION_READ_COMMITTED, DERBY: CS, PROTOCOL: Cursor stability
0:     // UNCOMMITTED_READ = JDBC: TRANSACTION_READ_UNCOMMITTED, DERBY: UR , PROTOCOL: Change
0:     // NO_COMMIT = JDBC: TRANSACTION_NONE, DERBY: NC, PROTOCOL: No commit
0:     //
0: 	String levelString = null;
0:     switch (level) {
0:     case java.sql.Connection.TRANSACTION_REPEATABLE_READ:
0: 		levelString = DERBY_TRANSACTION_REPEATABLE_READ;
0: 		break;
0:     case java.sql.Connection.TRANSACTION_READ_COMMITTED:
0: 		levelString = DERBY_TRANSACTION_READ_COMMITTED;
0: 		break;
0:     case java.sql.Connection.TRANSACTION_SERIALIZABLE:
0: 		levelString = DERBY_TRANSACTION_SERIALIZABLE;
0: 		break;
0:     case java.sql.Connection.TRANSACTION_READ_UNCOMMITTED:
0: 		levelString = DERBY_TRANSACTION_READ_UNCOMMITTED;
0: 		break;
0:     // Per javadoc:
0:     //   Note that Connection.TRANSACTION_NONE cannot be used because it specifies that transactions are not supported.
0:     case java.sql.Connection.TRANSACTION_NONE:
0:     default:
0:       throw new SqlException (agent_.logWriter_,
0:         "Transaction isolation level " + level + " is an invalid argument for java.sql.Connection.setTransactionIsolation()." +
0:         " See Javadoc specification for a list of valid arguments.","XJ045");
0:     }
0: 	if (setTransactionIsolationStmt == null)
0: 		setTransactionIsolationStmt =
0: 			createStatementX(java.sql.ResultSet.TYPE_FORWARD_ONLY, 
0: 							 java.sql.ResultSet.CONCUR_READ_ONLY, 
0: 							 resultSetHoldability_);
0: 	setTransactionIsolationStmt.executeUpdate("SET CURRENT ISOLATION = " + levelString);
1: 	
0: 	isolation_ = level;
1: 	
0:   }
1: 
0:   public int getTransactionIsolation () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceExit (this, "getTransactionIsolation", isolation_);
0:     return isolation_;
0:   }
1: 
0:   public java.sql.SQLWarning getWarnings ()
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceExit (this, "getWarnings", warnings_);
0:     return warnings_;
0:   }
1: 
0:   synchronized public void clearWarnings () throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "clearWarnings");
0:     clearWarningsX();
0:   }
1: 
0:   // An untraced version of clearWarnings()
0:   public void clearWarningsX () throws SqlException
0:   {
0:     warnings_ = null;
0:     accumulated440ForMessageProcFailure_ = false;
0:     accumulated444ForMessageProcFailure_ = false;
0:     accumulatedSetReadOnlyWarning_ = false;
0:   }
1: 
0:   //======================================================================
0:   // Advanced features:
1: 
0:   public java.sql.DatabaseMetaData getMetaData () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceExit (this, "getMetaData", databaseMetaData_);
0:     return databaseMetaData_;
0:   }
1: 
0:   synchronized public void setReadOnly (boolean readOnly) throws SqlException
0:   {
0:     // This is a hint to the driver only, so this request is silently ignored.
0:     // PROTOCOL can only flow a set-read-only before the connection is established.
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "setReadOnly", readOnly);
0:     checkForClosedConnection();
0:   }
1: 
0:   public boolean isReadOnly () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceExit (this, "isReadOnly", jdbcReadOnly_);
0:     return false;
0:   }
1: 
0:   synchronized public void setCatalog (String catalog) throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "setCatalog", catalog);
0:     checkForClosedConnection();
0:     // Per jdbc spec: if the driver does not support catalogs, it will silently ignore this request.
0:   }
1: 
0:   public String getCatalog () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceExit (this, "getCatalog", (String) null);
0:     return null;
0:   }
1: 
0:   //--------------------------JDBC 2.0-----------------------------
1: 
0:   synchronized public java.sql.Statement createStatement (int resultSetType,
0:                                                           int resultSetConcurrency) throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "createStatement", resultSetType, resultSetConcurrency);
0:     Statement s = createStatementX (resultSetType, resultSetConcurrency, resultSetHoldability_);
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceExit (this, "createStatement", s);
0:     return s;
0:   }
1: 
0:   synchronized public java.sql.PreparedStatement prepareStatement (String sql,
0:                                                                    int resultSetType,
0:                                                                    int resultSetConcurrency) throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "prepareStatement", sql, resultSetType, resultSetConcurrency);
0:     PreparedStatement ps = prepareStatementX (sql,
0:                                                 resultSetType,
0:                                                 resultSetConcurrency,
0:                                                 resultSetHoldability_,
0:                                                 java.sql.Statement.NO_GENERATED_KEYS,
0:                                                 null);
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceExit (this, "prepareStatement", ps);
0:     return ps;
0:   }
1: 
0:   synchronized public java.sql.CallableStatement prepareCall (String sql,
0:                                                               int resultSetType,
0:                                                               int resultSetConcurrency) throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "prepareCall", sql, resultSetType, resultSetConcurrency);
0:     CallableStatement cs = prepareCallX (sql, resultSetType, resultSetConcurrency, resultSetHoldability_);
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceExit (this, "prepareCall", cs);
0:     return cs;
0:   }
1: 
0:   synchronized public CallableStatement prepareMessageProc (String sql) throws SqlException
0:   {
0:     checkForClosedConnection ();
1: 
0:     CallableStatement cs = prepareCallX (sql, java.sql.ResultSet.TYPE_FORWARD_ONLY, java.sql.ResultSet.CONCUR_READ_ONLY, resultSetHoldability_);
0:     return cs;
0:   }
1: 
0:   // Per jdbc spec, when a result set type is unsupported, we downgrade and
0:   // issue a warning rather than to throw an exception.
0:   private int downgradeResultSetType (int resultSetType)
0:   {
0:     if (resultSetType == java.sql.ResultSet.TYPE_SCROLL_SENSITIVE) {
0:       accumulateWarning (new SqlWarning (
0:         agent_.logWriter_, "Scroll sensitive result sets are not supported by server; remapping to forward-only cursor"));
0:       return java.sql.ResultSet.TYPE_SCROLL_INSENSITIVE;
0:     }
0:     return resultSetType;
0:   }
1: 
0:   // Per jdbc spec, when a result set concurrency is unsupported, we downgrade and
0:   // issue a warning rather than to throw an exception.
0:   private int downgradeResultSetConcurrency (int resultSetConcurrency, int resultSetType)
0:   {
0:       if (resultSetConcurrency == java.sql.ResultSet.CONCUR_UPDATABLE &&
0:           resultSetType == java.sql.ResultSet.TYPE_SCROLL_INSENSITIVE) {
0:         accumulateWarning (new SqlWarning (
0:           agent_.logWriter_, "Insensitive updatable result sets are not supported by server; remapping to insensitive read-only cursor"));
0:         return java.sql.ResultSet.CONCUR_READ_ONLY;
0:       }
0:       return resultSetConcurrency;
0:   }
1: 
0:   public java.util.Map getTypeMap () throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "getTypeMap");
0:     checkForClosedConnection();
0:     java.util.Map map = new java.util.HashMap();
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceExit (this, "getTypeMap", map);
0:     return map;
0:   }
1: 
0:   synchronized public void setTypeMap (java.util.Map map) throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "setTypeMap", map);
0:     checkForClosedConnection();
0:     throw new SqlException (agent_.logWriter_, "Connection.setTypeMap is not supported");
0:   }
1: 
0:   //--------------------------JDBC 3.0-----------------------------
1: 
0:   synchronized public void setHoldability (int holdability) throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "setHoldability", holdability);
0:     checkForClosedConnection();
0:     resultSetHoldability_ = holdability;
0:   }
1: 
0:   public int getHoldability() throws SqlException
0:   {
0:     checkForClosedConnection();
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceExit (this, "getHoldability", resultSetHoldability_);
0:     return resultSetHoldability_;
0:   }
1: 
0:   public int dncGeneratedSavepointId_;
0:   // generated name used internally for unnamed savepoints
0:   public static final String dncGeneratedSavepointNamePrefix__ = "DNC_GENENERATED_NAME_";
1: 
0:   synchronized public java.sql.Savepoint setSavepoint() throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "setSavepoint");
0:     checkForClosedConnection ();
0:     if (autoCommit_) // Throw exception if auto-commit is on
0:       throw new SqlException (agent_.logWriter_, "Cannot set savepoint when in auto-commit mode.");
0:     else if (xaState_ == XA_PENDING_START ||
0:              xaState_ == XA_ACTIVE) // Throw exception if in distributed transaction
0:       throw new SqlException (agent_.logWriter_, "Cannot set savepoint during distributed transaction.");
0:     // create an un-named savepoint.
0:     if ((++dncGeneratedSavepointId_) < 0) dncGeneratedSavepointId_ = 1; // restart from 1 when overflow.
0:     Object s = setSavepointX (new Savepoint (agent_, dncGeneratedSavepointId_));
0:     return (java.sql.Savepoint) s;
0:   }
1: 
0:   synchronized public java.sql.Savepoint setSavepoint (String name) throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "setSavepoint", name);
0:     checkForClosedConnection ();
0:     if (name == null) // Throw exception if savepoint name is null
0:       throw new SqlException (agent_.logWriter_, "Named savepoint needs a none-null name.");
0:     else if (autoCommit_) // Throw exception if auto-commit is on
0:       throw new SqlException (agent_.logWriter_, "Cannot set savepoint when in auto-commit mode.");
0:     else if (xaState_ == XA_PENDING_START ||
0:              xaState_ == XA_ACTIVE) // Throw exception if in distributed transaction
0:       throw new SqlException (agent_.logWriter_, "Cannot set savepoint during distributed transaction.");
0:     // create a named savepoint.
0:     Object s = setSavepointX (new Savepoint (agent_, name));
0:     return (java.sql.Savepoint) s;
0:   }
1: 
0:   private Savepoint setSavepointX (Savepoint savepoint) throws SqlException
0:   {
0:     // Construct and flow a savepoint statement to server.
0:     Statement stmt = null;
0:     try {
0:       stmt = (Statement) createStatementX (java.sql.ResultSet.TYPE_FORWARD_ONLY,
0:                                            java.sql.ResultSet.CONCUR_READ_ONLY,
0:                                            resultSetHoldability_);
0:       String savepointName;
0:       try {
0:         savepointName = savepoint.getSavepointName();
0:       }
0:       catch (SqlException e) {
0:         // generate the name for an un-named savepoint.
0:         savepointName = dncGeneratedSavepointNamePrefix__ +
1:                         savepoint.getSavepointId();
0:       }
0:       String sql = "SAVEPOINT \"" + savepointName + "\" ON ROLLBACK RETAIN CURSORS";
0:       stmt.executeX (sql);
0:     }
0:     finally {
0:       if (stmt != null)
0:         try { stmt.closeX(); } catch (SqlException doNothing) {}
0:     }
1: 
0:     return savepoint;
0:   }
1: 
0:   synchronized public void rollback (java.sql.Savepoint savepoint) throws SqlException
0:   {
0:     int saveXaState = xaState_;
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "rollback", savepoint);
0:     checkForClosedConnection ();
0:     if (savepoint == null) // Throw exception if savepoint is null
0:       throw new SqlException (agent_.logWriter_, "Cannot rollback to a null savepoint.");
0:     else if (autoCommit_) // Throw exception if auto-commit is on
0:       throw new SqlException (agent_.logWriter_, "Cannot rollback to a savepoint when in auto-commit mode.");
0:     else if (xaState_ == XA_PENDING_START ||
0:              xaState_ == XA_ACTIVE) // Throw exception if in distributed transaction
0:       throw new SqlException (agent_.logWriter_, "Cannot rollback to a savepoint during distributed transaction.");
0:     // Only allow to rollback to a savepoint from the connection that create the savepoint.
0:     try {
0:       if (this != ((Savepoint) savepoint).agent_.connection_)
0:         throw new SqlException (agent_.logWriter_,
0:                                 "Rollback to a savepoint not created by this connection.");
0:     }
0:     catch (java.lang.ClassCastException e) { // savepoint is not an instance of am.Savepoint
0:       throw new SqlException (agent_.logWriter_,
0:                               "Rollback to a savepoint not created by this connection.");
0:     }
1: 
0:     // Construct and flow a savepoint rollback statement to server.
0:     Statement stmt = null;
0:     try {
0:       stmt = createStatementX (java.sql.ResultSet.TYPE_FORWARD_ONLY,
0:                                            java.sql.ResultSet.CONCUR_READ_ONLY,
0:                                            resultSetHoldability_);
0:       String savepointName;
0:       try {
0:         savepointName = ((Savepoint) savepoint).getSavepointName();
0:       }
0:       catch (SqlException e) {
0:         // generate the name for an un-named savepoint.
0:         savepointName = dncGeneratedSavepointNamePrefix__ +
0:                         ((Savepoint) savepoint).getSavepointId();
0:       }
0:       String sql = "ROLLBACK TO SAVEPOINT \"" + savepointName + "\"";
0:       stmt.executeX (sql);
0:     }
0:     finally {
0:       if (stmt != null)
0:         try { stmt.closeX(); } catch (SqlException doNothing) {}
0:       xaState_ = saveXaState;
0:     }
0:   }
1: 
0:   synchronized public void releaseSavepoint (java.sql.Savepoint savepoint) throws SqlException
0:   {
0:     int saveXaState = xaState_;
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "releaseSavepoint", savepoint);
0:     checkForClosedConnection ();
0:     if (savepoint == null) // Throw exception if savepoint is null
0:       throw new SqlException (agent_.logWriter_, "Cannot release a null savepoint.");
0:     else if (autoCommit_) // Throw exception if auto-commit is on
0:       throw new SqlException (agent_.logWriter_, "Cannot release a savepoint when in auto-commit mode.");
0:     else if (xaState_ == XA_PENDING_START ||
0:              xaState_ == XA_ACTIVE) // Throw exception if in distributed transaction
0:       throw new SqlException (agent_.logWriter_, "Cannot release a savepoint during distributed transaction.");
0:     // Only allow to release a savepoint from the connection that create the savepoint.
0:     try {
0:       if (this != ((Savepoint) savepoint).agent_.connection_)
0:         throw new SqlException (agent_.logWriter_,
0:                                 "Cannot release a savepoint that was not created by this connection.");
0:     }
0:     catch (java.lang.ClassCastException e) { // savepoint is not an instance of am.Savepoint
0:       throw new SqlException (agent_.logWriter_,
0:                               "Cannot release a savepoint that was not created by this connection.");
0:     }
1: 
0:     // Construct and flow a savepoint release statement to server.
0:     Statement stmt = null;
0:     try {
0:       stmt = (Statement) createStatementX (java.sql.ResultSet.TYPE_FORWARD_ONLY,
0:                                            java.sql.ResultSet.CONCUR_READ_ONLY,
0:                                            resultSetHoldability_);
0:       String savepointName;
0:       try {
0:         savepointName = ((Savepoint) savepoint).getSavepointName();
0:       }
0:       catch (SqlException e) {
0:         // generate the name for an un-named savepoint.
0:         savepointName = dncGeneratedSavepointNamePrefix__ +
0:                         ((Savepoint) savepoint).getSavepointId();
0:       }
0:       String sql = "RELEASE SAVEPOINT \"" + savepointName + "\"";
0:       stmt.executeX (sql);
0:     }
0:     finally {
0:       if (stmt != null)
0:         try { stmt.closeX(); } catch (SqlException doNothing) {}
0:       xaState_ = saveXaState;
0:     }
0:   }
1: 
0:   synchronized public java.sql.Statement createStatement (int resultSetType,
0:                                              int resultSetConcurrency,
0:                                              int resultSetHoldability) throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "createStatement", resultSetType, resultSetConcurrency, resultSetHoldability);
0:     Statement s = createStatementX (resultSetType, resultSetConcurrency, resultSetHoldability);
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceExit (this, "createStatement", s);
0:     return s;
0:   }
1: 
0:   private Statement createStatementX (int resultSetType,
0:                                              int resultSetConcurrency,
0:                                              int resultSetHoldability) throws SqlException
0:   {
0:     checkForClosedConnection ();
0:     resultSetType = downgradeResultSetType (resultSetType);
0:     resultSetConcurrency = downgradeResultSetConcurrency (resultSetConcurrency, resultSetType);
0:     Statement s = newStatement_ (resultSetType, resultSetConcurrency, resultSetHoldability);
0:     s.cursorAttributesToSendOnPrepare_ = s.cacheCursorAttributesToSendOnPrepare();
0:     openStatements_.add (s);
0:     return s;
0:   }
1: 
0:   // not sure if holding on to cursorAttributesToSendOnPrepare and restoring it is the
0:   // right thing to do here... because if property on the dataSource changes, we may have
0:   // to send different attributes, i.e. SENSITIVE DYNAMIC, instead of SENSITIVE STATIC.
0:   protected void resetStatement (Statement s) throws SqlException
0:   {
0:     String cursorAttributesToSendOnPrepare = s.cursorAttributesToSendOnPrepare_;
0:     resetStatement_ (s, s.resultSetType_, s.resultSetConcurrency_, s.resultSetHoldability_);
0:     s.cursorAttributesToSendOnPrepare_ = cursorAttributesToSendOnPrepare;
0:   }
1: 
0:   synchronized public java.sql.PreparedStatement prepareStatement (String sql,
0:                                                       int resultSetType,
0:                                                       int resultSetConcurrency,
0:                                                       int resultSetHoldability) throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "prepareStatement", sql, resultSetType, resultSetConcurrency, resultSetHoldability);
0:     PreparedStatement ps = prepareStatementX (sql,
0:                                                 resultSetType,
0:                                                 resultSetConcurrency,
0:                                                 resultSetHoldability,
0:                                                 java.sql.Statement.NO_GENERATED_KEYS,
0:                                                 null);
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceExit (this, "prepareStatement", ps);
0:     return ps;
0:   }
1: 
0:   // used by DBMD
0:   PreparedStatement prepareStatementX (String sql,
0:                                                       int resultSetType,
0:                                                       int resultSetConcurrency,
0:                                        int resultSetHoldability,
0:                                        int autoGeneratedKeys,
0:                                        String[] columnNames) throws SqlException
0:   {
0:     checkForClosedConnection ();
0:     checkAutoGeneratedKeysParameters (autoGeneratedKeys, columnNames);
0:     resultSetType = downgradeResultSetType (resultSetType);
0:     resultSetConcurrency = downgradeResultSetConcurrency (resultSetConcurrency, resultSetType);
0:     PreparedStatement ps = newPreparedStatement_ (sql, resultSetType, resultSetConcurrency, resultSetHoldability, autoGeneratedKeys, columnNames);
0:     ps.cursorAttributesToSendOnPrepare_ = ps.cacheCursorAttributesToSendOnPrepare();
0:     ps.prepare ();
0:     openStatements_.add (ps);
0:     return ps;
0:   }
1: 
0:   // not sure if holding on to cursorAttributesToSendOnPrepare and restoring it is the
0:   // right thing to do here... because if property on the dataSource changes, we may have
0:   // to send different attributes, i.e. SENSITIVE DYNAMIC, instead of SENSITIVE STATIC.
0:   protected void resetPrepareStatement (PreparedStatement ps) throws SqlException
0:   {
0:     String cursorAttributesToSendOnPrepare = ps.cursorAttributesToSendOnPrepare_;
0:     resetPreparedStatement_ (ps, ps.sql_, ps.resultSetType_, ps.resultSetConcurrency_, ps.resultSetHoldability_, ps.autoGeneratedKeys_, ps.generatedKeysColumnNames_);
0:     ps.cursorAttributesToSendOnPrepare_ = cursorAttributesToSendOnPrepare;
0:     ps.prepare();  
0:   }
1: 
0:   synchronized public java.sql.CallableStatement prepareCall (String sql,
0:                                                  int resultSetType,
0:                                                  int resultSetConcurrency,
0:                                                  int resultSetHoldability) throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "prepareCall", sql, resultSetType, resultSetConcurrency, resultSetHoldability);
0:     CallableStatement cs = prepareCallX (sql, resultSetType, resultSetConcurrency, resultSetHoldability);
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceExit (this, "prepareCall", cs);
0:     return cs;
0:   }
1: 
0:   private CallableStatement prepareCallX (String sql,
0:                                                  int resultSetType,
0:                                                  int resultSetConcurrency,
0:                                                  int resultSetHoldability) throws SqlException
0:   {
0:     checkForClosedConnection ();
0:     resultSetType = downgradeResultSetType (resultSetType);
0:     resultSetConcurrency = downgradeResultSetConcurrency (resultSetConcurrency, resultSetType);
0:     CallableStatement cs = newCallableStatement_ (sql, resultSetType, resultSetConcurrency, resultSetHoldability);
0:     cs.cursorAttributesToSendOnPrepare_ = cs.cacheCursorAttributesToSendOnPrepare();
0:     cs.prepare ();
0:     openStatements_.add (cs);
0:     return cs;
0:   }
1: 
0:   protected void resetPrepareCall (CallableStatement cs) throws SqlException
0:   {
0:     String cursorAttributesToSendOnPrepare = cs.cursorAttributesToSendOnPrepare_;
0:     resetCallableStatement_ (cs, cs.sql_, cs.resultSetType_, cs.resultSetConcurrency_, cs.resultSetHoldability_);
0:     cs.cursorAttributesToSendOnPrepare_ = cursorAttributesToSendOnPrepare;
0:     cs.prepare ();  
0:   }
1: 
0:   public java.sql.PreparedStatement prepareStatement (String sql, int autoGeneratedKeys) throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "prepareStatement", sql, autoGeneratedKeys);
0:     PreparedStatement ps = prepareStatementX (sql,
0:                                                 java.sql.ResultSet.TYPE_FORWARD_ONLY,
0:                                                 java.sql.ResultSet.CONCUR_READ_ONLY,
0:                                                 resultSetHoldability_,
0:                                                 autoGeneratedKeys,
0:                                                 null);
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceExit (this, "prepareStatement", ps);
0:     return ps;
0:   }
1: 
0:   public java.sql.PreparedStatement prepareStatement (String sql, int columnIndexes[]) throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "prepareStatement", sql, columnIndexes);
0:     checkForClosedConnection();
0:     throw new SqlException (agent_.logWriter_, "Driver not capable");
0:   }
1: 
0:   public java.sql.PreparedStatement prepareStatement (String sql, String columnNames[]) throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "prepareStatement", sql, columnNames);
0:       PreparedStatement ps = prepareStatementX (sql,
0:                                                   java.sql.ResultSet.TYPE_FORWARD_ONLY,
0:                                                   java.sql.ResultSet.CONCUR_READ_ONLY,
0:                                                   resultSetHoldability_,
0:                                                   java.sql.Statement.RETURN_GENERATED_KEYS,
0:                                                   columnNames);
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceExit (this, "prepareStatement", ps);
0:       return ps;
0:     }
1: 
1: 
0:   // ---------------------------------------------------------------------------
1: 
0:   protected abstract boolean allowCloseInUOW_();
0:   protected abstract boolean doCloseStatementsOnClose_();
1: 
0:   public abstract SectionManager newSectionManager (String collection,
0:        Agent agent,
0:        String databaseName);
0:   //--------------------Abstract material factory methods-----------------
1: 
0:   protected abstract Agent newAgent_ (LogWriter logWriter, int loginTimeout, String serverName, int portNumber) throws SqlException;
1: 
1: 
0:   protected abstract DatabaseMetaData newDatabaseMetaData_ ();
0:   protected abstract Statement newStatement_ (int type,
0:                                              int concurrency,
0:                                              int holdability) throws SqlException;
0:   protected abstract void resetStatement_ (Statement statement,
0:                                            int type,
0:                                            int concurrency,
0:                                            int holdability) throws SqlException;
1: 
1: 
0:   protected abstract PreparedStatement newPositionedUpdatePreparedStatement_ (String sql, Section section) throws SqlException;
0:   protected abstract PreparedStatement newPreparedStatement_ (String sql,
0:                                                              int type,
0:                                                              int concurrency,
0:                                                              int holdability,
0:                                                              int autoGeneratedKeys,
0:                                                              String[] columnNames) throws SqlException;
1: 
0:   protected abstract void resetPreparedStatement_ (PreparedStatement ps,
0:                                                    String sql,
0:                                                    int resultSetType,
0:                                                    int resultSetConcurrency,
0:                                                    int resultSetHoldability,
0:                                                    int autoGeneratedKeys,
0:                                                    String[] columnNames) throws SqlException;
1: 
0:   protected abstract CallableStatement newCallableStatement_ (String sql,
0:                                                              int type,
0:                                                              int concurrency,
0:                                                              int holdability) throws SqlException;
1: 
0:   protected abstract void resetCallableStatement_ (CallableStatement cs,
0:                                                    String sql,
0:                                                    int resultSetType,
0:                                                    int resultSetConcurrency,
0:                                                    int resultSetHoldability) throws SqlException;
1: 
0:   // ----------------------- abstract box car and callback methods ---------------------
0:   // All callbacks must be client-side only operations.
1: 
1: 
0:   public void completeConnect () throws SqlException
0:   {
0:     open_ = true;
0:     databaseMetaData_ = newDatabaseMetaData_();
1: 
0:     agent_.sectionManager_ =
0:           newSectionManager ("NULLID",
0:           agent_,
0:           databaseName_);
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceConnectExit (this);
0:   }
1: 
0:   public abstract void writeCommitSubstitute_ () throws SqlException;
0:   public abstract void readCommitSubstitute_ () throws SqlException;
1: 
0:   public abstract void writeLocalXAStart_ () throws SqlException;
0:   public abstract void readLocalXAStart_ () throws SqlException;
1: 
0:   public abstract void writeLocalXACommit_ () throws SqlException;
0:   public abstract void readLocalXACommit_ () throws SqlException;
1: 
0:   public abstract void writeLocalCommit_ () throws SqlException;
0:   public abstract void readLocalCommit_ () throws SqlException;
0:   public void completeLocalCommit ()
0:   {
0:     for (java.util.Iterator i = CommitAndRollbackListeners_.iterator(); i.hasNext(); ) {
0:       UnitOfWorkListener listener = (UnitOfWorkListener)i.next();
0:       listener.completeLocalCommit(i);
0:     }
0:     inUnitOfWork_ = false;
0:   }
1: 
0:   public abstract void writeLocalRollback_ () throws SqlException;
0:   public abstract void readLocalRollback_ () throws SqlException;
0:   // A callback for certain non-fatal exceptions that occur when parsing error replies.
0:   // This is a client-side only operation.
0:   // This method will only throw an exception on bug check.
0:   public void completeLocalRollback ()
0:   {
0:     for (java.util.Iterator i = CommitAndRollbackListeners_.iterator(); i.hasNext(); ) {
0:       UnitOfWorkListener listener = (UnitOfWorkListener)i.next();
0:       listener.completeLocalRollback (i);
0:     }
0:     for (java.util.Iterator i = RollbackOnlyListeners_.iterator(); i.hasNext(); ) {
0:       UnitOfWorkListener listener = (UnitOfWorkListener)i.next();
0:       listener.completeLocalRollback (i);
0:     }
0:     inUnitOfWork_ = false;
0:   }
1: 
1: 
0:   public abstract void writeLocalXARollback_ () throws SqlException;
0:   public abstract void readLocalXARollback_ () throws SqlException;
1: 
0:   public void writeTransactionStart(Statement statement) throws SqlException {}
0:   public void readTransactionStart() throws SqlException { completeTransactionStart(); }
0:   void completeTransactionStart() { inUnitOfWork_ = true; }
1: 
0:   // Occurs autonomously
0:   public void completeAbnormalUnitOfWork () { completeLocalRollback (); }
1: 
0:   // Called by Connection.close(), NetConnection.errorRollbackDisconnect().
0:   // The Agent's client-side resources associated with database connection are reclaimed (eg. socket).
0:   // And this connection and all associated statements and result sets are marked closed.
0:   // This is a client-side only operation.
0:   // This method will only throw an exception if the agent cannot be closed.
0:   public void completeChainBreakingDisconnect ()
0:   {
0:     open_ = false;
0:     completeLocalRollback();
0:     markStatementsClosed();
0:   }
1: 
0:   public void completeSqlca (Sqlca sqlca)
0:   {
0:     if (sqlca == null) {}
0:     else if (sqlca.getSqlCode() > 0)
0:       accumulateWarning (new SqlWarning (agent_.logWriter_, sqlca));
0:     else if (sqlca.getSqlCode() < 0)
0:       agent_.accumulateReadException (new SqlException (agent_.logWriter_, sqlca));
0:   }
1: 
0:   public abstract void addSpecialRegisters (String s);
1: 
0:   // can this only be called by the PooledConnection
0:   // can this be called on a closed connection
0:   // can this be called in a unit of work
0:   // can this be called from within a stored procedure
0:   //
0:   synchronized public void reset (LogWriter logWriter, String user, String password, ClientDataSource ds, boolean recomputeFromDataSource) throws SqlException
0:   {
0:     if (logWriter != null) {
0:       logWriter.traceConnectResetEntry (this, logWriter, user, (ds!=null)?ds:dataSource_);
0:     }
0:     try {
0:       reset_ (logWriter, user, password, ds, recomputeFromDataSource);
0:     }
0:     catch (SqlException sqle) {
0:       DisconnectException de = new DisconnectException (
0:         agent_, "An error occurred during connect reset and the connection has been terminated.  See chained exceptions for details.");
0:       de.setNextException (sqle);
0:       throw de;
0:     }
0:   }
1: 
0:   synchronized public void reset (LogWriter logWriter, ClientDataSource ds, boolean recomputeFromDataSource) throws SqlException
0:   {
0:     if (logWriter != null) {
0:       logWriter.traceConnectResetEntry (this, logWriter, null, (ds!=null)?ds:dataSource_);
0:     }
0:     try {
0:       reset_ (logWriter,  ds, recomputeFromDataSource);
0:     }
0:     catch (SqlException sqle) {
0:       DisconnectException de = new DisconnectException (
0:         agent_, "An error occurred during connect reset and the connection has been terminated.  See chained exceptions for details.");
0:       de.setNextException (sqle);
0:       throw de;
0:     }
0:   }
1: 
0:   synchronized public void lightReset () throws SqlException
0:   {
0:     if (!open_ && !availableForReuse_) return;
0:     open_ = true;
0:     availableForReuse_ = false;
0:   }
1: 
0:   abstract protected void reset_ (LogWriter logWriter, String user, String password, ClientDataSource ds, boolean recomputerFromDataSource) throws SqlException;
0:   abstract protected void reset_ (LogWriter logWriter, ClientDataSource ds, boolean recomputerFromDataSource) throws SqlException;
0:   protected void completeReset (boolean isDeferredReset, boolean recomputeFromDataSource) throws SqlException
0:   {
0:     open_ = true;
1: 
0:     completeLocalRollback(); // this will close the cursors if the physical connection hadn't been closed for reuse properly
1: 
0:     // Reopen physical statement resources associated with previous uses of this physical connection.
0:     // Notice that these physical statements may not belong to this logical connection.
0:     // Iterate through the physical statements and re-enable them for reuse.
1: 
0:     for (java.util.Iterator i = openStatements_.iterator(); i.hasNext(); ) {
0:       Object o = i.next();
0:       ((Statement)o).reset (recomputeFromDataSource);
1: 
0:     }
1: 
0:     if (!isDeferredReset && agent_.loggingEnabled()) agent_.logWriter_.traceConnectResetExit (this);
0:   }
1: 
1: 
0:   //-------------------------------helper methods-------------------------------
1: 
0:   protected void checkForClosedConnection () throws SqlException
0:   {
0:     if (!open_) {
0:       agent_.checkForDeferredExceptions();
0:       throw new SqlException (agent_.logWriter_, "invalid operation: connection closed");
0:     }
0:     else {
0:       agent_.checkForDeferredExceptions();
0:     }
0:   }
1: 
0:   void checkAutoGeneratedKeysParameters (int autoGeneratedKeys, String[] columnNames) throws SqlException
0:   {
0:     if (autoGeneratedKeys != java.sql.Statement.NO_GENERATED_KEYS &&
0:         autoGeneratedKeys != java.sql.Statement.RETURN_GENERATED_KEYS)
0:       throw new SqlException (agent_.logWriter_, "Invalid argument: " +
0:                               "Statement auto-generated keys value " + autoGeneratedKeys +
0:                               " is invalid.");
1: 
0:     if (columnNames != null)
0:       throw new SqlException (agent_.logWriter_, "Driver not capable");
1: 
0:   }
1: 
0:   public boolean isXAConnection() { return isXAConnection_; }
0:   public int getXAState() { return xaState_; }
0:   public void setXAState (int state) { xaState_ =  state; }
1: 
0:   public void accumulateWarning (SqlWarning e)
0:   {
0:     if (warnings_ == null)
0:       warnings_ = e;
0:     else
0:       warnings_.setNextException (e);
0:   }
1: 
0:   public void accumulate440WarningForMessageProcFailure (SqlWarning e)
0:   { if (!accumulated440ForMessageProcFailure_) { accumulateWarning (e); accumulated440ForMessageProcFailure_ = true; }}
1: 
0:   public void accumulate444WarningForMessageProcFailure (SqlWarning e)
0:   { if (!accumulated444ForMessageProcFailure_) { accumulateWarning (e); accumulated444ForMessageProcFailure_ = true; }}
1: 
0:   // get the server version
0:   public int getServerVersion()
0:   {
0:     return databaseMetaData_.productLevel_.versionLevel_;
0:   }
1: 
0:   public void setInUnitOfWork (boolean inUnitOfWork)
0:   {
0:     inUnitOfWork_ = inUnitOfWork;
0:   }
1: 
0: }
============================================================================