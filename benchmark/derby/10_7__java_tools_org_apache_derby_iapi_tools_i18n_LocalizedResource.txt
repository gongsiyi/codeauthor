1:eac0369: /*
5:eac0369: 
1:985fc85:    Derby - Class org.apache.derby.iapi.tools.i18n.LocalizedResource
1:985fc85: 
1:3dc2ce4:    Licensed to the Apache Software Foundation (ASF) under one or more
1:3dc2ce4:    contributor license agreements.  See the NOTICE file distributed with
1:3dc2ce4:    this work for additional information regarding copyright ownership.
1:3dc2ce4:    The ASF licenses this file to You under the Apache License, Version 2.0
1:3dc2ce4:    (the "License"); you may not use this file except in compliance with
1:3dc2ce4:    the License.  You may obtain a copy of the License at
1:985fc85: 
1:985fc85:       http://www.apache.org/licenses/LICENSE-2.0
1:985fc85: 
1:985fc85:    Unless required by applicable law or agreed to in writing, software
1:985fc85:    distributed under the License is distributed on an "AS IS" BASIS,
1:985fc85:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:985fc85:    See the License for the specific language governing permissions and
1:985fc85:    limitations under the License.
1:985fc85: 
2:eac0369:  */
1:eac0369: package org.apache.derby.iapi.tools.i18n;
1:eac0369: 
1:eac0369: import java.io.InputStream;
1:eac0369: import java.io.OutputStream;
1:eac0369: import java.io.UnsupportedEncodingException;
1:eac0369: import java.sql.ResultSet;
1:eac0369: import java.sql.ResultSetMetaData;
1:eac0369: import java.sql.SQLException;
1:953afd7: import java.sql.Timestamp;
1:eac0369: import java.sql.Types;
1:953afd7: import java.text.DateFormat;
1:953afd7: import java.text.DecimalFormat;
1:953afd7: import java.text.FieldPosition;
1:953afd7: import java.text.MessageFormat;
1:953afd7: import java.text.NumberFormat;
1:953afd7: import java.text.ParseException;
1:953afd7: import java.util.Date;
1:953afd7: import java.util.Locale;
1:953afd7: import java.util.ResourceBundle;
1:953afd7: import java.util.StringTokenizer;
1:eac0369: 
1:eac0369: 
1:b5b1316: public final class LocalizedResource  implements java.security.PrivilegedAction<String> {
1:eac0369: 
1:eac0369: 	private ResourceBundle res;
1:eac0369: 	private Locale locale;
1:eac0369: 	private String encode;
1:eac0369: 	private final static String MESSAGE_FILE = "org.apache.derby.loc.toolsmessages";
1:953afd7:     public final static String ENV_CODESET = "derby.ui.codeset";
1:953afd7:     public final static String ENV_LOCALE = "derby.ui.locale";
1:eac0369: 	private String messageFileName;
1:eac0369: 	private String resourceKey;
1:eac0369: 	private LocalizedOutput out;
1:eac0369: 	private LocalizedInput in;
1:eac0369: 	private boolean enableLocalized;
1:eac0369: 	private static LocalizedResource local;
1:eac0369: 	private int dateSize;
1:eac0369: 	private int timeSize;
1:eac0369: 	private int timestampSize;
1:eac0369: 	private DateFormat formatDate;
1:eac0369: 	private DateFormat formatTime;
1:eac0369: 	private DateFormat formatTimestamp;
1:eac0369: 	private NumberFormat formatNumber;
1:eac0369:     private DecimalFormat formatDecimal;
1:953afd7: 
1:953afd7:     private LocalizedResource(){
1:eac0369: 		init();
21:eac0369: 	}
1:953afd7:     public LocalizedResource(String msgF){
1:953afd7:         init(null, null, msgF, true);
1:eac0369: 	}
1:953afd7: 
1:953afd7:     /**
1:953afd7:      * This overload version does <b>not</b> check the environment for values of
1:953afd7:      * encoding via {@link #ENV_CODESET} and locale via {@link #ENV_LOCALE}.
1:953afd7:      * The others do if value of either is null. DERBY-6680.
1:953afd7:      * @param encStr encoding
1:953afd7:      * @param locStr locale
1:953afd7:      * @param msgF message file
1:953afd7:      */
1:953afd7:     public LocalizedResource(String encStr, String locStr, String msgF){
1:953afd7:         init(encStr,locStr,msgF, false);
1:953afd7:     }
1:953afd7: 
1:953afd7:     public static LocalizedResource getInstance(){
1:eac0369: 		if (local == null){
1:eac0369: 			local = new  LocalizedResource();
1:eac0369: 		}
1:eac0369: 		return local;
1:eac0369: 	}
1:678868b:     // Resets the 'local' field to null. This is not needed for normal
1:678868b:     // operations, however, when executing sql files in our junit tests, we use
1:678868b:     // the same jvm and thus the locale will get loaded only once, resulting
1:678868b:     // in trouble when testing the localization for ij.
1:678868b:     public static void resetLocalizedResourceCache()
1:678868b:     {
1:678868b:         local=null;
1:678868b:     }
1:eac0369: 	public void init(){
1:eac0369: 		init(null,null,null);
1:eac0369: 	}
1:953afd7: 
1:953afd7: 
1:953afd7:     public void init (String encStr, String locStr, String msgF) {
1:953afd7:         init(encStr, locStr, msgF, true);
1:953afd7:     }
1:953afd7: 
1:953afd7:     private void init (String encStr, String locStr, String msgF, boolean readEnv){
1:eac0369: 		if (encStr != null){
1:eac0369: 			encode = encStr;
1:eac0369: 		}
1:eac0369: 		//then get encoding string from environment
1:953afd7:         if (encode == null && readEnv) {
1:eac0369: 			String eEncode = getEnvProperty(ENV_CODESET);
1:eac0369: 			if ( eEncode != null ){
1:eac0369: 				encode = eEncode;
1:eac0369: 			}
1:eac0369: 		}
1:18c4da7: 		
1:18c4da7: 		// If null at this point then the default encoding
1:18c4da7: 		// will be always used.
1:18c4da7: 
1:eac0369: 		//get locale string from the caller first
1:eac0369: 		locale = getNewLocale(locStr);
1:eac0369: 
1:eac0369: 		//if null, get locale again from the environment variable
1:953afd7:         if (locale==null && readEnv) {
1:eac0369: 			String s = getEnvProperty(ENV_LOCALE);
1:eac0369: 			locale = getNewLocale(s);
1:eac0369: 		}
1:eac0369: 		//get the default locale if forced
1:eac0369: 		if (locale==null){
1:eac0369: 			locale = Locale.getDefault();
1:eac0369: 		}
1:eac0369: 		if (msgF != null) {
1:eac0369: 			messageFileName = msgF;
1:eac0369: 		}
1:eac0369: 		else {
1:eac0369: 			messageFileName = MESSAGE_FILE;
1:eac0369: 		}
1:eac0369: 		//create default in/out
1:18c4da7: 		out = getNewOutput(System.out);
1:18c4da7: 		in = getNewInput(System.in);
1:eac0369: 
1:eac0369: 		//for faster code: get the format objs
1:eac0369: 		if (enableLocalized && locale != null){
1:eac0369: 			formatDecimal = (DecimalFormat)DecimalFormat.getInstance(locale);
1:eac0369: 			formatNumber = NumberFormat.getInstance(locale);
1:eac0369: 			formatDate = DateFormat.getDateInstance(DateFormat.LONG,locale);
1:eac0369: 			formatTime = DateFormat.getTimeInstance(DateFormat.LONG,locale);
1:eac0369: 			formatTimestamp = DateFormat.getDateTimeInstance(DateFormat.LONG,
1:eac0369: 													DateFormat.LONG, locale);
1:eac0369: 		}
1:eac0369: 		else {
1:eac0369: 			formatDecimal = (DecimalFormat)DecimalFormat.getInstance();
1:eac0369: 			formatNumber = NumberFormat.getInstance();
1:eac0369: 			formatDate = DateFormat.getDateInstance(DateFormat.LONG);
1:eac0369: 			formatTime = DateFormat.getTimeInstance(DateFormat.LONG);
1:eac0369: 			formatTimestamp = DateFormat.getDateTimeInstance(DateFormat.LONG,
1:eac0369: 													DateFormat.LONG);
1:eac0369: 		}
1:eac0369: 		//initialize display sizes for columns
1:eac0369: 		initMaxSizes2();
1:eac0369: 	}
1:eac0369: 	//get the message file resource according to the locale
1:eac0369: 	//fall back to English message file if locale message file is not found
1:eac0369: 	private void setResource(){
1:eac0369: 		if (res != null){
1:eac0369: 			return;
1:eac0369: 		}
1:eac0369: 		if ( locale == null || locale.toString().equals("none") ){
1:9a55084: 			res = ResourceBundle.getBundle(messageFileName);
1:eac0369: 		}
1:eac0369: 		else
3:eac0369: 		try {
1:eac0369: 			res = ResourceBundle.getBundle(messageFileName,locale);
1:eac0369: 		}
1:eac0369: 		catch(java.util.MissingResourceException e){
1:eac0369: 			res = ResourceBundle.getBundle(messageFileName,Locale.ENGLISH);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 	private void initMaxSizes2(){
1:eac0369: 		dateSize = 0;
1:eac0369: 		timeSize = 0;
1:eac0369: 		timestampSize = 0;
1:eac0369: 
1:eac0369: 		int len;
1:eac0369: 
1:eac0369: 		// check the date & timestamp max length
1:eac0369: 		// 3900/01/28 !! original devloper thought they were getting 2000/01/28
1:eac0369: 		Date d = new Date(60907276800000L);
1:eac0369: 		Timestamp t = new Timestamp(d.getTime());
1:eac0369: 		for(int month  = 0 ;  month <=11 ; month++, d.setTime(d.getTime() + (30L * 24L * 60L * 60L * 1000L))) {
1:eac0369: 			len=getDateAsString(d).length();
1:eac0369: 
1:eac0369: 			if(len > dateSize ) {
1:eac0369: 				dateSize=len;
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			t.setTime(d.getTime() + ((((21L * 60L) + 59L) * 60L) + 59L));
1:eac0369: 			len=getTimestampAsString(t).length();
1:eac0369: 
1:eac0369: 			if(len > timestampSize) {
1:eac0369: 				timestampSize=len;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// set the time max length
1:eac0369: 		// minimum of 18 because the old buggy code always used 18
1:eac0369: 		len = 18;
1:eac0369: 		for (int hour = 0 ; hour < 24; hour++) {
1:eac0369: 
1:eac0369: 			long secs = (hour * 3600L) + (59 * 60L) + 59L;
1:eac0369: 
1:eac0369: 			long ms = secs * 1000L;
1:eac0369: 
1:eac0369: 			Date td = new Date(ms);
1:eac0369: 
1:eac0369: 			String fd = formatTime.format(td);
1:eac0369: 
1:eac0369: 			if (fd.length() > len)
1:eac0369: 				len = fd.length();
1:eac0369: 		}
1:eac0369: 		timeSize=len;
1:1edcdb3: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public LocalizedInput getNewInput(InputStream i) {
1:eac0369: 		try {
1:18c4da7: 			if (encode != null)
1:18c4da7: 			    return new LocalizedInput(i,encode);
1:eac0369: 		}
1:eac0369: 		catch (UnsupportedEncodingException e){
1:18c4da7: 			
1:eac0369: 		}
1:18c4da7: 		return new LocalizedInput(i);
1:eac0369: 	}
1:eac0369: 
1:1edcdb3: 	public LocalizedInput getNewEncodedInput(InputStream i, String encoding) {
1:1edcdb3: 		try {
1:1edcdb3: 	          return new LocalizedInput(i,encoding);
1:1edcdb3: 		}
1:1edcdb3: 		catch (UnsupportedEncodingException e){
1:1edcdb3: 			
1:1edcdb3: 		}
1:1edcdb3: 		return new LocalizedInput(i);
1:1edcdb3:         }
1:1edcdb3: 
1:eac0369: 	public LocalizedOutput getNewOutput(OutputStream o){
1:eac0369: 		try {
1:18c4da7: 			if (encode != null)
1:18c4da7: 			    return new LocalizedOutput(o,encode);
1:eac0369: 		}
3:eac0369: 		catch(UnsupportedEncodingException e){
1:eac0369: 		}
1:18c4da7: 		return new LocalizedOutput(o);
1:eac0369: 	}
1:a5a98ce: 	/**
1:a5a98ce: 	 * Get a new LocalizedOutput with the given encoding.
1:a5a98ce: 	 * @throws UnsupportedEncodingException
1:a5a98ce: 	 */
1:a5a98ce: 	public LocalizedOutput getNewEncodedOutput(OutputStream o,
1:a5a98ce: 			String encoding) throws UnsupportedEncodingException{
1:0b1a784: 	    out = new LocalizedOutput(o, encoding);
1:0b1a784: 	    return out;
1:a5a98ce: 	}
1:eac0369: 	private Locale getNewLocale(String locStr){
1:eac0369: 			String l="", r="", v="";
1:eac0369: 			StringTokenizer st;
1:eac0369: 			if (locStr==null) {
1:eac0369: 				return null;
1:eac0369: 			}
1:eac0369: 			st=new StringTokenizer(locStr, "_");
1:eac0369: 			try {
1:eac0369: 				l=st.nextToken();
1:eac0369: 				if(st.hasMoreTokens()==true)
1:eac0369: 					r=st.nextToken();
1:eac0369: 				if(st.hasMoreTokens()==true)
1:eac0369: 					v=st.nextToken();
1:eac0369: 				return new Locale(l,r,v);
2:eac0369: 			} catch (Exception e) {
1:eac0369: 				return null;
1:eac0369: 			}
1:eac0369: 	}
1:c465481:     public String getTextMessage(String key, Object... objectArr) {
1:eac0369: 		if (res == null){
2:eac0369: 			setResource();
1:eac0369: 		}
2:eac0369: 			try{
1:eac0369: 				return MessageFormat.format(res.getString(key), objectArr);
1:eac0369: 			} catch (Exception e) {
1:eac0369: 					String tmpFormat = key;
1:820eb0a: 					for (int i=0; objectArr != null && i<objectArr.length; i++)
1:eac0369: 						tmpFormat = tmpFormat + ", <{" + (i) + "}>";
1:eac0369: 					return MessageFormat.format(tmpFormat, objectArr);
1:eac0369: 			}
1:eac0369: 	}
1:eac0369: 	public String getLocalizedString(ResultSet rs,
1:eac0369: 										ResultSetMetaData rsm,
1:eac0369: 										int columnNumber) throws SQLException{
1:eac0369: 			if (!enableLocalized){
1:eac0369: 				return rs.getString(columnNumber);
1:eac0369: 			}
1:eac0369: 			int type = rsm.getColumnType(columnNumber);
1:eac0369: 			if ( type == Types.DATE ) {
1:eac0369: 				return getDateAsString(rs.getDate(columnNumber));
1:eac0369: 			}
1:eac0369: 			else if ( type == Types.INTEGER ||	type == Types.SMALLINT ||
1:eac0369: 					type == Types.BIGINT ||	type == Types.TINYINT ) {
1:eac0369: 				return getNumberAsString(rs.getLong(columnNumber));
1:eac0369: 			}
1:eac0369: 			else if (type == Types.REAL || 	type == Types.FLOAT ||
1:eac0369: 					type == Types.DOUBLE ) {
1:eac0369: 				return getNumberAsString(rs.getDouble(columnNumber));
1:eac0369: 			}
1:5465561:             else if (type == Types.NUMERIC || type == Types.DECIMAL) {
1:5465561:                 return getNumberAsString(rs.getBigDecimal(columnNumber));
1:eac0369: 			}
1:eac0369: 			else if (type == Types.TIME ) {
1:eac0369: 				return getTimeAsString(rs.getTime(columnNumber));
1:eac0369: 			}
1:eac0369: 			else if (type == Types.TIMESTAMP ) {
1:eac0369: 				return getTimestampAsString(rs.getTimestamp(columnNumber));
1:eac0369: 			}
1:eac0369: 			return rs.getString(columnNumber);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 	public String getDateAsString(Date d){
1:eac0369: 		if (!enableLocalized){
1:eac0369: 			return d.toString();
1:eac0369: 		}
1:eac0369: 		return formatDate.format(d);
1:eac0369: 	}
1:eac0369: 	public String getTimeAsString(Date t){
1:eac0369: 		if (!enableLocalized){
1:eac0369: 			return t.toString();
1:eac0369: 		}
2:eac0369: 		return formatTime.format(t,	new StringBuffer(),
2:eac0369: 									  new java.text.FieldPosition(0)).toString();
1:eac0369: 	}
1:eac0369: 	public String getNumberAsString(int o){
1:eac0369: 		if (enableLocalized){
1:eac0369: 			return formatNumber.format(o);
1:eac0369: 		}
1:eac0369: 		else {
1:eac0369: 			return String.valueOf(o);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 	public String getNumberAsString(long o){
1:eac0369: 		if (enableLocalized){
1:eac0369: 			return formatNumber.format(o);
1:eac0369: 		}
1:eac0369: 		else{
1:eac0369: 			return String.valueOf(o);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 	public String getNumberAsString(Object o){
1:eac0369: 		if (enableLocalized){
1:eac0369: 			return formatNumber.format(o, new StringBuffer(),
1:eac0369: 										new FieldPosition(0)).toString();
1:eac0369: 		}
1:eac0369: 		else {
1:eac0369: 			return o.toString();
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 	public String getNumberAsString(double o){
1:eac0369: 		if (!enableLocalized) {
1:eac0369: 			return String.valueOf(o);
1:eac0369: 		}
1:eac0369: 		return formatDecimal.format(o);
1:eac0369: 	}
1:eac0369: 	public String getTimestampAsString(Timestamp t){
1:eac0369: 		if (!enableLocalized){
1:eac0369: 			return t.toString();
1:eac0369: 		}
1:23d21a3: 		return formatTimestamp.format
1:23d21a3: 			(t, new StringBuffer(),
1:23d21a3: 			 new java.text.FieldPosition(0)).toString();
1:eac0369: 	}
1:eac0369: 	public int getColumnDisplaySize(ResultSetMetaData rsm,
1:eac0369: 										int columnNumber) throws SQLException{
1:eac0369: 		  if (!enableLocalized){
1:eac0369: 				return rsm.getColumnDisplaySize(columnNumber);
1:eac0369: 		  }
1:eac0369: 		  int type = rsm.getColumnType(columnNumber);
1:eac0369: 		  if (type == Types.DATE)
1:eac0369: 					return dateSize;
1:eac0369: 		  if (type == Types.TIME)
1:eac0369: 					return timeSize;
1:eac0369: 		  if (type == Types.TIMESTAMP)
1:eac0369: 					return timestampSize;
1:eac0369: 		  return rsm.getColumnDisplaySize(columnNumber);
1:eac0369: 	}
1:eac0369: 	public String getStringFromDate(String dateStr)
1:eac0369: 		throws ParseException{
1:eac0369: 			if (!enableLocalized){
1:eac0369: 				return dateStr;
1:eac0369: 			}
1:eac0369: 			Date d = formatDate.parse(dateStr);
1:eac0369: 			return new java.sql.Date(d.getTime()).toString();
1:eac0369: 	}
1:eac0369: 	public String getStringFromTime(String timeStr)
1:eac0369: 		throws ParseException{
1:eac0369: 			if (!enableLocalized){
1:eac0369: 				return timeStr;
1:eac0369: 			}
1:eac0369: 			Date t = formatTime.parse(timeStr);
1:eac0369: 			return new java.sql.Time(t.getTime()).toString();
1:eac0369: 	}
1:eac0369: 	public String getStringFromValue(String val)
1:eac0369: 		throws ParseException{
1:eac0369: 			if (!enableLocalized){
1:eac0369: 				return val;
1:eac0369: 			}
1:eac0369: 			return formatNumber.parse(val).toString();
1:eac0369: 	}
1:eac0369: 	public String getStringFromTimestamp(String timestampStr)
1:eac0369: 		throws ParseException{
1:eac0369: 			if (!enableLocalized){
1:eac0369: 				return timestampStr;
1:eac0369: 			}
1:eac0369: 			Date ts = formatTimestamp.parse(timestampStr);
1:eac0369: 			return new java.sql.Timestamp(ts.getTime()).toString();
1:eac0369: 	}
1:eac0369: 	public Locale getLocale(){
1:eac0369: 			return locale;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	private final synchronized String getEnvProperty(String key) {
1:eac0369: 		String s;
1:eac0369: 		 try
1:eac0369: 		  {
1:eac0369: 				resourceKey =  key;
1:b5b1316: 				s = java.security.AccessController.doPrivileged(this);
1:eac0369: 		}
1:eac0369: 		catch (SecurityException se) {
1:eac0369: 			s = null;
1:eac0369: 		}
1:eac0369: 		//System.out.println("{"+resourceKey+"="+s+"}");
2:eac0369: 		return s;
1:eac0369: 	}
1:b5b1316: 	public final String run() {
1:eac0369: 		String s = System.getProperty(resourceKey);
1:eac0369: 		return s;
1:eac0369: 	}
1:eac0369: 	public static boolean enableLocalization(boolean mode) {
1:eac0369: 		getInstance().enableLocalized = mode;
1:eac0369: 		//re-initialized locale
1:eac0369: 		getInstance().init();
1:eac0369: 		return mode;
1:eac0369: 	}
1:eac0369: 	public boolean isLocalized(){
1:eac0369: 		return getInstance().enableLocalized;
1:eac0369: 	}
1:c465481:     public static String getMessage(String key, Object... args) {
1:c465481:         return getInstance().getTextMessage(key, args);
1:c465481:     }
1:eac0369: 	public static LocalizedOutput OutputWriter(){
1:eac0369: 		return getInstance().out;
1:eac0369: 	}
1:eac0369: 	public static LocalizedInput InputReader(){
1:eac0369: 		return getInstance().in;
1:eac0369: 	}
1:eac0369: 	public static String getNumber(long o){
1:eac0369: 		return getInstance().getNumberAsString(o);
1:eac0369: 	}
1:eac0369: 	public static String getNumber(int o){
1:eac0369: 		return getInstance().getNumberAsString(o);
1:eac0369: 	}
1:eac0369: 	public String toString(){
1:eac0369: 		String s = "toString(){\n" +
1:eac0369: 			"locale=" + (locale==null?"null":locale.toString()) + "\n" +
1:eac0369: 			"encode=" + encode + "\n" +
1:eac0369: 			"messageFile=" + messageFileName + "\n" +
1:eac0369: 			"resourceKey=" + resourceKey + "\n" +
1:eac0369: 			"enableLocalized=" + enableLocalized + " \n" +
1:eac0369: 			"dateSize=" + dateSize + "\n" +
1:eac0369: 			"timeSize=" + timeSize + "\n" +
1:eac0369: 			"timestampSize="+timestampSize+ "\n}";
1:eac0369: 			return s;
1:eac0369: 	}
1:eac0369: }
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:820eb0a
/////////////////////////////////////////////////////////////////////////
1: 					for (int i=0; objectArr != null && i<objectArr.length; i++)
commit:0b1a784
/////////////////////////////////////////////////////////////////////////
1: 	    out = new LocalizedOutput(o, encoding);
1: 	    return out;
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:953afd7
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Timestamp;
1: import java.text.DateFormat;
1: import java.text.DecimalFormat;
1: import java.text.FieldPosition;
1: import java.text.MessageFormat;
1: import java.text.NumberFormat;
1: import java.text.ParseException;
1: import java.util.Date;
1: import java.util.Locale;
1: import java.util.ResourceBundle;
1: import java.util.StringTokenizer;
/////////////////////////////////////////////////////////////////////////
1:     public final static String ENV_CODESET = "derby.ui.codeset";
1:     public final static String ENV_LOCALE = "derby.ui.locale";
/////////////////////////////////////////////////////////////////////////
1: 
1:     private LocalizedResource(){
1:     public LocalizedResource(String msgF){
1:         init(null, null, msgF, true);
1: 
1:     /**
1:      * This overload version does <b>not</b> check the environment for values of
1:      * encoding via {@link #ENV_CODESET} and locale via {@link #ENV_LOCALE}.
1:      * The others do if value of either is null. DERBY-6680.
1:      * @param encStr encoding
1:      * @param locStr locale
1:      * @param msgF message file
1:      */
1:     public LocalizedResource(String encStr, String locStr, String msgF){
1:         init(encStr,locStr,msgF, false);
1:     }
1: 
1:     public static LocalizedResource getInstance(){
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:     public void init (String encStr, String locStr, String msgF) {
1:         init(encStr, locStr, msgF, true);
1:     }
1: 
1:     private void init (String encStr, String locStr, String msgF, boolean readEnv){
1:         if (encode == null && readEnv) {
/////////////////////////////////////////////////////////////////////////
1:         if (locale==null && readEnv) {
commit:23d21a3
/////////////////////////////////////////////////////////////////////////
1: 		return formatTimestamp.format
1: 			(t, new StringBuffer(),
1: 			 new java.text.FieldPosition(0)).toString();
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:5465561
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             else if (type == Types.NUMERIC || type == Types.DECIMAL) {
1:                 return getNumberAsString(rs.getBigDecimal(columnNumber));
commit:c465481
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     public String getTextMessage(String key, Object... objectArr) {
/////////////////////////////////////////////////////////////////////////
1:     public static String getMessage(String key, Object... args) {
1:         return getInstance().getTextMessage(key, args);
1:     }
commit:a02269e
/////////////////////////////////////////////////////////////////////////
0:         return getTextMessage(key, new Object[0]);
commit:ccabbd0
/////////////////////////////////////////////////////////////////////////
0: 				// BigDecimal JDBC calls are supported on this platform, but
0: 				// use getObject() so that the class can be compiled against
0: 				// the JSR-169 libraries.
0: 				return getNumberAsString(rs.getObject(columnNumber));
commit:9a55084
/////////////////////////////////////////////////////////////////////////
1: 			res = ResourceBundle.getBundle(messageFileName);
commit:129b076
/////////////////////////////////////////////////////////////////////////
0: 				return getNumberAsString(rs.getBigDecimal(columnNumber));
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:b5b1316
/////////////////////////////////////////////////////////////////////////
1: public final class LocalizedResource  implements java.security.PrivilegedAction<String> {
/////////////////////////////////////////////////////////////////////////
1: 				s = java.security.AccessController.doPrivileged(this);
/////////////////////////////////////////////////////////////////////////
1: 	public final String run() {
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:678868b
/////////////////////////////////////////////////////////////////////////
1:     // Resets the 'local' field to null. This is not needed for normal
1:     // operations, however, when executing sql files in our junit tests, we use
1:     // the same jvm and thus the locale will get loaded only once, resulting
1:     // in trouble when testing the localization for ij.
1:     public static void resetLocalizedResourceCache()
1:     {
1:         local=null;
1:     }
commit:6a29676
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:0070f97
/////////////////////////////////////////////////////////////////////////
0: import java.lang.reflect.Method;
/////////////////////////////////////////////////////////////////////////
0: 	private static final boolean SUPPORTS_BIG_DECIMAL_CALLS;
0: 		boolean supportsBigDecimalCalls;
0: 			// This class attempts to make a call to a 
0: 			// ResultSet.getBigDecimal method, which may not be available.
0: 			// For instance, java.math.BigDecimal is not available with
0: 			// J2ME/CDC/Foundation 1.0 profile.
0: 			supportsBigDecimalCalls = true;
0: 			// And no methods using BigDecimal are available with JSR169 spec.
0: 			Method getbd = ResultSet.class.getMethod("getBigDecimal", new Class[] {int.class});
0: 			supportsBigDecimalCalls = true;
0: 			supportsBigDecimalCalls = false;
0: 		SUPPORTS_BIG_DECIMAL_CALLS = supportsBigDecimalCalls;
/////////////////////////////////////////////////////////////////////////
0: 			else if (SUPPORTS_BIG_DECIMAL_CALLS && (type == Types.NUMERIC || type == Types.DECIMAL)) {
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:3dc2ce4
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:1edcdb3
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 	public LocalizedInput getNewEncodedInput(InputStream i, String encoding) {
1: 		try {
1: 	          return new LocalizedInput(i,encoding);
1: 		}
1: 		catch (UnsupportedEncodingException e){
1: 			
1: 		}
1: 		return new LocalizedInput(i);
1:         }
1: 
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:a5a98ce
/////////////////////////////////////////////////////////////////////////
0: 	private static final boolean HAVE_BIG_DECIMAL;
0: 	static {
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * Get a new LocalizedOutput with the given encoding.
1: 	 * @throws UnsupportedEncodingException
1: 	 */
1: 	public LocalizedOutput getNewEncodedOutput(OutputStream o,
1: 			String encoding) throws UnsupportedEncodingException{
0: 		return new LocalizedOutput(o, encoding);
1: 	}
commit:18c4da7
/////////////////////////////////////////////////////////////////////////
1: 		
1: 		// If null at this point then the default encoding
1: 		// will be always used.
1: 
/////////////////////////////////////////////////////////////////////////
1: 		out = getNewOutput(System.out);
1: 		in = getNewInput(System.in);
/////////////////////////////////////////////////////////////////////////
1: 			if (encode != null)
1: 			    return new LocalizedInput(i,encode);
1: 			
1: 		return new LocalizedInput(i);
1: 			if (encode != null)
1: 			    return new LocalizedOutput(o,encode);
1: 		return new LocalizedOutput(o);
/////////////////////////////////////////////////////////////////////////
commit:7a92d1f
/////////////////////////////////////////////////////////////////////////
0: public final class LocalizedResource  implements java.security.PrivilegedAction {
commit:985fc85
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.iapi.tools.i18n.LocalizedResource
1: 
0:    Copyright 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:a8ff4fd
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.tools.i18n
0:    (C) Copyright IBM Corp. 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: package org.apache.derby.iapi.tools.i18n;
1: 
1: import java.io.InputStream;
1: import java.io.OutputStream;
1: import java.io.UnsupportedEncodingException;
1: 
0: import java.util.ResourceBundle;
0: import java.util.Date;
0: import java.util.Locale;
0: import java.util.StringTokenizer;
1: 
0: import java.text.MessageFormat;
0: import java.text.NumberFormat;
0: import java.text.DecimalFormat;
0: import java.text.DateFormat;
0: import java.text.ParseException;
0: import java.text.FieldPosition;
1: 
0: import java.sql.Timestamp;
1: import java.sql.ResultSet;
1: import java.sql.ResultSetMetaData;
1: import java.sql.SQLException;
1: import java.sql.Types;
1: 
1: 
0: public class LocalizedResource  implements java.security.PrivilegedAction {
0: 	/**
0: 			IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2004;
1: 
1: 	private ResourceBundle res;
1: 	private Locale locale;
1: 	private String encode;
1: 	private final static String MESSAGE_FILE = "org.apache.derby.loc.toolsmessages";
0: 	private final static String ENV_CODESET = "derby.ui.codeset";
0: 	private final static String ENV_LOCALE = "derby.ui.locale";
1: 	private String messageFileName;
1: 	private String resourceKey;
1: 	private LocalizedOutput out;
1: 	private LocalizedInput in;
1: 	private boolean enableLocalized;
0: 	private boolean unicodeEscape;
1: 	private static LocalizedResource local;
1: 	private int dateSize;
1: 	private int timeSize;
1: 	private int timestampSize;
1: 	private DateFormat formatDate;
1: 	private DateFormat formatTime;
1: 	private DateFormat formatTimestamp;
1: 	private NumberFormat formatNumber;
1:     private DecimalFormat formatDecimal;
0: 	public LocalizedResource(){
1: 		init();
1: 	}
0: 	public LocalizedResource(String encStr, String locStr, String msgF){
0: 		init(encStr,locStr,msgF);
1: 	}
0: 	public static LocalizedResource getInstance(){
1: 		if (local == null){
1: 			local = new  LocalizedResource();
1: 		}
1: 		return local;
1: 	}
1: 	public void init(){
1: 		init(null,null,null);
1: 	}
0: 	public void init (String encStr, String locStr, String msgF){
1: 		if (encStr != null){
1: 			encode = encStr;
1: 		}
1: 		//then get encoding string from environment
0: 		if (encode == null) {
1: 			String eEncode = getEnvProperty(ENV_CODESET);
1: 			if ( eEncode != null ){
1: 				encode = eEncode;
1: 			}
1: 		}
0: 		//last chance: get default encoding
0: 		if (encode == null ){
0: 		 	encode = new java.io.InputStreamReader(System.in).getEncoding();
1: 		}
1: 		//get locale string from the caller first
1: 		locale = getNewLocale(locStr);
1: 
1: 		//if null, get locale again from the environment variable
0: 		if (locale==null) {
1: 			String s = getEnvProperty(ENV_LOCALE);
1: 			locale = getNewLocale(s);
1: 		}
1: 		//get the default locale if forced
1: 		if (locale==null){
1: 			locale = Locale.getDefault();
1: 		}
1: 		if (msgF != null) {
1: 			messageFileName = msgF;
1: 		}
1: 		else {
1: 			messageFileName = MESSAGE_FILE;
1: 		}
1: 		//create default in/out
1: 		try {
0: 			out = new LocalizedOutput(System.out,encode);
1: 		}
1: 		catch(UnsupportedEncodingException e){
0: 			out = new LocalizedOutput(System.out);
1: 		}
1: 		try {
0: 			in = new LocalizedInput(System.in, encode);
1: 		}
1: 		catch(UnsupportedEncodingException e){
0: 			in = new LocalizedInput(System.in);
1: 		}
1: 
1: 		//for faster code: get the format objs
1: 		if (enableLocalized && locale != null){
1: 			formatDecimal = (DecimalFormat)DecimalFormat.getInstance(locale);
1: 			formatNumber = NumberFormat.getInstance(locale);
1: 			formatDate = DateFormat.getDateInstance(DateFormat.LONG,locale);
1: 			formatTime = DateFormat.getTimeInstance(DateFormat.LONG,locale);
1: 			formatTimestamp = DateFormat.getDateTimeInstance(DateFormat.LONG,
1: 													DateFormat.LONG, locale);
1: 		}
1: 		else {
1: 			formatDecimal = (DecimalFormat)DecimalFormat.getInstance();
1: 			formatNumber = NumberFormat.getInstance();
1: 			formatDate = DateFormat.getDateInstance(DateFormat.LONG);
1: 			formatTime = DateFormat.getTimeInstance(DateFormat.LONG);
1: 			formatTimestamp = DateFormat.getDateTimeInstance(DateFormat.LONG,
1: 													DateFormat.LONG);
1: 		}
1: 		//initialize display sizes for columns
1: 		initMaxSizes2();
1: 	}
1: 	//get the message file resource according to the locale
1: 	//fall back to English message file if locale message file is not found
1: 	private void setResource(){
1: 		if (res != null){
1: 			return;
1: 		}
1: 		if ( locale == null || locale.toString().equals("none") ){
0: 			res = ResourceBundle.getBundle(MESSAGE_FILE);
1: 		}
1: 		else
1: 		try {
1: 			res = ResourceBundle.getBundle(messageFileName,locale);
1: 		}
1: 		catch(java.util.MissingResourceException e){
1: 			res = ResourceBundle.getBundle(messageFileName,Locale.ENGLISH);
1: 		}
1: 	}
1: 	private void initMaxSizes2(){
1: 		dateSize = 0;
1: 		timeSize = 0;
1: 		timestampSize = 0;
1: 
1: 		int len;
1: 
1: 		// check the date & timestamp max length
1: 		// 3900/01/28 !! original devloper thought they were getting 2000/01/28
1: 		Date d = new Date(60907276800000L);
1: 		Timestamp t = new Timestamp(d.getTime());
1: 		for(int month  = 0 ;  month <=11 ; month++, d.setTime(d.getTime() + (30L * 24L * 60L * 60L * 1000L))) {
1: 			len=getDateAsString(d).length();
1: 
1: 			if(len > dateSize ) {
1: 				dateSize=len;
1: 			}
1: 
1: 			t.setTime(d.getTime() + ((((21L * 60L) + 59L) * 60L) + 59L));
1: 			len=getTimestampAsString(t).length();
1: 
1: 			if(len > timestampSize) {
1: 				timestampSize=len;
1: 			}
1: 		}
1: 
1: 		// set the time max length
1: 		// minimum of 18 because the old buggy code always used 18
1: 		len = 18;
1: 		for (int hour = 0 ; hour < 24; hour++) {
1: 
1: 			long secs = (hour * 3600L) + (59 * 60L) + 59L;
1: 
1: 			long ms = secs * 1000L;
1: 
1: 			Date td = new Date(ms);
1: 
1: 			String fd = formatTime.format(td);
1: 
1: 			if (fd.length() > len)
1: 				len = fd.length();
1: 		}
1: 		timeSize=len;
1: 
1: 	}
1: 	public LocalizedInput getNewInput(InputStream i) {
1: 		try {
0: 			return new LocalizedInput(i,encode);
1: 		}
1: 		catch (UnsupportedEncodingException e){
0: 			return new LocalizedInput(i);
1: 		}
1: 	}
1: 
1: 	public LocalizedOutput getNewOutput(OutputStream o){
1: 		try {
0: 			return new LocalizedOutput(o,encode);
1: 		}
1: 		catch(UnsupportedEncodingException e){
0: 			return new LocalizedOutput(o);
1: 		}
1: 	}
0: 	public String getTextMessage(String key ) {
0: 		if ( res == null){
1: 			setResource();
1: 		}
0: 		String s = key;
1: 		try{
0: 			s = res.getString(key);
1: 		} catch (Exception e) {
0: 			s = key;
1: 		}
0: 		//System.out.println(local.toString());
0: 		//System.out.println("GetKey:"+key+"="+s);
1: 		return s;
1: 	}
0: 	public String getTextMessage(String key, Object o){
0: 			Object [] att=new Object[] {o};
0: 			return getTextMessage(key,att);
1: 	}
0: 	public String getTextMessage(String key, Object o1, Object o2){
0: 			Object [] att=new Object[] {o1,o2};
0: 			return getTextMessage(key,att);
1: 	}
0: 	public String getTextMessage(String key, Object o1, Object o2, Object o3){
0: 			Object [] att=new Object[] {o1,o2,o3};
0: 			return getTextMessage(key,att);
1: 	}
0: 	public String getTextMessage(String key, Object o1, Object o2, Object o3, Object o4){
0: 			Object [] att=new Object[] {o1,o2,o3,o4};
0: 			return getTextMessage(key,att);
1: 	}
1: 	private Locale getNewLocale(String locStr){
1: 			String l="", r="", v="";
1: 			StringTokenizer st;
1: 			if (locStr==null) {
1: 				return null;
1: 			}
1: 			st=new StringTokenizer(locStr, "_");
1: 			try {
1: 				l=st.nextToken();
1: 				if(st.hasMoreTokens()==true)
1: 					r=st.nextToken();
1: 				if(st.hasMoreTokens()==true)
1: 					v=st.nextToken();
1: 				return new Locale(l,r,v);
1: 			} catch (Exception e) {
1: 				return null;
1: 			}
1: 	}
0: 	public String getTextMessage(String key, Object [] objectArr) {
1: 		if (res == null){
1: 			setResource();
1: 		}
1: 			try{
1: 				return MessageFormat.format(res.getString(key), objectArr);
1: 			} catch (Exception e) {
1: 					String tmpFormat = key;
0: 					for (int i=0; i<objectArr.length; i++)
1: 						tmpFormat = tmpFormat + ", <{" + (i) + "}>";
1: 					return MessageFormat.format(tmpFormat, objectArr);
1: 			}
1: 	}
1: 	public String getLocalizedString(ResultSet rs,
1: 										ResultSetMetaData rsm,
1: 										int columnNumber) throws SQLException{
1: 			if (!enableLocalized){
1: 				return rs.getString(columnNumber);
1: 			}
1: 			int type = rsm.getColumnType(columnNumber);
1: 			if ( type == Types.DATE ) {
1: 				return getDateAsString(rs.getDate(columnNumber));
1: 			}
1: 			else if ( type == Types.INTEGER ||	type == Types.SMALLINT ||
1: 					type == Types.BIGINT ||	type == Types.TINYINT ) {
1: 				return getNumberAsString(rs.getLong(columnNumber));
1: 			}
1: 			else if (type == Types.REAL || 	type == Types.FLOAT ||
1: 					type == Types.DOUBLE ) {
1: 				return getNumberAsString(rs.getDouble(columnNumber));
1: 			}
0: 			else if (type == Types.NUMERIC || type == Types.DECIMAL ) {
0: 				return	getNumberAsString(rs.getBigDecimal(columnNumber,
0: 											rsm.getScale(columnNumber)));
1: 			}
1: 			else if (type == Types.TIME ) {
1: 				return getTimeAsString(rs.getTime(columnNumber));
1: 			}
1: 			else if (type == Types.TIMESTAMP ) {
1: 				return getTimestampAsString(rs.getTimestamp(columnNumber));
1: 			}
1: 			return rs.getString(columnNumber);
1: 		}
1: 
1: 	public String getDateAsString(Date d){
1: 		if (!enableLocalized){
1: 			return d.toString();
1: 		}
1: 		return formatDate.format(d);
1: 	}
1: 	public String getTimeAsString(Date t){
1: 		if (!enableLocalized){
1: 			return t.toString();
1: 		}
1: 		return formatTime.format(t,	new StringBuffer(),
1: 									  new java.text.FieldPosition(0)).toString();
1: 	}
1: 	public String getNumberAsString(int o){
1: 		if (enableLocalized){
1: 			return formatNumber.format(o);
1: 		}
1: 		else {
1: 			return String.valueOf(o);
1: 		}
1: 	}
1: 	public String getNumberAsString(long o){
1: 		if (enableLocalized){
1: 			return formatNumber.format(o);
1: 		}
1: 		else{
1: 			return String.valueOf(o);
1: 		}
1: 	}
1: 	public String getNumberAsString(Object o){
1: 		if (enableLocalized){
1: 			return formatNumber.format(o, new StringBuffer(),
1: 										new FieldPosition(0)).toString();
1: 		}
1: 		else {
1: 			return o.toString();
1: 		}
1: 	}
1: 	public String getNumberAsString(double o){
1: 		if (!enableLocalized) {
1: 			return String.valueOf(o);
1: 		}
1: 		return formatDecimal.format(o);
1: 	}
1: 	public String getTimestampAsString(Timestamp t){
1: 		if (!enableLocalized){
1: 			return t.toString();
1: 		}
1: 		return formatTime.format(t,	new StringBuffer(),
1: 									new java.text.FieldPosition(0)).toString();
1: 	}
1: 	public int getColumnDisplaySize(ResultSetMetaData rsm,
1: 										int columnNumber) throws SQLException{
1: 		  if (!enableLocalized){
1: 				return rsm.getColumnDisplaySize(columnNumber);
1: 		  }
1: 		  int type = rsm.getColumnType(columnNumber);
1: 		  if (type == Types.DATE)
1: 					return dateSize;
1: 		  if (type == Types.TIME)
1: 					return timeSize;
1: 		  if (type == Types.TIMESTAMP)
1: 					return timestampSize;
1: 		  return rsm.getColumnDisplaySize(columnNumber);
1: 	}
1: 	public String getStringFromDate(String dateStr)
1: 		throws ParseException{
1: 			if (!enableLocalized){
1: 				return dateStr;
1: 			}
1: 			Date d = formatDate.parse(dateStr);
1: 			return new java.sql.Date(d.getTime()).toString();
1: 	}
1: 	public String getStringFromTime(String timeStr)
1: 		throws ParseException{
1: 			if (!enableLocalized){
1: 				return timeStr;
1: 			}
1: 			Date t = formatTime.parse(timeStr);
1: 			return new java.sql.Time(t.getTime()).toString();
1: 	}
1: 	public String getStringFromValue(String val)
1: 		throws ParseException{
1: 			if (!enableLocalized){
1: 				return val;
1: 			}
1: 			return formatNumber.parse(val).toString();
1: 	}
1: 	public String getStringFromTimestamp(String timestampStr)
1: 		throws ParseException{
1: 			if (!enableLocalized){
1: 				return timestampStr;
1: 			}
1: 			Date ts = formatTimestamp.parse(timestampStr);
1: 			return new java.sql.Timestamp(ts.getTime()).toString();
1: 	}
1: 	public Locale getLocale(){
1: 			return locale;
1: 	}
0: 	public String getEncode(){
0: 		return encode;
1: 	}
1: 
1: 	private final synchronized String getEnvProperty(String key) {
1: 		String s;
1: 		 try
1: 		  {
1: 				resourceKey =  key;
0: 				s = (String) java.security.AccessController.doPrivileged(this);
1: 		}
1: 		catch (SecurityException se) {
1: 			s = null;
1: 		}
1: 		//System.out.println("{"+resourceKey+"="+s+"}");
1: 		return s;
1: 	}
0: 	public final Object run() {
1: 		String s = System.getProperty(resourceKey);
1: 		return s;
1: 	}
1: 	public static boolean enableLocalization(boolean mode) {
1: 		getInstance().enableLocalized = mode;
1: 		//re-initialized locale
1: 		getInstance().init();
1: 		return mode;
1: 	}
1: 	public boolean isLocalized(){
1: 		return getInstance().enableLocalized;
1: 	}
0: 	public static String getMessage(String key){
0: 		return getInstance().getTextMessage(key);
1: 	}
0: 	public static String getMessage(String key, Object o1){
0: 		return getInstance().getTextMessage(key,o1);
1: 	}
0: 	public static String getMessage(String key, Object o1, Object o2){
0: 		return getInstance().getTextMessage(key,o1,o2);
1: 	}
0: 	public static String getMessage(String key, Object o1, Object o2, Object o3){
0: 		return getInstance().getTextMessage(key,o1,o2,o3);
1: 	}
0: 	public static String getMessage(String key, Object o1, Object o2, Object o3, Object o4){
0: 		return getInstance().getTextMessage(key,o1,o2,o3,o4);
1: 	}
1: 	public static LocalizedOutput OutputWriter(){
1: 		return getInstance().out;
1: 	}
1: 	public static LocalizedInput InputReader(){
1: 		return getInstance().in;
1: 	}
1: 	public static String getNumber(long o){
1: 		return getInstance().getNumberAsString(o);
1: 	}
1: 	public static String getNumber(int o){
1: 		return getInstance().getNumberAsString(o);
1: 	}
0: 	public static void setUnicodeEscape(boolean u){
0: 		getInstance().unicodeEscape = u;
1: 	}
0: 	public static boolean getUnicodeEscape(){
0: 		return getInstance().unicodeEscape;
1: 	}
1: 	public String toString(){
1: 		String s = "toString(){\n" +
1: 			"locale=" + (locale==null?"null":locale.toString()) + "\n" +
1: 			"encode=" + encode + "\n" +
1: 			"messageFile=" + messageFileName + "\n" +
1: 			"resourceKey=" + resourceKey + "\n" +
1: 			"enableLocalized=" + enableLocalized + " \n" +
0: 			"unicodeEscape=" + unicodeEscape + "\n" +
1: 			"dateSize=" + dateSize + "\n" +
1: 			"timeSize=" + timeSize + "\n" +
1: 			"timestampSize="+timestampSize+ "\n}";
1: 			return s;
1: 	}
1: }
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:e1b8b60
/////////////////////////////////////////////////////////////////////////
0: 	private static boolean HAVE_BIG_DECIMAL;
0: 	
0: 	{
0: 		boolean haveBigDecimal;
0: 		try {
0: 			Class.forName("java.math.BigDecimal");
0: 			haveBigDecimal = true;
0: 		} catch (Throwable t) {
0: 			haveBigDecimal = false;
0: 		}
0: 		HAVE_BIG_DECIMAL = haveBigDecimal;
0: 	}
0: 	
/////////////////////////////////////////////////////////////////////////
0: 			else if (HAVE_BIG_DECIMAL && (type == Types.NUMERIC || type == Types.DECIMAL)) {
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.tools.i18n
0:    (C) Copyright IBM Corp. 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: package org.apache.derby.iapi.tools.i18n;
0: 
0: import java.io.InputStream;
0: import java.io.OutputStream;
0: import java.io.UnsupportedEncodingException;
0: 
0: import java.util.ResourceBundle;
0: import java.util.Date;
0: import java.util.Locale;
0: import java.util.StringTokenizer;
0: 
0: import java.text.MessageFormat;
0: import java.text.NumberFormat;
0: import java.text.DecimalFormat;
0: import java.text.DateFormat;
0: import java.text.ParseException;
0: import java.text.FieldPosition;
0: 
0: import java.sql.Timestamp;
0: import java.sql.ResultSet;
0: import java.sql.ResultSetMetaData;
0: import java.sql.SQLException;
0: import java.sql.Types;
0: 
0: 
0: public class LocalizedResource  implements java.security.PrivilegedAction {
0: 	/**
0: 			IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2004;
0: 
0: 	private ResourceBundle res;
0: 	private Locale locale;
0: 	private String encode;
0: 	private final static String MESSAGE_FILE = "org.apache.derby.loc.toolsmessages";
0: 	private final static String ENV_CODESET = "derby.ui.codeset";
0: 	private final static String ENV_LOCALE = "derby.ui.locale";
0: 	private String messageFileName;
0: 	private String resourceKey;
0: 	private LocalizedOutput out;
0: 	private LocalizedInput in;
0: 	private boolean enableLocalized;
0: 	private boolean unicodeEscape;
0: 	private static LocalizedResource local;
0: 	private int dateSize;
0: 	private int timeSize;
0: 	private int timestampSize;
0: 	private DateFormat formatDate;
0: 	private DateFormat formatTime;
0: 	private DateFormat formatTimestamp;
0: 	private NumberFormat formatNumber;
0:     private DecimalFormat formatDecimal;
0: 	public LocalizedResource(){
0: 		init();
0: 	}
0: 	public LocalizedResource(String encStr, String locStr, String msgF){
0: 		init(encStr,locStr,msgF);
0: 	}
0: 	public static LocalizedResource getInstance(){
0: 		if (local == null){
0: 			local = new  LocalizedResource();
0: 		}
0: 		return local;
0: 	}
0: 	public void init(){
0: 		init(null,null,null);
0: 	}
0: 	public void init (String encStr, String locStr, String msgF){
0: 		if (encStr != null){
0: 			encode = encStr;
0: 		}
0: 		//then get encoding string from environment
0: 		if (encode == null) {
0: 			String eEncode = getEnvProperty(ENV_CODESET);
0: 			if ( eEncode != null ){
0: 				encode = eEncode;
0: 			}
0: 		}
0: 		//last chance: get default encoding
0: 		if (encode == null ){
0: 		 	encode = new java.io.InputStreamReader(System.in).getEncoding();
0: 		}
0: 		//get locale string from the caller first
0: 		locale = getNewLocale(locStr);
0: 
0: 		//if null, get locale again from the environment variable
0: 		if (locale==null) {
0: 			String s = getEnvProperty(ENV_LOCALE);
0: 			locale = getNewLocale(s);
0: 		}
0: 		//get the default locale if forced
0: 		if (locale==null){
0: 			locale = Locale.getDefault();
0: 		}
0: 		if (msgF != null) {
0: 			messageFileName = msgF;
0: 		}
0: 		else {
0: 			messageFileName = MESSAGE_FILE;
0: 		}
0: 		//create default in/out
0: 		try {
0: 			out = new LocalizedOutput(System.out,encode);
0: 		}
0: 		catch(UnsupportedEncodingException e){
0: 			out = new LocalizedOutput(System.out);
0: 		}
0: 		try {
0: 			in = new LocalizedInput(System.in, encode);
0: 		}
0: 		catch(UnsupportedEncodingException e){
0: 			in = new LocalizedInput(System.in);
0: 		}
0: 
0: 		//for faster code: get the format objs
0: 		if (enableLocalized && locale != null){
0: 			formatDecimal = (DecimalFormat)DecimalFormat.getInstance(locale);
0: 			formatNumber = NumberFormat.getInstance(locale);
0: 			formatDate = DateFormat.getDateInstance(DateFormat.LONG,locale);
0: 			formatTime = DateFormat.getTimeInstance(DateFormat.LONG,locale);
0: 			formatTimestamp = DateFormat.getDateTimeInstance(DateFormat.LONG,
0: 													DateFormat.LONG, locale);
0: 		}
0: 		else {
0: 			formatDecimal = (DecimalFormat)DecimalFormat.getInstance();
0: 			formatNumber = NumberFormat.getInstance();
0: 			formatDate = DateFormat.getDateInstance(DateFormat.LONG);
0: 			formatTime = DateFormat.getTimeInstance(DateFormat.LONG);
0: 			formatTimestamp = DateFormat.getDateTimeInstance(DateFormat.LONG,
0: 													DateFormat.LONG);
0: 		}
0: 		//initialize display sizes for columns
0: 		initMaxSizes2();
0: 	}
0: 	//get the message file resource according to the locale
0: 	//fall back to English message file if locale message file is not found
0: 	private void setResource(){
0: 		if (res != null){
0: 			return;
0: 		}
0: 		if ( locale == null || locale.toString().equals("none") ){
0: 			res = ResourceBundle.getBundle(MESSAGE_FILE);
0: 		}
0: 		else
0: 		try {
0: 			res = ResourceBundle.getBundle(messageFileName,locale);
0: 		}
0: 		catch(java.util.MissingResourceException e){
0: 			res = ResourceBundle.getBundle(messageFileName,Locale.ENGLISH);
0: 		}
0: 	}
0: 	private void initMaxSizes2(){
0: 		dateSize = 0;
0: 		timeSize = 0;
0: 		timestampSize = 0;
0: 
0: 		int len;
0: 
0: 		// check the date & timestamp max length
0: 		// 3900/01/28 !! original devloper thought they were getting 2000/01/28
0: 		Date d = new Date(60907276800000L);
0: 		Timestamp t = new Timestamp(d.getTime());
0: 		for(int month  = 0 ;  month <=11 ; month++, d.setTime(d.getTime() + (30L * 24L * 60L * 60L * 1000L))) {
0: 			len=getDateAsString(d).length();
0: 
0: 			if(len > dateSize ) {
0: 				dateSize=len;
0: 			}
0: 
0: 			t.setTime(d.getTime() + ((((21L * 60L) + 59L) * 60L) + 59L));
0: 			len=getTimestampAsString(t).length();
0: 
0: 			if(len > timestampSize) {
0: 				timestampSize=len;
0: 			}
0: 		}
0: 
0: 		// set the time max length
0: 		// minimum of 18 because the old buggy code always used 18
0: 		len = 18;
0: 		for (int hour = 0 ; hour < 24; hour++) {
0: 
0: 			long secs = (hour * 3600L) + (59 * 60L) + 59L;
0: 
0: 			long ms = secs * 1000L;
0: 
0: 			Date td = new Date(ms);
0: 
0: 			String fd = formatTime.format(td);
0: 
0: 			if (fd.length() > len)
0: 				len = fd.length();
0: 		}
0: 		timeSize=len;
0: 
0: 	}
0: 	public LocalizedInput getNewInput(InputStream i) {
0: 		try {
0: 			return new LocalizedInput(i,encode);
0: 		}
0: 		catch (UnsupportedEncodingException e){
0: 			return new LocalizedInput(i);
0: 		}
0: 	}
0: 
0: 	public LocalizedOutput getNewOutput(OutputStream o){
0: 		try {
0: 			return new LocalizedOutput(o,encode);
0: 		}
0: 		catch(UnsupportedEncodingException e){
0: 			return new LocalizedOutput(o);
0: 		}
0: 	}
0: 	public String getTextMessage(String key ) {
0: 		if ( res == null){
0: 			setResource();
0: 		}
0: 		String s = key;
0: 		try{
0: 			s = res.getString(key);
0: 		} catch (Exception e) {
0: 			s = key;
0: 		}
0: 		//System.out.println(local.toString());
0: 		//System.out.println("GetKey:"+key+"="+s);
0: 		return s;
0: 	}
0: 	public String getTextMessage(String key, Object o){
0: 			Object [] att=new Object[] {o};
0: 			return getTextMessage(key,att);
0: 	}
0: 	public String getTextMessage(String key, Object o1, Object o2){
0: 			Object [] att=new Object[] {o1,o2};
0: 			return getTextMessage(key,att);
0: 	}
0: 	public String getTextMessage(String key, Object o1, Object o2, Object o3){
0: 			Object [] att=new Object[] {o1,o2,o3};
0: 			return getTextMessage(key,att);
0: 	}
0: 	public String getTextMessage(String key, Object o1, Object o2, Object o3, Object o4){
0: 			Object [] att=new Object[] {o1,o2,o3,o4};
0: 			return getTextMessage(key,att);
0: 	}
0: 	private Locale getNewLocale(String locStr){
0: 			String l="", r="", v="";
0: 			StringTokenizer st;
0: 			if (locStr==null) {
0: 				return null;
0: 			}
0: 			st=new StringTokenizer(locStr, "_");
0: 			try {
0: 				l=st.nextToken();
0: 				if(st.hasMoreTokens()==true)
0: 					r=st.nextToken();
0: 				if(st.hasMoreTokens()==true)
0: 					v=st.nextToken();
0: 				return new Locale(l,r,v);
0: 			} catch (Exception e) {
0: 				return null;
0: 			}
0: 	}
0: 	public String getTextMessage(String key, Object [] objectArr) {
0: 		if (res == null){
0: 			setResource();
0: 		}
0: 			try{
0: 				return MessageFormat.format(res.getString(key), objectArr);
0: 			} catch (Exception e) {
0: 					String tmpFormat = key;
0: 					for (int i=0; i<objectArr.length; i++)
0: 						tmpFormat = tmpFormat + ", <{" + (i) + "}>";
0: 					return MessageFormat.format(tmpFormat, objectArr);
0: 			}
0: 	}
0: 	public String getLocalizedString(ResultSet rs,
0: 										ResultSetMetaData rsm,
0: 										int columnNumber) throws SQLException{
0: 			if (!enableLocalized){
0: 				return rs.getString(columnNumber);
0: 			}
0: 			int type = rsm.getColumnType(columnNumber);
0: 			if ( type == Types.DATE ) {
0: 				return getDateAsString(rs.getDate(columnNumber));
0: 			}
0: 			else if ( type == Types.INTEGER ||	type == Types.SMALLINT ||
0: 					type == Types.BIGINT ||	type == Types.TINYINT ) {
0: 				return getNumberAsString(rs.getLong(columnNumber));
0: 			}
0: 			else if (type == Types.REAL || 	type == Types.FLOAT ||
0: 					type == Types.DOUBLE ) {
0: 				return getNumberAsString(rs.getDouble(columnNumber));
0: 			}
0: 			else if (type == Types.NUMERIC || type == Types.DECIMAL ) {
0: 				return	getNumberAsString(rs.getBigDecimal(columnNumber,
0: 											rsm.getScale(columnNumber)));
0: 			}
0: 			else if (type == Types.TIME ) {
0: 				return getTimeAsString(rs.getTime(columnNumber));
0: 			}
0: 			else if (type == Types.TIMESTAMP ) {
0: 				return getTimestampAsString(rs.getTimestamp(columnNumber));
0: 			}
0: 			return rs.getString(columnNumber);
0: 		}
0: 
0: 	public String getDateAsString(Date d){
0: 		if (!enableLocalized){
0: 			return d.toString();
0: 		}
0: 		return formatDate.format(d);
0: 	}
0: 	public String getTimeAsString(Date t){
0: 		if (!enableLocalized){
0: 			return t.toString();
0: 		}
0: 		return formatTime.format(t,	new StringBuffer(),
0: 									  new java.text.FieldPosition(0)).toString();
0: 	}
0: 	public String getNumberAsString(int o){
0: 		if (enableLocalized){
0: 			return formatNumber.format(o);
0: 		}
0: 		else {
0: 			return String.valueOf(o);
0: 		}
0: 	}
0: 	public String getNumberAsString(long o){
0: 		if (enableLocalized){
0: 			return formatNumber.format(o);
0: 		}
0: 		else{
0: 			return String.valueOf(o);
0: 		}
0: 	}
0: 	public String getNumberAsString(Object o){
0: 		if (enableLocalized){
0: 			return formatNumber.format(o, new StringBuffer(),
0: 										new FieldPosition(0)).toString();
0: 		}
0: 		else {
0: 			return o.toString();
0: 		}
0: 	}
0: 	public String getNumberAsString(double o){
0: 		if (!enableLocalized) {
0: 			return String.valueOf(o);
0: 		}
0: 		return formatDecimal.format(o);
0: 	}
0: 	public String getTimestampAsString(Timestamp t){
0: 		if (!enableLocalized){
0: 			return t.toString();
0: 		}
0: 		return formatTime.format(t,	new StringBuffer(),
0: 									new java.text.FieldPosition(0)).toString();
0: 	}
0: 	public int getColumnDisplaySize(ResultSetMetaData rsm,
0: 										int columnNumber) throws SQLException{
0: 		  if (!enableLocalized){
0: 				return rsm.getColumnDisplaySize(columnNumber);
0: 		  }
0: 		  int type = rsm.getColumnType(columnNumber);
0: 		  if (type == Types.DATE)
0: 					return dateSize;
0: 		  if (type == Types.TIME)
0: 					return timeSize;
0: 		  if (type == Types.TIMESTAMP)
0: 					return timestampSize;
0: 		  return rsm.getColumnDisplaySize(columnNumber);
0: 	}
0: 	public String getStringFromDate(String dateStr)
0: 		throws ParseException{
0: 			if (!enableLocalized){
0: 				return dateStr;
0: 			}
0: 			Date d = formatDate.parse(dateStr);
0: 			return new java.sql.Date(d.getTime()).toString();
0: 	}
0: 	public String getStringFromTime(String timeStr)
0: 		throws ParseException{
0: 			if (!enableLocalized){
0: 				return timeStr;
0: 			}
0: 			Date t = formatTime.parse(timeStr);
0: 			return new java.sql.Time(t.getTime()).toString();
0: 	}
0: 	public String getStringFromValue(String val)
0: 		throws ParseException{
0: 			if (!enableLocalized){
0: 				return val;
0: 			}
0: 			return formatNumber.parse(val).toString();
0: 	}
0: 	public String getStringFromTimestamp(String timestampStr)
0: 		throws ParseException{
0: 			if (!enableLocalized){
0: 				return timestampStr;
0: 			}
0: 			Date ts = formatTimestamp.parse(timestampStr);
0: 			return new java.sql.Timestamp(ts.getTime()).toString();
0: 	}
0: 	public Locale getLocale(){
0: 			return locale;
0: 	}
0: 	public String getEncode(){
0: 		return encode;
0: 	}
0: 
0: 	private final synchronized String getEnvProperty(String key) {
0: 		String s;
0: 		 try
0: 		  {
0: 				resourceKey =  key;
0: 				s = (String) java.security.AccessController.doPrivileged(this);
0: 		}
0: 		catch (SecurityException se) {
0: 			s = null;
0: 		}
0: 		//System.out.println("{"+resourceKey+"="+s+"}");
0: 		return s;
0: 	}
0: 	public final Object run() {
0: 		String s = System.getProperty(resourceKey);
0: 		return s;
0: 	}
0: 	public static boolean enableLocalization(boolean mode) {
0: 		getInstance().enableLocalized = mode;
0: 		//re-initialized locale
0: 		getInstance().init();
0: 		return mode;
0: 	}
0: 	public boolean isLocalized(){
0: 		return getInstance().enableLocalized;
0: 	}
0: 	public static String getMessage(String key){
0: 		return getInstance().getTextMessage(key);
0: 	}
0: 	public static String getMessage(String key, Object o1){
0: 		return getInstance().getTextMessage(key,o1);
0: 	}
0: 	public static String getMessage(String key, Object o1, Object o2){
0: 		return getInstance().getTextMessage(key,o1,o2);
0: 	}
0: 	public static String getMessage(String key, Object o1, Object o2, Object o3){
0: 		return getInstance().getTextMessage(key,o1,o2,o3);
0: 	}
0: 	public static String getMessage(String key, Object o1, Object o2, Object o3, Object o4){
0: 		return getInstance().getTextMessage(key,o1,o2,o3,o4);
0: 	}
0: 	public static LocalizedOutput OutputWriter(){
0: 		return getInstance().out;
0: 	}
0: 	public static LocalizedInput InputReader(){
0: 		return getInstance().in;
0: 	}
0: 	public static String getNumber(long o){
0: 		return getInstance().getNumberAsString(o);
0: 	}
0: 	public static String getNumber(int o){
0: 		return getInstance().getNumberAsString(o);
0: 	}
0: 	public static void setUnicodeEscape(boolean u){
0: 		getInstance().unicodeEscape = u;
0: 	}
0: 	public static boolean getUnicodeEscape(){
0: 		return getInstance().unicodeEscape;
0: 	}
0: 	public String toString(){
0: 		String s = "toString(){\n" +
0: 			"locale=" + (locale==null?"null":locale.toString()) + "\n" +
0: 			"encode=" + encode + "\n" +
0: 			"messageFile=" + messageFileName + "\n" +
0: 			"resourceKey=" + resourceKey + "\n" +
0: 			"enableLocalized=" + enableLocalized + " \n" +
0: 			"unicodeEscape=" + unicodeEscape + "\n" +
0: 			"dateSize=" + dateSize + "\n" +
0: 			"timeSize=" + timeSize + "\n" +
0: 			"timestampSize="+timestampSize+ "\n}";
0: 			return s;
0: 	}
0: }
============================================================================