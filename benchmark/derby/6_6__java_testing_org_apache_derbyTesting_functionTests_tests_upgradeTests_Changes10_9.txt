1:6e000cc: /*
1:6e000cc: 
1:6e000cc: Derby - Class org.apache.derbyTesting.functionTests.tests.upgradeTests.Changes10_9
1:6e000cc: 
1:6e000cc: Licensed to the Apache Software Foundation (ASF) under one or more
1:6e000cc: contributor license agreements.  See the NOTICE file distributed with
1:6e000cc: this work for additional information regarding copyright ownership.
1:6e000cc: The ASF licenses this file to You under the Apache License, Version 2.0
1:6e000cc: (the "License"); you may not use this file except in compliance with
1:6e000cc: the License.  You may obtain a copy of the License at
1:6e000cc: 
1:6e000cc:    http://www.apache.org/licenses/LICENSE-2.0
1:6e000cc: 
1:6e000cc: Unless required by applicable law or agreed to in writing, software
1:6e000cc: distributed under the License is distributed on an "AS IS" BASIS,
1:6e000cc: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:6e000cc: See the License for the specific language governing permissions and
1:6e000cc: limitations under the License.
1:6e000cc: 
1:6e000cc: */
1:6e000cc: package org.apache.derbyTesting.functionTests.tests.upgradeTests;
1:9020cea: 
1:78c2db1: import java.io.File;
1:78c2db1: import java.net.MalformedURLException;
1:78c2db1: import java.net.URL;
1:1ede0a8: import java.sql.CallableStatement;
1:1ede0a8: import java.sql.Connection;
1:1ede0a8: import java.sql.PreparedStatement;
1:6e000cc: import java.sql.ResultSet;
1:6e000cc: import java.sql.SQLException;
1:6e000cc: import java.sql.Statement;
1:78c2db1: import java.util.ArrayList;
1:78c2db1: import java.util.List;
1:1ede0a8: import javax.sql.DataSource;
1:6e000cc: import junit.framework.Test;
1:bce78c9: import org.apache.derbyTesting.functionTests.tests.upgradeTests.helpers.DisposableIndexStatistics;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:c1e0f8e: import org.apache.derbyTesting.junit.IndexStatsUtil;
1:6e000cc: import org.apache.derbyTesting.junit.JDBC;
1:1ede0a8: import org.apache.derbyTesting.junit.JDBCDataSource;
1:6e000cc: import org.apache.derbyTesting.junit.SupportFilesSetup;
1:78c2db1: import org.apache.derbyTesting.junit.TestConfiguration;
1:9020cea: 
1:6e000cc: 
1:6e000cc: /**
1:6e000cc:  * Upgrade test cases for 10.9.
1:6e000cc:  */
1:6e000cc: public class Changes10_9 extends UpgradeChange
2:9020cea: {
1:6e000cc:     ///////////////////////////////////////////////////////////////////////////////////
1:6e000cc:     //
1:6e000cc:     // CONSTANTS
1:6e000cc:     //
1:6e000cc:     ///////////////////////////////////////////////////////////////////////////////////
1:9020cea: 
1:9efa649:     private static  final   String  UPGRADE_REQUIRED = "XCL47";
1:9efa649:     private static  final   String  INVALID_PROVIDER_CHANGE = "XCY05";
1:9efa649: 
1:6e000cc:     ///////////////////////////////////////////////////////////////////////////////////
1:6e000cc:     //
1:6e000cc:     // STATE
1:6e000cc:     //
1:6e000cc:     ///////////////////////////////////////////////////////////////////////////////////
1:9020cea: 
1:6e000cc:     ///////////////////////////////////////////////////////////////////////////////////
1:6e000cc:     //
1:6e000cc:     // CONSTRUCTOR
1:6e000cc:     //
1:6e000cc:     ///////////////////////////////////////////////////////////////////////////////////
1:9020cea: 
1:6e000cc:     public Changes10_9(String name)
1:9020cea:     {
1:6e000cc:         super(name);
1:78c2db1:         initPattern();
1:6e000cc:     }
1:8e352d6: 
1:6e000cc:     ///////////////////////////////////////////////////////////////////////////////////
1:6e000cc:     //
1:6e000cc:     // JUnit BEHAVIOR
1:6e000cc:     //
1:6e000cc:     ///////////////////////////////////////////////////////////////////////////////////
1:92268ac: 
1:78c2db1:     private static final String[] SUPPORT_FILES_SOURCE =
1:92268ac:     {
1:78c2db1:         "functionTests/tests/lang/dcl_java.jar",
1:78c2db1:         "functionTests/tests/lang/dcl_emc1.jar",
1:78c2db1:         "functionTests/tests/lang/dcl_emc2.jar",
1:78c2db1:     };
1:92268ac:     
1:92268ac:     
1:aa609d5:     /**
1:6e000cc:      * Return the suite of tests to test the changes made in 10.7.
1:6e000cc:      * @param phase an integer that indicates the current phase in
1:6e000cc:      *              the upgrade test.
1:6e000cc:      * @return the test suite created.
1:9020cea:      */
1:6e000cc:     public static Test suite(int phase) {
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite("Upgrade test for 10.9");
1:92268ac: 
1:6e000cc:         suite.addTestSuite(Changes10_9.class);
1:9020cea:         
1:78c2db1:         return new SupportFilesSetup(
1:78c2db1:                 (Test)suite, SUPPORT_FILES_SOURCE);
1:9020cea:     }
1:9020cea: 
1:6e000cc:     ///////////////////////////////////////////////////////////////////////////////////
1:6e000cc:     //
1:6e000cc:     // TESTS
1:6e000cc:     //
1:6e000cc:     ///////////////////////////////////////////////////////////////////////////////////
1:9020cea: 
1:9020cea:     /**
1:a6a0733:      * Make sure that the drop statistics procedure only appears after 
1:a6a0733:      * hard-upgrade.
1:6e000cc:      */
1:a6a0733:     public  void    testDropStatisticsProc()  throws Exception
1:9020cea:     {
1:9020cea:         Statement s = createStatement();
1:9020cea: 
1:9020cea:         switch ( getPhase() )
1:9020cea:         {
1:9020cea:         case PH_CREATE: // create with old version
1:a6a0733:             s.execute("CREATE TABLE dropStatsT1 (c11 int, c12 int) ");
1:a6a0733:             vetProcs(s, "call syscs_util.syscs_drop_statistics( 'APP', 'DROPSTATST1', null )", false);
1:9020cea:             break;
1:9020cea:             
1:9020cea:         case PH_SOFT_UPGRADE: // boot with new version and soft-upgrade
1:a6a0733:             vetProcs(s, "call syscs_util.syscs_drop_statistics( 'APP', 'DROPSTATST1', null )", false);
1:9020cea:             break;
1:9020cea:             
1:9020cea:         case PH_POST_SOFT_UPGRADE: // soft-downgrade: boot with old version after soft-upgrade
1:a6a0733:             vetProcs(s, "call syscs_util.syscs_drop_statistics( 'APP', 'DROPSTATST1', null )", false);
1:9020cea:             break;
1:9020cea: 
1:9020cea:         case PH_HARD_UPGRADE: // boot with new version and hard-upgrade
1:a6a0733:             vetProcs(s, "call syscs_util.syscs_drop_statistics( 'APP', 'DROPSTATST1', null )", true);
1:a6a0733:             s.execute("DROP TABLE dropStatsT1");
1:9020cea:             break;
1:9020cea:         }
1:9020cea:         
1:9020cea:         s.close();
1:9020cea:     	
1:9020cea:     }
1:6e000cc:     /**
1:aa609d5:      * Make sure that the catalogs and procedures for NATIVE authentication
1:aa609d5:      * only appear after hard-upgrade.
1:aa609d5:      */
1:aa609d5:     public  void    testNativeAuthentication()  throws Exception
1:aa609d5:     {
1:aa609d5:         Statement s = createStatement();
1:aa609d5: 
1:aa609d5:         switch ( getPhase() )
1:aa609d5:         {
1:aa609d5:         case PH_CREATE: // create with old version
1:aa609d5:             vetSYSUSERS( s, false );
1:92268ac:             vetNativeProcs( s, false );
1:aa609d5:             break;
1:aa609d5:             
1:aa609d5:         case PH_SOFT_UPGRADE: // boot with new version and soft-upgrade
1:aa609d5:             vetSYSUSERS( s, false );
1:92268ac:             vetNativeProcs( s, false );
1:aa609d5:             break;
1:aa609d5:             
1:aa609d5:         case PH_POST_SOFT_UPGRADE: // soft-downgrade: boot with old version after soft-upgrade
1:aa609d5:             vetSYSUSERS( s, false );
1:92268ac:             vetNativeProcs( s, false );
1:aa609d5:             break;
1:aa609d5: 
1:aa609d5:         case PH_HARD_UPGRADE: // boot with new version and hard-upgrade
1:aa609d5:             vetSYSUSERS( s, true );
1:92268ac:             vetNativeProcs( s, true );
1:aa609d5:             break;
1:aa609d5:         }
1:aa609d5:         
1:aa609d5:         s.close();
1:aa609d5:     }
1:a6a0733:     private void    vetProcs( Statement s, String procCall, boolean shouldExist ) throws Exception
1:aa609d5:     {
1:92268ac:         try {
1:a6a0733:             s.execute( procCall );
1:92268ac:             
1:92268ac:             if ( !shouldExist )
1:92268ac:             {
1:92268ac:                 fail( "syscs_util.syscs_create_user should not exist." );
1:9020cea:             }
1:92268ac:         } catch (SQLException se )
1:9020cea:         {
1:92268ac:             if ( shouldExist )
1:9020cea:             {
1:c5b9acb:                 assertSQLState( "4251K", se );
1:9020cea:             }
1:c5b9acb:             else
1:c5b9acb:             {
1:c5b9acb:                 assertSQLState( "42Y03", se );
1:c5b9acb:             }
1:a84fc26:         }
1:9020cea:     }
1:aa609d5:     private void    vetSYSUSERS( Statement s, boolean shouldExist ) throws Exception
1:a84fc26:     {
1:aa609d5:         ResultSet   rs = s.executeQuery( "select count(*) from sys.systables where tablename = 'SYSUSERS'" );
1:92268ac:         rs.next();
1:a84fc26: 
1:aa609d5:         int expectedValue = shouldExist ? 1 : 0;
1:04cfd28: 
1:aa609d5:         assertEquals( expectedValue, rs.getInt( 1 ) );
1:04cfd28: 
1:92268ac:         rs.close();
1:aa609d5:     }
1:92268ac:     private void    vetNativeProcs( Statement s, boolean shouldExist ) throws Exception
1:92268ac:     {
1:a84fc26:         // make sure that an authentication algorithm has been set
1:9efa649:         String  defaultDigestAlgorithm = pushAuthenticationAlgorithm( s );
1:a6a0733:         vetProcs(s, "call syscs_util.syscs_create_user( 'FRED', 'fredpassword' )", shouldExist);
1:a84fc26:         // restore the authentication algorithm if we changed it
1:9efa649:         popAuthenticationAlgorithm( s, defaultDigestAlgorithm );
1:9efa649:     }
1:9efa649:     private String    pushAuthenticationAlgorithm( Statement s ) throws Exception
1:9efa649:     {
1:9efa649:         // make sure that an authentication algorithm has been set.
1:9efa649:         // otherwise, we won't be able to create NATIVE users.
1:9efa649:         String  defaultDigestAlgorithm = getDatabaseProperty( s, "derby.authentication.builtin.algorithm" );
1:9efa649:         if ( defaultDigestAlgorithm == null )
1:9efa649:         {
1:9efa649:             setDatabaseProperty( s, "derby.authentication.builtin.algorithm", "SHA-1" );
1:9efa649:         }
1:9efa649: 
1:9efa649:         return defaultDigestAlgorithm;
1:9efa649:     }
1:9efa649:     private void    popAuthenticationAlgorithm( Statement s, String defaultDigestAlgorithm ) throws Exception
1:9efa649:     {
1:9efa649:         // restore the authentication algorithm if we changed it
1:a84fc26:         if ( defaultDigestAlgorithm == null )
1:a84fc26:         {
1:a84fc26:             setDatabaseProperty( s, "derby.authentication.builtin.algorithm", null );
1:a84fc26:         }
1:a84fc26:     }
1:a84fc26:     private void  setDatabaseProperty( Statement s, String key, String value )
1:a84fc26:         throws Exception
1:a84fc26:     {
1:a84fc26:         if ( value == null ) { value = "cast ( null as varchar( 32672 ) )"; }
1:a84fc26:         else { value = "'" + value + "'"; }
1:a84fc26:         String  command = "call syscs_util.syscs_set_database_property( '" + key + "', " + value + " )";
1:a84fc26: 
1:a84fc26:         s.execute( command );
1:a84fc26:     }
1:a84fc26:     private String  getDatabaseProperty( Statement s, String key )
1:a84fc26:         throws Exception
1:a84fc26:     {
1:a84fc26:         ResultSet   rs = s.executeQuery( "values( syscs_util.syscs_get_database_property( '" + key + "' ) )" );
1:a84fc26: 
1:a84fc26:         try {
1:a84fc26:             rs.next();
1:a84fc26:             return rs.getString( 1 );
1:a84fc26:         }
1:a84fc26:         finally
1:a84fc26:         {
1:a84fc26:             rs.close();
1:a84fc26:         }
1:92268ac:     }
1:a84fc26:     
1:6e000cc:     /**
1:9efa649:      * Make sure that NATIVE LOCAL authentication can't be turned on
1:9efa649:      * before hard-upgrade.
1:9efa649:      */
1:9efa649:     public  void    testNativeLocalAuthentication()  throws Exception
1:9efa649:     {
1:9efa649:         Statement s = createStatement();
1:9efa649: 
1:9efa649:         switch ( getPhase() )
1:9efa649:         {
1:9efa649:         case PH_CREATE: // create with old version
1:9efa649:         case PH_POST_SOFT_UPGRADE: // soft-downgrade: boot with old version after soft-upgrade
1:9efa649: 
1:9efa649:             //
1:9efa649:             // It's possible (although very unlikely) that someone could set the
1:9efa649:             // authentication provider to be NATIVE::LOCAL in an old database
1:9efa649:             // just before upgrading. If they do this, they will get an error at
1:9efa649:             // soft-upgrade time and they will have to back off to the old
1:9efa649:             // derby version in order to unset the authentication provider.
1:9efa649:             //
1:9efa649:             setDatabaseProperty( s, "derby.authentication.provider", "NATIVE::LOCAL" );
1:9efa649:             setDatabaseProperty( s, "derby.authentication.provider", null );
1:9efa649:             break;
1:9efa649:             
1:9efa649:         case PH_SOFT_UPGRADE: // boot with new version and soft-upgrade
1:9efa649:             setDatabaseProperty( s, "derby.authentication.provider", "com.acme.AcmeAuthenticator" );
1:9efa649:             assertStatementError
1:9efa649:                 (
1:9efa649:                  UPGRADE_REQUIRED, s,
1:9efa649:                  "call syscs_util.syscs_set_database_property( 'derby.authentication.provider', 'NATIVE::LOCAL' )"
1:9efa649:                  );
1:9efa649:             setDatabaseProperty( s, "derby.authentication.provider", null );
1:9efa649:             break;
1:9efa649:             
1:9efa649:         case PH_HARD_UPGRADE: // boot with new version and hard-upgrade
1:9efa649:             //
1:9efa649:             // Can't actually turn on NATIVE LOCAL authentication in the upgrade tests because, once turned on,
1:9efa649:             // you can't turn it off and that would mess up later tests. 
1:9efa649:             //
1:9efa649:             break;
1:9efa649:         }
1:9efa649:         
1:9efa649:         s.close();
1:9efa649:     }
1:9efa649: 
1:9efa649:     /**
1:1ede0a8:      * Make sure builtin authentication doesn't use a hash scheme that's not
1:1ede0a8:      * supported by the old version until the database has been hard upgraded.
1:1ede0a8:      * See DERBY-4483 and DERBY-5539.
1:6e000cc:      */
1:1ede0a8:     public void testBuiltinAuthenticationWithConfigurableHash()
1:1ede0a8:             throws SQLException {
1:04cfd28: 
1:1ede0a8:         // This test needs to enable authentication, which is not supported
1:1ede0a8:         // in the default database for the upgrade tests, so roll our own.
1:1ede0a8:         DataSource ds = JDBCDataSource.getDataSourceLogical("BUILTIN_10_9");
1:92268ac: 
1:1ede0a8:         // Add create=true or upgrade=true, as appropriate, since we don't
1:1ede0a8:         // get this for free when we don't use the default database.
1:1ede0a8:         if (getPhase() == PH_CREATE) {
1:1ede0a8:             JDBCDataSource.setBeanProperty(ds, "createDatabase", "create");
1:1ede0a8:         } else if (getPhase() == PH_HARD_UPGRADE) {
1:1ede0a8:             JDBCDataSource.setBeanProperty(
1:1ede0a8:                     ds, "connectionAttributes", "upgrade=true");
1:92268ac:         }
1:aa609d5: 
1:1ede0a8:         // Connect as database owner, possibly creating or upgrading the
1:1ede0a8:         // database.
1:1ede0a8:         Connection c = ds.getConnection("dbo", "the boss");
1:aa609d5: 
1:1ede0a8:         // Let's first verify that all the users can connect after the changes
1:1ede0a8:         // in the previous phase. Would fail for instance in post soft upgrade
1:1ede0a8:         // if soft upgrade saved passwords using the new scheme.
1:1ede0a8:         verifyCanConnect(ds);
1:aa609d5: 
1:1ede0a8:         CallableStatement setProp = c.prepareCall(
1:1ede0a8:                 "call syscs_util.syscs_set_database_property(?, ?)");
1:aa609d5: 
1:1ede0a8:         if (getPhase() == PH_CREATE) {
1:1ede0a8:             // The database is being created. Make sure that builtin
1:1ede0a8:             // authentication is enabled.
1:1ede0a8:             setProp.setString(1, "derby.connection.requireAuthentication");
1:1ede0a8:             setProp.setString(2, "true");
1:1ede0a8:             setProp.execute();
1:9020cea: 
1:1ede0a8:             setProp.setString(1, "derby.authentication.provider");
1:1ede0a8:             setProp.setString(2, "BUILTIN");
1:1ede0a8:             setProp.execute();
1:9020cea: 
1:1ede0a8:             // Set the length of the random salt to 0 to ensure that the
1:1ede0a8:             // hashed token doesn't vary between test runs.
1:1ede0a8:             setProp.setString(1, "derby.authentication.builtin.saltLength");
1:1ede0a8:             setProp.setInt(2, 0);
1:1ede0a8:             setProp.execute();
1:92268ac:         }
1:9020cea: 
1:1ede0a8:         // Set (or reset) passwords for all users.
1:1ede0a8:         setPasswords(setProp);
1:1ede0a8:         setProp.close();
1:9020cea: 
1:1ede0a8:         // We should still be able to connect.
1:1ede0a8:         verifyCanConnect(ds);
1:9020cea: 
1:1ede0a8:         // Check that the passwords are stored using the expected scheme (new
1:1ede0a8:         // configurable hash scheme in hard upgrade, old scheme otherwise).
1:1ede0a8:         verifyPasswords(c);
1:9020cea: 
1:1ede0a8:         c.close();
1:6e000cc: 
1:1ede0a8:         // The framework doesn't know how to shutdown a database using
1:1ede0a8:         // authentication, so do it manually as database owner here.
1:1ede0a8:         JDBCDataSource.setBeanProperty(ds, "user", "dbo");
1:1ede0a8:         JDBCDataSource.setBeanProperty(ds, "password", "the boss");
1:1ede0a8:         JDBCDataSource.shutdownDatabase(ds);
1:92268ac:     }
1:6e000cc: 
1:78c2db1:     /**
1:1ede0a8:      * Information about users for the test of builtin authentication with
1:1ede0a8:      * configurable hash algorithm. Two-dimensional array of strings where
1:1ede0a8:      * each row contains (1) a user name, (2) a password, (3) the name of a
1:1ede0a8:      * digest algorithm with which the password should be hashed, (4) the
1:1ede0a8:      * hashed password when the old scheme is used, (5) the hashed password
1:1ede0a8:      * when the new, configurable hash scheme is used in databases that
1:1ede0a8:      * don't support the key-stretching extension (DERBY-5539), and (6) the
1:1ede0a8:      * hashed password when configurable hash with key stretching is used.
1:1ede0a8:      */
1:1ede0a8:     private static final String[][] USERS = {
1:1ede0a8:         { "dbo", "the boss", null,
1:1ede0a8:                   "3b6071d99b1d48ab732e75a8de701b6c77632db65898",
1:1ede0a8:                   "3b6071d99b1d48ab732e75a8de701b6c77632db65898",
1:1ede0a8:                   "3b6071d99b1d48ab732e75a8de701b6c77632db65898",
1:1ede0a8:         },
1:1ede0a8:         { "pat", "postman", "MD5",
1:1ede0a8:                   "3b609129e181a7f7527697235c8aead65c461a0257f3",
1:1ede0a8:                   "3b61aaca567ed43d1ba2e6402cbf1a723407:MD5",
1:1ede0a8:                   "3b624f4b0d7f3d2330c1db98a2000c62b5cd::1000:MD5",
1:1ede0a8:         },
1:1ede0a8:         { "sam", "fireman", "SHA-1",
1:1ede0a8:                   "3b609e5173cfa03620061518adc92f2a58c7b15cf04f",
1:1ede0a8:                   "3b6197160362c0122fcd7a63a9da58fd0781140901fb:SHA-1",
1:1ede0a8:                   "3b62a2d88ffac5332219116ab53e29dd3b9e1222e990::1000:SHA-1",
1:1ede0a8:         },
1:1ede0a8:     };
1:6e000cc: 
1:1ede0a8:     /**
1:1ede0a8:      * Set the passwords for all users specified in {@code USERS}.
1:1ede0a8:      *
1:1ede0a8:      * @param cs a callable statement that sets database properties
1:1ede0a8:      */
1:1ede0a8:     private void setPasswords(CallableStatement cs) throws SQLException {
1:1ede0a8:         for (int i = 0; i < USERS.length; i++) {
1:1ede0a8:             // Use the specified algorithm, if possible. (Will be ignored if
1:1ede0a8:             // the data dictionary doesn't support the new scheme.)
1:1ede0a8:             cs.setString(1, Changes10_6.HASH_ALGORITHM_PROPERTY);
1:1ede0a8:             cs.setString(2, USERS[i][2]);
1:1ede0a8:             cs.execute();
1:1ede0a8:             // Set the password.
1:1ede0a8:             cs.setString(1, "derby.user." + USERS[i][0]);
1:1ede0a8:             cs.setString(2, USERS[i][1]);
1:1ede0a8:             cs.execute();
1:9020cea:         }
1:6e000cc:     }
1:6e000cc: 
1:1ede0a8:     /**
1:1ede0a8:      * Verify that all passwords for the users in {@code USERS} are stored
1:1ede0a8:      * as expected. Raise an assert failure on mismatch.
1:1ede0a8:      *
1:1ede0a8:      * @param c a connection to the database
1:1ede0a8:      */
1:1ede0a8:     private void verifyPasswords(Connection c)
1:1ede0a8:             throws SQLException {
1:1ede0a8:         int pwIdx;
1:1ede0a8:         if (getPhase() == PH_HARD_UPGRADE) {
1:1ede0a8:             // Expect configurable hash scheme with key stretching in fully
1:1ede0a8:             // upgraded databases.
1:1ede0a8:             pwIdx = 5;
1:1ede0a8:         } else if (oldAtLeast(10, 6)) {
1:1ede0a8:             // Databases whose dictionary is at least version 10.6 support
1:1ede0a8:             // configurable hash without key stretching.
1:1ede0a8:             pwIdx = 4;
1:1ede0a8:         } else {
1:1ede0a8:             // Older databases only support the old scheme based on SHA-1.
1:1ede0a8:             pwIdx = 3;
1:6e000cc:         }
1:1ede0a8:         PreparedStatement ps = c.prepareStatement(
1:1ede0a8:                 "values syscs_util.syscs_get_database_property(?)");
1:1ede0a8:         for (int i = 0; i < USERS.length; i++) {
1:1ede0a8:             String expectedToken = USERS[i][pwIdx];
1:1ede0a8:             ps.setString(1, "derby.user." + USERS[i][0]);
1:1ede0a8:             JDBC.assertSingleValueResultSet(ps.executeQuery(), expectedToken);
1:6e000cc:         }
1:1ede0a8:         ps.close();
1:6e000cc:     }
1:6e000cc: 
1:1ede0a8:     /**
1:1ede0a8:      * Verify that all users specified in {@code USERS} can connect to the
1:1ede0a8:      * database.
1:1ede0a8:      *
1:1ede0a8:      * @param ds a data source for connecting to the database
1:1ede0a8:      * @throws SQLException if one of the users cannot connect to the database
1:1ede0a8:      */
1:1ede0a8:     private void verifyCanConnect(DataSource ds) throws SQLException {
1:1ede0a8:         for (int i = 0; i < USERS.length; i++) {
1:1ede0a8:             Connection c = ds.getConnection(USERS[i][0], USERS[i][1]);
1:1ede0a8:             c.close();
1:6e000cc:         }
1:6e000cc:     }
1:6e000cc: 
1:6e000cc: 
1:1ede0a8:     /**
1:78c2db1:      * For 10.9 and later storage of jar files changed. DERBY-5357.
1:78c2db1:      */
1:78c2db1:     public void testJarStorage()  throws Exception
1:92268ac:     {
1:6e000cc:         Statement s = createStatement();
1:6e000cc: 
1:78c2db1:         switch (getPhase()) {
1:6e000cc:         case PH_CREATE: // create with old version
1:78c2db1:             createSchema("EMC");
1:78c2db1:             createSchema("FOO");
1:6e000cc: 
1:78c2db1:             s.executeUpdate(
1:78c2db1:                 "create procedure EMC.ADDCONTACT(id INT, e_mail VARCHAR(30)) " +
1:78c2db1:                 "MODIFIES SQL DATA " +
1:78c2db1:                 "external name " +
1:78c2db1:                 "'org.apache.derbyTesting.databaseclassloader.emc.addContact'" +
1:78c2db1:                 " language java parameter style java");
1:78c2db1:             s.executeUpdate(
1:78c2db1:                 "create table EMC.CONTACTS " +
1:78c2db1:                 "    (id int, e_mail varchar(30))");
1:6e000cc: 
1:78c2db1:             installJar("dcl_emc1.jar", "EMC.MAIL_APP");
1:78c2db1:             installJar("dcl_java.jar", "EMC.MY_JAVA");
1:78c2db1:             installJar("dcl_emc2.jar", "FOO.BAR");
1:6e000cc: 
1:78c2db1:             setDBClasspath("EMC.MAIL_APP");
1:78c2db1:             tryCall();
1:78c2db1:             setDBClasspath(null);
1:6e000cc: 
1:6e000cc:             break;
1:6e000cc: 
1:78c2db1:         case PH_SOFT_UPGRADE:
1:78c2db1:             // boot with new version and soft-upgrade
1:6e000cc: 
1:030bfac:             // DERBY-6505: Take a backup of the database. Backing up the
1:030bfac:             // jar storage takes a different path in soft upgrade, so make
1:030bfac:             // sure that path is exercised.
1:030bfac:             String backupdir =
1:030bfac:                 SupportFilesSetup.getReadWriteFileName("d6505-backup");
1:030bfac:             PreparedStatement backupStmt =
1:030bfac:                 prepareStatement("call syscs_util.syscs_backup_database(?)");
1:030bfac:             backupStmt.setString(1, backupdir);
1:030bfac:             backupStmt.execute();
1:6e000cc: 
1:030bfac:             // fallthrough... run the same tests as in post soft upgrade.
1:78c2db1:         case PH_POST_SOFT_UPGRADE:
1:78c2db1:             // soft-downgrade: boot with old version after soft-upgrade
1:6e000cc: 
1:78c2db1:             setDBClasspath("EMC.MAIL_APP");
1:78c2db1:             tryCall();
1:78c2db1:             setDBClasspath(null);
1:6e000cc:             
1:78c2db1:             // if we can do this, it hasn't moved already:
1:78c2db1:             replaceJar("dcl_emc1.jar", "EMC.MAIL_APP");
1:6e000cc: 
1:78c2db1:             setDBClasspath("EMC.MAIL_APP");
1:78c2db1:             tryCall();
1:78c2db1:             setDBClasspath(null);
1:6e000cc: 
1:6e000cc:             break;
1:6e000cc:             
1:6e000cc:         case PH_HARD_UPGRADE: // boot with new version and hard-upgrade
1:6e000cc: 
1:78c2db1:             setDBClasspath("EMC.MAIL_APP");
1:78c2db1:             tryCall();
1:78c2db1:             setDBClasspath(null);
1:6e000cc: 
1:78c2db1:             installJar("dcl_emc1.jar", "FOO.\"BAR/..\\../\"");
1:6e000cc: 
1:78c2db1:             verifyNewLocations(4);
1:6e000cc:             
1:78c2db1:             removeJar("EMC.MAIL_APP");
1:78c2db1:             installJar("dcl_emc1.jar", "EMC.MAIL_APP");
1:6e000cc:             
1:78c2db1:             setDBClasspath("EMC.MAIL_APP");
1:78c2db1:             tryCall();
1:78c2db1:             setDBClasspath(null);
1:6e000cc:             
1:78c2db1:             // finally, check that all the rest are also here
1:78c2db1:             replaceJar("dcl_java.jar", "EMC.MY_JAVA");
1:78c2db1:             replaceJar("dcl_emc2.jar", "FOO.BAR");
1:78c2db1:             replaceJar("dcl_emc1.jar", "FOO.\"BAR/..\\../\"");
1:6e000cc: 
1:78c2db1:             // clean up
1:78c2db1:             removeJar("EMC.MY_JAVA");
1:78c2db1:             removeJar("FOO.BAR");
1:78c2db1:             removeJar("FOO.\"BAR/..\\../\"");
1:78c2db1:             removeJar("EMC.MAIL_APP");
1:78c2db1:             s.executeUpdate("drop table EMC.CONTACTS");
1:78c2db1:             s.executeUpdate("drop procedure EMC.ADDCONTACT");
1:78c2db1:             s.executeUpdate("drop schema FOO restrict");
1:78c2db1:             s.executeUpdate("drop schema EMC restrict");
1:6e000cc: 
1:6e000cc:             break;
1:6e000cc:         }
1:6e000cc:         
1:6e000cc:         s.close();
1:78c2db1:     }
1:6e000cc: 
1:78c2db1:     private void createSchema(String name) throws SQLException {
1:78c2db1:         Statement s = createStatement();
1:78c2db1:         s.executeUpdate("create schema " + name);
2:78c2db1:         s.close();
1:78c2db1:     }
1:78c2db1: 
1:78c2db1:     private void installJar(String resource, String jarName)
1:78c2db1:             throws SQLException, MalformedURLException {        
1:78c2db1: 
1:78c2db1:         URL jar = SupportFilesSetup.getReadOnlyURL(resource);
1:78c2db1:         
1:78c2db1:         CallableStatement cs = prepareCall("CALL SQLJ.INSTALL_JAR(?, ?, 0)");
1:78c2db1:         cs.setString(1, jar.toExternalForm());
1:78c2db1:         cs.setString(2, jarName);
1:78c2db1:         cs.executeUpdate();
1:78c2db1:         cs.close();
1:78c2db1:     }
18:78c2db1:     
1:78c2db1:     private void replaceJar(String resource, String jarName)
1:78c2db1:             throws SQLException, MalformedURLException {        
1:78c2db1: 
1:78c2db1:         URL jar = SupportFilesSetup.getReadOnlyURL(resource);
1:78c2db1:         CallableStatement cs = prepareCall("CALL SQLJ.REPLACE_JAR(?, ?)");
1:78c2db1:         cs.setString(1, jar.toExternalForm());
1:78c2db1:         cs.setString(2, jarName);
1:78c2db1:         cs.executeUpdate();
1:78c2db1:         cs.close();
1:78c2db1:     }
1:78c2db1:     
1:78c2db1:     private void removeJar(String jarName) throws SQLException {
1:78c2db1:         CallableStatement cs = prepareCall("CALL SQLJ.REMOVE_JAR(?, 0)");       
1:78c2db1:         cs.setString(1, jarName);       
1:78c2db1:         cs.executeUpdate();        
1:78c2db1:         cs.close();
1:78c2db1:     }
1:78c2db1: 
1:78c2db1:     private void setDBClasspath(String cp) throws SQLException {
1:78c2db1:         CallableStatement cs = prepareCall(
1:78c2db1:           "CALL SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:78c2db1:           "'derby.database.classpath', ?)");
1:78c2db1: 
1:78c2db1:         cs.setString(1, cp);
1:78c2db1:         cs.executeUpdate();
1:78c2db1:         cs.close();
1:78c2db1:     }
1:78c2db1: 
1:78c2db1:     private void tryCall() throws SQLException {
1:78c2db1:         if (JDBC.vmSupportsJSR169()) {
1:78c2db1:             return; // skip, EMC uses DriverManager
1:78c2db1:         }
1:78c2db1: 
1:78c2db1:         CallableStatement cs = prepareCall("CALL EMC.ADDCONTACT(?, ?)");
1:78c2db1:         cs.setInt(1, 0);
1:78c2db1:         cs.setString(2, "now@classpathchange.com");
1:78c2db1:         cs.executeUpdate();
1:78c2db1:         cs.close();
1:78c2db1:     }
1:78c2db1: 
1:78c2db1:     private void verifyNewLocations(int noOfObjects)
1:78c2db1:             throws SQLException {
1:78c2db1:         TestConfiguration tc = TestConfiguration.getCurrent();
1:78c2db1:         String dbPath = tc.getPhysicalDatabaseName(tc.getDefaultDatabaseName());
1:78c2db1:         String jarDirName =
1:78c2db1:             "system" + File.separator + dbPath + File.separator + "jar";
1:78c2db1:         File jarDir = new File(jarDirName);
1:78c2db1: 
1:78c2db1:         assertTrue(jarDir.isDirectory());
1:78c2db1: 
1:78c2db1:         File[] contents = jarDir.listFiles();
1:78c2db1:         
1:78c2db1:         // <db>/jar should now contain this no of files, none of which are
1:78c2db1:         // directories
1:78c2db1:         assertEquals(noOfObjects, contents.length);
1:78c2db1:         
1:78c2db1:         // assert that all the old style directories are gone
1:78c2db1:         for (int i=0; i < contents.length; i++) {
1:78c2db1:             File f = contents[i];
1:78c2db1:             assertTrue(f.isFile());
1:78c2db1:             assertFileNameShape(f.getName());
1:78c2db1:         }
1:78c2db1:     }
1:78c2db1: 
1:78c2db1: 
1:78c2db1:     /**
1:78c2db1:      * Regexp pattern to match the file name of a jar file stored in the
1:dbed020:      * database (version &gt;= 10.9).
1:78c2db1:      */
1:78c2db1:     private Goal[] pattern;
1:78c2db1:     
1:78c2db1:     /**
1:78c2db1:      * Initialize a pattern corresponding to:
1:78c2db1:      * <p/>
1:78c2db1:      * &lt;Derby uuid string&gt;[.]jar[.]G[0-9]+
1:78c2db1:      * <p/>
1:78c2db1:      * where:
1:78c2db1:      * <p/>
1:78c2db1:      * &lt;Derby uuid string&gt; has the form
1:78c2db1:      * hhhhhhhh-hhhh-hhhh-hhhh-hhhhhhhhhhhh
1:78c2db1:      * <p/>
1:78c2db1:      * where <em>h</em> id a lower case hex digit.
1:78c2db1:      */
1:78c2db1:     private void initPattern() {
1:e18f54b:         List<Goal> l = new ArrayList<Goal>(100);
1:78c2db1:         // The UUID format is determined by
1:78c2db1:         // org.apache.derby.impl.services.uuid.BasicUUID#toString
1:78c2db1: 
1:78c2db1:         for (int i=0; i < 8; i++) {
1:78c2db1:             l.add(new CharRange(new char[][]{{'0','9'},{'a','f'}}));
1:78c2db1:         }
1:78c2db1: 
1:78c2db1:         l.add(new SingleChar('-'));
1:78c2db1:         
1:78c2db1:         for (int j = 0; j < 3; j++) {
1:78c2db1:             for (int i=0; i < 4; i++) {
1:78c2db1:                 l.add(new CharRange(new char[][]{{'0','9'},{'a','f'}}));
1:78c2db1:             }
1:78c2db1:             
1:78c2db1:             l.add(new SingleChar('-'));
1:78c2db1:         }
1:78c2db1:         
1:78c2db1:         for (int i=0; i < 12; i++) {
1:78c2db1:             l.add(new CharRange(new char[][]{{'0','9'},{'a','f'}}));
1:78c2db1:         }
1:78c2db1:         
1:78c2db1:         l.add(new SingleChar('.'));
1:78c2db1:         l.add(new SingleChar('j'));
1:78c2db1:         l.add(new SingleChar('a'));
1:78c2db1:         l.add(new SingleChar('r'));
1:78c2db1:         l.add(new SingleChar('.'));
1:78c2db1:         l.add(new SingleChar('G'));
1:78c2db1:         l.add(new CharRange(new char[][]{{'0','9'}}, Goal.REPEAT));
1:78c2db1: 
1:e18f54b:         this.pattern = l.toArray(new Goal[l.size()]);
1:78c2db1:     }
1:78c2db1: 
1:78c2db1:     /**
1:78c2db1:      * assert that fName has the expected shape of a jar file
1:dbed020:      * in the database (version &gt;= 10.9).
1:78c2db1:      */
1:78c2db1:     private void assertFileNameShape(String fName) {
1:78c2db1:         assertTrue(matches(fName, pattern));
1:78c2db1:     }
1:78c2db1:     
1:78c2db1:     /**
1:78c2db1:      * Poor man's regexp matcher: can match patterns of type below, where
1:78c2db1:      * start "^" and end "$" is implied: must match whole string.
1:78c2db1:      * <p/>
1:78c2db1:      * reg.exp: ( '[' &lt;fromchar&gt;-&lt;tochar&gt; ] '+'? ']' |
1:78c2db1:      *            &lt;char&gt; '+'? )*
1:78c2db1:      */
1:78c2db1:     private boolean matches(String fName, Goal[] pattern) {
1:78c2db1:         int patIdx = 0;
1:78c2db1:         for (int i = 0; i < fName.length(); i++) {
1:78c2db1:             Goal p = pattern[patIdx];
1:78c2db1:             char c = fName.charAt(i);
1:78c2db1: 
1:78c2db1:             if (p.matches(c)) {
1:78c2db1:                 if (!p.isRepeatable()) {
1:78c2db1:                     patIdx++;
1:78c2db1:                 } 
1:78c2db1:                 p.setFoundOnce();
1:78c2db1:                 continue;
1:78c2db1:             } 
1:78c2db1:                 
1:78c2db1:             // Goal did not match: if we have a repeatable goal and we already
1:78c2db1:             // found one occurence it's ok, to step on to next goal in pattern
1:78c2db1:             // and see it that matches.
1:78c2db1:             patIdx++;
1:78c2db1:             if (p.matches(c)) {
1:78c2db1:                 if (!p.isRepeatable()) {
1:78c2db1:                     patIdx++;
1:78c2db1:                 } 
1:78c2db1:                 p.setFoundOnce();
1:78c2db1:                 continue;
1:78c2db1:             }
1:78c2db1: 
1:78c2db1:             return false;
1:78c2db1:             
1:78c2db1:         }
1:78c2db1:         
1:78c2db1:         return patIdx >= (pattern.length - 1); // exact match
1:78c2db1:     }
1:78c2db1:     
1:78c2db1:     abstract class Goal {
1:78c2db1:         public abstract boolean matches(char c);
1:78c2db1:         
1:78c2db1:         public final static int REPEAT = 0; // optional goal property
1:78c2db1:         int option = -1;
1:78c2db1:         boolean foundOnce = false;
1:78c2db1: 
1:78c2db1:         public boolean isRepeatable () {
1:78c2db1:             return option == REPEAT;
1:78c2db1:         }
1:78c2db1:         
1:78c2db1:         public void setFoundOnce() {
1:78c2db1:             this.foundOnce = true;
1:78c2db1:         }
1:78c2db1:         
1:78c2db1:         public boolean foundOnce () {
1:78c2db1:             return this.foundOnce;
1:78c2db1:         }
1:78c2db1:     }
1:78c2db1: 
1:78c2db1:     private class CharRange extends Goal {
1:78c2db1:         private char[][] ranges;
1:78c2db1:         
1:78c2db1:         public CharRange(char[][]ranges) {
1:78c2db1:             this.ranges = (char[][])ranges.clone();
1:78c2db1:         }
1:78c2db1:         
1:78c2db1:         public CharRange(char[][]ranges, int option) {
1:78c2db1:             this.ranges = (char[][])ranges.clone();
1:78c2db1:             this.option = option;
1:78c2db1:         }
1:78c2db1:         
1:78c2db1:         public boolean matches(char c) {
1:78c2db1:             for (int i = 0; i < ranges.length; i++) {
1:78c2db1:                 if (c >= ranges[i][0] && c <= ranges[i][1]) {
1:78c2db1:                     return true;
1:78c2db1:                 }
1:78c2db1:             }
1:78c2db1:             return false;
1:78c2db1:         }
1:78c2db1:     }
1:78c2db1: 
1:78c2db1:     private class SingleChar extends Goal {
1:78c2db1:         private char c;
1:78c2db1:         private int option = -1;
1:78c2db1:         private boolean foundOnce = false;
1:78c2db1:         
1:78c2db1:         public SingleChar(char c) {
1:78c2db1:             this.c = c;
1:78c2db1:         }
1:78c2db1:     
1:78c2db1:         public SingleChar(char c, int option) {
1:78c2db1:             this.c = c;
1:78c2db1:             this.option = option;
1:78c2db1:         }
1:78c2db1:         public boolean matches(char c) {
1:78c2db1:             return c == this.c;
1:78c2db1:         }
1:78c2db1:     }
1:8e352d6:     
1:8e352d6:     
1:8e352d6:     /**
1:8e352d6:      * Test the changes introduced to fix correctness problems with sequences.
1:8e352d6:      */
1:8e352d6:     public  void    test_5493()  throws Exception
1:8e352d6:     {
1:8e352d6:         Connection  conn = getConnection();
1:8e352d6:         Statement s = createStatement();
1:8e352d6: 
1:8e352d6:         switch ( getPhase() )
1:8e352d6:         {
1:8e352d6:         case PH_CREATE: // create with old version
1:8e352d6:             assertNull( getNewFunctionID( s ) );
1:8e352d6:             break;
1:8e352d6:             
1:8e352d6:         case PH_SOFT_UPGRADE: // boot with new version and soft-upgrade
1:8e352d6:             assertNull( getNewFunctionID( s ) );
1:8e352d6:             break;
1:8e352d6:             
1:8e352d6:         case PH_POST_SOFT_UPGRADE: // soft-downgrade: boot with old version after soft-upgrade
1:8e352d6:             assertNull( getNewFunctionID( s ) );
1:8e352d6:             break;
1:78c2db1: 
1:8e352d6:         case PH_HARD_UPGRADE: // boot with new version and hard-upgrade
1:8e352d6:             assertNotNull( getNewFunctionID( s ) );
1:8e352d6:             break;
1:8e352d6:         }
1:8e352d6:         
1:8e352d6:         s.close();
1:8e352d6:     }
1:8e352d6:     private String    getNewFunctionID( Statement s )
1:8e352d6:         throws Exception
1:8e352d6:     {
1:8e352d6:         ResultSet   rs = null;
1:8e352d6: 
1:8e352d6:         try {
1:8e352d6:             rs = s.executeQuery
1:8e352d6:             ( "select aliasid from sys.sysaliases where alias = 'SYSCS_PEEK_AT_SEQUENCE'" );
1:8e352d6:             if ( !rs.next() ) { return null; }
1:8e352d6:             else { return rs.getString( 1 ); }
1:8e352d6:         }
1:8e352d6:         finally
1:8e352d6:         {
1:8e352d6:             if ( rs != null ) { rs.close(); }
1:8e352d6:         }
1:8e352d6:     }
1:8e352d6: 
1:1ede0a8:     /**
1:c1e0f8e:      * Verifies that an orphaned statistics entry can be dropped by running the
1:c1e0f8e:      * {@code SYSCS_DROP_STATISTICS} system procedure.
1:c1e0f8e:      * <p>
1:c1e0f8e:      * Relevant JIRAs:
1:c1e0f8e:      * <ul> <li>DERBY-4115: Provide a way to drop statistics information</li>
1:c1e0f8e:      *      <li>DERBY-5681: When a foreign key constraint on a table is dropped,
1:c1e0f8e:      *          the associated statistics row for the conglomerate</li>
1:c1e0f8e:      * </ul>
1:c1e0f8e:      * <p>
1:c1e0f8e:      *  DERBY-5702(Creating a foreign key constraint does not automatically
1:c1e0f8e:      *   create a statistics row if foreign key constraint will share a
1:c1e0f8e:      *   backing index created for a primay key) is causing a problem for
1:c1e0f8e:      *   us to test the hanging statistics row with 10.4 and prior releases.
1:c1e0f8e:      *   Following test relies on having hanging statistics rows which should
1:c1e0f8e:      *   have been dropped when the constraint owing it was dropped. The test
1:c1e0f8e:      *   then goes ahead and uses the new drop statisitcs procedure to drop
1:c1e0f8e:      *   the hanging statistics rows. But because of DERBY-5702, when a
1:c1e0f8e:      *   constraint is added which will reuse an existing backing index,
1:c1e0f8e:      *   no statistics row is created for that constraint unless a user were
1:c1e0f8e:      *   to say use an update statistics stored procedure to create the
1:c1e0f8e:      *   statistics for that constraint. And later when that constraint is
1:c1e0f8e:      *   dropped, we will find that because of DERBY-5681, the statistics
1:c1e0f8e:      *   row never gets dropped. But update statistics stored procedure was
1:c1e0f8e:      *   not introduced up until 10.5 and because of that, we can't really
1:c1e0f8e:      *   test for hanging index created through constraints sharing the same
1:c1e0f8e:      *   backing index prior to 10.5
1:1ede0a8:      */
1:c1e0f8e:     public void testDropOrphanedStatistics()
1:c1e0f8e:             throws SQLException {
1:c1e0f8e:         // Update statistics procedure SYSCS_UPDATE_STATISTICS is not available
1:c1e0f8e:         //  prior to 10.5 and hence we can't cause the hanging statistics to 
1:c1e0f8e:         //  appear in order to test the drop statistics after hard upgrade
1:c1e0f8e:         if (!oldAtLeast(10, 5)) return;
1:9020cea: 
1:c1e0f8e:         // Helper object to obtain information about index statistics.
1:c1e0f8e:         IndexStatsUtil stats = new IndexStatsUtil(openDefaultConnection());
1:78c2db1:         Statement s = createStatement();
1:6be56bc:         // The expected initial number of statistics entries in TEST_TAB_2.
1:6be56bc:         final int expected =
1:6be56bc:                 DisposableIndexStatistics.hasDerby5681Bug(getOldVersion()) ?
1:6be56bc:                     2 : 1;
1:9020cea:         
1:c1e0f8e:         switch (getPhase())
1:9020cea:         {
1:c1e0f8e:         case PH_CREATE:
1:c1e0f8e:             s.executeUpdate("CREATE TABLE TEST_TAB_1 (c11 int not null,"+
1:c1e0f8e:                     "c12 int not null, c13 int)");
1:c1e0f8e:             s.executeUpdate("INSERT INTO TEST_TAB_1 VALUES(1,1,1),(2,2,2)");
1:c1e0f8e:             s.executeUpdate("ALTER TABLE TEST_TAB_1 "+
1:c1e0f8e:                     "ADD CONSTRAINT TEST_TAB_1_PK_1 "+
1:c1e0f8e:                     "PRIMARY KEY (c11)");
1:c1e0f8e:             //The statistics for primary key constraint has been added
1:c1e0f8e:             stats.assertTableStats("TEST_TAB_1",1);
1:9020cea:             
1:c1e0f8e:             s.executeUpdate("CREATE TABLE TEST_TAB_2 (c21 int not null)");
1:c1e0f8e:             s.executeUpdate("INSERT INTO TEST_TAB_2 VALUES(1),(2)");
1:c1e0f8e:             s.executeUpdate("ALTER TABLE TEST_TAB_2 "+
1:c1e0f8e:                     "ADD CONSTRAINT TEST_TAB_2_PK_1 "+
1:c1e0f8e:                     "PRIMARY KEY (c21)");
1:c1e0f8e:             stats.assertTableStats("TEST_TAB_2",1);
1:c1e0f8e:             //DERBY-5702 Add a foreign key constraint and now we should find 2 rows
1:c1e0f8e:             // of statistics for TEST_TAB_2 - 1 for primary key and other for
1:c1e0f8e:             // foreign key constraint
1:c1e0f8e:             s.executeUpdate("ALTER TABLE TEST_TAB_2 "+
1:c1e0f8e:                     "ADD CONSTRAINT TEST_TAB_2_FK_1 "+
1:c1e0f8e:                     "FOREIGN KEY(c21) REFERENCES TEST_TAB_1(c11)");
1:c1e0f8e:             //DERBY-5702 Like primary key earlier, adding foreign key constraint
1:c1e0f8e:             // didn't automatically add a statistics row for it. Have to run update
1:c1e0f8e:             // statistics manually to get a row added for it's stat
1:c1e0f8e:             stats.assertTableStats("TEST_TAB_2",1);
1:c1e0f8e:             //Need to do a compress table to create the statistics for foreign
1:c1e0f8e:             // key constraint. Update statisitcs procedure is only available
1:c1e0f8e:             // in 10.5 and upwards and hence can't use that procedure here
1:c1e0f8e:             // since we are testing older releases too.
1:c1e0f8e:             s.execute("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS('APP','TEST_TAB_2', null)");
1:c1e0f8e:             //s.execute("CALL SYSCS_UTIL.SYSCS_COMPRESS_TABLE('APP','TEST_TAB_2',1)");
3:c1e0f8e:             stats.assertTableStats("TEST_TAB_2",2);
1:c1e0f8e:             s.executeUpdate("ALTER TABLE TEST_TAB_2 "+
1:c1e0f8e:                     "DROP CONSTRAINT TEST_TAB_2_FK_1");
1:c1e0f8e:             //Dropping the foreign key constraint does not remove it's 
1:c1e0f8e:             // statistics row because of DERBY-5681.
1:6be56bc:             stats.assertTableStats("TEST_TAB_2", expected);
1:c1e0f8e:             assertStatementError("42Y03", s,
1:c1e0f8e:             "CALL SYSCS_UTIL.SYSCS_DROP_STATISTICS('APP','TEST_TAB_2', null)");
1:6e000cc:             break;
1:9020cea: 
1:c1e0f8e:         case PH_SOFT_UPGRADE:
1:c1e0f8e:         case PH_POST_SOFT_UPGRADE:
1:c1e0f8e:             assertStatementError("42Y03", s,
1:c1e0f8e:                        "CALL SYSCS_UTIL.SYSCS_DROP_STATISTICS('APP','TEST_TAB_2', null)");
1:78c2db1:             break;
1:78c2db1: 
1:c1e0f8e:         case PH_HARD_UPGRADE:
1:6be56bc:             stats.assertTableStats("TEST_TAB_2", expected);
1:c1e0f8e:             s.execute("CALL SYSCS_UTIL.SYSCS_DROP_STATISTICS('APP','TEST_TAB_2', null)");
1:c1e0f8e:             stats.assertNoStatsTable("TEST_TAB_2");
1:c1e0f8e:             s.execute("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS('APP','TEST_TAB_2', null)");
1:bce78c9:             stats.assertNoStatsTable("TEST_TAB_2");
1:78c2db1:             break;
1:78c2db1: 
1:c1e0f8e:         case PH_POST_HARD_UPGRADE:
1:c1e0f8e:             //Make sure that the new procedure is still available
1:c1e0f8e:             s.execute("CALL SYSCS_UTIL.SYSCS_DROP_STATISTICS('APP','TEST_TAB_2', null)");
1:c1e0f8e:             s.executeUpdate("DROP TABLE TEST_TAB_1");
1:c1e0f8e:             s.executeUpdate("DROP TABLE TEST_TAB_2");
1:78c2db1:             break;
1:9020cea:         }
1:9020cea:     }
1:78c2db1: 
1:bce78c9:     /**
1:bce78c9:      * Verifies the behavior of the update statistics code when faced with
1:bce78c9:      * "disposable statistics entries".
1:bce78c9:      * <p>
1:bce78c9:      * A disposable statistics entry is a row in SYS.SYSSTATISTICS that has
1:bce78c9:      * been orphaned (see DERBY-5681) or it is on longer needed by the
1:bce78c9:      * Derby optimizer (due to internal changes/improvements).
1:bce78c9:      * <p>
1:bce78c9:      * This test expects different things based on the phase:
1:bce78c9:      * <dl> <dt>create</dt>
1:bce78c9:      *      <dd>- run statements that will cause disposable statistics
1:bce78c9:      *          entries to be created</dd>
1:bce78c9:      *      <dt>soft upgrade</dt>
1:bce78c9:      *      <dd>- run the new update statistics code, expecting it to leave the
1:bce78c9:      *          disposable statistics intact</dd>
1:bce78c9:      *      <dt>downgrade</dt>
1:bce78c9:      *      <dd>- verify that the relevant statistics are present</dd>
1:bce78c9:      *      <dt>hard upgrade</dt>
1:bce78c9:      *      <dd>- run the new update statistics code, expecting it to get rid
1:bce78c9:      *          of the disposable statistics</dd>
1:bce78c9:      * </dl>
1:bce78c9:      */
1:bce78c9:     public void testDisposableStatisticsExplicit()
1:bce78c9:             throws SQLException {
1:bce78c9:         // Don't run this test with versions prior to 10.5, since the
1:bce78c9:         // required SYSCS_UPDATE_STATISTICS don't exist in older versions.
1:bce78c9:         if (!oldAtLeast(10, 5)) {
1:bce78c9:             return;
1:9020cea:         }
1:78c2db1: 
1:bce78c9:         final String TBL = "ISTAT_DISPOSABLE_STATS";
1:bce78c9:         String updateStatsSQL = "call syscs_util.syscs_update_statistics(" +
1:bce78c9:                 "'APP', ?, null)";
1:6be56bc:         DisposableIndexStatistics dis = new DisposableIndexStatistics(
1:6be56bc:                 getOldVersion(), getConnection(), TBL);
1:78c2db1: 
1:bce78c9:         switch (getPhase()) {
1:bce78c9:             // create with old version
1:bce78c9:             case PH_CREATE:
1:9020cea:             {
1:bce78c9:                 dis.createAndPopulateTables();
1:31c208a:                 // The expected number of statistics entries depends on the
1:31c208a:                 // version of Derby used to create the database. Some older
1:31c208a:                 // versions of Derby contained a bug and lacked optimizations,
1:31c208a:                 // causing the number of statistics entries to increase.
1:a2f00b4:                 // Just after creation and before any update statistics expect
1:a2f00b4:                 // all stats to exist.
1:a2f00b4:                 dis.assertStatsCount(false, false);
1:bce78c9:                 break;
1:9020cea:             }
1:bce78c9:             // boot with new version and soft-upgrade
1:bce78c9:             case PH_SOFT_UPGRADE:
1:9020cea:             {
1:bce78c9:                 PreparedStatement ps = prepareStatement(updateStatsSQL);
1:bce78c9:                 String[] tables = dis.getTableNames();
1:bce78c9:                 // Update statistics on all relevant tables.
1:bce78c9:                 for (int i=0; i < tables.length; i++) {
1:bce78c9:                     ps.setString(1, tables[i]);
1:bce78c9:                     ps.executeUpdate();
1:9020cea:                 }
1:78c2db1: 
1:a2f00b4:                 // After soft upgrade and update statistics expect the 
1:a2f00b4:                 // orphaned index entry to be deleted, but the "unneeded
1:a2f00b4:                 // disposable entries" are only deleted after hard upgrade.
1:a2f00b4:                 dis.assertStatsCount(true, false);
1:bce78c9:                 break;
1:78c2db1:             }
1:bce78c9:             // soft-downgrade: boot with old version after soft-upgrade
1:bce78c9:             case PH_POST_SOFT_UPGRADE:
1:9020cea:             {
1:78c2db1: 
1:a2f00b4:                 // expect no change in entries on downgrade, should be same
1:a2f00b4:                 // as they were in soft upgrade.
1:a2f00b4:                 dis.assertStatsCount(true, false);
1:bce78c9:                 break;
3:1ede0a8:             }
1:bce78c9:             // boot with new version and hard-upgrade
1:bce78c9:             case PH_HARD_UPGRADE:
1:9020cea:             {
1:a2f00b4:                 // expect no change in entries on upgrade before update
1:a2f00b4:                 // statistics.
1:a2f00b4:                 dis.assertStatsCount(true, false);
1:bce78c9:                 PreparedStatement ps = prepareStatement(updateStatsSQL);
1:bce78c9:                 String[] tables = dis.getTableNames();
1:bce78c9:                 for (int i=0; i < tables.length; i++) {
1:bce78c9:                     ps.setString(1, tables[i]);
1:bce78c9:                     ps.executeUpdate();
1:1ede0a8:                 }
1:bce78c9:                 // Confirm that we disposed of the statistics that were added
1:bce78c9:                 // due to a bug or simply not needed by Derby.
1:bce78c9:                 try {
1:a2f00b4:                     dis.assertStatsCount(true, true);
1:bce78c9:                 } finally {
1:bce78c9:                     for (int i=0; i < tables.length; i++) {
1:bce78c9:                         dropTable(tables[i]);
1:1ede0a8:                     }
1:1ede0a8:                 }
1:bce78c9:                 commit();
1:bce78c9:                 break;
1:1ede0a8:             }
1:1ede0a8:         }
1:1ede0a8:     }
1:1ede0a8: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1:      * database (version &gt;= 10.9).
/////////////////////////////////////////////////////////////////////////
1:      * in the database (version &gt;= 10.9).
commit:8e352d6
/////////////////////////////////////////////////////////////////////////
1:     
1:     
1:     /**
1:      * Test the changes introduced to fix correctness problems with sequences.
1:      */
1:     public  void    test_5493()  throws Exception
1:     {
1:         Connection  conn = getConnection();
1:         Statement s = createStatement();
1: 
1:         switch ( getPhase() )
1:         {
1:         case PH_CREATE: // create with old version
1:             assertNull( getNewFunctionID( s ) );
1:             break;
1:             
1:         case PH_SOFT_UPGRADE: // boot with new version and soft-upgrade
1:             assertNull( getNewFunctionID( s ) );
1:             break;
1:             
1:         case PH_POST_SOFT_UPGRADE: // soft-downgrade: boot with old version after soft-upgrade
1:             assertNull( getNewFunctionID( s ) );
1:             break;
1: 
1:         case PH_HARD_UPGRADE: // boot with new version and hard-upgrade
1:             assertNotNull( getNewFunctionID( s ) );
1:             break;
1:         }
1:         
1:         s.close();
1:     }
1:     private String    getNewFunctionID( Statement s )
1:         throws Exception
1:     {
1:         ResultSet   rs = null;
1: 
1:         try {
1:             rs = s.executeQuery
1:             ( "select aliasid from sys.sysaliases where alias = 'SYSCS_PEEK_AT_SEQUENCE'" );
1:             if ( !rs.next() ) { return null; }
1:             else { return rs.getString( 1 ); }
1:         }
1:         finally
1:         {
1:             if ( rs != null ) { rs.close(); }
1:         }
1:     }
1: 
commit:bb4cfe9
/////////////////////////////////////////////////////////////////////////
commit:c5b9acb
/////////////////////////////////////////////////////////////////////////
0:             s.execute( "call syscs_util.syscs_create_user( 'FRED', 'fredpassword' )" );
/////////////////////////////////////////////////////////////////////////
1:                 assertSQLState( "4251K", se );
1:             else
1:             {
1:                 assertSQLState( "42Y03", se );
1:             }
commit:b60a998
/////////////////////////////////////////////////////////////////////////
commit:9efa649
/////////////////////////////////////////////////////////////////////////
1:     private static  final   String  UPGRADE_REQUIRED = "XCL47";
1:     private static  final   String  INVALID_PROVIDER_CHANGE = "XCY05";
1: 
/////////////////////////////////////////////////////////////////////////
1:         String  defaultDigestAlgorithm = pushAuthenticationAlgorithm( s );
/////////////////////////////////////////////////////////////////////////
1:         popAuthenticationAlgorithm( s, defaultDigestAlgorithm );
1:     }
1:     private String    pushAuthenticationAlgorithm( Statement s ) throws Exception
1:     {
1:         // make sure that an authentication algorithm has been set.
1:         // otherwise, we won't be able to create NATIVE users.
1:         String  defaultDigestAlgorithm = getDatabaseProperty( s, "derby.authentication.builtin.algorithm" );
1:         if ( defaultDigestAlgorithm == null )
1:         {
1:             setDatabaseProperty( s, "derby.authentication.builtin.algorithm", "SHA-1" );
1:         }
1: 
1:         return defaultDigestAlgorithm;
1:     }
1:     private void    popAuthenticationAlgorithm( Statement s, String defaultDigestAlgorithm ) throws Exception
1:     {
1:         // restore the authentication algorithm if we changed it
/////////////////////////////////////////////////////////////////////////
1:      * Make sure that NATIVE LOCAL authentication can't be turned on
1:      * before hard-upgrade.
1:      */
1:     public  void    testNativeLocalAuthentication()  throws Exception
1:     {
1:         Statement s = createStatement();
1: 
1:         switch ( getPhase() )
1:         {
1:         case PH_CREATE: // create with old version
1:         case PH_POST_SOFT_UPGRADE: // soft-downgrade: boot with old version after soft-upgrade
1: 
1:             //
1:             // It's possible (although very unlikely) that someone could set the
1:             // authentication provider to be NATIVE::LOCAL in an old database
1:             // just before upgrading. If they do this, they will get an error at
1:             // soft-upgrade time and they will have to back off to the old
1:             // derby version in order to unset the authentication provider.
1:             //
1:             setDatabaseProperty( s, "derby.authentication.provider", "NATIVE::LOCAL" );
1:             setDatabaseProperty( s, "derby.authentication.provider", null );
1:             break;
1:             
1:         case PH_SOFT_UPGRADE: // boot with new version and soft-upgrade
1:             setDatabaseProperty( s, "derby.authentication.provider", "com.acme.AcmeAuthenticator" );
1:             assertStatementError
1:                 (
1:                  UPGRADE_REQUIRED, s,
1:                  "call syscs_util.syscs_set_database_property( 'derby.authentication.provider', 'NATIVE::LOCAL' )"
1:                  );
1:             setDatabaseProperty( s, "derby.authentication.provider", null );
1:             break;
1:             
1:         case PH_HARD_UPGRADE: // boot with new version and hard-upgrade
1:             //
1:             // Can't actually turn on NATIVE LOCAL authentication in the upgrade tests because, once turned on,
1:             // you can't turn it off and that would mess up later tests. 
1:             //
1:             break;
1:         }
1:         
1:         s.close();
1:     }
1: 
1:     /**
commit:a84fc26
/////////////////////////////////////////////////////////////////////////
1:         // make sure that an authentication algorithm has been set
0:         String  defaultDigestAlgorithm = getDatabaseProperty( s, "derby.authentication.builtin.algorithm" );
1:         if ( defaultDigestAlgorithm == null )
1:         {
0:             setDatabaseProperty( s, "derby.authentication.builtin.algorithm", "SHA-1" );
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:         // restore the authentication algorithm if we changed it
0:         if ( defaultDigestAlgorithm == null )
1:         {
1:             setDatabaseProperty( s, "derby.authentication.builtin.algorithm", null );
1:         }
1:     }
1:     private void  setDatabaseProperty( Statement s, String key, String value )
1:         throws Exception
1:     {
1:         if ( value == null ) { value = "cast ( null as varchar( 32672 ) )"; }
1:         else { value = "'" + value + "'"; }
1:         String  command = "call syscs_util.syscs_set_database_property( '" + key + "', " + value + " )";
1: 
1:         s.execute( command );
1:     }
1:     private String  getDatabaseProperty( Statement s, String key )
1:         throws Exception
1:     {
1:         ResultSet   rs = s.executeQuery( "values( syscs_util.syscs_get_database_property( '" + key + "' ) )" );
1: 
1:         try {
1:             rs.next();
1:             return rs.getString( 1 );
1:         }
1:         finally
1:         {
1:             rs.close();
1:         }
commit:04cfd28
/////////////////////////////////////////////////////////////////////////
1: 
0:             // does nothing
0:             s.execute( "call syscs_util.syscs_modify_password( 'test_dbo_password_rev0' )" );
1: 
0:             s.execute( "call syscs_util.syscs_reset_password( 'fred', 'fredpassword_rev2' )" );
1: 
commit:92268ac
/////////////////////////////////////////////////////////////////////////
1:             vetNativeProcs( s, false );
1:             vetNativeProcs( s, false );
1:             vetNativeProcs( s, false );
1:             vetNativeProcs( s, true );
/////////////////////////////////////////////////////////////////////////
1:     private void    vetNativeProcs( Statement s, boolean shouldExist ) throws Exception
1:     {
1:         try {
0:             s.execute( "call syscs_util.syscs_create_user( 'fred', 'fredpassword' )" );
1:             
0:             ResultSet   rs = s.executeQuery( "select username from sys.sysusers order by username" );
1:             rs.next();
0:             assertEquals( "fred", rs.getString( 1 ) );
1:             
0:             s.execute( "call syscs_util.syscs_drop_user( 'fred' )" );
1:             
0:             rs = s.executeQuery( "select username from sys.sysusers order by username" );
0:             assertFalse( rs.next() );
1: 
1:             rs.close();
1: 
1:             if ( !shouldExist )
1:             {
1:                 fail( "syscs_util.syscs_create_user should not exist." );
1:             }
1:         } catch (SQLException se )
1:         {
1:             if ( shouldExist )
1:             {
0:                 fail( "Saw unexpected error: " + se.getMessage() );
1:             }
0:             assertSQLState( "42Y03", se );
1:         }
1:         
1:     }
commit:aa609d5
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Make sure that the catalogs and procedures for NATIVE authentication
1:      * only appear after hard-upgrade.
1:      */
1:     public  void    testNativeAuthentication()  throws Exception
1:     {
1:         Statement s = createStatement();
1: 
1:         switch ( getPhase() )
1:         {
1:         case PH_CREATE: // create with old version
1:             vetSYSUSERS( s, false );
1:             break;
1:             
1:         case PH_SOFT_UPGRADE: // boot with new version and soft-upgrade
1:             vetSYSUSERS( s, false );
1:             break;
1:             
1:         case PH_POST_SOFT_UPGRADE: // soft-downgrade: boot with old version after soft-upgrade
1:             vetSYSUSERS( s, false );
1:             break;
1: 
1:         case PH_HARD_UPGRADE: // boot with new version and hard-upgrade
1:             vetSYSUSERS( s, true );
1:             break;
1:         }
1:         
1:         s.close();
1:     }
1:     private void    vetSYSUSERS( Statement s, boolean shouldExist ) throws Exception
1:     {
1:         ResultSet   rs = s.executeQuery( "select count(*) from sys.systables where tablename = 'SYSUSERS'" );
0:         rs.next();
1: 
1:         int expectedValue = shouldExist ? 1 : 0;
1: 
1:         assertEquals( expectedValue, rs.getInt( 1 ) );
1: 
0:         rs.close();
1:     }
1:     
commit:d313491
/////////////////////////////////////////////////////////////////////////
commit:9020cea
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * Make sure that generator-based identity columns don't break upgrade/downgrade.
0:      * See DERBY-4437. Originally, this behavior was backported to 10.8.2. However, the behavior
0:      * was backed out of 10.8.2.
1:      */
0:     public void testIdentity10_8_2() throws Exception
1:     {
1:         Statement s = createStatement();
1: 
0:         boolean supportsSequences = oldAtLeast( 10, 6 );
1: 
1:         switch ( getPhase() )
1:         {
1:         case PH_CREATE: // create with old version
0:             s.execute( "create table t_identity1_4437( a int, b int generated always as identity )" );
0:             s.execute( "insert into t_identity1_4437( a ) values ( 100 )" );
0:             vetIdentityValues_4437( s, "t_identity1_4437", 1, 2 );
1: 
0:             if ( supportsSequences )
1:             {
0:                 s.execute( "create sequence seq1_4437" );
0:                 vetSequenceValue( s, "seq1_4437", -2147483648, -2147483643 );
1:             }
1:             
1:             break;
1:             
1:         case PH_SOFT_UPGRADE: // boot with new version and soft-upgrade
0:             s.execute( "insert into t_identity1_4437( a ) values ( 200 )" );
0:             vetIdentityValues_4437( s, "t_identity1_4437", 2, 22 );
1: 
0:             s.execute( "create table t_identity2_4437( a int, b int generated always as identity )" );
0:             s.execute( "insert into t_identity2_4437( a ) values ( 100 )" );
0:             vetIdentityValues_4437( s, "t_identity2_4437", 1, 21 );
1: 
0:             if ( supportsSequences )
1:             {
0:                 vetSequenceValue( s, "seq1_4437", -2147483643, -2147483623 );
1:             
0:                 s.execute( "create sequence seq2_4437" );
0:                 vetSequenceValue( s, "seq2_4437", -2147483648, -2147483628 );
1:             }
1: 
1:             break;
1:             
1:         case PH_POST_SOFT_UPGRADE: // soft-downgrade: boot with old version after soft-upgrade
0:             s.execute( "insert into t_identity1_4437( a ) values ( 300 )" );
0:             vetIdentityValues_4437( s, "t_identity1_4437", 3, 4 );
1: 
0:             s.execute( "insert into t_identity2_4437( a ) values ( 200 )" );
0:             vetIdentityValues_4437( s, "t_identity2_4437", 2, 3 );
1: 
0:             if ( supportsSequences )
1:             {
0:                 vetSequenceValue( s, "seq1_4437", -2147483642, -2147483637 );
0:                 vetSequenceValue( s, "seq2_4437", -2147483647, -2147483642 );
1:             }
1:             
1:             break;
1: 
1:         case PH_HARD_UPGRADE: // boot with new version and hard-upgrade
0:             s.execute( "insert into t_identity1_4437( a ) values ( 400 )" );
0:             vetIdentityValues_4437( s, "t_identity1_4437", 4, 24 );
1: 
0:             s.execute( "insert into t_identity2_4437( a ) values ( 300 )" );
0:             vetIdentityValues_4437( s, "t_identity2_4437", 3, 23 );
1: 
0:             if ( supportsSequences )
1:             {
0:                 vetSequenceValue( s, "seq1_4437", -2147483637, -2147483617 );
0:                 vetSequenceValue( s, "seq2_4437", -2147483642, -2147483622 );
1:             }
1:             
1:             break;
1:         }
1:         
1:         s.close();
1:     }
0:     private void    vetIdentityValues_4437( Statement s, String tableName, int expectedRowCount, int expectedSyscolumnsValue ) throws Exception
1:     {
0:         vetTable( s, tableName, expectedRowCount );
1: 
0:         ResultSet rs = s.executeQuery
0:             (
0:              "select c.autoincrementvalue\n" +
0:              "from sys.syscolumns c, sys.systables t\n" +
0:              "where t.tablename = '" + tableName.toUpperCase() + "'\n" +
0:              "and t.tableid = c.referenceid\n" +
0:              "and c.columnname = 'B'"
0:              );
0:         rs.next();
0:         int    actualSyscolumnsValue = rs.getInt( 1 );
0:         vetValues( expectedSyscolumnsValue, actualSyscolumnsValue );
0:         rs.close();
1:     }
0:     private void    vetSequenceValue( Statement s, String sequenceName, int expectedSequenceValue, int expectedSyssequencesValue ) throws Exception
1:     {
0:         ResultSet   rs = s.executeQuery( "values ( next value for " + sequenceName + " )" );
0:         rs.next();
0:         int actualSequenceValue = rs.getInt( 1 );
0:         vetValues( expectedSequenceValue, actualSequenceValue );
0:         rs.close();
1: 
0:         rs = s.executeQuery
0:             (
0:              "select currentvalue\n" +
0:              "from sys.syssequences\n" +
0:              "where sequencename = '" + sequenceName.toUpperCase() + "'\n"
0:              );
0:         rs.next();
0:         int    actualSyssequencesValue = rs.getInt( 1 );
0:         vetValues( expectedSyssequencesValue, actualSyssequencesValue );
0:         rs.close();
1:     }
0:     private void    vetTable( Statement s, String tableName, int expectedRowCount ) throws Exception
1:     {
0:         int     actualRowCount = 0;
0:         int     lastValue = 0;
1: 
0:         ResultSet   rs = s.executeQuery( "select * from " + tableName + " order by a" );
1: 
0:         while( rs.next() )
1:         {
0:             actualRowCount++;
1:             
0:             int currentValue = rs.getInt( 2 );
0:             if ( actualRowCount > 1 )
1:             {
0:                 assertTrue( currentValue > lastValue );
1:             }
0:             lastValue = currentValue;
1:         }
0:         rs.close();
1: 
0:         vetValues( expectedRowCount, actualRowCount );
1:     }
0:     private void    vetValues( int expected, int actual )   throws Exception
1:     {
0:         assertEquals
0:             (
0:              getOldVersionString(),
0:              expected,
0:              actual
0:              );
1:     }
commit:6e000cc
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1: Derby - Class org.apache.derbyTesting.functionTests.tests.upgradeTests.Changes10_9
1: 
1: Licensed to the Apache Software Foundation (ASF) under one or more
1: contributor license agreements.  See the NOTICE file distributed with
1: this work for additional information regarding copyright ownership.
1: The ASF licenses this file to You under the Apache License, Version 2.0
1: (the "License"); you may not use this file except in compliance with
1: the License.  You may obtain a copy of the License at
1: 
1:    http://www.apache.org/licenses/LICENSE-2.0
1: 
1: Unless required by applicable law or agreed to in writing, software
1: distributed under the License is distributed on an "AS IS" BASIS,
1: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1: See the License for the specific language governing permissions and
1: limitations under the License.
1: 
1: */
1: package org.apache.derbyTesting.functionTests.tests.upgradeTests;
1: 
1: import org.apache.derbyTesting.junit.SupportFilesSetup;
1: 
1: import java.sql.SQLException;
0: import java.sql.SQLWarning;
1: import java.sql.Statement;
1: import java.sql.ResultSet;
0: import java.util.HashSet;
0: import java.util.Set;
1: 
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: 
1: import org.apache.derbyTesting.junit.JDBC;
1: 
1: 
1: /**
1:  * Upgrade test cases for 10.9.
1:  */
1: public class Changes10_9 extends UpgradeChange
0: {
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // CONSTANTS
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // STATE
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // CONSTRUCTOR
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     public Changes10_9(String name)
0:     {
1:         super(name);
1:     }
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // JUnit BEHAVIOR
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Return the suite of tests to test the changes made in 10.7.
1:      * @param phase an integer that indicates the current phase in
1:      *              the upgrade test.
1:      * @return the test suite created.
1:      */
1:     public static Test suite(int phase) {
0:         TestSuite suite = new TestSuite("Upgrade test for 10.9");
1: 
1:         suite.addTestSuite(Changes10_9.class);
0:         return new SupportFilesSetup((Test) suite);
1:     }
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // TESTS
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     /**
0:      * Make sure that generator-based identity columns don't break upgrade/downgrade.
1:      */
0:     public void testIdentity() throws Exception
0:     {
1:         Statement s = createStatement();
1: 
0:         switch ( getPhase() )
0:         {
1:         case PH_CREATE: // create with old version
0:             s.execute( "create table t_identity1( a int, b int generated always as identity )" );
0:             s.execute( "insert into t_identity1( a ) values ( 100 )" );
0:             vetIdentityValues( s, "t_identity1", 1 );
1:             break;
1:             
0:         case PH_SOFT_UPGRADE: // boot with new version and soft-upgrade
0:             s.execute( "insert into t_identity1( a ) values ( 200 )" );
0:             vetIdentityValues( s, "t_identity1", 2 );
1: 
0:             s.execute( "create table t_identity2( a int, b int generated always as identity )" );
0:             s.execute( "insert into t_identity2( a ) values ( 100 )" );
0:             vetIdentityValues( s, "t_identity2", 1 );
1: 
1:             break;
1:             
0:         case PH_POST_SOFT_UPGRADE: // soft-downgrade: boot with old version after soft-upgrade
0:             s.execute( "insert into t_identity1( a ) values ( 300 )" );
0:             vetIdentityValues( s, "t_identity1", 3 );
1: 
0:             s.execute( "insert into t_identity2( a ) values ( 200 )" );
0:             vetIdentityValues( s, "t_identity2", 2 );
1: 
1:             break;
1: 
1:         case PH_HARD_UPGRADE: // boot with new version and hard-upgrade
0:             s.execute( "insert into t_identity1( a ) values ( 400 )" );
0:             vetIdentityValues( s, "t_identity1", 4 );
1: 
0:             s.execute( "insert into t_identity2( a ) values ( 300 )" );
0:             vetIdentityValues( s, "t_identity2", 3 );
1: 
1:             break;
1:         }
1:         
1:         s.close();
1:     }
0:     private void    vetIdentityValues( Statement s, String tableName, int expectedRowCount ) throws Exception
0:     {
0:         int     actualRowCount = 0;
0:         int     lastValue = 0;
1: 
0:         ResultSet   rs = s.executeQuery( "select * from " + tableName + " order by a" );
1: 
0:         while( rs.next() )
0:         {
0:             actualRowCount++;
1:             
0:             int currentValue = rs.getInt( 2 );
0:             if ( actualRowCount > 1 )
0:             {
0:                 assertTrue( currentValue > lastValue );
1:             }
0:             lastValue = currentValue;
1:         }
1: 
0:         assertEquals( expectedRowCount, actualRowCount );
1:     }
1: 
1: 
1: }
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.BaseTestSuite;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite("Upgrade test for 10.9");
commit:78c2db1
/////////////////////////////////////////////////////////////////////////
1: import java.io.File;
1: import java.net.MalformedURLException;
1: import java.net.URL;
1: import java.util.ArrayList;
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.TestConfiguration;
/////////////////////////////////////////////////////////////////////////
1:         initPattern();
/////////////////////////////////////////////////////////////////////////
1:     private static final String[] SUPPORT_FILES_SOURCE =
0:     {
1:         "functionTests/tests/lang/dcl_java.jar",
1:         "functionTests/tests/lang/dcl_emc1.jar",
1:         "functionTests/tests/lang/dcl_emc2.jar",
1:     };
1:     
1:     
/////////////////////////////////////////////////////////////////////////
1:         
1:         return new SupportFilesSetup(
1:                 (Test)suite, SUPPORT_FILES_SOURCE);
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:     /**
1:      * For 10.9 and later storage of jar files changed. DERBY-5357.
1:      */
1:     public void testJarStorage()  throws Exception
0:     {
1:         Statement s = createStatement();
1: 
1:         switch (getPhase()) {
0:         case PH_CREATE: // create with old version
1:             createSchema("EMC");
1:             createSchema("FOO");
1: 
1:             s.executeUpdate(
1:                 "create procedure EMC.ADDCONTACT(id INT, e_mail VARCHAR(30)) " +
1:                 "MODIFIES SQL DATA " +
1:                 "external name " +
1:                 "'org.apache.derbyTesting.databaseclassloader.emc.addContact'" +
1:                 " language java parameter style java");
1:             s.executeUpdate(
1:                 "create table EMC.CONTACTS " +
1:                 "    (id int, e_mail varchar(30))");
1: 
1:             installJar("dcl_emc1.jar", "EMC.MAIL_APP");
1:             installJar("dcl_java.jar", "EMC.MY_JAVA");
1:             installJar("dcl_emc2.jar", "FOO.BAR");
1: 
1:             setDBClasspath("EMC.MAIL_APP");
1:             tryCall();
1:             setDBClasspath(null);
1: 
1:             break;
1: 
1:         case PH_SOFT_UPGRADE:
1:             // boot with new version and soft-upgrade
1:         case PH_POST_SOFT_UPGRADE:
1:             // soft-downgrade: boot with old version after soft-upgrade
1: 
1:             setDBClasspath("EMC.MAIL_APP");
1:             tryCall();
1:             setDBClasspath(null);
1:             
1:             // if we can do this, it hasn't moved already:
1:             replaceJar("dcl_emc1.jar", "EMC.MAIL_APP");
1: 
1:             setDBClasspath("EMC.MAIL_APP");
1:             tryCall();
1:             setDBClasspath(null);
1: 
1:             break;
1:             
0:         case PH_HARD_UPGRADE: // boot with new version and hard-upgrade
1: 
1:             setDBClasspath("EMC.MAIL_APP");
1:             tryCall();
1:             setDBClasspath(null);
1: 
1:             installJar("dcl_emc1.jar", "FOO.\"BAR/..\\../\"");
1: 
1:             verifyNewLocations(4);
1:             
1:             removeJar("EMC.MAIL_APP");
1:             installJar("dcl_emc1.jar", "EMC.MAIL_APP");
1:             
1:             setDBClasspath("EMC.MAIL_APP");
1:             tryCall();
1:             setDBClasspath(null);
1:             
1:             // finally, check that all the rest are also here
1:             replaceJar("dcl_java.jar", "EMC.MY_JAVA");
1:             replaceJar("dcl_emc2.jar", "FOO.BAR");
1:             replaceJar("dcl_emc1.jar", "FOO.\"BAR/..\\../\"");
1: 
1:             // clean up
1:             removeJar("EMC.MY_JAVA");
1:             removeJar("FOO.BAR");
1:             removeJar("FOO.\"BAR/..\\../\"");
1:             removeJar("EMC.MAIL_APP");
1:             s.executeUpdate("drop table EMC.CONTACTS");
1:             s.executeUpdate("drop procedure EMC.ADDCONTACT");
1:             s.executeUpdate("drop schema FOO restrict");
1:             s.executeUpdate("drop schema EMC restrict");
1: 
1:             break;
1:         }
1:         
1:         s.close();
1:     }
1: 
1:     private void createSchema(String name) throws SQLException {
1:         Statement s = createStatement();
1:         s.executeUpdate("create schema " + name);
1:         s.close();
1:     }
1: 
1:     private void installJar(String resource, String jarName)
1:             throws SQLException, MalformedURLException {        
1: 
1:         URL jar = SupportFilesSetup.getReadOnlyURL(resource);
1:         
1:         CallableStatement cs = prepareCall("CALL SQLJ.INSTALL_JAR(?, ?, 0)");
1:         cs.setString(1, jar.toExternalForm());
1:         cs.setString(2, jarName);
1:         cs.executeUpdate();
1:         cs.close();
1:     }
1:     
1:     private void replaceJar(String resource, String jarName)
1:             throws SQLException, MalformedURLException {        
1: 
1:         URL jar = SupportFilesSetup.getReadOnlyURL(resource);
1:         CallableStatement cs = prepareCall("CALL SQLJ.REPLACE_JAR(?, ?)");
1:         cs.setString(1, jar.toExternalForm());
1:         cs.setString(2, jarName);
1:         cs.executeUpdate();
1:         cs.close();
1:     }
1:     
1:     private void removeJar(String jarName) throws SQLException {
1:         CallableStatement cs = prepareCall("CALL SQLJ.REMOVE_JAR(?, 0)");       
1:         cs.setString(1, jarName);       
1:         cs.executeUpdate();        
1:         cs.close();
1:     }
1: 
1:     private void setDBClasspath(String cp) throws SQLException {
1:         CallableStatement cs = prepareCall(
1:           "CALL SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:           "'derby.database.classpath', ?)");
1: 
1:         cs.setString(1, cp);
1:         cs.executeUpdate();
1:         cs.close();
1:     }
1: 
1:     private void tryCall() throws SQLException {
1:         if (JDBC.vmSupportsJSR169()) {
1:             return; // skip, EMC uses DriverManager
1:         }
1: 
1:         CallableStatement cs = prepareCall("CALL EMC.ADDCONTACT(?, ?)");
1:         cs.setInt(1, 0);
1:         cs.setString(2, "now@classpathchange.com");
1:         cs.executeUpdate();
1:         cs.close();
1:     }
1: 
1:     private void verifyNewLocations(int noOfObjects)
1:             throws SQLException {
1:         TestConfiguration tc = TestConfiguration.getCurrent();
1:         String dbPath = tc.getPhysicalDatabaseName(tc.getDefaultDatabaseName());
1:         String jarDirName =
1:             "system" + File.separator + dbPath + File.separator + "jar";
1:         File jarDir = new File(jarDirName);
1: 
1:         assertTrue(jarDir.isDirectory());
1: 
1:         File[] contents = jarDir.listFiles();
1:         
1:         // <db>/jar should now contain this no of files, none of which are
1:         // directories
1:         assertEquals(noOfObjects, contents.length);
1:         
1:         // assert that all the old style directories are gone
1:         for (int i=0; i < contents.length; i++) {
1:             File f = contents[i];
1:             assertTrue(f.isFile());
1:             assertFileNameShape(f.getName());
1:         }
1:     }
1: 
1: 
1:     /**
1:      * Regexp pattern to match the file name of a jar file stored in the
0:      * database (version >= 10.9).
1:      */
1:     private Goal[] pattern;
1:     
1:     /**
1:      * Initialize a pattern corresponding to:
1:      * <p/>
1:      * &lt;Derby uuid string&gt;[.]jar[.]G[0-9]+
1:      * <p/>
1:      * where:
1:      * <p/>
1:      * &lt;Derby uuid string&gt; has the form
1:      * hhhhhhhh-hhhh-hhhh-hhhh-hhhhhhhhhhhh
1:      * <p/>
1:      * where <em>h</em> id a lower case hex digit.
1:      */
1:     private void initPattern() {
0:         List l = new ArrayList(100);
1:         // The UUID format is determined by
1:         // org.apache.derby.impl.services.uuid.BasicUUID#toString
1: 
1:         for (int i=0; i < 8; i++) {
1:             l.add(new CharRange(new char[][]{{'0','9'},{'a','f'}}));
1:         }
1: 
1:         l.add(new SingleChar('-'));
1:         
1:         for (int j = 0; j < 3; j++) {
1:             for (int i=0; i < 4; i++) {
1:                 l.add(new CharRange(new char[][]{{'0','9'},{'a','f'}}));
1:             }
1:             
1:             l.add(new SingleChar('-'));
1:         }
1:         
1:         for (int i=0; i < 12; i++) {
1:             l.add(new CharRange(new char[][]{{'0','9'},{'a','f'}}));
1:         }
1:         
1:         l.add(new SingleChar('.'));
1:         l.add(new SingleChar('j'));
1:         l.add(new SingleChar('a'));
1:         l.add(new SingleChar('r'));
1:         l.add(new SingleChar('.'));
1:         l.add(new SingleChar('G'));
1:         l.add(new CharRange(new char[][]{{'0','9'}}, Goal.REPEAT));
0:         this.pattern = new Goal[l.size()];
0:         System.arraycopy(l.toArray(), 0, this.pattern, 0, l.size());
1:     }
1: 
1:     /**
1:      * assert that fName has the expected shape of a jar file
0:      * in the database (version >= 10.9).
1:      */
1:     private void assertFileNameShape(String fName) {
1:         assertTrue(matches(fName, pattern));
1:     }
1:     
1:     /**
1:      * Poor man's regexp matcher: can match patterns of type below, where
1:      * start "^" and end "$" is implied: must match whole string.
1:      * <p/>
1:      * reg.exp: ( '[' &lt;fromchar&gt;-&lt;tochar&gt; ] '+'? ']' |
1:      *            &lt;char&gt; '+'? )*
1:      */
1:     private boolean matches(String fName, Goal[] pattern) {
1:         int patIdx = 0;
1:         for (int i = 0; i < fName.length(); i++) {
1:             Goal p = pattern[patIdx];
1:             char c = fName.charAt(i);
1: 
1:             if (p.matches(c)) {
1:                 if (!p.isRepeatable()) {
1:                     patIdx++;
1:                 } 
1:                 p.setFoundOnce();
1:                 continue;
1:             } 
1:                 
1:             // Goal did not match: if we have a repeatable goal and we already
1:             // found one occurence it's ok, to step on to next goal in pattern
1:             // and see it that matches.
1:             patIdx++;
1:             if (p.matches(c)) {
1:                 if (!p.isRepeatable()) {
1:                     patIdx++;
1:                 } 
1:                 p.setFoundOnce();
1:                 continue;
1:             }
1: 
1:             return false;
1:             
1:         }
1:         
1:         return patIdx >= (pattern.length - 1); // exact match
1:     }
1:     
1:     abstract class Goal {
1:         public abstract boolean matches(char c);
1:         
1:         public final static int REPEAT = 0; // optional goal property
1:         int option = -1;
1:         boolean foundOnce = false;
1: 
1:         public boolean isRepeatable () {
1:             return option == REPEAT;
1:         }
1:         
1:         public void setFoundOnce() {
1:             this.foundOnce = true;
1:         }
1:         
1:         public boolean foundOnce () {
1:             return this.foundOnce;
1:         }
1:     }
1: 
1:     private class CharRange extends Goal {
1:         private char[][] ranges;
1:         
1:         public CharRange(char[][]ranges) {
1:             this.ranges = (char[][])ranges.clone();
1:         }
1:         
1:         public CharRange(char[][]ranges, int option) {
1:             this.ranges = (char[][])ranges.clone();
1:             this.option = option;
1:         }
1:         
1:         public boolean matches(char c) {
1:             for (int i = 0; i < ranges.length; i++) {
1:                 if (c >= ranges[i][0] && c <= ranges[i][1]) {
1:                     return true;
1:                 }
1:             }
1:             return false;
1:         }
1:     }
1: 
1:     private class SingleChar extends Goal {
1:         private char c;
1:         private int option = -1;
1:         private boolean foundOnce = false;
1:         
1:         public SingleChar(char c) {
1:             this.c = c;
1:         }
1:     
1:         public SingleChar(char c, int option) {
1:             this.c = c;
1:             this.option = option;
1:         }
1:         public boolean matches(char c) {
1:             return c == this.c;
1:         }
1:     }
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:030bfac
/////////////////////////////////////////////////////////////////////////
0: 
1:             // DERBY-6505: Take a backup of the database. Backing up the
1:             // jar storage takes a different path in soft upgrade, so make
1:             // sure that path is exercised.
1:             String backupdir =
1:                 SupportFilesSetup.getReadWriteFileName("d6505-backup");
1:             PreparedStatement backupStmt =
1:                 prepareStatement("call syscs_util.syscs_backup_database(?)");
1:             backupStmt.setString(1, backupdir);
1:             backupStmt.execute();
0: 
1:             // fallthrough... run the same tests as in post soft upgrade.
commit:e18f54b
/////////////////////////////////////////////////////////////////////////
1:         List<Goal> l = new ArrayList<Goal>(100);
/////////////////////////////////////////////////////////////////////////
0: 
1:         this.pattern = l.toArray(new Goal[l.size()]);
commit:1ede0a8
/////////////////////////////////////////////////////////////////////////
1: import java.sql.CallableStatement;
1: import java.sql.Connection;
1: import java.sql.PreparedStatement;
0: import java.sql.SQLException;
0: import java.sql.Statement;
0: 
1: import javax.sql.DataSource;
1: import org.apache.derbyTesting.junit.JDBCDataSource;
0: import org.apache.derbyTesting.junit.SupportFilesSetup;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Make sure builtin authentication doesn't use a hash scheme that's not
1:      * supported by the old version until the database has been hard upgraded.
1:      * See DERBY-4483 and DERBY-5539.
1:      */
1:     public void testBuiltinAuthenticationWithConfigurableHash()
1:             throws SQLException {
0: 
1:         // This test needs to enable authentication, which is not supported
1:         // in the default database for the upgrade tests, so roll our own.
1:         DataSource ds = JDBCDataSource.getDataSourceLogical("BUILTIN_10_9");
0: 
1:         // Add create=true or upgrade=true, as appropriate, since we don't
1:         // get this for free when we don't use the default database.
1:         if (getPhase() == PH_CREATE) {
1:             JDBCDataSource.setBeanProperty(ds, "createDatabase", "create");
1:         } else if (getPhase() == PH_HARD_UPGRADE) {
1:             JDBCDataSource.setBeanProperty(
1:                     ds, "connectionAttributes", "upgrade=true");
1:         }
0: 
1:         // Connect as database owner, possibly creating or upgrading the
1:         // database.
1:         Connection c = ds.getConnection("dbo", "the boss");
0: 
1:         // Let's first verify that all the users can connect after the changes
1:         // in the previous phase. Would fail for instance in post soft upgrade
1:         // if soft upgrade saved passwords using the new scheme.
1:         verifyCanConnect(ds);
0: 
1:         CallableStatement setProp = c.prepareCall(
1:                 "call syscs_util.syscs_set_database_property(?, ?)");
0: 
1:         if (getPhase() == PH_CREATE) {
1:             // The database is being created. Make sure that builtin
1:             // authentication is enabled.
1:             setProp.setString(1, "derby.connection.requireAuthentication");
1:             setProp.setString(2, "true");
1:             setProp.execute();
0: 
1:             setProp.setString(1, "derby.authentication.provider");
1:             setProp.setString(2, "BUILTIN");
1:             setProp.execute();
0: 
1:             // Set the length of the random salt to 0 to ensure that the
1:             // hashed token doesn't vary between test runs.
1:             setProp.setString(1, "derby.authentication.builtin.saltLength");
1:             setProp.setInt(2, 0);
1:             setProp.execute();
1:         }
0: 
1:         // Set (or reset) passwords for all users.
1:         setPasswords(setProp);
1:         setProp.close();
0: 
1:         // We should still be able to connect.
1:         verifyCanConnect(ds);
0: 
1:         // Check that the passwords are stored using the expected scheme (new
1:         // configurable hash scheme in hard upgrade, old scheme otherwise).
1:         verifyPasswords(c);
0: 
1:         c.close();
0: 
1:         // The framework doesn't know how to shutdown a database using
1:         // authentication, so do it manually as database owner here.
1:         JDBCDataSource.setBeanProperty(ds, "user", "dbo");
1:         JDBCDataSource.setBeanProperty(ds, "password", "the boss");
1:         JDBCDataSource.shutdownDatabase(ds);
1:     }
0: 
1:     /**
1:      * Information about users for the test of builtin authentication with
1:      * configurable hash algorithm. Two-dimensional array of strings where
1:      * each row contains (1) a user name, (2) a password, (3) the name of a
1:      * digest algorithm with which the password should be hashed, (4) the
1:      * hashed password when the old scheme is used, (5) the hashed password
1:      * when the new, configurable hash scheme is used in databases that
1:      * don't support the key-stretching extension (DERBY-5539), and (6) the
1:      * hashed password when configurable hash with key stretching is used.
1:      */
1:     private static final String[][] USERS = {
1:         { "dbo", "the boss", null,
1:                   "3b6071d99b1d48ab732e75a8de701b6c77632db65898",
1:                   "3b6071d99b1d48ab732e75a8de701b6c77632db65898",
1:                   "3b6071d99b1d48ab732e75a8de701b6c77632db65898",
1:         },
1:         { "pat", "postman", "MD5",
1:                   "3b609129e181a7f7527697235c8aead65c461a0257f3",
1:                   "3b61aaca567ed43d1ba2e6402cbf1a723407:MD5",
1:                   "3b624f4b0d7f3d2330c1db98a2000c62b5cd::1000:MD5",
1:         },
1:         { "sam", "fireman", "SHA-1",
1:                   "3b609e5173cfa03620061518adc92f2a58c7b15cf04f",
1:                   "3b6197160362c0122fcd7a63a9da58fd0781140901fb:SHA-1",
1:                   "3b62a2d88ffac5332219116ab53e29dd3b9e1222e990::1000:SHA-1",
1:         },
1:     };
0: 
1:     /**
1:      * Set the passwords for all users specified in {@code USERS}.
1:      *
1:      * @param cs a callable statement that sets database properties
1:      */
1:     private void setPasswords(CallableStatement cs) throws SQLException {
1:         for (int i = 0; i < USERS.length; i++) {
1:             // Use the specified algorithm, if possible. (Will be ignored if
1:             // the data dictionary doesn't support the new scheme.)
1:             cs.setString(1, Changes10_6.HASH_ALGORITHM_PROPERTY);
1:             cs.setString(2, USERS[i][2]);
1:             cs.execute();
1:             // Set the password.
1:             cs.setString(1, "derby.user." + USERS[i][0]);
1:             cs.setString(2, USERS[i][1]);
1:             cs.execute();
1:         }
1:     }
0: 
1:     /**
1:      * Verify that all passwords for the users in {@code USERS} are stored
1:      * as expected. Raise an assert failure on mismatch.
1:      *
1:      * @param c a connection to the database
1:      */
1:     private void verifyPasswords(Connection c)
1:             throws SQLException {
1:         int pwIdx;
1:         if (getPhase() == PH_HARD_UPGRADE) {
1:             // Expect configurable hash scheme with key stretching in fully
1:             // upgraded databases.
1:             pwIdx = 5;
1:         } else if (oldAtLeast(10, 6)) {
1:             // Databases whose dictionary is at least version 10.6 support
1:             // configurable hash without key stretching.
1:             pwIdx = 4;
1:         } else {
1:             // Older databases only support the old scheme based on SHA-1.
1:             pwIdx = 3;
1:         }
1:         PreparedStatement ps = c.prepareStatement(
1:                 "values syscs_util.syscs_get_database_property(?)");
1:         for (int i = 0; i < USERS.length; i++) {
1:             String expectedToken = USERS[i][pwIdx];
1:             ps.setString(1, "derby.user." + USERS[i][0]);
1:             JDBC.assertSingleValueResultSet(ps.executeQuery(), expectedToken);
1:         }
1:         ps.close();
1:     }
0: 
1:     /**
1:      * Verify that all users specified in {@code USERS} can connect to the
1:      * database.
1:      *
1:      * @param ds a data source for connecting to the database
1:      * @throws SQLException if one of the users cannot connect to the database
1:      */
1:     private void verifyCanConnect(DataSource ds) throws SQLException {
1:         for (int i = 0; i < USERS.length; i++) {
1:             Connection c = ds.getConnection(USERS[i][0], USERS[i][1]);
1:             c.close();
1:         }
1:     }
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:a2f00b4
/////////////////////////////////////////////////////////////////////////
1:                 // Just after creation and before any update statistics expect
1:                 // all stats to exist.
1:                 dis.assertStatsCount(false, false);
/////////////////////////////////////////////////////////////////////////
0: 
1:                 // After soft upgrade and update statistics expect the 
1:                 // orphaned index entry to be deleted, but the "unneeded
1:                 // disposable entries" are only deleted after hard upgrade.
1:                 dis.assertStatsCount(true, false);
0: 
1:                 // expect no change in entries on downgrade, should be same
1:                 // as they were in soft upgrade.
1:                 dis.assertStatsCount(true, false);
1:                 // expect no change in entries on upgrade before update
1:                 // statistics.
1:                 dis.assertStatsCount(true, false);
/////////////////////////////////////////////////////////////////////////
1:                     dis.assertStatsCount(true, true);
/////////////////////////////////////////////////////////////////////////
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:31c208a
/////////////////////////////////////////////////////////////////////////
1:                 // The expected number of statistics entries depends on the
1:                 // version of Derby used to create the database. Some older
1:                 // versions of Derby contained a bug and lacked optimizations,
1:                 // causing the number of statistics entries to increase.
commit:6be56bc
/////////////////////////////////////////////////////////////////////////
1:         // The expected initial number of statistics entries in TEST_TAB_2.
1:         final int expected =
1:                 DisposableIndexStatistics.hasDerby5681Bug(getOldVersion()) ?
1:                     2 : 1;
/////////////////////////////////////////////////////////////////////////
1:             stats.assertTableStats("TEST_TAB_2", expected);
/////////////////////////////////////////////////////////////////////////
1:             stats.assertTableStats("TEST_TAB_2", expected);
/////////////////////////////////////////////////////////////////////////
1:         DisposableIndexStatistics dis = new DisposableIndexStatistics(
1:                 getOldVersion(), getConnection(), TBL);
/////////////////////////////////////////////////////////////////////////
0:                 dis.assertStatsCount(false);
/////////////////////////////////////////////////////////////////////////
0:                 dis.assertStatsCount(false);
0:                 dis.assertStatsCount(false);
0:                 dis.assertStatsCount(false);
/////////////////////////////////////////////////////////////////////////
0:                     dis.assertStatsCount(true);
commit:bce78c9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.functionTests.tests.upgradeTests.helpers.DisposableIndexStatistics;
/////////////////////////////////////////////////////////////////////////
1:             stats.assertNoStatsTable("TEST_TAB_2");
/////////////////////////////////////////////////////////////////////////
0: 
1:     /**
1:      * Verifies the behavior of the update statistics code when faced with
1:      * "disposable statistics entries".
1:      * <p>
1:      * A disposable statistics entry is a row in SYS.SYSSTATISTICS that has
1:      * been orphaned (see DERBY-5681) or it is on longer needed by the
1:      * Derby optimizer (due to internal changes/improvements).
1:      * <p>
1:      * This test expects different things based on the phase:
1:      * <dl> <dt>create</dt>
1:      *      <dd>- run statements that will cause disposable statistics
1:      *          entries to be created</dd>
1:      *      <dt>soft upgrade</dt>
1:      *      <dd>- run the new update statistics code, expecting it to leave the
1:      *          disposable statistics intact</dd>
1:      *      <dt>downgrade</dt>
1:      *      <dd>- verify that the relevant statistics are present</dd>
1:      *      <dt>hard upgrade</dt>
1:      *      <dd>- run the new update statistics code, expecting it to get rid
1:      *          of the disposable statistics</dd>
1:      * </dl>
1:      */
1:     public void testDisposableStatisticsExplicit()
1:             throws SQLException {
1:         // Don't run this test with versions prior to 10.5, since the
1:         // required SYSCS_UPDATE_STATISTICS don't exist in older versions.
1:         if (!oldAtLeast(10, 5)) {
1:             return;
0:         }
0: 
1:         final String TBL = "ISTAT_DISPOSABLE_STATS";
1:         String updateStatsSQL = "call syscs_util.syscs_update_statistics(" +
1:                 "'APP', ?, null)";
0:         DisposableIndexStatistics dis =
0:                 new DisposableIndexStatistics(getConnection(), TBL);
0: 
1:         switch (getPhase()) {
1:             // create with old version
1:             case PH_CREATE:
0:             {
1:                 dis.createAndPopulateTables();
0:                 // We expect that the maximum number of statistics have been
0:                 // created here, since we're using an older version of Derby
0:                 // that contained a bug and lacked the latest optimizations.
0:                 dis.assertStatsCount(
0:                         DisposableIndexStatistics.getNumTotalPossibleStats());
1:                 break;
0:             }
1:             // boot with new version and soft-upgrade
1:             case PH_SOFT_UPGRADE:
0:             {
1:                 PreparedStatement ps = prepareStatement(updateStatsSQL);
1:                 String[] tables = dis.getTableNames();
1:                 // Update statistics on all relevant tables.
1:                 for (int i=0; i < tables.length; i++) {
1:                     ps.setString(1, tables[i]);
1:                     ps.executeUpdate();
0:                 }
0:                 dis.assertStatsCount(
0:                         DisposableIndexStatistics.getNumTotalPossibleStats());
1:                 break;
0:             }
1:             // soft-downgrade: boot with old version after soft-upgrade
1:             case PH_POST_SOFT_UPGRADE:
0:             {
0:                 dis.assertStatsCount(
0:                         DisposableIndexStatistics.getNumTotalPossibleStats());
1:                 break;
0:             }
1:             // boot with new version and hard-upgrade
1:             case PH_HARD_UPGRADE:
0:             {
0:                 dis.assertStatsCount(
0:                         DisposableIndexStatistics.getNumTotalPossibleStats());
1:                 PreparedStatement ps = prepareStatement(updateStatsSQL);
1:                 String[] tables = dis.getTableNames();
1:                 for (int i=0; i < tables.length; i++) {
1:                     ps.setString(1, tables[i]);
1:                     ps.executeUpdate();
0:                 }
1:                 // Confirm that we disposed of the statistics that were added
1:                 // due to a bug or simply not needed by Derby.
1:                 try {
0:                     dis.assertStatsCount(
0:                         DisposableIndexStatistics.getNumTotalPossibleStats() -
0:                         DisposableIndexStatistics.getNumDisposableStats());
1:                 } finally {
1:                     for (int i=0; i < tables.length; i++) {
1:                         dropTable(tables[i]);
0:                     }
0:                 }
1:                 commit();
1:                 break;
0:             }
0:         }
0:     }
0: 
commit:c1e0f8e
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.IndexStatsUtil;
/////////////////////////////////////////////////////////////////////////
0:     /**
1:      * Verifies that an orphaned statistics entry can be dropped by running the
1:      * {@code SYSCS_DROP_STATISTICS} system procedure.
1:      * <p>
1:      * Relevant JIRAs:
1:      * <ul> <li>DERBY-4115: Provide a way to drop statistics information</li>
1:      *      <li>DERBY-5681: When a foreign key constraint on a table is dropped,
1:      *          the associated statistics row for the conglomerate</li>
1:      * </ul>
1:      * <p>
1:      *  DERBY-5702(Creating a foreign key constraint does not automatically
1:      *   create a statistics row if foreign key constraint will share a
1:      *   backing index created for a primay key) is causing a problem for
1:      *   us to test the hanging statistics row with 10.4 and prior releases.
1:      *   Following test relies on having hanging statistics rows which should
1:      *   have been dropped when the constraint owing it was dropped. The test
1:      *   then goes ahead and uses the new drop statisitcs procedure to drop
1:      *   the hanging statistics rows. But because of DERBY-5702, when a
1:      *   constraint is added which will reuse an existing backing index,
1:      *   no statistics row is created for that constraint unless a user were
1:      *   to say use an update statistics stored procedure to create the
1:      *   statistics for that constraint. And later when that constraint is
1:      *   dropped, we will find that because of DERBY-5681, the statistics
1:      *   row never gets dropped. But update statistics stored procedure was
1:      *   not introduced up until 10.5 and because of that, we can't really
1:      *   test for hanging index created through constraints sharing the same
1:      *   backing index prior to 10.5
0:      */
1:     public void testDropOrphanedStatistics()
1:             throws SQLException {
1:         // Update statistics procedure SYSCS_UPDATE_STATISTICS is not available
1:         //  prior to 10.5 and hence we can't cause the hanging statistics to 
1:         //  appear in order to test the drop statistics after hard upgrade
1:         if (!oldAtLeast(10, 5)) return;
0: 
1:         // Helper object to obtain information about index statistics.
1:         IndexStatsUtil stats = new IndexStatsUtil(openDefaultConnection());
0:         Statement s = createStatement();
0:         
1:         switch (getPhase())
0:         {
1:         case PH_CREATE:
1:             s.executeUpdate("CREATE TABLE TEST_TAB_1 (c11 int not null,"+
1:                     "c12 int not null, c13 int)");
1:             s.executeUpdate("INSERT INTO TEST_TAB_1 VALUES(1,1,1),(2,2,2)");
1:             s.executeUpdate("ALTER TABLE TEST_TAB_1 "+
1:                     "ADD CONSTRAINT TEST_TAB_1_PK_1 "+
1:                     "PRIMARY KEY (c11)");
1:             //The statistics for primary key constraint has been added
1:             stats.assertTableStats("TEST_TAB_1",1);
0:             
1:             s.executeUpdate("CREATE TABLE TEST_TAB_2 (c21 int not null)");
1:             s.executeUpdate("INSERT INTO TEST_TAB_2 VALUES(1),(2)");
1:             s.executeUpdate("ALTER TABLE TEST_TAB_2 "+
1:                     "ADD CONSTRAINT TEST_TAB_2_PK_1 "+
1:                     "PRIMARY KEY (c21)");
1:             stats.assertTableStats("TEST_TAB_2",1);
1:             //DERBY-5702 Add a foreign key constraint and now we should find 2 rows
1:             // of statistics for TEST_TAB_2 - 1 for primary key and other for
1:             // foreign key constraint
1:             s.executeUpdate("ALTER TABLE TEST_TAB_2 "+
1:                     "ADD CONSTRAINT TEST_TAB_2_FK_1 "+
1:                     "FOREIGN KEY(c21) REFERENCES TEST_TAB_1(c11)");
1:             //DERBY-5702 Like primary key earlier, adding foreign key constraint
1:             // didn't automatically add a statistics row for it. Have to run update
1:             // statistics manually to get a row added for it's stat
1:             stats.assertTableStats("TEST_TAB_2",1);
1:             //Need to do a compress table to create the statistics for foreign
1:             // key constraint. Update statisitcs procedure is only available
1:             // in 10.5 and upwards and hence can't use that procedure here
1:             // since we are testing older releases too.
1:             s.execute("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS('APP','TEST_TAB_2', null)");
1:             //s.execute("CALL SYSCS_UTIL.SYSCS_COMPRESS_TABLE('APP','TEST_TAB_2',1)");
1:             stats.assertTableStats("TEST_TAB_2",2);
1:             s.executeUpdate("ALTER TABLE TEST_TAB_2 "+
1:                     "DROP CONSTRAINT TEST_TAB_2_FK_1");
1:             //Dropping the foreign key constraint does not remove it's 
1:             // statistics row because of DERBY-5681.
1:             stats.assertTableStats("TEST_TAB_2",2);
1:             assertStatementError("42Y03", s,
1:             "CALL SYSCS_UTIL.SYSCS_DROP_STATISTICS('APP','TEST_TAB_2', null)");
0:             break;
0: 
1:         case PH_SOFT_UPGRADE:
1:         case PH_POST_SOFT_UPGRADE:
1:             assertStatementError("42Y03", s,
1:                        "CALL SYSCS_UTIL.SYSCS_DROP_STATISTICS('APP','TEST_TAB_2', null)");
0:             break;
0: 
1:         case PH_HARD_UPGRADE:
1:             stats.assertTableStats("TEST_TAB_2",2);
1:             s.execute("CALL SYSCS_UTIL.SYSCS_DROP_STATISTICS('APP','TEST_TAB_2', null)");
1:             stats.assertNoStatsTable("TEST_TAB_2");
1:             s.execute("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS('APP','TEST_TAB_2', null)");
0:             stats.assertTableStats("TEST_TAB_2", 1); // TODO: Adjust for DERBY-3790
0:             break;
0: 
1:         case PH_POST_HARD_UPGRADE:
1:             //Make sure that the new procedure is still available
1:             s.execute("CALL SYSCS_UTIL.SYSCS_DROP_STATISTICS('APP','TEST_TAB_2', null)");
1:             s.executeUpdate("DROP TABLE TEST_TAB_1");
1:             s.executeUpdate("DROP TABLE TEST_TAB_2");
0:             break;
0:         }
0:     }
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:a6a0733
/////////////////////////////////////////////////////////////////////////
1:      * Make sure that the drop statistics procedure only appears after 
1:      * hard-upgrade.
0:      */
1:     public  void    testDropStatisticsProc()  throws Exception
0:     {
0:         Statement s = createStatement();
0: 
0:         switch ( getPhase() )
0:         {
0:         case PH_CREATE: // create with old version
1:             s.execute("CREATE TABLE dropStatsT1 (c11 int, c12 int) ");
1:             vetProcs(s, "call syscs_util.syscs_drop_statistics( 'APP', 'DROPSTATST1', null )", false);
0:             break;
0:             
0:         case PH_SOFT_UPGRADE: // boot with new version and soft-upgrade
1:             vetProcs(s, "call syscs_util.syscs_drop_statistics( 'APP', 'DROPSTATST1', null )", false);
0:             break;
0:             
0:         case PH_POST_SOFT_UPGRADE: // soft-downgrade: boot with old version after soft-upgrade
1:             vetProcs(s, "call syscs_util.syscs_drop_statistics( 'APP', 'DROPSTATST1', null )", false);
0:             break;
0: 
0:         case PH_HARD_UPGRADE: // boot with new version and hard-upgrade
1:             vetProcs(s, "call syscs_util.syscs_drop_statistics( 'APP', 'DROPSTATST1', null )", true);
1:             s.execute("DROP TABLE dropStatsT1");
0:             break;
0:         }
0:         
0:         s.close();
0:     	
0:     }
0:     /**
/////////////////////////////////////////////////////////////////////////
1:     private void    vetProcs( Statement s, String procCall, boolean shouldExist ) throws Exception
1:             s.execute( procCall );
/////////////////////////////////////////////////////////////////////////
0:     }
0:     private void    vetSYSUSERS( Statement s, boolean shouldExist ) throws Exception
0:     {
0:         ResultSet   rs = s.executeQuery( "select count(*) from sys.systables where tablename = 'SYSUSERS'" );
0:         rs.next();
0:         int expectedValue = shouldExist ? 1 : 0;
0: 
0:         assertEquals( expectedValue, rs.getInt( 1 ) );
0: 
0:         rs.close();
0:     }
0:     private void    vetNativeProcs( Statement s, boolean shouldExist ) throws Exception
0:     {
0:         // make sure that an authentication algorithm has been set
0:         String  defaultDigestAlgorithm = pushAuthenticationAlgorithm( s );
1:         vetProcs(s, "call syscs_util.syscs_create_user( 'FRED', 'fredpassword' )", shouldExist);
============================================================================