2:eac0369: /*
1:2700e3d: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.execute.TableScanResultSet
1:345de35: 
1:f6123ee:    Licensed to the Apache Software Foundation (ASF) under one or more
1:f6123ee:    contributor license agreements.  See the NOTICE file distributed with
1:f6123ee:    this work for additional information regarding copyright ownership.
1:f6123ee:    The ASF licenses this file to you under the Apache License, Version 2.0
1:f6123ee:    (the "License"); you may not use this file except in compliance with
1:f6123ee:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:345de35: 
10:eac0369:  */
38:eac0369: 
1:eac0369: package org.apache.derby.impl.sql.execute;
1:eac0369: 
1:b31849d: import java.util.Properties;
1:eac0369: 
1:b31849d: import org.apache.derby.iapi.error.StandardException;
1:b31849d: import org.apache.derby.iapi.reference.SQLState;
1:b31849d: import org.apache.derby.iapi.services.i18n.MessageService;
1:b31849d: import org.apache.derby.iapi.services.loader.GeneratedMethod;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: import org.apache.derby.iapi.sql.Activation;
1:b31849d: import org.apache.derby.iapi.sql.execute.CursorResultSet;
1:eac0369: import org.apache.derby.iapi.sql.execute.ExecIndexRow;
1:b31849d: import org.apache.derby.iapi.sql.execute.ExecRow;
1:eac0369: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
1:91f376c: import org.apache.derby.iapi.store.access.BackingStoreHashtable;
1:eac0369: import org.apache.derby.iapi.store.access.ConglomerateController;
1:eac0369: import org.apache.derby.iapi.store.access.DynamicCompiledOpenConglomInfo;
1:eac0369: import org.apache.derby.iapi.store.access.Qualifier;
1:eac0369: import org.apache.derby.iapi.store.access.ScanController;
1:eac0369: import org.apache.derby.iapi.store.access.StaticCompiledOpenConglomInfo;
1:eac0369: import org.apache.derby.iapi.store.access.TransactionController;
1:eac0369: import org.apache.derby.iapi.types.DataValueDescriptor;
1:eac0369: import org.apache.derby.iapi.types.RowLocation;
1:eac0369: 
4:eac0369: /**
1:eac0369:  * Takes a table and a table filter and returns
1:eac0369:  * the table's rows satisfying the filter as a result set.
3:eac0369:  *
1:eac0369:  * There are several things we could do during object
1:dbed020:  * construction that are done in the open and next calls, to
1:eac0369:  * improve performance.
1:eac0369:  *
1:eac0369:  */
1:97105d6: class TableScanResultSet extends ScanResultSet
1:eac0369: 	implements CursorResultSet, Cloneable
30:eac0369: {
1:eac0369:     protected ScanController scanController;
1:eac0369: 	protected boolean		scanControllerOpened;
1:eac0369: 	protected boolean		isKeyed;
1:eac0369: 	protected boolean		firstScan = true;
1:eac0369: 	protected ExecIndexRow	startPosition;
1:eac0369: 	protected ExecIndexRow	stopPosition;
1:eac0369: 
1:eac0369:     // set in constructor and not altered during
1:eac0369:     // life of object.
1:eac0369: 	protected long conglomId;
1:eac0369:     protected DynamicCompiledOpenConglomInfo dcoci;
1:eac0369:     protected StaticCompiledOpenConglomInfo scoci;
1:eac0369: 	protected GeneratedMethod startKeyGetter;
1:eac0369: 	protected int startSearchOperator;
1:eac0369: 	protected GeneratedMethod stopKeyGetter;
1:eac0369: 	protected int stopSearchOperator;
1:eac0369: 	public    Qualifier[][] qualifiers;
1:c7248d5: 	public String userSuppliedOptimizerOverrides;
1:eac0369: 	protected boolean runTimeStatisticsOn;
1:eac0369:     protected int[] indexCols;		//index keys base column position array
1:eac0369: 	public int rowsPerRead;
1:eac0369: 	public boolean forUpdate;
1:5ce8731: 	final boolean sameStartStopPosition;
1:af1c18c:     protected boolean nextDone;
1:eac0369: 	private RowLocation rlTemplate;
1:eac0369: 
1:eac0369: 	// Run time statistics
1:eac0369: 	private Properties scanProperties;
1:eac0369: 	public String startPositionString;
1:eac0369: 	public String stopPositionString;
1:eac0369: 	public boolean isConstraint;
1:eac0369: 	public boolean coarserLock;
1:eac0369: 	public boolean oneRowScan;
1:eac0369: 
1:eac0369: 	protected long	rowsThisScan;
1:eac0369: 
1:eac0369: 	private long estimatedRowCount;
1:eac0369: 
1:91f376c:     /**
1:91f376c:      * This field is used by beetle 3865, updateable cursor using index. It
1:91f376c:      * is a hash table containing updated rows that are thrown into future
1:91f376c:      * direction of the index scan, and as a result we'll hit it again but
1:91f376c:      * should skip it. The hash table will spill to disk if it grows too big
1:91f376c:      * to be kept in memory.
1:91f376c:      */
1:91f376c:     protected BackingStoreHashtable past2FutureTbl;
1:eac0369: 
1:2700e3d: 	// For Scrollable insensitive updatable result sets, only qualify a row the 
1:2700e3d: 	// first time it's been read, since an update can change a row so that it 
1:2700e3d: 	// no longer qualifies
1:af1c18c:     protected boolean qualify;
1:2700e3d: 
1:2700e3d: 	// currentRowIsValid is set to the result of positioning at a rowLocation.
1:2700e3d: 	// It will be true if the positioning was successful and false if the row 
1:2700e3d: 	// was deleted under our feet. Whenenver currentRowIsValid is false it means 
1:2700e3d: 	// that the row has been deleted.
1:af1c18c:     protected boolean currentRowIsValid;
1:2700e3d: 	
1:2700e3d: 	// Indicates whether the scan has been positioned back to a previously read
1:2700e3d: 	// row, or it is accessing a row for the first time.
1:af1c18c:     protected boolean scanRepositioned;
1:2700e3d: 
1:eac0369:     //
1:eac0369:     // class interface
1:eac0369:     //
1:f77f36d:     TableScanResultSet(long conglomId,
1:eac0369: 		StaticCompiledOpenConglomInfo scoci, 
1:eac0369: 		Activation activation, 
1:959fef2: 		int resultRowTemplate,
1:eac0369: 		int resultSetNumber,
1:eac0369: 		GeneratedMethod startKeyGetter, int startSearchOperator,
1:eac0369: 		GeneratedMethod stopKeyGetter, int stopSearchOperator,
1:eac0369: 		boolean sameStartStopPosition,
1:eac0369: 		Qualifier[][] qualifiers,
1:eac0369: 		String tableName,
1:c7248d5: 		String userSuppliedOptimizerOverrides,
1:eac0369: 		String indexName,
1:eac0369: 		boolean isConstraint,
1:eac0369: 		boolean forUpdate,
1:eac0369: 		int colRefItem,
1:eac0369: 		int indexColItem,
1:eac0369: 		int lockMode,
1:eac0369: 		boolean tableLocked,
1:eac0369: 		int isolationLevel,
1:eac0369: 		int rowsPerRead,
1:eac0369: 		boolean oneRowScan,
1:eac0369: 		double optimizerEstimatedRowCount,
1:f77f36d: 		double optimizerEstimatedCost)
2:eac0369: 			throws StandardException
1:eac0369:     {
1:eac0369: 		super(activation,
1:eac0369: 				resultSetNumber,
1:959fef2: 				resultRowTemplate,
1:97105d6: 				lockMode, tableLocked, isolationLevel,
1:2ec36d1:                 colRefItem,
1:eac0369: 				optimizerEstimatedRowCount,
1:eac0369: 				optimizerEstimatedCost);
1:eac0369: 
1:eac0369: 		this.conglomId = conglomId;
1:eac0369: 
1:eac0369: 		/* Static info created at compile time and can be shared across
1:eac0369: 		 * instances of the plan.
1:eac0369: 		 * Dynamic info created on 1st opening of this ResultSet as
1:eac0369: 		 * it cannot be shared.
1:eac0369: 		 */
1:eac0369:         this.scoci = scoci;
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG) {
1:eac0369: 			SanityManager.ASSERT( activation!=null, "table scan must get activation context");
3:eac0369: 			if (sameStartStopPosition)
1:eac0369: 			{
1:eac0369: 				SanityManager.ASSERT(stopKeyGetter == null,
1:eac0369: 					"stopKeyGetter expected to be null when sameStartStopPosition is true");
29:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		this.startKeyGetter = startKeyGetter;
1:eac0369: 		this.startSearchOperator = startSearchOperator;
1:eac0369: 		this.stopKeyGetter = stopKeyGetter;
1:eac0369: 		this.stopSearchOperator = stopSearchOperator;
1:eac0369: 		this.sameStartStopPosition = sameStartStopPosition;
1:eac0369: 		this.qualifiers = qualifiers;
1:eac0369: 		this.tableName = tableName;
1:c7248d5: 		this.userSuppliedOptimizerOverrides = userSuppliedOptimizerOverrides;
1:eac0369: 		this.indexName = indexName;
1:eac0369: 		this.isConstraint = isConstraint;
1:eac0369: 		this.forUpdate = forUpdate;
1:eac0369: 		this.rowsPerRead = rowsPerRead;
1:eac0369: 		this.oneRowScan = oneRowScan;
1:eac0369: 
1:eac0369: 		if (indexColItem != -1)
1:eac0369: 		{
1:eac0369: 			this.indexCols = (int[])(activation.getPreparedStatement().
1:eac0369: 						getSavedObject(indexColItem));
1:eac0369: 		}
1:eac0369: 		if (indexCols != null)
1:eac0369: 			activation.setForUpdateIndexScan(this);
1:eac0369: 
1:eac0369: 		runTimeStatisticsOn = (activation != null &&
1:eac0369: 							   activation.getLanguageConnectionContext().getRunTimeStatisticsMode());
1:eac0369: 		
1:2700e3d: 		/* Always qualify the first time a row is being read */
1:2700e3d: 		qualify = true;
1:2700e3d: 		currentRowIsValid = false;
1:2700e3d: 		scanRepositioned = false;
1:7008b63: 		
1:7008b63: 		recordConstructorTime();
1:eac0369:     }
1:eac0369: 
1:eac0369: 	//
1:eac0369: 	// ResultSet interface (leftover from NoPutResultSet)
1:eac0369: 	//
1:eac0369: 
1:eac0369: 	/**
1:eac0369:      * open a scan on the table. scan parameters are evaluated
1:eac0369:      * at each open, so there is probably some way of altering
1:eac0369:      * their values...
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException thrown on failure to open
1:eac0369:      */
1:eac0369: 	public void	openCore() throws StandardException
1:eac0369: 	{
3:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		    SanityManager.ASSERT( ! isOpen, "TableScanResultSet already open");
1:eac0369: 
1:eac0369:         // Get the current transaction controller
1:eac0369:         TransactionController tc = activation.getTransactionController();
1:eac0369: 
1:97105d6: 		initIsolationLevel();
1:97105d6: 
1:eac0369: 		if (dcoci == null)
1:eac0369: 			dcoci = tc.getDynamicCompiledConglomInfo(conglomId);
1:eac0369: 
1:5ce8731:         initStartAndStopKey();
1:eac0369: 
1:eac0369: 		/* NOTE: We always open the ScanController on the 1st open
1:eac0369: 		 * to do the keyed conglomerate check.
1:eac0369: 		 */
1:eac0369: 
1:eac0369: 		// Determine whether the conglomerate is keyed.  This determines
1:eac0369: 		// how we find the RowLocation for the base heap.  For non-keyed
1:eac0369: 		// conglomerates, we ask the scan.  For keyed conglomerates, it
1:eac0369: 		// is the last column in the row.
1:eac0369: 		//
1:eac0369: 		// Do this here, rather than in the constructor, so we can avoid
1:eac0369: 		// throwing exceptions from the constructor
1:eac0369: 		if (firstScan)
1:eac0369: 		{
1:eac0369: 			openScanController(tc);
1:eac0369: 
1:eac0369: 			isKeyed = scanController.isKeyed();
1:eac0369: 
1:eac0369: 			/*
1:eac0369: 			** If scan tracing is turned on, print information about this
1:eac0369: 			** TableScanResultSet when it is first opened.  We would like
1:eac0369: 			** to do this when it is constructed, but it is not always
1:eac0369: 			** possible to get the start and stop positioners at the time
1:eac0369: 			** this object is constructed (because they may depend on outer
1:eac0369: 			** rows).
1:eac0369: 			*/
1:eac0369: 			if (SanityManager.DEBUG)
1:eac0369: 			{
1:eac0369: 				if (SanityManager.DEBUG_ON("ScanTrace"))
1:eac0369: 				{
1:eac0369: 					//traceScanParameters();
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// Check whether there are any comparisons with unordered nulls
1:eac0369: 		// on either the start or stop position.  If there are, we can
1:eac0369: 		// (and must) skip the scan, because no rows can qualify
1:eac0369: 		if (skipScan(startPosition, stopPosition))
1:eac0369: 		{
1:eac0369: 			scanControllerOpened = false;
1:eac0369: 		}
1:eac0369: 		/* NOTE: We always open the ScanController on the 1st open
1:eac0369: 		 * to do the keyed conglomerate check, so we only need to
1:eac0369: 		 * do it here if not the 1st scan.
1:eac0369: 		 */
1:eac0369: 		else if (! firstScan)
1:eac0369: 		{
1:eac0369: 			openScanController(tc);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* If the scan is on an index and opened for update,
1:eac0369: 		 * then we cache the scan controller and conglomerate
1:eac0369: 		 * number in the activation so that the scan controller
1:eac0369: 		 * can be re-used by the update/delete if the index
1:eac0369: 		 * that we are scanning also needs to be updated.
1:eac0369: 		 */
1:eac0369: 		if (forUpdate && isKeyed)
1:eac0369: 		{
1:eac0369: 			activation.setIndexScanController(scanController);
1:eac0369: 			activation.setIndexConglomerateNumber(conglomId);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		firstScan = false;
1:eac0369: 	    isOpen = true;
1:eac0369: 		numOpens++;
1:eac0369: 		nextDone = false;
1:eac0369: 		openTime += getElapsedMillis(beginTime);
1:eac0369: 	}
1:a42c32e: 
1:5ce8731:     /**
1:5ce8731:      * Initialize the {@code startPosition} and {@code stopPosition} fields
1:5ce8731:      * which are used to limit the rows returned by the scan.
1:5ce8731:      */
1:5ce8731:     void initStartAndStopKey() throws StandardException {
1:5ce8731:         if (startKeyGetter != null) {
1:5ce8731:             startPosition = (ExecIndexRow) startKeyGetter.invoke(activation);
1:5ce8731:             if (sameStartStopPosition) {
1:5ce8731:                 stopPosition = startPosition;
1:5ce8731:             }
1:5ce8731:         }
1:5ce8731:         if (stopKeyGetter != null) {
1:5ce8731:             stopPosition = (ExecIndexRow) stopKeyGetter.invoke(activation);
1:5ce8731:         }
1:5ce8731:     }
1:5ce8731: 
1:eac0369: 	/*
1:eac0369: 	** Open the scan controller
1:eac0369: 	**
1:eac0369: 	** @param transaction controller will open one if null
1:eac0369: 	*/
1:eac0369: 	protected void openScanController(TransactionController tc)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		DataValueDescriptor[] startPositionRow = 
1:eac0369:             startPosition == null ? null : startPosition.getRowArray();
1:eac0369: 		DataValueDescriptor[] stopPositionRow = 
1:eac0369:             stopPosition == null ? null : stopPosition.getRowArray();
1:eac0369: 
1:eac0369: 		// Clear the Qualifiers's Orderable cache 
1:eac0369: 		if (qualifiers != null)
1:eac0369: 		{
1:eac0369: 			clearOrderableCache(qualifiers);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// Get the current transaction controller
1:eac0369: 		if (tc == null)
1:eac0369: 			tc = activation.getTransactionController();
1:eac0369: 
1:eac0369:         int openMode = 0;
1:eac0369:         if (forUpdate)
1:eac0369:         {
1:eac0369:             openMode = TransactionController.OPENMODE_FORUPDATE;
1:eac0369: 
1:eac0369:             if (activation.isCursorActivation())
1:eac0369:                 openMode |= TransactionController.OPENMODE_USE_UPDATE_LOCKS;
1:eac0369:         }
1:eac0369: 
1:eac0369: 		scanController = tc.openCompiledScan(
1:eac0369: 				activation.getResultSetHoldability(),
1:eac0369: 				openMode,
1:eac0369: 				lockMode,
1:eac0369: 				isolationLevel,
1:eac0369: 				accessedCols,
1:eac0369: 				startPositionRow,
1:eac0369: 					// not used when giving null start position
1:eac0369: 				startSearchOperator,
1:eac0369: 				qualifiers,
1:eac0369: 				stopPositionRow,
1:eac0369: 					// not used when giving null stop position
1:eac0369: 				stopSearchOperator,
1:eac0369: 				scoci,
1:eac0369: 				dcoci);
1:eac0369: 
1:eac0369: 		/* Remember that we opened the scan */
1:eac0369: 		scanControllerOpened = true;
1:eac0369: 
2:eac0369: 		rowsThisScan = 0;
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** Inform the activation of the estimated number of rows.  Only
1:eac0369: 		** do it here, not in reopen, so that we don't do this costly
1:eac0369: 		** check too often.
1:eac0369: 		*/
1:eac0369: 		estimatedRowCount = scanController.getEstimatedRowCount();
1:eac0369: 		activation.informOfRowCount(
1:eac0369: 									this,
1:eac0369: 									scanController.getEstimatedRowCount()
1:eac0369: 									);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** reopen the scan controller
1:eac0369: 	*/
1:028077e: 	protected void reopenScanController() throws StandardException
1:eac0369: 	{
1:eac0369: 		DataValueDescriptor[] startPositionRow = 
1:eac0369:             startPosition == null ? null : startPosition.getRowArray();
1:eac0369: 		DataValueDescriptor[] stopPositionRow = 
1:eac0369:             stopPosition == null ? null : stopPosition.getRowArray();
1:eac0369: 
1:5ce8731:         rowsThisScan = 0;
1:eac0369: 
1:eac0369: 		// Clear the Qualifiers's Orderable cache 
1:eac0369: 		if (qualifiers != null)
1:eac0369: 		{
1:eac0369: 			clearOrderableCache(qualifiers);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		scanController.reopenScan(
1:eac0369: 						startPositionRow,
1:eac0369: 						startSearchOperator,
1:eac0369: 						qualifiers,
1:eac0369: 						stopPositionRow,
1:eac0369: 						stopSearchOperator);
1:eac0369: 
1:eac0369: 		/* Remember that we opened the scan */
1:eac0369: 		scanControllerOpened = true;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369:      * Reopen a table scan.  Here we take advantage
1:eac0369: 	 * of the reopenScan() interface on scanController
1:eac0369: 	 * for optimimal performance on joins where we are
1:eac0369: 	 * an inner table.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException thrown on failure to open
1:eac0369:      */
1:eac0369: 	public void	reopenCore() throws StandardException
1:eac0369: 	{
1:eac0369: 		beginTime = getCurrentTimeMillis();
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		    SanityManager.ASSERT(isOpen, "TableScanResultSet not open, cannot reopen");
1:eac0369: 
1:5ce8731:         initStartAndStopKey();
1:eac0369: 
1:eac0369: 		// Check whether there are any comparisons with unordered nulls
1:eac0369: 		// on either the start or stop position.  If there are, we can
1:eac0369: 		// (and must) skip the scan, because no rows can qualify
1:eac0369: 		if (skipScan(startPosition, stopPosition))
1:eac0369: 		{
1:eac0369: 			scanControllerOpened = false;
1:eac0369: 		}
3:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			if (scanController == null)
1:eac0369: 				openScanController((TransactionController)null);
1:eac0369: 			else
1:eac0369: 				reopenScanController();
1:eac0369: 		
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		numOpens++;
1:eac0369: 		nextDone = false;
1:eac0369: 		openTime += getElapsedMillis(beginTime);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:a42c32e:     boolean loopControl(boolean moreRows) throws StandardException {
1:a42c32e:         return scanController.fetchNext(candidate.getRowArray());
1:a42c32e:     }
1:a42c32e: 
1:eac0369: 	/**
1:eac0369:      * Return the next row (if any) from the scan (if open).
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException thrown on failure to get next row
1:eac0369: 	 */
1:eac0369: 	public ExecRow getNextRowCore() throws StandardException
1:eac0369: 	{
1:2a4654b: 		if( isXplainOnlyMode() )
1:2a4654b: 			return null;
1:2a4654b: 
1:3fcea8a:         checkCancellationFlag();
1:3fcea8a:             
1:2700e3d: 		if (currentRow == null || scanRepositioned)
1:eac0369: 		{
2:eac0369: 			currentRow =
1:49f3f24: 				getCompactRow(candidate, accessedCols, isKeyed);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		beginTime = getCurrentTimeMillis();
1:eac0369: 
2:eac0369: 		ExecRow result = null;
1:eac0369: 
1:eac0369: 	    if ( isOpen  && !nextDone)
1:eac0369: 	    {
1:eac0369: 			/* Only need to do 1 next per scan
1:eac0369: 			 * for 1 row scans.
1:eac0369: 			 */
1:eac0369: 			nextDone = oneRowScan;
1:eac0369: 
1:eac0369: 			if (scanControllerOpened)
1:eac0369: 			{
1:a42c32e:                 boolean moreRows = true;
1:eac0369: 
1:a42c32e:                 while (true)
1:eac0369: 				{
1:a42c32e:                     // loop control overriden by subclass
1:a42c32e:                     // ValidateCheckConstraintResultSet..
1:a42c32e:                     if (! (moreRows = loopControl(moreRows))) {
1:a42c32e:                         break;
1:a42c32e:                     }
1:eac0369: 					rowsSeen++;
1:eac0369: 					rowsThisScan++;
1:eac0369: 
1:eac0369: 					/*
1:eac0369: 					** Skip rows where there are start or stop positioners
1:eac0369: 					** that do not implement ordered null semantics and
1:eac0369: 					** there are columns in those positions that contain
1:eac0369: 					** null.
1:eac0369: 					** No need to check if start and stop positions are the
1:eac0369: 					** same, since all predicates in both will be ='s,
1:eac0369: 					** and hence evaluated in the store.
1:eac0369: 					*/
1:eac0369: 					if ((! sameStartStopPosition) && skipRow(candidate))
1:eac0369: 					{
1:eac0369: 						rowsFiltered++;
2:eac0369: 						continue;
1:eac0369: 					}
1:eac0369: 
1:eac0369: 					/* beetle 3865, updateable cursor use index. If we have a hash table that
1:eac0369: 					 * holds updated records, and we hit it again, skip it, and remove it from
1:eac0369: 					 * hash since we can't hit it again, and we have a space in hash, so can
1:eac0369: 					 * stop scanning forward.
1:eac0369: 					 */
1:eac0369: 					if (past2FutureTbl != null)
1:eac0369: 					{
1:eac0369: 						RowLocation rowLoc = (RowLocation) currentRow.getColumn(currentRow.nColumns());
1:4639287: 						if (past2FutureTbl.remove(rowLoc) != null){
1:4639287: 						    continue;
1:eac0369: 						}
1:eac0369: 					}
1:eac0369: 
2:eac0369: 					result = currentRow;
1:eac0369: 
1:eac0369: 					break;
1:eac0369: 				}
1:eac0369: 
1:eac0369: 				/*
1:eac0369: 				** If we just finished a full scan of the heap, update
1:eac0369: 				** the number of rows in the scan controller.
1:eac0369: 				**
1:eac0369: 				** NOTE: It would be more efficient to only update the
1:eac0369: 				** scan controller if the optimizer's estimated number of
1:eac0369: 				** rows were wrong by more than some threshold (like 10%).
1:eac0369: 				** This would require a little more work than I have the
1:eac0369: 				** time for now, however, as the row estimate that is given
1:eac0369: 				** to this result set is the total number of rows for all
1:eac0369: 				** scans, not the number of rows per scan.
1:eac0369: 				*/
1:eac0369: 				if (! moreRows)
1:eac0369: 				{
1:eac0369: 					setRowCountIfPossible(rowsThisScan);
3:eac0369: 					currentRow = null;
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 	    }
1:eac0369: 
3:eac0369: 		setCurrentRow(result);
1:2700e3d: 		currentRowIsValid = true;
1:2700e3d: 		scanRepositioned = false;
1:2700e3d: 		qualify = true;
1:eac0369: 
2:eac0369: 		nextTime += getElapsedMillis(beginTime);
2:eac0369: 	    return result;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * If the result set has been opened,
1:eac0369: 	 * close the open scan.
1:eac0369: 	 * @exception StandardException on error
1:eac0369: 	 */
1:eac0369: 	public void	close() throws StandardException
1:eac0369: 	{
1:eac0369: 		beginTime = getCurrentTimeMillis();
1:eac0369: 		if ( isOpen )
1:eac0369: 	    {
1:eac0369: 			/*
1:eac0369: 			** If scan tracing is turned on, print information about this
1:eac0369: 			** TableScanResultSet when it is closed.
1:eac0369: 			*/
1:eac0369: 			if (SanityManager.DEBUG)
1:eac0369: 			{
1:eac0369: 				if (SanityManager.DEBUG_ON("ScanTrace"))
1:eac0369: 				{
1:eac0369: 					//traceClose();
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			// we don't want to keep around a pointer to the
1:eac0369: 			// row ... so it can be thrown away.
1:eac0369: 			// REVISIT: does this need to be in a finally
1:eac0369: 			// block, to ensure that it is executed?
1:eac0369: 		    clearCurrentRow();
1:f77f36d: ;
1:eac0369: 			if (scanController != null)
1:eac0369: 			{
1:eac0369: 				// This is where we get the positioner info for inner tables
1:eac0369: 				if (runTimeStatisticsOn)
1:eac0369: 				{
1:eac0369: 					// This is where we get the scan properties for a subquery
1:eac0369: 					scanProperties = getScanProperties();
1:eac0369: 					startPositionString = printStartPosition();
1:eac0369: 					stopPositionString = printStopPosition();
1:eac0369: 				}
1:eac0369: 	        	scanController.close();
1:eac0369: 				scanController = null; // should not access after close
1:bd2badd: 
1:bd2badd:                 // Updatable index scans are cached in the activation for
1:bd2badd:                 // easy access from IndexChanger. Remember to clear the cached
1:bd2badd:                 // info here, but only if this is the result set that cached
1:bd2badd:                 // it in the first place (DERBY-4585).
1:bd2badd:                 if (forUpdate && isKeyed) {
1:bd2badd:                     activation.clearIndexScanInfo();
1:bd2badd:                 }
1:bd2badd: 
1:eac0369: 			}
1:eac0369: 			scanControllerOpened = false;
1:eac0369: 			startPosition = null;
1:eac0369: 			stopPosition = null;
1:eac0369: 
1:eac0369: 			super.close();
1:eac0369: 
1:eac0369: 			if (indexCols != null)
1:eac0369: 			{
1:eac0369: 				ConglomerateController borrowedBaseCC = activation.getHeapConglomerateController();
1:eac0369: 				if (borrowedBaseCC != null)
1:eac0369: 				{
1:eac0369: 					borrowedBaseCC.close();
1:eac0369: 					activation.clearHeapConglomerateController();
1:eac0369: 				}
1:eac0369: 			}
1:91f376c: 
1:91f376c:             if (past2FutureTbl != null)
1:91f376c:             {
1:91f376c:                 past2FutureTbl.close();
1:91f376c:             }
1:eac0369: 	    }
1:eac0369: 		else
1:eac0369: 			if (SanityManager.DEBUG)
1:eac0369: 				SanityManager.DEBUG("CloseRepeatInfo","Close of TableScanResultSet repeated");
1:eac0369: 
1:eac0369: 		closeTime += getElapsedMillis(beginTime);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return the total amount of time spent in this ResultSet
1:eac0369: 	 *
1:eac0369: 	 * @param type	CURRENT_RESULTSET_ONLY - time spent only in this ResultSet
1:eac0369: 	 *				ENTIRE_RESULTSET_TREE  - time spent in this ResultSet and below.
1:eac0369: 	 *
1:eac0369: 	 * @return long		The total amount of time spent (in milliseconds).
1:eac0369: 	 */
1:eac0369: 	public long getTimeSpent(int type)
1:eac0369: 	{
1:eac0369: 		long totTime = constructorTime + openTime + nextTime + closeTime;
1:eac0369: 
1:eac0369: 		/* RESOLVE - subtract out store time later, when available */
1:eac0369: 		if (type == NoPutResultSet.CURRENT_RESULTSET_ONLY)
1:eac0369: 		{
1:eac0369: 			return	totTime;
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return totTime;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	//
1:eac0369: 	// CursorResultSet interface
1:eac0369: 	//
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * This result set has its row location from
1:2700e3d: 	 * the last fetch done. If the cursor is closed, 
1:2700e3d: 	 * or the row has been deleted a null is returned.
1:eac0369: 	 *
1:eac0369: 	 * @see CursorResultSet
1:eac0369: 	 *
1:eac0369: 	 * @return the row location of the current cursor row.
1:eac0369: 	 * @exception StandardException thrown on failure to get row location
1:eac0369: 	 */
1:eac0369: 	public RowLocation getRowLocation() throws StandardException
1:eac0369: 	{
1:eac0369: 		RowLocation rl;
1:eac0369: 
1:eac0369: 		if (! isOpen) return null;
1:eac0369: 
1:eac0369: 		if ( ! scanControllerOpened)
1:eac0369: 			return null;
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** If the conglomerate is keyed, the row location of the base row
1:eac0369: 		** is in the last column of the current row.  If it's not keyed,
1:eac0369: 		** we get the row location from the scan of the heap.
1:eac0369: 		*/
1:eac0369: 		if (isKeyed)
1:eac0369: 		{
1:eac0369: 			if (SanityManager.DEBUG)
1:eac0369: 			{
1:eac0369: 				SanityManager.ASSERT(currentRow != null,
1:eac0369: 				  "There must be a current row when fetching the row location");
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			rl = (RowLocation) currentRow.getColumn(
1:eac0369: 													currentRow.nColumns());
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:2700e3d: 			if (currentRowIsValid) {
1:2700e3d: 				// we reuse the same rowlocation object across several calls.
1:2700e3d: 				if (rlTemplate == null)
1:2700e3d: 					rlTemplate = scanController.newRowLocationTemplate();
1:2700e3d: 				rl = rlTemplate;
1:eac0369: 				try {
1:2700e3d: 					scanController.fetchLocation(rl);
1:eac0369: 				} catch (StandardException se) {
1:c247315: 					if (se.getMessageId().
1:c247315: 						equals(SQLState.HEAP_SCAN_NOT_POSITIONED)) {
1:f342d5b: 						//Have a easier to understand error message than what 
1:f342d5b: 						//we get from store 
1:f342d5b: 						throw StandardException.
1:f342d5b: 							newException(SQLState.NO_CURRENT_ROW);
1:eac0369: 					}
1:c247315:                     throw se;
1:eac0369: 				}
1:2700e3d: 			} else {
1:2700e3d: 				rl = null;
1:2700e3d: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return rl;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * This result set has its row from the last fetch done. 
1:2700e3d: 	 * If the cursor is closed, the row has been deleted, or
1:2700e3d: 	 * no longer qualifies (for forward only result sets) a 
1:2700e3d: 	 * null is returned.
1:eac0369: 	 *
1:eac0369: 	 * @see CursorResultSet
1:eac0369: 	 *
1:eac0369: 	 * @return the last row returned;
1:eac0369: 	 * @exception StandardException thrown on failure.
1:eac0369: 	 */
1:eac0369: 	/* RESOLVE - this should return activation.getCurrentRow(resultSetNumber),
1:eac0369: 	 * once there is such a method.  (currentRow is redundant)
1:eac0369: 	 */
1:eac0369: 	public ExecRow getCurrentRow() throws StandardException 
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT(isOpen, "TSRS expected to be open");
1:eac0369: 
1:eac0369: 		/* Nothing to do if we're not currently on a row or
1:eac0369: 		 * if the current row get deleted out from under us
1:eac0369: 		 * or if there is no current scan (can happen if the
1:eac0369: 		 * scan is being skipped) or if the current position
1:eac0369: 		 * no longer qualifies.
1:eac0369: 		 */
1:eac0369: 		try
1:eac0369: 		{
1:eac0369: 			if ((currentRow == null)                        ||
1:2700e3d: 			(!currentRowIsValid)                            ||
1:eac0369: 			(!scanControllerOpened)                         ||
1:2700e3d: 			(qualify && scanController.isCurrentPositionDeleted())     ||
1:2700e3d: 			(qualify && (!scanController.doesCurrentPositionQualify())))
1:eac0369: 			{
1:eac0369: 				return null;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		catch (StandardException se)
1:eac0369: 		{
1:eac0369: 			if (se.getMessageId().equals(SQLState.AM_SCAN_NOT_POSITIONED))
1:eac0369: 			{
1:eac0369: 				//bug 4515 - Have a easier to understand error message than what we get from store 
1:eac0369: 				se=StandardException.newException(SQLState.NO_CURRENT_ROW);
1:eac0369: 				throw se;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:959fef2:         resultRowBuilder.reset(candidate);
1:959fef2:         currentRow = getCompactRow(candidate, accessedCols, isKeyed);
1:eac0369: 
1:eac0369:         try
1:eac0369:         {
1:959fef2:             scanController.fetchWithoutQualify(candidate.getRowArray());
1:eac0369:         }
1:eac0369:         catch (StandardException se)
1:eac0369:         {
1:eac0369:             if (se.getMessageId().equals(SQLState.AM_RECORD_NOT_FOUND))
1:eac0369:             {
1:eac0369:                 // Somehow the row got deleted between the above 
1:eac0369:                 // doesCurrentPositionQualify() call and here (one way is if
1:eac0369:                 // this scan is read uncommitted isolation level).
1:eac0369:                 return null;
1:eac0369:             }
1:eac0369:             else
1:eac0369:             {
1:eac0369:                 throw se;
1:eac0369:             }
1:eac0369:         }
1:eac0369: 
1:959fef2:         setCurrentRow(candidate);
2:eac0369: 	    return currentRow;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:2700e3d: 	 * @see NoPutResultSet#positionScanAtRowLocation
1:2700e3d: 	 * 
1:2700e3d: 	 * Also sets qualify to false so that later calls to getCurrentRow
1:2700e3d: 	 * will not attempt to re-qualify the current row. 
1:2700e3d: 	 */
1:2700e3d: 	public void positionScanAtRowLocation(RowLocation rl) 
1:2700e3d: 		throws StandardException 
1:2700e3d: 	{
1:2700e3d: 		// Check if the scanController is a B-tree scan controller. Do not
1:2700e3d: 		// attempt to re-position a b-tree controller.
1:2700e3d: 		if (!isKeyed) {
1:2700e3d: 			currentRowIsValid = scanController.positionAtRowLocation(rl);
1:2700e3d: 		}
1:2700e3d: 		qualify = false;
1:2700e3d: 		scanRepositioned = true;
1:2700e3d: 	}
1:2700e3d: 
1:2700e3d: 	/**
1:eac0369: 	 * Print the parameters that constructed this result set to the
1:eac0369: 	 * trace stream.
1:eac0369: 	 */
1:eac0369: /*
1:eac0369: 	private final void traceScanParameters()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			HeaderPrintWriter traceStream = SanityManager.GET_DEBUG_STREAM();
1:eac0369: 
1:eac0369: 			traceStream.println("");
1:eac0369: 			traceStream.println("TableScanResultSet number " +
1:eac0369: 								resultSetNumber +
1:eac0369: 								" parameters:");
1:eac0369: 
1:eac0369: 			traceStream.println("");
1:eac0369: 			traceStream.println("\tTable name: " + tableName);
1:eac0369: 			if (indexName != null)
1:eac0369: 			{
1:eac0369: 				traceStream.println("\tIndex name: " + indexName);
1:eac0369: 			}
1:eac0369: 			traceStream.println("");
1:eac0369: 			traceStream.println("\tStart position is: ");
1:eac0369: 			tracePrintPosition(traceStream,
1:eac0369: 								startSearchOperator,
1:eac0369: 								startKeyGetter);
1:eac0369: 			traceStream.println("");
1:eac0369: 			traceStream.println("\tStop position is: " );
1:eac0369: 			tracePrintPosition(traceStream,
1:eac0369: 								stopSearchOperator,
1:eac0369: 								stopKeyGetter);
1:eac0369: 			traceStream.println("");
1:eac0369: 			traceStream.println("\tQualifiers are: ");
1:eac0369: 			tracePrintQualifiers(traceStream, qualifiers, 2);
1:eac0369: 			traceStream.println("");
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: */
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Print I/O statistics about a scan when it closes.
1:eac0369: 	 */
1:eac0369: /*
1:eac0369: 	private final void traceClose()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			InfoStreams			infoStreams;
1:eac0369: 			HeaderPrintWriter	traceStream;
1:eac0369: 
1:eac0369: 			traceStream = SanityManager.GET_DEBUG_STREAM();
1:eac0369: 
1:eac0369: 			traceStream.println("TableScanResultSet number " +
1:eac0369: 								resultSetNumber +
1:eac0369: 								" closed.");
1:eac0369: 			if (isKeyed)
1:eac0369: 			{
1:eac0369: 				traceStream.println("\t" +
1:eac0369: 									rowCount() +
1:eac0369: 									" row(s) qualified from " +
1:eac0369: 									"keyed" +
1:eac0369: 									" table " +
1:eac0369: 									tableName +
1:eac0369: 									" using index " +
1:eac0369: 									indexName);
1:eac0369: 			}
1:eac0369: 			else
1:eac0369: 			{
1:eac0369: 				traceStream.println("\t" +
1:eac0369: 									rowCount() +
1:eac0369: 									" row(s) qualified from " +
1:eac0369: 									"non-keyed" +
1:eac0369: 									" table " +
1:eac0369: 									tableName);
1:eac0369: 			}
1:eac0369: 			traceStream.println("");
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: */
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Print a start or stop positioner to the trace stream.
1:eac0369: 	 */
1:eac0369: /*
1:eac0369: 	private final void tracePrintPosition(HeaderPrintWriter traceStream,
1:eac0369: 										  int searchOperator,
1:eac0369: 										  GeneratedMethod positionGetter)
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			if (positionGetter == null)
1:eac0369: 			{
1:eac0369: 				traceStream.println("\t\tNone");
1:eac0369: 				return;
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			ExecIndexRow	positioner = null;
1:eac0369: 
1:eac0369: 			try
1:eac0369: 			{
1:eac0369: 				positioner = (ExecIndexRow) positionGetter.invoke(activation);
1:eac0369: 			}
1:eac0369: 			catch (StandardException e)
1:eac0369: 			{
1:eac0369: 				traceStream.println("\t\tUnexpected exception " +
1:eac0369: 									e +
1:eac0369: 									" getting positioner.");
1:eac0369: 				e.printStackTrace(traceStream.getPrintWriter());
1:eac0369: 				return;
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			if (positioner == null)
1:eac0369: 			{
1:eac0369: 				traceStream.println("\t\tNone");
1:eac0369: 				return;
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			String searchOp = null;
1:eac0369: 
1:eac0369: 			switch (searchOperator)
1:eac0369: 			{
1:eac0369: 			  case ScanController.GE:
1:eac0369: 				searchOp = "GE";
1:eac0369: 				break;
1:eac0369: 
1:eac0369: 			  case ScanController.GT:
1:eac0369: 				searchOp = "GT";
1:eac0369: 				break;
1:eac0369: 
1:eac0369: 			  default:
1:eac0369: 				searchOp = "unknown value (" + searchOperator + ")";
1:eac0369: 				break;
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			traceStream.println("\t\t" +
1:eac0369: 								searchOp +
1:eac0369: 								" on first " +
1:eac0369: 								positioner.nColumns() +
1:eac0369: 								" column(s).");
1:eac0369: 
1:eac0369: 			traceStream.print(
1:eac0369: 					"\t\tOrdered null semantics on the following columns: ");
1:eac0369: 			for (int position = 0; position < positioner.nColumns(); position++)
1:eac0369: 			{
1:eac0369: 				if (positioner.areNullsOrdered(position))
1:eac0369: 				{
1:eac0369: 					traceStream.print(position + " ");
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 			traceStream.println("");
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: */
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Print an array of Qualifiers to the trace stream.
1:eac0369: 	 */
1:eac0369: /*
1:eac0369: 	private final void tracePrintQualifiers(HeaderPrintWriter traceStream,
1:eac0369: 											Qualifier[][] qualifiers,
1:eac0369: 											int depth)
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			char[] indentchars = new char[depth];
1:eac0369: 
1:eac0369: 			/*
1:eac0369: 			** Form an array of tab characters for indentation.
1:eac0369: 			*
1:eac0369: 			while (depth > 0)
1:eac0369: 			{
1:eac0369: 				indentchars[depth - 1] = '\t';
1:eac0369: 				depth--;
1:eac0369: 			}
1:eac0369: 			String indent = new String(indentchars);
1:eac0369: 
1:eac0369: 			if (qualifiers == null)
1:eac0369: 			{
1:eac0369: 				traceStream.println(indent +
1:eac0369: 									MessageService.getTextMessage(
1:eac0369: 										SQLState.LANG_NONE)
1:eac0369: 									);
1:eac0369: 				return;
1:eac0369: 			}
1:eac0369: 
1:eac0369:             // RESOLVE (mikem) We don't support 2-d qualifiers yet.
1:eac0369:             if (SanityManager.DEBUG)
1:eac0369:             {
1:eac0369:                 SanityManager.ASSERT(qualifiers.length == 1);
1:eac0369:             }
1:eac0369: 
1:eac0369: 			for (int i = 0; i < qualifiers[0].length; i++)
1:eac0369: 			{
1:eac0369: 				Qualifier qual = qualifiers[0][i];
1:eac0369: 
1:eac0369: 				traceStream.println("");
1:eac0369: 				traceStream.println(indent + "Column Id: " + qual.getColumnId());
1:eac0369: 				
1:eac0369: 				int operator = qual.getOperator();
1:eac0369: 				String opString = null;
1:eac0369: 				switch (operator)
1:eac0369: 				{
1:eac0369: 				  case Orderable.ORDER_OP_EQUALS:
1:eac0369: 					opString = "=";
1:eac0369: 					break;
1:eac0369: 
1:eac0369: 				  case Orderable.ORDER_OP_LESSOREQUALS:
1:eac0369: 					opString = "<=";
1:eac0369: 					break;
1:eac0369: 
1:eac0369: 				  case Orderable.ORDER_OP_LESSTHAN:
1:eac0369: 					opString = "<";
1:eac0369: 					break;
1:eac0369: 
1:eac0369: 				  default:
1:eac0369: 					opString = "unknown value (" + operator + ")";
1:eac0369: 					break;
1:eac0369: 				}
1:eac0369: 				traceStream.println(indent + "Operator: " + opString);
1:eac0369: 				traceStream.println(indent + "Ordered nulls: " +
1:eac0369: 											qual.getOrderedNulls());
1:eac0369: 				traceStream.println(indent + "Unknown return value: " +
1:eac0369: 											qual.getUnknownRV());
1:eac0369: 				traceStream.println(indent + "Negate comparison result: " +
1:eac0369: 											qual.negateCompareResult());
1:eac0369: 				traceStream.println("");
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: */
1:eac0369: 
1:eac0369: 	public String printStartPosition()
1:eac0369: 	{
1:eac0369: 		return printPosition(startSearchOperator, startKeyGetter, startPosition);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public String printStopPosition()
1:eac0369: 	{
1:eac0369: 		if (sameStartStopPosition)
1:eac0369: 		{
1:eac0369: 			return printPosition(stopSearchOperator, startKeyGetter, startPosition);
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return printPosition(stopSearchOperator, stopKeyGetter, stopPosition);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return a start or stop positioner as a String.
1:eac0369: 	 *
1:eac0369: 	 * If we already generated the information, then use
1:eac0369: 	 * that.  Otherwise, invoke the activation to get it.
1:eac0369: 	 */
1:eac0369: 	private String printPosition(int searchOperator,
1:eac0369: 								 GeneratedMethod positionGetter,
1:eac0369: 								 ExecIndexRow positioner)
1:eac0369: 	{
1:eac0369: 		String output = "";
1:eac0369: 		if (positionGetter == null)
1:eac0369: 		{
1:eac0369: 			return "\t" +
1:eac0369: 					MessageService.getTextMessage(SQLState.LANG_NONE) +
1:eac0369: 					"\n";
1:eac0369: 		}
1:eac0369: 		
1:eac0369: 		if (positioner == null)
1:eac0369: 		{
1:17af76d: 			if (numOpens == 0)
1:17af76d: 				return "\t" + MessageService.getTextMessage(
1:17af76d: 					SQLState.LANG_POSITION_NOT_AVAIL) +
1:17af76d:                                     "\n";
1:eac0369: 			try
1:eac0369: 			{
1:eac0369: 				positioner = (ExecIndexRow)positionGetter.invoke(activation);
1:eac0369: 			}
1:eac0369: 			catch (StandardException e)
1:eac0369: 			{
2:eac0369: 				return "\t" + MessageService.getTextMessage(
1:eac0369: 						SQLState.LANG_UNEXPECTED_EXC_GETTING_POSITIONER,
1:eac0369: 						e.toString());
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		if (positioner == null)
1:eac0369: 		{
1:eac0369: 			return "\t" +
1:eac0369: 					MessageService.getTextMessage(SQLState.LANG_NONE) +
1:eac0369: 					"\n";
1:eac0369: 		}
1:eac0369: 		String searchOp = null;
1:eac0369: 
1:eac0369: 		switch (searchOperator)
1:eac0369: 		{
1:eac0369: 			case ScanController.GE:
1:eac0369: 				searchOp = ">=";
1:eac0369: 				break;
1:eac0369: 
1:eac0369: 			case ScanController.GT:
1:eac0369: 				searchOp = ">";
1:eac0369: 				break;
1:eac0369: 
1:eac0369: 			default:
1:eac0369: 				if (SanityManager.DEBUG)
1:eac0369: 				{
1:eac0369: 					SanityManager.THROWASSERT("Unknown search operator " +
1:eac0369: 												searchOperator);
1:eac0369: 				}
1:eac0369: 
1:eac0369: 				// NOTE: This does not have to be internationalized because
1:eac0369: 				// this code should never be reached.
1:eac0369: 				searchOp = "unknown value (" + searchOperator + ")";
1:eac0369: 				break;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		output = output + "\t" +
1:eac0369: 						MessageService.getTextMessage(
1:eac0369: 							SQLState.LANG_POSITIONER,
1:eac0369: 							searchOp,
1:eac0369: 							String.valueOf(positioner.nColumns())) +
1:eac0369: 						"\n";
1:eac0369: 
1:eac0369: 		output = output + "\t" +
1:eac0369: 					MessageService.getTextMessage(
1:eac0369: 						SQLState.LANG_ORDERED_NULL_SEMANTICS) +
1:eac0369: 					"\n";
1:c9a1206: 		boolean colSeen = false;
1:eac0369: 		for (int position = 0; position < positioner.nColumns(); position++)
1:eac0369: 		{
1:eac0369: 			if (positioner.areNullsOrdered(position))
1:eac0369: 			{
1:eac0369: 				output = output + position + " ";
1:c9a1206: 				colSeen = true;
1:c9a1206: 			}
1:c9a1206: 
1:c9a1206: 			if (colSeen && position == positioner.nColumns() - 1) {
1:c9a1206: 				output = output +  "\n";
1:eac0369: 			}
1:eac0369: 		}
1:c9a1206: 
1:c9a1206: 		return output;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public Properties getScanProperties()
1:eac0369: 	{
1:eac0369: 		if (scanProperties == null)
1:eac0369: 		{
1:eac0369: 			scanProperties = new Properties();
1:eac0369: 		}
1:eac0369: 		try
1:eac0369: 		{
1:eac0369: 			if (scanController != null)
1:eac0369: 			{
1:eac0369: 				scanController.getScanInfo().getAllScanInfo(scanProperties);
1:eac0369: 				/* Did we get a coarser lock due to
1:eac0369: 				 * a covering lock, lock escalation
1:eac0369: 				 * or configuration?
1:eac0369: 				 */
1:eac0369: 				coarserLock = scanController.isTableLocked() &&
1:eac0369: 					(lockMode == TransactionController.MODE_RECORD);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		catch(StandardException se)
1:eac0369: 		{
1:eac0369: 			// ignore
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return scanProperties;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see NoPutResultSet#requiresRelocking
1:eac0369: 	 */
1:eac0369: 	public boolean requiresRelocking()
1:eac0369: 	{
1:eac0369: 		return(
1:eac0369:             isolationLevel == 
1:eac0369:                 TransactionController.ISOLATION_READ_COMMITTED_NOHOLDLOCK);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Update the number of rows in the scan controller.
1:eac0369: 	 *
1:eac0369: 	 * NOTE: It would be more efficient to only update the
1:eac0369: 	 * scan controller if the optimizer's estimated number of
1:eac0369: 	 * rows were wrong by more than some threshold (like 10%).
1:eac0369: 	 * This would require a little more work than I have the
1:eac0369: 	 * time for now, however, as the row estimate that is given
1:eac0369: 	 * to this result set is the total number of rows for all
1:eac0369: 	 * scans, not the number of rows per scan.
1:eac0369: 	 *
1:eac0369: 	 *
1:eac0369: 	 * @param rowsThisScan	The number of rows to update the scanController to
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	protected final void setRowCountIfPossible(long rowsThisScan)
1:eac0369: 					throws StandardException
1:eac0369: 	{
1:eac0369: 		/*
1:eac0369: 		** Is it a heap scan with no qualifiers (full table scan?)
1:eac0369: 		** and is it not for update (we don't want to count rows we're
1:eac0369: 		** about to delete.
1:eac0369: 		*/
1:eac0369: 		if ( ( ! scanController.isKeyed() ) &&
1:eac0369: 			(qualifiers == null || qualifiers.length == 0) &&
1:eac0369: 			( ! forUpdate ) )
1:eac0369: 		{
1:eac0369: 
1:eac0369: 			// Only update rows if different by more than 10%
1:eac0369: 			long diff = rowsThisScan - estimatedRowCount;
1:eac0369: 
1:eac0369: 			long tenPerCent = estimatedRowCount  / 10;
1:eac0369: 
1:eac0369: 			if (diff < 0)
1:eac0369: 				diff = -diff;
1:eac0369: 
1:eac0369: 			if (diff > tenPerCent)
1:eac0369: 				scanController.setEstimatedRowCount(rowsThisScan);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Can we get instantaneous locks when getting share row
1:eac0369: 	 * locks at READ COMMITTED.
1:eac0369: 	 */
1:eac0369: 	protected boolean canGetInstantaneousLocks()
1:eac0369: 	{
1:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Is this ResultSet or it's source result set for update
1:eac0369: 	 * 
1:eac0369: 	 * @return Whether or not the result set is for update.
1:eac0369: 	 */
1:eac0369: 	public boolean isForUpdate()
1:eac0369: 	{
1:eac0369: 		return forUpdate;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Shallow clone this result set.  Used in trigger reference.
1:eac0369: 	 * beetle 4373.
1:eac0369: 	 */
1:eac0369: 	public Object clone()
1:eac0369: 	{
1:eac0369: 		Object clo = null;
1:eac0369: 		try {
1:eac0369: 			clo = super.clone();
1:eac0369: 		}
1:eac0369: 		catch (CloneNotSupportedException e) {}
1:eac0369: 		return clo;
1:eac0369: 	}
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1:  * construction that are done in the open and next calls, to
commit:b197ffa
/////////////////////////////////////////////////////////////////////////
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:a42c32e
/////////////////////////////////////////////////////////////////////////
1: 
1:     boolean loopControl(boolean moreRows) throws StandardException {
1:         return scanController.fetchNext(candidate.getRowArray());
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:                 boolean moreRows = true;
1:                 while (true)
1:                     // loop control overriden by subclass
1:                     // ValidateCheckConstraintResultSet..
1:                     if (! (moreRows = loopControl(moreRows))) {
1:                         break;
1:                     }
commit:af1c18c
/////////////////////////////////////////////////////////////////////////
1:     protected boolean nextDone;
/////////////////////////////////////////////////////////////////////////
1:     protected boolean qualify;
1:     protected boolean currentRowIsValid;
1:     protected boolean scanRepositioned;
commit:c9a1206
/////////////////////////////////////////////////////////////////////////
1: 		boolean colSeen = false;
1: 				colSeen = true;
1: 			}
1: 
1: 			if (colSeen && position == positioner.nColumns() - 1) {
1: 				output = output +  "\n";
1: 
1: 		return output;
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
commit:2a4654b
/////////////////////////////////////////////////////////////////////////
1: 		if( isXplainOnlyMode() )
1: 			return null;
1: 
commit:17af76d
/////////////////////////////////////////////////////////////////////////
1: 			if (numOpens == 0)
1: 				return "\t" + MessageService.getTextMessage(
1: 					SQLState.LANG_POSITION_NOT_AVAIL) +
1:                                     "\n";
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:959fef2
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		int resultRowTemplate,
/////////////////////////////////////////////////////////////////////////
1: 				resultRowTemplate,
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         resultRowBuilder.reset(candidate);
1:         currentRow = getCompactRow(candidate, accessedCols, isKeyed);
1:             scanController.fetchWithoutQualify(candidate.getRowArray());
/////////////////////////////////////////////////////////////////////////
1:         setCurrentRow(candidate);
commit:91f376c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.store.access.BackingStoreHashtable;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * This field is used by beetle 3865, updateable cursor using index. It
1:      * is a hash table containing updated rows that are thrown into future
1:      * direction of the index scan, and as a result we'll hit it again but
1:      * should skip it. The hash table will spill to disk if it grows too big
1:      * to be kept in memory.
1:      */
1:     protected BackingStoreHashtable past2FutureTbl;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1:             if (past2FutureTbl != null)
1:             {
1:                 past2FutureTbl.close();
1:             }
/////////////////////////////////////////////////////////////////////////
commit:bd2badd
/////////////////////////////////////////////////////////////////////////
1: 
1:                 // Updatable index scans are cached in the activation for
1:                 // easy access from IndexChanger. Remember to clear the cached
1:                 // info here, but only if this is the result set that cached
1:                 // it in the first place (DERBY-4585).
1:                 if (forUpdate && isKeyed) {
1:                     activation.clearIndexScanInfo();
1:                 }
1: 
commit:5ce8731
/////////////////////////////////////////////////////////////////////////
1: 	final boolean sameStartStopPosition;
/////////////////////////////////////////////////////////////////////////
1:         initStartAndStopKey();
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Initialize the {@code startPosition} and {@code stopPosition} fields
1:      * which are used to limit the rows returned by the scan.
1:      */
1:     void initStartAndStopKey() throws StandardException {
1:         if (startKeyGetter != null) {
1:             startPosition = (ExecIndexRow) startKeyGetter.invoke(activation);
1:             if (sameStartStopPosition) {
1:                 stopPosition = startPosition;
1:             }
1:         }
1:         if (stopKeyGetter != null) {
1:             stopPosition = (ExecIndexRow) stopKeyGetter.invoke(activation);
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         rowsThisScan = 0;
/////////////////////////////////////////////////////////////////////////
1:         initStartAndStopKey();
commit:109cb26
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 				resultRowAllocator,
/////////////////////////////////////////////////////////////////////////
commit:97105d6
/////////////////////////////////////////////////////////////////////////
1: class TableScanResultSet extends ScanResultSet
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 				lockMode, tableLocked, isolationLevel,
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		initIsolationLevel();
1: 
/////////////////////////////////////////////////////////////////////////
commit:2700e3d
/////////////////////////////////////////////////////////////////////////
1: 	// For Scrollable insensitive updatable result sets, only qualify a row the 
1: 	// first time it's been read, since an update can change a row so that it 
1: 	// no longer qualifies
0: 	private boolean qualify;
1: 
1: 	// currentRowIsValid is set to the result of positioning at a rowLocation.
1: 	// It will be true if the positioning was successful and false if the row 
1: 	// was deleted under our feet. Whenenver currentRowIsValid is false it means 
1: 	// that the row has been deleted.
0: 	private boolean currentRowIsValid;
1: 	
1: 	// Indicates whether the scan has been positioned back to a previously read
1: 	// row, or it is accessing a row for the first time.
0: 	private boolean scanRepositioned;
1: 
/////////////////////////////////////////////////////////////////////////
1: 		
1: 		/* Always qualify the first time a row is being read */
1: 		qualify = true;
1: 		currentRowIsValid = false;
1: 		scanRepositioned = false;
/////////////////////////////////////////////////////////////////////////
1: 		if (currentRow == null || scanRepositioned)
/////////////////////////////////////////////////////////////////////////
1: 		currentRowIsValid = true;
1: 		scanRepositioned = false;
1: 		qualify = true;
/////////////////////////////////////////////////////////////////////////
1: 	 * the last fetch done. If the cursor is closed, 
1: 	 * or the row has been deleted a null is returned.
/////////////////////////////////////////////////////////////////////////
1: 			if (currentRowIsValid) {
1: 				// we reuse the same rowlocation object across several calls.
1: 				if (rlTemplate == null)
1: 					rlTemplate = scanController.newRowLocationTemplate();
1: 				rl = rlTemplate;
1: 				scanController.fetchLocation(rl);
1: 			} else {
1: 				rl = null;
1: 			}
/////////////////////////////////////////////////////////////////////////
1: 	 * If the cursor is closed, the row has been deleted, or
1: 	 * no longer qualifies (for forward only result sets) a 
1: 	 * null is returned.
/////////////////////////////////////////////////////////////////////////
1: 			(!currentRowIsValid)                            ||
1: 			(qualify && scanController.isCurrentPositionDeleted())     ||
1: 			(qualify && (!scanController.doesCurrentPositionQualify())))
/////////////////////////////////////////////////////////////////////////
0:             scanController.fetchWithoutQualify(result.getRowArray());
/////////////////////////////////////////////////////////////////////////
1: 	 * @see NoPutResultSet#positionScanAtRowLocation
1: 	 * 
1: 	 * Also sets qualify to false so that later calls to getCurrentRow
1: 	 * will not attempt to re-qualify the current row. 
1: 	 */
1: 	public void positionScanAtRowLocation(RowLocation rl) 
1: 		throws StandardException 
1: 	{
1: 		// Check if the scanController is a B-tree scan controller. Do not
1: 		// attempt to re-position a b-tree controller.
1: 		if (!isKeyed) {
1: 			currentRowIsValid = scanController.positionAtRowLocation(rl);
1: 		}
1: 		qualify = false;
1: 		scanRepositioned = true;
1: 	}
1: 
1: 	/**
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:854dd10
/////////////////////////////////////////////////////////////////////////
0:                     RowLocation rl2 = (RowLocation) rl.cloneValue(false);
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:4639287
/////////////////////////////////////////////////////////////////////////
1: 						if (past2FutureTbl.remove(rowLoc) != null){
1: 						    continue;
/////////////////////////////////////////////////////////////////////////
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:2ec36d1
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 colRefItem,
/////////////////////////////////////////////////////////////////////////
commit:49f3f24
/////////////////////////////////////////////////////////////////////////
1: 				getCompactRow(candidate, accessedCols, isKeyed);
/////////////////////////////////////////////////////////////////////////
0:             getCompactRow(result, accessedCols, isKeyed);
commit:7008b63
/////////////////////////////////////////////////////////////////////////
1: 		
1: 		recordConstructorTime();
commit:b31849d
/////////////////////////////////////////////////////////////////////////
0: import java.util.Hashtable;
1: import java.util.Properties;
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.services.i18n.MessageService;
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
1: import org.apache.derby.iapi.services.loader.GeneratedMethod;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.sql.execute.CursorResultSet;
1: import org.apache.derby.iapi.sql.execute.ExecRow;
commit:f77f36d
/////////////////////////////////////////////////////////////////////////
0: class TableScanResultSet extends NoPutResultSetImpl
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     TableScanResultSet(long conglomId,
/////////////////////////////////////////////////////////////////////////
1: 		double optimizerEstimatedCost)
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: ;
commit:3fcea8a
/////////////////////////////////////////////////////////////////////////
1:         checkCancellationFlag();
1:             
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.execute.TableScanResultSet
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:9e5097f
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.execute
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.sql.execute;
1: 
0: import org.apache.derby.iapi.sql.execute.CursorResultSet;
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.services.i18n.MessageService;
1: 
1: import org.apache.derby.iapi.sql.Activation;
0: import org.apache.derby.iapi.sql.ResultSet;
0: import org.apache.derby.iapi.sql.execute.ExecRow;
1: import org.apache.derby.iapi.sql.execute.ExecIndexRow;
0: import org.apache.derby.iapi.sql.execute.ExecutionContext;
1: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
0: import org.apache.derby.iapi.sql.execute.TemporaryRowHolder;
1: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1: 
1: import org.apache.derby.iapi.store.access.ConglomerateController;
1: import org.apache.derby.iapi.store.access.DynamicCompiledOpenConglomInfo;
1: import org.apache.derby.iapi.store.access.Qualifier;
1: import org.apache.derby.iapi.store.access.ScanController;
1: import org.apache.derby.iapi.store.access.StaticCompiledOpenConglomInfo;
1: import org.apache.derby.iapi.store.access.TransactionController;
1: 
1: import org.apache.derby.iapi.types.DataValueDescriptor;
1: 
0: import org.apache.derby.iapi.types.Orderable;
1: import org.apache.derby.iapi.types.RowLocation;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
0: import org.apache.derby.iapi.services.stream.HeaderPrintWriter;
0: import org.apache.derby.iapi.services.stream.InfoStreams;
1: 
0: import org.apache.derby.iapi.services.monitor.Monitor;
1: 
0: import org.apache.derby.iapi.services.loader.GeneratedMethod;
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
1: 
0: import org.apache.derby.iapi.reference.SQLState;
1: 
0: import java.util.Properties;
0: import java.util.Hashtable;
1: 
1: /**
1:  * Takes a table and a table filter and returns
1:  * the table's rows satisfying the filter as a result set.
1:  *
1:  * There are several things we could do during object
0:  * construction that are done in the open & next calls, to
1:  * improve performance.
1:  *
0:  * @author ames
1:  */
0: public class TableScanResultSet extends NoPutResultSetImpl
1: 	implements CursorResultSet, Cloneable
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1:     protected ScanController scanController;
1: 	protected boolean		scanControllerOpened;
1: 	protected boolean		isKeyed;
1: 	protected boolean		firstScan = true;
1: 	protected ExecIndexRow	startPosition;
1: 	protected ExecIndexRow	stopPosition;
0: 	protected	ExecRow		candidate;
1: 
1:     // set in constructor and not altered during
1:     // life of object.
1: 	protected long conglomId;
1:     protected DynamicCompiledOpenConglomInfo dcoci;
1:     protected StaticCompiledOpenConglomInfo scoci;
0: 	protected GeneratedMethod resultRowAllocator;
1: 	protected GeneratedMethod startKeyGetter;
1: 	protected int startSearchOperator;
1: 	protected GeneratedMethod stopKeyGetter;
1: 	protected int stopSearchOperator;
1: 	public    Qualifier[][] qualifiers;
0: 	protected GeneratedMethod closeCleanup;
0: 	public String tableName;
0: 	public String indexName;
1: 	protected boolean runTimeStatisticsOn;
0: 	protected FormatableBitSet accessedCols;
1:     protected int[] indexCols;		//index keys base column position array
1: 	public int rowsPerRead;
1: 	public boolean forUpdate;
0: 	private boolean sameStartStopPosition;
0: 	private boolean nextDone;
1: 	private RowLocation rlTemplate;
1: 
0: 	public int isolationLevel;
0: 	public int lockMode;
1: 
1: 	// Run time statistics
1: 	private Properties scanProperties;
1: 	public String startPositionString;
1: 	public String stopPositionString;
1: 	public boolean isConstraint;
1: 	public boolean coarserLock;
1: 	public boolean oneRowScan;
1: 
1: 	protected long	rowsThisScan;
1: 
1: 	private long estimatedRowCount;
1: 
0: 	/* Following fields are used by beetle 3865, updateable cursor using index. "past2FutureTbl"
0: 	 * is a hash table containing updated rows that are thrown into future direction of the
0: 	 * index scan and as a result we'll hit it again but should skip it.  If this hash table
0: 	 * is full, we scan forward and have a virtual memory style temp heap holding future row
0: 	 * id's.
1: 	 */
0: 	protected Hashtable past2FutureTbl;
0: 	protected TemporaryRowHolder futureForUpdateRows;  //tmp table for materialized rids
0: 	protected TemporaryRowHolderResultSet futureRowResultSet;	//result set for reading from above
0: 	protected boolean skipFutureRowHolder;		//skip reading rows from above
0: 	protected boolean sourceDrained;			//all row ids materialized
0: 	protected boolean currentRowPrescanned;	//got a row from above tmp table
0: 	protected boolean compareToLastKey;		//see comments in UpdateResultSet
0: 	protected ExecRow lastCursorKey;
0: 	private ExecRow sparseRow;				//sparse row in heap column order
0: 	private FormatableBitSet sparseRowMap;			//which columns to read
1: 
1:     //
1:     // class interface
1:     //
0:     public TableScanResultSet(long conglomId,
1: 		StaticCompiledOpenConglomInfo scoci, 
1: 		Activation activation, 
0: 		GeneratedMethod resultRowAllocator, 
1: 		int resultSetNumber,
1: 		GeneratedMethod startKeyGetter, int startSearchOperator,
1: 		GeneratedMethod stopKeyGetter, int stopSearchOperator,
1: 		boolean sameStartStopPosition,
1: 		Qualifier[][] qualifiers,
1: 		String tableName,
1: 		String indexName,
1: 		boolean isConstraint,
1: 		boolean forUpdate,
1: 		int colRefItem,
1: 		int indexColItem,
1: 		int lockMode,
1: 		boolean tableLocked,
1: 		int isolationLevel,
1: 		int rowsPerRead,
1: 		boolean oneRowScan,
1: 		double optimizerEstimatedRowCount,
0: 		double optimizerEstimatedCost,
0: 		GeneratedMethod closeCleanup)
1: 			throws StandardException
1:     {
1: 		super(activation,
1: 				resultSetNumber,
1: 				optimizerEstimatedRowCount,
1: 				optimizerEstimatedCost);
1: 
1: 		this.conglomId = conglomId;
1: 
1: 		/* Static info created at compile time and can be shared across
1: 		 * instances of the plan.
1: 		 * Dynamic info created on 1st opening of this ResultSet as
1: 		 * it cannot be shared.
1: 		 */
1:         this.scoci = scoci;
1: 
1: 		if (SanityManager.DEBUG) {
1: 			SanityManager.ASSERT( activation!=null, "table scan must get activation context");
0: 			SanityManager.ASSERT( resultRowAllocator!= null, "table scan must get row allocator");
1: 			if (sameStartStopPosition)
1: 			{
1: 				SanityManager.ASSERT(stopKeyGetter == null,
1: 					"stopKeyGetter expected to be null when sameStartStopPosition is true");
1: 			}
1: 		}
1: 
0:         this.resultRowAllocator = resultRowAllocator;
1: 
1: 		this.startKeyGetter = startKeyGetter;
1: 		this.startSearchOperator = startSearchOperator;
1: 		this.stopKeyGetter = stopKeyGetter;
1: 		this.stopSearchOperator = stopSearchOperator;
1: 		this.sameStartStopPosition = sameStartStopPosition;
1: 		this.qualifiers = qualifiers;
1: 		this.tableName = tableName;
1: 		this.indexName = indexName;
1: 		this.isConstraint = isConstraint;
1: 		this.forUpdate = forUpdate;
1: 		this.rowsPerRead = rowsPerRead;
1: 		this.oneRowScan = oneRowScan;
1: 
0: 		// retrieve the valid column list from
0: 		// the saved objects, if it exists
0: 		this.accessedCols = null;
0: 		if (colRefItem != -1)
1: 		{
0: 			this.accessedCols = (FormatableBitSet)(activation.getPreparedStatement().
0: 						getSavedObject(colRefItem));
1: 		}
1: 		if (indexColItem != -1)
1: 		{
1: 			this.indexCols = (int[])(activation.getPreparedStatement().
1: 						getSavedObject(indexColItem));
1: 		}
1: 		if (indexCols != null)
1: 			activation.setForUpdateIndexScan(this);
1: 
0: 		this.lockMode = lockMode;
1: 
0: 		/* Isolation level - translate from language to store */
0: 		// If not specified, get current isolation level
0: 		if (isolationLevel == ExecutionContext.UNSPECIFIED_ISOLATION_LEVEL)
1: 		{
0: 			isolationLevel = lcc.getCurrentIsolationLevel();
1: 		}
1: 
0:         if (isolationLevel == ExecutionContext.SERIALIZABLE_ISOLATION_LEVEL)
1:         {
0:             this.isolationLevel = TransactionController.ISOLATION_SERIALIZABLE;
1:         }
1:         else
1:         {
0: 			/* NOTE: always do row locking on READ COMMITTED/UNCOMITTED scans,
0: 			 * unless the table is marked as table locked (in sys.systables)
0: 			 * This is to improve concurrency.  Also see FromBaseTable's
0: 			 * updateTargetLockMode (KEEP THESE TWO PLACES CONSISTENT!
0: 			 * bug 4318).
1: 			 */
1: 
0:             /* NOTE: always do row locking on READ COMMITTED/UNCOMMITTED 
0:              *       and repeatable read scans unless the table is marked as 
0:              *       table locked (in sys.systables).
1:              *
0:              *		 We always get instantaneous locks as we will complete
0:              *		 the scan before returning any rows and we will fully
0:              *		 requalify the row if we need to go to the heap on a next().
1:              */
1: 
0:             if (! tableLocked)
1:             {
0:                 this.lockMode = TransactionController.MODE_RECORD;
1:             }
1: 
0:             if (isolationLevel == 
0:                     ExecutionContext.READ_COMMITTED_ISOLATION_LEVEL)
1:             {
1:                 /* 
0:                  * Now we see if we can get instantaneous locks
0:                  * if we are getting share locks.
0:                  * (For example, we can get instantaneous locks
0:                  * when doing a bulk fetch.)
1:                  */
0:                 if ((! forUpdate) && canGetInstantaneousLocks())
1:                 {
0:                     this.isolationLevel = 
0:                         TransactionController.ISOLATION_READ_COMMITTED_NOHOLDLOCK;
1:                 }
1:                 else
1:                 {
0:                     this.isolationLevel = 
0:                         TransactionController.ISOLATION_READ_COMMITTED;
1:                 }
1:             }
0:             else if (isolationLevel == 
0:                         ExecutionContext.READ_UNCOMMITTED_ISOLATION_LEVEL)
1:             {
0:                 this.isolationLevel = 
0:                     TransactionController.ISOLATION_READ_UNCOMMITTED;
1:             }
0:             else if (isolationLevel == 
0:                         ExecutionContext.REPEATABLE_READ_ISOLATION_LEVEL)
1:             {
0:                 this.isolationLevel = 
0:                     TransactionController.ISOLATION_REPEATABLE_READ;
1:             }
1:         }
1: 
1:         if (SanityManager.DEBUG)
1:         {
0:             SanityManager.ASSERT(
0:                 ((isolationLevel == 
0:                       ExecutionContext.READ_COMMITTED_ISOLATION_LEVEL)   ||
0:                  (isolationLevel == 
0:                       ExecutionContext.READ_UNCOMMITTED_ISOLATION_LEVEL) ||
0:                  (isolationLevel == 
0:                       ExecutionContext.REPEATABLE_READ_ISOLATION_LEVEL)  ||
0:                  (isolationLevel == 
0:                       ExecutionContext.SERIALIZABLE_ISOLATION_LEVEL)),
1: 
0:                 "Invalid isolation level - " + isolationLevel);
1:         }
1: 
0: 		this.closeCleanup = closeCleanup;
1: 
1: 		runTimeStatisticsOn = (activation != null &&
1: 							   activation.getLanguageConnectionContext().getRunTimeStatisticsMode());
1: 
0: 		/* Only call row allocators once */
0: 		candidate = (ExecRow) resultRowAllocator.invoke(activation);
0: 		constructorTime += getElapsedMillis(beginTime);
1:     }
1: 
1: 	//
1: 	// ResultSet interface (leftover from NoPutResultSet)
1: 	//
1: 
1: 	/**
1:      * open a scan on the table. scan parameters are evaluated
1:      * at each open, so there is probably some way of altering
1:      * their values...
1: 	 *
1: 	 * @exception StandardException thrown on failure to open
1:      */
1: 	public void	openCore() throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		    SanityManager.ASSERT( ! isOpen, "TableScanResultSet already open");
1: 
1:         // Get the current transaction controller
1:         TransactionController tc = activation.getTransactionController();
1: 
1: 		if (dcoci == null)
1: 			dcoci = tc.getDynamicCompiledConglomInfo(conglomId);
1: 
1: 
0: 		if (startKeyGetter != null)
1: 		{
0: 			startPosition = (ExecIndexRow) startKeyGetter.invoke(activation);
1: 			if (sameStartStopPosition)
1: 			{
0: 				stopPosition = startPosition;
1: 			}
1: 		}
0: 		if (stopKeyGetter != null)
1: 		{
0: 			stopPosition = (ExecIndexRow) stopKeyGetter.invoke(activation);
1: 		}
1: 
1: 		/* NOTE: We always open the ScanController on the 1st open
1: 		 * to do the keyed conglomerate check.
1: 		 */
1: 
1: 		// Determine whether the conglomerate is keyed.  This determines
1: 		// how we find the RowLocation for the base heap.  For non-keyed
1: 		// conglomerates, we ask the scan.  For keyed conglomerates, it
1: 		// is the last column in the row.
1: 		//
1: 		// Do this here, rather than in the constructor, so we can avoid
1: 		// throwing exceptions from the constructor
1: 		if (firstScan)
1: 		{
1: 			openScanController(tc);
1: 
1: 			isKeyed = scanController.isKeyed();
1: 
1: 			/*
1: 			** If scan tracing is turned on, print information about this
1: 			** TableScanResultSet when it is first opened.  We would like
1: 			** to do this when it is constructed, but it is not always
1: 			** possible to get the start and stop positioners at the time
1: 			** this object is constructed (because they may depend on outer
1: 			** rows).
1: 			*/
1: 			if (SanityManager.DEBUG)
1: 			{
1: 				if (SanityManager.DEBUG_ON("ScanTrace"))
1: 				{
1: 					//traceScanParameters();
1: 				}
1: 			}
1: 		}
1: 
1: 		// Check whether there are any comparisons with unordered nulls
1: 		// on either the start or stop position.  If there are, we can
1: 		// (and must) skip the scan, because no rows can qualify
1: 		if (skipScan(startPosition, stopPosition))
1: 		{
1: 			scanControllerOpened = false;
1: 		}
1: 		/* NOTE: We always open the ScanController on the 1st open
1: 		 * to do the keyed conglomerate check, so we only need to
1: 		 * do it here if not the 1st scan.
1: 		 */
1: 		else if (! firstScan)
1: 		{
1: 			openScanController(tc);
1: 		}
1: 
1: 		/* If the scan is on an index and opened for update,
1: 		 * then we cache the scan controller and conglomerate
1: 		 * number in the activation so that the scan controller
1: 		 * can be re-used by the update/delete if the index
1: 		 * that we are scanning also needs to be updated.
1: 		 */
1: 		if (forUpdate && isKeyed)
1: 		{
1: 			activation.setIndexScanController(scanController);
1: 			activation.setIndexConglomerateNumber(conglomId);
1: 		}
1: 
1: 		firstScan = false;
1: 	    isOpen = true;
1: 		numOpens++;
1: 		nextDone = false;
1: 		openTime += getElapsedMillis(beginTime);
1: 	}
1: 
1: 	/*
1: 	** Open the scan controller
1: 	**
1: 	** @param transaction controller will open one if null
1: 	*/
1: 	protected void openScanController(TransactionController tc)
1: 		throws StandardException
1: 	{
1: 		DataValueDescriptor[] startPositionRow = 
1:             startPosition == null ? null : startPosition.getRowArray();
1: 		DataValueDescriptor[] stopPositionRow = 
1:             stopPosition == null ? null : stopPosition.getRowArray();
1: 
1: 		// Clear the Qualifiers's Orderable cache 
1: 		if (qualifiers != null)
1: 		{
1: 			clearOrderableCache(qualifiers);
1: 		}
1: 
1: 		// Get the current transaction controller
1: 		if (tc == null)
1: 			tc = activation.getTransactionController();
1: 
1:         int openMode = 0;
1:         if (forUpdate)
1:         {
1:             openMode = TransactionController.OPENMODE_FORUPDATE;
1: 
1:             if (activation.isCursorActivation())
1:                 openMode |= TransactionController.OPENMODE_USE_UPDATE_LOCKS;
1:         }
1: 
1: 		scanController = tc.openCompiledScan(
1: 				activation.getResultSetHoldability(),
1: 				openMode,
1: 				lockMode,
1: 				isolationLevel,
1: 				accessedCols,
1: 				startPositionRow,
1: 					// not used when giving null start position
1: 				startSearchOperator,
1: 				qualifiers,
1: 				stopPositionRow,
1: 					// not used when giving null stop position
1: 				stopSearchOperator,
1: 				scoci,
1: 				dcoci);
1: 
1: 		/* Remember that we opened the scan */
1: 		scanControllerOpened = true;
1: 
1: 		rowsThisScan = 0;
1: 
1: 		/*
1: 		** Inform the activation of the estimated number of rows.  Only
1: 		** do it here, not in reopen, so that we don't do this costly
1: 		** check too often.
1: 		*/
1: 		estimatedRowCount = scanController.getEstimatedRowCount();
1: 		activation.informOfRowCount(
1: 									this,
1: 									scanController.getEstimatedRowCount()
1: 									);
1: 	}
1: 
1: 	/*
1: 	** reopen the scan controller
1: 	*/
0: 	private void reopenScanController()
1: 		throws StandardException
1: 	{
1: 		DataValueDescriptor[] startPositionRow = 
1:             startPosition == null ? null : startPosition.getRowArray();
1: 		DataValueDescriptor[] stopPositionRow = 
1:             stopPosition == null ? null : stopPosition.getRowArray();
1: 
1: 		// Clear the Qualifiers's Orderable cache 
1: 		if (qualifiers != null)
1: 		{
1: 			clearOrderableCache(qualifiers);
1: 		}
1: 
1: 		scanController.reopenScan(
1: 						startPositionRow,
1: 						startSearchOperator,
1: 						qualifiers,
1: 						stopPositionRow,
1: 						stopSearchOperator);
1: 
1: 		/* Remember that we opened the scan */
1: 		scanControllerOpened = true;
1: 
1: 		rowsThisScan = 0;
1: 	}
1: 
1: 	/**
1:      * Reopen a table scan.  Here we take advantage
1: 	 * of the reopenScan() interface on scanController
1: 	 * for optimimal performance on joins where we are
1: 	 * an inner table.
1: 	 *
1: 	 * @exception StandardException thrown on failure to open
1:      */
1: 	public void	reopenCore() throws StandardException
1: 	{
1: 		beginTime = getCurrentTimeMillis();
1: 		if (SanityManager.DEBUG)
1: 		    SanityManager.ASSERT(isOpen, "TableScanResultSet not open, cannot reopen");
1: 
0: 		if (startKeyGetter != null)
1: 		{
0: 			startPosition = (ExecIndexRow) startKeyGetter.invoke(activation);
1: 			if (sameStartStopPosition)
1: 			{
0: 				stopPosition = startPosition;
1: 			}
1: 		}
0: 		if (stopKeyGetter != null)
1: 		{
0: 			stopPosition = (ExecIndexRow) stopKeyGetter.invoke(activation);
1: 		}
1: 
1: 		// Check whether there are any comparisons with unordered nulls
1: 		// on either the start or stop position.  If there are, we can
1: 		// (and must) skip the scan, because no rows can qualify
1: 		if (skipScan(startPosition, stopPosition))
1: 		{
1: 			scanControllerOpened = false;
1: 		}
1: 		else
1: 		{
1: 			if (scanController == null)
1: 				openScanController((TransactionController)null);
1: 			else
1: 				reopenScanController();
1: 		
1: 		}
1: 
1: 		numOpens++;
1: 		nextDone = false;
1: 		openTime += getElapsedMillis(beginTime);
1: 	}
1: 
1: 	/**
0:      * Check and make sure sparse heap row and accessed bit map are created.
0: 	 * beetle 3865, update cursor using index.
1: 	 *
0: 	 * @exception StandardException thrown on failure
1: 	 */
0: 	private void getSparseRowAndMap() throws StandardException
1: 	{
0: 		int numCols = 1, colPos;
0: 		for (int i = 0; i < indexCols.length; i++)
1: 		{
0: 			colPos = (indexCols[i] > 0) ? indexCols[i] : -indexCols[i];
0: 			if (colPos > numCols)
0: 				numCols = colPos;
1: 		}
0: 		sparseRow = new ValueRow(numCols);
0: 		sparseRowMap = new FormatableBitSet(numCols);
0: 		for (int i = 0; i < indexCols.length; i++)
1: 		{
0: 			if (accessedCols.get(i))
1: 			{
0: 				colPos = (indexCols[i] > 0) ? indexCols[i] : -indexCols[i];
0: 				sparseRow.setColumn(colPos, candidate.getColumn(i + 1));
0: 				sparseRowMap.set(colPos - 1);
1: 			}
1: 		}
1: 	}
1: 		
1: 
1: 	/**
1:      * Return the next row (if any) from the scan (if open).
1: 	 *
1: 	 * @exception StandardException thrown on failure to get next row
1: 	 */
1: 	public ExecRow getNextRowCore() throws StandardException
1: 	{
0: 		if (currentRow == null)
1: 		{
1: 			currentRow =
0: 				getCompactRow(candidate, accessedCols, (FormatableBitSet) null, isKeyed);
1: 		}
1: 
1: 		beginTime = getCurrentTimeMillis();
1: 
1: 		ExecRow result = null;
1: 
0: 		/* beetle 3865, updateable cursor using index. We first saved updated rows with new value
0: 		 * falling into future direction of index scan in hash table, if it's full, we scanned
0: 		 * forward and saved future row ids in a virtual mem heap.
1: 		 */
0: 		if (futureForUpdateRows != null)
1: 		{
0: 			currentRowPrescanned = false;
0: 			if (! skipFutureRowHolder)
1: 			{
0: 				if (futureRowResultSet == null)
1: 				{
0: 					futureRowResultSet = (TemporaryRowHolderResultSet) futureForUpdateRows.getResultSet();
0: 					futureRowResultSet.openCore();
1: 				}
1: 
0: 				ExecRow ridRow = futureRowResultSet.getNextRowCore();
1: 
0: 				if (ridRow != null)
1: 				{
0: 					/* to boost performance, we used virtual mem heap, and we can insert after
0: 					 * we start retrieving results.  The assumption is to
0: 					 * delete current row right after we retrieve it.
1: 					 */
0: 					futureRowResultSet.deleteCurrentRow();
0: 					RowLocation rl = (RowLocation) ridRow.getColumn(1);
0: 					ConglomerateController baseCC = activation.getHeapConglomerateController();
0: 					if (sparseRow == null)
0: 						getSparseRowAndMap();
0:             	   	baseCC.fetch(
0:         	 	      	      rl, sparseRow.getRowArray(), sparseRowMap);
0: 					RowLocation rl2 = (RowLocation) rl.getClone();
0: 					currentRow.setColumn(currentRow.nColumns(), rl2);
0: 					candidate.setColumn(candidate.nColumns(), rl2);		// have to be consistent!
1: 
1: 					result = currentRow;
0: 					currentRowPrescanned = true;
1: 				}
0: 				else if (sourceDrained)
1: 				{
0: 					currentRowPrescanned = true;
1: 					currentRow = null;
1: 				}
1: 
0: 				if (currentRowPrescanned)
1: 				{
1: 					setCurrentRow(result);
1: 
1: 					nextTime += getElapsedMillis(beginTime);
1: 	 		   		return result;
1: 				}
1: 			}
1: 		}
1: 
1: 	    if ( isOpen  && !nextDone)
1: 	    {
1: 			/* Only need to do 1 next per scan
1: 			 * for 1 row scans.
1: 			 */
1: 			nextDone = oneRowScan;
1: 
1: 			if (scanControllerOpened)
1: 			{
0: 				boolean moreRows;
1: 
0: 				while (moreRows =
0: 							scanController.fetchNext(candidate.getRowArray()))
1: 				{
1: 					rowsSeen++;
1: 					rowsThisScan++;
1: 
1: 					/*
1: 					** Skip rows where there are start or stop positioners
1: 					** that do not implement ordered null semantics and
1: 					** there are columns in those positions that contain
1: 					** null.
1: 					** No need to check if start and stop positions are the
1: 					** same, since all predicates in both will be ='s,
1: 					** and hence evaluated in the store.
1: 					*/
1: 					if ((! sameStartStopPosition) && skipRow(candidate))
1: 					{
1: 						rowsFiltered++;
1: 						continue;
1: 					}
1: 
1: 					/* beetle 3865, updateable cursor use index. If we have a hash table that
1: 					 * holds updated records, and we hit it again, skip it, and remove it from
1: 					 * hash since we can't hit it again, and we have a space in hash, so can
1: 					 * stop scanning forward.
1: 					 */
1: 					if (past2FutureTbl != null)
1: 					{
1: 						RowLocation rowLoc = (RowLocation) currentRow.getColumn(currentRow.nColumns());
0: 						if (past2FutureTbl.get(rowLoc) != null)
1: 						{
0: 							past2FutureTbl.remove(rowLoc);
1: 							continue;
1: 						}
1: 					}
1: 
1: 					result = currentRow;
1: 
1: 					break;
1: 				}
1: 
1: 				/*
1: 				** If we just finished a full scan of the heap, update
1: 				** the number of rows in the scan controller.
1: 				**
1: 				** NOTE: It would be more efficient to only update the
1: 				** scan controller if the optimizer's estimated number of
1: 				** rows were wrong by more than some threshold (like 10%).
1: 				** This would require a little more work than I have the
1: 				** time for now, however, as the row estimate that is given
1: 				** to this result set is the total number of rows for all
1: 				** scans, not the number of rows per scan.
1: 				*/
1: 				if (! moreRows)
1: 				{
1: 					setRowCountIfPossible(rowsThisScan);
1: 					currentRow = null;
1: 				}
1: 			}
1: 	    }
1: 
1: 		setCurrentRow(result);
1: 
1: 		nextTime += getElapsedMillis(beginTime);
1: 	    return result;
1: 	}
1: 
1: 	/**
1: 	 * If the result set has been opened,
1: 	 * close the open scan.
1: 	 * @exception StandardException on error
1: 	 */
1: 	public void	close() throws StandardException
1: 	{
1: 		beginTime = getCurrentTimeMillis();
1: 		if ( isOpen )
1: 	    {
1: 			/*
1: 			** If scan tracing is turned on, print information about this
1: 			** TableScanResultSet when it is closed.
1: 			*/
1: 			if (SanityManager.DEBUG)
1: 			{
1: 				if (SanityManager.DEBUG_ON("ScanTrace"))
1: 				{
1: 					//traceClose();
1: 				}
1: 			}
1: 
1: 			// we don't want to keep around a pointer to the
1: 			// row ... so it can be thrown away.
1: 			// REVISIT: does this need to be in a finally
1: 			// block, to ensure that it is executed?
1: 		    clearCurrentRow();
0: 			if (closeCleanup != null) {
1: 				try {
0: 					closeCleanup.invoke(activation); // let activation tidy up
1: 				} catch (StandardException se) {
1: 					if (SanityManager.DEBUG)
0: 						SanityManager.THROWASSERT(se);
1: 				}
1: 			}
1: 
1: 			currentRow = null;
1: 			if (scanController != null)
1: 			{
1: 				// This is where we get the positioner info for inner tables
1: 				if (runTimeStatisticsOn)
1: 				{
1: 					// This is where we get the scan properties for a subquery
1: 					scanProperties = getScanProperties();
1: 					startPositionString = printStartPosition();
1: 					stopPositionString = printStopPosition();
1: 				}
1: 	        	scanController.close();
1: 				scanController = null; // should not access after close
0: 				activation.clearIndexScanInfo();
1: 			}
1: 			scanControllerOpened = false;
1: 			startPosition = null;
1: 			stopPosition = null;
1: 
1: 			super.close();
1: 
1: 			if (indexCols != null)
1: 			{
1: 				ConglomerateController borrowedBaseCC = activation.getHeapConglomerateController();
1: 				if (borrowedBaseCC != null)
1: 				{
1: 					borrowedBaseCC.close();
1: 					activation.clearHeapConglomerateController();
1: 				}
1: 			}
0: 			if (futureRowResultSet != null)
0: 				futureRowResultSet.close();
1: 	    }
1: 		else
1: 			if (SanityManager.DEBUG)
1: 				SanityManager.DEBUG("CloseRepeatInfo","Close of TableScanResultSet repeated");
1: 
1: 		closeTime += getElapsedMillis(beginTime);
1: 	}
1: 
1: 	/**
1: 	 * Return the total amount of time spent in this ResultSet
1: 	 *
1: 	 * @param type	CURRENT_RESULTSET_ONLY - time spent only in this ResultSet
1: 	 *				ENTIRE_RESULTSET_TREE  - time spent in this ResultSet and below.
1: 	 *
1: 	 * @return long		The total amount of time spent (in milliseconds).
1: 	 */
1: 	public long getTimeSpent(int type)
1: 	{
1: 		long totTime = constructorTime + openTime + nextTime + closeTime;
1: 
1: 		/* RESOLVE - subtract out store time later, when available */
1: 		if (type == NoPutResultSet.CURRENT_RESULTSET_ONLY)
1: 		{
1: 			return	totTime;
1: 		}
1: 		else
1: 		{
1: 			return totTime;
1: 		}
1: 	}
1: 
1: 
1: 	//
1: 	// CursorResultSet interface
1: 	//
1: 
1: 	/**
1: 	 * This result set has its row location from
0: 	 * the last fetch done. If the cursor is closed,
0: 	 * a null is returned.
1: 	 *
1: 	 * @see CursorResultSet
1: 	 *
1: 	 * @return the row location of the current cursor row.
1: 	 * @exception StandardException thrown on failure to get row location
1: 	 */
1: 	public RowLocation getRowLocation() throws StandardException
1: 	{
1: 		RowLocation rl;
1: 
1: 		if (! isOpen) return null;
1: 
1: 		if ( ! scanControllerOpened)
1: 			return null;
1: 
1: 		/*
1: 		** If the conglomerate is keyed, the row location of the base row
1: 		** is in the last column of the current row.  If it's not keyed,
1: 		** we get the row location from the scan of the heap.
1: 		*/
1: 		if (isKeyed)
1: 		{
1: 			if (SanityManager.DEBUG)
1: 			{
1: 				SanityManager.ASSERT(currentRow != null,
1: 				  "There must be a current row when fetching the row location");
1: 			}
1: 
1: 			rl = (RowLocation) currentRow.getColumn(
1: 													currentRow.nColumns());
1: 		}
1: 		else
1: 		{
0: 			// we reuse the same rowlocation object across several calls.
0: 			if (rlTemplate == null)
0: 				rlTemplate = scanController.newRowLocationTemplate();
0: 			rl = rlTemplate;
0: 			scanController.fetchLocation(rl);
1: 		}
1: 
1: 		return rl;
1: 	}
1: 
1: 	/**
1: 	 * This result set has its row from the last fetch done. 
0: 	 * If the cursor is closed, a null is returned.
1: 	 *
1: 	 * @see CursorResultSet
1: 	 *
1: 	 * @return the last row returned;
1: 	 * @exception StandardException thrown on failure.
1: 	 */
1: 	/* RESOLVE - this should return activation.getCurrentRow(resultSetNumber),
1: 	 * once there is such a method.  (currentRow is redundant)
1: 	 */
1: 	public ExecRow getCurrentRow() throws StandardException 
1: 	{
1: 	    ExecRow result = null;
1: 
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT(isOpen, "TSRS expected to be open");
1: 
0: 		if (currentRowPrescanned)
1: 			return currentRow;
1: 
1: 		/* Nothing to do if we're not currently on a row or
1: 		 * if the current row get deleted out from under us
1: 		 * or if there is no current scan (can happen if the
1: 		 * scan is being skipped) or if the current position
1: 		 * no longer qualifies.
1: 		 */
1: 		try
1: 		{
1: 			if ((currentRow == null)                        ||
1: 			(!scanControllerOpened)                         ||
0: 			(scanController.isCurrentPositionDeleted())     ||
0: 			(!scanController.doesCurrentPositionQualify()))
1: 			{
1: 				return null;
1: 			}
1: 		}
1: 		catch (StandardException se)
1: 		{
1: 			if (se.getMessageId().equals(SQLState.AM_SCAN_NOT_POSITIONED))
1: 			{
1: 				//bug 4515 - Have a easier to understand error message than what we get from store 
1: 				se=StandardException.newException(SQLState.NO_CURRENT_ROW);
1: 				throw se;
1: 			}
1: 		}
1: 
0: 		result = (ExecRow) resultRowAllocator.invoke(activation);
1: 		currentRow = 
0:             getCompactRow(result, accessedCols, (FormatableBitSet) null, isKeyed);
1: 
1:         try
1:         {
0:             scanController.fetch(result.getRowArray());
1:         }
1:         catch (StandardException se)
1:         {
1:             if (se.getMessageId().equals(SQLState.AM_RECORD_NOT_FOUND))
1:             {
1:                 // Somehow the row got deleted between the above 
1:                 // doesCurrentPositionQualify() call and here (one way is if
1:                 // this scan is read uncommitted isolation level).
1:                 return null;
1:             }
1:             else
1:             {
1:                 throw se;
1:             }
1:         }
1: 
1: 		setCurrentRow(result);
1: 	    return currentRow;
1: 	}
1: 
1: 	/**
1: 	 * Print the parameters that constructed this result set to the
1: 	 * trace stream.
1: 	 */
1: /*
1: 	private final void traceScanParameters()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			HeaderPrintWriter traceStream = SanityManager.GET_DEBUG_STREAM();
1: 
1: 			traceStream.println("");
1: 			traceStream.println("TableScanResultSet number " +
1: 								resultSetNumber +
1: 								" parameters:");
1: 
1: 			traceStream.println("");
1: 			traceStream.println("\tTable name: " + tableName);
1: 			if (indexName != null)
1: 			{
1: 				traceStream.println("\tIndex name: " + indexName);
1: 			}
1: 			traceStream.println("");
1: 			traceStream.println("\tStart position is: ");
1: 			tracePrintPosition(traceStream,
1: 								startSearchOperator,
1: 								startKeyGetter);
1: 			traceStream.println("");
1: 			traceStream.println("\tStop position is: " );
1: 			tracePrintPosition(traceStream,
1: 								stopSearchOperator,
1: 								stopKeyGetter);
1: 			traceStream.println("");
1: 			traceStream.println("\tQualifiers are: ");
1: 			tracePrintQualifiers(traceStream, qualifiers, 2);
1: 			traceStream.println("");
1: 		}
1: 	}
1: */
1: 
1: 	/**
1: 	 * Print I/O statistics about a scan when it closes.
1: 	 */
1: /*
1: 	private final void traceClose()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			InfoStreams			infoStreams;
1: 			HeaderPrintWriter	traceStream;
1: 
1: 			traceStream = SanityManager.GET_DEBUG_STREAM();
1: 
1: 			traceStream.println("TableScanResultSet number " +
1: 								resultSetNumber +
1: 								" closed.");
1: 			if (isKeyed)
1: 			{
1: 				traceStream.println("\t" +
1: 									rowCount() +
1: 									" row(s) qualified from " +
1: 									"keyed" +
1: 									" table " +
1: 									tableName +
1: 									" using index " +
1: 									indexName);
1: 			}
1: 			else
1: 			{
1: 				traceStream.println("\t" +
1: 									rowCount() +
1: 									" row(s) qualified from " +
1: 									"non-keyed" +
1: 									" table " +
1: 									tableName);
1: 			}
1: 			traceStream.println("");
1: 		}
1: 	}
1: */
1: 
1: 	/**
1: 	 * Print a start or stop positioner to the trace stream.
1: 	 */
1: /*
1: 	private final void tracePrintPosition(HeaderPrintWriter traceStream,
1: 										  int searchOperator,
1: 										  GeneratedMethod positionGetter)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			if (positionGetter == null)
1: 			{
1: 				traceStream.println("\t\tNone");
1: 				return;
1: 			}
1: 
1: 			ExecIndexRow	positioner = null;
1: 
1: 			try
1: 			{
1: 				positioner = (ExecIndexRow) positionGetter.invoke(activation);
1: 			}
1: 			catch (StandardException e)
1: 			{
1: 				traceStream.println("\t\tUnexpected exception " +
1: 									e +
1: 									" getting positioner.");
1: 				e.printStackTrace(traceStream.getPrintWriter());
1: 				return;
1: 			}
1: 
1: 			if (positioner == null)
1: 			{
1: 				traceStream.println("\t\tNone");
1: 				return;
1: 			}
1: 
1: 			String searchOp = null;
1: 
1: 			switch (searchOperator)
1: 			{
1: 			  case ScanController.GE:
1: 				searchOp = "GE";
1: 				break;
1: 
1: 			  case ScanController.GT:
1: 				searchOp = "GT";
1: 				break;
1: 
1: 			  default:
1: 				searchOp = "unknown value (" + searchOperator + ")";
1: 				break;
1: 			}
1: 
1: 			traceStream.println("\t\t" +
1: 								searchOp +
1: 								" on first " +
1: 								positioner.nColumns() +
1: 								" column(s).");
1: 
1: 			traceStream.print(
1: 					"\t\tOrdered null semantics on the following columns: ");
1: 			for (int position = 0; position < positioner.nColumns(); position++)
1: 			{
1: 				if (positioner.areNullsOrdered(position))
1: 				{
1: 					traceStream.print(position + " ");
1: 				}
1: 			}
1: 			traceStream.println("");
1: 		}
1: 	}
1: */
1: 
1: 
1: 	/**
1: 	 * Print an array of Qualifiers to the trace stream.
1: 	 */
1: /*
1: 	private final void tracePrintQualifiers(HeaderPrintWriter traceStream,
1: 											Qualifier[][] qualifiers,
1: 											int depth)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			char[] indentchars = new char[depth];
1: 
1: 			/*
1: 			** Form an array of tab characters for indentation.
1: 			*
1: 			while (depth > 0)
1: 			{
1: 				indentchars[depth - 1] = '\t';
1: 				depth--;
1: 			}
1: 			String indent = new String(indentchars);
1: 
1: 			if (qualifiers == null)
1: 			{
1: 				traceStream.println(indent +
1: 									MessageService.getTextMessage(
1: 										SQLState.LANG_NONE)
1: 									);
1: 				return;
1: 			}
1: 
1:             // RESOLVE (mikem) We don't support 2-d qualifiers yet.
1:             if (SanityManager.DEBUG)
1:             {
1:                 SanityManager.ASSERT(qualifiers.length == 1);
1:             }
1: 
1: 			for (int i = 0; i < qualifiers[0].length; i++)
1: 			{
1: 				Qualifier qual = qualifiers[0][i];
1: 
1: 				traceStream.println("");
1: 				traceStream.println(indent + "Column Id: " + qual.getColumnId());
1: 				
1: 				int operator = qual.getOperator();
1: 				String opString = null;
1: 				switch (operator)
1: 				{
1: 				  case Orderable.ORDER_OP_EQUALS:
1: 					opString = "=";
1: 					break;
1: 
1: 				  case Orderable.ORDER_OP_LESSOREQUALS:
1: 					opString = "<=";
1: 					break;
1: 
1: 				  case Orderable.ORDER_OP_LESSTHAN:
1: 					opString = "<";
1: 					break;
1: 
1: 				  default:
1: 					opString = "unknown value (" + operator + ")";
1: 					break;
1: 				}
1: 				traceStream.println(indent + "Operator: " + opString);
1: 				traceStream.println(indent + "Ordered nulls: " +
1: 											qual.getOrderedNulls());
1: 				traceStream.println(indent + "Unknown return value: " +
1: 											qual.getUnknownRV());
1: 				traceStream.println(indent + "Negate comparison result: " +
1: 											qual.negateCompareResult());
1: 				traceStream.println("");
1: 			}
1: 		}
1: 	}
1: */
1: 
1: 	public String printStartPosition()
1: 	{
1: 		return printPosition(startSearchOperator, startKeyGetter, startPosition);
1: 	}
1: 
1: 	public String printStopPosition()
1: 	{
1: 		if (sameStartStopPosition)
1: 		{
1: 			return printPosition(stopSearchOperator, startKeyGetter, startPosition);
1: 		}
1: 		else
1: 		{
1: 			return printPosition(stopSearchOperator, stopKeyGetter, stopPosition);
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Return a start or stop positioner as a String.
1: 	 *
1: 	 * If we already generated the information, then use
1: 	 * that.  Otherwise, invoke the activation to get it.
1: 	 */
1: 	private String printPosition(int searchOperator,
1: 								 GeneratedMethod positionGetter,
1: 								 ExecIndexRow positioner)
1: 	{
0:                 String idt = "";
1: 		String output = "";
1: 		if (positionGetter == null)
1: 		{
1: 			return "\t" +
1: 					MessageService.getTextMessage(SQLState.LANG_NONE) +
1: 					"\n";
1: 		}
1: 		
1: 		if (positioner == null)
1: 		{
1: 			try
1: 			{
1: 				positioner = (ExecIndexRow)positionGetter.invoke(activation);
1: 			}
1: 			catch (StandardException e)
1: 			{
0: 				// the positionGetter will fail with a NullPointerException
0: 				// if the outer table is empty
0: 				// (this isn't a problem since we won't call it on the inner
0: 				// table if there are no rows on the outer table)
0: 				if (e.getSQLState() == SQLState.LANG_UNEXPECTED_USER_EXCEPTION )
1: 					return "\t" + MessageService.getTextMessage(
0: 						SQLState.LANG_POSITION_NOT_AVAIL);
1: 				return "\t" + MessageService.getTextMessage(
1: 						SQLState.LANG_UNEXPECTED_EXC_GETTING_POSITIONER,
1: 						e.toString());
1: 			}
1: 		}
1: 		if (positioner == null)
1: 		{
1: 			return "\t" +
1: 					MessageService.getTextMessage(SQLState.LANG_NONE) +
1: 					"\n";
1: 		}
1: 		String searchOp = null;
1: 
1: 		switch (searchOperator)
1: 		{
1: 			case ScanController.GE:
1: 				searchOp = ">=";
1: 				break;
1: 
1: 			case ScanController.GT:
1: 				searchOp = ">";
1: 				break;
1: 
1: 			default:
1: 				if (SanityManager.DEBUG)
1: 				{
1: 					SanityManager.THROWASSERT("Unknown search operator " +
1: 												searchOperator);
1: 				}
1: 
1: 				// NOTE: This does not have to be internationalized because
1: 				// this code should never be reached.
1: 				searchOp = "unknown value (" + searchOperator + ")";
1: 				break;
1: 		}
1: 
1: 		output = output + "\t" +
1: 						MessageService.getTextMessage(
1: 							SQLState.LANG_POSITIONER,
1: 							searchOp,
1: 							String.valueOf(positioner.nColumns())) +
1: 						"\n";
1: 
1: 		output = output + "\t" +
1: 					MessageService.getTextMessage(
1: 						SQLState.LANG_ORDERED_NULL_SEMANTICS) +
1: 					"\n";
1: 		for (int position = 0; position < positioner.nColumns(); position++)
1: 		{
1: 			if (positioner.areNullsOrdered(position))
1: 			{
1: 				output = output + position + " ";
1: 			}
1: 		}
1: 		
0: 		return output + "\n";
1: 	}
1: 
1: 	public Properties getScanProperties()
1: 	{
1: 		if (scanProperties == null)
1: 		{
1: 			scanProperties = new Properties();
1: 		}
1: 		try
1: 		{
1: 			if (scanController != null)
1: 			{
1: 				scanController.getScanInfo().getAllScanInfo(scanProperties);
1: 				/* Did we get a coarser lock due to
1: 				 * a covering lock, lock escalation
1: 				 * or configuration?
1: 				 */
1: 				coarserLock = scanController.isTableLocked() &&
1: 					(lockMode == TransactionController.MODE_RECORD);
1: 			}
1: 		}
1: 		catch(StandardException se)
1: 		{
1: 			// ignore
1: 		}
1: 
1: 		return scanProperties;
1: 	}
1: 
1: 	/**
0: 	 * @see NoPutResultSet#getScanIsolationLevel
1: 	 */
0: 	public int getScanIsolationLevel()
1: 	{
0: 		return isolationLevel;
1: 	}
1: 
1: 	/**
1: 	 * @see NoPutResultSet#requiresRelocking
1: 	 */
1: 	public boolean requiresRelocking()
1: 	{
1: 		return(
1:             isolationLevel == 
1:                 TransactionController.ISOLATION_READ_COMMITTED_NOHOLDLOCK);
1: 	}
1: 
1: 	/**
1: 	 * Update the number of rows in the scan controller.
1: 	 *
1: 	 * NOTE: It would be more efficient to only update the
1: 	 * scan controller if the optimizer's estimated number of
1: 	 * rows were wrong by more than some threshold (like 10%).
1: 	 * This would require a little more work than I have the
1: 	 * time for now, however, as the row estimate that is given
1: 	 * to this result set is the total number of rows for all
1: 	 * scans, not the number of rows per scan.
1: 	 *
1: 	 *
1: 	 * @param rowsThisScan	The number of rows to update the scanController to
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	protected final void setRowCountIfPossible(long rowsThisScan)
1: 					throws StandardException
1: 	{
1: 		/*
1: 		** Is it a heap scan with no qualifiers (full table scan?)
1: 		** and is it not for update (we don't want to count rows we're
1: 		** about to delete.
1: 		*/
1: 		if ( ( ! scanController.isKeyed() ) &&
1: 			(qualifiers == null || qualifiers.length == 0) &&
1: 			( ! forUpdate ) )
1: 		{
1: 
1: 			// Only update rows if different by more than 10%
1: 			long diff = rowsThisScan - estimatedRowCount;
1: 
1: 			long tenPerCent = estimatedRowCount  / 10;
1: 
1: 			if (diff < 0)
1: 				diff = -diff;
1: 
1: 			if (diff > tenPerCent)
1: 				scanController.setEstimatedRowCount(rowsThisScan);
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Can we get instantaneous locks when getting share row
1: 	 * locks at READ COMMITTED.
1: 	 */
1: 	protected boolean canGetInstantaneousLocks()
1: 	{
1: 		return false;
1: 	}
1: 
1: 
1: 	/**
1: 	 * Is this ResultSet or it's source result set for update
1: 	 * 
1: 	 * @return Whether or not the result set is for update.
1: 	 */
1: 	public boolean isForUpdate()
1: 	{
1: 		return forUpdate;
1: 	}
1: 
1: 	/**
1: 	 * Shallow clone this result set.  Used in trigger reference.
1: 	 * beetle 4373.
1: 	 */
1: 	public Object clone()
1: 	{
1: 		Object clo = null;
1: 		try {
1: 			clo = super.clone();
1: 		}
1: 		catch (CloneNotSupportedException e) {}
1: 		return clo;
1: 	}
1: }
author:Army
-------------------------------------------------------------------------------
commit:9fd3c00
/////////////////////////////////////////////////////////////////////////
0: 		 * happen if we plug it into first column of "startPositionRow".
0: 		 * So in this case startPositionRow[0] functions as a "place-holder"
0: 		 * for the probe value.  The same goes for stopPositionRow[0].
0: 		 *
0: 		 * Note that it *is* possible for a start/stop key to contain more
0: 		 * than one column (ex. if we're scanning a multi-column index). In
0: 		 * that case we plug probeValue into the first column of the start
0: 		 * and/or stop key and leave the rest of the key as it is.  As an 
0: 		 * example, assume we have the following predicates:
0: 		 *
0: 		 *    ... where d in (1, 20000) and b > 200 and b <= 500
0: 		 *
0: 		 * And assume further that we have an index defined on (d, b).
0: 		 * In this case it's possible that we have TWO start predicates
0: 		 * and TWO stop predicates: the IN list will give us "d = probeVal",
0: 		 * which is a start predicate and a stop predicate; then "b > 200"
0: 		 * may give us a second start predicate, while "b <= 500" may give
0: 		 * us a second stop predicate.  So in this situation we want our
0: 		 * start key to be:
0: 		 *
0: 		 *    (probeValue, 200)
0: 		 *
0: 		 * and our stop key to be:
0: 		 *
0: 		 *    (probeValue, 500).
0: 		 *
0: 		 * This will effectively limit the scan so that it only returns
0: 		 * rows whose "D" column equals probeValue and whose "B" column
0: 		 * falls in the range of 200 thru 500.
0: 		 *
0: 		 * Note: Derby currently only allows a single start/stop predicate
0: 		 * per column. See PredicateList.orderUsefulPredicates().
0: 		{
0: 		 	/* If the start key and stop key are the same, we've already set
0: 			 * stopPosition equal to startPosition as part of openCore().
0: 			 * So by putting the probe value into startPositionRow[0], we
0: 			 * also put it into stopPositionRow[0].
0: 			 */
0: 			if (!sameStartStopPosition)
0: 				stopPositionRow[0] = probeValue;
0: 		}
0: 
/////////////////////////////////////////////////////////////////////////
0: 		{
0: 			if (!sameStartStopPosition)
0: 				stopPositionRow[0] = probeValue;
0: 		}
commit:028077e
/////////////////////////////////////////////////////////////////////////
0: 		openScanController(tc, (DataValueDescriptor)null);
0: 	}
0: 
0: 	/*
0: 	** Does the work of openScanController.
0: 	**
0: 	** @param tc transaction controller; will open one if null.
0: 	** @param probeValue If non-null then we will open the scan controller
0: 	**  and position it using the received probeValue as the start key.
0: 	**  Otherwise we'll use whatever value is in startPosition (if non-
0: 	**  null) as the start key.
0: 	*/
0: 	protected void openScanController(TransactionController tc,
0: 		DataValueDescriptor probeValue) throws StandardException
0: 	{
0: 		/* If we have a probe value then we do the "probe" by positioning
0: 		 * the scan at the first row matching the value.  The way to do
0: 		 * that is to use the value as a start key, which is what will
0: 		 * happen if we plug it into "startPositionRow".  So in this case
0: 		 * startPositionRow functions as a "place-holder" for the probe
0: 		 * value.  Note: if we have a probe value then we want to use it
0: 		 * as the start key AND as the stop key.  In that case the value
0: 		 * of "sameStartStopPosition" would have been true when we created
0: 		 * this result set, and thus we've already set stopPosition equal
0: 		 * to startPosition as part of openCore(). So by putting the probe
0: 		 * value into startPositionRow, we're also putting it into
0: 		 * stopPositionRow, which is what we want.
0: 		 */
0: 		if (probeValue != null)
0: 			startPositionRow[0] = probeValue;
0: 
/////////////////////////////////////////////////////////////////////////
1: 	protected void reopenScanController() throws StandardException
0: 	{
0: 		reopenScanController((DataValueDescriptor)null);
0: 	}
0: 
0: 	/*
0: 	** Does the work of reopenScanController.
0: 	**
0: 	** @param probeValue If non-null then we will open the scan controller
0: 	**  and position it using the received probeValue as the start key.
0: 	**  Otherwise we'll use whatever value is in startPosition (if non-
0: 	**  null) as the start key.
0: 	*/
0: 	protected void reopenScanController(DataValueDescriptor probeValue)
/////////////////////////////////////////////////////////////////////////
0: 		/* If we have a probe value then we do the "probe" by using the
0: 		 * value as a start and stop key.  See openScanController() for
0: 		 * details.  Note that in this case we do *not* want to reset
0: 		 * the rowsThisScan variable because we are going to be doing
0: 		 * multiple "probes" for a single scan.  Logic to detect when
0: 		 * when we've actually started a new scan (as opposed to just
0: 		 * repositioning an existing scan based on a probe value) is
0: 		 * in MultiProbeTableScanResultSet.reopenScanController(),
0: 		 * and that method will then take care of resetting the variable
0: 		 * (if needed) for probing scans.
0: 		 */
0: 		if (probeValue != null)
0: 			startPositionRow[0] = probeValue;
0: 		else
0: 			rowsThisScan = 0;
0: 
/////////////////////////////////////////////////////////////////////////
author:David Van Couvering
-------------------------------------------------------------------------------
commit:f6123ee
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Bernt Johnsen
-------------------------------------------------------------------------------
commit:c247315
/////////////////////////////////////////////////////////////////////////
1: 					if (se.getMessageId().
1: 						equals(SQLState.HEAP_SCAN_NOT_POSITIONED)) {
1:                     throw se;
commit:f342d5b
/////////////////////////////////////////////////////////////////////////
0: 				try {
0: 					scanController.fetchLocation(rl);
0: 				} catch (StandardException se) {
0: 					if (se.getMessageId().equals(SQLState.AM_SCAN_NOT_POSITIONED)) {
0: 						
1: 						//Have a easier to understand error message than what 
1: 						//we get from store 
1: 						throw StandardException.
1: 							newException(SQLState.NO_CURRENT_ROW);
0: 					}
0: 				}
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:c7248d5
/////////////////////////////////////////////////////////////////////////
1: 	public String userSuppliedOptimizerOverrides;
/////////////////////////////////////////////////////////////////////////
1: 		String userSuppliedOptimizerOverrides,
/////////////////////////////////////////////////////////////////////////
1: 		this.userSuppliedOptimizerOverrides = userSuppliedOptimizerOverrides;
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.execute
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.sql.execute;
0: 
0: import org.apache.derby.iapi.sql.execute.CursorResultSet;
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.services.i18n.MessageService;
0: 
0: import org.apache.derby.iapi.sql.Activation;
0: import org.apache.derby.iapi.sql.ResultSet;
0: import org.apache.derby.iapi.sql.execute.ExecRow;
0: import org.apache.derby.iapi.sql.execute.ExecIndexRow;
0: import org.apache.derby.iapi.sql.execute.ExecutionContext;
0: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
0: import org.apache.derby.iapi.sql.execute.TemporaryRowHolder;
0: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: 
0: import org.apache.derby.iapi.store.access.ConglomerateController;
0: import org.apache.derby.iapi.store.access.DynamicCompiledOpenConglomInfo;
0: import org.apache.derby.iapi.store.access.Qualifier;
0: import org.apache.derby.iapi.store.access.ScanController;
0: import org.apache.derby.iapi.store.access.StaticCompiledOpenConglomInfo;
0: import org.apache.derby.iapi.store.access.TransactionController;
0: 
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: 
0: import org.apache.derby.iapi.types.Orderable;
0: import org.apache.derby.iapi.types.RowLocation;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.services.stream.HeaderPrintWriter;
0: import org.apache.derby.iapi.services.stream.InfoStreams;
0: 
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: 
0: import org.apache.derby.iapi.services.loader.GeneratedMethod;
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import java.util.Properties;
0: import java.util.Hashtable;
0: 
0: /**
0:  * Takes a table and a table filter and returns
0:  * the table's rows satisfying the filter as a result set.
0:  *
0:  * There are several things we could do during object
0:  * construction that are done in the open & next calls, to
0:  * improve performance.
0:  *
0:  * @author ames
0:  */
0: public class TableScanResultSet extends NoPutResultSetImpl
0: 	implements CursorResultSet, Cloneable
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0:     protected ScanController scanController;
0: 	protected boolean		scanControllerOpened;
0: 	protected boolean		isKeyed;
0: 	protected boolean		firstScan = true;
0: 	protected ExecIndexRow	startPosition;
0: 	protected ExecIndexRow	stopPosition;
0: 	protected	ExecRow		candidate;
0: 
0:     // set in constructor and not altered during
0:     // life of object.
0: 	protected long conglomId;
0:     protected DynamicCompiledOpenConglomInfo dcoci;
0:     protected StaticCompiledOpenConglomInfo scoci;
0: 	protected GeneratedMethod resultRowAllocator;
0: 	protected GeneratedMethod startKeyGetter;
0: 	protected int startSearchOperator;
0: 	protected GeneratedMethod stopKeyGetter;
0: 	protected int stopSearchOperator;
0: 	public    Qualifier[][] qualifiers;
0: 	protected GeneratedMethod closeCleanup;
0: 	public String tableName;
0: 	public String indexName;
0: 	protected boolean runTimeStatisticsOn;
0: 	protected FormatableBitSet accessedCols;
0:     protected int[] indexCols;		//index keys base column position array
0: 	public int rowsPerRead;
0: 	public boolean forUpdate;
0: 	private boolean sameStartStopPosition;
0: 	private boolean nextDone;
0: 	private RowLocation rlTemplate;
0: 
0: 	public int isolationLevel;
0: 	public int lockMode;
0: 
0: 	// Run time statistics
0: 	private Properties scanProperties;
0: 	public String startPositionString;
0: 	public String stopPositionString;
0: 	public boolean isConstraint;
0: 	public boolean coarserLock;
0: 	public boolean oneRowScan;
0: 
0: 	protected long	rowsThisScan;
0: 
0: 	private long estimatedRowCount;
0: 
0: 	/* Following fields are used by beetle 3865, updateable cursor using index. "past2FutureTbl"
0: 	 * is a hash table containing updated rows that are thrown into future direction of the
0: 	 * index scan and as a result we'll hit it again but should skip it.  If this hash table
0: 	 * is full, we scan forward and have a virtual memory style temp heap holding future row
0: 	 * id's.
0: 	 */
0: 	protected Hashtable past2FutureTbl;
0: 	protected TemporaryRowHolder futureForUpdateRows;  //tmp table for materialized rids
0: 	protected TemporaryRowHolderResultSet futureRowResultSet;	//result set for reading from above
0: 	protected boolean skipFutureRowHolder;		//skip reading rows from above
0: 	protected boolean sourceDrained;			//all row ids materialized
0: 	protected boolean currentRowPrescanned;	//got a row from above tmp table
0: 	protected boolean compareToLastKey;		//see comments in UpdateResultSet
0: 	protected ExecRow lastCursorKey;
0: 	private ExecRow sparseRow;				//sparse row in heap column order
0: 	private FormatableBitSet sparseRowMap;			//which columns to read
0: 
0:     //
0:     // class interface
0:     //
0:     public TableScanResultSet(long conglomId,
0: 		StaticCompiledOpenConglomInfo scoci, 
0: 		Activation activation, 
0: 		GeneratedMethod resultRowAllocator, 
0: 		int resultSetNumber,
0: 		GeneratedMethod startKeyGetter, int startSearchOperator,
0: 		GeneratedMethod stopKeyGetter, int stopSearchOperator,
0: 		boolean sameStartStopPosition,
0: 		Qualifier[][] qualifiers,
0: 		String tableName,
0: 		String indexName,
0: 		boolean isConstraint,
0: 		boolean forUpdate,
0: 		int colRefItem,
0: 		int indexColItem,
0: 		int lockMode,
0: 		boolean tableLocked,
0: 		int isolationLevel,
0: 		int rowsPerRead,
0: 		boolean oneRowScan,
0: 		double optimizerEstimatedRowCount,
0: 		double optimizerEstimatedCost,
0: 		GeneratedMethod closeCleanup)
0: 			throws StandardException
0:     {
0: 		super(activation,
0: 				resultSetNumber,
0: 				optimizerEstimatedRowCount,
0: 				optimizerEstimatedCost);
0: 
0: 		this.conglomId = conglomId;
0: 
0: 		/* Static info created at compile time and can be shared across
0: 		 * instances of the plan.
0: 		 * Dynamic info created on 1st opening of this ResultSet as
0: 		 * it cannot be shared.
0: 		 */
0:         this.scoci = scoci;
0: 
0: 		if (SanityManager.DEBUG) {
0: 			SanityManager.ASSERT( activation!=null, "table scan must get activation context");
0: 			SanityManager.ASSERT( resultRowAllocator!= null, "table scan must get row allocator");
0: 			if (sameStartStopPosition)
0: 			{
0: 				SanityManager.ASSERT(stopKeyGetter == null,
0: 					"stopKeyGetter expected to be null when sameStartStopPosition is true");
0: 			}
0: 		}
0: 
0:         this.resultRowAllocator = resultRowAllocator;
0: 
0: 		this.startKeyGetter = startKeyGetter;
0: 		this.startSearchOperator = startSearchOperator;
0: 		this.stopKeyGetter = stopKeyGetter;
0: 		this.stopSearchOperator = stopSearchOperator;
0: 		this.sameStartStopPosition = sameStartStopPosition;
0: 		this.qualifiers = qualifiers;
0: 		this.tableName = tableName;
0: 		this.indexName = indexName;
0: 		this.isConstraint = isConstraint;
0: 		this.forUpdate = forUpdate;
0: 		this.rowsPerRead = rowsPerRead;
0: 		this.oneRowScan = oneRowScan;
0: 
0: 		// retrieve the valid column list from
0: 		// the saved objects, if it exists
0: 		this.accessedCols = null;
0: 		if (colRefItem != -1)
0: 		{
0: 			this.accessedCols = (FormatableBitSet)(activation.getPreparedStatement().
0: 						getSavedObject(colRefItem));
0: 		}
0: 		if (indexColItem != -1)
0: 		{
0: 			this.indexCols = (int[])(activation.getPreparedStatement().
0: 						getSavedObject(indexColItem));
0: 		}
0: 		if (indexCols != null)
0: 			activation.setForUpdateIndexScan(this);
0: 
0: 		this.lockMode = lockMode;
0: 
0: 		/* Isolation level - translate from language to store */
0: 		// If not specified, get current isolation level
0: 		if (isolationLevel == ExecutionContext.UNSPECIFIED_ISOLATION_LEVEL)
0: 		{
0: 			isolationLevel = lcc.getCurrentIsolationLevel();
0: 		}
0: 
0:         if (isolationLevel == ExecutionContext.SERIALIZABLE_ISOLATION_LEVEL)
0:         {
0:             this.isolationLevel = TransactionController.ISOLATION_SERIALIZABLE;
0:         }
0:         else
0:         {
0: 			/* NOTE: always do row locking on READ COMMITTED/UNCOMITTED scans,
0: 			 * unless the table is marked as table locked (in sys.systables)
0: 			 * This is to improve concurrency.  Also see FromBaseTable's
0: 			 * updateTargetLockMode (KEEP THESE TWO PLACES CONSISTENT!
0: 			 * bug 4318).
0: 			 */
0: 
0:             /* NOTE: always do row locking on READ COMMITTED/UNCOMMITTED 
0:              *       and repeatable read scans unless the table is marked as 
0:              *       table locked (in sys.systables).
0:              *
0:              *		 We always get instantaneous locks as we will complete
0:              *		 the scan before returning any rows and we will fully
0:              *		 requalify the row if we need to go to the heap on a next().
0:              */
0: 
0:             if (! tableLocked)
0:             {
0:                 this.lockMode = TransactionController.MODE_RECORD;
0:             }
0: 
0:             if (isolationLevel == 
0:                     ExecutionContext.READ_COMMITTED_ISOLATION_LEVEL)
0:             {
0:                 /* 
0:                  * Now we see if we can get instantaneous locks
0:                  * if we are getting share locks.
0:                  * (For example, we can get instantaneous locks
0:                  * when doing a bulk fetch.)
0:                  */
0:                 if ((! forUpdate) && canGetInstantaneousLocks())
0:                 {
0:                     this.isolationLevel = 
0:                         TransactionController.ISOLATION_READ_COMMITTED_NOHOLDLOCK;
0:                 }
0:                 else
0:                 {
0:                     this.isolationLevel = 
0:                         TransactionController.ISOLATION_READ_COMMITTED;
0:                 }
0:             }
0:             else if (isolationLevel == 
0:                         ExecutionContext.READ_UNCOMMITTED_ISOLATION_LEVEL)
0:             {
0:                 this.isolationLevel = 
0:                     TransactionController.ISOLATION_READ_UNCOMMITTED;
0:             }
0:             else if (isolationLevel == 
0:                         ExecutionContext.REPEATABLE_READ_ISOLATION_LEVEL)
0:             {
0:                 this.isolationLevel = 
0:                     TransactionController.ISOLATION_REPEATABLE_READ;
0:             }
0:         }
0: 
0:         if (SanityManager.DEBUG)
0:         {
0:             SanityManager.ASSERT(
0:                 ((isolationLevel == 
0:                       ExecutionContext.READ_COMMITTED_ISOLATION_LEVEL)   ||
0:                  (isolationLevel == 
0:                       ExecutionContext.READ_UNCOMMITTED_ISOLATION_LEVEL) ||
0:                  (isolationLevel == 
0:                       ExecutionContext.REPEATABLE_READ_ISOLATION_LEVEL)  ||
0:                  (isolationLevel == 
0:                       ExecutionContext.SERIALIZABLE_ISOLATION_LEVEL)),
0: 
0:                 "Invalid isolation level - " + isolationLevel);
0:         }
0: 
0: 		this.closeCleanup = closeCleanup;
0: 
0: 		runTimeStatisticsOn = (activation != null &&
0: 							   activation.getLanguageConnectionContext().getRunTimeStatisticsMode());
0: 
0: 		/* Only call row allocators once */
0: 		candidate = (ExecRow) resultRowAllocator.invoke(activation);
0: 		constructorTime += getElapsedMillis(beginTime);
0:     }
0: 
0: 	//
0: 	// ResultSet interface (leftover from NoPutResultSet)
0: 	//
0: 
0: 	/**
0:      * open a scan on the table. scan parameters are evaluated
0:      * at each open, so there is probably some way of altering
0:      * their values...
0: 	 *
0: 	 * @exception StandardException thrown on failure to open
0:      */
0: 	public void	openCore() throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		    SanityManager.ASSERT( ! isOpen, "TableScanResultSet already open");
0: 
0:         // Get the current transaction controller
0:         TransactionController tc = activation.getTransactionController();
0: 
0: 		if (dcoci == null)
0: 			dcoci = tc.getDynamicCompiledConglomInfo(conglomId);
0: 
0: 
0: 		if (startKeyGetter != null)
0: 		{
0: 			startPosition = (ExecIndexRow) startKeyGetter.invoke(activation);
0: 			if (sameStartStopPosition)
0: 			{
0: 				stopPosition = startPosition;
0: 			}
0: 		}
0: 		if (stopKeyGetter != null)
0: 		{
0: 			stopPosition = (ExecIndexRow) stopKeyGetter.invoke(activation);
0: 		}
0: 
0: 		/* NOTE: We always open the ScanController on the 1st open
0: 		 * to do the keyed conglomerate check.
0: 		 */
0: 
0: 		// Determine whether the conglomerate is keyed.  This determines
0: 		// how we find the RowLocation for the base heap.  For non-keyed
0: 		// conglomerates, we ask the scan.  For keyed conglomerates, it
0: 		// is the last column in the row.
0: 		//
0: 		// Do this here, rather than in the constructor, so we can avoid
0: 		// throwing exceptions from the constructor
0: 		if (firstScan)
0: 		{
0: 			openScanController(tc);
0: 
0: 			isKeyed = scanController.isKeyed();
0: 
0: 			/*
0: 			** If scan tracing is turned on, print information about this
0: 			** TableScanResultSet when it is first opened.  We would like
0: 			** to do this when it is constructed, but it is not always
0: 			** possible to get the start and stop positioners at the time
0: 			** this object is constructed (because they may depend on outer
0: 			** rows).
0: 			*/
0: 			if (SanityManager.DEBUG)
0: 			{
0: 				if (SanityManager.DEBUG_ON("ScanTrace"))
0: 				{
0: 					//traceScanParameters();
0: 				}
0: 			}
0: 		}
0: 
0: 		// Check whether there are any comparisons with unordered nulls
0: 		// on either the start or stop position.  If there are, we can
0: 		// (and must) skip the scan, because no rows can qualify
0: 		if (skipScan(startPosition, stopPosition))
0: 		{
0: 			scanControllerOpened = false;
0: 		}
0: 		/* NOTE: We always open the ScanController on the 1st open
0: 		 * to do the keyed conglomerate check, so we only need to
0: 		 * do it here if not the 1st scan.
0: 		 */
0: 		else if (! firstScan)
0: 		{
0: 			openScanController(tc);
0: 		}
0: 
0: 		/* If the scan is on an index and opened for update,
0: 		 * then we cache the scan controller and conglomerate
0: 		 * number in the activation so that the scan controller
0: 		 * can be re-used by the update/delete if the index
0: 		 * that we are scanning also needs to be updated.
0: 		 */
0: 		if (forUpdate && isKeyed)
0: 		{
0: 			activation.setIndexScanController(scanController);
0: 			activation.setIndexConglomerateNumber(conglomId);
0: 		}
0: 
0: 		firstScan = false;
0: 	    isOpen = true;
0: 		numOpens++;
0: 		nextDone = false;
0: 		openTime += getElapsedMillis(beginTime);
0: 	}
0: 
0: 	/*
0: 	** Open the scan controller
0: 	**
0: 	** @param transaction controller will open one if null
0: 	*/
0: 	protected void openScanController(TransactionController tc)
0: 		throws StandardException
0: 	{
0: 		DataValueDescriptor[] startPositionRow = 
0:             startPosition == null ? null : startPosition.getRowArray();
0: 		DataValueDescriptor[] stopPositionRow = 
0:             stopPosition == null ? null : stopPosition.getRowArray();
0: 
0: 		// Clear the Qualifiers's Orderable cache 
0: 		if (qualifiers != null)
0: 		{
0: 			clearOrderableCache(qualifiers);
0: 		}
0: 
0: 		// Get the current transaction controller
0: 		if (tc == null)
0: 			tc = activation.getTransactionController();
0: 
0:         int openMode = 0;
0:         if (forUpdate)
0:         {
0:             openMode = TransactionController.OPENMODE_FORUPDATE;
0: 
0:             if (activation.isCursorActivation())
0:                 openMode |= TransactionController.OPENMODE_USE_UPDATE_LOCKS;
0:         }
0: 
0: 		scanController = tc.openCompiledScan(
0: 				activation.getResultSetHoldability(),
0: 				openMode,
0: 				lockMode,
0: 				isolationLevel,
0: 				accessedCols,
0: 				startPositionRow,
0: 					// not used when giving null start position
0: 				startSearchOperator,
0: 				qualifiers,
0: 				stopPositionRow,
0: 					// not used when giving null stop position
0: 				stopSearchOperator,
0: 				scoci,
0: 				dcoci);
0: 
0: 		/* Remember that we opened the scan */
0: 		scanControllerOpened = true;
0: 
0: 		rowsThisScan = 0;
0: 
0: 		/*
0: 		** Inform the activation of the estimated number of rows.  Only
0: 		** do it here, not in reopen, so that we don't do this costly
0: 		** check too often.
0: 		*/
0: 		estimatedRowCount = scanController.getEstimatedRowCount();
0: 		activation.informOfRowCount(
0: 									this,
0: 									scanController.getEstimatedRowCount()
0: 									);
0: 	}
0: 
0: 	/*
0: 	** reopen the scan controller
0: 	*/
0: 	private void reopenScanController()
0: 		throws StandardException
0: 	{
0: 		DataValueDescriptor[] startPositionRow = 
0:             startPosition == null ? null : startPosition.getRowArray();
0: 		DataValueDescriptor[] stopPositionRow = 
0:             stopPosition == null ? null : stopPosition.getRowArray();
0: 
0: 		// Clear the Qualifiers's Orderable cache 
0: 		if (qualifiers != null)
0: 		{
0: 			clearOrderableCache(qualifiers);
0: 		}
0: 
0: 		scanController.reopenScan(
0: 						startPositionRow,
0: 						startSearchOperator,
0: 						qualifiers,
0: 						stopPositionRow,
0: 						stopSearchOperator);
0: 
0: 		/* Remember that we opened the scan */
0: 		scanControllerOpened = true;
0: 
0: 		rowsThisScan = 0;
0: 	}
0: 
0: 	/**
0:      * Reopen a table scan.  Here we take advantage
0: 	 * of the reopenScan() interface on scanController
0: 	 * for optimimal performance on joins where we are
0: 	 * an inner table.
0: 	 *
0: 	 * @exception StandardException thrown on failure to open
0:      */
0: 	public void	reopenCore() throws StandardException
0: 	{
0: 		beginTime = getCurrentTimeMillis();
0: 		if (SanityManager.DEBUG)
0: 		    SanityManager.ASSERT(isOpen, "TableScanResultSet not open, cannot reopen");
0: 
0: 		if (startKeyGetter != null)
0: 		{
0: 			startPosition = (ExecIndexRow) startKeyGetter.invoke(activation);
0: 			if (sameStartStopPosition)
0: 			{
0: 				stopPosition = startPosition;
0: 			}
0: 		}
0: 		if (stopKeyGetter != null)
0: 		{
0: 			stopPosition = (ExecIndexRow) stopKeyGetter.invoke(activation);
0: 		}
0: 
0: 		// Check whether there are any comparisons with unordered nulls
0: 		// on either the start or stop position.  If there are, we can
0: 		// (and must) skip the scan, because no rows can qualify
0: 		if (skipScan(startPosition, stopPosition))
0: 		{
0: 			scanControllerOpened = false;
0: 		}
0: 		else
0: 		{
0: 			if (scanController == null)
0: 				openScanController((TransactionController)null);
0: 			else
0: 				reopenScanController();
0: 		
0: 		}
0: 
0: 		numOpens++;
0: 		nextDone = false;
0: 		openTime += getElapsedMillis(beginTime);
0: 	}
0: 
0: 	/**
0:      * Check and make sure sparse heap row and accessed bit map are created.
0: 	 * beetle 3865, update cursor using index.
0: 	 *
0: 	 * @exception StandardException thrown on failure
0: 	 */
0: 	private void getSparseRowAndMap() throws StandardException
0: 	{
0: 		int numCols = 1, colPos;
0: 		for (int i = 0; i < indexCols.length; i++)
0: 		{
0: 			colPos = (indexCols[i] > 0) ? indexCols[i] : -indexCols[i];
0: 			if (colPos > numCols)
0: 				numCols = colPos;
0: 		}
0: 		sparseRow = new ValueRow(numCols);
0: 		sparseRowMap = new FormatableBitSet(numCols);
0: 		for (int i = 0; i < indexCols.length; i++)
0: 		{
0: 			if (accessedCols.get(i))
0: 			{
0: 				colPos = (indexCols[i] > 0) ? indexCols[i] : -indexCols[i];
0: 				sparseRow.setColumn(colPos, candidate.getColumn(i + 1));
0: 				sparseRowMap.set(colPos - 1);
0: 			}
0: 		}
0: 	}
0: 		
0: 
0: 	/**
0:      * Return the next row (if any) from the scan (if open).
0: 	 *
0: 	 * @exception StandardException thrown on failure to get next row
0: 	 */
0: 	public ExecRow getNextRowCore() throws StandardException
0: 	{
0: 		if (currentRow == null)
0: 		{
0: 			currentRow =
0: 				getCompactRow(candidate, accessedCols, (FormatableBitSet) null, isKeyed);
0: 		}
0: 
0: 		beginTime = getCurrentTimeMillis();
0: 
0: 		ExecRow result = null;
0: 
0: 		/* beetle 3865, updateable cursor using index. We first saved updated rows with new value
0: 		 * falling into future direction of index scan in hash table, if it's full, we scanned
0: 		 * forward and saved future row ids in a virtual mem heap.
0: 		 */
0: 		if (futureForUpdateRows != null)
0: 		{
0: 			currentRowPrescanned = false;
0: 			if (! skipFutureRowHolder)
0: 			{
0: 				if (futureRowResultSet == null)
0: 				{
0: 					futureRowResultSet = (TemporaryRowHolderResultSet) futureForUpdateRows.getResultSet();
0: 					futureRowResultSet.openCore();
0: 				}
0: 
0: 				ExecRow ridRow = futureRowResultSet.getNextRowCore();
0: 
0: 				if (ridRow != null)
0: 				{
0: 					/* to boost performance, we used virtual mem heap, and we can insert after
0: 					 * we start retrieving results.  The assumption is to
0: 					 * delete current row right after we retrieve it.
0: 					 */
0: 					futureRowResultSet.deleteCurrentRow();
0: 					RowLocation rl = (RowLocation) ridRow.getColumn(1);
0: 					ConglomerateController baseCC = activation.getHeapConglomerateController();
0: 					if (sparseRow == null)
0: 						getSparseRowAndMap();
0:             	   	baseCC.fetch(
0:         	 	      	      rl, sparseRow.getRowArray(), sparseRowMap);
0: 					RowLocation rl2 = (RowLocation) rl.getClone();
0: 					currentRow.setColumn(currentRow.nColumns(), rl2);
0: 					candidate.setColumn(candidate.nColumns(), rl2);		// have to be consistent!
0: 
0: 					result = currentRow;
0: 					currentRowPrescanned = true;
0: 				}
0: 				else if (sourceDrained)
0: 				{
0: 					currentRowPrescanned = true;
0: 					currentRow = null;
0: 				}
0: 
0: 				if (currentRowPrescanned)
0: 				{
0: 					setCurrentRow(result);
0: 
0: 					nextTime += getElapsedMillis(beginTime);
0: 	 		   		return result;
0: 				}
0: 			}
0: 		}
0: 
0: 	    if ( isOpen  && !nextDone)
0: 	    {
0: 			/* Only need to do 1 next per scan
0: 			 * for 1 row scans.
0: 			 */
0: 			nextDone = oneRowScan;
0: 
0: 			if (scanControllerOpened)
0: 			{
0: 				boolean moreRows;
0: 
0: 				while (moreRows =
0: 							scanController.fetchNext(candidate.getRowArray()))
0: 				{
0: 					rowsSeen++;
0: 					rowsThisScan++;
0: 
0: 					/*
0: 					** Skip rows where there are start or stop positioners
0: 					** that do not implement ordered null semantics and
0: 					** there are columns in those positions that contain
0: 					** null.
0: 					** No need to check if start and stop positions are the
0: 					** same, since all predicates in both will be ='s,
0: 					** and hence evaluated in the store.
0: 					*/
0: 					if ((! sameStartStopPosition) && skipRow(candidate))
0: 					{
0: 						rowsFiltered++;
0: 						continue;
0: 					}
0: 
0: 					/* beetle 3865, updateable cursor use index. If we have a hash table that
0: 					 * holds updated records, and we hit it again, skip it, and remove it from
0: 					 * hash since we can't hit it again, and we have a space in hash, so can
0: 					 * stop scanning forward.
0: 					 */
0: 					if (past2FutureTbl != null)
0: 					{
0: 						RowLocation rowLoc = (RowLocation) currentRow.getColumn(currentRow.nColumns());
0: 						if (past2FutureTbl.get(rowLoc) != null)
0: 						{
0: 							past2FutureTbl.remove(rowLoc);
0: 							continue;
0: 						}
0: 					}
0: 
0: 					result = currentRow;
0: 
0: 					break;
0: 				}
0: 
0: 				/*
0: 				** If we just finished a full scan of the heap, update
0: 				** the number of rows in the scan controller.
0: 				**
0: 				** NOTE: It would be more efficient to only update the
0: 				** scan controller if the optimizer's estimated number of
0: 				** rows were wrong by more than some threshold (like 10%).
0: 				** This would require a little more work than I have the
0: 				** time for now, however, as the row estimate that is given
0: 				** to this result set is the total number of rows for all
0: 				** scans, not the number of rows per scan.
0: 				*/
0: 				if (! moreRows)
0: 				{
0: 					setRowCountIfPossible(rowsThisScan);
0: 					currentRow = null;
0: 				}
0: 			}
0: 	    }
0: 
0: 		setCurrentRow(result);
0: 
0: 		nextTime += getElapsedMillis(beginTime);
0: 	    return result;
0: 	}
0: 
0: 	/**
0: 	 * If the result set has been opened,
0: 	 * close the open scan.
0: 	 * @exception StandardException on error
0: 	 */
0: 	public void	close() throws StandardException
0: 	{
0: 		beginTime = getCurrentTimeMillis();
0: 		if ( isOpen )
0: 	    {
0: 			/*
0: 			** If scan tracing is turned on, print information about this
0: 			** TableScanResultSet when it is closed.
0: 			*/
0: 			if (SanityManager.DEBUG)
0: 			{
0: 				if (SanityManager.DEBUG_ON("ScanTrace"))
0: 				{
0: 					//traceClose();
0: 				}
0: 			}
0: 
0: 			// we don't want to keep around a pointer to the
0: 			// row ... so it can be thrown away.
0: 			// REVISIT: does this need to be in a finally
0: 			// block, to ensure that it is executed?
0: 		    clearCurrentRow();
0: 			if (closeCleanup != null) {
0: 				try {
0: 					closeCleanup.invoke(activation); // let activation tidy up
0: 				} catch (StandardException se) {
0: 					if (SanityManager.DEBUG)
0: 						SanityManager.THROWASSERT(se);
0: 				}
0: 			}
0: 
0: 			currentRow = null;
0: 			if (scanController != null)
0: 			{
0: 				// This is where we get the positioner info for inner tables
0: 				if (runTimeStatisticsOn)
0: 				{
0: 					// This is where we get the scan properties for a subquery
0: 					scanProperties = getScanProperties();
0: 					startPositionString = printStartPosition();
0: 					stopPositionString = printStopPosition();
0: 				}
0: 	        	scanController.close();
0: 				scanController = null; // should not access after close
0: 				activation.clearIndexScanInfo();
0: 			}
0: 			scanControllerOpened = false;
0: 			startPosition = null;
0: 			stopPosition = null;
0: 
0: 			super.close();
0: 
0: 			if (indexCols != null)
0: 			{
0: 				ConglomerateController borrowedBaseCC = activation.getHeapConglomerateController();
0: 				if (borrowedBaseCC != null)
0: 				{
0: 					borrowedBaseCC.close();
0: 					activation.clearHeapConglomerateController();
0: 				}
0: 			}
0: 			if (futureRowResultSet != null)
0: 				futureRowResultSet.close();
0: 	    }
0: 		else
0: 			if (SanityManager.DEBUG)
0: 				SanityManager.DEBUG("CloseRepeatInfo","Close of TableScanResultSet repeated");
0: 
0: 		closeTime += getElapsedMillis(beginTime);
0: 	}
0: 
0: 	/**
0: 	 * Return the total amount of time spent in this ResultSet
0: 	 *
0: 	 * @param type	CURRENT_RESULTSET_ONLY - time spent only in this ResultSet
0: 	 *				ENTIRE_RESULTSET_TREE  - time spent in this ResultSet and below.
0: 	 *
0: 	 * @return long		The total amount of time spent (in milliseconds).
0: 	 */
0: 	public long getTimeSpent(int type)
0: 	{
0: 		long totTime = constructorTime + openTime + nextTime + closeTime;
0: 
0: 		/* RESOLVE - subtract out store time later, when available */
0: 		if (type == NoPutResultSet.CURRENT_RESULTSET_ONLY)
0: 		{
0: 			return	totTime;
0: 		}
0: 		else
0: 		{
0: 			return totTime;
0: 		}
0: 	}
0: 
0: 
0: 	//
0: 	// CursorResultSet interface
0: 	//
0: 
0: 	/**
0: 	 * This result set has its row location from
0: 	 * the last fetch done. If the cursor is closed,
0: 	 * a null is returned.
0: 	 *
0: 	 * @see CursorResultSet
0: 	 *
0: 	 * @return the row location of the current cursor row.
0: 	 * @exception StandardException thrown on failure to get row location
0: 	 */
0: 	public RowLocation getRowLocation() throws StandardException
0: 	{
0: 		RowLocation rl;
0: 
0: 		if (! isOpen) return null;
0: 
0: 		if ( ! scanControllerOpened)
0: 			return null;
0: 
0: 		/*
0: 		** If the conglomerate is keyed, the row location of the base row
0: 		** is in the last column of the current row.  If it's not keyed,
0: 		** we get the row location from the scan of the heap.
0: 		*/
0: 		if (isKeyed)
0: 		{
0: 			if (SanityManager.DEBUG)
0: 			{
0: 				SanityManager.ASSERT(currentRow != null,
0: 				  "There must be a current row when fetching the row location");
0: 			}
0: 
0: 			rl = (RowLocation) currentRow.getColumn(
0: 													currentRow.nColumns());
0: 		}
0: 		else
0: 		{
0: 			// we reuse the same rowlocation object across several calls.
0: 			if (rlTemplate == null)
0: 				rlTemplate = scanController.newRowLocationTemplate();
0: 			rl = rlTemplate;
0: 			scanController.fetchLocation(rl);
0: 		}
0: 
0: 		return rl;
0: 	}
0: 
0: 	/**
0: 	 * This result set has its row from the last fetch done. 
0: 	 * If the cursor is closed, a null is returned.
0: 	 *
0: 	 * @see CursorResultSet
0: 	 *
0: 	 * @return the last row returned;
0: 	 * @exception StandardException thrown on failure.
0: 	 */
0: 	/* RESOLVE - this should return activation.getCurrentRow(resultSetNumber),
0: 	 * once there is such a method.  (currentRow is redundant)
0: 	 */
0: 	public ExecRow getCurrentRow() throws StandardException 
0: 	{
0: 	    ExecRow result = null;
0: 
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(isOpen, "TSRS expected to be open");
0: 
0: 		if (currentRowPrescanned)
0: 			return currentRow;
0: 
0: 		/* Nothing to do if we're not currently on a row or
0: 		 * if the current row get deleted out from under us
0: 		 * or if there is no current scan (can happen if the
0: 		 * scan is being skipped) or if the current position
0: 		 * no longer qualifies.
0: 		 */
0: 		try
0: 		{
0: 			if ((currentRow == null)                        ||
0: 			(!scanControllerOpened)                         ||
0: 			(scanController.isCurrentPositionDeleted())     ||
0: 			(!scanController.doesCurrentPositionQualify()))
0: 			{
0: 				return null;
0: 			}
0: 		}
0: 		catch (StandardException se)
0: 		{
0: 			if (se.getMessageId().equals(SQLState.AM_SCAN_NOT_POSITIONED))
0: 			{
0: 				//bug 4515 - Have a easier to understand error message than what we get from store 
0: 				se=StandardException.newException(SQLState.NO_CURRENT_ROW);
0: 				throw se;
0: 			}
0: 		}
0: 
0: 		result = (ExecRow) resultRowAllocator.invoke(activation);
0: 		currentRow = 
0:             getCompactRow(result, accessedCols, (FormatableBitSet) null, isKeyed);
0: 
0:         try
0:         {
0:             scanController.fetch(result.getRowArray());
0:         }
0:         catch (StandardException se)
0:         {
0:             if (se.getMessageId().equals(SQLState.AM_RECORD_NOT_FOUND))
0:             {
0:                 // Somehow the row got deleted between the above 
0:                 // doesCurrentPositionQualify() call and here (one way is if
0:                 // this scan is read uncommitted isolation level).
0:                 return null;
0:             }
0:             else
0:             {
0:                 throw se;
0:             }
0:         }
0: 
0: 		setCurrentRow(result);
0: 	    return currentRow;
0: 	}
0: 
0: 	/**
0: 	 * Print the parameters that constructed this result set to the
0: 	 * trace stream.
0: 	 */
0: /*
0: 	private final void traceScanParameters()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			HeaderPrintWriter traceStream = SanityManager.GET_DEBUG_STREAM();
0: 
0: 			traceStream.println("");
0: 			traceStream.println("TableScanResultSet number " +
0: 								resultSetNumber +
0: 								" parameters:");
0: 
0: 			traceStream.println("");
0: 			traceStream.println("\tTable name: " + tableName);
0: 			if (indexName != null)
0: 			{
0: 				traceStream.println("\tIndex name: " + indexName);
0: 			}
0: 			traceStream.println("");
0: 			traceStream.println("\tStart position is: ");
0: 			tracePrintPosition(traceStream,
0: 								startSearchOperator,
0: 								startKeyGetter);
0: 			traceStream.println("");
0: 			traceStream.println("\tStop position is: " );
0: 			tracePrintPosition(traceStream,
0: 								stopSearchOperator,
0: 								stopKeyGetter);
0: 			traceStream.println("");
0: 			traceStream.println("\tQualifiers are: ");
0: 			tracePrintQualifiers(traceStream, qualifiers, 2);
0: 			traceStream.println("");
0: 		}
0: 	}
0: */
0: 
0: 	/**
0: 	 * Print I/O statistics about a scan when it closes.
0: 	 */
0: /*
0: 	private final void traceClose()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			InfoStreams			infoStreams;
0: 			HeaderPrintWriter	traceStream;
0: 
0: 			traceStream = SanityManager.GET_DEBUG_STREAM();
0: 
0: 			traceStream.println("TableScanResultSet number " +
0: 								resultSetNumber +
0: 								" closed.");
0: 			if (isKeyed)
0: 			{
0: 				traceStream.println("\t" +
0: 									rowCount() +
0: 									" row(s) qualified from " +
0: 									"keyed" +
0: 									" table " +
0: 									tableName +
0: 									" using index " +
0: 									indexName);
0: 			}
0: 			else
0: 			{
0: 				traceStream.println("\t" +
0: 									rowCount() +
0: 									" row(s) qualified from " +
0: 									"non-keyed" +
0: 									" table " +
0: 									tableName);
0: 			}
0: 			traceStream.println("");
0: 		}
0: 	}
0: */
0: 
0: 	/**
0: 	 * Print a start or stop positioner to the trace stream.
0: 	 */
0: /*
0: 	private final void tracePrintPosition(HeaderPrintWriter traceStream,
0: 										  int searchOperator,
0: 										  GeneratedMethod positionGetter)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (positionGetter == null)
0: 			{
0: 				traceStream.println("\t\tNone");
0: 				return;
0: 			}
0: 
0: 			ExecIndexRow	positioner = null;
0: 
0: 			try
0: 			{
0: 				positioner = (ExecIndexRow) positionGetter.invoke(activation);
0: 			}
0: 			catch (StandardException e)
0: 			{
0: 				traceStream.println("\t\tUnexpected exception " +
0: 									e +
0: 									" getting positioner.");
0: 				e.printStackTrace(traceStream.getPrintWriter());
0: 				return;
0: 			}
0: 
0: 			if (positioner == null)
0: 			{
0: 				traceStream.println("\t\tNone");
0: 				return;
0: 			}
0: 
0: 			String searchOp = null;
0: 
0: 			switch (searchOperator)
0: 			{
0: 			  case ScanController.GE:
0: 				searchOp = "GE";
0: 				break;
0: 
0: 			  case ScanController.GT:
0: 				searchOp = "GT";
0: 				break;
0: 
0: 			  default:
0: 				searchOp = "unknown value (" + searchOperator + ")";
0: 				break;
0: 			}
0: 
0: 			traceStream.println("\t\t" +
0: 								searchOp +
0: 								" on first " +
0: 								positioner.nColumns() +
0: 								" column(s).");
0: 
0: 			traceStream.print(
0: 					"\t\tOrdered null semantics on the following columns: ");
0: 			for (int position = 0; position < positioner.nColumns(); position++)
0: 			{
0: 				if (positioner.areNullsOrdered(position))
0: 				{
0: 					traceStream.print(position + " ");
0: 				}
0: 			}
0: 			traceStream.println("");
0: 		}
0: 	}
0: */
0: 
0: 
0: 	/**
0: 	 * Print an array of Qualifiers to the trace stream.
0: 	 */
0: /*
0: 	private final void tracePrintQualifiers(HeaderPrintWriter traceStream,
0: 											Qualifier[][] qualifiers,
0: 											int depth)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			char[] indentchars = new char[depth];
0: 
0: 			/*
0: 			** Form an array of tab characters for indentation.
0: 			*
0: 			while (depth > 0)
0: 			{
0: 				indentchars[depth - 1] = '\t';
0: 				depth--;
0: 			}
0: 			String indent = new String(indentchars);
0: 
0: 			if (qualifiers == null)
0: 			{
0: 				traceStream.println(indent +
0: 									MessageService.getTextMessage(
0: 										SQLState.LANG_NONE)
0: 									);
0: 				return;
0: 			}
0: 
0:             // RESOLVE (mikem) We don't support 2-d qualifiers yet.
0:             if (SanityManager.DEBUG)
0:             {
0:                 SanityManager.ASSERT(qualifiers.length == 1);
0:             }
0: 
0: 			for (int i = 0; i < qualifiers[0].length; i++)
0: 			{
0: 				Qualifier qual = qualifiers[0][i];
0: 
0: 				traceStream.println("");
0: 				traceStream.println(indent + "Column Id: " + qual.getColumnId());
0: 				
0: 				int operator = qual.getOperator();
0: 				String opString = null;
0: 				switch (operator)
0: 				{
0: 				  case Orderable.ORDER_OP_EQUALS:
0: 					opString = "=";
0: 					break;
0: 
0: 				  case Orderable.ORDER_OP_LESSOREQUALS:
0: 					opString = "<=";
0: 					break;
0: 
0: 				  case Orderable.ORDER_OP_LESSTHAN:
0: 					opString = "<";
0: 					break;
0: 
0: 				  default:
0: 					opString = "unknown value (" + operator + ")";
0: 					break;
0: 				}
0: 				traceStream.println(indent + "Operator: " + opString);
0: 				traceStream.println(indent + "Ordered nulls: " +
0: 											qual.getOrderedNulls());
0: 				traceStream.println(indent + "Unknown return value: " +
0: 											qual.getUnknownRV());
0: 				traceStream.println(indent + "Negate comparison result: " +
0: 											qual.negateCompareResult());
0: 				traceStream.println("");
0: 			}
0: 		}
0: 	}
0: */
0: 
0: 	public String printStartPosition()
0: 	{
0: 		return printPosition(startSearchOperator, startKeyGetter, startPosition);
0: 	}
0: 
0: 	public String printStopPosition()
0: 	{
0: 		if (sameStartStopPosition)
0: 		{
0: 			return printPosition(stopSearchOperator, startKeyGetter, startPosition);
0: 		}
0: 		else
0: 		{
0: 			return printPosition(stopSearchOperator, stopKeyGetter, stopPosition);
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Return a start or stop positioner as a String.
0: 	 *
0: 	 * If we already generated the information, then use
0: 	 * that.  Otherwise, invoke the activation to get it.
0: 	 */
0: 	private String printPosition(int searchOperator,
0: 								 GeneratedMethod positionGetter,
0: 								 ExecIndexRow positioner)
0: 	{
0:                 String idt = "";
0: 		String output = "";
0: 		if (positionGetter == null)
0: 		{
0: 			return "\t" +
0: 					MessageService.getTextMessage(SQLState.LANG_NONE) +
0: 					"\n";
0: 		}
0: 		
0: 		if (positioner == null)
0: 		{
0: 			try
0: 			{
0: 				positioner = (ExecIndexRow)positionGetter.invoke(activation);
0: 			}
0: 			catch (StandardException e)
0: 			{
0: 				// the positionGetter will fail with a NullPointerException
0: 				// if the outer table is empty
0: 				// (this isn't a problem since we won't call it on the inner
0: 				// table if there are no rows on the outer table)
0: 				if (e.getSQLState() == SQLState.LANG_UNEXPECTED_USER_EXCEPTION )
0: 					return "\t" + MessageService.getTextMessage(
0: 						SQLState.LANG_POSITION_NOT_AVAIL);
0: 				return "\t" + MessageService.getTextMessage(
0: 						SQLState.LANG_UNEXPECTED_EXC_GETTING_POSITIONER,
0: 						e.toString());
0: 			}
0: 		}
0: 		if (positioner == null)
0: 		{
0: 			return "\t" +
0: 					MessageService.getTextMessage(SQLState.LANG_NONE) +
0: 					"\n";
0: 		}
0: 		String searchOp = null;
0: 
0: 		switch (searchOperator)
0: 		{
0: 			case ScanController.GE:
0: 				searchOp = ">=";
0: 				break;
0: 
0: 			case ScanController.GT:
0: 				searchOp = ">";
0: 				break;
0: 
0: 			default:
0: 				if (SanityManager.DEBUG)
0: 				{
0: 					SanityManager.THROWASSERT("Unknown search operator " +
0: 												searchOperator);
0: 				}
0: 
0: 				// NOTE: This does not have to be internationalized because
0: 				// this code should never be reached.
0: 				searchOp = "unknown value (" + searchOperator + ")";
0: 				break;
0: 		}
0: 
0: 		output = output + "\t" +
0: 						MessageService.getTextMessage(
0: 							SQLState.LANG_POSITIONER,
0: 							searchOp,
0: 							String.valueOf(positioner.nColumns())) +
0: 						"\n";
0: 
0: 		output = output + "\t" +
0: 					MessageService.getTextMessage(
0: 						SQLState.LANG_ORDERED_NULL_SEMANTICS) +
0: 					"\n";
0: 		for (int position = 0; position < positioner.nColumns(); position++)
0: 		{
0: 			if (positioner.areNullsOrdered(position))
0: 			{
0: 				output = output + position + " ";
0: 			}
0: 		}
0: 		
0: 		return output + "\n";
0: 	}
0: 
0: 	public Properties getScanProperties()
0: 	{
0: 		if (scanProperties == null)
0: 		{
0: 			scanProperties = new Properties();
0: 		}
0: 		try
0: 		{
0: 			if (scanController != null)
0: 			{
0: 				scanController.getScanInfo().getAllScanInfo(scanProperties);
0: 				/* Did we get a coarser lock due to
0: 				 * a covering lock, lock escalation
0: 				 * or configuration?
0: 				 */
0: 				coarserLock = scanController.isTableLocked() &&
0: 					(lockMode == TransactionController.MODE_RECORD);
0: 			}
0: 		}
0: 		catch(StandardException se)
0: 		{
0: 			// ignore
0: 		}
0: 
0: 		return scanProperties;
0: 	}
0: 
0: 	/**
0: 	 * @see NoPutResultSet#getScanIsolationLevel
0: 	 */
0: 	public int getScanIsolationLevel()
0: 	{
0: 		return isolationLevel;
0: 	}
0: 
0: 	/**
0: 	 * @see NoPutResultSet#requiresRelocking
0: 	 */
0: 	public boolean requiresRelocking()
0: 	{
0: 		return(
0:             isolationLevel == 
0:                 TransactionController.ISOLATION_READ_COMMITTED_NOHOLDLOCK);
0: 	}
0: 
0: 	/**
0: 	 * Update the number of rows in the scan controller.
0: 	 *
0: 	 * NOTE: It would be more efficient to only update the
0: 	 * scan controller if the optimizer's estimated number of
0: 	 * rows were wrong by more than some threshold (like 10%).
0: 	 * This would require a little more work than I have the
0: 	 * time for now, however, as the row estimate that is given
0: 	 * to this result set is the total number of rows for all
0: 	 * scans, not the number of rows per scan.
0: 	 *
0: 	 *
0: 	 * @param rowsThisScan	The number of rows to update the scanController to
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	protected final void setRowCountIfPossible(long rowsThisScan)
0: 					throws StandardException
0: 	{
0: 		/*
0: 		** Is it a heap scan with no qualifiers (full table scan?)
0: 		** and is it not for update (we don't want to count rows we're
0: 		** about to delete.
0: 		*/
0: 		if ( ( ! scanController.isKeyed() ) &&
0: 			(qualifiers == null || qualifiers.length == 0) &&
0: 			( ! forUpdate ) )
0: 		{
0: 
0: 			// Only update rows if different by more than 10%
0: 			long diff = rowsThisScan - estimatedRowCount;
0: 
0: 			long tenPerCent = estimatedRowCount  / 10;
0: 
0: 			if (diff < 0)
0: 				diff = -diff;
0: 
0: 			if (diff > tenPerCent)
0: 				scanController.setEstimatedRowCount(rowsThisScan);
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Can we get instantaneous locks when getting share row
0: 	 * locks at READ COMMITTED.
0: 	 */
0: 	protected boolean canGetInstantaneousLocks()
0: 	{
0: 		return false;
0: 	}
0: 
0: 
0: 	/**
0: 	 * Is this ResultSet or it's source result set for update
0: 	 * 
0: 	 * @return Whether or not the result set is for update.
0: 	 */
0: 	public boolean isForUpdate()
0: 	{
0: 		return forUpdate;
0: 	}
0: 
0: 	/**
0: 	 * Shallow clone this result set.  Used in trigger reference.
0: 	 * beetle 4373.
0: 	 */
0: 	public Object clone()
0: 	{
0: 		Object clo = null;
0: 		try {
0: 			clo = super.clone();
0: 		}
0: 		catch (CloneNotSupportedException e) {}
0: 		return clo;
0: 	}
0: }
============================================================================