1:69a192a: /*
2:69a192a: 
1:69a192a:    Derby - Class org.apache.derby.impl.sql.compile.RowCountNode
1:69a192a: 
1:69a192a:    Licensed to the Apache Software Foundation (ASF) under one or more
1:69a192a:    contributor license agreements.  See the NOTICE file distributed with
1:69a192a:    this work for additional information regarding copyright ownership.
1:69a192a:    The ASF licenses this file to you under the Apache License, Version 2.0
1:69a192a:    (the "License"); you may not use this file except in compliance with
1:69a192a:    the License.  You may obtain a copy of the License at
1:69a192a: 
1:69a192a:       http://www.apache.org/licenses/LICENSE-2.0
1:69a192a: 
1:69a192a:    Unless required by applicable law or agreed to in writing, software
1:69a192a:    distributed under the License is distributed on an "AS IS" BASIS,
1:69a192a:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:69a192a:    See the License for the specific language governing permissions and
1:69a192a:    limitations under the License.
1:69a192a: 
1:69a192a: */
1:69a192a: 
1:69a192a: package org.apache.derby.impl.sql.compile;
1:69a192a: 
1:69a192a: import org.apache.derby.iapi.error.StandardException;
1:69a192a: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:69a192a: import org.apache.derby.iapi.services.classfile.VMOpcode;
1:00c7a20: import org.apache.derby.iapi.reference.ClassName;
1:3bb140c: import org.apache.derby.iapi.services.context.ContextManager;
1:69a192a: 
1:69a192a: /**
1:69a192a:  * The result set generated by this node (RowCountResultSet) implements the
1:69a192a:  * filtering of rows needed for the <result offset clause> and the <fetch first
1:69a192a:  * clause>.  It sits on top of the normal SELECT's top result set, but under any
1:69a192a:  * ScrollInsensitiveResultSet. The latter's positioning is needed for the correct
1:69a192a:  * functioning of <result offset clause> and <fetch first clause> in the
1:69a192a:  * presence of scrollable and/or updatable result sets and CURRENT OF cursors.
1:69a192a:  */
1:69a192a: public final class RowCountNode extends SingleChildResultSetNode
1:69a192a: {
1:69a192a:     /**
1:69a192a:      * If not null, this represents the value of a <result offset clause>.
1:69a192a:      */
1:69a192a:     private ValueNode offset;
1:69a192a:     /**
1:69a192a:      * If not null, this represents the value of a <fetch first clause>.
1:69a192a:      */
1:69a192a:     private ValueNode fetchFirst;
1:57c1b5c:     /**
1:57c1b5c:      * True if the offset/fetchFirst clauses were added by JDBC LIMIT syntax.
1:57c1b5c:      */
1:57c1b5c:     private boolean hasJDBClimitClause;
1:69a192a: 
1:69a192a: 
1:69a192a:     /**
1:3bb140c:      * Constructor for a RowCountNode
1:69a192a:      *
1:69a192a:      * @exception StandardException
1:69a192a:      */
1:3bb140c: 
1:3bb140c:     /**
1:3bb140c:      * Constructor for a RowCountNode
1:3bb140c:      * @param childResult        The result set for which we want to get
1:3bb140c:      *                           only a subset
1:3bb140c:      * @param rcl                The result columns we want
1:3bb140c:      * @param offset             The offset, if any, in the result set
1:3bb140c:      * @param fetchFirst         The number of rows to inspect to get
1:64521e8:      * @param hasJDBClimitClause {@code true} if a JDBC limit syntax was used
1:3bb140c:      * @param cm                 The context manager
1:3bb140c:      * @throws StandardException
1:3bb140c:      */
1:3bb140c:     RowCountNode(ResultSetNode    childResult,
1:3bb140c:                  ResultColumnList rcl,
1:3bb140c:                  ValueNode        offset,
1:3bb140c:                  ValueNode        fetchFirst,
1:3bb140c:                  boolean          hasJDBClimitClause,
1:3bb140c:                  ContextManager   cm)
1:69a192a:         throws StandardException {
1:69a192a: 
1:3bb140c:         super(childResult, null, cm);
1:11f7ee3:         setResultColumns( rcl );
1:69a192a: 
1:3bb140c:         this.offset = offset;
1:3bb140c:         this.fetchFirst = fetchFirst;
1:3bb140c:         this.hasJDBClimitClause = hasJDBClimitClause;
1:69a192a:     }
1:69a192a: 
1:69a192a: 
1:69a192a:     /**
1:69a192a:      * Generate code.
1:69a192a:      *
1:69a192a:      * @param acb activation class builder
1:69a192a:      * @param mb  method builder
1:69a192a:      *
1:69a192a:      * @exception StandardException         Thrown on error
1:69a192a:      */
1:3bb140c:     @Override
1:8fe3166:     void generate(ActivationClassBuilder acb, MethodBuilder mb)
1:69a192a:             throws StandardException {
1:69a192a: 
1:69a192a:         /* Get the next ResultSet #, so that we can number this ResultSetNode,
1:69a192a:          * its ResultColumnList and ResultSet.
1:69a192a:          */
1:69a192a:         assignResultSetNumber();
1:69a192a: 
1:11f7ee3:         setCostEstimate( childResult.getFinalCostEstimate() );
1:69a192a: 
1:69a192a:         acb.pushGetResultSetFactoryExpression(mb);
1:69a192a: 
1:69a192a:         childResult.generate(acb, mb); // arg1
1:69a192a: 
1:69a192a:         acb.pushThisAsActivation(mb);  // arg2
1:11f7ee3:         mb.push(getResultSetNumber());      // arg3
1:69a192a: 
1:00c7a20:         boolean dynamicOffset = false;
1:00c7a20:         boolean dynamicFetchFirst = false;
1:69a192a: 
1:00c7a20:         // arg4
1:00c7a20:         if (offset != null) {
1:00c7a20:             generateExprFun(acb, mb, offset);
1:00c7a20:         } else {
1:00c7a20:             mb.pushNull(ClassName.GeneratedMethod);
1:00c7a20:         }
1:69a192a: 
1:00c7a20:         // arg5
1:00c7a20:         if (fetchFirst != null) {
1:00c7a20:             generateExprFun(acb, mb, fetchFirst);
1:00c7a20:         } else {
1:00c7a20:             mb.pushNull(ClassName.GeneratedMethod);
1:00c7a20:         }
1:69a192a: 
1:57c1b5c:         mb.push( hasJDBClimitClause );  // arg6
1:57c1b5c: 
1:11f7ee3:         mb.push(getCostEstimate().rowCount()); // arg7
1:11f7ee3:         mb.push(getCostEstimate().getEstimatedCost()); // arg8
1:69a192a: 
1:69a192a:         mb.callMethod(VMOpcode.INVOKEINTERFACE,
1:69a192a:                       (String) null,
1:69a192a:                       "getRowCountResultSet",
1:69a192a:                       ClassName.NoPutResultSet,
1:57c1b5c:                       8);
1:69a192a:     }
1:69a192a: 
1:69a192a: 
1:00c7a20:     private void generateExprFun(
1:00c7a20:         ExpressionClassBuilder ecb,
1:00c7a20:         MethodBuilder mb,
1:00c7a20:         ValueNode vn) throws StandardException {
1:00c7a20: 
1:00c7a20:         // Generates:
1:00c7a20:         //     Object exprFun { }
1:00c7a20:         MethodBuilder exprFun = ecb.newExprFun();
1:00c7a20: 
1:00c7a20:         /* generates:
1:00c7a20:          *    return  <dynamic parameter.generate(ecb)>;
1:00c7a20:          * and adds it to exprFun
1:00c7a20:          */
1:00c7a20:         vn.generateExpression(ecb, exprFun);
1:00c7a20:         exprFun.methodReturn();
1:00c7a20: 
1:00c7a20:         // we are done modifying exprFun, complete it.
1:00c7a20:         exprFun.complete();
1:00c7a20: 
1:00c7a20:         // Pass in the method that will be used to evaluates the dynamic
1:00c7a20:         // parameter in RowCountResultSet.
1:00c7a20:         ecb.pushMethodReference(mb, exprFun);
1:00c7a20:     }
1:00c7a20: 
1:00c7a20: 
1:69a192a:     /**
1:69a192a:      * Convert this object to a String.  See comments in QueryTreeNode.java
1:69a192a:      * for how this should be done for tree printing.
1:69a192a:      *
1:69a192a:      * @return  This object as a String
1:69a192a:      */
1:3bb140c:     @Override
1:69a192a:     public String toString() {
1:69a192a:         if (SanityManager.DEBUG) {
1:69a192a:             return "offset: " + offset + "\n" +
1:69a192a:                 "fetchFirst:" + fetchFirst + "\n" +
1:69a192a:                 super.toString();
1:69a192a:         } else {
1:69a192a:             return "";
1:69a192a:         }
1:69a192a:     }
1:69a192a: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:11f7ee3
/////////////////////////////////////////////////////////////////////////
1:         setResultColumns( rcl );
/////////////////////////////////////////////////////////////////////////
1:         setCostEstimate( childResult.getFinalCostEstimate() );
1:         mb.push(getResultSetNumber());      // arg3
/////////////////////////////////////////////////////////////////////////
1:         mb.push(getCostEstimate().rowCount()); // arg7
1:         mb.push(getCostEstimate().getEstimatedCost()); // arg8
commit:57c1b5c
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * True if the offset/fetchFirst clauses were added by JDBC LIMIT syntax.
1:      */
1:     private boolean hasJDBClimitClause;
/////////////////////////////////////////////////////////////////////////
0:                      Object fetchFirst,
0:                      Object hasJDBClimitClause)
/////////////////////////////////////////////////////////////////////////
0:         this.hasJDBClimitClause = (hasJDBClimitClause == null) ? false : ((Boolean) hasJDBClimitClause).booleanValue();
/////////////////////////////////////////////////////////////////////////
1:         mb.push( hasJDBClimitClause );  // arg6
1: 
0:         mb.push(costEstimate.rowCount()); // arg7
0:         mb.push(costEstimate.getEstimatedCost()); // arg8
1:                       8);
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:2706d1f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.context.ContextManager;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
/////////////////////////////////////////////////////////////////////////
1:      * Constructor for a RowCountNode
1: 
1:     /**
1:      * Constructor for a RowCountNode
1:      * @param childResult        The result set for which we want to get
1:      *                           only a subset
1:      * @param rcl                The result columns we want
1:      * @param offset             The offset, if any, in the result set
1:      * @param fetchFirst         The number of rows to inspect to get
0:      * @param hasJDBClimitClause {@true} if a JDBC limit syntax was used
1:      * @param cm                 The context manager
1:      * @throws StandardException
1:      */
1:     RowCountNode(ResultSetNode    childResult,
1:                  ResultColumnList rcl,
1:                  ValueNode        offset,
1:                  ValueNode        fetchFirst,
1:                  boolean          hasJDBClimitClause,
1:                  ContextManager   cm)
1:         super(childResult, null, cm);
0:         setNodeType(C_NodeTypes.ROW_COUNT_NODE);
0:         resultColumns = rcl;
1:         this.offset = offset;
1:         this.fetchFirst = fetchFirst;
1:         this.hasJDBClimitClause = hasJDBClimitClause;
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
commit:00c7a20
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.types.SQLLongint;
1: import org.apache.derby.iapi.reference.ClassName;
/////////////////////////////////////////////////////////////////////////
1:         boolean dynamicOffset = false;
1:         boolean dynamicFetchFirst = false;
1:         // arg4
1:         if (offset != null) {
1:             generateExprFun(acb, mb, offset);
1:         } else {
1:             mb.pushNull(ClassName.GeneratedMethod);
1:         }
1:         // arg5
1:         if (fetchFirst != null) {
1:             generateExprFun(acb, mb, fetchFirst);
1:         } else {
1:             mb.pushNull(ClassName.GeneratedMethod);
1:         }
/////////////////////////////////////////////////////////////////////////
1:     private void generateExprFun(
1:         ExpressionClassBuilder ecb,
1:         MethodBuilder mb,
1:         ValueNode vn) throws StandardException {
1: 
1:         // Generates:
1:         //     Object exprFun { }
1:         MethodBuilder exprFun = ecb.newExprFun();
1: 
1:         /* generates:
1:          *    return  <dynamic parameter.generate(ecb)>;
1:          * and adds it to exprFun
1:          */
1:         vn.generateExpression(ecb, exprFun);
1:         exprFun.methodReturn();
1: 
1:         // we are done modifying exprFun, complete it.
1:         exprFun.complete();
1: 
1:         // Pass in the method that will be used to evaluates the dynamic
1:         // parameter in RowCountResultSet.
1:         ecb.pushMethodReference(mb, exprFun);
1:     }
1: 
1: 
commit:69a192a
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derby.impl.sql.compile.RowCountNode
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1: */
1: 
1: package org.apache.derby.impl.sql.compile;
1: 
0: import java.util.Vector;
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.services.compiler.MethodBuilder;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.reference.ClassName;
1: import org.apache.derby.iapi.services.classfile.VMOpcode;
1: 
1: /**
1:  * The result set generated by this node (RowCountResultSet) implements the
1:  * filtering of rows needed for the <result offset clause> and the <fetch first
1:  * clause>.  It sits on top of the normal SELECT's top result set, but under any
1:  * ScrollInsensitiveResultSet. The latter's positioning is needed for the correct
1:  * functioning of <result offset clause> and <fetch first clause> in the
1:  * presence of scrollable and/or updatable result sets and CURRENT OF cursors.
1:  */
1: public final class RowCountNode extends SingleChildResultSetNode
1: {
1:     /**
1:      * If not null, this represents the value of a <result offset clause>.
1:      */
1:     private ValueNode offset;
1:     /**
1:      * If not null, this represents the value of a <fetch first clause>.
1:      */
1:     private ValueNode fetchFirst;
1: 
1: 
1:     /**
0:      * Initializer for a RowCountNode
1:      *
1:      * @exception StandardException
1:      */
0:     public void init(Object childResult,
0:                      Object rcl,
0:                      Object offset,
0:                      Object fetchFirst)
1:         throws StandardException {
1: 
0:         init(childResult, null);
0:         resultColumns = (ResultColumnList) rcl;
1: 
0:         this.offset = (ValueNode)offset;
0:         this.fetchFirst = (ValueNode)fetchFirst;
1:     }
1: 
1: 
1:     /**
1:      * Generate code.
1:      *
1:      * @param acb activation class builder
1:      * @param mb  method builder
1:      *
1:      * @exception StandardException         Thrown on error
1:      */
0:     public void generate(ActivationClassBuilder acb,
0:                          MethodBuilder mb)
1:             throws StandardException {
1: 
1:         /* Get the next ResultSet #, so that we can number this ResultSetNode,
1:          * its ResultColumnList and ResultSet.
1:          */
1:         assignResultSetNumber();
1: 
0:         costEstimate = childResult.getFinalCostEstimate();
1: 
1:         acb.pushGetResultSetFactoryExpression(mb);
1: 
1:         childResult.generate(acb, mb); // arg1
1: 
1:         acb.pushThisAsActivation(mb);  // arg2
0:         mb.push(resultSetNumber);      // arg3
1: 
1: 
0:         // If OFFSET is not given, we pass in the default, i.e 0.
0:         long offsetVal =
0:             (offset != null) ?
0:             ((ConstantNode)offset).getValue().getLong() : 0;
1: 
0:         // If FETCH FIRST is not given, we pass in -1 to RowCountResultSet.
0:         long fetchFirstVal =
0:             (fetchFirst != null) ?
0:             ((ConstantNode)fetchFirst).getValue().getLong() : -1;
1: 
0:         mb.push(offsetVal);            // arg4
0:         mb.push(fetchFirstVal);        // arg5
0:         mb.push(costEstimate.rowCount()); // arg6
0:         mb.push(costEstimate.getEstimatedCost()); // arg7
1: 
1:         mb.callMethod(VMOpcode.INVOKEINTERFACE,
1:                       (String) null,
1:                       "getRowCountResultSet",
1:                       ClassName.NoPutResultSet,
0:                       7);
1:     }
1: 
1: 
1:     /**
1:      * Convert this object to a String.  See comments in QueryTreeNode.java
1:      * for how this should be done for tree printing.
1:      *
1:      * @return  This object as a String
1:      */
1: 
1:     public String toString() {
1:         if (SanityManager.DEBUG) {
1:             return "offset: " + offset + "\n" +
1:                 "fetchFirst:" + fetchFirst + "\n" +
1:                 super.toString();
1:         } else {
1:             return "";
1:         }
1:     }
1: }
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:64521e8
/////////////////////////////////////////////////////////////////////////
1:      * @param hasJDBClimitClause {@code true} if a JDBC limit syntax was used
commit:8fe3166
/////////////////////////////////////////////////////////////////////////
1:     void generate(ActivationClassBuilder acb, MethodBuilder mb)
commit:47d4a4c
/////////////////////////////////////////////////////////////////////////
============================================================================