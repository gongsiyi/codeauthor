1:28c4dc4: /*
1:28c4dc4: 
1:28c4dc4:    org.apache.derby.optional.dump.RawDBReader
1:28c4dc4: 
1:28c4dc4:    Licensed to the Apache Software Foundation (ASF) under one or more
1:28c4dc4:    contributor license agreements.  See the NOTICE file distributed with
1:28c4dc4:    this work for additional information regarding copyright ownership.
1:28c4dc4:    The ASF licenses this file to You under the Apache License, Version 2.0
1:28c4dc4:    (the "License"); you may not use this file except in compliance with
1:28c4dc4:    the License.  You may obtain a copy of the License at
1:28c4dc4: 
1:28c4dc4:       http://www.apache.org/licenses/LICENSE-2.0
1:28c4dc4: 
1:28c4dc4:    Unless required by applicable law or agreed to in writing, software
1:28c4dc4:    distributed under the License is distributed on an "AS IS" BASIS,
1:28c4dc4:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:28c4dc4:    See the License for the specific language governing permissions and
1:28c4dc4:    limitations under the License.
1:28c4dc4: 
1:28c4dc4:  */
1:28c4dc4: 
1:28c4dc4: package org.apache.derby.optional.dump;
1:28c4dc4: 
1:28c4dc4: import java.io.File;
1:28c4dc4: import java.io.IOException;
1:28c4dc4: import java.io.PrintWriter;
1:28c4dc4: import java.sql.Connection;
1:28c4dc4: import java.sql.DatabaseMetaData;
1:28c4dc4: import java.sql.DriverManager;
1:28c4dc4: import java.sql.PreparedStatement;
1:28c4dc4: import java.sql.ResultSet;
1:28c4dc4: import java.sql.SQLException;
1:28c4dc4: import java.util.ArrayList;
1:28c4dc4: 
1:28c4dc4: import org.apache.derby.catalog.TypeDescriptor;
1:28c4dc4: import org.apache.derby.iapi.sql.dictionary.OptionalTool;
1:28c4dc4: import org.apache.derby.iapi.util.IdUtil;
1:28c4dc4: import org.apache.derby.iapi.util.StringUtil;
1:28c4dc4: import org.apache.derby.impl.jdbc.EmbedConnection;
1:28c4dc4: import org.apache.derby.tools.dblook;
1:28c4dc4: 
1:28c4dc4: /**
1:28c4dc4:  * <p>
1:28c4dc4:  * OptionalTool to create wrapper functions and views for all of the user heap conglomerates
1:5e33d79:  * in the seg0 subdirectory of a corrupt database.
1:28c4dc4:  * </p>
1:28c4dc4:  */
1:28c4dc4: public	class   RawDBReader  implements OptionalTool
1:28c4dc4: {
1:28c4dc4:     ////////////////////////////////////////////////////////////////////////
1:28c4dc4:     //
1:28c4dc4:     //	CONSTANTS
1:28c4dc4:     //
1:28c4dc4:     ////////////////////////////////////////////////////////////////////////
1:28c4dc4: 
1:28c4dc4:     ////////////////////////////////////////////////////////////////////////
1:28c4dc4:     //
1:28c4dc4:     //	STATE
1:28c4dc4:     //
1:28c4dc4:     ////////////////////////////////////////////////////////////////////////
1:28c4dc4: 
1:28c4dc4:     ////////////////////////////////////////////////////////////////////////
1:28c4dc4:     //
1:28c4dc4:     //	CONSTRUCTOR
1:28c4dc4:     //
1:28c4dc4:     ////////////////////////////////////////////////////////////////////////
1:28c4dc4: 
1:28c4dc4:     /** 0-arg constructor required by the OptionalTool contract */
1:28c4dc4:     public  RawDBReader() {}
1:28c4dc4: 
1:28c4dc4:     ///////////////////////////////////////////////////////////////////////////////////
1:28c4dc4:     //
1:28c4dc4:     // OptionalTool BEHAVIOR
1:28c4dc4:     //
1:28c4dc4:     ///////////////////////////////////////////////////////////////////////////////////
1:28c4dc4: 
1:28c4dc4:     /**
1:28c4dc4:      * <p>
1:5e33d79:      * Creates the following schema objects in a healthy database in order
1:5e33d79:      * to siphon data out of a corrupt database:
1:28c4dc4:      * </p>
1:28c4dc4:      *
1:28c4dc4:      * <ul>
1:28c4dc4:      * <li>A control schema containing views on SYSSCHEMAS, SYSCONGLOMERATES, SYSTABLES
1:5e33d79:      * and SYSCOLUMNS in the corrupt database.</li>
1:5e33d79:      * <li>A schema for every user schema in the corrupt database.</li>
1:5e33d79:      * <li>Table functions and views on every user table in the corrupt database.</li>
1:28c4dc4:      * </ul>
1:28c4dc4:      *
1:28c4dc4:      * <p>
1:5e33d79:      * In addition, the tool creates a script for siphoning data out of the corrupt
1:28c4dc4:      * database.
1:28c4dc4:      * </p>
1:28c4dc4:      *
1:28c4dc4:      * <p>
1:28c4dc4:      * Takes the following arguments:
1:28c4dc4:      * </p>
1:28c4dc4:      *
1:28c4dc4:      * <ul>
1:28c4dc4:      * <li>recoveryScript (required) - Name of the recovery script file which
1:28c4dc4:      * the tool will write.</li>
1:28c4dc4:      * <li>controlSchema (required) - Name of a schema in which control objects will be
1:5e33d79:      * created. These include the views on the corrupt database's SYSSCHEMAS, SYSCONGLOMERATES,
1:28c4dc4:      * SYSTABLES, and SYSCOLUMNS catalogs. May not be null or an empty string.</li>
1:28c4dc4:      * <li>schemaPrefix (required) - This prefix is prepended
1:5e33d79:      * to the names of the schemas which are created in the healthy database.
1:5e33d79:      * May not be null or empty.</li>
1:5e33d79:      * <li>corruptDBLocation (required) - Absolute path to the corrupt database directory.
1:28c4dc4:      * That is the directory which contains service.properties. May not be null or empty.</li>
1:5e33d79:      * <li>encryptionAttributes (required) - Encryption attributes which were
1:5e33d79:      * used to connect to the corrupt database when it was bootable. May be null
1:28c4dc4:      * if encryption is not being used.</li>
1:5e33d79:      * <li>dbo (required) - User name of the owner of the corrupt database. May be null
1:28c4dc4:      * if authentication is not being used.</li>
1:5e33d79:      * <li>dboPassword (required) - Password for the owner of the corrupt database. May be null
1:28c4dc4:      * if authentication is not being used.</li>
1:28c4dc4:      * </ul>
1:28c4dc4:      */
1:28c4dc4:     public  void    loadTool( String... configurationParameters )
1:28c4dc4:         throws SQLException
1:28c4dc4:     {
1:28c4dc4:         if ( (configurationParameters == null) || (configurationParameters.length < 7) )
1:28c4dc4:         { throw badArgs( "Wrong number of arguments." ); }
1:28c4dc4: 
1:28c4dc4:         int     idx = 0;
1:28c4dc4:         String  recoveryScript = configurationParameters[ idx++ ];
1:28c4dc4:         String  controlSchema = configurationParameters[ idx++ ];
1:28c4dc4:         String  schemaPrefix = configurationParameters[ idx++ ];
1:5e33d79:         String  corruptDBLocation = configurationParameters[ idx++ ];
1:28c4dc4:         String  encryptionAttributes = configurationParameters[ idx++ ];
1:28c4dc4:         String  dbo = configurationParameters[ idx++ ];
1:28c4dc4:         String  dboPassword = configurationParameters[ idx++ ];
1:28c4dc4:         
1:5e33d79:         if ( nullOrEmpty( recoveryScript) )
1:5e33d79:         { throw badArgs( "Null or empty recovery script argument." ); }
1:5e33d79:         if ( nullOrEmpty( controlSchema) )
1:5e33d79:         { throw badArgs( "Null or empty control schema argument." ); }
1:5e33d79:         if ( nullOrEmpty( schemaPrefix ) )
1:5e33d79:         { throw badArgs( "Null or empty schema prefix argument." ); }
1:5e33d79:         if ( nullOrEmpty( corruptDBLocation ) )
1:5e33d79:         { throw badArgs( "Null or empty database location argument." ); }
1:5e33d79:         if ( nullOrEmpty( dbo)  )
1:5e33d79:         { throw badArgs( "Null or empty database owner argument." ); }
1:28c4dc4: 
1:28c4dc4:         Connection  conn = getDerbyConnection();
1:28c4dc4: 
1:5e33d79:         createControlSchema( conn, controlSchema, corruptDBLocation,
1:5e33d79:                              encryptionAttributes, dbo, dboPassword );
1:5e33d79:         createUserSchemas( conn, controlSchema, schemaPrefix, corruptDBLocation,
1:5e33d79:                            encryptionAttributes, dbo, dboPassword );
1:5e33d79:         createViews( conn, recoveryScript, controlSchema, schemaPrefix, corruptDBLocation,
1:5e33d79:                      encryptionAttributes, dbo, dboPassword );
1:28c4dc4:     }
1:28c4dc4: 
1:28c4dc4:     /** Returns true if the text is null or empty */
1:28c4dc4:     private boolean nullOrEmpty( String text ) { return ( (text == null) || (text.length() == 0) ); }
1:28c4dc4: 
1:28c4dc4:     /**
1:28c4dc4:      * <p>
1:28c4dc4:      * Removes the schemas, table functions, and views created by loadTool().
1:28c4dc4:      * </p>
1:28c4dc4:      *
1:28c4dc4:      * <p>
1:28c4dc4:      * Takes the following arguments:
1:28c4dc4:      * </p>
1:28c4dc4:      *
1:28c4dc4:      * <ul>
1:5e33d79:      * <li>controlSchema (required) - Name of the schema in which loadTool() created control objects
1:5e33d79:      * in the healthy database. May not be null or an empty string.</li>
1:28c4dc4:      * <li>schemaPrefix (required) - This is the prefix which was prepended
1:5e33d79:      * to the names of the schemas which loadTool() created in the healthy
1:5e33d79:      * database. May not be null or empty.</li>
1:28c4dc4:      * </ul>
1:28c4dc4:      */
1:28c4dc4:     public  void    unloadTool( String... configurationParameters )
1:28c4dc4:         throws SQLException
1:28c4dc4:     {
1:28c4dc4:         if ( (configurationParameters == null) || (configurationParameters.length < 2) )
1:28c4dc4:         { throw badArgs( "Wrong number of arguments." ); }
1:28c4dc4:         
1:28c4dc4:         int     idx = 0;
1:28c4dc4:         String  controlSchema = configurationParameters[ idx++ ];
1:28c4dc4:         String  schemaPrefix = configurationParameters[ idx++ ];
1:28c4dc4: 
1:5e33d79:         if ( nullOrEmpty( controlSchema) )
1:5e33d79:         { throw badArgs( "Null or empty control schema argument." ); }
1:5e33d79:         if ( nullOrEmpty( schemaPrefix ) )
1:5e33d79:         { throw badArgs( "Null or empty schema prefix argument." ); }
1:28c4dc4: 
1:28c4dc4:         Connection  conn = getDerbyConnection();
1:28c4dc4: 
1:28c4dc4:         dropViews( conn, schemaPrefix );
1:28c4dc4:         dropUserSchemas( conn, schemaPrefix );
1:28c4dc4:         dropControlSchema( conn, controlSchema );
1:28c4dc4:     }
1:28c4dc4:     /** Return a "bad args" exception */
1:28c4dc4:     private SQLException    badArgs( String message )
1:28c4dc4:     {
1:28c4dc4:         return new SQLException( message );
1:28c4dc4:     }
1:28c4dc4:     
1:28c4dc4: 
1:28c4dc4:     ////////////////////////////////////////////////////////////////////////
1:28c4dc4:     //
1:28c4dc4:     //	LOADING MINIONS
1:28c4dc4:     //
1:28c4dc4:     ////////////////////////////////////////////////////////////////////////
1:28c4dc4: 
1:28c4dc4:     /**
1:28c4dc4:      * Create and populate the schema which holds control objects.
1:28c4dc4:      */
1:28c4dc4:     private void    createControlSchema
1:28c4dc4:         (
1:28c4dc4:          Connection conn,
1:28c4dc4:          String controlSchema,
1:5e33d79:          String corruptDBLocation,
1:28c4dc4:          String encryptionAttributes,
1:28c4dc4:          String dbo,
1:28c4dc4:          String dboPassword
1:28c4dc4:          )
1:28c4dc4:         throws SQLException
1:28c4dc4:     {
1:28c4dc4:         // create the schema and move into it
1:28c4dc4:         executeDDL( conn, "create schema " + controlSchema );
1:28c4dc4:         executeDDL( conn, "set schema " + controlSchema );
1:28c4dc4: 
1:28c4dc4:         // create a generic UDT for use with all object types
1:28c4dc4:         executeDDL( conn, "create type serializable external name 'java.io.Serializable' language java" );
1:28c4dc4: 
1:28c4dc4:         // create table functions and views on core catalogs
1:28c4dc4:         createTable
1:28c4dc4:             (
1:28c4dc4:              conn,
1:28c4dc4:              controlSchema,
1:28c4dc4:              "SYSCONGLOMERATES", 
1:28c4dc4:              "( schemaid char(36), tableid char(36), conglomeratenumber bigint, conglomeratename varchar( 128), isindex boolean, descriptor serializable, isconstant boolean, conglomerateid char( 36 ) )",
1:28c4dc4:              "c20.dat",
1:5e33d79:              corruptDBLocation,
1:28c4dc4:              encryptionAttributes,
1:28c4dc4:              dbo,
1:28c4dc4:              dboPassword
1:28c4dc4:              );
1:28c4dc4:         createTable
1:28c4dc4:             (
1:28c4dc4:              conn,
1:28c4dc4:              controlSchema,
1:28c4dc4:              "SYSCOLUMNS", 
1:28c4dc4:              "( referenceid char(36), columnname varchar(128), columnnumber int, columndatatype serializable, columndefault serializable, columndefaultid char(36), autoincrementvalue bigint, autoincrementstart bigint, autoincrementinc bigint )",
1:28c4dc4:              "c90.dat",
1:5e33d79:              corruptDBLocation,
1:28c4dc4:              encryptionAttributes,
1:28c4dc4:              dbo,
1:28c4dc4:              dboPassword
1:28c4dc4:              );
1:28c4dc4:         createTable
1:28c4dc4:             (
1:28c4dc4:              conn,
1:28c4dc4:              controlSchema,
1:28c4dc4:              "SYSSCHEMAS", 
1:28c4dc4:              DataFileVTI.SYSSCHEMAS_SIGNATURE,
1:28c4dc4:              DataFileVTI.SYSSCHEMAS_CONGLOMERATE_NAME,
1:5e33d79:              corruptDBLocation,
1:28c4dc4:              encryptionAttributes,
1:28c4dc4:              dbo,
1:28c4dc4:              dboPassword
1:28c4dc4:              );
1:28c4dc4:         createTable
1:28c4dc4:             (
1:28c4dc4:              conn,
1:28c4dc4:              controlSchema,
1:28c4dc4:              "SYSTABLES", 
1:28c4dc4:              DataFileVTI.SYSTABLES_SIGNATURE,
1:28c4dc4:              DataFileVTI.SYSTABLES_CONGLOMERATE_NAME,
1:5e33d79:              corruptDBLocation,
1:28c4dc4:              encryptionAttributes,
1:28c4dc4:              dbo,
1:28c4dc4:              dboPassword
1:28c4dc4:              );
1:28c4dc4:     }
1:28c4dc4: 
1:28c4dc4:     /**
1:5e33d79:      * Create a table function and view for a corrupt database table.
1:28c4dc4:      */
1:28c4dc4:     private void    createTable
1:28c4dc4:         (
1:28c4dc4:          Connection conn,
1:28c4dc4:          String schema,
1:28c4dc4:          String tableName,
1:28c4dc4:          String tableSignature,
1:28c4dc4:          String heapFileName,
1:5e33d79:          String corruptDBLocation,
1:28c4dc4:          String encryptionAttributes,
1:28c4dc4:          String dbo,
1:28c4dc4:          String dboPassword
1:28c4dc4:          )
1:28c4dc4:         throws SQLException
1:28c4dc4:     {
1:28c4dc4:         String  qualifiedName = schema + "." + tableName;
1:28c4dc4:         String  dataFileVTIClassName = DataFileVTI.class.getName();
1:28c4dc4:         
1:28c4dc4:         executeDDL
1:28c4dc4:             (
1:28c4dc4:              conn,
1:28c4dc4:             "create function " + qualifiedName + "\n" +
1:28c4dc4:             "(\n" +
1:28c4dc4:             "    databaseDirectoryName varchar( 32672 ),\n" +
1:28c4dc4:             "    dataFileName varchar( 32672 ),\n" +
1:28c4dc4:             "    tableSignature varchar( 32672 ),\n" +
1:28c4dc4:             "    encryptionAttributes varchar( 32672 ),\n" +
1:28c4dc4:             "    userName varchar( 32672 ),\n" +
1:28c4dc4:             "    password varchar( 32672 )\n" +
1:28c4dc4:             ")\n" +
1:28c4dc4:             "returns table\n" + tableSignature +
1:28c4dc4:             "language java\n" +
1:28c4dc4:             "parameter style derby_jdbc_result_set\n" +
1:28c4dc4:             "no sql\n" +
1:28c4dc4:             "external name '" + dataFileVTIClassName + ".dataFileVTI'\n"
1:28c4dc4:             );
1:28c4dc4:         executeDDL
1:28c4dc4:             (
1:28c4dc4:              conn,
1:28c4dc4:              "create view " + qualifiedName + "\n" +
1:28c4dc4:              "as select * from table\n" +
1:28c4dc4:              "(\n" +
1:28c4dc4:              "    " + qualifiedName + "\n" +
1:28c4dc4:              "    (\n" +
1:5e33d79:              "        '" + corruptDBLocation + "',\n" +
1:28c4dc4:              "        '" + heapFileName + "',\n" +
1:28c4dc4:              "        '" + tableSignature + "',\n" +
1:28c4dc4:              "        " + singleQuote( encryptionAttributes ) + ",\n" +
1:28c4dc4:              "        " + singleQuote( dbo ) + ",\n" +
1:28c4dc4:              "        " + singleQuote( dboPassword ) + "\n" +
1:28c4dc4:              "    )\n" +
1:28c4dc4:              ") t\n"
1:28c4dc4:              );
1:28c4dc4:     }
1:28c4dc4: 
1:28c4dc4:     /**
1:28c4dc4:      * Create user schemas.
1:28c4dc4:      */
1:28c4dc4:     private void    createUserSchemas
1:28c4dc4:         (
1:28c4dc4:          Connection conn,
1:28c4dc4:          String controlSchema,
1:28c4dc4:          String schemaPrefix,
1:5e33d79:          String corruptDBLocation,
1:28c4dc4:          String encryptionAttributes,
1:28c4dc4:          String dbo,
1:28c4dc4:          String dboPassword
1:28c4dc4:          )
1:28c4dc4:         throws SQLException
1:28c4dc4:     {
1:28c4dc4:         PreparedStatement   ps = prepareStatement
1:28c4dc4:             (
1:28c4dc4:              conn,
1:28c4dc4:              "select schemaName\n" +
1:28c4dc4:              "from "+ controlSchema + ".sysschemas\n" +
1:28c4dc4:              "where schemaName not like 'SYS%' and schemaName != 'NULLID' and schemaName != 'SQLJ'\n"
1:28c4dc4:              );
1:28c4dc4:         ResultSet   rs = ps.executeQuery();
1:28c4dc4: 
1:28c4dc4:         while ( rs.next() )
1:28c4dc4:         {
1:28c4dc4:             String  schemaName = makeSchemaName( schemaPrefix , rs.getString( 1 ) );
1:28c4dc4: 
1:28c4dc4:             executeDDL( conn, "create schema " + schemaName );
1:28c4dc4:         }
1:28c4dc4: 
1:28c4dc4:         rs.close();
1:28c4dc4:         ps.close();
1:28c4dc4:     }
1:5e33d79:     /** Make the name of a local schema from a prefix and the name of a corrupt schema */
1:5e33d79:     private String  makeSchemaName( String schemaPrefix, String corruptName )
1:28c4dc4:     {
1:5e33d79:         return IdUtil.normalToDelimited( schemaPrefix + corruptName );
1:28c4dc4:     }
1:28c4dc4:     
1:28c4dc4:     /**
1:5e33d79:      * Create table functions and views on corrupt user tables. These objects
1:5e33d79:      * are created in the healthy database. Write the recovery
1:28c4dc4:      * script.
1:28c4dc4:      */
1:28c4dc4:     private void    createViews
1:28c4dc4:         (
1:28c4dc4:          Connection conn,
1:28c4dc4:          String recoveryScriptName,
1:28c4dc4:          String controlSchema,
1:28c4dc4:          String schemaPrefix,
1:5e33d79:          String corruptDBLocation,
1:28c4dc4:          String encryptionAttributes,
1:28c4dc4:          String dbo,
1:28c4dc4:          String dboPassword
1:28c4dc4:          )
1:28c4dc4:         throws SQLException
1:28c4dc4:     {
1:28c4dc4:         File                recoveryScript = new File( recoveryScriptName );
1:28c4dc4:         PrintWriter         scriptWriter = null;
1:28c4dc4:         try {
1:28c4dc4:             scriptWriter = new PrintWriter( recoveryScript );
1:28c4dc4:         }
1:28c4dc4:         catch (Exception e) { throw wrap( e ); }
1:28c4dc4: 
1:28c4dc4:         String              localDBName = ((EmbedConnection) conn).getDBName();
1:28c4dc4:         scriptWriter.println( "connect 'jdbc:derby:" + localDBName + "';\n" );
1:28c4dc4:         
1:28c4dc4:         PreparedStatement   ps = prepareStatement
1:28c4dc4:             (
1:28c4dc4:              conn,
1:28c4dc4:              "select s.schemaName, t.tableName, g.conglomerateNumber, c.columnName, c.columnNumber, c.columnDatatype\n" +
1:28c4dc4:              "from " + controlSchema + ".sysschemas s,\n" +
1:28c4dc4:              controlSchema + ".systables t,\n" +
1:28c4dc4:              controlSchema + ".sysconglomerates g,\n" +
1:28c4dc4:              controlSchema + ".syscolumns c\n" +
1:28c4dc4:              "where s.schemaName not like 'SYS%' and schemaName != 'NULLID' and schemaName != 'SQLJ'\n" +
1:28c4dc4:              "and s.schemaID = t.schemaID\n" +
1:28c4dc4:              "and t.tableID = g.tableID and not g.isindex\n" +
1:28c4dc4:              "and t.tableID = c.referenceID\n" +
1:28c4dc4:              "order by s.schemaName, t.tableName, c.columnNumber"
1:28c4dc4:              );
1:28c4dc4:         ResultSet   rs = ps.executeQuery();
1:28c4dc4: 
1:28c4dc4:         ArrayList<String>   columnNames = new ArrayList<String>();
1:28c4dc4:         ArrayList<TypeDescriptor>   columnTypes = new ArrayList<TypeDescriptor>();
1:5e33d79:         String  corruptSchemaName = null;
1:5e33d79:         String  corruptTableName = null;
1:28c4dc4:         String  schemaName = null;
1:28c4dc4:         String  tableName = null;
1:28c4dc4:         long    conglomerateNumber = -1L;
1:28c4dc4:         while ( rs.next() )
1:28c4dc4:         {
1:28c4dc4:             int     col = 1;
1:5e33d79:             String  currentCorruptSchemaName = rs.getString( col++ );
1:5e33d79:             String  currentCorruptTableName = rs.getString( col++ );
1:28c4dc4: 
1:5e33d79:             if ( !currentCorruptSchemaName.equals( corruptSchemaName ) )
1:28c4dc4:             {
1:28c4dc4:                 scriptWriter.println
1:5e33d79:                     ( "create schema " + IdUtil.normalToDelimited( currentCorruptSchemaName ) + ";\n" );
1:28c4dc4:             }            
1:28c4dc4:                 
1:5e33d79:             String  newSchemaName = makeSchemaName( schemaPrefix, currentCorruptSchemaName );
1:5e33d79:             String  newTableName = IdUtil.normalToDelimited( currentCorruptTableName );
1:28c4dc4: 
1:28c4dc4:             if ( schemaName != null )
1:28c4dc4:             {
1:28c4dc4:                 if ( !schemaName.equals( newSchemaName ) || !tableName.equals( newTableName ) )
1:28c4dc4:                 {
1:28c4dc4:                     createView
1:28c4dc4:                         (
1:28c4dc4:                          conn,
1:28c4dc4:                          scriptWriter,
1:28c4dc4:                          controlSchema,
1:5e33d79:                          corruptSchemaName,
1:5e33d79:                          corruptTableName,
1:28c4dc4:                          schemaName,
1:28c4dc4:                          tableName,
1:28c4dc4:                          conglomerateNumber,
1:28c4dc4:                          columnNames,
1:28c4dc4:                          columnTypes,
1:5e33d79:                          corruptDBLocation,
1:28c4dc4:                          encryptionAttributes,
1:28c4dc4:                          dbo,
1:28c4dc4:                          dboPassword
1:28c4dc4:                          );
1:28c4dc4:                     columnNames.clear();
1:28c4dc4:                     columnTypes.clear();
1:28c4dc4:                 }
1:28c4dc4:             }
1:28c4dc4: 
1:5e33d79:             corruptSchemaName = currentCorruptSchemaName;
1:5e33d79:             corruptTableName = currentCorruptTableName;
1:28c4dc4:             schemaName = newSchemaName;
1:28c4dc4:             tableName = newTableName;
1:28c4dc4:             conglomerateNumber = rs.getLong( col++ );
1:28c4dc4:             columnNames.add( normalizeColumnName( rs.getString( col++ ) ) );
1:28c4dc4:             col++;  // only need the column number to order the results
1:28c4dc4:             columnTypes.add( (TypeDescriptor) rs.getObject( col++ ) );
1:28c4dc4:         }
1:28c4dc4: 
1:28c4dc4:         // create last view
1:28c4dc4:         if ( schemaName != null )
1:28c4dc4:         {
1:28c4dc4:             createView
1:28c4dc4:                 (
1:28c4dc4:                  conn,
1:28c4dc4:                  scriptWriter,
1:28c4dc4:                  controlSchema,
1:5e33d79:                  corruptSchemaName,
1:5e33d79:                  corruptTableName,
1:28c4dc4:                  schemaName,
1:28c4dc4:                  tableName,
1:28c4dc4:                  conglomerateNumber,
1:28c4dc4:                  columnNames,
1:28c4dc4:                  columnTypes,
1:5e33d79:                  corruptDBLocation,
1:28c4dc4:                  encryptionAttributes,
1:28c4dc4:                  dbo,
1:28c4dc4:                  dboPassword
1:28c4dc4:                  );
1:28c4dc4:         }
1:28c4dc4: 
1:28c4dc4:         rs.close();
1:28c4dc4:         ps.close();
1:28c4dc4:         scriptWriter.flush();
1:28c4dc4:         scriptWriter.close();
1:28c4dc4:     }
1:28c4dc4:     /** Use dblook methods to normalize the name of a column */
1:5e33d79:     private String  normalizeColumnName( String unnormalizedName )
1:28c4dc4:     {
1:28c4dc4:         return dblook.addQuotes
1:28c4dc4:             (
1:28c4dc4:              dblook.expandDoubleQuotes
1:28c4dc4:              (
1:28c4dc4:               dblook.stripQuotes
1:28c4dc4:               (
1:5e33d79:                dblook.addQuotes( unnormalizedName )
1:28c4dc4:                )
1:28c4dc4:               )
1:28c4dc4:              );
1:28c4dc4:     }
1:28c4dc4: 
1:28c4dc4:     /**
1:5e33d79:      * Create the table function and view for a single corrupt table.
1:28c4dc4:      * Add statements to the recovery script for siphoning data out
1:5e33d79:      * of the corrupt database into the healthy database.
1:28c4dc4:      */
1:28c4dc4:     private void    createView
1:28c4dc4:         (
1:28c4dc4:          Connection conn,
1:28c4dc4:          PrintWriter scriptWriter,
1:28c4dc4:          String controlSchema,
1:5e33d79:          String corruptSchemaName,
1:5e33d79:          String corruptTableName,
1:28c4dc4:          String schemaName,
1:28c4dc4:          String tableName,
1:28c4dc4:          long   conglomerateNumber,
1:28c4dc4:          ArrayList<String>  columnNames,
1:28c4dc4:          ArrayList<TypeDescriptor>  columnTypes,
1:5e33d79:          String corruptDBLocation,
1:28c4dc4:          String encryptionAttributes,
1:28c4dc4:          String dbo,
1:28c4dc4:          String dboPassword
1:28c4dc4:          )
1:28c4dc4:         throws SQLException
1:28c4dc4:     {
1:28c4dc4:         String  conglomerateName = "c" + Long.toHexString( conglomerateNumber ) + ".dat";
1:28c4dc4:         String  tableSignature = makeTableSignature( controlSchema, columnNames, columnTypes );
1:28c4dc4:         String  localTableName =
1:5e33d79:             IdUtil.normalToDelimited( corruptSchemaName ) + "." +
1:5e33d79:             IdUtil.normalToDelimited( corruptTableName );
1:28c4dc4:         String  viewName = schemaName + "." + tableName;
1:28c4dc4:         
1:28c4dc4:         scriptWriter.println( "-- siphon data out of " + conglomerateName );
1:28c4dc4:         scriptWriter.println
1:28c4dc4:             (
1:28c4dc4:              "create table " + localTableName + " as select * from " +
1:28c4dc4:              viewName + " with no data;"
1:28c4dc4:              );
1:28c4dc4:         scriptWriter.println( "insert into " + localTableName + " select * from " + viewName + ";\n" );
1:28c4dc4:         
1:28c4dc4:         createTable
1:28c4dc4:             (
1:28c4dc4:              conn,
1:28c4dc4:              schemaName,
1:28c4dc4:              tableName, 
1:28c4dc4:              tableSignature,
1:28c4dc4:              conglomerateName,
1:5e33d79:              corruptDBLocation,
1:28c4dc4:              encryptionAttributes,
1:28c4dc4:              dbo,
1:28c4dc4:              dboPassword
1:28c4dc4:              );
1:28c4dc4:     }
1:28c4dc4:     /** Make the signature of a table from its column names and types */
1:28c4dc4:     private String  makeTableSignature
1:28c4dc4:         (
1:28c4dc4:          String controlSchema,  // for serializable types
1:28c4dc4:          ArrayList<String>  columnNames,
1:28c4dc4:          ArrayList<TypeDescriptor>  columnTypes
1:28c4dc4:          )
1:28c4dc4:     {
1:28c4dc4:         StringBuilder   buffer = new StringBuilder();
1:28c4dc4: 
1:28c4dc4:         buffer.append( "( " );
1:28c4dc4:         for ( int i = 0; i < columnNames.size(); i++ )
1:28c4dc4:         {
1:28c4dc4:             if ( i > 0 ) { buffer.append( ", " ); }
1:28c4dc4:             buffer.append( columnNames.get( i ) + " " );
1:28c4dc4: 
1:28c4dc4:             TypeDescriptor  type = columnTypes.get( i );
1:28c4dc4:             if ( type.isUserDefinedType() ) { buffer.append( controlSchema + ".serializable" ); }
1:28c4dc4:             else { buffer.append( type.getSQLstring() ); }
1:28c4dc4:         }
1:28c4dc4:         buffer.append( " )" );
1:28c4dc4: 
1:28c4dc4:         return buffer.toString();
1:28c4dc4:     }
1:28c4dc4: 
1:28c4dc4:     
1:28c4dc4:     /** Return "null" if string is null, otherwise single quote it */
1:28c4dc4:     private String  singleQuote( String text )   { return text == null ? "null" : "'" + text + "'"; }
1:28c4dc4:     
1:28c4dc4:     ////////////////////////////////////////////////////////////////////////
1:28c4dc4:     //
1:28c4dc4:     //	UNLOADING MINIONS
1:28c4dc4:     //
1:28c4dc4:     ////////////////////////////////////////////////////////////////////////
1:28c4dc4: 
1:28c4dc4:     /**
1:5e33d79:      * Drop the table functions and views on the corrupt user tables.
1:28c4dc4:      */
1:28c4dc4:     private void    dropViews
1:28c4dc4:         (
1:28c4dc4:          Connection conn,
1:28c4dc4:          String schemaPrefix
1:28c4dc4:          )
1:28c4dc4:         throws SQLException
1:28c4dc4:     {
1:28c4dc4:         PreparedStatement   ps = prepareStatement
1:28c4dc4:             (
1:28c4dc4:              conn,
1:28c4dc4:              "select s.schemaName, t.tableName\n" +
1:28c4dc4:              "from sys.sysschemas s, sys.systables t\n" +
1:28c4dc4:              "where s.schemaName like '" + schemaPrefix + "%'\n" +
1:28c4dc4:              "and s.schemaID = t.schemaID"
1:28c4dc4:              );
1:28c4dc4:         ResultSet   rs = ps.executeQuery();
1:28c4dc4: 
1:28c4dc4:         while ( rs.next() )
1:28c4dc4:         {
1:28c4dc4:             int col = 1;
1:28c4dc4:             dropTable
1:28c4dc4:                 (
1:28c4dc4:                  conn,
1:28c4dc4:                  IdUtil.normalToDelimited( rs.getString( col++ ) ),
1:28c4dc4:                  IdUtil.normalToDelimited( rs.getString( col++ ) )
1:28c4dc4:                  );
1:28c4dc4:         }
1:28c4dc4: 
1:28c4dc4:         rs.close();
1:28c4dc4:         ps.close();
1:28c4dc4:     }
1:28c4dc4: 
1:28c4dc4:     /**
1:5e33d79:      * Drop the table function and view for a catalog in the
1:5e33d79:      * corrupt database.
1:28c4dc4:      */
1:28c4dc4:     private void    dropTable
1:28c4dc4:         (
1:28c4dc4:          Connection conn,
1:28c4dc4:          String schema,
1:28c4dc4:          String tableName
1:28c4dc4:          )
1:28c4dc4:         throws SQLException
1:28c4dc4:     {
1:28c4dc4:         String  qualifiedName = schema + "." + tableName;
1:28c4dc4:         
1:28c4dc4:         executeDDL( conn, "drop view " + qualifiedName );
1:28c4dc4:         executeDDL( conn, "drop function " + qualifiedName );
1:28c4dc4:     }
1:28c4dc4: 
1:28c4dc4:     /**
1:28c4dc4:      * Drop the now empty schemas which held the table functions and views
1:5e33d79:      * on conglomerates in the corrupt database.
1:28c4dc4:      */
1:28c4dc4:     private void    dropUserSchemas
1:28c4dc4:         (
1:28c4dc4:          Connection conn,
1:28c4dc4:          String schemaPrefix
1:28c4dc4:          )
1:28c4dc4:         throws SQLException
1:28c4dc4:     {
1:28c4dc4:         PreparedStatement   ps = prepareStatement
1:28c4dc4:             (
1:28c4dc4:              conn,
1:28c4dc4:              "select s.schemaName\n" +
1:28c4dc4:              "from sys.sysschemas s\n" +
1:28c4dc4:              "where s.schemaName like '" + schemaPrefix + "%'\n"
1:28c4dc4:              );
1:28c4dc4:         ResultSet   rs = ps.executeQuery();
1:28c4dc4: 
1:28c4dc4:         while ( rs.next() )
1:28c4dc4:         {
1:28c4dc4:             String  schemaName = IdUtil.normalToDelimited( rs.getString( 1 ) );
1:28c4dc4:             
1:28c4dc4:             executeDDL( conn, "drop schema " + schemaName + " restrict" );
1:28c4dc4:         }
1:28c4dc4:         
1:28c4dc4:         rs.close();
1:28c4dc4:         ps.close();
1:28c4dc4:     }
1:28c4dc4: 
1:28c4dc4:     /**
1:28c4dc4:      * Drop the schema which holds the table functions and views on the
1:5e33d79:      * corrupt core conglomerates.
1:28c4dc4:      */
1:28c4dc4:     private void    dropControlSchema
1:28c4dc4:         (
1:28c4dc4:          Connection conn,
1:28c4dc4:          String controlSchema
1:28c4dc4:          )
1:28c4dc4:         throws SQLException
1:28c4dc4:     {
1:28c4dc4:         executeDDL( conn, "set schema sys" );
1:28c4dc4: 
1:28c4dc4:         dropTable( conn, controlSchema, "SYSTABLES" );
1:28c4dc4:         dropTable( conn, controlSchema, "SYSSCHEMAS" );
1:28c4dc4:         dropTable( conn, controlSchema, "SYSCOLUMNS" );
1:28c4dc4:         dropTable( conn, controlSchema, "SYSCONGLOMERATES" );
1:28c4dc4: 
1:28c4dc4:         executeDDL( conn, "drop type " + controlSchema + ".serializable restrict" );
1:28c4dc4:         executeDDL( conn, "drop schema " + controlSchema + " restrict" );
1:28c4dc4:     }
1:28c4dc4: 
1:28c4dc4:     ////////////////////////////////////////////////////////////////////////
1:28c4dc4:     //
1:28c4dc4:     //	Connection MANAGEMENT
1:28c4dc4:     //
1:28c4dc4:     ////////////////////////////////////////////////////////////////////////
1:28c4dc4: 
1:28c4dc4:     private Connection  getDerbyConnection() throws SQLException
1:28c4dc4:     {
1:28c4dc4:         return DriverManager.getConnection( "jdbc:default:connection" );
1:28c4dc4:     }
1:28c4dc4: 
1:28c4dc4:     ////////////////////////////////////////////////////////////////////////
1:28c4dc4:     //
1:28c4dc4:     //	SQL MINIONS
1:28c4dc4:     //
1:28c4dc4:     ////////////////////////////////////////////////////////////////////////
1:28c4dc4: 
1:28c4dc4:     private String  delimitedID( String text )  { return IdUtil.normalToDelimited( text ); }
1:28c4dc4:     private String  stringLiteral( String text )  { return StringUtil.quoteStringLiteral( text ); }
1:28c4dc4: 
1:28c4dc4:     private void    executeDDL
1:28c4dc4:         ( Connection conn, String text )
1:28c4dc4:         throws SQLException
1:28c4dc4:     {
1:28c4dc4:         PreparedStatement   ddl = prepareStatement( conn, text );
1:28c4dc4:         ddl.execute();
1:28c4dc4:         ddl.close();
1:28c4dc4:     }
1:28c4dc4:     
1:28c4dc4:     private PreparedStatement   prepareStatement
1:28c4dc4:         ( Connection conn, String text )
1:28c4dc4:         throws SQLException
1:28c4dc4:     {
1:28c4dc4:         return conn.prepareStatement( text );
1:28c4dc4:     }
1:28c4dc4: 
1:28c4dc4:     private SQLException    wrap( Throwable t )
1:28c4dc4:     {
1:28c4dc4:         String  errorMessage = t.getMessage();
1:5e33d79:         String  sqlState = org.apache.derby.shared.common.reference.SQLState.JAVA_EXCEPTION
1:5e33d79:             .substring( 0, 5 );
1:28c4dc4: 
1:28c4dc4:         return new SQLException( errorMessage, sqlState, t );
1:28c4dc4:     }
1:28c4dc4:     
1:28c4dc4: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:5e33d79
/////////////////////////////////////////////////////////////////////////
1:  * in the seg0 subdirectory of a corrupt database.
/////////////////////////////////////////////////////////////////////////
1:      * Creates the following schema objects in a healthy database in order
1:      * to siphon data out of a corrupt database:
1:      * and SYSCOLUMNS in the corrupt database.</li>
1:      * <li>A schema for every user schema in the corrupt database.</li>
1:      * <li>Table functions and views on every user table in the corrupt database.</li>
1:      * In addition, the tool creates a script for siphoning data out of the corrupt
/////////////////////////////////////////////////////////////////////////
1:      * created. These include the views on the corrupt database's SYSSCHEMAS, SYSCONGLOMERATES,
1:      * to the names of the schemas which are created in the healthy database.
1:      * May not be null or empty.</li>
1:      * <li>corruptDBLocation (required) - Absolute path to the corrupt database directory.
1:      * <li>encryptionAttributes (required) - Encryption attributes which were
1:      * used to connect to the corrupt database when it was bootable. May be null
1:      * <li>dbo (required) - User name of the owner of the corrupt database. May be null
1:      * <li>dboPassword (required) - Password for the owner of the corrupt database. May be null
/////////////////////////////////////////////////////////////////////////
1:         String  corruptDBLocation = configurationParameters[ idx++ ];
1:         if ( nullOrEmpty( recoveryScript) )
1:         { throw badArgs( "Null or empty recovery script argument." ); }
1:         if ( nullOrEmpty( controlSchema) )
1:         { throw badArgs( "Null or empty control schema argument." ); }
1:         if ( nullOrEmpty( schemaPrefix ) )
1:         { throw badArgs( "Null or empty schema prefix argument." ); }
1:         if ( nullOrEmpty( corruptDBLocation ) )
1:         { throw badArgs( "Null or empty database location argument." ); }
1:         if ( nullOrEmpty( dbo)  )
1:         { throw badArgs( "Null or empty database owner argument." ); }
1:         createControlSchema( conn, controlSchema, corruptDBLocation,
1:                              encryptionAttributes, dbo, dboPassword );
1:         createUserSchemas( conn, controlSchema, schemaPrefix, corruptDBLocation,
1:                            encryptionAttributes, dbo, dboPassword );
1:         createViews( conn, recoveryScript, controlSchema, schemaPrefix, corruptDBLocation,
1:                      encryptionAttributes, dbo, dboPassword );
/////////////////////////////////////////////////////////////////////////
1:      * <li>controlSchema (required) - Name of the schema in which loadTool() created control objects
1:      * in the healthy database. May not be null or an empty string.</li>
1:      * to the names of the schemas which loadTool() created in the healthy
1:      * database. May not be null or empty.</li>
/////////////////////////////////////////////////////////////////////////
1:         if ( nullOrEmpty( controlSchema) )
1:         { throw badArgs( "Null or empty control schema argument." ); }
1:         if ( nullOrEmpty( schemaPrefix ) )
1:         { throw badArgs( "Null or empty schema prefix argument." ); }
/////////////////////////////////////////////////////////////////////////
1:          String corruptDBLocation,
/////////////////////////////////////////////////////////////////////////
1:              corruptDBLocation,
/////////////////////////////////////////////////////////////////////////
1:              corruptDBLocation,
/////////////////////////////////////////////////////////////////////////
1:              corruptDBLocation,
/////////////////////////////////////////////////////////////////////////
1:              corruptDBLocation,
/////////////////////////////////////////////////////////////////////////
1:      * Create a table function and view for a corrupt database table.
/////////////////////////////////////////////////////////////////////////
1:          String corruptDBLocation,
/////////////////////////////////////////////////////////////////////////
1:              "        '" + corruptDBLocation + "',\n" +
/////////////////////////////////////////////////////////////////////////
1:          String corruptDBLocation,
/////////////////////////////////////////////////////////////////////////
1:     /** Make the name of a local schema from a prefix and the name of a corrupt schema */
1:     private String  makeSchemaName( String schemaPrefix, String corruptName )
1:         return IdUtil.normalToDelimited( schemaPrefix + corruptName );
1:      * Create table functions and views on corrupt user tables. These objects
1:      * are created in the healthy database. Write the recovery
/////////////////////////////////////////////////////////////////////////
1:          String corruptDBLocation,
/////////////////////////////////////////////////////////////////////////
1:         String  corruptSchemaName = null;
1:         String  corruptTableName = null;
1:             String  currentCorruptSchemaName = rs.getString( col++ );
1:             String  currentCorruptTableName = rs.getString( col++ );
1:             if ( !currentCorruptSchemaName.equals( corruptSchemaName ) )
1:                     ( "create schema " + IdUtil.normalToDelimited( currentCorruptSchemaName ) + ";\n" );
1:             String  newSchemaName = makeSchemaName( schemaPrefix, currentCorruptSchemaName );
1:             String  newTableName = IdUtil.normalToDelimited( currentCorruptTableName );
/////////////////////////////////////////////////////////////////////////
1:                          corruptSchemaName,
1:                          corruptTableName,
1:                          corruptDBLocation,
/////////////////////////////////////////////////////////////////////////
1:             corruptSchemaName = currentCorruptSchemaName;
1:             corruptTableName = currentCorruptTableName;
/////////////////////////////////////////////////////////////////////////
1:                  corruptSchemaName,
1:                  corruptTableName,
1:                  corruptDBLocation,
/////////////////////////////////////////////////////////////////////////
1:     private String  normalizeColumnName( String unnormalizedName )
/////////////////////////////////////////////////////////////////////////
1:                dblook.addQuotes( unnormalizedName )
1:      * Create the table function and view for a single corrupt table.
1:      * of the corrupt database into the healthy database.
1:          String corruptSchemaName,
1:          String corruptTableName,
1:          String corruptDBLocation,
/////////////////////////////////////////////////////////////////////////
1:             IdUtil.normalToDelimited( corruptSchemaName ) + "." +
1:             IdUtil.normalToDelimited( corruptTableName );
/////////////////////////////////////////////////////////////////////////
1:              corruptDBLocation,
/////////////////////////////////////////////////////////////////////////
1:      * Drop the table functions and views on the corrupt user tables.
/////////////////////////////////////////////////////////////////////////
1:      * Drop the table function and view for a catalog in the
1:      * corrupt database.
/////////////////////////////////////////////////////////////////////////
1:      * on conglomerates in the corrupt database.
/////////////////////////////////////////////////////////////////////////
1:      * corrupt core conglomerates.
/////////////////////////////////////////////////////////////////////////
1:         String  sqlState = org.apache.derby.shared.common.reference.SQLState.JAVA_EXCEPTION
1:             .substring( 0, 5 );
commit:28c4dc4
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    org.apache.derby.optional.dump.RawDBReader
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derby.optional.dump;
1: 
1: import java.io.File;
1: import java.io.IOException;
1: import java.io.PrintWriter;
1: import java.sql.Connection;
1: import java.sql.DatabaseMetaData;
1: import java.sql.DriverManager;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: import java.util.ArrayList;
1: 
1: import org.apache.derby.catalog.TypeDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.OptionalTool;
1: import org.apache.derby.iapi.util.IdUtil;
1: import org.apache.derby.iapi.util.StringUtil;
1: import org.apache.derby.impl.jdbc.EmbedConnection;
1: import org.apache.derby.tools.dblook;
1: 
1: /**
1:  * <p>
1:  * OptionalTool to create wrapper functions and views for all of the user heap conglomerates
0:  * in the seg0 subdirectory of a database.
1:  * </p>
1:  */
1: public	class   RawDBReader  implements OptionalTool
1: {
1:     ////////////////////////////////////////////////////////////////////////
1:     //
1:     //	CONSTANTS
1:     //
1:     ////////////////////////////////////////////////////////////////////////
1: 
1:     ////////////////////////////////////////////////////////////////////////
1:     //
1:     //	STATE
1:     //
1:     ////////////////////////////////////////////////////////////////////////
1: 
1:     ////////////////////////////////////////////////////////////////////////
1:     //
1:     //	CONSTRUCTOR
1:     //
1:     ////////////////////////////////////////////////////////////////////////
1: 
1:     /** 0-arg constructor required by the OptionalTool contract */
1:     public  RawDBReader() {}
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // OptionalTool BEHAVIOR
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * <p>
0:      * Creates the following:
1:      * </p>
1:      *
1:      * <ul>
1:      * <li>A control schema containing views on SYSSCHEMAS, SYSCONGLOMERATES, SYSTABLES
0:      * and SYSCOLUMNS in the raw database.</li>
0:      * <li>A schema for every user schema in the raw database.</li>
0:      * <li>Table functions and views on every user table in the raw database..</li>
1:      * </ul>
1:      *
1:      * <p>
0:      * In addition, the tool creates a script for siphoning data out of the raw
1:      * database.
1:      * </p>
1:      *
1:      * <p>
1:      * Takes the following arguments:
1:      * </p>
1:      *
1:      * <ul>
1:      * <li>recoveryScript (required) - Name of the recovery script file which
1:      * the tool will write.</li>
1:      * <li>controlSchema (required) - Name of a schema in which control objects will be
0:      * created. These include the views on the raw database's SYSSCHEMAS, SYSCONGLOMERATES,
1:      * SYSTABLES, and SYSCOLUMNS catalogs. May not be null or an empty string.</li>
1:      * <li>schemaPrefix (required) - This prefix is prepended
0:      * to the names of the local Derby schemas which are created. May not be null or empty.</li>
0:      * <li>rawDBLocation (required) - Absolute path to the raw database directory.
1:      * That is the directory which contains service.properties. May not be null or empty.</li>
0:      * <li>encryptionAttributes (required) - Encryption attributes. May be null
1:      * if encryption is not being used.</li>
0:      * <li>dbo (required) - User name of the owner of the raw database. May be null
1:      * if authentication is not being used.</li>
0:      * <li>dboPassword (required) - Password for the owner of the raw database. May be null
1:      * if authentication is not being used.</li>
1:      * </ul>
1:      */
1:     public  void    loadTool( String... configurationParameters )
1:         throws SQLException
1:     {
1:         if ( (configurationParameters == null) || (configurationParameters.length < 7) )
1:         { throw badArgs( "Wrong number of arguments." ); }
1: 
1:         int     idx = 0;
1:         String  recoveryScript = configurationParameters[ idx++ ];
1:         String  controlSchema = configurationParameters[ idx++ ];
1:         String  schemaPrefix = configurationParameters[ idx++ ];
0:         String  rawDBLocation = configurationParameters[ idx++ ];
1:         String  encryptionAttributes = configurationParameters[ idx++ ];
1:         String  dbo = configurationParameters[ idx++ ];
1:         String  dboPassword = configurationParameters[ idx++ ];
1:         
0:         if ( nullOrEmpty( recoveryScript) )  { throw badArgs( "Null or empty recovery script argument." ); }
0:         if ( nullOrEmpty( controlSchema) )  { throw badArgs( "Null or empty control schema argument." ); }
0:         if ( nullOrEmpty( schemaPrefix ) )  { throw badArgs( "Null or empty schema prefix argument." ); }
0:         if ( nullOrEmpty( rawDBLocation ) )  { throw badArgs( "Null or empty database location argument." ); }
0:         if ( nullOrEmpty( dbo)  )   { throw badArgs( "Null or empty database owner argument." ); }
1: 
1:         Connection  conn = getDerbyConnection();
1: 
0:         createControlSchema( conn, controlSchema, rawDBLocation, encryptionAttributes, dbo, dboPassword );
0:         createUserSchemas( conn, controlSchema, schemaPrefix, rawDBLocation, encryptionAttributes, dbo, dboPassword );
0:         createViews( conn, recoveryScript, controlSchema, schemaPrefix, rawDBLocation, encryptionAttributes, dbo, dboPassword );
1:     }
1: 
1:     /** Returns true if the text is null or empty */
1:     private boolean nullOrEmpty( String text ) { return ( (text == null) || (text.length() == 0) ); }
1: 
1:     /**
1:      * <p>
1:      * Removes the schemas, table functions, and views created by loadTool().
1:      * </p>
1:      *
1:      * <p>
1:      * Takes the following arguments:
1:      * </p>
1:      *
1:      * <ul>
0:      * <li>controlSchema (required) - Name of the schema in which control objects were created
0:      * by loadTool(). May not be null or an empty string.</li>
1:      * <li>schemaPrefix (required) - This is the prefix which was prepended
0:      * to the names of the local Derby schemas which loadTool() created. May not be null or empty.</li>
1:      * </ul>
1:      */
1:     public  void    unloadTool( String... configurationParameters )
1:         throws SQLException
1:     {
1:         if ( (configurationParameters == null) || (configurationParameters.length < 2) )
1:         { throw badArgs( "Wrong number of arguments." ); }
1:         
1:         int     idx = 0;
1:         String  controlSchema = configurationParameters[ idx++ ];
1:         String  schemaPrefix = configurationParameters[ idx++ ];
1: 
0:         if ( nullOrEmpty( controlSchema) )  { throw badArgs( "Null or empty control schema argument." ); }
0:         if ( nullOrEmpty( schemaPrefix ) )  { throw badArgs( "Null or empty schema prefix argument." ); }
1: 
1:         Connection  conn = getDerbyConnection();
1: 
1:         dropViews( conn, schemaPrefix );
1:         dropUserSchemas( conn, schemaPrefix );
1:         dropControlSchema( conn, controlSchema );
1:     }
1:     /** Return a "bad args" exception */
1:     private SQLException    badArgs( String message )
1:     {
1:         return new SQLException( message );
1:     }
1:     
1: 
1:     ////////////////////////////////////////////////////////////////////////
1:     //
1:     //	LOADING MINIONS
1:     //
1:     ////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Create and populate the schema which holds control objects.
1:      */
1:     private void    createControlSchema
1:         (
1:          Connection conn,
1:          String controlSchema,
0:          String rawDBLocation,
1:          String encryptionAttributes,
1:          String dbo,
1:          String dboPassword
1:          )
1:         throws SQLException
1:     {
1:         // create the schema and move into it
1:         executeDDL( conn, "create schema " + controlSchema );
1:         executeDDL( conn, "set schema " + controlSchema );
1: 
1:         // create a generic UDT for use with all object types
1:         executeDDL( conn, "create type serializable external name 'java.io.Serializable' language java" );
1: 
1:         // create table functions and views on core catalogs
1:         createTable
1:             (
1:              conn,
1:              controlSchema,
1:              "SYSCONGLOMERATES", 
1:              "( schemaid char(36), tableid char(36), conglomeratenumber bigint, conglomeratename varchar( 128), isindex boolean, descriptor serializable, isconstant boolean, conglomerateid char( 36 ) )",
1:              "c20.dat",
0:              rawDBLocation,
1:              encryptionAttributes,
1:              dbo,
1:              dboPassword
1:              );
1:         createTable
1:             (
1:              conn,
1:              controlSchema,
1:              "SYSCOLUMNS", 
1:              "( referenceid char(36), columnname varchar(128), columnnumber int, columndatatype serializable, columndefault serializable, columndefaultid char(36), autoincrementvalue bigint, autoincrementstart bigint, autoincrementinc bigint )",
1:              "c90.dat",
0:              rawDBLocation,
1:              encryptionAttributes,
1:              dbo,
1:              dboPassword
1:              );
1:         createTable
1:             (
1:              conn,
1:              controlSchema,
1:              "SYSSCHEMAS", 
1:              DataFileVTI.SYSSCHEMAS_SIGNATURE,
1:              DataFileVTI.SYSSCHEMAS_CONGLOMERATE_NAME,
0:              rawDBLocation,
1:              encryptionAttributes,
1:              dbo,
1:              dboPassword
1:              );
1:         createTable
1:             (
1:              conn,
1:              controlSchema,
1:              "SYSTABLES", 
1:              DataFileVTI.SYSTABLES_SIGNATURE,
1:              DataFileVTI.SYSTABLES_CONGLOMERATE_NAME,
0:              rawDBLocation,
1:              encryptionAttributes,
1:              dbo,
1:              dboPassword
1:              );
1:     }
1: 
1:     /**
0:      * Create a table function and view for a raw database table.
1:      */
1:     private void    createTable
1:         (
1:          Connection conn,
1:          String schema,
1:          String tableName,
1:          String tableSignature,
1:          String heapFileName,
0:          String rawDBLocation,
1:          String encryptionAttributes,
1:          String dbo,
1:          String dboPassword
1:          )
1:         throws SQLException
1:     {
1:         String  qualifiedName = schema + "." + tableName;
1:         String  dataFileVTIClassName = DataFileVTI.class.getName();
1:         
1:         executeDDL
1:             (
1:              conn,
1:             "create function " + qualifiedName + "\n" +
1:             "(\n" +
1:             "    databaseDirectoryName varchar( 32672 ),\n" +
1:             "    dataFileName varchar( 32672 ),\n" +
1:             "    tableSignature varchar( 32672 ),\n" +
1:             "    encryptionAttributes varchar( 32672 ),\n" +
1:             "    userName varchar( 32672 ),\n" +
1:             "    password varchar( 32672 )\n" +
1:             ")\n" +
1:             "returns table\n" + tableSignature +
1:             "language java\n" +
1:             "parameter style derby_jdbc_result_set\n" +
1:             "no sql\n" +
1:             "external name '" + dataFileVTIClassName + ".dataFileVTI'\n"
1:             );
1:         executeDDL
1:             (
1:              conn,
1:              "create view " + qualifiedName + "\n" +
1:              "as select * from table\n" +
1:              "(\n" +
1:              "    " + qualifiedName + "\n" +
1:              "    (\n" +
0:              "        '" + rawDBLocation + "',\n" +
1:              "        '" + heapFileName + "',\n" +
1:              "        '" + tableSignature + "',\n" +
1:              "        " + singleQuote( encryptionAttributes ) + ",\n" +
1:              "        " + singleQuote( dbo ) + ",\n" +
1:              "        " + singleQuote( dboPassword ) + "\n" +
1:              "    )\n" +
1:              ") t\n"
1:              );
1:     }
1: 
1:     /**
1:      * Create user schemas.
1:      */
1:     private void    createUserSchemas
1:         (
1:          Connection conn,
1:          String controlSchema,
1:          String schemaPrefix,
0:          String rawDBLocation,
1:          String encryptionAttributes,
1:          String dbo,
1:          String dboPassword
1:          )
1:         throws SQLException
1:     {
1:         PreparedStatement   ps = prepareStatement
1:             (
1:              conn,
1:              "select schemaName\n" +
1:              "from "+ controlSchema + ".sysschemas\n" +
1:              "where schemaName not like 'SYS%' and schemaName != 'NULLID' and schemaName != 'SQLJ'\n"
1:              );
1:         ResultSet   rs = ps.executeQuery();
1: 
1:         while ( rs.next() )
1:         {
1:             String  schemaName = makeSchemaName( schemaPrefix , rs.getString( 1 ) );
1: 
1:             executeDDL( conn, "create schema " + schemaName );
1:         }
1: 
1:         rs.close();
1:         ps.close();
1:     }
0:     /** Make the name of a local schema from a prefix and a raw name */
0:     private String  makeSchemaName( String schemaPrefix, String rawName )
1:     {
0:         return IdUtil.normalToDelimited( schemaPrefix + rawName );
1:     }
1:     
1:     /**
0:      * Create table functions and views on user tables. Write the recovery
1:      * script.
1:      */
1:     private void    createViews
1:         (
1:          Connection conn,
1:          String recoveryScriptName,
1:          String controlSchema,
1:          String schemaPrefix,
0:          String rawDBLocation,
1:          String encryptionAttributes,
1:          String dbo,
1:          String dboPassword
1:          )
1:         throws SQLException
1:     {
1:         File                recoveryScript = new File( recoveryScriptName );
1:         PrintWriter         scriptWriter = null;
1:         try {
1:             scriptWriter = new PrintWriter( recoveryScript );
1:         }
1:         catch (Exception e) { throw wrap( e ); }
1: 
1:         String              localDBName = ((EmbedConnection) conn).getDBName();
1:         scriptWriter.println( "connect 'jdbc:derby:" + localDBName + "';\n" );
1:         
1:         PreparedStatement   ps = prepareStatement
1:             (
1:              conn,
1:              "select s.schemaName, t.tableName, g.conglomerateNumber, c.columnName, c.columnNumber, c.columnDatatype\n" +
1:              "from " + controlSchema + ".sysschemas s,\n" +
1:              controlSchema + ".systables t,\n" +
1:              controlSchema + ".sysconglomerates g,\n" +
1:              controlSchema + ".syscolumns c\n" +
1:              "where s.schemaName not like 'SYS%' and schemaName != 'NULLID' and schemaName != 'SQLJ'\n" +
1:              "and s.schemaID = t.schemaID\n" +
1:              "and t.tableID = g.tableID and not g.isindex\n" +
1:              "and t.tableID = c.referenceID\n" +
1:              "order by s.schemaName, t.tableName, c.columnNumber"
1:              );
1:         ResultSet   rs = ps.executeQuery();
1: 
1:         ArrayList<String>   columnNames = new ArrayList<String>();
1:         ArrayList<TypeDescriptor>   columnTypes = new ArrayList<TypeDescriptor>();
0:         String  rawSchemaName = null;
0:         String  rawTableName = null;
1:         String  schemaName = null;
1:         String  tableName = null;
1:         long    conglomerateNumber = -1L;
1:         while ( rs.next() )
1:         {
1:             int     col = 1;
0:             String  currentRawSchemaName = rs.getString( col++ );
0:             String  currentRawTableName = rs.getString( col++ );
1: 
0:             if ( !currentRawSchemaName.equals( rawSchemaName ) )
1:             {
1:                 scriptWriter.println
0:                     ( "create schema " + IdUtil.normalToDelimited( currentRawSchemaName ) + ";\n" );
1:             }            
1:                 
0:             String  newSchemaName = makeSchemaName( schemaPrefix, currentRawSchemaName );
0:             String  newTableName = IdUtil.normalToDelimited( currentRawTableName );
1: 
1:             if ( schemaName != null )
1:             {
1:                 if ( !schemaName.equals( newSchemaName ) || !tableName.equals( newTableName ) )
1:                 {
1:                     createView
1:                         (
1:                          conn,
1:                          scriptWriter,
1:                          controlSchema,
0:                          rawSchemaName,
0:                          rawTableName,
1:                          schemaName,
1:                          tableName,
1:                          conglomerateNumber,
1:                          columnNames,
1:                          columnTypes,
0:                          rawDBLocation,
1:                          encryptionAttributes,
1:                          dbo,
1:                          dboPassword
1:                          );
1:                     columnNames.clear();
1:                     columnTypes.clear();
1:                 }
1:             }
1: 
0:             rawSchemaName = currentRawSchemaName;
0:             rawTableName = currentRawTableName;
1:             schemaName = newSchemaName;
1:             tableName = newTableName;
1:             conglomerateNumber = rs.getLong( col++ );
1:             columnNames.add( normalizeColumnName( rs.getString( col++ ) ) );
1:             col++;  // only need the column number to order the results
1:             columnTypes.add( (TypeDescriptor) rs.getObject( col++ ) );
1:         }
1: 
1:         // create last view
1:         if ( schemaName != null )
1:         {
1:             createView
1:                 (
1:                  conn,
1:                  scriptWriter,
1:                  controlSchema,
0:                  rawSchemaName,
0:                  rawTableName,
1:                  schemaName,
1:                  tableName,
1:                  conglomerateNumber,
1:                  columnNames,
1:                  columnTypes,
0:                  rawDBLocation,
1:                  encryptionAttributes,
1:                  dbo,
1:                  dboPassword
1:                  );
1:         }
1: 
1:         rs.close();
1:         ps.close();
1:         scriptWriter.flush();
1:         scriptWriter.close();
1:     }
1:     /** Use dblook methods to normalize the name of a column */
0:     private String  normalizeColumnName( String raw )
1:     {
1:         return dblook.addQuotes
1:             (
1:              dblook.expandDoubleQuotes
1:              (
1:               dblook.stripQuotes
1:               (
0:                dblook.addQuotes( raw )
1:                )
1:               )
1:              );
1:     }
1: 
1:     /**
0:      * Create the table function and view for a single raw table.
1:      * Add statements to the recovery script for siphoning data out
0:      * of the raw database into the current database.
1:      */
1:     private void    createView
1:         (
1:          Connection conn,
1:          PrintWriter scriptWriter,
1:          String controlSchema,
0:          String rawSchemaName,
0:          String rawTableName,
1:          String schemaName,
1:          String tableName,
1:          long   conglomerateNumber,
1:          ArrayList<String>  columnNames,
1:          ArrayList<TypeDescriptor>  columnTypes,
0:          String rawDBLocation,
1:          String encryptionAttributes,
1:          String dbo,
1:          String dboPassword
1:          )
1:         throws SQLException
1:     {
1:         String  conglomerateName = "c" + Long.toHexString( conglomerateNumber ) + ".dat";
1:         String  tableSignature = makeTableSignature( controlSchema, columnNames, columnTypes );
1:         String  localTableName =
0:             IdUtil.normalToDelimited( rawSchemaName ) + "." +
0:             IdUtil.normalToDelimited( rawTableName );
1:         String  viewName = schemaName + "." + tableName;
1:         
1:         scriptWriter.println( "-- siphon data out of " + conglomerateName );
1:         scriptWriter.println
1:             (
1:              "create table " + localTableName + " as select * from " +
1:              viewName + " with no data;"
1:              );
1:         scriptWriter.println( "insert into " + localTableName + " select * from " + viewName + ";\n" );
1:         
1:         createTable
1:             (
1:              conn,
1:              schemaName,
1:              tableName, 
1:              tableSignature,
1:              conglomerateName,
0:              rawDBLocation,
1:              encryptionAttributes,
1:              dbo,
1:              dboPassword
1:              );
1:     }
1:     /** Make the signature of a table from its column names and types */
1:     private String  makeTableSignature
1:         (
1:          String controlSchema,  // for serializable types
1:          ArrayList<String>  columnNames,
1:          ArrayList<TypeDescriptor>  columnTypes
1:          )
1:     {
1:         StringBuilder   buffer = new StringBuilder();
1: 
1:         buffer.append( "( " );
1:         for ( int i = 0; i < columnNames.size(); i++ )
1:         {
1:             if ( i > 0 ) { buffer.append( ", " ); }
1:             buffer.append( columnNames.get( i ) + " " );
1: 
1:             TypeDescriptor  type = columnTypes.get( i );
1:             if ( type.isUserDefinedType() ) { buffer.append( controlSchema + ".serializable" ); }
1:             else { buffer.append( type.getSQLstring() ); }
1:         }
1:         buffer.append( " )" );
1: 
1:         return buffer.toString();
1:     }
1: 
1:     
1:     /** Return "null" if string is null, otherwise single quote it */
1:     private String  singleQuote( String text )   { return text == null ? "null" : "'" + text + "'"; }
1:     
1:     ////////////////////////////////////////////////////////////////////////
1:     //
1:     //	UNLOADING MINIONS
1:     //
1:     ////////////////////////////////////////////////////////////////////////
1: 
1:     /**
0:      * Drop the table functions and views on user tables.
1:      */
1:     private void    dropViews
1:         (
1:          Connection conn,
1:          String schemaPrefix
1:          )
1:         throws SQLException
1:     {
1:         PreparedStatement   ps = prepareStatement
1:             (
1:              conn,
1:              "select s.schemaName, t.tableName\n" +
1:              "from sys.sysschemas s, sys.systables t\n" +
1:              "where s.schemaName like '" + schemaPrefix + "%'\n" +
1:              "and s.schemaID = t.schemaID"
1:              );
1:         ResultSet   rs = ps.executeQuery();
1: 
1:         while ( rs.next() )
1:         {
1:             int col = 1;
1:             dropTable
1:                 (
1:                  conn,
1:                  IdUtil.normalToDelimited( rs.getString( col++ ) ),
1:                  IdUtil.normalToDelimited( rs.getString( col++ ) )
1:                  );
1:         }
1: 
1:         rs.close();
1:         ps.close();
1:     }
1: 
1:     /**
0:      * Drop the table function and view for a raw database catalog.
1:      */
1:     private void    dropTable
1:         (
1:          Connection conn,
1:          String schema,
1:          String tableName
1:          )
1:         throws SQLException
1:     {
1:         String  qualifiedName = schema + "." + tableName;
1:         
1:         executeDDL( conn, "drop view " + qualifiedName );
1:         executeDDL( conn, "drop function " + qualifiedName );
1:     }
1: 
1:     /**
1:      * Drop the now empty schemas which held the table functions and views
0:      * on raw conglomerates.
1:      */
1:     private void    dropUserSchemas
1:         (
1:          Connection conn,
1:          String schemaPrefix
1:          )
1:         throws SQLException
1:     {
1:         PreparedStatement   ps = prepareStatement
1:             (
1:              conn,
1:              "select s.schemaName\n" +
1:              "from sys.sysschemas s\n" +
1:              "where s.schemaName like '" + schemaPrefix + "%'\n"
1:              );
1:         ResultSet   rs = ps.executeQuery();
1: 
1:         while ( rs.next() )
1:         {
1:             String  schemaName = IdUtil.normalToDelimited( rs.getString( 1 ) );
1:             
1:             executeDDL( conn, "drop schema " + schemaName + " restrict" );
1:         }
1:         
1:         rs.close();
1:         ps.close();
1:     }
1: 
1:     /**
1:      * Drop the schema which holds the table functions and views on the
0:      * raw external core conglomerates.
1:      */
1:     private void    dropControlSchema
1:         (
1:          Connection conn,
1:          String controlSchema
1:          )
1:         throws SQLException
1:     {
1:         executeDDL( conn, "set schema sys" );
1: 
1:         dropTable( conn, controlSchema, "SYSTABLES" );
1:         dropTable( conn, controlSchema, "SYSSCHEMAS" );
1:         dropTable( conn, controlSchema, "SYSCOLUMNS" );
1:         dropTable( conn, controlSchema, "SYSCONGLOMERATES" );
1: 
1:         executeDDL( conn, "drop type " + controlSchema + ".serializable restrict" );
1:         executeDDL( conn, "drop schema " + controlSchema + " restrict" );
1:     }
1: 
1:     ////////////////////////////////////////////////////////////////////////
1:     //
1:     //	Connection MANAGEMENT
1:     //
1:     ////////////////////////////////////////////////////////////////////////
1: 
1:     private Connection  getDerbyConnection() throws SQLException
1:     {
1:         return DriverManager.getConnection( "jdbc:default:connection" );
1:     }
1: 
1:     ////////////////////////////////////////////////////////////////////////
1:     //
1:     //	SQL MINIONS
1:     //
1:     ////////////////////////////////////////////////////////////////////////
1: 
1:     private String  delimitedID( String text )  { return IdUtil.normalToDelimited( text ); }
1:     private String  stringLiteral( String text )  { return StringUtil.quoteStringLiteral( text ); }
1: 
1:     private void    executeDDL
1:         ( Connection conn, String text )
1:         throws SQLException
1:     {
1:         PreparedStatement   ddl = prepareStatement( conn, text );
1:         ddl.execute();
1:         ddl.close();
1:     }
1:     
1:     private PreparedStatement   prepareStatement
1:         ( Connection conn, String text )
1:         throws SQLException
1:     {
1:         return conn.prepareStatement( text );
1:     }
1: 
1:     private SQLException    wrap( Throwable t )
1:     {
1:         String  errorMessage = t.getMessage();
0:         String  sqlState = org.apache.derby.shared.common.reference.SQLState.JAVA_EXCEPTION.substring( 0, 5 );
1: 
1:         return new SQLException( errorMessage, sqlState, t );
1:     }
1:     
1: }
============================================================================