1:9bbe2e4: /*
1:9bbe2e4:  *
1:9bbe2e4:  * Derby - Class org.apache.derbyTesting.system.mailjdbc.utils.DbTasks
1:9bbe2e4:  *
1:9bbe2e4:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:9bbe2e4:  * contributor license agreements. See the NOTICE file distributed with this
1:9bbe2e4:  * work for additional information regarding copyright ownership. The ASF
1:9bbe2e4:  * licenses this file to You under the Apache License, Version 2.0 (the
1:9bbe2e4:  * "License"); you may not use this file except in compliance with the License.
1:9bbe2e4:  * You may obtain a copy of the License at
1:9bbe2e4:  *
1:9bbe2e4:  * http://www.apache.org/licenses/LICENSE-2.0
1:9bbe2e4:  *
1:9bbe2e4:  * Unless required by applicable law or agreed to in writing, software
1:9bbe2e4:  * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
1:9bbe2e4:  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
1:9bbe2e4:  * License for the specific language governing permissions and limitations under
1:9bbe2e4:  * the License.
1:9bbe2e4:  *
1:9bbe2e4:  */
1:9bbe2e4: package org.apache.derbyTesting.system.mailjdbc.utils;
14:9bbe2e4: 
1:9bbe2e4: /**
1:a5430dd:  * This class is used all other classes for various tasks like insert, delete,
1:a5430dd:  * backup etc
1:9bbe2e4:  */
1:9bbe2e4: 
1:9bbe2e4: import java.io.File;
1:9bbe2e4: import java.io.InputStream;
1:a5430dd: import java.io.Reader;
1:9bbe2e4: import java.sql.CallableStatement;
1:9bbe2e4: import java.sql.Connection;
1:9bbe2e4: import java.sql.DriverManager;
1:9bbe2e4: import java.sql.PreparedStatement;
1:9bbe2e4: import java.sql.ResultSet;
1:9bbe2e4: import java.sql.SQLException;
1:9bbe2e4: import java.sql.Statement;
1:9bbe2e4: import java.sql.Timestamp;
1:9bbe2e4: import java.util.ArrayList;
1:a5430dd: import java.util.Random;
1:a5430dd: import org.apache.derbyTesting.functionTests.util.streams.CharAlphabet;
1:a5430dd: import org.apache.derbyTesting.functionTests.util.streams.LoopingAlphabetReader;
1:a5430dd: import org.apache.derbyTesting.functionTests.util.streams.LoopingAlphabetStream;
1:9bbe2e4: import org.apache.derbyTesting.system.mailjdbc.MailJdbc;
1:cae4ed4: public class DbTasks {
1:9bbe2e4: 
1:9bbe2e4: 	public static LogFile log = new LogFile("performance.out");
1:04014b2: 
1:9bbe2e4: 	private static int id_count = 0;
1:9bbe2e4: 
1:9bbe2e4: 	public static int insert_count = 0;
1:9bbe2e4: 
1:9bbe2e4: 	public static int delete_count = 0;
1:a216dfd: 	
1:9bbe2e4: 	public static int clob_count = 0;
1:9bbe2e4: 
1:9bbe2e4: 	public static int blob_count = 0;
1:9bbe2e4: 
1:a5430dd: 	public static Random Rn = new Random();
1:934f02d: 	/**
1:934f02d: 	 * jdbcLoad - Create url, schema and set driver and database system property that will be use later in the test.
1:934f02d: 	 * @param driverType - "embedded" or "NetworkServer" 
1:934f02d: 	 * @param useexistingdb - whether to use existing database or not
1:934f02d: 	 */
1:934f02d: 	public static void jdbcLoad(String driverType, boolean useexistingdb) {
1:9bbe2e4: 
1:9bbe2e4: 		if (driverType.equalsIgnoreCase("embedded")) {
1:9bbe2e4: 			setSystemProperty("driver", "org.apache.derby.jdbc.EmbeddedDriver");
1:9bbe2e4: 			MailJdbc.logAct
1:9bbe2e4: 					.logMsg(" \n*****************************************************");
1:9bbe2e4: 			MailJdbc.logAct.logMsg("\n\n\tStarting the test in Embedded mode");
1:9bbe2e4: 			MailJdbc.logAct
1:9bbe2e4: 					.logMsg("\n\n*****************************************************");
1:a5430dd: 			// setting the properties like user, password etc for both the
1:58a99b7: 			// database and the backup database
1:934f02d: 			if (useexistingdb)
1:934f02d: 		        setSystemProperty("database", "jdbc:derby:mailsdb");
1:934f02d: 			else
1:934f02d: 		        setSystemProperty("database", "jdbc:derby:mailsdb;create=true");			
1:9bbe2e4: 			setSystemProperty("ij.user", "REFRESH");
1:9bbe2e4: 			setSystemProperty("ij.password", "Refresh");
1:9bbe2e4: 		} else {
1:9bbe2e4: 			setSystemProperty("driver", "org.apache.derby.jdbc.ClientDriver");
1:a216dfd: 			MailJdbc.logAct
1:a216dfd: 			.logMsg(" \n*****************************************************");
1:a216dfd: 			MailJdbc.logAct
1:a216dfd: 			.logMsg("\n\n\tStarting the test in NetworkServer mode");
1:a216dfd: 			MailJdbc.logAct
1:a216dfd: 			.logMsg("\n\n*****************************************************");
1:934f02d: 			if (useexistingdb)
1:934f02d: 				setSystemProperty("database",
1:934f02d: 					"jdbc:derby://localhost:1527/mailsdb");
1:934f02d: 			else
1:934f02d: 				setSystemProperty("database",
1:934f02d: 					"jdbc:derby://localhost:1527/mailsdb;create=true");
1:934f02d: 			setSystemProperty("ij.user", "REFRESH");
1:934f02d: 			setSystemProperty("ij.password", "Refresh");
1:a216dfd: 			
1:63e167e: 		}
19:9bbe2e4: 		try {
1:934f02d: 			if (useexistingdb)
1:934f02d: 			{
1:934f02d: 				MailJdbc.logAct
1:934f02d: 				.logMsg("Useing the existing database...");
1:934f02d: 				return;
1:934f02d: 			}
1:9bbe2e4: 			// Create the schema (tables)
1:9bbe2e4: 			long s_schema = System.currentTimeMillis();
1:9bbe2e4: 			org.apache.derby.tools.ij
1:9bbe2e4: 					.main(new String[] { "-fr",
1:9bbe2e4: 							"/org/apache/derbyTesting/system/mailjdbc/schema/schema.sql" });
1:9bbe2e4: 			long e_schema = System.currentTimeMillis();
1:9bbe2e4: 			log
1:9bbe2e4: 					.logMsg(" \n*****************************************************");
1:9bbe2e4: 			log.logMsg("\n\n\tPerformance Info for the Test on" + s_schema);
1:9bbe2e4: 			log
1:9bbe2e4: 					.logMsg("\n\n*****************************************************");
1:9bbe2e4: 			log.logMsg(LogFile.INFO + "Schema Creation :"
1:9bbe2e4: 					+ PerfTime.readableTime(e_schema - s_schema));
1:9bbe2e4: 			System.out.println("created the schema");
1:9bbe2e4: 		} catch (Exception e) {
1:9bbe2e4: 			log.logMsg(LogFile.ERROR
1:9bbe2e4: 					+ "Exception while running loading and creating tables: "
1:9bbe2e4: 					+ e.getMessage());
1:9bbe2e4: 			e.printStackTrace();
2:9bbe2e4: 			errorPrint(e);
1:63e167e: 		}
1:9bbe2e4: 
35:9bbe2e4: 	}
1:9bbe2e4: 
1:a216dfd: 	public static Connection getConnection(String usr, String passwd){
1:9bbe2e4: 		try {
1:a5430dd: 			// Returns the Connection object
1:4469400:             Class<?> clazz = Class.forName(System.getProperty("driver"));
1:4469400:             clazz.getConstructor().newInstance();
1:9bbe2e4: 
1:9bbe2e4: 			Connection con = DriverManager.getConnection(System
1:cae4ed4: 					.getProperty("database"), usr, passwd);
1:9bbe2e4: 			return con;
1:9bbe2e4: 		} catch (Exception e) {
1:9bbe2e4: 			log.logMsg(LogFile.ERROR
1:9bbe2e4: 					+ "Error while getting connection for threads:"
1:9bbe2e4: 					+ e.getMessage());
1:9bbe2e4: 			e.printStackTrace();
1:9bbe2e4: 			errorPrint(e);
1:9bbe2e4: 			return null;
1:9bbe2e4: 		}
1:9bbe2e4: 	}
1:9bbe2e4: 
1:58a99b7: 	public void readMail(Connection conn, String thread_name) throws Exception{
1:a5430dd: 		// This function will be reading mails from the inbox.
1:58a99b7: 		// Getting the number of rows in the table and getting the
1:a5430dd: 		// size of the attachment (Blob) for a randomly selected row
1:58a99b7: 		boolean saveAutoCommit = conn.getAutoCommit();
1:58a99b7: 		int saveIsolation = conn.getTransactionIsolation();
1:9bbe2e4: 		Statement stmt = null;
1:a216dfd: 		Statement attach_stmt = null;
1:a216dfd: 		int inbox_count = 0;
1:a216dfd: 		int attach_count = 0;
1:9bbe2e4: 		long size = 0;
1:9bbe2e4: 		try {
1:9bbe2e4: 			conn.setAutoCommit(false);
1:58a99b7: 			conn.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);
1:9bbe2e4: 			long s_select = System.currentTimeMillis();
1:9bbe2e4: 			stmt = conn.createStatement();
1:a216dfd: 			attach_stmt = conn.createStatement();
1:9bbe2e4: 			ResultSet rs = stmt.executeQuery(Statements.getRowCount);
1:a216dfd: 			ResultSet rs1 = attach_stmt.executeQuery(Statements.getRowCountAttach);
3:9bbe2e4: 			while (rs.next()) {
1:a216dfd: 				inbox_count = rs.getInt(1);
1:9bbe2e4: 			}
1:9bbe2e4: 			while (rs1.next()) {
1:a216dfd: 				attach_count = rs1.getInt(1);
1:9bbe2e4: 			}
1:a216dfd: 			if (inbox_count == 0)
10:9bbe2e4: 				MailJdbc.logAct.logMsg(LogFile.INFO + thread_name + " : "
1:9bbe2e4: 						+ "Inbox is empty");
1:9bbe2e4: 			long e_select = System.currentTimeMillis();
1:9bbe2e4: 			MailJdbc.logAct
1:9bbe2e4: 					.logMsg(LogFile.INFO + thread_name + " : "
1:9bbe2e4: 							+ "The number of mails in the REFRESH.INBOX are : "
1:a216dfd: 							+ inbox_count);
1:9bbe2e4: 			MailJdbc.logAct.logMsg(LogFile.INFO + thread_name + " : "
1:a216dfd: 					+ "The number of mails in the REFRESH.ATTACH are : "
1:a216dfd: 					+ attach_count);
4:9bbe2e4: 			log.logMsg(LogFile.INFO + thread_name + " : "
1:9bbe2e4: 					+ "Time taken to scan the entire REFRESH.INBOX for count :"
1:9bbe2e4: 					+ PerfTime.readableTime(e_select - s_select));
6:9bbe2e4: 			rs.close();
1:9bbe2e4: 			rs1.close();
1:a216dfd: 			attach_stmt.close();
3:9bbe2e4: 		} catch (SQLException sqe) {
1:04014b2: 			MailJdbc.logAct.logMsg(LogFile.ERROR + thread_name + " : "
1:9bbe2e4: 					+ "SQL Exception while reading : " + sqe.getMessage());
2:9bbe2e4: 			sqe.printStackTrace();
2:9bbe2e4: 			errorPrint(sqe);
1:58a99b7: 			conn.rollback();
1:58a99b7: 			throw sqe;
1:04014b2: 		}
1:04014b2: 		try {
1:a216dfd: 			int inbox_id = 0;
1:a216dfd: 			if((inbox_count - 1) <= 0)
1:a216dfd: 				inbox_id = 1;
1:a216dfd: 			else {
1:a216dfd: 				 inbox_id = Rn.nextInt(inbox_count - 1);
1:a216dfd: 				 if (inbox_id == 0)
1:a216dfd: 					 inbox_id = 1;
1:a216dfd: 			}
1:9bbe2e4: 			long start_t = System.currentTimeMillis();
1:a216dfd: 
1:a216dfd: 			ResultSet inbox_rs = stmt
1:a216dfd: 					.executeQuery("select message from REFRESH.INBOX where id  = "
1:a216dfd: 							+ inbox_id);
1:a216dfd: 			
1:a216dfd: 			if (inbox_rs.next()) {
1:a216dfd: 				size = inbox_rs.getClob(1).length();
1:9bbe2e4: 				MailJdbc.logAct.logMsg(LogFile.INFO + thread_name + " : "
1:a216dfd: 						+ "size of the message for id " + inbox_id + " is : "
1:9bbe2e4: 						+ size);
3:9bbe2e4: 			} else
1:9bbe2e4: 				MailJdbc.logAct.logMsg(LogFile.INFO + thread_name + " : "
1:a216dfd: 						+ "mail with the id " + inbox_id + " does not exist");
1:9bbe2e4: 			long end_t = System.currentTimeMillis();
1:9bbe2e4: 			log.logMsg(LogFile.INFO + thread_name + " : "
1:9bbe2e4: 					+ "Time taken to get the clob :"
1:9bbe2e4: 					+ PerfTime.readableTime(end_t - start_t));
1:a216dfd: 			inbox_rs.close();
1:a216dfd: 			ResultSet attach_rs = stmt
1:a216dfd: 					.executeQuery("select attachment from REFRESH.attach where id  = "
1:a216dfd: 							+ inbox_id);
1:a216dfd: 			long start = System.currentTimeMillis();
1:a216dfd: 			if (attach_rs.next()) {
1:a216dfd: 				size = attach_rs.getBlob(1).length();
1:a216dfd: 				MailJdbc.logAct.logMsg(LogFile.INFO + thread_name + " : "
1:a216dfd: 						+ "size of the attachment for id " + inbox_id
1:a216dfd: 						+ " is : " + size);
1:a216dfd: 			} else
1:a216dfd: 				MailJdbc.logAct.logMsg(LogFile.INFO + thread_name + " : "
1:a216dfd: 						+ "no attachment");
1:a216dfd: 			attach_rs.close();
1:a216dfd:    			stmt.close();
1:a216dfd: 			long end = System.currentTimeMillis();
1:a216dfd: 			log.logMsg(LogFile.INFO + thread_name + " : "
1:a216dfd: 					+ "Time taken to get the blob :"
1:a216dfd: 					+ PerfTime.readableTime(end - start));
3:9bbe2e4: 			conn.commit();
1:9bbe2e4: 		} catch (SQLException sqe) {
1:9bbe2e4: 			MailJdbc.logAct
1:9bbe2e4: 					.logMsg(LogFile.ERROR
1:9bbe2e4: 							+ thread_name
1:9bbe2e4: 							+ " : "
1:9bbe2e4: 							+ "SQL Exception while getting the message and attach size : "
2:9bbe2e4: 							+ sqe.getMessage());
1:9bbe2e4: 			sqe.printStackTrace();
1:9bbe2e4: 			errorPrint(sqe);
1:58a99b7: 			conn.rollback();
1:58a99b7: 			throw sqe;
1:58a99b7: 		}
1:58a99b7: 		finally{
1:58a99b7: 			conn.setAutoCommit(saveAutoCommit);
1:58a99b7: 			conn.setTransactionIsolation(saveIsolation);
1:58a99b7: 		}
1:9bbe2e4: 
1:58a99b7: 	}
1:9bbe2e4: 
1:58a99b7: 	public synchronized void deleteMailByUser (Connection conn,
1:58a99b7: 			String thread_name) throws Exception{
1:a216dfd: 		// Delete done by the user. The user will mark the mails to be deleted
1:a216dfd: 	
1:58a99b7: 		boolean saveAutoCommit = conn.getAutoCommit();
1:9bbe2e4: 		int id_count = 0;
1:cd2b901: 		int id = 0;
1:04014b2: 		try {
1:9bbe2e4: 			conn.setAutoCommit(false);
1:9bbe2e4: 			PreparedStatement updateUser = conn
1:9bbe2e4: 					.prepareStatement(Statements.updateStr);
2:9bbe2e4: 			Statement stmt = conn.createStatement();
4:9bbe2e4: 			ResultSet rs = stmt
1:a216dfd: 					.executeQuery("select max(id) from REFRESH.INBOX ");
1:9bbe2e4: 			if (rs.next())
2:9bbe2e4: 				id_count = rs.getInt(1);
1:a216dfd: 			rs.close();
1:a216dfd: 			stmt.close();
1:9bbe2e4: 			short to_delete = 1;
2:cd2b901: 			if((id_count -1) <= 0 )
1:cd2b901: 				id = id_count;
1:cd2b901: 			else
1:a216dfd: 			{
1:a216dfd: 			    id = Rn.nextInt(id_count - 1);
1:a216dfd: 			    if (id == 0)
1:a216dfd: 			    	id = 1;
1:a216dfd: 			}
1:9bbe2e4: 			long s_update = System.currentTimeMillis();
1:9bbe2e4: 			int delete_count = 0;
1:9bbe2e4: 			for (int i = 0; i < id; i++) {
1:9bbe2e4: 				updateUser.setShort(1, to_delete);
1:a216dfd: 				updateUser.setInt(2, i);
1:9bbe2e4: 				int del = updateUser.executeUpdate();
1:9bbe2e4: 				delete_count = delete_count + del;
1:58a99b7: 			}
1:9bbe2e4: 			long e_update = System.currentTimeMillis();
1:9bbe2e4: 			log.logMsg(LogFile.INFO + thread_name + " : "
1:a216dfd: 					+ " Time taken to mark " + id + " mails to be deleted :"
1:9bbe2e4: 					+ PerfTime.readableTime(e_update - s_update));
1:04014b2: 			MailJdbc.logAct.logMsg(LogFile.INFO + thread_name + " : "
1:a216dfd: 					+ "The number of mails marked to be deleted from REFRESH.INBOX is: "
1:9bbe2e4: 					+ delete_count);
1:9bbe2e4: 			updateUser.close();
1:9bbe2e4: 			conn.commit();
1:9bbe2e4: 		} catch (SQLException sqe) {
1:04014b2: 			MailJdbc.logAct.logMsg(LogFile.ERROR + thread_name + " : "
1:a216dfd: 					+ "Exception while deleting mail REFRESH.INBOX"
1:9bbe2e4: 					+ sqe.getMessage());
1:9bbe2e4: 			sqe.printStackTrace();
1:9bbe2e4: 			errorPrint(sqe);
1:58a99b7: 			conn.rollback();
1:58a99b7: 			throw sqe;
1:58a99b7: 		}
1:58a99b7: 		finally{
1:58a99b7: 			conn.setAutoCommit(saveAutoCommit);
1:04014b2: 		}
1:04014b2: 	}
1:9bbe2e4: 
1:9bbe2e4: 	public void deleteMailByThread(Connection conn, String thread_name)
1:9bbe2e4: 			throws Exception {
1:a5430dd: 		// Deleting mails which are marked to be deleted
1:58a99b7: 		boolean saveAutoCommit = conn.getAutoCommit();
1:04014b2: 		try {
1:9bbe2e4: 			conn.setAutoCommit(false);
1:9bbe2e4: 			PreparedStatement deleteThread = conn
1:9bbe2e4: 					.prepareStatement(Statements.deleteStr);
1:9bbe2e4: 			Statement stmt = conn.createStatement();
1:9bbe2e4: 			long s_delete = System.currentTimeMillis();
3:9bbe2e4: 			int count = 0;
1:9bbe2e4: 			count = deleteThread.executeUpdate();
1:9bbe2e4: 			long e_delete = System.currentTimeMillis();
1:9bbe2e4: 			log.logMsg(LogFile.INFO + thread_name + " : "
1:9bbe2e4: 					+ "Time taken to delete mails by thread :"
1:9bbe2e4: 					+ PerfTime.readableTime(e_delete - s_delete));
1:9bbe2e4: 			MailJdbc.logAct.logMsg(LogFile.INFO + thread_name + " : " + count
1:a216dfd: 					+ " rows deleted from REFRESH.INBOX");
1:9bbe2e4: 			delete_count = delete_count + count;
1:9bbe2e4: 			deleteThread.close();
4:9bbe2e4: 			stmt.close();
1:9bbe2e4: 			conn.commit();
1:9bbe2e4: 		} catch (SQLException sqe) {
1:04014b2: 			MailJdbc.logAct.logMsg(LogFile.ERROR + thread_name + " : "
1:a216dfd: 					+ "Exception while deleting mail from REFRESH.INBOX, REFRESH.ATTACH by Thread: "
1:9bbe2e4: 					+ sqe.getMessage());
1:9bbe2e4: 			sqe.printStackTrace();
1:9bbe2e4: 			errorPrint(sqe);
1:58a99b7: 			conn.rollback();
1:58a99b7: 			throw sqe;
1:04014b2: 		}
1:58a99b7: 		finally{
1:58a99b7: 			conn.setAutoCommit(saveAutoCommit);
1:04014b2: 		}
1:9bbe2e4: 
1:63e167e: 	}
1:9bbe2e4: 
1:58a99b7: 	public void moveToFolders(Connection conn, String thread_name) throws Exception{
1:a5430dd: 		// Changing the folder id of randomly selected rows
1:58a99b7: 		boolean saveAutoCommit = conn.getAutoCommit();
1:04014b2: 		try {
1:9bbe2e4: 			conn.setAutoCommit(false);
1:9bbe2e4: 			Statement stmt = conn.createStatement();
1:9bbe2e4: 			PreparedStatement moveToFolder = conn
1:9bbe2e4: 					.prepareStatement(Statements.movefolder);
1:9bbe2e4: 			ResultSet rs = stmt.executeQuery(Statements.getRowCount);
1:9bbe2e4: 			if (!(rs.next()))
1:04014b2: 				MailJdbc.logAct.logMsg(LogFile.INFO + thread_name + " : "
1:9bbe2e4: 						+ "no message in the REFRESH.INBOX to move");
1:9bbe2e4: 			else {
1:cd2b901: 				int message_id = 0;
1:9bbe2e4: 				int count = rs.getInt(1);
1:a216dfd:                 //If there is zero row, nothing to do	
1:a216dfd: 				if (count==0)
1:a216dfd: 					return;
1:a216dfd: 				//If there is just one row, id is 1 (start from 1)
1:a216dfd: 				if (count <= 1) 
1:a216dfd: 					message_id = 1;
1:cd2b901: 				else
1:cd2b901: 				    message_id = Rn.nextInt(count - 1);
1:a216dfd: 				if (message_id == 0)
1:a216dfd: 					message_id = 1;
1:a216dfd: 				//Assign the folder to be between 1 to 5
1:a216dfd: 				int folder_id = Rn.nextInt(5 - 1);
1:a216dfd: 				if (folder_id == 0)
1:a216dfd: 					folder_id = 1;
1:9bbe2e4: 				moveToFolder.setInt(1, folder_id);
1:9bbe2e4: 				moveToFolder.setInt(2, message_id);
1:9bbe2e4: 				long s_folder = System.currentTimeMillis();
1:9bbe2e4: 				moveToFolder.executeUpdate();
1:9bbe2e4: 				long e_folder = System.currentTimeMillis();
1:9bbe2e4: 				log.logMsg(LogFile.INFO + thread_name + " : "
1:9bbe2e4: 						+ "Time taken to move a mail to the folder :"
1:9bbe2e4: 						+ PerfTime.readableTime(e_folder - s_folder));
1:9bbe2e4: 				MailJdbc.logAct.logMsg(LogFile.INFO + thread_name + " : "
1:9bbe2e4: 						+ "Mail with id : " + message_id
1:a216dfd: 						+ " is moved to folder" + folder_id);
1:63e167e: 			}
1:9bbe2e4: 			stmt.close();
1:9bbe2e4: 			moveToFolder.close();
1:9bbe2e4: 			rs.close();
1:9bbe2e4: 			conn.commit();
1:9bbe2e4: 		} catch (SQLException sqe) {
1:04014b2: 			MailJdbc.logAct.logMsg(LogFile.ERROR + thread_name + " : "
1:9bbe2e4: 					+ "Exception while moving mail to folders: "
1:9bbe2e4: 					+ sqe.getMessage());
1:9bbe2e4: 			sqe.printStackTrace();
1:9bbe2e4: 			errorPrint(sqe);
1:58a99b7: 			conn.rollback();
1:58a99b7: 			throw sqe;
1:58a99b7: 		}
1:58a99b7: 		finally{
1:58a99b7: 			conn.setAutoCommit(saveAutoCommit);
1:04014b2: 		}
1:63e167e: 	}
1:04014b2: 
1:9bbe2e4: 	public void insertMail(Connection conn, String thread_name)
1:9bbe2e4: 			throws Exception {
1:a216dfd: 		// Inserting rows to the inbox table. 
1:a216dfd: 		// inbox table would have random attachments - (attach table)
1:a216dfd: 		// The random attachment depends on no of rows id in inbox
1:a5430dd: 		InputStream streamIn = null;
1:a5430dd: 		Reader streamReader = null;
1:58a99b7: 		boolean saveAutoCommit = conn.getAutoCommit();
1:58a99b7: 		int saveIsolation = conn.getTransactionIsolation();
1:04014b2: 		try {
1:9bbe2e4: 			conn.setAutoCommit(false);
1:9bbe2e4: 			PreparedStatement insertFirst = conn.prepareStatement(
1:9bbe2e4: 					Statements.insertStr, Statement.RETURN_GENERATED_KEYS);
1:9bbe2e4: 			String name = new String("ABCD");
1:9bbe2e4: 			String l_name = new String("WXYZ");
1:a216dfd: 			long total_ins_inb = 0;
1:a216dfd: 			long total_ins_att = 0;
1:a216dfd: 			int row_count = 0;
1:a216dfd: 			int num = Rn.nextInt(10 - 1);
1:a216dfd: 			if (num == 0) 
1:a216dfd: 				num = 1;
1:9bbe2e4: 			for (int i = 0; i < num; i++) {
1:a216dfd: 				long s_insert = System.currentTimeMillis();
1:9bbe2e4: 				String new_name = new String(increment(name, 60));
1:a5430dd: 				String new_lname = new String(decrement(l_name, 60));
1:9bbe2e4: 				insertFirst.setString(1, new_name);
1:9bbe2e4: 				insertFirst.setString(2, new_lname);
1:9bbe2e4: 				insertFirst.setTimestamp(3, new Timestamp(System
1:9bbe2e4: 						.currentTimeMillis()));
1:9bbe2e4: 				name = new_name;
1:9bbe2e4: 				l_name = new_lname;
1:04014b2: 				try {
1:a5430dd: 					// to create a stream of random length between 200 bytes and 3MB
1:a5430dd: 					int clobLength = Rn.nextInt(3078000 - 200 + 1) + 200;
1:a5430dd: 					streamReader = new LoopingAlphabetReader(clobLength,
1:a5430dd: 							CharAlphabet.modernLatinLowercase());
1:a5430dd: 					insertFirst.setCharacterStream(4, streamReader, clobLength);
1:9bbe2e4: 				} catch (Exception e) {
1:04014b2: 					MailJdbc.logAct.logMsg(LogFile.ERROR + thread_name + " : "
1:9bbe2e4: 							+ "File not found Exception : " + e.getMessage());
1:9bbe2e4: 					errorPrint(e);
2:9bbe2e4: 					throw e;
1:63e167e: 				}
1:9bbe2e4: 				int result = insertFirst.executeUpdate();
1:9bbe2e4: 				if (result != 0) {
1:9bbe2e4: 					insert_count = insert_count + 1;
1:63e167e: 				}
1:a216dfd: 				streamReader.close();
1:9bbe2e4: 
1:a216dfd: 				long e_insert = System.currentTimeMillis();
1:a216dfd: 				total_ins_inb = total_ins_inb + (e_insert - s_insert);
1:a216dfd: 				PreparedStatement insertAttach = conn
1:9bbe2e4: 					.prepareStatement(Statements.insertStrAttach);
1:a216dfd: 				Statement stmt1 = conn.createStatement();
1:a216dfd: 				ResultSet rs = insertFirst.getGeneratedKeys();
1:a216dfd: 				//10/1 chance to have attactment
1:a216dfd: 				int numa = Rn.nextInt(10 - 1);
1:a216dfd: 				if (numa == 0)
1:a216dfd: 					numa = 1;
1:a216dfd: 				if (i == numa) {
1:a216dfd: 					int attachid  = 0;
1:a216dfd: 				while (rs.next()) {
1:a216dfd: 					attachid = rs.getInt(1);	
1:a216dfd: 				}
1:a216dfd: 				// insert from 1 to 5 attachments
1:a216dfd: 				int num_attach = Rn.nextInt(5 - 1);
1:a216dfd: 				if (num_attach == 0)
1:a216dfd: 					num_attach = 1;
1:a216dfd: 				for (int j = 0; j < num_attach; j++) { 
1:a216dfd: 					long a_start = System.currentTimeMillis();
1:a216dfd: 					insertAttach.setInt(1, attachid);
1:a216dfd: 					//attach_id should be automatically generated
1:a216dfd: 					try {
1:a216dfd: 						// to create a stream of random length between 0 and 5M
1:a216dfd: 						int blobLength = Rn.nextInt(5130000 - 0 + 1) + 0;
1:a216dfd: 						streamIn = new LoopingAlphabetStream(blobLength);
1:a216dfd: 						insertAttach.setBinaryStream(2, streamIn, blobLength);
1:a216dfd: 					} catch (Exception e) {
1:a216dfd: 						MailJdbc.logAct.logMsg(LogFile.ERROR + thread_name + " : "
1:9bbe2e4: 							+ "Exception : " + e.getMessage());
1:a216dfd: 						errorPrint(e);
1:a216dfd: 						throw e;
1:a216dfd: 					}
1:a216dfd: 					int result_attach = insertAttach.executeUpdate();
1:a216dfd: 					streamIn.close();
1:a216dfd: 					if (result_attach != 0) {
1:a216dfd: 						blob_count = blob_count + 1;
1:a216dfd: 						row_count++;
1:a216dfd: 					}
1:a216dfd: 					long a_end = System.currentTimeMillis();
1:a216dfd: 					total_ins_att = total_ins_att + (a_end - a_start);
1:a216dfd: 				 }
1:9bbe2e4: 				}
1:9bbe2e4: 			id_count++;
1:9bbe2e4: 			rs.close();
2:9bbe2e4: 			stmt1.close();
1:9bbe2e4: 			insertAttach.close();
1:a216dfd: 			} 
1:a216dfd: 			log.logMsg(LogFile.INFO + thread_name + " : "
1:a216dfd: 					+ "Time taken to insert " + num + " rows to REFRESH.INBOX :"
1:a216dfd: 					+ PerfTime.readableTime(total_ins_inb));
1:a216dfd: 			log.logMsg(LogFile.INFO + thread_name + " : "
1:a216dfd: 					+ "Time taken to insert " + row_count + " rows to REFRESH.ATTACH :"			
1:a216dfd: 					+ PerfTime.readableTime(total_ins_att));
1:a216dfd: 			insertFirst.close();
1:9bbe2e4: 			conn.commit();
1:a216dfd: 		}
1:a216dfd: 		catch (SQLException sqe) {
1:a216dfd: 			MailJdbc.logAct.logMsg(LogFile.ERROR + thread_name + " : "
1:a216dfd: 					+ "Error while inserting REFRESH.ATTACH:" + sqe.getMessage());
1:9bbe2e4: 			sqe.printStackTrace();
1:9bbe2e4: 			errorPrint(sqe);
1:58a99b7: 			conn.rollback();
1:58a99b7: 			throw sqe;
1:58a99b7: 		}
1:58a99b7: 		finally{
1:58a99b7: 			conn.setTransactionIsolation(saveIsolation);
1:58a99b7: 			conn.setAutoCommit(saveAutoCommit);
1:04014b2: 		}
1:63e167e: 	}
1:9bbe2e4: 
1:58a99b7: 	public synchronized void deleteMailByExp(Connection conn, String thread_name) throws Exception{
1:58a99b7: 		boolean saveAutoCommit = conn.getAutoCommit();
1:04014b2: 		try {
1:a5430dd: 			// Deleting mails which are older than 1 day
1:9bbe2e4: 			conn.setAutoCommit(false);
1:9bbe2e4: 			long s_delExp = System.currentTimeMillis();
1:9bbe2e4: 			Statement selExp = conn.createStatement();
1:9bbe2e4: 			MailJdbc.logAct.logMsg(LogFile.INFO + thread_name + " : "
1:a216dfd: 				+ "delete mails which are older than 1 day with sleep 250000 ");
1:9bbe2e4: 			int count = 0;
1:9bbe2e4: 			count = selExp.executeUpdate(Statements.del_jdbc_exp);
1:a216dfd: 			selExp.close();
1:a216dfd: 			conn.commit();
1:9bbe2e4: 			long e_delExp = System.currentTimeMillis();
1:9bbe2e4: 			log.logMsg(LogFile.INFO + thread_name + " : "
1:a216dfd: 					+ PerfTime.readableTime(s_delExp) + " : "
1:a216dfd: 					+ "Time taken to delete " + count + " mails :"
1:9bbe2e4: 					+ PerfTime.readableTime(e_delExp - s_delExp));
1:9bbe2e4: 			MailJdbc.logAct.logMsg(LogFile.INFO + thread_name + " : "
1:9bbe2e4: 					+ " number of mails deleted : " + count);
1:9bbe2e4: 			delete_count = delete_count + count;
1:9bbe2e4: 		} catch (SQLException sqe) {
1:04014b2: 			MailJdbc.logAct.logMsg(LogFile.ERROR + thread_name + " : "
1:9bbe2e4: 					+ "Error while deleting mails by expiry manager: "
1:9bbe2e4: 					+ sqe.getMessage());
1:9bbe2e4: 			sqe.printStackTrace();
1:9bbe2e4: 			errorPrint(sqe);
1:58a99b7: 			conn.rollback();
1:58a99b7: 			throw sqe;
1:58a99b7: 		}
1:58a99b7: 		finally {
1:58a99b7: 			conn.setAutoCommit(saveAutoCommit);
1:04014b2: 		}
1:63e167e: 	}
1:9bbe2e4: 
1:58a99b7: 	public void Backup(Connection conn, String thread_name) throws Exception{
1:a5430dd: 		// when the backup thread kicks in, it will use this function to
1:a5430dd: 		// take the periodic backups
1:58a99b7: 		boolean saveAutoCommit = conn.getAutoCommit();
1:9bbe2e4: 		long s_backup = System.currentTimeMillis();
1:04014b2: 		try {
1:9bbe2e4: 			conn.setAutoCommit(true);
1:9bbe2e4: 			CallableStatement cs = conn
1:9bbe2e4: 					.prepareCall("CALL SYSCS_UTIL.SYSCS_BACKUP_DATABASE_AND_ENABLE_LOG_ARCHIVE_MODE_NOWAIT(?, ?)");
1:a5430dd: 			cs.setString(1, System.getProperty("user.dir") + File.separator
1:a5430dd: 					+ "mailbackup");
1:9bbe2e4: 			cs.setInt(2, 1);
1:9bbe2e4: 			cs.execute();
1:9bbe2e4: 			cs.close();
1:9bbe2e4: 			MailJdbc.logAct.logMsg(LogFile.INFO + thread_name + " : "
1:9bbe2e4: 					+ "Finished backing up the Database");
1:9bbe2e4: 			conn.commit();
1:9bbe2e4: 		} catch (Throwable sqe) {
14:9bbe2e4: 			MailJdbc.logAct.logMsg(LogFile.ERROR + thread_name + " : "
1:9bbe2e4: 					+ "Error while doing the backup system procedure: "
1:9bbe2e4: 					+ sqe.getMessage());
1:9bbe2e4: 			sqe.printStackTrace();
1:9bbe2e4: 			errorPrint(sqe);
1:9bbe2e4: 		}
1:58a99b7: 		finally{
1:58a99b7: 			conn.setAutoCommit(saveAutoCommit);
1:9bbe2e4: 		}
1:9bbe2e4: 		long e_backup = System.currentTimeMillis();
1:9bbe2e4: 		log.logMsg(LogFile.INFO + thread_name + " : "
1:9bbe2e4: 				+ "Time taken to do backup :"
1:9bbe2e4: 				+ PerfTime.readableTime(e_backup - s_backup));
1:9bbe2e4: 
1:9bbe2e4: 	}
1:9bbe2e4: 
1:9bbe2e4: 	public void compressTable(Connection conn, String tabname,
1:58a99b7: 			String thread_name) throws Exception
1:58a99b7: 	// periodically compresses the table to get back the free spaces available
1:9bbe2e4: 	// after
1:a5430dd: 	// the deletion of some rows
1:9bbe2e4: 	{
1:9bbe2e4: 		long s_compress = System.currentTimeMillis();
1:d9e100c: 		long dbsize = databaseSize(new File("mailsdb"));
1:9bbe2e4: 		MailJdbc.logAct.logMsg(LogFile.INFO + thread_name + " : "
1:9bbe2e4: 				+ "dbsize before compress : " + dbsize);
1:58a99b7: 		boolean saveAutoCommit = conn.getAutoCommit();
1:9bbe2e4: 		try {
1:9bbe2e4: 			conn.setAutoCommit(true);
1:9bbe2e4: 			CallableStatement cs = conn
1:9bbe2e4: 					.prepareCall("CALL SYSCS_UTIL.SYSCS_INPLACE_COMPRESS_TABLE(?, ?, ?, ?, ?)");
1:9bbe2e4: 			cs.setString(1, "REFRESH");
1:9bbe2e4: 			cs.setString(2, tabname);
1:9bbe2e4: 			cs.setShort(3, (short) 1);
1:9bbe2e4: 			cs.setShort(4, (short) 1);
1:9bbe2e4: 			cs.setShort(5, (short) 1);
1:9bbe2e4: 			cs.execute();
1:9bbe2e4: 			cs.close();
1:9bbe2e4: 		} catch (Throwable sqe) {
1:9bbe2e4: 			MailJdbc.logAct.logMsg(LogFile.ERROR + thread_name + " : "
1:9bbe2e4: 					+ "Error while doing the Compress procedure: "
1:9bbe2e4: 					+ sqe.getMessage());
1:9bbe2e4: 			sqe.printStackTrace();
1:9bbe2e4: 			errorPrint(sqe);
1:9bbe2e4: 		}
1:58a99b7: 		finally{
1:58a99b7: 		    conn.setAutoCommit(saveAutoCommit);
1:9bbe2e4: 		}
1:9bbe2e4: 		long e_compress = System.currentTimeMillis();
1:9bbe2e4: 		MailJdbc.logAct.logMsg(LogFile.INFO + thread_name + " : "
1:9bbe2e4: 				+ "Finished Compressing the table: " + tabname);
1:9bbe2e4: 		log.logMsg(LogFile.INFO + thread_name + " : "
1:9bbe2e4: 				+ "Time taken to compress the table : " + tabname
1:a216dfd: 				+ " " + PerfTime.readableTime(e_compress - s_compress));
1:d9e100c: 		dbsize = databaseSize(new File("mailsdb"));
1:9bbe2e4: 		MailJdbc.logAct.logMsg(LogFile.INFO + thread_name + " : "
1:9bbe2e4: 				+ "dbsize after compress : " + dbsize);
1:9bbe2e4: 	}
1:9bbe2e4: 
1:9bbe2e4: 	public synchronized void checkDbSize(Connection conn, String thread_name)
1:a5430dd: 	// Will give the information about the size of the database in regular
1:9bbe2e4: 	// intervals
1:9bbe2e4: 	{
1:9bbe2e4: 		try {
1:9bbe2e4: 			int del_count = 0;
1:9bbe2e4: 			int count = 0;
1:9bbe2e4: 			int diff = 0;
1:9d44c9e: 			ArrayList<Integer> idArray = new ArrayList<Integer>();
1:9bbe2e4: 			Statement stmt = conn.createStatement();
2:9bbe2e4: 			Statement stmt1 = conn.createStatement();
1:9bbe2e4: 			Statement stmt2 = conn.createStatement();
1:9bbe2e4: 			ResultSet rs = stmt
1:9bbe2e4: 					.executeQuery("select count(*) from REFRESH.INBOX ");
1:9bbe2e4: 			while (rs.next())
2:9bbe2e4: 				count = rs.getInt(1);
1:a216dfd: 			//Generate the random number between (count - 36)==>24 to 1
1:a216dfd: 			if (count > 50) {
1:a216dfd: 				diff = Rn.nextInt((count - 36) - 1);
1:a216dfd: 				if (diff == 0) 
1:a216dfd: 					diff = 1;
1:9bbe2e4: 				ResultSet rs1 = stmt1
1:9bbe2e4: 						.executeQuery("select id from REFRESH.INBOX");
1:9bbe2e4: 				while (rs1.next()) {
1:9d44c9e: 					idArray.add(rs1.getInt(1));
1:9bbe2e4: 				}
1:9bbe2e4: 				for (int i = 0; i <= diff; i++) {
1:9bbe2e4: 					del_count = del_count
1:a216dfd: 							+ stmt2
1:9bbe2e4: 									.executeUpdate("delete from REFRESH.INBOX where id ="
1:9bbe2e4: 											+ idArray.get(i));
1:9bbe2e4: 
1:9bbe2e4: 				}
1:9bbe2e4: 				rs1.close();
1:9bbe2e4: 			}
1:9bbe2e4: 			delete_count = delete_count + del_count;
1:9bbe2e4: 			rs.close();
1:9bbe2e4: 			stmt.close();
1:9bbe2e4: 			stmt1.close();
1:9bbe2e4: 			stmt2.close();
1:9bbe2e4: 		} catch (Exception fe) {
1:9bbe2e4: 			MailJdbc.logAct.logMsg(LogFile.ERROR + thread_name + " :  "
1:9bbe2e4: 					+ fe.getMessage());
1:9bbe2e4: 			errorPrint(fe);
1:9bbe2e4: 		}
1:9bbe2e4: 
1:9bbe2e4: 	}
1:9bbe2e4: 
1:58a99b7: 	public void grantRevoke(Connection conn, String thread_name) throws Exception{
1:58a99b7: 		boolean saveAutoCommit = conn.getAutoCommit();
1:9bbe2e4: 		try {
1:58a99b7: 			// Giving appropriate permission to each threads
1:9bbe2e4: 			Statement stmt = conn.createStatement();
1:9bbe2e4: 			stmt.execute(Statements.grantSel1);
1:9bbe2e4: 			stmt.execute(Statements.grantSel2);
1:9bbe2e4: 			stmt.execute(Statements.grantSel3);
1:9bbe2e4: 			stmt.execute(Statements.grantSel4);
1:9bbe2e4: 			stmt.execute(Statements.grantSel5);
1:9bbe2e4: 			stmt.execute(Statements.grantSel6);
1:9bbe2e4: 			stmt.execute(Statements.grantSel7);
1:9bbe2e4: 			stmt.execute(Statements.grantIns1);
1:9bbe2e4: 			stmt.execute(Statements.grantIns2);
1:9bbe2e4: 			stmt.execute(Statements.grantIns3);
1:9bbe2e4: 			stmt.execute(Statements.grantUp1);
1:9bbe2e4: 			stmt.execute(Statements.grantUp2);
1:9bbe2e4: 			stmt.execute(Statements.grantUp3);
1:9bbe2e4: 			stmt.execute(Statements.grantDel1);
1:9bbe2e4: 			stmt.execute(Statements.grantDel2);
1:9bbe2e4: 			stmt.execute(Statements.grantDel3);
1:9bbe2e4: 			stmt.execute(Statements.grantExe1);
1:9bbe2e4: 			stmt.execute(Statements.grantExe2);
1:9bbe2e4: 			stmt.execute(Statements.grantExe3);
1:9bbe2e4: 			stmt.execute(Statements.grantExe4);
1:9bbe2e4: 			stmt.execute(Statements.grantExe5);
1:9bbe2e4: 			conn.commit();
1:9bbe2e4: 			stmt.close();
1:9bbe2e4: 			MailJdbc.logAct.logMsg(LogFile.INFO + thread_name + " : "
1:9bbe2e4: 					+ "Finished Granting permissions");
1:9bbe2e4: 		} catch (Throwable sqe) {
1:9bbe2e4: 			MailJdbc.logAct.logMsg(LogFile.ERROR + thread_name + " : "
1:9bbe2e4: 					+ "Error while doing Grant Revoke: " + sqe.getMessage());
1:9bbe2e4: 			sqe.printStackTrace();
1:9bbe2e4: 			errorPrint(sqe);
1:58a99b7: 		}
1:58a99b7: 		finally {
1:58a99b7: 			conn.setAutoCommit(saveAutoCommit);
1:63e167e: 		}
1:9bbe2e4: 	}
1:d9e100c: 	public static long databaseSize(File dbname) {
1:d9e100c: 	    long length = 0;
1:d9e100c: 	    if (dbname.isDirectory()) {
1:d9e100c: 	        String[] children = dbname.list();
1:d9e100c: 	        for (int i=0; i<children.length; i++) 
1:d9e100c: 	            length = length + databaseSize(new File(dbname, children[i]));
1:d9e100c: 	        return length;
1:d9e100c: 	    }
1:d9e100c: 	    else
1:d9e100c: 	        return dbname.length();	
1:9bbe2e4: 	}
1:04014b2: 
1:9bbe2e4: 	public static void setSystemProperty(String key, String value) {
1:9bbe2e4: 		String svalue = System.getProperty(key);
1:9bbe2e4: 		if (svalue == null)
1:9bbe2e4: 			System.setProperty(key, value);
1:cd2b901: 		else
1:9bbe2e4: 			value = svalue;
1:9bbe2e4: 		MailJdbc.logAct.logMsg(LogFile.INFO + key + "=" + value);
1:9bbe2e4: 	}
1:04014b2: 
1:a216dfd: 	public void totals(String thread_name) {
1:a216dfd: 		MailJdbc.logAct.logMsg(LogFile.INFO + thread_name + " : " + "total number of inserts : "
1:9bbe2e4: 				+ insert_count);
1:a216dfd: 		MailJdbc.logAct.logMsg(LogFile.INFO + thread_name + " : " + "total number of deletes : "
1:9bbe2e4: 				+ delete_count);
1:a216dfd: 		//This number does not fit into reality. Reader should use 
1:a216dfd: 		//number of rows in REFRESH.ATTACH.
1:a216dfd: 		MailJdbc.logAct.logMsg(LogFile.INFO + thread_name + " : "
1:a216dfd: 				+ "total number of blobs had inserted : " + blob_count);
1:9bbe2e4: 	}
1:04014b2: 
1:9bbe2e4: 	public static String decrement(String name, int maxLength) {
1:9bbe2e4: 		StringBuffer buff = new StringBuffer(name);
1:9bbe2e4: 
1:a5430dd: 		// if the String is '0', return the maximum String
1:9bbe2e4: 		StringBuffer tempBuff = new StringBuffer();
1:9bbe2e4: 		if (name.length() == 1 && name.charAt(0) == firstChar()) {
1:9bbe2e4: 			for (int i = 0; i < maxLength; i++) {
1:9bbe2e4: 				tempBuff.append(lastChar());
1:9bbe2e4: 			}
1:9bbe2e4: 			return tempBuff.toString();
1:9bbe2e4: 		}
1:9bbe2e4: 
1:a5430dd: 		// if String is all '000...0', eliminate one '0' and set the rest to 'z'
1:9bbe2e4: 		else {
1:9bbe2e4: 			boolean isAll0 = true;
1:9bbe2e4: 			for (int i = 0; i < buff.length(); i++) {
1:9bbe2e4: 				if (buff.charAt(i) != firstChar()) {
1:9bbe2e4: 					isAll0 = false;
1:9bbe2e4: 					break;
1:58a99b7: 				}
1:04014b2: 			} 
1:9bbe2e4: 			if (isAll0 == true) {
1:9bbe2e4: 				buff.deleteCharAt(0);
1:9bbe2e4: 				for (int i = 0; i < buff.length(); i++) {
1:9bbe2e4: 					buff.setCharAt(i, lastChar());
1:9bbe2e4: 				}
1:9bbe2e4: 			}
1:a5430dd: 			// if the String is not all '000...0', loop starting with the last
1:9bbe2e4: 			// char
1:9bbe2e4: 			else {
1:9bbe2e4: 				for (int i = buff.length() - 1; i >= 0; i--) {
1:a5430dd: 					// if this char is not '0'
1:9bbe2e4: 					if (buff.charAt(i) > firstChar()) {
1:a5430dd: 						// decrement this char
1:9bbe2e4: 						buff.setCharAt(i, previousChar(buff.charAt(i)));
1:9bbe2e4: 						break;
1:9bbe2e4: 					}
1:a5430dd: 					// Resetting the counter 000 -> zzz
1:a5430dd: 					// if this char is '0' and if the char before is not '0',
1:9bbe2e4: 					// set this char to 'z' and decrement the char before
1:cd2b901: 					else
1:9bbe2e4: 						buff.setCharAt(i, lastChar());
1:9bbe2e4: 					if (buff.charAt(i - 1) < firstChar()) {
1:9bbe2e4: 						buff.setCharAt(i - 1, previousChar(buff.charAt(i - 1)));
1:9bbe2e4: 						break;
1:9bbe2e4: 					}
1:9bbe2e4: 				}
1:9bbe2e4: 			}
1:9bbe2e4: 		}
1:9bbe2e4: 		return buff.toString();
1:9bbe2e4: 	}
1:9bbe2e4: 
1:9bbe2e4: 	private static char firstChar() {
1:9bbe2e4: 		return (char) 48;
1:9bbe2e4: 	}
1:9bbe2e4: 
1:9bbe2e4: 	private static char lastChar() {
1:9bbe2e4: 		return (char) 122;
1:9bbe2e4: 	}
1:9bbe2e4: 
1:9bbe2e4: 	private static char previousChar(char c) {
1:9bbe2e4: 		if (c <= 65 && c >= 59)
1:9bbe2e4: 			return (char) 57;
1:9bbe2e4: 		else if (c <= 97 && c >= 92)
1:9bbe2e4: 			return (char) 90;
3:9bbe2e4: 		else
1:9bbe2e4: 			return (char) (c - 1);
1:9bbe2e4: 	}
1:9bbe2e4: 
1:9bbe2e4: 	public static String increment(String name, int maxLength) {
1:9bbe2e4: 
1:a5430dd: 		// if (name.length() > maxLength) {
1:a5430dd: 		// //String greater than maxLength, so set it to '0'
1:a5430dd: 		// return "0";
1:a5430dd: 		// }
1:9bbe2e4: 		StringBuffer buff = new StringBuffer(name);
1:a5430dd: 		// check if the String is all 'zzz...z'
1:9bbe2e4: 		boolean isAllZ = true;
1:9bbe2e4: 		for (int i = 0; i < name.length(); i++) {
1:9bbe2e4: 			if (name.charAt(i) != lastChar()) {
1:9bbe2e4: 				isAllZ = false;
1:9bbe2e4: 				break;
1:9bbe2e4: 			}
1:9bbe2e4: 		}
1:a5430dd: 		// if the String is all 'zzz...z', check if it's the maximum length
1:9bbe2e4: 		if (isAllZ == true) {
1:9bbe2e4: 			if (name.length() >= maxLength) {
1:a5430dd: 				// String is all 'zzz...z' to maxLength, so set it to '0'
1:9bbe2e4: 				return "0";
1:9bbe2e4: 			} else {
1:a5430dd: 				// String is all 'zzz...z' but not maxLength, so set all to 0
1:9bbe2e4: 				// and append '0'
1:9bbe2e4: 				for (int i = 0; i < buff.length(); i++) {
1:9bbe2e4: 					buff.setCharAt(i, firstChar());
1:9bbe2e4: 				}
1:9bbe2e4: 				buff.append('0');
1:9bbe2e4: 			}
1:9bbe2e4: 		}
1:a5430dd: 		// if the String is not all 'zzz...z', loop starting with the last char
1:9bbe2e4: 		else {
1:9bbe2e4: 			for (int i = buff.length() - 1; i >= 0; i--) {
1:a5430dd: 				// if this char is not 'z'
1:9bbe2e4: 				if (buff.charAt(i) < lastChar()) {
1:a5430dd: 					// increment this char
1:9bbe2e4: 					buff.setCharAt(i, nextChar(buff.charAt(i)));
1:9bbe2e4: 					break;
1:9bbe2e4: 				}
1:9bbe2e4: 				// if this char is 'z' and if the char before is not 'z', set
1:9bbe2e4: 				// this char to '0' and increment the char before
1:9bbe2e4: 				else
1:9bbe2e4: 					buff.setCharAt(i, firstChar());
1:9bbe2e4: 				if (buff.charAt(i - 1) < lastChar()) {
1:9bbe2e4: 					buff.setCharAt(i - 1, nextChar(buff.charAt(i - 1)));
1:9bbe2e4: 					break;
1:9bbe2e4: 				}
1:9bbe2e4: 			}
1:9bbe2e4: 		}
1:9bbe2e4: 		return buff.toString();
1:9bbe2e4: 	}
1:9bbe2e4: 
1:9bbe2e4: 	private static char nextChar(char c) {
1:9bbe2e4: 		if (c <= 63 && c >= 57)
1:9bbe2e4: 			return (char) 65;
1:9bbe2e4: 		else if (c <= 95 && c >= 90)
1:9bbe2e4: 			return (char) 97;
1:9bbe2e4: 		else
1:9bbe2e4: 			return (char) (c + 1);
1:9bbe2e4: 	}
1:9bbe2e4: 
1:9bbe2e4: 	static void errorPrint(Throwable e) {
1:9bbe2e4: 		if (e instanceof SQLException)
1:9bbe2e4: 			SQLExceptionPrint((SQLException) e);
1:9bbe2e4: 		else {
1:9bbe2e4: 			System.out.println("A non SQL error occured.");
1:9bbe2e4: 			e.printStackTrace();
1:9bbe2e4: 		}
1:9bbe2e4: 	} // END errorPrint
1:9bbe2e4: 
1:a5430dd: 	// Iterates through a stack of SQLExceptions
1:9bbe2e4: 	static void SQLExceptionPrint(SQLException sqle) {
1:9bbe2e4: 		while (sqle != null) {
1:9bbe2e4: 			System.out.println("\n---SQLException Caught---\n");
1:9bbe2e4: 			System.out.println("SQLState:   " + (sqle).getSQLState());
1:9bbe2e4: 			System.out.println("Severity: " + (sqle).getErrorCode());
1:9bbe2e4: 			System.out.println("Message:  " + (sqle).getMessage());
1:9bbe2e4: 			sqle.printStackTrace();
1:9bbe2e4: 			sqle = sqle.getNextException();
1:9bbe2e4: 		}
1:9bbe2e4: 	}
1:9bbe2e4: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:4469400
/////////////////////////////////////////////////////////////////////////
1:             Class<?> clazz = Class.forName(System.getProperty("driver"));
1:             clazz.getConstructor().newInstance();
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:8d4cd27
/////////////////////////////////////////////////////////////////////////
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:9d44c9e
/////////////////////////////////////////////////////////////////////////
1: 			ArrayList<Integer> idArray = new ArrayList<Integer>();
/////////////////////////////////////////////////////////////////////////
1: 					idArray.add(rs1.getInt(1));
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:a216dfd
/////////////////////////////////////////////////////////////////////////
1: 	
/////////////////////////////////////////////////////////////////////////
1: 			MailJdbc.logAct
1: 			.logMsg(" \n*****************************************************");
1: 			MailJdbc.logAct
1: 			.logMsg("\n\n\tStarting the test in NetworkServer mode");
1: 			MailJdbc.logAct
1: 			.logMsg("\n\n*****************************************************");
/////////////////////////////////////////////////////////////////////////
1: 			
/////////////////////////////////////////////////////////////////////////
1: 	public static Connection getConnection(String usr, String passwd){
/////////////////////////////////////////////////////////////////////////
1: 		Statement attach_stmt = null;
1: 		int inbox_count = 0;
1: 		int attach_count = 0;
1: 			attach_stmt = conn.createStatement();
1: 			ResultSet rs1 = attach_stmt.executeQuery(Statements.getRowCountAttach);
1: 				inbox_count = rs.getInt(1);
1: 				attach_count = rs1.getInt(1);
1: 			if (inbox_count == 0)
1: 							+ inbox_count);
1: 					+ "The number of mails in the REFRESH.ATTACH are : "
1: 					+ attach_count);
1: 			attach_stmt.close();
/////////////////////////////////////////////////////////////////////////
1: 			int inbox_id = 0;
1: 			if((inbox_count - 1) <= 0)
1: 				inbox_id = 1;
1: 			else {
1: 				 inbox_id = Rn.nextInt(inbox_count - 1);
1: 				 if (inbox_id == 0)
1: 					 inbox_id = 1;
1: 			}
1: 
1: 			ResultSet inbox_rs = stmt
1: 					.executeQuery("select message from REFRESH.INBOX where id  = "
1: 							+ inbox_id);
1: 			
1: 			if (inbox_rs.next()) {
1: 				size = inbox_rs.getClob(1).length();
1: 						+ "size of the message for id " + inbox_id + " is : "
1: 						+ "mail with the id " + inbox_id + " does not exist");
1: 			inbox_rs.close();
1: 			ResultSet attach_rs = stmt
1: 					.executeQuery("select attachment from REFRESH.attach where id  = "
1: 							+ inbox_id);
1: 			long start = System.currentTimeMillis();
1: 			if (attach_rs.next()) {
1: 				size = attach_rs.getBlob(1).length();
1: 				MailJdbc.logAct.logMsg(LogFile.INFO + thread_name + " : "
1: 						+ "size of the attachment for id " + inbox_id
1: 						+ " is : " + size);
1: 			} else
1: 				MailJdbc.logAct.logMsg(LogFile.INFO + thread_name + " : "
1: 						+ "no attachment");
1: 			attach_rs.close();
1:    			stmt.close();
1: 			long end = System.currentTimeMillis();
1: 			log.logMsg(LogFile.INFO + thread_name + " : "
1: 					+ "Time taken to get the blob :"
1: 					+ PerfTime.readableTime(end - start));
/////////////////////////////////////////////////////////////////////////
1: 		// Delete done by the user. The user will mark the mails to be deleted
1: 	
1: 					.executeQuery("select max(id) from REFRESH.INBOX ");
1: 			rs.close();
1: 			stmt.close();
1: 			{
1: 			    id = Rn.nextInt(id_count - 1);
1: 			    if (id == 0)
1: 			    	id = 1;
1: 			}
1: 				updateUser.setInt(2, i);
1: 					+ " Time taken to mark " + id + " mails to be deleted :"
1: 					+ "The number of mails marked to be deleted from REFRESH.INBOX is: "
1: 					+ "Exception while deleting mail REFRESH.INBOX"
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 					+ " rows deleted from REFRESH.INBOX");
1: 					+ "Exception while deleting mail from REFRESH.INBOX, REFRESH.ATTACH by Thread: "
/////////////////////////////////////////////////////////////////////////
1:                 //If there is zero row, nothing to do	
1: 				if (count==0)
1: 					return;
1: 				//If there is just one row, id is 1 (start from 1)
1: 				if (count <= 1) 
1: 					message_id = 1;
1: 				if (message_id == 0)
1: 					message_id = 1;
1: 				//Assign the folder to be between 1 to 5
1: 				int folder_id = Rn.nextInt(5 - 1);
1: 				if (folder_id == 0)
1: 					folder_id = 1;
/////////////////////////////////////////////////////////////////////////
1: 						+ " is moved to folder" + folder_id);
/////////////////////////////////////////////////////////////////////////
1: 		// Inserting rows to the inbox table. 
1: 		// inbox table would have random attachments - (attach table)
1: 		// The random attachment depends on no of rows id in inbox
/////////////////////////////////////////////////////////////////////////
1: 			long total_ins_inb = 0;
1: 			long total_ins_att = 0;
1: 			int row_count = 0;
1: 			int num = Rn.nextInt(10 - 1);
1: 			if (num == 0) 
1: 				num = 1;
1: 				long s_insert = System.currentTimeMillis();
/////////////////////////////////////////////////////////////////////////
0: 								5,
1: 				streamReader.close();
1: 				long e_insert = System.currentTimeMillis();
1: 				total_ins_inb = total_ins_inb + (e_insert - s_insert);
1: 				PreparedStatement insertAttach = conn
1: 				Statement stmt1 = conn.createStatement();
1: 				ResultSet rs = insertFirst.getGeneratedKeys();
1: 				//10/1 chance to have attactment
1: 				int numa = Rn.nextInt(10 - 1);
1: 				if (numa == 0)
1: 					numa = 1;
1: 				if (i == numa) {
1: 					int attachid  = 0;
1: 				while (rs.next()) {
1: 					attachid = rs.getInt(1);	
1: 				}
1: 				// insert from 1 to 5 attachments
1: 				int num_attach = Rn.nextInt(5 - 1);
1: 				if (num_attach == 0)
1: 					num_attach = 1;
1: 				for (int j = 0; j < num_attach; j++) { 
1: 					long a_start = System.currentTimeMillis();
1: 					insertAttach.setInt(1, attachid);
1: 					//attach_id should be automatically generated
1: 					try {
1: 						// to create a stream of random length between 0 and 5M
1: 						int blobLength = Rn.nextInt(5130000 - 0 + 1) + 0;
1: 						streamIn = new LoopingAlphabetStream(blobLength);
1: 						insertAttach.setBinaryStream(2, streamIn, blobLength);
1: 					} catch (Exception e) {
1: 						MailJdbc.logAct.logMsg(LogFile.ERROR + thread_name + " : "
1: 						errorPrint(e);
1: 						throw e;
1: 					}
1: 					int result_attach = insertAttach.executeUpdate();
1: 					streamIn.close();
1: 					if (result_attach != 0) {
1: 						blob_count = blob_count + 1;
1: 						row_count++;
1: 					}
1: 					long a_end = System.currentTimeMillis();
1: 					total_ins_att = total_ins_att + (a_end - a_start);
1: 				 }
1: 			} 
1: 			log.logMsg(LogFile.INFO + thread_name + " : "
1: 					+ "Time taken to insert " + num + " rows to REFRESH.INBOX :"
1: 					+ PerfTime.readableTime(total_ins_inb));
1: 			log.logMsg(LogFile.INFO + thread_name + " : "
1: 					+ "Time taken to insert " + row_count + " rows to REFRESH.ATTACH :"			
1: 					+ PerfTime.readableTime(total_ins_att));
1: 			insertFirst.close();
1: 		}
1: 		catch (SQLException sqe) {
1: 			MailJdbc.logAct.logMsg(LogFile.ERROR + thread_name + " : "
1: 					+ "Error while inserting REFRESH.ATTACH:" + sqe.getMessage());
/////////////////////////////////////////////////////////////////////////
1: 				+ "delete mails which are older than 1 day with sleep 250000 ");
1: 			selExp.close();
1: 			conn.commit();
1: 					+ PerfTime.readableTime(s_delExp) + " : "
1: 					+ "Time taken to delete " + count + " mails :"
/////////////////////////////////////////////////////////////////////////
1: 				+ " " + PerfTime.readableTime(e_compress - s_compress));
/////////////////////////////////////////////////////////////////////////
1: 			//Generate the random number between (count - 36)==>24 to 1
1: 			if (count > 50) {
1: 				diff = Rn.nextInt((count - 36) - 1);
1: 				if (diff == 0) 
1: 					diff = 1;
/////////////////////////////////////////////////////////////////////////
1: 							+ stmt2
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	public void totals(String thread_name) {
1: 		MailJdbc.logAct.logMsg(LogFile.INFO + thread_name + " : " + "total number of inserts : "
1: 		MailJdbc.logAct.logMsg(LogFile.INFO + thread_name + " : " + "total number of deletes : "
1: 		//This number does not fit into reality. Reader should use 
1: 		//number of rows in REFRESH.ATTACH.
1: 		MailJdbc.logAct.logMsg(LogFile.INFO + thread_name + " : "
1: 				+ "total number of blobs had inserted : " + blob_count);
commit:d9e100c
/////////////////////////////////////////////////////////////////////////
1: 		long dbsize = databaseSize(new File("mailsdb"));
/////////////////////////////////////////////////////////////////////////
1: 		dbsize = databaseSize(new File("mailsdb"));
/////////////////////////////////////////////////////////////////////////
1: 	public static long databaseSize(File dbname) {
1: 	    long length = 0;
1: 	    if (dbname.isDirectory()) {
1: 	        String[] children = dbname.list();
1: 	        for (int i=0; i<children.length; i++) 
1: 	            length = length + databaseSize(new File(dbname, children[i]));
1: 	        return length;
1: 	    }
1: 	    else
1: 	        return dbname.length();	
commit:934f02d
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * jdbcLoad - Create url, schema and set driver and database system property that will be use later in the test.
1: 	 * @param driverType - "embedded" or "NetworkServer" 
1: 	 * @param useexistingdb - whether to use existing database or not
1: 	 */
1: 	public static void jdbcLoad(String driverType, boolean useexistingdb) {
/////////////////////////////////////////////////////////////////////////
1: 			if (useexistingdb)
1: 		        setSystemProperty("database", "jdbc:derby:mailsdb");
1: 			else
1: 		        setSystemProperty("database", "jdbc:derby:mailsdb;create=true");			
1: 			if (useexistingdb)
1: 				setSystemProperty("database",
1: 					"jdbc:derby://localhost:1527/mailsdb");
1: 			else
1: 				setSystemProperty("database",
1: 					"jdbc:derby://localhost:1527/mailsdb;create=true");
1: 			setSystemProperty("ij.user", "REFRESH");
1: 			setSystemProperty("ij.password", "Refresh");
/////////////////////////////////////////////////////////////////////////
1: 			if (useexistingdb)
1: 			{
1: 				MailJdbc.logAct
1: 				.logMsg("Useing the existing database...");
1: 				return;
1: 			}
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:58a99b7
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 			// database and the backup database
/////////////////////////////////////////////////////////////////////////
0: 	public  static Connection getConnection(String usr, String passwd){
/////////////////////////////////////////////////////////////////////////
1: 	public void readMail(Connection conn, String thread_name) throws Exception{
1: 		// Getting the number of rows in the table and getting the
1: 		boolean saveAutoCommit = conn.getAutoCommit();
1: 		int saveIsolation = conn.getTransactionIsolation();
1: 			conn.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);
/////////////////////////////////////////////////////////////////////////
1: 			conn.rollback();
1: 			throw sqe;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 			conn.rollback();
1: 			throw sqe;
1: 		}
1: 		finally{
1: 			conn.setAutoCommit(saveAutoCommit);
1: 			conn.setTransactionIsolation(saveIsolation);
1: 	public synchronized void deleteMailByUser (Connection conn,
1: 			String thread_name) throws Exception{
1: 		boolean saveAutoCommit = conn.getAutoCommit();
/////////////////////////////////////////////////////////////////////////
1: 			conn.rollback();
1: 			throw sqe;
1: 		}
1: 		finally{
1: 			conn.setAutoCommit(saveAutoCommit);
1: 		boolean saveAutoCommit = conn.getAutoCommit();
/////////////////////////////////////////////////////////////////////////
1: 			conn.rollback();
1: 			throw sqe;
1: 		}
1: 		finally{
1: 			conn.setAutoCommit(saveAutoCommit);
1: 	public void moveToFolders(Connection conn, String thread_name) throws Exception{
1: 		boolean saveAutoCommit = conn.getAutoCommit();
/////////////////////////////////////////////////////////////////////////
1: 			conn.rollback();
1: 			throw sqe;
1: 		finally{
1: 			conn.setAutoCommit(saveAutoCommit);
1: 		}
/////////////////////////////////////////////////////////////////////////
1: 		boolean saveAutoCommit = conn.getAutoCommit();
1: 		int saveIsolation = conn.getTransactionIsolation();
/////////////////////////////////////////////////////////////////////////
0: 					conn.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
/////////////////////////////////////////////////////////////////////////
1: 			conn.rollback();
1: 			throw sqe;
/////////////////////////////////////////////////////////////////////////
1: 			conn.rollback();
1: 			throw sqe;
1: 		}
1: 		finally{
1: 			conn.setTransactionIsolation(saveIsolation);
1: 			conn.setAutoCommit(saveAutoCommit);
1: 	public synchronized void deleteMailByExp(Connection conn, String thread_name) throws Exception{
1: 		boolean saveAutoCommit = conn.getAutoCommit();
/////////////////////////////////////////////////////////////////////////
0: 			conn.rollback();
0: 			throw sqe;
1: 		}
1: 		finally {
1: 			conn.setAutoCommit(saveAutoCommit);
1: 	public void Backup(Connection conn, String thread_name) throws Exception{
1: 		boolean saveAutoCommit = conn.getAutoCommit();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		finally{
1: 			conn.setAutoCommit(saveAutoCommit);
1: 		}
/////////////////////////////////////////////////////////////////////////
1: 			String thread_name) throws Exception
1: 	// periodically compresses the table to get back the free spaces available
/////////////////////////////////////////////////////////////////////////
1: 		boolean saveAutoCommit = conn.getAutoCommit();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		finally{
1: 		    conn.setAutoCommit(saveAutoCommit);
1: 		}
/////////////////////////////////////////////////////////////////////////
1: 	public void grantRevoke(Connection conn, String thread_name) throws Exception{
1: 		boolean saveAutoCommit = conn.getAutoCommit();
1: 			// Giving appropriate permission to each threads
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		finally {
1: 			conn.setAutoCommit(saveAutoCommit);
1: 		}
/////////////////////////////////////////////////////////////////////////
1: 			} 
commit:04014b2
/////////////////////////////////////////////////////////////////////////
0: import java.util.Properties;
/////////////////////////////////////////////////////////////////////////
0: 	static boolean saveAutoCommit;
1: 
/////////////////////////////////////////////////////////////////////////
0: 			// database and the backup datatbase
/////////////////////////////////////////////////////////////////////////
0: 	public void readMail(Connection conn, String thread_name) {
0: 		// Getiing the number of rows in the table and getting the
0: 			saveAutoCommit = conn.getAutoCommit();
0: 			conn
0: 					.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);
/////////////////////////////////////////////////////////////////////////
1: 			try {
0: 				conn.rollback();
0: 			} catch (SQLException sq) {
1: 				MailJdbc.logAct.logMsg(LogFile.ERROR + thread_name + " : "
0: 						+ "Exception while rolling back: " + sq);
0: 				errorPrint(sq);
0: 				sq.printStackTrace();
1: 			}
/////////////////////////////////////////////////////////////////////////
0: 			conn.setAutoCommit(saveAutoCommit);
/////////////////////////////////////////////////////////////////////////
1: 			try {
0: 				conn.rollback();
0: 			} catch (SQLException sq) {
1: 				MailJdbc.logAct.logMsg(LogFile.ERROR + thread_name + " : "
0: 						+ "Exception while rolling back: " + sq);
0: 				sq.printStackTrace();
0: 				errorPrint(sq);
1: 			}
0: 	public synchronized void deleteMailByUser(Connection conn,
0: 			String thread_name) {
0: 			saveAutoCommit = conn.getAutoCommit();
/////////////////////////////////////////////////////////////////////////
0: 			conn.setAutoCommit(saveAutoCommit);
1: 			try {
0: 				conn.rollback();
0: 			} catch (SQLException sq) {
1: 				MailJdbc.logAct.logMsg(LogFile.ERROR + thread_name + " : "
0: 						+ "Exception while rolling back: " + sq);
0: 				sq.printStackTrace();
0: 				errorPrint(sq);
1: 			}
0: 			saveAutoCommit = conn.getAutoCommit();
/////////////////////////////////////////////////////////////////////////
0: 			conn.setAutoCommit(saveAutoCommit);
1: 			try {
0: 				conn.rollback();
0: 			} catch (SQLException sq) {
1: 				MailJdbc.logAct.logMsg(LogFile.ERROR + thread_name + " : "
0: 						+ "Exception while rolling back: " + sq);
0: 				sq.printStackTrace();
0: 				errorPrint(sq);
0: 				throw sqe;
1: 			}
0: 	public void moveToFolders(Connection conn, String thread_name) {
0: 			saveAutoCommit = conn.getAutoCommit();
/////////////////////////////////////////////////////////////////////////
0: 			conn.setAutoCommit(saveAutoCommit);
1: 			try {
0: 				conn.rollback();
0: 			} catch (SQLException sq) {
1: 				MailJdbc.logAct.logMsg(LogFile.ERROR + thread_name + " : "
0: 						+ "Exception while rolling back: " + sq);
0: 				sq.printStackTrace();
0: 				errorPrint(sq);
1: 			}
1: 
/////////////////////////////////////////////////////////////////////////
0: 			saveAutoCommit = conn.getAutoCommit();
/////////////////////////////////////////////////////////////////////////
0: 					conn
0: 							.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
/////////////////////////////////////////////////////////////////////////
1: 			try {
0: 				conn.rollback();
0: 			} catch (SQLException sq) {
1: 				MailJdbc.logAct.logMsg(LogFile.INFO + thread_name + " : "
0: 						+ "Exception while rolling back: " + sq);
0: 				sq.printStackTrace();
0: 				errorPrint(sq);
0: 				throw sqe;
1: 			}
/////////////////////////////////////////////////////////////////////////
0: 			conn.setAutoCommit(saveAutoCommit);
1: 			try {
0: 				conn.rollback();
0: 			} catch (SQLException sq) {
1: 				MailJdbc.logAct.logMsg(LogFile.INFO + thread_name + " : "
0: 						+ "Exception while rolling back: " + sq);
0: 				sq.printStackTrace();
0: 				errorPrint(sq);
0: 				throw sqe;
1: 			}
0: 	public synchronized void deleteMailByExp(Connection conn, String thread_name) {
0: 			saveAutoCommit = conn.getAutoCommit();
/////////////////////////////////////////////////////////////////////////
0: 			conn.setAutoCommit(saveAutoCommit);
1: 			try {
0: 				conn.rollback();
0: 			} catch (SQLException sq) {
1: 				MailJdbc.logAct.logMsg(LogFile.ERROR + thread_name + " : "
0: 						+ "Exception while rolling back: " + sq);
0: 				sq.printStackTrace();
0: 				errorPrint(sq);
1: 			}
0: 	public void Backup(Connection conn, String thread_name) {
0: 			saveAutoCommit = conn.getAutoCommit();
/////////////////////////////////////////////////////////////////////////
0: 			conn.setAutoCommit(saveAutoCommit);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 			String thread_name)
0: 	// preiodically compresses the table to get back the free spaces available
/////////////////////////////////////////////////////////////////////////
0: 			boolean saveAutoCommit = conn.getAutoCommit();
/////////////////////////////////////////////////////////////////////////
0: 			conn.setAutoCommit(saveAutoCommit);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 	public void grantRevoke(Connection conn, String thread_name) {
0: 			// Giving appropriate permission to eahc threads
0: 			saveAutoCommit = conn.getAutoCommit();
/////////////////////////////////////////////////////////////////////////
0: 			conn.setAutoCommit(saveAutoCommit);
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 			}
commit:63e167e
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 			// database and the backup database
/////////////////////////////////////////////////////////////////////////
0: 	public void readMail(Connection conn, String thread_name) throws Exception{
0: 		// Getting the number of rows in the table and getting the
0: 		boolean saveAutoCommit = conn.getAutoCommit();
0: 		int saveIsolation = conn.getTransactionIsolation();
0: 			conn.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);
/////////////////////////////////////////////////////////////////////////
0: 			conn.rollback();
0: 			throw sqe;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 			conn.rollback();
0: 			throw sqe;
1: 		}
0: 		finally{
0: 			conn.setAutoCommit(saveAutoCommit);
0: 			conn.setTransactionIsolation(saveIsolation);
0: 	public synchronized void deleteMailByUser (Connection conn,
0: 			String thread_name) throws Exception{
0: 		boolean saveAutoCommit = conn.getAutoCommit();
/////////////////////////////////////////////////////////////////////////
0: 			conn.rollback();
0: 			throw sqe;
1: 		}
0: 		finally{
0: 			conn.setAutoCommit(saveAutoCommit);
0: 		boolean saveAutoCommit = conn.getAutoCommit();
/////////////////////////////////////////////////////////////////////////
0: 			conn.rollback();
0: 			throw sqe;
1: 		}
0: 		finally{
0: 			conn.setAutoCommit(saveAutoCommit);
0: 	public void moveToFolders(Connection conn, String thread_name) throws Exception{
0: 		boolean saveAutoCommit = conn.getAutoCommit();
/////////////////////////////////////////////////////////////////////////
0: 			conn.rollback();
0: 			throw sqe;
0: 		finally{
0: 			conn.setAutoCommit(saveAutoCommit);
1: 		}
/////////////////////////////////////////////////////////////////////////
0: 		boolean saveAutoCommit = conn.getAutoCommit();
0: 		int saveIsolation = conn.getTransactionIsolation();
/////////////////////////////////////////////////////////////////////////
0: 					conn.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
/////////////////////////////////////////////////////////////////////////
0: 			conn.rollback();
0: 			throw sqe;
/////////////////////////////////////////////////////////////////////////
0: 			conn.rollback();
0: 			throw sqe;
1: 		}
0: 		finally{
0: 			conn.setTransactionIsolation(saveIsolation);
0: 			conn.setAutoCommit(saveAutoCommit);
0: 	public synchronized void deleteMailByExp(Connection conn, String thread_name) throws Exception{
0: 		boolean saveAutoCommit = conn.getAutoCommit();
/////////////////////////////////////////////////////////////////////////
0: 			conn.rollback();
0: 			throw sqe;
1: 		}
0: 		finally {
0: 			conn.setAutoCommit(saveAutoCommit);
0: 	public void Backup(Connection conn, String thread_name) throws Exception{
0: 		boolean saveAutoCommit = conn.getAutoCommit();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 		finally{
0: 			conn.setAutoCommit(saveAutoCommit);
1: 		}
/////////////////////////////////////////////////////////////////////////
0: 			String thread_name) throws Exception
0: 	// periodically compresses the table to get back the free spaces available
/////////////////////////////////////////////////////////////////////////
0: 		boolean saveAutoCommit = conn.getAutoCommit();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 		finally{
0: 		    conn.setAutoCommit(saveAutoCommit);
1: 		}
/////////////////////////////////////////////////////////////////////////
0: 	public void grantRevoke(Connection conn, String thread_name) throws Exception{
0: 		boolean saveAutoCommit = conn.getAutoCommit();
0: 			// Giving appropriate permission to each threads
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 		finally {
0: 			conn.setAutoCommit(saveAutoCommit);
1: 		}
/////////////////////////////////////////////////////////////////////////
1: 			} 
commit:cd2b901
/////////////////////////////////////////////////////////////////////////
0: 			int attach_id = 0;
0: 			if((count - 1) <= 0)
0: 				attach_id = 0;
1: 			else
0: 				 attach_id = Rn.nextInt(count - 1);
/////////////////////////////////////////////////////////////////////////
1: 		int id = 0;
0: 		int for_id = 0;
/////////////////////////////////////////////////////////////////////////
1: 			if((id_count -1) <= 0 )
1: 				id = id_count;
1: 			else
0: 				id = Rn.nextInt(id_count - 1);
1: 				if((id_count -1) <= 0 )
0: 					for_id = id_count;
1: 				else
0: 					for_id = Rn.nextInt(id_count - 1);
/////////////////////////////////////////////////////////////////////////
1: 				int message_id = 0;
0: 				if (count == 0)
0: 					message_id = 0;
1: 				else
1: 				    message_id = Rn.nextInt(count - 1);
/////////////////////////////////////////////////////////////////////////
commit:9bbe2e4
/////////////////////////////////////////////////////////////////////////
1: /*
1:  *
1:  * Derby - Class org.apache.derbyTesting.system.mailjdbc.utils.DbTasks
1:  *
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements. See the NOTICE file distributed with this
1:  * work for additional information regarding copyright ownership. The ASF
1:  * licenses this file to You under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance with the License.
1:  * You may obtain a copy of the License at
1:  *
1:  * http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
1:  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
1:  * License for the specific language governing permissions and limitations under
1:  * the License.
1:  *
1:  */
1: package org.apache.derbyTesting.system.mailjdbc.utils;
1: /**
0:  * This class is used all other classes for various tasks like insert, delete, backup etc
1:  */
0: import java.io.BufferedReader;
1: import java.io.File;
0: import java.io.FileInputStream;
0: import java.io.FileNotFoundException;
0: import java.io.FileReader;
1: import java.io.InputStream;
1: import java.sql.CallableStatement;
1: import java.sql.Connection;
1: import java.sql.DriverManager;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: import java.sql.Statement;
1: import java.sql.Timestamp;
1: import java.util.ArrayList;
0: import java.util.Properties;
1: 
1: import org.apache.derbyTesting.system.mailjdbc.MailJdbc;
1: 
0: public class DbTasks extends Thread {
0: 	private static Process pr;
1: 
1: 	public static LogFile log = new LogFile("performance.out");
1: 
0: 	static boolean saveAutoCommit;
1: 
1: 	private static int id_count = 0;
1: 
1: 	public static int insert_count = 0;
1: 
1: 	public static int delete_count = 0;
1: 
1: 	public static int clob_count = 0;
1: 
1: 	public static int blob_count = 0;
1: 
0: 	public static Properties prop = new Properties();
1: 
0: 	public static void jdbcLoad(String driverType) {
0: 		String type = driverType;
1: 		if (driverType.equalsIgnoreCase("embedded")) {
1: 			setSystemProperty("driver", "org.apache.derby.jdbc.EmbeddedDriver");
1: 			MailJdbc.logAct
1: 					.logMsg(" \n*****************************************************");
1: 			MailJdbc.logAct.logMsg("\n\n\tStarting the test in Embedded mode");
1: 			MailJdbc.logAct
1: 					.logMsg("\n\n*****************************************************");
0: 			//setting the properties like user, password etc for both the
0: 			// database and the backup datatbase
0: 			setSystemProperty("database", "jdbc:derby:mailsdb;create=true");
1: 			setSystemProperty("ij.user", "REFRESH");
1: 			setSystemProperty("ij.password", "Refresh");
0: 			setSystemProperty("backup_database",
0: 					"jdbc:derby:/mailjdbc/mailbackup/mailsdb");
1: 		} else {
1: 			setSystemProperty("driver", "org.apache.derby.jdbc.ClientDriver");
0: 			setSystemProperty("database",
0: 					"jdbc:derby://localhost:1527/mailsdb;create=true;user=REFRESH;password=Refresh");
1: 		}
1: 		try {
1: 			// Create the schema (tables)
1: 			long s_schema = System.currentTimeMillis();
1: 			org.apache.derby.tools.ij
1: 					.main(new String[] { "-fr",
1: 							"/org/apache/derbyTesting/system/mailjdbc/schema/schema.sql" });
1: 			long e_schema = System.currentTimeMillis();
1: 			log
1: 					.logMsg(" \n*****************************************************");
1: 			log.logMsg("\n\n\tPerformance Info for the Test on" + s_schema);
1: 			log
1: 					.logMsg("\n\n*****************************************************");
1: 			log.logMsg(LogFile.INFO + "Schema Creation :"
1: 					+ PerfTime.readableTime(e_schema - s_schema));
1: 			System.out.println("created the schema");
1: 		} catch (Exception e) {
1: 			log.logMsg(LogFile.ERROR
1: 					+ "Exception while running loading and creating tables: "
1: 					+ e.getMessage());
1: 			e.printStackTrace();
1: 			errorPrint(e);
1: 		}
1: 
1: 	}
1: 
0: 	public static Connection getConnection(String usr, String passwd) {
1: 		try {
0: 			//Returns the Connection object
0: 			Class.forName(System.getProperty("driver")).newInstance();
0: 			prop.setProperty("user", usr);
0: 			prop.setProperty("password", passwd);
1: 			Connection con = DriverManager.getConnection(System
0: 					.getProperty("database"), prop);
1: 			return con;
1: 		} catch (Exception e) {
1: 			log.logMsg(LogFile.ERROR
1: 					+ "Error while getting connection for threads:"
1: 					+ e.getMessage());
1: 			e.printStackTrace();
1: 			errorPrint(e);
1: 			return null;
1: 		}
1: 	}
1: 
0: 	public void readMail(Connection conn, String thread_name) {
0: 		//This function will be reading mails from the inbox.
0: 		//Getiing the number of rows in the table and getting the
0: 		//size of the attachment (Blob) for a randomly selected row
1: 		Statement stmt = null;
0: 		Statement stmt1 = null;
1: 		int count = 0;
0: 		int count1 = 0;
1: 		long size = 0;
1: 		try {
0: 			saveAutoCommit = conn.getAutoCommit();
1: 			conn.setAutoCommit(false);
0: 			conn
0: 					.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);
1: 			long s_select = System.currentTimeMillis();
1: 			stmt = conn.createStatement();
0: 			stmt1 = conn.createStatement();
1: 			ResultSet rs = stmt.executeQuery(Statements.getRowCount);
0: 			ResultSet rs1 = stmt1.executeQuery(Statements.getRowCountAtach);
1: 			while (rs.next()) {
1: 				count = rs.getInt(1);
1: 			}
1: 			while (rs1.next()) {
0: 				count1 = rs1.getInt(1);
1: 			}
0: 			if (count == 0)
1: 				MailJdbc.logAct.logMsg(LogFile.INFO + thread_name + " : "
1: 						+ "Inbox is empty");
1: 			long e_select = System.currentTimeMillis();
1: 			MailJdbc.logAct
1: 					.logMsg(LogFile.INFO + thread_name + " : "
1: 							+ "The number of mails in the REFRESH.INBOX are : "
0: 							+ count);
1: 			MailJdbc.logAct.logMsg(LogFile.INFO + thread_name + " : "
0: 					+ "The number of mails in the attachment table are : "
0: 					+ count1);
1: 			log.logMsg(LogFile.INFO + thread_name + " : "
1: 					+ "Time taken to scan the entire REFRESH.INBOX for count :"
1: 					+ PerfTime.readableTime(e_select - s_select));
0: 			if (rs != null)
1: 				rs.close();
0: 			if (stmt != null)
1: 				stmt1.close();
0: 			if (rs1 != null)
1: 				rs1.close();
1: 		} catch (SQLException sqe) {
1: 			MailJdbc.logAct.logMsg(LogFile.ERROR + thread_name + " : "
1: 					+ "SQL Exception while reading : " + sqe.getMessage());
1: 			sqe.printStackTrace();
1: 			errorPrint(sqe);
1: 			try {
0: 				conn.rollback();
0: 			} catch (SQLException sq) {
1: 				MailJdbc.logAct.logMsg(LogFile.ERROR + thread_name + " : "
0: 						+ "Exception while rolling back: " + sq);
0: 				errorPrint(sq);
0: 				sq.printStackTrace();
1: 			}
1: 		}
1: 		try {
0: 			int attach_id = (int) ((Math.random() * count));
1: 			ResultSet rs = stmt
0: 					.executeQuery("select attachment from REFRESH.attach where id  = "
0: 							+ attach_id);
0: 			long start = System.currentTimeMillis();
0: 			if (rs.next()) {
0: 				size = rs.getBlob(1).length();
1: 				MailJdbc.logAct.logMsg(LogFile.INFO + thread_name + " : "
0: 						+ "size of the attachment for id " + attach_id
0: 						+ " is : " + size);
1: 			} else
1: 				MailJdbc.logAct.logMsg(LogFile.INFO + thread_name + " : "
0: 						+ "no attachment");
0: 			if (rs != null)
1: 				rs.close();
1: 
0: 			long end = System.currentTimeMillis();
1: 			log.logMsg(LogFile.INFO + thread_name + " : "
0: 					+ "Time taken to get the blob :"
0: 					+ PerfTime.readableTime(end - start));
0: 			rs = stmt
0: 					.executeQuery("select message from REFRESH.INBOX where id  = "
0: 							+ attach_id);
1: 			long start_t = System.currentTimeMillis();
0: 			if (rs.next()) {
0: 				size = rs.getClob(1).length();
1: 				MailJdbc.logAct.logMsg(LogFile.INFO + thread_name + " : "
0: 						+ "size of the message for id " + attach_id + " is : "
1: 						+ size);
1: 			} else
1: 				MailJdbc.logAct.logMsg(LogFile.INFO + thread_name + " : "
0: 						+ "mail with the id " + attach_id + " does not exist");
1: 			long end_t = System.currentTimeMillis();
1: 			log.logMsg(LogFile.INFO + thread_name + " : "
1: 					+ "Time taken to get the clob :"
1: 					+ PerfTime.readableTime(end_t - start_t));
0: 			if (rs != null)
1: 				rs.close();
0: 			if (stmt != null)
1: 				stmt.close();
1: 			conn.commit();
0: 			conn.setAutoCommit(saveAutoCommit);
1: 		} catch (SQLException sqe) {
1: 			MailJdbc.logAct
1: 					.logMsg(LogFile.ERROR
1: 							+ thread_name
1: 							+ " : "
1: 							+ "SQL Exception while getting the message and attach size : "
1: 							+ sqe.getMessage());
1: 			sqe.printStackTrace();
1: 			errorPrint(sqe);
1: 			try {
0: 				conn.rollback();
0: 			} catch (SQLException sq) {
1: 				MailJdbc.logAct.logMsg(LogFile.ERROR + thread_name + " : "
0: 						+ "Exception while rolling back: " + sq);
0: 				sq.printStackTrace();
0: 				errorPrint(sq);
1: 			}
1: 		}
1: 
1: 	}
1: 
0: 	public synchronized void deleteMailByUser(Connection conn,
0: 			String thread_name) {
0: 		//Delete done by the user. Thre user will mark the mails to be deleted
0: 		// and then
1: 		int id_count = 0;
1: 		try {
0: 			saveAutoCommit = conn.getAutoCommit();
1: 			conn.setAutoCommit(false);
1: 			PreparedStatement updateUser = conn
1: 					.prepareStatement(Statements.updateStr);
1: 			Statement stmt = conn.createStatement();
1: 			ResultSet rs = stmt
0: 					.executeQuery("select max(id)from REFRESH.INBOX ");
1: 			if (rs.next())
1: 				id_count = rs.getInt(1);
1: 			short to_delete = 1;
0: 			int id = (int) ((Math.random() * id_count));
1: 			long s_update = System.currentTimeMillis();
1: 			int delete_count = 0;
1: 			for (int i = 0; i < id; i++) {
1: 				updateUser.setShort(1, to_delete);
0: 				int for_id = (int) ((Math.random() * id_count));
0: 				updateUser.setInt(2, for_id);
1: 				int del = updateUser.executeUpdate();
1: 				delete_count = delete_count + del;
1: 			}
1: 			long e_update = System.currentTimeMillis();
1: 			log.logMsg(LogFile.INFO + thread_name + " : "
0: 					+ " Time taken to mark the mails to be deleted :"
1: 					+ PerfTime.readableTime(e_update - s_update));
1: 			MailJdbc.logAct.logMsg(LogFile.INFO + thread_name + " : "
0: 					+ "The number of mails marked to be deleted  by user:"
1: 					+ delete_count);
0: 			if (rs != null)
1: 				rs.close();
0: 			if (updateUser != null)
1: 				updateUser.close();
0: 			if (stmt != null)
1: 				stmt.close();
1: 			conn.commit();
0: 			conn.setAutoCommit(saveAutoCommit);
1: 		} catch (SQLException sqe) {
1: 			MailJdbc.logAct.logMsg(LogFile.ERROR + thread_name + " : "
0: 					+ "Exception while deleting mail by user: "
1: 					+ sqe.getMessage());
1: 			sqe.printStackTrace();
1: 			errorPrint(sqe);
1: 			try {
0: 				conn.rollback();
0: 			} catch (SQLException sq) {
1: 				MailJdbc.logAct.logMsg(LogFile.ERROR + thread_name + " : "
0: 						+ "Exception while rolling back: " + sq);
0: 				sq.printStackTrace();
0: 				errorPrint(sq);
1: 			}
1: 		}
1: 	}
1: 
1: 	public void deleteMailByThread(Connection conn, String thread_name)
1: 			throws Exception {
0: 		//Deleting mails which are marked to be deleted
1: 		try {
0: 			boolean saveAutoCommit = conn.getAutoCommit();
1: 			conn.setAutoCommit(false);
1: 			PreparedStatement deleteThread = conn
1: 					.prepareStatement(Statements.deleteStr);
1: 			Statement stmt = conn.createStatement();
1: 			ResultSet rs = stmt
0: 					.executeQuery("select count(*) from REFRESH.INBOX where to_delete=1");
1: 			long s_delete = System.currentTimeMillis();
1: 			int count = 0;
1: 			count = deleteThread.executeUpdate();
1: 			long e_delete = System.currentTimeMillis();
1: 			log.logMsg(LogFile.INFO + thread_name + " : "
1: 					+ "Time taken to delete mails by thread :"
1: 					+ PerfTime.readableTime(e_delete - s_delete));
1: 			MailJdbc.logAct.logMsg(LogFile.INFO + thread_name + " : " + count
0: 					+ " rows deleted");
1: 			delete_count = delete_count + count;
0: 			if (deleteThread != null)
1: 				deleteThread.close();
0: 			if (rs != null)
1: 				rs.close();
0: 			if (stmt != null)
1: 				stmt.close();
1: 			conn.commit();
0: 			conn.setAutoCommit(saveAutoCommit);
1: 		} catch (SQLException sqe) {
1: 			MailJdbc.logAct.logMsg(LogFile.ERROR + thread_name + " : "
0: 					+ "Exception while deleting mail by Thread: "
1: 					+ sqe.getMessage());
1: 			sqe.printStackTrace();
1: 			errorPrint(sqe);
1: 			try {
0: 				conn.rollback();
0: 			} catch (SQLException sq) {
1: 				MailJdbc.logAct.logMsg(LogFile.ERROR + thread_name + " : "
0: 						+ "Exception while rolling back: " + sq);
0: 				sq.printStackTrace();
0: 				errorPrint(sq);
0: 				throw sqe;
1: 			}
1: 		}
1: 
1: 	}
1: 
0: 	public void moveToFolders(Connection conn, String thread_name) {
0: 		//Changing the folder id of randomly selected rows
1: 		try {
0: 			boolean saveAutoCommit = conn.getAutoCommit();
1: 			conn.setAutoCommit(false);
1: 			Statement stmt = conn.createStatement();
1: 			PreparedStatement moveToFolder = conn
1: 					.prepareStatement(Statements.movefolder);
1: 			ResultSet rs = stmt.executeQuery(Statements.getRowCount);
1: 			if (!(rs.next()))
1: 				MailJdbc.logAct.logMsg(LogFile.INFO + thread_name + " : "
1: 						+ "no message in the REFRESH.INBOX to move");
1: 			else {
1: 				int count = rs.getInt(1);
0: 				int folder_id = (int) (Math.random() * 5);
0: 				int message_id = (int) (Math.random() * count);
1: 				moveToFolder.setInt(1, folder_id);
1: 				moveToFolder.setInt(2, message_id);
1: 				long s_folder = System.currentTimeMillis();
1: 				moveToFolder.executeUpdate();
1: 				long e_folder = System.currentTimeMillis();
1: 				log.logMsg(LogFile.INFO + thread_name + " : "
1: 						+ "Time taken to move a mail to the folder :"
1: 						+ PerfTime.readableTime(e_folder - s_folder));
0: 				long s_fselect = System.currentTimeMillis();
1: 				MailJdbc.logAct.logMsg(LogFile.INFO + thread_name + " : "
1: 						+ "Mail with id : " + message_id
0: 						+ " is moved to folder with id : " + folder_id);
1: 			}
0: 			if (stmt != null)
1: 				stmt.close();
0: 			if (moveToFolder != null)
1: 				moveToFolder.close();
0: 			if (rs != null)
1: 				rs.close();
1: 			conn.commit();
0: 			conn.setAutoCommit(saveAutoCommit);
1: 		} catch (SQLException sqe) {
1: 			MailJdbc.logAct.logMsg(LogFile.ERROR + thread_name + " : "
1: 					+ "Exception while moving mail to folders: "
1: 					+ sqe.getMessage());
1: 			sqe.printStackTrace();
1: 			errorPrint(sqe);
1: 			try {
0: 				conn.rollback();
0: 			} catch (SQLException sq) {
1: 				MailJdbc.logAct.logMsg(LogFile.ERROR + thread_name + " : "
0: 						+ "Exception while rolling back: " + sq);
0: 				sq.printStackTrace();
0: 				errorPrint(sq);
1: 			}
1: 		}
1: 
1: 	}
1: 
1: 	public void insertMail(Connection conn, String thread_name)
1: 			throws Exception {
0: 		//Inserting rows to the inbox table. Making attach_id of randomly
0: 		// selected rows to be one
0: 		//and for those rows inserting blobs in the attach table
1: 		Statement stmt = conn.createStatement();
0: 		int num = (int) (Math.random() * 10);
1: 		try {
0: 			boolean saveAutoCommit = conn.getAutoCommit();
1: 			conn.setAutoCommit(false);
1: 			PreparedStatement insertFirst = conn.prepareStatement(
1: 					Statements.insertStr, Statement.RETURN_GENERATED_KEYS);
1: 			String name = new String("ABCD");
1: 			String l_name = new String("WXYZ");
0: 			long s_insert = System.currentTimeMillis();
1: 			for (int i = 0; i < num; i++) {
1: 				String new_name = new String(increment(name, 60));
0: 				String new_lname = new String(decrement(name, 60));
1: 				insertFirst.setString(1, new_name);
1: 				insertFirst.setString(2, new_lname);
1: 				insertFirst.setTimestamp(3, new Timestamp(System
1: 						.currentTimeMillis()));
1: 				name = new_name;
1: 				l_name = new_lname;
1: 				try {
0: 					File inputfile = new File("l" + num + ".txt");
0: 					FileReader fr = new FileReader(inputfile);
0: 					BufferedReader br = new BufferedReader(fr);
0: 					insertFirst.setCharacterStream(4, fr, (int) inputfile
0: 							.length());
0: 				} catch (FileNotFoundException e) {
1: 					MailJdbc.logAct.logMsg(LogFile.ERROR + thread_name + " : "
1: 							+ "File not found Exception : " + e.getMessage());
1: 					errorPrint(e);
1: 					throw e;
1: 				}
0: 				int rand_num = (int) (Math.random() * 10);
0: 				if (i == rand_num) {
1: 					ResultSet rs = stmt
0: 							.executeQuery("select count(*) from REFRESH.INBOX where attach_id>0");
1: 					while (rs.next()) {
1: 						id_count = rs.getInt(1);
0: 						int attach_id = rs.getInt(1) + 1;
0: 						insertFirst.setInt(5, rs.getInt(1) + 1);
1: 					}
1: 
0: 					if (rs != null)
1: 						rs.close();
0: 					conn
0: 							.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
1: 				} else
0: 					insertFirst.setInt(5, 0);
0: 				insertFirst
0: 						.setString(
0: 								6,
0: 								"This column is used only to by pass the space problem. If the problem still exists, then we are going to "
0: 										+ "have a serious issue here.*****************************************************************************************************");
1: 				int result = insertFirst.executeUpdate();
1: 				if (result != 0) {
1: 					insert_count = insert_count + 1;
1: 				}
1: 			}
0: 			if (insertFirst != null)
0: 				insertFirst.close();
1: 			conn.commit();
0: 			long e_insert = System.currentTimeMillis();
1: 			log.logMsg(LogFile.INFO + thread_name + " : "
0: 					+ "Time taken to insert " + num + "rows :"
0: 					+ PerfTime.readableTime(e_insert - s_insert));
1: 			MailJdbc.logAct.logMsg(LogFile.INFO + thread_name + " : "
0: 					+ "number of mails inserted : " + num);
1: 
1: 		} catch (SQLException sqe) {
1: 			MailJdbc.logAct.logMsg(LogFile.INFO + thread_name + " : "
0: 					+ "Error while inserting into REFRESH.INBOX:"
1: 					+ sqe.getMessage());
1: 			sqe.printStackTrace();
1: 			errorPrint(sqe);
1: 			try {
0: 				conn.rollback();
0: 			} catch (SQLException sq) {
1: 				MailJdbc.logAct.logMsg(LogFile.INFO + thread_name + " : "
0: 						+ "Exception while rolling back: " + sq);
0: 				sq.printStackTrace();
0: 				errorPrint(sq);
0: 				throw sqe;
1: 			}
1: 		}
1: 		try {
0: 			PreparedStatement insertAttach = conn
1: 					.prepareStatement(Statements.insertStrAttach);
1: 			Statement stmt1 = conn.createStatement();
0: 			ResultSet rs = stmt1
0: 					.executeQuery("select id,attach_id from REFRESH.INBOX where attach_id> "
0: 							+ id_count);
0: 			int row_count = 0;
0: 			long a_start = System.currentTimeMillis();
1: 			while (rs.next()) {
0: 				insertAttach.setInt(1, rs.getInt(1));
0: 				insertAttach.setInt(2, rs.getInt(2));
1: 				try {
0: 					File inputfile = new File("p" + num + ".jpg");
0: 					InputStream fileIn = new FileInputStream(inputfile); //"pic"+
0: 					// row_count+".jpg");
0: 					insertAttach.setBinaryStream(3, fileIn, (int) inputfile
0: 							.length());
1: 				} catch (Exception e) {
1: 					MailJdbc.logAct.logMsg(LogFile.ERROR + thread_name + " : "
1: 							+ "Exception : " + e.getMessage());
1: 					errorPrint(e);
1: 					throw e;
1: 				}
0: 				int result_attach = insertAttach.executeUpdate();
0: 				if (result_attach != 0) {
0: 					blob_count = blob_count + 1;
0: 					row_count++;
1: 				}
1: 
1: 			}
0: 			long a_end = System.currentTimeMillis();
1: 			log.logMsg(LogFile.INFO + thread_name + " : "
0: 					+ "Time taken to insert " + row_count + "attachments :"
0: 					+ PerfTime.readableTime(a_end - a_start));
1: 			id_count++;
0: 			if (rs != null)
1: 				rs.close();
0: 			if (stmt != null)
1: 				stmt.close();
0: 			if (stmt1 != null)
1: 				stmt1.close();
0: 			if (insertAttach != null)
1: 				insertAttach.close();
1: 			conn.commit();
0: 			conn.setAutoCommit(saveAutoCommit);
1: 		} catch (SQLException sqe) {
1: 			MailJdbc.logAct.logMsg(LogFile.INFO + thread_name + " : "
0: 					+ "Error while inserting attachments:" + sqe.getMessage());
1: 			sqe.printStackTrace();
1: 			errorPrint(sqe);
1: 			try {
0: 				conn.rollback();
0: 			} catch (SQLException sq) {
1: 				MailJdbc.logAct.logMsg(LogFile.INFO + thread_name + " : "
0: 						+ "Exception while rolling back: " + sq);
0: 				sq.printStackTrace();
0: 				errorPrint(sq);
0: 				throw sqe;
1: 			}
1: 		}
1: 	}
1: 
0: 	public synchronized void deleteMailByExp(Connection conn, String thread_name) {
1: 		try {
0: 			//Deleting mails which are older than 1 day
0: 			boolean saveAutoCommit = conn.getAutoCommit();
1: 			conn.setAutoCommit(false);
1: 			long s_delExp = System.currentTimeMillis();
1: 			Statement selExp = conn.createStatement();
0: 			PreparedStatement deleteExp = conn
0: 					.prepareStatement(Statements.delExp);
1: 			MailJdbc.logAct.logMsg(LogFile.INFO + thread_name + " : "
0: 					+ "delete mails which are older than 1 day");
1: 			int count = 0;
1: 			count = selExp.executeUpdate(Statements.del_jdbc_exp);
1: 			long e_delExp = System.currentTimeMillis();
1: 			log.logMsg(LogFile.INFO + thread_name + " : "
0: 					+ "Time taken to delete " + count + "mails :"
1: 					+ PerfTime.readableTime(e_delExp - s_delExp));
1: 			MailJdbc.logAct.logMsg(LogFile.INFO + thread_name + " : "
1: 					+ " number of mails deleted : " + count);
1: 			delete_count = delete_count + count;
0: 			if (deleteExp != null)
0: 				deleteExp.close();
0: 			if (selExp != null)
0: 				selExp.close();
1: 			conn.commit();
0: 			conn.setAutoCommit(saveAutoCommit);
1: 		} catch (SQLException sqe) {
1: 			MailJdbc.logAct.logMsg(LogFile.ERROR + thread_name + " : "
1: 					+ "Error while deleting mails by expiry manager: "
1: 					+ sqe.getMessage());
1: 			sqe.printStackTrace();
1: 			errorPrint(sqe);
1: 			try {
0: 				conn.rollback();
0: 			} catch (SQLException sq) {
1: 				MailJdbc.logAct.logMsg(LogFile.ERROR + thread_name + " : "
0: 						+ "Exception while rolling back: " + sq);
0: 				sq.printStackTrace();
0: 				errorPrint(sq);
1: 			}
1: 		}
1: 	}
1: 
0: 	public void Backup(Connection conn, String thread_name) {
0: 		//when the backup thread kicks in, it will use this function to
0: 		//take the periodic backups
1: 		long s_backup = System.currentTimeMillis();
1: 		try {
0: 			saveAutoCommit = conn.getAutoCommit();
1: 			conn.setAutoCommit(true);
1: 			CallableStatement cs = conn
1: 					.prepareCall("CALL SYSCS_UTIL.SYSCS_BACKUP_DATABASE_AND_ENABLE_LOG_ARCHIVE_MODE_NOWAIT(?, ?)");
0: 			cs.setString(1, "/mailjdbc/mailbackup");
1: 			cs.setInt(2, 1);
1: 			cs.execute();
1: 			cs.close();
1: 			MailJdbc.logAct.logMsg(LogFile.INFO + thread_name + " : "
1: 					+ "Finished backing up the Database");
1: 			conn.commit();
0: 			conn.setAutoCommit(saveAutoCommit);
1: 		} catch (Throwable sqe) {
1: 			MailJdbc.logAct.logMsg(LogFile.ERROR + thread_name + " : "
1: 					+ "Error while doing the backup system procedure: "
1: 					+ sqe.getMessage());
1: 			sqe.printStackTrace();
1: 			errorPrint(sqe);
1: 		}
1: 		long e_backup = System.currentTimeMillis();
1: 		log.logMsg(LogFile.INFO + thread_name + " : "
1: 				+ "Time taken to do backup :"
1: 				+ PerfTime.readableTime(e_backup - s_backup));
1: 
1: 	}
1: 
1: 	public void compressTable(Connection conn, String tabname,
0: 			String thread_name)
0: 	//preiodically compresses the table to get back the free spaces available
1: 	// after
0: 	//the deletion of some rows
1: 	{
1: 		long s_compress = System.currentTimeMillis();
0: 		long dbsize = databaseSize("mailsdb/seg0");
1: 		MailJdbc.logAct.logMsg(LogFile.INFO + thread_name + " : "
1: 				+ "dbsize before compress : " + dbsize);
1: 		try {
0: 			boolean saveAutoCommit = conn.getAutoCommit();
1: 			conn.setAutoCommit(true);
1: 			CallableStatement cs = conn
1: 					.prepareCall("CALL SYSCS_UTIL.SYSCS_INPLACE_COMPRESS_TABLE(?, ?, ?, ?, ?)");
1: 			cs.setString(1, "REFRESH");
1: 			cs.setString(2, tabname);
1: 			cs.setShort(3, (short) 1);
1: 			cs.setShort(4, (short) 1);
1: 			cs.setShort(5, (short) 1);
1: 			cs.execute();
0: 			conn.setAutoCommit(saveAutoCommit);
1: 			cs.close();
1: 		} catch (Throwable sqe) {
1: 			MailJdbc.logAct.logMsg(LogFile.ERROR + thread_name + " : "
1: 					+ "Error while doing the Compress procedure: "
1: 					+ sqe.getMessage());
1: 			sqe.printStackTrace();
1: 			errorPrint(sqe);
1: 		}
1: 		long e_compress = System.currentTimeMillis();
1: 		MailJdbc.logAct.logMsg(LogFile.INFO + thread_name + " : "
1: 				+ "Finished Compressing the table: " + tabname);
1: 		log.logMsg(LogFile.INFO + thread_name + " : "
1: 				+ "Time taken to compress the table : " + tabname
0: 				+ PerfTime.readableTime(e_compress - s_compress));
0: 		dbsize = databaseSize("mailsdb/seg0");
1: 		MailJdbc.logAct.logMsg(LogFile.INFO + thread_name + " : "
1: 				+ "dbsize after compress : " + dbsize);
1: 	}
1: 
1: 	public synchronized void checkDbSize(Connection conn, String thread_name)
0: 	//Will give the information about the size of the database in regular
1: 	// intervals
1: 	{
1: 		try {
0: 			long dbsize = 0;
1: 			int del_count = 0;
0: 			int row_count = 0;
1: 			int count = 0;
0: 			int new_const = 0;
1: 			int diff = 0;
0: 			ArrayList idArray = new ArrayList();
0: 			Integer id_element = new Integer(0);
1: 			Statement stmt = conn.createStatement();
1: 			Statement stmt1 = conn.createStatement();
1: 			Statement stmt2 = conn.createStatement();
0: 			Statement stmt3 = conn.createStatement();
1: 			ResultSet rs = stmt
1: 					.executeQuery("select count(*) from REFRESH.INBOX ");
1: 			while (rs.next())
1: 				count = rs.getInt(1);
0: 			if (count > 12) {
0: 				diff = count - 12;
1: 				ResultSet rs1 = stmt1
1: 						.executeQuery("select id from REFRESH.INBOX");
1: 				while (rs1.next()) {
0: 					id_element = new Integer(rs1.getInt(1));
0: 					idArray.add(id_element);
1: 				}
1: 				for (int i = 0; i <= diff; i++) {
1: 					del_count = del_count
0: 							+ stmt3
1: 									.executeUpdate("delete from REFRESH.INBOX where id ="
1: 											+ idArray.get(i));
1: 
1: 				}
0: 				if (rs1 != null)
1: 					rs1.close();
1: 			}
1: 			delete_count = delete_count + del_count;
0: 			if (rs != null)
1: 				rs.close();
0: 			if (stmt != null)
1: 				stmt.close();
0: 			if (stmt1 != null)
1: 				stmt1.close();
0: 			if (stmt2 != null)
1: 				stmt2.close();
0: 			if (stmt3 != null)
0: 				stmt3.close();
1: 		} catch (Exception fe) {
1: 			MailJdbc.logAct.logMsg(LogFile.ERROR + thread_name + " :  "
1: 					+ fe.getMessage());
1: 			errorPrint(fe);
1: 		}
1: 
1: 	}
1: 
0: 	public void grantRevoke(Connection conn, String thread_name) {
1: 		try {
0: 			//Giving appropriate permission to eahc threads
0: 			saveAutoCommit = conn.getAutoCommit();
1: 			Statement stmt = conn.createStatement();
1: 			stmt.execute(Statements.grantSel1);
1: 			stmt.execute(Statements.grantSel2);
1: 			stmt.execute(Statements.grantSel3);
1: 			stmt.execute(Statements.grantSel4);
1: 			stmt.execute(Statements.grantSel5);
1: 			stmt.execute(Statements.grantSel6);
1: 			stmt.execute(Statements.grantSel7);
1: 			stmt.execute(Statements.grantIns1);
1: 			stmt.execute(Statements.grantIns2);
1: 			stmt.execute(Statements.grantIns3);
1: 			stmt.execute(Statements.grantUp1);
1: 			stmt.execute(Statements.grantUp2);
1: 			stmt.execute(Statements.grantUp3);
1: 			stmt.execute(Statements.grantDel1);
1: 			stmt.execute(Statements.grantDel2);
1: 			stmt.execute(Statements.grantDel3);
1: 			stmt.execute(Statements.grantExe1);
1: 			stmt.execute(Statements.grantExe2);
1: 			stmt.execute(Statements.grantExe3);
1: 			stmt.execute(Statements.grantExe4);
1: 			stmt.execute(Statements.grantExe5);
1: 			conn.commit();
0: 			conn.setAutoCommit(saveAutoCommit);
0: 			if (stmt != null)
1: 				stmt.close();
1: 			MailJdbc.logAct.logMsg(LogFile.INFO + thread_name + " : "
1: 					+ "Finished Granting permissions");
1: 		} catch (Throwable sqe) {
1: 			MailJdbc.logAct.logMsg(LogFile.ERROR + thread_name + " : "
1: 					+ "Error while doing Grant Revoke: " + sqe.getMessage());
1: 			sqe.printStackTrace();
1: 			errorPrint(sqe);
1: 
1: 		}
1: 
1: 	}
1: 
0: 	public static long databaseSize(String dbname) {
0: 		File dir = new File(dbname);
0: 		File[] files = dir.listFiles();
0: 		long length = 0;
1: 		int count = 0;
0: 		for (int i = 0; i < files.length; i++) {
0: 			length = length + files[i].length();
0: 			count++;
1: 		}
0: 		return length;
1: 	}
1: 
1: 	public static void setSystemProperty(String key, String value) {
1: 		String svalue = System.getProperty(key);
1: 		if (svalue == null)
1: 			System.setProperty(key, value);
1: 		else
1: 			value = svalue;
1: 		MailJdbc.logAct.logMsg(LogFile.INFO + key + "=" + value);
1: 	}
1: 
0: 	public void totals() {
0: 		MailJdbc.logAct.logMsg(LogFile.INFO + " total number of inserts : "
1: 				+ insert_count);
0: 		MailJdbc.logAct.logMsg(LogFile.INFO + " total number of deletes : "
1: 				+ delete_count);
0: 		MailJdbc.logAct.logMsg(LogFile.INFO
0: 				+ " total number of clobs inserted : " + insert_count);
0: 		MailJdbc.logAct.logMsg(LogFile.INFO
0: 				+ " total number of blobs inserted : " + blob_count);
1: 	}
1: 
1: 	public static String decrement(String name, int maxLength) {
1: 		StringBuffer buff = new StringBuffer(name);
1: 
0: 		//if the String is '0', return the maximum String
1: 		StringBuffer tempBuff = new StringBuffer();
1: 		if (name.length() == 1 && name.charAt(0) == firstChar()) {
1: 			for (int i = 0; i < maxLength; i++) {
1: 				tempBuff.append(lastChar());
1: 			}
1: 			return tempBuff.toString();
1: 		}
1: 
0: 		//if String is all '000...0', eliminate one '0' and set the rest to 'z'
1: 		else {
1: 			boolean isAll0 = true;
1: 			for (int i = 0; i < buff.length(); i++) {
1: 				if (buff.charAt(i) != firstChar()) {
1: 					isAll0 = false;
1: 					break;
1: 				}
1: 			}
1: 			if (isAll0 == true) {
1: 				buff.deleteCharAt(0);
1: 				for (int i = 0; i < buff.length(); i++) {
1: 					buff.setCharAt(i, lastChar());
1: 				}
1: 			}
0: 			//if the String is not all '000...0', loop starting with the last
1: 			// char
1: 			else {
1: 				for (int i = buff.length() - 1; i >= 0; i--) {
0: 					//if this char is not '0'
1: 					if (buff.charAt(i) > firstChar()) {
0: 						//decrement this char
1: 						buff.setCharAt(i, previousChar(buff.charAt(i)));
1: 						break;
1: 					}
0: 					//Resetting the counter 000 -> zzz
0: 					//if this char is '0' and if the char before is not '0',
1: 					// set this char to 'z' and decrement the char before
1: 					else
1: 						buff.setCharAt(i, lastChar());
1: 					if (buff.charAt(i - 1) < firstChar()) {
1: 						buff.setCharAt(i - 1, previousChar(buff.charAt(i - 1)));
1: 						break;
1: 					}
1: 				}
1: 			}
1: 		}
1: 		return buff.toString();
1: 	}
1: 
1: 	private static char firstChar() {
1: 		return (char) 48;
1: 	}
1: 
1: 	private static char lastChar() {
1: 		return (char) 122;
1: 	}
1: 
1: 	private static char previousChar(char c) {
1: 		if (c <= 65 && c >= 59)
1: 			return (char) 57;
1: 		else if (c <= 97 && c >= 92)
1: 			return (char) 90;
1: 		else
1: 			return (char) (c - 1);
1: 	}
1: 
1: 	public static String increment(String name, int maxLength) {
1: 
0: 		//		if (name.length() > maxLength) {
0: 		//			//String greater than maxLength, so set it to '0'
0: 		//			return "0";
0: 		//		}
1: 		StringBuffer buff = new StringBuffer(name);
0: 		//check if the String is all 'zzz...z'
1: 		boolean isAllZ = true;
1: 		for (int i = 0; i < name.length(); i++) {
1: 			if (name.charAt(i) != lastChar()) {
1: 				isAllZ = false;
1: 				break;
1: 			}
1: 		}
0: 		//if the String is all 'zzz...z', check if it's the maximum length
1: 		if (isAllZ == true) {
1: 			if (name.length() >= maxLength) {
0: 				//String is all 'zzz...z' to maxLength, so set it to '0'
1: 				return "0";
1: 			} else {
0: 				//String is all 'zzz...z' but not maxLength, so set all to 0
1: 				// and append '0'
1: 				for (int i = 0; i < buff.length(); i++) {
1: 					buff.setCharAt(i, firstChar());
1: 				}
1: 				buff.append('0');
1: 			}
1: 		}
0: 		//if the String is not all 'zzz...z', loop starting with the last char
1: 		else {
1: 			for (int i = buff.length() - 1; i >= 0; i--) {
0: 				//if this char is not 'z'
1: 				if (buff.charAt(i) < lastChar()) {
0: 					//increment this char
1: 					buff.setCharAt(i, nextChar(buff.charAt(i)));
1: 					break;
1: 				}
1: 				// if this char is 'z' and if the char before is not 'z', set
1: 				// this char to '0' and increment the char before
1: 				else
1: 					buff.setCharAt(i, firstChar());
1: 				if (buff.charAt(i - 1) < lastChar()) {
1: 					buff.setCharAt(i - 1, nextChar(buff.charAt(i - 1)));
1: 					break;
1: 				}
1: 			}
1: 		}
1: 		return buff.toString();
1: 	}
1: 
1: 	private static char nextChar(char c) {
1: 		if (c <= 63 && c >= 57)
1: 			return (char) 65;
1: 		else if (c <= 95 && c >= 90)
1: 			return (char) 97;
1: 		else
1: 			return (char) (c + 1);
1: 	}
1: 
1: 	static void errorPrint(Throwable e) {
1: 		if (e instanceof SQLException)
1: 			SQLExceptionPrint((SQLException) e);
1: 		else {
1: 			System.out.println("A non SQL error occured.");
1: 			e.printStackTrace();
1: 		}
1: 	} // END errorPrint
1: 
0: 	//  Iterates through a stack of SQLExceptions
1: 	static void SQLExceptionPrint(SQLException sqle) {
1: 		while (sqle != null) {
1: 			System.out.println("\n---SQLException Caught---\n");
1: 			System.out.println("SQLState:   " + (sqle).getSQLState());
1: 			System.out.println("Severity: " + (sqle).getErrorCode());
1: 			System.out.println("Message:  " + (sqle).getMessage());
1: 			sqle.printStackTrace();
1: 			sqle = sqle.getNextException();
1: 		}
1: 	}
1: }
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:cae4ed4
/////////////////////////////////////////////////////////////////////////
1: public class DbTasks {
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
1: 					.getProperty("database"), usr, passwd);
/////////////////////////////////////////////////////////////////////////
0: 			rs.close();
0: 			stmt1.close();
0: 			rs1.close();
/////////////////////////////////////////////////////////////////////////
0: 			rs.close();
/////////////////////////////////////////////////////////////////////////
0: 			rs.close();
0: 			stmt.close();
/////////////////////////////////////////////////////////////////////////
0: 			rs.close();
0: 			updateUser.close();
0: 			stmt.close();
/////////////////////////////////////////////////////////////////////////
0: 			deleteThread.close();
0: 			rs.close();
0: 			stmt.close();
/////////////////////////////////////////////////////////////////////////
0: 			stmt.close();
0: 			moveToFolder.close();
0: 			rs.close();
/////////////////////////////////////////////////////////////////////////
0: 					rs.close();
/////////////////////////////////////////////////////////////////////////
0: 			insertFirst.close();
/////////////////////////////////////////////////////////////////////////
0: 			rs.close();
0: 			stmt.close();
0: 			stmt1.close();
0: 			insertAttach.close();
/////////////////////////////////////////////////////////////////////////
0: 			deleteExp.close();
0: 			selExp.close();
/////////////////////////////////////////////////////////////////////////
0: 				rs1.close();
0: 			rs.close();
0: 			stmt.close();
0: 			stmt1.close();
0: 			stmt2.close();
0: 			stmt3.close();
/////////////////////////////////////////////////////////////////////////
0: 			stmt.close();
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:a5430dd
/////////////////////////////////////////////////////////////////////////
0: 
1:  * This class is used all other classes for various tasks like insert, delete,
1:  * backup etc
0: 
1: import java.io.Reader;
/////////////////////////////////////////////////////////////////////////
1: import java.util.Random;
1: import org.apache.derbyTesting.functionTests.util.streams.CharAlphabet;
1: import org.apache.derbyTesting.functionTests.util.streams.LoopingAlphabetReader;
1: import org.apache.derbyTesting.functionTests.util.streams.LoopingAlphabetStream;
/////////////////////////////////////////////////////////////////////////
1: 	public static Random Rn = new Random();
0: 
0: 		setSystemProperty("derby.database.sqlAuthorization", "true");
/////////////////////////////////////////////////////////////////////////
1: 			// setting the properties like user, password etc for both the
0: 			MailJdbc.logAct
0: 					.logMsg(" \n*****************************************************");
0: 			MailJdbc.logAct
0: 					.logMsg("\n\n\tStarting the test in NetworkServer mode");
0: 			MailJdbc.logAct
0: 					.logMsg("\n\n*****************************************************");
/////////////////////////////////////////////////////////////////////////
1: 			// Returns the Connection object
/////////////////////////////////////////////////////////////////////////
1: 		// This function will be reading mails from the inbox.
0: 		// Getiing the number of rows in the table and getting the
1: 		// size of the attachment (Blob) for a randomly selected row
/////////////////////////////////////////////////////////////////////////
0: 			int attach_id = Rn.nextInt(count - 1);
/////////////////////////////////////////////////////////////////////////
0: 		// Delete done by the user. Thre user will mark the mails to be deleted
/////////////////////////////////////////////////////////////////////////
0: 			int id = Rn.nextInt(id_count - 1);
0: 				int for_id = Rn.nextInt(id_count - 1);
/////////////////////////////////////////////////////////////////////////
1: 		// Deleting mails which are marked to be deleted
0: 			saveAutoCommit = conn.getAutoCommit();
/////////////////////////////////////////////////////////////////////////
1: 		// Changing the folder id of randomly selected rows
0: 			saveAutoCommit = conn.getAutoCommit();
/////////////////////////////////////////////////////////////////////////
0: 				int folder_id = Rn.nextInt(5 - 1);
0: 				int message_id = Rn.nextInt(count - 1);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 		// Inserting rows to the inbox table. Making attach_id of randomly
0: 		// and for those rows inserting blobs in the attach table
0: 		int num = Rn.nextInt(10 - 1);
0: 		System.out.println("num: " + num);
1: 		InputStream streamIn = null;
1: 		Reader streamReader = null;
0: 			saveAutoCommit = conn.getAutoCommit();
/////////////////////////////////////////////////////////////////////////
1: 				String new_lname = new String(decrement(l_name, 60));
/////////////////////////////////////////////////////////////////////////
1: 					// to create a stream of random length between 200 bytes and 3MB
1: 					int clobLength = Rn.nextInt(3078000 - 200 + 1) + 200;
1: 					streamReader = new LoopingAlphabetReader(clobLength,
1: 							CharAlphabet.modernLatinLowercase());
1: 					insertFirst.setCharacterStream(4, streamReader, clobLength);
0: 				} catch (Exception e) {
0: 				int rand_num = Rn.nextInt(10 - 1);
/////////////////////////////////////////////////////////////////////////
0: 			streamReader.close();
0: 
/////////////////////////////////////////////////////////////////////////
0: 					.executeQuery("select id,attach_id from REFRESH.INBOX where attach_id >"
/////////////////////////////////////////////////////////////////////////
0: 					// to create a stream of random length between 0 and 5M
0: 					int blobLength = Rn.nextInt(5130000 - 0 + 1) + 0;
0: 					streamIn = new LoopingAlphabetStream(blobLength);
0: 					insertAttach.setBinaryStream(3, streamIn, blobLength);
/////////////////////////////////////////////////////////////////////////
0: 				streamIn.close();
/////////////////////////////////////////////////////////////////////////
1: 			// Deleting mails which are older than 1 day
0: 			saveAutoCommit = conn.getAutoCommit();
/////////////////////////////////////////////////////////////////////////
1: 		// when the backup thread kicks in, it will use this function to
1: 		// take the periodic backups
1: 			cs.setString(1, System.getProperty("user.dir") + File.separator
1: 					+ "mailbackup");
/////////////////////////////////////////////////////////////////////////
0: 	// preiodically compresses the table to get back the free spaces available
1: 	// the deletion of some rows
/////////////////////////////////////////////////////////////////////////
1: 	// Will give the information about the size of the database in regular
/////////////////////////////////////////////////////////////////////////
0: 			// Giving appropriate permission to eahc threads
/////////////////////////////////////////////////////////////////////////
1: 		// if the String is '0', return the maximum String
/////////////////////////////////////////////////////////////////////////
1: 		// if String is all '000...0', eliminate one '0' and set the rest to 'z'
/////////////////////////////////////////////////////////////////////////
1: 			// if the String is not all '000...0', loop starting with the last
1: 					// if this char is not '0'
1: 						// decrement this char
1: 					// Resetting the counter 000 -> zzz
1: 					// if this char is '0' and if the char before is not '0',
/////////////////////////////////////////////////////////////////////////
1: 		// if (name.length() > maxLength) {
1: 		// //String greater than maxLength, so set it to '0'
1: 		// return "0";
1: 		// }
1: 		// check if the String is all 'zzz...z'
/////////////////////////////////////////////////////////////////////////
1: 		// if the String is all 'zzz...z', check if it's the maximum length
1: 				// String is all 'zzz...z' to maxLength, so set it to '0'
1: 				// String is all 'zzz...z' but not maxLength, so set all to 0
/////////////////////////////////////////////////////////////////////////
1: 		// if the String is not all 'zzz...z', loop starting with the last char
1: 				// if this char is not 'z'
1: 					// increment this char
/////////////////////////////////////////////////////////////////////////
1: 	// Iterates through a stack of SQLExceptions
============================================================================