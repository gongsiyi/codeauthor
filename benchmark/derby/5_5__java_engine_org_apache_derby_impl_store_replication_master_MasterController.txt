1:4aeada8: /*
13:4aeada8:  
1:4aeada8:    Derby - Class
1:1bac3f3:    org.apache.derby.impl.store.replication.master.MasterController
1:4aeada8:  
1:4aeada8:    Licensed to the Apache Software Foundation (ASF) under one or more
1:4aeada8:    contributor license agreements.  See the NOTICE file distributed with
1:4aeada8:    this work for additional information regarding copyright ownership.
1:4aeada8:    The ASF licenses this file to you under the Apache License, Version 2.0
1:4aeada8:    (the "License"); you may not use this file except in compliance with
1:4aeada8:    the License.  You may obtain a copy of the License at
1:4aeada8:  
1:4aeada8:       http://www.apache.org/licenses/LICENSE-2.0
1:4aeada8:  
1:4aeada8:    Unless required by applicable law or agreed to in writing, software
1:4aeada8:    distributed under the License is distributed on an "AS IS" BASIS,
1:4aeada8:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:4aeada8:    See the License for the specific language governing permissions and
1:4aeada8:    limitations under the License.
1:4aeada8:  
1:4aeada8: */
1:4aeada8: 
1:1bac3f3: package org.apache.derby.impl.store.replication.master;
1:4aeada8: 
1:864d9d1: import java.io.IOException;
1:864d9d1: import java.net.SocketTimeoutException;
1:f2ec1d8: import java.net.UnknownHostException;
1:4aeada8: import org.apache.derby.iapi.error.StandardException;
1:864d9d1: import org.apache.derby.iapi.reference.MessageId;
1:4aeada8: import org.apache.derby.iapi.reference.SQLState;
1:4aeada8: import org.apache.derby.iapi.services.monitor.ModuleControl;
1:4aeada8: import org.apache.derby.iapi.services.monitor.ModuleSupportable;
1:864d9d1: import org.apache.derby.iapi.services.monitor.Monitor;
1:1d0892e: import org.apache.derby.iapi.services.property.PropertyUtil;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:1d0892e: import org.apache.derby.iapi.reference.Property;
1:4aeada8: 
1:4aeada8: import org.apache.derby.iapi.store.raw.RawStoreFactory;
1:4aeada8: import org.apache.derby.iapi.store.raw.log.LogFactory;
1:4aeada8: import org.apache.derby.iapi.store.raw.data.DataFactory;
1:864d9d1: 
1:1bac3f3: import org.apache.derby.iapi.store.replication.master.MasterFactory;
1:4aeada8: 
1:1bac3f3: import org.apache.derby.impl.store.replication.net.ReplicationMessage;
1:1bac3f3: import org.apache.derby.impl.store.replication.ReplicationLogger;
1:1bac3f3: import org.apache.derby.impl.store.replication.net.ReplicationMessageTransmit;
1:1bac3f3: import org.apache.derby.impl.store.replication.buffer.ReplicationLogBuffer;
1:1bac3f3: import org.apache.derby.impl.store.replication.buffer.LogBufferFullException;
1:4aeada8: 
1:4aeada8: import java.util.Properties;
1:f2ec1d8: import org.apache.derby.impl.store.replication.net.SlaveAddress;
1:4aeada8: 
1:4aeada8: /**
1:4aeada8:  * <p> 
1:4aeada8:  * This is an implementation of the replication master controller
1:4aeada8:  * service. The service is booted when this instance of Derby will
1:4aeada8:  * have the replication master role for this database.
1:4aeada8:  * </p> 
1:4aeada8:  * <p>
1:4aeada8:  * Note: The current version of the class is far from complete. Code
1:4aeada8:  * to control the replication master behavior will be added as more
1:4aeada8:  * parts of the replication functionality is added to Derby. 
1:4aeada8:  * </p>
1:864d9d1:  *
1:4aeada8:  * @see MasterFactory
1:4aeada8:  */
1:696377a: public class MasterController 
1:864d9d1:         implements MasterFactory, ModuleControl, ModuleSupportable {
1:4aeada8: 
1:4aeada8:     private static final int DEFAULT_LOG_BUFFER_SIZE = 32768; //32K
1:1d0892e:     private static final int LOG_BUFFER_SIZE_MIN = 8192; //8KB
1:1d0892e:     private static final int LOG_BUFFER_SIZE_MAX = 1024*1024; //1MB
1:4aeada8: 
1:4aeada8:     private RawStoreFactory rawStoreFactory;
1:4aeada8:     private DataFactory dataFactory;
1:4aeada8:     private LogFactory logFactory;
1:4aeada8:     private ReplicationLogBuffer logBuffer;
1:864d9d1:     private AsynchronousLogShipper logShipper;
1:5235dfd:     private ReplicationMessageTransmit transmitter; 
1:1d0892e:     private ReplicationLogger repLogger;
1:4aeada8: 
1:4aeada8:     private String replicationMode;
1:f2ec1d8:     private SlaveAddress slaveAddr;
1:864d9d1:     private String dbname;
1:1d0892e:     private int logBufferSize = 0;
1:864d9d1:     
1:fc4e76b:     //Indicates whether the Master Controller is currently
1:fc4e76b:     //active
1:fc4e76b:     private boolean active = false;
1:4aeada8: 
1:864d9d1:     //How long to wait before reporting the failure to
1:864d9d1:     //establish a connection with the slave.
1:864d9d1:     // TODO: make this configurable through a property
1:864d9d1:     private static final int SLAVE_CONNECTION_ATTEMPT_TIMEOUT = 5000;
1:4aeada8: 
1:4aeada8: 
1:4aeada8:     /**
1:4aeada8:      * Empty constructor required by Monitor.bootServiceModule
1:4aeada8:      */
1:4aeada8:     public MasterController() { }
1:4aeada8: 
1:4aeada8:     ////////////////////////////////////////////////////////////
1:4aeada8:     // Implementation of methods from interface ModuleControl //
1:4aeada8:     ////////////////////////////////////////////////////////////
1:4aeada8: 
1:4aeada8:     /**
1:fc4e76b:      * Used by Monitor.bootServiceModule to start the service. Currently
1:fc4e76b:      * only used to set up the replication mode.
9:4aeada8:      *
1:4aeada8:      * @param create Currently ignored
1:4aeada8:      * @param properties Properties used to start the service in the
1:fc4e76b:      *                   correct mode. Currently initializes only the
1:fc4e76b:      *                   replicationMode property.
1:4aeada8:      * @exception StandardException Standard Derby exception policy,
1:4aeada8:      * thrown on error.
1:4aeada8:      */
1:4aeada8:     public void boot(boolean create, Properties properties)
1:4aeada8:         throws StandardException {
1:fc4e76b:         //The boot method is loaded only once, because of that the
1:fc4e76b:         //boot time parameters once wrong would result in repeated
1:fc4e76b:         //startMaster attempts failing. In order to allow for
1:fc4e76b:         //multiple start master attempts the slave host name, port
1:fc4e76b:         //number and the dbname have been moved to the startMaster
1:fc4e76b:         //method.
1:4aeada8:         replicationMode =
1:4aeada8:             properties.getProperty(MasterFactory.REPLICATION_MODE);
1:4aeada8:     }
1:4aeada8: 
1:4aeada8:     ////////////////////////////////////////////////////////////////
1:4aeada8:     // Implementation of methods from interface ModuleSupportable //
1:4aeada8:     ////////////////////////////////////////////////////////////////
1:4aeada8: 
1:41a2601:     /**
1:4aeada8:      * Used by Monitor.bootServiceModule to check if this class is
1:4aeada8:      * usable for replication. To be usable, we require that
1:4aeada8:      * asynchronous replication is specified in startParams by
1:4aeada8:      * checking that a property with key
1:4aeada8:      * MasterFactory.REPLICATION_MODE has the value
1:4aeada8:      * MasterFactory.ASYNCHRONOUS_MODE. 
1:4aeada8:      * @param startParams The properties used to boot replication
1:4aeada8:      * @return true if asynchronous replication is requested, meaning
1:4aeada8:      * that this MasterController is a suitable implementation for the
1:4aeada8:      * MasterFactory service. False otherwise
1:4aeada8:      * @see ModuleSupportable#canSupport 
1:0217bc6:      */
1:4aeada8:     public boolean canSupport(Properties startParams) {
1:4aeada8:         String modeParam =
1:4aeada8:             startParams.getProperty(MasterFactory.REPLICATION_MODE);
1:4aeada8: 
1:4aeada8:         // currently only one attribute: asynchronous replication mode
1:4aeada8:         if (modeParam != null && 
1:4aeada8:             modeParam.equals(MasterFactory.ASYNCHRONOUS_MODE)) {
1:5235dfd:             return true;
1:4aeada8:         } else {
1:5235dfd:             return false;
1:4aeada8:         }
1:4aeada8:     }
1:864d9d1:     
1:864d9d1:     /**
1:56c419e:      * Will stop the replication master service.
1:864d9d1:      */
1:56c419e:     public void stop() { 
1:56c419e:         try {
1:56c419e:             stopMaster();
1:56c419e:         } catch (StandardException se) {
1:56c419e:             repLogger.
1:56c419e:                 logError(MessageId.REPLICATION_MASTER_STOPPED, se);
1:56c419e:         }
1:56c419e:        
1:56c419e:     }
1:29fd25c: 
1:4aeada8:     ////////////////////////////////////////////////////////////
1:4aeada8:     // Implementation of methods from interface MasterFactory //
1:4aeada8:     ////////////////////////////////////////////////////////////
1:2146e78: 
1:2146e78:     /**
1:864d9d1:      * Will perform all the work that is needed to set up replication.
1:0217bc6:      *
1:4aeada8:      * @param rawStore The RawStoreFactory for the database
1:4aeada8:      * @param dataFac The DataFactory for this database
1:4aeada8:      * @param logFac The LogFactory ensuring recoverability for this database
1:fc4e76b:      * @param slavehost The hostname of the slave
1:fc4e76b:      * @param slaveport The port the slave is listening on
1:fc4e76b:      * @param dbname The master database that is being replicated.
1:c414a36:      * @exception StandardException Standard Derby exception policy,
1:fc4e76b:      *                              1) thrown on replication startup error
1:fc4e76b:      *                              2) thrown if the master has already been
1:fc4e76b:      *                                 booted.
1:fc4e76b:      *                              3) thrown if the specified replication mode
1:fc4e76b:      *                                 is not supported.
1:4aeada8:      */
1:4aeada8:     public void startMaster(RawStoreFactory rawStore,
1:fc4e76b:                             DataFactory dataFac,
1:fc4e76b:                             LogFactory logFac,
1:fc4e76b:                             String slavehost,
1:fc4e76b:                             int slaveport,
1:fc4e76b:                             String dbname)
1:864d9d1:                             throws StandardException {
1:fc4e76b:         if (active) {
1:fc4e76b:             //It is wrong to attempt startMaster on a already
1:fc4e76b:             //started master.
1:fc4e76b:             throw StandardException.newException
1:fc4e76b:                     (SQLState.REPLICATION_MASTER_ALREADY_BOOTED, dbname);
1:fc4e76b:         }
1:fc4e76b: 
1:f2ec1d8:         try {
1:eb7e251:             slaveAddr = new SlaveAddress(slavehost, slaveport);
1:f2ec1d8:         } catch (UnknownHostException uhe) {
1:f2ec1d8:             throw StandardException.newException
1:f2ec1d8:                     (SQLState.REPLICATION_CONNECTION_EXCEPTION, uhe, 
1:f2ec1d8:                      dbname, getHostName(), String.valueOf(getPortNumber()));
1:f2ec1d8:         }
1:f2ec1d8:         
1:fc4e76b:         this.dbname = dbname;
1:fc4e76b: 
1:4aeada8:         rawStoreFactory = rawStore;
1:4aeada8:         dataFactory = dataFac;
1:4aeada8:         logFactory = logFac;
1:4aeada8: 
1:1d0892e:         repLogger = new ReplicationLogger(dbname);
1:1d0892e:         getMasterProperties();
1:1d0892e:         logBuffer = new ReplicationLogBuffer(logBufferSize, this);
1:4aeada8: 
1:fc4e76b:         try {
1:29fd25c:             logFactory.startReplicationMasterRole(this);
1:4c4c239:         
1:29fd25c:             rawStoreFactory.unfreeze();
1:c414a36: 
1:29fd25c:             setupConnection();
1:864d9d1: 
1:29fd25c:             if (replicationMode.equals(MasterFactory.ASYNCHRONOUS_MODE)) {
1:29fd25c:                 logShipper = new AsynchronousLogShipper(logBuffer,
1:29fd25c:                                                         transmitter,
1:1d0892e:                                                         this,
1:1d0892e:                                                         repLogger);
1:56c419e:                 logShipper.setDaemon(true);
1:56c419e:                 logShipper.start();
1:29fd25c:             }
1:29fd25c:         } catch (StandardException se) {
1:29fd25c:             // cleanup everything that may have been started before
1:29fd25c:             // the exception was thrown
1:1d0892e:             repLogger.logError(MessageId.REPLICATION_FATAL_ERROR, se);
1:29fd25c:             logFactory.stopReplicationMasterRole();
1:29fd25c:             teardownNetwork();
1:29fd25c:             throw se;
1:5235dfd:         }
1:0f8eece: 
1:fc4e76b:         //The master has been started successfully.
1:fc4e76b:         active = true;
1:fc4e76b: 
1:4aeada8:         // Add code that initializes replication by sending the
1:4aeada8:         // database to the slave, making logFactory add logrecords to
1:4aeada8:         // the buffer etc. Repliation should be up and running when
1:4aeada8:         // this method returns.
1:0f8eece: 
1:864d9d1:         Monitor.logTextMessage(MessageId.REPLICATION_MASTER_STARTED, dbname);
1:4aeada8:     }
1:4aeada8: 
1:4aeada8:     /**
1:fc4e76b:      * Will perform all work that is needed to shut down replication.
1:fc4e76b:      *
1:fc4e76b:      * @throws StandardException If the replication master has been stopped
1:fc4e76b:      *                           already.
1:4aeada8:      */
1:fc4e76b:     public void stopMaster() throws StandardException {
1:fc4e76b:         if (!active) {
1:fc4e76b:             throw StandardException.newException
1:fc4e76b:                     (SQLState.REPLICATION_NOT_IN_MASTER_MODE);
1:fc4e76b:         }
1:fc4e76b:         active = false;
1:0f8eece:         logFactory.stopReplicationMasterRole();
1:29fd25c:         try {
1:0f8eece:             logShipper.flushBuffer();
1:0f8eece:         } catch (IOException ioe) {
1:1d0892e:             repLogger.
1:1d0892e:                 logError(MessageId.REPLICATION_LOGSHIPPER_EXCEPTION, ioe);
1:0f8eece:         } catch(StandardException se) {
1:1d0892e:             repLogger.
1:1d0892e:                 logError(MessageId.REPLICATION_LOGSHIPPER_EXCEPTION, se);
1:f0fbf76:         } finally {
1:f0fbf76:             teardownNetwork();
1:0f8eece:         }
1:864d9d1:         Monitor.logTextMessage(MessageId.REPLICATION_MASTER_STOPPED, dbname);
1:4aeada8:     }
1:d159b2e: 
1:4aeada8:     /**
1:58addc4:      * @see MasterFactory#startFailover()
1:4aeada8:      */
1:0217bc6:     public void startFailover() throws StandardException {
1:fc4e76b:         if (!active) {
1:fc4e76b:             //It is not correct to stop the master and then attempt a failover.
1:fc4e76b:             //The control would come here because the master module is already
1:fc4e76b:             //loaded and a findService for the master module will not fail. But
1:fc4e76b:             //since this module has been stopped failover does not suceed.
1:fc4e76b:             throw StandardException.newException
1:fc4e76b:                     (SQLState.REPLICATION_NOT_IN_MASTER_MODE);
1:fc4e76b:         }
1:fc4e76b: 
1:0217bc6:         //acknowledgment returned from the slave containing
1:0217bc6:         //the status of the failover performed.
1:0217bc6:         ReplicationMessage ack = null;
1:0217bc6:         
1:fc4e76b:         //A failover stops the master controller and shuts down
1:fc4e76b:         //the master database.
1:fc4e76b:         active = false;
1:0217bc6:         
1:0217bc6:         //freeze the database to stop clients when this command is received
1:0217bc6:         rawStoreFactory.freeze();
1:0217bc6:         
1:0217bc6:         try {
1:0217bc6:             //Flush the log buffer of any remaining log records.
1:0217bc6:             logShipper.flushBuffer();
1:0217bc6:             
1:0217bc6:             //Send the failover message to the slave and wait for 
1:0217bc6:             //acknowledgement.
1:0217bc6:             ReplicationMessage mesg = new ReplicationMessage(
1:0217bc6:                         ReplicationMessage.TYPE_FAILOVER, null);
1:c283bcd:             ack = transmitter.sendMessageWaitForReply(mesg);
1:0217bc6:         } catch (IOException ioe) {
1:0217bc6:             handleFailoverFailure(ioe);
1:0217bc6:         } catch (StandardException se) {
1:0217bc6:             handleFailoverFailure(se);
1:0217bc6:         }
1:0217bc6:         
1:0217bc6:         //check the contents of the acknowledgement received from the slave
1:0217bc6:         //and perform appropriate actions.
1:0217bc6:         if (ack == null) {
1:0217bc6:             //ack can be null if the wait on the socket stream timed out
1:0217bc6:             handleFailoverFailure(null);
1:0217bc6:         } else if (ack.getType() == ReplicationMessage.TYPE_ACK) {
1:0217bc6:             //An exception is thrown to indicate the successful completion 
1:0217bc6:             //of failover. Also the AsynchronousLogShipper thread is terminated.
1:5d5aab5:             //The socket connection that is obtained needs to be torn down.
1:0217bc6:             //The exception thrown is of Database Severity, this shuts
1:0217bc6:             //down the master database.
1:5d5aab5:             teardownNetwork();
1:5a6acbf: 
1:5a6acbf:             //If we require an exception of Database Severity to shutdown the
1:5a6acbf:             //database to shutdown the database we need to unfreeze first
1:5a6acbf:             //before throwing the exception. Unless we unfreeze the shutdown
1:5a6acbf:             //hangs.
1:5a6acbf:             rawStoreFactory.unfreeze();
1:5a6acbf: 
1:0217bc6:             throw StandardException.newException
1:0217bc6:                     (SQLState.REPLICATION_FAILOVER_SUCCESSFUL, dbname);  
1:0217bc6:         } else {
1:0217bc6:             //TYPE_ACK is the only type that is returned. ack can
1:0217bc6:             //ideally not contain any other type. The program should
1:0217bc6:             //ideally not come here.
1:0217bc6:            handleFailoverFailure(null);
1:0217bc6:         }
1:0217bc6:     }
1:0217bc6: 
1:0217bc6:     /**
1:1d0892e:      * Load relevant system property: replication log buffer size
1:4aeada8:      */
1:1d0892e:     private void getMasterProperties() {
1:1d0892e:         logBufferSize =
1:1d0892e:             PropertyUtil.getSystemInt(Property.REPLICATION_LOG_BUFFER_SIZE,
1:1d0892e:                                       DEFAULT_LOG_BUFFER_SIZE);
1:4aeada8: 
1:1d0892e:         if (logBufferSize < LOG_BUFFER_SIZE_MIN) {
1:1d0892e:             logBufferSize = LOG_BUFFER_SIZE_MIN;
1:1d0892e:             if (SanityManager.DEBUG) {
1:1d0892e:                 repLogger.logText("Replication log buffer size " +
1:1d0892e:                                   "property too small. Set to " +
1:1d0892e:                                   "minimum value: " + logBufferSize,
1:1d0892e:                                   false);
1:4aeada8:             }
1:1d0892e:         }  else if (logBufferSize > LOG_BUFFER_SIZE_MAX) {
1:1d0892e:             logBufferSize = LOG_BUFFER_SIZE_MAX;
1:1d0892e:             if (SanityManager.DEBUG) {
1:1d0892e:                 repLogger.logText("Replication log buffer size " +
1:1d0892e:                                   "property too big. Set to " +
1:1d0892e:                                   "maximum value: " + logBufferSize,
1:1d0892e:                                   false);
1:4aeada8:             }
1:4aeada8:         }
1:4aeada8:     }
1:4aeada8:     
1:4aeada8:     /**
1:0217bc6:      * used to handle the case when an attempt to failover the database
1:0217bc6:      * fails.
1:0217bc6:      *
1:0217bc6:      * @param t        The throwable which resulted in the aborted failover
1:0217bc6:      *                 attempt.
1:0217bc6:      * 
1:0217bc6:      * @throws StandardException Indicating the reason for the aborted
1:0217bc6:      *                          failover attempt. 
1:0217bc6:      */
1:0217bc6:     private void handleFailoverFailure(Throwable t) 
1:0217bc6:     throws StandardException {
1:5d5aab5:         teardownNetwork();
1:4c4c239:         rawStoreFactory.unfreeze();
1:0217bc6:         if (t != null) {
1:0217bc6:             throw StandardException.newException
1:0217bc6:                         (SQLState.REPLICATION_FAILOVER_UNSUCCESSFUL, t, dbname);
1:0217bc6:         } else {
1:0217bc6:             throw StandardException.newException
1:0217bc6:                         (SQLState.REPLICATION_FAILOVER_UNSUCCESSFUL, dbname);
1:0217bc6:         }
1:0217bc6:     }
1:0217bc6:     
1:4aeada8:     /**
1:1872308:      * Append a chunk of log records to the log buffer. The method is not 
1:1872308:      * threadsafe; only one thread should access this method at a time. 
1:4aeada8:      *
1:5235dfd:      * @param greatestInstant   the instant of the log record that was
1:5235dfd:      *                          added last to this chunk of log
1:5235dfd:      * @param log               the chunk of log records
1:5235dfd:      * @param logOffset         offset in log to start copy from
1:5235dfd:      * @param logLength         number of bytes to copy, starting
1:5235dfd:      *                          from logOffset
1:4aeada8:      **/
1:5235dfd:     public void appendLog(long greatestInstant,
1:5235dfd:                           byte[] log, int logOffset, int logLength){
1:5235dfd: 
1:0f8eece:         try {
1:5235dfd:             logBuffer.appendLog(greatestInstant, log, logOffset, logLength);
1:4aeada8:         } catch (LogBufferFullException lbfe) {
1:864d9d1:             try {
1:864d9d1:                 logShipper.forceFlush();
1:0c97a10:                 // Either the forceFlush succeeded in sending a chunk of log
1:0c97a10:                 // (making room for this log chunk in the buffer), or
1:0c97a10:                 // forceFlush did not succeed (in which case replication is
1:0c97a10:                 // stopped)
1:0c97a10:                 logBuffer.appendLog(greatestInstant, log,
1:0c97a10:                                     logOffset, logLength);
1:0c97a10:             } catch (LogBufferFullException lbfe2) {
1:0c97a10:                 printStackAndStopMaster(lbfe2);
1:864d9d1:             } catch (IOException ioe) {
1:864d9d1:                 printStackAndStopMaster(ioe);
1:864d9d1:             } catch (StandardException se) {
1:864d9d1:                 printStackAndStopMaster(se);
1:864d9d1:             }
1:4aeada8:         }
1:4aeada8:     }
1:4aeada8: 
1:4aeada8:     /**
1:4aeada8:      * Used by the LogFactory to notify the replication master
1:4aeada8:      * controller that the log records up to this instant have been
1:4aeada8:      * flushed to disk. The master controller takes action according
1:4aeada8:      * to the current replication strategy when this method is called.
1:4aeada8:      *
1:4aeada8:      * When the asynchronous replication strategy is used, the method
1:4aeada8:      * does not force log shipping to the slave; the log records may
1:4aeada8:      * be shipped now or later at the MasterController's discretion.
1:4aeada8:      *
1:4aeada8:      * However, if another strategy like 2-safe replication is
1:4aeada8:      * implemented in the future, a call to this method may force log
1:4aeada8:      * shipment before returning control to the caller.
1:4aeada8:      *
1:4aeada8:      * Currently, only asynchronous replication is supported.
1:4aeada8:      *
1:864d9d1:      * Not implemented yet
1:4aeada8:      *
1:4aeada8:      * @param instant The highest log instant that has been flushed to
1:4aeada8:      * disk
1:4aeada8:      *
1:4aeada8:      * @see MasterFactory#flushedTo
1:4aeada8:      * @see LogFactory#flush
1:4aeada8:      */
1:4aeada8:     public void flushedTo(long instant) {
1:864d9d1:         logShipper.flushedInstance(instant); 
1:864d9d1:     }
1:eeeece4:     
1:eeeece4:     /**
1:864d9d1:      * Connects to the slave being replicated to.
1:864d9d1:      *
1:864d9d1:      * @throws StandardException If a failure occurs while trying to open
1:864d9d1:      *                           the connection to the slave.
1:864d9d1:      */
1:864d9d1:     private void setupConnection() throws StandardException {
1:864d9d1:         try {
1:c283bcd:             if (transmitter != null) {
1:c283bcd:                 transmitter.tearDown();
1:c283bcd:             }
1:f2ec1d8:             transmitter = new ReplicationMessageTransmit(slaveAddr);
1:f2ec1d8:             
1:29fd25c:             // getHighestShippedInstant is -1 until the first log
1:29fd25c:             // chunk has been shipped to the slave. If a log chunk has
1:29fd25c:             // been shipped, use the instant of the latest shipped log
1:29fd25c:             // record to synchronize log files. If no log has been
1:29fd25c:             // shipped yet, use the end position of the log (i.e.,
1:29fd25c:             // logToFile.getFirstUnflushedInstantAsLong). 
1:29fd25c:             if (logShipper != null && 
1:29fd25c:                 logShipper.getHighestShippedInstant() != -1) {
1:29fd25c:                 transmitter.initConnection(SLAVE_CONNECTION_ATTEMPT_TIMEOUT,
1:29fd25c:                                            logShipper.
1:29fd25c:                                            getHighestShippedInstant());
1:29fd25c:             } else {
1:29fd25c:                 transmitter.initConnection(SLAVE_CONNECTION_ATTEMPT_TIMEOUT,
1:29fd25c:                                            logFactory.
1:29fd25c:                                            getFirstUnflushedInstantAsLong());
1:c283bcd:             }
1:864d9d1:         } catch (SocketTimeoutException ste) {
1:864d9d1:             throw StandardException.newException
1:864d9d1:                     (SQLState.REPLICATION_MASTER_TIMED_OUT, dbname);
1:864d9d1:         } catch (IOException ioe) {
1:864d9d1:             throw StandardException.newException
1:334e9a3:                     (SQLState.REPLICATION_CONNECTION_EXCEPTION, ioe, 
1:f2ec1d8:                      dbname, getHostName(), String.valueOf(getPortNumber()));
1:29fd25c:         } catch (StandardException se) {
1:29fd25c:             throw se;
1:864d9d1:         } catch (Exception e) {
1:864d9d1:             throw StandardException.newException
1:334e9a3:                     (SQLState.REPLICATION_CONNECTION_EXCEPTION, e,
1:f2ec1d8:                      dbname, getHostName(), String.valueOf(getPortNumber()));
1:29fd25c:         }
1:864d9d1:     }
1:864d9d1:     
1:864d9d1:     /**
1:864d9d1:      * Used to handle the exceptions (IOException and StandardException) from 
1:864d9d1:      * the log shipper.
1:eeeece4:      *
1:eeeece4:      * @param exception the exception which caused the log shipper to terminate
1:eeeece4:      *                  in an unexcepted manner.
1:8971c8b:      *
1:8971c8b:      * @return an instance of the transmitter used to transmit messages to the
1:8971c8b:      *         slave.
1:eeeece4:      */
1:8971c8b:     ReplicationMessageTransmit handleExceptions(Exception exception) {
1:864d9d1:         if (exception instanceof IOException) {
1:1d0892e:             repLogger.logError(MessageId.REPLICATION_LOGSHIPPER_EXCEPTION,
1:1d0892e:                                exception);
1:864d9d1:             Monitor.logTextMessage(MessageId.REPLICATION_MASTER_RECONN, dbname);
1:864d9d1:             
1:fc4e76b:             while (active) {
1:864d9d1:                 try {
1:f2ec1d8:                     transmitter = new ReplicationMessageTransmit(slaveAddr);
1:29fd25c:                     // see comment in setupConnection
1:29fd25c:                     if (logShipper != null &&
1:29fd25c:                         logShipper.getHighestShippedInstant() != -1) {
1:29fd25c:                         transmitter.
1:29fd25c:                             initConnection(SLAVE_CONNECTION_ATTEMPT_TIMEOUT,
1:29fd25c:                                            logShipper.
1:29fd25c:                                            getHighestShippedInstant());
1:29fd25c:                     } else {
1:29fd25c:                         transmitter.
1:29fd25c:                             initConnection(SLAVE_CONNECTION_ATTEMPT_TIMEOUT,
1:29fd25c:                                            logFactory.
1:29fd25c:                                            getFirstUnflushedInstantAsLong());
1:29fd25c:                     }
1:29fd25c: 
1:864d9d1:                     break;
1:864d9d1:                 } catch (SocketTimeoutException ste) {
1:864d9d1:                     continue;
1:864d9d1:                 } catch (IOException ioe) {
1:864d9d1:                     continue;
1:864d9d1:                 } catch (Exception e) {
1:864d9d1:                     printStackAndStopMaster(e);
1:8971c8b:                     return null;
1:864d9d1:                 }
1:864d9d1:             }
1:864d9d1:         } else if (exception instanceof StandardException) {
1:864d9d1:             printStackAndStopMaster(exception);
1:8971c8b:             return null;
1:864d9d1:         }
1:8971c8b:         return transmitter;
1:864d9d1:     }
1:864d9d1:     
1:864d9d1:     /**
1:864d9d1:      * used to print the error stack for the given exception and
1:864d9d1:      * stop the master.
1:864d9d1:      *
1:46ed45c:      * @param e the exception that needs to be handled.
1:864d9d1:      */
1:46ed45c:     private void printStackAndStopMaster(Exception e) {
1:46ed45c:         repLogger.logError(MessageId.REPLICATION_LOGSHIPPER_EXCEPTION, e);
1:5235dfd:         try {
1:fc4e76b:             stopMaster();
1:46ed45c:         } catch (StandardException se) {
1:fc4e76b:             //The stop master threw an exception saying the replication
1:fc4e76b:             //has been stopped already.
1:1d0892e:             repLogger.
1:46ed45c:                 logError(MessageId.REPLICATION_MASTER_STOPPED, se);
1:fc4e76b:         }
1:5235dfd:     }
1:5235dfd:     
1:4aeada8:     /**
1:2146e78:      * Used to notify the log shipper that a log buffer element is full.
1:2146e78:      */
1:2146e78:     public void workToDo() {
1:2146e78:         logShipper.workToDo();
1:2146e78:     }
1:29fd25c: 
1:29fd25c:     /**
1:29fd25c:      * Stop log shipping, notify slave that replication is stopped and
1:29fd25c:      * tear down network connection with slave.
1:29fd25c:      */
1:29fd25c:     private void teardownNetwork() {
1:29fd25c: 
1:29fd25c:         if (logShipper != null) {
1:29fd25c:             logShipper.stopLogShipment();
1:29fd25c:         }
1:29fd25c: 
1:c283bcd:         if (transmitter != null) {
1:29fd25c:             try {
1:29fd25c:                 ReplicationMessage mesg =
1:29fd25c:                     new ReplicationMessage(ReplicationMessage.TYPE_STOP, null);
1:29fd25c:                 transmitter.sendMessage(mesg);
1:29fd25c:             } catch (IOException ioe) {}
1:29fd25c:             try {
1:c283bcd:                 transmitter.tearDown();
1:29fd25c:             } catch (IOException ioe) {}
1:29fd25c:         }
1:29fd25c:     }
1:29fd25c: 
1:0217bc6:     /**
1:41a2601:      * <p>
1:41a2601:      * Returns a name of a database associated with this master
1:41a2601:      * controller.
1:41a2601:      * </p>
1:41a2601:      * 
1:41a2601:      * <p>
1:41a2601:      * Note: The only purpose of the method as of now is to give a 
1:41a2601:      * meaningful name to a log shipper thread. The log shipper thread 
1:41a2601:      * name should contain a name of a corresponding master database,
1:41a2601:      * and this method is used to access it.
1:41a2601:      * </p>
1:41a2601:      * 
1:41a2601:      * @return a master database name
1:41a2601:      */
1:41a2601:     String getDbName() {
1:41a2601:         return this.dbname;
1:41a2601:     }
1:f2ec1d8:     
1:f2ec1d8:     /**
1:f2ec1d8:      * Used to return the host name of the slave being connected to.
1:f2ec1d8:      *
1:f2ec1d8:      * @return a String containing the host name of the slave being
1:f2ec1d8:      *         connected to.
1:f2ec1d8:      */
1:f2ec1d8:     private String getHostName() {
1:f2ec1d8:         return slaveAddr.getHostAddress().getHostName();
1:f2ec1d8:     }
1:f2ec1d8:     
1:f2ec1d8:     /**
1:f2ec1d8:      * Used to return the port number of the slave being connected to.
1:f2ec1d8:      *
1:f2ec1d8:      * @return an Integer that represents the port number of the slave
1:f2ec1d8:      *         being connected to.
1:f2ec1d8:      */
1:f2ec1d8:     private int getPortNumber() {
1:f2ec1d8:         return slaveAddr.getPortNumber();
1:f2ec1d8:     }
1:eeeece4: }
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Lily Wei
-------------------------------------------------------------------------------
commit:eb7e251
/////////////////////////////////////////////////////////////////////////
1:             slaveAddr = new SlaveAddress(slavehost, slaveport);
author:Oystein Grovlen
-------------------------------------------------------------------------------
commit:f2ec1d8
/////////////////////////////////////////////////////////////////////////
1: import java.net.UnknownHostException;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.impl.store.replication.net.SlaveAddress;
/////////////////////////////////////////////////////////////////////////
1:     private SlaveAddress slaveAddr;
/////////////////////////////////////////////////////////////////////////
1:         try {
0:             slaveAddr = new SlaveAddress(slavehost, 
0:                     (new Integer(slaveport)).intValue());
1:         } catch (UnknownHostException uhe) {
1:             throw StandardException.newException
1:                     (SQLState.REPLICATION_CONNECTION_EXCEPTION, uhe, 
1:                      dbname, getHostName(), String.valueOf(getPortNumber()));
1:         }
1:         
/////////////////////////////////////////////////////////////////////////
1:             transmitter = new ReplicationMessageTransmit(slaveAddr);
1:             
/////////////////////////////////////////////////////////////////////////
1:                      dbname, getHostName(), String.valueOf(getPortNumber()));
1:                      dbname, getHostName(), String.valueOf(getPortNumber()));
/////////////////////////////////////////////////////////////////////////
1:                     transmitter = new ReplicationMessageTransmit(slaveAddr);
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Used to return the host name of the slave being connected to.
1:      *
1:      * @return a String containing the host name of the slave being
1:      *         connected to.
1:      */
1:     private String getHostName() {
1:         return slaveAddr.getHostAddress().getHostName();
1:     }
1:     
1:     /**
1:      * Used to return the port number of the slave being connected to.
1:      *
1:      * @return an Integer that represents the port number of the slave
1:      *         being connected to.
1:      */
1:     private int getPortNumber() {
1:         return slaveAddr.getPortNumber();
1:     }
commit:0c97a10
/////////////////////////////////////////////////////////////////////////
1:                 // Either the forceFlush succeeded in sending a chunk of log
1:                 // (making room for this log chunk in the buffer), or
1:                 // forceFlush did not succeed (in which case replication is
1:                 // stopped)
1:                 logBuffer.appendLog(greatestInstant, log,
1:                                     logOffset, logLength);
1:             } catch (LogBufferFullException lbfe2) {
1:                 printStackAndStopMaster(lbfe2);
commit:8971c8b
/////////////////////////////////////////////////////////////////////////
1:      *
1:      * @return an instance of the transmitter used to transmit messages to the
1:      *         slave.
1:     ReplicationMessageTransmit handleExceptions(Exception exception) {
/////////////////////////////////////////////////////////////////////////
1:                     return null;
1:             return null;
1:         return transmitter;
commit:c283bcd
/////////////////////////////////////////////////////////////////////////
1:             ack = transmitter.sendMessageWaitForReply(mesg);
/////////////////////////////////////////////////////////////////////////
1:             if (transmitter != null) {
1:                 transmitter.tearDown();
1:             }
0:             transmitter = new ReplicationMessageTransmit(slavehost,
0:                                                          slaveport,
0:                                                          dbname);
/////////////////////////////////////////////////////////////////////////
1:                     if (transmitter != null) {
1:                         transmitter.tearDown();
1:                     }
0:                     transmitter = new ReplicationMessageTransmit(slavehost,
0:                                                                  slaveport,
0:                                                                  dbname);
commit:56c419e
/////////////////////////////////////////////////////////////////////////
1:      * Will stop the replication master service.
1:     public void stop() { 
1:         try {
1:             stopMaster();
1:         } catch (StandardException se) {
1:             repLogger.
1:                 logError(MessageId.REPLICATION_MASTER_STOPPED, se);
1:         }
1:        
1:     }
/////////////////////////////////////////////////////////////////////////
1:                 logShipper.setDaemon(true);
1:                 logShipper.start();
commit:1bac3f3
/////////////////////////////////////////////////////////////////////////
1:    org.apache.derby.impl.store.replication.master.MasterController
/////////////////////////////////////////////////////////////////////////
1: package org.apache.derby.impl.store.replication.master;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.store.replication.master.MasterFactory;
1: import org.apache.derby.impl.store.replication.net.ReplicationMessage;
1: import org.apache.derby.impl.store.replication.ReplicationLogger;
1: import org.apache.derby.impl.store.replication.net.ReplicationMessageTransmit;
1: import org.apache.derby.impl.store.replication.buffer.ReplicationLogBuffer;
1: import org.apache.derby.impl.store.replication.buffer.LogBufferFullException;
commit:46ed45c
/////////////////////////////////////////////////////////////////////////
1:      * @param e the exception that needs to be handled.
1:     private void printStackAndStopMaster(Exception e) {
1:         repLogger.logError(MessageId.REPLICATION_LOGSHIPPER_EXCEPTION, e);
1:         } catch (StandardException se) {
1:                 logError(MessageId.REPLICATION_MASTER_STOPPED, se);
commit:fc4e76b
/////////////////////////////////////////////////////////////////////////
1:     //Indicates whether the Master Controller is currently
1:     //active
1:     private boolean active = false;
/////////////////////////////////////////////////////////////////////////
1:      * Used by Monitor.bootServiceModule to start the service. Currently
1:      * only used to set up the replication mode.
1:      *                   correct mode. Currently initializes only the
1:      *                   replicationMode property.
1:         //The boot method is loaded only once, because of that the
1:         //boot time parameters once wrong would result in repeated
1:         //startMaster attempts failing. In order to allow for
1:         //multiple start master attempts the slave host name, port
1:         //number and the dbname have been moved to the startMaster
1:         //method.
/////////////////////////////////////////////////////////////////////////
1:      * @param slavehost The hostname of the slave
1:      * @param slaveport The port the slave is listening on
1:      * @param dbname The master database that is being replicated.
1:      *                              1) thrown on replication startup error
1:      *                              2) thrown if the master has already been
1:      *                                 booted.
1:      *                              3) thrown if the specified replication mode
1:      *                                 is not supported.
1:                             DataFactory dataFac,
1:                             LogFactory logFac,
1:                             String slavehost,
1:                             int slaveport,
1:                             String dbname)
1:         if (active) {
1:             //It is wrong to attempt startMaster on a already
1:             //started master.
1:             throw StandardException.newException
1:                     (SQLState.REPLICATION_MASTER_ALREADY_BOOTED, dbname);
1:         }
1: 
0:         this.slavehost = slavehost;
0:         this.slaveport = new Integer(slaveport).intValue();
1:         this.dbname = dbname;
1: 
/////////////////////////////////////////////////////////////////////////
1:         //The master has been started successfully.
1:         active = true;
1: 
/////////////////////////////////////////////////////////////////////////
1:      * Will perform all work that is needed to shut down replication.
1:      *
1:      * @throws StandardException If the replication master has been stopped
1:      *                           already.
1:     public void stopMaster() throws StandardException {
1:         if (!active) {
1:             throw StandardException.newException
1:                     (SQLState.REPLICATION_NOT_IN_MASTER_MODE);
1:         }
1:         active = false;
/////////////////////////////////////////////////////////////////////////
1:         if (!active) {
1:             //It is not correct to stop the master and then attempt a failover.
1:             //The control would come here because the master module is already
1:             //loaded and a findService for the master module will not fail. But
1:             //since this module has been stopped failover does not suceed.
1:             throw StandardException.newException
1:                     (SQLState.REPLICATION_NOT_IN_MASTER_MODE);
1:         }
1: 
1:         //A failover stops the master controller and shuts down
1:         //the master database.
1:         active = false;
/////////////////////////////////////////////////////////////////////////
1:             while (active) {
/////////////////////////////////////////////////////////////////////////
1:         try {
1:             stopMaster();
0:         } catch (Throwable t_stopmaster) {
1:             //The stop master threw an exception saying the replication
1:             //has been stopped already.
0:             ReplicationLogger.
0:                 logError(MessageId.REPLICATION_MASTER_STOPPED, t, dbname);
1:         }
commit:1872308
/////////////////////////////////////////////////////////////////////////
1:      * Append a chunk of log records to the log buffer. The method is not 
1:      * threadsafe; only one thread should access this method at a time. 
/////////////////////////////////////////////////////////////////////////
0:                 // There should now be room for this log chunk in the buffer
0:                 appendLog(greatestInstant, log, logOffset, logLength);
commit:41a2601
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * <p>
1:      * Returns a name of a database associated with this master
1:      * controller.
1:      * </p>
1:      * 
1:      * <p>
1:      * Note: The only purpose of the method as of now is to give a 
1:      * meaningful name to a log shipper thread. The log shipper thread 
1:      * name should contain a name of a corresponding master database,
1:      * and this method is used to access it.
1:      * </p>
1:      * 
1:      * @return a master database name
1:      */
1:     String getDbName() {
1:         return this.dbname;
1:     }
commit:f0fbf76
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         } finally {
1:             teardownNetwork();
commit:5a6acbf
/////////////////////////////////////////////////////////////////////////
1: 
1:             //If we require an exception of Database Severity to shutdown the
1:             //database to shutdown the database we need to unfreeze first
1:             //before throwing the exception. Unless we unfreeze the shutdown
1:             //hangs.
1:             rawStoreFactory.unfreeze();
1: 
commit:5d5aab5
/////////////////////////////////////////////////////////////////////////
1:             //The socket connection that is obtained needs to be torn down.
1:             teardownNetwork();
/////////////////////////////////////////////////////////////////////////
1:         teardownNetwork();
commit:29fd25c
/////////////////////////////////////////////////////////////////////////
1:         try {
1:             logFactory.startReplicationMasterRole(this);
1:             rawStoreFactory.unfreeze();
1:             setupConnection();
1:             if (replicationMode.equals(MasterFactory.ASYNCHRONOUS_MODE)) {
1:                 logShipper = new AsynchronousLogShipper(logBuffer,
1:                                                         transmitter,
0:                                                         this);
0:                 ((Thread)logShipper).start();
1:             }
1:         } catch (StandardException se) {
1:             // cleanup everything that may have been started before
1:             // the exception was thrown
0:             ReplicationLogger.logError(MessageId.REPLICATION_FATAL_ERROR, null,
0:                                        dbname);
1:             logFactory.stopReplicationMasterRole();
1:             teardownNetwork();
1:             throw se;
/////////////////////////////////////////////////////////////////////////
0:             teardownNetwork();
/////////////////////////////////////////////////////////////////////////
1:             // getHighestShippedInstant is -1 until the first log
1:             // chunk has been shipped to the slave. If a log chunk has
1:             // been shipped, use the instant of the latest shipped log
1:             // record to synchronize log files. If no log has been
1:             // shipped yet, use the end position of the log (i.e.,
1:             // logToFile.getFirstUnflushedInstantAsLong). 
1:             if (logShipper != null && 
1:                 logShipper.getHighestShippedInstant() != -1) {
1:                 transmitter.initConnection(SLAVE_CONNECTION_ATTEMPT_TIMEOUT,
1:                                            logShipper.
1:                                            getHighestShippedInstant());
1:             } else {
1:                 transmitter.initConnection(SLAVE_CONNECTION_ATTEMPT_TIMEOUT,
1:                                            logFactory.
1:                                            getFirstUnflushedInstantAsLong());
1:             }
/////////////////////////////////////////////////////////////////////////
1:         } catch (StandardException se) {
1:             throw se;
/////////////////////////////////////////////////////////////////////////
1: 
1:                     // see comment in setupConnection
1:                     if (logShipper != null &&
1:                         logShipper.getHighestShippedInstant() != -1) {
1:                         transmitter.
1:                             initConnection(SLAVE_CONNECTION_ATTEMPT_TIMEOUT,
1:                                            logShipper.
1:                                            getHighestShippedInstant());
1:                     } else {
1:                         transmitter.
1:                             initConnection(SLAVE_CONNECTION_ATTEMPT_TIMEOUT,
1:                                            logFactory.
1:                                            getFirstUnflushedInstantAsLong());
1:                     }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Stop log shipping, notify slave that replication is stopped and
1:      * tear down network connection with slave.
1:      */
1:     private void teardownNetwork() {
1: 
1:         if (logShipper != null) {
1:             logShipper.stopLogShipment();
1:         }
1: 
0:         if (transmitter != null) {
1:             try {
1:                 ReplicationMessage mesg =
1:                     new ReplicationMessage(ReplicationMessage.TYPE_STOP, null);
1:                 transmitter.sendMessage(mesg);
1:             } catch (IOException ioe) {}
1:             try {
0:                 transmitter.tearDown();
1:             } catch (IOException ioe) {}
1:         }
1:     }
1: 
commit:4c4c239
/////////////////////////////////////////////////////////////////////////
1:         
1:         rawStoreFactory.unfreeze();
commit:2146e78
/////////////////////////////////////////////////////////////////////////
0:         logBuffer = new ReplicationLogBuffer(DEFAULT_LOG_BUFFER_SIZE, this);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Used to notify the log shipper that a log buffer element is full.
1:      */
1:     public void workToDo() {
1:         logShipper.workToDo();
1:     }
commit:334e9a3
/////////////////////////////////////////////////////////////////////////
1:                     (SQLState.REPLICATION_CONNECTION_EXCEPTION, ioe, 
0:                      dbname, slavehost, String.valueOf(slaveport));
1:                     (SQLState.REPLICATION_CONNECTION_EXCEPTION, e,
0:                      dbname, slavehost, String.valueOf(slaveport));
commit:fd20d6b
/////////////////////////////////////////////////////////////////////////
0:      * @see org.apache.derby.iapi.services.replication.master.MasterFactory#startFailover()
commit:696377a
/////////////////////////////////////////////////////////////////////////
1: public class MasterController 
/////////////////////////////////////////////////////////////////////////
0:             ReplicationLogger.
0:                 logError(MessageId.REPLICATION_LOGSHIPPER_EXCEPTION,
0:                          ioe, dbname);
0:             ReplicationLogger.
0:                 logError(MessageId.REPLICATION_LOGSHIPPER_EXCEPTION, 
0:                          se, dbname);
/////////////////////////////////////////////////////////////////////////
0:             ReplicationLogger.
0:                 logError(MessageId.REPLICATION_LOGSHIPPER_EXCEPTION, 
0:                          exception, dbname);
/////////////////////////////////////////////////////////////////////////
0:         ReplicationLogger.
0:             logError(MessageId.REPLICATION_LOGSHIPPER_EXCEPTION, t, dbname);
commit:0217bc6
/////////////////////////////////////////////////////////////////////////
0:      * Will perform all work needed to failover.
1:      *
0:      * @throws StandardException 1) If the failover succeeds
0:      *                           2) If a failure occurs during network 
0:      *                              communication with slave.
1:      */
1:     public void startFailover() throws StandardException {
1:         //acknowledgment returned from the slave containing
1:         //the status of the failover performed.
1:         ReplicationMessage ack = null;
1:         
0:         stopMasterController = true;
1:         
1:         //freeze the database to stop clients when this command is received
1:         rawStoreFactory.freeze();
1:         
1:         try {
1:             //Flush the log buffer of any remaining log records.
1:             logShipper.flushBuffer();
1:             
1:             //Send the failover message to the slave and wait for 
1:             //acknowledgement.
1:             ReplicationMessage mesg = new ReplicationMessage(
1:                         ReplicationMessage.TYPE_FAILOVER, null);
0:             transmitter.sendMessage(mesg);
0:             ack = transmitter.readMessage();
1:         } catch (IOException ioe) {
1:             handleFailoverFailure(ioe);
1:         } catch (StandardException se) {
1:             handleFailoverFailure(se);
0:         } catch (ClassNotFoundException cnfe) {
0:             handleFailoverFailure(cnfe);
1:         }
1:         
1:         //check the contents of the acknowledgement received from the slave
1:         //and perform appropriate actions.
1:         if (ack == null) {
1:             //ack can be null if the wait on the socket stream timed out
1:             handleFailoverFailure(null);
1:         } else if (ack.getType() == ReplicationMessage.TYPE_ACK) {
1:             //An exception is thrown to indicate the successful completion 
1:             //of failover. Also the AsynchronousLogShipper thread is terminated.
1:             //The exception thrown is of Database Severity, this shuts
1:             //down the master database.
0:             logShipper.stopLogShipment();
1:             throw StandardException.newException
1:                     (SQLState.REPLICATION_FAILOVER_SUCCESSFUL, dbname);  
1:         } else {
1:             //TYPE_ACK is the only type that is returned. ack can
1:             //ideally not contain any other type. The program should
1:             //ideally not come here.
1:            handleFailoverFailure(null);
1:         }
1:     }
1:     
1:     /**
1:      * used to handle the case when an attempt to failover the database
1:      * fails.
1:      *
1:      * @param t        The throwable which resulted in the aborted failover
1:      *                 attempt.
1:      * 
1:      * @throws StandardException Indicating the reason for the aborted
1:      *                          failover attempt. 
1:      */
1:     private void handleFailoverFailure(Throwable t) 
1:     throws StandardException {
0:         rawStoreFactory.unfreeze();
1:         if (t != null) {
1:             throw StandardException.newException
1:                         (SQLState.REPLICATION_FAILOVER_UNSUCCESSFUL, t, dbname);
1:         } else {
1:             throw StandardException.newException
1:                         (SQLState.REPLICATION_FAILOVER_UNSUCCESSFUL, dbname);
1:         }
1:     }
1:     
1:     /**
commit:d159b2e
/////////////////////////////////////////////////////////////////////////
1:             
0:             logShipper.stopLogShipment();
commit:0f8eece
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.impl.services.replication.net.ReplicationMessage;
/////////////////////////////////////////////////////////////////////////
1:         logFactory.stopReplicationMasterRole();
1:         try {
1:             logShipper.flushBuffer();
1: 
0:             ReplicationMessage mesg = new ReplicationMessage(
0:                         ReplicationMessage.TYPE_STOP, null);
1: 
0:             transmitter.sendMessage(mesg);
1:         } catch (IOException ioe) {
0:             logError(MessageId.REPLICATION_LOGSHIPPER_EXCEPTION, ioe, dbname);
1:         } catch(StandardException se) {
0:             logError(MessageId.REPLICATION_LOGSHIPPER_EXCEPTION, se, dbname);
1:         }
commit:864d9d1
/////////////////////////////////////////////////////////////////////////
1: import java.io.IOException;
1: import java.net.SocketTimeoutException;
1: import org.apache.derby.iapi.reference.MessageId;
1: import org.apache.derby.iapi.services.monitor.Monitor;
1: 
0: import org.apache.derby.impl.services.replication.ReplicationLogger;
/////////////////////////////////////////////////////////////////////////
0: public class MasterController extends ReplicationLogger 
1:         implements MasterFactory, ModuleControl, ModuleSupportable {
/////////////////////////////////////////////////////////////////////////
1:     private AsynchronousLogShipper logShipper;
1:     private String dbname;
1:     
0:     //Set to true when stopMaster is called
0:     private boolean stopMasterController = false;
1:     //How long to wait before reporting the failure to
1:     //establish a connection with the slave.
1:     // TODO: make this configurable through a property
1:     private static final int SLAVE_CONNECTION_ATTEMPT_TIMEOUT = 5000;
/////////////////////////////////////////////////////////////////////////
0:         dbname = properties.getProperty(MasterFactory.MASTER_DB);
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
0:      * Will stop the replication master service
1:      *
1:      * Not implemented yet
1:      */
0:     public void stop() { }
1:      * Will perform all the work that is needed to set up replication.
/////////////////////////////////////////////////////////////////////////
0:                             DataFactory dataFac, LogFactory logFac) 
1:                             throws StandardException {
0:         stopMasterController = false;
0:         setupConnection();
1: 
0:             logShipper = new AsynchronousLogShipper(logBuffer,
0:                                                     transmitter,
0:                                                     1000,
0:                                                     this);
0:             ((Thread)logShipper).start();
/////////////////////////////////////////////////////////////////////////
1:         Monitor.logTextMessage(MessageId.REPLICATION_MASTER_STARTED, dbname);
0:         stopMasterController = true;
0:         //interrupt the periodic shipper first
0:         logShipper.interrupt();
0:         //This would ensure that any further call to forceFlush fails.
0:         logShipper.stopLogShipment();
1:         Monitor.logTextMessage(MessageId.REPLICATION_MASTER_STOPPED, dbname);
/////////////////////////////////////////////////////////////////////////
1:             try {
1:                 logShipper.forceFlush();
1:             } catch (IOException ioe) {
1:                 printStackAndStopMaster(ioe);
1:             } catch (StandardException se) {
1:                 printStackAndStopMaster(se);
1:             }
/////////////////////////////////////////////////////////////////////////
1:         logShipper.flushedInstance(instant); 
1:      * Connects to the slave being replicated to.
1:      *
1:      * @throws StandardException If a failure occurs while trying to open
1:      *                           the connection to the slave.
1:      */
1:     private void setupConnection() throws StandardException {
1:         try {
0:             transmitter = new ReplicationMessageTransmit(slavehost, slaveport);
0:             transmitter.initConnection(SLAVE_CONNECTION_ATTEMPT_TIMEOUT);
1:         } catch (SocketTimeoutException ste) {
1:             throw StandardException.newException
1:                     (SQLState.REPLICATION_MASTER_TIMED_OUT, dbname);
1:         } catch (IOException ioe) {
1:             throw StandardException.newException
0:                     (SQLState.REPLICATION_CONNECTION_EXCEPTION, ioe, dbname);
1:         } catch (Exception e) {
1:             throw StandardException.newException
0:                     (SQLState.REPLICATION_CONNECTION_EXCEPTION, e, dbname);
1:         }
1:     }
1:     
1:     /**
1:      * Used to handle the exceptions (IOException and StandardException) from 
1:      * the log shipper.
1:         if (exception instanceof IOException) {
0:             logError(MessageId.REPLICATION_LOGSHIPPER_EXCEPTION, 
0:                     exception, dbname);
1:             Monitor.logTextMessage(MessageId.REPLICATION_MASTER_RECONN, dbname);
1:             
0:             while (!stopMasterController) {
1:                 try {
0:                     transmitter = new ReplicationMessageTransmit
0:                             (slavehost, slaveport);
0:                     transmitter.initConnection
0:                             (SLAVE_CONNECTION_ATTEMPT_TIMEOUT);
1:                     break;
1:                 } catch (SocketTimeoutException ste) {
1:                     continue;
1:                 } catch (IOException ioe) {
1:                     continue;
1:                 } catch (Exception e) {
1:                     printStackAndStopMaster(e);
1:                 }
1:             }
1:         } else if (exception instanceof StandardException) {
1:             printStackAndStopMaster(exception);
1:         }
1:     }
1:     
1:     /**
1:      * used to print the error stack for the given exception and
1:      * stop the master.
1:      *
0:      * @param t the throwable that needs to be handled.
1:      */
0:     private void printStackAndStopMaster(Throwable t) {
0:         logError(MessageId.REPLICATION_LOGSHIPPER_EXCEPTION, t, dbname);
0:         stopMaster();
commit:5235dfd
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.impl.services.replication.net.ReplicationMessageTransmit;
/////////////////////////////////////////////////////////////////////////
1:     private ReplicationMessageTransmit transmitter; 
/////////////////////////////////////////////////////////////////////////
0:     private boolean setupConnection(){
1:         try {
0:             transmitter = new ReplicationMessageTransmit(slavehost, slaveport);
0:             transmitter.initConnection();
1:             return true;
0:         } catch (Exception e) {
0:             // printline used for debugging - will be removed
0:             System.out.println("(MC) Got an exception during setupConnection:");
1:             return false;
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:         // May want to move this below connectblock later when
0:         // database is not filesystem copied to slave. 
/////////////////////////////////////////////////////////////////////////
0:      * Append a chunk of log records to the log buffer.
1:      * @param greatestInstant   the instant of the log record that was
1:      *                          added last to this chunk of log
1:      * @param log               the chunk of log records
1:      * @param logOffset         offset in log to start copy from
1:      * @param logLength         number of bytes to copy, starting
1:      *                          from logOffset
1:     public void appendLog(long greatestInstant,
1:                           byte[] log, int logOffset, int logLength){
1: 
1:             logBuffer.appendLog(greatestInstant, log, logOffset, logLength);
commit:eeeece4
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
0:      * Used by the log shipper to inform the master controller about the 
0:      * exception condition that caused it to terminate unexpectedly.
1:      *
1:      * @param exception the exception which caused the log shipper to terminate
1:      *                  in an unexcepted manner.
1:      */
0:     void handleExceptions(Exception exception) {
1:     }
commit:c414a36
/////////////////////////////////////////////////////////////////////////
1:      * @exception StandardException Standard Derby exception policy,
0:      * thrown on replication startup error. 
0:                             DataFactory dataFac, LogFactory logFac)
0:         throws StandardException{
/////////////////////////////////////////////////////////////////////////
0:         logFactory.startReplicationMasterRole(this);
1: 
/////////////////////////////////////////////////////////////////////////
0:      * @param instant               the log address of this log record.
0:      * @param dataOffset            offset in data[] to start copying from.
0:      * @param optionalDataOffset    offset in optionalData[] to start copy from
0:      * @param optionalDataLength    number of bytes in optionalData[]
0:     public void appendLogRecord(int dataLength,
0:                                 long instant,
0:                                 int dataOffset,
0:                                 byte[] optionalData, 
0:                                 int optionalDataOffset,
0:                                 int optionalDataLength) {
commit:4aeada8
/////////////////////////////////////////////////////////////////////////
1: /*
1:  
1:    Derby - Class
0:    org.apache.derby.impl.services.replication.master.MasterController
1:  
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1:  
1:       http://www.apache.org/licenses/LICENSE-2.0
1:  
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1:  
1: */
1: 
0: package org.apache.derby.impl.services.replication.master;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.services.monitor.ModuleControl;
1: import org.apache.derby.iapi.services.monitor.ModuleSupportable;
1: 
1: import org.apache.derby.iapi.store.raw.RawStoreFactory;
1: import org.apache.derby.iapi.store.raw.log.LogFactory;
1: import org.apache.derby.iapi.store.raw.data.DataFactory;
1: 
0: import org.apache.derby.iapi.services.replication.master.MasterFactory;
0: import org.apache.derby.impl.services.replication.buffer.ReplicationLogBuffer;
0: import org.apache.derby.impl.services.replication.buffer.LogBufferFullException;
1: 
1: import java.util.Properties;
1: 
1: /**
1:  * <p> 
1:  * This is an implementation of the replication master controller
1:  * service. The service is booted when this instance of Derby will
1:  * have the replication master role for this database.
1:  * </p> 
1:  * <p>
1:  * Note: The current version of the class is far from complete. Code
1:  * to control the replication master behavior will be added as more
1:  * parts of the replication functionality is added to Derby. 
1:  * </p>
1:  *
1:  * @see MasterFactory
1:  */
0: public class MasterController implements MasterFactory, ModuleControl,
0:                                          ModuleSupportable {
1: 
1:     private static final int DEFAULT_LOG_BUFFER_SIZE = 32768; //32K
1: 
1:     private RawStoreFactory rawStoreFactory;
1:     private DataFactory dataFactory;
1:     private LogFactory logFactory;
1:     private ReplicationLogBuffer logBuffer;
0:     // waiting for code to go into trunk:
0:     //    private LogShipper logShipper; 
0:     //    private NetworkTransmit connection; 
1: 
1:     private String replicationMode;
0:     private String slavehost;
0:     private int slaveport;
1: 
1: 
1: 
1:     /**
1:      * Empty constructor required by Monitor.bootServiceModule
1:      */
1:     public MasterController() { }
1: 
1:     ////////////////////////////////////////////////////////////
1:     // Implementation of methods from interface ModuleControl //
1:     ////////////////////////////////////////////////////////////
1: 
1:     /**
0:      * Used by Monitor.bootServiceModule to start the service. Will:
1:      *
0:      * Set up basic variables
0:      * Connect to the slave using the network service (DERBY-2921)
1:      *
0:      * Not implemented yet
1:      *
1:      * @param create Currently ignored
1:      * @param properties Properties used to start the service in the
0:      * correct mode
1:      * @exception StandardException Standard Derby exception policy,
1:      * thrown on error.
1:      */
1:     public void boot(boolean create, Properties properties)
1:         throws StandardException {
1: 
1:         replicationMode =
1:             properties.getProperty(MasterFactory.REPLICATION_MODE);
1: 
0:         slavehost = properties.getProperty(MasterFactory.SLAVE_HOST);
1: 
0:         String port = properties.getProperty(MasterFactory.SLAVE_PORT);
0:         if (port != null) {
0:             slaveport = new Integer(port).intValue();
1:         }
1: 
0:         // Added when Network Service has been committed to trunk
0:         // connection = new NetworkTransmit();
1: 
0:         System.out.println("MasterController booted");
1:     }
1: 
1:     /**
0:      * Will stop the replication master service
1:      *
0:      * Not implemented yet
1:      */
0:     public void stop() { }
1: 
1:     ////////////////////////////////////////////////////////////////
1:     // Implementation of methods from interface ModuleSupportable //
1:     ////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Used by Monitor.bootServiceModule to check if this class is
1:      * usable for replication. To be usable, we require that
1:      * asynchronous replication is specified in startParams by
1:      * checking that a property with key
1:      * MasterFactory.REPLICATION_MODE has the value
1:      * MasterFactory.ASYNCHRONOUS_MODE. 
1:      * @param startParams The properties used to boot replication
1:      * @return true if asynchronous replication is requested, meaning
1:      * that this MasterController is a suitable implementation for the
1:      * MasterFactory service. False otherwise
1:      * @see ModuleSupportable#canSupport 
1:      */
1:     public boolean canSupport(Properties startParams) {
1:         String modeParam =
1:             startParams.getProperty(MasterFactory.REPLICATION_MODE);
1: 
1:         // currently only one attribute: asynchronous replication mode
1:         if (modeParam != null && 
1:             modeParam.equals(MasterFactory.ASYNCHRONOUS_MODE)) {
0:             return true;
1:         } else {
0:             return false;
1:         }
1:     }
1: 
1:     ////////////////////////////////////////////////////////////
1:     // Implementation of methods from interface MasterFactory //
1:     ////////////////////////////////////////////////////////////
1: 
1:     /**
0:      * Will perform all the work that is needed to set up replication
1:      *
0:      * Not implemented yet
1:      *
1:      * @param rawStore The RawStoreFactory for the database
1:      * @param dataFac The DataFactory for this database
1:      * @param logFac The LogFactory ensuring recoverability for this database
1:      */
1:     public void startMaster(RawStoreFactory rawStore,
0:                             DataFactory dataFac, LogFactory logFac) {
0:         // Added when Network Service has been committed to trunk:
0:         // connection.connect(); // sets up a network connection to the slave
1: 
1:         rawStoreFactory = rawStore;
1:         dataFactory = dataFac;
1:         logFactory = logFac;
0:         logBuffer = new ReplicationLogBuffer(DEFAULT_LOG_BUFFER_SIZE);
0:         //  logFactory.setReplicationMaster(this); //added later
1: 
0:         if (replicationMode.equals(MasterFactory.ASYNCHRONOUS_MODE)) {
0:             System.out.println("MasterController would now " +
0:                                "start asynchronous log shipping");
0:             // Added when Master Log Shipping code has been committed to trunk:
0:             // logShipper = new AsynchronousLogShipper(connection);
1:         }
1: 
1:         // Add code that initializes replication by sending the
1:         // database to the slave, making logFactory add logrecords to
1:         // the buffer etc. Repliation should be up and running when
1:         // this method returns.
1: 
0:         System.out.println("MasterController started");
1:     }
1: 
1:     /**
0:      * Will perform all work that is needed to shut down replication
1:      *
0:      * Not implemented yet
1:      */
0:     public void stopMaster() {
0:         // logFactory.stopReplicationLogging(); // added later
1: 
0:         // Added when Network Service has been committed to trunk:
0:         // if (connection.isUp()) {
0:         //     logShipper.flushAllLog();
0:         // }
1: 
0:         // logBuffer.stop();
0:         System.out.println("MasterController stopped");
1:     }
1: 
1:     /**
0:      * Append a single log record to the replication log buffer.
1:      *
0:      * @param instant               the log address of this log record.
0:      * @param dataLength            number of bytes in data[]
0:      * @param dataOffset            offset in data[] to start copying from.
0:      * @param optionalDataLength    number of bytes in optionalData[]
0:      * @param optionalDataOffset    offset in optionalData[] to start copy from
0:      * @param data                  "from" array to copy "data" portion of rec
0:      * @param optionalData          "from" array to copy "optional data" from
1:      *
1:      **/
0:     public void appendLogRecord(long instant,
0:                                 int dataLength,
0:                                 int dataOffset,
0:                                 int optionalDataLength,
0:                                 int optionalDataOffset,
0:                                 byte[] data,
0:                                 byte[] optionalData) {
0:         try {
0:             logBuffer.appendLogRecord(instant, dataLength, dataOffset,
0:                                       optionalDataLength, optionalDataOffset,
0:                                       data, optionalData);
1:         } catch (LogBufferFullException lbfe) {
0:             // Waiting for log shipper to implement this
0:             // We have multiple alternatives: 
0:             //  1) Try to force-send some log to the slave:
0:             //     logShipper.forceFlush()
0:             //  2) Increase the size of the buffer
0:             // Stop replication if both these are unsuccessful or not
0:             // an alternative. 
1:         }
1:     }
1: 
1:     /**
1:      * Used by the LogFactory to notify the replication master
1:      * controller that the log records up to this instant have been
1:      * flushed to disk. The master controller takes action according
1:      * to the current replication strategy when this method is called.
1:      *
1:      * When the asynchronous replication strategy is used, the method
1:      * does not force log shipping to the slave; the log records may
1:      * be shipped now or later at the MasterController's discretion.
1:      *
1:      * However, if another strategy like 2-safe replication is
1:      * implemented in the future, a call to this method may force log
1:      * shipment before returning control to the caller.
1:      *
1:      * Currently, only asynchronous replication is supported.
1:      *
0:      * Not implemented yet
1:      *
1:      * @param instant The highest log instant that has been flushed to
1:      * disk
1:      *
1:      * @see MasterFactory#flushedTo
1:      * @see LogFactory#flush
1:      */
1:     public void flushedTo(long instant) {
0:         // logShipper.flushedTo(instant); 
1:     }
1: 
1: }
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:58addc4
/////////////////////////////////////////////////////////////////////////
1:      * @see MasterFactory#startFailover()
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:1d0892e
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.property.PropertyUtil;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.reference.Property;
/////////////////////////////////////////////////////////////////////////
1:     private static final int LOG_BUFFER_SIZE_MIN = 8192; //8KB
1:     private static final int LOG_BUFFER_SIZE_MAX = 1024*1024; //1MB
/////////////////////////////////////////////////////////////////////////
1:     private ReplicationLogger repLogger;
1:     private int logBufferSize = 0;
/////////////////////////////////////////////////////////////////////////
0: 
1:         repLogger = new ReplicationLogger(dbname);
1:         getMasterProperties();
1:         logBuffer = new ReplicationLogBuffer(logBufferSize, this);
/////////////////////////////////////////////////////////////////////////
1:                                                         this,
1:                                                         repLogger);
1:             repLogger.logError(MessageId.REPLICATION_FATAL_ERROR, se);
/////////////////////////////////////////////////////////////////////////
1:             repLogger.
1:                 logError(MessageId.REPLICATION_LOGSHIPPER_EXCEPTION, ioe);
1:             repLogger.
1:                 logError(MessageId.REPLICATION_LOGSHIPPER_EXCEPTION, se);
/////////////////////////////////////////////////////////////////////////
0: 
0:     /**
1:      * Load relevant system property: replication log buffer size
0:      */
1:     private void getMasterProperties() {
1:         logBufferSize =
1:             PropertyUtil.getSystemInt(Property.REPLICATION_LOG_BUFFER_SIZE,
1:                                       DEFAULT_LOG_BUFFER_SIZE);
0: 
1:         if (logBufferSize < LOG_BUFFER_SIZE_MIN) {
1:             logBufferSize = LOG_BUFFER_SIZE_MIN;
1:             if (SanityManager.DEBUG) {
1:                 repLogger.logText("Replication log buffer size " +
1:                                   "property too small. Set to " +
1:                                   "minimum value: " + logBufferSize,
1:                                   false);
0:             }
1:         }  else if (logBufferSize > LOG_BUFFER_SIZE_MAX) {
1:             logBufferSize = LOG_BUFFER_SIZE_MAX;
1:             if (SanityManager.DEBUG) {
1:                 repLogger.logText("Replication log buffer size " +
1:                                   "property too big. Set to " +
1:                                   "maximum value: " + logBufferSize,
1:                                   false);
0:             }
0:         }
0:     }
/////////////////////////////////////////////////////////////////////////
1:             repLogger.logError(MessageId.REPLICATION_LOGSHIPPER_EXCEPTION,
1:                                exception);
/////////////////////////////////////////////////////////////////////////
0:         repLogger.logError(MessageId.REPLICATION_LOGSHIPPER_EXCEPTION, t);
1:             repLogger.
0:                 logError(MessageId.REPLICATION_MASTER_STOPPED, t);
============================================================================