1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.execute.GenericTriggerExecutor
1:345de35: 
1:f6123ee:    Licensed to the Apache Software Foundation (ASF) under one or more
1:f6123ee:    contributor license agreements.  See the NOTICE file distributed with
1:f6123ee:    this work for additional information regarding copyright ownership.
1:f6123ee:    The ASF licenses this file to you under the Apache License, Version 2.0
1:f6123ee:    (the "License"); you may not use this file except in compliance with
1:f6123ee:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:eac0369: 
1:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.sql.execute;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.SPSDescriptor;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.TriggerDescriptor;
1:eac0369: import org.apache.derby.iapi.sql.execute.CursorResultSet;
1:eac0369: import org.apache.derby.iapi.sql.execute.ExecPreparedStatement;
1:1725dd1: import org.apache.derby.iapi.sql.execute.ExecRow;
1:eac0369: import org.apache.derby.iapi.sql.Activation;
1:eac0369: import org.apache.derby.iapi.sql.ResultSet;
1:eac0369: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1:eac0369: import org.apache.derby.iapi.sql.conn.StatementContext;
1:1725dd1: import org.apache.derby.iapi.types.DataValueDescriptor;
1:1725dd1: import org.apache.derby.iapi.types.SQLBoolean;
1:eac0369: import org.apache.derby.iapi.reference.SQLState;
1:1725dd1: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: 
2:eac0369: /**
1:eac0369:  * A trigger executor is an object that executes
1:eac0369:  * a trigger.  It is subclassed by row and statement
1:eac0369:  * executors.
1:eac0369:  */
1:05623b6: abstract class GenericTriggerExecutor
1:eac0369: {
1:05623b6:     final InternalTriggerExecutionContext   tec;
1:05623b6:     final TriggerDescriptor                 triggerd;
1:05623b6:     final Activation                        activation;
1:05623b6:     private final LanguageConnectionContext lcc;
1:eac0369: 
1:c69c8b0: 	private	boolean			whenClauseRetrieved;
1:c69c8b0: 	private	boolean			actionRetrieved;
1:c69c8b0: 	private SPSDescriptor	whenClause; 
1:c69c8b0: 	private SPSDescriptor	action;
1:eac0369: 
1:1725dd1:     // Cached prepared statement and activation for WHEN clause and
1:1725dd1:     // trigger action.
1:1725dd1:     private ExecPreparedStatement   whenPS;
1:1725dd1:     private Activation              spsWhenActivation;
1:1725dd1:     private ExecPreparedStatement   actionPS;
1:1725dd1:     private Activation              spsActionActivation;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Constructor
1:eac0369: 	 *
1:eac0369: 	 * @param tec the execution context
1:eac0369: 	 * @param triggerd the trigger descriptor
1:eac0369: 	 * @param activation the activation
1:eac0369: 	 * @param lcc the lcc
1:eac0369: 	 */
1:eac0369: 	GenericTriggerExecutor
1:eac0369: 	(
1:eac0369: 		InternalTriggerExecutionContext tec, 
1:eac0369: 		TriggerDescriptor 				triggerd,
1:eac0369: 		Activation						activation,
1:eac0369: 		LanguageConnectionContext		lcc
1:eac0369: 	)
1:eac0369: 	{
1:eac0369: 		this.tec = tec;
1:eac0369: 		this.triggerd = triggerd;
1:eac0369: 		this.activation = activation;
1:eac0369: 		this.lcc = lcc;
3:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Fire the trigger based on the event.
1:eac0369: 	 *
1:eac0369: 	 * @param event	    the trigger event
1:eac0369: 	 * @param brs		the before result set
1:eac0369: 	 * @param ars		the after result set
1:d9d1bc8: 	 * @param colsReadFromTable   columns required from the trigger table
1:d9d1bc8: 	 *   by the triggering sql
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException on error or user exception
1:eac0369: 	 * from trigger action
1:eac0369: 	 */
1:eac0369: 	abstract void fireTrigger
1:eac0369: 	(
1:eac0369: 		TriggerEvent 		event, 
1:eac0369: 		CursorResultSet 	brs, 
1:d9d1bc8: 		CursorResultSet 	ars,
1:d9d1bc8: 		int[]	colsReadFromTable
1:eac0369: 	) throws StandardException;
1:eac0369: 
1:1725dd1:     private SPSDescriptor getWhenClause() throws StandardException
1:eac0369: 	{
1:c69c8b0: 		if (!whenClauseRetrieved)
1:c69c8b0: 		{
1:c69c8b0: 			whenClauseRetrieved = true;
1:50734d8:             whenClause = triggerd.getWhenClauseSPS(lcc);
1:c69c8b0: 		}
1:c69c8b0: 		return whenClause;
1:eac0369: 	}
1:eac0369: 
1:db60062:     private SPSDescriptor getAction() throws StandardException
1:eac0369: 	{
1:c69c8b0: 		if (!actionRetrieved)
1:c69c8b0: 		{
1:c69c8b0: 			actionRetrieved = true;
1:c69c8b0: 			action = triggerd.getActionSPS(lcc);
1:c69c8b0: 		}
1:c69c8b0: 		return action;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Execute the given stored prepared statement.  We
1:eac0369: 	 * just grab the prepared statement from the spsd,
1:eac0369: 	 * get a new activation holder and let er rip.
1:eac0369: 	 *
1:1725dd1:      * @param sps the SPS to execute
1:1725dd1:      * @param isWhen {@code true} if the SPS is for the WHEN clause,
1:1725dd1:      *               {@code false} otherwise
1:1725dd1:      * @return {@code true} if the SPS is for a WHEN clause and it evaluated
1:1725dd1:      *         to {@code TRUE}, {@code false} otherwise
1:eac0369: 	 * @exception StandardException on error
1:eac0369: 	 */
1:db60062:     private boolean executeSPS(SPSDescriptor sps, boolean isWhen)
1:1725dd1:             throws StandardException
1:eac0369: 	{
1:eac0369: 		boolean recompile = false;
1:1725dd1:         boolean whenClauseWasTrue = false;
1:1725dd1: 
1:1725dd1:         // The prepared statement and the activation may already be available
1:1725dd1:         // if the trigger has been fired before in the same statement. (Only
1:1725dd1:         // happens with row triggers that are triggered by a statement that
1:1725dd1:         // touched multiple rows.) The WHEN clause and the trigger action have
1:1725dd1:         // their own prepared statement and activation. Fetch the correct set.
1:1725dd1:         ExecPreparedStatement ps = isWhen ? whenPS : actionPS;
1:1725dd1:         Activation spsActivation = isWhen
1:1725dd1:                 ? spsWhenActivation : spsActionActivation;
1:1725dd1: 
1:eac0369: 		while (true) {
1:eac0369: 			/*
1:eac0369: 			** Only grab the ps the 1st time through.  This
1:eac0369: 			** way a row trigger doesn't do any unnecessary
1:eac0369: 			** setup work.
1:eac0369: 			*/
1:eac0369: 			if (ps == null || recompile)
1:eac0369: 			{
1:1061fd2:                 // The SPS activation will set its parent activation from
1:1061fd2:                 // the statement context. Reset it to the original parent
1:1061fd2:                 // activation first so that it doesn't use the activation of
1:1061fd2:                 // the previously executed SPS as parent. DERBY-6348.
1:1061fd2:                 lcc.getStatementContext().setActivation(activation);
1:1061fd2: 
1:eac0369: 				/*
1:eac0369: 				** We need to clone the prepared statement so we don't
1:eac0369: 				** wind up marking that ps that is tied to sps as finished
1:eac0369: 				** during the course of execution.
1:eac0369: 				*/
1:eac0369: 				ps = sps.getPreparedStatement();
1:eac0369: 				ps = ps.getClone();
1:eac0369: 				// it should be valid since we've just prepared for it
1:eac0369: 				ps.setValid();
1:eac0369: 				spsActivation = ps.getActivation(lcc, false);
1:eac0369: 
1:eac0369: 				/*
1:eac0369: 				** Normally, we want getSource() for an sps invocation
1:eac0369: 				** to be EXEC STATEMENT xxx, but in this case, since
1:eac0369: 				** we are executing the SPS in our own fashion, we want
1:eac0369: 				** the text to be the trigger action.  So set it accordingly.
1:eac0369: 				*/
1:eac0369: 				ps.setSource(sps.getText());
1:eac0369: 				ps.setSPSAction();
1:1725dd1: 
1:1725dd1:                 // Cache the prepared statement and activation in case the
1:1725dd1:                 // trigger fires multiple times.
1:1725dd1:                 if (isWhen) {
1:1725dd1:                     whenPS = ps;
1:1725dd1:                     spsWhenActivation = spsActivation;
1:1725dd1:                 } else {
1:1725dd1:                     actionPS = ps;
1:1725dd1:                     spsActionActivation = spsActivation;
1:1725dd1:                 }
1:eac0369: 			}
1:eac0369: 
1:5d8b257: 			// save the active statement context for exception handling purpose
1:5d8b257: 			StatementContext active_sc = lcc.getStatementContext();
1:eac0369: 			
1:eac0369: 			/*
1:eac0369: 			** Execute the activation.  If we have an error, we
1:eac0369: 			** are going to go to some extra work to pop off
1:eac0369: 			** our statement context.  This is because we are
1:eac0369: 			** a nested statement (we have 2 activations), but
1:eac0369: 			** we aren't a nested connection, so we have to
1:eac0369: 			** pop off our statementcontext to get error handling	
1:eac0369: 			** to work correctly.  This is normally a no-no, but
1:eac0369: 			** we are an unusual case.
1:eac0369: 			*/
1:eac0369: 			try
1:eac0369: 			{
1:3fcea8a:                 // This is a substatement; for now, we do not set any timeout
1:3fcea8a:                 // for it. We might change this behaviour later, by linking
1:3fcea8a:                 // timeout to its parent statement's timeout settings.
1:e3883f5: 				ResultSet rs = ps.executeSubStatement
1:e3883f5: 					(activation, spsActivation, false, 0L);
1:1725dd1: 
1:1725dd1:                 if (isWhen)
1:1725dd1:                 {
1:1725dd1:                     // This is a WHEN clause. Expect a single BOOLEAN value
1:1725dd1:                     // to be returned.
1:1725dd1:                     ExecRow row = rs.getNextRow();
1:1725dd1:                     if (SanityManager.DEBUG && row.nColumns() != 1) {
1:1725dd1:                         SanityManager.THROWASSERT(
1:1725dd1:                             "Expected WHEN clause to have exactly "
1:1725dd1:                             + "one column, found: " + row.nColumns());
1:1725dd1:                     }
1:1725dd1: 
1:1725dd1:                     DataValueDescriptor value = row.getColumn(1);
1:1725dd1:                     if (SanityManager.DEBUG) {
1:1725dd1:                         SanityManager.ASSERT(value instanceof SQLBoolean);
1:1725dd1:                     }
1:1725dd1: 
1:1725dd1:                     whenClauseWasTrue =
1:1725dd1:                             !value.isNull() && value.getBoolean();
1:1725dd1: 
1:1725dd1:                     if (SanityManager.DEBUG) {
1:1725dd1:                         SanityManager.ASSERT(rs.getNextRow() == null,
1:1725dd1:                                 "WHEN clause returned more than one row");
1:1725dd1:                     }
1:1725dd1:                 }
1:1725dd1:                 else if (rs.returnsRows())
1:eac0369:                 {
1:42261f8:                     // Fetch all the data to ensure that functions in the select list or values statement will
1:42261f8:                     // be evaluated and side effects will happen. Why else would the trigger action return
1:42261f8:                     // rows, but for side effects?
1:42261f8:                     // The result set was opened in ps.execute()
1:42261f8:                     while( rs.getNextRow() != null)
1:eac0369:                     {
1:eac0369:                     }
1:eac0369:                 }
1:42261f8:                 rs.close();
1:eac0369: 			} 
1:eac0369: 			catch (StandardException e)
1:eac0369: 			{
1:5d8b257: 				/* 
1:5d8b257: 				** When a trigger SPS action is executed and results in 
1:5d8b257: 				** an exception, the system needs to clean up the active 
1:5d8b257: 				** statement context(SC) and the trigger execution context
1:5d8b257: 				** (TEC) in language connection context(LCC) properly (e.g.:  
1:5d8b257: 				** "Maximum depth triggers exceeded" exception); otherwise, 
1:5d8b257: 				** this will leave old TECs lingering and may result in 
1:5d8b257: 				** subsequent statements within the same connection to throw 
1:5d8b257: 				** the same exception again prematurely.  
1:5d8b257: 				**    
1:5d8b257: 				** A new statement context will be created for the SPS before
1:5d8b257: 				** it is executed.  However, it is possible for some 
1:5d8b257: 				** StandardException to be thrown before a new statement 
1:5d8b257: 				** context is pushed down to the context stack; hence, the 
1:5d8b257: 				** trigger executor needs to ensure that the current active SC 
1:5d8b257: 				** is associated with the SPS, so that it is cleaning up the 
1:5d8b257: 				** right statement context in LCC. 
1:18ab492:                 **
1:18ab492:                 ** It is also possible that the error has already been handled
1:18ab492:                 ** on a lower level, especially if the trigger re-enters the
1:18ab492:                 ** JDBC layer. In that case, the current SC will be null.
1:5d8b257: 				**    
1:5d8b257: 				** When the active SC is cleaned up, the TEC will be removed
1:5d8b257: 				** from LCC and the SC object will be popped off from the LCC 
1:5d8b257: 				** as part of cleanupOnError logic.  
1:eac0369: 				 */
1:3fcea8a: 				
1:5d8b257: 				/* retrieve the current active SC */
1:eac0369: 				StatementContext sc = lcc.getStatementContext();
1:eac0369: 				
1:5d8b257: 				/* make sure that the cleanup is on the new SC */
1:18ab492: 				if (sc != null && active_sc != sc)
1:eac0369: 				{
1:eac0369: 					sc.cleanupOnError(e);
1:eac0369: 				}
1:eac0369: 				
1:eac0369: 				/* Handle dynamic recompiles */
1:eac0369: 				if (e.getMessageId().equals(SQLState.LANG_STATEMENT_NEEDS_RECOMPILE))
1:eac0369: 				{
1:eac0369: 					recompile = true;
1:eac0369: 					sps.revalidate(lcc);
1:eac0369: 					continue;
1:eac0369: 				}
1:eac0369: 				
2:eac0369: 				spsActivation.close();
1:eac0369: 				throw e;
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			/* Done with execution without any recompiles */
1:1725dd1:             return whenClauseWasTrue;
1:1725dd1: 		}
1:eac0369: 	}
1:1725dd1: 
1:1725dd1: 	/**
1:db60062:      * Cleanup after executing the SPS for the WHEN clause and trigger action.
1:1725dd1: 	 *
1:eac0369: 	 * @exception StandardException on error
1:1725dd1: 	 */
1:eac0369: 	protected void clearSPS() throws StandardException
1:eac0369: 	{
1:1725dd1:         if (spsActionActivation != null) {
1:1725dd1:             spsActionActivation.close();
1:1725dd1:         }
1:1725dd1:         actionPS = null;
1:1725dd1:         spsActionActivation = null;
1:db60062: 
1:db60062:         if (spsWhenActivation != null) {
1:db60062:             spsWhenActivation.close();
1:db60062:         }
1:db60062:         whenPS = null;
1:db60062:         spsWhenActivation = null;
1:1725dd1: 	}
1:1725dd1: 
1:eac0369:     /**
1:db60062:      * <p>
1:db60062:      * Execute the WHEN clause SPS and the trigger action SPS.
1:db60062:      * </p>
1:eac0369:      *
1:db60062:      * <p>
1:db60062:      * If there is no WHEN clause, the trigger action should always be
1:db60062:      * executed. If there is a WHEN clause, the trigger action should only
1:db60062:      * be executed if the WHEN clause returns TRUE.
1:db60062:      * </p>
1:db60062:      *
1:db60062:      * @throws StandardException if trigger execution fails
1:eac0369:      */
1:db60062:     final void executeWhenClauseAndAction() throws StandardException {
1:1725dd1:         SPSDescriptor whenClauseDescriptor = getWhenClause();
1:db60062:         if (whenClauseDescriptor == null ||
1:db60062:                 executeSPS(whenClauseDescriptor, true)) {
1:db60062:             executeSPS(getAction(), false);
1:1725dd1:         }
1:1725dd1:     }
1:eac0369: } 
============================================================================
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:1061fd2
/////////////////////////////////////////////////////////////////////////
1:                 // The SPS activation will set its parent activation from
1:                 // the statement context. Reset it to the original parent
1:                 // activation first so that it doesn't use the activation of
1:                 // the previously executed SPS as parent. DERBY-6348.
1:                 lcc.getStatementContext().setActivation(activation);
1: 
commit:50734d8
/////////////////////////////////////////////////////////////////////////
1:             whenClause = triggerd.getWhenClauseSPS(lcc);
commit:db60062
/////////////////////////////////////////////////////////////////////////
1:     private SPSDescriptor getAction() throws StandardException
/////////////////////////////////////////////////////////////////////////
1:     private boolean executeSPS(SPSDescriptor sps, boolean isWhen)
/////////////////////////////////////////////////////////////////////////
1:      * Cleanup after executing the SPS for the WHEN clause and trigger action.
/////////////////////////////////////////////////////////////////////////
1: 
1:         if (spsWhenActivation != null) {
1:             spsWhenActivation.close();
1:         }
1:         whenPS = null;
1:         spsWhenActivation = null;
1:      * <p>
1:      * Execute the WHEN clause SPS and the trigger action SPS.
1:      * </p>
1:      * <p>
1:      * If there is no WHEN clause, the trigger action should always be
1:      * executed. If there is a WHEN clause, the trigger action should only
1:      * be executed if the WHEN clause returns TRUE.
1:      * </p>
1:      *
1:      * @throws StandardException if trigger execution fails
1:     final void executeWhenClauseAndAction() throws StandardException {
1:         if (whenClauseDescriptor == null ||
1:                 executeSPS(whenClauseDescriptor, true)) {
1:             executeSPS(getAction(), false);
commit:1725dd1
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.execute.ExecRow;
1: import org.apache.derby.iapi.types.DataValueDescriptor;
1: import org.apache.derby.iapi.types.SQLBoolean;
1: import org.apache.derby.shared.common.sanity.SanityManager;
/////////////////////////////////////////////////////////////////////////
1:     // Cached prepared statement and activation for WHEN clause and
1:     // trigger action.
1:     private ExecPreparedStatement   whenPS;
1:     private Activation              spsWhenActivation;
1:     private ExecPreparedStatement   actionPS;
1:     private Activation              spsActionActivation;
/////////////////////////////////////////////////////////////////////////
1:     private SPSDescriptor getWhenClause() throws StandardException
/////////////////////////////////////////////////////////////////////////
1:      * @param sps the SPS to execute
1:      * @param isWhen {@code true} if the SPS is for the WHEN clause,
1:      *               {@code false} otherwise
1:      * @return {@code true} if the SPS is for a WHEN clause and it evaluated
1:      *         to {@code TRUE}, {@code false} otherwise
0:     final boolean executeSPS(SPSDescriptor sps, boolean isWhen)
1:             throws StandardException
1:         boolean whenClauseWasTrue = false;
1: 
1:         // The prepared statement and the activation may already be available
1:         // if the trigger has been fired before in the same statement. (Only
1:         // happens with row triggers that are triggered by a statement that
1:         // touched multiple rows.) The WHEN clause and the trigger action have
1:         // their own prepared statement and activation. Fetch the correct set.
1:         ExecPreparedStatement ps = isWhen ? whenPS : actionPS;
1:         Activation spsActivation = isWhen
1:                 ? spsWhenActivation : spsActionActivation;
/////////////////////////////////////////////////////////////////////////
1: 
1:                 // Cache the prepared statement and activation in case the
1:                 // trigger fires multiple times.
1:                 if (isWhen) {
1:                     whenPS = ps;
1:                     spsWhenActivation = spsActivation;
1:                 } else {
1:                     actionPS = ps;
1:                     spsActionActivation = spsActivation;
1:                 }
/////////////////////////////////////////////////////////////////////////
1: 
1:                 if (isWhen)
1:                 {
1:                     // This is a WHEN clause. Expect a single BOOLEAN value
1:                     // to be returned.
1:                     ExecRow row = rs.getNextRow();
1:                     if (SanityManager.DEBUG && row.nColumns() != 1) {
1:                         SanityManager.THROWASSERT(
1:                             "Expected WHEN clause to have exactly "
1:                             + "one column, found: " + row.nColumns());
1:                     }
1: 
1:                     DataValueDescriptor value = row.getColumn(1);
1:                     if (SanityManager.DEBUG) {
1:                         SanityManager.ASSERT(value instanceof SQLBoolean);
1:                     }
1: 
1:                     whenClauseWasTrue =
1:                             !value.isNull() && value.getBoolean();
1: 
1:                     if (SanityManager.DEBUG) {
1:                         SanityManager.ASSERT(rs.getNextRow() == null,
1:                                 "WHEN clause returned more than one row");
1:                     }
1:                 }
1:                 else if (rs.returnsRows())
/////////////////////////////////////////////////////////////////////////
1:             return whenClauseWasTrue;
0:      * Cleanup after executing the SPS for the trigger action.
1:         if (spsActionActivation != null) {
1:             spsActionActivation.close();
1:         }
1:         actionPS = null;
1:         spsActionActivation = null;
1: 
1:     /**
0:      * Evaluate the WHEN clause, if there is one, and return whether the
0:      * trigger action should be executed.
1:      *
0:      * @return {@code true} if the trigger action should be executed (that is,
0:      *   if there is no WHEN clause or if the WHEN clause evaluates to TRUE),
0:      *   {@code false} otherwise
0:      * @throws StandardException if an error happens when executing the
0:      *   WHEN clause
1:      */
0:     final boolean executeWhenClause() throws StandardException {
1:         SPSDescriptor whenClauseDescriptor = getWhenClause();
1: 
0:         if (whenClauseDescriptor == null) {
0:             // Always execute the trigger action if there is no WHEN clause.
0:             return true;
1:         }
1: 
0:         try {
0:             return executeSPS(whenClauseDescriptor, true);
0:         } finally {
0:             if (spsWhenActivation != null) {
0:                 spsWhenActivation.close();
1:             }
0:             whenPS = null;
0:             spsWhenActivation = null;
1:         }
1:     }
commit:05623b6
/////////////////////////////////////////////////////////////////////////
1: abstract class GenericTriggerExecutor
1:     final InternalTriggerExecutionContext   tec;
1:     final TriggerDescriptor                 triggerd;
1:     final Activation                        activation;
1:     private final LanguageConnectionContext lcc;
commit:18ab492
/////////////////////////////////////////////////////////////////////////
1:                 **
1:                 ** It is also possible that the error has already been handled
1:                 ** on a lower level, especially if the trigger re-enters the
1:                 ** JDBC layer. In that case, the current SC will be null.
/////////////////////////////////////////////////////////////////////////
1: 				if (sc != null && active_sc != sc)
commit:c69c8b0
/////////////////////////////////////////////////////////////////////////
0: public abstract class GenericTriggerExecutor
0: 	protected InternalTriggerExecutionContext	tec;
0: 	protected TriggerDescriptor					triggerd;
0: 	protected Activation						activation;
0: 	protected LanguageConnectionContext			lcc;
1: 	private	boolean			whenClauseRetrieved;
1: 	private	boolean			actionRetrieved;
1: 	private SPSDescriptor	whenClause; 
1: 	private SPSDescriptor	action;
/////////////////////////////////////////////////////////////////////////
1: 		if (!whenClauseRetrieved)
1: 		{
1: 			whenClauseRetrieved = true;
0: 			whenClause = triggerd.getWhenClauseSPS();
1: 		}
1: 		return whenClause;
1: 		if (!actionRetrieved)
1: 		{
1: 			actionRetrieved = true;
1: 			action = triggerd.getActionSPS(lcc);
1: 		}
1: 		return action;
commit:fade7e9
/////////////////////////////////////////////////////////////////////////
0:                 ResultSet rs = ps.execute(spsActivation, false, 0L);
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:d9d1bc8
/////////////////////////////////////////////////////////////////////////
1: 	 * @param colsReadFromTable   columns required from the trigger table
1: 	 *   by the triggering sql
/////////////////////////////////////////////////////////////////////////
1: 		CursorResultSet 	ars,
1: 		int[]	colsReadFromTable
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:e3883f5
/////////////////////////////////////////////////////////////////////////
1: 				ResultSet rs = ps.executeSubStatement
1: 					(activation, spsActivation, false, 0L);
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:88bb146
/////////////////////////////////////////////////////////////////////////
0: abstract class GenericTriggerExecutor
0: 	final InternalTriggerExecutionContext	tec;
0: 	final TriggerDescriptor					triggerd;
0: 	final Activation						activation;
0: 	final LanguageConnectionContext			lcc;
/////////////////////////////////////////////////////////////////////////
0: 		return triggerd.getWhenClauseSPS();
0: 		return triggerd.getActionSPS(lcc);
commit:3fcea8a
/////////////////////////////////////////////////////////////////////////
1:                 // This is a substatement; for now, we do not set any timeout
1:                 // for it. We might change this behaviour later, by linking
1:                 // timeout to its parent statement's timeout settings.
0:                 ps.setQueryTimeout(0L);
1: 
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.execute.GenericTriggerExecutor
1: 
0:    Copyright 1999, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:9e5097f
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.execute
0:    (C) Copyright IBM Corp. 1999, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.sql.execute;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.sql.dictionary.SPSDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.TriggerDescriptor;
1: import org.apache.derby.iapi.sql.execute.CursorResultSet;
1: import org.apache.derby.iapi.sql.execute.ExecPreparedStatement;
1: import org.apache.derby.iapi.sql.Activation;
1: import org.apache.derby.iapi.sql.ResultSet;
1: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1: import org.apache.derby.iapi.sql.conn.StatementContext;
1: 
1: import org.apache.derby.iapi.reference.SQLState;
1: 
1: /**
1:  * A trigger executor is an object that executes
1:  * a trigger.  It is subclassed by row and statement
1:  * executors.
1:  */
0: public abstract class GenericTriggerExecutor
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1999_2004;
0: 	protected InternalTriggerExecutionContext	tec;
0: 	protected TriggerDescriptor					triggerd;
0: 	protected Activation						activation;
0: 	protected LanguageConnectionContext			lcc;
1: 
0: 	private	boolean			whenClauseRetrieved;
0: 	private	boolean			actionRetrieved;
0: 	private SPSDescriptor	whenClause; 
0: 	private SPSDescriptor	action;
1: 
0: 	private ExecPreparedStatement	ps;
0: 	private Activation 				spsActivation;
1: 
1: 	/**
1: 	 * Constructor
1: 	 *
1: 	 * @param tec the execution context
1: 	 * @param triggerd the trigger descriptor
1: 	 * @param activation the activation
1: 	 * @param lcc the lcc
1: 	 */
1: 	GenericTriggerExecutor
1: 	(
1: 		InternalTriggerExecutionContext tec, 
1: 		TriggerDescriptor 				triggerd,
1: 		Activation						activation,
1: 		LanguageConnectionContext		lcc
1: 	)
1: 	{
1: 		this.tec = tec;
1: 		this.triggerd = triggerd;
1: 		this.activation = activation;
1: 		this.lcc = lcc;
1: 	}
1: 
1: 	/**
1: 	 * Fire the trigger based on the event.
1: 	 *
1: 	 * @param event	    the trigger event
1: 	 * @param brs		the before result set
1: 	 * @param ars		the after result set
1: 	 *
1: 	 * @exception StandardException on error or user exception
1: 	 * from trigger action
1: 	 */
1: 	abstract void fireTrigger
1: 	(
1: 		TriggerEvent 		event, 
1: 		CursorResultSet 	brs, 
0: 		CursorResultSet 	ars
1: 	) throws StandardException;
1: 
0: 	protected SPSDescriptor getWhenClause() throws StandardException
1: 	{
0: 		if (!whenClauseRetrieved)
1: 		{
0: 			whenClauseRetrieved = true;
0: 			whenClause = triggerd.getWhenClauseSPS();
1: 		}
0: 		return whenClause;
1: 	}
1: 
0: 	protected SPSDescriptor getAction() throws StandardException
1: 	{
0: 		if (!actionRetrieved)
1: 		{
0: 			actionRetrieved = true;
0: 			action = triggerd.getActionSPS(lcc);
1: 		}
0: 		return action;
1: 	}
1: 
1: 	/**
1: 	 * Execute the given stored prepared statement.  We
1: 	 * just grab the prepared statement from the spsd,
1: 	 * get a new activation holder and let er rip.
1: 	 *
1: 	 * @exception StandardException on error
1: 	 */
0: 	protected void executeSPS(SPSDescriptor sps) throws StandardException
1: 	{
1: 		boolean recompile = false;
1: 
1: 		while (true) {
1: 			/*
1: 			** Only grab the ps the 1st time through.  This
1: 			** way a row trigger doesn't do any unnecessary
1: 			** setup work.
1: 			*/
1: 			if (ps == null || recompile)
1: 			{
1: 				/*
1: 				** We need to clone the prepared statement so we don't
1: 				** wind up marking that ps that is tied to sps as finished
1: 				** during the course of execution.
1: 				*/
1: 				ps = sps.getPreparedStatement();
1: 				ps = ps.getClone();
1: 				// it should be valid since we've just prepared for it
1: 				ps.setValid();
1: 				spsActivation = ps.getActivation(lcc, false);
1: 
1: 				/*
1: 				** Normally, we want getSource() for an sps invocation
1: 				** to be EXEC STATEMENT xxx, but in this case, since
1: 				** we are executing the SPS in our own fashion, we want
1: 				** the text to be the trigger action.  So set it accordingly.
1: 				*/
1: 				ps.setSource(sps.getText());
1: 				ps.setSPSAction();
1: 			}
1: 
1: 			/*
1: 			** Execute the activation.  If we have an error, we
1: 			** are going to go to some extra work to pop off
1: 			** our statement context.  This is because we are
1: 			** a nested statement (we have 2 activations), but
1: 			** we aren't a nested connection, so we have to
1: 			** pop off our statementcontext to get error handling	
1: 			** to work correctly.  This is normally a no-no, but
1: 			** we are an unusual case.
1: 			*/
1: 			try
1: 			{
0: 				ps.execute(spsActivation, false, false, false);
1: 			} 
1: 			catch (StandardException e)
1: 			{
1: 				/* Handle dynamic recompiles */
1: 				if (e.getMessageId().equals(SQLState.LANG_STATEMENT_NEEDS_RECOMPILE))
1: 				{
1: 					StatementContext sc = lcc.getStatementContext();
1: 					sc.cleanupOnError(e);
1: 					recompile = true;
1: 					sps.revalidate(lcc);
1: 					continue;
1: 				}
0: 				lcc.popStatementContext(lcc.getStatementContext(), e);
1: 				spsActivation.close();
1: 				throw e;
1: 			}
1: 
1: 			/* Done with execution without any recompiles */
0: 			break;
1: 		}
1: 	}
1: 
1: 	/**
0: 	 * Cleanup after executing an sps.
1: 	 *
1: 	 * @exception StandardException on error
1: 	 */
1: 	protected void clearSPS() throws StandardException
1: 	{
0: 		if (spsActivation != null)
1: 		{
1: 			spsActivation.close();
1: 		}
0: 		ps = null;
0: 		spsActivation = null;
1: 	}
1: } 
commit:d2a30a0
/////////////////////////////////////////////////////////////////////////
0: 				ps.execute(spsActivation, false, false, false);
commit:42261f8
/////////////////////////////////////////////////////////////////////////
0: 				ResultSet rs = ps.execute(spsActivation, false, false, false);
0:                 if( rs.returnsRows())
0:                 {
1:                     // Fetch all the data to ensure that functions in the select list or values statement will
1:                     // be evaluated and side effects will happen. Why else would the trigger action return
1:                     // rows, but for side effects?
1:                     // The result set was opened in ps.execute()
1:                     while( rs.getNextRow() != null)
0:                     {
0:                     }
0:                 }
1:                 rs.close();
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:5d8b257
/////////////////////////////////////////////////////////////////////////
1: 			// save the active statement context for exception handling purpose
1: 			StatementContext active_sc = lcc.getStatementContext();
0: 			
/////////////////////////////////////////////////////////////////////////
1: 				/* 
1: 				** When a trigger SPS action is executed and results in 
1: 				** an exception, the system needs to clean up the active 
1: 				** statement context(SC) and the trigger execution context
1: 				** (TEC) in language connection context(LCC) properly (e.g.:  
1: 				** "Maximum depth triggers exceeded" exception); otherwise, 
1: 				** this will leave old TECs lingering and may result in 
1: 				** subsequent statements within the same connection to throw 
1: 				** the same exception again prematurely.  
1: 				**    
1: 				** A new statement context will be created for the SPS before
1: 				** it is executed.  However, it is possible for some 
1: 				** StandardException to be thrown before a new statement 
1: 				** context is pushed down to the context stack; hence, the 
1: 				** trigger executor needs to ensure that the current active SC 
1: 				** is associated with the SPS, so that it is cleaning up the 
1: 				** right statement context in LCC. 
1: 				**    
1: 				** When the active SC is cleaned up, the TEC will be removed
1: 				** from LCC and the SC object will be popped off from the LCC 
1: 				** as part of cleanupOnError logic.  
0: 				 */
0: 				
1: 				/* retrieve the current active SC */
0: 				StatementContext sc = lcc.getStatementContext();
0: 				
1: 				/* make sure that the cleanup is on the new SC */
0: 				if (active_sc != sc) 
0: 				{
0: 					sc.cleanupOnError(e);
0: 				}
0: 				
0: 				
author:David Van Couvering
-------------------------------------------------------------------------------
commit:f6123ee
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
commit:1373f5a
/////////////////////////////////////////////////////////////////////////
0: 				ResultSet rs = ps.execute(spsActivation, false, false, false, 0L);
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:99bc32a
/////////////////////////////////////////////////////////////////////////
0: 				ResultSet rs = ps.execute(spsActivation, false, false, false);
0:                 if( rs.returnsRows())
0:                 {
0:                     // Fetch all the data to ensure that functions in the select list or values statement will
0:                     // be evaluated and side effects will happen. Why else would the trigger action return
0:                     // rows, but for side effects?
0:                     // The result set was opened in ps.execute()
0:                     while( rs.getNextRow() != null)
0:                     {
0:                     }
0:                 }
0:                 rs.close();
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.execute
0:    (C) Copyright IBM Corp. 1999, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.sql.execute;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.sql.dictionary.SPSDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.TriggerDescriptor;
0: import org.apache.derby.iapi.sql.execute.CursorResultSet;
0: import org.apache.derby.iapi.sql.execute.ExecPreparedStatement;
0: import org.apache.derby.iapi.sql.Activation;
0: import org.apache.derby.iapi.sql.ResultSet;
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: import org.apache.derby.iapi.sql.conn.StatementContext;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: /**
0:  * A trigger executor is an object that executes
0:  * a trigger.  It is subclassed by row and statement
0:  * executors.
0:  */
0: public abstract class GenericTriggerExecutor
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1999_2004;
0: 	protected InternalTriggerExecutionContext	tec;
0: 	protected TriggerDescriptor					triggerd;
0: 	protected Activation						activation;
0: 	protected LanguageConnectionContext			lcc;
0: 
0: 	private	boolean			whenClauseRetrieved;
0: 	private	boolean			actionRetrieved;
0: 	private SPSDescriptor	whenClause; 
0: 	private SPSDescriptor	action;
0: 
0: 	private ExecPreparedStatement	ps;
0: 	private Activation 				spsActivation;
0: 
0: 	/**
0: 	 * Constructor
0: 	 *
0: 	 * @param tec the execution context
0: 	 * @param triggerd the trigger descriptor
0: 	 * @param activation the activation
0: 	 * @param lcc the lcc
0: 	 */
0: 	GenericTriggerExecutor
0: 	(
0: 		InternalTriggerExecutionContext tec, 
0: 		TriggerDescriptor 				triggerd,
0: 		Activation						activation,
0: 		LanguageConnectionContext		lcc
0: 	)
0: 	{
0: 		this.tec = tec;
0: 		this.triggerd = triggerd;
0: 		this.activation = activation;
0: 		this.lcc = lcc;
0: 	}
0: 
0: 	/**
0: 	 * Fire the trigger based on the event.
0: 	 *
0: 	 * @param event	    the trigger event
0: 	 * @param brs		the before result set
0: 	 * @param ars		the after result set
0: 	 *
0: 	 * @exception StandardException on error or user exception
0: 	 * from trigger action
0: 	 */
0: 	abstract void fireTrigger
0: 	(
0: 		TriggerEvent 		event, 
0: 		CursorResultSet 	brs, 
0: 		CursorResultSet 	ars
0: 	) throws StandardException;
0: 
0: 	protected SPSDescriptor getWhenClause() throws StandardException
0: 	{
0: 		if (!whenClauseRetrieved)
0: 		{
0: 			whenClauseRetrieved = true;
0: 			whenClause = triggerd.getWhenClauseSPS();
0: 		}
0: 		return whenClause;
0: 	}
0: 
0: 	protected SPSDescriptor getAction() throws StandardException
0: 	{
0: 		if (!actionRetrieved)
0: 		{
0: 			actionRetrieved = true;
0: 			action = triggerd.getActionSPS(lcc);
0: 		}
0: 		return action;
0: 	}
0: 
0: 	/**
0: 	 * Execute the given stored prepared statement.  We
0: 	 * just grab the prepared statement from the spsd,
0: 	 * get a new activation holder and let er rip.
0: 	 *
0: 	 * @exception StandardException on error
0: 	 */
0: 	protected void executeSPS(SPSDescriptor sps) throws StandardException
0: 	{
0: 		boolean recompile = false;
0: 
0: 		while (true) {
0: 			/*
0: 			** Only grab the ps the 1st time through.  This
0: 			** way a row trigger doesn't do any unnecessary
0: 			** setup work.
0: 			*/
0: 			if (ps == null || recompile)
0: 			{
0: 				/*
0: 				** We need to clone the prepared statement so we don't
0: 				** wind up marking that ps that is tied to sps as finished
0: 				** during the course of execution.
0: 				*/
0: 				ps = sps.getPreparedStatement();
0: 				ps = ps.getClone();
0: 				// it should be valid since we've just prepared for it
0: 				ps.setValid();
0: 				spsActivation = ps.getActivation(lcc, false);
0: 
0: 				/*
0: 				** Normally, we want getSource() for an sps invocation
0: 				** to be EXEC STATEMENT xxx, but in this case, since
0: 				** we are executing the SPS in our own fashion, we want
0: 				** the text to be the trigger action.  So set it accordingly.
0: 				*/
0: 				ps.setSource(sps.getText());
0: 				ps.setSPSAction();
0: 			}
0: 
0: 			/*
0: 			** Execute the activation.  If we have an error, we
0: 			** are going to go to some extra work to pop off
0: 			** our statement context.  This is because we are
0: 			** a nested statement (we have 2 activations), but
0: 			** we aren't a nested connection, so we have to
0: 			** pop off our statementcontext to get error handling	
0: 			** to work correctly.  This is normally a no-no, but
0: 			** we are an unusual case.
0: 			*/
0: 			try
0: 			{
0: 				ps.execute(spsActivation, false, false, false);
0: 			} 
0: 			catch (StandardException e)
0: 			{
0: 				/* Handle dynamic recompiles */
0: 				if (e.getMessageId().equals(SQLState.LANG_STATEMENT_NEEDS_RECOMPILE))
0: 				{
0: 					StatementContext sc = lcc.getStatementContext();
0: 					sc.cleanupOnError(e);
0: 					recompile = true;
0: 					sps.revalidate(lcc);
0: 					continue;
0: 				}
0: 				lcc.popStatementContext(lcc.getStatementContext(), e);
0: 				spsActivation.close();
0: 				throw e;
0: 			}
0: 
0: 			/* Done with execution without any recompiles */
0: 			break;
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Cleanup after executing an sps.
0: 	 *
0: 	 * @exception StandardException on error
0: 	 */
0: 	protected void clearSPS() throws StandardException
0: 	{
0: 		if (spsActivation != null)
0: 		{
0: 			spsActivation.close();
0: 		}
0: 		ps = null;
0: 		spsActivation = null;
0: 	}
0: } 
============================================================================