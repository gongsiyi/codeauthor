1:eac0369: /*
11:eac0369: 
1:7ecc1f2:    Derby - Class org.apache.derby.iapi.jdbc.BrokeredStatement
1:7ecc1f2: 
1:2431ece:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2431ece:    contributor license agreements.  See the NOTICE file distributed with
1:2431ece:    this work for additional information regarding copyright ownership.
1:2431ece:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2431ece:    (the "License"); you may not use this file except in compliance with
1:2431ece:    the License.  You may obtain a copy of the License at
1:7ecc1f2: 
1:7ecc1f2:       http://www.apache.org/licenses/LICENSE-2.0
1:7ecc1f2: 
1:7ecc1f2:    Unless required by applicable law or agreed to in writing, software
1:7ecc1f2:    distributed under the License is distributed on an "AS IS" BASIS,
1:7ecc1f2:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7ecc1f2:    See the License for the specific language governing permissions and
1:7ecc1f2:    limitations under the License.
1:7ecc1f2: 
2:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.iapi.jdbc;
1:eac0369: 
1:562671e: import org.apache.derby.iapi.reference.SQLState;
1:562671e: 
1:eac0369: import java.sql.Connection;
1:eac0369: import java.sql.ResultSet;
1:eac0369: import java.sql.SQLException;
1:eac0369: import java.sql.SQLWarning;
1:eac0369: import java.sql.Statement;
1:eac0369: 
2:eac0369: /**
1:eac0369: 	A Statement implementation that forwards all of its requests to an underlying Statement.
1:863daa0:     This class implements the JDBC 4.1 interface.
1:eac0369:  */
1:863daa0: public class BrokeredStatement implements EngineStatement
2:eac0369: {
1:eac0369: 
1:eac0369: 	/**
1:7827676: 		My control. Use the controlCheck() method to obtain the control
1:7827676: 		when calling a check method. This will result in the correct exception
1:7827676: 		being thrown if the statement is already closed.
1:eac0369: 	*/
1:e65be5b: 	final BrokeredStatementControl control;
1:eac0369: 
1:e65be5b: 	final int resultSetType;
1:e65be5b: 	final int resultSetConcurrency;
1:e65be5b: 	final int resultSetHoldability;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		My state
1:eac0369: 	*/
1:eac0369: 	private String cursorName;
1:eac0369: 	private Boolean escapeProcessing;
1:eac0369: 
1:3be5c9d:     BrokeredStatement(BrokeredStatementControl control) throws SQLException
1:eac0369:     {
1:eac0369: 		this.control = control;
1:eac0369: 
1:eac0369: 		// save the state of the Statement while we are pretty much guaranteed the
1:eac0369: 		// underlying statement is open.
1:eac0369: 		resultSetType = getResultSetType();
1:eac0369: 		resultSetConcurrency = getResultSetConcurrency();
1:eac0369: 		resultSetHoldability = getResultSetHoldability();
4:eac0369:     }
1:de8ba18: 
1:562671e: 
1:eac0369:     public final void addBatch(String sql)
1:eac0369:               throws SQLException
1:eac0369:     {
1:eac0369: 		getStatement().addBatch( sql);
1:eac0369: 	}
1:562671e: 
1:eac0369:     public final void clearBatch()
1:eac0369:         throws SQLException
1:eac0369:     {
1:eac0369:            getStatement().clearBatch();
1:eac0369: 	}
1:7827676: 
1:eac0369:     public final int[] executeBatch()
1:eac0369:         throws SQLException
1:eac0369:     {
1:eac0369: 		return getStatement().executeBatch();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369:     public final void cancel()
1:eac0369:         throws SQLException
1:eac0369:     {
1:eac0369:         getStatement().cancel();
1:eac0369:     }
1:eac0369: 
1:eac0369:     public final boolean execute(String sql) throws SQLException
1:eac0369: 	{
1:eac0369: 		return getStatement().execute(sql);
1:eac0369:     } 
1:eac0369: 
1:eac0369:     public final ResultSet executeQuery(String sql) throws SQLException
1:eac0369: 	{
1:175a740:  		return wrapResultSet(getStatement().executeQuery(sql));
1:eac0369:     }
1:eac0369: 
1:eac0369:     public final int executeUpdate(String sql) throws SQLException
1:eac0369: 	{
1:eac0369: 		return getStatement().executeUpdate(sql);
1:eac0369:     }
1:eac0369: 
1:eac0369:         
1:7827676:     /**
1:eac0369:      * In many cases, it is desirable to immediately release a
1:eac0369:      * Statements's database and JDBC resources instead of waiting for
1:eac0369:      * this to happen when it is automatically closed; the close
1:eac0369:      * method provides this immediate release.
1:eac0369:      *
1:eac0369:      * <P><B>Note:</B> A Statement is automatically closed when it is
1:eac0369:      * garbage collected. When a Statement is closed its current
1:eac0369:      * ResultSet, if one exists, is also closed.
1:eac0369: 	 * @exception SQLException thrown on failure.
1:eac0369:      */
1:5b78c4e: 	public void close() throws SQLException
1:eac0369:     {
1:5b78c4e: 		control.closeRealStatement();
1:eac0369:     }
1:eac0369: 
1:eac0369:     public final Connection getConnection()
1:eac0369:         throws SQLException
1:eac0369:     {
1:eac0369: 		return getStatement().getConnection();
1:eac0369: 	}
1:eac0369: 
1:eac0369:     public final int getFetchDirection()
1:eac0369:         throws SQLException
1:eac0369:     {
1:eac0369: 		return getStatement().getFetchDirection();
1:eac0369: 	}
1:eac0369: 
1:eac0369:     public final int getFetchSize()
1:eac0369:         throws SQLException
1:eac0369:     {
1:eac0369: 		return getStatement().getFetchSize();
1:eac0369: 	}
1:eac0369: 
1:eac0369:     public final int getMaxFieldSize()
1:eac0369:         throws SQLException
1:eac0369:     {
1:eac0369: 		return getStatement().getMaxFieldSize();
1:eac0369: 	}
1:eac0369: 
1:eac0369:     public final int getMaxRows()
1:eac0369:         throws SQLException
1:eac0369:     {
1:eac0369: 		return getStatement().getMaxRows();
1:eac0369: 	}
1:eac0369: 
1:eac0369:     public final int getResultSetConcurrency()
1:eac0369:         throws SQLException
1:eac0369:     {
1:eac0369: 		return getStatement().getResultSetConcurrency();
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * The maxFieldSize limit (in bytes) is set to limit the size of
1:eac0369:      * data that can be returned for any column value; it only applies
1:eac0369:      * to BINARY, VARBINARY, LONGVARBINARY, CHAR, VARCHAR, and
1:eac0369:      * LONGVARCHAR fields.  If the limit is exceeded, the excess data
1:eac0369:      * is silently discarded.
1:eac0369:      *
1:eac0369:      * @param max the new max column size limit; zero means unlimited
1:eac0369: 	 * @exception SQLException thrown on failure.
1:eac0369:      */
1:eac0369: 	public final void setMaxFieldSize(int max) throws SQLException
1:eac0369:     {
1:eac0369:         getStatement().setMaxFieldSize(max);
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * The maxRows limit is set to limit the number of rows that any
1:eac0369:      * ResultSet can contain.  If the limit is exceeded, the excess
1:eac0369:      * rows are silently dropped.
1:eac0369:      *
1:eac0369:      * @param max the new max rows limit; zero means unlimited
1:eac0369: 	 * @exception SQLException thrown on failure.
1:eac0369:      */
1:eac0369: 	public final void setMaxRows(int max) throws SQLException	
1:eac0369: 	{
1:eac0369:         getStatement().setMaxRows( max);
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * If escape scanning is on (the default) the driver will do
1:eac0369:      * escape substitution before sending the SQL to the database.
1:eac0369:      *
1:eac0369:      * @param enable true to enable; false to disable
1:eac0369: 	 * @exception SQLException thrown on failure.
1:eac0369:      */
1:eac0369: 	public final void setEscapeProcessing(boolean enable) throws SQLException
1:eac0369:     {
1:eac0369:         getStatement().setEscapeProcessing( enable);
1:eac0369: 		escapeProcessing = enable ? Boolean.TRUE : Boolean.FALSE;
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * The first warning reported by calls on this Statement is
1:eac0369:      * returned.  A Statment's execute methods clear its SQLWarning
1:eac0369:      * chain. Subsequent Statement warnings will be chained to this
1:eac0369:      * SQLWarning.
1:eac0369:      *
1:eac0369:      * <p>The warning chain is automatically cleared each time
1:eac0369:      * a statement is (re)executed.
1:eac0369:      *
1:eac0369:      * <P><B>Note:</B> If you are processing a ResultSet then any
1:eac0369:      * warnings associated with ResultSet reads will be chained on the
1:eac0369:      * ResultSet object.
1:eac0369:      *
1:eac0369:      * @return the first SQLWarning or null
1:eac0369: 	 * @exception SQLException thrown on failure.
1:eac0369:      */
1:eac0369: 	public final SQLWarning getWarnings() throws SQLException
1:eac0369:     {
1:eac0369: 		return getStatement().getWarnings();
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * After this call getWarnings returns null until a new warning is
1:eac0369:      * reported for this Statement.
1:eac0369: 	 * @exception SQLException thrown on failure.
1:eac0369:      */
1:eac0369: 	public final void clearWarnings() throws SQLException
1:eac0369:     {
1:eac0369: 		getStatement().clearWarnings();
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * setCursorName defines the SQL cursor name that will be used by
1:eac0369:      * subsequent Statement execute methods. This name can then be
1:eac0369:      * used in SQL positioned update/delete statements to identify the
1:eac0369:      * current row in the ResultSet generated by this getStatement().  If
1:eac0369:      * the database doesn't support positioned update/delete, this
1:eac0369:      * method is a noop.
1:eac0369:      *
1:eac0369:      * <P><B>Note:</B> By definition, positioned update/delete
1:eac0369:      * execution must be done by a different Statement than the one
1:eac0369:      * which generated the ResultSet being used for positioning. Also,
1:eac0369:      * cursor names must be unique within a Connection.
1:eac0369:      *
1:eac0369:      * @param name the new cursor name.
1:eac0369:      */
1:eac0369: 	public final void setCursorName(String name) throws SQLException
1:eac0369:     {
1:eac0369: 		getStatement().setCursorName( name);
1:eac0369: 		cursorName = name;
1:eac0369: 	}
1:eac0369:     
1:eac0369:     
1:eac0369:     /**
1:eac0369:      *  getResultSet returns the current result as a ResultSet.  It
1:eac0369:      *  should only be called once per result.
1:eac0369:      *
1:eac0369:      * @return the current result as a ResultSet; null if the result
1:eac0369:      * is an update count or there are no more results or the statement
1:eac0369: 	 * was closed.
1:eac0369:      * @see #execute
1:eac0369:      */
1:eac0369: 	public final ResultSet getResultSet() throws SQLException
1:eac0369:     {
1:eac0369:         return wrapResultSet(getStatement().getResultSet());
1:eac0369:     }
1:eac0369:     
1:eac0369:     /**
1:eac0369:      *  getUpdateCount returns the current result as an update count;
1:eac0369:      *  if the result is a ResultSet or there are no more results -1
1:eac0369:      *  is returned.  It should only be called once per result.
1:eac0369:      *
1:eac0369:      * <P>The only way to tell for sure that the result is an update
1:eac0369:      *  count is to first test to see if it is a ResultSet. If it is
1:eac0369:      *  not a ResultSet it is either an update count or there are no
1:eac0369:      *  more results.
1:eac0369:      *
1:eac0369:      * @return the current result as an update count; -1 if it is a
1:eac0369:      * ResultSet or there are no more results
1:eac0369:      * @see #execute
1:eac0369:      */
1:eac0369: 	public final int getUpdateCount()	throws SQLException
1:eac0369:     {
1:eac0369:         return getStatement().getUpdateCount();
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * getMoreResults moves to a Statement's next result.  It returns true if
1:eac0369:      * this result is a ResultSet.  getMoreResults also implicitly
1:eac0369:      * closes any current ResultSet obtained with getResultSet.
1:eac0369:      *
1:dbed020:      * There are no more results when (!getMoreResults() &amp;&amp;
1:eac0369:      * (getUpdateCount() == -1)
1:eac0369:      *
1:eac0369:      * @return true if the next result is a ResultSet; false if it is
1:eac0369:      * an update count or there are no more results
1:eac0369:      * @see #execute
1:eac0369: 	 * @exception SQLException thrown on failure.
1:eac0369:      */
1:eac0369: 	public final boolean getMoreResults() throws SQLException
1:eac0369:     {
1:eac0369:         return getStatement().getMoreResults();
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * JDBC 2.0
1:eac0369:      *
1:eac0369:      * Determine the result set type.
1:eac0369:      *
1:eac0369:      * @exception SQLException Feature not implemented for now.
1:eac0369:      */
1:eac0369:     public final int getResultSetType()
1:eac0369: 		throws SQLException 
1:eac0369: 	{
1:eac0369:         return getStatement().getResultSetType();
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * JDBC 2.0
1:eac0369:      *
1:eac0369:      * Give a hint as to the direction in which the rows in a result set
1:eac0369:      * will be processed. The hint applies only to result sets created
1:eac0369:      * using this Statement object.  The default value is 
1:eac0369:      * ResultSet.FETCH_FORWARD.
1:eac0369:      *
1:eac0369:      * @param direction the initial direction for processing rows
1:eac0369:      * @exception SQLException if a database-access error occurs or direction
1:eac0369:      * is not one of ResultSet.FETCH_FORWARD, ResultSet.FETCH_REVERSE, or
1:eac0369:      * ResultSet.FETCH_UNKNOWN
1:eac0369:      */
1:eac0369:     public final void setFetchDirection(int direction) throws SQLException
1:eac0369:     {
1:eac0369:         getStatement().setFetchDirection( direction);
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * JDBC 2.0
1:eac0369:      *
1:eac0369:      * Give the JDBC driver a hint as to the number of rows that should
1:eac0369:      * be fetched from the database when more rows are needed.  The number 
1:eac0369:      * of rows specified only affects result sets created using this 
1:eac0369:      * getStatement(). If the value specified is zero, then the hint is ignored.
1:eac0369:      * The default value is zero.
1:eac0369:      *
1:eac0369:      * @param rows the number of rows to fetch
1:eac0369:      * @exception SQLException if a database-access error occurs, or the
1:dbed020:      * condition 0 &lt;= rows &lt;= this.getMaxRows() is not satisfied.
1:eac0369:      */
1:eac0369:     public final void setFetchSize(int rows) throws SQLException
1:eac0369:     {
1:eac0369:         getStatement().setFetchSize( rows);
1:eac0369:     }
1:eac0369: 
1:eac0369:     public final int getQueryTimeout()
1:eac0369:         throws SQLException
1:eac0369:     {
1:eac0369:         return getStatement().getQueryTimeout();
1:eac0369:     }
1:eac0369: 
1:eac0369:     public final void setQueryTimeout(int seconds)
1:eac0369:         throws SQLException
1:eac0369:     {
1:eac0369:         getStatement().setQueryTimeout( seconds);
1:eac0369:     }
1:eac0369: 
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** JDBC 3.0 methods
1:eac0369: 	*/
1:eac0369: 	public final boolean execute(String sql,
1:eac0369:                            int autoGeneratedKeys)
1:eac0369:         throws SQLException
1:eac0369:     {
1:eac0369: 
1:eac0369:         return  getStatement().execute( sql, autoGeneratedKeys);
1:eac0369:     }
1:eac0369: 
1:eac0369: 
1:eac0369:     public final boolean execute(String sql,
1:eac0369:                            int[] columnIndexes)
1:eac0369:         throws SQLException
1:eac0369:     {
1:eac0369:         return getStatement().execute( sql, columnIndexes);
1:eac0369:     }
1:eac0369: 
1:eac0369:     public final boolean execute(String sql,
1:eac0369:                            String[] columnNames)
1:eac0369:         throws SQLException
1:eac0369:     {
1:eac0369:         return getStatement().execute( sql, columnNames);
1:eac0369:     }
1:eac0369: 
1:eac0369:     public final int executeUpdate(String sql,
1:eac0369:                            int autoGeneratedKeys)
1:eac0369:         throws SQLException
1:eac0369:     {
1:eac0369:                 int retVal =  getStatement().executeUpdate( sql, autoGeneratedKeys);
1:eac0369:                 return retVal;
1:eac0369:     }
1:eac0369: 
1:eac0369:     public final int executeUpdate(String sql,
1:eac0369:                            int[] columnIndexes)
1:eac0369:         throws SQLException
1:eac0369:     {
1:eac0369:              return  getStatement().executeUpdate( sql, columnIndexes);
1:eac0369:     }
1:eac0369: 
1:eac0369:     public final int executeUpdate(String sql,
1:eac0369:                            String[] columnNames)
1:eac0369:         throws SQLException
1:eac0369:     {
1:eac0369: 
1:eac0369:         return getStatement().executeUpdate( sql, columnNames);
1:eac0369:     }
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * JDBC 3.0
1:eac0369:      *
1:eac0369:      * Moves to this Statement obect's next result, deals with any current ResultSet
1:eac0369:      * object(s) according to the instructions specified by the given flag, and
1:eac0369:      * returns true if the next result is a ResultSet object
1:eac0369:      *
1:eac0369:      * @param current - one of the following Statement constants indicating what
1:eac0369:      * should happen to current ResultSet objects obtained using the method
1:eac0369:      * getResultSetCLOSE_CURRENT_RESULT, KEEP_CURRENT_RESULT, or CLOSE_ALL_RESULTS
1:eac0369:      * @return true if the next result is a ResultSet; false if it is
1:eac0369:      * an update count or there are no more results
1:eac0369:      * @see #execute
1:eac0369:      * @exception SQLException thrown on failure.
1:eac0369:      */
1:eac0369: 	public final boolean getMoreResults(int current) throws SQLException
1:eac0369:     {
1:b5f2776:         return getStatement().getMoreResults(current);
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * JDBC 3.0
1:eac0369:      *
1:eac0369:      * Retrieves any auto-generated keys created as a result of executing this
1:eac0369:      * Statement object. If this Statement object did not generate any keys, an empty
1:eac0369:      * ResultSet object is returned. If this Statement is a non-insert statement,
1:eac0369:      * an exception will be thrown.
1:eac0369:      *
1:eac0369:      * @return a ResultSet object containing the auto-generated key(s) generated by
1:eac0369:      * the execution of this Statement object
1:eac0369:      * @exception SQLException if a database access error occurs
1:eac0369:      */
1:eac0369: 	public final ResultSet getGeneratedKeys() throws SQLException
1:eac0369:     {
1:eac0369:         return wrapResultSet(getStatement().getGeneratedKeys());
1:eac0369:     }
1:eac0369: 
1:562671e:     /**
1:562671e:      * Return the holdability of ResultSets created by this Statement.
1:562671e:      * If this Statement is active in a global transaction the
1:562671e:      * CLOSE_CURSORS_ON_COMMIT will be returned regardless of
1:562671e:      * the holdability it was created with. In a local transaction
1:562671e:      * the original create holdabilty will be returned.
1:562671e:      */
1:eac0369: 	public final int getResultSetHoldability()
1:eac0369:         throws SQLException
1:eac0369: 	{
1:b5f2776:         int holdability = getStatement().getResultSetHoldability();
1:562671e:         
1:562671e:         // Holdability might be downgraded.
1:562671e:         return controlCheck().checkHoldCursors(holdability);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Control methods
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	public Statement createDuplicateStatement(Connection conn, Statement oldStatement) throws SQLException {
1:eac0369: 
1:eac0369: 		Statement newStatement;
1:3be5c9d: 		newStatement = conn.createStatement(resultSetType, resultSetConcurrency,
1:562671e:                     resultSetHoldability);
1:eac0369: 
1:eac0369: 		setStatementState(oldStatement, newStatement);
1:eac0369: 
1:eac0369: 		return newStatement;
1:eac0369: 	}
1:eac0369: 
1:e65be5b: 	void setStatementState(Statement oldStatement, Statement newStatement) throws SQLException {
1:eac0369: 		if (cursorName != null)
1:eac0369: 			newStatement.setCursorName(cursorName);
1:eac0369: 		if (escapeProcessing != null)
1:eac0369: 			newStatement.setEscapeProcessing(escapeProcessing.booleanValue());
1:eac0369: 
1:eac0369: 		newStatement.setFetchDirection(oldStatement.getFetchDirection());
1:eac0369: 		newStatement.setFetchSize(oldStatement.getFetchSize());
1:eac0369: 		newStatement.setMaxFieldSize(oldStatement.getMaxFieldSize());
1:eac0369: 		newStatement.setMaxRows(oldStatement.getMaxRows());
1:eac0369: 		newStatement.setQueryTimeout(oldStatement.getQueryTimeout());
1:eac0369: 	}
1:eac0369: 
1:2e4a36f: 	public Statement getStatement() throws SQLException {
1:eac0369: 		return control.getRealStatement();
1:eac0369: 	}
1:e65be5b:     
1:e65be5b:     /**
1:e65be5b:      * Provide the control access to every ResultSet we return.
1:e65be5b:      * If required the control can wrap the ResultSet, but
1:e65be5b:      * it (the control) must ensure a underlying ResultSet is
1:e65be5b:      * only wrapped once, if say java.sql.Statement.getResultSet
1:e65be5b:      * is returned twice.
1:e65be5b:      * 
1:e65be5b:      * @param rs ResultSet being returned, can be null.
1:e65be5b:      */
1:e65be5b: 	final ResultSet wrapResultSet(ResultSet rs) {
1:e65be5b: 		return control.wrapResultSet(this, rs);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:7827676: 		Get the BrokeredStatementControl in order to perform a check.
1:7827676: 		Obtained indirectly to ensure that the correct exception is
1:7827676: 		thrown if the Statement has been closed.
1:7827676: 	*/
1:e65be5b: 	final BrokeredStatementControl controlCheck() throws SQLException
1:7827676: 	{
1:7827676: 		// simplest method that will throw an exception if the Statement is closed
1:7827676: 		getStatement().getConnection();
1:7827676: 		return control;
1:fcf7ef3: 	}
1:fcf7ef3: 
1:46e89a9:     // JDBC 4.0 java.sql.Wrapper interface methods
1:46e89a9: 
1:2658306:     /**
1:2658306:      * Returns false unless <code>iface</code> is implemented 
1:2658306:      * 
1:2658306:      * @param  iface                  a Class defining an interface.
1:2658306:      * @return true                   if this implements the interface or 
1:2658306:      *                                directly or indirectly wraps an object 
1:2658306:      *                                that does.
1:2658306:      * @throws java.sql.SQLException  if an error occurs while determining 
1:2658306:      *                                whether this is a wrapper for an object 
1:2658306:      *                                with the given interface.
1:2658306:      */
1:2658306:     public boolean isWrapperFor(Class iface) throws SQLException {
1:2658306:         checkIfClosed();
1:2658306:         return iface.isInstance(this);
1:2658306:     }
1:2658306: 
1:2658306:     /**
1:46e89a9:      * Returns {@code this} if this class implements the specified interface.
1:46e89a9:      *
1:46e89a9:      * @param iface a class defining an interface
1:46e89a9:      * @return an object that implements the interface
1:46e89a9:      * @throws SQLException if no object is found that implements the
1:46e89a9:      * interface
1:46e89a9:      */
1:46e89a9:     public <T> T unwrap(Class<T> iface) throws SQLException {
1:46e89a9:         checkIfClosed();
1:46e89a9:         // Derby does not implement non-standard methods on JDBC objects.
1:46e89a9:         try {
1:46e89a9:             return iface.cast(this);
1:46e89a9:         } catch (ClassCastException cce) {
1:46e89a9:             throw unableToUnwrap(iface);
1:46e89a9:         }
1:46e89a9:     }
1:46e89a9: 
1:46e89a9:     /**
1:c9ec6b9:      * Checks if the statement is closed.
1:2658306:      *
1:2658306:      * @return <code>true</code> if the statement is closed,
1:2658306:      * <code>false</code> otherwise
1:c9ec6b9:      * @exception SQLException if an error occurs
1:2658306:      */
1:c9ec6b9:     public final boolean isClosed() throws SQLException {
1:b5f2776:         return getStatement().isClosed();
1:562671e:     }
1:2658306: 
1:2658306:     /**
1:2658306:      * Checks if the statement is closed and throws an exception if it
1:ec60014:      * is.
1:2658306:      *
1:2658306:      * @exception SQLException if the statement is closed
1:2658306:      */
1:2658306:     protected final void checkIfClosed()
1:2658306:         throws SQLException
1:2658306:     {
1:2658306:         if (isClosed()) {
1:aa5c5de:             throw ExceptionFactory.getInstance().getSQLException(
1:ec60014:                     SQLState.ALREADY_CLOSED, null, null,
1:ec60014:                     new Object[]{ "Statement" });
1:2658306:         }
1:2658306:     }
1:ec60014: 
1:ec60014:     /**
1:ec60014:      * Return an exception that reports that an unwrap operation has failed
1:ec60014:      * because the object couldn't be cast to the specified interface.
1:ec60014:      *
1:ec60014:      * @param iface the class or interface passed in to the failed unwrap call
1:ec60014:      * @return an exception indicating that unwrap failed
1:ec60014:      */
1:ec60014:     final SQLException unableToUnwrap(Class iface) {
1:aa5c5de:         return ExceptionFactory.getInstance().getSQLException(
1:ec60014:                 SQLState.UNABLE_TO_UNWRAP, null, null,
1:ec60014:                 new Object[]{ iface });
1:ec60014:     }
1:863daa0: 
1:863daa0:     /**
1:863daa0:      * Forwards to the real Statement.
1:863daa0:      *
1:863daa0:      * @return true if the underlying Statement is poolable, false otherwise.
1:863daa0:      * @throws SQLException if the forwarding call fails.
1:863daa0:      */
1:863daa0:     public final boolean isPoolable() throws SQLException {
1:863daa0:         return getStatement().isPoolable();
1:863daa0:     }
1:863daa0: 
1:863daa0:     /**
1:863daa0:      * Forwards to the real Statement.
1:863daa0:      *
1:863daa0:      * @param poolable the new value for the poolable hint.
1:863daa0:      * @throws SQLException if the forwarding call fails.
1:863daa0:      */
1:863daa0:     public final void setPoolable(boolean poolable) throws SQLException {
1:863daa0:         getStatement().setPoolable(poolable);
1:863daa0:     }
1:863daa0: 
1:de8ba18:     ////////////////////////////////////////////////////////////////////
1:de8ba18:     //
1:de8ba18:     // INTRODUCED BY JDBC 4.1 IN JAVA 7
1:de8ba18:     //
1:de8ba18:     ////////////////////////////////////////////////////////////////////
1:de8ba18: 
1:de8ba18:     public  void    closeOnCompletion() throws SQLException
1:de8ba18:     {
1:de8ba18:         ((EngineStatement) getStatement()).closeOnCompletion();
1:de8ba18:     }
1:de8ba18: 
1:de8ba18:     public  boolean isCloseOnCompletion() throws SQLException
1:de8ba18:     {
1:de8ba18:         return ((EngineStatement) getStatement()).isCloseOnCompletion();
1:de8ba18:     }
1:de8ba18:     
1:7fb9956:     ////////////////////////////////////////////////////////////////////
1:7fb9956:     //
1:7fb9956:     // INTRODUCED BY JDBC 4.2 IN JAVA 8
1:7fb9956:     //
1:7fb9956:     ////////////////////////////////////////////////////////////////////
1:7fb9956: 
1:0b0a105:     public  long[] executeLargeBatch() throws SQLException
1:0b0a105:     {
1:0b0a105:         return ((EngineStatement) getStatement()).executeLargeBatch();
1:0b0a105:     }
1:7fb9956:     public  long executeLargeUpdate( String sql ) throws SQLException
1:7fb9956:     {
1:7fb9956:         return ((EngineStatement) getStatement()).executeLargeUpdate( sql );
1:7fb9956:     }
1:7fb9956:     public  long executeLargeUpdate( String sql, int autoGeneratedKeys) throws SQLException
1:7fb9956:     {
1:7fb9956:         return ((EngineStatement) getStatement()).executeLargeUpdate( sql, autoGeneratedKeys );
1:7fb9956:     }
1:7fb9956:     public  long executeLargeUpdate( String sql, int[] columnIndexes ) throws SQLException
1:7fb9956:     {
1:7fb9956:         return ((EngineStatement) getStatement()).executeLargeUpdate( sql, columnIndexes );
1:7fb9956:     }
1:7fb9956:     public  long executeLargeUpdate( String sql, String[] columnNames ) throws SQLException
1:7fb9956:     {
1:7fb9956:         return ((EngineStatement) getStatement()).executeLargeUpdate( sql, columnNames );
1:7fb9956:     }
1:47a8183:     public  long getLargeMaxRows() throws SQLException
1:47a8183:     {
1:47a8183:         return ((EngineStatement) getStatement()).getLargeMaxRows();
1:47a8183:     }
1:f26c60c:     public  long getLargeUpdateCount() throws SQLException
1:f26c60c:     {
1:f26c60c:         return ((EngineStatement) getStatement()).getLargeUpdateCount();
1:f26c60c:     }
1:47a8183:     public  void setLargeMaxRows( long max ) throws SQLException
1:47a8183:     {
1:47a8183:         ((EngineStatement) getStatement()).setLargeMaxRows( max );
1:47a8183:     }
1:7fb9956: 
1:7827676: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1:      * There are no more results when (!getMoreResults() &amp;&amp;
/////////////////////////////////////////////////////////////////////////
1:      * condition 0 &lt;= rows &lt;= this.getMaxRows() is not satisfied.
commit:eec86ed
/////////////////////////////////////////////////////////////////////////
0: public abstract class BrokeredStatement implements EngineStatement
commit:47a8183
/////////////////////////////////////////////////////////////////////////
1:     public  long getLargeMaxRows() throws SQLException
1:     {
1:         return ((EngineStatement) getStatement()).getLargeMaxRows();
1:     }
1:     public  void setLargeMaxRows( long max ) throws SQLException
1:     {
1:         ((EngineStatement) getStatement()).setLargeMaxRows( max );
1:     }
commit:0b0a105
/////////////////////////////////////////////////////////////////////////
1:     public  long[] executeLargeBatch() throws SQLException
1:     {
1:         return ((EngineStatement) getStatement()).executeLargeBatch();
1:     }
commit:f26c60c
/////////////////////////////////////////////////////////////////////////
1:     public  long getLargeUpdateCount() throws SQLException
1:     {
1:         return ((EngineStatement) getStatement()).getLargeUpdateCount();
1:     }
commit:7fb9956
/////////////////////////////////////////////////////////////////////////
1:     ////////////////////////////////////////////////////////////////////
1:     //
1:     // INTRODUCED BY JDBC 4.2 IN JAVA 8
1:     //
1:     ////////////////////////////////////////////////////////////////////
1: 
1:     public  long executeLargeUpdate( String sql ) throws SQLException
1:     {
1:         return ((EngineStatement) getStatement()).executeLargeUpdate( sql );
1:     }
1:     public  long executeLargeUpdate( String sql, int autoGeneratedKeys) throws SQLException
1:     {
1:         return ((EngineStatement) getStatement()).executeLargeUpdate( sql, autoGeneratedKeys );
1:     }
1:     public  long executeLargeUpdate( String sql, int[] columnIndexes ) throws SQLException
1:     {
1:         return ((EngineStatement) getStatement()).executeLargeUpdate( sql, columnIndexes );
1:     }
1:     public  long executeLargeUpdate( String sql, String[] columnNames ) throws SQLException
1:     {
1:         return ((EngineStatement) getStatement()).executeLargeUpdate( sql, columnNames );
1:     }
1: 
commit:de8ba18
/////////////////////////////////////////////////////////////////////////
1:     
1:     ////////////////////////////////////////////////////////////////////
1:     //
1:     // INTRODUCED BY JDBC 4.1 IN JAVA 7
1:     //
1:     ////////////////////////////////////////////////////////////////////
1: 
1:     public  void    closeOnCompletion() throws SQLException
1:     {
1:         ((EngineStatement) getStatement()).closeOnCompletion();
1:     }
1: 
1:     public  boolean isCloseOnCompletion() throws SQLException
1:     {
1:         return ((EngineStatement) getStatement()).isCloseOnCompletion();
1:     }
1:     
commit:2431ece
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:863daa0
/////////////////////////////////////////////////////////////////////////
1:     This class implements the JDBC 4.1 interface.
1: public class BrokeredStatement implements EngineStatement
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Forwards to the real Statement.
1:      *
1:      * @return true if the underlying Statement is poolable, false otherwise.
1:      * @throws SQLException if the forwarding call fails.
1:      */
1:     public final boolean isPoolable() throws SQLException {
1:         return getStatement().isPoolable();
1:     }
1: 
1:     /**
1:      * Forwards to the real Statement.
1:      *
1:      * @param poolable the new value for the poolable hint.
1:      * @throws SQLException if the forwarding call fails.
1:      */
1:     public final void setPoolable(boolean poolable) throws SQLException {
1:         getStatement().setPoolable(poolable);
1:     }
1: 
commit:aa5c5de
/////////////////////////////////////////////////////////////////////////
1:             throw ExceptionFactory.getInstance().getSQLException(
/////////////////////////////////////////////////////////////////////////
1:         return ExceptionFactory.getInstance().getSQLException(
commit:b5f2776
/////////////////////////////////////////////////////////////////////////
1:         return getStatement().getMoreResults(current);
/////////////////////////////////////////////////////////////////////////
1:         int holdability = getStatement().getResultSetHoldability();
/////////////////////////////////////////////////////////////////////////
1:         return getStatement().isClosed();
commit:46e89a9
/////////////////////////////////////////////////////////////////////////
1:     // JDBC 4.0 java.sql.Wrapper interface methods
1: 
/////////////////////////////////////////////////////////////////////////
1:      * Returns {@code this} if this class implements the specified interface.
1:      *
1:      * @param iface a class defining an interface
1:      * @return an object that implements the interface
1:      * @throws SQLException if no object is found that implements the
1:      * interface
1:      */
1:     public <T> T unwrap(Class<T> iface) throws SQLException {
1:         checkIfClosed();
1:         // Derby does not implement non-standard methods on JDBC objects.
1:         try {
1:             return iface.cast(this);
1:         } catch (ClassCastException cce) {
1:             throw unableToUnwrap(iface);
1:         }
1:     }
1: 
1:     /**
commit:ec60014
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:      * is.
/////////////////////////////////////////////////////////////////////////
0:             throw control.getExceptionFactory().getSQLException(
1:                     SQLState.ALREADY_CLOSED, null, null,
1:                     new Object[]{ "Statement" });
1: 
1:     /**
1:      * Return an exception that reports that an unwrap operation has failed
1:      * because the object couldn't be cast to the specified interface.
1:      *
1:      * @param iface the class or interface passed in to the failed unwrap call
1:      * @return an exception indicating that unwrap failed
1:      */
1:     final SQLException unableToUnwrap(Class iface) {
0:         return control.getExceptionFactory().getSQLException(
1:                 SQLState.UNABLE_TO_UNWRAP, null, null,
1:                 new Object[]{ iface });
1:     }
commit:c9ec6b9
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:      * Checks if the statement is closed.
1:      * @exception SQLException if an error occurs
1:     public final boolean isClosed() throws SQLException {
0:         return ((EngineStatement) getStatement()).isClosed();
commit:2658306
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Returns false unless <code>iface</code> is implemented 
1:      * 
1:      * @param  iface                  a Class defining an interface.
1:      * @return true                   if this implements the interface or 
1:      *                                directly or indirectly wraps an object 
1:      *                                that does.
1:      * @throws java.sql.SQLException  if an error occurs while determining 
1:      *                                whether this is a wrapper for an object 
1:      *                                with the given interface.
1:      */
1:     public boolean isWrapperFor(Class iface) throws SQLException {
1:         checkIfClosed();
1:         return iface.isInstance(this);
1:     }
1: 
1:     /**
0:      * Checks if the statement is closed. Not implemented for this
0:      * class since <code>isClosed()</code> is a new method in JDBC
0:      * 4.0. The JDBC 4.0 sub-classes should override this method.
1:      *
1:      * @return <code>true</code> if the statement is closed,
1:      * <code>false</code> otherwise
0:      * @exception SQLException not-implemented exception
1:      */
0:     protected boolean isClosed() throws SQLException {
0:         // Not implemented since we cannot forward the call to a JDBC
0:         // 4.0 method from this class. This dummy implementation is
0:         // provided here so that checkIfClosed() can be implemented
0:         // once in this class instead of once in each of the
0:         // Brokered*Statement40 classes.
1: 
1:     /**
1:      * Checks if the statement is closed and throws an exception if it
0:      * is. This method relies on the <code>isClosed()</code> method
0:      * and therefore only works with JDBC 4.0.
1:      *
1:      * @exception SQLException if the statement is closed
1:      */
1:     protected final void checkIfClosed()
1:         throws SQLException
1:     {
1:         if (isClosed()) {
0:             throw Util.generateCsSQLException(SQLState.ALREADY_CLOSED,
0:                                               "Statement");
1:         }
1:     }
commit:fcf7ef3
/////////////////////////////////////////////////////////////////////////
1: 
0:     public boolean isClosed()
0:         throws SQLException {
0:         // NOTE 1: Depending on implementation, this method may have to be
0:         //  duplicated in the 3 *Statement40 classes.
0:         // NOTE 2: This is the only method using the Util class. Remove
0:         //  import when method is implemented.
0:         throw Util.notImplemented();
1:     }
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:5b78c4e
/////////////////////////////////////////////////////////////////////////
1: 	public void close() throws SQLException
1: 		control.closeRealStatement();
commit:3be5c9d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     BrokeredStatement(BrokeredStatementControl control) throws SQLException
/////////////////////////////////////////////////////////////////////////
1: 		newStatement = conn.createStatement(resultSetType, resultSetConcurrency,
commit:2e4a36f
/////////////////////////////////////////////////////////////////////////
1: 	public Statement getStatement() throws SQLException {
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:175a740
/////////////////////////////////////////////////////////////////////////
1:  		return wrapResultSet(getStatement().executeQuery(sql));
/////////////////////////////////////////////////////////////////////////
commit:562671e
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.impl.jdbc.Util;
1: 
/////////////////////////////////////////////////////////////////////////
0:         checkHoldability();
0:         checkHoldability();
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Return the holdability of ResultSets created by this Statement.
1:      * If this Statement is active in a global transaction the
1:      * CLOSE_CURSORS_ON_COMMIT will be returned regardless of
1:      * the holdability it was created with. In a local transaction
1:      * the original create holdabilty will be returned.
1:      */
0:         int holdability =
0:             ((EngineStatement) getStatement()).getResultSetHoldability();
1:         
1:         // Holdability might be downgraded.
1:         return controlCheck().checkHoldCursors(holdability);
/////////////////////////////////////////////////////////////////////////
0: 			newStatement = conn.createStatement(resultSetType, resultSetConcurrency,
1:                     resultSetHoldability);
/////////////////////////////////////////////////////////////////////////
1:     
0:     final void checkHoldability() throws SQLException {
0:         int holdability = controlCheck().checkHoldCursors(resultSetHoldability);
0:         if (holdability != resultSetHoldability)
0:             throw Util.generateCsSQLException(SQLState.CANNOT_HOLD_CURSOR_XA);
1: 
1:     }
commit:4e3b1b6
/////////////////////////////////////////////////////////////////////////
0: public class BrokeredStatement implements EngineStatement
/////////////////////////////////////////////////////////////////////////
0:         return ((EngineStatement) getStatement()).getMoreResults( current);
/////////////////////////////////////////////////////////////////////////
0: 		return ((EngineStatement) getStatement()).getResultSetHoldability();
commit:e65be5b
/////////////////////////////////////////////////////////////////////////
1: 	final BrokeredStatementControl control;
0: 	final int jdbcLevel;
1: 	final int resultSetType;
1: 	final int resultSetConcurrency;
1: 	final int resultSetHoldability;
/////////////////////////////////////////////////////////////////////////
0:     BrokeredStatement(BrokeredStatementControl control, int jdbcLevel) throws SQLException
/////////////////////////////////////////////////////////////////////////
1: 	void setStatementState(Statement oldStatement, Statement newStatement) throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Provide the control access to every ResultSet we return.
1:      * If required the control can wrap the ResultSet, but
1:      * it (the control) must ensure a underlying ResultSet is
1:      * only wrapped once, if say java.sql.Statement.getResultSet
1:      * is returned twice.
1:      * 
1:      * @param rs ResultSet being returned, can be null.
1:      */
1: 	final ResultSet wrapResultSet(ResultSet rs) {
1: 		return control.wrapResultSet(this, rs);
/////////////////////////////////////////////////////////////////////////
1: 	final BrokeredStatementControl controlCheck() throws SQLException
commit:6ae3022
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.services.info.JVMInfo;
/////////////////////////////////////////////////////////////////////////
0: 		if (JVMInfo.JDK_ID >= JVMInfo.J2SE_14) { //No need to use reflection for jdks 1.4 and higher
commit:7ecc1f2
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.iapi.jdbc.BrokeredStatement
1: 
0:    Copyright 2003, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:5d24b1a
/////////////////////////////////////////////////////////////////////////
commit:7827676
/////////////////////////////////////////////////////////////////////////
1: 		My control. Use the controlCheck() method to obtain the control
1: 		when calling a check method. This will result in the correct exception
1: 		being thrown if the statement is already closed.
/////////////////////////////////////////////////////////////////////////
0: 		controlCheck().checkHoldCursors(resultSetHoldability);
0: 		controlCheck().checkHoldCursors(resultSetHoldability);
/////////////////////////////////////////////////////////////////////////
1: 
1: 	/**
1: 		Get the BrokeredStatementControl in order to perform a check.
1: 		Obtained indirectly to ensure that the correct exception is
1: 		thrown if the Statement has been closed.
1: 	*/
0: 	protected final BrokeredStatementControl controlCheck() throws SQLException
1: 	{
1: 		// simplest method that will throw an exception if the Statement is closed
1: 		getStatement().getConnection();
1: 		return control;
1: 	}
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.jdbc
0:    (C) Copyright IBM Corp. 2003, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.iapi.jdbc;
1: 
0: import org.apache.derby.iapi.reference.JDBC30Translation;
1: 
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.error.PublicAPI;
1: 
1: import java.sql.Connection;
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: import java.sql.SQLWarning;
1: import java.sql.Statement;
1: 
0: import java.lang.reflect.*;
1: 
1: /**
1: 	A Statement implementation that forwards all of its requests to an underlying Statement.
1:  */
0: public class BrokeredStatement implements Statement
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
1: 
0:     private static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2003_2004;
1: 
1: 	/**
0: 		My control.
1: 	*/
0: 	protected final BrokeredStatementControl control;
1: 
0: 	protected final int jdbcLevel;
0: 	protected final int resultSetType;
0: 	protected final int resultSetConcurrency;
0: 	protected final int resultSetHoldability;
1: 
1: 	/**
1: 		My state
1: 	*/
1: 	private String cursorName;
1: 	private Boolean escapeProcessing;
1: 
0:     protected BrokeredStatement(BrokeredStatementControl control, int jdbcLevel) throws SQLException
1:     {
1: 		this.control = control;
0: 		this.jdbcLevel = jdbcLevel;
1: 
1: 		// save the state of the Statement while we are pretty much guaranteed the
1: 		// underlying statement is open.
1: 		resultSetType = getResultSetType();
1: 		resultSetConcurrency = getResultSetConcurrency();
1: 
1: 		resultSetHoldability = getResultSetHoldability();
1:     }
1: 
1: 
1:     public final void addBatch(String sql)
1:               throws SQLException
1:     {
1: 		getStatement().addBatch( sql);
1: 	}
1: 
1:     public final void clearBatch()
1:         throws SQLException
1:     {
1:            getStatement().clearBatch();
1: 	}
1: 
1:     public final int[] executeBatch()
1:         throws SQLException
1:     {
1: 		return getStatement().executeBatch();
1: 	}
1: 
1: 
1:     public final void cancel()
1:         throws SQLException
1:     {
1:         getStatement().cancel();
1:     }
1: 
1:     public final boolean execute(String sql) throws SQLException
1: 	{
0: 		control.checkHoldCursors(resultSetHoldability);
1: 		return getStatement().execute(sql);
1:     } 
1: 
1:     public final ResultSet executeQuery(String sql) throws SQLException
1: 	{
0: 		control.checkHoldCursors(resultSetHoldability);
0: 		return wrapResultSet(getStatement().executeQuery(sql));
1:     }
1: 
1:     public final int executeUpdate(String sql) throws SQLException
1: 	{
1: 		return getStatement().executeUpdate(sql);
1:     }
1: 
1:         
1:     /**
1:      * In many cases, it is desirable to immediately release a
1:      * Statements's database and JDBC resources instead of waiting for
1:      * this to happen when it is automatically closed; the close
1:      * method provides this immediate release.
1:      *
1:      * <P><B>Note:</B> A Statement is automatically closed when it is
1:      * garbage collected. When a Statement is closed its current
1:      * ResultSet, if one exists, is also closed.
1: 	 * @exception SQLException thrown on failure.
1:      */
0: 	public final void close() throws SQLException
1:     {
0: 		getStatement().close();
1:     }
1: 
1:     public final Connection getConnection()
1:         throws SQLException
1:     {
1: 		return getStatement().getConnection();
1: 	}
1: 
1:     public final int getFetchDirection()
1:         throws SQLException
1:     {
1: 		return getStatement().getFetchDirection();
1: 	}
1: 
1:     public final int getFetchSize()
1:         throws SQLException
1:     {
1: 		return getStatement().getFetchSize();
1: 	}
1: 
1:     public final int getMaxFieldSize()
1:         throws SQLException
1:     {
1: 		return getStatement().getMaxFieldSize();
1: 	}
1: 
1:     public final int getMaxRows()
1:         throws SQLException
1:     {
1: 		return getStatement().getMaxRows();
1: 	}
1: 
1:     public final int getResultSetConcurrency()
1:         throws SQLException
1:     {
1: 		return getStatement().getResultSetConcurrency();
1: 	}
1: 
1:     /**
1:      * The maxFieldSize limit (in bytes) is set to limit the size of
1:      * data that can be returned for any column value; it only applies
1:      * to BINARY, VARBINARY, LONGVARBINARY, CHAR, VARCHAR, and
1:      * LONGVARCHAR fields.  If the limit is exceeded, the excess data
1:      * is silently discarded.
1:      *
1:      * @param max the new max column size limit; zero means unlimited
1: 	 * @exception SQLException thrown on failure.
1:      */
1: 	public final void setMaxFieldSize(int max) throws SQLException
1:     {
1:         getStatement().setMaxFieldSize(max);
1: 	}
1: 
1:     /**
1:      * The maxRows limit is set to limit the number of rows that any
1:      * ResultSet can contain.  If the limit is exceeded, the excess
1:      * rows are silently dropped.
1:      *
1:      * @param max the new max rows limit; zero means unlimited
1: 	 * @exception SQLException thrown on failure.
1:      */
1: 	public final void setMaxRows(int max) throws SQLException	
1: 	{
1:         getStatement().setMaxRows( max);
1:     }
1: 
1:     /**
1:      * If escape scanning is on (the default) the driver will do
1:      * escape substitution before sending the SQL to the database.
1:      *
1:      * @param enable true to enable; false to disable
1: 	 * @exception SQLException thrown on failure.
1:      */
1: 	public final void setEscapeProcessing(boolean enable) throws SQLException
1:     {
1:         getStatement().setEscapeProcessing( enable);
1: 		escapeProcessing = enable ? Boolean.TRUE : Boolean.FALSE;
1: 	}
1: 
1:     /**
1:      * The first warning reported by calls on this Statement is
1:      * returned.  A Statment's execute methods clear its SQLWarning
1:      * chain. Subsequent Statement warnings will be chained to this
1:      * SQLWarning.
1:      *
1:      * <p>The warning chain is automatically cleared each time
1:      * a statement is (re)executed.
1:      *
1:      * <P><B>Note:</B> If you are processing a ResultSet then any
1:      * warnings associated with ResultSet reads will be chained on the
1:      * ResultSet object.
1:      *
1:      * @return the first SQLWarning or null
1: 	 * @exception SQLException thrown on failure.
1:      */
1: 	public final SQLWarning getWarnings() throws SQLException
1:     {
1: 		return getStatement().getWarnings();
1: 	}
1: 
1:     /**
1:      * After this call getWarnings returns null until a new warning is
1:      * reported for this Statement.
1: 	 * @exception SQLException thrown on failure.
1:      */
1: 	public final void clearWarnings() throws SQLException
1:     {
1: 		getStatement().clearWarnings();
1:     }
1: 
1:     /**
1:      * setCursorName defines the SQL cursor name that will be used by
1:      * subsequent Statement execute methods. This name can then be
1:      * used in SQL positioned update/delete statements to identify the
1:      * current row in the ResultSet generated by this getStatement().  If
1:      * the database doesn't support positioned update/delete, this
1:      * method is a noop.
1:      *
1:      * <P><B>Note:</B> By definition, positioned update/delete
1:      * execution must be done by a different Statement than the one
1:      * which generated the ResultSet being used for positioning. Also,
1:      * cursor names must be unique within a Connection.
1:      *
1:      * @param name the new cursor name.
1:      */
1: 	public final void setCursorName(String name) throws SQLException
1:     {
1: 		getStatement().setCursorName( name);
1: 		cursorName = name;
1: 	}
1:     
1:     
1:     /**
1:      *  getResultSet returns the current result as a ResultSet.  It
1:      *  should only be called once per result.
1:      *
1:      * @return the current result as a ResultSet; null if the result
1:      * is an update count or there are no more results or the statement
1: 	 * was closed.
1:      * @see #execute
1:      */
1: 	public final ResultSet getResultSet() throws SQLException
1:     {
1:         return wrapResultSet(getStatement().getResultSet());
1:     }
1:     
1:     /**
1:      *  getUpdateCount returns the current result as an update count;
1:      *  if the result is a ResultSet or there are no more results -1
1:      *  is returned.  It should only be called once per result.
1:      *
1:      * <P>The only way to tell for sure that the result is an update
1:      *  count is to first test to see if it is a ResultSet. If it is
1:      *  not a ResultSet it is either an update count or there are no
1:      *  more results.
1:      *
1:      * @return the current result as an update count; -1 if it is a
1:      * ResultSet or there are no more results
1:      * @see #execute
1:      */
1: 	public final int getUpdateCount()	throws SQLException
1:     {
1:         return getStatement().getUpdateCount();
1:     }
1: 
1:     /**
1:      * getMoreResults moves to a Statement's next result.  It returns true if
1:      * this result is a ResultSet.  getMoreResults also implicitly
1:      * closes any current ResultSet obtained with getResultSet.
1:      *
0:      * There are no more results when (!getMoreResults() &&
1:      * (getUpdateCount() == -1)
1:      *
1:      * @return true if the next result is a ResultSet; false if it is
1:      * an update count or there are no more results
1:      * @see #execute
1: 	 * @exception SQLException thrown on failure.
1:      */
1: 	public final boolean getMoreResults() throws SQLException
1:     {
1:         return getStatement().getMoreResults();
1:     }
1: 
1:     /**
1:      * JDBC 2.0
1:      *
1:      * Determine the result set type.
1:      *
1:      * @exception SQLException Feature not implemented for now.
1:      */
1:     public final int getResultSetType()
1: 		throws SQLException 
1: 	{
1:         return getStatement().getResultSetType();
1:     }
1: 
1:     /**
1:      * JDBC 2.0
1:      *
1:      * Give a hint as to the direction in which the rows in a result set
1:      * will be processed. The hint applies only to result sets created
1:      * using this Statement object.  The default value is 
1:      * ResultSet.FETCH_FORWARD.
1:      *
1:      * @param direction the initial direction for processing rows
1:      * @exception SQLException if a database-access error occurs or direction
1:      * is not one of ResultSet.FETCH_FORWARD, ResultSet.FETCH_REVERSE, or
1:      * ResultSet.FETCH_UNKNOWN
1:      */
1:     public final void setFetchDirection(int direction) throws SQLException
1:     {
1:         getStatement().setFetchDirection( direction);
1:     }
1: 
1:     /**
1:      * JDBC 2.0
1:      *
1:      * Give the JDBC driver a hint as to the number of rows that should
1:      * be fetched from the database when more rows are needed.  The number 
1:      * of rows specified only affects result sets created using this 
1:      * getStatement(). If the value specified is zero, then the hint is ignored.
1:      * The default value is zero.
1:      *
1:      * @param rows the number of rows to fetch
1:      * @exception SQLException if a database-access error occurs, or the
0:      * condition 0 <= rows <= this.getMaxRows() is not satisfied.
1:      */
1:     public final void setFetchSize(int rows) throws SQLException
1:     {
1:         getStatement().setFetchSize( rows);
1:     }
1: 
1:     public final int getQueryTimeout()
1:         throws SQLException
1:     {
1:         return getStatement().getQueryTimeout();
1:     }
1: 
1:     public final void setQueryTimeout(int seconds)
1:         throws SQLException
1:     {
1:         getStatement().setQueryTimeout( seconds);
1:     }
1: 
1: 
1: 	/*
1: 	** JDBC 3.0 methods
1: 	*/
1: 	public final boolean execute(String sql,
1:                            int autoGeneratedKeys)
1:         throws SQLException
1:     {
1: 
1:         return  getStatement().execute( sql, autoGeneratedKeys);
1:     }
1: 
1: 
1:     public final boolean execute(String sql,
1:                            int[] columnIndexes)
1:         throws SQLException
1:     {
1:         return getStatement().execute( sql, columnIndexes);
1:     }
1: 
1:     public final boolean execute(String sql,
1:                            String[] columnNames)
1:         throws SQLException
1:     {
1:         return getStatement().execute( sql, columnNames);
1:     }
1: 
1:     public final int executeUpdate(String sql,
1:                            int autoGeneratedKeys)
1:         throws SQLException
1:     {
1:                 int retVal =  getStatement().executeUpdate( sql, autoGeneratedKeys);
1:                 return retVal;
1:     }
1: 
1:     public final int executeUpdate(String sql,
1:                            int[] columnIndexes)
1:         throws SQLException
1:     {
1:              return  getStatement().executeUpdate( sql, columnIndexes);
1:     }
1: 
1:     public final int executeUpdate(String sql,
1:                            String[] columnNames)
1:         throws SQLException
1:     {
1: 
1:         return getStatement().executeUpdate( sql, columnNames);
1:     }
1: 
1: 
1: 
1:     /**
1:      * JDBC 3.0
1:      *
1:      * Moves to this Statement obect's next result, deals with any current ResultSet
1:      * object(s) according to the instructions specified by the given flag, and
1:      * returns true if the next result is a ResultSet object
1:      *
1:      * @param current - one of the following Statement constants indicating what
1:      * should happen to current ResultSet objects obtained using the method
1:      * getResultSetCLOSE_CURRENT_RESULT, KEEP_CURRENT_RESULT, or CLOSE_ALL_RESULTS
1:      * @return true if the next result is a ResultSet; false if it is
1:      * an update count or there are no more results
1:      * @see #execute
1:      * @exception SQLException thrown on failure.
1:      */
1: 	public final boolean getMoreResults(int current) throws SQLException
1:     {
0:         return getStatement().getMoreResults( current);
1: 	}
1: 
1:     /**
1:      * JDBC 3.0
1:      *
1:      * Retrieves any auto-generated keys created as a result of executing this
1:      * Statement object. If this Statement object did not generate any keys, an empty
1:      * ResultSet object is returned. If this Statement is a non-insert statement,
1:      * an exception will be thrown.
1:      *
1:      * @return a ResultSet object containing the auto-generated key(s) generated by
1:      * the execution of this Statement object
1:      * @exception SQLException if a database access error occurs
1:      */
1: 	public final ResultSet getGeneratedKeys() throws SQLException
1:     {
1:         return wrapResultSet(getStatement().getGeneratedKeys());
1:     }
1: 
1: 	public final int getResultSetHoldability()
1:         throws SQLException
1: 	{
0: 		int defaultHoldability = JDBC30Translation.HOLD_CURSORS_OVER_COMMIT;
0: 		if (org.apache.derby.iapi.services.info.JVMInfo.JDK_ID > 2) { //No need to use reflection for jdks 1.4 and higher
0: 			defaultHoldability = getStatement().getResultSetHoldability();
0: 		} else {
0: 			try {
0: 				Method sh = getStatement().getClass().getMethod("getResultSetHoldability", null);
0: 				defaultHoldability = ((Integer)sh.invoke(getStatement(), null)).intValue();
0: 			} catch( Exception e)
1: 			{
0: 				throw PublicAPI.wrapStandardException( StandardException.plainWrapException( e));
1: 			}
1: 		}
0: 		return defaultHoldability;
1: 	}
1: 
1: 	/*
1: 	** Control methods
1: 	*/
1: 
1: 	public Statement createDuplicateStatement(Connection conn, Statement oldStatement) throws SQLException {
1: 
1: 		Statement newStatement;
1: 		
0: 		if (jdbcLevel == 2)
0: 			newStatement = conn.createStatement(resultSetType, resultSetConcurrency);
0: 		else
0: 			newStatement = conn.createStatement(resultSetType, resultSetConcurrency, resultSetHoldability);
1: 
1: 		setStatementState(oldStatement, newStatement);
1: 
1: 		return newStatement;
1: 	}
1: 
0: 	protected void setStatementState(Statement oldStatement, Statement newStatement) throws SQLException {
1: 		if (cursorName != null)
1: 			newStatement.setCursorName(cursorName);
1: 		if (escapeProcessing != null)
1: 			newStatement.setEscapeProcessing(escapeProcessing.booleanValue());
1: 
1: 		newStatement.setFetchDirection(oldStatement.getFetchDirection());
1: 		newStatement.setFetchSize(oldStatement.getFetchSize());
1: 		newStatement.setMaxFieldSize(oldStatement.getMaxFieldSize());
1: 		newStatement.setMaxRows(oldStatement.getMaxRows());
1: 		newStatement.setQueryTimeout(oldStatement.getQueryTimeout());
1: 	}
1: 
0: 	protected Statement getStatement() throws SQLException {
1: 		return control.getRealStatement();
1: 	}
0: 	protected final ResultSet wrapResultSet(ResultSet rs) {
0: 		return control.wrapResultSet(rs);
1: 	}
1: }
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.jdbc
0:    (C) Copyright IBM Corp. 2003, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.iapi.jdbc;
0: 
0: import org.apache.derby.iapi.reference.JDBC30Translation;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.error.PublicAPI;
0: 
0: import java.sql.Connection;
0: import java.sql.ResultSet;
0: import java.sql.SQLException;
0: import java.sql.SQLWarning;
0: import java.sql.Statement;
0: 
0: import java.lang.reflect.*;
0: 
0: /**
0: 	A Statement implementation that forwards all of its requests to an underlying Statement.
0:  */
0: public class BrokeredStatement implements Statement
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 
0:     private static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2003_2004;
0: 
0: 	/**
0: 		My control.
0: 	*/
0: 	protected final BrokeredStatementControl control;
0: 
0: 	protected final int jdbcLevel;
0: 	protected final int resultSetType;
0: 	protected final int resultSetConcurrency;
0: 	protected final int resultSetHoldability;
0: 
0: 	/**
0: 		My state
0: 	*/
0: 	private String cursorName;
0: 	private Boolean escapeProcessing;
0: 
0:     protected BrokeredStatement(BrokeredStatementControl control, int jdbcLevel) throws SQLException
0:     {
0: 		this.control = control;
0: 		this.jdbcLevel = jdbcLevel;
0: 
0: 		// save the state of the Statement while we are pretty much guaranteed the
0: 		// underlying statement is open.
0: 		resultSetType = getResultSetType();
0: 		resultSetConcurrency = getResultSetConcurrency();
0: 
0: 		resultSetHoldability = getResultSetHoldability();
0:     }
0: 
0: 
0:     public final void addBatch(String sql)
0:               throws SQLException
0:     {
0: 		getStatement().addBatch( sql);
0: 	}
0: 
0:     public final void clearBatch()
0:         throws SQLException
0:     {
0:            getStatement().clearBatch();
0: 	}
0: 
0:     public final int[] executeBatch()
0:         throws SQLException
0:     {
0: 		return getStatement().executeBatch();
0: 	}
0: 
0: 
0:     public final void cancel()
0:         throws SQLException
0:     {
0:         getStatement().cancel();
0:     }
0: 
0:     public final boolean execute(String sql) throws SQLException
0: 	{
0: 		control.checkHoldCursors(resultSetHoldability);
0: 		return getStatement().execute(sql);
0:     } 
0: 
0:     public final ResultSet executeQuery(String sql) throws SQLException
0: 	{
0: 		control.checkHoldCursors(resultSetHoldability);
0: 		return wrapResultSet(getStatement().executeQuery(sql));
0:     }
0: 
0:     public final int executeUpdate(String sql) throws SQLException
0: 	{
0: 		return getStatement().executeUpdate(sql);
0:     }
0: 
0:         
0:     /**
0:      * In many cases, it is desirable to immediately release a
0:      * Statements's database and JDBC resources instead of waiting for
0:      * this to happen when it is automatically closed; the close
0:      * method provides this immediate release.
0:      *
0:      * <P><B>Note:</B> A Statement is automatically closed when it is
0:      * garbage collected. When a Statement is closed its current
0:      * ResultSet, if one exists, is also closed.
0: 	 * @exception SQLException thrown on failure.
0:      */
0: 	public final void close() throws SQLException
0:     {
0: 		getStatement().close();
0:     }
0: 
0:     public final Connection getConnection()
0:         throws SQLException
0:     {
0: 		return getStatement().getConnection();
0: 	}
0: 
0:     public final int getFetchDirection()
0:         throws SQLException
0:     {
0: 		return getStatement().getFetchDirection();
0: 	}
0: 
0:     public final int getFetchSize()
0:         throws SQLException
0:     {
0: 		return getStatement().getFetchSize();
0: 	}
0: 
0:     public final int getMaxFieldSize()
0:         throws SQLException
0:     {
0: 		return getStatement().getMaxFieldSize();
0: 	}
0: 
0:     public final int getMaxRows()
0:         throws SQLException
0:     {
0: 		return getStatement().getMaxRows();
0: 	}
0: 
0:     public final int getResultSetConcurrency()
0:         throws SQLException
0:     {
0: 		return getStatement().getResultSetConcurrency();
0: 	}
0: 
0:     /**
0:      * The maxFieldSize limit (in bytes) is set to limit the size of
0:      * data that can be returned for any column value; it only applies
0:      * to BINARY, VARBINARY, LONGVARBINARY, CHAR, VARCHAR, and
0:      * LONGVARCHAR fields.  If the limit is exceeded, the excess data
0:      * is silently discarded.
0:      *
0:      * @param max the new max column size limit; zero means unlimited
0: 	 * @exception SQLException thrown on failure.
0:      */
0: 	public final void setMaxFieldSize(int max) throws SQLException
0:     {
0:         getStatement().setMaxFieldSize(max);
0: 	}
0: 
0:     /**
0:      * The maxRows limit is set to limit the number of rows that any
0:      * ResultSet can contain.  If the limit is exceeded, the excess
0:      * rows are silently dropped.
0:      *
0:      * @param max the new max rows limit; zero means unlimited
0: 	 * @exception SQLException thrown on failure.
0:      */
0: 	public final void setMaxRows(int max) throws SQLException	
0: 	{
0:         getStatement().setMaxRows( max);
0:     }
0: 
0:     /**
0:      * If escape scanning is on (the default) the driver will do
0:      * escape substitution before sending the SQL to the database.
0:      *
0:      * @param enable true to enable; false to disable
0: 	 * @exception SQLException thrown on failure.
0:      */
0: 	public final void setEscapeProcessing(boolean enable) throws SQLException
0:     {
0:         getStatement().setEscapeProcessing( enable);
0: 		escapeProcessing = enable ? Boolean.TRUE : Boolean.FALSE;
0: 	}
0: 
0:     /**
0:      * The first warning reported by calls on this Statement is
0:      * returned.  A Statment's execute methods clear its SQLWarning
0:      * chain. Subsequent Statement warnings will be chained to this
0:      * SQLWarning.
0:      *
0:      * <p>The warning chain is automatically cleared each time
0:      * a statement is (re)executed.
0:      *
0:      * <P><B>Note:</B> If you are processing a ResultSet then any
0:      * warnings associated with ResultSet reads will be chained on the
0:      * ResultSet object.
0:      *
0:      * @return the first SQLWarning or null
0: 	 * @exception SQLException thrown on failure.
0:      */
0: 	public final SQLWarning getWarnings() throws SQLException
0:     {
0: 		return getStatement().getWarnings();
0: 	}
0: 
0:     /**
0:      * After this call getWarnings returns null until a new warning is
0:      * reported for this Statement.
0: 	 * @exception SQLException thrown on failure.
0:      */
0: 	public final void clearWarnings() throws SQLException
0:     {
0: 		getStatement().clearWarnings();
0:     }
0: 
0:     /**
0:      * setCursorName defines the SQL cursor name that will be used by
0:      * subsequent Statement execute methods. This name can then be
0:      * used in SQL positioned update/delete statements to identify the
0:      * current row in the ResultSet generated by this getStatement().  If
0:      * the database doesn't support positioned update/delete, this
0:      * method is a noop.
0:      *
0:      * <P><B>Note:</B> By definition, positioned update/delete
0:      * execution must be done by a different Statement than the one
0:      * which generated the ResultSet being used for positioning. Also,
0:      * cursor names must be unique within a Connection.
0:      *
0:      * @param name the new cursor name.
0:      */
0: 	public final void setCursorName(String name) throws SQLException
0:     {
0: 		getStatement().setCursorName( name);
0: 		cursorName = name;
0: 	}
0:     
0:     
0:     /**
0:      *  getResultSet returns the current result as a ResultSet.  It
0:      *  should only be called once per result.
0:      *
0:      * @return the current result as a ResultSet; null if the result
0:      * is an update count or there are no more results or the statement
0: 	 * was closed.
0:      * @see #execute
0:      */
0: 	public final ResultSet getResultSet() throws SQLException
0:     {
0:         return wrapResultSet(getStatement().getResultSet());
0:     }
0:     
0:     /**
0:      *  getUpdateCount returns the current result as an update count;
0:      *  if the result is a ResultSet or there are no more results -1
0:      *  is returned.  It should only be called once per result.
0:      *
0:      * <P>The only way to tell for sure that the result is an update
0:      *  count is to first test to see if it is a ResultSet. If it is
0:      *  not a ResultSet it is either an update count or there are no
0:      *  more results.
0:      *
0:      * @return the current result as an update count; -1 if it is a
0:      * ResultSet or there are no more results
0:      * @see #execute
0:      */
0: 	public final int getUpdateCount()	throws SQLException
0:     {
0:         return getStatement().getUpdateCount();
0:     }
0: 
0:     /**
0:      * getMoreResults moves to a Statement's next result.  It returns true if
0:      * this result is a ResultSet.  getMoreResults also implicitly
0:      * closes any current ResultSet obtained with getResultSet.
0:      *
0:      * There are no more results when (!getMoreResults() &&
0:      * (getUpdateCount() == -1)
0:      *
0:      * @return true if the next result is a ResultSet; false if it is
0:      * an update count or there are no more results
0:      * @see #execute
0: 	 * @exception SQLException thrown on failure.
0:      */
0: 	public final boolean getMoreResults() throws SQLException
0:     {
0:         return getStatement().getMoreResults();
0:     }
0: 
0:     /**
0:      * JDBC 2.0
0:      *
0:      * Determine the result set type.
0:      *
0:      * @exception SQLException Feature not implemented for now.
0:      */
0:     public final int getResultSetType()
0: 		throws SQLException 
0: 	{
0:         return getStatement().getResultSetType();
0:     }
0: 
0:     /**
0:      * JDBC 2.0
0:      *
0:      * Give a hint as to the direction in which the rows in a result set
0:      * will be processed. The hint applies only to result sets created
0:      * using this Statement object.  The default value is 
0:      * ResultSet.FETCH_FORWARD.
0:      *
0:      * @param direction the initial direction for processing rows
0:      * @exception SQLException if a database-access error occurs or direction
0:      * is not one of ResultSet.FETCH_FORWARD, ResultSet.FETCH_REVERSE, or
0:      * ResultSet.FETCH_UNKNOWN
0:      */
0:     public final void setFetchDirection(int direction) throws SQLException
0:     {
0:         getStatement().setFetchDirection( direction);
0:     }
0: 
0:     /**
0:      * JDBC 2.0
0:      *
0:      * Give the JDBC driver a hint as to the number of rows that should
0:      * be fetched from the database when more rows are needed.  The number 
0:      * of rows specified only affects result sets created using this 
0:      * getStatement(). If the value specified is zero, then the hint is ignored.
0:      * The default value is zero.
0:      *
0:      * @param rows the number of rows to fetch
0:      * @exception SQLException if a database-access error occurs, or the
0:      * condition 0 <= rows <= this.getMaxRows() is not satisfied.
0:      */
0:     public final void setFetchSize(int rows) throws SQLException
0:     {
0:         getStatement().setFetchSize( rows);
0:     }
0: 
0:     public final int getQueryTimeout()
0:         throws SQLException
0:     {
0:         return getStatement().getQueryTimeout();
0:     }
0: 
0:     public final void setQueryTimeout(int seconds)
0:         throws SQLException
0:     {
0:         getStatement().setQueryTimeout( seconds);
0:     }
0: 
0: 
0: 	/*
0: 	** JDBC 3.0 methods
0: 	*/
0: 	public final boolean execute(String sql,
0:                            int autoGeneratedKeys)
0:         throws SQLException
0:     {
0: 
0:         return  getStatement().execute( sql, autoGeneratedKeys);
0:     }
0: 
0: 
0:     public final boolean execute(String sql,
0:                            int[] columnIndexes)
0:         throws SQLException
0:     {
0:         return getStatement().execute( sql, columnIndexes);
0:     }
0: 
0:     public final boolean execute(String sql,
0:                            String[] columnNames)
0:         throws SQLException
0:     {
0:         return getStatement().execute( sql, columnNames);
0:     }
0: 
0:     public final int executeUpdate(String sql,
0:                            int autoGeneratedKeys)
0:         throws SQLException
0:     {
0:                 int retVal =  getStatement().executeUpdate( sql, autoGeneratedKeys);
0:                 return retVal;
0:     }
0: 
0:     public final int executeUpdate(String sql,
0:                            int[] columnIndexes)
0:         throws SQLException
0:     {
0:              return  getStatement().executeUpdate( sql, columnIndexes);
0:     }
0: 
0:     public final int executeUpdate(String sql,
0:                            String[] columnNames)
0:         throws SQLException
0:     {
0: 
0:         return getStatement().executeUpdate( sql, columnNames);
0:     }
0: 
0: 
0: 
0:     /**
0:      * JDBC 3.0
0:      *
0:      * Moves to this Statement obect's next result, deals with any current ResultSet
0:      * object(s) according to the instructions specified by the given flag, and
0:      * returns true if the next result is a ResultSet object
0:      *
0:      * @param current - one of the following Statement constants indicating what
0:      * should happen to current ResultSet objects obtained using the method
0:      * getResultSetCLOSE_CURRENT_RESULT, KEEP_CURRENT_RESULT, or CLOSE_ALL_RESULTS
0:      * @return true if the next result is a ResultSet; false if it is
0:      * an update count or there are no more results
0:      * @see #execute
0:      * @exception SQLException thrown on failure.
0:      */
0: 	public final boolean getMoreResults(int current) throws SQLException
0:     {
0:         return getStatement().getMoreResults( current);
0: 	}
0: 
0:     /**
0:      * JDBC 3.0
0:      *
0:      * Retrieves any auto-generated keys created as a result of executing this
0:      * Statement object. If this Statement object did not generate any keys, an empty
0:      * ResultSet object is returned. If this Statement is a non-insert statement,
0:      * an exception will be thrown.
0:      *
0:      * @return a ResultSet object containing the auto-generated key(s) generated by
0:      * the execution of this Statement object
0:      * @exception SQLException if a database access error occurs
0:      */
0: 	public final ResultSet getGeneratedKeys() throws SQLException
0:     {
0:         return wrapResultSet(getStatement().getGeneratedKeys());
0:     }
0: 
0: 	public final int getResultSetHoldability()
0:         throws SQLException
0: 	{
0: 		int defaultHoldability = JDBC30Translation.HOLD_CURSORS_OVER_COMMIT;
0: 		if (org.apache.derby.iapi.services.info.JVMInfo.JDK_ID > 2) { //No need to use reflection for jdks 1.4 and higher
0: 			defaultHoldability = getStatement().getResultSetHoldability();
0: 		} else {
0: 			try {
0: 				Method sh = getStatement().getClass().getMethod("getResultSetHoldability", null);
0: 				defaultHoldability = ((Integer)sh.invoke(getStatement(), null)).intValue();
0: 			} catch( Exception e)
0: 			{
0: 				throw PublicAPI.wrapStandardException( StandardException.plainWrapException( e));
0: 			}
0: 		}
0: 		return defaultHoldability;
0: 	}
0: 
0: 	/*
0: 	** Control methods
0: 	*/
0: 
0: 	public Statement createDuplicateStatement(Connection conn, Statement oldStatement) throws SQLException {
0: 
0: 		Statement newStatement;
0: 		
0: 		if (jdbcLevel == 2)
0: 			newStatement = conn.createStatement(resultSetType, resultSetConcurrency);
0: 		else
0: 			newStatement = conn.createStatement(resultSetType, resultSetConcurrency, resultSetHoldability);
0: 
0: 		setStatementState(oldStatement, newStatement);
0: 
0: 		return newStatement;
0: 	}
0: 
0: 	protected void setStatementState(Statement oldStatement, Statement newStatement) throws SQLException {
0: 		if (cursorName != null)
0: 			newStatement.setCursorName(cursorName);
0: 		if (escapeProcessing != null)
0: 			newStatement.setEscapeProcessing(escapeProcessing.booleanValue());
0: 
0: 		newStatement.setFetchDirection(oldStatement.getFetchDirection());
0: 		newStatement.setFetchSize(oldStatement.getFetchSize());
0: 		newStatement.setMaxFieldSize(oldStatement.getMaxFieldSize());
0: 		newStatement.setMaxRows(oldStatement.getMaxRows());
0: 		newStatement.setQueryTimeout(oldStatement.getQueryTimeout());
0: 	}
0: 
0: 	protected Statement getStatement() throws SQLException {
0: 		return control.getRealStatement();
0: 	}
0: 	protected final ResultSet wrapResultSet(ResultSet rs) {
0: 		return control.wrapResultSet(rs);
0: 	}
0: }
============================================================================