1:8b62109: /*
1:8b62109:    Derby - Class LocCompare
1:8b62109: 
1:8b62109:    Licensed to the Apache Software Foundation (ASF) under one or more
1:8b62109:    contributor license agreements.  See the NOTICE file distributed with
1:8b62109:    this work for additional information regarding copyright ownership.
1:8b62109:    The ASF licenses this file to You under the Apache License, Version 2.0
1:8b62109:    (the "License"); you may not use this file except in compliance with
1:8b62109:    the License.  You may obtain a copy of the License at
1:8b62109: 
1:8b62109:       http://www.apache.org/licenses/LICENSE-2.0
1:8b62109: 
1:8b62109:    Unless required by applicable law or agreed to in writing, software
1:8b62109:    distributed under the License is distributed on an "AS IS" BASIS,
1:8b62109:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:8b62109:    See the License for the specific language governing permissions and
1:8b62109:    limitations under the License.
1:8b62109: 
1:8b62109:  */
1:8b62109: 
1:8b62109: 
1:8b62109: import java.io.*;
1:8b62109: import java.util.ArrayList;
1:8b62109: 
1:8b62109: /**
1:8b62109:  * Program that attempts to flag the derby i18n properties files for a variety
1:8b62109:  * of possible and actual problems.
1:8b62109:  * For syntax, see USAGE string ( obtained with -h)
1:8b62109:  * For further info, see readme file 
1:8b62109:  *
1:8b62109:  */
1:8b62109: public class LocCompare {
1:8b62109: 
1:8b62109: 	private static StringBuffer strbuf;
1:8b62109: 	private static boolean interesting;
1:8b62109: 	
1:8b62109:     private static String USAGE=
1:8b62109:     	"USAGE: \n java \n  [-Dderbysvntop=<svntop>] [-Dtranslations=<newloc>] LocCompare [<territories>][?|-h]\n" +
1:8b62109:     	"  where \n" +
1:8b62109:     	"     svntop      = top of derby svn tree for branch or trunk \n" +
1:8b62109:     	"                   default is current dir is the top\n" +
1:8b62109:     	"     newloc      = temporary location for translated files \n" +
1:8b62109:     	"                   drda locale files are expected in a subdir 'drda'\n" +
1:8b62109:     	"                   default is same file structure as for the english files\n" +
1:8b62109:     	"     territories = one translated territories, or 'all' \n" +
1:8b62109:     	"                   where all means: \n" +
1:8b62109:     	"                      {cs,de_DE,es,fr,hu,it,ja_JP,ko_KR,pl,pt_BR,ru,zh_CN,zh_TW}\n" +
1:8b62109:     	"     ?|-h        = you can pass on -h or ? to get this message\n" +
1:8b62109:     	"\n" +
1:8b62109:     	"   you can also pass -Dtvtdebug=true in to see more comments.";
1:8b62109: 	
1:8b62109: 	public static void main(String[] args) {
1:8b62109: 		// some args checking and usage.
1:8b62109: 		String curdir = System.getProperty("user.home");
1:8b62109: 		String svntop = curdir;
1:8b62109: 		String locnewlocfiles = curdir;
1:8b62109: 		String languages[] = {"cs","de_DE","es","fr","hu","it","ja_JP","ko_KR","pl","pt_BR","ru","zh_CN","zh_TW"};
1:8b62109: 		if (args.length == 0) // no arguments, will assume currentdir for loc files
1:8b62109: 			curdir = System.getProperty("user.home");
1:8b62109: 		else if ((args.length >2) || (args[0].equals("?") || (args[0].startsWith("-h"))))
1:8b62109: 		{
1:8b62109: 			System.out.println(USAGE);
1:8b62109: 			return;
1:8b62109: 		}
1:8b62109: 		else if ((args.length==1) && (!args[0].equals("all")))
1:8b62109: 		{
1:8b62109: 			languages = new String[1];
1:8b62109: 			languages[0] = args[0];
1:8b62109: 		}
1:8b62109: 		
1:8b62109: 		if (System.getProperty("derbysvntop") == null )
1:8b62109: 			chatterMsg("assuming start from current dir - if not, run with -h for info\n");
1:8b62109: 		else
1:8b62109: 			svntop = System.getProperty("derbysvntop");
1:8b62109: 	
1:8b62109: 		boolean temporaryfiles = false;	
1:8b62109: 		if (System.getProperty("translations") == null )
1:8b62109: 		{
1:8b62109: 			chatterMsg("comparing files in same locations as english message files\n");
1:8b62109: 		}	
1:8b62109: 		else
1:8b62109: 		{
1:8b62109: 			temporaryfiles = true;
1:8b62109: 			locnewlocfiles = System.getProperty("translations");
1:8b62109: 		}
1:8b62109: 		
1:8b62109: 		// making assumptions about the paths and filenames
1:8b62109: 		String ext = ".properties";
1:8b62109: 		String[] typefiles = {"messages_","sysinfoMessages_","toolsmessages_"};
1:8b62109: 		String[] drdatypefiles = {"messages_","servlet_"};
1:8b62109: 		
1:8b62109: 		String englishPath = svntop + "/java/engine/org/apache/derby/loc/";
1:8b62109: 		String english = "en";
1:8b62109: 		String englishDrdaPath = svntop + "/java/drda/org/apache/derby/loc/drda/";
1:8b62109: 		String englishToolsPath = svntop + "/java/tools/org/apache/derby/loc/";
1:8b62109: 	
1:8b62109: 		String forLangPath = svntop + "/java/engine/org/apache/derby/loc/";
1:8b62109: 		String forDrdaPath = svntop + "/java/drda/org/apache/derby/loc/drda/";
1:8b62109: 		String forToolsPath = svntop + "/java/tools/org/apache/derby/loc/";
1:8b62109: 		if ( temporaryfiles )	
1:8b62109: 		{
1:8b62109: 			forLangPath = locnewlocfiles + "/";
1:8b62109: 			forDrdaPath = locnewlocfiles + "/drda/";
1:8b62109: 			forToolsPath = locnewlocfiles + "/";
1:8b62109: 		}
1:8b62109: 		
1:8b62109: 		String EnglishFileName;
1:8b62109: 		String ForeignFileNameString;
1:8b62109: 		String ForeignFileName="";
1:8b62109: 
1:8b62109: 		// first find the apprioriate embedded messages
1:8b62109: 		for (int i=0; i< typefiles.length; i++)
1:8b62109: 		{
1:8b62109: 			if (( typefiles[i].equals("sysinfoMessages_")) || (typefiles[i].equals("toolsmessages_")))
1:8b62109: 			{
1:8b62109: 				EnglishFileName=englishToolsPath + typefiles[i].substring(0,(typefiles[i].length()-1)) + ext;
1:8b62109: 				if (checkExistsFile(EnglishFileName) == false)
1:8b62109: 				{	
1:8b62109: 					System.out.println(" English file does not exist: \n  " + EnglishFileName);
1:8b62109: 					continue;
1:8b62109: 				}
1:8b62109: 				ForeignFileNameString=forToolsPath + typefiles[i];
1:8b62109: 			}
1:8b62109: 			else	
1:8b62109: 			{
1:8b62109: 				EnglishFileName=englishPath + typefiles[i] + english + ext;
1:8b62109: 				if (checkExistsFile(EnglishFileName) == false)
1:8b62109: 				{
1:8b62109: 					System.out.println(" English file does not exist: \n  " + EnglishFileName);
1:8b62109: 					continue;
1:8b62109: 				}
1:8b62109: 				ForeignFileNameString=forLangPath + typefiles[i];
1:8b62109: 			}
1:8b62109: 			for (int j=0; j < languages.length; j++)
1:8b62109: 			{
1:8b62109: 				String ForeignFileNametmp = ForeignFileNameString + languages[j] + ext;
1:8b62109: 				if (checkExistsFile(ForeignFileNametmp) == false)
1:8b62109: 				{
1:8b62109: 					System.out.println(" Translated file does not exist: \n  " + ForeignFileNametmp);
1:8b62109: 					continue;
1:8b62109: 				}
1:8b62109: 				ForeignFileName=ForeignFileNametmp;
1:8b62109: 				System.out.println("********************************************* ");
1:8b62109: 				System.out.println("********************************************* ");
1:8b62109: 				System.out.println("Now comparing \n < " + EnglishFileName +
1:8b62109: 						"\n > " + ForeignFileName);
1:8b62109: 				compare(EnglishFileName, ForeignFileName, languages[j]);
1:8b62109: 			}
1:8b62109: 		}
1:8b62109: 		
1:8b62109: 		// now compare the drda messages
1:8b62109: 		for (int i=0; i< drdatypefiles.length; i++)
1:8b62109: 		{
1:8b62109: 			EnglishFileName=englishDrdaPath + drdatypefiles[i] + english + ext;
1:8b62109: 			if (checkExistsFile(EnglishFileName) == false)
1:8b62109: 			{
1:8b62109: 				System.out.println(" English file does not exist: \n  " + EnglishFileName);
1:8b62109: 				continue;
1:8b62109: 			}
1:8b62109: 			for (int j=0; j < languages.length; j++)
1:8b62109: 			{
1:8b62109: 				ForeignFileName=forDrdaPath + drdatypefiles[i] + languages[j] + ext;
1:8b62109: 				if (checkExistsFile(ForeignFileName) == false)
1:8b62109: 				{
1:8b62109: 					System.out.println(" Translated file does not exist: \n  " + ForeignFileName);
1:8b62109: 					continue;
1:8b62109: 				}
1:8b62109: 				System.out.println(" ********************************************* ");
1:8b62109: 				System.out.println(" ********************************************* ");
1:8b62109: 				System.out.println("Now comparing \n < " + EnglishFileName +
1:8b62109: 						"\n > " + ForeignFileName);
1:8b62109: 				compare(EnglishFileName, ForeignFileName, languages[j]);
1:8b62109: 			}
1:8b62109: 		}
1:8b62109: 	}
1:8b62109: 	
1:8b62109: 	public static void compare(String englishFileName, String foreignFileName, String langcode){
1:8b62109: 		String openBrace="{";
1:8b62109: 		String closeBrace="}";
1:8b62109: 		String apostrophe="'";
1:8b62109: 		
1:8b62109: 				try {
1:8b62109: 			BufferedReader englishR = new BufferedReader(
1:8b62109: 					new InputStreamReader(new FileInputStream(englishFileName), "UTF8"));
1:8b62109: 			BufferedReader foreignR = new BufferedReader(
1:8b62109: 					new InputStreamReader(new FileInputStream(foreignFileName), "UTF8"));
1:8b62109: 			
1:8b62109: 			int i=0;
1:8b62109: 			String englishStr;
1:8b62109: 			String foreignStr;
1:8b62109: 			
1:8b62109: 			while ((englishStr = englishR.readLine())!=null)
1:8b62109: 			{
1:8b62109: 				i++;
1:8b62109: 				interesting = false;
1:8b62109: 				// first position English on a message
1:8b62109: 				// note that this means we're only checking the first
1:8b62109: 				// line of each message...After that, we can't be sure
1:8b62109: 				// how long the messages are. 
1:8b62109: 				// An improvement would be to string all text found after a line
1:8b62109: 				// ending in '\' together and compare the whole thing. 
1:8b62109: 				// But the readLine reads \ lines as null...
1:8b62109: 				
1:8b62109: 				if ((englishStr.indexOf("=") < 0) ||
1:8b62109: 					(englishStr.indexOf("#")>=0)   || 
1:8b62109: 					(englishStr.indexOf("user=usr")>0)) // may be url syntax
1:8b62109: 					continue;
1:8b62109: 				String englishError = "";
1:8b62109: 				String foreignError = "";
1:8b62109: 				
1:8b62109: 				englishError = englishStr.substring(0,englishStr.indexOf("="));				
1:8b62109: 				
1:8b62109: 				foreignStr = lookForForeignErrorString(foreignR, englishError, langcode);
1:8b62109: 				if (foreignStr == null)
1:8b62109: 				{
1:8b62109: 					logMsg("  ===============");
1:8b62109: 					String spacingforformat = "";
1:8b62109: 					if (langcode.length()>2)
1:8b62109: 						spacingforformat = "   ";
1:8b62109: 					logMsg("  " + spacingforformat + "en: < " + englishStr);
1:8b62109: 					logMsg("  " + langcode + ": > ------- No translation found");
1:8b62109: 					interesting = true;
1:8b62109: 					// reset foreign reader to top
1:8b62109: 					foreignR = new BufferedReader(
1:8b62109: 						new InputStreamReader(new FileInputStream(foreignFileName), "UTF8"));	
1:8b62109: 					continue;
1:8b62109: 				}
1:8b62109: 				else
1:8b62109: 				{
1:8b62109: 					// theoretically, we should now be at the same error.
1:8b62109: 					//chatterMsg("\tMessage: " + englishError + "(en), found match") ;
1:8b62109: 					logMsg("  ===============");
1:8b62109: 					String spacingforformat = "";
1:8b62109: 					if (langcode.length()>2)
1:8b62109: 						spacingforformat = "   ";
1:8b62109: 					logMsg("  " + spacingforformat + "en: < " + englishStr);
1:8b62109: 					logMsg("  " + langcode + ": > " + foreignStr);
1:8b62109: 					
1:8b62109: 					checkISO8559(foreignStr);
1:8b62109: 				
1:8b62109: 					// just for fun, compare occurrences of some unusual characters:				
1:8b62109: 					int count = countAndCompareCountCharacter(
1:8b62109: 						englishStr, foreignStr, "%", englishError);
1:8b62109: 					// let's not check for , it is a language specific construct
1:8b62109: 					// count = countAndCompareCountCharacter(
1:8b62109: 					//		englishStr, foreignStr, ",", englishError);
1:8b62109: 					count = countAndCompareCountCharacter(
1:8b62109: 						englishStr, foreignStr, ";", englishError);
1:8b62109: 					count = countAndCompareCountCharacter(
1:8b62109: 						englishStr, foreignStr, ":", englishError);
1:8b62109: 					count = countAndCompareCountCharacter(
1:8b62109: 						englishStr, foreignStr, "_", englishError);
1:8b62109: 					count = countAndCompareCountCharacter(
1:8b62109: 						englishStr, foreignStr, "=", englishError);
1:8b62109: 					count = countAndCompareCountCharacter(
1:8b62109: 						englishStr, foreignStr, "(", englishError);
1:8b62109: 					count = countAndCompareCountCharacter(
1:8b62109: 						englishStr, foreignStr, ")", englishError);
1:8b62109: 					count = countAndCompareCountCharacter(
1:8b62109: 						englishStr, foreignStr, "+", englishError);
1:8b62109: 					// let's not check for -, it is a language specific construct
1:8b62109: 					// count = countAndCompareCountCharacter(
1:8b62109: 					//		englishStr, foreignStr, "-", englishError);
1:8b62109: 					count = countAndCompareCountCharacter(
1:8b62109: 						englishStr, foreignStr, "/", englishError);
1:8b62109: 					count = countAndCompareCountCharacter(
1:8b62109: 						englishStr, foreignStr, "]", englishError);
1:8b62109: 					count = countAndCompareCountCharacter(
1:8b62109: 						englishStr, foreignStr, "[", englishError);
1:8b62109: 					count = countAndCompareCountCharacter(
1:8b62109: 						englishStr, foreignStr, "\"", englishError);	
1:8b62109: 				
1:8b62109: 					// check to see if the errorstring has a {
1:8b62109: 					int countOpen = countAndCompareCountCharacter(
1:8b62109: 						englishStr, foreignStr, openBrace, englishError);
1:8b62109: 					// then check to see if the errorstring has a } 
1:8b62109: 					int countClose = countAndCompareCountCharacter(
1:8b62109: 						englishStr, foreignStr, closeBrace, englishError);
1:8b62109: 					if ((countOpen <0) || (countClose <0))
1:8b62109: 					{
1:8b62109: 						// we have a mismatch between the languages should already have seen an error
1:8b62109: 						continue;
1:8b62109: 					}			
1:8b62109: 					if (countOpen != countClose)
1:8b62109: 					{	
1:8b62109: 						logMsg("\t FAILURE!!! - unmatched braces");
1:8b62109: 						interesting = true;
1:8b62109: 						continue;
1:8b62109: 					}
1:8b62109: 					// now check that the parameter numbers encircled by the braces are matching
1:8b62109: 					compareParameterSequenceNumbers(englishStr, foreignStr, countOpen, englishError);
1:8b62109: 
1:8b62109: 					// now, for the toolsmessages files, if we do not have replacements,
1:8b62109: 					// in theory there is no need for double single quotes. 
1:8b62109: 					// For all other files, single quotes need to be doubled
1:8b62109: 					// So, check for apostropes
1:8b62109: 					if ((englishFileName.indexOf("tools")>0) ||
1:8b62109: 						(foreignFileName.indexOf("tools")>0))
1:8b62109: 					{
1:8b62109: 						if ((countOpen == 0) || (countClose == 0))
1:8b62109: 						{
1:8b62109: 							lookAtSingleQuotes(englishStr, apostrophe, englishError, englishFileName, "in English String");
1:8b62109: 							lookAtSingleQuotes(foreignStr, apostrophe, foreignError, foreignFileName, "in translated String");
1:8b62109: 						}
1:8b62109: 						else if ((countOpen == countClose) && (countOpen > 0))
1:8b62109: 						{
1:8b62109: 							// except for strings with replacements in toolsmessages files
1:8b62109: 							// all apostrophes *must* get doubled.
1:8b62109: 							if ((englishStr.indexOf(apostrophe) < 0) && (foreignStr.indexOf(apostrophe) < 0))
1:8b62109: 							{
1:8b62109: 								continue;
1:8b62109: 							}
1:8b62109: 							else
1:8b62109: 							{
1:8b62109: 								lookAtDoubleQuotes(englishStr, apostrophe, englishError, englishFileName, "in English String");
1:8b62109: 								lookAtDoubleQuotes(foreignStr, apostrophe, foreignError, foreignFileName, "in translated String");
1:8b62109: 							}
1:8b62109: 						}
1:8b62109: 					}
1:8b62109: 					else // just check that the quotes are doubled
1:8b62109: 					{
1:8b62109: 						lookAtDoubleQuotes(englishStr, apostrophe, englishError, englishFileName, "in English String");
1:8b62109: 						lookAtDoubleQuotes(foreignStr, apostrophe, foreignError, foreignFileName, "in translated String");
1:8b62109: 					}
1:8b62109: 					// last automated check is to find strings
1:8b62109: 					// with all capitals and compare....
1:8b62109: 					compareUpperCaseStrings(englishStr, foreignStr, englishError, foreignFileName);
1:8b62109: 					
1:8b62109: 					if ((strbuf!=null) && (strbuf.length() >0) && interesting)
1:8b62109: 						System.out.println(strbuf);
1:8b62109: 					strbuf=null;
1:8b62109: 					
1:8b62109: 				}
1:8b62109: 			}
1:8b62109: 		} catch (UnsupportedEncodingException e) {
1:8b62109: 		} catch (IOException e) {
1:8b62109: 		}
1:8b62109: 	}
1:8b62109: 	
1:8b62109: 	/**
1:8b62109: 	 * 
1:8b62109: 	 * @param englishStr
1:8b62109: 	 * @param foreignStr
1:8b62109: 	 * @param Character
1:8b62109: 	 * @return 0 if the character does not occur at all
1:8b62109: 	 *         -1 if there is a difference between English and translation
1:8b62109: 	 *         #>0 indicating the number of occurrences of the character
1:8b62109: 	 */
1:8b62109: 	public static int countAndCompareCountCharacter(
1:8b62109: 			String englishStr, String foreignStr, String Character, String englishError)
1:8b62109: 	{
1:8b62109: 		if (englishStr.indexOf(Character)< 0)
1:8b62109: 			return 0;
1:8b62109: 		else { // (if character exists)
1:8b62109: 			//then compare the number of occurrences per line
1:8b62109: 			int noCharE=0;
1:8b62109: 			int noCharF=0;
1:8b62109: 			noCharE = countCharacter(englishStr, Character);
1:8b62109: 			noCharF = countCharacter(foreignStr, Character);
1:8b62109: 			if (noCharE!=noCharF)
1:8b62109: 			{
1:8b62109: 				logMsg("\t WARNING - not the same number of the character " + Character);
1:8b62109: 				interesting = true;
1:8b62109: 				return -1;
1:8b62109: 			}
1:8b62109: 			else
1:8b62109: 			{	
1:8b62109: 				chatterMsg("\t\tsame number of the character " + Character + ", namely, :" + noCharE);
1:8b62109: 				return noCharE;
1:8b62109: 			}
1:8b62109: 		}
1:8b62109: 	}
1:8b62109: 	
1:8b62109: 	/**
1:8b62109: 	 * 
1:8b62109: 	 * @param englishStr
1:8b62109: 	 * @param foreignStr
1:8b62109: 	 * @param Character
1:8b62109: 	 * @return 0 if the character does not occur at all
1:8b62109: 	 *         -1 if there is a difference between English and translation
1:8b62109: 	 *         #>0 indicating the number of occurrences of the character
1:8b62109: 	 */
1:8b62109: 	public static int countCharacter(String Str, String Character)
1:8b62109: 	{
1:8b62109: 		if (Str.indexOf(Character)< 0)
1:8b62109: 			return 0;
1:8b62109: 		else { // (if character exists)
1:8b62109: 		//then compare the number of occurrences per line
1:8b62109: 			String tmpstr = Str;
1:8b62109: 			int noChar=0;
1:8b62109: 			for (int k=0; k<Str.length() ; k++){
1:8b62109: 				if (tmpstr.indexOf(Character) >= 0)
1:8b62109: 					noChar++;
1:8b62109: 					tmpstr = tmpstr.substring(tmpstr.indexOf(Character)+1);
1:8b62109: 			}
1:8b62109: 			return noChar;
1:8b62109: 		}
1:8b62109: 	}
1:8b62109: 	
1:8b62109: 	public static void compareParameterSequenceNumbers(
1:8b62109: 			String englishStr, String foreignStr, int NumberOfParameters, String englishError)
1:8b62109: 	{
1:8b62109: 		for ( int i=0 ; i < NumberOfParameters; i++)
1:8b62109: 		{
1:8b62109: 			int eindex1 = englishStr.indexOf("{");
1:8b62109: 			int findex1 = foreignStr.indexOf("{");
1:8b62109: 			int eindex2 = englishStr.indexOf("}");
1:8b62109: 			int findex2 = foreignStr.indexOf("}");
1:8b62109: 			String englishSubStr1 = englishStr.substring(eindex1+1, eindex2);
1:8b62109: 			String foreignSubStr1 = foreignStr.substring(findex1+1, findex2);
1:8b62109: 			chatterMsg("\t\tcomparing english parameter or string substr: " + englishSubStr1 + " with translated substr " + foreignSubStr1);
1:8b62109: 			if (!englishSubStr1.equals(foreignSubStr1))
1:8b62109: 			{
1:8b62109: 				logMsg("\t WARNING - not the same parameter or string in brackets");
1:8b62109: 				interesting = true;
1:8b62109: 			}
1:8b62109: 			englishStr=englishStr.substring(eindex2+1);
1:8b62109: 			foreignStr=foreignStr.substring(findex2+1);
1:8b62109: 		}
1:8b62109: 	}	
1:8b62109: 	
1:8b62109: 	/**
1:8b62109: 	 * check that strings without replacements only have
1:8b62109: 	 * single quotes 
1:8b62109: 	 * Note that we're passing in 'Character' but it's really only
1:8b62109: 	 * thought about for quotes.
1:8b62109: 	 * If the apostrophes are doubled, flag a warning.
1:8b62109: 	 * Note that it may still be ok, we just want to know.
1:8b62109: 	 * This is only relevant in the toolsmessages files.	
1:8b62109: 	 * 
1:8b62109: 	 */
1:8b62109: 	private static void lookAtSingleQuotes (
1:8b62109: 			String Str, String Character, String Error, String FileName, String print ) 
1:8b62109: 	{
1:8b62109: 		String tmpStr = Str;
1:8b62109: 		int countOfCharacter = countCharacter(tmpStr, Character);
1:8b62109: 		//chatterMsg("\t\t\tcountOfCharacter for " + Character + " is: " + countOfCharacter);
1:8b62109: 		if (countOfCharacter < 0)
1:8b62109: 			return;
1:8b62109: 		for (int m=0 ; m < countOfCharacter ; m++)
1:8b62109: 		{
1:8b62109: 			int index1 = Str.indexOf("'");
1:8b62109: 			String SubStr1 = Str.substring(index1 +1);
1:8b62109: 			int index2 = SubStr1.indexOf("'");
1:8b62109: 			if (index2 < 0)  
1:8b62109: 				return; // we're done
1:8b62109: 			if (index2 == 0) // it *is* right after!
1:8b62109: 			{
1:8b62109: 				logMsg("\t WARNING - double quotes in String without replacements");
1:8b62109: 				interesting = true;
1:8b62109: 			}
1:8b62109: 			else
1:8b62109: 				chatterMsg("\t\t" + print + " found: " + countOfCharacter + " single quotes");
1:8b62109: 			tmpStr = SubStr1;
1:8b62109: 		}
1:8b62109: 	}
1:8b62109: 
1:8b62109: 	/**
1:8b62109: 	 * check that strings have doubled quotes.
1:8b62109: 	 * Note that we're passing in 'Character' but it's really only
1:8b62109: 	 * thought about for quotes/apostrophes.
1:8b62109: 	 * If the apostrophes are single FAIL, not OK. (except for tools)	
1:8b62109: 	 * Note that we already know there *are* quotes in the string
1:8b62109: 	 * 
1:8b62109: 	 */
1:8b62109: 	private static void lookAtDoubleQuotes (
1:8b62109: 			String Str, String Character, String Error, String FileName, String print ) 
1:8b62109: 	{
1:8b62109: 		int countOfCharacter = countCharacter(Str, Character);
1:8b62109: 		if (countOfCharacter % 2 == 1)
1:8b62109: 		{
1:8b62109: 			logMsg("\t WARNING - found single single quotes - quotes need to be doubled");
1:8b62109: 			interesting = true;
1:8b62109: 		}
1:8b62109: 		else
1:8b62109: 			chatterMsg(" \t\t" + print + " found: " + (countOfCharacter / 2) + " double quotes");
1:8b62109: 	}
1:8b62109: 	
1:8b62109: 	public static void compareUpperCaseStrings(String englishStr, String foreignStr, String Error, String FileName)
1:8b62109: 	{
1:8b62109: 		// first check to see if there are any strings with 
1:8b62109: 		// more than one uppercase.
1:8b62109: 		ArrayList englishArray = findUpperCaseStrings(englishStr);
1:8b62109: 		ArrayList foreignArray = findUpperCaseStrings(foreignStr);
1:8b62109: 		if ((englishArray == null) && (foreignArray==null))
1:8b62109: 		{
1:8b62109: 			chatterMsg("no such character in string");
1:8b62109: 			return;
1:8b62109: 		}
1:8b62109: 		else if ((englishArray == null) || (foreignArray == null))
1:8b62109: 		{
1:8b62109: 			logMsg("\t FAILURE!!! - not the same number of Uppercase strings, one has none, the other something");
1:8b62109: 			interesting = true;
1:8b62109: 			return;
1:8b62109: 		}
1:8b62109: 		if (englishArray.size() != foreignArray.size())
1:8b62109: 		{
1:8b62109: 			logMsg("\t FAILURE!!! - not the same number of Uppercase strings");
1:8b62109: 			interesting = true;
1:8b62109: 		}
1:8b62109: 		else
1:8b62109: 		{
1:8b62109: 			for (int i=0; i < englishArray.size(); i++)
1:8b62109: 			{
1:8b62109: 				if (!englishArray.get(i).equals(foreignArray.get(i)))
1:8b62109: 				{
1:8b62109: 					logMsg("\t WARNING - difference in Uppercase strings");
1:8b62109: 					interesting = true;
1:8b62109: 				}
1:8b62109: 				else 
1:8b62109: 					chatterMsg("\t\tsuccessfully compared " + englishArray.get(i));
1:8b62109: 			}
1:8b62109: 		}
1:8b62109: 	}
1:8b62109: 	
1:8b62109: 	/**
1:8b62109: 	 * 
1:8b62109: 	 * Find uppercase strings in a string passed in
1:8b62109: 	 */
1:8b62109: 	public static ArrayList findUpperCaseStrings(String Strin)
1:8b62109: 	{
1:8b62109: 		ArrayList StrArr = new ArrayList(); // for out
1:8b62109: 		StringBuffer buf = new StringBuffer();
1:8b62109: 
1:8b62109: 		int length = Strin.length();
1:8b62109: 		for ( int upperIdx = 0 ; upperIdx < length ; ++upperIdx )
1:8b62109: 		{
1:8b62109: 			char ch = Strin.charAt( upperIdx );
1:8b62109: 			if ((buf == null) || (buf.length() == 0))
1:8b62109: 			{
1:8b62109: 				buf = new StringBuffer();
1:8b62109: 				if (Character.isUpperCase(ch))
1:8b62109: 					buf.append(ch);
1:8b62109: 			}
1:8b62109: 			else if (buf.length() == 1)
1:8b62109: 			{
1:8b62109: 				if (Character.isUpperCase(ch))
1:8b62109: 					buf.append(ch);
1:8b62109: 				else 
1:8b62109: 					buf = null; // never mind
1:8b62109: 			}
1:8b62109: 			else
1:8b62109: 			{
1:8b62109: 				if (Character.isUpperCase(ch))
1:8b62109: 					buf.append(ch);
1:8b62109: 				else
1:8b62109: 				{
1:8b62109: 					StrArr.add(buf.toString());
1:8b62109: 					buf = null;
1:8b62109: 				}
1:8b62109: 			}
1:8b62109: 		}
1:8b62109: 		return StrArr;
1:8b62109: 	}
1:8b62109: 	
1:8b62109: 	/**
1:8b62109: 	 * Check for characters in the range 0x00-0x1f (which are ASCII) and 0x7f-0xff
1:8b62109: 	 * If found, suggest native2ascii modification of file
1:8b62109: 	 */
1:8b62109: 	private static void checkISO8559(String lineRead){
1:8b62109: 		int numchars = lineRead.length();
1:8b62109: 		for (int i = 0 ; i < numchars ; i++) 
1:8b62109: 		{
1:8b62109: 		      int c = lineRead.charAt(i);
1:8b62109: 		      if (((c >= 0x0000) && (c <= 0x1F)) || ((c >= 0x7F) && c <= 0XFF ))
1:8b62109: 		      {
1:8b62109: 		    	  logMsg("\t FAILURE: encountered non-ISO8559-1 character");
1:8b62109: 		    	  logMsg("\t please run: native2ascii -encoding UTF-8 on this file");
1:8b62109: 		    	  interesting = true;
1:8b62109: 		      }
1:8b62109: 		}
1:8b62109: 	}
1:8b62109: 	
1:8b62109: 	
1:8b62109: 	/**
1:8b62109: 	 * Check that the file exists
1:8b62109: 	 */
1:8b62109: 	private static boolean checkExistsFile(String FileName){
1:8b62109: 		//chatterMsg(" FileName: " + FileName);
1:8b62109: 		File File = new File(FileName);
1:8b62109: 		if (!File.exists())
1:8b62109: 			return false;
1:8b62109: 		else 
1:8b62109: 			return true;
1:8b62109: 	}
1:8b62109: 	
1:8b62109: 	private static String lookForForeignErrorString (
1:8b62109:     		BufferedReader foreignR, String englishError, String langcode)
1:8b62109:     throws IOException
1:8b62109:     {	
1:8b62109:     	String foreignError="";
1:8b62109: 		String foreignStr="";
1:8b62109: 		while (true)
1:8b62109: 		{
1:8b62109: 			// some messages have only a \, which will be a null string
1:8b62109: 			// If this is the case, try to grab a next line. 
1:8b62109: 			// If that too is null, bail out.
1:8b62109: 			if (foreignStr == null)
1:8b62109: 			{
1:8b62109: 				foreignStr = foreignR.readLine();
1:8b62109: 				// if still null, we must really be at the end.
1:8b62109: 				if (foreignStr == null)
1:8b62109: 				{
1:8b62109: 					// Assume we Reached EOF
1:8b62109: 					return null;
1:8b62109: 				}
1:8b62109: 			}
1:8b62109: 			else if ((foreignStr.indexOf("=")>0) &&
1:8b62109: 				 (foreignStr.indexOf("#")!=0) &&
1:8b62109: 				 (!foreignStr.trim().equals("")))
1:8b62109: 			{
1:8b62109: 				foreignError = foreignStr.substring(0,foreignStr.indexOf("="));
1:8b62109: 				if (foreignError.equals(englishError))
1:8b62109: 				{
1:8b62109: 					return foreignStr;
1:8b62109: 				}
1:8b62109: 			}
1:8b62109: 			foreignStr = foreignR.readLine();
1:8b62109: 		}
1:8b62109: 	}
1:8b62109:     
1:8b62109: 	/**
1:8b62109: 	 * Write message to the standard output.
1:8b62109: 	 */
1:8b62109: 	private static void logMsg(String str)	{
1:8b62109: 		if (strbuf == null)
1:8b62109: 			strbuf = new StringBuffer(str + "\n");
1:8b62109: 		else
1:8b62109: 			strbuf.append(str + "\n");
1:8b62109: 	}
1:8b62109: 
1:8b62109: 	/**
1:8b62109: 	 * Write more messages to the standard output if property tvtdebug is true.
1:8b62109: 	 */
1:8b62109: 	private static void chatterMsg(String str)	{
1:8b62109: 	 	String debug = System.getProperty("tvtdebug");
1:8b62109: 	   	if ((debug!=null) && (debug.equals("true")))
1:8b62109: 	   	{
1:8b62109: 	   		interesting = true;
1:8b62109: 	   		if (strbuf == null)
1:8b62109: 				strbuf = new StringBuffer(str + "\n");
1:8b62109: 			else
1:8b62109: 				strbuf.append(str + "\n");
1:8b62109: 	   	}
1:8b62109: 	}
1:8b62109: }
============================================================================
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:8b62109
/////////////////////////////////////////////////////////////////////////
1: /*
1:    Derby - Class LocCompare
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: 
1: import java.io.*;
1: import java.util.ArrayList;
1: 
1: /**
1:  * Program that attempts to flag the derby i18n properties files for a variety
1:  * of possible and actual problems.
1:  * For syntax, see USAGE string ( obtained with -h)
1:  * For further info, see readme file 
1:  *
1:  */
1: public class LocCompare {
1: 
1: 	private static StringBuffer strbuf;
1: 	private static boolean interesting;
1: 	
1:     private static String USAGE=
1:     	"USAGE: \n java \n  [-Dderbysvntop=<svntop>] [-Dtranslations=<newloc>] LocCompare [<territories>][?|-h]\n" +
1:     	"  where \n" +
1:     	"     svntop      = top of derby svn tree for branch or trunk \n" +
1:     	"                   default is current dir is the top\n" +
1:     	"     newloc      = temporary location for translated files \n" +
1:     	"                   drda locale files are expected in a subdir 'drda'\n" +
1:     	"                   default is same file structure as for the english files\n" +
1:     	"     territories = one translated territories, or 'all' \n" +
1:     	"                   where all means: \n" +
1:     	"                      {cs,de_DE,es,fr,hu,it,ja_JP,ko_KR,pl,pt_BR,ru,zh_CN,zh_TW}\n" +
1:     	"     ?|-h        = you can pass on -h or ? to get this message\n" +
1:     	"\n" +
1:     	"   you can also pass -Dtvtdebug=true in to see more comments.";
1: 	
1: 	public static void main(String[] args) {
1: 		// some args checking and usage.
1: 		String curdir = System.getProperty("user.home");
1: 		String svntop = curdir;
1: 		String locnewlocfiles = curdir;
1: 		String languages[] = {"cs","de_DE","es","fr","hu","it","ja_JP","ko_KR","pl","pt_BR","ru","zh_CN","zh_TW"};
1: 		if (args.length == 0) // no arguments, will assume currentdir for loc files
1: 			curdir = System.getProperty("user.home");
1: 		else if ((args.length >2) || (args[0].equals("?") || (args[0].startsWith("-h"))))
1: 		{
1: 			System.out.println(USAGE);
1: 			return;
1: 		}
1: 		else if ((args.length==1) && (!args[0].equals("all")))
1: 		{
1: 			languages = new String[1];
1: 			languages[0] = args[0];
1: 		}
1: 		
1: 		if (System.getProperty("derbysvntop") == null )
1: 			chatterMsg("assuming start from current dir - if not, run with -h for info\n");
1: 		else
1: 			svntop = System.getProperty("derbysvntop");
1: 	
1: 		boolean temporaryfiles = false;	
1: 		if (System.getProperty("translations") == null )
1: 		{
1: 			chatterMsg("comparing files in same locations as english message files\n");
1: 		}	
1: 		else
1: 		{
1: 			temporaryfiles = true;
1: 			locnewlocfiles = System.getProperty("translations");
1: 		}
1: 		
1: 		// making assumptions about the paths and filenames
1: 		String ext = ".properties";
1: 		String[] typefiles = {"messages_","sysinfoMessages_","toolsmessages_"};
1: 		String[] drdatypefiles = {"messages_","servlet_"};
1: 		
1: 		String englishPath = svntop + "/java/engine/org/apache/derby/loc/";
1: 		String english = "en";
1: 		String englishDrdaPath = svntop + "/java/drda/org/apache/derby/loc/drda/";
1: 		String englishToolsPath = svntop + "/java/tools/org/apache/derby/loc/";
1: 	
1: 		String forLangPath = svntop + "/java/engine/org/apache/derby/loc/";
1: 		String forDrdaPath = svntop + "/java/drda/org/apache/derby/loc/drda/";
1: 		String forToolsPath = svntop + "/java/tools/org/apache/derby/loc/";
1: 		if ( temporaryfiles )	
1: 		{
1: 			forLangPath = locnewlocfiles + "/";
1: 			forDrdaPath = locnewlocfiles + "/drda/";
1: 			forToolsPath = locnewlocfiles + "/";
1: 		}
1: 		
1: 		String EnglishFileName;
1: 		String ForeignFileNameString;
1: 		String ForeignFileName="";
1: 
1: 		// first find the apprioriate embedded messages
1: 		for (int i=0; i< typefiles.length; i++)
1: 		{
1: 			if (( typefiles[i].equals("sysinfoMessages_")) || (typefiles[i].equals("toolsmessages_")))
1: 			{
1: 				EnglishFileName=englishToolsPath + typefiles[i].substring(0,(typefiles[i].length()-1)) + ext;
1: 				if (checkExistsFile(EnglishFileName) == false)
1: 				{	
1: 					System.out.println(" English file does not exist: \n  " + EnglishFileName);
1: 					continue;
1: 				}
1: 				ForeignFileNameString=forToolsPath + typefiles[i];
1: 			}
1: 			else	
1: 			{
1: 				EnglishFileName=englishPath + typefiles[i] + english + ext;
1: 				if (checkExistsFile(EnglishFileName) == false)
1: 				{
1: 					System.out.println(" English file does not exist: \n  " + EnglishFileName);
1: 					continue;
1: 				}
1: 				ForeignFileNameString=forLangPath + typefiles[i];
1: 			}
1: 			for (int j=0; j < languages.length; j++)
1: 			{
1: 				String ForeignFileNametmp = ForeignFileNameString + languages[j] + ext;
1: 				if (checkExistsFile(ForeignFileNametmp) == false)
1: 				{
1: 					System.out.println(" Translated file does not exist: \n  " + ForeignFileNametmp);
1: 					continue;
1: 				}
1: 				ForeignFileName=ForeignFileNametmp;
1: 				System.out.println("********************************************* ");
1: 				System.out.println("********************************************* ");
1: 				System.out.println("Now comparing \n < " + EnglishFileName +
1: 						"\n > " + ForeignFileName);
1: 				compare(EnglishFileName, ForeignFileName, languages[j]);
1: 			}
1: 		}
1: 		
1: 		// now compare the drda messages
1: 		for (int i=0; i< drdatypefiles.length; i++)
1: 		{
1: 			EnglishFileName=englishDrdaPath + drdatypefiles[i] + english + ext;
1: 			if (checkExistsFile(EnglishFileName) == false)
1: 			{
1: 				System.out.println(" English file does not exist: \n  " + EnglishFileName);
1: 				continue;
1: 			}
1: 			for (int j=0; j < languages.length; j++)
1: 			{
1: 				ForeignFileName=forDrdaPath + drdatypefiles[i] + languages[j] + ext;
1: 				if (checkExistsFile(ForeignFileName) == false)
1: 				{
1: 					System.out.println(" Translated file does not exist: \n  " + ForeignFileName);
1: 					continue;
1: 				}
1: 				System.out.println(" ********************************************* ");
1: 				System.out.println(" ********************************************* ");
1: 				System.out.println("Now comparing \n < " + EnglishFileName +
1: 						"\n > " + ForeignFileName);
1: 				compare(EnglishFileName, ForeignFileName, languages[j]);
1: 			}
1: 		}
1: 	}
1: 	
1: 	public static void compare(String englishFileName, String foreignFileName, String langcode){
1: 		String openBrace="{";
1: 		String closeBrace="}";
1: 		String apostrophe="'";
1: 		
1: 				try {
1: 			BufferedReader englishR = new BufferedReader(
1: 					new InputStreamReader(new FileInputStream(englishFileName), "UTF8"));
1: 			BufferedReader foreignR = new BufferedReader(
1: 					new InputStreamReader(new FileInputStream(foreignFileName), "UTF8"));
1: 			
1: 			int i=0;
1: 			String englishStr;
1: 			String foreignStr;
1: 			
1: 			while ((englishStr = englishR.readLine())!=null)
1: 			{
1: 				i++;
1: 				interesting = false;
1: 				// first position English on a message
1: 				// note that this means we're only checking the first
1: 				// line of each message...After that, we can't be sure
1: 				// how long the messages are. 
1: 				// An improvement would be to string all text found after a line
1: 				// ending in '\' together and compare the whole thing. 
1: 				// But the readLine reads \ lines as null...
1: 				
1: 				if ((englishStr.indexOf("=") < 0) ||
1: 					(englishStr.indexOf("#")>=0)   || 
1: 					(englishStr.indexOf("user=usr")>0)) // may be url syntax
1: 					continue;
1: 				String englishError = "";
1: 				String foreignError = "";
1: 				
1: 				englishError = englishStr.substring(0,englishStr.indexOf("="));				
1: 				
1: 				foreignStr = lookForForeignErrorString(foreignR, englishError, langcode);
1: 				if (foreignStr == null)
1: 				{
1: 					logMsg("  ===============");
1: 					String spacingforformat = "";
1: 					if (langcode.length()>2)
1: 						spacingforformat = "   ";
1: 					logMsg("  " + spacingforformat + "en: < " + englishStr);
1: 					logMsg("  " + langcode + ": > ------- No translation found");
1: 					interesting = true;
1: 					// reset foreign reader to top
1: 					foreignR = new BufferedReader(
1: 						new InputStreamReader(new FileInputStream(foreignFileName), "UTF8"));	
1: 					continue;
1: 				}
1: 				else
1: 				{
1: 					// theoretically, we should now be at the same error.
1: 					//chatterMsg("\tMessage: " + englishError + "(en), found match") ;
1: 					logMsg("  ===============");
1: 					String spacingforformat = "";
1: 					if (langcode.length()>2)
1: 						spacingforformat = "   ";
1: 					logMsg("  " + spacingforformat + "en: < " + englishStr);
1: 					logMsg("  " + langcode + ": > " + foreignStr);
1: 					
1: 					checkISO8559(foreignStr);
1: 				
1: 					// just for fun, compare occurrences of some unusual characters:				
1: 					int count = countAndCompareCountCharacter(
1: 						englishStr, foreignStr, "%", englishError);
1: 					// let's not check for , it is a language specific construct
1: 					// count = countAndCompareCountCharacter(
1: 					//		englishStr, foreignStr, ",", englishError);
1: 					count = countAndCompareCountCharacter(
1: 						englishStr, foreignStr, ";", englishError);
1: 					count = countAndCompareCountCharacter(
1: 						englishStr, foreignStr, ":", englishError);
1: 					count = countAndCompareCountCharacter(
1: 						englishStr, foreignStr, "_", englishError);
1: 					count = countAndCompareCountCharacter(
1: 						englishStr, foreignStr, "=", englishError);
1: 					count = countAndCompareCountCharacter(
1: 						englishStr, foreignStr, "(", englishError);
1: 					count = countAndCompareCountCharacter(
1: 						englishStr, foreignStr, ")", englishError);
1: 					count = countAndCompareCountCharacter(
1: 						englishStr, foreignStr, "+", englishError);
1: 					// let's not check for -, it is a language specific construct
1: 					// count = countAndCompareCountCharacter(
1: 					//		englishStr, foreignStr, "-", englishError);
1: 					count = countAndCompareCountCharacter(
1: 						englishStr, foreignStr, "/", englishError);
1: 					count = countAndCompareCountCharacter(
1: 						englishStr, foreignStr, "]", englishError);
1: 					count = countAndCompareCountCharacter(
1: 						englishStr, foreignStr, "[", englishError);
1: 					count = countAndCompareCountCharacter(
1: 						englishStr, foreignStr, "\"", englishError);	
1: 				
1: 					// check to see if the errorstring has a {
1: 					int countOpen = countAndCompareCountCharacter(
1: 						englishStr, foreignStr, openBrace, englishError);
1: 					// then check to see if the errorstring has a } 
1: 					int countClose = countAndCompareCountCharacter(
1: 						englishStr, foreignStr, closeBrace, englishError);
1: 					if ((countOpen <0) || (countClose <0))
1: 					{
1: 						// we have a mismatch between the languages should already have seen an error
1: 						continue;
1: 					}			
1: 					if (countOpen != countClose)
1: 					{	
1: 						logMsg("\t FAILURE!!! - unmatched braces");
1: 						interesting = true;
1: 						continue;
1: 					}
1: 					// now check that the parameter numbers encircled by the braces are matching
1: 					compareParameterSequenceNumbers(englishStr, foreignStr, countOpen, englishError);
1: 
1: 					// now, for the toolsmessages files, if we do not have replacements,
1: 					// in theory there is no need for double single quotes. 
1: 					// For all other files, single quotes need to be doubled
1: 					// So, check for apostropes
1: 					if ((englishFileName.indexOf("tools")>0) ||
1: 						(foreignFileName.indexOf("tools")>0))
1: 					{
1: 						if ((countOpen == 0) || (countClose == 0))
1: 						{
1: 							lookAtSingleQuotes(englishStr, apostrophe, englishError, englishFileName, "in English String");
1: 							lookAtSingleQuotes(foreignStr, apostrophe, foreignError, foreignFileName, "in translated String");
1: 						}
1: 						else if ((countOpen == countClose) && (countOpen > 0))
1: 						{
1: 							// except for strings with replacements in toolsmessages files
1: 							// all apostrophes *must* get doubled.
1: 							if ((englishStr.indexOf(apostrophe) < 0) && (foreignStr.indexOf(apostrophe) < 0))
1: 							{
1: 								continue;
1: 							}
1: 							else
1: 							{
1: 								lookAtDoubleQuotes(englishStr, apostrophe, englishError, englishFileName, "in English String");
1: 								lookAtDoubleQuotes(foreignStr, apostrophe, foreignError, foreignFileName, "in translated String");
1: 							}
1: 						}
1: 					}
1: 					else // just check that the quotes are doubled
1: 					{
1: 						lookAtDoubleQuotes(englishStr, apostrophe, englishError, englishFileName, "in English String");
1: 						lookAtDoubleQuotes(foreignStr, apostrophe, foreignError, foreignFileName, "in translated String");
1: 					}
1: 					// last automated check is to find strings
1: 					// with all capitals and compare....
1: 					compareUpperCaseStrings(englishStr, foreignStr, englishError, foreignFileName);
1: 					
1: 					if ((strbuf!=null) && (strbuf.length() >0) && interesting)
1: 						System.out.println(strbuf);
1: 					strbuf=null;
1: 					
1: 				}
1: 			}
1: 		} catch (UnsupportedEncodingException e) {
1: 		} catch (IOException e) {
1: 		}
1: 	}
1: 	
1: 	/**
1: 	 * 
1: 	 * @param englishStr
1: 	 * @param foreignStr
1: 	 * @param Character
1: 	 * @return 0 if the character does not occur at all
1: 	 *         -1 if there is a difference between English and translation
1: 	 *         #>0 indicating the number of occurrences of the character
1: 	 */
1: 	public static int countAndCompareCountCharacter(
1: 			String englishStr, String foreignStr, String Character, String englishError)
1: 	{
1: 		if (englishStr.indexOf(Character)< 0)
1: 			return 0;
1: 		else { // (if character exists)
1: 			//then compare the number of occurrences per line
1: 			int noCharE=0;
1: 			int noCharF=0;
1: 			noCharE = countCharacter(englishStr, Character);
1: 			noCharF = countCharacter(foreignStr, Character);
1: 			if (noCharE!=noCharF)
1: 			{
1: 				logMsg("\t WARNING - not the same number of the character " + Character);
1: 				interesting = true;
1: 				return -1;
1: 			}
1: 			else
1: 			{	
1: 				chatterMsg("\t\tsame number of the character " + Character + ", namely, :" + noCharE);
1: 				return noCharE;
1: 			}
1: 		}
1: 	}
1: 	
1: 	/**
1: 	 * 
1: 	 * @param englishStr
1: 	 * @param foreignStr
1: 	 * @param Character
1: 	 * @return 0 if the character does not occur at all
1: 	 *         -1 if there is a difference between English and translation
1: 	 *         #>0 indicating the number of occurrences of the character
1: 	 */
1: 	public static int countCharacter(String Str, String Character)
1: 	{
1: 		if (Str.indexOf(Character)< 0)
1: 			return 0;
1: 		else { // (if character exists)
1: 		//then compare the number of occurrences per line
1: 			String tmpstr = Str;
1: 			int noChar=0;
1: 			for (int k=0; k<Str.length() ; k++){
1: 				if (tmpstr.indexOf(Character) >= 0)
1: 					noChar++;
1: 					tmpstr = tmpstr.substring(tmpstr.indexOf(Character)+1);
1: 			}
1: 			return noChar;
1: 		}
1: 	}
1: 	
1: 	public static void compareParameterSequenceNumbers(
1: 			String englishStr, String foreignStr, int NumberOfParameters, String englishError)
1: 	{
1: 		for ( int i=0 ; i < NumberOfParameters; i++)
1: 		{
1: 			int eindex1 = englishStr.indexOf("{");
1: 			int findex1 = foreignStr.indexOf("{");
1: 			int eindex2 = englishStr.indexOf("}");
1: 			int findex2 = foreignStr.indexOf("}");
1: 			String englishSubStr1 = englishStr.substring(eindex1+1, eindex2);
1: 			String foreignSubStr1 = foreignStr.substring(findex1+1, findex2);
1: 			chatterMsg("\t\tcomparing english parameter or string substr: " + englishSubStr1 + " with translated substr " + foreignSubStr1);
1: 			if (!englishSubStr1.equals(foreignSubStr1))
1: 			{
1: 				logMsg("\t WARNING - not the same parameter or string in brackets");
1: 				interesting = true;
1: 			}
1: 			englishStr=englishStr.substring(eindex2+1);
1: 			foreignStr=foreignStr.substring(findex2+1);
1: 		}
1: 	}	
1: 	
1: 	/**
1: 	 * check that strings without replacements only have
1: 	 * single quotes 
1: 	 * Note that we're passing in 'Character' but it's really only
1: 	 * thought about for quotes.
1: 	 * If the apostrophes are doubled, flag a warning.
1: 	 * Note that it may still be ok, we just want to know.
1: 	 * This is only relevant in the toolsmessages files.	
1: 	 * 
1: 	 */
1: 	private static void lookAtSingleQuotes (
1: 			String Str, String Character, String Error, String FileName, String print ) 
1: 	{
1: 		String tmpStr = Str;
1: 		int countOfCharacter = countCharacter(tmpStr, Character);
1: 		//chatterMsg("\t\t\tcountOfCharacter for " + Character + " is: " + countOfCharacter);
1: 		if (countOfCharacter < 0)
1: 			return;
1: 		for (int m=0 ; m < countOfCharacter ; m++)
1: 		{
1: 			int index1 = Str.indexOf("'");
1: 			String SubStr1 = Str.substring(index1 +1);
1: 			int index2 = SubStr1.indexOf("'");
1: 			if (index2 < 0)  
1: 				return; // we're done
1: 			if (index2 == 0) // it *is* right after!
1: 			{
1: 				logMsg("\t WARNING - double quotes in String without replacements");
1: 				interesting = true;
1: 			}
1: 			else
1: 				chatterMsg("\t\t" + print + " found: " + countOfCharacter + " single quotes");
1: 			tmpStr = SubStr1;
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * check that strings have doubled quotes.
1: 	 * Note that we're passing in 'Character' but it's really only
1: 	 * thought about for quotes/apostrophes.
1: 	 * If the apostrophes are single FAIL, not OK. (except for tools)	
1: 	 * Note that we already know there *are* quotes in the string
1: 	 * 
1: 	 */
1: 	private static void lookAtDoubleQuotes (
1: 			String Str, String Character, String Error, String FileName, String print ) 
1: 	{
1: 		int countOfCharacter = countCharacter(Str, Character);
1: 		if (countOfCharacter % 2 == 1)
1: 		{
1: 			logMsg("\t WARNING - found single single quotes - quotes need to be doubled");
1: 			interesting = true;
1: 		}
1: 		else
1: 			chatterMsg(" \t\t" + print + " found: " + (countOfCharacter / 2) + " double quotes");
1: 	}
1: 	
1: 	public static void compareUpperCaseStrings(String englishStr, String foreignStr, String Error, String FileName)
1: 	{
1: 		// first check to see if there are any strings with 
1: 		// more than one uppercase.
1: 		ArrayList englishArray = findUpperCaseStrings(englishStr);
1: 		ArrayList foreignArray = findUpperCaseStrings(foreignStr);
1: 		if ((englishArray == null) && (foreignArray==null))
1: 		{
1: 			chatterMsg("no such character in string");
1: 			return;
1: 		}
1: 		else if ((englishArray == null) || (foreignArray == null))
1: 		{
1: 			logMsg("\t FAILURE!!! - not the same number of Uppercase strings, one has none, the other something");
1: 			interesting = true;
1: 			return;
1: 		}
1: 		if (englishArray.size() != foreignArray.size())
1: 		{
1: 			logMsg("\t FAILURE!!! - not the same number of Uppercase strings");
1: 			interesting = true;
1: 		}
1: 		else
1: 		{
1: 			for (int i=0; i < englishArray.size(); i++)
1: 			{
1: 				if (!englishArray.get(i).equals(foreignArray.get(i)))
1: 				{
1: 					logMsg("\t WARNING - difference in Uppercase strings");
1: 					interesting = true;
1: 				}
1: 				else 
1: 					chatterMsg("\t\tsuccessfully compared " + englishArray.get(i));
1: 			}
1: 		}
1: 	}
1: 	
1: 	/**
1: 	 * 
1: 	 * Find uppercase strings in a string passed in
1: 	 */
1: 	public static ArrayList findUpperCaseStrings(String Strin)
1: 	{
1: 		ArrayList StrArr = new ArrayList(); // for out
1: 		StringBuffer buf = new StringBuffer();
1: 
1: 		int length = Strin.length();
1: 		for ( int upperIdx = 0 ; upperIdx < length ; ++upperIdx )
1: 		{
1: 			char ch = Strin.charAt( upperIdx );
1: 			if ((buf == null) || (buf.length() == 0))
1: 			{
1: 				buf = new StringBuffer();
1: 				if (Character.isUpperCase(ch))
1: 					buf.append(ch);
1: 			}
1: 			else if (buf.length() == 1)
1: 			{
1: 				if (Character.isUpperCase(ch))
1: 					buf.append(ch);
1: 				else 
1: 					buf = null; // never mind
1: 			}
1: 			else
1: 			{
1: 				if (Character.isUpperCase(ch))
1: 					buf.append(ch);
1: 				else
1: 				{
1: 					StrArr.add(buf.toString());
1: 					buf = null;
1: 				}
1: 			}
1: 		}
1: 		return StrArr;
1: 	}
1: 	
1: 	/**
1: 	 * Check for characters in the range 0x00-0x1f (which are ASCII) and 0x7f-0xff
1: 	 * If found, suggest native2ascii modification of file
1: 	 */
1: 	private static void checkISO8559(String lineRead){
1: 		int numchars = lineRead.length();
1: 		for (int i = 0 ; i < numchars ; i++) 
1: 		{
1: 		      int c = lineRead.charAt(i);
1: 		      if (((c >= 0x0000) && (c <= 0x1F)) || ((c >= 0x7F) && c <= 0XFF ))
1: 		      {
1: 		    	  logMsg("\t FAILURE: encountered non-ISO8559-1 character");
1: 		    	  logMsg("\t please run: native2ascii -encoding UTF-8 on this file");
1: 		    	  interesting = true;
1: 		      }
1: 		}
1: 	}
1: 	
1: 	
1: 	/**
1: 	 * Check that the file exists
1: 	 */
1: 	private static boolean checkExistsFile(String FileName){
1: 		//chatterMsg(" FileName: " + FileName);
1: 		File File = new File(FileName);
1: 		if (!File.exists())
1: 			return false;
1: 		else 
1: 			return true;
1: 	}
1: 	
1: 	private static String lookForForeignErrorString (
1:     		BufferedReader foreignR, String englishError, String langcode)
1:     throws IOException
1:     {	
1:     	String foreignError="";
1: 		String foreignStr="";
1: 		while (true)
1: 		{
1: 			// some messages have only a \, which will be a null string
1: 			// If this is the case, try to grab a next line. 
1: 			// If that too is null, bail out.
1: 			if (foreignStr == null)
1: 			{
1: 				foreignStr = foreignR.readLine();
1: 				// if still null, we must really be at the end.
1: 				if (foreignStr == null)
1: 				{
1: 					// Assume we Reached EOF
1: 					return null;
1: 				}
1: 			}
1: 			else if ((foreignStr.indexOf("=")>0) &&
1: 				 (foreignStr.indexOf("#")!=0) &&
1: 				 (!foreignStr.trim().equals("")))
1: 			{
1: 				foreignError = foreignStr.substring(0,foreignStr.indexOf("="));
1: 				if (foreignError.equals(englishError))
1: 				{
1: 					return foreignStr;
1: 				}
1: 			}
1: 			foreignStr = foreignR.readLine();
1: 		}
1: 	}
1:     
1: 	/**
1: 	 * Write message to the standard output.
1: 	 */
1: 	private static void logMsg(String str)	{
1: 		if (strbuf == null)
1: 			strbuf = new StringBuffer(str + "\n");
1: 		else
1: 			strbuf.append(str + "\n");
1: 	}
1: 
1: 	/**
1: 	 * Write more messages to the standard output if property tvtdebug is true.
1: 	 */
1: 	private static void chatterMsg(String str)	{
1: 	 	String debug = System.getProperty("tvtdebug");
1: 	   	if ((debug!=null) && (debug.equals("true")))
1: 	   	{
1: 	   		interesting = true;
1: 	   		if (strbuf == null)
1: 				strbuf = new StringBuffer(str + "\n");
1: 			else
1: 				strbuf.append(str + "\n");
1: 	   	}
1: 	}
1: }
============================================================================