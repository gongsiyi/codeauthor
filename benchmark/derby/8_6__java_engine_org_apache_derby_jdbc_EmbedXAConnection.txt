3:eac0369: /*
191:eac0369: 
1:345de35:    Derby - Class org.apache.derby.jdbc.EmbedXAConnection
1:345de35: 
1:2f36947:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2f36947:    contributor license agreements.  See the NOTICE file distributed with
1:2f36947:    this work for additional information regarding copyright ownership.
1:2f36947:    The ASF licenses this file to You under the Apache License, Version 2.0
1:2f36947:    (the "License"); you may not use this file except in compliance with
1:2f36947:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:345de35: 
18:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.jdbc;
1:eac0369: 
1:eac0369: import org.apache.derby.impl.jdbc.Util;
1:ad40eda: import org.apache.derby.iapi.jdbc.BrokeredConnectionControl;
1:da847a2: import org.apache.derby.iapi.jdbc.EngineConnection;
1:eac0369: import org.apache.derby.iapi.jdbc.ResourceAdapter;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.reference.SQLState;
1:eac0369: 
1:eac0369: import java.sql.Connection;
1:1e8a20f: import java.sql.ResultSet;
1:eac0369: import java.sql.SQLException;
1:eac0369: import java.sql.Statement;
1:eac0369: import java.sql.PreparedStatement;
1:eac0369: import java.sql.CallableStatement;
1:eac0369: import javax.transaction.xa.XAResource;
1:eac0369: 
1:eac0369: /** -- jdbc 2.0. extension -- */
1:eac0369: import javax.sql.XAConnection;
1:eac0369: 
16:eac0369: /** 
1:eac0369:  */
1:99ae840: class EmbedXAConnection extends EmbedPooledConnection implements XAConnection {
1:eac0369: 
1:0076dfb:         private EmbedXAResource xaRes;
1:eac0369: 
1:a086620:    EmbedXAConnection(BasicEmbeddedDataSource40 ds,
1:58bf06e:                       ResourceAdapter ra,
1:58bf06e:                       String u,
1:58bf06e:                       String p,
1:58bf06e:                       boolean requestPassword) throws SQLException
24:eac0369: 	{
1:eac0369: 		super(ds, u, p, requestPassword);
1:0076dfb:                 xaRes = new EmbedXAResource (this, ra);
1:08cd3aa: 	}
1:08cd3aa: 
1:ad40eda:     /** @see BrokeredConnectionControl#isInGlobalTransaction() */
1:ad40eda:     public boolean isInGlobalTransaction() {
1:ad40eda:     	return isGlobal();
1:ad40eda:     }	
1:ad40eda: 
1:902041a:     /**
1:902041a:      * Check if this connection is part of a global XA transaction.
1:902041a:      *
1:902041a:      * @return {@code true} if the transaction is global, {@code false} if the
1:902041a:      * transaction is local
1:902041a:      */
1:902041a:     private boolean isGlobal() {
1:902041a:         return xaRes.getCurrentXid () != null;
1:902041a:     }
1:902041a: 
1:eac0369: 	/*
1:eac0369: 	** XAConnection methods
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	public final synchronized XAResource getXAResource() throws SQLException {
2:eac0369: 		checkActive();
1:0076dfb: 		return xaRes;
66:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** BrokeredConnectionControl api
1:eac0369: 	*/
1:eac0369: 	/**
1:eac0369: 		Allow control over setting auto commit mode.
1:eac0369: 	*/
1:eac0369: 	public void checkAutoCommit(boolean autoCommit) throws SQLException {
1:902041a: 		if (autoCommit && isGlobal())
1:eac0369: 			throw Util.generateCsSQLException(SQLState.CANNOT_AUTOCOMMIT_XA);
1:eac0369: 
1:eac0369: 		super.checkAutoCommit(autoCommit);
1:eac0369: 	}
1:eac0369: 	/**
1:ce9d214: 		Are held cursors allowed. If the connection is attached to
1:ce9d214:         a global transaction then downgrade the result set holdabilty
1:ce9d214:         to CLOSE_CURSORS_AT_COMMIT if downgrade is true, otherwise
1:ce9d214:         throw an exception.
1:ce9d214:         If the connection is in a local transaction then the
1:ce9d214:         passed in holdabilty is returned.
1:eac0369: 	*/
1:ce9d214: 	public int  checkHoldCursors(int holdability, boolean downgrade)
1:ce9d214:         throws SQLException
1:ce9d214:     {
1:1e8a20f: 		if (holdability == ResultSet.HOLD_CURSORS_OVER_COMMIT) {		
1:902041a: 			if (isGlobal()) {
1:562671e:                 if (!downgrade)
1:562671e:                     throw Util.generateCsSQLException(SQLState.CANNOT_HOLD_CURSOR_XA);
1:562671e:                 
1:1e8a20f:                 holdability = ResultSet.CLOSE_CURSORS_AT_COMMIT;
1:ce9d214:             }
1:eac0369: 		}
1:eac0369: 
1:ce9d214: 		return super.checkHoldCursors(holdability, downgrade);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Allow control over creating a Savepoint (JDBC 3.0)
1:eac0369: 	*/
1:eac0369: 	public void checkSavepoint() throws SQLException {
1:eac0369: 
1:902041a: 		if (isGlobal())
1:eac0369: 			throw Util.generateCsSQLException(SQLState.CANNOT_ROLLBACK_XA);
1:eac0369: 
1:eac0369: 		super.checkSavepoint();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Allow control over calling rollback.
1:eac0369: 	*/
1:eac0369: 	public void checkRollback() throws SQLException {
1:eac0369: 
1:902041a: 		if (isGlobal())
1:eac0369: 			throw Util.generateCsSQLException(SQLState.CANNOT_ROLLBACK_XA);
1:eac0369: 
1:eac0369: 		super.checkRollback();
1:eac0369: 	}
1:eac0369: 	/**
1:eac0369: 		Allow control over calling commit.
1:eac0369: 	*/
1:eac0369: 	public void checkCommit() throws SQLException {
1:eac0369: 
1:902041a: 		if (isGlobal())
1:eac0369: 			throw Util.generateCsSQLException(SQLState.CANNOT_COMMIT_XA);
1:eac0369: 
1:eac0369: 		super.checkCommit();
1:eac0369: 	}
1:eac0369: 
1:902041a:     /**
1:902041a:      * @see org.apache.derby.iapi.jdbc.BrokeredConnectionControl#checkClose()
1:902041a:      */
1:902041a:     public void checkClose() throws SQLException {
1:902041a:         if (isGlobal()) {
1:902041a:             // It is always OK to close a connection associated with a global
1:902041a:             // XA transaction, even if it isn't idle, since we still can commit
1:902041a:             // or roll back the global transaction with the XAResource after
1:902041a:             // the connection has been closed.
1:902041a:         } else {
1:902041a:             super.checkClose();
1:902041a:         }
1:902041a:     }
1:902041a: 
1:eac0369: 	public Connection getConnection() throws SQLException
1:eac0369: 	{
1:eac0369: 		Connection handle;
1:eac0369: 
1:eac0369: 		// Is this just a local transaction?
1:902041a: 		if (!isGlobal()) {
1:eac0369: 			handle = super.getConnection();
4:eac0369: 		} else {
1:eac0369: 
5:eac0369: 			if (currentConnectionHandle != null) {
1:eac0369: 				// this can only happen if someone called start(Xid),
1:eac0369: 				// getConnection, getConnection (and we are now the 2nd
1:eac0369: 				// getConnection call).
1:eac0369: 				// Cannot yank a global connection away like, I don't think... 
1:eac0369: 				throw Util.generateCsSQLException(
1:eac0369: 							   SQLState.CANNOT_CLOSE_ACTIVE_XA_CONNECTION);
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			handle = getNewCurrentConnectionHandle();
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		currentConnectionHandle.syncState();
1:eac0369: 
1:eac0369: 		return handle;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Wrap and control a Statement
1:eac0369: 	*/
1:eac0369: 	public Statement wrapStatement(Statement s) throws SQLException {
1:eac0369: 		XAStatementControl sc = new XAStatementControl(this, s);
1:eac0369: 		return sc.applicationStatement;
1:eac0369: 	}
1:eac0369: 	/**
1:eac0369: 		Wrap and control a PreparedStatement
1:eac0369: 	*/
1:eac0369: 	public PreparedStatement wrapStatement(PreparedStatement ps, String sql, Object generatedKeys) throws SQLException {
1:448ecb0:                 ps = super.wrapStatement(ps,sql,generatedKeys);
1:eac0369: 		XAStatementControl sc = new XAStatementControl(this, ps, sql, generatedKeys);
1:eac0369: 		return (PreparedStatement) sc.applicationStatement;
1:eac0369: 	}
1:eac0369: 	/**
1:eac0369: 		Wrap and control a PreparedStatement
1:eac0369: 	*/
1:eac0369: 	public CallableStatement wrapStatement(CallableStatement cs, String sql) throws SQLException {
1:448ecb0:                 cs = super.wrapStatement(cs,sql);
1:eac0369: 		XAStatementControl sc = new XAStatementControl(this, cs, sql);
1:eac0369: 		return (CallableStatement) sc.applicationStatement;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Override getRealConnection to create a a local connection
1:eac0369: 		when we are not associated with an XA transaction.
1:eac0369: 
1:eac0369: 		This can occur if the application has a Connection object (conn)
1:eac0369: 		and the following sequence occurs.
1:eac0369: 
1:eac0369: 		conn = xac.getConnection();
1:eac0369: 		xac.start(xid, ...)
1:eac0369: 		
1:eac0369: 		// do work with conn
1:eac0369: 
1:eac0369: 		xac.end(xid, ...);
1:eac0369: 
1:eac0369: 		// do local work with conn
1:eac0369: 		// need to create new connection here.
1:eac0369: 	*/
1:da847a2: 	public EngineConnection getRealConnection() throws SQLException
1:eac0369: 	{
1:da847a2:         EngineConnection rc = super.getRealConnection();
1:eac0369: 		if (rc != null)
1:eac0369: 			return rc;
1:eac0369: 
2:eac0369: 		openRealConnection();
1:eac0369: 
1:eac0369: 		// a new Connection, set its state according to the application's Connection handle
3:eac0369: 		currentConnectionHandle.setState(true);
1:eac0369: 
1:eac0369: 		return realConnection;
1:eac0369: 	}
1:eac0369: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:a086620
/////////////////////////////////////////////////////////////////////////
1:    EmbedXAConnection(BasicEmbeddedDataSource40 ds,
commit:58bf06e
/////////////////////////////////////////////////////////////////////////
0:    EmbedXAConnection(EmbeddedBaseDataSource ds,
1:                       ResourceAdapter ra,
1:                       String u,
1:                       String p,
1:                       boolean requestPassword) throws SQLException
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:99ae840
/////////////////////////////////////////////////////////////////////////
1: class EmbedXAConnection extends EmbedPooledConnection implements XAConnection {
commit:902041a
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Check if this connection is part of a global XA transaction.
1:      *
1:      * @return {@code true} if the transaction is global, {@code false} if the
1:      * transaction is local
1:      */
1:     private boolean isGlobal() {
1:         return xaRes.getCurrentXid () != null;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1: 		if (autoCommit && isGlobal())
/////////////////////////////////////////////////////////////////////////
1: 			if (isGlobal()) {
/////////////////////////////////////////////////////////////////////////
1: 		if (isGlobal())
/////////////////////////////////////////////////////////////////////////
1: 		if (isGlobal())
/////////////////////////////////////////////////////////////////////////
1: 		if (isGlobal())
1:     /**
1:      * @see org.apache.derby.iapi.jdbc.BrokeredConnectionControl#checkClose()
1:      */
1:     public void checkClose() throws SQLException {
1:         if (isGlobal()) {
1:             // It is always OK to close a connection associated with a global
1:             // XA transaction, even if it isn't idle, since we still can commit
1:             // or roll back the global transaction with the XAResource after
1:             // the connection has been closed.
1:         } else {
1:             super.checkClose();
1:         }
1:     }
1: 
1: 		if (!isGlobal()) {
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:eec86ed
/////////////////////////////////////////////////////////////////////////
0: abstract class EmbedXAConnection extends EmbedPooledConnection
commit:448ecb0
/////////////////////////////////////////////////////////////////////////
1:                 ps = super.wrapStatement(ps,sql,generatedKeys);
/////////////////////////////////////////////////////////////////////////
1:                 cs = super.wrapStatement(cs,sql);
commit:e916164
/////////////////////////////////////////////////////////////////////////
0: class EmbedXAConnection extends EmbedPooledConnection
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:ad40eda
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.jdbc.BrokeredConnectionControl;
/////////////////////////////////////////////////////////////////////////
1:     /** @see BrokeredConnectionControl#isInGlobalTransaction() */
1:     public boolean isInGlobalTransaction() {
1:     	return isGlobal();
1:     }	
1: 
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:1e8a20f
/////////////////////////////////////////////////////////////////////////
1: import java.sql.ResultSet;
/////////////////////////////////////////////////////////////////////////
1: 		if (holdability == ResultSet.HOLD_CURSORS_OVER_COMMIT) {		
1:                 holdability = ResultSet.CLOSE_CURSORS_AT_COMMIT;
commit:562671e
/////////////////////////////////////////////////////////////////////////
1:                 if (!downgrade)
1:                     throw Util.generateCsSQLException(SQLState.CANNOT_HOLD_CURSOR_XA);
1:                 
0:                 holdability = JDBC30Translation.CLOSE_CURSORS_AT_COMMIT;
commit:ce9d214
/////////////////////////////////////////////////////////////////////////
1: 		Are held cursors allowed. If the connection is attached to
1:         a global transaction then downgrade the result set holdabilty
1:         to CLOSE_CURSORS_AT_COMMIT if downgrade is true, otherwise
1:         throw an exception.
1:         If the connection is in a local transaction then the
1:         passed in holdabilty is returned.
1: 	public int  checkHoldCursors(int holdability, boolean downgrade)
1:         throws SQLException
1:     {
0: 			if (xaRes.getCurrentXid () != null) {
0:                 if (downgrade)
0:                     return JDBC30Translation.CLOSE_CURSORS_AT_COMMIT;
0:                 throw Util.generateCsSQLException(SQLState.CANNOT_HOLD_CURSOR_XA);
1:             }
1: 		return super.checkHoldCursors(holdability, downgrade);
commit:0076dfb
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 		implements XAConnection
1:         private EmbedXAResource xaRes;
1:                 xaRes = new EmbedXAResource (this, ra);
/////////////////////////////////////////////////////////////////////////
1: 		return xaRes;
/////////////////////////////////////////////////////////////////////////
0: 		if (autoCommit && (xaRes.getCurrentXid () != null))
/////////////////////////////////////////////////////////////////////////
0: 			if (xaRes.getCurrentXid () != null)
/////////////////////////////////////////////////////////////////////////
0: 		if (xaRes.getCurrentXid () != null)
/////////////////////////////////////////////////////////////////////////
0: 		if (xaRes.getCurrentXid () != null)
/////////////////////////////////////////////////////////////////////////
0: 		if (xaRes.getCurrentXid () != null)
/////////////////////////////////////////////////////////////////////////
0: 		if (xaRes.getCurrentXid () == null) {
/////////////////////////////////////////////////////////////////////////
commit:da847a2
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.jdbc.EngineConnection;
/////////////////////////////////////////////////////////////////////////
1: 	public EngineConnection getRealConnection() throws SQLException
1:         EngineConnection rc = super.getRealConnection();
commit:08cd3aa
/////////////////////////////////////////////////////////////////////////
0: 						// It is possible that the isolation level state in connection
0: 						// handle has gotten out of sync with the real isolation level.
0: 						// This can happen if SLQ instead of JDBC api has been used to
0: 						// set the isolation level. The code below will check if isolation
0: 						// was set using JDBC or SQL and if yes, then it will update the
0: 						// isolation state in BrokeredConnection with EmbedConnection's
0: 						// isolation level.
0: 						currentConnectionHandle.getIsolationUptoDate();
/////////////////////////////////////////////////////////////////////////
0: 						 xid_im.getFormatId(),
/////////////////////////////////////////////////////////////////////////
0: 		try {
0: 			// It is possible that the isolation level state in connection
0: 			// handle has gotten out of sync with the real isolation level.
0: 			// This can happen if SLQ instead of JDBC api has been used to
0: 			// set the isolation level. The code below will check if isolation
0: 			// was set using JDBC or SQL and if yes, then it will update the
0: 			// isolation state in BrokeredConnection with EmbedConnection's
0: 			// isolation level.
0: 			if (currentConnectionHandle != null)
0: 				currentConnectionHandle.getIsolationUptoDate();
0: 		} catch (SQLException sqle) {
0: 			throw wrapInXAException(sqle);
1: 		}
1: 
commit:6ae3022
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.services.info.JVMInfo;
/////////////////////////////////////////////////////////////////////////
0: 		if (JVMInfo.JDK_ID >= JVMInfo.J2SE_14)
commit:63d26f5
/////////////////////////////////////////////////////////////////////////
0:    Copyright 2003, 2005 The Apache Software Foundation or its licensors, as applicable.
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.impl.jdbc.EmbedConnection;
/////////////////////////////////////////////////////////////////////////
0: 			EmbedConnection conn = tranState.conn; 
/////////////////////////////////////////////////////////////////////////
0: 			EmbedConnection conn = tranState.conn; 
/////////////////////////////////////////////////////////////////////////
0: 			EmbedConnection conn = tranState.conn;
/////////////////////////////////////////////////////////////////////////
0: 	private static void closeUnusedConnection(EmbedConnection conn) {
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.jdbc.EmbedXAConnection
1: 
0:    Copyright 2003, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:4dede3b
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.jdbc
0:    (C) Copyright IBM Corp. 2003, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.jdbc;
1: 
0: import org.apache.derby.iapi.store.access.xa.XAXactId;
0: import org.apache.derby.iapi.store.access.xa.XAResourceManager;
0: import org.apache.derby.iapi.store.access.XATransactionController;
1: import org.apache.derby.impl.jdbc.Util;
0: import org.apache.derby.impl.jdbc.EmbedConnection20;
0: import org.apache.derby.impl.jdbc.TransactionResourceImpl;
0: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.jdbc.ResourceAdapter;
0: import org.apache.derby.iapi.jdbc.BrokeredConnection;
1: 
0: import org.apache.derby.iapi.services.context.ContextManager;
0: import org.apache.derby.iapi.services.context.ContextService;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.reference.JDBC30Translation;
1: 
1: import java.sql.Connection;
1: import java.sql.SQLException;
1: import java.sql.Statement;
1: import java.sql.PreparedStatement;
1: import java.sql.CallableStatement;
1: 
0: /* import jta packages */
0: import javax.transaction.xa.Xid;
1: import javax.transaction.xa.XAResource;
0: import javax.transaction.xa.XAException;
1: 
1: /** -- jdbc 2.0. extension -- */
1: import javax.sql.XAConnection;
1: 
1: /** 
1:  */
0: final class EmbedXAConnection extends EmbedPooledConnection
0: 		implements XAConnection, XAResource
1: 
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2003_2004;
1: 
1: 
0: 	final ResourceAdapter ra;
1: 
0: 	XAXactId	currentXid;
1: 
1: 
0: 	EmbedXAConnection(EmbeddedDataSource ds, ResourceAdapter ra, String u, String p, boolean requestPassword) throws SQLException
1: 	{
1: 		super(ds, u, p, requestPassword);
0: 		this.ra = ra;
1: 
1: 	}
1: 
1: 	/*
1: 	** XAConnection methods
1: 	*/
1: 
1: 	public final synchronized XAResource getXAResource() throws SQLException {
1: 		checkActive();
0: 		return this;
1: 	}
1: 
1: 	/*
0: 	** XAResource methods
1: 	*/
1: 
1: 	/**
0: 		Start work on behalf of a transaction branch specified in xid If TMJOIN
0: 		is specified, the start is for joining a transaction previously seen by
0: 		the resource manager. If TMRESUME is specified, the start is to resume
0: 		a suspended transaction specified in the parameter xid. If neither
0: 		TMJOIN nor TMRESUME is specified and the transaction specified by xid
0: 		has previously been seen by the resource manager, the resource manager
0: 		throws the XAException exception with XAER_DUPID error code.
1: 
0: 		@param xid A global transaction identifier to be associated with the
0: 				resource 
0: 		@param flags One of TMNOFLAGS, TMJOIN, or TMRESUME 
1: 
0: 		@exception XAException An error has occurred. Possible exceptions are
0: 		XA_RB*, XAER_RMERR, XAER_RMFAIL, XAER_DUPID, XAER_OUTSIDE, XAER_NOTA,
0: 		XAER_INVAL, or XAER_PROTO.
1: 	 */
0: 	public final synchronized void start(Xid xid, int flags) throws XAException
1: 	{
0: 		checkXAActive();
1: 
0: 		// JDBC 3.0 section 12.3 - One transaction associated with a XAConnection
0: 		if (currentXid != null)
0: 			throw new XAException(XAException.XAER_PROTO);
1: 
0: 		// ensure immtable and correct equals method.
0: 		XAXactId xid_im = new XAXactId(xid);
1: 
0: 		XATransactionState tranState = getTransactionState(xid_im);
1: 
0: 		switch (flags) {
0: 		case XAResource.TMNOFLAGS:
0: 			if (tranState != null)
0: 				throw new XAException(XAException.XAER_DUPID);
1: 
0: 			try {
1: 
0: 				if (realConnection == null) {
1: 					openRealConnection();
1: 
1: 					if (currentConnectionHandle != null) {
1: 
0: 						// since this is a new connection, set its complete
0: 						// state according to the application's Connection
0: 						// handle view of the world.
1: 						currentConnectionHandle.setState(true);
0: 						realConnection.setApplicationConnection(currentConnectionHandle);
1: 					}
1: 
1: 				} else {
1: 
0: 					// XAResource.start() auto commits in DB2 when in auto commit mode.
1: 					if (currentConnectionHandle != null) {
0: 						if (currentConnectionHandle.getAutoCommit())
0: 							currentConnectionHandle.rollback();
1: 					}
0: 					if (!realConnection.transactionIsIdle())
0: 						throw new XAException(XAException.XAER_OUTSIDE);
1: 
1: 					if (currentConnectionHandle != null) {
1: 
0: 						// we have a current handle so we need to keep
0: 						// the connection state of the current connection.
1: 						currentConnectionHandle.setState(true);
1: 
0: 						// At the local to global transition we need to discard
0: 						// and close any open held result sets, a rollback will do this.
0: 						realConnection.rollback();
1: 					} else {
0: 						resetRealConnection();
1: 					}
1: 
1: 				}
1: 
0: 				// Global connections are always in auto commit false mode.
0: 				realConnection.setAutoCommit(false);
1: 
0: 				// and holdability false (cannot hold cursors across XA transactions.
0: 				realConnection.setHoldability(JDBC30Translation.CLOSE_CURSORS_AT_COMMIT);
1: 
0: 				realConnection.getLanguageConnection().
0: 					getTransactionExecute().createXATransactionFromLocalTransaction(
0: 						 xid_im.getFormatId(), 
0: 						 xid_im.getGlobalTransactionId(),
0: 						 xid_im.getBranchQualifier());
1: 
1: 
0: 			} catch (StandardException se) {
0: 				throw wrapInXAException(se);
1: 			
0: 			} catch (SQLException sqle) {
0: 				throw wrapInXAException(sqle);
1: 			}
1: 
1: 
0: 			if (!ra.addConnection(xid_im, new XATransactionState(realConnection.getContextManager(), realConnection, this, xid_im)))
0: 				throw new XAException(XAException.XAER_DUPID);
1: 
0: 			break;
1: 
0: 		case XAResource.TMRESUME:
0: 		case XAResource.TMJOIN:
0: 			if (tranState == null)
0: 				throw new XAException(XAException.XAER_NOTA);
1: 
0: 			tranState.start(this, flags);
1: 
0: 			if (tranState.conn != realConnection) {
1: 
0: 				if (realConnection != null) {
1: 
0: 					if (!realConnection.transactionIsIdle())
0: 						throw new XAException(XAException.XAER_OUTSIDE);
1: 
0: 					closeUnusedConnection(realConnection);
1: 				}
0: 				realConnection = tranState.conn;
1: 
1: 				if (currentConnectionHandle != null) {
1: 
0: 					try {
0: 						// only reset the non-transaction specific Connection state.
0: 						currentConnectionHandle.setState(false);
0: 						realConnection.setApplicationConnection(currentConnectionHandle);
0: 					} catch (SQLException sqle) {
0: 						throw wrapInXAException(sqle);
1: 					}
1: 				}
1: 
1: 			}
1: 
1: 
0: 			break;
1: 
0: 		default:
0: 			throw new XAException(XAException.XAER_INVAL);
1: 		}
1: 
0: 		currentXid = xid_im;
1: 	}
1: 
1: 
1: 	/**
0: 		Ends the work performed on behalf of a transaction branch. The resource
0: 		manager disassociates the XA resource from the transaction branch
0: 		specified and let the transaction be completed.  
1: 
0: 		<p> If TMSUSPEND is specified in flags, the transaction branch is
0: 		temporarily suspended in incomplete state. The transaction context 
0: 		is in suspened state and must be resumed via start with TMRESUME
0: 		specified. 
1: 
0: 		<p> If TMFAIL is specified, the portion of work has failed. The
0: 		resource manager may mark the transaction as rollback-only 
1: 
0: 		<p> If TMSUCCESS is specified, the portion of work has completed
0: 		successfully. 
1: 
0: 		@param xid A global transaction identifier that is the same as what was
0: 				used previously in the start method. 
0: 		@param flags One of TMSUCCESS, TMFAIL, or TMSUSPEND
1: 
0: 		@exception XAException An error has occurred. 
0: 		Possible XAException values are XAER_RMERR, XAER_RMFAILED, XAER_NOTA,
0: 		XAER_INVAL, XAER_PROTO, or XA_RB*. 
1: 	 */
0: 	public final synchronized void end(Xid xid, int flags) throws XAException
1: 	{
0: 		checkXAActive();
1: 
0: 		// ensure immtable and correct equals method.
0: 		XAXactId xid_im = new XAXactId(xid);
1: 
0: 		boolean endingCurrentXid = false;
1: 
0: 		// must match the Xid from start()
0: 		if (currentXid != null) {
0: 			if (!currentXid.equals(xid_im))
0: 				throw new XAException(XAException.XAER_PROTO);
0: 			endingCurrentXid = true;
1: 		}
1: 
0: 		XATransactionState tranState = getTransactionState(xid_im);
0: 		if (tranState == null)
0: 			throw new XAException(XAException.XAER_NOTA);
1: 
0: 		boolean rollbackOnly = tranState.end(this, flags, endingCurrentXid);
1: 
0: 		// RESOLVE - what happens to the connection on a fail
0: 		// where we are not ending the current XID.
0: 		if (endingCurrentXid) {
0: 			currentXid = null;
1: 
0: 			realConnection = null;
1: 		}
1: 
0: 		if (rollbackOnly)
0: 			throw new XAException(tranState.rollbackOnlyCode); 
1: 
1: 	}
1: 
1: 	/**
0: 		Ask the resource manager to prepare for a transaction commit of the
0: 		transaction specified in xid. 
1: 
0: 		@param xid A global transaction identifier
1: 
0: 		@return A value indicating the resource manager's vote on the outcome
0: 		of the transaction. The possible values are: XA_RDONLY or XA_OK. If the
0: 		resource manager wants to roll back the transaction, it should do so by
0: 		raising an appropriate XAException in the prepare method.
1: 
0: 		@exception XAException An error has occurred. Possible exception values
0: 		are: XA_RB*, XAER_RMERR, XAER_RMFAIL, XAER_NOTA, XAER_INVAL, or
0: 		XAER_PROTO.
1: 
1: 	 */
0: 	public final synchronized int prepare(Xid xid) throws XAException
1: 	{
0: 		checkXAActive();
1: 
0: 		// ensure immtable and correct equals method.
0: 		XAXactId xid_im = new XAXactId(xid);
1: 
0: 		XATransactionState tranState = getTransactionState(xid_im);
1: 
0: 		if (tranState == null) {
0: 			XAResourceManager rm = ra.getXAResourceManager();
1: 
0: 			ContextManager inDoubtCM = rm.find(xid);
1: 
0: 			// RM also does not know about this xid.
0: 			if (inDoubtCM == null)
0: 				throw new XAException(XAException.XAER_NOTA);
1: 
0: 			// cannot prepare in doubt transactions
0: 			throw new XAException(XAException.XAER_PROTO);
1: 
1: 		}
1: 
0: 		synchronized (tranState) {
1: 
0: 			checkUserCredentials(tranState.creatingResource);
1: 
0: 			// Check the transaction is no associated with
0: 			// any XAResource.
0: 			switch (tranState.associationState) {
0: 			case XATransactionState.T0_NOT_ASSOCIATED:
0: 				break;
1: 
0: 			case XATransactionState.TRO_FAIL:
0: 				throw new XAException(tranState.rollbackOnlyCode);
1: 
0: 			default:
0: 				throw new XAException(XAException.XAER_PROTO);
1: 			}
1: 
0: 			if (tranState.suspendedList != null && tranState.suspendedList.size() != 0)
0: 				throw new XAException(XAException.XAER_PROTO);
1: 
0: 			if (tranState.isPrepared)
0: 				throw new XAException(XAException.XAER_PROTO);
1: 
0: 			EmbedConnection20 conn = tranState.conn; 
1: 
0: 			try {
1: 
0: 				int ret = conn.xa_prepare();
1: 
0: 				if (ret == XATransactionController.XA_OK) {
0: 					tranState.isPrepared = true;
1: 
0: 					return XAResource.XA_OK;
1: 				} else {
1: 
0: 					returnConnectionToResource(tranState, xid_im);
0: 					return XAResource.XA_RDONLY;
1: 				}
0: 			} catch (SQLException sqle) {
0: 				throw wrapInXAException(sqle);
1: 			}
1: 		}
1: 	
1: 	}
1: 
1: 	/**
0: 		Commit the global transaction specified by xid.
0: 		@param xid A global transaction identifier
0: 		@param onePhase If true, the resource manager should use a one-phase
0: 				commit protocol to commit the work done on behalf of xid.
1: 
0: 		@exception XAException An error has occurred. Possible XAExceptions are
0: 				XA_HEURHAZ, XA_HEURCOM, XA_HEURRB, XA_HEURMIX, XAER_RMERR,
0: 				XAER_RMFAIL, XAER_NOTA, XAER_INVAL, or XAER_PROTO.  
0: 				<P>If the resource manager did not commit the transaction and
0: 				the paramether onePhase is set to true, the resource manager 
0: 				may throw one of the XA_RB* exceptions. Upon return, the
0: 				resource manager has rolled back the branch's work and has 
0: 				released all held resources.
1: 	*/
0: 	public final synchronized void commit(Xid xid, boolean onePhase) throws XAException
1: 	{
0: 		checkXAActive();
1: 
0: 		// ensure immtable and correct equals method.
0: 		XAXactId xid_im = new XAXactId(xid);
1: 
0: 		XATransactionState tranState = getTransactionState(xid_im);
1: 
0: 		if (tranState == null) {
1: 
0: 			XAResourceManager rm = ra.getXAResourceManager();
1: 
0: 			ContextManager inDoubtCM = rm.find(xid);
1: 
0: 			// RM also does not know about this xid.
0: 			if (inDoubtCM == null)
0: 				throw new XAException(XAException.XAER_NOTA);
1: 
0: 			ContextService csf = ContextService.getFactory();
1: 
0: 			csf.setCurrentContextManager(inDoubtCM);
0: 			try
1: 			{
0: 				rm.commit(inDoubtCM, xid_im, onePhase);
1: 
0: 				// close the connection/transaction since it can never be used again.
0: 				inDoubtCM.cleanupOnError(StandardException.closeException());
0: 				return;
1: 			}
0: 			catch (StandardException se)
1: 			{
0: 				// The rm threw an exception, clean it up in the approprate
0: 				// context.  There is no transactionResource to handle the
0: 				// exception for us.
0: 				inDoubtCM.cleanupOnError(se);
0: 				throw wrapInXAException(se);
1: 			}
0: 			finally
1: 			{
0: 				csf.resetCurrentContextManager(inDoubtCM);
1: 			}
1: 
1: 		}
1: 
0: 		synchronized (tranState) {
0: 			checkUserCredentials(tranState.creatingResource);
1: 		
0: 			// Check the transaction is no associated with
0: 			// any XAResource.
0: 			switch (tranState.associationState) {
0: 			case XATransactionState.T0_NOT_ASSOCIATED:
0: 				break;
1: 
0: 			case XATransactionState.TRO_FAIL:
0: 				throw new XAException(tranState.rollbackOnlyCode);
1: 
0: 			default:
0: 				throw new XAException(XAException.XAER_PROTO);
1: 			}
1: 
0: 			if (tranState.suspendedList != null && tranState.suspendedList.size() != 0)
0: 				throw new XAException(XAException.XAER_PROTO);
1: 
0: 			if (tranState.isPrepared == onePhase)
0: 				throw new XAException(XAException.XAER_PROTO);
1: 
0: 			EmbedConnection20 conn = tranState.conn; 
1: 
0: 			try {
1: 
0: 				conn.xa_commit(onePhase);
1: 
0: 			} catch (SQLException sqle) {
0: 				throw wrapInXAException(sqle);
0: 			} finally {
0: 				returnConnectionToResource(tranState, xid_im);
1: 			}
1: 		}
1: 	}
1: 
1: 	/** 
0: 		Inform the resource manager to roll back work done on behalf of a
0: 		transaction branch
1: 
0: 		@param xid A global transaction identifier
0: 		@exception XAException - An error has occurred 
1: 	*/
0: 	public final synchronized void rollback(Xid xid) throws XAException
1: 	{
0: 		checkXAActive();
1: 
0: 		// ensure immtable and correct equals method.
0: 		XAXactId xid_im = new XAXactId(xid);
1: 
0: 		XATransactionState tranState = getTransactionState(xid_im);
1: 
0: 		if (tranState == null) {
0: 			XAResourceManager rm = ra.getXAResourceManager();
1: 
0: 			ContextManager inDoubtCM = rm.find(xid);
1: 
0: 			// RM also does not know about this xid.
0: 			if (inDoubtCM == null)
0: 				throw new XAException(XAException.XAER_NOTA);
1: 
0: 			ContextService csf = ContextService.getFactory();
1: 
0: 			csf.setCurrentContextManager(inDoubtCM);
0: 			try
1: 			{
0: 				rm.rollback(inDoubtCM, xid_im);
1: 
0: 				// close the connection/transaction since it can never be used again.
0: 				inDoubtCM.cleanupOnError(StandardException.closeException());
0: 				return;
1: 			}
0: 			catch (StandardException se)
1: 			{
0: 				// The rm threw an exception, clean it up in the approprate
0: 				// context.  There is no transactionResource to handle the
0: 				// exception for us.
0: 				inDoubtCM.cleanupOnError(se);
0: 				throw wrapInXAException(se);
1: 			}
0: 			finally
1: 			{
0: 				csf.resetCurrentContextManager(inDoubtCM);
1: 			}
1: 
1: 		}
1: 
0: 		synchronized (tranState) {
1: 		
0: 			// Check the transaction is no associated with
0: 			// any XAResource.
0: 			switch (tranState.associationState) {
0: 			case XATransactionState.T0_NOT_ASSOCIATED:
0: 			case XATransactionState.TRO_FAIL:
0: 				break;
1: 				
0: 			default:
0: 				throw new XAException(XAException.XAER_PROTO);
1: 			}
1: 
0: 			if (tranState.suspendedList != null && tranState.suspendedList.size() != 0)
0: 				throw new XAException(XAException.XAER_PROTO);
1: 
0: 			checkUserCredentials(tranState.creatingResource);
1: 
0: 			try {
1: 
0: 				tranState.conn.xa_rollback();
0: 			} catch (SQLException sqle) {
0: 				throw wrapInXAException(sqle);
0: 			} finally {
0: 				returnConnectionToResource(tranState, xid_im);
1: 			}
1: 		}
1: 	}
1: 
1: 	/**
0: 		Obtain a list of prepared transaction branches from a resource
0: 		manager. The transaction manager calls this method during recovery to
0: 		obtain the list of transaction branches that are currently in prepared
0: 		or heuristically completed states. 
1: 
0: 		@param flag One of TMSTARTRSCAN, TMENDRSCAN, TMNOFLAGS. TMNOFLAGS must
0: 		be used when no other flags are set in flags.
1: 
0: 		@return The resource manager returns zero or more XIDs for the
0: 		transaction branches that are currently in a prepared or heuristically
0: 		completed state. If an error occurs during the operation, the resource
0: 		manager should throw the appropriate XAException.
1: 
0: 		@exception XAException An error has occurred. Possible values are
0: 		XAER_RMERR, XAER_RMFAIL, XAER_INVAL, and XAER_PROTO.
1: 
1: 	*/
0: 	public final synchronized Xid[] recover(int flag) throws XAException
1: 	{
0: 		checkXAActive();
1: 
0: 		try
1: 		{
0: 			return ra.getXAResourceManager().recover(flag);
1: 		}
0: 		catch (StandardException se)
1: 		{
0: 			throw wrapInXAException(se);
1: 		}
1: 	}
1: 
1: 	/**
0: 		Tell the resource manager to forget about a heuristically completed
0: 		transaction branch. 
1: 
0: 		@param xid A global transaction identifier
0: 		@exception XAException An error has occurred. Possible exception values
0: 		are XAER_RMERR, XAER_RMFAIL, XAER_NOTA, XAER_INVAL, or XAER_PROTO.
1: 	 */
0: 	public final synchronized void forget(Xid xid) throws XAException {
1: 
0: 		checkXAActive();
1: 
0: 		// ensure immtable and correct equals method.
0: 		XAXactId xid_im = new XAXactId(xid);
1: 
0: 		XATransactionState tranState = getTransactionState(xid_im);
0: 		if (tranState == null) {
0: 			XAResourceManager rm = ra.getXAResourceManager();
1: 
0: 			ContextManager inDoubtCM = rm.find(xid);
1: 
0: 			// RM also does not know about this xid.
0: 			if (inDoubtCM == null)
0: 				throw new XAException(XAException.XAER_NOTA);
1: 
0: 			ContextService csf = ContextService.getFactory();
1: 
0: 			csf.setCurrentContextManager(inDoubtCM);
0: 			try
1: 			{
0: 				rm.forget(inDoubtCM, xid_im);
1: 
0: 				// close the connection/transaction since it can never be used again.
0: 				inDoubtCM.cleanupOnError(StandardException.closeException());
0: 				return;
1: 			}
0: 			catch (StandardException se)
1: 			{
0: 				// The rm threw an exception, clean it up in the approprate
0: 				// context.  There is no transactionResource to handle the
0: 				// exception for us.
0: 				inDoubtCM.cleanupOnError(se);
0: 				throw wrapInXAException(se);
1: 			}
0: 			finally
1: 			{
0: 				csf.resetCurrentContextManager(inDoubtCM);
1: 			}
1: 
1: 		}
1: 
0: 		throw new XAException(tranState.isPrepared ? XAException.XAER_NOTA : XAException.XAER_PROTO);
1: 
1: 	}
1: 	/** 
0: 		This method is called to determine if the resource manager instance
0: 		represented by the target object is the same as the resouce manager
0: 		instance represented by the parameter xares.
1: 
0: 		@param xares An XAResource object whose resource manager instance is to
0: 		be compared with the resource manager instance of the target object.
1: 
0: 		@return true if it's the same RM instance; otherwise false.
0:  		@exception XAException An error has occurred. Possible exception values
0: 		are XAER_RMERR, XAER_RMFAIL. 
1: 	 */
0: 	public final synchronized boolean isSameRM(XAResource xares) throws XAException {
0: 		checkXAActive();
1: 
0: 		if (xares instanceof EmbedXAConnection) {
1: 
0: 			return ra == ((EmbedXAConnection) xares).ra;
1: 		}
1: 
0: 		return false;
1: 	}
1: 	/**
0: 		Obtain the current transaction timeout value set for this XAResource
0: 		instance. If XAResource.setTransactionTimeout was not use prior to
0: 		invoking this method, the return value is the default timeout set for
0: 		the resource manager; otherwise, the value used in the previous
0: 		setTransactionTimeout call is returned. 
1: 
0: 		@return the transaction timeout value in seconds.
1: 	 */
0: 	public int getTransactionTimeout()
1: 	{
0: 		return 0;
1: 	}
1: 
1: 	/**
0: 		Set the current transaction timeout value for this XAResource
0: 		instance. Once set, this timeout value is effective until
0: 		setTransactionTimeout is invoked again with a different value. To reset
0: 		the timeout value to the default value used by the resource manager,
0: 		set the value to zero. If the timeout operation is performed
0: 		successfully, the method returns true; otherwise false. If a resource
0: 		manager does not support transaction timeout value to be set
0: 		explicitly, this method returns false.
1: 
0: 		@param seconds the transaction timeout value in seconds.
0: 		@return true if transaction timeout value is set successfully;
0: 		otherwise false. 
1: 
0: 		@exception XAException - An error has occurred. Possible exception
0: 		values are XAER_RMERR, XAER_RMFAIL, or XAER_INVAL.
1: 	 */
0: 	public boolean setTransactionTimeout(int seconds)
1: 	{
0: 		return false;
1: 	}
1: 
1: 	/*
1: 	** BrokeredConnectionControl api
1: 	*/
1: 	/**
1: 		Allow control over setting auto commit mode.
1: 	*/
1: 	public void checkAutoCommit(boolean autoCommit) throws SQLException {
0: 		if (autoCommit && (currentXid != null))
1: 			throw Util.generateCsSQLException(SQLState.CANNOT_AUTOCOMMIT_XA);
1: 
1: 		super.checkAutoCommit(autoCommit);
1: 	}
1: 	/**
0: 		Are held cursors allowed.
1: 	*/
0: 	public void checkHoldCursors(int holdability) throws SQLException {
1: 
0: 		if (holdability == JDBC30Translation.HOLD_CURSORS_OVER_COMMIT) {		
0: 			if (currentXid != null)
0: 				throw Util.generateCsSQLException(SQLState.CANNOT_HOLD_CURSOR_XA);
1: 		}
1: 
0: 		super.checkHoldCursors(holdability);
1: 	}
1: 
1: 	/**
1: 		Allow control over creating a Savepoint (JDBC 3.0)
1: 	*/
1: 	public void checkSavepoint() throws SQLException {
1: 
0: 		if (currentXid != null)
1: 			throw Util.generateCsSQLException(SQLState.CANNOT_ROLLBACK_XA);
1: 
1: 		super.checkSavepoint();
1: 	}
1: 
1: 	/**
1: 		Allow control over calling rollback.
1: 	*/
1: 	public void checkRollback() throws SQLException {
1: 
0: 		if (currentXid != null)
1: 			throw Util.generateCsSQLException(SQLState.CANNOT_ROLLBACK_XA);
1: 
1: 		super.checkRollback();
1: 	}
1: 	/**
1: 		Allow control over calling commit.
1: 	*/
1: 	public void checkCommit() throws SQLException {
1: 
0: 		if (currentXid != null)
1: 			throw Util.generateCsSQLException(SQLState.CANNOT_COMMIT_XA);
1: 
1: 		super.checkCommit();
1: 	}
1: 
1: 	public Connection getConnection() throws SQLException
1: 	{
1: 		Connection handle;
1: 
1: 		// Is this just a local transaction?
0: 		if (currentXid == null) {
1: 			handle = super.getConnection();
1: 		} else {
1: 
1: 			if (currentConnectionHandle != null) {
1: 				// this can only happen if someone called start(Xid),
1: 				// getConnection, getConnection (and we are now the 2nd
1: 				// getConnection call).
1: 				// Cannot yank a global connection away like, I don't think... 
1: 				throw Util.generateCsSQLException(
1: 							   SQLState.CANNOT_CLOSE_ACTIVE_XA_CONNECTION);
1: 			}
1: 
1: 			handle = getNewCurrentConnectionHandle();
1: 		}
1: 
1: 		currentConnectionHandle.syncState();
1: 
1: 		return handle;
1: 	}
1: 
1: 	/**
1: 		Wrap and control a Statement
1: 	*/
1: 	public Statement wrapStatement(Statement s) throws SQLException {
1: 		XAStatementControl sc = new XAStatementControl(this, s);
1: 		return sc.applicationStatement;
1: 	}
1: 	/**
1: 		Wrap and control a PreparedStatement
1: 	*/
1: 	public PreparedStatement wrapStatement(PreparedStatement ps, String sql, Object generatedKeys) throws SQLException {
1: 		XAStatementControl sc = new XAStatementControl(this, ps, sql, generatedKeys);
1: 		return (PreparedStatement) sc.applicationStatement;
1: 	}
1: 	/**
1: 		Wrap and control a PreparedStatement
1: 	*/
1: 	public CallableStatement wrapStatement(CallableStatement cs, String sql) throws SQLException {
1: 		XAStatementControl sc = new XAStatementControl(this, cs, sql);
1: 		return (CallableStatement) sc.applicationStatement;
1: 	}
1: 
1: 	/**
1: 		Override getRealConnection to create a a local connection
1: 		when we are not associated with an XA transaction.
1: 
1: 		This can occur if the application has a Connection object (conn)
1: 		and the following sequence occurs.
1: 
1: 		conn = xac.getConnection();
1: 		xac.start(xid, ...)
1: 		
1: 		// do work with conn
1: 
1: 		xac.end(xid, ...);
1: 
1: 		// do local work with conn
1: 		// need to create new connection here.
1: 	*/
0: 	public Connection getRealConnection() throws SQLException
1: 	{
0: 		Connection rc = super.getRealConnection();
1: 		if (rc != null)
1: 			return rc;
1: 
1: 		openRealConnection();
1: 
1: 		// a new Connection, set its state according to the application's Connection handle
1: 		currentConnectionHandle.setState(true);
1: 
1: 		return realConnection;
1: 	}
1: 
1: 
1: 	/*
0: 	** Class specific methods
1: 	*/
1: 
0: 	private XATransactionState getTransactionState(XAXactId xid_im) {
1: 
0: 		return (XATransactionState) ra.findConnection(xid_im);
1: 	}
1: 
1: 
1: 	/**
0: 		Map a SQL exception to appropriate XAException.
0: 		Return the mapped XAException.
1: 	 */
0: 	private static XAException wrapInXAException(SQLException se)
1:     {
0: 		// Map interesting exceptions to XAException
0: 		String sqlstate = se.getSQLState();
0: 		String message = se.getMessage();
1: 
0: 		XAException xae;
1: 
0: 		if (sqlstate == null)
1: 		{
0: 			// no idea what was wrong, throw non-descript error. 
0: 			if (message != null)
0: 				xae = new XAException(message);
0: 			else
0: 				xae = new XAException(XAException.XAER_RMERR);
1: 		}
0: 		else if (sqlstate.equals(StandardException.getSQLStateFromIdentifier(SQLState.STORE_XA_XAER_DUPID)))
0: 			xae = new XAException(XAException.XAER_DUPID);
0: 		else if (sqlstate.equals(StandardException.getSQLStateFromIdentifier(SQLState.STORE_XA_PROTOCOL_VIOLATION)))
0: 			xae = new XAException(XAException.XA_RBPROTO);
0: 		else if (sqlstate.equals(SQLState.DEADLOCK))
0: 			xae = new XAException(XAException.XA_RBDEADLOCK);
0: 		else if (sqlstate.equals(SQLState.LOCK_TIMEOUT))
0: 			xae = new XAException(XAException.XA_RBTIMEOUT);
0: 		else if (message != null)
0: 			xae = new XAException(message);
0: 		else
0: 			xae = new XAException(XAException.XAER_RMERR);
1: 
0: 		if (org.apache.derby.iapi.services.info.JVMInfo.JDK_ID >= 4)
0: 			xae.initCause(se);
0: 		return xae;
1: 	}
1: 	/**
0: 		Map a Standard exception to appropriate XAException.
0: 		Return the mapped XAException.
1: 	 */
0: 	private static XAException wrapInXAException(StandardException se)
1: 	{
0: 		return wrapInXAException(TransactionResourceImpl.wrapInSQLException((SQLException) null, se));
1: 	}
1: 
0: 	void removeXATransaction(XAXactId xid_im) {
0: 		XATransactionState tranState = (XATransactionState) ra.removeConnection(xid_im);
0: 		if (tranState != null)
0: 			tranState.popMe();
1: 	}
1: 
1: 
1: 	/**
0: 		Return an underlying connection object back to its XAResource
0: 		if possible. If not close the connection.
1: 	*/
0: 	private void returnConnectionToResource(XATransactionState tranState, XAXactId xid_im) {
1: 
0: 		removeXATransaction(xid_im);
1: 
0: 		synchronized (tranState) {
0: 			// global transaction is over.
0: 			tranState.associationState = XATransactionState.TC_COMPLETED;
0: 			tranState.notifyAll();
1: 
0: 			EmbedConnection20 conn = tranState.conn;
1: 
0: 			// already set in its own resource
0: 			// or can it be returned to its original resource?
0: 			if ((tranState.creatingResource.realConnection == conn) ||
0: 				(tranState.creatingResource.realConnection == null)) {
1: 
0: 				tranState.creatingResource.realConnection = conn;
1: 
0: 				BrokeredConnection handle = tranState.creatingResource.currentConnectionHandle;
1: 
0: 				conn.setApplicationConnection(handle);
1: 
0: 				if (handle != null) {
0: 					try {
0: 						handle.setState(true);
0: 					} catch (SQLException sqle) {
1: 
0: 						// couldn't reset the connection
0: 						closeUnusedConnection(tranState.conn);
0: 						tranState.creatingResource.realConnection = null;
1: 					}
1: 				}
0: 				return;
1: 			}
1: 		}
1: 
0: 		// nowhere to place it, close it.
0: 		closeUnusedConnection(tranState.conn);
1: 	}
1: 
0: 	private void checkXAActive() throws XAException {
1: 
0: 		try {
1: 			checkActive();
0: 		} catch (SQLException sqle) {
0: 			throw wrapInXAException(sqle);
1: 		}
1: 	}
1: 
0: 	private void checkUserCredentials(EmbedXAConnection original)
0: 		throws XAException {
1: 
0: 		if (original == this)
0: 			return;
1: 
0: 		if (original.getPassword().equals(getPassword()) && (original.getUsername().equals(getUsername())))
0: 			return;
1: 
1: 
0: 		throw new XAException(XAException.XA_RBINTEGRITY);
1: 	}
1: 
1: 	/**
0: 		Close  an underlying connection object when there is
0: 		no active XAResource to hand it to.
1: 	*/
0: 	private static void closeUnusedConnection(EmbedConnection20 conn) {
0: 		if (conn != null) {
0: 			try {
0: 				conn.close();
0: 			} catch (SQLException sqle) {
1: 			}
1: 		}
1: 	}
1: }
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:2f36947
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.jdbc
0:    (C) Copyright IBM Corp. 2003, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.jdbc;
0: 
0: import org.apache.derby.iapi.store.access.xa.XAXactId;
0: import org.apache.derby.iapi.store.access.xa.XAResourceManager;
0: import org.apache.derby.iapi.store.access.XATransactionController;
0: import org.apache.derby.impl.jdbc.Util;
0: import org.apache.derby.impl.jdbc.EmbedConnection20;
0: import org.apache.derby.impl.jdbc.TransactionResourceImpl;
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.jdbc.ResourceAdapter;
0: import org.apache.derby.iapi.jdbc.BrokeredConnection;
0: 
0: import org.apache.derby.iapi.services.context.ContextManager;
0: import org.apache.derby.iapi.services.context.ContextService;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.reference.JDBC30Translation;
0: 
0: import java.sql.Connection;
0: import java.sql.SQLException;
0: import java.sql.Statement;
0: import java.sql.PreparedStatement;
0: import java.sql.CallableStatement;
0: 
0: /* import jta packages */
0: import javax.transaction.xa.Xid;
0: import javax.transaction.xa.XAResource;
0: import javax.transaction.xa.XAException;
0: 
0: /** -- jdbc 2.0. extension -- */
0: import javax.sql.XAConnection;
0: 
0: /** 
0:  */
0: final class EmbedXAConnection extends EmbedPooledConnection
0: 		implements XAConnection, XAResource
0: 
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2003_2004;
0: 
0: 
0: 	final ResourceAdapter ra;
0: 
0: 	XAXactId	currentXid;
0: 
0: 
0: 	EmbedXAConnection(EmbeddedDataSource ds, ResourceAdapter ra, String u, String p, boolean requestPassword) throws SQLException
0: 	{
0: 		super(ds, u, p, requestPassword);
0: 		this.ra = ra;
0: 
0: 	}
0: 
0: 	/*
0: 	** XAConnection methods
0: 	*/
0: 
0: 	public final synchronized XAResource getXAResource() throws SQLException {
0: 		checkActive();
0: 		return this;
0: 	}
0: 
0: 	/*
0: 	** XAResource methods
0: 	*/
0: 
0: 	/**
0: 		Start work on behalf of a transaction branch specified in xid If TMJOIN
0: 		is specified, the start is for joining a transaction previously seen by
0: 		the resource manager. If TMRESUME is specified, the start is to resume
0: 		a suspended transaction specified in the parameter xid. If neither
0: 		TMJOIN nor TMRESUME is specified and the transaction specified by xid
0: 		has previously been seen by the resource manager, the resource manager
0: 		throws the XAException exception with XAER_DUPID error code.
0: 
0: 		@param xid A global transaction identifier to be associated with the
0: 				resource 
0: 		@param flags One of TMNOFLAGS, TMJOIN, or TMRESUME 
0: 
0: 		@exception XAException An error has occurred. Possible exceptions are
0: 		XA_RB*, XAER_RMERR, XAER_RMFAIL, XAER_DUPID, XAER_OUTSIDE, XAER_NOTA,
0: 		XAER_INVAL, or XAER_PROTO.
0: 	 */
0: 	public final synchronized void start(Xid xid, int flags) throws XAException
0: 	{
0: 		checkXAActive();
0: 
0: 		// JDBC 3.0 section 12.3 - One transaction associated with a XAConnection
0: 		if (currentXid != null)
0: 			throw new XAException(XAException.XAER_PROTO);
0: 
0: 		// ensure immtable and correct equals method.
0: 		XAXactId xid_im = new XAXactId(xid);
0: 
0: 		XATransactionState tranState = getTransactionState(xid_im);
0: 
0: 		switch (flags) {
0: 		case XAResource.TMNOFLAGS:
0: 			if (tranState != null)
0: 				throw new XAException(XAException.XAER_DUPID);
0: 
0: 			try {
0: 
0: 				if (realConnection == null) {
0: 					openRealConnection();
0: 
0: 					if (currentConnectionHandle != null) {
0: 
0: 						// since this is a new connection, set its complete
0: 						// state according to the application's Connection
0: 						// handle view of the world.
0: 						currentConnectionHandle.setState(true);
0: 						realConnection.setApplicationConnection(currentConnectionHandle);
0: 					}
0: 
0: 				} else {
0: 
0: 					// XAResource.start() auto commits in DB2 when in auto commit mode.
0: 					if (currentConnectionHandle != null) {
0: 						if (currentConnectionHandle.getAutoCommit())
0: 							currentConnectionHandle.rollback();
0: 					}
0: 					if (!realConnection.transactionIsIdle())
0: 						throw new XAException(XAException.XAER_OUTSIDE);
0: 
0: 					if (currentConnectionHandle != null) {
0: 
0: 						// we have a current handle so we need to keep
0: 						// the connection state of the current connection.
0: 						currentConnectionHandle.setState(true);
0: 
0: 						// At the local to global transition we need to discard
0: 						// and close any open held result sets, a rollback will do this.
0: 						realConnection.rollback();
0: 					} else {
0: 						resetRealConnection();
0: 					}
0: 
0: 				}
0: 
0: 				// Global connections are always in auto commit false mode.
0: 				realConnection.setAutoCommit(false);
0: 
0: 				// and holdability false (cannot hold cursors across XA transactions.
0: 				realConnection.setHoldability(JDBC30Translation.CLOSE_CURSORS_AT_COMMIT);
0: 
0: 				realConnection.getLanguageConnection().
0: 					getTransactionExecute().createXATransactionFromLocalTransaction(
0: 						 xid_im.getFormatId(), 
0: 						 xid_im.getGlobalTransactionId(),
0: 						 xid_im.getBranchQualifier());
0: 
0: 
0: 			} catch (StandardException se) {
0: 				throw wrapInXAException(se);
0: 			
0: 			} catch (SQLException sqle) {
0: 				throw wrapInXAException(sqle);
0: 			}
0: 
0: 
0: 			if (!ra.addConnection(xid_im, new XATransactionState(realConnection.getContextManager(), realConnection, this, xid_im)))
0: 				throw new XAException(XAException.XAER_DUPID);
0: 
0: 			break;
0: 
0: 		case XAResource.TMRESUME:
0: 		case XAResource.TMJOIN:
0: 			if (tranState == null)
0: 				throw new XAException(XAException.XAER_NOTA);
0: 
0: 			tranState.start(this, flags);
0: 
0: 			if (tranState.conn != realConnection) {
0: 
0: 				if (realConnection != null) {
0: 
0: 					if (!realConnection.transactionIsIdle())
0: 						throw new XAException(XAException.XAER_OUTSIDE);
0: 
0: 					closeUnusedConnection(realConnection);
0: 				}
0: 				realConnection = tranState.conn;
0: 
0: 				if (currentConnectionHandle != null) {
0: 
0: 					try {
0: 						// only reset the non-transaction specific Connection state.
0: 						currentConnectionHandle.setState(false);
0: 						realConnection.setApplicationConnection(currentConnectionHandle);
0: 					} catch (SQLException sqle) {
0: 						throw wrapInXAException(sqle);
0: 					}
0: 				}
0: 
0: 			}
0: 
0: 
0: 			break;
0: 
0: 		default:
0: 			throw new XAException(XAException.XAER_INVAL);
0: 		}
0: 
0: 		currentXid = xid_im;
0: 	}
0: 
0: 
0: 	/**
0: 		Ends the work performed on behalf of a transaction branch. The resource
0: 		manager disassociates the XA resource from the transaction branch
0: 		specified and let the transaction be completed.  
0: 
0: 		<p> If TMSUSPEND is specified in flags, the transaction branch is
0: 		temporarily suspended in incomplete state. The transaction context 
0: 		is in suspened state and must be resumed via start with TMRESUME
0: 		specified. 
0: 
0: 		<p> If TMFAIL is specified, the portion of work has failed. The
0: 		resource manager may mark the transaction as rollback-only 
0: 
0: 		<p> If TMSUCCESS is specified, the portion of work has completed
0: 		successfully. 
0: 
0: 		@param xid A global transaction identifier that is the same as what was
0: 				used previously in the start method. 
0: 		@param flags One of TMSUCCESS, TMFAIL, or TMSUSPEND
0: 
0: 		@exception XAException An error has occurred. 
0: 		Possible XAException values are XAER_RMERR, XAER_RMFAILED, XAER_NOTA,
0: 		XAER_INVAL, XAER_PROTO, or XA_RB*. 
0: 	 */
0: 	public final synchronized void end(Xid xid, int flags) throws XAException
0: 	{
0: 		checkXAActive();
0: 
0: 		// ensure immtable and correct equals method.
0: 		XAXactId xid_im = new XAXactId(xid);
0: 
0: 		boolean endingCurrentXid = false;
0: 
0: 		// must match the Xid from start()
0: 		if (currentXid != null) {
0: 			if (!currentXid.equals(xid_im))
0: 				throw new XAException(XAException.XAER_PROTO);
0: 			endingCurrentXid = true;
0: 		}
0: 
0: 		XATransactionState tranState = getTransactionState(xid_im);
0: 		if (tranState == null)
0: 			throw new XAException(XAException.XAER_NOTA);
0: 
0: 		boolean rollbackOnly = tranState.end(this, flags, endingCurrentXid);
0: 
0: 		// RESOLVE - what happens to the connection on a fail
0: 		// where we are not ending the current XID.
0: 		if (endingCurrentXid) {
0: 			currentXid = null;
0: 
0: 			realConnection = null;
0: 		}
0: 
0: 		if (rollbackOnly)
0: 			throw new XAException(tranState.rollbackOnlyCode); 
0: 
0: 	}
0: 
0: 	/**
0: 		Ask the resource manager to prepare for a transaction commit of the
0: 		transaction specified in xid. 
0: 
0: 		@param xid A global transaction identifier
0: 
0: 		@return A value indicating the resource manager's vote on the outcome
0: 		of the transaction. The possible values are: XA_RDONLY or XA_OK. If the
0: 		resource manager wants to roll back the transaction, it should do so by
0: 		raising an appropriate XAException in the prepare method.
0: 
0: 		@exception XAException An error has occurred. Possible exception values
0: 		are: XA_RB*, XAER_RMERR, XAER_RMFAIL, XAER_NOTA, XAER_INVAL, or
0: 		XAER_PROTO.
0: 
0: 	 */
0: 	public final synchronized int prepare(Xid xid) throws XAException
0: 	{
0: 		checkXAActive();
0: 
0: 		// ensure immtable and correct equals method.
0: 		XAXactId xid_im = new XAXactId(xid);
0: 
0: 		XATransactionState tranState = getTransactionState(xid_im);
0: 
0: 		if (tranState == null) {
0: 			XAResourceManager rm = ra.getXAResourceManager();
0: 
0: 			ContextManager inDoubtCM = rm.find(xid);
0: 
0: 			// RM also does not know about this xid.
0: 			if (inDoubtCM == null)
0: 				throw new XAException(XAException.XAER_NOTA);
0: 
0: 			// cannot prepare in doubt transactions
0: 			throw new XAException(XAException.XAER_PROTO);
0: 
0: 		}
0: 
0: 		synchronized (tranState) {
0: 
0: 			checkUserCredentials(tranState.creatingResource);
0: 
0: 			// Check the transaction is no associated with
0: 			// any XAResource.
0: 			switch (tranState.associationState) {
0: 			case XATransactionState.T0_NOT_ASSOCIATED:
0: 				break;
0: 
0: 			case XATransactionState.TRO_FAIL:
0: 				throw new XAException(tranState.rollbackOnlyCode);
0: 
0: 			default:
0: 				throw new XAException(XAException.XAER_PROTO);
0: 			}
0: 
0: 			if (tranState.suspendedList != null && tranState.suspendedList.size() != 0)
0: 				throw new XAException(XAException.XAER_PROTO);
0: 
0: 			if (tranState.isPrepared)
0: 				throw new XAException(XAException.XAER_PROTO);
0: 
0: 			EmbedConnection20 conn = tranState.conn; 
0: 
0: 			try {
0: 
0: 				int ret = conn.xa_prepare();
0: 
0: 				if (ret == XATransactionController.XA_OK) {
0: 					tranState.isPrepared = true;
0: 
0: 					return XAResource.XA_OK;
0: 				} else {
0: 
0: 					returnConnectionToResource(tranState, xid_im);
0: 					return XAResource.XA_RDONLY;
0: 				}
0: 			} catch (SQLException sqle) {
0: 				throw wrapInXAException(sqle);
0: 			}
0: 		}
0: 	
0: 	}
0: 
0: 	/**
0: 		Commit the global transaction specified by xid.
0: 		@param xid A global transaction identifier
0: 		@param onePhase If true, the resource manager should use a one-phase
0: 				commit protocol to commit the work done on behalf of xid.
0: 
0: 		@exception XAException An error has occurred. Possible XAExceptions are
0: 				XA_HEURHAZ, XA_HEURCOM, XA_HEURRB, XA_HEURMIX, XAER_RMERR,
0: 				XAER_RMFAIL, XAER_NOTA, XAER_INVAL, or XAER_PROTO.  
0: 				<P>If the resource manager did not commit the transaction and
0: 				the paramether onePhase is set to true, the resource manager 
0: 				may throw one of the XA_RB* exceptions. Upon return, the
0: 				resource manager has rolled back the branch's work and has 
0: 				released all held resources.
0: 	*/
0: 	public final synchronized void commit(Xid xid, boolean onePhase) throws XAException
0: 	{
0: 		checkXAActive();
0: 
0: 		// ensure immtable and correct equals method.
0: 		XAXactId xid_im = new XAXactId(xid);
0: 
0: 		XATransactionState tranState = getTransactionState(xid_im);
0: 
0: 		if (tranState == null) {
0: 
0: 			XAResourceManager rm = ra.getXAResourceManager();
0: 
0: 			ContextManager inDoubtCM = rm.find(xid);
0: 
0: 			// RM also does not know about this xid.
0: 			if (inDoubtCM == null)
0: 				throw new XAException(XAException.XAER_NOTA);
0: 
0: 			ContextService csf = ContextService.getFactory();
0: 
0: 			csf.setCurrentContextManager(inDoubtCM);
0: 			try
0: 			{
0: 				rm.commit(inDoubtCM, xid_im, onePhase);
0: 
0: 				// close the connection/transaction since it can never be used again.
0: 				inDoubtCM.cleanupOnError(StandardException.closeException());
0: 				return;
0: 			}
0: 			catch (StandardException se)
0: 			{
0: 				// The rm threw an exception, clean it up in the approprate
0: 				// context.  There is no transactionResource to handle the
0: 				// exception for us.
0: 				inDoubtCM.cleanupOnError(se);
0: 				throw wrapInXAException(se);
0: 			}
0: 			finally
0: 			{
0: 				csf.resetCurrentContextManager(inDoubtCM);
0: 			}
0: 
0: 		}
0: 
0: 		synchronized (tranState) {
0: 			checkUserCredentials(tranState.creatingResource);
0: 		
0: 			// Check the transaction is no associated with
0: 			// any XAResource.
0: 			switch (tranState.associationState) {
0: 			case XATransactionState.T0_NOT_ASSOCIATED:
0: 				break;
0: 
0: 			case XATransactionState.TRO_FAIL:
0: 				throw new XAException(tranState.rollbackOnlyCode);
0: 
0: 			default:
0: 				throw new XAException(XAException.XAER_PROTO);
0: 			}
0: 
0: 			if (tranState.suspendedList != null && tranState.suspendedList.size() != 0)
0: 				throw new XAException(XAException.XAER_PROTO);
0: 
0: 			if (tranState.isPrepared == onePhase)
0: 				throw new XAException(XAException.XAER_PROTO);
0: 
0: 			EmbedConnection20 conn = tranState.conn; 
0: 
0: 			try {
0: 
0: 				conn.xa_commit(onePhase);
0: 
0: 			} catch (SQLException sqle) {
0: 				throw wrapInXAException(sqle);
0: 			} finally {
0: 				returnConnectionToResource(tranState, xid_im);
0: 			}
0: 		}
0: 	}
0: 
0: 	/** 
0: 		Inform the resource manager to roll back work done on behalf of a
0: 		transaction branch
0: 
0: 		@param xid A global transaction identifier
0: 		@exception XAException - An error has occurred 
0: 	*/
0: 	public final synchronized void rollback(Xid xid) throws XAException
0: 	{
0: 		checkXAActive();
0: 
0: 		// ensure immtable and correct equals method.
0: 		XAXactId xid_im = new XAXactId(xid);
0: 
0: 		XATransactionState tranState = getTransactionState(xid_im);
0: 
0: 		if (tranState == null) {
0: 			XAResourceManager rm = ra.getXAResourceManager();
0: 
0: 			ContextManager inDoubtCM = rm.find(xid);
0: 
0: 			// RM also does not know about this xid.
0: 			if (inDoubtCM == null)
0: 				throw new XAException(XAException.XAER_NOTA);
0: 
0: 			ContextService csf = ContextService.getFactory();
0: 
0: 			csf.setCurrentContextManager(inDoubtCM);
0: 			try
0: 			{
0: 				rm.rollback(inDoubtCM, xid_im);
0: 
0: 				// close the connection/transaction since it can never be used again.
0: 				inDoubtCM.cleanupOnError(StandardException.closeException());
0: 				return;
0: 			}
0: 			catch (StandardException se)
0: 			{
0: 				// The rm threw an exception, clean it up in the approprate
0: 				// context.  There is no transactionResource to handle the
0: 				// exception for us.
0: 				inDoubtCM.cleanupOnError(se);
0: 				throw wrapInXAException(se);
0: 			}
0: 			finally
0: 			{
0: 				csf.resetCurrentContextManager(inDoubtCM);
0: 			}
0: 
0: 		}
0: 
0: 		synchronized (tranState) {
0: 		
0: 			// Check the transaction is no associated with
0: 			// any XAResource.
0: 			switch (tranState.associationState) {
0: 			case XATransactionState.T0_NOT_ASSOCIATED:
0: 			case XATransactionState.TRO_FAIL:
0: 				break;
0: 				
0: 			default:
0: 				throw new XAException(XAException.XAER_PROTO);
0: 			}
0: 
0: 			if (tranState.suspendedList != null && tranState.suspendedList.size() != 0)
0: 				throw new XAException(XAException.XAER_PROTO);
0: 
0: 			checkUserCredentials(tranState.creatingResource);
0: 
0: 			try {
0: 
0: 				tranState.conn.xa_rollback();
0: 			} catch (SQLException sqle) {
0: 				throw wrapInXAException(sqle);
0: 			} finally {
0: 				returnConnectionToResource(tranState, xid_im);
0: 			}
0: 		}
0: 	}
0: 
0: 	/**
0: 		Obtain a list of prepared transaction branches from a resource
0: 		manager. The transaction manager calls this method during recovery to
0: 		obtain the list of transaction branches that are currently in prepared
0: 		or heuristically completed states. 
0: 
0: 		@param flag One of TMSTARTRSCAN, TMENDRSCAN, TMNOFLAGS. TMNOFLAGS must
0: 		be used when no other flags are set in flags.
0: 
0: 		@return The resource manager returns zero or more XIDs for the
0: 		transaction branches that are currently in a prepared or heuristically
0: 		completed state. If an error occurs during the operation, the resource
0: 		manager should throw the appropriate XAException.
0: 
0: 		@exception XAException An error has occurred. Possible values are
0: 		XAER_RMERR, XAER_RMFAIL, XAER_INVAL, and XAER_PROTO.
0: 
0: 	*/
0: 	public final synchronized Xid[] recover(int flag) throws XAException
0: 	{
0: 		checkXAActive();
0: 
0: 		try
0: 		{
0: 			return ra.getXAResourceManager().recover(flag);
0: 		}
0: 		catch (StandardException se)
0: 		{
0: 			throw wrapInXAException(se);
0: 		}
0: 	}
0: 
0: 	/**
0: 		Tell the resource manager to forget about a heuristically completed
0: 		transaction branch. 
0: 
0: 		@param xid A global transaction identifier
0: 		@exception XAException An error has occurred. Possible exception values
0: 		are XAER_RMERR, XAER_RMFAIL, XAER_NOTA, XAER_INVAL, or XAER_PROTO.
0: 	 */
0: 	public final synchronized void forget(Xid xid) throws XAException {
0: 
0: 		checkXAActive();
0: 
0: 		// ensure immtable and correct equals method.
0: 		XAXactId xid_im = new XAXactId(xid);
0: 
0: 		XATransactionState tranState = getTransactionState(xid_im);
0: 		if (tranState == null) {
0: 			XAResourceManager rm = ra.getXAResourceManager();
0: 
0: 			ContextManager inDoubtCM = rm.find(xid);
0: 
0: 			// RM also does not know about this xid.
0: 			if (inDoubtCM == null)
0: 				throw new XAException(XAException.XAER_NOTA);
0: 
0: 			ContextService csf = ContextService.getFactory();
0: 
0: 			csf.setCurrentContextManager(inDoubtCM);
0: 			try
0: 			{
0: 				rm.forget(inDoubtCM, xid_im);
0: 
0: 				// close the connection/transaction since it can never be used again.
0: 				inDoubtCM.cleanupOnError(StandardException.closeException());
0: 				return;
0: 			}
0: 			catch (StandardException se)
0: 			{
0: 				// The rm threw an exception, clean it up in the approprate
0: 				// context.  There is no transactionResource to handle the
0: 				// exception for us.
0: 				inDoubtCM.cleanupOnError(se);
0: 				throw wrapInXAException(se);
0: 			}
0: 			finally
0: 			{
0: 				csf.resetCurrentContextManager(inDoubtCM);
0: 			}
0: 
0: 		}
0: 
0: 		throw new XAException(tranState.isPrepared ? XAException.XAER_NOTA : XAException.XAER_PROTO);
0: 
0: 	}
0: 	/** 
0: 		This method is called to determine if the resource manager instance
0: 		represented by the target object is the same as the resouce manager
0: 		instance represented by the parameter xares.
0: 
0: 		@param xares An XAResource object whose resource manager instance is to
0: 		be compared with the resource manager instance of the target object.
0: 
0: 		@return true if it's the same RM instance; otherwise false.
0:  		@exception XAException An error has occurred. Possible exception values
0: 		are XAER_RMERR, XAER_RMFAIL. 
0: 	 */
0: 	public final synchronized boolean isSameRM(XAResource xares) throws XAException {
0: 		checkXAActive();
0: 
0: 		if (xares instanceof EmbedXAConnection) {
0: 
0: 			return ra == ((EmbedXAConnection) xares).ra;
0: 		}
0: 
0: 		return false;
0: 	}
0: 	/**
0: 		Obtain the current transaction timeout value set for this XAResource
0: 		instance. If XAResource.setTransactionTimeout was not use prior to
0: 		invoking this method, the return value is the default timeout set for
0: 		the resource manager; otherwise, the value used in the previous
0: 		setTransactionTimeout call is returned. 
0: 
0: 		@return the transaction timeout value in seconds.
0: 	 */
0: 	public int getTransactionTimeout()
0: 	{
0: 		return 0;
0: 	}
0: 
0: 	/**
0: 		Set the current transaction timeout value for this XAResource
0: 		instance. Once set, this timeout value is effective until
0: 		setTransactionTimeout is invoked again with a different value. To reset
0: 		the timeout value to the default value used by the resource manager,
0: 		set the value to zero. If the timeout operation is performed
0: 		successfully, the method returns true; otherwise false. If a resource
0: 		manager does not support transaction timeout value to be set
0: 		explicitly, this method returns false.
0: 
0: 		@param seconds the transaction timeout value in seconds.
0: 		@return true if transaction timeout value is set successfully;
0: 		otherwise false. 
0: 
0: 		@exception XAException - An error has occurred. Possible exception
0: 		values are XAER_RMERR, XAER_RMFAIL, or XAER_INVAL.
0: 	 */
0: 	public boolean setTransactionTimeout(int seconds)
0: 	{
0: 		return false;
0: 	}
0: 
0: 	/*
0: 	** BrokeredConnectionControl api
0: 	*/
0: 	/**
0: 		Allow control over setting auto commit mode.
0: 	*/
0: 	public void checkAutoCommit(boolean autoCommit) throws SQLException {
0: 		if (autoCommit && (currentXid != null))
0: 			throw Util.generateCsSQLException(SQLState.CANNOT_AUTOCOMMIT_XA);
0: 
0: 		super.checkAutoCommit(autoCommit);
0: 	}
0: 	/**
0: 		Are held cursors allowed.
0: 	*/
0: 	public void checkHoldCursors(int holdability) throws SQLException {
0: 
0: 		if (holdability == JDBC30Translation.HOLD_CURSORS_OVER_COMMIT) {		
0: 			if (currentXid != null)
0: 				throw Util.generateCsSQLException(SQLState.CANNOT_HOLD_CURSOR_XA);
0: 		}
0: 
0: 		super.checkHoldCursors(holdability);
0: 	}
0: 
0: 	/**
0: 		Allow control over creating a Savepoint (JDBC 3.0)
0: 	*/
0: 	public void checkSavepoint() throws SQLException {
0: 
0: 		if (currentXid != null)
0: 			throw Util.generateCsSQLException(SQLState.CANNOT_ROLLBACK_XA);
0: 
0: 		super.checkSavepoint();
0: 	}
0: 
0: 	/**
0: 		Allow control over calling rollback.
0: 	*/
0: 	public void checkRollback() throws SQLException {
0: 
0: 		if (currentXid != null)
0: 			throw Util.generateCsSQLException(SQLState.CANNOT_ROLLBACK_XA);
0: 
0: 		super.checkRollback();
0: 	}
0: 	/**
0: 		Allow control over calling commit.
0: 	*/
0: 	public void checkCommit() throws SQLException {
0: 
0: 		if (currentXid != null)
0: 			throw Util.generateCsSQLException(SQLState.CANNOT_COMMIT_XA);
0: 
0: 		super.checkCommit();
0: 	}
0: 
0: 	public Connection getConnection() throws SQLException
0: 	{
0: 		Connection handle;
0: 
0: 		// Is this just a local transaction?
0: 		if (currentXid == null) {
0: 			handle = super.getConnection();
0: 		} else {
0: 
0: 			if (currentConnectionHandle != null) {
0: 				// this can only happen if someone called start(Xid),
0: 				// getConnection, getConnection (and we are now the 2nd
0: 				// getConnection call).
0: 				// Cannot yank a global connection away like, I don't think... 
0: 				throw Util.generateCsSQLException(
0: 							   SQLState.CANNOT_CLOSE_ACTIVE_XA_CONNECTION);
0: 			}
0: 
0: 			handle = getNewCurrentConnectionHandle();
0: 		}
0: 
0: 		currentConnectionHandle.syncState();
0: 
0: 		return handle;
0: 	}
0: 
0: 	/**
0: 		Wrap and control a Statement
0: 	*/
0: 	public Statement wrapStatement(Statement s) throws SQLException {
0: 		XAStatementControl sc = new XAStatementControl(this, s);
0: 		return sc.applicationStatement;
0: 	}
0: 	/**
0: 		Wrap and control a PreparedStatement
0: 	*/
0: 	public PreparedStatement wrapStatement(PreparedStatement ps, String sql, Object generatedKeys) throws SQLException {
0: 		XAStatementControl sc = new XAStatementControl(this, ps, sql, generatedKeys);
0: 		return (PreparedStatement) sc.applicationStatement;
0: 	}
0: 	/**
0: 		Wrap and control a PreparedStatement
0: 	*/
0: 	public CallableStatement wrapStatement(CallableStatement cs, String sql) throws SQLException {
0: 		XAStatementControl sc = new XAStatementControl(this, cs, sql);
0: 		return (CallableStatement) sc.applicationStatement;
0: 	}
0: 
0: 	/**
0: 		Override getRealConnection to create a a local connection
0: 		when we are not associated with an XA transaction.
0: 
0: 		This can occur if the application has a Connection object (conn)
0: 		and the following sequence occurs.
0: 
0: 		conn = xac.getConnection();
0: 		xac.start(xid, ...)
0: 		
0: 		// do work with conn
0: 
0: 		xac.end(xid, ...);
0: 
0: 		// do local work with conn
0: 		// need to create new connection here.
0: 	*/
0: 	public Connection getRealConnection() throws SQLException
0: 	{
0: 		Connection rc = super.getRealConnection();
0: 		if (rc != null)
0: 			return rc;
0: 
0: 		openRealConnection();
0: 
0: 		// a new Connection, set its state according to the application's Connection handle
0: 		currentConnectionHandle.setState(true);
0: 
0: 		return realConnection;
0: 	}
0: 
0: 
0: 	/*
0: 	** Class specific methods
0: 	*/
0: 
0: 	private XATransactionState getTransactionState(XAXactId xid_im) {
0: 
0: 		return (XATransactionState) ra.findConnection(xid_im);
0: 	}
0: 
0: 
0: 	/**
0: 		Map a SQL exception to appropriate XAException.
0: 		Return the mapped XAException.
0: 	 */
0: 	private static XAException wrapInXAException(SQLException se)
0:     {
0: 		// Map interesting exceptions to XAException
0: 		String sqlstate = se.getSQLState();
0: 		String message = se.getMessage();
0: 
0: 		XAException xae;
0: 
0: 		if (sqlstate == null)
0: 		{
0: 			// no idea what was wrong, throw non-descript error. 
0: 			if (message != null)
0: 				xae = new XAException(message);
0: 			else
0: 				xae = new XAException(XAException.XAER_RMERR);
0: 		}
0: 		else if (sqlstate.equals(StandardException.getSQLStateFromIdentifier(SQLState.STORE_XA_XAER_DUPID)))
0: 			xae = new XAException(XAException.XAER_DUPID);
0: 		else if (sqlstate.equals(StandardException.getSQLStateFromIdentifier(SQLState.STORE_XA_PROTOCOL_VIOLATION)))
0: 			xae = new XAException(XAException.XA_RBPROTO);
0: 		else if (sqlstate.equals(SQLState.DEADLOCK))
0: 			xae = new XAException(XAException.XA_RBDEADLOCK);
0: 		else if (sqlstate.equals(SQLState.LOCK_TIMEOUT))
0: 			xae = new XAException(XAException.XA_RBTIMEOUT);
0: 		else if (message != null)
0: 			xae = new XAException(message);
0: 		else
0: 			xae = new XAException(XAException.XAER_RMERR);
0: 
0: 		if (org.apache.derby.iapi.services.info.JVMInfo.JDK_ID >= 4)
0: 			xae.initCause(se);
0: 		return xae;
0: 	}
0: 	/**
0: 		Map a Standard exception to appropriate XAException.
0: 		Return the mapped XAException.
0: 	 */
0: 	private static XAException wrapInXAException(StandardException se)
0: 	{
0: 		return wrapInXAException(TransactionResourceImpl.wrapInSQLException((SQLException) null, se));
0: 	}
0: 
0: 	void removeXATransaction(XAXactId xid_im) {
0: 		XATransactionState tranState = (XATransactionState) ra.removeConnection(xid_im);
0: 		if (tranState != null)
0: 			tranState.popMe();
0: 	}
0: 
0: 
0: 	/**
0: 		Return an underlying connection object back to its XAResource
0: 		if possible. If not close the connection.
0: 	*/
0: 	private void returnConnectionToResource(XATransactionState tranState, XAXactId xid_im) {
0: 
0: 		removeXATransaction(xid_im);
0: 
0: 		synchronized (tranState) {
0: 			// global transaction is over.
0: 			tranState.associationState = XATransactionState.TC_COMPLETED;
0: 			tranState.notifyAll();
0: 
0: 			EmbedConnection20 conn = tranState.conn;
0: 
0: 			// already set in its own resource
0: 			// or can it be returned to its original resource?
0: 			if ((tranState.creatingResource.realConnection == conn) ||
0: 				(tranState.creatingResource.realConnection == null)) {
0: 
0: 				tranState.creatingResource.realConnection = conn;
0: 
0: 				BrokeredConnection handle = tranState.creatingResource.currentConnectionHandle;
0: 
0: 				conn.setApplicationConnection(handle);
0: 
0: 				if (handle != null) {
0: 					try {
0: 						handle.setState(true);
0: 					} catch (SQLException sqle) {
0: 
0: 						// couldn't reset the connection
0: 						closeUnusedConnection(tranState.conn);
0: 						tranState.creatingResource.realConnection = null;
0: 					}
0: 				}
0: 				return;
0: 			}
0: 		}
0: 
0: 		// nowhere to place it, close it.
0: 		closeUnusedConnection(tranState.conn);
0: 	}
0: 
0: 	private void checkXAActive() throws XAException {
0: 
0: 		try {
0: 			checkActive();
0: 		} catch (SQLException sqle) {
0: 			throw wrapInXAException(sqle);
0: 		}
0: 	}
0: 
0: 	private void checkUserCredentials(EmbedXAConnection original)
0: 		throws XAException {
0: 
0: 		if (original == this)
0: 			return;
0: 
0: 		if (original.getPassword().equals(getPassword()) && (original.getUsername().equals(getUsername())))
0: 			return;
0: 
0: 
0: 		throw new XAException(XAException.XA_RBINTEGRITY);
0: 	}
0: 
0: 	/**
0: 		Close  an underlying connection object when there is
0: 		no active XAResource to hand it to.
0: 	*/
0: 	private static void closeUnusedConnection(EmbedConnection20 conn) {
0: 		if (conn != null) {
0: 			try {
0: 				conn.close();
0: 			} catch (SQLException sqle) {
0: 			}
0: 		}
0: 	}
0: }
============================================================================