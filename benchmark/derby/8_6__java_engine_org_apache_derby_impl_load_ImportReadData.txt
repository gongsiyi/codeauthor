1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.load.ImportReadData
1:345de35: 
1:6d913c6:    Licensed to the Apache Software Foundation (ASF) under one or more
1:6d913c6:    contributor license agreements.  See the NOTICE file distributed with
1:6d913c6:    this work for additional information regarding copyright ownership.
1:6d913c6:    The ASF licenses this file to You under the Apache License, Version 2.0
1:6d913c6:    (the "License"); you may not use this file except in compliance with
1:6d913c6:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
11:eac0369: 
2:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.load;
1:eac0369: 
1:eac0369: import java.io.BufferedReader;
1:eac0369: import java.io.FileNotFoundException;
1:eac0369: import java.io.InputStream;
1:eac0369: import java.io.InputStreamReader;
1:eac0369: import java.io.FileInputStream;
1:eac0369: import java.io.IOException;
1:e17a43d: import java.io.File;
1:eac0369: import java.net.MalformedURLException;
1:eac0369: import java.net.URL;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:84e347a: import java.sql.SQLException;
1:eac0369: 
1:400f6eb: final class ImportReadData implements java.security.PrivilegedExceptionAction<Object> {
1:eac0369:   //Read data from this file
1:eac0369:   private String inputFileName;
1:ea2e939:   //The number of header lines to be skipped.
1:ea2e939:   private short skipLines;
1:eac0369:   private int[] columnWidths;
1:eac0369:   private int rowWidth;
1:eac0369:   private char[] tempString;
1:eac0369:   private int numberOfCharsReadSoFar;
1:eac0369: 
1:eac0369:   //temporary variables
1:eac0369:   private BufferedReader bufferedReader;
1:eac0369: 
1:eac0369:   //temporary variable which holds each token as we are building it.
1:eac0369:   private static final int START_SIZE = 10240;
1:eac0369:   private char[] currentToken = new char[START_SIZE];
1:eac0369:   private int currentTokenMaxSize = START_SIZE;
1:eac0369: 
1:eac0369:   //This tells whether to look for a matching stop pattern
1:eac0369:   boolean foundStartDelimiter;
1:eac0369:   int totalCharsSoFar;
1:eac0369:   //following is used to ignore whitespaces in the front
1:eac0369:   int positionOfNonWhiteSpaceCharInFront;
1:eac0369:   //following is used to ignore whitespaces in the back
1:eac0369:   int positionOfNonWhiteSpaceCharInBack;
1:eac0369:   int lineNumber;
1:eac0369:   int fieldStartDelimiterIndex;
1:eac0369:   int fieldStopDelimiterIndex;
1:eac0369:   int stopDelimiterPosition;
1:eac0369:   boolean foundStartAndStopDelimiters;
1:eac0369: 
1:eac0369:   //in the constructor we open the stream only if it's delimited file to find out
1:eac0369:   //number of columns. In case of fixed, we know that already from the control file.
1:eac0369:   //then we close the stream. Now the stream is reopened when the first record is
1:eac0369:   //read from the file(ie when the first time next is issued. This was done for the
1:eac0369:   //bug 1032 filed by Dan
1:eac0369:   boolean streamOpenForReading;
1:eac0369: 
1:eac0369:   static final int DEFAULT_FORMAT_CODE = 0;
1:eac0369:   static final int ASCII_FIXED_FORMAT_CODE = 1;
1:eac0369:   private int formatCode = DEFAULT_FORMAT_CODE;
1:eac0369:   private boolean hasColumnDefinition;
1:eac0369:   private char recordSeparatorChar0;
1:eac0369:   private char fieldSeparatorChar0;
1:eac0369:   private boolean recordSepStartNotWhite = true;
1:eac0369:   private boolean fieldSepStartNotWhite = true;
1:eac0369: 
1:eac0369:   //get properties infr from following
1:eac0369:   protected ControlInfo controlFileReader;
1:eac0369: 
1:eac0369:   //Read first row to find out how many columns make up a row and put it in
1:eac0369:   //the following variable
1:eac0369:   protected int numberOfColumns;
1:eac0369:  
1:eac0369:   // the types of the columns that we are about to read
1:eac0369:   protected String [] columnTypes;
1:eac0369:   
1:eac0369:   //Read control file properties and write it in here
1:eac0369:   protected char[] fieldSeparator;
1:eac0369:   protected int fieldSeparatorLength;
1:eac0369:   protected char[] recordSeparator;
1:eac0369:   protected int recordSeparatorLength;
1:eac0369:   protected String nullString;
1:eac0369:   protected String columnDefinition;
1:eac0369:   protected String format;
1:eac0369:   protected String dataCodeset;
1:eac0369:   protected char[] fieldStartDelimiter;
1:eac0369:   protected int fieldStartDelimiterLength;
1:eac0369:   protected char[] fieldStopDelimiter;
1:eac0369:   protected int fieldStopDelimiterLength;
1:eac0369:   protected boolean hasDelimiterAtEnd;
1:84e347a: 
1:84e347a: 
1:84e347a:   // variables realted to reading lob data from files.
1:3568cea:   private ImportLobFile[] lobFileHandles; // lob file handle object 
1:84e347a:   private String lobFileName; // current file name
1:62ab900:   private long lobOffset; // offset of the current large object
1:84e347a:   private int lobLength; //length of the current large object
1:84e347a: 
1:eac0369: 
1:eac0369:   //load the control file properties info locally, since we need to refer to them
1:eac0369:   //all the time while looking for tokens
1:eac0369:   private void loadPropertiesInfo() throws Exception {
1:eac0369:     fieldSeparator = controlFileReader.getFieldSeparator().toCharArray();
1:eac0369:     fieldSeparatorLength = fieldSeparator.length;
1:eac0369:     recordSeparator = controlFileReader.getRecordSeparator().toCharArray();
1:eac0369:     recordSeparatorLength = recordSeparator.length;
1:eac0369:     nullString = controlFileReader.getNullString();
1:eac0369:     columnDefinition = controlFileReader.getColumnDefinition();
1:eac0369:     format = controlFileReader.getFormat();
1:eac0369:     dataCodeset = controlFileReader.getDataCodeset();
1:eac0369:     fieldStartDelimiter = controlFileReader.getFieldStartDelimiter().toCharArray();
1:eac0369:     fieldStartDelimiterLength = fieldStartDelimiter.length;
1:eac0369:     fieldStopDelimiter = controlFileReader.getFieldEndDelimiter().toCharArray();
1:eac0369:     fieldStopDelimiterLength = fieldStopDelimiter.length;
1:eac0369:     hasDelimiterAtEnd = controlFileReader.getHasDelimiterAtEnd();
1:eac0369: 
1:eac0369:     // when record or field separators start with typical white space,
1:eac0369:     // we can't ignore it around values in the import file.  So set up
1:eac0369:     // a boolean so we don't keep re-testing for it.
1:eac0369:     if (recordSeparatorLength >0) {
1:eac0369:       recordSeparatorChar0=recordSeparator[0];
1:eac0369:       recordSepStartNotWhite = (Character.isWhitespace(recordSeparatorChar0)==false);
3:eac0369:     }
1:eac0369:     if (fieldSeparatorLength >0) {
1:eac0369:       fieldSeparatorChar0=fieldSeparator[0];
1:eac0369:       fieldSepStartNotWhite = (Character.isWhitespace(fieldSeparatorChar0)==false);
1:eac0369:     }
1:eac0369:   }
1:eac0369:   //inputFileName: File to read data from
1:eac0369:   //controlFileReader: File used to interpret data in the inputFileName
1:ea2e939:   ImportReadData(String inputFileName, ControlInfo controlFileReader,short skipLines)
1:eac0369:   throws Exception {
1:ea2e939:     this.skipLines=skipLines;
1:eac0369:     this.inputFileName = inputFileName;
1:eac0369:     this.controlFileReader = controlFileReader;
1:eac0369: 
1:eac0369:     //load the control file properties info locally, since we need to refer to
1:eac0369:     //them all the time while looking for tokens
1:eac0369:     loadPropertiesInfo();
1:eac0369:     //read the first row to find how many columns make a row and then save that
1:eac0369:     //column information for further use
1:eac0369:     loadMetaData();
1:3568cea: 
1:3568cea:     lobFileHandles = new ImportLobFile[numberOfColumns];
1:3568cea: 
1:eac0369:   }
1:eac0369: 
1:eac0369:   //just a getter returning number of columns for a row in the data file
1:7a92d1f:   int getNumberOfColumns() {
1:eac0369:     return numberOfColumns;
1:eac0369:   }
1:eac0369:   /**if columndefinition is true, ignore first row. The way to do that is to just
1:eac0369:   *  look for the record separator
1:eac0369:  	* @exception	Exception if there is an error
1:eac0369: 	*/
1:eac0369:   protected void ignoreFirstRow() throws Exception {
1:eac0369:     readNextToken(recordSeparator, 0, recordSeparatorLength, true);
1:eac0369:   }
1:bb55cc3: 
1:eac0369: 
1:bb55cc3:   /**if skipHeaderLines is greater than 0, ignore skipHeaderLines number of lines. The way to do that is to just
1:bb55cc3:   *  look for the record separator
1:bb55cc3:  	* @exception	Exception if there is an error
1:bb55cc3: 	*/
1:bb55cc3:   protected void ignoreHeaderLines() throws Exception {
1:bb55cc3:     for(int i =0;i<skipLines;i++){
1:bb55cc3:        if(!readNextToken(recordSeparator, 0, recordSeparatorLength, true))
1:bb55cc3:           throw LoadError.unexpectedEndOfFile(lineNumber+1);
1:83668f1:        lineNumber++;
1:bb55cc3:     }
1:bb55cc3:   }
1:bb55cc3: 
1:bb55cc3: 
1:eac0369:   /** load the column types from the meta data line to be analyzed
1:eac0369:     * later in the constructor of the ImportResultSetMetaData.
1:eac0369: 	*/
1:eac0369:   protected void loadColumnTypes() throws Exception {
1:eac0369:     int idx;
1:eac0369:     String [] metaDataArray;
1:eac0369: 
1:eac0369:     // start by counting the number of columns that we have at the
1:eac0369:     // meta data line
1:eac0369:     findNumberOfColumnsInARow();
1:eac0369: 
1:eac0369:     // reopen the file to the start of the file to read the actual column types data
1:eac0369: 	closeStream();
1:eac0369: 	openFile();
1:eac0369: 
1:eac0369:     // make room for the meta data
1:eac0369:     metaDataArray=new String [numberOfColumns];
1:eac0369: 
1:eac0369:     // read the meta data line line - meta data is always in a delimited format
1:eac0369:     readNextDelimitedRow(metaDataArray);
1:eac0369: 
1:eac0369:     // allocate space for the columnTypes  meta data
1:eac0369:     // since the meta data line contains a combination of column name and
1:eac0369:     // column type for every column we actually have only half the number of
1:eac0369:     // columns that was counted.
1:eac0369:     columnTypes=new String[numberOfColumns/2];
1:eac0369: 
1:eac0369:     for(idx=0 ; idx<numberOfColumns ; idx=idx+2) {
1:eac0369:       columnTypes[idx/2]=metaDataArray[idx+1];
1:eac0369:     }
1:eac0369: 
1:eac0369: 
1:eac0369:     // reopen to the start of the file so the rest of the program will
1:eac0369:     // work as expected
1:eac0369: 	closeStream();
1:eac0369: 	openFile();
1:eac0369: 
1:eac0369:     // init the numberOfColumns variable since it is
1:eac0369:     // being accumulate by the findNumberOfColumnsInARow method
1:eac0369:     numberOfColumns=0;
1:eac0369:   }
1:eac0369: 
1:eac0369:   private void openFile() throws Exception {
1:eac0369: 	try {
1:eac0369: 		java.security.AccessController.doPrivileged(this);
1:eac0369: 	} catch (java.security.PrivilegedActionException pae) {
1:eac0369: 		throw pae.getException();
1:eac0369: 	}
1:eac0369:   }
1:eac0369: 
1:eac0369:   public final Object run() throws Exception {
1:eac0369: 	  realOpenFile();
1:eac0369: 	  return null;
1:eac0369:   }
1:eac0369: 
1:eac0369:   //open the input data file for reading
1:eac0369:   private void realOpenFile() throws Exception {
1:18c4da7: 	  InputStream inputStream;
1:eac0369:     try {
1:eac0369:       try {
1:eac0369:         URL url = new URL(inputFileName);
1:eac0369:         if (url.getProtocol().equals("file")) { //this means it's a file url
1:eac0369:            inputFileName = url.getFile(); //seems like you can't do openstream on file
1:eac0369:            throw new MalformedURLException(); //so, get the filename from url and do it ususal way
1:eac0369:         }
1:18c4da7:         inputStream =  url.openStream();
1:eac0369:       } catch (MalformedURLException ex) {
1:18c4da7:         inputStream = new FileInputStream(inputFileName);
1:18c4da7:         
1:eac0369:       }
1:eac0369:     } catch (FileNotFoundException ex) {
1:7478b0d:         throw LoadError.dataFileNotFound(inputFileName, ex);
1:eac0369:     } catch (SecurityException se) {
1:7478b0d: 		throw LoadError.dataFileNotFound(inputFileName, se);
1:eac0369: 	}
1:18c4da7:     java.io.Reader rd = dataCodeset == null ?
1:18c4da7:     		new InputStreamReader(inputStream) : new InputStreamReader(inputStream, dataCodeset);    
1:18c4da7:     bufferedReader = new BufferedReader(rd, 32*1024);
1:eac0369:     streamOpenForReading = true;
1:eac0369:   }
1:eac0369: 
1:eac0369:   //read the first data row to find how many columns make a row and then save that
1:eac0369:   //column information for future use
1:eac0369:   private void loadMetaData() throws Exception {
1:eac0369:     //open the input data file for reading the metadata information
1:eac0369:     openFile();
1:eac0369:     // if column definition is true, ignore the first row since that's not
1:eac0369:     // really the data do uppercase because the ui shows the values as True
1:eac0369:     // and False
1:eac0369:     if (columnDefinition.toUpperCase(java.util.Locale.ENGLISH).equals(ControlInfo.INTERNAL_TRUE.toUpperCase(java.util.Locale.ENGLISH))) {
1:eac0369:       hasColumnDefinition = true;
2:eac0369:       ignoreFirstRow();
1:eac0369:     }
1:eac0369: 
1:eac0369:     if (formatCode == DEFAULT_FORMAT_CODE) {
1:eac0369:       findNumberOfColumnsInARow();
1:eac0369:     }
1:eac0369:     closeStream();
1:eac0369:   }
1:eac0369: 
1:eac0369:   /**close the input data file
1:eac0369:  	* @exception	Exception if there is an error
1:eac0369: 	*/
1:7a92d1f:   void closeStream() throws Exception {
1:eac0369:     if (streamOpenForReading) {
1:eac0369:        bufferedReader.close();
1:eac0369:        streamOpenForReading = false;
1:eac0369:     }
1:84e347a: 
1:84e347a:     // close external lob file resources.
1:3568cea:     if (lobFileHandles != null) {
1:3568cea:         for (int i = 0 ; i < numberOfColumns ; i++) 
1:3568cea:         {
1:3568cea:             if(lobFileHandles[i] != null) 
1:3568cea:                 lobFileHandles[i].close();
1:3568cea:         }
1:84e347a:     }
1:3568cea: 
1:eac0369:   }
1:eac0369: 
1:eac0369:   //actually looks at the data file to find how many columns make up a row
1:7a92d1f:   int findNumberOfColumnsInARow() throws Exception {
1:eac0369:     // init the number of columns to 1 - no such thing as a table
1:eac0369:     // without columns
1:eac0369:     numberOfColumns=1;
1:eac0369:     while (! readTokensUntilEndOfRecord() ) {
1:eac0369:       numberOfColumns++;
1:eac0369:     }
1:eac0369:     //--numberOfColumns;
1:eac0369:     //what shall we do if there is delimeter after the last column?
1:eac0369:     //reducing the number of columns seems to work fine.
1:eac0369: 
1:eac0369:     //this is necessary to be able to read delimited files that have a delimeter
1:eac0369:     //at the end of a row.
1:eac0369:     if (hasDelimiterAtEnd){
1:eac0369:         --numberOfColumns;
1:eac0369:     }
1:eac0369: 
1:eac0369:     // a special check - if the imported file is empty then
1:eac0369:     // set the number of columns to 0
1:eac0369:     if (numberOfCharsReadSoFar==0) {
1:eac0369:       numberOfColumns=0;
1:eac0369:     }
1:eac0369:     return numberOfColumns;
1:eac0369:   }
1:eac0369: 
1:eac0369:   //keep track of white spaces in the front. We use positionOfNonWhiteSpaceCharInFront for
1:eac0369:   //that. It has the count of number of white spaces found so far before any non-white char
1:eac0369:   //in the token.
1:eac0369:   //Look for whitespace only if field start delimiter is not found yet. Any white spaces
1:eac0369:   //within the start and stop delimiters are ignored.
1:eac0369:   //Also if one of the white space chars is same as recordSeparator or fieldSeparator then
1:eac0369:   //disregard it.
1:eac0369:   private void checkForWhiteSpaceInFront() {
1:eac0369:     //if found white space characters so far, the following if will be true
1:eac0369:     if ((positionOfNonWhiteSpaceCharInFront + 1) == totalCharsSoFar &&
1:eac0369:         ((!foundStartDelimiter) && (!foundStartAndStopDelimiters) )) {
1:eac0369:        char currentChar = currentToken[positionOfNonWhiteSpaceCharInFront];
1:eac0369:        if (//currentChar == '\t' ||
1:eac0369:            //currentChar == '\r' || alc: why isn't this included?
1:eac0369: 		// alc: BTW, \r and \n should be replaced
1:eac0369: 		// or amended with the first char of line.separator...
1:eac0369:            //currentChar == '\n' ||
1:eac0369:            //currentChar == ' ') {
1:eac0369:            // use String.trim()'s definition of whitespace.
1:eac0369: 		   // i18n - check for whitespace - avoid doing a hard coded character
1:eac0369: 		   // check and use the isWhitespace method to cover all the Unicode
1:eac0369: 		   // options
1:eac0369: 		   Character.isWhitespace(currentChar) == true) {
1:eac0369: 
1:eac0369:              if ((recordSepStartNotWhite || (currentChar != recordSeparatorChar0))
1:eac0369:                   &&
1:eac0369:                  (fieldSepStartNotWhite || (currentChar != fieldSeparatorChar0)))
1:eac0369:              //disregard if whitespace char is same as separator first char
1:eac0369:                 positionOfNonWhiteSpaceCharInFront++;
1:eac0369:        }
1:eac0369:     }
1:eac0369:   }
1:eac0369: 
1:eac0369: 
1:eac0369:   //look for white spaces from the back towards the stop delimiter position.
1:eac0369:   //If there was no startdelimite & stopdelimiter combination, then we start from the back
1:eac0369:   //all the way to the beginning and stop when we find non-white char
1:eac0369:   //positionOfNonWhiteSpaceCharInBack keeps the count of whitespaces at the back
1:eac0369:   private void checkForWhiteSpaceInBack() {
1:eac0369:     boolean onlyWhiteSpaceSoFar = true;
1:eac0369:     positionOfNonWhiteSpaceCharInBack = 0;
1:eac0369: 
1:eac0369:     for (int i = totalCharsSoFar; (i > stopDelimiterPosition) && onlyWhiteSpaceSoFar; i--) {
1:eac0369:        char currentChar = currentToken[i];
1:eac0369: 	// replace test on \t,\n,' ' with String.trim's definition of white space
1:eac0369: 	   // i18n - check for whitespace - avoid doing a hard coded character
1:eac0369: 	   // check and use the isWhitespace method to cover all the Unicode
1:eac0369: 	   // options
1:eac0369:        if (Character.isWhitespace(currentChar)==true) {
1:eac0369: 
1:eac0369:              if ((recordSepStartNotWhite || (currentChar != recordSeparatorChar0))
1:eac0369:                   &&
1:eac0369:                  (fieldSepStartNotWhite || (currentChar != fieldSeparatorChar0)))
1:eac0369:              //disregard if whitespace char is same as separator first char
1:eac0369:                 positionOfNonWhiteSpaceCharInBack++;
1:eac0369:        } else
1:eac0369:          onlyWhiteSpaceSoFar = false;
1:eac0369:     }
1:eac0369:   }
1:eac0369: 
1:eac0369:   //keep looking for field and record separators simultaneously because we don't yet
1:eac0369:   //know how many columns make up a row in this data file. Stop as soon as we get
1:eac0369:   //the record separator which is indicated by a return value of true from this function
1:7a92d1f:   boolean readTokensUntilEndOfRecord() throws Exception {
1:eac0369:     int nextChar;
1:eac0369:     int fieldSeparatorIndex = 0;
1:eac0369:     int recordSeparatorIndex = 0;
1:eac0369: 
1:eac0369:     fieldStopDelimiterIndex =  0;
1:eac0369:     fieldStartDelimiterIndex =  0;
1:eac0369:     totalCharsSoFar = 0;
1:eac0369:     //at the start of every new token, make white space in front count 0
1:eac0369:     positionOfNonWhiteSpaceCharInFront = 0;
1:eac0369:     foundStartDelimiter = false;
1:eac0369:     foundStartAndStopDelimiters = false;
1:eac0369:     numberOfCharsReadSoFar = 0;
1:eac0369: 
1:eac0369:     while (true) {
1:eac0369:       nextChar = bufferedReader.read();
1:eac0369:       if (nextChar == -1)
1:eac0369:          return true;
1:eac0369:       numberOfCharsReadSoFar++;
1:eac0369:       //read the character into the token holder. If token holder reaches it's capacity,
1:eac0369:       //double it's capacity
1:eac0369:       currentToken[totalCharsSoFar++] = (char)nextChar;
1:eac0369:       //check if character read is white space char in front
1:eac0369:       checkForWhiteSpaceInFront();
1:eac0369:       if (totalCharsSoFar == currentTokenMaxSize) {
1:eac0369:         currentTokenMaxSize = currentTokenMaxSize * 2;
1:eac0369:         char[] tempArray = new char[currentTokenMaxSize];
1:eac0369:         System.arraycopy(currentToken, 0, tempArray, 0, totalCharsSoFar);
1:eac0369:         currentToken = tempArray;
1:eac0369:       }
1:eac0369: 
1:eac0369:       //see if we can find fieldSeparator
1:eac0369:       fieldSeparatorIndex = lookForPassedSeparator(fieldSeparator, 
1:eac0369: 												   fieldSeparatorIndex, 
1:eac0369: 												   fieldSeparatorLength,
1:eac0369: 												   nextChar, false);
1:eac0369:       //every time we find a column separator, the return false will indicate that count
1:eac0369:       //this token as column data value and keep lookin for more tokens or record
1:eac0369:       //separator
1:eac0369:       if (fieldSeparatorIndex == -1)
1:eac0369:          return false;
1:eac0369: 
1:eac0369:       //if found start delimiter, then don't look for record separator, just look for
1:eac0369:       //end delimiter
1:eac0369:       if (!foundStartDelimiter ) {
1:eac0369:          //see if we can find recordSeparator
1:eac0369:          recordSeparatorIndex = lookForPassedSeparator(recordSeparator, recordSeparatorIndex,
1:eac0369:            recordSeparatorLength, nextChar, true);
1:eac0369:          if (recordSeparatorIndex == -1)
1:eac0369:             return true;
1:eac0369:       }
1:eac0369:     }
1:eac0369:   }
1:eac0369: 
1:eac0369:   //if not inside a start delimiter, then look for the delimiter passed
1:eac0369:   //else look for stop delimiter first.
1:eac0369:   //this routine returns -1 if it finds field delimiter or record delimiter
1:eac0369:   private int lookForPassedSeparator(char[] delimiter, int delimiterIndex,
1:eac0369: 									 int delimiterLength, int nextChar,  
1:eac0369: 									 boolean lookForRecordSeperator) throws
1:eac0369: 									 IOException
1:eac0369: 	{
1:eac0369: 
1:eac0369:     //foundStartDelimiter will be false if we haven't found a start delimiter yet
1:eac0369:     //if we haven't found startdelimiter, then we look for both start delimiter
1:eac0369:     //and passed delimiter(which can be field or record delimiter). If we do find
1:eac0369:     //start delimiter, then we only look for stop delimiter and not the passed delimiter.
1:eac0369:     if (!foundStartDelimiter ) {
1:eac0369:        //look for start delimiter only if it's length is non-zero and only if haven't already
1:eac0369:        //found it at all so far.
1:eac0369:        if (fieldStartDelimiterLength != 0 && (!foundStartAndStopDelimiters) ) {
1:eac0369:           //the code inside following if will be executed only if we have gone past all the
1:eac0369:           //white characters in the front.
1:eac0369:           if (totalCharsSoFar != positionOfNonWhiteSpaceCharInFront &&
1:eac0369:               (totalCharsSoFar - positionOfNonWhiteSpaceCharInFront) <= fieldStartDelimiterLength) {
1:eac0369:              //After getting rid of white spaces in front, look for the start delimiter. If
1:eac0369:              //found, set foundStartDelimiter flag.
1:eac0369:              if (nextChar == fieldStartDelimiter[fieldStartDelimiterIndex]){
1:eac0369:                 fieldStartDelimiterIndex++;
1:eac0369:                 if (fieldStartDelimiterIndex == fieldStartDelimiterLength) {
1:eac0369:                    foundStartDelimiter = true;
1:eac0369:                    //since characters read so far are same as start delimiters, discard those chars
1:eac0369:                    totalCharsSoFar = 0;
1:eac0369:                    positionOfNonWhiteSpaceCharInFront = 0;
1:eac0369:                    return 0;
1:eac0369:                 }
1:eac0369:              } else {
1:eac0369:                 //found a mismatch for the start delimiter
1:eac0369:                 //see if found match for more than one char of this start delimiter before the
1:eac0369:                 //current mismatch, if so check the remaining chars agains
1:eac0369:                 //eg if stop delimiter is xa and data is xxa
1:eac0369:                 if (fieldStartDelimiterIndex > 0) {
1:eac0369:                    reCheckRestOfTheCharacters(totalCharsSoFar-fieldStartDelimiterIndex,
1:eac0369:                    fieldStartDelimiter, fieldStartDelimiterLength);
1:eac0369:                 }
1:eac0369:              }
1:eac0369:           }
1:eac0369:        }
1:eac0369: 
1:eac0369: 	   /*look for typical record seperators line feed (\n),  a carriage return
1:eac0369: 		* (\r) or a carriage return followed by line feed (\r\n)
1:eac0369: 		*/
1:eac0369: 	   if(lookForRecordSeperator)
1:eac0369: 	   {
1:eac0369: 		   if(nextChar == '\r' || nextChar == '\n')
1:eac0369: 		   {
1:eac0369: 			   recordSeparatorChar0 = (char) nextChar;
1:eac0369: 			   if(nextChar == '\r' )
1:eac0369: 			   {
1:eac0369: 				   //omot the line feed character if it exists in the stream
1:eac0369: 				   omitLineFeed();
1:eac0369: 			   }
1:eac0369: 
1:eac0369: 			   totalCharsSoFar = totalCharsSoFar - 1 ;
1:eac0369: 			   return -1;
1:eac0369: 		   }
1:eac0369: 
1:eac0369: 		   return delimiterIndex;
1:eac0369: 	   }
1:eac0369: 
1:eac0369:        //look for passed delimiter
1:eac0369:        if (nextChar == delimiter[delimiterIndex]) {
1:eac0369:           delimiterIndex++;
1:eac0369:           if (delimiterIndex == delimiterLength) { //found passed delimiter
1:eac0369:              totalCharsSoFar = totalCharsSoFar - delimiterLength;
1:eac0369:              return -1;
1:eac0369:           }
1:eac0369:           return delimiterIndex; //this number of chars of delimiter have exact match so far
1:eac0369:        } else {
1:eac0369:          //found a mismatch for the delimiter
1:eac0369:          //see if found match for more than one char of this delimiter before the
1:eac0369:          //current mismatch, if so check the remaining chars agains
1:eac0369:          //eg if delimiter is xa and data is xxa
1:eac0369:          if (delimiterIndex > 0)
1:eac0369:             return(reCheckRestOfTheCharacters(totalCharsSoFar-delimiterIndex,
1:eac0369: 		delimiter,
1:eac0369:             	delimiterLength));
1:eac0369:        }
1:eac0369:     } else {
1:eac0369:       //see if we can find fieldStopDelimiter
1:eac0369:       if (nextChar == fieldStopDelimiter[fieldStopDelimiterIndex]) {
1:eac0369:          fieldStopDelimiterIndex++;
1:eac0369:          if (fieldStopDelimiterIndex == fieldStopDelimiterLength) {
1:eac0369: 			 boolean skipped = 	skipDoubleDelimiters(fieldStopDelimiter);
1:eac0369: 			 if(!skipped)
1:eac0369: 			 {
1:eac0369: 				 foundStartDelimiter = false;
1:eac0369: 				 //found stop delimiter, discard the chars corresponding to stop delimiter
1:eac0369: 				 totalCharsSoFar = totalCharsSoFar - fieldStopDelimiterLength;
1:eac0369: 				 //following is to take care of a case like "aa"aa This will result in an
1:eac0369: 				 //error. Also a case like "aa"   will truncate it to just aa
1:eac0369: 				 stopDelimiterPosition = totalCharsSoFar;
1:eac0369: 				 //following is used to distinguish between empty string ,"", and null string ,,
1:eac0369: 				 foundStartAndStopDelimiters = true;
1:eac0369: 			 }else
1:eac0369: 			 {
1:eac0369: 				 fieldStopDelimiterIndex =0 ; 
1:eac0369: 			 }
1:eac0369:             return 0;
1:eac0369:          }
1:eac0369:          return 0;
1:eac0369:       } else {
1:eac0369:          //found a mismatch for the stop delimiter
1:eac0369:          //see if found match for more than one char of this stop delimiter before the
1:eac0369:          //current mismatch, if so check the remaining chars agains
1:eac0369:          //eg if stop delimiter is xa and data is xxa
1:eac0369:         if (fieldStopDelimiterIndex > 0) {
1:eac0369:             reCheckRestOfTheCharacters(totalCharsSoFar-fieldStopDelimiterIndex,
1:eac0369:             fieldStopDelimiter, fieldStopDelimiterLength);
1:eac0369:             return 0;
1:eac0369:         }
1:eac0369:       }
1:eac0369:     }
1:eac0369:     return 0;
1:eac0369:   }
1:eac0369: 
1:eac0369:   //If after finding a few matching characters for a delimiter, find a mismatch,
1:eac0369:   //restart the matching process from character next to the one from which you
1:eac0369:   //were in the process of finding the matching pattern
1:eac0369:   private int reCheckRestOfTheCharacters(int startFrom,
1:eac0369:          char[] delimiter, int delimiterLength) {
1:eac0369:     int delimiterIndex =  0;
1:eac0369:     // alc: need to test delim of abab with abaabab
1:eac0369:     // if delimIndex resets to 0, i probably needs to reset to
1:eac0369:     // (an ever increasing) startFrom=startFrom+1, not stay where it is
1:eac0369:     for (int i = startFrom; i<totalCharsSoFar; i++) {
1:eac0369:         if (currentToken[i] == delimiter[delimiterIndex])
1:eac0369:            delimiterIndex++;
1:eac0369:         else
1:eac0369:          delimiterIndex =  0;
1:eac0369:     }
1:eac0369:     return delimiterIndex;
1:eac0369:   }
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * skips the duplicate delimeter characters inserd character stringd ata 
1:eac0369: 	 * to get the original string. In Double Delimter recognigation Delimiter 
1:eac0369: 	 * Format strings are written with a duplicate delimeter if a delimiter is
1:eac0369: 	 * found inside the data while exporting.
1:eac0369: 	 * For example with double quote(") as character delimiter
1:eac0369: 	 *
1:eac0369: 	 *	 "What a ""nice""day!"
1:eac0369: 	 *
1:eac0369: 	 *   will be imported as:
1:eac0369: 	 *
1:eac0369: 	 *	 What a "nice"day!
1:eac0369: 	 *
1:eac0369: 	 *	 In the case of export, the rule applies in reverse. For example,
1:eac0369: 	 *
1:eac0369: 	 *	 I am 6"tall.
1:eac0369: 	 *
1:eac0369: 	 *	 will be exported to a file as:
1:eac0369: 	 *
1:eac0369: 	 *	 "I am 6""tall."
1:eac0369:  	 */
1:eac0369: 	private boolean skipDoubleDelimiters(char [] characterDelimiter) throws IOException
1:eac0369: 	{ 
1:eac0369: 		boolean skipped = true;
1:eac0369: 		int cDelLength = characterDelimiter.length ;
1:eac0369: 		bufferedReader.mark(cDelLength);
1:eac0369: 		for(int i = 0 ; i < cDelLength ; i++)
1:eac0369: 		{
1:eac0369: 			int nextChar = bufferedReader.read();
1:eac0369: 			if(nextChar != characterDelimiter[i])
1:eac0369: 			{
1:eac0369: 				//not a double delimter case
1:eac0369: 				bufferedReader.reset();
1:eac0369: 				skipped = false;
1:eac0369: 				break;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		return skipped;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 	//omit the line feed character(\n) 
1:eac0369: 	private void omitLineFeed() throws IOException
1:eac0369: 	{ 
1:eac0369: 		bufferedReader.mark(1);
1:eac0369: 		int nextChar = bufferedReader.read();
1:eac0369: 		if(nextChar != '\n')
1:eac0369: 		{
1:eac0369: 			//not a Line Feed
1:eac0369: 			bufferedReader.reset();
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369:   /**returns the number of the current row
1:eac0369:   */
1:7a92d1f:   int getCurrentRowNumber() {
1:eac0369:     return lineNumber;
1:eac0369:   }
1:eac0369: 
1:eac0369:   /**the way we read the next row from input file depends on it's format
1:eac0369:  	* @exception	Exception if there is an error
1:eac0369: 	*/
1:7a92d1f:   boolean readNextRow(String[] returnStringArray) throws Exception {
1:eac0369:     boolean readVal;
1:eac0369:     int idx;
1:eac0369: 
1:eac0369:     if (!streamOpenForReading) {
1:eac0369:        openFile();
1:eac0369:        //as earlier, ignore the first row if it's colum definition
1:eac0369:        //do uppercase because the ui shows the values as True and False
1:eac0369:        if (hasColumnDefinition){
1:ea2e939:           ignoreFirstRow();
1:ea2e939:        }
1:bb55cc3:        ignoreHeaderLines();
1:ea2e939:     }
1:eac0369:     if (formatCode == DEFAULT_FORMAT_CODE)
1:eac0369:        readVal=readNextDelimitedRow(returnStringArray);
1:eac0369:     else
1:eac0369:        readVal=readNextFixedRow(returnStringArray);
1:eac0369: 
1:eac0369:     return readVal;
1:eac0369:   }
1:eac0369: 
1:eac0369: 	// made this a field so it isn't inited for each row, just
1:eac0369: 	// set and cleared on the rows that need it (the last row
1:eac0369: 	// in a file, typically, so it isn't used much)
1:eac0369: 
1:eac0369: 	private boolean haveSep = true;
1:eac0369:   //read the specified column width for each column
1:eac0369:   private boolean readNextFixedRow(String[] returnStringArray) throws Exception {
1:eac0369:     // readLength is how many bytes it has read so far
1:eac0369:     int readLength = 0;
1:eac0369:     int totalLength = 0;
1:eac0369: 
1:eac0369:     // keep reading until rolWidth bytes have been read
1:eac0369:     while ((readLength +=
1:eac0369:       bufferedReader.read(tempString, readLength,
1:eac0369:                  rowWidth-readLength))
1:eac0369:         < rowWidth) {
1:eac0369: 
1:eac0369:       if (readLength == totalLength-1) {// EOF
1:eac0369:          if ( readLength == -1) { // no row, EOF
1:eac0369:            return false;
1:eac0369:          }
1:eac0369:          else {
1:eac0369:             // it's only a bad read if insufficient data was
1:eac0369:             // returned; missing the last record separator is ok
1:eac0369:             if (totalLength != rowWidth - recordSeparator.length) {
1:eac0369:               throw LoadError.unexpectedEndOfFile(lineNumber+1);
1:eac0369:             }
1:eac0369:             else {
1:eac0369:               haveSep = false;
1:eac0369:               break;
1:eac0369:             }
1:eac0369:          }
1:eac0369:       }
1:eac0369:       // else, some thing is read, continue until the whole column is
1:eac0369:       // read
1:eac0369:       totalLength = readLength;
1:eac0369:     }
1:eac0369: 
1:eac0369: 	 int colStart = 0;
1:eac0369:      for (int i=0; i< numberOfColumns; i++) {
1:eac0369:   		 int colWidth = columnWidths[i];
1:eac0369: 
1:eac0369:        if (colWidth == 0) //if column width is 0, return null
1:eac0369:           returnStringArray[i] = null;
1:eac0369:        else {
1:eac0369:           // if found nullstring, return it as null value
1:eac0369:           String checkAgainstNullString = new String(tempString, colStart, colWidth);
1:eac0369:           if (checkAgainstNullString.trim().equals(nullString))
1:eac0369:              returnStringArray[i] = null;
1:eac0369:           else
1:eac0369:               returnStringArray[i] = checkAgainstNullString;
1:eac0369:           colStart += colWidth;
1:eac0369:        }
1:eac0369:      }
1:eac0369: 
1:eac0369:      //if what we read is not recordSeparator, throw an exception
1:eac0369:      if (haveSep) {
1:eac0369:         for (int i=(recordSeparatorLength-1); i>=0; i--) {
1:eac0369:             if (tempString[colStart+i] != recordSeparator[i])
1:eac0369:                throw LoadError.recordSeparatorMissing(lineNumber+1);
1:eac0369:         }
1:eac0369:      } else haveSep = true; // reset for the next time, if any.
1:eac0369: 
1:eac0369:      lineNumber++;
1:eac0369:      return true;
1:eac0369:   }
1:eac0369: 
1:eac0369:   //by this time, we know number of columns that make up a row in this data file
1:eac0369:   //so first look for number of columns-1 field delimites and then look for record
1:eac0369:   //delimiter
1:eac0369:   private boolean readNextDelimitedRow(String[] returnStringArray) throws Exception {
1:eac0369: 
1:eac0369:     int upperLimit = numberOfColumns-1; //reduce # field accesses
1:eac0369: 
1:eac0369:     //no data in the input file for some reason
1:eac0369:     if (upperLimit < 0)
1:eac0369:        return false;
1:eac0369: 
1:eac0369:     //look for number of columns - 1 field separators
1:eac0369:     for (int i = 0; i<upperLimit; i++) {
1:eac0369:       if (!readNextToken(fieldSeparator, 0, fieldSeparatorLength, false) ) {
1:eac0369:         if (i == 0) // still on the first check
1:eac0369:           return false;
1:eac0369:         else
1:eac0369:           throw LoadError.unexpectedEndOfFile(lineNumber+1);
1:eac0369:       }
1:eac0369:       //following is to take care of a case like "aa"aa This will result in an
1:eac0369:       //error. Also a case like "aa"   will truncate it to just aa. valid blank
1:eac0369:       //chars are  ' ' '\r' '\t'
1:eac0369:       if (stopDelimiterPosition!=0 && ((stopDelimiterPosition) != totalCharsSoFar)) {
1:eac0369:         for (int k=stopDelimiterPosition+1; k<totalCharsSoFar; k++) {
1:eac0369:           // alc: should change || to && since || case is never true --
1:eac0369:           // currentChar can't be three different things at once.
1:eac0369:           // alc: why no \n? BTW, \r and \n should be replaced
1:eac0369:           // or amended with the first char of line.separator...
1:eac0369:                   //char currentChar = currentToken[k];
1:eac0369:                   //if (currentChar != ' ' && currentChar != '\r' && currentChar != '\t')
1:eac0369:                   // use String.trim()'s definition of whitespace.
1:eac0369:           // i18n - check for whitespace - avoid doing a hard coded
1:eac0369:           // character check and use the isWhitespace method to cover all
1:eac0369:           // the Unicode options
1:eac0369:           if (Character.isWhitespace(currentToken[k])==false) {
1:eac0369:               throw LoadError.dataAfterStopDelimiter(lineNumber+1, i+1);
1:eac0369:           }
1:eac0369:         }
1:eac0369:         totalCharsSoFar = stopDelimiterPosition;
1:eac0369:       }
1:eac0369:       //totalCharsSoFar can become -1 in readNextToken
2:eac0369:       if (totalCharsSoFar != -1) {
1:eac0369:         returnStringArray[i] = new String(currentToken,
1:eac0369:                       positionOfNonWhiteSpaceCharInFront, totalCharsSoFar);
1:eac0369:       }
1:eac0369:       else
1:eac0369:          returnStringArray[i] = null;
1:eac0369:     }
1:eac0369: 
1:eac0369:     //look for record separator for the last column's value
1:eac0369:     //if I find endoffile and the it's only one column table, then it's a valid endoffile
1:eac0369:     //case. Otherwise, it's an error case. Without the following check for the return value
1:eac0369:     //of readNextToken, import was going into infinite loop for a table with single column
1:eac0369:     //import. end-of-file was getting ignored without the following if.
1:eac0369:     if (!readNextToken(recordSeparator, 0, recordSeparatorLength, true) ) {
1:eac0369:        if (upperLimit == 0)
1:eac0369:           return false;
1:eac0369:        else
1:eac0369:           throw LoadError.unexpectedEndOfFile(lineNumber+1);
1:eac0369:     }
1:eac0369:     //following is to take care of a case like "aa"aa This will result in an
1:eac0369:     //error. Also a case like "aa"   will truncate it to just aa. valid blank
1:eac0369:     //chars are  ' ' '\r' '\t'
1:eac0369:     if (stopDelimiterPosition!=0 && (stopDelimiterPosition != totalCharsSoFar)) {
1:eac0369:       for (int i=stopDelimiterPosition+1; i<totalCharsSoFar; i++) {
1:eac0369:         // alc: should change || to && since || case is never true --
1:eac0369:         // currentChar can't be three different things at once.
1:eac0369:         // alc: why no \n? BTW, \r and \n should be replaced
1:eac0369:         // or amended with the first char of line.separator...
1:eac0369:         //char currentChar = currentToken[i];
1:eac0369:         //if (currentChar != ' ' && currentChar != '\r' && currentChar != '\t')
1:eac0369:         // use String.trim()'s definition of whitespace.
1:eac0369:         // i18n - check for whitespace - avoid doing a hard coded character
1:eac0369:         // check and use the isWhitespace method to cover all the Unicode
1:eac0369:         // options
1:eac0369:         if (Character.isWhitespace(currentToken[i])==false) {
1:eac0369:           throw LoadError.dataAfterStopDelimiter(lineNumber+1, numberOfColumns);
1:eac0369:         }
1:eac0369:       }
1:eac0369:       totalCharsSoFar = stopDelimiterPosition;
1:eac0369:     }
1:eac0369: 
1:eac0369:     //to be able to read delimited files that have a delimeter at the end,
1:eac0369:     //we have to reduce totalCharsSoFar by one when it is last column.
1:eac0369:     //Otherwise last delimeter becomes part of the data.
1:eac0369:     if (hasDelimiterAtEnd) {
1:eac0369:       if (!(fieldStopDelimiterLength > 0)) { //if there is no field stop delimeter specified,
1:eac0369:                                               //hopefully fieldStopDelimiterLength will not be >0
1:eac0369: 
1:eac0369:         //there is weird behavior in the code that makes it read the last
1:eac0369:         //delimeter as part of the last column data, so this forces us to
1:eac0369:         //reduce number of read chars only if there is data stop delimeter
1:eac0369: 
1:eac0369:         //Only if it is the last column:
1:eac0369:         //if (fieldStopDelimiter==null){
1:eac0369:           --totalCharsSoFar;
1:eac0369:         //}
1:eac0369:       }
1:eac0369:     }
1:eac0369: 
1:4f0a685:     if (totalCharsSoFar > -1) {
1:eac0369: 
1:eac0369:       /* This is a hack to fix a problem: When there is missing data in columns
1:eac0369:       and hasDelimiterAtEnd==true, then the last delimiter was read as the last column data.
1:eac0369:       Hopefully this will tackle that issue by skipping the last column which is in this case
1:eac0369:       just the delimiter.
1:eac0369:       We need to be careful about the case when the last column data itself is
1:eac0369:       actually same as the delimiter.
1:eac0369:       */
1:eac0369:       if (!hasDelimiterAtEnd) {//normal path:
1:4f0a685:           returnStringArray[upperLimit] = new String(currentToken,
1:eac0369:                           positionOfNonWhiteSpaceCharInFront, totalCharsSoFar);
1:eac0369:       }
1:eac0369:       else if (totalCharsSoFar==fieldSeparatorLength && isFieldSep(currentToken) ){
1:eac0369:         //means hasDelimiterAtEnd==true and all of the above are true
1:eac0369: 
1:eac0369:         String currentStr = new String(currentToken,
1:eac0369:                           positionOfNonWhiteSpaceCharInFront, totalCharsSoFar);
1:eac0369: 
1:eac0369:         if (currentToken[totalCharsSoFar+1]==fieldStopDelimiter[0]){
1:eac0369:           returnStringArray[upperLimit] = currentStr;
1:eac0369:         }
1:eac0369:         else {
1:eac0369:           returnStringArray[upperLimit] = null;
1:eac0369:         }
1:eac0369:       }
1:eac0369:       else {
1:eac0369:         //means hasDelimiterAtEnd==true and previous case is wrong.
1:eac0369:         if (totalCharsSoFar>0) {
2:eac0369:           returnStringArray[upperLimit] = new String(currentToken,
1:eac0369:                             positionOfNonWhiteSpaceCharInFront, totalCharsSoFar);
1:eac0369:         }
1:eac0369:         else{
1:eac0369:           returnStringArray[upperLimit] = null;
1:eac0369:         }
1:eac0369:       }
1:eac0369:     }
1:eac0369:     else
1:eac0369:       returnStringArray[upperLimit] = null;
1:eac0369: 
1:eac0369:     lineNumber++;
1:eac0369:     return true;
1:eac0369:   }
1:eac0369:   //tells if a char array is field separator:
1:eac0369:   private boolean isFieldSep(char[] chrArray){
1:eac0369:     for (int i=0; i<chrArray.length && i<fieldSeparatorLength; i++){
1:eac0369:       if (chrArray[i]!=fieldSeparator[i])
1:eac0369:         return false;
1:eac0369:     }
1:eac0369:     return true;
1:eac0369:   }
1:eac0369:   //read one column's value at a time
1:7a92d1f:   boolean readNextToken(char[] delimiter, int delimiterIndex,
1:eac0369: 							   int delimiterLength, 
1:eac0369: 							   boolean isRecordSeperator) throws Exception {
1:eac0369:     int nextChar;
1:eac0369: 
1:eac0369:     fieldStopDelimiterIndex =  0;
1:eac0369:     fieldStartDelimiterIndex =  0;
1:eac0369:     totalCharsSoFar = 0;
1:eac0369:     //at the start of every new token, make white space in front count 0
1:eac0369:     positionOfNonWhiteSpaceCharInFront = 0;
1:eac0369:     stopDelimiterPosition = 0;
1:eac0369:     foundStartAndStopDelimiters = false;
1:eac0369:     foundStartDelimiter = false;
1:eac0369:     int returnValue;
1:eac0369: 
1:eac0369:     while (true) {
1:eac0369:       nextChar = bufferedReader.read();
1:eac0369:       if (nextChar == -1) //end of file
1:eac0369:          return false;
1:eac0369: 
1:eac0369:       //read the character into the token holder. If token holder reaches it's capacity,
1:eac0369:       //double it's capacity
1:eac0369:       currentToken[totalCharsSoFar++] = (char)nextChar;
1:eac0369:       //check if character read is white space char in front
1:eac0369:       checkForWhiteSpaceInFront();
1:eac0369:       if (totalCharsSoFar == currentTokenMaxSize) {
1:eac0369:         currentTokenMaxSize = currentTokenMaxSize * 2;
1:eac0369:         char[] tempArray = new char[currentTokenMaxSize];
1:eac0369:         System.arraycopy(currentToken, 0, tempArray, 0, totalCharsSoFar);
1:eac0369:         currentToken = tempArray;
1:eac0369:       }
1:eac0369: 
1:eac0369:       returnValue = lookForPassedSeparator(delimiter, delimiterIndex,
1:eac0369: 										   delimiterLength, nextChar, 
1:eac0369: 										   isRecordSeperator);
1:eac0369:       if (returnValue == -1) {
1:eac0369:          //if no stop delimiter found that "" this means null
1:eac0369:          //also if no stop delimiter found then get rid of spaces around the token
1:eac0369:          if (!foundStartAndStopDelimiters ) {
1:eac0369:             if (totalCharsSoFar == 0)
1:eac0369:                totalCharsSoFar = -1;
1:eac0369:             else {
1:eac0369:                //get the count of white spaces from back and subtract that and white spaces in
1:eac0369:                //the front from the characters read so far so that we ignore spaces around the
1:eac0369:                //token.
1:eac0369:                checkForWhiteSpaceInBack();
1:eac0369:                totalCharsSoFar = totalCharsSoFar - positionOfNonWhiteSpaceCharInFront - positionOfNonWhiteSpaceCharInBack;
1:eac0369:             }
1:eac0369:          }
1:eac0369:          return true;
1:eac0369:       }
1:eac0369:       delimiterIndex = returnValue;
1:eac0369:     }
1:eac0369:   }
1:84e347a: 
1:84e347a: 	
1:84e347a:     /* following are the routines that are used to read lob data stored
1:84e347a:      * in a external import file for clob/blob columns, the reference 
1:84e347a:      * to external file is stored in the main import file.
1:84e347a:      */
1:3568cea: 
1:84e347a:     
1:84e347a:     /**
1:84e347a:      * Returns a clob columnn data stored at the specified location.
1:84e347a:      * @param lobLocationStr location of the clob data.
1:3568cea:      * @param colIndex number of the column. starts at 1.      
1:84e347a:      * @exception  SQLException  on any errors. 
1:84e347a:      */
1:3568cea:     String getClobColumnFromExtFileAsString(String lobLocationStr, int colIndex) 
1:84e347a:         throws SQLException 
1:84e347a:     {
1:84e347a: 		try {
1:3568cea:             initExternalLobFile(lobLocationStr, colIndex);
1:ffdaf1e:             if (lobLength == -1 ){
1:ffdaf1e:                 // lob length -1 indicates columnn value is a NULL, 
1:ffdaf1e:                 // just return null. 
1:ffdaf1e:                 return null;
1:ffdaf1e:             } else {
1:3568cea:                 return lobFileHandles[colIndex-1].getString(lobOffset,lobLength);
1:3568cea:             }
1:3568cea:             
1:3568cea: 		}catch(Exception ex) {
1:3568cea: 			throw LoadError.unexpectedError(ex);
1:3568cea: 		}
1:3568cea: 	}
1:3568cea: 
1:3568cea: 
1:3568cea:     /**
1:3568cea:      * Returns a clob columnn data stored at the specified location as
1:3568cea:      * a java.sql.Clob object. 
1:3568cea:      * @param lobLocationStr location of the clob data.
1:3568cea:      * @param colIndex number of the column. starts at 1. 
1:3568cea:      * @exception  SQLException  on any errors. 
1:3568cea:      */
1:3568cea:     java.sql.Clob getClobColumnFromExtFile(String lobLocationStr, int colIndex) 
1:3568cea:         throws SQLException 
1:3568cea:     {
1:3568cea: 		try {
1:3568cea:             initExternalLobFile(lobLocationStr, colIndex);
1:3568cea:             if (lobLength == -1 ){
1:3568cea:                 // lob length -1 indicates columnn value is a NULL, 
1:3568cea:                 // just return null. 
1:3568cea:                 return null;
1:3568cea:             } else {
1:3568cea:                 return new ImportClob(lobFileHandles[colIndex -1],
1:3568cea:                                       lobOffset,lobLength);
1:ffdaf1e:             }
1:ffdaf1e:             
1:84e347a: 		}catch(Exception ex) {
1:84e347a: 			throw LoadError.unexpectedError(ex);
1:84e347a: 		}
1:84e347a: 	}
1:84e347a: 
1:84e347a:     /**
1:84e347a:      * Returns a blob columnn data stored at the specified location as
1:84e347a:      * a java.sql.Blob object. 
1:84e347a:      * @param lobLocationStr location of the clob data.
1:3568cea:      * @param colIndex number of the column. starts at 1.                   
1:84e347a:      * @exception  SQLException  on any errors. 
1:84e347a:      */
1:3568cea:     java.sql.Blob getBlobColumnFromExtFile(String lobLocationStr, int colIndex)
1:84e347a:         throws SQLException
1:84e347a:     {
1:3568cea:         initExternalLobFile(lobLocationStr, colIndex);
1:ffdaf1e:         if (lobLength == -1) {
1:ffdaf1e:             // lob length -1 indicates columnn value is a NULL, 
1:ffdaf1e:             // just return null. 
1:ffdaf1e:             return null;
1:ffdaf1e:         }
1:ffdaf1e:         else {
1:3568cea:             return new ImportBlob(lobFileHandles[colIndex -1], 
1:3568cea:                                   lobOffset, lobLength);
1:ffdaf1e:         }
1:84e347a:     }
1:84e347a: 
1:84e347a:     /**
1:84e347a:      * Extract the file name, offset and length from the given lob 
1:84e347a:      * location and setup the file resources to read the data from 
1:84e347a:      * the file on first  invocaton. 
1:84e347a:      *
1:84e347a:      * @param lobLocationStr location of the clob data.
1:3568cea:      * @param colIndex number of the column. starts at 1.
1:84e347a:      * @exception  SQLException  on any errors. 
1:84e347a:      */
1:3568cea:     private void initExternalLobFile(String lobLocationStr, int colIndex) 
1:84e347a:         throws SQLException 
1:84e347a:     {
1:84e347a: 		// extract file name, offset, and the length from the 
1:84e347a: 		// given lob location. Lob location string format is 
1:ffdaf1e:         // <code > <fileName>.<lobOffset>.<size of lob>/ </code>.
1:ffdaf1e:         // For a NULL blob, size will be  -1
1:84e347a:  
1:ffdaf1e:         int lengthIndex = lobLocationStr.lastIndexOf(".") ;
1:ffdaf1e:         int offsetIndex = lobLocationStr.lastIndexOf(".", 
1:ffdaf1e:                                                      lengthIndex -1);
1:84e347a: 
1:ffdaf1e:         lobLength = Integer.parseInt(lobLocationStr.substring(
1:ffdaf1e:                                      lengthIndex + 1, 
1:ffdaf1e:                                      lobLocationStr.length() -1));
1:62ab900:         lobOffset = Long.parseLong(lobLocationStr.substring(
1:ffdaf1e:                                      offsetIndex+1, 
1:ffdaf1e:                                      lengthIndex));
1:ffdaf1e:         lobFileName = lobLocationStr.substring(0 , offsetIndex);
1:3568cea:         if (lobFileHandles[colIndex-1] == null) {
1:84e347a:             // open external file where the lobs are stored.
1:84e347a:             try {
1:3568cea:                 // each lob column in the table has it's own file handle. 
1:3568cea:                 // separate file handles are must, lob stream objects
1:3568cea:                 // can not be reused until the whole row is inserted.
1:e17a43d:                 File lobsFile = new File (lobFileName);
1:e17a43d:                 if (lobsFile.getParentFile() == null) {
1:e17a43d:                     // lob file name is unqualified. lob file 
1:e17a43d:                     // is expected to be in the same location as
1:e17a43d:                     // the import file.
1:e17a43d:                     lobsFile = new File((
1:e17a43d:                                 new File(inputFileName)).getParentFile(),
1:e17a43d:                                         lobFileName);
1:e17a43d:                 }
1:e17a43d:                 lobFileHandles[colIndex-1] = new ImportLobFile(lobsFile, 
1:e17a43d:                                              controlFileReader.getDataCodeset());
1:84e347a:             }catch(Exception ex) {
1:84e347a:                 throw LoadError.unexpectedError(ex);
1:84e347a:             }
1:84e347a:         }
1:84e347a:     }
1:eac0369: }
1:84e347a: 
1:84e347a: 
1:84e347a: 
1:eac0369: 
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:83668f1
/////////////////////////////////////////////////////////////////////////
1:        lineNumber++;
commit:bb55cc3
/////////////////////////////////////////////////////////////////////////
1: 
1:   /**if skipHeaderLines is greater than 0, ignore skipHeaderLines number of lines. The way to do that is to just
1:   *  look for the record separator
1:  	* @exception	Exception if there is an error
1: 	*/
1:   protected void ignoreHeaderLines() throws Exception {
1:     for(int i =0;i<skipLines;i++){
1:        if(!readNextToken(recordSeparator, 0, recordSeparatorLength, true))
1:           throw LoadError.unexpectedEndOfFile(lineNumber+1);
1:     }
1:   }
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:        ignoreHeaderLines();
commit:ea2e939
/////////////////////////////////////////////////////////////////////////
1:   //The number of header lines to be skipped.
1:   private short skipLines;
/////////////////////////////////////////////////////////////////////////
1:   ImportReadData(String inputFileName, ControlInfo controlFileReader,short skipLines)
1:     this.skipLines=skipLines;
/////////////////////////////////////////////////////////////////////////
1:        }
0:        for(int i =0;i<skipLines;i++){
1:           ignoreFirstRow();
1:        }
commit:62ab900
/////////////////////////////////////////////////////////////////////////
1:   private long lobOffset; // offset of the current large object
/////////////////////////////////////////////////////////////////////////
1:         lobOffset = Long.parseLong(lobLocationStr.substring(
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:400f6eb
/////////////////////////////////////////////////////////////////////////
1: final class ImportReadData implements java.security.PrivilegedExceptionAction<Object> {
commit:4f0a685
/////////////////////////////////////////////////////////////////////////
1:     if (totalCharsSoFar > -1) {
/////////////////////////////////////////////////////////////////////////
1:           returnStringArray[upperLimit] = new String(currentToken,
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:7478b0d
/////////////////////////////////////////////////////////////////////////
1:         throw LoadError.dataFileNotFound(inputFileName, ex);
1: 		throw LoadError.dataFileNotFound(inputFileName, se);
author:Suresh Thalamati
-------------------------------------------------------------------------------
commit:e17a43d
/////////////////////////////////////////////////////////////////////////
1: import java.io.File;
/////////////////////////////////////////////////////////////////////////
1:                 File lobsFile = new File (lobFileName);
1:                 if (lobsFile.getParentFile() == null) {
1:                     // lob file name is unqualified. lob file 
1:                     // is expected to be in the same location as
1:                     // the import file.
1:                     lobsFile = new File((
1:                                 new File(inputFileName)).getParentFile(),
1:                                         lobFileName);
1:                 }
1:                 lobFileHandles[colIndex-1] = new ImportLobFile(lobsFile, 
1:                                              controlFileReader.getDataCodeset());
commit:3568cea
/////////////////////////////////////////////////////////////////////////
1:   private ImportLobFile[] lobFileHandles; // lob file handle object 
/////////////////////////////////////////////////////////////////////////
1: 
1:     lobFileHandles = new ImportLobFile[numberOfColumns];
1: 
/////////////////////////////////////////////////////////////////////////
1:     if (lobFileHandles != null) {
1:         for (int i = 0 ; i < numberOfColumns ; i++) 
1:         {
1:             if(lobFileHandles[i] != null) 
1:                 lobFileHandles[i].close();
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1:     
1:      * @param colIndex number of the column. starts at 1.      
1:     String getClobColumnFromExtFileAsString(String lobLocationStr, int colIndex) 
1:             initExternalLobFile(lobLocationStr, colIndex);
1:                 return lobFileHandles[colIndex-1].getString(lobOffset,lobLength);
1:             }
1:             
1: 		}catch(Exception ex) {
1: 			throw LoadError.unexpectedError(ex);
1: 		}
1: 	}
1: 
1: 
1:     /**
1:      * Returns a clob columnn data stored at the specified location as
1:      * a java.sql.Clob object. 
1:      * @param lobLocationStr location of the clob data.
1:      * @param colIndex number of the column. starts at 1. 
1:      * @exception  SQLException  on any errors. 
1:      */
1:     java.sql.Clob getClobColumnFromExtFile(String lobLocationStr, int colIndex) 
1:         throws SQLException 
1:     {
1: 		try {
1:             initExternalLobFile(lobLocationStr, colIndex);
1:             if (lobLength == -1 ){
1:                 // lob length -1 indicates columnn value is a NULL, 
1:                 // just return null. 
1:                 return null;
1:             } else {
1:                 return new ImportClob(lobFileHandles[colIndex -1],
1:                                       lobOffset,lobLength);
/////////////////////////////////////////////////////////////////////////
1:      * @param colIndex number of the column. starts at 1.                   
1:     java.sql.Blob getBlobColumnFromExtFile(String lobLocationStr, int colIndex)
1:         initExternalLobFile(lobLocationStr, colIndex);
1:             return new ImportBlob(lobFileHandles[colIndex -1], 
1:                                   lobOffset, lobLength);
/////////////////////////////////////////////////////////////////////////
1:      * @param colIndex number of the column. starts at 1.
1:     private void initExternalLobFile(String lobLocationStr, int colIndex) 
/////////////////////////////////////////////////////////////////////////
1:         if (lobFileHandles[colIndex-1] == null) {
1:                 // each lob column in the table has it's own file handle. 
1:                 // separate file handles are must, lob stream objects
1:                 // can not be reused until the whole row is inserted.
0:                 lobFileHandles[colIndex-1] = new ImportLobFile(lobFileName, 
0:                                          controlFileReader.getDataCodeset());
/////////////////////////////////////////////////////////////////////////
commit:ffdaf1e
/////////////////////////////////////////////////////////////////////////
1:             if (lobLength == -1 ){
1:                 // lob length -1 indicates columnn value is a NULL, 
1:                 // just return null. 
1:                 return null;
1:             } else {
0:                 return lobFile.getString(lobOffset,lobLength);
1:             }
1:             
/////////////////////////////////////////////////////////////////////////
1:         if (lobLength == -1) {
1:             // lob length -1 indicates columnn value is a NULL, 
1:             // just return null. 
1:             return null;
1:         }
1:         else {
0:             return new ImportBlob(lobFile, lobOffset, lobLength);
1:         }
/////////////////////////////////////////////////////////////////////////
1:         // <code > <fileName>.<lobOffset>.<size of lob>/ </code>.
1:         // For a NULL blob, size will be  -1
1:         int lengthIndex = lobLocationStr.lastIndexOf(".") ;
1:         int offsetIndex = lobLocationStr.lastIndexOf(".", 
1:                                                      lengthIndex -1);
1:         lobLength = Integer.parseInt(lobLocationStr.substring(
1:                                      lengthIndex + 1, 
1:                                      lobLocationStr.length() -1));
0:         lobOffset = Integer.parseInt(lobLocationStr.substring(
1:                                      offsetIndex+1, 
1:                                      lengthIndex));
1:         lobFileName = lobLocationStr.substring(0 , offsetIndex);
commit:84e347a
/////////////////////////////////////////////////////////////////////////
1: import java.sql.SQLException;
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:   // variables realted to reading lob data from files.
0:   private ImportLobFile lobFile; // lob file object 
1:   private String lobFileName; // current file name
0:   private int lobOffset; // offset of the current large object
1:   private int lobLength; //length of the current large object
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     // close external lob file resources.
0:     if (lobFile !=null) {
0:         lobFile.close();
1:     }
/////////////////////////////////////////////////////////////////////////
1: 
1: 	
1:     /* following are the routines that are used to read lob data stored
1:      * in a external import file for clob/blob columns, the reference 
1:      * to external file is stored in the main import file.
1:      */
1: 
1:     /**
1:      * Returns a clob columnn data stored at the specified location.
1:      * @param lobLocationStr location of the clob data.
1:      * @exception  SQLException  on any errors. 
1:      */
0:     String getClobColumnFromExtFile(String lobLocationStr) 
1:         throws SQLException 
1:     {
1: 		try {
0:             initExternalLobFile(lobLocationStr);
0:             return lobFile.getString(lobOffset,lobLength);
1: 		}catch(Exception ex) {
1: 			throw LoadError.unexpectedError(ex);
1: 		}
1: 	}
1: 
1:     /**
1:      * Returns a blob columnn data stored at the specified location as
1:      * a java.sql.Blob object. 
1:      * @param lobLocationStr location of the clob data.
1:      * @exception  SQLException  on any errors. 
1:      */
0:     java.sql.Blob getBlobColumnFromExtFile(String lobLocationStr)
1:         throws SQLException
1:     {
0:         initExternalLobFile(lobLocationStr);
0:         return new ImportBlob(lobFile, lobOffset, lobLength);
1:     }
1: 
1:     /**
1:      * Extract the file name, offset and length from the given lob 
1:      * location and setup the file resources to read the data from 
1:      * the file on first  invocaton. 
1:      *
1:      * @param lobLocationStr location of the clob data.
1:      * @exception  SQLException  on any errors. 
1:      */
0:     private void initExternalLobFile(String lobLocationStr) 
1:         throws SQLException 
1:     {
1:         
1: 		// extract file name, offset, and the length from the 
1: 		// given lob location. Lob location string format is 
0: 		// fileName:offset:length
1:  
0: 		int lengthIndex = lobLocationStr.lastIndexOf(":") ;
0: 		int offsetIndex = lobLocationStr.lastIndexOf(":", lengthIndex -1);
1: 
0: 		lobLength = Integer.parseInt(lobLocationStr.substring(lengthIndex + 1));
0: 		lobOffset = Integer.parseInt(lobLocationStr.substring(offsetIndex+1, 
0: 														lengthIndex));
0: 		lobFileName = lobLocationStr.substring(0 , offsetIndex);
1: 
1: 
0:         if (lobFile == null) {
1:             // open external file where the lobs are stored.
1:             try {
0:                 lobFile = new ImportLobFile(lobFileName, 
0:                                             controlFileReader.getDataCodeset());
1:             }catch(Exception ex) {
1:                 throw LoadError.unexpectedError(ex);
1:             }
1:         }
1:     }
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:6d913c6
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:18c4da7
/////////////////////////////////////////////////////////////////////////
1: 	  InputStream inputStream;
/////////////////////////////////////////////////////////////////////////
1:         inputStream =  url.openStream();
1:         inputStream = new FileInputStream(inputFileName);
1:         
/////////////////////////////////////////////////////////////////////////
1:     java.io.Reader rd = dataCodeset == null ?
1:     		new InputStreamReader(inputStream) : new InputStreamReader(inputStream, dataCodeset);    
1:     bufferedReader = new BufferedReader(rd, 32*1024);
commit:7a92d1f
/////////////////////////////////////////////////////////////////////////
0:   ImportReadData(String inputFileName, ControlInfo controlFileReader)
/////////////////////////////////////////////////////////////////////////
1:   int getNumberOfColumns() {
/////////////////////////////////////////////////////////////////////////
1:   void closeStream() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:   int findNumberOfColumnsInARow() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:   boolean readTokensUntilEndOfRecord() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:   int getCurrentRowNumber() {
1:   boolean readNextRow(String[] returnStringArray) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:   boolean readNextToken(char[] delimiter, int delimiterIndex,
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.load.ImportReadData
1: 
0:    Copyright 1998, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:9e5097f
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.load
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.load;
1: 
1: import java.io.BufferedReader;
1: import java.io.FileNotFoundException;
1: import java.io.InputStream;
1: import java.io.InputStreamReader;
1: import java.io.FileInputStream;
1: import java.io.IOException;
1: import java.net.MalformedURLException;
1: import java.net.URL;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
0: final class ImportReadData implements java.security.PrivilegedExceptionAction {
0: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
1:   //Read data from this file
1:   private String inputFileName;
1: 
1:   private int[] columnWidths;
1:   private int rowWidth;
1:   private char[] tempString;
1:   private int numberOfCharsReadSoFar;
1: 
1:   //temporary variables
1:   private BufferedReader bufferedReader;
1: 
1:   //temporary variable which holds each token as we are building it.
1:   private static final int START_SIZE = 10240;
1:   private char[] currentToken = new char[START_SIZE];
1:   private int currentTokenMaxSize = START_SIZE;
1: 
1:   //This tells whether to look for a matching stop pattern
1:   boolean foundStartDelimiter;
1:   int totalCharsSoFar;
1:   //following is used to ignore whitespaces in the front
1:   int positionOfNonWhiteSpaceCharInFront;
1:   //following is used to ignore whitespaces in the back
1:   int positionOfNonWhiteSpaceCharInBack;
1:   int lineNumber;
1:   int fieldStartDelimiterIndex;
1:   int fieldStopDelimiterIndex;
1:   int stopDelimiterPosition;
1:   boolean foundStartAndStopDelimiters;
1: 
1:   //in the constructor we open the stream only if it's delimited file to find out
1:   //number of columns. In case of fixed, we know that already from the control file.
1:   //then we close the stream. Now the stream is reopened when the first record is
1:   //read from the file(ie when the first time next is issued. This was done for the
1:   //bug 1032 filed by Dan
1:   boolean streamOpenForReading;
1: 
1:   static final int DEFAULT_FORMAT_CODE = 0;
1:   static final int ASCII_FIXED_FORMAT_CODE = 1;
1:   private int formatCode = DEFAULT_FORMAT_CODE;
1:   private boolean hasColumnDefinition;
1:   private char recordSeparatorChar0;
1:   private char fieldSeparatorChar0;
1:   private boolean recordSepStartNotWhite = true;
1:   private boolean fieldSepStartNotWhite = true;
1: 
1:   //get properties infr from following
1:   protected ControlInfo controlFileReader;
1: 
1:   //Read first row to find out how many columns make up a row and put it in
1:   //the following variable
1:   protected int numberOfColumns;
1:  
1:   // the types of the columns that we are about to read
1:   protected String [] columnTypes;
1:   
1:   //Read control file properties and write it in here
1:   protected char[] fieldSeparator;
1:   protected int fieldSeparatorLength;
1:   protected char[] recordSeparator;
1:   protected int recordSeparatorLength;
1:   protected String nullString;
1:   protected String columnDefinition;
1:   protected String format;
1:   protected String dataCodeset;
1:   protected char[] fieldStartDelimiter;
1:   protected int fieldStartDelimiterLength;
1:   protected char[] fieldStopDelimiter;
1:   protected int fieldStopDelimiterLength;
1:   protected boolean hasDelimiterAtEnd;
1:   
1: 
1:   //load the control file properties info locally, since we need to refer to them
1:   //all the time while looking for tokens
1:   private void loadPropertiesInfo() throws Exception {
1:     fieldSeparator = controlFileReader.getFieldSeparator().toCharArray();
1:     fieldSeparatorLength = fieldSeparator.length;
1:     recordSeparator = controlFileReader.getRecordSeparator().toCharArray();
1:     recordSeparatorLength = recordSeparator.length;
1:     nullString = controlFileReader.getNullString();
1:     columnDefinition = controlFileReader.getColumnDefinition();
1:     format = controlFileReader.getFormat();
1:     dataCodeset = controlFileReader.getDataCodeset();
1:     fieldStartDelimiter = controlFileReader.getFieldStartDelimiter().toCharArray();
1:     fieldStartDelimiterLength = fieldStartDelimiter.length;
1:     fieldStopDelimiter = controlFileReader.getFieldEndDelimiter().toCharArray();
1:     fieldStopDelimiterLength = fieldStopDelimiter.length;
1:     hasDelimiterAtEnd = controlFileReader.getHasDelimiterAtEnd();
1: 
1:     // when record or field separators start with typical white space,
1:     // we can't ignore it around values in the import file.  So set up
1:     // a boolean so we don't keep re-testing for it.
1:     if (recordSeparatorLength >0) {
1:       recordSeparatorChar0=recordSeparator[0];
1:       recordSepStartNotWhite = (Character.isWhitespace(recordSeparatorChar0)==false);
1:     }
1:     if (fieldSeparatorLength >0) {
1:       fieldSeparatorChar0=fieldSeparator[0];
1:       fieldSepStartNotWhite = (Character.isWhitespace(fieldSeparatorChar0)==false);
1:     }
1:   }
1:   //inputFileName: File to read data from
1:   //controlFileReader: File used to interpret data in the inputFileName
0:   public ImportReadData(String inputFileName, ControlInfo controlFileReader)
1:   throws Exception {
1:     this.inputFileName = inputFileName;
1:     this.controlFileReader = controlFileReader;
1: 
1:     //load the control file properties info locally, since we need to refer to
1:     //them all the time while looking for tokens
1:     loadPropertiesInfo();
1:     //read the first row to find how many columns make a row and then save that
1:     //column information for further use
1:     loadMetaData();
1:   }
1: 
1:   //just a getter returning number of columns for a row in the data file
0:   public int getNumberOfColumns() {
1:     return numberOfColumns;
1:   }
1:   /**if columndefinition is true, ignore first row. The way to do that is to just
1:   *  look for the record separator
1:  	* @exception	Exception if there is an error
1: 	*/
1:   protected void ignoreFirstRow() throws Exception {
1:     readNextToken(recordSeparator, 0, recordSeparatorLength, true);
1:   }
1: 
1:   /** load the column types from the meta data line to be analyzed
1:     * later in the constructor of the ImportResultSetMetaData.
1: 	*/
1:   protected void loadColumnTypes() throws Exception {
1:     int idx;
1:     String [] metaDataArray;
1: 
1:     // start by counting the number of columns that we have at the
1:     // meta data line
1:     findNumberOfColumnsInARow();
1: 
1:     // reopen the file to the start of the file to read the actual column types data
1: 	closeStream();
1: 	openFile();
1: 
1:     // make room for the meta data
1:     metaDataArray=new String [numberOfColumns];
1: 
1:     // read the meta data line line - meta data is always in a delimited format
1:     readNextDelimitedRow(metaDataArray);
1: 
1:     // allocate space for the columnTypes  meta data
1:     // since the meta data line contains a combination of column name and
1:     // column type for every column we actually have only half the number of
1:     // columns that was counted.
1:     columnTypes=new String[numberOfColumns/2];
1: 
1:     for(idx=0 ; idx<numberOfColumns ; idx=idx+2) {
1:       columnTypes[idx/2]=metaDataArray[idx+1];
1:     }
1: 
1: 
1:     // reopen to the start of the file so the rest of the program will
1:     // work as expected
1: 	closeStream();
1: 	openFile();
1: 
1:     // init the numberOfColumns variable since it is
1:     // being accumulate by the findNumberOfColumnsInARow method
1:     numberOfColumns=0;
1:   }
1: 
1:   private void openFile() throws Exception {
1: 	try {
1: 		java.security.AccessController.doPrivileged(this);
1: 	} catch (java.security.PrivilegedActionException pae) {
1: 		throw pae.getException();
1: 	}
1:   }
1: 
1:   public final Object run() throws Exception {
1: 	  realOpenFile();
1: 	  return null;
1:   }
1: 
1:   //open the input data file for reading
1:   private void realOpenFile() throws Exception {
1:     try {
1:       try {
1:         URL url = new URL(inputFileName);
1:         if (url.getProtocol().equals("file")) { //this means it's a file url
1:            inputFileName = url.getFile(); //seems like you can't do openstream on file
1:            throw new MalformedURLException(); //so, get the filename from url and do it ususal way
1:         }
0:         InputStream inputStream =  url.openStream();
0:         bufferedReader = new BufferedReader(new InputStreamReader(inputStream, dataCodeset));
1:       } catch (MalformedURLException ex) {
0:         InputStreamReader inputFileStreamReader = new InputStreamReader(new FileInputStream(inputFileName), dataCodeset);
0:         bufferedReader = new BufferedReader(inputFileStreamReader, 32*1024);
1:       }
1:     } catch (FileNotFoundException ex) {
0:       throw LoadError.dataFileNotFound(inputFileName);
1:     } catch (SecurityException se) {
0: 		java.sql.SQLException sqle = LoadError.dataFileNotFound(inputFileName);
1: 
0: 		sqle.setNextException(new java.sql.SQLException("XJ001", se.getMessage(), 0));
1: 
0: 		throw sqle;
1: 	}
1:     streamOpenForReading = true;
1:   }
1: 
1:   //read the first data row to find how many columns make a row and then save that
1:   //column information for future use
1:   private void loadMetaData() throws Exception {
1:     //open the input data file for reading the metadata information
1:     openFile();
1:     // if column definition is true, ignore the first row since that's not
1:     // really the data do uppercase because the ui shows the values as True
1:     // and False
1:     if (columnDefinition.toUpperCase(java.util.Locale.ENGLISH).equals(ControlInfo.INTERNAL_TRUE.toUpperCase(java.util.Locale.ENGLISH))) {
1:       hasColumnDefinition = true;
1:       ignoreFirstRow();
1:     }
1: 
1:     if (formatCode == DEFAULT_FORMAT_CODE) {
1:       findNumberOfColumnsInARow();
1:     }
1:     closeStream();
1:   }
1: 
1:   /**close the input data file
1:  	* @exception	Exception if there is an error
1: 	*/
0:   public void closeStream() throws Exception {
1:     if (streamOpenForReading) {
1:        bufferedReader.close();
1:        streamOpenForReading = false;
1:     }
1:   }
1: 
1:   //actually looks at the data file to find how many columns make up a row
0:   public int findNumberOfColumnsInARow() throws Exception {
1:     // init the number of columns to 1 - no such thing as a table
1:     // without columns
1:     numberOfColumns=1;
1:     while (! readTokensUntilEndOfRecord() ) {
1:       numberOfColumns++;
1:     }
1:     //--numberOfColumns;
1:     //what shall we do if there is delimeter after the last column?
1:     //reducing the number of columns seems to work fine.
1: 
1:     //this is necessary to be able to read delimited files that have a delimeter
1:     //at the end of a row.
1:     if (hasDelimiterAtEnd){
1:         --numberOfColumns;
1:     }
1: 
1:     // a special check - if the imported file is empty then
1:     // set the number of columns to 0
1:     if (numberOfCharsReadSoFar==0) {
1:       numberOfColumns=0;
1:     }
1:     return numberOfColumns;
1:   }
1: 
1:   //keep track of white spaces in the front. We use positionOfNonWhiteSpaceCharInFront for
1:   //that. It has the count of number of white spaces found so far before any non-white char
1:   //in the token.
1:   //Look for whitespace only if field start delimiter is not found yet. Any white spaces
1:   //within the start and stop delimiters are ignored.
1:   //Also if one of the white space chars is same as recordSeparator or fieldSeparator then
1:   //disregard it.
1:   private void checkForWhiteSpaceInFront() {
1:     //if found white space characters so far, the following if will be true
1:     if ((positionOfNonWhiteSpaceCharInFront + 1) == totalCharsSoFar &&
1:         ((!foundStartDelimiter) && (!foundStartAndStopDelimiters) )) {
1:        char currentChar = currentToken[positionOfNonWhiteSpaceCharInFront];
1:        if (//currentChar == '\t' ||
1:            //currentChar == '\r' || alc: why isn't this included?
1: 		// alc: BTW, \r and \n should be replaced
1: 		// or amended with the first char of line.separator...
1:            //currentChar == '\n' ||
1:            //currentChar == ' ') {
1:            // use String.trim()'s definition of whitespace.
1: 		   // i18n - check for whitespace - avoid doing a hard coded character
1: 		   // check and use the isWhitespace method to cover all the Unicode
1: 		   // options
1: 		   Character.isWhitespace(currentChar) == true) {
1: 
1:              if ((recordSepStartNotWhite || (currentChar != recordSeparatorChar0))
1:                   &&
1:                  (fieldSepStartNotWhite || (currentChar != fieldSeparatorChar0)))
1:              //disregard if whitespace char is same as separator first char
1:                 positionOfNonWhiteSpaceCharInFront++;
1:        }
1:     }
1:   }
1: 
1: 
1:   //look for white spaces from the back towards the stop delimiter position.
1:   //If there was no startdelimite & stopdelimiter combination, then we start from the back
1:   //all the way to the beginning and stop when we find non-white char
1:   //positionOfNonWhiteSpaceCharInBack keeps the count of whitespaces at the back
1:   private void checkForWhiteSpaceInBack() {
1:     boolean onlyWhiteSpaceSoFar = true;
1:     positionOfNonWhiteSpaceCharInBack = 0;
1: 
1:     for (int i = totalCharsSoFar; (i > stopDelimiterPosition) && onlyWhiteSpaceSoFar; i--) {
1:        char currentChar = currentToken[i];
1: 	// replace test on \t,\n,' ' with String.trim's definition of white space
1: 	   // i18n - check for whitespace - avoid doing a hard coded character
1: 	   // check and use the isWhitespace method to cover all the Unicode
1: 	   // options
1:        if (Character.isWhitespace(currentChar)==true) {
1: 
1:              if ((recordSepStartNotWhite || (currentChar != recordSeparatorChar0))
1:                   &&
1:                  (fieldSepStartNotWhite || (currentChar != fieldSeparatorChar0)))
1:              //disregard if whitespace char is same as separator first char
1:                 positionOfNonWhiteSpaceCharInBack++;
1:        } else
1:          onlyWhiteSpaceSoFar = false;
1:     }
1:   }
1: 
1:   //keep looking for field and record separators simultaneously because we don't yet
1:   //know how many columns make up a row in this data file. Stop as soon as we get
1:   //the record separator which is indicated by a return value of true from this function
0:   public boolean readTokensUntilEndOfRecord() throws Exception {
1:     int nextChar;
1:     int fieldSeparatorIndex = 0;
1:     int recordSeparatorIndex = 0;
1: 
1:     fieldStopDelimiterIndex =  0;
1:     fieldStartDelimiterIndex =  0;
1:     totalCharsSoFar = 0;
1:     //at the start of every new token, make white space in front count 0
1:     positionOfNonWhiteSpaceCharInFront = 0;
1:     foundStartDelimiter = false;
1:     foundStartAndStopDelimiters = false;
1:     numberOfCharsReadSoFar = 0;
1: 
1:     while (true) {
1:       nextChar = bufferedReader.read();
1:       if (nextChar == -1)
1:          return true;
1:       numberOfCharsReadSoFar++;
1:       //read the character into the token holder. If token holder reaches it's capacity,
1:       //double it's capacity
1:       currentToken[totalCharsSoFar++] = (char)nextChar;
1:       //check if character read is white space char in front
1:       checkForWhiteSpaceInFront();
1:       if (totalCharsSoFar == currentTokenMaxSize) {
1:         currentTokenMaxSize = currentTokenMaxSize * 2;
1:         char[] tempArray = new char[currentTokenMaxSize];
1:         System.arraycopy(currentToken, 0, tempArray, 0, totalCharsSoFar);
1:         currentToken = tempArray;
1:       }
1: 
1:       //see if we can find fieldSeparator
1:       fieldSeparatorIndex = lookForPassedSeparator(fieldSeparator, 
1: 												   fieldSeparatorIndex, 
1: 												   fieldSeparatorLength,
1: 												   nextChar, false);
1:       //every time we find a column separator, the return false will indicate that count
1:       //this token as column data value and keep lookin for more tokens or record
1:       //separator
1:       if (fieldSeparatorIndex == -1)
1:          return false;
1: 
1:       //if found start delimiter, then don't look for record separator, just look for
1:       //end delimiter
1:       if (!foundStartDelimiter ) {
1:          //see if we can find recordSeparator
1:          recordSeparatorIndex = lookForPassedSeparator(recordSeparator, recordSeparatorIndex,
1:            recordSeparatorLength, nextChar, true);
1:          if (recordSeparatorIndex == -1)
1:             return true;
1:       }
1:     }
1:   }
1: 
1:   //if not inside a start delimiter, then look for the delimiter passed
1:   //else look for stop delimiter first.
1:   //this routine returns -1 if it finds field delimiter or record delimiter
1:   private int lookForPassedSeparator(char[] delimiter, int delimiterIndex,
1: 									 int delimiterLength, int nextChar,  
1: 									 boolean lookForRecordSeperator) throws
1: 									 IOException
1: 	{
1: 
1:     //foundStartDelimiter will be false if we haven't found a start delimiter yet
1:     //if we haven't found startdelimiter, then we look for both start delimiter
1:     //and passed delimiter(which can be field or record delimiter). If we do find
1:     //start delimiter, then we only look for stop delimiter and not the passed delimiter.
1:     if (!foundStartDelimiter ) {
1:        //look for start delimiter only if it's length is non-zero and only if haven't already
1:        //found it at all so far.
1:        if (fieldStartDelimiterLength != 0 && (!foundStartAndStopDelimiters) ) {
1:           //the code inside following if will be executed only if we have gone past all the
1:           //white characters in the front.
1:           if (totalCharsSoFar != positionOfNonWhiteSpaceCharInFront &&
1:               (totalCharsSoFar - positionOfNonWhiteSpaceCharInFront) <= fieldStartDelimiterLength) {
1:              //After getting rid of white spaces in front, look for the start delimiter. If
1:              //found, set foundStartDelimiter flag.
1:              if (nextChar == fieldStartDelimiter[fieldStartDelimiterIndex]){
1:                 fieldStartDelimiterIndex++;
1:                 if (fieldStartDelimiterIndex == fieldStartDelimiterLength) {
1:                    foundStartDelimiter = true;
1:                    //since characters read so far are same as start delimiters, discard those chars
1:                    totalCharsSoFar = 0;
1:                    positionOfNonWhiteSpaceCharInFront = 0;
1:                    return 0;
1:                 }
1:              } else {
1:                 //found a mismatch for the start delimiter
1:                 //see if found match for more than one char of this start delimiter before the
1:                 //current mismatch, if so check the remaining chars agains
1:                 //eg if stop delimiter is xa and data is xxa
1:                 if (fieldStartDelimiterIndex > 0) {
1:                    reCheckRestOfTheCharacters(totalCharsSoFar-fieldStartDelimiterIndex,
1:                    fieldStartDelimiter, fieldStartDelimiterLength);
1:                 }
1:              }
1:           }
1:        }
1: 
1: 	   /*look for typical record seperators line feed (\n),  a carriage return
1: 		* (\r) or a carriage return followed by line feed (\r\n)
1: 		*/
1: 	   if(lookForRecordSeperator)
1: 	   {
1: 		   if(nextChar == '\r' || nextChar == '\n')
1: 		   {
1: 			   recordSeparatorChar0 = (char) nextChar;
1: 			   if(nextChar == '\r' )
1: 			   {
1: 				   //omot the line feed character if it exists in the stream
1: 				   omitLineFeed();
1: 			   }
1: 
1: 			   totalCharsSoFar = totalCharsSoFar - 1 ;
1: 			   return -1;
1: 		   }
1: 
1: 		   return delimiterIndex;
1: 	   }
1: 
1:        //look for passed delimiter
1:        if (nextChar == delimiter[delimiterIndex]) {
1:           delimiterIndex++;
1:           if (delimiterIndex == delimiterLength) { //found passed delimiter
1:              totalCharsSoFar = totalCharsSoFar - delimiterLength;
1:              return -1;
1:           }
1:           return delimiterIndex; //this number of chars of delimiter have exact match so far
1:        } else {
1:          //found a mismatch for the delimiter
1:          //see if found match for more than one char of this delimiter before the
1:          //current mismatch, if so check the remaining chars agains
1:          //eg if delimiter is xa and data is xxa
1:          if (delimiterIndex > 0)
1:             return(reCheckRestOfTheCharacters(totalCharsSoFar-delimiterIndex,
1: 		delimiter,
1:             	delimiterLength));
1:        }
1:     } else {
1:       //see if we can find fieldStopDelimiter
1:       if (nextChar == fieldStopDelimiter[fieldStopDelimiterIndex]) {
1:          fieldStopDelimiterIndex++;
1:          if (fieldStopDelimiterIndex == fieldStopDelimiterLength) {
1: 			 boolean skipped = 	skipDoubleDelimiters(fieldStopDelimiter);
1: 			 if(!skipped)
1: 			 {
1: 				 foundStartDelimiter = false;
1: 				 //found stop delimiter, discard the chars corresponding to stop delimiter
1: 				 totalCharsSoFar = totalCharsSoFar - fieldStopDelimiterLength;
1: 				 //following is to take care of a case like "aa"aa This will result in an
1: 				 //error. Also a case like "aa"   will truncate it to just aa
1: 				 stopDelimiterPosition = totalCharsSoFar;
1: 				 //following is used to distinguish between empty string ,"", and null string ,,
1: 				 foundStartAndStopDelimiters = true;
1: 			 }else
1: 			 {
1: 				 fieldStopDelimiterIndex =0 ; 
1: 			 }
1:             return 0;
1:          }
1:          return 0;
1:       } else {
1:          //found a mismatch for the stop delimiter
1:          //see if found match for more than one char of this stop delimiter before the
1:          //current mismatch, if so check the remaining chars agains
1:          //eg if stop delimiter is xa and data is xxa
1:         if (fieldStopDelimiterIndex > 0) {
1:             reCheckRestOfTheCharacters(totalCharsSoFar-fieldStopDelimiterIndex,
1:             fieldStopDelimiter, fieldStopDelimiterLength);
1:             return 0;
1:         }
1:       }
1:     }
1:     return 0;
1:   }
1: 
1:   //If after finding a few matching characters for a delimiter, find a mismatch,
1:   //restart the matching process from character next to the one from which you
1:   //were in the process of finding the matching pattern
1:   private int reCheckRestOfTheCharacters(int startFrom,
1:          char[] delimiter, int delimiterLength) {
1:     int delimiterIndex =  0;
1:     // alc: need to test delim of abab with abaabab
1:     // if delimIndex resets to 0, i probably needs to reset to
1:     // (an ever increasing) startFrom=startFrom+1, not stay where it is
1:     for (int i = startFrom; i<totalCharsSoFar; i++) {
1:         if (currentToken[i] == delimiter[delimiterIndex])
1:            delimiterIndex++;
1:         else
1:          delimiterIndex =  0;
1:     }
1:     return delimiterIndex;
1:   }
1: 
1: 	/*
1: 	 * skips the duplicate delimeter characters inserd character stringd ata 
1: 	 * to get the original string. In Double Delimter recognigation Delimiter 
1: 	 * Format strings are written with a duplicate delimeter if a delimiter is
1: 	 * found inside the data while exporting.
1: 	 * For example with double quote(") as character delimiter
1: 	 *
1: 	 *	 "What a ""nice""day!"
1: 	 *
1: 	 *   will be imported as:
1: 	 *
1: 	 *	 What a "nice"day!
1: 	 *
1: 	 *	 In the case of export, the rule applies in reverse. For example,
1: 	 *
1: 	 *	 I am 6"tall.
1: 	 *
1: 	 *	 will be exported to a file as:
1: 	 *
1: 	 *	 "I am 6""tall."
1:  	 */
1: 	private boolean skipDoubleDelimiters(char [] characterDelimiter) throws IOException
1: 	{ 
1: 		boolean skipped = true;
1: 		int cDelLength = characterDelimiter.length ;
1: 		bufferedReader.mark(cDelLength);
1: 		for(int i = 0 ; i < cDelLength ; i++)
1: 		{
1: 			int nextChar = bufferedReader.read();
1: 			if(nextChar != characterDelimiter[i])
1: 			{
1: 				//not a double delimter case
1: 				bufferedReader.reset();
1: 				skipped = false;
1: 				break;
1: 			}
1: 		}
1: 		return skipped;
1: 	}
1: 
1: 
1: 
1: 	//omit the line feed character(\n) 
1: 	private void omitLineFeed() throws IOException
1: 	{ 
1: 		bufferedReader.mark(1);
1: 		int nextChar = bufferedReader.read();
1: 		if(nextChar != '\n')
1: 		{
1: 			//not a Line Feed
1: 			bufferedReader.reset();
1: 		}
1: 	}
1: 
1: 
1: 
1:   /**returns the number of the current row
1:   */
0:   public int getCurrentRowNumber() {
1:     return lineNumber;
1:   }
1: 
1:   /**the way we read the next row from input file depends on it's format
1:  	* @exception	Exception if there is an error
1: 	*/
0:   public boolean readNextRow(String[] returnStringArray) throws Exception {
1:     boolean readVal;
1:     int idx;
1: 
1:     if (!streamOpenForReading) {
1:        openFile();
1:        //as earlier, ignore the first row if it's colum definition
1:        //do uppercase because the ui shows the values as True and False
1:        if (hasColumnDefinition){
1:           ignoreFirstRow();
1: 	   }
1:     }
1:     if (formatCode == DEFAULT_FORMAT_CODE)
1:        readVal=readNextDelimitedRow(returnStringArray);
1:     else
1:        readVal=readNextFixedRow(returnStringArray);
1: 
1:     return readVal;
1:   }
1: 
1: 	// made this a field so it isn't inited for each row, just
1: 	// set and cleared on the rows that need it (the last row
1: 	// in a file, typically, so it isn't used much)
1: 
1: 	private boolean haveSep = true;
1:   //read the specified column width for each column
1:   private boolean readNextFixedRow(String[] returnStringArray) throws Exception {
1:     // readLength is how many bytes it has read so far
1:     int readLength = 0;
1:     int totalLength = 0;
1: 
1:     // keep reading until rolWidth bytes have been read
1:     while ((readLength +=
1:       bufferedReader.read(tempString, readLength,
1:                  rowWidth-readLength))
1:         < rowWidth) {
1: 
1:       if (readLength == totalLength-1) {// EOF
1:          if ( readLength == -1) { // no row, EOF
1:            return false;
1:          }
1:          else {
1:             // it's only a bad read if insufficient data was
1:             // returned; missing the last record separator is ok
1:             if (totalLength != rowWidth - recordSeparator.length) {
1:               throw LoadError.unexpectedEndOfFile(lineNumber+1);
1:             }
1:             else {
1:               haveSep = false;
1:               break;
1:             }
1:          }
1:       }
1:       // else, some thing is read, continue until the whole column is
1:       // read
1:       totalLength = readLength;
1:     }
1: 
1: 	 int colStart = 0;
1:      for (int i=0; i< numberOfColumns; i++) {
1:   		 int colWidth = columnWidths[i];
1: 
1:        if (colWidth == 0) //if column width is 0, return null
1:           returnStringArray[i] = null;
1:        else {
1:           // if found nullstring, return it as null value
1:           String checkAgainstNullString = new String(tempString, colStart, colWidth);
1:           if (checkAgainstNullString.trim().equals(nullString))
1:              returnStringArray[i] = null;
1:           else
1:               returnStringArray[i] = checkAgainstNullString;
1:           colStart += colWidth;
1:        }
1:      }
1: 
1:      //if what we read is not recordSeparator, throw an exception
1:      if (haveSep) {
1:         for (int i=(recordSeparatorLength-1); i>=0; i--) {
1:             if (tempString[colStart+i] != recordSeparator[i])
1:                throw LoadError.recordSeparatorMissing(lineNumber+1);
1:         }
1:      } else haveSep = true; // reset for the next time, if any.
1: 
1:      lineNumber++;
1:      return true;
1:   }
1: 
1:   //by this time, we know number of columns that make up a row in this data file
1:   //so first look for number of columns-1 field delimites and then look for record
1:   //delimiter
1:   private boolean readNextDelimitedRow(String[] returnStringArray) throws Exception {
1: 
1:     int upperLimit = numberOfColumns-1; //reduce # field accesses
1: 
1:     //no data in the input file for some reason
1:     if (upperLimit < 0)
1:        return false;
1: 
1:     //look for number of columns - 1 field separators
1:     for (int i = 0; i<upperLimit; i++) {
1:       if (!readNextToken(fieldSeparator, 0, fieldSeparatorLength, false) ) {
1:         if (i == 0) // still on the first check
1:           return false;
1:         else
1:           throw LoadError.unexpectedEndOfFile(lineNumber+1);
1:       }
1:       //following is to take care of a case like "aa"aa This will result in an
1:       //error. Also a case like "aa"   will truncate it to just aa. valid blank
1:       //chars are  ' ' '\r' '\t'
1:       if (stopDelimiterPosition!=0 && ((stopDelimiterPosition) != totalCharsSoFar)) {
1:         for (int k=stopDelimiterPosition+1; k<totalCharsSoFar; k++) {
1:           // alc: should change || to && since || case is never true --
1:           // currentChar can't be three different things at once.
1:           // alc: why no \n? BTW, \r and \n should be replaced
1:           // or amended with the first char of line.separator...
1:                   //char currentChar = currentToken[k];
1:                   //if (currentChar != ' ' && currentChar != '\r' && currentChar != '\t')
1:                   // use String.trim()'s definition of whitespace.
1:           // i18n - check for whitespace - avoid doing a hard coded
1:           // character check and use the isWhitespace method to cover all
1:           // the Unicode options
1:           if (Character.isWhitespace(currentToken[k])==false) {
1:               throw LoadError.dataAfterStopDelimiter(lineNumber+1, i+1);
1:           }
1:         }
1:         totalCharsSoFar = stopDelimiterPosition;
1:       }
1:       //totalCharsSoFar can become -1 in readNextToken
1:       if (totalCharsSoFar != -1) {
1:         returnStringArray[i] = new String(currentToken,
1:                       positionOfNonWhiteSpaceCharInFront, totalCharsSoFar);
1:       }
1:       else
1:          returnStringArray[i] = null;
1:     }
1: 
1:     //look for record separator for the last column's value
1:     //if I find endoffile and the it's only one column table, then it's a valid endoffile
1:     //case. Otherwise, it's an error case. Without the following check for the return value
1:     //of readNextToken, import was going into infinite loop for a table with single column
1:     //import. end-of-file was getting ignored without the following if.
1:     if (!readNextToken(recordSeparator, 0, recordSeparatorLength, true) ) {
1:        if (upperLimit == 0)
1:           return false;
1:        else
1:           throw LoadError.unexpectedEndOfFile(lineNumber+1);
1:     }
1:     //following is to take care of a case like "aa"aa This will result in an
1:     //error. Also a case like "aa"   will truncate it to just aa. valid blank
1:     //chars are  ' ' '\r' '\t'
1:     if (stopDelimiterPosition!=0 && (stopDelimiterPosition != totalCharsSoFar)) {
1:       for (int i=stopDelimiterPosition+1; i<totalCharsSoFar; i++) {
1:         // alc: should change || to && since || case is never true --
1:         // currentChar can't be three different things at once.
1:         // alc: why no \n? BTW, \r and \n should be replaced
1:         // or amended with the first char of line.separator...
1:         //char currentChar = currentToken[i];
1:         //if (currentChar != ' ' && currentChar != '\r' && currentChar != '\t')
1:         // use String.trim()'s definition of whitespace.
1:         // i18n - check for whitespace - avoid doing a hard coded character
1:         // check and use the isWhitespace method to cover all the Unicode
1:         // options
1:         if (Character.isWhitespace(currentToken[i])==false) {
1:           throw LoadError.dataAfterStopDelimiter(lineNumber+1, numberOfColumns);
1:         }
1:       }
1:       totalCharsSoFar = stopDelimiterPosition;
1:     }
1: 
1:     //to be able to read delimited files that have a delimeter at the end,
1:     //we have to reduce totalCharsSoFar by one when it is last column.
1:     //Otherwise last delimeter becomes part of the data.
1:     if (hasDelimiterAtEnd) {
1:       if (!(fieldStopDelimiterLength > 0)) { //if there is no field stop delimeter specified,
1:                                               //hopefully fieldStopDelimiterLength will not be >0
1: 
1:         //there is weird behavior in the code that makes it read the last
1:         //delimeter as part of the last column data, so this forces us to
1:         //reduce number of read chars only if there is data stop delimeter
1: 
1:         //Only if it is the last column:
1:         //if (fieldStopDelimiter==null){
1:           --totalCharsSoFar;
1:         //}
1:       }
1:     }
1: 
1:     if (totalCharsSoFar != -1) {
1: 
1:       /* This is a hack to fix a problem: When there is missing data in columns
1:       and hasDelimiterAtEnd==true, then the last delimiter was read as the last column data.
1:       Hopefully this will tackle that issue by skipping the last column which is in this case
1:       just the delimiter.
1:       We need to be careful about the case when the last column data itself is
1:       actually same as the delimiter.
1:       */
1:       if (!hasDelimiterAtEnd) {//normal path:
1:         returnStringArray[upperLimit] = new String(currentToken,
1:                           positionOfNonWhiteSpaceCharInFront, totalCharsSoFar);
1:       }
1:       else if (totalCharsSoFar==fieldSeparatorLength && isFieldSep(currentToken) ){
1:         //means hasDelimiterAtEnd==true and all of the above are true
1: 
1:         String currentStr = new String(currentToken,
1:                           positionOfNonWhiteSpaceCharInFront, totalCharsSoFar);
1: 
1:         if (currentToken[totalCharsSoFar+1]==fieldStopDelimiter[0]){
1:           returnStringArray[upperLimit] = currentStr;
1:         }
1:         else {
1:           returnStringArray[upperLimit] = null;
1:         }
1:       }
1:       else {
1:         //means hasDelimiterAtEnd==true and previous case is wrong.
1:         if (totalCharsSoFar>0) {
1:           returnStringArray[upperLimit] = new String(currentToken,
1:                             positionOfNonWhiteSpaceCharInFront, totalCharsSoFar);
1:         }
1:         else{
1:           returnStringArray[upperLimit] = null;
1:         }
1:       }
1:     }
1:     else
1:       returnStringArray[upperLimit] = null;
1: 
1:     lineNumber++;
1:     return true;
1:   }
1:   //tells if a char array is field separator:
1:   private boolean isFieldSep(char[] chrArray){
1:     for (int i=0; i<chrArray.length && i<fieldSeparatorLength; i++){
1:       if (chrArray[i]!=fieldSeparator[i])
1:         return false;
1:     }
1:     return true;
1:   }
1:   //read one column's value at a time
0:   public boolean readNextToken(char[] delimiter, int delimiterIndex,
1: 							   int delimiterLength, 
1: 							   boolean isRecordSeperator) throws Exception {
1:     int nextChar;
1: 
1:     fieldStopDelimiterIndex =  0;
1:     fieldStartDelimiterIndex =  0;
1:     totalCharsSoFar = 0;
1:     //at the start of every new token, make white space in front count 0
1:     positionOfNonWhiteSpaceCharInFront = 0;
1:     stopDelimiterPosition = 0;
1:     foundStartAndStopDelimiters = false;
1:     foundStartDelimiter = false;
1:     int returnValue;
1: 
1:     while (true) {
1:       nextChar = bufferedReader.read();
1:       if (nextChar == -1) //end of file
1:          return false;
1: 
1:       //read the character into the token holder. If token holder reaches it's capacity,
1:       //double it's capacity
1:       currentToken[totalCharsSoFar++] = (char)nextChar;
1:       //check if character read is white space char in front
1:       checkForWhiteSpaceInFront();
1:       if (totalCharsSoFar == currentTokenMaxSize) {
1:         currentTokenMaxSize = currentTokenMaxSize * 2;
1:         char[] tempArray = new char[currentTokenMaxSize];
1:         System.arraycopy(currentToken, 0, tempArray, 0, totalCharsSoFar);
1:         currentToken = tempArray;
1:       }
1: 
1:       returnValue = lookForPassedSeparator(delimiter, delimiterIndex,
1: 										   delimiterLength, nextChar, 
1: 										   isRecordSeperator);
1:       if (returnValue == -1) {
1:          //if no stop delimiter found that "" this means null
1:          //also if no stop delimiter found then get rid of spaces around the token
1:          if (!foundStartAndStopDelimiters ) {
1:             if (totalCharsSoFar == 0)
1:                totalCharsSoFar = -1;
1:             else {
1:                //get the count of white spaces from back and subtract that and white spaces in
1:                //the front from the characters read so far so that we ignore spaces around the
1:                //token.
1:                checkForWhiteSpaceInBack();
1:                totalCharsSoFar = totalCharsSoFar - positionOfNonWhiteSpaceCharInFront - positionOfNonWhiteSpaceCharInBack;
1:             }
1:          }
1:          return true;
1:       }
1:       delimiterIndex = returnValue;
1:     }
1:   }
1: }
1: 
1: 
1: 
1: 
1: 
1: 
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.load
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.load;
0: 
0: import java.io.BufferedReader;
0: import java.io.FileNotFoundException;
0: import java.io.InputStream;
0: import java.io.InputStreamReader;
0: import java.io.FileInputStream;
0: import java.io.IOException;
0: import java.net.MalformedURLException;
0: import java.net.URL;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: final class ImportReadData implements java.security.PrivilegedExceptionAction {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
0:   //Read data from this file
0:   private String inputFileName;
0: 
0:   private int[] columnWidths;
0:   private int rowWidth;
0:   private char[] tempString;
0:   private int numberOfCharsReadSoFar;
0: 
0:   //temporary variables
0:   private BufferedReader bufferedReader;
0: 
0:   //temporary variable which holds each token as we are building it.
0:   private static final int START_SIZE = 10240;
0:   private char[] currentToken = new char[START_SIZE];
0:   private int currentTokenMaxSize = START_SIZE;
0: 
0:   //This tells whether to look for a matching stop pattern
0:   boolean foundStartDelimiter;
0:   int totalCharsSoFar;
0:   //following is used to ignore whitespaces in the front
0:   int positionOfNonWhiteSpaceCharInFront;
0:   //following is used to ignore whitespaces in the back
0:   int positionOfNonWhiteSpaceCharInBack;
0:   int lineNumber;
0:   int fieldStartDelimiterIndex;
0:   int fieldStopDelimiterIndex;
0:   int stopDelimiterPosition;
0:   boolean foundStartAndStopDelimiters;
0: 
0:   //in the constructor we open the stream only if it's delimited file to find out
0:   //number of columns. In case of fixed, we know that already from the control file.
0:   //then we close the stream. Now the stream is reopened when the first record is
0:   //read from the file(ie when the first time next is issued. This was done for the
0:   //bug 1032 filed by Dan
0:   boolean streamOpenForReading;
0: 
0:   static final int DEFAULT_FORMAT_CODE = 0;
0:   static final int ASCII_FIXED_FORMAT_CODE = 1;
0:   private int formatCode = DEFAULT_FORMAT_CODE;
0:   private boolean hasColumnDefinition;
0:   private char recordSeparatorChar0;
0:   private char fieldSeparatorChar0;
0:   private boolean recordSepStartNotWhite = true;
0:   private boolean fieldSepStartNotWhite = true;
0: 
0:   //get properties infr from following
0:   protected ControlInfo controlFileReader;
0: 
0:   //Read first row to find out how many columns make up a row and put it in
0:   //the following variable
0:   protected int numberOfColumns;
0:  
0:   // the types of the columns that we are about to read
0:   protected String [] columnTypes;
0:   
0:   //Read control file properties and write it in here
0:   protected char[] fieldSeparator;
0:   protected int fieldSeparatorLength;
0:   protected char[] recordSeparator;
0:   protected int recordSeparatorLength;
0:   protected String nullString;
0:   protected String columnDefinition;
0:   protected String format;
0:   protected String dataCodeset;
0:   protected char[] fieldStartDelimiter;
0:   protected int fieldStartDelimiterLength;
0:   protected char[] fieldStopDelimiter;
0:   protected int fieldStopDelimiterLength;
0:   protected boolean hasDelimiterAtEnd;
0:   
0: 
0:   //load the control file properties info locally, since we need to refer to them
0:   //all the time while looking for tokens
0:   private void loadPropertiesInfo() throws Exception {
0:     fieldSeparator = controlFileReader.getFieldSeparator().toCharArray();
0:     fieldSeparatorLength = fieldSeparator.length;
0:     recordSeparator = controlFileReader.getRecordSeparator().toCharArray();
0:     recordSeparatorLength = recordSeparator.length;
0:     nullString = controlFileReader.getNullString();
0:     columnDefinition = controlFileReader.getColumnDefinition();
0:     format = controlFileReader.getFormat();
0:     dataCodeset = controlFileReader.getDataCodeset();
0:     fieldStartDelimiter = controlFileReader.getFieldStartDelimiter().toCharArray();
0:     fieldStartDelimiterLength = fieldStartDelimiter.length;
0:     fieldStopDelimiter = controlFileReader.getFieldEndDelimiter().toCharArray();
0:     fieldStopDelimiterLength = fieldStopDelimiter.length;
0:     hasDelimiterAtEnd = controlFileReader.getHasDelimiterAtEnd();
0: 
0:     // when record or field separators start with typical white space,
0:     // we can't ignore it around values in the import file.  So set up
0:     // a boolean so we don't keep re-testing for it.
0:     if (recordSeparatorLength >0) {
0:       recordSeparatorChar0=recordSeparator[0];
0:       recordSepStartNotWhite = (Character.isWhitespace(recordSeparatorChar0)==false);
0:     }
0:     if (fieldSeparatorLength >0) {
0:       fieldSeparatorChar0=fieldSeparator[0];
0:       fieldSepStartNotWhite = (Character.isWhitespace(fieldSeparatorChar0)==false);
0:     }
0:   }
0:   //inputFileName: File to read data from
0:   //controlFileReader: File used to interpret data in the inputFileName
0:   public ImportReadData(String inputFileName, ControlInfo controlFileReader)
0:   throws Exception {
0:     this.inputFileName = inputFileName;
0:     this.controlFileReader = controlFileReader;
0: 
0:     //load the control file properties info locally, since we need to refer to
0:     //them all the time while looking for tokens
0:     loadPropertiesInfo();
0:     //read the first row to find how many columns make a row and then save that
0:     //column information for further use
0:     loadMetaData();
0:   }
0: 
0:   //just a getter returning number of columns for a row in the data file
0:   public int getNumberOfColumns() {
0:     return numberOfColumns;
0:   }
0:   /**if columndefinition is true, ignore first row. The way to do that is to just
0:   *  look for the record separator
0:  	* @exception	Exception if there is an error
0: 	*/
0:   protected void ignoreFirstRow() throws Exception {
0:     readNextToken(recordSeparator, 0, recordSeparatorLength, true);
0:   }
0: 
0:   /** load the column types from the meta data line to be analyzed
0:     * later in the constructor of the ImportResultSetMetaData.
0: 	*/
0:   protected void loadColumnTypes() throws Exception {
0:     int idx;
0:     String [] metaDataArray;
0: 
0:     // start by counting the number of columns that we have at the
0:     // meta data line
0:     findNumberOfColumnsInARow();
0: 
0:     // reopen the file to the start of the file to read the actual column types data
0: 	closeStream();
0: 	openFile();
0: 
0:     // make room for the meta data
0:     metaDataArray=new String [numberOfColumns];
0: 
0:     // read the meta data line line - meta data is always in a delimited format
0:     readNextDelimitedRow(metaDataArray);
0: 
0:     // allocate space for the columnTypes  meta data
0:     // since the meta data line contains a combination of column name and
0:     // column type for every column we actually have only half the number of
0:     // columns that was counted.
0:     columnTypes=new String[numberOfColumns/2];
0: 
0:     for(idx=0 ; idx<numberOfColumns ; idx=idx+2) {
0:       columnTypes[idx/2]=metaDataArray[idx+1];
0:     }
0: 
0: 
0:     // reopen to the start of the file so the rest of the program will
0:     // work as expected
0: 	closeStream();
0: 	openFile();
0: 
0:     // init the numberOfColumns variable since it is
0:     // being accumulate by the findNumberOfColumnsInARow method
0:     numberOfColumns=0;
0:   }
0: 
0:   private void openFile() throws Exception {
0: 	try {
0: 		java.security.AccessController.doPrivileged(this);
0: 	} catch (java.security.PrivilegedActionException pae) {
0: 		throw pae.getException();
0: 	}
0:   }
0: 
0:   public final Object run() throws Exception {
0: 	  realOpenFile();
0: 	  return null;
0:   }
0: 
0:   //open the input data file for reading
0:   private void realOpenFile() throws Exception {
0:     try {
0:       try {
0:         URL url = new URL(inputFileName);
0:         if (url.getProtocol().equals("file")) { //this means it's a file url
0:            inputFileName = url.getFile(); //seems like you can't do openstream on file
0:            throw new MalformedURLException(); //so, get the filename from url and do it ususal way
0:         }
0:         InputStream inputStream =  url.openStream();
0:         bufferedReader = new BufferedReader(new InputStreamReader(inputStream, dataCodeset));
0:       } catch (MalformedURLException ex) {
0:         InputStreamReader inputFileStreamReader = new InputStreamReader(new FileInputStream(inputFileName), dataCodeset);
0:         bufferedReader = new BufferedReader(inputFileStreamReader, 32*1024);
0:       }
0:     } catch (FileNotFoundException ex) {
0:       throw LoadError.dataFileNotFound(inputFileName);
0:     } catch (SecurityException se) {
0: 		java.sql.SQLException sqle = LoadError.dataFileNotFound(inputFileName);
0: 
0: 		sqle.setNextException(new java.sql.SQLException("XJ001", se.getMessage(), 0));
0: 
0: 		throw sqle;
0: 	}
0:     streamOpenForReading = true;
0:   }
0: 
0:   //read the first data row to find how many columns make a row and then save that
0:   //column information for future use
0:   private void loadMetaData() throws Exception {
0:     //open the input data file for reading the metadata information
0:     openFile();
0:     // if column definition is true, ignore the first row since that's not
0:     // really the data do uppercase because the ui shows the values as True
0:     // and False
0:     if (columnDefinition.toUpperCase(java.util.Locale.ENGLISH).equals(ControlInfo.INTERNAL_TRUE.toUpperCase(java.util.Locale.ENGLISH))) {
0:       hasColumnDefinition = true;
0:       ignoreFirstRow();
0:     }
0: 
0:     if (formatCode == DEFAULT_FORMAT_CODE) {
0:       findNumberOfColumnsInARow();
0:     }
0:     closeStream();
0:   }
0: 
0:   /**close the input data file
0:  	* @exception	Exception if there is an error
0: 	*/
0:   public void closeStream() throws Exception {
0:     if (streamOpenForReading) {
0:        bufferedReader.close();
0:        streamOpenForReading = false;
0:     }
0:   }
0: 
0:   //actually looks at the data file to find how many columns make up a row
0:   public int findNumberOfColumnsInARow() throws Exception {
0:     // init the number of columns to 1 - no such thing as a table
0:     // without columns
0:     numberOfColumns=1;
0:     while (! readTokensUntilEndOfRecord() ) {
0:       numberOfColumns++;
0:     }
0:     //--numberOfColumns;
0:     //what shall we do if there is delimeter after the last column?
0:     //reducing the number of columns seems to work fine.
0: 
0:     //this is necessary to be able to read delimited files that have a delimeter
0:     //at the end of a row.
0:     if (hasDelimiterAtEnd){
0:         --numberOfColumns;
0:     }
0: 
0:     // a special check - if the imported file is empty then
0:     // set the number of columns to 0
0:     if (numberOfCharsReadSoFar==0) {
0:       numberOfColumns=0;
0:     }
0:     return numberOfColumns;
0:   }
0: 
0:   //keep track of white spaces in the front. We use positionOfNonWhiteSpaceCharInFront for
0:   //that. It has the count of number of white spaces found so far before any non-white char
0:   //in the token.
0:   //Look for whitespace only if field start delimiter is not found yet. Any white spaces
0:   //within the start and stop delimiters are ignored.
0:   //Also if one of the white space chars is same as recordSeparator or fieldSeparator then
0:   //disregard it.
0:   private void checkForWhiteSpaceInFront() {
0:     //if found white space characters so far, the following if will be true
0:     if ((positionOfNonWhiteSpaceCharInFront + 1) == totalCharsSoFar &&
0:         ((!foundStartDelimiter) && (!foundStartAndStopDelimiters) )) {
0:        char currentChar = currentToken[positionOfNonWhiteSpaceCharInFront];
0:        if (//currentChar == '\t' ||
0:            //currentChar == '\r' || alc: why isn't this included?
0: 		// alc: BTW, \r and \n should be replaced
0: 		// or amended with the first char of line.separator...
0:            //currentChar == '\n' ||
0:            //currentChar == ' ') {
0:            // use String.trim()'s definition of whitespace.
0: 		   // i18n - check for whitespace - avoid doing a hard coded character
0: 		   // check and use the isWhitespace method to cover all the Unicode
0: 		   // options
0: 		   Character.isWhitespace(currentChar) == true) {
0: 
0:              if ((recordSepStartNotWhite || (currentChar != recordSeparatorChar0))
0:                   &&
0:                  (fieldSepStartNotWhite || (currentChar != fieldSeparatorChar0)))
0:              //disregard if whitespace char is same as separator first char
0:                 positionOfNonWhiteSpaceCharInFront++;
0:        }
0:     }
0:   }
0: 
0: 
0:   //look for white spaces from the back towards the stop delimiter position.
0:   //If there was no startdelimite & stopdelimiter combination, then we start from the back
0:   //all the way to the beginning and stop when we find non-white char
0:   //positionOfNonWhiteSpaceCharInBack keeps the count of whitespaces at the back
0:   private void checkForWhiteSpaceInBack() {
0:     boolean onlyWhiteSpaceSoFar = true;
0:     positionOfNonWhiteSpaceCharInBack = 0;
0: 
0:     for (int i = totalCharsSoFar; (i > stopDelimiterPosition) && onlyWhiteSpaceSoFar; i--) {
0:        char currentChar = currentToken[i];
0: 	// replace test on \t,\n,' ' with String.trim's definition of white space
0: 	   // i18n - check for whitespace - avoid doing a hard coded character
0: 	   // check and use the isWhitespace method to cover all the Unicode
0: 	   // options
0:        if (Character.isWhitespace(currentChar)==true) {
0: 
0:              if ((recordSepStartNotWhite || (currentChar != recordSeparatorChar0))
0:                   &&
0:                  (fieldSepStartNotWhite || (currentChar != fieldSeparatorChar0)))
0:              //disregard if whitespace char is same as separator first char
0:                 positionOfNonWhiteSpaceCharInBack++;
0:        } else
0:          onlyWhiteSpaceSoFar = false;
0:     }
0:   }
0: 
0:   //keep looking for field and record separators simultaneously because we don't yet
0:   //know how many columns make up a row in this data file. Stop as soon as we get
0:   //the record separator which is indicated by a return value of true from this function
0:   public boolean readTokensUntilEndOfRecord() throws Exception {
0:     int nextChar;
0:     int fieldSeparatorIndex = 0;
0:     int recordSeparatorIndex = 0;
0: 
0:     fieldStopDelimiterIndex =  0;
0:     fieldStartDelimiterIndex =  0;
0:     totalCharsSoFar = 0;
0:     //at the start of every new token, make white space in front count 0
0:     positionOfNonWhiteSpaceCharInFront = 0;
0:     foundStartDelimiter = false;
0:     foundStartAndStopDelimiters = false;
0:     numberOfCharsReadSoFar = 0;
0: 
0:     while (true) {
0:       nextChar = bufferedReader.read();
0:       if (nextChar == -1)
0:          return true;
0:       numberOfCharsReadSoFar++;
0:       //read the character into the token holder. If token holder reaches it's capacity,
0:       //double it's capacity
0:       currentToken[totalCharsSoFar++] = (char)nextChar;
0:       //check if character read is white space char in front
0:       checkForWhiteSpaceInFront();
0:       if (totalCharsSoFar == currentTokenMaxSize) {
0:         currentTokenMaxSize = currentTokenMaxSize * 2;
0:         char[] tempArray = new char[currentTokenMaxSize];
0:         System.arraycopy(currentToken, 0, tempArray, 0, totalCharsSoFar);
0:         currentToken = tempArray;
0:       }
0: 
0:       //see if we can find fieldSeparator
0:       fieldSeparatorIndex = lookForPassedSeparator(fieldSeparator, 
0: 												   fieldSeparatorIndex, 
0: 												   fieldSeparatorLength,
0: 												   nextChar, false);
0:       //every time we find a column separator, the return false will indicate that count
0:       //this token as column data value and keep lookin for more tokens or record
0:       //separator
0:       if (fieldSeparatorIndex == -1)
0:          return false;
0: 
0:       //if found start delimiter, then don't look for record separator, just look for
0:       //end delimiter
0:       if (!foundStartDelimiter ) {
0:          //see if we can find recordSeparator
0:          recordSeparatorIndex = lookForPassedSeparator(recordSeparator, recordSeparatorIndex,
0:            recordSeparatorLength, nextChar, true);
0:          if (recordSeparatorIndex == -1)
0:             return true;
0:       }
0:     }
0:   }
0: 
0:   //if not inside a start delimiter, then look for the delimiter passed
0:   //else look for stop delimiter first.
0:   //this routine returns -1 if it finds field delimiter or record delimiter
0:   private int lookForPassedSeparator(char[] delimiter, int delimiterIndex,
0: 									 int delimiterLength, int nextChar,  
0: 									 boolean lookForRecordSeperator) throws
0: 									 IOException
0: 	{
0: 
0:     //foundStartDelimiter will be false if we haven't found a start delimiter yet
0:     //if we haven't found startdelimiter, then we look for both start delimiter
0:     //and passed delimiter(which can be field or record delimiter). If we do find
0:     //start delimiter, then we only look for stop delimiter and not the passed delimiter.
0:     if (!foundStartDelimiter ) {
0:        //look for start delimiter only if it's length is non-zero and only if haven't already
0:        //found it at all so far.
0:        if (fieldStartDelimiterLength != 0 && (!foundStartAndStopDelimiters) ) {
0:           //the code inside following if will be executed only if we have gone past all the
0:           //white characters in the front.
0:           if (totalCharsSoFar != positionOfNonWhiteSpaceCharInFront &&
0:               (totalCharsSoFar - positionOfNonWhiteSpaceCharInFront) <= fieldStartDelimiterLength) {
0:              //After getting rid of white spaces in front, look for the start delimiter. If
0:              //found, set foundStartDelimiter flag.
0:              if (nextChar == fieldStartDelimiter[fieldStartDelimiterIndex]){
0:                 fieldStartDelimiterIndex++;
0:                 if (fieldStartDelimiterIndex == fieldStartDelimiterLength) {
0:                    foundStartDelimiter = true;
0:                    //since characters read so far are same as start delimiters, discard those chars
0:                    totalCharsSoFar = 0;
0:                    positionOfNonWhiteSpaceCharInFront = 0;
0:                    return 0;
0:                 }
0:              } else {
0:                 //found a mismatch for the start delimiter
0:                 //see if found match for more than one char of this start delimiter before the
0:                 //current mismatch, if so check the remaining chars agains
0:                 //eg if stop delimiter is xa and data is xxa
0:                 if (fieldStartDelimiterIndex > 0) {
0:                    reCheckRestOfTheCharacters(totalCharsSoFar-fieldStartDelimiterIndex,
0:                    fieldStartDelimiter, fieldStartDelimiterLength);
0:                 }
0:              }
0:           }
0:        }
0: 
0: 	   /*look for typical record seperators line feed (\n),  a carriage return
0: 		* (\r) or a carriage return followed by line feed (\r\n)
0: 		*/
0: 	   if(lookForRecordSeperator)
0: 	   {
0: 		   if(nextChar == '\r' || nextChar == '\n')
0: 		   {
0: 			   recordSeparatorChar0 = (char) nextChar;
0: 			   if(nextChar == '\r' )
0: 			   {
0: 				   //omot the line feed character if it exists in the stream
0: 				   omitLineFeed();
0: 			   }
0: 
0: 			   totalCharsSoFar = totalCharsSoFar - 1 ;
0: 			   return -1;
0: 		   }
0: 
0: 		   return delimiterIndex;
0: 	   }
0: 
0:        //look for passed delimiter
0:        if (nextChar == delimiter[delimiterIndex]) {
0:           delimiterIndex++;
0:           if (delimiterIndex == delimiterLength) { //found passed delimiter
0:              totalCharsSoFar = totalCharsSoFar - delimiterLength;
0:              return -1;
0:           }
0:           return delimiterIndex; //this number of chars of delimiter have exact match so far
0:        } else {
0:          //found a mismatch for the delimiter
0:          //see if found match for more than one char of this delimiter before the
0:          //current mismatch, if so check the remaining chars agains
0:          //eg if delimiter is xa and data is xxa
0:          if (delimiterIndex > 0)
0:             return(reCheckRestOfTheCharacters(totalCharsSoFar-delimiterIndex,
0: 		delimiter,
0:             	delimiterLength));
0:        }
0:     } else {
0:       //see if we can find fieldStopDelimiter
0:       if (nextChar == fieldStopDelimiter[fieldStopDelimiterIndex]) {
0:          fieldStopDelimiterIndex++;
0:          if (fieldStopDelimiterIndex == fieldStopDelimiterLength) {
0: 			 boolean skipped = 	skipDoubleDelimiters(fieldStopDelimiter);
0: 			 if(!skipped)
0: 			 {
0: 				 foundStartDelimiter = false;
0: 				 //found stop delimiter, discard the chars corresponding to stop delimiter
0: 				 totalCharsSoFar = totalCharsSoFar - fieldStopDelimiterLength;
0: 				 //following is to take care of a case like "aa"aa This will result in an
0: 				 //error. Also a case like "aa"   will truncate it to just aa
0: 				 stopDelimiterPosition = totalCharsSoFar;
0: 				 //following is used to distinguish between empty string ,"", and null string ,,
0: 				 foundStartAndStopDelimiters = true;
0: 			 }else
0: 			 {
0: 				 fieldStopDelimiterIndex =0 ; 
0: 			 }
0:             return 0;
0:          }
0:          return 0;
0:       } else {
0:          //found a mismatch for the stop delimiter
0:          //see if found match for more than one char of this stop delimiter before the
0:          //current mismatch, if so check the remaining chars agains
0:          //eg if stop delimiter is xa and data is xxa
0:         if (fieldStopDelimiterIndex > 0) {
0:             reCheckRestOfTheCharacters(totalCharsSoFar-fieldStopDelimiterIndex,
0:             fieldStopDelimiter, fieldStopDelimiterLength);
0:             return 0;
0:         }
0:       }
0:     }
0:     return 0;
0:   }
0: 
0:   //If after finding a few matching characters for a delimiter, find a mismatch,
0:   //restart the matching process from character next to the one from which you
0:   //were in the process of finding the matching pattern
0:   private int reCheckRestOfTheCharacters(int startFrom,
0:          char[] delimiter, int delimiterLength) {
0:     int delimiterIndex =  0;
0:     // alc: need to test delim of abab with abaabab
0:     // if delimIndex resets to 0, i probably needs to reset to
0:     // (an ever increasing) startFrom=startFrom+1, not stay where it is
0:     for (int i = startFrom; i<totalCharsSoFar; i++) {
0:         if (currentToken[i] == delimiter[delimiterIndex])
0:            delimiterIndex++;
0:         else
0:          delimiterIndex =  0;
0:     }
0:     return delimiterIndex;
0:   }
0: 
0: 	/*
0: 	 * skips the duplicate delimeter characters inserd character stringd ata 
0: 	 * to get the original string. In Double Delimter recognigation Delimiter 
0: 	 * Format strings are written with a duplicate delimeter if a delimiter is
0: 	 * found inside the data while exporting.
0: 	 * For example with double quote(") as character delimiter
0: 	 *
0: 	 *	 "What a ""nice""day!"
0: 	 *
0: 	 *   will be imported as:
0: 	 *
0: 	 *	 What a "nice"day!
0: 	 *
0: 	 *	 In the case of export, the rule applies in reverse. For example,
0: 	 *
0: 	 *	 I am 6"tall.
0: 	 *
0: 	 *	 will be exported to a file as:
0: 	 *
0: 	 *	 "I am 6""tall."
0:  	 */
0: 	private boolean skipDoubleDelimiters(char [] characterDelimiter) throws IOException
0: 	{ 
0: 		boolean skipped = true;
0: 		int cDelLength = characterDelimiter.length ;
0: 		bufferedReader.mark(cDelLength);
0: 		for(int i = 0 ; i < cDelLength ; i++)
0: 		{
0: 			int nextChar = bufferedReader.read();
0: 			if(nextChar != characterDelimiter[i])
0: 			{
0: 				//not a double delimter case
0: 				bufferedReader.reset();
0: 				skipped = false;
0: 				break;
0: 			}
0: 		}
0: 		return skipped;
0: 	}
0: 
0: 
0: 
0: 	//omit the line feed character(\n) 
0: 	private void omitLineFeed() throws IOException
0: 	{ 
0: 		bufferedReader.mark(1);
0: 		int nextChar = bufferedReader.read();
0: 		if(nextChar != '\n')
0: 		{
0: 			//not a Line Feed
0: 			bufferedReader.reset();
0: 		}
0: 	}
0: 
0: 
0: 
0:   /**returns the number of the current row
0:   */
0:   public int getCurrentRowNumber() {
0:     return lineNumber;
0:   }
0: 
0:   /**the way we read the next row from input file depends on it's format
0:  	* @exception	Exception if there is an error
0: 	*/
0:   public boolean readNextRow(String[] returnStringArray) throws Exception {
0:     boolean readVal;
0:     int idx;
0: 
0:     if (!streamOpenForReading) {
0:        openFile();
0:        //as earlier, ignore the first row if it's colum definition
0:        //do uppercase because the ui shows the values as True and False
0:        if (hasColumnDefinition){
0:           ignoreFirstRow();
0: 	   }
0:     }
0:     if (formatCode == DEFAULT_FORMAT_CODE)
0:        readVal=readNextDelimitedRow(returnStringArray);
0:     else
0:        readVal=readNextFixedRow(returnStringArray);
0: 
0:     return readVal;
0:   }
0: 
0: 	// made this a field so it isn't inited for each row, just
0: 	// set and cleared on the rows that need it (the last row
0: 	// in a file, typically, so it isn't used much)
0: 
0: 	private boolean haveSep = true;
0:   //read the specified column width for each column
0:   private boolean readNextFixedRow(String[] returnStringArray) throws Exception {
0:     // readLength is how many bytes it has read so far
0:     int readLength = 0;
0:     int totalLength = 0;
0: 
0:     // keep reading until rolWidth bytes have been read
0:     while ((readLength +=
0:       bufferedReader.read(tempString, readLength,
0:                  rowWidth-readLength))
0:         < rowWidth) {
0: 
0:       if (readLength == totalLength-1) {// EOF
0:          if ( readLength == -1) { // no row, EOF
0:            return false;
0:          }
0:          else {
0:             // it's only a bad read if insufficient data was
0:             // returned; missing the last record separator is ok
0:             if (totalLength != rowWidth - recordSeparator.length) {
0:               throw LoadError.unexpectedEndOfFile(lineNumber+1);
0:             }
0:             else {
0:               haveSep = false;
0:               break;
0:             }
0:          }
0:       }
0:       // else, some thing is read, continue until the whole column is
0:       // read
0:       totalLength = readLength;
0:     }
0: 
0: 	 int colStart = 0;
0:      for (int i=0; i< numberOfColumns; i++) {
0:   		 int colWidth = columnWidths[i];
0: 
0:        if (colWidth == 0) //if column width is 0, return null
0:           returnStringArray[i] = null;
0:        else {
0:           // if found nullstring, return it as null value
0:           String checkAgainstNullString = new String(tempString, colStart, colWidth);
0:           if (checkAgainstNullString.trim().equals(nullString))
0:              returnStringArray[i] = null;
0:           else
0:               returnStringArray[i] = checkAgainstNullString;
0:           colStart += colWidth;
0:        }
0:      }
0: 
0:      //if what we read is not recordSeparator, throw an exception
0:      if (haveSep) {
0:         for (int i=(recordSeparatorLength-1); i>=0; i--) {
0:             if (tempString[colStart+i] != recordSeparator[i])
0:                throw LoadError.recordSeparatorMissing(lineNumber+1);
0:         }
0:      } else haveSep = true; // reset for the next time, if any.
0: 
0:      lineNumber++;
0:      return true;
0:   }
0: 
0:   //by this time, we know number of columns that make up a row in this data file
0:   //so first look for number of columns-1 field delimites and then look for record
0:   //delimiter
0:   private boolean readNextDelimitedRow(String[] returnStringArray) throws Exception {
0: 
0:     int upperLimit = numberOfColumns-1; //reduce # field accesses
0: 
0:     //no data in the input file for some reason
0:     if (upperLimit < 0)
0:        return false;
0: 
0:     //look for number of columns - 1 field separators
0:     for (int i = 0; i<upperLimit; i++) {
0:       if (!readNextToken(fieldSeparator, 0, fieldSeparatorLength, false) ) {
0:         if (i == 0) // still on the first check
0:           return false;
0:         else
0:           throw LoadError.unexpectedEndOfFile(lineNumber+1);
0:       }
0:       //following is to take care of a case like "aa"aa This will result in an
0:       //error. Also a case like "aa"   will truncate it to just aa. valid blank
0:       //chars are  ' ' '\r' '\t'
0:       if (stopDelimiterPosition!=0 && ((stopDelimiterPosition) != totalCharsSoFar)) {
0:         for (int k=stopDelimiterPosition+1; k<totalCharsSoFar; k++) {
0:           // alc: should change || to && since || case is never true --
0:           // currentChar can't be three different things at once.
0:           // alc: why no \n? BTW, \r and \n should be replaced
0:           // or amended with the first char of line.separator...
0:                   //char currentChar = currentToken[k];
0:                   //if (currentChar != ' ' && currentChar != '\r' && currentChar != '\t')
0:                   // use String.trim()'s definition of whitespace.
0:           // i18n - check for whitespace - avoid doing a hard coded
0:           // character check and use the isWhitespace method to cover all
0:           // the Unicode options
0:           if (Character.isWhitespace(currentToken[k])==false) {
0:               throw LoadError.dataAfterStopDelimiter(lineNumber+1, i+1);
0:           }
0:         }
0:         totalCharsSoFar = stopDelimiterPosition;
0:       }
0:       //totalCharsSoFar can become -1 in readNextToken
0:       if (totalCharsSoFar != -1) {
0:         returnStringArray[i] = new String(currentToken,
0:                       positionOfNonWhiteSpaceCharInFront, totalCharsSoFar);
0:       }
0:       else
0:          returnStringArray[i] = null;
0:     }
0: 
0:     //look for record separator for the last column's value
0:     //if I find endoffile and the it's only one column table, then it's a valid endoffile
0:     //case. Otherwise, it's an error case. Without the following check for the return value
0:     //of readNextToken, import was going into infinite loop for a table with single column
0:     //import. end-of-file was getting ignored without the following if.
0:     if (!readNextToken(recordSeparator, 0, recordSeparatorLength, true) ) {
0:        if (upperLimit == 0)
0:           return false;
0:        else
0:           throw LoadError.unexpectedEndOfFile(lineNumber+1);
0:     }
0:     //following is to take care of a case like "aa"aa This will result in an
0:     //error. Also a case like "aa"   will truncate it to just aa. valid blank
0:     //chars are  ' ' '\r' '\t'
0:     if (stopDelimiterPosition!=0 && (stopDelimiterPosition != totalCharsSoFar)) {
0:       for (int i=stopDelimiterPosition+1; i<totalCharsSoFar; i++) {
0:         // alc: should change || to && since || case is never true --
0:         // currentChar can't be three different things at once.
0:         // alc: why no \n? BTW, \r and \n should be replaced
0:         // or amended with the first char of line.separator...
0:         //char currentChar = currentToken[i];
0:         //if (currentChar != ' ' && currentChar != '\r' && currentChar != '\t')
0:         // use String.trim()'s definition of whitespace.
0:         // i18n - check for whitespace - avoid doing a hard coded character
0:         // check and use the isWhitespace method to cover all the Unicode
0:         // options
0:         if (Character.isWhitespace(currentToken[i])==false) {
0:           throw LoadError.dataAfterStopDelimiter(lineNumber+1, numberOfColumns);
0:         }
0:       }
0:       totalCharsSoFar = stopDelimiterPosition;
0:     }
0: 
0:     //to be able to read delimited files that have a delimeter at the end,
0:     //we have to reduce totalCharsSoFar by one when it is last column.
0:     //Otherwise last delimeter becomes part of the data.
0:     if (hasDelimiterAtEnd) {
0:       if (!(fieldStopDelimiterLength > 0)) { //if there is no field stop delimeter specified,
0:                                               //hopefully fieldStopDelimiterLength will not be >0
0: 
0:         //there is weird behavior in the code that makes it read the last
0:         //delimeter as part of the last column data, so this forces us to
0:         //reduce number of read chars only if there is data stop delimeter
0: 
0:         //Only if it is the last column:
0:         //if (fieldStopDelimiter==null){
0:           --totalCharsSoFar;
0:         //}
0:       }
0:     }
0: 
0:     if (totalCharsSoFar != -1) {
0: 
0:       /* This is a hack to fix a problem: When there is missing data in columns
0:       and hasDelimiterAtEnd==true, then the last delimiter was read as the last column data.
0:       Hopefully this will tackle that issue by skipping the last column which is in this case
0:       just the delimiter.
0:       We need to be careful about the case when the last column data itself is
0:       actually same as the delimiter.
0:       */
0:       if (!hasDelimiterAtEnd) {//normal path:
0:         returnStringArray[upperLimit] = new String(currentToken,
0:                           positionOfNonWhiteSpaceCharInFront, totalCharsSoFar);
0:       }
0:       else if (totalCharsSoFar==fieldSeparatorLength && isFieldSep(currentToken) ){
0:         //means hasDelimiterAtEnd==true and all of the above are true
0: 
0:         String currentStr = new String(currentToken,
0:                           positionOfNonWhiteSpaceCharInFront, totalCharsSoFar);
0: 
0:         if (currentToken[totalCharsSoFar+1]==fieldStopDelimiter[0]){
0:           returnStringArray[upperLimit] = currentStr;
0:         }
0:         else {
0:           returnStringArray[upperLimit] = null;
0:         }
0:       }
0:       else {
0:         //means hasDelimiterAtEnd==true and previous case is wrong.
0:         if (totalCharsSoFar>0) {
0:           returnStringArray[upperLimit] = new String(currentToken,
0:                             positionOfNonWhiteSpaceCharInFront, totalCharsSoFar);
0:         }
0:         else{
0:           returnStringArray[upperLimit] = null;
0:         }
0:       }
0:     }
0:     else
0:       returnStringArray[upperLimit] = null;
0: 
0:     lineNumber++;
0:     return true;
0:   }
0:   //tells if a char array is field separator:
0:   private boolean isFieldSep(char[] chrArray){
0:     for (int i=0; i<chrArray.length && i<fieldSeparatorLength; i++){
0:       if (chrArray[i]!=fieldSeparator[i])
0:         return false;
0:     }
0:     return true;
0:   }
0:   //read one column's value at a time
0:   public boolean readNextToken(char[] delimiter, int delimiterIndex,
0: 							   int delimiterLength, 
0: 							   boolean isRecordSeperator) throws Exception {
0:     int nextChar;
0: 
0:     fieldStopDelimiterIndex =  0;
0:     fieldStartDelimiterIndex =  0;
0:     totalCharsSoFar = 0;
0:     //at the start of every new token, make white space in front count 0
0:     positionOfNonWhiteSpaceCharInFront = 0;
0:     stopDelimiterPosition = 0;
0:     foundStartAndStopDelimiters = false;
0:     foundStartDelimiter = false;
0:     int returnValue;
0: 
0:     while (true) {
0:       nextChar = bufferedReader.read();
0:       if (nextChar == -1) //end of file
0:          return false;
0: 
0:       //read the character into the token holder. If token holder reaches it's capacity,
0:       //double it's capacity
0:       currentToken[totalCharsSoFar++] = (char)nextChar;
0:       //check if character read is white space char in front
0:       checkForWhiteSpaceInFront();
0:       if (totalCharsSoFar == currentTokenMaxSize) {
0:         currentTokenMaxSize = currentTokenMaxSize * 2;
0:         char[] tempArray = new char[currentTokenMaxSize];
0:         System.arraycopy(currentToken, 0, tempArray, 0, totalCharsSoFar);
0:         currentToken = tempArray;
0:       }
0: 
0:       returnValue = lookForPassedSeparator(delimiter, delimiterIndex,
0: 										   delimiterLength, nextChar, 
0: 										   isRecordSeperator);
0:       if (returnValue == -1) {
0:          //if no stop delimiter found that "" this means null
0:          //also if no stop delimiter found then get rid of spaces around the token
0:          if (!foundStartAndStopDelimiters ) {
0:             if (totalCharsSoFar == 0)
0:                totalCharsSoFar = -1;
0:             else {
0:                //get the count of white spaces from back and subtract that and white spaces in
0:                //the front from the characters read so far so that we ignore spaces around the
0:                //token.
0:                checkForWhiteSpaceInBack();
0:                totalCharsSoFar = totalCharsSoFar - positionOfNonWhiteSpaceCharInFront - positionOfNonWhiteSpaceCharInBack;
0:             }
0:          }
0:          return true;
0:       }
0:       delimiterIndex = returnValue;
0:     }
0:   }
0: }
0: 
0: 
0: 
0: 
0: 
0: 
============================================================================