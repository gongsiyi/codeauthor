1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.execute.TemporaryRowHolderResultSet
1:345de35: 
1:f6123ee:    Licensed to the Apache Software Foundation (ASF) under one or more
1:f6123ee:    contributor license agreements.  See the NOTICE file distributed with
1:f6123ee:    this work for additional information regarding copyright ownership.
1:f6123ee:    The ASF licenses this file to you under the Apache License, Version 2.0
1:f6123ee:    (the "License"); you may not use this file except in compliance with
1:f6123ee:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
10:eac0369: 
3:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.sql.execute;
1:eac0369: 
1:75ec275: import java.sql.SQLWarning;
1:b31849d: import java.sql.Timestamp;
1:b197ffa: import org.w3c.dom.Element;
1:b31849d: 
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:b31849d: import org.apache.derby.iapi.services.io.FormatableBitSet;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:6b26ee1: import org.apache.derby.iapi.sql.Activation;
1:eac0369: import org.apache.derby.iapi.sql.ResultDescription;
1:eac0369: import org.apache.derby.iapi.sql.ResultSet;
1:eac0369: import org.apache.derby.iapi.sql.Row;
1:d9d1bc8: import org.apache.derby.iapi.sql.dictionary.TriggerDescriptor;
1:b31849d: import org.apache.derby.iapi.sql.execute.CursorResultSet;
1:b31849d: import org.apache.derby.iapi.sql.execute.ExecRow;
1:b31849d: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
1:7d0f620: import org.apache.derby.iapi.sql.execute.RowChanger;
1:b31849d: import org.apache.derby.iapi.sql.execute.TargetResultSet;
1:b31849d: import org.apache.derby.iapi.store.access.ConglomerateController;
1:b31849d: import org.apache.derby.iapi.store.access.ScanController;
1:b31849d: import org.apache.derby.iapi.store.access.TransactionController;
1:eac0369: import org.apache.derby.iapi.types.DataValueDescriptor;
1:eac0369: import org.apache.derby.iapi.types.RowLocation;
1:eac0369: import org.apache.derby.iapi.types.SQLLongint;
1:d9d1bc8: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1:eac0369: 
3:eac0369: /**
1:eac0369:  * A result set to scan temporary row holders.  Ultimately, this
1:eac0369:  * may be returned to users, hence the extra junk from the ResultSet
1:eac0369:  * interface.
7:eac0369:  *
1:eac0369:  */
1:81b9853: class TemporaryRowHolderResultSet implements CursorResultSet, NoPutResultSet, Cloneable
2:eac0369: {
1:eac0369: 	private ExecRow[] 				rowArray;
1:eac0369: 	private int						numRowsOut;
1:eac0369: 	private ScanController			scan;
1:eac0369: 	private TransactionController	tc;
1:eac0369: 	private boolean 				isOpen;
1:eac0369: 	private boolean 				finished;
1:eac0369: 	private ExecRow					currentRow;
1:c69c8b0: 	private ResultDescription		resultDescription;
1:eac0369: 	private boolean                 isAppendable = false;
1:eac0369: 	private long                    positionIndexConglomId;
1:eac0369: 	private boolean 				isVirtualMemHeap;
1:eac0369: 	private boolean 				currRowFromMem;
1:eac0369: 	private TemporaryRowHolderImpl	holder;
1:eac0369: 
1:eac0369: 	// the following is used by position based scan, as well as virtual memory style heap
1:eac0369: 	ConglomerateController			heapCC;
1:eac0369: 	private RowLocation				baseRowLocation;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Constructor
1:eac0369: 	 *
2:eac0369: 	 * @param tc the xact controller
1:eac0369: 	 * @param rowArray the row array
1:c69c8b0: 	 * @param resultDescription value returned by getResultDescription()
1:eac0369: 	 */
1:c69c8b0: 	public TemporaryRowHolderResultSet
1:eac0369: 	(
1:eac0369: 		TransactionController		tc,
1:eac0369: 		ExecRow[]					rowArray,
1:c69c8b0: 		ResultDescription			resultDescription,
1:eac0369: 		boolean						isVirtualMemHeap,
1:eac0369: 		TemporaryRowHolderImpl		holder
1:eac0369:    	)
1:eac0369: 	{
1:eac0369: 
1:c69c8b0: 		this(tc, rowArray, resultDescription, isVirtualMemHeap, false, 0, holder);
1:eac0369: 
1:eac0369: 
2:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Constructor
1:eac0369: 	 *
1:eac0369: 	 * @param tc the xact controller
1:eac0369: 	 * @param rowArray the row array
1:c69c8b0: 	 * @param resultDescription value returned by getResultDescription()
1:eac0369: 	 * @param isAppendable true,if we can insert rows after this result is created
1:eac0369: 	 * @param positionIndexConglomId conglomId of the index which has order rows
1:eac0369: 	 *                               are inserted and their row location 
1:eac0369: 	 */
1:c69c8b0: 	public TemporaryRowHolderResultSet
1:eac0369: 	(
1:eac0369: 		TransactionController		tc,
1:eac0369: 		ExecRow[]					rowArray,
1:c69c8b0: 		ResultDescription			resultDescription,
1:eac0369: 		boolean						isVirtualMemHeap,
1:eac0369: 		boolean                     isAppendable,
1:eac0369: 		long                        positionIndexConglomId,
1:eac0369: 		TemporaryRowHolderImpl		holder
1:eac0369: 	) 
1:eac0369: 	{
1:eac0369: 		this.tc = tc;
1:eac0369: 		this.rowArray = rowArray;
1:c69c8b0: 		this.resultDescription = resultDescription;
1:eac0369: 		this.numRowsOut = 0;
1:eac0369: 		isOpen = false;
1:eac0369: 		finished = false;
1:eac0369: 		this.isVirtualMemHeap = isVirtualMemHeap;
1:eac0369: 		this.isAppendable = isAppendable;
1:eac0369: 		this.positionIndexConglomId = positionIndexConglomId;
1:eac0369: 
2:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(rowArray != null, "rowArray is null");
1:eac0369: 			SanityManager.ASSERT(rowArray.length > 0, "rowArray has no elements, need at least one");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		this.holder = holder;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Reset the exec row array and reinitialize
1:eac0369: 	 *
1:eac0369: 	 * @param rowArray the row array
1:eac0369: 	 */
1:eac0369: 	public void reset(ExecRow[]	rowArray)
1:eac0369: 	{
1:eac0369: 		this.rowArray = rowArray;
1:eac0369: 		this.numRowsOut = 0;
1:eac0369: 		isOpen = false;
1:eac0369: 		finished = false;
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(rowArray != null, "rowArray is null");
1:eac0369: 			SanityManager.ASSERT(rowArray.length > 0, "rowArray has no elements, need at least one");
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * postion scan to start from after where we stopped earlier
1:eac0369: 	 */
1:eac0369: 	public void reStartScan(long currentConglomId, long pconglomId) throws  StandardException 
1:eac0369: 	{
1:eac0369: 		if(isAppendable)
1:eac0369: 		{
1:2a31ed9:             if (SanityManager.DEBUG) {
1:2a31ed9:                 SanityManager.ASSERT(currentConglomId == holder.getTemporaryConglomId(),
1:2a31ed9:                         "currentConglomId(" + currentConglomId + 
1:2a31ed9:                         ") == holder.getTemporaryConglomeateId (" + 
1:2a31ed9:                         holder.getTemporaryConglomId() + ")");
1:2a31ed9:             }
1:eac0369: 			positionIndexConglomId = pconglomId;
1:eac0369: 			setupPositionBasedScan(numRowsOut);
1:eac0369: 		}else
1:eac0369: 		{
1:eac0369: 			numRowsOut--;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:d9d1bc8: 	//Make an array which is a superset of the 2 passed column arrays.
1:d9d1bc8: 	//The superset will not have any duplicates
1:d9d1bc8: 	private static int[] supersetofAllColumns(int[] columnsArray1, int[] columnsArray2)
1:d9d1bc8: 	{
1:d9d1bc8: 		int maxLength = columnsArray1.length + columnsArray2.length;
1:d9d1bc8: 		int[] maxArray = new int[maxLength];
1:d9d1bc8: 		for (int i=0; i<maxLength; i++) maxArray[i]=-1;
1:d9d1bc8: 		
1:d9d1bc8: 		//First simply copy the first array into superset
1:d9d1bc8: 		for (int i=0; i<columnsArray1.length; i++) {
1:d9d1bc8: 			maxArray[i] = columnsArray1[i];
1:d9d1bc8: 		}
1:d9d1bc8: 		
1:d9d1bc8: 		//Now copy only new values from second array into superset
1:d9d1bc8: 		int validColsPosition=columnsArray1.length;
1:d9d1bc8: 		for (int i=0; i<columnsArray2.length; i++) {
1:d9d1bc8: 			boolean found = false;
1:d9d1bc8: 			for (int j=0;j<validColsPosition;j++) {
1:d9d1bc8: 				if (maxArray[j] == columnsArray2[i]) {
1:d9d1bc8: 					found = true;
1:d9d1bc8: 					break;
1:d9d1bc8: 				}
1:d9d1bc8: 			}
1:d9d1bc8: 			if (!found) {
1:d9d1bc8: 				maxArray[validColsPosition] = columnsArray2[i];
1:d9d1bc8: 				validColsPosition++;
1:d9d1bc8: 			}
1:d9d1bc8: 		}
1:d9d1bc8: 		maxArray = shrinkArray(maxArray);
1:d9d1bc8: 		java.util.Arrays.sort(maxArray);
1:d9d1bc8: 		return maxArray;
1:d9d1bc8: 	}
1:d9d1bc8: 
1:d9d1bc8: 	//The passed array can have some -1 elements and some +ve elements
1:d9d1bc8: 	// Return an array containing just the +ve elements
1:d9d1bc8: 	private static int[] shrinkArray(int[] columnsArrary) {
1:d9d1bc8: 		int countOfColsRefedInArray = 0;
1:d9d1bc8: 		int numberOfColsInTriggerTable = columnsArrary.length;
1:d9d1bc8: 
1:d9d1bc8: 		//Count number of non -1 entries
1:d9d1bc8: 		for (int i=0; i < numberOfColsInTriggerTable; i++) {
1:d9d1bc8: 			if (columnsArrary[i] != -1)
1:d9d1bc8: 				countOfColsRefedInArray++;
1:d9d1bc8: 		}
1:d9d1bc8: 
1:d9d1bc8: 		if (countOfColsRefedInArray > 0){
1:d9d1bc8: 			int[] tempArrayOfNeededColumns = new int[countOfColsRefedInArray];
1:d9d1bc8: 			int j=0;
1:d9d1bc8: 			for (int i=0; i < numberOfColsInTriggerTable; i++) {
1:d9d1bc8: 				if (columnsArrary[i] != -1)
1:d9d1bc8: 					tempArrayOfNeededColumns[j++] = columnsArrary[i];
1:d9d1bc8: 			}
1:d9d1bc8: 			return tempArrayOfNeededColumns;
1:d9d1bc8: 		} else
1:d9d1bc8: 			return null;
1:d9d1bc8: 	}
1:d9d1bc8: 
1:d9d1bc8: 	//Return an array which contains the column positions of all the 
1:d9d1bc8: 	// +ve columns in the passed array
1:d9d1bc8: 	private static int[] justTheRequiredColumnsPositions(int[] columnsArrary) {
1:d9d1bc8: 		int countOfColsRefedInArray = 0;
1:d9d1bc8: 		int numberOfColsInTriggerTable = columnsArrary.length;
1:d9d1bc8: 
1:d9d1bc8: 		//Count number of non -1 entries
1:d9d1bc8: 		for (int i=0; i < numberOfColsInTriggerTable; i++) {
1:d9d1bc8: 			if (columnsArrary[i] != -1)
1:d9d1bc8: 				countOfColsRefedInArray++;
1:d9d1bc8: 		}
1:d9d1bc8: 
1:d9d1bc8: 		if (countOfColsRefedInArray > 0){
1:d9d1bc8: 			int[] tempArrayOfNeededColumns = new int[countOfColsRefedInArray];
1:d9d1bc8: 			int j=0;
1:d9d1bc8: 			for (int i=0; i < numberOfColsInTriggerTable; i++) {
1:d9d1bc8: 				if (columnsArrary[i] != -1)
1:d9d1bc8: 					tempArrayOfNeededColumns[j++] = i+1;
1:d9d1bc8: 			}
1:d9d1bc8: 			return tempArrayOfNeededColumns;
1:d9d1bc8: 		} else
1:d9d1bc8: 			return null;
1:d9d1bc8: 	}
1:6b26ee1: 
1:81b9853: 	/**
1:eac0369: 	 * Whip up a new Temp ResultSet that has a single
1:d9d1bc8: 	 * row. This row will either have all the columns from
1:d9d1bc8: 	 * the current row of the passed resultset or a subset 
1:d9d1bc8: 	 * of the columns from the passed resulset. It all depends
1:d9d1bc8: 	 * on what columns are needed by the passed trigger and what
1:d9d1bc8: 	 * columns exist in the resulset. The Temp resulset
1:d9d1bc8: 	 * should only have the columns required by the trigger.
1:eac0369: 	 * 
1:d9d1bc8: 	 * @param triggerd We are building Temp resultset for this trigger
1:81b9853: 	 * @param activation the activation
1:eac0369: 	 * @param rs the result set 
1:d9d1bc8: 	 * @param colsReadFromTable The passed resultset is composed of
1:d9d1bc8: 	 *   these columns. We will create a temp resultset which
1:d9d1bc8: 	 *   will have either all these columns or only a subset of
1:d9d1bc8: 	 *   these columns. It all depends on what columns are needed
1:d9d1bc8: 	 *   by the trigger. If this param is null, then that means that
1:d9d1bc8: 	 *   all the columns from the trigger table have been read into
1:d9d1bc8: 	 *   the passed resultset.
1:eac0369: 	 * 
1:eac0369: 	 * @return a single row result set
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException on error
1:eac0369: 	 */
1:c69c8b0: 	public static TemporaryRowHolderResultSet getNewRSOnCurrentRow
1:eac0369: 	(
1:d9d1bc8: 			TriggerDescriptor triggerd,
1:81b9853: 		Activation				activation,
1:d9d1bc8: 		CursorResultSet 		rs,
1:d9d1bc8: 		int[]	colsReadFromTable
1:eac0369: 	) throws StandardException
1:eac0369: 	{
1:d9d1bc8: 		TemporaryRowHolderImpl singleRow;
1:d9d1bc8: 		DataDictionary dd = activation.getLanguageConnectionContext().getDataDictionary();
1:d9d1bc8: 		// In soft upgrade mode, we could be dealing with databases created 
1:d9d1bc8: 		// with 10.8 or prior and for such databases, we do not want to do
1:d9d1bc8: 		// any column reading optimization to maintain backward compatibility
1:d9d1bc8: 		if (!dd.checkVersion(DataDictionary.DD_VERSION_DERBY_10_9,null)) {
1:d9d1bc8: 	    	singleRow =
1:c69c8b0: 	    		new TemporaryRowHolderImpl(activation, null,
1:c69c8b0: 						   rs.getResultDescription());
1:d9d1bc8: 			singleRow.insert(rs.getCurrentRow());
1:d9d1bc8: 			return (TemporaryRowHolderResultSet) singleRow.getResultSet();
1:d9d1bc8: 		}
1:d9d1bc8: 
1:d9d1bc8: 		//Get columns referenced in trigger action through REFERENCING clause
1:d9d1bc8:     	int[] referencedColsInTriggerAction = triggerd.getReferencedColsInTriggerAction();
1:d9d1bc8:     	// Get trigger column. If null, then it means that all the columns
1:d9d1bc8:     	// have been read because this trigger can be fired for any of the
1:d9d1bc8:     	// columns in the table
1:d9d1bc8:     	int[] referencedColsInTrigger = triggerd.getReferencedCols();
1:d9d1bc8: 
1:d9d1bc8: 	    if ((referencedColsInTrigger != null) && //this means not all the columns are being read
1:d9d1bc8: 	    		(triggerd.isRowTrigger() && referencedColsInTriggerAction!=null &&
1:d9d1bc8: 	    		referencedColsInTriggerAction.length != 0)) {
1:d9d1bc8: 	    	//If we are here, then trigger is defined on specific columns and
1:d9d1bc8: 	    	// it has trigger action columns used through REFERENCING clause
1:d9d1bc8: 
1:d9d1bc8: 	    	//Make an array which is a superset of trigger columns and 
1:d9d1bc8: 	    	// trigger action columns referenced through REFERENCING clause.
1:d9d1bc8: 	    	//This superset is what the trigger is looking for in it's
1:d9d1bc8: 	    	// resulset. 
1:d9d1bc8: 		    int[] colsInTrigger = supersetofAllColumns(referencedColsInTrigger,referencedColsInTriggerAction);
1:d9d1bc8: 	    	int colsCountInTrigger = colsInTrigger.length;
1:d9d1bc8: 		    int[] colsReallyNeeded = new int[colsCountInTrigger];
1:d9d1bc8: 
1:d9d1bc8: 		    //Here, we find out what columns make up the passed resulset
1:d9d1bc8: 	    	int[] actualColsReadFromTable;
1:d9d1bc8:     		if (colsReadFromTable != null) //this means not all the columns are being read
1:d9d1bc8:     			actualColsReadFromTable = justTheRequiredColumnsPositions(colsReadFromTable);
1:d9d1bc8:     		else {
1:d9d1bc8:     			int colsInTriggerTable = triggerd.getTableDescriptor().getNumberOfColumns();
1:d9d1bc8:     			actualColsReadFromTable = new int[colsInTriggerTable];
1:d9d1bc8:     			for (int i=1; i<=colsInTriggerTable; i++)
1:d9d1bc8:     				actualColsReadFromTable[i-1] = i;
1:d9d1bc8:     		}
1:d9d1bc8: 	    	
1:d9d1bc8:     		//Now we have what columns make up the passed resulset and what
1:d9d1bc8:     		// columns are needed by the trigger. We will map a temporary
1:d9d1bc8:     		// resultset for the trigger out of the above information using
1:d9d1bc8:     		// the passed resultset
1:d9d1bc8: 	    	int indexInActualColsReadFromTable = 0;
1:d9d1bc8: 	    	for (int i=0; i<colsCountInTrigger; i++) {
1:d9d1bc8: 
1:d9d1bc8: 	    		for (;indexInActualColsReadFromTable < actualColsReadFromTable.length; indexInActualColsReadFromTable++)
1:d9d1bc8: 	    		{
1:d9d1bc8: 	    			/* Return 1-based key column position if column is in the key */
1:d9d1bc8: 	    			if (actualColsReadFromTable[indexInActualColsReadFromTable] 
1:d9d1bc8: 	    			                            == colsInTrigger[i])
1:d9d1bc8: 	    			{
1:d9d1bc8: 	    				colsReallyNeeded[i] = indexInActualColsReadFromTable+1;
1:d9d1bc8: 	    				break;
1:d9d1bc8: 	    			}
1:d9d1bc8: 	    		}
1:d9d1bc8: 	    	}    			
1:d9d1bc8: 	    	singleRow =
1:81b9853: 	    		new TemporaryRowHolderImpl(activation, null,
1:d9d1bc8: 	    				activation.getLanguageConnectionContext().getLanguageFactory().
1:d9d1bc8: 	    				getResultDescription(rs.getResultDescription(),colsReallyNeeded));
1:d9d1bc8: 			ExecRow				row = activation.getExecutionFactory().getValueRow( colsCountInTrigger );
1:d9d1bc8: 			for (int i=0; i<colsCountInTrigger; i++)
1:d9d1bc8: 				row.setColumn(i+1, rs.getCurrentRow().getColumn(colsReallyNeeded[i]));
1:d9d1bc8: 			singleRow.insert(row);
1:d9d1bc8: 	    } else {
1:d9d1bc8: 	    	singleRow =
3:d9d1bc8: 	    		new TemporaryRowHolderImpl(activation, null,
1:81b9853: 						   rs.getResultDescription());
1:d9d1bc8: 			singleRow.insert(rs.getCurrentRow());
1:d9d1bc8: 	    }
1:d9d1bc8: 	    
1:eac0369: 		return (TemporaryRowHolderResultSet) singleRow.getResultSet();
1:6b26ee1: 	}
1:eac0369: 
1:eac0369: 	/////////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	// NoPutResultSet
1:eac0369: 	// 
1:eac0369: 	/////////////////////////////////////////////////////////
1:eac0369: 	/**
1:eac0369: 	 * Mark the ResultSet as the topmost one in the ResultSet tree.
1:eac0369: 	 * Useful for closing down the ResultSet on an error.
1:eac0369: 	 */
1:eac0369: 	public void markAsTopResultSet()
1:eac0369: 	{ }
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Open the scan and evaluate qualifiers and the like.
1:eac0369: 	 * For us, there are no qualifiers, this is really a
1:eac0369: 	 * noop.
1:eac0369: 	 */
1:eac0369: 	public void openCore() throws StandardException
1:eac0369: 	{
1:eac0369: 		this.numRowsOut = 0;
1:eac0369: 		isOpen = true;
1:eac0369: 		currentRow = null;
1:eac0369: 
1:eac0369: 		if(isAppendable)
1:eac0369: 			setupPositionBasedScan(numRowsOut);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Reopen the scan.  Typically faster than open()/close()
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException on error
1:eac0369: 	 */
1:eac0369: 	public void reopenCore() throws StandardException
1:eac0369: 	{
1:eac0369: 		numRowsOut = 0;
1:eac0369: 		isOpen = true;
1:eac0369: 		currentRow = null;
1:eac0369: 
1:eac0369: 		if(isAppendable)
1:eac0369: 		{
1:eac0369: 			setupPositionBasedScan(numRowsOut);
1:eac0369: 			return;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (scan != null)
1:eac0369: 		{
1:eac0369: 			scan.reopenScan(
1:eac0369:                 (DataValueDescriptor[]) null,		// start key value
1:eac0369:                 0,						// start operator
1:eac0369:                 null,					// qualifier
1:eac0369:                 (DataValueDescriptor[]) null,		// stop key value
1:eac0369:                 0);						// stop operator
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the next row.
1:eac0369: 	 *
1:eac0369: 	 * @return the next row, or null if none
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException on error
1:eac0369: 	 */
1:eac0369: 	public ExecRow getNextRowCore()
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 
1:eac0369: 		if (!isOpen)
1:eac0369: 		{
1:eac0369: 			return (ExecRow)null;
1:eac0369: 		}
1:eac0369: 			
1:eac0369: 		if(isAppendable)
1:eac0369: 		{
1:eac0369: 			return getNextAppendedRow() ;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (isVirtualMemHeap && holder.lastArraySlot >= 0)
1:eac0369: 		{
1:eac0369: 			numRowsOut++;
1:eac0369: 			currentRow = rowArray[holder.lastArraySlot];
1:eac0369: 			currRowFromMem = true;
1:eac0369: 			return currentRow;
1:eac0369: 		}
1:eac0369: 		else if (numRowsOut++ <= holder.lastArraySlot)
1:eac0369: 		{
1:eac0369: 			currentRow = rowArray[numRowsOut-1];
1:eac0369: 			return currentRow;
1:eac0369: 		}
1:eac0369: 
1:2a31ed9: 		if (holder.getTemporaryConglomId() == 0)
1:eac0369: 		{
1:eac0369: 			return (ExecRow)null;
1:eac0369: 		}
1:eac0369: 			
1:eac0369: 		/*
1:eac0369: 		** Advance in the temporary conglomerate
1:eac0369: 		*/
1:eac0369: 		if (scan == null)
1:eac0369: 		{
1:eac0369: 			scan = 
1:eac0369:                 tc.openScan(
1:2a31ed9:                     holder.getTemporaryConglomId(),
1:eac0369:                     false,					// hold
1:eac0369:                     0, 		// open read only
1:eac0369:                     TransactionController.MODE_TABLE,
1:eac0369:                     TransactionController.ISOLATION_SERIALIZABLE,
1:eac0369:                     (FormatableBitSet) null, 
1:eac0369:                     (DataValueDescriptor[]) null,		// start key value
1:eac0369:                     0,						// start operator
1:eac0369:                     null,					// qualifier
1:eac0369:                     (DataValueDescriptor[]) null,		// stop key value
1:eac0369:                     0);						// stop operator
1:eac0369: 		}
1:eac0369: 		else if (isVirtualMemHeap && holder.state == TemporaryRowHolderImpl.STATE_INSERT)
1:eac0369: 		{
1:eac0369: 			holder.state = TemporaryRowHolderImpl.STATE_DRAIN;
1:eac0369: 			scan.reopenScan(
1:eac0369:                 (DataValueDescriptor[]) null,		// start key value
1:eac0369:                 0,						// start operator
1:eac0369:                 null,					// qualifier
1:eac0369:                 (DataValueDescriptor[]) null,		// stop key value
1:eac0369:                 0);						// stop operator
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (scan.next())
1:eac0369: 		{
1:eac0369: 			currentRow = rowArray[0].getNewNullRow();
1:eac0369: 			scan.fetch(currentRow.getRowArray());
1:eac0369: 			currRowFromMem = false;
1:eac0369: 			return currentRow;
1:eac0369: 		}
1:eac0369: 		return (ExecRow)null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public void deleteCurrentRow()
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:6b26ee1: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(isVirtualMemHeap, "deleteCurrentRow is not implemented");
1:eac0369: 		}
1:eac0369: 		if (currRowFromMem)
1:eac0369: 		{
1:eac0369: 			if (holder.lastArraySlot > 0)				// 0 is kept for template
1:eac0369: 				rowArray[holder.lastArraySlot] = null;  // erase reference
1:eac0369: 			holder.lastArraySlot--;
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			if (baseRowLocation == null)
1:eac0369: 				baseRowLocation = scan.newRowLocationTemplate();
1:eac0369: 			scan.fetchLocation(baseRowLocation);
1:eac0369: 			if(heapCC == null)
1:eac0369: 			{
1:2a31ed9:                 heapCC = tc.openConglomerate(holder.getTemporaryConglomId(),
1:eac0369: 											  false,
1:eac0369: 											  TransactionController.OPENMODE_FORUPDATE,
1:eac0369: 											  TransactionController.MODE_TABLE,
1:eac0369: 											  TransactionController.ISOLATION_SERIALIZABLE);
1:eac0369: 			}
1:eac0369: 			heapCC.delete(baseRowLocation);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	//following variables are specific to the position based scans.
1:eac0369: 	DataValueDescriptor[] indexRow;
1:eac0369: 	ScanController indexsc;
1:eac0369: 
1:eac0369: 	//open the scan of the temporary heap and the position index
1:eac0369: 	private void setupPositionBasedScan(long position) throws StandardException
1:eac0369: 	{
1:eac0369: 
1:eac0369: 		//incase nothing is inserted yet into the temporary row holder
1:2a31ed9:         if (holder.getTemporaryConglomId() == 0)
1:eac0369: 			return;
1:eac0369: 		if(heapCC == null)
1:eac0369: 		{
1:2a31ed9: 			heapCC = tc.openConglomerate( holder.getTemporaryConglomId(),
1:eac0369: 										  false,
1:eac0369: 										  0,
1:eac0369: 										  TransactionController.MODE_TABLE,
1:eac0369: 										  TransactionController.ISOLATION_SERIALIZABLE);
1:eac0369: 
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		currentRow = rowArray[0].getNewNullRow();
1:eac0369: 		indexRow = new DataValueDescriptor[2];
1:eac0369: 		indexRow[0] = new SQLLongint(position);
1:eac0369: 		indexRow[1] = 	heapCC.newRowLocationTemplate();
1:eac0369: 
1:eac0369: 		DataValueDescriptor[] searchRow =  new DataValueDescriptor[1];
1:eac0369: 		searchRow[0] = new SQLLongint(position);
1:eac0369: 
1:eac0369: 		if(indexsc == null)
1:eac0369: 		{
1:eac0369: 			indexsc = tc.openScan(positionIndexConglomId,
1:eac0369: 								  false,                           // don't hold open across commit
1:eac0369: 								  0,                               // for read
1:eac0369: 								  TransactionController.MODE_TABLE,
1:eac0369: 								  TransactionController.ISOLATION_SERIALIZABLE,
1:eac0369: 								  (FormatableBitSet) null,                  // all fields as objects
1:eac0369: 								  searchRow,            	          // start position - first row
1:eac0369: 								  ScanController.GE,               // startSearchOperation
1:eac0369: 								  null,                            //scanQualifier,
1:eac0369: 								  null,                           // stop position - through last row
1:eac0369: 								  ScanController.GT);              // stopSearchOperation
1:eac0369: 		}else
1:eac0369: 		{
1:eac0369: 
1:eac0369: 			indexsc.reopenScan(
1:eac0369: 						searchRow,                      	// startKeyValue
1:eac0369: 						ScanController.GE,            		// startSearchOp
1:eac0369: 						null,                         		// qualifier
1:eac0369: 						null, 		                        // stopKeyValue
1:eac0369: 						ScanController.GT             		// stopSearchOp 
1:eac0369: 						);
1:eac0369: 		}
1:eac0369: 		
1:eac0369: 	} 
1:eac0369: 
1:eac0369: 
1:eac0369: 	//get the next row inserted into the temporary holder
1:eac0369: 	private ExecRow getNextAppendedRow() throws StandardException
1:eac0369: 	{
1:eac0369: 		if (indexsc == null) return null;
1:d3a4f64: 		if (!indexsc.fetchNext(indexRow))
1:eac0369: 		{
1:6b26ee1: 			return null;
1:eac0369: 		}
1:eac0369: 		
1:eac0369: 		RowLocation baseRowLocation =  (RowLocation) indexRow[1];
1:eac0369: 		boolean base_row_exists = 
1:eac0369:             heapCC.fetch(
1:eac0369:                 baseRowLocation, currentRow.getRowArray(), (FormatableBitSet) null);
1:eac0369: 
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:             SanityManager.ASSERT(base_row_exists, "base row disappeared.");
1:eac0369:         }
1:eac0369: 		numRowsOut++; 
1:eac0369: 		return currentRow;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return the point of attachment for this subquery.
1:eac0369: 	 * (Only meaningful for Any and Once ResultSets, which can and will only
1:eac0369: 	 * be at the top of a ResultSet for a subquery.)
1:eac0369: 	 *
1:eac0369: 	 * @return int	Point of attachment (result set number) for this
1:eac0369: 	 *			    subquery.  (-1 if not a subquery - also Sanity violation)
1:eac0369: 	 */
1:eac0369: 	public int getPointOfAttachment()
1:eac0369: 	{
1:eac0369: 		return -1;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return the isolation level of the scan in the result set.
1:eac0369: 	 * Only expected to be called for those ResultSets that
1:eac0369: 	 * contain a scan.
1:eac0369: 	 *
1:eac0369: 	 * @return The isolation level of the scan (in TransactionController constants).
1:eac0369: 	 */
1:eac0369: 	public int getScanIsolationLevel()
1:eac0369: 	{
1:eac0369: 		return TransactionController.ISOLATION_SERIALIZABLE;	
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Notify a NPRS that it is the source for the specified 
1:eac0369: 	 * TargetResultSet.  This is useful when doing bulk insert.
1:eac0369: 	 *
1:eac0369: 	 * @param trs	The TargetResultSet.
1:eac0369: 	 */
1:eac0369: 	public void setTargetResultSet(TargetResultSet trs)
1:eac0369: 	{
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set whether or not the NPRS need the row location when acting
1:eac0369: 	 * as a row source.  (The target result set determines this.)
1:eac0369: 	 * 
1:eac0369: 	 */
1:eac0369: 	public void setNeedsRowLocation(boolean needsRowLocation)
1:eac0369: 	{
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the estimated row count from this result set.
1:eac0369: 	 *
1:eac0369: 	 * @return	The estimated row count (as a double) from this result set.
1:eac0369: 	 */
1:eac0369: 	public double getEstimatedRowCount()
1:eac0369: 	{
1:eac0369: 		return 0d;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the number of this ResultSet, which is guaranteed to be unique
1:eac0369: 	 * within a statement.
1:eac0369: 	 */
1:eac0369: 	public int resultSetNumber()
1:eac0369: 	{
1:01632c2: 		return TEMPORARY_RESULT_SET_NUMBER;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set the current row to the row passed in.
1:eac0369: 	 *
1:eac0369: 	 * @param row the new current row
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 	public void setCurrentRow(ExecRow row)
1:eac0369: 	{
1:eac0369: 		currentRow = row;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Clear the current row
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 	public void clearCurrentRow()
1:eac0369: 	{
1:eac0369: 		currentRow = null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * This result set has its row from the last fetch done. 
1:eac0369: 	 * If the cursor is closed, a null is returned.
1:eac0369: 	 *
1:eac0369: 	 * @see CursorResultSet
1:eac0369: 	 *
1:eac0369: 	 * @return the last row returned;
1:eac0369: 	 * @exception StandardException thrown on failure.
1:eac0369: 	 */
1:eac0369: 	public ExecRow getCurrentRow() throws StandardException 
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(isOpen, "resultSet expected to be open");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return currentRow;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Returns the row location of the current base table row of the cursor.
1:eac0369: 	 * If this cursor's row is composed of multiple base tables' rows,
1:eac0369: 	 * i.e. due to a join, then a null is returned.  For
1:eac0369: 	 * a temporary row holder, we always return null.
1:eac0369: 	 *
1:eac0369: 	 * @return the row location of the current cursor row.
1:eac0369: 	 */
1:eac0369: 	public RowLocation getRowLocation()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(isOpen, "resultSet expected to be open");
1:eac0369: 		}
1:eac0369: 		return (RowLocation)null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Clean up
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException thrown on error
1:eac0369: 	 */
1:eac0369: 	public void	close() throws StandardException
1:eac0369: 	{
1:eac0369: 		isOpen = false;
1:eac0369: 		numRowsOut = 0;
1:eac0369: 		currentRow = null;
1:eac0369: 		if (scan != null)
1:eac0369: 		{
1:eac0369: 			scan.close();
1:eac0369: 			scan = null;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	//////////////////////////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	// MISC FROM RESULT SET
1:eac0369: 	//
1:eac0369: 	/////////////////////////////////////////////////////////////////////////
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Returns TRUE if the statement returns rows (i.e. is a SELECT
1:eac0369: 	 * or FETCH statement), FALSE if it returns no rows.
1:eac0369: 	 *
1:eac0369: 	 * @return	TRUE if the statement returns rows, FALSE if not.
1:eac0369: 	 */
1:eac0369: 	public boolean	returnsRows()
1:eac0369: 	{
1:eac0369: 		return true;
1:eac0369: 	}
1:eac0369: 
1:7fb9956: 	public long modifiedRowCount() { return 0L;};
1:eac0369: 
1:eac0369: 	/**
1:c69c8b0: 	 * Returns a ResultDescription object, which describes the results
1:c69c8b0: 	 * of the statement this ResultSet is in. This will *not* be a
1:c69c8b0: 	 * description of this particular ResultSet, if this is not the
1:c69c8b0: 	 * outermost ResultSet.
1:c69c8b0: 	 *
1:c69c8b0: 	 * @return	A ResultDescription describing the results of the
1:c69c8b0: 	 *		statement.
1:c69c8b0: 	 */
1:c69c8b0: 	public ResultDescription	getResultDescription()
1:c69c8b0: 	{
1:c69c8b0: 		return resultDescription;
1:c69c8b0: 	}
1:c69c8b0: 
1:c69c8b0: 	/**
1:eac0369: 	 * Tells the system that there will be calls to getNextRow().
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on failure
1:eac0369: 	 */
1:eac0369: 	public void open() throws StandardException
1:eac0369: 	{
1:eac0369: 		openCore();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Returns the row at the absolute position from the query, 
1:eac0369: 	 * and returns NULL when there is no such position.
1:eac0369: 	 * (Negative position means from the end of the result set.)
1:eac0369: 	 * Moving the cursor to an invalid position leaves the cursor
1:eac0369: 	 * positioned either before the first row (negative position)
1:eac0369: 	 * or after the last row (positive position).
1:eac0369: 	 * NOTE: An exception will be thrown on 0.
1:eac0369: 	 *
1:eac0369: 	 * @param row	The position.
1:eac0369: 	 * @return	The row at the absolute position, or NULL if no such position.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on failure
1:eac0369: 	 * @see Row
1:eac0369: 	 */
1:eac0369: 	public ExecRow	getAbsoluteRow(int row) throws StandardException
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.THROWASSERT(
1:eac0369: 				"getAbsoluteRow() not expected to be called yet.");
1:eac0369: 		}
1:eac0369: 
1:88bb146: 		return null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Returns the row at the relative position from the current
1:eac0369: 	 * cursor position, and returns NULL when there is no such position.
1:eac0369: 	 * (Negative position means toward the beginning of the result set.)
1:eac0369: 	 * Moving the cursor to an invalid position leaves the cursor
1:eac0369: 	 * positioned either before the first row (negative position)
1:eac0369: 	 * or after the last row (positive position).
1:eac0369: 	 * NOTE: 0 is valid.
1:eac0369: 	 * NOTE: An exception is thrown if the cursor is not currently
1:eac0369: 	 * positioned on a row.
1:eac0369: 	 *
1:eac0369: 	 * @param row	The position.
1:eac0369: 	 * @return	The row at the relative position, or NULL if no such position.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on failure
1:eac0369: 	 * @see Row
1:eac0369: 	 */
1:eac0369: 	public ExecRow	getRelativeRow(int row) throws StandardException
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.THROWASSERT(
1:eac0369: 				"getRelativeRow() not expected to be called yet.");
1:eac0369: 		}
1:eac0369: 
3:eac0369: 		return null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Sets the current position to before the first row and returns NULL
1:eac0369: 	 * because there is no current row.
1:eac0369: 	 *
1:eac0369: 	 * @return	NULL.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on failure
1:eac0369: 	 * @see Row
1:eac0369: 	 */
1:eac0369: 	public ExecRow	setBeforeFirstRow() 
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.THROWASSERT(
1:eac0369: 				"setBeforeFirstRow() not expected to be called yet.");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Returns the first row from the query, and returns NULL when there
1:eac0369: 	 * are no rows.
1:eac0369: 	 *
1:eac0369: 	 * @return	The first row, or NULL if no rows.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on failure
1:eac0369: 	 * @see Row
1:eac0369: 	 */
1:eac0369: 	public ExecRow	getFirstRow() 
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.THROWASSERT(
1:eac0369: 				"getFirstRow() not expected to be called yet.");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Returns the next row from the query, and returns NULL when there
1:eac0369: 	 * are no more rows.
1:eac0369: 	 *
1:eac0369: 	 * @return	The next row, or NULL if no more rows.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on failure
1:eac0369: 	 * @see Row
1:eac0369: 	 */
1:eac0369: 	public ExecRow	getNextRow() throws StandardException
1:eac0369: 	{
1:eac0369: 		return getNextRowCore();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Returns the previous row from the query, and returns NULL when there
1:eac0369: 	 * are no more previous rows.
1:eac0369: 	 *
1:eac0369: 	 * @return	The previous row, or NULL if no more previous rows.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on failure
1:eac0369: 	 * @see Row
1:eac0369: 	 */
1:eac0369: 	public ExecRow	getPreviousRow() 
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.THROWASSERT(
1:eac0369: 				"getPreviousRow() not expected to be called yet.");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Returns the last row from the query, and returns NULL when there
1:eac0369: 	 * are no rows.
1:eac0369: 	 *
1:eac0369: 	 * @return	The last row, or NULL if no rows.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on failure
1:eac0369: 	 * @see Row
1:eac0369: 	 */
1:eac0369: 	public ExecRow	getLastRow()
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.THROWASSERT(
1:eac0369: 				"getLastRow() not expected to be called yet.");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Sets the current position to after the last row and returns NULL
1:eac0369: 	 * because there is no current row.
1:eac0369: 	 *
1:eac0369: 	 * @return	NULL.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on failure
1:eac0369: 	 * @see Row
1:eac0369: 	 */
1:eac0369: 	public ExecRow	setAfterLastRow() 
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.THROWASSERT(
1:eac0369: 				"getLastRow() not expected to be called yet.");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return null;
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Determine if the cursor is before the first row in the result 
1:eac0369:      * set.   
1:eac0369:      *
1:eac0369:      * @return true if before the first row, false otherwise. Returns
1:eac0369:      * false when the result set contains no rows.
1:eac0369:      */
1:eac0369:     public boolean checkRowPosition(int isType)
1:eac0369: 	{
1:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Returns the row number of the current row.  Row
1:eac0369: 	 * numbers start from 1 and go to 'n'.  Corresponds
1:eac0369: 	 * to row numbering used to position current row
1:eac0369: 	 * in the result set (as per JDBC).
1:eac0369: 	 *
1:eac0369: 	 * @return	the row number, or 0 if not on a row
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 	public int getRowNumber()
1:eac0369: 	{
2:eac0369: 		return 0;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Tells the system to clean up on an error.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error.
1:eac0369: 	 */
1:eac0369: 	public void	cleanUp() throws StandardException
1:eac0369: 	{
1:eac0369: 		close();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Find out if the ResultSet is closed or not.
1:eac0369: 		Will report true for result sets that do not return rows.
1:eac0369: 
1:eac0369: 		@return true if the ResultSet has been closed.
1:eac0369: 	 */
1:eac0369: 	public boolean isClosed()
1:eac0369: 	{
1:eac0369: 		return !isOpen;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Tells the system that there will be no more access
1:eac0369: 	 * to any database information via this result set;
1:eac0369: 	 * in particular, no more calls to open().
1:eac0369: 	 * Will close the result set if it is not already closed.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException	on error
1:eac0369: 	 */
1:eac0369: 	public void finish() throws StandardException
1:eac0369: 	{
1:eac0369: 		finished = true;
1:eac0369: 		close();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the execution time in milliseconds.
1:eac0369: 	 *
1:eac0369: 	 * @return long		The execution time in milliseconds.
1:eac0369: 	 */
1:eac0369: 	public long getExecuteTime()
1:eac0369: 	{
1:eac0369: 		return 0L;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see ResultSet#getAutoGeneratedKeysResultset
1:eac0369: 	 */
1:eac0369: 	public ResultSet getAutoGeneratedKeysResultset()
1:eac0369: 	{
1:eac0369: 		//A non-null resultset would be returned only for an insert statement 
1:eac0369: 		return (ResultSet)null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the Timestamp for the beginning of execution.
1:eac0369: 	 *
1:eac0369: 	 * @return Timestamp		The Timestamp for the beginning of execution.
1:eac0369: 	 */
1:eac0369: 	public Timestamp getBeginExecutionTimestamp()
1:eac0369: 	{
1:eac0369: 		return (Timestamp)null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the Timestamp for the end of execution.
1:eac0369: 	 *
1:eac0369: 	 * @return Timestamp		The Timestamp for the end of execution.
1:eac0369: 	 */
1:eac0369: 	public Timestamp getEndExecutionTimestamp()
1:eac0369: 	{
1:eac0369: 		return (Timestamp)null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return the total amount of time spent in this ResultSet
1:eac0369: 	 *
1:eac0369: 	 * @param type	CURRENT_RESULTSET_ONLY - time spent only in this ResultSet
1:eac0369: 	 *				ENTIRE_RESULTSET_TREE  - time spent in this ResultSet and below.
1:eac0369: 	 *
1:eac0369: 	 * @return long		The total amount of time spent (in milliseconds).
1:eac0369: 	 */
1:eac0369: 	public long getTimeSpent(int type)
1:eac0369: 	{
1:eac0369: 		return 0L;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the subquery ResultSet tracking array from the top ResultSet.
1:eac0369: 	 * (Used for tracking open subqueries when closing down on an error.)
1:eac0369: 	 *
1:eac0369: 	 * @param numSubqueries		The size of the array (For allocation on demand.)
1:eac0369: 	 *
1:eac0369: 	 * @return NoPutResultSet[]	Array of NoPutResultSets for subqueries.
1:eac0369: 	 */
1:eac0369: 	public NoPutResultSet[] getSubqueryTrackingArray(int numSubqueries)
1:eac0369: 	{
1:eac0369: 		return (NoPutResultSet[])null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Returns the name of the cursor, if this is cursor statement of some
1:eac0369: 	 * type (declare, open, fetch, positioned update, positioned delete,
1:eac0369: 	 * close).
1:eac0369: 	 *
1:eac0369: 	 * @return	A String with the name of the cursor, if any. Returns
1:eac0369: 	 *		NULL if this is not a cursor statement.
1:eac0369: 	 */
1:eac0369: 	public String	getCursorName()
1:eac0369: 	{
1:eac0369: 		return (String) null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see NoPutResultSet#requiresRelocking
1:eac0369: 	 */
1:eac0369: 	public boolean requiresRelocking()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.THROWASSERT(
1:eac0369: 				"requiresRelocking() not expected to be called for " +
1:eac0369: 				getClass().getName());
1:eac0369: 		}
1:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/////////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	// Access/RowSource -- not implemented
1:eac0369: 	// 
1:eac0369: 	/////////////////////////////////////////////////////////
1:eac0369: 	/**
1:eac0369: 		Get the next row as an array of column objects. The column objects can
1:eac0369: 		be a JBMS Storable or any
1:eac0369: 		Serializable/Externalizable/Formattable/Streaming type.
1:eac0369: 		<BR>
1:eac0369: 		A return of null indicates that the complete set of rows has been read.
1:eac0369: 
1:eac0369: 		<p>
1:eac0369: 		A null column can be specified by leaving the object null, or indicated
1:eac0369: 		by returning a non-null getValidColumns.  On streaming columns, it can
1:eac0369: 		be indicated by returning a non-null get FieldStates.
1:eac0369: 
1:eac0369: 		<p>
1:eac0369:         If RowSource.needToClone() is true then the returned row (the 
1:eac0369:         DataValueDescriptor[]) is guaranteed not to be modified by drainer of 
1:eac0369:         the RowSource (except that the input stream will be read, of course) 
1:eac0369:         and drainer will keep no reference to it before making the subsequent 
1:eac0369:         nextRow call.  So it is safe to return the same DataValueDescriptor[] 
1:eac0369:         in subsequent nextRow calls if that is desirable for performance 
1:eac0369:         reasons.  
1:eac0369: 		<p>
1:eac0369:         If RowSource.needToClone() is false then the returned row (the 
1:eac0369:         DataValueDescriptor[]) may be be modified by drainer of the RowSource, 
1:eac0369:         and the drainer may keep a reference to it after making the subsequent 
1:eac0369:         nextRow call.  In this case the client should severe all references to 
1:eac0369:         the row after returning it from getNextRowFromRowSource().
1:eac0369: 
1:94f158a: 		@exception StandardException Standard Derby Error Policy
1:eac0369: 	 */
1:eac0369: 	public DataValueDescriptor[] getNextRowFromRowSource() throws StandardException
1:eac0369: 	{ 
1:eac0369: 		return null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369:         Does the caller of getNextRowFromRowSource() need to clone the row
1:eac0369:         in order to keep a reference to the row past the 
1:eac0369:         getNextRowFromRowSource() call which returned the row.  This call
1:eac0369:         must always return the same for all rows in a RowSource (ie. the
1:eac0369:         caller will call this once per scan from a RowSource and assume the
1:eac0369:         behavior is true for all rows in the RowSource).
1:eac0369: 
1:eac0369: 	 */
1:eac0369: 	public boolean needsToClone()
1:eac0369: 	{
1:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  getValidColumns describes the DataValueDescriptor[] returned by all 
1:eac0369:       calls to the getNextRowFromRowSource() call. 
1:eac0369: 
1:eac0369: 	  If getValidColumns returns null, the number of columns is given by the
1:eac0369: 	  DataValueDescriptor.length where DataValueDescriptor[] is returned by the
1:eac0369:       preceeding getNextRowFromRowSource() call.  Column N maps to 
1:eac0369:       DataValueDescriptor[N], where column numbers start at zero.
1:eac0369: 
1:eac0369: 	  If getValidColumns return a non null validColumns FormatableBitSet the number of
1:eac0369: 	  columns is given by the number of bits set in validColumns.  Column N is
1:eac0369: 	  not in the partial row if validColumns.get(N) returns false.  Column N is
1:eac0369: 	  in the partial row if validColumns.get(N) returns true.  If column N is
1:eac0369: 	  in the partial row then it maps to DataValueDescriptor[M] where M is the
1:dbed020:       count of calls to validColumns.get(i) that return true where i &lt; N.  If
1:eac0369: 	  DataValueDescriptor.length is greater than the number of columns 
1:eac0369:       indicated by validColumns the extra entries are ignored.  
1:eac0369: 	*/
1:eac0369: 	public FormatableBitSet getValidColumns()
1:eac0369: 	{
1:eac0369: 		return null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		closeRowSource tells the RowSource that it will no longer need to
1:eac0369: 		return any rows and it can release any resource it may have.
1:eac0369: 		Subsequent call to any method on the RowSource will result in undefined
1:eac0369: 		behavior.  A closed rowSource can be closed again.
1:eac0369: 	*/
1:eac0369: 	public void closeRowSource()
1:eac0369: 	{ }
1:eac0369: 
1:eac0369: 
1:eac0369: 	/////////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	// Access/RowLocationRetRowSource -- not implemented
1:eac0369: 	// 
1:eac0369: 	/////////////////////////////////////////////////////////
1:eac0369: 	/**
1:eac0369: 		needsRowLocation returns true iff this the row source expects the
1:eac0369: 		drainer of the row source to call rowLocation after getting a row from
1:eac0369: 		getNextRowFromRowSource.
1:eac0369: 
1:eac0369: 		@return true iff this row source expects some row location to be
1:eac0369: 		returned 
1:eac0369: 		@see #rowLocation
1:eac0369: 	 */
1:eac0369: 	public boolean needsRowLocation()
1:eac0369: 	{
1:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: 
1:af1c18c:     public void setHasDeferrableChecks() {
1:af1c18c:         if (SanityManager.DEBUG) {
1:af1c18c:             SanityManager.NOTREACHED();
1:af1c18c:         }
1:af1c18c:     }
1:af1c18c: 
1:af1c18c:     public boolean needsRowLocationForDeferredCheckConstraints()
1:af1c18c:     {
1:af1c18c:         return false;
1:af1c18c:     }
1:af1c18c: 
1:af1c18c: 
1:eac0369: 	/**
1:eac0369: 		rowLocation is a callback for the drainer of the row source to return
1:eac0369: 		the rowLocation of the current row, i.e, the row that is being returned
1:eac0369: 		by getNextRowFromRowSource.  This interface is for the purpose of
1:eac0369: 		loading a base table with index.  In that case, the indices can be
1:eac0369: 		built at the same time the base table is laid down once the row
1:eac0369: 		location of the base row is known.  This is an example pseudo code on
1:eac0369: 		how this call is expected to be used:
1:eac0369: 		
1:eac0369: 		<BR><pre>
1:eac0369: 		boolean needsRL = rowSource.needsRowLocation();
1:eac0369: 		DataValueDescriptor[] row;
1:eac0369: 		while((row = rowSource.getNextRowFromRowSource()) != null)
1:eac0369: 		{
1:eac0369: 			RowLocation rl = heapConglomerate.insertRow(row);
1:eac0369: 			if (needsRL)
1:eac0369: 				rowSource.rowLocation(rl);
1:eac0369: 		}
1:eac0369: 		</pre><BR>
1:eac0369: 
1:eac0369: 		NeedsRowLocation and rowLocation will ONLY be called by a drainer of
1:eac0369: 		the row source which CAN return a row location.  Drainer of row source
1:eac0369: 		which cannot return rowLocation will guarentee to not call either
1:eac0369: 		callbacks. Conversely, if NeedsRowLocation is called and it returns
1:eac0369: 		true, then for every row return by getNextRowFromRowSource, a
1:eac0369: 		rowLocation callback must also be issued with the row location of the
1:eac0369: 		row.  Implementor of both the source and the drain of the row source
1:eac0369: 		must be aware of this protocol.
1:eac0369: 
1:eac0369: 		<BR>
1:eac0369: 		The RowLocation object is own by the caller of rowLocation, in other
1:eac0369: 		words, the drainer of the RowSource.  This is so that we don't need to
1:eac0369: 		new a row location for every row.  If the Row Source wants to keep the
1:eac0369: 		row location, it needs to clone it (RowLocation is a ClonableObject).
1:eac0369: 		@exception StandardException on error
1:eac0369: 	 */
1:eac0369: 	public void rowLocation(RowLocation rl) throws StandardException
1:eac0369: 	{ }
1:eac0369: 
1:af1c18c:     public void offendingRowLocation(
1:af1c18c:             RowLocation rl, long containdId) throws StandardException {
1:af1c18c:         if (SanityManager.DEBUG) {
1:af1c18c:             SanityManager.NOTREACHED();
1:af1c18c:         }
1:af1c18c:     }
1:af1c18c: 
1:2700e3d: 	/**
1:2700e3d: 	 * @see NoPutResultSet#positionScanAtRowLocation
1:2700e3d: 	 *
1:2700e3d: 	 * This method is result sets used for scroll insensitive updatable 
1:2700e3d: 	 * result sets for other result set it is a no-op.
1:2700e3d: 	 */
1:2700e3d: 	public void positionScanAtRowLocation(RowLocation rl) 
1:2700e3d: 		throws StandardException 
1:2700e3d: 	{
1:2700e3d: 		// Only used for Scrollable insensitive result sets otherwise no-op
1:2700e3d: 	}
1:2700e3d: 
1:eac0369: 	// Class implementation
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Is this ResultSet or it's source result set for update
1:eac0369: 	 * This method will be overriden in the inherited Classes
1:eac0369: 	 * if it is true
1:eac0369: 	 * @return Whether or not the result set is for update.
1:eac0369: 	 */
1:eac0369: 	public boolean isForUpdate()
1:eac0369: 	{
1:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Shallow clone this result set.  Used in trigger reference.
1:eac0369: 	 * beetle 4373.
1:eac0369: 	 */
1:eac0369: 	public Object clone()
1:eac0369: 	{
1:eac0369: 		Object clo = null;
1:eac0369: 		try {
1:eac0369: 			clo = super.clone();
1:eac0369: 		}
1:eac0369: 		catch (CloneNotSupportedException e) {}
1:eac0369: 		return clo;
1:eac0369: 	}
1:75ec275: 
1:75ec275:     public void addWarning(SQLWarning w) {
1:75ec275:         getActivation().addWarning(w);
1:75ec275:     }
1:75ec275: 
1:75ec275: 	public SQLWarning getWarnings() {
1:eac0369: 		return null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:2700e3d: 	 * @see NoPutResultSet#updateRow
1:2700e3d: 	 *
1:2700e3d: 	 * This method is result sets used for scroll insensitive updatable 
1:2700e3d: 	 * result sets for other result set it is a no-op.
1:2700e3d: 	 */
1:7d0f620: 	public void updateRow(ExecRow row, RowChanger rowChanger)
1:7d0f620: 			throws StandardException {
1:2700e3d: 		// Only ResultSets of type Scroll Insensitive implement
1:2700e3d: 		// detectability, so for other result sets this method
1:2700e3d: 		// is a no-op
1:2700e3d: 	}
1:2700e3d:  
1:2700e3d: 	/**
1:2700e3d: 	 * @see NoPutResultSet#markRowAsDeleted
1:2700e3d: 	 *
1:2700e3d: 	 * This method is result sets used for scroll insensitive updatable 
1:2700e3d: 	 * result sets for other result set it is a no-op.
1:2700e3d: 	 */
1:2700e3d: 	public void markRowAsDeleted() throws StandardException {
1:2700e3d: 		// Only ResultSets of type Scroll Insensitive implement
1:2700e3d: 		// detectability, so for other result sets this method
1:2700e3d: 		// is a no-op
1:2700e3d: 	}
1:2700e3d: 
1:2700e3d: 	/**
1:81b9853: 	 * Return the <code>Activation</code> for this result set.
1:81b9853: 	 *
1:81b9853: 	 * @return activation
1:81b9853: 	 */
1:81b9853: 	public final Activation getActivation() {
1:81b9853: 		return holder.activation;
1:eac0369: 	}
1:b197ffa:     
1:b197ffa:     public Element toXML( Element parentNode, String tag ) throws Exception
1:b197ffa:     {
1:b197ffa:         return BasicNoPutResultSetImpl.childrenToXML( BasicNoPutResultSetImpl.toXML( parentNode, tag, this ), this );
1:b197ffa:     }
1:b197ffa: 
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1:       count of calls to validColumns.get(i) that return true where i &lt; N.  If
commit:01632c2
/////////////////////////////////////////////////////////////////////////
1: 		return TEMPORARY_RESULT_SET_NUMBER;
commit:b197ffa
/////////////////////////////////////////////////////////////////////////
1: import org.w3c.dom.Element;
/////////////////////////////////////////////////////////////////////////
1:     
1:     public Element toXML( Element parentNode, String tag ) throws Exception
1:     {
1:         return BasicNoPutResultSetImpl.childrenToXML( BasicNoPutResultSetImpl.toXML( parentNode, tag, this ), this );
1:     }
1: 
commit:7fb9956
/////////////////////////////////////////////////////////////////////////
1: 	public long modifiedRowCount() { return 0L;};
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:af1c18c
/////////////////////////////////////////////////////////////////////////
1:     public void setHasDeferrableChecks() {
1:         if (SanityManager.DEBUG) {
1:             SanityManager.NOTREACHED();
1:         }
1:     }
1: 
1:     public boolean needsRowLocationForDeferredCheckConstraints()
1:     {
1:         return false;
1:     }
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:     public void offendingRowLocation(
1:             RowLocation rl, long containdId) throws StandardException {
1:         if (SanityManager.DEBUG) {
1:             SanityManager.NOTREACHED();
1:         }
1:     }
1: 
commit:7d0f620
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.execute.RowChanger;
/////////////////////////////////////////////////////////////////////////
1: 	public void updateRow(ExecRow row, RowChanger rowChanger)
1: 			throws StandardException {
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:75ec275
/////////////////////////////////////////////////////////////////////////
1: import java.sql.SQLWarning;
/////////////////////////////////////////////////////////////////////////
1: 
1:     public void addWarning(SQLWarning w) {
1:         getActivation().addWarning(w);
1:     }
1: 
1: 	public SQLWarning getWarnings() {
commit:c69c8b0
/////////////////////////////////////////////////////////////////////////
1: 	private ResultDescription		resultDescription;
/////////////////////////////////////////////////////////////////////////
1: 	 * @param resultDescription value returned by getResultDescription()
1: 	public TemporaryRowHolderResultSet
1: 		ResultDescription			resultDescription,
1: 		this(tc, rowArray, resultDescription, isVirtualMemHeap, false, 0, holder);
/////////////////////////////////////////////////////////////////////////
1: 	 * @param resultDescription value returned by getResultDescription()
1: 	public TemporaryRowHolderResultSet
1: 		ResultDescription			resultDescription,
/////////////////////////////////////////////////////////////////////////
1: 		this.resultDescription = resultDescription;
/////////////////////////////////////////////////////////////////////////
1: 	public static TemporaryRowHolderResultSet getNewRSOnCurrentRow
1: 			new TemporaryRowHolderImpl(activation, null,
1: 									   rs.getResultDescription());
/////////////////////////////////////////////////////////////////////////
1: 	 * Returns a ResultDescription object, which describes the results
1: 	 * of the statement this ResultSet is in. This will *not* be a
1: 	 * description of this particular ResultSet, if this is not the
1: 	 * outermost ResultSet.
1: 	 *
1: 	 * @return	A ResultDescription describing the results of the
1: 	 *		statement.
1: 	 */
1: 	public ResultDescription	getResultDescription()
1: 	{
1: 		return resultDescription;
1: 	}
1: 
1: 	/**
commit:2700e3d
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * @see NoPutResultSet#positionScanAtRowLocation
1: 	 *
1: 	 * This method is result sets used for scroll insensitive updatable 
1: 	 * result sets for other result set it is a no-op.
1: 	 */
1: 	public void positionScanAtRowLocation(RowLocation rl) 
1: 		throws StandardException 
1: 	{
1: 		// Only used for Scrollable insensitive result sets otherwise no-op
1: 	}
1: 
/////////////////////////////////////////////////////////////////////////
1: 	 * @see NoPutResultSet#updateRow
1: 	 *
1: 	 * This method is result sets used for scroll insensitive updatable 
1: 	 * result sets for other result set it is a no-op.
1: 	 */
0: 	public void updateRow(ExecRow row) throws StandardException {
1: 		// Only ResultSets of type Scroll Insensitive implement
1: 		// detectability, so for other result sets this method
1: 		// is a no-op
1: 	}
1:  
1: 	/**
1: 	 * @see NoPutResultSet#markRowAsDeleted
1: 	 *
1: 	 * This method is result sets used for scroll insensitive updatable 
1: 	 * result sets for other result set it is a no-op.
1: 	 */
1: 	public void markRowAsDeleted() throws StandardException {
1: 		// Only ResultSets of type Scroll Insensitive implement
1: 		// detectability, so for other result sets this method
1: 		// is a no-op
1: 	}
1: 
1: 	/**
commit:81b9853
/////////////////////////////////////////////////////////////////////////
1: class TemporaryRowHolderResultSet implements CursorResultSet, NoPutResultSet, Cloneable
/////////////////////////////////////////////////////////////////////////
1: 	 * @param activation the activation
/////////////////////////////////////////////////////////////////////////
1: 		Activation				activation,
0: 		TemporaryRowHolderImpl singleRow =
1: 			new TemporaryRowHolderImpl(activation, null,
1: 									   rs.getResultDescription());
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * Return the <code>Activation</code> for this result set.
1: 	 *
1: 	 * @return activation
1: 	 */
1: 	public final Activation getActivation() {
1: 		return holder.activation;
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:d9d1bc8
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.dictionary.TriggerDescriptor;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
/////////////////////////////////////////////////////////////////////////
1: 	//Make an array which is a superset of the 2 passed column arrays.
1: 	//The superset will not have any duplicates
1: 	private static int[] supersetofAllColumns(int[] columnsArray1, int[] columnsArray2)
1: 	{
1: 		int maxLength = columnsArray1.length + columnsArray2.length;
1: 		int[] maxArray = new int[maxLength];
1: 		for (int i=0; i<maxLength; i++) maxArray[i]=-1;
1: 		
1: 		//First simply copy the first array into superset
1: 		for (int i=0; i<columnsArray1.length; i++) {
1: 			maxArray[i] = columnsArray1[i];
1: 		}
1: 		
1: 		//Now copy only new values from second array into superset
1: 		int validColsPosition=columnsArray1.length;
1: 		for (int i=0; i<columnsArray2.length; i++) {
1: 			boolean found = false;
1: 			for (int j=0;j<validColsPosition;j++) {
1: 				if (maxArray[j] == columnsArray2[i]) {
1: 					found = true;
1: 					break;
1: 				}
1: 			}
1: 			if (!found) {
1: 				maxArray[validColsPosition] = columnsArray2[i];
1: 				validColsPosition++;
1: 			}
1: 		}
1: 		maxArray = shrinkArray(maxArray);
1: 		java.util.Arrays.sort(maxArray);
1: 		return maxArray;
1: 	}
1: 
1: 	//The passed array can have some -1 elements and some +ve elements
1: 	// Return an array containing just the +ve elements
1: 	private static int[] shrinkArray(int[] columnsArrary) {
1: 		int countOfColsRefedInArray = 0;
1: 		int numberOfColsInTriggerTable = columnsArrary.length;
1: 
1: 		//Count number of non -1 entries
1: 		for (int i=0; i < numberOfColsInTriggerTable; i++) {
1: 			if (columnsArrary[i] != -1)
1: 				countOfColsRefedInArray++;
1: 		}
1: 
1: 		if (countOfColsRefedInArray > 0){
1: 			int[] tempArrayOfNeededColumns = new int[countOfColsRefedInArray];
1: 			int j=0;
1: 			for (int i=0; i < numberOfColsInTriggerTable; i++) {
1: 				if (columnsArrary[i] != -1)
1: 					tempArrayOfNeededColumns[j++] = columnsArrary[i];
1: 			}
1: 			return tempArrayOfNeededColumns;
1: 		} else
1: 			return null;
1: 	}
1: 
1: 	//Return an array which contains the column positions of all the 
1: 	// +ve columns in the passed array
1: 	private static int[] justTheRequiredColumnsPositions(int[] columnsArrary) {
1: 		int countOfColsRefedInArray = 0;
1: 		int numberOfColsInTriggerTable = columnsArrary.length;
1: 
1: 		//Count number of non -1 entries
1: 		for (int i=0; i < numberOfColsInTriggerTable; i++) {
1: 			if (columnsArrary[i] != -1)
1: 				countOfColsRefedInArray++;
1: 		}
1: 
1: 		if (countOfColsRefedInArray > 0){
1: 			int[] tempArrayOfNeededColumns = new int[countOfColsRefedInArray];
1: 			int j=0;
1: 			for (int i=0; i < numberOfColsInTriggerTable; i++) {
1: 				if (columnsArrary[i] != -1)
1: 					tempArrayOfNeededColumns[j++] = i+1;
1: 			}
1: 			return tempArrayOfNeededColumns;
1: 		} else
1: 			return null;
1: 	}
1: 	 * row. This row will either have all the columns from
1: 	 * the current row of the passed resultset or a subset 
1: 	 * of the columns from the passed resulset. It all depends
1: 	 * on what columns are needed by the passed trigger and what
1: 	 * columns exist in the resulset. The Temp resulset
1: 	 * should only have the columns required by the trigger.
1: 	 * @param triggerd We are building Temp resultset for this trigger
1: 	 * @param colsReadFromTable The passed resultset is composed of
1: 	 *   these columns. We will create a temp resultset which
1: 	 *   will have either all these columns or only a subset of
1: 	 *   these columns. It all depends on what columns are needed
1: 	 *   by the trigger. If this param is null, then that means that
1: 	 *   all the columns from the trigger table have been read into
1: 	 *   the passed resultset.
/////////////////////////////////////////////////////////////////////////
1: 			TriggerDescriptor triggerd,
1: 		CursorResultSet 		rs,
1: 		int[]	colsReadFromTable
1: 		TemporaryRowHolderImpl singleRow;
1: 		DataDictionary dd = activation.getLanguageConnectionContext().getDataDictionary();
1: 		// In soft upgrade mode, we could be dealing with databases created 
1: 		// with 10.8 or prior and for such databases, we do not want to do
1: 		// any column reading optimization to maintain backward compatibility
1: 		if (!dd.checkVersion(DataDictionary.DD_VERSION_DERBY_10_9,null)) {
1: 	    	singleRow =
1: 	    		new TemporaryRowHolderImpl(activation, null,
0: 						   rs.getResultDescription());
1: 			singleRow.insert(rs.getCurrentRow());
1: 			return (TemporaryRowHolderResultSet) singleRow.getResultSet();
1: 		}
1: 
1: 		//Get columns referenced in trigger action through REFERENCING clause
1:     	int[] referencedColsInTriggerAction = triggerd.getReferencedColsInTriggerAction();
1:     	// Get trigger column. If null, then it means that all the columns
1:     	// have been read because this trigger can be fired for any of the
1:     	// columns in the table
1:     	int[] referencedColsInTrigger = triggerd.getReferencedCols();
1: 
1: 	    if ((referencedColsInTrigger != null) && //this means not all the columns are being read
1: 	    		(triggerd.isRowTrigger() && referencedColsInTriggerAction!=null &&
1: 	    		referencedColsInTriggerAction.length != 0)) {
1: 	    	//If we are here, then trigger is defined on specific columns and
1: 	    	// it has trigger action columns used through REFERENCING clause
1: 
1: 	    	//Make an array which is a superset of trigger columns and 
1: 	    	// trigger action columns referenced through REFERENCING clause.
1: 	    	//This superset is what the trigger is looking for in it's
1: 	    	// resulset. 
1: 		    int[] colsInTrigger = supersetofAllColumns(referencedColsInTrigger,referencedColsInTriggerAction);
1: 	    	int colsCountInTrigger = colsInTrigger.length;
1: 		    int[] colsReallyNeeded = new int[colsCountInTrigger];
1: 
1: 		    //Here, we find out what columns make up the passed resulset
1: 	    	int[] actualColsReadFromTable;
1:     		if (colsReadFromTable != null) //this means not all the columns are being read
1:     			actualColsReadFromTable = justTheRequiredColumnsPositions(colsReadFromTable);
1:     		else {
1:     			int colsInTriggerTable = triggerd.getTableDescriptor().getNumberOfColumns();
1:     			actualColsReadFromTable = new int[colsInTriggerTable];
1:     			for (int i=1; i<=colsInTriggerTable; i++)
1:     				actualColsReadFromTable[i-1] = i;
1:     		}
1: 	    	
1:     		//Now we have what columns make up the passed resulset and what
1:     		// columns are needed by the trigger. We will map a temporary
1:     		// resultset for the trigger out of the above information using
1:     		// the passed resultset
1: 	    	int indexInActualColsReadFromTable = 0;
1: 	    	for (int i=0; i<colsCountInTrigger; i++) {
1: 
1: 	    		for (;indexInActualColsReadFromTable < actualColsReadFromTable.length; indexInActualColsReadFromTable++)
1: 	    		{
1: 	    			/* Return 1-based key column position if column is in the key */
1: 	    			if (actualColsReadFromTable[indexInActualColsReadFromTable] 
1: 	    			                            == colsInTrigger[i])
1: 	    			{
1: 	    				colsReallyNeeded[i] = indexInActualColsReadFromTable+1;
1: 	    				break;
1: 	    			}
1: 	    		}
1: 	    	}    			
1: 	    	singleRow =
1: 	    		new TemporaryRowHolderImpl(activation, null,
1: 	    				activation.getLanguageConnectionContext().getLanguageFactory().
1: 	    				getResultDescription(rs.getResultDescription(),colsReallyNeeded));
1: 			ExecRow				row = activation.getExecutionFactory().getValueRow( colsCountInTrigger );
1: 			for (int i=0; i<colsCountInTrigger; i++)
1: 				row.setColumn(i+1, rs.getCurrentRow().getColumn(colsReallyNeeded[i]));
1: 			singleRow.insert(row);
1: 	    } else {
1: 	    	singleRow =
1: 	    		new TemporaryRowHolderImpl(activation, null,
0: 						   rs.getResultDescription());
1: 			singleRow.insert(rs.getCurrentRow());
1: 	    }
1: 	    
author:Dyre Tjeldvoll
-------------------------------------------------------------------------------
commit:2a31ed9
/////////////////////////////////////////////////////////////////////////
1:             if (SanityManager.DEBUG) {
1:                 SanityManager.ASSERT(currentConglomId == holder.getTemporaryConglomId(),
1:                         "currentConglomId(" + currentConglomId + 
1:                         ") == holder.getTemporaryConglomeateId (" + 
1:                         holder.getTemporaryConglomId() + ")");
1:             }
/////////////////////////////////////////////////////////////////////////
1: 		if (holder.getTemporaryConglomId() == 0)
/////////////////////////////////////////////////////////////////////////
1:                     holder.getTemporaryConglomId(),
/////////////////////////////////////////////////////////////////////////
1:                 heapCC = tc.openConglomerate(holder.getTemporaryConglomId(),
/////////////////////////////////////////////////////////////////////////
1:         if (holder.getTemporaryConglomId() == 0)
1: 			heapCC = tc.openConglomerate( holder.getTemporaryConglomId(),
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:24e3f7e
/////////////////////////////////////////////////////////////////////////
commit:88bb146
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 	TemporaryRowHolderResultSet
0: 		this(tc, rowArray, isVirtualMemHeap, false, 0, holder);
/////////////////////////////////////////////////////////////////////////
0: 	TemporaryRowHolderResultSet
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 	static TemporaryRowHolderResultSet getNewRSOnCurrentRow
0: 			new TemporaryRowHolderImpl(activation, null);
/////////////////////////////////////////////////////////////////////////
1: 		return null;
commit:48d2629
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:b31849d
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Timestamp;
1: 
1: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.sql.execute.CursorResultSet;
1: import org.apache.derby.iapi.sql.execute.ExecRow;
0: import org.apache.derby.iapi.sql.execute.ExecutionFactory;
1: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
1: import org.apache.derby.iapi.sql.execute.TargetResultSet;
1: import org.apache.derby.iapi.store.access.ConglomerateController;
1: import org.apache.derby.iapi.store.access.ScanController;
1: import org.apache.derby.iapi.store.access.TransactionController;
commit:d3a4f64
/////////////////////////////////////////////////////////////////////////
1: 		if (!indexsc.fetchNext(indexRow))
commit:6b26ee1
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.Activation;
/////////////////////////////////////////////////////////////////////////
1: 
0: 	public Activation getActivation() {
1: 		if (SanityManager.DEBUG)
0: 			SanityManager.THROWASSERT("getActivation() called for " + getClass());
1: 		return null;
1: 	}
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.execute.TemporaryRowHolderResultSet
1: 
0:    Copyright 1998, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:61070a6
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.execute
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.sql.execute;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.iapi.store.access.ConglomerateController;
0: import org.apache.derby.iapi.store.access.ScanController;
0: import org.apache.derby.iapi.store.access.TransactionController;
1: 
0: import org.apache.derby.iapi.reference.SQLState;
1: 
0: import org.apache.derby.iapi.sql.execute.CursorResultSet;
0: import org.apache.derby.iapi.sql.execute.ExecRow;
0: import org.apache.derby.iapi.sql.execute.ExecutionContext;
0: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
0: import org.apache.derby.iapi.sql.execute.ExecutionFactory;
0: import org.apache.derby.iapi.sql.execute.TargetResultSet;
1: 
1: import org.apache.derby.iapi.sql.ResultDescription;
1: import org.apache.derby.iapi.sql.ResultSet;
1: import org.apache.derby.iapi.sql.Row;
1: 
1: import org.apache.derby.iapi.types.DataValueDescriptor;
1: import org.apache.derby.iapi.types.RowLocation;
0: import org.apache.derby.iapi.sql.execute.ExecIndexRow;
1: import org.apache.derby.iapi.types.SQLLongint;
1: 
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: import java.sql.Timestamp;
1: 
1: 
1: /**
1:  * A result set to scan temporary row holders.  Ultimately, this
1:  * may be returned to users, hence the extra junk from the ResultSet
1:  * interface.
1:  *
0:  * @author jamie
1:  */
0: public class TemporaryRowHolderResultSet implements CursorResultSet, NoPutResultSet, Cloneable
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
1: 	private ExecRow[] 				rowArray;
1: 	private int						numRowsOut;
1: 	private ScanController			scan;
1: 	private TransactionController	tc;
1: 	private boolean 				isOpen;
1: 	private boolean 				finished;
1: 	private ExecRow					currentRow;
0: 	private ResultDescription		resultDescription;
0: 	private ExecutionFactory		ef;
1: 	private boolean                 isAppendable = false;
1: 	private long                    positionIndexConglomId;
1: 	private boolean 				isVirtualMemHeap;
1: 	private boolean 				currRowFromMem;
1: 	private TemporaryRowHolderImpl	holder;
1: 
1: 	// the following is used by position based scan, as well as virtual memory style heap
1: 	ConglomerateController			heapCC;
1: 	private RowLocation				baseRowLocation;
1: 
1: 	/**
1: 	 * Constructor
1: 	 *
1: 	 * @param tc the xact controller
1: 	 * @param rowArray the row array
0: 	 * @param lastArraySlot the last array slot in use 
0: 	 * @param conglomId	0 if no conglom used
0: 	 * @param resultDescription value returned by getResultDescription()
1: 	 */
0: 	public TemporaryRowHolderResultSet
1: 	(
1: 		TransactionController		tc,
1: 		ExecRow[]					rowArray,
0: 		ResultDescription			resultDescription,
1: 		boolean						isVirtualMemHeap,
1: 		TemporaryRowHolderImpl		holder
1:    	)
1: 	{
1: 
0: 		this(tc, rowArray, resultDescription, isVirtualMemHeap, false, 0, holder);
1: 
1: 
1: 	}
1: 
1: 	/**
1: 	 * Constructor
1: 	 *
1: 	 * @param tc the xact controller
1: 	 * @param rowArray the row array
0: 	 * @param lastArraySlot the last array slot in use 
0: 	 * @param conglomId	0 if no conglom used
0: 	 * @param resultDescription value returned by getResultDescription()
1: 	 * @param isAppendable true,if we can insert rows after this result is created
1: 	 * @param positionIndexConglomId conglomId of the index which has order rows
1: 	 *                               are inserted and their row location 
1: 	 */
0: 	public TemporaryRowHolderResultSet
1: 	(
1: 		TransactionController		tc,
1: 		ExecRow[]					rowArray,
0: 		ResultDescription			resultDescription,
1: 		boolean						isVirtualMemHeap,
1: 		boolean                     isAppendable,
1: 		long                        positionIndexConglomId,
1: 		TemporaryRowHolderImpl		holder
1: 	) 
1: 	{
1: 		this.tc = tc;
1: 		this.rowArray = rowArray;
0: 		this.resultDescription = resultDescription;
1: 		this.numRowsOut = 0;
1: 		isOpen = false;
1: 		finished = false;
1: 		this.isVirtualMemHeap = isVirtualMemHeap;
1: 		this.isAppendable = isAppendable;
1: 		this.positionIndexConglomId = positionIndexConglomId;
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(rowArray != null, "rowArray is null");
1: 			SanityManager.ASSERT(rowArray.length > 0, "rowArray has no elements, need at least one");
1: 		}
1: 
1: 		this.holder = holder;
1: 	}
1: 
1: 	/**
1: 	 * Reset the exec row array and reinitialize
1: 	 *
1: 	 * @param rowArray the row array
1: 	 */
1: 	public void reset(ExecRow[]	rowArray)
1: 	{
1: 		this.rowArray = rowArray;
1: 		this.numRowsOut = 0;
1: 		isOpen = false;
1: 		finished = false;
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(rowArray != null, "rowArray is null");
1: 			SanityManager.ASSERT(rowArray.length > 0, "rowArray has no elements, need at least one");
1: 		}
1: 	}
1: 
1: 
1: 	/**
1: 	 * postion scan to start from after where we stopped earlier
1: 	 */
1: 	public void reStartScan(long currentConglomId, long pconglomId) throws  StandardException 
1: 	{
1: 		if(isAppendable)
1: 		{
0: 			holder.CID = currentConglomId;
1: 			positionIndexConglomId = pconglomId;
1: 			setupPositionBasedScan(numRowsOut);
1: 		}else
1: 		{
1: 			numRowsOut--;
1: 		}
1: 	}
1: 
1: 
1: 	/**
1: 	 * Whip up a new Temp ResultSet that has a single
0: 	 * row, the current row of this result set.
1: 	 * 
1: 	 * @param tc the xact controller
1: 	 * @param rs the result set 
1: 	 * 
1: 	 * @return a single row result set
1: 	 *
1: 	 * @exception StandardException on error
1: 	 */
0: 	public static TemporaryRowHolderResultSet getNewRSOnCurrentRow
1: 	(
0: 		TransactionController	tc,
0: 		CursorResultSet 		rs
1: 	) throws StandardException
1: 	{
0: 		TemporaryRowHolderImpl singleRow = new TemporaryRowHolderImpl(tc, null, rs.getResultDescription());
0: 		singleRow.insert(rs.getCurrentRow());
1: 		return (TemporaryRowHolderResultSet) singleRow.getResultSet();
1: 	}
1: 
1: 	/////////////////////////////////////////////////////////
1: 	//
1: 	// NoPutResultSet
1: 	// 
1: 	/////////////////////////////////////////////////////////
1: 	/**
1: 	 * Mark the ResultSet as the topmost one in the ResultSet tree.
1: 	 * Useful for closing down the ResultSet on an error.
1: 	 *
0: 	 * @return Nothing.
1: 	 */
1: 	public void markAsTopResultSet()
1: 	{ }
1: 
1: 	/**
1: 	 * Open the scan and evaluate qualifiers and the like.
1: 	 * For us, there are no qualifiers, this is really a
1: 	 * noop.
1: 	 */
1: 	public void openCore() throws StandardException
1: 	{
1: 		this.numRowsOut = 0;
1: 		isOpen = true;
1: 		currentRow = null;
1: 
1: 		if(isAppendable)
1: 			setupPositionBasedScan(numRowsOut);
1: 	}
1: 
1: 	/**
1: 	 * Reopen the scan.  Typically faster than open()/close()
1: 	 *
1: 	 * @exception StandardException on error
1: 	 */
1: 	public void reopenCore() throws StandardException
1: 	{
1: 		numRowsOut = 0;
1: 		isOpen = true;
1: 		currentRow = null;
1: 
1: 		if(isAppendable)
1: 		{
1: 			setupPositionBasedScan(numRowsOut);
1: 			return;
1: 		}
1: 
1: 		if (scan != null)
1: 		{
1: 			scan.reopenScan(
1:                 (DataValueDescriptor[]) null,		// start key value
1:                 0,						// start operator
1:                 null,					// qualifier
1:                 (DataValueDescriptor[]) null,		// stop key value
1:                 0);						// stop operator
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Get the next row.
1: 	 *
1: 	 * @return the next row, or null if none
1: 	 *
1: 	 * @exception StandardException on error
1: 	 */
1: 	public ExecRow getNextRowCore()
1: 		throws StandardException
1: 	{
1: 
1: 		if (!isOpen)
1: 		{
1: 			return (ExecRow)null;
1: 		}
1: 			
1: 		if(isAppendable)
1: 		{
1: 			return getNextAppendedRow() ;
1: 		}
1: 
1: 		if (isVirtualMemHeap && holder.lastArraySlot >= 0)
1: 		{
1: 			numRowsOut++;
1: 			currentRow = rowArray[holder.lastArraySlot];
1: 			currRowFromMem = true;
1: 			return currentRow;
1: 		}
1: 		else if (numRowsOut++ <= holder.lastArraySlot)
1: 		{
1: 			currentRow = rowArray[numRowsOut-1];
1: 			return currentRow;
1: 		}
1: 
0: 		if (holder.CID == 0)
1: 		{
1: 			return (ExecRow)null;
1: 		}
1: 			
1: 		/*
1: 		** Advance in the temporary conglomerate
1: 		*/
1: 		if (scan == null)
1: 		{
1: 			scan = 
1:                 tc.openScan(
0:                     holder.CID,
1:                     false,					// hold
1:                     0, 		// open read only
1:                     TransactionController.MODE_TABLE,
1:                     TransactionController.ISOLATION_SERIALIZABLE,
1:                     (FormatableBitSet) null, 
1:                     (DataValueDescriptor[]) null,		// start key value
1:                     0,						// start operator
1:                     null,					// qualifier
1:                     (DataValueDescriptor[]) null,		// stop key value
1:                     0);						// stop operator
1: 		}
1: 		else if (isVirtualMemHeap && holder.state == TemporaryRowHolderImpl.STATE_INSERT)
1: 		{
1: 			holder.state = TemporaryRowHolderImpl.STATE_DRAIN;
1: 			scan.reopenScan(
1:                 (DataValueDescriptor[]) null,		// start key value
1:                 0,						// start operator
1:                 null,					// qualifier
1:                 (DataValueDescriptor[]) null,		// stop key value
1:                 0);						// stop operator
1: 		}
1: 
1: 		if (scan.next())
1: 		{
1: 			currentRow = rowArray[0].getNewNullRow();
1: 			scan.fetch(currentRow.getRowArray());
1: 			currRowFromMem = false;
1: 			return currentRow;
1: 		}
1: 		return (ExecRow)null;
1: 	}
1: 
1: 	public void deleteCurrentRow()
1: 		throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(isVirtualMemHeap, "deleteCurrentRow is not implemented");
1: 		}
1: 		if (currRowFromMem)
1: 		{
1: 			if (holder.lastArraySlot > 0)				// 0 is kept for template
1: 				rowArray[holder.lastArraySlot] = null;  // erase reference
1: 			holder.lastArraySlot--;
1: 		}
1: 		else
1: 		{
1: 			if (baseRowLocation == null)
1: 				baseRowLocation = scan.newRowLocationTemplate();
1: 			scan.fetchLocation(baseRowLocation);
1: 			if(heapCC == null)
1: 			{
0: 				heapCC = tc.openConglomerate( holder.CID,
1: 											  false,
1: 											  TransactionController.OPENMODE_FORUPDATE,
1: 											  TransactionController.MODE_TABLE,
1: 											  TransactionController.ISOLATION_SERIALIZABLE);
1: 			}
1: 			heapCC.delete(baseRowLocation);
1: 		}
1: 	}
1: 
1: 
1: 	//following variables are specific to the position based scans.
1: 	DataValueDescriptor[] indexRow;
1: 	ScanController indexsc;
1: 
1: 	//open the scan of the temporary heap and the position index
1: 	private void setupPositionBasedScan(long position) throws StandardException
1: 	{
1: 
1: 		//incase nothing is inserted yet into the temporary row holder
0: 		if(holder.CID ==0)
1: 			return;
1: 		if(heapCC == null)
1: 		{
0: 			heapCC = tc.openConglomerate( holder.CID,
1: 										  false,
1: 										  0,
1: 										  TransactionController.MODE_TABLE,
1: 										  TransactionController.ISOLATION_SERIALIZABLE);
1: 
1: 		}
1: 
1: 		currentRow = rowArray[0].getNewNullRow();
1: 		indexRow = new DataValueDescriptor[2];
1: 		indexRow[0] = new SQLLongint(position);
1: 		indexRow[1] = 	heapCC.newRowLocationTemplate();
1: 
1: 		DataValueDescriptor[] searchRow =  new DataValueDescriptor[1];
1: 		searchRow[0] = new SQLLongint(position);
1: 
1: 		if(indexsc == null)
1: 		{
1: 			indexsc = tc.openScan(positionIndexConglomId,
1: 								  false,                           // don't hold open across commit
1: 								  0,                               // for read
1: 								  TransactionController.MODE_TABLE,
1: 								  TransactionController.ISOLATION_SERIALIZABLE,
1: 								  (FormatableBitSet) null,                  // all fields as objects
1: 								  searchRow,            	          // start position - first row
1: 								  ScanController.GE,               // startSearchOperation
1: 								  null,                            //scanQualifier,
1: 								  null,                           // stop position - through last row
1: 								  ScanController.GT);              // stopSearchOperation
1: 		}else
1: 		{
1: 
1: 			indexsc.reopenScan(
1: 						searchRow,                      	// startKeyValue
1: 						ScanController.GE,            		// startSearchOp
1: 						null,                         		// qualifier
1: 						null, 		                        // stopKeyValue
1: 						ScanController.GT             		// stopSearchOp 
1: 						);
1: 		}
1: 		
1: 	} 
1: 
1: 
1: 	//get the next row inserted into the temporary holder
1: 	private ExecRow getNextAppendedRow() throws StandardException
1: 	{
1: 		if (indexsc == null) return null;
0: 		if (!indexsc.next())
1: 		{
1: 			return null;
1: 		}
1: 		
0: 		indexsc.fetch(indexRow);
1: 		RowLocation baseRowLocation =  (RowLocation) indexRow[1];
1: 		boolean base_row_exists = 
1:             heapCC.fetch(
1:                 baseRowLocation, currentRow.getRowArray(), (FormatableBitSet) null);
1: 
1:         if (SanityManager.DEBUG)
1:         {
1:             SanityManager.ASSERT(base_row_exists, "base row disappeared.");
1:         }
1: 		numRowsOut++; 
1: 		return currentRow;
1: 	}
1: 
1: 
1: 
1: 	/**
1: 	 * Return the point of attachment for this subquery.
1: 	 * (Only meaningful for Any and Once ResultSets, which can and will only
1: 	 * be at the top of a ResultSet for a subquery.)
1: 	 *
1: 	 * @return int	Point of attachment (result set number) for this
1: 	 *			    subquery.  (-1 if not a subquery - also Sanity violation)
1: 	 */
1: 	public int getPointOfAttachment()
1: 	{
1: 		return -1;
1: 	}
1: 
1: 	/**
1: 	 * Return the isolation level of the scan in the result set.
1: 	 * Only expected to be called for those ResultSets that
1: 	 * contain a scan.
1: 	 *
1: 	 * @return The isolation level of the scan (in TransactionController constants).
1: 	 */
1: 	public int getScanIsolationLevel()
1: 	{
1: 		return TransactionController.ISOLATION_SERIALIZABLE;	
1: 	}
1: 
1: 	/**
1: 	 * Notify a NPRS that it is the source for the specified 
1: 	 * TargetResultSet.  This is useful when doing bulk insert.
1: 	 *
1: 	 * @param trs	The TargetResultSet.
1: 	 *
0: 	 * @return Nothing.
1: 	 */
1: 	public void setTargetResultSet(TargetResultSet trs)
1: 	{
1: 	}
1: 
1: 	/**
1: 	 * Set whether or not the NPRS need the row location when acting
1: 	 * as a row source.  (The target result set determines this.)
1: 	 * 
0: 	 * @param boolean needsRowLocation
1: 	 *
0: 	 * @return Nothing.
1: 	 */
1: 	public void setNeedsRowLocation(boolean needsRowLocation)
1: 	{
1: 	}
1: 
1: 	/**
1: 	 * Get the estimated row count from this result set.
1: 	 *
1: 	 * @return	The estimated row count (as a double) from this result set.
1: 	 */
1: 	public double getEstimatedRowCount()
1: 	{
1: 		return 0d;
1: 	}
1: 
1: 	/**
1: 	 * Get the number of this ResultSet, which is guaranteed to be unique
1: 	 * within a statement.
1: 	 */
1: 	public int resultSetNumber()
1: 	{
1: 		return 0;
1: 	}
1: 
1: 	/**
1: 	 * Set the current row to the row passed in.
1: 	 *
1: 	 * @param row the new current row
1: 	 *
1: 	 */
1: 	public void setCurrentRow(ExecRow row)
1: 	{
1: 		currentRow = row;
1: 	}
1: 
1: 	/**
1: 	 * Clear the current row
1: 	 *
1: 	 */
1: 	public void clearCurrentRow()
1: 	{
1: 		currentRow = null;
1: 	}
1: 
1: 	/**
1: 	 * This result set has its row from the last fetch done. 
1: 	 * If the cursor is closed, a null is returned.
1: 	 *
1: 	 * @see CursorResultSet
1: 	 *
1: 	 * @return the last row returned;
1: 	 * @exception StandardException thrown on failure.
1: 	 */
1: 	public ExecRow getCurrentRow() throws StandardException 
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(isOpen, "resultSet expected to be open");
1: 		}
1: 
1: 		return currentRow;
1: 	}
1: 
1: 	/**
1: 	 * Returns the row location of the current base table row of the cursor.
1: 	 * If this cursor's row is composed of multiple base tables' rows,
1: 	 * i.e. due to a join, then a null is returned.  For
1: 	 * a temporary row holder, we always return null.
1: 	 *
1: 	 * @return the row location of the current cursor row.
1: 	 */
1: 	public RowLocation getRowLocation()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(isOpen, "resultSet expected to be open");
1: 		}
1: 		return (RowLocation)null;
1: 	}
1: 
1: 
1: 	/**
1: 	 * Clean up
1: 	 *
1: 	 * @exception StandardException thrown on error
1: 	 */
1: 	public void	close() throws StandardException
1: 	{
1: 		isOpen = false;
1: 		numRowsOut = 0;
1: 		currentRow = null;
1: 		if (scan != null)
1: 		{
1: 			scan.close();
1: 			scan = null;
1: 		}
1: 	}
1: 
1: 
1: 	//////////////////////////////////////////////////////////////////////////
1: 	//
1: 	// MISC FROM RESULT SET
1: 	//
1: 	/////////////////////////////////////////////////////////////////////////
1: 
1: 	/**
1: 	 * Returns TRUE if the statement returns rows (i.e. is a SELECT
1: 	 * or FETCH statement), FALSE if it returns no rows.
1: 	 *
1: 	 * @return	TRUE if the statement returns rows, FALSE if not.
1: 	 */
1: 	public boolean	returnsRows()
1: 	{
1: 		return true;
1: 	}
1: 
0: 	public int modifiedRowCount() { return 0;};
1: 
1: 	/**
0: 	 * Returns a ResultDescription object, which describes the results
0: 	 * of the statement this ResultSet is in. This will *not* be a
0: 	 * description of this particular ResultSet, if this is not the
0: 	 * outermost ResultSet.
1: 	 *
0: 	 * @return	A ResultDescription describing the results of the
0: 	 *		statement.
1: 	 */
0: 	public ResultDescription	getResultDescription()
1: 	{
0: 		return resultDescription;
1: 	}
1: 
1: 	/**
1: 	 * Tells the system that there will be calls to getNextRow().
1: 	 *
0: 	 * @return	Nothing
1: 	 *
1: 	 * @exception StandardException		Thrown on failure
1: 	 */
1: 	public void open() throws StandardException
1: 	{
1: 		openCore();
1: 	}
1: 
1: 	/**
1: 	 * Returns the row at the absolute position from the query, 
1: 	 * and returns NULL when there is no such position.
1: 	 * (Negative position means from the end of the result set.)
1: 	 * Moving the cursor to an invalid position leaves the cursor
1: 	 * positioned either before the first row (negative position)
1: 	 * or after the last row (positive position).
1: 	 * NOTE: An exception will be thrown on 0.
1: 	 *
1: 	 * @param row	The position.
1: 	 * @return	The row at the absolute position, or NULL if no such position.
1: 	 *
1: 	 * @exception StandardException		Thrown on failure
1: 	 * @see Row
1: 	 */
1: 	public ExecRow	getAbsoluteRow(int row) throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.THROWASSERT(
1: 				"getAbsoluteRow() not expected to be called yet.");
1: 		}
1: 
1: 		return null;
1: 	}
1: 
1: 	/**
1: 	 * Returns the row at the relative position from the current
1: 	 * cursor position, and returns NULL when there is no such position.
1: 	 * (Negative position means toward the beginning of the result set.)
1: 	 * Moving the cursor to an invalid position leaves the cursor
1: 	 * positioned either before the first row (negative position)
1: 	 * or after the last row (positive position).
1: 	 * NOTE: 0 is valid.
1: 	 * NOTE: An exception is thrown if the cursor is not currently
1: 	 * positioned on a row.
1: 	 *
1: 	 * @param row	The position.
1: 	 * @return	The row at the relative position, or NULL if no such position.
1: 	 *
1: 	 * @exception StandardException		Thrown on failure
1: 	 * @see Row
1: 	 */
1: 	public ExecRow	getRelativeRow(int row) throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.THROWASSERT(
1: 				"getRelativeRow() not expected to be called yet.");
1: 		}
1: 
1: 		return null;
1: 	}
1: 
1: 	/**
1: 	 * Sets the current position to before the first row and returns NULL
1: 	 * because there is no current row.
1: 	 *
1: 	 * @return	NULL.
1: 	 *
1: 	 * @exception StandardException		Thrown on failure
1: 	 * @see Row
1: 	 */
1: 	public ExecRow	setBeforeFirstRow() 
1: 		throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.THROWASSERT(
1: 				"setBeforeFirstRow() not expected to be called yet.");
1: 		}
1: 
1: 		return null;
1: 	}
1: 
1: 	/**
1: 	 * Returns the first row from the query, and returns NULL when there
1: 	 * are no rows.
1: 	 *
1: 	 * @return	The first row, or NULL if no rows.
1: 	 *
1: 	 * @exception StandardException		Thrown on failure
1: 	 * @see Row
1: 	 */
1: 	public ExecRow	getFirstRow() 
1: 		throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.THROWASSERT(
1: 				"getFirstRow() not expected to be called yet.");
1: 		}
1: 
1: 		return null;
1: 	}
1: 
1: 	/**
1: 	 * Returns the next row from the query, and returns NULL when there
1: 	 * are no more rows.
1: 	 *
1: 	 * @return	The next row, or NULL if no more rows.
1: 	 *
1: 	 * @exception StandardException		Thrown on failure
1: 	 * @see Row
1: 	 */
1: 	public ExecRow	getNextRow() throws StandardException
1: 	{
1: 		return getNextRowCore();
1: 	}
1: 
1: 	/**
1: 	 * Returns the previous row from the query, and returns NULL when there
1: 	 * are no more previous rows.
1: 	 *
1: 	 * @return	The previous row, or NULL if no more previous rows.
1: 	 *
1: 	 * @exception StandardException		Thrown on failure
1: 	 * @see Row
1: 	 */
1: 	public ExecRow	getPreviousRow() 
1: 		throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.THROWASSERT(
1: 				"getPreviousRow() not expected to be called yet.");
1: 		}
1: 
1: 		return null;
1: 	}
1: 
1: 	/**
1: 	 * Returns the last row from the query, and returns NULL when there
1: 	 * are no rows.
1: 	 *
1: 	 * @return	The last row, or NULL if no rows.
1: 	 *
1: 	 * @exception StandardException		Thrown on failure
1: 	 * @see Row
1: 	 */
1: 	public ExecRow	getLastRow()
1: 		throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.THROWASSERT(
1: 				"getLastRow() not expected to be called yet.");
1: 		}
1: 
1: 		return null;
1: 	}
1: 
1: 	/**
1: 	 * Sets the current position to after the last row and returns NULL
1: 	 * because there is no current row.
1: 	 *
1: 	 * @return	NULL.
1: 	 *
1: 	 * @exception StandardException		Thrown on failure
1: 	 * @see Row
1: 	 */
1: 	public ExecRow	setAfterLastRow() 
1: 		throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.THROWASSERT(
1: 				"getLastRow() not expected to be called yet.");
1: 		}
1: 
1: 		return null;
1: 	}
1: 
1:     /**
1:      * Determine if the cursor is before the first row in the result 
1:      * set.   
1:      *
1:      * @return true if before the first row, false otherwise. Returns
1:      * false when the result set contains no rows.
1:      */
1:     public boolean checkRowPosition(int isType)
1: 	{
1: 		return false;
1: 	}
1: 
1: 	/**
1: 	 * Returns the row number of the current row.  Row
1: 	 * numbers start from 1 and go to 'n'.  Corresponds
1: 	 * to row numbering used to position current row
1: 	 * in the result set (as per JDBC).
1: 	 *
1: 	 * @return	the row number, or 0 if not on a row
1: 	 *
1: 	 */
1: 	public int getRowNumber()
1: 	{
1: 		return 0;
1: 	}
1: 
1: 	/**
1: 	 * Tells the system to clean up on an error.
1: 	 *
0: 	 * @return	Nothing
1: 	 *
1: 	 * @exception StandardException		Thrown on error.
1: 	 */
1: 	public void	cleanUp() throws StandardException
1: 	{
1: 		close();
1: 	}
1: 
1: 
1: 	/**
1: 		Find out if the ResultSet is closed or not.
1: 		Will report true for result sets that do not return rows.
1: 
1: 		@return true if the ResultSet has been closed.
1: 	 */
1: 	public boolean isClosed()
1: 	{
1: 		return !isOpen;
1: 	}
1: 
1: 	/**
1: 	 * Tells the system that there will be no more access
1: 	 * to any database information via this result set;
1: 	 * in particular, no more calls to open().
1: 	 * Will close the result set if it is not already closed.
1: 	 *
0: 	 * @return	Nothing
1: 	 * @exception StandardException	on error
1: 	 */
1: 	public void finish() throws StandardException
1: 	{
1: 		finished = true;
1: 		close();
1: 	}
1: 
1: 
1: 	/**
1: 	 * Get the execution time in milliseconds.
1: 	 *
1: 	 * @return long		The execution time in milliseconds.
1: 	 */
1: 	public long getExecuteTime()
1: 	{
1: 		return 0L;
1: 	}
1: 
1: 	/**
1: 	 * @see ResultSet#getAutoGeneratedKeysResultset
1: 	 */
1: 	public ResultSet getAutoGeneratedKeysResultset()
1: 	{
1: 		//A non-null resultset would be returned only for an insert statement 
1: 		return (ResultSet)null;
1: 	}
1: 
1: 	/**
1: 	 * Get the Timestamp for the beginning of execution.
1: 	 *
1: 	 * @return Timestamp		The Timestamp for the beginning of execution.
1: 	 */
1: 	public Timestamp getBeginExecutionTimestamp()
1: 	{
1: 		return (Timestamp)null;
1: 	}
1: 
1: 	/**
1: 	 * Get the Timestamp for the end of execution.
1: 	 *
1: 	 * @return Timestamp		The Timestamp for the end of execution.
1: 	 */
1: 	public Timestamp getEndExecutionTimestamp()
1: 	{
1: 		return (Timestamp)null;
1: 	}
1: 
1: 	/**
1: 	 * Return the total amount of time spent in this ResultSet
1: 	 *
1: 	 * @param type	CURRENT_RESULTSET_ONLY - time spent only in this ResultSet
1: 	 *				ENTIRE_RESULTSET_TREE  - time spent in this ResultSet and below.
1: 	 *
1: 	 * @return long		The total amount of time spent (in milliseconds).
1: 	 */
1: 	public long getTimeSpent(int type)
1: 	{
1: 		return 0L;
1: 	}
1: 
1: 
1: 	/**
1: 	 * Get the subquery ResultSet tracking array from the top ResultSet.
1: 	 * (Used for tracking open subqueries when closing down on an error.)
1: 	 *
1: 	 * @param numSubqueries		The size of the array (For allocation on demand.)
1: 	 *
1: 	 * @return NoPutResultSet[]	Array of NoPutResultSets for subqueries.
1: 	 */
1: 	public NoPutResultSet[] getSubqueryTrackingArray(int numSubqueries)
1: 	{
1: 		return (NoPutResultSet[])null;
1: 	}
1: 
1: 	/**
1: 	 * Returns the name of the cursor, if this is cursor statement of some
1: 	 * type (declare, open, fetch, positioned update, positioned delete,
1: 	 * close).
1: 	 *
1: 	 * @return	A String with the name of the cursor, if any. Returns
1: 	 *		NULL if this is not a cursor statement.
1: 	 */
1: 	public String	getCursorName()
1: 	{
1: 		return (String) null;
1: 	}
1: 
1: 	/**
1: 	 * @see NoPutResultSet#requiresRelocking
1: 	 */
1: 	public boolean requiresRelocking()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.THROWASSERT(
1: 				"requiresRelocking() not expected to be called for " +
1: 				getClass().getName());
1: 		}
1: 		return false;
1: 	}
1: 
1: 	/////////////////////////////////////////////////////////
1: 	//
1: 	// Access/RowSource -- not implemented
1: 	// 
1: 	/////////////////////////////////////////////////////////
1: 	/**
1: 		Get the next row as an array of column objects. The column objects can
1: 		be a JBMS Storable or any
1: 		Serializable/Externalizable/Formattable/Streaming type.
1: 		<BR>
1: 		A return of null indicates that the complete set of rows has been read.
1: 
1: 		<p>
1: 		A null column can be specified by leaving the object null, or indicated
1: 		by returning a non-null getValidColumns.  On streaming columns, it can
1: 		be indicated by returning a non-null get FieldStates.
1: 
1: 		<p>
1:         If RowSource.needToClone() is true then the returned row (the 
1:         DataValueDescriptor[]) is guaranteed not to be modified by drainer of 
1:         the RowSource (except that the input stream will be read, of course) 
1:         and drainer will keep no reference to it before making the subsequent 
1:         nextRow call.  So it is safe to return the same DataValueDescriptor[] 
1:         in subsequent nextRow calls if that is desirable for performance 
1:         reasons.  
1: 		<p>
1:         If RowSource.needToClone() is false then the returned row (the 
1:         DataValueDescriptor[]) may be be modified by drainer of the RowSource, 
1:         and the drainer may keep a reference to it after making the subsequent 
1:         nextRow call.  In this case the client should severe all references to 
1:         the row after returning it from getNextRowFromRowSource().
1: 
0: 		@exception StandardException Cloudscape Standard Error Policy
1: 	 */
1: 	public DataValueDescriptor[] getNextRowFromRowSource() throws StandardException
1: 	{ 
1: 		return null;
1: 	}
1: 
1: 	/**
1:         Does the caller of getNextRowFromRowSource() need to clone the row
1:         in order to keep a reference to the row past the 
1:         getNextRowFromRowSource() call which returned the row.  This call
1:         must always return the same for all rows in a RowSource (ie. the
1:         caller will call this once per scan from a RowSource and assume the
1:         behavior is true for all rows in the RowSource).
1: 
1: 	 */
1: 	public boolean needsToClone()
1: 	{
1: 		return false;
1: 	}
1: 
1: 
1: 	/**
1: 	  getValidColumns describes the DataValueDescriptor[] returned by all 
1:       calls to the getNextRowFromRowSource() call. 
1: 
1: 	  If getValidColumns returns null, the number of columns is given by the
1: 	  DataValueDescriptor.length where DataValueDescriptor[] is returned by the
1:       preceeding getNextRowFromRowSource() call.  Column N maps to 
1:       DataValueDescriptor[N], where column numbers start at zero.
1: 
1: 	  If getValidColumns return a non null validColumns FormatableBitSet the number of
1: 	  columns is given by the number of bits set in validColumns.  Column N is
1: 	  not in the partial row if validColumns.get(N) returns false.  Column N is
1: 	  in the partial row if validColumns.get(N) returns true.  If column N is
1: 	  in the partial row then it maps to DataValueDescriptor[M] where M is the
0:       count of calls to validColumns.get(i) that return true where i < N.  If
1: 	  DataValueDescriptor.length is greater than the number of columns 
1:       indicated by validColumns the extra entries are ignored.  
1: 	*/
1: 	public FormatableBitSet getValidColumns()
1: 	{
1: 		return null;
1: 	}
1: 
1: 	/**
1: 		closeRowSource tells the RowSource that it will no longer need to
1: 		return any rows and it can release any resource it may have.
1: 		Subsequent call to any method on the RowSource will result in undefined
1: 		behavior.  A closed rowSource can be closed again.
1: 	*/
1: 	public void closeRowSource()
1: 	{ }
1: 
1: 
1: 	/////////////////////////////////////////////////////////
1: 	//
1: 	// Access/RowLocationRetRowSource -- not implemented
1: 	// 
1: 	/////////////////////////////////////////////////////////
1: 	/**
1: 		needsRowLocation returns true iff this the row source expects the
1: 		drainer of the row source to call rowLocation after getting a row from
1: 		getNextRowFromRowSource.
1: 
1: 		@return true iff this row source expects some row location to be
1: 		returned 
1: 		@see #rowLocation
1: 	 */
1: 	public boolean needsRowLocation()
1: 	{
1: 		return false;
1: 	}
1: 
1: 	/**
1: 		rowLocation is a callback for the drainer of the row source to return
1: 		the rowLocation of the current row, i.e, the row that is being returned
1: 		by getNextRowFromRowSource.  This interface is for the purpose of
1: 		loading a base table with index.  In that case, the indices can be
1: 		built at the same time the base table is laid down once the row
1: 		location of the base row is known.  This is an example pseudo code on
1: 		how this call is expected to be used:
1: 		
1: 		<BR><pre>
1: 		boolean needsRL = rowSource.needsRowLocation();
1: 		DataValueDescriptor[] row;
1: 		while((row = rowSource.getNextRowFromRowSource()) != null)
1: 		{
1: 			RowLocation rl = heapConglomerate.insertRow(row);
1: 			if (needsRL)
1: 				rowSource.rowLocation(rl);
1: 		}
1: 		</pre><BR>
1: 
1: 		NeedsRowLocation and rowLocation will ONLY be called by a drainer of
1: 		the row source which CAN return a row location.  Drainer of row source
1: 		which cannot return rowLocation will guarentee to not call either
1: 		callbacks. Conversely, if NeedsRowLocation is called and it returns
1: 		true, then for every row return by getNextRowFromRowSource, a
1: 		rowLocation callback must also be issued with the row location of the
1: 		row.  Implementor of both the source and the drain of the row source
1: 		must be aware of this protocol.
1: 
1: 		<BR>
1: 		The RowLocation object is own by the caller of rowLocation, in other
1: 		words, the drainer of the RowSource.  This is so that we don't need to
1: 		new a row location for every row.  If the Row Source wants to keep the
1: 		row location, it needs to clone it (RowLocation is a ClonableObject).
1: 		@exception StandardException on error
1: 	 */
1: 	public void rowLocation(RowLocation rl) throws StandardException
1: 	{ }
1: 
1: 	// Class implementation
1: 
1: 	/**
1: 	 * Is this ResultSet or it's source result set for update
1: 	 * This method will be overriden in the inherited Classes
1: 	 * if it is true
1: 	 * @return Whether or not the result set is for update.
1: 	 */
1: 	public boolean isForUpdate()
1: 	{
1: 		return false;
1: 	}
1: 
1: 	/**
1: 	 * Shallow clone this result set.  Used in trigger reference.
1: 	 * beetle 4373.
1: 	 */
1: 	public Object clone()
1: 	{
1: 		Object clo = null;
1: 		try {
1: 			clo = super.clone();
1: 		}
1: 		catch (CloneNotSupportedException e) {}
1: 		return clo;
1: 	}
0: 	public java.sql.SQLWarning getWarnings() {
1: 		return null;
1: 	}
1: }
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:94f158a
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException Standard Derby Error Policy
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:David Van Couvering
-------------------------------------------------------------------------------
commit:f6123ee
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.execute
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.sql.execute;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.store.access.ConglomerateController;
0: import org.apache.derby.iapi.store.access.ScanController;
0: import org.apache.derby.iapi.store.access.TransactionController;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.iapi.sql.execute.CursorResultSet;
0: import org.apache.derby.iapi.sql.execute.ExecRow;
0: import org.apache.derby.iapi.sql.execute.ExecutionContext;
0: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
0: import org.apache.derby.iapi.sql.execute.ExecutionFactory;
0: import org.apache.derby.iapi.sql.execute.TargetResultSet;
0: 
0: import org.apache.derby.iapi.sql.ResultDescription;
0: import org.apache.derby.iapi.sql.ResultSet;
0: import org.apache.derby.iapi.sql.Row;
0: 
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.types.RowLocation;
0: import org.apache.derby.iapi.sql.execute.ExecIndexRow;
0: import org.apache.derby.iapi.types.SQLLongint;
0: 
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: import java.sql.Timestamp;
0: 
0: 
0: /**
0:  * A result set to scan temporary row holders.  Ultimately, this
0:  * may be returned to users, hence the extra junk from the ResultSet
0:  * interface.
0:  *
0:  * @author jamie
0:  */
0: public class TemporaryRowHolderResultSet implements CursorResultSet, NoPutResultSet, Cloneable
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
0: 	private ExecRow[] 				rowArray;
0: 	private int						numRowsOut;
0: 	private ScanController			scan;
0: 	private TransactionController	tc;
0: 	private boolean 				isOpen;
0: 	private boolean 				finished;
0: 	private ExecRow					currentRow;
0: 	private ResultDescription		resultDescription;
0: 	private ExecutionFactory		ef;
0: 	private boolean                 isAppendable = false;
0: 	private long                    positionIndexConglomId;
0: 	private boolean 				isVirtualMemHeap;
0: 	private boolean 				currRowFromMem;
0: 	private TemporaryRowHolderImpl	holder;
0: 
0: 	// the following is used by position based scan, as well as virtual memory style heap
0: 	ConglomerateController			heapCC;
0: 	private RowLocation				baseRowLocation;
0: 
0: 	/**
0: 	 * Constructor
0: 	 *
0: 	 * @param tc the xact controller
0: 	 * @param rowArray the row array
0: 	 * @param lastArraySlot the last array slot in use 
0: 	 * @param conglomId	0 if no conglom used
0: 	 * @param resultDescription value returned by getResultDescription()
0: 	 */
0: 	public TemporaryRowHolderResultSet
0: 	(
0: 		TransactionController		tc,
0: 		ExecRow[]					rowArray,
0: 		ResultDescription			resultDescription,
0: 		boolean						isVirtualMemHeap,
0: 		TemporaryRowHolderImpl		holder
0:    	)
0: 	{
0: 
0: 		this(tc, rowArray, resultDescription, isVirtualMemHeap, false, 0, holder);
0: 
0: 
0: 	}
0: 
0: 	/**
0: 	 * Constructor
0: 	 *
0: 	 * @param tc the xact controller
0: 	 * @param rowArray the row array
0: 	 * @param lastArraySlot the last array slot in use 
0: 	 * @param conglomId	0 if no conglom used
0: 	 * @param resultDescription value returned by getResultDescription()
0: 	 * @param isAppendable true,if we can insert rows after this result is created
0: 	 * @param positionIndexConglomId conglomId of the index which has order rows
0: 	 *                               are inserted and their row location 
0: 	 */
0: 	public TemporaryRowHolderResultSet
0: 	(
0: 		TransactionController		tc,
0: 		ExecRow[]					rowArray,
0: 		ResultDescription			resultDescription,
0: 		boolean						isVirtualMemHeap,
0: 		boolean                     isAppendable,
0: 		long                        positionIndexConglomId,
0: 		TemporaryRowHolderImpl		holder
0: 	) 
0: 	{
0: 		this.tc = tc;
0: 		this.rowArray = rowArray;
0: 		this.resultDescription = resultDescription;
0: 		this.numRowsOut = 0;
0: 		isOpen = false;
0: 		finished = false;
0: 		this.isVirtualMemHeap = isVirtualMemHeap;
0: 		this.isAppendable = isAppendable;
0: 		this.positionIndexConglomId = positionIndexConglomId;
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(rowArray != null, "rowArray is null");
0: 			SanityManager.ASSERT(rowArray.length > 0, "rowArray has no elements, need at least one");
0: 		}
0: 
0: 		this.holder = holder;
0: 	}
0: 
0: 	/**
0: 	 * Reset the exec row array and reinitialize
0: 	 *
0: 	 * @param rowArray the row array
0: 	 */
0: 	public void reset(ExecRow[]	rowArray)
0: 	{
0: 		this.rowArray = rowArray;
0: 		this.numRowsOut = 0;
0: 		isOpen = false;
0: 		finished = false;
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(rowArray != null, "rowArray is null");
0: 			SanityManager.ASSERT(rowArray.length > 0, "rowArray has no elements, need at least one");
0: 		}
0: 	}
0: 
0: 
0: 	/**
0: 	 * postion scan to start from after where we stopped earlier
0: 	 */
0: 	public void reStartScan(long currentConglomId, long pconglomId) throws  StandardException 
0: 	{
0: 		if(isAppendable)
0: 		{
0: 			holder.CID = currentConglomId;
0: 			positionIndexConglomId = pconglomId;
0: 			setupPositionBasedScan(numRowsOut);
0: 		}else
0: 		{
0: 			numRowsOut--;
0: 		}
0: 	}
0: 
0: 
0: 	/**
0: 	 * Whip up a new Temp ResultSet that has a single
0: 	 * row, the current row of this result set.
0: 	 * 
0: 	 * @param tc the xact controller
0: 	 * @param rs the result set 
0: 	 * 
0: 	 * @return a single row result set
0: 	 *
0: 	 * @exception StandardException on error
0: 	 */
0: 	public static TemporaryRowHolderResultSet getNewRSOnCurrentRow
0: 	(
0: 		TransactionController	tc,
0: 		CursorResultSet 		rs
0: 	) throws StandardException
0: 	{
0: 		TemporaryRowHolderImpl singleRow = new TemporaryRowHolderImpl(tc, null, rs.getResultDescription());
0: 		singleRow.insert(rs.getCurrentRow());
0: 		return (TemporaryRowHolderResultSet) singleRow.getResultSet();
0: 	}
0: 
0: 	/////////////////////////////////////////////////////////
0: 	//
0: 	// NoPutResultSet
0: 	// 
0: 	/////////////////////////////////////////////////////////
0: 	/**
0: 	 * Mark the ResultSet as the topmost one in the ResultSet tree.
0: 	 * Useful for closing down the ResultSet on an error.
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	public void markAsTopResultSet()
0: 	{ }
0: 
0: 	/**
0: 	 * Open the scan and evaluate qualifiers and the like.
0: 	 * For us, there are no qualifiers, this is really a
0: 	 * noop.
0: 	 */
0: 	public void openCore() throws StandardException
0: 	{
0: 		this.numRowsOut = 0;
0: 		isOpen = true;
0: 		currentRow = null;
0: 
0: 		if(isAppendable)
0: 			setupPositionBasedScan(numRowsOut);
0: 	}
0: 
0: 	/**
0: 	 * Reopen the scan.  Typically faster than open()/close()
0: 	 *
0: 	 * @exception StandardException on error
0: 	 */
0: 	public void reopenCore() throws StandardException
0: 	{
0: 		numRowsOut = 0;
0: 		isOpen = true;
0: 		currentRow = null;
0: 
0: 		if(isAppendable)
0: 		{
0: 			setupPositionBasedScan(numRowsOut);
0: 			return;
0: 		}
0: 
0: 		if (scan != null)
0: 		{
0: 			scan.reopenScan(
0:                 (DataValueDescriptor[]) null,		// start key value
0:                 0,						// start operator
0:                 null,					// qualifier
0:                 (DataValueDescriptor[]) null,		// stop key value
0:                 0);						// stop operator
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Get the next row.
0: 	 *
0: 	 * @return the next row, or null if none
0: 	 *
0: 	 * @exception StandardException on error
0: 	 */
0: 	public ExecRow getNextRowCore()
0: 		throws StandardException
0: 	{
0: 
0: 		if (!isOpen)
0: 		{
0: 			return (ExecRow)null;
0: 		}
0: 			
0: 		if(isAppendable)
0: 		{
0: 			return getNextAppendedRow() ;
0: 		}
0: 
0: 		if (isVirtualMemHeap && holder.lastArraySlot >= 0)
0: 		{
0: 			numRowsOut++;
0: 			currentRow = rowArray[holder.lastArraySlot];
0: 			currRowFromMem = true;
0: 			return currentRow;
0: 		}
0: 		else if (numRowsOut++ <= holder.lastArraySlot)
0: 		{
0: 			currentRow = rowArray[numRowsOut-1];
0: 			return currentRow;
0: 		}
0: 
0: 		if (holder.CID == 0)
0: 		{
0: 			return (ExecRow)null;
0: 		}
0: 			
0: 		/*
0: 		** Advance in the temporary conglomerate
0: 		*/
0: 		if (scan == null)
0: 		{
0: 			scan = 
0:                 tc.openScan(
0:                     holder.CID,
0:                     false,					// hold
0:                     0, 		// open read only
0:                     TransactionController.MODE_TABLE,
0:                     TransactionController.ISOLATION_SERIALIZABLE,
0:                     (FormatableBitSet) null, 
0:                     (DataValueDescriptor[]) null,		// start key value
0:                     0,						// start operator
0:                     null,					// qualifier
0:                     (DataValueDescriptor[]) null,		// stop key value
0:                     0);						// stop operator
0: 		}
0: 		else if (isVirtualMemHeap && holder.state == TemporaryRowHolderImpl.STATE_INSERT)
0: 		{
0: 			holder.state = TemporaryRowHolderImpl.STATE_DRAIN;
0: 			scan.reopenScan(
0:                 (DataValueDescriptor[]) null,		// start key value
0:                 0,						// start operator
0:                 null,					// qualifier
0:                 (DataValueDescriptor[]) null,		// stop key value
0:                 0);						// stop operator
0: 		}
0: 
0: 		if (scan.next())
0: 		{
0: 			currentRow = rowArray[0].getNewNullRow();
0: 			scan.fetch(currentRow.getRowArray());
0: 			currRowFromMem = false;
0: 			return currentRow;
0: 		}
0: 		return (ExecRow)null;
0: 	}
0: 
0: 	public void deleteCurrentRow()
0: 		throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(isVirtualMemHeap, "deleteCurrentRow is not implemented");
0: 		}
0: 		if (currRowFromMem)
0: 		{
0: 			if (holder.lastArraySlot > 0)				// 0 is kept for template
0: 				rowArray[holder.lastArraySlot] = null;  // erase reference
0: 			holder.lastArraySlot--;
0: 		}
0: 		else
0: 		{
0: 			if (baseRowLocation == null)
0: 				baseRowLocation = scan.newRowLocationTemplate();
0: 			scan.fetchLocation(baseRowLocation);
0: 			if(heapCC == null)
0: 			{
0: 				heapCC = tc.openConglomerate( holder.CID,
0: 											  false,
0: 											  TransactionController.OPENMODE_FORUPDATE,
0: 											  TransactionController.MODE_TABLE,
0: 											  TransactionController.ISOLATION_SERIALIZABLE);
0: 			}
0: 			heapCC.delete(baseRowLocation);
0: 		}
0: 	}
0: 
0: 
0: 	//following variables are specific to the position based scans.
0: 	DataValueDescriptor[] indexRow;
0: 	ScanController indexsc;
0: 
0: 	//open the scan of the temporary heap and the position index
0: 	private void setupPositionBasedScan(long position) throws StandardException
0: 	{
0: 
0: 		//incase nothing is inserted yet into the temporary row holder
0: 		if(holder.CID ==0)
0: 			return;
0: 		if(heapCC == null)
0: 		{
0: 			heapCC = tc.openConglomerate( holder.CID,
0: 										  false,
0: 										  0,
0: 										  TransactionController.MODE_TABLE,
0: 										  TransactionController.ISOLATION_SERIALIZABLE);
0: 
0: 		}
0: 
0: 		currentRow = rowArray[0].getNewNullRow();
0: 		indexRow = new DataValueDescriptor[2];
0: 		indexRow[0] = new SQLLongint(position);
0: 		indexRow[1] = 	heapCC.newRowLocationTemplate();
0: 
0: 		DataValueDescriptor[] searchRow =  new DataValueDescriptor[1];
0: 		searchRow[0] = new SQLLongint(position);
0: 
0: 		if(indexsc == null)
0: 		{
0: 			indexsc = tc.openScan(positionIndexConglomId,
0: 								  false,                           // don't hold open across commit
0: 								  0,                               // for read
0: 								  TransactionController.MODE_TABLE,
0: 								  TransactionController.ISOLATION_SERIALIZABLE,
0: 								  (FormatableBitSet) null,                  // all fields as objects
0: 								  searchRow,            	          // start position - first row
0: 								  ScanController.GE,               // startSearchOperation
0: 								  null,                            //scanQualifier,
0: 								  null,                           // stop position - through last row
0: 								  ScanController.GT);              // stopSearchOperation
0: 		}else
0: 		{
0: 
0: 			indexsc.reopenScan(
0: 						searchRow,                      	// startKeyValue
0: 						ScanController.GE,            		// startSearchOp
0: 						null,                         		// qualifier
0: 						null, 		                        // stopKeyValue
0: 						ScanController.GT             		// stopSearchOp 
0: 						);
0: 		}
0: 		
0: 	} 
0: 
0: 
0: 	//get the next row inserted into the temporary holder
0: 	private ExecRow getNextAppendedRow() throws StandardException
0: 	{
0: 		if (indexsc == null) return null;
0: 		if (!indexsc.next())
0: 		{
0: 			return null;
0: 		}
0: 		
0: 		indexsc.fetch(indexRow);
0: 		RowLocation baseRowLocation =  (RowLocation) indexRow[1];
0: 		boolean base_row_exists = 
0:             heapCC.fetch(
0:                 baseRowLocation, currentRow.getRowArray(), (FormatableBitSet) null);
0: 
0:         if (SanityManager.DEBUG)
0:         {
0:             SanityManager.ASSERT(base_row_exists, "base row disappeared.");
0:         }
0: 		numRowsOut++; 
0: 		return currentRow;
0: 	}
0: 
0: 
0: 
0: 	/**
0: 	 * Return the point of attachment for this subquery.
0: 	 * (Only meaningful for Any and Once ResultSets, which can and will only
0: 	 * be at the top of a ResultSet for a subquery.)
0: 	 *
0: 	 * @return int	Point of attachment (result set number) for this
0: 	 *			    subquery.  (-1 if not a subquery - also Sanity violation)
0: 	 */
0: 	public int getPointOfAttachment()
0: 	{
0: 		return -1;
0: 	}
0: 
0: 	/**
0: 	 * Return the isolation level of the scan in the result set.
0: 	 * Only expected to be called for those ResultSets that
0: 	 * contain a scan.
0: 	 *
0: 	 * @return The isolation level of the scan (in TransactionController constants).
0: 	 */
0: 	public int getScanIsolationLevel()
0: 	{
0: 		return TransactionController.ISOLATION_SERIALIZABLE;	
0: 	}
0: 
0: 	/**
0: 	 * Notify a NPRS that it is the source for the specified 
0: 	 * TargetResultSet.  This is useful when doing bulk insert.
0: 	 *
0: 	 * @param trs	The TargetResultSet.
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	public void setTargetResultSet(TargetResultSet trs)
0: 	{
0: 	}
0: 
0: 	/**
0: 	 * Set whether or not the NPRS need the row location when acting
0: 	 * as a row source.  (The target result set determines this.)
0: 	 * 
0: 	 * @param boolean needsRowLocation
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	public void setNeedsRowLocation(boolean needsRowLocation)
0: 	{
0: 	}
0: 
0: 	/**
0: 	 * Get the estimated row count from this result set.
0: 	 *
0: 	 * @return	The estimated row count (as a double) from this result set.
0: 	 */
0: 	public double getEstimatedRowCount()
0: 	{
0: 		return 0d;
0: 	}
0: 
0: 	/**
0: 	 * Get the number of this ResultSet, which is guaranteed to be unique
0: 	 * within a statement.
0: 	 */
0: 	public int resultSetNumber()
0: 	{
0: 		return 0;
0: 	}
0: 
0: 	/**
0: 	 * Set the current row to the row passed in.
0: 	 *
0: 	 * @param row the new current row
0: 	 *
0: 	 */
0: 	public void setCurrentRow(ExecRow row)
0: 	{
0: 		currentRow = row;
0: 	}
0: 
0: 	/**
0: 	 * Clear the current row
0: 	 *
0: 	 */
0: 	public void clearCurrentRow()
0: 	{
0: 		currentRow = null;
0: 	}
0: 
0: 	/**
0: 	 * This result set has its row from the last fetch done. 
0: 	 * If the cursor is closed, a null is returned.
0: 	 *
0: 	 * @see CursorResultSet
0: 	 *
0: 	 * @return the last row returned;
0: 	 * @exception StandardException thrown on failure.
0: 	 */
0: 	public ExecRow getCurrentRow() throws StandardException 
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(isOpen, "resultSet expected to be open");
0: 		}
0: 
0: 		return currentRow;
0: 	}
0: 
0: 	/**
0: 	 * Returns the row location of the current base table row of the cursor.
0: 	 * If this cursor's row is composed of multiple base tables' rows,
0: 	 * i.e. due to a join, then a null is returned.  For
0: 	 * a temporary row holder, we always return null.
0: 	 *
0: 	 * @return the row location of the current cursor row.
0: 	 */
0: 	public RowLocation getRowLocation()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(isOpen, "resultSet expected to be open");
0: 		}
0: 		return (RowLocation)null;
0: 	}
0: 
0: 
0: 	/**
0: 	 * Clean up
0: 	 *
0: 	 * @exception StandardException thrown on error
0: 	 */
0: 	public void	close() throws StandardException
0: 	{
0: 		isOpen = false;
0: 		numRowsOut = 0;
0: 		currentRow = null;
0: 		if (scan != null)
0: 		{
0: 			scan.close();
0: 			scan = null;
0: 		}
0: 	}
0: 
0: 
0: 	//////////////////////////////////////////////////////////////////////////
0: 	//
0: 	// MISC FROM RESULT SET
0: 	//
0: 	/////////////////////////////////////////////////////////////////////////
0: 
0: 	/**
0: 	 * Returns TRUE if the statement returns rows (i.e. is a SELECT
0: 	 * or FETCH statement), FALSE if it returns no rows.
0: 	 *
0: 	 * @return	TRUE if the statement returns rows, FALSE if not.
0: 	 */
0: 	public boolean	returnsRows()
0: 	{
0: 		return true;
0: 	}
0: 
0: 	public int modifiedRowCount() { return 0;};
0: 
0: 	/**
0: 	 * Returns a ResultDescription object, which describes the results
0: 	 * of the statement this ResultSet is in. This will *not* be a
0: 	 * description of this particular ResultSet, if this is not the
0: 	 * outermost ResultSet.
0: 	 *
0: 	 * @return	A ResultDescription describing the results of the
0: 	 *		statement.
0: 	 */
0: 	public ResultDescription	getResultDescription()
0: 	{
0: 		return resultDescription;
0: 	}
0: 
0: 	/**
0: 	 * Tells the system that there will be calls to getNextRow().
0: 	 *
0: 	 * @return	Nothing
0: 	 *
0: 	 * @exception StandardException		Thrown on failure
0: 	 */
0: 	public void open() throws StandardException
0: 	{
0: 		openCore();
0: 	}
0: 
0: 	/**
0: 	 * Returns the row at the absolute position from the query, 
0: 	 * and returns NULL when there is no such position.
0: 	 * (Negative position means from the end of the result set.)
0: 	 * Moving the cursor to an invalid position leaves the cursor
0: 	 * positioned either before the first row (negative position)
0: 	 * or after the last row (positive position).
0: 	 * NOTE: An exception will be thrown on 0.
0: 	 *
0: 	 * @param row	The position.
0: 	 * @return	The row at the absolute position, or NULL if no such position.
0: 	 *
0: 	 * @exception StandardException		Thrown on failure
0: 	 * @see Row
0: 	 */
0: 	public ExecRow	getAbsoluteRow(int row) throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.THROWASSERT(
0: 				"getAbsoluteRow() not expected to be called yet.");
0: 		}
0: 
0: 		return null;
0: 	}
0: 
0: 	/**
0: 	 * Returns the row at the relative position from the current
0: 	 * cursor position, and returns NULL when there is no such position.
0: 	 * (Negative position means toward the beginning of the result set.)
0: 	 * Moving the cursor to an invalid position leaves the cursor
0: 	 * positioned either before the first row (negative position)
0: 	 * or after the last row (positive position).
0: 	 * NOTE: 0 is valid.
0: 	 * NOTE: An exception is thrown if the cursor is not currently
0: 	 * positioned on a row.
0: 	 *
0: 	 * @param row	The position.
0: 	 * @return	The row at the relative position, or NULL if no such position.
0: 	 *
0: 	 * @exception StandardException		Thrown on failure
0: 	 * @see Row
0: 	 */
0: 	public ExecRow	getRelativeRow(int row) throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.THROWASSERT(
0: 				"getRelativeRow() not expected to be called yet.");
0: 		}
0: 
0: 		return null;
0: 	}
0: 
0: 	/**
0: 	 * Sets the current position to before the first row and returns NULL
0: 	 * because there is no current row.
0: 	 *
0: 	 * @return	NULL.
0: 	 *
0: 	 * @exception StandardException		Thrown on failure
0: 	 * @see Row
0: 	 */
0: 	public ExecRow	setBeforeFirstRow() 
0: 		throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.THROWASSERT(
0: 				"setBeforeFirstRow() not expected to be called yet.");
0: 		}
0: 
0: 		return null;
0: 	}
0: 
0: 	/**
0: 	 * Returns the first row from the query, and returns NULL when there
0: 	 * are no rows.
0: 	 *
0: 	 * @return	The first row, or NULL if no rows.
0: 	 *
0: 	 * @exception StandardException		Thrown on failure
0: 	 * @see Row
0: 	 */
0: 	public ExecRow	getFirstRow() 
0: 		throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.THROWASSERT(
0: 				"getFirstRow() not expected to be called yet.");
0: 		}
0: 
0: 		return null;
0: 	}
0: 
0: 	/**
0: 	 * Returns the next row from the query, and returns NULL when there
0: 	 * are no more rows.
0: 	 *
0: 	 * @return	The next row, or NULL if no more rows.
0: 	 *
0: 	 * @exception StandardException		Thrown on failure
0: 	 * @see Row
0: 	 */
0: 	public ExecRow	getNextRow() throws StandardException
0: 	{
0: 		return getNextRowCore();
0: 	}
0: 
0: 	/**
0: 	 * Returns the previous row from the query, and returns NULL when there
0: 	 * are no more previous rows.
0: 	 *
0: 	 * @return	The previous row, or NULL if no more previous rows.
0: 	 *
0: 	 * @exception StandardException		Thrown on failure
0: 	 * @see Row
0: 	 */
0: 	public ExecRow	getPreviousRow() 
0: 		throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.THROWASSERT(
0: 				"getPreviousRow() not expected to be called yet.");
0: 		}
0: 
0: 		return null;
0: 	}
0: 
0: 	/**
0: 	 * Returns the last row from the query, and returns NULL when there
0: 	 * are no rows.
0: 	 *
0: 	 * @return	The last row, or NULL if no rows.
0: 	 *
0: 	 * @exception StandardException		Thrown on failure
0: 	 * @see Row
0: 	 */
0: 	public ExecRow	getLastRow()
0: 		throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.THROWASSERT(
0: 				"getLastRow() not expected to be called yet.");
0: 		}
0: 
0: 		return null;
0: 	}
0: 
0: 	/**
0: 	 * Sets the current position to after the last row and returns NULL
0: 	 * because there is no current row.
0: 	 *
0: 	 * @return	NULL.
0: 	 *
0: 	 * @exception StandardException		Thrown on failure
0: 	 * @see Row
0: 	 */
0: 	public ExecRow	setAfterLastRow() 
0: 		throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.THROWASSERT(
0: 				"getLastRow() not expected to be called yet.");
0: 		}
0: 
0: 		return null;
0: 	}
0: 
0:     /**
0:      * Determine if the cursor is before the first row in the result 
0:      * set.   
0:      *
0:      * @return true if before the first row, false otherwise. Returns
0:      * false when the result set contains no rows.
0:      */
0:     public boolean checkRowPosition(int isType)
0: 	{
0: 		return false;
0: 	}
0: 
0: 	/**
0: 	 * Returns the row number of the current row.  Row
0: 	 * numbers start from 1 and go to 'n'.  Corresponds
0: 	 * to row numbering used to position current row
0: 	 * in the result set (as per JDBC).
0: 	 *
0: 	 * @return	the row number, or 0 if not on a row
0: 	 *
0: 	 */
0: 	public int getRowNumber()
0: 	{
0: 		return 0;
0: 	}
0: 
0: 	/**
0: 	 * Tells the system to clean up on an error.
0: 	 *
0: 	 * @return	Nothing
0: 	 *
0: 	 * @exception StandardException		Thrown on error.
0: 	 */
0: 	public void	cleanUp() throws StandardException
0: 	{
0: 		close();
0: 	}
0: 
0: 
0: 	/**
0: 		Find out if the ResultSet is closed or not.
0: 		Will report true for result sets that do not return rows.
0: 
0: 		@return true if the ResultSet has been closed.
0: 	 */
0: 	public boolean isClosed()
0: 	{
0: 		return !isOpen;
0: 	}
0: 
0: 	/**
0: 	 * Tells the system that there will be no more access
0: 	 * to any database information via this result set;
0: 	 * in particular, no more calls to open().
0: 	 * Will close the result set if it is not already closed.
0: 	 *
0: 	 * @return	Nothing
0: 	 * @exception StandardException	on error
0: 	 */
0: 	public void finish() throws StandardException
0: 	{
0: 		finished = true;
0: 		close();
0: 	}
0: 
0: 
0: 	/**
0: 	 * Get the execution time in milliseconds.
0: 	 *
0: 	 * @return long		The execution time in milliseconds.
0: 	 */
0: 	public long getExecuteTime()
0: 	{
0: 		return 0L;
0: 	}
0: 
0: 	/**
0: 	 * @see ResultSet#getAutoGeneratedKeysResultset
0: 	 */
0: 	public ResultSet getAutoGeneratedKeysResultset()
0: 	{
0: 		//A non-null resultset would be returned only for an insert statement 
0: 		return (ResultSet)null;
0: 	}
0: 
0: 	/**
0: 	 * Get the Timestamp for the beginning of execution.
0: 	 *
0: 	 * @return Timestamp		The Timestamp for the beginning of execution.
0: 	 */
0: 	public Timestamp getBeginExecutionTimestamp()
0: 	{
0: 		return (Timestamp)null;
0: 	}
0: 
0: 	/**
0: 	 * Get the Timestamp for the end of execution.
0: 	 *
0: 	 * @return Timestamp		The Timestamp for the end of execution.
0: 	 */
0: 	public Timestamp getEndExecutionTimestamp()
0: 	{
0: 		return (Timestamp)null;
0: 	}
0: 
0: 	/**
0: 	 * Return the total amount of time spent in this ResultSet
0: 	 *
0: 	 * @param type	CURRENT_RESULTSET_ONLY - time spent only in this ResultSet
0: 	 *				ENTIRE_RESULTSET_TREE  - time spent in this ResultSet and below.
0: 	 *
0: 	 * @return long		The total amount of time spent (in milliseconds).
0: 	 */
0: 	public long getTimeSpent(int type)
0: 	{
0: 		return 0L;
0: 	}
0: 
0: 
0: 	/**
0: 	 * Get the subquery ResultSet tracking array from the top ResultSet.
0: 	 * (Used for tracking open subqueries when closing down on an error.)
0: 	 *
0: 	 * @param numSubqueries		The size of the array (For allocation on demand.)
0: 	 *
0: 	 * @return NoPutResultSet[]	Array of NoPutResultSets for subqueries.
0: 	 */
0: 	public NoPutResultSet[] getSubqueryTrackingArray(int numSubqueries)
0: 	{
0: 		return (NoPutResultSet[])null;
0: 	}
0: 
0: 	/**
0: 	 * Returns the name of the cursor, if this is cursor statement of some
0: 	 * type (declare, open, fetch, positioned update, positioned delete,
0: 	 * close).
0: 	 *
0: 	 * @return	A String with the name of the cursor, if any. Returns
0: 	 *		NULL if this is not a cursor statement.
0: 	 */
0: 	public String	getCursorName()
0: 	{
0: 		return (String) null;
0: 	}
0: 
0: 	/**
0: 	 * @see NoPutResultSet#requiresRelocking
0: 	 */
0: 	public boolean requiresRelocking()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.THROWASSERT(
0: 				"requiresRelocking() not expected to be called for " +
0: 				getClass().getName());
0: 		}
0: 		return false;
0: 	}
0: 
0: 	/////////////////////////////////////////////////////////
0: 	//
0: 	// Access/RowSource -- not implemented
0: 	// 
0: 	/////////////////////////////////////////////////////////
0: 	/**
0: 		Get the next row as an array of column objects. The column objects can
0: 		be a JBMS Storable or any
0: 		Serializable/Externalizable/Formattable/Streaming type.
0: 		<BR>
0: 		A return of null indicates that the complete set of rows has been read.
0: 
0: 		<p>
0: 		A null column can be specified by leaving the object null, or indicated
0: 		by returning a non-null getValidColumns.  On streaming columns, it can
0: 		be indicated by returning a non-null get FieldStates.
0: 
0: 		<p>
0:         If RowSource.needToClone() is true then the returned row (the 
0:         DataValueDescriptor[]) is guaranteed not to be modified by drainer of 
0:         the RowSource (except that the input stream will be read, of course) 
0:         and drainer will keep no reference to it before making the subsequent 
0:         nextRow call.  So it is safe to return the same DataValueDescriptor[] 
0:         in subsequent nextRow calls if that is desirable for performance 
0:         reasons.  
0: 		<p>
0:         If RowSource.needToClone() is false then the returned row (the 
0:         DataValueDescriptor[]) may be be modified by drainer of the RowSource, 
0:         and the drainer may keep a reference to it after making the subsequent 
0:         nextRow call.  In this case the client should severe all references to 
0:         the row after returning it from getNextRowFromRowSource().
0: 
0: 		@exception StandardException Cloudscape Standard Error Policy
0: 	 */
0: 	public DataValueDescriptor[] getNextRowFromRowSource() throws StandardException
0: 	{ 
0: 		return null;
0: 	}
0: 
0: 	/**
0:         Does the caller of getNextRowFromRowSource() need to clone the row
0:         in order to keep a reference to the row past the 
0:         getNextRowFromRowSource() call which returned the row.  This call
0:         must always return the same for all rows in a RowSource (ie. the
0:         caller will call this once per scan from a RowSource and assume the
0:         behavior is true for all rows in the RowSource).
0: 
0: 	 */
0: 	public boolean needsToClone()
0: 	{
0: 		return false;
0: 	}
0: 
0: 
0: 	/**
0: 	  getValidColumns describes the DataValueDescriptor[] returned by all 
0:       calls to the getNextRowFromRowSource() call. 
0: 
0: 	  If getValidColumns returns null, the number of columns is given by the
0: 	  DataValueDescriptor.length where DataValueDescriptor[] is returned by the
0:       preceeding getNextRowFromRowSource() call.  Column N maps to 
0:       DataValueDescriptor[N], where column numbers start at zero.
0: 
0: 	  If getValidColumns return a non null validColumns FormatableBitSet the number of
0: 	  columns is given by the number of bits set in validColumns.  Column N is
0: 	  not in the partial row if validColumns.get(N) returns false.  Column N is
0: 	  in the partial row if validColumns.get(N) returns true.  If column N is
0: 	  in the partial row then it maps to DataValueDescriptor[M] where M is the
0:       count of calls to validColumns.get(i) that return true where i < N.  If
0: 	  DataValueDescriptor.length is greater than the number of columns 
0:       indicated by validColumns the extra entries are ignored.  
0: 	*/
0: 	public FormatableBitSet getValidColumns()
0: 	{
0: 		return null;
0: 	}
0: 
0: 	/**
0: 		closeRowSource tells the RowSource that it will no longer need to
0: 		return any rows and it can release any resource it may have.
0: 		Subsequent call to any method on the RowSource will result in undefined
0: 		behavior.  A closed rowSource can be closed again.
0: 	*/
0: 	public void closeRowSource()
0: 	{ }
0: 
0: 
0: 	/////////////////////////////////////////////////////////
0: 	//
0: 	// Access/RowLocationRetRowSource -- not implemented
0: 	// 
0: 	/////////////////////////////////////////////////////////
0: 	/**
0: 		needsRowLocation returns true iff this the row source expects the
0: 		drainer of the row source to call rowLocation after getting a row from
0: 		getNextRowFromRowSource.
0: 
0: 		@return true iff this row source expects some row location to be
0: 		returned 
0: 		@see #rowLocation
0: 	 */
0: 	public boolean needsRowLocation()
0: 	{
0: 		return false;
0: 	}
0: 
0: 	/**
0: 		rowLocation is a callback for the drainer of the row source to return
0: 		the rowLocation of the current row, i.e, the row that is being returned
0: 		by getNextRowFromRowSource.  This interface is for the purpose of
0: 		loading a base table with index.  In that case, the indices can be
0: 		built at the same time the base table is laid down once the row
0: 		location of the base row is known.  This is an example pseudo code on
0: 		how this call is expected to be used:
0: 		
0: 		<BR><pre>
0: 		boolean needsRL = rowSource.needsRowLocation();
0: 		DataValueDescriptor[] row;
0: 		while((row = rowSource.getNextRowFromRowSource()) != null)
0: 		{
0: 			RowLocation rl = heapConglomerate.insertRow(row);
0: 			if (needsRL)
0: 				rowSource.rowLocation(rl);
0: 		}
0: 		</pre><BR>
0: 
0: 		NeedsRowLocation and rowLocation will ONLY be called by a drainer of
0: 		the row source which CAN return a row location.  Drainer of row source
0: 		which cannot return rowLocation will guarentee to not call either
0: 		callbacks. Conversely, if NeedsRowLocation is called and it returns
0: 		true, then for every row return by getNextRowFromRowSource, a
0: 		rowLocation callback must also be issued with the row location of the
0: 		row.  Implementor of both the source and the drain of the row source
0: 		must be aware of this protocol.
0: 
0: 		<BR>
0: 		The RowLocation object is own by the caller of rowLocation, in other
0: 		words, the drainer of the RowSource.  This is so that we don't need to
0: 		new a row location for every row.  If the Row Source wants to keep the
0: 		row location, it needs to clone it (RowLocation is a ClonableObject).
0: 		@exception StandardException on error
0: 	 */
0: 	public void rowLocation(RowLocation rl) throws StandardException
0: 	{ }
0: 
0: 	// Class implementation
0: 
0: 	/**
0: 	 * Is this ResultSet or it's source result set for update
0: 	 * This method will be overriden in the inherited Classes
0: 	 * if it is true
0: 	 * @return Whether or not the result set is for update.
0: 	 */
0: 	public boolean isForUpdate()
0: 	{
0: 		return false;
0: 	}
0: 
0: 	/**
0: 	 * Shallow clone this result set.  Used in trigger reference.
0: 	 * beetle 4373.
0: 	 */
0: 	public Object clone()
0: 	{
0: 		Object clo = null;
0: 		try {
0: 			clo = super.clone();
0: 		}
0: 		catch (CloneNotSupportedException e) {}
0: 		return clo;
0: 	}
0: 	public java.sql.SQLWarning getWarnings() {
0: 		return null;
0: 	}
0: }
============================================================================