1:67614ad: /*
57:67614ad: 
1:f68f62f:    Derby - Class org.apache.derbyTesting.functionTests.util.Triggers
1:67614ad: 
1:15651f5:    Licensed to the Apache Software Foundation (ASF) under one or more
1:15651f5:    contributor license agreements.  See the NOTICE file distributed with
1:15651f5:    this work for additional information regarding copyright ownership.
1:15651f5:    The ASF licenses this file to You under the Apache License, Version 2.0
1:15651f5:    (the "License"); you may not use this file except in compliance with
1:15651f5:    the License.  You may obtain a copy of the License at
1:67614ad: 
1:f68f62f:       http://www.apache.org/licenses/LICENSE-2.0
1:67614ad: 
1:f68f62f:    Unless required by applicable law or agreed to in writing, software
1:f68f62f:    distributed under the License is distributed on an "AS IS" BASIS,
1:f68f62f:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:f68f62f:    See the License for the specific language governing permissions and
1:f68f62f:    limitations under the License.
1:67614ad: 
3:67614ad:  */
1:67614ad: 
1:67614ad: package org.apache.derbyTesting.functionTests.util;
1:67614ad: 
1:67614ad: import java.sql.*;
1:67614ad: 
3:67614ad: /**
1:67614ad:  * Methods for testing triggers
1:67614ad:  */
1:67614ad: public class Triggers
58:67614ad: {
1:78227e4:     private static final String RESULT_SET_NOT_OPEN = "XCL16";
1:78227e4: 
1:78227e4:     private Triggers()
1:67614ad: 	{
55:67614ad: 	}
1:67614ad: 
1:67614ad: 
1:67614ad: 	public static int doNothingInt() throws Throwable
1:67614ad: 	{
1:67614ad: 		return 1;
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public static void doNothing() throws Throwable
2:67614ad: 	{}
1:67614ad: 
1:67614ad: 	public static int doConnCommitInt() throws Throwable
1:67614ad: 	{
3:67614ad: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:67614ad: 		conn.commit();
1:67614ad: 		return 1;
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public static void doConnCommit() throws Throwable
1:67614ad: 	{
1:67614ad: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:67614ad: 		conn.commit();
1:67614ad: 	}
1:67614ad: 			
1:67614ad: 	public static void doConnRollback() throws Throwable
1:67614ad: 	{
1:67614ad: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:67614ad: 		conn.rollback();
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public static void doConnectionSetIsolation() throws Throwable
1:67614ad: 	{
1:67614ad: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:67614ad: 		conn.setTransactionIsolation(conn.TRANSACTION_SERIALIZABLE);
1:67614ad: 	}
1:67614ad: 			
1:67614ad: 	public static int doConnStmtIntNoRS(String text) throws Throwable
1:67614ad: 	{
1:67614ad: 		doConnStmtNoRS(text);
1:67614ad: 		return 1;
1:67614ad: 	}
1:67614ad: 	public static void doConnStmtNoRS(String text) throws Throwable
1:67614ad: 	{
1:67614ad: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:67614ad: 		Statement stmt = conn.createStatement();
1:67614ad: 		stmt.execute(text);
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public static int doConnStmtInt(String text) throws Throwable
1:67614ad: 	{
2:67614ad: 		doConnStmt(text);
1:67614ad: 		return 1;
1:67614ad: 	}
1:67614ad: 	public static void doConnStmt(String text) throws Throwable
1:67614ad: 	{
1:67614ad: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:67614ad: 		Statement stmt = conn.createStatement();
1:67614ad: 		if (stmt.execute(text))
1:67614ad: 		{
1:67614ad: 			ResultSet rs = stmt.getResultSet();
1:78227e4:             try {
1:78227e4:                 while (rs.next()) {}
1:78227e4:             } catch (SQLException e) {
1:78227e4:                 if (RESULT_SET_NOT_OPEN.equals(e.getSQLState())) {
1:78227e4:                     // Some side effect (stored proc?) made the rs close,
1:78227e4:                     // bail out
1:78227e4:                 } else {
1:78227e4:                     throw e;
1:78227e4:                 }
1:78227e4:             } finally {
1:78227e4:                 rs.close();
1:78227e4:             }
1:67614ad: 		}
1:67614ad: 		stmt.close();
1:67614ad: 		conn.close();
1:67614ad: 	}
1:67614ad: 
1:698f7a2: 	public static void getConnection() throws Throwable
1:67614ad: 	{
1:67614ad: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:698f7a2: 		conn.close();
1:698f7a2: 		System.out.println("getConnection() called");
1:67614ad: 	}
2:67614ad: 	// used for performance numbers
1:67614ad: 	static void zipThroughRs(ResultSet s) throws SQLException
1:67614ad: 	{
2:67614ad: 		if (s == null)
6:67614ad: 			return;
1:67614ad: 		
1:67614ad: 		while (s.next()) ;
1:67614ad: 	}
1:67614ad: 
1:67614ad: 
1:67614ad: 	public static long returnPrimLong(long  x)
1:67614ad: 	{
1:67614ad: 		return x;
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public static Long returnLong(Long x)
1:67614ad: 	{
1:67614ad: 		return x;
1:67614ad: 	}
1:67614ad: 
1:67614ad: 
1:67614ad: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:78227e4
/////////////////////////////////////////////////////////////////////////
1:     private static final String RESULT_SET_NOT_OPEN = "XCL16";
1: 
1:     private Triggers()
/////////////////////////////////////////////////////////////////////////
1:             try {
1:                 while (rs.next()) {}
1:             } catch (SQLException e) {
1:                 if (RESULT_SET_NOT_OPEN.equals(e.getSQLState())) {
1:                     // Some side effect (stored proc?) made the rs close,
1:                     // bail out
1:                 } else {
1:                     throw e;
1:                 }
1:             } finally {
1:                 rs.close();
1:             }
commit:8a59583
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:15651f5
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:67614ad
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derbyTesting.functionTests.util
0:    (C) Copyright IBM Corp. 1999, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.util;
1: 
0: import org.apache.derby.iapi.db.*;
1: import java.sql.*;
0: import java.math.BigDecimal;
0: import java.math.BigInteger;
1: 
1: /**
1:  * Methods for testing triggers
1:  */
1: public class Triggers
1: { 
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	private static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1999_2004;
1: 
0: 	// used for threading test
0: 	static TriggerThread triggerThread;
1: 
0: 	public Triggers()
1: 	{
1: 	}
1: 
0: 	public static String triggerFiresMinimal(String string) throws Throwable
1: 	{
0: 		TriggerExecutionContext tec = Factory.getTriggerExecutionContext();
0: 		System.out.println("TRIGGER: " + "<"+string+">");
0: 		return "";
1: 	}
1: 
0: 	public static String triggerFires(String string) throws Throwable
1: 	{
0: 		TriggerExecutionContext tec = Factory.getTriggerExecutionContext();
0: 		System.out.println("TRIGGER: " + "<"+string+"> on statement "+tec.getEventStatementText());
0: 		printTriggerChanges();
0: 		return "";
1: 	}
1: 
0: 	public static void triggerFiresRep(String string) throws Throwable
1: 	{	
0: 		String preface = isReplicationTarget() ? 
0: 						"TARGET: " : isReplicationSource() ?
0: 								"SOURCE: " : "<not in rep context>" ;
0: 		TriggerExecutionContext tec = Factory.getTriggerExecutionContext();
0: 		System.out.println(preface + "<"+string+"> on statement "+tec.getEventStatementText());
0: 		printTriggerChanges();
1: 	}
1: 
0: 	public static boolean isReplicationTarget() throws Throwable
1: 	{
0: 		String repTargetProp = PropertyInfo.getDatabaseProperty("derby.engineType");
0: 		return (repTargetProp != null && repTargetProp.equals("8"));
1: 	}
0: 	public static boolean isReplicationSource() throws Throwable
1: 	{
0: 		String repSourceProp = PropertyInfo.getDatabaseProperty("derby.engineType");
0: 		return (repSourceProp != null && repSourceProp.equals("4"));
1: 	}
1: 
1: 	public static int doNothingInt() throws Throwable
1: 	{
1: 		return 1;
1: 	}
1: 
1: 	public static void doNothing() throws Throwable
1: 	{}
1: 
1: 	public static int doConnCommitInt() throws Throwable
1: 	{
1: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
1: 		conn.commit();
1: 		return 1;
1: 	}
1: 
1: 	public static void doConnCommit() throws Throwable
1: 	{
1: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
1: 		conn.commit();
1: 	}
1: 			
1: 	public static void doConnRollback() throws Throwable
1: 	{
1: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
1: 		conn.rollback();
1: 	}
1: 
1: 	public static void doConnectionSetIsolation() throws Throwable
1: 	{
1: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
1: 		conn.setTransactionIsolation(conn.TRANSACTION_SERIALIZABLE);
1: 	}
1: 			
1: 	public static int doConnStmtIntNoRS(String text) throws Throwable
1: 	{
1: 		doConnStmtNoRS(text);
1: 		return 1;
1: 	}
1: 	public static void doConnStmtNoRS(String text) throws Throwable
1: 	{
1: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
1: 		Statement stmt = conn.createStatement();
1: 		stmt.execute(text);
1: 	}
1: 
1: 	public static int doConnStmtInt(String text) throws Throwable
1: 	{
1: 		doConnStmt(text);
1: 		return 1;
1: 	}
1: 	public static void doConnStmt(String text) throws Throwable
1: 	{
1: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
1: 		Statement stmt = conn.createStatement();
1: 		if (stmt.execute(text))
1: 		{
1: 			ResultSet rs = stmt.getResultSet();
0: 			while (rs.next())
1: 			{}
0: 			rs.close();
1: 		}
1: 		stmt.close();
1: 		conn.close();
1: 	}
1: 
0: 	public static void doConnStmt(String text, boolean targetOnly) throws Throwable
1: 	{
0: 		if (isReplicationTarget() == targetOnly)
1: 		{
0: 			System.out.println("Trigger Executing: "+text);
1: 			doConnStmt(text);
1: 		}
1: 	}
1: 
0: 	public static void workUnitFires() throws Throwable
1: 	{
0: 		System.out.println((isReplicationTarget() ? 
0: 						"TARGET: workUnitFires" : isReplicationSource() ?
0: 								"SOURCE: workUnitFires" : 
0: 								"<error, not in rep context?!?>"));
1: 	}
1: 
0: 	public static String printTriggerInfo() throws Throwable
1: 	{
0: 		TriggerExecutionContext tec = Factory.getTriggerExecutionContext();
0: 		int eventType = tec.getEventType();
0: 		String eventName;
1: 
0: 		switch (eventType)
1: 		{
0: 			case TriggerExecutionContext.UPDATE_EVENT: 
0: 					eventName = "UPDATE";
0: 					break;
1: 
0: 			case TriggerExecutionContext.DELETE_EVENT: 
0: 					eventName = "DELETE";
0: 					break;
1: 
0: 			case TriggerExecutionContext.INSERT_EVENT: 
0: 					eventName = "INSERT";
0: 					break;
0: 			default:
0: 				throw new Throwable("unexpected event type: "+eventType);
1: 		}			
1: 
0: 		StringBuffer strbuf = new StringBuffer("TriggerInformation\n------------------\n");
0: 		strbuf.append("getEventStatetmentText(): "+tec.getEventStatementText());
0: 		strbuf.append("\ngetEventType(): "+eventName);
0: 		strbuf.append("\ngetModifiedColumns(): {");
1: 
0: 		String[] modifiedCols = tec.getModifiedColumns();
0: 		if (modifiedCols == null)
1: 		{
0: 			strbuf.append(" <all> }");
1: 		}
0: 		else
1: 		{
0: 			for (int i = 0; i < modifiedCols.length; i++)
1: 			{
0: 				if (i > 0)
0: 					strbuf.append(", ");
0: 				strbuf.append(modifiedCols[i]);
1: 			}
0: 			strbuf.append("}");
1: 		}
0: 		strbuf.append("\n");
0: 		strbuf.append(getModifiedColumnsCheckInfo(tec));
0: 		System.out.println(strbuf.toString());
0: 		printTriggerChanges();
0: 		return "";
1: 	}
1: 
0: 	private static String getModifiedColumnsCheckInfo(TriggerExecutionContext tec) throws Throwable
1: 	{
0: 		ResultSet rs = (tec.getNewRowSet() == null) ?
0: 					tec.getOldRowSet() :
0: 					tec.getNewRowSet();
1: 
0: 		ResultSetMetaData rsmd = rs.getMetaData();
1: 
0: 		// Get the number of columns in the result set
0: 		int numCols = rsmd.getColumnCount();
1: 
0: 		StringBuffer msg = new StringBuffer("wasColumnModified() on each column\n\t");
0: 		for (int i=1; i<=numCols; i++) 
1: 		{
0: 			if (i > 1) 
1: 			{
0: 				msg.append("\n\t");
1: 			}
0: 			msg.append(rsmd.getColumnLabel(i));
0: 			msg.append(":\t");
0: 			boolean wasModified = tec.wasColumnModified(rsmd.getColumnLabel(i));
0: 			if (wasModified != tec.wasColumnModified(i))
1: 			{
0: 				msg.append("ERROR: tec.wasColumnModifed(String) = "+wasModified);
0: 				msg.append("and tec.wasColumnModifed(int) = "+(!wasModified));
1: 			}
0: 			else
1: 			{
0: 				msg.append(wasModified);
1: 			}
1: 		}
0: 		msg.append("\n");
0: 		return msg.toString();
1: 	}
1: 
1: 	// used for performance numbers
0: 	public static void zipThroughTriggerResultSets() throws SQLException
1: 	{
0: 		TriggerExecutionContext tec = Factory.getTriggerExecutionContext();
0: 		zipThroughRs(tec.getOldRowSet());
0: 		zipThroughRs(tec.getNewRowSet());
1: 	}
1: 
1: 	// used for performance numbers
1: 	static void zipThroughRs(ResultSet s) throws SQLException
1: 	{
1: 		if (s == null)
1: 			return;
1: 		
1: 		while (s.next()) ;
1: 	}
1: 
0: 	public static void barfOnInsertEquals(int value) throws Throwable
1: 	{
0: 		TriggerExecutionContext tec = Factory.getTriggerExecutionContext();
0: 		ResultSet rs = tec.getNewRowSet();
0: 		while (rs.next())
1: 		{
0: 			if (rs.getInt(1) == value)
1: 			{
0: 				throw new SQLException("barfing because of "+value+" in BeforeResultSet","38001");
1: 			}
1: 		}
1: 	}
1: 
0: 	private static void printTriggerChanges() throws Throwable
1: 	{
0: 		TriggerExecutionContext tec = Factory.getTriggerExecutionContext();
0: 		System.out.println("BEFORE RESULT SET");
0: 		dumpRS(tec.getOldRowSet());
0: 		System.out.println("\nAFTER RESULT SET");
0: 		dumpRS(tec.getNewRowSet());
1: 	}
1: 
0: 	// lifted from the metadata test	
0: 	private static void dumpRS(ResultSet s) throws SQLException 
1: 	{
1: 		if (s == null)
1: 		{
0: 			System.out.println("<NULL>");
1: 			return;
1: 		}
1: 
0: 		ResultSetMetaData rsmd = s.getMetaData();
1: 
0: 		// Get the number of columns in the result set
0: 		int numCols = rsmd.getColumnCount();
1: 
0: 		if (numCols <= 0) 
1: 		{
0: 			System.out.println("(no columns!)");
1: 			return;
1: 		}
1: 
0: 		StringBuffer heading = new StringBuffer("\t ");
0: 		StringBuffer underline = new StringBuffer("\t ");
1: 
0: 		int len;
0: 		// Display column headings
0: 		for (int i=1; i<=numCols; i++) 
1: 		{
0: 			if (i > 1) 
1: 			{
0: 				heading.append(",");
0: 				underline.append(" ");
1: 			}
0: 			len = heading.length();
0: 			heading.append(rsmd.getColumnLabel(i));
0: 			len = heading.length() - len;
0: 			for (int j = len; j > 0; j--)
1: 			{
0: 				underline.append("-");
1: 			}
1: 		}
0: 		System.out.println(heading.toString());
0: 		System.out.println(underline.toString());
1: 		
1: 	
0: 		StringBuffer row = new StringBuffer();
0: 		// Display data, fetching until end of the result set
0: 		while (s.next()) 
1: 		{
0: 			row.append("\t{");
0: 			// Loop through each column, getting the
0: 			// column data and displaying
0: 			for (int i=1; i<=numCols; i++) 
1: 			{
0: 				if (i > 1) row.append(",");
0: 				row.append(s.getString(i));
1: 			}
0: 			row.append("}\n");
1: 		}
0: 		System.out.println(row.toString());
0: 		s.close();
1: 	}
1: 
0: 	// WARNING: will deadlock unless on a separate
0: 	// connection
0: 	public static void notifyDMLDone() throws Throwable
1: 	{
0: 		if (triggerThread == null)
1: 		{
0: 			System.out.println("ERROR: no triggerThread object, has beginInvalidRefToTECTest() been executed?");
1: 		}
0: 		else
1: 		{
0: 			triggerThread.goForIt();
0: 			while (!triggerThread.done())
1: 			{
0: 				try {Thread.sleep(1000L); } catch (InterruptedException e) {}
1: 			}
0: 			triggerThread = null;
1: 		}
1: 	}
1: 
0: 	public static void simpleTrigger() throws Throwable
1: 	{
0: 		Long ai;
1: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
1: 		
0: 		PreparedStatement lastai = conn.prepareStatement("values org.apache.derby.iapi.db.ConnectionInfo::lastAutoincrementValue('APP', 'TRIGTEST', 'S1') ");
1: 		
0: 		ResultSet rs = lastai.executeQuery();
0: 		rs.next();
0: 		ai = (Long)rs.getObject(1);
0: 		rs.close();
0: 		System.out.println("autoincrement value is " + ai);
1: 	}
1: 	/**
1: 	 */
0: 	public static void insertIntoTab1(Integer level)
0: 	      throws Throwable	
1: 	{
0: 		Long entry, exit;
0: 		int levelValue = level.intValue();
0: 		long entryValue, exitValue;
1: 
1: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
1: 		
0: 		PreparedStatement lastai = conn.prepareStatement("values (org.apache.derby.iapi.db.ConnectionInfo::lastAutoincrementValue('APP','TAB1','S1'))");
0: 		ResultSet rs = lastai.executeQuery();
0: 		rs.next();
0: 		entry = (Long)rs.getObject(1);
0: 		rs.close();
1: 
0: 		System.out.println("coming in with level = " + levelValue + 
0: 						   " and autoincrement = " + entry.longValue());
1: 		
0: 		if (levelValue == 3)
1: 			return;
1: 
1: 		
0: 		PreparedStatement ps = 
0: 			conn.prepareStatement("insert into tab1 (lvl) values (?)");
0: 		// insert one higher value into tab1.
0: 		ps.setInt(1, levelValue + 1);
0: 		ps.execute();
1: 		
0: 		rs = lastai.executeQuery();
0: 		rs.next();
0: 		exit = (Long)rs.getObject(1);
0: 		rs.close();
1: 
0: 		// When we get out of this trigger, subsequent firings of the trigger by the
0: 		// insert statement in this routine shouldn't be returned by
0: 		// lastautoincrement value.
1: 
0: 		System.out.println("going out with level = " + levelValue + 
0: 						   " and autoincrement = " + exit.longValue());
1: 
1: 	}
1: 
1: 
0: 	public static void aiWorkUnit(String s)
0: 	       	      throws Throwable	
1: 	{
1: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
0: 		String query = "insert into watab (s) values (?)";
0: 		PreparedStatement ps = conn.prepareStatement(query);
0: 		System.out.println("in work unit with s=" + s);
0: 		ps.setString(1, s);
0: 		ps.execute();
1: 	}
1: 
0: 	public static String beginInvalidRefToTECTest() throws Throwable
1: 	{
0: 		triggerThread = new TriggerThread();
0: 		triggerThread.start();
0: 		return "";
1: 	}
1: 
1: 	public static long returnPrimLong(long  x)
1: 	{
1: 		return x;
1: 	}
1: 
1: 	public static Long returnLong(Long x)
1: 	{
1: 		return x;
1: 	}
1: 
0: 	// used to test binding
0: 	public static void allTypesMethodPrimitive
0: 	(
0: 		int 		i,
0: 		byte		by,	
0: 		short		s,
0: 		long		l,
0: 		String		s1,
0: 		String		s2,
0: 		String		s3,
0: 		boolean		bl,
0: 		double		db,
0: 		float		f1,
0: 		double		db2,
0: 		Date		dt,
0: 		Time		t,
0: 		Timestamp	ts,
0: 		byte[]		b1,
0: 		byte[]		b2,
0: 		byte[]		b3,
0: 		double		bd1,
0: 		double		bd2,
0: 		BigInteger	bi
0: 	)
1: 	{
1: 	}
1: 
0: 	public static void allTypesMethodObject
0: 	(
0: 		Integer		i,
0: 		Integer		by,	
0: 		Integer		s,
0: 		Long		l,
0: 		String		s1,
0: 		String		s2,
0: 		String		s3,
0: 		Boolean		bl,
0: 		Double		db,
0: 		Float		f1,
0: 		Double		db2,
0: 		Date		dt,
0: 		Time		t,
0: 		Timestamp	ts,
0: 		byte[]		b1,
0: 		byte[]		b2,
0: 		byte[]		b3,
0: 		BigDecimal	bd1,
0: 		BigDecimal	bd2,
0: 		BigInteger	bi
0: 	)
1: 	{
1: 	}
1: 
1: }
1: 
0: // class for testing valid tec accesses	
0: class TriggerThread extends Thread
1: {	
0: 	private TriggerExecutionContext tec;
0: 	private ResultSet rs;
0: 	private boolean start; 
0: 	private boolean done; 
1: 
0: 	public TriggerThread() throws Throwable
1: 	{
0: 		this.tec = Factory.getTriggerExecutionContext();
0: 		if (tec == null)
1: 		{
0: 			System.out.println("ERROR: no tec found, no trigger appears to be active");
1: 			return;
1: 		}
1: 	
0: 		this.rs = (tec.getNewRowSet() == null) ?
0: 			tec.getOldRowSet() :
0: 			tec.getNewRowSet();
1: 	}
1: 
0: 	public void goForIt()
1: 	{
0: 		start = true;
1: 	}
1: 
0: 	public boolean done()
1: 	{
0: 		return done;
1: 	}
1: 
0: 	public void run() 
1: 	{
0: 		boolean gotException = false;
1: 	
0: 		int i;	
0: 		for (i = 0; !start && i < 1000; i++)
1: 		{
0: 			try {Thread.sleep(50L); } catch (InterruptedException e) {}
1: 		} 
0: 		if (i == 1000)
1: 		{
0: 			System.out.println("ERROR: start never received");
1: 			return;
1: 		}
0: 		// let the other thread get to its pause point
0: 		try {Thread.sleep(5000L); } catch (InterruptedException e) {}
1: 
0: 		System.out.println("...nested thread running using expired tec");
0: 		try
1: 		{
0: 			System.out.println("...trying to loop through stale result set");
0: 			Triggers.zipThroughRs(rs);
0: 		} catch (SQLException e)
1: 		{
0: 			gotException = true;	
0: 			System.out.println("Got expected exception: "+e);
1: 		}
0: 		if (!gotException)
1: 		{
0: 			System.out.println("ERROR: no exception when trying to do next on stale ResultSet");
1: 		}
0: 		gotException = false;
1: 
0: 		try
1: 		{	
0: 			tec.getNewRowSet();
0: 		} catch (SQLException e)
1: 		{
0: 			gotException = true;	
0: 			System.out.println("Got expected exception: "+e);
1: 		}
1: 
0: 		if (!gotException)
1: 		{
0: 			System.out.println("ERROR: getNewRowSet() didn't throw an exception on stale tec");
1: 		}
1: 
0: 		gotException = false;
1: 
0: 		try
1: 		{	
0: 			tec.getOldRowSet();
0: 		} catch (SQLException e)
1: 		{
0: 			gotException = true;	
0: 			System.out.println("Got expected exception: "+e);
1: 		}
1: 
0: 		if (!gotException)
1: 		{
0: 			System.out.println("ERROR: getOldRowSet() didn't throw an exception on stale tec");
1: 		}
1: 
0: 		// signal that we are done
0: 		done = true;
1: 	}
1: }
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:698f7a2
/////////////////////////////////////////////////////////////////////////
1: 	public static void getConnection() throws Throwable
0: 	{
0: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
1: 		conn.close();
1: 		System.out.println("getConnection() called");
0: 	}
commit:9a55713
/////////////////////////////////////////////////////////////////////////
0: 	private Triggers()
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: }
commit:648b4c1
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:f6f8e10
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:962234b
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:f68f62f
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
1:    Derby - Class org.apache.derbyTesting.functionTests.util.Triggers
0: 
0:    Copyright 1999, 2004 The Apache Software Foundation or its licensors, as applicable.
0: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
0: 
1:       http://www.apache.org/licenses/LICENSE-2.0
0: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
0: 
0:  */
0: 
0: package org.apache.derbyTesting.functionTests.util;
0: 
0: import org.apache.derby.iapi.db.*;
0: import java.sql.*;
0: import java.math.BigDecimal;
0: import java.math.BigInteger;
0: 
0: /**
0:  * Methods for testing triggers
0:  */
0: public class Triggers
0: {
0: 
0: 	// used for threading test
0: 	static TriggerThread triggerThread;
0: 
0: 	public Triggers()
0: 	{
0: 	}
0: 
0: 	public static String triggerFiresMinimal(String string) throws Throwable
0: 	{
0: 		TriggerExecutionContext tec = Factory.getTriggerExecutionContext();
0: 		System.out.println("TRIGGER: " + "<"+string+">");
0: 		return "";
0: 	}
0: 
0: 	public static String triggerFires(String string) throws Throwable
0: 	{
0: 		TriggerExecutionContext tec = Factory.getTriggerExecutionContext();
0: 		System.out.println("TRIGGER: " + "<"+string+"> on statement "+tec.getEventStatementText());
0: 		printTriggerChanges();
0: 		return "";
0: 	}
0: 
0: 	public static void triggerFiresRep(String string) throws Throwable
0: 	{	
0: 		String preface = isReplicationTarget() ? 
0: 						"TARGET: " : isReplicationSource() ?
0: 								"SOURCE: " : "<not in rep context>" ;
0: 		TriggerExecutionContext tec = Factory.getTriggerExecutionContext();
0: 		System.out.println(preface + "<"+string+"> on statement "+tec.getEventStatementText());
0: 		printTriggerChanges();
0: 	}
0: 
0: 	public static boolean isReplicationTarget() throws Throwable
0: 	{
0: 		String repTargetProp = PropertyInfo.getDatabaseProperty("derby.engineType");
0: 		return (repTargetProp != null && repTargetProp.equals("8"));
0: 	}
0: 	public static boolean isReplicationSource() throws Throwable
0: 	{
0: 		String repSourceProp = PropertyInfo.getDatabaseProperty("derby.engineType");
0: 		return (repSourceProp != null && repSourceProp.equals("4"));
0: 	}
0: 
0: 	public static int doNothingInt() throws Throwable
0: 	{
0: 		return 1;
0: 	}
0: 
0: 	public static void doNothing() throws Throwable
0: 	{}
0: 
0: 	public static int doConnCommitInt() throws Throwable
0: 	{
0: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
0: 		conn.commit();
0: 		return 1;
0: 	}
0: 
0: 	public static void doConnCommit() throws Throwable
0: 	{
0: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
0: 		conn.commit();
0: 	}
0: 			
0: 	public static void doConnRollback() throws Throwable
0: 	{
0: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
0: 		conn.rollback();
0: 	}
0: 
0: 	public static void doConnectionSetIsolation() throws Throwable
0: 	{
0: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
0: 		conn.setTransactionIsolation(conn.TRANSACTION_SERIALIZABLE);
0: 	}
0: 			
0: 	public static int doConnStmtIntNoRS(String text) throws Throwable
0: 	{
0: 		doConnStmtNoRS(text);
0: 		return 1;
0: 	}
0: 	public static void doConnStmtNoRS(String text) throws Throwable
0: 	{
0: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
0: 		Statement stmt = conn.createStatement();
0: 		stmt.execute(text);
0: 	}
0: 
0: 	public static int doConnStmtInt(String text) throws Throwable
0: 	{
0: 		doConnStmt(text);
0: 		return 1;
0: 	}
0: 	public static void doConnStmt(String text) throws Throwable
0: 	{
0: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
0: 		Statement stmt = conn.createStatement();
0: 		if (stmt.execute(text))
0: 		{
0: 			ResultSet rs = stmt.getResultSet();
0: 			while (rs.next())
0: 			{}
0: 			rs.close();
0: 		}
0: 		stmt.close();
0: 		conn.close();
0: 	}
0: 
0: 	public static void doConnStmt(String text, boolean targetOnly) throws Throwable
0: 	{
0: 		if (isReplicationTarget() == targetOnly)
0: 		{
0: 			System.out.println("Trigger Executing: "+text);
0: 			doConnStmt(text);
0: 		}
0: 	}
0: 
0: 	public static void workUnitFires() throws Throwable
0: 	{
0: 		System.out.println((isReplicationTarget() ? 
0: 						"TARGET: workUnitFires" : isReplicationSource() ?
0: 								"SOURCE: workUnitFires" : 
0: 								"<error, not in rep context?!?>"));
0: 	}
0: 
0: 	public static String printTriggerInfo() throws Throwable
0: 	{
0: 		TriggerExecutionContext tec = Factory.getTriggerExecutionContext();
0: 		int eventType = tec.getEventType();
0: 		String eventName;
0: 
0: 		switch (eventType)
0: 		{
0: 			case TriggerExecutionContext.UPDATE_EVENT: 
0: 					eventName = "UPDATE";
0: 					break;
0: 
0: 			case TriggerExecutionContext.DELETE_EVENT: 
0: 					eventName = "DELETE";
0: 					break;
0: 
0: 			case TriggerExecutionContext.INSERT_EVENT: 
0: 					eventName = "INSERT";
0: 					break;
0: 			default:
0: 				throw new Throwable("unexpected event type: "+eventType);
0: 		}			
0: 
0: 		StringBuffer strbuf = new StringBuffer("TriggerInformation\n------------------\n");
0: 		strbuf.append("getEventStatetmentText(): "+tec.getEventStatementText());
0: 		strbuf.append("\ngetEventType(): "+eventName);
0: 		strbuf.append("\ngetModifiedColumns(): {");
0: 
0: 		String[] modifiedCols = tec.getModifiedColumns();
0: 		if (modifiedCols == null)
0: 		{
0: 			strbuf.append(" <all> }");
0: 		}
0: 		else
0: 		{
0: 			for (int i = 0; i < modifiedCols.length; i++)
0: 			{
0: 				if (i > 0)
0: 					strbuf.append(", ");
0: 				strbuf.append(modifiedCols[i]);
0: 			}
0: 			strbuf.append("}");
0: 		}
0: 		strbuf.append("\n");
0: 		strbuf.append(getModifiedColumnsCheckInfo(tec));
0: 		System.out.println(strbuf.toString());
0: 		printTriggerChanges();
0: 		return "";
0: 	}
0: 
0: 	private static String getModifiedColumnsCheckInfo(TriggerExecutionContext tec) throws Throwable
0: 	{
0: 		ResultSet rs = (tec.getNewRowSet() == null) ?
0: 					tec.getOldRowSet() :
0: 					tec.getNewRowSet();
0: 
0: 		ResultSetMetaData rsmd = rs.getMetaData();
0: 
0: 		// Get the number of columns in the result set
0: 		int numCols = rsmd.getColumnCount();
0: 
0: 		StringBuffer msg = new StringBuffer("wasColumnModified() on each column\n\t");
0: 		for (int i=1; i<=numCols; i++) 
0: 		{
0: 			if (i > 1) 
0: 			{
0: 				msg.append("\n\t");
0: 			}
0: 			msg.append(rsmd.getColumnLabel(i));
0: 			msg.append(":\t");
0: 			boolean wasModified = tec.wasColumnModified(rsmd.getColumnLabel(i));
0: 			if (wasModified != tec.wasColumnModified(i))
0: 			{
0: 				msg.append("ERROR: tec.wasColumnModifed(String) = "+wasModified);
0: 				msg.append("and tec.wasColumnModifed(int) = "+(!wasModified));
0: 			}
0: 			else
0: 			{
0: 				msg.append(wasModified);
0: 			}
0: 		}
0: 		msg.append("\n");
0: 		return msg.toString();
0: 	}
0: 
0: 	// used for performance numbers
0: 	public static void zipThroughTriggerResultSets() throws SQLException
0: 	{
0: 		TriggerExecutionContext tec = Factory.getTriggerExecutionContext();
0: 		zipThroughRs(tec.getOldRowSet());
0: 		zipThroughRs(tec.getNewRowSet());
0: 	}
0: 
0: 	// used for performance numbers
0: 	static void zipThroughRs(ResultSet s) throws SQLException
0: 	{
0: 		if (s == null)
0: 			return;
0: 		
0: 		while (s.next()) ;
0: 	}
0: 
0: 	public static void barfOnInsertEquals(int value) throws Throwable
0: 	{
0: 		TriggerExecutionContext tec = Factory.getTriggerExecutionContext();
0: 		ResultSet rs = tec.getNewRowSet();
0: 		while (rs.next())
0: 		{
0: 			if (rs.getInt(1) == value)
0: 			{
0: 				throw new SQLException("barfing because of "+value+" in BeforeResultSet","38001");
0: 			}
0: 		}
0: 	}
0: 
0: 	private static void printTriggerChanges() throws Throwable
0: 	{
0: 		TriggerExecutionContext tec = Factory.getTriggerExecutionContext();
0: 		System.out.println("BEFORE RESULT SET");
0: 		dumpRS(tec.getOldRowSet());
0: 		System.out.println("\nAFTER RESULT SET");
0: 		dumpRS(tec.getNewRowSet());
0: 	}
0: 
0: 	// lifted from the metadata test	
0: 	private static void dumpRS(ResultSet s) throws SQLException 
0: 	{
0: 		if (s == null)
0: 		{
0: 			System.out.println("<NULL>");
0: 			return;
0: 		}
0: 
0: 		ResultSetMetaData rsmd = s.getMetaData();
0: 
0: 		// Get the number of columns in the result set
0: 		int numCols = rsmd.getColumnCount();
0: 
0: 		if (numCols <= 0) 
0: 		{
0: 			System.out.println("(no columns!)");
0: 			return;
0: 		}
0: 
0: 		StringBuffer heading = new StringBuffer("\t ");
0: 		StringBuffer underline = new StringBuffer("\t ");
0: 
0: 		int len;
0: 		// Display column headings
0: 		for (int i=1; i<=numCols; i++) 
0: 		{
0: 			if (i > 1) 
0: 			{
0: 				heading.append(",");
0: 				underline.append(" ");
0: 			}
0: 			len = heading.length();
0: 			heading.append(rsmd.getColumnLabel(i));
0: 			len = heading.length() - len;
0: 			for (int j = len; j > 0; j--)
0: 			{
0: 				underline.append("-");
0: 			}
0: 		}
0: 		System.out.println(heading.toString());
0: 		System.out.println(underline.toString());
0: 		
0: 	
0: 		StringBuffer row = new StringBuffer();
0: 		// Display data, fetching until end of the result set
0: 		while (s.next()) 
0: 		{
0: 			row.append("\t{");
0: 			// Loop through each column, getting the
0: 			// column data and displaying
0: 			for (int i=1; i<=numCols; i++) 
0: 			{
0: 				if (i > 1) row.append(",");
0: 				row.append(s.getString(i));
0: 			}
0: 			row.append("}\n");
0: 		}
0: 		System.out.println(row.toString());
0: 		s.close();
0: 	}
0: 
0: 	// WARNING: will deadlock unless on a separate
0: 	// connection
0: 	public static void notifyDMLDone() throws Throwable
0: 	{
0: 		if (triggerThread == null)
0: 		{
0: 			System.out.println("ERROR: no triggerThread object, has beginInvalidRefToTECTest() been executed?");
0: 		}
0: 		else
0: 		{
0: 			triggerThread.goForIt();
0: 			while (!triggerThread.done())
0: 			{
0: 				try {Thread.sleep(1000L); } catch (InterruptedException e) {}
0: 			}
0: 			triggerThread = null;
0: 		}
0: 	}
0: 
0: 	public static void simpleTrigger() throws Throwable
0: 	{
0: 		Long ai;
0: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
0: 		
0: 		PreparedStatement lastai = conn.prepareStatement("values org.apache.derby.iapi.db.ConnectionInfo::lastAutoincrementValue('APP', 'TRIGTEST', 'S1') ");
0: 		
0: 		ResultSet rs = lastai.executeQuery();
0: 		rs.next();
0: 		ai = (Long)rs.getObject(1);
0: 		rs.close();
0: 		System.out.println("autoincrement value is " + ai);
0: 	}
0: 	/**
0: 	 */
0: 	public static void insertIntoTab1(Integer level)
0: 	      throws Throwable	
0: 	{
0: 		Long entry, exit;
0: 		int levelValue = level.intValue();
0: 		long entryValue, exitValue;
0: 
0: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
0: 		
0: 		PreparedStatement lastai = conn.prepareStatement("values (org.apache.derby.iapi.db.ConnectionInfo::lastAutoincrementValue('APP','TAB1','S1'))");
0: 		ResultSet rs = lastai.executeQuery();
0: 		rs.next();
0: 		entry = (Long)rs.getObject(1);
0: 		rs.close();
0: 
0: 		System.out.println("coming in with level = " + levelValue + 
0: 						   " and autoincrement = " + entry.longValue());
0: 		
0: 		if (levelValue == 3)
0: 			return;
0: 
0: 		
0: 		PreparedStatement ps = 
0: 			conn.prepareStatement("insert into tab1 (lvl) values (?)");
0: 		// insert one higher value into tab1.
0: 		ps.setInt(1, levelValue + 1);
0: 		ps.execute();
0: 		
0: 		rs = lastai.executeQuery();
0: 		rs.next();
0: 		exit = (Long)rs.getObject(1);
0: 		rs.close();
0: 
0: 		// When we get out of this trigger, subsequent firings of the trigger by the
0: 		// insert statement in this routine shouldn't be returned by
0: 		// lastautoincrement value.
0: 
0: 		System.out.println("going out with level = " + levelValue + 
0: 						   " and autoincrement = " + exit.longValue());
0: 
0: 	}
0: 
0: 
0: 	public static void aiWorkUnit(String s)
0: 	       	      throws Throwable	
0: 	{
0: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
0: 		String query = "insert into watab (s) values (?)";
0: 		PreparedStatement ps = conn.prepareStatement(query);
0: 		System.out.println("in work unit with s=" + s);
0: 		ps.setString(1, s);
0: 		ps.execute();
0: 	}
0: 
0: 	public static String beginInvalidRefToTECTest() throws Throwable
0: 	{
0: 		triggerThread = new TriggerThread();
0: 		triggerThread.start();
0: 		return "";
0: 	}
0: 
0: 	public static long returnPrimLong(long  x)
0: 	{
0: 		return x;
0: 	}
0: 
0: 	public static Long returnLong(Long x)
0: 	{
0: 		return x;
0: 	}
0: 
0: 	// used to test binding
0: 	public static void allTypesMethodPrimitive
0: 	(
0: 		int 		i,
0: 		byte		by,	
0: 		short		s,
0: 		long		l,
0: 		String		s1,
0: 		String		s2,
0: 		String		s3,
0: 		boolean		bl,
0: 		double		db,
0: 		float		f1,
0: 		double		db2,
0: 		Date		dt,
0: 		Time		t,
0: 		Timestamp	ts,
0: 		byte[]		b1,
0: 		byte[]		b2,
0: 		byte[]		b3,
0: 		double		bd1,
0: 		double		bd2,
0: 		BigInteger	bi
0: 	)
0: 	{
0: 	}
0: 
0: 	public static void allTypesMethodObject
0: 	(
0: 		Integer		i,
0: 		Integer		by,	
0: 		Integer		s,
0: 		Long		l,
0: 		String		s1,
0: 		String		s2,
0: 		String		s3,
0: 		Boolean		bl,
0: 		Double		db,
0: 		Float		f1,
0: 		Double		db2,
0: 		Date		dt,
0: 		Time		t,
0: 		Timestamp	ts,
0: 		byte[]		b1,
0: 		byte[]		b2,
0: 		byte[]		b3,
0: 		BigDecimal	bd1,
0: 		BigDecimal	bd2,
0: 		BigInteger	bi
0: 	)
0: 	{
0: 	}
0: 
0: }
0: 
0: // class for testing valid tec accesses	
0: class TriggerThread extends Thread
0: {	
0: 	private TriggerExecutionContext tec;
0: 	private ResultSet rs;
0: 	private boolean start; 
0: 	private boolean done; 
0: 
0: 	public TriggerThread() throws Throwable
0: 	{
0: 		this.tec = Factory.getTriggerExecutionContext();
0: 		if (tec == null)
0: 		{
0: 			System.out.println("ERROR: no tec found, no trigger appears to be active");
0: 			return;
0: 		}
0: 	
0: 		this.rs = (tec.getNewRowSet() == null) ?
0: 			tec.getOldRowSet() :
0: 			tec.getNewRowSet();
0: 	}
0: 
0: 	public void goForIt()
0: 	{
0: 		start = true;
0: 	}
0: 
0: 	public boolean done()
0: 	{
0: 		return done;
0: 	}
0: 
0: 	public void run() 
0: 	{
0: 		boolean gotException = false;
0: 	
0: 		int i;	
0: 		for (i = 0; !start && i < 1000; i++)
0: 		{
0: 			try {Thread.sleep(50L); } catch (InterruptedException e) {}
0: 		} 
0: 		if (i == 1000)
0: 		{
0: 			System.out.println("ERROR: start never received");
0: 			return;
0: 		}
0: 		// let the other thread get to its pause point
0: 		try {Thread.sleep(5000L); } catch (InterruptedException e) {}
0: 
0: 		System.out.println("...nested thread running using expired tec");
0: 		try
0: 		{
0: 			System.out.println("...trying to loop through stale result set");
0: 			Triggers.zipThroughRs(rs);
0: 		} catch (SQLException e)
0: 		{
0: 			gotException = true;	
0: 			System.out.println("Got expected exception: "+e);
0: 		}
0: 		if (!gotException)
0: 		{
0: 			System.out.println("ERROR: no exception when trying to do next on stale ResultSet");
0: 		}
0: 		gotException = false;
0: 
0: 		try
0: 		{	
0: 			tec.getNewRowSet();
0: 		} catch (SQLException e)
0: 		{
0: 			gotException = true;	
0: 			System.out.println("Got expected exception: "+e);
0: 		}
0: 
0: 		if (!gotException)
0: 		{
0: 			System.out.println("ERROR: getNewRowSet() didn't throw an exception on stale tec");
0: 		}
0: 
0: 		gotException = false;
0: 
0: 		try
0: 		{	
0: 			tec.getOldRowSet();
0: 		} catch (SQLException e)
0: 		{
0: 			gotException = true;	
0: 			System.out.println("Got expected exception: "+e);
0: 		}
0: 
0: 		if (!gotException)
0: 		{
0: 			System.out.println("ERROR: getOldRowSet() didn't throw an exception on stale tec");
0: 		}
0: 
0: 		// signal that we are done
0: 		done = true;
0: 	}
0: }
commit:c1c71ef
/////////////////////////////////////////////////////////////////////////
0:    Derby - Class org.apache.derbyTesting.functionTests.util.Triggers
0: 
0:    Copyright 1999, 2004 The Apache Software Foundation or its licensors, as applicable.
0: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
0: 
0:       http://www.apache.org/licenses/LICENSE-2.0
0: 
0:    Unless required by applicable law or agreed to in writing, software
0:    distributed under the License is distributed on an "AS IS" BASIS,
0:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:    See the License for the specific language governing permissions and
0:    limitations under the License.
commit:cb1ca12
/////////////////////////////////////////////////////////////////////////
0: {
============================================================================