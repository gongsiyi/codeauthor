1:281df80: /*
3:281df80: 
1:281df80:    Derby - Class org.apache.derbyBuild.jirasoap.FilteredIssueLister
1:281df80: 
1:281df80:    Licensed to the Apache Software Foundation (ASF) under one or more
1:281df80:    contributor license agreements.  See the NOTICE file distributed with
1:281df80:    this work for additional information regarding copyright ownership.
1:281df80:    The ASF licenses this file to you under the Apache License, Version 2.0
1:281df80:    (the "License"); you may not use this file except in compliance with
1:281df80:    the License.  You may obtain a copy of the License at
1:281df80: 
1:281df80:       http://www.apache.org/licenses/LICENSE-2.0
1:281df80: 
1:281df80:    Unless required by applicable law or agreed to in writing, software
1:281df80:    distributed under the License is distributed on an "AS IS" BASIS,
1:281df80:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:281df80:    See the License for the specific language governing permissions and
1:281df80:    limitations under the License.
1:281df80: 
1:281df80:  */
1:281df80: 
1:281df80: package org.apache.derbyBuild.jirasoap;
1:281df80: 
1:281df80: import java.io.BufferedWriter;
1:281df80: import java.io.File;
1:281df80: import java.io.FileOutputStream;
1:281df80: import java.io.IOException;
1:281df80: import java.io.OutputStreamWriter;
1:281df80: import java.io.PrintStream;
1:281df80: 
1:281df80: import java.rmi.RemoteException;
1:281df80: 
1:281df80: import java.util.ArrayList;
1:281df80: import java.util.Calendar;
1:281df80: import java.util.Collections;
1:281df80: import java.util.Comparator;
1:281df80: import java.util.GregorianCalendar;
1:281df80: import java.util.Iterator;
1:281df80: import java.util.List;
1:281df80: 
1:281df80: import javax.xml.rpc.ServiceException;
1:281df80: 
1:281df80: /**
1:281df80:  * Client talking to the Apache JIRA instance to retrieve and derive information
1:281df80:  * required to generate releases notes for a Derby release.
1:281df80:  * <p>
1:281df80:  * The purpose of this client is to carry out some of the tasks a release
1:281df80:  * manager has to do when generating the release notes.
1:281df80:  */
1:281df80: public class FilteredIssueLister {
1:281df80: 
1:281df80:     /** System property for specifying the ancestor cutoff threshold. */
1:281df80:     private static final String ANCESTOR_CUTOFF_PROP = "ancestorCutoff";
1:281df80:     private static final String DEFAULT_ANCESTOR_CUTOFF = "10.3.3.0";
1:281df80:     /** System property for turning on reporting of disqualified issues. */
1:281df80:     private static final String REPORT_DISQUALIFICATIONS_PROP =
1:281df80:             "reportDisqualifications";
1:281df80:     /** Help text for command line invocation. */
1:281df80:     private static final String USAGE =
1:281df80: "-- Apache Derby JIRA SOAP client --\n\n" +
1:281df80: "The main purpose of this client is to fetch the required information from\n" +
1:281df80: "JIRA, such that the release manager can generate the release notes.\n" +
1:281df80: "This tool does not generate the release notes, but provides some of the\n" +
1:281df80: "information for the tool doing that.\n\n" +
1:281df80: "Primary usage:\n" +
1:281df80: "  o <USER> <PASSWORD> <VERSION> <FILTERID> <DESTINATION_FILE> [ANCESTRY]\n" +
1:281df80: "    generates a list of fixed issues for the specified release version,\n" +
1:281df80: "    which can be processed by the ReleaseNotesGenerator tool.\n" +
1:281df80: "    Note that the release ancestry should be verified. The ancestry is\n" +
1:281df80: "    printed to standard out and into the generated file. You can also\n" +
1:281df80: "    check up-front by running the 'ancestors' mode (see 'Secondary usage').\n"+
1:281df80: "    If incorrect, re-run and specify the release ancestry manually.\n" +
1:281df80: "\n" +
1:281df80: "Secondary usage:\n" +
1:281df80: "  o <USER> <PASSWORD> ancestors <VERSION>\n" +
1:281df80: "    prints the ancestors of the specified version\n"+
1:281df80: "    (only released versions can be ancestors)\n" +
1:281df80: "  o <USER> <PASSWORD> releases\n" +
1:281df80: "    prints all Derby releases, sorted by release date\n"+
1:281df80: "\n" +
1:281df80: "Argument values:\n" +
1:281df80: "  o VERSION\n" +
1:281df80: "      Derby version string, i.e. 10.6.2.1\n" +
1:281df80: "  o FILTERID\n" +
1:695493d: "      JIRA id, only digits allowed.\n" +
1:695493d: "      If '0' (zero), a JQL query will be generated instead of using an\n" +
1:695493d: "      existing (manually created) JIRA filter.\n" +
1:281df80: "  o ANCESTRY\n" +
1:281df80: "      if necessary, the release ancestry can be overridden by specifying\n " +
1:281df80: "      the ancestors by version manually. Valid values:\n" +
1:281df80: "        - derive (the default)\n" +
1:281df80: "        - ignore (don't filter issues)\n" +
1:281df80: "        - VERSION[,VERSION]* (manually specified)\n" +
1:281df80: "\n" +
1:281df80: "System properties:\n" +
1:281df80: "  o " + ANCESTOR_CUTOFF_PROP + "\n" +
1:281df80: "    modify the value of the cutoff version\n" +
1:281df80: "    (default is 10.3.3.0)\n" +
1:281df80: "  o " + REPORT_DISQUALIFICATIONS_PROP + "\n" +
1:281df80: "    if set to true, disqualified issues will be printed to standard out\n" +
1:281df80: "    (default is false)\n" +
1:281df80: "\n";
1:281df80: 
1:281df80:     /** Apache Derby project identifier in JIRA. */
1:281df80:     private static final String DERBY_PROJECT = "DERBY";
1:281df80:     /** Custom Derby flag used in JIRA. */
1:281df80:     private static final String FIELD_RELEASE_NOTE = "Release Note Needed";
1:281df80:     /**
1:281df80:      * Name of the file containing release notes in JIRA. This is by
1:281df80:      * Apache Derby community convention.
1:281df80:      */
1:281df80:     private static final String RELEASE_NOTE_NAME = "releaseNote.html";
1:695493d:     /** Constant used to choose using JQL over an existing filter. */
1:695493d:     private static final int GENERATE_JQL = 0;
1:281df80: 
1:281df80:     private PrintStream logOut = new PrintStream(System.out);
1:281df80:     private JiraSoapService jiraSoapService;
1:281df80:     /** JIRA user to log in as. */
1:281df80:     private String user;
1:281df80:     /** JIRA authentication token. */
1:281df80:     private String auth;
1:281df80:     /** Cached version objects. */
1:281df80:     private DerbyVersion[] allVersions;
1:281df80:     /** The point at which we stop listing ancestors for a release. */
1:0a218e3:     private final DerbyVersion ancestorCutoff;
1:281df80:     /** Tells if disqualified issues should be reported. */
1:281df80:     private final boolean reportDisqualifiedIssues;
1:281df80:     /** Tells if the release ancestry has been overriden by the user. */
1:281df80:     private boolean ancestryOverridden;
1:281df80: 
1:281df80:     /**
1:281df80:      * Creates a new JIRA client.
1:281df80:      *
1:281df80:      * @param username JIRA user to log in as
1:281df80:      * @param cred JIRA password
1:281df80:      * @throws RemoteException if the login fails for some unexpected reason, or
1:281df80:      *      if fetching the version list fails
1:281df80:      * @throws ServiceException if obtaining the JIRA service fails
1:281df80:      * @throws RuntimeException if the JIRA credentials are invalid
1:281df80:      */
1:281df80:     public FilteredIssueLister(String username, String cred)
1:281df80:             throws RemoteException, ServiceException {
1:281df80:         JiraSoapServiceService jiraSoapServiceLocator =
1:281df80:                 new JiraSoapServiceServiceLocator();
1:281df80:         log("getting JIRA service");
1:281df80:         jiraSoapService = jiraSoapServiceLocator.getJirasoapserviceV2();
1:281df80:         log("logging in as '" + username + "'");
2:281df80:         try {
1:281df80:             auth = jiraSoapService.login(username, cred);
1:281df80:         } catch (RemoteAuthenticationException rae) {
1:281df80:             // Give a friendlier error message for this case.
1:281df80:             throw new RuntimeException(
1:281df80:                     "JIRA login failed. Cause:\n" + rae.toString());
4:281df80:         }
1:281df80:         user = username;
1:281df80:         log("fetching versions");
1:281df80:         RemoteVersion[] jiraVer =
1:281df80:                 jiraSoapService.getVersions(auth, DERBY_PROJECT);
1:281df80:         allVersions = new DerbyVersion[jiraVer.length];
1:281df80:         for (int i=0; i < jiraVer.length; i++) {
1:281df80:             allVersions[i] = new DerbyVersion(jiraVer[i]);
1:281df80:         }
1:281df80:         // Give a better error message if user-specified cutoff value is bad.
1:281df80:         try {
1:0a218e3:             ancestorCutoff = getVersion(System.getProperty(
1:281df80:                 ANCESTOR_CUTOFF_PROP, DEFAULT_ANCESTOR_CUTOFF));
1:281df80:         } catch (IllegalArgumentException iae) {
2:281df80:             throw new IllegalArgumentException(
1:281df80:                     "invalid ancestor cutoff version", iae);
1:281df80:         }
1:281df80:         reportDisqualifiedIssues =
1:281df80:                 Boolean.getBoolean(REPORT_DISQUALIFICATIONS_PROP);
1:281df80:     }
1:281df80: 
1:281df80:     /** Constructor for testing, where the Derby versions can be specified
1:281df80:      * manually.
1:281df80:      *
1:281df80:      * @param versions format is {{"major.minor.fixpack.point", "YYYY-MM-DD"}}
1:281df80:      */
1:281df80:     FilteredIssueLister(String username, String cred, String[][] versions)
1:281df80:             throws RemoteException, ServiceException {
1:281df80:         JiraSoapServiceService jiraSoapServiceLocator =
1:281df80:                 new JiraSoapServiceServiceLocator();
1:281df80:         log("getting JIRA service");
1:281df80:         jiraSoapService = jiraSoapServiceLocator.getJirasoapserviceV2();
1:281df80:         log("logging in as '" + username + "'");
1:281df80:         try {
1:281df80:             auth = jiraSoapService.login(username, cred);
1:281df80:         } catch (RemoteAuthenticationException rae) {
1:281df80:             // Give a friendlier error message for this case.
1:281df80:             throw new RuntimeException(
1:281df80:                     "JIRA login failed. Cause:\n" + rae.toString());
1:281df80:         }
1:281df80:         user = username;
1:281df80:         allVersions = new DerbyVersion[versions.length];
1:0a218e3:         // Expected format: release version, release date (YYYY-MM-DD, or null)
1:281df80:         for (int i=0; i < versions.length; i++) {
1:281df80:             allVersions[i] = new DerbyVersion(
1:0a218e3:                     versions[i][0], versions[i][1] == null
1:0a218e3:                                             ? DerbyVersion.NOT_RELEASED
1:0a218e3:                                             : parseDate(versions[i][1]));
1:281df80:         }
1:281df80:         // Give a better error message if user-specified cutoff value is bad.
1:281df80:         try {
1:0a218e3:             ancestorCutoff = getVersion(System.getProperty(
1:281df80:                 ANCESTOR_CUTOFF_PROP, DEFAULT_ANCESTOR_CUTOFF));
1:281df80:         } catch (IllegalArgumentException iae) {
1:281df80:             throw new IllegalArgumentException(
1:0a218e3:                     "invalid ancestor cutoff version", iae);
1:281df80:         }
1:281df80:         reportDisqualifiedIssues =
1:281df80:                 Boolean.getBoolean(REPORT_DISQUALIFICATIONS_PROP);
1:281df80:     }
1:281df80: 
1:281df80:     /**
1:281df80:      * Generates a list of Derby JIRA issues addressed by the target release
1:281df80:      * version and writes these to a file for further processing.
1:281df80:      * <p>
1:281df80:      * <b>Important:</b> Although some sanity checks are performed, it is
1:281df80:      * crucial that the manually created filter is set up correctly. If the
1:281df80:      * filter misses issues addressed by the release, they will not make it
1:281df80:      * into the generated release notes. Short description:
1:281df80:      * <ul>
1:281df80:      *  <li>include bugs and improvements</li>
1:281df80:      *  <li>include issues resolved as Fixed</li>
1:281df80:      *  <li>include issues marked as Resolved or Closed</li>
1:281df80:      *  <li>include all release candidates in the fix version field
1:281df80:      *      (if not already released)</li>
1:281df80:      * </ul>
1:281df80:      *
1:281df80:      * @param version the target release version
1:281df80:      * @param filterId the JIRA filter id
1:281df80:      * @param destFile output file for the issue report
1:281df80:     * @throws IOException if writing to the output file fails
1:281df80:      */
1:281df80:     public void prepareReleaseNotes(String version, long filterId,
1:281df80:                                     String destFile,
1:281df80:                                     String[] ancestorVersions)
1:695493d:             throws IOException {
1:281df80:         DerbyVersion releaseVersion = getVersion(version);
1:281df80:         DerbyVersion[] ancestors = null;
1:281df80:         if (ancestorVersions == null) {
1:281df80:             // Obtain a list of ancestors, used to disqualify JIRA issues
1:281df80:             // matched by the JIRA filter.
1:281df80:             ancestryOverridden = false;
1:281df80:             ancestors = getAncestors(releaseVersion);
2:281df80:         } else {
1:281df80:             ancestryOverridden = true;
1:281df80:             ancestors = new DerbyVersion[ancestorVersions.length];
1:281df80:             for (int i=0; i < ancestorVersions.length; i++) {
1:281df80:                 ancestors[i] = getVersion(ancestorVersions[i]);
1:281df80:             }
1:281df80:         }
1:281df80:         persistFilterResult(releaseVersion, filterId, destFile, ancestors);
1:281df80:     }
1:281df80: 
1:281df80:     /**
1:281df80:      * Prints the list of ancestors, i.e. earlier releases down the release
1:281df80:      * chain, for specified Derby version.
1:281df80:      * <p>
1:281df80:      * Note that only released versions are considered to be ancestors.
1:281df80:      *
1:281df80:      * @param parentVersion the version to start at (released or not)
1:281df80:      */
1:281df80:     public void printAncestors(String parentVersion) {
1:281df80:         DerbyVersion parent = getVersion(parentVersion);
1:0a218e3:         if (parent.compareTo(ancestorCutoff) < 0) {
1:281df80:             throw new IllegalArgumentException(
1:281df80:                     "specified version " + parentVersion +
1:281df80:                     " is less than the ancestor cut-off version: " +
1:0a218e3:                     ancestorCutoff.getVersion());
1:281df80:         }
1:281df80:         DerbyVersion[] ancestors = getAncestors(parent);
1:281df80:         System.out.println("--- Ancestors for version " + parentVersion + " (" +
1:281df80:                 (parent.isReleased() ? "released)" : "unreleased)"));
1:281df80:         for (int i=0; i < ancestors.length; i++) {
1:0a218e3:             System.out.println(ancestors[i]);
1:281df80:         }
1:281df80:         // Special case when there is no ancestor.
1:281df80:         if (ancestors.length == 0) {
1:281df80:             System.out.println("<no ancestors found in JIRA>");
1:281df80:         }
1:0a218e3:         System.out.println("(cutoff=" + ancestorCutoff.getVersion() + ")");
1:281df80:     }
1:281df80: 
1:281df80:     /**
1:281df80:      * Prints all Derby releases.
1:281df80:      */
1:281df80:     public void printReleases() {
1:281df80:         ArrayList releases = new ArrayList();
1:281df80:         for (int i=0; i < allVersions.length; i++) {
1:281df80:             DerbyVersion dv = allVersions[i];
1:281df80:             if (dv.isReleased()) {
1:281df80:                 releases.add(dv);
1:281df80:             }
1:281df80:         }
1:281df80:         Collections.sort(releases, new Comparator() {
1:281df80: 
1:281df80:             public int compare(Object o1, Object o2) {
1:281df80:                 Long release1 = new Long(
1:281df80:                         ((DerbyVersion)o1).getReleaseDateMillis());
1:281df80:                 Long release2 = new Long(
1:281df80:                         ((DerbyVersion)o2).getReleaseDateMillis());
1:281df80:                 return release1.compareTo(release2);
1:281df80:             }
1:281df80:         });
1:281df80:         Collections.reverse(releases);
1:281df80:         System.out.println("--- Derby releases");
1:281df80:         Iterator relIter = releases.iterator();
1:281df80:         while (relIter.hasNext()) {
1:0a218e3:             System.out.println(relIter.next());
1:281df80:         }
1:281df80:     }
1:281df80: 
1:281df80:     /**
1:281df80:      * Releases resources associated with the client.
1:281df80:      *
1:281df80:      * @throws RemoteException if logging out fails
1:281df80:      */
1:281df80:     public void destroy()
1:281df80:             throws RemoteException {
1:281df80:         jiraSoapService.logout(auth);
1:281df80:         auth = null;
1:281df80:         jiraSoapService = null;
1:281df80:         allVersions = null;
1:281df80:     }
1:281df80: 
1:281df80:     /**
1:281df80:      * Executes a JIRA filter and writes the matching JIRA issues to file.
1:281df80:      *
1:281df80:      * @param targetVersion targetted release version
1:281df80:      * @param filterId JIRA filter id used to obtain the relevant issues
1:281df80:      * @param destFile destination file
1:281df80:      * @param excludeFixVersions exclude issues which have been fixed on one
1:281df80:      *      of the exclude versions (also called ancestry chain)
1:281df80:      * @return The number of filters written to the destination file.
1:281df80:      * @throws IOException if writing to the output file fails
1:281df80:      */
1:281df80:     private int persistFilterResult(DerbyVersion targetVersion, long filterId,
1:281df80:                                    String destFile,
1:281df80:                                    DerbyVersion[] excludeFixVersions)
2:281df80:             throws IOException {
1:281df80:         // Extract the version string from the versions to exclude.
1:281df80:         int size = excludeFixVersions == null ? 0 : excludeFixVersions.length;
1:281df80:         final ArrayList excludeList = new ArrayList(size);
1:281df80:         for (int i=0; i < size; i++) {
1:281df80:             excludeList.add(excludeFixVersions[i].getVersion());
1:281df80:         }
1:281df80: 
1:281df80:         BufferedWriter out = new BufferedWriter(new OutputStreamWriter(
1:281df80:                 new FileOutputStream(destFile), "UTF-8"));
1:281df80:         out.write("// Produced on " + new java.util.Date().toString());
2:281df80:         out.newLine();
1:281df80:         out.write("// Release version: " + targetVersion.getVersion());
1:281df80:         out.newLine();
1:281df80:         out.write("// Previous release: " + excludeFixVersions[0].getVersion());
1:281df80:         out.newLine();
1:281df80:         out.write("// " + (ancestryOverridden ? "Overridden" : "Derived"));
1:281df80:         out.write(" ancestry chain");
1:281df80:         out.newLine();
1:281df80:         for (int i=0; i < excludeFixVersions.length; i++) {
1:281df80:             out.write("//   " + excludeFixVersions[i].getVersion());
1:281df80:             out.newLine();
1:281df80:         }
1:281df80:         RemoteIssue[] issues = null;
1:695493d:         if (filterId == GENERATE_JQL) {
1:846080f:             issues = execJiraJQLQuery( out, auth, targetVersion, excludeFixVersions );
1:695493d:         } else {
1:695493d:             issues = execJiraFilterQuery(out, auth, filterId);
1:281df80:         }
1:695493d:         log("persisting issues (" + issues.length + " candidate issues)");
1:695493d:         out.write("// Candidate issue count: " + issues.length);
1:281df80:         out.newLine();
1:281df80:         int count = 0;
1:281df80:         int issuesWithReleaseNote = 0;
1:281df80:         // Adhere to this very simple format.
1:281df80:         // --- (separator)
1:281df80:         // DERBY-XXXX
1:281df80:         // SUMMARY
1:281df80:         // FIX_VERSION[,FIX_VERSION]*
1:281df80:         // RELEASENOTE_ATTACHMENT_ID|null|missing
1:281df80:         // ("null" if not existing, "missing" if missing)
1:281df80:         for (int i=0; i < issues.length; i++) {
1:281df80:             RemoteIssue ri = issues[i];
1:281df80:             // This will throw exception if the target version isn't in the list
1:281df80:             // of fix versions, and return null if the issue has been dis-
1:281df80:             // qualified because it has already been fixed in an ancestor.
1:281df80:             String fixVersions = stringifyAndCheckFixVersions(ri.getKey(),
1:281df80:                     ri.getFixVersions(), excludeList, targetVersion);
1:281df80:             if (fixVersions == null) {
1:281df80:                 continue;
1:281df80:             }
1:281df80:             // Persist the issue (human readable/editable).
1:281df80:             out.write("---");
1:281df80:             out.newLine();
1:281df80:             // key
1:281df80:             out.write(ri.getKey());
1:281df80:             out.newLine();
1:281df80:             // summary
1:281df80:             out.write(ri.getSummary());
1:281df80:             out.newLine();
1:281df80:             // fix versions
1:281df80:             out.write(fixVersions);
1:281df80:             out.newLine();
1:281df80:             // release note flag and affects existing applications flag
1:281df80:             RemoteCustomFieldValue[] fieldValues = ri.getCustomFieldValues();
1:281df80:             boolean releaseNoteNeeded = hasCustomField(
1:281df80:                     FIELD_RELEASE_NOTE, fieldValues);
1:281df80:             // release note attachemnt id
1:281df80:             if (hasReleaseNote(ri)) {
1:281df80:                 issuesWithReleaseNote++;
1:281df80:                 long latest = 0;
1:281df80:                 RemoteAttachment[] attachments =
1:281df80:                         jiraSoapService.getAttachmentsFromIssue(
1:281df80:                                                             auth, ri.getKey());
1:281df80:                 // Find the latest attachment, just use the one with the
1:281df80:                 // highest id.
1:281df80:                 for (int a=0; a < attachments.length; a++) {
1:281df80:                     String name = attachments[a].getFilename();
1:281df80:                     long id = Long.parseLong(attachments[a].getId());
1:281df80:                     if (name.equals(RELEASE_NOTE_NAME)) {
1:281df80:                         latest = Math.max(latest, id);
1:281df80:                     }
1:281df80:                 }
1:281df80:                 out.write(Long.toString(latest));
1:281df80:             } else {
1:281df80:                 if (releaseNoteNeeded) {
1:281df80:                     out.write("missing");
1:281df80:                 } else {
1:281df80:                     out.write("null");
1:281df80:                 }
1:281df80:             }
1:281df80:             out.newLine();
1:281df80:             count++;
1:281df80:         }
1:281df80: 
1:281df80:         // Write some more status
1:281df80:         out.write("// Issues written: " + count);
1:281df80:         out.newLine();
1:281df80:         out.write("// Issues disqualified: ");
1:281df80:         if (excludeFixVersions == null) {
1:281df80:             out.write("disqualification disabled");
1:281df80:         } else {
1:281df80:             out.write(Integer.toString(issues.length - count));
1:281df80:         }
1:281df80:         out.newLine();
1:281df80:         out.write("// Issues with release note: " + issuesWithReleaseNote);
1:281df80:         out.newLine();
1:281df80:         out.close();
1:281df80: 
1:281df80:         // Log some basic information
1:281df80:         log("wrote " + count + " issues, " + issuesWithReleaseNote +
1:281df80:                 " with release notes, " + (issues.length - count) +
1:281df80:                 " issues disqualified");
1:0a218e3:         log("dump file: " + new File(destFile).getCanonicalPath());
1:281df80:         return count;
1:281df80:     }
1:281df80: 
1:281df80:     /**
1:281df80:      * Returns the version object for the specified Derby version.
1:281df80:      *
1:281df80:      * @param version target version
1:281df80:      * @return A version object.
1:281df80:      * @throws IllegalArgumentException if the specified version doesn't exist
1:281df80:      */
1:281df80:     private DerbyVersion getVersion(String version) {
1:281df80:         DerbyVersion match = null;
1:281df80:         for (int i=0; i < allVersions.length; i++) {
1:281df80:             if (version.equals(allVersions[i].getVersion())) {
1:281df80:                 match = allVersions[i];
1:281df80:             }
1:281df80:         }
1:281df80:         if (match == null) {
1:281df80:             throw new IllegalArgumentException(
1:281df80:                     "version '" + version + "' doesn't exist");
1:281df80:         }
1:281df80:         return  match;
1:281df80:     }
1:281df80: 
1:281df80:     /**
1:281df80:      * Computes the ancestors for the specified version.
1:281df80:      *
1:281df80:      * @param parent the initial parent version
1:281df80:      * @return A list of ancestors for the specified version.
1:281df80:      */
1:281df80:     private DerbyVersion[] getAncestors(DerbyVersion parent) {
1:281df80:         ArrayList ancestors = new ArrayList();
1:281df80:         DerbyVersion[] dv = getSortedAndFilteredReleases(parent);
1:0a218e3:         while (dv.length > 1 && dv[0].compareTo(ancestorCutoff) >= 0) {
1:281df80:             dv = getSortedAndFilteredReleases(dv[1]);
2:281df80:             ancestors.add(dv[0]);
1:281df80:         }
1:281df80:         dv = new DerbyVersion[ancestors.size()];
1:281df80:         ancestors.toArray(dv);
1:281df80:         return dv;
1:281df80:     }
1:281df80: 
1:281df80:     /**
1:281df80:      * Returns a list of sorted and filtered Derby releases.
1:281df80:      * <p>
1:281df80:      * If a target release is specified, all later releases will be filtered
1:281df80:      * out. The filtering happens at two levels:
1:281df80:      * <ul> <li>version number (i.e. 10.6.2.1 > 10.5.1.0)</li>
1:281df80:      *      <li>release date</li>
1:281df80:      * </ul>
1:0a218e3:      * <p>
1:0a218e3:      * The target version will always be found at index zero.
1:281df80:      * <p>
1:281df80:      * Not specifying a target version will return all Derby releases sorted by
1:281df80:      * version number.
1:281df80:      *
1:281df80:      * @param target target version to start sorting/filtering at (may be null)
1:281df80:      * @return A list of previous releases, sorted by version number
1:281df80:      *      (highest first).
1:281df80:      */
1:281df80:     private DerbyVersion[] getSortedAndFilteredReleases(DerbyVersion target) {
1:281df80:         // Add versions to the list, filtering as specified.
1:281df80:         ArrayList tmp = new ArrayList();
1:281df80:         for (int i=0; i < allVersions.length; i++) {
1:281df80:             DerbyVersion dv = allVersions[i];
1:281df80:             // Skip versions that haven't been released.
1:0a218e3:             if (!dv.isReleased() && !dv.equals(target)) {
1:281df80:                 continue;
1:281df80:             }
1:281df80:             if (target != null) {
1:281df80:                 if (dv.compareTo(target) > 0) {
1:281df80:                     continue;
1:281df80:                 }
1:281df80:                 if (target.isReleased() && dv.getReleaseDateMillis() >
1:281df80:                         target.getReleaseDateMillis()) {
1:281df80:                     continue;
1:281df80:                 }
1:281df80:             }
1:281df80:             tmp.add(dv);
1:281df80:         }
1:281df80:         // Sort, then reverse to get newest version at index zero.
1:281df80:         Collections.sort(tmp);
1:281df80:         Collections.reverse(tmp);
1:281df80:         DerbyVersion[] result = new DerbyVersion[tmp.size()];
1:281df80:         tmp.toArray(result);
1:281df80:         return result;
1:281df80:     }
1:281df80: 
1:281df80:     /**
1:695493d:      * Fetches JIRA issues matched by a predefined filter search.
1:695493d:      * <p>
1:695493d:      * The filter must be created manually and before the release notes are
1:695493d:      * generated.
1:695493d:      *
1:695493d:      * @param out output stream
1:695493d:      * @param auth JIRA authententication token
1:695493d:      * @param filterId JIRA filter id (digits only)
1:695493d:      * @return A list of matching issues.
1:695493d:      * @throws IOException if something goes wrong
1:695493d:      */
1:695493d:     private RemoteIssue[] execJiraFilterQuery(BufferedWriter out, String auth,
1:695493d:                                               long filterId)
1:695493d:             throws IOException {
1:695493d:         out.write("// Filter id: " + filterId + ", user id " + user);
1:695493d:         out.newLine();
1:695493d:         log("fetching issues from filter (id = " + filterId + ")");
1:695493d:         try {
1:695493d:              return jiraSoapService.getIssuesFromFilterWithLimit(
1:695493d:                 auth, Long.toString(filterId), 0, 1000);
1:695493d:         } catch (org.apache.derbyBuild.jirasoap.RemoteException re) {
1:695493d:             throw new IllegalArgumentException(
1:695493d:                     "invalid filter id: " + filterId +
1:695493d:                     " (" + re.getFaultString() + ")");
1:695493d:         }
1:695493d:     }
1:695493d: 
1:695493d:     /**
1:695493d:      * Fetches JIRA issues matching a generated JQL (Jira Query Language)
1:695493d:      * search.
1:695493d:      *
1:695493d:      * @param out output stream
1:695493d:      * @param auth JIRA authententication token
1:695493d:      * @param targetVersion the target release version
1:695493d:      * @return A list of matching issues.
1:695493d:      * @throws IOException if something goes wrong
1:695493d:      */
1:846080f:     private RemoteIssue[] execJiraJQLQuery
1:846080f:         (
1:846080f:          BufferedWriter out,
1:846080f:          String auth,
1:846080f:          DerbyVersion targetVersion,
1:846080f:          DerbyVersion[] excludeFixVersions
1:846080f:          )
1:846080f:         throws IOException
1:846080f:     {
1:695493d:         // Here we have two scenarions:
1:695493d:         // a) A single target version number - the release has already been
1:695493d:         //    made, or there is only one release candidate.
1:695493d:         // b) Multiple target version numbers - there are multiple release
1:695493d:         //    candidates, and we want to include issues fixed in all of them.
1:695493d:         // To simplify code, just build an IN-clause for all scenarios.
1:695493d: 
1:695493d:         // Identify versions.
1:695493d:         List rcs = new ArrayList();
1:695493d:         for (int i=0; i < allVersions.length; i++) {
1:695493d:             DerbyVersion ver = allVersions[i];
1:695493d:             if (targetVersion.isSameFixPack(ver) &&
1:695493d:                     ver.compareTo(targetVersion) < 1) {
1:695493d:                 rcs.add(ver);
1:695493d:             }
1:695493d:         }
1:695493d:         Collections.sort(rcs);
1:695493d:         Collections.reverse(rcs);
1:695493d:         Iterator rcIter = rcs.iterator();
1:695493d: 
1:695493d:         // Build JQL query.
1:d311311:         String jql = "project = DERBY AND resolution = fixed AND component not in ( Test ) AND fixversion ";
1:695493d:         StringBuffer sb = new StringBuffer("in (");
1:695493d:         while (rcIter.hasNext()) {
1:695493d:             DerbyVersion rc = (DerbyVersion)rcIter.next();
1:695493d:             sb.append(rc.getQuotedVersion());
1:695493d:             sb.append(", ");
1:695493d:         }
1:695493d:         sb.deleteCharAt(sb.length() -1).deleteCharAt(sb.length() -1);
1:695493d:         sb.append(')');
1:695493d:         jql += sb.toString();
1:695493d: 
1:846080f:         StringBuilder   notIn = new StringBuilder();
1:846080f:         notIn.append( " and fixversion not in ( " );
1:846080f:         for ( int i = 0; i < excludeFixVersions.length; i++ )
1:846080f:         {
1:846080f:             if ( i > 0 ) { notIn.append( ", " ); }
1:846080f:             DerbyVersion    exclusion = excludeFixVersions[ i ];
1:846080f:             notIn.append( exclusion.getQuotedVersion() );
1:846080f:         }
1:846080f:         notIn.append( " )" );
1:846080f:         jql += notIn.toString();
1:846080f: 
1:695493d:         // Execute the query.
1:695493d:         out.write("// JQL query: " + jql);
1:695493d:         out.newLine();
1:695493d:         log("executing JQL query: " + jql);
1:695493d:         try {
1:695493d:              return jiraSoapService.getIssuesFromJqlSearch(auth, jql, 1000);
1:695493d:         } catch (org.apache.derbyBuild.jirasoap.RemoteException re) {
1:695493d:             throw new IllegalArgumentException(
1:695493d:                     "JQL query '" + jql + "' failed (" +
1:695493d:                     re.getFaultString() + ")");
1:695493d:         }
1:695493d:     }
1:695493d: 
1:695493d:     /**
1:281df80:      * Interface for running from the command line.
1:281df80:      *
1:281df80:      * @param args see USAGE constant, or invoke with zero arguments
1:281df80:      * @throws Exception if something goes wrong
1:281df80:      */
1:281df80:     public static void main(String[] args)
1:281df80:             throws Exception {
1:281df80:         // Always require JIRA user name and password.
1:281df80:         if (args.length > 2) {
1:281df80:             FilteredIssueLister client =
1:281df80:                     new FilteredIssueLister(args[0], args[1]);
1:281df80:             try {
1:281df80:                 // PRINT ANCESTORS
1:281df80:                 if (args[2].equalsIgnoreCase("ancestors")) {
1:281df80:                     if (args.length == 2) {
1:281df80:                         System.err.println("Missing version argument.");
1:281df80:                         System.exit(1);
1:281df80:                     }
1:281df80:                     client.printAncestors(args[3]);
1:281df80:                 // PRINT VERSIONS
1:281df80:                 } else if(args[2].equalsIgnoreCase("releases")) {
1:281df80:                     client.printReleases();
1:281df80:                 // RELEASE NOTES PREPARATION / GENERATE ISSUE LIST
1:281df80:                 } else {
1:281df80:                     if (args.length < 4) {
1:281df80:                         System.err.println("Missing argument(s).");
1:281df80:                         System.exit(1);
1:281df80:                     }
1:281df80:                     String[] overriddenAncestry = null;
1:281df80:                     // This is the default release target
1:281df80:                     // Args: user password version filterId dest [remove]
1:281df80:                     if (args.length > 5) {
1:281df80:                         overriddenAncestry = args[5].split(",");
1:281df80:                         if (args[0].equalsIgnoreCase("ignore")) {
1:281df80:                             overriddenAncestry = new String[0];
1:281df80:                         } else if(args[0].equalsIgnoreCase("derive")) {
1:281df80:                             overriddenAncestry = null;
1:281df80:                         }
1:281df80:                     }
1:281df80:                     client.prepareReleaseNotes(args[2], Long.parseLong(args[3]),
1:281df80:                             args[4], overriddenAncestry);
1:281df80:                 }
1:281df80:             } finally {
1:281df80:                 client.destroy();
1:281df80:             }
1:281df80:         } else {
1:281df80:             System.err.println(USAGE);
1:281df80:         }
1:281df80:     }
1:281df80: 
1:281df80:     /** Logs status/convenience messages. */
1:281df80:     private void log(String msg) {
1:281df80:         if (logOut != null) {
1:281df80:             logOut.println(msg);
1:281df80:         }
1:281df80:     }
1:281df80: 
1:281df80:     /**
1:281df80:      * Converts an array of fix versions into a string representation.
1:281df80:      *
1:281df80:      * @param fixVersions fix versions for a JIRA issue
1:281df80:      * @return A string describing all the fix versions.
1:281df80:      */
1:281df80:     private String stringifyAndCheckFixVersions(String issueKey,
1:281df80:             RemoteVersion[] fixVersions, List excludeVersions,
1:281df80:             DerbyVersion releaseVersion) {
1:281df80:         if (fixVersions.length == 0) {
1:281df80:             throw new IllegalStateException(issueKey + " has no fix version");
1:281df80:         }
1:281df80:         boolean disqualified = false;
1:281df80:         boolean sanityCheckPassed = false;
1:281df80:         StringBuffer sb = new StringBuffer();
1:281df80:         StringBuffer fixedIn = new StringBuffer(); // only used for reporting
1:281df80:         for (int i=0; i < fixVersions.length; i++) {
1:281df80:             String fv = fixVersions[i].getName();
1:281df80:             if (!sanityCheckPassed) {
1:281df80:                 DerbyVersion dv = new DerbyVersion(fixVersions[i]);
1:281df80:                 if (dv.equals(releaseVersion) ||
1:281df80:                         dv.isSameFixPack(releaseVersion)) {
1:281df80:                     sanityCheckPassed = true;
1:281df80:                 }
1:281df80:             }
1:281df80:             if (excludeVersions.contains(fv)) {
1:281df80:                 disqualified = true;
1:281df80:                 fixedIn.append(fv).append(',');
1:281df80:                 // Could return null here, but then the sanity-check may be
1:281df80:                 // bypassed.
1:281df80:             }
1:281df80:             sb.append(fv).append(',');
1:281df80:         }
1:281df80:         sb.deleteCharAt(sb.length() -1);
1:281df80: 
1:281df80:         // Sanity check to catch if an invalid JIRA filter is being used.
1:281df80:         if (!sanityCheckPassed) {
1:281df80:             throw new IllegalStateException(issueKey + " not marked as fixed " +
1:281df80:                     "in the target release version" +
1:281df80:                     releaseVersion.getVersion() + ", nor in any of the " +
1:281df80:                     "versions with the same fixpack. Invalid JIRA filter?");
1:281df80:         }
1:281df80:         if (disqualified) {
1:281df80:             if (reportDisqualifiedIssues) {
1:281df80:                 fixedIn.deleteCharAt(fixedIn.length() -1);
1:281df80:                 System.out.println(issueKey + " disqualified, " +
1:281df80:                         "already fixed in " + fixedIn.toString());
1:281df80:             }
1:281df80:             return null;
1:281df80:         } else {
1:281df80:             return sb.toString();
1:281df80:         }
1:281df80:     }
1:281df80: 
1:281df80:     /**
1:281df80:      * Tells if the issue has a release note.
1:281df80:      *
1:281df80:      * @param issue JIRA issue
1:281df80:      * @return {@code true} if the issue has a release note attached.
1:281df80:      */
1:281df80:     private static boolean hasReleaseNote(RemoteIssue issue) {
1:281df80:         String[] aNames = issue.getAttachmentNames();
1:281df80:         for (int i=0; i < aNames.length; i++) {
1:281df80:             if (aNames[i].equals(RELEASE_NOTE_NAME)) {
1:281df80:                 return true;
1:281df80:             }
1:281df80:         }
1:281df80:         return false;
1:281df80:     }
1:281df80: 
1:281df80:     /**
1:281df80:      * Tells if the issue has the specified custom field value set.
1:281df80:      *
1:281df80:      * @param fieldValue the value to look for
1:281df80:      * @param values the field values
1:281df80:      * @return {@code true} if the custom field value was found,
1:281df80:      *      {@code false} otherwise.
1:281df80:      */
1:281df80:     private static boolean hasCustomField(String fieldName,
1:281df80:                                           RemoteCustomFieldValue[] values) {
1:281df80:         // The API is a but awkward when it comes to fields, but we can do our
1:281df80:         // thing by looking at the custom field values only.
1:281df80:         for (int i=0; i < values.length; i++) {
1:281df80:             String[] v = values[i].getValues();
1:281df80:             for (int j=0; j < v.length; j++) {
1:281df80:                 if (fieldName.equals(v[j])) {
1:281df80:                     return true;
1:281df80:                 }
1:281df80:             }
1:281df80:         }
1:281df80:         return false;
1:281df80:     }
1:281df80: 
1:281df80:     private static final Calendar PARSECAL = GregorianCalendar.getInstance();
1:281df80:     private static synchronized long parseDate(String date) {
1:281df80:         String[] comp = date.split("-");
1:281df80:         int year = Integer.parseInt(comp[0]);
1:281df80:         int month = Integer.parseInt(comp[1]) -1;
1:281df80:         int day = Integer.parseInt(comp[2]);
1:281df80:         PARSECAL.set(year, month, day, 0, 0, 0);
1:281df80:         return PARSECAL.getTimeInMillis();
1:281df80:     }
1:281df80: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:d311311
/////////////////////////////////////////////////////////////////////////
1:         String jql = "project = DERBY AND resolution = fixed AND component not in ( Test ) AND fixversion ";
commit:846080f
/////////////////////////////////////////////////////////////////////////
1:             issues = execJiraJQLQuery( out, auth, targetVersion, excludeFixVersions );
/////////////////////////////////////////////////////////////////////////
1:     private RemoteIssue[] execJiraJQLQuery
1:         (
1:          BufferedWriter out,
1:          String auth,
1:          DerbyVersion targetVersion,
1:          DerbyVersion[] excludeFixVersions
1:          )
1:         throws IOException
1:     {
/////////////////////////////////////////////////////////////////////////
1:         StringBuilder   notIn = new StringBuilder();
1:         notIn.append( " and fixversion not in ( " );
1:         for ( int i = 0; i < excludeFixVersions.length; i++ )
1:         {
1:             if ( i > 0 ) { notIn.append( ", " ); }
1:             DerbyVersion    exclusion = excludeFixVersions[ i ];
1:             notIn.append( exclusion.getQuotedVersion() );
1:         }
1:         notIn.append( " )" );
1:         jql += notIn.toString();
1: 
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:695493d
/////////////////////////////////////////////////////////////////////////
1: "      JIRA id, only digits allowed.\n" +
1: "      If '0' (zero), a JQL query will be generated instead of using an\n" +
1: "      existing (manually created) JIRA filter.\n" +
/////////////////////////////////////////////////////////////////////////
1:     /** Constant used to choose using JQL over an existing filter. */
1:     private static final int GENERATE_JQL = 0;
/////////////////////////////////////////////////////////////////////////
1:         if (filterId == GENERATE_JQL) {
0:             issues = execJiraJQLQuery(out, auth, targetVersion);
1:         } else {
1:             issues = execJiraFilterQuery(out, auth, filterId);
1:         log("persisting issues (" + issues.length + " candidate issues)");
1:         out.write("// Candidate issue count: " + issues.length);
/////////////////////////////////////////////////////////////////////////
1:      * Fetches JIRA issues matched by a predefined filter search.
1:      * <p>
1:      * The filter must be created manually and before the release notes are
1:      * generated.
1:      *
1:      * @param out output stream
1:      * @param auth JIRA authententication token
1:      * @param filterId JIRA filter id (digits only)
1:      * @return A list of matching issues.
1:      * @throws IOException if something goes wrong
1:      */
1:     private RemoteIssue[] execJiraFilterQuery(BufferedWriter out, String auth,
1:                                               long filterId)
1:             throws IOException {
1:         out.write("// Filter id: " + filterId + ", user id " + user);
1:         out.newLine();
1:         log("fetching issues from filter (id = " + filterId + ")");
1:         try {
1:              return jiraSoapService.getIssuesFromFilterWithLimit(
1:                 auth, Long.toString(filterId), 0, 1000);
1:         } catch (org.apache.derbyBuild.jirasoap.RemoteException re) {
1:             throw new IllegalArgumentException(
1:                     "invalid filter id: " + filterId +
1:                     " (" + re.getFaultString() + ")");
1:         }
1:     }
1: 
1:     /**
1:      * Fetches JIRA issues matching a generated JQL (Jira Query Language)
1:      * search.
1:      *
1:      * @param out output stream
1:      * @param auth JIRA authententication token
1:      * @param targetVersion the target release version
1:      * @return A list of matching issues.
1:      * @throws IOException if something goes wrong
1:      */
0:     private RemoteIssue[] execJiraJQLQuery(BufferedWriter out, String auth,
0:                                            DerbyVersion targetVersion)
1:             throws IOException {
1:         // Here we have two scenarions:
1:         // a) A single target version number - the release has already been
1:         //    made, or there is only one release candidate.
1:         // b) Multiple target version numbers - there are multiple release
1:         //    candidates, and we want to include issues fixed in all of them.
1:         // To simplify code, just build an IN-clause for all scenarios.
1: 
1:         // Identify versions.
1:         List rcs = new ArrayList();
1:         for (int i=0; i < allVersions.length; i++) {
1:             DerbyVersion ver = allVersions[i];
1:             if (targetVersion.isSameFixPack(ver) &&
1:                     ver.compareTo(targetVersion) < 1) {
1:                 rcs.add(ver);
1:             }
1:         }
1:         Collections.sort(rcs);
1:         Collections.reverse(rcs);
1:         Iterator rcIter = rcs.iterator();
1: 
1:         // Build JQL query.
0:         String jql = "project = DERBY AND resolution = fixed AND fixversion ";
1:         StringBuffer sb = new StringBuffer("in (");
1:         while (rcIter.hasNext()) {
1:             DerbyVersion rc = (DerbyVersion)rcIter.next();
1:             sb.append(rc.getQuotedVersion());
1:             sb.append(", ");
1:         }
1:         sb.deleteCharAt(sb.length() -1).deleteCharAt(sb.length() -1);
1:         sb.append(')');
1:         jql += sb.toString();
1: 
1:         // Execute the query.
1:         out.write("// JQL query: " + jql);
1:         out.newLine();
1:         log("executing JQL query: " + jql);
1:         try {
1:              return jiraSoapService.getIssuesFromJqlSearch(auth, jql, 1000);
1:         } catch (org.apache.derbyBuild.jirasoap.RemoteException re) {
1:             throw new IllegalArgumentException(
1:                     "JQL query '" + jql + "' failed (" +
1:                     re.getFaultString() + ")");
1:         }
1:     }
1: 
1:     /**
commit:0a218e3
/////////////////////////////////////////////////////////////////////////
1:     private final DerbyVersion ancestorCutoff;
/////////////////////////////////////////////////////////////////////////
1:             ancestorCutoff = getVersion(System.getProperty(
/////////////////////////////////////////////////////////////////////////
1:         // Expected format: release version, release date (YYYY-MM-DD, or null)
1:                     versions[i][0], versions[i][1] == null
1:                                             ? DerbyVersion.NOT_RELEASED
1:                                             : parseDate(versions[i][1]));
1:             ancestorCutoff = getVersion(System.getProperty(
1:                     "invalid ancestor cutoff version", iae);
/////////////////////////////////////////////////////////////////////////
1:         if (parent.compareTo(ancestorCutoff) < 0) {
1:                     ancestorCutoff.getVersion());
1:             System.out.println(ancestors[i]);
1:         System.out.println("(cutoff=" + ancestorCutoff.getVersion() + ")");
/////////////////////////////////////////////////////////////////////////
1:             System.out.println(relIter.next());
/////////////////////////////////////////////////////////////////////////
1:         log("dump file: " + new File(destFile).getCanonicalPath());
/////////////////////////////////////////////////////////////////////////
1:         while (dv.length > 1 && dv[0].compareTo(ancestorCutoff) >= 0) {
/////////////////////////////////////////////////////////////////////////
1:      * <p>
1:      * The target version will always be found at index zero.
/////////////////////////////////////////////////////////////////////////
1:             if (!dv.isReleased() && !dv.equals(target)) {
/////////////////////////////////////////////////////////////////////////
commit:281df80
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derbyBuild.jirasoap.FilteredIssueLister
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derbyBuild.jirasoap;
1: 
1: import java.io.BufferedWriter;
1: import java.io.File;
1: import java.io.FileOutputStream;
1: import java.io.IOException;
1: import java.io.OutputStreamWriter;
1: import java.io.PrintStream;
1: 
1: import java.rmi.RemoteException;
1: 
1: import java.util.ArrayList;
1: import java.util.Calendar;
1: import java.util.Collections;
1: import java.util.Comparator;
1: import java.util.GregorianCalendar;
1: import java.util.Iterator;
1: import java.util.List;
1: 
1: import javax.xml.rpc.ServiceException;
1: 
1: /**
1:  * Client talking to the Apache JIRA instance to retrieve and derive information
1:  * required to generate releases notes for a Derby release.
1:  * <p>
1:  * The purpose of this client is to carry out some of the tasks a release
1:  * manager has to do when generating the release notes.
1:  */
1: public class FilteredIssueLister {
1: 
1:     /** System property for specifying the ancestor cutoff threshold. */
1:     private static final String ANCESTOR_CUTOFF_PROP = "ancestorCutoff";
1:     private static final String DEFAULT_ANCESTOR_CUTOFF = "10.3.3.0";
1:     /** System property for turning on reporting of disqualified issues. */
1:     private static final String REPORT_DISQUALIFICATIONS_PROP =
1:             "reportDisqualifications";
1:     /** Help text for command line invocation. */
1:     private static final String USAGE =
1: "-- Apache Derby JIRA SOAP client --\n\n" +
1: "The main purpose of this client is to fetch the required information from\n" +
1: "JIRA, such that the release manager can generate the release notes.\n" +
1: "This tool does not generate the release notes, but provides some of the\n" +
1: "information for the tool doing that.\n\n" +
1: "Primary usage:\n" +
1: "  o <USER> <PASSWORD> <VERSION> <FILTERID> <DESTINATION_FILE> [ANCESTRY]\n" +
1: "    generates a list of fixed issues for the specified release version,\n" +
1: "    which can be processed by the ReleaseNotesGenerator tool.\n" +
1: "    Note that the release ancestry should be verified. The ancestry is\n" +
1: "    printed to standard out and into the generated file. You can also\n" +
1: "    check up-front by running the 'ancestors' mode (see 'Secondary usage').\n"+
1: "    If incorrect, re-run and specify the release ancestry manually.\n" +
1: "\n" +
1: "Secondary usage:\n" +
1: "  o <USER> <PASSWORD> ancestors <VERSION>\n" +
1: "    prints the ancestors of the specified version\n"+
1: "    (only released versions can be ancestors)\n" +
1: "  o <USER> <PASSWORD> releases\n" +
1: "    prints all Derby releases, sorted by release date\n"+
1: "\n" +
1: "Argument values:\n" +
1: "  o VERSION\n" +
1: "      Derby version string, i.e. 10.6.2.1\n" +
1: "  o FILTERID\n" +
0: "      JIRA id, only digits allowed\n" +
1: "  o ANCESTRY\n" +
1: "      if necessary, the release ancestry can be overridden by specifying\n " +
1: "      the ancestors by version manually. Valid values:\n" +
1: "        - derive (the default)\n" +
1: "        - ignore (don't filter issues)\n" +
1: "        - VERSION[,VERSION]* (manually specified)\n" +
1: "\n" +
1: "System properties:\n" +
1: "  o " + ANCESTOR_CUTOFF_PROP + "\n" +
1: "    modify the value of the cutoff version\n" +
1: "    (default is 10.3.3.0)\n" +
1: "  o " + REPORT_DISQUALIFICATIONS_PROP + "\n" +
1: "    if set to true, disqualified issues will be printed to standard out\n" +
1: "    (default is false)\n" +
1: "\n";
1: 
1:     /** Apache Derby project identifier in JIRA. */
1:     private static final String DERBY_PROJECT = "DERBY";
1:     /** Custom Derby flag used in JIRA. */
1:     private static final String FIELD_RELEASE_NOTE = "Release Note Needed";
1:     /**
1:      * Name of the file containing release notes in JIRA. This is by
1:      * Apache Derby community convention.
1:      */
1:     private static final String RELEASE_NOTE_NAME = "releaseNote.html";
1: 
1:     private PrintStream logOut = new PrintStream(System.out);
1:     private JiraSoapService jiraSoapService;
1:     /** JIRA user to log in as. */
1:     private String user;
1:     /** JIRA authentication token. */
1:     private String auth;
1:     /** Cached version objects. */
1:     private DerbyVersion[] allVersions;
1:     /** The point at which we stop listing ancestors for a release. */
0:     private final DerbyVersion ancestorCutOff;
1:     /** Tells if disqualified issues should be reported. */
1:     private final boolean reportDisqualifiedIssues;
1:     /** Tells if the release ancestry has been overriden by the user. */
1:     private boolean ancestryOverridden;
1: 
1:     /**
1:      * Creates a new JIRA client.
1:      *
1:      * @param username JIRA user to log in as
1:      * @param cred JIRA password
1:      * @throws RemoteException if the login fails for some unexpected reason, or
1:      *      if fetching the version list fails
1:      * @throws ServiceException if obtaining the JIRA service fails
1:      * @throws RuntimeException if the JIRA credentials are invalid
1:      */
1:     public FilteredIssueLister(String username, String cred)
1:             throws RemoteException, ServiceException {
1:         JiraSoapServiceService jiraSoapServiceLocator =
1:                 new JiraSoapServiceServiceLocator();
1:         log("getting JIRA service");
1:         jiraSoapService = jiraSoapServiceLocator.getJirasoapserviceV2();
1:         log("logging in as '" + username + "'");
1:         try {
1:             auth = jiraSoapService.login(username, cred);
1:         } catch (RemoteAuthenticationException rae) {
1:             // Give a friendlier error message for this case.
1:             throw new RuntimeException(
1:                     "JIRA login failed. Cause:\n" + rae.toString());
1:         }
1:         user = username;
1:         log("fetching versions");
1:         RemoteVersion[] jiraVer =
1:                 jiraSoapService.getVersions(auth, DERBY_PROJECT);
1:         allVersions = new DerbyVersion[jiraVer.length];
1:         for (int i=0; i < jiraVer.length; i++) {
1:             allVersions[i] = new DerbyVersion(jiraVer[i]);
1:         }
1:         // Give a better error message if user-specified cutoff value is bad.
1:         try {
0:             ancestorCutOff = getVersion(System.getProperty(
1:                 ANCESTOR_CUTOFF_PROP, DEFAULT_ANCESTOR_CUTOFF));
1:         } catch (IllegalArgumentException iae) {
1:             throw new IllegalArgumentException(
1:                     "invalid ancestor cutoff version", iae);
1:         }
1:         reportDisqualifiedIssues =
1:                 Boolean.getBoolean(REPORT_DISQUALIFICATIONS_PROP);
1:     }
1: 
1:     /** Constructor for testing, where the Derby versions can be specified
1:      * manually.
1:      *
1:      * @param versions format is {{"major.minor.fixpack.point", "YYYY-MM-DD"}}
1:      */
1:     FilteredIssueLister(String username, String cred, String[][] versions)
1:             throws RemoteException, ServiceException {
1:         JiraSoapServiceService jiraSoapServiceLocator =
1:                 new JiraSoapServiceServiceLocator();
1:         log("getting JIRA service");
1:         jiraSoapService = jiraSoapServiceLocator.getJirasoapserviceV2();
1:         log("logging in as '" + username + "'");
1:         try {
1:             auth = jiraSoapService.login(username, cred);
1:         } catch (RemoteAuthenticationException rae) {
1:             // Give a friendlier error message for this case.
1:             throw new RuntimeException(
1:                     "JIRA login failed. Cause:\n" + rae.toString());
1:         }
1:         user = username;
1:         allVersions = new DerbyVersion[versions.length];
0:         // Expected format: release version, release date (YYYY-MM-DD)
1:         for (int i=0; i < versions.length; i++) {
1:             allVersions[i] = new DerbyVersion(
0:                     versions[i][0], parseDate(versions[i][1]));
1:         }
1:         // Give a better error message if user-specified cutoff value is bad.
1:         try {
0:             ancestorCutOff = getVersion(System.getProperty(
1:                 ANCESTOR_CUTOFF_PROP, DEFAULT_ANCESTOR_CUTOFF));
1:         } catch (IllegalArgumentException iae) {
1:             throw new IllegalArgumentException(
0:                     "invaild ancestor cutoff version", iae);
1:         }
1:         reportDisqualifiedIssues =
1:                 Boolean.getBoolean(REPORT_DISQUALIFICATIONS_PROP);
1:     }
1: 
1:     /**
1:      * Generates a list of Derby JIRA issues addressed by the target release
1:      * version and writes these to a file for further processing.
1:      * <p>
1:      * <b>Important:</b> Although some sanity checks are performed, it is
1:      * crucial that the manually created filter is set up correctly. If the
1:      * filter misses issues addressed by the release, they will not make it
1:      * into the generated release notes. Short description:
1:      * <ul>
1:      *  <li>include bugs and improvements</li>
1:      *  <li>include issues resolved as Fixed</li>
1:      *  <li>include issues marked as Resolved or Closed</li>
1:      *  <li>include all release candidates in the fix version field
1:      *      (if not already released)</li>
1:      * </ul>
1:      *
1:      * @param version the target release version
1:      * @param filterId the JIRA filter id
1:      * @param destFile output file for the issue report
1:     * @throws IOException if writing to the output file fails
1:      */
1:     public void prepareReleaseNotes(String version, long filterId,
1:                                     String destFile,
1:                                     String[] ancestorVersions)
1:             throws IOException {
1:         DerbyVersion releaseVersion = getVersion(version);
1:         DerbyVersion[] ancestors = null;
1:         if (ancestorVersions == null) {
1:             // Obtain a list of ancestors, used to disqualify JIRA issues
1:             // matched by the JIRA filter.
1:             ancestryOverridden = false;
1:             ancestors = getAncestors(releaseVersion);
1:         } else {
1:             ancestryOverridden = true;
1:             ancestors = new DerbyVersion[ancestorVersions.length];
1:             for (int i=0; i < ancestorVersions.length; i++) {
1:                 ancestors[i] = getVersion(ancestorVersions[i]);
1:             }
1:         }
1:         persistFilterResult(releaseVersion, filterId, destFile, ancestors);
1:     }
1: 
1:     /**
1:      * Prints the list of ancestors, i.e. earlier releases down the release
1:      * chain, for specified Derby version.
1:      * <p>
1:      * Note that only released versions are considered to be ancestors.
1:      *
1:      * @param parentVersion the version to start at (released or not)
1:      */
1:     public void printAncestors(String parentVersion) {
1:         DerbyVersion parent = getVersion(parentVersion);
0:         if (parent.compareTo(ancestorCutOff) < 0) {
1:             throw new IllegalArgumentException(
1:                     "specified version " + parentVersion +
1:                     " is less than the ancestor cut-off version: " +
0:                     ancestorCutOff.getVersion());
1:         }
1:         DerbyVersion[] ancestors = getAncestors(parent);
1:         System.out.println("--- Ancestors for version " + parentVersion + " (" +
1:                 (parent.isReleased() ? "released)" : "unreleased)"));
1:         for (int i=0; i < ancestors.length; i++) {
0:             DerbyVersion a = ancestors[i];
0:             Calendar cal = GregorianCalendar.getInstance();
0:             cal.setTimeInMillis(a.getReleaseDateMillis());
0:             System.out.println(a.getVersion() + ", " +
0:                     cal.get(Calendar.YEAR) + "-" +
0:                     padZero(cal.get(Calendar.MONTH) +1) + "-" +
0:                     padZero(cal.get(Calendar.DAY_OF_MONTH)));
1:         }
1:         // Special case when there is no ancestor.
1:         if (ancestors.length == 0) {
1:             System.out.println("<no ancestors found in JIRA>");
1:         }
0:         System.out.println("(cutoff=" + ancestorCutOff.getVersion() + ")");
1:     }
1: 
1:     /**
1:      * Prints all Derby releases.
1:      */
1:     public void printReleases() {
1:         ArrayList releases = new ArrayList();
1:         for (int i=0; i < allVersions.length; i++) {
1:             DerbyVersion dv = allVersions[i];
1:             if (dv.isReleased()) {
1:                 releases.add(dv);
1:             }
1:         }
1:         Collections.sort(releases, new Comparator() {
1: 
1:             public int compare(Object o1, Object o2) {
1:                 Long release1 = new Long(
1:                         ((DerbyVersion)o1).getReleaseDateMillis());
1:                 Long release2 = new Long(
1:                         ((DerbyVersion)o2).getReleaseDateMillis());
1:                 return release1.compareTo(release2);
1:             }
1:         });
1:         Collections.reverse(releases);
1:         System.out.println("--- Derby releases");
1:         Iterator relIter = releases.iterator();
1:         while (relIter.hasNext()) {
0:             DerbyVersion dv = (DerbyVersion)relIter.next();
0:             Calendar cal = GregorianCalendar.getInstance();
0:             cal.setTimeInMillis(dv.getReleaseDateMillis());
0:             System.out.println(dv.getVersion() + ", " +
0:                     cal.get(Calendar.YEAR) + "-" +
0:                     padZero(cal.get(Calendar.MONTH) +1) + "-" +
0:                     padZero(cal.get(Calendar.DAY_OF_MONTH)));
1: 
1:         }
1:     }
1: 
1:     /**
1:      * Releases resources associated with the client.
1:      *
1:      * @throws RemoteException if logging out fails
1:      */
1:     public void destroy()
1:             throws RemoteException {
1:         jiraSoapService.logout(auth);
1:         auth = null;
1:         jiraSoapService = null;
1:         allVersions = null;
1:     }
1: 
1:     /**
1:      * Executes a JIRA filter and writes the matching JIRA issues to file.
1:      *
1:      * @param targetVersion targetted release version
1:      * @param filterId JIRA filter id used to obtain the relevant issues
1:      * @param destFile destination file
1:      * @param excludeFixVersions exclude issues which have been fixed on one
1:      *      of the exclude versions (also called ancestry chain)
1:      * @return The number of filters written to the destination file.
1:      * @throws IOException if writing to the output file fails
1:      */
1:     private int persistFilterResult(DerbyVersion targetVersion, long filterId,
1:                                    String destFile,
1:                                    DerbyVersion[] excludeFixVersions)
1:             throws IOException {
1:         // Extract the version string from the versions to exclude.
1:         int size = excludeFixVersions == null ? 0 : excludeFixVersions.length;
1:         final ArrayList excludeList = new ArrayList(size);
1:         for (int i=0; i < size; i++) {
1:             excludeList.add(excludeFixVersions[i].getVersion());
1:         }
1: 
1:         BufferedWriter out = new BufferedWriter(new OutputStreamWriter(
1:                 new FileOutputStream(destFile), "UTF-8"));
1:         out.write("// Produced on " + new java.util.Date().toString());
1:         out.newLine();
1:         out.write("// Release version: " + targetVersion.getVersion());
1:         out.newLine();
1:         out.write("// Previous release: " + excludeFixVersions[0].getVersion());
1:         out.newLine();
1:         out.write("// " + (ancestryOverridden ? "Overridden" : "Derived"));
1:         out.write(" ancestry chain");
1:         out.newLine();
1:         for (int i=0; i < excludeFixVersions.length; i++) {
1:             out.write("//   " + excludeFixVersions[i].getVersion());
1:             out.newLine();
1:         }
0:         out.write("// Filter id: " + filterId + ", user id " + user);
1:         out.newLine();
0:         log("fetching issues from filter (id = " + filterId + ")");
1:         RemoteIssue[] issues = null;
1:         try {
0:             issues= jiraSoapService.getIssuesFromFilterWithLimit(
0:                 auth, Long.toString(filterId), 0, 1000);
0:         } catch (org.apache.derbyBuild.jirasoap.RemoteException re) {
1:             throw new IllegalArgumentException(
0:                     "invalid filter id: " + filterId +
0:                     " (" + re.getFaultString() + ")");
1:         }
0:         log("persisting issues (filter matched " + issues.length + " issues)");
0:         out.write("// Filter issue count: " + issues.length);
1:         out.newLine();
1:         int count = 0;
1:         int issuesWithReleaseNote = 0;
1:         // Adhere to this very simple format.
1:         // --- (separator)
1:         // DERBY-XXXX
1:         // SUMMARY
1:         // FIX_VERSION[,FIX_VERSION]*
1:         // RELEASENOTE_ATTACHMENT_ID|null|missing
1:         // ("null" if not existing, "missing" if missing)
1:         for (int i=0; i < issues.length; i++) {
1:             RemoteIssue ri = issues[i];
1:             // This will throw exception if the target version isn't in the list
1:             // of fix versions, and return null if the issue has been dis-
1:             // qualified because it has already been fixed in an ancestor.
1:             String fixVersions = stringifyAndCheckFixVersions(ri.getKey(),
1:                     ri.getFixVersions(), excludeList, targetVersion);
1:             if (fixVersions == null) {
1:                 continue;
1:             }
1:             // Persist the issue (human readable/editable).
1:             out.write("---");
1:             out.newLine();
1:             // key
1:             out.write(ri.getKey());
1:             out.newLine();
1:             // summary
1:             out.write(ri.getSummary());
1:             out.newLine();
1:             // fix versions
1:             out.write(fixVersions);
1:             out.newLine();
1:             // release note flag and affects existing applications flag
1:             RemoteCustomFieldValue[] fieldValues = ri.getCustomFieldValues();
1:             boolean releaseNoteNeeded = hasCustomField(
1:                     FIELD_RELEASE_NOTE, fieldValues);
1:             // release note attachemnt id
1:             if (hasReleaseNote(ri)) {
1:                 issuesWithReleaseNote++;
1:                 long latest = 0;
1:                 RemoteAttachment[] attachments =
1:                         jiraSoapService.getAttachmentsFromIssue(
1:                                                             auth, ri.getKey());
1:                 // Find the latest attachment, just use the one with the
1:                 // highest id.
1:                 for (int a=0; a < attachments.length; a++) {
1:                     String name = attachments[a].getFilename();
1:                     long id = Long.parseLong(attachments[a].getId());
1:                     if (name.equals(RELEASE_NOTE_NAME)) {
1:                         latest = Math.max(latest, id);
1:                     }
1:                 }
1:                 out.write(Long.toString(latest));
1:             } else {
1:                 if (releaseNoteNeeded) {
1:                     out.write("missing");
1:                 } else {
1:                     out.write("null");
1:                 }
1:             }
1:             out.newLine();
1:             count++;
1:         }
1: 
1:         // Write some more status
1:         out.write("// Issues written: " + count);
1:         out.newLine();
1:         out.write("// Issues disqualified: ");
1:         if (excludeFixVersions == null) {
1:             out.write("disqualification disabled");
1:         } else {
1:             out.write(Integer.toString(issues.length - count));
1:         }
1:         out.newLine();
1:         out.write("// Issues with release note: " + issuesWithReleaseNote);
1:         out.newLine();
1:         out.close();
1: 
1:         // Log some basic information
1:         log("wrote " + count + " issues, " + issuesWithReleaseNote +
1:                 " with release notes, " + (issues.length - count) +
1:                 " issues disqualified");
0:         log("dump file: " + new File(destFile).getAbsolutePath());
1:         return count;
1:     }
1: 
1:     /**
1:      * Returns the version object for the specified Derby version.
1:      *
1:      * @param version target version
1:      * @return A version object.
1:      * @throws IllegalArgumentException if the specified version doesn't exist
1:      */
1:     private DerbyVersion getVersion(String version) {
1:         DerbyVersion match = null;
1:         for (int i=0; i < allVersions.length; i++) {
1:             if (version.equals(allVersions[i].getVersion())) {
1:                 match = allVersions[i];
1:             }
1:         }
1:         if (match == null) {
1:             throw new IllegalArgumentException(
1:                     "version '" + version + "' doesn't exist");
1:         }
1:         return  match;
1:     }
1: 
1:     /**
1:      * Computes the ancestors for the specified version.
1:      *
1:      * @param parent the initial parent version
1:      * @return A list of ancestors for the specified version.
1:      */
1:     private DerbyVersion[] getAncestors(DerbyVersion parent) {
1:         ArrayList ancestors = new ArrayList();
1:         DerbyVersion[] dv = getSortedAndFilteredReleases(parent);
0:         if (!parent.isReleased() && dv.length > 0) {
1:             ancestors.add(dv[0]);
1:         }
0:         while (dv.length > 1 && dv[0].compareTo(ancestorCutOff) >= 0) {
1:             dv = getSortedAndFilteredReleases(dv[1]);
1:             ancestors.add(dv[0]);
1:         }
1:         dv = new DerbyVersion[ancestors.size()];
1:         ancestors.toArray(dv);
1:         return dv;
1:     }
1: 
1:     /**
1:      * Returns a list of sorted and filtered Derby releases.
1:      * <p>
1:      * If a target release is specified, all later releases will be filtered
1:      * out. The filtering happens at two levels:
1:      * <ul> <li>version number (i.e. 10.6.2.1 > 10.5.1.0)</li>
1:      *      <li>release date</li>
1:      * </ul>
0:      * If the target version has been released, it will be placed at index zero.
0:      * If the target version hasn't been released, it will not be included in
0:      * the list.
1:      * <p>
1:      * Not specifying a target version will return all Derby releases sorted by
1:      * version number.
1:      *
1:      * @param target target version to start sorting/filtering at (may be null)
1:      * @return A list of previous releases, sorted by version number
1:      *      (highest first).
1:      */
1:     private DerbyVersion[] getSortedAndFilteredReleases(DerbyVersion target) {
1:         // Add versions to the list, filtering as specified.
1:         ArrayList tmp = new ArrayList();
1:         for (int i=0; i < allVersions.length; i++) {
1:             DerbyVersion dv = allVersions[i];
1:             // Skip versions that haven't been released.
0:             if (!dv.isReleased()) {
1:                 continue;
1:             }
1:             if (target != null) {
1:                 if (dv.compareTo(target) > 0) {
1:                     continue;
1:                 }
1:                 if (target.isReleased() && dv.getReleaseDateMillis() >
1:                         target.getReleaseDateMillis()) {
1:                     continue;
1:                 }
1:             }
1:             tmp.add(dv);
1:         }
1:         // Sort, then reverse to get newest version at index zero.
1:         Collections.sort(tmp);
1:         Collections.reverse(tmp);
1:         DerbyVersion[] result = new DerbyVersion[tmp.size()];
1:         tmp.toArray(result);
1:         return result;
1:     }
1: 
0:     /** Adds a leading zero if the value is less than ten. */
0:     private static String padZero(int val) {
0:         if (val < 10) {
0:             return "0" + Integer.toString(val);
1:         } else {
0:             return Integer.toString(val);
1:         }
1:     }
1: 
1:     /**
1:      * Interface for running from the command line.
1:      *
1:      * @param args see USAGE constant, or invoke with zero arguments
1:      * @throws Exception if something goes wrong
1:      */
1:     public static void main(String[] args)
1:             throws Exception {
1:         // Always require JIRA user name and password.
1:         if (args.length > 2) {
1:             FilteredIssueLister client =
1:                     new FilteredIssueLister(args[0], args[1]);
1:             try {
1:                 // PRINT ANCESTORS
1:                 if (args[2].equalsIgnoreCase("ancestors")) {
1:                     if (args.length == 2) {
1:                         System.err.println("Missing version argument.");
1:                         System.exit(1);
1:                     }
1:                     client.printAncestors(args[3]);
1:                 // PRINT VERSIONS
1:                 } else if(args[2].equalsIgnoreCase("releases")) {
1:                     client.printReleases();
1:                 // RELEASE NOTES PREPARATION / GENERATE ISSUE LIST
1:                 } else {
1:                     if (args.length < 4) {
1:                         System.err.println("Missing argument(s).");
1:                         System.exit(1);
1:                     }
1:                     String[] overriddenAncestry = null;
1:                     // This is the default release target
1:                     // Args: user password version filterId dest [remove]
1:                     if (args.length > 5) {
1:                         overriddenAncestry = args[5].split(",");
1:                         if (args[0].equalsIgnoreCase("ignore")) {
1:                             overriddenAncestry = new String[0];
1:                         } else if(args[0].equalsIgnoreCase("derive")) {
1:                             overriddenAncestry = null;
1:                         }
1:                     }
1:                     client.prepareReleaseNotes(args[2], Long.parseLong(args[3]),
1:                             args[4], overriddenAncestry);
1:                 }
1:             } finally {
1:                 client.destroy();
1:             }
1:         } else {
1:             System.err.println(USAGE);
1:         }
1:     }
1: 
1:     /** Logs status/convenience messages. */
1:     private void log(String msg) {
1:         if (logOut != null) {
1:             logOut.println(msg);
1:         }
1:     }
1: 
1:     /**
1:      * Converts an array of fix versions into a string representation.
1:      *
1:      * @param fixVersions fix versions for a JIRA issue
1:      * @return A string describing all the fix versions.
1:      */
1:     private String stringifyAndCheckFixVersions(String issueKey,
1:             RemoteVersion[] fixVersions, List excludeVersions,
1:             DerbyVersion releaseVersion) {
1:         if (fixVersions.length == 0) {
1:             throw new IllegalStateException(issueKey + " has no fix version");
1:         }
1:         boolean disqualified = false;
1:         boolean sanityCheckPassed = false;
1:         StringBuffer sb = new StringBuffer();
1:         StringBuffer fixedIn = new StringBuffer(); // only used for reporting
1:         for (int i=0; i < fixVersions.length; i++) {
1:             String fv = fixVersions[i].getName();
1:             if (!sanityCheckPassed) {
1:                 DerbyVersion dv = new DerbyVersion(fixVersions[i]);
1:                 if (dv.equals(releaseVersion) ||
1:                         dv.isSameFixPack(releaseVersion)) {
1:                     sanityCheckPassed = true;
1:                 }
1:             }
1:             if (excludeVersions.contains(fv)) {
1:                 disqualified = true;
1:                 fixedIn.append(fv).append(',');
1:                 // Could return null here, but then the sanity-check may be
1:                 // bypassed.
1:             }
1:             sb.append(fv).append(',');
1:         }
1:         sb.deleteCharAt(sb.length() -1);
1: 
1:         // Sanity check to catch if an invalid JIRA filter is being used.
1:         if (!sanityCheckPassed) {
1:             throw new IllegalStateException(issueKey + " not marked as fixed " +
1:                     "in the target release version" +
1:                     releaseVersion.getVersion() + ", nor in any of the " +
1:                     "versions with the same fixpack. Invalid JIRA filter?");
1:         }
1:         if (disqualified) {
1:             if (reportDisqualifiedIssues) {
1:                 fixedIn.deleteCharAt(fixedIn.length() -1);
1:                 System.out.println(issueKey + " disqualified, " +
1:                         "already fixed in " + fixedIn.toString());
1:             }
1:             return null;
1:         } else {
1:             return sb.toString();
1:         }
1:     }
1: 
1:     /**
1:      * Tells if the issue has a release note.
1:      *
1:      * @param issue JIRA issue
1:      * @return {@code true} if the issue has a release note attached.
1:      */
1:     private static boolean hasReleaseNote(RemoteIssue issue) {
1:         String[] aNames = issue.getAttachmentNames();
1:         for (int i=0; i < aNames.length; i++) {
1:             if (aNames[i].equals(RELEASE_NOTE_NAME)) {
1:                 return true;
1:             }
1:         }
1:         return false;
1:     }
1: 
1:     /**
1:      * Tells if the issue has the specified custom field value set.
1:      *
1:      * @param fieldValue the value to look for
1:      * @param values the field values
1:      * @return {@code true} if the custom field value was found,
1:      *      {@code false} otherwise.
1:      */
1:     private static boolean hasCustomField(String fieldName,
1:                                           RemoteCustomFieldValue[] values) {
1:         // The API is a but awkward when it comes to fields, but we can do our
1:         // thing by looking at the custom field values only.
1:         for (int i=0; i < values.length; i++) {
1:             String[] v = values[i].getValues();
1:             for (int j=0; j < v.length; j++) {
1:                 if (fieldName.equals(v[j])) {
1:                     return true;
1:                 }
1:             }
1:         }
1:         return false;
1:     }
1: 
1:     private static final Calendar PARSECAL = GregorianCalendar.getInstance();
1:     private static synchronized long parseDate(String date) {
1:         String[] comp = date.split("-");
1:         int year = Integer.parseInt(comp[0]);
1:         int month = Integer.parseInt(comp[1]) -1;
1:         int day = Integer.parseInt(comp[2]);
1:         PARSECAL.set(year, month, day, 0, 0, 0);
1:         return PARSECAL.getTimeInMillis();
1:     }
1: }
============================================================================