1:cbd0ff1: /*
1:fefd864: 
1:33776ff:    Derby - Class org.apache.derby.client.am.Blob
1:8055511: 
1:59bf37d:    Licensed to the Apache Software Foundation (ASF) under one or more
1:59bf37d:    contributor license agreements.  See the NOTICE file distributed with
1:59bf37d:    this work for additional information regarding copyright ownership.
1:59bf37d:    The ASF licenses this file to You under the Apache License, Version 2.0
1:59bf37d:    (the "License"); you may not use this file except in compliance with
1:59bf37d:    the License.  You may obtain a copy of the License at
1:cbd0ff1: 
1:33776ff:       http://www.apache.org/licenses/LICENSE-2.0
37:33776ff: 
1:33776ff:    Unless required by applicable law or agreed to in writing, software
1:33776ff:    distributed under the License is distributed on an "AS IS" BASIS,
1:33776ff:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:33776ff:    See the License for the specific language governing permissions and
1:33776ff:    limitations under the License.
1:33776ff: 
1:f433a64: */
1:fefd864: 
1:33776ff: package org.apache.derby.client.am;
1:a4846de: 
1:69e3d06: import java.io.ByteArrayInputStream;
1:125c328: import java.io.IOException;
1:a4846de: import java.io.InputStream;
1:1a66a1a: import java.io.OutputStream;
1:69e3d06: import java.sql.Blob;
1:d506170: import java.sql.SQLException;
1:956354d: 
1:daecc5d: import org.apache.derby.shared.common.reference.SQLState;
1:66a9818: 
1:69e3d06: public class ClientBlob extends Lob implements Blob {
1:125c328: 
1:70f7692:     //-----------------------------state------------------------------------------
1:125c328: 
1:70f7692:     byte[] binaryString_ = null;
1:a4846de: 
1:70f7692:     // Only used for input purposes.  For output, each getBinaryStream call
1:70f7692:     // must generate an independent stream.
1:69e3d06:     InputStream binaryStream_ = null;
1:70f7692:     int dataOffset_;
1:fefd864:     
1:70f7692:     //---------------------constructors/finalizer---------------------------------
1:fefd864: 
1:69e3d06:     public ClientBlob(byte[] binaryString,
1:70f7692:                 Agent agent,
1:70f7692:                 int dataOffset) {
1:fefd864:         
1:fefd864:         super(agent, 
1:fefd864:               false);
1:fefd864:         
1:70f7692:         binaryString_ = binaryString;
1:70f7692:         dataType_ |= BINARY_STRING;
1:2ef245a:         setSqlLength(binaryString.length - dataOffset);
1:70f7692:         dataOffset_ = dataOffset;
11:70f7692:     }
1:2ef245a: 
1:70f7692:     // CTOR for input:
1:0326967:     ClientBlob(Agent agent,
1:69e3d06:                 InputStream binaryStream,
1:70f7692:                 int length) {
1:125c328:         
1:fefd864:         super(agent,
1:fefd864:               false);
1:a4846de:         
1:70f7692:         binaryStream_ = binaryStream;
1:70f7692:         dataType_ |= BINARY_STREAM;
1:2ef245a:         setSqlLength(length);
1:a4846de:     }
1:1a66a1a: 
1:2ef245a:     /**
1:956354d:      * Create a new <code>Blob</code> from a stream with unknown length.
1:956354d:      * <em>Important:</em> This constructor is a temporary solution for
1:956354d:      * implementing lengthless overloads in the JDBC4 API. Before a proper
1:956354d:      * solution can be implemented, we need to enable streaming without having
1:956354d:      * to know the stream length in the DRDA protocol. See Jira DERBY-1471 and
1:956354d:      * DERBY-1417 for more details.
1:956354d:      *
1:956354d:      * <em>Shortcomings:</em> This constructor will cause the <em>whole stream
1:956354d:      * to be materialized</em> to determine its length. If the stream is big
1:956354d:      * enough, the client will fail with an OutOfMemoryError. Since this is a
1:956354d:      * temporary solution, state checking is not added to all methods as it
1:956354d:      * would clutter up the class severely. After using the constructor, the
1:956354d:      * <code>length</code>-method must be called, which will materialize the
1:956354d:      * stream and determine the length. <em>Do not pass a Blob object created
1:956354d:      * with this constructor to the user!</em>
1:c9382f0:      *
1:956354d:      * @param agent
1:956354d:      * @param binaryStream the stream to get data from
1:956354d:      */
1:0326967:     ClientBlob(Agent agent, InputStream binaryStream) {
1:956354d:         
1:fefd864:         super(agent,
1:fefd864:               isLayerBStreamingPossible(agent));
1:a4846de:         
1:956354d:         binaryStream_ = binaryStream;
1:956354d:         dataType_ |= BINARY_STREAM;
1:956354d:     }
1:fefd864:     
1:c9382f0:     /**
1:1a66a1a:      * Create a <code>Blob</code> object for a Blob value stored 
1:1a66a1a:      * on the server and indentified by <code>locator</code>.
1:1a66a1a:      * @param agent context for this Blob object (incl. connection)
1:1a66a1a:      * @param locator reference id to Blob value on server
1:1a66a1a:      */
1:69e3d06:     public ClientBlob(Agent agent, int locator)
1:1a66a1a:     {
1:1a66a1a:         super(agent, false);
1:1a66a1a:         locator_ = locator;
1:1a66a1a:         dataType_ |= LOCATOR;
1:1a66a1a:     }
1:fefd864: 
1:70f7692:     // ---------------------------jdbc 2------------------------------------------
1:fefd864: 
1:d506170:     public long length() throws SQLException {
1:125c328:         //call checkValidity to exit by throwing a SQLException if
1:125c328:         //the Blob object has been freed by calling free() on it
1:125c328:         checkValidity();
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (agent_.connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this, "length");
1:956354d:                 }
1:2ef245a: 
1:2ef245a:                 checkForClosedConnection();
1:d506170:                 long retVal = super.sqlLength();
1:2ef245a: 
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceExit(this, "length", retVal);
1:d506170:                 }
1:d506170:                 return retVal;
1:d506170:             }
1:d506170:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:1a66a1a:     
1:1a66a1a:     /**
1:1a66a1a:      * Get the length in bytes of the <code>Blob</code> value represented by 
1:1a66a1a:      * this locator based <Blob> object.  
1:1a66a1a:      * 
1:1a66a1a:      * A stored procedure call will be made to get it from the server.
1:69e3d06:      * @throws org.apache.derby.client.am.SqlException
1:1a66a1a:      * @return length of Blob in bytes
1:1a66a1a:      */
1:1a66a1a:     long getLocatorLength() throws SqlException
1:1a66a1a:     {
1:1a66a1a:         return agent_.connection_.locatorProcedureCall()
1:1a66a1a:             .blobGetLength(locator_);
1:1a66a1a:     }
1:fefd864: 
1:1a66a1a:   /**
1:f433a64:    * Returns as an array of bytes part or all of the <code>BLOB</code>
1:f433a64:    * value that this <code>Blob</code> object designates.  The byte
1:f433a64:    * array contains up to <code>length</code> consecutive bytes
1:f433a64:    * starting at position <code>pos</code>.
1:f433a64:    * The starting position must be between 1 and the length
1:f433a64:    * of the BLOB plus 1. This allows for zero-length BLOB values, from
1:f433a64:    * which only zero-length byte arrays can be returned. 
1:f433a64:    * If a larger length is requested than there are bytes available,
1:f433a64:    * characters from the start position to the end of the BLOB are returned.
1:f433a64:    * @param pos the ordinal position of the first byte in the
1:f433a64:    * <code>BLOB</code> value to be extracted; the first byte is at
1:f433a64:    * position 1
1:f433a64:    * @param length is the number of consecutive bytes to be copied
1:f433a64:    * @return a byte array containing up to <code>length</code>
1:f433a64:    * consecutive bytes from the <code>BLOB</code> value designated
1:f433a64:    * by this <code>Blob</code> object, starting with the
1:f433a64:    * byte at position <code>startPos</code>.
1:f433a64:    * @exception SQLException if there is an error accessing the
1:f433a64:    * <code>BLOB</code>
1:f433a64:    * NOTE: If the starting position is the length of the BLOB plus 1,
1:f433a64:    * zero bytess are returned regardless of the length requested.
1:125c328:    */
1:d506170:     public byte[] getBytes(long pos, int length) throws SQLException {
1:125c328:         //call checkValidity to exit by throwing a SQLException if
1:125c328:         //the Blob object has been freed by calling free() on it
1:125c328:         checkValidity();
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (agent_.connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this, "getBytes", (int) pos, length);
1:d506170:                 }
1:d506170:                 if (pos <= 0) {
1:fefd864:                     throw new SqlException(agent_.logWriter_, 
1:66527ec:                         new ClientMessageId(SQLState.BLOB_BAD_POSITION), pos);
1:d506170:                 }
1:2ef245a:                 if (pos > sqlLength() + 1) {
1:f433a64:                     throw new SqlException(agent_.logWriter_, 
1:1a66a1a:                         new ClientMessageId(SQLState.BLOB_POSITION_TOO_LARGE), 
1:66527ec:                         pos);
1:f433a64:                 }
1:d506170:                 if (length < 0) {
1:d506170:                     throw new SqlException(agent_.logWriter_, 
1:e65b4db:                         new ClientMessageId(SQLState.BLOB_NONPOSITIVE_LENGTH),
1:66527ec:                         length);
1:d506170:                 }
1:d506170:                 byte[] retVal = getBytesX(pos, length);
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceExit(this, "getBytes", retVal);
1:d506170:                 }
1:d506170:                 return retVal;
1:d506170:             }
1:daecc5d:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:daecc5d:         }
1:70f7692:     }
1:fefd864: 
1:70f7692:     private byte[] getBytesX(long pos, int length) throws SqlException {
1:70f7692:         checkForClosedConnection();
1:daecc5d: 
1:d506170:         long actualLength;
1:2ef245a:         // actual length is the lesser of the number of bytes requested
1:2ef245a:         // and the number of bytes available from pos to the end
1:2ef245a:         actualLength = Math.min(sqlLength() - pos + 1, (long) length);
1:1a66a1a:         byte[] retVal; 
1:1a66a1a:         if (isLocator()) {
1:1a66a1a:             retVal = agent_.connection_.locatorProcedureCall()
1:1a66a1a:                 .blobGetBytes(locator_, pos, (int )actualLength);
1:1a66a1a:         } else {
1:1a66a1a:             retVal = new byte[(int) actualLength];
1:1a66a1a:             System.arraycopy(binaryString_, (int) pos + dataOffset_ - 1, 
1:1a66a1a:                              retVal, 0, (int) actualLength);
1:1a66a1a:         }
1:c720ff6:         return retVal;
1:70f7692:     }
1:daecc5d: 
1:70f7692: 
1:69e3d06:     public InputStream getBinaryStream() throws SQLException {
1:125c328:         //call checkValidity to exit by throwing a SQLException if
1:125c328:         //the Blob object has been freed by calling free() on it
1:125c328:         checkValidity();
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (agent_.connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this, "getBinaryStream");
1:d506170:                 }
1:69e3d06:                 InputStream retVal = getBinaryStreamX();
1:d506170:                 if (agent_.loggingEnabled()) {
1:c9382f0:                     agent_.logWriter_.traceExit(this, "getBinaryStream", retVal);
1:d506170:                 }
1:d506170:                 return retVal;
1:d506170:             }
1:70f7692:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:69e3d06:     InputStream getBinaryStreamX() throws SqlException {
1:70f7692:         checkForClosedConnection();
1:70f7692: 
1:70f7692:         if (isBinaryStream())    // this Lob is used for input
1:70f7692:         {
1:70f7692:             return binaryStream_;
1:1a66a1a:         } else if (isLocator()) {
1:a8908bd:             //The Blob is locator enabled. Return a instance of the 
1:a8908bd:             //UpdateSensitive stream which wraps inside it a 
1:a8908bd:             //Buffered Locator stream. The wrapper watches out 
1:a8908bd:             //for updates.
1:a8908bd:             return new UpdateSensitiveBlobLocatorInputStream
1:a8908bd:                     (agent_.connection_, this);
1:1a66a1a:         } else {  // binary string
1:69e3d06:             return new ByteArrayInputStream(binaryString_, dataOffset_,
1:1a66a1a:                                            binaryString_.length - dataOffset_);
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:d506170:     public long position(byte[] pattern, long start) throws SQLException {
1:125c328:         //call checkValidity to exit by throwing a SQLException if
1:125c328:         //the Blob object has been freed by calling free() on it
1:125c328:         checkValidity();
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (agent_.connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this, "position(byte[], long)", pattern, start);
1:d506170:                 }
1:d506170:                 if (pattern == null) {
1:d506170:                     throw new SqlException(agent_.logWriter_, 
1:e65b4db:                         new ClientMessageId(SQLState.BLOB_NULL_PATTERN_OR_SEARCH_STR));
1:d506170:                 }
1:f433a64:                 if (start < 1) {
1:f433a64:                     throw new SqlException(agent_.logWriter_, 
1:66527ec:                         new ClientMessageId(SQLState.BLOB_BAD_POSITION), start);
1:f433a64:                 }
1:d506170:                 long pos = positionX(pattern, start);
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceExit(this, "position(byte[], long)", pos);
1:f433a64:                 }
1:d506170:                 return pos;
1:d506170:             }
1:d506170:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:70f7692:     private long positionX(byte[] pattern, long start) throws SqlException {
1:70f7692:         checkForClosedConnection();
1:70f7692: 
1:1a66a1a:         if (isLocator()) {
1:1a66a1a:             return agent_.connection_.locatorProcedureCall()
1:1a66a1a:                 .blobGetPositionFromBytes(locator_, pattern, start);
1:1a66a1a:         } else {
1:1a66a1a:             return binaryStringPosition(pattern, start);
1:1a66a1a:         }
1:70f7692:     }
1:70f7692: 
1:69e3d06:     public long position(Blob pattern, long start) throws SQLException {
1:125c328:         //call checkValidity to exit by throwing a SQLException if
1:125c328:         //the Blob object has been freed by calling free() on it
1:125c328:         checkValidity();
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (agent_.connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this, "position(Blob, long)", pattern, start);
1:d506170:                 }
1:d506170:                 if (pattern == null) {
1:f433a64:                     throw new SqlException(agent_.logWriter_, 
1:e65b4db:                         new ClientMessageId(SQLState.BLOB_NULL_PATTERN_OR_SEARCH_STR));
1:d506170:                 }
1:f433a64:                 if (start < 1) {
1:d506170:                     throw new SqlException(agent_.logWriter_, 
1:66527ec:                         new ClientMessageId(SQLState.BLOB_BAD_POSITION), start);
1:d506170:                 }
1:d506170:                 long pos = positionX(pattern, start);
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceExit(this, "position(Blob, long)", pos);
1:d506170:                 }
1:d506170:                 return pos;
1:70f7692:             }
1:70f7692:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:69e3d06:     private long positionX(Blob pattern, long start) throws SqlException {
1:70f7692:         checkForClosedConnection();
1:70f7692: 
1:c720ff6:         try {
1:1a66a1a:             if (isLocator()) {
1:69e3d06:                 if ((pattern instanceof ClientBlob)
1:69e3d06:                     && ((ClientBlob )pattern).isLocator()) {
1:1a66a1a:                     // Send locator for pattern to server
1:1a66a1a:                     return agent_.connection_.locatorProcedureCall()
1:69e3d06:                         .blobGetPositionFromLocator(
1:69e3d06:                             locator_,
1:69e3d06:                             ((ClientBlob )pattern).getLocator(),
1:69e3d06:                             start);
1:1a66a1a:                 } else {
1:1a66a1a:                     // Convert pattern to byte array before sending to server
1:1a66a1a:                     return agent_.connection_.locatorProcedureCall()
1:1a66a1a:                         .blobGetPositionFromBytes(locator_, 
1:1a66a1a:                                   pattern.getBytes(1L, (int )pattern.length()),
1:2ef245a:                                   start);
1:c720ff6:                 }
1:1a66a1a:             } else { 
1:1a66a1a:                 return binaryStringPosition(
1:1a66a1a:                                   pattern.getBytes(1L, (int )pattern.length()),
3:1a66a1a:                                   start);
1:1a66a1a:             }
1:69e3d06:         } catch (SQLException e) {
1:b2a1747:             throw new SqlException(e);
1:1a66a1a:         }
1:d506170:     }
1:33776ff: 
1:33776ff:     // -------------------------- JDBC 3.0 -----------------------------------
1:33776ff: 
1:33776ff: 
1:d506170:     public int setBytes(long pos, byte[] bytes) throws SQLException {
1:125c328:         //call checkValidity to exit by throwing a SQLException if
1:125c328:         //the Blob object has been freed by calling free() on it
1:125c328:         checkValidity();
1:d506170:         try
1:d506170:         {
1:c720ff6:             synchronized (agent_.connection_) {
1:c720ff6:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this, "setBytes", (int) pos, bytes);
1:d506170:                 }
1:d506170:                 int length = setBytesX(pos, bytes, 0, bytes.length);
1:1a66a1a:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceExit(this, "setBytes", length);
1:d506170:                 }
1:d506170:                 return length;
1:d506170:             }
1:70f7692:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:33776ff: 
1:d506170:     public int setBytes(long pos, byte[] bytes, int offset, int len) throws SQLException {
1:125c328:         //call checkValidity to exit by throwing a SQLException if
1:125c328:         //the Blob object has been freed by calling free() on it
1:125c328:         checkValidity();
1:d506170:         try
1:d506170:         {
1:1a66a1a:             synchronized (agent_.connection_) {
2:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this, "setBytes", (int) pos, bytes, offset, len);
1:d506170:                 }
1:d506170:                 int length = setBytesX(pos, bytes, offset, len);
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceExit(this, "setBytes", length);
1:d506170:                 }
1:d506170:                 return length;
1:d506170:             }
1:70f7692:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:33776ff: 
1:0326967:     int setBytesX(long pos, byte[] bytes, int offset, int len)
1:0326967:             throws SqlException {
1:125c328:         /*
1:cbd0ff1:             Check if position is less than 0 and if true
1:cbd0ff1:             raise an exception
1:cbd0ff1:          */
1:cbd0ff1:         
1:cbd0ff1:         if (pos <= 0L) {
1:d506170:             throw new SqlException(agent_.logWriter_,
1:66527ec:                     new ClientMessageId(SQLState.BLOB_BAD_POSITION), pos);
1:70f7692:         }
1:33776ff:         
1:cbd0ff1:         /*
1:cbd0ff1:            Currently only 2G-1 bytes can be inserted in a
1:cbd0ff1:            single Blob column hence check corresponding position
1:cbd0ff1:            value
1:cbd0ff1:          */
1:cbd0ff1:         
1:cbd0ff1:         if (pos  >= Integer.MAX_VALUE) {
1:cbd0ff1:             throw new SqlException(agent_.logWriter_,
1:66527ec:                     new ClientMessageId(SQLState.BLOB_POSITION_TOO_LARGE), pos);
1:cbd0ff1:         }
1:cbd0ff1:         
1:1a66a1a:         if (pos - 1 > sqlLength()) {
1:cbd0ff1:             throw new SqlException(agent_.logWriter_,
1:66527ec:                     new ClientMessageId(SQLState.BLOB_POSITION_TOO_LARGE), pos);
1:70f7692:         }
1:cbd0ff1:         
1:daecc5d:         if ((offset < 0) || offset > bytes.length )
1:daecc5d:         {
1:daecc5d:             throw new SqlException(agent_.logWriter_,
1:66527ec:                 new ClientMessageId(SQLState.BLOB_INVALID_OFFSET), offset);
1:daecc5d:         }
1:daecc5d:         if ( len < 0 ) {
1:daecc5d:             throw new SqlException(agent_.logWriter_,
1:66527ec:                 new ClientMessageId(SQLState.BLOB_NONPOSITIVE_LENGTH), len);
1:70f7692:         }
1:70f7692:         if (len == 0) {
1:70f7692:             return 0;
1:2d3a136:         }
1:24400cd:         if (len > bytes.length - offset) {
1:2d3a136:             throw new SqlException(agent_.logWriter_,
1:66527ec:                     new ClientMessageId(SQLState.BLOB_LENGTH_TOO_LONG), len);
1:70f7692:         }   
1:1a66a1a:         
1:be49cca:         final int length = Math.min((bytes.length - offset), len);
1:be49cca: 
1:1a66a1a:         if (isLocator()) {  
1:1a66a1a:             byte[] ba = bytes;
1:1a66a1a:             if ((offset > 0) || (length < bytes.length)) { 
1:1a66a1a:                 // Copy the part we will use into a new array
1:1a66a1a:                 ba = new byte[length];
1:1a66a1a:                 System.arraycopy(bytes, offset, ba, 0, length);
1:1a66a1a:             }
1:1a66a1a:             agent_.connection_.locatorProcedureCall()
1:1a66a1a:                 .blobSetBytes(locator_, pos, length, ba);
1:1a66a1a:             if (pos+length-1 > sqlLength()) { // Wrote beyond the old end
1:1a66a1a:                 // Update length
1:1a66a1a:                 setSqlLength(pos + length - 1);
1:1a66a1a:             } 
1:a8908bd:             //The Blob value has been
1:a8908bd:             //modified. Increment the
1:a8908bd:             //updateCount to reflect the
1:a8908bd:             //change.
1:a8908bd:             incrementUpdateCount();
1:1a66a1a:         } else {
1:1a66a1a:             if ((binaryString_.length - dataOffset_ - (int)pos + 1) < length) {
1:1a66a1a:                 byte newbuf[] = new byte[(int) pos + length + dataOffset_ - 1];
1:1a66a1a:                 System.arraycopy(binaryString_, 0, 
1:1a66a1a:                                  newbuf, 0, binaryString_.length);
1:1a66a1a:                 binaryString_ = newbuf;
1:1a66a1a:             }
1:33776ff: 
1:1a66a1a:             System.arraycopy(bytes, offset, 
1:1a66a1a:                              binaryString_, (int) pos + dataOffset_ - 1, 
1:c720ff6:                              length);
1:69e3d06:             binaryStream_ = new ByteArrayInputStream(binaryString_);
1:2ef245a:             setSqlLength(binaryString_.length - dataOffset_);
1:1a66a1a:         }
3:70f7692:         return length;
1:70f7692:     }
1:33776ff: 
1:69e3d06:     public OutputStream setBinaryStream(long pos) throws SQLException {
1:125c328:         //call checkValidity to exit by throwing a SQLException if
1:125c328:         //the Blob object has been freed by calling free() on it
1:125c328:         checkValidity();
1:1a66a1a:         try {
1:d506170:             synchronized (agent_.connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:1a66a1a:                     agent_.logWriter_.traceEntry(this, "setBinaryStream", (int) pos);
1:1a66a1a:                 }
1:1a66a1a:                 if (pos < 1) {
1:1a66a1a:                     throw new SqlException(agent_.logWriter_,
1:1a66a1a:                             new ClientMessageId(SQLState.BLOB_BAD_POSITION),
1:66527ec:                             pos);
1:1a66a1a:                 }
1:1a66a1a:                 
1:1a66a1a:                 OutputStream outStream;
1:1a66a1a:                 if (isLocator()) {
1:1a66a1a:                     outStream = new BlobLocatorOutputStream(agent_.connection_,
1:c720ff6:                                                             this,
1:1a66a1a:                                                             pos);
1:1a66a1a:                 } else {
1:1a66a1a:                     outStream = new BlobOutputStream(this, pos);
1:1a66a1a:                 }
1:33776ff: 
1:c720ff6:                 if (agent_.loggingEnabled()) {
1:1a66a1a:                     agent_.logWriter_.traceExit(this, 
1:1a66a1a:                                                 "setBinaryStream", 
1:1a66a1a:                                                 outStream);
1:1a66a1a:                 }
1:1a66a1a:                 return outStream;
1:70f7692:             }
1:1a66a1a:         } catch ( SqlException se ) {
1:1a66a1a:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:d506170:     public void truncate(long len) throws SQLException {
1:125c328:         //call checkValidity to exit by throwing a SQLException if
1:125c328:         //the Blob object has been freed by calling free() on it
1:125c328:         checkValidity();
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (agent_.connection_) {
1:1a66a1a:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this, " truncate", (int) len);
1:d506170:                 }
1:2ef245a:                 if (len < 0 || len > sqlLength()) {
1:d506170:                     throw new SqlException(agent_.logWriter_,
1:e65b4db:                         new ClientMessageId(SQLState.INVALID_API_PARAMETER),
1:66527ec:                         len, "len", "Blob.truncate()");
1:d506170:                 }
1:2ef245a:                 if (len == this.sqlLength()) {
1:d506170:                     return;
1:d506170:                 }
1:1a66a1a:                 if (isLocator()) {
1:1a66a1a:                     agent_.connection_.locatorProcedureCall()
1:1a66a1a:                         .blobTruncate(locator_, len);
1:1a66a1a:                     setSqlLength(len);
1:a8908bd:                     //The Blob value has been
1:a8908bd:                     //updated Increment the
1:a8908bd:                     //update count to reflect
1:a8908bd:                     //the change.
1:a8908bd:                     incrementUpdateCount();
1:1a66a1a:                 } else {
1:1a66a1a:                     long newLength = (int) len + dataOffset_;
1:1a66a1a:                     byte newbuf[] = new byte[(int) len + dataOffset_];
1:1a66a1a:                     System.arraycopy(binaryString_, 0, 
1:1a66a1a:                                      newbuf, 0, (int) newLength);
1:1a66a1a:                     binaryString_ = newbuf;
1:1a66a1a:                     binaryStream_ 
1:69e3d06:                         = new ByteArrayInputStream(binaryString_);
1:2ef245a:                     setSqlLength(binaryString_.length - dataOffset_);
1:1a66a1a:                 }
1:d506170:             }
1:70f7692:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:a4846de:     // -------------------------- JDBC 4.0 -----------------------------------
1:125c328:     
1:956354d:     /**
1:125c328:      * This method frees the <code>Blob</code> object and releases the resources that 
1:125c328:      * it holds. The object is invalid once the <code>free</code>
1:125c328:      * method is called. If <code>free</code> is called multiple times, the subsequent
1:125c328:      * calls to <code>free</code> are treated as a no-op.
1:956354d:      * 
1:125c328:      * @throws SQLException if an error occurs releasing
1:125c328:      * the Blob's resources
1:125c328:      */
1:a4846de:     public void free()
1:a4846de:         throws SQLException {
1:125c328:         
1:125c328:         //calling free() on a already freed object is treated as a no-op
1:8055511:         if (!isValid_) return;
1:125c328:         
1:125c328:         //now that free has been called the Blob object is no longer
1:125c328:         //valid
1:8055511:         isValid_ = false;
1:1a66a1a:         try {            
1:1a66a1a:             synchronized (agent_.connection_) {
1:1a66a1a:                 if (agent_.loggingEnabled()) {
1:1a66a1a:                     agent_.logWriter_.traceEntry(this, "free");
1:1a66a1a:                 }
1:1a66a1a:                 if (isBinaryStream()) {
1:1a66a1a:                     try {
1:1a66a1a:                         binaryStream_.close();
1:1a66a1a:                     } catch(IOException ioe) {
1:1a66a1a:                         throw new SqlException(null, new ClientMessageId(
1:1a66a1a:                                              SQLState.IO_ERROR_UPON_LOB_FREE));
1:1a66a1a:                     }
1:1a66a1a:                 } else if (isLocator()) {
1:1a66a1a:                     agent_.connection_.locatorProcedureCall()
1:1a66a1a:                         .blobReleaseLocator(locator_);
1:1a66a1a:                 } else {
1:1a66a1a:                     binaryString_ = null;
1:1a66a1a:                 }
1:125c328:             }
1:1a66a1a:         } catch (SqlException se) {
1:1a66a1a:             throw se.getSQLException();
1:125c328:         }
1:125c328:     }
1:8055511: 
1:125c328:     /**
1:c9382f0:      * Returns an <code>InputStream</code> object that contains a partial <code>
1:c9382f0:      * Blob</code> value, starting  with the byte specified by pos,
1:c9382f0:      * which is length bytes in length.
1:c9382f0:      *
1:c9382f0:      * @param pos the offset to the first byte of the partial value to
1:c9382f0:      * be retrieved. The first byte in the <code>Blob</code> is at position 1.
1:c9382f0:      * @param length the length in bytes of the partial value to be retrieved
1:c9382f0:      * @return <code>InputStream</code> through which the partial
1:c9382f0:      * <code>Blob</code> value can be read.
1:c9382f0:      * @throws SQLException if pos is less than 1 or if pos is greater than
1:418a799:      * the number of bytes in the {@code Blob} or if {@code pos + length} is
1:418a799:      * greater than {@code Blob.length() +1}
1:c9382f0:      */
1:a4846de:     public InputStream getBinaryStream(long pos, long length)
1:a4846de:         throws SQLException {
1:c9382f0:         //call checkValidity to exit by throwing a SQLException if
1:c9382f0:         //the Blob object has been freed by calling free() on it
1:c9382f0:         checkValidity();
1:125c328:         try {
1:c9382f0:             synchronized (agent_.connection_) {
1:c9382f0:                 if (agent_.loggingEnabled()) {
1:c9382f0:                     agent_.logWriter_.traceEntry(this, "getBinaryStream",
1:c9382f0:                                                  (int) pos, length);
1:c9382f0:                 }
1:c9382f0:                 checkPosAndLength(pos, length);
1:c720ff6:                 
1:c720ff6:                 InputStream retVal;
1:c720ff6:                 if (isLocator()) {
1:a8908bd:                     //The Blob is locator enabled. Return an
1:a8908bd:                     //instance of the update sensitive stream
1:a8908bd:                     //that wraps inside it a Buffered InputStream.
1:a8908bd:                     //The wrapper watches out for updates to the
1:a8908bd:                     //underlying Blob.
1:a8908bd:                     retVal = new UpdateSensitiveBlobLocatorInputStream
1:a8908bd:                                                       (agent_.connection_,
1:05d610e:                                                        this,
1:05d610e:                                                        pos,
1:a8908bd:                                                        length);
1:c720ff6:                 } else {  // binary string
1:69e3d06:                     retVal = new ByteArrayInputStream
1:c720ff6:                         (binaryString_, 
1:c720ff6:                          (int)(dataOffset_ + pos - 1), 
1:c720ff6:                          (int)length);
1:c9382f0:                 }
1:c720ff6:                 
1:c9382f0:                 if (agent_.loggingEnabled()) {
1:c720ff6:                     agent_.logWriter_.traceExit(this, 
1:c720ff6:                                                 "getBinaryStream", 
1:c720ff6:                                                 retVal);
1:c9382f0:                 }
1:c9382f0:                 return retVal;
1:c720ff6:             }
1:c720ff6:         } catch ( SqlException se ) {
1:c720ff6:             throw se.getSQLException();
1:c720ff6:         }
1:c720ff6: 
1:125c328:     }
1:125c328: 
1:70f7692:     //------------------ Material layer event callback methods -------------------
1:a4846de: 
1:70f7692:     //---------------------------- helper methods --------------------------------
1:70f7692:     public boolean isBinaryString() {
1:70f7692:         return ((dataType_ & BINARY_STRING) == BINARY_STRING);
1:a4846de:     }
1:70f7692: 
1:70f7692:     public boolean isBinaryStream() {
1:70f7692:         return ((dataType_ & BINARY_STREAM) == BINARY_STREAM);
1:70f7692:     }
1:70f7692: 
1:0326967:     private long binaryStringPosition(byte[] pattern, long start) {
1:70f7692:         // perform a local byte string search, starting at start
1:70f7692:         // check that the range of comparison is valid
1:70f7692:         int index = (int) start + dataOffset_ - 1; // api start begins at 1
1:70f7692: 
1:70f7692:         while (index + pattern.length <= binaryString_.length) {
1:70f7692:             if (isSubString(pattern, index)) {
1:70f7692:                 return (long) (index - dataOffset_ + 1); // readjust for api indexing
1:70f7692:             }
1:70f7692:             index++;
1:70f7692:         }
1:70f7692:         return -1L; // not found
1:70f7692:     }
1:70f7692: 
1:70f7692:     // precondition: binaryString_ is long enough for the comparison
1:0326967:     private boolean isSubString(byte[] pattern, int index) {
1:70f7692:         for (int i = 0; i < pattern.length; i++, index++) {
1:70f7692:             if (pattern[i] != binaryString_[index]) {
1:70f7692:                 return false;
1:70f7692:             }
1:70f7692:         }
1:70f7692: 
1:70f7692:         return true;
1:125c328:     }
1:8055511: 
1:30e5317:     /**
1:2ef245a:      * Materialize the stream used for input to the database.
1:2ef245a:      *
1:2ef245a:      * @throws SqlException
1:2ef245a:      */
1:2ef245a:     protected void materializeStream() throws SqlException 
1:2ef245a:     {
1:2ef245a:         binaryStream_ = super.materializeStream(binaryStream_, "java.sql.Blob");
1:2ef245a:     }
1:2ef245a: 
1:70f7692: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:b565f41
/////////////////////////////////////////////////////////////////////////
commit:0326967
/////////////////////////////////////////////////////////////////////////
1:     ClientBlob(Agent agent,
/////////////////////////////////////////////////////////////////////////
1:     ClientBlob(Agent agent, InputStream binaryStream) {
/////////////////////////////////////////////////////////////////////////
1:     int setBytesX(long pos, byte[] bytes, int offset, int len)
1:             throws SqlException {
/////////////////////////////////////////////////////////////////////////
1:     private long binaryStringPosition(byte[] pattern, long start) {
/////////////////////////////////////////////////////////////////////////
1:     private boolean isSubString(byte[] pattern, int index) {
commit:69e3d06
/////////////////////////////////////////////////////////////////////////
1: import java.io.ByteArrayInputStream;
1: import java.sql.Blob;
1: public class ClientBlob extends Lob implements Blob {
/////////////////////////////////////////////////////////////////////////
1:     InputStream binaryStream_ = null;
1:     public ClientBlob(byte[] binaryString,
/////////////////////////////////////////////////////////////////////////
0:     public ClientBlob(Agent agent,
1:                 InputStream binaryStream,
/////////////////////////////////////////////////////////////////////////
0:     public ClientBlob(Agent agent, InputStream binaryStream) {
/////////////////////////////////////////////////////////////////////////
1:     public ClientBlob(Agent agent, int locator)
/////////////////////////////////////////////////////////////////////////
1:      * @throws org.apache.derby.client.am.SqlException
/////////////////////////////////////////////////////////////////////////
1:     public InputStream getBinaryStream() throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:                 InputStream retVal = getBinaryStreamX();
/////////////////////////////////////////////////////////////////////////
1:     InputStream getBinaryStreamX() throws SqlException {
/////////////////////////////////////////////////////////////////////////
1:             return new ByteArrayInputStream(binaryString_, dataOffset_,
/////////////////////////////////////////////////////////////////////////
1:     public long position(Blob pattern, long start) throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:     private long positionX(Blob pattern, long start) throws SqlException {
1:                 if ((pattern instanceof ClientBlob)
1:                     && ((ClientBlob )pattern).isLocator()) {
1:                         .blobGetPositionFromLocator(
1:                             locator_,
1:                             ((ClientBlob )pattern).getLocator(),
1:                             start);
/////////////////////////////////////////////////////////////////////////
1:         } catch (SQLException e) {
/////////////////////////////////////////////////////////////////////////
1:             binaryStream_ = new ByteArrayInputStream(binaryString_);
1:     public OutputStream setBinaryStream(long pos) throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:                         = new ByteArrayInputStream(binaryString_);
/////////////////////////////////////////////////////////////////////////
1:                     retVal = new ByteArrayInputStream
commit:b13b17c
/////////////////////////////////////////////////////////////////////////
commit:2ef245a
/////////////////////////////////////////////////////////////////////////
1:         setSqlLength(binaryString.length - dataOffset);
/////////////////////////////////////////////////////////////////////////
1:         setSqlLength(length);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1:                 checkForClosedConnection();
1: 
/////////////////////////////////////////////////////////////////////////
1:                 if (pos > sqlLength() + 1) {
/////////////////////////////////////////////////////////////////////////
1:         // actual length is the lesser of the number of bytes requested
1:         // and the number of bytes available from pos to the end
1:         actualLength = Math.min(sqlLength() - pos + 1, (long) length);
/////////////////////////////////////////////////////////////////////////
0:             return binaryStringPosition(pattern.getBytes(1L, 
0:                                                          (int)pattern.length()),
1:                                         start);
/////////////////////////////////////////////////////////////////////////
1:         setSqlLength(binaryString_.length - dataOffset_);
/////////////////////////////////////////////////////////////////////////
1:                 if (len < 0 || len > sqlLength()) {
1:                 if (len == this.sqlLength()) {
/////////////////////////////////////////////////////////////////////////
1:                 setSqlLength(binaryString_.length - dataOffset_);
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Materialize the stream used for input to the database.
1:      *
1:      * @throws SqlException
1:      */
1:     protected void materializeStream() throws SqlException 
1:     {
1:         binaryStream_ = super.materializeStream(binaryStream_, "java.sql.Blob");
1:     }
1: 
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:66527ec
/////////////////////////////////////////////////////////////////////////
1:                         new ClientMessageId(SQLState.BLOB_BAD_POSITION), pos);
1:                         pos);
1:                         length);
/////////////////////////////////////////////////////////////////////////
1:                         new ClientMessageId(SQLState.BLOB_BAD_POSITION), start);
/////////////////////////////////////////////////////////////////////////
1:                         new ClientMessageId(SQLState.BLOB_BAD_POSITION), start);
/////////////////////////////////////////////////////////////////////////
1:                     new ClientMessageId(SQLState.BLOB_BAD_POSITION), pos);
/////////////////////////////////////////////////////////////////////////
1:                     new ClientMessageId(SQLState.BLOB_POSITION_TOO_LARGE), pos);
1:                     new ClientMessageId(SQLState.BLOB_POSITION_TOO_LARGE), pos);
1:                 new ClientMessageId(SQLState.BLOB_INVALID_OFFSET), offset);
1:                 new ClientMessageId(SQLState.BLOB_NONPOSITIVE_LENGTH), len);
1:                     new ClientMessageId(SQLState.BLOB_LENGTH_TOO_LONG), len);
/////////////////////////////////////////////////////////////////////////
1:                             pos);
/////////////////////////////////////////////////////////////////////////
1:                         len, "len", "Blob.truncate()");
commit:24400cd
/////////////////////////////////////////////////////////////////////////
1:         if (len > bytes.length - offset) {
commit:be49cca
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         final int length = Math.min((bytes.length - offset), len);
1: 
commit:3b85b5e
/////////////////////////////////////////////////////////////////////////
0:                 new Integer(len));
commit:66a9818
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:30e5317
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * @throws SQLException if isValid is not true
commit:5b7bb25
/////////////////////////////////////////////////////////////////////////
commit:05d610e
/////////////////////////////////////////////////////////////////////////
0: import java.io.BufferedInputStream;
0: import java.io.BufferedOutputStream;
/////////////////////////////////////////////////////////////////////////
0:             return new BufferedInputStream(
0:                     new BlobLocatorInputStream(agent_.connection_, this));
/////////////////////////////////////////////////////////////////////////
0:                     retVal = new BufferedInputStream(
0:                             new BlobLocatorInputStream(agent_.connection_,
1:                                                        this,
1:                                                        pos,
0:                                                        length));
commit:c9382f0
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Returns an <code>InputStream</code> object that contains a partial <code>
1:      * Blob</code> value, starting  with the byte specified by pos,
1:      * which is length bytes in length.
1:      *
1:      * @param pos the offset to the first byte of the partial value to
1:      * be retrieved. The first byte in the <code>Blob</code> is at position 1.
1:      * @param length the length in bytes of the partial value to be retrieved
1:      * @return <code>InputStream</code> through which the partial
1:      * <code>Blob</code> value can be read.
1:      * @throws SQLException if pos is less than 1 or if pos is greater than
0:      * the number of bytes in the <code>Blob</code> or if pos + length is
0:      * greater than the number of bytes in the <code>Blob</code>
1:      *
0:      * @throws SQLException.
1:      */
1:         //call checkValidity to exit by throwing a SQLException if
1:         //the Blob object has been freed by calling free() on it
1:         checkValidity();
1:         synchronized (agent_.connection_) {
1:             if (agent_.loggingEnabled()) {
1:                 agent_.logWriter_.traceEntry(this, "getBinaryStream",
1:                     (int) pos, length);
1:             }
1:             checkPosAndLength(pos, length);
0:             InputStream retVal = new java.io.ByteArrayInputStream
0:                     (binaryString_, (int)(dataOffset_ + pos - 1), (int)length);
1:             if (agent_.loggingEnabled()) {
1:                 agent_.logWriter_.traceExit(this, "getBinaryStream", retVal);
1:             }
1:             return retVal;
1:         }
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:2d3a136
/////////////////////////////////////////////////////////////////////////
0:         if (len + offset > bytes.length) {
1:             throw new SqlException(agent_.logWriter_,
0:                     new ClientMessageId(SQLState.BLOB_LENGTH_TOO_LONG),
0:                     new Integer(len));
1:         }   
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:418a799
/////////////////////////////////////////////////////////////////////////
1:      * the number of bytes in the {@code Blob} or if {@code pos + length} is
1:      * greater than {@code Blob.length() +1}
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:8055511
/////////////////////////////////////////////////////////////////////////
1:     
/////////////////////////////////////////////////////////////////////////
1:         if (!isValid_) return;
1:         
1:         isValid_ = false;
/////////////////////////////////////////////////////////////////////////
1:     
commit:c6ed70e
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     java.io.InputStream getBinaryStreamX() throws SqlException {
/////////////////////////////////////////////////////////////////////////
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:a8908bd
/////////////////////////////////////////////////////////////////////////
1:             //The Blob is locator enabled. Return a instance of the 
1:             //UpdateSensitive stream which wraps inside it a 
1:             //Buffered Locator stream. The wrapper watches out 
1:             //for updates.
1:             return new UpdateSensitiveBlobLocatorInputStream
1:                     (agent_.connection_, this);
/////////////////////////////////////////////////////////////////////////
1:             //The Blob value has been
1:             //modified. Increment the
1:             //updateCount to reflect the
1:             //change.
1:             incrementUpdateCount();
/////////////////////////////////////////////////////////////////////////
1:                     //The Blob value has been
1:                     //updated Increment the
1:                     //update count to reflect
1:                     //the change.
1:                     incrementUpdateCount();
/////////////////////////////////////////////////////////////////////////
1:                     //The Blob is locator enabled. Return an
1:                     //instance of the update sensitive stream
1:                     //that wraps inside it a Buffered InputStream.
1:                     //The wrapper watches out for updates to the
1:                     //underlying Blob.
1:                     retVal = new UpdateSensitiveBlobLocatorInputStream
1:                                                       (agent_.connection_,
1:                                                        length);
commit:c720ff6
/////////////////////////////////////////////////////////////////////////
1:         try {
1:             synchronized (agent_.connection_) {
1:                 if (agent_.loggingEnabled()) {
0:                     agent_.logWriter_.traceEntry(this, "getBinaryStream",
0:                                                  (int) pos, length);
1:                 }
0:                 checkPosAndLength(pos, length);
1:                 
1:                 InputStream retVal;
1:                 if (isLocator()) {
0:                     retVal = new BlobLocatorInputStream(agent_.connection_, 
1:                                                         this, 
0:                                                         pos, 
1:                                                         length);
1:                 } else {  // binary string
0:                     retVal = new java.io.ByteArrayInputStream
1:                         (binaryString_, 
1:                          (int)(dataOffset_ + pos - 1), 
1:                          (int)length);
1:                 }
1:                 
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceExit(this, 
1:                                                 "getBinaryStream", 
1:                                                 retVal);
1:                 }
1:                 return retVal;
1:         } catch ( SqlException se ) {
1:             throw se.getSQLException();
1: 
commit:1a66a1a
/////////////////////////////////////////////////////////////////////////
1: import java.io.OutputStream;
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Create a <code>Blob</code> object for a Blob value stored 
1:      * on the server and indentified by <code>locator</code>.
1:      * @param agent context for this Blob object (incl. connection)
1:      * @param locator reference id to Blob value on server
1:      */
0:     public Blob(Agent agent, int locator)  
1:     {
1:         super(agent, false);
1:         locator_ = locator;
1:         dataType_ |= LOCATOR;
1:     }
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Get the length in bytes of the <code>Blob</code> value represented by 
1:      * this locator based <Blob> object.  
1:      * 
1:      * A stored procedure call will be made to get it from the server.
0:      * @throws org.apache.derby.client.am.SqlException 
1:      * @return length of Blob in bytes
1:      */
1:     long getLocatorLength() throws SqlException
1:     {
1:         return agent_.connection_.locatorProcedureCall()
1:             .blobGetLength(locator_);
1:     }
/////////////////////////////////////////////////////////////////////////
1:         byte[] retVal; 
1:         if (isLocator()) {
1:             retVal = agent_.connection_.locatorProcedureCall()
1:                 .blobGetBytes(locator_, pos, (int )actualLength);
1:         } else {
1:             retVal = new byte[(int) actualLength];
1:             System.arraycopy(binaryString_, (int) pos + dataOffset_ - 1, 
1:                              retVal, 0, (int) actualLength);
1:         }
/////////////////////////////////////////////////////////////////////////
1:         } else if (isLocator()) {
0:             return new BlobLocatorInputStream(agent_.connection_, this);
1:         } else {  // binary string
0:             return new java.io.ByteArrayInputStream(binaryString_, dataOffset_,
1:                                            binaryString_.length - dataOffset_);
/////////////////////////////////////////////////////////////////////////
1:         if (isLocator()) {
1:             return agent_.connection_.locatorProcedureCall()
1:                 .blobGetPositionFromBytes(locator_, pattern, start);
1:         } else {
1:             return binaryStringPosition(pattern, start);
1:         }
/////////////////////////////////////////////////////////////////////////
1:             if (isLocator()) {
0:                 if ((pattern instanceof Blob) 
0:                     && ((Blob )pattern).isLocator()) {
1:                     // Send locator for pattern to server
1:                     return agent_.connection_.locatorProcedureCall()
0:                         .blobGetPositionFromLocator(locator_, 
0:                                                  ((Blob )pattern).getLocator(),
1:                                                  start);
1:                 } else {
1:                     // Convert pattern to byte array before sending to server
1:                     return agent_.connection_.locatorProcedureCall()
1:                         .blobGetPositionFromBytes(locator_, 
1:                                   pattern.getBytes(1L, (int )pattern.length()),
1:                                   start);
1:                 }
1:             } else { 
1:                 return binaryStringPosition(
1:                                   pattern.getBytes(1L, (int )pattern.length()),
1:                                   start);
1:             }
/////////////////////////////////////////////////////////////////////////
1:         if (pos - 1 > sqlLength()) {
1:                          new ClientMessageId(SQLState.BLOB_POSITION_TOO_LARGE),
0:                          new Long(pos));
/////////////////////////////////////////////////////////////////////////
1:         
1:         if (isLocator()) {  
1:             byte[] ba = bytes;
1:             if ((offset > 0) || (length < bytes.length)) { 
1:                 // Copy the part we will use into a new array
1:                 ba = new byte[length];
1:                 System.arraycopy(bytes, offset, ba, 0, length);
1:             }
1:             agent_.connection_.locatorProcedureCall()
1:                 .blobSetBytes(locator_, pos, length, ba);
1:             if (pos+length-1 > sqlLength()) { // Wrote beyond the old end
1:                 // Update length
1:                 setSqlLength(pos + length - 1);
1:             } 
1:         } else {
1:             if ((binaryString_.length - dataOffset_ - (int)pos + 1) < length) {
1:                 byte newbuf[] = new byte[(int) pos + length + dataOffset_ - 1];
1:                 System.arraycopy(binaryString_, 0, 
1:                                  newbuf, 0, binaryString_.length);
1:                 binaryString_ = newbuf;
1:             }
1:             System.arraycopy(bytes, offset, 
1:                              binaryString_, (int) pos + dataOffset_ - 1, 
0:                              length);
0:             binaryStream_ = new java.io.ByteArrayInputStream(binaryString_);
0:             setSqlLength(binaryString_.length - dataOffset_);
1:         }
/////////////////////////////////////////////////////////////////////////
1:         try {
1:             synchronized (agent_.connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "setBinaryStream", (int) pos);
1:                 }
1:                 if (pos < 1) {
1:                     throw new SqlException(agent_.logWriter_,
1:                             new ClientMessageId(SQLState.BLOB_BAD_POSITION),
0:                             new Long(pos));
1:                 }
1:                 
1:                 OutputStream outStream;
1:                 if (isLocator()) {
1:                     outStream = new BlobLocatorOutputStream(agent_.connection_,
0:                                                             this,
1:                                                             pos);
1:                 } else {
1:                     outStream = new BlobOutputStream(this, pos);
1:                 }
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceExit(this, 
1:                                                 "setBinaryStream", 
1:                                                 outStream);
1:                 }
1:                 return outStream;
1:         } catch ( SqlException se ) {
1:             throw se.getSQLException();
/////////////////////////////////////////////////////////////////////////
1:                 if (isLocator()) {
1:                     agent_.connection_.locatorProcedureCall()
1:                         .blobTruncate(locator_, len);
1:                     setSqlLength(len);
1:                 } else {
1:                     long newLength = (int) len + dataOffset_;
1:                     byte newbuf[] = new byte[(int) len + dataOffset_];
1:                     System.arraycopy(binaryString_, 0, 
1:                                      newbuf, 0, (int) newLength);
1:                     binaryString_ = newbuf;
1:                     binaryStream_ 
0:                         = new java.io.ByteArrayInputStream(binaryString_);
0:                     setSqlLength(binaryString_.length - dataOffset_);
1:                 }
/////////////////////////////////////////////////////////////////////////
1:         try {            
1:             synchronized (agent_.connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "free");
1:                 }
1:                 if (isBinaryStream()) {
1:                     try {
1:                         binaryStream_.close();
1:                     } catch(IOException ioe) {
1:                         throw new SqlException(null, new ClientMessageId(
1:                                              SQLState.IO_ERROR_UPON_LOB_FREE));
1:                     }
1:                 } else if (isLocator()) {
1:                     agent_.connection_.locatorProcedureCall()
1:                         .blobReleaseLocator(locator_);
1:                 } else {
1:                     binaryString_ = null;
1:                 }
1:         } catch (SqlException se) {
1:             throw se.getSQLException();
commit:956354d
/////////////////////////////////////////////////////////////////////////
0: import java.util.ArrayList;
1: 
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Create a new <code>Blob</code> from a stream with unknown length.
1:      * <em>Important:</em> This constructor is a temporary solution for
1:      * implementing lengthless overloads in the JDBC4 API. Before a proper
1:      * solution can be implemented, we need to enable streaming without having
1:      * to know the stream length in the DRDA protocol. See Jira DERBY-1471 and
1:      * DERBY-1417 for more details.
1:      *
1:      * <em>Shortcomings:</em> This constructor will cause the <em>whole stream
1:      * to be materialized</em> to determine its length. If the stream is big
1:      * enough, the client will fail with an OutOfMemoryError. Since this is a
1:      * temporary solution, state checking is not added to all methods as it
1:      * would clutter up the class severely. After using the constructor, the
1:      * <code>length</code>-method must be called, which will materialize the
1:      * stream and determine the length. <em>Do not pass a Blob object created
1:      * with this constructor to the user!</em>
1:      *
1:      * @param agent
1:      * @param binaryStream the stream to get data from
1:      */
0:     public Blob(Agent agent, java.io.InputStream binaryStream) {
0:         super(agent);
1:         binaryStream_ = binaryStream;
1:         dataType_ |= BINARY_STREAM;
0:         sqlLength_ = -1;
0:         lengthObtained_ = false;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:                 // Code to handle the lengthless constructor.
0:                 if (!lengthObtained_) {
0:                     binaryStream_ = super.materializeStream(binaryStream_,
0:                                                             "java.sql.Blob");
1:                 }
commit:125c328
/////////////////////////////////////////////////////////////////////////
1: import java.io.IOException;
1:     
0:     //This boolean variable indicates whether the Blob object has
0:     //been invalidated by calling free() on it
0:     private boolean isValid = true;
1:     
/////////////////////////////////////////////////////////////////////////
1:         //call checkValidity to exit by throwing a SQLException if
1:         //the Blob object has been freed by calling free() on it
1:         checkValidity();
/////////////////////////////////////////////////////////////////////////
1:         //call checkValidity to exit by throwing a SQLException if
1:         //the Blob object has been freed by calling free() on it
1:         checkValidity();
/////////////////////////////////////////////////////////////////////////
1:         //call checkValidity to exit by throwing a SQLException if
1:         //the Blob object has been freed by calling free() on it
1:         checkValidity();
/////////////////////////////////////////////////////////////////////////
1:         //call checkValidity to exit by throwing a SQLException if
1:         //the Blob object has been freed by calling free() on it
1:         checkValidity();
/////////////////////////////////////////////////////////////////////////
1:         //call checkValidity to exit by throwing a SQLException if
1:         //the Blob object has been freed by calling free() on it
1:         checkValidity();
/////////////////////////////////////////////////////////////////////////
1:         //call checkValidity to exit by throwing a SQLException if
1:         //the Blob object has been freed by calling free() on it
1:         checkValidity();
/////////////////////////////////////////////////////////////////////////
1:         //call checkValidity to exit by throwing a SQLException if
1:         //the Blob object has been freed by calling free() on it
1:         checkValidity();
/////////////////////////////////////////////////////////////////////////
1:         //call checkValidity to exit by throwing a SQLException if
1:         //the Blob object has been freed by calling free() on it
1:         checkValidity();
/////////////////////////////////////////////////////////////////////////
1:         //call checkValidity to exit by throwing a SQLException if
1:         //the Blob object has been freed by calling free() on it
1:         checkValidity();
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * This method frees the <code>Blob</code> object and releases the resources that 
1:      * it holds. The object is invalid once the <code>free</code>
1:      * method is called. If <code>free</code> is called multiple times, the subsequent
1:      * calls to <code>free</code> are treated as a no-op.
0:      * 
1:      * @throws SQLException if an error occurs releasing
1:      * the Blob's resources
1:      */
1:         
1:         //calling free() on a already freed object is treated as a no-op
0:         if (!isValid) return;
1:         
1:         //now that free has been called the Blob object is no longer
1:         //valid
0:         isValid = false;
1:         
0:         if(isBinaryStream()) {
1:             try {
0:                 binaryStream_.close();
1:             }
0:             catch(IOException ioe) {
0:                 throw new SqlException(null, new ClientMessageId(SQLState.IO_ERROR_UPON_LOB_FREE)).getSQLException();
1:             }
1:         }
0:         else {
0:             binaryString_ = null;
1:         }
/////////////////////////////////////////////////////////////////////////
1:     
1:     /*
0:      * Checks is isValid is true. If it is not true throws 
0:      * a SQLException stating that a method has been called on
0:      * an invalid LOB object
0:      *
0:      * throws SQLException if isvalid is not true.
1:      */
0:     private void checkValidity() throws SQLException{
0:         if(!isValid)
0:             throw new SqlException(null,new ClientMessageId(SQLState.LOB_OBJECT_INVALID))
0:                                                   .getSQLException();
1:     }
commit:a4846de
/////////////////////////////////////////////////////////////////////////
1: import java.io.InputStream;
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:     // -------------------------- JDBC 4.0 -----------------------------------
1: 
1:     public void free()
1:         throws SQLException {
0:         throw SQLExceptionFactory.notImplemented("free()");
1:     }
1: 
1:     public InputStream getBinaryStream(long pos, long length)
1:         throws SQLException {
0:         throw SQLExceptionFactory.notImplemented("getBinaryStream(long,long)");
1:     }
1: 
commit:cbd0ff1
/////////////////////////////////////////////////////////////////////////
1:         
1:         /*
1:             Check if position is less than 0 and if true
1:             raise an exception
1:          */
1:         
1:         if (pos <= 0L) {
0:                     new MessageId(SQLState.BLOB_BAD_POSITION), new Long(pos));
1:         /*
1:            Currently only 2G-1 bytes can be inserted in a
1:            single Blob column hence check corresponding position
1:            value
1:          */
1:         
1:         if (pos  >= Integer.MAX_VALUE) {
1:             throw new SqlException(agent_.logWriter_,
0:                     new MessageId(SQLState.BLOB_POSITION_TOO_LARGE), new Long(pos));
1:         
0:         if (pos - 1 > binaryString_.length - dataOffset_) {
1:             throw new SqlException(agent_.logWriter_,
0:                     new MessageId(SQLState.BLOB_POSITION_TOO_LARGE), new Long(pos));
1:         }
1:         
author:Tomohito Nakayama
-------------------------------------------------------------------------------
commit:fefd864
/////////////////////////////////////////////////////////////////////////
1:     
1:         
1:         super(agent, 
1:               false);
1:         
/////////////////////////////////////////////////////////////////////////
1:         
1:         super(agent,
1:               false);
1:         
/////////////////////////////////////////////////////////////////////////
1:         
1:         super(agent,
1:               isLayerBStreamingPossible(agent));
1:         
1:         
/////////////////////////////////////////////////////////////////////////
1:                     
0:                     if( willBeLayerBStreamed() )
1:                         throw new SqlException(agent_.logWriter_,
0:                                                LOB_OBJECT_LENGTH_UNKNOWN_YET);
1:                     
/////////////////////////////////////////////////////////////////////////
1:     
author:David Van Couvering
-------------------------------------------------------------------------------
commit:f433a64
/////////////////////////////////////////////////////////////////////////
0:   /**
1:    * Returns as an array of bytes part or all of the <code>BLOB</code>
1:    * value that this <code>Blob</code> object designates.  The byte
1:    * array contains up to <code>length</code> consecutive bytes
1:    * starting at position <code>pos</code>.
1:    * The starting position must be between 1 and the length
1:    * of the BLOB plus 1. This allows for zero-length BLOB values, from
1:    * which only zero-length byte arrays can be returned. 
1:    * If a larger length is requested than there are bytes available,
1:    * characters from the start position to the end of the BLOB are returned.
1:    * @param pos the ordinal position of the first byte in the
1:    * <code>BLOB</code> value to be extracted; the first byte is at
1:    * position 1
1:    * @param length is the number of consecutive bytes to be copied
1:    * @return a byte array containing up to <code>length</code>
1:    * consecutive bytes from the <code>BLOB</code> value designated
1:    * by this <code>Blob</code> object, starting with the
1:    * byte at position <code>startPos</code>.
1:    * @exception SQLException if there is an error accessing the
1:    * <code>BLOB</code>
1:    * NOTE: If the starting position is the length of the BLOB plus 1,
1:    * zero bytess are returned regardless of the length requested.
1:    */
/////////////////////////////////////////////////////////////////////////
0:                 if (pos > this.length() + 1) {
1:                     throw new SqlException(agent_.logWriter_, 
0:                         new ClientMessageId(SQLState.BLOB_POSITION_TOO_LARGE), 
0:                         new Long(pos));
1:                 }
/////////////////////////////////////////////////////////////////////////
0:             // actual length is the lesser of the number of bytes requested
0:             // and the number of bytes available from pos to the end
/////////////////////////////////////////////////////////////////////////
1:                 if (start < 1) {
1:                     throw new SqlException(agent_.logWriter_, 
0:                         new ClientMessageId(SQLState.BLOB_BAD_POSITION), 
0:                             new Long(start));
1:                 }
/////////////////////////////////////////////////////////////////////////
1:                 if (start < 1) {
1:                     throw new SqlException(agent_.logWriter_, 
0:                         new ClientMessageId(SQLState.BLOB_BAD_POSITION), 
0:                             new Long(start));
1:                 }
commit:b2a1747
/////////////////////////////////////////////////////////////////////////
1:             throw new SqlException(e);
commit:e65b4db
/////////////////////////////////////////////////////////////////////////
0:                         new ClientMessageId(SQLState.BLOB_BAD_POSITION), 
1:                         new ClientMessageId(SQLState.BLOB_NONPOSITIVE_LENGTH),
/////////////////////////////////////////////////////////////////////////
1:                         new ClientMessageId(SQLState.BLOB_NULL_PATTERN_OR_SEARCH_STR));
/////////////////////////////////////////////////////////////////////////
1:                         new ClientMessageId(SQLState.BLOB_NULL_PATTERN_OR_SEARCH_STR));
/////////////////////////////////////////////////////////////////////////
0:                     new ClientMessageId(SQLState.BLOB_BAD_POSITION), new Long(pos));
/////////////////////////////////////////////////////////////////////////
0:                     new ClientMessageId(SQLState.BLOB_POSITION_TOO_LARGE), new Long(pos));
0:                     new ClientMessageId(SQLState.BLOB_POSITION_TOO_LARGE), new Long(pos));
0:                 new ClientMessageId(SQLState.BLOB_INVALID_OFFSET), 
0:                 new ClientMessageId(SQLState.BLOB_NONPOSITIVE_LENGTH),
/////////////////////////////////////////////////////////////////////////
1:                         new ClientMessageId(SQLState.INVALID_API_PARAMETER),
commit:e6936ea
/////////////////////////////////////////////////////////////////////////
0:                         new MessageId(SQLState.BLOB_NULL_PATTERN_OR_SEARCH_STR));
/////////////////////////////////////////////////////////////////////////
0:                         new MessageId(SQLState.BLOB_NULL_PATTERN_OR_SEARCH_STR));
/////////////////////////////////////////////////////////////////////////
0:                 new MessageId(SQLState.BLOB_INVALID_OFFSET), 
commit:d506170
/////////////////////////////////////////////////////////////////////////
1: import java.sql.SQLException;
/////////////////////////////////////////////////////////////////////////
1:     public long length() throws SQLException {
1:         try
1:         {
1:             synchronized (agent_.connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "length");
1:                 }
1:                 long retVal = super.sqlLength();
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceExit(this, "length", retVal);
1:                 }
1:                 return retVal;
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
1:     public byte[] getBytes(long pos, int length) throws SQLException {
1:         try
1:         {
1:             synchronized (agent_.connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "getBytes", (int) pos, length);
1:                 }
1:                 if (pos <= 0) {
1:                     throw new SqlException(agent_.logWriter_, 
0:                         new MessageId(SQLState.BLOB_BAD_POSITION), 
0:                         new Long(pos));
1:                 }
1:                 if (length < 0) {
1:                     throw new SqlException(agent_.logWriter_, 
0:                         new MessageId(SQLState.BLOB_NONPOSITIVE_LENGTH),
0:                         new Integer(length));
1:                 }
1:                 byte[] retVal = getBytesX(pos, length);
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceExit(this, "getBytes", retVal);
1:                 }
1:                 return retVal;
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
/////////////////////////////////////////////////////////////////////////
1:         long actualLength;
0:         try {
0:             actualLength = Math.min(this.length() - pos + 1, (long) length);
0:         } catch ( SQLException se ) {
0:             throw new SqlException(se);
1:         }
/////////////////////////////////////////////////////////////////////////
0:     public java.io.InputStream getBinaryStream() throws SQLException {
1:         try
1:         {
1:             synchronized (agent_.connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "getBinaryStream");
1:                 }
0:                 java.io.InputStream retVal = getBinaryStreamX();
1:                 if (agent_.loggingEnabled()) {
0:                     agent_.logWriter_.traceExit(this, "getBinaryStream", retVal);
1:                 }
1:                 return retVal;
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
/////////////////////////////////////////////////////////////////////////
1:     public long position(byte[] pattern, long start) throws SQLException {
1:         try
1:         {
1:             synchronized (agent_.connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "position(byte[], long)", pattern, start);
1:                 }
1:                 if (pattern == null) {
1:                     throw new SqlException(agent_.logWriter_, 
0:                         new MessageId(SQLState.BLOB_NULL_PATTERN));
1:                 }
1:                 long pos = positionX(pattern, start);
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceExit(this, "position(byte[], long)", pos);
1:                 }
1:                 return pos;
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
/////////////////////////////////////////////////////////////////////////
0:     public long position(java.sql.Blob pattern, long start) throws SQLException {
1:         try
1:         {
1:             synchronized (agent_.connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "position(Blob, long)", pattern, start);
1:                 }
1:                 if (pattern == null) {
1:                     throw new SqlException(agent_.logWriter_, 
0:                         new MessageId(SQLState.BLOB_NULL_PATTERN));
1:                 }
1:                 long pos = positionX(pattern, start);
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceExit(this, "position(Blob, long)", pos);
1:                 }
1:                 return pos;
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
/////////////////////////////////////////////////////////////////////////
1:     public int setBytes(long pos, byte[] bytes) throws SQLException {
1:         try
1:         {
1:             synchronized (agent_.connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "setBytes", (int) pos, bytes);
1:                 }
1:                 int length = setBytesX(pos, bytes, 0, bytes.length);
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceExit(this, "setBytes", length);
1:                 }
1:                 return length;
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
1:     public int setBytes(long pos, byte[] bytes, int offset, int len) throws SQLException {
1:         try
1:         {
1:             synchronized (agent_.connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "setBytes", (int) pos, bytes, offset, len);
1:                 }
1:                 int length = setBytesX(pos, bytes, offset, len);
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceExit(this, "setBytes", length);
1:                 }
1:                 return length;
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
/////////////////////////////////////////////////////////////////////////
0:     public java.io.OutputStream setBinaryStream(long pos) throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:     public void truncate(long len) throws SQLException {
1:         try
1:         {
0:             synchronized (agent_.connection_) {
0:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, " truncate", (int) len);
1:                 }
0:                 if (len < 0 || len > this.length()) {
1:                     throw new SqlException(agent_.logWriter_,
0:                         new MessageId(SQLState.INVALID_API_PARAMETER),
0:                         new Long(len), "len", "Blob.truncate()");
1:                 }
0:                 if (len == this.length()) {
1:                     return;
1:                 }
0:                 long newLength = (int) len + dataOffset_;
0:                 byte newbuf[] = new byte[(int) len + dataOffset_];
0:                 System.arraycopy(binaryString_, 0, newbuf, 0, (int) newLength);
0:                 binaryString_ = newbuf;
0:                 binaryStream_ = new java.io.ByteArrayInputStream(binaryString_);
0:                 sqlLength_ = binaryString_.length - dataOffset_;
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
commit:daecc5d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.reference.SQLState;
1: 
/////////////////////////////////////////////////////////////////////////
0:             if (pos <= 0) {
1:                 throw new SqlException(agent_.logWriter_, 
0:                     new MessageId(SQLState.BLOB_BAD_POSITION), 
0:                     new Long(pos));
1:             }
0:             if (length < 0) {
1:                 throw new SqlException(agent_.logWriter_, 
0:                     new MessageId(SQLState.BLOB_NONPOSITIVE_LENGTH),
0:                     new Integer(length));
/////////////////////////////////////////////////////////////////////////
0:                 throw new SqlException(agent_.logWriter_, 
0:                     new MessageId(SQLState.BLOB_NULL_PATTERN));
/////////////////////////////////////////////////////////////////////////
0:                 throw new SqlException(agent_.logWriter_, 
0:                     new MessageId(SQLState.BLOB_NULL_PATTERN));
/////////////////////////////////////////////////////////////////////////
0:         if ((int) pos <= 0) {
0:             throw new SqlException(agent_.logWriter_,
0:                 new MessageId(SQLState.BLOB_BAD_POSITION), new Long(pos));
1:         
0:         if ( pos > binaryString_.length - dataOffset_) {
0:             throw new SqlException(agent_.logWriter_, 
0:                 new MessageId(SQLState.BLOB_POSITION_TOO_LARGE), new Long(pos));
1:         }
1:         if ((offset < 0) || offset > bytes.length )
1:         {
0:             throw new SqlException(agent_.logWriter_,
0:                 new MessageId(SQLState.INVALID_BLOB_OFFSET), 
0:                 new Integer(offset));
1:         }
1:         if ( len < 0 ) {
0:             throw new SqlException(agent_.logWriter_,
0:                 new MessageId(SQLState.BLOB_NONPOSITIVE_LENGTH),
0:                 new Integer(length));
/////////////////////////////////////////////////////////////////////////
0:                 throw new SqlException(agent_.logWriter_,
0:                     new MessageId(SQLState.INVALID_API_PARAMETER),
0:                     new Long(len), "len", "Blob.truncate()");
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:59bf37d
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Jeremy Boynes
-------------------------------------------------------------------------------
commit:70f7692
/////////////////////////////////////////////////////////////////////////
0: public class Blob extends Lob implements java.sql.Blob {
1:     //-----------------------------state------------------------------------------
1:     byte[] binaryString_ = null;
1:     // Only used for input purposes.  For output, each getBinaryStream call
1:     // must generate an independent stream.
0:     java.io.InputStream binaryStream_ = null;
1:     int dataOffset_;
1:     //---------------------constructors/finalizer---------------------------------
0:     public Blob(byte[] binaryString,
1:                 Agent agent,
1:                 int dataOffset) {
0:         super(agent);
1:         binaryString_ = binaryString;
1:         dataType_ |= BINARY_STRING;
0:         sqlLength_ = binaryString.length - dataOffset;
0:         lengthObtained_ = true;
1:         dataOffset_ = dataOffset;
1:     // CTOR for input:
0:     public Blob(Agent agent,
0:                 java.io.InputStream binaryStream,
1:                 int length) {
0:         super(agent);
1:         binaryStream_ = binaryStream;
1:         dataType_ |= BINARY_STREAM;
0:         sqlLength_ = length;
0:         lengthObtained_ = true;
1:     // ---------------------------jdbc 2------------------------------------------
0:     public long length() throws SqlException {
0:         synchronized (agent_.connection_) {
0:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "length");
1:             }
0:             long retVal = super.sqlLength();
0:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceExit(this, "length", retVal);
1:             }
0:             return retVal;
1:         }
0:     // can return an array that may be have a length shorter than the supplied
0:     // length (no padding occurs)
0:     public byte[] getBytes(long pos, int length) throws SqlException {
0:         synchronized (agent_.connection_) {
0:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "getBytes", (int) pos, length);
1:             }
0:             if ((pos <= 0) || (length < 0)) {
0:                 throw new SqlException(agent_.logWriter_, "Invalid position " + pos + " or length " + length);
1:             }
0:             byte[] retVal = getBytesX(pos, length);
0:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceExit(this, "getBytes", retVal);
1:             }
0:             return retVal;
1:         }
1:     private byte[] getBytesX(long pos, int length) throws SqlException {
1:         checkForClosedConnection();
0:         // we may need to check for overflow on this cast
0:         long actualLength = Math.min(this.length() - pos + 1, (long) length);
0:         byte[] retVal = new byte[(int) actualLength];
0:         System.arraycopy(binaryString_, (int) pos + dataOffset_ - 1, retVal, 0, (int) actualLength);
0:         return retVal;
0:     public java.io.InputStream getBinaryStream() throws SqlException {
0:         synchronized (agent_.connection_) {
0:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "getBinaryStream");
1:             }
0:             java.io.InputStream retVal = getBinaryStreamX();
0:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceExit(this, "getBinaryStream", retVal);
1:             }
0:             return retVal;
1:         }
1: 
0:     private java.io.InputStream getBinaryStreamX() throws SqlException {
1:         checkForClosedConnection();
1: 
1:         if (isBinaryStream())    // this Lob is used for input
1:         {
1:             return binaryStream_;
1:         }
1: 
0:         return new java.io.ByteArrayInputStream(binaryString_, dataOffset_, binaryString_.length - dataOffset_);
1: 
0:     public long position(byte[] pattern, long start) throws SqlException {
0:         synchronized (agent_.connection_) {
0:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "position(byte[], long)", pattern, start);
1:             }
0:             if (pattern == null) {
0:                 throw new SqlException(agent_.logWriter_, "Search pattern cannot be null.");
1:             }
0:             long pos = positionX(pattern, start);
0:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceExit(this, "position(byte[], long)", pos);
1:             }
0:             return pos;
1:         }
1:     }
1: 
1:     private long positionX(byte[] pattern, long start) throws SqlException {
1:         checkForClosedConnection();
1: 
0:         return binaryStringPosition(pattern, start);
1:     }
1: 
0:     public long position(java.sql.Blob pattern, long start) throws SqlException {
0:         synchronized (agent_.connection_) {
0:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "position(Blob, long)", pattern, start);
1:             }
0:             if (pattern == null) {
0:                 throw new SqlException(agent_.logWriter_, "Search pattern cannot be null.");
1:             }
0:             long pos = positionX(pattern, start);
0:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceExit(this, "position(Blob, long)", pos);
1:             }
0:             return pos;
1:         }
1:     }
1: 
0:     private long positionX(java.sql.Blob pattern, long start) throws SqlException {
1:         checkForClosedConnection();
1: 
0:         try {
0:             return binaryStringPosition(pattern.getBytes(1L, (int) pattern.length()), start);
0:         } catch (java.sql.SQLException e) {
0:             throw new SqlException(agent_.logWriter_, e.getMessage());
1:         }
1:     }
0:     public int setBytes(long pos, byte[] bytes) throws SqlException {
0:         synchronized (agent_.connection_) {
0:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "setBytes", (int) pos, bytes);
1:             }
0:             int length = setBytesX(pos, bytes, 0, bytes.length);
0:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceExit(this, "setBytes", length);
1:             }
1:             return length;
1:         }
0:     public int setBytes(long pos, byte[] bytes, int offset, int len) throws SqlException {
0:         synchronized (agent_.connection_) {
0:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "setBytes", (int) pos, bytes, offset, len);
1:             }
0:             int length = setBytesX(pos, bytes, offset, len);
0:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceExit(this, "setBytes", length);
1:             }
1:             return length;
1:         }
0:     public int setBytesX(long pos, byte[] bytes, int offset, int len) throws SqlException {
0:         int length = 0;
0:         if ((int) pos <= 0 || pos > binaryString_.length - dataOffset_) {
0:             throw new SqlException(agent_.logWriter_, "Invalid position " + pos
0:                     + " , offset " + offset + " or length " + len);
1:         }
0:         if ((offset < 0) || offset > bytes.length || len < 0) {
0:             throw new SqlException(agent_.logWriter_, "Invalid position " + pos
0:                     + " , offset " + offset + " or length " + len);
1:         }
1:         if (len == 0) {
1:             return 0;
1:         }
0:         length = Math.min((bytes.length - offset), len);
0:         if ((binaryString_.length - dataOffset_ - (int) pos + 1) < length) {
0:             byte newbuf[] = new byte[(int) pos + length + dataOffset_ - 1];
0:             System.arraycopy(binaryString_, 0, newbuf, 0, binaryString_.length);
0:             binaryString_ = newbuf;
1:         }
0:         System.arraycopy(bytes, offset, binaryString_, (int) pos + dataOffset_ - 1, length);
1:         return length;
0:     public java.io.OutputStream setBinaryStream(long pos) throws SqlException {
0:         synchronized (agent_.connection_) {
0:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "setBinaryStream", (int) pos);
1:             }
0:             BlobOutputStream outStream = new BlobOutputStream(this, pos);
0:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceExit(this, "setBinaryStream", outStream);
1:             }
0:             return outStream;
1:         }
0:     public void truncate(long len) throws SqlException {
0:         synchronized (agent_.connection_) {
0:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, " truncate", (int) len);
1:             }
0:             if (len < 0 || len > this.length()) {
0:                 throw new SqlException(agent_.logWriter_, "Invalid length " + len);
1:             }
0:             if (len == this.length()) {
0:                 return;
1:             }
0:             long newLength = (int) len + dataOffset_;
0:             byte newbuf[] = new byte[(int) len + dataOffset_];
0:             System.arraycopy(binaryString_, 0, newbuf, 0, (int) newLength);
0:             binaryString_ = newbuf;
0:             binaryStream_ = new java.io.ByteArrayInputStream(binaryString_);
0:             sqlLength_ = binaryString_.length - dataOffset_;
1:         }
1:     }
1:     //------------------ Material layer event callback methods -------------------
1: 
1:     //---------------------------- helper methods --------------------------------
1:     public boolean isBinaryString() {
1:         return ((dataType_ & BINARY_STRING) == BINARY_STRING);
1:     }
1: 
1:     public boolean isBinaryStream() {
1:         return ((dataType_ & BINARY_STREAM) == BINARY_STREAM);
1:     }
1: 
0:     public byte[] getBinaryString() {
0:         return binaryString_;
1:     }
1: 
0:     protected long binaryStringPosition(byte[] pattern, long start) {
1:         // perform a local byte string search, starting at start
1:         // check that the range of comparison is valid
1:         int index = (int) start + dataOffset_ - 1; // api start begins at 1
1: 
1:         while (index + pattern.length <= binaryString_.length) {
1:             if (isSubString(pattern, index)) {
1:                 return (long) (index - dataOffset_ + 1); // readjust for api indexing
1:             }
1:             index++;
1:         }
1:         return -1L; // not found
1:     }
1: 
1:     // precondition: binaryString_ is long enough for the comparison
0:     protected boolean isSubString(byte[] pattern, int index) {
1:         for (int i = 0; i < pattern.length; i++, index++) {
1:             if (pattern[i] != binaryString_[index]) {
1:                 return false;
1:             }
1:         }
1: 
1:         return true;
1:     }
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:33776ff
/////////////////////////////////////////////////////////////////////////
0: /*
1: 
1:    Derby - Class org.apache.derby.client.am.Blob
1: 
0:    Copyright (c) 2001, 2005 The Apache Software Foundation or its licensors, where applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
0: */
1: 
1: package org.apache.derby.client.am;
1: 
0: public class Blob extends Lob implements java.sql.Blob
0: {
0:   //-----------------------------state------------------------------------------
1: 
0:   byte[] binaryString_ = null;
1: 
0:   // Only used for input purposes.  For output, each getBinaryStream call
0:   // must generate an independent stream.
0:   java.io.InputStream binaryStream_ = null;
0:   int dataOffset_;
1: 
0:   //---------------------constructors/finalizer---------------------------------
1: 
0:   public Blob (byte[] binaryString,
0:                Agent agent,
0:                int dataOffset)
0:   {
0:     super (agent);
0:     binaryString_ = binaryString;
0:     dataType_ |= BINARY_STRING;
0:     sqlLength_ =  binaryString.length - dataOffset;
0:     lengthObtained_ = true;
0:     dataOffset_ = dataOffset;
0:   }
1: 
0:   // CTOR for input:
0:   public Blob (Agent agent,
0:                java.io.InputStream binaryStream,
0:                int length)
0:   {
0:     super (agent);
0:     binaryStream_ = binaryStream;
0:     dataType_ |= BINARY_STREAM;
0:     sqlLength_ = length;
0:     lengthObtained_ = true;
0:   }
1: 
0:   // ---------------------------jdbc 2------------------------------------------
1: 
0:   public long length () throws SqlException
0:   {
0:     synchronized (agent_.connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "length");
0:       long retVal = super.sqlLength();
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceExit (this, "length", retVal);
0:       return retVal;
0:     }
0:   }
1: 
0:   // can return an array that may be have a length shorter than the supplied
0:   // length (no padding occurs)
0:   public byte[] getBytes (long pos, int length) throws SqlException
0:   {
0:     synchronized (agent_.connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "getBytes", (int) pos, length);
0:       if ((pos <= 0) || (length < 0))
0:         throw new SqlException (agent_.logWriter_, "Invalid position " + pos +" or length " + length);
0:       byte[] retVal = getBytesX (pos, length);
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceExit (this, "getBytes", retVal);
0:       return retVal;
0:     }
0:   }
1: 
0:   private byte[] getBytesX (long pos, int length) throws SqlException
0:   {
0:     checkForClosedConnection ();
1: 
0:     // we may need to check for overflow on this cast
0:     long actualLength = Math.min (this.length() - pos + 1, (long) length);
1: 
0:     byte[] retVal = new byte[(int) actualLength];
0:     System.arraycopy (binaryString_, (int) pos + dataOffset_ - 1, retVal, 0, (int) actualLength);
0:     return retVal;
0:   }
1: 
1: 
0:   public java.io.InputStream getBinaryStream () throws SqlException
0:   {
0:     synchronized (agent_.connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "getBinaryStream");
0:       java.io.InputStream retVal = getBinaryStreamX();
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceExit (this, "getBinaryStream", retVal);
0:       return retVal;
0:     }
0:   }
1: 
0:   private java.io.InputStream getBinaryStreamX () throws SqlException
0:   {
0:     checkForClosedConnection ();
1: 
0:     if (isBinaryStream ())    // this Lob is used for input
0:       return binaryStream_;
1: 
0:     return  new java.io.ByteArrayInputStream (binaryString_, dataOffset_, binaryString_.length - dataOffset_);
0:   }
1: 
0:   public long position (byte[] pattern, long start) throws SqlException
0:   {
0:     synchronized (agent_.connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "position(byte[], long)", pattern, start);
0:       if (pattern == null) throw new SqlException (agent_.logWriter_, "Search pattern cannot be null.");
0:       long pos = positionX (pattern, start);
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceExit (this, "position(byte[], long)", pos);
0:       return pos;
0:     }
0:   }
1: 
0:   private long positionX (byte[] pattern, long start) throws SqlException
0:   {
0:     checkForClosedConnection ();
1: 
0:     return binaryStringPosition(pattern, start);
0:   }
1: 
0:   public long position (java.sql.Blob pattern, long start) throws SqlException
0:   {
0:     synchronized (agent_.connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "position(Blob, long)", pattern, start);
0:       if (pattern == null) throw new SqlException (agent_.logWriter_, "Search pattern cannot be null.");
0:       long pos = positionX (pattern, start);
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceExit (this, "position(Blob, long)", pos);
0:       return pos;
0:     }
0:   }
1: 
0:   private long positionX (java.sql.Blob pattern, long start) throws SqlException
0:   {
0:     checkForClosedConnection ();
1: 
0:     try {
0:       return binaryStringPosition(pattern.getBytes(1L, (int)pattern.length()) , start);
0:     }
0:     catch (java.sql.SQLException e) {
0:       throw new SqlException (agent_.logWriter_, e.getMessage());
0:     }
0:   }
1: 
1:     // -------------------------- JDBC 3.0 -----------------------------------
1: 
1: 
0:     public int setBytes (long pos, byte[] bytes) throws SqlException
0:     {
0:       synchronized (agent_.connection_) {
0:         if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "setBytes", (int) pos, bytes);
0:         int length = setBytesX (pos, bytes, 0, bytes.length);
0:         if (agent_.loggingEnabled()) agent_.logWriter_.traceExit (this, "setBytes", length);
0:         return length;
0:       }
0:     }
1: 
0:     public int setBytes (long pos, byte[] bytes, int offset, int len) throws SqlException
0:     {
0:       synchronized (agent_.connection_) {
0:         if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "setBytes", (int) pos, bytes, offset, len);
0:         int length = setBytesX (pos, bytes, offset, len);
0:         if (agent_.loggingEnabled()) agent_.logWriter_.traceExit (this, "setBytes", length);
0:         return length;
0:       }
0:     }
1: 
0:     public int setBytesX (long pos, byte[] bytes, int offset, int len) throws SqlException
0:     {
0:       int length = 0;
0:       if ( (int) pos <= 0 || pos > binaryString_.length - dataOffset_)
0:         throw new SqlException(agent_.logWriter_, "Invalid position " + pos 
0:                      + " , offset " + offset + " or length " + len);
0:       if ( (offset < 0) || offset > bytes.length || len < 0 )
0:         throw new SqlException(agent_.logWriter_, "Invalid position " + pos 
0:                              + " , offset " + offset + " or length " + len);
0:       if (len == 0)
0:         return 0;
0:       length = Math.min((bytes.length  - offset ),len);
0:       if ((binaryString_.length - dataOffset_ - (int) pos + 1) < length) {
0:         byte newbuf[] = new byte[(int)pos + length + dataOffset_-1];
0:         System.arraycopy(binaryString_,0,newbuf,0,binaryString_.length);
0:         binaryString_ = newbuf;
0:       }
1: 
0:       System.arraycopy(bytes,offset, binaryString_, (int)pos + dataOffset_ -1, length);
0:       binaryStream_ = new java.io.ByteArrayInputStream(binaryString_);
0:       sqlLength_ = binaryString_.length - dataOffset_;
0:       return length;
0:     }
1: 
0:     public java.io.OutputStream setBinaryStream (long pos) throws SqlException
0:     {
0:       synchronized (agent_.connection_) {
0:           if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "setBinaryStream", (int) pos);
0:           BlobOutputStream outStream = new BlobOutputStream (this,pos);
1: 
0:           if (agent_.loggingEnabled()) agent_.logWriter_.traceExit (this, "setBinaryStream", outStream);
0:           return outStream;
0:       }
0:     }
1: 
0:     public void truncate (long len) throws SqlException
0:     {
0:       synchronized (agent_.connection_) {
0:         if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, " truncate", (int) len);
0:         if (len < 0 || len > this.length())
0:           throw new SqlException (agent_.logWriter_, "Invalid length " + len);
0:         if (len == this.length())
0:           return;
0:         long newLength = (int)len + dataOffset_;
0:         byte newbuf[] = new byte[(int)len + dataOffset_];
0:         System.arraycopy(binaryString_,0,newbuf,0,(int)newLength);
0:         binaryString_ = newbuf;
0:         binaryStream_ = new java.io.ByteArrayInputStream(binaryString_);
0:         sqlLength_ = binaryString_.length - dataOffset_;
0:       }
0:     }
1: 
0:   //------------------ Material layer event callback methods -------------------
1: 
0:   //---------------------------- helper methods --------------------------------
0:   public boolean isBinaryString ()
0:   {
0:     return ((dataType_ & BINARY_STRING) == BINARY_STRING);
0:   }
1: 
0:   public boolean isBinaryStream ()
0:   {
0:     return ((dataType_ & BINARY_STREAM) == BINARY_STREAM);
0:   }
1: 
0:   public byte[] getBinaryString ()
0:   {
0:     return binaryString_;
0:   }
1: 
0:   protected long binaryStringPosition (byte[] pattern, long start)
0:   {
0:     // perform a local byte string search, starting at start
0:     // check that the range of comparison is valid
0:     int index = (int) start + dataOffset_ - 1; // api start begins at 1
1: 
0:     while (index + pattern.length <= binaryString_.length) {
0:       if (isSubString (pattern, index))
0:         return (long)(index - dataOffset_ + 1); // readjust for api indexing
0:       index++;
0:     }
0:     return -1L; // not found
0:   }
1: 
0:   // precondition: binaryString_ is long enough for the comparison
0:   protected boolean isSubString (byte[] pattern, int index)
0:   {
0:     for (int i = 0; i < pattern.length; i++, index++)
0:       if (pattern[i] != binaryString_[index])
0:         return false;
1: 
0:     return true;
0:   }
0: }
============================================================================