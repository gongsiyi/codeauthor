1:eac0369: /*
33:eac0369: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.compile.ActivationClassBuilder
1:345de35: 
1:2d37fd6:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2d37fd6:    contributor license agreements.  See the NOTICE file distributed with
1:2d37fd6:    this work for additional information regarding copyright ownership.
1:2d37fd6:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2d37fd6:    (the "License"); you may not use this file except in compliance with
1:2d37fd6:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:345de35: 
5:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.sql.compile;
1:eac0369: 
1:eac0369: import java.lang.reflect.Modifier;
1:edb7fcc: import org.apache.derby.iapi.error.StandardException;
1:edb7fcc: import org.apache.derby.iapi.reference.ClassName;
1:edb7fcc: import org.apache.derby.iapi.services.classfile.VMOpcode;
1:edb7fcc: import org.apache.derby.iapi.services.compiler.LocalField;
1:edb7fcc: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1:edb7fcc: import org.apache.derby.iapi.sql.compile.CodeGeneration;
1:edb7fcc: import org.apache.derby.iapi.sql.compile.CompilerContext;
1:eac0369: 
4:eac0369: /**
1:eac0369:  * ActivationClassBuilder
1:eac0369:  * provides an interface to satisfy generation's
1:eac0369:  * common tasks in building an activation class,
1:eac0369:  * as well as a repository for the JavaFactory used
1:eac0369:  * to generate the basic language constructs for the methods in the class.
1:eac0369:  * Common tasks include the setting of a static field for each
1:eac0369:  * expression function that gets added, the creation
1:eac0369:  * of the execute method that gets expanded as the query tree
1:eac0369:  * is walked, setting the superclass.
1:eac0369:  * <p>
1:eac0369:  * An activation class is defined for each statement. It has
1:eac0369:  * the following basic layout: TBD
1:eac0369:  * See the document
1:eac0369:  * \\Jeeves\Unversioned Repository 1\Internal Technical Documents\Other\GenAndExec.doc
1:eac0369:  * for details.
1:eac0369:  * <p>
1:eac0369:  * We could also verify methods as they are
1:eac0369:  * added, to have 0 parameters, ...
6:eac0369:  *
1:eac0369:  */
1:e077c88: class ActivationClassBuilder	extends	ExpressionClassBuilder
4:eac0369: {
1:eac0369: 	///////////////////////////////////////////////////////////////////////
3:eac0369: 	//
1:eac0369: 	// CONSTANTS
1:eac0369: 	//
1:eac0369: 	///////////////////////////////////////////////////////////////////////
1:eac0369: 
1:eac0369: 	///////////////////////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	// STATE
1:eac0369: 	//
1:eac0369: 	///////////////////////////////////////////////////////////////////////
1:eac0369: 
1:eac0369: 	private LocalField	targetResultSetField;
1:eac0369: 	private LocalField  cursorResultSetField;
1:eac0369: 
1:eac0369: 	private MethodBuilder closeActivationMethod;
1:eac0369: 
1:eac0369: 
1:eac0369: 	///////////////////////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	// CONSTRUCTOR
1:eac0369: 	//
1:eac0369: 	///////////////////////////////////////////////////////////////////////
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * By the time this is done, it has constructed the following class:
2:eac0369: 	 * <pre>
1:ab2cc4a: 	 *    final public class #className extends #superClass {
1:eac0369: 	 *		// public void reset() { return; }
1:edb7fcc: 	 *		protected ResultSet doExecute() throws StandardException {
2:eac0369: 	 *			// statements must be added here
2:eac0369: 	 *		}
1:ab2cc4a:      *      public #className() { super(); }
2:eac0369: 	 *    }
2:eac0369: 	 * </pre>
1:eac0369: 	 *
2:eac0369: 	 * @exception StandardException thrown on failure
1:eac0369: 	 */
1:e077c88: 	ActivationClassBuilder (String superClass, CompilerContext cc) throws StandardException
1:eac0369: 	{
1:eac0369: 		super( superClass, (String) null, cc );
4:eac0369: 	}
1:eac0369: 
1:eac0369: 	///////////////////////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	// ACCESSORS
1:eac0369: 	//
1:eac0369: 	///////////////////////////////////////////////////////////////////////
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  *	Get the package name that this generated class lives in
1:eac0369: 	  *
1:eac0369: 	  *	@return	package name
1:eac0369: 	  */
1:eac0369:     public	String	getPackageName()
1:eac0369: 	{	return	CodeGeneration.GENERATED_PACKAGE_PREFIX; }
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		The base class for activations is BaseActivation
1:eac0369: 	 */
1:e077c88: 	String getBaseClassName() {
1:eac0369: 	    return ClassName.BaseActivation;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  *	Get the number of ExecRows to allocate
1:eac0369: 	  *
1:eac0369: 	  * @exception StandardException thrown on failure
1:eac0369: 	  *	@return	package name
1:eac0369: 	  */
1:eac0369: 	public	int		getRowCount()
3:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369: 		return	myCompCtx.getNumResultSets();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Generate the assignment for numSubqueries = x
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException thrown on failure
1:eac0369: 	 */
1:eac0369: 	public	 void	setNumSubqueries()
1:eac0369: 	{
1:eac0369: 		int				numSubqueries = myCompCtx.getNumSubquerys();
1:eac0369: 
1:eac0369: 		// If there are no subqueries then
1:eac0369: 		// the field is set to the correctly
1:eac0369: 		// value (0) by java.
1:eac0369: 		if (numSubqueries == 0)
1:eac0369: 			return;
1:eac0369: 
1:eac0369: 		/* Generated code is:
1:eac0369: 		 *		numSubqueries = x;
1:eac0369: 		 */
1:eac0369: 		constructor.pushThis();
1:eac0369: 		constructor.push(numSubqueries);
1:eac0369: 		constructor.putField(ClassName.BaseActivation, "numSubqueries", "int");
1:eac0369: 		constructor.endStatement();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	///////////////////////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	// EXECUTE METHODS
1:eac0369: 	//
1:eac0369: 	///////////////////////////////////////////////////////////////////////
1:eac0369: 
1:e077c88: 	MethodBuilder startResetMethod() {
2:eac0369: 		MethodBuilder mb = cb.newMethodBuilder(Modifier.PUBLIC,
1:eac0369: 			"void", "reset");
1:eac0369: 
2:eac0369: 		mb.addThrownException(ClassName.StandardException);
1:eac0369: 		mb.pushThis();
1:eac0369: 		mb.callMethod(VMOpcode.INVOKESPECIAL, ClassName.BaseActivation, "reset", "void", 0);
1:eac0369: 
1:eac0369: 
1:eac0369: 		return mb;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * An execute method always ends in a return statement, returning
1:eac0369: 	 * the result set that has been constructed.  We want to
1:eac0369: 	 * do some bookkeeping on that statement, so we generate
1:eac0369: 	 * the return given the result set.
1:eac0369: 
1:eac0369: 	   Upon entry the only word on the stack is the result set expression
1:eac0369: 	 */
1:d11ed08: 	void finishExecuteMethod() {
1:eac0369: 
1:d11ed08:         if (executeMethod != null) {
1:d11ed08:             executeMethod.methodReturn();
1:d11ed08:             executeMethod.complete();
1:d11ed08:         }
1:eac0369: 
1:eac0369: 		if (closeActivationMethod != null) {
1:eac0369: 			closeActivationMethod.methodReturn();
1:eac0369: 			closeActivationMethod.complete();
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	///////////////////////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	// CURSOR SUPPORT
1:eac0369: 	//
1:eac0369: 	///////////////////////////////////////////////////////////////////////
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Updatable cursors
1:eac0369: 	 * need to add a getter method for use in BaseActivation to access
1:eac0369: 	 * the result set that identifies target rows for a positioned
1:eac0369: 	 * update or delete.
1:eac0369: 	 * <p>
1:eac0369: 	 * The code that is generated is:
1:eac0369: 	 * <pre><verbatim>
1:eac0369: 	 *  public CursorResultSet getTargetResultSet() {
1:eac0369: 	 *	    return targetResultSet;
1:eac0369: 	 *  }
1:eac0369: 	 *
1:eac0369: 	 *  public CursorResultSet getCursorResultSet() {
1:eac0369: 	 *		return cursorResultSet;
1:eac0369: 	 *  }
1:eac0369: 	 * </verbatim></pre>
1:eac0369: 	 *
1:eac0369: 	 */
1:e077c88: 	void addCursorPositionCode() {
1:eac0369: 
1:eac0369: 		// the getter
2:eac0369: 		// This method is an implementation of the interface method
1:eac0369: 		// CursorActivation - CursorResultSet getTargetResultSet()
1:eac0369: 		MethodBuilder getter = cb.newMethodBuilder(Modifier.PUBLIC, 
1:eac0369: 			ClassName.CursorResultSet, "getTargetResultSet");
1:eac0369: 
1:eac0369: 		getter.getField(targetResultSetField);
1:eac0369: 		getter.methodReturn();
1:eac0369: 		getter.complete();
1:eac0369: 
1:eac0369: 		// This method is an implementation of the interface method
1:eac0369: 		// CursorActivation - CursorResultSet getCursorResultSet()
1:eac0369: 
1:eac0369: 		getter = cb.newMethodBuilder(Modifier.PUBLIC, 
1:eac0369: 			ClassName.CursorResultSet, "getCursorResultSet");
1:eac0369: 
1:eac0369: 		getter.getField(cursorResultSetField);
1:eac0369: 		getter.methodReturn();
1:eac0369: 		getter.complete();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Updatable cursors
1:eac0369: 	 * need to add a field and its initialization
1:eac0369: 	 * for use in BaseActivation to access the result set that
1:eac0369: 	 * identifies target rows for a positioned update or delete.
1:eac0369: 	 * <p>
1:eac0369: 	 * The code that is generated is:
1:eac0369: 	 * <pre><verbatim>
1:eac0369: 	 *  private CursorResultSet targetResultSet;
1:eac0369: 	 *
1:eac0369: 	 * </verbatim></pre>
1:eac0369: 	 *
1:eac0369: 	 * The expression that is generated is:
1:eac0369: 	 * <pre><verbatim>
1:eac0369: 	 *  (ResultSet) (targetResultSet = (CursorResultSet) #expression#)
1:eac0369: 	 * </verbatim></pre>
1:eac0369: 	 *
1:eac0369: 	 */
1:e077c88: 	void rememberCursorTarget(MethodBuilder mb) {
1:eac0369: 
1:eac0369: 		// the field
1:eac0369: 		targetResultSetField = cb.addField(ClassName.CursorResultSet,
1:eac0369: 					"targetResultSet",
1:eac0369: 					Modifier.PRIVATE);
1:eac0369: 
1:eac0369: 		mb.cast(ClassName.CursorResultSet);
1:eac0369: 		mb.putField(targetResultSetField);
1:eac0369: 		mb.cast(ClassName.NoPutResultSet);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Updatable cursors
1:eac0369: 	 * need to add a field and its initialization
1:eac0369: 	 * for use in BaseActivation to access the result set that
1:eac0369: 	 * identifies cursor result rows for a positioned update or delete.
1:eac0369: 	 * <p>
1:eac0369: 	 * The code that is generated is:
1:eac0369: 	 * <pre><verbatim>
1:eac0369: 	 *  private CursorResultSet cursorResultSet;
1:eac0369: 	 *
1:eac0369: 	 * </verbatim></pre>
1:eac0369: 	 *
1:eac0369: 	 * The expression that is generated is:
1:eac0369: 	 * <pre><verbatim>
1:eac0369: 	 *  (ResultSet) (cursorResultSet = (CursorResultSet) #expression#)
1:eac0369: 	 * </verbatim></pre>
1:eac0369: 
1:eac0369:        The expression must be the top stack word when this method is called.
1:eac0369: 	 *
1:eac0369: 	 */
1:e077c88: 	void rememberCursor(MethodBuilder mb) {
1:eac0369: 
1:eac0369: 		// the field
1:eac0369: 		cursorResultSetField = cb.addField(ClassName.CursorResultSet,
1:eac0369: 					"cursorResultSet",
1:eac0369: 					Modifier.PRIVATE);
1:eac0369: 
1:eac0369: 		mb.cast(ClassName.CursorResultSet);
1:eac0369: 		mb.putField(cursorResultSetField);
1:eac0369: 		mb.cast(ClassName.ResultSet);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	///////////////////////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	// CURRENT DATE/TIME SUPPORT
1:eac0369: 	//
1:eac0369: 	///////////////////////////////////////////////////////////////////////
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 		The first time a current datetime is needed, create the class
1:eac0369: 		level support for it. The first half of the logic is in our parent
1:bb579f8: 		class.
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	protected LocalField getCurrentSetup()
1:eac0369: 	{
1:eac0369: 		if (cdtField != null) return cdtField;
1:eac0369: 
1:eac0369: 		LocalField lf = super.getCurrentSetup();
1:eac0369: 
1:eac0369: 		// 3) the execute method gets a statement (prior to the return)
1:eac0369: 		//    to tell cdt to restart:
1:eac0369: 		//	  cdt.forget();
1:eac0369: 
1:d11ed08:         MethodBuilder execute = getExecuteMethod();
1:d11ed08:         execute.getField(lf);
1:d11ed08:         execute.callMethod(
1:d11ed08:                 VMOpcode.INVOKEVIRTUAL, (String) null, "forget", "void", 0);
1:eac0369: 
1:eac0369: 		return lf;
1:eac0369: 	}
1:eac0369: 
1:e077c88: 	MethodBuilder getCloseActivationMethod() {
1:eac0369: 
1:eac0369: 		if (closeActivationMethod == null) {
1:eac0369: 			closeActivationMethod = cb.newMethodBuilder(Modifier.PUBLIC, "void", "closeActivationAction");
1:eac0369: 			closeActivationMethod.addThrownException("java.lang.Exception");
1:eac0369: 		}
1:eac0369: 		return closeActivationMethod;
1:eac0369: 	}
1:eac0369: }
1:eac0369: 
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:ab2cc4a
/////////////////////////////////////////////////////////////////////////
1: 	 *    final public class #className extends #superClass {
1:      *      public #className() { super(); }
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
0:      *      #className() { super(); }
/////////////////////////////////////////////////////////////////////////
1:     @Override
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:f542632
/////////////////////////////////////////////////////////////////////////
commit:d11ed08
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	void finishExecuteMethod() {
1:         if (executeMethod != null) {
1:             executeMethod.methodReturn();
1:             executeMethod.complete();
1:         }
/////////////////////////////////////////////////////////////////////////
1:         MethodBuilder execute = getExecuteMethod();
1:         execute.getField(lf);
1:         execute.callMethod(
1:                 VMOpcode.INVOKEVIRTUAL, (String) null, "forget", "void", 0);
commit:edb7fcc
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.reference.ClassName;
1: import org.apache.derby.iapi.services.classfile.VMOpcode;
1: import org.apache.derby.iapi.services.compiler.LocalField;
1: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1: import org.apache.derby.iapi.sql.compile.CodeGeneration;
1: import org.apache.derby.iapi.sql.compile.CompilerContext;
/////////////////////////////////////////////////////////////////////////
1: 	 *		protected ResultSet doExecute() throws StandardException {
/////////////////////////////////////////////////////////////////////////
0: 	 *		protected ResultSet doExecute() throws StandardException {
/////////////////////////////////////////////////////////////////////////
0: 		// This method is an implementation of the abstract method
0: 		// BaseActivation - ResultSet doExecute()
0: 		MethodBuilder mb = cb.newMethodBuilder(Modifier.PROTECTED,
0: 			ClassName.ResultSet, "doExecute");
commit:0393775
/////////////////////////////////////////////////////////////////////////
0:         // Create and initialize a static field that holds row count statistics.
0:         LocalField rowCountField = newFieldDeclaration(
0:                 Modifier.PRIVATE | Modifier.STATIC | Modifier.FINAL,
0:                 ClassName.RowCountStats);
0:         MethodBuilder init = getStaticInitializer();
0:         init.pushNewStart(ClassName.RowCountStats);
0:         init.pushNewComplete(0);
0:         init.setStaticField(rowCountField);
0:         // Create a method that returns the row count statistics.
0:         MethodBuilder getRowCountStats = cb.newMethodBuilder(
0:                 Modifier.PROTECTED | Modifier.FINAL,
0:                 ClassName.RowCountStats,
0:                 "getRowCountStats");
0:         getRowCountStats.getStaticField(rowCountField);
0:         getRowCountStats.methodReturn();
0:         getRowCountStats.complete();
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:95e850d
/////////////////////////////////////////////////////////////////////////
0: 	private	MethodBuilder	beginExecuteMethod()
/////////////////////////////////////////////////////////////////////////
commit:bb579f8
/////////////////////////////////////////////////////////////////////////
1: 		class.
/////////////////////////////////////////////////////////////////////////
commit:e077c88
/////////////////////////////////////////////////////////////////////////
1: class ActivationClassBuilder	extends	ExpressionClassBuilder
/////////////////////////////////////////////////////////////////////////
1: 	ActivationClassBuilder (String superClass, CompilerContext cc) throws StandardException
/////////////////////////////////////////////////////////////////////////
1: 	String getBaseClassName() {
/////////////////////////////////////////////////////////////////////////
1: 	MethodBuilder startResetMethod() {
/////////////////////////////////////////////////////////////////////////
0: 	void finishExecuteMethod(boolean genMarkAsTopNode) {
/////////////////////////////////////////////////////////////////////////
1: 	void addCursorPositionCode() {
/////////////////////////////////////////////////////////////////////////
1: 	void rememberCursorTarget(MethodBuilder mb) {
/////////////////////////////////////////////////////////////////////////
1: 	void rememberCursor(MethodBuilder mb) {
/////////////////////////////////////////////////////////////////////////
1: 	MethodBuilder getCloseActivationMethod() {
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.compile.ActivationClassBuilder
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:61070a6
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.sql.compile;
1: 
0: import org.apache.derby.iapi.services.compiler.ClassBuilder;
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
0: import org.apache.derby.iapi.services.compiler.LocalField;
0: import org.apache.derby.iapi.reference.ClassName;
1: 
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
0: import org.apache.derby.iapi.sql.compile.CompilerContext;
0: import org.apache.derby.iapi.sql.compile.CodeGeneration;
1: 
0: import org.apache.derby.iapi.sql.execute.CursorResultSet;
1: 
0: import org.apache.derby.iapi.sql.ResultSet;
1: 
0: import org.apache.derby.iapi.sql.execute.ExecRow;
1: 
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: import org.apache.derby.iapi.types.TypeId;
1: 
0: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.iapi.services.loader.GeneratedMethod;
0: import org.apache.derby.iapi.services.classfile.VMOpcode;
1: 
1: import java.lang.reflect.Modifier;
1: 
0: import java.io.PrintWriter;
1: 
0: import java.io.File;
0: import java.io.FileOutputStream;
0: import java.io.ByteArrayOutputStream;
0: import java.io.IOException;
0: import java.util.Hashtable;
1: 
1: /**
1:  * ActivationClassBuilder
1:  * provides an interface to satisfy generation's
1:  * common tasks in building an activation class,
1:  * as well as a repository for the JavaFactory used
1:  * to generate the basic language constructs for the methods in the class.
1:  * Common tasks include the setting of a static field for each
1:  * expression function that gets added, the creation
1:  * of the execute method that gets expanded as the query tree
1:  * is walked, setting the superclass.
1:  * <p>
1:  * An activation class is defined for each statement. It has
1:  * the following basic layout: TBD
1:  * See the document
1:  * \\Jeeves\Unversioned Repository 1\Internal Technical Documents\Other\GenAndExec.doc
1:  * for details.
1:  * <p>
1:  * We could also verify methods as they are
1:  * added, to have 0 parameters, ...
1:  *
0:  * @author ames
1:  */
0: public class ActivationClassBuilder	extends	ExpressionClassBuilder
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 	///////////////////////////////////////////////////////////////////////
1: 	//
1: 	// CONSTANTS
1: 	//
1: 	///////////////////////////////////////////////////////////////////////
1: 
1: 	///////////////////////////////////////////////////////////////////////
1: 	//
1: 	// STATE
1: 	//
1: 	///////////////////////////////////////////////////////////////////////
1: 
1: 	private LocalField	targetResultSetField;
1: 	private LocalField  cursorResultSetField;
1: 
1: 	private MethodBuilder closeActivationMethod;
1: 
1: 
1: 	///////////////////////////////////////////////////////////////////////
1: 	//
1: 	// CONSTRUCTOR
1: 	//
1: 	///////////////////////////////////////////////////////////////////////
1: 
1: 	/**
1: 	 * By the time this is done, it has constructed the following class:
1: 	 * <pre>
0: 	 *    public class #className extends #superClass {
1: 	 *		// public void reset() { return; }
0: 	 *		public ResultSet execute() throws StandardException {
0: 	 *			throwIfClosed("execute");
1: 	 *			// statements must be added here
1: 	 *		}
0: 	 *		public #className() { super(); }
1: 	 *    }
1: 	 * </pre>
1: 	 *
1: 	 * @exception StandardException thrown on failure
1: 	 */
0: 	public ActivationClassBuilder (String superClass, CompilerContext cc) throws StandardException
1: 	{
1: 		super( superClass, (String) null, cc );
0: 		executeMethod = beginExecuteMethod();
1: 	}
1: 
1: 	///////////////////////////////////////////////////////////////////////
1: 	//
1: 	// ACCESSORS
1: 	//
1: 	///////////////////////////////////////////////////////////////////////
1: 
1: 	/**
1: 	  *	Get the package name that this generated class lives in
1: 	  *
1: 	  *	@return	package name
1: 	  */
1:     public	String	getPackageName()
1: 	{	return	CodeGeneration.GENERATED_PACKAGE_PREFIX; }
1: 
1: 	/**
1: 		The base class for activations is BaseActivation
1: 	 */
0: 	public String getBaseClassName() {
1: 	    return ClassName.BaseActivation;
1: 	}
1: 
1: 
1: 	/**
1: 	  *	Get the number of ExecRows to allocate
1: 	  *
1: 	  * @exception StandardException thrown on failure
1: 	  *	@return	package name
1: 	  */
1: 	public	int		getRowCount()
1: 		 throws StandardException
1: 	{
1: 		return	myCompCtx.getNumResultSets();
1: 	}
1: 
1: 	/**
1: 	 * Generate the assignment for numSubqueries = x
1: 	 *
0: 	 * @param numSubqueries		The number of subqueries in the query.
1: 	 *
0: 	 * @return Nothing.
1: 	 * @exception StandardException thrown on failure
1: 	 */
1: 	public	 void	setNumSubqueries()
1: 	{
1: 		int				numSubqueries = myCompCtx.getNumSubquerys();
1: 
1: 		// If there are no subqueries then
1: 		// the field is set to the correctly
1: 		// value (0) by java.
1: 		if (numSubqueries == 0)
1: 			return;
1: 
1: 		/* Generated code is:
1: 		 *		numSubqueries = x;
1: 		 */
1: 		constructor.pushThis();
1: 		constructor.push(numSubqueries);
1: 		constructor.putField(ClassName.BaseActivation, "numSubqueries", "int");
1: 		constructor.endStatement();
1: 	}
1: 
1: 
1: 	///////////////////////////////////////////////////////////////////////
1: 	//
1: 	// EXECUTE METHODS
1: 	//
1: 	///////////////////////////////////////////////////////////////////////
1: 
1: 	/**
0: 	 * By the time this is done, it has generated the following code
1: 	 * <pre>
0: 	 *		public ResultSet execute() throws StandardException {
0: 	 *			throwIfClosed("execute");
1: 	 *			// statements must be added here
1: 	 *		}
1: 	 *    }
1: 	 * </pre>
1: 	 *
1: 	 * @exception StandardException thrown on failure
1: 	 */
0: 	public	MethodBuilder	beginExecuteMethod()
1: 		throws StandardException
1: 	{
0: 		// create a reset method that does nothing.
0: 		// REVISIT: this might better belong in the Activation
0: 		// superclasses ?? not clear yet what it needs to do.
1: 
0: 		// don't yet need a reset method here. when we do,
0: 		// it will need to call super.reset() as well as
0: 		// whatever it does.
0: 		// mb = cb.newMethodBuilder(
0: 		// 	Modifier.PUBLIC, "void", "reset");
0: 		// mb.addStatement(javaFac.newStatement(
0: 		//		javaFac.newSpecialMethodCall(
0: 		//			thisExpression(),
0: 		//			BaseActivation.CLASS_NAME,
0: 		//			"reset", "void")));
0: 		// mb.addStatement(javaFac.newReturnStatement());
0: 		// mb.complete(); // there is nothing else.
1: 
1: 
1: 		// This method is an implementation of the interface method
0: 		// Activation - ResultSet execute()
1: 
0: 		// create an empty execute method
1: 		MethodBuilder mb = cb.newMethodBuilder(Modifier.PUBLIC,
0: 			ClassName.ResultSet, "execute");
1: 		mb.addThrownException(ClassName.StandardException);
1: 
0: 		// put a 'throwIfClosed("execute");' statement into the execute method.
0: 		mb.pushThis(); // instance
0: 		mb.push("execute");
0: 		mb.callMethod(VMOpcode.INVOKEVIRTUAL, ClassName.BaseActivation, "throwIfClosed", "void", 1);
1: 
0: 		// call this.startExecution(), so the parent class can know an execution
0: 		// has begun.
1: 
0: 		mb.pushThis(); // instance
0: 		mb.callMethod(VMOpcode.INVOKEVIRTUAL, ClassName.BaseActivation, "startExecution", "void", 0);
1: 
0: 		return	mb;
1: 	}
1: 
0: 	public MethodBuilder startResetMethod() {
1: 		MethodBuilder mb = cb.newMethodBuilder(Modifier.PUBLIC,
1: 			"void", "reset");
1: 
1: 		mb.addThrownException(ClassName.StandardException);
1: 		mb.pushThis();
1: 		mb.callMethod(VMOpcode.INVOKESPECIAL, ClassName.BaseActivation, "reset", "void", 0);
1: 
1: 
1: 		return mb;
1: 	}
1: 
1: 	/**
1: 	 * An execute method always ends in a return statement, returning
1: 	 * the result set that has been constructed.  We want to
1: 	 * do some bookkeeping on that statement, so we generate
1: 	 * the return given the result set.
1: 
1: 	   Upon entry the only word on the stack is the result set expression
1: 	 */
0: 	public void finishExecuteMethod(boolean genMarkAsTopNode) {
1: 
0: 		executeMethod.pushThis();
0: 		executeMethod.getField(ClassName.BaseActivation, "resultSet", ClassName.ResultSet);
1: 
0: 		/* We only call markAsTopResultSet() for selects.
0: 		 * Non-select DML marks the top NoPutResultSet in the constructor.
0: 		 * Needed for closing down resultSet on an error.
1: 		 */
0: 		if (genMarkAsTopNode)
1: 		{
0: 			// dup the result set to leave one for the return and one for this call
0: 			executeMethod.dup();
0: 			executeMethod.cast(ClassName.NoPutResultSet);
0: 			executeMethod.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, "markAsTopResultSet", "void", 0);
1: 		}
1: 
0: 		/* return resultSet */
0: 		executeMethod.methodReturn();
0: 		executeMethod.complete();
1: 
0: 		getClassBuilder().newFieldWithAccessors("getExecutionCount", "setExecutionCount",
0: 			Modifier.PROTECTED, true, "int");
1: 
0: 		getClassBuilder().newFieldWithAccessors("getRowCountCheckVector", "setRowCountCheckVector",
0: 			Modifier.PROTECTED, true, "java.util.Vector");
1: 
0: 		getClassBuilder().newFieldWithAccessors("getStalePlanCheckInterval", "setStalePlanCheckInterval",
0: 			Modifier.PROTECTED, true, "int");
1: 
1: 		if (closeActivationMethod != null) {
1: 			closeActivationMethod.methodReturn();
1: 			closeActivationMethod.complete();
1: 		}
1: 	}
1: 
1: 	///////////////////////////////////////////////////////////////////////
1: 	//
1: 	// CURSOR SUPPORT
1: 	//
1: 	///////////////////////////////////////////////////////////////////////
1: 
1: 	/**
1: 	 * Updatable cursors
1: 	 * need to add a getter method for use in BaseActivation to access
1: 	 * the result set that identifies target rows for a positioned
1: 	 * update or delete.
1: 	 * <p>
1: 	 * The code that is generated is:
1: 	 * <pre><verbatim>
1: 	 *  public CursorResultSet getTargetResultSet() {
1: 	 *	    return targetResultSet;
1: 	 *  }
1: 	 *
1: 	 *  public CursorResultSet getCursorResultSet() {
1: 	 *		return cursorResultSet;
1: 	 *  }
1: 	 * </verbatim></pre>
1: 	 *
1: 	 */
0: 	public void addCursorPositionCode() {
1: 
1: 		// the getter
1: 		// This method is an implementation of the interface method
1: 		// CursorActivation - CursorResultSet getTargetResultSet()
1: 		MethodBuilder getter = cb.newMethodBuilder(Modifier.PUBLIC, 
1: 			ClassName.CursorResultSet, "getTargetResultSet");
1: 
1: 		getter.getField(targetResultSetField);
1: 		getter.methodReturn();
1: 		getter.complete();
1: 
1: 		// This method is an implementation of the interface method
1: 		// CursorActivation - CursorResultSet getCursorResultSet()
1: 
1: 		getter = cb.newMethodBuilder(Modifier.PUBLIC, 
1: 			ClassName.CursorResultSet, "getCursorResultSet");
1: 
1: 		getter.getField(cursorResultSetField);
1: 		getter.methodReturn();
1: 		getter.complete();
1: 	}
1: 
1: 	/**
1: 	 * Updatable cursors
1: 	 * need to add a field and its initialization
1: 	 * for use in BaseActivation to access the result set that
1: 	 * identifies target rows for a positioned update or delete.
1: 	 * <p>
1: 	 * The code that is generated is:
1: 	 * <pre><verbatim>
1: 	 *  private CursorResultSet targetResultSet;
1: 	 *
1: 	 * </verbatim></pre>
1: 	 *
1: 	 * The expression that is generated is:
1: 	 * <pre><verbatim>
1: 	 *  (ResultSet) (targetResultSet = (CursorResultSet) #expression#)
1: 	 * </verbatim></pre>
1: 	 *
1: 	 */
0: 	public void rememberCursorTarget(MethodBuilder mb) {
1: 
1: 		// the field
1: 		targetResultSetField = cb.addField(ClassName.CursorResultSet,
1: 					"targetResultSet",
1: 					Modifier.PRIVATE);
1: 
1: 		mb.cast(ClassName.CursorResultSet);
1: 		mb.putField(targetResultSetField);
1: 		mb.cast(ClassName.NoPutResultSet);
1: 	}
1: 
1: 	/**
1: 	 * Updatable cursors
1: 	 * need to add a field and its initialization
1: 	 * for use in BaseActivation to access the result set that
1: 	 * identifies cursor result rows for a positioned update or delete.
1: 	 * <p>
1: 	 * The code that is generated is:
1: 	 * <pre><verbatim>
1: 	 *  private CursorResultSet cursorResultSet;
1: 	 *
1: 	 * </verbatim></pre>
1: 	 *
1: 	 * The expression that is generated is:
1: 	 * <pre><verbatim>
1: 	 *  (ResultSet) (cursorResultSet = (CursorResultSet) #expression#)
1: 	 * </verbatim></pre>
1: 
1:        The expression must be the top stack word when this method is called.
1: 	 *
1: 	 */
0: 	public void rememberCursor(MethodBuilder mb) {
1: 
1: 		// the field
1: 		cursorResultSetField = cb.addField(ClassName.CursorResultSet,
1: 					"cursorResultSet",
1: 					Modifier.PRIVATE);
1: 
1: 		mb.cast(ClassName.CursorResultSet);
1: 		mb.putField(cursorResultSetField);
1: 		mb.cast(ClassName.ResultSet);
1: 	}
1: 
1: 	///////////////////////////////////////////////////////////////////////
1: 	//
1: 	// CURRENT DATE/TIME SUPPORT
1: 	//
1: 	///////////////////////////////////////////////////////////////////////
1: 
1: 	/*
1: 		The first time a current datetime is needed, create the class
1: 		level support for it. The first half of the logic is in our parent
0: 		class. Then we add logic here to tidy up for ResultSet management.
1: 	 */
1: 	protected LocalField getCurrentSetup()
1: 	{
1: 		if (cdtField != null) return cdtField;
1: 
1: 		LocalField lf = super.getCurrentSetup();
1: 
1: 		// 3) the execute method gets a statement (prior to the return)
1: 		//    to tell cdt to restart:
1: 		//	  cdt.forget();
1: 
0: 		executeMethod.getField(lf);
0: 		executeMethod.callMethod(VMOpcode.INVOKEVIRTUAL, (String) null, "forget", "void", 0);
1: 
0: 		// 4) a resultSetClosed method is set up to be passed to
0: 		//    the outermost result set, if it is an open/close result set,
0: 		//    so that cdt can be told to forget when a result set closes:
0: 		//	  GeneratedMethod rscm; // the name is just a generated name, simpler.
0: 		//    void rscm() {
0: 		//		cdt.forget();
0: 		//	  }
0: 		MethodBuilder mb = newExprFun();
0: 		mb.getField(lf); // the instance
0: 		mb.callMethod(VMOpcode.INVOKEVIRTUAL, (String) null, "forget", "void", 0);
0: 		mb.pushNull("java.lang.Object");
0: 		mb.methodReturn();
0: 		mb.complete();
1: 		
0: 		resultSetClosedMethod = mb;
1: 
1: 		return lf;
1: 	}
1: 
0: 	//////////////////////////////////////////////////////////////////////////
1: 	//
0: 	//	NAMED PARAMETER METHODS
1: 	//
0: 	//////////////////////////////////////////////////////////////////////////
1: 
1: 	/**
0: 	 *	Generates a parameter reference. Only implemented for Filters right now.
1: 	 *
0: 	 *	@param	name		Parameter name.
0: 	 *	@param	position	Parameter id.
0: 	 *	@param	dataType	Parameter datatype.
0: 	 *  @param	mb			The method to put the generated code into
1: 	 *
0: 	 *	@return	an expression representing the parameter reference.
1: 	 *
0: 	 * 	@exception StandardException thrown on failure
1: 	 */
0: 	public	void	getParameterReference( String				name,
0: 											   int					position,
0: 											   DataTypeDescriptor		dataType,
0: 											   MethodBuilder		mb )
1: 		 throws StandardException
1: 	{
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.NOTREACHED();
1: 	}
1: 
1: 
0: 	public MethodBuilder getCloseActivationMethod() {
1: 
1: 		if (closeActivationMethod == null) {
1: 			closeActivationMethod = cb.newMethodBuilder(Modifier.PUBLIC, "void", "closeActivationAction");
1: 			closeActivationMethod.addThrownException("java.lang.Exception");
1: 		}
1: 		return closeActivationMethod;
1: 	}
1: }
1: 
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2d37fd6
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.sql.compile;
0: 
0: import org.apache.derby.iapi.services.compiler.ClassBuilder;
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
0: import org.apache.derby.iapi.services.compiler.LocalField;
0: import org.apache.derby.iapi.reference.ClassName;
0: 
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.sql.compile.CompilerContext;
0: import org.apache.derby.iapi.sql.compile.CodeGeneration;
0: 
0: import org.apache.derby.iapi.sql.execute.CursorResultSet;
0: 
0: import org.apache.derby.iapi.sql.ResultSet;
0: 
0: import org.apache.derby.iapi.sql.execute.ExecRow;
0: 
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: import org.apache.derby.iapi.types.TypeId;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.services.loader.GeneratedMethod;
0: import org.apache.derby.iapi.services.classfile.VMOpcode;
0: 
0: import java.lang.reflect.Modifier;
0: 
0: import java.io.PrintWriter;
0: 
0: import java.io.File;
0: import java.io.FileOutputStream;
0: import java.io.ByteArrayOutputStream;
0: import java.io.IOException;
0: import java.util.Hashtable;
0: 
0: /**
0:  * ActivationClassBuilder
0:  * provides an interface to satisfy generation's
0:  * common tasks in building an activation class,
0:  * as well as a repository for the JavaFactory used
0:  * to generate the basic language constructs for the methods in the class.
0:  * Common tasks include the setting of a static field for each
0:  * expression function that gets added, the creation
0:  * of the execute method that gets expanded as the query tree
0:  * is walked, setting the superclass.
0:  * <p>
0:  * An activation class is defined for each statement. It has
0:  * the following basic layout: TBD
0:  * See the document
0:  * \\Jeeves\Unversioned Repository 1\Internal Technical Documents\Other\GenAndExec.doc
0:  * for details.
0:  * <p>
0:  * We could also verify methods as they are
0:  * added, to have 0 parameters, ...
0:  *
0:  * @author ames
0:  */
0: public class ActivationClassBuilder	extends	ExpressionClassBuilder
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	///////////////////////////////////////////////////////////////////////
0: 	//
0: 	// CONSTANTS
0: 	//
0: 	///////////////////////////////////////////////////////////////////////
0: 
0: 	///////////////////////////////////////////////////////////////////////
0: 	//
0: 	// STATE
0: 	//
0: 	///////////////////////////////////////////////////////////////////////
0: 
0: 	private LocalField	targetResultSetField;
0: 	private LocalField  cursorResultSetField;
0: 
0: 	private MethodBuilder closeActivationMethod;
0: 
0: 
0: 	///////////////////////////////////////////////////////////////////////
0: 	//
0: 	// CONSTRUCTOR
0: 	//
0: 	///////////////////////////////////////////////////////////////////////
0: 
0: 	/**
0: 	 * By the time this is done, it has constructed the following class:
0: 	 * <pre>
0: 	 *    public class #className extends #superClass {
0: 	 *		// public void reset() { return; }
0: 	 *		public ResultSet execute() throws StandardException {
0: 	 *			throwIfClosed("execute");
0: 	 *			// statements must be added here
0: 	 *		}
0: 	 *		public #className() { super(); }
0: 	 *    }
0: 	 * </pre>
0: 	 *
0: 	 * @exception StandardException thrown on failure
0: 	 */
0: 	public ActivationClassBuilder (String superClass, CompilerContext cc) throws StandardException
0: 	{
0: 		super( superClass, (String) null, cc );
0: 		executeMethod = beginExecuteMethod();
0: 	}
0: 
0: 	///////////////////////////////////////////////////////////////////////
0: 	//
0: 	// ACCESSORS
0: 	//
0: 	///////////////////////////////////////////////////////////////////////
0: 
0: 	/**
0: 	  *	Get the package name that this generated class lives in
0: 	  *
0: 	  *	@return	package name
0: 	  */
0:     public	String	getPackageName()
0: 	{	return	CodeGeneration.GENERATED_PACKAGE_PREFIX; }
0: 
0: 	/**
0: 		The base class for activations is BaseActivation
0: 	 */
0: 	public String getBaseClassName() {
0: 	    return ClassName.BaseActivation;
0: 	}
0: 
0: 
0: 	/**
0: 	  *	Get the number of ExecRows to allocate
0: 	  *
0: 	  * @exception StandardException thrown on failure
0: 	  *	@return	package name
0: 	  */
0: 	public	int		getRowCount()
0: 		 throws StandardException
0: 	{
0: 		return	myCompCtx.getNumResultSets();
0: 	}
0: 
0: 	/**
0: 	 * Generate the assignment for numSubqueries = x
0: 	 *
0: 	 * @param numSubqueries		The number of subqueries in the query.
0: 	 *
0: 	 * @return Nothing.
0: 	 * @exception StandardException thrown on failure
0: 	 */
0: 	public	 void	setNumSubqueries()
0: 	{
0: 		int				numSubqueries = myCompCtx.getNumSubquerys();
0: 
0: 		// If there are no subqueries then
0: 		// the field is set to the correctly
0: 		// value (0) by java.
0: 		if (numSubqueries == 0)
0: 			return;
0: 
0: 		/* Generated code is:
0: 		 *		numSubqueries = x;
0: 		 */
0: 		constructor.pushThis();
0: 		constructor.push(numSubqueries);
0: 		constructor.putField(ClassName.BaseActivation, "numSubqueries", "int");
0: 		constructor.endStatement();
0: 	}
0: 
0: 
0: 	///////////////////////////////////////////////////////////////////////
0: 	//
0: 	// EXECUTE METHODS
0: 	//
0: 	///////////////////////////////////////////////////////////////////////
0: 
0: 	/**
0: 	 * By the time this is done, it has generated the following code
0: 	 * <pre>
0: 	 *		public ResultSet execute() throws StandardException {
0: 	 *			throwIfClosed("execute");
0: 	 *			// statements must be added here
0: 	 *		}
0: 	 *    }
0: 	 * </pre>
0: 	 *
0: 	 * @exception StandardException thrown on failure
0: 	 */
0: 	public	MethodBuilder	beginExecuteMethod()
0: 		throws StandardException
0: 	{
0: 		// create a reset method that does nothing.
0: 		// REVISIT: this might better belong in the Activation
0: 		// superclasses ?? not clear yet what it needs to do.
0: 
0: 		// don't yet need a reset method here. when we do,
0: 		// it will need to call super.reset() as well as
0: 		// whatever it does.
0: 		// mb = cb.newMethodBuilder(
0: 		// 	Modifier.PUBLIC, "void", "reset");
0: 		// mb.addStatement(javaFac.newStatement(
0: 		//		javaFac.newSpecialMethodCall(
0: 		//			thisExpression(),
0: 		//			BaseActivation.CLASS_NAME,
0: 		//			"reset", "void")));
0: 		// mb.addStatement(javaFac.newReturnStatement());
0: 		// mb.complete(); // there is nothing else.
0: 
0: 
0: 		// This method is an implementation of the interface method
0: 		// Activation - ResultSet execute()
0: 
0: 		// create an empty execute method
0: 		MethodBuilder mb = cb.newMethodBuilder(Modifier.PUBLIC,
0: 			ClassName.ResultSet, "execute");
0: 		mb.addThrownException(ClassName.StandardException);
0: 
0: 		// put a 'throwIfClosed("execute");' statement into the execute method.
0: 		mb.pushThis(); // instance
0: 		mb.push("execute");
0: 		mb.callMethod(VMOpcode.INVOKEVIRTUAL, ClassName.BaseActivation, "throwIfClosed", "void", 1);
0: 
0: 		// call this.startExecution(), so the parent class can know an execution
0: 		// has begun.
0: 
0: 		mb.pushThis(); // instance
0: 		mb.callMethod(VMOpcode.INVOKEVIRTUAL, ClassName.BaseActivation, "startExecution", "void", 0);
0: 
0: 		return	mb;
0: 	}
0: 
0: 	public MethodBuilder startResetMethod() {
0: 		MethodBuilder mb = cb.newMethodBuilder(Modifier.PUBLIC,
0: 			"void", "reset");
0: 
0: 		mb.addThrownException(ClassName.StandardException);
0: 		mb.pushThis();
0: 		mb.callMethod(VMOpcode.INVOKESPECIAL, ClassName.BaseActivation, "reset", "void", 0);
0: 
0: 
0: 		return mb;
0: 	}
0: 
0: 	/**
0: 	 * An execute method always ends in a return statement, returning
0: 	 * the result set that has been constructed.  We want to
0: 	 * do some bookkeeping on that statement, so we generate
0: 	 * the return given the result set.
0: 
0: 	   Upon entry the only word on the stack is the result set expression
0: 	 */
0: 	public void finishExecuteMethod(boolean genMarkAsTopNode) {
0: 
0: 		executeMethod.pushThis();
0: 		executeMethod.getField(ClassName.BaseActivation, "resultSet", ClassName.ResultSet);
0: 
0: 		/* We only call markAsTopResultSet() for selects.
0: 		 * Non-select DML marks the top NoPutResultSet in the constructor.
0: 		 * Needed for closing down resultSet on an error.
0: 		 */
0: 		if (genMarkAsTopNode)
0: 		{
0: 			// dup the result set to leave one for the return and one for this call
0: 			executeMethod.dup();
0: 			executeMethod.cast(ClassName.NoPutResultSet);
0: 			executeMethod.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, "markAsTopResultSet", "void", 0);
0: 		}
0: 
0: 		/* return resultSet */
0: 		executeMethod.methodReturn();
0: 		executeMethod.complete();
0: 
0: 		getClassBuilder().newFieldWithAccessors("getExecutionCount", "setExecutionCount",
0: 			Modifier.PROTECTED, true, "int");
0: 
0: 		getClassBuilder().newFieldWithAccessors("getRowCountCheckVector", "setRowCountCheckVector",
0: 			Modifier.PROTECTED, true, "java.util.Vector");
0: 
0: 		getClassBuilder().newFieldWithAccessors("getStalePlanCheckInterval", "setStalePlanCheckInterval",
0: 			Modifier.PROTECTED, true, "int");
0: 
0: 		if (closeActivationMethod != null) {
0: 			closeActivationMethod.methodReturn();
0: 			closeActivationMethod.complete();
0: 		}
0: 	}
0: 
0: 	///////////////////////////////////////////////////////////////////////
0: 	//
0: 	// CURSOR SUPPORT
0: 	//
0: 	///////////////////////////////////////////////////////////////////////
0: 
0: 	/**
0: 	 * Updatable cursors
0: 	 * need to add a getter method for use in BaseActivation to access
0: 	 * the result set that identifies target rows for a positioned
0: 	 * update or delete.
0: 	 * <p>
0: 	 * The code that is generated is:
0: 	 * <pre><verbatim>
0: 	 *  public CursorResultSet getTargetResultSet() {
0: 	 *	    return targetResultSet;
0: 	 *  }
0: 	 *
0: 	 *  public CursorResultSet getCursorResultSet() {
0: 	 *		return cursorResultSet;
0: 	 *  }
0: 	 * </verbatim></pre>
0: 	 *
0: 	 */
0: 	public void addCursorPositionCode() {
0: 
0: 		// the getter
0: 		// This method is an implementation of the interface method
0: 		// CursorActivation - CursorResultSet getTargetResultSet()
0: 		MethodBuilder getter = cb.newMethodBuilder(Modifier.PUBLIC, 
0: 			ClassName.CursorResultSet, "getTargetResultSet");
0: 
0: 		getter.getField(targetResultSetField);
0: 		getter.methodReturn();
0: 		getter.complete();
0: 
0: 		// This method is an implementation of the interface method
0: 		// CursorActivation - CursorResultSet getCursorResultSet()
0: 
0: 		getter = cb.newMethodBuilder(Modifier.PUBLIC, 
0: 			ClassName.CursorResultSet, "getCursorResultSet");
0: 
0: 		getter.getField(cursorResultSetField);
0: 		getter.methodReturn();
0: 		getter.complete();
0: 	}
0: 
0: 	/**
0: 	 * Updatable cursors
0: 	 * need to add a field and its initialization
0: 	 * for use in BaseActivation to access the result set that
0: 	 * identifies target rows for a positioned update or delete.
0: 	 * <p>
0: 	 * The code that is generated is:
0: 	 * <pre><verbatim>
0: 	 *  private CursorResultSet targetResultSet;
0: 	 *
0: 	 * </verbatim></pre>
0: 	 *
0: 	 * The expression that is generated is:
0: 	 * <pre><verbatim>
0: 	 *  (ResultSet) (targetResultSet = (CursorResultSet) #expression#)
0: 	 * </verbatim></pre>
0: 	 *
0: 	 */
0: 	public void rememberCursorTarget(MethodBuilder mb) {
0: 
0: 		// the field
0: 		targetResultSetField = cb.addField(ClassName.CursorResultSet,
0: 					"targetResultSet",
0: 					Modifier.PRIVATE);
0: 
0: 		mb.cast(ClassName.CursorResultSet);
0: 		mb.putField(targetResultSetField);
0: 		mb.cast(ClassName.NoPutResultSet);
0: 	}
0: 
0: 	/**
0: 	 * Updatable cursors
0: 	 * need to add a field and its initialization
0: 	 * for use in BaseActivation to access the result set that
0: 	 * identifies cursor result rows for a positioned update or delete.
0: 	 * <p>
0: 	 * The code that is generated is:
0: 	 * <pre><verbatim>
0: 	 *  private CursorResultSet cursorResultSet;
0: 	 *
0: 	 * </verbatim></pre>
0: 	 *
0: 	 * The expression that is generated is:
0: 	 * <pre><verbatim>
0: 	 *  (ResultSet) (cursorResultSet = (CursorResultSet) #expression#)
0: 	 * </verbatim></pre>
0: 
0:        The expression must be the top stack word when this method is called.
0: 	 *
0: 	 */
0: 	public void rememberCursor(MethodBuilder mb) {
0: 
0: 		// the field
0: 		cursorResultSetField = cb.addField(ClassName.CursorResultSet,
0: 					"cursorResultSet",
0: 					Modifier.PRIVATE);
0: 
0: 		mb.cast(ClassName.CursorResultSet);
0: 		mb.putField(cursorResultSetField);
0: 		mb.cast(ClassName.ResultSet);
0: 	}
0: 
0: 	///////////////////////////////////////////////////////////////////////
0: 	//
0: 	// CURRENT DATE/TIME SUPPORT
0: 	//
0: 	///////////////////////////////////////////////////////////////////////
0: 
0: 	/*
0: 		The first time a current datetime is needed, create the class
0: 		level support for it. The first half of the logic is in our parent
0: 		class. Then we add logic here to tidy up for ResultSet management.
0: 	 */
0: 	protected LocalField getCurrentSetup()
0: 	{
0: 		if (cdtField != null) return cdtField;
0: 
0: 		LocalField lf = super.getCurrentSetup();
0: 
0: 		// 3) the execute method gets a statement (prior to the return)
0: 		//    to tell cdt to restart:
0: 		//	  cdt.forget();
0: 
0: 		executeMethod.getField(lf);
0: 		executeMethod.callMethod(VMOpcode.INVOKEVIRTUAL, (String) null, "forget", "void", 0);
0: 
0: 		// 4) a resultSetClosed method is set up to be passed to
0: 		//    the outermost result set, if it is an open/close result set,
0: 		//    so that cdt can be told to forget when a result set closes:
0: 		//	  GeneratedMethod rscm; // the name is just a generated name, simpler.
0: 		//    void rscm() {
0: 		//		cdt.forget();
0: 		//	  }
0: 		MethodBuilder mb = newExprFun();
0: 		mb.getField(lf); // the instance
0: 		mb.callMethod(VMOpcode.INVOKEVIRTUAL, (String) null, "forget", "void", 0);
0: 		mb.pushNull("java.lang.Object");
0: 		mb.methodReturn();
0: 		mb.complete();
0: 		
0: 		resultSetClosedMethod = mb;
0: 
0: 		return lf;
0: 	}
0: 
0: 	//////////////////////////////////////////////////////////////////////////
0: 	//
0: 	//	NAMED PARAMETER METHODS
0: 	//
0: 	//////////////////////////////////////////////////////////////////////////
0: 
0: 	/**
0: 	 *	Generates a parameter reference. Only implemented for Filters right now.
0: 	 *
0: 	 *	@param	name		Parameter name.
0: 	 *	@param	position	Parameter id.
0: 	 *	@param	dataType	Parameter datatype.
0: 	 *  @param	mb			The method to put the generated code into
0: 	 *
0: 	 *	@return	an expression representing the parameter reference.
0: 	 *
0: 	 * 	@exception StandardException thrown on failure
0: 	 */
0: 	public	void	getParameterReference( String				name,
0: 											   int					position,
0: 											   DataTypeDescriptor		dataType,
0: 											   MethodBuilder		mb )
0: 		 throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.NOTREACHED();
0: 	}
0: 
0: 
0: 	public MethodBuilder getCloseActivationMethod() {
0: 
0: 		if (closeActivationMethod == null) {
0: 			closeActivationMethod = cb.newMethodBuilder(Modifier.PUBLIC, "void", "closeActivationAction");
0: 			closeActivationMethod.addThrownException("java.lang.Exception");
0: 		}
0: 		return closeActivationMethod;
0: 	}
0: }
0: 
============================================================================