1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.execute.IndexChanger
1:345de35: 
1:f6123ee:    Licensed to the Apache Software Foundation (ASF) under one or more
1:f6123ee:    contributor license agreements.  See the NOTICE file distributed with
1:f6123ee:    this work for additional information regarding copyright ownership.
1:f6123ee:    The ASF licenses this file to you under the Apache License, Version 2.0
1:f6123ee:    (the "License"); you may not use this file except in compliance with
1:f6123ee:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
16:eac0369: 
2:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.sql.execute;
1:b31849d: 
1:b31849d: import java.util.Properties;
1:b31849d: import org.apache.derby.catalog.UUID;
1:b31849d: import org.apache.derby.iapi.error.StandardException;
1:b31849d: import org.apache.derby.iapi.reference.SQLState;
1:b31849d: import org.apache.derby.iapi.services.i18n.MessageService;
1:b31849d: import org.apache.derby.iapi.services.io.FormatableBitSet;
1:eac0369: import org.apache.derby.iapi.services.monitor.Monitor;
1:eac0369: import org.apache.derby.iapi.sql.Activation;
1:b31849d: import org.apache.derby.iapi.sql.ResultDescription;
1:b31849d: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1:b31849d: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
1:b31849d: import org.apache.derby.iapi.sql.dictionary.ConstraintDescriptor;
1:f6d02c9: import org.apache.derby.iapi.sql.dictionary.ConstraintDescriptorList;
1:b31849d: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1:b31849d: import org.apache.derby.iapi.sql.dictionary.IndexRowGenerator;
1:f6d02c9: import org.apache.derby.iapi.sql.dictionary.ReferencedKeyConstraintDescriptor;
1:b31849d: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1:b31849d: import org.apache.derby.iapi.sql.execute.CursorResultSet;
1:b31849d: import org.apache.derby.iapi.sql.execute.ExecIndexRow;
1:b31849d: import org.apache.derby.iapi.sql.execute.ExecRow;
1:0c5bc3a: import org.apache.derby.iapi.store.access.BackingStoreHashtable;
1:eac0369: import org.apache.derby.iapi.store.access.ConglomerateController;
1:eac0369: import org.apache.derby.iapi.store.access.DynamicCompiledOpenConglomInfo;
1:eac0369: import org.apache.derby.iapi.store.access.ScanController;
1:eac0369: import org.apache.derby.iapi.store.access.StaticCompiledOpenConglomInfo;
1:eac0369: import org.apache.derby.iapi.store.access.TransactionController;
1:eac0369: import org.apache.derby.iapi.types.DataValueDescriptor;
1:eac0369: import org.apache.derby.iapi.types.RowLocation;
1:0c5bc3a: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: 
3:eac0369: /**
1:05623b6:   Perform Index maintenance associated with DML operations for a single index.
1:eac0369:   */
1:05623b6: class IndexChanger
4:eac0369: {
1:0c5bc3a:     final private IndexRowGenerator irg;
1:eac0369: 	//Index Conglomerate ID
1:0c5bc3a:     final private long indexCID;
1:0c5bc3a:     final private DynamicCompiledOpenConglomInfo indexDCOCI;
1:0c5bc3a:     final private StaticCompiledOpenConglomInfo indexSCOCI;
1:0c5bc3a:     final private String indexName;
1:eac0369: 	private ConglomerateController baseCC;
1:0c5bc3a:     final private TransactionController tc;
1:0c5bc3a:     final private int lockMode;
1:0c5bc3a:     final private FormatableBitSet baseRowReadMap;
1:eac0369: 
1:eac0369: 	private ConglomerateController indexCC = null;
1:eac0369: 	private ScanController indexSC = null;
1:eac0369: 
1:eac0369: 	//
1:eac0369: 	//Index rows used by this module to perform DML.
1:eac0369: 	private ExecIndexRow ourIndexRow = null;
1:eac0369: 	private ExecIndexRow ourUpdatedIndexRow = null;
1:eac0369: 
1:eac0369: 	private TemporaryRowHolderImpl	rowHolder = null;
1:eac0369: 	private boolean					rowHolderPassedIn;
1:eac0369: 	private int						isolationLevel;
1:48d2629: 	private final Activation				activation;
1:eac0369: 	private boolean					ownIndexSC = true;
1:eac0369: 
1:0c5bc3a:     private final boolean deferrable; // supports a deferrable constraint
1:0c5bc3a:     private final LanguageConnectionContext lcc;
1:af1c18c:     private BackingStoreHashtable deferredDuplicates; // cached for speed
1:0c5bc3a: 
1:0c5bc3a:     /**
1:eac0369: 	  Create an IndexChanger
1:eac0369: 
1:eac0369: 	  @param irg the IndexRowGenerator for the index.
1:eac0369: 	  @param indexCID the conglomerate id for the index.
1:05623b6: 	  @param indexSCOCI the SCOCI for the indexes.
1:05623b6: 	  @param indexDCOCI the DCOCI for the indexes.
1:eac0369: 	  @param baseCC the ConglomerateController for the base table.
1:eac0369: 	  @param tc			The TransactionController
1:eac0369: 	  @param lockMode	The lock mode (granularity) to use
1:eac0369: 	  @param baseRowReadMap Map of columns read in.  1 based.
1:eac0369: 	  @param isolationLevel	Isolation level to use.
1:eac0369: 	  @param activation	Current activation
1:eac0369: 
1:eac0369: 	  @exception StandardException		Thrown on error
1:eac0369: 	  */
1:05623b6:     IndexChanger
1:eac0369: 	(
1:eac0369: 		IndexRowGenerator 		irg,
1:eac0369: 		long 					indexCID,
1:eac0369: 	    StaticCompiledOpenConglomInfo indexSCOCI,
1:eac0369: 		DynamicCompiledOpenConglomInfo indexDCOCI,
1:eac0369: 		String					indexName,
1:eac0369: 		ConglomerateController	baseCC,
1:eac0369: 		TransactionController 	tc,
1:eac0369: 		int 					lockMode,
1:eac0369: 		FormatableBitSet					baseRowReadMap,
1:eac0369: 		int						isolationLevel,
1:eac0369: 		Activation				activation
1:eac0369: 	)
4:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369: 		this.irg = irg;
1:0c5bc3a:         this.deferrable = irg.hasDeferrableChecking(); // cache value
1:0c5bc3a:                                                        // for speed..
1:eac0369: 		this.indexCID = indexCID;
1:eac0369: 		this.indexSCOCI = indexSCOCI;
1:eac0369: 		this.indexDCOCI = indexDCOCI;
1:eac0369: 		this.baseCC = baseCC;
1:eac0369: 		this.tc = tc;
1:eac0369: 		this.lockMode = lockMode;
1:eac0369: 		this.baseRowReadMap = baseRowReadMap;
1:eac0369: 		this.rowHolderPassedIn = false;
1:eac0369: 		this.isolationLevel = isolationLevel;
1:eac0369: 		this.activation = activation;
1:eac0369: 		this.indexName = indexName;
1:eac0369: 
1:0c5bc3a:         this.lcc = (activation != null) ?
1:0c5bc3a:                 activation.getLanguageConnectionContext() : null;
1:0c5bc3a:         // activation will be null when called from DataDictionary
1:0c5bc3a:         if (activation != null &&
1:0c5bc3a:                 activation.getIndexConglomerateNumber() == indexCID)
1:eac0369: 		{
1:eac0369: 			ownIndexSC = false;
7:eac0369: 		}
1:eac0369: 	
2:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(tc != null, 
1:eac0369: 				"TransactionController argument to constructor is null");
1:0c5bc3a: 		}
1:0c5bc3a: 
1:eac0369:     }
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set the row holder for this changer to use.
1:eac0369: 	 * If the row holder is set, it wont bother 
1:eac0369: 	 * saving copies of rows needed for deferred
1:eac0369: 	 * processing.  Also, it will never close the
1:eac0369: 	 * passed in rowHolder.
2:eac0369: 	 *
1:eac0369: 	 * @param rowHolder	the row holder
1:eac0369: 	 */
1:05623b6:     void setRowHolder(TemporaryRowHolderImpl rowHolder)
1:eac0369: 	{
1:eac0369: 		this.rowHolder = rowHolder;
1:eac0369: 		rowHolderPassedIn = (rowHolder != null);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Propagate the heap's ConglomerateController to
1:eac0369: 	 * this index changer.
1:eac0369: 	 *
1:eac0369: 	 * @param baseCC	The heap's ConglomerateController.
1:eac0369: 	 */
1:05623b6:     void setBaseCC(ConglomerateController baseCC)
1:eac0369: 	{
1:eac0369: 		this.baseCC = baseCC;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  Set the column values for 'ourIndexRow' to refer to 
1:eac0369: 	  a base table row and location provided by the caller.
1:eac0369: 	  The idea here is to 
1:eac0369: 	  @param baseRow a base table row.
1:eac0369: 	  @param baseRowLoc baseRowLoc baseRow's location
1:eac0369: 	  @exception StandardException		Thrown on error
1:eac0369: 	  */
1:eac0369: 	private void setOurIndexRow(ExecRow baseRow,
2:eac0369: 								RowLocation baseRowLoc)
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369: 			if (ourIndexRow == null)
1:eac0369: 				ourIndexRow = irg.getIndexRowTemplate();
1:eac0369: 		
1:eac0369: 			irg.getIndexRow(baseRow, baseRowLoc, ourIndexRow, baseRowReadMap);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  Set the column values for 'ourUpdatedIndexRow' to refer to 
1:eac0369: 	  a base table row and location provided by the caller.
1:eac0369: 	  The idea here is to 
1:eac0369: 	  @param baseRow a base table row.
1:eac0369: 	  @param baseRowLoc baseRowLoc baseRow's location
1:eac0369: 	  @exception StandardException		Thrown on error
1:eac0369: 	  */
1:eac0369: 	private void setOurUpdatedIndexRow(ExecRow baseRow,
1:eac0369: 								RowLocation baseRowLoc)
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369: 			if (ourUpdatedIndexRow == null)
1:eac0369: 				ourUpdatedIndexRow = irg.getIndexRowTemplate();
1:eac0369: 		
1:eac0369: 			irg.getIndexRow(baseRow, baseRowLoc, ourUpdatedIndexRow, baseRowReadMap);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Determine whether or not any columns in the current index
1:eac0369: 	 * row are being changed by the update.  No need to update the
1:eac0369: 	 * index if no columns changed.
1:eac0369: 	 *
2:eac0369: 	 * @return Nothing.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	private boolean indexRowChanged()
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		int numColumns = ourIndexRow.nColumns();
1:eac0369: 		for (int index = 1; index <= numColumns; index++)
1:eac0369: 		{
1:eac0369: 			DataValueDescriptor oldOrderable = ourIndexRow.getColumn(index);
1:eac0369: 			DataValueDescriptor newOrderable = ourUpdatedIndexRow.getColumn(index);
1:eac0369: 			if (! (oldOrderable.compare(DataValueDescriptor.ORDER_OP_EQUALS, newOrderable, true, true)))
1:eac0369: 			{
1:eac0369: 				return true;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  Position our index scan to 'ourIndexRow'.
1:eac0369: 
1:eac0369: 	  <P>This creates the scan the first time it is called.
1:eac0369: 
1:eac0369: 	  @exception StandardException		Thrown on error
1:eac0369: 	  */
1:eac0369: 	private void setScan()
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369: 		/* Get the SC from the activation if re-using */
1:eac0369: 		if (! ownIndexSC)
1:eac0369: 		{
1:eac0369: 			indexSC = activation.getIndexScanController();
1:eac0369: 		}
1:eac0369: 		else if (indexSC == null)
1:eac0369: 		{
1:eac0369: 			RowLocation templateBaseRowLocation = baseCC.newRowLocationTemplate();
1:eac0369: 			/* DataDictionary doesn't have compiled info */
1:eac0369: 			if (indexSCOCI == null)
1:eac0369: 			{
1:eac0369: 				indexSC = 
1:eac0369: 		            tc.openScan(
1:0c5bc3a: 			              indexCID,
1:eac0369: 				          false,                       /* hold */
1:eac0369: 					      TransactionController.OPENMODE_FORUPDATE, /* forUpdate */
1:eac0369: 						  lockMode,
1:eac0369: 	                      isolationLevel,
1:eac0369: 		                  (FormatableBitSet)null,					/* all fields */
1:eac0369: 			              ourIndexRow.getRowArray(),    /* startKeyValue */
1:eac0369: 				          ScanController.GE,            /* startSearchOp */
1:eac0369: 					      null,                         /* qualifier */
1:eac0369: 						  ourIndexRow.getRowArray(),    /* stopKeyValue */
1:eac0369: 						ScanController.GT             /* stopSearchOp */
1:eac0369: 	                      );
1:eac0369: 			}
1:eac0369: 			else
1:eac0369: 			{
1:eac0369: 				indexSC = 
1:eac0369: 		            tc.openCompiledScan(
1:eac0369: 				          false,                       /* hold */
1:eac0369: 					      TransactionController.OPENMODE_FORUPDATE, /* forUpdate */
1:eac0369: 						  lockMode,
1:eac0369: 	                      isolationLevel,
1:eac0369: 		                  (FormatableBitSet)null,					/* all fields */
1:eac0369: 			              ourIndexRow.getRowArray(),    /* startKeyValue */
1:eac0369: 				          ScanController.GE,            /* startSearchOp */
1:eac0369: 					      null,                         /* qualifier */
1:eac0369: 						  ourIndexRow.getRowArray(),    /* stopKeyValue */
1:eac0369: 						  ScanController.GT,             /* stopSearchOp */
1:eac0369: 						  indexSCOCI,
1:eac0369: 						  indexDCOCI
1:eac0369: 	                      );
1:eac0369:             }
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			indexSC.reopenScan(
1:eac0369: 							   ourIndexRow.getRowArray(),			/* startKeyValue */
1:eac0369: 							   ScanController.GE, 	/* startSearchOperator */
1:eac0369: 							   null,	            /* qualifier */
1:eac0369: 							   ourIndexRow.getRowArray(),			/* stopKeyValue */
1:eac0369: 							   ScanController.GT	/* stopSearchOperator */
1:eac0369: 							   );
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  Close our index Conglomerate Controller
1:eac0369: 	  */
1:eac0369: 	private void closeIndexCC()
1:eac0369:         throws StandardException
1:eac0369: 	{
1:eac0369: 		if (indexCC != null)
1:eac0369: 			indexCC.close();
1:eac0369: 		indexCC = null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  Close our index ScanController.
1:eac0369: 	  */
1:eac0369: 	private void closeIndexSC()
1:eac0369:         throws StandardException
1:eac0369: 	{
1:eac0369: 		/* Only consider closing index SC if we own it. */
1:eac0369: 		if (ownIndexSC && indexSC != null)
1:eac0369: 		{
1:eac0369: 			indexSC.close();
1:eac0369: 			indexSC = null;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  Delete a row from our index. This assumes our index ScanController
1:eac0369: 	  is positioned before the row by setScan if we own the SC, otherwise
1:eac0369: 	  it is positioned on the row by the underlying index scan.
1:eac0369: 	  
1:eac0369: 	  <P>This verifies the row exists and is unique.
1:eac0369: 	  
1:eac0369: 	  @exception StandardException		Thrown on error
1:eac0369: 	  */
1:eac0369: 	private void doDelete()
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369: 		if (ownIndexSC)
1:eac0369: 		{
1:eac0369: 			if (! indexSC.next())
1:eac0369: 			{
1:eac0369:                 // This means that the entry for the index does not exist, this
1:eac0369:                 // is a serious problem with the index.  Past fixed problems
1:eac0369:                 // like track 3703 can leave db's in the field with this problem
1:eac0369:                 // even though the bug in the code which caused it has long 
1:eac0369:                 // since been fixed.  Then the problem can surface months later
1:eac0369:                 // when the customer attempts to upgrade.  By "ignoring" the
1:eac0369:                 // missing row here the problem is automatically "fixed" and
1:eac0369:                 // since the code is trying to delete the row anyway it doesn't
1:eac0369:                 // seem like such a bad idea.  It also then gives a tool to 
1:eac0369:                 // support to be able to fix some system catalog problems where
1:eac0369:                 // they can delete the base rows by dropping the system objects
1:eac0369:                 // like stored statements.
1:eac0369: 
1:eac0369: 				if (SanityManager.DEBUG)
1:eac0369: 					SanityManager.THROWASSERT(
1:eac0369:                         "Index row "+RowUtil.toString(ourIndexRow)+
1:eac0369:                         " not found in conglomerateid " + indexCID +
1:eac0369:                         "Current scan = " + indexSC);
1:eac0369: 
1:eac0369:                 Object[] args = new Object[2];
1:eac0369:                 args[0] = ourIndexRow.getRowArray()[ourIndexRow.getRowArray().length - 1];
1:ce40a31:                 args[1] = indexCID;
1:eac0369: 
1:1f18dc3:                 Monitor.getStream().println(MessageService.getTextMessage(
1:eac0369:                     SQLState.LANG_IGNORE_MISSING_INDEX_ROW_DURING_DELETE, 
1:eac0369:                     args));
1:eac0369: 
1:eac0369:                 // just return indicating the row has been deleted.
1:eac0369:                 return;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369:         indexSC.delete();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  Insert a row into our indes.
1:eac0369: 	  
1:eac0369: 	  <P>This opens our index ConglomeratController the first time it
1:eac0369: 	  is called. 
1:eac0369: 	  
1:eac0369: 	  @exception StandardException		Thrown on error
1:eac0369: 	  */
1:eac0369: 	private void doInsert()
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369: 		insertAndCheckDups(ourIndexRow);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  Insert a row into the temporary conglomerate
1:eac0369: 	  
1:eac0369: 	  <P>This opens our deferred ConglomeratController the first time it
1:eac0369: 	  is called.
1:eac0369: 	  
1:eac0369: 	  @exception StandardException		Thrown on error
1:eac0369: 	  */
1:eac0369: 	private void doDeferredInsert()
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369: 		if (rowHolder == null)
1:eac0369: 		{
1:eac0369: 			Properties properties = new Properties();
1:eac0369: 
1:eac0369: 			// Get the properties on the index
1:eac0369: 			openIndexCC().getInternalTablePropertySet(properties);
1:eac0369: 
1:eac0369: 			/*
1:eac0369: 			** Create our row holder.  it is ok to skip passing
1:eac0369: 			** in the result description because if we don't already
1:eac0369: 			** have a row holder, then we are the only user of the
1:eac0369: 			** row holder (the description is needed when the row
1:eac0369: 			** holder is going to be handed to users for triggers).
1:eac0369: 			*/
1:c69c8b0: 			rowHolder = new TemporaryRowHolderImpl(activation, properties,
1:c69c8b0: 												   (ResultDescription) null);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** If the user of the IndexChanger already
1:eac0369: 		** had a row holder, then we don't need to
1:eac0369: 		** bother saving deferred inserts -- they
1:eac0369: 		** have already done so.	
1:eac0369: 		*/
1:eac0369: 		if (!rowHolderPassedIn)
1:eac0369: 		{
1:eac0369: 			rowHolder.insert(ourIndexRow);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:f6d02c9:     private UUID uniqueConstraintId; // cached copy
1:f6d02c9: 
1:f6d02c9:     // Return the id of the corresponding unique or primary key
1:f6d02c9:     // constraint. Note: this only works because deferrable constraints
1:f6d02c9:     // do not share an index with other constraints and explicit indexes, so the
1:f6d02c9:     // mapping back from index conglomerate to constraint is one-to-one.
1:f6d02c9:     private UUID getUniqueConstraintId() throws StandardException {
1:f6d02c9:         if (uniqueConstraintId == null) {
1:f6d02c9:             DataDictionary dd = lcc.getDataDictionary();
1:f6d02c9:             ConglomerateDescriptor cd = dd.getConglomerateDescriptor(indexCID);
1:f6d02c9:             uniqueConstraintId =
1:f6d02c9:                     dd.getConstraintDescriptor(
1:f6d02c9:                     dd.getTableDescriptor(cd.getTableID()),
1:f6d02c9:                     cd.getUUID()).getUUID();
1:f6d02c9:         }
1:f6d02c9: 
1:f6d02c9:         return uniqueConstraintId;
1:f6d02c9:     }
1:f6d02c9: 
1:eac0369: 	/**
1:eac0369: 	 * Insert the given row into the given conglomerate and check for duplicate
1:eac0369: 	 * key error.
1:eac0369: 	 *
1:eac0369: 	 * @param row	The row to insert
1:eac0369: 	 *
1:0c5bc3a:      * @exception StandardException     Thrown on duplicate key error unless
1:0c5bc3a:      *                                  we have a deferred constraint. In that
1:0c5bc3a:      *                                  index rows are saved for checking
1:0c5bc3a:      *                                  on commit.
1:eac0369: 	 */
1:eac0369: 	private void insertAndCheckDups(ExecIndexRow row)
1:eac0369: 				throws StandardException
1:eac0369: 	{
1:eac0369: 		openIndexCC();
1:eac0369: 
1:0c5bc3a:         int insertStatus;
1:eac0369: 
1:0c5bc3a:         final DataValueDescriptor[] rowArray = row.getRowArray();
1:0c5bc3a: 
1:0c5bc3a:         if (deferrable) {
1:0c5bc3a:             insertStatus = indexCC.insert(row.getRowArray());
1:0c5bc3a: 
1:0c5bc3a:             if (SanityManager.DEBUG) { // deferrable: we use a non-unique index
1:0c5bc3a:                 SanityManager.ASSERT(
1:0c5bc3a:                         insertStatus != ConglomerateController.ROWISDUPLICATE);
1:0c5bc3a:             }
1:0c5bc3a: 
1:0c5bc3a:             final DataValueDescriptor [] key =
1:0c5bc3a:                     new DataValueDescriptor[rowArray.length - 1];
1:0c5bc3a:             System.arraycopy(rowArray, 0, key, 0, key.length);
1:ea36b42: 
1:ea36b42:             // If the constraint mode is deferred, perform the check without
1:ea36b42:             // waiting for any locks; we will just presume any lock conflicts
1:ea36b42:             // constitute duplicates (not always the case), and check those keys
1:ea36b42:             // again at commit time.
1:4cc0287:             final boolean deferred = lcc.isEffectivelyDeferred(
1:f6d02c9:                     lcc.getCurrentSQLSessionContext(activation),
1:f6d02c9:                     getUniqueConstraintId());
1:f6d02c9:             // TODO add assert getUniqueConstraintId() != null
1:ea36b42: 
1:0c5bc3a:             ScanController idxScan = tc.openScan(
1:0c5bc3a:                     indexCID,
1:0c5bc3a:                     false,
1:ea36b42:                     (deferred ?
1:ea36b42:                      TransactionController.OPENMODE_LOCK_ROW_NOWAIT :
1:ea36b42:                      0),
1:0c5bc3a:                     TransactionController.MODE_RECORD,
1:0c5bc3a:                     TransactionController.ISOLATION_READ_COMMITTED_NOHOLDLOCK,
1:0c5bc3a:                     (FormatableBitSet)null, // retrieve all fields
1:0c5bc3a:                     key,
1:0c5bc3a:                     ScanController.GE, // startSearchOp
1:0c5bc3a:                     null,
1:0c5bc3a:                     key,
1:0c5bc3a:                     ScanController.GT);
1:0c5bc3a: 
1:0c5bc3a:             boolean duplicate = false;
1:0c5bc3a: 
1:0c5bc3a:             try {
1:0c5bc3a:                 final boolean foundOne = idxScan.next();
1:0c5bc3a: 
1:0c5bc3a:                 if (SanityManager.DEBUG) {
1:0c5bc3a:                     SanityManager.ASSERT(
1:0c5bc3a:                             foundOne, "IndexChanger: inserted row gone?");
1:0c5bc3a:                 }
1:0c5bc3a: 
1:0c5bc3a:                 duplicate = foundOne && idxScan.next();
1:0c5bc3a: 
1:0c5bc3a:             } catch (StandardException e) {
1:400cc60:                 if ((e.getSQLState().equals(SQLState.LOCK_TIMEOUT) ||
1:400cc60:                      e.getSQLState().equals(SQLState.DEADLOCK)) &&
1:ea36b42:                      deferred)  {
1:0c5bc3a:                     // Assume there is a duplicate, so we'll check again at
1:0c5bc3a:                     // commit time.
1:0c5bc3a:                     duplicate = true;
1:0c5bc3a:                 } else {
1:0c5bc3a:                     throw e;
1:0c5bc3a:                 }
1:0c5bc3a:             }
1:0c5bc3a: 
1:0c5bc3a:             if (duplicate && irg.isUniqueWithDuplicateNulls()) {
1:0c5bc3a:                 int keyParts = rowArray.length - 1;
1:0c5bc3a: 
1:0c5bc3a:                 for (int i = 0; i < keyParts; i++) {
1:0c5bc3a:                     // Keys with null in it are always unique
1:0c5bc3a:                     if (rowArray[i].isNull()) {
1:0c5bc3a:                         duplicate = false;
1:0c5bc3a:                         break;
1:0c5bc3a:                     }
1:0c5bc3a:                 }
1:0c5bc3a:             }
1:0c5bc3a: 
1:0c5bc3a:             if (duplicate) {
1:f6d02c9:                 if (deferred) {
1:0c5bc3a:                     // Save duplicate row so we can check at commit time there is
1:0c5bc3a:                     // no longer any duplicate.
1:0c5bc3a: 
1:af1c18c:                     deferredDuplicates =
1:af1c18c:                         DeferredConstraintsMemory.rememberDuplicate(
1:0c5bc3a:                             lcc,
1:af1c18c:                             deferredDuplicates,
1:f6d02c9:                             getUniqueConstraintId(),
1:0c5bc3a:                             row.getRowArray());
1:0c5bc3a:                 } else { // the constraint is not deferred, so throw
1:0c5bc3a:                     insertStatus = ConglomerateController.ROWISDUPLICATE;
1:0c5bc3a:                 }
1:0c5bc3a:             }
1:0c5bc3a: 
1:0c5bc3a:         } else { // not a deferred constraint
1:0c5bc3a:             insertStatus = indexCC.insert(row.getRowArray());
1:0c5bc3a:         }
1:0c5bc3a: 
1:0c5bc3a:         if (insertStatus == ConglomerateController.ROWISDUPLICATE)
1:eac0369: 		{
1:eac0369: 			/*
1:eac0369: 			** We have a duplicate key error. 
1:eac0369: 			*/
1:eac0369: 			String indexOrConstraintName = indexName;
1:eac0369: 			// now get table name, and constraint name if needed
1:eac0369: 			LanguageConnectionContext lcc =
1:eac0369:                 			activation.getLanguageConnectionContext();
1:eac0369: 			DataDictionary dd = lcc.getDataDictionary();
1:eac0369: 			//get the descriptors
1:eac0369: 			ConglomerateDescriptor cd = dd.getConglomerateDescriptor(indexCID);
1:eac0369: 
1:eac0369: 			UUID tableID = cd.getTableID();
1:eac0369: 			TableDescriptor td = dd.getTableDescriptor(tableID);
1:eac0369: 			String tableName = td.getName();
1:eac0369: 			
1:eac0369: 			if (indexOrConstraintName == null) // no index name passed in
1:eac0369: 			{
1:eac0369: 				ConstraintDescriptor conDesc = dd.getConstraintDescriptor(td,
1:eac0369:                                                                       cd.getUUID());
1:eac0369: 				indexOrConstraintName = conDesc.getConstraintName();
1:eac0369: 			}		
1:eac0369: 
1:eac0369: 			StandardException se = 
1:eac0369: 				StandardException.newException(
1:eac0369: 				SQLState.LANG_DUPLICATE_KEY_CONSTRAINT, indexOrConstraintName, tableName);
1:eac0369: 			throw se;
1:0c5bc3a:         } else {
1:0c5bc3a:             if (SanityManager.DEBUG) {
1:0c5bc3a:                 if (insertStatus != 0) {
1:0c5bc3a:                     SanityManager.THROWASSERT("Unknown insert status " + insertStatus);
1:0c5bc3a:                 }
1:0c5bc3a:             }
1:0c5bc3a:         }
1:0c5bc3a:     }
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Open the ConglomerateController for this index if it isn't open yet.
1:eac0369: 	 *
1:eac0369: 	 * @return The ConglomerateController for this index.
1:eac0369: 	 *
2:eac0369: 	 * @exception StandardException		Thrown on duplicate key error
1:eac0369: 	 */
1:eac0369: 	private ConglomerateController openIndexCC()
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		if (indexCC == null)
1:eac0369: 		{
1:eac0369: 			/* DataDictionary doesn't have compiled info */
1:eac0369: 			if (indexSCOCI == null)
1:eac0369: 			{
1:eac0369: 				indexCC = 
1:eac0369: 		            tc.openConglomerate(
1:af1c18c: 						indexCID,
1:eac0369:                         false,
1:eac0369: 			            (TransactionController.OPENMODE_FORUPDATE |
1:eac0369: 				         TransactionController.OPENMODE_BASEROW_INSERT_LOCKED),
1:eac0369: 					    lockMode,
1:eac0369:                         isolationLevel);
1:eac0369: 			}
1:eac0369: 			else
1:eac0369: 			{
1:eac0369: 				indexCC = 
1:eac0369: 		            tc.openCompiledConglomerate(
1:eac0369:                         false,
1:eac0369: 			            (TransactionController.OPENMODE_FORUPDATE |
1:eac0369: 				         TransactionController.OPENMODE_BASEROW_INSERT_LOCKED),
1:eac0369: 					    lockMode,
1:eac0369:                         isolationLevel,
1:eac0369: 						indexSCOCI,
1:eac0369: 						indexDCOCI);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return indexCC;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  Open this IndexChanger.
1:eac0369: 
1:eac0369: 	  @exception StandardException		Thrown on error
1:eac0369: 	  */
1:05623b6:     void open()
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  Perform index maintenance to support a delete of a base table row.
1:eac0369: 
1:eac0369: 	  @param baseRow the base table row.
1:eac0369: 	  @param baseRowLocation the base table row's location.
1:eac0369: 	  @exception StandardException		Thrown on error
1:eac0369: 	  */
1:05623b6:     void delete(ExecRow baseRow, RowLocation baseRowLocation)
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369: 		setOurIndexRow(baseRow, baseRowLocation);
1:eac0369: 		setScan();
1:eac0369: 		doDelete();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  Perform index maintenance to support an update of a base table row.
1:eac0369: 
1:eac0369: 	  @param oldBaseRow         the old image of the base table row.
1:eac0369: 	  @param newBaseRow         the new image of the base table row.
1:eac0369: 	  @param baseRowLocation    the base table row's location.
1:eac0369: 
1:eac0369: 	  @exception StandardException		Thrown on error
1:eac0369: 	  */
1:05623b6:     void update(ExecRow oldBaseRow,
1:eac0369: 					   ExecRow newBaseRow,
1:eac0369: 					   RowLocation baseRowLocation
1:eac0369: 					   )
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369: 		setOurIndexRow(oldBaseRow, baseRowLocation);
1:eac0369: 		setOurUpdatedIndexRow(newBaseRow, baseRowLocation);
1:eac0369: 
1:eac0369: 		/* We skip the update in the degenerate case
1:eac0369: 		 * where none of the key columns changed.
1:eac0369: 		 * (From an actual customer case.)
1:eac0369: 		 */
1:eac0369: 		if (indexRowChanged())
1:eac0369: 		{
1:eac0369: 			setScan();
1:eac0369: 			doDelete();
1:eac0369: 			insertForUpdate(newBaseRow, baseRowLocation);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  Perform index maintenance to support an insert of a base table row.
1:eac0369: 
1:6b50965: 	  @param newRow            the base table row.
1:eac0369: 	  @param baseRowLocation    the base table row's location.
1:eac0369: 
1:eac0369: 	  @exception StandardException		Thrown on error
1:eac0369: 	  */
1:05623b6:     void insert(ExecRow newRow, RowLocation baseRowLocation)
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369: 		setOurIndexRow(newRow, baseRowLocation);
1:eac0369: 		doInsert();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  If we're updating a unique index, the inserts have to be
1:eac0369: 	  deferred.  This is to avoid uniqueness violations that are only
1:eac0369: 	  temporary.  If we do all the deletes first, only "true" uniqueness
1:eac0369: 	  violations can happen.  We do this here, rather than in open(),
1:eac0369: 	  because this is the only operation that requires deferred inserts,
1:eac0369: 	  and we only want to create the conglomerate if necessary.
1:eac0369: 
1:6b50965: 	  @param newRow            the base table row.
1:eac0369: 	  @param baseRowLocation    the base table row's location.
1:eac0369: 
1:eac0369: 	  @exception StandardException		Thrown on error
1:eac0369: 	*/
1:eac0369: 	void insertForUpdate(ExecRow newRow, RowLocation baseRowLocation)
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369: 		setOurIndexRow(newRow, baseRowLocation);
1:28e234d: 		//defer inserts if its on unique or UniqueWhereNotNull index
1:0c5bc3a:         if (irg.isUnique() ||
1:0c5bc3a:             irg.isUniqueWithDuplicateNulls() ||
1:0c5bc3a:             irg.hasDeferrableChecking())
1:eac0369: 		{
1:eac0369: 			doDeferredInsert();
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			doInsert();
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  Finish doing the changes for this index.  This is intended for deferred
1:eac0369: 	  inserts for unique indexes.  It has no effect unless we are doing an
1:eac0369: 	  update of a unique index.
1:eac0369: 
1:eac0369: 	  @exception StandardException		Thrown on error
1:eac0369: 	 */
1:05623b6:     void finish() throws StandardException
1:eac0369: 	{
1:eac0369: 		ExecRow			deferredRow;
1:eac0369: 
1:eac0369: 		/* Deferred processing only necessary for unique indexes */
1:eac0369: 		if (rowHolder != null)
1:eac0369: 		{
1:eac0369: 			CursorResultSet rs = rowHolder.getResultSet();
1:eac0369: 			try
1:eac0369: 			{
1:eac0369: 				rs.open();
1:eac0369: 				while ((deferredRow = rs.getNextRow()) != null)
1:eac0369: 				{
1:eac0369: 					if (SanityManager.DEBUG)
1:eac0369: 					{
1:eac0369: 						if (!(deferredRow instanceof ExecIndexRow))
1:eac0369: 						{
1:eac0369: 							SanityManager.THROWASSERT("deferredRow isn't an instance "+
1:eac0369: 								"of ExecIndexRow as expected. "+
1:eac0369: 								"It is an "+deferredRow.getClass().getName());
1:eac0369: 						}
1:eac0369: 					}
1:eac0369: 					insertAndCheckDups((ExecIndexRow)deferredRow);
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 			finally
1:eac0369: 			{
1:eac0369: 				rs.close();
1:eac0369: 
1:eac0369: 				/*
1:eac0369: 				** If row holder was passed in, let the
1:eac0369: 				** client of this method clean it up.
1:eac0369: 				*/
1:eac0369: 				if (!rowHolderPassedIn)
1:eac0369: 				{
1:eac0369: 					rowHolder.close();
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  Close this IndexChanger.
1:eac0369: 
1:eac0369: 	  @exception StandardException		Thrown on error
1:eac0369: 	  */
1:05623b6:     void close() throws StandardException
1:eac0369: 	{
1:eac0369: 		closeIndexCC();
1:eac0369: 		closeIndexSC();
1:eac0369: 		if (rowHolder != null && !rowHolderPassedIn)
1:eac0369: 		{
1:eac0369: 			rowHolder.close();
1:eac0369: 		}
1:eac0369: 		baseCC = null;
1:eac0369: 	}
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:ce40a31
/////////////////////////////////////////////////////////////////////////
1:                 args[1] = indexCID;
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:f6d02c9
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.dictionary.ConstraintDescriptorList;
1: import org.apache.derby.iapi.sql.dictionary.ReferencedKeyConstraintDescriptor;
/////////////////////////////////////////////////////////////////////////
1:     private UUID uniqueConstraintId; // cached copy
1: 
1:     // Return the id of the corresponding unique or primary key
1:     // constraint. Note: this only works because deferrable constraints
1:     // do not share an index with other constraints and explicit indexes, so the
1:     // mapping back from index conglomerate to constraint is one-to-one.
1:     private UUID getUniqueConstraintId() throws StandardException {
1:         if (uniqueConstraintId == null) {
1:             DataDictionary dd = lcc.getDataDictionary();
1:             ConglomerateDescriptor cd = dd.getConglomerateDescriptor(indexCID);
1:             uniqueConstraintId =
1:                     dd.getConstraintDescriptor(
1:                     dd.getTableDescriptor(cd.getTableID()),
1:                     cd.getUUID()).getUUID();
1:         }
1: 
1:         return uniqueConstraintId;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:                     lcc.getCurrentSQLSessionContext(activation),
1:                     getUniqueConstraintId());
1:             // TODO add assert getUniqueConstraintId() != null
/////////////////////////////////////////////////////////////////////////
1:                 if (deferred) {
/////////////////////////////////////////////////////////////////////////
1:                             getUniqueConstraintId(),
commit:4cc0287
/////////////////////////////////////////////////////////////////////////
1:             final boolean deferred = lcc.isEffectivelyDeferred(
0:                     lcc.getCurrentSQLSessionContext(activation), indexCID);
/////////////////////////////////////////////////////////////////////////
0:                 if (lcc.isEffectivelyDeferred(
0:                         lcc.getCurrentSQLSessionContext(activation),
0:                         indexCID)) {
commit:af1c18c
/////////////////////////////////////////////////////////////////////////
1:     private BackingStoreHashtable deferredDuplicates; // cached for speed
/////////////////////////////////////////////////////////////////////////
1:                     deferredDuplicates =
1:                         DeferredConstraintsMemory.rememberDuplicate(
1:                             deferredDuplicates,
1:                             indexCID,
commit:ea36b42
/////////////////////////////////////////////////////////////////////////
1: 
1:             // If the constraint mode is deferred, perform the check without
1:             // waiting for any locks; we will just presume any lock conflicts
1:             // constitute duplicates (not always the case), and check those keys
1:             // again at commit time.
0:             final boolean deferred =
0:                     lcc.isEffectivelyDeferred(activation, indexCID);
1: 
1:                     (deferred ?
1:                      TransactionController.OPENMODE_LOCK_ROW_NOWAIT :
1:                      0),
/////////////////////////////////////////////////////////////////////////
1:                      deferred)  {
commit:400cc60
/////////////////////////////////////////////////////////////////////////
1:                 if ((e.getSQLState().equals(SQLState.LOCK_TIMEOUT) ||
1:                      e.getSQLState().equals(SQLState.DEADLOCK)) &&
0:                      lcc.isEffectivelyDeferred(activation, indexCID))  {
commit:040d5c5
/////////////////////////////////////////////////////////////////////////
0:                     TransactionController.OPENMODE_LOCK_ROW_NOWAIT,
commit:0c5bc3a
/////////////////////////////////////////////////////////////////////////
0: import java.sql.SQLException;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.store.access.BackingStoreHashtable;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
1:     final private IndexRowGenerator irg;
1:     final private long indexCID;
1:     final private DynamicCompiledOpenConglomInfo indexDCOCI;
1:     final private StaticCompiledOpenConglomInfo indexSCOCI;
1:     final private String indexName;
1:     final private TransactionController tc;
1:     final private int lockMode;
1:     final private FormatableBitSet baseRowReadMap;
/////////////////////////////////////////////////////////////////////////
1:     private final boolean deferrable; // supports a deferrable constraint
1:     private final LanguageConnectionContext lcc;
0:     private BackingStoreHashtable deferredRowsHashTable; // cached for speed
1: 
1:     /**
/////////////////////////////////////////////////////////////////////////
1:         this.deferrable = irg.hasDeferrableChecking(); // cache value
1:                                                        // for speed..
/////////////////////////////////////////////////////////////////////////
1:         this.lcc = (activation != null) ?
1:                 activation.getLanguageConnectionContext() : null;
1:         // activation will be null when called from DataDictionary
1:         if (activation != null &&
1:                 activation.getIndexConglomerateNumber() == indexCID)
/////////////////////////////////////////////////////////////////////////
1: 
1:     }
/////////////////////////////////////////////////////////////////////////
1:      * @exception StandardException     Thrown on duplicate key error unless
1:      *                                  we have a deferred constraint. In that
1:      *                                  index rows are saved for checking
1:      *                                  on commit.
1:         int insertStatus;
1:         final DataValueDescriptor[] rowArray = row.getRowArray();
1: 
1:         if (deferrable) {
1:             insertStatus = indexCC.insert(row.getRowArray());
1: 
1:             if (SanityManager.DEBUG) { // deferrable: we use a non-unique index
1:                 SanityManager.ASSERT(
1:                         insertStatus != ConglomerateController.ROWISDUPLICATE);
1:             }
1: 
1:             final DataValueDescriptor [] key =
1:                     new DataValueDescriptor[rowArray.length - 1];
1:             System.arraycopy(rowArray, 0, key, 0, key.length);
1:             ScanController idxScan = tc.openScan(
1:                     indexCID,
1:                     false,
0:                     0, // FIXME: want NO_WAIT but not yet implemented
0:                        // for row locks in BTRee scan
1:                     TransactionController.MODE_RECORD,
1:                     TransactionController.ISOLATION_READ_COMMITTED_NOHOLDLOCK,
1:                     (FormatableBitSet)null, // retrieve all fields
1:                     key,
1:                     ScanController.GE, // startSearchOp
1:                     null,
1:                     key,
1:                     ScanController.GT);
1: 
1:             boolean duplicate = false;
1: 
1:             try {
1:                 final boolean foundOne = idxScan.next();
1: 
1:                 if (SanityManager.DEBUG) {
1:                     SanityManager.ASSERT(
1:                             foundOne, "IndexChanger: inserted row gone?");
1:                 }
1: 
1:                 duplicate = foundOne && idxScan.next();
1: 
1:             } catch (StandardException e) {
0:                 if (e.getSQLState().equals(SQLState.LOCK_TIMEOUT) ||
0:                     e.getSQLState().equals(SQLState.DEADLOCK)) {
1:                     // Assume there is a duplicate, so we'll check again at
1:                     // commit time.
1:                     duplicate = true;
1:                 } else {
1:                     throw e;
1:                 }
1:             }
1: 
1:             if (duplicate && irg.isUniqueWithDuplicateNulls()) {
1:                 int keyParts = rowArray.length - 1;
1: 
1:                 for (int i = 0; i < keyParts; i++) {
1:                     // Keys with null in it are always unique
1:                     if (rowArray[i].isNull()) {
1:                         duplicate = false;
1:                         break;
1:                     }
1:                 }
1:             }
1: 
1:             if (duplicate) {
0:                 if (lcc.isEffectivelyDeferred(activation, indexCID)) {
1:                     // Save duplicate row so we can check at commit time there is
1:                     // no longer any duplicate.
1: 
0:                     deferredRowsHashTable = DeferredDuplicates.rememberDuplicate(
0:                             tc,
1:                             indexCID,
0:                             deferredRowsHashTable,
1:                             lcc,
1:                             row.getRowArray());
1:                 } else { // the constraint is not deferred, so throw
1:                     insertStatus = ConglomerateController.ROWISDUPLICATE;
1:                 }
1:             }
1: 
1:         } else { // not a deferred constraint
1:             insertStatus = indexCC.insert(row.getRowArray());
1:         }
1: 
1:         if (insertStatus == ConglomerateController.ROWISDUPLICATE)
/////////////////////////////////////////////////////////////////////////
1:         } else {
1:             if (SanityManager.DEBUG) {
1:                 if (insertStatus != 0) {
1:                     SanityManager.THROWASSERT("Unknown insert status " + insertStatus);
1:                 }
1:             }
1:         }
1:     }
/////////////////////////////////////////////////////////////////////////
1:         if (irg.isUnique() ||
1:             irg.isUniqueWithDuplicateNulls() ||
1:             irg.hasDeferrableChecking())
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.shared.common.sanity.SanityManager;
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:1f18dc3
/////////////////////////////////////////////////////////////////////////
1:                 Monitor.getStream().println(MessageService.getTextMessage(
commit:05623b6
/////////////////////////////////////////////////////////////////////////
1:   Perform Index maintenance associated with DML operations for a single index.
1: class IndexChanger
/////////////////////////////////////////////////////////////////////////
1: 	  @param indexSCOCI the SCOCI for the indexes.
1: 	  @param indexDCOCI the DCOCI for the indexes.
/////////////////////////////////////////////////////////////////////////
1:     IndexChanger
/////////////////////////////////////////////////////////////////////////
1:     void setRowHolder(TemporaryRowHolderImpl rowHolder)
/////////////////////////////////////////////////////////////////////////
1:     void setBaseCC(ConglomerateController baseCC)
/////////////////////////////////////////////////////////////////////////
1:     void open()
/////////////////////////////////////////////////////////////////////////
1:     void delete(ExecRow baseRow, RowLocation baseRowLocation)
/////////////////////////////////////////////////////////////////////////
1:     void update(ExecRow oldBaseRow,
/////////////////////////////////////////////////////////////////////////
1:     void insert(ExecRow newRow, RowLocation baseRowLocation)
/////////////////////////////////////////////////////////////////////////
1:     void finish() throws StandardException
/////////////////////////////////////////////////////////////////////////
1:     void close() throws StandardException
commit:c69c8b0
/////////////////////////////////////////////////////////////////////////
1: 			rowHolder = new TemporaryRowHolderImpl(activation, properties,
1: 												   (ResultDescription) null);
commit:81b9853
/////////////////////////////////////////////////////////////////////////
0: 			rowHolder = new TemporaryRowHolderImpl(activation, properties,
0: 												   (ResultDescription) null);
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:28e234d
/////////////////////////////////////////////////////////////////////////
1: 		//defer inserts if its on unique or UniqueWhereNotNull index
0: 		if (irg.isUnique() || irg.isUniqueWithDuplicateNulls())
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:88bb146
/////////////////////////////////////////////////////////////////////////
0: 			rowHolder = new TemporaryRowHolderImpl(activation, properties);
commit:51f60c6
/////////////////////////////////////////////////////////////////////////
commit:48d2629
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	private final Activation				activation;
/////////////////////////////////////////////////////////////////////////
commit:b31849d
/////////////////////////////////////////////////////////////////////////
1: import java.util.Properties;
1: 
1: import org.apache.derby.catalog.UUID;
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.services.i18n.MessageService;
1: import org.apache.derby.iapi.services.io.FormatableBitSet;
1: import org.apache.derby.iapi.sql.ResultDescription;
1: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.ConstraintDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1: import org.apache.derby.iapi.sql.dictionary.IndexRowGenerator;
1: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1: import org.apache.derby.iapi.sql.execute.CursorResultSet;
1: import org.apache.derby.iapi.sql.execute.ExecIndexRow;
1: import org.apache.derby.iapi.sql.execute.ExecRow;
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.execute.IndexChanger
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:61070a6
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.execute
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.sql.execute;
1: 
1: import org.apache.derby.iapi.services.monitor.Monitor;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: import org.apache.derby.iapi.sql.dictionary.IndexRowGenerator;
0: import org.apache.derby.iapi.sql.ResultDescription;
0: import org.apache.derby.iapi.sql.execute.CursorResultSet;
0: import org.apache.derby.iapi.sql.execute.ExecRow;
0: import org.apache.derby.iapi.sql.execute.ExecIndexRow;
0: import org.apache.derby.iapi.sql.execute.ExecutionContext;
0: import org.apache.derby.iapi.sql.execute.ExecutionFactory;
1: 
0: import org.apache.derby.iapi.reference.SQLState;
1: 
1: import org.apache.derby.iapi.sql.Activation;
1: 
1: import org.apache.derby.iapi.store.access.ConglomerateController;
1: import org.apache.derby.iapi.store.access.DynamicCompiledOpenConglomInfo;
1: import org.apache.derby.iapi.store.access.ScanController;
1: import org.apache.derby.iapi.store.access.StaticCompiledOpenConglomInfo;
1: import org.apache.derby.iapi.store.access.TransactionController;
1: 
0: import org.apache.derby.catalog.UUID;
0: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.ConstraintDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptorList;
1: 
1: import org.apache.derby.iapi.types.DataValueDescriptor;
1: import org.apache.derby.iapi.types.RowLocation;
1: 
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: import org.apache.derby.iapi.services.i18n.MessageService;
0: import java.util.Properties;
1: 
1: /**
0:   Perform Index maintenace associated with DML operations for a single index.
1:   */
0: public class IndexChanger
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	private IndexRowGenerator irg;
1: 	//Index Conglomerate ID
0: 	private long indexCID;
0: 	private DynamicCompiledOpenConglomInfo indexDCOCI;
0: 	private StaticCompiledOpenConglomInfo indexSCOCI;
0: 	private String indexName;
1: 	private ConglomerateController baseCC;
0: 	private TransactionController tc;
0: 	private int lockMode;
0: 	private FormatableBitSet baseRowReadMap;
1: 
1: 	private ConglomerateController indexCC = null;
1: 	private ScanController indexSC = null;
1: 
0: 	private LanguageConnectionContext lcc;
1: 
1: 	//
1: 	//Index rows used by this module to perform DML.
1: 	private ExecIndexRow ourIndexRow = null;
1: 	private ExecIndexRow ourUpdatedIndexRow = null;
1: 
1: 	private TemporaryRowHolderImpl	rowHolder = null;
1: 	private boolean					rowHolderPassedIn;
1: 	private int						isolationLevel;
0: 	private Activation				activation;
1: 	private boolean					ownIndexSC = true;
1: 
1: 	/**
1: 	  Create an IndexChanger
1: 
1: 	  @param irg the IndexRowGenerator for the index.
1: 	  @param indexCID the conglomerate id for the index.
0: 	  @param indexSCOCI the SCOCI for the idexes. 
0: 	  @param indexDCOCI the DCOCI for the idexes. 
1: 	  @param baseCC the ConglomerateController for the base table.
1: 	  @param tc			The TransactionController
1: 	  @param lockMode	The lock mode (granularity) to use
1: 	  @param baseRowReadMap Map of columns read in.  1 based.
1: 	  @param isolationLevel	Isolation level to use.
1: 	  @param activation	Current activation
1: 
1: 	  @exception StandardException		Thrown on error
1: 	  */
0: 	public IndexChanger
1: 	(
1: 		IndexRowGenerator 		irg,
1: 		long 					indexCID,
1: 	    StaticCompiledOpenConglomInfo indexSCOCI,
1: 		DynamicCompiledOpenConglomInfo indexDCOCI,
1: 		String					indexName,
1: 		ConglomerateController	baseCC,
1: 		TransactionController 	tc,
1: 		int 					lockMode,
1: 		FormatableBitSet					baseRowReadMap,
1: 		int						isolationLevel,
1: 		Activation				activation
1: 	)
1: 		 throws StandardException
1: 	{
1: 		this.irg = irg;
1: 		this.indexCID = indexCID;
1: 		this.indexSCOCI = indexSCOCI;
1: 		this.indexDCOCI = indexDCOCI;
1: 		this.baseCC = baseCC;
1: 		this.tc = tc;
1: 		this.lockMode = lockMode;
1: 		this.baseRowReadMap = baseRowReadMap;
1: 		this.rowHolderPassedIn = false;
1: 		this.isolationLevel = isolationLevel;
1: 		this.activation = activation;
1: 		this.indexName = indexName;
1: 
0: 		// activation will be null when called from DataDictionary
0: 		if (activation != null && activation.getIndexConglomerateNumber() == indexCID)
1: 		{
1: 			ownIndexSC = false;
1: 		}
1: 	
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(tc != null, 
1: 				"TransactionController argument to constructor is null");
0: 			SanityManager.ASSERT(irg != null, 
0: 				"IndexRowGenerator argument to constructor is null");
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Set the row holder for this changer to use.
1: 	 * If the row holder is set, it wont bother 
1: 	 * saving copies of rows needed for deferred
1: 	 * processing.  Also, it will never close the
1: 	 * passed in rowHolder.
1: 	 *
1: 	 * @param rowHolder	the row holder
1: 	 */
0: 	public void setRowHolder(TemporaryRowHolderImpl rowHolder)
1: 	{
1: 		this.rowHolder = rowHolder;
1: 		rowHolderPassedIn = (rowHolder != null);
1: 	}
1: 
1: 	/**
1: 	 * Propagate the heap's ConglomerateController to
1: 	 * this index changer.
1: 	 *
1: 	 * @param baseCC	The heap's ConglomerateController.
1: 	 *
1: 	 * @return Nothing.
1: 	 */
0: 	public void setBaseCC(ConglomerateController baseCC)
1: 	{
1: 		this.baseCC = baseCC;
1: 	}
1: 
1: 	/**
1: 	  Set the column values for 'ourIndexRow' to refer to 
1: 	  a base table row and location provided by the caller.
1: 	  The idea here is to 
1: 	  @param baseRow a base table row.
1: 	  @param baseRowLoc baseRowLoc baseRow's location
1: 	  @exception StandardException		Thrown on error
1: 	  */
1: 	private void setOurIndexRow(ExecRow baseRow,
1: 								RowLocation baseRowLoc)
1: 		 throws StandardException
1: 	{
1: 			if (ourIndexRow == null)
1: 				ourIndexRow = irg.getIndexRowTemplate();
1: 		
1: 			irg.getIndexRow(baseRow, baseRowLoc, ourIndexRow, baseRowReadMap);
1: 	}
1: 
1: 	/**
1: 	  Set the column values for 'ourUpdatedIndexRow' to refer to 
1: 	  a base table row and location provided by the caller.
1: 	  The idea here is to 
1: 	  @param baseRow a base table row.
1: 	  @param baseRowLoc baseRowLoc baseRow's location
1: 	  @exception StandardException		Thrown on error
1: 	  */
1: 	private void setOurUpdatedIndexRow(ExecRow baseRow,
1: 								RowLocation baseRowLoc)
1: 		 throws StandardException
1: 	{
1: 			if (ourUpdatedIndexRow == null)
1: 				ourUpdatedIndexRow = irg.getIndexRowTemplate();
1: 		
1: 			irg.getIndexRow(baseRow, baseRowLoc, ourUpdatedIndexRow, baseRowReadMap);
1: 	}
1: 
1: 	/**
1: 	 * Determine whether or not any columns in the current index
1: 	 * row are being changed by the update.  No need to update the
1: 	 * index if no columns changed.
1: 	 *
1: 	 * @return Nothing.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	private boolean indexRowChanged()
1: 		throws StandardException
1: 	{
1: 		int numColumns = ourIndexRow.nColumns();
1: 		for (int index = 1; index <= numColumns; index++)
1: 		{
1: 			DataValueDescriptor oldOrderable = ourIndexRow.getColumn(index);
1: 			DataValueDescriptor newOrderable = ourUpdatedIndexRow.getColumn(index);
1: 			if (! (oldOrderable.compare(DataValueDescriptor.ORDER_OP_EQUALS, newOrderable, true, true)))
1: 			{
1: 				return true;
1: 			}
1: 		}
1: 		return false;
1: 	}
1: 
0: 	private ExecIndexRow getDeferredIndexRowTemplate(ExecRow baseRow,
1: 													RowLocation baseRowLoc)
1: 		 throws StandardException
1: 	{
0: 		ExecIndexRow	template;
1: 
0: 		template = irg.getIndexRowTemplate();
1: 
0: 		irg.getIndexRow(baseRow, baseRowLoc, template, baseRowReadMap);
1: 
0: 		return template;
1: 	}
1: 
1: 	/**
1: 	  Position our index scan to 'ourIndexRow'.
1: 
1: 	  <P>This creates the scan the first time it is called.
1: 
1: 	  @exception StandardException		Thrown on error
1: 	  */
1: 	private void setScan()
1: 		 throws StandardException
1: 	{
1: 		/* Get the SC from the activation if re-using */
1: 		if (! ownIndexSC)
1: 		{
1: 			indexSC = activation.getIndexScanController();
1: 		}
1: 		else if (indexSC == null)
1: 		{
1: 			RowLocation templateBaseRowLocation = baseCC.newRowLocationTemplate();
1: 			/* DataDictionary doesn't have compiled info */
1: 			if (indexSCOCI == null)
1: 			{
1: 				indexSC = 
1: 		            tc.openScan(
0: 			              indexCID,
1: 				          false,                       /* hold */
1: 					      TransactionController.OPENMODE_FORUPDATE, /* forUpdate */
1: 						  lockMode,
1: 	                      isolationLevel,
1: 		                  (FormatableBitSet)null,					/* all fields */
1: 			              ourIndexRow.getRowArray(),    /* startKeyValue */
1: 				          ScanController.GE,            /* startSearchOp */
1: 					      null,                         /* qualifier */
1: 						  ourIndexRow.getRowArray(),    /* stopKeyValue */
1: 						ScanController.GT             /* stopSearchOp */
1: 	                      );
1: 			}
1: 			else
1: 			{
1: 				indexSC = 
1: 		            tc.openCompiledScan(
1: 				          false,                       /* hold */
1: 					      TransactionController.OPENMODE_FORUPDATE, /* forUpdate */
1: 						  lockMode,
1: 	                      isolationLevel,
1: 		                  (FormatableBitSet)null,					/* all fields */
1: 			              ourIndexRow.getRowArray(),    /* startKeyValue */
1: 				          ScanController.GE,            /* startSearchOp */
1: 					      null,                         /* qualifier */
1: 						  ourIndexRow.getRowArray(),    /* stopKeyValue */
1: 						  ScanController.GT,             /* stopSearchOp */
1: 						  indexSCOCI,
1: 						  indexDCOCI
1: 	                      );
1:             }
1: 		}
1: 		else
1: 		{
1: 			indexSC.reopenScan(
1: 							   ourIndexRow.getRowArray(),			/* startKeyValue */
1: 							   ScanController.GE, 	/* startSearchOperator */
1: 							   null,	            /* qualifier */
1: 							   ourIndexRow.getRowArray(),			/* stopKeyValue */
1: 							   ScanController.GT	/* stopSearchOperator */
1: 							   );
1: 		}
1: 	}
1: 
1: 	/**
1: 	  Close our index Conglomerate Controller
1: 	  */
1: 	private void closeIndexCC()
1:         throws StandardException
1: 	{
1: 		if (indexCC != null)
1: 			indexCC.close();
1: 		indexCC = null;
1: 	}
1: 
1: 	/**
1: 	  Close our index ScanController.
1: 	  */
1: 	private void closeIndexSC()
1:         throws StandardException
1: 	{
1: 		/* Only consider closing index SC if we own it. */
1: 		if (ownIndexSC && indexSC != null)
1: 		{
1: 			indexSC.close();
1: 			indexSC = null;
1: 		}
1: 	}
1: 
1: 	/**
1: 	  Delete a row from our index. This assumes our index ScanController
1: 	  is positioned before the row by setScan if we own the SC, otherwise
1: 	  it is positioned on the row by the underlying index scan.
1: 	  
1: 	  <P>This verifies the row exists and is unique.
1: 	  
1: 	  @exception StandardException		Thrown on error
1: 	  */
1: 	private void doDelete()
1: 		 throws StandardException
1: 	{
1: 		if (ownIndexSC)
1: 		{
1: 			if (! indexSC.next())
1: 			{
1:                 // This means that the entry for the index does not exist, this
1:                 // is a serious problem with the index.  Past fixed problems
1:                 // like track 3703 can leave db's in the field with this problem
1:                 // even though the bug in the code which caused it has long 
1:                 // since been fixed.  Then the problem can surface months later
1:                 // when the customer attempts to upgrade.  By "ignoring" the
1:                 // missing row here the problem is automatically "fixed" and
1:                 // since the code is trying to delete the row anyway it doesn't
1:                 // seem like such a bad idea.  It also then gives a tool to 
1:                 // support to be able to fix some system catalog problems where
1:                 // they can delete the base rows by dropping the system objects
1:                 // like stored statements.
1: 
1: 				if (SanityManager.DEBUG)
1: 					SanityManager.THROWASSERT(
1:                         "Index row "+RowUtil.toString(ourIndexRow)+
1:                         " not found in conglomerateid " + indexCID +
1:                         "Current scan = " + indexSC);
1: 
1:                 Object[] args = new Object[2];
1:                 args[0] = ourIndexRow.getRowArray()[ourIndexRow.getRowArray().length - 1];
0:                 args[1] = new Long(indexCID);
1: 
0:                 Monitor.getStream().println(MessageService.getCompleteMessage(
1:                     SQLState.LANG_IGNORE_MISSING_INDEX_ROW_DURING_DELETE, 
1:                     args));
1: 
1:                 // just return indicating the row has been deleted.
1:                 return;
1: 			}
1: 		}
1: 
1:         indexSC.delete();
1: 	}
1: 
1: 	/**
1: 	  Insert a row into our indes.
1: 	  
1: 	  <P>This opens our index ConglomeratController the first time it
1: 	  is called. 
1: 	  
1: 	  @exception StandardException		Thrown on error
1: 	  */
1: 	private void doInsert()
1: 		 throws StandardException
1: 	{
1: 		insertAndCheckDups(ourIndexRow);
1: 	}
1: 
1: 	/**
1: 	  Insert a row into the temporary conglomerate
1: 	  
1: 	  <P>This opens our deferred ConglomeratController the first time it
1: 	  is called.
1: 	  
1: 	  @exception StandardException		Thrown on error
1: 	  */
1: 	private void doDeferredInsert()
1: 		 throws StandardException
1: 	{
1: 		if (rowHolder == null)
1: 		{
1: 			Properties properties = new Properties();
1: 
1: 			// Get the properties on the index
1: 			openIndexCC().getInternalTablePropertySet(properties);
1: 
1: 			/*
1: 			** Create our row holder.  it is ok to skip passing
1: 			** in the result description because if we don't already
1: 			** have a row holder, then we are the only user of the
1: 			** row holder (the description is needed when the row
1: 			** holder is going to be handed to users for triggers).
1: 			*/
0: 			rowHolder = new TemporaryRowHolderImpl(tc, properties, (ResultDescription)null);
1: 		}
1: 
1: 		/*
1: 		** If the user of the IndexChanger already
1: 		** had a row holder, then we don't need to
1: 		** bother saving deferred inserts -- they
1: 		** have already done so.	
1: 		*/
1: 		if (!rowHolderPassedIn)
1: 		{
1: 			rowHolder.insert(ourIndexRow);
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Insert the given row into the given conglomerate and check for duplicate
1: 	 * key error.
1: 	 *
1: 	 * @param row	The row to insert
1: 	 *
1: 	 * @exception StandardException		Thrown on duplicate key error
1: 	 */
1: 	private void insertAndCheckDups(ExecIndexRow row)
1: 				throws StandardException
1: 	{
1: 		openIndexCC();
1: 
0: 		int insertStatus = indexCC.insert(row.getRowArray());
1: 
0: 		if (insertStatus == ConglomerateController.ROWISDUPLICATE)
1: 		{
1: 			/*
1: 			** We have a duplicate key error. 
1: 			*/
1: 			String indexOrConstraintName = indexName;
1: 			// now get table name, and constraint name if needed
1: 			LanguageConnectionContext lcc =
1:                 			activation.getLanguageConnectionContext();
1: 			DataDictionary dd = lcc.getDataDictionary();
1: 			//get the descriptors
1: 			ConglomerateDescriptor cd = dd.getConglomerateDescriptor(indexCID);
1: 
1: 			UUID tableID = cd.getTableID();
1: 			TableDescriptor td = dd.getTableDescriptor(tableID);
1: 			String tableName = td.getName();
1: 			
1: 			if (indexOrConstraintName == null) // no index name passed in
1: 			{
1: 				ConstraintDescriptor conDesc = dd.getConstraintDescriptor(td,
1:                                                                       cd.getUUID());
1: 				indexOrConstraintName = conDesc.getConstraintName();
1: 			}		
1: 
1: 			StandardException se = 
1: 				StandardException.newException(
1: 				SQLState.LANG_DUPLICATE_KEY_CONSTRAINT, indexOrConstraintName, tableName);
1: 			throw se;
1: 		}
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			if (insertStatus != 0)
1: 			{
0: 				SanityManager.THROWASSERT("Unknown insert status " + insertStatus);
1: 			}
1: 		}
1: 	}
1: 
1: 
1: 	/**
1: 	 * Open the ConglomerateController for this index if it isn't open yet.
1: 	 *
1: 	 * @return The ConglomerateController for this index.
1: 	 *
1: 	 * @exception StandardException		Thrown on duplicate key error
1: 	 */
1: 	private ConglomerateController openIndexCC()
1: 		throws StandardException
1: 	{
1: 		if (indexCC == null)
1: 		{
1: 			/* DataDictionary doesn't have compiled info */
1: 			if (indexSCOCI == null)
1: 			{
1: 				indexCC = 
1: 		            tc.openConglomerate(
0: 						indexCID,
1:                         false,
1: 			            (TransactionController.OPENMODE_FORUPDATE |
1: 				         TransactionController.OPENMODE_BASEROW_INSERT_LOCKED),
1: 					    lockMode,
1:                         isolationLevel);
1: 			}
1: 			else
1: 			{
1: 				indexCC = 
1: 		            tc.openCompiledConglomerate(
1:                         false,
1: 			            (TransactionController.OPENMODE_FORUPDATE |
1: 				         TransactionController.OPENMODE_BASEROW_INSERT_LOCKED),
1: 					    lockMode,
1:                         isolationLevel,
1: 						indexSCOCI,
1: 						indexDCOCI);
1: 			}
1: 		}
1: 
1: 		return indexCC;
1: 	}
1: 
1: 	/**
1: 	  Open this IndexChanger.
1: 
1: 	  @exception StandardException		Thrown on error
1: 	  */
0: 	public void open()
1: 		 throws StandardException
1: 	{
1: 	}
1: 
1: 	/**
1: 	  Perform index maintenance to support a delete of a base table row.
1: 
1: 	  @param baseRow the base table row.
1: 	  @param baseRowLocation the base table row's location.
1: 	  @exception StandardException		Thrown on error
1: 	  */
0: 	public void delete(ExecRow baseRow,
0: 					   RowLocation baseRowLocation)
1: 		 throws StandardException
1: 	{
1: 		setOurIndexRow(baseRow, baseRowLocation);
1: 		setScan();
1: 		doDelete();
1: 	}
1: 
1: 	/**
1: 	  Perform index maintenance to support an update of a base table row.
1: 
0: 	  @param ef	                ExecutionFactory to use in case of cloning
1: 	  @param oldBaseRow         the old image of the base table row.
1: 	  @param newBaseRow         the new image of the base table row.
1: 	  @param baseRowLocation    the base table row's location.
1: 
1: 	  @exception StandardException		Thrown on error
1: 	  */
0: 	public void update(ExecRow oldBaseRow,
1: 					   ExecRow newBaseRow,
1: 					   RowLocation baseRowLocation
1: 					   )
1: 		 throws StandardException
1: 	{
1: 		setOurIndexRow(oldBaseRow, baseRowLocation);
1: 		setOurUpdatedIndexRow(newBaseRow, baseRowLocation);
1: 
1: 		/* We skip the update in the degenerate case
1: 		 * where none of the key columns changed.
1: 		 * (From an actual customer case.)
1: 		 */
1: 		if (indexRowChanged())
1: 		{
1: 			setScan();
1: 			doDelete();
1: 			insertForUpdate(newBaseRow, baseRowLocation);
1: 		}
1: 	}
1: 
1: 	/**
1: 	  Perform index maintenance to support an insert of a base table row.
1: 
0: 	  @param baseRow            the base table row.
1: 	  @param baseRowLocation    the base table row's location.
1: 
1: 	  @exception StandardException		Thrown on error
1: 	  */
0: 	public void insert(ExecRow newRow, RowLocation baseRowLocation)
1: 		 throws StandardException
1: 	{
1: 		setOurIndexRow(newRow, baseRowLocation);
1: 		doInsert();
1: 	}
1: 
1: 	/**
1: 	  If we're updating a unique index, the inserts have to be
1: 	  deferred.  This is to avoid uniqueness violations that are only
1: 	  temporary.  If we do all the deletes first, only "true" uniqueness
1: 	  violations can happen.  We do this here, rather than in open(),
1: 	  because this is the only operation that requires deferred inserts,
1: 	  and we only want to create the conglomerate if necessary.
1: 
0: 	  @param ef		            ExecutionFactory to use in case of cloning
0: 	  @param baseRow            the base table row.
1: 	  @param baseRowLocation    the base table row's location.
1: 
1: 	  @exception StandardException		Thrown on error
1: 	*/
1: 	void insertForUpdate(ExecRow newRow, RowLocation baseRowLocation)
1: 		 throws StandardException
1: 	{
1: 		setOurIndexRow(newRow, baseRowLocation);
1: 
0: 		if (irg.isUnique())
1: 		{
1: 			doDeferredInsert();
1: 		}
1: 		else
1: 		{
1: 			doInsert();
1: 		}
1: 	}
1: 
1: 	/**
1: 	  Finish doing the changes for this index.  This is intended for deferred
1: 	  inserts for unique indexes.  It has no effect unless we are doing an
1: 	  update of a unique index.
1: 
1: 	  @exception StandardException		Thrown on error
1: 	 */
0: 	public void finish()
1: 		throws StandardException
1: 	{
1: 		ExecRow			deferredRow;
0: 		ExecIndexRow	deferredIndexRow = new IndexRow();
1: 
1: 		/* Deferred processing only necessary for unique indexes */
1: 		if (rowHolder != null)
1: 		{
1: 			CursorResultSet rs = rowHolder.getResultSet();
1: 			try
1: 			{
1: 				rs.open();
1: 				while ((deferredRow = rs.getNextRow()) != null)
1: 				{
1: 					if (SanityManager.DEBUG)
1: 					{
1: 						if (!(deferredRow instanceof ExecIndexRow))
1: 						{
1: 							SanityManager.THROWASSERT("deferredRow isn't an instance "+
1: 								"of ExecIndexRow as expected. "+
1: 								"It is an "+deferredRow.getClass().getName());
1: 						}
1: 					}
1: 					insertAndCheckDups((ExecIndexRow)deferredRow);
1: 				}
1: 			}
1: 			finally
1: 			{
1: 				rs.close();
1: 
1: 				/*
1: 				** If row holder was passed in, let the
1: 				** client of this method clean it up.
1: 				*/
1: 				if (!rowHolderPassedIn)
1: 				{
1: 					rowHolder.close();
1: 				}
1: 			}
1: 		}
1: 	}
1: 
1: 	/**
1: 	  Close this IndexChanger.
1: 
1: 	  @exception StandardException		Thrown on error
1: 	  */
0: 	public void close()
1: 		throws StandardException
1: 	{
1: 		closeIndexCC();
1: 		closeIndexSC();
1: 		if (rowHolder != null && !rowHolderPassedIn)
1: 		{
1: 			rowHolder.close();
1: 		}
1: 		baseCC = null;
1: 	}
1: }
author:David Van Couvering
-------------------------------------------------------------------------------
commit:f6123ee
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	  @param newRow            the base table row.
/////////////////////////////////////////////////////////////////////////
1: 	  @param newRow            the base table row.
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.execute
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.sql.execute;
0: 
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: import org.apache.derby.iapi.sql.dictionary.IndexRowGenerator;
0: import org.apache.derby.iapi.sql.ResultDescription;
0: import org.apache.derby.iapi.sql.execute.CursorResultSet;
0: import org.apache.derby.iapi.sql.execute.ExecRow;
0: import org.apache.derby.iapi.sql.execute.ExecIndexRow;
0: import org.apache.derby.iapi.sql.execute.ExecutionContext;
0: import org.apache.derby.iapi.sql.execute.ExecutionFactory;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.iapi.sql.Activation;
0: 
0: import org.apache.derby.iapi.store.access.ConglomerateController;
0: import org.apache.derby.iapi.store.access.DynamicCompiledOpenConglomInfo;
0: import org.apache.derby.iapi.store.access.ScanController;
0: import org.apache.derby.iapi.store.access.StaticCompiledOpenConglomInfo;
0: import org.apache.derby.iapi.store.access.TransactionController;
0: 
0: import org.apache.derby.catalog.UUID;
0: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.ConstraintDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptorList;
0: 
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.types.RowLocation;
0: 
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: import org.apache.derby.iapi.services.i18n.MessageService;
0: import java.util.Properties;
0: 
0: /**
0:   Perform Index maintenace associated with DML operations for a single index.
0:   */
0: public class IndexChanger
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	private IndexRowGenerator irg;
0: 	//Index Conglomerate ID
0: 	private long indexCID;
0: 	private DynamicCompiledOpenConglomInfo indexDCOCI;
0: 	private StaticCompiledOpenConglomInfo indexSCOCI;
0: 	private String indexName;
0: 	private ConglomerateController baseCC;
0: 	private TransactionController tc;
0: 	private int lockMode;
0: 	private FormatableBitSet baseRowReadMap;
0: 
0: 	private ConglomerateController indexCC = null;
0: 	private ScanController indexSC = null;
0: 
0: 	private LanguageConnectionContext lcc;
0: 
0: 	//
0: 	//Index rows used by this module to perform DML.
0: 	private ExecIndexRow ourIndexRow = null;
0: 	private ExecIndexRow ourUpdatedIndexRow = null;
0: 
0: 	private TemporaryRowHolderImpl	rowHolder = null;
0: 	private boolean					rowHolderPassedIn;
0: 	private int						isolationLevel;
0: 	private Activation				activation;
0: 	private boolean					ownIndexSC = true;
0: 
0: 	/**
0: 	  Create an IndexChanger
0: 
0: 	  @param irg the IndexRowGenerator for the index.
0: 	  @param indexCID the conglomerate id for the index.
0: 	  @param indexSCOCI the SCOCI for the idexes. 
0: 	  @param indexDCOCI the DCOCI for the idexes. 
0: 	  @param baseCC the ConglomerateController for the base table.
0: 	  @param tc			The TransactionController
0: 	  @param lockMode	The lock mode (granularity) to use
0: 	  @param baseRowReadMap Map of columns read in.  1 based.
0: 	  @param isolationLevel	Isolation level to use.
0: 	  @param activation	Current activation
0: 
0: 	  @exception StandardException		Thrown on error
0: 	  */
0: 	public IndexChanger
0: 	(
0: 		IndexRowGenerator 		irg,
0: 		long 					indexCID,
0: 	    StaticCompiledOpenConglomInfo indexSCOCI,
0: 		DynamicCompiledOpenConglomInfo indexDCOCI,
0: 		String					indexName,
0: 		ConglomerateController	baseCC,
0: 		TransactionController 	tc,
0: 		int 					lockMode,
0: 		FormatableBitSet					baseRowReadMap,
0: 		int						isolationLevel,
0: 		Activation				activation
0: 	)
0: 		 throws StandardException
0: 	{
0: 		this.irg = irg;
0: 		this.indexCID = indexCID;
0: 		this.indexSCOCI = indexSCOCI;
0: 		this.indexDCOCI = indexDCOCI;
0: 		this.baseCC = baseCC;
0: 		this.tc = tc;
0: 		this.lockMode = lockMode;
0: 		this.baseRowReadMap = baseRowReadMap;
0: 		this.rowHolderPassedIn = false;
0: 		this.isolationLevel = isolationLevel;
0: 		this.activation = activation;
0: 		this.indexName = indexName;
0: 
0: 		// activation will be null when called from DataDictionary
0: 		if (activation != null && activation.getIndexConglomerateNumber() == indexCID)
0: 		{
0: 			ownIndexSC = false;
0: 		}
0: 	
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(tc != null, 
0: 				"TransactionController argument to constructor is null");
0: 			SanityManager.ASSERT(irg != null, 
0: 				"IndexRowGenerator argument to constructor is null");
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Set the row holder for this changer to use.
0: 	 * If the row holder is set, it wont bother 
0: 	 * saving copies of rows needed for deferred
0: 	 * processing.  Also, it will never close the
0: 	 * passed in rowHolder.
0: 	 *
0: 	 * @param rowHolder	the row holder
0: 	 */
0: 	public void setRowHolder(TemporaryRowHolderImpl rowHolder)
0: 	{
0: 		this.rowHolder = rowHolder;
0: 		rowHolderPassedIn = (rowHolder != null);
0: 	}
0: 
0: 	/**
0: 	 * Propagate the heap's ConglomerateController to
0: 	 * this index changer.
0: 	 *
0: 	 * @param baseCC	The heap's ConglomerateController.
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	public void setBaseCC(ConglomerateController baseCC)
0: 	{
0: 		this.baseCC = baseCC;
0: 	}
0: 
0: 	/**
0: 	  Set the column values for 'ourIndexRow' to refer to 
0: 	  a base table row and location provided by the caller.
0: 	  The idea here is to 
0: 	  @param baseRow a base table row.
0: 	  @param baseRowLoc baseRowLoc baseRow's location
0: 	  @exception StandardException		Thrown on error
0: 	  */
0: 	private void setOurIndexRow(ExecRow baseRow,
0: 								RowLocation baseRowLoc)
0: 		 throws StandardException
0: 	{
0: 			if (ourIndexRow == null)
0: 				ourIndexRow = irg.getIndexRowTemplate();
0: 		
0: 			irg.getIndexRow(baseRow, baseRowLoc, ourIndexRow, baseRowReadMap);
0: 	}
0: 
0: 	/**
0: 	  Set the column values for 'ourUpdatedIndexRow' to refer to 
0: 	  a base table row and location provided by the caller.
0: 	  The idea here is to 
0: 	  @param baseRow a base table row.
0: 	  @param baseRowLoc baseRowLoc baseRow's location
0: 	  @exception StandardException		Thrown on error
0: 	  */
0: 	private void setOurUpdatedIndexRow(ExecRow baseRow,
0: 								RowLocation baseRowLoc)
0: 		 throws StandardException
0: 	{
0: 			if (ourUpdatedIndexRow == null)
0: 				ourUpdatedIndexRow = irg.getIndexRowTemplate();
0: 		
0: 			irg.getIndexRow(baseRow, baseRowLoc, ourUpdatedIndexRow, baseRowReadMap);
0: 	}
0: 
0: 	/**
0: 	 * Determine whether or not any columns in the current index
0: 	 * row are being changed by the update.  No need to update the
0: 	 * index if no columns changed.
0: 	 *
0: 	 * @return Nothing.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	private boolean indexRowChanged()
0: 		throws StandardException
0: 	{
0: 		int numColumns = ourIndexRow.nColumns();
0: 		for (int index = 1; index <= numColumns; index++)
0: 		{
0: 			DataValueDescriptor oldOrderable = ourIndexRow.getColumn(index);
0: 			DataValueDescriptor newOrderable = ourUpdatedIndexRow.getColumn(index);
0: 			if (! (oldOrderable.compare(DataValueDescriptor.ORDER_OP_EQUALS, newOrderable, true, true)))
0: 			{
0: 				return true;
0: 			}
0: 		}
0: 		return false;
0: 	}
0: 
0: 	private ExecIndexRow getDeferredIndexRowTemplate(ExecRow baseRow,
0: 													RowLocation baseRowLoc)
0: 		 throws StandardException
0: 	{
0: 		ExecIndexRow	template;
0: 
0: 		template = irg.getIndexRowTemplate();
0: 
0: 		irg.getIndexRow(baseRow, baseRowLoc, template, baseRowReadMap);
0: 
0: 		return template;
0: 	}
0: 
0: 	/**
0: 	  Position our index scan to 'ourIndexRow'.
0: 
0: 	  <P>This creates the scan the first time it is called.
0: 
0: 	  @exception StandardException		Thrown on error
0: 	  */
0: 	private void setScan()
0: 		 throws StandardException
0: 	{
0: 		/* Get the SC from the activation if re-using */
0: 		if (! ownIndexSC)
0: 		{
0: 			indexSC = activation.getIndexScanController();
0: 		}
0: 		else if (indexSC == null)
0: 		{
0: 			RowLocation templateBaseRowLocation = baseCC.newRowLocationTemplate();
0: 			/* DataDictionary doesn't have compiled info */
0: 			if (indexSCOCI == null)
0: 			{
0: 				indexSC = 
0: 		            tc.openScan(
0: 			              indexCID,
0: 				          false,                       /* hold */
0: 					      TransactionController.OPENMODE_FORUPDATE, /* forUpdate */
0: 						  lockMode,
0: 	                      isolationLevel,
0: 		                  (FormatableBitSet)null,					/* all fields */
0: 			              ourIndexRow.getRowArray(),    /* startKeyValue */
0: 				          ScanController.GE,            /* startSearchOp */
0: 					      null,                         /* qualifier */
0: 						  ourIndexRow.getRowArray(),    /* stopKeyValue */
0: 						ScanController.GT             /* stopSearchOp */
0: 	                      );
0: 			}
0: 			else
0: 			{
0: 				indexSC = 
0: 		            tc.openCompiledScan(
0: 				          false,                       /* hold */
0: 					      TransactionController.OPENMODE_FORUPDATE, /* forUpdate */
0: 						  lockMode,
0: 	                      isolationLevel,
0: 		                  (FormatableBitSet)null,					/* all fields */
0: 			              ourIndexRow.getRowArray(),    /* startKeyValue */
0: 				          ScanController.GE,            /* startSearchOp */
0: 					      null,                         /* qualifier */
0: 						  ourIndexRow.getRowArray(),    /* stopKeyValue */
0: 						  ScanController.GT,             /* stopSearchOp */
0: 						  indexSCOCI,
0: 						  indexDCOCI
0: 	                      );
0:             }
0: 		}
0: 		else
0: 		{
0: 			indexSC.reopenScan(
0: 							   ourIndexRow.getRowArray(),			/* startKeyValue */
0: 							   ScanController.GE, 	/* startSearchOperator */
0: 							   null,	            /* qualifier */
0: 							   ourIndexRow.getRowArray(),			/* stopKeyValue */
0: 							   ScanController.GT	/* stopSearchOperator */
0: 							   );
0: 		}
0: 	}
0: 
0: 	/**
0: 	  Close our index Conglomerate Controller
0: 	  */
0: 	private void closeIndexCC()
0:         throws StandardException
0: 	{
0: 		if (indexCC != null)
0: 			indexCC.close();
0: 		indexCC = null;
0: 	}
0: 
0: 	/**
0: 	  Close our index ScanController.
0: 	  */
0: 	private void closeIndexSC()
0:         throws StandardException
0: 	{
0: 		/* Only consider closing index SC if we own it. */
0: 		if (ownIndexSC && indexSC != null)
0: 		{
0: 			indexSC.close();
0: 			indexSC = null;
0: 		}
0: 	}
0: 
0: 	/**
0: 	  Delete a row from our index. This assumes our index ScanController
0: 	  is positioned before the row by setScan if we own the SC, otherwise
0: 	  it is positioned on the row by the underlying index scan.
0: 	  
0: 	  <P>This verifies the row exists and is unique.
0: 	  
0: 	  @exception StandardException		Thrown on error
0: 	  */
0: 	private void doDelete()
0: 		 throws StandardException
0: 	{
0: 		if (ownIndexSC)
0: 		{
0: 			if (! indexSC.next())
0: 			{
0:                 // This means that the entry for the index does not exist, this
0:                 // is a serious problem with the index.  Past fixed problems
0:                 // like track 3703 can leave db's in the field with this problem
0:                 // even though the bug in the code which caused it has long 
0:                 // since been fixed.  Then the problem can surface months later
0:                 // when the customer attempts to upgrade.  By "ignoring" the
0:                 // missing row here the problem is automatically "fixed" and
0:                 // since the code is trying to delete the row anyway it doesn't
0:                 // seem like such a bad idea.  It also then gives a tool to 
0:                 // support to be able to fix some system catalog problems where
0:                 // they can delete the base rows by dropping the system objects
0:                 // like stored statements.
0: 
0: 				if (SanityManager.DEBUG)
0: 					SanityManager.THROWASSERT(
0:                         "Index row "+RowUtil.toString(ourIndexRow)+
0:                         " not found in conglomerateid " + indexCID +
0:                         "Current scan = " + indexSC);
0: 
0:                 Object[] args = new Object[2];
0:                 args[0] = ourIndexRow.getRowArray()[ourIndexRow.getRowArray().length - 1];
0:                 args[1] = new Long(indexCID);
0: 
0:                 Monitor.getStream().println(MessageService.getCompleteMessage(
0:                     SQLState.LANG_IGNORE_MISSING_INDEX_ROW_DURING_DELETE, 
0:                     args));
0: 
0:                 // just return indicating the row has been deleted.
0:                 return;
0: 			}
0: 		}
0: 
0:         indexSC.delete();
0: 	}
0: 
0: 	/**
0: 	  Insert a row into our indes.
0: 	  
0: 	  <P>This opens our index ConglomeratController the first time it
0: 	  is called. 
0: 	  
0: 	  @exception StandardException		Thrown on error
0: 	  */
0: 	private void doInsert()
0: 		 throws StandardException
0: 	{
0: 		insertAndCheckDups(ourIndexRow);
0: 	}
0: 
0: 	/**
0: 	  Insert a row into the temporary conglomerate
0: 	  
0: 	  <P>This opens our deferred ConglomeratController the first time it
0: 	  is called.
0: 	  
0: 	  @exception StandardException		Thrown on error
0: 	  */
0: 	private void doDeferredInsert()
0: 		 throws StandardException
0: 	{
0: 		if (rowHolder == null)
0: 		{
0: 			Properties properties = new Properties();
0: 
0: 			// Get the properties on the index
0: 			openIndexCC().getInternalTablePropertySet(properties);
0: 
0: 			/*
0: 			** Create our row holder.  it is ok to skip passing
0: 			** in the result description because if we don't already
0: 			** have a row holder, then we are the only user of the
0: 			** row holder (the description is needed when the row
0: 			** holder is going to be handed to users for triggers).
0: 			*/
0: 			rowHolder = new TemporaryRowHolderImpl(tc, properties, (ResultDescription)null);
0: 		}
0: 
0: 		/*
0: 		** If the user of the IndexChanger already
0: 		** had a row holder, then we don't need to
0: 		** bother saving deferred inserts -- they
0: 		** have already done so.	
0: 		*/
0: 		if (!rowHolderPassedIn)
0: 		{
0: 			rowHolder.insert(ourIndexRow);
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Insert the given row into the given conglomerate and check for duplicate
0: 	 * key error.
0: 	 *
0: 	 * @param row	The row to insert
0: 	 *
0: 	 * @exception StandardException		Thrown on duplicate key error
0: 	 */
0: 	private void insertAndCheckDups(ExecIndexRow row)
0: 				throws StandardException
0: 	{
0: 		openIndexCC();
0: 
0: 		int insertStatus = indexCC.insert(row.getRowArray());
0: 
0: 		if (insertStatus == ConglomerateController.ROWISDUPLICATE)
0: 		{
0: 			/*
0: 			** We have a duplicate key error. 
0: 			*/
0: 			String indexOrConstraintName = indexName;
0: 			// now get table name, and constraint name if needed
0: 			LanguageConnectionContext lcc =
0:                 			activation.getLanguageConnectionContext();
0: 			DataDictionary dd = lcc.getDataDictionary();
0: 			//get the descriptors
0: 			ConglomerateDescriptor cd = dd.getConglomerateDescriptor(indexCID);
0: 
0: 			UUID tableID = cd.getTableID();
0: 			TableDescriptor td = dd.getTableDescriptor(tableID);
0: 			String tableName = td.getName();
0: 			
0: 			if (indexOrConstraintName == null) // no index name passed in
0: 			{
0: 				ConstraintDescriptor conDesc = dd.getConstraintDescriptor(td,
0:                                                                       cd.getUUID());
0: 				indexOrConstraintName = conDesc.getConstraintName();
0: 			}		
0: 
0: 			StandardException se = 
0: 				StandardException.newException(
0: 				SQLState.LANG_DUPLICATE_KEY_CONSTRAINT, indexOrConstraintName, tableName);
0: 			throw se;
0: 		}
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (insertStatus != 0)
0: 			{
0: 				SanityManager.THROWASSERT("Unknown insert status " + insertStatus);
0: 			}
0: 		}
0: 	}
0: 
0: 
0: 	/**
0: 	 * Open the ConglomerateController for this index if it isn't open yet.
0: 	 *
0: 	 * @return The ConglomerateController for this index.
0: 	 *
0: 	 * @exception StandardException		Thrown on duplicate key error
0: 	 */
0: 	private ConglomerateController openIndexCC()
0: 		throws StandardException
0: 	{
0: 		if (indexCC == null)
0: 		{
0: 			/* DataDictionary doesn't have compiled info */
0: 			if (indexSCOCI == null)
0: 			{
0: 				indexCC = 
0: 		            tc.openConglomerate(
0: 						indexCID,
0:                         false,
0: 			            (TransactionController.OPENMODE_FORUPDATE |
0: 				         TransactionController.OPENMODE_BASEROW_INSERT_LOCKED),
0: 					    lockMode,
0:                         isolationLevel);
0: 			}
0: 			else
0: 			{
0: 				indexCC = 
0: 		            tc.openCompiledConglomerate(
0:                         false,
0: 			            (TransactionController.OPENMODE_FORUPDATE |
0: 				         TransactionController.OPENMODE_BASEROW_INSERT_LOCKED),
0: 					    lockMode,
0:                         isolationLevel,
0: 						indexSCOCI,
0: 						indexDCOCI);
0: 			}
0: 		}
0: 
0: 		return indexCC;
0: 	}
0: 
0: 	/**
0: 	  Open this IndexChanger.
0: 
0: 	  @exception StandardException		Thrown on error
0: 	  */
0: 	public void open()
0: 		 throws StandardException
0: 	{
0: 	}
0: 
0: 	/**
0: 	  Perform index maintenance to support a delete of a base table row.
0: 
0: 	  @param baseRow the base table row.
0: 	  @param baseRowLocation the base table row's location.
0: 	  @exception StandardException		Thrown on error
0: 	  */
0: 	public void delete(ExecRow baseRow,
0: 					   RowLocation baseRowLocation)
0: 		 throws StandardException
0: 	{
0: 		setOurIndexRow(baseRow, baseRowLocation);
0: 		setScan();
0: 		doDelete();
0: 	}
0: 
0: 	/**
0: 	  Perform index maintenance to support an update of a base table row.
0: 
0: 	  @param ef	                ExecutionFactory to use in case of cloning
0: 	  @param oldBaseRow         the old image of the base table row.
0: 	  @param newBaseRow         the new image of the base table row.
0: 	  @param baseRowLocation    the base table row's location.
0: 
0: 	  @exception StandardException		Thrown on error
0: 	  */
0: 	public void update(ExecRow oldBaseRow,
0: 					   ExecRow newBaseRow,
0: 					   RowLocation baseRowLocation
0: 					   )
0: 		 throws StandardException
0: 	{
0: 		setOurIndexRow(oldBaseRow, baseRowLocation);
0: 		setOurUpdatedIndexRow(newBaseRow, baseRowLocation);
0: 
0: 		/* We skip the update in the degenerate case
0: 		 * where none of the key columns changed.
0: 		 * (From an actual customer case.)
0: 		 */
0: 		if (indexRowChanged())
0: 		{
0: 			setScan();
0: 			doDelete();
0: 			insertForUpdate(newBaseRow, baseRowLocation);
0: 		}
0: 	}
0: 
0: 	/**
0: 	  Perform index maintenance to support an insert of a base table row.
0: 
0: 	  @param baseRow            the base table row.
0: 	  @param baseRowLocation    the base table row's location.
0: 
0: 	  @exception StandardException		Thrown on error
0: 	  */
0: 	public void insert(ExecRow newRow, RowLocation baseRowLocation)
0: 		 throws StandardException
0: 	{
0: 		setOurIndexRow(newRow, baseRowLocation);
0: 		doInsert();
0: 	}
0: 
0: 	/**
0: 	  If we're updating a unique index, the inserts have to be
0: 	  deferred.  This is to avoid uniqueness violations that are only
0: 	  temporary.  If we do all the deletes first, only "true" uniqueness
0: 	  violations can happen.  We do this here, rather than in open(),
0: 	  because this is the only operation that requires deferred inserts,
0: 	  and we only want to create the conglomerate if necessary.
0: 
0: 	  @param ef		            ExecutionFactory to use in case of cloning
0: 	  @param baseRow            the base table row.
0: 	  @param baseRowLocation    the base table row's location.
0: 
0: 	  @exception StandardException		Thrown on error
0: 	*/
0: 	void insertForUpdate(ExecRow newRow, RowLocation baseRowLocation)
0: 		 throws StandardException
0: 	{
0: 		setOurIndexRow(newRow, baseRowLocation);
0: 
0: 		if (irg.isUnique())
0: 		{
0: 			doDeferredInsert();
0: 		}
0: 		else
0: 		{
0: 			doInsert();
0: 		}
0: 	}
0: 
0: 	/**
0: 	  Finish doing the changes for this index.  This is intended for deferred
0: 	  inserts for unique indexes.  It has no effect unless we are doing an
0: 	  update of a unique index.
0: 
0: 	  @exception StandardException		Thrown on error
0: 	 */
0: 	public void finish()
0: 		throws StandardException
0: 	{
0: 		ExecRow			deferredRow;
0: 		ExecIndexRow	deferredIndexRow = new IndexRow();
0: 
0: 		/* Deferred processing only necessary for unique indexes */
0: 		if (rowHolder != null)
0: 		{
0: 			CursorResultSet rs = rowHolder.getResultSet();
0: 			try
0: 			{
0: 				rs.open();
0: 				while ((deferredRow = rs.getNextRow()) != null)
0: 				{
0: 					if (SanityManager.DEBUG)
0: 					{
0: 						if (!(deferredRow instanceof ExecIndexRow))
0: 						{
0: 							SanityManager.THROWASSERT("deferredRow isn't an instance "+
0: 								"of ExecIndexRow as expected. "+
0: 								"It is an "+deferredRow.getClass().getName());
0: 						}
0: 					}
0: 					insertAndCheckDups((ExecIndexRow)deferredRow);
0: 				}
0: 			}
0: 			finally
0: 			{
0: 				rs.close();
0: 
0: 				/*
0: 				** If row holder was passed in, let the
0: 				** client of this method clean it up.
0: 				*/
0: 				if (!rowHolderPassedIn)
0: 				{
0: 					rowHolder.close();
0: 				}
0: 			}
0: 		}
0: 	}
0: 
0: 	/**
0: 	  Close this IndexChanger.
0: 
0: 	  @exception StandardException		Thrown on error
0: 	  */
0: 	public void close()
0: 		throws StandardException
0: 	{
0: 		closeIndexCC();
0: 		closeIndexSC();
0: 		if (rowHolder != null && !rowHolderPassedIn)
0: 		{
0: 			rowHolder.close();
0: 		}
0: 		baseCC = null;
0: 	}
0: }
============================================================================