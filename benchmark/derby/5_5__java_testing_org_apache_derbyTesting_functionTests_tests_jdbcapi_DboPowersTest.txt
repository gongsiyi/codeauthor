1:674c2a4: /*
10:674c2a4: 
1:674c2a4:    Derby - Class org.apache.derbyTesting.functionTests.tests.jdbcapi.DboPowersTest
1:674c2a4: 
1:674c2a4:    Licensed to the Apache Software Foundation (ASF) under one or more
1:674c2a4:    contributor license agreements.  See the NOTICE file distributed with
1:674c2a4:    this work for additional information regarding copyright ownership.
1:674c2a4:    The ASF licenses this file to you under the Apache License, Version 2.0
1:674c2a4:    (the "License"); you may not use this file except in compliance with
1:674c2a4:    the License.  You may obtain a copy of the License at
1:674c2a4: 
1:674c2a4:      http://www.apache.org/licenses/LICENSE-2.0
1:674c2a4: 
1:674c2a4:    Unless required by applicable law or agreed to in writing, software
1:674c2a4:    distributed under the License is distributed on an "AS IS" BASIS,
1:674c2a4:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:674c2a4:    See the License for the specific language governing permissions and
1:674c2a4:    limitations under the License.
1:674c2a4: 
5:674c2a4:  */
1:674c2a4: 
1:674c2a4: package org.apache.derbyTesting.functionTests.tests.jdbcapi;
1:674c2a4: 
1:1c70964: import java.sql.Connection;
1:1ae02c9: import java.sql.SQLException;
1:674c2a4: import javax.sql.DataSource;
1:674c2a4: import junit.framework.Test;
1:674c2a4: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:674c2a4: import org.apache.derbyTesting.junit.DatabasePropertyTestSetup;
1:19ea327: import org.apache.derbyTesting.junit.JDBC;
1:674c2a4: import org.apache.derbyTesting.junit.JDBCDataSource;
1:674c2a4: import org.apache.derbyTesting.junit.TestConfiguration;
1:674c2a4: 
1:674c2a4: /**
1:674c2a4:  * This JUnit tests enforcement of dbo (=database owner) powers, cf.
1:df597d1:  * DERBY-2264.
1:df597d1:  *
1:674c2a4:  * The tests are run in the cross product (cardinality 10) of contexts:
3:674c2a4:  *
1:af7f5e2:  *    {client/server, embedded} x
1:674c2a4:  *    {no authentication, authentication and authentication/sqlAuthorization} x
1:674c2a4:  *    {data base owner, other user }
1:674c2a4:  *
1:c4e95b5:  * One could consider removing the client/server suites to speed up
1:674c2a4:  * this test as it does not add much value given the nature of the changes.
1:674c2a4:  *
1:df597d1:  */
1:674c2a4: public class DboPowersTest extends BaseJDBCTestCase
2:674c2a4: {
1:af7f5e2:     /* internal state */
1:af7f5e2:     final private int _authLevel;
1:af7f5e2:     final private String _dbo;
1:af7f5e2:     final private String _dboPassword;
1:af7f5e2: 
1:674c2a4:     /* test execution security context: one of three below */
1:674c2a4:     final private static int NOAUTHENTICATION=0;
1:674c2a4:     final private static int AUTHENTICATION=1;
1:674c2a4:     final private static int SQLAUTHORIZATION=2;
1:af7f5e2: 
1:af7f5e2:     final private static String[] secLevelNames = {
1:af7f5e2:         "noAuthentication",
1:af7f5e2:         "authentication",
1:af7f5e2:         "authentication + sqlAuthorization"};
1:af7f5e2: 
1:d203eea:     final private static boolean ENCRYPT = true;
1:d203eea:     final private static boolean DECRYPT = false;
1:d203eea: 
1:674c2a4:     /**
1:af7f5e2:      * Create a new instance of DboPowersTest (for shutdown test)
1:af7f5e2:      *
1:674c2a4:      * @param name Fixture name
1:674c2a4:      * @param authLevel authentication level with which test is run
1:674c2a4:      */
1:af7f5e2:     public DboPowersTest(String name, int authLevel)
1:af7f5e2:     {
1:af7f5e2:         super(name);
1:af7f5e2:         this._authLevel = authLevel;
1:af7f5e2:         this._dbo = null;
1:af7f5e2:         this._dboPassword = null;
1:c4e95b5:     }
1:c4e95b5: 
1:c4e95b5:     /**
1:d203eea:      * Creates a new instance of DboPowersTest for cryptographic operations
1:d203eea:      * and hard upgrade tests.
1:d203eea:      * <p>
1:d203eea:      * The database owner credentials is needed to always be able to perform
1:d203eea:      * the restricted operations (when they are not under test, but used as
1:d203eea:      * part of a test fixture for another operation).
1:c4e95b5:      *
1:af7f5e2:      * @param name Fixture name
1:af7f5e2:      * @param authLevel authentication level with which test is run
1:af7f5e2:      * @param dbo Database owner
1:af7f5e2:      * @param dboPassword Database owner's password
1:af7f5e2:      */
1:af7f5e2: 
1:af7f5e2:     public DboPowersTest(String name, int authLevel,
1:af7f5e2:                          String dbo, String dboPassword)
1:af7f5e2:     {
1:af7f5e2:         super(name);
1:af7f5e2:         this._authLevel = authLevel;
1:af7f5e2:         this._dbo = dbo;
1:af7f5e2:         this._dboPassword = dboPassword;
1:af7f5e2:     }
1:af7f5e2: 
1:af7f5e2: 
1:af7f5e2:     /**
1:df597d1:      * Construct top level suite in this JUnit test
1:c4e95b5:      *
1:674c2a4:      * @return A suite containing embedded and client suites
1:674c2a4:      */
1:674c2a4:     public static Test suite()
1:674c2a4:     {
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite("DboPowersTest");
1:af7f5e2: 
1:19ea327:         /* Database shutdown powers */
1:19ea327: 
1:af7f5e2:         suite.addTest(dboShutdownSuite("suite: shutdown powers, embedded"));
1:af7f5e2:         suite.addTest(
2:af7f5e2:             TestConfiguration.clientServerDecorator(
1:af7f5e2:                 dboShutdownSuite("suite: shutdown powers, client")));
1:af7f5e2: 
1:d203eea:         // Database (re)encryption powers and decryption powers.
1:d203eea:         // The cryptographic power tests are not run for JSR169, since Derby
1:d203eea:         // does not support database encryption for that platform, cf.
1:d203eea:         // the specification for JSR169 support in DERBY-97.
1:19ea327:         if (!JDBC.vmSupportsJSR169()) {
1:19ea327:             suite.addTest(
1:d203eea:                 dboCryptoSuite("suite: cryptographic powers, embedded"));
1:19ea327:             suite.addTest(
1:19ea327:                 TestConfiguration.clientServerDecorator(
1:d203eea:                     dboCryptoSuite("suite: cryptographic powers, client")));
1:19ea327:         }
1:af7f5e2: 
1:c4e95b5:         /* Database hard upgrade powers */
1:c4e95b5: 
1:c4e95b5:         suite.addTest(
1:c4e95b5:             dboHardUpgradeSuite("suite: hard upgrade powers, embedded"));
1:c4e95b5:         suite.addTest(
1:c4e95b5:             TestConfiguration.clientServerDecorator(
1:c4e95b5:                 dboHardUpgradeSuite("suite: hard upgrade powers, client")));
1:c4e95b5: 
2:674c2a4:         return suite;
1:df597d1:     }
1:af7f5e2: 
1:af7f5e2:     /**
1:d203eea:      * Users used by both dboShutdownSuite and dboCryptoSuite
1:19ea327:      */
1:af7f5e2:     final static String[][] users = {
1:af7f5e2:         /* authLevel == AUTHENTICATION: dbo is APP/APP for db 'wombat',
1:ca5edbb:          * so use that as first user.
1:af7f5e2:          */
1:af7f5e2:         {"APP", "U1"},
1:af7f5e2:         /* authLevel == SQLAUTHORIZATION: sqlAuthorizationDecorator
1:af7f5e2:          * decorator presumes TEST_DBO as dbo, so add it to set of
1:af7f5e2:          * valid users. Uses a fresh db 'dbsqlauth', not 'wombat'.
1:af7f5e2:          */
1:af7f5e2:         {"TEST_DBO", "U1"}};
1:af7f5e2: 
1:af7f5e2:     final static String pwSuffix = "pwSuffix";
1:af7f5e2: 
1:af7f5e2: 
1:af7f5e2:     /**
1:19ea327:      *
1:af7f5e2:      * Construct suite of tests for shutdown database action
1:df597d1:      *
1:af7f5e2:      * @param framework Derby framework name
1:af7f5e2:      * @return A suite containing the test case for shutdown
1:af7f5e2:      * incarnated for the three security levels no authentication,
1:af7f5e2:      * authentication, and authentication plus sqlAuthorization, The
1:c4e95b5:      * latter two has an instance for dbo, and one for an ordinary user,
1:af7f5e2:      * so there are in all five incarnations of tests.
1:af7f5e2:      */
1:af7f5e2:     private static Test dboShutdownSuite(String framework)
1:674c2a4:     {
1:df597d1:         Test tests[] = new Test[SQLAUTHORIZATION+1]; // one per authLevel
1:674c2a4: 
1:af7f5e2:         /* Tests without any authorization active (level ==
1:af7f5e2:          * NOAUTHENTICATION).
1:af7f5e2:          */
1:1ae02c9:         BaseTestSuite noauthSuite =
1:1ae02c9:             new BaseTestSuite("suite: security level=" +
1:af7f5e2:                           secLevelNames[NOAUTHENTICATION]);
1:af7f5e2:         noauthSuite.addTest(new DboPowersTest("testShutDown",
1:c4e95b5:                                               NOAUTHENTICATION));
1:af7f5e2:         tests[NOAUTHENTICATION] = noauthSuite;
1:af7f5e2: 
1:df597d1:         /* First decorate with users, then with authentication. Do this
1:674c2a4:          * twice, once for authentication only, and once for
1:af7f5e2:          * authentication + sqlAuthorization (see extra decorator
1:674c2a4:          * added below).
1:c4e95b5:          */
1:af7f5e2:         for (int autLev = AUTHENTICATION;
1:674c2a4:              autLev <= SQLAUTHORIZATION ; autLev++) {
1:c4e95b5: 
1:af7f5e2:             tests[autLev] = wrapShutdownUserTests(autLev);
5:674c2a4:         }
1:674c2a4: 
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite("dboPowers:"+framework);
1:674c2a4: 
1:674c2a4:         /* run tests with no authentication enabled */
1:c4e95b5:         suite.addTest(tests[NOAUTHENTICATION]);
1:674c2a4: 
1:674c2a4:         /* run test for all users with only authentication enabled */
1:c4e95b5:         suite.addTest(tests[AUTHENTICATION]);
1:674c2a4: 
1:df597d1:         /* run test for all users with authentication and
1:674c2a4:          * sqlAuthorization enabled
1:674c2a4:          */
1:af7f5e2:         suite.addTest(
1:674c2a4:             TestConfiguration.
1:674c2a4:             sqlAuthorizationDecorator(tests[SQLAUTHORIZATION]));
1:af7f5e2: 
1:674c2a4:         return suite;
1:674c2a4:     }
1:af7f5e2: 
1:674c2a4: 
1:674c2a4:     /**
1:af7f5e2:      * Wraps the shutdown fixture in decorators to run with data
1:c4e95b5:      * base owner and one other valid user.
1:674c2a4:      *
1:af7f5e2:      * @param autLev security context to use
1:674c2a4:      */
1:af7f5e2: 
1:af7f5e2:     private static Test wrapShutdownUserTests(int autLev)
1:674c2a4:     {
1:af7f5e2:         // add decorator for different users authenticated
1:1ae02c9:         BaseTestSuite usersSuite =
1:1ae02c9:             new BaseTestSuite("usersSuite: security level=" +
1:af7f5e2:                           secLevelNames[autLev]);
1:af7f5e2: 
1:af7f5e2:         // First decorate with users, then with
1:af7f5e2:         for (int userNo = 0; userNo < users.length; userNo++) {
1:af7f5e2:             usersSuite.addTest
1:af7f5e2:                 (TestConfiguration.changeUserDecorator
1:af7f5e2:                  (new DboPowersTest("testShutDown", autLev),
1:af7f5e2:                   users[autLev-1][userNo],
1:af7f5e2:                   users[autLev-1][userNo].concat(pwSuffix)));
1:af7f5e2:         }
1:af7f5e2: 
1:af7f5e2:         return DatabasePropertyTestSetup.
1:af7f5e2:             builtinAuthentication(usersSuite, users[autLev-1], pwSuffix);
1:674c2a4:     }
1:af7f5e2: 
1:af7f5e2: 
1:674c2a4:     /**
1:df597d1:      * Test database shutdown power enforcement
1:df597d1:      *
1:df597d1:      * @throws SQLException
1:674c2a4:      */
1:674c2a4:     public void testShutDown() throws SQLException
1:674c2a4:     {
1:af7f5e2:         println("testShutDown: auth=" + this._authLevel +
1:af7f5e2:                 " user="+getTestConfiguration().getUserName());
1:af7f5e2: 
1:674c2a4:         // make sure db is booted
1:674c2a4:         getConnection().close();
1:674c2a4: 
1:674c2a4:         String user = getTestConfiguration().getUserName();
1:674c2a4:         String password = getTestConfiguration().getUserPassword();
1:674c2a4: 
1:674c2a4:         DataSource ds = JDBCDataSource.getDataSource();
1:af7f5e2:         JDBCDataSource.setBeanProperty(
1:674c2a4:             ds, "connectionAttributes", "shutdown=true");
1:674c2a4:         JDBCDataSource.setBeanProperty(ds, "user", user);
1:674c2a4:         JDBCDataSource.setBeanProperty(ds, "password", password);
1:674c2a4:         try {
1:af7f5e2:             ds.getConnection();
1:674c2a4:             fail("shutdown failed: no exception");
1:674c2a4:         } catch (SQLException e) {
1:674c2a4:             if ("08006".equals(e.getSQLState())) {
1:674c2a4:                 // reboot if shutdown succeeded
1:674c2a4:                 JDBCDataSource.setBeanProperty(ds, "connectionAttributes", "");
1:df597d1:                 ds.getConnection().close();
1:674c2a4:             }
1:9cf3fb5: 
1:674c2a4:             vetShutdownException(user, e);
1:674c2a4:         }
1:674c2a4:     }
1:674c2a4: 
1:674c2a4:     /**
1:674c2a4:      * Decide if the result of trying to shut down the database is
1:af7f5e2:      * compliant with the semantics introduced by DERBY-2264.
1:df597d1:      *
1:674c2a4:      */
1:df597d1:     private void vetShutdownException (String user, SQLException e)
1:674c2a4:     {
1:af7f5e2:         switch (_authLevel) {
1:674c2a4:         case NOAUTHENTICATION:
1:af7f5e2:             assertSQLState("database shutdown, no authentication",
2:674c2a4:                            "08006", e);
1:674c2a4:             break;
1:674c2a4:         case AUTHENTICATION:
1:ca5edbb:             /* We don't enforce dbo powers if only connection level
1:ca5edbb:              * authentication is used, for now. This leniency was
1:ca5edbb:              * introduced late in 10.3 release cycle for compatibility
1:ca5edbb:              * reasons.
1:ca5edbb:              */
1:ca5edbb:             assertSQLState("database shutdown, authentication",
1:ca5edbb:                            "08006", e);
1:674c2a4:             break;
1:674c2a4:         case SQLAUTHORIZATION:
1:674c2a4:             if ("TEST_DBO".equals(user)) {
1:674c2a4:                 assertSQLState("database shutdown, SQL authorization, db owner",
1:674c2a4:                                "08006", e);
1:af7f5e2:             } else {
1:af7f5e2:                 assertSQLState("database shutdown restriction, " +
1:af7f5e2:                                "SQL authorization, not db owner",
1:8f3b0b9:                                "08004", e);
1:674c2a4:             }
1:674c2a4:             break;
1:674c2a4:         default:
1:af7f5e2:             fail("test error: invalid authLevel: " + _authLevel);
1:af7f5e2:             break;
1:af7f5e2:         }
1:af7f5e2:     }
1:1c70964: 
1:1c70964:     /**
1:af7f5e2:      *
1:d203eea:      * Constructs suite of tests for cryptographic actions, that is database
1:d203eea:      * encryption, re-encryption, and decryption.
1:af7f5e2:      *
1:af7f5e2:      * @param framework Derby framework name
1:d203eea:      * @return A suite containing the test cases for cryptographic operations
1:af7f5e2:      * incarnated for the three security levels no authentication,
1:af7f5e2:      * authentication, and authentication plus sqlAuthorization, The
1:c4e95b5:      * latter two has an instance for dbo, and one for an ordinary user,
1:af7f5e2:      * so there are in all five incarnations of tests.
1:af7f5e2:      */
1:d203eea:     private static Test dboCryptoSuite(String framework)
1:af7f5e2:     {
1:af7f5e2:         Test tests[] = new Test[SQLAUTHORIZATION+1]; // one per authLevel
1:1c70964: 
1:af7f5e2:         /* Tests without any authorization active (level ==
1:af7f5e2:          * NOAUTHENTICATION).  Note use of no shutdown decorator
1:af7f5e2:          * variants: Necessary since framework doesn't know
1:af7f5e2:          * bootPassword.
1:af7f5e2:          */
1:1ae02c9:         BaseTestSuite noauthSuite =
1:1ae02c9:             new BaseTestSuite("suite: security level=" +
1:af7f5e2:                           secLevelNames[NOAUTHENTICATION]);
1:af7f5e2: 
1:d203eea:         for (int tNo = 0; tNo < cryptoTests.length; tNo++) {
1:af7f5e2:             noauthSuite.addTest(
1:af7f5e2:                 TestConfiguration.singleUseDatabaseDecoratorNoShutdown(
1:d203eea:                     new DboPowersTest(cryptoTests[tNo], NOAUTHENTICATION,
1:af7f5e2:                                       "foo", "bar")));
1:af7f5e2:         }
1:af7f5e2: 
1:af7f5e2:         tests[NOAUTHENTICATION] = noauthSuite;
1:af7f5e2: 
1:af7f5e2:         /* Tests with authentication and sql authorization
1:af7f5e2:          */
1:af7f5e2:         for (int autLev = AUTHENTICATION;
1:af7f5e2:              autLev <= SQLAUTHORIZATION ; autLev++) {
1:af7f5e2: 
1:d203eea:             tests[autLev] = wrapCryptoUserTests(autLev);
1:af7f5e2:         }
1:af7f5e2: 
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite("dboPowers:"+framework);
1:af7f5e2: 
1:af7f5e2:         /* run tests with no authentication enabled */
1:af7f5e2:         suite.addTest(tests[NOAUTHENTICATION]);
1:af7f5e2: 
1:af7f5e2:         /* run test for all users with only authentication enabled */
1:af7f5e2:         suite.addTest(tests[AUTHENTICATION]);
1:af7f5e2: 
1:af7f5e2:         /* run test for all users with authentication and
1:af7f5e2:          * sqlAuthorization enabled
1:af7f5e2:          */
1:af7f5e2:         suite.addTest(tests[SQLAUTHORIZATION]);
1:af7f5e2: 
1:af7f5e2:         return suite;
1:af7f5e2:     }
1:af7f5e2: 
1:af7f5e2:     /**
1:af7f5e2:      * Wraps the encryption fixtures in decorators to run with data
1:c4e95b5:      * base owner and one other valid user.
1:af7f5e2:      *
1:af7f5e2:      * @param autLev security context to use
1:af7f5e2:      */
1:af7f5e2: 
1:d203eea:     private static Test wrapCryptoUserTests(int autLev)
1:af7f5e2:     {
1:af7f5e2:         // add decorator for different users authenticated
1:1ae02c9:         BaseTestSuite usersSuite =
1:1ae02c9:             new BaseTestSuite("usersSuite: security level=" +
1:af7f5e2:                           secLevelNames[autLev]);
1:af7f5e2: 
1:af7f5e2:         // First decorate with users, then with authentication.  Note
1:af7f5e2:         // use of no teardown / no shutdown decorator variants:
1:af7f5e2:         // Necessary since framework doesnt know bootPassword
1:af7f5e2:         for (int userNo = 0; userNo < users.length; userNo++) {
1:d203eea:             for (int tNo = 0; tNo < cryptoTests.length; tNo++) {
1:af7f5e2:                 Test test = TestConfiguration.changeUserDecorator
1:d203eea:                     (new DboPowersTest(cryptoTests[tNo],
1:af7f5e2:                                        autLev,
1:af7f5e2:                                        users[autLev-1][0], // dbo
1:af7f5e2:                                        users[autLev-1][0].concat(pwSuffix)),
1:af7f5e2:                      users[autLev-1][userNo],
1:af7f5e2:                      users[autLev-1][userNo].concat(pwSuffix));
1:af7f5e2:                 test = DatabasePropertyTestSetup.builtinAuthenticationNoTeardown
1:af7f5e2:                     (test, users[autLev-1], pwSuffix);
1:af7f5e2:                 if (autLev == AUTHENTICATION) {
1:af7f5e2:                     test = TestConfiguration.
1:af7f5e2:                         singleUseDatabaseDecoratorNoShutdown(test);
1:af7f5e2:                 } else {
1:af7f5e2:                     test = TestConfiguration.
1:af7f5e2:                         sqlAuthorizationDecoratorSingleUse(test);
1:af7f5e2:                 }
1:af7f5e2:                 usersSuite.addTest(test);
1:af7f5e2:             }
1:af7f5e2:         }
1:af7f5e2:         return usersSuite;
1:af7f5e2:     }
1:af7f5e2: 
1:af7f5e2:     /**
1:d203eea:      * Enumerates the cryptographic tests.
1:af7f5e2:      */
1:d203eea:     final static String[] cryptoTests = {
1:d203eea:         "testEncrypt", "testReEncrypt", "testDecrypt"};
1:af7f5e2: 
1:af7f5e2:     /**
1:af7f5e2:      * Test database encryption for an already created
1:af7f5e2:      * database. Note: The test needs to shut down the database for
1:af7f5e2:      * the single use decorators to work.
1:af7f5e2:      *
1:af7f5e2:      * @throws SQLException
1:af7f5e2:      */
1:af7f5e2:     public void testEncrypt() throws SQLException
1:af7f5e2:     {
1:af7f5e2:         println("testEncrypt: auth=" + this._authLevel +
1:af7f5e2:                 " user="+getTestConfiguration().getUserName());
1:af7f5e2: 
1:af7f5e2:         // make sure db is created
1:af7f5e2:         getConnection().close();
1:af7f5e2: 
1:af7f5e2:         // shut down database in preparation for encryption
1:af7f5e2:         bringDbDown();
1:af7f5e2: 
1:af7f5e2:         // make encryption attempt
1:af7f5e2:         String user = getTestConfiguration().getUserName();
1:af7f5e2:         String password = getTestConfiguration().getUserPassword();
1:af7f5e2:         String bootPassword="12345678";
1:af7f5e2:         DataSource ds = JDBCDataSource.getDataSource();
1:af7f5e2: 
1:af7f5e2:         JDBCDataSource.setBeanProperty(ds, "connectionAttributes",
1:af7f5e2:                                        "dataEncryption=true;bootPassword=" +
1:af7f5e2:                                            bootPassword);
1:af7f5e2:         JDBCDataSource.setBeanProperty(ds, "user", user);
1:af7f5e2:         JDBCDataSource.setBeanProperty(ds, "password", password);
1:af7f5e2: 
1:d203eea:         Connection con;
1:af7f5e2:         try {
1:1c70964:             con = ds.getConnection();
1:d203eea:             vetCryptoAttempt(ENCRYPT, user, null);
1:af7f5e2:         } catch (SQLException e) {
1:d203eea:             vetCryptoAttempt(ENCRYPT, user, e);
1:af7f5e2:             bringDbDown();
1:af7f5e2:             return;
1:af7f5e2:         }
1:af7f5e2: 
1:1c70964:         try {
1:1c70964:             derby3038(con);
1:1c70964:         } catch (SQLException e) {
1:1c70964:             fail("derby3038 regression: " + e);
1:1c70964:         } 
1:1c70964: 
1:af7f5e2:         // we managed to encrypt: bring db down and up again to verify
1:af7f5e2:         bringDbDown();
1:af7f5e2:         bringDbUp(bootPassword);
1:af7f5e2:         bringDbDown();
1:af7f5e2:     }
1:af7f5e2: 
1:af7f5e2: 
1:d203eea:     /**
1:af7f5e2:      * Test database re-encryption for an already encrypted
1:af7f5e2:      * database. Note: The test needs to shut down database for the
1:af7f5e2:      * single use decorators to work.
1:af7f5e2:      *
1:af7f5e2:      * @throws SQLException
1:af7f5e2:      */
1:af7f5e2:     public void testReEncrypt() throws SQLException
1:af7f5e2:     {
1:af7f5e2:         println("testReEncrypt: auth=" + this._authLevel +
1:af7f5e2:                 " user="+getTestConfiguration().getUserName());
1:af7f5e2: 
1:af7f5e2:         // make sure db is created
1:af7f5e2:         getConnection().close();
1:af7f5e2: 
1:af7f5e2:         // shut down database in preparation for encryption
1:af7f5e2:         bringDbDown();
1:af7f5e2: 
1:af7f5e2:         String bootPassword="12345678";
1:af7f5e2:         doEncrypt(bootPassword);
1:af7f5e2:         bringDbDown();
1:af7f5e2: 
1:af7f5e2:         // make re-encryption attempt
1:af7f5e2:         String user = getTestConfiguration().getUserName();
1:af7f5e2:         String password = getTestConfiguration().getUserPassword();
1:af7f5e2:         String newBootPassword="87654321";
1:af7f5e2:         DataSource ds = JDBCDataSource.getDataSource();
1:af7f5e2: 
1:af7f5e2:         JDBCDataSource.setBeanProperty(ds, "connectionAttributes",
1:af7f5e2:                                        "bootPassword=" + bootPassword +
1:af7f5e2:                                        ";newBootPassword=" + newBootPassword);
1:af7f5e2:         JDBCDataSource.setBeanProperty(ds, "user", user);
1:af7f5e2:         JDBCDataSource.setBeanProperty(ds, "password", password);
1:af7f5e2: 
1:af7f5e2:         try {
1:af7f5e2:             ds.getConnection();
1:d203eea:             vetCryptoAttempt(ENCRYPT, user, null);
1:af7f5e2:         } catch (SQLException e) {
1:d203eea:             vetCryptoAttempt(ENCRYPT, user, e);
1:af7f5e2:             bringDbDown();
1:af7f5e2:             return;
1:af7f5e2:         }
1:af7f5e2: 
1:af7f5e2:         // we managed to encrypt: bring db down and up again to verify
1:af7f5e2:         bringDbDown();
1:af7f5e2:         bringDbUp(newBootPassword);
1:af7f5e2:         bringDbDown();
1:af7f5e2:     }
1:af7f5e2: 
1:af7f5e2:     /**
1:d203eea:      * Tests that only the DBO can decrypt a database.
1:d203eea:      */
1:d203eea:     public void testDecrypt()
1:d203eea:             throws SQLException {
1:d203eea:         println("testDecrypt: auth=" + this._authLevel +
1:d203eea:                 " user=" + getTestConfiguration().getUserName());
1:d203eea: 
1:d203eea:         // make sure db is created
1:d203eea:         getConnection().close();
1:d203eea: 
1:d203eea:         // shut down database in preparation for encryption
1:d203eea:         bringDbDown();
1:d203eea:         String bootPassword = "conHippo08";
1:d203eea:         doEncrypt(bootPassword);
1:d203eea:         // shut down database in preparation for decryption
1:d203eea:         bringDbDown();
1:d203eea: 
1:d203eea:         String user = getTestConfiguration().getUserName();
1:d203eea:         String password = getTestConfiguration().getUserPassword();
1:d203eea:         DataSource ds = JDBCDataSource.getDataSource();
1:d203eea:         JDBCDataSource.setBeanProperty(ds, "connectionAttributes",
1:d203eea:                                        "bootPassword=" + bootPassword +
1:d203eea:                                        ";decryptDatabase=true");
1:d203eea:         JDBCDataSource.setBeanProperty(ds, "user", user);
1:d203eea:         JDBCDataSource.setBeanProperty(ds, "password", password);
1:d203eea: 
1:d203eea:         try {
1:d203eea:             ds.getConnection();
1:d203eea:             vetCryptoAttempt(DECRYPT, user, null);
1:d203eea:         } catch (SQLException sqle) {
1:d203eea:             vetCryptoAttempt(DECRYPT, user, sqle);
1:d203eea:             return;
1:d203eea:         } finally {
1:d203eea:             bringDbDown();
1:d203eea:         }
1:d203eea: 
1:d203eea:         // we managed to decrypt: bring db up again to verify
1:d203eea:         bringDbUp(null);
1:d203eea:         bringDbDown();
1:d203eea:     }
1:af7f5e2: 
1:af7f5e2:     /**
1:af7f5e2:      * Encrypt database, as owner (not testing encryption power here)
1:af7f5e2:      * @param bootPassword
1:af7f5e2:      * @throws SQLException
1:af7f5e2:      */
1:af7f5e2:     private void doEncrypt(String bootPassword) throws SQLException
1:af7f5e2:     {
1:af7f5e2:         DataSource ds = JDBCDataSource.getDataSource();
1:af7f5e2:         JDBCDataSource.setBeanProperty(ds, "connectionAttributes",
1:af7f5e2:                                        "dataEncryption=true;bootPassword=" +
1:af7f5e2:                                        bootPassword);
1:af7f5e2:         JDBCDataSource.setBeanProperty(ds, "user", _dbo);
1:af7f5e2:         JDBCDataSource.setBeanProperty(ds, "password", _dboPassword);
1:af7f5e2:         ds.getConnection();
1:af7f5e2:     }
1:af7f5e2: 
1:af7f5e2: 
1:af7f5e2:     /**
1:af7f5e2:      * Shut down database, as db owner (not testing that power here)
1:af7f5e2:      */
1:af7f5e2:     private void bringDbDown()
1:af7f5e2:     {
1:af7f5e2:         DataSource ds = JDBCDataSource.getDataSource();
1:af7f5e2:         JDBCDataSource.setBeanProperty(
1:af7f5e2:             ds, "connectionAttributes", "shutdown=true");
1:af7f5e2:         JDBCDataSource.setBeanProperty(ds, "user", _dbo);
1:af7f5e2:         JDBCDataSource.setBeanProperty(ds, "password", _dboPassword);
1:af7f5e2:         try {
1:af7f5e2:             ds.getConnection();
1:af7f5e2:             fail("shutdown failed: expected exception");
1:af7f5e2:         } catch (SQLException e) {
1:af7f5e2:             assertSQLState("database shutdown", "08006", e);
1:af7f5e2:         }
1:af7f5e2:     }
1:af7f5e2: 
1:af7f5e2: 
1:af7f5e2:     /**
1:d203eea:      * Boots database back up after cryptographic operation using current user,
1:d203eea:      * should succeed.
1:af7f5e2:      *
1:d203eea:      * @param bootPassword boot using this bootPassword, may be {@code null}
1:af7f5e2:      * @throws SQLException
1:af7f5e2:      */
1:af7f5e2:     private void bringDbUp(String bootPassword) throws SQLException
1:af7f5e2:     {
1:af7f5e2:         String user = getTestConfiguration().getUserName();
1:af7f5e2:         String password = getTestConfiguration().getUserPassword();
1:af7f5e2:         DataSource ds = JDBCDataSource.getDataSource();
1:d203eea:         if (bootPassword != null) {
1:d203eea:             JDBCDataSource.setBeanProperty(
1:d203eea:                 ds, "connectionAttributes", "bootPassword=" + bootPassword);
1:d203eea:         }
1:af7f5e2:         JDBCDataSource.setBeanProperty(ds, "user", user);
1:af7f5e2:         JDBCDataSource.setBeanProperty(ds, "password", password);
1:af7f5e2:         ds.getConnection().close();
1:af7f5e2:     }
1:af7f5e2: 
1:af7f5e2:     /**
1:d203eea:      * Decides if the result of trying to (re-)encrypt or decrypt the database
1:d203eea:      * is compliant with the semantics introduced by DERBY-2264.
1:af7f5e2:      *
1:d203eea:      * @param encrypt whether we are (re-)encrypting or decrypting
1:af7f5e2:      * @param user The db user under which we tried to encrypt
1:af7f5e2:      * @param e    Exception caught during attempt, if any
1:af7f5e2:      */
1:d203eea:     private void vetCryptoAttempt(boolean encrypt, String user, SQLException e)
1:af7f5e2:     {
1:d203eea:         vetAttempt(user, e, "08004", encrypt ? "(re)encryption" : "decrypt");
1:af7f5e2:     }
1:674c2a4: 
1:674c2a4:     /**
1:674c2a4:      *
1:c4e95b5:      * Construct suite of tests for hard upgrade database action
1:674c2a4:      *
1:c4e95b5:      * NOTE: there is no real upgrade going on here since the
1:c4e95b5:      * database is created with the same version, but the checking
1:c4e95b5:      * is performed nonetheless, which is what we are testing
1:c4e95b5:      * here.  This saves us from having to create a database with
1:c4e95b5:      * an old version of Derby to test this power.
1:c4e95b5:      *
1:c4e95b5:      * @param framework Derby framework name
1:c4e95b5:      * @return A suite containing the test case for hard upgrade
1:c4e95b5:      * incarnated for the three security levels no authentication,
1:c4e95b5:      * authentication, and authentication plus sqlAuthorization, The
1:c4e95b5:      * latter two has an instance for dbo, and one for an ordinary user,
1:c4e95b5:      * so there are in all five incarnations of tests.
1:c4e95b5:      */
1:c4e95b5:     private static Test dboHardUpgradeSuite(String framework)
1:c4e95b5:     {
1:c4e95b5:         Test tests[] = new Test[SQLAUTHORIZATION+1]; // one per authLevel
1:c4e95b5: 
1:c4e95b5:         /* Tests without any authorization active (level ==
1:c4e95b5:          * NOAUTHENTICATION).
1:c4e95b5:          */
1:1ae02c9:         BaseTestSuite noauthSuite =
1:1ae02c9:             new BaseTestSuite("suite: security level=" +
1:c4e95b5:                           secLevelNames[NOAUTHENTICATION]);
1:c4e95b5:         noauthSuite.addTest(new DboPowersTest("testHardUpgrade",
1:c4e95b5:                                               NOAUTHENTICATION,
1:c4e95b5:                                               "foo", "bar"));
1:c4e95b5:         tests[NOAUTHENTICATION] = noauthSuite;
1:c4e95b5: 
1:c4e95b5:         /* First decorate with users, then with authentication. Do this
1:c4e95b5:          * twice, once for authentication only, and once for
1:c4e95b5:          * authentication + sqlAuthorization (see extra decorator
1:c4e95b5:          * added below).
1:c4e95b5:          */
1:c4e95b5:         for (int autLev = AUTHENTICATION;
1:c4e95b5:              autLev <= SQLAUTHORIZATION ; autLev++) {
1:c4e95b5: 
1:c4e95b5:             tests[autLev] = wrapHardUpgradeUserTests(autLev);
1:c4e95b5:         }
1:c4e95b5: 
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite("dboPowers:"+framework);
1:c4e95b5: 
1:7feaf9c:         // A priori, doing a hard upgrade is a no-op here; we are only
1:7feaf9c:         // interested in checking if we have the powers to do it. However,
1:7feaf9c:         // sometimes the regression suite is run against a default database
1:7feaf9c:         // (system/wombat) created by an earlier release to check soft upgrade
1:7feaf9c:         // modes. To avoid interfering with such usage, we use a
1:7feaf9c:         // singleUseDatabaseDecorator below, so we avoid accidentally hard
1:7feaf9c:         // upgrading system/wombat in such runs. The SQLAUTHORIZATION run takes
1:7feaf9c:         // care of itself since it uses another database anyway.
1:7feaf9c: 
1:c4e95b5:         /* run tests with no authentication enabled */
1:7feaf9c:         suite.addTest(TestConfiguration.singleUseDatabaseDecorator(
1:7feaf9c:                           tests[NOAUTHENTICATION]));
1:c4e95b5: 
1:c4e95b5:         /* run test for all users with only authentication enabled */
1:7feaf9c:         suite.addTest(TestConfiguration.singleUseDatabaseDecorator(
1:7feaf9c:                           tests[AUTHENTICATION]));
1:c4e95b5: 
1:c4e95b5:         /* run test for all users with authentication and
1:c4e95b5:          * sqlAuthorization enabled
1:c4e95b5:          */
1:c4e95b5:         suite.addTest(
1:c4e95b5:             TestConfiguration.
1:c4e95b5:             sqlAuthorizationDecorator(tests[SQLAUTHORIZATION]));
1:c4e95b5: 
1:c4e95b5:         return suite;
1:c4e95b5:     }
1:c4e95b5: 
1:c4e95b5:     /**
1:c4e95b5:      * Wraps the shutdown fixture in decorators to run with data
1:c4e95b5:      * base owner and one other valid user.
1:c4e95b5:      *
1:c4e95b5:      * @param autLev security context to use
1:674c2a4:      */
1:c4e95b5: 
1:c4e95b5:     private static Test wrapHardUpgradeUserTests(int autLev)
1:c4e95b5:     {
1:c4e95b5:         // add decorator for different users authenticated
1:1ae02c9:         BaseTestSuite usersSuite =
1:1ae02c9:             new BaseTestSuite("usersSuite: security level=" +
1:c4e95b5:                           secLevelNames[autLev]);
1:c4e95b5: 
1:c4e95b5:         // First decorate with users, then with
1:c4e95b5:         for (int userNo = 0; userNo < users.length; userNo++) {
1:c4e95b5:             usersSuite.addTest
1:c4e95b5:                 (TestConfiguration.changeUserDecorator
1:c4e95b5:                  (new DboPowersTest("testHardUpgrade",
1:c4e95b5:                                     autLev,
1:c4e95b5:                                     users[autLev-1][0], // dbo
1:c4e95b5:                                     users[autLev-1][0].concat(pwSuffix)),
1:c4e95b5:                   users[autLev-1][userNo],
1:c4e95b5:                   users[autLev-1][userNo].concat(pwSuffix)));
1:c4e95b5:         }
1:c4e95b5: 
1:c4e95b5:         return DatabasePropertyTestSetup.
1:c4e95b5:             builtinAuthentication(usersSuite, users[autLev-1], pwSuffix);
1:c4e95b5:     }
1:674c2a4: 
1:c4e95b5:     /**
1:c4e95b5:      * Test database upgrade power enforcement
1:c4e95b5:      *
1:c4e95b5:      * @throws SQLException
1:c4e95b5:      */
1:c4e95b5:     public void testHardUpgrade() throws SQLException
1:c4e95b5:     {
1:c4e95b5:         println("testHardUpgrade: auth=" + this._authLevel +
1:c4e95b5:                 " user="+getTestConfiguration().getUserName());
1:c4e95b5: 
1:c4e95b5:         // make sure db is created
1:c4e95b5:         getConnection().close();
1:c4e95b5:         // shut it down in preparation for upgrade boot
1:c4e95b5:         bringDbDown();
1:c4e95b5: 
1:c4e95b5:         String user = getTestConfiguration().getUserName();
1:c4e95b5:         String password = getTestConfiguration().getUserPassword();
1:c4e95b5: 
1:c4e95b5:         DataSource ds = JDBCDataSource.getDataSource();
1:c4e95b5:         JDBCDataSource.setBeanProperty(
1:c4e95b5:             ds, "connectionAttributes", "upgrade=true");
1:c4e95b5:         JDBCDataSource.setBeanProperty(ds, "user", user);
1:c4e95b5:         JDBCDataSource.setBeanProperty(ds, "password", password);
1:c4e95b5:         try {
1:c4e95b5:             ds.getConnection();
1:c4e95b5:             vetHardUpgradeAttempt(user, null);
1:c4e95b5:         } catch (SQLException e) {
1:c4e95b5:             vetHardUpgradeAttempt(user, e);
1:c4e95b5:         }
1:c4e95b5: 
1:c4e95b5:         bringDbDown();
1:c4e95b5:     }
1:c4e95b5: 
1:c4e95b5: 
1:c4e95b5:     /**
1:c4e95b5:      * Decide if the result of trying to hard upgrade the database is
1:c4e95b5:      * compliant with the semantics introduced by DERBY-2264.
1:c4e95b5:      *
1:c4e95b5:      * @param user The db user under which we tried to upgrade
1:c4e95b5:      * @param e    Exception caught during attempt, if any
1:c4e95b5:      */
1:c4e95b5:     private void vetHardUpgradeAttempt (String user, SQLException e)
1:c4e95b5:     {
1:8f3b0b9:         vetAttempt(user, e, "08004", "hard upgrade");
1:c4e95b5:     }
1:c4e95b5: 
1:c4e95b5:     /**
1:c4e95b5:      * Decide if the result of trying operation yields expected result.
1:c4e95b5:      *
1:c4e95b5:      * @param user The db user under which we tried to upgrade
1:c4e95b5:      * @param e    Exception caught during attempted operation, if any
1:c4e95b5:      * @param state The expected SQL state if this operation fails due to
1:c4e95b5:      *             insufficient power
1:c4e95b5:      * @param operation string describing the operation attempted
1:c4e95b5:      */
1:c4e95b5:     private void vetAttempt (String user, SQLException e,
1:c4e95b5:                              String state, String operation)
1:c4e95b5:     {
1:af7f5e2:         switch (_authLevel) {
1:af7f5e2:         case NOAUTHENTICATION:
1:c4e95b5:             assertEquals(operation + ", no authentication", null, e);
1:af7f5e2:             break;
1:af7f5e2:         case AUTHENTICATION:
1:ca5edbb:             /* We don't enforce dbo powers if only connection level
1:ca5edbb:              * authentication is used, for now. This leniency was
1:ca5edbb:              * introduced late in 10.3 release cycle for compatibility
1:ca5edbb:              * reasons.
1:ca5edbb:              */
1:ca5edbb:             assertEquals(operation + ", authentication", null, e);
1:af7f5e2:             break;
1:af7f5e2:         case SQLAUTHORIZATION:
1:af7f5e2:             if ("TEST_DBO".equals(user)) {
1:c4e95b5:                 assertEquals(operation + ", SQL authorization, db owner",
1:af7f5e2:                              null, e);
1:af7f5e2:             } else {
1:d203eea:                 String msg = operation + ", SQL authorization, not db owner";
1:d203eea:                 assertNotNull(
1:d203eea:                         msg + ": succeeded unexpectedly without exeption", e);
1:d203eea:                 assertSQLState(msg, state, e);
1:af7f5e2:             }
1:af7f5e2:             break;
1:af7f5e2:         default:
1:af7f5e2:             fail("test error: invalid authLevel: " + _authLevel);
1:674c2a4:             break;
1:674c2a4:         }
1:674c2a4:     }
1:674c2a4: 
1:674c2a4: 
1:674c2a4:     /**
1:1c70964:      * Make and call a stored procedure which opens a nested
1:1c70964:      * connection to expose DERBY-3038.
1:1c70964:      */
1:1c70964:     private void derby3038(Connection con) throws SQLException {
1:1c70964: 
1:1c70964:         java.sql.Statement s = con.createStatement();
1:1c70964: 
1:1c70964:         try {
1:1c70964:             s.executeUpdate
1:1c70964:                 ("CREATE PROCEDURE DERBY3038PROC () " + 
1:1c70964:                  "LANGUAGE JAVA PARAMETER STYLE JAVA EXTERNAL NAME '" +
1:1c70964:                  DboPowersTest.class.getName() + ".derby3038Proc' " + 
1:1c70964:                  "READS SQL DATA");
1:1c70964:             s.executeUpdate("CALL DERBY3038PROC()");
1:1c70964:         } finally {
1:1c70964:             s.close();
1:1c70964:         }
1:1c70964:     }
1:1c70964: 
1:1c70964: 
1:1c70964:     public static void derby3038Proc() 
1:1c70964:         throws SQLException {
1:1c70964: 
1:d203eea:         // Before fixing DERBY-3038 this connect would fail.
1:1c70964:         Connection con = java.sql.DriverManager.
1:1c70964:             getConnection("jdbc:default:connection");
1:1c70964:         con.close();
1:1c70964:     }
1:674c2a4: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import java.sql.SQLException;
1: import org.apache.derbyTesting.junit.BaseTestSuite;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite("DboPowersTest");
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite noauthSuite =
1:             new BaseTestSuite("suite: security level=" +
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite("dboPowers:"+framework);
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite usersSuite =
1:             new BaseTestSuite("usersSuite: security level=" +
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite noauthSuite =
1:             new BaseTestSuite("suite: security level=" +
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite("dboPowers:"+framework);
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite usersSuite =
1:             new BaseTestSuite("usersSuite: security level=" +
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite noauthSuite =
1:             new BaseTestSuite("suite: security level=" +
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite("dboPowers:"+framework);
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite usersSuite =
1:             new BaseTestSuite("usersSuite: security level=" +
commit:7feaf9c
/////////////////////////////////////////////////////////////////////////
1:         // A priori, doing a hard upgrade is a no-op here; we are only
1:         // interested in checking if we have the powers to do it. However,
1:         // sometimes the regression suite is run against a default database
1:         // (system/wombat) created by an earlier release to check soft upgrade
1:         // modes. To avoid interfering with such usage, we use a
1:         // singleUseDatabaseDecorator below, so we avoid accidentally hard
1:         // upgrading system/wombat in such runs. The SQLAUTHORIZATION run takes
1:         // care of itself since it uses another database anyway.
1: 
1:         suite.addTest(TestConfiguration.singleUseDatabaseDecorator(
1:                           tests[NOAUTHENTICATION]));
1:         suite.addTest(TestConfiguration.singleUseDatabaseDecorator(
1:                           tests[AUTHENTICATION]));
commit:1c70964
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Connection;
/////////////////////////////////////////////////////////////////////////
0:         Connection con = null;
1:             con = ds.getConnection();
/////////////////////////////////////////////////////////////////////////
1:         try {
1:             derby3038(con);
1:         } catch (SQLException e) {
1:             fail("derby3038 regression: " + e);
1:         } 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:     /**
1:      * Make and call a stored procedure which opens a nested
1:      * connection to expose DERBY-3038.
1:      */
1:     private void derby3038(Connection con) throws SQLException {
1: 
1:         java.sql.Statement s = con.createStatement();
1: 
1:         try {
1:             s.executeUpdate
1:                 ("CREATE PROCEDURE DERBY3038PROC () " + 
1:                  "LANGUAGE JAVA PARAMETER STYLE JAVA EXTERNAL NAME '" +
1:                  DboPowersTest.class.getName() + ".derby3038Proc' " + 
1:                  "READS SQL DATA");
1:             s.executeUpdate("CALL DERBY3038PROC()");
1:         } finally {
1:             s.close();
1:         }
1:     }
1: 
1: 
1:     public static void derby3038Proc() 
1:         throws SQLException {
1: 
0:         // Before fixing DERNY-3038 this connect would fail.
1:         Connection con = java.sql.DriverManager.
1:             getConnection("jdbc:default:connection");
1:         con.close();
1:     }
commit:ca5edbb
/////////////////////////////////////////////////////////////////////////
1:          * so use that as first user.
/////////////////////////////////////////////////////////////////////////
1:             /* We don't enforce dbo powers if only connection level
1:              * authentication is used, for now. This leniency was
1:              * introduced late in 10.3 release cycle for compatibility
1:              * reasons.
1:              */
1:             assertSQLState("database shutdown, authentication",
1:                            "08006", e);
/////////////////////////////////////////////////////////////////////////
1:             /* We don't enforce dbo powers if only connection level
1:              * authentication is used, for now. This leniency was
1:              * introduced late in 10.3 release cycle for compatibility
1:              * reasons.
1:              */
1:             assertEquals(operation + ", authentication", null, e);
commit:c4e95b5
/////////////////////////////////////////////////////////////////////////
1:  * One could consider removing the client/server suites to speed up
/////////////////////////////////////////////////////////////////////////
0:      * Create a new instance of DboPowersTest (for encryption and hard
0:      * upgrade tests). The database owner credentials is needed to
0:      * always be able to perform the restricted operations (when they
0:      * are not under test, but used as part of a test fixture for
0:      * another operation).
/////////////////////////////////////////////////////////////////////////
1:         /* Database hard upgrade powers */
1: 
1:         suite.addTest(
1:             dboHardUpgradeSuite("suite: hard upgrade powers, embedded"));
1:         suite.addTest(
1:             TestConfiguration.clientServerDecorator(
1:                 dboHardUpgradeSuite("suite: hard upgrade powers, client")));
1: 
/////////////////////////////////////////////////////////////////////////
1:      * latter two has an instance for dbo, and one for an ordinary user,
/////////////////////////////////////////////////////////////////////////
1:                                               NOAUTHENTICATION));
/////////////////////////////////////////////////////////////////////////
1:      * base owner and one other valid user.
/////////////////////////////////////////////////////////////////////////
1:      * latter two has an instance for dbo, and one for an ordinary user,
/////////////////////////////////////////////////////////////////////////
1:      * base owner and one other valid user.
/////////////////////////////////////////////////////////////////////////
0:         vetAttempt(user, e, "2850I", "(re)encryption");
1:     }
1: 
1:     /**
1:      *
1:      * Construct suite of tests for hard upgrade database action
1:      *
1:      * NOTE: there is no real upgrade going on here since the
1:      * database is created with the same version, but the checking
1:      * is performed nonetheless, which is what we are testing
1:      * here.  This saves us from having to create a database with
1:      * an old version of Derby to test this power.
1:      *
1:      * @param framework Derby framework name
1:      * @return A suite containing the test case for hard upgrade
1:      * incarnated for the three security levels no authentication,
1:      * authentication, and authentication plus sqlAuthorization, The
1:      * latter two has an instance for dbo, and one for an ordinary user,
1:      * so there are in all five incarnations of tests.
1:      */
1:     private static Test dboHardUpgradeSuite(String framework)
1:     {
1:         Test tests[] = new Test[SQLAUTHORIZATION+1]; // one per authLevel
1: 
1:         /* Tests without any authorization active (level ==
1:          * NOAUTHENTICATION).
1:          */
0:         TestSuite noauthSuite =
0:             new TestSuite("suite: security level=" +
1:                           secLevelNames[NOAUTHENTICATION]);
1:         noauthSuite.addTest(new DboPowersTest("testHardUpgrade",
1:                                               NOAUTHENTICATION,
1:                                               "foo", "bar"));
1:         tests[NOAUTHENTICATION] = noauthSuite;
1: 
1:         /* First decorate with users, then with authentication. Do this
1:          * twice, once for authentication only, and once for
1:          * authentication + sqlAuthorization (see extra decorator
1:          * added below).
1:          */
1:         for (int autLev = AUTHENTICATION;
1:              autLev <= SQLAUTHORIZATION ; autLev++) {
1: 
1:             tests[autLev] = wrapHardUpgradeUserTests(autLev);
1:         }
1: 
0:         TestSuite suite = new TestSuite("dboPowers:"+framework);
1: 
1:         /* run tests with no authentication enabled */
1:         suite.addTest(tests[NOAUTHENTICATION]);
1: 
1:         /* run test for all users with only authentication enabled */
1:         suite.addTest(tests[AUTHENTICATION]);
1: 
1:         /* run test for all users with authentication and
1:          * sqlAuthorization enabled
1:          */
1:         suite.addTest(
1:             TestConfiguration.
1:             sqlAuthorizationDecorator(tests[SQLAUTHORIZATION]));
1: 
1:         return suite;
1:     }
1: 
1:     /**
1:      * Wraps the shutdown fixture in decorators to run with data
1:      * base owner and one other valid user.
1:      *
1:      * @param autLev security context to use
1:      */
1: 
1:     private static Test wrapHardUpgradeUserTests(int autLev)
1:     {
1:         // add decorator for different users authenticated
0:         TestSuite usersSuite =
0:             new TestSuite("usersSuite: security level=" +
1:                           secLevelNames[autLev]);
1: 
1:         // First decorate with users, then with
1:         for (int userNo = 0; userNo < users.length; userNo++) {
1:             usersSuite.addTest
1:                 (TestConfiguration.changeUserDecorator
1:                  (new DboPowersTest("testHardUpgrade",
1:                                     autLev,
1:                                     users[autLev-1][0], // dbo
1:                                     users[autLev-1][0].concat(pwSuffix)),
1:                   users[autLev-1][userNo],
1:                   users[autLev-1][userNo].concat(pwSuffix)));
1:         }
1: 
1:         return DatabasePropertyTestSetup.
1:             builtinAuthentication(usersSuite, users[autLev-1], pwSuffix);
1:     }
1: 
1:     /**
1:      * Test database upgrade power enforcement
1:      *
1:      * @throws SQLException
1:      */
1:     public void testHardUpgrade() throws SQLException
1:     {
1:         println("testHardUpgrade: auth=" + this._authLevel +
1:                 " user="+getTestConfiguration().getUserName());
1: 
1:         // make sure db is created
1:         getConnection().close();
1:         // shut it down in preparation for upgrade boot
1:         bringDbDown();
1: 
1:         String user = getTestConfiguration().getUserName();
1:         String password = getTestConfiguration().getUserPassword();
1: 
1:         DataSource ds = JDBCDataSource.getDataSource();
1:         JDBCDataSource.setBeanProperty(
1:             ds, "connectionAttributes", "upgrade=true");
1:         JDBCDataSource.setBeanProperty(ds, "user", user);
1:         JDBCDataSource.setBeanProperty(ds, "password", password);
1:         try {
1:             ds.getConnection();
1:             vetHardUpgradeAttempt(user, null);
1:         } catch (SQLException e) {
1:             vetHardUpgradeAttempt(user, e);
1:         }
1: 
1:         bringDbDown();
1:     }
1: 
1: 
1:     /**
1:      * Decide if the result of trying to hard upgrade the database is
1:      * compliant with the semantics introduced by DERBY-2264.
1:      *
1:      * @param user The db user under which we tried to upgrade
1:      * @param e    Exception caught during attempt, if any
1:      */
1:     private void vetHardUpgradeAttempt (String user, SQLException e)
1:     {
0:         vetAttempt(user, e, "2850J", "hard upgrade");
1:     }
1: 
1:     /**
1:      * Decide if the result of trying operation yields expected result.
1:      *
1:      * @param user The db user under which we tried to upgrade
1:      * @param e    Exception caught during attempted operation, if any
1:      * @param state The expected SQL state if this operation fails due to
1:      *             insufficient power
1:      * @param operation string describing the operation attempted
1:      */
1:     private void vetAttempt (String user, SQLException e,
1:                              String state, String operation)
1:     {
1:             assertEquals(operation + ", no authentication", null, e);
0:                 assertEquals(operation + ", authentication, db owner", null, e);
0:                 assertSQLState(operation + ", authentication, not db owner",
0:                                state, e);
1:                 assertEquals(operation + ", SQL authorization, db owner",
0:                 assertSQLState(operation +", SQL authorization, not db owner",
0:                                state, e);
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:d203eea
/////////////////////////////////////////////////////////////////////////
1:     final private static boolean ENCRYPT = true;
1:     final private static boolean DECRYPT = false;
1: 
/////////////////////////////////////////////////////////////////////////
1:      * Creates a new instance of DboPowersTest for cryptographic operations
1:      * and hard upgrade tests.
1:      * <p>
1:      * The database owner credentials is needed to always be able to perform
1:      * the restricted operations (when they are not under test, but used as
1:      * part of a test fixture for another operation).
/////////////////////////////////////////////////////////////////////////
1:         // Database (re)encryption powers and decryption powers.
1:         // The cryptographic power tests are not run for JSR169, since Derby
1:         // does not support database encryption for that platform, cf.
1:         // the specification for JSR169 support in DERBY-97.
1:                 dboCryptoSuite("suite: cryptographic powers, embedded"));
1:                     dboCryptoSuite("suite: cryptographic powers, client")));
/////////////////////////////////////////////////////////////////////////
1:      * Users used by both dboShutdownSuite and dboCryptoSuite
/////////////////////////////////////////////////////////////////////////
1:      * Constructs suite of tests for cryptographic actions, that is database
1:      * encryption, re-encryption, and decryption.
1:      * @return A suite containing the test cases for cryptographic operations
1:     private static Test dboCryptoSuite(String framework)
/////////////////////////////////////////////////////////////////////////
1:         for (int tNo = 0; tNo < cryptoTests.length; tNo++) {
1:                     new DboPowersTest(cryptoTests[tNo], NOAUTHENTICATION,
/////////////////////////////////////////////////////////////////////////
1:             tests[autLev] = wrapCryptoUserTests(autLev);
/////////////////////////////////////////////////////////////////////////
1:     private static Test wrapCryptoUserTests(int autLev)
/////////////////////////////////////////////////////////////////////////
1:             for (int tNo = 0; tNo < cryptoTests.length; tNo++) {
1:                     (new DboPowersTest(cryptoTests[tNo],
/////////////////////////////////////////////////////////////////////////
1:      * Enumerates the cryptographic tests.
1:     final static String[] cryptoTests = {
1:         "testEncrypt", "testReEncrypt", "testDecrypt"};
/////////////////////////////////////////////////////////////////////////
1:         Connection con;
1:             vetCryptoAttempt(ENCRYPT, user, null);
1:             vetCryptoAttempt(ENCRYPT, user, e);
/////////////////////////////////////////////////////////////////////////
1:             vetCryptoAttempt(ENCRYPT, user, null);
1:             vetCryptoAttempt(ENCRYPT, user, e);
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Tests that only the DBO can decrypt a database.
1:      */
1:     public void testDecrypt()
1:             throws SQLException {
1:         println("testDecrypt: auth=" + this._authLevel +
1:                 " user=" + getTestConfiguration().getUserName());
1: 
1:         // make sure db is created
1:         getConnection().close();
1: 
1:         // shut down database in preparation for encryption
1:         bringDbDown();
1:         String bootPassword = "conHippo08";
1:         doEncrypt(bootPassword);
1:         // shut down database in preparation for decryption
1:         bringDbDown();
1: 
1:         String user = getTestConfiguration().getUserName();
1:         String password = getTestConfiguration().getUserPassword();
1:         DataSource ds = JDBCDataSource.getDataSource();
1:         JDBCDataSource.setBeanProperty(ds, "connectionAttributes",
1:                                        "bootPassword=" + bootPassword +
1:                                        ";decryptDatabase=true");
1:         JDBCDataSource.setBeanProperty(ds, "user", user);
1:         JDBCDataSource.setBeanProperty(ds, "password", password);
1: 
1:         try {
1:             ds.getConnection();
1:             vetCryptoAttempt(DECRYPT, user, null);
1:         } catch (SQLException sqle) {
1:             vetCryptoAttempt(DECRYPT, user, sqle);
1:             return;
1:         } finally {
1:             bringDbDown();
1:         }
1: 
1:         // we managed to decrypt: bring db up again to verify
1:         bringDbUp(null);
1:         bringDbDown();
1:     }
/////////////////////////////////////////////////////////////////////////
1:      * Boots database back up after cryptographic operation using current user,
1:      * should succeed.
1:      * @param bootPassword boot using this bootPassword, may be {@code null}
/////////////////////////////////////////////////////////////////////////
1:         if (bootPassword != null) {
1:             JDBCDataSource.setBeanProperty(
1:                 ds, "connectionAttributes", "bootPassword=" + bootPassword);
1:         }
1:      * Decides if the result of trying to (re-)encrypt or decrypt the database
1:      * is compliant with the semantics introduced by DERBY-2264.
1:      * @param encrypt whether we are (re-)encrypting or decrypting
1:     private void vetCryptoAttempt(boolean encrypt, String user, SQLException e)
1:         vetAttempt(user, e, "08004", encrypt ? "(re)encryption" : "decrypt");
/////////////////////////////////////////////////////////////////////////
1:                 String msg = operation + ", SQL authorization, not db owner";
1:                 assertNotNull(
1:                         msg + ": succeeded unexpectedly without exeption", e);
1:                 assertSQLState(msg, state, e);
/////////////////////////////////////////////////////////////////////////
1:         // Before fixing DERBY-3038 this connect would fail.
commit:7fe51c3
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:9cf3fb5
/////////////////////////////////////////////////////////////////////////
0:         JDBCDataSource.setBeanProperty(ds, "createDatabase", "false");
/////////////////////////////////////////////////////////////////////////
0:         JDBCDataSource.setBeanProperty(ds, "createDatabase", "false");
/////////////////////////////////////////////////////////////////////////
1: 
0:         JDBCDataSource.setBeanProperty(ds, "createDatabase", "false");
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:8f3b0b9
/////////////////////////////////////////////////////////////////////////
1:                                "08004", e);
/////////////////////////////////////////////////////////////////////////
0:                                "08004", e);
/////////////////////////////////////////////////////////////////////////
0:         vetAttempt(user, e, "08004", "(re)encryption");
/////////////////////////////////////////////////////////////////////////
1:         vetAttempt(user, e, "08004", "hard upgrade");
author:Army
-------------------------------------------------------------------------------
commit:19ea327
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.JDBC;
/////////////////////////////////////////////////////////////////////////
1:         /* Database shutdown powers */
1: 
0:         /* Database (re)encryption powers
1:          *
0:          * The encryption power tests are not run for JSR169, since Derby
0:          * does not support database encryption for that platform, cf.
0:          * the specification for JSR169 support in DERBY-97.
1:          */
1:         if (!JDBC.vmSupportsJSR169()) {
1:             suite.addTest(
0:                 dboEncryptionSuite("suite: encryption powers, embedded"));
1:             suite.addTest(
1:                 TestConfiguration.clientServerDecorator(
0:                     dboEncryptionSuite("suite: encryption powers, client")));
1:         }
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:af7f5e2
/////////////////////////////////////////////////////////////////////////
1:  *    {client/server, embedded} x
/////////////////////////////////////////////////////////////////////////
1:     /* internal state */
1:     final private int _authLevel;
1:     final private String _dbo;
1:     final private String _dboPassword;
1: 
1: 
1:     final private static String[] secLevelNames = {
1:         "noAuthentication",
1:         "authentication",
1:         "authentication + sqlAuthorization"};
1: 
1:      * Create a new instance of DboPowersTest (for shutdown test)
1:     public DboPowersTest(String name, int authLevel)
1:     {
1:         super(name);
1:         this._authLevel = authLevel;
1:         this._dbo = null;
1:         this._dboPassword = null;
0:      * Create a new instance of DboPowersTest (for encryption tests)
1:      *
1:      * @param name Fixture name
1:      * @param authLevel authentication level with which test is run
1:      * @param dbo Database owner
1:      * @param dboPassword Database owner's password
1:      */
1: 
1:     public DboPowersTest(String name, int authLevel,
1:                          String dbo, String dboPassword)
1:     {
1:         super(name);
1:         this._authLevel = authLevel;
1:         this._dbo = dbo;
1:         this._dboPassword = dboPassword;
1:     }
1: 
1: 
1:     /**
/////////////////////////////////////////////////////////////////////////
1: 
1:         suite.addTest(dboShutdownSuite("suite: shutdown powers, embedded"));
1:         suite.addTest(
1:             TestConfiguration.clientServerDecorator(
1:                 dboShutdownSuite("suite: shutdown powers, client")));
1: 
0:         suite.addTest(dboEncryptionSuite("suite: encryption powers, embedded"));
1:         suite.addTest(
1:             TestConfiguration.clientServerDecorator(
0:                 dboEncryptionSuite("suite: encryption powers, client")));
1: 
1: 
1:     /**
0:      * Users used by both dboShutdownSuite and dboEncryptionSuite
1:      */
1:     final static String[][] users = {
1:         /* authLevel == AUTHENTICATION: dbo is APP/APP for db 'wombat',
0:          * so use that as first user.  Otherwise,
0:          * builtinAuthentication decorator's db shutdown fails to
0:          * work after DERBY-2264(!).
1:          */
1:         {"APP", "U1"},
1:         /* authLevel == SQLAUTHORIZATION: sqlAuthorizationDecorator
1:          * decorator presumes TEST_DBO as dbo, so add it to set of
1:          * valid users. Uses a fresh db 'dbsqlauth', not 'wombat'.
1:          */
1:         {"TEST_DBO", "U1"}};
1: 
1:     final static String pwSuffix = "pwSuffix";
1: 
1: 
1:      * Construct suite of tests for shutdown database action
1:      * @param framework Derby framework name
1:      * @return A suite containing the test case for shutdown
1:      * incarnated for the three security levels no authentication,
1:      * authentication, and authentication plus sqlAuthorization, The
0:      * latter two has an instance for dbo, and one for ordinary user,
1:      * so there are in all five incarnations of tests.
1:     private static Test dboShutdownSuite(String framework)
1:         /* Tests without any authorization active (level ==
1:          * NOAUTHENTICATION).
1:          */
0:         TestSuite noauthSuite =
0:             new TestSuite("suite: security level=" +
1:                           secLevelNames[NOAUTHENTICATION]);
1:         noauthSuite.addTest(new DboPowersTest("testShutDown",
0:                                                     NOAUTHENTICATION));;
1:         tests[NOAUTHENTICATION] = noauthSuite;
1:          * authentication + sqlAuthorization (see extra decorator
1:         for (int autLev = AUTHENTICATION;
1:             tests[autLev] = wrapShutdownUserTests(autLev);
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:      * Wraps the shutdown fixture in decorators to run with data
0:      * base owner and other valid user.
1:      * @param autLev security context to use
1: 
1:     private static Test wrapShutdownUserTests(int autLev)
1:         // add decorator for different users authenticated
0:         TestSuite usersSuite =
0:             new TestSuite("usersSuite: security level=" +
1:                           secLevelNames[autLev]);
1: 
1:         // First decorate with users, then with
1:         for (int userNo = 0; userNo < users.length; userNo++) {
1:             usersSuite.addTest
1:                 (TestConfiguration.changeUserDecorator
1:                  (new DboPowersTest("testShutDown", autLev),
1:                   users[autLev-1][userNo],
1:                   users[autLev-1][userNo].concat(pwSuffix)));
1:         }
1: 
1:         return DatabasePropertyTestSetup.
1:             builtinAuthentication(usersSuite, users[autLev-1], pwSuffix);
1: 
/////////////////////////////////////////////////////////////////////////
1:         println("testShutDown: auth=" + this._authLevel +
1:                 " user="+getTestConfiguration().getUserName());
1: 
/////////////////////////////////////////////////////////////////////////
1:         switch (_authLevel) {
1:             assertSQLState("database shutdown, no authentication",
0:                 assertSQLState("database shutdown, authentication, db owner",
1:                 assertSQLState("database shutdown restriction, " +
0:                                "authentication,  not db owner",
0:                                "2850H", e);
/////////////////////////////////////////////////////////////////////////
0:                 assertSQLState("database shutdown restriction, " +
1:             fail("test error: invalid authLevel: " + _authLevel);
1:             break;
1:         }
1:     }
1: 
1:     /**
1:      *
0:      * Construct suite of tests for database encryption action
1:      *
1:      * @param framework Derby framework name
0:      * @return A suite containing the test case for encryption
1:      * incarnated for the three security levels no authentication,
1:      * authentication, and authentication plus sqlAuthorization, The
0:      * latter two has an instance for dbo, and one for ordinary user,
1:      * so there are in all five incarnations of tests.
1:      */
0:     private static Test dboEncryptionSuite(String framework)
1:     {
1:         Test tests[] = new Test[SQLAUTHORIZATION+1]; // one per authLevel
1: 
1:         /* Tests without any authorization active (level ==
1:          * NOAUTHENTICATION).  Note use of no shutdown decorator
1:          * variants: Necessary since framework doesn't know
1:          * bootPassword.
1:          */
0:         TestSuite noauthSuite =
0:             new TestSuite("suite: security level=" +
1:                           secLevelNames[NOAUTHENTICATION]);
1: 
0:         for (int tNo = 0; tNo < encryptionTests.length; tNo++) {
1:             noauthSuite.addTest(
1:                 TestConfiguration.singleUseDatabaseDecoratorNoShutdown(
0:                     new DboPowersTest(encryptionTests[tNo], NOAUTHENTICATION,
1:                                       "foo", "bar")));
1:         }
1: 
1:         tests[NOAUTHENTICATION] = noauthSuite;
1: 
1:         /* Tests with authentication and sql authorization
1:          */
1:         for (int autLev = AUTHENTICATION;
1:              autLev <= SQLAUTHORIZATION ; autLev++) {
1: 
0:             tests[autLev] = wrapEncryptionUserTests(autLev);
1:         }
1: 
0:         TestSuite suite = new TestSuite("dboPowers:"+framework);
1: 
1:         /* run tests with no authentication enabled */
1:         suite.addTest(tests[NOAUTHENTICATION]);
1: 
1:         /* run test for all users with only authentication enabled */
1:         suite.addTest(tests[AUTHENTICATION]);
1: 
1:         /* run test for all users with authentication and
1:          * sqlAuthorization enabled
1:          */
1:         suite.addTest(tests[SQLAUTHORIZATION]);
1: 
1:         return suite;
1:     }
1: 
1:     /**
1:      * Wraps the encryption fixtures in decorators to run with data
0:      * base owner and other valid user.
1:      *
1:      * @param autLev security context to use
1:      */
1: 
0:     private static Test wrapEncryptionUserTests(int autLev)
1:     {
1:         // add decorator for different users authenticated
0:         TestSuite usersSuite =
0:             new TestSuite("usersSuite: security level=" +
1:                           secLevelNames[autLev]);
1: 
1:         // First decorate with users, then with authentication.  Note
1:         // use of no teardown / no shutdown decorator variants:
1:         // Necessary since framework doesnt know bootPassword
1:         for (int userNo = 0; userNo < users.length; userNo++) {
0:             for (int tNo = 0; tNo < encryptionTests.length; tNo++) {
1:                 Test test = TestConfiguration.changeUserDecorator
0:                     (new DboPowersTest(encryptionTests[tNo],
1:                                        autLev,
1:                                        users[autLev-1][0], // dbo
1:                                        users[autLev-1][0].concat(pwSuffix)),
1:                      users[autLev-1][userNo],
1:                      users[autLev-1][userNo].concat(pwSuffix));
1:                 test = DatabasePropertyTestSetup.builtinAuthenticationNoTeardown
1:                     (test, users[autLev-1], pwSuffix);
1:                 if (autLev == AUTHENTICATION) {
1:                     test = TestConfiguration.
1:                         singleUseDatabaseDecoratorNoShutdown(test);
1:                 } else {
1:                     test = TestConfiguration.
1:                         sqlAuthorizationDecoratorSingleUse(test);
1:                 }
1:                 usersSuite.addTest(test);
1:             }
1:         }
1:         return usersSuite;
1:     }
1: 
1:     /**
0:      * Enumerates the encryption tests
1:      */
0:     final static String[] encryptionTests = { "testEncrypt", "testReEncrypt" };
1: 
1:     /**
1:      * Test database encryption for an already created
1:      * database. Note: The test needs to shut down the database for
1:      * the single use decorators to work.
1:      *
1:      * @throws SQLException
1:      */
1:     public void testEncrypt() throws SQLException
1:     {
1:         println("testEncrypt: auth=" + this._authLevel +
1:                 " user="+getTestConfiguration().getUserName());
1: 
1:         // make sure db is created
1:         getConnection().close();
1: 
1:         // shut down database in preparation for encryption
1:         bringDbDown();
1: 
1:         // make encryption attempt
1:         String user = getTestConfiguration().getUserName();
1:         String password = getTestConfiguration().getUserPassword();
1:         String bootPassword="12345678";
1:         DataSource ds = JDBCDataSource.getDataSource();
1: 
1:         JDBCDataSource.setBeanProperty(ds, "connectionAttributes",
1:                                        "dataEncryption=true;bootPassword=" +
1:                                            bootPassword);
1:         JDBCDataSource.setBeanProperty(ds, "user", user);
1:         JDBCDataSource.setBeanProperty(ds, "password", password);
1: 
1:         try {
1:             ds.getConnection();
0:             vetEncryptionAttempt(user, null);
1:         } catch (SQLException e) {
0:             vetEncryptionAttempt(user, e);
1:             bringDbDown();
1:             return;
1:         }
1: 
1:         // we managed to encrypt: bring db down and up again to verify
1:         bringDbDown();
1:         bringDbUp(bootPassword);
1:         bringDbDown();
1:     }
1: 
1: 
1:     /**
1:      * Test database re-encryption for an already encrypted
1:      * database. Note: The test needs to shut down database for the
1:      * single use decorators to work.
1:      *
1:      * @throws SQLException
1:      */
1:     public void testReEncrypt() throws SQLException
1:     {
1:         println("testReEncrypt: auth=" + this._authLevel +
1:                 " user="+getTestConfiguration().getUserName());
1: 
1:         // make sure db is created
1:         getConnection().close();
1: 
1:         // shut down database in preparation for encryption
1:         bringDbDown();
1: 
1:         String bootPassword="12345678";
1:         doEncrypt(bootPassword);
1:         bringDbDown();
1: 
1:         // make re-encryption attempt
1:         String user = getTestConfiguration().getUserName();
1:         String password = getTestConfiguration().getUserPassword();
1:         String newBootPassword="87654321";
1:         DataSource ds = JDBCDataSource.getDataSource();
1: 
1:         JDBCDataSource.setBeanProperty(ds, "connectionAttributes",
1:                                        "bootPassword=" + bootPassword +
1:                                        ";newBootPassword=" + newBootPassword);
1:         JDBCDataSource.setBeanProperty(ds, "user", user);
1:         JDBCDataSource.setBeanProperty(ds, "password", password);
1: 
1:         try {
1:             ds.getConnection();
0:             vetEncryptionAttempt(user, null);
1:         } catch (SQLException e) {
0:             vetEncryptionAttempt(user, e);
1:             bringDbDown();
1:             return;
1:         }
1: 
1:         // we managed to encrypt: bring db down and up again to verify
1:         bringDbDown();
1:         bringDbUp(newBootPassword);
1:         bringDbDown();
1:     }
1: 
1: 
1:     /**
1:      * Encrypt database, as owner (not testing encryption power here)
1:      * @param bootPassword
1:      * @throws SQLException
1:      */
1:     private void doEncrypt(String bootPassword) throws SQLException
1:     {
1:         DataSource ds = JDBCDataSource.getDataSource();
1:         JDBCDataSource.setBeanProperty(ds, "connectionAttributes",
1:                                        "dataEncryption=true;bootPassword=" +
1:                                        bootPassword);
1:         JDBCDataSource.setBeanProperty(ds, "user", _dbo);
1:         JDBCDataSource.setBeanProperty(ds, "password", _dboPassword);
1:         ds.getConnection();
1:     }
1: 
1: 
1:     /**
1:      * Shut down database, as db owner (not testing that power here)
1:      */
1:     private void bringDbDown()
1:     {
1:         DataSource ds = JDBCDataSource.getDataSource();
1:         JDBCDataSource.setBeanProperty(
1:             ds, "connectionAttributes", "shutdown=true");
1:         JDBCDataSource.setBeanProperty(ds, "user", _dbo);
1:         JDBCDataSource.setBeanProperty(ds, "password", _dboPassword);
1:         try {
1:             ds.getConnection();
1:             fail("shutdown failed: expected exception");
1:         } catch (SQLException e) {
1:             assertSQLState("database shutdown", "08006", e);
1:         }
1:     }
1: 
1: 
1:     /**
0:      * Boot database back up after encryption using current user,
0:      * should succeed
1:      *
0:      * @param bootPassword Boot using this bootPassword
1:      * @throws SQLException
1:      */
1:     private void bringDbUp(String bootPassword) throws SQLException
1:     {
1:         String user = getTestConfiguration().getUserName();
1:         String password = getTestConfiguration().getUserPassword();
1:         DataSource ds = JDBCDataSource.getDataSource();
1:         JDBCDataSource.setBeanProperty(
0:             ds, "connectionAttributes", "bootPassword=" + bootPassword);
1:         JDBCDataSource.setBeanProperty(ds, "user", user);
1:         JDBCDataSource.setBeanProperty(ds, "password", password);
1:         ds.getConnection().close();
1:     }
1: 
1:     /**
0:      * Decide if the result of trying to (re)encrypt the database is
1:      * compliant with the semantics introduced by DERBY-2264.
1:      *
1:      * @param user The db user under which we tried to encrypt
1:      * @param e    Exception caught during attempt, if any
1:      */
0:     private void vetEncryptionAttempt (String user, SQLException e)
1:     {
1:         switch (_authLevel) {
1:         case NOAUTHENTICATION:
0:             assertEquals("encryption, no authentication", null, e);
1:             break;
1:         case AUTHENTICATION:
0:             if ("APP".equals(user)) {
0:                 assertEquals("encryption, authentication, db owner", null, e);
1:             } else {
0:                 assertSQLState("database encryption restriction, " +
0:                                "authentication, not db owner", "2850I", e);
1:             }
1:             break;
1:         case SQLAUTHORIZATION:
1:             if ("TEST_DBO".equals(user)) {
0:                 assertEquals("encryption, SQL authorization, db owner",
1:                              null, e);
1:             } else {
0:                 assertSQLState("encryption restriction, " +
1:                                "SQL authorization, not db owner",
0:                                "2850I", e);
1:             }
1:             break;
1:         default:
1:             fail("test error: invalid authLevel: " + _authLevel);
commit:df597d1
/////////////////////////////////////////////////////////////////////////
1:  * DERBY-2264.
/////////////////////////////////////////////////////////////////////////
1:  */
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      * Construct top level suite in this JUnit test
/////////////////////////////////////////////////////////////////////////
1:     }
/////////////////////////////////////////////////////////////////////////
0:      * in all five incarnations of tests.
/////////////////////////////////////////////////////////////////////////
0:             /* authLevel == SQLAUTHORIZATION: sqlAuthorizationDecorator
/////////////////////////////////////////////////////////////////////////
1:         Test tests[] = new Test[SQLAUTHORIZATION+1]; // one per authLevel
1:         /* First decorate with users, then with authentication. Do this
/////////////////////////////////////////////////////////////////////////
0:                                : "sqlAuthorization"));
/////////////////////////////////////////////////////////////////////////
0:                 builtinAuthentication(userSuite, users[autLev-1], pwSuffix);
/////////////////////////////////////////////////////////////////////////
1:         /* run test for all users with authentication and
/////////////////////////////////////////////////////////////////////////
0:      * Pick up individual test fixtures explicitly, since we need to
1:      *
0:      * @param authLevel tests to be run with this security level
/////////////////////////////////////////////////////////////////////////
1:      * Test database shutdown power enforcement
1:      *
1:      * @throws SQLException
/////////////////////////////////////////////////////////////////////////
1:                 ds.getConnection().close();
/////////////////////////////////////////////////////////////////////////
1:      *
0:      * @throws SQLException
1:     private void vetShutdownException (String user, SQLException e)
/////////////////////////////////////////////////////////////////////////
0:             } else {
/////////////////////////////////////////////////////////////////////////
0:                                "SQL authorization, not db owner",
/////////////////////////////////////////////////////////////////////////
commit:674c2a4
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derbyTesting.functionTests.tests.jdbcapi.DboPowersTest
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:      http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.tests.jdbcapi;
1: 
0: import java.sql.SQLException;
1: import javax.sql.DataSource;
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.DatabasePropertyTestSetup;
1: import org.apache.derbyTesting.junit.JDBCDataSource;
1: import org.apache.derbyTesting.junit.TestConfiguration;
1: 
1: /**
1:  * This JUnit tests enforcement of dbo (=database owner) powers, cf.
0: * DERBY-2264.
1:  *
1:  * The tests are run in the cross product (cardinality 10) of contexts:
1:  *
0:  *    {client/server, embedded} x 
1:  *    {no authentication, authentication and authentication/sqlAuthorization} x
1:  *    {data base owner, other user }
1:  *
0:  * One could consider removing the client/server suite to speed up
1:  * this test as it does not add much value given the nature of the changes.
1:  *
1: */
1: public class DboPowersTest extends BaseJDBCTestCase
1: {
1:     /* test execution security context: one of three below */
0:     final private int authLevel; 
1:     final private static int NOAUTHENTICATION=0;
1:     final private static int AUTHENTICATION=1;
1:     final private static int SQLAUTHORIZATION=2;
1:     
1:     /**
0:      * Create a new instance of DboPowersTest
1:     *
1:      * @param name Fixture name
1:      * @param authLevel authentication level with which test is run
1:      */
0:     public DboPowersTest(String name, int authLevel) 
1:     { 
0:         super(name); 
0:         this.authLevel = authLevel;
1:     }
1: 
1:     /**
0:     * Construct top level suite in this JUnit test
1:      *
1:      * @return A suite containing embedded and client suites
1:      */
1:     public static Test suite()
1:     {
0:         TestSuite suite = new TestSuite("DboPowersTest");
0:         suite.addTest(dboSuite("embedded"));
0:         suite.addTest(TestConfiguration.clientServerDecorator(
0:                           dboSuite("client")));
1:         return suite;
1:    }
1:         
1:     /**
1:      *
0:      * Construct default suite of tests
1:      *
0:      * @param framework Derby framework
0:      * @return A suite containing the test cases incarnated for the three
0:      * security levels no authentication, authentication, and
0:      * authentication plus sqlAuthorization, 
0:      * The latter two has an instance for dbo, and one for ordinary user,
0:     * in all five incarnations of tests.
1:      */
0:     private static Test dboSuite(String framework) 
1:     {
0:         final String[][] users = {
0:             /* authLevel == AUTHENTICATION: dbo is APP/APP for db 'wombat',
0:              * so use that as first user.  Otherwise,
0:              * builtinAuthentication decorator's db shutdown fails to
0:              * work after DERBY-2264(!).
1:              */
0:             {"APP", "U1"}, 
0:            /* authLevel == SQLAUTHORIZATION: sqlAuthorizationDecorator
0:              * decorator presumes TEST_DBO as dbo, so add it to set of
0:              * valid users. Uses a fresh db 'dbsqlauth', not 'wombat'.
1:              */
0:             {"TEST_DBO", "U1"}};
1:         
0:         final String pwSuffix = "pwSuffix";
1: 
0:         Test tests[] = new Test[3]; // one per authLevel
1: 
0:         tests[NOAUTHENTICATION] = collectFixtures(NOAUTHENTICATION);
1: 
0:         /** First decorate with users, then with authentication. Do this
1:          * twice, once for authentication only, and once for
0:          * authentication and sqlAuthorization (see extra decorator
1:          * added below).
1:          */
0:         for (int autLev = AUTHENTICATION; 
1:              autLev <= SQLAUTHORIZATION ; autLev++) {
1: 
0:             // add decorator for different users authenticated
0:             TestSuite userSuite =  new TestSuite(
0:                 "userSuite:"+ (autLev == AUTHENTICATION ? "authentication"
0:                               : "sqlAuthorization"));
1: 
0:             for (int userNo = 0; userNo < users.length; userNo++) {
0:                 userSuite.addTest
0:                     (TestConfiguration.changeUserDecorator
0:                      (collectFixtures(autLev),
0:                       users[autLev-1][userNo], 
0:                       users[autLev-1][userNo].concat(pwSuffix)));
1:             }
1:         
0:             tests[autLev] = DatabasePropertyTestSetup.
0:                builtinAuthentication(userSuite, users[autLev-1], pwSuffix);
1:         }
1: 
0:         TestSuite suite = new TestSuite("dboPowers:"+framework);
1: 
1:         /* run tests with no authentication enabled */
0:         suite.addTest(tests[NOAUTHENTICATION]);
1: 
1:         /* run test for all users with only authentication enabled */
0:         suite.addTest(tests[AUTHENTICATION]);
1: 
0:        /* run test for all users with authentication and
1:          * sqlAuthorization enabled
1:          */
0:         suite.addTest(
1:             TestConfiguration.
1:             sqlAuthorizationDecorator(tests[SQLAUTHORIZATION]));
1:                          
1:         return suite;
1:     }
1: 
1:     /**
0:     * Picks up individual test fixtures explicitly, since we need to
0:      * provide the context.
1:      */
0:     private static TestSuite collectFixtures(int authLevel)
1:     {
0:         TestSuite suite = new TestSuite("dboPowersTests");
0:         suite.addTest(new DboPowersTest("testShutDown", authLevel));
1:         return suite;
1:     }
1: 
1:     /**
0:     * Test database shutdown power enforcement
1:      */
1:     public void testShutDown() throws SQLException
1:     {
1:         // make sure db is booted
1:         getConnection().close();
1: 
1:         String user = getTestConfiguration().getUserName();
1:         String password = getTestConfiguration().getUserPassword();
1: 
1:         DataSource ds = JDBCDataSource.getDataSource();
0:         JDBCDataSource.setBeanProperty(
1:             ds, "connectionAttributes", "shutdown=true");
1:         JDBCDataSource.setBeanProperty(ds, "user", user);
1:         JDBCDataSource.setBeanProperty(ds, "password", password);
1:         try {
0:             ds.getConnection();
1:             fail("shutdown failed: no exception");
1:         } catch (SQLException e) {
1:             if ("08006".equals(e.getSQLState())) {
1:                 // reboot if shutdown succeeded
1:                 JDBCDataSource.setBeanProperty(ds, "connectionAttributes", "");
0:                ds.getConnection().close();
1:             }
1: 
1:             vetShutdownException(user, e);
1:         }
1:     }
1: 
1:     /**
1:      * Decide if the result of trying to shut down the database is
0:      * compliant with the semantics introduced by DERBY-2264.
1:      */
0:    private void vetShutdownException (String user, SQLException e)
1:     {
0:         switch (authLevel) {
1:         case NOAUTHENTICATION:
0:             assertSQLState("database shutdown, no authentication", 
1:                            "08006", e);
1:             break;
1:         case AUTHENTICATION:
0:             if ("APP".equals(user)) {
0:                 assertSQLState("database shutdown, authentication, db owner", 
1:                                "08006", e);
0:            } else {
0:                 assertSQLState("database shutdown restriction, authentication," +
0:                                " not db owner", "2850H", e);
1:             }
1:             break;
1:         case SQLAUTHORIZATION:
1:             if ("TEST_DBO".equals(user)) {
1:                 assertSQLState("database shutdown, SQL authorization, db owner",
1:                                "08006", e);
0:             } else {
0:                 assertSQLState("database shutdown restriction, " + 
0:                               "SQL authorization, not db owner",
0:                                "2850H", e);
1:             }
1:             break;
1:         default:
0:             fail("test error");
1:             break;
1:         }
1:     }
1: }
1: 
============================================================================