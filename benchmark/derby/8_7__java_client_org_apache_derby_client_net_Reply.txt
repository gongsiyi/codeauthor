3:33776ff: /*
157:33776ff: 
1:33776ff:    Derby - Class org.apache.derby.client.net.Reply
1:33776ff: 
1:59bf37d:    Licensed to the Apache Software Foundation (ASF) under one or more
1:59bf37d:    contributor license agreements.  See the NOTICE file distributed with
1:59bf37d:    this work for additional information regarding copyright ownership.
1:59bf37d:    The ASF licenses this file to You under the Apache License, Version 2.0
1:59bf37d:    (the "License"); you may not use this file except in compliance with
1:59bf37d:    the License.  You may obtain a copy of the License at
1:33776ff: 
1:33776ff:       http://www.apache.org/licenses/LICENSE-2.0
1:33776ff: 
1:33776ff:    Unless required by applicable law or agreed to in writing, software
1:33776ff:    distributed under the License is distributed on an "AS IS" BASIS,
1:33776ff:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:33776ff:    See the License for the specific language governing permissions and
1:33776ff:    limitations under the License.
1:33776ff: 
3:33776ff: */
1:33776ff: 
1:33776ff: package org.apache.derby.client.net;
1:33776ff: 
1:33776ff: 
1:33776ff: import java.io.ByteArrayOutputStream;
1:69e3d06: import java.io.IOException;
1:a0b8943: import java.nio.charset.Charset;
1:9f5bc90: import java.util.Arrays;
1:b13b17c: import org.apache.derby.client.am.Agent;
1:33776ff: 
1:70f7692: import org.apache.derby.client.am.SignedBinary;
1:70f7692: import org.apache.derby.client.am.SqlException;
1:1b39163: import org.apache.derby.client.am.DisconnectException;
1:1b39163: import org.apache.derby.client.am.ClientMessageId;
1:1b39163: 
1:1b39163: import org.apache.derby.shared.common.reference.SQLState;
1:6a925a3: import org.apache.derby.shared.common.reference.MessageId;
1:33776ff: 
1:0326967: class Reply {
1:b13b17c:     protected Agent agent_;
1:70f7692:     protected NetAgent netAgent_; //cheat-link to (NetAgent) agent_
1:33776ff: 
1:70f7692:     protected final static int DEFAULT_BUFFER_SIZE = 32767;
1:70f7692:     protected byte[] buffer_;
1:70f7692:     protected int pos_;
1:70f7692:     protected int count_;
1:33776ff: 
1:70f7692:     private int topDdmCollectionStack_;
1:70f7692:     private final static int MAX_MARKS_NESTING = 10;
1:70f7692:     private int[] ddmCollectionLenStack_;
1:70f7692:     private int ddmScalarLen_; // a value of -1 -> streamed ddm -> length unknown
1:70f7692:     private final static int EMPTY_STACK = -1;
1:33776ff: 
1:70f7692:     protected boolean ensuredLengthForDecryption_ = false; // A layer lengths have already been ensured in decrypt method.
1:70f7692:     protected byte[] longBufferForDecryption_ = null;
1:70f7692:     protected int longPosForDecryption_ = 0;
1:70f7692:     protected byte[] longValueForDecryption_ = null;
1:70f7692:     protected int longCountForDecryption_ = 0;
1:33776ff: 
1:70f7692:     protected int dssLength_;
1:0326967:     private boolean dssIsContinued_;
1:70f7692:     private boolean dssIsChainedWithSameID_;
1:0326967:     private int dssCorrelationID_;
1:33776ff: 
1:70f7692:     protected int peekedLength_ = 0;
1:0326967:     private int peekedCodePoint_ = END_OF_COLLECTION; // saves the peeked codept
1:70f7692:     private int peekedNumOfExtendedLenBytes_ = 0;
1:70f7692:     private int currentPos_ = 0;
1:33776ff: 
1:0326967:     final static int END_OF_COLLECTION = -1;
1:0326967:     final static int END_OF_SAME_ID_CHAIN = -2;
1:33776ff: 
1:70f7692:     Reply(NetAgent netAgent, int bufferSize) {
1:70f7692:         buffer_ = new byte[bufferSize];
1:70f7692:         agent_ = netAgent_ = netAgent;
1:70f7692:         ddmCollectionLenStack_ = new int[Reply.MAX_MARKS_NESTING];
1:70f7692:         initialize();
160:33776ff:     }
1:33776ff: 
1:70f7692:     final void initialize() {
1:70f7692:         pos_ = 0;
1:70f7692:         count_ = 0;
1:70f7692:         topDdmCollectionStack_ = Reply.EMPTY_STACK;
1:9f5bc90:         Arrays.fill(ddmCollectionLenStack_, 0);
1:70f7692:         ddmScalarLen_ = 0;
1:70f7692:         dssLength_ = 0;
1:70f7692:         dssIsContinued_ = false;
3:33776ff:         dssIsChainedWithSameID_ = false;
1:70f7692:         dssCorrelationID_ = 1;
1:33776ff:     }
1:33776ff: 
1:70f7692:     final int getDdmLength() {
1:70f7692:         return ddmScalarLen_;
1:70f7692:     }
1:70f7692: 
1:70f7692:     // This is a helper method which shifts the buffered bytes from
1:70f7692:     // wherever they are in the current buffer to the beginning of
1:70f7692:     // different buffer (note these buffers could be the same).
1:70f7692:     // State information is updated as needed after the shift.
1:0326967:     private void shiftBuffer(byte[] destinationBuffer) {
1:70f7692:         // calculate the size of the data in the current buffer.
1:70f7692:         int sz = count_ - pos_;
1:70f7692: 
1:70f7692:         // copy this data to the new buffer starting at position 0.
1:70f7692:         System.arraycopy(buffer_, pos_, destinationBuffer, 0, sz);
1:70f7692: 
1:70f7692:         // update the state information for data in the new buffer.
1:70f7692:         pos_ = 0;
1:70f7692:         count_ = sz;
1:70f7692: 
1:70f7692:         // replace the old buffer with the new buffer.
1:70f7692:         buffer_ = destinationBuffer;
1:70f7692:     }
1:70f7692: 
1:70f7692:     // This method makes sure there is enough room in the buffer
1:70f7692:     // for a certain number of bytes.  This method will allocate
1:70f7692:     // a new buffer if needed and shift the bytes in the current buffer
1:70f7692:     // to make ensure space is available for a fill.  Right now
1:70f7692:     // this method will shift bytes as needed to make sure there is
1:70f7692:     // as much room as possible in the buffer before trying to
1:70f7692:     // do the read.  The idea is to try to have space to get as much data as possible
1:70f7692:     // if we need to do a read on the socket's stream.
1:0326967:     private void ensureSpaceInBufferForFill(int desiredSpace) {
1:70f7692:         // calculate the total unused space in the buffer.
1:70f7692:         // this includes any space at the end of the buffer and any free
1:70f7692:         // space at the beginning resulting from bytes already read.
1:70f7692:         int currentAvailableSpace = (buffer_.length - count_) + pos_;
1:70f7692: 
1:70f7692:         // check to see if there is enough free space.
1:70f7692:         if (currentAvailableSpace < desiredSpace) {
1:70f7692: 
1:70f7692:             // there is not enough free space so we need more storage.
1:70f7692:             // we are going to double the buffer unless that happens to still be too small.
1:70f7692:             // if more than double the buffer is needed, use the smallest amount over this as possible.
1:70f7692:             int doubleBufferSize = (2 * buffer_.length);
1:70f7692: 
1:70f7692:             int minumNewBufferSize = (desiredSpace - currentAvailableSpace) + buffer_.length;
1:70f7692:             int newsz = minumNewBufferSize <= doubleBufferSize ? doubleBufferSize : minumNewBufferSize;
1:70f7692: 
1:70f7692:             byte[] newBuffer = new byte[newsz];
1:70f7692: 
1:70f7692:             // shift everything from the old buffer to the new buffer
1:70f7692:             shiftBuffer(newBuffer);
1:70f7692:         } else {
1:70f7692: 
1:70f7692:             // there is enough free space in the buffer but let's make sure it is all at the end.
1:70f7692:             // this is also important because if we are going to do a read, it would be nice
1:70f7692:             // to get as much data as possible and making room at the end if the buffer helps to
1:70f7692:             // ensure this.
1:70f7692:             if (pos_ != 0) {
1:70f7692:                 shiftBuffer(buffer_);
1:70f7692:             }
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:70f7692:     // This method will attempt to read a minimum number of bytes
1:70f7692:     // from the underlying stream.  This method will keep trying to
1:70f7692:     // read bytes until it has obtained at least the minimum number.
1:70f7692:     // Now returns the total bytes read for decryption, use to return void.
1:0326967:     private int fill(int minimumBytesNeeded) throws DisconnectException {
1:70f7692:         // make sure that there is enough space in the buffer to hold
1:70f7692:         // the minimum number of bytes needed.
1:70f7692:         ensureSpaceInBufferForFill(minimumBytesNeeded);
1:70f7692: 
1:70f7692:         // read until the minimum number of bytes needed is now in the buffer.
1:70f7692:         // hopefully the read method will return as many bytes as it can.
1:70f7692:         int totalBytesRead = 0;
1:70f7692:         int actualBytesRead = 0;
1:70f7692:         do {
3:70f7692:             try {
1:70f7692:                 // oops, we shouldn't expose the agent's input stream here, collapse this into a read method on the agent
1:70f7692:                 actualBytesRead = netAgent_.getInputStream().read(buffer_, count_, buffer_.length - count_);
1:69e3d06:             } catch (IOException ioe) {
1:1b39163:                 netAgent_.throwCommunicationsFailure(ioe);
1:70f7692:             } finally {
1:70f7692:                 if (agent_.loggingEnabled()) {
1:70f7692:                     ((NetLogWriter) netAgent_.logWriter_).traceProtocolFlow(buffer_,
1:70f7692:                             count_,
1:70f7692:                             actualBytesRead,
1:70f7692:                             NetLogWriter.TYPE_TRACE_RECEIVE,
1:70f7692:                             "Reply",
1:70f7692:                             "fill",
1:70f7692:                             2); // tracepoint
1:70f7692:                 }
1:70f7692:             }
1:e0c99e5:             // DERBY-2747: only count if we actually read something
1:e0c99e5:             if (actualBytesRead > 0) {
1:e0c99e5:                 count_ += actualBytesRead;
1:e0c99e5:                 totalBytesRead += actualBytesRead;
1:e0c99e5:             }
1:70f7692: 
1:70f7692:         } while ((totalBytesRead < minimumBytesNeeded) && (actualBytesRead != -1));
1:70f7692: 
1:70f7692:         if (actualBytesRead == -1) {
1:70f7692:             if (totalBytesRead < minimumBytesNeeded) {
1:1b39163:                 netAgent_.accumulateChainBreakingReadExceptionAndThrow(
1:1b39163:                     new DisconnectException(netAgent_,
1:1b39163:                         new ClientMessageId(SQLState.NET_INSUFFICIENT_DATA),
1:66527ec:                         minimumBytesNeeded, totalBytesRead));
1:70f7692:             }
1:70f7692:         }
1:70f7692:         return totalBytesRead;
1:70f7692:     }
1:70f7692: 
1:70f7692:     // Make sure a certain amount of Layer A data is in the buffer.
1:70f7692:     // The data will be in the buffer after this method is called.
1:70f7692:     // Now returns the total bytes read for decryption, use to return void.
1:0326967:     private int ensureALayerDataInBuffer(int desiredDataSize)
1:0326967:             throws DisconnectException {
1:70f7692:         int totalBytesRead = 0;
1:70f7692:         // calulate the the number of bytes in the buffer.
1:70f7692:         int avail = count_ - pos_;
1:70f7692: 
1:70f7692:         // read more bytes off the network if the data is not in the buffer already.
1:70f7692:         if (avail < desiredDataSize) {
1:70f7692:             totalBytesRead = fill(desiredDataSize - avail);
1:70f7692:         }
1:70f7692:         return totalBytesRead;
1:70f7692:     }
1:70f7692: 
1:6a925a3:     protected final void ensureBLayerDataInBuffer(int desiredDataSize) throws DisconnectException {
1:70f7692:         if (dssIsContinued_ && (desiredDataSize > dssLength_)) {
1:70f7692:             int continueDssHeaderCount =
1:70f7692:                     (((desiredDataSize - dssLength_) / 32767) + 1);
1:70f7692:             ensureALayerDataInBuffer(desiredDataSize + (continueDssHeaderCount * 2));
1:70f7692:             compressBLayerData(continueDssHeaderCount);
1:70f7692:             return;
1:70f7692:         }
1:70f7692:         ensureALayerDataInBuffer(desiredDataSize);
1:70f7692:     }
1:70f7692: 
1:70f7692:     // this will probably never be called.
1:70f7692:     // it is included here in the highly unlikely event that a reply object
1:70f7692:     // exceeds 32K.  for opimization purposes, we should consider
1:70f7692:     // removing this.  removing this should be ok since we handle most
1:70f7692:     // big stuff returned from the server (qrydta's for example) by
1:70f7692:     // copying out the data into some other storage.  any extended dss header
1:70f7692:     // info will be removed in the copying process.
1:0326967:     private void compressBLayerData(int continueDssHeaderCount)
1:0326967:             throws DisconnectException {
1:70f7692:         int tempPos = 0;
1:70f7692: 
1:70f7692:         // jump to the last continuation header.
1:70f7692:         for (int i = 0; i < continueDssHeaderCount; i++) {
1:70f7692:             // the first may be less than the size of a full dss
1:70f7692:             if (i == 0) {
1:70f7692:                 // only jump by the number of bytes remaining in the current dss
1:70f7692:                 tempPos = pos_ + dssLength_;
1:70f7692:             } else {
1:70f7692:                 // all other jumps are for a full continued dss
1:70f7692:                 tempPos += 32767;
1:70f7692:             }
1:70f7692:         }
1:70f7692: 
1:70f7692:         // for each of the dss headers to remove,
1:70f7692:         // read out the continuation header and increment the dss length by the
1:70f7692:         // size of the conitnation bytes,  then shift the continuation data as needed.
1:70f7692:         int shiftSize = 0;
1:0326967:         int bytesToShift;
1:0326967:         int continueHeaderLength;
1:70f7692:         int newDssLength = 0;
1:70f7692:         for (int i = 0; i < continueDssHeaderCount; i++) {
1:70f7692: 
1:70f7692:             continueHeaderLength = ((buffer_[tempPos] & 0xFF) << 8) +
1:70f7692:                     ((buffer_[tempPos + 1] & 0xFF) << 0);
1:70f7692: 
1:70f7692:             if (i == 0) {
1:70f7692:                 // if this is the last one (farthest down stream and first to strip out)
1:70f7692: 
1:70f7692:                 if ((continueHeaderLength & 0x8000) == 0x8000) {
1:70f7692:                     // the last dss header is again continued
1:70f7692:                     continueHeaderLength = 32767;
1:70f7692:                     dssIsContinued_ = true;
1:70f7692:                 } else {
1:70f7692:                     // the last dss header was not contiued so update continue state flag
1:70f7692:                     dssIsContinued_ = false;
1:70f7692:                 }
1:70f7692:                 // the very first shift size is 2
1:70f7692:                 shiftSize = 2;
1:70f7692:             } else {
1:70f7692:                 // already removed the last header so make sure the chaining flag is on
1:70f7692:                 if ((continueHeaderLength & 0x8000) == 0x8000) {
1:70f7692:                     continueHeaderLength = 32767;
1:70f7692:                 } else {
1:70f7692:                     // this is a syntax error but not really certain which one.
1:70f7692:                     // for now pick 0x02 which is Dss header Length does not match the number
1:70f7692:                     // of bytes of data found.
1:70f7692:                     doSyntaxrmSemantics(CodePoint.SYNERRCD_DSS_LENGTH_BYTE_NUMBER_MISMATCH);
1:70f7692:                 }
1:70f7692:                 // increase the shift size by 2
1:70f7692:                 shiftSize += 2;
1:70f7692:             }
1:70f7692: 
1:70f7692:             // it is a syntax error if the dss continuation is less than or equal to two
1:70f7692:             if (continueHeaderLength <= 2) {
1:70f7692:                 doSyntaxrmSemantics(CodePoint.SYNERRCD_DSS_CONT_LESS_OR_EQUAL_2);
1:70f7692:             }
1:70f7692: 
1:70f7692:             newDssLength += (continueHeaderLength - 2);
1:70f7692: 
1:70f7692:             // calculate the number of bytes to shift
1:70f7692:             if (i != (continueDssHeaderCount - 1)) {
1:70f7692:                 bytesToShift = 32767;
1:70f7692:             } else {
1:70f7692:                 bytesToShift = dssLength_;
1:70f7692:             }
1:70f7692: 
1:9f5bc90:             tempPos -= (bytesToShift - 2);
1:9f5bc90:             System.arraycopy(buffer_, tempPos - shiftSize, buffer_, tempPos , bytesToShift);
1:70f7692:         }
1:70f7692:         // reposition the start of the data after the final dss shift.
1:70f7692:         pos_ = tempPos;
1:70f7692:         dssLength_ = dssLength_ + newDssLength;
1:70f7692:     }
1:70f7692: 
1:0326967:     private void readDssHeader() throws DisconnectException {
1:0326967:         int correlationID;
1:0326967:         int nextCorrelationID;
1:70f7692:         ensureALayerDataInBuffer(6);
1:70f7692: 
1:70f7692:         // read out the dss length
1:70f7692:         dssLength_ =
1:70f7692:                 ((buffer_[pos_++] & 0xFF) << 8) +
1:70f7692:                 ((buffer_[pos_++] & 0xFF) << 0);
1:70f7692: 
1:70f7692:         // Remember the old dss length for decryption only.
1:70f7692:         int oldDssLength = dssLength_;
1:70f7692: 
1:70f7692:         // check for the continuation bit and update length as needed.
1:70f7692:         if ((dssLength_ & 0x8000) == 0x8000) {
1:70f7692:             dssLength_ = 32767;
1:70f7692:             dssIsContinued_ = true;
1:70f7692:         } else {
1:70f7692:             dssIsContinued_ = false;
1:70f7692:         }
1:70f7692: 
1:70f7692:         if (dssLength_ < 6) {
1:70f7692:             doSyntaxrmSemantics(CodePoint.SYNERRCD_DSS_LESS_THAN_6);
1:70f7692:         }
1:70f7692: 
1:70f7692:         // If the GDS id is not valid, or
1:70f7692:         // if the reply is not an RPYDSS nor
1:70f7692:         // a OBJDSS, then throw an exception.
1:70f7692:         if ((buffer_[pos_++] & 0xFF) != 0xd0) {
1:70f7692:             doSyntaxrmSemantics(CodePoint.SYNERRCD_CBYTE_NOT_D0);
1:70f7692:         }
1:70f7692: 
1:70f7692:         int gdsFormatter = buffer_[pos_++] & 0xFF;
1:70f7692:         if (((gdsFormatter & 0x02) != 0x02)
1:70f7692:                 && ((gdsFormatter & 0x03) != 0x03)
1:70f7692:                 && ((gdsFormatter & 0x04) != 0x04)) {
1:70f7692:             doSyntaxrmSemantics(CodePoint.SYNERRCD_FBYTE_NOT_SUPPORTED);
1:70f7692:         }
1:70f7692: 
1:70f7692:         // Determine if the current DSS is chained with the
1:70f7692:         // next DSS, with the same or different request ID.
1:70f7692:         if ((gdsFormatter & 0x40) == 0x40) {    // on indicates structure chained to next structure
1:70f7692:             if ((gdsFormatter & 0x10) == 0x10) {
1:70f7692:                 dssIsChainedWithSameID_ = true;
1:70f7692:                 nextCorrelationID = dssCorrelationID_;
1:70f7692:             } else {
1:70f7692:                 dssIsChainedWithSameID_ = false;
1:70f7692:                 nextCorrelationID = dssCorrelationID_ + 1;
1:70f7692:             }
1:70f7692:         } else {
1:70f7692:             // chaining bit not b'1', make sure DSSFMT bit3 not b'1'
1:70f7692:             if ((gdsFormatter & 0x10) == 0x10) {  // Next DSS can not have same correlator
1:70f7692:                 doSyntaxrmSemantics(CodePoint.SYNERRCD_CHAIN_OFF_SAME_NEXT_CORRELATOR);
1:70f7692:             }
1:70f7692: 
1:70f7692:             // chaining bit not b'1', make sure no error continuation
1:70f7692:             if ((gdsFormatter & 0x20) == 0x20) { // must be 'do not continue on error'
1:70f7692:                 doSyntaxrmSemantics(CodePoint.SYNERRCD_CHAIN_OFF_ERROR_CONTINUE);
1:70f7692:             }
1:70f7692: 
1:70f7692:             dssIsChainedWithSameID_ = false;
1:70f7692:             nextCorrelationID = 1;
1:70f7692:         }
1:70f7692: 
1:70f7692:         correlationID =
1:70f7692:                 ((buffer_[pos_++] & 0xFF) << 8) +
1:70f7692:                 ((buffer_[pos_++] & 0xFF) << 0);
1:70f7692: 
1:70f7692:         // corrid must be the one expected or a -1 which gets returned in some error cases.
1:70f7692:         if ((correlationID != dssCorrelationID_) && (correlationID != 0xFFFF)) {
1:70f7692:             doSyntaxrmSemantics(CodePoint.SYNERRCD_INVALID_CORRELATOR);
1:70f7692:         } else {
1:70f7692:             dssCorrelationID_ = nextCorrelationID;
1:70f7692:         }
1:70f7692:         dssLength_ -= 6;
1:70f7692:         if ((gdsFormatter & 0x04) == 0x04) {
1:70f7692:             decryptData(gdsFormatter, oldDssLength);  //we have to decrypt data here because
1:70f7692:         }
1:70f7692:         //we need the decrypted codepoint. If
1:70f7692:         //Data is very long > 32767, we have to
1:70f7692:         //get all the data first because decrypt
1:70f7692:         //piece by piece doesn't work.
1:70f7692:     }
1:33776ff: 
1:33776ff: 
1:0326967:     private void decryptData(int gdsFormatter, int oldDssLength)
1:0326967:             throws DisconnectException {
3:33776ff:         boolean readHeader;
1:70f7692: 
1:70f7692:         if (dssLength_ == 32761) {
1:70f7692:             ByteArrayOutputStream baos;
1:70f7692:             int copySize = 0;
1:70f7692: 
1:70f7692:             baos = new ByteArrayOutputStream();
1:70f7692: 
1:70f7692:             // set the amount to read for the first segment
1:70f7692:             copySize = dssLength_; // note: has already been adjusted for headers
1:70f7692: 
1:70f7692:             do {
1:70f7692:                 // determine if a continuation header needs to be read after the data
1:70f7692:                 if (dssIsContinued_) {
1:70f7692:                     readHeader = true;
1:70f7692:                 } else {
1:70f7692:                     readHeader = false;
1:70f7692:                 }
1:70f7692: 
1:70f7692:                 // read the segment
1:70f7692:                 ensureALayerDataInBuffer(copySize);
1:70f7692:                 adjustLengths(copySize);
1:70f7692:                 baos.write(buffer_, pos_, copySize);
1:70f7692:                 pos_ += copySize;
1:70f7692: 
1:70f7692:                 // read the continuation header, if necessary
1:70f7692:                 if (readHeader) {
1:70f7692:                     readDSSContinuationHeader();
1:70f7692:                 }
1:70f7692: 
1:70f7692:                 copySize = dssLength_;
1:70f7692:             } while (readHeader == true);
1:70f7692:             byte[] cipherBytes = baos.toByteArray();
1:70f7692:             byte[] clearedByte = null;
1:70f7692:             try {
1:70f7692:                 clearedByte = netAgent_.netConnection_.getEncryptionManager().decryptData(cipherBytes,
1:70f7692:                         NetConfiguration.SECMEC_EUSRIDPWD,
1:70f7692:                         netAgent_.netConnection_.getTargetPublicKey(),
1:70f7692:                         netAgent_.netConnection_.getTargetPublicKey());
1:70f7692:             } catch (SqlException e) {
1:70f7692:                 //throw new SqlException (agent_.logWriter_, "error in decrypting data");
1:70f7692:             }
1:70f7692: 
1:70f7692:             //The decrypted data is for one codepoint only. We need to save the data follows this codepoint
1:70f7692:             longBufferForDecryption_ = new byte[buffer_.length - pos_];
1:70f7692:             longPosForDecryption_ = 0;
1:70f7692:             count_ = count_ - pos_;
1:70f7692:             longCountForDecryption_ = count_;
1:70f7692:             System.arraycopy(buffer_, pos_, longBufferForDecryption_, 0, buffer_.length - pos_);
1:70f7692: 
1:70f7692:             //copy the clear data to buffer_
1:70f7692:             if (clearedByte.length >= 32767) {
1:70f7692:                 System.arraycopy(clearedByte, 0, buffer_, 0, 32767);
1:70f7692:             } else {
1:70f7692:                 System.arraycopy(clearedByte, 0, buffer_, 0, clearedByte.length);
1:70f7692:             }
1:70f7692: 
1:70f7692:             pos_ = 0;
1:70f7692:             dssLength_ = buffer_.length;
1:70f7692: 
1:70f7692:             int lobLength = 0;
1:70f7692:             if (clearedByte.length > 32767) {  //for extended length, length is the 4 bytes that follow codepoint
1:70f7692:                 lobLength = ((clearedByte[4] & 0xFF) << 24) +
1:70f7692:                         ((clearedByte[5] & 0xFF) << 16) +
1:70f7692:                         ((clearedByte[6] & 0xFF) << 8) +
1:70f7692:                         ((clearedByte[7] & 0xFF) << 0);
1:70f7692:                 longValueForDecryption_ = new byte[lobLength];
1:70f7692:                 System.arraycopy(clearedByte, 8, longValueForDecryption_, 0, clearedByte.length - 8);
1:70f7692:             } else {
1:70f7692:                 lobLength = ((clearedByte[0] & 0xFF) << 8) +
2:70f7692:                         ((clearedByte[1] & 0xFF) << 0);
1:70f7692:                 longValueForDecryption_ = new byte[lobLength - 4];
1:70f7692:                 System.arraycopy(clearedByte, 4, longValueForDecryption_, 0, clearedByte.length - 4);
1:70f7692:             }
1:70f7692:         } else {
1:70f7692:             int bytesRead = ensureALayerDataInBuffer(dssLength_);  //we need to get back all the data here, and then decrypt
1:70f7692:             if (bytesRead > 0) //we ensuredALayerDAtaInBuffer here and set the flag to true, so we don't need do this again later
1:70f7692:             {
1:70f7692:                 ensuredLengthForDecryption_ = true;
1:70f7692:             }
1:70f7692:             byte[] encryptedByte = new byte[dssLength_];
1:70f7692:             System.arraycopy(buffer_, pos_, encryptedByte, 0, dssLength_);
1:70f7692:             byte[] array1 = new byte[pos_];
1:70f7692:             System.arraycopy(buffer_, 0, array1, 0, pos_);  //save the data before encrypted data in array1
1:70f7692:             byte[] array3 = new byte[buffer_.length - dssLength_ - pos_];
1:70f7692:             System.arraycopy(buffer_, pos_ + dssLength_, array3, 0, buffer_.length - dssLength_ - pos_); //save the data follows encrypted data in array3
1:70f7692:             byte[] clearedByte = null;
1:70f7692:             try {
1:70f7692:                 clearedByte = netAgent_.netConnection_.getEncryptionManager().decryptData(encryptedByte,
1:70f7692:                         NetConfiguration.SECMEC_EUSRIDPWD,
1:70f7692:                         netAgent_.netConnection_.getTargetPublicKey(),
1:70f7692:                         netAgent_.netConnection_.getTargetPublicKey());
1:70f7692:             } catch (SqlException e) {
1:70f7692:                 //throw new SqlException (agent_.logWriter_, "error in decrypting data");
1:70f7692:             }
1:70f7692:             dssLength_ -= (encryptedByte.length - clearedByte.length);
1:70f7692:             byte[] buffer = new byte[array1.length + clearedByte.length + array3.length];
1:70f7692:             System.arraycopy(array1, 0, buffer, 0, array1.length);
1:70f7692:             System.arraycopy(clearedByte, 0, buffer, array1.length, clearedByte.length);
1:70f7692:             System.arraycopy(array3, 0, buffer, array1.length + clearedByte.length, array3.length);
1:70f7692:             buffer_ = buffer;
1:70f7692:             int oldCount = count_;
1:70f7692:             count_ = count_ - (encryptedByte.length - clearedByte.length);
1:70f7692:             if (((clearedByte[2] & 0xff) << 8) + ((clearedByte[3] & 0xff) << 0) == 0x146c) {
1:70f7692: 
1:70f7692:                 boolean flag = false;
1:70f7692:                 if (gdsFormatter == 0x54) {
1:70f7692:                     flag = true;
1:70f7692:                 }
1:70f7692:                 if (flag) {
1:c7a1d17:                     int firstLobLength = ((clearedByte[0] & 0xFF) << 8) +
1:c7a1d17:                         ((clearedByte[1] & 0xFF) << 0);
1:70f7692:                     if (oldCount - oldDssLength < 6) {
1:70f7692:                         int totalBytesRead = fill(6); //sometimes the 2nd EXTDTA doesn't come back, need to fetch again to get it
1:70f7692:                         if (totalBytesRead > 0) {
1:70f7692:                             longBufferForDecryption_ = new byte[totalBytesRead];
1:70f7692:                             longPosForDecryption_ = 0;
1:70f7692:                             System.arraycopy(buffer_, pos_ + firstLobLength, longBufferForDecryption_, 0,
1:70f7692:                                     totalBytesRead);
1:70f7692:                         }
1:70f7692: 
1:70f7692:                     } else {
1:70f7692:                         longBufferForDecryption_ = new byte[count_ - pos_ - firstLobLength];
1:70f7692:                         longPosForDecryption_ = 0;
1:70f7692:                         System.arraycopy(buffer_, pos_ + firstLobLength, longBufferForDecryption_, 0,
1:70f7692:                                 longBufferForDecryption_.length);
1:70f7692: 
1:70f7692:                     }
1:70f7692:                 } //end if(flag)
1:70f7692:                 int lobLength = ((clearedByte[0] & 0xFF) << 8) +
1:70f7692:                         ((clearedByte[1] & 0xFF) << 0) - 4;
1:70f7692: 
1:70f7692:                 longValueForDecryption_ = new byte[lobLength];
1:70f7692: 
1:70f7692:                 System.arraycopy(clearedByte, 4, longValueForDecryption_, 0, clearedByte.length - 4);  //copy the decrypted lob value (excluded length an dcodepoint) to longValue_
1:70f7692:             } else if (((clearedByte[2] & 0xff) << 8) + ((clearedByte[3] & 0xff) << 0) == 0x241B) {
1:70f7692:                 int length = ((clearedByte[0] & 0xFF) << 8) +
1:70f7692:                         ((clearedByte[1] & 0xFF) << 0);
1:70f7692:                 boolean noData = false;
1:70f7692:                 if (clearedByte[4] == -1 && clearedByte[5] == -1) {
1:70f7692:                     noData = true; //there is no data, no need to do the copy
1:70f7692:                 }
1:70f7692:                 if (!noData) {
1:70f7692:                     if (length == 32776) {
1:70f7692:                         length = ((clearedByte[4] & 0xFF) << 24) +
1:70f7692:                                 ((clearedByte[5] & 0xFF) << 16) +
1:70f7692:                                 ((clearedByte[6] & 0xFF) << 8) +
1:70f7692:                                 ((clearedByte[7] & 0xFF) << 0);
1:70f7692:                         longValueForDecryption_ = new byte[length];
1:70f7692:                         System.arraycopy(clearedByte, 8, longValueForDecryption_, 0,
1:70f7692:                                 clearedByte.length - 8);
1:70f7692:                         longCountForDecryption_ = count_ - (pos_ + length + 8);
1:70f7692:                         longBufferForDecryption_ = new byte[buffer_.length - pos_ - length - 8];
1:70f7692:                         System.arraycopy(buffer_, pos_ + length + 8, longBufferForDecryption_, 0,
1:70f7692:                                 longBufferForDecryption_.length);
1:70f7692: 
1:70f7692:                     } else {
1:70f7692:                         longPosForDecryption_ = 0;
1:70f7692:                         longCountForDecryption_ = count_ - (pos_ + length);
1:70f7692:                         longBufferForDecryption_ = new byte[buffer_.length - pos_ - length];
1:70f7692:                         System.arraycopy(buffer_, pos_ + length, longBufferForDecryption_, 0,
1:70f7692:                                 longBufferForDecryption_.length);
1:70f7692: 
1:70f7692:                         longValueForDecryption_ = new byte[length - 4];
1:70f7692: 
1:70f7692:                         System.arraycopy(clearedByte, 4, longValueForDecryption_, 0,
1:70f7692:                                 clearedByte.length - 4);
1:70f7692:                     }
1:70f7692:                 }
1:70f7692:             }
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:70f7692: 
1:6a925a3:     final int readUnsignedShort() throws DisconnectException {
2:70f7692:         // should we be checking dss lengths and ddmScalarLengths here
1:70f7692:         // if yes, i am not sure this is the correct place if we should be checking
3:70f7692:         ensureBLayerDataInBuffer(2);
2:70f7692:         adjustLengths(2);
1:70f7692:         return ((buffer_[pos_++] & 0xff) << 8) +
1:70f7692:                 ((buffer_[pos_++] & 0xff) << 0);
1:70f7692:     }
1:70f7692: 
1:6a925a3:     final short readShort() throws DisconnectException {
1:70f7692:         // should we be checking dss lengths and ddmScalarLengths here
1:70f7692:         ensureBLayerDataInBuffer(2);
1:70f7692:         adjustLengths(2);
1:70f7692:         short s = SignedBinary.getShort(buffer_, pos_);
1:70f7692: 
1:70f7692:         pos_ += 2;
1:70f7692: 
1:70f7692:         return s;
1:70f7692:     }
1:70f7692: 
1:6a925a3:     final int readInt() throws DisconnectException {
1:70f7692:         // should we be checking dss lengths and ddmScalarLengths here
1:70f7692:         ensureBLayerDataInBuffer(4);
1:70f7692:         adjustLengths(4);
1:70f7692:         int i = SignedBinary.getInt(buffer_, pos_);
2:70f7692:         pos_ += 4;
1:70f7692: 
1:70f7692:         return i;
1:70f7692:     }
1:70f7692: 
1:6a925a3:     final int[] readUnsignedShortList() throws DisconnectException {
1:70f7692:         int len = ddmScalarLen_;
2:70f7692:         ensureBLayerDataInBuffer(len);
1:70f7692:         adjustLengths(len);
1:70f7692: 
1:70f7692:         int count = len / 2;
1:70f7692:         int[] list = new int[count];
1:70f7692: 
1:70f7692:         for (int i = 0; i < count; i++) {
1:70f7692:             list[i] = ((buffer_[pos_++] & 0xff) << 8) +
1:70f7692:                     ((buffer_[pos_++] & 0xff) << 0);
1:70f7692:         }
1:70f7692: 
1:70f7692:         return list;
1:70f7692:     }
1:70f7692: 
1:6a925a3:     final int readUnsignedByte() throws DisconnectException {
2:70f7692:         ensureBLayerDataInBuffer(1);
2:70f7692:         adjustLengths(1);
1:70f7692:         return (buffer_[pos_++] & 0xff);
1:70f7692:     }
1:70f7692: 
1:6a925a3:     final byte readByte() throws DisconnectException {
1:70f7692:         ensureBLayerDataInBuffer(1);
1:70f7692:         adjustLengths(1);
1:70f7692:         return (byte) (buffer_[pos_++] & 0xff);
1:70f7692:     }
1:70f7692: 
1:a0b8943:     final String readString(int length, Charset encoding)
1:a0b8943:             throws DisconnectException {
2:70f7692:         ensureBLayerDataInBuffer(length);
2:70f7692:         adjustLengths(length);
1:a0b8943:         String s = new String(buffer_, pos_, length, encoding);
2:70f7692:         pos_ += length;
1:70f7692:         return s;
1:70f7692:     }
1:70f7692: 
1:6a925a3:     final String readString() throws DisconnectException {
1:70f7692:         int len = ddmScalarLen_;
1:70f7692:         ensureBLayerDataInBuffer(len);
1:70f7692:         adjustLengths(len);
1:1451af7:         String result = netAgent_.getCurrentCcsidManager()
1:1451af7:                             .convertToJavaString(buffer_, pos_, len);
2:70f7692:         pos_ += len;
2:70f7692:         return result;
1:70f7692:     }
1:70f7692: 
1:6a925a3:     final byte[] readBytes(int length) throws DisconnectException {
1:70f7692:         ensureBLayerDataInBuffer(length);
1:70f7692:         adjustLengths(length);
1:70f7692: 
1:70f7692:         byte[] b = new byte[length];
1:70f7692:         System.arraycopy(buffer_, pos_, b, 0, length);
1:70f7692:         pos_ += length;
2:70f7692:         return b;
1:70f7692:     }
1:70f7692: 
1:6a925a3:     final byte[] readBytes() throws DisconnectException {
1:70f7692:         int len = ddmScalarLen_;
1:70f7692:         ensureBLayerDataInBuffer(len);
1:70f7692:         adjustLengths(len);
1:70f7692: 
2:70f7692:         byte[] b = new byte[len];
2:70f7692:         System.arraycopy(buffer_, pos_, b, 0, len);
1:70f7692:         pos_ += len;
1:70f7692:         return b;
1:70f7692:     }
1:70f7692: 
1:6a925a3:     final void skipBytes(int length) throws DisconnectException {
1:70f7692:         ensureBLayerDataInBuffer(length);
1:70f7692:         adjustLengths(length);
1:70f7692:         pos_ += length;
1:70f7692:     }
1:70f7692: 
1:6a925a3:     final void skipBytes() throws DisconnectException {
1:70f7692:         int len = ddmScalarLen_;
1:70f7692:         ensureBLayerDataInBuffer(len);
1:70f7692:         adjustLengths(len);
1:70f7692:         pos_ += len;
1:70f7692:     }
1:70f7692: 
1:70f7692:     // This will be the new and improved getData that handles all QRYDTA/EXTDTA
1:70f7692:     // Returns the stream so that the caller can cache it
1:6a925a3:     final ByteArrayOutputStream getData(ByteArrayOutputStream existingBuffer) throws DisconnectException {
1:70f7692:         boolean readHeader;
1:70f7692:         int copySize;
1:70f7692:         ByteArrayOutputStream baos;
1:70f7692: 
1:70f7692:         // note: an empty baos can yield an allocated and empty byte[]
1:70f7692:         if (existingBuffer != null) {
1:70f7692:             baos = existingBuffer;
1:70f7692:         } else {
1:70f7692:             if (ddmScalarLen_ != -1) {
1:70f7692:                 // allocate a stream based on a known amount of data
1:70f7692:                 baos = new ByteArrayOutputStream(ddmScalarLen_);
1:70f7692:             } else {
1:70f7692:                 // allocate a stream to hold an unknown amount of data
1:70f7692:                 baos = new ByteArrayOutputStream();
1:70f7692:                 //isLengthAndNullabilityUnknown = true;
1:70f7692:             }
1:70f7692:         }
1:70f7692: 
1:70f7692:         // set the amount to read for the first segment
1:70f7692:         copySize = dssLength_; // note: has already been adjusted for headers
1:70f7692: 
1:70f7692:         do {
3:33776ff:             // determine if a continuation header needs to be read after the data
1:70f7692:             if (dssIsContinued_) {
1:70f7692:                 readHeader = true;
1:70f7692:             } else {
1:70f7692:                 readHeader = false;
1:70f7692:             }
1:70f7692: 
3:33776ff:             // read the segment
1:70f7692:             ensureALayerDataInBuffer(copySize);
1:70f7692:             adjustLengths(copySize);
1:70f7692:             baos.write(buffer_, pos_, copySize);
3:33776ff:             pos_ += copySize;
1:70f7692: 
3:33776ff:             // read the continuation header, if necessary
1:70f7692:             if (readHeader) {
1:70f7692:                 readDSSContinuationHeader();
1:70f7692:             }
1:70f7692: 
3:33776ff:             copySize = dssLength_;
1:70f7692:         } while (readHeader == true);
1:70f7692: 
1:70f7692:         return baos;
1:70f7692:     }
1:70f7692: 
1:70f7692:     // reads a DSS continuation header
1:70f7692:     // prereq: pos_ is positioned on the first byte of the two-byte header
1:70f7692:     // post:   dssIsContinued_ is set to true if the continuation bit is on, false otherwise
1:70f7692:     //         dssLength_ is set to DssConstants.MAX_DSS_LEN - 2 (don't count the header for the next read)
1:70f7692:     // helper method for getEXTDTAData
1:0326967:     private void readDSSContinuationHeader() throws DisconnectException {
1:70f7692:         ensureALayerDataInBuffer(2);
1:70f7692: 
1:70f7692:         dssLength_ =
1:70f7692:                 ((buffer_[pos_++] & 0xFF) << 8) +
1:70f7692:                 ((buffer_[pos_++] & 0xFF) << 0);
1:70f7692: 
1:70f7692:         if ((dssLength_ & 0x8000) == 0x8000) {
1:70f7692:             dssLength_ = DssConstants.MAX_DSS_LEN;
1:70f7692:             dssIsContinued_ = true;
1:70f7692:         } else {
1:70f7692:             dssIsContinued_ = false;
1:70f7692:         }
1:70f7692:         // it is a syntax error if the dss continuation header length
1:70f7692:         // is less than or equal to two
1:70f7692:         if (dssLength_ <= 2) {
1:70f7692:             doSyntaxrmSemantics(CodePoint.SYNERRCD_DSS_CONT_LESS_OR_EQUAL_2);
1:70f7692:         }
1:70f7692: 
1:70f7692:         dssLength_ -= 2;  // avoid consuming the DSS cont header
1:70f7692:     }
1:70f7692: 
1:70f7692: 
1:70f7692:     // As part of parsing the reply, the client can detect that the
1:70f7692:     // data sent from the target agent does not structurally
1:70f7692:     // conform to the requirements of the DDM architecture.  These are
1:70f7692:     // the same checks performed by the target server on the messages
1:70f7692:     // it receives from the protocolj code.  Server side detected errors
1:70f7692:     // result in a SYNTAXRM being returned from the AS.  According to the
1:70f7692:     // DDM manual, parsing of the DSS is terminated when the error is
1:70f7692:     // detected.  The Syntax Error Code, SYNERRCD, describes the various errors.
1:70f7692:     //
1:70f7692:     // Note: Not all of these may be valid at the client.  See descriptions for
1:70f7692:     // which ones make sense for client side errors/checks.
1:70f7692:     // Syntax Error Code                  Description of Error
1:70f7692:     // -----------------                  --------------------
1:70f7692:     // 0x01                               Dss header Length is less than 6.
1:70f7692:     // 0x02                               Dss header Length does not match the
1:70f7692:     //                                    number of bytes of data found.
1:70f7692:     // 0x03                               Dss header C-byte not D0.
1:70f7692:     // 0x04                               Dss header f-bytes either not
1:70f7692:     //                                    recognized or not supported.
1:70f7692:     // 0x05                               DSS continuation specified but not found.
1:70f7692:     //                                    For example, DSS continuation is specified
1:70f7692:     //                                    on the last DSS, and the SNA LU 6.2 communication
1:70f7692:     //                                    facility returned the SEND indicator.
1:70f7692:     // 0x06                               DSS chaining specified but no DSS found.
1:70f7692:     //                                    For example, DSS chaining is specified
1:70f7692:     //                                    on the last DSS, and the SNA LU 6.2 communication
1:70f7692:     //                                    facility returned the SEND indicator.
1:70f7692:     // 0x07                               Object length less than four.  For example,
1:70f7692:     //                                    a command parameter's length is specified
1:70f7692:     //                                    as two, or a command's length is specified as three.
1:70f7692:     // 0x08                               Object length does not match the number of bytes of data
1:70f7692:     //                                    found.  For example, a RQSDSS with a length of 150
1:70f7692:     //                                    contains a command whose length is 125 or a SRVDGN parameter
1:70f7692:     //                                    specifies a length of 200 but there are only 50
1:70f7692:     //                                    bytes left in the DSS.
1:70f7692:     // 0x09                               Object length greater than maximum allowed.
1:70f7692:     //                                    For example, a RECCNT parameter specifies a
1:70f7692:     //                                    length of ten, but the parameter is defined
1:70f7692:     //                                    to have a maximum length of eight.
1:70f7692:     // 0x0A                               Object length less than the minimum required.
1:70f7692:     //                                    For example, a SVRCOD parameter specifies a
1:70f7692:     //                                    length of five, but the parameter is defined
1:70f7692:     //                                    to have a fixed length of six.
1:70f7692:     // 0x0B                               Object length not allowed.  For example,
1:70f7692:     //                                    a FILEXDPT parameter is specified with a length of
1:70f7692:     //                                    11, but this would indicate that only half of the hours
1:70f7692:     //                                    field is present instead of the complete hours field.
1:70f7692:     // 0x0C                               Incorrect large object extended length field (see
1:70f7692:     //                                    description of DSS).  For example, an extended
1:70f7692:     //                                    length field is present, but it is only three bytes
1:70f7692:     //                                    long when it is defined to be a multiple of two bytes.
1:70f7692:     // 0x0D                               Object code point index not supported.
1:70f7692:     //                                    For example, a code point of 8032 is encountered
1:70f7692:     //                                    but x'8' is a reserved code point index.
1:70f7692:     // 0x0E                               Required object not found.  For example, a CLEAR
1:70f7692:     //                                    command does not have a filnam parameter present,
1:70f7692:     //                                    or a MODREC command is not followed by a RECORD
1:70f7692:     //                                    command data object.
1:70f7692:     // 0x0F                               Too many command data objects sent.  For example,
1:70f7692:     //                                    a MODREC command is followed by two RECORD command
1:70f7692:     //                                    command data objects, or a DECREC command is followed
1:70f7692:     //                                    by RECORD object.
1:70f7692:     // 0x10                               Mutually exclusive objects present.
1:70f7692:     //                                    For example, a CRTDIRF command specifies both
1:70f7692:     //                                    a DCLNAM and FILNAM parameters.
1:70f7692:     // 0x11                               Too few command data objects sent.
1:70f7692:     //                                    For example, an INSRECEF command that
1:70f7692:     //                                    specified RECCNT95) is followed by only
1:70f7692:     //                                    4 RECORD command data objects.
1:70f7692:     // 0x12                               Duplicate object present.
1:70f7692:     //                                    For example, a LSTFAT command has tow FILNAM
1:70f7692:     //                                    parameters specified.
1:70f7692:     // 0x13                               Invalid request correlator specified.
1:70f7692:     //                                    Use PRCCNVRM with PRCCNVDC of 04 or 05 instead
1:70f7692:     //                                    of this error code.  This error code is being retained
1:70f7692:     //                                    for compatibility with Level 1 of the architecture.
1:70f7692:     // 0x14                               Required value not found.
1:70f7692:     // 0x15                               Reserved value not allowed.  For example,
1:70f7692:     //                                    a INSRECEF command specified a RECCNT(0) parameter.
1:70f7692:     // 0x16                               DSS continuation less than or equal to two.
1:70f7692:     //                                    For example, the length bytes of the DSS continuation
1:70f7692:     //                                    have the value of one.
1:70f7692:     // 0x17                               Objects not in required order.  For example, a RECAL
1:70f7692:     //                                    object contains a RECORD object followed by a RECNBR
1:70f7692:     //                                    object with is not in the defined order.
1:70f7692:     // 0x18                               DSS chaining byt not b'1', but DSSFMT bit3 set to b'1'.
1:70f7692:     // 0x19                               Previous DSS indicated current DSS has the same
1:70f7692:     //                                    request correlator, but the request correlators are
1:70f7692:     //                                    not the same.
1:70f7692:     // 0x1A                               DSS cahining bit not b'1', but error continuation requested.
1:70f7692:     // 0x1B                               Mutually exclusive parameter values not specified.
1:70f7692:     //                                    For example, an OPEN command specified PRPSHD(TRUE)
1:70f7692:     //                                    and FILSHR(READER).
1:70f7692:     // 0x1D                               Code point not valid command.  For example, the first
1:70f7692:     //                                    code point in RQSDSS either is not in the dictionary
1:70f7692:     //                                    or is not a code point for a command.
1:70f7692:     //
1:70f7692:     // When the client detects these errors, it will be handled as if a SYNTAXRM is returned
1:70f7692:     // from the server.  In this SYNTAXRM case, PROTOCOL architects an SQLSTATE of 58008 or 58009.
1:70f7692:     //
1:70f7692:     // Messages
1:70f7692:     // SQLSTATE : 58009
1:70f7692:     //     Execution failed due to a distribution protocol error that caused deallocation of the conversation.
1:70f7692:     //     SQLCODE : -30020
1:70f7692:     //     Execution failed because of a Distributed Protocol
1:70f7692:     //         Error that will affect the successful execution of subsequent
1:70f7692:     //         commands and SQL statements: Reason Code <reason-code>.
1:70f7692:     //      Some possible reason codes include:
1:70f7692:     //      121C Indicates that the user is not authorized to perform the requested command.
1:70f7692:     //      1232 The command could not be completed because of a permanent error.
1:70f7692:     //          In most cases, the server will be in the process of an abend.
1:70f7692:     //      220A The target server has received an invalid data description.
1:70f7692:     //          If a user SQLDA is specified, ensure that the fields are
1:70f7692:     //          initialized correctly. Also, ensure that the length does not
1:70f7692:     //          exceed the maximum allowed length for the data type being used.
1:70f7692:     //
1:70f7692:     //      The command or statement cannot be processed.  The current
1:70f7692:     //          transaction is rolled back and the application is disconnected
1:70f7692:     //          from the remote database.
1:6a925a3:     final void doSyntaxrmSemantics(int syntaxErrorCode) throws DisconnectException {
1:6384512:         DisconnectException e = new DisconnectException(agent_,
1:6a925a3:                 new ClientMessageId(SQLState.DRDA_CONNECTION_TERMINATED),
1:6a925a3:                 SqlException.getMessageUtil().getTextMessage(
1:6a925a3:                     MessageId.CONN_DRDA_DATASTREAM_SYNTAX_ERROR,
1:66527ec:                     syntaxErrorCode));
1:6384512:             
1:6384512:         // if we are communicating to an older server, we may get a SYNTAXRM on
1:6384512:         // ACCSEC (missing codepoint RDBNAM) if we were unable to convert to
1:6384512:         // EBCDIC (See DERBY-4008/DERBY-4004).  In that case we should chain 
1:6384512:         // the original conversion exception, so it is clear to the user what
1:6384512:         // the problem was.
1:6384512:         if (netAgent_.exceptionConvertingRdbnam != null) {
1:6384512:             e.setNextException(netAgent_.exceptionConvertingRdbnam);
1:6384512:             netAgent_.exceptionConvertingRdbnam = null;
1:6384512:         }
1:6384512:         agent_.accumulateChainBreakingReadExceptionAndThrow(e);
1:70f7692:     }
1:70f7692: 
1:70f7692: 
1:33776ff: // the names of these methods start with a letter z.
1:33776ff: // the z will be removed when they are finalized...
1:33776ff: 
1:70f7692:     protected final void pushLengthOnCollectionStack() {
1:70f7692:         ddmCollectionLenStack_[++topDdmCollectionStack_] = ddmScalarLen_;
1:70f7692:         ddmScalarLen_ = 0;
1:70f7692:     }
1:33776ff: 
1:70f7692:     protected final void adjustLengths(int length) {
1:70f7692:         ddmScalarLen_ -= length;
1:70f7692:         adjustCollectionAndDssLengths(length);
1:70f7692:         /*
1:70f7692:         for (int i = 0; i <= topDdmCollectionStack_; i++) {
1:70f7692:           ddmCollectionLenStack_[i] -= length;
1:70f7692:         }
1:70f7692:         dssLength_ -= length;
1:70f7692:         */
1:70f7692:     }
1:33776ff: 
1:70f7692:     protected int adjustDdmLength(int ddmLength, int length) {
1:70f7692:         ddmLength -= length;
1:70f7692:         if (ddmLength == 0) {
1:70f7692:             adjustLengths(getDdmLength());
1:70f7692:         }
1:70f7692:         return ddmLength;
1:70f7692:     }
1:33776ff: 
1:70f7692:     // Pop the collection Length stack.
1:70f7692:     // pre:  The collection length stack must not be empty and the top value
1:70f7692:     //       on the stack must be 0.
1:70f7692:     // post: The top 0 value on the stack will be popped.
1:70f7692:     protected final void popCollectionStack() {
1:70f7692:         topDdmCollectionStack_--;
1:70f7692:     }
1:33776ff: 
1:6a925a3:     protected final int peekCodePoint() throws DisconnectException {
1:70f7692:         if (topDdmCollectionStack_ != EMPTY_STACK) {
1:70f7692:             if (ddmCollectionLenStack_[topDdmCollectionStack_] == 0) {
1:70f7692:                 return END_OF_COLLECTION;
1:70f7692:             } else if (ddmCollectionLenStack_[topDdmCollectionStack_] < 4) {
1:70f7692:                 // error
1:70f7692:             }
1:70f7692:         }
1:70f7692: 
1:70f7692:         // if there is no more data in the current dss, and the dss is not
1:70f7692:         // continued, indicate the end of the same Id chain or read the next dss header.
1:70f7692:         if ((dssLength_ == 0) && (!dssIsContinued_)) {
1:70f7692:             if (!dssIsChainedWithSameID_) {
1:70f7692:                 return END_OF_SAME_ID_CHAIN;
1:70f7692:             }
1:70f7692:             readDssHeader();
1:70f7692:         }
1:70f7692: 
1:70f7692:         if (longBufferForDecryption_ == null)  //we don't need to do this if it's data stream encryption
1:70f7692:         {
1:70f7692:             ensureBLayerDataInBuffer(4);
1:70f7692:         }
1:70f7692:         peekedLength_ = ((buffer_[pos_] & 0xff) << 8) + ((buffer_[pos_ + 1] & 0xff) << 0);
1:70f7692:         peekedCodePoint_ = ((buffer_[pos_ + 2] & 0xff) << 8) + ((buffer_[pos_ + 3] & 0xff) << 0);
1:70f7692: 
1:70f7692:         // check for extended length
1:70f7692:         if ((peekedLength_ & 0x8000) == 0x8000) {
1:70f7692:             peekExtendedLength();
1:70f7692:         } else {
1:70f7692:             peekedNumOfExtendedLenBytes_ = 0;
1:70f7692:         }
1:70f7692:         return peekedCodePoint_;
1:33776ff:     }
1:33776ff: 
1:70f7692:     // Read "length" number of bytes from the buffer into the byte array b starting from offset
1:70f7692:     // "offset".  The current offset in the buffer does not change.
1:6a925a3:     protected final int peekFastBytes(byte[] b, int offset, int length) throws DisconnectException {
1:70f7692:         for (int i = 0; i < length; i++) {
1:70f7692:             b[offset + i] = buffer_[pos_ + i];
1:70f7692:         }
1:70f7692:         return offset + length;
1:33776ff:     }
1:33776ff: 
1:6a925a3:     protected final void parseLengthAndMatchCodePoint(int expectedCodePoint) throws DisconnectException {
1:70f7692:         int actualCodePoint = 0;
1:70f7692:         if (peekedCodePoint_ == END_OF_COLLECTION) {
1:70f7692:             actualCodePoint = readLengthAndCodePoint();
1:70f7692:         } else {
1:70f7692:             actualCodePoint = peekedCodePoint_;
1:70f7692:             pos_ += (4 + peekedNumOfExtendedLenBytes_);
1:70f7692:             ddmScalarLen_ = peekedLength_;
1:70f7692:             if (peekedNumOfExtendedLenBytes_ == 0 && ddmScalarLen_ != -1) {
1:70f7692:                 adjustLengths(4);
1:70f7692:             } else {
1:70f7692:                 adjustCollectionAndDssLengths(4 + peekedNumOfExtendedLenBytes_);
1:70f7692:             }
1:70f7692:             peekedLength_ = 0;
1:70f7692:             peekedCodePoint_ = END_OF_COLLECTION;
1:70f7692:             peekedNumOfExtendedLenBytes_ = 0;
1:70f7692:         }
1:33776ff: 
1:70f7692:         if (actualCodePoint != expectedCodePoint) {
1:6a925a3:             agent_.accumulateChainBreakingReadExceptionAndThrow(
1:6a925a3:                 new DisconnectException(agent_, 
1:6a925a3:                     new ClientMessageId(SQLState.NET_NOT_EXPECTED_CODEPOINT), 
1:66527ec:                     actualCodePoint, expectedCodePoint));
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:0326967:     private int readLengthAndCodePoint() throws DisconnectException {
1:70f7692:         if (topDdmCollectionStack_ != EMPTY_STACK) {
1:70f7692:             if (ddmCollectionLenStack_[topDdmCollectionStack_] == 0) {
1:70f7692:                 return END_OF_COLLECTION;
1:70f7692:             } else if (ddmCollectionLenStack_[topDdmCollectionStack_] < 4) {
1:6a925a3:                 agent_.accumulateChainBreakingReadExceptionAndThrow(
1:6a925a3:                     new DisconnectException(agent_, 
1:6a925a3:                     new ClientMessageId(SQLState.NET_DDM_COLLECTION_TOO_SMALL)));
1:70f7692:             }
1:70f7692:         }
1:70f7692: 
1:70f7692:         // if there is no more data in the current dss, and the dss is not
1:70f7692:         // continued, indicate the end of the same Id chain or read the next dss header.
1:70f7692:         if ((dssLength_ == 0) && (!dssIsContinued_)) {
1:70f7692:             if (!dssIsChainedWithSameID_) {
1:70f7692:                 return END_OF_SAME_ID_CHAIN;
1:70f7692:             }
1:70f7692:             readDssHeader();
1:33776ff:         }
1:70f7692: 
1:70f7692:         ensureBLayerDataInBuffer(4);
1:70f7692:         ddmScalarLen_ =
1:70f7692:                 ((buffer_[pos_++] & 0xff) << 8) +
1:70f7692:                 ((buffer_[pos_++] & 0xff) << 0);
1:70f7692:         int codePoint = ((buffer_[pos_++] & 0xff) << 8) +
1:70f7692:                 ((buffer_[pos_++] & 0xff) << 0);
1:70f7692:         adjustLengths(4);
1:70f7692: 
1:70f7692:         // check for extended length
1:70f7692:         if ((ddmScalarLen_ & 0x8000) == 0x8000) {
1:70f7692:             readExtendedLength();
1:70f7692:         }
1:70f7692:         return codePoint;
1:70f7692:     }
1:70f7692: 
1:0326967:     private void readExtendedLength() throws DisconnectException {
1:70f7692:         int numberOfExtendedLenBytes = (ddmScalarLen_ - 0x8000); // fix scroll problem was - 4
1:70f7692:         int adjustSize = 0;
1:70f7692:         switch (numberOfExtendedLenBytes) {
1:70f7692:         case 4:
1:70f7692:             ensureBLayerDataInBuffer(4);
1:70f7692:             ddmScalarLen_ =
1:cce01c8:                     ((buffer_[pos_++] & 0xff) << 24) +
1:70f7692:                     ((buffer_[pos_++] & 0xff) << 16) +
1:70f7692:                     ((buffer_[pos_++] & 0xff) << 8) +
1:70f7692:                     ((buffer_[pos_++] & 0xff) << 0);
1:70f7692:             adjustSize = 4;
1:70f7692:             break;
1:70f7692:         case 0:
1:70f7692:             ddmScalarLen_ = -1;
1:70f7692:             adjustSize = 0;
1:70f7692:             break;
1:70f7692:         default:
1:70f7692:             doSyntaxrmSemantics(CodePoint.SYNERRCD_INCORRECT_EXTENDED_LEN);
1:70f7692:         }
1:70f7692: 
1:70f7692:         adjustCollectionAndDssLengths(adjustSize);
1:70f7692:         /*
1:70f7692:         // adjust the lengths here.  this is a special case since the
1:70f7692:         // extended length bytes do not include their own length.
1:70f7692:         for (int i = 0; i <= topDdmCollectionStack_; i++) {
1:70f7692:           ddmCollectionLenStack_[i] -= adjustSize;
1:70f7692:         }
1:70f7692:         dssLength_ -= adjustSize;
1:70f7692:         */
1:70f7692:     }
1:70f7692: 
1:0326967:     private void adjustCollectionAndDssLengths(int length) {
1:70f7692:         // adjust the lengths here.  this is a special case since the
1:70f7692:         // extended length bytes do not include their own length.
1:70f7692:         for (int i = 0; i <= topDdmCollectionStack_; i++) {
1:70f7692:             ddmCollectionLenStack_[i] -= length;
1:70f7692:         }
1:70f7692:         dssLength_ -= length;
1:70f7692:     }
1:70f7692: 
1:6a925a3:     protected final void startSameIdChainParse() throws DisconnectException {
1:70f7692:         readDssHeader();
1:70f7692:         netAgent_.clearSvrcod();
1:70f7692:     }
1:70f7692: 
1:6a925a3:     protected final void endOfSameIdChainData() throws DisconnectException {
1:70f7692:         netAgent_.targetTypdef_ = netAgent_.originalTargetTypdef_;
1:70f7692:         netAgent_.targetSqlam_ = netAgent_.orignalTargetSqlam_;
1:70f7692: 
1:70f7692:         if (this.topDdmCollectionStack_ != Reply.EMPTY_STACK) {
1:6a925a3:             agent_.accumulateChainBreakingReadExceptionAndThrow(
1:6a925a3:                 new DisconnectException(agent_, 
1:6a925a3:                 new ClientMessageId(SQLState.NET_COLLECTION_STACK_NOT_EMPTY)));
1:70f7692:         }
1:70f7692:         if (this.dssLength_ != 0) {
1:6a925a3:             agent_.accumulateChainBreakingReadExceptionAndThrow(
1:6a925a3:                 new DisconnectException(agent_, 
1:6a925a3:                 new ClientMessageId(SQLState.NET_DSS_NOT_ZERO)));
1:70f7692:         }
1:70f7692:         if (dssIsChainedWithSameID_ == true) {
2:6a925a3:             agent_.accumulateChainBreakingReadExceptionAndThrow(
2:6a925a3:                 new DisconnectException(agent_, 
1:6a925a3:                 new ClientMessageId(SQLState.NET_DSS_CHAINED_WITH_SAME_ID)));
1:70f7692:         }
1:70f7692:     }
1:6a925a3:     
1:6a925a3:     protected final int peekTotalColumnCount(int tripletLength) throws DisconnectException {
1:70f7692:         int columnCount = 0;
1:70f7692:         int offset = 0;
1:70f7692:         int tripletType = FdocaConstants.CPT_TRIPLET_TYPE;
1:70f7692:         while (tripletType == FdocaConstants.CPT_TRIPLET_TYPE) {
1:70f7692:             columnCount += ((tripletLength - 3) / 3);
1:70f7692:             // Peek ahead for the next triplet's tripletLength and tripletType.
1:70f7692:             // The number of bytes to skip before the next tripletType is tripletLength - 3.
1:70f7692:             ensureBLayerDataInBuffer(tripletLength - 3);
1:70f7692:             offset += (tripletLength - 3);
1:70f7692:             tripletLength = (buffer_[pos_ + offset++] & 0xff);
1:70f7692:             tripletType = (buffer_[pos_ + offset++] & 0xff);
1:70f7692:             // Skip the 1-byte tripletId.
1:70f7692:             offset++;
1:70f7692:         }
1:70f7692:         return columnCount;
1:70f7692:     }
1:70f7692: 
1:0326967:     private void peekExtendedLength() throws DisconnectException {
1:70f7692:         peekedNumOfExtendedLenBytes_ = (peekedLength_ - 0x8004);
1:70f7692:         switch (peekedNumOfExtendedLenBytes_) {
1:70f7692:         case 4:
1:70f7692:             // L   L   C   P  Extended Length
1:70f7692:             // -->2-bytes<--  --->4-bytes<---
1:70f7692:             // We are only peeking the length here, the actual pos_ is still before LLCP.  We ensured
1:70f7692:             // 4-bytes in peedCodePoint() for the LLCP, and we need to ensure 4-bytes(of LLCP) + the
1:70f7692:             // extended length bytes here.
1:70f7692:             if (longBufferForDecryption_ == null) //we ddon't need to do this if it's data stream encryption
1:70f7692:             {
1:70f7692:                 ensureBLayerDataInBuffer(4 + 4);
1:70f7692:             }
1:70f7692:             // The ddmScalarLen_ we peek here does not include the LLCP and the extended length bytes
1:70f7692:             // themselves.  So we will add those back to the ddmScalarLen_ so it can be adjusted
1:70f7692:             // correctly in parseLengthAndMatchCodePoint(). (since the adjustLengths() method will
1:70f7692:             // subtract the length from ddmScalarLen_)
1:70f7692:             peekedLength_ =
1:cce01c8:                     ((buffer_[pos_ + 4] & 0xff) << 24) +
1:70f7692:                     ((buffer_[pos_ + 5] & 0xff) << 16) +
1:70f7692:                     ((buffer_[pos_ + 6] & 0xff) << 8) +
1:70f7692:                     ((buffer_[pos_ + 7] & 0xff) << 0);
1:70f7692:             break;
1:70f7692:         case 0:
1:70f7692:             peekedLength_ = -1; // this ddm is streamed, so set -1 -> length unknown
1:70f7692:             break;
1:70f7692:         default:
1:70f7692:             doSyntaxrmSemantics(CodePoint.SYNERRCD_INCORRECT_EXTENDED_LEN);
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:6a925a3:     final int readFastUnsignedByte() throws DisconnectException {
1:70f7692:         return (buffer_[pos_++] & 0xff);
1:70f7692:     }
1:70f7692: 
1:6a925a3:     final short readFastShort() throws DisconnectException {
1:70f7692:         short s = SignedBinary.getShort(buffer_, pos_);
1:70f7692:         pos_ += 2;
1:70f7692:         return s;
1:70f7692:     }
1:70f7692: 
1:6a925a3:     final int readFastUnsignedShort() throws DisconnectException {
1:70f7692:         return ((buffer_[pos_++] & 0xff) << 8) +
1:70f7692:                 ((buffer_[pos_++] & 0xff) << 0);
1:70f7692:     }
1:70f7692: 
1:6a925a3:     final int readFastInt() throws DisconnectException {
1:70f7692:         int i = SignedBinary.getInt(buffer_, pos_);
1:70f7692:         pos_ += 4;
1:70f7692:         return i;
1:70f7692:     }
1:70f7692: 
1:6a925a3:     final String readFastString(int length) throws DisconnectException {
1:1451af7:         String result = netAgent_.getCurrentCcsidManager()
1:1451af7:                             .convertToJavaString(buffer_, pos_, length);
1:70f7692:         pos_ += length;
1:70f7692:         return result;
1:70f7692:     }
1:70f7692: 
1:6a925a3:     final byte[] readFastBytes(int length) throws DisconnectException {
1:70f7692:         byte[] b = new byte[length];
1:70f7692:         System.arraycopy(buffer_, pos_, b, 0, length);
1:70f7692:         pos_ += length;
1:70f7692:         return b;
1:70f7692:     }
1:70f7692: 
1:6a925a3:     protected final int peekFastLength() throws DisconnectException {
2:70f7692:         return (((buffer_[pos_] & 0xff) << 8) +
2:70f7692:                 ((buffer_[pos_ + 1] & 0xff) << 0));
1:70f7692:     }
1:70f7692: 
1:6a925a3:     final void skipFastBytes(int length) throws DisconnectException {
1:70f7692:         pos_ += length;
1:70f7692:     }
1:70f7692: 
1:6a925a3:     final void readFastIntArray(int[] array) throws DisconnectException {
2:70f7692:         for (int i = 0; i < array.length; i++) {
2:70f7692:             array[i] = SignedBinary.getInt(buffer_, pos_);
1:70f7692:             pos_ += 4;
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:a0b8943:     final String readFastString(int length, Charset encoding) {
1:a0b8943:         String s = new String(buffer_, pos_, length, encoding);
1:70f7692:         pos_ += length;
1:70f7692:         return s;
1:70f7692:     }
1:70f7692: 
1:6a925a3:     final byte[] readFastLDBytes() throws DisconnectException {
2:70f7692:         int len = ((buffer_[pos_++] & 0xff) << 8) + ((buffer_[pos_++] & 0xff) << 0);
2:70f7692:         if (len == 0) {
2:70f7692:             return null;
1:70f7692:         }
1:70f7692: 
1:70f7692:         byte[] b = new byte[len];
1:70f7692:         System.arraycopy(buffer_, pos_, b, 0, len);
1:70f7692:         pos_ += len;
1:70f7692:         return b;
1:70f7692:     }
1:70f7692: 
1:6a925a3:     final long readFastLong() throws DisconnectException {
2:70f7692:         long l = SignedBinary.getLong(buffer_, pos_);
2:70f7692:         pos_ += 8;
2:70f7692:         return l;
1:70f7692:     }
1:70f7692: 
1:6a925a3:     final byte readFastByte() throws DisconnectException {
1:70f7692:         return (byte) (buffer_[pos_++] & 0xff);
1:70f7692:     }
1:70f7692: 
1:70f7692:     final void mark() {
1:70f7692:         currentPos_ = pos_;
1:70f7692:     }
1:70f7692: 
1:70f7692:     // remove and return the top offset value from mark stack.
1:0326967:     private int popMark() {
1:70f7692:         return currentPos_;
1:70f7692:     }
1:70f7692: 
1:70f7692:     final int getFastSkipSQLCARDrowLength() {
1:70f7692:         return pos_ - popMark();
1:70f7692:     }
1:70f7692: 
1:70f7692:     // The only difference between this method and the original getData() method is this method
1:70f7692:     // is not doing an ensureALayerDataInBuffer
1:6a925a3:     final ByteArrayOutputStream getFastData(ByteArrayOutputStream existingBuffer) throws DisconnectException {
1:70f7692:         boolean readHeader;
1:70f7692:         int copySize;
1:70f7692:         ByteArrayOutputStream baos;
1:70f7692: 
1:70f7692:         // note: an empty baos can yield an allocated and empty byte[]
1:70f7692:         if (existingBuffer != null) {
1:70f7692:             baos = existingBuffer;
1:70f7692:         } else {
1:70f7692:             if (ddmScalarLen_ != -1) {
1:70f7692:                 // allocate a stream based on a known amount of data
1:70f7692:                 baos = new ByteArrayOutputStream(ddmScalarLen_);
1:70f7692:             } else {
1:70f7692:                 // allocate a stream to hold an unknown amount of data
1:70f7692:                 baos = new ByteArrayOutputStream();
1:70f7692:                 //isLengthAndNullabilityUnknown = true;
1:70f7692:             }
1:70f7692:         }
1:70f7692: 
1:70f7692:         // set the amount to read for the first segment
1:70f7692:         copySize = dssLength_; // note: has already been adjusted for headers
1:70f7692: 
1:70f7692:         do {
1:70f7692:             // determine if a continuation header needs to be read after the data
1:70f7692:             if (dssIsContinued_) {
1:70f7692:                 readHeader = true;
1:70f7692:             } else {
1:70f7692:                 readHeader = false;
1:70f7692:             }
1:70f7692: 
1:70f7692:             // read the segment
1:70f7692:             //ensureALayerDataInBuffer (copySize);
1:70f7692:             adjustLengths(copySize);
1:70f7692:             baos.write(buffer_, pos_, copySize);
1:70f7692:             pos_ += copySize;
1:70f7692: 
1:70f7692:             // read the continuation header, if necessary
1:70f7692:             if (readHeader) {
1:70f7692:                 readDSSContinuationHeader();
1:70f7692:             }
1:70f7692: 
1:70f7692:             copySize = dssLength_;
1:70f7692:         } while (readHeader == true);
1:70f7692: 
1:70f7692:         return baos;
1:70f7692:     }
1:70f7692: 
1:70f7692:     // This method is only used to match the codePoint for those class instance variables
1:70f7692:     // that are embedded in other reply messages.
1:6a925a3:     final protected void matchCodePoint(int expectedCodePoint) throws DisconnectException {
1:70f7692:         int actualCodePoint = 0;
1:70f7692:         actualCodePoint = peekedCodePoint_;
1:70f7692:         pos_ += 4;
1:70f7692:         if (actualCodePoint != expectedCodePoint) {
1:6a925a3:             agent_.accumulateChainBreakingReadExceptionAndThrow(
1:6a925a3:                 new DisconnectException(agent_, 
1:6a925a3:                     new ClientMessageId(SQLState.NET_NOT_EXPECTED_CODEPOINT), 
1:66527ec:                     actualCodePoint, expectedCodePoint));
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:33776ff: 
1:6a925a3:     protected final int peekNumOfColumns() throws DisconnectException {
1:70f7692:         // skip the 4-byte LLCP and any extended length bytes + 1-byte null sqlcagrp null indicator
1:70f7692:         int offset = (4 + peekedNumOfExtendedLenBytes_ + 1);
1:33776ff: 
1:70f7692:         offset = skipSQLDHROW(offset);
1:33776ff: 
1:70f7692:         return SignedBinary.getShort(buffer_, pos_ + offset);
1:70f7692:     }
1:33776ff: 
1:70f7692:     protected final boolean peekForNullSqlcagrp() {
1:70f7692:         // skip the 4-byte LLCP and any extended length bytes
1:70f7692:         int offset = (4 + peekedNumOfExtendedLenBytes_);
1:70f7692:         int nullInd = buffer_[pos_ + offset] & 0xff;
1:70f7692:         return (nullInd == CodePoint.NULLDATA);
1:70f7692:     }
1:33776ff: 
1:0326967:     private int skipSQLDHROW(int offset) {
1:70f7692:         int sqldhrowgrpNullInd = buffer_[pos_ + offset++] & 0xff;
1:70f7692:         if (sqldhrowgrpNullInd == CodePoint.NULLDATA) {
1:70f7692:             return offset;
1:70f7692:         }
1:33776ff: 
1:70f7692:         offset += 12;
1:33776ff: 
1:70f7692:         // skip sqldrdbnam
1:70f7692:         int stringLength = ((buffer_[pos_ + offset++] & 0xff) << 8) +
1:70f7692:                 ((buffer_[pos_ + offset++] & 0xff) << 0);
1:70f7692:         offset += stringLength;
1:33776ff: 
1:70f7692:         // skip sqldschema
1:70f7692:         stringLength = ((buffer_[pos_ + offset++] & 0xff) << 8) +
1:70f7692:                 ((buffer_[pos_ + offset++] & 0xff) << 0);
1:70f7692:         offset += stringLength;
1:33776ff: 
1:70f7692:         stringLength = ((buffer_[pos_ + offset++] & 0xff) << 8) +
1:70f7692:                 ((buffer_[pos_ + offset++] & 0xff) << 0);
1:70f7692:         offset += stringLength;
1:33776ff: 
1:70f7692:         return offset;
1:70f7692:     }
1:70f7692: }
1:33776ff: 
1:33776ff: 
1:33776ff: 
1:33776ff: 
============================================================================
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:a0b8943
/////////////////////////////////////////////////////////////////////////
1: import java.nio.charset.Charset;
/////////////////////////////////////////////////////////////////////////
1:     final String readString(int length, Charset encoding)
1:             throws DisconnectException {
1:         String s = new String(buffer_, pos_, length, encoding);
/////////////////////////////////////////////////////////////////////////
1:     final String readFastString(int length, Charset encoding) {
1:         String s = new String(buffer_, pos_, length, encoding);
commit:66527ec
/////////////////////////////////////////////////////////////////////////
1:                         minimumBytesNeeded, totalBytesRead));
/////////////////////////////////////////////////////////////////////////
1:                     syntaxErrorCode));
/////////////////////////////////////////////////////////////////////////
1:                     actualCodePoint, expectedCodePoint));
/////////////////////////////////////////////////////////////////////////
1:                     actualCodePoint, expectedCodePoint));
commit:c7a1d17
/////////////////////////////////////////////////////////////////////////
1:                     int firstLobLength = ((clearedByte[0] & 0xFF) << 8) +
1:                         ((clearedByte[1] & 0xFF) << 0);
commit:2349a90
/////////////////////////////////////////////////////////////////////////
0:     private final int skipSQLDHROW(int offset) {
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:0326967
/////////////////////////////////////////////////////////////////////////
1: class Reply {
/////////////////////////////////////////////////////////////////////////
1:     private boolean dssIsContinued_;
1:     private int dssCorrelationID_;
1:     private int peekedCodePoint_ = END_OF_COLLECTION; // saves the peeked codept
1:     final static int END_OF_COLLECTION = -1;
1:     final static int END_OF_SAME_ID_CHAIN = -2;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private void shiftBuffer(byte[] destinationBuffer) {
/////////////////////////////////////////////////////////////////////////
1:     private void ensureSpaceInBufferForFill(int desiredSpace) {
/////////////////////////////////////////////////////////////////////////
1:     private int fill(int minimumBytesNeeded) throws DisconnectException {
/////////////////////////////////////////////////////////////////////////
1:     private int ensureALayerDataInBuffer(int desiredDataSize)
1:             throws DisconnectException {
/////////////////////////////////////////////////////////////////////////
1:     private void compressBLayerData(int continueDssHeaderCount)
1:             throws DisconnectException {
/////////////////////////////////////////////////////////////////////////
1:         int bytesToShift;
1:         int continueHeaderLength;
/////////////////////////////////////////////////////////////////////////
1:     private void readDssHeader() throws DisconnectException {
1:         int correlationID;
1:         int nextCorrelationID;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private void decryptData(int gdsFormatter, int oldDssLength)
1:             throws DisconnectException {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private void readDSSContinuationHeader() throws DisconnectException {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private int readLengthAndCodePoint() throws DisconnectException {
/////////////////////////////////////////////////////////////////////////
1:     private void readExtendedLength() throws DisconnectException {
/////////////////////////////////////////////////////////////////////////
1:     private void adjustCollectionAndDssLengths(int length) {
/////////////////////////////////////////////////////////////////////////
1:     private void peekExtendedLength() throws DisconnectException {
/////////////////////////////////////////////////////////////////////////
1:     private int popMark() {
/////////////////////////////////////////////////////////////////////////
1:     private int skipSQLDHROW(int offset) {
commit:69e3d06
/////////////////////////////////////////////////////////////////////////
1: import java.io.IOException;
0: import java.io.UnsupportedEncodingException;
/////////////////////////////////////////////////////////////////////////
1:             } catch (IOException ioe) {
/////////////////////////////////////////////////////////////////////////
0:         } catch (UnsupportedEncodingException e) {
/////////////////////////////////////////////////////////////////////////
0:         } catch (UnsupportedEncodingException e) {
commit:b13b17c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.client.am.Agent;
/////////////////////////////////////////////////////////////////////////
1:     protected Agent agent_;
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:1451af7
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         String result = netAgent_.getCurrentCcsidManager()
1:                             .convertToJavaString(buffer_, pos_, length);
/////////////////////////////////////////////////////////////////////////
1:         String result = netAgent_.getCurrentCcsidManager()
1:                             .convertToJavaString(buffer_, pos_, len);
/////////////////////////////////////////////////////////////////////////
0:         String result = netAgent_.getCurrentCcsidManager()
0:                             .convertToJavaString(buffer_, pos_, length);
commit:6384512
/////////////////////////////////////////////////////////////////////////
1:         DisconnectException e = new DisconnectException(agent_,
0:                     new Integer(syntaxErrorCode)));
1:             
1:         // if we are communicating to an older server, we may get a SYNTAXRM on
1:         // ACCSEC (missing codepoint RDBNAM) if we were unable to convert to
1:         // EBCDIC (See DERBY-4008/DERBY-4004).  In that case we should chain 
1:         // the original conversion exception, so it is clear to the user what
1:         // the problem was.
1:         if (netAgent_.exceptionConvertingRdbnam != null) {
1:             e.setNextException(netAgent_.exceptionConvertingRdbnam);
1:             netAgent_.exceptionConvertingRdbnam = null;
1:         }
1:         agent_.accumulateChainBreakingReadExceptionAndThrow(e);
commit:e0c99e5
/////////////////////////////////////////////////////////////////////////
1:             // DERBY-2747: only count if we actually read something
1:             if (actualBytesRead > 0) {
1:                 count_ += actualBytesRead;
1:                 totalBytesRead += actualBytesRead;
1:             }
commit:cce01c8
/////////////////////////////////////////////////////////////////////////
1:                     ((buffer_[pos_++] & 0xff) << 24) +
/////////////////////////////////////////////////////////////////////////
1:                     ((buffer_[pos_ + 4] & 0xff) << 24) +
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:b9687fb
/////////////////////////////////////////////////////////////////////////
0:         ccsidManager_ = netAgent.getCurrentCcsidManager();
/////////////////////////////////////////////////////////////////////////
0:         String result = ccsidManager_.convertToJavaString(buffer_, pos_, length);
/////////////////////////////////////////////////////////////////////////
0:         String result = ccsidManager_.convertToJavaString(buffer_, pos_, len);
/////////////////////////////////////////////////////////////////////////
0:         String result = ccsidManager_.convertToJavaString(buffer_, pos_, length);
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:59bf37d
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:David Van Couvering
-------------------------------------------------------------------------------
commit:6a925a3
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.reference.MessageId;
/////////////////////////////////////////////////////////////////////////
0:     protected int fill(int minimumBytesNeeded) throws DisconnectException {
/////////////////////////////////////////////////////////////////////////
0:     protected final int ensureALayerDataInBuffer(int desiredDataSize) throws DisconnectException {
/////////////////////////////////////////////////////////////////////////
1:     protected final void ensureBLayerDataInBuffer(int desiredDataSize) throws DisconnectException {
/////////////////////////////////////////////////////////////////////////
0:     private final void compressBLayerData(int continueDssHeaderCount) throws DisconnectException {
/////////////////////////////////////////////////////////////////////////
0:     protected final void readDssHeader() throws DisconnectException {
/////////////////////////////////////////////////////////////////////////
0:     private final void decryptData(int gdsFormatter, int oldDssLength) throws DisconnectException {
/////////////////////////////////////////////////////////////////////////
1:     final int readUnsignedShort() throws DisconnectException {
/////////////////////////////////////////////////////////////////////////
1:     final short readShort() throws DisconnectException {
/////////////////////////////////////////////////////////////////////////
1:     final int readInt() throws DisconnectException {
/////////////////////////////////////////////////////////////////////////
0:     final void readIntArray(int[] array) throws DisconnectException {
/////////////////////////////////////////////////////////////////////////
0:     final long readLong() throws DisconnectException {
/////////////////////////////////////////////////////////////////////////
1:     final int[] readUnsignedShortList() throws DisconnectException {
/////////////////////////////////////////////////////////////////////////
1:     final int readUnsignedByte() throws DisconnectException {
1:     final byte readByte() throws DisconnectException {
0:     final boolean readBoolean() throws DisconnectException {
0:     final String readString(int length) throws DisconnectException {
/////////////////////////////////////////////////////////////////////////
0:     final String readString(int length, String encoding) throws DisconnectException {
/////////////////////////////////////////////////////////////////////////
1:             agent_.accumulateChainBreakingReadExceptionAndThrow(
1:                 new DisconnectException(agent_,
0:                     new ClientMessageId(SQLState.NET_ENCODING_NOT_SUPPORTED), 
0:                     e));
1:     final String readString() throws DisconnectException {
/////////////////////////////////////////////////////////////////////////
1:     final byte[] readBytes(int length) throws DisconnectException {
/////////////////////////////////////////////////////////////////////////
1:     final byte[] readBytes() throws DisconnectException {
/////////////////////////////////////////////////////////////////////////
0:     final byte[] readLDBytes() throws DisconnectException {
/////////////////////////////////////////////////////////////////////////
1:     final void skipBytes(int length) throws DisconnectException {
1:     final void skipBytes() throws DisconnectException {
/////////////////////////////////////////////////////////////////////////
1:     final ByteArrayOutputStream getData(ByteArrayOutputStream existingBuffer) throws DisconnectException {
/////////////////////////////////////////////////////////////////////////
0:     protected final void readDSSContinuationHeader() throws DisconnectException {
/////////////////////////////////////////////////////////////////////////
1:     final void doSyntaxrmSemantics(int syntaxErrorCode) throws DisconnectException {
1:         agent_.accumulateChainBreakingReadExceptionAndThrow(
1:             new DisconnectException(agent_,
1:                 new ClientMessageId(SQLState.DRDA_CONNECTION_TERMINATED),
1:                 SqlException.getMessageUtil().getTextMessage(
1:                     MessageId.CONN_DRDA_DATASTREAM_SYNTAX_ERROR,
0:                     new Integer(syntaxErrorCode))));
/////////////////////////////////////////////////////////////////////////
1:     protected final int peekCodePoint() throws DisconnectException {
/////////////////////////////////////////////////////////////////////////
0:     protected final int peekLength() throws DisconnectException {
/////////////////////////////////////////////////////////////////////////
1:     protected final int peekFastBytes(byte[] b, int offset, int length) throws DisconnectException {
1:     protected final void parseLengthAndMatchCodePoint(int expectedCodePoint) throws DisconnectException {
/////////////////////////////////////////////////////////////////////////
1:             agent_.accumulateChainBreakingReadExceptionAndThrow(
1:                 new DisconnectException(agent_, 
1:                     new ClientMessageId(SQLState.NET_NOT_EXPECTED_CODEPOINT), 
0:                     new Integer(actualCodePoint), 
0:                     new Integer(expectedCodePoint)));
0:     protected final int readLengthAndCodePoint() throws DisconnectException {
1:                 agent_.accumulateChainBreakingReadExceptionAndThrow(
1:                     new DisconnectException(agent_, 
1:                     new ClientMessageId(SQLState.NET_DDM_COLLECTION_TOO_SMALL)));
/////////////////////////////////////////////////////////////////////////
0:     private final void readExtendedLength() throws DisconnectException {
/////////////////////////////////////////////////////////////////////////
1:     protected final void startSameIdChainParse() throws DisconnectException {
1:     protected final void endOfSameIdChainData() throws DisconnectException {
1:             agent_.accumulateChainBreakingReadExceptionAndThrow(
1:                 new DisconnectException(agent_, 
1:                 new ClientMessageId(SQLState.NET_COLLECTION_STACK_NOT_EMPTY)));
1:             agent_.accumulateChainBreakingReadExceptionAndThrow(
1:                 new DisconnectException(agent_, 
1:                 new ClientMessageId(SQLState.NET_DSS_NOT_ZERO)));
1:             agent_.accumulateChainBreakingReadExceptionAndThrow(
1:                 new DisconnectException(agent_, 
1:                 new ClientMessageId(SQLState.NET_DSS_CHAINED_WITH_SAME_ID)));
1:     
1:     protected final int peekTotalColumnCount(int tripletLength) throws DisconnectException {
/////////////////////////////////////////////////////////////////////////
0:     private final void peekExtendedLength() throws DisconnectException {
/////////////////////////////////////////////////////////////////////////
1:     final int readFastUnsignedByte() throws DisconnectException {
1:     final short readFastShort() throws DisconnectException {
1:     final int readFastUnsignedShort() throws DisconnectException {
1:     final int readFastInt() throws DisconnectException {
1:     final String readFastString(int length) throws DisconnectException {
1:     final byte[] readFastBytes(int length) throws DisconnectException {
1:     protected final int peekFastLength() throws DisconnectException {
1:     final void skipFastBytes(int length) throws DisconnectException {
1:     final void readFastIntArray(int[] array) throws DisconnectException {
0:     final String readFastString(int length, String encoding) throws DisconnectException {
0:             agent_.accumulateChainBreakingReadExceptionAndThrow(
0:                 new DisconnectException(agent_,
0:                     new ClientMessageId(SQLState.NET_ENCODING_NOT_SUPPORTED),
0:                     e));
1:     final byte[] readFastLDBytes() throws DisconnectException {
/////////////////////////////////////////////////////////////////////////
1:     final long readFastLong() throws DisconnectException {
1:     final byte readFastByte() throws DisconnectException {
/////////////////////////////////////////////////////////////////////////
1:     final ByteArrayOutputStream getFastData(ByteArrayOutputStream existingBuffer) throws DisconnectException {
/////////////////////////////////////////////////////////////////////////
1:     final protected void matchCodePoint(int expectedCodePoint) throws DisconnectException {
0:             agent_.accumulateChainBreakingReadExceptionAndThrow(
0:                 new DisconnectException(agent_, 
1:                     new ClientMessageId(SQLState.NET_NOT_EXPECTED_CODEPOINT), 
0:                     new Integer(actualCodePoint), 
0:                     new Integer(expectedCodePoint)));
1:     protected final int peekNumOfColumns() throws DisconnectException {
/////////////////////////////////////////////////////////////////////////
0:     private final int skipSQLDHROW(int offset) throws DisconnectException {
commit:1b39163
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.client.am.DisconnectException;
1: import org.apache.derby.client.am.ClientMessageId;
1: 
1: import org.apache.derby.shared.common.reference.SQLState;
/////////////////////////////////////////////////////////////////////////
1:                 netAgent_.throwCommunicationsFailure(ioe);
/////////////////////////////////////////////////////////////////////////
1:                 netAgent_.accumulateChainBreakingReadExceptionAndThrow(
1:                     new DisconnectException(netAgent_,
1:                         new ClientMessageId(SQLState.NET_INSUFFICIENT_DATA),
0:                         new Integer(minimumBytesNeeded),
0:                         new Integer(totalBytesRead)));
commit:9f5bc90
/////////////////////////////////////////////////////////////////////////
1: import java.util.Arrays;
/////////////////////////////////////////////////////////////////////////
1:         Arrays.fill(ddmCollectionLenStack_, 0);
/////////////////////////////////////////////////////////////////////////
1:             tempPos -= (bytesToShift - 2);
1:             System.arraycopy(buffer_, tempPos - shiftSize, buffer_, tempPos , bytesToShift);
author:Jeremy Boynes
-------------------------------------------------------------------------------
commit:70f7692
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.client.am.SignedBinary;
1: import org.apache.derby.client.am.SqlException;
0: import org.apache.derby.client.am.SqlState;
0: public class Reply {
0:     protected org.apache.derby.client.am.Agent agent_;
1:     protected NetAgent netAgent_; //cheat-link to (NetAgent) agent_
0:     private CcsidManager ccsidManager_;
1:     protected final static int DEFAULT_BUFFER_SIZE = 32767;
1:     protected byte[] buffer_;
1:     protected int pos_;
1:     protected int count_;
1:     private int topDdmCollectionStack_;
1:     private final static int MAX_MARKS_NESTING = 10;
1:     private int[] ddmCollectionLenStack_;
1:     private int ddmScalarLen_; // a value of -1 -> streamed ddm -> length unknown
1:     private final static int EMPTY_STACK = -1;
1:     protected boolean ensuredLengthForDecryption_ = false; // A layer lengths have already been ensured in decrypt method.
1:     protected byte[] longBufferForDecryption_ = null;
1:     protected int longPosForDecryption_ = 0;
1:     protected byte[] longValueForDecryption_ = null;
1:     protected int longCountForDecryption_ = 0;
1:     protected int dssLength_;
0:     protected boolean dssIsContinued_;
1:     private boolean dssIsChainedWithSameID_;
0:     private boolean dssIsChainedWithDiffID_;
0:     protected int dssCorrelationID_;
1:     protected int peekedLength_ = 0;
0:     protected int peekedCodePoint_ = END_OF_COLLECTION;    // saves the peeked codept
1:     private int peekedNumOfExtendedLenBytes_ = 0;
1:     private int currentPos_ = 0;
0:     public final static int END_OF_COLLECTION = -1;
0:     public final static int END_OF_SAME_ID_CHAIN = -2;
1:     Reply(NetAgent netAgent, int bufferSize) {
1:         buffer_ = new byte[bufferSize];
1:         agent_ = netAgent_ = netAgent;
0:         ccsidManager_ = netAgent.targetCcsidManager_;
1:         ddmCollectionLenStack_ = new int[Reply.MAX_MARKS_NESTING];
1:         initialize();
1:     final void initialize() {
1:         pos_ = 0;
1:         count_ = 0;
1:         topDdmCollectionStack_ = Reply.EMPTY_STACK;
0:         for (int i = 0; i < Reply.MAX_MARKS_NESTING; i++) {
0:             ddmCollectionLenStack_[i] = 0;
1:         ddmScalarLen_ = 0;
1:         dssLength_ = 0;
1:         dssIsContinued_ = false;
0:         dssIsChainedWithDiffID_ = false;
1:         dssCorrelationID_ = 1;
1:     final int getDdmLength() {
1:         return ddmScalarLen_;
1: 
1:     // This is a helper method which shifts the buffered bytes from
1:     // wherever they are in the current buffer to the beginning of
1:     // different buffer (note these buffers could be the same).
1:     // State information is updated as needed after the shift.
0:     private final void shiftBuffer(byte[] destinationBuffer) {
1:         // calculate the size of the data in the current buffer.
1:         int sz = count_ - pos_;
1: 
1:         // copy this data to the new buffer starting at position 0.
1:         System.arraycopy(buffer_, pos_, destinationBuffer, 0, sz);
1: 
1:         // update the state information for data in the new buffer.
1:         pos_ = 0;
1:         count_ = sz;
1: 
1:         // replace the old buffer with the new buffer.
1:         buffer_ = destinationBuffer;
1: 
1:     // This method makes sure there is enough room in the buffer
1:     // for a certain number of bytes.  This method will allocate
1:     // a new buffer if needed and shift the bytes in the current buffer
1:     // to make ensure space is available for a fill.  Right now
1:     // this method will shift bytes as needed to make sure there is
1:     // as much room as possible in the buffer before trying to
1:     // do the read.  The idea is to try to have space to get as much data as possible
1:     // if we need to do a read on the socket's stream.
0:     protected final void ensureSpaceInBufferForFill(int desiredSpace) {
1:         // calculate the total unused space in the buffer.
1:         // this includes any space at the end of the buffer and any free
1:         // space at the beginning resulting from bytes already read.
1:         int currentAvailableSpace = (buffer_.length - count_) + pos_;
1: 
1:         // check to see if there is enough free space.
1:         if (currentAvailableSpace < desiredSpace) {
1: 
1:             // there is not enough free space so we need more storage.
1:             // we are going to double the buffer unless that happens to still be too small.
1:             // if more than double the buffer is needed, use the smallest amount over this as possible.
1:             int doubleBufferSize = (2 * buffer_.length);
1: 
1:             int minumNewBufferSize = (desiredSpace - currentAvailableSpace) + buffer_.length;
1:             int newsz = minumNewBufferSize <= doubleBufferSize ? doubleBufferSize : minumNewBufferSize;
1: 
1:             byte[] newBuffer = new byte[newsz];
1: 
1:             // shift everything from the old buffer to the new buffer
1:             shiftBuffer(newBuffer);
1:         } else {
1: 
1:             // there is enough free space in the buffer but let's make sure it is all at the end.
1:             // this is also important because if we are going to do a read, it would be nice
1:             // to get as much data as possible and making room at the end if the buffer helps to
1:             // ensure this.
1:             if (pos_ != 0) {
1:                 shiftBuffer(buffer_);
1:             }
1:         }
1:     }
1: 
1:     // This method will attempt to read a minimum number of bytes
1:     // from the underlying stream.  This method will keep trying to
1:     // read bytes until it has obtained at least the minimum number.
1:     // Now returns the total bytes read for decryption, use to return void.
0:     protected int fill(int minimumBytesNeeded) throws org.apache.derby.client.am.DisconnectException {
1:         // make sure that there is enough space in the buffer to hold
1:         // the minimum number of bytes needed.
1:         ensureSpaceInBufferForFill(minimumBytesNeeded);
1: 
1:         // read until the minimum number of bytes needed is now in the buffer.
1:         // hopefully the read method will return as many bytes as it can.
1:         int totalBytesRead = 0;
1:         int actualBytesRead = 0;
1:         do {
1:             try {
1:                 // oops, we shouldn't expose the agent's input stream here, collapse this into a read method on the agent
1:                 actualBytesRead = netAgent_.getInputStream().read(buffer_, count_, buffer_.length - count_);
0:             } catch (java.io.IOException ioe) {
0:                 netAgent_.throwCommunicationsFailure("Reply.fill()",
0:                         "InputStream.read()",
0:                         ioe.getMessage(),
0:                         "*");
1:             } finally {
1:                 if (agent_.loggingEnabled()) {
1:                     ((NetLogWriter) netAgent_.logWriter_).traceProtocolFlow(buffer_,
1:                             count_,
1:                             actualBytesRead,
1:                             NetLogWriter.TYPE_TRACE_RECEIVE,
1:                             "Reply",
1:                             "fill",
1:                             2); // tracepoint
1:                 }
1:             }
0:             count_ += actualBytesRead;
0:             totalBytesRead += actualBytesRead;
1: 
1:         } while ((totalBytesRead < minimumBytesNeeded) && (actualBytesRead != -1));
1: 
1:         if (actualBytesRead == -1) {
1:             if (totalBytesRead < minimumBytesNeeded) {
0:                 netAgent_.throwCommunicationsFailure("Reply.fill()",
0:                         "InputStream.read()",
0:                         "insufficient data",
0:                         "*");
1:             }
1:         }
1:         return totalBytesRead;
1:     }
1: 
1:     // Make sure a certain amount of Layer A data is in the buffer.
1:     // The data will be in the buffer after this method is called.
1:     // Now returns the total bytes read for decryption, use to return void.
0:     protected final int ensureALayerDataInBuffer(int desiredDataSize) throws org.apache.derby.client.am.DisconnectException {
1:         int totalBytesRead = 0;
1:         // calulate the the number of bytes in the buffer.
1:         int avail = count_ - pos_;
1: 
1:         // read more bytes off the network if the data is not in the buffer already.
1:         if (avail < desiredDataSize) {
1:             totalBytesRead = fill(desiredDataSize - avail);
1:         }
1:         return totalBytesRead;
1:     }
1: 
0:     protected final void ensureBLayerDataInBuffer(int desiredDataSize) throws org.apache.derby.client.am.DisconnectException {
1:         if (dssIsContinued_ && (desiredDataSize > dssLength_)) {
1:             int continueDssHeaderCount =
1:                     (((desiredDataSize - dssLength_) / 32767) + 1);
1:             ensureALayerDataInBuffer(desiredDataSize + (continueDssHeaderCount * 2));
1:             compressBLayerData(continueDssHeaderCount);
1:             return;
1:         }
1:         ensureALayerDataInBuffer(desiredDataSize);
1:     }
1: 
1:     // this will probably never be called.
1:     // it is included here in the highly unlikely event that a reply object
1:     // exceeds 32K.  for opimization purposes, we should consider
1:     // removing this.  removing this should be ok since we handle most
1:     // big stuff returned from the server (qrydta's for example) by
1:     // copying out the data into some other storage.  any extended dss header
1:     // info will be removed in the copying process.
0:     private final void compressBLayerData(int continueDssHeaderCount) throws org.apache.derby.client.am.DisconnectException {
1:         int tempPos = 0;
1: 
1:         // jump to the last continuation header.
1:         for (int i = 0; i < continueDssHeaderCount; i++) {
1:             // the first may be less than the size of a full dss
1:             if (i == 0) {
1:                 // only jump by the number of bytes remaining in the current dss
1:                 tempPos = pos_ + dssLength_;
1:             } else {
1:                 // all other jumps are for a full continued dss
1:                 tempPos += 32767;
1:             }
1:         }
1: 
1:         // for each of the dss headers to remove,
1:         // read out the continuation header and increment the dss length by the
1:         // size of the conitnation bytes,  then shift the continuation data as needed.
1:         int shiftSize = 0;
0:         int bytesToShift = 0;
0:         int continueHeaderLength = 0;
1:         int newDssLength = 0;
1:         for (int i = 0; i < continueDssHeaderCount; i++) {
1: 
1:             continueHeaderLength = ((buffer_[tempPos] & 0xFF) << 8) +
1:                     ((buffer_[tempPos + 1] & 0xFF) << 0);
1: 
1:             if (i == 0) {
1:                 // if this is the last one (farthest down stream and first to strip out)
1: 
1:                 if ((continueHeaderLength & 0x8000) == 0x8000) {
1:                     // the last dss header is again continued
1:                     continueHeaderLength = 32767;
1:                     dssIsContinued_ = true;
1:                 } else {
1:                     // the last dss header was not contiued so update continue state flag
1:                     dssIsContinued_ = false;
1:                 }
1:                 // the very first shift size is 2
1:                 shiftSize = 2;
1:             } else {
1:                 // already removed the last header so make sure the chaining flag is on
1:                 if ((continueHeaderLength & 0x8000) == 0x8000) {
1:                     continueHeaderLength = 32767;
1:                 } else {
1:                     // this is a syntax error but not really certain which one.
1:                     // for now pick 0x02 which is Dss header Length does not match the number
1:                     // of bytes of data found.
1:                     doSyntaxrmSemantics(CodePoint.SYNERRCD_DSS_LENGTH_BYTE_NUMBER_MISMATCH);
1:                 }
1:                 // increase the shift size by 2
1:                 shiftSize += 2;
1:             }
1: 
1:             // it is a syntax error if the dss continuation is less than or equal to two
1:             if (continueHeaderLength <= 2) {
1:                 doSyntaxrmSemantics(CodePoint.SYNERRCD_DSS_CONT_LESS_OR_EQUAL_2);
1:             }
1: 
1:             newDssLength += (continueHeaderLength - 2);
1: 
1:             // calculate the number of bytes to shift
1:             if (i != (continueDssHeaderCount - 1)) {
1:                 bytesToShift = 32767;
1:             } else {
1:                 bytesToShift = dssLength_;
1:             }
1: 
0:             tempPos -= (shiftSize - 1);
0:             // perform the compress
0:             for (int j = 0; j < bytesToShift; j++) {
0:                 buffer_[tempPos + shiftSize] = buffer_[tempPos];
0:                 tempPos--;
1:             }
0:             tempPos += (shiftSize + 1);
1:         }
1:         // reposition the start of the data after the final dss shift.
1:         pos_ = tempPos;
1:         dssLength_ = dssLength_ + newDssLength;
1:     }
1: 
0:     protected final void readDssHeader() throws org.apache.derby.client.am.DisconnectException {
0:         int correlationID = 0;
0:         int nextCorrelationID = 0;
1:         ensureALayerDataInBuffer(6);
1: 
1:         // read out the dss length
1:         dssLength_ =
1:                 ((buffer_[pos_++] & 0xFF) << 8) +
1:                 ((buffer_[pos_++] & 0xFF) << 0);
1: 
1:         // Remember the old dss length for decryption only.
1:         int oldDssLength = dssLength_;
1: 
1:         // check for the continuation bit and update length as needed.
1:         if ((dssLength_ & 0x8000) == 0x8000) {
1:             dssLength_ = 32767;
1:             dssIsContinued_ = true;
1:         } else {
1:             dssIsContinued_ = false;
1:         }
1: 
1:         if (dssLength_ < 6) {
1:             doSyntaxrmSemantics(CodePoint.SYNERRCD_DSS_LESS_THAN_6);
1:         }
1: 
1:         // If the GDS id is not valid, or
1:         // if the reply is not an RPYDSS nor
1:         // a OBJDSS, then throw an exception.
1:         if ((buffer_[pos_++] & 0xFF) != 0xd0) {
1:             doSyntaxrmSemantics(CodePoint.SYNERRCD_CBYTE_NOT_D0);
1:         }
1: 
1:         int gdsFormatter = buffer_[pos_++] & 0xFF;
1:         if (((gdsFormatter & 0x02) != 0x02)
1:                 && ((gdsFormatter & 0x03) != 0x03)
1:                 && ((gdsFormatter & 0x04) != 0x04)) {
1:             doSyntaxrmSemantics(CodePoint.SYNERRCD_FBYTE_NOT_SUPPORTED);
1:         }
1: 
1:         // Determine if the current DSS is chained with the
1:         // next DSS, with the same or different request ID.
1:         if ((gdsFormatter & 0x40) == 0x40) {    // on indicates structure chained to next structure
1:             if ((gdsFormatter & 0x10) == 0x10) {
1:                 dssIsChainedWithSameID_ = true;
0:                 dssIsChainedWithDiffID_ = false;
1:                 nextCorrelationID = dssCorrelationID_;
1:             } else {
1:                 dssIsChainedWithSameID_ = false;
0:                 dssIsChainedWithDiffID_ = true;
1:                 nextCorrelationID = dssCorrelationID_ + 1;
1:             }
1:         } else {
1:             // chaining bit not b'1', make sure DSSFMT bit3 not b'1'
1:             if ((gdsFormatter & 0x10) == 0x10) {  // Next DSS can not have same correlator
1:                 doSyntaxrmSemantics(CodePoint.SYNERRCD_CHAIN_OFF_SAME_NEXT_CORRELATOR);
1:             }
1: 
1:             // chaining bit not b'1', make sure no error continuation
1:             if ((gdsFormatter & 0x20) == 0x20) { // must be 'do not continue on error'
1:                 doSyntaxrmSemantics(CodePoint.SYNERRCD_CHAIN_OFF_ERROR_CONTINUE);
1:             }
1: 
1:             dssIsChainedWithSameID_ = false;
0:             dssIsChainedWithDiffID_ = false;
1:             nextCorrelationID = 1;
1:         }
1: 
1:         correlationID =
1:                 ((buffer_[pos_++] & 0xFF) << 8) +
1:                 ((buffer_[pos_++] & 0xFF) << 0);
1: 
1:         // corrid must be the one expected or a -1 which gets returned in some error cases.
1:         if ((correlationID != dssCorrelationID_) && (correlationID != 0xFFFF)) {
1:             doSyntaxrmSemantics(CodePoint.SYNERRCD_INVALID_CORRELATOR);
1:         } else {
1:             dssCorrelationID_ = nextCorrelationID;
1:         }
1:         dssLength_ -= 6;
1:         if ((gdsFormatter & 0x04) == 0x04) {
1:             decryptData(gdsFormatter, oldDssLength);  //we have to decrypt data here because
1:         }
1:         //we need the decrypted codepoint. If
1:         //Data is very long > 32767, we have to
1:         //get all the data first because decrypt
1:         //piece by piece doesn't work.
1:     }
0:     private final void decryptData(int gdsFormatter, int oldDssLength) throws org.apache.derby.client.am.DisconnectException {
1:         if (dssLength_ == 32761) {
1:             ByteArrayOutputStream baos;
1:             int copySize = 0;
1:             baos = new ByteArrayOutputStream();
1:             // set the amount to read for the first segment
1:             copySize = dssLength_; // note: has already been adjusted for headers
1:             do {
1:                 // determine if a continuation header needs to be read after the data
1:                 if (dssIsContinued_) {
1:                     readHeader = true;
1:                 } else {
1:                     readHeader = false;
1:                 }
1: 
1:                 // read the segment
1:                 ensureALayerDataInBuffer(copySize);
1:                 adjustLengths(copySize);
1:                 baos.write(buffer_, pos_, copySize);
1:                 pos_ += copySize;
1: 
1:                 // read the continuation header, if necessary
1:                 if (readHeader) {
1:                     readDSSContinuationHeader();
1:                 }
1: 
1:                 copySize = dssLength_;
1:             } while (readHeader == true);
1:             byte[] cipherBytes = baos.toByteArray();
1:             byte[] clearedByte = null;
1:             try {
1:                 clearedByte = netAgent_.netConnection_.getEncryptionManager().decryptData(cipherBytes,
1:                         NetConfiguration.SECMEC_EUSRIDPWD,
1:                         netAgent_.netConnection_.getTargetPublicKey(),
1:                         netAgent_.netConnection_.getTargetPublicKey());
1:             } catch (SqlException e) {
1:                 //throw new SqlException (agent_.logWriter_, "error in decrypting data");
1:             }
1: 
1:             //The decrypted data is for one codepoint only. We need to save the data follows this codepoint
1:             longBufferForDecryption_ = new byte[buffer_.length - pos_];
1:             longPosForDecryption_ = 0;
1:             count_ = count_ - pos_;
1:             longCountForDecryption_ = count_;
1:             System.arraycopy(buffer_, pos_, longBufferForDecryption_, 0, buffer_.length - pos_);
1: 
1:             //copy the clear data to buffer_
1:             if (clearedByte.length >= 32767) {
1:                 System.arraycopy(clearedByte, 0, buffer_, 0, 32767);
1:             } else {
1:                 System.arraycopy(clearedByte, 0, buffer_, 0, clearedByte.length);
1:             }
1: 
1:             pos_ = 0;
1:             dssLength_ = buffer_.length;
1: 
1:             int lobLength = 0;
1:             if (clearedByte.length > 32767) {  //for extended length, length is the 4 bytes that follow codepoint
1:                 lobLength = ((clearedByte[4] & 0xFF) << 24) +
1:                         ((clearedByte[5] & 0xFF) << 16) +
1:                         ((clearedByte[6] & 0xFF) << 8) +
1:                         ((clearedByte[7] & 0xFF) << 0);
1:                 longValueForDecryption_ = new byte[lobLength];
1:                 System.arraycopy(clearedByte, 8, longValueForDecryption_, 0, clearedByte.length - 8);
1:             } else {
1:                 lobLength = ((clearedByte[0] & 0xFF) << 8) +
1:                         ((clearedByte[1] & 0xFF) << 0);
1:                 longValueForDecryption_ = new byte[lobLength - 4];
1:                 System.arraycopy(clearedByte, 4, longValueForDecryption_, 0, clearedByte.length - 4);
1:             }
1:         } else {
1:             int bytesRead = ensureALayerDataInBuffer(dssLength_);  //we need to get back all the data here, and then decrypt
1:             if (bytesRead > 0) //we ensuredALayerDAtaInBuffer here and set the flag to true, so we don't need do this again later
1:             {
1:                 ensuredLengthForDecryption_ = true;
1:             }
1:             byte[] encryptedByte = new byte[dssLength_];
1:             System.arraycopy(buffer_, pos_, encryptedByte, 0, dssLength_);
1:             byte[] array1 = new byte[pos_];
1:             System.arraycopy(buffer_, 0, array1, 0, pos_);  //save the data before encrypted data in array1
1:             byte[] array3 = new byte[buffer_.length - dssLength_ - pos_];
1:             System.arraycopy(buffer_, pos_ + dssLength_, array3, 0, buffer_.length - dssLength_ - pos_); //save the data follows encrypted data in array3
1:             byte[] clearedByte = null;
1:             try {
1:                 clearedByte = netAgent_.netConnection_.getEncryptionManager().decryptData(encryptedByte,
1:                         NetConfiguration.SECMEC_EUSRIDPWD,
1:                         netAgent_.netConnection_.getTargetPublicKey(),
1:                         netAgent_.netConnection_.getTargetPublicKey());
1:             } catch (SqlException e) {
1:                 //throw new SqlException (agent_.logWriter_, "error in decrypting data");
1:             }
1:             dssLength_ -= (encryptedByte.length - clearedByte.length);
1:             byte[] buffer = new byte[array1.length + clearedByte.length + array3.length];
1:             System.arraycopy(array1, 0, buffer, 0, array1.length);
1:             System.arraycopy(clearedByte, 0, buffer, array1.length, clearedByte.length);
1:             System.arraycopy(array3, 0, buffer, array1.length + clearedByte.length, array3.length);
1:             buffer_ = buffer;
1:             int oldCount = count_;
1:             count_ = count_ - (encryptedByte.length - clearedByte.length);
1:             if (((clearedByte[2] & 0xff) << 8) + ((clearedByte[3] & 0xff) << 0) == 0x146c) {
0:                 int firstLobLength = ((clearedByte[0] & 0xFF) << 8) +
1:                         ((clearedByte[1] & 0xFF) << 0);
1: 
1:                 boolean flag = false;
1:                 if (gdsFormatter == 0x54) {
1:                     flag = true;
1:                 }
1:                 if (flag) {
1:                     if (oldCount - oldDssLength < 6) {
1:                         int totalBytesRead = fill(6); //sometimes the 2nd EXTDTA doesn't come back, need to fetch again to get it
1:                         if (totalBytesRead > 0) {
1:                             longBufferForDecryption_ = new byte[totalBytesRead];
1:                             longPosForDecryption_ = 0;
1:                             System.arraycopy(buffer_, pos_ + firstLobLength, longBufferForDecryption_, 0,
1:                                     totalBytesRead);
1:                         }
1: 
1:                     } else {
1:                         longBufferForDecryption_ = new byte[count_ - pos_ - firstLobLength];
1:                         longPosForDecryption_ = 0;
1:                         System.arraycopy(buffer_, pos_ + firstLobLength, longBufferForDecryption_, 0,
1:                                 longBufferForDecryption_.length);
1: 
1:                     }
1:                 } //end if(flag)
1:                 int lobLength = ((clearedByte[0] & 0xFF) << 8) +
1:                         ((clearedByte[1] & 0xFF) << 0) - 4;
1: 
1:                 longValueForDecryption_ = new byte[lobLength];
1: 
1:                 System.arraycopy(clearedByte, 4, longValueForDecryption_, 0, clearedByte.length - 4);  //copy the decrypted lob value (excluded length an dcodepoint) to longValue_
1:             } else if (((clearedByte[2] & 0xff) << 8) + ((clearedByte[3] & 0xff) << 0) == 0x241B) {
1:                 int length = ((clearedByte[0] & 0xFF) << 8) +
1:                         ((clearedByte[1] & 0xFF) << 0);
1:                 boolean noData = false;
1:                 if (clearedByte[4] == -1 && clearedByte[5] == -1) {
1:                     noData = true; //there is no data, no need to do the copy
1:                 }
1:                 if (!noData) {
1:                     if (length == 32776) {
1:                         length = ((clearedByte[4] & 0xFF) << 24) +
1:                                 ((clearedByte[5] & 0xFF) << 16) +
1:                                 ((clearedByte[6] & 0xFF) << 8) +
1:                                 ((clearedByte[7] & 0xFF) << 0);
1:                         longValueForDecryption_ = new byte[length];
1:                         System.arraycopy(clearedByte, 8, longValueForDecryption_, 0,
1:                                 clearedByte.length - 8);
1:                         longCountForDecryption_ = count_ - (pos_ + length + 8);
1:                         longBufferForDecryption_ = new byte[buffer_.length - pos_ - length - 8];
1:                         System.arraycopy(buffer_, pos_ + length + 8, longBufferForDecryption_, 0,
1:                                 longBufferForDecryption_.length);
1: 
1:                     } else {
1:                         longPosForDecryption_ = 0;
1:                         longCountForDecryption_ = count_ - (pos_ + length);
1:                         longBufferForDecryption_ = new byte[buffer_.length - pos_ - length];
1:                         System.arraycopy(buffer_, pos_ + length, longBufferForDecryption_, 0,
1:                                 longBufferForDecryption_.length);
1: 
1:                         longValueForDecryption_ = new byte[length - 4];
1: 
1:                         System.arraycopy(clearedByte, 4, longValueForDecryption_, 0,
1:                                 clearedByte.length - 4);
1:                     }
1:                 }
1:             }
1:         }
1:     }
1: 
1: 
0:     final int readUnsignedShort() throws org.apache.derby.client.am.DisconnectException {
1:         // should we be checking dss lengths and ddmScalarLengths here
1:         // if yes, i am not sure this is the correct place if we should be checking
1:         ensureBLayerDataInBuffer(2);
1:         adjustLengths(2);
1:         return ((buffer_[pos_++] & 0xff) << 8) +
1:                 ((buffer_[pos_++] & 0xff) << 0);
1:     }
1: 
0:     final short readShort() throws org.apache.derby.client.am.DisconnectException {
1:         // should we be checking dss lengths and ddmScalarLengths here
1:         ensureBLayerDataInBuffer(2);
1:         adjustLengths(2);
1:         short s = SignedBinary.getShort(buffer_, pos_);
1: 
1:         pos_ += 2;
1: 
1:         return s;
1:     }
1: 
0:     final int readInt() throws org.apache.derby.client.am.DisconnectException {
1:         // should we be checking dss lengths and ddmScalarLengths here
1:         ensureBLayerDataInBuffer(4);
1:         adjustLengths(4);
1:         int i = SignedBinary.getInt(buffer_, pos_);
1:         pos_ += 4;
1: 
1:         return i;
1:     }
1: 
0:     final void readIntArray(int[] array) throws org.apache.derby.client.am.DisconnectException {
0:         ensureBLayerDataInBuffer(array.length * 4);
0:         adjustLengths(array.length * 4);
1: 
1:         for (int i = 0; i < array.length; i++) {
1:             array[i] = SignedBinary.getInt(buffer_, pos_);
1:             pos_ += 4;
1:         }
1:     }
1: 
1: 
0:     final long readLong() throws org.apache.derby.client.am.DisconnectException {
1:         // should we be checking dss lengths and ddmScalarLengths here
0:         ensureBLayerDataInBuffer(8);
0:         adjustLengths(8);
1:         long l = SignedBinary.getLong(buffer_, pos_);
1: 
1:         pos_ += 8;
1: 
1:         return l;
1:     }
1: 
1: 
0:     final int[] readUnsignedShortList() throws org.apache.derby.client.am.DisconnectException {
1:         int len = ddmScalarLen_;
1:         ensureBLayerDataInBuffer(len);
1:         adjustLengths(len);
1: 
1:         int count = len / 2;
1:         int[] list = new int[count];
1: 
1:         for (int i = 0; i < count; i++) {
1:             list[i] = ((buffer_[pos_++] & 0xff) << 8) +
1:                     ((buffer_[pos_++] & 0xff) << 0);
1:         }
1: 
1:         return list;
1:     }
1: 
0:     final int readUnsignedByte() throws org.apache.derby.client.am.DisconnectException {
1:         ensureBLayerDataInBuffer(1);
1:         adjustLengths(1);
1:         return (buffer_[pos_++] & 0xff);
1:     }
1: 
0:     final byte readByte() throws org.apache.derby.client.am.DisconnectException {
1:         ensureBLayerDataInBuffer(1);
1:         adjustLengths(1);
1:         return (byte) (buffer_[pos_++] & 0xff);
1:     }
1: 
0:     final boolean readBoolean() throws org.apache.derby.client.am.DisconnectException {
1:         ensureBLayerDataInBuffer(1);
1:         adjustLengths(1);
0:         return buffer_[pos_++] != 0;
1:     }
1: 
0:     final String readString(int length) throws org.apache.derby.client.am.DisconnectException {
1:         ensureBLayerDataInBuffer(length);
1:         adjustLengths(length);
1: 
0:         String result = ccsidManager_.convertToUCS2(buffer_, pos_, length);
1:         pos_ += length;
1:         return result;
1:     }
1: 
0:     final String readString(int length, String encoding) throws org.apache.derby.client.am.DisconnectException {
1:         ensureBLayerDataInBuffer(length);
1:         adjustLengths(length);
0:         String s = null;
1: 
1:         try {
0:             s = new String(buffer_, pos_, length, encoding);
0:         } catch (java.io.UnsupportedEncodingException e) {
0:             agent_.accumulateChainBreakingReadExceptionAndThrow(new org.apache.derby.client.am.DisconnectException(e,
0:                     agent_,
0:                     "encoding not supported!!"));
1:         }
1: 
1:         pos_ += length;
1:         return s;
1:     }
1: 
0:     final String readString() throws org.apache.derby.client.am.DisconnectException {
1:         int len = ddmScalarLen_;
1:         ensureBLayerDataInBuffer(len);
1:         adjustLengths(len);
0:         String result = ccsidManager_.convertToUCS2(buffer_, pos_, len);
1:         pos_ += len;
1:         return result;
1:     }
1: 
0:     final byte[] readBytes(int length) throws org.apache.derby.client.am.DisconnectException {
1:         ensureBLayerDataInBuffer(length);
1:         adjustLengths(length);
1: 
1:         byte[] b = new byte[length];
1:         System.arraycopy(buffer_, pos_, b, 0, length);
1:         pos_ += length;
1:         return b;
1:     }
1: 
0:     final byte[] readBytes() throws org.apache.derby.client.am.DisconnectException {
1:         int len = ddmScalarLen_;
1:         ensureBLayerDataInBuffer(len);
1:         adjustLengths(len);
1: 
1:         byte[] b = new byte[len];
1:         System.arraycopy(buffer_, pos_, b, 0, len);
1:         pos_ += len;
1:         return b;
1:     }
1: 
0:     final byte[] readLDBytes() throws org.apache.derby.client.am.DisconnectException {
1:         ensureBLayerDataInBuffer(2);
1:         int len = ((buffer_[pos_++] & 0xff) << 8) + ((buffer_[pos_++] & 0xff) << 0);
1: 
1:         if (len == 0) {
1:             adjustLengths(2);
1:             return null;
1:         }
1: 
1:         ensureBLayerDataInBuffer(len);
0:         adjustLengths(len + 2);
1: 
1:         byte[] b = new byte[len];
1:         System.arraycopy(buffer_, pos_, b, 0, len);
1:         pos_ += len;
1:         return b;
1:     }
1: 
0:     final void skipBytes(int length) throws org.apache.derby.client.am.DisconnectException {
1:         ensureBLayerDataInBuffer(length);
1:         adjustLengths(length);
1:         pos_ += length;
1:     }
1: 
0:     final void skipBytes() throws org.apache.derby.client.am.DisconnectException {
1:         int len = ddmScalarLen_;
1:         ensureBLayerDataInBuffer(len);
1:         adjustLengths(len);
1:         pos_ += len;
1:     }
1: 
1:     // This will be the new and improved getData that handles all QRYDTA/EXTDTA
1:     // Returns the stream so that the caller can cache it
0:     final ByteArrayOutputStream getData(ByteArrayOutputStream existingBuffer) throws org.apache.derby.client.am.DisconnectException {
1:         boolean readHeader;
1:         int copySize;
1:         ByteArrayOutputStream baos;
1: 
1:         // note: an empty baos can yield an allocated and empty byte[]
1:         if (existingBuffer != null) {
1:             baos = existingBuffer;
1:         } else {
1:             if (ddmScalarLen_ != -1) {
1:                 // allocate a stream based on a known amount of data
1:                 baos = new ByteArrayOutputStream(ddmScalarLen_);
1:             } else {
1:                 // allocate a stream to hold an unknown amount of data
1:                 baos = new ByteArrayOutputStream();
1:                 //isLengthAndNullabilityUnknown = true;
1:             }
1:         }
1: 
1:         // set the amount to read for the first segment
1:         copySize = dssLength_; // note: has already been adjusted for headers
1: 
1:         do {
1:             if (dssIsContinued_) {
1:                 readHeader = true;
1:             } else {
1:                 readHeader = false;
1:             }
1:             ensureALayerDataInBuffer(copySize);
1:             adjustLengths(copySize);
1:             baos.write(buffer_, pos_, copySize);
1:             if (readHeader) {
1:                 readDSSContinuationHeader();
1:             }
1:         } while (readHeader == true);
1:         return baos;
1:     }
1:     // reads a DSS continuation header
1:     // prereq: pos_ is positioned on the first byte of the two-byte header
1:     // post:   dssIsContinued_ is set to true if the continuation bit is on, false otherwise
1:     //         dssLength_ is set to DssConstants.MAX_DSS_LEN - 2 (don't count the header for the next read)
1:     // helper method for getEXTDTAData
0:     protected final void readDSSContinuationHeader() throws org.apache.derby.client.am.DisconnectException {
1:         ensureALayerDataInBuffer(2);
1:         dssLength_ =
1:                 ((buffer_[pos_++] & 0xFF) << 8) +
1:                 ((buffer_[pos_++] & 0xFF) << 0);
1:         if ((dssLength_ & 0x8000) == 0x8000) {
1:             dssLength_ = DssConstants.MAX_DSS_LEN;
1:             dssIsContinued_ = true;
1:         } else {
1:             dssIsContinued_ = false;
1:         }
1:         // it is a syntax error if the dss continuation header length
1:         // is less than or equal to two
1:         if (dssLength_ <= 2) {
1:             doSyntaxrmSemantics(CodePoint.SYNERRCD_DSS_CONT_LESS_OR_EQUAL_2);
1:         dssLength_ -= 2;  // avoid consuming the DSS cont header
1:     // As part of parsing the reply, the client can detect that the
1:     // data sent from the target agent does not structurally
1:     // conform to the requirements of the DDM architecture.  These are
1:     // the same checks performed by the target server on the messages
1:     // it receives from the protocolj code.  Server side detected errors
1:     // result in a SYNTAXRM being returned from the AS.  According to the
1:     // DDM manual, parsing of the DSS is terminated when the error is
1:     // detected.  The Syntax Error Code, SYNERRCD, describes the various errors.
1:     //
1:     // Note: Not all of these may be valid at the client.  See descriptions for
1:     // which ones make sense for client side errors/checks.
1:     // Syntax Error Code                  Description of Error
1:     // -----------------                  --------------------
1:     // 0x01                               Dss header Length is less than 6.
1:     // 0x02                               Dss header Length does not match the
1:     //                                    number of bytes of data found.
1:     // 0x03                               Dss header C-byte not D0.
1:     // 0x04                               Dss header f-bytes either not
1:     //                                    recognized or not supported.
1:     // 0x05                               DSS continuation specified but not found.
1:     //                                    For example, DSS continuation is specified
1:     //                                    on the last DSS, and the SNA LU 6.2 communication
1:     //                                    facility returned the SEND indicator.
1:     // 0x06                               DSS chaining specified but no DSS found.
1:     //                                    For example, DSS chaining is specified
1:     //                                    on the last DSS, and the SNA LU 6.2 communication
1:     //                                    facility returned the SEND indicator.
1:     // 0x07                               Object length less than four.  For example,
1:     //                                    a command parameter's length is specified
1:     //                                    as two, or a command's length is specified as three.
1:     // 0x08                               Object length does not match the number of bytes of data
1:     //                                    found.  For example, a RQSDSS with a length of 150
1:     //                                    contains a command whose length is 125 or a SRVDGN parameter
1:     //                                    specifies a length of 200 but there are only 50
1:     //                                    bytes left in the DSS.
1:     // 0x09                               Object length greater than maximum allowed.
1:     //                                    For example, a RECCNT parameter specifies a
1:     //                                    length of ten, but the parameter is defined
1:     //                                    to have a maximum length of eight.
1:     // 0x0A                               Object length less than the minimum required.
1:     //                                    For example, a SVRCOD parameter specifies a
1:     //                                    length of five, but the parameter is defined
1:     //                                    to have a fixed length of six.
1:     // 0x0B                               Object length not allowed.  For example,
1:     //                                    a FILEXDPT parameter is specified with a length of
1:     //                                    11, but this would indicate that only half of the hours
1:     //                                    field is present instead of the complete hours field.
1:     // 0x0C                               Incorrect large object extended length field (see
1:     //                                    description of DSS).  For example, an extended
1:     //                                    length field is present, but it is only three bytes
1:     //                                    long when it is defined to be a multiple of two bytes.
1:     // 0x0D                               Object code point index not supported.
1:     //                                    For example, a code point of 8032 is encountered
1:     //                                    but x'8' is a reserved code point index.
1:     // 0x0E                               Required object not found.  For example, a CLEAR
1:     //                                    command does not have a filnam parameter present,
1:     //                                    or a MODREC command is not followed by a RECORD
1:     //                                    command data object.
1:     // 0x0F                               Too many command data objects sent.  For example,
1:     //                                    a MODREC command is followed by two RECORD command
1:     //                                    command data objects, or a DECREC command is followed
1:     //                                    by RECORD object.
1:     // 0x10                               Mutually exclusive objects present.
1:     //                                    For example, a CRTDIRF command specifies both
1:     //                                    a DCLNAM and FILNAM parameters.
1:     // 0x11                               Too few command data objects sent.
1:     //                                    For example, an INSRECEF command that
1:     //                                    specified RECCNT95) is followed by only
1:     //                                    4 RECORD command data objects.
1:     // 0x12                               Duplicate object present.
1:     //                                    For example, a LSTFAT command has tow FILNAM
1:     //                                    parameters specified.
1:     // 0x13                               Invalid request correlator specified.
1:     //                                    Use PRCCNVRM with PRCCNVDC of 04 or 05 instead
1:     //                                    of this error code.  This error code is being retained
1:     //                                    for compatibility with Level 1 of the architecture.
1:     // 0x14                               Required value not found.
1:     // 0x15                               Reserved value not allowed.  For example,
1:     //                                    a INSRECEF command specified a RECCNT(0) parameter.
1:     // 0x16                               DSS continuation less than or equal to two.
1:     //                                    For example, the length bytes of the DSS continuation
1:     //                                    have the value of one.
1:     // 0x17                               Objects not in required order.  For example, a RECAL
1:     //                                    object contains a RECORD object followed by a RECNBR
1:     //                                    object with is not in the defined order.
1:     // 0x18                               DSS chaining byt not b'1', but DSSFMT bit3 set to b'1'.
1:     // 0x19                               Previous DSS indicated current DSS has the same
1:     //                                    request correlator, but the request correlators are
1:     //                                    not the same.
1:     // 0x1A                               DSS cahining bit not b'1', but error continuation requested.
1:     // 0x1B                               Mutually exclusive parameter values not specified.
1:     //                                    For example, an OPEN command specified PRPSHD(TRUE)
1:     //                                    and FILSHR(READER).
1:     // 0x1D                               Code point not valid command.  For example, the first
1:     //                                    code point in RQSDSS either is not in the dictionary
1:     //                                    or is not a code point for a command.
1:     //
1:     // When the client detects these errors, it will be handled as if a SYNTAXRM is returned
1:     // from the server.  In this SYNTAXRM case, PROTOCOL architects an SQLSTATE of 58008 or 58009.
1:     //
1:     // Messages
1:     // SQLSTATE : 58009
1:     //     Execution failed due to a distribution protocol error that caused deallocation of the conversation.
1:     //     SQLCODE : -30020
1:     //     Execution failed because of a Distributed Protocol
1:     //         Error that will affect the successful execution of subsequent
1:     //         commands and SQL statements: Reason Code <reason-code>.
1:     //      Some possible reason codes include:
1:     //      121C Indicates that the user is not authorized to perform the requested command.
1:     //      1232 The command could not be completed because of a permanent error.
1:     //          In most cases, the server will be in the process of an abend.
1:     //      220A The target server has received an invalid data description.
1:     //          If a user SQLDA is specified, ensure that the fields are
1:     //          initialized correctly. Also, ensure that the length does not
1:     //          exceed the maximum allowed length for the data type being used.
1:     //
1:     //      The command or statement cannot be processed.  The current
1:     //          transaction is rolled back and the application is disconnected
1:     //          from the remote database.
0:     final void doSyntaxrmSemantics(int syntaxErrorCode) throws org.apache.derby.client.am.DisconnectException {
0:         agent_.accumulateChainBreakingReadExceptionAndThrow(new org.apache.derby.client.am.DisconnectException(agent_,
0:                 "Execution failed due to a distribution protocol error " +
0:                 "that caused deallocation of the conversation.  " +
0:                 "A PROTOCOL Data Stream Syntax Error was detected.  Reason: " +
0:                 "0x" + Integer.toHexString(syntaxErrorCode),
0:                 SqlState._58009));
1:     protected final void pushLengthOnCollectionStack() {
1:         ddmCollectionLenStack_[++topDdmCollectionStack_] = ddmScalarLen_;
1:         ddmScalarLen_ = 0;
1:     protected final void adjustLengths(int length) {
1:         ddmScalarLen_ -= length;
1:         adjustCollectionAndDssLengths(length);
1:         /*
1:         for (int i = 0; i <= topDdmCollectionStack_; i++) {
1:           ddmCollectionLenStack_[i] -= length;
1:         }
1:         dssLength_ -= length;
1:         */
1:     protected int adjustDdmLength(int ddmLength, int length) {
1:         ddmLength -= length;
1:         if (ddmLength == 0) {
1:             adjustLengths(getDdmLength());
1:         }
1:         return ddmLength;
1:     // Pop the collection Length stack.
1:     // pre:  The collection length stack must not be empty and the top value
1:     //       on the stack must be 0.
1:     // post: The top 0 value on the stack will be popped.
1:     protected final void popCollectionStack() {
1:         topDdmCollectionStack_--;
0:     protected final int peekCodePoint() throws org.apache.derby.client.am.DisconnectException {
1:         if (topDdmCollectionStack_ != EMPTY_STACK) {
1:             if (ddmCollectionLenStack_[topDdmCollectionStack_] == 0) {
1:                 return END_OF_COLLECTION;
1:             } else if (ddmCollectionLenStack_[topDdmCollectionStack_] < 4) {
1:                 // error
1:             }
1:         }
1: 
1:         // if there is no more data in the current dss, and the dss is not
1:         // continued, indicate the end of the same Id chain or read the next dss header.
1:         if ((dssLength_ == 0) && (!dssIsContinued_)) {
1:             if (!dssIsChainedWithSameID_) {
1:                 return END_OF_SAME_ID_CHAIN;
1:             }
1:             readDssHeader();
1:         }
1: 
1:         if (longBufferForDecryption_ == null)  //we don't need to do this if it's data stream encryption
1:         {
1:             ensureBLayerDataInBuffer(4);
1:         }
1:         peekedLength_ = ((buffer_[pos_] & 0xff) << 8) + ((buffer_[pos_ + 1] & 0xff) << 0);
1:         peekedCodePoint_ = ((buffer_[pos_ + 2] & 0xff) << 8) + ((buffer_[pos_ + 3] & 0xff) << 0);
1: 
1:         // check for extended length
1:         if ((peekedLength_ & 0x8000) == 0x8000) {
1:             peekExtendedLength();
1:         } else {
1:             peekedNumOfExtendedLenBytes_ = 0;
1:         }
1:         return peekedCodePoint_;
0:     // Read out the 2-byte length without moving the pos_ pointer.
0:     protected final int peekLength() throws org.apache.derby.client.am.DisconnectException {
1:         ensureBLayerDataInBuffer(2);
1:         return (((buffer_[pos_] & 0xff) << 8) +
1:                 ((buffer_[pos_ + 1] & 0xff) << 0));
1:     // Read "length" number of bytes from the buffer into the byte array b starting from offset
1:     // "offset".  The current offset in the buffer does not change.
0:     protected final int peekFastBytes(byte[] b, int offset, int length) throws org.apache.derby.client.am.DisconnectException {
1:         for (int i = 0; i < length; i++) {
1:             b[offset + i] = buffer_[pos_ + i];
1:         }
1:         return offset + length;
0:     protected final void parseLengthAndMatchCodePoint(int expectedCodePoint) throws org.apache.derby.client.am.DisconnectException {
1:         int actualCodePoint = 0;
1:         if (peekedCodePoint_ == END_OF_COLLECTION) {
1:             actualCodePoint = readLengthAndCodePoint();
1:         } else {
1:             actualCodePoint = peekedCodePoint_;
1:             pos_ += (4 + peekedNumOfExtendedLenBytes_);
1:             ddmScalarLen_ = peekedLength_;
1:             if (peekedNumOfExtendedLenBytes_ == 0 && ddmScalarLen_ != -1) {
1:                 adjustLengths(4);
1:             } else {
1:                 adjustCollectionAndDssLengths(4 + peekedNumOfExtendedLenBytes_);
1:             }
1:             peekedLength_ = 0;
1:             peekedCodePoint_ = END_OF_COLLECTION;
1:             peekedNumOfExtendedLenBytes_ = 0;
1:         }
1:         if (actualCodePoint != expectedCodePoint) {
0:             zThrowSyntaxError("actual code point, " + actualCodePoint +
0:                     " does not match expected code point, " + expectedCodePoint);
1:         }
0:     protected final int readLengthAndCodePoint() throws org.apache.derby.client.am.DisconnectException {
1:         if (topDdmCollectionStack_ != EMPTY_STACK) {
1:             if (ddmCollectionLenStack_[topDdmCollectionStack_] == 0) {
1:                 return END_OF_COLLECTION;
1:             } else if (ddmCollectionLenStack_[topDdmCollectionStack_] < 4) {
0:                 zThrowSyntaxError("ddm collection contains less than 4 bytes of data");
1:             }
1:         }
1:         // if there is no more data in the current dss, and the dss is not
1:         // continued, indicate the end of the same Id chain or read the next dss header.
1:         if ((dssLength_ == 0) && (!dssIsContinued_)) {
1:             if (!dssIsChainedWithSameID_) {
1:                 return END_OF_SAME_ID_CHAIN;
1:             }
1:             readDssHeader();
1:         }
1: 
1:         ensureBLayerDataInBuffer(4);
1:         ddmScalarLen_ =
1:                 ((buffer_[pos_++] & 0xff) << 8) +
1:                 ((buffer_[pos_++] & 0xff) << 0);
1:         int codePoint = ((buffer_[pos_++] & 0xff) << 8) +
1:                 ((buffer_[pos_++] & 0xff) << 0);
1:         adjustLengths(4);
1: 
1:         // check for extended length
1:         if ((ddmScalarLen_ & 0x8000) == 0x8000) {
1:             readExtendedLength();
1:         }
1:         return codePoint;
1: 
0:     private final void readExtendedLength() throws org.apache.derby.client.am.DisconnectException {
1:         int numberOfExtendedLenBytes = (ddmScalarLen_ - 0x8000); // fix scroll problem was - 4
1:         int adjustSize = 0;
1:         switch (numberOfExtendedLenBytes) {
1:         case 4:
1:             ensureBLayerDataInBuffer(4);
1:             ddmScalarLen_ =
0:                     ((buffer_[pos_++] & 0xff) << 32) +
1:                     ((buffer_[pos_++] & 0xff) << 16) +
1:                     ((buffer_[pos_++] & 0xff) << 8) +
1:                     ((buffer_[pos_++] & 0xff) << 0);
1:             adjustSize = 4;
1:             break;
1:         case 0:
1:             ddmScalarLen_ = -1;
1:             adjustSize = 0;
1:             break;
1:         default:
1:             doSyntaxrmSemantics(CodePoint.SYNERRCD_INCORRECT_EXTENDED_LEN);
1:         }
1: 
1:         adjustCollectionAndDssLengths(adjustSize);
1:         /*
1:         // adjust the lengths here.  this is a special case since the
1:         // extended length bytes do not include their own length.
1:         for (int i = 0; i <= topDdmCollectionStack_; i++) {
1:           ddmCollectionLenStack_[i] -= adjustSize;
1:         }
1:         dssLength_ -= adjustSize;
1:         */
1:     }
1: 
0:     private final void adjustCollectionAndDssLengths(int length) {
1:         // adjust the lengths here.  this is a special case since the
1:         // extended length bytes do not include their own length.
1:         for (int i = 0; i <= topDdmCollectionStack_; i++) {
1:             ddmCollectionLenStack_[i] -= length;
1:         }
1:         dssLength_ -= length;
1:     }
1: 
0:     protected final void startSameIdChainParse() throws org.apache.derby.client.am.DisconnectException {
1:         readDssHeader();
1:         netAgent_.clearSvrcod();
1:     }
1: 
0:     protected final void endOfSameIdChainData() throws org.apache.derby.client.am.DisconnectException {
1:         netAgent_.targetTypdef_ = netAgent_.originalTargetTypdef_;
1:         netAgent_.targetSqlam_ = netAgent_.orignalTargetSqlam_;
1: 
1:         if (this.topDdmCollectionStack_ != Reply.EMPTY_STACK) {
0:             zThrowSyntaxError("collection stack not empty at end of same id chain parse");
1:         }
1:         if (this.dssLength_ != 0) {
0:             zThrowSyntaxError("dss length not 0 at end of same id chain parse");
1:         }
1:         if (dssIsChainedWithSameID_ == true) {
0:             zThrowSyntaxError("dss chained with same id at end of same id chain parse");
1:         }
1:     }
1: 
0:     private final void zThrowSyntaxError(String error) throws org.apache.derby.client.am.DisconnectException {
0:         agent_.accumulateChainBreakingReadExceptionAndThrow(new org.apache.derby.client.am.DisconnectException(agent_, error));
1:     }
1: 
0:     protected final int peekTotalColumnCount(int tripletLength) throws org.apache.derby.client.am.DisconnectException {
1:         int columnCount = 0;
1:         int offset = 0;
1:         int tripletType = FdocaConstants.CPT_TRIPLET_TYPE;
1:         while (tripletType == FdocaConstants.CPT_TRIPLET_TYPE) {
1:             columnCount += ((tripletLength - 3) / 3);
1:             // Peek ahead for the next triplet's tripletLength and tripletType.
1:             // The number of bytes to skip before the next tripletType is tripletLength - 3.
1:             ensureBLayerDataInBuffer(tripletLength - 3);
1:             offset += (tripletLength - 3);
1:             tripletLength = (buffer_[pos_ + offset++] & 0xff);
1:             tripletType = (buffer_[pos_ + offset++] & 0xff);
1:             // Skip the 1-byte tripletId.
1:             offset++;
1:         }
1:         return columnCount;
1:     }
1: 
0:     private final void peekExtendedLength() throws org.apache.derby.client.am.DisconnectException {
1:         peekedNumOfExtendedLenBytes_ = (peekedLength_ - 0x8004);
1:         switch (peekedNumOfExtendedLenBytes_) {
1:         case 4:
1:             // L   L   C   P  Extended Length
1:             // -->2-bytes<--  --->4-bytes<---
1:             // We are only peeking the length here, the actual pos_ is still before LLCP.  We ensured
1:             // 4-bytes in peedCodePoint() for the LLCP, and we need to ensure 4-bytes(of LLCP) + the
1:             // extended length bytes here.
1:             if (longBufferForDecryption_ == null) //we ddon't need to do this if it's data stream encryption
1:             {
1:                 ensureBLayerDataInBuffer(4 + 4);
1:             }
1:             // The ddmScalarLen_ we peek here does not include the LLCP and the extended length bytes
1:             // themselves.  So we will add those back to the ddmScalarLen_ so it can be adjusted
1:             // correctly in parseLengthAndMatchCodePoint(). (since the adjustLengths() method will
1:             // subtract the length from ddmScalarLen_)
1:             peekedLength_ =
0:                     ((buffer_[pos_ + 4] & 0xff) << 32) +
1:                     ((buffer_[pos_ + 5] & 0xff) << 16) +
1:                     ((buffer_[pos_ + 6] & 0xff) << 8) +
1:                     ((buffer_[pos_ + 7] & 0xff) << 0);
1:             break;
1:         case 0:
1:             peekedLength_ = -1; // this ddm is streamed, so set -1 -> length unknown
1:             break;
1:         default:
1:             doSyntaxrmSemantics(CodePoint.SYNERRCD_INCORRECT_EXTENDED_LEN);
1:         }
1:     }
1: 
0:     final int readFastUnsignedByte() throws org.apache.derby.client.am.DisconnectException {
1:         return (buffer_[pos_++] & 0xff);
1:     }
1: 
0:     final short readFastShort() throws org.apache.derby.client.am.DisconnectException {
1:         short s = SignedBinary.getShort(buffer_, pos_);
1:         pos_ += 2;
1:         return s;
1:     }
1: 
0:     final int readFastUnsignedShort() throws org.apache.derby.client.am.DisconnectException {
1:         return ((buffer_[pos_++] & 0xff) << 8) +
1:                 ((buffer_[pos_++] & 0xff) << 0);
1:     }
1: 
0:     final int readFastInt() throws org.apache.derby.client.am.DisconnectException {
1:         int i = SignedBinary.getInt(buffer_, pos_);
1:         pos_ += 4;
1:         return i;
1:     }
1: 
0:     final String readFastString(int length) throws org.apache.derby.client.am.DisconnectException {
0:         String result = ccsidManager_.convertToUCS2(buffer_, pos_, length);
1:         pos_ += length;
1:         return result;
1:     }
1: 
0:     final byte[] readFastBytes(int length) throws org.apache.derby.client.am.DisconnectException {
1:         byte[] b = new byte[length];
1:         System.arraycopy(buffer_, pos_, b, 0, length);
1:         pos_ += length;
1:         return b;
1:     }
1: 
0:     protected final int peekFastLength() throws org.apache.derby.client.am.DisconnectException {
1:         return (((buffer_[pos_] & 0xff) << 8) +
1:                 ((buffer_[pos_ + 1] & 0xff) << 0));
1:     }
1: 
0:     final void skipFastBytes(int length) throws org.apache.derby.client.am.DisconnectException {
1:         pos_ += length;
1:     }
1: 
0:     final void readFastIntArray(int[] array) throws org.apache.derby.client.am.DisconnectException {
1:         for (int i = 0; i < array.length; i++) {
1:             array[i] = SignedBinary.getInt(buffer_, pos_);
1:             pos_ += 4;
1:         }
1:     }
1: 
0:     final String readFastString(int length, String encoding) throws org.apache.derby.client.am.DisconnectException {
0:         String s = null;
1: 
1:         try {
0:             s = new String(buffer_, pos_, length, encoding);
0:         } catch (java.io.UnsupportedEncodingException e) {
0:             agent_.accumulateChainBreakingReadExceptionAndThrow(new org.apache.derby.client.am.DisconnectException(e,
0:                     agent_,
0:                     "encoding not supported!!"));
1:         }
1:         pos_ += length;
1:         return s;
1:     }
1: 
0:     final byte[] readFastLDBytes() throws org.apache.derby.client.am.DisconnectException {
1:         int len = ((buffer_[pos_++] & 0xff) << 8) + ((buffer_[pos_++] & 0xff) << 0);
1:         if (len == 0) {
1:             return null;
1:         }
1: 
1:         byte[] b = new byte[len];
1:         System.arraycopy(buffer_, pos_, b, 0, len);
1:         pos_ += len;
1:         return b;
1:     }
1: 
0:     final long readFastLong() throws org.apache.derby.client.am.DisconnectException {
1:         long l = SignedBinary.getLong(buffer_, pos_);
1:         pos_ += 8;
1:         return l;
1:     }
1: 
0:     final byte readFastByte() throws org.apache.derby.client.am.DisconnectException {
1:         return (byte) (buffer_[pos_++] & 0xff);
1:     }
1: 
1:     final void mark() {
1:         currentPos_ = pos_;
1:     }
1: 
1:     // remove and return the top offset value from mark stack.
0:     final int popMark() {
1:         return currentPos_;
1:     }
1: 
1:     final int getFastSkipSQLCARDrowLength() {
1:         return pos_ - popMark();
1:     }
1: 
1:     // The only difference between this method and the original getData() method is this method
1:     // is not doing an ensureALayerDataInBuffer
0:     final ByteArrayOutputStream getFastData(ByteArrayOutputStream existingBuffer) throws org.apache.derby.client.am.DisconnectException {
1:         boolean readHeader;
1:         int copySize;
1:         ByteArrayOutputStream baos;
1: 
1:         // note: an empty baos can yield an allocated and empty byte[]
1:         if (existingBuffer != null) {
1:             baos = existingBuffer;
1:         } else {
1:             if (ddmScalarLen_ != -1) {
1:                 // allocate a stream based on a known amount of data
1:                 baos = new ByteArrayOutputStream(ddmScalarLen_);
1:             } else {
1:                 // allocate a stream to hold an unknown amount of data
1:                 baos = new ByteArrayOutputStream();
1:                 //isLengthAndNullabilityUnknown = true;
1:             }
1:         }
1: 
1:         // set the amount to read for the first segment
1:         copySize = dssLength_; // note: has already been adjusted for headers
1: 
1:         do {
1:             // determine if a continuation header needs to be read after the data
1:             if (dssIsContinued_) {
1:                 readHeader = true;
1:             } else {
1:                 readHeader = false;
1:             }
1: 
1:             // read the segment
1:             //ensureALayerDataInBuffer (copySize);
1:             adjustLengths(copySize);
1:             baos.write(buffer_, pos_, copySize);
1:             pos_ += copySize;
1: 
1:             // read the continuation header, if necessary
1:             if (readHeader) {
1:                 readDSSContinuationHeader();
1:             }
1: 
1:             copySize = dssLength_;
1:         } while (readHeader == true);
1: 
1:         return baos;
1:     }
1: 
1:     // This method is only used to match the codePoint for those class instance variables
1:     // that are embedded in other reply messages.
0:     final protected void matchCodePoint(int expectedCodePoint) throws org.apache.derby.client.am.DisconnectException {
1:         int actualCodePoint = 0;
1:         actualCodePoint = peekedCodePoint_;
1:         pos_ += 4;
1:         if (actualCodePoint != expectedCodePoint) {
0:             zThrowSyntaxError("actual code point, " + actualCodePoint +
0:                     " does not match expected code point, " + expectedCodePoint);
1:         }
1:     }
0:     protected final int peekNumOfColumns() throws org.apache.derby.client.am.DisconnectException {
1:         // skip the 4-byte LLCP and any extended length bytes + 1-byte null sqlcagrp null indicator
1:         int offset = (4 + peekedNumOfExtendedLenBytes_ + 1);
1:         offset = skipSQLDHROW(offset);
1:         return SignedBinary.getShort(buffer_, pos_ + offset);
1:     }
1:     protected final boolean peekForNullSqlcagrp() {
1:         // skip the 4-byte LLCP and any extended length bytes
1:         int offset = (4 + peekedNumOfExtendedLenBytes_);
1:         int nullInd = buffer_[pos_ + offset] & 0xff;
1:         return (nullInd == CodePoint.NULLDATA);
1:     }
0:     private final int skipSQLDHROW(int offset) throws org.apache.derby.client.am.DisconnectException {
1:         int sqldhrowgrpNullInd = buffer_[pos_ + offset++] & 0xff;
1:         if (sqldhrowgrpNullInd == CodePoint.NULLDATA) {
1:             return offset;
1:         }
1:         offset += 12;
1:         // skip sqldrdbnam
1:         int stringLength = ((buffer_[pos_ + offset++] & 0xff) << 8) +
1:                 ((buffer_[pos_ + offset++] & 0xff) << 0);
1:         offset += stringLength;
1:         // skip sqldschema
1:         stringLength = ((buffer_[pos_ + offset++] & 0xff) << 8) +
1:                 ((buffer_[pos_ + offset++] & 0xff) << 0);
1:         offset += stringLength;
1:         stringLength = ((buffer_[pos_ + offset++] & 0xff) << 8) +
1:                 ((buffer_[pos_ + offset++] & 0xff) << 0);
1:         offset += stringLength;
1:         return offset;
1:     }
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:33776ff
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derby.client.net.Reply
1: 
0:    Copyright (c) 2001, 2005 The Apache Software Foundation or its licensors, where applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1: */
1: 
1: package org.apache.derby.client.net;
1: 
1: 
0: import org.apache.derby.client.am.SqlState;
0: import org.apache.derby.client.am.SqlException;
0: import org.apache.derby.client.am.SignedBinary;
1: import java.io.ByteArrayOutputStream;
1: 
0: public class Reply
0: {
0:   protected org.apache.derby.client.am.Agent agent_;
0:   protected NetAgent netAgent_; //cheat-link to (NetAgent) agent_
1: 
0:   private CcsidManager ccsidManager_;
0:   protected final static int DEFAULT_BUFFER_SIZE = 32767;
0:   protected byte[] buffer_;
0:   protected int pos_;
0:   protected int count_;
1: 
0:   private int topDdmCollectionStack_;
0:   private final static int MAX_MARKS_NESTING = 10;
0:   private int[] ddmCollectionLenStack_;
0:   private int ddmScalarLen_; // a value of -1 -> streamed ddm -> length unknown
0:   private final static int EMPTY_STACK = -1;
1: 
0:   protected boolean ensuredLengthForDecryption_ = false; // A layer lengths have already been ensured in decrypt method.
0:   protected byte[] longBufferForDecryption_ = null;
0:   protected int longPosForDecryption_ = 0;
0:   protected byte[] longValueForDecryption_ = null;
0:   protected int longCountForDecryption_ = 0;
1: 
0:   protected int dssLength_;
0:   protected boolean dssIsContinued_;
0:   private boolean dssIsChainedWithSameID_;
0:   private boolean dssIsChainedWithDiffID_;
0:   protected int dssCorrelationID_;
1: 
0:   protected int peekedLength_ = 0;
0:   protected int peekedCodePoint_ = END_OF_COLLECTION;    // saves the peeked codept
0:   private int peekedNumOfExtendedLenBytes_ = 0;
0:   private int currentPos_ = 0;
1: 
0:   public final static int END_OF_COLLECTION = -1;
0:   public final static int END_OF_SAME_ID_CHAIN = -2;
0:   Reply (NetAgent netAgent, int bufferSize)
0:   {
0:     buffer_ = new byte[bufferSize];
0:     agent_ = netAgent_ = netAgent;
0:     ccsidManager_ = netAgent.targetCcsidManager_;
0:     ddmCollectionLenStack_ = new int[Reply.MAX_MARKS_NESTING];
0:     initialize ();
1:   }
1: 
0:   final void initialize ()
0:   {
0:     pos_ = 0;
0:     count_ = 0;
0:     topDdmCollectionStack_ = Reply.EMPTY_STACK;
0:     for (int i = 0; i < Reply.MAX_MARKS_NESTING; i++) {
0:       ddmCollectionLenStack_[i] = 0;
1:     }
0:     ddmScalarLen_ = 0;
0:     dssLength_ = 0;
0:     dssIsContinued_ = false;
1:     dssIsChainedWithSameID_ = false;
0:     dssIsChainedWithDiffID_ = false;
0:     dssCorrelationID_ = 1;
1:   }
1: 
0:   final int getDdmLength()
0:   {
0:     return ddmScalarLen_;
1:   }
1: 
0:   // This is a helper method which shifts the buffered bytes from
0:   // wherever they are in the current buffer to the beginning of
0:   // different buffer (note these buffers could be the same).
0:   // State information is updated as needed after the shift.
0:   private final void shiftBuffer (byte[] destinationBuffer)
0:   {
0:     // calculate the size of the data in the current buffer.
0:     int sz = count_ - pos_;
1: 
0:     // copy this data to the new buffer starting at position 0.
0:     System.arraycopy (buffer_, pos_, destinationBuffer, 0, sz);
1: 
0:     // update the state information for data in the new buffer.
0:     pos_ = 0;
0:     count_ = sz;
1: 
0:     // replace the old buffer with the new buffer.
0:     buffer_ = destinationBuffer;
1:   }
1: 
0:   // This method makes sure there is enough room in the buffer
0:   // for a certain number of bytes.  This method will allocate
0:   // a new buffer if needed and shift the bytes in the current buffer
0:   // to make ensure space is available for a fill.  Right now
0:   // this method will shift bytes as needed to make sure there is
0:   // as much room as possible in the buffer before trying to
0:   // do the read.  The idea is to try to have space to get as much data as possible
0:   // if we need to do a read on the socket's stream.
0:   protected final void ensureSpaceInBufferForFill (int desiredSpace)
0:   {
0:     // calculate the total unused space in the buffer.
0:     // this includes any space at the end of the buffer and any free
0:     // space at the beginning resulting from bytes already read.
0:     int currentAvailableSpace = (buffer_.length - count_) + pos_;
1: 
0:     // check to see if there is enough free space.
0:     if (currentAvailableSpace < desiredSpace) {
1: 
0:       // there is not enough free space so we need more storage.
0:       // we are going to double the buffer unless that happens to still be too small.
0:       // if more than double the buffer is needed, use the smallest amount over this as possible.
0:       int doubleBufferSize = (2 * buffer_.length);
1: 
0:       int minumNewBufferSize = (desiredSpace - currentAvailableSpace) + buffer_.length;
0:       int newsz = minumNewBufferSize <= doubleBufferSize ? doubleBufferSize : minumNewBufferSize;
1: 
0:       byte[] newBuffer = new byte[newsz];
1: 
0:       // shift everything from the old buffer to the new buffer
0:       shiftBuffer (newBuffer);
1:     }
0:     else {
1: 
0:       // there is enough free space in the buffer but let's make sure it is all at the end.
0:       // this is also important because if we are going to do a read, it would be nice
0:       // to get as much data as possible and making room at the end if the buffer helps to
0:       // ensure this.
0:       if (pos_ != 0) {
0:         shiftBuffer (buffer_);
1:       }
1:     }
1:   }
1: 
0:   // This method will attempt to read a minimum number of bytes
0:   // from the underlying stream.  This method will keep trying to
0:   // read bytes until it has obtained at least the minimum number.
0:   // Now returns the total bytes read for decryption, use to return void.
0:   protected int fill (int minimumBytesNeeded) throws org.apache.derby.client.am.DisconnectException
0:   {
0:     // make sure that there is enough space in the buffer to hold
0:     // the minimum number of bytes needed.
0:     ensureSpaceInBufferForFill (minimumBytesNeeded);
1: 
0:     // read until the minimum number of bytes needed is now in the buffer.
0:     // hopefully the read method will return as many bytes as it can.
0:     int totalBytesRead = 0;
0:     int actualBytesRead = 0;
0:     do {
0:       try {
0:        // oops, we shouldn't expose the agent's input stream here, collapse this into a read method on the agent
0:         actualBytesRead = netAgent_.getInputStream().read (buffer_, count_, buffer_.length - count_);
1:       }
0:       catch (java.io.IOException ioe) {
0:         netAgent_.throwCommunicationsFailure ("Reply.fill()",
0:                                              "InputStream.read()",
0:                                              ioe.getMessage(),
0:                                              "*");
1:       }
0:       finally {
0:         if (agent_.loggingEnabled())
0:           ((NetLogWriter) netAgent_.logWriter_).traceProtocolFlow (buffer_,
0:                                        count_,
0:                                        actualBytesRead,
0:                                        NetLogWriter.TYPE_TRACE_RECEIVE,
0:                                        "Reply",
0:                                        "fill",
0:                                        2); // tracepoint
1:       }
0:       count_ += actualBytesRead;
0:       totalBytesRead += actualBytesRead;
1: 
1:     }
0:     while ((totalBytesRead < minimumBytesNeeded) && (actualBytesRead != -1));
1: 
0:     if (actualBytesRead == -1) {
0:       if (totalBytesRead < minimumBytesNeeded) {
0:         netAgent_.throwCommunicationsFailure ("Reply.fill()",
0:                                              "InputStream.read()",
0:                                              "insufficient data",
0:                                              "*");
1:       }
1:     }
0:     return totalBytesRead;
1:   }
1: 
0:   // Make sure a certain amount of Layer A data is in the buffer.
0:   // The data will be in the buffer after this method is called.
0:   // Now returns the total bytes read for decryption, use to return void.
0:   protected final int ensureALayerDataInBuffer (int desiredDataSize) throws org.apache.derby.client.am.DisconnectException
0:   {
0:     int totalBytesRead = 0;
0:     // calulate the the number of bytes in the buffer.
0:     int avail = count_ - pos_;
1: 
0:     // read more bytes off the network if the data is not in the buffer already.
0:     if (avail < desiredDataSize) {
0:       totalBytesRead = fill (desiredDataSize - avail);
1:     }
0:     return totalBytesRead;
1:   }
1: 
0:   protected final void ensureBLayerDataInBuffer (int desiredDataSize) throws org.apache.derby.client.am.DisconnectException
0:   {
0:     if (dssIsContinued_ && (desiredDataSize > dssLength_)) {
0:       int continueDssHeaderCount =
0:         (((desiredDataSize - dssLength_) / 32767) + 1);
0:       ensureALayerDataInBuffer (desiredDataSize + (continueDssHeaderCount * 2));
0:       compressBLayerData (continueDssHeaderCount);
0:       return;
1:     }
0:     ensureALayerDataInBuffer (desiredDataSize);
1:   }
1: 
0:   // this will probably never be called.
0:   // it is included here in the highly unlikely event that a reply object
0:   // exceeds 32K.  for opimization purposes, we should consider
0:   // removing this.  removing this should be ok since we handle most
0:   // big stuff returned from the server (qrydta's for example) by
0:   // copying out the data into some other storage.  any extended dss header
0:   // info will be removed in the copying process.
0:   private final void compressBLayerData (int continueDssHeaderCount) throws org.apache.derby.client.am.DisconnectException
0:   {
0:     int tempPos = 0;
1: 
0:     // jump to the last continuation header.
0:     for (int i = 0; i < continueDssHeaderCount; i++) {
0:       // the first may be less than the size of a full dss
0:       if (i == 0) {
0:         // only jump by the number of bytes remaining in the current dss
0:         tempPos = pos_ + dssLength_;
1:       }
0:       else {
0:         // all other jumps are for a full continued dss
0:         tempPos += 32767;
1:       }
1:     }
1: 
0:     // for each of the dss headers to remove,
0:     // read out the continuation header and increment the dss length by the
0:     // size of the conitnation bytes,  then shift the continuation data as needed.
0:     int shiftSize = 0;
0:     int bytesToShift = 0;
0:     int continueHeaderLength = 0;
0:     int newDssLength = 0;
0:     for (int i = 0; i < continueDssHeaderCount; i++) {
1: 
0:       continueHeaderLength = ((buffer_[tempPos]&0xFF) << 8) +
0:         ((buffer_[tempPos + 1]&0xFF) << 0);
1: 
0:       if (i == 0) {
0:         // if this is the last one (farthest down stream and first to strip out)
1: 
0:         if ((continueHeaderLength & 0x8000) == 0x8000) {
0:           // the last dss header is again continued
0:           continueHeaderLength = 32767;
0:           dssIsContinued_ = true;
1:         }
0:         else {
0:           // the last dss header was not contiued so update continue state flag
0:           dssIsContinued_ = false;
1:         }
0:         // the very first shift size is 2
0:         shiftSize = 2;
1:       }
0:       else {
0:         // already removed the last header so make sure the chaining flag is on
0:         if ((continueHeaderLength & 0x8000) == 0x8000) {
0:           continueHeaderLength = 32767;
1:         }
0:         else {
0:           // this is a syntax error but not really certain which one.
0:           // for now pick 0x02 which is Dss header Length does not match the number
0:           // of bytes of data found.
0:           doSyntaxrmSemantics (CodePoint.SYNERRCD_DSS_LENGTH_BYTE_NUMBER_MISMATCH);
1:         }
0:         // increase the shift size by 2
0:         shiftSize += 2;
1:       }
1: 
0:       // it is a syntax error if the dss continuation is less than or equal to two
0:       if (continueHeaderLength <= 2) {
0:         doSyntaxrmSemantics (CodePoint.SYNERRCD_DSS_CONT_LESS_OR_EQUAL_2);
1:       }
1: 
0:       newDssLength += (continueHeaderLength - 2);
1: 
0:       // calculate the number of bytes to shift
0:       if (i != (continueDssHeaderCount - 1))
0:         bytesToShift = 32767;
0:       else
0:         bytesToShift = dssLength_;
1: 
0:       tempPos -= (shiftSize - 1);
0:       // perform the compress
0:       for (int j = 0; j < bytesToShift; j++) {
0:         buffer_[tempPos + shiftSize] = buffer_[tempPos];
0:         tempPos--;
1:       }
0:       tempPos += (shiftSize + 1);
1:     }
0:     // reposition the start of the data after the final dss shift.
0:     pos_ = tempPos;
0:     dssLength_ = dssLength_ + newDssLength;
1:   }
1: 
0:   protected final void readDssHeader () throws org.apache.derby.client.am.DisconnectException
0:   {
0:     int correlationID = 0;
0:     int nextCorrelationID = 0;
0:     ensureALayerDataInBuffer (6);
1: 
0:     // read out the dss length
0:     dssLength_ =
0:       ((buffer_[pos_++]&0xFF) << 8) +
0:       ((buffer_[pos_++]&0xFF) << 0);
1: 
0:     // Remember the old dss length for decryption only.
0:     int oldDssLength = dssLength_;
1: 
0:     // check for the continuation bit and update length as needed.
0:     if ((dssLength_ & 0x8000) == 0x8000) {
0:       dssLength_ = 32767;
0:       dssIsContinued_ = true;
1:     }
0:     else {
0:       dssIsContinued_ = false;
1:     }
1: 
0:     if (dssLength_ < 6)
0:       doSyntaxrmSemantics (CodePoint.SYNERRCD_DSS_LESS_THAN_6);
1: 
0:     // If the GDS id is not valid, or
0:     // if the reply is not an RPYDSS nor
0:     // a OBJDSS, then throw an exception.
0:     if ((buffer_[pos_++]&0xFF) != 0xd0)
0:       doSyntaxrmSemantics (CodePoint.SYNERRCD_CBYTE_NOT_D0);
1: 
0:     int gdsFormatter = buffer_[pos_++]&0xFF;
0:     if (((gdsFormatter & 0x02) != 0x02)
0:         &&((gdsFormatter & 0x03) != 0x03)
0:         &&((gdsFormatter & 0x04) != 0x04)) {
0:       doSyntaxrmSemantics (CodePoint.SYNERRCD_FBYTE_NOT_SUPPORTED);
1:     }
1: 
0:     // Determine if the current DSS is chained with the
0:     // next DSS, with the same or different request ID.
0:     if ((gdsFormatter & 0x40) == 0x40) {    // on indicates structure chained to next structure
0:       if ((gdsFormatter & 0x10) == 0x10) {
0:         dssIsChainedWithSameID_ = true;
0:         dssIsChainedWithDiffID_ = false;
0:         nextCorrelationID = dssCorrelationID_;
1:       }
0:       else {
1:         dssIsChainedWithSameID_ = false;
0:         dssIsChainedWithDiffID_ = true;
0:         nextCorrelationID = dssCorrelationID_ + 1;
1:       }
1:     }
0:     else {
0:       // chaining bit not b'1', make sure DSSFMT bit3 not b'1'
0:       if ((gdsFormatter & 0x10) == 0x10)  {  // Next DSS can not have same correlator
0:         doSyntaxrmSemantics(CodePoint.SYNERRCD_CHAIN_OFF_SAME_NEXT_CORRELATOR);
1:       }
1: 
0:       // chaining bit not b'1', make sure no error continuation
0:       if ((gdsFormatter & 0x20) == 0x20) { // must be 'do not continue on error'
0:         doSyntaxrmSemantics(CodePoint.SYNERRCD_CHAIN_OFF_ERROR_CONTINUE);
1:       }
1: 
1:       dssIsChainedWithSameID_ = false;
0:       dssIsChainedWithDiffID_ = false;
0:       nextCorrelationID = 1;
1:     }
1: 
0:     correlationID =
0:       ((buffer_[pos_++]&0xFF) << 8) +
0:       ((buffer_[pos_++]&0xFF) << 0);
1: 
0:     // corrid must be the one expected or a -1 which gets returned in some error cases.
0:     if ((correlationID != dssCorrelationID_) && (correlationID != 0xFFFF)){
0:       doSyntaxrmSemantics (CodePoint.SYNERRCD_INVALID_CORRELATOR);
1:     }
0:     else {
0:       dssCorrelationID_ = nextCorrelationID;
1:     }
0:     dssLength_ -= 6;
0:      if ((gdsFormatter & 0x04) == 0x04 )
0:        decryptData (gdsFormatter, oldDssLength);  //we have to decrypt data here because
0:                                                   //we need the decrypted codepoint. If
0:                                                   //Data is very long > 32767, we have to
0:                                                   //get all the data first because decrypt
0:                                                   //piece by piece doesn't work.
1:   }
1: 
1: 
1: 
0:   private final void decryptData(int gdsFormatter, int oldDssLength) throws org.apache.derby.client.am.DisconnectException
0:   {
1:         boolean readHeader;
1: 
0:         if(dssLength_ == 32761) {
0:           ByteArrayOutputStream baos;
0:           int copySize = 0;
1: 
0:           baos = new ByteArrayOutputStream ();
1: 
0:           // set the amount to read for the first segment
0:           copySize = dssLength_; // note: has already been adjusted for headers
1: 
0:           do {
1:             // determine if a continuation header needs to be read after the data
0:             if (dssIsContinued_)
0:               readHeader = true;
0:             else
0:               readHeader = false;
1: 
1:             // read the segment
0:             ensureALayerDataInBuffer (copySize);
0:             adjustLengths (copySize);
0:             baos.write (buffer_, pos_, copySize);
1:             pos_ += copySize;
1: 
1:             // read the continuation header, if necessary
0:             if (readHeader)
0:               readDSSContinuationHeader ();
1: 
1:             copySize = dssLength_;
1:           }
0:           while (readHeader == true);
0:           byte[] cipherBytes = baos.toByteArray();
0:           byte[] clearedByte = null;
0:           try{
0:             clearedByte = netAgent_.netConnection_.getEncryptionManager().decryptData(
0:                 cipherBytes,
0:                 NetConfiguration.SECMEC_EUSRIDPWD,
0:                 netAgent_.netConnection_.getTargetPublicKey(),
0:                 netAgent_.netConnection_.getTargetPublicKey());
1:           }
0:           catch (SqlException e)
0:           {
0:             //throw new SqlException (agent_.logWriter_, "error in decrypting data");
1:           }
1: 
0:           //The decrypted data is for one codepoint only. We need to save the data follows this codepoint
0:           longBufferForDecryption_ = new byte[buffer_.length - pos_];
0:           longPosForDecryption_ = 0;
0:           count_ = count_ - pos_;
0:           longCountForDecryption_ = count_;
0:           System.arraycopy(buffer_,pos_,longBufferForDecryption_,0,buffer_.length - pos_);
1: 
0:           //copy the clear data to buffer_
0:           if (clearedByte.length >=32767)
0:             System.arraycopy(clearedByte,0,buffer_,0,32767);
0:          else
0:              System.arraycopy(clearedByte,0,buffer_,0,clearedByte.length);
1: 
0:           pos_ = 0;
0:           dssLength_ = buffer_.length;
1: 
0:           int lobLength = 0;
0:           if(clearedByte.length > 32767) {  //for extended length, length is the 4 bytes that follow codepoint
0:             lobLength = ( (clearedByte[4] & 0xFF) << 24) +
0:                 ( (clearedByte[5] & 0xFF) << 16) +
0:                 ( (clearedByte[6] & 0xFF) << 8) +
0:                 ( (clearedByte[7] & 0xFF) << 0);
0:             longValueForDecryption_ = new byte[lobLength];
0:             System.arraycopy (clearedByte, 8, longValueForDecryption_, 0, clearedByte.length-8);
1:           }
0:           else {
0:             lobLength = ( (clearedByte[0] & 0xFF) << 8) +
0:                 ( (clearedByte[1] & 0xFF) << 0);
0:             longValueForDecryption_ = new byte[lobLength-4];
0:             System.arraycopy (clearedByte, 4, longValueForDecryption_, 0, clearedByte.length-4);
1:           }
1:         }
1: 
0:         else{
0:         int bytesRead = ensureALayerDataInBuffer (dssLength_);  //we need to get back all the data here, and then decrypt
0:         if (bytesRead > 0) //we ensuredALayerDAtaInBuffer here and set the flag to true, so we don't need do this again later
0:           ensuredLengthForDecryption_ = true;
0:         byte[] encryptedByte = new byte[dssLength_];
0:         System.arraycopy(buffer_,pos_,encryptedByte,0,dssLength_);
0:         byte[] array1 = new byte[pos_];
0:         System.arraycopy(buffer_,0,array1,0,pos_);  //save the data before encrypted data in array1
0:         byte[] array3 = new byte[buffer_.length - dssLength_ - pos_];
0:         System.arraycopy(buffer_,pos_+dssLength_,array3,0,buffer_.length - dssLength_ - pos_); //save the data follows encrypted data in array3
0:         byte[] clearedByte = null;
0:         try{
0:           clearedByte = netAgent_.netConnection_.getEncryptionManager().decryptData(
0:               encryptedByte,
0:               NetConfiguration.SECMEC_EUSRIDPWD,
0:               netAgent_.netConnection_.getTargetPublicKey(),
0:               netAgent_.netConnection_.getTargetPublicKey());
1:         }
0:         catch (SqlException e)
0:         {
0:           //throw new SqlException (agent_.logWriter_, "error in decrypting data");
1:         }
0:         dssLength_ -= (encryptedByte.length - clearedByte.length);
0:         byte[] buffer = new byte[array1.length + clearedByte.length + array3.length];
0:         System.arraycopy(array1,0,buffer,0,array1.length);
0:         System.arraycopy(clearedByte,0,buffer,array1.length,clearedByte.length);
0:         System.arraycopy(array3,0,buffer,array1.length+clearedByte.length,array3.length);
0:         buffer_ = buffer;
0:         int oldCount = count_;
0:         count_ = count_ - (encryptedByte.length - clearedByte.length);
0:         if (((clearedByte[2]& 0xff) << 8) + ((clearedByte[3] & 0xff) << 0) == 0x146c) {
0:           int firstLobLength = ( (clearedByte[0] & 0xFF) << 8) +
0:                 ( (clearedByte[1] & 0xFF) << 0);
1: 
0:           boolean flag = false;
0:           if (gdsFormatter == 0x54)
0:             flag = true;
0:           if(flag){
0:              if (oldCount - oldDssLength < 6) {
0:                int totalBytesRead = fill(6); //sometimes the 2nd EXTDTA doesn't come back, need to fetch again to get it
0:                if (totalBytesRead > 0) {
0:                  longBufferForDecryption_ = new byte[totalBytesRead];
0:                  longPosForDecryption_ = 0;
0:                  System.arraycopy(buffer_, pos_ + firstLobLength, longBufferForDecryption_, 0,
0:                                   totalBytesRead);
1:                }
1: 
1:   }
0:              else {
0:                longBufferForDecryption_ = new byte[count_ - pos_ - firstLobLength];
0:                longPosForDecryption_ = 0;
0:                System.arraycopy(buffer_, pos_ + firstLobLength, longBufferForDecryption_, 0,
0:                                 longBufferForDecryption_.length);
1: 
1:              }
0:          } //end if(flag)
0:          int lobLength = ( (clearedByte[0] & 0xFF) << 8) +
0:               ( (clearedByte[1] & 0xFF) << 0) - 4;
1: 
0:          longValueForDecryption_ = new byte[lobLength];
1: 
0:          System.arraycopy (clearedByte, 4, longValueForDecryption_, 0, clearedByte.length - 4);  //copy the decrypted lob value (excluded length an dcodepoint) to longValue_
1:         }
0:         else if (((clearedByte[2]& 0xff) << 8) + ((clearedByte[3] & 0xff) << 0) == 0x241B){
0:           int length = ( (clearedByte[0] & 0xFF) << 8) +
0:               ( (clearedByte[1] & 0xFF) << 0);
0:           boolean noData = false;
0:           if  (clearedByte[4] == -1 && clearedByte[5] == -1)
0:               noData = true; //there is no data, no need to do the copy
0:           if (!noData) {
0:               if (length == 32776) {
0:                 length = ( (clearedByte[4] & 0xFF) << 24) +
0:                     ( (clearedByte[5] & 0xFF) << 16) +
0:                     ( (clearedByte[6] & 0xFF) << 8) +
0:                     ( (clearedByte[7] & 0xFF) << 0);
0:                 longValueForDecryption_ = new byte[length];
0:                 System.arraycopy (clearedByte, 8, longValueForDecryption_, 0,
0:                                   clearedByte.length - 8);
0:                 longCountForDecryption_ = count_ - (pos_ + length + 8);
0:                 longBufferForDecryption_ = new byte[buffer_.length - pos_ - length - 8];
0:                 System.arraycopy(buffer_, pos_ + length + 8, longBufferForDecryption_, 0,
0:                                    longBufferForDecryption_.length);
1: 
1:               }
0:               else {
0:                 longPosForDecryption_ = 0;
0:                 longCountForDecryption_ = count_ - (pos_ + length);
0:                 longBufferForDecryption_ = new byte[buffer_.length - pos_ - length];
0:                 System.arraycopy (buffer_, pos_ + length, longBufferForDecryption_, 0,
0:                                    longBufferForDecryption_.length);
1: 
0:                 longValueForDecryption_ = new byte[length - 4];
1: 
0:                 System.arraycopy (clearedByte, 4, longValueForDecryption_, 0,
0:                                   clearedByte.length - 4);
1:               }
1:             }
1:         }
1:       }
1:     }
1: 
1: 
0:   final int readUnsignedShort () throws org.apache.derby.client.am.DisconnectException
0:   {
0:     // should we be checking dss lengths and ddmScalarLengths here 
0:     // if yes, i am not sure this is the correct place if we should be checking 
0:     ensureBLayerDataInBuffer (2);
0:     adjustLengths (2);
0:     return ((buffer_[pos_++] & 0xff) << 8) +
0:       ((buffer_[pos_++] & 0xff) << 0);
1:   }
1: 
0:   final short readShort () throws org.apache.derby.client.am.DisconnectException
0:   {
0:     // should we be checking dss lengths and ddmScalarLengths here 
0:     ensureBLayerDataInBuffer (2);
0:     adjustLengths (2);
0:     short s = SignedBinary.getShort (buffer_, pos_);
1: 
0:     pos_ += 2;
1: 
0:     return s;
1:   }
1: 
0:   final int readInt () throws org.apache.derby.client.am.DisconnectException
0:   {
0:     // should we be checking dss lengths and ddmScalarLengths here 
0:     ensureBLayerDataInBuffer (4);
0:     adjustLengths (4);
0:     int i = SignedBinary.getInt (buffer_, pos_);
0:     pos_ += 4;
1: 
0:     return i;
1:   }
1: 
0:   final void readIntArray (int[] array) throws org.apache.derby.client.am.DisconnectException
0:   {
0:     ensureBLayerDataInBuffer (array.length * 4);
0:     adjustLengths (array.length * 4);
1: 
0:     for (int i = 0; i < array.length; i++) {
0:       array[i] = SignedBinary.getInt (buffer_, pos_);
0:       pos_ += 4;
1:     }
1:   }
1: 
1: 
0:   final long readLong () throws org.apache.derby.client.am.DisconnectException
0:   {
0:     // should we be checking dss lengths and ddmScalarLengths here
0:     ensureBLayerDataInBuffer (8);
0:     adjustLengths (8);
0:     long l = SignedBinary.getLong (buffer_, pos_);
1: 
0:     pos_ += 8;
1: 
0:     return l;
1:   }
1: 
1: 
0:   final int [] readUnsignedShortList()  throws org.apache.derby.client.am.DisconnectException
0:   {
0:     int len = ddmScalarLen_;
0:     ensureBLayerDataInBuffer (len);
0:     adjustLengths (len);
1: 
0:     int count = len/2;
0:     int[] list = new int[count];
1: 
0:     for (int i=0; i < count; i++) {
0:       list[i] = ((buffer_[pos_++] & 0xff) << 8) +
0:         ((buffer_[pos_++] & 0xff) << 0);
1:     }
1: 
0:     return list;
1:   }
1: 
0:   final int readUnsignedByte () throws org.apache.derby.client.am.DisconnectException
0:   {
0:     ensureBLayerDataInBuffer (1);
0:     adjustLengths (1);
0:     return (buffer_[pos_++] & 0xff);
1:   }
1: 
0:   final byte readByte () throws org.apache.derby.client.am.DisconnectException
0:   {
0:     ensureBLayerDataInBuffer (1);
0:     adjustLengths (1);
0:     return (byte) (buffer_[pos_++] & 0xff);
1:   }
1: 
0:   final boolean readBoolean () throws org.apache.derby.client.am.DisconnectException
0:   {
0:     ensureBLayerDataInBuffer (1);
0:     adjustLengths (1);
0:     return buffer_[pos_++] != 0;
1:   }
1: 
0:   final String readString (int length) throws org.apache.derby.client.am.DisconnectException
0:   {
0:     ensureBLayerDataInBuffer (length);
0:     adjustLengths (length);
1: 
0:     String result = ccsidManager_.convertToUCS2 (buffer_, pos_, length);
0:     pos_ += length;
0:     return result;
1:   }
1: 
0:   final String readString (int length, String encoding) throws org.apache.derby.client.am.DisconnectException
0:   {
0:     ensureBLayerDataInBuffer (length);
0:     adjustLengths (length);
0:     String s = null;
1: 
0:     try {
0:       s = new String (buffer_, pos_, length, encoding);
1:     }
0:     catch (java.io.UnsupportedEncodingException e) {
0:       agent_.accumulateChainBreakingReadExceptionAndThrow (
0:         new org.apache.derby.client.am.DisconnectException (
0:           e,
0:           agent_,
0:           "encoding not supported!!"));
1:     }
1: 
0:     pos_ += length;
0:     return s;
1:   }
1: 
0:   final String readString () throws org.apache.derby.client.am.DisconnectException
0:   {
0:     int len = ddmScalarLen_;
0:     ensureBLayerDataInBuffer (len);
0:     adjustLengths (len);
0:     String result = ccsidManager_.convertToUCS2 (buffer_, pos_, len);
0:     pos_ += len;
0:     return result;
1:   }
1: 
0:   final byte[] readBytes (int length) throws org.apache.derby.client.am.DisconnectException
0:   {
0:     ensureBLayerDataInBuffer (length);
0:     adjustLengths (length);
1: 
0:     byte[] b = new byte[length];
0:     System.arraycopy (buffer_, pos_, b, 0, length);
0:     pos_ += length;
0:     return b;
1:   }
1: 
0:   final byte[] readBytes () throws org.apache.derby.client.am.DisconnectException
0:   {
0:     int len = ddmScalarLen_;
0:     ensureBLayerDataInBuffer (len);
0:     adjustLengths (len);
1: 
0:     byte[] b = new byte[len];
0:     System.arraycopy (buffer_, pos_, b, 0, len);
0:     pos_ += len;
0:     return b;
1:   }
1: 
0:   final byte[] readLDBytes () throws org.apache.derby.client.am.DisconnectException
0:   {
0:     ensureBLayerDataInBuffer (2);
0:     int len = ((buffer_[pos_++] & 0xff) << 8) + ((buffer_[pos_++] & 0xff) << 0);
1: 
0:     if (len == 0) {
0:       adjustLengths (2);
0:       return null;
1:     }
1: 
0:     ensureBLayerDataInBuffer (len);
0:     adjustLengths (len + 2);
1: 
0:     byte [] b = new byte[len];
0:     System.arraycopy (buffer_, pos_, b, 0, len);
0:     pos_ += len;
0:     return b;
1:   }
1: 
0:   final void skipBytes (int length) throws org.apache.derby.client.am.DisconnectException
0:   {
0:     ensureBLayerDataInBuffer (length);
0:     adjustLengths (length);
0:     pos_ += length;
1:   }
1: 
0:   final void skipBytes () throws org.apache.derby.client.am.DisconnectException
0:   {
0:     int len = ddmScalarLen_;
0:     ensureBLayerDataInBuffer (len);
0:     adjustLengths (len);
0:     pos_ += len;
1:   }
1: 
0:   // This will be the new and improved getData that handles all QRYDTA/EXTDTA
0:   // Returns the stream so that the caller can cache it
0:   final ByteArrayOutputStream getData (ByteArrayOutputStream existingBuffer) throws org.apache.derby.client.am.DisconnectException
0:   {
1:     boolean readHeader;
0:     int copySize;
0:     ByteArrayOutputStream baos;
1: 
0:     // note: an empty baos can yield an allocated and empty byte[]
0:     if (existingBuffer != null)
0:       baos = existingBuffer;
0:     else {
0:       if (ddmScalarLen_ != -1) {
0:         // allocate a stream based on a known amount of data
0:         baos = new ByteArrayOutputStream (ddmScalarLen_);
1:       }
0:       else {
0:         // allocate a stream to hold an unknown amount of data
0:         baos = new ByteArrayOutputStream ();
0:         //isLengthAndNullabilityUnknown = true;
1:       }
1:     }
1: 
0:     // set the amount to read for the first segment
0:     copySize = dssLength_; // note: has already been adjusted for headers
1: 
0:     do {
1:       // determine if a continuation header needs to be read after the data
0:       if (dssIsContinued_)
0:         readHeader = true;
0:       else
0:         readHeader = false;
1: 
1:       // read the segment
0:       ensureALayerDataInBuffer (copySize);
0:       adjustLengths (copySize);
0:       baos.write (buffer_, pos_, copySize);
1:       pos_ += copySize;
1: 
1:       // read the continuation header, if necessary
0:       if (readHeader)
0:         readDSSContinuationHeader ();
1: 
1:       copySize = dssLength_;
1:     }
0:     while (readHeader == true);
1: 
0:     return baos;
1:   }
1: 
0:   // reads a DSS continuation header
0:   // prereq: pos_ is positioned on the first byte of the two-byte header
0:   // post:   dssIsContinued_ is set to true if the continuation bit is on, false otherwise
0:   //         dssLength_ is set to DssConstants.MAX_DSS_LEN - 2 (don't count the header for the next read)
0:   // helper method for getEXTDTAData
0:   protected final void readDSSContinuationHeader () throws org.apache.derby.client.am.DisconnectException
0:   {
0:     ensureALayerDataInBuffer(2);
1: 
0:     dssLength_ =
0:       ((buffer_[pos_++]&0xFF) << 8) +
0:       ((buffer_[pos_++]&0xFF) << 0);
1: 
0:     if ((dssLength_ & 0x8000) == 0x8000) {
0:       dssLength_ = DssConstants.MAX_DSS_LEN;
0:       dssIsContinued_ = true;
1:     }
0:     else {
0:       dssIsContinued_ = false;
1:     }
0:     // it is a syntax error if the dss continuation header length
0:     // is less than or equal to two
0:     if (dssLength_ <= 2) {
0:       doSyntaxrmSemantics (CodePoint.SYNERRCD_DSS_CONT_LESS_OR_EQUAL_2);
1:     }
1: 
0:     dssLength_ -= 2;  // avoid consuming the DSS cont header
1:   }
1: 
1: 
0:   // As part of parsing the reply, the client can detect that the
0:   // data sent from the target agent does not structurally
0:   // conform to the requirements of the DDM architecture.  These are
0:   // the same checks performed by the target server on the messages
0:   // it receives from the protocolj code.  Server side detected errors
0:   // result in a SYNTAXRM being returned from the AS.  According to the
0:   // DDM manual, parsing of the DSS is terminated when the error is
0:   // detected.  The Syntax Error Code, SYNERRCD, describes the various errors.
0:   //
0:   // Note: Not all of these may be valid at the client.  See descriptions for
0:   // which ones make sense for client side errors/checks.
0:   // Syntax Error Code                  Description of Error
0:   // -----------------                  --------------------
0:   // 0x01                               Dss header Length is less than 6.
0:   // 0x02                               Dss header Length does not match the
0:   //                                    number of bytes of data found.
0:   // 0x03                               Dss header C-byte not D0.
0:   // 0x04                               Dss header f-bytes either not
0:   //                                    recognized or not supported.
0:   // 0x05                               DSS continuation specified but not found.
0:   //                                    For example, DSS continuation is specified
0:   //                                    on the last DSS, and the SNA LU 6.2 communication
0:   //                                    facility returned the SEND indicator.
0:   // 0x06                               DSS chaining specified but no DSS found.
0:   //                                    For example, DSS chaining is specified
0:   //                                    on the last DSS, and the SNA LU 6.2 communication
0:   //                                    facility returned the SEND indicator.
0:   // 0x07                               Object length less than four.  For example,
0:   //                                    a command parameter's length is specified
0:   //                                    as two, or a command's length is specified as three.
0:   // 0x08                               Object length does not match the number of bytes of data
0:   //                                    found.  For example, a RQSDSS with a length of 150
0:   //                                    contains a command whose length is 125 or a SRVDGN parameter
0:   //                                    specifies a length of 200 but there are only 50
0:   //                                    bytes left in the DSS.
0:   // 0x09                               Object length greater than maximum allowed.
0:   //                                    For example, a RECCNT parameter specifies a
0:   //                                    length of ten, but the parameter is defined
0:   //                                    to have a maximum length of eight.
0:   // 0x0A                               Object length less than the minimum required.
0:   //                                    For example, a SVRCOD parameter specifies a
0:   //                                    length of five, but the parameter is defined
0:   //                                    to have a fixed length of six.
0:   // 0x0B                               Object length not allowed.  For example,
0:   //                                    a FILEXDPT parameter is specified with a length of
0:   //                                    11, but this would indicate that only half of the hours
0:   //                                    field is present instead of the complete hours field.
0:   // 0x0C                               Incorrect large object extended length field (see
0:   //                                    description of DSS).  For example, an extended
0:   //                                    length field is present, but it is only three bytes
0:   //                                    long when it is defined to be a multiple of two bytes.
0:   // 0x0D                               Object code point index not supported.
0:   //                                    For example, a code point of 8032 is encountered
0:   //                                    but x'8' is a reserved code point index.
0:   // 0x0E                               Required object not found.  For example, a CLEAR
0:   //                                    command does not have a filnam parameter present,
0:   //                                    or a MODREC command is not followed by a RECORD
0:   //                                    command data object.
0:   // 0x0F                               Too many command data objects sent.  For example,
0:   //                                    a MODREC command is followed by two RECORD command
0:   //                                    command data objects, or a DECREC command is followed
0:   //                                    by RECORD object.
0:   // 0x10                               Mutually exclusive objects present.
0:   //                                    For example, a CRTDIRF command specifies both
0:   //                                    a DCLNAM and FILNAM parameters.
0:   // 0x11                               Too few command data objects sent.
0:   //                                    For example, an INSRECEF command that
0:   //                                    specified RECCNT95) is followed by only
0:   //                                    4 RECORD command data objects.
0:   // 0x12                               Duplicate object present.
0:   //                                    For example, a LSTFAT command has tow FILNAM
0:   //                                    parameters specified.
0:   // 0x13                               Invalid request correlator specified.
0:   //                                    Use PRCCNVRM with PRCCNVDC of 04 or 05 instead
0:   //                                    of this error code.  This error code is being retained
0:   //                                    for compatibility with Level 1 of the architecture.
0:   // 0x14                               Required value not found.
0:   // 0x15                               Reserved value not allowed.  For example,
0:   //                                    a INSRECEF command specified a RECCNT(0) parameter.
0:   // 0x16                               DSS continuation less than or equal to two.
0:   //                                    For example, the length bytes of the DSS continuation
0:   //                                    have the value of one.
0:   // 0x17                               Objects not in required order.  For example, a RECAL
0:   //                                    object contains a RECORD object followed by a RECNBR
0:   //                                    object with is not in the defined order.
0:   // 0x18                               DSS chaining byt not b'1', but DSSFMT bit3 set to b'1'.
0:   // 0x19                               Previous DSS indicated current DSS has the same
0:   //                                    request correlator, but the request correlators are
0:   //                                    not the same.
0:   // 0x1A                               DSS cahining bit not b'1', but error continuation requested.
0:   // 0x1B                               Mutually exclusive parameter values not specified.
0:   //                                    For example, an OPEN command specified PRPSHD(TRUE)
0:   //                                    and FILSHR(READER).
0:   // 0x1D                               Code point not valid command.  For example, the first
0:   //                                    code point in RQSDSS either is not in the dictionary
0:   //                                    or is not a code point for a command.
0:   //
0:   // When the client detects these errors, it will be handled as if a SYNTAXRM is returned
0:   // from the server.  In this SYNTAXRM case, PROTOCOL architects an SQLSTATE of 58008 or 58009.
0:   //
0:   // Messages
0:   // SQLSTATE : 58009
0:   //     Execution failed due to a distribution protocol error that caused deallocation of the conversation.
0:   //     SQLCODE : -30020
0:   //     Execution failed because of a Distributed Protocol
0:   //         Error that will affect the successful execution of subsequent
0:   //         commands and SQL statements: Reason Code <reason-code>.
0:   //      Some possible reason codes include:
0:   //      121C Indicates that the user is not authorized to perform the requested command.
0:   //      1232 The command could not be completed because of a permanent error.
0:   //          In most cases, the server will be in the process of an abend.
0:   //      220A The target server has received an invalid data description.
0:   //          If a user SQLDA is specified, ensure that the fields are
0:   //          initialized correctly. Also, ensure that the length does not
0:   //          exceed the maximum allowed length for the data type being used.
0:   //
0:   //      The command or statement cannot be processed.  The current
0:   //          transaction is rolled back and the application is disconnected
0:   //          from the remote database.
0:   final void doSyntaxrmSemantics (int syntaxErrorCode) throws org.apache.derby.client.am.DisconnectException
0:   {
0:     agent_.accumulateChainBreakingReadExceptionAndThrow (
0:       new org.apache.derby.client.am.DisconnectException (
0:         agent_,
0:         "Execution failed due to a distribution protocol error " +
0:         "that caused deallocation of the conversation.  " +
0:         "A PROTOCOL Data Stream Syntax Error was detected.  Reason: " +
0:         "0x" + Integer.toHexString (syntaxErrorCode),
0:         SqlState._58009));
1:   }
1: 
1: 
1: // the names of these methods start with a letter z.
1: // the z will be removed when they are finalized...
1: 
0:   protected final void pushLengthOnCollectionStack()
0:   {
0:     ddmCollectionLenStack_[++topDdmCollectionStack_] = ddmScalarLen_;
0:     ddmScalarLen_ = 0;
1:   }
1: 
0:   protected final void adjustLengths(int length)
0:   {
0:     ddmScalarLen_ -= length;
0:     adjustCollectionAndDssLengths (length);
1:     /*
0:     for (int i = 0; i <= topDdmCollectionStack_; i++) {
0:       ddmCollectionLenStack_[i] -= length;
1:     }
0:     dssLength_ -= length;
1:     */
1:   }
1: 
0:   protected int adjustDdmLength (int ddmLength, int length)
0:   {
0:     ddmLength -= length;
0:     if (ddmLength == 0)
0:       adjustLengths (getDdmLength());
0:     return ddmLength;
1:   }
1: 
0:   // Pop the collection Length stack.
0:   // pre:  The collection length stack must not be empty and the top value
0:   //       on the stack must be 0.
0:   // post: The top 0 value on the stack will be popped.
0:   protected final void popCollectionStack()
0:   {
0:     topDdmCollectionStack_--;
1:   }
1: 
0:   protected final int peekCodePoint() throws org.apache.derby.client.am.DisconnectException
0:   {
0:     if (topDdmCollectionStack_ != EMPTY_STACK) {
0:       if (ddmCollectionLenStack_[topDdmCollectionStack_] == 0)
0:         return END_OF_COLLECTION;
0:       else if (ddmCollectionLenStack_[topDdmCollectionStack_] < 4) {
0:         // error
1:       }
1:     }
1: 
0:     // if there is no more data in the current dss, and the dss is not
0:     // continued, indicate the end of the same Id chain or read the next dss header.
0:     if ((dssLength_ == 0) && (!dssIsContinued_)) {
0:       if (!dssIsChainedWithSameID_) {
0:         return END_OF_SAME_ID_CHAIN;
1:       }
0:       readDssHeader();
1:     }
1: 
0:     if (longBufferForDecryption_ == null)  //we don't need to do this if it's data stream encryption
0:     ensureBLayerDataInBuffer (4);
0:     peekedLength_ = ((buffer_[pos_] & 0xff) << 8) + ((buffer_[pos_+1] & 0xff) << 0);
0:     peekedCodePoint_ = ((buffer_[pos_+2] & 0xff) << 8) + ((buffer_[pos_+3] & 0xff) << 0);
1: 
0:     // check for extended length
0:     if ((peekedLength_ & 0x8000) == 0x8000)
0:       peekExtendedLength();
0:     else
0:       peekedNumOfExtendedLenBytes_ = 0;
0:     return peekedCodePoint_;
1:   }
1: 
0:   // Read out the 2-byte length without moving the pos_ pointer.
0:   protected final int peekLength() throws org.apache.derby.client.am.DisconnectException
0:   {
0:     ensureBLayerDataInBuffer (2);
0:     return (((buffer_[pos_] & 0xff) << 8) +
0:             ((buffer_[pos_ + 1] & 0xff) << 0));
1:   }
1: 
0:   // Read "length" number of bytes from the buffer into the byte array b starting from offset
0:   // "offset".  The current offset in the buffer does not change.
0:   protected final int peekFastBytes (byte[] b, int offset, int length) throws org.apache.derby.client.am.DisconnectException
0:   {
0:     for (int i = 0; i < length; i++) {
0:       b[offset+i] = buffer_[pos_+i];
1:     }
0:     return offset+length;
1:   }
1: 
0:   protected final void parseLengthAndMatchCodePoint (int expectedCodePoint) throws org.apache.derby.client.am.DisconnectException
0:   {
0:     int actualCodePoint = 0;
0:     if (peekedCodePoint_ == END_OF_COLLECTION)
0:       actualCodePoint = readLengthAndCodePoint();
0:     else {
0:       actualCodePoint = peekedCodePoint_;
0:       pos_ += (4 + peekedNumOfExtendedLenBytes_);
0:       ddmScalarLen_ = peekedLength_;
0:       if (peekedNumOfExtendedLenBytes_ == 0 && ddmScalarLen_ != -1) {
0:         adjustLengths (4);
1:       }
0:       else {
0:         adjustCollectionAndDssLengths (4+peekedNumOfExtendedLenBytes_);
1:       }
0:       peekedLength_ = 0;
0:       peekedCodePoint_ = END_OF_COLLECTION;
0:       peekedNumOfExtendedLenBytes_ = 0;
1:     }
1: 
0:     if (actualCodePoint != expectedCodePoint) {
0:       zThrowSyntaxError ("actual code point, " + actualCodePoint +
0:                          " does not match expected code point, " + expectedCodePoint);
1:     }
1:   }
0:   protected final int readLengthAndCodePoint () throws org.apache.derby.client.am.DisconnectException
0:   {
0:     if (topDdmCollectionStack_ != EMPTY_STACK) {
0:       if (ddmCollectionLenStack_[topDdmCollectionStack_] == 0)
0:         return END_OF_COLLECTION;
0:       else if (ddmCollectionLenStack_[topDdmCollectionStack_] < 4) {
0:         zThrowSyntaxError ("ddm collection contains less than 4 bytes of data");
1:       }
1:     }
1: 
0:     // if there is no more data in the current dss, and the dss is not
0:     // continued, indicate the end of the same Id chain or read the next dss header.
0:     if ((dssLength_ == 0) && (!dssIsContinued_)) {
0:       if (!dssIsChainedWithSameID_) {
0:         return END_OF_SAME_ID_CHAIN;
1:       }
0:       readDssHeader();
1:     }
1: 
0:     ensureBLayerDataInBuffer (4);
0:     ddmScalarLen_ =
0:       ((buffer_[pos_++] & 0xff) << 8) +
0:       ((buffer_[pos_++] & 0xff) << 0);
0:     int codePoint = ((buffer_[pos_++] & 0xff) << 8) +
0:       ((buffer_[pos_++] & 0xff) << 0);
0:     adjustLengths (4);
1: 
0:     // check for extended length
0:     if ((ddmScalarLen_ & 0x8000) == 0x8000) {
0:       readExtendedLength();
1:     }
0:     return codePoint;
1:   }
1: 
0:   private final void readExtendedLength() throws org.apache.derby.client.am.DisconnectException
0:   {
0:     int numberOfExtendedLenBytes = (ddmScalarLen_ - 0x8000); // fix scroll problem was - 4
0:     int adjustSize = 0;
0:     switch (numberOfExtendedLenBytes) {
0:     case 4:
0:       ensureBLayerDataInBuffer (4);
0:       ddmScalarLen_ =
0:         ((buffer_[pos_++] & 0xff) << 32) +
0:         ((buffer_[pos_++] & 0xff) << 16) +
0:         ((buffer_[pos_++] & 0xff) << 8) +
0:         ((buffer_[pos_++] & 0xff) << 0);
0:       adjustSize = 4;     
0:       break;
0:     case 0:
0:       ddmScalarLen_ = -1; 
0:       adjustSize = 0;    
0:       break;
0:     default:
0:       doSyntaxrmSemantics(CodePoint.SYNERRCD_INCORRECT_EXTENDED_LEN);
1:     }
1: 
0:     adjustCollectionAndDssLengths (adjustSize);
1:     /*
0:     // adjust the lengths here.  this is a special case since the
0:     // extended length bytes do not include their own length.
0:     for (int i = 0; i <= topDdmCollectionStack_; i++) {
0:       ddmCollectionLenStack_[i] -= adjustSize;
1:     }
0:     dssLength_ -= adjustSize;
1:     */
1:   }
1: 
0:   private final void adjustCollectionAndDssLengths (int length)
0:   {
0:     // adjust the lengths here.  this is a special case since the
0:     // extended length bytes do not include their own length.
0:     for (int i = 0; i <= topDdmCollectionStack_; i++) {
0:       ddmCollectionLenStack_[i] -= length;
1:     }
0:     dssLength_ -= length;
1:   }
1: 
0:   protected final void startSameIdChainParse() throws org.apache.derby.client.am.DisconnectException
0:   {
0:     readDssHeader ();
0:     netAgent_.clearSvrcod();
1:   }
1: 
0:   protected final void endOfSameIdChainData() throws org.apache.derby.client.am.DisconnectException
0:   {
0:     netAgent_.targetTypdef_ = netAgent_.originalTargetTypdef_;
0:     netAgent_.targetSqlam_ = netAgent_.orignalTargetSqlam_;
1: 
0:     if (this.topDdmCollectionStack_ != Reply.EMPTY_STACK) {
0:       zThrowSyntaxError ("collection stack not empty at end of same id chain parse");
1:     }
0:     if (this.dssLength_ != 0) {
0:       zThrowSyntaxError ("dss length not 0 at end of same id chain parse");
1:     }
0:     if (dssIsChainedWithSameID_ == true) {
0:       zThrowSyntaxError ("dss chained with same id at end of same id chain parse");
1:     }
1:   }
1: 
0:   private final void zThrowSyntaxError (String error) throws org.apache.derby.client.am.DisconnectException
0:   {
0:     agent_.accumulateChainBreakingReadExceptionAndThrow (
0:       new org.apache.derby.client.am.DisconnectException (agent_, error));
1:   }
1: 
0:   protected final int peekTotalColumnCount (int tripletLength) throws org.apache.derby.client.am.DisconnectException
0:   {
0:     int columnCount = 0;
0:     int offset = 0;
0:     int tripletType = FdocaConstants.CPT_TRIPLET_TYPE;
0:     while (tripletType == FdocaConstants.CPT_TRIPLET_TYPE) {
0:       columnCount += ((tripletLength-3)/3);
0:       // Peek ahead for the next triplet's tripletLength and tripletType.
0:       // The number of bytes to skip before the next tripletType is tripletLength - 3.
0:       ensureBLayerDataInBuffer (tripletLength-3);
0:       offset += (tripletLength-3);
0:       tripletLength = (buffer_[pos_+offset++] & 0xff);
0:       tripletType = (buffer_[pos_+offset++] & 0xff);
0:       // Skip the 1-byte tripletId.
0:       offset++;
1:     }
0:     return columnCount;
1:   }
1: 
0:   private final void peekExtendedLength () throws org.apache.derby.client.am.DisconnectException
0:   {
0:     peekedNumOfExtendedLenBytes_ = (peekedLength_ - 0x8004);
0:     switch (peekedNumOfExtendedLenBytes_) {
0:     case 4:
0:       // L   L   C   P  Extended Length
0:       // -->2-bytes<--  --->4-bytes<---
0:       // We are only peeking the length here, the actual pos_ is still before LLCP.  We ensured
0:       // 4-bytes in peedCodePoint() for the LLCP, and we need to ensure 4-bytes(of LLCP) + the
0:       // extended length bytes here.
0:       if (longBufferForDecryption_ == null ) //we ddon't need to do this if it's data stream encryption
0:       ensureBLayerDataInBuffer (4 + 4);
0:       // The ddmScalarLen_ we peek here does not include the LLCP and the extended length bytes
0:       // themselves.  So we will add those back to the ddmScalarLen_ so it can be adjusted
0:       // correctly in parseLengthAndMatchCodePoint(). (since the adjustLengths() method will
0:       // subtract the length from ddmScalarLen_)
0:       peekedLength_ =
0:         ((buffer_[pos_+4] & 0xff) << 32) +
0:         ((buffer_[pos_+5] & 0xff) << 16) +
0:         ((buffer_[pos_+6] & 0xff) << 8) +
0:         ((buffer_[pos_+7] & 0xff) << 0);
0:       break;
0:     case 0:
0:       peekedLength_ = -1; // this ddm is streamed, so set -1 -> length unknown
0:       break;
0:     default:
0:       doSyntaxrmSemantics(CodePoint.SYNERRCD_INCORRECT_EXTENDED_LEN);
1:     }
1:   }
1: 
0:   final int readFastUnsignedByte () throws org.apache.derby.client.am.DisconnectException
0:   {
0:     return (buffer_[pos_++] & 0xff);
1:   }
1: 
0:   final short readFastShort () throws org.apache.derby.client.am.DisconnectException
0:   {
0:     short s = SignedBinary.getShort (buffer_, pos_);
0:     pos_ += 2;
0:     return s;
1:   }
1: 
0:   final int readFastUnsignedShort () throws org.apache.derby.client.am.DisconnectException
0:   {
0:     return ((buffer_[pos_++] & 0xff) << 8) +
0:       ((buffer_[pos_++] & 0xff) << 0);
1:   }
1: 
0:   final int readFastInt () throws org.apache.derby.client.am.DisconnectException
0:   {
0:     int i = SignedBinary.getInt (buffer_, pos_);
0:     pos_ += 4;
0:     return i;
1:   }
1: 
0:   final String readFastString (int length) throws org.apache.derby.client.am.DisconnectException
0:   {
0:     String result = ccsidManager_.convertToUCS2 (buffer_, pos_, length);
0:     pos_ += length;
0:     return result;
1:   }
1: 
0:   final byte[] readFastBytes (int length) throws org.apache.derby.client.am.DisconnectException
0:   {
0:     byte[] b = new byte[length];
0:     System.arraycopy (buffer_, pos_, b, 0, length);
0:     pos_ += length;
0:     return b;
1:   }
1: 
0:   protected final int peekFastLength() throws org.apache.derby.client.am.DisconnectException
0:   {
0:     return (((buffer_[pos_] & 0xff) << 8) +
0:             ((buffer_[pos_ + 1] & 0xff) << 0));
1:   }
1: 
0:   final void skipFastBytes (int length) throws org.apache.derby.client.am.DisconnectException
0:   {
0:     pos_ += length;
1:   }
1: 
0:   final void readFastIntArray (int[] array) throws org.apache.derby.client.am.DisconnectException
0:   {
0:     for (int i = 0; i < array.length; i++) {
0:       array[i] = SignedBinary.getInt (buffer_, pos_);
0:       pos_ += 4;
1:     }
1:   }
1: 
0:   final String readFastString (int length, String encoding) throws org.apache.derby.client.am.DisconnectException
0:   {
0:     String s = null;
1: 
0:     try {
0:       s = new String (buffer_, pos_, length, encoding);
1:     }
0:     catch (java.io.UnsupportedEncodingException e) {
0:       agent_.accumulateChainBreakingReadExceptionAndThrow (
0:         new org.apache.derby.client.am.DisconnectException (
0:           e,
0:           agent_,
0:           "encoding not supported!!"));
1:     }
0:     pos_ += length;
0:     return s;
1:   }
1: 
0:   final byte[] readFastLDBytes () throws org.apache.derby.client.am.DisconnectException
0:   {
0:     int len = ((buffer_[pos_++] & 0xff) << 8) + ((buffer_[pos_++] & 0xff) << 0);
0:     if (len == 0) return null;
1: 
0:     byte [] b = new byte[len];
0:     System.arraycopy (buffer_, pos_, b, 0, len);
0:     pos_ += len;
0:     return b;
1:   }
0:   final long readFastLong () throws org.apache.derby.client.am.DisconnectException
0:   {
0:     long l = SignedBinary.getLong (buffer_, pos_ );
0:     pos_ += 8;
0:     return l;
1:   }
1: 
0:   final byte readFastByte () throws org.apache.derby.client.am.DisconnectException
0:   {
0:     return (byte) (buffer_[pos_++] & 0xff);
1: }
1: 
0:   final void mark()
0:   {
0:     currentPos_ = pos_;
1:   }
1: 
0:   // remove and return the top offset value from mark stack.
0:   final int popMark()
0:   {
0:     return currentPos_;
1:   }
1: 
0:   final int getFastSkipSQLCARDrowLength ()
0:   {
0:     return pos_ - popMark();
1:   }
1: 
0:   // The only difference between this method and the original getData() method is this method
0:   // is not doing an ensureALayerDataInBuffer
0:   final ByteArrayOutputStream getFastData (ByteArrayOutputStream existingBuffer) throws org.apache.derby.client.am.DisconnectException
0:   {
1:     boolean readHeader;
0:     int copySize;
0:     ByteArrayOutputStream baos;
1: 
0:     // note: an empty baos can yield an allocated and empty byte[]
0:     if (existingBuffer != null)
0:       baos = existingBuffer;
0:     else {
0:       if (ddmScalarLen_ != -1) {
0:         // allocate a stream based on a known amount of data
0:         baos = new ByteArrayOutputStream (ddmScalarLen_);
1:       }
0:       else {
0:         // allocate a stream to hold an unknown amount of data
0:         baos = new ByteArrayOutputStream ();
0:         //isLengthAndNullabilityUnknown = true;
1:       }
1:     }
1: 
0:     // set the amount to read for the first segment
0:     copySize = dssLength_; // note: has already been adjusted for headers
1: 
0:     do {
1:       // determine if a continuation header needs to be read after the data
0:       if (dssIsContinued_)
0:         readHeader = true;
0:       else
0:         readHeader = false;
1: 
1:       // read the segment
0:       //ensureALayerDataInBuffer (copySize);
0:       adjustLengths (copySize);
0:       baos.write (buffer_, pos_, copySize);
1:       pos_ += copySize;
1: 
1:       // read the continuation header, if necessary
0:       if (readHeader)
0:         readDSSContinuationHeader ();
1: 
1:       copySize = dssLength_;
1:     }
0:     while (readHeader == true);
1: 
0:     return baos;
1:   }
1: 
0:   // This method is only used to match the codePoint for those class instance variables
0:   // that are embedded in other reply messages.
0:   final protected void matchCodePoint (int expectedCodePoint) throws org.apache.derby.client.am.DisconnectException
0:   {
0:     int actualCodePoint = 0;
0:     actualCodePoint = peekedCodePoint_;
0:     pos_ += 4;
0:     if (actualCodePoint != expectedCodePoint) {
0:       zThrowSyntaxError ("actual code point, " + actualCodePoint +
0:                          " does not match expected code point, " + expectedCodePoint);
1:     }
1:   }
1: 
1: 
0:   protected final int peekNumOfColumns () throws org.apache.derby.client.am.DisconnectException
0:   {
0:     // skip the 4-byte LLCP and any extended length bytes + 1-byte null sqlcagrp null indicator
0:     int offset = (4 + peekedNumOfExtendedLenBytes_ + 1);
1: 
0: 	offset = skipSQLDHROW (offset);
1: 
0:     return SignedBinary.getShort (buffer_, pos_+offset);
1:   }
1: 
0:   protected final boolean peekForNullSqlcagrp ()
0:   {
0:     // skip the 4-byte LLCP and any extended length bytes
0:     int offset = (4 + peekedNumOfExtendedLenBytes_);
0:     int nullInd = buffer_[pos_+offset] & 0xff;
0:     return (nullInd == CodePoint.NULLDATA);
1:   }
1: 
0:   private final int skipSQLDHROW (int offset) throws org.apache.derby.client.am.DisconnectException
0:   {
0:     int sqldhrowgrpNullInd = buffer_[pos_+offset++]  & 0xff;
0:     if (sqldhrowgrpNullInd == CodePoint.NULLDATA)
0:       return offset;
1: 
0:     offset += 12;
1: 
0:     // skip sqldrdbnam
0:     int stringLength = ((buffer_[pos_+offset++] & 0xff) << 8) +
0:                        ((buffer_[pos_+offset++] & 0xff) << 0);
0:     offset += stringLength;
1: 
0:     // skip sqldschema
0:     stringLength = ((buffer_[pos_+offset++] & 0xff) << 8) +
0:                    ((buffer_[pos_+offset++] & 0xff) << 0);
0:     offset += stringLength;
1: 
0:     stringLength = ((buffer_[pos_+offset++] & 0xff) << 8) +
0:                    ((buffer_[pos_+offset++] & 0xff) << 0);
0:     offset += stringLength;
1: 
0:     return offset;
1:   }
1: }
1: 
1: 
1: 
1: 
============================================================================