1:eac0369: /*
5:eac0369: 
1:345de35:    Derby - Class org.apache.derby.impl.store.raw.data.AllocExtent
1:345de35: 
1:270a34d:    Licensed to the Apache Software Foundation (ASF) under one or more
1:270a34d:    contributor license agreements.  See the NOTICE file distributed with
1:270a34d:    this work for additional information regarding copyright ownership.
1:270a34d:    The ASF licenses this file to you under the Apache License, Version 2.0
1:270a34d:    (the "License"); you may not use this file except in compliance with
1:270a34d:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:345de35: 
2:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.store.raw.data;
1:eac0369: 
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: import org.apache.derby.iapi.store.raw.ContainerHandle;
1:04a2f12: import org.apache.derby.iapi.store.raw.xact.RawTransaction; 
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.io.FormatableBitSet;
1:eac0369: 
1:eac0369: import java.io.Externalizable;
1:eac0369: import java.io.IOException;
1:eac0369: 
1:eac0369: import java.io.ObjectOutput;
1:eac0369: import java.io.ObjectInput;
1:eac0369: 
2:eac0369: /**
1:eac0369: 
1:eac0369: 	An allocation extent row manages the page status of page in the extent.
1:eac0369: 	AllocExtent is externalizable and is written to the AllocPage directly,
1:eac0369: 	without being converted to a row first.
1:eac0369: 	<P>
1:eac0369: 	<PRE>
1:787ceb4: 	@derby.formatId	none, format implied by AllocPage's format
1:787ceb4: 	@derby.purpose	manage page status of page in extent
1:787ceb4: 	@derby.upgrade
1:787ceb4: 	@derby.diskLayout
1:eac0369: 		extentOffset(long) the begin physical byte offset of the first page of this extent
1:eac0369: 		extentStart(long) the first logical page mananged by this extent.
1:eac0369: 		extentEnd(long) the last page this extent can ever hope to manage 
1:eac0369: 		extentLength(int) the number of pages allocated in this extent
1:eac0369: 		extentStatus(int) status bits for the whole extent.
1:eac0369: 				HAS_DEALLOCATED - most likely, this extent has a deallocated 
1:eac0369:                         page somewhere
1:eac0369: 						If !HAD_DEALLOCATED, the extent has no deallocated page
1:eac0369: 				HAS_FREE - most likely, this extent has a free page somewhere
1:eac0369: 						If !HAS_FREE, there is no free page in the extent
1:eac0369: 				ALL_FREE - most likely, this extent only has free pages, good 
1:eac0369:                         candidate for shrinking the file.
1:eac0369: 						If !ALL_FREE, the extent is not all free
1:eac0369: 				HAS_UNFILLED_PAGES - most likely, this extent has unfilled pages.
1:eac0369: 						if !HAS_UNFILLED_PAGES, all pages are filled
1:eac0369: 				KEEP_UNFILLED_PAGES - this extent keeps track of unfilled pages
1:eac0369: 						(post v1.3).  If not set, this extent has no notion of
1:eac0369: 						unfilled page and has no unFilledPage bitmap.
1:eac0369: 				NO_DEALLOC_PAGE_MAP - this extents do not have a dealloc and a
1:eac0369: 						free page bit maps.  Prior to 2.0, there are 2 bit
1:eac0369: 						maps, a deallocate page bit map and a free page bit
1:eac0369: 						map.  Cloudscape 2.0 and later merged the dealloc page
1:eac0369: 						bit map into the free page bit map.
1:eac0369: 				RETIRED - this extent contains only 'retired' pages, never use 
1:eac0369:                         any page from this extent.  The pages don't actually 
1:eac0369:                         exist, i.e., it maps to nothing (physicalOffset is 
1:eac0369:                         garbage).  The purpose of this extent is to blot out a 
1:eac0369:                         range of logical page numbers that no longer exists 
1:eac0369:                         for this container.  Use this to reuse a physical page
1:eac0369:                         when a logical page has exhausted all recordId or for
1:eac0369:                         logical pages that has been shrunk out.
1:eac0369: 		preAllocLength(int)  the number of pages that have been preallocated
1:eac0369: 		reserved1(int)
1:eac0369: 		reserved2(long)	reserved for future use
1:eac0369: 		reserved3(long)	reserved for future use
1:eac0369: 		FreePages(bit)	bitmap of free pages
1:eac0369: 				Bit[i] is ON iff page i is free for immediate (re)use.
1:eac0369: 		[
1:eac0369: 		    on disk version before 2.0
1:eac0369: 				deAllocPages(bit) bitmap of deallocated pages
1:eac0369: 				Bit[i] is ON iff page i has been deallocated.
1:eac0369: 		]
1:eac0369: 		unFilledPages(bit)	bitmap of pages that has free space
1:eac0369: 				Bit[i] is ON if page i is likely to be < 1/2 full
1:eac0369: 
1:eac0369: 		org.apache.derby.iapi.services.io.FormatableBitSet is used to store the bit map.  
1:eac0369:             FormatableBitSet is an externalizable class.
1:eac0369: 
1:787ceb4: 	@derby.endFormat
1:eac0369: 
1:eac0369: 	<PRE>
1:eac0369: 	A page can have the following logical state:
1:eac0369: 	<BR>Free - a page that is free to be used
1:eac0369: 	<BR>Valid - a page that is currently in use
1:eac0369: 	<P>
1:eac0369: 	There is another type of transitional pages which pages that have been
1:eac0369: 	allocated on disk but has not yet been used.  These pages are Free.
1:eac0369: 	<P>
1:eac0369: 	Bit[K] freePages
1:eac0369: 		Bit[i] is ON iff page i maybe free for reuse.  User must get the
1:eac0369: 		dealloc page lock on the free page to make sure the transaction.
1:eac0369: 	<P>
1:eac0369: 	K is the size of the bit array, it must be >= length.
1:eac0369: 
1:eac0369: 	@see AllocPage
1:eac0369: */
1:eac0369: 
1:eac0369: 
1:eac0369: public class AllocExtent implements Externalizable
1:eac0369: {
1:eac0369: 	private long extentOffset;	// begin physical offset
1:eac0369: 	private long extentStart;	// first logical page number
1:eac0369: 	private long extentEnd;		// last logical page number
1:eac0369: 	// page[extentStart] to page[extentEnd] are the pages in the range of this
1:eac0369: 	// alloc extent.
1:eac0369: 	// page[exentStart] to page[extentStart+extentLength-1] are actually
1:eac0369: 	// allocated in this extent
1:eac0369: 	// when the extent is completely allocated,
1:eac0369: 	// extentEnd == extentStart+extentLength -1
1:44fe060: 
1:eac0369: 	private int extentLength;	// number of pages allocated in the extent
1:eac0369: 
1:eac0369: 	int extentStatus;
1:eac0369: 
1:eac0369: 	private int preAllocLength;
1:eac0369: 
1:eac0369: 	private int reserved1;
1:eac0369: 	private long reserved2;
1:eac0369: 	private long reserved3;
1:eac0369: 
1:eac0369: 	// extent Status bits
1:eac0369: 	private static final int HAS_DEALLOCATED = 0x1;
1:eac0369: 	private static final int HAS_FREE = 0x2;
1:eac0369: 	private static final int ALL_FREE = 0x4;
1:eac0369: 	private static final int HAS_UNFILLED_PAGES = 0x10;
1:eac0369: 	private static final int KEEP_UNFILLED_PAGES = 0x10000000;
1:eac0369: 	private static final int NO_DEALLOC_PAGE_MAP = 0x20000000;
1:eac0369: 	private static final int RETIRED = 0x8;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		public Per Page status
1:eac0369: 	*/
1:eac0369: 	protected static final int ALLOCATED_PAGE = 0;
1:eac0369: 	protected static final int DEALLOCATED_PAGE = 1;
1:eac0369: 	protected static final int FREE_PAGE = 2;
1:eac0369: 
1:eac0369: 
1:eac0369: 	// a page which is not a freePage is a regular old
1:eac0369: 	// allocated page.  Only an allocated page can be unFilled.
1:eac0369: 	FormatableBitSet freePages;
1:eac0369: 	FormatableBitSet unFilledPages;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Statically calculates how many pages this extent can manage given the
1:eac0369: 		availspace number of bytes to store this extent in
1:eac0369: 
1:eac0369: 		if read/writeExternal changes, this must change too
1:eac0369: 	*/
1:eac0369: 	protected static int MAX_RANGE(int availspace)
1:eac0369: 	{
1:eac0369: 		/* extent Offset, Start, End, Length, Status, preAllocLength, reserved1,2,3 */
1:eac0369: 		int bookkeeping = 	8 /* offset */ +
1:eac0369: 							8 /* start */ +
1:eac0369: 							8 /* end */ +
1:eac0369: 							4 /* length */ +
1:eac0369: 							4 /* status */ +
1:eac0369: 							4 /* preAllocLength */ +
1:eac0369: 							4 /* reserved1 */ +
1:eac0369: 							8 /* reserved2 */ +
1:eac0369: 							8 /* reserved3 */;
1:eac0369: 		availspace -= bookkeeping;
1:eac0369: 
1:eac0369: 		// each bit array is allowed to the 1/3 the remaining space
1:eac0369: 		availspace /= 3;
1:eac0369: 
1:eac0369: 		if (availspace <= 0)
1:eac0369: 			return 0;
1:eac0369: 
1:eac0369: 		// ask bit array how many bits it can store in this amount of space
1:eac0369: 		return FormatableBitSet.maxBitsForSpace(availspace);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * methods
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * ctors
1:eac0369: 	 */
1:eac0369: 	protected AllocExtent(long offset, // physical offset
1:eac0369: 					   long start,  // starting logical page number
1:eac0369: 					   int length,  // how many pages are in this extent
1:eac0369: 					   int pagesize, // size of all the pages in the extent
1:eac0369: 					   int maxlength) // initial size of the bit map arrays
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			if (length > maxlength)
1:eac0369: 				SanityManager.THROWASSERT(
1:eac0369: 							"length " + length + " > maxlength " + maxlength);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		this.extentOffset = offset;
1:eac0369: 		this.extentStart = start;
1:eac0369: 		this.extentEnd = start+maxlength-1;
1:eac0369: 
1:eac0369: 		this.extentLength = length;
1:eac0369: 		preAllocLength = extentLength;
1:eac0369: 
1:eac0369: 		if (length > 0)
1:eac0369: 			extentStatus = HAS_FREE | ALL_FREE ;
1:eac0369: 		else
1:eac0369: 			extentStatus = 0;
1:eac0369: 
1:eac0369: 		extentStatus |= KEEP_UNFILLED_PAGES; // v1.3 or beyond
1:eac0369: 		extentStatus |= NO_DEALLOC_PAGE_MAP; // v2.0 or beyond
1:eac0369: 
1:eac0369: 		int numbits = (1+(length/8))*8;
1:eac0369: 		if (numbits > maxlength)
1:eac0369: 			numbits = maxlength;
1:eac0369: 
1:eac0369: 		freePages = new FormatableBitSet(numbits);
1:eac0369: 		unFilledPages = new FormatableBitSet(numbits);
1:eac0369: 
1:eac0369: 		// by definition, all pages are free to begin with, no pages are
1:eac0369: 		// deallocated and no page is unfilled
1:eac0369: 		for (int i = 0; i < length; i++)
1:eac0369: 			freePages.set(i);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	  Copy constructor
1:eac0369: 	*/
1:eac0369: 	protected AllocExtent(AllocExtent original)
1:eac0369: 	{
1:eac0369: 		extentOffset = original.extentOffset;
1:eac0369: 		extentStart	 = original.extentStart;
1:eac0369: 		extentEnd	 = original.extentEnd;
1:eac0369: 		extentLength = original.extentLength;
1:eac0369: 		extentStatus = original.extentStatus;
1:eac0369: 		preAllocLength = original.preAllocLength;
1:eac0369: 
1:eac0369: 		freePages = new FormatableBitSet(original.freePages);
1:eac0369: 		unFilledPages = new FormatableBitSet(original.unFilledPages);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * Methods of Externalizable
1:eac0369: 	 */
1:eac0369: 	public AllocExtent()
1:eac0369: 	{
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	public void writeExternal(ObjectOutput out) throws IOException
1:eac0369: 	{
1:eac0369: 
1:eac0369: 		// any change to this routine must change maxRange
1:eac0369: 		out.writeLong(extentOffset);
1:eac0369: 		out.writeLong(extentStart);
1:eac0369: 		out.writeLong(extentEnd);
1:eac0369: 		out.writeInt(extentLength);
1:eac0369: 		out.writeInt(extentStatus);
1:eac0369: 		out.writeInt(preAllocLength);
1:eac0369: 		out.writeInt(0);		// reserved1
1:eac0369: 		out.writeLong(0);		// reserved2
1:eac0369: 		out.writeLong(0);		// reserved3
1:eac0369: 
1:eac0369: 		freePages.writeExternal(out);
1:eac0369: 		unFilledPages.writeExternal(out);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public void readExternal(ObjectInput in)
1:eac0369: 		 throws IOException, ClassNotFoundException
1:eac0369: 	{
1:eac0369: 		// any change to this routine must change maxRange
1:eac0369: 		extentOffset = in.readLong();
1:eac0369: 		extentStart	= in.readLong();
1:eac0369: 		extentEnd	= in.readLong();
1:eac0369: 		extentLength = in.readInt();
1:eac0369: 		extentStatus = in.readInt();
1:eac0369: 		preAllocLength = in.readInt();
1:eac0369: 		reserved1 = in.readInt();
1:eac0369: 		reserved2 = in.readLong();
1:eac0369: 		reserved3 = in.readLong();
1:eac0369: 
1:eac0369: 		freePages = new FormatableBitSet();	// don't know how to point to it
1:eac0369: 		freePages.readExternal(in);
1:eac0369: 
1:eac0369: 		// this extent is created before 2.0
1:eac0369: 		if ((extentStatus & NO_DEALLOC_PAGE_MAP) == 0)	
1:eac0369: 		{
1:eac0369: 			FormatableBitSet deAllocPages = new FormatableBitSet();
1:eac0369: 			deAllocPages.readExternal(in);
1:eac0369: 			// fold this into free page bit map
1:eac0369: 			freePages.or(deAllocPages);
1:eac0369: 			extentStatus |= NO_DEALLOC_PAGE_MAP; // dealloc page map has been merged
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if ((extentStatus & KEEP_UNFILLED_PAGES) == KEEP_UNFILLED_PAGES)
1:eac0369: 		{
1:eac0369: 			unFilledPages = new FormatableBitSet();
1:eac0369: 			unFilledPages.readExternal(in);
1:eac0369: 		}
1:eac0369: 		else					// before we keep track of unfilled pages pre 1.3
1:eac0369: 		{
1:eac0369: 			// make sure there are enough space
1:eac0369: 			unFilledPages = new FormatableBitSet(freePages.getLength());
1:eac0369: 			extentStatus |= KEEP_UNFILLED_PAGES; // now we keep track of them
1:eac0369: 		}
1:eac0369: 		
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * methods specific to allocExtent
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * write operation that is called underneath the log
1:bd54198: 	 *
1:eac0369: 	 * page goes thru the following transition:
1:eac0369: 	 * ALLOCATED_PAGE <-> deallocated page -> free page <-> ALLOCATED_PAGE
2:04a2f12: 	 *
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Allocate this page - this is called underneath the log record
1:eac0369: 
1:94f158a: 		@exception StandardException Standard Derby error policy
1:eac0369: 	*/
1:eac0369: 	protected void allocPage(long pagenum) throws StandardException
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			if (pagenum > getLastPagenum())
1:eac0369: 			{
1:eac0369: 				// adding a brand new page, it should be at most one off from the last page
1:eac0369: 				if (pagenum > extentEnd)
1:eac0369: 					SanityManager.THROWASSERT("pagenum " + pagenum +
1:eac0369: 									 " is out of beyond my range (" +
1:eac0369: 										extentStart + "," + extentEnd + ")");
1:eac0369: 				if (pagenum != getLastPagenum() + 1)
1:eac0369: 					SanityManager.THROWASSERT(
1:eac0369: 						"skipping pages, lastPageNumber = " + getLastPagenum() +
1:eac0369: 						 " pageNumber = " + pagenum + "\n");
1:eac0369: 			}
1:eac0369: 			else
1:eac0369: 			{
1:eac0369: 				// reuseing a page, make sure it is in range and is not already in use
1:eac0369: 				checkInRange(pagenum);
1:eac0369: 
1:eac0369: 				int bitnum = (int)(pagenum-extentStart);
1:eac0369: 
1:eac0369: 				// either the pagenum is now free (do) or deallocated (undo)
1:eac0369: 				if (!freePages.isSet(bitnum))
1:eac0369:                 {
1:eac0369: 					SanityManager.THROWASSERT(
1:eac0369:                         "trying to re-allocate a page ( " +
1:eac0369:                         pagenum + " ) that is already allocated ");
1:eac0369:                 }
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// don't know if we are redoing (from free -> valid)
1:eac0369: 		// or undoing (from dealloc -> valid), reset them both
1:eac0369: 		int bitnum = (int)(pagenum-extentStart);
1:eac0369: 
1:eac0369: 		if (bitnum >= freePages.getLength())	// expand the bit map
1:eac0369: 		{
1:eac0369: 			int numbits = (1+(bitnum/8))*8;
1:eac0369: 			if (numbits > (int)(extentEnd - extentStart + 1))
1:eac0369: 				numbits = (int)(extentEnd - extentStart + 1);
1:eac0369: 
1:eac0369: 			freePages.grow(numbits);
1:eac0369: 			unFilledPages.grow(numbits);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// the first page to be allocated has pagenum == extentStart.
1:eac0369: 		int numPageAlloced = (int)(pagenum-extentStart+1);
1:eac0369: 
1:eac0369: 		if (numPageAlloced > extentLength)
1:eac0369: 		{
1:eac0369: 			extentLength = numPageAlloced;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		freePages.clear(bitnum);
1:eac0369: 
1:eac0369: 		// do not set the unfilled bit on a newly allocated page because
1:eac0369: 		// we only keep track of unfilled HEAD page, not unfilled overflow
1:eac0369: 		// page. 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	    Deallocate logical page pagenum - this is called underneath the log record.
1:eac0369: 		pagenum must be a page managed by this extent and it must be valid
1:eac0369: 
1:94f158a: 		@exception StandardException Standard Derby error policy
1:eac0369: 	*/
1:eac0369: 	protected void deallocPage(long pagenum) throws StandardException
1:eac0369: 	{
1:eac0369: 		int bitnum = (int)(pagenum-extentStart);
1:eac0369: 
1:eac0369: 		// the pagenum must now be either valid (do) or free (undo)
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			if (freePages.isSet(bitnum))
1:eac0369: 				SanityManager.THROWASSERT(
1:eac0369: 						"trying to deallocate a deallocated page " + pagenum);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		freePages.set(bitnum);
1:eac0369: 		unFilledPages.clear(bitnum); // deallocated page is never unfilled
1:eac0369: 
1:eac0369: 		setExtentFreePageStatus(true);
1:eac0369: 	}
1:bbc927c: 
1:44fe060:     /**
1:44fe060:      * Compress free pages at end of this extent.
1:44fe060:      * <p>
1:44fe060:      * Search backward from end of extent and prepare data structures
1:44fe060:      * to return pages at end of extent to the OS. Returns the lowest
1:44fe060:      * page that can be returned to the OS.
1:44fe060:      * <p>
1:bd54198:      *
1:04a2f12: 	 * @return Return bit of page where all pages that follow can
1:44fe060:      *         be returned to the OS.
1:44fe060:      **/
1:04a2f12:     protected int compress(
1:04a2f12:     BaseContainerHandle owner,
1:04a2f12:     RawTransaction      ntt,
1:04a2f12:     AllocPage           alloc_page)
1:04a2f12:         throws StandardException
1:bbc927c:     {
1:04a2f12:         int compress_bitnum      = -1;
1:04a2f12:         int num_pages_compressed = 0;
1:eac0369: 
1:04a2f12:         for (int i = (extentLength - 1); i >= 0; i--)
1:bbc927c:         {
1:bbc927c:             if (freePages.isSet(i))
1:bbc927c:             {
1:bbc927c:                 compress_bitnum = i;
1:04a2f12:                 num_pages_compressed++;
1:bbc927c:             }
1:bbc927c:             else
1:bbc927c:             {
1:bbc927c:                 break;
1:bbc927c:             }
1:bbc927c:         }
1:bbc927c: 
1:04a2f12:         // new_highest_page is the last page to remain in the file after 
1:04a2f12:         // the truncate, the above loop set compress_bitnum to lowest 
1:04a2f12:         // free page in the set of contiguous free pages at end of extent.
1:04a2f12:         int new_highest_page = compress_bitnum - 1;
1:04a2f12: 
1:04a2f12:         if (num_pages_compressed > 0)
1:04a2f12:         {
1:04a2f12:             if (SanityManager.DEBUG)
1:bbc927c:             {
1:04a2f12:                 for (int i = new_highest_page + 1; i < extentLength; i++)
1:04a2f12:                 {
1:04a2f12:                     if (!freePages.isSet(i))
1:04a2f12:                     {
1:04a2f12: 
1:04a2f12:                         SanityManager.THROWASSERT(
1:04a2f12:                             "compressPages with nonfree pg to truncate," +
1:04a2f12:                             "new_highest_page = " + new_highest_page +
1:04a2f12:                             "num_pages_truncated = " + num_pages_compressed +
1:04a2f12:                             ";extentLength = " + extentLength +
1:04a2f12:                             ";extentStart = " + extentStart +
1:04a2f12:                             ";freePages.isSet(" + i + ") = " + 
1:04a2f12:                                 freePages.isSet(i) +
1:04a2f12:                             "\nextent:\n" + toDebugString());
1:04a2f12:                     }
1:04a2f12:                 }
1:04a2f12: 
1:04a2f12:                 SanityManager.ASSERT(
1:04a2f12:                     (new_highest_page + num_pages_compressed + 1) == 
1:04a2f12:                         extentLength,
1:04a2f12:                     "truncate page count did not match: " +
1:04a2f12:                     ";new_highest_page = " + new_highest_page +
1:04a2f12:                     ";num_pages_truncated = " + num_pages_compressed +
1:04a2f12:                     ";extentLength = " + extentLength);
1:04a2f12: 
1:04a2f12:                 // the following assert could be made invalid by a new type of
1:04a2f12:                 // access method, but currently page 1 of btree and heap contain
1:04a2f12:                 // control rows, so will never become free and thus should never
1:04a2f12:                 // be compressed.
1:04a2f12:                 if (extentStart == 1)
1:04a2f12:                 {
1:04a2f12:                     SanityManager.ASSERT(new_highest_page >= 0);
1:04a2f12: 
1:04a2f12:                     if (num_pages_compressed >= extentLength)
1:04a2f12:                     {
1:04a2f12:                         SanityManager.THROWASSERT(
1:04a2f12:                             "new_highest_page = "     + new_highest_page +
1:04a2f12:                             "num_pages_compressed = " + num_pages_compressed +
1:04a2f12:                             "; extentLength = "       + extentLength +
1:04a2f12:                             "extent:\n"               + toDebugString());
1:04a2f12:                     }
1:04a2f12:                 }
1:04a2f12:             }
1:04a2f12: 
1:04a2f12:             /*
1:04a2f12:             SanityManager.DEBUG_PRINT("AllocExtent", 
1:04a2f12:                 "calling actionCompressSpaceOperation:" +
1:04a2f12:                 ";new_highest_page = " + new_highest_page +
1:04a2f12:                 ";num_pages_compressed = " +  num_pages_compressed +
1:04a2f12:                 ";extentLength = " +  extentLength +
1:04a2f12:                 ";extent: \n" + toDebugString());
1:04a2f12:             */
1:04a2f12: 
1:04a2f12: 
1:04a2f12:             owner.getAllocationActionSet().actionCompressSpaceOperation(
1:04a2f12:                 ntt, alloc_page, new_highest_page, num_pages_compressed); 
1:04a2f12:             return(compress_bitnum);
1:bbc927c:         }
1:bbc927c:         else
1:bbc927c:         {
1:bbc927c:             return(-1);
1:04a2f12:         }
1:04a2f12: 
1:bbc927c:     }
1:04a2f12: 
1:04a2f12:     protected void compressPages(
1:04a2f12:     int        new_highest_page,
1:04a2f12:     int        num_pages_truncated)
1:04a2f12:     {
1:04a2f12:         if (SanityManager.DEBUG)
1:04a2f12:         {
2:04a2f12:             if (new_highest_page >= 0)
1:04a2f12:             {
1:04a2f12:                 for (int i = new_highest_page + 1; i < extentLength; i++)
1:04a2f12:                 {
1:04a2f12:                     if (!freePages.isSet(i))
1:04a2f12:                     {
1:04a2f12:                         SanityManager.THROWASSERT(
1:04a2f12:                             "compressPages with non free page to truncate," +
1:04a2f12:                             "new_highest_page = " + new_highest_page +
1:04a2f12:                             "num_pages_truncated = " + num_pages_truncated +
1:04a2f12:                             ";extentLength = " + extentLength +
1:04a2f12:                             ";extentStart = " + extentStart +
1:04a2f12:                             ";freePages.isSet(" + i + ") = " + 
1:04a2f12:                                 freePages.isSet(i) +
1:04a2f12:                             "\nextent:\n" + toDebugString());
1:04a2f12:                     }
1:04a2f12:                 }
1:04a2f12:             }
1:04a2f12: 
1:04a2f12:             SanityManager.ASSERT(
1:04a2f12:                 (new_highest_page + num_pages_truncated + 1) == extentLength,
1:04a2f12:                 "truncate page count did not match: " +
1:04a2f12:                 ";new_highest_page = " + new_highest_page +
1:04a2f12:                 ";num_pages_truncated = " + num_pages_truncated +
1:04a2f12:                 ";extentLength = " + extentLength);
1:04a2f12: 
1:04a2f12:             // the following assert could be made invalid by a new type of
1:04a2f12:             // access method, but currently page 1 of btree and heap contain
1:04a2f12:             // control rows, so will never become free and thus should never
1:04a2f12:             // be compressed.
1:04a2f12:             if (extentStart == 1)
1:04a2f12:             {
1:04a2f12:                 SanityManager.ASSERT(new_highest_page >= 0);
1:04a2f12:                 SanityManager.ASSERT(num_pages_truncated < extentLength);
1:04a2f12:             }
1:04a2f12:         }
1:04a2f12: 
1:74e2f88:         if (new_highest_page + 1 >= 0)
1:04a2f12:         {
1:04a2f12:             freePages.shrink(new_highest_page + 1);
1:04a2f12:             unFilledPages.shrink(new_highest_page + 1);
1:04a2f12: 
1:04a2f12:             // This routine assumes the caller
1:04a2f12:             // will be doing the truncate, and just updates the data structures.
1:04a2f12:             preAllocLength = extentLength = (new_highest_page + 1);
1:04a2f12:         }
1:04a2f12: 
1:04a2f12:         return;
1:bbc927c:     }
1:bbc927c: 
1:bd54198:     /**
1:bd54198:      * Undo the compress space operation.
1:bd54198:      * <p>
1:bd54198:      * Undo of this operation doesn't really "undo" the operation, it just
1:bd54198:      * makes sure the data structures are ok after the undo.  We are 
1:bd54198:      * guaranteed at the point of the transaction doing the 
1:bd54198:      * Undo of the compress space operation fixes up the bit maps to
1:bd54198:      * only point at pages within the new_highest_page range.
1:bd54198:      * <p>
1:bd54198:      * Prior to logging the compress space operation all pages greater 
1:bd54198:      * than 
1:bd54198:      * There are only 2 possibilities at this point:
1:bd54198:      * 1) the truncate of pages greater than new_highest_page happened before
1:bd54198:      *    the abort took place.  W
1:bd54198:      * 2) 
1:bd54198:      **/
1:bd54198:     protected void undoCompressPages(
1:bd54198:     int        new_highest_page,
1:bd54198:     int        num_pages_truncated)
1:bd54198:     {
1:bd54198:         if (new_highest_page >= 0)
1:bd54198:         {
1:bd54198:             freePages.shrink(new_highest_page + 1);
1:bd54198:             unFilledPages.shrink(new_highest_page + 1);
1:bd54198:             preAllocLength = extentLength = (new_highest_page + 1);
1:bd54198:         }
1:bd54198: 
1:bd54198:         return;
1:bd54198:     }
1:bd54198: 
1:eac0369: 	protected long getExtentEnd()
1:eac0369: 	{
1:eac0369: 		return extentEnd;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * read operation that is called above the log
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Get a page number that is free
1:eac0369: 	*/
1:eac0369: 	protected long getFreePageNumber(long pnum)
1:eac0369: 	{
1:eac0369: 		// if we can reuse page, do so, otherwise add a brand new page
1:eac0369: 		if (mayHaveFreePage())
1:eac0369: 		{
1:eac0369: 			// The last allocated page may be from a previous alloc extent, but
1:eac0369: 			// if that extent is full and we are the first extent that can
1:eac0369: 			// accomodate a new page, we may be picked.  In that case, pnum may
1:eac0369: 			// be before the start of this extent.
1:eac0369: 			int i = (pnum < extentStart) ? freePages.anySetBit() : 
1:eac0369: 				freePages.anySetBit((int)(pnum-extentStart));
1:eac0369: 
1:eac0369: 			if (i != -1)
1:eac0369: 			{
1:eac0369:                 if (SanityManager.DEBUG)
1:eac0369:                 {
1:eac0369:  		    		if (i >= extentLength)
1:eac0369:  		    			SanityManager.THROWASSERT("returned bit = " + i +
1:eac0369: 			    						 " extent length = " + extentLength);
1:eac0369: 			    }
1:eac0369: 
1:eac0369: 				return i+extentStart;
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			// the hint is wrong, no free page in the extent
1:eac0369: 			// do this unlogged, it is just a hint, don't care if it is lost
1:eac0369: 			if (pnum < extentStart)
1:eac0369: 				setExtentFreePageStatus(false);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// maximally, we can have up to extendEnd page
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT(extentStart+extentLength <= extentEnd);
1:eac0369: 
1:eac0369: 		// need to add a brand new page, current end of extent is at page
1:eac0369: 		// extentStart+extentLength-1;
1:eac0369: 		return extentStart+extentLength;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Get the physical offset of pagenum.
1:eac0369: 		If deallocOK is true, then even if pagenum is deallocated, it is OK.
1:eac0369: 		If deallocOK is false, then an exception is thrown if pagenum is
1:eac0369: 		deallocated.
1:eac0369: 
1:eac0369: 		An exception is always thrown if pagenum is a free page
1:eac0369: 
1:94f158a: 		@exception StandardException Standard Derby error policy
1:eac0369: 	 */
1:eac0369: 	protected long getPageOffset(long pagenum, int pagesize, boolean deallocOK) throws StandardException
1:eac0369: 	{
1:eac0369: 		return pagenum * pagesize;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Return the status of this extent
1:eac0369: 	*/
1:eac0369: 	protected boolean isRetired()
1:eac0369: 	{
1:eac0369: 		return ((extentStatus & RETIRED) != 0);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	private boolean mayHaveFreePage()
1:eac0369: 	{
1:eac0369: 		return ((extentStatus & HAS_FREE) != 0);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	private void setExtentFreePageStatus(boolean hasFree)
1:eac0369: 	{
1:eac0369: 		if (hasFree)
1:eac0369: 			extentStatus |= HAS_FREE;
1:eac0369: 		else
1:eac0369: 			extentStatus &= ~HAS_FREE;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	protected boolean canAddFreePage(long lastAllocatedPage)
1:eac0369: 	{
1:eac0369: 		// the last page to be allocated == extentEnd
1:eac0369: 		if (extentStart + extentLength <= extentEnd)
1:eac0369: 			return true;
1:eac0369: 
1:eac0369: 		// else, check to see if this may have any free page
1:eac0369: 		if (!mayHaveFreePage())
1:eac0369: 			return false;
1:eac0369: 
1:eac0369: 		// we may have a free page, but that is not certain, double check
1:eac0369: 		if (lastAllocatedPage < extentStart)
1:eac0369: 			return (freePages.anySetBit() != -1);
1:eac0369: 		else
1:eac0369: 			return ((freePages.anySetBit((int)(lastAllocatedPage-extentStart))) != -1);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Return the status of a particular page
1:eac0369: 	*/
1:eac0369: 	protected int getPageStatus(long pagenum)
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			checkInRange(pagenum);
1:eac0369: 
1:eac0369: 		int status = 0;
1:eac0369: 		int bitnum = (int)(pagenum-extentStart);
1:eac0369: 
1:eac0369: 		if (freePages.isSet(bitnum))
1:eac0369: 			status = FREE_PAGE;
1:eac0369: 		else
1:eac0369: 			status = ALLOCATED_PAGE;
1:eac0369: 
1:eac0369: 		return status;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Get the first logical page number managed by this extent.
1:eac0369: 	*/
1:eac0369: 	protected long getFirstPagenum()
1:eac0369: 	{
1:eac0369: 		return extentStart;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Get the last logical page number managed by this extent.
1:eac0369: 	*/
1:eac0369: 	protected long getLastPagenum()
1:eac0369: 	{
1:eac0369: 		return extentStart+extentLength-1;
1:eac0369: 	}
1:eac0369: 
1:04a2f12:     /**
1:04a2f12:      * translate bit position in map to page number.
1:04a2f12:      * <p>
1:bd54198:      *
1:04a2f12: 	 * @return The page number of this "bit" in the extent map.
1:04a2f12:      **/
1:04a2f12:     protected long getPagenum(int bit_pos)
1:04a2f12:     {
1:04a2f12:         return(extentStart + bit_pos);
1:04a2f12:     }
1:04a2f12:         
1:04a2f12: 
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * page preallocation 
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * get the last preallocated pagenumber managed by this alloc page
1:eac0369: 	 */
1:eac0369: 	protected long getLastPreallocPagenum()
1:eac0369: 	{
1:eac0369: 		if (extentLength > preAllocLength)
1:eac0369: 			preAllocLength = extentLength;
1:eac0369: 
1:eac0369: 		return extentStart + preAllocLength - 1 ;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		preallocated N pages, passed in the last preallocated page number.
1:eac0369: 	*/
1:eac0369: 	protected void setLastPreallocPagenum(long preAllocPagenum)
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT(preAllocPagenum >= getLastPreallocPagenum(),
1:eac0369:                 "setLastPreallocPagenum set to small prealloc length than before");
1:eac0369: 
1:eac0369: 		// cannot prealloc more than this extent can handle
1:eac0369: 		if (preAllocPagenum > extentEnd)
1:eac0369: 			preAllocPagenum = extentEnd;
1:eac0369: 
1:eac0369: 		preAllocLength = (int)(preAllocPagenum - extentStart + 1);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	  Get the logical page number that is bigger than prevPageNumber
1:eac0369: 	  and is a valid page.  If no such page in this extent, return
1:eac0369: 	  ContainerHandle.INVALID_PAGE_HANDLE
1:eac0369: 	*/
1:eac0369: 	protected long getNextValidPageNumber(long prevPageNumber)
1:eac0369: 	{
1:eac0369: 		long pageNum;
1:eac0369: 		long lastpage = getLastPagenum();
1:eac0369: 
1:eac0369: 		if (prevPageNumber < extentStart)
1:eac0369: 			pageNum = extentStart;
1:eac0369: 		else
1:eac0369: 			pageNum = prevPageNumber +1;
1:eac0369: 
1:eac0369: 		while(pageNum <= lastpage)
1:eac0369: 		{
1:eac0369: 			int status = getPageStatus(pageNum);
1:eac0369: 			if (status == ALLOCATED_PAGE)
1:eac0369: 				break;
1:eac0369: 			pageNum++;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (pageNum > lastpage)
1:eac0369: 			pageNum = ContainerHandle.INVALID_PAGE_NUMBER;
1:eac0369: 		return pageNum;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	protected long getLastValidPageNumber()
1:eac0369: 	{
1:eac0369: 		long pageNum = getLastPagenum();
1:eac0369: 		while(pageNum >= extentStart)
1:eac0369: 		{
1:eac0369: 			int status = getPageStatus(pageNum);
1:eac0369: 			if (status == ALLOCATED_PAGE)
1:eac0369: 				break;
1:eac0369: 			pageNum--;
1:eac0369: 		}
1:eac0369: 		if (pageNum < extentStart)
1:eac0369: 			pageNum = ContainerHandle.INVALID_PAGE_NUMBER;
1:eac0369: 		return pageNum;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	private void checkInRange(long pagenum)
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			if (pagenum < extentStart || pagenum >= extentStart+extentLength)
1:eac0369: 				SanityManager.THROWASSERT(
1:eac0369:                     "pagenum " + pagenum + " out of range");
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	protected void updateUnfilledPageInfo(AllocExtent inputExtent)
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369:             if (inputExtent.unFilledPages.getLength() != 
1:eac0369:                     unFilledPages.getLength())
1:eac0369:             {
1:eac0369:                 SanityManager.THROWASSERT(
1:eac0369:                     "inputExtent's unfilled page length " +
1:eac0369:                     inputExtent.unFilledPages.getLength() + 
1:eac0369:                     " != extent's unfilled page length " + 
1:eac0369:                     unFilledPages.getLength());
1:eac0369:             }
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// just use the passed in inputExtent, we know (wink wink) that the
1:eac0369: 		// unfilled page info is being updated just when the allocation cache
1:eac0369: 		// is being invalidated.  Nobody is going to have a reference to the
1:eac0369: 		// inputExtent after this so is it save to share the FormatableBitSet.
1:eac0369: 
1:eac0369: 		// if we cannot guarentee that the inputExtent will be unchanged by the
1:eac0369: 		// caller, we need to copy it 		
1:eac0369: 		//		unFilledPages = new FormatableBitSet(inputExtent.unFilledPages);
1:eac0369: 		// Right now, just reference it directly
1:eac0369: 		unFilledPages = inputExtent.unFilledPages;
1:eac0369: 
1:eac0369: 		if (unFilledPages.anySetBit() >= 0)
1:eac0369: 			extentStatus |= HAS_UNFILLED_PAGES;
1:eac0369: 		else
1:eac0369: 			extentStatus &= ~HAS_UNFILLED_PAGES;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 		Keep track of unfilled pages, if the extent changed, returns true.
1:eac0369: 	 */
1:eac0369: 	protected boolean trackUnfilledPage(long pagenumber, boolean unfilled)
1:eac0369: 	{
1:eac0369: 		checkInRange(pagenumber);
1:eac0369: 
1:eac0369: 		int bitnum = (int)(pagenumber-extentStart);
1:eac0369: 
1:eac0369: 		boolean bitSet = unFilledPages.isSet(bitnum);
1:eac0369: 		if (unfilled != bitSet)
1:eac0369: 		{
1:eac0369: 			if (unfilled)
1:eac0369: 			{
1:eac0369: 				unFilledPages.set(bitnum);
1:eac0369: 				extentStatus |= HAS_UNFILLED_PAGES;
1:eac0369: 			}
1:eac0369: 			else
1:eac0369: 				unFilledPages.clear(bitnum);
1:eac0369: 			return true;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Get a page number that is unfilled, pagenum is the last page that was
1:eac0369: 		rejected.
1:eac0369: 	 */
1:eac0369: 	protected long getUnfilledPageNumber(long pagenum)
1:eac0369: 	{
1:eac0369: 		if ((extentStatus & HAS_UNFILLED_PAGES) == 0)
1:eac0369: 			return ContainerHandle.INVALID_PAGE_NUMBER;
1:eac0369: 
1:eac0369: 		int i = unFilledPages.anySetBit();
1:eac0369: 
1:eac0369: 		if (i != -1)
1:eac0369: 		{
1:eac0369: 			if (i+extentStart != pagenum)
1:eac0369: 				return i+extentStart;
1:eac0369: 			else
1:eac0369: 			{
1:eac0369: 				// unfortunately, we found the same page number that
1:eac0369: 				// was rejected.  It would be unwise to unset bit
1:eac0369: 				// pagenum because just because it was rejected does not mean
1:eac0369: 				// the page is full, the row we are trying to insert may just
1:eac0369: 				// be too big.  If we unset it, we will never find that page
1:eac0369: 				// again even though it may be a perfectly good page for any
1:eac0369: 				// other row.  Just get the next set bit.
1:eac0369: 				i = unFilledPages.anySetBit(i);
1:eac0369: 				if (i != -1)
1:eac0369: 					return i+extentStart;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return ContainerHandle.INVALID_PAGE_NUMBER;
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Get the number of used page in this extent
1:eac0369: 	 */
1:eac0369: 	protected int getAllocatedPageCount()
1:eac0369: 	{
1:eac0369: 		// allocated page is one which is not free or deallocated.
1:eac0369: 		int allocatedPageCount = extentLength;
1:eac0369: 
1:eac0369: 		if (!mayHaveFreePage())
1:eac0369: 			return allocatedPageCount;
1:eac0369: 
1:eac0369: 
1:eac0369: 		byte[] free = freePages.getByteArray();
1:eac0369: 		int numBytes = free.length;
1:eac0369: 
1:eac0369: 		for (int i = 0; i < numBytes; i++)
1:eac0369: 		{
1:eac0369: 			if (free[i] != 0)
1:eac0369: 			{
1:eac0369: 				for (int j = 0; j < 8; j++)
1:eac0369: 				{
1:eac0369: 					if (((1 << j) & free[i]) != 0)
1:bbc927c:                     {
1:eac0369: 						allocatedPageCount--;
1:bbc927c:                     }
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:bbc927c:         {
1:04a2f12:             if (allocatedPageCount < 0)
1:04a2f12:             {
1:04a2f12:                 SanityManager.THROWASSERT(
1:04a2f12:                     "number of allocated page < 0, val =" + allocatedPageCount +
1:04a2f12:                     "\nextent = " + toDebugString());
1:04a2f12:             }
1:bbc927c:         }
1:eac0369: 
1:eac0369: 		return allocatedPageCount;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Get the number of unfilled pages in this extent
1:eac0369: 	 */
1:eac0369: 	protected int getUnfilledPageCount()
1:eac0369: 	{
1:eac0369:         int unfilledPageCount = 0;
1:eac0369:         int freePagesSize = freePages.size();
1:eac0369: 
1:eac0369:         for (int i = 0; i < unFilledPages.size(); i++)
1:eac0369:         {
1:eac0369:             if (unFilledPages.isSet(i) &&
1:eac0369:                 (i >= freePagesSize || !freePages.isSet(i)))
1:eac0369:                 unfilledPageCount++;
1:eac0369:         }
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT(unfilledPageCount >= 0,
1:eac0369: 								 "number of unfilled pages < 0");
1:eac0369: 
1:eac0369:         return unfilledPageCount;
1:eac0369:  	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Get the total number of pages in this extent
1:eac0369: 	 */
1:eac0369: 	protected int getTotalPageCount()
1:eac0369: 	{
1:eac0369:         return extentLength;
1:eac0369:     }
1:eac0369: 
1:eac0369: 	protected String toDebugString()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			String str =
1:eac0369: 				"------------------------------------------------------------------------------\n" +
1:eac0369: 				"Extent map of from page " + extentStart + " to page " + extentEnd + "\n";
1:eac0369: 
1:eac0369: 			for (long i = extentStart; i < extentStart+extentLength; i++)
1:eac0369: 			{
1:eac0369: 				str += "\tpage " + i + ": ";
1:eac0369: 				switch(getPageStatus(i))
1:eac0369: 				{
1:eac0369: 				case FREE_PAGE: str += "free page\n"; break;
1:eac0369: 				case ALLOCATED_PAGE: str += "valid, in use page\n"; break;
1:eac0369: 				}
1:eac0369: 
1:eac0369: 		        // int bitnum = (int)(i-extentStart);
1:eac0369:         		// if (unFilledPages.isSet(bitnum))
1:eac0369:                 //    str += "          page is estimated to be unfilled\n";
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			if (getLastPagenum() < extentEnd)
1:eac0369: 				str += "\tFrom " + getLastPagenum() + " to " + extentEnd +
1:eac0369: 					" are un-allocated pages\n";
1:eac0369: 
1:eac0369: 			str += "------------------------------------------------------------------------------\n";
1:eac0369: 
1:eac0369: 			return str;
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 			return null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: }
============================================================================
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:f668d94
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:74e2f88
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         if (new_highest_page + 1 >= 0)
commit:270a34d
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:787ceb4
/////////////////////////////////////////////////////////////////////////
1: 	@derby.formatId	none, format implied by AllocPage's format
1: 	@derby.purpose	manage page status of page in extent
1: 	@derby.upgrade
1: 	@derby.diskLayout
/////////////////////////////////////////////////////////////////////////
1: 	@derby.endFormat
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:94f158a
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException Standard Derby error policy
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException Standard Derby error policy
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException Standard Derby error policy
author:David Van Couvering
-------------------------------------------------------------------------------
commit:6b50965
/////////////////////////////////////////////////////////////////////////
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:bd54198
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Undo the compress space operation.
1:      * <p>
1:      * Undo of this operation doesn't really "undo" the operation, it just
1:      * makes sure the data structures are ok after the undo.  We are 
1:      * guaranteed at the point of the transaction doing the 
1:      * Undo of the compress space operation fixes up the bit maps to
1:      * only point at pages within the new_highest_page range.
1:      * <p>
1:      * Prior to logging the compress space operation all pages greater 
1:      * than 
1:      * There are only 2 possibilities at this point:
1:      * 1) the truncate of pages greater than new_highest_page happened before
1:      *    the abort took place.  W
1:      * 2) 
1:      *
0: 	 * @return The identifier to be used to open the conglomerate later.
1:      *
0:      * @param param1 param1 does this.
0:      * @param param2 param2 does this.
1:      *
0: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     protected void undoCompressPages(
1:     int        new_highest_page,
1:     int        num_pages_truncated)
1:     {
1:         if (new_highest_page >= 0)
1:         {
1:             freePages.shrink(new_highest_page + 1);
1:             unFilledPages.shrink(new_highest_page + 1);
1:             preAllocLength = extentLength = (new_highest_page + 1);
1:         }
1: 
1:         return;
1:     }
1: 
commit:04a2f12
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.store.raw.xact.RawTransaction; 
/////////////////////////////////////////////////////////////////////////
1: 	 * @return Return bit of page where all pages that follow can
1:     protected int compress(
1:     BaseContainerHandle owner,
1:     RawTransaction      ntt,
1:     AllocPage           alloc_page)
1:         throws StandardException
1:         int compress_bitnum      = -1;
1:         int num_pages_compressed = 0;
1:         for (int i = (extentLength - 1); i >= 0; i--)
1:                 num_pages_compressed++;
/////////////////////////////////////////////////////////////////////////
1:         // new_highest_page is the last page to remain in the file after 
1:         // the truncate, the above loop set compress_bitnum to lowest 
1:         // free page in the set of contiguous free pages at end of extent.
1:         int new_highest_page = compress_bitnum - 1;
1: 
1:         if (num_pages_compressed > 0)
1:             if (SanityManager.DEBUG)
1:             {
1:                 for (int i = new_highest_page + 1; i < extentLength; i++)
1:                 {
1:                     if (!freePages.isSet(i))
1:                     {
1: 
1:                         SanityManager.THROWASSERT(
1:                             "compressPages with nonfree pg to truncate," +
1:                             "new_highest_page = " + new_highest_page +
1:                             "num_pages_truncated = " + num_pages_compressed +
1:                             ";extentLength = " + extentLength +
1:                             ";extentStart = " + extentStart +
1:                             ";freePages.isSet(" + i + ") = " + 
1:                                 freePages.isSet(i) +
1:                             "\nextent:\n" + toDebugString());
1:                     }
1:                 }
1: 
1:                 SanityManager.ASSERT(
1:                     (new_highest_page + num_pages_compressed + 1) == 
1:                         extentLength,
1:                     "truncate page count did not match: " +
1:                     ";new_highest_page = " + new_highest_page +
1:                     ";num_pages_truncated = " + num_pages_compressed +
1:                     ";extentLength = " + extentLength);
1: 
1:                 // the following assert could be made invalid by a new type of
1:                 // access method, but currently page 1 of btree and heap contain
1:                 // control rows, so will never become free and thus should never
1:                 // be compressed.
1:                 if (extentStart == 1)
1:                 {
1:                     SanityManager.ASSERT(new_highest_page >= 0);
1: 
1:                     if (num_pages_compressed >= extentLength)
1:                     {
1:                         SanityManager.THROWASSERT(
1:                             "new_highest_page = "     + new_highest_page +
1:                             "num_pages_compressed = " + num_pages_compressed +
1:                             "; extentLength = "       + extentLength +
1:                             "extent:\n"               + toDebugString());
1:                     }
1:                 }
1:             }
1: 
1:             /*
1:             SanityManager.DEBUG_PRINT("AllocExtent", 
1:                 "calling actionCompressSpaceOperation:" +
1:                 ";new_highest_page = " + new_highest_page +
1:                 ";num_pages_compressed = " +  num_pages_compressed +
1:                 ";extentLength = " +  extentLength +
1:                 ";extent: \n" + toDebugString());
1:             */
1: 
1: 
1:             owner.getAllocationActionSet().actionCompressSpaceOperation(
1:                 ntt, alloc_page, new_highest_page, num_pages_compressed); 
1:             return(compress_bitnum);
1: 
1:     }
1: 
1:     protected void compressPages(
1:     int        new_highest_page,
1:     int        num_pages_truncated)
1:     {
1:         if (SanityManager.DEBUG)
1:         {
1:             if (new_highest_page >= 0)
1:             {
1:                 for (int i = new_highest_page + 1; i < extentLength; i++)
1:                 {
1:                     if (!freePages.isSet(i))
1:                     {
1:                         SanityManager.THROWASSERT(
1:                             "compressPages with non free page to truncate," +
1:                             "new_highest_page = " + new_highest_page +
1:                             "num_pages_truncated = " + num_pages_truncated +
1:                             ";extentLength = " + extentLength +
1:                             ";extentStart = " + extentStart +
1:                             ";freePages.isSet(" + i + ") = " + 
1:                                 freePages.isSet(i) +
1:                             "\nextent:\n" + toDebugString());
1:                     }
1:                 }
1:             }
1: 
1:             SanityManager.ASSERT(
1:                 (new_highest_page + num_pages_truncated + 1) == extentLength,
1:                 "truncate page count did not match: " +
1:                 ";new_highest_page = " + new_highest_page +
1:                 ";num_pages_truncated = " + num_pages_truncated +
1:                 ";extentLength = " + extentLength);
1: 
1:             // the following assert could be made invalid by a new type of
1:             // access method, but currently page 1 of btree and heap contain
1:             // control rows, so will never become free and thus should never
1:             // be compressed.
1:             if (extentStart == 1)
1:             {
1:                 SanityManager.ASSERT(new_highest_page >= 0);
1:                 SanityManager.ASSERT(num_pages_truncated < extentLength);
1:             }
1:         }
1: 
1:         if (new_highest_page >= 0)
1:         {
1:             freePages.shrink(new_highest_page + 1);
1:             unFilledPages.shrink(new_highest_page + 1);
1: 
1:             // This routine assumes the caller
1:             // will be doing the truncate, and just updates the data structures.
1:             preAllocLength = extentLength = (new_highest_page + 1);
1:         }
1: 
1:         return;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * translate bit position in map to page number.
1:      * <p>
1:      *
1: 	 * @return The page number of this "bit" in the extent map.
1:      *
0: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     protected long getPagenum(int bit_pos)
1:     {
1:         return(extentStart + bit_pos);
1:     }
1:         
1: 
/////////////////////////////////////////////////////////////////////////
1:             if (allocatedPageCount < 0)
1:             {
1:                 SanityManager.THROWASSERT(
1:                     "number of allocated page < 0, val =" + allocatedPageCount +
1:                     "\nextent = " + toDebugString());
1:             }
commit:44fe060
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Compress free pages at end of this extent.
1:      * <p>
1:      * Search backward from end of extent and prepare data structures
1:      * to return pages at end of extent to the OS. Returns the lowest
1:      * page that can be returned to the OS.
1:      * <p>
0:      *
0: 	 * @return Return bit of page where page and all those that follow can
1:      *         be returned to the OS.
1:      **/
/////////////////////////////////////////////////////////////////////////
0:                 unFilledPages.clear(i);
1: 
/////////////////////////////////////////////////////////////////////////
commit:bbc927c
/////////////////////////////////////////////////////////////////////////
0:     protected long compressPages()
1:     {
0:         int compress_bitnum = -1;
1: 
0:         for (int i = extentLength - 1; i >= 0; i--)
1:         {
1:             if (freePages.isSet(i))
1:             {
0:                 freePages.clear(i);
1:                 compress_bitnum = i;
1:             }
1:             else
1:             {
1:                 break;
1:             }
1:         }
1: 
0:         if (compress_bitnum >= 0)
1:         {
0:             extentLength = compress_bitnum;
0:             return(extentStart + extentLength - 1);
1:         }
1:         else
1:         {
1:             return(-1);
1:         }
1: 
1:     }
/////////////////////////////////////////////////////////////////////////
1:                     {
1:                     }
1:         {
0: 			SanityManager.ASSERT(
0:                 allocatedPageCount >= 0,
0:                 "number of allocated page < 0, val =" + allocatedPageCount +
0:                 "\nextent = " + toDebugString());
1:         }
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.store.raw.data.AllocExtent
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:c6ad534
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.raw.data
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.store.raw.data;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.store.raw.ContainerHandle;
1: 
1: import org.apache.derby.iapi.services.io.FormatableBitSet;
1: 
1: import java.io.Externalizable;
1: import java.io.IOException;
1: 
1: import java.io.ObjectOutput;
1: import java.io.ObjectInput;
1: 
1: /**
1: 
1: 	An allocation extent row manages the page status of page in the extent.
1: 	AllocExtent is externalizable and is written to the AllocPage directly,
1: 	without being converted to a row first.
1: 	<P>
1: 	<PRE>
0: 	@format_id	none, format implied by AllocPage's format
0: 	@purpose	manage page status of page in extent
0: 	@upgrade
0: 	@disk_layout
1: 		extentOffset(long) the begin physical byte offset of the first page of this extent
1: 		extentStart(long) the first logical page mananged by this extent.
1: 		extentEnd(long) the last page this extent can ever hope to manage 
1: 		extentLength(int) the number of pages allocated in this extent
1: 		extentStatus(int) status bits for the whole extent.
1: 				HAS_DEALLOCATED - most likely, this extent has a deallocated 
1:                         page somewhere
1: 						If !HAD_DEALLOCATED, the extent has no deallocated page
1: 				HAS_FREE - most likely, this extent has a free page somewhere
1: 						If !HAS_FREE, there is no free page in the extent
1: 				ALL_FREE - most likely, this extent only has free pages, good 
1:                         candidate for shrinking the file.
1: 						If !ALL_FREE, the extent is not all free
1: 				HAS_UNFILLED_PAGES - most likely, this extent has unfilled pages.
1: 						if !HAS_UNFILLED_PAGES, all pages are filled
1: 				KEEP_UNFILLED_PAGES - this extent keeps track of unfilled pages
1: 						(post v1.3).  If not set, this extent has no notion of
1: 						unfilled page and has no unFilledPage bitmap.
1: 				NO_DEALLOC_PAGE_MAP - this extents do not have a dealloc and a
1: 						free page bit maps.  Prior to 2.0, there are 2 bit
1: 						maps, a deallocate page bit map and a free page bit
1: 						map.  Cloudscape 2.0 and later merged the dealloc page
1: 						bit map into the free page bit map.
1: 				RETIRED - this extent contains only 'retired' pages, never use 
1:                         any page from this extent.  The pages don't actually 
1:                         exist, i.e., it maps to nothing (physicalOffset is 
1:                         garbage).  The purpose of this extent is to blot out a 
1:                         range of logical page numbers that no longer exists 
1:                         for this container.  Use this to reuse a physical page
1:                         when a logical page has exhausted all recordId or for
1:                         logical pages that has been shrunk out.
1: 		preAllocLength(int)  the number of pages that have been preallocated
1: 		reserved1(int)
1: 		reserved2(long)	reserved for future use
1: 		reserved3(long)	reserved for future use
1: 		FreePages(bit)	bitmap of free pages
1: 				Bit[i] is ON iff page i is free for immediate (re)use.
1: 		[
1: 		    on disk version before 2.0
1: 				deAllocPages(bit) bitmap of deallocated pages
1: 				Bit[i] is ON iff page i has been deallocated.
1: 		]
1: 		unFilledPages(bit)	bitmap of pages that has free space
1: 				Bit[i] is ON if page i is likely to be < 1/2 full
1: 
1: 		org.apache.derby.iapi.services.io.FormatableBitSet is used to store the bit map.  
1:             FormatableBitSet is an externalizable class.
1: 
0: 	@end_format
1: 
1: 	<PRE>
1: 	A page can have the following logical state:
1: 	<BR>Free - a page that is free to be used
1: 	<BR>Valid - a page that is currently in use
1: 	<P>
1: 	There is another type of transitional pages which pages that have been
1: 	allocated on disk but has not yet been used.  These pages are Free.
1: 	<P>
1: 	Bit[K] freePages
1: 		Bit[i] is ON iff page i maybe free for reuse.  User must get the
1: 		dealloc page lock on the free page to make sure the transaction.
1: 	<P>
1: 	K is the size of the bit array, it must be >= length.
1: 
1: 	@see AllocPage
1: */
1: 
1: 
1: public class AllocExtent implements Externalizable
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 	private long extentOffset;	// begin physical offset
1: 	private long extentStart;	// first logical page number
1: 	private long extentEnd;		// last logical page number
1: 	// page[extentStart] to page[extentEnd] are the pages in the range of this
1: 	// alloc extent.
1: 	// page[exentStart] to page[extentStart+extentLength-1] are actually
1: 	// allocated in this extent
1: 	// when the extent is completely allocated,
1: 	// extentEnd == extentStart+extentLength -1
1: 
1: 	private int extentLength;	// number of pages allocated in the extent
1: 
1: 	int extentStatus;
1: 
1: 	private int preAllocLength;
1: 
1: 	private int reserved1;
1: 	private long reserved2;
1: 	private long reserved3;
1: 
1: 	// extent Status bits
1: 	private static final int HAS_DEALLOCATED = 0x1;
1: 	private static final int HAS_FREE = 0x2;
1: 	private static final int ALL_FREE = 0x4;
1: 	private static final int HAS_UNFILLED_PAGES = 0x10;
1: 	private static final int KEEP_UNFILLED_PAGES = 0x10000000;
1: 	private static final int NO_DEALLOC_PAGE_MAP = 0x20000000;
1: 	private static final int RETIRED = 0x8;
1: 
1: 	/**
1: 		public Per Page status
1: 	*/
1: 	protected static final int ALLOCATED_PAGE = 0;
1: 	protected static final int DEALLOCATED_PAGE = 1;
1: 	protected static final int FREE_PAGE = 2;
1: 
1: 
1: 	// a page which is not a freePage is a regular old
1: 	// allocated page.  Only an allocated page can be unFilled.
1: 	FormatableBitSet freePages;
1: 	FormatableBitSet unFilledPages;
1: 
1: 	/**
1: 		Statically calculates how many pages this extent can manage given the
1: 		availspace number of bytes to store this extent in
1: 
1: 		if read/writeExternal changes, this must change too
1: 	*/
1: 	protected static int MAX_RANGE(int availspace)
1: 	{
1: 		/* extent Offset, Start, End, Length, Status, preAllocLength, reserved1,2,3 */
1: 		int bookkeeping = 	8 /* offset */ +
1: 							8 /* start */ +
1: 							8 /* end */ +
1: 							4 /* length */ +
1: 							4 /* status */ +
1: 							4 /* preAllocLength */ +
1: 							4 /* reserved1 */ +
1: 							8 /* reserved2 */ +
1: 							8 /* reserved3 */;
1: 		availspace -= bookkeeping;
1: 
1: 		// each bit array is allowed to the 1/3 the remaining space
1: 		availspace /= 3;
1: 
1: 		if (availspace <= 0)
1: 			return 0;
1: 
1: 		// ask bit array how many bits it can store in this amount of space
1: 		return FormatableBitSet.maxBitsForSpace(availspace);
1: 	}
1: 
1: 	/*
1: 	 * methods
1: 	 */
1: 
1: 	/*
1: 	 * ctors
1: 	 */
1: 	protected AllocExtent(long offset, // physical offset
1: 					   long start,  // starting logical page number
1: 					   int length,  // how many pages are in this extent
1: 					   int pagesize, // size of all the pages in the extent
1: 					   int maxlength) // initial size of the bit map arrays
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			if (length > maxlength)
1: 				SanityManager.THROWASSERT(
1: 							"length " + length + " > maxlength " + maxlength);
1: 		}
1: 
1: 
1: 		this.extentOffset = offset;
1: 		this.extentStart = start;
1: 		this.extentEnd = start+maxlength-1;
1: 
1: 		this.extentLength = length;
1: 		preAllocLength = extentLength;
1: 
1: 		if (length > 0)
1: 			extentStatus = HAS_FREE | ALL_FREE ;
1: 		else
1: 			extentStatus = 0;
1: 
1: 		extentStatus |= KEEP_UNFILLED_PAGES; // v1.3 or beyond
1: 		extentStatus |= NO_DEALLOC_PAGE_MAP; // v2.0 or beyond
1: 
1: 		int numbits = (1+(length/8))*8;
1: 		if (numbits > maxlength)
1: 			numbits = maxlength;
1: 
1: 		freePages = new FormatableBitSet(numbits);
1: 		unFilledPages = new FormatableBitSet(numbits);
1: 
1: 		// by definition, all pages are free to begin with, no pages are
1: 		// deallocated and no page is unfilled
1: 		for (int i = 0; i < length; i++)
1: 			freePages.set(i);
1: 	}
1: 
1: 	/*
1: 	  Copy constructor
1: 	*/
1: 	protected AllocExtent(AllocExtent original)
1: 	{
1: 		extentOffset = original.extentOffset;
1: 		extentStart	 = original.extentStart;
1: 		extentEnd	 = original.extentEnd;
1: 		extentLength = original.extentLength;
1: 		extentStatus = original.extentStatus;
1: 		preAllocLength = original.preAllocLength;
1: 
1: 		freePages = new FormatableBitSet(original.freePages);
1: 		unFilledPages = new FormatableBitSet(original.unFilledPages);
1: 	}
1: 
1: 
1: 	/*
1: 	 * Methods of Externalizable
1: 	 */
1: 	public AllocExtent()
1: 	{
1: 	}
1: 
1: 
1: 	public void writeExternal(ObjectOutput out) throws IOException
1: 	{
1: 
1: 		// any change to this routine must change maxRange
1: 		out.writeLong(extentOffset);
1: 		out.writeLong(extentStart);
1: 		out.writeLong(extentEnd);
1: 		out.writeInt(extentLength);
1: 		out.writeInt(extentStatus);
1: 		out.writeInt(preAllocLength);
1: 		out.writeInt(0);		// reserved1
1: 		out.writeLong(0);		// reserved2
1: 		out.writeLong(0);		// reserved3
1: 
1: 		freePages.writeExternal(out);
1: 		unFilledPages.writeExternal(out);
1: 	}
1: 
1: 	public void readExternal(ObjectInput in)
1: 		 throws IOException, ClassNotFoundException
1: 	{
1: 		// any change to this routine must change maxRange
1: 		extentOffset = in.readLong();
1: 		extentStart	= in.readLong();
1: 		extentEnd	= in.readLong();
1: 		extentLength = in.readInt();
1: 		extentStatus = in.readInt();
1: 		preAllocLength = in.readInt();
1: 		reserved1 = in.readInt();
1: 		reserved2 = in.readLong();
1: 		reserved3 = in.readLong();
1: 
1: 		freePages = new FormatableBitSet();	// don't know how to point to it
1: 		freePages.readExternal(in);
1: 
1: 		// this extent is created before 2.0
1: 		if ((extentStatus & NO_DEALLOC_PAGE_MAP) == 0)	
1: 		{
1: 			FormatableBitSet deAllocPages = new FormatableBitSet();
1: 			deAllocPages.readExternal(in);
1: 			// fold this into free page bit map
1: 			freePages.or(deAllocPages);
1: 			extentStatus |= NO_DEALLOC_PAGE_MAP; // dealloc page map has been merged
1: 		}
1: 
1: 		if ((extentStatus & KEEP_UNFILLED_PAGES) == KEEP_UNFILLED_PAGES)
1: 		{
1: 			unFilledPages = new FormatableBitSet();
1: 			unFilledPages.readExternal(in);
1: 		}
1: 		else					// before we keep track of unfilled pages pre 1.3
1: 		{
1: 			// make sure there are enough space
1: 			unFilledPages = new FormatableBitSet(freePages.getLength());
1: 			extentStatus |= KEEP_UNFILLED_PAGES; // now we keep track of them
1: 		}
1: 		
1: 	}
1: 
1: 
1: 	/*
1: 	 * methods specific to allocExtent
1: 	 */
1: 
1: 
1: 	/*
1: 	 * write operation that is called underneath the log
0: 	 *
1: 	 * page goes thru the following transition:
1: 	 * ALLOCATED_PAGE <-> deallocated page -> free page <-> ALLOCATED_PAGE
0: 	 *
1: 	 */
1: 
1: 	/**
1: 		Allocate this page - this is called underneath the log record
1: 
0: 		@exception StandardException Standard Cloudscape error policy
1: 	*/
1: 	protected void allocPage(long pagenum) throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			if (pagenum > getLastPagenum())
1: 			{
1: 				// adding a brand new page, it should be at most one off from the last page
1: 				if (pagenum > extentEnd)
1: 					SanityManager.THROWASSERT("pagenum " + pagenum +
1: 									 " is out of beyond my range (" +
1: 										extentStart + "," + extentEnd + ")");
1: 				if (pagenum != getLastPagenum() + 1)
1: 					SanityManager.THROWASSERT(
1: 						"skipping pages, lastPageNumber = " + getLastPagenum() +
1: 						 " pageNumber = " + pagenum + "\n");
1: 			}
1: 			else
1: 			{
1: 				// reuseing a page, make sure it is in range and is not already in use
1: 				checkInRange(pagenum);
1: 
1: 				int bitnum = (int)(pagenum-extentStart);
1: 
1: 				// either the pagenum is now free (do) or deallocated (undo)
1: 				if (!freePages.isSet(bitnum))
1:                 {
1: 					SanityManager.THROWASSERT(
1:                         "trying to re-allocate a page ( " +
1:                         pagenum + " ) that is already allocated ");
1:                 }
1: 			}
1: 		}
1: 
1: 		// don't know if we are redoing (from free -> valid)
1: 		// or undoing (from dealloc -> valid), reset them both
1: 		int bitnum = (int)(pagenum-extentStart);
1: 
1: 		if (bitnum >= freePages.getLength())	// expand the bit map
1: 		{
1: 			int numbits = (1+(bitnum/8))*8;
1: 			if (numbits > (int)(extentEnd - extentStart + 1))
1: 				numbits = (int)(extentEnd - extentStart + 1);
1: 
1: 			freePages.grow(numbits);
1: 			unFilledPages.grow(numbits);
1: 		}
1: 
1: 		// the first page to be allocated has pagenum == extentStart.
1: 		int numPageAlloced = (int)(pagenum-extentStart+1);
1: 
1: 		if (numPageAlloced > extentLength)
1: 		{
1: 			extentLength = numPageAlloced;
1: 		}
1: 
1: 		freePages.clear(bitnum);
1: 
1: 		// do not set the unfilled bit on a newly allocated page because
1: 		// we only keep track of unfilled HEAD page, not unfilled overflow
1: 		// page. 
1: 	}
1: 
1: 	/**
1: 	    Deallocate logical page pagenum - this is called underneath the log record.
1: 		pagenum must be a page managed by this extent and it must be valid
1: 
0: 		@exception StandardException Standard Cloudscape error policy
1: 	*/
1: 	protected void deallocPage(long pagenum) throws StandardException
1: 	{
1: 		int bitnum = (int)(pagenum-extentStart);
1: 
1: 		// the pagenum must now be either valid (do) or free (undo)
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			if (freePages.isSet(bitnum))
1: 				SanityManager.THROWASSERT(
1: 						"trying to deallocate a deallocated page " + pagenum);
1: 		}
1: 
1: 		freePages.set(bitnum);
1: 		unFilledPages.clear(bitnum); // deallocated page is never unfilled
1: 
1: 		setExtentFreePageStatus(true);
1: 	}
1: 
1: 
1: 	protected long getExtentEnd()
1: 	{
1: 		return extentEnd;
1: 	}
1: 
1: 
1: 	/*
1: 	 * read operation that is called above the log
1: 	 */
1: 
1: 	/**
1: 		Get a page number that is free
1: 	*/
1: 	protected long getFreePageNumber(long pnum)
1: 	{
1: 		// if we can reuse page, do so, otherwise add a brand new page
1: 		if (mayHaveFreePage())
1: 		{
1: 			// The last allocated page may be from a previous alloc extent, but
1: 			// if that extent is full and we are the first extent that can
1: 			// accomodate a new page, we may be picked.  In that case, pnum may
1: 			// be before the start of this extent.
1: 			int i = (pnum < extentStart) ? freePages.anySetBit() : 
1: 				freePages.anySetBit((int)(pnum-extentStart));
1: 
1: 			if (i != -1)
1: 			{
1:                 if (SanityManager.DEBUG)
1:                 {
1:  		    		if (i >= extentLength)
1:  		    			SanityManager.THROWASSERT("returned bit = " + i +
1: 			    						 " extent length = " + extentLength);
1: 			    }
1: 
1: 				return i+extentStart;
1: 			}
1: 
1: 			// the hint is wrong, no free page in the extent
1: 			// do this unlogged, it is just a hint, don't care if it is lost
1: 			if (pnum < extentStart)
1: 				setExtentFreePageStatus(false);
1: 		}
1: 
1: 		// maximally, we can have up to extendEnd page
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT(extentStart+extentLength <= extentEnd);
1: 
1: 		// need to add a brand new page, current end of extent is at page
1: 		// extentStart+extentLength-1;
1: 		return extentStart+extentLength;
1: 	}
1: 
1: 
1: 	/**
1: 		Get the physical offset of pagenum.
1: 		If deallocOK is true, then even if pagenum is deallocated, it is OK.
1: 		If deallocOK is false, then an exception is thrown if pagenum is
1: 		deallocated.
1: 
1: 		An exception is always thrown if pagenum is a free page
1: 
0: 		@exception StandardException Standard Cloudscape error policy
1: 	 */
1: 	protected long getPageOffset(long pagenum, int pagesize, boolean deallocOK) throws StandardException
1: 	{
1: 		return pagenum * pagesize;
1: 	}
1: 
1: 	/**
1: 		Return the status of this extent
1: 	*/
1: 	protected boolean isRetired()
1: 	{
1: 		return ((extentStatus & RETIRED) != 0);
1: 	}
1: 
1: 	private boolean mayHaveFreePage()
1: 	{
1: 		return ((extentStatus & HAS_FREE) != 0);
1: 	}
1: 
1: 	private void setExtentFreePageStatus(boolean hasFree)
1: 	{
1: 		if (hasFree)
1: 			extentStatus |= HAS_FREE;
1: 		else
1: 			extentStatus &= ~HAS_FREE;
1: 	}
1: 
1: 	protected boolean canAddFreePage(long lastAllocatedPage)
1: 	{
1: 		// the last page to be allocated == extentEnd
1: 		if (extentStart + extentLength <= extentEnd)
1: 			return true;
1: 
1: 		// else, check to see if this may have any free page
1: 		if (!mayHaveFreePage())
1: 			return false;
1: 
1: 		// we may have a free page, but that is not certain, double check
1: 		if (lastAllocatedPage < extentStart)
1: 			return (freePages.anySetBit() != -1);
1: 		else
1: 			return ((freePages.anySetBit((int)(lastAllocatedPage-extentStart))) != -1);
1: 	}
1: 
1: 	/**
1: 		Return the status of a particular page
1: 	*/
1: 	protected int getPageStatus(long pagenum)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 			checkInRange(pagenum);
1: 
1: 		int status = 0;
1: 		int bitnum = (int)(pagenum-extentStart);
1: 
1: 		if (freePages.isSet(bitnum))
1: 			status = FREE_PAGE;
1: 		else
1: 			status = ALLOCATED_PAGE;
1: 
1: 		return status;
1: 	}
1: 
1: 
1: 	/**
1: 		Get the first logical page number managed by this extent.
1: 	*/
1: 	protected long getFirstPagenum()
1: 	{
1: 		return extentStart;
1: 	}
1: 
1: 	/**
1: 		Get the last logical page number managed by this extent.
1: 	*/
1: 	protected long getLastPagenum()
1: 	{
1: 		return extentStart+extentLength-1;
1: 	}
1: 
1: 
1: 	/*
1: 	 * page preallocation 
1: 	 */
1: 
1: 	/**
1: 	 * get the last preallocated pagenumber managed by this alloc page
1: 	 */
1: 	protected long getLastPreallocPagenum()
1: 	{
1: 		if (extentLength > preAllocLength)
1: 			preAllocLength = extentLength;
1: 
1: 		return extentStart + preAllocLength - 1 ;
1: 	}
1: 
1: 	/**
1: 		preallocated N pages, passed in the last preallocated page number.
1: 	*/
1: 	protected void setLastPreallocPagenum(long preAllocPagenum)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT(preAllocPagenum >= getLastPreallocPagenum(),
1:                 "setLastPreallocPagenum set to small prealloc length than before");
1: 
1: 		// cannot prealloc more than this extent can handle
1: 		if (preAllocPagenum > extentEnd)
1: 			preAllocPagenum = extentEnd;
1: 
1: 		preAllocLength = (int)(preAllocPagenum - extentStart + 1);
1: 	}
1: 
1: 
1: 	/*
1: 	  Get the logical page number that is bigger than prevPageNumber
1: 	  and is a valid page.  If no such page in this extent, return
1: 	  ContainerHandle.INVALID_PAGE_HANDLE
1: 	*/
1: 	protected long getNextValidPageNumber(long prevPageNumber)
1: 	{
1: 		long pageNum;
1: 		long lastpage = getLastPagenum();
1: 
1: 		if (prevPageNumber < extentStart)
1: 			pageNum = extentStart;
1: 		else
1: 			pageNum = prevPageNumber +1;
1: 
1: 		while(pageNum <= lastpage)
1: 		{
1: 			int status = getPageStatus(pageNum);
1: 			if (status == ALLOCATED_PAGE)
1: 				break;
1: 			pageNum++;
1: 		}
1: 
1: 		if (pageNum > lastpage)
1: 			pageNum = ContainerHandle.INVALID_PAGE_NUMBER;
1: 		return pageNum;
1: 	}
1: 
1: 
1: 	protected long getLastValidPageNumber()
1: 	{
1: 		long pageNum = getLastPagenum();
1: 		while(pageNum >= extentStart)
1: 		{
1: 			int status = getPageStatus(pageNum);
1: 			if (status == ALLOCATED_PAGE)
1: 				break;
1: 			pageNum--;
1: 		}
1: 		if (pageNum < extentStart)
1: 			pageNum = ContainerHandle.INVALID_PAGE_NUMBER;
1: 		return pageNum;
1: 	}
1: 
1: 	private void checkInRange(long pagenum)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 			if (pagenum < extentStart || pagenum >= extentStart+extentLength)
1: 				SanityManager.THROWASSERT(
1:                     "pagenum " + pagenum + " out of range");
1: 	}
1: 
1: 	protected void updateUnfilledPageInfo(AllocExtent inputExtent)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1:             if (inputExtent.unFilledPages.getLength() != 
1:                     unFilledPages.getLength())
1:             {
1:                 SanityManager.THROWASSERT(
1:                     "inputExtent's unfilled page length " +
1:                     inputExtent.unFilledPages.getLength() + 
1:                     " != extent's unfilled page length " + 
1:                     unFilledPages.getLength());
1:             }
1: 		}
1: 
1: 		// just use the passed in inputExtent, we know (wink wink) that the
1: 		// unfilled page info is being updated just when the allocation cache
1: 		// is being invalidated.  Nobody is going to have a reference to the
1: 		// inputExtent after this so is it save to share the FormatableBitSet.
1: 
1: 		// if we cannot guarentee that the inputExtent will be unchanged by the
1: 		// caller, we need to copy it 		
1: 		//		unFilledPages = new FormatableBitSet(inputExtent.unFilledPages);
1: 		// Right now, just reference it directly
1: 		unFilledPages = inputExtent.unFilledPages;
1: 
1: 		if (unFilledPages.anySetBit() >= 0)
1: 			extentStatus |= HAS_UNFILLED_PAGES;
1: 		else
1: 			extentStatus &= ~HAS_UNFILLED_PAGES;
1: 	}
1: 
1: 	/*
1: 		Keep track of unfilled pages, if the extent changed, returns true.
1: 	 */
1: 	protected boolean trackUnfilledPage(long pagenumber, boolean unfilled)
1: 	{
1: 		checkInRange(pagenumber);
1: 
1: 		int bitnum = (int)(pagenumber-extentStart);
1: 
1: 		boolean bitSet = unFilledPages.isSet(bitnum);
1: 		if (unfilled != bitSet)
1: 		{
1: 			if (unfilled)
1: 			{
1: 				unFilledPages.set(bitnum);
1: 				extentStatus |= HAS_UNFILLED_PAGES;
1: 			}
1: 			else
1: 				unFilledPages.clear(bitnum);
1: 			return true;
1: 		}
1: 
1: 		return false;
1: 	}
1: 
1: 	/**
1: 		Get a page number that is unfilled, pagenum is the last page that was
1: 		rejected.
1: 	 */
1: 	protected long getUnfilledPageNumber(long pagenum)
1: 	{
1: 		if ((extentStatus & HAS_UNFILLED_PAGES) == 0)
1: 			return ContainerHandle.INVALID_PAGE_NUMBER;
1: 
1: 		int i = unFilledPages.anySetBit();
1: 
1: 		if (i != -1)
1: 		{
1: 			if (i+extentStart != pagenum)
1: 				return i+extentStart;
1: 			else
1: 			{
1: 				// unfortunately, we found the same page number that
1: 				// was rejected.  It would be unwise to unset bit
1: 				// pagenum because just because it was rejected does not mean
1: 				// the page is full, the row we are trying to insert may just
1: 				// be too big.  If we unset it, we will never find that page
1: 				// again even though it may be a perfectly good page for any
1: 				// other row.  Just get the next set bit.
1: 				i = unFilledPages.anySetBit(i);
1: 				if (i != -1)
1: 					return i+extentStart;
1: 			}
1: 		}
1: 
1: 		return ContainerHandle.INVALID_PAGE_NUMBER;
1: 
1: 	}
1: 
1: 	/**
1: 		Get the number of used page in this extent
1: 	 */
1: 	protected int getAllocatedPageCount()
1: 	{
1: 		// allocated page is one which is not free or deallocated.
1: 		int allocatedPageCount = extentLength;
1: 
1: 		if (!mayHaveFreePage())
1: 			return allocatedPageCount;
1: 
1: 
1: 		byte[] free = freePages.getByteArray();
1: 		int numBytes = free.length;
1: 
1: 		for (int i = 0; i < numBytes; i++)
1: 		{
1: 			if (free[i] != 0)
1: 			{
1: 				for (int j = 0; j < 8; j++)
1: 				{
1: 					if (((1 << j) & free[i]) != 0)
1: 						allocatedPageCount--;
1: 				}
1: 			}
1: 		}
1: 
1: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(allocatedPageCount >= 0,
0: 								 "number of allocated page < 0");
1: 
1: 		return allocatedPageCount;
1: 	}
1: 
1: 
1: 	/**
1: 		Get the number of unfilled pages in this extent
1: 	 */
1: 	protected int getUnfilledPageCount()
1: 	{
1:         int unfilledPageCount = 0;
1:         int freePagesSize = freePages.size();
1: 
1:         for (int i = 0; i < unFilledPages.size(); i++)
1:         {
1:             if (unFilledPages.isSet(i) &&
1:                 (i >= freePagesSize || !freePages.isSet(i)))
1:                 unfilledPageCount++;
1:         }
1: 
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT(unfilledPageCount >= 0,
1: 								 "number of unfilled pages < 0");
1: 
1:         return unfilledPageCount;
1:  	}
1: 
1: 
1: 	/**
1: 		Get the total number of pages in this extent
1: 	 */
1: 	protected int getTotalPageCount()
1: 	{
1:         return extentLength;
1:     }
1: 
1: 	protected String toDebugString()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			String str =
1: 				"------------------------------------------------------------------------------\n" +
1: 				"Extent map of from page " + extentStart + " to page " + extentEnd + "\n";
1: 
1: 			for (long i = extentStart; i < extentStart+extentLength; i++)
1: 			{
1: 				str += "\tpage " + i + ": ";
1: 				switch(getPageStatus(i))
1: 				{
1: 				case FREE_PAGE: str += "free page\n"; break;
1: 				case ALLOCATED_PAGE: str += "valid, in use page\n"; break;
1: 				}
1: 
1: 		        // int bitnum = (int)(i-extentStart);
1:         		// if (unFilledPages.isSet(bitnum))
1:                 //    str += "          page is estimated to be unfilled\n";
1: 			}
1: 
1: 			if (getLastPagenum() < extentEnd)
1: 				str += "\tFrom " + getLastPagenum() + " to " + extentEnd +
1: 					" are un-allocated pages\n";
1: 
1: 			str += "------------------------------------------------------------------------------\n";
1: 
1: 			return str;
1: 		}
1: 		else
1: 			return null;
1: 	}
1: 
1: }
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.raw.data
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.store.raw.data;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.store.raw.ContainerHandle;
0: 
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: 
0: import java.io.Externalizable;
0: import java.io.IOException;
0: 
0: import java.io.ObjectOutput;
0: import java.io.ObjectInput;
0: 
0: /**
0: 
0: 	An allocation extent row manages the page status of page in the extent.
0: 	AllocExtent is externalizable and is written to the AllocPage directly,
0: 	without being converted to a row first.
0: 	<P>
0: 	<PRE>
0: 	@format_id	none, format implied by AllocPage's format
0: 	@purpose	manage page status of page in extent
0: 	@upgrade
0: 	@disk_layout
0: 		extentOffset(long) the begin physical byte offset of the first page of this extent
0: 		extentStart(long) the first logical page mananged by this extent.
0: 		extentEnd(long) the last page this extent can ever hope to manage 
0: 		extentLength(int) the number of pages allocated in this extent
0: 		extentStatus(int) status bits for the whole extent.
0: 				HAS_DEALLOCATED - most likely, this extent has a deallocated 
0:                         page somewhere
0: 						If !HAD_DEALLOCATED, the extent has no deallocated page
0: 				HAS_FREE - most likely, this extent has a free page somewhere
0: 						If !HAS_FREE, there is no free page in the extent
0: 				ALL_FREE - most likely, this extent only has free pages, good 
0:                         candidate for shrinking the file.
0: 						If !ALL_FREE, the extent is not all free
0: 				HAS_UNFILLED_PAGES - most likely, this extent has unfilled pages.
0: 						if !HAS_UNFILLED_PAGES, all pages are filled
0: 				KEEP_UNFILLED_PAGES - this extent keeps track of unfilled pages
0: 						(post v1.3).  If not set, this extent has no notion of
0: 						unfilled page and has no unFilledPage bitmap.
0: 				NO_DEALLOC_PAGE_MAP - this extents do not have a dealloc and a
0: 						free page bit maps.  Prior to 2.0, there are 2 bit
0: 						maps, a deallocate page bit map and a free page bit
0: 						map.  Cloudscape 2.0 and later merged the dealloc page
0: 						bit map into the free page bit map.
0: 				RETIRED - this extent contains only 'retired' pages, never use 
0:                         any page from this extent.  The pages don't actually 
0:                         exist, i.e., it maps to nothing (physicalOffset is 
0:                         garbage).  The purpose of this extent is to blot out a 
0:                         range of logical page numbers that no longer exists 
0:                         for this container.  Use this to reuse a physical page
0:                         when a logical page has exhausted all recordId or for
0:                         logical pages that has been shrunk out.
0: 		preAllocLength(int)  the number of pages that have been preallocated
0: 		reserved1(int)
0: 		reserved2(long)	reserved for future use
0: 		reserved3(long)	reserved for future use
0: 		FreePages(bit)	bitmap of free pages
0: 				Bit[i] is ON iff page i is free for immediate (re)use.
0: 		[
0: 		    on disk version before 2.0
0: 				deAllocPages(bit) bitmap of deallocated pages
0: 				Bit[i] is ON iff page i has been deallocated.
0: 		]
0: 		unFilledPages(bit)	bitmap of pages that has free space
0: 				Bit[i] is ON if page i is likely to be < 1/2 full
0: 
0: 		org.apache.derby.iapi.services.io.FormatableBitSet is used to store the bit map.  
0:             FormatableBitSet is an externalizable class.
0: 
0: 	@end_format
0: 
0: 	<PRE>
0: 	A page can have the following logical state:
0: 	<BR>Free - a page that is free to be used
0: 	<BR>Valid - a page that is currently in use
0: 	<P>
0: 	There is another type of transitional pages which pages that have been
0: 	allocated on disk but has not yet been used.  These pages are Free.
0: 	<P>
0: 	Bit[K] freePages
0: 		Bit[i] is ON iff page i maybe free for reuse.  User must get the
0: 		dealloc page lock on the free page to make sure the transaction.
0: 	<P>
0: 	K is the size of the bit array, it must be >= length.
0: 
0: 	@see AllocPage
0: */
0: 
0: 
0: public class AllocExtent implements Externalizable
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	private long extentOffset;	// begin physical offset
0: 	private long extentStart;	// first logical page number
0: 	private long extentEnd;		// last logical page number
0: 	// page[extentStart] to page[extentEnd] are the pages in the range of this
0: 	// alloc extent.
0: 	// page[exentStart] to page[extentStart+extentLength-1] are actually
0: 	// allocated in this extent
0: 	// when the extent is completely allocated,
0: 	// extentEnd == extentStart+extentLength -1
0: 
0: 	private int extentLength;	// number of pages allocated in the extent
0: 
0: 	int extentStatus;
0: 
0: 	private int preAllocLength;
0: 
0: 	private int reserved1;
0: 	private long reserved2;
0: 	private long reserved3;
0: 
0: 	// extent Status bits
0: 	private static final int HAS_DEALLOCATED = 0x1;
0: 	private static final int HAS_FREE = 0x2;
0: 	private static final int ALL_FREE = 0x4;
0: 	private static final int HAS_UNFILLED_PAGES = 0x10;
0: 	private static final int KEEP_UNFILLED_PAGES = 0x10000000;
0: 	private static final int NO_DEALLOC_PAGE_MAP = 0x20000000;
0: 	private static final int RETIRED = 0x8;
0: 
0: 	/**
0: 		public Per Page status
0: 	*/
0: 	protected static final int ALLOCATED_PAGE = 0;
0: 	protected static final int DEALLOCATED_PAGE = 1;
0: 	protected static final int FREE_PAGE = 2;
0: 
0: 
0: 	// a page which is not a freePage is a regular old
0: 	// allocated page.  Only an allocated page can be unFilled.
0: 	FormatableBitSet freePages;
0: 	FormatableBitSet unFilledPages;
0: 
0: 	/**
0: 		Statically calculates how many pages this extent can manage given the
0: 		availspace number of bytes to store this extent in
0: 
0: 		if read/writeExternal changes, this must change too
0: 	*/
0: 	protected static int MAX_RANGE(int availspace)
0: 	{
0: 		/* extent Offset, Start, End, Length, Status, preAllocLength, reserved1,2,3 */
0: 		int bookkeeping = 	8 /* offset */ +
0: 							8 /* start */ +
0: 							8 /* end */ +
0: 							4 /* length */ +
0: 							4 /* status */ +
0: 							4 /* preAllocLength */ +
0: 							4 /* reserved1 */ +
0: 							8 /* reserved2 */ +
0: 							8 /* reserved3 */;
0: 		availspace -= bookkeeping;
0: 
0: 		// each bit array is allowed to the 1/3 the remaining space
0: 		availspace /= 3;
0: 
0: 		if (availspace <= 0)
0: 			return 0;
0: 
0: 		// ask bit array how many bits it can store in this amount of space
0: 		return FormatableBitSet.maxBitsForSpace(availspace);
0: 	}
0: 
0: 	/*
0: 	 * methods
0: 	 */
0: 
0: 	/*
0: 	 * ctors
0: 	 */
0: 	protected AllocExtent(long offset, // physical offset
0: 					   long start,  // starting logical page number
0: 					   int length,  // how many pages are in this extent
0: 					   int pagesize, // size of all the pages in the extent
0: 					   int maxlength) // initial size of the bit map arrays
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (length > maxlength)
0: 				SanityManager.THROWASSERT(
0: 							"length " + length + " > maxlength " + maxlength);
0: 		}
0: 
0: 
0: 		this.extentOffset = offset;
0: 		this.extentStart = start;
0: 		this.extentEnd = start+maxlength-1;
0: 
0: 		this.extentLength = length;
0: 		preAllocLength = extentLength;
0: 
0: 		if (length > 0)
0: 			extentStatus = HAS_FREE | ALL_FREE ;
0: 		else
0: 			extentStatus = 0;
0: 
0: 		extentStatus |= KEEP_UNFILLED_PAGES; // v1.3 or beyond
0: 		extentStatus |= NO_DEALLOC_PAGE_MAP; // v2.0 or beyond
0: 
0: 		int numbits = (1+(length/8))*8;
0: 		if (numbits > maxlength)
0: 			numbits = maxlength;
0: 
0: 		freePages = new FormatableBitSet(numbits);
0: 		unFilledPages = new FormatableBitSet(numbits);
0: 
0: 		// by definition, all pages are free to begin with, no pages are
0: 		// deallocated and no page is unfilled
0: 		for (int i = 0; i < length; i++)
0: 			freePages.set(i);
0: 	}
0: 
0: 	/*
0: 	  Copy constructor
0: 	*/
0: 	protected AllocExtent(AllocExtent original)
0: 	{
0: 		extentOffset = original.extentOffset;
0: 		extentStart	 = original.extentStart;
0: 		extentEnd	 = original.extentEnd;
0: 		extentLength = original.extentLength;
0: 		extentStatus = original.extentStatus;
0: 		preAllocLength = original.preAllocLength;
0: 
0: 		freePages = new FormatableBitSet(original.freePages);
0: 		unFilledPages = new FormatableBitSet(original.unFilledPages);
0: 	}
0: 
0: 
0: 	/*
0: 	 * Methods of Externalizable
0: 	 */
0: 	public AllocExtent()
0: 	{
0: 	}
0: 
0: 
0: 	public void writeExternal(ObjectOutput out) throws IOException
0: 	{
0: 
0: 		// any change to this routine must change maxRange
0: 		out.writeLong(extentOffset);
0: 		out.writeLong(extentStart);
0: 		out.writeLong(extentEnd);
0: 		out.writeInt(extentLength);
0: 		out.writeInt(extentStatus);
0: 		out.writeInt(preAllocLength);
0: 		out.writeInt(0);		// reserved1
0: 		out.writeLong(0);		// reserved2
0: 		out.writeLong(0);		// reserved3
0: 
0: 		freePages.writeExternal(out);
0: 		unFilledPages.writeExternal(out);
0: 	}
0: 
0: 	public void readExternal(ObjectInput in)
0: 		 throws IOException, ClassNotFoundException
0: 	{
0: 		// any change to this routine must change maxRange
0: 		extentOffset = in.readLong();
0: 		extentStart	= in.readLong();
0: 		extentEnd	= in.readLong();
0: 		extentLength = in.readInt();
0: 		extentStatus = in.readInt();
0: 		preAllocLength = in.readInt();
0: 		reserved1 = in.readInt();
0: 		reserved2 = in.readLong();
0: 		reserved3 = in.readLong();
0: 
0: 		freePages = new FormatableBitSet();	// don't know how to point to it
0: 		freePages.readExternal(in);
0: 
0: 		// this extent is created before 2.0
0: 		if ((extentStatus & NO_DEALLOC_PAGE_MAP) == 0)	
0: 		{
0: 			FormatableBitSet deAllocPages = new FormatableBitSet();
0: 			deAllocPages.readExternal(in);
0: 			// fold this into free page bit map
0: 			freePages.or(deAllocPages);
0: 			extentStatus |= NO_DEALLOC_PAGE_MAP; // dealloc page map has been merged
0: 		}
0: 
0: 		if ((extentStatus & KEEP_UNFILLED_PAGES) == KEEP_UNFILLED_PAGES)
0: 		{
0: 			unFilledPages = new FormatableBitSet();
0: 			unFilledPages.readExternal(in);
0: 		}
0: 		else					// before we keep track of unfilled pages pre 1.3
0: 		{
0: 			// make sure there are enough space
0: 			unFilledPages = new FormatableBitSet(freePages.getLength());
0: 			extentStatus |= KEEP_UNFILLED_PAGES; // now we keep track of them
0: 		}
0: 		
0: 	}
0: 
0: 
0: 	/*
0: 	 * methods specific to allocExtent
0: 	 */
0: 
0: 
0: 	/*
0: 	 * write operation that is called underneath the log
0: 	 *
0: 	 * page goes thru the following transition:
0: 	 * ALLOCATED_PAGE <-> deallocated page -> free page <-> ALLOCATED_PAGE
0: 	 *
0: 	 */
0: 
0: 	/**
0: 		Allocate this page - this is called underneath the log record
0: 
0: 		@exception StandardException Standard Cloudscape error policy
0: 	*/
0: 	protected void allocPage(long pagenum) throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (pagenum > getLastPagenum())
0: 			{
0: 				// adding a brand new page, it should be at most one off from the last page
0: 				if (pagenum > extentEnd)
0: 					SanityManager.THROWASSERT("pagenum " + pagenum +
0: 									 " is out of beyond my range (" +
0: 										extentStart + "," + extentEnd + ")");
0: 				if (pagenum != getLastPagenum() + 1)
0: 					SanityManager.THROWASSERT(
0: 						"skipping pages, lastPageNumber = " + getLastPagenum() +
0: 						 " pageNumber = " + pagenum + "\n");
0: 			}
0: 			else
0: 			{
0: 				// reuseing a page, make sure it is in range and is not already in use
0: 				checkInRange(pagenum);
0: 
0: 				int bitnum = (int)(pagenum-extentStart);
0: 
0: 				// either the pagenum is now free (do) or deallocated (undo)
0: 				if (!freePages.isSet(bitnum))
0:                 {
0: 					SanityManager.THROWASSERT(
0:                         "trying to re-allocate a page ( " +
0:                         pagenum + " ) that is already allocated ");
0:                 }
0: 			}
0: 		}
0: 
0: 		// don't know if we are redoing (from free -> valid)
0: 		// or undoing (from dealloc -> valid), reset them both
0: 		int bitnum = (int)(pagenum-extentStart);
0: 
0: 		if (bitnum >= freePages.getLength())	// expand the bit map
0: 		{
0: 			int numbits = (1+(bitnum/8))*8;
0: 			if (numbits > (int)(extentEnd - extentStart + 1))
0: 				numbits = (int)(extentEnd - extentStart + 1);
0: 
0: 			freePages.grow(numbits);
0: 			unFilledPages.grow(numbits);
0: 		}
0: 
0: 		// the first page to be allocated has pagenum == extentStart.
0: 		int numPageAlloced = (int)(pagenum-extentStart+1);
0: 
0: 		if (numPageAlloced > extentLength)
0: 		{
0: 			extentLength = numPageAlloced;
0: 		}
0: 
0: 		freePages.clear(bitnum);
0: 
0: 		// do not set the unfilled bit on a newly allocated page because
0: 		// we only keep track of unfilled HEAD page, not unfilled overflow
0: 		// page. 
0: 	}
0: 
0: 	/**
0: 	    Deallocate logical page pagenum - this is called underneath the log record.
0: 		pagenum must be a page managed by this extent and it must be valid
0: 
0: 		@exception StandardException Standard Cloudscape error policy
0: 	*/
0: 	protected void deallocPage(long pagenum) throws StandardException
0: 	{
0: 		int bitnum = (int)(pagenum-extentStart);
0: 
0: 		// the pagenum must now be either valid (do) or free (undo)
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (freePages.isSet(bitnum))
0: 				SanityManager.THROWASSERT(
0: 						"trying to deallocate a deallocated page " + pagenum);
0: 		}
0: 
0: 		freePages.set(bitnum);
0: 		unFilledPages.clear(bitnum); // deallocated page is never unfilled
0: 
0: 		setExtentFreePageStatus(true);
0: 	}
0: 
0: 
0: 	protected long getExtentEnd()
0: 	{
0: 		return extentEnd;
0: 	}
0: 
0: 
0: 	/*
0: 	 * read operation that is called above the log
0: 	 */
0: 
0: 	/**
0: 		Get a page number that is free
0: 	*/
0: 	protected long getFreePageNumber(long pnum)
0: 	{
0: 		// if we can reuse page, do so, otherwise add a brand new page
0: 		if (mayHaveFreePage())
0: 		{
0: 			// The last allocated page may be from a previous alloc extent, but
0: 			// if that extent is full and we are the first extent that can
0: 			// accomodate a new page, we may be picked.  In that case, pnum may
0: 			// be before the start of this extent.
0: 			int i = (pnum < extentStart) ? freePages.anySetBit() : 
0: 				freePages.anySetBit((int)(pnum-extentStart));
0: 
0: 			if (i != -1)
0: 			{
0:                 if (SanityManager.DEBUG)
0:                 {
0:  		    		if (i >= extentLength)
0:  		    			SanityManager.THROWASSERT("returned bit = " + i +
0: 			    						 " extent length = " + extentLength);
0: 			    }
0: 
0: 				return i+extentStart;
0: 			}
0: 
0: 			// the hint is wrong, no free page in the extent
0: 			// do this unlogged, it is just a hint, don't care if it is lost
0: 			if (pnum < extentStart)
0: 				setExtentFreePageStatus(false);
0: 		}
0: 
0: 		// maximally, we can have up to extendEnd page
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(extentStart+extentLength <= extentEnd);
0: 
0: 		// need to add a brand new page, current end of extent is at page
0: 		// extentStart+extentLength-1;
0: 		return extentStart+extentLength;
0: 	}
0: 
0: 
0: 	/**
0: 		Get the physical offset of pagenum.
0: 		If deallocOK is true, then even if pagenum is deallocated, it is OK.
0: 		If deallocOK is false, then an exception is thrown if pagenum is
0: 		deallocated.
0: 
0: 		An exception is always thrown if pagenum is a free page
0: 
0: 		@exception StandardException Standard Cloudscape error policy
0: 	 */
0: 	protected long getPageOffset(long pagenum, int pagesize, boolean deallocOK) throws StandardException
0: 	{
0: 		return pagenum * pagesize;
0: 	}
0: 
0: 	/**
0: 		Return the status of this extent
0: 	*/
0: 	protected boolean isRetired()
0: 	{
0: 		return ((extentStatus & RETIRED) != 0);
0: 	}
0: 
0: 	private boolean mayHaveFreePage()
0: 	{
0: 		return ((extentStatus & HAS_FREE) != 0);
0: 	}
0: 
0: 	private void setExtentFreePageStatus(boolean hasFree)
0: 	{
0: 		if (hasFree)
0: 			extentStatus |= HAS_FREE;
0: 		else
0: 			extentStatus &= ~HAS_FREE;
0: 	}
0: 
0: 	protected boolean canAddFreePage(long lastAllocatedPage)
0: 	{
0: 		// the last page to be allocated == extentEnd
0: 		if (extentStart + extentLength <= extentEnd)
0: 			return true;
0: 
0: 		// else, check to see if this may have any free page
0: 		if (!mayHaveFreePage())
0: 			return false;
0: 
0: 		// we may have a free page, but that is not certain, double check
0: 		if (lastAllocatedPage < extentStart)
0: 			return (freePages.anySetBit() != -1);
0: 		else
0: 			return ((freePages.anySetBit((int)(lastAllocatedPage-extentStart))) != -1);
0: 	}
0: 
0: 	/**
0: 		Return the status of a particular page
0: 	*/
0: 	protected int getPageStatus(long pagenum)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 			checkInRange(pagenum);
0: 
0: 		int status = 0;
0: 		int bitnum = (int)(pagenum-extentStart);
0: 
0: 		if (freePages.isSet(bitnum))
0: 			status = FREE_PAGE;
0: 		else
0: 			status = ALLOCATED_PAGE;
0: 
0: 		return status;
0: 	}
0: 
0: 
0: 	/**
0: 		Get the first logical page number managed by this extent.
0: 	*/
0: 	protected long getFirstPagenum()
0: 	{
0: 		return extentStart;
0: 	}
0: 
0: 	/**
0: 		Get the last logical page number managed by this extent.
0: 	*/
0: 	protected long getLastPagenum()
0: 	{
0: 		return extentStart+extentLength-1;
0: 	}
0: 
0: 
0: 	/*
0: 	 * page preallocation 
0: 	 */
0: 
0: 	/**
0: 	 * get the last preallocated pagenumber managed by this alloc page
0: 	 */
0: 	protected long getLastPreallocPagenum()
0: 	{
0: 		if (extentLength > preAllocLength)
0: 			preAllocLength = extentLength;
0: 
0: 		return extentStart + preAllocLength - 1 ;
0: 	}
0: 
0: 	/**
0: 		preallocated N pages, passed in the last preallocated page number.
0: 	*/
0: 	protected void setLastPreallocPagenum(long preAllocPagenum)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(preAllocPagenum >= getLastPreallocPagenum(),
0:                 "setLastPreallocPagenum set to small prealloc length than before");
0: 
0: 		// cannot prealloc more than this extent can handle
0: 		if (preAllocPagenum > extentEnd)
0: 			preAllocPagenum = extentEnd;
0: 
0: 		preAllocLength = (int)(preAllocPagenum - extentStart + 1);
0: 	}
0: 
0: 
0: 	/*
0: 	  Get the logical page number that is bigger than prevPageNumber
0: 	  and is a valid page.  If no such page in this extent, return
0: 	  ContainerHandle.INVALID_PAGE_HANDLE
0: 	*/
0: 	protected long getNextValidPageNumber(long prevPageNumber)
0: 	{
0: 		long pageNum;
0: 		long lastpage = getLastPagenum();
0: 
0: 		if (prevPageNumber < extentStart)
0: 			pageNum = extentStart;
0: 		else
0: 			pageNum = prevPageNumber +1;
0: 
0: 		while(pageNum <= lastpage)
0: 		{
0: 			int status = getPageStatus(pageNum);
0: 			if (status == ALLOCATED_PAGE)
0: 				break;
0: 			pageNum++;
0: 		}
0: 
0: 		if (pageNum > lastpage)
0: 			pageNum = ContainerHandle.INVALID_PAGE_NUMBER;
0: 		return pageNum;
0: 	}
0: 
0: 
0: 	protected long getLastValidPageNumber()
0: 	{
0: 		long pageNum = getLastPagenum();
0: 		while(pageNum >= extentStart)
0: 		{
0: 			int status = getPageStatus(pageNum);
0: 			if (status == ALLOCATED_PAGE)
0: 				break;
0: 			pageNum--;
0: 		}
0: 		if (pageNum < extentStart)
0: 			pageNum = ContainerHandle.INVALID_PAGE_NUMBER;
0: 		return pageNum;
0: 	}
0: 
0: 	private void checkInRange(long pagenum)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 			if (pagenum < extentStart || pagenum >= extentStart+extentLength)
0: 				SanityManager.THROWASSERT(
0:                     "pagenum " + pagenum + " out of range");
0: 	}
0: 
0: 	protected void updateUnfilledPageInfo(AllocExtent inputExtent)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0:             if (inputExtent.unFilledPages.getLength() != 
0:                     unFilledPages.getLength())
0:             {
0:                 SanityManager.THROWASSERT(
0:                     "inputExtent's unfilled page length " +
0:                     inputExtent.unFilledPages.getLength() + 
0:                     " != extent's unfilled page length " + 
0:                     unFilledPages.getLength());
0:             }
0: 		}
0: 
0: 		// just use the passed in inputExtent, we know (wink wink) that the
0: 		// unfilled page info is being updated just when the allocation cache
0: 		// is being invalidated.  Nobody is going to have a reference to the
0: 		// inputExtent after this so is it save to share the FormatableBitSet.
0: 
0: 		// if we cannot guarentee that the inputExtent will be unchanged by the
0: 		// caller, we need to copy it 		
0: 		//		unFilledPages = new FormatableBitSet(inputExtent.unFilledPages);
0: 		// Right now, just reference it directly
0: 		unFilledPages = inputExtent.unFilledPages;
0: 
0: 		if (unFilledPages.anySetBit() >= 0)
0: 			extentStatus |= HAS_UNFILLED_PAGES;
0: 		else
0: 			extentStatus &= ~HAS_UNFILLED_PAGES;
0: 	}
0: 
0: 	/*
0: 		Keep track of unfilled pages, if the extent changed, returns true.
0: 	 */
0: 	protected boolean trackUnfilledPage(long pagenumber, boolean unfilled)
0: 	{
0: 		checkInRange(pagenumber);
0: 
0: 		int bitnum = (int)(pagenumber-extentStart);
0: 
0: 		boolean bitSet = unFilledPages.isSet(bitnum);
0: 		if (unfilled != bitSet)
0: 		{
0: 			if (unfilled)
0: 			{
0: 				unFilledPages.set(bitnum);
0: 				extentStatus |= HAS_UNFILLED_PAGES;
0: 			}
0: 			else
0: 				unFilledPages.clear(bitnum);
0: 			return true;
0: 		}
0: 
0: 		return false;
0: 	}
0: 
0: 	/**
0: 		Get a page number that is unfilled, pagenum is the last page that was
0: 		rejected.
0: 	 */
0: 	protected long getUnfilledPageNumber(long pagenum)
0: 	{
0: 		if ((extentStatus & HAS_UNFILLED_PAGES) == 0)
0: 			return ContainerHandle.INVALID_PAGE_NUMBER;
0: 
0: 		int i = unFilledPages.anySetBit();
0: 
0: 		if (i != -1)
0: 		{
0: 			if (i+extentStart != pagenum)
0: 				return i+extentStart;
0: 			else
0: 			{
0: 				// unfortunately, we found the same page number that
0: 				// was rejected.  It would be unwise to unset bit
0: 				// pagenum because just because it was rejected does not mean
0: 				// the page is full, the row we are trying to insert may just
0: 				// be too big.  If we unset it, we will never find that page
0: 				// again even though it may be a perfectly good page for any
0: 				// other row.  Just get the next set bit.
0: 				i = unFilledPages.anySetBit(i);
0: 				if (i != -1)
0: 					return i+extentStart;
0: 			}
0: 		}
0: 
0: 		return ContainerHandle.INVALID_PAGE_NUMBER;
0: 
0: 	}
0: 
0: 	/**
0: 		Get the number of used page in this extent
0: 	 */
0: 	protected int getAllocatedPageCount()
0: 	{
0: 		// allocated page is one which is not free or deallocated.
0: 		int allocatedPageCount = extentLength;
0: 
0: 		if (!mayHaveFreePage())
0: 			return allocatedPageCount;
0: 
0: 
0: 		byte[] free = freePages.getByteArray();
0: 		int numBytes = free.length;
0: 
0: 		for (int i = 0; i < numBytes; i++)
0: 		{
0: 			if (free[i] != 0)
0: 			{
0: 				for (int j = 0; j < 8; j++)
0: 				{
0: 					if (((1 << j) & free[i]) != 0)
0: 						allocatedPageCount--;
0: 				}
0: 			}
0: 		}
0: 
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(allocatedPageCount >= 0,
0: 								 "number of allocated page < 0");
0: 
0: 		return allocatedPageCount;
0: 	}
0: 
0: 
0: 	/**
0: 		Get the number of unfilled pages in this extent
0: 	 */
0: 	protected int getUnfilledPageCount()
0: 	{
0:         int unfilledPageCount = 0;
0:         int freePagesSize = freePages.size();
0: 
0:         for (int i = 0; i < unFilledPages.size(); i++)
0:         {
0:             if (unFilledPages.isSet(i) &&
0:                 (i >= freePagesSize || !freePages.isSet(i)))
0:                 unfilledPageCount++;
0:         }
0: 
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(unfilledPageCount >= 0,
0: 								 "number of unfilled pages < 0");
0: 
0:         return unfilledPageCount;
0:  	}
0: 
0: 
0: 	/**
0: 		Get the total number of pages in this extent
0: 	 */
0: 	protected int getTotalPageCount()
0: 	{
0:         return extentLength;
0:     }
0: 
0: 	protected String toDebugString()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			String str =
0: 				"------------------------------------------------------------------------------\n" +
0: 				"Extent map of from page " + extentStart + " to page " + extentEnd + "\n";
0: 
0: 			for (long i = extentStart; i < extentStart+extentLength; i++)
0: 			{
0: 				str += "\tpage " + i + ": ";
0: 				switch(getPageStatus(i))
0: 				{
0: 				case FREE_PAGE: str += "free page\n"; break;
0: 				case ALLOCATED_PAGE: str += "valid, in use page\n"; break;
0: 				}
0: 
0: 		        // int bitnum = (int)(i-extentStart);
0:         		// if (unFilledPages.isSet(bitnum))
0:                 //    str += "          page is estimated to be unfilled\n";
0: 			}
0: 
0: 			if (getLastPagenum() < extentEnd)
0: 				str += "\tFrom " + getLastPagenum() + " to " + extentEnd +
0: 					" are un-allocated pages\n";
0: 
0: 			str += "------------------------------------------------------------------------------\n";
0: 
0: 			return str;
0: 		}
0: 		else
0: 			return null;
0: 	}
0: 
0: }
============================================================================