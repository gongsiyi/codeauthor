1:eac0369: /*
1:6853511: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.compile.IndexToBaseRowNode
1:345de35: 
1:2d37fd6:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2d37fd6:    contributor license agreements.  See the NOTICE file distributed with
1:2d37fd6:    this work for additional information regarding copyright ownership.
1:2d37fd6:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2d37fd6:    (the "License"); you may not use this file except in compliance with
1:2d37fd6:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:345de35: 
2:eac0369:  */
16:eac0369: 
1:eac0369: package	org.apache.derby.impl.sql.compile;
1:eac0369: 
1:47d4a4c: import java.util.List;
1:3bb140c: import java.util.Properties;
1:3bb140c: import org.apache.derby.catalog.types.ReferencedColumnsDescriptorImpl;
1:3bb140c: import org.apache.derby.iapi.error.StandardException;
1:3bb140c: import org.apache.derby.iapi.reference.ClassName;
1:3bb140c: import org.apache.derby.iapi.services.classfile.VMOpcode;
1:3bb140c: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1:3bb140c: import org.apache.derby.iapi.services.context.ContextManager;
1:3bb140c: import org.apache.derby.iapi.services.io.FormatableBitSet;
1:eac0369: import org.apache.derby.iapi.sql.compile.AccessPath;
1:eac0369: import org.apache.derby.iapi.sql.compile.CostEstimate;
1:eac0369: import org.apache.derby.iapi.sql.compile.Optimizable;
1:50567fe: import org.apache.derby.iapi.sql.compile.RequiredRowOrdering;
1:f36770c: import org.apache.derby.iapi.sql.compile.Visitor;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
1:eac0369: import org.apache.derby.iapi.store.access.StaticCompiledOpenConglomInfo;
1:eac0369: 
2:eac0369: /**
1:eac0369:  * This node type translates an index row to a base row.  It takes a
1:eac0369:  * FromBaseTable as its source ResultSetNode, and generates an
1:eac0369:  * IndexRowToBaseRowResultSet that takes a TableScanResultSet on an
1:eac0369:  * index conglomerate as its source.
1:eac0369:  */
1:3bb140c: class IndexToBaseRowNode extends FromTable
2:eac0369: {
1:eac0369: 	protected FromBaseTable	source;
1:eac0369: 	protected ConglomerateDescriptor	baseCD;
1:eac0369: 	protected boolean	cursorTargetTable;
1:eac0369: 	protected PredicateList restrictionList;
1:eac0369: 	protected boolean	forUpdate;
1:eac0369: 	private FormatableBitSet	heapReferencedCols;
1:eac0369: 	private FormatableBitSet	indexReferencedCols;
1:6853511: 	private FormatableBitSet	allReferencedCols;
1:6853511: 	private FormatableBitSet	heapOnlyReferencedCols;
1:eac0369: 
1:3bb140c:     IndexToBaseRowNode(
1:3bb140c:             FromBaseTable    source,
1:3bb140c:             ConglomerateDescriptor  baseCD,
1:3bb140c:             ResultColumnList resultColumns,
1:3bb140c:             boolean          cursorTargetTable,
1:3bb140c:             FormatableBitSet heapReferencedCols,
1:3bb140c:             FormatableBitSet indexReferencedCols,
1:3bb140c:             PredicateList    restrictionList,
1:3bb140c:             boolean          forUpdate,
1:3bb140c:             Properties       tableProperties,
1:3bb140c:             ContextManager   cm)
1:eac0369: 	{
1:3bb140c:         super(null, tableProperties, cm);
1:3bb140c:         this.source = source;
1:3bb140c:         this.baseCD = baseCD;
1:11f7ee3:         setResultColumns( resultColumns );
1:3bb140c:         this.cursorTargetTable = cursorTargetTable;
1:3bb140c:         this.restrictionList = restrictionList;
1:3bb140c:         this.forUpdate = forUpdate;
1:3bb140c:         this.heapReferencedCols = heapReferencedCols;
1:3bb140c:         this.indexReferencedCols = indexReferencedCols;
1:eac0369: 
1:6853511: 		if (this.indexReferencedCols == null) {
1:6853511: 			this.allReferencedCols = this.heapReferencedCols;
1:6853511: 			heapOnlyReferencedCols = this.heapReferencedCols;
1:6853511: 		}
1:6853511: 		else {
1:6853511: 			this.allReferencedCols =
1:6853511: 				new FormatableBitSet(this.heapReferencedCols);
1:6853511: 			this.allReferencedCols.or(this.indexReferencedCols);
1:6853511: 			heapOnlyReferencedCols =
1:6853511: 				new FormatableBitSet(allReferencedCols);
1:6853511: 			heapOnlyReferencedCols.xor(this.indexReferencedCols);
1:6853511: 		}
2:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see Optimizable#forUpdate */
1:3bb140c:     @Override
1:eac0369: 	public boolean forUpdate()
1:eac0369: 	{
1:eac0369: 		return source.forUpdate();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see Optimizable#getTrulyTheBestAccessPath */
1:3bb140c:     @Override
1:eac0369: 	public AccessPath getTrulyTheBestAccessPath()
1:eac0369: 	{
1:eac0369: 		// Get AccessPath comes from base table.
1:eac0369: 		return ((Optimizable) source).getTrulyTheBestAccessPath();
1:eac0369: 	}
1:eac0369: 
1:3bb140c:     @Override
1:3bb140c:     CostEstimate getCostEstimate()
1:eac0369: 	{
1:eac0369: 		return source.getTrulyTheBestAccessPath().getCostEstimate();
1:eac0369: 	}
1:eac0369: 
1:3bb140c:     @Override
1:3bb140c:     CostEstimate getFinalCostEstimate()
1:eac0369: 	{
1:eac0369: 		return source.getFinalCostEstimate();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return whether or not the underlying ResultSet tree
1:eac0369: 	 * is ordered on the specified columns.
1:eac0369: 	 * RESOLVE - This method currently only considers the outermost table 
1:eac0369: 	 * of the query block.
3:eac0369: 	 *
1:eac0369: 	 * @param	crs					The specified ColumnReference[]
1:eac0369: 	 * @param	permuteOrdering		Whether or not the order of the CRs in the array can be permuted
1:b153b24:      * @param   fbtHolder           List that is to be filled with the FromBaseTable
1:eac0369: 	 *
1:eac0369: 	 * @return	Whether the underlying ResultSet tree
1:eac0369: 	 * is ordered on the specified column.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:71c8e86:     boolean isOrderedOn(ColumnReference[] crs, boolean permuteOrdering, List<FromBaseTable> fbtHolder)
1:eac0369: 				throws StandardException
1:f36770c: 	{
1:b153b24:         return source.isOrderedOn(crs, permuteOrdering, fbtHolder);
1:eac0369: 	}
1:f36770c: 
1:eac0369: 	/**
1:eac0369: 	 * Generation of an IndexToBaseRowNode creates an
1:eac0369: 	 * IndexRowToBaseRowResultSet, which uses the RowLocation in the last
1:eac0369: 	 * column of an index row to get the row from the base conglomerate (heap).
1:eac0369: 	 *
1:eac0369: 	 * @param acb	The ActivationClassBuilder for the class being built
1:eac0369: 	 * @param mb the method  for the method to be built
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:8fe3166:     void generate(ActivationClassBuilder acb, MethodBuilder mb)
1:eac0369: 							throws StandardException
1:eac0369: 	{
1:eac0369: 		ValueNode		restriction = null;
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** Get the next ResultSet #, so that we can number this ResultSetNode,
1:eac0369: 		** its ResultColumnList and ResultSet.
1:eac0369: 		*/
1:eac0369: 		assignResultSetNumber();
1:eac0369: 
1:eac0369: 		// Get the CostEstimate info for the underlying scan
1:11f7ee3: 		setCostEstimate( getFinalCostEstimate() );
1:eac0369: 
1:eac0369: 		/* Put the predicates back into the tree */
1:eac0369: 		if (restrictionList != null)
1:eac0369: 		{
1:eac0369: 			restriction = restrictionList.restorePredicates();
1:eac0369: 			/* Allow the restrictionList to get garbage collected now
1:eac0369: 			 * that we're done with it.
1:eac0369: 			 */
1:eac0369: 			restrictionList = null;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// for the restriction, we generate an exprFun
1:eac0369: 		// that evaluates the expression of the clause
1:eac0369: 		// against the current row of the child's result.
1:eac0369: 		// if the restriction is empty, simply pass null
1:eac0369: 		// to optimize for run time performance.
1:eac0369: 
1:eac0369:    		// generate the function and initializer:
1:eac0369:    		// Note: Boolean lets us return nulls (boolean would not)
1:eac0369:    		// private Boolean exprN()
1:eac0369:    		// {
1:eac0369:    		//   return <<restriction.generate(ps)>>;
1:eac0369:    		// }
1:eac0369:    		// static Method exprN = method pointer to exprN;
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 		int heapColRefItem = -1;
1:eac0369: 		if (heapReferencedCols != null)
1:eac0369: 		{
1:eac0369: 			heapColRefItem = acb.addItem(heapReferencedCols);
1:eac0369: 		}
1:6853511: 		int allColRefItem = -1;
1:6853511: 		if (allReferencedCols != null)
1:eac0369: 		{
1:6853511: 			allColRefItem = acb.addItem(allReferencedCols);
1:6853511: 		}
1:6853511: 		int heapOnlyColRefItem = -1;
1:6853511: 		if (heapOnlyReferencedCols != null)
1:6853511: 		{
1:6853511: 			heapOnlyColRefItem = acb.addItem(heapOnlyReferencedCols);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* Create the ReferencedColumnsDescriptorImpl which tells which columns
1:eac0369: 		 * come from the index.
1:eac0369: 		 */
1:eac0369: 		int indexColMapItem = acb.addItem(new ReferencedColumnsDescriptorImpl(getIndexColMapping()));
1:eac0369: 		long heapConglomNumber = baseCD.getConglomerateNumber();
1:eac0369: 		StaticCompiledOpenConglomInfo scoci = getLanguageConnectionContext().
1:eac0369: 												getTransactionCompile().
1:eac0369: 													getStaticCompiledConglomInfo(heapConglomNumber);
1:eac0369: 
1:eac0369: 		acb.pushGetResultSetFactoryExpression(mb);
1:eac0369: 
1:eac0369: 		mb.push(heapConglomNumber);
1:eac0369: 		mb.push(acb.addItem(scoci));
1:eac0369: 		source.generate(acb, mb);
1:eac0369: 		
1:eac0369: 		mb.upCast(ClassName.NoPutResultSet);
1:eac0369: 
1:bda7291:         // Skip over the index columns that are propagated from the source
1:bda7291:         // result set, if there are such columns. We won't pass the SQL NULL
1:bda7291:         // wrappers down to store for those columns anyways, so no need to
1:bda7291:         // generate them in the row template.
1:bda7291:         // NOTE: We have to check for the case where indexReferencedCols is
1:bda7291:         // not null, but no bits are set. This can happen when we need to get
1:bda7291:         // all of the columns from the heap due to a check constraint.
1:bda7291:         boolean skipPropagatedCols =
1:bda7291:                 indexReferencedCols != null &&
1:bda7291:                 indexReferencedCols.getNumBitsSet() != 0;
1:11f7ee3:         mb.push(acb.addItem(getResultColumns()
1:bda7291:                 .buildRowTemplate(heapReferencedCols, skipPropagatedCols)));
1:bda7291: 
1:11f7ee3: 		mb.push(getResultSetNumber());
1:eac0369: 		mb.push(source.getBaseTableName());
1:eac0369: 		mb.push(heapColRefItem);
1:6853511: 
1:6853511: 		mb.push(allColRefItem);
1:6853511: 		mb.push(heapOnlyColRefItem);
1:6853511: 
1:eac0369: 		mb.push(indexColMapItem);
1:eac0369: 
1:eac0369: 		// if there is no restriction, we just want to pass null.
1:eac0369: 		if (restriction == null)
1:eac0369: 		{
1:eac0369: 		   	mb.pushNull(ClassName.GeneratedMethod);
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			// this sets up the method and the static field.
1:eac0369: 			// generates:
1:eac0369: 			// 	Object userExprFun { }
1:eac0369: 			MethodBuilder userExprFun = acb.newUserExprFun();
1:eac0369: 
1:eac0369: 			// restriction knows it is returning its value;
1:eac0369: 	
1:eac0369: 			/* generates:
1:eac0369: 			 *    return <restriction.generate(acb)>;
1:eac0369: 			 * and adds it to userExprFun
1:eac0369: 			 * NOTE: The explicit cast to DataValueDescriptor is required
1:eac0369: 			 * since the restriction may simply be a boolean column or subquery
1:eac0369: 			 * which returns a boolean.  For example:
1:eac0369: 			 *		where booleanColumn
1:eac0369: 			 */
1:eac0369: 			restriction.generate(acb, userExprFun);
1:eac0369: 			userExprFun.methodReturn();
1:eac0369: 
1:eac0369: 			// we are done modifying userExprFun, complete it.
1:eac0369: 			userExprFun.complete();
1:eac0369: 
1:eac0369: 	   		// restriction is used in the final result set as an access of the new static
1:eac0369:    			// field holding a reference to this new method.
1:eac0369: 			// generates:
1:eac0369: 			//	ActivationClass.userExprFun
1:eac0369: 			// which is the static field that "points" to the userExprFun
1:eac0369: 			// that evaluates the where clause.
1:eac0369:    			acb.pushMethodReference(mb, userExprFun);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		mb.push(forUpdate);
1:11f7ee3: 		mb.push(getCostEstimate().rowCount());
1:11f7ee3: 		mb.push(getCostEstimate().getEstimatedCost());
1:1705596:         mb.push( source.getTableDescriptor().getNumberOfColumns() );
1:eac0369: 
1:eac0369: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, "getIndexRowToBaseRowResultSet",
1:1705596: 						ClassName.NoPutResultSet, 15);
1:eac0369: 
1:eac0369: 		/* The IndexRowToBaseRowResultSet generator is what we return */
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** Remember if this result set is the cursor target table, so we
1:eac0369: 		** can know which table to use when doing positioned update and delete.
1:eac0369: 		*/
1:eac0369: 		if (cursorTargetTable)
1:eac0369: 		{
1:eac0369: 			acb.rememberCursorTarget(mb);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return whether or not the underlying ResultSet tree will return
1:eac0369: 	 * a single row, at most.
1:eac0369: 	 * This is important for join nodes where we can save the extra next
1:eac0369: 	 * on the right side if we know that it will return at most 1 row.
1:eac0369: 	 *
1:eac0369: 	 * @return Whether or not the underlying ResultSet tree will return a single row.
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     boolean isOneRowResultSet() throws StandardException
1:eac0369: 	{
1:eac0369: 		// Default is false
1:eac0369: 		return source.isOneRowResultSet();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return whether or not the underlying FBT is for NOT EXISTS.
1:eac0369: 	 *
1:eac0369: 	 * @return Whether or not the underlying FBT is for NOT EXISTS.
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     boolean isNotExists()
1:eac0369: 	{
1:eac0369: 		return source.isNotExists();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Decrement (query block) level (0-based) for this FromTable.
1:eac0369: 	 * This is useful when flattening a subquery.
1:eac0369: 	 *
1:eac0369: 	 * @param decrement	The amount to decrement by.
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	void decrementLevel(int decrement)
1:eac0369: 	{
1:eac0369: 		source.decrementLevel(decrement);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the lock mode for the target of an update statement
1:eac0369: 	 * (a delete or update).  The update mode will always be row for
1:eac0369: 	 * CurrentOfNodes.  It will be table if there is no where clause.
1:eac0369: 	 *
1:eac0369: 	 * @return	The lock mode
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     int updateTargetLockMode()
1:eac0369: 	{
1:eac0369: 		return source.updateTargetLockMode();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:cf530d5: 	 * @see ResultSetNode#adjustForSortElimination
1:eac0369: 	 */
1:3bb140c:     @Override
1:cf530d5: 	void adjustForSortElimination()
1:eac0369: 	{
1:eac0369: 		/* NOTE: We use a different method to tell a FBT that
1:eac0369: 		 * it cannot do a bulk fetch as the ordering issues are
1:eac0369: 		 * specific to a FBT being under an IRTBR as opposed to a
1:eac0369: 		 * FBT being under a PRN, etc.
1:eac0369: 		 */
1:eac0369: 		source.disableBulkFetch();
1:eac0369: 	}
1:eac0369: 
1:50567fe: 	/**
1:50567fe: 	 * @see ResultSetNode#adjustForSortElimination
1:50567fe: 	 */
1:3bb140c:     @Override
1:50567fe: 	void adjustForSortElimination(RequiredRowOrdering rowOrdering)
1:50567fe: 		throws StandardException
1:50567fe: 	{
1:50567fe: 		/* rowOrdering is not important to this specific node, so
1:50567fe: 		 * just call the no-arg version of the method.
1:50567fe: 		 */
1:50567fe: 		adjustForSortElimination();
1:50567fe: 
1:50567fe: 		/* Now pass the rowOrdering down to source, which may
1:50567fe: 		 * need to do additional work. DERBY-3279.
1:50567fe: 		 */
1:50567fe: 		source.adjustForSortElimination(rowOrdering);
1:50567fe: 	}
1:50567fe: 
1:eac0369: 	/** 
1:eac0369: 	 * Fill in the column mapping for those columns coming from the index.
1:eac0369: 	 *
1:eac0369: 	 * @return The int[] with the mapping.
1:eac0369: 	 */
1:eac0369: 	private int[] getIndexColMapping()
1:eac0369: 	{
1:11f7ee3: 		int		rclSize = getResultColumns().size();
1:eac0369: 		int[]	indexColMapping = new int[rclSize];
1:eac0369: 
1:eac0369: 		for (int index = 0; index < rclSize; index++)
1:eac0369: 		{
1:11f7ee3:             ResultColumn rc = getResultColumns().elementAt(index);
1:e1f49ca: 
1:eac0369: 			if (indexReferencedCols != null && rc.getExpression() instanceof VirtualColumnNode)
1:eac0369: 			{
1:eac0369: 				// Column is coming from index
1:eac0369: 				VirtualColumnNode vcn = (VirtualColumnNode) rc.getExpression();
1:eac0369: 				indexColMapping[index] =
1:eac0369: 					vcn.getSourceColumn().getVirtualColumnId() - 1;
1:eac0369: 			}
1:eac0369: 			else
1:eac0369: 			{
1:eac0369: 				// Column is not coming from index
1:eac0369: 				indexColMapping[index] = -1;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return indexColMapping;
1:f36770c: 	}
1:f36770c: 
1:f36770c: 	/**
1:dd2f5a8: 	 * Accept the visitor for all visitable children of this node.
1:f36770c: 	 * 
1:f36770c: 	 * @param v the visitor
1:f36770c: 	 *
1:f36770c: 	 * @exception StandardException on error
1:f36770c: 	 */
1:3bb140c:     @Override
1:dd2f5a8: 	void acceptChildren(Visitor v)
1:f36770c: 		throws StandardException
1:f36770c: 	{
1:dd2f5a8: 		super.acceptChildren(v);
1:f36770c: 
1:aebfb28: 		if (source != null)
1:f36770c: 		{
1:f36770c: 			source = (FromBaseTable)source.accept(v);
1:f36770c: 		}
1:f36770c: 	}
1:f36770c: 
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:1705596
/////////////////////////////////////////////////////////////////////////
1:         mb.push( source.getTableDescriptor().getNumberOfColumns() );
1: 						ClassName.NoPutResultSet, 15);
commit:11f7ee3
/////////////////////////////////////////////////////////////////////////
1:         setResultColumns( resultColumns );
/////////////////////////////////////////////////////////////////////////
1: 		setCostEstimate( getFinalCostEstimate() );
/////////////////////////////////////////////////////////////////////////
1:         mb.push(acb.addItem(getResultColumns()
1: 		mb.push(getResultSetNumber());
/////////////////////////////////////////////////////////////////////////
1: 		mb.push(getCostEstimate().rowCount());
1: 		mb.push(getCostEstimate().getEstimatedCost());
/////////////////////////////////////////////////////////////////////////
1: 		int		rclSize = getResultColumns().size();
1:             ResultColumn rc = getResultColumns().elementAt(index);
commit:71c8e86
/////////////////////////////////////////////////////////////////////////
1:     boolean isOrderedOn(ColumnReference[] crs, boolean permuteOrdering, List<FromBaseTable> fbtHolder)
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:2706d1f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:e1f49ca
/////////////////////////////////////////////////////////////////////////
0:             ResultColumn rc = resultColumns.elementAt(index);
1: 
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
1: import java.util.Properties;
1: import org.apache.derby.catalog.types.ReferencedColumnsDescriptorImpl;
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.reference.ClassName;
1: import org.apache.derby.iapi.services.classfile.VMOpcode;
1: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1: import org.apache.derby.iapi.services.context.ContextManager;
1: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
1: class IndexToBaseRowNode extends FromTable
/////////////////////////////////////////////////////////////////////////
1:     IndexToBaseRowNode(
1:             FromBaseTable    source,
1:             ConglomerateDescriptor  baseCD,
1:             ResultColumnList resultColumns,
1:             boolean          cursorTargetTable,
1:             FormatableBitSet heapReferencedCols,
1:             FormatableBitSet indexReferencedCols,
1:             PredicateList    restrictionList,
1:             boolean          forUpdate,
1:             Properties       tableProperties,
1:             ContextManager   cm)
1:         super(null, tableProperties, cm);
0:         setNodeType(C_NodeTypes.INDEX_TO_BASE_ROW_NODE);
1:         this.source = source;
1:         this.baseCD = baseCD;
0:         this.resultColumns = resultColumns;
1:         this.cursorTargetTable = cursorTargetTable;
1:         this.restrictionList = restrictionList;
1:         this.forUpdate = forUpdate;
1:         this.heapReferencedCols = heapReferencedCols;
1:         this.indexReferencedCols = indexReferencedCols;
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
1:     @Override
1:     CostEstimate getCostEstimate()
1:     @Override
1:     CostEstimate getFinalCostEstimate()
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     boolean isOneRowResultSet() throws StandardException
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     boolean isNotExists()
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     int updateTargetLockMode()
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:8fe3166
/////////////////////////////////////////////////////////////////////////
1:     void generate(ActivationClassBuilder acb, MethodBuilder mb)
commit:b153b24
/////////////////////////////////////////////////////////////////////////
1:      * @param   fbtHolder           List that is to be filled with the FromBaseTable
0:     boolean isOrderedOn(ColumnReference[] crs, boolean permuteOrdering, List fbtHolder)
1:         return source.isOrderedOn(crs, permuteOrdering, fbtHolder);
commit:47d4a4c
/////////////////////////////////////////////////////////////////////////
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 	boolean isOrderedOn(ColumnReference[] crs, boolean permuteOrdering, List fbtVector)
commit:bda7291
/////////////////////////////////////////////////////////////////////////
1:         // Skip over the index columns that are propagated from the source
1:         // result set, if there are such columns. We won't pass the SQL NULL
1:         // wrappers down to store for those columns anyways, so no need to
1:         // generate them in the row template.
1:         // NOTE: We have to check for the case where indexReferencedCols is
1:         // not null, but no bits are set. This can happen when we need to get
1:         // all of the columns from the heap due to a check constraint.
1:         boolean skipPropagatedCols =
1:                 indexReferencedCols != null &&
1:                 indexReferencedCols.getNumBitsSet() != 0;
0:         mb.push(acb.addItem(resultColumns
1:                 .buildRowTemplate(heapReferencedCols, skipPropagatedCols)));
1: 
commit:aebfb28
/////////////////////////////////////////////////////////////////////////
1: 		if (source != null)
commit:dd2f5a8
/////////////////////////////////////////////////////////////////////////
1: 	 * Accept the visitor for all visitable children of this node.
1: 	void acceptChildren(Visitor v)
1: 		super.acceptChildren(v);
commit:6853511
/////////////////////////////////////////////////////////////////////////
1: 	private FormatableBitSet	allReferencedCols;
1: 	private FormatableBitSet	heapOnlyReferencedCols;
/////////////////////////////////////////////////////////////////////////
1: 
1: 		if (this.indexReferencedCols == null) {
1: 			this.allReferencedCols = this.heapReferencedCols;
1: 			heapOnlyReferencedCols = this.heapReferencedCols;
1: 		}
1: 		else {
1: 			this.allReferencedCols =
1: 				new FormatableBitSet(this.heapReferencedCols);
1: 			this.allReferencedCols.or(this.indexReferencedCols);
1: 			heapOnlyReferencedCols =
1: 				new FormatableBitSet(allReferencedCols);
1: 			heapOnlyReferencedCols.xor(this.indexReferencedCols);
1: 		}
/////////////////////////////////////////////////////////////////////////
1: 		int allColRefItem = -1;
1: 		if (allReferencedCols != null)
1: 			allColRefItem = acb.addItem(allReferencedCols);
1: 		}
1: 		int heapOnlyColRefItem = -1;
1: 		if (heapOnlyReferencedCols != null)
1: 		{
1: 			heapOnlyColRefItem = acb.addItem(heapOnlyReferencedCols);
/////////////////////////////////////////////////////////////////////////
1: 
1: 		mb.push(allColRefItem);
1: 		mb.push(heapOnlyColRefItem);
1: 
/////////////////////////////////////////////////////////////////////////
0: 						ClassName.NoPutResultSet, 14);
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:f36770c
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.sql.compile.Visitable;
1: import org.apache.derby.iapi.sql.compile.Visitor;
/////////////////////////////////////////////////////////////////////////
1: 	/**
0: 	 * Accept a visitor, and call v.visit()
0: 	 * on child nodes as necessary.  
1: 	 * 
1: 	 * @param v the visitor
1: 	 *
1: 	 * @exception StandardException on error
1: 	 */
0: 	public Visitable accept(Visitor v) 
1: 		throws StandardException
1: 	{
0: 		if (v.skipChildren(this))
1: 		{
0: 			return v.visit(this);
1: 		}
1: 
0: 		Visitable returnNode = super.accept(v);
1: 
0: 		if (source != null && !v.stopTraversal())
1: 		{
1: 			source = (FromBaseTable)source.accept(v);
1: 		}
1: 
0: 		return returnNode;
1: 	}
1: 
author:Army
-------------------------------------------------------------------------------
commit:50567fe
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.compile.RequiredRowOrdering;
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * @see ResultSetNode#adjustForSortElimination
1: 	 */
1: 	void adjustForSortElimination(RequiredRowOrdering rowOrdering)
1: 		throws StandardException
1: 	{
1: 		/* rowOrdering is not important to this specific node, so
1: 		 * just call the no-arg version of the method.
1: 		 */
1: 		adjustForSortElimination();
1: 
1: 		/* Now pass the rowOrdering down to source, which may
1: 		 * need to do additional work. DERBY-3279.
1: 		 */
1: 		source.adjustForSortElimination(rowOrdering);
1: 	}
1: 
commit:cf530d5
/////////////////////////////////////////////////////////////////////////
1: 	 * @see ResultSetNode#adjustForSortElimination
1: 	void adjustForSortElimination()
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:9e6e461
/////////////////////////////////////////////////////////////////////////
0: 						ClassName.NoPutResultSet, 13);
commit:93ff8cc
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 						ClassName.NoPutResultSet, 14);
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.compile.IndexToBaseRowNode
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:61070a6
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package	org.apache.derby.impl.sql.compile;
1: 
0: import org.apache.derby.iapi.services.context.ContextManager;
1: 
1: import org.apache.derby.iapi.sql.compile.AccessPath;
1: import org.apache.derby.iapi.sql.compile.CostEstimate;
1: import org.apache.derby.iapi.sql.compile.Optimizable;
1: 
1: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
1: 
0: import org.apache.derby.impl.sql.compile.ActivationClassBuilder;
1: 
0: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1: 
0: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
1: 
0: import org.apache.derby.iapi.sql.Activation;
0: import org.apache.derby.iapi.sql.ResultSet;
1: 
0: import org.apache.derby.iapi.services.loader.GeneratedMethod;
1: 
1: import org.apache.derby.iapi.store.access.StaticCompiledOpenConglomInfo;
1: 
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
1: 
0: import org.apache.derby.catalog.types.ReferencedColumnsDescriptorImpl;
0: import org.apache.derby.iapi.reference.ClassName;
0: import org.apache.derby.iapi.services.classfile.VMOpcode;
1: 
0: import java.util.Properties;
0: import java.util.Vector;
1: 
1: /**
1:  * This node type translates an index row to a base row.  It takes a
1:  * FromBaseTable as its source ResultSetNode, and generates an
1:  * IndexRowToBaseRowResultSet that takes a TableScanResultSet on an
1:  * index conglomerate as its source.
1:  */
0: public class IndexToBaseRowNode extends FromTable
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 	protected FromBaseTable	source;
1: 	protected ConglomerateDescriptor	baseCD;
1: 	protected boolean	cursorTargetTable;
1: 	protected PredicateList restrictionList;
1: 	protected boolean	forUpdate;
1: 	private FormatableBitSet	heapReferencedCols;
1: 	private FormatableBitSet	indexReferencedCols;
1: 
0: 	public void init(
0: 			Object	source,
0: 			Object	baseCD,
0: 			Object	resultColumns,
0: 			Object	cursorTargetTable,
0: 			Object heapReferencedCols,
0: 			Object indexReferencedCols,
0: 			Object restrictionList,
0: 			Object forUpdate,
0: 			Object tableProperties)
1: 	{
0: 		super.init(null, tableProperties);
0: 		this.source = (FromBaseTable) source;
0: 		this.baseCD = (ConglomerateDescriptor) baseCD;
0: 		this.resultColumns = (ResultColumnList) resultColumns;
0: 		this.cursorTargetTable = ((Boolean) cursorTargetTable).booleanValue();
0: 		this.restrictionList = (PredicateList) restrictionList;
0: 		this.forUpdate = ((Boolean) forUpdate).booleanValue();
0: 		this.heapReferencedCols = (FormatableBitSet) heapReferencedCols;
0: 		this.indexReferencedCols = (FormatableBitSet) indexReferencedCols;
1: 	}
1: 
1: 	/** @see Optimizable#forUpdate */
1: 	public boolean forUpdate()
1: 	{
1: 		return source.forUpdate();
1: 	}
1: 
1: 	/** @see Optimizable#getTrulyTheBestAccessPath */
1: 	public AccessPath getTrulyTheBestAccessPath()
1: 	{
1: 		// Get AccessPath comes from base table.
1: 		return ((Optimizable) source).getTrulyTheBestAccessPath();
1: 	}
1: 
0: 	public CostEstimate getCostEstimate()
1: 	{
1: 		return source.getTrulyTheBestAccessPath().getCostEstimate();
1: 	}
1: 
0: 	public CostEstimate getFinalCostEstimate()
1: 	{
1: 		return source.getFinalCostEstimate();
1: 	}
1: 
1: 	/**
1: 	 * Return whether or not the underlying ResultSet tree
1: 	 * is ordered on the specified columns.
1: 	 * RESOLVE - This method currently only considers the outermost table 
1: 	 * of the query block.
1: 	 *
1: 	 * @param	crs					The specified ColumnReference[]
1: 	 * @param	permuteOrdering		Whether or not the order of the CRs in the array can be permuted
0: 	 * @param	fbtVector			Vector that is to be filled with the FromBaseTable	
1: 	 *
1: 	 * @return	Whether the underlying ResultSet tree
1: 	 * is ordered on the specified column.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	boolean isOrderedOn(ColumnReference[] crs, boolean permuteOrdering, Vector fbtVector)
1: 				throws StandardException
1: 	{
0: 		return source.isOrderedOn(crs, permuteOrdering, fbtVector);
1: 	}
1: 
1: 	/**
1: 	 * Generation of an IndexToBaseRowNode creates an
1: 	 * IndexRowToBaseRowResultSet, which uses the RowLocation in the last
1: 	 * column of an index row to get the row from the base conglomerate (heap).
1: 	 *
1: 	 * @param acb	The ActivationClassBuilder for the class being built
1: 	 * @param mb the method  for the method to be built
1: 	 *
0: 	 * @return	A compiled Expression that returns a ResultSet that
0: 	 *			gets a base from from an index row.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public void generate(ActivationClassBuilder acb,
0: 								MethodBuilder mb)
1: 							throws StandardException
1: 	{
1: 		ValueNode		restriction = null;
1: 
1: 		/*
1: 		** Get the next ResultSet #, so that we can number this ResultSetNode,
1: 		** its ResultColumnList and ResultSet.
1: 		*/
1: 		assignResultSetNumber();
1: 
1: 		// Get the CostEstimate info for the underlying scan
0: 		costEstimate = getFinalCostEstimate();
1: 
1: 		/* Put the predicates back into the tree */
1: 		if (restrictionList != null)
1: 		{
1: 			restriction = restrictionList.restorePredicates();
1: 			/* Allow the restrictionList to get garbage collected now
1: 			 * that we're done with it.
1: 			 */
1: 			restrictionList = null;
1: 		}
1: 
1: 		// for the restriction, we generate an exprFun
1: 		// that evaluates the expression of the clause
1: 		// against the current row of the child's result.
1: 		// if the restriction is empty, simply pass null
1: 		// to optimize for run time performance.
1: 
1:    		// generate the function and initializer:
1:    		// Note: Boolean lets us return nulls (boolean would not)
1:    		// private Boolean exprN()
1:    		// {
1:    		//   return <<restriction.generate(ps)>>;
1:    		// }
1:    		// static Method exprN = method pointer to exprN;
1: 
1: 
1: 
1: 		int heapColRefItem = -1;
0: 		int indexColRefItem = -1;
1: 		if (heapReferencedCols != null)
1: 		{
1: 			heapColRefItem = acb.addItem(heapReferencedCols);
1: 		}
0: 		if (indexReferencedCols != null)
1: 		{
0: 			indexColRefItem = acb.addItem(indexReferencedCols);
1: 		}
1: 
1: 		/* Create the ReferencedColumnsDescriptorImpl which tells which columns
1: 		 * come from the index.
1: 		 */
1: 		int indexColMapItem = acb.addItem(new ReferencedColumnsDescriptorImpl(getIndexColMapping()));
1: 		long heapConglomNumber = baseCD.getConglomerateNumber();
1: 		StaticCompiledOpenConglomInfo scoci = getLanguageConnectionContext().
1: 												getTransactionCompile().
1: 													getStaticCompiledConglomInfo(heapConglomNumber);
1: 
1: 		acb.pushGetResultSetFactoryExpression(mb);
1: 
1: 		mb.push(heapConglomNumber);
1: 		mb.push(acb.addItem(scoci));
0: 		acb.pushThisAsActivation(mb);
1: 		source.generate(acb, mb);
1: 		
1: 		mb.upCast(ClassName.NoPutResultSet);
1: 
0: 		resultColumns.generateHolder(acb, mb,  heapReferencedCols, indexReferencedCols);
0: 		mb.push(resultSetNumber);
1: 		mb.push(source.getBaseTableName());
1: 		mb.push(heapColRefItem);
0: 		mb.push(indexColRefItem);
1: 		mb.push(indexColMapItem);
1: 
1: 		// if there is no restriction, we just want to pass null.
1: 		if (restriction == null)
1: 		{
1: 		   	mb.pushNull(ClassName.GeneratedMethod);
1: 		}
1: 		else
1: 		{
1: 			// this sets up the method and the static field.
1: 			// generates:
1: 			// 	Object userExprFun { }
1: 			MethodBuilder userExprFun = acb.newUserExprFun();
1: 
1: 			// restriction knows it is returning its value;
1: 	
1: 			/* generates:
1: 			 *    return <restriction.generate(acb)>;
1: 			 * and adds it to userExprFun
1: 			 * NOTE: The explicit cast to DataValueDescriptor is required
1: 			 * since the restriction may simply be a boolean column or subquery
1: 			 * which returns a boolean.  For example:
1: 			 *		where booleanColumn
1: 			 */
1: 			restriction.generate(acb, userExprFun);
1: 			userExprFun.methodReturn();
1: 
1: 			// we are done modifying userExprFun, complete it.
1: 			userExprFun.complete();
1: 
1: 	   		// restriction is used in the final result set as an access of the new static
1:    			// field holding a reference to this new method.
1: 			// generates:
1: 			//	ActivationClass.userExprFun
1: 			// which is the static field that "points" to the userExprFun
1: 			// that evaluates the where clause.
1:    			acb.pushMethodReference(mb, userExprFun);
1: 		}
1: 
1: 		mb.push(forUpdate);
0: 		mb.push(costEstimate.rowCount());
0: 		mb.push(costEstimate.getEstimatedCost());
0: 		closeMethodArgument(acb, mb);
1: 
1: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, "getIndexRowToBaseRowResultSet",
0: 						ClassName.NoPutResultSet, 15);
1: 
1: 		/* The IndexRowToBaseRowResultSet generator is what we return */
1: 
1: 		/*
1: 		** Remember if this result set is the cursor target table, so we
1: 		** can know which table to use when doing positioned update and delete.
1: 		*/
1: 		if (cursorTargetTable)
1: 		{
1: 			acb.rememberCursorTarget(mb);
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Return whether or not the underlying ResultSet tree will return
1: 	 * a single row, at most.
1: 	 * This is important for join nodes where we can save the extra next
1: 	 * on the right side if we know that it will return at most 1 row.
1: 	 *
1: 	 * @return Whether or not the underlying ResultSet tree will return a single row.
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public boolean isOneRowResultSet()	throws StandardException
1: 	{
1: 		// Default is false
1: 		return source.isOneRowResultSet();
1: 	}
1: 
1: 	/**
1: 	 * Return whether or not the underlying FBT is for NOT EXISTS.
1: 	 *
1: 	 * @return Whether or not the underlying FBT is for NOT EXISTS.
1: 	 */
0: 	public boolean isNotExists()
1: 	{
1: 		return source.isNotExists();
1: 	}
1: 
1: 	/**
1: 	 * Decrement (query block) level (0-based) for this FromTable.
1: 	 * This is useful when flattening a subquery.
1: 	 *
1: 	 * @param decrement	The amount to decrement by.
1: 	 */
1: 	void decrementLevel(int decrement)
1: 	{
1: 		source.decrementLevel(decrement);
1: 	}
1: 
1: 	/**
1: 	 * Get the lock mode for the target of an update statement
1: 	 * (a delete or update).  The update mode will always be row for
1: 	 * CurrentOfNodes.  It will be table if there is no where clause.
1: 	 *
1: 	 * @return	The lock mode
1: 	 */
0: 	public int updateTargetLockMode()
1: 	{
1: 		return source.updateTargetLockMode();
1: 	}
1: 
1: 	/**
0: 	 * Notify the underlying result set tree that the result is
0: 	 * ordering dependent.  (For example, no bulk fetch on an index
0: 	 * if under an IndexRowToBaseRow.)
1: 	 *
0: 	 * @return Nothing.
1: 	 */
0: 	void markOrderingDependent()
1: 	{
1: 		/* NOTE: We use a different method to tell a FBT that
1: 		 * it cannot do a bulk fetch as the ordering issues are
1: 		 * specific to a FBT being under an IRTBR as opposed to a
1: 		 * FBT being under a PRN, etc.
1: 		 */
1: 		source.disableBulkFetch();
1: 	}
1: 
1: 	/** 
1: 	 * Fill in the column mapping for those columns coming from the index.
1: 	 *
1: 	 * @return The int[] with the mapping.
1: 	 */
1: 	private int[] getIndexColMapping()
1: 	{
0: 		int		rclSize = resultColumns.size();
1: 		int[]	indexColMapping = new int[rclSize];
1: 
1: 		for (int index = 0; index < rclSize; index++)
1: 		{
0: 			ResultColumn rc = (ResultColumn) resultColumns.elementAt(index);
1: 			if (indexReferencedCols != null && rc.getExpression() instanceof VirtualColumnNode)
1: 			{
1: 				// Column is coming from index
1: 				VirtualColumnNode vcn = (VirtualColumnNode) rc.getExpression();
1: 				indexColMapping[index] =
1: 					vcn.getSourceColumn().getVirtualColumnId() - 1;
1: 			}
1: 			else
1: 			{
1: 				// Column is not coming from index
1: 				indexColMapping[index] = -1;
1: 			}
1: 		}
1: 
1: 		return indexColMapping;
1: 	}
1: 
1: }
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2d37fd6
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package	org.apache.derby.impl.sql.compile;
0: 
0: import org.apache.derby.iapi.services.context.ContextManager;
0: 
0: import org.apache.derby.iapi.sql.compile.AccessPath;
0: import org.apache.derby.iapi.sql.compile.CostEstimate;
0: import org.apache.derby.iapi.sql.compile.Optimizable;
0: 
0: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
0: 
0: import org.apache.derby.impl.sql.compile.ActivationClassBuilder;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
0: 
0: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
0: 
0: import org.apache.derby.iapi.sql.Activation;
0: import org.apache.derby.iapi.sql.ResultSet;
0: 
0: import org.apache.derby.iapi.services.loader.GeneratedMethod;
0: 
0: import org.apache.derby.iapi.store.access.StaticCompiledOpenConglomInfo;
0: 
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: 
0: import org.apache.derby.catalog.types.ReferencedColumnsDescriptorImpl;
0: import org.apache.derby.iapi.reference.ClassName;
0: import org.apache.derby.iapi.services.classfile.VMOpcode;
0: 
0: import java.util.Properties;
0: import java.util.Vector;
0: 
0: /**
0:  * This node type translates an index row to a base row.  It takes a
0:  * FromBaseTable as its source ResultSetNode, and generates an
0:  * IndexRowToBaseRowResultSet that takes a TableScanResultSet on an
0:  * index conglomerate as its source.
0:  */
0: public class IndexToBaseRowNode extends FromTable
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	protected FromBaseTable	source;
0: 	protected ConglomerateDescriptor	baseCD;
0: 	protected boolean	cursorTargetTable;
0: 	protected PredicateList restrictionList;
0: 	protected boolean	forUpdate;
0: 	private FormatableBitSet	heapReferencedCols;
0: 	private FormatableBitSet	indexReferencedCols;
0: 
0: 	public void init(
0: 			Object	source,
0: 			Object	baseCD,
0: 			Object	resultColumns,
0: 			Object	cursorTargetTable,
0: 			Object heapReferencedCols,
0: 			Object indexReferencedCols,
0: 			Object restrictionList,
0: 			Object forUpdate,
0: 			Object tableProperties)
0: 	{
0: 		super.init(null, tableProperties);
0: 		this.source = (FromBaseTable) source;
0: 		this.baseCD = (ConglomerateDescriptor) baseCD;
0: 		this.resultColumns = (ResultColumnList) resultColumns;
0: 		this.cursorTargetTable = ((Boolean) cursorTargetTable).booleanValue();
0: 		this.restrictionList = (PredicateList) restrictionList;
0: 		this.forUpdate = ((Boolean) forUpdate).booleanValue();
0: 		this.heapReferencedCols = (FormatableBitSet) heapReferencedCols;
0: 		this.indexReferencedCols = (FormatableBitSet) indexReferencedCols;
0: 	}
0: 
0: 	/** @see Optimizable#forUpdate */
0: 	public boolean forUpdate()
0: 	{
0: 		return source.forUpdate();
0: 	}
0: 
0: 	/** @see Optimizable#getTrulyTheBestAccessPath */
0: 	public AccessPath getTrulyTheBestAccessPath()
0: 	{
0: 		// Get AccessPath comes from base table.
0: 		return ((Optimizable) source).getTrulyTheBestAccessPath();
0: 	}
0: 
0: 	public CostEstimate getCostEstimate()
0: 	{
0: 		return source.getTrulyTheBestAccessPath().getCostEstimate();
0: 	}
0: 
0: 	public CostEstimate getFinalCostEstimate()
0: 	{
0: 		return source.getFinalCostEstimate();
0: 	}
0: 
0: 	/**
0: 	 * Return whether or not the underlying ResultSet tree
0: 	 * is ordered on the specified columns.
0: 	 * RESOLVE - This method currently only considers the outermost table 
0: 	 * of the query block.
0: 	 *
0: 	 * @param	crs					The specified ColumnReference[]
0: 	 * @param	permuteOrdering		Whether or not the order of the CRs in the array can be permuted
0: 	 * @param	fbtVector			Vector that is to be filled with the FromBaseTable	
0: 	 *
0: 	 * @return	Whether the underlying ResultSet tree
0: 	 * is ordered on the specified column.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	boolean isOrderedOn(ColumnReference[] crs, boolean permuteOrdering, Vector fbtVector)
0: 				throws StandardException
0: 	{
0: 		return source.isOrderedOn(crs, permuteOrdering, fbtVector);
0: 	}
0: 
0: 	/**
0: 	 * Generation of an IndexToBaseRowNode creates an
0: 	 * IndexRowToBaseRowResultSet, which uses the RowLocation in the last
0: 	 * column of an index row to get the row from the base conglomerate (heap).
0: 	 *
0: 	 * @param acb	The ActivationClassBuilder for the class being built
0: 	 * @param mb the method  for the method to be built
0: 	 *
0: 	 * @return	A compiled Expression that returns a ResultSet that
0: 	 *			gets a base from from an index row.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void generate(ActivationClassBuilder acb,
0: 								MethodBuilder mb)
0: 							throws StandardException
0: 	{
0: 		ValueNode		restriction = null;
0: 
0: 		/*
0: 		** Get the next ResultSet #, so that we can number this ResultSetNode,
0: 		** its ResultColumnList and ResultSet.
0: 		*/
0: 		assignResultSetNumber();
0: 
0: 		// Get the CostEstimate info for the underlying scan
0: 		costEstimate = getFinalCostEstimate();
0: 
0: 		/* Put the predicates back into the tree */
0: 		if (restrictionList != null)
0: 		{
0: 			restriction = restrictionList.restorePredicates();
0: 			/* Allow the restrictionList to get garbage collected now
0: 			 * that we're done with it.
0: 			 */
0: 			restrictionList = null;
0: 		}
0: 
0: 		// for the restriction, we generate an exprFun
0: 		// that evaluates the expression of the clause
0: 		// against the current row of the child's result.
0: 		// if the restriction is empty, simply pass null
0: 		// to optimize for run time performance.
0: 
0:    		// generate the function and initializer:
0:    		// Note: Boolean lets us return nulls (boolean would not)
0:    		// private Boolean exprN()
0:    		// {
0:    		//   return <<restriction.generate(ps)>>;
0:    		// }
0:    		// static Method exprN = method pointer to exprN;
0: 
0: 
0: 
0: 		int heapColRefItem = -1;
0: 		int indexColRefItem = -1;
0: 		if (heapReferencedCols != null)
0: 		{
0: 			heapColRefItem = acb.addItem(heapReferencedCols);
0: 		}
0: 		if (indexReferencedCols != null)
0: 		{
0: 			indexColRefItem = acb.addItem(indexReferencedCols);
0: 		}
0: 
0: 		/* Create the ReferencedColumnsDescriptorImpl which tells which columns
0: 		 * come from the index.
0: 		 */
0: 		int indexColMapItem = acb.addItem(new ReferencedColumnsDescriptorImpl(getIndexColMapping()));
0: 		long heapConglomNumber = baseCD.getConglomerateNumber();
0: 		StaticCompiledOpenConglomInfo scoci = getLanguageConnectionContext().
0: 												getTransactionCompile().
0: 													getStaticCompiledConglomInfo(heapConglomNumber);
0: 
0: 		acb.pushGetResultSetFactoryExpression(mb);
0: 
0: 		mb.push(heapConglomNumber);
0: 		mb.push(acb.addItem(scoci));
0: 		acb.pushThisAsActivation(mb);
0: 		source.generate(acb, mb);
0: 		
0: 		mb.upCast(ClassName.NoPutResultSet);
0: 
0: 		resultColumns.generateHolder(acb, mb,  heapReferencedCols, indexReferencedCols);
0: 		mb.push(resultSetNumber);
0: 		mb.push(source.getBaseTableName());
0: 		mb.push(heapColRefItem);
0: 		mb.push(indexColRefItem);
0: 		mb.push(indexColMapItem);
0: 
0: 		// if there is no restriction, we just want to pass null.
0: 		if (restriction == null)
0: 		{
0: 		   	mb.pushNull(ClassName.GeneratedMethod);
0: 		}
0: 		else
0: 		{
0: 			// this sets up the method and the static field.
0: 			// generates:
0: 			// 	Object userExprFun { }
0: 			MethodBuilder userExprFun = acb.newUserExprFun();
0: 
0: 			// restriction knows it is returning its value;
0: 	
0: 			/* generates:
0: 			 *    return <restriction.generate(acb)>;
0: 			 * and adds it to userExprFun
0: 			 * NOTE: The explicit cast to DataValueDescriptor is required
0: 			 * since the restriction may simply be a boolean column or subquery
0: 			 * which returns a boolean.  For example:
0: 			 *		where booleanColumn
0: 			 */
0: 			restriction.generate(acb, userExprFun);
0: 			userExprFun.methodReturn();
0: 
0: 			// we are done modifying userExprFun, complete it.
0: 			userExprFun.complete();
0: 
0: 	   		// restriction is used in the final result set as an access of the new static
0:    			// field holding a reference to this new method.
0: 			// generates:
0: 			//	ActivationClass.userExprFun
0: 			// which is the static field that "points" to the userExprFun
0: 			// that evaluates the where clause.
0:    			acb.pushMethodReference(mb, userExprFun);
0: 		}
0: 
0: 		mb.push(forUpdate);
0: 		mb.push(costEstimate.rowCount());
0: 		mb.push(costEstimate.getEstimatedCost());
0: 		closeMethodArgument(acb, mb);
0: 
0: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, "getIndexRowToBaseRowResultSet",
0: 						ClassName.NoPutResultSet, 15);
0: 
0: 		/* The IndexRowToBaseRowResultSet generator is what we return */
0: 
0: 		/*
0: 		** Remember if this result set is the cursor target table, so we
0: 		** can know which table to use when doing positioned update and delete.
0: 		*/
0: 		if (cursorTargetTable)
0: 		{
0: 			acb.rememberCursorTarget(mb);
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Return whether or not the underlying ResultSet tree will return
0: 	 * a single row, at most.
0: 	 * This is important for join nodes where we can save the extra next
0: 	 * on the right side if we know that it will return at most 1 row.
0: 	 *
0: 	 * @return Whether or not the underlying ResultSet tree will return a single row.
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public boolean isOneRowResultSet()	throws StandardException
0: 	{
0: 		// Default is false
0: 		return source.isOneRowResultSet();
0: 	}
0: 
0: 	/**
0: 	 * Return whether or not the underlying FBT is for NOT EXISTS.
0: 	 *
0: 	 * @return Whether or not the underlying FBT is for NOT EXISTS.
0: 	 */
0: 	public boolean isNotExists()
0: 	{
0: 		return source.isNotExists();
0: 	}
0: 
0: 	/**
0: 	 * Decrement (query block) level (0-based) for this FromTable.
0: 	 * This is useful when flattening a subquery.
0: 	 *
0: 	 * @param decrement	The amount to decrement by.
0: 	 */
0: 	void decrementLevel(int decrement)
0: 	{
0: 		source.decrementLevel(decrement);
0: 	}
0: 
0: 	/**
0: 	 * Get the lock mode for the target of an update statement
0: 	 * (a delete or update).  The update mode will always be row for
0: 	 * CurrentOfNodes.  It will be table if there is no where clause.
0: 	 *
0: 	 * @return	The lock mode
0: 	 */
0: 	public int updateTargetLockMode()
0: 	{
0: 		return source.updateTargetLockMode();
0: 	}
0: 
0: 	/**
0: 	 * Notify the underlying result set tree that the result is
0: 	 * ordering dependent.  (For example, no bulk fetch on an index
0: 	 * if under an IndexRowToBaseRow.)
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	void markOrderingDependent()
0: 	{
0: 		/* NOTE: We use a different method to tell a FBT that
0: 		 * it cannot do a bulk fetch as the ordering issues are
0: 		 * specific to a FBT being under an IRTBR as opposed to a
0: 		 * FBT being under a PRN, etc.
0: 		 */
0: 		source.disableBulkFetch();
0: 	}
0: 
0: 	/** 
0: 	 * Fill in the column mapping for those columns coming from the index.
0: 	 *
0: 	 * @return The int[] with the mapping.
0: 	 */
0: 	private int[] getIndexColMapping()
0: 	{
0: 		int		rclSize = resultColumns.size();
0: 		int[]	indexColMapping = new int[rclSize];
0: 
0: 		for (int index = 0; index < rclSize; index++)
0: 		{
0: 			ResultColumn rc = (ResultColumn) resultColumns.elementAt(index);
0: 			if (indexReferencedCols != null && rc.getExpression() instanceof VirtualColumnNode)
0: 			{
0: 				// Column is coming from index
0: 				VirtualColumnNode vcn = (VirtualColumnNode) rc.getExpression();
0: 				indexColMapping[index] =
0: 					vcn.getSourceColumn().getVirtualColumnId() - 1;
0: 			}
0: 			else
0: 			{
0: 				// Column is not coming from index
0: 				indexColMapping[index] = -1;
0: 			}
0: 		}
0: 
0: 		return indexColMapping;
0: 	}
0: 
0: }
============================================================================