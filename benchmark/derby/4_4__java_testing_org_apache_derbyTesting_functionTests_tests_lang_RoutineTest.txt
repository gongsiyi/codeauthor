1:d8a9518: /*
9:d8a9518: 
1:d8a9518:    Derby - Class org.apache.derbyTesting.functionTests.tests.lang.RoutineTest
1:eff9169: 
1:d8a9518:        Licensed to the Apache Software Foundation (ASF) under one
1:d8a9518:        or more contributor license agreements.  See the NOTICE file
1:d8a9518:        distributed with this work for additional information
1:d8a9518:        regarding copyright ownership.  The ASF licenses this file
1:d8a9518:        to you under the Apache License, Version 2.0 (the
1:d8a9518:        "License"); you may not use this file except in compliance
1:d8a9518:        with the License.  You may obtain a copy of the License at
1:d8a9518: 
1:d8a9518:          http://www.apache.org/licenses/LICENSE-2.0
1:d8a9518: 
1:d8a9518:        Unless required by applicable law or agreed to in writing,
1:d8a9518:        software distributed under the License is distributed on an
1:d8a9518:        "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:d8a9518:        KIND, either express or implied.  See the License for the
1:d8a9518:        specific language governing permissions and limitations
1:d8a9518:        under the License
1:d8a9518: */
1:d8a9518: package org.apache.derbyTesting.functionTests.tests.lang;
1:d8a9518: 
1:d8a9518: import java.io.UnsupportedEncodingException;
1:eff9169: import java.sql.CallableStatement;
1:8c39c1c: import java.sql.Connection;
1:d8a9518: import java.sql.PreparedStatement;
1:96e7da9: import java.sql.ResultSet;
1:d8a9518: import java.sql.SQLException;
1:ea8303d: import java.sql.Statement;
1:d2cb094: import java.sql.Time;
1:d8a9518: import java.sql.Types;
1:d8a9518: import junit.framework.Test;
1:d8a9518: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:d8a9518: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1:d8a9518: import org.apache.derbyTesting.junit.JDBC;
1:d8a9518: 
1:057ae46: /**
1:d8a9518:  * Set of tests for SQL routines.
1:d8a9518:  * This tests mainly the SQL definition of routines
1:d8a9518:  * and the server-side behaviour of routines.
1:d8a9518:  * Calling of procedures is tested in ProcedureTest.
1:d8a9518:  *
1:d8a9518:  */
1:d8a9518: public class RoutineTest extends BaseJDBCTestCase {
1:d8a9518: 
1:aec2537:     private static final String CANNOT_STUFF_NULL_INTO_PRIMITIVE = "39004";
1:aec2537:     
1:d8a9518:     public RoutineTest(String name)
1:d8a9518:     {
1:d8a9518:         super(name);
1:d8a9518:     }
1:eff9169:     
1:d8a9518:     public static Test suite() {
1:1ae02c9:         BaseTestSuite suite =
1:1ae02c9:             new BaseTestSuite(RoutineTest.class, "RoutineTest");
1:d8a9518:         
1:d8a9518:         return new CleanDatabaseTestSetup(suite);
1:d8a9518:     }
1:057ae46:     
1:d8a9518:     
1:8c39c1c:     /**
1:057ae46:      * Test that function result data types are resolved correctly for numeric
1:057ae46:      * types that Derby supports that are simply mappable or object mappable.
1:057ae46:      */
1:057ae46:     public void testFunctionResultDataTypeValidation() throws SQLException
1:057ae46:     {
1:057ae46:         Statement s = createStatement();
1:057ae46: 
1:057ae46:         // SMALLINT -> short
1:057ae46:         s.executeUpdate(
1:057ae46:         "CREATE FUNCTION SMALLINT_P_SHORT(VARCHAR(10)) RETURNS SMALLINT " +
1:057ae46:            "EXTERNAL NAME 'java.lang.Short.parseShort' " +
1:057ae46:            "LANGUAGE JAVA PARAMETER STYLE JAVA");
1:057ae46: 
1:057ae46:         PreparedStatement ps = prepareStatement("VALUES SMALLINT_P_SHORT(?)");
1:057ae46:         ps.setString(1, "123");
1:057ae46:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "123");  
1:057ae46: 
1:057ae46:         // SMALLINT -> Integer
1:057ae46:         s.executeUpdate(
1:057ae46:         "CREATE FUNCTION SMALLINT_O_INTEGER(VARCHAR(10)) RETURNS SMALLINT " +
1:057ae46:            "EXTERNAL NAME 'java.lang.Integer.valueOf' " +
1:057ae46:            "LANGUAGE JAVA PARAMETER STYLE JAVA");
1:057ae46: 
1:057ae46:         ps = prepareStatement("VALUES SMALLINT_O_INTEGER(?)");
1:057ae46:         ps.setString(1, "123");
1:057ae46:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "123");  
1:057ae46: 
1:057ae46:         // INTEGER -> int
1:057ae46:         s.executeUpdate(
1:057ae46:         "CREATE FUNCTION INTEGER_P_INT(VARCHAR(10)) RETURNS INTEGER " +
1:057ae46:            "EXTERNAL NAME 'java.lang.Integer.parseInt' " +
1:057ae46:            "LANGUAGE JAVA PARAMETER STYLE JAVA");
1:057ae46: 
1:057ae46:         ps = prepareStatement("VALUES INTEGER_P_INT(?)");
1:057ae46:         ps.setString(1, "123");
1:057ae46:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "123");  
1:057ae46: 
1:057ae46:         // INTEGER -> Integer
1:057ae46:         s.executeUpdate(
1:057ae46:         "CREATE FUNCTION INTEGER_O_INTEGER(VARCHAR(10)) RETURNS INTEGER " +
1:057ae46:            "EXTERNAL NAME 'java.lang.Integer.valueOf' " +
1:057ae46:            "LANGUAGE JAVA PARAMETER STYLE JAVA");
1:057ae46: 
1:057ae46:         ps = prepareStatement("VALUES INTEGER_O_INTEGER(?)");
1:057ae46:         ps.setString(1, "123");
1:057ae46:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "123");  
1:057ae46: 
1:057ae46:         // BIGINT -> long
1:057ae46:         s.executeUpdate(
1:057ae46:         "CREATE FUNCTION BIGINT_P_LONG(VARCHAR(10)) RETURNS BIGINT " +
1:057ae46:            "EXTERNAL NAME 'java.lang.Long.parseLong' " +
1:057ae46:            "LANGUAGE JAVA PARAMETER STYLE JAVA");
1:057ae46: 
1:057ae46:         ps = prepareStatement("VALUES BIGINT_P_LONG(?)");
1:057ae46:         ps.setString(1, "123");
1:057ae46:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "123");  
1:057ae46: 
1:057ae46:         // BIGINT -> Long
1:057ae46:         s.executeUpdate(
1:057ae46:         "CREATE FUNCTION BIGINT_O_LONG(VARCHAR(10)) RETURNS BIGINT " +
1:057ae46:            "EXTERNAL NAME 'java.lang.Long.valueOf' " +
1:057ae46:            "LANGUAGE JAVA PARAMETER STYLE JAVA");
1:057ae46: 
1:057ae46:         ps = prepareStatement("VALUES BIGINT_O_LONG(?)");
1:057ae46:         ps.setString(1, "123");
1:057ae46:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "123");  
1:057ae46: 
1:057ae46:         // REAL -> float
1:057ae46:         s.executeUpdate(
1:057ae46:         "CREATE FUNCTION REAL_P_FLOAT(VARCHAR(10)) RETURNS REAL " +
1:057ae46:            "EXTERNAL NAME 'java.lang.Float.parseFloat' " +
1:057ae46:            "LANGUAGE JAVA PARAMETER STYLE JAVA");
1:057ae46: 
1:057ae46:         ps = prepareStatement("VALUES REAL_P_FLOAT(?)");
1:057ae46:         ps.setString(1, "123.0");
1:057ae46:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "123.0");  
1:057ae46: 
1:057ae46:         // REAL -> Float
1:057ae46:         s.executeUpdate(
1:057ae46:         "CREATE FUNCTION REAL_O_FLOAT(VARCHAR(10)) RETURNS REAL " +
1:057ae46:            "EXTERNAL NAME 'java.lang.Float.valueOf' " +
1:057ae46:            "LANGUAGE JAVA PARAMETER STYLE JAVA");
1:057ae46: 
1:057ae46:         ps = prepareStatement("VALUES REAL_O_FLOAT(?)");
1:057ae46:         ps.setString(1, "123.0");
1:057ae46:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "123.0");  
1:057ae46: 
1:057ae46:         // DOUBLE -> double
1:057ae46:         s.executeUpdate(
1:057ae46:         "CREATE FUNCTION DOUBLE_P_DOUBLE(VARCHAR(10)) RETURNS DOUBLE " +
1:057ae46:            "EXTERNAL NAME 'java.lang.Double.parseDouble' " +
1:057ae46:            "LANGUAGE JAVA PARAMETER STYLE JAVA");
1:057ae46: 
1:057ae46:         ps = prepareStatement("VALUES DOUBLE_P_DOUBLE(?)");
1:057ae46:         ps.setString(1, "123.0");
1:057ae46:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "123.0");  
1:057ae46: 
1:057ae46:         // DOBULE -> Double
1:057ae46:         s.executeUpdate(
1:057ae46:         "CREATE FUNCTION DOUBLE_O_DOUBLE(VARCHAR(10)) RETURNS DOUBLE " +
1:057ae46:            "EXTERNAL NAME 'java.lang.Double.valueOf' " +
1:057ae46:            "LANGUAGE JAVA PARAMETER STYLE JAVA");
1:057ae46: 
1:057ae46:         ps = prepareStatement("VALUES DOUBLE_O_DOUBLE(?)");
1:057ae46:         ps.setString(1, "123.0");
1:057ae46:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "123.0");
1:057ae46:         
1:057ae46:         ps.close();
1:057ae46:         s.close();
1:057ae46:     }
1:057ae46:     
1:aec2537:     /**
1:0a6ce0b:      * Test that RETURNS NULL ON NULL INPUT works properly with 
1:0a6ce0b:      * numeric datatypes for null and non-null values.
1:0a6ce0b:      */
1:0a6ce0b:     public void testFunctionReturnsNullOnNullInput() throws SQLException
1:0a6ce0b:     {
1:0a6ce0b:         Statement s = createStatement();
1:0a6ce0b: 
1:0a6ce0b:         // SMALLINT -> short
1:0a6ce0b:         s.executeUpdate(
1:0a6ce0b:         "CREATE FUNCTION SMALLINT_P_SHORT_RN(VARCHAR(10)) RETURNS SMALLINT " +
1:0a6ce0b:            "EXTERNAL NAME 'java.lang.Short.parseShort' " +
1:0a6ce0b:            "LANGUAGE JAVA PARAMETER STYLE JAVA " +
1:0a6ce0b:            "RETURNS NULL ON NULL INPUT");
1:0a6ce0b: 
1:0a6ce0b:         PreparedStatement ps = prepareStatement("VALUES SMALLINT_P_SHORT_RN(?)");
1:0a6ce0b:         ps.setString(1, "123");
1:0a6ce0b:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "123");  
1:0a6ce0b: 
1:0a6ce0b:         ps.setString(1,null);
1:0a6ce0b:         JDBC.assertSingleValueResultSet(ps.executeQuery(), null);
1:0a6ce0b:         // SMALLINT -> Integer
1:0a6ce0b:         s.executeUpdate(
1:0a6ce0b:         "CREATE FUNCTION SMALLINT_O_INTEGER_RN(VARCHAR(10)) RETURNS SMALLINT " +
1:0a6ce0b:            "EXTERNAL NAME 'java.lang.Integer.valueOf' " +
1:0a6ce0b:            "LANGUAGE JAVA PARAMETER STYLE JAVA " +
1:0a6ce0b:            "RETURNS NULL ON NULL INPUT");
1:0a6ce0b: 
1:0a6ce0b:         ps = prepareStatement("VALUES SMALLINT_O_INTEGER_RN(?)");
1:0a6ce0b:         ps.setString(1, "123");
1:0a6ce0b:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "123");  
1:0a6ce0b: 
1:0a6ce0b:         ps.setString(1, null);
1:0a6ce0b:         JDBC.assertSingleValueResultSet(ps.executeQuery(), null);
1:0a6ce0b:         // INTEGER -> int
1:0a6ce0b:         s.executeUpdate(
1:0a6ce0b:         "CREATE FUNCTION INTEGER_P_INT_RN(VARCHAR(10)) RETURNS INTEGER " +
1:0a6ce0b:            "EXTERNAL NAME 'java.lang.Integer.parseInt' " +
1:0a6ce0b:            "LANGUAGE JAVA PARAMETER STYLE JAVA " +
1:0a6ce0b:            "RETURNS NULL ON NULL INPUT");
1:0a6ce0b: 
1:0a6ce0b:         ps = prepareStatement("VALUES INTEGER_P_INT_RN(?)");
1:0a6ce0b:         ps.setString(1, "123");
1:0a6ce0b:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "123");  
1:0a6ce0b: 
1:0a6ce0b:         // INTEGER -> Integer
1:0a6ce0b:         s.executeUpdate(
1:0a6ce0b:         "CREATE FUNCTION INTEGER_O_INTEGER_RN(VARCHAR(10)) RETURNS INTEGER " +
1:0a6ce0b:            "EXTERNAL NAME 'java.lang.Integer.valueOf' " +
1:0a6ce0b:            "LANGUAGE JAVA PARAMETER STYLE JAVA " +
1:0a6ce0b:            "RETURNS NULL ON NULL INPUT");
1:0a6ce0b: 
1:0a6ce0b:         ps = prepareStatement("VALUES INTEGER_O_INTEGER_RN(?)");
1:0a6ce0b:         ps.setString(1, "123");
1:0a6ce0b:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "123");  
1:0a6ce0b:         ps.setString(1, null);
1:0a6ce0b:         JDBC.assertSingleValueResultSet(ps.executeQuery(), null);
1:0a6ce0b:         // BIGINT -> long
1:0a6ce0b:         s.executeUpdate(
1:0a6ce0b:         "CREATE FUNCTION BIGINT_P_LONG_RN(VARCHAR(10)) RETURNS BIGINT " +
1:0a6ce0b:            "EXTERNAL NAME 'java.lang.Long.parseLong' " +
1:0a6ce0b:            "LANGUAGE JAVA PARAMETER STYLE JAVA " +
1:0a6ce0b:            "RETURNS NULL ON NULL INPUT");
1:0a6ce0b: 
1:0a6ce0b:         ps = prepareStatement("VALUES BIGINT_P_LONG_RN(?)");
1:0a6ce0b:         ps.setString(1, "123");
1:0a6ce0b:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "123");  
1:0a6ce0b:         ps.setString(1, null);
1:0a6ce0b:         JDBC.assertSingleValueResultSet(ps.executeQuery(), null);
1:0a6ce0b:         // BIGINT -> Long
1:0a6ce0b:         s.executeUpdate(
1:0a6ce0b:         "CREATE FUNCTION BIGINT_O_LONG_NR(VARCHAR(10)) RETURNS BIGINT " +
1:0a6ce0b:            "EXTERNAL NAME 'java.lang.Long.valueOf' " +
1:0a6ce0b:            "LANGUAGE JAVA PARAMETER STYLE JAVA " +
1:0a6ce0b:            "RETURNS NULL ON NULL INPUT");
1:0a6ce0b: 
1:0a6ce0b:         ps = prepareStatement("VALUES BIGINT_O_LONG_NR(?)");
1:0a6ce0b:         ps.setString(1, "123");
1:0a6ce0b:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "123");  
1:0a6ce0b:         ps.setString(1, null);
1:0a6ce0b:         JDBC.assertSingleValueResultSet(ps.executeQuery(), null);
1:0a6ce0b:         // REAL -> float
1:0a6ce0b:         s.executeUpdate(
1:0a6ce0b:         "CREATE FUNCTION REAL_P_FLOAT_NR(VARCHAR(10)) RETURNS REAL " +
1:0a6ce0b:            "EXTERNAL NAME 'java.lang.Float.parseFloat' " +
1:0a6ce0b:            "LANGUAGE JAVA PARAMETER STYLE JAVA " +
1:0a6ce0b:            "RETURNS NULL ON NULL INPUT");
1:0a6ce0b: 
1:0a6ce0b:         ps = prepareStatement("VALUES REAL_P_FLOAT_NR(?)");
1:0a6ce0b:         ps.setString(1, "123.0");
1:0a6ce0b:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "123.0");  
1:0a6ce0b:         ps.setString(1, null);
1:0a6ce0b:         JDBC.assertSingleValueResultSet(ps.executeQuery(), null);
1:0a6ce0b:         
1:0a6ce0b:         // REAL -> Float
1:0a6ce0b:         s.executeUpdate(
1:0a6ce0b:         "CREATE FUNCTION REAL_O_FLOAT_NR(VARCHAR(10)) RETURNS REAL " +
1:0a6ce0b:            "EXTERNAL NAME 'java.lang.Float.valueOf' " +
1:0a6ce0b:            "LANGUAGE JAVA PARAMETER STYLE JAVA " +
1:0a6ce0b:            "RETURNS NULL ON NULL INPUT");
1:0a6ce0b: 
1:0a6ce0b:         ps = prepareStatement("VALUES REAL_O_FLOAT_NR(?)");
1:0a6ce0b:         ps.setString(1, "123.0");
1:0a6ce0b:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "123.0");  
1:0a6ce0b:         ps.setString(1, null);
1:0a6ce0b:         JDBC.assertSingleValueResultSet(ps.executeQuery(), null);
1:0a6ce0b:         
1:0a6ce0b:         // DOUBLE -> double
1:0a6ce0b:         s.executeUpdate(
1:0a6ce0b:         "CREATE FUNCTION DOUBLE_P_DOUBLE_NR(VARCHAR(10)) RETURNS DOUBLE " +
1:0a6ce0b:            "EXTERNAL NAME 'java.lang.Double.parseDouble' " +
1:0a6ce0b:            "LANGUAGE JAVA PARAMETER STYLE JAVA " +
1:0a6ce0b:            "RETURNS NULL ON NULL INPUT");
1:0a6ce0b: 
1:0a6ce0b:         ps = prepareStatement("VALUES DOUBLE_P_DOUBLE_NR(?)");
1:0a6ce0b:         ps.setString(1, "123.0");
1:0a6ce0b:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "123.0");  
1:0a6ce0b:         ps.setString(1, null);
1:0a6ce0b:         JDBC.assertSingleValueResultSet(ps.executeQuery(), null);
1:0a6ce0b:         
1:0a6ce0b:         // DOBULE -> Double
1:0a6ce0b:         s.executeUpdate(
1:0a6ce0b:         "CREATE FUNCTION DOUBLE_O_DOUBLE_NR(VARCHAR(10)) RETURNS DOUBLE " +
1:0a6ce0b:            "EXTERNAL NAME 'java.lang.Double.valueOf' " +
1:0a6ce0b:            "LANGUAGE JAVA PARAMETER STYLE JAVA " +
1:0a6ce0b:            "RETURNS NULL ON NULL INPUT");
1:0a6ce0b: 
1:0a6ce0b:         ps = prepareStatement("VALUES DOUBLE_O_DOUBLE_NR(?)");
1:0a6ce0b:         ps.setString(1, "123.0");
1:0a6ce0b:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "123.0");
1:0a6ce0b:         ps.setString(1, null);
1:0a6ce0b:         JDBC.assertSingleValueResultSet(ps.executeQuery(), null);
1:0a6ce0b:         
1:0a6ce0b:         ps.close();
1:0a6ce0b:         s.close();
1:0a6ce0b:     }
1:0a6ce0b:     
1:0a6ce0b:     /**
1:d8a9518:      * Test that functions handle being called or not called
1:d8a9518:      * when it is passed a NULL argument correctly.
1:d8a9518:      * A function can be declared:
1:d8a9518:      * RETURNS NULL ON NULL INPUT - any argument being NULL means the
1:d8a9518:      * function is returns NULL without being called.
1:d8a9518:      * CALLED ON NULL INPUT (default) - function is always called regardless
1:d8a9518:      * of any arguement being NULL.
1:d8a9518:      */
1:d8a9518:     public void testFunctionNullHandling() throws SQLException, UnsupportedEncodingException
1:d8a9518:     {
1:ea8303d:         Statement s = createStatement();
1:ea8303d:         
1:d8a9518:         // Create three simple functions that take an integer and
1:d8a9518:         // return its value as a VARCHAR().
1:ea8303d:         s.executeUpdate(
1:d8a9518:         "CREATE FUNCTION SV_NOCALL(INTEGER) RETURNS VARCHAR(10) " +
1:d8a9518:            "RETURNS NULL ON NULL INPUT " +
1:d8a9518:            "EXTERNAL NAME 'java.lang.String.valueOf'  " +
1:ea8303d:            "LANGUAGE JAVA PARAMETER STYLE JAVA");
1:d8a9518:            
1:ea8303d:         s.executeUpdate("CREATE FUNCTION SV_CALL(INTEGER) RETURNS VARCHAR(10) " +
1:d8a9518:           "CALLED ON NULL INPUT " +
1:d8a9518:           "EXTERNAL NAME 'java.lang.String.valueOf' " +
1:ea8303d:           "LANGUAGE JAVA PARAMETER STYLE JAVA");
1:d8a9518:           
1:ea8303d:         s.executeUpdate("CREATE FUNCTION SV_DEFAULT(INTEGER) RETURNS VARCHAR(10) " +
1:d8a9518:           "EXTERNAL NAME 'java.lang.String.valueOf' " +
1:ea8303d:           "LANGUAGE JAVA PARAMETER STYLE JAVA");
1:d8a9518:         
1:d8a9518:         // Simple cases of calling each function individually
1:d8a9518:         // Test each function with non-NULL and NULL values.
1:d8a9518:         PreparedStatement ps = prepareStatement("VALUES SV_NOCALL(?)");
1:d8a9518:         ps.setInt(1, 42);
1:d8a9518:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "42");  
1:d8a9518:         ps.setNull(1, Types.INTEGER);
1:d8a9518:         JDBC.assertSingleValueResultSet(ps.executeQuery(), null);
1:d8a9518:         ps.close();
1:d8a9518:         
1:d8a9518:         
1:d8a9518:         ps = prepareStatement("VALUES SV_CALL(?)");
1:d8a9518:         ps.setInt(1, 52);
1:d8a9518:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "52"); 
1:d8a9518:         
1:d8a9518:         // NULL will attempt to call the function but be blocked
1:d8a9518:         // because the Java parameter is a primitive. Since
1:d8a9518:         // the call attempt it made it is enough to show the
1:d8a9518:         // correct behaviour.
1:d8a9518:         ps.setNull(1, Types.INTEGER);
1:d8a9518:         assertStatementError("39004", ps);
1:d8a9518:         
1:d8a9518:         ps.close();
1:d8a9518:         
1:d8a9518:         // Default behaviour maps to CALLED ON NULL INPUT
1:d8a9518:         ps = prepareStatement("VALUES SV_DEFAULT(?)");
1:d8a9518:         ps.setInt(1, 62);
1:d8a9518:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "62");
1:d8a9518:         ps.setNull(1, Types.INTEGER);
1:d8a9518:         assertStatementError("39004", ps);
1:d8a9518:         ps.close();
1:d8a9518:         
1:d8a9518:         // Test that any single argument being null causes NULL to be returned.
1:ea8303d:         s.executeUpdate(
1:d8a9518:                 "CREATE FUNCTION CONCAT_NOCALL(VARCHAR(10), VARCHAR(10)) " +
1:d8a9518:                    "RETURNS VARCHAR(20) " +
1:d8a9518:                    "RETURNS NULL ON NULL INPUT " +
1:d8a9518:                    "EXTERNAL NAME '" +
1:d8a9518:                    RoutineTest.class.getName() + ".concat'  " +
1:ea8303d:                    "LANGUAGE JAVA PARAMETER STYLE JAVA");
1:ea8303d:          s.executeUpdate(
1:d8a9518:                 "CREATE FUNCTION CONCAT_CALL(VARCHAR(10), VARCHAR(10)) " +
1:d8a9518:                    "RETURNS VARCHAR(20) " +
1:d8a9518:                    "CALLED ON NULL INPUT " +
1:d8a9518:                    "EXTERNAL NAME '" +
1:d8a9518:                    RoutineTest.class.getName() + ".concat'  " +
1:ea8303d:                    "LANGUAGE JAVA PARAMETER STYLE JAVA");
1:d8a9518:         
1:d8a9518:         ps = prepareStatement("VALUES CONCAT_NOCALL(?, ?)");
1:d8a9518:         ps.setString(1, "good");
1:d8a9518:         ps.setString(2, "bye");
1:d8a9518:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "goodbye");
1:d8a9518:         
1:d8a9518:         ps.setString(1, null);
1:d8a9518:         ps.setString(2, "bye");
1:d8a9518:         JDBC.assertSingleValueResultSet(ps.executeQuery(), null);
1:d8a9518: 
1:d8a9518:         ps.setString(1, "good");
1:d8a9518:         ps.setString(2, null);
1:d8a9518:         JDBC.assertSingleValueResultSet(ps.executeQuery(), null);
1:d8a9518:         
1:d8a9518:         ps.setString(1, null);
1:d8a9518:         ps.setString(2, null);
1:d8a9518:         JDBC.assertSingleValueResultSet(ps.executeQuery(), null);
1:d8a9518:         
1:d8a9518:         ps.close();
1:d8a9518: 
1:d8a9518:         ps = prepareStatement("VALUES CONCAT_CALL(?, ?)");
1:d8a9518:         ps.setString(1, "good");
1:d8a9518:         ps.setString(2, "bye");
1:d8a9518:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "goodbye");
1:d8a9518:         
1:d8a9518:         ps.setString(1, null);
1:d8a9518:         ps.setString(2, "bye");
1:d8a9518:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "s1NULLbye");
1:d8a9518: 
1:d8a9518:         ps.setString(1, "good");
1:d8a9518:         ps.setString(2, null);
1:d8a9518:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "goods2NULL");
1:d8a9518:         
1:d8a9518:         ps.setString(1, null);
1:d8a9518:         ps.setString(2, null);
1:d8a9518:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "s1NULLs2NULL");
1:d8a9518:         
1:d8a9518:         ps.close();
1:d8a9518:         
1:d8a9518:         // Now nested calls
1:d8a9518:         ps = prepareStatement(
1:d8a9518:           "VALUES CONCAT_NOCALL(CONCAT_NOCALL(?, 'RNNI'), CONCAT_CALL(?, 'CONI'))");
1:d8a9518:         
1:d8a9518:         ps.setString(1, "p1");
1:d8a9518:         ps.setString(2, "p2");
1:d8a9518:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "p1RNNIp2CONI");
1:d8a9518:         
1:d8a9518:         ps.setString(1, null);
1:d8a9518:         ps.setString(2, "p2");
1:d8a9518:         JDBC.assertSingleValueResultSet(ps.executeQuery(), null);
1:d8a9518:         
1:d8a9518:         ps.setString(1, "p1");
1:d8a9518:         ps.setString(2, null);
1:d8a9518:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "p1RNNIs1NULLCONI");
1:d8a9518:         
1:d8a9518:         ps.setString(1, null);
1:d8a9518:         ps.setString(2, null);
1:d8a9518:         JDBC.assertSingleValueResultSet(ps.executeQuery(), null);
1:d8a9518:         ps.close();
1:d8a9518: 
1:d8a9518:         ps = prepareStatement(
1:d8a9518:           "VALUES CONCAT_CALL(CONCAT_NOCALL(?, 'RNNI'), CONCAT_CALL(?, 'CONI'))");
1:d8a9518:       
1:d8a9518:         ps.setString(1, "p1");
1:d8a9518:         ps.setString(2, "p2");
1:d8a9518:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "p1RNNIp2CONI");
1:d8a9518:       
1:d8a9518:         ps.setString(1, null);
1:d8a9518:         ps.setString(2, "p2");
1:d8a9518:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "s1NULLp2CONI");
1:d8a9518:       
1:d8a9518:         ps.setString(1, "p1");
1:d8a9518:         ps.setString(2, null);
1:d8a9518:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "p1RNNIs1NULLCONI");
1:d8a9518:       
1:d8a9518:         ps.setString(1, null);
1:d8a9518:         ps.setString(2, null);
1:d8a9518:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "s1NULLs1NULLCONI");
1:d8a9518:         ps.close();
1:d8a9518: 
1:d8a9518:         
1:d8a9518:         // Nested calls with SQL types that do not need casts
1:d8a9518:         // and map to primitive types. This had issues see DERBY-479
1:ea8303d:         s.executeUpdate(
1:d8a9518:                 "CREATE FUNCTION SAME_NOCALL(INTEGER) " +
1:d8a9518:                    "RETURNS INTEGER " +
1:d8a9518:                    "RETURNS NULL ON NULL INPUT " +
1:d8a9518:                    "EXTERNAL NAME '" +
1:d8a9518:                    RoutineTest.class.getName() + ".same'  " +
1:ea8303d:                    "LANGUAGE JAVA PARAMETER STYLE JAVA");
1:ea8303d:         
1:ea8303d:         s.executeUpdate(
1:d8a9518:                 "CREATE FUNCTION SAME_CALL(INTEGER) " +
1:d8a9518:                    "RETURNS INTEGER " +
1:d8a9518:                    "CALLED ON NULL INPUT " +
1:d8a9518:                    "EXTERNAL NAME '" +
1:d8a9518:                    RoutineTest.class.getName() + ".same'  " +
1:ea8303d:                    "LANGUAGE JAVA PARAMETER STYLE JAVA");
1:d8a9518:         
1:d8a9518:         ps = prepareStatement("VALUES SAME_NOCALL(SAME_NOCALL(?))");
1:d8a9518:         ps.setInt(1, 41);
1:d8a9518:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "41");
1:d8a9518:         ps.setNull(1, Types.INTEGER);
1:d8a9518:         JDBC.assertSingleValueResultSet(ps.executeQuery(), null);
1:d8a9518:         ps.close();
1:d8a9518:         
1:d8a9518:         ps = prepareStatement("VALUES SAME_NOCALL(SAME_CALL(?))");
1:d8a9518:         ps.setInt(1, 47);
1:d8a9518:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "47");
1:d8a9518:         ps.setNull(1, Types.INTEGER);
1:d8a9518:         assertStatementError("39004", ps); // Can't pass NULL into primitive type
1:d8a9518:         ps.close();
1:d2cb094: 
1:d8a9518:         ps = prepareStatement("VALUES SAME_CALL(SAME_NOCALL(?))");
1:d8a9518:         ps.setInt(1, 41);
1:d8a9518:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "41");
1:d8a9518:         ps.setNull(1, Types.INTEGER);
1:d8a9518:         assertStatementError("39004", ps); // Can't pass NULL into primitive type
1:d8a9518:         ps.close();
1:d2cb094: 
1:d8a9518:         ps = prepareStatement("VALUES SAME_CALL(SAME_CALL(?))");
1:d8a9518:         ps.setInt(1, 53);
1:d8a9518:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "53");
1:d8a9518:         ps.setNull(1, Types.INTEGER);
1:d8a9518:         assertStatementError("39004", ps); // Can't pass NULL into primitive type
1:d8a9518:         ps.close();
1:d8a9518: 
1:ea8303d:         s.executeUpdate(
1:d2cb094:                 "CREATE FUNCTION NOON_NOCALL(TIME) " +
1:d2cb094:                    "RETURNS TIME " +
1:d2cb094:                    "RETURNS NULL ON NULL INPUT " +
1:d2cb094:                    "EXTERNAL NAME '" +
1:d2cb094:                    RoutineTest.class.getName() + ".nullAtNoon'  " +
1:ea8303d:                    "LANGUAGE JAVA PARAMETER STYLE JAVA");
1:ea8303d:         
1:ea8303d:         s.executeUpdate(
1:d2cb094:                 "CREATE FUNCTION NOON_CALL(TIME) " +
1:d2cb094:                    "RETURNS TIME " +
1:d2cb094:                    "CALLED ON NULL INPUT " +
1:d2cb094:                    "EXTERNAL NAME '" +
1:d2cb094:                    RoutineTest.class.getName() + ".nullAtNoon'  " +
1:ea8303d:                    "LANGUAGE JAVA PARAMETER STYLE JAVA");
1:d2cb094:         
1:d2cb094:         // Function maps:
1:d2cb094:         // NULL to 11:00:00 (if null can be passed)
1:d2cb094:         // 11:00:00 to 11:30:00
1:d2cb094:         // 12:00:00 to NULL
1:d2cb094:         // any other time to itself
1:d2cb094:         
1:d2cb094:         Time noon = Time.valueOf("12:00:00"); // mapped to null by the function
1:d2cb094:         Time tea = Time.valueOf("15:30:00");
1:d2cb094:         
1:d2cb094:         ps = prepareStatement("VALUES NOON_NOCALL(?)");
1:d2cb094:         ps.setTime(1, tea);
1:d2cb094:         JDBC.assertSingleValueResultSet(ps.executeQuery(), tea.toString());
1:d2cb094:         ps.setTime(1, noon);
1:d2cb094:         JDBC.assertSingleValueResultSet(ps.executeQuery(), null);
1:d2cb094:         ps.setTime(1, null);
1:d2cb094:         JDBC.assertSingleValueResultSet(ps.executeQuery(), null);
1:d2cb094:         ps.close();
1:d2cb094: 
1:d2cb094:         ps = prepareStatement("VALUES NOON_CALL(?)");
1:d2cb094:         ps.setTime(1, tea);
1:d2cb094:         JDBC.assertSingleValueResultSet(ps.executeQuery(), tea.toString());
1:d2cb094:         ps.setTime(1, noon);
1:d2cb094:         JDBC.assertSingleValueResultSet(ps.executeQuery(), null);
1:d2cb094:         ps.setTime(1, null);
2:d2cb094:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "11:00:00");
1:d2cb094:         ps.close();
1:d2cb094:         
1:d2cb094:         // All the nested calls in these cases take take the
1:d2cb094:         // value 'tea' will return the same value.
1:d2cb094:         
1:d2cb094:         ps = prepareStatement("VALUES NOON_NOCALL(NOON_NOCALL(?))");
1:d2cb094:         ps.setTime(1, tea);
1:d2cb094:         JDBC.assertSingleValueResultSet(ps.executeQuery(), tea.toString());
1:d2cb094:         ps.setTime(1, noon); // noon->NULL->NULL
1:d2cb094:         JDBC.assertSingleValueResultSet(ps.executeQuery(), null);
1:d2cb094:         ps.setTime(1, null); // NULL->NULL->NULL
1:d2cb094:         JDBC.assertSingleValueResultSet(ps.executeQuery(), null);
1:d2cb094:         ps.close();
1:d2cb094:         
1:d2cb094:         ps = prepareStatement("VALUES NOON_NOCALL(NOON_CALL(?))");
1:d2cb094:         ps.setTime(1, tea);
1:d2cb094:         JDBC.assertSingleValueResultSet(ps.executeQuery(), tea.toString());
1:d2cb094:                
1:d2cb094:         // DERBY-1030 RESULT SHOULD BE NULL
1:d2cb094:         // noon->NULL by inner function
1:d2cb094:         // NULL->NULL by outer due to RETURN NULL ON NULL INPUT
1:d2cb094:         ps.setTime(1, noon); // noon->NULL->NULL
1:ec60795:         JDBC.assertSingleValueResultSet(ps.executeQuery(), null);        
1:d2cb094:         ps.setTime(1, null); // NULL->11:00:00->11:30:00
1:d2cb094:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "11:30:00");
1:ea8303d: 
1:d2cb094:         ps.close();
1:d2cb094:         
1:d2cb094:         ps = prepareStatement("VALUES NOON_CALL(NOON_NOCALL(?))");
1:d2cb094:         ps.setTime(1, tea);
1:d2cb094:         JDBC.assertSingleValueResultSet(ps.executeQuery(), tea.toString());
1:d2cb094:         ps.setTime(1, noon); // noon->NULL->11:00:00
1:d2cb094:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "11:00:00");
1:d2cb094:         ps.setTime(1, null); // NULL->NULL->11:00:00
1:d2cb094:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "11:00:00");
1:d2cb094:         ps.close();
1:d2cb094:         
1:d2cb094:         ps = prepareStatement("VALUES NOON_CALL(NOON_CALL(?))");
1:d2cb094:         ps.setTime(1, tea);
1:d2cb094:         JDBC.assertSingleValueResultSet(ps.executeQuery(), tea.toString());
1:d2cb094:         ps.setTime(1, noon); // noon->NULL->11:00:00
1:d2cb094:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "11:00:00");
1:d2cb094:         ps.setTime(1, null); // NULL->11:00:00->11:30:00
1:d2cb094:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "11:30:00");
1:d2cb094:         ps.close();
1:d8a9518:         
1:ea8303d:         s.close();
1:d8a9518:     }
1:d8a9518:     
1:96e7da9:     /**
1:96e7da9:      * Test function with an aggregate argument. DERBY-3649
1:96e7da9:      * @throws SQLException
1:96e7da9:      */
1:96e7da9:     public void testAggregateArgument() throws SQLException
1:96e7da9:     {
1:96e7da9:     	Statement s = createStatement();
1:96e7da9:     	s.executeUpdate("CREATE TABLE TEST (I INT)");
1:96e7da9:     	s.executeUpdate("INSERT INTO TEST VALUES(1)");
1:96e7da9:     	s.executeUpdate("INSERT INTO TEST VALUES(2)");
1:96e7da9:     	s.executeUpdate("CREATE FUNCTION CheckCount(count integer) RETURNS INTEGER PARAMETER STYLE JAVA NO SQL LANGUAGE JAVA EXTERNAL NAME 'org.apache.derbyTesting.functionTests.tests.lang.RoutineTest.checkCount'");
1:96e7da9:     	ResultSet rs = s.executeQuery("select checkCount(count(*)) from test");
1:96e7da9:     	JDBC.assertSingleValueResultSet(rs, "2");
1:96e7da9:     	
1:96e7da9:     	
1:96e7da9:     }
1:96e7da9:     
1:d8a9518:     /**
1:aec2537:      * Test that we don't get verification errors trying to cram nulls
1:aec2537:      * into primitive args. See DERBY-4459.
1:aec2537:      */
1:aec2537:     public void test_4459() throws Exception
1:aec2537:     {
1:aec2537:     	Statement s = createStatement();
1:aec2537: 
1:aec2537:     	s.executeUpdate
1:aec2537:             (
1:aec2537:              "create function getNullInt() returns int language java parameter style java\n" +
1:aec2537:              "external name '" + RoutineTest.class.getName() + ".getNullInt'"
1:aec2537:              );
1:aec2537:     	s.executeUpdate
1:aec2537:             (
1:aec2537:              "create function negateInt( a int ) returns int language java parameter style java\n" +
1:aec2537:              "external name '" + RoutineTest.class.getName() + ".negateInt'"
1:aec2537:              );
1:aec2537: 
1:aec2537:         assertStatementError( CANNOT_STUFF_NULL_INTO_PRIMITIVE, s, "values( negateInt( cast( null as int) ) )" );
1:aec2537:         assertStatementError( CANNOT_STUFF_NULL_INTO_PRIMITIVE, s, "values( negateInt( getNullInt() ) )" );
1:aec2537:     }
1:aec2537: 
1:eff9169:     /**
1:eff9169:      * DERBY-5749: Too long (non-blank) argument for VARCHAR parameter does not
1:eff9169:      * throw as expected.
1:eff9169:      */
1:eff9169:     public void test_5749() throws SQLException
1:eff9169:     {
1:eff9169:         Statement s = createStatement();
1:eff9169:         s.executeUpdate("create table t5749(v varchar(5))");
1:eff9169:         s.executeUpdate(
1:eff9169:             "create procedure p5749 (a varchar(5)) modifies sql data " +
1:eff9169:             "external name '" + RoutineTest.class.getName() + ".p5749' " +
1:eff9169:             "language java parameter style java");
1:eff9169:         CallableStatement cs = prepareCall("call p5749(?)");
1:eff9169:         cs.setString(1, "123456");
1:eff9169: 
1:eff9169:         // This silently truncates before fix of DERBY-5749
1:eff9169:         try {
1:eff9169:             cs.execute();
1:eff9169:             fail();
1:eff9169:         } catch (SQLException e) {
1:eff9169:             assertSQLState("22001", e);
1:eff9169:         }
1:eff9169: 
1:eff9169:         // This silently truncates also
1:eff9169:         try {
1:eff9169:             s.executeUpdate("call p5749('123456')");
1:eff9169:             fail();
1:eff9169:         } catch (SQLException e) {
1:eff9169:             assertSQLState("22001", e);
1:eff9169:         }
1:eff9169: 
1:eff9169: 
1:eff9169:         PreparedStatement ps = prepareStatement("insert into t5749 values(?)");
1:eff9169:         ps.setString(1, "123456");
1:eff9169:         // This does not truncate
1:eff9169:         try {
1:eff9169:             ps.execute();
1:eff9169:             fail();
1:eff9169:         } catch (SQLException e) {
1:eff9169:             assertSQLState("22001", e);
1:eff9169:         }
1:eff9169:     }
1:eff9169: 
1:d8a9518:     /**
1:8c39c1c:      * DERBY-6511: Make sure that conversions between primitive and wrapper
1:8c39c1c:      * types work properly.
1:8c39c1c:      */
1:8c39c1c:     public void test_6511() throws Exception
1:8c39c1c:     {
1:8c39c1c:         Connection  conn = getConnection();
1:eff9169: 
1:8c39c1c:         vet_6511( conn, "boolean", "booleanpToBoolean", "booleanToBooleanp", "true" );
1:8c39c1c:         vet_6511( conn, "int", "intToInteger", "integerToInt", "1" );
1:8c39c1c:         vet_6511( conn, "bigint", "longpToLong", "longToLongp", "1" );
1:8c39c1c:         vet_6511( conn, "smallint", "shortpToInteger", "integerToShortp", "1" );
1:8c39c1c:         vet_6511( conn, "double", "doublepToDouble", "doubleToDoublep", "1.0" );
1:8c39c1c:         vet_6511( conn, "real", "floatpToFloat", "floatToFloatp", "1.0" );
1:8c39c1c:     }
1:8c39c1c:     private void    vet_6511
1:8c39c1c:         (
1:8c39c1c:          Connection conn,
1:8c39c1c:          String sqlDatatype,
1:8c39c1c:          String primitiveToWrapperName,
1:8c39c1c:          String wrapperToPrimitiveName,
1:8c39c1c:          String dataValue
1:8c39c1c:          )
1:8c39c1c:         throws Exception
1:8c39c1c:     {
1:8c39c1c:         createFunction_6511( conn, sqlDatatype, primitiveToWrapperName );
1:8c39c1c:         createFunction_6511( conn, sqlDatatype, wrapperToPrimitiveName );
1:8c39c1c: 
1:8c39c1c:         vetChaining_6511( conn, primitiveToWrapperName, primitiveToWrapperName, dataValue );
1:8c39c1c:         vetChaining_6511( conn, primitiveToWrapperName, wrapperToPrimitiveName, dataValue );
1:8c39c1c:         vetChaining_6511( conn, wrapperToPrimitiveName, primitiveToWrapperName, dataValue );
1:8c39c1c:         vetChaining_6511( conn, wrapperToPrimitiveName, wrapperToPrimitiveName, dataValue );
1:8c39c1c: 
1:8c39c1c:         dropFunction_6511( conn, primitiveToWrapperName );
1:8c39c1c:         dropFunction_6511( conn, wrapperToPrimitiveName );
1:8c39c1c:     }
1:8c39c1c:     private void    createFunction_6511
1:8c39c1c:         (
1:8c39c1c:          Connection conn,
1:8c39c1c:          String sqlDatatype,
1:8c39c1c:          String functionName
1:8c39c1c:          )
1:8c39c1c:         throws Exception
1:8c39c1c:     {
1:8c39c1c:         goodStatement
1:8c39c1c:             (
1:8c39c1c:              conn,
1:8c39c1c:              "create function " + functionName + "( val " + sqlDatatype + " ) returns " + sqlDatatype + "\n" +
1:8c39c1c:              "language java parameter style java deterministic no sql\n" +
1:8c39c1c:              "external name '" + getClass().getName() + "." + functionName + "'"
1:8c39c1c:              );
1:8c39c1c:     }
1:8c39c1c:     private void    dropFunction_6511
1:8c39c1c:         (
1:8c39c1c:          Connection conn,
1:8c39c1c:          String functionName
1:8c39c1c:          )
1:8c39c1c:         throws Exception
1:8c39c1c:     {
1:8c39c1c:         goodStatement( conn, "drop function " + functionName );
1:8c39c1c:     }
1:8c39c1c:     private void    vetChaining_6511
1:8c39c1c:         (
1:8c39c1c:          Connection conn,
1:8c39c1c:          String innerFunctionName,
1:8c39c1c:          String outerFunctionName,
1:8c39c1c:          String dataValue
1:8c39c1c:          )
1:8c39c1c:         throws Exception
1:8c39c1c:     {
1:8c39c1c:         assertResults
1:8c39c1c:             (
1:8c39c1c:              conn,
1:8c39c1c:              "values " + outerFunctionName + "( " + innerFunctionName + "( " + dataValue + " ) )",
1:8c39c1c:              new String[][]
1:8c39c1c:              {
1:8c39c1c:                  { dataValue },
1:8c39c1c:              },
1:8c39c1c:              false
1:8c39c1c:              );
1:8c39c1c:     }
1:eff9169: 
1:eff9169: 
1:d8a9518:     /*
1:d8a9518:     ** Routine implementations called from the tests but do
1:d8a9518:     *  not use DriverManager so that this test can be used on
1:d8a9518:     *  J2ME/CDC/Foundation with JSR169.
1:d8a9518:     */
1:d8a9518:     
1:d8a9518:     public static String concat(String s1, String s2)
1:d8a9518:     {
1:d8a9518:         if (s1 == null)
1:d8a9518:             s1 = "s1NULL";
1:d8a9518:         if (s2 == null)
1:d8a9518:             s2 = "s2NULL";
1:d8a9518:         return s1.concat(s2);
1:d8a9518:     }
1:d8a9518:     
1:d8a9518:     public static int same(int i)
1:d8a9518:     {
1:d8a9518:         return i;
1:d8a9518:     }
1:d2cb094:     
1:d2cb094:     public static Time nullAtNoon(Time t) {
1:d2cb094:         if (t == null)
1:d2cb094:             return Time.valueOf("11:00:00");
1:d2cb094:         String s = t.toString();
1:d2cb094:         if ("11:00:00".equals(s))
1:d2cb094:             return Time.valueOf("11:30:00");
1:d2cb094:         if ("12:00:00".equals(s))
1:d2cb094:            return null;
1:d2cb094:         
1:d2cb094:         return t;
1:d2cb094:     }
1:96e7da9:     
1:96e7da9: 
1:96e7da9:     public static int checkCount(int count)
1:96e7da9:                throws SQLException {
1:96e7da9:            //   throws ZeroException {
1:96e7da9: 
1:96e7da9:            if (count == 0) {
1:96e7da9:                //throw new ZeroException();
1:96e7da9:                throw new SQLException("No results found", "38777");
1:96e7da9:            }
1:96e7da9: 
1:96e7da9:            return count;
1:96e7da9:        }
1:96e7da9: 
1:aec2537:     public static int negateInt( int arg ) { return -arg; }
1:aec2537:     public static Integer getNullInt() { return null; }
1:aec2537: 
1:eff9169:     public static void p5749 (String s) {
1:eff9169:     }
1:8c39c1c: 
1:8c39c1c:     // functions for converting between primitive and wrapper types
1:8c39c1c:     public  static  Boolean booleanpToBoolean( boolean val )
1:8c39c1c:     {
1:39b3237:         return val;
1:8c39c1c:     }
1:8c39c1c:     public  static  boolean booleanToBooleanp( Boolean val ) throws Exception
1:8c39c1c:     {
1:8c39c1c:         if ( val == null )  { throw new Exception( "This method does not allow nulls!" ); }
1:8c39c1c:         else { return val.booleanValue(); }
1:8c39c1c:     }
1:8c39c1c:     
1:8c39c1c:     public  static  Integer intToInteger( int val )
1:8c39c1c:     {
1:39b3237:         return val;
1:8c39c1c:     }
1:8c39c1c:     public  static  int     integerToInt( Integer val ) throws Exception
1:8c39c1c:     {
1:8c39c1c:         if ( val == null )  { throw new Exception( "This method does not allow nulls!" ); }
1:8c39c1c:         else { return val.intValue(); }
1:8c39c1c:     }
1:8c39c1c:     
1:8c39c1c:     public  static  Long    longpToLong( long val )
1:8c39c1c:     {
1:39b3237:         return val ;
1:8c39c1c:     }
1:8c39c1c:     public  static  long     longToLongp( Long val ) throws Exception
1:8c39c1c:     {
1:8c39c1c:         if ( val == null )  { throw new Exception( "This method does not allow nulls!" ); }
1:8c39c1c:         else { return val.longValue(); }
1:8c39c1c:     }
1:8c39c1c:     
1:8c39c1c:     public  static  Integer    shortpToInteger( short val )
1:8c39c1c:     {
1:39b3237:       return (int) val;
1:8c39c1c:     }
1:8c39c1c:     public  static  short     integerToShortp( Integer val ) throws Exception
1:8c39c1c:     {
1:8c39c1c:         if ( val == null )  { throw new Exception( "This method does not allow nulls!" ); }
1:8c39c1c:         else { return val.shortValue(); }
1:8c39c1c:     }
1:8c39c1c:     
1:8c39c1c:     public  static  Float floatpToFloat( float val )
1:8c39c1c:     {
1:39b3237:         return val;
1:8c39c1c:     }
1:8c39c1c:     public  static  float     floatToFloatp( Float val ) throws Exception
1:8c39c1c:     {
1:8c39c1c:         if ( val == null )  { throw new Exception( "This method does not allow nulls!" ); }
1:8c39c1c:         else { return val.floatValue(); }
1:8c39c1c:     }
1:8c39c1c:     
1:8c39c1c:     public  static  Double doublepToDouble( double val )
1:8c39c1c:     {
1:39b3237:         return val;
1:8c39c1c:     }
1:8c39c1c:     public  static  double     doubleToDoublep( Double val ) throws Exception
1:8c39c1c:     {
1:8c39c1c:         if ( val == null )  { throw new Exception( "This method does not allow nulls!" ); }
1:8c39c1c:         else { return val.doubleValue(); }
1:8c39c1c:     }
1:8c39c1c:     
1:d8a9518: }
1:d8a9518: 
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:39b3237
/////////////////////////////////////////////////////////////////////////
1:         return val;
/////////////////////////////////////////////////////////////////////////
1:         return val;
/////////////////////////////////////////////////////////////////////////
1:         return val ;
/////////////////////////////////////////////////////////////////////////
1:       return (int) val;
/////////////////////////////////////////////////////////////////////////
1:         return val;
/////////////////////////////////////////////////////////////////////////
1:         return val;
commit:8c39c1c
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Connection;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * DERBY-6511: Make sure that conversions between primitive and wrapper
1:      * types work properly.
1:      */
1:     public void test_6511() throws Exception
1:     {
1:         Connection  conn = getConnection();
1:         vet_6511( conn, "boolean", "booleanpToBoolean", "booleanToBooleanp", "true" );
1:         vet_6511( conn, "int", "intToInteger", "integerToInt", "1" );
1:         vet_6511( conn, "bigint", "longpToLong", "longToLongp", "1" );
1:         vet_6511( conn, "smallint", "shortpToInteger", "integerToShortp", "1" );
1:         vet_6511( conn, "double", "doublepToDouble", "doubleToDoublep", "1.0" );
1:         vet_6511( conn, "real", "floatpToFloat", "floatToFloatp", "1.0" );
1:     }
1:     private void    vet_6511
1:         (
1:          Connection conn,
1:          String sqlDatatype,
1:          String primitiveToWrapperName,
1:          String wrapperToPrimitiveName,
1:          String dataValue
1:          )
1:         throws Exception
1:     {
1:         createFunction_6511( conn, sqlDatatype, primitiveToWrapperName );
1:         createFunction_6511( conn, sqlDatatype, wrapperToPrimitiveName );
1: 
1:         vetChaining_6511( conn, primitiveToWrapperName, primitiveToWrapperName, dataValue );
1:         vetChaining_6511( conn, primitiveToWrapperName, wrapperToPrimitiveName, dataValue );
1:         vetChaining_6511( conn, wrapperToPrimitiveName, primitiveToWrapperName, dataValue );
1:         vetChaining_6511( conn, wrapperToPrimitiveName, wrapperToPrimitiveName, dataValue );
1: 
1:         dropFunction_6511( conn, primitiveToWrapperName );
1:         dropFunction_6511( conn, wrapperToPrimitiveName );
1:     }
1:     private void    createFunction_6511
1:         (
1:          Connection conn,
1:          String sqlDatatype,
1:          String functionName
1:          )
1:         throws Exception
1:     {
1:         goodStatement
1:             (
1:              conn,
1:              "create function " + functionName + "( val " + sqlDatatype + " ) returns " + sqlDatatype + "\n" +
1:              "language java parameter style java deterministic no sql\n" +
1:              "external name '" + getClass().getName() + "." + functionName + "'"
1:              );
1:     }
1:     private void    dropFunction_6511
1:         (
1:          Connection conn,
1:          String functionName
1:          )
1:         throws Exception
1:     {
1:         goodStatement( conn, "drop function " + functionName );
1:     }
1:     private void    vetChaining_6511
1:         (
1:          Connection conn,
1:          String innerFunctionName,
1:          String outerFunctionName,
1:          String dataValue
1:          )
1:         throws Exception
1:     {
1:         assertResults
1:             (
1:              conn,
1:              "values " + outerFunctionName + "( " + innerFunctionName + "( " + dataValue + " ) )",
1:              new String[][]
1:              {
1:                  { dataValue },
1:              },
1:              false
1:              );
1:     }
/////////////////////////////////////////////////////////////////////////
1: 
1:     // functions for converting between primitive and wrapper types
1:     public  static  Boolean booleanpToBoolean( boolean val )
1:     {
0:         return new Boolean( val );
1:     }
1:     public  static  boolean booleanToBooleanp( Boolean val ) throws Exception
1:     {
1:         if ( val == null )  { throw new Exception( "This method does not allow nulls!" ); }
1:         else { return val.booleanValue(); }
1:     }
1:     
1:     public  static  Integer intToInteger( int val )
1:     {
0:         return new Integer( val );
1:     }
1:     public  static  int     integerToInt( Integer val ) throws Exception
1:     {
1:         if ( val == null )  { throw new Exception( "This method does not allow nulls!" ); }
1:         else { return val.intValue(); }
1:     }
1:     
1:     public  static  Long    longpToLong( long val )
1:     {
0:         return new Long( val );
1:     }
1:     public  static  long     longToLongp( Long val ) throws Exception
1:     {
1:         if ( val == null )  { throw new Exception( "This method does not allow nulls!" ); }
1:         else { return val.longValue(); }
1:     }
1:     
1:     public  static  Integer    shortpToInteger( short val )
1:     {
0:         return new Integer( val );
1:     }
1:     public  static  short     integerToShortp( Integer val ) throws Exception
1:     {
1:         if ( val == null )  { throw new Exception( "This method does not allow nulls!" ); }
1:         else { return val.shortValue(); }
1:     }
1:     
1:     public  static  Float floatpToFloat( float val )
1:     {
0:         return new Float( val );
1:     }
1:     public  static  float     floatToFloatp( Float val ) throws Exception
1:     {
1:         if ( val == null )  { throw new Exception( "This method does not allow nulls!" ); }
1:         else { return val.floatValue(); }
1:     }
1:     
1:     public  static  Double doublepToDouble( double val )
1:     {
0:         return new Double( val );
1:     }
1:     public  static  double     doubleToDoublep( Double val ) throws Exception
1:     {
1:         if ( val == null )  { throw new Exception( "This method does not allow nulls!" ); }
1:         else { return val.doubleValue(); }
1:     }
1:     
commit:aec2537
/////////////////////////////////////////////////////////////////////////
1:     private static final String CANNOT_STUFF_NULL_INTO_PRIMITIVE = "39004";
1:     
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Test that we don't get verification errors trying to cram nulls
1:      * into primitive args. See DERBY-4459.
1:      */
1:     public void test_4459() throws Exception
1:     {
1:     	Statement s = createStatement();
1: 
1:     	s.executeUpdate
1:             (
1:              "create function getNullInt() returns int language java parameter style java\n" +
1:              "external name '" + RoutineTest.class.getName() + ".getNullInt'"
1:              );
1:     	s.executeUpdate
1:             (
1:              "create function negateInt( a int ) returns int language java parameter style java\n" +
1:              "external name '" + RoutineTest.class.getName() + ".negateInt'"
1:              );
1: 
1:         assertStatementError( CANNOT_STUFF_NULL_INTO_PRIMITIVE, s, "values( negateInt( cast( null as int) ) )" );
1:         assertStatementError( CANNOT_STUFF_NULL_INTO_PRIMITIVE, s, "values( negateInt( getNullInt() ) )" );
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
1:     public static int negateInt( int arg ) { return -arg; }
1:     public static Integer getNullInt() { return null; }
1:     
commit:ec60795
/////////////////////////////////////////////////////////////////////////
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), null);        
commit:057ae46
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Test that function result data types are resolved correctly for numeric
1:      * types that Derby supports that are simply mappable or object mappable.
1:      */
1:     public void testFunctionResultDataTypeValidation() throws SQLException
1:     {
1:         Statement s = createStatement();
1: 
1:         // SMALLINT -> short
1:         s.executeUpdate(
1:         "CREATE FUNCTION SMALLINT_P_SHORT(VARCHAR(10)) RETURNS SMALLINT " +
1:            "EXTERNAL NAME 'java.lang.Short.parseShort' " +
1:            "LANGUAGE JAVA PARAMETER STYLE JAVA");
1: 
1:         PreparedStatement ps = prepareStatement("VALUES SMALLINT_P_SHORT(?)");
1:         ps.setString(1, "123");
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "123");  
1: 
1:         // SMALLINT -> Integer
1:         s.executeUpdate(
1:         "CREATE FUNCTION SMALLINT_O_INTEGER(VARCHAR(10)) RETURNS SMALLINT " +
1:            "EXTERNAL NAME 'java.lang.Integer.valueOf' " +
1:            "LANGUAGE JAVA PARAMETER STYLE JAVA");
1: 
1:         ps = prepareStatement("VALUES SMALLINT_O_INTEGER(?)");
1:         ps.setString(1, "123");
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "123");  
1: 
1:         // INTEGER -> int
1:         s.executeUpdate(
1:         "CREATE FUNCTION INTEGER_P_INT(VARCHAR(10)) RETURNS INTEGER " +
1:            "EXTERNAL NAME 'java.lang.Integer.parseInt' " +
1:            "LANGUAGE JAVA PARAMETER STYLE JAVA");
1: 
1:         ps = prepareStatement("VALUES INTEGER_P_INT(?)");
1:         ps.setString(1, "123");
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "123");  
1: 
1:         // INTEGER -> Integer
1:         s.executeUpdate(
1:         "CREATE FUNCTION INTEGER_O_INTEGER(VARCHAR(10)) RETURNS INTEGER " +
1:            "EXTERNAL NAME 'java.lang.Integer.valueOf' " +
1:            "LANGUAGE JAVA PARAMETER STYLE JAVA");
1: 
1:         ps = prepareStatement("VALUES INTEGER_O_INTEGER(?)");
1:         ps.setString(1, "123");
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "123");  
1: 
1:         // BIGINT -> long
1:         s.executeUpdate(
1:         "CREATE FUNCTION BIGINT_P_LONG(VARCHAR(10)) RETURNS BIGINT " +
1:            "EXTERNAL NAME 'java.lang.Long.parseLong' " +
1:            "LANGUAGE JAVA PARAMETER STYLE JAVA");
1: 
1:         ps = prepareStatement("VALUES BIGINT_P_LONG(?)");
1:         ps.setString(1, "123");
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "123");  
1: 
1:         // BIGINT -> Long
1:         s.executeUpdate(
1:         "CREATE FUNCTION BIGINT_O_LONG(VARCHAR(10)) RETURNS BIGINT " +
1:            "EXTERNAL NAME 'java.lang.Long.valueOf' " +
1:            "LANGUAGE JAVA PARAMETER STYLE JAVA");
1: 
1:         ps = prepareStatement("VALUES BIGINT_O_LONG(?)");
1:         ps.setString(1, "123");
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "123");  
1: 
1:         // REAL -> float
1:         s.executeUpdate(
1:         "CREATE FUNCTION REAL_P_FLOAT(VARCHAR(10)) RETURNS REAL " +
1:            "EXTERNAL NAME 'java.lang.Float.parseFloat' " +
1:            "LANGUAGE JAVA PARAMETER STYLE JAVA");
1: 
1:         ps = prepareStatement("VALUES REAL_P_FLOAT(?)");
1:         ps.setString(1, "123.0");
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "123.0");  
1: 
1:         // REAL -> Float
1:         s.executeUpdate(
1:         "CREATE FUNCTION REAL_O_FLOAT(VARCHAR(10)) RETURNS REAL " +
1:            "EXTERNAL NAME 'java.lang.Float.valueOf' " +
1:            "LANGUAGE JAVA PARAMETER STYLE JAVA");
1: 
1:         ps = prepareStatement("VALUES REAL_O_FLOAT(?)");
1:         ps.setString(1, "123.0");
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "123.0");  
1: 
1:         // DOUBLE -> double
1:         s.executeUpdate(
1:         "CREATE FUNCTION DOUBLE_P_DOUBLE(VARCHAR(10)) RETURNS DOUBLE " +
1:            "EXTERNAL NAME 'java.lang.Double.parseDouble' " +
1:            "LANGUAGE JAVA PARAMETER STYLE JAVA");
1: 
1:         ps = prepareStatement("VALUES DOUBLE_P_DOUBLE(?)");
1:         ps.setString(1, "123.0");
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "123.0");  
1: 
1:         // DOBULE -> Double
1:         s.executeUpdate(
1:         "CREATE FUNCTION DOUBLE_O_DOUBLE(VARCHAR(10)) RETURNS DOUBLE " +
1:            "EXTERNAL NAME 'java.lang.Double.valueOf' " +
1:            "LANGUAGE JAVA PARAMETER STYLE JAVA");
1: 
1:         ps = prepareStatement("VALUES DOUBLE_O_DOUBLE(?)");
1:         ps.setString(1, "123.0");
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "123.0");
1:         
1:         ps.close();
1:         s.close();
1:     }
1:     
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.BaseTestSuite;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite =
1:             new BaseTestSuite(RoutineTest.class, "RoutineTest");
commit:eff9169
/////////////////////////////////////////////////////////////////////////
1: import java.sql.CallableStatement;
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * DERBY-5749: Too long (non-blank) argument for VARCHAR parameter does not
1:      * throw as expected.
1:      */
1:     public void test_5749() throws SQLException
1:     {
1:         Statement s = createStatement();
1:         s.executeUpdate("create table t5749(v varchar(5))");
1:         s.executeUpdate(
1:             "create procedure p5749 (a varchar(5)) modifies sql data " +
1:             "external name '" + RoutineTest.class.getName() + ".p5749' " +
1:             "language java parameter style java");
1:         CallableStatement cs = prepareCall("call p5749(?)");
1:         cs.setString(1, "123456");
1: 
1:         // This silently truncates before fix of DERBY-5749
1:         try {
1:             cs.execute();
1:             fail();
1:         } catch (SQLException e) {
1:             assertSQLState("22001", e);
1:         }
1: 
1:         // This silently truncates also
1:         try {
1:             s.executeUpdate("call p5749('123456')");
1:             fail();
1:         } catch (SQLException e) {
1:             assertSQLState("22001", e);
1:         }
1: 
1: 
1:         PreparedStatement ps = prepareStatement("insert into t5749 values(?)");
1:         ps.setString(1, "123456");
1:         // This does not truncate
1:         try {
1:             ps.execute();
1:             fail();
1:         } catch (SQLException e) {
1:             assertSQLState("22001", e);
1:         }
1:     }
1: 
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     public static void p5749 (String s) {
1:     }
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:0a6ce0b
/////////////////////////////////////////////////////////////////////////
1:      * Test that RETURNS NULL ON NULL INPUT works properly with 
1:      * numeric datatypes for null and non-null values.
1:      */
1:     public void testFunctionReturnsNullOnNullInput() throws SQLException
1:     {
1:         Statement s = createStatement();
1: 
1:         // SMALLINT -> short
1:         s.executeUpdate(
1:         "CREATE FUNCTION SMALLINT_P_SHORT_RN(VARCHAR(10)) RETURNS SMALLINT " +
1:            "EXTERNAL NAME 'java.lang.Short.parseShort' " +
1:            "LANGUAGE JAVA PARAMETER STYLE JAVA " +
1:            "RETURNS NULL ON NULL INPUT");
1: 
1:         PreparedStatement ps = prepareStatement("VALUES SMALLINT_P_SHORT_RN(?)");
1:         ps.setString(1, "123");
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "123");  
1: 
1:         ps.setString(1,null);
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), null);
1:         // SMALLINT -> Integer
1:         s.executeUpdate(
1:         "CREATE FUNCTION SMALLINT_O_INTEGER_RN(VARCHAR(10)) RETURNS SMALLINT " +
1:            "EXTERNAL NAME 'java.lang.Integer.valueOf' " +
1:            "LANGUAGE JAVA PARAMETER STYLE JAVA " +
1:            "RETURNS NULL ON NULL INPUT");
1: 
1:         ps = prepareStatement("VALUES SMALLINT_O_INTEGER_RN(?)");
1:         ps.setString(1, "123");
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "123");  
1: 
1:         ps.setString(1, null);
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), null);
1:         // INTEGER -> int
1:         s.executeUpdate(
1:         "CREATE FUNCTION INTEGER_P_INT_RN(VARCHAR(10)) RETURNS INTEGER " +
1:            "EXTERNAL NAME 'java.lang.Integer.parseInt' " +
1:            "LANGUAGE JAVA PARAMETER STYLE JAVA " +
1:            "RETURNS NULL ON NULL INPUT");
1: 
1:         ps = prepareStatement("VALUES INTEGER_P_INT_RN(?)");
1:         ps.setString(1, "123");
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "123");  
1: 
1:         // INTEGER -> Integer
1:         s.executeUpdate(
1:         "CREATE FUNCTION INTEGER_O_INTEGER_RN(VARCHAR(10)) RETURNS INTEGER " +
1:            "EXTERNAL NAME 'java.lang.Integer.valueOf' " +
1:            "LANGUAGE JAVA PARAMETER STYLE JAVA " +
1:            "RETURNS NULL ON NULL INPUT");
1: 
1:         ps = prepareStatement("VALUES INTEGER_O_INTEGER_RN(?)");
1:         ps.setString(1, "123");
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "123");  
1:         ps.setString(1, null);
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), null);
1:         // BIGINT -> long
1:         s.executeUpdate(
1:         "CREATE FUNCTION BIGINT_P_LONG_RN(VARCHAR(10)) RETURNS BIGINT " +
1:            "EXTERNAL NAME 'java.lang.Long.parseLong' " +
1:            "LANGUAGE JAVA PARAMETER STYLE JAVA " +
1:            "RETURNS NULL ON NULL INPUT");
1: 
1:         ps = prepareStatement("VALUES BIGINT_P_LONG_RN(?)");
1:         ps.setString(1, "123");
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "123");  
1:         ps.setString(1, null);
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), null);
1:         // BIGINT -> Long
1:         s.executeUpdate(
1:         "CREATE FUNCTION BIGINT_O_LONG_NR(VARCHAR(10)) RETURNS BIGINT " +
1:            "EXTERNAL NAME 'java.lang.Long.valueOf' " +
1:            "LANGUAGE JAVA PARAMETER STYLE JAVA " +
1:            "RETURNS NULL ON NULL INPUT");
1: 
1:         ps = prepareStatement("VALUES BIGINT_O_LONG_NR(?)");
1:         ps.setString(1, "123");
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "123");  
1:         ps.setString(1, null);
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), null);
1:         // REAL -> float
1:         s.executeUpdate(
1:         "CREATE FUNCTION REAL_P_FLOAT_NR(VARCHAR(10)) RETURNS REAL " +
1:            "EXTERNAL NAME 'java.lang.Float.parseFloat' " +
1:            "LANGUAGE JAVA PARAMETER STYLE JAVA " +
1:            "RETURNS NULL ON NULL INPUT");
1: 
1:         ps = prepareStatement("VALUES REAL_P_FLOAT_NR(?)");
1:         ps.setString(1, "123.0");
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "123.0");  
1:         ps.setString(1, null);
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), null);
1:         
1:         // REAL -> Float
1:         s.executeUpdate(
1:         "CREATE FUNCTION REAL_O_FLOAT_NR(VARCHAR(10)) RETURNS REAL " +
1:            "EXTERNAL NAME 'java.lang.Float.valueOf' " +
1:            "LANGUAGE JAVA PARAMETER STYLE JAVA " +
1:            "RETURNS NULL ON NULL INPUT");
1: 
1:         ps = prepareStatement("VALUES REAL_O_FLOAT_NR(?)");
1:         ps.setString(1, "123.0");
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "123.0");  
1:         ps.setString(1, null);
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), null);
1:         
1:         // DOUBLE -> double
1:         s.executeUpdate(
1:         "CREATE FUNCTION DOUBLE_P_DOUBLE_NR(VARCHAR(10)) RETURNS DOUBLE " +
1:            "EXTERNAL NAME 'java.lang.Double.parseDouble' " +
1:            "LANGUAGE JAVA PARAMETER STYLE JAVA " +
1:            "RETURNS NULL ON NULL INPUT");
1: 
1:         ps = prepareStatement("VALUES DOUBLE_P_DOUBLE_NR(?)");
1:         ps.setString(1, "123.0");
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "123.0");  
1:         ps.setString(1, null);
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), null);
1:         
1:         // DOBULE -> Double
1:         s.executeUpdate(
1:         "CREATE FUNCTION DOUBLE_O_DOUBLE_NR(VARCHAR(10)) RETURNS DOUBLE " +
1:            "EXTERNAL NAME 'java.lang.Double.valueOf' " +
1:            "LANGUAGE JAVA PARAMETER STYLE JAVA " +
1:            "RETURNS NULL ON NULL INPUT");
1: 
1:         ps = prepareStatement("VALUES DOUBLE_O_DOUBLE_NR(?)");
1:         ps.setString(1, "123.0");
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "123.0");
1:         ps.setString(1, null);
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), null);
1:         
1:         ps.close();
1:         s.close();
1:     }
1:     
1:     /**
commit:96e7da9
/////////////////////////////////////////////////////////////////////////
1: import java.sql.ResultSet;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Test function with an aggregate argument. DERBY-3649
1:      * @throws SQLException
1:      */
1:     public void testAggregateArgument() throws SQLException
1:     {
1:     	Statement s = createStatement();
1:     	s.executeUpdate("CREATE TABLE TEST (I INT)");
1:     	s.executeUpdate("INSERT INTO TEST VALUES(1)");
1:     	s.executeUpdate("INSERT INTO TEST VALUES(2)");
1:     	s.executeUpdate("CREATE FUNCTION CheckCount(count integer) RETURNS INTEGER PARAMETER STYLE JAVA NO SQL LANGUAGE JAVA EXTERNAL NAME 'org.apache.derbyTesting.functionTests.tests.lang.RoutineTest.checkCount'");
1:     	ResultSet rs = s.executeQuery("select checkCount(count(*)) from test");
1:     	JDBC.assertSingleValueResultSet(rs, "2");
1:     	
1:     	
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
1:     
1: 
1:     public static int checkCount(int count)
1:                throws SQLException {
1:            //   throws ZeroException {
1: 
1:            if (count == 0) {
1:                //throw new ZeroException();
1:                throw new SQLException("No results found", "38777");
1:            }
1: 
1:            return count;
1:        }
1: 
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:ea8303d
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Statement;
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement();
1:         
1:         s.executeUpdate(
1:            "LANGUAGE JAVA PARAMETER STYLE JAVA");
1:         s.executeUpdate("CREATE FUNCTION SV_CALL(INTEGER) RETURNS VARCHAR(10) " +
1:           "LANGUAGE JAVA PARAMETER STYLE JAVA");
1:         s.executeUpdate("CREATE FUNCTION SV_DEFAULT(INTEGER) RETURNS VARCHAR(10) " +
1:           "LANGUAGE JAVA PARAMETER STYLE JAVA");
/////////////////////////////////////////////////////////////////////////
1:         s.executeUpdate(
1:                    "LANGUAGE JAVA PARAMETER STYLE JAVA");
1:          s.executeUpdate(
1:                    "LANGUAGE JAVA PARAMETER STYLE JAVA");
/////////////////////////////////////////////////////////////////////////
1:         s.executeUpdate(
1:                    "LANGUAGE JAVA PARAMETER STYLE JAVA");
1:         
1:         s.executeUpdate(
1:                    "LANGUAGE JAVA PARAMETER STYLE JAVA");
/////////////////////////////////////////////////////////////////////////
1:         s.executeUpdate(
1:                    "LANGUAGE JAVA PARAMETER STYLE JAVA");
1:         
1:         s.executeUpdate(
1:                    "LANGUAGE JAVA PARAMETER STYLE JAVA");
/////////////////////////////////////////////////////////////////////////
1:         
1:         s.close();
commit:d2cb094
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Time;
/////////////////////////////////////////////////////////////////////////
1: 
0:         errors = runSQLCommands(
1:                 "CREATE FUNCTION NOON_NOCALL(TIME) " +
1:                    "RETURNS TIME " +
1:                    "RETURNS NULL ON NULL INPUT " +
1:                    "EXTERNAL NAME '" +
1:                    RoutineTest.class.getName() + ".nullAtNoon'  " +
0:                    "LANGUAGE JAVA PARAMETER STYLE JAVA; " +
1:                 "CREATE FUNCTION NOON_CALL(TIME) " +
1:                    "RETURNS TIME " +
1:                    "CALLED ON NULL INPUT " +
1:                    "EXTERNAL NAME '" +
1:                    RoutineTest.class.getName() + ".nullAtNoon'  " +
0:                    "LANGUAGE JAVA PARAMETER STYLE JAVA; "
1:                    
0:         );  
0:         assertEquals("errors running DDL", 0, errors);
1:         // Function maps:
1:         // NULL to 11:00:00 (if null can be passed)
1:         // 11:00:00 to 11:30:00
1:         // 12:00:00 to NULL
1:         // any other time to itself
1:         
1:         Time noon = Time.valueOf("12:00:00"); // mapped to null by the function
1:         Time tea = Time.valueOf("15:30:00");
1:         
1:         ps = prepareStatement("VALUES NOON_NOCALL(?)");
1:         ps.setTime(1, tea);
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), tea.toString());
1:         ps.setTime(1, noon);
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), null);
1:         ps.setTime(1, null);
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), null);
1:         ps.close();
1: 
1:         ps = prepareStatement("VALUES NOON_CALL(?)");
1:         ps.setTime(1, tea);
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), tea.toString());
1:         ps.setTime(1, noon);
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), null);
1:         ps.setTime(1, null);
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "11:00:00");
1:         ps.close();
1:         
1:         // All the nested calls in these cases take take the
1:         // value 'tea' will return the same value.
1:         
1:         ps = prepareStatement("VALUES NOON_NOCALL(NOON_NOCALL(?))");
1:         ps.setTime(1, tea);
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), tea.toString());
1:         ps.setTime(1, noon); // noon->NULL->NULL
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), null);
1:         ps.setTime(1, null); // NULL->NULL->NULL
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), null);
1:         ps.close();
1:         
1:         ps = prepareStatement("VALUES NOON_NOCALL(NOON_CALL(?))");
1:         ps.setTime(1, tea);
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), tea.toString());
1:                
1:         // DERBY-1030 RESULT SHOULD BE NULL
1:         // noon->NULL by inner function
1:         // NULL->NULL by outer due to RETURN NULL ON NULL INPUT
1:         ps.setTime(1, noon); // noon->NULL->NULL
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "11:00:00");        
1:         ps.setTime(1, null); // NULL->11:00:00->11:30:00
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "11:30:00");
1: 
1:         ps.close();
1:         
1:         ps = prepareStatement("VALUES NOON_CALL(NOON_NOCALL(?))");
1:         ps.setTime(1, tea);
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), tea.toString());
1:         ps.setTime(1, noon); // noon->NULL->11:00:00
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "11:00:00");
1:         ps.setTime(1, null); // NULL->NULL->11:00:00
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "11:00:00");
1:         ps.close();
1:         
1:         ps = prepareStatement("VALUES NOON_CALL(NOON_CALL(?))");
1:         ps.setTime(1, tea);
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), tea.toString());
1:         ps.setTime(1, noon); // noon->NULL->11:00:00
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "11:00:00");
1:         ps.setTime(1, null); // NULL->11:00:00->11:30:00
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "11:30:00");
1:         ps.close();
/////////////////////////////////////////////////////////////////////////
1:     
1:     public static Time nullAtNoon(Time t) {
1:         if (t == null)
1:             return Time.valueOf("11:00:00");
1:         String s = t.toString();
1:         if ("11:00:00".equals(s))
1:             return Time.valueOf("11:30:00");
1:         if ("12:00:00".equals(s))
1:            return null;
1:         
1:         return t;
1:     }
commit:d8a9518
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derbyTesting.functionTests.tests.lang.RoutineTest
1: 
1:        Licensed to the Apache Software Foundation (ASF) under one
1:        or more contributor license agreements.  See the NOTICE file
1:        distributed with this work for additional information
1:        regarding copyright ownership.  The ASF licenses this file
1:        to you under the Apache License, Version 2.0 (the
1:        "License"); you may not use this file except in compliance
1:        with the License.  You may obtain a copy of the License at
1: 
1:          http://www.apache.org/licenses/LICENSE-2.0
1: 
1:        Unless required by applicable law or agreed to in writing,
1:        software distributed under the License is distributed on an
1:        "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:        KIND, either express or implied.  See the License for the
1:        specific language governing permissions and limitations
1:        under the License
1: */
1: package org.apache.derbyTesting.functionTests.tests.lang;
1: 
1: import java.io.UnsupportedEncodingException;
1: import java.sql.PreparedStatement;
1: import java.sql.SQLException;
1: import java.sql.Types;
1: 
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: 
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1: import org.apache.derbyTesting.junit.JDBC;
1: 
1: /**
1:  * Set of tests for SQL routines.
1:  * This tests mainly the SQL definition of routines
1:  * and the server-side behaviour of routines.
1:  * Calling of procedures is tested in ProcedureTest.
1:  *
1:  */
1: public class RoutineTest extends BaseJDBCTestCase {
1: 
1:     public RoutineTest(String name)
1:     {
1:         super(name);
1:     }
1:     
1:     public static Test suite() {
0:         TestSuite suite = new TestSuite(RoutineTest.class, "RoutineTest");
1:         
1:         return new CleanDatabaseTestSetup(suite);
1:     }
1:     
1:     /**
1:      * Test that functions handle being called or not called
1:      * when it is passed a NULL argument correctly.
1:      * A function can be declared:
1:      * RETURNS NULL ON NULL INPUT - any argument being NULL means the
1:      * function is returns NULL without being called.
1:      * CALLED ON NULL INPUT (default) - function is always called regardless
1:      * of any arguement being NULL.
1:      */
1:     public void testFunctionNullHandling() throws SQLException, UnsupportedEncodingException
1:     {
1:         // Create three simple functions that take an integer and
1:         // return its value as a VARCHAR().
0:         int errors = runSQLCommands(
1:         "CREATE FUNCTION SV_NOCALL(INTEGER) RETURNS VARCHAR(10) " +
1:            "RETURNS NULL ON NULL INPUT " +
1:            "EXTERNAL NAME 'java.lang.String.valueOf'  " +
0:            "LANGUAGE JAVA PARAMETER STYLE JAVA; " +
1:            
0:         "CREATE FUNCTION SV_CALL(INTEGER) RETURNS VARCHAR(10) " +
1:           "CALLED ON NULL INPUT " +
1:           "EXTERNAL NAME 'java.lang.String.valueOf' " +
0:           "LANGUAGE JAVA PARAMETER STYLE JAVA; " +
1:           
0:         "CREATE FUNCTION SV_DEFAULT(INTEGER) RETURNS VARCHAR(10) " +
1:           "EXTERNAL NAME 'java.lang.String.valueOf' " +
0:           "LANGUAGE JAVA PARAMETER STYLE JAVA; ");
1:         
0:         assertEquals("errors running DDL", 0, errors);
1:         
1:         // Simple cases of calling each function individually
1:         // Test each function with non-NULL and NULL values.
1:         PreparedStatement ps = prepareStatement("VALUES SV_NOCALL(?)");
1:         ps.setInt(1, 42);
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "42");  
1:         ps.setNull(1, Types.INTEGER);
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), null);
1:         ps.close();
1:         
1:         
1:         ps = prepareStatement("VALUES SV_CALL(?)");
1:         ps.setInt(1, 52);
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "52"); 
1:         
1:         // NULL will attempt to call the function but be blocked
1:         // because the Java parameter is a primitive. Since
1:         // the call attempt it made it is enough to show the
1:         // correct behaviour.
1:         ps.setNull(1, Types.INTEGER);
1:         assertStatementError("39004", ps);
1:         
1:         ps.close();
1:         
1:         // Default behaviour maps to CALLED ON NULL INPUT
1:         ps = prepareStatement("VALUES SV_DEFAULT(?)");
1:         ps.setInt(1, 62);
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "62");
1:         ps.setNull(1, Types.INTEGER);
1:         assertStatementError("39004", ps);
1:         ps.close();
1:         
1:         // Test that any single argument being null causes NULL to be returned.
0:         errors = runSQLCommands(
1:                 "CREATE FUNCTION CONCAT_NOCALL(VARCHAR(10), VARCHAR(10)) " +
1:                    "RETURNS VARCHAR(20) " +
1:                    "RETURNS NULL ON NULL INPUT " +
1:                    "EXTERNAL NAME '" +
1:                    RoutineTest.class.getName() + ".concat'  " +
0:                    "LANGUAGE JAVA PARAMETER STYLE JAVA; " +
1:                 "CREATE FUNCTION CONCAT_CALL(VARCHAR(10), VARCHAR(10)) " +
1:                    "RETURNS VARCHAR(20) " +
1:                    "CALLED ON NULL INPUT " +
1:                    "EXTERNAL NAME '" +
1:                    RoutineTest.class.getName() + ".concat'  " +
0:                    "LANGUAGE JAVA PARAMETER STYLE JAVA; "
1:                    
0:         );  
0:         assertEquals("errors running DDL", 0, errors);
1:         
1:         ps = prepareStatement("VALUES CONCAT_NOCALL(?, ?)");
1:         ps.setString(1, "good");
1:         ps.setString(2, "bye");
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "goodbye");
1:         
1:         ps.setString(1, null);
1:         ps.setString(2, "bye");
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), null);
1: 
1:         ps.setString(1, "good");
1:         ps.setString(2, null);
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), null);
1:         
1:         ps.setString(1, null);
1:         ps.setString(2, null);
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), null);
1:         
1:         ps.close();
1: 
1:         ps = prepareStatement("VALUES CONCAT_CALL(?, ?)");
1:         ps.setString(1, "good");
1:         ps.setString(2, "bye");
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "goodbye");
1:         
1:         ps.setString(1, null);
1:         ps.setString(2, "bye");
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "s1NULLbye");
1: 
1:         ps.setString(1, "good");
1:         ps.setString(2, null);
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "goods2NULL");
1:         
1:         ps.setString(1, null);
1:         ps.setString(2, null);
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "s1NULLs2NULL");
1:         
1:         ps.close();
1:         
1:         // Now nested calls
1:         ps = prepareStatement(
1:           "VALUES CONCAT_NOCALL(CONCAT_NOCALL(?, 'RNNI'), CONCAT_CALL(?, 'CONI'))");
1:         
1:         ps.setString(1, "p1");
1:         ps.setString(2, "p2");
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "p1RNNIp2CONI");
1:         
1:         ps.setString(1, null);
1:         ps.setString(2, "p2");
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), null);
1:         
1:         ps.setString(1, "p1");
1:         ps.setString(2, null);
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "p1RNNIs1NULLCONI");
1:         
1:         ps.setString(1, null);
1:         ps.setString(2, null);
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), null);
1:         ps.close();
1: 
1:         ps = prepareStatement(
1:           "VALUES CONCAT_CALL(CONCAT_NOCALL(?, 'RNNI'), CONCAT_CALL(?, 'CONI'))");
1:       
1:         ps.setString(1, "p1");
1:         ps.setString(2, "p2");
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "p1RNNIp2CONI");
1:       
1:         ps.setString(1, null);
1:         ps.setString(2, "p2");
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "s1NULLp2CONI");
1:       
1:         ps.setString(1, "p1");
1:         ps.setString(2, null);
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "p1RNNIs1NULLCONI");
1:       
1:         ps.setString(1, null);
1:         ps.setString(2, null);
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "s1NULLs1NULLCONI");
1:         ps.close();
1: 
1:         
1:         // Nested calls with SQL types that do not need casts
1:         // and map to primitive types. This had issues see DERBY-479
0:         errors = runSQLCommands(
1:                 "CREATE FUNCTION SAME_NOCALL(INTEGER) " +
1:                    "RETURNS INTEGER " +
1:                    "RETURNS NULL ON NULL INPUT " +
1:                    "EXTERNAL NAME '" +
1:                    RoutineTest.class.getName() + ".same'  " +
0:                    "LANGUAGE JAVA PARAMETER STYLE JAVA; " +
1:                 "CREATE FUNCTION SAME_CALL(INTEGER) " +
1:                    "RETURNS INTEGER " +
1:                    "CALLED ON NULL INPUT " +
1:                    "EXTERNAL NAME '" +
1:                    RoutineTest.class.getName() + ".same'  " +
0:                    "LANGUAGE JAVA PARAMETER STYLE JAVA; "
1:                    
0:         );  
0:         assertEquals("errors running DDL", 0, errors);
1:         
1:         ps = prepareStatement("VALUES SAME_NOCALL(SAME_NOCALL(?))");
1:         ps.setInt(1, 41);
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "41");
1:         ps.setNull(1, Types.INTEGER);
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), null);
1:         ps.close();
1:         
1:         ps = prepareStatement("VALUES SAME_NOCALL(SAME_CALL(?))");
1:         ps.setInt(1, 47);
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "47");
1:         ps.setNull(1, Types.INTEGER);
1:         assertStatementError("39004", ps); // Can't pass NULL into primitive type
1:         ps.close();
1: 
1:         ps = prepareStatement("VALUES SAME_CALL(SAME_NOCALL(?))");
1:         ps.setInt(1, 41);
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "41");
1:         ps.setNull(1, Types.INTEGER);
1:         assertStatementError("39004", ps); // Can't pass NULL into primitive type
1:         ps.close();
1: 
1:         ps = prepareStatement("VALUES SAME_CALL(SAME_CALL(?))");
1:         ps.setInt(1, 53);
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "53");
1:         ps.setNull(1, Types.INTEGER);
1:         assertStatementError("39004", ps); // Can't pass NULL into primitive type
1:         ps.close();
1:         
1:     }
1:     
1:     /*
1:     ** Routine implementations called from the tests but do
1:     *  not use DriverManager so that this test can be used on
1:     *  J2ME/CDC/Foundation with JSR169.
1:     */
1:     
1:     public static String concat(String s1, String s2)
1:     {
1:         if (s1 == null)
1:             s1 = "s1NULL";
1:         if (s2 == null)
1:             s2 = "s2NULL";
1:         return s1.concat(s2);
1:     }
1:     
1:     public static int same(int i)
1:     {
1:         return i;
1:     }
1: }
1: 
============================================================================