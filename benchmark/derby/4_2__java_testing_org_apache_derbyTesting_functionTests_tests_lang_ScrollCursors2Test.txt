2:026fbdd: /**
1:026fbdd:  *  Derby - Class org.apache.derbyTesting.functionTests.tests.lang.ScrollCursors2Test
2:026fbdd:  *  
1:026fbdd:  * Licensed to the Apache Software Foundation (ASF) under one
1:026fbdd:  * or more contributor license agreements.  See the NOTICE file
1:026fbdd:  * distributed with this work for additional information
1:026fbdd:  * regarding copyright ownership.  The ASF licenses this file
1:026fbdd:  * to you under the Apache License, Version 2.0 (the
1:026fbdd:  * "License"); you may not use this file except in compliance
1:026fbdd:  * with the License.  You may obtain a copy of the License at
1:026fbdd:  *
1:026fbdd:  *   http://www.apache.org/licenses/LICENSE-2.0
1:026fbdd:  *
1:026fbdd:  * Unless required by applicable law or agreed to in writing,
1:026fbdd:  * software distributed under the License is distributed on an
1:026fbdd:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:026fbdd:  * KIND, either express or implied.  See the License for the
1:026fbdd:  * specific language governing permissions and limitations
1:026fbdd:  * under the License.
2:026fbdd:  */
4:026fbdd: 
1:026fbdd: package org.apache.derbyTesting.functionTests.tests.lang;
1:026fbdd: 
1:026fbdd: import java.sql.CallableStatement;
1:026fbdd: import java.sql.Connection;
1:026fbdd: import java.sql.PreparedStatement;
1:026fbdd: import java.sql.ResultSet;
1:026fbdd: import java.sql.ResultSetMetaData;
1:026fbdd: import java.sql.SQLException;
1:026fbdd: import java.sql.SQLWarning;
1:026fbdd: import java.sql.Statement;
1:026fbdd: 
1:026fbdd: import junit.framework.Test;
1:026fbdd: 
1:026fbdd: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:026fbdd: import org.apache.derbyTesting.junit.JDBC;
1:026fbdd: import org.apache.derbyTesting.junit.TestConfiguration;
1:026fbdd: 
1:026fbdd: public class ScrollCursors2Test extends BaseJDBCTestCase {
1:026fbdd: 
1:026fbdd:     public ScrollCursors2Test(String name) {
1:026fbdd:         super(name);
1:026fbdd: 
1:026fbdd:     }
1:026fbdd: 
1:026fbdd:     private static boolean isDerbyNetClient = usingDerbyNetClient();
1:026fbdd: 
1:026fbdd:     /**
1:026fbdd:      * Set up the test.
1:026fbdd:      * 
1:026fbdd:      * This method creates the table used by the rest of the test.
1:026fbdd:      * 
1:026fbdd:      * 
2:026fbdd:      * @exception SQLException
2:026fbdd:      *                Thrown if some unexpected error happens
1:026fbdd:      */
1:026fbdd: 
1:026fbdd:     public void setUp() throws SQLException {
1:026fbdd: 
1:026fbdd:         Statement s_i_r;
1:026fbdd: 
1:00364eb:         s_i_r = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
1:026fbdd:                 ResultSet.CONCUR_READ_ONLY);
1:026fbdd: 
1:026fbdd:         /* Create a table */
1:026fbdd:         s_i_r.execute("create table t (i int, c50 char(50))");
1:026fbdd: 
1:026fbdd:         /* Populate the table */
1:026fbdd:         s_i_r.execute("insert into t (i) values (2), (3), (4), (5), (6)");
1:026fbdd:         s_i_r.execute("update t set c50 = RTRIM(CAST (i AS CHAR(50)))");
1:026fbdd:         s_i_r.close();
1:026fbdd:         isDerbyNetClient = usingDerbyNetClient();
1:026fbdd:     }
1:026fbdd: 
1:026fbdd:     public void tearDown() throws SQLException, Exception {
1:00364eb:         dropTable("T");
1:00364eb:         commit();
1:026fbdd:         super.tearDown();
1:026fbdd:     }
1:026fbdd: 
1:026fbdd:     public void testForwardOnlyNegative() throws SQLException {
5:026fbdd:         Connection conn = getConnection();
1:026fbdd:         PreparedStatement ps_f_r = null;
3:026fbdd:         ResultSet rs;
2:026fbdd:         Statement s_f_r = null;
1:026fbdd: 
1:00364eb:         s_f_r = createStatement(ResultSet.TYPE_FORWARD_ONLY,
1:026fbdd:                 ResultSet.CONCUR_READ_ONLY);
1:026fbdd:         // We should have gotten no warnings and a read only forward only cursor
1:00364eb:         JDBC.assertNoWarnings(conn.getWarnings());
1:026fbdd: 
1:026fbdd:         conn.clearWarnings();
1:026fbdd: 
1:026fbdd:         // Verify that setMaxRows(-1) fails
1:026fbdd:         try {
1:026fbdd:             s_f_r.setMaxRows(-1);
1:026fbdd:             // Should never get here
1:026fbdd:             fail("setMaxRows(-1) expected to fail");
1:026fbdd:         } catch (SQLException sqle) {
1:026fbdd:             /* Check to be sure the exception is the one we expect */
1:026fbdd: 
1:026fbdd:             assertEquals("XJ063", sqle.getSQLState());
1:026fbdd:         }
1:026fbdd:         // Verify maxRows still 0
1:026fbdd:         assertEquals("getMaxRows() expected to return 0", 0, s_f_r.getMaxRows());
1:026fbdd: 
1:026fbdd:         // Verify that result set from statement is
1:026fbdd:         // scroll insensitive and read only
1:026fbdd:         rs = s_f_r.executeQuery("select * from t");
1:026fbdd:         assertEquals(ResultSet.TYPE_FORWARD_ONLY, rs.getType());
1:026fbdd:         assertEquals(ResultSet.CONCUR_READ_ONLY, rs.getConcurrency());
1:026fbdd: 
1:026fbdd:         // Verify that first(), etc. don't work
1:026fbdd:         try {
1:026fbdd:             rs.first();
1:026fbdd:             // Should never get here
1:026fbdd:             fail("first() expected to fail");
1:026fbdd:         } catch (SQLException sqle) {
1:026fbdd:             assertOnlyOnScrollableException(sqle);
1:026fbdd:         }
1:026fbdd: 
1:026fbdd:         try {
1:026fbdd:             rs.beforeFirst();
1:026fbdd:             // Should never get here
1:026fbdd:             fail("beforeFirst() expected to fail");
1:026fbdd:         } catch (SQLException sqle) {
1:026fbdd:             assertOnlyOnScrollableException(sqle);
1:026fbdd: 
1:026fbdd:         }
1:026fbdd:         try {
1:026fbdd:             rs.isBeforeFirst();
1:026fbdd:             // Should never get here
1:026fbdd:             fail("isBeforeFirst() expected to fail");
1:026fbdd: 
1:026fbdd:         } catch (SQLException sqle) {
1:026fbdd:             // Check to be sure the exception is the one we expect
1:026fbdd:             assertOnlyOnScrollableException(sqle);
1:026fbdd:         }
1:026fbdd:         try {
1:026fbdd:             rs.isAfterLast();
1:026fbdd:             // Should never get here
1:026fbdd:             fail("isAfterLast() expected to fail");
1:026fbdd:         } catch (SQLException sqle) {
1:026fbdd:             // Check to be sure the exception is the one we expect
1:026fbdd:             assertOnlyOnScrollableException(sqle);
1:026fbdd: 
1:026fbdd:         }
1:026fbdd:         try {
1:026fbdd:             rs.isFirst();
1:026fbdd:             // Should never get here
1:026fbdd:             fail("isFirst() expected to fail");
1:026fbdd:         } catch (SQLException sqle) {
1:026fbdd:             // Check to be sure the exception is the one we expect
1:026fbdd:             assertOnlyOnScrollableException(sqle);
1:026fbdd: 
1:026fbdd:         }
1:026fbdd:         try {
1:026fbdd:             rs.isLast();
1:026fbdd:             // Should never get here
1:026fbdd:             fail("isLast() expected to fail");
1:026fbdd:         } catch (SQLException sqle) {
1:026fbdd:             // Check to be sure the exception is the one we expect
1:026fbdd: 
1:026fbdd:             assertOnlyOnScrollableException(sqle);
1:026fbdd: 
1:026fbdd:         }
1:026fbdd:         try {
1:026fbdd:             rs.absolute(1);
1:026fbdd:             // Should never get here
1:026fbdd:             fail("absolute() expected to fail");
1:026fbdd:         } catch (SQLException sqle) {
1:026fbdd:             assertOnlyOnScrollableException(sqle);
1:026fbdd: 
1:026fbdd:         }
1:026fbdd:         try {
1:026fbdd:             rs.relative(1);
1:026fbdd:             // Should never get here
1:026fbdd:             fail("relative() expected to fail");
1:026fbdd:         } catch (SQLException sqle) {
1:026fbdd:             assertOnlyOnScrollableException(sqle);
1:026fbdd:         }
1:026fbdd: 
1:026fbdd:         // setFetchDirection should fail
1:026fbdd:         try {
1:026fbdd:             rs.setFetchDirection(ResultSet.FETCH_FORWARD);
1:026fbdd:             // Should never get here
1:026fbdd:             fail("setFetchDirection() expected to fail");
1:026fbdd:         } catch (SQLException sqle) {
1:026fbdd:             assertOnlyOnScrollableException(sqle);
1:026fbdd:         }
1:026fbdd: 
1:026fbdd:         // Book says that getFetchDirection(), getFetchSize() and
1:026fbdd:         // setFetchSize() are all okay.
1:026fbdd:         if (isDerbyNetClient)
1:026fbdd:             assertEquals(0, rs.getFetchSize());
1:026fbdd:         else
1:026fbdd:             assertEquals(1, rs.getFetchSize());
1:026fbdd: 
1:026fbdd:         rs.setFetchSize(5);
1:026fbdd:         assertEquals(5,rs.getFetchSize());
1:026fbdd:       
1:026fbdd:         assertEquals(ResultSet.FETCH_FORWARD,rs.getFetchDirection());
1:026fbdd:             
1:026fbdd: 
1:026fbdd:         rs.close();
1:026fbdd:         s_f_r.close();
1:026fbdd: 
1:00364eb:         ps_f_r = prepareStatement("select * from t",
1:026fbdd:                 ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);
1:026fbdd:         // We should have gotten no warnings and a read only forward only cursor
1:00364eb:         JDBC.assertNoWarnings(conn.getWarnings());
1:026fbdd:         
1:026fbdd:         conn.clearWarnings();
1:026fbdd: 
1:026fbdd:         // Verify that result set from statement is
1:026fbdd:         // scroll insensitive and read only
1:026fbdd:         rs = ps_f_r.executeQuery();
1:026fbdd:         assertEquals(ResultSet.TYPE_FORWARD_ONLY, rs.getType());
1:026fbdd:         
1:026fbdd:         assertEquals(ResultSet.CONCUR_READ_ONLY,rs.getConcurrency());
1:026fbdd:         
1:026fbdd:         // Verify that first() doesn't work
1:026fbdd:         try {
1:026fbdd:             rs.first();
1:026fbdd:             // Should never get here
1:026fbdd:             fail("first() expected to fail");
1:026fbdd:         } catch (SQLException sqle) {
1:026fbdd:             assertOnlyOnScrollableException(sqle);
1:026fbdd: 
1:026fbdd:         }
1:026fbdd:         rs.close();
1:026fbdd:         ps_f_r.close();
1:026fbdd: 
1:026fbdd:     }
1:026fbdd: 
1:026fbdd:     /**
1:026fbdd:      * Positive tests for forward only cursors.
1:026fbdd:      * 
1:026fbdd:      * This method tests forward only cursors.
1:026fbdd:      * 
1:026fbdd:      * 
1:026fbdd:      * @exception SQLException
1:026fbdd:      *                Thrown if some unexpected error happens
1:026fbdd:      */
1:026fbdd: 
1:026fbdd:     public void testForwardOnlyPositive() throws SQLException {
1:026fbdd:         Connection conn = getConnection();
1:026fbdd:         ResultSet rs;
1:00364eb:         Statement s_f_r = createStatement(ResultSet.TYPE_FORWARD_ONLY,
1:026fbdd:                 ResultSet.CONCUR_READ_ONLY);
1:026fbdd:         // We should have gotten no warnings and a read only forward only cursor
1:00364eb:         JDBC.assertNoWarnings(conn.getWarnings());
1:026fbdd:         conn.clearWarnings();
1:026fbdd: 
1:026fbdd:         // Verify that setMaxRows(4) succeeds
1:026fbdd:         s_f_r.setMaxRows(5);
1:026fbdd:         assertEquals(5, s_f_r.getMaxRows());
1:026fbdd: 
1:026fbdd:         rs = s_f_r.executeQuery("values 1, 2, 3, 4, 5, 6");
1:026fbdd:         // Iterate straight thru RS, expect only 5 rows.
1:026fbdd:         JDBC.assertDrainResults(rs, 5);
1:026fbdd:         
1:026fbdd:         s_f_r.close();
1:026fbdd: 
1:026fbdd:     }
1:026fbdd: 
1:026fbdd:     /**
1:026fbdd:      * Scroll sensitive cursor tests
1:026fbdd:      * 
1:026fbdd:      * This method tests scroll sensitive cursors. (Not implemented, so we
1:026fbdd:      * should get back scroll insensitive curors with read only concurrency.)
1:026fbdd:      * 
1:026fbdd:      * @exception SQLException
1:026fbdd:      *                Thrown if some unexpected error happens
1:026fbdd:      */
1:026fbdd: 
1:026fbdd:     public void testScrollSensitive() throws SQLException {
1:026fbdd:         Connection conn = getConnection();
1:026fbdd:         ResultSet rs;
6:026fbdd:         SQLWarning warning;
1:026fbdd:         Statement s_s_r = null; // sensitive, read only
1:026fbdd:         Statement s_s_u = null; // sensitive, updatable
1:026fbdd: 
1:00364eb:         s_s_r = createStatement(ResultSet.TYPE_SCROLL_SENSITIVE,
1:026fbdd:                 ResultSet.CONCUR_READ_ONLY);
1:026fbdd: 
1:026fbdd:         // We should have gotten a warning and a scroll insensitive cursor
9:026fbdd:         warning = conn.getWarnings();
1:026fbdd:         assertNotNull(warning);
1:026fbdd:         conn.clearWarnings();
1:026fbdd: 
1:026fbdd:         // Verify that result set from statement is
1:026fbdd:         // scroll insensitive and read only
1:026fbdd:         rs = s_s_r.executeQuery("select * from t");
1:026fbdd:         assertEquals(ResultSet.TYPE_SCROLL_INSENSITIVE, rs.getType());
1:026fbdd:         assertEquals(ResultSet.CONCUR_READ_ONLY, rs.getConcurrency());
1:026fbdd:         rs.close();
1:026fbdd: 
1:026fbdd:         // Close the statement
1:026fbdd:         s_s_r.close();
1:026fbdd: 
1:00364eb:         s_s_u = createStatement(ResultSet.TYPE_SCROLL_SENSITIVE,
1:026fbdd:                 ResultSet.CONCUR_UPDATABLE);
1:026fbdd:         // We should have gotten 1 warning and a updatable scroll
1:026fbdd:         // insensitive cursor.
1:026fbdd:         warning = conn.getWarnings();
1:026fbdd:         assertNotNull(warning);
1:026fbdd:         conn.clearWarnings();
1:026fbdd: 
1:026fbdd:         // Verify that result set from statement is
1:026fbdd:         // scroll insensitive and read only
1:026fbdd:         rs = s_s_u.executeQuery("select * from t");
1:026fbdd:         assertEquals(ResultSet.TYPE_SCROLL_INSENSITIVE, rs.getType());
1:026fbdd:         assertEquals(ResultSet.CONCUR_UPDATABLE, rs.getConcurrency());
1:026fbdd: 
1:026fbdd:         rs.close();
1:026fbdd:     }
1:026fbdd: 
1:026fbdd:     /**
1:026fbdd:      * Positive tests for scroll insensitive cursor.
1:026fbdd:      * 
1:026fbdd:      * 
1:026fbdd:      * @exception SQLException
1:026fbdd:      *                Thrown if some unexpected error happens
1:026fbdd:      */
1:026fbdd:     public void testScrollInsensitivePositive() throws SQLException {
1:026fbdd:         Connection conn = getConnection();
1:00364eb: 
1:00364eb:         ResultSet rs;
1:026fbdd: 
1:00364eb:         // insensitive, read only
1:00364eb:         Statement s_i_r = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
1:026fbdd:                 ResultSet.CONCUR_READ_ONLY);
1:026fbdd: 
1:026fbdd:         // We should not have gotten any warnings
1:026fbdd:         // and should have gotten a scroll insensitive cursor
1:00364eb:         JDBC.assertNoWarnings(conn.getWarnings());
1:026fbdd: 
1:026fbdd:         conn.clearWarnings();
1:026fbdd: 
1:026fbdd:         // run a query
1:026fbdd:         rs = s_i_r.executeQuery("select * from t");
1:026fbdd:         // verify scroll insensitive and read only
1:026fbdd:         assertEquals(ResultSet.TYPE_SCROLL_INSENSITIVE, rs.getType());
1:026fbdd:         assertEquals(ResultSet.CONCUR_READ_ONLY, rs.getConcurrency());
1:026fbdd:         // We should be positioned before the 1st row
1:026fbdd:         assertTrue(rs.isBeforeFirst());
1:026fbdd:         assertFalse(rs.absolute(0));
1:026fbdd:         // still expected to be before first
1:026fbdd:         assertTrue(rs.isBeforeFirst());
1:026fbdd:         // go to first row
1:026fbdd:         assertTrue(rs.first());
1:026fbdd:         assertEquals(rs.getInt(1), 2);
1:026fbdd:         assertTrue(rs.isFirst());
1:026fbdd: 
1:026fbdd:         // move to before first
1:026fbdd:         rs.beforeFirst();
1:026fbdd:         assertTrue(rs.isBeforeFirst());
1:026fbdd:         // move to last row
1:026fbdd:         assertTrue(rs.last());
1:026fbdd:         assertTrue(rs.isLast());
1:026fbdd:         assertFalse(rs.isAfterLast());
1:026fbdd:         assertEquals(6, rs.getInt(1));
1:026fbdd:         assertFalse("not expecting to find another row", rs.next());
1:026fbdd:         assertTrue(rs.isAfterLast());
1:026fbdd:         // We're after the last row, verify that only isAfterLast()
1:026fbdd:         // returns true
1:026fbdd:         assertFalse(rs.isLast());
1:026fbdd:         assertFalse(rs.isFirst());
1:026fbdd:         assertFalse(rs.isBeforeFirst());
1:026fbdd:         assertEquals(ResultSet.FETCH_FORWARD, rs.getFetchDirection());
1:026fbdd:         rs.setFetchDirection(ResultSet.FETCH_UNKNOWN);
1:026fbdd:         assertEquals(ResultSet.FETCH_UNKNOWN, rs.getFetchDirection());
1:026fbdd:         if (isDerbyNetClient)
1:026fbdd:             assertEquals(64, rs.getFetchSize());
1:026fbdd:         else
1:026fbdd:             assertEquals(1, rs.getFetchSize());
1:026fbdd:         rs.setFetchSize(5);
1:026fbdd:         assertEquals(5, rs.getFetchSize());
1:026fbdd: 
1:026fbdd:         // setFetchSize() to 0 should have no effect.
1:026fbdd:         // for client server, fetchSize should have to 64
1:026fbdd:         rs.setFetchSize(0);
1:026fbdd:         if (isDerbyNetClient)
1:026fbdd:             assertEquals(64, rs.getFetchSize());
1:026fbdd:         else
1:026fbdd:             assertEquals(5, rs.getFetchSize());
1:026fbdd:         // done
1:026fbdd:         rs.close();
1:026fbdd: 
1:026fbdd:         // Empty result set tests (DERBY-992)
1:026fbdd:         rs = s_i_r.executeQuery("select * from t where 1=0");
1:026fbdd:         rs.afterLast();
1:026fbdd:         assertFalse("afterLast() on empty RS should be no-op", rs.isAfterLast());
1:026fbdd:         rs.beforeFirst();
1:026fbdd:         assertFalse("beforeFirst() on empty RS should be no-op", rs
1:026fbdd:                 .isBeforeFirst());
1:026fbdd: 
1:026fbdd:         rs.close();
1:026fbdd: 
1:00364eb:         PreparedStatement ps_i_r = prepareStatement("select * from t",
1:026fbdd:                 ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);
1:026fbdd: 
1:026fbdd:         // We should not have gotten any warnings
1:026fbdd:         // and should have gotten a prepared scroll insensitive cursor
1:00364eb:         JDBC.assertNoWarnings(conn.getWarnings());
1:026fbdd: 
1:026fbdd:         rs = ps_i_r.executeQuery();
1:026fbdd:         // make sure it's scrollable
1:026fbdd:         rs.last();
1:026fbdd:         rs.close();
1:026fbdd:         ps_i_r.close();
1:026fbdd: 
1:026fbdd:         // Check setMaxRows()/getMaxRows()
1:026fbdd:         assertEquals(0, s_i_r.getMaxRows());
1:026fbdd:         s_i_r.setMaxRows(5);
1:026fbdd:         assertEquals(5, s_i_r.getMaxRows());
1:026fbdd: 
1:026fbdd:         rs = s_i_r.executeQuery("values 1, 2, 3, 4, 5, 6");
2:026fbdd:         assertNotNull(rs);
1:026fbdd:         // Iterate straight thru RS, expect only 5 rows.
1:026fbdd:         for (int index = 1; index < 6; index++) {
1:026fbdd:             assertTrue(rs.next());
1:026fbdd: 
1:026fbdd:         }
1:026fbdd:         // We should not see another row (only 5, not 6)
1:026fbdd:         assertFalse(rs.next());
1:026fbdd:         rs.close();
1:026fbdd:         // Jump around and verify setMaxRows() works.
1:026fbdd:         rs = s_i_r.executeQuery("values 1, 2, 3, 4, 5, 6");
1:026fbdd:         assertNotNull(rs);
1:026fbdd:         assertTrue(rs.last());
1:026fbdd: 
1:026fbdd:         // Iterate backwards thru RS, expect only 4 more (5 total) rows.
1:026fbdd:         for (int index = 1; index < 5; index++) {
1:026fbdd:             assertTrue(rs.previous());
1:026fbdd:         }
1:026fbdd:         // We should not see another row (only 5, not 6)
1:026fbdd:         assertFalse(rs.previous());
1:026fbdd:         rs.close();
1:026fbdd:         rs = s_i_r.executeQuery("values 1, 2, 3, 4, 5, 6");
1:026fbdd:         assertNotNull(rs);
1:026fbdd: 
1:026fbdd:         rs.afterLast();
1:026fbdd:         // Iterate backwards thru RS, expect only 5 rows.
1:026fbdd:         for (int index = 1; index < 6; index++) {
1:026fbdd:             assertTrue(rs.previous());
1:026fbdd: 
1:026fbdd:         }
1:026fbdd:         // We should not see another row (only 5, not 6)
1:026fbdd:         assertFalse(rs.previous());
1:026fbdd:         rs.close();
1:026fbdd:         // Verify setting maxRows back to 0 works.
1:026fbdd:         s_i_r.setMaxRows(0);
1:026fbdd:         rs = s_i_r.executeQuery("values 1, 2, 3, 4, 5, 6");
1:026fbdd:         assertNotNull(rs);
1:026fbdd: 
1:026fbdd:         // Iterate straight thru RS, expect 6 rows.
1:026fbdd:         for (int index = 1; index < 7; index++) {
1:026fbdd:             assertTrue(rs.next());
1:026fbdd: 
1:026fbdd:         }
1:026fbdd:         // We should not see another row
1:026fbdd:         assertFalse(rs.next());
1:026fbdd: 
1:026fbdd:         rs.close();
1:026fbdd: 
1:026fbdd:     }
1:026fbdd: 
1:026fbdd:     /**
2:026fbdd:      * Negative tests for scroll insensitive cursor.
1:026fbdd:      * 
1:026fbdd:      * @exception SQLException
1:026fbdd:      *                Thrown if some unexpected error happens
1:026fbdd:      */
1:026fbdd:     public void testScrollInsensitiveNegative() throws SQLException {
1:026fbdd:         Connection conn = getConnection();
1:026fbdd: 
1:00364eb:         ResultSet rs;
1:00364eb:         // insensitive, read only
1:00364eb:         Statement s_i_r = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
1:026fbdd:                 ResultSet.CONCUR_READ_ONLY);
1:026fbdd: 
1:026fbdd:         // We should not have gotten any warnings
1:026fbdd:         // and should have gotten a scroll insensitive cursor
1:00364eb:         JDBC.assertNoWarnings(conn.getWarnings());
1:026fbdd:         conn.clearWarnings();
1:026fbdd: 
1:026fbdd:         // Verify that setMaxRows(-1) fails
1:026fbdd:         try {
1:026fbdd:             s_i_r.setMaxRows(-1);
1:026fbdd:             // Should never get here
1:026fbdd:             fail("setMaxRows(-1) expected to fail");
1:026fbdd:         } catch (SQLException sqle) {
1:026fbdd:             /* Check to be sure the exception is the one we expect */
1:026fbdd:             assertEquals("XJ063", sqle.getSQLState());
1:026fbdd: 
1:026fbdd:         }
1:026fbdd:         // Verify maxRows still 0
1:026fbdd:         assertEquals(0, s_i_r.getMaxRows());
1:026fbdd: 
1:026fbdd:         // Empty result set
1:026fbdd:         rs = s_i_r.executeQuery("select * from t where 1=0");
1:026fbdd:         // isBeforeFirst() and isAfterLast() should always return false
1:026fbdd:         // when result set is empty
1:026fbdd:         assertFalse(rs.isBeforeFirst());
1:026fbdd:         assertFalse(rs.next());
1:026fbdd:         assertFalse(rs.previous());
1:026fbdd:         assertFalse(rs.isAfterLast());
1:026fbdd:         assertFalse(rs.isFirst());
1:026fbdd:         assertFalse(rs.isLast());
1:026fbdd:         assertFalse(rs.relative(0));
1:026fbdd:         assertFalse(rs.relative(1));
1:026fbdd:         assertFalse(rs.relative(-1));
1:026fbdd:         assertFalse(rs.absolute(0));
1:026fbdd:         assertFalse(rs.absolute(1));
1:026fbdd:         assertFalse(rs.absolute(-1));
1:026fbdd:         rs.close();
1:026fbdd:         // End of empty result set tests
1:026fbdd: 
1:026fbdd:         // Non-empty result set
1:026fbdd:         rs = s_i_r.executeQuery("select * from t");
1:026fbdd:         // Negative fetch size
1:026fbdd:         try {
1:026fbdd:             rs.setFetchSize(-5);
1:026fbdd:             fail("setFetchSize(-5) expected to fail");
1:026fbdd: 
1:026fbdd:         } catch (SQLException sqle) {
1:026fbdd:             /* Check to be sure the exception is the one we expect */
1:026fbdd:             assertEquals("XJ062", sqle.getSQLState());
1:026fbdd: 
1:026fbdd:         }
1:026fbdd:         rs.close();
1:026fbdd:         s_i_r.close();
1:026fbdd:         
1:026fbdd:     }
1:026fbdd: 
1:026fbdd:     /**
1:026fbdd:      * CallableStatement tests.
1:026fbdd:      * 
1:026fbdd:      * @exception SQLException
1:026fbdd:      *                Thrown if some unexpected error happens
1:026fbdd:      */
1:026fbdd: 
1:026fbdd:     public void testCallableStatements() throws SQLException {
1:026fbdd:         Connection conn = getConnection();
1:026fbdd: 
1:026fbdd:         SQLWarning warning;
1:026fbdd:         CallableStatement cs_s_r = null; // sensitive, read only
1:026fbdd:         CallableStatement cs_s_u = null; // sensitive, updatable
1:026fbdd:         CallableStatement cs_i_r = null; // insensitive, read only
1:026fbdd:         CallableStatement cs_f_r = null; // forward only, read only
1:026fbdd: 
1:00364eb:         cs_s_r = prepareCall("values cast (? as Integer)",
1:026fbdd:                 ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_READ_ONLY);
1:026fbdd: 
1:026fbdd:         // We should have gotten 1 warnings
1:026fbdd:         warning = conn.getWarnings();
1:026fbdd:         assertNotNull(warning);
1:026fbdd:         if (!isDerbyNetClient)
1:026fbdd:             assertEquals("01J02", warning.getSQLState());
1:026fbdd:         else
1:026fbdd:             assertEquals("01J10", warning.getSQLState());
1:026fbdd: 
1:00364eb:         JDBC.assertNoWarnings(warning.getNextWarning());
1:026fbdd: 
1:026fbdd:         conn.clearWarnings();
1:026fbdd:         cs_s_r.close();
1:026fbdd: 
1:00364eb:         cs_s_u = prepareCall("values cast (? as Integer)",
1:026fbdd:                 ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);
1:026fbdd: 
1:026fbdd:         // We should have gotten 1 warning
1:026fbdd:         warning = conn.getWarnings();
1:026fbdd:         assertNotNull(warning);
1:026fbdd:         if (!isDerbyNetClient)
1:026fbdd:             assertEquals("01J02", warning.getSQLState());
1:026fbdd:         else
1:026fbdd:             assertEquals("01J10", warning.getSQLState());
1:026fbdd: 
1:00364eb:         JDBC.assertNoWarnings(warning.getNextWarning());
1:026fbdd:         conn.clearWarnings();
1:026fbdd:         cs_s_u.close();
1:026fbdd: 
1:00364eb:         cs_i_r = prepareCall("values cast (? as Integer)",
1:026fbdd:                 ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);
1:026fbdd: 
1:026fbdd:         // We should have gotten 0 warnings
1:00364eb:         JDBC.assertNoWarnings(conn.getWarnings());
1:026fbdd: 
1:026fbdd:         conn.clearWarnings();
1:026fbdd:         cs_i_r.close();
1:026fbdd: 
1:00364eb:         cs_f_r = prepareCall("values cast (? as Integer)",
1:026fbdd:                 ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);
1:026fbdd: 
1:026fbdd:         // We should have gotten 0 warnings
1:00364eb:         JDBC.assertNoWarnings(conn.getWarnings());
1:026fbdd: 
1:026fbdd:         conn.clearWarnings();
1:026fbdd:         cs_f_r.close();
1:026fbdd: 
1:026fbdd:     }
1:026fbdd: 
1:026fbdd:     /**
1:026fbdd:      * Tests for PreparedStatement.getMetaData().
1:026fbdd:      * 
1:026fbdd:      * @exception SQLException
1:026fbdd:      *                Thrown if some unexpected error happens
1:026fbdd:      */
1:026fbdd:     public void testGetMetaData() throws SQLException {
1:00364eb: 
1:026fbdd:         PreparedStatement ps_f_r = null; // forward only, read only
1:026fbdd:         ResultSet rs;
1:026fbdd:         ResultSetMetaData rsmd_ps;
1:026fbdd:         ResultSetMetaData rsmd_rs;
1:026fbdd: 
1:00364eb:         ps_f_r = prepareStatement("select c50, i, 43 from t",
1:026fbdd:                 ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);
1:026fbdd: 
1:026fbdd:         rsmd_ps = ps_f_r.getMetaData();
1:026fbdd:         assertNotNull(rsmd_ps);
1:026fbdd: 
1:026fbdd:         // Now get meta data from result set
1:026fbdd:         rs = ps_f_r.executeQuery();
1:026fbdd:         rsmd_rs = rs.getMetaData();
1:026fbdd:         assertNotNull(rsmd_rs);
1:026fbdd: 
1:026fbdd:         // check column count
1:026fbdd:         assertEquals(rsmd_ps.getColumnCount(), rsmd_rs.getColumnCount());
1:026fbdd: 
1:026fbdd:         // get column name for 2nd column
1:026fbdd:         assertEquals(rsmd_ps.getColumnName(2), rsmd_rs.getColumnName(2));
1:026fbdd:         assertEquals(rsmd_ps.isReadOnly(2), rsmd_rs.isReadOnly(2));
1:026fbdd: 
1:026fbdd:         rs.close();
1:026fbdd:         ps_f_r.close();
1:026fbdd: 
1:026fbdd:     }
1:026fbdd: 
1:026fbdd:     public void testScrollVerifyMaxRowWithFetchSize() throws SQLException {
1:026fbdd:         scrollVerifyMaxRowWithFetchSize(10, 10);
1:026fbdd:         scrollVerifyMaxRowWithFetchSize(10, 5);
1:026fbdd:         scrollVerifyMaxRowWithFetchSize(10, 0);
1:026fbdd:         scrollVerifyMaxRowWithFetchSize(0, 0);
1:026fbdd:         scrollVerifyMaxRowWithFetchSize(0, 5);
1:026fbdd:         scrollVerifyMaxRowWithFetchSize(0, 10);
1:026fbdd:         scrollVerifyMaxRowWithFetchSize(0, 15);
1:026fbdd:     }
1:026fbdd: 
1:026fbdd:     /**
1:026fbdd:      * Tests for maxRow and fetchSize with scrollable cursors
1:026fbdd:      * 
1:026fbdd:      * 
1:026fbdd:      * @param maxRows
1:026fbdd:      *            The maxRows value to use
1:026fbdd:      * @param fetchSize
1:026fbdd:      *            The fetchSize value to use
1:026fbdd:      * 
1:026fbdd:      * @exception SQLException
1:026fbdd:      *                Thrown if some unexpected error happens
1:026fbdd:      */
1:026fbdd:     private void scrollVerifyMaxRowWithFetchSize(int maxRows, int fetchSize)
1:026fbdd:             throws SQLException {
1:00364eb: 
1:026fbdd:         ResultSet rs;
1:00364eb:         Statement s_i_r = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
1:026fbdd:                 ResultSet.CONCUR_READ_ONLY);
1:026fbdd:         s_i_r.setMaxRows(maxRows);
1:026fbdd: 
1:026fbdd:         // Execute query
1:026fbdd:         rs = s_i_r
1:026fbdd:                 .executeQuery("values 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15");
1:026fbdd:         rs.setFetchSize(fetchSize);
1:026fbdd: 
1:026fbdd:         // this should not affect the ResultSet because
1:026fbdd:         s_i_r.setMaxRows(2);
1:026fbdd:         if (maxRows == 0)
1:026fbdd:             maxRows = 15;
1:026fbdd:         assertNotNull(rs);
1:026fbdd: 
1:026fbdd:         // Start from before first
1:026fbdd:         // Iterate straight thru RS, expect only maxRows rows.
1:026fbdd:         for (int index = 1; index < maxRows + 1; index++) {
1:026fbdd:             assertTrue("rs.next() failed, index = " + index, rs.next());
1:026fbdd:             assertEquals(index, rs.getInt(1));
1:026fbdd: 
1:026fbdd:         }
1:026fbdd:         // We should not see another row (only maxRows, not total)
1:026fbdd:         assertFalse(rs.next());
1:026fbdd: 
1:026fbdd:         // Start from first and verify maxRows
1:026fbdd:         assertTrue(rs.first());
1:026fbdd: 
1:026fbdd:         // Iterate forward thru RS, expect only (maxRows - 1) more rows.
1:026fbdd:         for (int index = 1; index < maxRows; index++) {
1:026fbdd:             assertTrue(rs.next());
1:026fbdd:             assertEquals(index + 1, rs.getInt(1));
1:026fbdd: 
1:026fbdd:         }
1:026fbdd:         // We should not see another row (only maxRows, not total)
1:026fbdd:         assertFalse(rs.next());
1:026fbdd: 
1:026fbdd:         // Start from afterLast and verify maxRows
1:026fbdd:         rs.afterLast();
1:026fbdd:         // Iterate backwards thru RS, expect only (maxRows - 1) rows.
1:026fbdd:         for (int index = 1; index < maxRows + 1; index++) {
1:026fbdd:             assertTrue(rs.previous());
1:026fbdd:             assertEquals(maxRows - index + 1, rs.getInt(1));
1:026fbdd:         }
1:026fbdd:         // We should not see another row (only maxRows, not total)
1:026fbdd:         assertFalse(rs.previous());
1:026fbdd: 
1:026fbdd:         // Start from last and verify maxRows
1:026fbdd:         assertTrue(rs.last());
1:026fbdd: 
1:026fbdd:         // Iterate backwards thru RS, expect only (maxRows - 1) more rows.
1:026fbdd:         for (int index = 1; index < maxRows; index++) {
1:026fbdd:             assertTrue(rs.previous());
1:026fbdd:             assertEquals((maxRows - index), rs.getInt(1));
1:026fbdd: 
1:026fbdd:         }
1:026fbdd:         // We should not see another row (only 5, not 6)
1:026fbdd:         assertFalse(rs.previous());
1:026fbdd:         rs.last();
1:026fbdd:         int rows = rs.getRow();
1:026fbdd: 
1:026fbdd:         rs.absolute(rows / 2);
1:026fbdd:         assertFalse(rs.relative(-1 * (rows)));
1:026fbdd:         assertTrue(rs.isBeforeFirst());
1:026fbdd: 
1:026fbdd:         rs.absolute(rows / 2);
1:026fbdd:         assertFalse(rs.relative(rows));
1:026fbdd:         assertTrue(rs.isAfterLast());
1:026fbdd:         rs.absolute(rows / 2);
1:026fbdd:         assertFalse("absolute(" + (rows + 1)
1:026fbdd:                 + ") should return false, position outside of the resultSet",
1:026fbdd:                 rs.absolute(rows + 1));
1:026fbdd: 
1:026fbdd:         rs.absolute(rows / 2);
1:026fbdd:         assertFalse(rs.absolute((-1) * (rows + 1)));
1:026fbdd: 
1:026fbdd:         assertTrue(rs.isBeforeFirst());
1:026fbdd: 
1:026fbdd:         rs.close();
1:026fbdd: 
1:026fbdd:     }
1:026fbdd: 
1:026fbdd:     private void assertOnlyOnScrollableException(SQLException sqle) {
1:026fbdd:         if (!isDerbyNetClient) {
1:026fbdd:             assertEquals("XJ061", sqle.getSQLState());
1:026fbdd:         } else {
1:026fbdd:             assertEquals("XJ125", sqle.getSQLState());
1:026fbdd:         }
1:026fbdd:     }
1:026fbdd: 
1:026fbdd:     public static Test suite() {
1:026fbdd:         return TestConfiguration.defaultSuite(ScrollCursors2Test.class);
1:026fbdd:     }
1:026fbdd: 
1:026fbdd: }
============================================================================
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:00364eb
/////////////////////////////////////////////////////////////////////////
1:         s_i_r = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
/////////////////////////////////////////////////////////////////////////
1:         dropTable("T");
1:         commit();
/////////////////////////////////////////////////////////////////////////
1:         s_f_r = createStatement(ResultSet.TYPE_FORWARD_ONLY,
1:         JDBC.assertNoWarnings(conn.getWarnings());
/////////////////////////////////////////////////////////////////////////
1:         ps_f_r = prepareStatement("select * from t",
1:         JDBC.assertNoWarnings(conn.getWarnings());
/////////////////////////////////////////////////////////////////////////
1:         Statement s_f_r = createStatement(ResultSet.TYPE_FORWARD_ONLY,
1:         JDBC.assertNoWarnings(conn.getWarnings());
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         s_s_r = createStatement(ResultSet.TYPE_SCROLL_SENSITIVE,
/////////////////////////////////////////////////////////////////////////
1:         s_s_u = createStatement(ResultSet.TYPE_SCROLL_SENSITIVE,
/////////////////////////////////////////////////////////////////////////
1:         ResultSet rs;
1: 
1:         // insensitive, read only
1:         Statement s_i_r = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
1:         JDBC.assertNoWarnings(conn.getWarnings());
/////////////////////////////////////////////////////////////////////////
1:         PreparedStatement ps_i_r = prepareStatement("select * from t",
1:         JDBC.assertNoWarnings(conn.getWarnings());
/////////////////////////////////////////////////////////////////////////
1:         ResultSet rs;
1:         // insensitive, read only
1:         Statement s_i_r = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
1:         JDBC.assertNoWarnings(conn.getWarnings());
/////////////////////////////////////////////////////////////////////////
1:         cs_s_r = prepareCall("values cast (? as Integer)",
/////////////////////////////////////////////////////////////////////////
1:         JDBC.assertNoWarnings(warning.getNextWarning());
1:         cs_s_u = prepareCall("values cast (? as Integer)",
/////////////////////////////////////////////////////////////////////////
1:         JDBC.assertNoWarnings(warning.getNextWarning());
1:         cs_i_r = prepareCall("values cast (? as Integer)",
1:         JDBC.assertNoWarnings(conn.getWarnings());
1:         cs_f_r = prepareCall("values cast (? as Integer)",
1:         JDBC.assertNoWarnings(conn.getWarnings());
/////////////////////////////////////////////////////////////////////////
1: 
1:         ps_f_r = prepareStatement("select c50, i, 43 from t",
/////////////////////////////////////////////////////////////////////////
1: 
1:         Statement s_i_r = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:a444166
/////////////////////////////////////////////////////////////////////////
commit:026fbdd
/////////////////////////////////////////////////////////////////////////
1: /**
1:  *  Derby - Class org.apache.derbyTesting.functionTests.tests.lang.ScrollCursors2Test
1:  *  
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.tests.lang;
1: 
1: import java.sql.CallableStatement;
1: import java.sql.Connection;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.ResultSetMetaData;
1: import java.sql.SQLException;
1: import java.sql.SQLWarning;
1: import java.sql.Statement;
1: 
1: import junit.framework.Test;
1: 
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.JDBC;
1: import org.apache.derbyTesting.junit.TestConfiguration;
1: 
1: public class ScrollCursors2Test extends BaseJDBCTestCase {
1: 
1:     public ScrollCursors2Test(String name) {
1:         super(name);
1: 
1:     }
1: 
1:     private static boolean isDerbyNetClient = usingDerbyNetClient();
1: 
1:     /**
1:      * Set up the test.
1:      * 
1:      * This method creates the table used by the rest of the test.
1:      * 
1:      * 
1:      * @exception SQLException
1:      *                Thrown if some unexpected error happens
1:      */
1: 
1:     public void setUp() throws SQLException {
1:         Connection conn = getConnection();
1: 
1:         Statement s_i_r;
1: 
0:         s_i_r = conn.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
1:                 ResultSet.CONCUR_READ_ONLY);
1: 
1:         /* Create a table */
1:         s_i_r.execute("create table t (i int, c50 char(50))");
1: 
1:         /* Populate the table */
1:         s_i_r.execute("insert into t (i) values (2), (3), (4), (5), (6)");
1:         s_i_r.execute("update t set c50 = RTRIM(CAST (i AS CHAR(50)))");
1:         s_i_r.close();
1:         isDerbyNetClient = usingDerbyNetClient();
1:     }
1: 
1:     public void tearDown() throws SQLException, Exception {
1:         Connection conn = getConnection();
0:         Statement s = conn.createStatement();
0:         s.execute("drop table t");
0:         conn.commit();
1:         super.tearDown();
1:     }
1: 
1:     public void testForwardOnlyNegative() throws SQLException {
1:         Connection conn = getConnection();
1:         PreparedStatement ps_f_r = null;
1:         ResultSet rs;
1:         SQLWarning warning;
1:         Statement s_f_r = null;
1: 
0:         s_f_r = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY,
1:                 ResultSet.CONCUR_READ_ONLY);
1:         // We should have gotten no warnings and a read only forward only cursor
1:         warning = conn.getWarnings();
0:         assertNull(warning);
1: 
1:         conn.clearWarnings();
1: 
1:         // Verify that setMaxRows(-1) fails
1:         try {
1:             s_f_r.setMaxRows(-1);
1:             // Should never get here
1:             fail("setMaxRows(-1) expected to fail");
1:         } catch (SQLException sqle) {
1:             /* Check to be sure the exception is the one we expect */
1: 
1:             assertEquals("XJ063", sqle.getSQLState());
1:         }
1:         // Verify maxRows still 0
1:         assertEquals("getMaxRows() expected to return 0", 0, s_f_r.getMaxRows());
1: 
1:         // Verify that result set from statement is
1:         // scroll insensitive and read only
1:         rs = s_f_r.executeQuery("select * from t");
1:         assertEquals(ResultSet.TYPE_FORWARD_ONLY, rs.getType());
1:         assertEquals(ResultSet.CONCUR_READ_ONLY, rs.getConcurrency());
1: 
1:         // Verify that first(), etc. don't work
1:         try {
1:             rs.first();
1:             // Should never get here
1:             fail("first() expected to fail");
1:         } catch (SQLException sqle) {
1:             assertOnlyOnScrollableException(sqle);
1:         }
1: 
1:         try {
1:             rs.beforeFirst();
1:             // Should never get here
1:             fail("beforeFirst() expected to fail");
1:         } catch (SQLException sqle) {
1:             assertOnlyOnScrollableException(sqle);
1: 
1:         }
1:         try {
1:             rs.isBeforeFirst();
1:             // Should never get here
1:             fail("isBeforeFirst() expected to fail");
1: 
1:         } catch (SQLException sqle) {
1:             // Check to be sure the exception is the one we expect
1:             assertOnlyOnScrollableException(sqle);
1:         }
1:         try {
1:             rs.isAfterLast();
1:             // Should never get here
1:             fail("isAfterLast() expected to fail");
1:         } catch (SQLException sqle) {
1:             // Check to be sure the exception is the one we expect
1:             assertOnlyOnScrollableException(sqle);
1: 
1:         }
1:         try {
1:             rs.isFirst();
1:             // Should never get here
1:             fail("isFirst() expected to fail");
1:         } catch (SQLException sqle) {
1:             // Check to be sure the exception is the one we expect
1:             assertOnlyOnScrollableException(sqle);
1: 
1:         }
1:         try {
1:             rs.isLast();
1:             // Should never get here
1:             fail("isLast() expected to fail");
1:         } catch (SQLException sqle) {
1:             // Check to be sure the exception is the one we expect
1: 
1:             assertOnlyOnScrollableException(sqle);
1: 
1:         }
1:         try {
1:             rs.absolute(1);
1:             // Should never get here
1:             fail("absolute() expected to fail");
1:         } catch (SQLException sqle) {
1:             assertOnlyOnScrollableException(sqle);
1: 
1:         }
1:         try {
1:             rs.relative(1);
1:             // Should never get here
1:             fail("relative() expected to fail");
1:         } catch (SQLException sqle) {
1:             assertOnlyOnScrollableException(sqle);
1:         }
1: 
1:         // setFetchDirection should fail
1:         try {
1:             rs.setFetchDirection(ResultSet.FETCH_FORWARD);
1:             // Should never get here
1:             fail("setFetchDirection() expected to fail");
1:         } catch (SQLException sqle) {
1:             assertOnlyOnScrollableException(sqle);
1:         }
1: 
1:         // Book says that getFetchDirection(), getFetchSize() and
1:         // setFetchSize() are all okay.
1:         if (isDerbyNetClient)
1:             assertEquals(0, rs.getFetchSize());
1:         else
1:             assertEquals(1, rs.getFetchSize());
1: 
1:         rs.setFetchSize(5);
1:         assertEquals(5,rs.getFetchSize());
1:       
1:         assertEquals(ResultSet.FETCH_FORWARD,rs.getFetchDirection());
1:             
1: 
1:         rs.close();
1:         s_f_r.close();
1: 
0:         ps_f_r = conn.prepareStatement("select * from t",
1:                 ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);
1:         // We should have gotten no warnings and a read only forward only cursor
1:         warning = conn.getWarnings();
0:         assertNull(warning);
1:         
1:         conn.clearWarnings();
1: 
1:         // Verify that result set from statement is
1:         // scroll insensitive and read only
1:         rs = ps_f_r.executeQuery();
1:         assertEquals(ResultSet.TYPE_FORWARD_ONLY, rs.getType());
1:         
1:         assertEquals(ResultSet.CONCUR_READ_ONLY,rs.getConcurrency());
1:         
1:         // Verify that first() doesn't work
1:         try {
1:             rs.first();
1:             // Should never get here
1:             fail("first() expected to fail");
1:         } catch (SQLException sqle) {
1:             assertOnlyOnScrollableException(sqle);
1: 
1:         }
1:         rs.close();
1:         ps_f_r.close();
1: 
1:     }
1: 
1:     /**
1:      * Positive tests for forward only cursors.
1:      * 
1:      * This method tests forward only cursors.
1:      * 
1:      * 
1:      * @exception SQLException
1:      *                Thrown if some unexpected error happens
1:      */
1: 
1:     public void testForwardOnlyPositive() throws SQLException {
1:         Connection conn = getConnection();
0:         boolean passed = true;
1:         ResultSet rs;
1:         SQLWarning warning;
1:         Statement s_f_r = null;
1: 
0:         s_f_r = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY,
1:                 ResultSet.CONCUR_READ_ONLY);
1:         // We should have gotten no warnings and a read only forward only cursor
1:         warning = conn.getWarnings();
0:         assertNull(warning);
1:         conn.clearWarnings();
1: 
1:         // Verify that setMaxRows(4) succeeds
1:         s_f_r.setMaxRows(5);
1:         assertEquals(5, s_f_r.getMaxRows());
1: 
1:         rs = s_f_r.executeQuery("values 1, 2, 3, 4, 5, 6");
1:         // Iterate straight thru RS, expect only 5 rows.
1:         assertNotNull(rs);
1:         JDBC.assertDrainResults(rs, 5);
1:         
1:         s_f_r.close();
1: 
1:     }
1: 
1:     /**
1:      * Scroll sensitive cursor tests
1:      * 
1:      * This method tests scroll sensitive cursors. (Not implemented, so we
1:      * should get back scroll insensitive curors with read only concurrency.)
1:      * 
1:      * @exception SQLException
1:      *                Thrown if some unexpected error happens
1:      */
1: 
1:     public void testScrollSensitive() throws SQLException {
1:         Connection conn = getConnection();
1:         ResultSet rs;
1:         SQLWarning warning;
1:         Statement s_s_r = null; // sensitive, read only
1:         Statement s_s_u = null; // sensitive, updatable
1: 
0:         s_s_r = conn.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE,
1:                 ResultSet.CONCUR_READ_ONLY);
1: 
1:         // We should have gotten a warning and a scroll insensitive cursor
1:         warning = conn.getWarnings();
1:         assertNotNull(warning);
1:         conn.clearWarnings();
1: 
1:         // Verify that result set from statement is
1:         // scroll insensitive and read only
1:         rs = s_s_r.executeQuery("select * from t");
1:         assertEquals(ResultSet.TYPE_SCROLL_INSENSITIVE, rs.getType());
1:         assertEquals(ResultSet.CONCUR_READ_ONLY, rs.getConcurrency());
1:         rs.close();
1: 
1:         // Close the statement
1:         s_s_r.close();
1: 
0:         s_s_u = conn.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE,
1:                 ResultSet.CONCUR_UPDATABLE);
1:         // We should have gotten 1 warning and a updatable scroll
1:         // insensitive cursor.
1:         warning = conn.getWarnings();
1:         assertNotNull(warning);
1:         conn.clearWarnings();
1: 
1:         // Verify that result set from statement is
1:         // scroll insensitive and read only
1:         rs = s_s_u.executeQuery("select * from t");
1:         assertEquals(ResultSet.TYPE_SCROLL_INSENSITIVE, rs.getType());
1:         assertEquals(ResultSet.CONCUR_UPDATABLE, rs.getConcurrency());
1: 
1:         rs.close();
1:     }
1: 
1:     /**
1:      * Positive tests for scroll insensitive cursor.
1:      * 
1:      * 
1:      * @exception SQLException
1:      *                Thrown if some unexpected error happens
1:      */
1:     public void testScrollInsensitivePositive() throws SQLException {
1:         Connection conn = getConnection();
0:         boolean passed = true;
0:         PreparedStatement ps_i_r = null;
1:         ResultSet rs;
1:         SQLWarning warning;
0:         Statement s_i_r = null; // insensitive, read only
1: 
0:         s_i_r = conn.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
1:                 ResultSet.CONCUR_READ_ONLY);
1: 
1:         // We should not have gotten any warnings
1:         // and should have gotten a scroll insensitive cursor
1:         warning = conn.getWarnings();
0:         assertNull(warning);
1: 
1:         conn.clearWarnings();
1: 
1:         // run a query
1:         rs = s_i_r.executeQuery("select * from t");
1:         // verify scroll insensitive and read only
1:         assertEquals(ResultSet.TYPE_SCROLL_INSENSITIVE, rs.getType());
1:         assertEquals(ResultSet.CONCUR_READ_ONLY, rs.getConcurrency());
1:         // We should be positioned before the 1st row
1:         assertTrue(rs.isBeforeFirst());
1:         assertFalse(rs.absolute(0));
1:         // still expected to be before first
1:         assertTrue(rs.isBeforeFirst());
1:         // go to first row
1:         assertTrue(rs.first());
1:         assertEquals(rs.getInt(1), 2);
1:         assertTrue(rs.isFirst());
1: 
1:         // move to before first
1:         rs.beforeFirst();
1:         assertTrue(rs.isBeforeFirst());
1:         // move to last row
1:         assertTrue(rs.last());
1:         assertTrue(rs.isLast());
1:         assertFalse(rs.isAfterLast());
1:         assertEquals(6, rs.getInt(1));
1:         assertFalse("not expecting to find another row", rs.next());
1:         assertTrue(rs.isAfterLast());
1:         // We're after the last row, verify that only isAfterLast()
1:         // returns true
1:         assertFalse(rs.isLast());
1:         assertFalse(rs.isFirst());
1:         assertFalse(rs.isBeforeFirst());
1:         assertEquals(ResultSet.FETCH_FORWARD, rs.getFetchDirection());
1:         rs.setFetchDirection(ResultSet.FETCH_UNKNOWN);
1:         assertEquals(ResultSet.FETCH_UNKNOWN, rs.getFetchDirection());
1:         if (isDerbyNetClient)
1:             assertEquals(64, rs.getFetchSize());
1:         else
1:             assertEquals(1, rs.getFetchSize());
1:         rs.setFetchSize(5);
1:         assertEquals(5, rs.getFetchSize());
1: 
1:         // setFetchSize() to 0 should have no effect.
1:         // for client server, fetchSize should have to 64
1:         rs.setFetchSize(0);
1:         if (isDerbyNetClient)
1:             assertEquals(64, rs.getFetchSize());
1:         else
1:             assertEquals(5, rs.getFetchSize());
1:         // done
1:         rs.close();
1: 
1:         // Empty result set tests (DERBY-992)
1:         rs = s_i_r.executeQuery("select * from t where 1=0");
1:         rs.afterLast();
1:         assertFalse("afterLast() on empty RS should be no-op", rs.isAfterLast());
1:         rs.beforeFirst();
1:         assertFalse("beforeFirst() on empty RS should be no-op", rs
1:                 .isBeforeFirst());
1: 
1:         rs.close();
1: 
0:         ps_i_r = conn.prepareStatement("select * from t",
1:                 ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);
1: 
1:         // We should not have gotten any warnings
1:         // and should have gotten a prepared scroll insensitive cursor
1:         warning = conn.getWarnings();
0:         assertNull(warning);
1: 
1:         rs = ps_i_r.executeQuery();
1:         // make sure it's scrollable
1:         rs.last();
1:         rs.close();
1:         ps_i_r.close();
1: 
1:         // Check setMaxRows()/getMaxRows()
1:         assertEquals(0, s_i_r.getMaxRows());
1:         s_i_r.setMaxRows(5);
1:         assertEquals(5, s_i_r.getMaxRows());
1: 
1:         rs = s_i_r.executeQuery("values 1, 2, 3, 4, 5, 6");
1:         assertNotNull(rs);
1:         // Iterate straight thru RS, expect only 5 rows.
1:         for (int index = 1; index < 6; index++) {
1:             assertTrue(rs.next());
1: 
1:         }
1:         // We should not see another row (only 5, not 6)
1:         assertFalse(rs.next());
1:         rs.close();
1:         // Jump around and verify setMaxRows() works.
1:         rs = s_i_r.executeQuery("values 1, 2, 3, 4, 5, 6");
1:         assertNotNull(rs);
1:         assertTrue(rs.last());
1: 
1:         // Iterate backwards thru RS, expect only 4 more (5 total) rows.
1:         for (int index = 1; index < 5; index++) {
1:             assertTrue(rs.previous());
1:         }
1:         // We should not see another row (only 5, not 6)
1:         assertFalse(rs.previous());
1:         rs.close();
1:         rs = s_i_r.executeQuery("values 1, 2, 3, 4, 5, 6");
1:         assertNotNull(rs);
1: 
1:         rs.afterLast();
1:         // Iterate backwards thru RS, expect only 5 rows.
1:         for (int index = 1; index < 6; index++) {
1:             assertTrue(rs.previous());
1: 
1:         }
1:         // We should not see another row (only 5, not 6)
1:         assertFalse(rs.previous());
1:         rs.close();
1:         // Verify setting maxRows back to 0 works.
1:         s_i_r.setMaxRows(0);
1:         rs = s_i_r.executeQuery("values 1, 2, 3, 4, 5, 6");
1:         assertNotNull(rs);
1: 
1:         // Iterate straight thru RS, expect 6 rows.
1:         for (int index = 1; index < 7; index++) {
1:             assertTrue(rs.next());
1: 
1:         }
1:         // We should not see another row
1:         assertFalse(rs.next());
1: 
1:         rs.close();
1: 
1:     }
1: 
1:     /**
1:      * Negative tests for scroll insensitive cursor.
1:      * 
1:      * @exception SQLException
1:      *                Thrown if some unexpected error happens
1:      */
1:     public void testScrollInsensitiveNegative() throws SQLException {
1:         Connection conn = getConnection();
0:         boolean passed = true;
1:         ResultSet rs;
1:         SQLWarning warning;
0:         Statement s_i_r = null; // insensitive, read only
1: 
0:         s_i_r = conn.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
1:                 ResultSet.CONCUR_READ_ONLY);
1: 
1:         // We should not have gotten any warnings
1:         // and should have gotten a scroll insensitive cursor
1:         warning = conn.getWarnings();
0:         assertNull(warning);
1:         conn.clearWarnings();
1: 
1:         // Verify that setMaxRows(-1) fails
1:         try {
1:             s_i_r.setMaxRows(-1);
1:             // Should never get here
1:             fail("setMaxRows(-1) expected to fail");
1:         } catch (SQLException sqle) {
1:             /* Check to be sure the exception is the one we expect */
1:             assertEquals("XJ063", sqle.getSQLState());
1: 
1:         }
1:         // Verify maxRows still 0
1:         assertEquals(0, s_i_r.getMaxRows());
1: 
1:         // Empty result set
1:         rs = s_i_r.executeQuery("select * from t where 1=0");
1:         // isBeforeFirst() and isAfterLast() should always return false
1:         // when result set is empty
1:         assertFalse(rs.isBeforeFirst());
1:         assertFalse(rs.next());
1:         assertFalse(rs.previous());
1:         assertFalse(rs.isAfterLast());
1:         assertFalse(rs.isFirst());
1:         assertFalse(rs.isLast());
1:         assertFalse(rs.relative(0));
1:         assertFalse(rs.relative(1));
1:         assertFalse(rs.relative(-1));
1:         assertFalse(rs.absolute(0));
1:         assertFalse(rs.absolute(1));
1:         assertFalse(rs.absolute(-1));
1:         rs.close();
1:         // End of empty result set tests
1: 
1:         // Non-empty result set
1:         rs = s_i_r.executeQuery("select * from t");
1:         // Negative fetch size
1:         try {
1:             rs.setFetchSize(-5);
1:             fail("setFetchSize(-5) expected to fail");
1: 
1:         } catch (SQLException sqle) {
1:             /* Check to be sure the exception is the one we expect */
1:             assertEquals("XJ062", sqle.getSQLState());
1: 
1:         }
1:         rs.close();
1:         s_i_r.close();
1:         
1:     }
1: 
1:     /**
1:      * Negative tests for scroll insensitive cursor.
1:      * 
1:      * @exception SQLException
1:      *                Thrown if some unexpected error happens
1:      */
1:     
1:     
1:     /**
1:      * CallableStatement tests.
1:      * 
1:      * @exception SQLException
1:      *                Thrown if some unexpected error happens
1:      */
1: 
1:     public void testCallableStatements() throws SQLException {
1:         Connection conn = getConnection();
1: 
1:         SQLWarning warning;
1:         CallableStatement cs_s_r = null; // sensitive, read only
1:         CallableStatement cs_s_u = null; // sensitive, updatable
1:         CallableStatement cs_i_r = null; // insensitive, read only
1:         CallableStatement cs_f_r = null; // forward only, read only
1: 
0:         cs_s_r = conn.prepareCall("values cast (? as Integer)",
1:                 ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_READ_ONLY);
1: 
1:         // We should have gotten 1 warnings
1:         warning = conn.getWarnings();
1:         assertNotNull(warning);
1:         if (!isDerbyNetClient)
1:             assertEquals("01J02", warning.getSQLState());
1:         else
1:             assertEquals("01J10", warning.getSQLState());
1: 
0:         assertNull(warning.getNextWarning());
1: 
1:         conn.clearWarnings();
1:         cs_s_r.close();
1: 
0:         cs_s_u = conn.prepareCall("values cast (? as Integer)",
1:                 ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);
1: 
1:         // We should have gotten 1 warning
1:         warning = conn.getWarnings();
1:         assertNotNull(warning);
1:         if (!isDerbyNetClient)
1:             assertEquals("01J02", warning.getSQLState());
1:         else
1:             assertEquals("01J10", warning.getSQLState());
1: 
0:         assertNull(warning.getNextWarning());
1:         conn.clearWarnings();
1:         cs_s_u.close();
1: 
0:         cs_i_r = conn.prepareCall("values cast (? as Integer)",
1:                 ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);
1: 
1:         // We should have gotten 0 warnings
1:         warning = conn.getWarnings();
0:         assertNull(warning);
1: 
1:         conn.clearWarnings();
1:         cs_i_r.close();
1: 
0:         cs_f_r = conn.prepareCall("values cast (? as Integer)",
1:                 ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);
1: 
1:         // We should have gotten 0 warnings
1:         warning = conn.getWarnings();
0:         assertNull(warning);
1: 
1:         conn.clearWarnings();
1:         cs_f_r.close();
1: 
1:     }
1: 
1:     /**
1:      * Tests for PreparedStatement.getMetaData().
1:      * 
1:      * @exception SQLException
1:      *                Thrown if some unexpected error happens
1:      */
1:     public void testGetMetaData() throws SQLException {
1:         Connection conn = getConnection();
1:         PreparedStatement ps_f_r = null; // forward only, read only
1:         ResultSet rs;
1:         ResultSetMetaData rsmd_ps;
1:         ResultSetMetaData rsmd_rs;
1:         SQLWarning warning;
1: 
0:         ps_f_r = conn.prepareStatement("select c50, i, 43 from t",
1:                 ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);
1: 
1:         rsmd_ps = ps_f_r.getMetaData();
1:         assertNotNull(rsmd_ps);
1: 
1:         // Now get meta data from result set
1:         rs = ps_f_r.executeQuery();
1:         rsmd_rs = rs.getMetaData();
1:         assertNotNull(rsmd_rs);
1: 
1:         // check column count
1:         assertEquals(rsmd_ps.getColumnCount(), rsmd_rs.getColumnCount());
1: 
1:         // get column name for 2nd column
1:         assertEquals(rsmd_ps.getColumnName(2), rsmd_rs.getColumnName(2));
1:         assertEquals(rsmd_ps.isReadOnly(2), rsmd_rs.isReadOnly(2));
1: 
1:         rs.close();
1:         ps_f_r.close();
1: 
1:     }
1: 
1:     public void testScrollVerifyMaxRowWithFetchSize() throws SQLException {
1:         scrollVerifyMaxRowWithFetchSize(10, 10);
1:         scrollVerifyMaxRowWithFetchSize(10, 5);
1:         scrollVerifyMaxRowWithFetchSize(10, 0);
1:         scrollVerifyMaxRowWithFetchSize(0, 0);
1:         scrollVerifyMaxRowWithFetchSize(0, 5);
1:         scrollVerifyMaxRowWithFetchSize(0, 10);
1:         scrollVerifyMaxRowWithFetchSize(0, 15);
1:     }
1: 
1:     /**
1:      * Tests for maxRow and fetchSize with scrollable cursors
1:      * 
1:      * 
1:      * @param maxRows
1:      *            The maxRows value to use
1:      * @param fetchSize
1:      *            The fetchSize value to use
1:      * 
1:      * @exception SQLException
1:      *                Thrown if some unexpected error happens
1:      */
1:     private void scrollVerifyMaxRowWithFetchSize(int maxRows, int fetchSize)
1:             throws SQLException {
1:         Connection conn = getConnection();
1:         ResultSet rs;
0:         boolean passed = true;
0:         Statement s_i_r = null;
0:         s_i_r = conn.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
1:                 ResultSet.CONCUR_READ_ONLY);
1:         s_i_r.setMaxRows(maxRows);
1: 
1:         // Execute query
1:         rs = s_i_r
1:                 .executeQuery("values 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15");
1:         rs.setFetchSize(fetchSize);
1: 
1:         // this should not affect the ResultSet because
1:         s_i_r.setMaxRows(2);
1:         if (maxRows == 0)
1:             maxRows = 15;
1:         assertNotNull(rs);
1: 
1:         // Start from before first
1:         // Iterate straight thru RS, expect only maxRows rows.
1:         for (int index = 1; index < maxRows + 1; index++) {
1:             assertTrue("rs.next() failed, index = " + index, rs.next());
1:             assertEquals(index, rs.getInt(1));
1: 
1:         }
1:         // We should not see another row (only maxRows, not total)
1:         assertFalse(rs.next());
1: 
1:         // Start from first and verify maxRows
1:         assertTrue(rs.first());
1: 
1:         // Iterate forward thru RS, expect only (maxRows - 1) more rows.
1:         for (int index = 1; index < maxRows; index++) {
1:             assertTrue(rs.next());
1:             assertEquals(index + 1, rs.getInt(1));
1: 
1:         }
1:         // We should not see another row (only maxRows, not total)
1:         assertFalse(rs.next());
1: 
1:         // Start from afterLast and verify maxRows
1:         rs.afterLast();
1:         // Iterate backwards thru RS, expect only (maxRows - 1) rows.
1:         for (int index = 1; index < maxRows + 1; index++) {
1:             assertTrue(rs.previous());
1:             assertEquals(maxRows - index + 1, rs.getInt(1));
1:         }
1:         // We should not see another row (only maxRows, not total)
1:         assertFalse(rs.previous());
1: 
1:         // Start from last and verify maxRows
1:         assertTrue(rs.last());
1: 
1:         // Iterate backwards thru RS, expect only (maxRows - 1) more rows.
1:         for (int index = 1; index < maxRows; index++) {
1:             assertTrue(rs.previous());
1:             assertEquals((maxRows - index), rs.getInt(1));
1: 
1:         }
1:         // We should not see another row (only 5, not 6)
1:         assertFalse(rs.previous());
1:         rs.last();
1:         int rows = rs.getRow();
1: 
1:         rs.absolute(rows / 2);
1:         assertFalse(rs.relative(-1 * (rows)));
1:         assertTrue(rs.isBeforeFirst());
1: 
1:         rs.absolute(rows / 2);
1:         assertFalse(rs.relative(rows));
1:         assertTrue(rs.isAfterLast());
1:         rs.absolute(rows / 2);
1:         assertFalse("absolute(" + (rows + 1)
1:                 + ") should return false, position outside of the resultSet",
1:                 rs.absolute(rows + 1));
1: 
1:         rs.absolute(rows / 2);
1:         assertFalse(rs.absolute((-1) * (rows + 1)));
1: 
1:         assertTrue(rs.isBeforeFirst());
1: 
1:         rs.close();
1: 
1:     }
1: 
1:     private void assertOnlyOnScrollableException(SQLException sqle) {
1:         if (!isDerbyNetClient) {
1:             assertEquals("XJ061", sqle.getSQLState());
1:         } else {
1:             assertEquals("XJ125", sqle.getSQLState());
1:         }
1:     }
1: 
1:     public static Test suite() {
1:         return TestConfiguration.defaultSuite(ScrollCursors2Test.class);
1:     }
1: 
1: }
author:Army
-------------------------------------------------------------------------------
commit:4ef879d
/////////////////////////////////////////////////////////////////////////
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:e8c84af
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derbyTesting.junit.JDBC;
/////////////////////////////////////////////////////////////////////////
0:         assertEquals(5,rs.getFetchSize());
0:       
0:         assertEquals(ResultSet.FETCH_FORWARD,rs.getFetchDirection());
0:             
/////////////////////////////////////////////////////////////////////////
0:         assertNull(warning);
0:         
0:         assertEquals(ResultSet.TYPE_FORWARD_ONLY, rs.getType());
0:         
0:         assertEquals(ResultSet.CONCUR_READ_ONLY,rs.getConcurrency());
0:         
/////////////////////////////////////////////////////////////////////////
0:         assertNotNull(rs);
0:         JDBC.assertDrainResults(rs, 5);
0:         
/////////////////////////////////////////////////////////////////////////
0:     public void testScrollInsensitivePositive() throws SQLException {
/////////////////////////////////////////////////////////////////////////
0:     public void testScrollInsensitiveNegative() throws SQLException {
/////////////////////////////////////////////////////////////////////////
0:         rs.close();
0:         
/////////////////////////////////////////////////////////////////////////
0:     
0:     
/////////////////////////////////////////////////////////////////////////
0:     private void scrollVerifyMaxRowWithFetchSize(int maxRows, int fetchSize)
commit:f19e86d
/////////////////////////////////////////////////////////////////////////
0: /**
0:  *  Derby - Class org.apache.derbyTesting.functionTests.tests.lang.ScrollCursors2Test
0:  *  
0:  * Licensed to the Apache Software Foundation (ASF) under one
0:  * or more contributor license agreements.  See the NOTICE file
0:  * distributed with this work for additional information
0:  * regarding copyright ownership.  The ASF licenses this file
0:  * to you under the Apache License, Version 2.0 (the
0:  * "License"); you may not use this file except in compliance
0:  * with the License.  You may obtain a copy of the License at
0:  *
0:  *   http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  * Unless required by applicable law or agreed to in writing,
0:  * software distributed under the License is distributed on an
0:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
0:  * KIND, either express or implied.  See the License for the
0:  * specific language governing permissions and limitations
0:  * under the License.
0:  */
0: 
0: package org.apache.derbyTesting.functionTests.tests.lang;
0: 
0: import java.sql.CallableStatement;
0: import java.sql.Connection;
0: import java.sql.PreparedStatement;
0: import java.sql.ResultSet;
0: import java.sql.ResultSetMetaData;
0: import java.sql.SQLException;
0: import java.sql.SQLWarning;
0: import java.sql.Statement;
0: 
0: import junit.framework.Test;
0: 
0: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
0: import org.apache.derbyTesting.junit.TestConfiguration;
0: 
0: public class ScrollCursors2Test extends BaseJDBCTestCase {
0: 
0:     public ScrollCursors2Test(String name) {
0:         super(name);
0: 
0:     }
0: 
0:     private static boolean isDerbyNetClient = usingDerbyNetClient();
0: 
0:     /**
0:      * Set up the test.
0:      * 
0:      * This method creates the table used by the rest of the test.
0:      * 
0:      * 
0:      * @exception SQLException
0:      *                Thrown if some unexpected error happens
0:      */
0: 
0:     public void setUp() throws SQLException {
0:         Connection conn = getConnection();
0: 
0:         Statement s_i_r;
0: 
0:         s_i_r = conn.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
0:                 ResultSet.CONCUR_READ_ONLY);
0: 
0:         /* Create a table */
0:         s_i_r.execute("create table t (i int, c50 char(50))");
0: 
0:         /* Populate the table */
0:         s_i_r.execute("insert into t (i) values (2), (3), (4), (5), (6)");
0:         s_i_r.execute("update t set c50 = RTRIM(CAST (i AS CHAR(50)))");
0:         s_i_r.close();
0:         isDerbyNetClient = usingDerbyNetClient();
0:     }
0: 
0:     public void tearDown() throws SQLException, Exception {
0:         Connection conn = getConnection();
0:         Statement s = conn.createStatement();
0:         s.execute("drop table t");
0:         conn.commit();
0:         super.tearDown();
0:     }
0: 
0:     public void testForwardOnlyNegative() throws SQLException {
0:         Connection conn = getConnection();
0:         PreparedStatement ps_f_r = null;
0:         ResultSet rs;
0:         SQLWarning warning;
0:         Statement s_f_r = null;
0: 
0:         s_f_r = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY,
0:                 ResultSet.CONCUR_READ_ONLY);
0:         // We should have gotten no warnings and a read only forward only cursor
0:         warning = conn.getWarnings();
0:         assertNull(warning);
0: 
0:         conn.clearWarnings();
0: 
0:         // Verify that setMaxRows(-1) fails
0:         try {
0:             s_f_r.setMaxRows(-1);
0:             // Should never get here
0:             fail("setMaxRows(-1) expected to fail");
0:         } catch (SQLException sqle) {
0:             /* Check to be sure the exception is the one we expect */
0: 
0:             assertEquals("XJ063", sqle.getSQLState());
0:         }
0:         // Verify maxRows still 0
0:         assertEquals("getMaxRows() expected to return 0", 0, s_f_r.getMaxRows());
0: 
0:         // Verify that result set from statement is
0:         // scroll insensitive and read only
0:         rs = s_f_r.executeQuery("select * from t");
0:         assertEquals(ResultSet.TYPE_FORWARD_ONLY, rs.getType());
0:         assertEquals(ResultSet.CONCUR_READ_ONLY, rs.getConcurrency());
0: 
0:         // Verify that first(), etc. don't work
0:         try {
0:             rs.first();
0:             // Should never get here
0:             fail("first() expected to fail");
0:         } catch (SQLException sqle) {
0:             assertOnlyOnScrollableException(sqle);
0:         }
0: 
0:         try {
0:             rs.beforeFirst();
0:             // Should never get here
0:             fail("beforeFirst() expected to fail");
0:         } catch (SQLException sqle) {
0:             assertOnlyOnScrollableException(sqle);
0: 
0:         }
0:         try {
0:             rs.isBeforeFirst();
0:             // Should never get here
0:             fail("isBeforeFirst() expected to fail");
0: 
0:         } catch (SQLException sqle) {
0:             // Check to be sure the exception is the one we expect
0:             assertOnlyOnScrollableException(sqle);
0:         }
0:         try {
0:             rs.isAfterLast();
0:             // Should never get here
0:             fail("isAfterLast() expected to fail");
0:         } catch (SQLException sqle) {
0:             // Check to be sure the exception is the one we expect
0:             assertOnlyOnScrollableException(sqle);
0: 
0:         }
0:         try {
0:             rs.isFirst();
0:             // Should never get here
0:             fail("isFirst() expected to fail");
0:         } catch (SQLException sqle) {
0:             // Check to be sure the exception is the one we expect
0:             assertOnlyOnScrollableException(sqle);
0: 
0:         }
0:         try {
0:             rs.isLast();
0:             // Should never get here
0:             fail("isLast() expected to fail");
0:         } catch (SQLException sqle) {
0:             // Check to be sure the exception is the one we expect
0: 
0:             assertOnlyOnScrollableException(sqle);
0: 
0:         }
0:         try {
0:             rs.absolute(1);
0:             // Should never get here
0:             fail("absolute() expected to fail");
0:         } catch (SQLException sqle) {
0:             assertOnlyOnScrollableException(sqle);
0: 
0:         }
0:         try {
0:             rs.relative(1);
0:             // Should never get here
0:             fail("relative() expected to fail");
0:         } catch (SQLException sqle) {
0:             assertOnlyOnScrollableException(sqle);
0:         }
0: 
0:         // setFetchDirection should fail
0:         try {
0:             rs.setFetchDirection(ResultSet.FETCH_FORWARD);
0:             // Should never get here
0:             fail("setFetchDirection() expected to fail");
0:         } catch (SQLException sqle) {
0:             assertOnlyOnScrollableException(sqle);
0:         }
0: 
0:         // Book says that getFetchDirection(), getFetchSize() and
0:         // setFetchSize() are all okay.
0:         if (isDerbyNetClient)
0:             assertEquals(0, rs.getFetchSize());
0:         else
0:             assertEquals(1, rs.getFetchSize());
0: 
0:         rs.setFetchSize(5);
0:         if (rs.getFetchSize() != 5) {
0:             fail("getFetchSize() expected to return 5");
0:         }
0: 
0:         if (rs.getFetchDirection() != ResultSet.FETCH_FORWARD) {
0:             fail("getFetchDirection() expected to return FETCH_FORWARD, not "
0:                     + rs.getFetchDirection());
0:         }
0: 
0:         rs.close();
0:         s_f_r.close();
0: 
0:         ps_f_r = conn.prepareStatement("select * from t",
0:                 ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);
0:         // We should have gotten no warnings and a read only forward only cursor
0:         warning = conn.getWarnings();
0:         while (warning != null) {
0:             System.out.println("warning = " + warning);
0:             warning = warning.getNextWarning();
0:         }
0:         conn.clearWarnings();
0: 
0:         // Verify that result set from statement is
0:         // scroll insensitive and read only
0:         rs = ps_f_r.executeQuery();
0:         if (rs.getType() != ResultSet.TYPE_FORWARD_ONLY) {
0:             System.out.println("cursor type = " + rs.getType() + ", not "
0:                     + ResultSet.TYPE_FORWARD_ONLY);
0:         }
0:         if (rs.getConcurrency() != ResultSet.CONCUR_READ_ONLY) {
0:             System.out.println("concurrency = " + rs.getConcurrency()
0:                     + ", not " + ResultSet.CONCUR_READ_ONLY);
0:         }
0: 
0:         // Verify that first() doesn't work
0:         try {
0:             rs.first();
0:             // Should never get here
0:             fail("first() expected to fail");
0:         } catch (SQLException sqle) {
0:             assertOnlyOnScrollableException(sqle);
0: 
0:         }
0:         rs.close();
0:         ps_f_r.close();
0: 
0:     }
0: 
0:     /**
0:      * Positive tests for forward only cursors.
0:      * 
0:      * This method tests forward only cursors.
0:      * 
0:      * 
0:      * @exception SQLException
0:      *                Thrown if some unexpected error happens
0:      */
0: 
0:     public void testForwardOnlyPositive() throws SQLException {
0:         Connection conn = getConnection();
0:         boolean passed = true;
0:         ResultSet rs;
0:         SQLWarning warning;
0:         Statement s_f_r = null;
0: 
0:         s_f_r = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY,
0:                 ResultSet.CONCUR_READ_ONLY);
0:         // We should have gotten no warnings and a read only forward only cursor
0:         warning = conn.getWarnings();
0:         assertNull(warning);
0:         conn.clearWarnings();
0: 
0:         // Verify that setMaxRows(4) succeeds
0:         s_f_r.setMaxRows(5);
0:         assertEquals(5, s_f_r.getMaxRows());
0: 
0:         rs = s_f_r.executeQuery("values 1, 2, 3, 4, 5, 6");
0:         if (rs == null) {
0:             fail("rs expected to be non-null.");
0:         }
0:         // Iterate straight thru RS, expect only 5 rows.
0:         for (int index = 1; index < 6; index++) {
0:             if (!rs.next()) {
0:                 fail("rs.next() failed, index = " + index);
0:                 break;
0:             }
0:         }
0:         // We should not see another row (only 5, not 6)
0:         if (rs.next()) {
0:             fail("rs.next() failed, should not have seen 6th row.");
0:             passed = false;
0:         }
0:         rs.close();
0:         s_f_r.close();
0: 
0:     }
0: 
0:     /**
0:      * Scroll sensitive cursor tests
0:      * 
0:      * This method tests scroll sensitive cursors. (Not implemented, so we
0:      * should get back scroll insensitive curors with read only concurrency.)
0:      * 
0:      * @exception SQLException
0:      *                Thrown if some unexpected error happens
0:      */
0: 
0:     public void testScrollSensitive() throws SQLException {
0:         Connection conn = getConnection();
0:         ResultSet rs;
0:         SQLWarning warning;
0:         Statement s_s_r = null; // sensitive, read only
0:         Statement s_s_u = null; // sensitive, updatable
0: 
0:         s_s_r = conn.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE,
0:                 ResultSet.CONCUR_READ_ONLY);
0: 
0:         // We should have gotten a warning and a scroll insensitive cursor
0:         warning = conn.getWarnings();
0:         assertNotNull(warning);
0:         conn.clearWarnings();
0: 
0:         // Verify that result set from statement is
0:         // scroll insensitive and read only
0:         rs = s_s_r.executeQuery("select * from t");
0:         assertEquals(ResultSet.TYPE_SCROLL_INSENSITIVE, rs.getType());
0:         assertEquals(ResultSet.CONCUR_READ_ONLY, rs.getConcurrency());
0:         rs.close();
0: 
0:         // Close the statement
0:         s_s_r.close();
0: 
0:         s_s_u = conn.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE,
0:                 ResultSet.CONCUR_UPDATABLE);
0:         // We should have gotten 1 warning and a updatable scroll
0:         // insensitive cursor.
0:         warning = conn.getWarnings();
0:         assertNotNull(warning);
0:         conn.clearWarnings();
0: 
0:         // Verify that result set from statement is
0:         // scroll insensitive and read only
0:         rs = s_s_u.executeQuery("select * from t");
0:         assertEquals(ResultSet.TYPE_SCROLL_INSENSITIVE, rs.getType());
0:         assertEquals(ResultSet.CONCUR_UPDATABLE, rs.getConcurrency());
0: 
0:         rs.close();
0:     }
0: 
0:     /**
0:      * Positive tests for scroll insensitive cursor.
0:      * 
0:      * 
0:      * @exception SQLException
0:      *                Thrown if some unexpected error happens
0:      */
0:     public void scrollInsensitivePositive() throws SQLException {
0:         Connection conn = getConnection();
0:         boolean passed = true;
0:         PreparedStatement ps_i_r = null;
0:         ResultSet rs;
0:         SQLWarning warning;
0:         Statement s_i_r = null; // insensitive, read only
0: 
0:         s_i_r = conn.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
0:                 ResultSet.CONCUR_READ_ONLY);
0: 
0:         // We should not have gotten any warnings
0:         // and should have gotten a scroll insensitive cursor
0:         warning = conn.getWarnings();
0:         assertNull(warning);
0: 
0:         conn.clearWarnings();
0: 
0:         // run a query
0:         rs = s_i_r.executeQuery("select * from t");
0:         // verify scroll insensitive and read only
0:         assertEquals(ResultSet.TYPE_SCROLL_INSENSITIVE, rs.getType());
0:         assertEquals(ResultSet.CONCUR_READ_ONLY, rs.getConcurrency());
0:         // We should be positioned before the 1st row
0:         assertTrue(rs.isBeforeFirst());
0:         assertFalse(rs.absolute(0));
0:         // still expected to be before first
0:         assertTrue(rs.isBeforeFirst());
0:         // go to first row
0:         assertTrue(rs.first());
0:         assertEquals(rs.getInt(1), 2);
0:         assertTrue(rs.isFirst());
0: 
0:         // move to before first
0:         rs.beforeFirst();
0:         assertTrue(rs.isBeforeFirst());
0:         // move to last row
0:         assertTrue(rs.last());
0:         assertTrue(rs.isLast());
0:         assertFalse(rs.isAfterLast());
0:         assertEquals(6, rs.getInt(1));
0:         assertFalse("not expecting to find another row", rs.next());
0:         assertTrue(rs.isAfterLast());
0:         // We're after the last row, verify that only isAfterLast()
0:         // returns true
0:         assertFalse(rs.isLast());
0:         assertFalse(rs.isFirst());
0:         assertFalse(rs.isBeforeFirst());
0:         assertEquals(ResultSet.FETCH_FORWARD, rs.getFetchDirection());
0:         rs.setFetchDirection(ResultSet.FETCH_UNKNOWN);
0:         assertEquals(ResultSet.FETCH_UNKNOWN, rs.getFetchDirection());
0:         if (isDerbyNetClient)
0:             assertEquals(64, rs.getFetchSize());
0:         else
0:             assertEquals(1, rs.getFetchSize());
0:         rs.setFetchSize(5);
0:         assertEquals(5, rs.getFetchSize());
0: 
0:         // setFetchSize() to 0 should have no effect.
0:         // for client server, fetchSize should have to 64
0:         rs.setFetchSize(0);
0:         if (isDerbyNetClient)
0:             assertEquals(64, rs.getFetchSize());
0:         else
0:             assertEquals(5, rs.getFetchSize());
0:         // done
0:         rs.close();
0: 
0:         // Empty result set tests (DERBY-992)
0:         rs = s_i_r.executeQuery("select * from t where 1=0");
0:         rs.afterLast();
0:         assertFalse("afterLast() on empty RS should be no-op", rs.isAfterLast());
0:         rs.beforeFirst();
0:         assertFalse("beforeFirst() on empty RS should be no-op", rs
0:                 .isBeforeFirst());
0: 
0:         rs.close();
0: 
0:         ps_i_r = conn.prepareStatement("select * from t",
0:                 ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);
0: 
0:         // We should not have gotten any warnings
0:         // and should have gotten a prepared scroll insensitive cursor
0:         warning = conn.getWarnings();
0:         assertNull(warning);
0: 
0:         rs = ps_i_r.executeQuery();
0:         // make sure it's scrollable
0:         rs.last();
0:         rs.close();
0:         ps_i_r.close();
0: 
0:         // Check setMaxRows()/getMaxRows()
0:         assertEquals(0, s_i_r.getMaxRows());
0:         s_i_r.setMaxRows(5);
0:         assertEquals(5, s_i_r.getMaxRows());
0: 
0:         rs = s_i_r.executeQuery("values 1, 2, 3, 4, 5, 6");
0:         assertNotNull(rs);
0:         // Iterate straight thru RS, expect only 5 rows.
0:         for (int index = 1; index < 6; index++) {
0:             assertTrue(rs.next());
0: 
0:         }
0:         // We should not see another row (only 5, not 6)
0:         assertFalse(rs.next());
0:         rs.close();
0:         // Jump around and verify setMaxRows() works.
0:         rs = s_i_r.executeQuery("values 1, 2, 3, 4, 5, 6");
0:         assertNotNull(rs);
0:         assertTrue(rs.last());
0: 
0:         // Iterate backwards thru RS, expect only 4 more (5 total) rows.
0:         for (int index = 1; index < 5; index++) {
0:             assertTrue(rs.previous());
0:         }
0:         // We should not see another row (only 5, not 6)
0:         assertFalse(rs.previous());
0:         rs.close();
0:         rs = s_i_r.executeQuery("values 1, 2, 3, 4, 5, 6");
0:         assertNotNull(rs);
0: 
0:         rs.afterLast();
0:         // Iterate backwards thru RS, expect only 5 rows.
0:         for (int index = 1; index < 6; index++) {
0:             assertTrue(rs.previous());
0: 
0:         }
0:         // We should not see another row (only 5, not 6)
0:         assertFalse(rs.previous());
0:         rs.close();
0:         // Verify setting maxRows back to 0 works.
0:         s_i_r.setMaxRows(0);
0:         rs = s_i_r.executeQuery("values 1, 2, 3, 4, 5, 6");
0:         assertNotNull(rs);
0: 
0:         // Iterate straight thru RS, expect 6 rows.
0:         for (int index = 1; index < 7; index++) {
0:             assertTrue(rs.next());
0: 
0:         }
0:         // We should not see another row
0:         assertFalse(rs.next());
0: 
0:         rs.close();
0: 
0:     }
0: 
0:     /**
0:      * Negative tests for scroll insensitive cursor.
0:      * 
0:      * @exception SQLException
0:      *                Thrown if some unexpected error happens
0:      */
0:     public void scrollInsensitiveNegative() throws SQLException {
0:         Connection conn = getConnection();
0:         boolean passed = true;
0:         ResultSet rs;
0:         SQLWarning warning;
0:         Statement s_i_r = null; // insensitive, read only
0: 
0:         s_i_r = conn.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
0:                 ResultSet.CONCUR_READ_ONLY);
0: 
0:         // We should not have gotten any warnings
0:         // and should have gotten a scroll insensitive cursor
0:         warning = conn.getWarnings();
0:         assertNull(warning);
0:         conn.clearWarnings();
0: 
0:         // Verify that setMaxRows(-1) fails
0:         try {
0:             s_i_r.setMaxRows(-1);
0:             // Should never get here
0:             fail("setMaxRows(-1) expected to fail");
0:         } catch (SQLException sqle) {
0:             /* Check to be sure the exception is the one we expect */
0:             assertEquals("XJ063", sqle.getSQLState());
0: 
0:         }
0:         // Verify maxRows still 0
0:         assertEquals(0, s_i_r.getMaxRows());
0: 
0:         // Empty result set
0:         rs = s_i_r.executeQuery("select * from t where 1=0");
0:         // isBeforeFirst() and isAfterLast() should always return false
0:         // when result set is empty
0:         assertFalse(rs.isBeforeFirst());
0:         assertFalse(rs.next());
0:         assertFalse(rs.previous());
0:         assertFalse(rs.isAfterLast());
0:         assertFalse(rs.isFirst());
0:         assertFalse(rs.isLast());
0:         assertFalse(rs.relative(0));
0:         assertFalse(rs.relative(1));
0:         assertFalse(rs.relative(-1));
0:         assertFalse(rs.absolute(0));
0:         assertFalse(rs.absolute(1));
0:         assertFalse(rs.absolute(-1));
0:         rs.close();
0:         // End of empty result set tests
0: 
0:         // Non-empty result set
0:         rs = s_i_r.executeQuery("select * from t");
0:         // Negative fetch size
0:         try {
0:             rs.setFetchSize(-5);
0:             fail("setFetchSize(-5) expected to fail");
0: 
0:         } catch (SQLException sqle) {
0:             /* Check to be sure the exception is the one we expect */
0:             assertEquals("XJ062", sqle.getSQLState());
0: 
0:         }
0: 
0:         s_i_r.close();
0: 
0:     }
0: 
0:     /**
0:      * Negative tests for scroll insensitive cursor.
0:      * 
0:      * @exception SQLException
0:      *                Thrown if some unexpected error happens
0:      */
0:     public void testScrollInsensitiveNegative() throws SQLException {
0:         Connection conn = getConnection();
0:         ResultSet rs;
0:         SQLWarning warning;
0:         Statement s_i_r = null; // insensitive, read only
0: 
0:         s_i_r = conn.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
0:                 ResultSet.CONCUR_READ_ONLY);
0: 
0:         // We should not have gotten any warnings
0:         // and should have gotten a scroll insensitive cursor
0:         warning = conn.getWarnings();
0:         assertNull(warning);
0:         conn.clearWarnings();
0: 
0:         // Verify that setMaxRows(-1) fails
0:         try {
0:             s_i_r.setMaxRows(-1);
0:             // Should never get here
0:             fail("setMaxRows(-1) expected to fail");
0:         } catch (SQLException sqle) {
0:             /* Check to be sure the exception is the one we expect */
0:             assertEquals("XJ063", sqle.getSQLState());
0: 
0:         }
0:         // Verify maxRows still 0
0:         assertEquals(0, s_i_r.getMaxRows());
0: 
0:         // Empty result set
0:         rs = s_i_r.executeQuery("select * from t where 1=0");
0:         // isBeforeFirst() and isAfterLast() should always return false
0:         // when result set is empty
0:         assertFalse(rs.isBeforeFirst());
0:         assertFalse(rs.next());
0:         assertFalse(rs.previous());
0:         assertFalse(rs.isAfterLast());
0:         assertFalse(rs.isFirst());
0:         assertFalse(rs.isLast());
0:         assertFalse(rs.relative(0));
0:         assertFalse(rs.relative(1));
0:         assertFalse(rs.relative(-1));
0:         assertFalse(rs.absolute(0));
0:         assertFalse(rs.absolute(1));
0:         assertFalse(rs.absolute(-1));
0: 
0:         rs.close();
0:         // End of empty result set tests
0: 
0:         // Non-empty result set
0:         rs = s_i_r.executeQuery("select * from t");
0:         // Negative fetch size
0:         try {
0:             rs.setFetchSize(-5);
0:             fail("setFetchSize(-5) expected to fail");
0:         } catch (SQLException sqle) {
0:             /* Check to be sure the exception is the one we expect */
0:             assertEquals("XJ062", sqle.getSQLState());
0:         }
0: 
0:         s_i_r.close();
0: 
0:     }
0: 
0:     /**
0:      * CallableStatement tests.
0:      * 
0:      * @exception SQLException
0:      *                Thrown if some unexpected error happens
0:      */
0: 
0:     public void testCallableStatements() throws SQLException {
0:         Connection conn = getConnection();
0: 
0:         SQLWarning warning;
0:         CallableStatement cs_s_r = null; // sensitive, read only
0:         CallableStatement cs_s_u = null; // sensitive, updatable
0:         CallableStatement cs_i_r = null; // insensitive, read only
0:         CallableStatement cs_f_r = null; // forward only, read only
0: 
0:         cs_s_r = conn.prepareCall("values cast (? as Integer)",
0:                 ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_READ_ONLY);
0: 
0:         // We should have gotten 1 warnings
0:         warning = conn.getWarnings();
0:         assertNotNull(warning);
0:         if (!isDerbyNetClient)
0:             assertEquals("01J02", warning.getSQLState());
0:         else
0:             assertEquals("01J10", warning.getSQLState());
0: 
0:         assertNull(warning.getNextWarning());
0: 
0:         conn.clearWarnings();
0:         cs_s_r.close();
0: 
0:         cs_s_u = conn.prepareCall("values cast (? as Integer)",
0:                 ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);
0: 
0:         // We should have gotten 1 warning
0:         warning = conn.getWarnings();
0:         assertNotNull(warning);
0:         if (!isDerbyNetClient)
0:             assertEquals("01J02", warning.getSQLState());
0:         else
0:             assertEquals("01J10", warning.getSQLState());
0: 
0:         assertNull(warning.getNextWarning());
0:         conn.clearWarnings();
0:         cs_s_u.close();
0: 
0:         cs_i_r = conn.prepareCall("values cast (? as Integer)",
0:                 ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);
0: 
0:         // We should have gotten 0 warnings
0:         warning = conn.getWarnings();
0:         assertNull(warning);
0: 
0:         conn.clearWarnings();
0:         cs_i_r.close();
0: 
0:         cs_f_r = conn.prepareCall("values cast (? as Integer)",
0:                 ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);
0: 
0:         // We should have gotten 0 warnings
0:         warning = conn.getWarnings();
0:         assertNull(warning);
0: 
0:         conn.clearWarnings();
0:         cs_f_r.close();
0: 
0:     }
0: 
0:     /**
0:      * Tests for PreparedStatement.getMetaData().
0:      * 
0:      * @exception SQLException
0:      *                Thrown if some unexpected error happens
0:      */
0:     public void testGetMetaData() throws SQLException {
0:         Connection conn = getConnection();
0:         PreparedStatement ps_f_r = null; // forward only, read only
0:         ResultSet rs;
0:         ResultSetMetaData rsmd_ps;
0:         ResultSetMetaData rsmd_rs;
0:         SQLWarning warning;
0: 
0:         ps_f_r = conn.prepareStatement("select c50, i, 43 from t",
0:                 ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);
0: 
0:         rsmd_ps = ps_f_r.getMetaData();
0:         assertNotNull(rsmd_ps);
0: 
0:         // Now get meta data from result set
0:         rs = ps_f_r.executeQuery();
0:         rsmd_rs = rs.getMetaData();
0:         assertNotNull(rsmd_rs);
0: 
0:         // check column count
0:         assertEquals(rsmd_ps.getColumnCount(), rsmd_rs.getColumnCount());
0: 
0:         // get column name for 2nd column
0:         assertEquals(rsmd_ps.getColumnName(2), rsmd_rs.getColumnName(2));
0:         assertEquals(rsmd_ps.isReadOnly(2), rsmd_rs.isReadOnly(2));
0: 
0:         rs.close();
0:         ps_f_r.close();
0: 
0:     }
0: 
0:     public void testScrollVerifyMaxRowWithFetchSize() throws SQLException {
0:         scrollVerifyMaxRowWithFetchSize(10, 10);
0:         scrollVerifyMaxRowWithFetchSize(10, 5);
0:         scrollVerifyMaxRowWithFetchSize(10, 0);
0:         scrollVerifyMaxRowWithFetchSize(0, 0);
0:         scrollVerifyMaxRowWithFetchSize(0, 5);
0:         scrollVerifyMaxRowWithFetchSize(0, 10);
0:         scrollVerifyMaxRowWithFetchSize(0, 15);
0:     }
0: 
0:     /**
0:      * Tests for maxRow and fetchSize with scrollable cursors
0:      * 
0:      * 
0:      * @param maxRows
0:      *            The maxRows value to use
0:      * @param fetchSize
0:      *            The fetchSize value to use
0:      * 
0:      * @return Whether or not we were successful.
0:      * 
0:      * @exception SQLException
0:      *                Thrown if some unexpected error happens
0:      */
0:     public void scrollVerifyMaxRowWithFetchSize(int maxRows, int fetchSize)
0:             throws SQLException {
0:         Connection conn = getConnection();
0:         ResultSet rs;
0:         boolean passed = true;
0:         Statement s_i_r = null;
0:         s_i_r = conn.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
0:                 ResultSet.CONCUR_READ_ONLY);
0:         s_i_r.setMaxRows(maxRows);
0: 
0:         // Execute query
0:         rs = s_i_r
0:                 .executeQuery("values 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15");
0:         rs.setFetchSize(fetchSize);
0: 
0:         // this should not affect the ResultSet because
0:         s_i_r.setMaxRows(2);
0:         if (maxRows == 0)
0:             maxRows = 15;
0:         assertNotNull(rs);
0: 
0:         // Start from before first
0:         // Iterate straight thru RS, expect only maxRows rows.
0:         for (int index = 1; index < maxRows + 1; index++) {
0:             assertTrue("rs.next() failed, index = " + index, rs.next());
0:             assertEquals(index, rs.getInt(1));
0: 
0:         }
0:         // We should not see another row (only maxRows, not total)
0:         assertFalse(rs.next());
0: 
0:         // Start from first and verify maxRows
0:         assertTrue(rs.first());
0: 
0:         // Iterate forward thru RS, expect only (maxRows - 1) more rows.
0:         for (int index = 1; index < maxRows; index++) {
0:             assertTrue(rs.next());
0:             assertEquals(index + 1, rs.getInt(1));
0: 
0:         }
0:         // We should not see another row (only maxRows, not total)
0:         assertFalse(rs.next());
0: 
0:         // Start from afterLast and verify maxRows
0:         rs.afterLast();
0:         // Iterate backwards thru RS, expect only (maxRows - 1) rows.
0:         for (int index = 1; index < maxRows + 1; index++) {
0:             assertTrue(rs.previous());
0:             assertEquals(maxRows - index + 1, rs.getInt(1));
0:         }
0:         // We should not see another row (only maxRows, not total)
0:         assertFalse(rs.previous());
0: 
0:         // Start from last and verify maxRows
0:         assertTrue(rs.last());
0: 
0:         // Iterate backwards thru RS, expect only (maxRows - 1) more rows.
0:         for (int index = 1; index < maxRows; index++) {
0:             assertTrue(rs.previous());
0:             assertEquals((maxRows - index), rs.getInt(1));
0: 
0:         }
0:         // We should not see another row (only 5, not 6)
0:         assertFalse(rs.previous());
0:         rs.last();
0:         int rows = rs.getRow();
0: 
0:         rs.absolute(rows / 2);
0:         assertFalse(rs.relative(-1 * (rows)));
0:         assertTrue(rs.isBeforeFirst());
0: 
0:         rs.absolute(rows / 2);
0:         assertFalse(rs.relative(rows));
0:         assertTrue(rs.isAfterLast());
0:         rs.absolute(rows / 2);
0:         assertFalse("absolute(" + (rows + 1)
0:                 + ") should return false, position outside of the resultSet",
0:                 rs.absolute(rows + 1));
0: 
0:         rs.absolute(rows / 2);
0:         assertFalse(rs.absolute((-1) * (rows + 1)));
0: 
0:         assertTrue(rs.isBeforeFirst());
0: 
0:         rs.close();
0: 
0:     }
0: 
0:     private void assertOnlyOnScrollableException(SQLException sqle) {
0:         if (!isDerbyNetClient) {
0:             assertEquals("XJ061", sqle.getSQLState());
0:         } else {
0:             assertEquals("XJ125", sqle.getSQLState());
0:         }
0:     }
0: 
0:     public static Test suite() {
0:         return TestConfiguration.defaultSuite(ScrollCursors2Test.class);
0:     }
0: 
0: }
============================================================================