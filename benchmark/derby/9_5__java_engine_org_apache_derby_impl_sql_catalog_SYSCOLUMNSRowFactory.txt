1:fd46794: /*
43:eac0369: 
1:fd46794:    Derby - Class org.apache.derby.impl.sql.catalog.SYSCOLUMNSRowFactory
1:fd46794: 
1:f739ad1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:f739ad1:    contributor license agreements.  See the NOTICE file distributed with
1:f739ad1:    this work for additional information regarding copyright ownership.
1:f739ad1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:f739ad1:    (the "License"); you may not use this file except in compliance with
1:f739ad1:    the License.  You may obtain a copy of the License at
1:fd46794: 
1:fd46794:       http://www.apache.org/licenses/LICENSE-2.0
1:fd46794: 
1:fd46794:    Unless required by applicable law or agreed to in writing, software
1:fd46794:    distributed under the License is distributed on an "AS IS" BASIS,
1:fd46794:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:fd46794:    See the License for the specific language governing permissions and
1:fd46794:    limitations under the License.
1:fd46794: 
1:fd46794: */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.sql.catalog;
1:eac0369: 
1:082459a: import java.sql.Types;
1:2afe578: import java.util.Properties;
1:eac0369: 
1:eac0369: import org.apache.derby.catalog.TypeDescriptor;
1:2afe578: import org.apache.derby.catalog.UUID;
1:2afe578: import org.apache.derby.catalog.types.DefaultInfoImpl;
1:2afe578: import org.apache.derby.iapi.error.StandardException;
1:2afe578: import org.apache.derby.iapi.reference.Property;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:2afe578: import org.apache.derby.iapi.services.uuid.UUIDFactory;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.CatalogRowFactory;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.DataDescriptorGenerator;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1:2afe578: import org.apache.derby.iapi.sql.dictionary.SystemColumn;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.TupleDescriptor;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.UniqueTupleDescriptor;
1:eac0369: import org.apache.derby.iapi.sql.execute.ExecRow;
1:2afe578: import org.apache.derby.iapi.sql.execute.ExecutionFactory;
1:2afe578: import org.apache.derby.iapi.store.raw.RawStoreFactory;
1:2afe578: import org.apache.derby.iapi.types.DataTypeDescriptor;
1:2afe578: import org.apache.derby.iapi.types.DataValueDescriptor;
1:2afe578: import org.apache.derby.iapi.types.DataValueFactory;
1:2afe578: import org.apache.derby.iapi.types.SQLChar;
1:2afe578: import org.apache.derby.iapi.types.SQLInteger;
1:2afe578: import org.apache.derby.iapi.types.SQLLongint;
1:2afe578: import org.apache.derby.iapi.types.SQLVarchar;
1:2afe578: import org.apache.derby.iapi.types.TypeId;
1:4309044: import org.apache.derby.iapi.types.UserType;
1:6a5edfc: import org.apache.derby.impl.sql.compile.ColumnDefinitionNode;
1:eac0369: 
4:eac0369: /**
1:eac0369:  * Factory for creating a SYSCOLUMNS row.
7:eac0369:  *
1:eac0369:  *
1:eac0369:  * @version 0.1
7:eac0369:  */
1:345de35: 
1:eac0369: public class SYSCOLUMNSRowFactory extends CatalogRowFactory
5:eac0369: {
1:eac0369: 	static final String		TABLENAME_STRING = "SYSCOLUMNS";
1:345de35: 
1:eac0369: 	protected static final int		SYSCOLUMNS_COLUMN_COUNT = 9;
1:eac0369: 	/* Column #s for syscolumns (1 based) */
1:eac0369: 
1:eac0369: 	//TABLEID is an obsolete name, it is better to use 
1:eac0369: 	//REFERENCEID, but to make life easier you can use either
1:eac0369: 	protected static final int		SYSCOLUMNS_TABLEID = 1;
1:eac0369: 	protected static final int		SYSCOLUMNS_REFERENCEID = 1;
1:eac0369: 	protected static final int		SYSCOLUMNS_COLUMNNAME = 2;
1:eac0369: 	protected static final int		SYSCOLUMNS_COLUMNNUMBER = 3;
1:eac0369: 	protected static final int		SYSCOLUMNS_COLUMNDATATYPE = 4;
1:eac0369: 	protected static final int		SYSCOLUMNS_COLUMNDEFAULT = 5;
1:eac0369: 	protected static final int		SYSCOLUMNS_COLUMNDEFAULTID = 6;
1:eac0369: 	protected static final int 		SYSCOLUMNS_AUTOINCREMENTVALUE = 7;
1:eac0369: 	protected static final int 		SYSCOLUMNS_AUTOINCREMENTSTART = 8;
1:eac0369: 	protected static final int		SYSCOLUMNS_AUTOINCREMENTINC = 9;
1:eac0369: 
1:eac0369: 	//private static final String	SYSCOLUMNS_INDEX1_NAME = "SYSCOLUMNS_INDEX1";
1:eac0369: 	protected static final int		SYSCOLUMNS_INDEX1_ID = 0;
1:eac0369: 
1:eac0369: 	//private static final String	SYSCOLUMNS_INDEX2_NAME = "SYSCOLUMNS_INDEX2";
1:eac0369: 	protected static final int		SYSCOLUMNS_INDEX2_ID = 1;
1:eac0369: 
1:eac0369:     private	static	final	boolean[]	uniqueness = {
7:eac0369: 		                                               true,
1:eac0369: 													   false
2:eac0369: 	                                                 };
1:eac0369: 
1:eac0369: 	private	static	final	String[]	uuids =
1:eac0369: 	{
1:eac0369: 		 "8000001e-00d0-fd77-3ed8-000a0a0b1900"	// catalog UUID
1:eac0369: 		,"80000029-00d0-fd77-3ed8-000a0a0b1900"	// heap UUID
1:eac0369: 		,"80000020-00d0-fd77-3ed8-000a0a0b1900"	// SYSCOLUMNS_INDEX1 UUID
1:eac0369: 		,"6839c016-00d9-2829-dfcd-000a0a411400"	// SYSCOLUMNS_INDEX2 UUID
1:eac0369: 	};
1:eac0369: 
1:eac0369: 	private static final int[][] indexColumnPositions = 
1:eac0369: 	{
1:eac0369: 		{SYSCOLUMNS_REFERENCEID, SYSCOLUMNS_COLUMNNAME},
1:eac0369: 		{SYSCOLUMNS_COLUMNDEFAULTID}
1:eac0369: 	};
1:eac0369: 
1:eac0369: 	/////////////////////////////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	//	STATE
1:eac0369: 	//
1:eac0369: 	/////////////////////////////////////////////////////////////////////////////
1:eac0369: 
1:eac0369: 	/////////////////////////////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	//	CONSTRUCTORS
1:eac0369: 	//
1:eac0369: 	/////////////////////////////////////////////////////////////////////////////
1:eac0369: 
1:6870e87:     SYSCOLUMNSRowFactory(UUIDFactory uuidf, ExecutionFactory ef, DataValueFactory dvf)
1:eac0369: 	{
1:6870e87: 		this(uuidf, ef, dvf, TABLENAME_STRING);
2:eac0369: 	}
1:eac0369: 
1:6870e87:     SYSCOLUMNSRowFactory(UUIDFactory uuidf, ExecutionFactory ef, DataValueFactory dvf,
1:6870e87:                                  String myName )
1:eac0369: 	{
1:6870e87: 		super(uuidf,ef,dvf);
1:c2ff613: 		initInfo(SYSCOLUMNS_COLUMN_COUNT, myName, indexColumnPositions, uniqueness, uuids);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/////////////////////////////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	//	METHODS
1:eac0369: 	//
1:eac0369: 	/////////////////////////////////////////////////////////////////////////////
1:eac0369: 
1:eac0369:   /**
1:eac0369: 	 * Make a SYSCOLUMNS row
1:eac0369: 	 *
1:eac0369: 	 * @return	Row suitable for inserting into SYSCOLUMNS.
1:eac0369: 	 *
2:eac0369: 	 * @exception   StandardException thrown on failure
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	public ExecRow makeRow(TupleDescriptor td, TupleDescriptor parent)
2:eac0369: 					throws StandardException
1:eac0369: 	{
1:eac0369: 		ExecRow    				row;
1:eac0369: 
1:eac0369: 		String					colName = null;
1:eac0369: 		String					defaultID = null;
1:eac0369: 		String					tabID = null;
1:eac0369: 		Integer					colID = null;
1:2afe578: 		TypeDescriptor 		    typeDesc = null;
1:eac0369: 		Object					defaultSerializable = null;
1:eac0369: 		long					autoincStart = 0;
1:eac0369: 		long					autoincInc = 0;
1:45c3f03: 		long					autoincValue = 0;
1:6a5edfc: 		//The SYSCOLUMNS table's autoinc related columns change with different
1:6a5edfc: 		//values depending on what happened to the autoinc column, ie is the 
1:6a5edfc: 		//user adding an autoincrement column, or is user changing the existing 
1:6a5edfc: 		//autoincrement column to change it's increment value or to change it's
1:6a5edfc: 		//start value? Following variable is used to keep track of what happened 
1:6a5edfc: 		//to the autoincrement column.
1:6a5edfc: 		long autoinc_create_or_modify_Start_Increment = -1;
1:eac0369: 
1:eac0369: 		if (td != null)
1:eac0369: 		{
1:eac0369: 			ColumnDescriptor  column = (ColumnDescriptor)td;
1:eac0369: 		
1:eac0369: 			/* Lots of info in the column's type descriptor */
1:eac0369: 			typeDesc = column.getType().getCatalogType();
1:eac0369: 
1:eac0369: 			tabID = column.getReferencingUUID().toString();
1:eac0369: 			colName = column.getColumnName();
1:ce40a31: 			colID = column.getPosition();
1:eac0369: 			autoincStart = column.getAutoincStart();
1:eac0369: 			autoincInc   = column.getAutoincInc();
1:45c3f03: 			autoincValue   = column.getAutoincValue();
1:6a5edfc: 			autoinc_create_or_modify_Start_Increment = column.getAutoinc_create_or_modify_Start_Increment();
1:eac0369: 			if (column.getDefaultInfo() != null)
1:eac0369: 			{
1:eac0369: 				defaultSerializable = column.getDefaultInfo();
1:eac0369: 			}
1:eac0369: 			else
1:eac0369: 			{
1:eac0369: 				defaultSerializable = column.getDefaultValue();
1:eac0369: 			}
1:eac0369: 			if  (column.getDefaultUUID() != null)
1:eac0369: 			{
1:eac0369: 				defaultID = column.getDefaultUUID().toString();
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* Insert info into syscolumns */
1:eac0369: 
1:eac0369: 		/* RESOLVE - It would be nice to require less knowledge about syscolumns
1:eac0369: 		 * and have this be more table driven.
1:eac0369: 		 * RESOLVE - We'd like to store the DataTypeDescriptor in a column.
1:eac0369: 		 */
1:eac0369: 
1:eac0369: 		/* Build the row to insert  */
1:eac0369: 		row = getExecutionFactory().getValueRow(SYSCOLUMNS_COLUMN_COUNT);
1:eac0369: 
2:eac0369: 		/* 1st column is REFERENCEID (UUID - char(36)) */
1:eb47bdb: 		row.setColumn(SYSCOLUMNS_REFERENCEID, new SQLChar(tabID));
1:eac0369: 
2:eac0369: 		/* 2nd column is COLUMNNAME (varchar(128)) */
1:eb47bdb: 		row.setColumn(SYSCOLUMNS_COLUMNNAME, new SQLVarchar(colName));
1:eac0369: 
1:eac0369: 		/* 3rd column is COLUMNNUMBER (int) */
1:c8c1551: 		row.setColumn(SYSCOLUMNS_COLUMNNUMBER, new SQLInteger(colID));
1:eac0369: 
1:eac0369: 		/* 4th column is COLUMNDATATYPE */
1:eac0369: 		row.setColumn(SYSCOLUMNS_COLUMNDATATYPE,
1:4309044: 				new UserType(typeDesc));
1:eac0369: 
1:eac0369: 		/* 5th column is COLUMNDEFAULT */
1:eac0369: 		row.setColumn(SYSCOLUMNS_COLUMNDEFAULT,
1:4309044: 					  new UserType(defaultSerializable));
1:eac0369: 
1:eac0369: 		/* 6th column is DEFAULTID (UUID - char(36)) */
1:eb47bdb: 		row.setColumn(SYSCOLUMNS_COLUMNDEFAULTID, new SQLChar(defaultID));
1:eac0369: 
1:5b838fd: 		if (
1:5b838fd:             (autoinc_create_or_modify_Start_Increment ==
1:5b838fd:              ColumnDefinitionNode.CREATE_AUTOINCREMENT) ||
1:5b838fd:             (autoinc_create_or_modify_Start_Increment ==
1:5b838fd:              ColumnDefinitionNode.MODIFY_AUTOINCREMENT_INC_VALUE) ||
1:5b838fd:             (autoinc_create_or_modify_Start_Increment ==
1:5b838fd:              ColumnDefinitionNode.MODIFY_AUTOINCREMENT_ALWAYS_VS_DEFAULT)
1:5b838fd:             )
1:5b838fd: 		{
1:5b838fd:             //user is adding an autoinc column
1:5b838fd:             // or is changing the increment value of autoinc column
1:5b838fd:             // or is changing an autoinc column between ALWAYS and DEFAULT.
1:45c3f03: 			// This code also gets run when ALTER TABLE DROP COLUMN
1:45c3f03: 			// is used to drop a column other than the autoinc
1:45c3f03: 			// column, and the autoinc column gets removed from
1:45c3f03: 			// SYSCOLUMNS and immediately re-added with a different
1:45c3f03: 			// column position (to account for the dropped column).
1:45c3f03: 			// In this case, the autoincValue may have a
1:45c3f03: 			// different value than the autoincStart.
1:eac0369: 			row.setColumn(SYSCOLUMNS_AUTOINCREMENTVALUE, 
1:45c3f03: 						  new SQLLongint(autoincValue));
1:eac0369: 			row.setColumn(SYSCOLUMNS_AUTOINCREMENTSTART, 
2:eac0369: 						  new SQLLongint(autoincStart));
1:eac0369: 			row.setColumn(SYSCOLUMNS_AUTOINCREMENTINC, 
1:eac0369: 						  new SQLLongint(autoincInc));
1:6a5edfc: 		} else if (autoinc_create_or_modify_Start_Increment == ColumnDefinitionNode.MODIFY_AUTOINCREMENT_RESTART_VALUE)
1:6a5edfc: 		{//user asked for restart with a new value, so don't change increment by and original start
1:6a5edfc: 			//with values in the SYSCOLUMNS table. Just record the RESTART WITH value as the
1:6a5edfc: 			//next value to be generated in the SYSCOLUMNS table
1:6a5edfc: 			ColumnDescriptor  column = (ColumnDescriptor)td;
1:6a5edfc: 			row.setColumn(SYSCOLUMNS_AUTOINCREMENTVALUE, new SQLLongint(autoincStart));
1:1b54e9e: 			row.setColumn(SYSCOLUMNS_AUTOINCREMENTSTART, new SQLLongint(autoincStart));
1:6a5edfc: 			row.setColumn(SYSCOLUMNS_AUTOINCREMENTINC, new SQLLongint(
1:6a5edfc: 					column.getTableDescriptor().getColumnDescriptor(colName).getAutoincInc()));
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			row.setColumn(SYSCOLUMNS_AUTOINCREMENTVALUE, 
1:eac0369: 						  new SQLLongint());
1:eac0369: 			row.setColumn(SYSCOLUMNS_AUTOINCREMENTSTART, 
1:eac0369: 						  new SQLLongint());
1:eac0369: 			row.setColumn(SYSCOLUMNS_AUTOINCREMENTINC,
1:eac0369: 						  new SQLLongint());
1:eac0369: 		}
1:eac0369: 		return row;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the Properties associated with creating the heap.
1:eac0369: 	 *
1:eac0369: 	 * @return The Properties associated with creating the heap.
1:eac0369: 	 */
1:eac0369: 	public Properties getCreateHeapProperties()
1:eac0369: 	{
1:eac0369: 		Properties properties = new Properties();
1:eac0369: 		// keep page size at 4K since its a big table
1:eac0369: 		properties.put(Property.PAGE_SIZE_PARAMETER,"4096");
1:eac0369: 		// default properties for system tables:
1:eac0369: 		properties.put(RawStoreFactory.PAGE_RESERVED_SPACE_PARAMETER,"0");
1:eac0369: 		properties.put(RawStoreFactory.MINIMUM_RECORD_SIZE_PARAMETER,"1");
1:eac0369: 		return properties;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the Properties associated with creating the specified index.
1:eac0369: 	 *
1:eac0369: 	 * @param indexNumber	The specified index number.
1:eac0369: 	 *
1:eac0369: 	 * @return The Properties associated with creating the specified index.
1:eac0369: 	 */
1:eac0369: 	public Properties getCreateIndexProperties(int indexNumber)
1:eac0369: 	{
1:eac0369: 		Properties properties = new Properties();
1:eac0369: 		// keep page size for all indexes at 4K since its a big table
1:eac0369: 		properties.put(Property.PAGE_SIZE_PARAMETER,"4096");
1:eac0369: 		return properties;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	///////////////////////////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	//	ABSTRACT METHODS TO BE IMPLEMENTED BY CHILDREN OF CatalogRowFactory
1:eac0369: 	//
1:eac0369: 	///////////////////////////////////////////////////////////////////////////
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Make a ColumnDescriptor out of a SYSCOLUMNS row
1:eac0369: 	 *
1:eac0369: 	 * @param row 					a SYSCOLUMNS row
1:eac0369: 	 * @param parentTupleDescriptor	The UniqueTupleDescriptor for the object that is tied
1:eac0369: 	 *								to this column
1:eac0369: 	 * @param dd 					dataDictionary
1:eac0369: 	 *
1:eac0369: 	 * @return	a column descriptor equivalent to a SYSCOLUMNS row
1:eac0369: 	 *
1:eac0369: 	 * @exception   StandardException thrown on failure
1:eac0369: 	 */
1:eac0369: 	public TupleDescriptor buildDescriptor(
1:eac0369: 		ExecRow					row,
1:eac0369: 		TupleDescriptor			parentTupleDescriptor,
1:eac0369: 		DataDictionary 			dd )
1:eac0369: 					throws StandardException
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(row.nColumns() == SYSCOLUMNS_COLUMN_COUNT, 
1:eac0369: 								 "Wrong number of columns for a SYSCOLUMNS row");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		int columnNumber;
1:eac0369: 		String columnName;
1:eac0369: 		String defaultID;
1:eac0369: 		DefaultInfoImpl		defaultInfo = null;
1:eac0369: 		ColumnDescriptor colDesc;
1:eac0369: 		DataValueDescriptor	defaultValue = null;
1:eac0369: 		UUID				defaultUUID = null;
1:eac0369: 		UUID				uuid = null;
1:eac0369: 		UUIDFactory			uuidFactory = getUUIDFactory();
1:45c3f03: 		long autoincStart, autoincInc, autoincValue;
1:eac0369: 
1:eac0369: 		DataDescriptorGenerator	ddg = dd.getDataDescriptorGenerator();
1:eac0369: 
1:eac0369: 
2:eac0369: 		/*
1:eac0369: 		** We're going to be getting the UUID for this sucka
1:eac0369: 		** so make sure it is a UniqueTupleDescriptor.
1:eac0369: 		*/
1:eac0369: 		if (parentTupleDescriptor != null)
1:eac0369: 		{
1:eac0369: 			if (SanityManager.DEBUG)
1:eac0369: 			{
1:eac0369: 				if (!(parentTupleDescriptor instanceof UniqueTupleDescriptor))
1:eac0369: 				{
1:eac0369: 					SanityManager.THROWASSERT(parentTupleDescriptor.getClass().getName() 
1:eac0369: 							+ " not instanceof UniqueTupleDescriptor");	
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 			uuid = ((UniqueTupleDescriptor)parentTupleDescriptor).getUUID();
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			/* 1st column is REFERENCEID (char(36)) */
1:eac0369: 			uuid = uuidFactory.recreateUUID(row.getColumn(SYSCOLUMNS_REFERENCEID).
1:eac0369: 													getString());
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* NOTE: We get columns 5 and 6 next in order to work around 
2:eac0369: 		 * a 1.3.0 HotSpot bug.  (#4361550)
1:eac0369: 		 */
1:eac0369: 
1:eac0369: 		// 5th column is COLUMNDEFAULT (serialiazable)
1:eac0369: 		Object object = row.getColumn(SYSCOLUMNS_COLUMNDEFAULT).getObject();
1:eac0369: 		if (object instanceof DataValueDescriptor)
1:eac0369: 		{
1:eac0369: 			defaultValue = (DataValueDescriptor) object;
1:eac0369: 		}
1:eac0369: 		else if (object instanceof DefaultInfoImpl)
1:eac0369: 		{
1:eac0369: 			defaultInfo = (DefaultInfoImpl) object;
1:eac0369: 			defaultValue = defaultInfo.getDefaultValue();
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* 6th column is DEFAULTID (char(36)) */
1:eac0369: 		defaultID = row.getColumn(SYSCOLUMNS_COLUMNDEFAULTID).getString();
1:eac0369: 
1:eac0369: 		if (defaultID != null)
1:eac0369: 		{
1:eac0369: 			defaultUUID = uuidFactory.recreateUUID(defaultID);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* 2nd column is COLUMNNAME (varchar(128)) */
1:eac0369: 		columnName = row.getColumn(SYSCOLUMNS_COLUMNNAME).getString();
1:eac0369: 
1:eac0369: 		/* 3rd column is COLUMNNUMBER (int) */
1:eac0369: 		columnNumber = row.getColumn(SYSCOLUMNS_COLUMNNUMBER).getInt();
1:eac0369: 
1:eac0369: 		/* 4th column is COLUMNDATATYPE */
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** What is stored in the column is a TypeDescriptorImpl, which
1:eac0369: 		** points to a BaseTypeIdImpl.  These are simple types that are
1:eac0369: 		** intended to be movable to the client, so they don't have
1:eac0369: 		** the entire implementation.  We need to wrap them in DataTypeServices
1:eac0369: 		** and TypeId objects that contain the full implementations for
1:eac0369: 		** language processing.
1:eac0369: 		*/
1:b77f82e: 		TypeDescriptor catalogType = (TypeDescriptor) row.getColumn(SYSCOLUMNS_COLUMNDATATYPE).
1:eac0369: 													getObject();
1:b77f82e: 		DataTypeDescriptor dataTypeServices = 
1:b77f82e: 			DataTypeDescriptor.getType(catalogType);
1:eac0369: 
1:45c3f03: 		/* 7th column is AUTOINCREMENTVALUE (long) */
1:45c3f03: 		autoincValue = row.getColumn(SYSCOLUMNS_AUTOINCREMENTVALUE).getLong();
1:eac0369: 
1:eac0369: 		/* 8th column is AUTOINCREMENTSTART (long) */
1:eac0369: 		autoincStart = row.getColumn(SYSCOLUMNS_AUTOINCREMENTSTART).getLong();
1:eac0369: 
1:eac0369: 		/* 9th column is AUTOINCREMENTINC (long) */
1:eac0369: 		autoincInc = row.getColumn(SYSCOLUMNS_AUTOINCREMENTINC).getLong();
1:eac0369: 
1:eac0369: 		DataValueDescriptor col = row.getColumn(SYSCOLUMNS_AUTOINCREMENTSTART);
1:eac0369: 		autoincStart = col.getLong();
1:eac0369: 
1:eac0369: 		col = row.getColumn(SYSCOLUMNS_AUTOINCREMENTINC);
1:eac0369: 		autoincInc = col.getLong();
1:eac0369: 
1:eac0369: 		colDesc = new ColumnDescriptor(columnName, columnNumber,
1:eac0369: 							dataTypeServices, defaultValue, defaultInfo, uuid, 
1:45c3f03: 							defaultUUID, autoincStart, autoincInc,
1:45c3f03:                             autoincValue);
1:eac0369: 		return colDesc;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  *	Get the index number for the primary key index on this catalog.
1:eac0369: 	  *
1:eac0369: 	  *	@return	a 0-based number
1:eac0369: 	  *
1:eac0369: 	  */
1:eac0369: 	public	int	getPrimaryKeyIndexNumber()
1:eac0369: 	{
1:eac0369: 		return SYSCOLUMNS_INDEX1_ID;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Builds a list of columns suitable for creating this Catalog.
1:eac0369: 	 *
1:eac0369: 	 *
1:eac0369: 	 * @return array of SystemColumn suitable for making this catalog.
1:eac0369: 	 */
1:eac0369: 	public SystemColumn[]	buildColumnList()
1:2a5922a:         throws StandardException
1:eac0369: 	{
1:082459a:         
1:082459a:         return new SystemColumn[] {
1:082459a:             SystemColumnImpl.getUUIDColumn("REFERENCEID", false),
1:082459a:             SystemColumnImpl.getIdentifierColumn("COLUMNNAME", false),
1:082459a:             SystemColumnImpl.getColumn("COLUMNNUMBER", Types.INTEGER, false),
1:082459a:             SystemColumnImpl.getJavaColumn("COLUMNDATATYPE",
1:082459a:                 "org.apache.derby.catalog.TypeDescriptor", false),
1:082459a:             SystemColumnImpl.getJavaColumn("COLUMNDEFAULT",
1:082459a:                 "java.io.Serializable", true),
1:082459a:             SystemColumnImpl.getUUIDColumn("COLUMNDEFAULTID", true),
1:082459a:             
1:082459a:             SystemColumnImpl.getColumn("AUTOINCREMENTVALUE", Types.BIGINT, true),
1:082459a:             SystemColumnImpl.getColumn("AUTOINCREMENTSTART", Types.BIGINT, true),
1:082459a:             SystemColumnImpl.getColumn("AUTOINCREMENTINC", Types.BIGINT, true),
1:eac0369: 
1:082459a:        };
1:eac0369: 	}
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:ce40a31
/////////////////////////////////////////////////////////////////////////
1: 			colID = column.getPosition();
commit:5b838fd
/////////////////////////////////////////////////////////////////////////
1: 		if (
1:             (autoinc_create_or_modify_Start_Increment ==
1:              ColumnDefinitionNode.CREATE_AUTOINCREMENT) ||
1:             (autoinc_create_or_modify_Start_Increment ==
1:              ColumnDefinitionNode.MODIFY_AUTOINCREMENT_INC_VALUE) ||
1:             (autoinc_create_or_modify_Start_Increment ==
1:              ColumnDefinitionNode.MODIFY_AUTOINCREMENT_ALWAYS_VS_DEFAULT)
1:             )
1: 		{
1:             //user is adding an autoinc column
1:             // or is changing the increment value of autoinc column
1:             // or is changing an autoinc column between ALWAYS and DEFAULT.
commit:2a5922a
/////////////////////////////////////////////////////////////////////////
1:         throws StandardException
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
commit:4309044
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.types.UserType;
/////////////////////////////////////////////////////////////////////////
1: 				new UserType(typeDesc));
1: 					  new UserType(defaultSerializable));
commit:45c3f03
/////////////////////////////////////////////////////////////////////////
1: 		long					autoincValue = 0;
/////////////////////////////////////////////////////////////////////////
1: 			autoincValue   = column.getAutoincValue();
/////////////////////////////////////////////////////////////////////////
1: 			// This code also gets run when ALTER TABLE DROP COLUMN
1: 			// is used to drop a column other than the autoinc
1: 			// column, and the autoinc column gets removed from
1: 			// SYSCOLUMNS and immediately re-added with a different
1: 			// column position (to account for the dropped column).
1: 			// In this case, the autoincValue may have a
1: 			// different value than the autoincStart.
1: 						  new SQLLongint(autoincValue));
/////////////////////////////////////////////////////////////////////////
1: 		long autoincStart, autoincInc, autoincValue;
/////////////////////////////////////////////////////////////////////////
1: 		/* 7th column is AUTOINCREMENTVALUE (long) */
1: 		autoincValue = row.getColumn(SYSCOLUMNS_AUTOINCREMENTVALUE).getLong();
/////////////////////////////////////////////////////////////////////////
1: 							defaultUUID, autoincStart, autoincInc,
1:                             autoincValue);
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:6870e87
/////////////////////////////////////////////////////////////////////////
1:     SYSCOLUMNSRowFactory(UUIDFactory uuidf, ExecutionFactory ef, DataValueFactory dvf)
1: 		this(uuidf, ef, dvf, TABLENAME_STRING);
1:     SYSCOLUMNSRowFactory(UUIDFactory uuidf, ExecutionFactory ef, DataValueFactory dvf,
1:                                  String myName )
1: 		super(uuidf,ef,dvf);
commit:082459a
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Types;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         
1:         return new SystemColumn[] {
1:             SystemColumnImpl.getUUIDColumn("REFERENCEID", false),
1:             SystemColumnImpl.getIdentifierColumn("COLUMNNAME", false),
1:             SystemColumnImpl.getColumn("COLUMNNUMBER", Types.INTEGER, false),
1:             SystemColumnImpl.getJavaColumn("COLUMNDATATYPE",
1:                 "org.apache.derby.catalog.TypeDescriptor", false),
1:             SystemColumnImpl.getJavaColumn("COLUMNDEFAULT",
1:                 "java.io.Serializable", true),
1:             SystemColumnImpl.getUUIDColumn("COLUMNDEFAULTID", true),
1:             
1:             SystemColumnImpl.getColumn("AUTOINCREMENTVALUE", Types.BIGINT, true),
1:             SystemColumnImpl.getColumn("AUTOINCREMENTSTART", Types.BIGINT, true),
1:             SystemColumnImpl.getColumn("AUTOINCREMENTINC", Types.BIGINT, true),
1:        };
commit:b77f82e
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		TypeDescriptor catalogType = (TypeDescriptor) row.getColumn(SYSCOLUMNS_COLUMNDATATYPE).
1: 		DataTypeDescriptor dataTypeServices = 
1: 			DataTypeDescriptor.getType(catalogType);
commit:2afe578
/////////////////////////////////////////////////////////////////////////
1: import java.util.Properties;
1: import org.apache.derby.catalog.UUID;
1: import org.apache.derby.catalog.types.DefaultInfoImpl;
0: import org.apache.derby.catalog.types.TypeDescriptorImpl;
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.reference.Property;
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.services.uuid.UUIDFactory;
1: import org.apache.derby.iapi.sql.dictionary.SystemColumn;
1: import org.apache.derby.iapi.sql.execute.ExecutionFactory;
1: import org.apache.derby.iapi.store.raw.RawStoreFactory;
1: import org.apache.derby.iapi.types.DataTypeDescriptor;
1: import org.apache.derby.iapi.types.DataValueDescriptor;
1: import org.apache.derby.iapi.types.DataValueFactory;
1: import org.apache.derby.iapi.types.SQLChar;
1: import org.apache.derby.iapi.types.SQLInteger;
1: import org.apache.derby.iapi.types.SQLLongint;
1: import org.apache.derby.iapi.types.SQLVarchar;
1: import org.apache.derby.iapi.types.TypeId;
/////////////////////////////////////////////////////////////////////////
1: 		TypeDescriptor 		    typeDesc = null;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         BaseTypeIdImpl typeId = typeDescriptor.getTypeId();
0:         TypeId wrapperTypeId = new TypeId(typeId.wrapperTypeFormatId(), typeId);
commit:c8c1551
/////////////////////////////////////////////////////////////////////////
1: 		row.setColumn(SYSCOLUMNS_COLUMNNUMBER, new SQLInteger(colID));
commit:eb47bdb
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.types.SQLVarchar;
/////////////////////////////////////////////////////////////////////////
1: 		row.setColumn(SYSCOLUMNS_REFERENCEID, new SQLChar(tabID));
1: 		row.setColumn(SYSCOLUMNS_COLUMNNAME, new SQLVarchar(colName));
/////////////////////////////////////////////////////////////////////////
1: 		row.setColumn(SYSCOLUMNS_COLUMNDEFAULTID, new SQLChar(defaultID));
commit:7aa6fa8
/////////////////////////////////////////////////////////////////////////
commit:c2ff613
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		initInfo(SYSCOLUMNS_COLUMN_COUNT, myName, indexColumnPositions, uniqueness, uuids);
commit:fd46794
/////////////////////////////////////////////////////////////////////////
1: /*
1:    Derby - Class org.apache.derby.impl.sql.catalog.SYSCOLUMNSRowFactory
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1: */
commit:345de35
/////////////////////////////////////////////////////////////////////////
1: 
0:  * Copyright 2000, 2001WESTHAM
1: 
commit:9e5097f
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
0: /* IBM Confidential
1:  *
0:  * Product ID: 5697-F53
1:  *
0:  * (C) Copyright IBM Corp. 2000, 2001
1:  *
0:  * The source code for this program is not published or otherwise divested
0:  * of its trade secrets, irrespective of what has been deposited with the
0:  * U.S. Copyright Office.
1:  */
1: 
1: package org.apache.derby.impl.sql.catalog;
1: 
0: import org.apache.derby.iapi.reference.Property;
1: 
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: import org.apache.derby.iapi.types.TypeId;
0: import org.apache.derby.iapi.types.DataValueDescriptor;
1: 
0: import org.apache.derby.iapi.store.raw.RawStoreFactory;
1: 
0: import org.apache.derby.iapi.types.DataValueFactory;
0: import org.apache.derby.iapi.sql.dictionary.SystemColumn;
1: import org.apache.derby.catalog.TypeDescriptor;
0: import org.apache.derby.catalog.types.BaseTypeIdImpl;
1: 
0: import org.apache.derby.iapi.types.DataValueDescriptor;
1: 
0: import org.apache.derby.iapi.types.TypeId;
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: import org.apache.derby.iapi.types.DataValueFactory;
0: import org.apache.derby.iapi.types.RowLocation;
1: 
1: import org.apache.derby.iapi.sql.dictionary.CatalogRowFactory;
1: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.DataDescriptorGenerator;
1: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.TupleDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.UniqueTupleDescriptor;
1: 
0: import org.apache.derby.iapi.sql.execute.ExecutionContext;
0: import org.apache.derby.iapi.sql.execute.ExecutionFactory;
0: import org.apache.derby.iapi.sql.execute.ExecIndexRow;
1: import org.apache.derby.iapi.sql.execute.ExecRow;
1: 
0: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: import org.apache.derby.catalog.types.TypeDescriptorImpl;
0: import org.apache.derby.catalog.DefaultInfo;
0: import org.apache.derby.iapi.services.uuid.UUIDFactory;
0: import org.apache.derby.catalog.UUID;
1: 
0: import org.apache.derby.catalog.types.DefaultInfoImpl;
1: 
0: import org.apache.derby.iapi.types.*;
1: 
0: import java.io.Serializable;
1: 
0: import java.util.Properties;
1: 
1: /**
1:  * Factory for creating a SYSCOLUMNS row.
1:  *
1:  *
1:  * @version 0.1
0:  * @author Rick Hillegas (extracted from DataDictionaryImpl).
1:  */
1: 
1: public class SYSCOLUMNSRowFactory extends CatalogRowFactory
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2001;
1: 	static final String		TABLENAME_STRING = "SYSCOLUMNS";
1: 
1: 	/**
0: 	 * Old name for REFERENCEID, used by upgrade
1: 	 */
0: 	public static final String		OLD_REFERENCEID_NAME = "TABLEID";
1: 
1: 	protected static final int		SYSCOLUMNS_COLUMN_COUNT = 9;
1: 	/* Column #s for syscolumns (1 based) */
1: 
1: 	//TABLEID is an obsolete name, it is better to use 
1: 	//REFERENCEID, but to make life easier you can use either
1: 	protected static final int		SYSCOLUMNS_TABLEID = 1;
1: 	protected static final int		SYSCOLUMNS_REFERENCEID = 1;
1: 	protected static final int		SYSCOLUMNS_COLUMNNAME = 2;
1: 	protected static final int		SYSCOLUMNS_COLUMNNUMBER = 3;
1: 	protected static final int		SYSCOLUMNS_COLUMNDATATYPE = 4;
1: 	protected static final int		SYSCOLUMNS_COLUMNDEFAULT = 5;
1: 	protected static final int		SYSCOLUMNS_COLUMNDEFAULTID = 6;
1: 	protected static final int 		SYSCOLUMNS_AUTOINCREMENTVALUE = 7;
1: 	protected static final int 		SYSCOLUMNS_AUTOINCREMENTSTART = 8;
1: 	protected static final int		SYSCOLUMNS_AUTOINCREMENTINC = 9;
1: 
1: 	//private static final String	SYSCOLUMNS_INDEX1_NAME = "SYSCOLUMNS_INDEX1";
1: 	protected static final int		SYSCOLUMNS_INDEX1_ID = 0;
1: 
1: 	//private static final String	SYSCOLUMNS_INDEX2_NAME = "SYSCOLUMNS_INDEX2";
1: 	protected static final int		SYSCOLUMNS_INDEX2_ID = 1;
1: 
0: 	protected	static	final	String	REFERENCEDID_STRING = "REFERENCEID";
0: 	protected	static	final	String	COLUMNNAME_STRING = "COLUMNNAME";
0: 	protected	static	final	String	COLUMNDEFAULTID_STRING = "COLUMNDEFAULTID";
1: 
1:     private	static	final	boolean[]	uniqueness = {
1: 		                                               true,
1: 													   false
1: 	                                                 };
1: 
1: 	private	static	final	String[]	uuids =
1: 	{
1: 		 "8000001e-00d0-fd77-3ed8-000a0a0b1900"	// catalog UUID
1: 		,"80000029-00d0-fd77-3ed8-000a0a0b1900"	// heap UUID
1: 		,"80000020-00d0-fd77-3ed8-000a0a0b1900"	// SYSCOLUMNS_INDEX1 UUID
1: 		,"6839c016-00d9-2829-dfcd-000a0a411400"	// SYSCOLUMNS_INDEX2 UUID
1: 	};
1: 
1: 	private static final int[][] indexColumnPositions = 
1: 	{
1: 		{SYSCOLUMNS_REFERENCEID, SYSCOLUMNS_COLUMNNAME},
1: 		{SYSCOLUMNS_COLUMNDEFAULTID}
1: 	};
1: 
0: 	private static final String[][] indexColumnNames =
1: 	{
0: 		{REFERENCEDID_STRING, COLUMNNAME_STRING},
0: 		{COLUMNDEFAULTID_STRING}
1: 	};
1: 
1: 	/////////////////////////////////////////////////////////////////////////////
1: 	//
1: 	//	STATE
1: 	//
1: 	/////////////////////////////////////////////////////////////////////////////
1: 
0: 	private	SystemColumn[]		columnList;
1: 
1: 	/////////////////////////////////////////////////////////////////////////////
1: 	//
1: 	//	CONSTRUCTORS
1: 	//
1: 	/////////////////////////////////////////////////////////////////////////////
1: 
0:     public	SYSCOLUMNSRowFactory(UUIDFactory uuidf, ExecutionFactory ef, DataValueFactory dvf,
0:                                  boolean convertIdToLower)
1: 	{
0: 		this(uuidf, ef, dvf, convertIdToLower, TABLENAME_STRING);
1: 	}
1: 
0:     public	SYSCOLUMNSRowFactory(UUIDFactory uuidf, ExecutionFactory ef, DataValueFactory dvf,
0:                                  boolean convertIdToLower, String myName )
1: 	{
0: 		super(uuidf,ef,dvf,convertIdToLower);
0: 		initInfo(SYSCOLUMNS_COLUMN_COUNT, myName, indexColumnPositions, indexColumnNames, uniqueness, uuids);
1: 	}
1: 
1: 	/////////////////////////////////////////////////////////////////////////////
1: 	//
1: 	//	METHODS
1: 	//
1: 	/////////////////////////////////////////////////////////////////////////////
1: 
1:   /**
1: 	 * Make a SYSCOLUMNS row
1: 	 *
0: 	 * @param emptyRow	Make an empty row if this parameter is true
0: 	 * @param tableID	Table that the column is in
0: 	 * @param column	Column descriptor
1: 	 *
1: 	 * @return	Row suitable for inserting into SYSCOLUMNS.
1: 	 *
1: 	 * @exception   StandardException thrown on failure
1: 	 */
1: 
1: 	public ExecRow makeRow(TupleDescriptor td, TupleDescriptor parent)
1: 					throws StandardException
1: 	{
1: 		ExecRow    				row;
0: 		DataValueDescriptor		col;
1: 
1: 		String					colName = null;
1: 		String					defaultID = null;
1: 		String					tabID = null;
1: 		Integer					colID = null;
0: 		TypeDescriptorImpl		typeDesc = null;
1: 		Object					defaultSerializable = null;
1: 		long					autoincStart = 0;
1: 		long					autoincInc = 0;
1: 
1: 		if (td != null)
1: 		{
1: 			ColumnDescriptor  column = (ColumnDescriptor)td;
1: 		
1: 			/* Lots of info in the column's type descriptor */
1: 			typeDesc = column.getType().getCatalogType();
1: 
1: 			tabID = column.getReferencingUUID().toString();
1: 			colName = column.getColumnName();
0: 			colID = new Integer(column.getPosition() );
1: 			autoincStart = column.getAutoincStart();
1: 			autoincInc   = column.getAutoincInc();
1: 			if (column.getDefaultInfo() != null)
1: 			{
1: 				defaultSerializable = column.getDefaultInfo();
1: 			}
1: 			else
1: 			{
1: 				defaultSerializable = column.getDefaultValue();
1: 			}
1: 			if  (column.getDefaultUUID() != null)
1: 			{
1: 				defaultID = column.getDefaultUUID().toString();
1: 			}
1: 		}
1: 
1: 		/* Insert info into syscolumns */
1: 
1: 		/* RESOLVE - It would be nice to require less knowledge about syscolumns
1: 		 * and have this be more table driven.
1: 		 * RESOLVE - We'd like to store the DataTypeDescriptor in a column.
1: 		 */
1: 
1: 		/* Build the row to insert  */
1: 		row = getExecutionFactory().getValueRow(SYSCOLUMNS_COLUMN_COUNT);
1: 
1: 		/* 1st column is REFERENCEID (UUID - char(36)) */
0: 		row.setColumn(SYSCOLUMNS_REFERENCEID, dvf.getCharDataValue(tabID));
1: 
1: 		/* 2nd column is COLUMNNAME (varchar(128)) */
0: 		row.setColumn(SYSCOLUMNS_COLUMNNAME, dvf.getVarcharDataValue(colName));
1: 
1: 		/* 3rd column is COLUMNNUMBER (int) */
0: 		row.setColumn(SYSCOLUMNS_COLUMNNUMBER, dvf.getDataValue(colID));
1: 
1: 		/* 4th column is COLUMNDATATYPE */
1: 		row.setColumn(SYSCOLUMNS_COLUMNDATATYPE,
0: 				dvf.getDataValue(typeDesc));
1: 
1: 		/* 5th column is COLUMNDEFAULT */
1: 		row.setColumn(SYSCOLUMNS_COLUMNDEFAULT,
0: 					  dvf.getDataValue(defaultSerializable));
1: 
1: 		/* 6th column is DEFAULTID (UUID - char(36)) */
0: 		row.setColumn(SYSCOLUMNS_COLUMNDEFAULTID, dvf.getCharDataValue(defaultID));
1: 
0: 		if (autoincInc != 0)
1: 		{
1: 			row.setColumn(SYSCOLUMNS_AUTOINCREMENTVALUE, 
1: 						  new SQLLongint(autoincStart));
1: 			row.setColumn(SYSCOLUMNS_AUTOINCREMENTSTART, 
1: 						  new SQLLongint(autoincStart));
1: 			row.setColumn(SYSCOLUMNS_AUTOINCREMENTINC, 
1: 						  new SQLLongint(autoincInc));
1: 		}
1: 		else
1: 		{
1: 			row.setColumn(SYSCOLUMNS_AUTOINCREMENTVALUE, 
1: 						  new SQLLongint());
1: 			row.setColumn(SYSCOLUMNS_AUTOINCREMENTSTART, 
1: 						  new SQLLongint());
1: 			row.setColumn(SYSCOLUMNS_AUTOINCREMENTINC,
1: 						  new SQLLongint());
1: 		}
1: 		return row;
1: 	}
1: 
1: 	/**
1: 	 * Get the Properties associated with creating the heap.
1: 	 *
1: 	 * @return The Properties associated with creating the heap.
1: 	 */
1: 	public Properties getCreateHeapProperties()
1: 	{
1: 		Properties properties = new Properties();
1: 		// keep page size at 4K since its a big table
1: 		properties.put(Property.PAGE_SIZE_PARAMETER,"4096");
1: 		// default properties for system tables:
1: 		properties.put(RawStoreFactory.PAGE_RESERVED_SPACE_PARAMETER,"0");
1: 		properties.put(RawStoreFactory.MINIMUM_RECORD_SIZE_PARAMETER,"1");
1: 		return properties;
1: 	}
1: 
1: 	/**
1: 	 * Get the Properties associated with creating the specified index.
1: 	 *
1: 	 * @param indexNumber	The specified index number.
1: 	 *
1: 	 * @return The Properties associated with creating the specified index.
1: 	 */
1: 	public Properties getCreateIndexProperties(int indexNumber)
1: 	{
1: 		Properties properties = new Properties();
1: 		// keep page size for all indexes at 4K since its a big table
1: 		properties.put(Property.PAGE_SIZE_PARAMETER,"4096");
1: 		return properties;
1: 	}
1: 
1: 	///////////////////////////////////////////////////////////////////////////
1: 	//
1: 	//	ABSTRACT METHODS TO BE IMPLEMENTED BY CHILDREN OF CatalogRowFactory
1: 	//
1: 	///////////////////////////////////////////////////////////////////////////
1: 
1: 	/**
0: 	 * Builds an empty index row.
1: 	 *
0: 	 *	@param	indexNumber	Index to build empty row for.
0: 	 *  @param  rowLocation	Row location for last column of index row
1: 	 *
0: 	 * @return corresponding empty index row
1: 	 * @exception   StandardException thrown on failure
1: 	 */
0: 	public ExecIndexRow	buildEmptyIndexRow( int indexNumber,
0: 											RowLocation rowLocation) 
1: 			throws StandardException
1: 	{
0: 		int ncols = getIndexColumnCount(indexNumber);
0: 		ExecIndexRow row = getExecutionFactory().getIndexableRow(ncols + 1);
1: 
0: 		row.setColumn(ncols + 1, rowLocation);
1: 
0: 		switch(indexNumber)
1: 		{
0: 			case SYSCOLUMNS_INDEX1_ID:
1: 				/* 1st column is REFERENCEID (UUID - char(36)) */
0: 				row.setColumn
0: 					(1, getDataValueFactory().getCharDataValue((String) null));
1: 
1: 				/* 2nd column is COLUMNNAME (varchar(128)) */
0: 				row.setColumn
0: 				    (2, 
0: 					 getDataValueFactory().getVarcharDataValue((String) null));
1: 
0: 				break;
1: 
0: 		    case SYSCOLUMNS_INDEX2_ID:
1: 				
0: 				/* 1st column is DEFAULTID (UUID - char(36)) */
0: 				row.setColumn
0: 					(1, getDataValueFactory().getCharDataValue((String) null));
1: 
0: 				break;
0: 		}	// end switch
1: 
0: 		return	row;
1: 	}
1: 
1: 
1: 	/**
1: 	 * Make a ColumnDescriptor out of a SYSCOLUMNS row
1: 	 *
1: 	 * @param row 					a SYSCOLUMNS row
1: 	 * @param parentTupleDescriptor	The UniqueTupleDescriptor for the object that is tied
1: 	 *								to this column
1: 	 * @param dd 					dataDictionary
1: 	 *
1: 	 * @return	a column descriptor equivalent to a SYSCOLUMNS row
1: 	 *
1: 	 * @exception   StandardException thrown on failure
1: 	 */
1: 	public TupleDescriptor buildDescriptor(
1: 		ExecRow					row,
1: 		TupleDescriptor			parentTupleDescriptor,
1: 		DataDictionary 			dd )
1: 					throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(row.nColumns() == SYSCOLUMNS_COLUMN_COUNT, 
1: 								 "Wrong number of columns for a SYSCOLUMNS row");
1: 		}
1: 
1: 		int columnNumber;
1: 		String columnName;
1: 		String defaultID;
1: 		DefaultInfoImpl		defaultInfo = null;
1: 		ColumnDescriptor colDesc;
0: 		BaseTypeIdImpl		typeId;
0: 		TypeId	wrapperTypeId;
1: 		DataValueDescriptor	defaultValue = null;
1: 		UUID				defaultUUID = null;
1: 		UUID				uuid = null;
1: 		UUIDFactory			uuidFactory = getUUIDFactory();
0: 		long autoincStart, autoincInc;
1: 
1: 		DataDescriptorGenerator	ddg = dd.getDataDescriptorGenerator();
1: 
1: 
1: 		/*
1: 		** We're going to be getting the UUID for this sucka
1: 		** so make sure it is a UniqueTupleDescriptor.
1: 		*/
1: 		if (parentTupleDescriptor != null)
1: 		{
1: 			if (SanityManager.DEBUG)
1: 			{
1: 				if (!(parentTupleDescriptor instanceof UniqueTupleDescriptor))
1: 				{
1: 					SanityManager.THROWASSERT(parentTupleDescriptor.getClass().getName() 
1: 							+ " not instanceof UniqueTupleDescriptor");	
1: 				}
1: 			}
1: 			uuid = ((UniqueTupleDescriptor)parentTupleDescriptor).getUUID();
1: 		}
1: 		else
1: 		{
1: 			/* 1st column is REFERENCEID (char(36)) */
1: 			uuid = uuidFactory.recreateUUID(row.getColumn(SYSCOLUMNS_REFERENCEID).
1: 													getString());
1: 		}
1: 
1: 		/* NOTE: We get columns 5 and 6 next in order to work around 
1: 		 * a 1.3.0 HotSpot bug.  (#4361550)
1: 		 */
1: 
1: 		// 5th column is COLUMNDEFAULT (serialiazable)
1: 		Object object = row.getColumn(SYSCOLUMNS_COLUMNDEFAULT).getObject();
1: 		if (object instanceof DataValueDescriptor)
1: 		{
1: 			defaultValue = (DataValueDescriptor) object;
1: 		}
1: 		else if (object instanceof DefaultInfoImpl)
1: 		{
1: 			defaultInfo = (DefaultInfoImpl) object;
1: 			defaultValue = defaultInfo.getDefaultValue();
1: 		}
1: 
1: 		/* 6th column is DEFAULTID (char(36)) */
1: 		defaultID = row.getColumn(SYSCOLUMNS_COLUMNDEFAULTID).getString();
1: 
1: 		if (defaultID != null)
1: 		{
1: 			defaultUUID = uuidFactory.recreateUUID(defaultID);
1: 		}
1: 
1: 		/* 2nd column is COLUMNNAME (varchar(128)) */
1: 		columnName = row.getColumn(SYSCOLUMNS_COLUMNNAME).getString();
1: 
1: 		/* 3rd column is COLUMNNUMBER (int) */
1: 		columnNumber = row.getColumn(SYSCOLUMNS_COLUMNNUMBER).getInt();
1: 
1: 		/* 4th column is COLUMNDATATYPE */
1: 
1: 		/*
1: 		** What is stored in the column is a TypeDescriptorImpl, which
1: 		** points to a BaseTypeIdImpl.  These are simple types that are
1: 		** intended to be movable to the client, so they don't have
1: 		** the entire implementation.  We need to wrap them in DataTypeServices
1: 		** and TypeId objects that contain the full implementations for
1: 		** language processing.
1: 		*/
0: 		TypeDescriptorImpl typeDescriptor = (TypeDescriptorImpl) row.getColumn(SYSCOLUMNS_COLUMNDATATYPE).
1: 													getObject();
0: 		typeId = typeDescriptor.getTypeId();
1: 
1: 		/*
0: 		** The BaseTypeIdImpl tells what type of TypeId it is supposed to
0: 		** be wrapped in.
1: 		*/
0: 		wrapperTypeId =
0: 			(TypeId) Monitor.newInstanceFromIdentifier(typeId.wrapperTypeFormatId());
0: 		/* Wrap the BaseTypeIdImpl in a full type id */
0: 		wrapperTypeId.setNestedTypeId(typeId);
1: 
0: 		/* Wrap the TypeDescriptorImpl in a full DataTypeDescriptor */
0: 		DataTypeDescriptor dataTypeServices = new DataTypeDescriptor(typeDescriptor,
0: 													wrapperTypeId);
1: 
0: 		/* 7th column is AUTOINCREMENTVALUE, not cached in descriptor (long) */
1: 
1: 		/* 8th column is AUTOINCREMENTSTART (long) */
1: 		autoincStart = row.getColumn(SYSCOLUMNS_AUTOINCREMENTSTART).getLong();
1: 
1: 		/* 9th column is AUTOINCREMENTINC (long) */
1: 		autoincInc = row.getColumn(SYSCOLUMNS_AUTOINCREMENTINC).getLong();
1: 
0: 		/* NOTE: We use the autoincColumn variable in order to work around 
1: 		 * a 1.3.0 HotSpot bug.  (#4361550)
1: 		 */
0: 		boolean autoincColumn = (autoincInc != 0); 
1: 
1: 		DataValueDescriptor col = row.getColumn(SYSCOLUMNS_AUTOINCREMENTSTART);
1: 		autoincStart = col.getLong();
1: 
1: 		col = row.getColumn(SYSCOLUMNS_AUTOINCREMENTINC);
1: 		autoincInc = col.getLong();
1: 
1: 		colDesc = new ColumnDescriptor(columnName, columnNumber,
1: 							dataTypeServices, defaultValue, defaultInfo, uuid, 
0: 							defaultUUID, autoincStart, autoincInc, 
0: 							autoincColumn);
1: 		return colDesc;
1: 	}
1: 
1: 	/**
1: 	  *	Get the index number for the primary key index on this catalog.
1: 	  *
1: 	  *	@return	a 0-based number
1: 	  *
1: 	  */
1: 	public	int	getPrimaryKeyIndexNumber()
1: 	{
1: 		return SYSCOLUMNS_INDEX1_ID;
1: 	}
1: 
1: 	/**
1: 	 * Builds a list of columns suitable for creating this Catalog.
1: 	 *
1: 	 *
1: 	 * @return array of SystemColumn suitable for making this catalog.
1: 	 */
1: 	public SystemColumn[]	buildColumnList()
1: 	{
0: 		if ( columnList != null ) { return columnList; }
1: 
0: 		columnList = new SystemColumn[SYSCOLUMNS_COLUMN_COUNT];
1: 
0: 		// describe columns
1: 
0: 		columnList[0] = 
0: 					new SystemColumnImpl(
0: 								convertIdCase( REFERENCEDID_STRING),			// column name
0: 								SYSCOLUMNS_REFERENCEID,// column number
0: 								0,					// precision
0: 								0,					// scale
0: 								false,				// nullability
0: 								"CHAR",				// dataType
0: 								true,				// built-in type
0: 								36					// maxLength
0: 			                   );
1: 
0: 		columnList[1] = 
0: 					new SystemColumnImpl(			// SQL IDENTIFIER
0: 								convertIdCase( COLUMNNAME_STRING),		// column name
0: 								SYSCOLUMNS_COLUMNNAME,	// column number
0: 								false				// nullability
0: 			                   );
1: 
0: 		columnList[2] = 
0: 					new SystemColumnImpl(
0: 								convertIdCase( "COLUMNNUMBER"),	// column name
0: 								SYSCOLUMNS_COLUMNNUMBER,	// column number
0: 								0,					// precision
0: 								0,					// scale
0: 								false,				// nullability
0: 								"INTEGER",				// dataType
0: 								true,				// built-in type
0: 								4					// maxLength
0: 							   );
1: 
0: 		columnList[3] = 
0: 					new SystemColumnImpl(	
0: 							convertIdCase( "COLUMNDATATYPE"),			// column name
0: 							SYSCOLUMNS_COLUMNDATATYPE,	// column number
0: 							0,					// precision
0: 							0,					// scale
0: 							false,				// nullability
0: 							"org.apache.derby.catalog.TypeDescriptor",	    // dataType
0: 							false,				// built-in type
0: 							TypeDescriptor.MAXIMUM_WIDTH_UNKNOWN // maxLength
0: 			               );
1: 
0: 		columnList[4] = 
0: 					new SystemColumnImpl(	
0: 							convertIdCase( "COLUMNDEFAULT"),			// column name
0: 							SYSCOLUMNS_COLUMNDEFAULT,	// column number
0: 							0,					// precision
0: 							0,					// scale
0: 							true,				// nullability
0: 							"java.io.Serializable",	    // dataType
0: 							false,				// built-in type
0: 							TypeDescriptor.MAXIMUM_WIDTH_UNKNOWN // maxLength
0: 			               );
1: 
0: 		columnList[5] = 
0: 					new SystemColumnImpl(
0: 								convertIdCase( COLUMNDEFAULTID_STRING),			// column name
0: 								SYSCOLUMNS_COLUMNDEFAULTID,// column number
0: 								0,					// precision
0: 								0,					// scale
0: 								true,				// nullability
0: 								"CHAR",				// dataType
0: 								true,				// built-in type
0: 								36					// maxLength
0: 			                   );
1: 
0: 		// new columns for autoincrement.
0: 		columnList[6] = 
0: 			        new SystemColumnImpl(
0: 							    convertIdCase( "AUTOINCREMENTVALUE"), // column name
0: 								SYSCOLUMNS_AUTOINCREMENTVALUE,
0: 								0,
0: 								0, 
1: 								true,
0: 								"BIGINT",
1: 								true,
0: 								TypeId.LONGINT_MAXWIDTH
0: 							   );
1: 		
0: 		columnList[7] = 
0: 			        new SystemColumnImpl(
0: 							    convertIdCase( "AUTOINCREMENTSTART"), // column name
0: 								SYSCOLUMNS_AUTOINCREMENTSTART,
0: 								0,
0: 								0, 
1: 								true,
0: 								"BIGINT",
1: 								true,
0: 								TypeId.LONGINT_MAXWIDTH
0: 							   );
1: 
0: 		columnList[8] = 
0: 			        new SystemColumnImpl(
0: 							    convertIdCase( "AUTOINCREMENTINC"), // column name
0: 								SYSCOLUMNS_AUTOINCREMENTINC,
0: 								0,
0: 								0, 
1: 								true,
0: 								"BIGINT",
1: 								true,
0: 								TypeId.LONGINT_MAXWIDTH
0: 							   );
1: 
0: 		return	columnList;
1: 	}
1: }
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:David Van Couvering
-------------------------------------------------------------------------------
commit:f739ad1
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:318307e
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 							defaultUUID, autoincStart, autoincInc);
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:1b54e9e
/////////////////////////////////////////////////////////////////////////
1: 			row.setColumn(SYSCOLUMNS_AUTOINCREMENTSTART, new SQLLongint(autoincStart));
commit:6a5edfc
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.impl.sql.compile.ColumnDefinitionNode;
0: 
/////////////////////////////////////////////////////////////////////////
1: 		//The SYSCOLUMNS table's autoinc related columns change with different
1: 		//values depending on what happened to the autoinc column, ie is the 
1: 		//user adding an autoincrement column, or is user changing the existing 
1: 		//autoincrement column to change it's increment value or to change it's
1: 		//start value? Following variable is used to keep track of what happened 
1: 		//to the autoincrement column.
1: 		long autoinc_create_or_modify_Start_Increment = -1;
/////////////////////////////////////////////////////////////////////////
1: 			autoinc_create_or_modify_Start_Increment = column.getAutoinc_create_or_modify_Start_Increment();
/////////////////////////////////////////////////////////////////////////
0: 		if (autoinc_create_or_modify_Start_Increment == ColumnDefinitionNode.CREATE_AUTOINCREMENT ||
0: 				autoinc_create_or_modify_Start_Increment == ColumnDefinitionNode.MODIFY_AUTOINCREMENT_INC_VALUE)
0: 		{//user is adding an autoinc column or is changing the increment value of autoinc column
1: 		} else if (autoinc_create_or_modify_Start_Increment == ColumnDefinitionNode.MODIFY_AUTOINCREMENT_RESTART_VALUE)
1: 		{//user asked for restart with a new value, so don't change increment by and original start
1: 			//with values in the SYSCOLUMNS table. Just record the RESTART WITH value as the
1: 			//next value to be generated in the SYSCOLUMNS table
1: 			ColumnDescriptor  column = (ColumnDescriptor)td;
1: 			row.setColumn(SYSCOLUMNS_AUTOINCREMENTVALUE, new SQLLongint(autoincStart));
0: 			row.setColumn(SYSCOLUMNS_AUTOINCREMENTSTART, new SQLLongint(
0: 					column.getTableDescriptor().getColumnDescriptor(colName).getAutoincStart()));
1: 			row.setColumn(SYSCOLUMNS_AUTOINCREMENTINC, new SQLLongint(
1: 					column.getTableDescriptor().getColumnDescriptor(colName).getAutoincInc()));
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /* IBM Confidential
0:  *
0:  * Product ID: 5697-F53
0:  *
0:  * (C) Copyright IBM Corp. 2000, 2001
0:  *
0:  * The source code for this program is not published or otherwise divested
0:  * of its trade secrets, irrespective of what has been deposited with the
0:  * U.S. Copyright Office.
0:  */
0: 
0: package org.apache.derby.impl.sql.catalog;
0: 
0: import org.apache.derby.iapi.reference.Property;
0: 
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: import org.apache.derby.iapi.types.TypeId;
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: 
0: import org.apache.derby.iapi.store.raw.RawStoreFactory;
0: 
0: import org.apache.derby.iapi.types.DataValueFactory;
0: import org.apache.derby.iapi.sql.dictionary.SystemColumn;
0: import org.apache.derby.catalog.TypeDescriptor;
0: import org.apache.derby.catalog.types.BaseTypeIdImpl;
0: 
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: 
0: import org.apache.derby.iapi.types.TypeId;
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: import org.apache.derby.iapi.types.DataValueFactory;
0: import org.apache.derby.iapi.types.RowLocation;
0: 
0: import org.apache.derby.iapi.sql.dictionary.CatalogRowFactory;
0: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.DataDescriptorGenerator;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.TupleDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.UniqueTupleDescriptor;
0: 
0: import org.apache.derby.iapi.sql.execute.ExecutionContext;
0: import org.apache.derby.iapi.sql.execute.ExecutionFactory;
0: import org.apache.derby.iapi.sql.execute.ExecIndexRow;
0: import org.apache.derby.iapi.sql.execute.ExecRow;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: import org.apache.derby.catalog.types.TypeDescriptorImpl;
0: import org.apache.derby.catalog.DefaultInfo;
0: import org.apache.derby.iapi.services.uuid.UUIDFactory;
0: import org.apache.derby.catalog.UUID;
0: 
0: import org.apache.derby.catalog.types.DefaultInfoImpl;
0: 
0: import org.apache.derby.iapi.types.*;
0: 
0: import java.io.Serializable;
0: 
0: import java.util.Properties;
0: 
0: /**
0:  * Factory for creating a SYSCOLUMNS row.
0:  *
0:  *
0:  * @version 0.1
0:  * @author Rick Hillegas (extracted from DataDictionaryImpl).
0:  */
0: 
0: public class SYSCOLUMNSRowFactory extends CatalogRowFactory
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2001;
0: 	static final String		TABLENAME_STRING = "SYSCOLUMNS";
0: 
0: 	/**
0: 	 * Old name for REFERENCEID, used by upgrade
0: 	 */
0: 	public static final String		OLD_REFERENCEID_NAME = "TABLEID";
0: 
0: 	protected static final int		SYSCOLUMNS_COLUMN_COUNT = 9;
0: 	/* Column #s for syscolumns (1 based) */
0: 
0: 	//TABLEID is an obsolete name, it is better to use 
0: 	//REFERENCEID, but to make life easier you can use either
0: 	protected static final int		SYSCOLUMNS_TABLEID = 1;
0: 	protected static final int		SYSCOLUMNS_REFERENCEID = 1;
0: 	protected static final int		SYSCOLUMNS_COLUMNNAME = 2;
0: 	protected static final int		SYSCOLUMNS_COLUMNNUMBER = 3;
0: 	protected static final int		SYSCOLUMNS_COLUMNDATATYPE = 4;
0: 	protected static final int		SYSCOLUMNS_COLUMNDEFAULT = 5;
0: 	protected static final int		SYSCOLUMNS_COLUMNDEFAULTID = 6;
0: 	protected static final int 		SYSCOLUMNS_AUTOINCREMENTVALUE = 7;
0: 	protected static final int 		SYSCOLUMNS_AUTOINCREMENTSTART = 8;
0: 	protected static final int		SYSCOLUMNS_AUTOINCREMENTINC = 9;
0: 
0: 	//private static final String	SYSCOLUMNS_INDEX1_NAME = "SYSCOLUMNS_INDEX1";
0: 	protected static final int		SYSCOLUMNS_INDEX1_ID = 0;
0: 
0: 	//private static final String	SYSCOLUMNS_INDEX2_NAME = "SYSCOLUMNS_INDEX2";
0: 	protected static final int		SYSCOLUMNS_INDEX2_ID = 1;
0: 
0: 	protected	static	final	String	REFERENCEDID_STRING = "REFERENCEID";
0: 	protected	static	final	String	COLUMNNAME_STRING = "COLUMNNAME";
0: 	protected	static	final	String	COLUMNDEFAULTID_STRING = "COLUMNDEFAULTID";
0: 
0:     private	static	final	boolean[]	uniqueness = {
0: 		                                               true,
0: 													   false
0: 	                                                 };
0: 
0: 	private	static	final	String[]	uuids =
0: 	{
0: 		 "8000001e-00d0-fd77-3ed8-000a0a0b1900"	// catalog UUID
0: 		,"80000029-00d0-fd77-3ed8-000a0a0b1900"	// heap UUID
0: 		,"80000020-00d0-fd77-3ed8-000a0a0b1900"	// SYSCOLUMNS_INDEX1 UUID
0: 		,"6839c016-00d9-2829-dfcd-000a0a411400"	// SYSCOLUMNS_INDEX2 UUID
0: 	};
0: 
0: 	private static final int[][] indexColumnPositions = 
0: 	{
0: 		{SYSCOLUMNS_REFERENCEID, SYSCOLUMNS_COLUMNNAME},
0: 		{SYSCOLUMNS_COLUMNDEFAULTID}
0: 	};
0: 
0: 	private static final String[][] indexColumnNames =
0: 	{
0: 		{REFERENCEDID_STRING, COLUMNNAME_STRING},
0: 		{COLUMNDEFAULTID_STRING}
0: 	};
0: 
0: 	/////////////////////////////////////////////////////////////////////////////
0: 	//
0: 	//	STATE
0: 	//
0: 	/////////////////////////////////////////////////////////////////////////////
0: 
0: 	private	SystemColumn[]		columnList;
0: 
0: 	/////////////////////////////////////////////////////////////////////////////
0: 	//
0: 	//	CONSTRUCTORS
0: 	//
0: 	/////////////////////////////////////////////////////////////////////////////
0: 
0:     public	SYSCOLUMNSRowFactory(UUIDFactory uuidf, ExecutionFactory ef, DataValueFactory dvf,
0:                                  boolean convertIdToLower)
0: 	{
0: 		this(uuidf, ef, dvf, convertIdToLower, TABLENAME_STRING);
0: 	}
0: 
0:     public	SYSCOLUMNSRowFactory(UUIDFactory uuidf, ExecutionFactory ef, DataValueFactory dvf,
0:                                  boolean convertIdToLower, String myName )
0: 	{
0: 		super(uuidf,ef,dvf,convertIdToLower);
0: 		initInfo(SYSCOLUMNS_COLUMN_COUNT, myName, indexColumnPositions, indexColumnNames, uniqueness, uuids);
0: 	}
0: 
0: 	/////////////////////////////////////////////////////////////////////////////
0: 	//
0: 	//	METHODS
0: 	//
0: 	/////////////////////////////////////////////////////////////////////////////
0: 
0:   /**
0: 	 * Make a SYSCOLUMNS row
0: 	 *
0: 	 * @param emptyRow	Make an empty row if this parameter is true
0: 	 * @param tableID	Table that the column is in
0: 	 * @param column	Column descriptor
0: 	 *
0: 	 * @return	Row suitable for inserting into SYSCOLUMNS.
0: 	 *
0: 	 * @exception   StandardException thrown on failure
0: 	 */
0: 
0: 	public ExecRow makeRow(TupleDescriptor td, TupleDescriptor parent)
0: 					throws StandardException
0: 	{
0: 		ExecRow    				row;
0: 		DataValueDescriptor		col;
0: 
0: 		String					colName = null;
0: 		String					defaultID = null;
0: 		String					tabID = null;
0: 		Integer					colID = null;
0: 		TypeDescriptorImpl		typeDesc = null;
0: 		Object					defaultSerializable = null;
0: 		long					autoincStart = 0;
0: 		long					autoincInc = 0;
0: 
0: 		if (td != null)
0: 		{
0: 			ColumnDescriptor  column = (ColumnDescriptor)td;
0: 		
0: 			/* Lots of info in the column's type descriptor */
0: 			typeDesc = column.getType().getCatalogType();
0: 
0: 			tabID = column.getReferencingUUID().toString();
0: 			colName = column.getColumnName();
0: 			colID = new Integer(column.getPosition() );
0: 			autoincStart = column.getAutoincStart();
0: 			autoincInc   = column.getAutoincInc();
0: 			if (column.getDefaultInfo() != null)
0: 			{
0: 				defaultSerializable = column.getDefaultInfo();
0: 			}
0: 			else
0: 			{
0: 				defaultSerializable = column.getDefaultValue();
0: 			}
0: 			if  (column.getDefaultUUID() != null)
0: 			{
0: 				defaultID = column.getDefaultUUID().toString();
0: 			}
0: 		}
0: 
0: 		/* Insert info into syscolumns */
0: 
0: 		/* RESOLVE - It would be nice to require less knowledge about syscolumns
0: 		 * and have this be more table driven.
0: 		 * RESOLVE - We'd like to store the DataTypeDescriptor in a column.
0: 		 */
0: 
0: 		/* Build the row to insert  */
0: 		row = getExecutionFactory().getValueRow(SYSCOLUMNS_COLUMN_COUNT);
0: 
0: 		/* 1st column is REFERENCEID (UUID - char(36)) */
0: 		row.setColumn(SYSCOLUMNS_REFERENCEID, dvf.getCharDataValue(tabID));
0: 
0: 		/* 2nd column is COLUMNNAME (varchar(128)) */
0: 		row.setColumn(SYSCOLUMNS_COLUMNNAME, dvf.getVarcharDataValue(colName));
0: 
0: 		/* 3rd column is COLUMNNUMBER (int) */
0: 		row.setColumn(SYSCOLUMNS_COLUMNNUMBER, dvf.getDataValue(colID));
0: 
0: 		/* 4th column is COLUMNDATATYPE */
0: 		row.setColumn(SYSCOLUMNS_COLUMNDATATYPE,
0: 				dvf.getDataValue(typeDesc));
0: 
0: 		/* 5th column is COLUMNDEFAULT */
0: 		row.setColumn(SYSCOLUMNS_COLUMNDEFAULT,
0: 					  dvf.getDataValue(defaultSerializable));
0: 
0: 		/* 6th column is DEFAULTID (UUID - char(36)) */
0: 		row.setColumn(SYSCOLUMNS_COLUMNDEFAULTID, dvf.getCharDataValue(defaultID));
0: 
0: 		if (autoincInc != 0)
0: 		{
0: 			row.setColumn(SYSCOLUMNS_AUTOINCREMENTVALUE, 
0: 						  new SQLLongint(autoincStart));
0: 			row.setColumn(SYSCOLUMNS_AUTOINCREMENTSTART, 
0: 						  new SQLLongint(autoincStart));
0: 			row.setColumn(SYSCOLUMNS_AUTOINCREMENTINC, 
0: 						  new SQLLongint(autoincInc));
0: 		}
0: 		else
0: 		{
0: 			row.setColumn(SYSCOLUMNS_AUTOINCREMENTVALUE, 
0: 						  new SQLLongint());
0: 			row.setColumn(SYSCOLUMNS_AUTOINCREMENTSTART, 
0: 						  new SQLLongint());
0: 			row.setColumn(SYSCOLUMNS_AUTOINCREMENTINC,
0: 						  new SQLLongint());
0: 		}
0: 		return row;
0: 	}
0: 
0: 	/**
0: 	 * Get the Properties associated with creating the heap.
0: 	 *
0: 	 * @return The Properties associated with creating the heap.
0: 	 */
0: 	public Properties getCreateHeapProperties()
0: 	{
0: 		Properties properties = new Properties();
0: 		// keep page size at 4K since its a big table
0: 		properties.put(Property.PAGE_SIZE_PARAMETER,"4096");
0: 		// default properties for system tables:
0: 		properties.put(RawStoreFactory.PAGE_RESERVED_SPACE_PARAMETER,"0");
0: 		properties.put(RawStoreFactory.MINIMUM_RECORD_SIZE_PARAMETER,"1");
0: 		return properties;
0: 	}
0: 
0: 	/**
0: 	 * Get the Properties associated with creating the specified index.
0: 	 *
0: 	 * @param indexNumber	The specified index number.
0: 	 *
0: 	 * @return The Properties associated with creating the specified index.
0: 	 */
0: 	public Properties getCreateIndexProperties(int indexNumber)
0: 	{
0: 		Properties properties = new Properties();
0: 		// keep page size for all indexes at 4K since its a big table
0: 		properties.put(Property.PAGE_SIZE_PARAMETER,"4096");
0: 		return properties;
0: 	}
0: 
0: 	///////////////////////////////////////////////////////////////////////////
0: 	//
0: 	//	ABSTRACT METHODS TO BE IMPLEMENTED BY CHILDREN OF CatalogRowFactory
0: 	//
0: 	///////////////////////////////////////////////////////////////////////////
0: 
0: 	/**
0: 	 * Builds an empty index row.
0: 	 *
0: 	 *	@param	indexNumber	Index to build empty row for.
0: 	 *  @param  rowLocation	Row location for last column of index row
0: 	 *
0: 	 * @return corresponding empty index row
0: 	 * @exception   StandardException thrown on failure
0: 	 */
0: 	public ExecIndexRow	buildEmptyIndexRow( int indexNumber,
0: 											RowLocation rowLocation) 
0: 			throws StandardException
0: 	{
0: 		int ncols = getIndexColumnCount(indexNumber);
0: 		ExecIndexRow row = getExecutionFactory().getIndexableRow(ncols + 1);
0: 
0: 		row.setColumn(ncols + 1, rowLocation);
0: 
0: 		switch(indexNumber)
0: 		{
0: 			case SYSCOLUMNS_INDEX1_ID:
0: 				/* 1st column is REFERENCEID (UUID - char(36)) */
0: 				row.setColumn
0: 					(1, getDataValueFactory().getCharDataValue((String) null));
0: 
0: 				/* 2nd column is COLUMNNAME (varchar(128)) */
0: 				row.setColumn
0: 				    (2, 
0: 					 getDataValueFactory().getVarcharDataValue((String) null));
0: 
0: 				break;
0: 
0: 		    case SYSCOLUMNS_INDEX2_ID:
0: 				
0: 				/* 1st column is DEFAULTID (UUID - char(36)) */
0: 				row.setColumn
0: 					(1, getDataValueFactory().getCharDataValue((String) null));
0: 
0: 				break;
0: 		}	// end switch
0: 
0: 		return	row;
0: 	}
0: 
0: 
0: 	/**
0: 	 * Make a ColumnDescriptor out of a SYSCOLUMNS row
0: 	 *
0: 	 * @param row 					a SYSCOLUMNS row
0: 	 * @param parentTupleDescriptor	The UniqueTupleDescriptor for the object that is tied
0: 	 *								to this column
0: 	 * @param dd 					dataDictionary
0: 	 *
0: 	 * @return	a column descriptor equivalent to a SYSCOLUMNS row
0: 	 *
0: 	 * @exception   StandardException thrown on failure
0: 	 */
0: 	public TupleDescriptor buildDescriptor(
0: 		ExecRow					row,
0: 		TupleDescriptor			parentTupleDescriptor,
0: 		DataDictionary 			dd )
0: 					throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(row.nColumns() == SYSCOLUMNS_COLUMN_COUNT, 
0: 								 "Wrong number of columns for a SYSCOLUMNS row");
0: 		}
0: 
0: 		int columnNumber;
0: 		String columnName;
0: 		String defaultID;
0: 		DefaultInfoImpl		defaultInfo = null;
0: 		ColumnDescriptor colDesc;
0: 		BaseTypeIdImpl		typeId;
0: 		TypeId	wrapperTypeId;
0: 		DataValueDescriptor	defaultValue = null;
0: 		UUID				defaultUUID = null;
0: 		UUID				uuid = null;
0: 		UUIDFactory			uuidFactory = getUUIDFactory();
0: 		long autoincStart, autoincInc;
0: 
0: 		DataDescriptorGenerator	ddg = dd.getDataDescriptorGenerator();
0: 
0: 
0: 		/*
0: 		** We're going to be getting the UUID for this sucka
0: 		** so make sure it is a UniqueTupleDescriptor.
0: 		*/
0: 		if (parentTupleDescriptor != null)
0: 		{
0: 			if (SanityManager.DEBUG)
0: 			{
0: 				if (!(parentTupleDescriptor instanceof UniqueTupleDescriptor))
0: 				{
0: 					SanityManager.THROWASSERT(parentTupleDescriptor.getClass().getName() 
0: 							+ " not instanceof UniqueTupleDescriptor");	
0: 				}
0: 			}
0: 			uuid = ((UniqueTupleDescriptor)parentTupleDescriptor).getUUID();
0: 		}
0: 		else
0: 		{
0: 			/* 1st column is REFERENCEID (char(36)) */
0: 			uuid = uuidFactory.recreateUUID(row.getColumn(SYSCOLUMNS_REFERENCEID).
0: 													getString());
0: 		}
0: 
0: 		/* NOTE: We get columns 5 and 6 next in order to work around 
0: 		 * a 1.3.0 HotSpot bug.  (#4361550)
0: 		 */
0: 
0: 		// 5th column is COLUMNDEFAULT (serialiazable)
0: 		Object object = row.getColumn(SYSCOLUMNS_COLUMNDEFAULT).getObject();
0: 		if (object instanceof DataValueDescriptor)
0: 		{
0: 			defaultValue = (DataValueDescriptor) object;
0: 		}
0: 		else if (object instanceof DefaultInfoImpl)
0: 		{
0: 			defaultInfo = (DefaultInfoImpl) object;
0: 			defaultValue = defaultInfo.getDefaultValue();
0: 		}
0: 
0: 		/* 6th column is DEFAULTID (char(36)) */
0: 		defaultID = row.getColumn(SYSCOLUMNS_COLUMNDEFAULTID).getString();
0: 
0: 		if (defaultID != null)
0: 		{
0: 			defaultUUID = uuidFactory.recreateUUID(defaultID);
0: 		}
0: 
0: 		/* 2nd column is COLUMNNAME (varchar(128)) */
0: 		columnName = row.getColumn(SYSCOLUMNS_COLUMNNAME).getString();
0: 
0: 		/* 3rd column is COLUMNNUMBER (int) */
0: 		columnNumber = row.getColumn(SYSCOLUMNS_COLUMNNUMBER).getInt();
0: 
0: 		/* 4th column is COLUMNDATATYPE */
0: 
0: 		/*
0: 		** What is stored in the column is a TypeDescriptorImpl, which
0: 		** points to a BaseTypeIdImpl.  These are simple types that are
0: 		** intended to be movable to the client, so they don't have
0: 		** the entire implementation.  We need to wrap them in DataTypeServices
0: 		** and TypeId objects that contain the full implementations for
0: 		** language processing.
0: 		*/
0: 		TypeDescriptorImpl typeDescriptor = (TypeDescriptorImpl) row.getColumn(SYSCOLUMNS_COLUMNDATATYPE).
0: 													getObject();
0: 		typeId = typeDescriptor.getTypeId();
0: 
0: 		/*
0: 		** The BaseTypeIdImpl tells what type of TypeId it is supposed to
0: 		** be wrapped in.
0: 		*/
0: 		wrapperTypeId =
0: 			(TypeId) Monitor.newInstanceFromIdentifier(typeId.wrapperTypeFormatId());
0: 		/* Wrap the BaseTypeIdImpl in a full type id */
0: 		wrapperTypeId.setNestedTypeId(typeId);
0: 
0: 		/* Wrap the TypeDescriptorImpl in a full DataTypeDescriptor */
0: 		DataTypeDescriptor dataTypeServices = new DataTypeDescriptor(typeDescriptor,
0: 													wrapperTypeId);
0: 
0: 		/* 7th column is AUTOINCREMENTVALUE, not cached in descriptor (long) */
0: 
0: 		/* 8th column is AUTOINCREMENTSTART (long) */
0: 		autoincStart = row.getColumn(SYSCOLUMNS_AUTOINCREMENTSTART).getLong();
0: 
0: 		/* 9th column is AUTOINCREMENTINC (long) */
0: 		autoincInc = row.getColumn(SYSCOLUMNS_AUTOINCREMENTINC).getLong();
0: 
0: 		/* NOTE: We use the autoincColumn variable in order to work around 
0: 		 * a 1.3.0 HotSpot bug.  (#4361550)
0: 		 */
0: 		boolean autoincColumn = (autoincInc != 0); 
0: 
0: 		DataValueDescriptor col = row.getColumn(SYSCOLUMNS_AUTOINCREMENTSTART);
0: 		autoincStart = col.getLong();
0: 
0: 		col = row.getColumn(SYSCOLUMNS_AUTOINCREMENTINC);
0: 		autoincInc = col.getLong();
0: 
0: 		colDesc = new ColumnDescriptor(columnName, columnNumber,
0: 							dataTypeServices, defaultValue, defaultInfo, uuid, 
0: 							defaultUUID, autoincStart, autoincInc, 
0: 							autoincColumn);
0: 		return colDesc;
0: 	}
0: 
0: 	/**
0: 	  *	Get the index number for the primary key index on this catalog.
0: 	  *
0: 	  *	@return	a 0-based number
0: 	  *
0: 	  */
0: 	public	int	getPrimaryKeyIndexNumber()
0: 	{
0: 		return SYSCOLUMNS_INDEX1_ID;
0: 	}
0: 
0: 	/**
0: 	 * Builds a list of columns suitable for creating this Catalog.
0: 	 *
0: 	 *
0: 	 * @return array of SystemColumn suitable for making this catalog.
0: 	 */
0: 	public SystemColumn[]	buildColumnList()
0: 	{
0: 		if ( columnList != null ) { return columnList; }
0: 
0: 		columnList = new SystemColumn[SYSCOLUMNS_COLUMN_COUNT];
0: 
0: 		// describe columns
0: 
0: 		columnList[0] = 
0: 					new SystemColumnImpl(
0: 								convertIdCase( REFERENCEDID_STRING),			// column name
0: 								SYSCOLUMNS_REFERENCEID,// column number
0: 								0,					// precision
0: 								0,					// scale
0: 								false,				// nullability
0: 								"CHAR",				// dataType
0: 								true,				// built-in type
0: 								36					// maxLength
0: 			                   );
0: 
0: 		columnList[1] = 
0: 					new SystemColumnImpl(			// SQL IDENTIFIER
0: 								convertIdCase( COLUMNNAME_STRING),		// column name
0: 								SYSCOLUMNS_COLUMNNAME,	// column number
0: 								false				// nullability
0: 			                   );
0: 
0: 		columnList[2] = 
0: 					new SystemColumnImpl(
0: 								convertIdCase( "COLUMNNUMBER"),	// column name
0: 								SYSCOLUMNS_COLUMNNUMBER,	// column number
0: 								0,					// precision
0: 								0,					// scale
0: 								false,				// nullability
0: 								"INTEGER",				// dataType
0: 								true,				// built-in type
0: 								4					// maxLength
0: 							   );
0: 
0: 		columnList[3] = 
0: 					new SystemColumnImpl(	
0: 							convertIdCase( "COLUMNDATATYPE"),			// column name
0: 							SYSCOLUMNS_COLUMNDATATYPE,	// column number
0: 							0,					// precision
0: 							0,					// scale
0: 							false,				// nullability
0: 							"org.apache.derby.catalog.TypeDescriptor",	    // dataType
0: 							false,				// built-in type
0: 							TypeDescriptor.MAXIMUM_WIDTH_UNKNOWN // maxLength
0: 			               );
0: 
0: 		columnList[4] = 
0: 					new SystemColumnImpl(	
0: 							convertIdCase( "COLUMNDEFAULT"),			// column name
0: 							SYSCOLUMNS_COLUMNDEFAULT,	// column number
0: 							0,					// precision
0: 							0,					// scale
0: 							true,				// nullability
0: 							"java.io.Serializable",	    // dataType
0: 							false,				// built-in type
0: 							TypeDescriptor.MAXIMUM_WIDTH_UNKNOWN // maxLength
0: 			               );
0: 
0: 		columnList[5] = 
0: 					new SystemColumnImpl(
0: 								convertIdCase( COLUMNDEFAULTID_STRING),			// column name
0: 								SYSCOLUMNS_COLUMNDEFAULTID,// column number
0: 								0,					// precision
0: 								0,					// scale
0: 								true,				// nullability
0: 								"CHAR",				// dataType
0: 								true,				// built-in type
0: 								36					// maxLength
0: 			                   );
0: 
0: 		// new columns for autoincrement.
0: 		columnList[6] = 
0: 			        new SystemColumnImpl(
0: 							    convertIdCase( "AUTOINCREMENTVALUE"), // column name
0: 								SYSCOLUMNS_AUTOINCREMENTVALUE,
0: 								0,
0: 								0, 
0: 								true,
0: 								"BIGINT",
0: 								true,
0: 								TypeId.LONGINT_MAXWIDTH
0: 							   );
0: 		
0: 		columnList[7] = 
0: 			        new SystemColumnImpl(
0: 							    convertIdCase( "AUTOINCREMENTSTART"), // column name
0: 								SYSCOLUMNS_AUTOINCREMENTSTART,
0: 								0,
0: 								0, 
0: 								true,
0: 								"BIGINT",
0: 								true,
0: 								TypeId.LONGINT_MAXWIDTH
0: 							   );
0: 
0: 		columnList[8] = 
0: 			        new SystemColumnImpl(
0: 							    convertIdCase( "AUTOINCREMENTINC"), // column name
0: 								SYSCOLUMNS_AUTOINCREMENTINC,
0: 								0,
0: 								0, 
0: 								true,
0: 								"BIGINT",
0: 								true,
0: 								TypeId.LONGINT_MAXWIDTH
0: 							   );
0: 
0: 		return	columnList;
0: 	}
0: }
============================================================================