1:5d24c78: /*
1:5d24c78:  
1:9c2b1f3: Derby - Class org.apache.derbyTesting.functionTests.tests.replicationTests.ReplicationRun_Full
1:5d24c78:  
1:5d24c78: Licensed to the Apache Software Foundation (ASF) under one or more
1:5d24c78: contributor license agreements.  See the NOTICE file distributed with
1:5d24c78: this work for additional information regarding copyright ownership.
1:5d24c78: The ASF licenses this file to You under the Apache License, Version 2.0
1:5d24c78: (the "License"); you may not use this file except in compliance with
1:5d24c78: the License.  You may obtain a copy of the License at
1:5d24c78:  
1:5d24c78:    http://www.apache.org/licenses/LICENSE-2.0
1:5d24c78:  
1:5d24c78: Unless required by applicable law or agreed to in writing, software
1:5d24c78: distributed under the License is distributed on an "AS IS" BASIS,
1:5d24c78: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:5d24c78: See the License for the specific language governing permissions and
1:5d24c78: limitations under the License.
1:5d24c78:  
1:5d24c78:  */
1:5d24c78: package org.apache.derbyTesting.functionTests.tests.replicationTests;
1:5d24c78: 
1:5d24c78: import junit.framework.Test;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:40a554b: import org.apache.derbyTesting.junit.SecurityManagerSetup;
1:5d24c78: 
1:5d24c78: public class ReplicationRun_Full extends ReplicationRun
1:5d24c78: {
1:5d24c78:     
1:5d24c78:     public ReplicationRun_Full(String testcaseName)
1:5d24c78:     {
1:5d24c78:         super(testcaseName);
1:5d24c78:         
1:5d24c78:         LF = System.getProperties().getProperty("line.separator");
1:5d24c78:     }
1:5d24c78:         
1:5d24c78:     public static Test suite()
1:5d24c78:     {
1:5d24c78:         
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite("Replication_Full Suite");
1:5d24c78:         
1:5d24c78:         suite.addTestSuite( ReplicationRun_Full.class );
1:5d24c78:         
1:40a554b:         return SecurityManagerSetup.noSecurityManager(suite);
1:5d24c78:     }
1:5d24c78:     
1:5d24c78:     //////////////////////////////////////////////////////////////
1:5d24c78:     ////
1:5d24c78:     //// The replication test framework (testReplication()):
1:5d24c78:     //// a) "clean" replication run starting master and slave servers,
1:5d24c78:     ////     preparing master and slave databases,
1:5d24c78:     ////     starting and stopping replication and doing
1:5d24c78:     ////     failover for a "normal"/"failure free" replication
1:5d24c78:     ////     test run.
1:5d24c78:     //// b)  Running (positive and negative) tests at the various states 
1:5d24c78:     ////     of replication to test what is and is not accepted compared to
1:5d24c78:     ////     the functional specification.
1:5d24c78:     //// c)  Adding additional load on master and slave servers in 
1:5d24c78:     ////     different states of replication.
1:5d24c78:     ////
1:5d24c78:     //////////////////////////////////////////////////////////////
1:5d24c78:     
1:5d24c78:     public void testReplication()
1:5d24c78:     throws Exception
1:5d24c78:     {
1:5d24c78:         cleanAllTestHosts();
1:5d24c78:         
1:5d24c78:         initEnvironment();
1:5d24c78:         
1:5d24c78:         /* 'testReplication' steps through all states of the
1:5d24c78:          * replication process.
1:5d24c78:          * Tests required to be run in these states
1:5d24c78:          * should be specified in the replicationtest.properties file.
1:5d24c78:          */
1:5d24c78:         if ( runUnReplicated )  // test.runUnReplicated
1:5d24c78:         {
1:5d24c78:             util.DEBUG("**** BEGIN Running test without replication.");
1:5d24c78:             initMaster(masterServerHost,
1:5d24c78:                     replicatedDb);
1:5d24c78:             startServer(masterJvmVersion, derbyVersion, // No replication
1:5d24c78:                     masterServerHost,
1:5d24c78:                     ALL_INTERFACES, // masterServerHost, // "0.0.0.0", // All. or use masterServerHost for interfacesToListenOn,
1:5d24c78:                     masterServerPort,
1:dbe5dc3:                     masterDbSubPath); // Distinguishing master/slave
1:5d24c78:             runTest(replicationTest,
1:5d24c78:                     jvmVersion,
1:5d24c78:                     testClientHost,
1:5d24c78:                     masterServerHost, masterServerPort,
1:5d24c78:                     replicatedDb);
1:5d24c78:             stopServer(masterJvmVersion, derbyMasterVersion,
1:5d24c78:                     masterServerHost, masterServerPort);
1:5d24c78:             util.DEBUG("**** END Running test without replication.");
1:5d24c78:             // util.sleep(5000L, "End of runUnReplicated"); // Just for testing....
1:5d24c78:         }
1:5d24c78:         
1:5d24c78:         ///////////////////////////////////////////////////////
1:5d24c78:         // State: PreStartedMasterServer, PreStartedSlaveServer
1:5d24c78:             if (state.testPreStartedMasterServer()) return;
1:5d24c78:                 
1:5d24c78:         initMaster(masterServerHost,
1:5d24c78:                 replicatedDb); // Prototype V2: copy orig (possibly empty) db to db_master.
1:5d24c78:         
1:136610d:         startServer(masterJvmVersion, derbyMasterVersion,
1:5d24c78:                 masterServerHost,
1:5d24c78:                 ALL_INTERFACES, // masterServerHost, // "0.0.0.0", // All. or use masterServerHost for interfacesToListenOn,
1:5d24c78:                 masterServerPort,
1:dbe5dc3:                 masterDbSubPath); // Distinguishing master/slave
1:5d24c78:         ///////////////////////////////////////////////////////
1:5d24c78:         // State: PostStartedMasterServer, PreStartedSlaveServer
1:5d24c78:         
1:5d24c78:         startOptionalLoad(masterPreRepl,
1:5d24c78:                 masterDbSubPath,
1:5d24c78:                 masterServerHost,
1:5d24c78:                 masterServerPort);
1:5d24c78:         
1:5d24c78:             if (state.testPreStartedSlaveServer()) return; // + stop master server!
1:5d24c78:         
1:5d24c78:         // Thread.sleep(5000L); // Just for testing....
1:136610d:         startServer(slaveJvmVersion, derbySlaveVersion,
1:5d24c78:                 slaveServerHost,
1:5d24c78:                 ALL_INTERFACES, // slaveServerHost, // "0.0.0.0", // All. or use slaveServerHost for interfacesToListenOn,
1:5d24c78:                 slaveServerPort,
1:dbe5dc3:                 slaveDbSubPath); // Distinguishing master/slave
1:5d24c78:         ///////////////////////////////////////////////////////
1:5d24c78:         // State: PostStartedMasterServer, PostStartedSlaveServer
1:5d24c78:         //        PreStartedMaster,        PreStartedSlave
1:5d24c78:         
1:5d24c78:         // Thread.sleep(15000L); // Just for testing....
1:5d24c78:         startServerMonitor(slaveServerHost);
1:5d24c78:         
1:5d24c78:         xFindServerPID(slaveServerHost, slaveServerPort); // JUST DEBUGGING!
1:5d24c78:         
1:5d24c78:         bootMasterDatabase(jvmVersion,
1:5d24c78:                 masterDatabasePath +FS+ masterDbSubPath,
1:5d24c78:                 replicatedDb,
1:5d24c78:                 masterServerHost, // Where the startreplication command must be given
1:5d24c78:                 masterServerPort, // master server interface accepting client requests
1:5d24c78:                 null // bootLoad, // The "test" to start when booting db.
1:5d24c78:                 );
1:5d24c78:         
1:5d24c78:         ///////////////////////////////////////////////////////
1:5d24c78:         // State: PostStartedMasterServer, PostStartedSlaveServer
1:5d24c78:         //        PostStartedMaster,       PreStartedSlave
1:5d24c78:         
1:5d24c78:         startOptionalLoad(masterPostRepl,
1:5d24c78:                 masterDbSubPath,
1:5d24c78:                 masterServerHost,
1:5d24c78:                 masterServerPort);
1:5d24c78:         
1:5d24c78:         startOptionalLoad(slavePreSlave,
1:5d24c78:                 slaveDbSubPath,
1:5d24c78:                 slaveServerHost,
1:5d24c78:                 slaveServerPort);
1:5d24c78:         
1:5d24c78:         // util.sleep(sleepTime, "Before initSlave"); // A. 'Something wrong with the instants!' if removed!
1:5d24c78:         // 5secs is too little! 15secs is too little sometimes...!
1:5d24c78:         // 30secs is too little w/ShutdownSlave!
1:5d24c78:         
1:5d24c78:         
1:5d24c78:             if (state.testPreInitSlave()) return;
1:5d24c78: 
1:5d24c78:         initSlave(/*slaveHost*/ slaveServerHost,
1:5d24c78:                 jvmVersion,
1:5d24c78:                 replicatedDb); // Trunk and Prototype V2: copy master db to db_slave.
1:5d24c78:         
1:5d24c78: 
1:5d24c78:             if (state.testPreStartedSlave()) return;
1:5d24c78:                 
1:5d24c78:          startSlave(jvmVersion, replicatedDb,
1:5d24c78:                 slaveServerHost, // slaveClientInterface // where the slave db runs
1:5d24c78:                 slaveServerPort,
1:5d24c78:                 slaveServerHost, // for slaveReplInterface
1:5d24c78:                 slaveReplPort,
1:5d24c78:                 testClientHost);
1:5d24c78: 
1:5d24c78:             if (state.testPreStartedMaster()) return;
1:5d24c78:         
1:5d24c78:        startMaster(jvmVersion, replicatedDb,
1:5d24c78:                 masterServerHost, // Where the startMaster command must be given
1:5d24c78:                 masterServerPort, // master server interface accepting client requests
1:5d24c78:                 masterServerHost, // An interface on the master: masterClientInterface (==masterServerHost),
1:5d24c78:                 slaveServerPort, // Not used since slave don't allow clients.
1:5d24c78:                 slaveServerHost, // for slaveReplInterface
1:5d24c78:                 slaveReplPort);
1:5d24c78:         
1:5d24c78:         ///////////////////////////////////////////////////////
1:5d24c78:         // State: PostStartedMasterServer, PostStartedSlaveServer
1:5d24c78:         //        PostStartedMaster,       PostStartedSlave
1:5d24c78:         
1:5d24c78:         startOptionalLoad(masterPostSlave,
1:5d24c78:                 masterDbSubPath,
1:5d24c78:                 masterServerHost,
1:5d24c78:                 masterServerPort);
1:5d24c78:         
1:5d24c78:         startOptionalLoad(slavePostSlave,
1:5d24c78:                 slaveDbSubPath,
1:5d24c78:                 slaveServerHost,
1:5d24c78:                 slaveServerPort);
1:5d24c78:         
1:5d24c78:         // Thread.sleep(5000L); // Just for testing....
1:5d24c78:         // util.sleep(10000L, "Before runTest"); // Perf. testing....
1:5d24c78:         
1:5d24c78:             if (state.testPostStartedMasterAndSlave()) return;
1:5d24c78:             // Could be run concurrently with runTest below?
1:5d24c78:         
1:5d24c78:         // Used to run positive tests? Handle negative testing in State.testPostStartedMasterAndSlave()?
1:5d24c78:         // Observe that it will not be meaningful to do runTest if State.XXXX() 
1:5d24c78:         // has led to incorrect replication state wrt. replicationTest.
1:5d24c78:         runTest(replicationTest, // Returns immediatly if replicationTest is null.
1:5d24c78:                 jvmVersion,
1:5d24c78:                 testClientHost,
1:5d24c78:                 masterServerHost, masterServerPort,
1:5d24c78:                 replicatedDb);
1:5d24c78:         
1:5d24c78:         ///////////////////////////////////////////////////////
1:5d24c78:         // State: PostStartedMasterServer, PostStartedSlaveServer
1:5d24c78:         //        PostStartedMaster,       PostStartedSlave
1:5d24c78:         //        PreStoppedMaster,        PreStoppedSlave
1:5d24c78:             if (state.testPreStoppedMaster()) return;
1:5d24c78:         
1:5d24c78: // PoC        stopMaster(replicatedDb); // v7: RENAMED! FIXME! when 'stopMaster' cmd. available! // master..
1:5d24c78: /*         stopMaster_ij(jvmVersion, replicatedDb,
1:5d24c78:                 masterServerHost,
1:5d24c78:                 masterServerPort,
1:5d24c78:                 testClientHost);
1:5d24c78:  */
1:5d24c78:         ///////////////////////////////////////////////////////
1:5d24c78:         // State: PostStartedMasterServer, PostStartedSlaveServer
1:5d24c78:         //        PostStartedMaster,       PostStartedSlave
1:5d24c78:         //        PostStoppedMaster,       PreStoppedSlave,       PreFailover
1:5d24c78:         
1:5d24c78:         // Thread.sleep(5000L); // Just for testing....
1:5d24c78:         
1:5d24c78:             if (state.testPreStoppedMasterServer()) return;
1:5d24c78:         
1:5d24c78: /* PoC        stopServer(masterJvmVersion, derbyMasterVersion, // v7: NA // PoC V2b: forces failover on slave
1:5d24c78:                 masterServerHost, masterServerPort);
1:5d24c78:  */
1:5d24c78:         ///////////////////////////////////////////////////////
1:5d24c78:         // State: PostStartedMasterServer, PostStartedSlaveServer
1:5d24c78:         //        PostStartedMaster,       PostStartedSlave
1:5d24c78:         //        PostStoppedMaster,       PreStoppedSlave
1:5d24c78:         //        PostStoppedMasterServer, PreStoppedSlaveServer,  PoC:  PostFailover
1:5d24c78:             if (state.testPreStoppedSlave()) return;
1:5d24c78:         
1:5d24c78:         // Thread.sleep(5000L); // Just for testing....
1:5d24c78: // PoC        stopSlave(replicatedDb); // v7: NEW! FIXME! when 'stopSlave' cmd. available!
1:5d24c78: /*         stopSlave_ij(jvmVersion, replicatedDb,
1:5d24c78:                 slaveServerHost,
1:5d24c78:                 slaveServerPort,
1:5d24c78:                 testClientHost);
1:5d24c78:  */
1:5d24c78:         ///////////////////////////////////////////////////////
1:5d24c78:         // State: PostStartedMasterServer, PostStartedSlaveServer
1:5d24c78:         //        PostStartedMaster,       PostStartedSlave
1:5d24c78:         //        PostStoppedMaster,       PostStoppedSlave
1:5d24c78:         //        PostStoppedMasterServer, PreStoppedSlaveServer,  PreFailover // PoC:  PostFailover
1:5d24c78:         
1:5d24c78:         // Thread.sleep(5000L); // Just for testing....
1:5d24c78:         failOver(jvmVersion, // On master, which is the normal case.
1:5d24c78:             masterDatabasePath, masterDbSubPath, replicatedDb,
1:5d24c78:             masterServerHost,  // Where the master db is run.
1:5d24c78:             masterServerPort,
1:5d24c78:             testClientHost);
1:5d24c78: 
1:5d24c78: // PoC        failOver(replicatedDb); // FIXME! when 'failOver' cmd. available!
1:5d24c78: 
1:5d24c78:         ///////////////////////////////////////////////////////
1:5d24c78:         // State: PostStartedMasterServer, PostStartedSlaveServer
1:5d24c78:         //        PostStartedMaster,       PostStartedSlave
1:5d24c78:         //        PostStoppedMaster,       PostStoppedSlave
1:5d24c78:         //        PostStoppedMasterServer, PreStoppedSlaveServer,  PostFailover
1:5d24c78:         
1:5d24c78:         // util.sleep(10000L, "After failover"); // Try to avoid DERBY-3463....
1:5d24c78:         connectPing(slaveDatabasePath+FS+slaveDbSubPath+FS+replicatedDb,
1:5d24c78:                 slaveServerHost,slaveServerPort,
1:5d24c78:                 testClientHost);
1:5d24c78:         
1:5d24c78:         // If the slave server was shutdown, killed or died, start a "default" server on
1:5d24c78:         // the same server and port to do the verification:
1:5d24c78:         int slavePid = xFindServerPID(slaveServerHost, slaveServerPort);
1:5d24c78:         if ( slavePid == -1 )
1:5d24c78:         {
1:5d24c78:             util.DEBUG("WARNING: slave server not available. Starting.");
1:136610d:             startServer(jvmVersion, derbyVersion,
1:5d24c78:                     slaveServerHost,
1:5d24c78:                     ALL_INTERFACES, // slaveServerHost, // "0.0.0.0", // All. or use slaveServerHost for interfacesToListenOn,
1:5d24c78:                     slaveServerPort,
1:dbe5dc3:                     slaveDbSubPath); // Distinguishing master/slave
1:5d24c78:         }
1:5d24c78:         /* BEGIN Failover do not yet clean replication mode on slave! Must restart the server!*/
1:5d24c78:         else{
1:5d24c78:           if (true)
1:5d24c78:           {
1:5d24c78:             util.DEBUG("*********************** DERBY-3205/svn 630806. failover does now unset replication mode on slave.");
1:5d24c78:           }
1:5d24c78:           else // failover does not unset replication mode on slave.
1:5d24c78:           {
1:5d24c78:             util.DEBUG("*********************** DERBY-3205. failover does not unset replication mode on slave.");
1:5d24c78:             /* That also blocks for connecting!:
1:5d24c78:             // Do slave db shutdown (and reconnect) to unset... PRELIMINARY!!!
1:5d24c78:             shutdownDb(slaveServerHost,slaveServerPort,
1:5d24c78:                     slaveDatabasePath +FS+ slaveDbSubPath,replicatedDb);
1:5d24c78:              */
1:5d24c78:             /* */
1:5d24c78:             restartServer(jvmVersion, derbyVersion, // restart server is too strong!
1:5d24c78:                     slaveServerHost,
1:5d24c78:                     ALL_INTERFACES,
1:5d24c78:                     slaveServerPort,
1:dbe5dc3:                     slaveDbSubPath); // Distinguishing master/slave
1:5d24c78:             /* */
1:5d24c78:           }
1:5d24c78:         }/* END */
1:5d24c78:         
1:5d24c78:         verifySlave();
1:5d24c78:         
1:5d24c78:         // We should verify the master as well, at least to see that we still can connect.
1:5d24c78:         // If the slave server was shutdown, killed or died, start a "default" server on
1:5d24c78:         // the same server and port to do the verification:
1:5d24c78:         int masterPid = xFindServerPID(masterServerHost, masterServerPort);
1:5d24c78:         if ( masterPid == -1 )
1:5d24c78:         {
1:5d24c78:             util.DEBUG("WARNING: master server not available. Starting.");
1:136610d:             startServer(jvmVersion, derbyVersion,
1:5d24c78:                     masterServerHost,
1:5d24c78:                     ALL_INTERFACES, // masterServerHost, // "0.0.0.0", // All. or use slaveServerHost for interfacesToListenOn,
1:5d24c78:                     masterServerPort,
1:dbe5dc3:                     masterDbSubPath); // Distinguishing master/slave
1:5d24c78:         }
1:5d24c78:         verifyMaster(); // NB NB Hangs here with localhost/ReplicationTestRun!
1:5d24c78:         
1:5d24c78:         xFindServerPID(slaveServerHost, slaveServerPort); // JUST DEBUGGING!
1:5d24c78:         
1:5d24c78:         // Thread.sleep(5000L); // Just for testing....
1:5d24c78:         stopServer(jvmVersion, derbyVersion,
1:5d24c78:                 slaveServerHost, slaveServerPort);
1:5d24c78:         ///////////////////////////////////////////////////////
1:5d24c78:         // State: PostStartedMasterServer, PostStartedSlaveServer
1:5d24c78:         //        PostStartedMaster,       PostStartedSlave
1:5d24c78:         //        PostStoppedMaster,       PostStoppedSlave
1:5d24c78:         //        PostStoppedMasterServer, PostStoppedSlaveServer,  PostFailover
1:5d24c78:         
1:5d24c78:             if (state.testPostStoppedSlaveServer()) return;
1:5d24c78:         
1:5d24c78:         // Shutdown master:
1:5d24c78:         stopServer(jvmVersion, derbyVersion,
1:5d24c78:                 masterServerHost, masterServerPort);
1:5d24c78:         // As of 2008-02-06 master does not accept shutdown after replication, so:
1:5d24c78:         masterPid = xFindServerPID(masterServerHost, masterServerPort);
1:5d24c78:         if ( masterPid != -1 )
1:5d24c78:         {
1:5d24c78:         util.DEBUG("*********************** DERBY-3394. master does not accept shutdown after failover.");
1:5d24c78:         killMaster(masterServerHost,masterServerPort);
1:5d24c78:         }
1:5d24c78:         
1:5d24c78:     }
1:5d24c78: 
1:5d24c78: 
1:5d24c78:     
1:5d24c78: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.BaseTestSuite;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite("Replication_Full Suite");
commit:9c2b1f3
/////////////////////////////////////////////////////////////////////////
1: Derby - Class org.apache.derbyTesting.functionTests.tests.replicationTests.ReplicationRun_Full
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:136610d
/////////////////////////////////////////////////////////////////////////
1:         startServer(masterJvmVersion, derbyMasterVersion,
/////////////////////////////////////////////////////////////////////////
1:         startServer(slaveJvmVersion, derbySlaveVersion,
/////////////////////////////////////////////////////////////////////////
1:             startServer(jvmVersion, derbyVersion,
/////////////////////////////////////////////////////////////////////////
1:             startServer(jvmVersion, derbyVersion,
author:Oystein Grovlen
-------------------------------------------------------------------------------
commit:dbe5dc3
/////////////////////////////////////////////////////////////////////////
1:                     masterDbSubPath); // Distinguishing master/slave
/////////////////////////////////////////////////////////////////////////
1:                 masterDbSubPath); // Distinguishing master/slave
/////////////////////////////////////////////////////////////////////////
1:                 slaveDbSubPath); // Distinguishing master/slave
/////////////////////////////////////////////////////////////////////////
1:                     slaveDbSubPath); // Distinguishing master/slave
/////////////////////////////////////////////////////////////////////////
1:                     slaveDbSubPath); // Distinguishing master/slave
/////////////////////////////////////////////////////////////////////////
1:                     masterDbSubPath); // Distinguishing master/slave
commit:40a554b
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.SecurityManagerSetup;
/////////////////////////////////////////////////////////////////////////
1:         return SecurityManagerSetup.noSecurityManager(suite);
commit:5d24c78
/////////////////////////////////////////////////////////////////////////
1: /*
1:  
0: Derby - Class org.apache.derbyTesting.functionTests.tests.replicationTests.ReplicationRun
1:  
1: Licensed to the Apache Software Foundation (ASF) under one or more
1: contributor license agreements.  See the NOTICE file distributed with
1: this work for additional information regarding copyright ownership.
1: The ASF licenses this file to You under the Apache License, Version 2.0
1: (the "License"); you may not use this file except in compliance with
1: the License.  You may obtain a copy of the License at
1:  
1:    http://www.apache.org/licenses/LICENSE-2.0
1:  
1: Unless required by applicable law or agreed to in writing, software
1: distributed under the License is distributed on an "AS IS" BASIS,
1: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1: See the License for the specific language governing permissions and
1: limitations under the License.
1:  
1:  */
1: package org.apache.derbyTesting.functionTests.tests.replicationTests;
1: 
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: 
1: public class ReplicationRun_Full extends ReplicationRun
1: {
1:     
1:     public ReplicationRun_Full(String testcaseName)
1:     {
1:         super(testcaseName);
1:         
1:         LF = System.getProperties().getProperty("line.separator");
1:     }
1:         
1:     public static Test suite()
1:     {
1:         
0:         TestSuite suite = new TestSuite("Replication_Full Suite");
1:         
1:         suite.addTestSuite( ReplicationRun_Full.class );
1:         
0:         return suite;
1:     }
1:     
1:     //////////////////////////////////////////////////////////////
1:     ////
1:     //// The replication test framework (testReplication()):
1:     //// a) "clean" replication run starting master and slave servers,
1:     ////     preparing master and slave databases,
1:     ////     starting and stopping replication and doing
1:     ////     failover for a "normal"/"failure free" replication
1:     ////     test run.
1:     //// b)  Running (positive and negative) tests at the various states 
1:     ////     of replication to test what is and is not accepted compared to
1:     ////     the functional specification.
1:     //// c)  Adding additional load on master and slave servers in 
1:     ////     different states of replication.
1:     ////
1:     //////////////////////////////////////////////////////////////
1:     
1:     public void testReplication()
1:     throws Exception
1:     {
1:         cleanAllTestHosts();
1:         
1:         initEnvironment();
1:         
1:         /* 'testReplication' steps through all states of the
1:          * replication process.
1:          * Tests required to be run in these states
1:          * should be specified in the replicationtest.properties file.
1:          */
1:         if ( runUnReplicated )  // test.runUnReplicated
1:         {
1:             util.DEBUG("**** BEGIN Running test without replication.");
1:             initMaster(masterServerHost,
1:                     replicatedDb);
1:             startServer(masterJvmVersion, derbyVersion, // No replication
1:                     masterServerHost,
1:                     ALL_INTERFACES, // masterServerHost, // "0.0.0.0", // All. or use masterServerHost for interfacesToListenOn,
1:                     masterServerPort,
0:                     masterDatabasePath +FS+ masterDbSubPath); // Distinguishing master/slave
1:             runTest(replicationTest,
1:                     jvmVersion,
1:                     testClientHost,
1:                     masterServerHost, masterServerPort,
1:                     replicatedDb);
1:             stopServer(masterJvmVersion, derbyMasterVersion,
1:                     masterServerHost, masterServerPort);
1:             util.DEBUG("**** END Running test without replication.");
1:             // util.sleep(5000L, "End of runUnReplicated"); // Just for testing....
1:         }
1:         
1:         ///////////////////////////////////////////////////////
1:         // State: PreStartedMasterServer, PreStartedSlaveServer
1:             if (state.testPreStartedMasterServer()) return;
1:                 
1:         initMaster(masterServerHost,
1:                 replicatedDb); // Prototype V2: copy orig (possibly empty) db to db_master.
1:         
0:         masterServer = startServer(masterJvmVersion, derbyMasterVersion,
1:                 masterServerHost,
1:                 ALL_INTERFACES, // masterServerHost, // "0.0.0.0", // All. or use masterServerHost for interfacesToListenOn,
1:                 masterServerPort,
0:                 masterDatabasePath +FS+ masterDbSubPath); // Distinguishing master/slave
1:         ///////////////////////////////////////////////////////
1:         // State: PostStartedMasterServer, PreStartedSlaveServer
1:         
1:         startOptionalLoad(masterPreRepl,
1:                 masterDbSubPath,
1:                 masterServerHost,
1:                 masterServerPort);
1:         
1:             if (state.testPreStartedSlaveServer()) return; // + stop master server!
1:         
1:         // Thread.sleep(5000L); // Just for testing....
0:         slaveServer = startServer(slaveJvmVersion, derbySlaveVersion,
1:                 slaveServerHost,
1:                 ALL_INTERFACES, // slaveServerHost, // "0.0.0.0", // All. or use slaveServerHost for interfacesToListenOn,
1:                 slaveServerPort,
0:                 slaveDatabasePath +FS+ slaveDbSubPath); // Distinguishing master/slave
1:         ///////////////////////////////////////////////////////
1:         // State: PostStartedMasterServer, PostStartedSlaveServer
1:         //        PreStartedMaster,        PreStartedSlave
1:         
1:         // Thread.sleep(15000L); // Just for testing....
1:         startServerMonitor(slaveServerHost);
1:         
1:         xFindServerPID(slaveServerHost, slaveServerPort); // JUST DEBUGGING!
1:         
1:         bootMasterDatabase(jvmVersion,
1:                 masterDatabasePath +FS+ masterDbSubPath,
1:                 replicatedDb,
1:                 masterServerHost, // Where the startreplication command must be given
1:                 masterServerPort, // master server interface accepting client requests
1:                 null // bootLoad, // The "test" to start when booting db.
1:                 );
1:         
1:         ///////////////////////////////////////////////////////
1:         // State: PostStartedMasterServer, PostStartedSlaveServer
1:         //        PostStartedMaster,       PreStartedSlave
1:         
1:         startOptionalLoad(masterPostRepl,
1:                 masterDbSubPath,
1:                 masterServerHost,
1:                 masterServerPort);
1:         
1:         startOptionalLoad(slavePreSlave,
1:                 slaveDbSubPath,
1:                 slaveServerHost,
1:                 slaveServerPort);
1:         
1:         // util.sleep(sleepTime, "Before initSlave"); // A. 'Something wrong with the instants!' if removed!
1:         // 5secs is too little! 15secs is too little sometimes...!
1:         // 30secs is too little w/ShutdownSlave!
1:         
1:         
1:             if (state.testPreInitSlave()) return;
1: 
1:         initSlave(/*slaveHost*/ slaveServerHost,
1:                 jvmVersion,
1:                 replicatedDb); // Trunk and Prototype V2: copy master db to db_slave.
1:         
1: 
1:             if (state.testPreStartedSlave()) return;
1:                 
1:          startSlave(jvmVersion, replicatedDb,
1:                 slaveServerHost, // slaveClientInterface // where the slave db runs
1:                 slaveServerPort,
1:                 slaveServerHost, // for slaveReplInterface
1:                 slaveReplPort,
1:                 testClientHost);
1: 
1:             if (state.testPreStartedMaster()) return;
1:         
1:        startMaster(jvmVersion, replicatedDb,
1:                 masterServerHost, // Where the startMaster command must be given
1:                 masterServerPort, // master server interface accepting client requests
1:                 masterServerHost, // An interface on the master: masterClientInterface (==masterServerHost),
1:                 slaveServerPort, // Not used since slave don't allow clients.
1:                 slaveServerHost, // for slaveReplInterface
1:                 slaveReplPort);
1:         
1:         ///////////////////////////////////////////////////////
1:         // State: PostStartedMasterServer, PostStartedSlaveServer
1:         //        PostStartedMaster,       PostStartedSlave
1:         
1:         startOptionalLoad(masterPostSlave,
1:                 masterDbSubPath,
1:                 masterServerHost,
1:                 masterServerPort);
1:         
1:         startOptionalLoad(slavePostSlave,
1:                 slaveDbSubPath,
1:                 slaveServerHost,
1:                 slaveServerPort);
1:         
1:         // Thread.sleep(5000L); // Just for testing....
1:         // util.sleep(10000L, "Before runTest"); // Perf. testing....
1:         
1:             if (state.testPostStartedMasterAndSlave()) return;
1:             // Could be run concurrently with runTest below?
1:         
1:         // Used to run positive tests? Handle negative testing in State.testPostStartedMasterAndSlave()?
1:         // Observe that it will not be meaningful to do runTest if State.XXXX() 
1:         // has led to incorrect replication state wrt. replicationTest.
1:         runTest(replicationTest, // Returns immediatly if replicationTest is null.
1:                 jvmVersion,
1:                 testClientHost,
1:                 masterServerHost, masterServerPort,
1:                 replicatedDb);
1:         
1:         ///////////////////////////////////////////////////////
1:         // State: PostStartedMasterServer, PostStartedSlaveServer
1:         //        PostStartedMaster,       PostStartedSlave
1:         //        PreStoppedMaster,        PreStoppedSlave
1:             if (state.testPreStoppedMaster()) return;
1:         
1: // PoC        stopMaster(replicatedDb); // v7: RENAMED! FIXME! when 'stopMaster' cmd. available! // master..
1: /*         stopMaster_ij(jvmVersion, replicatedDb,
1:                 masterServerHost,
1:                 masterServerPort,
1:                 testClientHost);
1:  */
1:         ///////////////////////////////////////////////////////
1:         // State: PostStartedMasterServer, PostStartedSlaveServer
1:         //        PostStartedMaster,       PostStartedSlave
1:         //        PostStoppedMaster,       PreStoppedSlave,       PreFailover
1:         
1:         // Thread.sleep(5000L); // Just for testing....
1:         
1:             if (state.testPreStoppedMasterServer()) return;
1:         
1: /* PoC        stopServer(masterJvmVersion, derbyMasterVersion, // v7: NA // PoC V2b: forces failover on slave
1:                 masterServerHost, masterServerPort);
1:  */
1:         ///////////////////////////////////////////////////////
1:         // State: PostStartedMasterServer, PostStartedSlaveServer
1:         //        PostStartedMaster,       PostStartedSlave
1:         //        PostStoppedMaster,       PreStoppedSlave
1:         //        PostStoppedMasterServer, PreStoppedSlaveServer,  PoC:  PostFailover
1:             if (state.testPreStoppedSlave()) return;
1:         
1:         // Thread.sleep(5000L); // Just for testing....
1: // PoC        stopSlave(replicatedDb); // v7: NEW! FIXME! when 'stopSlave' cmd. available!
1: /*         stopSlave_ij(jvmVersion, replicatedDb,
1:                 slaveServerHost,
1:                 slaveServerPort,
1:                 testClientHost);
1:  */
1:         ///////////////////////////////////////////////////////
1:         // State: PostStartedMasterServer, PostStartedSlaveServer
1:         //        PostStartedMaster,       PostStartedSlave
1:         //        PostStoppedMaster,       PostStoppedSlave
1:         //        PostStoppedMasterServer, PreStoppedSlaveServer,  PreFailover // PoC:  PostFailover
1:         
1:         // Thread.sleep(5000L); // Just for testing....
1:         failOver(jvmVersion, // On master, which is the normal case.
1:             masterDatabasePath, masterDbSubPath, replicatedDb,
1:             masterServerHost,  // Where the master db is run.
1:             masterServerPort,
1:             testClientHost);
1: 
1: // PoC        failOver(replicatedDb); // FIXME! when 'failOver' cmd. available!
1: 
1:         ///////////////////////////////////////////////////////
1:         // State: PostStartedMasterServer, PostStartedSlaveServer
1:         //        PostStartedMaster,       PostStartedSlave
1:         //        PostStoppedMaster,       PostStoppedSlave
1:         //        PostStoppedMasterServer, PreStoppedSlaveServer,  PostFailover
1:         
1:         // util.sleep(10000L, "After failover"); // Try to avoid DERBY-3463....
1:         connectPing(slaveDatabasePath+FS+slaveDbSubPath+FS+replicatedDb,
1:                 slaveServerHost,slaveServerPort,
1:                 testClientHost);
1:         
1:         // If the slave server was shutdown, killed or died, start a "default" server on
1:         // the same server and port to do the verification:
1:         int slavePid = xFindServerPID(slaveServerHost, slaveServerPort);
1:         if ( slavePid == -1 )
1:         {
1:             util.DEBUG("WARNING: slave server not available. Starting.");
0:             slaveServer = startServer(jvmVersion, derbyVersion,
1:                     slaveServerHost,
1:                     ALL_INTERFACES, // slaveServerHost, // "0.0.0.0", // All. or use slaveServerHost for interfacesToListenOn,
1:                     slaveServerPort,
0:                     slaveDatabasePath +FS+ slaveDbSubPath); // Distinguishing master/slave
1:         }
1:         /* BEGIN Failover do not yet clean replication mode on slave! Must restart the server!*/
1:         else{
1:           if (true)
1:           {
1:             util.DEBUG("*********************** DERBY-3205/svn 630806. failover does now unset replication mode on slave.");
1:           }
1:           else // failover does not unset replication mode on slave.
1:           {
1:             util.DEBUG("*********************** DERBY-3205. failover does not unset replication mode on slave.");
1:             /* That also blocks for connecting!:
1:             // Do slave db shutdown (and reconnect) to unset... PRELIMINARY!!!
1:             shutdownDb(slaveServerHost,slaveServerPort,
1:                     slaveDatabasePath +FS+ slaveDbSubPath,replicatedDb);
1:              */
1:             /* */
1:             restartServer(jvmVersion, derbyVersion, // restart server is too strong!
1:                     slaveServerHost,
1:                     ALL_INTERFACES,
1:                     slaveServerPort,
0:                     slaveDatabasePath +FS+ slaveDbSubPath); // Distinguishing master/slave
1:             /* */
1:           }
1:         }/* END */
1:         
1:         verifySlave();
1:         
1:         // We should verify the master as well, at least to see that we still can connect.
1:         // If the slave server was shutdown, killed or died, start a "default" server on
1:         // the same server and port to do the verification:
1:         int masterPid = xFindServerPID(masterServerHost, masterServerPort);
1:         if ( masterPid == -1 )
1:         {
1:             util.DEBUG("WARNING: master server not available. Starting.");
0:             masterServer = startServer(jvmVersion, derbyVersion,
1:                     masterServerHost,
1:                     ALL_INTERFACES, // masterServerHost, // "0.0.0.0", // All. or use slaveServerHost for interfacesToListenOn,
1:                     masterServerPort,
0:                     masterDatabasePath +FS+ masterDbSubPath); // Distinguishing master/slave
1:         }
1:         verifyMaster(); // NB NB Hangs here with localhost/ReplicationTestRun!
1:         
1:         xFindServerPID(slaveServerHost, slaveServerPort); // JUST DEBUGGING!
1:         
1:         // Thread.sleep(5000L); // Just for testing....
1:         stopServer(jvmVersion, derbyVersion,
1:                 slaveServerHost, slaveServerPort);
1:         ///////////////////////////////////////////////////////
1:         // State: PostStartedMasterServer, PostStartedSlaveServer
1:         //        PostStartedMaster,       PostStartedSlave
1:         //        PostStoppedMaster,       PostStoppedSlave
1:         //        PostStoppedMasterServer, PostStoppedSlaveServer,  PostFailover
1:         
1:             if (state.testPostStoppedSlaveServer()) return;
1:         
1:         // Shutdown master:
1:         stopServer(jvmVersion, derbyVersion,
1:                 masterServerHost, masterServerPort);
1:         // As of 2008-02-06 master does not accept shutdown after replication, so:
1:         masterPid = xFindServerPID(masterServerHost, masterServerPort);
1:         if ( masterPid != -1 )
1:         {
1:         util.DEBUG("*********************** DERBY-3394. master does not accept shutdown after failover.");
1:         killMaster(masterServerHost,masterServerPort);
1:         }
1:         
1:     }
1: 
1: 
1:     
1: }
============================================================================