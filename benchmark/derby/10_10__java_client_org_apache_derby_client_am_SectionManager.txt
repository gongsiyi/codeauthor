1:33776ff: /*
13:33776ff: 
1:33776ff:    Derby - Class org.apache.derby.client.am.SectionManager
1:33776ff: 
1:59bf37d:    Licensed to the Apache Software Foundation (ASF) under one or more
1:59bf37d:    contributor license agreements.  See the NOTICE file distributed with
1:59bf37d:    this work for additional information regarding copyright ownership.
1:59bf37d:    The ASF licenses this file to You under the Apache License, Version 2.0
1:59bf37d:    (the "License"); you may not use this file except in compliance with
1:59bf37d:    the License.  You may obtain a copy of the License at
1:33776ff: 
1:33776ff:       http://www.apache.org/licenses/LICENSE-2.0
1:33776ff: 
1:33776ff:    Unless required by applicable law or agreed to in writing, software
1:33776ff:    distributed under the License is distributed on an "AS IS" BASIS,
1:33776ff:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:33776ff:    See the License for the specific language governing permissions and
1:33776ff:    limitations under the License.
1:33776ff: 
2:33776ff: */
1:33776ff: 
1:33776ff: package org.apache.derby.client.am;
1:f86608b: 
1:3abb572: import java.lang.ref.WeakReference;
1:69e3d06: import java.sql.ResultSet;
1:4772c7e: import java.util.Hashtable;
1:4772c7e: import java.util.Stack;
1:5d2e2bd: import org.apache.derby.shared.common.reference.SQLState;
1:3abb572: 
1:5d2e2bd: 
1:70f7692: public class SectionManager {
1:0326967:     private Agent agent_;
1:33776ff: 
1:70f7692:     // The following stack of available sections is
1:70f7692:     // for pooling and recycling previously used sections.
1:70f7692:     // For performance, the section objects themselves are pooled,
1:70f7692:     // rather than just keeping track of free section numbers;
1:70f7692:     // this way, we don't have to new-up a section if one is available in the pool.
1:4772c7e:     private final Stack<Section> freeSectionsNonHold_;
1:4772c7e:     private final Stack<Section> freeSectionsHold_;
1:33776ff: 
1:0326967:     private int nextAvailableSectionNumber_ = 1;
1:33776ff: 
1:70f7692:     // store package consistency token information and initialized in
1:70f7692:     // setPKGNAMCBytes
1:70f7692:     // holdPKGNAMCBytes stores PKGNAMCBytes when holdability is hold
1:70f7692:     // noHoldPKGNAMCBytes stores PKGNAMCBytes when holdability is no hold
1:0326967:     byte[] holdPKGNAMCBytes = null;
1:0326967:     byte[] noHoldPKGNAMCBytes = null;
1:33776ff: 
1:33776ff: 
1:0326967:     private final static String packageNameWithHold__ = "SYSLH000";
1:0326967:     private final static String packageNameWithNoHold__ = "SYSLN000";
1:33776ff: 
1:0326967:     private final static String cursorNamePrefixWithHold__ = "SQL_CURLH000C";
1:0326967:     private final static String cursorNamePrefixWithNoHold__ = "SQL_CURLN000C";
1:33776ff: 
1:70f7692:     // Jdbc 1 positioned updates are implemented via
1:70f7692:     // sql scan for "...where current of <users-cursor-name>",
1:70f7692:     // the addition of mappings from cursor names to query sections,
1:70f7692:     // and the subtitution of <users-cursor-name> with <canned-cursor-name> in the pass-thru sql string
1:70f7692:     // "...where current of <canned-cursor-name>" when user-defined cursor names are used.
1:70f7692:     // Both "canned" cursor names (from our jdbc package set) and user-defined cursor names are mapped.
1:70f7692:     // Statement.cursorName_ is initialized to null until the cursor name is requested or set.
1:70f7692:     // When set (s.setCursorName()) with a user-defined name, then it is added to the cursor map at that time;
1:70f7692:     // When requested (rs.getCursorName()), if the cursor name is still null,
1:70f7692:     // then is given the canned cursor name as defined by our jdbc package set and added to the cursor map.
1:70f7692:     // Still need to consider how positioned updates should interact with multiple result sets from a stored.
1:4772c7e:     private final Hashtable<String, Section>
1:4772c7e:         positionedUpdateCursorNameToQuerySection_ =
1:4772c7e:             new Hashtable<String, Section>();
1:33776ff: 
1:70f7692:     // Cursor name to ResultSet mapping is needed for positioned updates to check whether
1:70f7692:     // a ResultSet is scrollable.  If so, exception is thrown.
1:69e3d06:     private final Hashtable<String, WeakReference<ClientResultSet>>
1:4772c7e:         positionedUpdateCursorNameToResultSet_ =
1:69e3d06:             new Hashtable<String, WeakReference<ClientResultSet>>();
1:33776ff: 
1:0326967:     private final int maxNumSections_ = 32768;
1:33776ff: 
1:0326967:     public SectionManager(Agent agent) {
1:70f7692:         agent_ = agent;
1:4772c7e:         freeSectionsNonHold_ = new Stack<Section>();
1:4772c7e:         freeSectionsHold_ = new Stack<Section>();
15:33776ff:     }
1:33776ff: 
1:70f7692:     /**
1:70f7692:      * Store the Packagename and consistency token information This is called from Section.setPKGNAMCBytes
1:70f7692:      *
1:70f7692:      * @param b                    bytearray that has the PKGNAMC information to be stored
1:70f7692:      * @param resultSetHoldability depending on the holdability store it in the correct byte array packagename and
1:70f7692:      *                             consistency token information for when holdability is set to HOLD_CURSORS_OVER_COMMIT
1:70f7692:      *                             is stored in holdPKGNAMCBytes and in noHoldPKGNAMCBytes when holdability is set to
1:70f7692:      *                             CLOSE_CURSORS_AT_COMMIT
1:70f7692:      */
1:0326967:     void setPKGNAMCBytes(byte[] b, int resultSetHoldability) {
1:1e8a20f:         if (resultSetHoldability == ResultSet.HOLD_CURSORS_OVER_COMMIT) {
1:70f7692:             agent_.sectionManager_.holdPKGNAMCBytes = b;
1:1e8a20f:         } else if (resultSetHoldability == ResultSet.CLOSE_CURSORS_AT_COMMIT) {
1:70f7692:             agent_.sectionManager_.noHoldPKGNAMCBytes = b;
1:70f7692:         }
1:33776ff:     }
1:33776ff: 
1:33776ff: 
1:70f7692:     //------------------------entry points----------------------------------------
1:33776ff: 
1:70f7692:     // Get a section for either a jdbc update or query statement.
1:0326967:     Section getDynamicSection(int resultSetHoldability) throws SqlException {
1:1e8a20f:         if (resultSetHoldability == ResultSet.HOLD_CURSORS_OVER_COMMIT) {
1:70f7692:             return getSection(freeSectionsHold_, packageNameWithHold__, cursorNamePrefixWithHold__, resultSetHoldability);
1:1e8a20f:         } else if (resultSetHoldability == ResultSet.CLOSE_CURSORS_AT_COMMIT) {
1:70f7692:             return getSection(freeSectionsNonHold_, packageNameWithNoHold__, cursorNamePrefixWithNoHold__, resultSetHoldability);
1:70f7692:         } else {
1:5d2e2bd:             throw new SqlException(agent_.logWriter_,
1:e65b4db:                 new ClientMessageId(SQLState.UNSUPPORTED_HOLDABILITY_PROPERTY), 
1:66527ec:                 resultSetHoldability);
1:70f7692:         }
1:70f7692:     }
1:33776ff: 
1:0326967:     private Section getSection(
1:69e3d06:             Stack freeSections,
1:69e3d06:             String packageName,
1:69e3d06:             String cursorNamePrefix,
1:69e3d06:             int resultSetHoldability) throws SqlException {
1:69e3d06: 
1:70f7692:         if (!freeSections.empty()) {
1:70f7692:             return (Section) freeSections.pop();
1:70f7692:         } else if (nextAvailableSectionNumber_ < (maxNumSections_ - 1)) {
1:70f7692:             String cursorName = cursorNamePrefix + nextAvailableSectionNumber_;
1:70f7692:             Section section = new Section(agent_, packageName, nextAvailableSectionNumber_, cursorName, resultSetHoldability);
1:70f7692:             nextAvailableSectionNumber_++;
1:70f7692:             return section;
1:70f7692:         } else
1:70f7692:         // unfortunately we have run out of sections
1:70f7692:         {
1:5d2e2bd:             throw new SqlException(agent_.logWriter_, 
1:e65b4db:                 new ClientMessageId(SQLState.EXCEEDED_MAX_SECTIONS),
1:870f7cd:                 "32000");
1:70f7692:         }
1:70f7692:     }
1:33776ff: 
1:0326967:     void freeSection(Section section, int resultSetHoldability) {
1:1e8a20f:         if (resultSetHoldability == ResultSet.HOLD_CURSORS_OVER_COMMIT) {
1:70f7692:             this.freeSectionsHold_.push(section);
1:1e8a20f:         } else if (resultSetHoldability == ResultSet.CLOSE_CURSORS_AT_COMMIT) {
1:70f7692:             this.freeSectionsNonHold_.push(section);
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:70f7692:     // Get a section for a jdbc 2 positioned update/delete for the corresponding query.
1:70f7692:     // A positioned update section must come from the same package as its query section.
1:70f7692:     Section getPositionedUpdateSection(Section querySection) throws SqlException {
1:69e3d06:         ClientConnection connection = agent_.connection_;
1:fdfc981:         return getDynamicSection(connection.holdability());
1:70f7692:     }
1:70f7692: 
1:70f7692:     // Get a section for a jdbc 1 positioned update/delete for the corresponding query.
1:70f7692:     // A positioned update section must come from the same package as its query section.
1:70f7692:     Section getPositionedUpdateSection(String cursorName, boolean useExecuteImmediateSection) throws SqlException {
1:70f7692:         Section querySection = (Section) positionedUpdateCursorNameToQuerySection_.get(cursorName);
1:70f7692: 
1:70f7692:         // If querySection is null, then the user must have provided a bad cursor name.
1:70f7692:         // Otherwise, get a new section and save the client's cursor name and the server's
1:70f7692:         // cursor name to the new section.
1:70f7692:         if (querySection != null) {
1:70f7692:             Section section = getPositionedUpdateSection(querySection);
1:70f7692:             // getPositionedUpdateSection gets the next available section from the query
1:70f7692:             // package, and it has a different cursor name associated with the section.
1:70f7692:             // We need to save the client's cursor name and server's cursor name to the
1:70f7692:             // new section.
1:70f7692:             section.setClientCursorName(querySection.getClientCursorName());
1:70f7692:             section.serverCursorNameForPositionedUpdate_ = querySection.getServerCursorName();
1:70f7692:             return section;
1:70f7692:         } else {
1:70f7692:             return null;
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:70f7692:     void mapCursorNameToQuerySection(String cursorName, Section section) {
1:70f7692:         positionedUpdateCursorNameToQuerySection_.put(cursorName, section);
1:70f7692:     }
1:70f7692: 
1:69e3d06:     void mapCursorNameToResultSet(
1:69e3d06:             String cursorName,
1:69e3d06:             ClientResultSet resultSet) {
1:69e3d06: 
1:3abb572:         // DERBY-3316. Needs WeakReference so that ResultSet can be garbage collected
1:4772c7e:         positionedUpdateCursorNameToResultSet_.put(
1:69e3d06:                 cursorName, new WeakReference<ClientResultSet>(resultSet));
1:70f7692:     }
1:70f7692: 
1:69e3d06:     ClientResultSet getPositionedUpdateResultSet(String cursorName)
1:69e3d06:             throws SqlException {
1:69e3d06:         ClientResultSet rs =
1:69e3d06:             positionedUpdateCursorNameToResultSet_.get(cursorName).get();
1:70f7692:         if (rs == null) {
1:5d2e2bd:             throw new SqlException(agent_.logWriter_, 
1:80e5ab8:                 new ClientMessageId(SQLState.LANG_RESULT_SET_NOT_OPEN), "update");
1:70f7692:         }
1:69e3d06:         return (rs.resultSetType_ == ResultSet.TYPE_FORWARD_ONLY) ? null : rs;
1:70f7692:     }
1:70f7692: 
1:70f7692:     void removeCursorNameToResultSetMapping(String clientCursorName,
1:70f7692:                                             String serverCursorName) {
1:70f7692:         if (clientCursorName != null) {
1:70f7692:             positionedUpdateCursorNameToResultSet_.remove(clientCursorName);
1:70f7692:         }
1:70f7692:         if (serverCursorName != null) {
1:70f7692:             positionedUpdateCursorNameToResultSet_.remove(serverCursorName);
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:70f7692:     void removeCursorNameToQuerySectionMapping(String clientCursorName,
1:70f7692:                                                String serverCursorName) {
1:70f7692:         if (clientCursorName != null) {
1:70f7692:             positionedUpdateCursorNameToQuerySection_.remove(clientCursorName);
1:70f7692:         }
1:70f7692:         if (serverCursorName != null) {
1:70f7692:             positionedUpdateCursorNameToQuerySection_.remove(serverCursorName);
1:70f7692:         }
1:70f7692:     }
1:33776ff: 
1:33776ff: }
1:33776ff: 
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:0326967
/////////////////////////////////////////////////////////////////////////
1:     private Agent agent_;
/////////////////////////////////////////////////////////////////////////
1:     private int nextAvailableSectionNumber_ = 1;
1:     byte[] holdPKGNAMCBytes = null;
1:     byte[] noHoldPKGNAMCBytes = null;
1:     private final static String packageNameWithHold__ = "SYSLH000";
1:     private final static String packageNameWithNoHold__ = "SYSLN000";
1:     private final static String cursorNamePrefixWithHold__ = "SQL_CURLH000C";
1:     private final static String cursorNamePrefixWithNoHold__ = "SQL_CURLN000C";
/////////////////////////////////////////////////////////////////////////
1:     private final int maxNumSections_ = 32768;
1:     public SectionManager(Agent agent) {
/////////////////////////////////////////////////////////////////////////
1:     void setPKGNAMCBytes(byte[] b, int resultSetHoldability) {
/////////////////////////////////////////////////////////////////////////
1:     Section getDynamicSection(int resultSetHoldability) throws SqlException {
/////////////////////////////////////////////////////////////////////////
1:     private Section getSection(
/////////////////////////////////////////////////////////////////////////
1:     void freeSection(Section section, int resultSetHoldability) {
commit:69e3d06
/////////////////////////////////////////////////////////////////////////
1: import java.sql.ResultSet;
/////////////////////////////////////////////////////////////////////////
1:     private final Hashtable<String, WeakReference<ClientResultSet>>
1:             new Hashtable<String, WeakReference<ClientResultSet>>();
/////////////////////////////////////////////////////////////////////////
0:     protected Section getSection(
1:             Stack freeSections,
1:             String packageName,
1:             String cursorNamePrefix,
1:             int resultSetHoldability) throws SqlException {
1: 
/////////////////////////////////////////////////////////////////////////
1:         ClientConnection connection = agent_.connection_;
/////////////////////////////////////////////////////////////////////////
1:     void mapCursorNameToResultSet(
1:             String cursorName,
1:             ClientResultSet resultSet) {
1: 
1:                 cursorName, new WeakReference<ClientResultSet>(resultSet));
1:     ClientResultSet getPositionedUpdateResultSet(String cursorName)
1:             throws SqlException {
1:         ClientResultSet rs =
1:             positionedUpdateCursorNameToResultSet_.get(cursorName).get();
1:         return (rs.resultSetType_ == ResultSet.TYPE_FORWARD_ONLY) ? null : rs;
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:870f7cd
/////////////////////////////////////////////////////////////////////////
1:                 "32000");
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:66527ec
/////////////////////////////////////////////////////////////////////////
1:                 resultSetHoldability);
commit:4772c7e
/////////////////////////////////////////////////////////////////////////
1: import java.util.Hashtable;
1: import java.util.Stack;
/////////////////////////////////////////////////////////////////////////
1:     private final Stack<Section> freeSectionsNonHold_;
1:     private final Stack<Section> freeSectionsHold_;
/////////////////////////////////////////////////////////////////////////
1:     private final Hashtable<String, Section>
1:         positionedUpdateCursorNameToQuerySection_ =
1:             new Hashtable<String, Section>();
0:     private final Hashtable<String, WeakReference<ResultSet>>
1:         positionedUpdateCursorNameToResultSet_ =
0:             new Hashtable<String, WeakReference<ResultSet>>();
/////////////////////////////////////////////////////////////////////////
1:         freeSectionsNonHold_ = new Stack<Section>();
1:         freeSectionsHold_ = new Stack<Section>();
/////////////////////////////////////////////////////////////////////////
1:         positionedUpdateCursorNameToResultSet_.put(
0:                 cursorName, new WeakReference<ResultSet>(resultSet));
0:         ResultSet rs = positionedUpdateCursorNameToResultSet_.get(cursorName).get();
commit:34a7cbe
/////////////////////////////////////////////////////////////////////////
0:     public byte[] holdPKGNAMCBytes = null;
0:     public byte[] noHoldPKGNAMCBytes = null;
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:80e5ab8
/////////////////////////////////////////////////////////////////////////
1:                 new ClientMessageId(SQLState.LANG_RESULT_SET_NOT_OPEN), "update");
commit:c9687fc
/////////////////////////////////////////////////////////////////////////
0:                 new ClientMessageId(SQLState.LANG_RESULT_SET_NOT_OPEN), "next");
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:1e8a20f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         if (resultSetHoldability == ResultSet.HOLD_CURSORS_OVER_COMMIT) {
1:         } else if (resultSetHoldability == ResultSet.CLOSE_CURSORS_AT_COMMIT) {
/////////////////////////////////////////////////////////////////////////
1:         if (resultSetHoldability == ResultSet.HOLD_CURSORS_OVER_COMMIT) {
1:         } else if (resultSetHoldability == ResultSet.CLOSE_CURSORS_AT_COMMIT) {
/////////////////////////////////////////////////////////////////////////
1:         if (resultSetHoldability == ResultSet.HOLD_CURSORS_OVER_COMMIT) {
1:         } else if (resultSetHoldability == ResultSet.CLOSE_CURSORS_AT_COMMIT) {
commit:fdfc981
/////////////////////////////////////////////////////////////////////////
1:         return getDynamicSection(connection.holdability());
commit:f86608b
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.shared.common.reference.JDBC30Translation;
1: 
/////////////////////////////////////////////////////////////////////////
0:         if (resultSetHoldability == JDBC30Translation.HOLD_CURSORS_OVER_COMMIT) {
0:         } else if (resultSetHoldability == JDBC30Translation.CLOSE_CURSORS_AT_COMMIT) {
/////////////////////////////////////////////////////////////////////////
0:         if (resultSetHoldability == JDBC30Translation.HOLD_CURSORS_OVER_COMMIT) {
0:         } else if (resultSetHoldability == JDBC30Translation.CLOSE_CURSORS_AT_COMMIT) {
/////////////////////////////////////////////////////////////////////////
0:         if (resultSetHoldability == JDBC30Translation.HOLD_CURSORS_OVER_COMMIT) {
0:         } else if (resultSetHoldability == JDBC30Translation.CLOSE_CURSORS_AT_COMMIT) {
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:3abb572
/////////////////////////////////////////////////////////////////////////
1: import java.lang.ref.WeakReference;
1: 
/////////////////////////////////////////////////////////////////////////
1:         // DERBY-3316. Needs WeakReference so that ResultSet can be garbage collected
0:         positionedUpdateCursorNameToResultSet_.put(cursorName, new WeakReference(resultSet));
0:         ResultSet rs = (ResultSet) ((WeakReference) (positionedUpdateCursorNameToResultSet_.get(cursorName))).get();
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:59bf37d
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:David Van Couvering
-------------------------------------------------------------------------------
commit:e65b4db
/////////////////////////////////////////////////////////////////////////
1:                 new ClientMessageId(SQLState.UNSUPPORTED_HOLDABILITY_PROPERTY), 
/////////////////////////////////////////////////////////////////////////
1:                 new ClientMessageId(SQLState.EXCEEDED_MAX_SECTIONS),
/////////////////////////////////////////////////////////////////////////
0:                 new ClientMessageId(SQLState.CLIENT_RESULT_SET_NOT_OPEN));
commit:5d2e2bd
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.reference.SQLState;
1: 
/////////////////////////////////////////////////////////////////////////
1:             throw new SqlException(agent_.logWriter_,
0:                 new MessageId(SQLState.UNSUPPORTED_HOLDABILITY_PROPERTY), 
0:                 new Integer(resultSetHoldability));
/////////////////////////////////////////////////////////////////////////
1:             throw new SqlException(agent_.logWriter_, 
0:                 new MessageId(SQLState.EXCEEDED_MAX_SECTIONS),
0:                 "32k");
/////////////////////////////////////////////////////////////////////////
1:             throw new SqlException(agent_.logWriter_, 
0:                 new MessageId(SQLState.CLIENT_RESULT_SET_NOT_OPEN));
author:Jeremy Boynes
-------------------------------------------------------------------------------
commit:70f7692
/////////////////////////////////////////////////////////////////////////
1: public class SectionManager {
0:     String collection_;
0:     Agent agent_;
0:     // Cursor holdability attributes used as package cluster indices.
0:     // Not defined in PackageBindOptions because this attribute is part of the
0:     // declare cursor [with hold] sql string based on section binds.
0:     // By convention, we bind all sections in the same package with
0:     // the same holdability.
0:     final static int HOLD = 0;
0:     final static int NO_HOLD = 1;
1:     // The following stack of available sections is
1:     // for pooling and recycling previously used sections.
1:     // For performance, the section objects themselves are pooled,
1:     // rather than just keeping track of free section numbers;
1:     // this way, we don't have to new-up a section if one is available in the pool.
0:     java.util.Stack freeSectionsNonHold_ = null;
0:     java.util.Stack freeSectionsHold_ = null;
0:     int nextAvailableSectionNumber_ = 1;
1:     // store package consistency token information and initialized in
1:     // setPKGNAMCBytes
1:     // holdPKGNAMCBytes stores PKGNAMCBytes when holdability is hold
1:     // noHoldPKGNAMCBytes stores PKGNAMCBytes when holdability is no hold
0:     public static byte[] holdPKGNAMCBytes = null;
0:     public static byte[] noHoldPKGNAMCBytes = null;
0:     final static String packageNameWithHold__ = "SYSLH000";
0:     final static String packageNameWithNoHold__ = "SYSLN000";
0:     final static String cursorNamePrefixWithHold__ = "SQL_CURLH000C";
0:     final static String cursorNamePrefixWithNoHold__ = "SQL_CURLN000C";
1:     // Jdbc 1 positioned updates are implemented via
1:     // sql scan for "...where current of <users-cursor-name>",
1:     // the addition of mappings from cursor names to query sections,
1:     // and the subtitution of <users-cursor-name> with <canned-cursor-name> in the pass-thru sql string
1:     // "...where current of <canned-cursor-name>" when user-defined cursor names are used.
1:     // Both "canned" cursor names (from our jdbc package set) and user-defined cursor names are mapped.
1:     // Statement.cursorName_ is initialized to null until the cursor name is requested or set.
1:     // When set (s.setCursorName()) with a user-defined name, then it is added to the cursor map at that time;
1:     // When requested (rs.getCursorName()), if the cursor name is still null,
1:     // then is given the canned cursor name as defined by our jdbc package set and added to the cursor map.
1:     // Still need to consider how positioned updates should interact with multiple result sets from a stored.
0:     private java.util.Hashtable positionedUpdateCursorNameToQuerySection_ = new java.util.Hashtable();
1:     // Cursor name to ResultSet mapping is needed for positioned updates to check whether
1:     // a ResultSet is scrollable.  If so, exception is thrown.
0:     private java.util.Hashtable positionedUpdateCursorNameToResultSet_ = new java.util.Hashtable();
0:     String databaseName;
0:     int maxNumSections_ = 32768;
0:     public SectionManager(String collection, Agent agent, String databaseName) {
0:         collection_ = collection;
1:         agent_ = agent;
0:         this.databaseName = databaseName;
0:         freeSectionsNonHold_ = new java.util.Stack();
0:         freeSectionsHold_ = new java.util.Stack();
1:     /**
1:      * Store the Packagename and consistency token information This is called from Section.setPKGNAMCBytes
1:      *
1:      * @param b                    bytearray that has the PKGNAMC information to be stored
1:      * @param resultSetHoldability depending on the holdability store it in the correct byte array packagename and
1:      *                             consistency token information for when holdability is set to HOLD_CURSORS_OVER_COMMIT
1:      *                             is stored in holdPKGNAMCBytes and in noHoldPKGNAMCBytes when holdability is set to
1:      *                             CLOSE_CURSORS_AT_COMMIT
1:      */
0:     public void setPKGNAMCBytes(byte[] b, int resultSetHoldability) {
0:         if (resultSetHoldability == org.apache.derby.jdbc.ClientDataSource.HOLD_CURSORS_OVER_COMMIT) {
1:             agent_.sectionManager_.holdPKGNAMCBytes = b;
0:         } else if (resultSetHoldability == org.apache.derby.jdbc.ClientDataSource.CLOSE_CURSORS_AT_COMMIT) {
1:             agent_.sectionManager_.noHoldPKGNAMCBytes = b;
1:         }
1:     //------------------------entry points----------------------------------------
1:     // Get a section for either a jdbc update or query statement.
0:     public Section getDynamicSection(int resultSetHoldability) throws SqlException {
0:         int cursorHoldIndex;
0:         if (resultSetHoldability == org.apache.derby.jdbc.ClientDataSource.HOLD_CURSORS_OVER_COMMIT) {
1:             return getSection(freeSectionsHold_, packageNameWithHold__, cursorNamePrefixWithHold__, resultSetHoldability);
0:         } else if (resultSetHoldability == org.apache.derby.jdbc.ClientDataSource.CLOSE_CURSORS_AT_COMMIT) {
1:             return getSection(freeSectionsNonHold_, packageNameWithNoHold__, cursorNamePrefixWithNoHold__, resultSetHoldability);
1:         } else {
0:             throw new SqlException(agent_.logWriter_, "resultSetHoldability property " + resultSetHoldability + " not supported");
1:         }
1:     }
0:     protected Section getSection(java.util.Stack freeSections, String packageName, String cursorNamePrefix, int resultSetHoldability) throws SqlException {
1:         if (!freeSections.empty()) {
1:             return (Section) freeSections.pop();
1:         } else if (nextAvailableSectionNumber_ < (maxNumSections_ - 1)) {
1:             String cursorName = cursorNamePrefix + nextAvailableSectionNumber_;
1:             Section section = new Section(agent_, packageName, nextAvailableSectionNumber_, cursorName, resultSetHoldability);
1:             nextAvailableSectionNumber_++;
1:             return section;
1:         } else
1:         // unfortunately we have run out of sections
1:         {
0:             throw new SqlException(agent_.logWriter_, "Run out of sections to use,sections limited to 32k currently");
1:         }
1:     }
0:     public void freeSection(Section section, int resultSetHoldability) {
0:         if (resultSetHoldability == org.apache.derby.jdbc.ClientDataSource.HOLD_CURSORS_OVER_COMMIT) {
1:             this.freeSectionsHold_.push(section);
0:         } else if (resultSetHoldability == org.apache.derby.jdbc.ClientDataSource.CLOSE_CURSORS_AT_COMMIT) {
1:             this.freeSectionsNonHold_.push(section);
1:         }
1:     }
1: 
1:     // Get a section for a jdbc 2 positioned update/delete for the corresponding query.
1:     // A positioned update section must come from the same package as its query section.
1:     Section getPositionedUpdateSection(Section querySection) throws SqlException {
0:         Connection connection = agent_.connection_;
0:         return getDynamicSection(connection.resultSetHoldability_);
1:     }
1: 
1:     // Get a section for a jdbc 1 positioned update/delete for the corresponding query.
1:     // A positioned update section must come from the same package as its query section.
1:     Section getPositionedUpdateSection(String cursorName, boolean useExecuteImmediateSection) throws SqlException {
1:         Section querySection = (Section) positionedUpdateCursorNameToQuerySection_.get(cursorName);
1: 
1:         // If querySection is null, then the user must have provided a bad cursor name.
1:         // Otherwise, get a new section and save the client's cursor name and the server's
1:         // cursor name to the new section.
1:         if (querySection != null) {
1:             Section section = getPositionedUpdateSection(querySection);
1:             // getPositionedUpdateSection gets the next available section from the query
1:             // package, and it has a different cursor name associated with the section.
1:             // We need to save the client's cursor name and server's cursor name to the
1:             // new section.
1:             section.setClientCursorName(querySection.getClientCursorName());
1:             section.serverCursorNameForPositionedUpdate_ = querySection.getServerCursorName();
1:             return section;
1:         } else {
1:             return null;
1:         }
1:     }
1: 
1:     void mapCursorNameToQuerySection(String cursorName, Section section) {
1:         positionedUpdateCursorNameToQuerySection_.put(cursorName, section);
1:     }
1: 
0:     void mapCursorNameToResultSet(String cursorName, ResultSet resultSet) {
0:         positionedUpdateCursorNameToResultSet_.put(cursorName, resultSet);
1:     }
1: 
0:     ResultSet getPositionedUpdateResultSet(String cursorName) throws SqlException {
0:         ResultSet rs = (ResultSet) positionedUpdateCursorNameToResultSet_.get(cursorName);
1:         if (rs == null) {
0:             throw new SqlException(agent_.logWriter_, "ResultSet for cursor " +
0:                     cursorName + " is closed.");
1:         }
0:         return (rs.resultSetType_ == java.sql.ResultSet.TYPE_FORWARD_ONLY) ? null : rs;
1:     }
1: 
1:     void removeCursorNameToResultSetMapping(String clientCursorName,
1:                                             String serverCursorName) {
1:         if (clientCursorName != null) {
1:             positionedUpdateCursorNameToResultSet_.remove(clientCursorName);
1:         }
1:         if (serverCursorName != null) {
1:             positionedUpdateCursorNameToResultSet_.remove(serverCursorName);
1:         }
1:     }
1: 
1:     void removeCursorNameToQuerySectionMapping(String clientCursorName,
1:                                                String serverCursorName) {
1:         if (clientCursorName != null) {
1:             positionedUpdateCursorNameToQuerySection_.remove(clientCursorName);
1:         }
1:         if (serverCursorName != null) {
1:             positionedUpdateCursorNameToQuerySection_.remove(serverCursorName);
1:         }
1:     }
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:33776ff
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derby.client.am.SectionManager
1: 
0:    Copyright (c) 2001, 2005 The Apache Software Foundation or its licensors, where applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1: */
1: 
1: package org.apache.derby.client.am;
1: 
1: 
0: public class SectionManager
0: {
0:   String collection_;
0:   Agent agent_;
1: 
0:   // Cursor holdability attributes used as package cluster indices.
0:   // Not defined in PackageBindOptions because this attribute is part of the
0:   // declare cursor [with hold] sql string based on section binds.
0:   // By convention, we bind all sections in the same package with
0:   // the same holdability.
0:   final static int HOLD = 0;
0:   final static int NO_HOLD = 1;
1: 
0:   // The following stack of available sections is
0:   // for pooling and recycling previously used sections.
0:   // For performance, the section objects themselves are pooled,
0:   // rather than just keeping track of free section numbers;
0:   // this way, we don't have to new-up a section if one is available in the pool.
0:   java.util.Stack freeSectionsNonHold_ = null;
0:   java.util.Stack freeSectionsHold_ = null;
1: 
0:   int nextAvailableSectionNumber_ = 1;
1: 
0:   // store package consistency token information and initialized in
0:   // setPKGNAMCBytes 
0:   // holdPKGNAMCBytes stores PKGNAMCBytes when holdability is hold
0:   // noHoldPKGNAMCBytes stores PKGNAMCBytes when holdability is no hold
0:   public  static byte[] holdPKGNAMCBytes = null;
0:   public  static byte[] noHoldPKGNAMCBytes = null;
1: 
1: 
0:   final static String packageNameWithHold__ = "SYSLH000";
0:   final static String packageNameWithNoHold__ = "SYSLN000";
1: 
0:   final static String cursorNamePrefixWithHold__ = "SQL_CURLH000C";
0:   final static String cursorNamePrefixWithNoHold__ = "SQL_CURLN000C";
1: 
0:   // Jdbc 1 positioned updates are implemented via
0:   // sql scan for "...where current of <users-cursor-name>",
0:   // the addition of mappings from cursor names to query sections,
0:   // and the subtitution of <users-cursor-name> with <canned-cursor-name> in the pass-thru sql string
0:   // "...where current of <canned-cursor-name>" when user-defined cursor names are used.
0:   // Both "canned" cursor names (from our jdbc package set) and user-defined cursor names are mapped.
0:   // Statement.cursorName_ is initialized to null until the cursor name is requested or set.
0:   // When set (s.setCursorName()) with a user-defined name, then it is added to the cursor map at that time;
0:   // When requested (rs.getCursorName()), if the cursor name is still null,
0:   // then is given the canned cursor name as defined by our jdbc package set and added to the cursor map.
0:   // Still need to consider how positioned updates should interact with multiple result sets from a stored.
0:   private java.util.Hashtable positionedUpdateCursorNameToQuerySection_ = new java.util.Hashtable();
1: 
0:   // Cursor name to ResultSet mapping is needed for positioned updates to check whether
0:   // a ResultSet is scrollable.  If so, exception is thrown.
0:   private java.util.Hashtable positionedUpdateCursorNameToResultSet_ = new java.util.Hashtable();
1: 
0:   String databaseName;
1: 
0:   int maxNumSections_ = 32768;
1: 
0:   public SectionManager (String collection, Agent agent, String databaseName)
0:   {
0:     collection_ = collection;
0:     agent_ = agent;
0:     this.databaseName = databaseName;
0:     freeSectionsNonHold_ = new java.util.Stack();
0:     freeSectionsHold_ = new java.util.Stack();
1:   }
1: 
0:   /**
0:    *  Store the Packagename and consistency token information 
0:    *  This is called from Section.setPKGNAMCBytes
0:    *  @param b	bytearray that has the PKGNAMC information to be stored
0:    *  @param resultSetHoldability depending on the holdability store it in the correct 
0:    * 				  byte array
0:    *  packagename and consistency token information for 
0:    *  when holdability is set to HOLD_CURSORS_OVER_COMMIT is stored in holdPKGNAMCBytes
0:    *  and in noHoldPKGNAMCBytes when holdability is set to CLOSE_CURSORS_AT_COMMIT  
0:    *
1:    */
0:   public void setPKGNAMCBytes(byte[] b, int resultSetHoldability)
0:   {
0:     if(resultSetHoldability == org.apache.derby.jdbc.ClientDataSource.HOLD_CURSORS_OVER_COMMIT)
0:         agent_.sectionManager_.holdPKGNAMCBytes = b;
0:     else if (resultSetHoldability == org.apache.derby.jdbc.ClientDataSource.CLOSE_CURSORS_AT_COMMIT)
0: 	agent_.sectionManager_.noHoldPKGNAMCBytes = b;
1:   }
1: 
1: 
0:   //------------------------entry points----------------------------------------
1: 
0:   // Get a section for either a jdbc update or query statement.
0:   public Section getDynamicSection (
0: 			         int resultSetHoldability) throws SqlException
0:   {
0:     int cursorHoldIndex;
0:     if (resultSetHoldability == org.apache.derby.jdbc.ClientDataSource.HOLD_CURSORS_OVER_COMMIT) {
0:       return getSection (freeSectionsHold_, packageNameWithHold__, cursorNamePrefixWithHold__, resultSetHoldability);
1:     }
0:     else if (resultSetHoldability == org.apache.derby.jdbc.ClientDataSource.CLOSE_CURSORS_AT_COMMIT)
0:       return getSection (freeSectionsNonHold_, packageNameWithNoHold__, cursorNamePrefixWithNoHold__, resultSetHoldability);
0:     else
0:       throw new SqlException (agent_.logWriter_, "resultSetHoldability property " + resultSetHoldability + " not supported");
1:   }
1: 
0:   protected Section getSection(java.util.Stack freeSections, String packageName, String cursorNamePrefix, int resultSetHoldability) throws SqlException
0:  {
0:    if (!freeSections.empty()) {
0:      return (Section)freeSections.pop();
1:    }
0:    else if (nextAvailableSectionNumber_ < (maxNumSections_-1))  {
0:      String cursorName = cursorNamePrefix + nextAvailableSectionNumber_;
0:      Section section = new Section (agent_, packageName, nextAvailableSectionNumber_, cursorName, resultSetHoldability);
0:      nextAvailableSectionNumber_++;
0:      return section;
1:    }
0:   else
0:   // unfortunately we have run out of sections
0:   throw new SqlException(agent_.logWriter_, "Run out of sections to use,sections limited to 32k currently");
1:  }
1: 
0:   public void freeSection (Section section, int resultSetHoldability)
0:   {
0:     if (resultSetHoldability == org.apache.derby.jdbc.ClientDataSource.HOLD_CURSORS_OVER_COMMIT)
0:       this.freeSectionsHold_.push(section);
0:     else if (resultSetHoldability == org.apache.derby.jdbc.ClientDataSource.CLOSE_CURSORS_AT_COMMIT)
0:       this.freeSectionsNonHold_.push(section);
1:   }
0:   // Get a section for a jdbc 2 positioned update/delete for the corresponding query.
0:   // A positioned update section must come from the same package as its query section.
0:   Section getPositionedUpdateSection (Section querySection) throws SqlException
0:   {
0:     Connection connection = agent_.connection_;
0:     return getDynamicSection (connection.resultSetHoldability_);
1:   }
1: 
0:   // Get a section for a jdbc 1 positioned update/delete for the corresponding query.
0:   // A positioned update section must come from the same package as its query section.
0:   Section getPositionedUpdateSection (String cursorName, boolean useExecuteImmediateSection) throws SqlException
0:   {
0:     Section querySection = (Section) positionedUpdateCursorNameToQuerySection_.get (cursorName);
1: 
0:     // If querySection is null, then the user must have provided a bad cursor name.
0:     // Otherwise, get a new section and save the client's cursor name and the server's
0:     // cursor name to the new section.
0:     if (querySection != null) {
0:       Section section = getPositionedUpdateSection (querySection);
0:       // getPositionedUpdateSection gets the next available section from the query
0:       // package, and it has a different cursor name associated with the section.
0:       // We need to save the client's cursor name and server's cursor name to the
0:       // new section.
0:       section.setClientCursorName (querySection.getClientCursorName());
0:       section.serverCursorNameForPositionedUpdate_ = querySection.getServerCursorName();
0:       return section;
1:     }
0:     else
0:       return null;
1:   }
1: 
0:   void mapCursorNameToQuerySection (String cursorName, Section section)
0:   {
0:     positionedUpdateCursorNameToQuerySection_.put (cursorName, section);
1:   }
1: 
0:   void mapCursorNameToResultSet (String cursorName, ResultSet resultSet)
0:   {
0:     positionedUpdateCursorNameToResultSet_.put (cursorName, resultSet);
1:   }
1: 
0:   ResultSet getPositionedUpdateResultSet (String cursorName) throws SqlException
0:   {
0:     ResultSet rs = (ResultSet)positionedUpdateCursorNameToResultSet_.get (cursorName);
0:     if (rs == null)
0:       throw new SqlException (agent_.logWriter_, "ResultSet for cursor " +
0:                               cursorName + " is closed.");
0:     return (rs.resultSetType_ == java.sql.ResultSet.TYPE_FORWARD_ONLY) ? null : rs;
1:   }
1: 
0:   void removeCursorNameToResultSetMapping (String clientCursorName,
0:                                            String serverCursorName)
0:   {
0:     if (clientCursorName != null)
0:       positionedUpdateCursorNameToResultSet_.remove (clientCursorName);
0:     if (serverCursorName != null)
0:       positionedUpdateCursorNameToResultSet_.remove (serverCursorName);
1:   }
1: 
0:   void removeCursorNameToQuerySectionMapping (String clientCursorName,
0:                                               String serverCursorName)
0:   {
0:     if (clientCursorName != null)
0:       positionedUpdateCursorNameToQuerySection_.remove (clientCursorName);
0:     if (serverCursorName != null)
0:       positionedUpdateCursorNameToQuerySection_.remove (serverCursorName);
1:   }
1: 
1: }
1: 
============================================================================