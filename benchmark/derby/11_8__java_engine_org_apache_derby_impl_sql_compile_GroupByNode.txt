8:eac0369: /*
1:7a9ce7e: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.compile.GroupByNode
1:345de35: 
1:2d37fd6:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2d37fd6:    contributor license agreements.  See the NOTICE file distributed with
1:2d37fd6:    this work for additional information regarding copyright ownership.
1:2d37fd6:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2d37fd6:    (the "License"); you may not use this file except in compliance with
1:2d37fd6:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:345de35: 
10:eac0369:  */
23:eac0369: 
1:eac0369: package	org.apache.derby.impl.sql.compile;
1:eac0369: 
1:31d80c0: import java.util.ArrayList;
1:31d80c0: import java.util.Collections;
1:31d80c0: import java.util.Comparator;
1:47d4a4c: import java.util.List;
1:4fb136d: import org.apache.derby.catalog.IndexDescriptor;
1:4fb136d: import org.apache.derby.iapi.error.StandardException;
1:4fb136d: import org.apache.derby.iapi.reference.ClassName;
1:8bae7cf: import org.apache.derby.iapi.reference.SQLState;
1:4fb136d: import org.apache.derby.iapi.services.classfile.VMOpcode;
1:4fb136d: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1:3bb140c: import org.apache.derby.iapi.services.context.ContextManager;
1:4fb136d: import org.apache.derby.iapi.services.io.FormatableArrayHolder;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:4fb136d: import org.apache.derby.iapi.sql.LanguageFactory;
1:4fb136d: import org.apache.derby.iapi.sql.ResultColumnDescriptor;
1:eac0369: import org.apache.derby.iapi.sql.compile.AccessPath;
1:4fb136d: import org.apache.derby.iapi.sql.compile.CostEstimate;
1:eac0369: import org.apache.derby.iapi.sql.compile.Optimizable;
1:eac0369: import org.apache.derby.iapi.sql.compile.OptimizablePredicate;
1:eac0369: import org.apache.derby.iapi.sql.compile.OptimizablePredicateList;
1:eac0369: import org.apache.derby.iapi.sql.compile.Optimizer;
1:eac0369: import org.apache.derby.iapi.sql.compile.RequiredRowOrdering;
1:eac0369: import org.apache.derby.iapi.sql.compile.RowOrdering;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
1:4fb136d: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1:4fb136d: import org.apache.derby.iapi.store.access.ColumnOrdering;
1:eac0369: import org.apache.derby.impl.sql.execute.AggregatorInfo;
1:eac0369: import org.apache.derby.impl.sql.execute.AggregatorInfoList;
1:eac0369: 
2:eac0369: /**
1:eac0369:  * A GroupByNode represents a result set for a grouping operation
1:eac0369:  * on a select.  Note that this includes a SELECT with aggregates
1:eac0369:  * and no grouping columns (in which case the select list is null)
1:eac0369:  * It has the same description as its input result set.
1:eac0369:  * <p>
1:eac0369:  * For the most part, it simply delegates operations to its bottomPRSet,
1:eac0369:  * which is currently expected to be a ProjectRestrictResultSet generated
1:eac0369:  * for a SelectNode.
1:eac0369:  * <p>
1:eac0369:  * NOTE: A GroupByNode extends FromTable since it can exist in a FromList.
1:eac0369:  * <p>
1:eac0369:  * There is a lot of room for optimizations here: <UL>
1:dbed020:  * <LI> agg(distinct x) group by x =&gt; agg(x) group by x (for min and max) </LI>
1:eac0369:  * <LI> min()/max() use index scans if possible, no sort may 
1:eac0369:  *		be needed. </LI>
1:eac0369:  * </UL>
3:eac0369:  *
1:eac0369:  *
1:eac0369:  */
1:3bb140c: class GroupByNode extends SingleChildResultSetNode
2:eac0369: {
1:eac0369: 	/**
1:eac0369: 	 * The GROUP BY list
1:eac0369: 	 */
1:eac0369: 	GroupByList groupingList;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * The list of all aggregates in the query block
1:eac0369: 	 * that contains this group by.
1:eac0369: 	 */
1:3bb140c:     private List<AggregateNode> aggregates;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Information that is used at execution time to
1:eac0369: 	 * process aggregates.
1:eac0369: 	 */
1:eac0369: 	private AggregatorInfoList	aggInfo;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * The parent to the GroupByNode.  If we need to
1:eac0369: 	 * generate a ProjectRestrict over the group by
1:eac0369: 	 * then this is set to that node.  Otherwise it
1:eac0369: 	 * is null.
1:eac0369: 	 */
1:eac0369: 	FromTable	parent;
1:eac0369: 
1:eac0369: 	private boolean	addDistinctAggregate;
1:eac0369: 	private boolean singleInputRowOptimization;
1:eac0369: 	private int		addDistinctAggregateColumnNum;
1:eac0369: 
1:eac0369: 	// Is the source in sorted order
1:e1f49ca:     final private boolean isInSortedOrder;
1:eac0369: 
1:d5ef906: 	private ValueNode havingClause;
1:eac0369: 	
1:d5ef906: 	private SubqueryList havingSubquerys;
1:eac0369: 	
1:eac0369: 	/**
1:3bb140c:      * Constructor for a GroupByNode.
1:eac0369: 	 *
1:3bb140c:      * @param bottomPR      The child FromTable
1:eac0369: 	 * @param groupingList	The groupingList
1:09c2697:      * @param aggregates    The list of aggregates from
1:eac0369: 	 *		the query block.  Since aggregation is done
1:eac0369: 	 *		at the same time as grouping, we need them
1:eac0369: 	 *		here.
1:3bb140c:      * @param havingClause  The having clause.
1:d5ef906: 	 * @param havingSubquerys subqueries in the having clause.
1:3bb140c:      * @param nestingLevel  NestingLevel of this group by node. This is used for
1:d5ef906: 	 *     error checking of group by queries with having clause.
1:3bb140c:      * @param cm            The context manager
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     GroupByNode(ResultSetNode  bottomPR,
1:3bb140c:                 GroupByList    groupingList,
1:3bb140c:                 List<AggregateNode> aggregates,
1:3bb140c:                 ValueNode      havingClause,
1:3bb140c:                 SubqueryList   havingSubquerys,
1:3bb140c:                 int            nestingLevel,
1:3bb140c:                 ContextManager cm)
1:eac0369: 			throws StandardException
1:eac0369: 	{
1:3bb140c:         super(bottomPR, null /* tableProperties */, cm);
1:3bb140c:         setLevel(nestingLevel);
1:3bb140c:         this.havingClause = havingClause;
1:3bb140c:         this.havingSubquerys = havingSubquerys;
1:eac0369: 		/* Group by without aggregates gets xformed into distinct */
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:3bb140c:             // Aggregates can be null if we have a having clause.
1:3bb140c:             // select c1 from t1 group by c1 having c1 > 1;
1:3bb140c:             // SanityManager.ASSERT(((List) aggregates).size() > 0,
1:3bb140c:             // "aggregates expected to be non-empty");
1:eac0369: 			if (!(childResult instanceof Optimizable))
1:eac0369: 			{
1:eac0369: 				SanityManager.THROWASSERT("childResult, " + childResult.getClass().getName() +
1:eac0369: 					", expected to be instanceof Optimizable");
2:eac0369: 			}
1:eac0369: 			if (!(childResult instanceof FromTable))
1:eac0369: 			{
1:eac0369: 				SanityManager.THROWASSERT("childResult, " + childResult.getClass().getName() +
1:eac0369: 					", expected to be instanceof FromTable");
1:eac0369: 			}
1:eac0369: 		}
1:31d80c0: 
1:eac0369: 		ResultColumnList newBottomRCL;
1:3bb140c:         this.groupingList = groupingList;
1:3bb140c:         this.aggregates = aggregates;
1:eac0369: 		this.parent = this;
1:c00561a: 
1:eac0369: 		/*
1:eac0369: 		** The first thing we do is put ourselves on
1:eac0369: 		** top of the SELECT.  The select becomes the
1:eac0369: 		** childResult.  So our RCL becomes its RCL (so
1:eac0369: 		** nodes above it now point to us).  Map our
1:eac0369: 		** RCL to its columns.
1:eac0369: 		*/
1:eac0369: 		newBottomRCL = childResult.getResultColumns().copyListAndObjects();
1:11f7ee3: 		setResultColumns( childResult.getResultColumns() );
1:eac0369: 		childResult.setResultColumns(newBottomRCL);
1:01217c2: 
1:eac0369: 		/*
1:eac0369: 		** We have aggregates, so we need to add
1:eac0369: 		** an extra PRNode and we also have to muck around
1:eac0369: 		** with our trees a might.
1:eac0369: 		*/
1:eac0369: 		addAggregates();
1:eac0369: 
1:b5105f3: 		if (this.groupingList != null && this.groupingList.isRollup())
1:b5105f3:                 {
1:11f7ee3:                     getResultColumns().setNullability(true);
1:b5105f3: 			parent.getResultColumns().setNullability(true);
1:b5105f3:                 }
1:eac0369: 		/* We say that the source is never in sorted order if there is a distinct aggregate.
1:eac0369: 		 * (Not sure what happens if it is, so just skip it for now.)
1:eac0369: 		 * Otherwise, we check to see if the source is in sorted order on any permutation
1:eac0369: 		 * of the grouping columns.)
1:eac0369: 		 */
1:eac0369: 		if (! addDistinctAggregate && groupingList != null)
1:eac0369: 		{
1:eac0369: 			ColumnReference[] crs =
1:eac0369: 								new ColumnReference[this.groupingList.size()];
1:eac0369: 
1:eac0369: 			// Now populate the CR array and see if ordered
1:eac0369: 			int glSize = this.groupingList.size();
1:01217c2: 			int index;
1:01217c2: 			for (index = 0; index < glSize; index++)
1:eac0369: 			{
1:e1f49ca:                 GroupByColumn gc = this.groupingList.elementAt(index);
1:01217c2: 				if (gc.getColumnExpression() instanceof ColumnReference) 
1:01217c2: 				{
1:01217c2: 					crs[index] = (ColumnReference)gc.getColumnExpression();
1:01217c2: 				} 
1:01217c2: 				else 
1:01217c2: 				{
1:eac0369: 					break;
1:eac0369: 				}
1:e1f49ca: 				
1:eac0369: 			}
1:1c6c2e8: 
1:e1f49ca:             isInSortedOrder = (index == glSize) &&
1:e1f49ca:                 childResult.isOrderedOn(crs, true, (List<FromBaseTable>)null);
1:e1f49ca:         } else {
1:e1f49ca:             isInSortedOrder = false;
1:e1f49ca:         }
1:01217c2: 	}
1:01217c2: 
1:31d80c0: 	/**
1:eac0369: 	 * Get whether or not the source is in sorted order.
1:eac0369: 	 *
1:eac0369: 	 * @return Whether or not the source is in sorted order.
1:eac0369: 	 */
1:eac0369: 	boolean getIsInSortedOrder()
1:eac0369: 	{
1:eac0369: 		return isInSortedOrder;
1:01217c2: 	}
1:eac0369: 
1:01217c2: 	/**
1:eac0369: 	 * Add the extra result columns required by the aggregates
1:eac0369: 	 * to the result list.
1:eac0369: 	 * 
1:eac0369: 	 * @exception standard exception
1:eac0369: 	 */
1:eac0369: 	private void addAggregates()
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		addNewPRNode();
1:eac0369: 		addNewColumnsForAggregation();
1:eac0369: 		addDistinctAggregatesToOrderBy();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Add any distinct aggregates to the order by list.
1:eac0369: 	 * Asserts that there are 0 or more distincts.
1:eac0369: 	 */
1:eac0369: 	private void addDistinctAggregatesToOrderBy()
1:eac0369: 	{
1:09c2697:         int numDistinct = numDistinctAggregates(aggregates);
1:eac0369: 		if (numDistinct != 0)
1:eac0369: 		{
1:eac0369: 			if (SanityManager.DEBUG)
1:eac0369: 			{
1:b5105f3: 				SanityManager.ASSERT(groupingList != null || numDistinct == 1,
1:eac0369: 					"Should not have more than 1 distinct aggregate per Group By node");
1:eac0369: 			}
1:eac0369: 			
1:eac0369: 			AggregatorInfo agg = null;
1:eac0369: 			int count = aggInfo.size();
1:eac0369: 			for (int i = 0; i < count; i++)
1:eac0369: 			{
1:3bb140c:                 agg = aggInfo.elementAt(i);
1:eac0369: 				if (agg.isDistinct())
1:eac0369: 				{
1:01217c2: 					break;
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			if (SanityManager.DEBUG)
1:eac0369: 			{
1:eac0369: 				SanityManager.ASSERT(agg != null && agg.isDistinct());
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			addDistinctAggregate = true;
1:eac0369: 			addDistinctAggregateColumnNum = agg.getInputColNum();
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 	
1:eac0369: 	/**
1:eac0369: 	 * Add a new PR node for aggregation.  Put the
1:eac0369: 	 * new PR under the sort.
1:eac0369: 	 *		
1:eac0369: 	 * @exception standard exception
1:eac0369: 	 */
1:eac0369: 	private void addNewPRNode()
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		/*
1:eac0369: 		** Get the new PR, put above the GroupBy.  
1:eac0369: 		*/
1:3bb140c:         ResultColumnList rclNew = new ResultColumnList((getContextManager()));
1:e1f49ca: 
1:11f7ee3:         for (ResultColumn rc : getResultColumns())
1:eac0369: 		{
1:d5ef906: 			if (!rc.isGenerated()) {
1:d5ef906: 				rclNew.addElement(rc);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:d5ef906: 		// if any columns in the source RCL were generated for an order by
1:d5ef906: 		// remember it in the new RCL as well. After the sort is done it will
1:d5ef906: 		// have to be projected out upstream.
1:11f7ee3: 		rclNew.copyOrderBySelect(getResultColumns());
1:eac0369: 		
1:3bb140c:         parent = new ProjectRestrictNode(
1:eac0369: 										this, 	// child
1:d5ef906: 										rclNew,
1:d5ef906: 										null, //havingClause,
1:eac0369: 										null,				// restriction list
1:eac0369: 										null,				// project subqueries
1:d5ef906: 										havingSubquerys,
1:eac0369: 										tableProperties,
2:01217c2: 										getContextManager());
1:eac0369: 
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** Reset the bottom RCL to be empty.
1:eac0369: 		*/
1:3bb140c:         childResult.setResultColumns(new ResultColumnList(getContextManager()));
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** Set the group by RCL to be empty
1:eac0369: 		*/
1:11f7ee3:         setResultColumns( new ResultColumnList((getContextManager())) );
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:c00561a: 	 * In the query rewrite for group by, add the columns on which we are doing
1:c00561a: 	 * the group by.
1:c00561a: 	 *
1:c00561a: 	 * @return havingRefsToSubstitute visitors array. Return any
1:c00561a: 	 *         havingRefsToSubstitute visitors since it is too early to apply
1:c00561a: 	 *         them yet; we need the AggregateNodes unmodified until after
1:c00561a: 	 *         we add the new columns for aggregation (DERBY-4071).
1:c00561a: 	 *
1:01217c2: 	 * @see #addNewColumnsForAggregation
1:01217c2: 	 */
1:71c8e86: 	private ArrayList<SubstituteExpressionVisitor> addUnAggColumns() throws StandardException
1:01217c2: 	{
1:01217c2: 		ResultColumnList bottomRCL  = childResult.getResultColumns();
1:11f7ee3: 		ResultColumnList groupByRCL = getResultColumns();
1:01217c2: 
1:71c8e86: 		ArrayList<SubstituteExpressionVisitor> referencesToSubstitute = new ArrayList<SubstituteExpressionVisitor>();
1:71c8e86: 		ArrayList<SubstituteExpressionVisitor> havingRefsToSubstitute = null;
1:31d80c0: 		if (havingClause != null)
1:71c8e86: 			havingRefsToSubstitute = new ArrayList<SubstituteExpressionVisitor>();
1:e1f49ca: 
1:e1f49ca:         for (GroupByColumn gbc : groupingList)
1:01217c2: 		{
1:3bb140c:             ResultColumn newRC = new ResultColumn(
1:3bb140c:                     "##UnaggColumn",
2:01217c2: 					gbc.getColumnExpression(),
1:01217c2: 					getContextManager());
1:01217c2: 
1:01217c2: 			// add this result column to the bottom rcl
1:01217c2: 			bottomRCL.addElement(newRC);
1:01217c2: 			newRC.markGenerated();
1:01217c2: 			newRC.bindResultColumnToExpression();
1:01217c2: 			newRC.setVirtualColumnId(bottomRCL.size());
1:01217c2: 			
1:01217c2: 			// now add this column to the groupbylist
1:3bb140c:             ResultColumn gbRC = new ResultColumn(
1:3bb140c:                     "##UnaggColumn",
1:01217c2: 					gbc.getColumnExpression(),
1:01217c2: 					getContextManager());
1:3bb140c: 
1:3bb140c:             groupByRCL.addElement(gbRC);
1:01217c2: 			gbRC.markGenerated();
1:01217c2: 			gbRC.bindResultColumnToExpression();
1:01217c2: 			gbRC.setVirtualColumnId(groupByRCL.size());
1:01217c2: 
1:01217c2: 			/*
1:01217c2: 			 ** Reset the original node to point to the
1:01217c2: 			 ** Group By result set.
1:01217c2: 			 */
1:3bb140c:             VirtualColumnNode vc = new VirtualColumnNode(
1:01217c2: 					this, // source result set.
1:01217c2: 					gbRC,
1:3bb140c:                     groupByRCL.size(),
1:01217c2: 					getContextManager());
1:01217c2: 
1:01217c2: 			// we replace each group by expression 
1:01217c2: 			// in the projection list with a virtual column node
1:01217c2: 			// that effectively points to a result column 
1:01217c2: 			// in the result set doing the group by
1:31d80c0: 			//
1:31d80c0: 			// Note that we don't perform the replacements
1:31d80c0: 			// immediately, but instead we accumulate them
1:31d80c0: 			// until the end of the loop. This allows us to
1:31d80c0: 			// sort the expressions and process them in
1:31d80c0: 			// descending order of complexity, necessary
1:31d80c0: 			// because a compound expression may contain a
1:31d80c0: 			// reference to a simple grouped column, but in
1:31d80c0: 			// such a case we want to process the expression
1:31d80c0: 			// as an expression, not as individual column
1:31d80c0: 			// references. E.g., if the statement was:
1:31d80c0: 			//   SELECT ... GROUP BY C1, C1 * (C2 / 100), C3
1:31d80c0: 			// then we don't want the replacement of the
1:31d80c0: 			// simple column reference C1 to affect the
1:31d80c0: 			// compound expression C1 * (C2 / 100). DERBY-3094.
1:31d80c0: 			//
1:31d80c0: 			ValueNode vn = gbc.getColumnExpression();
1:31d80c0: 			SubstituteExpressionVisitor vis =
1:31d80c0: 				new SubstituteExpressionVisitor(vn, vc,
1:01217c2: 						AggregateNode.class);
1:31d80c0: 			referencesToSubstitute.add(vis);
1:01217c2: 			
1:d5ef906: 			// Since we always need a PR node on top of the GB 
1:d5ef906: 			// node to perform projection we can use it to perform 
1:d5ef906: 			// the having clause restriction as well. 
1:d5ef906: 			// To evaluate the having clause correctly, we need to 
1:d5ef906: 			// convert each aggregate and expression to point 
1:d5ef906: 			// to the appropriate result column in the group by node. 
1:d5ef906: 			// This is no different from the transformations we do to 
1:d5ef906: 			// correctly evaluate aggregates and expressions in the 
1:d5ef906: 			// projection list. 
1:d5ef906: 			// 
1:d5ef906: 			//
1:d5ef906: 			// For this query:
1:d5ef906: 			// SELECT c1, SUM(c2), MAX(c3)
1:d5ef906: 			//    FROM t1 
1:d5ef906: 			//    HAVING c1+max(c3) > 0;
1:eac0369: 
1:d5ef906: 			// PRSN RCL -> (ptr(gbn:rcl[0]), ptr(gbn:rcl[1]), ptr(gbn:rcl[4]))
1:d5ef906: 			// Restriction: (> (+ ptr(gbn:rcl[0]) ptr(gbn:rcl[4])) 0)
1:d5ef906: 			//              |
1:d5ef906: 			// GBN (RCL) -> (C1, SUM(C2), <input>, <aggregator>, MAX(C3), <input>, <aggregator>
1:d5ef906: 			//              |
1:d5ef906: 			//       FBT (C1, C2)
1:31d80c0: 			if (havingClause != null)
1:31d80c0: 			{
1:d5ef906: 				SubstituteExpressionVisitor havingSE =
1:31d80c0: 					new SubstituteExpressionVisitor(vn,vc,null);
1:31d80c0: 				havingRefsToSubstitute.add(havingSE);
1:01217c2: 			}
1:01217c2: 			gbc.setColumnPosition(bottomRCL.size());
1:01217c2: 		}
1:71c8e86: 		ExpressionSorter sorter = new ExpressionSorter();
1:31d80c0: 		Collections.sort(referencesToSubstitute,sorter);
1:31d80c0: 		for (int r = 0; r < referencesToSubstitute.size(); r++)
1:31d80c0: 			parent.getResultColumns().accept(
1:71c8e86: 				referencesToSubstitute.get(r));
1:31d80c0: 		if (havingRefsToSubstitute != null)
1:31d80c0: 		{
1:31d80c0: 			Collections.sort(havingRefsToSubstitute,sorter);
1:c00561a: 			// DERBY-4071 Don't substitute quite yet; we need the AggrateNodes
1:c00561a: 			// undisturbed until after we have had the chance to build the
1:c00561a: 			// other columns.  (The AggrateNodes are shared via an alias from
1:09c2697:             // aggregates and from the expression tree under havingClause).
1:31d80c0: 		}
1:c00561a: 		return havingRefsToSubstitute;
1:c00561a: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Add a whole slew of columns needed for 
1:eac0369: 	 * aggregation. Basically, for each aggregate we add
1:d5ef906: 	 * 3 columns: the aggregate input expression
1:d5ef906: 	 * and the aggregator column and a column where the aggregate 
1:d5ef906: 	 * result is stored.  The input expression is
1:eac0369: 	 * taken directly from the aggregator node.  The aggregator
1:eac0369: 	 * is the run time aggregator.  We add it to the RC list
1:eac0369: 	 * as a new object coming into the sort node.
1:eac0369: 	 * <P>
1:eac0369: 	 * At this point this is invoked, we have the following
1:eac0369: 	 * tree: <UL>
1:eac0369: 	 *      PR - (PARENT): RCL is the original select list
1:eac0369: 	 *       |
1:eac0369: 	 *      PR - GROUP BY:  RCL is empty
1:eac0369: 	 *       |
1:eac0369: 	 *      PR - FROM TABLE: RCL is empty </UL> <P>
1:eac0369: 	 *
1:eac0369: 	 * For each ColumnReference in PR RCL <UL>
1:eac0369: 	 *	<LI> clone the ref </LI>
1:eac0369: 	 *	<LI> create a new RC in the bottom RCL and set it 
1:eac0369: 	 *		 to the col ref </LI>
1:eac0369: 	 *	<LI> create a new RC in the GROUPBY RCL and set it to 
1:eac0369: 	 *		 point to the bottom RC </LI>
1:eac0369: 	 *	<LI> reset the top PR ref to point to the new GROUPBY
1:d5ef906: 	 *		 RC</LI></UL>	
1:eac0369: 	 *
1:09c2697:      * For each aggregate in {@code aggregates} <UL>
1:eac0369: 	 *	<LI> create RC in FROM TABLE.  Fill it with 
1:eac0369: 	 * 		aggs Operator.
1:eac0369: 	 *	<LI> create RC in FROM TABLE for agg result</LI>
1:eac0369: 	 *	<LI> create RC in FROM TABLE for aggregator</LI>
1:eac0369: 	 *	<LI> create RC in GROUPBY for agg input, set it
1:eac0369: 	 *		to point to FROM TABLE RC </LI>
1:eac0369: 	 *	<LI> create RC in GROUPBY for agg result</LI>
1:eac0369: 	 *	<LI> create RC in GROUPBY for aggregator</LI>
1:d5ef906: 	 *	<LI> replace Agg with reference to RC for agg result </LI></UL>.
1:d5ef906: 	 * <P>
1:d5ef906: 	 * For a query like,
1:d5ef906: 	 * <pre>
1:d5ef906: 	  select c1, sum(c2), max(c3)
1:d5ef906: 	  from t1 
1:d5ef906: 	  group by c1;
1:d5ef906: 	  </pre>
1:d5ef906: 	 * the query tree ends up looking like this:
1:d5ef906: 	   <pre>
1:dbed020: 	    ProjectRestrictNode RCL -&gt; (ptr to GBN(column[0]), ptr to GBN(column[1]), ptr to GBN(column[4]))
1:d5ef906: 	              |
1:dbed020: 	    GroupByNode RCL-&gt;(C1, SUM(C2), &lt;agg-input&gt;, <aggregator>, MAX(C3), &lt;agg-input&gt;, &lt;aggregator&gt;)
1:d5ef906: 	              |
1:dbed020: 	    ProjectRestrict RCL-&gt;(C1, C2, C3)
1:d5ef906: 	              |
1:d5ef906: 	    FromBaseTable
1:d5ef906: 	    </pre>
1:eac0369: 	 * 
1:d5ef906: 	 * The RCL of the GroupByNode contains all the unagg (or grouping columns)
1:d5ef906: 	 * followed by 3 RC's for each aggregate in this order: the final computed
1:d5ef906: 	 * aggregate value, the aggregate input and the aggregator function.
1:d5ef906: 	 * <p>
1:d5ef906: 	 * The Aggregator function puts the results in the first of the 3 RC's 
1:d5ef906: 	 * and the PR resultset in turn picks up the value from there.
1:d5ef906: 	 * <p>
1:d5ef906: 	 * The notation (ptr to GBN(column[0])) basically means that it is
1:d5ef906: 	 * a pointer to the 0th RC in the RCL of the GroupByNode. 
1:d5ef906: 	 * <p>
1:d5ef906: 	 * The addition of these unagg and agg columns to the GroupByNode and 
1:d5ef906: 	 * to the PRN is performed in addUnAggColumns and addAggregateColumns. 
1:d5ef906: 	 * <p>
1:d5ef906: 	 * Note that that addition of the GroupByNode is done after the
1:d5ef906: 	 * query is optimized (in SelectNode#modifyAccessPaths) which means a 
1:d5ef906: 	 * fair amount of patching up is needed to account for generated group by columns.
1:eac0369: 	 * @exception standard exception
1:eac0369: 	 */
1:eac0369: 	private void addNewColumnsForAggregation()
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:01217c2: 		aggInfo = new AggregatorInfoList();
1:71c8e86: 		ArrayList<SubstituteExpressionVisitor> havingRefsToSubstitute = null;
1:c00561a: 
1:01217c2: 		if (groupingList != null)
1:01217c2: 		{
1:c00561a: 			havingRefsToSubstitute = addUnAggColumns();
1:01217c2: 		}
1:c00561a: 
1:c00561a: 		addAggregateColumns();
1:c00561a: 
1:d5ef906: 		if (havingClause != null) {
1:c00561a: 
1:c00561a: 			// Now do the substitution of the group by expressions in the
1:c00561a: 			// having clause.
1:c00561a: 			if (havingRefsToSubstitute != null) {
1:c00561a: 				for (int r = 0; r < havingRefsToSubstitute.size(); r++) {
1:3bb140c:                     havingClause.accept(havingRefsToSubstitute.get(r));
1:c00561a: 				}
1:c00561a: 			}
1:c00561a: 
1:d5ef906: 			// we have replaced group by expressions in the having clause.
1:d5ef906: 			// there should be no column references in the having clause 
1:d5ef906: 			// referencing this table. Skip over aggregate nodes.
1:d5ef906: 			//   select a, sum(b) from t group by a having a+c > 1 
1:d5ef906: 			//  is not valid because of column c.
1:d5ef906: 			// 
1:d5ef906: 			// it is allright to have columns from parent or child subqueries;
1:d5ef906: 			//   select * from p where p.p1 in 
1:d5ef906: 			//      (select c.c1 from c group by c.c1 having count(*) = p.p2
1:a6d25cd:             CollectNodesVisitor<ColumnReference> collectNodesVisitor =
1:a6d25cd:                 new CollectNodesVisitor<ColumnReference>(
1:a6d25cd:                     ColumnReference.class, AggregateNode.class);
1:d5ef906: 			havingClause.accept(collectNodesVisitor);
1:7a9ce7e: 
1:a6d25cd:             for (ColumnReference cr: collectNodesVisitor.getList())
1:eac0369: 			{
1:7a9ce7e: 				if ( ! (cr.getGeneratedToReplaceAggregate() ||
1:7a9ce7e: 						cr.getGeneratedToReplaceWindowFunctionCall()) &&
1:7a9ce7e: 					 cr.getSourceLevel() == level) {
1:d5ef906: 					throw StandardException.newException(
1:d5ef906: 							SQLState.LANG_INVALID_COL_HAVING_CLAUSE, 
1:d5ef906: 							cr.getSQLColumnName());						
1:01217c2: 				}
1:eac0369: 			}
1:eac0369: 		}
1:01217c2: 
1:eac0369: 	}
1:eac0369: 	
1:01217c2: 	/**
1:01217c2: 	 * In the query rewrite involving aggregates, add the columns for
1:01217c2: 	 * aggregation.
1:01217c2: 	 *
1:01217c2: 	 * @see #addNewColumnsForAggregation
1:01217c2: 	 */
1:01217c2: 	private void addAggregateColumns() throws StandardException
1:01217c2: 	{
1:01217c2: 		DataDictionary			dd = getDataDictionary();
1:eac0369: 		ColumnReference	newColumnRef;
1:eac0369: 		ResultColumn	newRC;
1:eac0369: 		ResultColumn	tmpRC;
1:db69e70: 		ResultColumn	aggResultRC;
1:eac0369: 		ResultColumnList bottomRCL  = childResult.getResultColumns();
1:11f7ee3: 		ResultColumnList groupByRCL = getResultColumns();
1:eac0369: 		ResultColumnList aggRCL;
1:eac0369: 		int				aggregatorVColId;
1:eac0369: 		int				aggInputVColId;
1:eac0369: 		int				aggResultVColId;
1:eac0369: 		
1:eac0369: 		/*
1:01217c2: 		 ** Now process all of the aggregates.  Replace
1:01217c2: 		 ** every aggregate with an RC.  We toss out
1:01217c2: 		 ** the list of RCs, we need to get each RC
1:01217c2: 		 ** as we process its corresponding aggregate.
1:01217c2: 		 */
1:01217c2: 		LanguageFactory lf = getLanguageConnectionContext().getLanguageFactory();
1:01217c2: 		
1:eac0369: 		ReplaceAggregatesWithCRVisitor replaceAggsVisitor = 
1:eac0369: 			new ReplaceAggregatesWithCRVisitor(
1:3bb140c:                     new ResultColumnList((getContextManager())),
1:d5ef906: 				((FromTable) childResult).getTableNumber(),
1:d5ef906: 				ResultSetNode.class);
1:eac0369: 		parent.getResultColumns().accept(replaceAggsVisitor);
1:eac0369: 
1:eac0369: 		
1:d5ef906: 		if (havingClause != null) 
1:eac0369: 		{
1:d5ef906: 			// replace aggregates in the having clause with column references.
1:d5ef906: 			replaceAggsVisitor = new ReplaceAggregatesWithCRVisitor(
1:3bb140c:                     new ResultColumnList((getContextManager())),
1:d5ef906: 					((FromTable)childResult).getTableNumber());
1:d5ef906: 			havingClause.accept(replaceAggsVisitor);
1:d5ef906: 			// make having clause a restriction list in the parent 
1:d5ef906: 			// project restrict node.
1:d5ef906: 			ProjectRestrictNode parentPRSN = (ProjectRestrictNode)parent;
1:d5ef906: 			parentPRSN.setRestriction(havingClause);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		
1:eac0369: 		/*
1:eac0369: 		** For each aggregate
1:eac0369: 		*/
1:09c2697:         int alSize = aggregates.size();
1:eac0369: 		for (int index = 0; index < alSize; index++)
1:eac0369: 		{
1:3bb140c:             AggregateNode aggregate = aggregates.get(index);
1:eac0369: 
1:eac0369: 			/*
1:eac0369: 			** AGG RESULT: Set the aggregate result to null in the
1:eac0369: 			** bottom project restrict.
1:eac0369: 			*/
1:3bb140c:             newRC = new ResultColumn(
1:3bb140c:                     "##aggregate result",
1:3bb140c: 					aggregate.getNewNullResultExpression(),
1:01217c2: 					getContextManager());
2:eac0369: 			newRC.markGenerated();
2:eac0369: 			newRC.bindResultColumnToExpression();
2:eac0369: 			bottomRCL.addElement(newRC);
2:eac0369: 			newRC.setVirtualColumnId(bottomRCL.size());
1:eac0369: 			aggResultVColId = newRC.getVirtualColumnId();
1:eac0369: 
1:eac0369: 			/*
1:eac0369: 			** Set the GB aggregrate result column to
1:eac0369: 			** point to this.  The GB aggregate result
1:eac0369: 			** was created when we called
1:c00561a: 			** ReplaceAggregatesWithCRVisitor()
1:eac0369: 			*/
1:3bb140c:             newColumnRef = new ColumnReference(newRC.getName(),
1:3bb140c:                                                null,
1:3bb140c:                                                getContextManager());
1:eac0369: 			newColumnRef.setSource(newRC);
1:eac0369: 			newColumnRef.setNestingLevel(this.getLevel());
1:eac0369: 			newColumnRef.setSourceLevel(this.getLevel());
1:3bb140c:            tmpRC = new ResultColumn(
1:01217c2: 					newRC.getColumnName(),
1:01217c2: 					newColumnRef,
1:3bb140c: 					getContextManager());
1:eac0369: 			tmpRC.markGenerated();
1:eac0369: 			tmpRC.bindResultColumnToExpression();
1:eac0369: 			groupByRCL.addElement(tmpRC);
1:eac0369: 			tmpRC.setVirtualColumnId(groupByRCL.size());
1:eac0369: 
1:eac0369: 			/*
1:eac0369: 			** Set the column reference to point to
1:eac0369: 			** this.
1:eac0369: 			*/
1:eac0369: 			newColumnRef = aggregate.getGeneratedRef();
1:eac0369: 			newColumnRef.setSource(tmpRC);
1:eac0369: 
1:eac0369: 			/*
1:eac0369: 			** AGG INPUT: Create a ResultColumn in the bottom 
1:eac0369: 			** project restrict that has the expression that is
1:eac0369: 			** to be aggregated
1:eac0369: 			*/
1:eac0369: 			newRC = aggregate.getNewExpressionResultColumn(dd);
1:eac0369: 			newRC.markGenerated();
1:eac0369: 			newRC.bindResultColumnToExpression();
1:eac0369: 			bottomRCL.addElement(newRC);
1:eac0369: 			newRC.setVirtualColumnId(bottomRCL.size());
1:eac0369: 			aggInputVColId = newRC.getVirtualColumnId();
1:3bb140c:            aggResultRC = new ResultColumn(
1:db69e70:                     "##aggregate expression",
1:db69e70:                     aggregate.getNewNullResultExpression(),
1:db69e70:                     getContextManager());
1:eac0369: 	
1:eac0369: 			/*
1:eac0369: 			** Add a reference to this column into the
1:eac0369: 			** group by columns.
1:eac0369: 			*/
1:eac0369: 			tmpRC = getColumnReference(newRC, dd);
1:eac0369: 			groupByRCL.addElement(tmpRC);
1:eac0369: 			tmpRC.setVirtualColumnId(groupByRCL.size());
1:eac0369: 
1:eac0369: 			/*
1:eac0369: 			** AGGREGATOR: Add a getAggregator method call 
1:eac0369: 			** to the bottom result column list.
1:eac0369: 			*/
1:eac0369: 			newRC = aggregate.getNewAggregatorResultColumn(dd);
1:eac0369: 			newRC.markGenerated();
1:eac0369: 			newRC.bindResultColumnToExpression();
1:eac0369: 			bottomRCL.addElement(newRC);
1:eac0369: 			newRC.setVirtualColumnId(bottomRCL.size());
1:eac0369: 			aggregatorVColId = newRC.getVirtualColumnId();
1:eac0369: 
1:eac0369: 			/*
1:eac0369: 			** Add a reference to this column in the Group By result
1:eac0369: 			** set.
1:eac0369: 			*/
1:eac0369: 			tmpRC = getColumnReference(newRC, dd);
1:eac0369: 			groupByRCL.addElement(tmpRC);
1:eac0369: 			tmpRC.setVirtualColumnId(groupByRCL.size());
1:eac0369: 
1:eac0369: 			/*
1:eac0369: 			** Piece together a fake one column rcl that we will use
1:eac0369: 			** to generate a proper result description for input
1:eac0369: 			** to this agg if it is a user agg.
1:eac0369: 			*/
1:3bb140c:             aggRCL = new ResultColumnList((getContextManager()));
1:db69e70: 			aggRCL.addElement(aggResultRC);
1:eac0369: 
1:eac0369: 			/*
1:eac0369: 			** Note that the column ids in the row are 0 based
1:eac0369: 			** so we have to subtract 1.
1:eac0369: 			*/
1:eac0369: 			aggInfo.addElement(new AggregatorInfo(
1:01217c2: 					aggregate.getAggregateName(),
1:01217c2: 					aggregate.getAggregatorClassName(),
1:01217c2: 					aggInputVColId - 1,			// aggregate input column
1:01217c2: 					aggResultVColId -1,			// the aggregate result column
1:01217c2: 					aggregatorVColId - 1,		// the aggregator column	
1:01217c2: 					aggregate.isDistinct(),
1:01217c2: 					lf.getResultDescription(aggRCL.makeResultDescriptors(), "SELECT")
1:01217c2: 			));
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return the parent node to this one, if there is
1:eac0369: 	 * one.  It will return 'this' if there is no generated
1:eac0369: 	 * node above this one.
1:eac0369: 	 *
1:eac0369: 	 * @return the parent node
1:eac0369: 	 */
1:9f2ed7d:     final FromTable getParent()
1:eac0369: 	{
1:eac0369: 		return parent;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 *  Optimizable interface
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see Optimizable#optimizeIt
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	public CostEstimate optimizeIt(
1:eac0369: 							Optimizer optimizer,
1:eac0369: 							OptimizablePredicateList predList,
1:eac0369: 							CostEstimate outerCost,
1:eac0369: 							RowOrdering rowOrdering)
1:eac0369: 			throws StandardException
1:eac0369: 	{
1:eac0369: 		// RESOLVE: NEED TO FACTOR IN THE COST OF GROUPING (SORTING) HERE
1:e1f49ca:         ((Optimizable) childResult).optimizeIt( optimizer,
1:e1f49ca:                                                 predList,
1:e1f49ca:                                                 outerCost,
1:e1f49ca:                                                 rowOrdering);
1:eac0369: 
1:e1f49ca:         CostEstimate retval = super.optimizeIt( optimizer,
2:eac0369: 												predList,
2:eac0369: 												outerCost,
1:eac0369: 												rowOrdering
1:eac0369: 											  );
1:eac0369: 
1:eac0369: 		return retval;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see Optimizable#estimateCost
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	public CostEstimate estimateCost(OptimizablePredicateList predList,
1:eac0369: 										ConglomerateDescriptor cd,
1:eac0369: 										CostEstimate outerCost,
1:eac0369: 										Optimizer optimizer,
1:eac0369: 										RowOrdering rowOrdering
1:eac0369: 										)
1:eac0369: 			throws StandardException
1:eac0369: 	{
1:eac0369: 		// RESOLVE: NEED TO FACTOR IN THE COST OF GROUPING (SORTING) HERE
1:eac0369: 		//
1:eac0369: 		CostEstimate childCost = ((Optimizable) childResult).estimateCost(
1:eac0369: 													predList,
1:eac0369: 													cd,
1:eac0369: 													outerCost,
3:eac0369: 													optimizer,
2:eac0369: 													rowOrdering);
1:eac0369: 
1:3bb140c:         CostEstimate costEst = getCostEstimate(optimizer);
1:3bb140c:         costEst.setCost(childCost.getEstimatedCost(),
1:eac0369: 							childCost.rowCount(),
1:eac0369: 							childCost.singleScanRowCount());
1:eac0369: 
1:3bb140c:         return costEst;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see org.apache.derby.iapi.sql.compile.Optimizable#pushOptPredicate
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 
1:3bb140c:     @Override
1:eac0369: 	public boolean pushOptPredicate(OptimizablePredicate optimizablePredicate)
1:eac0369: 			throws StandardException
1:eac0369: 	{
1:eac0369: 		return ((Optimizable) childResult).pushOptPredicate(optimizablePredicate);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
1:eac0369: 	 * for how this should be done for tree printing.
1:eac0369: 	 *
1:eac0369: 	 * @return	This object as a String
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	public String toString()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			return "singleInputRowOptimization: " + singleInputRowOptimization + "\n" +
1:c9a1206: 				super.toString();
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return "";
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:c9a1206: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
1:c9a1206: 	 * how tree printing is supposed to work.
1:c9a1206: 	 *
1:c9a1206: 	 * @param depth		The depth of this node in the tree
1:c9a1206: 	 */
1:3bb140c:     @Override
1:3bb140c:     void printSubNodes(int depth) {
1:c9a1206: 		if (SanityManager.DEBUG)
1:c9a1206: 		{
1:c9a1206: 			super.printSubNodes(depth);
1:c9a1206: 
1:09c2697:             printLabel(depth, "aggregates:\n");
1:c9a1206: 
1:09c2697:             for (int i = 0; i < aggregates.size(); i++) {
1:3bb140c:                 AggregateNode agg = aggregates.get(i);
1:c9a1206:                 debugPrint(formatNodeString("[" + i + "]:", depth + 1));
1:c9a1206:                 agg.treePrint(depth + 1);
1:c9a1206:             }
1:c9a1206: 
1:c9a1206: 			if (groupingList != null) {
1:c9a1206: 				printLabel(depth, "groupingList: ");
1:c9a1206: 				groupingList.treePrint(depth + 1);
1:c9a1206: 			}
1:c9a1206: 
1:c9a1206: 			if (havingClause != null)
1:c9a1206: 			{
1:c9a1206: 				printLabel(depth, "havingClause: ");
1:c9a1206: 				havingClause.treePrint(depth + 1);
1:c9a1206: 			}
1:c9a1206: 
1:c9a1206: 			if (havingSubquerys != null)
1:c9a1206: 			{
1:c9a1206: 				printLabel(depth, "havingSubqueries: ");
1:c9a1206: 				havingSubquerys.treePrint(depth + 1);
1:c9a1206: 			}
1:c9a1206: 		}
1:c9a1206: 	}
1:c9a1206: 
1:c9a1206: 	/**
1:eac0369: 	 * Evaluate whether or not the subquery in a FromSubquery is flattenable.
1:eac0369: 	 * Currently, a FSqry is flattenable if all of the following are true:
1:eac0369: 	 *		o  Subquery is a SelectNode.
1:eac0369: 	 *		o  It contains no top level subqueries.  (RESOLVE - we can relax this)
1:eac0369: 	 *		o  It does not contain a group by or having clause
1:eac0369: 	 *		o  It does not contain aggregates.
1:eac0369: 	 *
1:eac0369: 	 * @param fromList	The outer from list
1:eac0369: 	 *
1:eac0369: 	 * @return boolean	Whether or not the FromSubquery is flattenable.
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     boolean flattenableInFromSubquery(FromList fromList)
1:eac0369: 	{
1:eac0369: 		/* Can't flatten a GroupByNode */
1:eac0369: 		return false;
1:09c2697: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Optimize this GroupByNode.
1:eac0369: 	 *
1:eac0369: 	 * @param dataDictionary	The DataDictionary to use for optimization
1:6b50965: 	 * @param predicates		The PredicateList to optimize.  This should
1:eac0369: 	 *							be a join predicate.
1:eac0369: 	 * @param outerRows			The number of outer joining rows
1:eac0369: 	 *
1:eac0369: 	 * @return	ResultSetNode	The top of the optimized subtree
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     ResultSetNode optimize(DataDictionary dataDictionary,
1:eac0369: 								  PredicateList predicates,
1:eac0369: 								  double outerRows)
1:eac0369: 					throws StandardException
1:eac0369: 	{
1:eac0369: 		/* We need to implement this method since a PRN can appear above a
1:eac0369: 		 * SelectNode in a query tree.
1:eac0369: 		 */
1:3bb140c:         childResult = childResult.optimize(dataDictionary,
2:3bb140c:                                            predicates,
1:3bb140c:                                            outerRows);
1:eac0369: 
1:eac0369: 		// RESOLVE: NEED TO FACTOR IN COST OF SORTING AND FIGURE OUT HOW
1:eac0369: 		// MANY ROWS HAVE BEEN ELIMINATED.
1:11f7ee3:         setCostEstimate( getOptimizerFactory().getCostEstimate() );
1:eac0369: 
1:11f7ee3: 		getCostEstimate().setCost(childResult.getCostEstimate().getEstimatedCost(),
1:eac0369: 							childResult.getCostEstimate().rowCount(),
1:eac0369: 							childResult.getCostEstimate().singleScanRowCount());
1:eac0369: 
1:eac0369: 		return this;
1:eac0369: 	}
1:eac0369: 
1:3bb140c:     @Override
1:6c000e8: 	ResultColumnDescriptor[] makeResultDescriptors()
1:eac0369: 	{
1:6c000e8: 	    return childResult.makeResultDescriptors();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return whether or not the underlying ResultSet tree will return
1:eac0369: 	 * a single row, at most.
1:eac0369: 	 * This is important for join nodes where we can save the extra next
1:eac0369: 	 * on the right side if we know that it will return at most 1 row.
1:eac0369: 	 *
1:eac0369: 	 * @return Whether or not the underlying ResultSet tree will return a single row.
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     boolean isOneRowResultSet() throws StandardException
1:eac0369: 	{
1:eac0369: 		// Only consider scalar aggregates for now
1:eac0369: 		return ((groupingList == null) ||  (groupingList.size() == 0));
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * generate the sort result set operating over the source
1:3bb140c:      * result set.  Adds distinct aggregates to the sort if
1:eac0369: 	 * necessary.
1:eac0369:      *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369:      */
1:3bb140c:     @Override
1:8fe3166:     void generate(ActivationClassBuilder acb, MethodBuilder mb)
1:eac0369: 							throws StandardException
1:eac0369: 	{
1:eac0369: 		FormatableArrayHolder	orderingHolder;
1:eac0369: 
1:eac0369: 		/* Get the next ResultSet#, so we can number this ResultSetNode, its
1:eac0369: 		 * ResultColumnList and ResultSet.
1:eac0369: 		 */
1:eac0369: 		assignResultSetNumber();
1:eac0369: 
1:ab10884: 		// Get the final cost estimate from the child.
1:11f7ee3: 		setCostEstimate( childResult.getFinalCostEstimate() );
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** Get the column ordering for the sort.  Note that
1:eac0369: 		** for a scalar aggegate we may not have any ordering
1:eac0369: 		** columns (if there are no distinct aggregates).
1:eac0369: 		** WARNING: if a distinct aggregate is passed to
1:eac0369: 		** SortResultSet it assumes that the last column
1:eac0369: 		** is the distinct one.  If this assumption changes
1:eac0369: 		** then SortResultSet will have to change.
1:eac0369: 		*/
1:eac0369: 		orderingHolder = acb.getColumnOrdering(groupingList);
1:eac0369: 		if (addDistinctAggregate)
1:eac0369: 		{
1:eac0369: 			orderingHolder = acb.addColumnToOrdering(
1:eac0369: 									orderingHolder,
1:eac0369: 									addDistinctAggregateColumnNum);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			if (SanityManager.DEBUG_ON("AggregateTrace"))
1:eac0369: 			{
1:3bb140c:                 StringBuilder s = new StringBuilder();
1:eac0369: 					
1:eac0369: 				s.append("Group by column ordering is (");
1:473d692:                 ColumnOrdering[] ordering =
1:473d692:                         orderingHolder.getArray(ColumnOrdering[].class);
1:eac0369: 
1:eac0369: 				for (int i = 0; i < ordering.length; i++)	
1:eac0369: 				{
1:eac0369: 					s.append(ordering[i].getColumnId());
1:eac0369: 					s.append(" ");
1:eac0369: 				}
1:eac0369: 				s.append(")");
1:eac0369: 				SanityManager.DEBUG("AggregateTrace", s.toString());
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:3bb140c:         int orderingItem = acb.addItem(orderingHolder);
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** We have aggregates, so save the aggInfo
1:eac0369: 		** struct in the activation and store the number
1:eac0369: 		*/
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(aggInfo != null,
1:eac0369: 					"aggInfo not set up as expected");
1:eac0369: 		}
1:3bb140c:         int aggInfoItem = acb.addItem(aggInfo);
1:eac0369: 
1:eac0369: 		acb.pushGetResultSetFactoryExpression(mb);
1:eac0369: 
1:eac0369: 		// Generate the child ResultSet
1:eac0369: 		childResult.generate(acb, mb);
1:eac0369: 		mb.push(isInSortedOrder);
1:eac0369: 		mb.push(aggInfoItem);
1:eac0369: 		mb.push(orderingItem);
1:eac0369: 
1:11f7ee3:         mb.push(acb.addItem(getResultColumns().buildRowTemplate()));
1:eac0369: 
1:11f7ee3: 		mb.push(getResultColumns().getTotalColumnSize());
1:11f7ee3: 		mb.push(getResultSetNumber());
1:eac0369: 
1:eac0369: 		/* Generate a (Distinct)ScalarAggregateResultSet if scalar aggregates */
1:eac0369: 		if ((groupingList == null) ||  (groupingList.size() == 0))
1:eac0369: 		{
1:eac0369: 			genScalarAggregateResultSet(acb, mb);
1:eac0369: 		}
1:eac0369: 		/* Generate a (Distinct)GroupedAggregateResultSet if grouped aggregates */
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			genGroupedAggregateResultSet(acb, mb);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Generate the code to evaluate scalar aggregates.
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 	private	void genScalarAggregateResultSet(ActivationClassBuilder acb,
2:eac0369: 												   MethodBuilder mb)
1:eac0369: 	{
1:eac0369: 		/* Generate the (Distinct)ScalarAggregateResultSet:
1:eac0369: 		 *	arg1: childExpress - Expression for childResult
1:eac0369: 		 *  arg2: isInSortedOrder - true if source result set in sorted order
1:eac0369: 		 *  arg3: aggregateItem - entry in saved objects for the aggregates,
1:eac0369: 		 *  arg4: orderItem - entry in saved objects for the ordering
1:eac0369: 		 *  arg5: Activation
1:eac0369: 		 *  arg6: rowAllocator - method to construct rows for fetching
1:eac0369: 		 *			from the sort
1:eac0369: 		 *  arg7: row size
1:eac0369: 		 *  arg8: resultSetNumber
1:eac0369: 		 *  arg9: Whether or not to perform min optimization.
1:eac0369: 		 */
1:eac0369: 		String resultSet = (addDistinctAggregate) ? "getDistinctScalarAggregateResultSet" : "getScalarAggregateResultSet";
1:eac0369: 
1:eac0369: 		mb.push(singleInputRowOptimization);
1:11f7ee3: 		mb.push(getCostEstimate().rowCount());
1:11f7ee3: 		mb.push(getCostEstimate().getEstimatedCost());
1:eac0369: 
1:9e6e461: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, resultSet,
1:9e6e461:                 ClassName.NoPutResultSet, 10);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Generate the code to evaluate grouped aggregates.
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 	private	void genGroupedAggregateResultSet(ActivationClassBuilder acb,
1:eac0369: 												   MethodBuilder mb)
1:eac0369: 				throws StandardException
1:eac0369: 	{
1:eac0369: 		/* Generate the (Distinct)GroupedAggregateResultSet:
1:eac0369: 		 *	arg1: childExpress - Expression for childResult
1:eac0369: 		 *  arg2: isInSortedOrder - true if source result set in sorted order
1:eac0369: 		 *  arg3: aggregateItem - entry in saved objects for the aggregates,
1:eac0369: 		 *  arg4: orderItem - entry in saved objects for the ordering
1:eac0369: 		 *  arg5: Activation
1:eac0369: 		 *  arg6: rowAllocator - method to construct rows for fetching
1:eac0369: 		 *			from the sort
1:eac0369: 		 *  arg7: row size
1:eac0369: 		 *  arg8: resultSetNumber
1:b5105f3: 		 *  arg9: isRollup
1:eac0369: 		 */
1:eac0369: 		String resultSet = (addDistinctAggregate) ? "getDistinctGroupedAggregateResultSet" : "getGroupedAggregateResultSet";
1:eac0369:     
1:11f7ee3: 		mb.push(getCostEstimate().rowCount());
1:11f7ee3: 		mb.push(getCostEstimate().getEstimatedCost());
1:b5105f3: 		mb.push(groupingList.isRollup());
1:eac0369: 
1:9e6e461: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, resultSet,
1:b5105f3:                 ClassName.NoPutResultSet, 10);
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	///////////////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	// UTILITIES
1:eac0369: 	//
1:eac0369: 	///////////////////////////////////////////////////////////////
1:eac0369: 	/**
1:eac0369: 	 * Method for creating a new result column referencing
1:eac0369: 	 * the one passed in.
1:eac0369: 	 *
1:eac0369: 	 * @param	targetRC	the source
1:eac0369: 	 * @param	dd
1:eac0369: 	 *
1:eac0369: 	 * @return the new result column
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException	on error
1:eac0369: 	 */
1:eac0369: 	private ResultColumn getColumnReference(ResultColumn targetRC, 
1:eac0369: 								DataDictionary		dd)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		ColumnReference	tmpColumnRef;
1:eac0369: 		ResultColumn	newRC;
1:eac0369: 	
1:3bb140c:         tmpColumnRef = new ColumnReference(targetRC.getName(),
1:3bb140c:                                            null,
1:3bb140c:                                            getContextManager());
1:eac0369: 		tmpColumnRef.setSource(targetRC);
1:eac0369: 		tmpColumnRef.setNestingLevel(this.getLevel());
1:eac0369: 		tmpColumnRef.setSourceLevel(this.getLevel());
1:3bb140c:        newRC = new ResultColumn(
1:3bb140c:                 targetRC.getColumnName(),
1:3bb140c:                 tmpColumnRef,
1:3bb140c:                 getContextManager());
1:eac0369: 		newRC.markGenerated();
1:eac0369: 		newRC.bindResultColumnToExpression();
1:eac0369: 		return newRC;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Consider any optimizations after the optimizer has chosen a plan.
1:eac0369: 	 * Optimizations include:
1:eac0369: 	 *	o  min optimization for scalar aggregates
1:eac0369: 	 *	o  max optimization for scalar aggregates
1:eac0369: 	 *
1:eac0369: 	 * @param selectHasPredicates true if SELECT containing this
1:eac0369: 	 *		vector/scalar aggregate has a restriction
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException	on error
1:eac0369: 	 */
1:eac0369: 	void considerPostOptimizeOptimizations(boolean selectHasPredicates)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		/* Consider the optimization for min with asc index on that column or
1:eac0369: 		 * max with desc index on that column:
1:eac0369: 		 *	o  No group by
1:eac0369: 		 *  o  One of:
1:eac0369: 		 *		o  min/max(ColumnReference) is only aggregate && source is 
1:eac0369: 		 *		   ordered on the ColumnReference
1:eac0369: 		 *		o  min/max(ConstantNode)
1:eac0369: 		 * The optimization of the other way around (min with desc index or
1:eac0369: 		 * max with asc index) has the same restrictions with the additional
1:eac0369: 		 * temporary restriction of no qualifications at all (because
1:eac0369: 		 * we don't have true backward scans).
1:eac0369: 		 */
1:eac0369: 		if (groupingList == null)
1:eac0369: 		{
1:09c2697:             if (aggregates.size() == 1)
1:eac0369: 			{
1:3bb140c:                 AggregateNode an = aggregates.get(0);
1:eac0369: 				AggregateDefinition ad = an.getAggregateDefinition();
1:eac0369: 				if (ad instanceof MaxMinAggregateDefinition)
1:eac0369: 				{
1:eac0369: 					if (an.getOperand() instanceof ColumnReference)
1:eac0369: 					{
1:eac0369: 						/* See if the underlying ResultSet tree
1:eac0369: 						 * is ordered on the ColumnReference.
1:eac0369: 						 */
1:1c6c2e8:                         ColumnReference[] crs = {
1:1c6c2e8:                             (ColumnReference) an.getOperand()
1:1c6c2e8:                         };
1:1c6c2e8: 
1:1c6c2e8:                         // Holder list for the FromBaseTable. We expect no more
1:1c6c2e8:                         // than one table, hence initial capacity is 1.
1:71c8e86:                         ArrayList<FromBaseTable> fbtHolder = new ArrayList<FromBaseTable>(1);
1:1c6c2e8: 
1:b153b24:                         boolean minMaxOptimizationPossible = isOrderedOn(crs, false, fbtHolder);
1:eac0369: 						if (SanityManager.DEBUG)
1:eac0369: 						{
1:b153b24:                             SanityManager.ASSERT(fbtHolder.size() <= 1,
1:b153b24:                                 "bad number of FromBaseTables returned by isOrderedOn() -- " +
1:b153b24:                                 fbtHolder.size());
1:eac0369: 						}
1:eac0369: 
1:eac0369: 						if (minMaxOptimizationPossible)
1:eac0369: 						{
1:eac0369: 							boolean ascIndex = true;
1:eac0369: 							int colNum = crs[0].getColumnNumber();
1:eac0369: 							
1:eac0369: 							/* Check if we have an access path, this will be
1:57191b4: 							 * null in a join case (See Beetle 4423,DERBY-3904)
1:eac0369: 							 */
1:eac0369: 							AccessPath accessPath= getTrulyTheBestAccessPath();
1:57191b4: 							if (accessPath == null ||
1:57191b4: 								accessPath.getConglomerateDescriptor()==null||
1:57191b4: 								accessPath.getConglomerateDescriptor().
1:57191b4: 								           getIndexDescriptor() == null)
1:eac0369: 								return;
1:eac0369: 							IndexDescriptor id = accessPath.
1:eac0369: 												getConglomerateDescriptor().
1:eac0369: 												getIndexDescriptor();
1:eac0369: 							int[] keyColumns = id.baseColumnPositions();
1:eac0369: 							boolean[] isAscending = id.isAscending();
1:eac0369: 							for (int i = 0; i < keyColumns.length; i++)
1:eac0369: 							{
1:eac0369: 								/* in such a query: select min(c3) from
1:eac0369: 								 * tab1 where c1 = 2 and c2 = 5, if prefix keys
1:eac0369: 								 * have equality operator, then we can still use
1:eac0369: 								 * the index.  The checking of equality operator
1:eac0369: 								 * has been done in isStrictlyOrderedOn.
1:eac0369: 								 */
1:eac0369: 								if (colNum == keyColumns[i])
1:eac0369: 								{
1:eac0369: 									if (! isAscending[i])
1:eac0369: 										ascIndex = false;
1:eac0369: 									break;
1:eac0369: 								}
1:eac0369: 							}
1:eac0369: 
1:3bb140c:                             FromBaseTable fbt = fbtHolder.get(0);
1:eac0369: 							MaxMinAggregateDefinition temp = (MaxMinAggregateDefinition)ad;
1:eac0369: 
1:eac0369: 							/*  MAX   ASC      NULLABLE 
1:eac0369:                              *  ----  ----------
1:eac0369: 							 *  TRUE  TRUE      TRUE/FALSE  =  Special Last Key Scan (ASC Index Last key with null skips)
1:eac0369: 							 *  TRUE  FALSE     TRUE/FALSE  =  JustDisableBulk(DESC index 1st key with null skips)
1:eac0369: 							 *  FALSE TRUE      TRUE/FALSE  = JustDisableBulk(ASC index 1st key)
1:eac0369: 							 *  FALSE FALSE     TRUE/FALSE  = Special Last Key Scan(Desc Index Last Key)
1:eac0369: 							 */
1:eac0369: 
1:eac0369: 							if (((!temp.isMax()) && ascIndex) || 
1:eac0369: 								((temp.isMax()) && !ascIndex))
1:eac0369: 							{
1:eac0369: 								fbt.disableBulkFetch();
1:eac0369: 								singleInputRowOptimization = true;
1:eac0369: 							}
1:eac0369: 							/*
1:eac0369: 							** Max optimization with asc index or min with
1:eac0369: 							** desc index is currently more
1:eac0369: 							** restrictive than otherwise.
1:eac0369: 							** We are getting the store to return the last
1:eac0369: 							** row from an index (for the time being, the
1:eac0369: 							** store cannot do real backward scans).  SO
1:eac0369: 							** we cannot do this optimization if we have
1:eac0369: 							** any predicates at all.
1:eac0369: 							*/
1:eac0369: 							else if (!selectHasPredicates && 
1:eac0369: 									 ((temp.isMax() && ascIndex) || 
1:eac0369: 									  (!temp.isMax() && !ascIndex )))
1:eac0369: 							{
1:eac0369: 								fbt.disableBulkFetch();
1:eac0369: 								fbt.doSpecialMaxScan();
1:eac0369: 								singleInputRowOptimization = true;
1:eac0369: 							}
1:eac0369: 						}
1:eac0369: 					}
1:eac0369: 					else if (an.getOperand() instanceof ConstantNode)
1:eac0369: 					{
1:eac0369: 						singleInputRowOptimization = true;
1:eac0369: 					}
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:31d80c0: 	 * Comparator class for GROUP BY expression substitution.
1:31d80c0: 	 *
1:31d80c0: 	 * This class enables the sorting of a collection of
1:31d80c0: 	 * SubstituteExpressionVisitor instances. We sort the visitors
1:31d80c0: 	 * during the tree manipulation processing in order to process
1:31d80c0: 	 * expressions of higher complexity prior to expressions of
1:31d80c0: 	 * lower complexity. Processing the expressions in this order ensures
1:31d80c0: 	 * that we choose the best match for an expression, and thus avoids
1:31d80c0: 	 * problems where we substitute a sub-expression instead of the
1:31d80c0: 	 * full expression. For example, if the statement is:
1:31d80c0: 	 *   ... GROUP BY a+b, a, a*(a+b), a+b+c
1:31d80c0: 	 * we'll process those expressions in the order: a*(a+b),
1:31d80c0: 	 * a+b+c, a+b, then a.
1:31d80c0: 	 */
1:3bb140c:     private static class ExpressionSorter
1:3bb140c:         implements Comparator<SubstituteExpressionVisitor>
1:31d80c0: 	{
1:71c8e86: 		public int compare(SubstituteExpressionVisitor o1, SubstituteExpressionVisitor o2)
1:31d80c0: 		{
1:31d80c0: 			try {
1:71c8e86: 				ValueNode v1 = o1.getSource();
1:71c8e86: 				ValueNode v2 = o2.getSource();
1:31d80c0: 				int refCount1, refCount2;
1:a6d25cd:                 CollectNodesVisitor<ColumnReference> vis =
1:a6d25cd:                     new CollectNodesVisitor<ColumnReference>(
1:31d80c0:                         ColumnReference.class);
1:31d80c0: 				v1.accept(vis);
1:31d80c0: 				refCount1 = vis.getList().size();
1:a6d25cd:                 vis = new CollectNodesVisitor<ColumnReference>(
2:a6d25cd:                         ColumnReference.class);
1:31d80c0: 				v2.accept(vis);
1:31d80c0: 				refCount2 = vis.getList().size();
1:31d80c0: 				// The ValueNode with the larger number of refs
1:31d80c0: 				// should compare lower. That way we are sorting
1:31d80c0: 				// the expressions in descending order of complexity.
1:31d80c0: 				return refCount2 - refCount1;
1:31d80c0: 			}
1:31d80c0: 			catch (StandardException e)
1:31d80c0: 			{
1:31d80c0: 				throw new RuntimeException(e);
1:31d80c0: 			}
1:31d80c0: 		}
1:31d80c0: 	}
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1:  * <LI> agg(distinct x) group by x =&gt; agg(x) group by x (for min and max) </LI>
/////////////////////////////////////////////////////////////////////////
1: 	    ProjectRestrictNode RCL -&gt; (ptr to GBN(column[0]), ptr to GBN(column[1]), ptr to GBN(column[4]))
1: 	    GroupByNode RCL-&gt;(C1, SUM(C2), &lt;agg-input&gt;, <aggregator>, MAX(C3), &lt;agg-input&gt;, &lt;aggregator&gt;)
1: 	    ProjectRestrict RCL-&gt;(C1, C2, C3)
commit:11f7ee3
/////////////////////////////////////////////////////////////////////////
1: 		setResultColumns( childResult.getResultColumns() );
/////////////////////////////////////////////////////////////////////////
1:                     getResultColumns().setNullability(true);
/////////////////////////////////////////////////////////////////////////
1:         for (ResultColumn rc : getResultColumns())
/////////////////////////////////////////////////////////////////////////
1: 		rclNew.copyOrderBySelect(getResultColumns());
/////////////////////////////////////////////////////////////////////////
1:         setResultColumns( new ResultColumnList((getContextManager())) );
/////////////////////////////////////////////////////////////////////////
1: 		ResultColumnList groupByRCL = getResultColumns();
/////////////////////////////////////////////////////////////////////////
1: 		ResultColumnList groupByRCL = getResultColumns();
/////////////////////////////////////////////////////////////////////////
1:         setCostEstimate( getOptimizerFactory().getCostEstimate() );
1: 		getCostEstimate().setCost(childResult.getCostEstimate().getEstimatedCost(),
/////////////////////////////////////////////////////////////////////////
1: 		setCostEstimate( childResult.getFinalCostEstimate() );
/////////////////////////////////////////////////////////////////////////
1:         mb.push(acb.addItem(getResultColumns().buildRowTemplate()));
1: 		mb.push(getResultColumns().getTotalColumnSize());
1: 		mb.push(getResultSetNumber());
/////////////////////////////////////////////////////////////////////////
1: 		mb.push(getCostEstimate().rowCount());
1: 		mb.push(getCostEstimate().getEstimatedCost());
/////////////////////////////////////////////////////////////////////////
1: 		mb.push(getCostEstimate().rowCount());
1: 		mb.push(getCostEstimate().getEstimatedCost());
commit:6a270cb
/////////////////////////////////////////////////////////////////////////
0:         costEstimate = getOptimizerFactory().getCostEstimate();
commit:a56ecfa
/////////////////////////////////////////////////////////////////////////
0:             (RequiredRowOrdering) null,
0:             null );
commit:71c8e86
/////////////////////////////////////////////////////////////////////////
0: 				isInSortedOrder = childResult.isOrderedOn(crs, true, (List<FromBaseTable>)null);
/////////////////////////////////////////////////////////////////////////
1: 	private ArrayList<SubstituteExpressionVisitor> addUnAggColumns() throws StandardException
1: 		ArrayList<SubstituteExpressionVisitor> referencesToSubstitute = new ArrayList<SubstituteExpressionVisitor>();
1: 		ArrayList<SubstituteExpressionVisitor> havingRefsToSubstitute = null;
1: 			havingRefsToSubstitute = new ArrayList<SubstituteExpressionVisitor>();
/////////////////////////////////////////////////////////////////////////
1: 		ExpressionSorter sorter = new ExpressionSorter();
1: 				referencesToSubstitute.get(r));
/////////////////////////////////////////////////////////////////////////
1: 		ArrayList<SubstituteExpressionVisitor> havingRefsToSubstitute = null;
/////////////////////////////////////////////////////////////////////////
1:                         ArrayList<FromBaseTable> fbtHolder = new ArrayList<FromBaseTable>(1);
/////////////////////////////////////////////////////////////////////////
0: 	private static final class ExpressionSorter implements Comparator<SubstituteExpressionVisitor>
1: 		public int compare(SubstituteExpressionVisitor o1, SubstituteExpressionVisitor o2)
1: 				ValueNode v1 = o1.getSource();
1: 				ValueNode v2 = o2.getSource();
commit:db69e70
/////////////////////////////////////////////////////////////////////////
1: 		ResultColumn	aggResultRC;
/////////////////////////////////////////////////////////////////////////
0: 			aggResultRC = (ResultColumn) getNodeFactory().getNode(
0: 								C_NodeTypes.RESULT_COLUMN,
1: 								"##aggregate expression",
1: 								aggregate.getNewNullResultExpression(),
1: 								getContextManager());
/////////////////////////////////////////////////////////////////////////
1: 			aggRCL.addElement(aggResultRC);
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
commit:b5105f3
/////////////////////////////////////////////////////////////////////////
1: 		if (this.groupingList != null && this.groupingList.isRollup())
1:                 {
0: 			resultColumns.setNullability(true);
1: 			parent.getResultColumns().setNullability(true);
1:                 }
/////////////////////////////////////////////////////////////////////////
1: 				SanityManager.ASSERT(groupingList != null || numDistinct == 1,
/////////////////////////////////////////////////////////////////////////
1: 		 *  arg9: isRollup
1: 		mb.push(groupingList.isRollup());
1:                 ClassName.NoPutResultSet, 10);
commit:57191b4
/////////////////////////////////////////////////////////////////////////
1: 							 * null in a join case (See Beetle 4423,DERBY-3904)
1: 							if (accessPath == null ||
1: 								accessPath.getConglomerateDescriptor()==null||
1: 								accessPath.getConglomerateDescriptor().
1: 								           getIndexDescriptor() == null)
commit:31d80c0
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayList;
1: import java.util.Comparator;
1: import java.util.Collections;
/////////////////////////////////////////////////////////////////////////
0: 		ArrayList referencesToSubstitute = new ArrayList();
0: 		ArrayList havingRefsToSubstitute = null;
1: 		if (havingClause != null)
0: 			havingRefsToSubstitute = new ArrayList();
/////////////////////////////////////////////////////////////////////////
1: 			//
1: 			// Note that we don't perform the replacements
1: 			// immediately, but instead we accumulate them
1: 			// until the end of the loop. This allows us to
1: 			// sort the expressions and process them in
1: 			// descending order of complexity, necessary
1: 			// because a compound expression may contain a
1: 			// reference to a simple grouped column, but in
1: 			// such a case we want to process the expression
1: 			// as an expression, not as individual column
1: 			// references. E.g., if the statement was:
1: 			//   SELECT ... GROUP BY C1, C1 * (C2 / 100), C3
1: 			// then we don't want the replacement of the
1: 			// simple column reference C1 to affect the
1: 			// compound expression C1 * (C2 / 100). DERBY-3094.
1: 			//
1: 			ValueNode vn = gbc.getColumnExpression();
1: 			SubstituteExpressionVisitor vis =
1: 				new SubstituteExpressionVisitor(vn, vc,
1: 			referencesToSubstitute.add(vis);
/////////////////////////////////////////////////////////////////////////
1: 			if (havingClause != null)
1: 			{
1: 					new SubstituteExpressionVisitor(vn,vc,null);
1: 				havingRefsToSubstitute.add(havingSE);
0: 		Comparator sorter = new ExpressionSorter();
1: 		Collections.sort(referencesToSubstitute,sorter);
1: 		for (int r = 0; r < referencesToSubstitute.size(); r++)
1: 			parent.getResultColumns().accept(
0: 				(SubstituteExpressionVisitor)referencesToSubstitute.get(r));
1: 		if (havingRefsToSubstitute != null)
1: 		{
1: 			Collections.sort(havingRefsToSubstitute,sorter);
0: 			for (int r = 0; r < havingRefsToSubstitute.size(); r++)
0: 				havingClause.accept(
0: 					(SubstituteExpressionVisitor)havingRefsToSubstitute.get(r));
1: }
/////////////////////////////////////////////////////////////////////////
1: 
1: 	/**
1: 	 * Comparator class for GROUP BY expression substitution.
1: 	 *
1: 	 * This class enables the sorting of a collection of
1: 	 * SubstituteExpressionVisitor instances. We sort the visitors
1: 	 * during the tree manipulation processing in order to process
1: 	 * expressions of higher complexity prior to expressions of
1: 	 * lower complexity. Processing the expressions in this order ensures
1: 	 * that we choose the best match for an expression, and thus avoids
1: 	 * problems where we substitute a sub-expression instead of the
1: 	 * full expression. For example, if the statement is:
1: 	 *   ... GROUP BY a+b, a, a*(a+b), a+b+c
1: 	 * we'll process those expressions in the order: a*(a+b),
1: 	 * a+b+c, a+b, then a.
1: 	 */
0: 	private static final class ExpressionSorter implements Comparator
1: 	{
0: 		public int compare(Object o1, Object o2)
1: 		{
1: 			try {
0: 				ValueNode v1 = ((SubstituteExpressionVisitor)o1).getSource();
0: 				ValueNode v2 = ((SubstituteExpressionVisitor)o2).getSource();
1: 				int refCount1, refCount2;
0: 				CollectNodesVisitor vis = new CollectNodesVisitor(
1: 				ColumnReference.class);
1: 				v1.accept(vis);
1: 				refCount1 = vis.getList().size();
0: 				vis = new CollectNodesVisitor(ColumnReference.class);
1: 				v2.accept(vis);
1: 				refCount2 = vis.getList().size();
1: 				// The ValueNode with the larger number of refs
1: 				// should compare lower. That way we are sorting
1: 				// the expressions in descending order of complexity.
1: 				return refCount2 - refCount1;
1: 			}
1: 			catch (StandardException e)
1: 			{
1: 				throw new RuntimeException(e);
1: 			}
1: 		}
1: 	}
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:2706d1f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:e1f49ca
/////////////////////////////////////////////////////////////////////////
1:     final private boolean isInSortedOrder;
/////////////////////////////////////////////////////////////////////////
1:                 GroupByColumn gc = this.groupingList.elementAt(index);
1: 
1:             isInSortedOrder = (index == glSize) &&
1:                 childResult.isOrderedOn(crs, true, (List<FromBaseTable>)null);
1:         } else {
1:             isInSortedOrder = false;
1:         }
/////////////////////////////////////////////////////////////////////////
1: 
0:         for (ResultColumn rc : resultColumns)
/////////////////////////////////////////////////////////////////////////
1: 
1:         for (GroupByColumn gbc : groupingList)
/////////////////////////////////////////////////////////////////////////
1:         ((Optimizable) childResult).optimizeIt( optimizer,
1:                                                 predList,
1:                                                 outerCost,
1:                                                 rowOrdering);
1:         CostEstimate retval = super.optimizeIt( optimizer,
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
0: import java.util.Comparator;
1: import org.apache.derby.iapi.services.context.ContextManager;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: class GroupByNode extends SingleChildResultSetNode
/////////////////////////////////////////////////////////////////////////
1:     private List<AggregateNode> aggregates;
/////////////////////////////////////////////////////////////////////////
1:      * Constructor for a GroupByNode.
1:      * @param bottomPR      The child FromTable
1:      * @param havingClause  The having clause.
1:      * @param nestingLevel  NestingLevel of this group by node. This is used for
1:      * @param cm            The context manager
1:     GroupByNode(ResultSetNode  bottomPR,
1:                 GroupByList    groupingList,
1:                 List<AggregateNode> aggregates,
1:                 ValueNode      havingClause,
1:                 SubqueryList   havingSubquerys,
1:                 int            nestingLevel,
1:                 ContextManager cm)
1:         super(bottomPR, null /* tableProperties */, cm);
0:         setNodeType(C_NodeTypes.GROUP_BY_NODE);
1:         setLevel(nestingLevel);
1:         this.havingClause = havingClause;
1:         this.havingSubquerys = havingSubquerys;
1:             // Aggregates can be null if we have a having clause.
1:             // select c1 from t1 group by c1 having c1 > 1;
1:             // SanityManager.ASSERT(((List) aggregates).size() > 0,
1:             // "aggregates expected to be non-empty");
/////////////////////////////////////////////////////////////////////////
1:         this.groupingList = groupingList;
1:         this.aggregates = aggregates;
/////////////////////////////////////////////////////////////////////////
1:                 agg = aggInfo.elementAt(i);
/////////////////////////////////////////////////////////////////////////
1:         ResultColumnList rclNew = new ResultColumnList((getContextManager()));
/////////////////////////////////////////////////////////////////////////
1:         parent = new ProjectRestrictNode(
/////////////////////////////////////////////////////////////////////////
1:         childResult.setResultColumns(new ResultColumnList(getContextManager()));
0:         resultColumns = new ResultColumnList((getContextManager()));
/////////////////////////////////////////////////////////////////////////
1:             ResultColumn newRC = new ResultColumn(
1:                     "##UnaggColumn",
/////////////////////////////////////////////////////////////////////////
1:             ResultColumn gbRC = new ResultColumn(
1:                     "##UnaggColumn",
1: 
1:             groupByRCL.addElement(gbRC);
/////////////////////////////////////////////////////////////////////////
1:             VirtualColumnNode vc = new VirtualColumnNode(
1:                     groupByRCL.size(),
/////////////////////////////////////////////////////////////////////////
1:                     havingClause.accept(havingRefsToSubstitute.get(r));
/////////////////////////////////////////////////////////////////////////
1:                     new ResultColumnList((getContextManager())),
/////////////////////////////////////////////////////////////////////////
1:                     new ResultColumnList((getContextManager())),
/////////////////////////////////////////////////////////////////////////
1:             AggregateNode aggregate = aggregates.get(index);
1:             newRC = new ResultColumn(
1:                     "##aggregate result",
/////////////////////////////////////////////////////////////////////////
1:             newColumnRef = new ColumnReference(newRC.getName(),
1:                                                null,
1:                                                getContextManager());
1:            tmpRC = new ResultColumn(
/////////////////////////////////////////////////////////////////////////
1:            aggResultRC = new ResultColumn(
0:                     "##aggregate expression",
1:                     aggregate.getNewNullResultExpression(),
1:                     getContextManager());
/////////////////////////////////////////////////////////////////////////
1:             aggRCL = new ResultColumnList((getContextManager()));
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:         CostEstimate costEst = getCostEstimate(optimizer);
1:         costEst.setCost(childCost.getEstimatedCost(),
1:         return costEst;
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     void printSubNodes(int depth) {
/////////////////////////////////////////////////////////////////////////
1:                 AggregateNode agg = aggregates.get(i);
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     boolean flattenableInFromSubquery(FromList fromList)
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     ResultSetNode optimize(DataDictionary dataDictionary,
/////////////////////////////////////////////////////////////////////////
1:         childResult = childResult.optimize(dataDictionary,
1:                                            predicates,
1:                                            outerRows);
0:         Optimizer opt = getOptimizer(
0:             new FromList(getOptimizerFactory().doJoinOrderOptimization(),
0:                          getContextManager()),
1:             predicates,
0:             dataDictionary,
0:             (RequiredRowOrdering) null);
0:         costEstimate = opt.newCostEstimate();
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     boolean isOneRowResultSet() throws StandardException
/////////////////////////////////////////////////////////////////////////
1:      * result set.  Adds distinct aggregates to the sort if
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:                 StringBuilder s = new StringBuilder();
/////////////////////////////////////////////////////////////////////////
1:         int orderingItem = acb.addItem(orderingHolder);
/////////////////////////////////////////////////////////////////////////
1:         int aggInfoItem = acb.addItem(aggInfo);
/////////////////////////////////////////////////////////////////////////
1:         tmpColumnRef = new ColumnReference(targetRC.getName(),
1:                                            null,
1:                                            getContextManager());
1:        newRC = new ResultColumn(
1:                 targetRC.getColumnName(),
1:                 tmpColumnRef,
1:                 getContextManager());
/////////////////////////////////////////////////////////////////////////
1:                 AggregateNode an = aggregates.get(0);
/////////////////////////////////////////////////////////////////////////
1:                             FromBaseTable fbt = fbtHolder.get(0);
/////////////////////////////////////////////////////////////////////////
1:     private static class ExpressionSorter
1:         implements Comparator<SubstituteExpressionVisitor>
commit:7a9ce7e
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 				if ( ! (cr.getGeneratedToReplaceAggregate() ||
1: 						cr.getGeneratedToReplaceWindowFunctionCall()) &&
1: 					 cr.getSourceLevel() == level) {
commit:c9a1206
/////////////////////////////////////////////////////////////////////////
1: 				super.toString();
/////////////////////////////////////////////////////////////////////////
1: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
1: 	 * how tree printing is supposed to work.
1: 	 *
1: 	 * @param depth		The depth of this node in the tree
1: 	 */
0: 	public void printSubNodes(int depth) {
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			super.printSubNodes(depth);
1: 
0: 			printLabel(depth, "aggregateVector:\n");
1: 
0: 			for (int i=0; i < aggregateVector.size(); i++) {
0: 					AggregateNode agg =
0: 						(AggregateNode)aggregateVector.elementAt(i);
1: 					debugPrint(formatNodeString("[" + i + "]:", depth + 1));
1: 					agg.treePrint(depth + 1);
1: 			}
1: 
1: 			if (groupingList != null) {
1: 				printLabel(depth, "groupingList: ");
1: 				groupingList.treePrint(depth + 1);
1: 			}
1: 
1: 			if (havingClause != null)
1: 			{
1: 				printLabel(depth, "havingClause: ");
1: 				havingClause.treePrint(depth + 1);
1: 			}
1: 
1: 			if (havingSubquerys != null)
1: 			{
1: 				printLabel(depth, "havingSubqueries: ");
1: 				havingSubquerys.treePrint(depth + 1);
1: 			}
1: 		}
1: 	}
1: 
1: 	/**
commit:c00561a
/////////////////////////////////////////////////////////////////////////
1: 	 * In the query rewrite for group by, add the columns on which we are doing
1: 	 * the group by.
1: 	 *
1: 	 * @return havingRefsToSubstitute visitors array. Return any
1: 	 *         havingRefsToSubstitute visitors since it is too early to apply
1: 	 *         them yet; we need the AggregateNodes unmodified until after
1: 	 *         we add the new columns for aggregation (DERBY-4071).
1: 	 *
0: 	private ArrayList addUnAggColumns() throws StandardException
/////////////////////////////////////////////////////////////////////////
1: 			// DERBY-4071 Don't substitute quite yet; we need the AggrateNodes
1: 			// undisturbed until after we have had the chance to build the
1: 			// other columns.  (The AggrateNodes are shared via an alias from
0: 			// aggregateVector and from the expression tree under
0: 			// havingClause).
1: 		}
1: 		return havingRefsToSubstitute;
/////////////////////////////////////////////////////////////////////////
0: 		ArrayList havingRefsToSubstitute = null;
1: 
1: 			havingRefsToSubstitute = addUnAggColumns();
1: 
1: 		addAggregateColumns();
1: 
1: 
1: 			// Now do the substitution of the group by expressions in the
1: 			// having clause.
1: 			if (havingRefsToSubstitute != null) {
1: 				for (int r = 0; r < havingRefsToSubstitute.size(); r++) {
0: 					havingClause.accept(
0: 						(SubstituteExpressionVisitor)havingRefsToSubstitute.get(r));
1: 				}
1: 			}
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 			** ReplaceAggregatesWithCRVisitor()
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:473d692
/////////////////////////////////////////////////////////////////////////
1:                 ColumnOrdering[] ordering =
1:                         orderingHolder.getArray(ColumnOrdering[].class);
commit:a6d25cd
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             CollectNodesVisitor<ColumnReference> collectNodesVisitor =
1:                 new CollectNodesVisitor<ColumnReference>(
1:                     ColumnReference.class, AggregateNode.class);
1:             for (ColumnReference cr: collectNodesVisitor.getList())
/////////////////////////////////////////////////////////////////////////
1:                 CollectNodesVisitor<ColumnReference> vis =
1:                     new CollectNodesVisitor<ColumnReference>(
1:                         ColumnReference.class);
1:                 vis = new CollectNodesVisitor<ColumnReference>(
1:                         ColumnReference.class);
commit:9f2ed7d
/////////////////////////////////////////////////////////////////////////
1:     final FromTable getParent()
commit:8fe3166
/////////////////////////////////////////////////////////////////////////
1:     void generate(ActivationClassBuilder acb, MethodBuilder mb)
commit:b153b24
/////////////////////////////////////////////////////////////////////////
0:                         ArrayList fbtHolder = new ArrayList(1);
1:                         boolean minMaxOptimizationPossible = isOrderedOn(crs, false, fbtHolder);
1:                             SanityManager.ASSERT(fbtHolder.size() <= 1,
1:                                 "bad number of FromBaseTables returned by isOrderedOn() -- " +
1:                                 fbtHolder.size());
/////////////////////////////////////////////////////////////////////////
0:                                     (FromBaseTable) fbtHolder.get(0);
commit:09c2697
/////////////////////////////////////////////////////////////////////////
0:     private List aggregates;
/////////////////////////////////////////////////////////////////////////
1:      * @param aggregates    The list of aggregates from
/////////////////////////////////////////////////////////////////////////
0:                         Object aggregates,
/////////////////////////////////////////////////////////////////////////
0: //          Aggregates can be null if we have a having clause.
0: //          SanityManager.ASSERT(((List) aggregates).size() > 0,
0: //          "aggregates expected to be non-empty");
/////////////////////////////////////////////////////////////////////////
0:         this.aggregates = (List) aggregates;
/////////////////////////////////////////////////////////////////////////
1:         int numDistinct = numDistinctAggregates(aggregates);
/////////////////////////////////////////////////////////////////////////
1:             // aggregates and from the expression tree under havingClause).
/////////////////////////////////////////////////////////////////////////
1:      * For each aggregate in {@code aggregates} <UL>
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         int alSize = aggregates.size();
0:             AggregateNode aggregate = (AggregateNode) aggregates.get(index);
/////////////////////////////////////////////////////////////////////////
1:             printLabel(depth, "aggregates:\n");
1:             for (int i = 0; i < aggregates.size(); i++) {
0:                 AggregateNode agg = (AggregateNode) aggregates.get(i);
0:                 debugPrint(formatNodeString("[" + i + "]:", depth + 1));
0:                 agg.treePrint(depth + 1);
1:             }
/////////////////////////////////////////////////////////////////////////
1:             if (aggregates.size() == 1)
0:                 AggregateNode an = (AggregateNode) aggregates.get(0);
commit:1c6c2e8
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 				isInSortedOrder = childResult.isOrderedOn(crs, true, (List)null);
/////////////////////////////////////////////////////////////////////////
1:                         ColumnReference[] crs = {
1:                             (ColumnReference) an.getOperand()
1:                         };
1: 
1:                         // Holder list for the FromBaseTable. We expect no more
1:                         // than one table, hence initial capacity is 1.
0: 						ArrayList tableVector = new ArrayList(1);
1: 
/////////////////////////////////////////////////////////////////////////
1: 
0:                             FromBaseTable fbt =
0:                                     (FromBaseTable) tableVector.get(0);
commit:47d4a4c
/////////////////////////////////////////////////////////////////////////
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
0:     private List aggregateVector;
/////////////////////////////////////////////////////////////////////////
0: //			SanityManager.ASSERT(((List) aggregateVector).size() > 0,
/////////////////////////////////////////////////////////////////////////
0: 		this.aggregateVector = (List) aggregateVector;
commit:bda7291
/////////////////////////////////////////////////////////////////////////
0:         mb.push(acb.addItem(resultColumns.buildRowTemplate()));
commit:d868eed
/////////////////////////////////////////////////////////////////////////
0:         mb.push(acb.addItem(resultColumns.buildRowTemplate(null)));
commit:7af858d
/////////////////////////////////////////////////////////////////////////
0: 		childResult = (ResultSetNode) childResult.optimize(
commit:a32eb9f
/////////////////////////////////////////////////////////////////////////
0: 			aggregate = (AggregateNode) aggregateVector.get(index);
/////////////////////////////////////////////////////////////////////////
0: 						(AggregateNode)aggregateVector.get(i);
/////////////////////////////////////////////////////////////////////////
0: 				AggregateNode an = (AggregateNode) aggregateVector.get(0);
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:ed82406
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:ba1b7ec
/////////////////////////////////////////////////////////////////////////
0: 			newColumnRef.setType(newRC.getExpression().getTypeServices());
/////////////////////////////////////////////////////////////////////////
0: 		tmpColumnRef.setType(targetRC.getExpression().getTypeServices());
commit:8bae7cf
/////////////////////////////////////////////////////////////////////////
0: import java.util.Iterator;
1: import org.apache.derby.iapi.reference.SQLState;
/////////////////////////////////////////////////////////////////////////
commit:6c000e8
/////////////////////////////////////////////////////////////////////////
1: 	ResultColumnDescriptor[] makeResultDescriptors()
1: 	    return childResult.makeResultDescriptors();
commit:4fb136d
/////////////////////////////////////////////////////////////////////////
0: import java.util.Vector;
1: import org.apache.derby.catalog.IndexDescriptor;
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.reference.ClassName;
1: import org.apache.derby.iapi.services.classfile.VMOpcode;
1: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1: import org.apache.derby.iapi.services.io.FormatableArrayHolder;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.sql.LanguageFactory;
1: import org.apache.derby.iapi.sql.ResultColumnDescriptor;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
1: import org.apache.derby.iapi.sql.compile.CostEstimate;
1: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1: import org.apache.derby.iapi.store.access.ColumnOrdering;
commit:3dd03e5
/////////////////////////////////////////////////////////////////////////
commit:9e6e461
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, resultSet,
1:                 ClassName.NoPutResultSet, 10);
/////////////////////////////////////////////////////////////////////////
1: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, resultSet,
0:                 ClassName.NoPutResultSet, 9);
commit:01217c2
/////////////////////////////////////////////////////////////////////////
1: 			int index;
1: 			for (index = 0; index < glSize; index++)
1: 				if (gc.getColumnExpression() instanceof ColumnReference) 
1: 				{
1: 					crs[index] = (ColumnReference)gc.getColumnExpression();
1: 				} 
1: 				else 
1: 				{
0: 					isInSortedOrder = false;
1: 					break;
1: 				}
1: 				
0: 			if (index == glSize) {
0: 				isInSortedOrder = childResult.isOrderedOn(crs, true, (Vector)null);
1: 			}
/////////////////////////////////////////////////////////////////////////
1: 	/**
0: 	 * In the query rewrite for group by, add the columns on which
0: 	 * we are doing the group by.
1: 
1: 	 * @see #addNewColumnsForAggregation
1: 	 */
0: 	private void addUnAggColumns() throws StandardException
1: 	{
1: 		ResultColumnList bottomRCL  = childResult.getResultColumns();
0: 		ResultColumnList groupByRCL = resultColumns;
1: 
0: 		int sz = groupingList.size();
0: 		for (int i = 0; i < sz; i++) 
1: 		{
0: 			GroupByColumn gbc = (GroupByColumn) groupingList.elementAt(i);
0: 			ResultColumn newRC = (ResultColumn) getNodeFactory().getNode(
0: 					C_NodeTypes.RESULT_COLUMN,
0: 					"##UnaggColumn",
1: 					gbc.getColumnExpression(),
1: 					getContextManager());
1: 
1: 			// add this result column to the bottom rcl
1: 			bottomRCL.addElement(newRC);
1: 			newRC.markGenerated();
1: 			newRC.bindResultColumnToExpression();
1: 			newRC.setVirtualColumnId(bottomRCL.size());
1: 			
1: 			// now add this column to the groupbylist
0: 			ResultColumn gbRC = (ResultColumn) getNodeFactory().getNode(
0: 					C_NodeTypes.RESULT_COLUMN,
0: 					"##UnaggColumn",
1: 					gbc.getColumnExpression(),
1: 					getContextManager());
0: 			groupByRCL.addElement(gbRC);
1: 			gbRC.markGenerated();
1: 			gbRC.bindResultColumnToExpression();
1: 			gbRC.setVirtualColumnId(groupByRCL.size());
1: 
1: 			/*
1: 			 ** Reset the original node to point to the
1: 			 ** Group By result set.
1: 			 */
0: 			VirtualColumnNode vc = (VirtualColumnNode) getNodeFactory().getNode(
0: 					C_NodeTypes.VIRTUAL_COLUMN_NODE,
1: 					this, // source result set.
1: 					gbRC,
0: 					new Integer(groupByRCL.size()),
1: 					getContextManager());
1: 
1: 			// we replace each group by expression 
1: 			// in the projection list with a virtual column node
1: 			// that effectively points to a result column 
1: 			// in the result set doing the group by
0: 			SubstituteExpressionVisitor se = 
0: 				new SubstituteExpressionVisitor(
1: 						gbc.getColumnExpression(),
0: 						vc,
1: 						AggregateNode.class);
0: 			parent.getResultColumns().accept(se);
1: 
0: 			// finally reset gbc to its new position.
1: 			gbc.setColumnPosition(bottomRCL.size());
1: 		}
1: 	}
/////////////////////////////////////////////////////////////////////////
1: 		aggInfo = new AggregatorInfoList();
1: 		if (groupingList != null)
1: 		{
0: 			addUnAggColumns();
1: 		}
0: 		addAggregateColumns();
1: 	}
1: 	
1: 	/**
1: 	 * In the query rewrite involving aggregates, add the columns for
1: 	 * aggregation.
1: 	 *
1: 	 * @see #addNewColumnsForAggregation
1: 	 */
1: 	private void addAggregateColumns() throws StandardException
1: 	{
1: 		DataDictionary			dd = getDataDictionary();
/////////////////////////////////////////////////////////////////////////
1: 		 ** Now process all of the aggregates.  Replace
1: 		 ** every aggregate with an RC.  We toss out
1: 		 ** the list of RCs, we need to get each RC
1: 		 ** as we process its corresponding aggregate.
1: 		 */
1: 		LanguageFactory lf = getLanguageConnectionContext().getLanguageFactory();
1: 		
0: 							C_NodeTypes.RESULT_COLUMN_LIST,
0: 							getContextManager()),
0: 				((FromTable) childResult).getTableNumber());
/////////////////////////////////////////////////////////////////////////
0: 					C_NodeTypes.RESULT_COLUMN,
0: 					"##aggregate result",
0: 					aggregate.getNewNullResultExpression(),
1: 					getContextManager());
/////////////////////////////////////////////////////////////////////////
0: 					C_NodeTypes.COLUMN_REFERENCE,
0: 					newRC.getName(),
0: 					null,
1: 					getContextManager());
0: 					C_NodeTypes.RESULT_COLUMN,
1: 					newRC.getColumnName(),
1: 					newColumnRef,
1: 					getContextManager());
/////////////////////////////////////////////////////////////////////////
0: 					C_NodeTypes.RESULT_COLUMN_LIST,
0: 					getContextManager());
/////////////////////////////////////////////////////////////////////////
1: 					aggregate.getAggregateName(),
1: 					aggregate.getAggregatorClassName(),
1: 					aggInputVColId - 1,			// aggregate input column
1: 					aggResultVColId -1,			// the aggregate result column
1: 					aggregatorVColId - 1,		// the aggregator column	
1: 					aggregate.isDistinct(),
1: 					lf.getResultDescription(aggRCL.makeResultDescriptors(), "SELECT")
1: 			));
commit:93ff8cc
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, resultSet, ClassName.NoPutResultSet, 11);
/////////////////////////////////////////////////////////////////////////
0: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, resultSet, ClassName.NoPutResultSet, 10);
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.compile.GroupByNode
1: 
0:    Copyright 1998, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:61070a6
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package	org.apache.derby.impl.sql.compile;
1: 
0: import org.apache.derby.iapi.services.context.ContextManager;
1: 
0: import org.apache.derby.iapi.store.access.ColumnOrdering;
1: 
1: import org.apache.derby.iapi.sql.compile.AccessPath;
1: import org.apache.derby.iapi.sql.compile.Optimizable;
0: import org.apache.derby.iapi.sql.compile.OptimizableList;
1: import org.apache.derby.iapi.sql.compile.OptimizablePredicate;
1: import org.apache.derby.iapi.sql.compile.OptimizablePredicateList;
1: import org.apache.derby.iapi.sql.compile.Optimizer;
0: import org.apache.derby.iapi.sql.compile.CostEstimate;
0: import org.apache.derby.iapi.sql.compile.Visitable;
0: import org.apache.derby.iapi.sql.compile.Visitor;
1: import org.apache.derby.iapi.sql.compile.RequiredRowOrdering;
1: import org.apache.derby.iapi.sql.compile.RowOrdering;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
1: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: import org.apache.derby.iapi.reference.ClassName;
1: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionaryContext;
1: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
0: import org.apache.derby.catalog.IndexDescriptor;
1: 
0: import org.apache.derby.iapi.sql.execute.ExecutionContext;
1: 
0: import org.apache.derby.iapi.sql.Activation; 
0: import org.apache.derby.iapi.sql.LanguageFactory;
0: import org.apache.derby.iapi.sql.ResultColumnDescriptor;
0: import org.apache.derby.iapi.sql.ResultSet;
1: 
0: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.impl.sql.compile.ActivationClassBuilder;
1: import org.apache.derby.impl.sql.execute.AggregatorInfo;
1: import org.apache.derby.impl.sql.execute.AggregatorInfoList;
1: 
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
0: import org.apache.derby.iapi.services.io.FormatableArrayHolder;
0: import org.apache.derby.iapi.util.JBitSet;
1: 
0: import org.apache.derby.impl.sql.compile.MaxMinAggregateDefinition;
0: import org.apache.derby.iapi.services.classfile.VMOpcode;
1: 
0: import java.util.Vector;
0: import java.util.Properties;
1: 
1: 
1: /**
1:  * A GroupByNode represents a result set for a grouping operation
1:  * on a select.  Note that this includes a SELECT with aggregates
1:  * and no grouping columns (in which case the select list is null)
1:  * It has the same description as its input result set.
1:  * <p>
1:  * For the most part, it simply delegates operations to its bottomPRSet,
1:  * which is currently expected to be a ProjectRestrictResultSet generated
1:  * for a SelectNode.
1:  * <p>
1:  * NOTE: A GroupByNode extends FromTable since it can exist in a FromList.
1:  * <p>
1:  * There is a lot of room for optimizations here: <UL>
0:  * <LI> agg(distinct x) group by x => agg(x) group by x (for min and max) </LI>
1:  * <LI> min()/max() use index scans if possible, no sort may 
1:  *		be needed. </LI>
1:  * </UL>
1:  *
0:  * @author jerry, aggregates by jamie
1:  *
1:  */
0: public class GroupByNode extends SingleChildResultSetNode
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
1: 	/**
1: 	 * The GROUP BY list
1: 	 */
1: 	GroupByList groupingList;
1: 
1: 	/**
1: 	 * The list of all aggregates in the query block
1: 	 * that contains this group by.
1: 	 */
0: 	Vector	aggregateVector;
1: 
1: 	/**
1: 	 * Information that is used at execution time to
1: 	 * process aggregates.
1: 	 */
1: 	private AggregatorInfoList	aggInfo;
1: 
1: 	/**
1: 	 * The parent to the GroupByNode.  If we need to
1: 	 * generate a ProjectRestrict over the group by
1: 	 * then this is set to that node.  Otherwise it
1: 	 * is null.
1: 	 */
1: 	FromTable	parent;
1: 
1: 	private boolean	addDistinctAggregate;
1: 	private boolean singleInputRowOptimization;
1: 	private int		addDistinctAggregateColumnNum;
1: 
1: 	// Is the source in sorted order
0: 	private boolean isInSortedOrder;
1: 
1: 	/**
0: 	 * Intializer for a GroupByNode.
1: 	 *
0: 	 * @param bottomPR	The child FromTable
1: 	 * @param groupingList	The groupingList
0: 	 * @param aggregateVector	The vector of aggregates from
1: 	 *		the query block.  Since aggregation is done
1: 	 *		at the same time as grouping, we need them
1: 	 *		here.
0: 	 * @param tableProperties	Properties list associated with the table
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public void init(
0: 						Object  bottomPR,
0: 						Object groupingList,
0: 						Object	aggregateVector,
0: 						Object tableProperties)
1: 			throws StandardException
1: 	{
0: 		super.init(bottomPR, tableProperties);
1: 
1: 		/* Group by without aggregates gets xformed into distinct */
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			SanityManager.ASSERT(((Vector) aggregateVector).size() > 0,
0: 				"aggregateVector expected to be non-empty");
1: 			if (!(childResult instanceof Optimizable))
1: 			{
1: 				SanityManager.THROWASSERT("childResult, " + childResult.getClass().getName() +
1: 					", expected to be instanceof Optimizable");
1: 			}
1: 			if (!(childResult instanceof FromTable))
1: 			{
1: 				SanityManager.THROWASSERT("childResult, " + childResult.getClass().getName() +
1: 					", expected to be instanceof FromTable");
1: 			}
1: 		}
1: 
1: 		ResultColumnList newBottomRCL;
0: 		this.groupingList = (GroupByList) groupingList;
0: 		this.aggregateVector = (Vector) aggregateVector;
1: 		this.parent = this;
1: 
1: 		/*
1: 		** The first thing we do is put ourselves on
1: 		** top of the SELECT.  The select becomes the
1: 		** childResult.  So our RCL becomes its RCL (so
1: 		** nodes above it now point to us).  Map our
1: 		** RCL to its columns.
1: 		*/
1: 		newBottomRCL = childResult.getResultColumns().copyListAndObjects();
0: 		resultColumns = childResult.getResultColumns();
1: 		childResult.setResultColumns(newBottomRCL);
1: 
1: 		/*
1: 		** We have aggregates, so we need to add
1: 		** an extra PRNode and we also have to muck around
1: 		** with our trees a might.
1: 		*/
1: 		addAggregates();
1: 
1: 		/* We say that the source is never in sorted order if there is a distinct aggregate.
1: 		 * (Not sure what happens if it is, so just skip it for now.)
1: 		 * Otherwise, we check to see if the source is in sorted order on any permutation
1: 		 * of the grouping columns.)
1: 		 */
1: 		if (! addDistinctAggregate && groupingList != null)
1: 		{
1: 			ColumnReference[] crs =
1: 								new ColumnReference[this.groupingList.size()];
1: 
1: 			// Now populate the CR array and see if ordered
1: 			int glSize = this.groupingList.size();
0: 			for (int index = 0; index < glSize; index++)
1: 			{
0: 				GroupByColumn gc =
0: 						(GroupByColumn) this.groupingList.elementAt(index);
0: 				crs[index] = gc.getColumnReference();
1: 			}
1: 
0: 			isInSortedOrder = childResult.isOrderedOn(crs, true, (Vector)null);
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Get whether or not the source is in sorted order.
1: 	 *
1: 	 * @return Whether or not the source is in sorted order.
1: 	 */
1: 	boolean getIsInSortedOrder()
1: 	{
1: 		return isInSortedOrder;
1: 	}
1: 
1: 	/**
1: 	 * Add the extra result columns required by the aggregates
1: 	 * to the result list.
1: 	 * 
1: 	 * @exception standard exception
1: 	 */
1: 	private void addAggregates()
1: 		throws StandardException
1: 	{
1: 		addNewPRNode();
1: 		addNewColumnsForAggregation();
1: 		addDistinctAggregatesToOrderBy();
1: 	}
1: 
1: 	/**
1: 	 * Add any distinct aggregates to the order by list.
1: 	 * Asserts that there are 0 or more distincts.
1: 	 */
1: 	private void addDistinctAggregatesToOrderBy()
1: 	{
0: 		int numDistinct = numDistinctAggregates(aggregateVector);
1: 		if (numDistinct != 0)
1: 		{
1: 			if (SanityManager.DEBUG)
1: 			{
0: 				SanityManager.ASSERT(numDistinct == 1,
1: 					"Should not have more than 1 distinct aggregate per Group By node");
1: 			}
1: 			
1: 			AggregatorInfo agg = null;
1: 			int count = aggInfo.size();
1: 			for (int i = 0; i < count; i++)
1: 			{
0: 				agg = (AggregatorInfo) aggInfo.elementAt(i);
1: 				if (agg.isDistinct())
1: 				{
1: 					break;
1: 				}
1: 			}
1: 
1: 			if (SanityManager.DEBUG)
1: 			{
1: 				SanityManager.ASSERT(agg != null && agg.isDistinct());
1: 			}
1: 
1: 			addDistinctAggregate = true;
1: 			addDistinctAggregateColumnNum = agg.getInputColNum();
1: 		}
1: 	}
1: 	
1: 	/**
1: 	 * Add a new PR node for aggregation.  Put the
1: 	 * new PR under the sort.
1: 	 *		
1: 	 * @exception standard exception
1: 	 */
1: 	private void addNewPRNode()
1: 		throws StandardException
1: 	{
1: 		/*
1: 		** Get the new PR, put above the GroupBy.  
1: 		*/
0: 		parent = (FromTable) getNodeFactory().getNode(
0: 										C_NodeTypes.PROJECT_RESTRICT_NODE,
1: 										this, 	// child
0: 										resultColumns,		// result column list
0: 										null,				// restriction
1: 										null,				// restriction list
1: 										null,				// project subqueries
0: 										null,				// restrict subqueries
1: 										tableProperties,
0: 										getContextManager());
1: 
1: 
1: 		/*
1: 		** Reset the bottom RCL to be empty.
1: 		*/
0: 		childResult.setResultColumns((ResultColumnList)
0: 											getNodeFactory().getNode(
0: 												C_NodeTypes.RESULT_COLUMN_LIST,
0: 												getContextManager()));
1: 
1: 		/*
1: 		** Set the group by RCL to be empty
1: 		*/
0: 		resultColumns = (ResultColumnList) getNodeFactory().getNode(
0: 											C_NodeTypes.RESULT_COLUMN_LIST,
0: 											getContextManager());
1: 
1: 	}
1: 
1: 
1: 	/**
1: 	 * Add a whole slew of columns needed for 
1: 	 * aggregation. Basically, for each aggregate we add
0: 	 * 2 columns: the aggregate input expression
0: 	 * and the aggregator column.  The input expression is
1: 	 * taken directly from the aggregator node.  The aggregator
1: 	 * is the run time aggregator.  We add it to the RC list
1: 	 * as a new object coming into the sort node.
1: 	 * <P>
1: 	 * At this point this is invoked, we have the following
1: 	 * tree: <UL>
1: 	 *      PR - (PARENT): RCL is the original select list
1: 	 *       |
1: 	 *      PR - GROUP BY:  RCL is empty
1: 	 *       |
1: 	 *      PR - FROM TABLE: RCL is empty </UL> <P>
1: 	 *
1: 	 * For each ColumnReference in PR RCL <UL>
1: 	 *	<LI> clone the ref </LI>
1: 	 *	<LI> create a new RC in the bottom RCL and set it 
1: 	 *		 to the col ref </LI>
1: 	 *	<LI> create a new RC in the GROUPBY RCL and set it to 
1: 	 *		 point to the bottom RC </LI>
1: 	 *	<LI> reset the top PR ref to point to the new GROUPBY
0: 	 *		 RC	
1: 	 *
0: 	 * For each aggregate in aggregateVector <UL>
1: 	 *	<LI> create RC in FROM TABLE.  Fill it with 
1: 	 * 		aggs Operator.
1: 	 *	<LI> create RC in FROM TABLE for agg result</LI>
1: 	 *	<LI> create RC in FROM TABLE for aggregator</LI>
1: 	 *	<LI> create RC in GROUPBY for agg input, set it
1: 	 *		to point to FROM TABLE RC </LI>
1: 	 *	<LI> create RC in GROUPBY for agg result</LI>
1: 	 *	<LI> create RC in GROUPBY for aggregator</LI>
0: 	 *	<LI> replace Agg with reference to RC for agg result </LI>
1: 	 *
1: 	 * @exception standard exception
1: 	 */
1: 	private void addNewColumnsForAggregation()
1: 		throws StandardException
1: 	{
1: 		/*
0: 		** Now we have two new nodes, the sort and a new PR above
0: 		** it.  They all map to the child result set.  Now we must
0: 		** find every aggregate and massage the tree.  For now we
0: 		** will examine every result column of the original select
0: 		** list.
1: 		*/
0: 		DataDictionary			dd;
0: 		AggregateNode	aggregate = null;
1: 		ColumnReference	newColumnRef;
0: 		ResultColumn	rcBottom;
1: 		ResultColumn	newRC;
0: 		ResultColumn	gbRC;
1: 		ResultColumn	tmpRC;
0: 		ResultColumn	aggInputRC;
1: 		ResultColumnList bottomRCL  = childResult.getResultColumns();
0: 		ResultColumnList groupByRCL = resultColumns;
1: 		ResultColumnList aggRCL;
1: 		int				aggregatorVColId;
1: 		int				aggInputVColId;
1: 		int				aggResultVColId;
1: 
0: 		LanguageFactory lf = getLanguageConnectionContext().getLanguageFactory();
0: 		dd = getDataDictionary();
0: 		aggInfo = new AggregatorInfoList();
1: 
1: 		/*
0: 		** Get a list of all column references in the
0: 		** parent RCL, skipping (not going below) AggregateNodes
1: 		*/
0: 		CollectNodesVisitor getUnaggVisitor = new CollectNodesVisitor(ColumnReference.class, AggregateNode.class);
0: 		parent.getResultColumns().accept(getUnaggVisitor);
0: 		Vector colRefVector = getUnaggVisitor.getList();
1: 
1: 		/*
0: 		** Walk the list of unaggregated column references
0: 		** and push them down.
1: 		*/
0: 		int crvSize = colRefVector.size();
0: 		for (int index = 0; index < crvSize; index++)
1: 		{
0: 			ColumnReference origColumnRef = (ColumnReference) colRefVector.elementAt(index);
0: 			newColumnRef = (ColumnReference)origColumnRef.getClone();
1: 
1: 			/*
0: 			** Put the column reference in the bottom PR.
1: 			*/
0: 			newRC = (ResultColumn) getNodeFactory().getNode(
0: 									C_NodeTypes.RESULT_COLUMN,
0: 									"##UnaggColumn",
0: 									newColumnRef,
0: 									getContextManager());
0: 			newRC.setExpression(newColumnRef);
1: 			bottomRCL.addElement(newRC);
1: 			newRC.markGenerated();
1: 			newRC.bindResultColumnToExpression();
1: 			newRC.setVirtualColumnId(bottomRCL.size());
1: 
1: 			/*
0: 			** Reset the group by column position
1: 			*/
0: 			if (groupingList != null) 
1: 			{
0: 				GroupByColumn	gbColumn;
0: 				if ((gbColumn = 
0: 						groupingList.containsColumnReference(newColumnRef)) 
0: 					!= null)
1: 				{
0: 					gbColumn.setColumnPosition(bottomRCL.size());
1: 				}
1: 			}
1: 		
1: 			/*
0: 			** Add the column to the group by list
1: 			*/
0: 			gbRC = getColumnReference(newRC, dd);
0: 			groupByRCL.addElement(gbRC);
0: 			gbRC.markGenerated();
0: 			gbRC.bindResultColumnToExpression();
0: 			gbRC.setVirtualColumnId(groupByRCL.size());
1: 	
1: 			/*
0: 			** Reset the original node to point to the
0: 			** Group By result set.
1: 			*/
0: 			origColumnRef.setSource(gbRC);
1: 		}
1: 		/*
0: 		** Now process all of the aggregates.  Replace
0: 		** every aggregate with an RC.  We toss out
0: 		** the list of RCs, we need to get each RC
0: 		** as we process its corresponding aggregate.
1: 		*/
1: 		ReplaceAggregatesWithCRVisitor replaceAggsVisitor = 
1: 			new ReplaceAggregatesWithCRVisitor(
0: 					(ResultColumnList) getNodeFactory().getNode(
0: 										C_NodeTypes.RESULT_COLUMN_LIST,
0: 										getContextManager()),
0: 					((FromTable) childResult).getTableNumber());
1: 		parent.getResultColumns().accept(replaceAggsVisitor);
1: 
1: 		/*
1: 		** For each aggregate
1: 		*/
0: 		int alSize = aggregateVector.size();
1: 		for (int index = 0; index < alSize; index++)
1: 		{
0: 			aggregate = (AggregateNode) aggregateVector.elementAt(index);
1: 
1: 			/*
1: 			** AGG RESULT: Set the aggregate result to null in the
1: 			** bottom project restrict.
1: 			*/
0: 			newRC = (ResultColumn) getNodeFactory().getNode(
0: 										C_NodeTypes.RESULT_COLUMN,
0: 										"##aggregate result",
0: 										aggregate.getNewNullResultExpression(),
0: 										getContextManager());
1: 			newRC.markGenerated();
1: 			newRC.bindResultColumnToExpression();
1: 			bottomRCL.addElement(newRC);
1: 			newRC.setVirtualColumnId(bottomRCL.size());
1: 			aggResultVColId = newRC.getVirtualColumnId();
1: 
1: 			/*
1: 			** Set the GB aggregrate result column to
1: 			** point to this.  The GB aggregate result
1: 			** was created when we called
0: 			** ReplaceAggregatesWithColumnReferencesVisitor()
1: 			*/
0: 			newColumnRef = (ColumnReference) getNodeFactory().getNode(
0: 												C_NodeTypes.COLUMN_REFERENCE,
0: 												newRC.getName(),
0: 												null,
0: 												getContextManager());
1: 			newColumnRef.setSource(newRC);
0: 			newColumnRef.setType(newRC.getExpressionType());
1: 			newColumnRef.setNestingLevel(this.getLevel());
1: 			newColumnRef.setSourceLevel(this.getLevel());
0: 			tmpRC = (ResultColumn) getNodeFactory().getNode(
0: 								C_NodeTypes.RESULT_COLUMN,
0: 								newRC.getColumnName(),
0: 								newColumnRef,
0: 								getContextManager());
1: 			tmpRC.markGenerated();
1: 			tmpRC.bindResultColumnToExpression();
1: 			groupByRCL.addElement(tmpRC);
1: 			tmpRC.setVirtualColumnId(groupByRCL.size());
1: 
1: 			/*
1: 			** Set the column reference to point to
1: 			** this.
1: 			*/
1: 			newColumnRef = aggregate.getGeneratedRef();
1: 			newColumnRef.setSource(tmpRC);
1: 
1: 			/*
1: 			** AGG INPUT: Create a ResultColumn in the bottom 
1: 			** project restrict that has the expression that is
1: 			** to be aggregated
1: 			*/
1: 			newRC = aggregate.getNewExpressionResultColumn(dd);
1: 			newRC.markGenerated();
1: 			newRC.bindResultColumnToExpression();
1: 			bottomRCL.addElement(newRC);
1: 			newRC.setVirtualColumnId(bottomRCL.size());
1: 			aggInputVColId = newRC.getVirtualColumnId();
0: 			aggInputRC = newRC;
1: 	
1: 			/*
1: 			** Add a reference to this column into the
1: 			** group by columns.
1: 			*/
1: 			tmpRC = getColumnReference(newRC, dd);
1: 			groupByRCL.addElement(tmpRC);
1: 			tmpRC.setVirtualColumnId(groupByRCL.size());
1: 
1: 			/*
1: 			** AGGREGATOR: Add a getAggregator method call 
1: 			** to the bottom result column list.
1: 			*/
1: 			newRC = aggregate.getNewAggregatorResultColumn(dd);
1: 			newRC.markGenerated();
1: 			newRC.bindResultColumnToExpression();
1: 			bottomRCL.addElement(newRC);
1: 			newRC.setVirtualColumnId(bottomRCL.size());
1: 			aggregatorVColId = newRC.getVirtualColumnId();
1: 
1: 			/*
1: 			** Add a reference to this column in the Group By result
1: 			** set.
1: 			*/
1: 			tmpRC = getColumnReference(newRC, dd);
1: 			groupByRCL.addElement(tmpRC);
1: 			tmpRC.setVirtualColumnId(groupByRCL.size());
1: 
1: 			/*
1: 			** Piece together a fake one column rcl that we will use
1: 			** to generate a proper result description for input
1: 			** to this agg if it is a user agg.
1: 			*/
0: 			aggRCL = (ResultColumnList) getNodeFactory().getNode(
0: 											C_NodeTypes.RESULT_COLUMN_LIST,
0: 											getContextManager());
0: 			aggRCL.addElement(aggInputRC);
1: 
1: 			/*
1: 			** Note that the column ids in the row are 0 based
1: 			** so we have to subtract 1.
1: 			*/
1: 			aggInfo.addElement(new AggregatorInfo(
0: 							aggregate.getAggregateName(),
0: 							aggregate.getAggregatorClassName(),
0: 							aggInputVColId - 1,			// aggregate input column
0: 							aggResultVColId -1,			// the aggregate result column
0: 							aggregatorVColId - 1,		// the aggregator column	
0: 							aggregate.isDistinct(),
0: 							lf.getResultDescription(aggRCL.makeResultDescriptors(), "SELECT")
0: 						));
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Return the parent node to this one, if there is
1: 	 * one.  It will return 'this' if there is no generated
1: 	 * node above this one.
1: 	 *
1: 	 * @return the parent node
1: 	 */
0: 	public FromTable getParent()
1: 	{
1: 		return parent;
1: 	}
1: 
1: 
1: 	/*
1: 	 *  Optimizable interface
1: 	 */
1: 
1: 	/**
1: 	 * @see Optimizable#optimizeIt
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public CostEstimate optimizeIt(
1: 							Optimizer optimizer,
1: 							OptimizablePredicateList predList,
1: 							CostEstimate outerCost,
1: 							RowOrdering rowOrdering)
1: 			throws StandardException
1: 	{
1: 		// RESOLVE: NEED TO FACTOR IN THE COST OF GROUPING (SORTING) HERE
0: 		CostEstimate childCost = ((Optimizable) childResult).optimizeIt(
1: 													optimizer,
1: 													predList,
1: 													outerCost,
1: 													rowOrdering);
1: 
0: 		CostEstimate retval = super.optimizeIt(
1: 												optimizer,
1: 												predList,
1: 												outerCost,
1: 												rowOrdering
1: 											  );
1: 
1: 		return retval;
1: 	}
1: 
1: 	/**
1: 	 * @see Optimizable#estimateCost
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public CostEstimate estimateCost(OptimizablePredicateList predList,
1: 										ConglomerateDescriptor cd,
1: 										CostEstimate outerCost,
1: 										Optimizer optimizer,
1: 										RowOrdering rowOrdering
1: 										)
1: 			throws StandardException
1: 	{
1: 		// RESOLVE: NEED TO FACTOR IN THE COST OF GROUPING (SORTING) HERE
1: 		//
1: 		CostEstimate childCost = ((Optimizable) childResult).estimateCost(
1: 													predList,
1: 													cd,
1: 													outerCost,
1: 													optimizer,
1: 													rowOrdering);
1: 
0: 		CostEstimate costEstimate = getCostEstimate(optimizer);
0: 		costEstimate.setCost(childCost.getEstimatedCost(),
1: 							childCost.rowCount(),
1: 							childCost.singleScanRowCount());
1: 
0: 		return costEstimate;
1: 	}
1: 
1: 	/**
1: 	 * @see org.apache.derby.iapi.sql.compile.Optimizable#pushOptPredicate
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
1: 	public boolean pushOptPredicate(OptimizablePredicate optimizablePredicate)
1: 			throws StandardException
1: 	{
1: 		return ((Optimizable) childResult).pushOptPredicate(optimizablePredicate);
1: 	}
1: 
1: 	/**
1: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
1: 	 * for how this should be done for tree printing.
1: 	 *
1: 	 * @return	This object as a String
1: 	 */
1: 
1: 	public String toString()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			return "singleInputRowOptimization: " + singleInputRowOptimization + "\n" +
0: 				childResult.toString() + "\n" + super.toString();
1: 		}
1: 		else
1: 		{
1: 			return "";
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Evaluate whether or not the subquery in a FromSubquery is flattenable.
1: 	 * Currently, a FSqry is flattenable if all of the following are true:
1: 	 *		o  Subquery is a SelectNode.
1: 	 *		o  It contains no top level subqueries.  (RESOLVE - we can relax this)
1: 	 *		o  It does not contain a group by or having clause
1: 	 *		o  It does not contain aggregates.
1: 	 *
1: 	 * @param fromList	The outer from list
1: 	 *
1: 	 * @return boolean	Whether or not the FromSubquery is flattenable.
1: 	 */
0: 	public boolean flattenableInFromSubquery(FromList fromList)
1: 	{
1: 		/* Can't flatten a GroupByNode */
1: 		return false;
1: 	}
1: 
1: 	/**
1: 	 * Optimize this GroupByNode.
1: 	 *
1: 	 * @param dataDictionary	The DataDictionary to use for optimization
0: 	 * @param predicateList		The PredicateList to optimize.  This should
1: 	 *							be a join predicate.
1: 	 * @param outerRows			The number of outer joining rows
1: 	 *
1: 	 * @return	ResultSetNode	The top of the optimized subtree
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public ResultSetNode optimize(DataDictionary dataDictionary,
1: 								  PredicateList predicates,
1: 								  double outerRows)
1: 					throws StandardException
1: 	{
1: 		/* We need to implement this method since a PRN can appear above a
1: 		 * SelectNode in a query tree.
1: 		 */
0: 		childResult = (FromTable) childResult.optimize(
0: 											dataDictionary,
0: 											predicates,
0: 											outerRows);
0: 		Optimizer optimizer = getOptimizer(
0: 						(FromList) getNodeFactory().getNode(
0: 									C_NodeTypes.FROM_LIST,
0: 									getNodeFactory().doJoinOrderOptimization(),
0: 									getContextManager()),
0: 						predicates,
0: 						dataDictionary,
0: 						(RequiredRowOrdering) null);
1: 
1: 		// RESOLVE: NEED TO FACTOR IN COST OF SORTING AND FIGURE OUT HOW
1: 		// MANY ROWS HAVE BEEN ELIMINATED.
0: 		costEstimate = optimizer.newCostEstimate();
1: 
0: 		costEstimate.setCost(childResult.getCostEstimate().getEstimatedCost(),
1: 							childResult.getCostEstimate().rowCount(),
1: 							childResult.getCostEstimate().singleScanRowCount());
1: 
1: 		return this;
1: 	}
1: 
0: 	ResultColumnDescriptor[] makeResultDescriptors(ExecutionContext ec)
1: 	{
0: 	    return childResult.makeResultDescriptors(ec);
1: 	}
1: 
1: 	/**
1: 	 * Return whether or not the underlying ResultSet tree will return
1: 	 * a single row, at most.
1: 	 * This is important for join nodes where we can save the extra next
1: 	 * on the right side if we know that it will return at most 1 row.
1: 	 *
1: 	 * @return Whether or not the underlying ResultSet tree will return a single row.
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public boolean isOneRowResultSet()	throws StandardException
1: 	{
1: 		// Only consider scalar aggregates for now
1: 		return ((groupingList == null) ||  (groupingList.size() == 0));
1: 	}
1: 
1:     /**
1:      * generate the sort result set operating over the source
0: 	 * resultset.  Adds distinct aggregates to the sort if
1: 	 * necessary.
1:      *
1: 	 * @exception StandardException		Thrown on error
1:      */
0: 	public void generate(ActivationClassBuilder acb,
1: 								MethodBuilder mb)
1: 							throws StandardException
1: 	{
0: 		int					orderingItem = 0;
0: 		int					aggInfoItem = 0;
1: 		FormatableArrayHolder	orderingHolder;
1: 
1: 		/* Get the next ResultSet#, so we can number this ResultSetNode, its
1: 		 * ResultColumnList and ResultSet.
1: 		 */
1: 		assignResultSetNumber();
1: 
0: 		// Get the cost estimate from the child if we don't have one yet
0: 		if (costEstimate == null)
1: 		{
0: 			costEstimate = childResult.getFinalCostEstimate();
1: 		}
1: 
1: 		/*
1: 		** Get the column ordering for the sort.  Note that
1: 		** for a scalar aggegate we may not have any ordering
1: 		** columns (if there are no distinct aggregates).
1: 		** WARNING: if a distinct aggregate is passed to
1: 		** SortResultSet it assumes that the last column
1: 		** is the distinct one.  If this assumption changes
1: 		** then SortResultSet will have to change.
1: 		*/
1: 		orderingHolder = acb.getColumnOrdering(groupingList);
1: 		if (addDistinctAggregate)
1: 		{
1: 			orderingHolder = acb.addColumnToOrdering(
1: 									orderingHolder,
1: 									addDistinctAggregateColumnNum);
1: 		}
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			if (SanityManager.DEBUG_ON("AggregateTrace"))
1: 			{
0: 				StringBuffer s = new StringBuffer();
1: 					
1: 				s.append("Group by column ordering is (");
0: 				ColumnOrdering[] ordering = 
0: 						(ColumnOrdering[])orderingHolder.getArray(ColumnOrdering.class);
1: 
1: 				for (int i = 0; i < ordering.length; i++)	
1: 				{
1: 					s.append(ordering[i].getColumnId());
1: 					s.append(" ");
1: 				}
1: 				s.append(")");
1: 				SanityManager.DEBUG("AggregateTrace", s.toString());
1: 			}
1: 		}
1: 
0: 		orderingItem = acb.addItem(orderingHolder);
1: 
1: 		/*
1: 		** We have aggregates, so save the aggInfo
1: 		** struct in the activation and store the number
1: 		*/
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(aggInfo != null,
1: 					"aggInfo not set up as expected");
1: 		}
0: 		aggInfoItem = acb.addItem(aggInfo);
1: 
1: 		acb.pushGetResultSetFactoryExpression(mb);
1: 
1: 		// Generate the child ResultSet
1: 		childResult.generate(acb, mb);
1: 		mb.push(isInSortedOrder);
1: 		mb.push(aggInfoItem);
1: 		mb.push(orderingItem);
0: 		acb.pushThisAsActivation(mb);
1: 
0: 		resultColumns.generateHolder(acb, mb);
1: 
0: 		mb.push(resultColumns.getTotalColumnSize());
0: 		mb.push(resultSetNumber);
1: 
1: 		/* Generate a (Distinct)ScalarAggregateResultSet if scalar aggregates */
1: 		if ((groupingList == null) ||  (groupingList.size() == 0))
1: 		{
1: 			genScalarAggregateResultSet(acb, mb);
1: 		}
1: 		/* Generate a (Distinct)GroupedAggregateResultSet if grouped aggregates */
1: 		else
1: 		{
1: 			genGroupedAggregateResultSet(acb, mb);
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Generate the code to evaluate scalar aggregates.
1: 	 *
1: 	 */
1: 	private	void genScalarAggregateResultSet(ActivationClassBuilder acb,
1: 												   MethodBuilder mb)
1: 	{
1: 		/* Generate the (Distinct)ScalarAggregateResultSet:
1: 		 *	arg1: childExpress - Expression for childResult
1: 		 *  arg2: isInSortedOrder - true if source result set in sorted order
1: 		 *  arg3: aggregateItem - entry in saved objects for the aggregates,
1: 		 *  arg4: orderItem - entry in saved objects for the ordering
1: 		 *  arg5: Activation
1: 		 *  arg6: rowAllocator - method to construct rows for fetching
1: 		 *			from the sort
1: 		 *  arg7: row size
1: 		 *  arg8: resultSetNumber
1: 		 *  arg9: Whether or not to perform min optimization.
0: 		 *  arg12: closeCleanup
1: 		 */
1: 		String resultSet = (addDistinctAggregate) ? "getDistinctScalarAggregateResultSet" : "getScalarAggregateResultSet";
1: 
1: 		mb.push(singleInputRowOptimization);
0: 		mb.push(costEstimate.rowCount());
0: 		mb.push(costEstimate.getEstimatedCost());
1: 
0: 		closeMethodArgument(acb, mb);
1: 
0: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, resultSet, ClassName.NoPutResultSet, 12);
1: 	}
1: 
1: 	/**
1: 	 * Generate the code to evaluate grouped aggregates.
1: 	 *
1: 	 */
1: 	private	void genGroupedAggregateResultSet(ActivationClassBuilder acb,
1: 												   MethodBuilder mb)
1: 				throws StandardException
1: 	{
1: 		/* Generate the (Distinct)GroupedAggregateResultSet:
1: 		 *	arg1: childExpress - Expression for childResult
1: 		 *  arg2: isInSortedOrder - true if source result set in sorted order
1: 		 *  arg3: aggregateItem - entry in saved objects for the aggregates,
1: 		 *  arg4: orderItem - entry in saved objects for the ordering
1: 		 *  arg5: Activation
1: 		 *  arg6: rowAllocator - method to construct rows for fetching
1: 		 *			from the sort
1: 		 *  arg7: row size
1: 		 *  arg8: resultSetNumber
0: 		 *  arg11: closeCleanup
1: 		 */
1: 		String resultSet = (addDistinctAggregate) ? "getDistinctGroupedAggregateResultSet" : "getGroupedAggregateResultSet";
1:     
0: 		mb.push(costEstimate.rowCount());
0: 		mb.push(costEstimate.getEstimatedCost());
1: 
0: 		closeMethodArgument(acb, mb);
1: 
0: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, resultSet, ClassName.NoPutResultSet, 11);
1: 
1: 	}
1: 
1: 	///////////////////////////////////////////////////////////////
1: 	//
1: 	// UTILITIES
1: 	//
1: 	///////////////////////////////////////////////////////////////
1: 	/**
1: 	 * Method for creating a new result column referencing
1: 	 * the one passed in.
1: 	 *
1: 	 * @param	targetRC	the source
1: 	 * @param	dd
1: 	 *
1: 	 * @return the new result column
1: 	 *
1: 	 * @exception StandardException	on error
1: 	 */
1: 	private ResultColumn getColumnReference(ResultColumn targetRC, 
1: 								DataDictionary		dd)
1: 		throws StandardException
1: 	{
1: 		ColumnReference	tmpColumnRef;
1: 		ResultColumn	newRC;
1: 	
0: 		tmpColumnRef = (ColumnReference) getNodeFactory().getNode(
0: 											C_NodeTypes.COLUMN_REFERENCE,
0: 											targetRC.getName(),
0: 											null,
0: 											getContextManager());
1: 		tmpColumnRef.setSource(targetRC);
0: 		tmpColumnRef.setType(targetRC.getExpressionType());
1: 		tmpColumnRef.setNestingLevel(this.getLevel());
1: 		tmpColumnRef.setSourceLevel(this.getLevel());
0: 		newRC = (ResultColumn) getNodeFactory().getNode(
0: 									C_NodeTypes.RESULT_COLUMN,
0: 									targetRC.getColumnName(),
0: 									tmpColumnRef,
0: 									getContextManager());
1: 		newRC.markGenerated();
1: 		newRC.bindResultColumnToExpression();
1: 		return newRC;
1: 	}
1: 
1: 	/**
1: 	 * Consider any optimizations after the optimizer has chosen a plan.
1: 	 * Optimizations include:
1: 	 *	o  min optimization for scalar aggregates
1: 	 *	o  max optimization for scalar aggregates
1: 	 *
1: 	 * @param selectHasPredicates true if SELECT containing this
1: 	 *		vector/scalar aggregate has a restriction
1: 	 *
0: 	 * @return Nothing.
1: 	 *
1: 	 * @exception StandardException	on error
1: 	 */
1: 	void considerPostOptimizeOptimizations(boolean selectHasPredicates)
1: 		throws StandardException
1: 	{
1: 		/* Consider the optimization for min with asc index on that column or
1: 		 * max with desc index on that column:
1: 		 *	o  No group by
1: 		 *  o  One of:
1: 		 *		o  min/max(ColumnReference) is only aggregate && source is 
1: 		 *		   ordered on the ColumnReference
1: 		 *		o  min/max(ConstantNode)
1: 		 * The optimization of the other way around (min with desc index or
1: 		 * max with asc index) has the same restrictions with the additional
1: 		 * temporary restriction of no qualifications at all (because
1: 		 * we don't have true backward scans).
1: 		 */
1: 		if (groupingList == null)
1: 		{
0: 			if (aggregateVector.size() == 1)
1: 			{
0: 				AggregateNode an = (AggregateNode) aggregateVector.elementAt(0);
1: 				AggregateDefinition ad = an.getAggregateDefinition();
1: 				if (ad instanceof MaxMinAggregateDefinition)
1: 				{
1: 					if (an.getOperand() instanceof ColumnReference)
1: 					{
1: 						/* See if the underlying ResultSet tree
1: 						 * is ordered on the ColumnReference.
1: 						 */
0: 						ColumnReference[] crs = new ColumnReference[1];
0: 						crs[0] = (ColumnReference) an.getOperand();
1: 						
0: 						Vector tableVector = new Vector();
0: 						boolean minMaxOptimizationPossible = isOrderedOn(crs, false, tableVector);
1: 						if (SanityManager.DEBUG)
1: 						{
0: 							SanityManager.ASSERT(tableVector.size() <= 1, "bad number of FromBaseTables returned by isOrderedOn() -- "+tableVector.size());
1: 						}
1: 
1: 						if (minMaxOptimizationPossible)
1: 						{
1: 							boolean ascIndex = true;
1: 							int colNum = crs[0].getColumnNumber();
1: 							
1: 							/* Check if we have an access path, this will be
0: 							 * null in a join case (See Beetle 4423)
1: 							 */
1: 							AccessPath accessPath= getTrulyTheBestAccessPath();
0: 							if (accessPath == null)
1: 								return;
1: 							IndexDescriptor id = accessPath.
1: 												getConglomerateDescriptor().
1: 												getIndexDescriptor();
1: 							int[] keyColumns = id.baseColumnPositions();
1: 							boolean[] isAscending = id.isAscending();
1: 							for (int i = 0; i < keyColumns.length; i++)
1: 							{
1: 								/* in such a query: select min(c3) from
1: 								 * tab1 where c1 = 2 and c2 = 5, if prefix keys
1: 								 * have equality operator, then we can still use
1: 								 * the index.  The checking of equality operator
1: 								 * has been done in isStrictlyOrderedOn.
1: 								 */
1: 								if (colNum == keyColumns[i])
1: 								{
1: 									if (! isAscending[i])
1: 										ascIndex = false;
1: 									break;
1: 								}
1: 							}
0: 							FromBaseTable fbt = (FromBaseTable)tableVector.firstElement();
1: 							MaxMinAggregateDefinition temp = (MaxMinAggregateDefinition)ad;
1: 
1: 							/*  MAX   ASC      NULLABLE 
1:                              *  ----  ----------
1: 							 *  TRUE  TRUE      TRUE/FALSE  =  Special Last Key Scan (ASC Index Last key with null skips)
1: 							 *  TRUE  FALSE     TRUE/FALSE  =  JustDisableBulk(DESC index 1st key with null skips)
1: 							 *  FALSE TRUE      TRUE/FALSE  = JustDisableBulk(ASC index 1st key)
1: 							 *  FALSE FALSE     TRUE/FALSE  = Special Last Key Scan(Desc Index Last Key)
1: 							 */
1: 
1: 							if (((!temp.isMax()) && ascIndex) || 
1: 								((temp.isMax()) && !ascIndex))
1: 							{
1: 								fbt.disableBulkFetch();
1: 								singleInputRowOptimization = true;
1: 							}
1: 							/*
1: 							** Max optimization with asc index or min with
1: 							** desc index is currently more
1: 							** restrictive than otherwise.
1: 							** We are getting the store to return the last
1: 							** row from an index (for the time being, the
1: 							** store cannot do real backward scans).  SO
1: 							** we cannot do this optimization if we have
1: 							** any predicates at all.
1: 							*/
1: 							else if (!selectHasPredicates && 
1: 									 ((temp.isMax() && ascIndex) || 
1: 									  (!temp.isMax() && !ascIndex )))
1: 							{
1: 								fbt.disableBulkFetch();
1: 								fbt.doSpecialMaxScan();
1: 								singleInputRowOptimization = true;
1: 							}
1: 						}
1: 					}
1: 					else if (an.getOperand() instanceof ConstantNode)
1: 					{
1: 						singleInputRowOptimization = true;
1: 					}
1: 				}
1: 			}
1: 		}
1: 	}
1: }
author:Army
-------------------------------------------------------------------------------
commit:d5ef906
/////////////////////////////////////////////////////////////////////////
0: 
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
0: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: import org.apache.derby.iapi.reference.ClassName;
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: import org.apache.derby.impl.sql.compile.MaxMinAggregateDefinition;
0: import java.util.Iterator;
0: import java.util.Vector;
0: 
0: 
/////////////////////////////////////////////////////////////////////////
1: 	private ValueNode havingClause;
0: 	
1: 	private SubqueryList havingSubquerys;
0: 	
/////////////////////////////////////////////////////////////////////////
0: 	 * @param havingClause The having clause.
1: 	 * @param havingSubquerys subqueries in the having clause.
0: 	 * @param nestingLevel nestingLevel of this group by node. This is used for 
1: 	 *     error checking of group by queries with having clause.
0: 						Object bottomPR,
0: 						Object aggregateVector,
0: 						Object havingClause,
0: 						Object havingSubquerys,
0: 						Object tableProperties,
0: 						Object nestingLevel)
0: 		setLevel(((Integer)nestingLevel).intValue());
0: 		this.havingClause = (ValueNode)havingClause;
0: 		this.havingSubquerys = (SubqueryList)havingSubquerys;
0: //			Aggregage vector can be null if we have a having clause.
0: //          select c1 from t1 group by c1 having c1 > 1;			
0: //			SanityManager.ASSERT(((Vector) aggregateVector).size() > 0,
0: //			"aggregateVector expected to be non-empty");
/////////////////////////////////////////////////////////////////////////
0: 		ResultColumnList rclNew = (ResultColumnList)getNodeFactory().getNode(
0: 				                                                 C_NodeTypes.RESULT_COLUMN_LIST,
0: 				                                                 getContextManager());
0: 		int sz = resultColumns.size();
0: 		for (int i = 0; i < sz; i++) 
0: 		{
0: 			ResultColumn rc = (ResultColumn) resultColumns.elementAt(i);
1: 			if (!rc.isGenerated()) {
1: 				rclNew.addElement(rc);
0: 			}
0: 		}
0: 
1: 		// if any columns in the source RCL were generated for an order by
1: 		// remember it in the new RCL as well. After the sort is done it will
1: 		// have to be projected out upstream.
0: 		rclNew.copyOrderBySelect(resultColumns);
0: 		
1: 										rclNew,
1: 										null, //havingClause,
1: 										havingSubquerys,
/////////////////////////////////////////////////////////////////////////
0: 			
1: 			// Since we always need a PR node on top of the GB 
1: 			// node to perform projection we can use it to perform 
1: 			// the having clause restriction as well. 
1: 			// To evaluate the having clause correctly, we need to 
1: 			// convert each aggregate and expression to point 
1: 			// to the appropriate result column in the group by node. 
1: 			// This is no different from the transformations we do to 
1: 			// correctly evaluate aggregates and expressions in the 
1: 			// projection list. 
1: 			// 
1: 			//
1: 			// For this query:
1: 			// SELECT c1, SUM(c2), MAX(c3)
1: 			//    FROM t1 
1: 			//    HAVING c1+max(c3) > 0;
1: 			// PRSN RCL -> (ptr(gbn:rcl[0]), ptr(gbn:rcl[1]), ptr(gbn:rcl[4]))
1: 			// Restriction: (> (+ ptr(gbn:rcl[0]) ptr(gbn:rcl[4])) 0)
1: 			//              |
1: 			// GBN (RCL) -> (C1, SUM(C2), <input>, <aggregator>, MAX(C3), <input>, <aggregator>
1: 			//              |
1: 			//       FBT (C1, C2)
1: 			if (havingClause != null) {
1: 				SubstituteExpressionVisitor havingSE =
0: 					new SubstituteExpressionVisitor(
0: 							gbc.getColumnExpression(),
0: 							vc, null);
0: 				havingClause.accept(havingSE);
0: 			}
/////////////////////////////////////////////////////////////////////////
1: 	 * 3 columns: the aggregate input expression
1: 	 * and the aggregator column and a column where the aggregate 
1: 	 * result is stored.  The input expression is
/////////////////////////////////////////////////////////////////////////
1: 	 *		 RC</LI></UL>	
/////////////////////////////////////////////////////////////////////////
1: 	 *	<LI> replace Agg with reference to RC for agg result </LI></UL>.
1: 	 * <P>
1: 	 * For a query like,
1: 	 * <pre>
1: 	  select c1, sum(c2), max(c3)
1: 	  from t1 
1: 	  group by c1;
1: 	  </pre>
1: 	 * the query tree ends up looking like this:
1: 	   <pre>
0: 	    ProjectRestrictNode RCL -> (ptr to GBN(column[0]), ptr to GBN(column[1]), ptr to GBN(column[4]))
1: 	              |
0: 	    GroupByNode RCL->(C1, SUM(C2), <agg-input>, <aggregator>, MAX(C3), <agg-input>, <aggregator>)
1: 	              |
0: 	    ProjectRestrict RCL->(C1, C2, C3)
1: 	              |
1: 	    FromBaseTable
1: 	    </pre>
0: 	 * 
1: 	 * The RCL of the GroupByNode contains all the unagg (or grouping columns)
1: 	 * followed by 3 RC's for each aggregate in this order: the final computed
1: 	 * aggregate value, the aggregate input and the aggregator function.
1: 	 * <p>
1: 	 * The Aggregator function puts the results in the first of the 3 RC's 
1: 	 * and the PR resultset in turn picks up the value from there.
1: 	 * <p>
1: 	 * The notation (ptr to GBN(column[0])) basically means that it is
1: 	 * a pointer to the 0th RC in the RCL of the GroupByNode. 
1: 	 * <p>
1: 	 * The addition of these unagg and agg columns to the GroupByNode and 
1: 	 * to the PRN is performed in addUnAggColumns and addAggregateColumns. 
1: 	 * <p>
1: 	 * Note that that addition of the GroupByNode is done after the
1: 	 * query is optimized (in SelectNode#modifyAccessPaths) which means a 
1: 	 * fair amount of patching up is needed to account for generated group by columns.
/////////////////////////////////////////////////////////////////////////
0: 		if (havingClause != null) {
1: 			// we have replaced group by expressions in the having clause.
1: 			// there should be no column references in the having clause 
1: 			// referencing this table. Skip over aggregate nodes.
1: 			//   select a, sum(b) from t group by a having a+c > 1 
1: 			//  is not valid because of column c.
1: 			// 
1: 			// it is allright to have columns from parent or child subqueries;
1: 			//   select * from p where p.p1 in 
1: 			//      (select c.c1 from c group by c.c1 having count(*) = p.p2
0: 			CollectNodesVisitor collectNodesVisitor = 
0: 				new CollectNodesVisitor(ColumnReference.class, AggregateNode.class);
1: 			havingClause.accept(collectNodesVisitor);
0: 			for (Iterator it = collectNodesVisitor.getList().iterator();
0: 			     it.hasNext(); ) 
0: 			{
0: 				ColumnReference cr = (ColumnReference)it.next();
0: 				
0: 				if (!cr.getGeneratedToReplaceAggregate() && 
0: 						cr.getSourceLevel() == level) {
1: 					throw StandardException.newException(
1: 							SQLState.LANG_INVALID_COL_HAVING_CLAUSE, 
1: 							cr.getSQLColumnName());						
0: 				}
0: 			}
0: 		}
/////////////////////////////////////////////////////////////////////////
1: 				((FromTable) childResult).getTableNumber(),
1: 				ResultSetNode.class);
0: 		
1: 		if (havingClause != null) 
0: 		{
1: 			// replace aggregates in the having clause with column references.
1: 			replaceAggsVisitor = new ReplaceAggregatesWithCRVisitor(
0: 					(ResultColumnList) getNodeFactory().getNode(
0: 							C_NodeTypes.RESULT_COLUMN_LIST,
0: 							getContextManager()),					
1: 					((FromTable)childResult).getTableNumber());
1: 			havingClause.accept(replaceAggsVisitor);
1: 			// make having clause a restriction list in the parent 
1: 			// project restrict node.
1: 			ProjectRestrictNode parentPRSN = (ProjectRestrictNode)parent;
1: 			parentPRSN.setRestriction(havingClause);
0: 		}
0: 
0: 		
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2d37fd6
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
1: 	 * @param predicates		The PredicateList to optimize.  This should
/////////////////////////////////////////////////////////////////////////
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:ab10884
/////////////////////////////////////////////////////////////////////////
1: 		// Get the final cost estimate from the child.
0: 		costEstimate = childResult.getFinalCostEstimate();
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package	org.apache.derby.impl.sql.compile;
0: 
0: import org.apache.derby.iapi.services.context.ContextManager;
0: 
0: import org.apache.derby.iapi.store.access.ColumnOrdering;
0: 
0: import org.apache.derby.iapi.sql.compile.AccessPath;
0: import org.apache.derby.iapi.sql.compile.Optimizable;
0: import org.apache.derby.iapi.sql.compile.OptimizableList;
0: import org.apache.derby.iapi.sql.compile.OptimizablePredicate;
0: import org.apache.derby.iapi.sql.compile.OptimizablePredicateList;
0: import org.apache.derby.iapi.sql.compile.Optimizer;
0: import org.apache.derby.iapi.sql.compile.CostEstimate;
0: import org.apache.derby.iapi.sql.compile.Visitable;
0: import org.apache.derby.iapi.sql.compile.Visitor;
0: import org.apache.derby.iapi.sql.compile.RequiredRowOrdering;
0: import org.apache.derby.iapi.sql.compile.RowOrdering;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
0: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: import org.apache.derby.iapi.reference.ClassName;
0: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionaryContext;
0: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
0: import org.apache.derby.catalog.IndexDescriptor;
0: 
0: import org.apache.derby.iapi.sql.execute.ExecutionContext;
0: 
0: import org.apache.derby.iapi.sql.Activation; 
0: import org.apache.derby.iapi.sql.LanguageFactory;
0: import org.apache.derby.iapi.sql.ResultColumnDescriptor;
0: import org.apache.derby.iapi.sql.ResultSet;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.impl.sql.compile.ActivationClassBuilder;
0: import org.apache.derby.impl.sql.execute.AggregatorInfo;
0: import org.apache.derby.impl.sql.execute.AggregatorInfoList;
0: 
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.services.io.FormatableArrayHolder;
0: import org.apache.derby.iapi.util.JBitSet;
0: 
0: import org.apache.derby.impl.sql.compile.MaxMinAggregateDefinition;
0: import org.apache.derby.iapi.services.classfile.VMOpcode;
0: 
0: import java.util.Vector;
0: import java.util.Properties;
0: 
0: 
0: /**
0:  * A GroupByNode represents a result set for a grouping operation
0:  * on a select.  Note that this includes a SELECT with aggregates
0:  * and no grouping columns (in which case the select list is null)
0:  * It has the same description as its input result set.
0:  * <p>
0:  * For the most part, it simply delegates operations to its bottomPRSet,
0:  * which is currently expected to be a ProjectRestrictResultSet generated
0:  * for a SelectNode.
0:  * <p>
0:  * NOTE: A GroupByNode extends FromTable since it can exist in a FromList.
0:  * <p>
0:  * There is a lot of room for optimizations here: <UL>
0:  * <LI> agg(distinct x) group by x => agg(x) group by x (for min and max) </LI>
0:  * <LI> min()/max() use index scans if possible, no sort may 
0:  *		be needed. </LI>
0:  * </UL>
0:  *
0:  * @author jerry, aggregates by jamie
0:  *
0:  */
0: public class GroupByNode extends SingleChildResultSetNode
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
0: 	/**
0: 	 * The GROUP BY list
0: 	 */
0: 	GroupByList groupingList;
0: 
0: 	/**
0: 	 * The list of all aggregates in the query block
0: 	 * that contains this group by.
0: 	 */
0: 	Vector	aggregateVector;
0: 
0: 	/**
0: 	 * Information that is used at execution time to
0: 	 * process aggregates.
0: 	 */
0: 	private AggregatorInfoList	aggInfo;
0: 
0: 	/**
0: 	 * The parent to the GroupByNode.  If we need to
0: 	 * generate a ProjectRestrict over the group by
0: 	 * then this is set to that node.  Otherwise it
0: 	 * is null.
0: 	 */
0: 	FromTable	parent;
0: 
0: 	private boolean	addDistinctAggregate;
0: 	private boolean singleInputRowOptimization;
0: 	private int		addDistinctAggregateColumnNum;
0: 
0: 	// Is the source in sorted order
0: 	private boolean isInSortedOrder;
0: 
0: 	/**
0: 	 * Intializer for a GroupByNode.
0: 	 *
0: 	 * @param bottomPR	The child FromTable
0: 	 * @param groupingList	The groupingList
0: 	 * @param aggregateVector	The vector of aggregates from
0: 	 *		the query block.  Since aggregation is done
0: 	 *		at the same time as grouping, we need them
0: 	 *		here.
0: 	 * @param tableProperties	Properties list associated with the table
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void init(
0: 						Object  bottomPR,
0: 						Object groupingList,
0: 						Object	aggregateVector,
0: 						Object tableProperties)
0: 			throws StandardException
0: 	{
0: 		super.init(bottomPR, tableProperties);
0: 
0: 		/* Group by without aggregates gets xformed into distinct */
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(((Vector) aggregateVector).size() > 0,
0: 				"aggregateVector expected to be non-empty");
0: 			if (!(childResult instanceof Optimizable))
0: 			{
0: 				SanityManager.THROWASSERT("childResult, " + childResult.getClass().getName() +
0: 					", expected to be instanceof Optimizable");
0: 			}
0: 			if (!(childResult instanceof FromTable))
0: 			{
0: 				SanityManager.THROWASSERT("childResult, " + childResult.getClass().getName() +
0: 					", expected to be instanceof FromTable");
0: 			}
0: 		}
0: 
0: 		ResultColumnList newBottomRCL;
0: 		this.groupingList = (GroupByList) groupingList;
0: 		this.aggregateVector = (Vector) aggregateVector;
0: 		this.parent = this;
0: 
0: 		/*
0: 		** The first thing we do is put ourselves on
0: 		** top of the SELECT.  The select becomes the
0: 		** childResult.  So our RCL becomes its RCL (so
0: 		** nodes above it now point to us).  Map our
0: 		** RCL to its columns.
0: 		*/
0: 		newBottomRCL = childResult.getResultColumns().copyListAndObjects();
0: 		resultColumns = childResult.getResultColumns();
0: 		childResult.setResultColumns(newBottomRCL);
0: 
0: 		/*
0: 		** We have aggregates, so we need to add
0: 		** an extra PRNode and we also have to muck around
0: 		** with our trees a might.
0: 		*/
0: 		addAggregates();
0: 
0: 		/* We say that the source is never in sorted order if there is a distinct aggregate.
0: 		 * (Not sure what happens if it is, so just skip it for now.)
0: 		 * Otherwise, we check to see if the source is in sorted order on any permutation
0: 		 * of the grouping columns.)
0: 		 */
0: 		if (! addDistinctAggregate && groupingList != null)
0: 		{
0: 			ColumnReference[] crs =
0: 								new ColumnReference[this.groupingList.size()];
0: 
0: 			// Now populate the CR array and see if ordered
0: 			int glSize = this.groupingList.size();
0: 			for (int index = 0; index < glSize; index++)
0: 			{
0: 				GroupByColumn gc =
0: 						(GroupByColumn) this.groupingList.elementAt(index);
0: 				crs[index] = gc.getColumnReference();
0: 			}
0: 
0: 			isInSortedOrder = childResult.isOrderedOn(crs, true, (Vector)null);
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Get whether or not the source is in sorted order.
0: 	 *
0: 	 * @return Whether or not the source is in sorted order.
0: 	 */
0: 	boolean getIsInSortedOrder()
0: 	{
0: 		return isInSortedOrder;
0: 	}
0: 
0: 	/**
0: 	 * Add the extra result columns required by the aggregates
0: 	 * to the result list.
0: 	 * 
0: 	 * @exception standard exception
0: 	 */
0: 	private void addAggregates()
0: 		throws StandardException
0: 	{
0: 		addNewPRNode();
0: 		addNewColumnsForAggregation();
0: 		addDistinctAggregatesToOrderBy();
0: 	}
0: 
0: 	/**
0: 	 * Add any distinct aggregates to the order by list.
0: 	 * Asserts that there are 0 or more distincts.
0: 	 */
0: 	private void addDistinctAggregatesToOrderBy()
0: 	{
0: 		int numDistinct = numDistinctAggregates(aggregateVector);
0: 		if (numDistinct != 0)
0: 		{
0: 			if (SanityManager.DEBUG)
0: 			{
0: 				SanityManager.ASSERT(numDistinct == 1,
0: 					"Should not have more than 1 distinct aggregate per Group By node");
0: 			}
0: 			
0: 			AggregatorInfo agg = null;
0: 			int count = aggInfo.size();
0: 			for (int i = 0; i < count; i++)
0: 			{
0: 				agg = (AggregatorInfo) aggInfo.elementAt(i);
0: 				if (agg.isDistinct())
0: 				{
0: 					break;
0: 				}
0: 			}
0: 
0: 			if (SanityManager.DEBUG)
0: 			{
0: 				SanityManager.ASSERT(agg != null && agg.isDistinct());
0: 			}
0: 
0: 			addDistinctAggregate = true;
0: 			addDistinctAggregateColumnNum = agg.getInputColNum();
0: 		}
0: 	}
0: 	
0: 	/**
0: 	 * Add a new PR node for aggregation.  Put the
0: 	 * new PR under the sort.
0: 	 *		
0: 	 * @exception standard exception
0: 	 */
0: 	private void addNewPRNode()
0: 		throws StandardException
0: 	{
0: 		/*
0: 		** Get the new PR, put above the GroupBy.  
0: 		*/
0: 		parent = (FromTable) getNodeFactory().getNode(
0: 										C_NodeTypes.PROJECT_RESTRICT_NODE,
0: 										this, 	// child
0: 										resultColumns,		// result column list
0: 										null,				// restriction
0: 										null,				// restriction list
0: 										null,				// project subqueries
0: 										null,				// restrict subqueries
0: 										tableProperties,
0: 										getContextManager());
0: 
0: 
0: 		/*
0: 		** Reset the bottom RCL to be empty.
0: 		*/
0: 		childResult.setResultColumns((ResultColumnList)
0: 											getNodeFactory().getNode(
0: 												C_NodeTypes.RESULT_COLUMN_LIST,
0: 												getContextManager()));
0: 
0: 		/*
0: 		** Set the group by RCL to be empty
0: 		*/
0: 		resultColumns = (ResultColumnList) getNodeFactory().getNode(
0: 											C_NodeTypes.RESULT_COLUMN_LIST,
0: 											getContextManager());
0: 
0: 	}
0: 
0: 
0: 	/**
0: 	 * Add a whole slew of columns needed for 
0: 	 * aggregation. Basically, for each aggregate we add
0: 	 * 2 columns: the aggregate input expression
0: 	 * and the aggregator column.  The input expression is
0: 	 * taken directly from the aggregator node.  The aggregator
0: 	 * is the run time aggregator.  We add it to the RC list
0: 	 * as a new object coming into the sort node.
0: 	 * <P>
0: 	 * At this point this is invoked, we have the following
0: 	 * tree: <UL>
0: 	 *      PR - (PARENT): RCL is the original select list
0: 	 *       |
0: 	 *      PR - GROUP BY:  RCL is empty
0: 	 *       |
0: 	 *      PR - FROM TABLE: RCL is empty </UL> <P>
0: 	 *
0: 	 * For each ColumnReference in PR RCL <UL>
0: 	 *	<LI> clone the ref </LI>
0: 	 *	<LI> create a new RC in the bottom RCL and set it 
0: 	 *		 to the col ref </LI>
0: 	 *	<LI> create a new RC in the GROUPBY RCL and set it to 
0: 	 *		 point to the bottom RC </LI>
0: 	 *	<LI> reset the top PR ref to point to the new GROUPBY
0: 	 *		 RC	
0: 	 *
0: 	 * For each aggregate in aggregateVector <UL>
0: 	 *	<LI> create RC in FROM TABLE.  Fill it with 
0: 	 * 		aggs Operator.
0: 	 *	<LI> create RC in FROM TABLE for agg result</LI>
0: 	 *	<LI> create RC in FROM TABLE for aggregator</LI>
0: 	 *	<LI> create RC in GROUPBY for agg input, set it
0: 	 *		to point to FROM TABLE RC </LI>
0: 	 *	<LI> create RC in GROUPBY for agg result</LI>
0: 	 *	<LI> create RC in GROUPBY for aggregator</LI>
0: 	 *	<LI> replace Agg with reference to RC for agg result </LI>
0: 	 *
0: 	 * @exception standard exception
0: 	 */
0: 	private void addNewColumnsForAggregation()
0: 		throws StandardException
0: 	{
0: 		/*
0: 		** Now we have two new nodes, the sort and a new PR above
0: 		** it.  They all map to the child result set.  Now we must
0: 		** find every aggregate and massage the tree.  For now we
0: 		** will examine every result column of the original select
0: 		** list.
0: 		*/
0: 		DataDictionary			dd;
0: 		AggregateNode	aggregate = null;
0: 		ColumnReference	newColumnRef;
0: 		ResultColumn	rcBottom;
0: 		ResultColumn	newRC;
0: 		ResultColumn	gbRC;
0: 		ResultColumn	tmpRC;
0: 		ResultColumn	aggInputRC;
0: 		ResultColumnList bottomRCL  = childResult.getResultColumns();
0: 		ResultColumnList groupByRCL = resultColumns;
0: 		ResultColumnList aggRCL;
0: 		int				aggregatorVColId;
0: 		int				aggInputVColId;
0: 		int				aggResultVColId;
0: 
0: 		LanguageFactory lf = getLanguageConnectionContext().getLanguageFactory();
0: 		dd = getDataDictionary();
0: 		aggInfo = new AggregatorInfoList();
0: 
0: 		/*
0: 		** Get a list of all column references in the
0: 		** parent RCL, skipping (not going below) AggregateNodes
0: 		*/
0: 		CollectNodesVisitor getUnaggVisitor = new CollectNodesVisitor(ColumnReference.class, AggregateNode.class);
0: 		parent.getResultColumns().accept(getUnaggVisitor);
0: 		Vector colRefVector = getUnaggVisitor.getList();
0: 
0: 		/*
0: 		** Walk the list of unaggregated column references
0: 		** and push them down.
0: 		*/
0: 		int crvSize = colRefVector.size();
0: 		for (int index = 0; index < crvSize; index++)
0: 		{
0: 			ColumnReference origColumnRef = (ColumnReference) colRefVector.elementAt(index);
0: 			newColumnRef = (ColumnReference)origColumnRef.getClone();
0: 
0: 			/*
0: 			** Put the column reference in the bottom PR.
0: 			*/
0: 			newRC = (ResultColumn) getNodeFactory().getNode(
0: 									C_NodeTypes.RESULT_COLUMN,
0: 									"##UnaggColumn",
0: 									newColumnRef,
0: 									getContextManager());
0: 			newRC.setExpression(newColumnRef);
0: 			bottomRCL.addElement(newRC);
0: 			newRC.markGenerated();
0: 			newRC.bindResultColumnToExpression();
0: 			newRC.setVirtualColumnId(bottomRCL.size());
0: 
0: 			/*
0: 			** Reset the group by column position
0: 			*/
0: 			if (groupingList != null) 
0: 			{
0: 				GroupByColumn	gbColumn;
0: 				if ((gbColumn = 
0: 						groupingList.containsColumnReference(newColumnRef)) 
0: 					!= null)
0: 				{
0: 					gbColumn.setColumnPosition(bottomRCL.size());
0: 				}
0: 			}
0: 		
0: 			/*
0: 			** Add the column to the group by list
0: 			*/
0: 			gbRC = getColumnReference(newRC, dd);
0: 			groupByRCL.addElement(gbRC);
0: 			gbRC.markGenerated();
0: 			gbRC.bindResultColumnToExpression();
0: 			gbRC.setVirtualColumnId(groupByRCL.size());
0: 	
0: 			/*
0: 			** Reset the original node to point to the
0: 			** Group By result set.
0: 			*/
0: 			origColumnRef.setSource(gbRC);
0: 		}
0: 		/*
0: 		** Now process all of the aggregates.  Replace
0: 		** every aggregate with an RC.  We toss out
0: 		** the list of RCs, we need to get each RC
0: 		** as we process its corresponding aggregate.
0: 		*/
0: 		ReplaceAggregatesWithCRVisitor replaceAggsVisitor = 
0: 			new ReplaceAggregatesWithCRVisitor(
0: 					(ResultColumnList) getNodeFactory().getNode(
0: 										C_NodeTypes.RESULT_COLUMN_LIST,
0: 										getContextManager()),
0: 					((FromTable) childResult).getTableNumber());
0: 		parent.getResultColumns().accept(replaceAggsVisitor);
0: 
0: 		/*
0: 		** For each aggregate
0: 		*/
0: 		int alSize = aggregateVector.size();
0: 		for (int index = 0; index < alSize; index++)
0: 		{
0: 			aggregate = (AggregateNode) aggregateVector.elementAt(index);
0: 
0: 			/*
0: 			** AGG RESULT: Set the aggregate result to null in the
0: 			** bottom project restrict.
0: 			*/
0: 			newRC = (ResultColumn) getNodeFactory().getNode(
0: 										C_NodeTypes.RESULT_COLUMN,
0: 										"##aggregate result",
0: 										aggregate.getNewNullResultExpression(),
0: 										getContextManager());
0: 			newRC.markGenerated();
0: 			newRC.bindResultColumnToExpression();
0: 			bottomRCL.addElement(newRC);
0: 			newRC.setVirtualColumnId(bottomRCL.size());
0: 			aggResultVColId = newRC.getVirtualColumnId();
0: 
0: 			/*
0: 			** Set the GB aggregrate result column to
0: 			** point to this.  The GB aggregate result
0: 			** was created when we called
0: 			** ReplaceAggregatesWithColumnReferencesVisitor()
0: 			*/
0: 			newColumnRef = (ColumnReference) getNodeFactory().getNode(
0: 												C_NodeTypes.COLUMN_REFERENCE,
0: 												newRC.getName(),
0: 												null,
0: 												getContextManager());
0: 			newColumnRef.setSource(newRC);
0: 			newColumnRef.setType(newRC.getExpressionType());
0: 			newColumnRef.setNestingLevel(this.getLevel());
0: 			newColumnRef.setSourceLevel(this.getLevel());
0: 			tmpRC = (ResultColumn) getNodeFactory().getNode(
0: 								C_NodeTypes.RESULT_COLUMN,
0: 								newRC.getColumnName(),
0: 								newColumnRef,
0: 								getContextManager());
0: 			tmpRC.markGenerated();
0: 			tmpRC.bindResultColumnToExpression();
0: 			groupByRCL.addElement(tmpRC);
0: 			tmpRC.setVirtualColumnId(groupByRCL.size());
0: 
0: 			/*
0: 			** Set the column reference to point to
0: 			** this.
0: 			*/
0: 			newColumnRef = aggregate.getGeneratedRef();
0: 			newColumnRef.setSource(tmpRC);
0: 
0: 			/*
0: 			** AGG INPUT: Create a ResultColumn in the bottom 
0: 			** project restrict that has the expression that is
0: 			** to be aggregated
0: 			*/
0: 			newRC = aggregate.getNewExpressionResultColumn(dd);
0: 			newRC.markGenerated();
0: 			newRC.bindResultColumnToExpression();
0: 			bottomRCL.addElement(newRC);
0: 			newRC.setVirtualColumnId(bottomRCL.size());
0: 			aggInputVColId = newRC.getVirtualColumnId();
0: 			aggInputRC = newRC;
0: 	
0: 			/*
0: 			** Add a reference to this column into the
0: 			** group by columns.
0: 			*/
0: 			tmpRC = getColumnReference(newRC, dd);
0: 			groupByRCL.addElement(tmpRC);
0: 			tmpRC.setVirtualColumnId(groupByRCL.size());
0: 
0: 			/*
0: 			** AGGREGATOR: Add a getAggregator method call 
0: 			** to the bottom result column list.
0: 			*/
0: 			newRC = aggregate.getNewAggregatorResultColumn(dd);
0: 			newRC.markGenerated();
0: 			newRC.bindResultColumnToExpression();
0: 			bottomRCL.addElement(newRC);
0: 			newRC.setVirtualColumnId(bottomRCL.size());
0: 			aggregatorVColId = newRC.getVirtualColumnId();
0: 
0: 			/*
0: 			** Add a reference to this column in the Group By result
0: 			** set.
0: 			*/
0: 			tmpRC = getColumnReference(newRC, dd);
0: 			groupByRCL.addElement(tmpRC);
0: 			tmpRC.setVirtualColumnId(groupByRCL.size());
0: 
0: 			/*
0: 			** Piece together a fake one column rcl that we will use
0: 			** to generate a proper result description for input
0: 			** to this agg if it is a user agg.
0: 			*/
0: 			aggRCL = (ResultColumnList) getNodeFactory().getNode(
0: 											C_NodeTypes.RESULT_COLUMN_LIST,
0: 											getContextManager());
0: 			aggRCL.addElement(aggInputRC);
0: 
0: 			/*
0: 			** Note that the column ids in the row are 0 based
0: 			** so we have to subtract 1.
0: 			*/
0: 			aggInfo.addElement(new AggregatorInfo(
0: 							aggregate.getAggregateName(),
0: 							aggregate.getAggregatorClassName(),
0: 							aggInputVColId - 1,			// aggregate input column
0: 							aggResultVColId -1,			// the aggregate result column
0: 							aggregatorVColId - 1,		// the aggregator column	
0: 							aggregate.isDistinct(),
0: 							lf.getResultDescription(aggRCL.makeResultDescriptors(), "SELECT")
0: 						));
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Return the parent node to this one, if there is
0: 	 * one.  It will return 'this' if there is no generated
0: 	 * node above this one.
0: 	 *
0: 	 * @return the parent node
0: 	 */
0: 	public FromTable getParent()
0: 	{
0: 		return parent;
0: 	}
0: 
0: 
0: 	/*
0: 	 *  Optimizable interface
0: 	 */
0: 
0: 	/**
0: 	 * @see Optimizable#optimizeIt
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public CostEstimate optimizeIt(
0: 							Optimizer optimizer,
0: 							OptimizablePredicateList predList,
0: 							CostEstimate outerCost,
0: 							RowOrdering rowOrdering)
0: 			throws StandardException
0: 	{
0: 		// RESOLVE: NEED TO FACTOR IN THE COST OF GROUPING (SORTING) HERE
0: 		CostEstimate childCost = ((Optimizable) childResult).optimizeIt(
0: 													optimizer,
0: 													predList,
0: 													outerCost,
0: 													rowOrdering);
0: 
0: 		CostEstimate retval = super.optimizeIt(
0: 												optimizer,
0: 												predList,
0: 												outerCost,
0: 												rowOrdering
0: 											  );
0: 
0: 		return retval;
0: 	}
0: 
0: 	/**
0: 	 * @see Optimizable#estimateCost
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public CostEstimate estimateCost(OptimizablePredicateList predList,
0: 										ConglomerateDescriptor cd,
0: 										CostEstimate outerCost,
0: 										Optimizer optimizer,
0: 										RowOrdering rowOrdering
0: 										)
0: 			throws StandardException
0: 	{
0: 		// RESOLVE: NEED TO FACTOR IN THE COST OF GROUPING (SORTING) HERE
0: 		//
0: 		CostEstimate childCost = ((Optimizable) childResult).estimateCost(
0: 													predList,
0: 													cd,
0: 													outerCost,
0: 													optimizer,
0: 													rowOrdering);
0: 
0: 		CostEstimate costEstimate = getCostEstimate(optimizer);
0: 		costEstimate.setCost(childCost.getEstimatedCost(),
0: 							childCost.rowCount(),
0: 							childCost.singleScanRowCount());
0: 
0: 		return costEstimate;
0: 	}
0: 
0: 	/**
0: 	 * @see org.apache.derby.iapi.sql.compile.Optimizable#pushOptPredicate
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public boolean pushOptPredicate(OptimizablePredicate optimizablePredicate)
0: 			throws StandardException
0: 	{
0: 		return ((Optimizable) childResult).pushOptPredicate(optimizablePredicate);
0: 	}
0: 
0: 	/**
0: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
0: 	 * for how this should be done for tree printing.
0: 	 *
0: 	 * @return	This object as a String
0: 	 */
0: 
0: 	public String toString()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			return "singleInputRowOptimization: " + singleInputRowOptimization + "\n" +
0: 				childResult.toString() + "\n" + super.toString();
0: 		}
0: 		else
0: 		{
0: 			return "";
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Evaluate whether or not the subquery in a FromSubquery is flattenable.
0: 	 * Currently, a FSqry is flattenable if all of the following are true:
0: 	 *		o  Subquery is a SelectNode.
0: 	 *		o  It contains no top level subqueries.  (RESOLVE - we can relax this)
0: 	 *		o  It does not contain a group by or having clause
0: 	 *		o  It does not contain aggregates.
0: 	 *
0: 	 * @param fromList	The outer from list
0: 	 *
0: 	 * @return boolean	Whether or not the FromSubquery is flattenable.
0: 	 */
0: 	public boolean flattenableInFromSubquery(FromList fromList)
0: 	{
0: 		/* Can't flatten a GroupByNode */
0: 		return false;
0: 	}
0: 
0: 	/**
0: 	 * Optimize this GroupByNode.
0: 	 *
0: 	 * @param dataDictionary	The DataDictionary to use for optimization
0: 	 * @param predicateList		The PredicateList to optimize.  This should
0: 	 *							be a join predicate.
0: 	 * @param outerRows			The number of outer joining rows
0: 	 *
0: 	 * @return	ResultSetNode	The top of the optimized subtree
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public ResultSetNode optimize(DataDictionary dataDictionary,
0: 								  PredicateList predicates,
0: 								  double outerRows)
0: 					throws StandardException
0: 	{
0: 		/* We need to implement this method since a PRN can appear above a
0: 		 * SelectNode in a query tree.
0: 		 */
0: 		childResult = (FromTable) childResult.optimize(
0: 											dataDictionary,
0: 											predicates,
0: 											outerRows);
0: 		Optimizer optimizer = getOptimizer(
0: 						(FromList) getNodeFactory().getNode(
0: 									C_NodeTypes.FROM_LIST,
0: 									getNodeFactory().doJoinOrderOptimization(),
0: 									getContextManager()),
0: 						predicates,
0: 						dataDictionary,
0: 						(RequiredRowOrdering) null);
0: 
0: 		// RESOLVE: NEED TO FACTOR IN COST OF SORTING AND FIGURE OUT HOW
0: 		// MANY ROWS HAVE BEEN ELIMINATED.
0: 		costEstimate = optimizer.newCostEstimate();
0: 
0: 		costEstimate.setCost(childResult.getCostEstimate().getEstimatedCost(),
0: 							childResult.getCostEstimate().rowCount(),
0: 							childResult.getCostEstimate().singleScanRowCount());
0: 
0: 		return this;
0: 	}
0: 
0: 	ResultColumnDescriptor[] makeResultDescriptors(ExecutionContext ec)
0: 	{
0: 	    return childResult.makeResultDescriptors(ec);
0: 	}
0: 
0: 	/**
0: 	 * Return whether or not the underlying ResultSet tree will return
0: 	 * a single row, at most.
0: 	 * This is important for join nodes where we can save the extra next
0: 	 * on the right side if we know that it will return at most 1 row.
0: 	 *
0: 	 * @return Whether or not the underlying ResultSet tree will return a single row.
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public boolean isOneRowResultSet()	throws StandardException
0: 	{
0: 		// Only consider scalar aggregates for now
0: 		return ((groupingList == null) ||  (groupingList.size() == 0));
0: 	}
0: 
0:     /**
0:      * generate the sort result set operating over the source
0: 	 * resultset.  Adds distinct aggregates to the sort if
0: 	 * necessary.
0:      *
0: 	 * @exception StandardException		Thrown on error
0:      */
0: 	public void generate(ActivationClassBuilder acb,
0: 								MethodBuilder mb)
0: 							throws StandardException
0: 	{
0: 		int					orderingItem = 0;
0: 		int					aggInfoItem = 0;
0: 		FormatableArrayHolder	orderingHolder;
0: 
0: 		/* Get the next ResultSet#, so we can number this ResultSetNode, its
0: 		 * ResultColumnList and ResultSet.
0: 		 */
0: 		assignResultSetNumber();
0: 
0: 		// Get the cost estimate from the child if we don't have one yet
0: 		if (costEstimate == null)
0: 		{
0: 			costEstimate = childResult.getFinalCostEstimate();
0: 		}
0: 
0: 		/*
0: 		** Get the column ordering for the sort.  Note that
0: 		** for a scalar aggegate we may not have any ordering
0: 		** columns (if there are no distinct aggregates).
0: 		** WARNING: if a distinct aggregate is passed to
0: 		** SortResultSet it assumes that the last column
0: 		** is the distinct one.  If this assumption changes
0: 		** then SortResultSet will have to change.
0: 		*/
0: 		orderingHolder = acb.getColumnOrdering(groupingList);
0: 		if (addDistinctAggregate)
0: 		{
0: 			orderingHolder = acb.addColumnToOrdering(
0: 									orderingHolder,
0: 									addDistinctAggregateColumnNum);
0: 		}
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (SanityManager.DEBUG_ON("AggregateTrace"))
0: 			{
0: 				StringBuffer s = new StringBuffer();
0: 					
0: 				s.append("Group by column ordering is (");
0: 				ColumnOrdering[] ordering = 
0: 						(ColumnOrdering[])orderingHolder.getArray(ColumnOrdering.class);
0: 
0: 				for (int i = 0; i < ordering.length; i++)	
0: 				{
0: 					s.append(ordering[i].getColumnId());
0: 					s.append(" ");
0: 				}
0: 				s.append(")");
0: 				SanityManager.DEBUG("AggregateTrace", s.toString());
0: 			}
0: 		}
0: 
0: 		orderingItem = acb.addItem(orderingHolder);
0: 
0: 		/*
0: 		** We have aggregates, so save the aggInfo
0: 		** struct in the activation and store the number
0: 		*/
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(aggInfo != null,
0: 					"aggInfo not set up as expected");
0: 		}
0: 		aggInfoItem = acb.addItem(aggInfo);
0: 
0: 		acb.pushGetResultSetFactoryExpression(mb);
0: 
0: 		// Generate the child ResultSet
0: 		childResult.generate(acb, mb);
0: 		mb.push(isInSortedOrder);
0: 		mb.push(aggInfoItem);
0: 		mb.push(orderingItem);
0: 		acb.pushThisAsActivation(mb);
0: 
0: 		resultColumns.generateHolder(acb, mb);
0: 
0: 		mb.push(resultColumns.getTotalColumnSize());
0: 		mb.push(resultSetNumber);
0: 
0: 		/* Generate a (Distinct)ScalarAggregateResultSet if scalar aggregates */
0: 		if ((groupingList == null) ||  (groupingList.size() == 0))
0: 		{
0: 			genScalarAggregateResultSet(acb, mb);
0: 		}
0: 		/* Generate a (Distinct)GroupedAggregateResultSet if grouped aggregates */
0: 		else
0: 		{
0: 			genGroupedAggregateResultSet(acb, mb);
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Generate the code to evaluate scalar aggregates.
0: 	 *
0: 	 */
0: 	private	void genScalarAggregateResultSet(ActivationClassBuilder acb,
0: 												   MethodBuilder mb)
0: 	{
0: 		/* Generate the (Distinct)ScalarAggregateResultSet:
0: 		 *	arg1: childExpress - Expression for childResult
0: 		 *  arg2: isInSortedOrder - true if source result set in sorted order
0: 		 *  arg3: aggregateItem - entry in saved objects for the aggregates,
0: 		 *  arg4: orderItem - entry in saved objects for the ordering
0: 		 *  arg5: Activation
0: 		 *  arg6: rowAllocator - method to construct rows for fetching
0: 		 *			from the sort
0: 		 *  arg7: row size
0: 		 *  arg8: resultSetNumber
0: 		 *  arg9: Whether or not to perform min optimization.
0: 		 *  arg12: closeCleanup
0: 		 */
0: 		String resultSet = (addDistinctAggregate) ? "getDistinctScalarAggregateResultSet" : "getScalarAggregateResultSet";
0: 
0: 		mb.push(singleInputRowOptimization);
0: 		mb.push(costEstimate.rowCount());
0: 		mb.push(costEstimate.getEstimatedCost());
0: 
0: 		closeMethodArgument(acb, mb);
0: 
0: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, resultSet, ClassName.NoPutResultSet, 12);
0: 	}
0: 
0: 	/**
0: 	 * Generate the code to evaluate grouped aggregates.
0: 	 *
0: 	 */
0: 	private	void genGroupedAggregateResultSet(ActivationClassBuilder acb,
0: 												   MethodBuilder mb)
0: 				throws StandardException
0: 	{
0: 		/* Generate the (Distinct)GroupedAggregateResultSet:
0: 		 *	arg1: childExpress - Expression for childResult
0: 		 *  arg2: isInSortedOrder - true if source result set in sorted order
0: 		 *  arg3: aggregateItem - entry in saved objects for the aggregates,
0: 		 *  arg4: orderItem - entry in saved objects for the ordering
0: 		 *  arg5: Activation
0: 		 *  arg6: rowAllocator - method to construct rows for fetching
0: 		 *			from the sort
0: 		 *  arg7: row size
0: 		 *  arg8: resultSetNumber
0: 		 *  arg11: closeCleanup
0: 		 */
0: 		String resultSet = (addDistinctAggregate) ? "getDistinctGroupedAggregateResultSet" : "getGroupedAggregateResultSet";
0:     
0: 		mb.push(costEstimate.rowCount());
0: 		mb.push(costEstimate.getEstimatedCost());
0: 
0: 		closeMethodArgument(acb, mb);
0: 
0: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, resultSet, ClassName.NoPutResultSet, 11);
0: 
0: 	}
0: 
0: 	///////////////////////////////////////////////////////////////
0: 	//
0: 	// UTILITIES
0: 	//
0: 	///////////////////////////////////////////////////////////////
0: 	/**
0: 	 * Method for creating a new result column referencing
0: 	 * the one passed in.
0: 	 *
0: 	 * @param	targetRC	the source
0: 	 * @param	dd
0: 	 *
0: 	 * @return the new result column
0: 	 *
0: 	 * @exception StandardException	on error
0: 	 */
0: 	private ResultColumn getColumnReference(ResultColumn targetRC, 
0: 								DataDictionary		dd)
0: 		throws StandardException
0: 	{
0: 		ColumnReference	tmpColumnRef;
0: 		ResultColumn	newRC;
0: 	
0: 		tmpColumnRef = (ColumnReference) getNodeFactory().getNode(
0: 											C_NodeTypes.COLUMN_REFERENCE,
0: 											targetRC.getName(),
0: 											null,
0: 											getContextManager());
0: 		tmpColumnRef.setSource(targetRC);
0: 		tmpColumnRef.setType(targetRC.getExpressionType());
0: 		tmpColumnRef.setNestingLevel(this.getLevel());
0: 		tmpColumnRef.setSourceLevel(this.getLevel());
0: 		newRC = (ResultColumn) getNodeFactory().getNode(
0: 									C_NodeTypes.RESULT_COLUMN,
0: 									targetRC.getColumnName(),
0: 									tmpColumnRef,
0: 									getContextManager());
0: 		newRC.markGenerated();
0: 		newRC.bindResultColumnToExpression();
0: 		return newRC;
0: 	}
0: 
0: 	/**
0: 	 * Consider any optimizations after the optimizer has chosen a plan.
0: 	 * Optimizations include:
0: 	 *	o  min optimization for scalar aggregates
0: 	 *	o  max optimization for scalar aggregates
0: 	 *
0: 	 * @param selectHasPredicates true if SELECT containing this
0: 	 *		vector/scalar aggregate has a restriction
0: 	 *
0: 	 * @return Nothing.
0: 	 *
0: 	 * @exception StandardException	on error
0: 	 */
0: 	void considerPostOptimizeOptimizations(boolean selectHasPredicates)
0: 		throws StandardException
0: 	{
0: 		/* Consider the optimization for min with asc index on that column or
0: 		 * max with desc index on that column:
0: 		 *	o  No group by
0: 		 *  o  One of:
0: 		 *		o  min/max(ColumnReference) is only aggregate && source is 
0: 		 *		   ordered on the ColumnReference
0: 		 *		o  min/max(ConstantNode)
0: 		 * The optimization of the other way around (min with desc index or
0: 		 * max with asc index) has the same restrictions with the additional
0: 		 * temporary restriction of no qualifications at all (because
0: 		 * we don't have true backward scans).
0: 		 */
0: 		if (groupingList == null)
0: 		{
0: 			if (aggregateVector.size() == 1)
0: 			{
0: 				AggregateNode an = (AggregateNode) aggregateVector.elementAt(0);
0: 				AggregateDefinition ad = an.getAggregateDefinition();
0: 				if (ad instanceof MaxMinAggregateDefinition)
0: 				{
0: 					if (an.getOperand() instanceof ColumnReference)
0: 					{
0: 						/* See if the underlying ResultSet tree
0: 						 * is ordered on the ColumnReference.
0: 						 */
0: 						ColumnReference[] crs = new ColumnReference[1];
0: 						crs[0] = (ColumnReference) an.getOperand();
0: 						
0: 						Vector tableVector = new Vector();
0: 						boolean minMaxOptimizationPossible = isOrderedOn(crs, false, tableVector);
0: 						if (SanityManager.DEBUG)
0: 						{
0: 							SanityManager.ASSERT(tableVector.size() <= 1, "bad number of FromBaseTables returned by isOrderedOn() -- "+tableVector.size());
0: 						}
0: 
0: 						if (minMaxOptimizationPossible)
0: 						{
0: 							boolean ascIndex = true;
0: 							int colNum = crs[0].getColumnNumber();
0: 							
0: 							/* Check if we have an access path, this will be
0: 							 * null in a join case (See Beetle 4423)
0: 							 */
0: 							AccessPath accessPath= getTrulyTheBestAccessPath();
0: 							if (accessPath == null)
0: 								return;
0: 							IndexDescriptor id = accessPath.
0: 												getConglomerateDescriptor().
0: 												getIndexDescriptor();
0: 							int[] keyColumns = id.baseColumnPositions();
0: 							boolean[] isAscending = id.isAscending();
0: 							for (int i = 0; i < keyColumns.length; i++)
0: 							{
0: 								/* in such a query: select min(c3) from
0: 								 * tab1 where c1 = 2 and c2 = 5, if prefix keys
0: 								 * have equality operator, then we can still use
0: 								 * the index.  The checking of equality operator
0: 								 * has been done in isStrictlyOrderedOn.
0: 								 */
0: 								if (colNum == keyColumns[i])
0: 								{
0: 									if (! isAscending[i])
0: 										ascIndex = false;
0: 									break;
0: 								}
0: 							}
0: 							FromBaseTable fbt = (FromBaseTable)tableVector.firstElement();
0: 							MaxMinAggregateDefinition temp = (MaxMinAggregateDefinition)ad;
0: 
0: 							/*  MAX   ASC      NULLABLE 
0:                              *  ----  ----------
0: 							 *  TRUE  TRUE      TRUE/FALSE  =  Special Last Key Scan (ASC Index Last key with null skips)
0: 							 *  TRUE  FALSE     TRUE/FALSE  =  JustDisableBulk(DESC index 1st key with null skips)
0: 							 *  FALSE TRUE      TRUE/FALSE  = JustDisableBulk(ASC index 1st key)
0: 							 *  FALSE FALSE     TRUE/FALSE  = Special Last Key Scan(Desc Index Last Key)
0: 							 */
0: 
0: 							if (((!temp.isMax()) && ascIndex) || 
0: 								((temp.isMax()) && !ascIndex))
0: 							{
0: 								fbt.disableBulkFetch();
0: 								singleInputRowOptimization = true;
0: 							}
0: 							/*
0: 							** Max optimization with asc index or min with
0: 							** desc index is currently more
0: 							** restrictive than otherwise.
0: 							** We are getting the store to return the last
0: 							** row from an index (for the time being, the
0: 							** store cannot do real backward scans).  SO
0: 							** we cannot do this optimization if we have
0: 							** any predicates at all.
0: 							*/
0: 							else if (!selectHasPredicates && 
0: 									 ((temp.isMax() && ascIndex) || 
0: 									  (!temp.isMax() && !ascIndex )))
0: 							{
0: 								fbt.disableBulkFetch();
0: 								fbt.doSpecialMaxScan();
0: 								singleInputRowOptimization = true;
0: 							}
0: 						}
0: 					}
0: 					else if (an.getOperand() instanceof ConstantNode)
0: 					{
0: 						singleInputRowOptimization = true;
0: 					}
0: 				}
0: 			}
0: 		}
0: 	}
0: }
============================================================================