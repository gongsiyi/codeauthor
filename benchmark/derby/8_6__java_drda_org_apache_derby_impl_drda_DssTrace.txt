1:eac0369: /*
1:d7258ed: 
1:d7258ed:    Derby - Class org.apache.derby.impl.drda.DssTrace
1:d7258ed: 
1:59e5225:    Licensed to the Apache Software Foundation (ASF) under one or more
1:59e5225:    contributor license agreements.  See the NOTICE file distributed with
1:59e5225:    this work for additional information regarding copyright ownership.
1:59e5225:    The ASF licenses this file to You under the Apache License, Version 2.0
1:59e5225:    (the "License"); you may not use this file except in compliance with
1:59e5225:    the License.  You may obtain a copy of the License at
1:d7258ed: 
1:d7258ed:       http://www.apache.org/licenses/LICENSE-2.0
1:d7258ed: 
1:d7258ed:    Unless required by applicable law or agreed to in writing, software
1:d7258ed:    distributed under the License is distributed on an "AS IS" BASIS,
1:d7258ed:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:d7258ed:    See the License for the specific language governing permissions and
1:d7258ed:    limitations under the License.
10:eac0369: 
2:eac0369:  */
1:eac0369: package org.apache.derby.impl.drda;
1:eac0369: 
1:45680ff: import java.io.File;
1:d835c40: import java.io.FileNotFoundException;
1:5028317: import java.io.IOException;
1:5028317: import java.io.PrintWriter;
1:5028317: import java.security.AccessController;
1:5028317: import java.security.PrivilegedActionException;
1:5028317: import java.security.PrivilegedExceptionAction;
1:dc43cf8: import org.apache.derby.iapi.services.io.FileUtil;
1:45680ff: 
1:eac0369: // Generic process and error tracing encapsulation.
1:eac0369: // This class also traces a DRDA communications buffer.
1:eac0369: // The value of the hex bytes are traced along with
1:eac0369: // the ascii and ebcdic translations.
1:eac0369: public class DssTrace
2:eac0369: {
1:eac0369:   // This class was implemented using character arrays to translate bytes
1:eac0369:   // into ascii and ebcdic.  The goal was to be able to quickly index into the
1:eac0369:   // arrays to find the characters.  Char arrays instead of strings were used as
1:eac0369:   // much as possible in an attempt to help speed up performance.
1:eac0369:   private static final String LIST_SEPARATOR = " # ";
1:5028317: 
1:eac0369:   // trace representation for a java null.
1:eac0369:   private static final String NULL_VALUE = "null";
1:5028317: 
1:eac0369:   // An array of characters used to translate bytes to ascii.
1:eac0369:   // The position in the array corresponds to the hex value of the
1:eac0369:   // character
1:eac0369:   private static final char asciiChar [] = {
1:eac0369:     // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
1:eac0369:     '.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.',  //0
1:eac0369:     '.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.',  //1
1:eac0369:     ' ','!','"','#','$','%','&','\'','(',')','*','+',',','-','.','/', //2
1:eac0369:     '0','1','2','3','4','5','6','7','8','9',':',';','<','=','>','?',  //3
1:eac0369:     '@','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O',  //4
1:eac0369:     'P','Q','R','S','T','U','V','W','X','Y','Z','[','\\',']','^','_', //5
1:eac0369:     '`','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o',  //6
1:eac0369:     'p','q','r','s','t','u','v','w','x','y','z','{','|','}','~','.',  //7
1:eac0369:     '.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.',  //8
1:eac0369:     '.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.',  //9
1:eac0369:     '.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.',  //A
1:eac0369:     '.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.',  //B
1:eac0369:     '.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.',  //C
1:eac0369:     '.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.',  //D
1:eac0369:     '.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.',  //E
1:eac0369:     '.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.'   //F
1:eac0369:   };
1:eac0369: 
1:eac0369: 
1:eac0369:   // This mapping table associates a codepoint to a String describing the codepoint.
1:eac0369:   // This is needed because the trace prints the
1:eac0369:   // first codepoint in send and receive buffers.
1:eac0369:   // This could be final but there is no need to create the mapping
1:eac0369:   // if tracing isn't used.  So... this array will only be created when
1:eac0369:   // the com buffer trace is started.  Note this ref is not protected
1:eac0369:   // by final and care must be taken if it's value needs to change.
1:eac0369:   private static CodePointNameTable codePointNameTable = null;
1:eac0369: 
1:eac0369:   // This column position header is used to mark offsets into the trace.
1:eac0369:   private static final String colPosHeader =
1:eac0369:   "       0 1 2 3 4 5 6 7   8 9 A B C D E F   0123456789ABCDEF  0123456789ABCDEF";
1:eac0369: 
1:eac0369:   // An array of characters used to translate bytes to ebcdic.
1:eac0369:   // The position in the array corresponds to the hex value of the
1:eac0369:   // character.
1:eac0369:   private static final char ebcdicChar[] = {
1:eac0369:     // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
1:eac0369:     '.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.',  //0
1:eac0369:     '.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.',  //1
1:eac0369:     '.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.',  //2
1:eac0369:     '.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.',  //3
1:eac0369:     ' ','.','.','.','.','.','.','.','.','.','.','.','<','(','+','|',  //4
1:eac0369:     '&','.','.','.','.','.','.','.','.','.','!','$','*',')',';','.',  //5
1:eac0369:     '-','/','.','.','.','.','.','.','.','.','|',',','%','_','>','?',  //6
1:eac0369:     '.','.','.','.','.','.','.','.','.','`',':','#','@','\'','=','"', //7
1:eac0369:     '.','a','b','c','d','e','f','g','h','i','.','.','.','.','.','.',  //8
1:eac0369:     '.','j','k','l','m','n','o','p','q','r','.','.','.','.','.','.',  //9
1:eac0369:     '.','~','s','t','u','v','w','x','y','z','.','.','.','.','.','.',  //A
1:eac0369:     '.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.',  //B
1:eac0369:     '{','A','B','C','D','E','F','G','H','I','.','.','.','.','.','.',  //C
1:eac0369:     '}','J','K','L','M','N','O','P','Q','R','.','.','.','.','.','.',  //D
1:eac0369:     '\\','.','S','T','U','V','W','X','Y','Z','.','.','.','.','.','.', //E
1:eac0369:     '0','1','2','3','4','5','6','7','8','9','.','.','.','.','.','.'   //F
1:eac0369:   };
1:eac0369: 
1:eac0369: 
1:eac0369:   // An array of characters representing hex numbers.
1:5028317:  private static final char hexDigit [] = {
1:eac0369:     '0','1','2','3','4','5','6','7',
1:eac0369:     '8','9','A','B','C','D','E','F'
1:eac0369:   };
1:eac0369: 
1:eac0369: 
1:eac0369:   // A PrintWriter is used in printing the trace.
1:eac0369:   private java.io.PrintWriter comBufferWriter = null;
1:eac0369: 
1:eac0369: 
1:eac0369:   // The receive header comes befor bytes which would be read from
1:eac0369:   // a Stream.
1:eac0369:   private static final String receiveHeader =
1:eac0369:   "       RECEIVE BUFFER:                     (ASCII)           (EBCDIC)";
1:eac0369: 
1:eac0369: 
1:eac0369:   // The send header comes before bytes which would be written to
1:eac0369:   // a Stream.
1:eac0369:   private static final String sendHeader =
1:eac0369:   "       SEND BUFFER:                        (ASCII)           (EBCDIC)";
1:eac0369: 
1:eac0369: 
1:eac0369:   // The space character is defined for convience.
1:eac0369:   private static final char spaceChar = ' ';
1:eac0369: 
1:eac0369: 
1:eac0369:   // This boolean indicates if the trace is on.
1:eac0369:   // It has been declared private now but may be made public at
1:eac0369:   // a later time.
1:eac0369:   private boolean comBufferTraceOn = false;
1:eac0369: 
1:eac0369: 
1:eac0369:   // The comBufferSync is an object used for serialization.
1:eac0369:   // This separate object is used because this trace code may
1:eac0369:   // get eventually placed into another class which performs
1:eac0369:   // method entry and exit tracing.  Since each trace may be writing
1:eac0369:   // to different logs, separate objects will be used to perform the
1:eac0369:   // synchronization.
1:66527ec:   private final Object comBufferSync = new Object();
1:eac0369: 
1:eac0369: 
1:eac0369:   // The zero character is defined for convinience.
1:eac0369:   private static final char zeroChar = '0';
1:eac0369: 
1:eac0369:   // The recevie constant is used to indicate that the bytes were read to a Stream.
1:eac0369:   // It indicates to this class that a receive header should be used.
1:eac0369:   protected static final int TYPE_TRACE_RECEIVE = 2;
1:eac0369: 
1:eac0369:   // The send constant is used to indicate that the bytes were written to
1:eac0369:   // a Stream.  It indicates to this class that a send header should be used.
1:eac0369:   protected static final int TYPE_TRACE_SEND = 1;
1:eac0369: 
1:eac0369:   // Query if trace is on.
1:eac0369:   // This is currently needed since the comBufferTrcOn flag is private.
1:eac0369:   protected boolean isComBufferTraceOn()
1:eac0369:   {
1:eac0369:     // The trace flag indicates if tracing is on.
1:eac0369:     return comBufferTraceOn;
7:eac0369:   }
1:5028317: 
1:eac0369:   // Start the communications buffer trace.
1:eac0369:   // The name of the file to place the trace is passed to this method.
1:eac0369:   // After calling this method, calls to isComBufferTraceOn() will return true.
1:45680ff:   protected void startComBufferTrace (final String fileName) throws Exception 
1:eac0369:   {
1:eac0369:     synchronized (comBufferSync) {
1:eac0369:         // Only start the trace if it is off.
1:eac0369:         if (comBufferTraceOn == false) {
1:d835c40:             // Make up to two attempts to create the trace file.
1:d835c40:             // First just try to make it. Then if we get a FileNotFoundException
1:d835c40:             // try making the directory and then retry the create.
1:d835c40:             // We don't try making the directory first because it would require
1:d835c40:             // extra permissions if the directory already exists. DERBY-4128
1:d835c40:             for (int attempt=0; attempt <2; attempt++) {
1:db9a013:                 try {
1:d835c40:                     // The writer will be buffered for effeciency.
1:dc43cf8:                     comBufferWriter =
1:27fbf33:                         (AccessController.doPrivileged(
1:27fbf33:                             new PrivilegedExceptionAction<PrintWriter>() {
1:27fbf33:                                 public PrintWriter run()
1:dc43cf8:                                         throws SecurityException, IOException {
1:dc43cf8:                                     File f = new File(fileName);
1:dc43cf8:                                     boolean exists = f.exists();
1:dc43cf8:                                     PrintWriter pw =
1:dc43cf8:                                         new PrintWriter(
1:dc43cf8:                                             new java.io.BufferedWriter(
1:dc43cf8:                                                 new java.io.FileWriter(
1:dc43cf8:                                                     fileName),
1:dc43cf8:                                                 4096));
1:dc43cf8:                                     if (!exists) {
1:dc43cf8:                                         FileUtil.limitAccessToOwner(f);
1:45680ff:                                     }
1:dc43cf8:                                     return pw;
1:5028317:                                 }
1:5028317:                             }));
1:229ef39:                     // If we successfully made the file. break out here and don't retry
1:229ef39:                     break;
1:d835c40:                 } catch (PrivilegedActionException pae) {
1:d835c40:                     Exception e = pae.getException();
1:d835c40:                     // If we got a FileNotFoundException on the first attempt,
1:d835c40:                     // it is likely that the directory did not exist. 
1:d835c40:                     //We will try to make it.
1:d835c40:                     if (attempt == 0 && (e instanceof FileNotFoundException)) {
1:d835c40:                         final File traceDirectory = new File(fileName).getParentFile();
1:d835c40:                         if (traceDirectory != null) {
1:d835c40:                             AccessController.doPrivileged(
1:4f7eee8:                                     new PrivilegedExceptionAction<Void>() {
1:4f7eee8:                                         public Void run() throws IOException {
1:d835c40:                                             // DERBY-4128: First try to create the
1:d835c40:                                             // directory with mkdir(), as that doesn't
1:d835c40:                                             // require read permission for the parent
1:d835c40:                                             // directory. It will only succeed if the
1:d835c40:                                             // parent directory exists. If mkdir()
1:d835c40:                                             // fails, retry with mkdirs(), which will
1:d835c40:                                             // create the parent directories as needed,
1:d835c40:                                             // but which also requires that read
1:d835c40:                                             // permission for the parent directory
1:d835c40:                                             // has been granted.
1:d835c40:                                             boolean created = traceDirectory.mkdir();
1:d835c40:                                             if (!created) {
1:dc43cf8:                                                 created =
1:d835c40:                                                         traceDirectory.mkdirs();
1:d835c40:                                             }
1:45680ff: 
1:dc43cf8:                                             if (created) {
1:dc43cf8:                                                 FileUtil.limitAccessToOwner(
1:dc43cf8:                                                         traceDirectory);
1:5028317:                                             }
1:d835c40:                                             return null;
1:d835c40:                                         }
1:d835c40:                                     });
1:d835c40: 
1:d835c40:                         }
1:d835c40:                     } else {
1:d835c40:                         // This is our second attempt or we got some other exception besides
1:d835c40:                         // FileNotFoundException. Just throw the exception.
1:d835c40:                         throw e;
1:4f996a4:                     }
1:d835c40:                 }
1:d835c40:             }
1:eac0369:           // Turn on the trace flag.
1:eac0369:           comBufferTraceOn = true;
1:eac0369:           // initialize the codepoint name table if it is null.
1:eac0369:           // this is done here so that the CodePointName objects
1:eac0369:           // aren't created if the trace isn't used (save some memory).
1:eac0369:           // this process should only be done once
1:eac0369:           // since after the table is created the ref will
1:eac0369:           // no longer be null.
1:eac0369:           if (DssTrace.codePointNameTable == null) {
1:eac0369:             codePointNameTable = new CodePointNameTable();
1:d835c40:           }
1:dc43cf8:         }
1:dc43cf8:       }
1:6588222:     }
1:5028317:   
1:5028317: 
1:eac0369:   // Stop the communications buffer trace.
1:eac0369:   // The trace file is flushed and closed.  After calling this method,
1:eac0369:   // calls to isComBufferTraceOn () will return false.
1:eac0369:   protected void stopComBufferTrace ()
1:45680ff:   {
1:eac0369:     synchronized (comBufferSync) {
1:eac0369:       // Only stop the trace if it is actually on.
1:eac0369:       if (comBufferTraceOn == true) {
1:eac0369:         // Turn of the trace flag.
1:eac0369:         comBufferTraceOn = false;
1:eac0369:         // Flush and close the writer used for tracing.
1:5028317:         if (comBufferWriter != null)
1:5028317:         {
1:5028317:             comBufferWriter.flush();
1:5028317:             comBufferWriter.close();
1:5028317:         }
1:eac0369:       }
1:eac0369:     }
1:eac0369:   }
1:dc43cf8: 
1:eac0369:   // Write the communication buffer data to the trace.
1:eac0369:   // The data is passed in via a byte array.  The start and length of the data is given.
1:eac0369:   // The type is needed to indicate if the data is part of the send or receive buffer.
1:eac0369:   // The class name, method name, and trcPt number are also written to the trace.
1:eac0369:   // Not much checking is performed on the parameters.  This is done to help performance.
1:eac0369:   protected void writeComBufferData (byte[] buff,
1:eac0369:                                          int offset,
1:eac0369:                                          int len,
1:eac0369:                                          int type,
1:eac0369:                                          String className,
1:eac0369:                                          String methodName,
1:eac0369:                                          int trcPt)
1:eac0369:   {
1:eac0369:     // why don't we synchronize the method!!!
1:6588222: 
1:eac0369:     // Grab the lock to make sure another thread doesn't try to
1:eac0369:     // write data or close the writer.
1:eac0369:     synchronized (comBufferSync) {
1:eac0369: 
1:eac0369:       // Only take action if the trace is on.
1:eac0369:       if (comBufferTraceOn) {
1:eac0369: 
1:eac0369:         // Obtain an instance of the Calendar so a timestamp can be written.
1:eac0369:         // this call seems to slow things down a bit.
1:eac0369:         java.util.Calendar time = java.util.Calendar.getInstance();
1:eac0369: 
1:eac0369:         // Print the timestamp, class name, method name, thread name, and tracepoint.
1:eac0369:         comBufferWriter.println ("       (" +
1:eac0369:                                  time.get (java.util.Calendar.YEAR) +
1:eac0369:                                  "." +
1:eac0369:                                  (time.get (java.util.Calendar.MONTH) + 1) +
1:eac0369:                                  "." +
1:eac0369:                                  time.get (java.util.Calendar.DAY_OF_MONTH) +
1:eac0369:                                  " " +
1:eac0369:                                  time.get (java.util.Calendar.HOUR_OF_DAY) +
1:eac0369:                                  ":" +
1:eac0369:                                  time.get (java.util.Calendar.MINUTE) +
1:eac0369:                                  ":" +
1:eac0369:                                  time.get (java.util.Calendar.SECOND) +
1:eac0369:                                  ") " +
1:eac0369:                                  className +
1:eac0369:                                  " " +
1:eac0369:                                  methodName +
1:eac0369:                                  " " +
1:eac0369:                                  Thread.currentThread().getName() +
1:eac0369:                                  " " +
1:eac0369:                                  trcPt);
1:eac0369: 
1:eac0369:         // A newline is added for formatting.
1:eac0369:         comBufferWriter.println();
1:eac0369: 
1:eac0369:         // The data will only be written if there is a non-zero positive length.
1:eac0369:         if (len != 0) {
1:eac0369:           String codePointName = null;
1:eac0369:           // If the length <= 10, lookup the first codepoint so it's name can be printed???
1:eac0369:           if (len >= 10) {
1:eac0369:             // Get the int value of the two byte unsigned codepoint.
1:eac0369:             int codePoint = getCodePoint (buff, offset+8);
1:eac0369:             codePointName = codePointNameTable.lookup (codePoint);
1:eac0369:           }
1:eac0369: 
1:eac0369:           if (codePointName == null) {
1:eac0369:             // codePointName was still null so either < 10 bytes were given or
1:eac0369:             // the codepoint wasn't found in the table.  Just print the plain send header.
1:eac0369:             comBufferWriter.println (getHeader (type));
1:eac0369:           }
1:eac0369:           else {
1:eac0369:             // codePointName isn't null so the name of the codepoint will be printed.
1:eac0369:             printHeaderWithCodePointName (codePointName, type);
1:eac0369:           }
1:eac0369: 
1:eac0369:           // Print the col position header in the trace.
1:eac0369:           comBufferWriter.println (colPosHeader);
1:eac0369: 
1:eac0369:           // A char array will be used to translate the bytes to their character
1:eac0369:           // representations along with ascii and ebcdic representations.
1:eac0369:           char trcDump[] = new char[77];
1:eac0369: 
1:eac0369:           // bCounter, aCounter, eCounter are offsets used to help position the characters
1:eac0369:           short bCounter = 7;
1:eac0369:           short aCounter = 43;
1:eac0369:           short eCounter = 61;
1:eac0369: 
1:eac0369:           // The lines will be counted starting at zero.  This is hard coded since we are
1:eac0369:           // at the beginning.
1:eac0369:           trcDump[0] = DssTrace.zeroChar;
1:eac0369:           trcDump[1] = DssTrace.zeroChar;
1:eac0369:           trcDump[2] = DssTrace.zeroChar;
1:eac0369:           trcDump[3] = DssTrace.zeroChar;
1:eac0369: 
1:eac0369:           // The 0's are already in the trace so bump the line counter up a row.
1:eac0369:           int lineCounter = 0x10;
1:eac0369: 
1:eac0369:           // Make sure the character array has all blanks in it.
1:eac0369:           // Some of these blanks will be replaced later with values.
1:eac0369:           // The 0's were not wrote over.
1:eac0369:           for (int j = 4; j < 77; j++) {
1:eac0369:             trcDump[j] = DssTrace.spaceChar;
1:eac0369:           }
1:eac0369: 
1:eac0369:           // i will maintain the position in the byte array to be traced.
1:eac0369:           int i = 0;
1:eac0369: 
1:eac0369:           do {
1:eac0369:             // Get the unsigned value of the byte.
1:eac0369:             //                  int num = b[off++] & 0xff;
1:eac0369:             int num = (buff[offset] < 0)? buff[offset] + 256 : buff[offset]; // jev
1:eac0369:             offset++;
1:eac0369:             i++;
1:eac0369:             // Place the characters representing the bytes in the array.
1:eac0369:             trcDump[bCounter++] = DssTrace.hexDigit[((num >>> 4) & 0xf)];
1:eac0369:             trcDump[bCounter++] = DssTrace.hexDigit[(num & 0xf)];
1:eac0369: 
1:eac0369:             // Place the ascii and ebcdc representations in the array.
1:eac0369:             trcDump[aCounter++] = DssTrace.asciiChar[num];
1:eac0369:             trcDump[eCounter++] = DssTrace.ebcdicChar[num];
1:eac0369: 
1:eac0369:             if (((i%8) == 0)) {
1:eac0369:               if (((i%16) == 0)) {
1:eac0369:                 // Print the array each time 16 bytes are processed.
1:eac0369:                 comBufferWriter.println (trcDump);
1:eac0369:                 if (i != len) {
1:eac0369:                   // Not yet at the end of the byte array.
1:eac0369:                   if ((len - i) < 16) {
1:eac0369:                     // This is the last line so blank it all out.
1:eac0369:                     // This keeps the last line looking pretty in case
1:eac0369:                     // < 16 bytes remain.
1:eac0369:                     for (int j = 0; j < trcDump.length; j++) {
1:eac0369:                       trcDump[j] = DssTrace.spaceChar;
1:eac0369:                     }
1:eac0369:                   }
1:eac0369:                   // Reset the counters.
1:eac0369:                   bCounter = 0;
1:eac0369:                   aCounter = 43;
1:eac0369:                   eCounter = 61;
1:eac0369:                   // Reset the lineCounter if it starts to get too large.
1:eac0369:                   if (lineCounter == 0xfff0) {
1:eac0369:                     lineCounter = 0;
1:eac0369:                   }
1:eac0369:                   // Place the characters representing the line counter in the array.
1:eac0369:                   trcDump[bCounter++] = DssTrace.hexDigit[((lineCounter >>> 12) & 0xf)];
1:eac0369:                   trcDump[bCounter++] = DssTrace.hexDigit[((lineCounter >>> 8) & 0xf)];
1:eac0369:                   trcDump[bCounter++] = DssTrace.hexDigit[((lineCounter >>> 4) & 0xf)];
1:eac0369:                   trcDump[bCounter++] = DssTrace.hexDigit[(lineCounter & 0xf)];
1:eac0369:                   bCounter += 3;
1:eac0369:                   // Bump up the line counter.
1:eac0369:                   lineCounter += 0x10;
1:eac0369:                 }
1:eac0369:               }
1:eac0369:               else {
1:eac0369:                 // 8 bytes were processed so move the counter to adjust for
1:eac0369:                 // spaces between the columns of bytes.
1:eac0369:                 bCounter += 2;
1:eac0369:               }
1:eac0369:             }
1:eac0369:             // do this until we all the data has been traced.
1:eac0369:           } while (i < len);
1:eac0369: 
1:eac0369:           // print the last line and add some blank lines to make it easier to read.
1:eac0369:           if (len % 16 != 0) {
1:eac0369:             comBufferWriter.println (trcDump);
1:eac0369:           }
1:eac0369:           comBufferWriter.println();
1:eac0369:           comBufferWriter.println();
1:eac0369:         }
1:eac0369:         // Flush the writer.
2:eac0369:         comBufferWriter.flush();
1:eac0369:       }
1:eac0369:     }
1:eac0369:   }
1:eac0369: 
1:eac0369:   // Gets the int value of the two byte unsigned codepoint.
1:eac0369:   private static int getCodePoint (byte[] buff, int offset)
1:eac0369:   {
1:eac0369:     return ((buff[offset++] & 0xff) << 8) +
1:eac0369:       ((buff[offset] & 0xff) << 0);
1:eac0369:   }
1:eac0369: 
1:eac0369:   private static String getHeader (int type)
1:eac0369:   {
1:eac0369:     switch (type) {
1:eac0369:     case DssTrace.TYPE_TRACE_SEND:
1:eac0369:       return DssTrace.sendHeader;
1:eac0369:     case DssTrace.TYPE_TRACE_RECEIVE:
1:eac0369:       return DssTrace.receiveHeader;
1:eac0369:     default:
1:eac0369:       //  throw new !!!
1:6588222:       return null;
1:eac0369:     }
1:eac0369:   }
1:eac0369: 
1:eac0369:   private static int getStartPosition (int type)
1:eac0369:   {
1:eac0369:     switch (type) {
1:eac0369:     case DssTrace.TYPE_TRACE_SEND:
1:eac0369:       return 20; // This is right after 'SEND BUFFER: '.
1:eac0369:     case DssTrace.TYPE_TRACE_RECEIVE:
1:eac0369:       return 23; // This is right after 'RECEIVE BUFFER: '.
1:eac0369:     default:
1:eac0369:       //  throw new !!!
1:eac0369:       return 0;
1:eac0369:     }
1:eac0369:   }
1:eac0369: 
1:eac0369:   private void printHeaderWithCodePointName (String codePointName, int type)
1:eac0369:   {
1:eac0369:     // Create a char array so some of the characters
1:eac0369:     // can be replaced with the name of the codepoint.
1:eac0369:     char headerArray[] = DssTrace.getHeader(type).toCharArray();
1:eac0369: 
1:eac0369:     // At most, 16 character name will be used.  This is so
1:eac0369:     // the headers on top of the ascii and ebcdic rows aren't shifted.
1:eac0369:     int replaceLen = (codePointName.length() < 17) ? codePointName.length() : 16;
1:eac0369: 
1:eac0369:     int offset = getStartPosition (type);
1:eac0369:     for (int i = 0; i < replaceLen; i++) {
1:eac0369:       headerArray[offset++] = codePointName.charAt (i); // make sure charAt() starts at 0!!!
1:eac0369:     }
1:eac0369:     comBufferWriter.println (headerArray);
1:eac0369:   }
1:eac0369: 
1:eac0369: }
============================================================================
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:4f7eee8
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                                     new PrivilegedExceptionAction<Void>() {
1:                                         public Void run() throws IOException {
commit:db9a013
/////////////////////////////////////////////////////////////////////////
1:                 try {
commit:66527ec
/////////////////////////////////////////////////////////////////////////
1:   private final Object comBufferSync = new Object();
commit:db4c995
/////////////////////////////////////////////////////////////////////////
commit:27fbf33
/////////////////////////////////////////////////////////////////////////
1:                         (AccessController.doPrivileged(
1:                             new PrivilegedExceptionAction<PrintWriter>() {
1:                                 public PrintWriter run()
/////////////////////////////////////////////////////////////////////////
0:                                     new PrivilegedAction<Void>() {
0:                                         public Void run() {
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:4f996a4
/////////////////////////////////////////////////////////////////////////
0:                 try {                 
/////////////////////////////////////////////////////////////////////////
1:             }
commit:229ef39
/////////////////////////////////////////////////////////////////////////
1:                     // If we successfully made the file. break out here and don't retry
1:                     break;
commit:d835c40
/////////////////////////////////////////////////////////////////////////
1: import java.io.FileNotFoundException;
/////////////////////////////////////////////////////////////////////////
1:             // Make up to two attempts to create the trace file.
1:             // First just try to make it. Then if we get a FileNotFoundException
1:             // try making the directory and then retry the create.
1:             // We don't try making the directory first because it would require
1:             // extra permissions if the directory already exists. DERBY-4128
1:             for (int attempt=0; attempt <2; attempt++) {
0:                 try {             	
1:                     // The writer will be buffered for effeciency.
0:                     comBufferWriter =  ((PrintWriter)AccessController.doPrivileged(
1:                 } catch (PrivilegedActionException pae) {
1:                     Exception e = pae.getException();
1:                     // If we got a FileNotFoundException on the first attempt,
1:                     // it is likely that the directory did not exist. 
1:                     //We will try to make it.
1:                     if (attempt == 0 && (e instanceof FileNotFoundException)) {
1:                         final File traceDirectory = new File(fileName).getParentFile();
1:                         if (traceDirectory != null) {
1:                             AccessController.doPrivileged(
0:                                     new PrivilegedAction() {
0:                                         public Object run() {
1:                                             // DERBY-4128: First try to create the
1:                                             // directory with mkdir(), as that doesn't
1:                                             // require read permission for the parent
1:                                             // directory. It will only succeed if the
1:                                             // parent directory exists. If mkdir()
1:                                             // fails, retry with mkdirs(), which will
1:                                             // create the parent directories as needed,
1:                                             // but which also requires that read
1:                                             // permission for the parent directory
1:                                             // has been granted.
1:                                             boolean created = traceDirectory.mkdir();
1:                                             if (!created) {
1:                                                 traceDirectory.mkdirs();
1:                                             }
1:                                             return null;
1:                                         }
1:                                     });
1: 
1:                         }
1:                     } else {
1:                         // This is our second attempt or we got some other exception besides
1:                         // FileNotFoundException. Just throw the exception.
1:                         throw e;
1:                     }
1:                 }
1:         	}
commit:efc1f08
/////////////////////////////////////////////////////////////////////////
0:                 if (traceDirectory != null)
commit:45680ff
/////////////////////////////////////////////////////////////////////////
1: import java.io.File;
0: import org.apache.derby.iapi.util.PrivilegedFileOps;
1: 
/////////////////////////////////////////////////////////////////////////
1:   protected void startComBufferTrace (final String fileName) throws Exception 
0:                 // Attempt to make the trace directory if it does not exist.
0:                 // If we can't create the directory the exception will occur 
0:                 // when trying to create the trace file.
0:                 File traceDirectory = new File(fileName).getParentFile();
0:                 if (!PrivilegedFileOps.exists(traceDirectory))
1:                 {
0:                     PrivilegedFileOps.mkdirs(traceDirectory);
1:                 }
0:                 // The writer will be buffered for effeciency.
/////////////////////////////////////////////////////////////////////////
0:                throw  pae.getException();
1:                
commit:5028317
/////////////////////////////////////////////////////////////////////////
1: import java.io.IOException;
1: import java.io.PrintWriter;
1: import java.security.AccessController;
1: import java.security.PrivilegedActionException;
1: import java.security.PrivilegedExceptionAction;
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:  private static final char hexDigit [] = {
/////////////////////////////////////////////////////////////////////////
0:   protected void startComBufferTrace (final String fileName) throws IOException 
0:             try {
1:                 
0:                 comBufferWriter =  ((PrintWriter)AccessController.doPrivileged(
0:                             new PrivilegedExceptionAction() {
0:                                 public Object run() throws SecurityException, IOException {
0:                                     return new  PrintWriter (new java.io.BufferedWriter (new java.io.FileWriter (fileName), 4096));
1:                                 }
1:                             }));
0:             } catch (PrivilegedActionException pae) {
0:                Exception e = pae.getException();
0:                if (e instanceof SecurityException)
0:                    throw (SecurityException)pae.getException();
0:                else
0:                    throw (IOException) pae.getException();
1:             }
1:           
/////////////////////////////////////////////////////////////////////////
1:   
/////////////////////////////////////////////////////////////////////////
1:         if (comBufferWriter != null)
1:         {
1:             comBufferWriter.flush();
1:             comBufferWriter.close();
1:         }
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:dc43cf8
/////////////////////////////////////////////////////////////////////////
0: import java.security.AccessControlException;
1: import org.apache.derby.iapi.services.io.FileUtil;
/////////////////////////////////////////////////////////////////////////
1:                     comBufferWriter =
0:                         ((PrintWriter)AccessController.doPrivileged(
0:                                 public Object run()
1:                                         throws SecurityException, IOException {
1:                                     File f = new File(fileName);
1:                                     boolean exists = f.exists();
1:                                     PrintWriter pw =
1:                                         new PrintWriter(
1:                                             new java.io.BufferedWriter(
1:                                                 new java.io.FileWriter(
1:                                                     fileName),
1:                                                 4096));
1:                                     if (!exists) {
1:                                         FileUtil.limitAccessToOwner(f);
1:                                     }
1:                                     return pw;
/////////////////////////////////////////////////////////////////////////
1:                                                 created =
0:                                                         traceDirectory.mkdirs();
1:                                             }
1: 
1:                                             if (created) {
1:                                                 FileUtil.limitAccessToOwner(
1:                                                         traceDirectory);
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6588222
/////////////////////////////////////////////////////////////////////////
0: import java.security.PrivilegedAction;
/////////////////////////////////////////////////////////////////////////
0:                 final File traceDirectory = new File(fileName).getParentFile();
0:                 if (traceDirectory != null) {
0:                     AccessController.doPrivileged(
0:                             new PrivilegedAction() {
0:                                 public Object run() {
0:                                     traceDirectory.mkdirs();
1:                                     return null;
1:                                 }
0:                             });
1: 
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:59e5225
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:d7258ed
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.drda.DssTrace
1: 
0:    Copyright 2001, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:141cd31
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.drda
0:    (C) Copyright IBM Corp. 2001, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: package org.apache.derby.impl.drda;
1: 
1: // Generic process and error tracing encapsulation.
1: // This class also traces a DRDA communications buffer.
1: // The value of the hex bytes are traced along with
1: // the ascii and ebcdic translations.
1: public class DssTrace
1: {
0: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
1: 
1: 
0:   private static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2001_2004;
1:   // This class was implemented using character arrays to translate bytes
1:   // into ascii and ebcdic.  The goal was to be able to quickly index into the
1:   // arrays to find the characters.  Char arrays instead of strings were used as
1:   // much as possible in an attempt to help speed up performance.
1:   private static final String LIST_SEPARATOR = " # ";
1: 
1:   // trace representation for a java null.
1:   private static final String NULL_VALUE = "null";
1: 
1:   // An array of characters used to translate bytes to ascii.
1:   // The position in the array corresponds to the hex value of the
1:   // character
1:   private static final char asciiChar [] = {
1:     // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
1:     '.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.',  //0
1:     '.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.',  //1
1:     ' ','!','"','#','$','%','&','\'','(',')','*','+',',','-','.','/', //2
1:     '0','1','2','3','4','5','6','7','8','9',':',';','<','=','>','?',  //3
1:     '@','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O',  //4
1:     'P','Q','R','S','T','U','V','W','X','Y','Z','[','\\',']','^','_', //5
1:     '`','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o',  //6
1:     'p','q','r','s','t','u','v','w','x','y','z','{','|','}','~','.',  //7
1:     '.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.',  //8
1:     '.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.',  //9
1:     '.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.',  //A
1:     '.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.',  //B
1:     '.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.',  //C
1:     '.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.',  //D
1:     '.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.',  //E
1:     '.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.'   //F
1:   };
1: 
1: 
1:   // This mapping table associates a codepoint to a String describing the codepoint.
1:   // This is needed because the trace prints the
1:   // first codepoint in send and receive buffers.
1:   // This could be final but there is no need to create the mapping
1:   // if tracing isn't used.  So... this array will only be created when
1:   // the com buffer trace is started.  Note this ref is not protected
1:   // by final and care must be taken if it's value needs to change.
1:   private static CodePointNameTable codePointNameTable = null;
1: 
1:   // This column position header is used to mark offsets into the trace.
1:   private static final String colPosHeader =
1:   "       0 1 2 3 4 5 6 7   8 9 A B C D E F   0123456789ABCDEF  0123456789ABCDEF";
1: 
1:   // An array of characters used to translate bytes to ebcdic.
1:   // The position in the array corresponds to the hex value of the
1:   // character.
1:   private static final char ebcdicChar[] = {
1:     // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
1:     '.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.',  //0
1:     '.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.',  //1
1:     '.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.',  //2
1:     '.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.',  //3
1:     ' ','.','.','.','.','.','.','.','.','.','.','.','<','(','+','|',  //4
1:     '&','.','.','.','.','.','.','.','.','.','!','$','*',')',';','.',  //5
1:     '-','/','.','.','.','.','.','.','.','.','|',',','%','_','>','?',  //6
1:     '.','.','.','.','.','.','.','.','.','`',':','#','@','\'','=','"', //7
1:     '.','a','b','c','d','e','f','g','h','i','.','.','.','.','.','.',  //8
1:     '.','j','k','l','m','n','o','p','q','r','.','.','.','.','.','.',  //9
1:     '.','~','s','t','u','v','w','x','y','z','.','.','.','.','.','.',  //A
1:     '.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.',  //B
1:     '{','A','B','C','D','E','F','G','H','I','.','.','.','.','.','.',  //C
1:     '}','J','K','L','M','N','O','P','Q','R','.','.','.','.','.','.',  //D
1:     '\\','.','S','T','U','V','W','X','Y','Z','.','.','.','.','.','.', //E
1:     '0','1','2','3','4','5','6','7','8','9','.','.','.','.','.','.'   //F
1:   };
1: 
1: 
1:   // An array of characters representing hex numbers.
0:   private static final char hexDigit [] = {
1:     '0','1','2','3','4','5','6','7',
1:     '8','9','A','B','C','D','E','F'
1:   };
1: 
1: 
1:   // A PrintWriter is used in printing the trace.
1:   private java.io.PrintWriter comBufferWriter = null;
1: 
1: 
1:   // The receive header comes befor bytes which would be read from
1:   // a Stream.
1:   private static final String receiveHeader =
1:   "       RECEIVE BUFFER:                     (ASCII)           (EBCDIC)";
1: 
1: 
1:   // The send header comes before bytes which would be written to
1:   // a Stream.
1:   private static final String sendHeader =
1:   "       SEND BUFFER:                        (ASCII)           (EBCDIC)";
1: 
1: 
1:   // The space character is defined for convience.
1:   private static final char spaceChar = ' ';
1: 
1: 
1:   // This boolean indicates if the trace is on.
1:   // It has been declared private now but may be made public at
1:   // a later time.
1:   private boolean comBufferTraceOn = false;
1: 
1: 
1:   // The comBufferSync is an object used for serialization.
1:   // This separate object is used because this trace code may
1:   // get eventually placed into another class which performs
1:   // method entry and exit tracing.  Since each trace may be writing
1:   // to different logs, separate objects will be used to perform the
1:   // synchronization.
0:   private Boolean comBufferSync = new Boolean (true);
1: 
1: 
1:   // The zero character is defined for convinience.
1:   private static final char zeroChar = '0';
1: 
1:   // The recevie constant is used to indicate that the bytes were read to a Stream.
1:   // It indicates to this class that a receive header should be used.
1:   protected static final int TYPE_TRACE_RECEIVE = 2;
1: 
1:   // The send constant is used to indicate that the bytes were written to
1:   // a Stream.  It indicates to this class that a send header should be used.
1:   protected static final int TYPE_TRACE_SEND = 1;
1: 
1:   // Query if trace is on.
1:   // This is currently needed since the comBufferTrcOn flag is private.
1:   protected boolean isComBufferTraceOn()
1:   {
1:     // The trace flag indicates if tracing is on.
1:     return comBufferTraceOn;
1:   }
1: 
1:   // Start the communications buffer trace.
1:   // The name of the file to place the trace is passed to this method.
1:   // After calling this method, calls to isComBufferTraceOn() will return true.
0:   protected void startComBufferTrace (String fileName)
1:   {
1:     synchronized (comBufferSync) {
0:       try {
1:         // Only start the trace if it is off.
1:         if (comBufferTraceOn == false) {
0:           // The writer will be buffered for effeciency.
0:           comBufferWriter = new java.io.PrintWriter (new java.io.BufferedWriter (new java.io.FileWriter (fileName), 4096));
1:           // Turn on the trace flag.
1:           comBufferTraceOn = true;
1:           // initialize the codepoint name table if it is null.
1:           // this is done here so that the CodePointName objects
1:           // aren't created if the trace isn't used (save some memory).
1:           // this process should only be done once
1:           // since after the table is created the ref will
1:           // no longer be null.
1:           if (DssTrace.codePointNameTable == null) {
1:             codePointNameTable = new CodePointNameTable();
1:           }
1:         }
1:       }
0:       catch (java.io.IOException e) {
0:         // The IOException is currently ignored.  Handling should be added.
1:       }
1:     }
1:   }
1: 
1:   // Stop the communications buffer trace.
1:   // The trace file is flushed and closed.  After calling this method,
1:   // calls to isComBufferTraceOn () will return false.
1:   protected void stopComBufferTrace ()
1:   {
1:     synchronized (comBufferSync) {
1:       // Only stop the trace if it is actually on.
1:       if (comBufferTraceOn == true) {
1:         // Turn of the trace flag.
1:         comBufferTraceOn = false;
1:         // Flush and close the writer used for tracing.
1:         comBufferWriter.flush();
0:         comBufferWriter.close();
1:       }
1:     }
1:   }
1: 
1:   // Write the communication buffer data to the trace.
1:   // The data is passed in via a byte array.  The start and length of the data is given.
1:   // The type is needed to indicate if the data is part of the send or receive buffer.
1:   // The class name, method name, and trcPt number are also written to the trace.
1:   // Not much checking is performed on the parameters.  This is done to help performance.
1:   protected void writeComBufferData (byte[] buff,
1:                                          int offset,
1:                                          int len,
1:                                          int type,
1:                                          String className,
1:                                          String methodName,
1:                                          int trcPt)
1:   {
1:     // why don't we synchronize the method!!!
1: 
1:     // Grab the lock to make sure another thread doesn't try to
1:     // write data or close the writer.
1:     synchronized (comBufferSync) {
1: 
1:       // Only take action if the trace is on.
1:       if (comBufferTraceOn) {
1: 
1:         // Obtain an instance of the Calendar so a timestamp can be written.
1:         // this call seems to slow things down a bit.
1:         java.util.Calendar time = java.util.Calendar.getInstance();
1: 
1:         // Print the timestamp, class name, method name, thread name, and tracepoint.
1:         comBufferWriter.println ("       (" +
1:                                  time.get (java.util.Calendar.YEAR) +
1:                                  "." +
1:                                  (time.get (java.util.Calendar.MONTH) + 1) +
1:                                  "." +
1:                                  time.get (java.util.Calendar.DAY_OF_MONTH) +
1:                                  " " +
1:                                  time.get (java.util.Calendar.HOUR_OF_DAY) +
1:                                  ":" +
1:                                  time.get (java.util.Calendar.MINUTE) +
1:                                  ":" +
1:                                  time.get (java.util.Calendar.SECOND) +
1:                                  ") " +
1:                                  className +
1:                                  " " +
1:                                  methodName +
1:                                  " " +
1:                                  Thread.currentThread().getName() +
1:                                  " " +
1:                                  trcPt);
1: 
1:         // A newline is added for formatting.
1:         comBufferWriter.println();
1: 
1:         // The data will only be written if there is a non-zero positive length.
1:         if (len != 0) {
1:           String codePointName = null;
1:           // If the length <= 10, lookup the first codepoint so it's name can be printed???
1:           if (len >= 10) {
1:             // Get the int value of the two byte unsigned codepoint.
1:             int codePoint = getCodePoint (buff, offset+8);
1:             codePointName = codePointNameTable.lookup (codePoint);
1:           }
1: 
1:           if (codePointName == null) {
1:             // codePointName was still null so either < 10 bytes were given or
1:             // the codepoint wasn't found in the table.  Just print the plain send header.
1:             comBufferWriter.println (getHeader (type));
1:           }
1:           else {
1:             // codePointName isn't null so the name of the codepoint will be printed.
1:             printHeaderWithCodePointName (codePointName, type);
1:           }
1: 
1:           // Print the col position header in the trace.
1:           comBufferWriter.println (colPosHeader);
1: 
1:           // A char array will be used to translate the bytes to their character
1:           // representations along with ascii and ebcdic representations.
1:           char trcDump[] = new char[77];
1: 
1:           // bCounter, aCounter, eCounter are offsets used to help position the characters
1:           short bCounter = 7;
1:           short aCounter = 43;
1:           short eCounter = 61;
1: 
1:           // The lines will be counted starting at zero.  This is hard coded since we are
1:           // at the beginning.
1:           trcDump[0] = DssTrace.zeroChar;
1:           trcDump[1] = DssTrace.zeroChar;
1:           trcDump[2] = DssTrace.zeroChar;
1:           trcDump[3] = DssTrace.zeroChar;
1: 
1:           // The 0's are already in the trace so bump the line counter up a row.
1:           int lineCounter = 0x10;
1: 
1:           // Make sure the character array has all blanks in it.
1:           // Some of these blanks will be replaced later with values.
1:           // The 0's were not wrote over.
1:           for (int j = 4; j < 77; j++) {
1:             trcDump[j] = DssTrace.spaceChar;
1:           }
1: 
1:           // i will maintain the position in the byte array to be traced.
1:           int i = 0;
1: 
1:           do {
1:             // Get the unsigned value of the byte.
1:             //                  int num = b[off++] & 0xff;
1:             int num = (buff[offset] < 0)? buff[offset] + 256 : buff[offset]; // jev
1:             offset++;
1:             i++;
1:             // Place the characters representing the bytes in the array.
1:             trcDump[bCounter++] = DssTrace.hexDigit[((num >>> 4) & 0xf)];
1:             trcDump[bCounter++] = DssTrace.hexDigit[(num & 0xf)];
1: 
1:             // Place the ascii and ebcdc representations in the array.
1:             trcDump[aCounter++] = DssTrace.asciiChar[num];
1:             trcDump[eCounter++] = DssTrace.ebcdicChar[num];
1: 
1:             if (((i%8) == 0)) {
1:               if (((i%16) == 0)) {
1:                 // Print the array each time 16 bytes are processed.
1:                 comBufferWriter.println (trcDump);
1:                 if (i != len) {
1:                   // Not yet at the end of the byte array.
1:                   if ((len - i) < 16) {
1:                     // This is the last line so blank it all out.
1:                     // This keeps the last line looking pretty in case
1:                     // < 16 bytes remain.
1:                     for (int j = 0; j < trcDump.length; j++) {
1:                       trcDump[j] = DssTrace.spaceChar;
1:                     }
1:                   }
1:                   // Reset the counters.
1:                   bCounter = 0;
1:                   aCounter = 43;
1:                   eCounter = 61;
1:                   // Reset the lineCounter if it starts to get too large.
1:                   if (lineCounter == 0xfff0) {
1:                     lineCounter = 0;
1:                   }
1:                   // Place the characters representing the line counter in the array.
1:                   trcDump[bCounter++] = DssTrace.hexDigit[((lineCounter >>> 12) & 0xf)];
1:                   trcDump[bCounter++] = DssTrace.hexDigit[((lineCounter >>> 8) & 0xf)];
1:                   trcDump[bCounter++] = DssTrace.hexDigit[((lineCounter >>> 4) & 0xf)];
1:                   trcDump[bCounter++] = DssTrace.hexDigit[(lineCounter & 0xf)];
1:                   bCounter += 3;
1:                   // Bump up the line counter.
1:                   lineCounter += 0x10;
1:                 }
1:               }
1:               else {
1:                 // 8 bytes were processed so move the counter to adjust for
1:                 // spaces between the columns of bytes.
1:                 bCounter += 2;
1:               }
1:             }
1:             // do this until we all the data has been traced.
1:           } while (i < len);
1: 
1:           // print the last line and add some blank lines to make it easier to read.
1:           if (len % 16 != 0) {
1:             comBufferWriter.println (trcDump);
1:           }
1:           comBufferWriter.println();
1:           comBufferWriter.println();
1:         }
1:         // Flush the writer.
1:         comBufferWriter.flush();
1:       }
1:     }
1:   }
1: 
1:   // Gets the int value of the two byte unsigned codepoint.
1:   private static int getCodePoint (byte[] buff, int offset)
1:   {
1:     return ((buff[offset++] & 0xff) << 8) +
1:       ((buff[offset] & 0xff) << 0);
1:   }
1: 
1:   private static String getHeader (int type)
1:   {
1:     switch (type) {
1:     case DssTrace.TYPE_TRACE_SEND:
1:       return DssTrace.sendHeader;
1:     case DssTrace.TYPE_TRACE_RECEIVE:
1:       return DssTrace.receiveHeader;
1:     default:
1:       //  throw new !!!
0:       return null;
1:     }
1:   }
1: 
1:   private static int getStartPosition (int type)
1:   {
1:     switch (type) {
1:     case DssTrace.TYPE_TRACE_SEND:
1:       return 20; // This is right after 'SEND BUFFER: '.
1:     case DssTrace.TYPE_TRACE_RECEIVE:
1:       return 23; // This is right after 'RECEIVE BUFFER: '.
1:     default:
1:       //  throw new !!!
1:       return 0;
1:     }
1:   }
1: 
1:   private void printHeaderWithCodePointName (String codePointName, int type)
1:   {
1:     // Create a char array so some of the characters
1:     // can be replaced with the name of the codepoint.
1:     char headerArray[] = DssTrace.getHeader(type).toCharArray();
1: 
1:     // At most, 16 character name will be used.  This is so
1:     // the headers on top of the ascii and ebcdic rows aren't shifted.
1:     int replaceLen = (codePointName.length() < 17) ? codePointName.length() : 16;
1: 
1:     int offset = getStartPosition (type);
1:     for (int i = 0; i < replaceLen; i++) {
1:       headerArray[offset++] = codePointName.charAt (i); // make sure charAt() starts at 0!!!
1:     }
1:     comBufferWriter.println (headerArray);
1:   }
1: 
1: }
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.drda
0:    (C) Copyright IBM Corp. 2001, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: package org.apache.derby.impl.drda;
0: 
0: // Generic process and error tracing encapsulation.
0: // This class also traces a DRDA communications buffer.
0: // The value of the hex bytes are traced along with
0: // the ascii and ebcdic translations.
0: public class DssTrace
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 
0: 
0:   private static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2001_2004;
0:   // This class was implemented using character arrays to translate bytes
0:   // into ascii and ebcdic.  The goal was to be able to quickly index into the
0:   // arrays to find the characters.  Char arrays instead of strings were used as
0:   // much as possible in an attempt to help speed up performance.
0:   private static final String LIST_SEPARATOR = " # ";
0: 
0:   // trace representation for a java null.
0:   private static final String NULL_VALUE = "null";
0: 
0:   // An array of characters used to translate bytes to ascii.
0:   // The position in the array corresponds to the hex value of the
0:   // character
0:   private static final char asciiChar [] = {
0:     // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
0:     '.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.',  //0
0:     '.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.',  //1
0:     ' ','!','"','#','$','%','&','\'','(',')','*','+',',','-','.','/', //2
0:     '0','1','2','3','4','5','6','7','8','9',':',';','<','=','>','?',  //3
0:     '@','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O',  //4
0:     'P','Q','R','S','T','U','V','W','X','Y','Z','[','\\',']','^','_', //5
0:     '`','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o',  //6
0:     'p','q','r','s','t','u','v','w','x','y','z','{','|','}','~','.',  //7
0:     '.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.',  //8
0:     '.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.',  //9
0:     '.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.',  //A
0:     '.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.',  //B
0:     '.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.',  //C
0:     '.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.',  //D
0:     '.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.',  //E
0:     '.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.'   //F
0:   };
0: 
0: 
0:   // This mapping table associates a codepoint to a String describing the codepoint.
0:   // This is needed because the trace prints the
0:   // first codepoint in send and receive buffers.
0:   // This could be final but there is no need to create the mapping
0:   // if tracing isn't used.  So... this array will only be created when
0:   // the com buffer trace is started.  Note this ref is not protected
0:   // by final and care must be taken if it's value needs to change.
0:   private static CodePointNameTable codePointNameTable = null;
0: 
0:   // This column position header is used to mark offsets into the trace.
0:   private static final String colPosHeader =
0:   "       0 1 2 3 4 5 6 7   8 9 A B C D E F   0123456789ABCDEF  0123456789ABCDEF";
0: 
0:   // An array of characters used to translate bytes to ebcdic.
0:   // The position in the array corresponds to the hex value of the
0:   // character.
0:   private static final char ebcdicChar[] = {
0:     // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
0:     '.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.',  //0
0:     '.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.',  //1
0:     '.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.',  //2
0:     '.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.',  //3
0:     ' ','.','.','.','.','.','.','.','.','.','.','.','<','(','+','|',  //4
0:     '&','.','.','.','.','.','.','.','.','.','!','$','*',')',';','.',  //5
0:     '-','/','.','.','.','.','.','.','.','.','|',',','%','_','>','?',  //6
0:     '.','.','.','.','.','.','.','.','.','`',':','#','@','\'','=','"', //7
0:     '.','a','b','c','d','e','f','g','h','i','.','.','.','.','.','.',  //8
0:     '.','j','k','l','m','n','o','p','q','r','.','.','.','.','.','.',  //9
0:     '.','~','s','t','u','v','w','x','y','z','.','.','.','.','.','.',  //A
0:     '.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.',  //B
0:     '{','A','B','C','D','E','F','G','H','I','.','.','.','.','.','.',  //C
0:     '}','J','K','L','M','N','O','P','Q','R','.','.','.','.','.','.',  //D
0:     '\\','.','S','T','U','V','W','X','Y','Z','.','.','.','.','.','.', //E
0:     '0','1','2','3','4','5','6','7','8','9','.','.','.','.','.','.'   //F
0:   };
0: 
0: 
0:   // An array of characters representing hex numbers.
0:   private static final char hexDigit [] = {
0:     '0','1','2','3','4','5','6','7',
0:     '8','9','A','B','C','D','E','F'
0:   };
0: 
0: 
0:   // A PrintWriter is used in printing the trace.
0:   private java.io.PrintWriter comBufferWriter = null;
0: 
0: 
0:   // The receive header comes befor bytes which would be read from
0:   // a Stream.
0:   private static final String receiveHeader =
0:   "       RECEIVE BUFFER:                     (ASCII)           (EBCDIC)";
0: 
0: 
0:   // The send header comes before bytes which would be written to
0:   // a Stream.
0:   private static final String sendHeader =
0:   "       SEND BUFFER:                        (ASCII)           (EBCDIC)";
0: 
0: 
0:   // The space character is defined for convience.
0:   private static final char spaceChar = ' ';
0: 
0: 
0:   // This boolean indicates if the trace is on.
0:   // It has been declared private now but may be made public at
0:   // a later time.
0:   private boolean comBufferTraceOn = false;
0: 
0: 
0:   // The comBufferSync is an object used for serialization.
0:   // This separate object is used because this trace code may
0:   // get eventually placed into another class which performs
0:   // method entry and exit tracing.  Since each trace may be writing
0:   // to different logs, separate objects will be used to perform the
0:   // synchronization.
0:   private Boolean comBufferSync = new Boolean (true);
0: 
0: 
0:   // The zero character is defined for convinience.
0:   private static final char zeroChar = '0';
0: 
0:   // The recevie constant is used to indicate that the bytes were read to a Stream.
0:   // It indicates to this class that a receive header should be used.
0:   protected static final int TYPE_TRACE_RECEIVE = 2;
0: 
0:   // The send constant is used to indicate that the bytes were written to
0:   // a Stream.  It indicates to this class that a send header should be used.
0:   protected static final int TYPE_TRACE_SEND = 1;
0: 
0:   // Query if trace is on.
0:   // This is currently needed since the comBufferTrcOn flag is private.
0:   protected boolean isComBufferTraceOn()
0:   {
0:     // The trace flag indicates if tracing is on.
0:     return comBufferTraceOn;
0:   }
0: 
0:   // Start the communications buffer trace.
0:   // The name of the file to place the trace is passed to this method.
0:   // After calling this method, calls to isComBufferTraceOn() will return true.
0:   protected void startComBufferTrace (String fileName)
0:   {
0:     synchronized (comBufferSync) {
0:       try {
0:         // Only start the trace if it is off.
0:         if (comBufferTraceOn == false) {
0:           // The writer will be buffered for effeciency.
0:           comBufferWriter = new java.io.PrintWriter (new java.io.BufferedWriter (new java.io.FileWriter (fileName), 4096));
0:           // Turn on the trace flag.
0:           comBufferTraceOn = true;
0:           // initialize the codepoint name table if it is null.
0:           // this is done here so that the CodePointName objects
0:           // aren't created if the trace isn't used (save some memory).
0:           // this process should only be done once
0:           // since after the table is created the ref will
0:           // no longer be null.
0:           if (DssTrace.codePointNameTable == null) {
0:             codePointNameTable = new CodePointNameTable();
0:           }
0:         }
0:       }
0:       catch (java.io.IOException e) {
0:         // The IOException is currently ignored.  Handling should be added.
0:       }
0:     }
0:   }
0: 
0:   // Stop the communications buffer trace.
0:   // The trace file is flushed and closed.  After calling this method,
0:   // calls to isComBufferTraceOn () will return false.
0:   protected void stopComBufferTrace ()
0:   {
0:     synchronized (comBufferSync) {
0:       // Only stop the trace if it is actually on.
0:       if (comBufferTraceOn == true) {
0:         // Turn of the trace flag.
0:         comBufferTraceOn = false;
0:         // Flush and close the writer used for tracing.
0:         comBufferWriter.flush();
0:         comBufferWriter.close();
0:       }
0:     }
0:   }
0: 
0:   // Write the communication buffer data to the trace.
0:   // The data is passed in via a byte array.  The start and length of the data is given.
0:   // The type is needed to indicate if the data is part of the send or receive buffer.
0:   // The class name, method name, and trcPt number are also written to the trace.
0:   // Not much checking is performed on the parameters.  This is done to help performance.
0:   protected void writeComBufferData (byte[] buff,
0:                                          int offset,
0:                                          int len,
0:                                          int type,
0:                                          String className,
0:                                          String methodName,
0:                                          int trcPt)
0:   {
0:     // why don't we synchronize the method!!!
0: 
0:     // Grab the lock to make sure another thread doesn't try to
0:     // write data or close the writer.
0:     synchronized (comBufferSync) {
0: 
0:       // Only take action if the trace is on.
0:       if (comBufferTraceOn) {
0: 
0:         // Obtain an instance of the Calendar so a timestamp can be written.
0:         // this call seems to slow things down a bit.
0:         java.util.Calendar time = java.util.Calendar.getInstance();
0: 
0:         // Print the timestamp, class name, method name, thread name, and tracepoint.
0:         comBufferWriter.println ("       (" +
0:                                  time.get (java.util.Calendar.YEAR) +
0:                                  "." +
0:                                  (time.get (java.util.Calendar.MONTH) + 1) +
0:                                  "." +
0:                                  time.get (java.util.Calendar.DAY_OF_MONTH) +
0:                                  " " +
0:                                  time.get (java.util.Calendar.HOUR_OF_DAY) +
0:                                  ":" +
0:                                  time.get (java.util.Calendar.MINUTE) +
0:                                  ":" +
0:                                  time.get (java.util.Calendar.SECOND) +
0:                                  ") " +
0:                                  className +
0:                                  " " +
0:                                  methodName +
0:                                  " " +
0:                                  Thread.currentThread().getName() +
0:                                  " " +
0:                                  trcPt);
0: 
0:         // A newline is added for formatting.
0:         comBufferWriter.println();
0: 
0:         // The data will only be written if there is a non-zero positive length.
0:         if (len != 0) {
0:           String codePointName = null;
0:           // If the length <= 10, lookup the first codepoint so it's name can be printed???
0:           if (len >= 10) {
0:             // Get the int value of the two byte unsigned codepoint.
0:             int codePoint = getCodePoint (buff, offset+8);
0:             codePointName = codePointNameTable.lookup (codePoint);
0:           }
0: 
0:           if (codePointName == null) {
0:             // codePointName was still null so either < 10 bytes were given or
0:             // the codepoint wasn't found in the table.  Just print the plain send header.
0:             comBufferWriter.println (getHeader (type));
0:           }
0:           else {
0:             // codePointName isn't null so the name of the codepoint will be printed.
0:             printHeaderWithCodePointName (codePointName, type);
0:           }
0: 
0:           // Print the col position header in the trace.
0:           comBufferWriter.println (colPosHeader);
0: 
0:           // A char array will be used to translate the bytes to their character
0:           // representations along with ascii and ebcdic representations.
0:           char trcDump[] = new char[77];
0: 
0:           // bCounter, aCounter, eCounter are offsets used to help position the characters
0:           short bCounter = 7;
0:           short aCounter = 43;
0:           short eCounter = 61;
0: 
0:           // The lines will be counted starting at zero.  This is hard coded since we are
0:           // at the beginning.
0:           trcDump[0] = DssTrace.zeroChar;
0:           trcDump[1] = DssTrace.zeroChar;
0:           trcDump[2] = DssTrace.zeroChar;
0:           trcDump[3] = DssTrace.zeroChar;
0: 
0:           // The 0's are already in the trace so bump the line counter up a row.
0:           int lineCounter = 0x10;
0: 
0:           // Make sure the character array has all blanks in it.
0:           // Some of these blanks will be replaced later with values.
0:           // The 0's were not wrote over.
0:           for (int j = 4; j < 77; j++) {
0:             trcDump[j] = DssTrace.spaceChar;
0:           }
0: 
0:           // i will maintain the position in the byte array to be traced.
0:           int i = 0;
0: 
0:           do {
0:             // Get the unsigned value of the byte.
0:             //                  int num = b[off++] & 0xff;
0:             int num = (buff[offset] < 0)? buff[offset] + 256 : buff[offset]; // jev
0:             offset++;
0:             i++;
0:             // Place the characters representing the bytes in the array.
0:             trcDump[bCounter++] = DssTrace.hexDigit[((num >>> 4) & 0xf)];
0:             trcDump[bCounter++] = DssTrace.hexDigit[(num & 0xf)];
0: 
0:             // Place the ascii and ebcdc representations in the array.
0:             trcDump[aCounter++] = DssTrace.asciiChar[num];
0:             trcDump[eCounter++] = DssTrace.ebcdicChar[num];
0: 
0:             if (((i%8) == 0)) {
0:               if (((i%16) == 0)) {
0:                 // Print the array each time 16 bytes are processed.
0:                 comBufferWriter.println (trcDump);
0:                 if (i != len) {
0:                   // Not yet at the end of the byte array.
0:                   if ((len - i) < 16) {
0:                     // This is the last line so blank it all out.
0:                     // This keeps the last line looking pretty in case
0:                     // < 16 bytes remain.
0:                     for (int j = 0; j < trcDump.length; j++) {
0:                       trcDump[j] = DssTrace.spaceChar;
0:                     }
0:                   }
0:                   // Reset the counters.
0:                   bCounter = 0;
0:                   aCounter = 43;
0:                   eCounter = 61;
0:                   // Reset the lineCounter if it starts to get too large.
0:                   if (lineCounter == 0xfff0) {
0:                     lineCounter = 0;
0:                   }
0:                   // Place the characters representing the line counter in the array.
0:                   trcDump[bCounter++] = DssTrace.hexDigit[((lineCounter >>> 12) & 0xf)];
0:                   trcDump[bCounter++] = DssTrace.hexDigit[((lineCounter >>> 8) & 0xf)];
0:                   trcDump[bCounter++] = DssTrace.hexDigit[((lineCounter >>> 4) & 0xf)];
0:                   trcDump[bCounter++] = DssTrace.hexDigit[(lineCounter & 0xf)];
0:                   bCounter += 3;
0:                   // Bump up the line counter.
0:                   lineCounter += 0x10;
0:                 }
0:               }
0:               else {
0:                 // 8 bytes were processed so move the counter to adjust for
0:                 // spaces between the columns of bytes.
0:                 bCounter += 2;
0:               }
0:             }
0:             // do this until we all the data has been traced.
0:           } while (i < len);
0: 
0:           // print the last line and add some blank lines to make it easier to read.
0:           if (len % 16 != 0) {
0:             comBufferWriter.println (trcDump);
0:           }
0:           comBufferWriter.println();
0:           comBufferWriter.println();
0:         }
0:         // Flush the writer.
0:         comBufferWriter.flush();
0:       }
0:     }
0:   }
0: 
0:   // Gets the int value of the two byte unsigned codepoint.
0:   private static int getCodePoint (byte[] buff, int offset)
0:   {
0:     return ((buff[offset++] & 0xff) << 8) +
0:       ((buff[offset] & 0xff) << 0);
0:   }
0: 
0:   private static String getHeader (int type)
0:   {
0:     switch (type) {
0:     case DssTrace.TYPE_TRACE_SEND:
0:       return DssTrace.sendHeader;
0:     case DssTrace.TYPE_TRACE_RECEIVE:
0:       return DssTrace.receiveHeader;
0:     default:
0:       //  throw new !!!
0:       return null;
0:     }
0:   }
0: 
0:   private static int getStartPosition (int type)
0:   {
0:     switch (type) {
0:     case DssTrace.TYPE_TRACE_SEND:
0:       return 20; // This is right after 'SEND BUFFER: '.
0:     case DssTrace.TYPE_TRACE_RECEIVE:
0:       return 23; // This is right after 'RECEIVE BUFFER: '.
0:     default:
0:       //  throw new !!!
0:       return 0;
0:     }
0:   }
0: 
0:   private void printHeaderWithCodePointName (String codePointName, int type)
0:   {
0:     // Create a char array so some of the characters
0:     // can be replaced with the name of the codepoint.
0:     char headerArray[] = DssTrace.getHeader(type).toCharArray();
0: 
0:     // At most, 16 character name will be used.  This is so
0:     // the headers on top of the ascii and ebcdic rows aren't shifted.
0:     int replaceLen = (codePointName.length() < 17) ? codePointName.length() : 16;
0: 
0:     int offset = getStartPosition (type);
0:     for (int i = 0; i < replaceLen; i++) {
0:       headerArray[offset++] = codePointName.charAt (i); // make sure charAt() starts at 0!!!
0:     }
0:     comBufferWriter.println (headerArray);
0:   }
0: 
0: }
============================================================================