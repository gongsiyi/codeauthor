1:fe77ca5: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.compile.TableElementList
1:95a483d: 
1:2d37fd6:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2d37fd6:    contributor license agreements.  See the NOTICE file distributed with
1:2d37fd6:    this work for additional information regarding copyright ownership.
1:2d37fd6:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2d37fd6:    (the "License"); you may not use this file except in compliance with
1:2d37fd6:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:345de35: 
7:fe77ca5:  */
42:fe77ca5: 
1:fe77ca5: package	org.apache.derby.impl.sql.compile;
1:fe77ca5: 
1:7168d7d: import java.util.ArrayList;
1:7168d7d: import java.util.HashSet;
1:c0a807c: import java.util.List;
1:e594ab0: import java.util.Properties;
1:234a2b6: import java.util.Set;
1:3bb140c: import org.apache.derby.catalog.UUID;
1:3bb140c: import org.apache.derby.catalog.types.DefaultInfoImpl;
1:3bb140c: import org.apache.derby.iapi.error.StandardException;
1:e594ab0: import org.apache.derby.iapi.reference.Property;
1:3bb140c: import org.apache.derby.iapi.reference.SQLState;
1:3bb140c: import org.apache.derby.iapi.services.context.ContextManager;
1:3bb140c: import org.apache.derby.iapi.services.io.FormatableBitSet;
1:e594ab0: import org.apache.derby.iapi.services.property.PropertyUtil;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:3bb140c: import org.apache.derby.iapi.sql.StatementType;
1:3bb140c: import org.apache.derby.iapi.sql.compile.CompilerContext;
1:3bb140c: import org.apache.derby.iapi.sql.depend.DependencyManager;
1:3bb140c: import org.apache.derby.iapi.sql.depend.ProviderInfo;
1:3bb140c: import org.apache.derby.iapi.sql.depend.ProviderList;
1:3bb140c: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
1:3bb140c: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptorList;
1:3bb140c: import org.apache.derby.iapi.sql.dictionary.ConstraintDescriptor;
1:3bb140c: import org.apache.derby.iapi.sql.dictionary.ConstraintDescriptorList;
1:3bb140c: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1:3bb140c: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
1:3bb140c: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1:3bb140c: import org.apache.derby.iapi.types.DataTypeDescriptor;
1:3bb140c: import org.apache.derby.iapi.types.TypeId;
1:3bb140c: import org.apache.derby.impl.sql.execute.ColumnInfo;
1:3bb140c: import org.apache.derby.impl.sql.execute.ConstraintConstantAction;
1:3bb140c: import org.apache.derby.impl.sql.execute.ConstraintInfo;
1:3bb140c: import org.apache.derby.impl.sql.execute.IndexConstantAction;
1:fe77ca5: 
3:fe77ca5: /**
1:fe77ca5:  * A TableElementList represents the list of columns and other table elements
1:fe77ca5:  * such as constraints in a CREATE TABLE or ALTER TABLE statement.
15:fe77ca5:  *
1:fe77ca5:  */
1:fe77ca5: 
1:e1f49ca: class TableElementList extends QueryTreeNodeVector<TableElementNode>
13:fe77ca5: {
1:02e0ae5: 	private int				numColumns;
1:02e0ae5: 	private TableDescriptor td;
1:e126f58: 
1:3bb140c:     public TableElementList(ContextManager cm) {
1:e1f49ca:         super(TableElementNode.class, cm);
1:3bb140c:     }
1:3bb140c: 
1:7168d7d: 	/**
1:fe77ca5: 	 * Add a TableElementNode to this TableElementList
1:95a483d: 	 *
1:fe77ca5: 	 * @param tableElement	The TableElementNode to add to this list
1:28e234d: 	 */
1:7168d7d: 
1:3bb140c:     void addTableElement(TableElementNode tableElement)
1:fe77ca5: 	{
1:fe77ca5: 		addElement(tableElement);
1:fe77ca5: 		if ((tableElement instanceof ColumnDefinitionNode) ||
1:fe77ca5: 			tableElement.getElementType() == TableElementNode.AT_DROP_COLUMN)
1:fe77ca5: 		{
1:fe77ca5: 			numColumns++;
1:7168d7d: 		}
12:fe77ca5: 	} 
1:7168d7d: 
1:28e234d: 	/**
1:fce10ba: 	 * Use the passed schema descriptor's collation type to set the collation
1:2779125: 	 * of the character string types in create table node
1:2779125: 	 * @param sd
1:fe77ca5: 	 */
1:fce10ba: 	void setCollationTypesOnCharacterStringColumns(SchemaDescriptor sd)
1:fce10ba:         throws StandardException
1:fce10ba:     {
1:e1f49ca:         for (TableElementNode te : this)
1:fe77ca5: 		{
1:e1f49ca:             if (te instanceof ColumnDefinitionNode)
1:fe77ca5: 			{
1:e1f49ca:                 setCollationTypeOnCharacterStringColumn(
1:e1f49ca:                         sd, (ColumnDefinitionNode)te );
1:fe77ca5: 			}
1:fe77ca5: 		}
1:fe77ca5: 	}
1:fce10ba: 
1:fe77ca5: 	/**
1:2779125: 	 * Use the passed schema descriptor's collation type to set the collation
1:fce10ba: 	 * of a character string column.
1:fce10ba: 	 * @param sd
1:fce10ba: 	 */
1:fce10ba: 	void setCollationTypeOnCharacterStringColumn(SchemaDescriptor sd, ColumnDefinitionNode cdn )
1:fce10ba:         throws StandardException
1:fce10ba:     {
1:fce10ba: 		int collationType = sd.getCollationType();
1:fce10ba: 
1:fce10ba:         //
1:fce10ba:         // Only generated columns can omit the datatype specification during the
1:fce10ba:         // early phases of binding--before we have been able to bind the
1:fce10ba:         // generation clause.
1:fce10ba:         //
1:fce10ba:         DataTypeDescriptor  dtd = cdn.getType();
1:fce10ba:         if ( dtd == null )
1:fce10ba:         {
1:3bb140c:             if ( !cdn.hasGenerationClause() )
1:fce10ba:             {
1:fce10ba:                 throw StandardException.newException
1:fce10ba:                     ( SQLState.LANG_NEEDS_DATATYPE, cdn.getColumnName() );
1:fce10ba:             }
1:fe77ca5:         }
1:fce10ba:         else
1:fce10ba:         {
1:fce10ba:             if ( dtd.getTypeId().isStringTypeId() ) { cdn.setCollationType(collationType); }
1:fe77ca5:         }
1:fe77ca5:     }
1:2a0827a:     
1:fe77ca5: 	/**
1:fe77ca5: 	 * Validate this TableElementList.  This includes checking for
1:fe77ca5: 	 * duplicate columns names, and checking that user types really exist.
1:28e234d: 	 *
1:fe77ca5: 	 * @param ddlStmt	DDLStatementNode which contains this list
1:fe77ca5: 	 * @param dd		DataDictionary to use
1:fe77ca5: 	 * @param td		TableDescriptor for table, if existing table.
1:28e234d: 	 *
1:fe77ca5: 	 * @exception StandardException		Thrown on error
1:fe77ca5: 	 */
1:fe77ca5: 	void validate(DDLStatementNode ddlStmt,
1:fe77ca5: 					     DataDictionary dd,
1:fe77ca5: 						 TableDescriptor td)
3:fe77ca5: 					throws StandardException
1:fe77ca5: 	{
1:fe77ca5:  		this.td = td;
1:fe77ca5: 		int numAutoCols = 0;
1:bd66456: 
1:b8b524c: 		int			size = size();
1:71c8e86:         HashSet<String> columnNames = new HashSet<String>(size + 2, 0.999f);
1:71c8e86:         HashSet<String> constraintNames = new HashSet<String>(size + 2, 0.999f);
1:fe77ca5: 		//all the primary key/unique key constraints for this table
1:71c8e86:         ArrayList<Object> constraints = new ArrayList<Object>();
1:3bb140c: 
1:fe77ca5: 		//special case for alter table (td is not null in case of alter table)
1:fe77ca5: 		if (td != null)
1:fe77ca5: 		{
1:fe77ca5: 			//In case of alter table, get the already existing primary key and unique
1:fe77ca5: 			//key constraints for this table. And then we will compare them with  new
1:fe77ca5: 			//primary key/unique key constraint column lists.
1:fe77ca5: 			ConstraintDescriptorList cdl = dd.getConstraintDescriptors(td);
1:fe77ca5: 			ConstraintDescriptor cd;
1:fe77ca5: 
1:fe77ca5: 			if (cdl != null) //table does have some pre-existing constraints defined on it
1:fe77ca5: 			{
1:fe77ca5: 				for (int i=0; i<cdl.size();i++)
1:fe77ca5: 				{
1:fe77ca5: 					cd = cdl.elementAt(i);
1:fe77ca5: 					//if the constraint type is not primary key or unique key, ignore it.
1:fe77ca5: 					if (cd.getConstraintType() == DataDictionary.PRIMARYKEY_CONSTRAINT ||
1:fe77ca5: 					cd.getConstraintType() == DataDictionary.UNIQUE_CONSTRAINT)
1:47d4a4c:                     {
1:b153b24:                         constraints.add(cd);
1:47d4a4c:                     }
1:fe77ca5: 				}
1:fe77ca5: 			}
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 		int tableType = TableDescriptor.BASE_TABLE_TYPE;
1:fe77ca5: 		if (ddlStmt instanceof CreateTableNode)
1:fe77ca5: 			tableType = ((CreateTableNode)ddlStmt).tableType;
1:fe77ca5: 
1:e1f49ca:         for (TableElementNode tableElement : this)
1:fe77ca5: 		{
3:fe77ca5: 			if (tableElement instanceof ColumnDefinitionNode)
1:fe77ca5: 			{
1:e1f49ca:                 ColumnDefinitionNode cdn = (ColumnDefinitionNode)tableElement;
1:fe77ca5: 				if (tableType == TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE &&
1:7dda5d5: 					(cdn.getType().getTypeId().isLongConcatableTypeId() ||
1:7dda5d5: 					cdn.getType().getTypeId().isUserDefinedTypeId()))
1:fe77ca5: 				{
1:fe77ca5: 					throw StandardException.newException(SQLState.LANG_LONG_DATA_TYPE_NOT_ALLOWED, cdn.getColumnName());
1:fe77ca5: 				}
1:234a2b6: 				checkForDuplicateColumns(ddlStmt, columnNames, cdn.getColumnName());
1:fe77ca5: 				cdn.checkUserType(td);
1:fe77ca5: 				cdn.bindAndValidateDefault(dd, td);
1:fe77ca5: 
1:fe77ca5: 				cdn.validateAutoincrement(dd, td, tableType);
1:fe77ca5: 
1:fe77ca5: 				if (tableElement instanceof ModifyColumnNode)
1:fe77ca5: 				{
1:fe77ca5: 					ModifyColumnNode mcdn = (ModifyColumnNode)cdn;
1:fe77ca5: 					mcdn.checkExistingConstraints(td);
1:93b320d: 					mcdn.useExistingCollation(td);
1:e126f58: 
1:fe77ca5: 				} else if (cdn.isAutoincrementColumn())
1:e126f58:                 { numAutoCols ++; }
1:fe77ca5: 			}
1:fe77ca5: 			else if (tableElement.getElementType() == TableElementNode.AT_DROP_COLUMN)
1:fe77ca5: 			{
1:fe77ca5: 				String colName = tableElement.getName();
1:fe77ca5: 				if (td.getColumnDescriptor(colName) == null)
1:fe77ca5: 				{
1:fe77ca5: 					throw StandardException.newException(
1:fe77ca5: 												SQLState.LANG_COLUMN_NOT_FOUND_IN_TABLE,
1:fe77ca5: 												colName,
1:fe77ca5: 												td.getQualifiedName());
1:fe77ca5: 				}
1:fe77ca5: 				break;
1:fe77ca5: 			}
1:fe77ca5: 
1:fe77ca5: 			/* The rest of this method deals with validating constraints */
1:fe77ca5: 			if (! (tableElement.hasConstraint()))
1:fe77ca5: 			{
4:fe77ca5: 				continue;
1:fe77ca5: 			}
1:fe77ca5: 
1:fe77ca5: 			ConstraintDefinitionNode cdn = (ConstraintDefinitionNode) tableElement;
1:fe77ca5: 
1:fe77ca5: 			cdn.bind(ddlStmt, dd);
1:fe77ca5: 
1:b153b24:             // If constraint is primary key or unique key, add it to the list.
1:fe77ca5: 			if (cdn.getConstraintType() == DataDictionary.PRIMARYKEY_CONSTRAINT ||
1:fe77ca5: 			cdn.getConstraintType() == DataDictionary.UNIQUE_CONSTRAINT)
1:fe77ca5: 			{
1:b153b24:                 /* In case of create table, the list can have only ConstraintDefinitionNode
1:fe77ca5: 				* elements. In case of alter table, it can have both ConstraintDefinitionNode
1:fe77ca5: 				* (for new constraints) and ConstraintDescriptor(for pre-existing constraints).
1:fe77ca5: 				*/
1:fe77ca5: 
1:fe77ca5: 				Object destConstraint;
1:fe77ca5: 				String destName = null;
1:fe77ca5: 				String[] destColumnNames = null;
1:fe77ca5: 
1:b153b24:                 for (int i = 0; i < constraints.size(); i++)
1:fe77ca5: 				{
1:fe77ca5: 
1:b153b24:                     destConstraint = constraints.get(i);
1:fe77ca5: 					if (destConstraint instanceof ConstraintDefinitionNode)
1:fe77ca5: 					{
1:fe77ca5: 						ConstraintDefinitionNode destCDN = (ConstraintDefinitionNode)destConstraint;
1:fe77ca5: 						destName = destCDN.getConstraintMoniker();
1:fe77ca5: 						destColumnNames = destCDN.getColumnList().getColumnNames();
1:fe77ca5: 					}
1:fe77ca5: 					else if (destConstraint instanceof ConstraintDescriptor)
1:fe77ca5: 					{
1:fe77ca5: 						//will come here only for pre-existing constraints in case of alter table
1:fe77ca5: 						ConstraintDescriptor destCD = (ConstraintDescriptor)destConstraint;
1:fe77ca5: 						destName = destCD.getConstraintName();
1:fe77ca5: 						destColumnNames = destCD.getColumnDescriptors().getColumnNames();
1:fe77ca5: 					}
1:fe77ca5: 					//check if there are multiple constraints with same set of columns
1:fe77ca5: 					if (columnsMatch(cdn.getColumnList().getColumnNames(), destColumnNames))
1:fe77ca5: 						throw StandardException.newException(SQLState.LANG_MULTIPLE_CONSTRAINTS_WITH_SAME_COLUMNS,
1:fe77ca5: 						cdn.getConstraintMoniker(), destName);
1:fe77ca5: 				}
1:b153b24:                 constraints.add(cdn);
1:fe77ca5: 			}
1:fe77ca5: 
1:fe77ca5: 			/* Make sure that there are no duplicate constraint names in the list */
1:234a2b6:             checkForDuplicateConstraintNames(ddlStmt, constraintNames, cdn.getConstraintMoniker());
1:fe77ca5: 
1:fe77ca5: 			/* Make sure that the constraint we are trying to drop exists */
1:09bee7d:             if (cdn.getConstraintType() == DataDictionary.DROP_CONSTRAINT ||
1:09bee7d:                 cdn.getConstraintType() == DataDictionary.MODIFY_CONSTRAINT)
1:fe77ca5: 			{
1:fe77ca5: 				/*
1:fe77ca5: 				** If no schema descriptor, then must be an invalid
1:fe77ca5: 				** schema name.
1:fe77ca5: 				*/
1:fe77ca5: 
1:fe77ca5: 				String dropConstraintName = cdn.getConstraintMoniker();
1:fe77ca5: 
1:fe77ca5: 				if (dropConstraintName != null) {
1:fe77ca5: 
1:fe77ca5: 					String dropSchemaName = cdn.getDropSchemaName();
1:fe77ca5: 
1:fe77ca5: 					SchemaDescriptor sd = dropSchemaName == null ? td.getSchemaDescriptor() :
1:fe77ca5: 											getSchemaDescriptor(dropSchemaName);
1:fe77ca5: 
1:fe77ca5: 					ConstraintDescriptor cd =
1:fe77ca5: 								dd.getConstraintDescriptorByName(
1:fe77ca5: 										td, sd, dropConstraintName,
1:fe77ca5: 										false);
1:fe77ca5: 					if (cd == null)
1:fe77ca5: 					{
1:09bee7d:                         throw StandardException.newException(SQLState.LANG_DROP_OR_ALTER_NON_EXISTING_CONSTRAINT,
1:fe77ca5: 								(sd.getSchemaName() + "."+ dropConstraintName),
1:fe77ca5: 								td.getQualifiedName());
1:fe77ca5: 					}
1:fe77ca5: 					/* Statement is dependendent on the ConstraintDescriptor */
1:fe77ca5: 					getCompilerContext().createDependency(cd);
1:fe77ca5: 				}
1:fe77ca5: 			}
1:fe77ca5: 
1:b8b524c:             // validation of primary key nullability moved to validatePrimaryKeyNullability().
1:02e0ae5:             if (cdn.hasPrimaryKeyConstraint())
1:fe77ca5:             {
1:02e0ae5:                 // for PRIMARY KEY, check that columns are unique
1:fe77ca5:                 verifyUniqueColumnList(ddlStmt, cdn);
1:fe77ca5:             }
1:02e0ae5:             else if (cdn.hasUniqueKeyConstraint())
1:fe77ca5:             {
1:28e234d:                 // for UNIQUE, check that columns are unique
2:02e0ae5:                 verifyUniqueColumnList(ddlStmt, cdn);
1:28e234d: 
1:28e234d:                 // unique constraints on nullable columns added in 10.4, 
1:28e234d:                 // disallow until database hard upgraded at least to 10.4.
1:28e234d:                 if (!dd.checkVersion(
1:28e234d:                         DataDictionary.DD_VERSION_DERBY_10_4, null))
1:28e234d:                 {
1:28e234d:                     checkForNullColumns(cdn, td);
1:28e234d:                 }
1:fe77ca5:             }
1:02e0ae5:             else if (cdn.hasForeignKeyConstraint())
1:fe77ca5:             {
1:02e0ae5:                 // for FOREIGN KEY, check that columns are unique
1:02e0ae5:                 verifyUniqueColumnList(ddlStmt, cdn);
1:fe77ca5:             }
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 		/* Can have only one autoincrement column in DB2 mode */
1:b5392db:         // Raise an error if we have more than one autoincrement column in a
1:b5392db:         // CREATE TABLE statement, or if we are adding a new autoincrement
1:b5392db:         // column to an existing table that already has an autoincrement column,
1:b5392db:         // with ALTER TABLE ADD COLUMN.
1:b5392db:         if (numAutoCols > 1 ||
1:b5392db:                 (numAutoCols > 0 && td != null && td.tableHasAutoincrement())) {
1:fe77ca5: 			throw StandardException.newException(SQLState.LANG_MULTIPLE_AUTOINCREMENT_COLUMNS);
1:b5392db:         }
1:fe77ca5: 
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5:     /**
1:b8b524c: 	 * Validate nullability of primary keys. This logic was moved out of the main validate
1:b8b524c: 	 * method so that it can be called after binding generation clauses. We need
1:b8b524c: 	 * to perform the nullability checks later on because the datatype may be
1:b8b524c: 	 * omitted on the generation clause--we can't set/vet the nullability of the
1:b8b524c: 	 * datatype until we determine what the datatype is.
1:b8b524c: 	 */
1:b8b524c:     public  void    validatePrimaryKeyNullability()
1:b8b524c:         throws StandardException
1:b8b524c:     {
1:e1f49ca:         for (TableElementNode tableElement : this)
1:b8b524c: 		{
1:b8b524c: 			if (! (tableElement.hasConstraint()))
1:b8b524c: 			{
1:b8b524c: 				continue;
1:b8b524c: 			}
1:b8b524c:             
1:b8b524c: 			ConstraintDefinitionNode cdn = (ConstraintDefinitionNode) tableElement;
1:b8b524c: 
1:b8b524c:             if (cdn.hasPrimaryKeyConstraint())
1:b8b524c:             {
1:b8b524c:                 if (td == null)
1:b8b524c:                 {
1:b8b524c:                     // in CREATE TABLE so set PRIMARY KEY columns to NOT NULL
1:b8b524c:                     setColumnListToNotNull(cdn);
1:b8b524c:                 }
1:b8b524c:                 else
1:b8b524c:                 {
1:b8b524c:                     // in ALTER TABLE so raise error if any columns are nullable
1:b8b524c:                     checkForNullColumns(cdn, td);
1:b8b524c:                 }
1:b8b524c:             }
1:b8b524c:         }
1:b8b524c:     }
1:b8b524c:     
1:b8b524c:     /**
1:fe77ca5: 	 * Count the number of constraints of the specified type.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @param constraintType	The constraint type to search for.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @return int	The number of constraints of the specified type.
1:fe77ca5: 	 */
1:3bb140c:     int countConstraints(int constraintType)
1:fe77ca5: 	{
1:fe77ca5: 		int	numConstraints = 0;
1:fe77ca5: 
1:e1f49ca:         for (TableElementNode element : this)
1:fe77ca5: 		{
1:e1f49ca:             if (element instanceof ConstraintDefinitionNode &&
1:e1f49ca:                 ((ConstraintDefinitionNode)element).getConstraintType() ==
1:e1f49ca:                     constraintType) {
1:e1f49ca:                 numConstraints++;
1:e1f49ca:             }
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 		return numConstraints;
1:fe77ca5: 	}
1:fe77ca5: 
1:95a483d:     /**
1:95a483d: 	 * Count the number of generation clauses.
1:95a483d: 	 */
1:3bb140c:     int countGenerationClauses()
1:95a483d: 	{
1:95a483d: 		int	numGenerationClauses = 0;
1:95a483d: 
1:e1f49ca:         for (TableElementNode element : this)
1:95a483d: 		{
1:e1f49ca:             if (element instanceof ColumnDefinitionNode &&
1:e1f49ca:                     ((ColumnDefinitionNode)element).hasGenerationClause()) {
1:e1f49ca:                 numGenerationClauses++;
1:e1f49ca:             }
1:fe77ca5: 		}
1:95a483d: 
1:95a483d: 		return numGenerationClauses;
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Count the number of columns.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @return int	The number of columns.
1:fe77ca5: 	 */
1:3bb140c:     int countNumberOfColumns()
1:fe77ca5: 	{
1:fe77ca5: 		return numColumns;
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Fill in the ColumnInfo[] for this table element list.
1:fe77ca5: 	 * 
1:fe77ca5: 	 * @param colInfos	The ColumnInfo[] to be filled in.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @return int		The number of constraints in the create table.
1:fe77ca5: 	 */
1:3bb140c:     int genColumnInfos( ColumnInfo[] colInfos)
1:3c09be7:         throws StandardException
1:fe77ca5: 	{
1:fe77ca5: 		int	numConstraints = 0;
1:95a483d: 		int size = size();
1:fe77ca5: 
1:3bb140c: 		for (int index = 0; index < size; index++)
1:fe77ca5: 		{
1:e1f49ca:             if (elementAt(index).getElementType() == TableElementNode.AT_DROP_COLUMN)
1:fe77ca5: 			{
1:e1f49ca:                 String columnName = elementAt(index).getName();
1:b8b524c: 
1:fe77ca5: 				colInfos[index] = new ColumnInfo(
1:e126f58: 								columnName,
1:e126f58: 								td.getColumnDescriptor( columnName ).getType(),
1:e126f58:                                 null, null, null, null, null,
1:d055adb: 								ColumnInfo.DROP, 0, 0, 0, 0);
1:fe77ca5: 				break;
1:fe77ca5: 			}
1:95a483d: 
1:fe77ca5: 			if (! (elementAt(index) instanceof ColumnDefinitionNode))
1:fe77ca5: 			{
1:68db840: 				if (SanityManager.DEBUG)
1:68db840: 				{
1:fe77ca5: 					SanityManager.ASSERT( elementAt(index) instanceof ConstraintDefinitionNode,
1:fe77ca5: 						"elementAt(index) expected to be instanceof " +
1:fe77ca5: 						"ConstraintDefinitionNode");
1:fe77ca5: 				}
1:fe77ca5: 
1:3c09be7: 				/* Remember how many constraints we've seen */
2:fe77ca5: 				numConstraints++;
1:fe77ca5: 				continue;
1:fe77ca5: 			}
1:fe77ca5: 
1:fe77ca5: 			ColumnDefinitionNode coldef = (ColumnDefinitionNode) elementAt(index);
1:3c09be7: 
1:3c09be7:             //
1:3c09be7:             // Generated columns may depend on functions mentioned in their
1:3c09be7:             // generation clauses.
1:3c09be7:             //
1:3c09be7:             ProviderList apl = null;
1:3c09be7:             ProviderInfo[]	providerInfos = null;
1:3c09be7: 			if ( coldef.hasGenerationClause() )
1:3c09be7: 			{
1:3c09be7: 				apl = coldef.getGenerationClauseNode().getAuxiliaryProviderList();
1:3c09be7: 			}
1:3c09be7:             if (apl != null && apl.size() > 0)
1:3c09be7:             {
1:3c09be7:                 DependencyManager dm = getDataDictionary().getDependencyManager();
1:3c09be7:                 providerInfos = dm.getPersistentProviderInfos(apl);
1:3c09be7:             }
1:e126f58: 
1:fe77ca5: 			colInfos[index - numConstraints] = 
1:fe77ca5: 				new ColumnInfo(coldef.getColumnName(),
1:7dda5d5: 							   coldef.getType(),
1:fe77ca5: 							   coldef.getDefaultValue(),
1:fe77ca5: 							   coldef.getDefaultInfo(),
1:3c09be7: 							   providerInfos,
1:fe77ca5: 							   (UUID) null,
1:fe77ca5: 							   coldef.getOldDefaultUUID(),
1:fe77ca5: 							   coldef.getAction(),
1:fe77ca5: 							   (coldef.isAutoincrementColumn() ? 
1:fe77ca5: 								coldef.getAutoincrementStart() : 0),
1:fe77ca5: 							   (coldef.isAutoincrementColumn() ? 
1:6a5edfc: 								coldef.getAutoincrementIncrement() : 0),
1:d055adb: 							   (coldef.isAutoincrementColumn() ?
1:d055adb:  								coldef.getAutoincrementCycle() : 0),
1:6a5edfc: 							   (coldef.isAutoincrementColumn() ? 
1:6a5edfc: 								coldef.getAutoinc_create_or_modify_Start_Increment() : -1));
1:fe77ca5: 
2:fe77ca5: 			/* Remember how many constraints that we've seen */
1:09bee7d:         if (coldef.hasConstraint())
1:fe77ca5: 			{
1:fe77ca5: 				numConstraints++;
1:fe77ca5: 			}
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 		return numConstraints;
1:fe77ca5: 	}
1:fe77ca5: 	/**
1:fe77ca5: 	 * Append goobered up ResultColumns to the table's RCL.
1:fe77ca5: 	 * This is useful for binding check constraints for CREATE and ALTER TABLE.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @param table		The table in question.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @exception StandardException		Thrown on error
1:fe77ca5: 	 */
1:3bb140c:     void appendNewColumnsToRCL(FromBaseTable table)
1:fe77ca5: 		throws StandardException
1:fe77ca5: 	{
1:fe77ca5: 		int				 size = size();
1:7ae50e9: 		ResultColumnList rcl = table.getResultColumns();
1:fe77ca5: 		TableName		 exposedName = table.getTableName();
1:fe77ca5: 
1:b8b524c: 		for (int index = 0; index < size; index++)
1:fe77ca5: 		{
1:fe77ca5: 			if (elementAt(index) instanceof ColumnDefinitionNode)
1:fe77ca5: 			{
2:fe77ca5: 				ColumnDefinitionNode cdn = (ColumnDefinitionNode) elementAt(index);
1:fe77ca5: 				ResultColumn	resultColumn;
1:fe77ca5: 				ValueNode		valueNode;
1:fe77ca5: 
1:fe77ca5: 				/* Build a ResultColumn/BaseColumnNode pair for the column */
1:3bb140c:                 valueNode = new BaseColumnNode(cdn.getColumnName(),
1:fe77ca5: 									  		exposedName,
2:7dda5d5: 											cdn.getType(),
3:fe77ca5: 											getContextManager());
1:fe77ca5: 
1:3bb140c:                 resultColumn = new ResultColumn(
1:3bb140c:                         cdn.getType(), valueNode, getContextManager());
1:fe77ca5: 				resultColumn.setName(cdn.getColumnName());
1:fe77ca5: 				rcl.addElement(resultColumn);
1:fe77ca5: 			}
1:fe77ca5: 		}
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Bind and validate all of the check constraints in this list against
1:95a483d: 	 * the specified FromList.  
1:fe77ca5: 	 *
1:95a483d: 	 * @param fromList		The FromList in question.
1:95a483d: 	 *
1:95a483d: 	 * @exception StandardException		Thrown on error
1:95a483d: 	 */
1:fe77ca5: 	void bindAndValidateCheckConstraints(FromList fromList)
1:95a483d: 		throws StandardException
1:95a483d: 	{
1:e1f49ca:         FromBaseTable table = (FromBaseTable) fromList.elementAt(0);
1:e1f49ca:         CompilerContext cc = getCompilerContext();
1:95a483d: 
1:71c8e86:         ArrayList<AggregateNode> aggregates = new ArrayList<AggregateNode>();
1:95a483d: 
1:e1f49ca:         for (TableElementNode element : this)
1:95a483d: 		{
2:fe77ca5: 			ConstraintDefinitionNode cdn;
1:fe77ca5: 			ValueNode	checkTree;
1:95a483d: 
2:fe77ca5: 			if (! (element instanceof ConstraintDefinitionNode))
1:95a483d: 			{
1:95a483d: 				continue;
1:95a483d: 			}
1:95a483d: 
2:fe77ca5: 			cdn = (ConstraintDefinitionNode) element;
1:95a483d: 
1:fe77ca5: 			if (cdn.getConstraintType() != DataDictionary.CHECK_CONSTRAINT)
1:95a483d: 			{
1:fe77ca5: 				continue;
1:95a483d: 			}
1:95a483d: 
1:fe77ca5: 			checkTree = cdn.getCheckCondition();
1:95a483d: 
1:95a483d: 			// bind the check condition
1:95a483d: 			// verify that it evaluates to a boolean
1:fe77ca5: 			final int previousReliability = cc.getReliability();
1:fe77ca5: 			try
1:fe77ca5: 			{
1:fe77ca5: 				/* Each check constraint can have its own set of dependencies.
1:fe77ca5: 				 * These dependencies need to be shared with the prepared
1:fe77ca5: 				 * statement as well.  We create a new auxiliary provider list
1:fe77ca5: 				 * for the check constraint, "push" it on the compiler context
1:fe77ca5: 				 * by swapping it with the current auxiliary provider list
1:fe77ca5: 				 * and the "pop" it when we're done by restoring the old 
1:fe77ca5: 				 * auxiliary provider list.
1:fe77ca5: 				 */
1:fe77ca5: 				ProviderList apl = new ProviderList();
1:fe77ca5: 
1:95a483d: 				ProviderList prevAPL = cc.getCurrentAuxiliaryProviderList();
1:fe77ca5: 				cc.setCurrentAuxiliaryProviderList(apl);
1:95a483d: 
1:fe77ca5: 				// Tell the compiler context to only allow deterministic nodes
1:fe77ca5: 				cc.setReliability( CompilerContext.CHECK_CONSTRAINT );
1:09c2697:                 checkTree = checkTree.bindExpression(
1:09c2697:                         fromList, (SubqueryList) null, aggregates);
1:95a483d: 
1:fe77ca5: 				// no aggregates, please
1:09c2697:                 if (!aggregates.isEmpty())
1:fe77ca5: 				{
1:fe77ca5: 					throw StandardException.newException(SQLState.LANG_INVALID_CHECK_CONSTRAINT, cdn.getConstraintText());
1:fe77ca5: 				}
1:fe77ca5: 				
1:fe77ca5: 				checkTree = checkTree.checkIsBoolean();
1:fe77ca5: 				cdn.setCheckCondition(checkTree);
1:fe77ca5: 
1:fe77ca5: 				/* Save the APL off in the constraint node */
1:fe77ca5: 				if (apl.size() > 0)
1:fe77ca5: 				{
1:fe77ca5: 					cdn.setAuxiliaryProviderList(apl);
1:fe77ca5: 				}
1:fe77ca5: 
1:95a483d: 				// Restore the previous AuxiliaryProviderList
1:95a483d: 				cc.setCurrentAuxiliaryProviderList(prevAPL);
1:fe77ca5: 			}
1:fe77ca5: 			finally
1:fe77ca5: 			{
1:fe77ca5: 				cc.setReliability(previousReliability);
1:fe77ca5: 			}
1:fe77ca5: 	
1:28f9484:             /* We have a valid check constraint.
1:28f9484:              * Now we build a list with only the referenced columns and
1:fe77ca5: 			 * copy it to the cdn.  Thus we can build the array of
1:fe77ca5: 			 * column names for the referenced columns during generate().
1:fe77ca5: 			 */
1:28f9484:             ResultColumnList rcl = table.getResultColumns();
1:28f9484:             int numReferenced = rcl.countReferencedColumns();
1:3bb140c:             ResultColumnList refRCL = new ResultColumnList(getContextManager());
1:fe77ca5: 			rcl.copyReferencedColumnsToNewList(refRCL);
1:fe77ca5: 
1:fe77ca5: 			/* A column check constraint can only refer to that column. If this is a
1:fe77ca5: 			 * column constraint, we should have an RCL with that column
1:fe77ca5: 			 */
1:fe77ca5: 			if (cdn.getColumnList() != null)
1:fe77ca5: 			{
1:e1f49ca:                 String colName = cdn.getColumnList().elementAt(0).getName();
1:fe77ca5: 				if (numReferenced > 1 ||
1:e1f49ca:                     !colName.equals(refRCL.elementAt(0).getName()))
1:fe77ca5: 					throw StandardException.newException(SQLState.LANG_DB2_INVALID_CHECK_CONSTRAINT, colName);
1:fe77ca5: 				
1:fe77ca5: 			}
1:fe77ca5: 			cdn.setColumnList(refRCL);
1:fe77ca5: 
1:fe77ca5: 			/* Clear the column references in the RCL so each check constraint
1:fe77ca5: 			 * starts with a clean list.
1:fe77ca5: 			 */
1:fe77ca5: 			rcl.clearColumnReferences();
1:9d9f6dd: 
1:9d9f6dd:             // Make sure all names are schema qualified (DERBY-6362)
1:9d9f6dd:             cdn.qualifyNames();
1:fe77ca5: 		}
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:95a483d: 	 * Bind and validate all of the generation clauses in this list against
1:fe77ca5: 	 * the specified FromList.  
1:fe77ca5: 	 *
1:ae7e54a: 	 * @param sd			Schema where the table lives.
1:72b444b: 	 * @param fromList		The FromList in question.
1:2a0827a: 	 * @param generatedColumns Bitmap of generated columns in the table. Vacuous for CREATE TABLE, but may be non-trivial for ALTER TABLE. This routine may set bits for new generated columns.
1:7168d7d: 	 * @param baseTable  Table descriptor if this is an ALTER TABLE statement.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @exception StandardException		Thrown on error
1:fe77ca5: 	 */
1:7168d7d: 	void bindAndValidateGenerationClauses( SchemaDescriptor sd, FromList fromList, FormatableBitSet generatedColumns, TableDescriptor baseTable )
1:fe77ca5: 		throws StandardException
1:2a0827a: 	{
1:e1f49ca:         FromBaseTable    table = (FromBaseTable) fromList.elementAt(0);
1:e1f49ca:         ResultColumnList tableColumns = table.getResultColumns();
1:e1f49ca:         int              columnCount = table.getResultColumns().size();
1:fe77ca5: 
1:7168d7d:         // complain if a generation clause references another generated column
1:7168d7d:         findIllegalGenerationReferences( fromList, baseTable );
1:7168d7d: 
1:2a0827a:         generatedColumns.grow( columnCount + 1 );
1:fe77ca5:         
1:e1f49ca:         CompilerContext cc = getCompilerContext();
1:fe77ca5: 
1:71c8e86:         ArrayList<AggregateNode> aggregates = new ArrayList<AggregateNode>();
1:fe77ca5: 
1:e1f49ca:         for (TableElementNode element : this)
1:fe77ca5: 		{
1:2a0827a: 			ColumnDefinitionNode cdn;
1:95a483d:             GenerationClauseNode    generationClauseNode;
1:95a483d: 			ValueNode	generationTree;
1:2a0827a: 
1:95a483d: 			if (! (element instanceof ColumnDefinitionNode))
1:95a483d: 			{
1:95a483d: 				continue;
1:95a483d: 			}
1:2a0827a: 
1:95a483d: 			cdn = (ColumnDefinitionNode) element;
1:95a483d: 
1:95a483d: 			if (!cdn.hasGenerationClause())
1:95a483d: 			{
1:95a483d: 				continue;
1:95a483d: 			}
1:95a483d: 
1:2a0827a:             generationClauseNode = cdn.getGenerationClauseNode();
1:95a483d: 
1:15b837e: 			// bind the generation clause
1:95a483d: 			final int previousReliability = cc.getReliability();
1:15b837e:             ProviderList prevAPL = cc.getCurrentAuxiliaryProviderList();
1:95a483d: 			try
1:95a483d: 			{
1:95a483d: 				/* Each generation clause can have its own set of dependencies.
1:95a483d: 				 * These dependencies need to be shared with the prepared
1:95a483d: 				 * statement as well.  We create a new auxiliary provider list
1:95a483d: 				 * for the generation clause, "push" it on the compiler context
1:95a483d: 				 * by swapping it with the current auxiliary provider list
1:95a483d: 				 * and the "pop" it when we're done by restoring the old 
1:95a483d: 				 * auxiliary provider list.
1:95a483d: 				 */
1:95a483d: 				ProviderList apl = new ProviderList();
1:95a483d: 
1:95a483d: 				cc.setCurrentAuxiliaryProviderList(apl);
1:95a483d: 
1:95a483d: 				// Tell the compiler context to forbid subqueries and
1:95a483d: 				// non-deterministic functions.
1:95a483d: 				cc.setReliability( CompilerContext.GENERATION_CLAUSE_RESTRICTION );
1:09c2697:                 generationTree = generationClauseNode.bindExpression(
1:09c2697:                         fromList, (SubqueryList) null, aggregates);
1:95a483d: 
1:b737f16:                 SelectNode.checkNoWindowFunctions(generationClauseNode, "generation clause");
1:b737f16: 
1:2a0827a:                 //
1:95a483d:                 // If the user did not declare a type for this column, then the column type defaults
1:95a483d:                 // to the type of the generation clause.
1:95a483d:                 // However, if the user did declare a type for this column, then the
1:95a483d:                 // type of the generation clause must be assignable to the declared
1:95a483d:                 // type.
1:2a0827a:                 //
1:95a483d:                 DataTypeDescriptor  generationClauseType = generationTree.getTypeServices();
1:95a483d:                 DataTypeDescriptor  declaredType = cdn.getType();
1:fce10ba:                 if ( declaredType == null )
1:fce10ba:                 {
1:fce10ba:                     cdn.setType( generationClauseType );
1:fce10ba: 
1:fce10ba:                     //
1:b8b524c:                     // Poke the type into the FromTable so that constraints will
1:b8b524c:                     // compile.
1:b8b524c:                     //
1:b8b524c:                     tableColumns.getResultColumn( cdn.getColumnName(), false ).setType( generationClauseType );
1:b8b524c: 
1:b8b524c:                     //
1:fce10ba:                     // We skipped these steps earlier on because we didn't have
1:fce10ba:                     // a datatype. Now that we have a datatype, revisit these
1:fce10ba:                     // steps.
1:fce10ba:                     //
1:fce10ba:                     setCollationTypeOnCharacterStringColumn( sd, cdn );
1:fce10ba:                     cdn.checkUserType( table.getTableDescriptor() );
1:fce10ba:                 }
1:fce10ba:                 else
1:95a483d:                 {
1:95a483d:                     TypeId  declaredTypeId = declaredType.getTypeId();
1:95a483d:                     TypeId  resolvedTypeId = generationClauseType.getTypeId();
1:95a483d: 
1:95a483d:                     if ( !getTypeCompiler( resolvedTypeId ).convertible( declaredTypeId, false ) )
1:95a483d:                     {
1:95a483d:                         throw StandardException.newException
1:95a483d:                             ( SQLState.LANG_UNASSIGNABLE_GENERATION_CLAUSE, cdn.getName(), resolvedTypeId.getSQLTypeName() );
1:95a483d:                     }
1:95a483d:                 }
1:95a483d: 
1:95a483d: 				// no aggregates, please
1:09c2697:                 if (!aggregates.isEmpty())
1:95a483d: 				{
1:95a483d: 					throw StandardException.newException( SQLState.LANG_AGGREGATE_IN_GENERATION_CLAUSE, cdn.getName());
1:95a483d: 				}
1:95a483d: 				
1:95a483d: 				/* Save the APL off in the constraint node */
1:95a483d: 				if (apl.size() > 0)
1:95a483d: 				{
1:95a483d: 					generationClauseNode.setAuxiliaryProviderList(apl);
1:95a483d: 				}
1:95a483d: 
1:95a483d: 			}
1:95a483d: 			finally
1:95a483d: 			{
1:15b837e: 				// Restore previous compiler state
1:15b837e: 				cc.setCurrentAuxiliaryProviderList(prevAPL);
1:95a483d: 				cc.setReliability(previousReliability);
1:95a483d: 			}
1:95a483d: 
1:95a483d: 			/* We have a valid generation clause, now build an array of
1:95a483d: 			 * 1-based columnIds that the clause references.
1:95a483d: 			 */
1:95a483d: 			ResultColumnList rcl = table.getResultColumns();
1:95a483d: 			int		numReferenced = rcl.countReferencedColumns();
1:95a483d: 			int[]	generationClauseColumnReferences = new int[numReferenced];
1:2a0827a:             int     position = rcl.getPosition( cdn.getColumnName(), 1 );
1:7ae50e9: 
1:2a0827a:             generatedColumns.set( position );
1:2a0827a:         
1:95a483d: 			rcl.recordColumnReferences(generationClauseColumnReferences, 1);
1:95a483d: 
1:7ae50e9:             String[]    referencedColumnNames = new String[ numReferenced ];
1:7ae50e9: 
1:7ae50e9:             for ( int i = 0; i < numReferenced; i++ )
1:7ae50e9:             {
1:e1f49ca:                 referencedColumnNames[i] =
1:e1f49ca:                     rcl.elementAt(generationClauseColumnReferences[i] - 1).
1:e1f49ca:                         getName();
1:7ae50e9:             }
1:7ae50e9: 
1:01aa176:             String              currentSchemaName = getLanguageConnectionContext().getCurrentSchemaName();
1:95a483d:             DefaultInfoImpl dii = new DefaultInfoImpl
1:01aa176:                 ( generationClauseNode.getExpressionText(), referencedColumnNames, currentSchemaName );
1:95a483d:             cdn.setDefaultInfo( dii );
1:95a483d: 
1:95a483d: 			/* Clear the column references in the RCL so each generation clause
1:95a483d: 			 * starts with a clean list.
1:95a483d: 			 */
1:95a483d: 			rcl.clearColumnReferences();
1:95a483d: 		}
1:95a483d: 
1:fe77ca5:         
1:95a483d: 	}
1:fe77ca5: 
1:95a483d: 	/**
1:7168d7d: 	 * Complain if a generation clause references other generated columns. This
1:7168d7d: 	 * is required by the SQL Standard, part 2, section 4.14.8.
1:7168d7d: 	 *
1:7168d7d: 	 * @param fromList		The FromList in question.
1:7168d7d: 	 * @param baseTable  Table descriptor if this is an ALTER TABLE statement.
1:7168d7d: 	 * @exception StandardException		Thrown on error
1:7168d7d: 	 */
1:7168d7d: 	void findIllegalGenerationReferences( FromList fromList, TableDescriptor baseTable )
1:7168d7d: 		throws StandardException
1:7168d7d: 	{
1:71c8e86:         ArrayList<ColumnDefinitionNode>   generatedColumns = new ArrayList<ColumnDefinitionNode>();
1:71c8e86:         HashSet<String>     names = new HashSet<String>();
1:7168d7d: 
1:7168d7d:         // add in existing generated columns if this is an ALTER TABLE statement
1:7168d7d:         if ( baseTable != null )
1:7168d7d:         {
1:7168d7d:             ColumnDescriptorList cdl = baseTable.getGeneratedColumns();
1:7168d7d:             int                  count = cdl.size();
1:7168d7d:             for ( int i = 0; i < count; i++ )
1:7168d7d:             {
1:7168d7d:                 names.add( cdl.elementAt( i ).getColumnName() );
1:7168d7d:             }
1:7168d7d:         }
1:7168d7d:         
1:7168d7d:         // find all of the generated columns
1:e1f49ca:         for (TableElementNode element : this)
1:fe77ca5: 		{
1:95a483d: 			ColumnDefinitionNode cdn;
1:c0342de: 
1:2a0827a: 			if (! (element instanceof ColumnDefinitionNode)) { continue; }
1:2a0827a: 
1:2a0827a: 			cdn = (ColumnDefinitionNode) element;
1:2a0827a: 
1:2a0827a: 			if (!cdn.hasGenerationClause()) { continue; }
1:7ae50e9: 
1:7168d7d:             generatedColumns.add( cdn );
1:7168d7d:             names.add( cdn.getColumnName() );
1:7168d7d:         }
1:2a0827a: 
1:7168d7d:         // now look at their generation clauses to see if they reference one
1:7168d7d:         // another
1:7168d7d:         int    count = generatedColumns.size();
1:7168d7d:         for ( int i = 0; i < count; i++ )
1:7168d7d:         {
1:3bb140c:             ColumnDefinitionNode    cdn = generatedColumns.get( i );
1:7168d7d:             GenerationClauseNode    generationClauseNode = cdn.getGenerationClauseNode();
1:3bb140c:             List<ColumnReference>   referencedColumns =
1:3bb140c:                 generationClauseNode.findReferencedColumns();
1:7168d7d:             int                     refCount = referencedColumns.size();
1:7168d7d:             for ( int j = 0; j < refCount; j++ )
1:2a0827a:             {
1:3bb140c:                 String name = referencedColumns.get(j).getColumnName();
1:fe77ca5: 
1:7168d7d:                 if ( name != null )
1:2a0827a:                 {
1:7168d7d:                     if ( names.contains( name ) )
1:7168d7d:                     {
1:7168d7d:                         throw StandardException.newException(SQLState.LANG_CANT_REFERENCE_GENERATED_COLUMN, cdn.getColumnName());
1:7168d7d:                     }
1:7168d7d:                 }
1:7168d7d:             }
1:7168d7d:         }
1:7168d7d: 
1:2a0827a:     }
1:c0342de:     
1:fe77ca5: 	/**
1:c0342de: 	 * Prevent foreign keys on generated columns from violating the SQL spec,
1:c0342de: 	 * part 2, section 11.8 (<column definition>), syntax rule 12: the
1:c0342de: 	 * referential action may not specify SET NULL or SET DEFAULT and the update
1:c0342de: 	 * rule may not specify ON UPDATE CASCADE.  
1:c0342de: 	 *
1:c0342de: 	 * @param fromList		The FromList in question.
1:c0342de: 	 * @param generatedColumns Bitmap of generated columns in the table.
1:c0342de: 	 *
1:c0342de: 	 * @exception StandardException		Thrown on error
1:c0342de: 	 */
1:c0342de: 	void validateForeignKeysOnGenerationClauses(FromList fromList, FormatableBitSet generatedColumns )
1:c0342de: 		throws StandardException
1:c0342de: 	{
1:c0342de:         // nothing to do if there are no generated columns
1:c0342de:         if ( generatedColumns.getNumBitsSet() <= 0 ) { return; }
1:c0342de:         
1:c0342de: 		FromBaseTable				table = (FromBaseTable) fromList.elementAt(0);
1:c0342de:         ResultColumnList        tableColumns = table.getResultColumns();
1:c0342de: 
1:c0342de:         // loop through the foreign keys, looking for keys which violate the
1:c0342de:         // rulse we're enforcing
1:e1f49ca:         for (TableElementNode element : this)
1:c0342de: 		{
1:c0342de: 			if (! (element instanceof FKConstraintDefinitionNode))
1:c0342de: 			{
1:c0342de: 				continue;
1:c0342de: 			}
1:c0342de: 
1:c0342de: 			FKConstraintDefinitionNode fk = (FKConstraintDefinitionNode) element;
1:c0342de:             ConstraintInfo                      ci = fk.getReferencedConstraintInfo();
1:c0342de:             int                                     deleteRule = ci.getReferentialActionDeleteRule();
1:c0342de:             int                                     updateRule = ci.getReferentialActionUpdateRule();
1:c0342de: 
1:c0342de:             //
1:c0342de:             // Currently we don't support ON UPDATE CASCADE. Someday we might.
1:c0342de:             // We're laying a trip-wire here so that we won't neglect to code the appropriate check
1:c0342de:             // when we support ON UPDATE CASCADE.
1:c0342de:             //
1:c0342de:             if (
1:c0342de:                 ( updateRule != StatementType.RA_RESTRICT ) &&
1:c0342de:                 ( updateRule != StatementType.RA_NOACTION )
1:c0342de:                 )
1:c0342de:             {
1:c0342de:                 throw StandardException.newException( SQLState.BTREE_UNIMPLEMENTED_FEATURE );
1:c0342de:             }
1:c0342de:             
1:c0342de:             if (
1:c0342de:                 ( deleteRule != StatementType.RA_SETNULL ) &&
1:c0342de:                 ( deleteRule != StatementType.RA_SETDEFAULT )
1:c0342de:                 )
1:c0342de:             { continue; }
1:c0342de: 
1:c0342de:             //
1:c0342de:             // OK, we have found a foreign key whose referential action is SET NULL or
1:c0342de:             // SET DEFAULT or whose update rule is ON UPDATE CASCADE.
1:c0342de:             // See if any of the key columns are generated columns.
1:c0342de:             //
1:e1f49ca:             for (ResultColumn keyCol : fk.getColumnList())
1:c0342de:             {
1:e1f49ca:                 String keyColName = keyCol.getName();
1:e1f49ca:                 int position = tableColumns.getPosition( keyColName, 1 );
1:c0342de: 
1:c0342de:                 if ( generatedColumns.isSet(  position ) )
1:c0342de:                 {
1:c0342de:                     throw StandardException.newException(SQLState.LANG_BAD_FK_ON_GENERATED_COLUMN, keyColName );
1:c0342de:                 }
1:c0342de:             }
1:c0342de: 
1:c0342de:         }   // end of loop through table elements
1:c0342de:     }
1:c0342de:     
1:c0342de: 	/**
1:fe77ca5: 	 * Fill in the ConstraintConstantAction[] for this create/alter table.
1:fe77ca5: 	 * 
1:68db840:      * @param forCreateTable ConstraintConstantAction is for a create table.
1:fe77ca5: 	 * @param conActions	The ConstraintConstantAction[] to be filled in.
1:fe77ca5: 	 * @param tableName		The name of the Table being created.
1:72b444b: 	 * @param tableSd		The schema for that table.
1:72b444b: 	 * @param dd	    	The DataDictionary
1:fe77ca5: 	 *
1:fe77ca5: 	 * @exception StandardException		Thrown on failure
1:fe77ca5: 	 */
1:68db840: 	void genConstraintActions(boolean forCreateTable,
1:fe77ca5: 				ConstraintConstantAction[] conActions,
2:fe77ca5: 				String tableName,
1:fe77ca5: 				SchemaDescriptor tableSd,
2:fe77ca5: 				DataDictionary dd)
1:fe77ca5: 		throws StandardException
1:fe77ca5: 	{
1:fe77ca5: 		int conActionIndex = 0;
1:e1f49ca: 
1:e1f49ca:         for (TableElementNode ten : this)
1:fe77ca5: 		{
1:fe77ca5: 			String[]	columnNames = null;
1:fe77ca5: 			IndexConstantAction indexAction = null;
1:c0342de: 
1:e1f49ca:             if (! ten.hasConstraint() ||
1:e1f49ca:                 ten instanceof ColumnDefinitionNode)
1:fe77ca5: 			{
1:fe77ca5: 				continue;
1:95a483d: 			}
1:2a0827a: 
1:fe77ca5: 			ConstraintDefinitionNode constraintDN = (ConstraintDefinitionNode) ten;
1:2a0827a: 
1:fe77ca5: 			if (constraintDN.getColumnList() != null)
1:fe77ca5: 			{
1:fe77ca5: 				columnNames = new String[constraintDN.getColumnList().size()];
1:fe77ca5: 				constraintDN.getColumnList().exportNames(columnNames);
1:95a483d: 			}
1:2a0827a: 
1:fe77ca5: 			int constraintType = constraintDN.getConstraintType();
1:09bee7d:             boolean[] cChars = constraintDN.getCharacteristics();
1:fe77ca5: 			String constraintText = constraintDN.getConstraintText();
1:fe77ca5: 
1:fe77ca5: 			/*
1:fe77ca5: 			** If the constraint is not named (e.g.
1:fe77ca5: 			** create table x (x int primary key)), then
1:fe77ca5: 			** the constraintSd is the same as the table.
1:fe77ca5: 			*/
1:fe77ca5: 			String constraintName = constraintDN.getConstraintMoniker();
1:fe77ca5: 
1:fe77ca5: 			/* At execution time, we will generate a unique name for the backing
1:fe77ca5: 			 * index (for CREATE CONSTRAINT) and we will look up the conglomerate
1:fe77ca5: 			 * name (for DROP CONSTRAINT).
1:fe77ca5: 			 */
1:fe77ca5: 			if (constraintDN.requiresBackingIndex())
1:fe77ca5: 			{
1:28e234d:                 // implement unique constraints using a unique backing index 
1:28e234d:                 // unless it is soft upgrade in version before 10.4, or if 
1:28e234d:                 // constraint contains no nullable columns.  In 10.4 use 
1:28e234d:                 // "unique with duplicate null" backing index for constraints 
1:28e234d:                 // that contain at least one nullable column.
1:28e234d: 
1:28e234d: 				if (constraintDN.constraintType ==
1:28e234d: 					DataDictionary.UNIQUE_CONSTRAINT && 
1:28e234d: 					(dd.checkVersion(
1:28e234d:                          DataDictionary.DD_VERSION_DERBY_10_4, null))) 
1:28e234d:                 {
1:28e234d:                     boolean contains_nullable_columns = 
1:28e234d:                         areColumnsNullable(constraintDN, td);
1:28e234d: 
1:28e234d:                     // if all the columns are non nullable, continue to use
1:28e234d:                     // a unique backing index.
1:28e234d:                     boolean unique = 
1:28e234d:                         !contains_nullable_columns;
1:28e234d: 
1:28e234d:                     // Only use a "unique with duplicate nulls" backing index
1:28e234d:                     // for constraints with nullable columns.
1:28e234d:                     boolean uniqueWithDuplicateNulls = 
1:28e234d:                         contains_nullable_columns;
1:28e234d: 
1:28e234d: 					indexAction = genIndexAction(
1:28e234d: 						forCreateTable,
1:28e234d: 						unique,
1:28e234d:                         uniqueWithDuplicateNulls,
1:0c5bc3a:                         cChars[0], // deferrable?
1:0c5bc3a:                         cChars[1], // initiallyDeferred?
1:28e234d: 						null, constraintDN,
1:28e234d: 						columnNames, true, tableSd, tableName,
1:28e234d: 						constraintType, dd);
1:28e234d: 				} 
1:28e234d:                 else 
1:4cc0287:                 {   // PRIMARY KEY, FOREIGN KEY
1:4cc0287:                     // For foreign key constraint we do no mark the
1:4cc0287:                     // index as deferrable; since checking isn't done on
1:4cc0287:                     // duplicate keys there.
1:28e234d: 					indexAction = genIndexAction(
1:28e234d: 						forCreateTable,
1:28e234d: 						constraintDN.requiresUniqueIndex(), false,
1:2db96c5:                         cChars[0],
1:2db96c5:                         cChars[1],
1:28e234d: 						null, constraintDN,
1:28e234d: 						columnNames, true, tableSd, tableName,
1:28e234d: 						constraintType, dd);
1:28e234d: 				}
1:fe77ca5: 			}
1:fe77ca5: 
1:fe77ca5: 			if (constraintType == DataDictionary.DROP_CONSTRAINT)
1:28e234d: 			{
1:1b41764:                 if (SanityManager.DEBUG)
1:1b41764:                 {
1:68db840:                     // Can't drop constraints on a create table.
1:68db840:                     SanityManager.ASSERT(!forCreateTable);
1:68db840:                 }
1:fe77ca5: 				conActions[conActionIndex] = 
1:fe77ca5: 					getGenericConstantActionFactory().
1:fe77ca5: 						getDropConstraintConstantAction(
1:fe77ca5: 												 constraintName, 
1:fe77ca5: 												 constraintDN.getDropSchemaName(), /// FiX
4:fe77ca5: 												 tableName,
2:fe77ca5: 												 td.getUUID(),
1:fe77ca5: 												 tableSd.getSchemaName(),
1:fe77ca5: 												 indexAction,
1:fe77ca5: 												 constraintDN.getDropBehavior(),
1:fe77ca5:                                                  constraintDN.getVerifyType());
1:fe77ca5: 			}
1:09bee7d:             else if (constraintType == DataDictionary.MODIFY_CONSTRAINT) {
1:09bee7d:                 conActions[conActionIndex] =
1:09bee7d:                     getGenericConstantActionFactory().
1:09bee7d:                         getAlterConstraintConstantAction(
1:09bee7d:                                                  constraintName,
1:09bee7d:                                                  constraintDN.getDropSchemaName(),
1:09bee7d:                                                  cChars,
1:09bee7d:                                                  tableName,
1:09bee7d:                                                  td.getUUID(),
1:09bee7d:                                                  tableSd.getSchemaName(),
1:09bee7d:                                                  indexAction);
1:09bee7d: 
1:09bee7d:             }
4:fe77ca5: 			else
1:fe77ca5: 			{
1:fe77ca5: 				ProviderList apl = constraintDN.getAuxiliaryProviderList();
1:fe77ca5: 				ConstraintInfo refInfo = null;
1:3bb140c:                 ProviderInfo[]  providerInfos;
1:fe77ca5: 
1:fe77ca5: 				if (constraintDN instanceof FKConstraintDefinitionNode)
1:fe77ca5: 				{
1:fe77ca5: 					refInfo = ((FKConstraintDefinitionNode)constraintDN).getReferencedConstraintInfo();
1:fe77ca5: 				}				
1:fe77ca5: 
1:fe77ca5: 				/* Create the ProviderInfos, if the constraint is dependent on any Providers */
1:fe77ca5: 				if (apl != null && apl.size() > 0)
1:fe77ca5: 				{
1:fe77ca5: 					/* Get all the dependencies for the current statement and transfer
1:fe77ca5: 					 * them to this view.
1:fe77ca5: 					 */
1:fe77ca5: 					DependencyManager dm = dd.getDependencyManager();
1:fe77ca5: 					providerInfos = dm.getPersistentProviderInfos(apl);
1:fe77ca5: 				}
1:fe77ca5: 				else
1:fe77ca5: 				{
1:fe77ca5: 					providerInfos = new ProviderInfo[0];
1:867a530: 					// System.out.println("TABLE ELEMENT LIST EMPTY");
1:fe77ca5: 				}
1:fe77ca5: 
1:fe77ca5: 				conActions[conActionIndex++] = 
1:fe77ca5: 					getGenericConstantActionFactory().
1:fe77ca5: 						getCreateConstraintConstantAction(
1:fe77ca5: 												 constraintName, 
1:fe77ca5: 											     constraintType,
1:09bee7d:                                                  cChars,
1:1b41764:                                                  forCreateTable,
1:68db840: 												 tableName, 
2:fe77ca5: 												 ((td != null) ? td.getUUID() : (UUID) null),
1:fe77ca5: 												 tableSd.getSchemaName(),
2:fe77ca5: 												 columnNames,
1:fe77ca5: 												 indexAction,
1:fe77ca5: 												 constraintText,
1:fe77ca5: 												 refInfo,
1:fe77ca5: 												 providerInfos);
1:fe77ca5: 			}
1:fe77ca5: 		}
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5:       //check if one array is same as another 
1:fe77ca5: 	private boolean columnsMatch(String[] columnNames1, String[] columnNames2)
1:fe77ca5: 	{
1:fe77ca5: 		int srcCount, srcSize, destCount,destSize;
1:fe77ca5: 
1:fe77ca5: 		if (columnNames1.length != columnNames2.length)
2:fe77ca5: 			return false;
1:fe77ca5: 
1:fe77ca5: 		srcSize = columnNames1.length;
1:fe77ca5: 		destSize = columnNames2.length;
1:fe77ca5: 
1:fe77ca5: 		for (srcCount = 0; srcCount < srcSize; srcCount++)
1:fe77ca5: 		{
1:3bb140c:             boolean match = false;
1:fe77ca5: 			for (destCount = 0; destCount < destSize; destCount++) {
1:fe77ca5: 				if (columnNames1[srcCount].equals(columnNames2[destCount])) {
1:fe77ca5: 					match = true;
1:fe77ca5: 					break;
1:fe77ca5: 				}
1:fe77ca5: 			}
1:fe77ca5: 			if (match == false)
1:fe77ca5: 				return false;
1:fe77ca5: 		}
1:fe77ca5: 
2:fe77ca5: 		return true;
1:fe77ca5: 	}
1:fe77ca5: 
1:28e234d:     /**
1:28e234d:      * utility to generated the call to create the index.
1:28e234d:      * <p>
1:28e234d:      *
1:28e234d:      *
1:28e234d:      * @param forCreateTable                Executed as part of a CREATE TABLE
1:28e234d:      * @param isUnique		                True means it will be a unique index
1:28e234d:      * @param isUniqueWithDuplicateNulls    True means index check and disallow
1:28e234d:      *                                      any duplicate key if key has no 
1:28e234d:      *                                      column with a null value.  If any 
1:28e234d:      *                                      column in the key has a null value,
1:28e234d:      *                                      no checking is done and insert will
1:28e234d:      *                                      always succeed.
1:0c5bc3a:      * @param hasDeferrableChecking         True if index is used to back a
1:0c5bc3a:      *                                      deferrable constraint
1:0c5bc3a:      * @param initiallyDeferred             True means the deferrable constraint
1:0c5bc3a:      *                                      has deferred mode
1:28e234d:      * @param indexName	                    The type of index (BTREE, for 
1:28e234d:      *                                      example)
1:28e234d:      * @param cdn
1:28e234d:      * @param columnNames	                Names of the columns in the index,
1:28e234d:      *                                      in order.
1:28e234d:      * @param isConstraint	                TRUE if index is backing up a 
1:28e234d:      *                                      constraint, else FALSE.
1:28e234d:      * @param sd
1:28e234d:      * @param tableName	                    Name of table the index will be on
1:28e234d:      * @param constraintType
1:28e234d:      * @param dd
1:28e234d:      **/
1:fe77ca5: 	private IndexConstantAction genIndexAction(
1:28e234d:     boolean                     forCreateTable,
1:28e234d:     boolean                     isUnique,
1:28e234d:     boolean                     isUniqueWithDuplicateNulls,
1:0c5bc3a:     boolean                     hasDeferrableChecking,
1:0c5bc3a:     boolean                     initiallyDeferred,
1:28e234d:     String                      indexName,
1:28e234d:     ConstraintDefinitionNode    cdn,
1:28e234d:     String[]                    columnNames,
1:28e234d:     boolean                     isConstraint,
1:28e234d:     SchemaDescriptor            sd,
1:28e234d:     String                      tableName,
1:28e234d:     int                         constraintType,
1:28e234d:     DataDictionary              dd)
1:fe77ca5: 		throws StandardException
1:28e234d: 	{
1:28e234d: 		if (indexName == null) 
1:28e234d:         { 
1:28e234d:             indexName = cdn.getBackingIndexName(dd); 
1:28e234d:         }
1:fe77ca5: 
1:fe77ca5: 		if (constraintType == DataDictionary.DROP_CONSTRAINT)
1:fe77ca5: 		{
2:fe77ca5:             if (SanityManager.DEBUG)
1:fe77ca5:             {
1:1b41764:                 if (forCreateTable)
1:28e234d:                     SanityManager.THROWASSERT(
1:28e234d:                         "DROP INDEX with forCreateTable true");
1:1b41764:             }
1:28e234d: 
1:28e234d: 			return getGenericConstantActionFactory().getDropIndexConstantAction(
1:28e234d:                       null,
1:28e234d:                       indexName,
1:28e234d:                       tableName,
1:28e234d:                       sd.getSchemaName(),
1:28e234d:                       td.getUUID(),
1:28e234d:                       td.getHeapConglomerateId());
1:fe77ca5: 		}
1:28e234d: 		else
1:fe77ca5: 		{
1:fe77ca5: 			boolean[]	isAscending = new boolean[columnNames.length];
1:28e234d: 
1:fe77ca5: 			for (int i = 0; i < isAscending.length; i++)
1:fe77ca5: 				isAscending[i] = true;
1:28e234d: 
1:fe77ca5: 			return	getGenericConstantActionFactory().getCreateIndexConstantAction(
1:28e234d:                     forCreateTable, 
1:28e234d:                     isUnique, 
1:28e234d:                     isUniqueWithDuplicateNulls,
1:0c5bc3a:                     hasDeferrableChecking,
1:0c5bc3a:                     initiallyDeferred,
1:2db96c5:                     constraintType,
1:28e234d:                     "BTREE", // indexType
1:28e234d:                     sd.getSchemaName(),
1:28e234d:                     indexName,
1:28e234d:                     tableName,
1:28e234d:                     ((td != null) ? td.getUUID() : (UUID) null),
1:28e234d:                     columnNames,
1:28e234d:                     isAscending,
1:28e234d:                     isConstraint,
1:28e234d:                     cdn.getBackingIndexUUID(),
1:e594ab0:                     checkIndexPageSizeProperty(cdn));
1:fe77ca5: 		}
1:fe77ca5: 	}
1:e594ab0:     /**
1:e594ab0:      * Checks if the index should use a larger page size.
1:e594ab0:      *
1:e594ab0:      * If the columns in the index are large, and if the user hasn't already
1:e594ab0:      * specified a page size to use, then we may need to default to the
1:e594ab0:      * large page size in order to get an index with sufficiently large pages.
1:e594ab0:      * For example, this DDL should use a larger page size for the index
1:e594ab0:      * that backs the PRIMARY KEY constraint:
1:e594ab0:      *
1:e594ab0:      * create table t (x varchar(1000) primary key)
1:e594ab0:      *
1:e594ab0:      * @param cdn Constraint node
1:e594ab0:      *
1:e594ab0:      * @return properties to use for creating the index
1:e594ab0:      */
1:e594ab0:     private Properties checkIndexPageSizeProperty(ConstraintDefinitionNode cdn) 
1:e594ab0:         throws StandardException
1:e594ab0:     {
1:e594ab0:         Properties result = cdn.getProperties();
1:e594ab0:         if (result == null)
1:e594ab0:             result = new Properties();
1:e594ab0:         if ( result.get(Property.PAGE_SIZE_PARAMETER) != null ||
1:e594ab0:              PropertyUtil.getServiceProperty(
1:e594ab0:                  getLanguageConnectionContext().getTransactionCompile(),
1:e594ab0:                  Property.PAGE_SIZE_PARAMETER) != null)
1:e594ab0:         {
1:e594ab0:             // do not override the user's choice of page size, whether it
1:e594ab0:             // is set for the whole database or just set on this statement.
1:e594ab0:             return result;
1:e594ab0:         }
1:e1f49ca: 
1:e594ab0:         int approxLength = 0;
1:e1f49ca: 
1:e1f49ca:         for (ResultColumn rc : cdn.getColumnList())
1:e594ab0:         {
1:e1f49ca:             String colName = rc.getName();
1:e594ab0:             DataTypeDescriptor dtd;
1:e594ab0:             if (td == null)
1:e594ab0:                 dtd = getColumnDataTypeDescriptor(colName);
1:e594ab0:             else
1:e594ab0:                 dtd = getColumnDataTypeDescriptor(colName, td);
1:e594ab0:             // There may be no DTD if the column does not exist. That syntax
1:e594ab0:             // error is not caught til later in processing, so here we just
1:e594ab0:             // skip the length checking if the column doesn't exist.
1:e594ab0:             if (dtd != null)
1:e594ab0:                 approxLength+=dtd.getTypeId().getApproximateLengthInBytes(dtd);
1:e594ab0:         }
1:e594ab0:         if (approxLength > Property.IDX_PAGE_SIZE_BUMP_THRESHOLD)
1:e594ab0:         {
1:e594ab0:             result.put(
1:e594ab0:                     Property.PAGE_SIZE_PARAMETER,
1:e594ab0:                     Property.PAGE_SIZE_DEFAULT_LONG);
1:e594ab0:         }
1:e594ab0:         return result;
1:e594ab0:     }
1:e594ab0: 
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Check to make sure that there are no duplicate column names
1:fe77ca5: 	 * in the list.  (The comparison here is case sensitive.
1:fe77ca5: 	 * The work of converting column names that are not quoted
1:fe77ca5: 	 * identifiers to upper case is handled by the parser.)
1:fe77ca5: 	 * RESOLVE: This check will also be performed by alter table.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @param ddlStmt	DDLStatementNode which contains this list
1:234a2b6:      * @param seenNames The column names seen so far (for enforcing uniqueness)
1:fe77ca5: 	 * @param colName	Column name to check for.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @exception StandardException		Thrown on error
1:fe77ca5: 	 */
1:fe77ca5: 	private void checkForDuplicateColumns(DDLStatementNode ddlStmt,
1:71c8e86: 									Set<String> seenNames,
1:fe77ca5: 									String colName)
1:fe77ca5: 			throws StandardException
1:fe77ca5: 	{
1:234a2b6: 		if (!seenNames.add(colName))
1:fe77ca5: 		{
1:fe77ca5: 			/* RESOLVE - different error messages for create and alter table */
1:fe77ca5: 			if (ddlStmt instanceof CreateTableNode)
1:fe77ca5: 			{
1:fe77ca5: 				throw StandardException.newException(SQLState.LANG_DUPLICATE_COLUMN_NAME_CREATE, colName);
1:fe77ca5: 			}
1:fe77ca5: 		}
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Check to make sure that there are no duplicate constraint names
1:fe77ca5: 	 * in the list.  (The comparison here is case sensitive.
1:fe77ca5: 	 * The work of converting column names that are not quoted
1:fe77ca5: 	 * identifiers to upper case is handled by the parser.)
1:fe77ca5: 	 * RESOLVE: This check will also be performed by alter table.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @param ddlStmt	DDLStatementNode which contains this list
1:234a2b6:      * @param seenNames The constraint names seen so far (for enforcing
1:234a2b6:      *                  uniqueness)
1:fe77ca5: 	 *
1:fe77ca5: 	 * @exception StandardException		Thrown on error
1:fe77ca5: 	 */
1:fe77ca5: 	private void checkForDuplicateConstraintNames(DDLStatementNode ddlStmt,
1:71c8e86: 									Set<String> seenNames,
1:fe77ca5: 									String constraintName)
1:fe77ca5: 			throws StandardException
1:fe77ca5: 	{
1:fe77ca5: 		if (constraintName == null)
1:fce10ba: 			return;
1:fce10ba: 
1:234a2b6: 		if (!seenNames.add(constraintName)) {
1:fe77ca5: 
1:fe77ca5: 			/* RESOLVE - different error messages for create and alter table */
1:fe77ca5: 			if (ddlStmt instanceof CreateTableNode)
1:fce10ba: 			{
1:fe77ca5: 				/* RESOLVE - new error message */
1:fe77ca5: 				throw StandardException.newException(SQLState.LANG_DUPLICATE_CONSTRAINT_NAME_CREATE, 
1:fe77ca5: 						constraintName);
1:fce10ba: 			}
1:fce10ba: 		}
1:fce10ba: 	}
1:fe77ca5: 
1:fce10ba: 	/**
1:fe77ca5: 	 * Verify that a primary/unique table constraint has a valid column list.
1:fe77ca5: 	 * (All columns in table and no duplicates.)
1:fe77ca5: 	 *
1:fe77ca5: 	 * @param ddlStmt	The outer DDLStatementNode
2:fe77ca5: 	 * @param cdn		The ConstraintDefinitionNode
1:fe77ca5: 	 *
1:fe77ca5: 	 * @exception	StandardException	Thrown if the column list is invalid
1:fe77ca5: 	 */
1:fe77ca5: 	private void verifyUniqueColumnList(DDLStatementNode ddlStmt,
1:fe77ca5: 								ConstraintDefinitionNode cdn)
1:fe77ca5: 		throws StandardException
1:fe77ca5: 	{
1:fe77ca5: 		String invalidColName;
1:fe77ca5: 
1:fe77ca5: 		/* Verify that every column in the list appears in the table's list of columns */
1:fe77ca5: 		if (ddlStmt instanceof CreateTableNode)
1:fe77ca5: 		{
1:fe77ca5: 			invalidColName = cdn.getColumnList().verifyCreateConstraintColumnList(this);
1:fe77ca5: 			if (invalidColName != null)
1:fe77ca5: 			{
1:fe77ca5: 				throw StandardException.newException(SQLState.LANG_INVALID_CREATE_CONSTRAINT_COLUMN_LIST, 
1:fe77ca5: 								ddlStmt.getRelativeName(),
1:fe77ca5: 								invalidColName);
1:fce10ba: 			}
1:fe77ca5: 		}
1:fce10ba: 		else
1:fe77ca5: 		{
1:fe77ca5: 			/* RESOLVE - alter table will need to get table descriptor */
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 		/* Check the uniqueness of the column names within the list */
1:fe77ca5: 		invalidColName = cdn.getColumnList().verifyUniqueNames(false);
1:fe77ca5: 		if (invalidColName != null)
1:fe77ca5: 		{
1:fe77ca5: 			throw StandardException.newException(SQLState.LANG_DUPLICATE_CONSTRAINT_COLUMN_NAME, invalidColName);
1:fe77ca5: 		}
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:02e0ae5: 	 * Set all columns in that appear in a PRIMARY KEY constraint in a CREATE TABLE statement to NOT NULL.
1:fe77ca5: 	 *
1:02e0ae5: 	 * @param cdn		The ConstraintDefinitionNode for a PRIMARY KEY constraint
1:fe77ca5: 	 */
1:02e0ae5: 	private void setColumnListToNotNull(ConstraintDefinitionNode cdn)
1:fe77ca5: 	{
1:e1f49ca:         for (ResultColumn rc : cdn.getColumnList())
1:fe77ca5: 		{
1:e1f49ca:             findColumnDefinition(rc.getName()).setNullability(false);
1:fe77ca5:         }
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5:     /**
1:28e234d:      * Checks if any of the columns in the constraint can be null.
1:fe77ca5:      *
1:28e234d:      * @param cdn Constraint node
1:28e234d:      * @param td tabe descriptor of the target table
1:fe77ca5:      *
1:28e234d:      * @return true if any of the column can be null false other wise
1:fe77ca5:      */
1:28e234d:     private boolean areColumnsNullable (
1:28e234d:     ConstraintDefinitionNode    cdn, 
1:28e234d:     TableDescriptor             td) 
1:28e234d:     {
1:e1f49ca:         for (ResultColumn rc : cdn.getColumnList())
1:28e234d:         {
1:e1f49ca:             String colName = rc.getName();
1:e1f49ca: 
1:e1f49ca:             DataTypeDescriptor dtd = (td == null) ?
1:e1f49ca:                 getColumnDataTypeDescriptor(colName) :
1:e1f49ca:                 getColumnDataTypeDescriptor(colName, td);
1:e1f49ca: 
1:28e234d:             // todo dtd may be null if the column does not exist, we should check that first
1:28e234d:             if (dtd != null && dtd.isNullable())
1:28e234d:             {
1:28e234d:                 return true;
1:28e234d:             }
1:28e234d:         }
1:28e234d:         return false;
1:28e234d:     }
1:fe77ca5: 
1:02e0ae5:     private void checkForNullColumns(ConstraintDefinitionNode cdn, TableDescriptor td) throws StandardException
1:28e234d:     {
1:e1f49ca:         for (ResultColumn rc : cdn.getColumnList())
1:fe77ca5:         {
1:e1f49ca:             DataTypeDescriptor dtd = (td == null) ?
1:e1f49ca:                     getColumnDataTypeDescriptor(rc.getName()) :
1:e1f49ca:                     getColumnDataTypeDescriptor(rc.getName(), td);
1:e1f49ca: 
1:02e0ae5:             // todo dtd may be null if the column does not exist, we should check that first
1:02e0ae5:             if (dtd != null && dtd.isNullable())
1:fe77ca5:             {
1:cd38662:                 String errorState = 
1:cd38662:                    (getLanguageConnectionContext().getDataDictionary()
1:cd38662:                         .checkVersion(DataDictionary.DD_VERSION_DERBY_10_4, null))
1:cd38662:                     ? SQLState.LANG_ADD_PRIMARY_KEY_ON_NULL_COLS
1:cd38662:                     : SQLState.LANG_DB2_ADD_UNIQUE_OR_PRIMARY_KEY_ON_NULL_COLS;
1:cd38662: 
1:e1f49ca:                 throw StandardException.newException(errorState, rc.getName());
1:28e234d:             }
1:28e234d:         }
1:fe77ca5:     }
1:fe77ca5: 
1:02e0ae5:     private DataTypeDescriptor getColumnDataTypeDescriptor(String colName)
1:fe77ca5:     {
1:bd66456:         ColumnDefinitionNode col = findColumnDefinition(colName);
1:bd66456:         if (col != null)
1:bd66456:             return col.getType();
1:fe77ca5: 
1:02e0ae5:         return null;
1:fe77ca5:     }
1:fe77ca5: 
1:02e0ae5:     private DataTypeDescriptor getColumnDataTypeDescriptor(String colName, TableDescriptor td)
1:fe77ca5:     {
1:02e0ae5:         // check existing columns
1:fe77ca5:         ColumnDescriptor cd = td.getColumnDescriptor(colName);
1:02e0ae5:         if (cd != null)
1:fe77ca5:         {
1:02e0ae5:             return cd.getType();
1:fe77ca5:         }
1:02e0ae5:         // check for new columns
1:02e0ae5:         return getColumnDataTypeDescriptor(colName);
1:fe77ca5:     }
1:bd66456:     
1:bd66456:     /**
1:bd66456:      * Find the column definition node in this list that matches
1:bd66456:      * the passed in column name.
1:bd66456:      * @param colName
1:bd66456:      * @return Reference to column definition node or null if the column is
1:bd66456:      * not in the list.
1:bd66456:      */
1:bd66456:     private ColumnDefinitionNode findColumnDefinition(String colName) {
1:e1f49ca:         for (TableElementNode te : this) {
1:e1f49ca:             if (te instanceof ColumnDefinitionNode) {
1:e1f49ca:                 ColumnDefinitionNode cdn = (ColumnDefinitionNode) te;
1:bd66456:                 if (colName.equals(cdn.getName())) {
1:bd66456:                     return cdn;
1:bd66456:                 }
1:bd66456:             }
1:bd66456:         }
1:bd66456:         return null;
1:bd66456:     }
1:bd66456:     
1:bd66456: 
1:fe77ca5: 	/**
1:bd66456:      * Determine whether or not the parameter matches a column name in this
1:bd66456:      * list.
1:bd66456:      * 
1:bd66456:      * @param colName
1:bd66456:      *            The column name to search for.
1:bd66456:      * 
1:bd66456:      * @return boolean Whether or not a match is found.
1:bd66456:      */
1:3bb140c:     boolean containsColumnName(String colName)
1:fe77ca5: 	{
1:bd66456:         return findColumnDefinition(colName) != null;
1:fe77ca5: 	}
1:fe77ca5: }
1:fe77ca5: 
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:d055adb
/////////////////////////////////////////////////////////////////////////
1: 								ColumnInfo.DROP, 0, 0, 0, 0);
/////////////////////////////////////////////////////////////////////////
1: 							   (coldef.isAutoincrementColumn() ?
1:  								coldef.getAutoincrementCycle() : 0),
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
commit:e594ab0
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.reference.Property;
1: import org.apache.derby.iapi.services.property.PropertyUtil;
/////////////////////////////////////////////////////////////////////////
1: import java.util.Properties;
/////////////////////////////////////////////////////////////////////////
1:                     checkIndexPageSizeProperty(cdn));
1:     /**
1:      * Checks if the index should use a larger page size.
1:      *
1:      * If the columns in the index are large, and if the user hasn't already
1:      * specified a page size to use, then we may need to default to the
1:      * large page size in order to get an index with sufficiently large pages.
1:      * For example, this DDL should use a larger page size for the index
1:      * that backs the PRIMARY KEY constraint:
1:      *
1:      * create table t (x varchar(1000) primary key)
1:      *
1:      * @param cdn Constraint node
1:      *
1:      * @return properties to use for creating the index
1:      */
1:     private Properties checkIndexPageSizeProperty(ConstraintDefinitionNode cdn) 
1:         throws StandardException
1:     {
1:         Properties result = cdn.getProperties();
1:         if (result == null)
1:             result = new Properties();
1:         if ( result.get(Property.PAGE_SIZE_PARAMETER) != null ||
1:              PropertyUtil.getServiceProperty(
1:                  getLanguageConnectionContext().getTransactionCompile(),
1:                  Property.PAGE_SIZE_PARAMETER) != null)
1:         {
1:             // do not override the user's choice of page size, whether it
1:             // is set for the whole database or just set on this statement.
1:             return result;
1:         }
0:         ResultColumnList rcl = cdn.getColumnList();
1:         int approxLength = 0;
0:         for (int index = 0; index < rcl.size(); index++)
1:         {
0:             String colName = ((ResultColumn) rcl.elementAt(index)).getName();
1:             DataTypeDescriptor dtd;
1:             if (td == null)
1:                 dtd = getColumnDataTypeDescriptor(colName);
1:             else
1:                 dtd = getColumnDataTypeDescriptor(colName, td);
1:             // There may be no DTD if the column does not exist. That syntax
1:             // error is not caught til later in processing, so here we just
1:             // skip the length checking if the column doesn't exist.
1:             if (dtd != null)
1:                 approxLength+=dtd.getTypeId().getApproximateLengthInBytes(dtd);
1:         }
1:         if (approxLength > Property.IDX_PAGE_SIZE_BUMP_THRESHOLD)
1:         {
1:             result.put(
1:                     Property.PAGE_SIZE_PARAMETER,
1:                     Property.PAGE_SIZE_DEFAULT_LONG);
1:         }
1:         return result;
1:     }
1: 
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:b5392db
/////////////////////////////////////////////////////////////////////////
1:         // Raise an error if we have more than one autoincrement column in a
1:         // CREATE TABLE statement, or if we are adding a new autoincrement
1:         // column to an existing table that already has an autoincrement column,
1:         // with ALTER TABLE ADD COLUMN.
1:         if (numAutoCols > 1 ||
1:                 (numAutoCols > 0 && td != null && td.tableHasAutoincrement())) {
1:         }
commit:9d9f6dd
/////////////////////////////////////////////////////////////////////////
1: 
1:             // Make sure all names are schema qualified (DERBY-6362)
1:             cdn.qualifyNames();
commit:28f9484
/////////////////////////////////////////////////////////////////////////
1:             /* We have a valid check constraint.
1:              * Now we build a list with only the referenced columns and
1:             ResultColumnList rcl = table.getResultColumns();
1:             int numReferenced = rcl.countReferencedColumns();
commit:b153b24
/////////////////////////////////////////////////////////////////////////
0:         ArrayList constraints = new ArrayList();
/////////////////////////////////////////////////////////////////////////
1:                         constraints.add(cd);
/////////////////////////////////////////////////////////////////////////
1:             // If constraint is primary key or unique key, add it to the list.
1:                 /* In case of create table, the list can have only ConstraintDefinitionNode
/////////////////////////////////////////////////////////////////////////
1:                 for (int i = 0; i < constraints.size(); i++)
1:                     destConstraint = constraints.get(i);
/////////////////////////////////////////////////////////////////////////
1:                 constraints.add(cdn);
commit:09c2697
/////////////////////////////////////////////////////////////////////////
0:         ArrayList aggregates = new ArrayList();
/////////////////////////////////////////////////////////////////////////
1:                 checkTree = checkTree.bindExpression(
1:                         fromList, (SubqueryList) null, aggregates);
1:                 if (!aggregates.isEmpty())
/////////////////////////////////////////////////////////////////////////
0:         ArrayList aggregates = new ArrayList();
/////////////////////////////////////////////////////////////////////////
1:                 generationTree = generationClauseNode.bindExpression(
1:                         fromList, (SubqueryList) null, aggregates);
/////////////////////////////////////////////////////////////////////////
1:                 if (!aggregates.isEmpty())
commit:43fdf45
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 		ArrayList aggregateVector = new ArrayList();
/////////////////////////////////////////////////////////////////////////
0: 				if (!aggregateVector.isEmpty())
/////////////////////////////////////////////////////////////////////////
0: 		ArrayList aggregateVector = new ArrayList();
/////////////////////////////////////////////////////////////////////////
0: 				if (!aggregateVector.isEmpty())
commit:234a2b6
/////////////////////////////////////////////////////////////////////////
1: import java.util.Set;
/////////////////////////////////////////////////////////////////////////
0:         HashSet columnNames = new HashSet(size + 2, 0.999f);
0:         HashSet constraintNames = new HashSet(size + 2, 0.999f);
0:         ArrayList constraintsVector = new ArrayList();
/////////////////////////////////////////////////////////////////////////
1: 				checkForDuplicateColumns(ddlStmt, columnNames, cdn.getColumnName());
/////////////////////////////////////////////////////////////////////////
1:             checkForDuplicateConstraintNames(ddlStmt, constraintNames, cdn.getConstraintMoniker());
/////////////////////////////////////////////////////////////////////////
1:      * @param seenNames The column names seen so far (for enforcing uniqueness)
0: 									Set seenNames,
1: 		if (!seenNames.add(colName))
/////////////////////////////////////////////////////////////////////////
1:      * @param seenNames The constraint names seen so far (for enforcing
1:      *                  uniqueness)
0: 									Set seenNames,
1: 		if (!seenNames.add(constraintName)) {
commit:47d4a4c
/////////////////////////////////////////////////////////////////////////
1:                     {
0:                         constraintsVector.add(cd);
1:                     }
/////////////////////////////////////////////////////////////////////////
0: 					destConstraint = constraintsVector.get(i);
/////////////////////////////////////////////////////////////////////////
0: 				constraintsVector.add(cdn);
commit:c0a807c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
0:             List                    referencedColumns = generationClauseNode.findReferencedColumns();
0:                 String name = ((ColumnReference) referencedColumns.get(j)).getColumnName();
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:b737f16
/////////////////////////////////////////////////////////////////////////
1:                 SelectNode.checkNoWindowFunctions(generationClauseNode, "generation clause");
1: 
commit:2db96c5
/////////////////////////////////////////////////////////////////////////
1:                         cChars[0],
1:                         cChars[1],
/////////////////////////////////////////////////////////////////////////
1:                     constraintType,
commit:4cc0287
/////////////////////////////////////////////////////////////////////////
1:                 {   // PRIMARY KEY, FOREIGN KEY
1:                     // For foreign key constraint we do no mark the
1:                     // index as deferrable; since checking isn't done on
1:                     // duplicate keys there.
0:                         cChars[0] &                     // deferrable ?
0:                                 (constraintType !=
0:                                  DataDictionary.FOREIGNKEY_CONSTRAINT),
0:                         cChars[1] &                     // initiallyDeferred ?
0:                                 (constraintType !=
0:                                  DataDictionary.FOREIGNKEY_CONSTRAINT),
commit:0c5bc3a
/////////////////////////////////////////////////////////////////////////
1:                         cChars[0], // deferrable?
1:                         cChars[1], // initiallyDeferred?
/////////////////////////////////////////////////////////////////////////
0:                         cChars[0], // deferrable
0:                         cChars[1], // initiallyDeferred?
/////////////////////////////////////////////////////////////////////////
1:      * @param hasDeferrableChecking         True if index is used to back a
1:      *                                      deferrable constraint
1:      * @param initiallyDeferred             True means the deferrable constraint
1:      *                                      has deferred mode
/////////////////////////////////////////////////////////////////////////
1:     boolean                     hasDeferrableChecking,
1:     boolean                     initiallyDeferred,
/////////////////////////////////////////////////////////////////////////
1:                     hasDeferrableChecking,
1:                     initiallyDeferred,
commit:09bee7d
/////////////////////////////////////////////////////////////////////////
1:             if (cdn.getConstraintType() == DataDictionary.DROP_CONSTRAINT ||
1:                 cdn.getConstraintType() == DataDictionary.MODIFY_CONSTRAINT)
/////////////////////////////////////////////////////////////////////////
1:                         throw StandardException.newException(SQLState.LANG_DROP_OR_ALTER_NON_EXISTING_CONSTRAINT,
/////////////////////////////////////////////////////////////////////////
1:         if (coldef.hasConstraint())
/////////////////////////////////////////////////////////////////////////
1:             boolean[] cChars = constraintDN.getCharacteristics();
/////////////////////////////////////////////////////////////////////////
1:             else if (constraintType == DataDictionary.MODIFY_CONSTRAINT) {
1:                 conActions[conActionIndex] =
1:                     getGenericConstantActionFactory().
1:                         getAlterConstraintConstantAction(
1:                                                  constraintName,
1:                                                  constraintDN.getDropSchemaName(),
1:                                                  cChars,
1:                                                  tableName,
1:                                                  td.getUUID(),
1:                                                  tableSd.getSchemaName(),
1:                                                  indexAction);
1: 
1:             }
/////////////////////////////////////////////////////////////////////////
1:                                                  cChars,
/////////////////////////////////////////////////////////////////////////
commit:2706d1f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:e1f49ca
/////////////////////////////////////////////////////////////////////////
1: class TableElementList extends QueryTreeNodeVector<TableElementNode>
1:         super(TableElementNode.class, cm);
/////////////////////////////////////////////////////////////////////////
1:         for (TableElementNode te : this)
1:             if (te instanceof ColumnDefinitionNode)
1:                 setCollationTypeOnCharacterStringColumn(
1:                         sd, (ColumnDefinitionNode)te );
/////////////////////////////////////////////////////////////////////////
1:         for (TableElementNode tableElement : this)
1:                 ColumnDefinitionNode cdn = (ColumnDefinitionNode)tableElement;
/////////////////////////////////////////////////////////////////////////
1:         for (TableElementNode tableElement : this)
/////////////////////////////////////////////////////////////////////////
1:         for (TableElementNode element : this)
1:             if (element instanceof ConstraintDefinitionNode &&
1:                 ((ConstraintDefinitionNode)element).getConstraintType() ==
1:                     constraintType) {
1:                 numConstraints++;
1:             }
/////////////////////////////////////////////////////////////////////////
1:         for (TableElementNode element : this)
1:             if (element instanceof ColumnDefinitionNode &&
1:                     ((ColumnDefinitionNode)element).hasGenerationClause()) {
1:                 numGenerationClauses++;
1:             }
/////////////////////////////////////////////////////////////////////////
1:             if (elementAt(index).getElementType() == TableElementNode.AT_DROP_COLUMN)
1:                 String columnName = elementAt(index).getName();
/////////////////////////////////////////////////////////////////////////
1:         FromBaseTable table = (FromBaseTable) fromList.elementAt(0);
1:         CompilerContext cc = getCompilerContext();
1:         for (TableElementNode element : this)
/////////////////////////////////////////////////////////////////////////
1:                 String colName = cdn.getColumnList().elementAt(0).getName();
1:                     !colName.equals(refRCL.elementAt(0).getName()))
/////////////////////////////////////////////////////////////////////////
1:         FromBaseTable    table = (FromBaseTable) fromList.elementAt(0);
1:         ResultColumnList tableColumns = table.getResultColumns();
1:         int              columnCount = table.getResultColumns().size();
1:         CompilerContext cc = getCompilerContext();
1:         for (TableElementNode element : this)
/////////////////////////////////////////////////////////////////////////
1:                 referencedColumnNames[i] =
1:                     rcl.elementAt(generationClauseColumnReferences[i] - 1).
1:                         getName();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         for (TableElementNode element : this)
/////////////////////////////////////////////////////////////////////////
1:         for (TableElementNode element : this)
/////////////////////////////////////////////////////////////////////////
1:             for (ResultColumn keyCol : fk.getColumnList())
1:                 String keyColName = keyCol.getName();
1:                 int position = tableColumns.getPosition( keyColName, 1 );
/////////////////////////////////////////////////////////////////////////
1: 
1:         for (TableElementNode ten : this)
1:             if (! ten.hasConstraint() ||
1:                 ten instanceof ColumnDefinitionNode)
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:         for (ResultColumn rc : cdn.getColumnList())
1:             String colName = rc.getName();
/////////////////////////////////////////////////////////////////////////
1:         for (ResultColumn rc : cdn.getColumnList())
1:             findColumnDefinition(rc.getName()).setNullability(false);
/////////////////////////////////////////////////////////////////////////
1:         for (ResultColumn rc : cdn.getColumnList())
1:             String colName = rc.getName();
1: 
1:             DataTypeDescriptor dtd = (td == null) ?
1:                 getColumnDataTypeDescriptor(colName) :
1:                 getColumnDataTypeDescriptor(colName, td);
1: 
/////////////////////////////////////////////////////////////////////////
1:         for (ResultColumn rc : cdn.getColumnList())
1:             DataTypeDescriptor dtd = (td == null) ?
1:                     getColumnDataTypeDescriptor(rc.getName()) :
1:                     getColumnDataTypeDescriptor(rc.getName(), td);
1: 
/////////////////////////////////////////////////////////////////////////
1:                 throw StandardException.newException(errorState, rc.getName());
/////////////////////////////////////////////////////////////////////////
1:         for (TableElementNode te : this) {
1:             if (te instanceof ColumnDefinitionNode) {
1:                 ColumnDefinitionNode cdn = (ColumnDefinitionNode) te;
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.catalog.UUID;
1: import org.apache.derby.catalog.types.DefaultInfoImpl;
1: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.reference.Property;
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.services.context.ContextManager;
1: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: import org.apache.derby.iapi.services.property.PropertyUtil;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.sql.StatementType;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
1: import org.apache.derby.iapi.sql.compile.CompilerContext;
1: import org.apache.derby.iapi.sql.depend.DependencyManager;
1: import org.apache.derby.iapi.sql.depend.ProviderInfo;
1: import org.apache.derby.iapi.sql.depend.ProviderList;
1: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptorList;
1: import org.apache.derby.iapi.sql.dictionary.ConstraintDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.ConstraintDescriptorList;
1: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1: import org.apache.derby.iapi.types.DataTypeDescriptor;
1: import org.apache.derby.iapi.types.TypeId;
1: import org.apache.derby.impl.sql.execute.ColumnInfo;
1: import org.apache.derby.impl.sql.execute.ConstraintConstantAction;
1: import org.apache.derby.impl.sql.execute.ConstraintInfo;
1: import org.apache.derby.impl.sql.execute.IndexConstantAction;
/////////////////////////////////////////////////////////////////////////
0: class TableElementList extends QueryTreeNodeVector
1:     public TableElementList(ContextManager cm) {
0:         super(cm);
0:         setNodeType(C_NodeTypes.TABLE_ELEMENT_LIST);
1:     }
1: 
1:     void addTableElement(TableElementNode tableElement)
/////////////////////////////////////////////////////////////////////////
1: 
1:         for (int index = 0; index < size; index++)
/////////////////////////////////////////////////////////////////////////
1:             if ( !cdn.hasGenerationClause() )
/////////////////////////////////////////////////////////////////////////
1:     int countConstraints(int constraintType)
/////////////////////////////////////////////////////////////////////////
1:     int countGenerationClauses()
/////////////////////////////////////////////////////////////////////////
1:     int countNumberOfColumns()
/////////////////////////////////////////////////////////////////////////
1:     int genColumnInfos( ColumnInfo[] colInfos)
/////////////////////////////////////////////////////////////////////////
1:     void appendNewColumnsToRCL(FromBaseTable table)
/////////////////////////////////////////////////////////////////////////
1:                 valueNode = new BaseColumnNode(cdn.getColumnName(),
1:                 resultColumn = new ResultColumn(
1:                         cdn.getType(), valueNode, getContextManager());
/////////////////////////////////////////////////////////////////////////
1:             ResultColumnList refRCL = new ResultColumnList(getContextManager());
/////////////////////////////////////////////////////////////////////////
1:             ColumnDefinitionNode    cdn = generatedColumns.get( i );
1:             List<ColumnReference>   referencedColumns =
1:                 generationClauseNode.findReferencedColumns();
1:                 String name = referencedColumns.get(j).getColumnName();
/////////////////////////////////////////////////////////////////////////
1:                 ProviderInfo[]  providerInfos;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             boolean match = false;
/////////////////////////////////////////////////////////////////////////
1:     boolean containsColumnName(String colName)
commit:c9a1206
/////////////////////////////////////////////////////////////////////////
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:71c8e86
/////////////////////////////////////////////////////////////////////////
1:         HashSet<String> columnNames = new HashSet<String>(size + 2, 0.999f);
1:         HashSet<String> constraintNames = new HashSet<String>(size + 2, 0.999f);
1:         ArrayList<Object> constraints = new ArrayList<Object>();
/////////////////////////////////////////////////////////////////////////
1:         ArrayList<AggregateNode> aggregates = new ArrayList<AggregateNode>();
/////////////////////////////////////////////////////////////////////////
1:         ArrayList<AggregateNode> aggregates = new ArrayList<AggregateNode>();
/////////////////////////////////////////////////////////////////////////
1:         ArrayList<ColumnDefinitionNode>   generatedColumns = new ArrayList<ColumnDefinitionNode>();
1:         HashSet<String>     names = new HashSet<String>();
/////////////////////////////////////////////////////////////////////////
1: 									Set<String> seenNames,
/////////////////////////////////////////////////////////////////////////
1: 									Set<String> seenNames,
commit:e126f58
/////////////////////////////////////////////////////////////////////////
1: 
1:                 { numAutoCols ++; }
/////////////////////////////////////////////////////////////////////////
0:                 String columnName = ((TableElementNode) elementAt(index)).getName();
1: 
1: 								columnName,
1: 								td.getColumnDescriptor( columnName ).getType(),
1:                                 null, null, null, null, null,
/////////////////////////////////////////////////////////////////////////
1: 
commit:7168d7d
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptorList;
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayList;
1: import java.util.HashSet;
/////////////////////////////////////////////////////////////////////////
1: 	 * @param baseTable  Table descriptor if this is an ALTER TABLE statement.
1: 	void bindAndValidateGenerationClauses( SchemaDescriptor sd, FromList fromList, FormatableBitSet generatedColumns, TableDescriptor baseTable )
/////////////////////////////////////////////////////////////////////////
1:         // complain if a generation clause references another generated column
1:         findIllegalGenerationReferences( fromList, baseTable );
1: 
/////////////////////////////////////////////////////////////////////////
1:         
1: 	}
1: 
1: 	/**
1: 	 * Complain if a generation clause references other generated columns. This
1: 	 * is required by the SQL Standard, part 2, section 4.14.8.
1: 	 *
1: 	 * @param fromList		The FromList in question.
1: 	 * @param baseTable  Table descriptor if this is an ALTER TABLE statement.
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	void findIllegalGenerationReferences( FromList fromList, TableDescriptor baseTable )
1: 		throws StandardException
1: 	{
0:         ArrayList   generatedColumns = new ArrayList();
0:         HashSet     names = new HashSet();
0: 		int         size = size();
1: 
1:         // add in existing generated columns if this is an ALTER TABLE statement
1:         if ( baseTable != null )
1:         {
1:             ColumnDescriptorList cdl = baseTable.getGeneratedColumns();
1:             int                  count = cdl.size();
1:             for ( int i = 0; i < count; i++ )
1:             {
1:                 names.add( cdl.elementAt( i ).getColumnName() );
1:             }
1:         }
1:         
1:         // find all of the generated columns
0: 			TableElementNode     element = (TableElementNode) elementAt(index);
/////////////////////////////////////////////////////////////////////////
1:             generatedColumns.add( cdn );
1:             names.add( cdn.getColumnName() );
1:         }
1:         // now look at their generation clauses to see if they reference one
1:         // another
1:         int    count = generatedColumns.size();
1:         for ( int i = 0; i < count; i++ )
1:         {
0:             ColumnDefinitionNode    cdn = (ColumnDefinitionNode) generatedColumns.get( i );
1:             GenerationClauseNode    generationClauseNode = cdn.getGenerationClauseNode();
0:             Vector                  referencedColumns = generationClauseNode.findReferencedColumns();
1:             int                     refCount = referencedColumns.size();
1:             for ( int j = 0; j < refCount; j++ )
0:                 String  name = ((ColumnReference) referencedColumns.elementAt( j ) ).getColumnName();
1:                 if ( name != null )
1:                     if ( names.contains( name ) )
1:                     {
1:                         throw StandardException.newException(SQLState.LANG_CANT_REFERENCE_GENERATED_COLUMN, cdn.getColumnName());
1:                     }
1:             }
1:         }
1:     }
1:     
commit:b8b524c
/////////////////////////////////////////////////////////////////////////
1:             // validation of primary key nullability moved to validatePrimaryKeyNullability().
/////////////////////////////////////////////////////////////////////////
1: 	 * Validate nullability of primary keys. This logic was moved out of the main validate
1: 	 * method so that it can be called after binding generation clauses. We need
1: 	 * to perform the nullability checks later on because the datatype may be
1: 	 * omitted on the generation clause--we can't set/vet the nullability of the
1: 	 * datatype until we determine what the datatype is.
1: 	 */
1:     public  void    validatePrimaryKeyNullability()
1:         throws StandardException
1:     {
1: 		int			size = size();
1: 		for (int index = 0; index < size; index++)
1: 		{
0: 			TableElementNode tableElement = (TableElementNode) elementAt(index);
1: 
1: 			if (! (tableElement.hasConstraint()))
1: 			{
1: 				continue;
1: 			}
1:             
1: 			ConstraintDefinitionNode cdn = (ConstraintDefinitionNode) tableElement;
1: 
1:             if (cdn.hasPrimaryKeyConstraint())
1:             {
1:                 if (td == null)
1:                 {
1:                     // in CREATE TABLE so set PRIMARY KEY columns to NOT NULL
1:                     setColumnListToNotNull(cdn);
1:                 }
1:                 else
1:                 {
1:                     // in ALTER TABLE so raise error if any columns are nullable
1:                     checkForNullColumns(cdn, td);
1:                 }
1:             }
1:         }
1:     }
1:     
1:     /**
/////////////////////////////////////////////////////////////////////////
0:         ResultColumnList            tableColumns = table.getResultColumns();
/////////////////////////////////////////////////////////////////////////
1:                     // Poke the type into the FromTable so that constraints will
1:                     // compile.
1:                     //
1:                     tableColumns.getResultColumn( cdn.getColumnName(), false ).setType( generationClauseType );
1: 
1:                     //
commit:15b837e
/////////////////////////////////////////////////////////////////////////
1: 			// bind the generation clause
1:             ProviderList prevAPL = cc.getCurrentAuxiliaryProviderList();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 				// Restore previous compiler state
1: 				cc.setCurrentAuxiliaryProviderList(prevAPL);
commit:01aa176
/////////////////////////////////////////////////////////////////////////
1:             String              currentSchemaName = getLanguageConnectionContext().getCurrentSchemaName();
1:                 ( generationClauseNode.getExpressionText(), referencedColumnNames, currentSchemaName );
commit:fce10ba
/////////////////////////////////////////////////////////////////////////
1: 	void setCollationTypesOnCharacterStringColumns(SchemaDescriptor sd)
1:         throws StandardException
1:     {
/////////////////////////////////////////////////////////////////////////
1: 
1:                 setCollationTypeOnCharacterStringColumn( sd, cdn );
1: 	 * Use the passed schema descriptor's collation type to set the collation
1: 	 * of a character string column.
1: 	 * @param sd
1: 	 */
1: 	void setCollationTypeOnCharacterStringColumn(SchemaDescriptor sd, ColumnDefinitionNode cdn )
1:         throws StandardException
1:     {
1: 		int collationType = sd.getCollationType();
1: 
1:         //
1:         // Only generated columns can omit the datatype specification during the
1:         // early phases of binding--before we have been able to bind the
1:         // generation clause.
1:         //
1:         DataTypeDescriptor  dtd = cdn.getType();
1:         if ( dtd == null )
1:         {
0:             if ( cdn.hasGenerationClause() )
1:             {
1:                 return;
1:             }
1:             else
1:             {
1:                 throw StandardException.newException
1:                     ( SQLState.LANG_NEEDS_DATATYPE, cdn.getColumnName() );
1:             }
1:         }
1:         else
1:         {
1:             if ( dtd.getTypeId().isStringTypeId() ) { cdn.setCollationType(collationType); }
1:         }
1:     }
1:     
1: 	/**
/////////////////////////////////////////////////////////////////////////
0: 	 * @param fromList		Schema where the table lives.
0: 	void bindAndValidateGenerationClauses( SchemaDescriptor sd, FromList fromList, FormatableBitSet generatedColumns )
/////////////////////////////////////////////////////////////////////////
1:                 if ( declaredType == null )
1:                 {
1:                     cdn.setType( generationClauseType );
1: 
1:                     //
1:                     // We skipped these steps earlier on because we didn't have
1:                     // a datatype. Now that we have a datatype, revisit these
1:                     // steps.
1:                     //
0:                     setCollationTypeOnCharacterStringColumn( sd, cdn );
1:                     cdn.checkUserType( table.getTableDescriptor() );
1:                 }
1:                 else
commit:3c09be7
/////////////////////////////////////////////////////////////////////////
0: 	public int genColumnInfos( ColumnInfo[] colInfos)
1:         throws StandardException
/////////////////////////////////////////////////////////////////////////
0: 								null, null, null, null, null, null,
/////////////////////////////////////////////////////////////////////////
1: 				/* Remember how many constraints we've seen */
1:             //
1:             // Generated columns may depend on functions mentioned in their
1:             // generation clauses.
1:             //
1:             ProviderList apl = null;
1:             ProviderInfo[]	providerInfos = null;
1: 			if ( coldef.hasGenerationClause() )
1: 			{
1: 				apl = coldef.getGenerationClauseNode().getAuxiliaryProviderList();
1: 			}
1:             if (apl != null && apl.size() > 0)
1:             {
1:                 DependencyManager dm = getDataDictionary().getDependencyManager();
1:                 providerInfos = dm.getPersistentProviderInfos(apl);
1:             }
1:             
1: 							   providerInfos,
commit:7ae50e9
/////////////////////////////////////////////////////////////////////////
1: 
1:             String[]    referencedColumnNames = new String[ numReferenced ];
1: 
1:             for ( int i = 0; i < numReferenced; i++ )
1:             {
0:                 referencedColumnNames[ i ] = ((ResultColumn)rcl.elementAt( generationClauseColumnReferences[ i ] - 1 )).getName();
1:             }
1: 
0:                 ( generationClauseNode.getExpressionText(), referencedColumnNames );
/////////////////////////////////////////////////////////////////////////
1:         ResultColumnList rcl = table.getResultColumns();
/////////////////////////////////////////////////////////////////////////
0:             String[]   referencedColumnNames = cdn.getDefaultInfo().getReferencedColumnNames();
0:             int     count = referencedColumnNames.length;
0:                 String      name = referencedColumnNames[ i ];
0:                 int         referencedColumnID = rcl.getPosition( name, 1 );
1: 
commit:c0342de
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.sql.StatementType;
/////////////////////////////////////////////////////////////////////////
0:                 int         referencedColumnID = referencedColumns[ i ]; 
0:            }   // end of loop through referenced columns
1:         
1: 	 * Prevent foreign keys on generated columns from violating the SQL spec,
1: 	 * part 2, section 11.8 (<column definition>), syntax rule 12: the
1: 	 * referential action may not specify SET NULL or SET DEFAULT and the update
1: 	 * rule may not specify ON UPDATE CASCADE.  
1: 	 *
1: 	 * @param fromList		The FromList in question.
1: 	 * @param generatedColumns Bitmap of generated columns in the table.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	void validateForeignKeysOnGenerationClauses(FromList fromList, FormatableBitSet generatedColumns )
1: 		throws StandardException
1: 	{
1:         // nothing to do if there are no generated columns
1:         if ( generatedColumns.getNumBitsSet() <= 0 ) { return; }
1:         
1: 		FromBaseTable				table = (FromBaseTable) fromList.elementAt(0);
1:         ResultColumnList        tableColumns = table.getResultColumns();
0: 		int						  size = size();
1: 
1:         // loop through the foreign keys, looking for keys which violate the
1:         // rulse we're enforcing
0: 		for (int index = 0; index < size; index++)
1: 		{
0: 			TableElementNode element = (TableElementNode) elementAt(index);
1: 
1: 			if (! (element instanceof FKConstraintDefinitionNode))
1: 			{
1: 				continue;
1: 			}
1: 
1: 			FKConstraintDefinitionNode fk = (FKConstraintDefinitionNode) element;
1:             ConstraintInfo                      ci = fk.getReferencedConstraintInfo();
1:             int                                     deleteRule = ci.getReferentialActionDeleteRule();
1:             int                                     updateRule = ci.getReferentialActionUpdateRule();
1: 
1:             //
1:             // Currently we don't support ON UPDATE CASCADE. Someday we might.
1:             // We're laying a trip-wire here so that we won't neglect to code the appropriate check
1:             // when we support ON UPDATE CASCADE.
1:             //
1:             if (
1:                 ( updateRule != StatementType.RA_RESTRICT ) &&
1:                 ( updateRule != StatementType.RA_NOACTION )
1:                 )
1:             {
1:                 throw StandardException.newException( SQLState.BTREE_UNIMPLEMENTED_FEATURE );
1:             }
1:             
1:             if (
1:                 ( deleteRule != StatementType.RA_SETNULL ) &&
1:                 ( deleteRule != StatementType.RA_SETDEFAULT )
1:                 )
1:             { continue; }
1: 
1:             //
1:             // OK, we have found a foreign key whose referential action is SET NULL or
1:             // SET DEFAULT or whose update rule is ON UPDATE CASCADE.
1:             // See if any of the key columns are generated columns.
1:             //
0:             ResultColumnList                keyCols = fk.getColumnList();
0:             int                                     keyCount = keyCols.size();
1: 
0:             for ( int i = 0; i < keyCount; i++ )
1:             {
0:                 ResultColumn    keyCol = (ResultColumn) keyCols.elementAt( i );
0:                 String                  keyColName = keyCol.getName();
0:                 int     position = tableColumns.getPosition( keyColName, 1 );
1: 
1:                 if ( generatedColumns.isSet(  position ) )
1:                 {
1:                     throw StandardException.newException(SQLState.LANG_BAD_FK_ON_GENERATED_COLUMN, keyColName );
1:                 }
1:             }
1: 
1:         }   // end of loop through table elements
1:     }
1:     
1: 	/**
commit:2a0827a
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
/////////////////////////////////////////////////////////////////////////
1: 	 * @param generatedColumns Bitmap of generated columns in the table. Vacuous for CREATE TABLE, but may be non-trivial for ALTER TABLE. This routine may set bits for new generated columns.
0: 	void bindAndValidateGenerationClauses(FromList fromList, FormatableBitSet generatedColumns )
0:         int                                 columnCount = table.getResultColumns().size();
1:         generatedColumns.grow( columnCount + 1 );
1:         
/////////////////////////////////////////////////////////////////////////
1:             generationClauseNode = cdn.getGenerationClauseNode();
/////////////////////////////////////////////////////////////////////////
1:             int     position = rcl.getPosition( cdn.getColumnName(), 1 );
1:             generatedColumns.set( position );
1:         
/////////////////////////////////////////////////////////////////////////
1: 
1:         //
0:         // Now verify that none of the generated columns reference other
0:         // generated columns.
1:         //
0: 		for (int index = 0; index < size; index++)
1: 		{
1: 			ColumnDefinitionNode cdn;
0: 			TableElementNode element = (TableElementNode) elementAt(index);
1: 
1: 			if (! (element instanceof ColumnDefinitionNode)) { continue; }
1: 
1: 			cdn = (ColumnDefinitionNode) element;
1: 
1: 			if (!cdn.hasGenerationClause()) { continue; }
1: 
0:             int[]   referencedColumns = cdn.getDefaultInfo().getReferencedColumnIDs();
0:             int     count = referencedColumns.length;
1: 
0:             for ( int i = 0; i < count; i++ )
1:             {
0:                 int         referencedColumnID = referencedColumns[ i ];
0:                 if ( generatedColumns.isSet( referencedColumnID ) )
1:                 {
0:                     throw StandardException.newException(SQLState.LANG_CANT_REFERENCE_GENERATED_COLUMN, cdn.getColumnName());
1:                 }
0:             }   // end of loop through referenced columns
1: 
0:         }       // end of loop through generated columns
1: 
commit:95a483d
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.types.TypeId;
1: 
0: import org.apache.derby.catalog.types.DefaultInfoImpl;
/////////////////////////////////////////////////////////////////////////
1:     /**
1: 	 * Count the number of generation clauses.
1: 	 */
0: 	public int countGenerationClauses()
1: 	{
1: 		int	numGenerationClauses = 0;
1: 		int size = size();
1: 
0: 		for (int index = 0; index < size; index++)
1: 		{
1: 			ColumnDefinitionNode cdn;
0: 			TableElementNode element = (TableElementNode) elementAt(index);
1: 
1: 			if (! (element instanceof ColumnDefinitionNode))
1: 			{
1: 				continue;
1: 			}
1: 
1: 			cdn = (ColumnDefinitionNode) element;
1: 
0: 			if ( cdn.hasGenerationClause() )
1: 			{
0: 				numGenerationClauses++;
1: 			}
1: 		}
1: 
1: 		return numGenerationClauses;
1: 	}
1: 
/////////////////////////////////////////////////////////////////////////
1: 	 * Bind and validate all of the generation clauses in this list against
1: 	 * the specified FromList.  
1: 	 *
1: 	 * @param fromList		The FromList in question.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	void bindAndValidateGenerationClauses(FromList fromList)
1: 		throws StandardException
1: 	{
0: 		CompilerContext cc;
0: 		FromBaseTable				table = (FromBaseTable) fromList.elementAt(0);
0: 		int						  size = size();
1: 
0: 		cc = getCompilerContext();
1: 
0: 		Vector aggregateVector = new Vector();
1: 
0: 		for (int index = 0; index < size; index++)
1: 		{
0: 			ColumnDefinitionNode cdn;
0: 			TableElementNode element = (TableElementNode) elementAt(index);
1:             GenerationClauseNode    generationClauseNode;
1: 			ValueNode	generationTree;
1: 
0: 			if (! (element instanceof ColumnDefinitionNode))
1: 			{
1: 				continue;
1: 			}
1: 
0: 			cdn = (ColumnDefinitionNode) element;
1: 
1: 			if (!cdn.hasGenerationClause())
1: 			{
1: 				continue;
1: 			}
1: 
0: 		    generationClauseNode = cdn.getGenerationClauseNode();
1: 
1: 			// bind the check condition
1: 			// verify that it evaluates to a boolean
1: 			final int previousReliability = cc.getReliability();
1: 			try
1: 			{
1: 				/* Each generation clause can have its own set of dependencies.
1: 				 * These dependencies need to be shared with the prepared
1: 				 * statement as well.  We create a new auxiliary provider list
1: 				 * for the generation clause, "push" it on the compiler context
1: 				 * by swapping it with the current auxiliary provider list
1: 				 * and the "pop" it when we're done by restoring the old 
1: 				 * auxiliary provider list.
1: 				 */
1: 				ProviderList apl = new ProviderList();
1: 
1: 				ProviderList prevAPL = cc.getCurrentAuxiliaryProviderList();
1: 				cc.setCurrentAuxiliaryProviderList(apl);
1: 
1: 				// Tell the compiler context to forbid subqueries and
1: 				// non-deterministic functions.
1: 				cc.setReliability( CompilerContext.GENERATION_CLAUSE_RESTRICTION );
0: 				generationTree = generationClauseNode.bindExpression(fromList, (SubqueryList) null,
0: 										 aggregateVector);
1: 
0:                 //
1:                 // If the user did not declare a type for this column, then the column type defaults
1:                 // to the type of the generation clause.
1:                 // However, if the user did declare a type for this column, then the
1:                 // type of the generation clause must be assignable to the declared
1:                 // type.
0:                 //
1:                 DataTypeDescriptor  generationClauseType = generationTree.getTypeServices();
1:                 DataTypeDescriptor  declaredType = cdn.getType();
0:                 if ( declaredType == null ) { cdn.setType( generationClauseType ); }
1:                 {
1:                     TypeId  declaredTypeId = declaredType.getTypeId();
1:                     TypeId  resolvedTypeId = generationClauseType.getTypeId();
1: 
1:                     if ( !getTypeCompiler( resolvedTypeId ).convertible( declaredTypeId, false ) )
1:                     {
1:                         throw StandardException.newException
1:                             ( SQLState.LANG_UNASSIGNABLE_GENERATION_CLAUSE, cdn.getName(), resolvedTypeId.getSQLTypeName() );
1:                     }
1:                 }
1: 
1: 				// no aggregates, please
0: 				if (aggregateVector.size() != 0)
1: 				{
1: 					throw StandardException.newException( SQLState.LANG_AGGREGATE_IN_GENERATION_CLAUSE, cdn.getName());
1: 				}
1: 				
1: 				/* Save the APL off in the constraint node */
1: 				if (apl.size() > 0)
1: 				{
1: 					generationClauseNode.setAuxiliaryProviderList(apl);
1: 				}
1: 
1: 				// Restore the previous AuxiliaryProviderList
1: 				cc.setCurrentAuxiliaryProviderList(prevAPL);
1: 			}
1: 			finally
1: 			{
1: 				cc.setReliability(previousReliability);
1: 			}
1: 
1: 			/* We have a valid generation clause, now build an array of
1: 			 * 1-based columnIds that the clause references.
1: 			 */
1: 			ResultColumnList rcl = table.getResultColumns();
1: 			int		numReferenced = rcl.countReferencedColumns();
1: 			int[]	generationClauseColumnReferences = new int[numReferenced];
1: 
1: 			rcl.recordColumnReferences(generationClauseColumnReferences, 1);
1: 
1:             DefaultInfoImpl dii = new DefaultInfoImpl
0:                 ( generationClauseNode.getExpressionText(), generationClauseColumnReferences );
1:             cdn.setDefaultInfo( dii );
1: 
1: 			/* Clear the column references in the RCL so each generation clause
1: 			 * starts with a clean list.
1: 			 */
1: 			rcl.clearColumnReferences();
1: 		}
1: 	}
1: 
1: 	/**
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:7f7477d
/////////////////////////////////////////////////////////////////////////
0:             checkForDuplicateConstraintNames(ddlStmt, constraintHT, cdn.getConstraintMoniker());
commit:ae7e54a
/////////////////////////////////////////////////////////////////////////
1: 	 * @param sd			Schema where the table lives.
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:cd38662
/////////////////////////////////////////////////////////////////////////
1:                 String errorState = 
1:                    (getLanguageConnectionContext().getDataDictionary()
1:                         .checkVersion(DataDictionary.DD_VERSION_DERBY_10_4, null))
1:                     ? SQLState.LANG_ADD_PRIMARY_KEY_ON_NULL_COLS
1:                     : SQLState.LANG_DB2_ADD_UNIQUE_OR_PRIMARY_KEY_ON_NULL_COLS;
1: 
0:                 throw StandardException.newException(errorState, colName);
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:28e234d
/////////////////////////////////////////////////////////////////////////
1:                 // for UNIQUE, check that columns are unique
1: 
1:                 // unique constraints on nullable columns added in 10.4, 
1:                 // disallow until database hard upgraded at least to 10.4.
1:                 if (!dd.checkVersion(
1:                         DataDictionary.DD_VERSION_DERBY_10_4, null))
1:                 {
1:                     checkForNullColumns(cdn, td);
1:                 }
/////////////////////////////////////////////////////////////////////////
1:                 // implement unique constraints using a unique backing index 
1:                 // unless it is soft upgrade in version before 10.4, or if 
1:                 // constraint contains no nullable columns.  In 10.4 use 
1:                 // "unique with duplicate null" backing index for constraints 
1:                 // that contain at least one nullable column.
1: 
1: 				if (constraintDN.constraintType ==
1: 					DataDictionary.UNIQUE_CONSTRAINT && 
1: 					(dd.checkVersion(
1:                          DataDictionary.DD_VERSION_DERBY_10_4, null))) 
1:                 {
1:                     boolean contains_nullable_columns = 
1:                         areColumnsNullable(constraintDN, td);
1: 
1:                     // if all the columns are non nullable, continue to use
1:                     // a unique backing index.
1:                     boolean unique = 
1:                         !contains_nullable_columns;
1: 
1:                     // Only use a "unique with duplicate nulls" backing index
1:                     // for constraints with nullable columns.
1:                     boolean uniqueWithDuplicateNulls = 
1:                         contains_nullable_columns;
1: 
1: 					indexAction = genIndexAction(
1: 						forCreateTable,
1: 						unique,
1:                         uniqueWithDuplicateNulls,
1: 						null, constraintDN,
1: 						columnNames, true, tableSd, tableName,
1: 						constraintType, dd);
1: 				} 
1:                 else 
1:                 {
1: 					indexAction = genIndexAction(
1: 						forCreateTable,
1: 						constraintDN.requiresUniqueIndex(), false,
1: 						null, constraintDN,
1: 						columnNames, true, tableSd, tableName,
1: 						constraintType, dd);
1: 				}
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * utility to generated the call to create the index.
1:      * <p>
1:      *
1:      *
1:      * @param forCreateTable                Executed as part of a CREATE TABLE
1:      * @param isUnique		                True means it will be a unique index
1:      * @param isUniqueWithDuplicateNulls    True means index check and disallow
1:      *                                      any duplicate key if key has no 
1:      *                                      column with a null value.  If any 
1:      *                                      column in the key has a null value,
1:      *                                      no checking is done and insert will
1:      *                                      always succeed.
1:      * @param indexName	                    The type of index (BTREE, for 
1:      *                                      example)
1:      * @param cdn
1:      * @param columnNames	                Names of the columns in the index,
1:      *                                      in order.
1:      * @param isConstraint	                TRUE if index is backing up a 
1:      *                                      constraint, else FALSE.
1:      * @param sd
1:      * @param tableName	                    Name of table the index will be on
1:      * @param constraintType
1:      * @param dd
1:      **/
1:     boolean                     forCreateTable,
1:     boolean                     isUnique,
1:     boolean                     isUniqueWithDuplicateNulls,
1:     String                      indexName,
1:     ConstraintDefinitionNode    cdn,
1:     String[]                    columnNames,
1:     boolean                     isConstraint,
1:     SchemaDescriptor            sd,
1:     String                      tableName,
1:     int                         constraintType,
1:     DataDictionary              dd)
1: 		if (indexName == null) 
1:         { 
1:             indexName = cdn.getBackingIndexName(dd); 
1:         }
1:                     SanityManager.THROWASSERT(
1:                         "DROP INDEX with forCreateTable true");
1: 
1: 			return getGenericConstantActionFactory().getDropIndexConstantAction(
1:                       null,
1:                       indexName,
1:                       tableName,
1:                       sd.getSchemaName(),
1:                       td.getUUID(),
1:                       td.getHeapConglomerateId());
1: 
1: 
1:                     forCreateTable, 
1:                     isUnique, 
1:                     isUniqueWithDuplicateNulls,
1:                     "BTREE", // indexType
1:                     sd.getSchemaName(),
1:                     indexName,
1:                     tableName,
1:                     ((td != null) ? td.getUUID() : (UUID) null),
1:                     columnNames,
1:                     isAscending,
1:                     isConstraint,
1:                     cdn.getBackingIndexUUID(),
0:                     cdn.getProperties());
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Checks if any of the columns in the constraint can be null.
1:      *
1:      * @param cdn Constraint node
1:      * @param td tabe descriptor of the target table
1:      *
1:      * @return true if any of the column can be null false other wise
1:      */
1:     private boolean areColumnsNullable (
1:     ConstraintDefinitionNode    cdn, 
1:     TableDescriptor             td) 
1:     {
0:         ResultColumnList rcl = cdn.getColumnList();
0:         int rclSize = rcl.size();
0:         for (int index = 0; index < rclSize; index++)
1:         {
0:             String colName = ((ResultColumn) rcl.elementAt(index)).getName();
0:             DataTypeDescriptor dtd;
0:             if (td == null)
1:             {
0:                 dtd = getColumnDataTypeDescriptor(colName);
1:             }
1:             else
1:             {
0:                 dtd = getColumnDataTypeDescriptor(colName, td);
1:             }
1:             // todo dtd may be null if the column does not exist, we should check that first
1:             if (dtd != null && dtd.isNullable())
1:             {
1:                 return true;
1:             }
1:         }
1:         return false;
1:     }
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:9ed7c4d
/////////////////////////////////////////////////////////////////////////
0: 					cdn.setCollationType(collationType);
commit:bd66456
/////////////////////////////////////////////////////////////////////////
1:             
0:             findColumnDefinition(colName).setNullability(false);
/////////////////////////////////////////////////////////////////////////
1:         ColumnDefinitionNode col = findColumnDefinition(colName);
1:         if (col != null)
1:             return col.getType();
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Find the column definition node in this list that matches
1:      * the passed in column name.
1:      * @param colName
1:      * @return Reference to column definition node or null if the column is
1:      * not in the list.
1:      */
1:     private ColumnDefinitionNode findColumnDefinition(String colName) {
0:         int size = size();
0:         for (int index = 0; index < size; index++) {
0:             TableElementNode tableElement = (TableElementNode) elementAt(index);
1: 
0:             if (tableElement instanceof ColumnDefinitionNode) {
0:                 ColumnDefinitionNode cdn = (ColumnDefinitionNode) tableElement;
1:                 if (colName.equals(cdn.getName())) {
1:                     return cdn;
1:                 }
1:             }
1:         }
1:         return null;
1:     }
1:     
1:      * Determine whether or not the parameter matches a column name in this
1:      * list.
1:      * 
1:      * @param colName
1:      *            The column name to search for.
1:      * 
1:      * @return boolean Whether or not a match is found.
1:      */
1:         return findColumnDefinition(colName) != null;
commit:1b41764
/////////////////////////////////////////////////////////////////////////
0: 				indexAction = genIndexAction(
1:                         forCreateTable,
0:                         constraintDN.requiresUniqueIndex(),
/////////////////////////////////////////////////////////////////////////
0:             boolean forCreateTable,
/////////////////////////////////////////////////////////////////////////
1:             if (SanityManager.DEBUG)
1:             {
1:                 if (forCreateTable)
0:                     SanityManager.THROWASSERT("DROP INDEX with forCreateTable true");
1:             }
/////////////////////////////////////////////////////////////////////////
0:                     forCreateTable,
commit:68db840
/////////////////////////////////////////////////////////////////////////
1:      * @param forCreateTable ConstraintConstantAction is for a create table.
/////////////////////////////////////////////////////////////////////////
1: 	void genConstraintActions(boolean forCreateTable,
/////////////////////////////////////////////////////////////////////////
1:                 if (SanityManager.DEBUG)
1:                 {
1:                     // Can't drop constraints on a create table.
1:                     SanityManager.ASSERT(!forCreateTable);
1:                 }
/////////////////////////////////////////////////////////////////////////
0:                                                  forCreateTable,
1: 												 tableName, 
commit:7dda5d5
/////////////////////////////////////////////////////////////////////////
1: 					(cdn.getType().getTypeId().isLongConcatableTypeId() ||
1: 					cdn.getType().getTypeId().isUserDefinedTypeId()))
/////////////////////////////////////////////////////////////////////////
1: 							   coldef.getType(),
/////////////////////////////////////////////////////////////////////////
1: 											cdn.getType(),
1: 												cdn.getType(), 
/////////////////////////////////////////////////////////////////////////
0:                     return cdn.getType();
commit:1429957
/////////////////////////////////////////////////////////////////////////
commit:867a530
/////////////////////////////////////////////////////////////////////////
0:    Copyright 1997, 2005 The Apache Software Foundation or its licensors, as applicable.
/////////////////////////////////////////////////////////////////////////
1: 					// System.out.println("TABLE ELEMENT LIST EMPTY");
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.compile.TableElementList
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:61070a6
/////////////////////////////////////////////////////////////////////////
commit:fe77ca5
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package	org.apache.derby.impl.sql.compile;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
0: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.iapi.sql.compile.CompilerContext;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
1: 
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
1: 
0: import org.apache.derby.iapi.sql.dictionary.ConstraintDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
1: 
0: import org.apache.derby.iapi.sql.depend.DependencyManager;
0: import org.apache.derby.iapi.sql.depend.ProviderInfo;
0: import org.apache.derby.iapi.sql.depend.ProviderList;
1: 
0: import org.apache.derby.iapi.reference.SQLState;
1: 
0: import org.apache.derby.impl.sql.execute.ColumnInfo;
0: import org.apache.derby.impl.sql.execute.ConstraintInfo;
0: import org.apache.derby.impl.sql.execute.ConstraintConstantAction;
0: import org.apache.derby.impl.sql.execute.IndexConstantAction;
1: 
0: import	org.apache.derby.iapi.sql.dictionary.ConstraintDescriptorList;
1: 
0: import org.apache.derby.catalog.UUID;
1: 
0: import java.util.Hashtable;
0: import java.util.Vector;
1: 
1: /**
1:  * A TableElementList represents the list of columns and other table elements
1:  * such as constraints in a CREATE TABLE or ALTER TABLE statement.
1:  *
0:  * @author Jeff Lichtman
1:  */
1: 
0: public class TableElementList extends QueryTreeNodeVector
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	int				numColumns;
0: 	TableDescriptor td;
1: 
1: 	/**
1: 	 * Add a TableElementNode to this TableElementList
1: 	 *
1: 	 * @param tableElement	The TableElementNode to add to this list
1: 	 *
0: 	 * @return	Nothing
1: 	 */
1: 
0: 	public void addTableElement(TableElementNode tableElement)
1: 	{
1: 		addElement(tableElement);
1: 		if ((tableElement instanceof ColumnDefinitionNode) ||
1: 			tableElement.getElementType() == TableElementNode.AT_DROP_COLUMN)
1: 		{
1: 			numColumns++;
1: 		}
1: 	} 
1: 
1: 	/**
0: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
0: 	 * for how this should be done for tree printing.
1: 	 *
0: 	 * @return	This object as a String
1: 	 */
1: 
0: 	public String toString()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			StringBuffer	buffer = new StringBuffer("");
1: 
0: 			for (int index = 0; index < size(); index++)
1: 			{
0: 				buffer.append(elementAt(index).toString()).append("\n");
1: 			}
1: 
0: 			return buffer.toString();
1: 		}
1: 		else
1: 		{
0: 			return "";
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Validate this TableElementList.  This includes checking for
1: 	 * duplicate columns names, and checking that user types really exist.
1: 	 *
1: 	 * @param ddlStmt	DDLStatementNode which contains this list
1: 	 * @param dd		DataDictionary to use
1: 	 * @param td		TableDescriptor for table, if existing table.
1: 	 *
0: 	 * @return	None
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	void validate(DDLStatementNode ddlStmt,
1: 					     DataDictionary dd,
1: 						 TableDescriptor td)
1: 					throws StandardException
1: 	{
1:  		this.td = td;
1: 		int numAutoCols = 0;
1: 
0: 		int			size = size();
0: 		Hashtable	columnHT = new Hashtable(size + 2, (float) .999);
0: 		Hashtable	constraintHT = new Hashtable(size + 2, (float) .999);
1: 		//all the primary key/unique key constraints for this table
0: 		Vector constraintsVector = new Vector();
1: 
1: 		//special case for alter table (td is not null in case of alter table)
1: 		if (td != null)
1: 		{
1: 			//In case of alter table, get the already existing primary key and unique
1: 			//key constraints for this table. And then we will compare them with  new
1: 			//primary key/unique key constraint column lists.
1: 			ConstraintDescriptorList cdl = dd.getConstraintDescriptors(td);
1: 			ConstraintDescriptor cd;
1: 
1: 			if (cdl != null) //table does have some pre-existing constraints defined on it
1: 			{
1: 				for (int i=0; i<cdl.size();i++)
1: 				{
1: 					cd = cdl.elementAt(i);
1: 					//if the constraint type is not primary key or unique key, ignore it.
1: 					if (cd.getConstraintType() == DataDictionary.PRIMARYKEY_CONSTRAINT ||
1: 					cd.getConstraintType() == DataDictionary.UNIQUE_CONSTRAINT)
0: 						constraintsVector.addElement(cd);
1: 				}
1: 			}
1: 		}
1: 
1: 		int tableType = TableDescriptor.BASE_TABLE_TYPE;
1: 		if (ddlStmt instanceof CreateTableNode)
1: 			tableType = ((CreateTableNode)ddlStmt).tableType;
1: 
0: 		for (int index = 0; index < size; index++)
1: 		{
0: 			TableElementNode tableElement = (TableElementNode) elementAt(index);
1: 
1: 			if (tableElement instanceof ColumnDefinitionNode)
1: 			{
1: 				ColumnDefinitionNode cdn = (ColumnDefinitionNode) elementAt(index);
1: 				if (tableType == TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE &&
0: 					(cdn.getDataTypeServices().getTypeId().isLongConcatableTypeId() ||
0: 					cdn.getDataTypeServices().getTypeId().isUserDefinedTypeId()))
1: 				{
1: 					throw StandardException.newException(SQLState.LANG_LONG_DATA_TYPE_NOT_ALLOWED, cdn.getColumnName());
1: 				}
0: 				checkForDuplicateColumns(ddlStmt, columnHT, cdn.getColumnName());
1: 				cdn.checkUserType(td);
1: 				cdn.bindAndValidateDefault(dd, td);
1: 				
1: 				cdn.validateAutoincrement(dd, td, tableType);
1: 
1: 				if (tableElement instanceof ModifyColumnNode)
1: 				{
1: 					ModifyColumnNode mcdn = (ModifyColumnNode)cdn;
1: 					mcdn.checkExistingConstraints(td);
1: 				} else if (cdn.isAutoincrementColumn())
0: 					numAutoCols ++;
1: 			}
1: 			else if (tableElement.getElementType() == TableElementNode.AT_DROP_COLUMN)
1: 			{
1: 				String colName = tableElement.getName();
1: 				if (td.getColumnDescriptor(colName) == null)
1: 				{
1: 					throw StandardException.newException(
1: 												SQLState.LANG_COLUMN_NOT_FOUND_IN_TABLE,
1: 												colName,
1: 												td.getQualifiedName());
1: 				}
1: 				break;
1: 			}
1: 
1: 			/* The rest of this method deals with validating constraints */
1: 			if (! (tableElement.hasConstraint()))
1: 			{
1: 				continue;
1: 			}
1: 
1: 			ConstraintDefinitionNode cdn = (ConstraintDefinitionNode) tableElement;
1: 
1: 			cdn.bind(ddlStmt, dd);
1: 
0: 			//if constraint is primary key or unique key, add it to the vector
1: 			if (cdn.getConstraintType() == DataDictionary.PRIMARYKEY_CONSTRAINT ||
1: 			cdn.getConstraintType() == DataDictionary.UNIQUE_CONSTRAINT)
1: 			{
0: 				/* In case of create table, the vector can have only ConstraintDefinitionNode
1: 				* elements. In case of alter table, it can have both ConstraintDefinitionNode
1: 				* (for new constraints) and ConstraintDescriptor(for pre-existing constraints).
1: 				*/
1: 
1: 				Object destConstraint;
1: 				String destName = null;
1: 				String[] destColumnNames = null;
1: 
0: 				for (int i=0; i<constraintsVector.size();i++)
1: 				{
1: 
0: 					destConstraint = constraintsVector.elementAt(i);
1: 					if (destConstraint instanceof ConstraintDefinitionNode)
1: 					{
1: 						ConstraintDefinitionNode destCDN = (ConstraintDefinitionNode)destConstraint;
1: 						destName = destCDN.getConstraintMoniker();
1: 						destColumnNames = destCDN.getColumnList().getColumnNames();
1: 					}
1: 					else if (destConstraint instanceof ConstraintDescriptor)
1: 					{
1: 						//will come here only for pre-existing constraints in case of alter table
1: 						ConstraintDescriptor destCD = (ConstraintDescriptor)destConstraint;
1: 						destName = destCD.getConstraintName();
1: 						destColumnNames = destCD.getColumnDescriptors().getColumnNames();
1: 					}
1: 					//check if there are multiple constraints with same set of columns
1: 					if (columnsMatch(cdn.getColumnList().getColumnNames(), destColumnNames))
1: 						throw StandardException.newException(SQLState.LANG_MULTIPLE_CONSTRAINTS_WITH_SAME_COLUMNS,
1: 						cdn.getConstraintMoniker(), destName);
1: 				}
0: 				constraintsVector.addElement(cdn);
1: 			}
1: 
1: 			/* Make sure that there are no duplicate constraint names in the list */
0: 			if (cdn instanceof ConstraintDefinitionNode)
0: 				checkForDuplicateConstraintNames(ddlStmt, constraintHT, cdn.getConstraintMoniker());
1: 
1: 			/* Make sure that the constraint we are trying to drop exists */
0: 			if (cdn.getConstraintType() == DataDictionary.DROP_CONSTRAINT)
1: 			{
1: 				/*
1: 				** If no schema descriptor, then must be an invalid
1: 				** schema name.
1: 				*/
1: 
1: 				String dropConstraintName = cdn.getConstraintMoniker();
1: 
1: 				if (dropConstraintName != null) {
1: 
1: 					String dropSchemaName = cdn.getDropSchemaName();
1: 
1: 					SchemaDescriptor sd = dropSchemaName == null ? td.getSchemaDescriptor() : 
1: 											getSchemaDescriptor(dropSchemaName);
1: 
1: 					ConstraintDescriptor cd =
1: 								dd.getConstraintDescriptorByName(
1: 										td, sd, dropConstraintName,
1: 										false);
1: 					if (cd == null)
1: 					{
0: 						throw StandardException.newException(SQLState.LANG_DROP_NON_EXISTENT_CONSTRAINT,
1: 								(sd.getSchemaName() + "."+ dropConstraintName),
1: 								td.getQualifiedName());
1: 					}
1: 					/* Statement is dependendent on the ConstraintDescriptor */
1: 					getCompilerContext().createDependency(cd);
1: 				}
1: 			}
1: 
0: 			/* For primary/unique/unique keys, verify that the constraint's column
0: 			 * list contains valid columns and does not contain any duplicates
0: 			 * (Also, all columns in a primary key will be set to non-null,
0: 				but only in Cloudscape mode. SQL and DB2 require explict NOT NULL.
1: 			 */
0: 			if (cdn.hasPrimaryKeyConstraint() ||
0: 				cdn.hasForeignKeyConstraint() ||
0: 				cdn.hasUniqueKeyConstraint())
1: 			{
1: 				verifyUniqueColumnList(ddlStmt, cdn);
0: 				/* Raise error if primary or unique key columns can be nullable. */
0: 				if (cdn.hasPrimaryKeyConstraint() || cdn.hasUniqueKeyConstraint())
1: 				{
0: 					setColumnListToNotNull(cdn, td);
1: 				}
1: 			}
1: 		}
1: 
1: 		/* Can have only one autoincrement column in DB2 mode */
0: 		if (numAutoCols > 1)
1: 			throw StandardException.newException(SQLState.LANG_MULTIPLE_AUTOINCREMENT_COLUMNS);
1: 
1: 	}
1: 	
1: 	/**
1: 	 * Count the number of constraints of the specified type.
1: 	 *
1: 	 * @param constraintType	The constraint type to search for.
1: 	 *
1: 	 * @return int	The number of constraints of the specified type.
1: 	 */
0: 	public int countConstraints(int constraintType)
1: 	{
1: 		int	numConstraints = 0;
0: 		int size = size();
1: 
0: 		for (int index = 0; index < size; index++)
1: 		{
1: 			ConstraintDefinitionNode cdn;
0: 			TableElementNode element = (TableElementNode) elementAt(index);
1: 
1: 			if (! (element instanceof ConstraintDefinitionNode))
1: 			{
1: 				continue;
1: 			}
1: 
1: 			cdn = (ConstraintDefinitionNode) element;
1: 
0: 			if (constraintType == cdn.getConstraintType())
1: 			{
1: 				numConstraints++;
1: 			}
1: 		}
1: 
1: 		return numConstraints;
1: 	}
1: 
1: 	/**
1: 	 * Count the number of columns.
1: 	 *
1: 	 * @return int	The number of columns.
1: 	 */
0: 	public int countNumberOfColumns()
1: 	{
1: 		return numColumns;
1: 	}
1: 
1: 	/**
1: 	 * Fill in the ColumnInfo[] for this table element list.
1: 	 * 
1: 	 * @param colInfos	The ColumnInfo[] to be filled in.
1: 	 *
1: 	 * @return int		The number of constraints in the create table.
1: 	 */
0: 	public int genColumnInfos(ColumnInfo[] colInfos)
1: 	{
1: 		int	numConstraints = 0;
0: 		int size = size();
1: 
0: 		for (int index = 0; index < size; index++)
1: 		{
0: 			if (((TableElementNode) elementAt(index)).getElementType() == TableElementNode.AT_DROP_COLUMN)
1: 			{
1: 				colInfos[index] = new ColumnInfo(
0: 								((TableElementNode) elementAt(index)).getName(),
0: 								null, null, null, null, null,
0: 								ColumnInfo.DROP, 0, 0);
1: 				break;
1: 			}
1: 
1: 			if (! (elementAt(index) instanceof ColumnDefinitionNode))
1: 			{
1: 				if (SanityManager.DEBUG)
1: 				{
1: 					SanityManager.ASSERT( elementAt(index) instanceof ConstraintDefinitionNode,
1: 						"elementAt(index) expected to be instanceof " +
1: 						"ConstraintDefinitionNode");
1: 				}
1: 
1: 				/* Remember how many constraints that we've seen */
1: 				numConstraints++;
1: 				continue;
1: 			}
1: 
1: 			ColumnDefinitionNode coldef = (ColumnDefinitionNode) elementAt(index);
1: 
1: 			colInfos[index - numConstraints] = 
1: 				new ColumnInfo(coldef.getColumnName(),
0: 							   coldef.getDataTypeServices(),
1: 							   coldef.getDefaultValue(),
1: 							   coldef.getDefaultInfo(),
1: 							   (UUID) null,
1: 							   coldef.getOldDefaultUUID(),
1: 							   coldef.getAction(),
1: 							   (coldef.isAutoincrementColumn() ? 
1: 								coldef.getAutoincrementStart() : 0),
1: 							   (coldef.isAutoincrementColumn() ? 
0: 								coldef.getAutoincrementIncrement() : 0));
1: 
1: 			/* Remember how many constraints that we've seen */
0: 			if (coldef.hasConstraint())
1: 			{
1: 				numConstraints++;
1: 			}
1: 		}
1: 
1: 		return numConstraints;
1: 	}
1: 	/**
1: 	 * Append goobered up ResultColumns to the table's RCL.
1: 	 * This is useful for binding check constraints for CREATE and ALTER TABLE.
1: 	 *
1: 	 * @param table		The table in question.
1: 	 *
0: 	 * @return Nothing.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public void appendNewColumnsToRCL(FromBaseTable table)
1: 		throws StandardException
1: 	{
1: 		int				 size = size();
0: 		ResultColumnList rcl = table.getResultColumns();
1: 		TableName		 exposedName = table.getTableName();
1: 
0: 		for (int index = 0; index < size; index++)
1: 		{
1: 			if (elementAt(index) instanceof ColumnDefinitionNode)
1: 			{
1: 				ColumnDefinitionNode cdn = (ColumnDefinitionNode) elementAt(index);
1: 				ResultColumn	resultColumn;
1: 				ValueNode		valueNode;
1: 
1: 				/* Build a ResultColumn/BaseColumnNode pair for the column */
0: 				valueNode = (ValueNode) getNodeFactory().getNode(
0: 											C_NodeTypes.BASE_COLUMN_NODE,
0: 											cdn.getColumnName(),
1: 									  		exposedName,
0: 											cdn.getDataTypeServices(),
1: 											getContextManager());
1: 
0: 				resultColumn = (ResultColumn) getNodeFactory().getNode(
0: 												C_NodeTypes.RESULT_COLUMN,
0: 												cdn.getDataTypeServices(), 
0: 												valueNode,
1: 												getContextManager());
1: 				resultColumn.setName(cdn.getColumnName());
1: 				rcl.addElement(resultColumn);
1: 			}
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Bind and validate all of the check constraints in this list against
1: 	 * the specified FromList.  
1: 	 *
0: 	 * @param FromList		The FromList in question.
1: 	 *
0: 	 * @return Nothing.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	void bindAndValidateCheckConstraints(FromList fromList)
1: 		throws StandardException
1: 	{
0: 		CompilerContext cc;
0: 		FromBaseTable				table = (FromBaseTable) fromList.elementAt(0);
0: 		int						  size = size();
1: 
0: 		cc = getCompilerContext();
1: 
0: 		Vector aggregateVector = new Vector();
1: 
0: 		for (int index = 0; index < size; index++)
1: 		{
1: 			ConstraintDefinitionNode cdn;
0: 			TableElementNode element = (TableElementNode) elementAt(index);
1: 			ValueNode	checkTree;
1: 
1: 			if (! (element instanceof ConstraintDefinitionNode))
1: 			{
1: 				continue;
1: 			}
1: 
1: 			cdn = (ConstraintDefinitionNode) element;
1: 
1: 			if (cdn.getConstraintType() != DataDictionary.CHECK_CONSTRAINT)
1: 			{
1: 				continue;
1: 			}
1: 
1: 			checkTree = cdn.getCheckCondition();
1: 
0: 			// bind the check condition
0: 			// verify that it evaluates to a boolean
1: 			final int previousReliability = cc.getReliability();
1: 			try
1: 			{
1: 				/* Each check constraint can have its own set of dependencies.
1: 				 * These dependencies need to be shared with the prepared
1: 				 * statement as well.  We create a new auxiliary provider list
1: 				 * for the check constraint, "push" it on the compiler context
1: 				 * by swapping it with the current auxiliary provider list
1: 				 * and the "pop" it when we're done by restoring the old 
1: 				 * auxiliary provider list.
1: 				 */
1: 				ProviderList apl = new ProviderList();
1: 
0: 				ProviderList prevAPL = cc.getCurrentAuxiliaryProviderList();
1: 				cc.setCurrentAuxiliaryProviderList(apl);
1: 
1: 				// Tell the compiler context to only allow deterministic nodes
1: 				cc.setReliability( CompilerContext.CHECK_CONSTRAINT );
0: 				checkTree = checkTree.bindExpression(fromList, (SubqueryList) null,
0: 										 aggregateVector);
1: 
1: 				// no aggregates, please
0: 				if (aggregateVector.size() != 0)
1: 				{
1: 					throw StandardException.newException(SQLState.LANG_INVALID_CHECK_CONSTRAINT, cdn.getConstraintText());
1: 				}
1: 				
1: 				checkTree = checkTree.checkIsBoolean();
1: 				cdn.setCheckCondition(checkTree);
1: 
1: 				/* Save the APL off in the constraint node */
1: 				if (apl.size() > 0)
1: 				{
1: 					cdn.setAuxiliaryProviderList(apl);
1: 				}
1: 
0: 				// Restore the previous AuxiliaryProviderList
0: 				cc.setCurrentAuxiliaryProviderList(prevAPL);
1: 			}
1: 			finally
1: 			{
1: 				cc.setReliability(previousReliability);
1: 			}
1: 	
0: 			/* We have a valid check constraint, now build an array of
0: 			 * 1-based columnIds that the constraint references.
1: 			 */
0: 			ResultColumnList rcl = table.getResultColumns();
0: 			int		numReferenced = rcl.countReferencedColumns();
0: 			int[]	checkColumnReferences = new int[numReferenced];
1: 
0: 			rcl.recordColumnReferences(checkColumnReferences, 1);
0: 			cdn.setCheckColumnReferences(checkColumnReferences);
1: 
0: 			/* Now we build a list with only the referenced columns and
1: 			 * copy it to the cdn.  Thus we can build the array of
1: 			 * column names for the referenced columns during generate().
1: 			 */
0: 			ResultColumnList refRCL =
0: 						(ResultColumnList) getNodeFactory().getNode(
0: 												C_NodeTypes.RESULT_COLUMN_LIST,
1: 												getContextManager());
1: 			rcl.copyReferencedColumnsToNewList(refRCL);
1: 
1: 			/* A column check constraint can only refer to that column. If this is a
1: 			 * column constraint, we should have an RCL with that column
1: 			 */
1: 			if (cdn.getColumnList() != null)
1: 			{
0: 				String colName = ((ResultColumn)(cdn.getColumnList().elementAt(0))).getName();
1: 				if (numReferenced > 1 ||
0: 					!colName.equals(((ResultColumn)(refRCL.elementAt(0))).getName()))
1: 					throw StandardException.newException(SQLState.LANG_DB2_INVALID_CHECK_CONSTRAINT, colName);
1: 				
1: 			}
1: 			cdn.setColumnList(refRCL);
1: 
1: 			/* Clear the column references in the RCL so each check constraint
1: 			 * starts with a clean list.
1: 			 */
1: 			rcl.clearColumnReferences();
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Fill in the ConstraintConstantAction[] for this create/alter table.
1: 	 * 
1: 	 * @param conActions	The ConstraintConstantAction[] to be filled in.
1: 	 * @param tableName		The name of the Table being created.
0: 	 * @param sd			The schema for that table.
0: 	 * @param dd		The DataDictionary
1: 	 *
0: 	 * @return Nothing.
1: 	 *
1: 	 * @exception StandardException		Thrown on failure
1: 	 */
0: 	void genConstraintActions(
1: 				ConstraintConstantAction[] conActions,
1: 				String tableName,
1: 				SchemaDescriptor tableSd,
1: 				DataDictionary dd)
1: 		throws StandardException
1: 	{
0: 		int size = size();
1: 		int conActionIndex = 0;
0: 		for (int index = 0; index < size; index++)
1: 		{
1: 			String[]	columnNames = null;
0: 			String		generatedConstraintName;
0: 			TableElementNode ten = (TableElementNode) elementAt(index);
1: 			IndexConstantAction indexAction = null;
1: 
0: 			if (! ten.hasConstraint())
1: 			{
1: 				continue;
1: 			}
1: 
0: 			if (ten instanceof ColumnDefinitionNode)
1: 			{
1: 				continue;
1: 			}
1: 
1: 			ConstraintDefinitionNode constraintDN = (ConstraintDefinitionNode) ten;
1: 
1: 			if (constraintDN.getColumnList() != null)
1: 			{
1: 				columnNames = new String[constraintDN.getColumnList().size()];
1: 				constraintDN.getColumnList().exportNames(columnNames);
1: 			}
1: 
1: 			int constraintType = constraintDN.getConstraintType();
1: 			String constraintText = constraintDN.getConstraintText();
1: 
1: 			/*
1: 			** If the constraint is not named (e.g.
1: 			** create table x (x int primary key)), then
1: 			** the constraintSd is the same as the table.
1: 			*/
1: 			String constraintName = constraintDN.getConstraintMoniker();
1: 
1: 			/* At execution time, we will generate a unique name for the backing
1: 			 * index (for CREATE CONSTRAINT) and we will look up the conglomerate
1: 			 * name (for DROP CONSTRAINT).
1: 			 */
1: 			if (constraintDN.requiresBackingIndex())
1: 			{
0: 				indexAction = genIndexAction(constraintDN.requiresUniqueIndex(),
0: 											 null, constraintDN, 
0: 											 columnNames, true, tableSd, tableName,
0: 											 constraintType, dd);
1: 			}
1: 
1: 			if (constraintType == DataDictionary.DROP_CONSTRAINT)
1: 			{
1: 				conActions[conActionIndex] = 
1: 					getGenericConstantActionFactory().
1: 						getDropConstraintConstantAction(
1: 												 constraintName, 
1: 												 constraintDN.getDropSchemaName(), /// FiX
1: 												 tableName,
1: 												 td.getUUID(),
1: 												 tableSd.getSchemaName(),
1: 												 indexAction,
1: 												 constraintDN.getDropBehavior(),
1:                                                  constraintDN.getVerifyType());
1: 			}
1: 			else
1: 			{
1: 				ProviderList apl = constraintDN.getAuxiliaryProviderList();
1: 				ConstraintInfo refInfo = null;
0: 				ProviderInfo[]	providerInfos = null;
1: 
1: 				if (constraintDN instanceof FKConstraintDefinitionNode)
1: 				{
1: 					refInfo = ((FKConstraintDefinitionNode)constraintDN).getReferencedConstraintInfo();
1: 				}				
1: 
1: 				/* Create the ProviderInfos, if the constraint is dependent on any Providers */
1: 				if (apl != null && apl.size() > 0)
1: 				{
1: 					/* Get all the dependencies for the current statement and transfer
1: 					 * them to this view.
1: 					 */
1: 					DependencyManager dm = dd.getDependencyManager();
1: 					providerInfos = dm.getPersistentProviderInfos(apl);
1: 				}
1: 				else
1: 				{
1: 					providerInfos = new ProviderInfo[0];
1: 				}
1: 
1: 				conActions[conActionIndex++] = 
1: 					getGenericConstantActionFactory().
1: 						getCreateConstraintConstantAction(
1: 												 constraintName, 
1: 											     constraintType,
1: 												 tableName,
1: 												 ((td != null) ? td.getUUID() : (UUID) null),
1: 												 tableSd.getSchemaName(),
1: 												 columnNames,
1: 												 indexAction,
1: 												 constraintText,
0: 												 true, 		// enabled
1: 												 refInfo,
1: 												 providerInfos);
1: 			}
1: 		}
1: 	}
1: 
1:       //check if one array is same as another 
1: 	private boolean columnsMatch(String[] columnNames1, String[] columnNames2)
1: 		throws StandardException
1: 	{
1: 		int srcCount, srcSize, destCount,destSize;
0: 		boolean match = true;
1: 
1: 		if (columnNames1.length != columnNames2.length)
1: 			return false;
1: 
1: 		srcSize = columnNames1.length;
1: 		destSize = columnNames2.length;
1: 
1: 		for (srcCount = 0; srcCount < srcSize; srcCount++)
1: 		{
0: 			match = false;
1: 			for (destCount = 0; destCount < destSize; destCount++) {
1: 				if (columnNames1[srcCount].equals(columnNames2[destCount])) {
1: 					match = true;
1: 					break;
1: 				}
1: 			}
1: 			if (match == false)
1: 				return false;
1: 		}
1: 
1: 		return true;
1: 	}
1: 
1: 	private IndexConstantAction genIndexAction(
0: 										boolean	isUnique,
0: 										String indexName,
0: 										ConstraintDefinitionNode cdn,
0: 										String[] columnNames,
0: 										boolean isConstraint,
0: 										SchemaDescriptor sd,
1: 										String tableName,
0: 										int constraintType,
1: 										DataDictionary dd)
1: 		throws StandardException
1: 	{
0: 		if ( indexName == null ) { indexName = cdn.getBackingIndexName(dd); }
1: 
1: 		if (constraintType == DataDictionary.DROP_CONSTRAINT)
1: 		{
0: 			return	getGenericConstantActionFactory().getDropIndexConstantAction(
0: 									  null,
0: 									  indexName,
1: 									  tableName,
0: 									  sd.getSchemaName(),
1: 									  td.getUUID(),
0: 									  td.getHeapConglomerateId());
1: 		}
1: 		else
1: 		{
1: 			boolean[]	isAscending = new boolean[columnNames.length];
1: 			for (int i = 0; i < isAscending.length; i++)
1: 				isAscending[i] = true;
1: 			return	getGenericConstantActionFactory().getCreateIndexConstantAction(
0: 									isUnique,
0: 									"BTREE", // indexType
0: 									sd.getSchemaName(),
0: 									indexName,
1: 									tableName,
1: 									((td != null) ? td.getUUID() : (UUID) null),
0: 									0, // conglomId
1: 									columnNames,
0: 									isAscending,
0: 									isConstraint,
0: 									cdn.getBackingIndexUUID(),
0: 									cdn.getProperties());
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Check to make sure that there are no duplicate column names
1: 	 * in the list.  (The comparison here is case sensitive.
1: 	 * The work of converting column names that are not quoted
1: 	 * identifiers to upper case is handled by the parser.)
1: 	 * RESOLVE: This check will also be performed by alter table.
1: 	 *
1: 	 * @param ddlStmt	DDLStatementNode which contains this list
0: 	 * @param ht		Hashtable for enforcing uniqueness.
1: 	 * @param colName	Column name to check for.
1: 	 *
0: 	 * @return	None
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	private void checkForDuplicateColumns(DDLStatementNode ddlStmt,
0: 									Hashtable ht,
1: 									String colName)
1: 			throws StandardException
1: 	{
0: 		Object object = ht.put(colName, colName);
0: 		if (object != null)
1: 		{
1: 			/* RESOLVE - different error messages for create and alter table */
1: 			if (ddlStmt instanceof CreateTableNode)
1: 			{
1: 				throw StandardException.newException(SQLState.LANG_DUPLICATE_COLUMN_NAME_CREATE, colName);
1: 			}
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Check to make sure that there are no duplicate constraint names
1: 	 * in the list.  (The comparison here is case sensitive.
1: 	 * The work of converting column names that are not quoted
1: 	 * identifiers to upper case is handled by the parser.)
1: 	 * RESOLVE: This check will also be performed by alter table.
1: 	 *
1: 	 * @param ddlStmt	DDLStatementNode which contains this list
0: 	 * @param outer		The element to check against.  Only check
0: 	 *						TableElements that come after this one, since this
0: 	 *						one has been checked against the TableElements
0: 	 *						before it.
1: 	 *
0: 	 * @return	None
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	private void checkForDuplicateConstraintNames(DDLStatementNode ddlStmt,
0: 									Hashtable ht,
1: 									String constraintName)
1: 			throws StandardException
1: 	{
1: 		if (constraintName == null)
0: 			return;
1: 
0: 		Object object = ht.put(constraintName, constraintName);
0: 		if (object != null) {
1: 
1: 			/* RESOLVE - different error messages for create and alter table */
1: 			if (ddlStmt instanceof CreateTableNode)
1: 			{
1: 				/* RESOLVE - new error message */
1: 				throw StandardException.newException(SQLState.LANG_DUPLICATE_CONSTRAINT_NAME_CREATE, 
1: 						constraintName);
1: 			}
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Verify that a primary/unique table constraint has a valid column list.
1: 	 * (All columns in table and no duplicates.)
1: 	 *
1: 	 * @param ddlStmt	The outer DDLStatementNode
1: 	 * @param cdn		The ConstraintDefinitionNode
1: 	 *
0: 	 * @return Nothing.
1: 	 *
1: 	 * @exception	StandardException	Thrown if the column list is invalid
1: 	 */
1: 	private void verifyUniqueColumnList(DDLStatementNode ddlStmt,
1: 								ConstraintDefinitionNode cdn)
1: 		throws StandardException
1: 	{
1: 		String invalidColName;
1: 
1: 		/* Verify that every column in the list appears in the table's list of columns */
1: 		if (ddlStmt instanceof CreateTableNode)
1: 		{
1: 			invalidColName = cdn.getColumnList().verifyCreateConstraintColumnList(this);
1: 			if (invalidColName != null)
1: 			{
1: 				throw StandardException.newException(SQLState.LANG_INVALID_CREATE_CONSTRAINT_COLUMN_LIST, 
1: 								ddlStmt.getRelativeName(),
1: 								invalidColName);
1: 			}
1: 		}
1: 		else
1: 		{
1: 			/* RESOLVE - alter table will need to get table descriptor */
1: 		}
1: 
1: 		/* Check the uniqueness of the column names within the list */
1: 		invalidColName = cdn.getColumnList().verifyUniqueNames(false);
1: 		if (invalidColName != null)
1: 		{
1: 			throw StandardException.newException(SQLState.LANG_DUPLICATE_CONSTRAINT_COLUMN_NAME, invalidColName);
1: 		}
1: 	}
1: 
1: 	/**
0: 	 * Set all columns in that appear in a primary/unique key constraint in a create
0: 	 * table statement to NOT NULL in Cloudscape mode and raises an error in DB2 mode.
1: 	 *
1: 	 * @param cdn		The ConstraintDefinitionNode
0: 	 * @param td		TableDescriptor for the table
1: 	 *
0: 	 * @return Nothing.
1: 	 */
0: 	private void setColumnListToNotNull(ConstraintDefinitionNode cdn, TableDescriptor td)
1: 		throws StandardException
1: 	{
0: 		ResultColumnList rcl = cdn.getColumnList();
0: 		int rclSize = rcl.size();
0: 		for (int index = 0; index < rclSize; index++)
1: 		{
0: 			String colName = ((ResultColumn) rcl.elementAt(index)).getName();
1: 
0: 			/* For ALTER TABLE ADD CONSTRAINT, make sure columns are not nullable for
0: 			 * primary and unique constraints.
1: 			 */
0: 			if (td != null && cdn instanceof ConstraintDefinitionNode)
1: 			{
1: 				ColumnDescriptor cd = td.getColumnDescriptor(colName);
0: 				if (cd != null && cd.getType().isNullable())
0: 					throw StandardException.newException(SQLState.LANG_DB2_ADD_UNIQUE_OR_PRIMARY_KEY_ON_NULL_COLS, colName);
1: 			}
1: 
0: 			setColumnToNotNull(colName);
1: 		}
1: 	}
1: 
1: 	/**
0: 	 * Set a column that appears in a primary/unique key constraint in
0: 	 * a create table statement to NOT NULL (but only in Cloudscape mode).
1: 	 *
0: 	 * @param colName	The column name
1: 	 *
0: 	 * @return Nothing.
1: 	 */
0: 	private void setColumnToNotNull(String colName) throws StandardException
1: 	{
0: 		int size = size();
1: 
0: 		for (int index = 0; index < size; index++)
1: 		{
0: 			TableElementNode tableElement = (TableElementNode) elementAt(index);
1: 
1: 			if (tableElement instanceof ColumnDefinitionNode)
1: 			{
0: 				ColumnDefinitionNode cdn = (ColumnDefinitionNode) tableElement;
0: 				if (colName.equals(cdn.getColumnName()))
1: 				{
0: 					DataTypeDescriptor dtd = cdn.getDataTypeServices();
1: 
0: 					if (dtd.isNullable())
0: 						throw StandardException.newException(SQLState.LANG_DB2_ADD_UNIQUE_OR_PRIMARY_KEY_ON_NULL_COLS, colName);
1: 				}
1: 			}
1: 		}
1: 	}
1: 
1: 	/**
0: 	 * Determine whether or not the parameter matches a column name in this list.
1: 	 *
0: 	 * @param colName	The column name to search for.
1: 	 *
0: 	 * @return boolean  Whether or not a match is found.
1: 	 */
0: 	public boolean containsColumnName(String colName)
1: 	{
0: 		int size = size();
0: 		for (int index = 0; index < size; index++)
1: 		{
0: 			TableElementNode tableElement = (TableElementNode) elementAt(index);
1: 
1: 			if (tableElement instanceof ColumnDefinitionNode)
1: 			{
0: 				if (colName.equals(((ColumnDefinitionNode) tableElement).getName()))
1: 				{
1: 					return true;
1: 				}
1: 			}
1: 		}
1: 
1: 		return false;
1: 	}
1: }
1: 
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:93b320d
/////////////////////////////////////////////////////////////////////////
1: 					mcdn.useExistingCollation(td);
commit:2779125
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.types.StringDataValue;
/////////////////////////////////////////////////////////////////////////
1: 	 * Use the passed schema descriptor's collation type to set the collation
1: 	 * of the character string types in create table node
1: 	 * @param sd
0: 	 */
0: 	void setCollationTypesOnCharacterStringColumns(SchemaDescriptor sd) {
0: 		int			size = size();
0: 		int collationType = sd.getCollationType();
0: 		for (int index = 0; index < size; index++)
0: 		{
0: 			TableElementNode tableElement = (TableElementNode) elementAt(index);
0: 
0: 			if (tableElement instanceof ColumnDefinitionNode)
0: 			{
0: 				ColumnDefinitionNode cdn = (ColumnDefinitionNode) elementAt(index);
0: 				if (cdn.getType().getTypeId().isStringTypeId()) {
0: 					cdn.getType().setCollationType(collationType);
0: 					cdn.getType().setCollationDerivation(StringDataValue.COLLATION_DERIVATION_IMPLICIT);
0: 				}
0: 			}
0: 		}
0: 	}
0: 
0: 	/**
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2d37fd6
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:6a5edfc
/////////////////////////////////////////////////////////////////////////
0: 								ColumnInfo.DROP, 0, 0, 0);
/////////////////////////////////////////////////////////////////////////
1: 								coldef.getAutoincrementIncrement() : 0),
1: 							   (coldef.isAutoincrementColumn() ? 
1: 								coldef.getAutoinc_create_or_modify_Start_Increment() : -1));
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Jeremy Boynes
-------------------------------------------------------------------------------
commit:02e0ae5
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
/////////////////////////////////////////////////////////////////////////
1: 	private int				numColumns;
1: 	private TableDescriptor td;
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 					SchemaDescriptor sd = dropSchemaName == null ? td.getSchemaDescriptor() :
/////////////////////////////////////////////////////////////////////////
1:             if (cdn.hasPrimaryKeyConstraint())
0:             {
1:                 // for PRIMARY KEY, check that columns are unique
1:                 verifyUniqueColumnList(ddlStmt, cdn);
0: 
0:                 if (td == null)
0:                 {
0:                     // in CREATE TABLE so set PRIMARY KEY columns to NOT NULL
0:                     setColumnListToNotNull(cdn);
0:                 }
0:                 else
0:                 {
0:                     // in ALTER TABLE so raise error if any columns are nullable
0:                     checkForNullColumns(cdn, td);
0:                 }
0:             }
1:             else if (cdn.hasUniqueKeyConstraint())
0:             {
0:                 // for UNIQUE, check that columns are unique and NOT NULL
1:                 verifyUniqueColumnList(ddlStmt, cdn);
0:                 checkForNullColumns(cdn, td);
0:             }
1:             else if (cdn.hasForeignKeyConstraint())
0:             {
1:                 // for FOREIGN KEY, check that columns are unique
1:                 verifyUniqueColumnList(ddlStmt, cdn);
0:             }
/////////////////////////////////////////////////////////////////////////
0: 
0:     /**
/////////////////////////////////////////////////////////////////////////
1: 	 * Set all columns in that appear in a PRIMARY KEY constraint in a CREATE TABLE statement to NOT NULL.
1: 	 * @param cdn		The ConstraintDefinitionNode for a PRIMARY KEY constraint
1: 	private void setColumnListToNotNull(ConstraintDefinitionNode cdn)
0:             DataTypeDescriptor dtd = getColumnDataTypeDescriptor(colName);
0:             dtd.setNullability(false);
0:         }
1:     private void checkForNullColumns(ConstraintDefinitionNode cdn, TableDescriptor td) throws StandardException
0:     {
0:         ResultColumnList rcl = cdn.getColumnList();
0:         int rclSize = rcl.size();
0:         for (int index = 0; index < rclSize; index++)
0:         {
0:             String colName = ((ResultColumn) rcl.elementAt(index)).getName();
0:             DataTypeDescriptor dtd;
0:             if (td == null)
0:             {
0:                 dtd = getColumnDataTypeDescriptor(colName);
0:             }
0:             else
0:             {
0:                 dtd = getColumnDataTypeDescriptor(colName, td);
0:             }
1:             // todo dtd may be null if the column does not exist, we should check that first
1:             if (dtd != null && dtd.isNullable())
0:             {
0:                 throw StandardException.newException(SQLState.LANG_DB2_ADD_UNIQUE_OR_PRIMARY_KEY_ON_NULL_COLS, colName);
0:             }
0:         }
0:     }
1:     private DataTypeDescriptor getColumnDataTypeDescriptor(String colName)
0:     {
0:         int size = size();
0:         for (int index = 0; index < size; index++)
0:         {
0:             TableElementNode tableElement = (TableElementNode) elementAt(index);
0: 
0:             if (tableElement instanceof ColumnDefinitionNode)
0:             {
0:                 ColumnDefinitionNode cdn = (ColumnDefinitionNode) tableElement;
0:                 if (colName.equals(cdn.getColumnName()))
0:                 {
0:                     return cdn.getDataTypeServices();
0:                 }
0:             }
0:         }
1:         return null;
0:     }
0: 
1:     private DataTypeDescriptor getColumnDataTypeDescriptor(String colName, TableDescriptor td)
0:     {
1:         // check existing columns
0:         ColumnDescriptor cd = td.getColumnDescriptor(colName);
1:         if (cd != null)
0:         {
1:             return cd.getType();
0:         }
1:         // check for new columns
1:         return getColumnDataTypeDescriptor(colName);
0:     }
commit:72b444b
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	 * @param fromList		The FromList in question.
/////////////////////////////////////////////////////////////////////////
1: 	 * @param tableSd		The schema for that table.
1: 	 * @param dd	    	The DataDictionary
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package	org.apache.derby.impl.sql.compile;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.sql.compile.CompilerContext;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
0: 
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: 
0: import org.apache.derby.iapi.sql.dictionary.ConstraintDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
0: 
0: import org.apache.derby.iapi.sql.depend.DependencyManager;
0: import org.apache.derby.iapi.sql.depend.ProviderInfo;
0: import org.apache.derby.iapi.sql.depend.ProviderList;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.impl.sql.execute.ColumnInfo;
0: import org.apache.derby.impl.sql.execute.ConstraintInfo;
0: import org.apache.derby.impl.sql.execute.ConstraintConstantAction;
0: import org.apache.derby.impl.sql.execute.IndexConstantAction;
0: 
0: import	org.apache.derby.iapi.sql.dictionary.ConstraintDescriptorList;
0: 
0: import org.apache.derby.catalog.UUID;
0: 
0: import java.util.Hashtable;
0: import java.util.Vector;
0: 
0: /**
0:  * A TableElementList represents the list of columns and other table elements
0:  * such as constraints in a CREATE TABLE or ALTER TABLE statement.
0:  *
0:  * @author Jeff Lichtman
0:  */
0: 
0: public class TableElementList extends QueryTreeNodeVector
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	int				numColumns;
0: 	TableDescriptor td;
0: 
0: 	/**
0: 	 * Add a TableElementNode to this TableElementList
0: 	 *
0: 	 * @param tableElement	The TableElementNode to add to this list
0: 	 *
0: 	 * @return	Nothing
0: 	 */
0: 
0: 	public void addTableElement(TableElementNode tableElement)
0: 	{
0: 		addElement(tableElement);
0: 		if ((tableElement instanceof ColumnDefinitionNode) ||
0: 			tableElement.getElementType() == TableElementNode.AT_DROP_COLUMN)
0: 		{
0: 			numColumns++;
0: 		}
0: 	} 
0: 
0: 	/**
0: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
0: 	 * for how this should be done for tree printing.
0: 	 *
0: 	 * @return	This object as a String
0: 	 */
0: 
0: 	public String toString()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			StringBuffer	buffer = new StringBuffer("");
0: 
0: 			for (int index = 0; index < size(); index++)
0: 			{
0: 				buffer.append(elementAt(index).toString()).append("\n");
0: 			}
0: 
0: 			return buffer.toString();
0: 		}
0: 		else
0: 		{
0: 			return "";
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Validate this TableElementList.  This includes checking for
0: 	 * duplicate columns names, and checking that user types really exist.
0: 	 *
0: 	 * @param ddlStmt	DDLStatementNode which contains this list
0: 	 * @param dd		DataDictionary to use
0: 	 * @param td		TableDescriptor for table, if existing table.
0: 	 *
0: 	 * @return	None
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	void validate(DDLStatementNode ddlStmt,
0: 					     DataDictionary dd,
0: 						 TableDescriptor td)
0: 					throws StandardException
0: 	{
0:  		this.td = td;
0: 		int numAutoCols = 0;
0: 
0: 		int			size = size();
0: 		Hashtable	columnHT = new Hashtable(size + 2, (float) .999);
0: 		Hashtable	constraintHT = new Hashtable(size + 2, (float) .999);
0: 		//all the primary key/unique key constraints for this table
0: 		Vector constraintsVector = new Vector();
0: 
0: 		//special case for alter table (td is not null in case of alter table)
0: 		if (td != null)
0: 		{
0: 			//In case of alter table, get the already existing primary key and unique
0: 			//key constraints for this table. And then we will compare them with  new
0: 			//primary key/unique key constraint column lists.
0: 			ConstraintDescriptorList cdl = dd.getConstraintDescriptors(td);
0: 			ConstraintDescriptor cd;
0: 
0: 			if (cdl != null) //table does have some pre-existing constraints defined on it
0: 			{
0: 				for (int i=0; i<cdl.size();i++)
0: 				{
0: 					cd = cdl.elementAt(i);
0: 					//if the constraint type is not primary key or unique key, ignore it.
0: 					if (cd.getConstraintType() == DataDictionary.PRIMARYKEY_CONSTRAINT ||
0: 					cd.getConstraintType() == DataDictionary.UNIQUE_CONSTRAINT)
0: 						constraintsVector.addElement(cd);
0: 				}
0: 			}
0: 		}
0: 
0: 		int tableType = TableDescriptor.BASE_TABLE_TYPE;
0: 		if (ddlStmt instanceof CreateTableNode)
0: 			tableType = ((CreateTableNode)ddlStmt).tableType;
0: 
0: 		for (int index = 0; index < size; index++)
0: 		{
0: 			TableElementNode tableElement = (TableElementNode) elementAt(index);
0: 
0: 			if (tableElement instanceof ColumnDefinitionNode)
0: 			{
0: 				ColumnDefinitionNode cdn = (ColumnDefinitionNode) elementAt(index);
0: 				if (tableType == TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE &&
0: 					(cdn.getDataTypeServices().getTypeId().isLongConcatableTypeId() ||
0: 					cdn.getDataTypeServices().getTypeId().isUserDefinedTypeId()))
0: 				{
0: 					throw StandardException.newException(SQLState.LANG_LONG_DATA_TYPE_NOT_ALLOWED, cdn.getColumnName());
0: 				}
0: 				checkForDuplicateColumns(ddlStmt, columnHT, cdn.getColumnName());
0: 				cdn.checkUserType(td);
0: 				cdn.bindAndValidateDefault(dd, td);
0: 				
0: 				cdn.validateAutoincrement(dd, td, tableType);
0: 
0: 				if (tableElement instanceof ModifyColumnNode)
0: 				{
0: 					ModifyColumnNode mcdn = (ModifyColumnNode)cdn;
0: 					mcdn.checkExistingConstraints(td);
0: 				} else if (cdn.isAutoincrementColumn())
0: 					numAutoCols ++;
0: 			}
0: 			else if (tableElement.getElementType() == TableElementNode.AT_DROP_COLUMN)
0: 			{
0: 				String colName = tableElement.getName();
0: 				if (td.getColumnDescriptor(colName) == null)
0: 				{
0: 					throw StandardException.newException(
0: 												SQLState.LANG_COLUMN_NOT_FOUND_IN_TABLE,
0: 												colName,
0: 												td.getQualifiedName());
0: 				}
0: 				break;
0: 			}
0: 
0: 			/* The rest of this method deals with validating constraints */
0: 			if (! (tableElement.hasConstraint()))
0: 			{
0: 				continue;
0: 			}
0: 
0: 			ConstraintDefinitionNode cdn = (ConstraintDefinitionNode) tableElement;
0: 
0: 			cdn.bind(ddlStmt, dd);
0: 
0: 			//if constraint is primary key or unique key, add it to the vector
0: 			if (cdn.getConstraintType() == DataDictionary.PRIMARYKEY_CONSTRAINT ||
0: 			cdn.getConstraintType() == DataDictionary.UNIQUE_CONSTRAINT)
0: 			{
0: 				/* In case of create table, the vector can have only ConstraintDefinitionNode
0: 				* elements. In case of alter table, it can have both ConstraintDefinitionNode
0: 				* (for new constraints) and ConstraintDescriptor(for pre-existing constraints).
0: 				*/
0: 
0: 				Object destConstraint;
0: 				String destName = null;
0: 				String[] destColumnNames = null;
0: 
0: 				for (int i=0; i<constraintsVector.size();i++)
0: 				{
0: 
0: 					destConstraint = constraintsVector.elementAt(i);
0: 					if (destConstraint instanceof ConstraintDefinitionNode)
0: 					{
0: 						ConstraintDefinitionNode destCDN = (ConstraintDefinitionNode)destConstraint;
0: 						destName = destCDN.getConstraintMoniker();
0: 						destColumnNames = destCDN.getColumnList().getColumnNames();
0: 					}
0: 					else if (destConstraint instanceof ConstraintDescriptor)
0: 					{
0: 						//will come here only for pre-existing constraints in case of alter table
0: 						ConstraintDescriptor destCD = (ConstraintDescriptor)destConstraint;
0: 						destName = destCD.getConstraintName();
0: 						destColumnNames = destCD.getColumnDescriptors().getColumnNames();
0: 					}
0: 					//check if there are multiple constraints with same set of columns
0: 					if (columnsMatch(cdn.getColumnList().getColumnNames(), destColumnNames))
0: 						throw StandardException.newException(SQLState.LANG_MULTIPLE_CONSTRAINTS_WITH_SAME_COLUMNS,
0: 						cdn.getConstraintMoniker(), destName);
0: 				}
0: 				constraintsVector.addElement(cdn);
0: 			}
0: 
0: 			/* Make sure that there are no duplicate constraint names in the list */
0: 			if (cdn instanceof ConstraintDefinitionNode)
0: 				checkForDuplicateConstraintNames(ddlStmt, constraintHT, cdn.getConstraintMoniker());
0: 
0: 			/* Make sure that the constraint we are trying to drop exists */
0: 			if (cdn.getConstraintType() == DataDictionary.DROP_CONSTRAINT)
0: 			{
0: 				/*
0: 				** If no schema descriptor, then must be an invalid
0: 				** schema name.
0: 				*/
0: 
0: 				String dropConstraintName = cdn.getConstraintMoniker();
0: 
0: 				if (dropConstraintName != null) {
0: 
0: 					String dropSchemaName = cdn.getDropSchemaName();
0: 
0: 					SchemaDescriptor sd = dropSchemaName == null ? td.getSchemaDescriptor() : 
0: 											getSchemaDescriptor(dropSchemaName);
0: 
0: 					ConstraintDescriptor cd =
0: 								dd.getConstraintDescriptorByName(
0: 										td, sd, dropConstraintName,
0: 										false);
0: 					if (cd == null)
0: 					{
0: 						throw StandardException.newException(SQLState.LANG_DROP_NON_EXISTENT_CONSTRAINT,
0: 								(sd.getSchemaName() + "."+ dropConstraintName),
0: 								td.getQualifiedName());
0: 					}
0: 					/* Statement is dependendent on the ConstraintDescriptor */
0: 					getCompilerContext().createDependency(cd);
0: 				}
0: 			}
0: 
0: 			/* For primary/unique/unique keys, verify that the constraint's column
0: 			 * list contains valid columns and does not contain any duplicates
0: 			 * (Also, all columns in a primary key will be set to non-null,
0: 				but only in Cloudscape mode. SQL and DB2 require explict NOT NULL.
0: 			 */
0: 			if (cdn.hasPrimaryKeyConstraint() ||
0: 				cdn.hasForeignKeyConstraint() ||
0: 				cdn.hasUniqueKeyConstraint())
0: 			{
0: 				verifyUniqueColumnList(ddlStmt, cdn);
0: 				/* Raise error if primary or unique key columns can be nullable. */
0: 				if (cdn.hasPrimaryKeyConstraint() || cdn.hasUniqueKeyConstraint())
0: 				{
0: 					setColumnListToNotNull(cdn, td);
0: 				}
0: 			}
0: 		}
0: 
0: 		/* Can have only one autoincrement column in DB2 mode */
0: 		if (numAutoCols > 1)
0: 			throw StandardException.newException(SQLState.LANG_MULTIPLE_AUTOINCREMENT_COLUMNS);
0: 
0: 	}
0: 	
0: 	/**
0: 	 * Count the number of constraints of the specified type.
0: 	 *
0: 	 * @param constraintType	The constraint type to search for.
0: 	 *
0: 	 * @return int	The number of constraints of the specified type.
0: 	 */
0: 	public int countConstraints(int constraintType)
0: 	{
0: 		int	numConstraints = 0;
0: 		int size = size();
0: 
0: 		for (int index = 0; index < size; index++)
0: 		{
0: 			ConstraintDefinitionNode cdn;
0: 			TableElementNode element = (TableElementNode) elementAt(index);
0: 
0: 			if (! (element instanceof ConstraintDefinitionNode))
0: 			{
0: 				continue;
0: 			}
0: 
0: 			cdn = (ConstraintDefinitionNode) element;
0: 
0: 			if (constraintType == cdn.getConstraintType())
0: 			{
0: 				numConstraints++;
0: 			}
0: 		}
0: 
0: 		return numConstraints;
0: 	}
0: 
0: 	/**
0: 	 * Count the number of columns.
0: 	 *
0: 	 * @return int	The number of columns.
0: 	 */
0: 	public int countNumberOfColumns()
0: 	{
0: 		return numColumns;
0: 	}
0: 
0: 	/**
0: 	 * Fill in the ColumnInfo[] for this table element list.
0: 	 * 
0: 	 * @param colInfos	The ColumnInfo[] to be filled in.
0: 	 *
0: 	 * @return int		The number of constraints in the create table.
0: 	 */
0: 	public int genColumnInfos(ColumnInfo[] colInfos)
0: 	{
0: 		int	numConstraints = 0;
0: 		int size = size();
0: 
0: 		for (int index = 0; index < size; index++)
0: 		{
0: 			if (((TableElementNode) elementAt(index)).getElementType() == TableElementNode.AT_DROP_COLUMN)
0: 			{
0: 				colInfos[index] = new ColumnInfo(
0: 								((TableElementNode) elementAt(index)).getName(),
0: 								null, null, null, null, null,
0: 								ColumnInfo.DROP, 0, 0);
0: 				break;
0: 			}
0: 
0: 			if (! (elementAt(index) instanceof ColumnDefinitionNode))
0: 			{
0: 				if (SanityManager.DEBUG)
0: 				{
0: 					SanityManager.ASSERT( elementAt(index) instanceof ConstraintDefinitionNode,
0: 						"elementAt(index) expected to be instanceof " +
0: 						"ConstraintDefinitionNode");
0: 				}
0: 
0: 				/* Remember how many constraints that we've seen */
0: 				numConstraints++;
0: 				continue;
0: 			}
0: 
0: 			ColumnDefinitionNode coldef = (ColumnDefinitionNode) elementAt(index);
0: 
0: 			colInfos[index - numConstraints] = 
0: 				new ColumnInfo(coldef.getColumnName(),
0: 							   coldef.getDataTypeServices(),
0: 							   coldef.getDefaultValue(),
0: 							   coldef.getDefaultInfo(),
0: 							   (UUID) null,
0: 							   coldef.getOldDefaultUUID(),
0: 							   coldef.getAction(),
0: 							   (coldef.isAutoincrementColumn() ? 
0: 								coldef.getAutoincrementStart() : 0),
0: 							   (coldef.isAutoincrementColumn() ? 
0: 								coldef.getAutoincrementIncrement() : 0));
0: 
0: 			/* Remember how many constraints that we've seen */
0: 			if (coldef.hasConstraint())
0: 			{
0: 				numConstraints++;
0: 			}
0: 		}
0: 
0: 		return numConstraints;
0: 	}
0: 	/**
0: 	 * Append goobered up ResultColumns to the table's RCL.
0: 	 * This is useful for binding check constraints for CREATE and ALTER TABLE.
0: 	 *
0: 	 * @param table		The table in question.
0: 	 *
0: 	 * @return Nothing.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void appendNewColumnsToRCL(FromBaseTable table)
0: 		throws StandardException
0: 	{
0: 		int				 size = size();
0: 		ResultColumnList rcl = table.getResultColumns();
0: 		TableName		 exposedName = table.getTableName();
0: 
0: 		for (int index = 0; index < size; index++)
0: 		{
0: 			if (elementAt(index) instanceof ColumnDefinitionNode)
0: 			{
0: 				ColumnDefinitionNode cdn = (ColumnDefinitionNode) elementAt(index);
0: 				ResultColumn	resultColumn;
0: 				ValueNode		valueNode;
0: 
0: 				/* Build a ResultColumn/BaseColumnNode pair for the column */
0: 				valueNode = (ValueNode) getNodeFactory().getNode(
0: 											C_NodeTypes.BASE_COLUMN_NODE,
0: 											cdn.getColumnName(),
0: 									  		exposedName,
0: 											cdn.getDataTypeServices(),
0: 											getContextManager());
0: 
0: 				resultColumn = (ResultColumn) getNodeFactory().getNode(
0: 												C_NodeTypes.RESULT_COLUMN,
0: 												cdn.getDataTypeServices(), 
0: 												valueNode,
0: 												getContextManager());
0: 				resultColumn.setName(cdn.getColumnName());
0: 				rcl.addElement(resultColumn);
0: 			}
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Bind and validate all of the check constraints in this list against
0: 	 * the specified FromList.  
0: 	 *
0: 	 * @param FromList		The FromList in question.
0: 	 *
0: 	 * @return Nothing.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	void bindAndValidateCheckConstraints(FromList fromList)
0: 		throws StandardException
0: 	{
0: 		CompilerContext cc;
0: 		FromBaseTable				table = (FromBaseTable) fromList.elementAt(0);
0: 		int						  size = size();
0: 
0: 		cc = getCompilerContext();
0: 
0: 		Vector aggregateVector = new Vector();
0: 
0: 		for (int index = 0; index < size; index++)
0: 		{
0: 			ConstraintDefinitionNode cdn;
0: 			TableElementNode element = (TableElementNode) elementAt(index);
0: 			ValueNode	checkTree;
0: 
0: 			if (! (element instanceof ConstraintDefinitionNode))
0: 			{
0: 				continue;
0: 			}
0: 
0: 			cdn = (ConstraintDefinitionNode) element;
0: 
0: 			if (cdn.getConstraintType() != DataDictionary.CHECK_CONSTRAINT)
0: 			{
0: 				continue;
0: 			}
0: 
0: 			checkTree = cdn.getCheckCondition();
0: 
0: 			// bind the check condition
0: 			// verify that it evaluates to a boolean
0: 			final int previousReliability = cc.getReliability();
0: 			try
0: 			{
0: 				/* Each check constraint can have its own set of dependencies.
0: 				 * These dependencies need to be shared with the prepared
0: 				 * statement as well.  We create a new auxiliary provider list
0: 				 * for the check constraint, "push" it on the compiler context
0: 				 * by swapping it with the current auxiliary provider list
0: 				 * and the "pop" it when we're done by restoring the old 
0: 				 * auxiliary provider list.
0: 				 */
0: 				ProviderList apl = new ProviderList();
0: 
0: 				ProviderList prevAPL = cc.getCurrentAuxiliaryProviderList();
0: 				cc.setCurrentAuxiliaryProviderList(apl);
0: 
0: 				// Tell the compiler context to only allow deterministic nodes
0: 				cc.setReliability( CompilerContext.CHECK_CONSTRAINT );
0: 				checkTree = checkTree.bindExpression(fromList, (SubqueryList) null,
0: 										 aggregateVector);
0: 
0: 				// no aggregates, please
0: 				if (aggregateVector.size() != 0)
0: 				{
0: 					throw StandardException.newException(SQLState.LANG_INVALID_CHECK_CONSTRAINT, cdn.getConstraintText());
0: 				}
0: 				
0: 				checkTree = checkTree.checkIsBoolean();
0: 				cdn.setCheckCondition(checkTree);
0: 
0: 				/* Save the APL off in the constraint node */
0: 				if (apl.size() > 0)
0: 				{
0: 					cdn.setAuxiliaryProviderList(apl);
0: 				}
0: 
0: 				// Restore the previous AuxiliaryProviderList
0: 				cc.setCurrentAuxiliaryProviderList(prevAPL);
0: 			}
0: 			finally
0: 			{
0: 				cc.setReliability(previousReliability);
0: 			}
0: 	
0: 			/* We have a valid check constraint, now build an array of
0: 			 * 1-based columnIds that the constraint references.
0: 			 */
0: 			ResultColumnList rcl = table.getResultColumns();
0: 			int		numReferenced = rcl.countReferencedColumns();
0: 			int[]	checkColumnReferences = new int[numReferenced];
0: 
0: 			rcl.recordColumnReferences(checkColumnReferences, 1);
0: 			cdn.setCheckColumnReferences(checkColumnReferences);
0: 
0: 			/* Now we build a list with only the referenced columns and
0: 			 * copy it to the cdn.  Thus we can build the array of
0: 			 * column names for the referenced columns during generate().
0: 			 */
0: 			ResultColumnList refRCL =
0: 						(ResultColumnList) getNodeFactory().getNode(
0: 												C_NodeTypes.RESULT_COLUMN_LIST,
0: 												getContextManager());
0: 			rcl.copyReferencedColumnsToNewList(refRCL);
0: 
0: 			/* A column check constraint can only refer to that column. If this is a
0: 			 * column constraint, we should have an RCL with that column
0: 			 */
0: 			if (cdn.getColumnList() != null)
0: 			{
0: 				String colName = ((ResultColumn)(cdn.getColumnList().elementAt(0))).getName();
0: 				if (numReferenced > 1 ||
0: 					!colName.equals(((ResultColumn)(refRCL.elementAt(0))).getName()))
0: 					throw StandardException.newException(SQLState.LANG_DB2_INVALID_CHECK_CONSTRAINT, colName);
0: 				
0: 			}
0: 			cdn.setColumnList(refRCL);
0: 
0: 			/* Clear the column references in the RCL so each check constraint
0: 			 * starts with a clean list.
0: 			 */
0: 			rcl.clearColumnReferences();
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Fill in the ConstraintConstantAction[] for this create/alter table.
0: 	 * 
0: 	 * @param conActions	The ConstraintConstantAction[] to be filled in.
0: 	 * @param tableName		The name of the Table being created.
0: 	 * @param sd			The schema for that table.
0: 	 * @param dd		The DataDictionary
0: 	 *
0: 	 * @return Nothing.
0: 	 *
0: 	 * @exception StandardException		Thrown on failure
0: 	 */
0: 	void genConstraintActions(
0: 				ConstraintConstantAction[] conActions,
0: 				String tableName,
0: 				SchemaDescriptor tableSd,
0: 				DataDictionary dd)
0: 		throws StandardException
0: 	{
0: 		int size = size();
0: 		int conActionIndex = 0;
0: 		for (int index = 0; index < size; index++)
0: 		{
0: 			String[]	columnNames = null;
0: 			String		generatedConstraintName;
0: 			TableElementNode ten = (TableElementNode) elementAt(index);
0: 			IndexConstantAction indexAction = null;
0: 
0: 			if (! ten.hasConstraint())
0: 			{
0: 				continue;
0: 			}
0: 
0: 			if (ten instanceof ColumnDefinitionNode)
0: 			{
0: 				continue;
0: 			}
0: 
0: 			ConstraintDefinitionNode constraintDN = (ConstraintDefinitionNode) ten;
0: 
0: 			if (constraintDN.getColumnList() != null)
0: 			{
0: 				columnNames = new String[constraintDN.getColumnList().size()];
0: 				constraintDN.getColumnList().exportNames(columnNames);
0: 			}
0: 
0: 			int constraintType = constraintDN.getConstraintType();
0: 			String constraintText = constraintDN.getConstraintText();
0: 
0: 			/*
0: 			** If the constraint is not named (e.g.
0: 			** create table x (x int primary key)), then
0: 			** the constraintSd is the same as the table.
0: 			*/
0: 			String constraintName = constraintDN.getConstraintMoniker();
0: 
0: 			/* At execution time, we will generate a unique name for the backing
0: 			 * index (for CREATE CONSTRAINT) and we will look up the conglomerate
0: 			 * name (for DROP CONSTRAINT).
0: 			 */
0: 			if (constraintDN.requiresBackingIndex())
0: 			{
0: 				indexAction = genIndexAction(constraintDN.requiresUniqueIndex(),
0: 											 null, constraintDN, 
0: 											 columnNames, true, tableSd, tableName,
0: 											 constraintType, dd);
0: 			}
0: 
0: 			if (constraintType == DataDictionary.DROP_CONSTRAINT)
0: 			{
0: 				conActions[conActionIndex] = 
0: 					getGenericConstantActionFactory().
0: 						getDropConstraintConstantAction(
0: 												 constraintName, 
0: 												 constraintDN.getDropSchemaName(), /// FiX
0: 												 tableName,
0: 												 td.getUUID(),
0: 												 tableSd.getSchemaName(),
0: 												 indexAction,
0: 												 constraintDN.getDropBehavior(),
0:                                                  constraintDN.getVerifyType());
0: 			}
0: 			else
0: 			{
0: 				ProviderList apl = constraintDN.getAuxiliaryProviderList();
0: 				ConstraintInfo refInfo = null;
0: 				ProviderInfo[]	providerInfos = null;
0: 
0: 				if (constraintDN instanceof FKConstraintDefinitionNode)
0: 				{
0: 					refInfo = ((FKConstraintDefinitionNode)constraintDN).getReferencedConstraintInfo();
0: 				}				
0: 
0: 				/* Create the ProviderInfos, if the constraint is dependent on any Providers */
0: 				if (apl != null && apl.size() > 0)
0: 				{
0: 					/* Get all the dependencies for the current statement and transfer
0: 					 * them to this view.
0: 					 */
0: 					DependencyManager dm = dd.getDependencyManager();
0: 					providerInfos = dm.getPersistentProviderInfos(apl);
0: 				}
0: 				else
0: 				{
0: 					providerInfos = new ProviderInfo[0];
0: 				}
0: 
0: 				conActions[conActionIndex++] = 
0: 					getGenericConstantActionFactory().
0: 						getCreateConstraintConstantAction(
0: 												 constraintName, 
0: 											     constraintType,
0: 												 tableName,
0: 												 ((td != null) ? td.getUUID() : (UUID) null),
0: 												 tableSd.getSchemaName(),
0: 												 columnNames,
0: 												 indexAction,
0: 												 constraintText,
0: 												 true, 		// enabled
0: 												 refInfo,
0: 												 providerInfos);
0: 			}
0: 		}
0: 	}
0: 
0:       //check if one array is same as another 
0: 	private boolean columnsMatch(String[] columnNames1, String[] columnNames2)
0: 		throws StandardException
0: 	{
0: 		int srcCount, srcSize, destCount,destSize;
0: 		boolean match = true;
0: 
0: 		if (columnNames1.length != columnNames2.length)
0: 			return false;
0: 
0: 		srcSize = columnNames1.length;
0: 		destSize = columnNames2.length;
0: 
0: 		for (srcCount = 0; srcCount < srcSize; srcCount++)
0: 		{
0: 			match = false;
0: 			for (destCount = 0; destCount < destSize; destCount++) {
0: 				if (columnNames1[srcCount].equals(columnNames2[destCount])) {
0: 					match = true;
0: 					break;
0: 				}
0: 			}
0: 			if (match == false)
0: 				return false;
0: 		}
0: 
0: 		return true;
0: 	}
0: 
0: 	private IndexConstantAction genIndexAction(
0: 										boolean	isUnique,
0: 										String indexName,
0: 										ConstraintDefinitionNode cdn,
0: 										String[] columnNames,
0: 										boolean isConstraint,
0: 										SchemaDescriptor sd,
0: 										String tableName,
0: 										int constraintType,
0: 										DataDictionary dd)
0: 		throws StandardException
0: 	{
0: 		if ( indexName == null ) { indexName = cdn.getBackingIndexName(dd); }
0: 
0: 		if (constraintType == DataDictionary.DROP_CONSTRAINT)
0: 		{
0: 			return	getGenericConstantActionFactory().getDropIndexConstantAction(
0: 									  null,
0: 									  indexName,
0: 									  tableName,
0: 									  sd.getSchemaName(),
0: 									  td.getUUID(),
0: 									  td.getHeapConglomerateId());
0: 		}
0: 		else
0: 		{
0: 			boolean[]	isAscending = new boolean[columnNames.length];
0: 			for (int i = 0; i < isAscending.length; i++)
0: 				isAscending[i] = true;
0: 			return	getGenericConstantActionFactory().getCreateIndexConstantAction(
0: 									isUnique,
0: 									"BTREE", // indexType
0: 									sd.getSchemaName(),
0: 									indexName,
0: 									tableName,
0: 									((td != null) ? td.getUUID() : (UUID) null),
0: 									0, // conglomId
0: 									columnNames,
0: 									isAscending,
0: 									isConstraint,
0: 									cdn.getBackingIndexUUID(),
0: 									cdn.getProperties());
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Check to make sure that there are no duplicate column names
0: 	 * in the list.  (The comparison here is case sensitive.
0: 	 * The work of converting column names that are not quoted
0: 	 * identifiers to upper case is handled by the parser.)
0: 	 * RESOLVE: This check will also be performed by alter table.
0: 	 *
0: 	 * @param ddlStmt	DDLStatementNode which contains this list
0: 	 * @param ht		Hashtable for enforcing uniqueness.
0: 	 * @param colName	Column name to check for.
0: 	 *
0: 	 * @return	None
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	private void checkForDuplicateColumns(DDLStatementNode ddlStmt,
0: 									Hashtable ht,
0: 									String colName)
0: 			throws StandardException
0: 	{
0: 		Object object = ht.put(colName, colName);
0: 		if (object != null)
0: 		{
0: 			/* RESOLVE - different error messages for create and alter table */
0: 			if (ddlStmt instanceof CreateTableNode)
0: 			{
0: 				throw StandardException.newException(SQLState.LANG_DUPLICATE_COLUMN_NAME_CREATE, colName);
0: 			}
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Check to make sure that there are no duplicate constraint names
0: 	 * in the list.  (The comparison here is case sensitive.
0: 	 * The work of converting column names that are not quoted
0: 	 * identifiers to upper case is handled by the parser.)
0: 	 * RESOLVE: This check will also be performed by alter table.
0: 	 *
0: 	 * @param ddlStmt	DDLStatementNode which contains this list
0: 	 * @param outer		The element to check against.  Only check
0: 	 *						TableElements that come after this one, since this
0: 	 *						one has been checked against the TableElements
0: 	 *						before it.
0: 	 *
0: 	 * @return	None
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	private void checkForDuplicateConstraintNames(DDLStatementNode ddlStmt,
0: 									Hashtable ht,
0: 									String constraintName)
0: 			throws StandardException
0: 	{
0: 		if (constraintName == null)
0: 			return;
0: 
0: 		Object object = ht.put(constraintName, constraintName);
0: 		if (object != null) {
0: 
0: 			/* RESOLVE - different error messages for create and alter table */
0: 			if (ddlStmt instanceof CreateTableNode)
0: 			{
0: 				/* RESOLVE - new error message */
0: 				throw StandardException.newException(SQLState.LANG_DUPLICATE_CONSTRAINT_NAME_CREATE, 
0: 						constraintName);
0: 			}
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Verify that a primary/unique table constraint has a valid column list.
0: 	 * (All columns in table and no duplicates.)
0: 	 *
0: 	 * @param ddlStmt	The outer DDLStatementNode
0: 	 * @param cdn		The ConstraintDefinitionNode
0: 	 *
0: 	 * @return Nothing.
0: 	 *
0: 	 * @exception	StandardException	Thrown if the column list is invalid
0: 	 */
0: 	private void verifyUniqueColumnList(DDLStatementNode ddlStmt,
0: 								ConstraintDefinitionNode cdn)
0: 		throws StandardException
0: 	{
0: 		String invalidColName;
0: 
0: 		/* Verify that every column in the list appears in the table's list of columns */
0: 		if (ddlStmt instanceof CreateTableNode)
0: 		{
0: 			invalidColName = cdn.getColumnList().verifyCreateConstraintColumnList(this);
0: 			if (invalidColName != null)
0: 			{
0: 				throw StandardException.newException(SQLState.LANG_INVALID_CREATE_CONSTRAINT_COLUMN_LIST, 
0: 								ddlStmt.getRelativeName(),
0: 								invalidColName);
0: 			}
0: 		}
0: 		else
0: 		{
0: 			/* RESOLVE - alter table will need to get table descriptor */
0: 		}
0: 
0: 		/* Check the uniqueness of the column names within the list */
0: 		invalidColName = cdn.getColumnList().verifyUniqueNames(false);
0: 		if (invalidColName != null)
0: 		{
0: 			throw StandardException.newException(SQLState.LANG_DUPLICATE_CONSTRAINT_COLUMN_NAME, invalidColName);
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Set all columns in that appear in a primary/unique key constraint in a create
0: 	 * table statement to NOT NULL in Cloudscape mode and raises an error in DB2 mode.
0: 	 *
0: 	 * @param cdn		The ConstraintDefinitionNode
0: 	 * @param td		TableDescriptor for the table
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	private void setColumnListToNotNull(ConstraintDefinitionNode cdn, TableDescriptor td)
0: 		throws StandardException
0: 	{
0: 		ResultColumnList rcl = cdn.getColumnList();
0: 		int rclSize = rcl.size();
0: 		for (int index = 0; index < rclSize; index++)
0: 		{
0: 			String colName = ((ResultColumn) rcl.elementAt(index)).getName();
0: 
0: 			/* For ALTER TABLE ADD CONSTRAINT, make sure columns are not nullable for
0: 			 * primary and unique constraints.
0: 			 */
0: 			if (td != null && cdn instanceof ConstraintDefinitionNode)
0: 			{
0: 				ColumnDescriptor cd = td.getColumnDescriptor(colName);
0: 				if (cd != null && cd.getType().isNullable())
0: 					throw StandardException.newException(SQLState.LANG_DB2_ADD_UNIQUE_OR_PRIMARY_KEY_ON_NULL_COLS, colName);
0: 			}
0: 
0: 			setColumnToNotNull(colName);
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Set a column that appears in a primary/unique key constraint in
0: 	 * a create table statement to NOT NULL (but only in Cloudscape mode).
0: 	 *
0: 	 * @param colName	The column name
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	private void setColumnToNotNull(String colName) throws StandardException
0: 	{
0: 		int size = size();
0: 
0: 		for (int index = 0; index < size; index++)
0: 		{
0: 			TableElementNode tableElement = (TableElementNode) elementAt(index);
0: 
0: 			if (tableElement instanceof ColumnDefinitionNode)
0: 			{
0: 				ColumnDefinitionNode cdn = (ColumnDefinitionNode) tableElement;
0: 				if (colName.equals(cdn.getColumnName()))
0: 				{
0: 					DataTypeDescriptor dtd = cdn.getDataTypeServices();
0: 
0: 					if (dtd.isNullable())
0: 						throw StandardException.newException(SQLState.LANG_DB2_ADD_UNIQUE_OR_PRIMARY_KEY_ON_NULL_COLS, colName);
0: 				}
0: 			}
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Determine whether or not the parameter matches a column name in this list.
0: 	 *
0: 	 * @param colName	The column name to search for.
0: 	 *
0: 	 * @return boolean  Whether or not a match is found.
0: 	 */
0: 	public boolean containsColumnName(String colName)
0: 	{
0: 		int size = size();
0: 		for (int index = 0; index < size; index++)
0: 		{
0: 			TableElementNode tableElement = (TableElementNode) elementAt(index);
0: 
0: 			if (tableElement instanceof ColumnDefinitionNode)
0: 			{
0: 				if (colName.equals(((ColumnDefinitionNode) tableElement).getName()))
0: 				{
0: 					return true;
0: 				}
0: 			}
0: 		}
0: 
0: 		return false;
0: 	}
0: }
0: 
============================================================================